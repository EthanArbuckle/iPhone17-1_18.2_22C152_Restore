unint64_t llvm::sampleprof::SampleProfileWriterCompactBinary::write(llvm::sampleprof::SampleProfileWriterCompactBinary *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;

  v3 = llvm::sampleprof::SampleProfileWriter::write((uint64_t)a1, a2);
  if (v3 || (v3 = llvm::sampleprof::SampleProfileWriterCompactBinary::writeFuncOffsetTable(a1), v3))
  {
    v4 = v3 & 0xFFFFFFFF00000000;
  }
  else
  {
    llvm::sampleprof_category((llvm *)v3);
    v4 = 0;
    LODWORD(v3) = 0;
  }
  return v3 | v4;
}

unint64_t llvm::sampleprof::SampleProfileWriterCompactBinary::writeFuncOffsetTable(llvm::sampleprof::SampleProfileWriterCompactBinary *this)
{
  v2 = (llvm::raw_fd_ostream *)*((void *)this + 1);
  uint64_t v3 = (*(uint64_t (**)(llvm::raw_fd_ostream *))(*(void *)v2 + 80))(v2);
  uint64_t v4 = *((void *)v2 + 4);
  uint64_t v5 = *((void *)v2 + 2);
  off_t v6 = llvm::raw_fd_ostream::seek(v2, *((void *)this + 16));
  if (v6 == -1
    || (off_t v7 = v4 - v5 + v3,
        v8 = (llvm::raw_ostream *)*((void *)this + 1),
        *(void *)v21 = v7,
        llvm::raw_ostream::write(v8, v21, 8uLL),
        off_t v6 = llvm::raw_fd_ostream::seek(v2, v7),
        v6 == -1))
  {
    llvm::sampleprof_category((llvm *)v6);
    unint64_t v19 = 0;
    uint64_t v16 = 11;
  }
  else
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 14) - *((void *)this + 13)) >> 3);
    do
    {
      char v10 = v9 & 0x7F | ((v9 > 0x7F) << 7);
      v11 = (char *)*((void *)v2 + 4);
      if ((unint64_t)v11 >= *((void *)v2 + 3))
      {
        off_t v6 = (off_t)llvm::raw_ostream::write(v2, v10);
      }
      else
      {
        *((void *)v2 + 4) = v11 + 1;
        char *v11 = v10;
      }
      BOOL v12 = v9 > 0x7F;
      v9 >>= 7;
    }
    while (v12);
    uint64_t v13 = *((void *)this + 13);
    uint64_t v14 = *((void *)this + 14);
    while (1)
    {
      if (v13 == v14)
      {
        llvm::sampleprof_category((llvm *)v6);
        uint64_t v16 = 0;
        unint64_t v19 = 0;
        return v19 | v16;
      }
      unint64_t v15 = *(void *)(v13 + 16);
      off_t v6 = llvm::sampleprof::SampleProfileWriterBinary::writeNameIdx(this, *(const void **)v13, *(const void **)(v13 + 8));
      uint64_t v16 = v6;
      if (v6) {
        break;
      }
      do
      {
        char v17 = v15 & 0x7F | ((v15 > 0x7F) << 7);
        v18 = (char *)*((void *)v2 + 4);
        if ((unint64_t)v18 >= *((void *)v2 + 3))
        {
          off_t v6 = (off_t)llvm::raw_ostream::write(v2, v17);
        }
        else
        {
          *((void *)v2 + 4) = v18 + 1;
          char *v18 = v17;
        }
        BOOL v12 = v15 > 0x7F;
        v15 >>= 7;
      }
      while (v12);
      v13 += 24;
    }
    unint64_t v19 = v6 & 0xFFFFFFFF00000000;
  }
  return v19 | v16;
}

unint64_t llvm::sampleprof::SampleProfileWriterText::writeSample(llvm::sampleprof::SampleProfileWriterText *this, const llvm::sampleprof::FunctionSamples *a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (llvm::raw_ostream *)*((void *)this + 1);
  if (llvm::sampleprof::FunctionSamples::ProfileIsCSFlat)
  {
    off_t v7 = (unsigned char *)*((void *)v3 + 4);
    if (*((unsigned char **)v3 + 3) == v7)
    {
      llvm::raw_ostream::write(*((llvm::raw_ostream **)this + 1), "[", 1uLL);
    }
    else
    {
      *off_t v7 = 91;
      ++*((void *)v3 + 4);
    }
    sub_1CCCF56CC((void *)a2 + 2, (uint64_t)&__p);
    if (v58 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v58 >= 0) {
      size_t v9 = HIBYTE(v58) & 0x7F;
    }
    else {
      size_t v9 = v57;
    }
    llvm::raw_ostream::write(v3, p_p, v9);
    char v10 = (_WORD *)*((void *)v3 + 4);
    if (*((void *)v3 + 3) - (void)v10 > 1uLL)
    {
      *char v10 = 14941;
      *((void *)v3 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v3, "]:", 2uLL);
    }
    sub_1CD098D14(v3, *((void *)a2 + 7), 0, 0, 0);
    if (SHIBYTE(v58) < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v4 = (const void *)*((void *)a2 + 2);
    unint64_t v5 = *((void *)a2 + 3);
    off_t v6 = (unsigned char *)*((void *)v3 + 4);
    if (v5 <= *((void *)v3 + 3) - (void)v6)
    {
      if (v5)
      {
        memcpy(v6, v4, *((void *)a2 + 3));
        off_t v6 = (unsigned char *)(*((void *)v3 + 4) + v5);
        *((void *)v3 + 4) = v6;
      }
    }
    else
    {
      llvm::raw_ostream::write(v3, (const char *)v4, *((void *)a2 + 3));
      off_t v6 = (unsigned char *)*((void *)v3 + 4);
    }
    if (*((unsigned char **)v3 + 3) == v6)
    {
      llvm::raw_ostream::write(v3, ":", 1uLL);
    }
    else
    {
      *off_t v6 = 58;
      ++*((void *)v3 + 4);
    }
    sub_1CD098D14(v3, *((void *)a2 + 7), 0, 0, 0);
  }
  if (!*((_DWORD *)this + 7))
  {
    v11 = (unsigned char *)*((void *)v3 + 4);
    if (*((unsigned char **)v3 + 3) == v11)
    {
      llvm::raw_ostream::write(v3, ":", 1uLL);
    }
    else
    {
      unsigned char *v11 = 58;
      ++*((void *)v3 + 4);
    }
    sub_1CD098D14(v3, *((void *)a2 + 8), 0, 0, 0);
  }
  BOOL v12 = (unsigned char *)*((void *)v3 + 4);
  if (*((unsigned char **)v3 + 3) == v12)
  {
    llvm::raw_ostream::write(v3, "\n", 1uLL);
  }
  else
  {
    *BOOL v12 = 10;
    ++*((void *)v3 + 4);
  }
  v50 = a2;
  sub_1CD752784((uint64_t)&__p, (void *)a2 + 9);
  if (v57)
  {
    v35 = (unsigned int **)__p;
    v51 = (unsigned int **)((char *)__p + 8 * v57);
    do
    {
      uint64_t v36 = (uint64_t)*v35;
      unint64_t v38 = **v35;
      unint64_t v37 = (*v35)[1];
      v39 = llvm::raw_ostream::indent(v3, *((_DWORD *)this + 7) + 1);
      sub_1CD098D14(v39, v38, 0, 0, 0);
      v41 = (unsigned char *)*((void *)v3 + 3);
      v40 = (unsigned char *)*((void *)v3 + 4);
      if (v37)
      {
        if (v41 == v40)
        {
          llvm::raw_ostream::write(v3, ".", 1uLL);
        }
        else
        {
          unsigned char *v40 = 46;
          ++*((void *)v3 + 4);
        }
        sub_1CD098D14(v3, v37, 0, 0, 0);
        v41 = (unsigned char *)*((void *)v3 + 3);
        v40 = (unsigned char *)*((void *)v3 + 4);
      }
      if ((unint64_t)(v41 - v40) > 1)
      {
        *(_WORD *)v40 = 8250;
        *((void *)v3 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v3, ": ", 2uLL);
      }
      sub_1CD098D14(v3, *(void *)(v36 + 8), 0, 0, 0);
      sub_1CD68327C((uint64_t *)(v36 + 16), &v53);
      v42 = v53;
      if (v53 != &v54)
      {
        do
        {
          v44 = (unsigned char *)*((void *)v3 + 4);
          if (*((unsigned char **)v3 + 3) == v44)
          {
            llvm::raw_ostream::write(v3, " ", 1uLL);
            v45 = (unsigned char *)*((void *)v3 + 4);
          }
          else
          {
            unsigned char *v44 = 32;
            v45 = (unsigned char *)(*((void *)v3 + 4) + 1);
            *((void *)v3 + 4) = v45;
          }
          v46 = (const void *)v42[4];
          unint64_t v47 = v42[5];
          if (v47 <= *((void *)v3 + 3) - (void)v45)
          {
            if (v47)
            {
              memcpy(v45, v46, v42[5]);
              v45 = (unsigned char *)(*((void *)v3 + 4) + v47);
              *((void *)v3 + 4) = v45;
            }
          }
          else
          {
            llvm::raw_ostream::write(v3, (const char *)v46, v42[5]);
            v45 = (unsigned char *)*((void *)v3 + 4);
          }
          if (*((unsigned char **)v3 + 3) == v45)
          {
            llvm::raw_ostream::write(v3, ":", 1uLL);
          }
          else
          {
            unsigned char *v45 = 58;
            ++*((void *)v3 + 4);
          }
          sub_1CD098D14(v3, v42[6], 0, 0, 0);
          v48 = (void *)v42[1];
          if (v48)
          {
            do
            {
              v49 = (void **)v48;
              v48 = (void *)*v48;
            }
            while (v48);
          }
          else
          {
            do
            {
              v49 = (void **)v42[2];
              BOOL v28 = *v49 == v42;
              v42 = v49;
            }
            while (!v28);
          }
          v42 = v49;
        }
        while (v49 != &v54);
      }
      sub_1CB833A08((uint64_t)&v53, v54);
      v43 = (unsigned char *)*((void *)v3 + 4);
      if (*((unsigned char **)v3 + 3) == v43)
      {
        llvm::raw_ostream::write(v3, "\n", 1uLL);
      }
      else
      {
        unsigned char *v43 = 10;
        ++*((void *)v3 + 4);
      }
      ++v35;
    }
    while (v35 != v51);
  }
  uint64_t v13 = v50;
  uint64_t v14 = sub_1CD752BB8((uint64_t)&v53, (void *)v50 + 12);
  unsigned int v15 = *((_DWORD *)this + 7) + 1;
  *((_DWORD *)this + 7) = v15;
  if (v54)
  {
    uint64_t v16 = (unsigned int **)v53;
    char v17 = (unsigned int **)((char *)v53 + 8 * v54);
    while (1)
    {
      v18 = (void *)*((void *)*v16 + 1);
      uint64_t v19 = (uint64_t)(*v16 + 4);
      if (v18 != (void *)v19) {
        break;
      }
LABEL_47:
      if (++v16 == v17)
      {
        unsigned int v15 = *((_DWORD *)this + 7);
        uint64_t v13 = v50;
        goto LABEL_49;
      }
    }
    while (1)
    {
      unint64_t v21 = **v16;
      unint64_t v20 = (*v16)[1];
      v22 = llvm::raw_ostream::indent(v3, *((_DWORD *)this + 7));
      sub_1CD098D14(v22, v21, 0, 0, 0);
      v24 = (unsigned char *)*((void *)v3 + 3);
      v23 = (unsigned char *)*((void *)v3 + 4);
      if (v20)
      {
        if (v24 == v23)
        {
          llvm::raw_ostream::write(v3, ".", 1uLL);
        }
        else
        {
          unsigned char *v23 = 46;
          ++*((void *)v3 + 4);
        }
        sub_1CD098D14(v3, v20, 0, 0, 0);
        v24 = (unsigned char *)*((void *)v3 + 3);
        v23 = (unsigned char *)*((void *)v3 + 4);
      }
      if ((unint64_t)(v24 - v23) > 1)
      {
        *(_WORD *)v23 = 8250;
        *((void *)v3 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v3, ": ", 2uLL);
      }
      uint64_t v14 = (*(uint64_t (**)(llvm::sampleprof::SampleProfileWriterText *, void *))(*(void *)this + 16))(this, v18 + 7);
      uint64_t v25 = v14;
      if (v14) {
        break;
      }
      v26 = (void *)v18[1];
      if (v26)
      {
        do
        {
          v27 = v26;
          v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          v27 = (void *)v18[2];
          BOOL v28 = *v27 == (void)v18;
          v18 = v27;
        }
        while (!v28);
      }
      v18 = v27;
      if (v27 == (void *)v19) {
        goto LABEL_47;
      }
    }
    unint64_t v33 = v14 & 0xFFFFFFFF00000000;
  }
  else
  {
LABEL_49:
    *((_DWORD *)this + 7) = v15 - 1;
    if (llvm::sampleprof::FunctionSamples::ProfileIsProbeBased)
    {
      llvm::raw_ostream::indent(v3, v15);
      v29 = (void *)*((void *)v3 + 4);
      if (*((void *)v3 + 3) - (void)v29 > 0xDuLL)
      {
        qmemcpy(v29, "!CFGChecksum: ", 14);
        *((void *)v3 + 4) += 14;
      }
      else
      {
        llvm::raw_ostream::write(v3, "!CFGChecksum: ", 0xEuLL);
      }
      uint64_t v14 = (uint64_t)sub_1CD098D14(v3, *((void *)v13 + 1), 0, 0, 0);
      v30 = (unsigned char *)*((void *)v3 + 4);
      if (*((unsigned char **)v3 + 3) == v30)
      {
        uint64_t v14 = (uint64_t)llvm::raw_ostream::write(v3, "\n", 1uLL);
      }
      else
      {
        unsigned char *v30 = 10;
        ++*((void *)v3 + 4);
      }
    }
    if (*((_DWORD *)v13 + 13))
    {
      llvm::raw_ostream::indent(v3, *((_DWORD *)this + 7) + 1);
      v31 = (void *)*((void *)v3 + 4);
      if (*((void *)v3 + 3) - (void)v31 > 0xCuLL)
      {
        qmemcpy(v31, "!Attributes: ", 13);
        *((void *)v3 + 4) += 13;
      }
      else
      {
        llvm::raw_ostream::write(v3, "!Attributes: ", 0xDuLL);
      }
      uint64_t v14 = (uint64_t)sub_1CD098D14(v3, *((unsigned int *)v13 + 13), 0, 0, 0);
      v32 = (unsigned char *)*((void *)v3 + 4);
      if (*((unsigned char **)v3 + 3) == v32)
      {
        uint64_t v14 = (uint64_t)llvm::raw_ostream::write(v3, "\n", 1uLL);
      }
      else
      {
        unsigned char *v32 = 10;
        ++*((void *)v3 + 4);
      }
    }
    llvm::sampleprof_category((llvm *)v14);
    uint64_t v25 = 0;
    unint64_t v33 = 0;
  }
  if (v53 != &v55) {
    free(v53);
  }
  if (__p != &v58) {
    free(__p);
  }
  return v33 | v25;
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::writeContextIdx(void *a1, const void **a2)
{
  return llvm::sampleprof::SampleProfileWriterBinary::writeNameIdx(a1, *a2, a2[1]);
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::addName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  *(void *)&long long v7 = a2;
  *((void *)&v7 + 1) = a3;
  int v8 = 0;
  return sub_1CD75A1E0(v5, &v7, &v8);
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::addContext(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  uint64_t v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
  *(void *)&long long v6 = v2;
  *((void *)&v6 + 1) = v3;
  int v7 = 0;
  return sub_1CD75A1E0(v4, &v6, &v7);
}

void llvm::sampleprof::SampleProfileWriterExtBinaryBase::addContext(uint64_t a1, long long *a2)
{
  if (*((_DWORD *)a2 + 8))
  {
    uint64_t v4 = *((void *)a2 + 3);
    if (v4)
    {
      unint64_t v5 = (uint64_t *)*((void *)a2 + 2);
      long long v6 = &v5[3 * v4];
      do
      {
        uint64_t v7 = *v5;
        uint64_t v8 = v5[1];
        v5 += 3;
        size_t v9 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
        *(void *)&long long v33 = v7;
        *((void *)&v33 + 1) = v8;
        LODWORD(v34) = 0;
        sub_1CD75A1E0(v9, &v33, &v34);
      }
      while (v5 != v6);
    }
    long long v30 = *a2;
    long long v31 = a2[1];
    uint64_t v32 = *((void *)a2 + 4);
    long long v33 = *a2;
    long long v34 = v31;
    uint64_t v35 = *((void *)a2 + 4);
    int v36 = 0;
    uint64_t v37 = 0;
    if ((sub_1CCCFDD40(*(void *)(a1 + 536), *(_DWORD *)(a1 + 552), (uint64_t)&v33, &v37) & 1) == 0)
    {
      uint64_t v10 = sub_1CCCFDF10(a1 + 536, (uint64_t)&v33, v37);
      uint64_t v11 = v35;
      long long v12 = v34;
      *(_OWORD *)uint64_t v10 = v33;
      *(_OWORD *)(v10 + 16) = v12;
      *(void *)(v10 + 32) = v11;
      uint64_t v13 = *(char **)(a1 + 568);
      uint64_t v14 = *(char **)(a1 + 560);
      uint64_t v15 = (v13 - v14) / 48;
      *(_DWORD *)(v10 + 40) = v15;
      unint64_t v16 = *(void *)(a1 + 576);
      if ((unint64_t)v13 >= v16)
      {
        unint64_t v18 = v15 + 1;
        if ((unint64_t)(v15 + 1) > 0x555555555555555) {
          abort();
        }
        unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - (void)v14) >> 4);
        if (2 * v19 > v18) {
          unint64_t v18 = 2 * v19;
        }
        if (v19 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v20 = 0x555555555555555;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20 > 0x555555555555555) {
          sub_1CB833614();
        }
        uint64_t v21 = 3 * v20;
        v22 = (char *)operator new(48 * v20);
        v23 = &v22[48 * v15];
        *(_OWORD *)v23 = v30;
        *((_OWORD *)v23 + 1) = v31;
        *((void *)v23 + 4) = v32;
        *((_DWORD *)v23 + 10) = 0;
        char v17 = v23 + 48;
        if (v13 == v14)
        {
          v24 = v23;
        }
        else
        {
          do
          {
            v24 = v23 - 48;
            long long v25 = *((_OWORD *)v13 - 3);
            long long v26 = *((_OWORD *)v13 - 1);
            *((_OWORD *)v23 - 2) = *((_OWORD *)v13 - 2);
            *((_OWORD *)v23 - 1) = v26;
            *((_OWORD *)v23 - 3) = v25;
            v13 -= 48;
            v23 -= 48;
          }
          while (v13 != v14);
        }
        *(void *)(a1 + 560) = v24;
        *(void *)(a1 + 568) = v17;
        *(void *)(a1 + 576) = &v22[16 * v21];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *(_OWORD *)uint64_t v13 = v30;
        *((_OWORD *)v13 + 1) = v31;
        *((void *)v13 + 4) = v32;
        *((_DWORD *)v13 + 10) = 0;
        char v17 = v13 + 48;
      }
      *(void *)(a1 + 568) = v17;
    }
  }
  else
  {
    uint64_t v28 = *(void *)a2;
    uint64_t v27 = *((void *)a2 + 1);
    v29 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
    *(void *)&long long v33 = v28;
    *((void *)&v33 + 1) = v27;
    LODWORD(v34) = 0;
    sub_1CD75A1E0(v29, &v33, &v34);
  }
}

uint64_t llvm::sampleprof::SampleProfileWriterCompactBinary::writeNameTable(llvm::raw_ostream **this)
{
  v1 = (llvm::sampleprof::SampleProfileWriterCompactBinary *)this;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = this[1];
  v24[0] = 0;
  v24[1] = 0;
  v23 = (long long *)v24;
  uint64_t v3 = this[7];
  uint64_t v4 = this[8];
  if (v3 != v4)
  {
    do
    {
      this = (llvm::raw_ostream **)sub_1CD69C5D0((uint64_t)&v23, (uint64_t)v3, v3);
      uint64_t v3 = (llvm::raw_ostream *)((char *)v3 + 24);
    }
    while (v3 != v4);
    unint64_t v5 = v23;
    if (v23 != (long long *)v24)
    {
      int v6 = 0;
      do
      {
        this = (llvm::raw_ostream **)sub_1CCCFD864((void *)v1 + 4, v5 + 2);
        *(_DWORD *)this = v6;
        uint64_t v7 = (long long *)*((void *)v5 + 1);
        if (v7)
        {
          do
          {
            uint64_t v8 = v7;
            uint64_t v7 = *(long long **)v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            uint64_t v8 = (long long *)*((void *)v5 + 2);
            BOOL v9 = *(void *)v8 == (void)v5;
            unint64_t v5 = v8;
          }
          while (!v9);
        }
        ++v6;
        unint64_t v5 = v8;
      }
      while (v8 != (long long *)v24);
    }
  }
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v1 + 8) - *((void *)v1 + 7)) >> 3);
  do
  {
    char v11 = v10 & 0x7F | ((v10 > 0x7F) << 7);
    long long v12 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v12 >= *((void *)v2 + 3))
    {
      this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, v11);
    }
    else
    {
      *((void *)v2 + 4) = v12 + 1;
      *long long v12 = v11;
    }
    BOOL v13 = v10 > 0x7F;
    v10 >>= 7;
  }
  while (v13);
  uint64_t v14 = v23;
  if (v23 != (long long *)v24)
  {
    do
    {
      uint64_t v15 = (int *)*((void *)v14 + 4);
      size_t v16 = *((void *)v14 + 5);
      long long v26 = xmmword_1CFAC4320;
      uint64_t v27 = 0;
      llvm::MD5::update((int *)&v26, v15, v16);
      this = (llvm::raw_ostream **)llvm::MD5::final((int *)&v26, (int *)&v25);
      unint64_t v17 = v25;
      do
      {
        char v18 = v17 & 0x7F | ((v17 > 0x7F) << 7);
        unint64_t v19 = (char *)*((void *)v2 + 4);
        if ((unint64_t)v19 >= *((void *)v2 + 3))
        {
          this = (llvm::raw_ostream **)llvm::raw_ostream::write(v2, v18);
        }
        else
        {
          *((void *)v2 + 4) = v19 + 1;
          *unint64_t v19 = v18;
        }
        BOOL v13 = v17 > 0x7F;
        v17 >>= 7;
      }
      while (v13);
      unint64_t v20 = (long long *)*((void *)v14 + 1);
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          unint64_t v20 = *(long long **)v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (long long *)*((void *)v14 + 2);
          BOOL v9 = *(void *)v21 == (void)v14;
          uint64_t v14 = v21;
        }
        while (!v9);
      }
      uint64_t v14 = v21;
    }
    while (v21 != (long long *)v24);
  }
  llvm::sampleprof_category((llvm *)this);
  sub_1CB833A08((uint64_t)&v23, v24[0]);
  return 0;
}

uint64_t llvm::sampleprof::SampleProfileWriterBinary::writeMagicIdent(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(llvm::raw_ostream **)(a1 + 8);
  unint64_t v3 = a2 | 0x5350524F46343200;
  do
  {
    char v4 = v3 & 0x7F | ((v3 > 0x7F) << 7);
    unint64_t v5 = (char *)*((void *)v2 + 4);
    if ((unint64_t)v5 >= *((void *)v2 + 3))
    {
      uint64_t v2 = llvm::raw_ostream::write(v2, v4);
    }
    else
    {
      *((void *)v2 + 4) = v5 + 1;
      *unint64_t v5 = v4;
    }
    BOOL v6 = v3 > 0x7F;
    v3 >>= 7;
  }
  while (v6);
  uint64_t v7 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v7 >= *((void *)v2 + 3))
  {
    uint64_t v2 = llvm::raw_ostream::write(v2, 103);
  }
  else
  {
    *((void *)v2 + 4) = v7 + 1;
    *uint64_t v7 = 103;
  }
  llvm::sampleprof_category(v2);
  return 0;
}

void llvm::sampleprof::SampleProfileWriterBinary::writeHeader(unsigned int *a1, uint64_t a2)
{
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::setToCompressAllSections(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 96);
  if (v1)
  {
    uint64_t v2 = 40 * v1;
    unint64_t v3 = (void *)(*(void *)(this + 88) + 8);
    do
    {
      *v3 |= 1uLL;
      v3 += 5;
      v2 -= 40;
    }
    while (v2);
  }
  return this;
}

llvm::raw_ostream *llvm::sampleprof::SampleProfileWriterExtBinaryBase::allocSecHdrTable(llvm::sampleprof::SampleProfileWriterExtBinaryBase *this)
{
  uint64_t v2 = (llvm::raw_ostream *)*((void *)this + 1);
  *(void *)BOOL v9 = *((unsigned int *)this + 24);
  llvm::raw_ostream::write(v2, v9, 8uLL);
  unint64_t v3 = (void *)*((void *)this + 1);
  result = (llvm::raw_ostream *)(*(uint64_t (**)(void *))(*v3 + 80))(v3);
  *((void *)this + 56) = (char *)result + v3[4] - v3[2];
  if (*((_DWORD *)this + 24))
  {
    unsigned int v5 = 0;
    do
    {
      *(void *)BOOL v9 = -1;
      BOOL v6 = llvm::raw_ostream::write(v2, v9, 8uLL);
      *(void *)BOOL v9 = -1;
      uint64_t v7 = llvm::raw_ostream::write(v6, v9, 8uLL);
      *(void *)BOOL v9 = -1;
      uint64_t v8 = llvm::raw_ostream::write(v7, v9, 8uLL);
      *(void *)BOOL v9 = -1;
      result = llvm::raw_ostream::write(v8, v9, 8uLL);
      ++v5;
    }
    while (*((_DWORD *)this + 24) > v5);
  }
  return result;
}

uint64_t llvm::sampleprof::SampleProfileWriterExtBinaryBase::writeHeader(llvm::sampleprof::SampleProfileWriterExtBinaryBase *a1)
{
  uint64_t v2 = (void *)*((void *)a1 + 1);
  *((void *)a1 + 55) = (*(uint64_t (**)(void *))(*v2 + 80))(v2) + v2[4] - v2[2];
  (*(void (**)(llvm::sampleprof::SampleProfileWriterExtBinaryBase *, void))(*(void *)a1 + 96))(a1, *((unsigned int *)a1 + 6));
  unint64_t v3 = llvm::sampleprof::SampleProfileWriterExtBinaryBase::allocSecHdrTable(a1);
  llvm::sampleprof_category(v3);
  return 0;
}

void llvm::sampleprof::SampleProfileWriterCompactBinary::writeHeader(unsigned int *a1, uint64_t a2)
{
}

unint64_t llvm::sampleprof::SampleProfileWriterBinary::writeSample(llvm::sampleprof::SampleProfileWriterBinary *this, const llvm::sampleprof::FunctionSamples *a2)
{
  unint64_t v4 = *((void *)a2 + 8);
  unsigned int v5 = (llvm::raw_ostream *)*((void *)this + 1);
  do
  {
    char v6 = v4 & 0x7F | ((v4 > 0x7F) << 7);
    uint64_t v7 = (char *)*((void *)v5 + 4);
    if ((unint64_t)v7 >= *((void *)v5 + 3))
    {
      unsigned int v5 = llvm::raw_ostream::write(v5, v6);
    }
    else
    {
      *((void *)v5 + 4) = v7 + 1;
      *uint64_t v7 = v6;
    }
    BOOL v8 = v4 > 0x7F;
    v4 >>= 7;
  }
  while (v8);

  return llvm::sampleprof::SampleProfileWriterBinary::writeBody(this, a2);
}

unint64_t llvm::sampleprof::SampleProfileWriterCompactBinary::writeSample(llvm::sampleprof::SampleProfileWriterCompactBinary *this, const llvm::sampleprof::FunctionSamples *a2)
{
  unint64_t v4 = (void *)*((void *)this + 1);
  uint64_t v5 = (*(uint64_t (**)(void *))(*v4 + 80))(v4);
  uint64_t v6 = v4[4];
  uint64_t v7 = v4[2];
  BOOL v9 = (const void *)*((void *)a2 + 2);
  BOOL v8 = (const void *)*((void *)a2 + 3);
  v33[0] = v9;
  v33[1] = v8;
  int v34 = 0;
  sub_1CD69C76C((uint64_t)this + 80, v33, &v34, (uint64_t)&v31);
  uint64_t v10 = v31;
  if (v32)
  {
    long long v12 = (void *)*((void *)this + 14);
    unint64_t v11 = *((void *)this + 15);
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v30 = v7;
      size_t v16 = (void *)*((void *)this + 13);
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v12 - v16) + 1;
      if (v17 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - (void)v16) >> 3);
      if (2 * v18 > v17) {
        unint64_t v17 = 2 * v18;
      }
      if (v18 >= 0x555555555555555) {
        unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        unint64_t v20 = (char *)operator new(24 * v19);
      }
      else
      {
        unint64_t v20 = 0;
      }
      uint64_t v21 = &v20[8 * (v12 - v16)];
      v22 = &v20[24 * v19];
      *(void *)uint64_t v21 = v9;
      *((void *)v21 + 1) = v8;
      *((void *)v21 + 2) = 0;
      BOOL v13 = v21 + 24;
      if (v12 == v16)
      {
        uint64_t v7 = v30;
      }
      else
      {
        uint64_t v7 = v30;
        do
        {
          long long v23 = *(_OWORD *)(v12 - 3);
          *((void *)v21 - 1) = *(v12 - 1);
          *(_OWORD *)(v21 - 24) = v23;
          v21 -= 24;
          v12 -= 3;
        }
        while (v12 != v16);
        long long v12 = (void *)*((void *)this + 13);
      }
      *((void *)this + 13) = v21;
      *((void *)this + 14) = v13;
      *((void *)this + 15) = v22;
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *long long v12 = v9;
      v12[1] = v8;
      BOOL v13 = v12 + 3;
      v12[2] = 0;
    }
    *((void *)this + 14) = v13;
    uint64_t v15 = *((void *)this + 13);
    unsigned int v14 = -1431655765 * (((unint64_t)v13 - v15) >> 3) - 1;
    *(_DWORD *)(v10 + 16) = v14;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(v31 + 16);
    uint64_t v15 = *((void *)this + 13);
  }
  *(void *)(v15 + 24 * v14 + 16) = v5 + v6 - v7;
  unint64_t v24 = *((void *)a2 + 8);
  unint64_t v25 = (llvm::raw_ostream *)*((void *)this + 1);
  do
  {
    char v26 = v24 & 0x7F | ((v24 > 0x7F) << 7);
    uint64_t v27 = (char *)*((void *)v25 + 4);
    if ((unint64_t)v27 >= *((void *)v25 + 3))
    {
      unint64_t v25 = llvm::raw_ostream::write(v25, v26);
    }
    else
    {
      *((void *)v25 + 4) = v27 + 1;
      char *v27 = v26;
    }
    BOOL v28 = v24 > 0x7F;
    v24 >>= 7;
  }
  while (v28);
  return llvm::sampleprof::SampleProfileWriterBinary::writeBody(this, a2);
}

void llvm::sampleprof::SampleProfileWriter::create(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = 0;
  uint64_t v5 = std::system_category();
  if (a3 != 2 && a3 != 255 && a3 != 4) {
    operator new();
  }
  operator new();
}

atomic_ullong llvm::sampleprof::SampleProfileWriter::create@<X0>(int a1@<W1>, uint64_t a2@<X8>)
{
  int v4 = (llvm *)std::system_category();
  if (!(llvm::sampleprof::FunctionSamples::ProfileIsCSFlat | llvm::sampleprof::FunctionSamples::ProfileIsProbeBased))
  {
    uint64_t v5 = 7;
    switch(a1)
    {
      case 1:
        goto LABEL_5;
      case 2:
        operator new();
      case 3:
        goto LABEL_11;
      case 4:
        goto LABEL_12;
      default:
        if (a1 == 255) {
          operator new();
        }
        goto LABEL_10;
    }
  }
  uint64_t v5 = 7;
  switch(a1)
  {
    case 1:
LABEL_5:
      operator new();
    case 2:
      goto LABEL_9;
    case 3:
      goto LABEL_11;
    case 4:
LABEL_12:
      operator new();
    default:
      if (a1 == 255)
      {
LABEL_9:
        *(unsigned char *)(a2 + 16) |= 1u;
        atomic_ullong result = llvm::sampleprof_category(v4);
        *(void *)a2 = 7;
        *(void *)(a2 + 8) = result;
      }
      else
      {
LABEL_10:
        uint64_t v5 = 6;
LABEL_11:
        atomic_ullong result = llvm::sampleprof_category(v4);
        *(unsigned char *)(a2 + 16) |= 1u;
        *(void *)a2 = v5;
        *(void *)(a2 + 8) = result;
      }
      return result;
  }
}

void sub_1CCCFD1C0(void *a1)
{
  sub_1CCCFDAC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCFD1F8(llvm *a1)
{
  return 0;
}

void *sub_1CCCFD218(void *a1)
{
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);

  return sub_1CCCFDAC8(a1);
}

void sub_1CCCFD26C(void *a1)
{
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);
  sub_1CCCFDAC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCFD2D4(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CCCFD2E4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 584) = a2;
  return result;
}

uint64_t sub_1CCCFD2EC(uint64_t result)
{
  *(unsigned char *)(result + 528) = 1;
  uint64_t v1 = *(unsigned int *)(result + 96);
  if (v1)
  {
    uint64_t v2 = *(void *)(result + 88);
    uint64_t v3 = 40 * v1;
    int v4 = (void *)(v2 + 8);
    do
    {
      if (*((_DWORD *)v4 - 2) == 2) {
        *v4 |= 0x100000000uLL;
      }
      v4 += 5;
      v3 -= 40;
    }
    while (v3);
    uint64_t v5 = 40 * v1;
    uint64_t v6 = (void *)(v2 + 8);
    do
    {
      if (*((_DWORD *)v6 - 2) == 2) {
        *v6 |= 0x200000000uLL;
      }
      v6 += 5;
      v5 -= 40;
    }
    while (v5);
  }
  return result;
}

uint64_t sub_1CCCFD364(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 96);
  if (v1)
  {
    uint64_t v2 = 40 * v1;
    uint64_t v3 = (void *)(*(void *)(result + 88) + 8);
    do
    {
      if (*((_DWORD *)v3 - 2) == 1) {
        *v3 |= 0x100000000uLL;
      }
      v3 += 5;
      v2 -= 40;
    }
    while (v2);
  }
  return result;
}

uint64_t sub_1CCCFD3A4(_DWORD *a1, unsigned int a2)
{
  (*(void (**)(_DWORD *))(*(void *)a1 + 136))(a1);
  a1[20] = a2;

  return sub_1CCCFDB48((uint64_t)(a1 + 22), (uint64_t)&qword_1EBCF03F8[42 * a2]);
}

void sub_1CCCFD418(void *a1)
{
  sub_1CCCFDC28(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCCFD450(llvm *a1)
{
  return 0;
}

void *sub_1CCCFD474(void *a1)
{
  *a1 = &unk_1F263CF30;
  uint64_t v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[10], 8);
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);

  return sub_1CCCFDAC8(a1);
}

void sub_1CCCFD504(void *a1)
{
  *a1 = &unk_1F263CF30;
  uint64_t v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[10], 8);
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);
  sub_1CCCFDAC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCCFD5A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v7 = sub_1CD681950(a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    long long v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      BOOL v13 = (void *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v8)
          {
            if (sub_1CD681C28((uint64_t)(v13 + 2), a2)) {
              return;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3) {
              break;
            }
          }
          BOOL v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v15 = (char *)operator new(0xB0uLL);
  size_t v16 = v15;
  *(void *)uint64_t v15 = 0;
  *((void *)v15 + 1) = v8;
  long long v17 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v15 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v15 + 2) = v17;
  *((void *)v15 + 6) = *(void *)(a3 + 32);
  *(_OWORD *)(v15 + 72) = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v15 + 88) = *(_OWORD *)(a3 + 72);
  *(_OWORD *)(v15 + 104) = *(_OWORD *)(a3 + 88);
  uint64_t v18 = *(void *)(a3 + 104);
  *(_OWORD *)(v15 + 56) = *(_OWORD *)(a3 + 40);
  unint64_t v19 = (void *)(a3 + 120);
  uint64_t v20 = *(void *)(a3 + 120);
  uint64_t v21 = *(void *)(a3 + 112);
  *((void *)v15 + 15) = v18;
  *((void *)v15 + 16) = v21;
  *((void *)v15 + 17) = v20;
  v22 = v15 + 136;
  uint64_t v23 = *(void *)(a3 + 128);
  *((void *)v15 + 18) = v23;
  if (v23)
  {
    *(void *)(v20 + 16) = v22;
    *(void *)(a3 + 112) = v19;
    *unint64_t v19 = 0;
    *(void *)(a3 + 128) = 0;
  }
  else
  {
    *((void *)v15 + 16) = v22;
  }
  unint64_t v24 = (void *)(a3 + 144);
  uint64_t v25 = *(void *)(a3 + 144);
  uint64_t v26 = *(void *)(a3 + 136);
  *((void *)v15 + 20) = v25;
  uint64_t v27 = v15 + 160;
  *((void *)v15 + 19) = v26;
  uint64_t v28 = *(void *)(a3 + 152);
  *((void *)v15 + 21) = v28;
  if (v28)
  {
    *(void *)(v25 + 16) = v27;
    *(void *)(a3 + 136) = v24;
    void *v24 = 0;
    *(void *)(a3 + 152) = 0;
  }
  else
  {
    *((void *)v15 + 19) = v27;
  }
  float v29 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v30 = *(float *)(a1 + 32);
  if (!v9 || (float)(v30 * (float)v9) < v29)
  {
    BOOL v31 = v9 < 3 || (v9 & (v9 - 1)) != 0;
    unint64_t v32 = v31 | (2 * v9);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t v34 = v33;
    }
    else {
      size_t v34 = v32;
    }
    sub_1CC9B3D48(a1, v34);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v35 = *(void *)a1;
  int v36 = *(void **)(*(void *)a1 + 8 * v3);
  if (v36)
  {
    *(void *)size_t v16 = *v36;
LABEL_46:
    *int v36 = v16;
    goto LABEL_47;
  }
  *(void *)size_t v16 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v16;
  *(void *)(v35 + 8 * v3) = a1 + 16;
  if (*(void *)v16)
  {
    unint64_t v37 = *(void *)(*(void *)v16 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v37 >= v9) {
        v37 %= v9;
      }
    }
    else
    {
      v37 &= v9 - 1;
    }
    int v36 = (void *)(*(void *)a1 + 8 * v37);
    goto LABEL_46;
  }
LABEL_47:
  ++*(void *)(a1 + 24);
}

uint64_t sub_1CCCFD864(void *a1, long long *a2)
{
  long long v20 = *a2;
  v21[0] = 0;
  sub_1CD69C76C((uint64_t)a1, (const void **)&v20, v21, (uint64_t)&v18);
  uint64_t v4 = v18;
  if (v19)
  {
    uint64_t v6 = (char *)a1[4];
    unint64_t v5 = a1[5];
    if ((unint64_t)v6 >= v5)
    {
      uint8x8_t v10 = (char *)a1[3];
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v10) >> 3) + 1;
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)v10) >> 3);
      if (2 * v12 > v11) {
        unint64_t v11 = 2 * v12;
      }
      if (v12 >= 0x555555555555555) {
        unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v13 = v11;
      }
      if (v13)
      {
        if (v13 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        unint64_t v14 = (char *)operator new(24 * v13);
      }
      else
      {
        unint64_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * ((v6 - v10) >> 3)];
      *(_OWORD *)uint64_t v15 = *a2;
      *((_DWORD *)v15 + 4) = 0;
      unint64_t v7 = v15 + 24;
      if (v6 != v10)
      {
        do
        {
          long long v16 = *(_OWORD *)(v6 - 24);
          *((void *)v15 - 1) = *((void *)v6 - 1);
          *(_OWORD *)(v15 - 24) = v16;
          v15 -= 24;
          v6 -= 24;
        }
        while (v6 != v10);
        uint64_t v6 = (char *)a1[3];
      }
      a1[3] = v15;
      a1[4] = v7;
      a1[5] = &v14[24 * v13];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *(_OWORD *)uint64_t v6 = *a2;
      *((_DWORD *)v6 + 4) = 0;
      unint64_t v7 = v6 + 24;
    }
    a1[4] = v7;
    uint64_t v9 = a1[3];
    unsigned int v8 = -1431655765 * (((unint64_t)v7 - v9) >> 3) - 1;
    *(_DWORD *)(v4 + 16) = v8;
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(v18 + 16);
    uint64_t v9 = a1[3];
  }
  return v9 + 24 * v8 + 16;
}

void *sub_1CCCFDA0C(void *a1)
{
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);

  return sub_1CCCFDAC8(a1);
}

void sub_1CCCFDA60(void *a1)
{
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);
  sub_1CCCFDAC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CCCFDAC8(void *a1)
{
  *a1 = &unk_1F263CC70;
  uint64_t v4 = a1[2];
  uint64_t v2 = a1 + 2;
  uint64_t v3 = v4;
  void *v2 = 0;
  if (v4) {
    sub_1CC025ED8((uint64_t)v2, v3);
  }
  uint64_t v5 = a1[1];
  a1[1] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

uint64_t sub_1CCCFDB48(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 40 * v4);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 40 * v5);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 40 * v5), (const void *)(*(void *)a2 + 40 * v5), *(void *)a2 + 40 * v6 - (*(void *)a2 + 40 * v5));
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void *sub_1CCCFDC28(void *a1)
{
  *a1 = &unk_1F263CDD0;
  uint64_t v2 = (uint64_t)(a1 + 67);
  uint64_t v3 = (void *)a1[70];
  if (v3)
  {
    a1[71] = v3;
    operator delete(v3);
  }
  sub_1CD759598(v2);
  MEMORY[0x1D25D9CD0](a1[67], 8);
  uint64_t v4 = (void *)a1[63];
  if (v4)
  {
    a1[64] = v4;
    operator delete(v4);
  }
  sub_1CD759598((uint64_t)(a1 + 60));
  MEMORY[0x1D25D9CD0](a1[60], 8);
  uint64_t v5 = (void *)a1[57];
  if (v5)
  {
    a1[58] = v5;
    operator delete(v5);
  }
  uint64_t v6 = a1[54];
  a1[54] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  unint64_t v7 = (void *)a1[11];
  if (v7 != a1 + 13) {
    free(v7);
  }
  *a1 = &unk_1F263CD40;
  sub_1CD456CB4(a1 + 4);

  return sub_1CCCFDAC8(a1);
}

uint64_t sub_1CCCFDD40(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  if (a2)
  {
    uint64_t v16 = 0;
    memset(v15, 0, sizeof(v15));
    uint64_t v5 = 1;
    v14[0] = "@";
    v14[1] = 1;
    memset(&v14[2], 0, 24);
    int v9 = a2 - 1;
    unsigned int v10 = (a2 - 1) & sub_1CD681950(a3);
    uint64_t v11 = a1 + 48 * v10;
    if (!sub_1CD681C28(a3, v11))
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (!sub_1CD681C28(v11, (uint64_t)v15))
      {
        if (sub_1CD681C28(v11, (uint64_t)v14) && v12 == 0) {
          uint64_t v12 = v11;
        }
        unsigned int v10 = (v10 + v13) & v9;
        uint64_t v11 = a1 + 48 * v10;
        uint64_t v5 = 1;
        ++v13;
        if (sub_1CD681C28(a3, v11)) {
          goto LABEL_5;
        }
      }
      uint64_t v5 = 0;
      if (v12) {
        uint64_t v11 = v12;
      }
    }
LABEL_5:
    *a4 = v11;
  }
  else
  {
    uint64_t v5 = 0;
    *a4 = 0;
  }
  return v5;
}

uint64_t sub_1CCCFDE6C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v14 = 0;
  uint64_t result = sub_1CCCFDD40(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v14);
  uint64_t v9 = v14;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = sub_1CCCFDF10(a2, a3, v14);
    uint64_t v9 = result;
    long long v12 = *(_OWORD *)a3;
    long long v11 = *(_OWORD *)(a3 + 16);
    *(void *)(result + 32) = *(void *)(a3 + 32);
    *(_OWORD *)uint64_t result = v12;
    *(_OWORD *)(result + 16) = v11;
    *(_DWORD *)(result + 40) = *a4;
    char v10 = 1;
  }
  uint64_t v13 = *(void *)a2 + 48 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v13;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CCCFDF10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CCCFDFE0(a1, v6);
  *(void *)&v9[0] = 0;
  sub_1CCCFDD40(*(void *)a1, *(_DWORD *)(a1 + 16), a2, (uint64_t *)v9);
  a3 = *(void *)&v9[0];
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (!sub_1CD681C28(a3, (uint64_t)v9)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CCCFDFE0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(48 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 48 * v10;
      do
      {
        result[4] = 0;
        *(_OWORD *)uint64_t result = 0uLL;
        *((_OWORD *)result + 1) = 0uLL;
        result += 6;
        v11 -= 48;
      }
      while (v11);
    }
    uint64_t v21 = 0;
    memset(v20, 0, sizeof(v20));
    v19[0] = "@";
    v19[1] = 1;
    memset(&v19[2], 0, 24);
    if (v3)
    {
      uint64_t v12 = 48 * v3;
      uint64_t v13 = v4;
      do
      {
        if (!sub_1CD681C28(v13, (uint64_t)v20) && !sub_1CD681C28(v13, (uint64_t)v19))
        {
          uint64_t v22 = 0;
          sub_1CCCFDD40(*(void *)a1, *(_DWORD *)(a1 + 16), v13, &v22);
          uint64_t v14 = v22;
          long long v15 = *(_OWORD *)v13;
          long long v16 = *(_OWORD *)(v13 + 16);
          *(void *)(v22 + 32) = *(void *)(v13 + 32);
          *(_OWORD *)uint64_t v14 = v15;
          *(_OWORD *)(v14 + 16) = v16;
          *(_DWORD *)(v14 + 40) = *(_DWORD *)(v13 + 40);
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 48;
        v12 -= 48;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 48 * v17;
    do
    {
      result[4] = 0;
      *(_OWORD *)uint64_t result = 0uLL;
      *((_OWORD *)result + 1) = 0uLL;
      result += 6;
      v18 -= 48;
    }
    while (v18);
  }
  return result;
}

char *sub_1CCCFE184(char **a1, uint64_t a2, _OWORD **a3, _DWORD **a4)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v7) {
    unint64_t v7 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555) {
    unint64_t v7 = 0xAAAAAAAAAAAAAAALL;
  }
  if (v7 > 0xAAAAAAAAAAAAAAALL) {
    sub_1CB833614();
  }
  uint64_t v11 = 3 * v7;
  uint64_t v12 = (char *)operator new(24 * v7);
  uint64_t v13 = &v12[24 * v6];
  uint64_t v14 = *a4;
  *(_OWORD *)uint64_t v13 = **a3;
  *((_DWORD *)v13 + 4) = *v14;
  long long v15 = v13 + 24;
  if (v5 == v4)
  {
    long long v16 = &v12[24 * v6];
  }
  else
  {
    do
    {
      long long v16 = v13 - 24;
      long long v17 = *(_OWORD *)(v5 - 24);
      *((void *)v13 - 1) = *((void *)v5 - 1);
      *(_OWORD *)(v13 - 24) = v17;
      v5 -= 24;
      v13 -= 24;
    }
    while (v5 != v4);
  }
  *a1 = v16;
  a1[1] = v15;
  a1[2] = &v12[8 * v11];
  if (v4) {
    operator delete(v4);
  }
  return v15;
}

uint64_t sub_1CCCFE2B0()
{
  memcpy(&unk_1EBCF0408, &unk_1CFB2C5D0, 0x118uLL);
  qword_1EBCF03F8[0] = (uint64_t)&unk_1EBCF0408;
  qword_1EBCF0400 = 0x800000007;
  memcpy(&unk_1EBCF0558, &unk_1CFB2C6E8, 0x140uLL);
  qword_1EBCF0548 = (uint64_t)&unk_1EBCF0558;
  qword_1EBCF0550 = 0x800000008;

  return __cxa_atexit((void (*)(void *))sub_1CCCF80DC, qword_1EBCF03F8, &dword_1CB82C000);
}

void llvm::memprof::RawMemProfReader::create(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)a1, 0, 1, (uint64_t)&v25);
  if ((uint64_t)v26.__cat_)
  {
    unint64_t v7 = v25;
    if (v25)
    {
      *(void *)&v6.__val_ = *(void *)&v26.__val_;
      llvm::errorCodeToError(v25, v6, &v23);
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      switch(*((unsigned char *)a1 + 32))
      {
        case 2:
          __break(1u);
          sub_1CCCFEB08((llvm *)&v22, (uint64_t)&v21, a2, 0);
        case 3:
          uint64_t v8 = (uint64_t)*a1;
          if (*a1) {
            uint64_t v9 = strlen((const char *)*a1);
          }
          else {
            uint64_t v9 = 0;
          }
          break;
        case 4:
          char v15 = *((unsigned char *)*a1 + 23);
          if (v15 >= 0) {
            uint64_t v8 = (uint64_t)*a1;
          }
          else {
            uint64_t v8 = **a1;
          }
          if (v15 >= 0) {
            uint64_t v9 = v15 & 0x7F;
          }
          else {
            uint64_t v9 = (*a1)[1];
          }
          break;
        case 5:
          uint64_t v8 = (uint64_t)*a1;
          uint64_t v9 = (uint64_t)a1[1];
          break;
        default:
          break;
      }
      sub_1CCCFEB08((llvm *)&v24, (uint64_t)&v23, v8, v9);
    }
  }
  else
  {
    std::system_category();
    unint64_t v7 = v25;
  }
  uint64_t v25 = 0;
  uint64_t v11 = (char *)*((void *)v7 + 1);
  uint64_t v10 = (char *)*((void *)v7 + 2);
  unint64_t v12 = v10 - v11;
  if ((unint64_t)(v10 - v11) >= 8 && *(void *)v11 == 0xFF6D70726F667281)
  {
    if (v10 != v11)
    {
      if (v12 < 0x30) {
        operator new();
      }
      if (v11 < v10)
      {
        uint64_t v13 = 0;
        do
        {
          if (*((void *)v11 + 1) != 1) {
            operator new();
          }
          uint64_t v14 = *((void *)v11 + 2);
          v13 += v14;
          v11 += v14;
        }
        while (v11 < v10);
        if (v12 == v13)
        {
          if (a3)
          {
            llvm::object::createBinary(a2, a3, 0, 1, (uint64_t)&v27);
            if ((v28 & 1) == 0) {
              operator new();
            }
            uint64_t v16 = v27;
            *(void *)&long long v27 = 0;
            uint64_t v17 = v16;
            sub_1CCCFEB08((llvm *)&v18, (uint64_t)&v17, a2, a3);
          }
          *(void *)&v30.__val_ = std::generic_category();
          llvm::errorCodeToError((llvm *)0x16, v30, &v19);
          sub_1CCCFEB08((llvm *)&v20, (uint64_t)&v19, (uint64_t)"Path to profiled binary is empty!", 33);
        }
      }
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_1CCCFEB08(llvm *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = llvm::inconvertibleErrorCode(a1);
  __int16 v9 = 261;
  v8[0] = a3;
  v8[1] = a4;
  sub_1CD4FF4BC(v6, v7, (llvm::Twine *)v8);
}

void llvm::memprof::RawMemProfReader::initialize(llvm::memprof::RawMemProfReader *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (llvm *)*((void *)this + 1);
  if (v1) {
    BOOL v2 = (*((_DWORD *)v1 + 2) & 0xFFFFFFFC) == 12;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    v5[0] = "Not an ELF file: ";
    __int16 v7 = 259;
    llvm::inconvertibleErrorCode(v1);
    operator new();
  }
  llvm::object::ObjectFile::makeTriple(v1, (llvm::Triple *)v5);
  if ((v6 - 41) < 2)
  {
    v9[0] = &unk_1F26187D0;
    v9[1] = llvm::WithColor::defaultErrorHandler;
    v9[3] = v9;
    v8[0] = &unk_1F26187D0;
    v8[1] = llvm::WithColor::defaultWarningHandler;
    v8[3] = v8;
    llvm::DWARFContext::create();
  }
  ArchName = llvm::Triple::getArchName((llvm::Triple *)v5);
  v9[4] = "Unsupported target: ";
  v9[6] = ArchName;
  v9[7] = v4;
  __int16 v10 = 1283;
  llvm::inconvertibleErrorCode(ArchName);
  operator new();
}

BOOL llvm::memprof::RawMemProfReader::hasFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  __int16 v6 = 261;
  v5[0] = a1;
  v5[1] = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)v5, 0, 1, (uint64_t)&v7);
  BOOL v2 = 0;
  if ((v8 & 1) == 0)
  {
    uint64_t v3 = (void *)v7[1];
    BOOL v2 = v7[2] - (void)v3 >= 8uLL && *v3 == 0xFF6D70726F667281;
    (*(void (**)(void))(*v7 + 8))();
  }
  return v2;
}

BOOL llvm::memprof::RawMemProfReader::hasFormat(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  return *(void *)(a1 + 16) - (void)v1 >= 8uLL && *v1 == 0xFF6D70726F667281;
}

char **llvm::memprof::RawMemProfReader::printYAML(llvm::memprof::RawMemProfReader *this, llvm::raw_ostream *a2)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = (uint64_t *)((char *)a2 + 32);
  uint64_t v4 = (_OWORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v4 > 0xFuLL)
  {
    *uint64_t v4 = *(_OWORD *)"MemprofProfile:\n";
    *v5 += 16;
  }
  else
  {
    llvm::raw_ostream::write(a2, "MemprofProfile:\n", 0x10uLL);
  }
  llvm::memprof::RawMemProfReader::printSummaries(this, a2);
  uint64_t v6 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v6) > 0xA)
  {
    *(_DWORD *)(v6 + 7) = 171602788;
    *(void *)uint64_t v6 = *(void *)"  Records:\n";
    *v5 += 11;
  }
  else
  {
    llvm::raw_ostream::write(a2, "  Records:\n", 0xBuLL);
  }
  *((void *)this + 139) = *((void *)this + 136);
  unint64_t v108 = 0;
  memset(&v109[1], 0, 176);
  long long v110 = 0u;
  memset(v111, 0, sizeof(v111));
  v107 = this;
  v109[0] = (char *)&v109[2];
  HIDWORD(v109[1]) = 1;
  *(void *)&long long v110 = v111;
  HIDWORD(v110) = 1;
  sub_1CCD03500((uint64_t)&v107);
  memset(&v106[1], 0, 72);
  uint64_t v105 = 0;
  v103[1] = (char *)0x100000000;
  memset(v104, 0, sizeof(v104));
  v103[0] = (char *)v104;
  v106[0] = (char *)&v106[2];
  HIDWORD(v106[1]) = 1;
  while (v107)
  {
    __int16 v7 = (_DWORD *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v7 > 3uLL)
    {
      *__int16 v7 = 170729504;
      uint64_t v8 = *v5 + 4;
      *unint64_t v5 = v8;
    }
    else
    {
      llvm::raw_ostream::write(a2, "  -\n", 4uLL);
      uint64_t v8 = *((void *)a2 + 4);
    }
    if ((unint64_t)(*((void *)a2 + 3) - v8) > 0x11)
    {
      *(_WORD *)(v8 + 16) = 8250;
      *(_OWORD *)uint64_t v8 = *(_OWORD *)"    FunctionGUID: ";
      *v5 += 18;
    }
    else
    {
      llvm::raw_ostream::write(a2, "    FunctionGUID: ", 0x12uLL);
    }
    sub_1CD098D14(a2, v108, 0, 0, 0);
    uint64_t v9 = (unsigned char *)*((void *)a2 + 4);
    if (*((unsigned char **)a2 + 3) == v9)
    {
      llvm::raw_ostream::write(a2, "\n", 1uLL);
    }
    else
    {
      *uint64_t v9 = 10;
      ++*v5;
    }
    if (LODWORD(v109[1]))
    {
      __int16 v10 = (_OWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v10 > 0xFuLL)
      {
        *__int16 v10 = *(_OWORD *)"    AllocSites:\n";
        *v5 += 16;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    AllocSites:\n", 0x10uLL);
      }
      if (LODWORD(v109[1]))
      {
        uint64_t v11 = v109[0];
        unint64_t v12 = &v109[0][168 * LODWORD(v109[1])];
        do
        {
          uint64_t v13 = *((void *)a2 + 4);
          if ((unint64_t)(*((void *)a2 + 3) - v13) > 5)
          {
            *(_WORD *)(v13 + 4) = 2605;
            *(_DWORD *)uint64_t v13 = 538976288;
            uint64_t v14 = *v5 + 6;
            *unint64_t v5 = v14;
          }
          else
          {
            llvm::raw_ostream::write(a2, "    -\n", 6uLL);
            uint64_t v14 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v14) > 0x10)
          {
            *(unsigned char *)(v14 + 16) = 10;
            *(_OWORD *)uint64_t v14 = *(_OWORD *)"      Callstack:\n";
            *v5 += 17;
          }
          else
          {
            llvm::raw_ostream::write(a2, "      Callstack:\n", 0x11uLL);
          }
          uint64_t v15 = *((unsigned int *)v11 + 2);
          if (v15)
          {
            uint64_t v16 = *(void *)v11;
            uint64_t v17 = 24 * v15;
            do
            {
              sub_1CCD03630(v16, a2);
              v16 += 24;
              v17 -= 24;
            }
            while (v17);
          }
          uint64_t v18 = *((void *)a2 + 4);
          if ((unint64_t)(*((void *)a2 + 3) - v18) > 0x13)
          {
            *(_DWORD *)(v18 + 16) = 171600739;
            *(_OWORD *)uint64_t v18 = *(_OWORD *)"      MemInfoBlock:\n";
            uint64_t v19 = (void *)(*v5 + 20);
            *unint64_t v5 = (uint64_t)v19;
          }
          else
          {
            llvm::raw_ostream::write(a2, "      MemInfoBlock:\n", 0x14uLL);
            uint64_t v19 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v19 > 7uLL)
          {
            *uint64_t v19 = 0x2020202020202020;
            uint64_t v20 = *v5 + 8;
            *unint64_t v5 = v20;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v20 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v20) > 9)
          {
            *(_WORD *)(v20 + 8) = 29806;
            *(void *)uint64_t v20 = *(void *)"AllocCount";
            uint64_t v21 = (_WORD *)(*v5 + 10);
            *unint64_t v5 = (uint64_t)v21;
          }
          else
          {
            llvm::raw_ostream::write(a2, "AllocCount", 0xAuLL);
            uint64_t v21 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v21 > 1uLL)
          {
            *uint64_t v21 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 16), 0, 0, 0);
          uint64_t v22 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v22)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            uint64_t v23 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v22 = 10;
            uint64_t v23 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v23;
          }
          if (*((void *)a2 + 3) - (void)v23 > 7uLL)
          {
            void *v23 = 0x2020202020202020;
            uint64_t v24 = (_OWORD *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v24;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v24 = (_OWORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v24 > 0xFuLL)
          {
            _OWORD *v24 = *(_OWORD *)"TotalAccessCount";
            uint64_t v25 = (_WORD *)(*v5 + 16);
            *unint64_t v5 = (uint64_t)v25;
          }
          else
          {
            llvm::raw_ostream::write(a2, "TotalAccessCount", 0x10uLL);
            uint64_t v25 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v25 > 1uLL)
          {
            *uint64_t v25 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((void *)v11 + 9), 0, 0, 0);
          std::error_code v26 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v26)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            long long v27 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v26 = 10;
            long long v27 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v27;
          }
          if (*((void *)a2 + 3) - (void)v27 > 7uLL)
          {
            void *v27 = 0x2020202020202020;
            char v28 = (void *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v28;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            char v28 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v28 > 0xDuLL)
          {
            qmemcpy(v28, "MinAccessCount", 14);
            uint64_t v29 = (_WORD *)(*v5 + 14);
            *unint64_t v5 = (uint64_t)v29;
          }
          else
          {
            llvm::raw_ostream::write(a2, "MinAccessCount", 0xEuLL);
            uint64_t v29 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v29 > 1uLL)
          {
            _WORD *v29 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((void *)v11 + 10), 0, 0, 0);
          std::error_code v30 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v30)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            BOOL v31 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v30 = 10;
            BOOL v31 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v31;
          }
          if (*((void *)a2 + 3) - (void)v31 > 7uLL)
          {
            void *v31 = 0x2020202020202020;
            unint64_t v32 = (void *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v32;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            unint64_t v32 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v32 > 0xDuLL)
          {
            qmemcpy(v32, "MaxAccessCount", 14);
            unint64_t v33 = (_WORD *)(*v5 + 14);
            *unint64_t v5 = (uint64_t)v33;
          }
          else
          {
            llvm::raw_ostream::write(a2, "MaxAccessCount", 0xEuLL);
            unint64_t v33 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v33 > 1uLL)
          {
            *unint64_t v33 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((void *)v11 + 11), 0, 0, 0);
          size_t v34 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v34)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            uint64_t v35 = (void *)*((void *)a2 + 4);
          }
          else
          {
            *size_t v34 = 10;
            uint64_t v35 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v35;
          }
          if (*((void *)a2 + 3) - (void)v35 > 7uLL)
          {
            *uint64_t v35 = 0x2020202020202020;
            uint64_t v36 = *v5 + 8;
            *unint64_t v5 = v36;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v36 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v36) > 8)
          {
            *(unsigned char *)(v36 + 8) = 101;
            *(void *)uint64_t v36 = *(void *)"TotalSize";
            unint64_t v37 = (_WORD *)(*v5 + 9);
            *unint64_t v5 = (uint64_t)v37;
          }
          else
          {
            llvm::raw_ostream::write(a2, "TotalSize", 9uLL);
            unint64_t v37 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v37 > 1uLL)
          {
            *unint64_t v37 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((void *)v11 + 12), 0, 0, 0);
          unint64_t v38 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v38)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v39 = (void *)*((void *)a2 + 4);
          }
          else
          {
            *unint64_t v38 = 10;
            v39 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v39;
          }
          if (*((void *)a2 + 3) - (void)v39 > 7uLL)
          {
            void *v39 = 0x2020202020202020;
            v40 = (_DWORD *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v40;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v40 = (_DWORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v40 > 6uLL)
          {
            *(_DWORD *)((char *)v40 + 3) = 1702521171;
            _DWORD *v40 = 1399744845;
            v41 = (_WORD *)(*v5 + 7);
            *unint64_t v5 = (uint64_t)v41;
          }
          else
          {
            llvm::raw_ostream::write(a2, "MinSize", 7uLL);
            v41 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v41 > 1uLL)
          {
            _WORD *v41 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 26), 0, 0, 0);
          v42 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v42)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v43 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v42 = 10;
            v43 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v43;
          }
          if (*((void *)a2 + 3) - (void)v43 > 7uLL)
          {
            void *v43 = 0x2020202020202020;
            v44 = (_DWORD *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v44;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v44 = (_DWORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v44 > 6uLL)
          {
            *(_DWORD *)((char *)v44 + 3) = 1702521171;
            _DWORD *v44 = 1400398157;
            v45 = (_WORD *)(*v5 + 7);
            *unint64_t v5 = (uint64_t)v45;
          }
          else
          {
            llvm::raw_ostream::write(a2, "MaxSize", 7uLL);
            v45 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v45 > 1uLL)
          {
            _WORD *v45 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 27), 0, 0, 0);
          v46 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v46)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            unint64_t v47 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v46 = 10;
            unint64_t v47 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v47;
          }
          if (*((void *)a2 + 3) - (void)v47 > 7uLL)
          {
            *unint64_t v47 = 0x2020202020202020;
            v48 = (void *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v48;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v48 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v48 > 0xDuLL)
          {
            qmemcpy(v48, "AllocTimestamp", 14);
            v49 = (_WORD *)(*v5 + 14);
            *unint64_t v5 = (uint64_t)v49;
          }
          else
          {
            llvm::raw_ostream::write(a2, "AllocTimestamp", 0xEuLL);
            v49 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v49 > 1uLL)
          {
            _WORD *v49 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 28), 0, 0, 0);
          v50 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v50)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v51 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v50 = 10;
            v51 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v51;
          }
          if (*((void *)a2 + 3) - (void)v51 > 7uLL)
          {
            void *v51 = 0x2020202020202020;
            v52 = (_OWORD *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v52;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v52 = (_OWORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v52 > 0xFuLL)
          {
            _OWORD *v52 = *(_OWORD *)"DeallocTimestamp";
            v53 = (_WORD *)(*v5 + 16);
            *unint64_t v5 = (uint64_t)v53;
          }
          else
          {
            llvm::raw_ostream::write(a2, "DeallocTimestamp", 0x10uLL);
            v53 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v53 > 1uLL)
          {
            _WORD *v53 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 29), 0, 0, 0);
          v54 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v54)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            uint64_t v55 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v54 = 10;
            uint64_t v55 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v55;
          }
          if (*((void *)a2 + 3) - (void)v55 > 7uLL)
          {
            *uint64_t v55 = 0x2020202020202020;
            v56 = (void *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v56;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v56 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v56 > 0xCuLL)
          {
            qmemcpy(v56, "TotalLifetime", 13);
            size_t v57 = (_WORD *)(*v5 + 13);
            *unint64_t v5 = (uint64_t)v57;
          }
          else
          {
            llvm::raw_ostream::write(a2, "TotalLifetime", 0xDuLL);
            size_t v57 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v57 > 1uLL)
          {
            *size_t v57 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((void *)v11 + 15), 0, 0, 0);
          uint64_t v58 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v58)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            uint64_t v59 = (void *)*((void *)a2 + 4);
          }
          else
          {
            *uint64_t v58 = 10;
            uint64_t v59 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v59;
          }
          if (*((void *)a2 + 3) - (void)v59 > 7uLL)
          {
            *uint64_t v59 = 0x2020202020202020;
            uint64_t v60 = *v5 + 8;
            *unint64_t v5 = v60;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v60 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v60) > 0xA)
          {
            *(_DWORD *)(v60 + 7) = 1701669236;
            *(void *)uint64_t v60 = *(void *)"MinLifetime";
            v61 = (_WORD *)(*v5 + 11);
            *unint64_t v5 = (uint64_t)v61;
          }
          else
          {
            llvm::raw_ostream::write(a2, "MinLifetime", 0xBuLL);
            v61 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v61 > 1uLL)
          {
            _WORD *v61 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 32), 0, 0, 0);
          v62 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v62)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v63 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v62 = 10;
            v63 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v63;
          }
          if (*((void *)a2 + 3) - (void)v63 > 7uLL)
          {
            void *v63 = 0x2020202020202020;
            uint64_t v64 = *v5 + 8;
            *unint64_t v5 = v64;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v64 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v64) > 0xA)
          {
            *(_DWORD *)(v64 + 7) = 1701669236;
            *(void *)uint64_t v64 = *(void *)"MaxLifetime";
            v65 = (_WORD *)(*v5 + 11);
            *unint64_t v5 = (uint64_t)v65;
          }
          else
          {
            llvm::raw_ostream::write(a2, "MaxLifetime", 0xBuLL);
            v65 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v65 > 1uLL)
          {
            _WORD *v65 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 33), 0, 0, 0);
          v66 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v66)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v67 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v66 = 10;
            v67 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v67;
          }
          if (*((void *)a2 + 3) - (void)v67 > 7uLL)
          {
            void *v67 = 0x2020202020202020;
            uint64_t v68 = *v5 + 8;
            *unint64_t v5 = v68;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v68 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v68) > 9)
          {
            *(_WORD *)(v68 + 8) = 25673;
            *(void *)uint64_t v68 = *(void *)"AllocCpuId";
            v69 = (_WORD *)(*v5 + 10);
            *unint64_t v5 = (uint64_t)v69;
          }
          else
          {
            llvm::raw_ostream::write(a2, "AllocCpuId", 0xAuLL);
            v69 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v69 > 1uLL)
          {
            _WORD *v69 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 34), 0, 0, 0);
          v70 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v70)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v71 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v70 = 10;
            v71 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v71;
          }
          if (*((void *)a2 + 3) - (void)v71 > 7uLL)
          {
            void *v71 = 0x2020202020202020;
            uint64_t v72 = *v5 + 8;
            *unint64_t v5 = v72;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v72 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v72) > 0xB)
          {
            *(_DWORD *)(v72 + 8) = 1682535792;
            *(void *)uint64_t v72 = *(void *)"DeallocCpuId";
            v73 = (_WORD *)(*v5 + 12);
            *unint64_t v5 = (uint64_t)v73;
          }
          else
          {
            llvm::raw_ostream::write(a2, "DeallocCpuId", 0xCuLL);
            v73 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v73 > 1uLL)
          {
            _WORD *v73 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 35), 0, 0, 0);
          v74 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v74)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v75 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v74 = 10;
            v75 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v75;
          }
          if (*((void *)a2 + 3) - (void)v75 > 7uLL)
          {
            void *v75 = 0x2020202020202020;
            v76 = (void *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v76;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v76 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v76 > 0xDuLL)
          {
            qmemcpy(v76, "NumMigratedCpu", 14);
            v77 = (_WORD *)(*v5 + 14);
            *unint64_t v5 = (uint64_t)v77;
          }
          else
          {
            llvm::raw_ostream::write(a2, "NumMigratedCpu", 0xEuLL);
            v77 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v77 > 1uLL)
          {
            _WORD *v77 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 36), 0, 0, 0);
          v78 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v78)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v79 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v78 = 10;
            v79 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v79;
          }
          if (*((void *)a2 + 3) - (void)v79 > 7uLL)
          {
            void *v79 = 0x2020202020202020;
            uint64_t v80 = *v5 + 8;
            *unint64_t v5 = v80;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v80 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v80) > 0x12)
          {
            *(_DWORD *)(v80 + 15) = 1936744812;
            *(_OWORD *)uint64_t v80 = *(_OWORD *)"NumLifetimeOverlaps";
            v81 = (_WORD *)(*v5 + 19);
            *unint64_t v5 = (uint64_t)v81;
          }
          else
          {
            llvm::raw_ostream::write(a2, "NumLifetimeOverlaps", 0x13uLL);
            v81 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v81 > 1uLL)
          {
            _WORD *v81 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 37), 0, 0, 0);
          v82 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v82)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v83 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v82 = 10;
            v83 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v83;
          }
          if (*((void *)a2 + 3) - (void)v83 > 7uLL)
          {
            void *v83 = 0x2020202020202020;
            v84 = (void *)(*v5 + 8);
            *unint64_t v5 = (uint64_t)v84;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            v84 = (void *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v84 > 0xEuLL)
          {
            qmemcpy(v84, "NumSameAllocCpu", 15);
            v85 = (_WORD *)(*v5 + 15);
            *unint64_t v5 = (uint64_t)v85;
          }
          else
          {
            llvm::raw_ostream::write(a2, "NumSameAllocCpu", 0xFuLL);
            v85 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v85 > 1uLL)
          {
            _WORD *v85 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 38), 0, 0, 0);
          v86 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v86)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v87 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v86 = 10;
            v87 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v87;
          }
          if (*((void *)a2 + 3) - (void)v87 > 7uLL)
          {
            void *v87 = 0x2020202020202020;
            uint64_t v88 = *v5 + 8;
            *unint64_t v5 = v88;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v88 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v88) > 0x10)
          {
            *(unsigned char *)(v88 + 16) = 117;
            *(_OWORD *)uint64_t v88 = *(_OWORD *)"NumSameDeallocCpu";
            v89 = (_WORD *)(*v5 + 17);
            *unint64_t v5 = (uint64_t)v89;
          }
          else
          {
            llvm::raw_ostream::write(a2, "NumSameDeallocCpu", 0x11uLL);
            v89 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v89 > 1uLL)
          {
            _WORD *v89 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((unsigned int *)v11 + 39), 0, 0, 0);
          v90 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v90)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
            v91 = (void *)*((void *)a2 + 4);
          }
          else
          {
            unsigned char *v90 = 10;
            v91 = (void *)(*v5 + 1);
            *unint64_t v5 = (uint64_t)v91;
          }
          if (*((void *)a2 + 3) - (void)v91 > 7uLL)
          {
            void *v91 = 0x2020202020202020;
            uint64_t v92 = *v5 + 8;
            *unint64_t v5 = v92;
          }
          else
          {
            llvm::raw_ostream::write(a2, "        ", 8uLL);
            uint64_t v92 = *((void *)a2 + 4);
          }
          if ((unint64_t)(*((void *)a2 + 3) - v92) > 9)
          {
            *(_WORD *)(v92 + 8) = 25673;
            *(void *)uint64_t v92 = *(void *)"DataTypeId";
            v93 = (_WORD *)(*v5 + 10);
            *unint64_t v5 = (uint64_t)v93;
          }
          else
          {
            llvm::raw_ostream::write(a2, "DataTypeId", 0xAuLL);
            v93 = (_WORD *)*((void *)a2 + 4);
          }
          if (*((void *)a2 + 3) - (void)v93 > 1uLL)
          {
            _WORD *v93 = 8250;
            *v5 += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          sub_1CD098D14(a2, *((void *)v11 + 20), 0, 0, 0);
          v94 = (unsigned char *)*((void *)a2 + 4);
          if (*((unsigned char **)a2 + 3) == v94)
          {
            llvm::raw_ostream::write(a2, "\n", 1uLL);
          }
          else
          {
            unsigned char *v94 = 10;
            ++*v5;
          }
          v11 += 168;
        }
        while (v11 != v12);
      }
    }
    if (DWORD2(v110))
    {
      v95 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v95 > 0xEuLL)
      {
        qmemcpy(v95, "    CallSites:\n", 15);
        *v5 += 15;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    CallSites:\n", 0xFuLL);
      }
      if (DWORD2(v110))
      {
        uint64_t v96 = v110;
        uint64_t v97 = v110 + ((unint64_t)DWORD2(v110) << 6);
        do
        {
          uint64_t v98 = *(unsigned int *)(v96 + 8);
          if (v98)
          {
            uint64_t v99 = *(void *)v96;
            uint64_t v100 = 24 * v98;
            do
            {
              uint64_t v101 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v101) > 5)
              {
                *(_WORD *)(v101 + 4) = 2605;
                *(_DWORD *)uint64_t v101 = 538976288;
                *v5 += 6;
              }
              else
              {
                llvm::raw_ostream::write(a2, "    -\n", 6uLL);
              }
              sub_1CCD03630(v99, a2);
              v99 += 24;
              v100 -= 24;
            }
            while (v100);
          }
          v96 += 64;
        }
        while (v96 != v97);
      }
    }
    sub_1CCD03500((uint64_t)&v107);
  }
  sub_1CD4D68AC(v106);
  sub_1CD74EA50(v103);
  sub_1CD4D68AC((char **)&v110);
  return sub_1CD74EA50(v109);
}

llvm::raw_ostream *llvm::memprof::RawMemProfReader::printSummaries(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  BOOL v2 = *(void **)(*(void *)this + 8);
  if ((unint64_t)v2 < *(void *)(*(void *)this + 16))
  {
    uint64_t v4 = this;
    do
    {
      unint64_t v6 = v2[1];
      unint64_t v5 = v2[2];
      unint64_t v7 = *(void *)((char *)v2 + v2[3]);
      unint64_t v8 = *(void *)((char *)v2 + v2[4]);
      unint64_t v9 = *(void *)((char *)v2 + v2[5]);
      __int16 v10 = (_DWORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v10 > 3uLL)
      {
        *__int16 v10 = 170729504;
        uint64_t v11 = *((void *)a2 + 4) + 4;
        *((void *)a2 + 4) = v11;
      }
      else
      {
        llvm::raw_ostream::write(a2, "  -\n", 4uLL);
        uint64_t v11 = *((void *)a2 + 4);
      }
      if ((unint64_t)(*((void *)a2 + 3) - v11) > 9)
      {
        *(_WORD *)(v11 + 8) = 2618;
        *(void *)uint64_t v11 = *(void *)"  Header:\n";
        unint64_t v12 = (void *)(*((void *)a2 + 4) + 10);
        *((void *)a2 + 4) = v12;
      }
      else
      {
        llvm::raw_ostream::write(a2, "  Header:\n", 0xAuLL);
        unint64_t v12 = (void *)*((void *)a2 + 4);
      }
      if (*((void *)a2 + 3) - (void)v12 > 0xCuLL)
      {
        qmemcpy(v12, "    Version: ", 13);
        *((void *)a2 + 4) += 13;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    Version: ", 0xDuLL);
      }
      sub_1CD098D14(a2, v6, 0, 0, 0);
      uint64_t v13 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v13)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v14 = *((void *)a2 + 4);
      }
      else
      {
        *uint64_t v13 = 10;
        uint64_t v14 = *((void *)a2 + 4) + 1;
        *((void *)a2 + 4) = v14;
      }
      if ((unint64_t)(*((void *)a2 + 3) - v14) > 0x13)
      {
        *(_DWORD *)(v14 + 16) = 540701541;
        *(_OWORD *)uint64_t v14 = *(_OWORD *)"    TotalSizeBytes: ";
        *((void *)a2 + 4) += 20;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    TotalSizeBytes: ", 0x14uLL);
      }
      sub_1CD098D14(a2, v5, 0, 0, 0);
      uint64_t v15 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v15)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v16 = *((void *)a2 + 4);
      }
      else
      {
        *uint64_t v15 = 10;
        uint64_t v16 = *((void *)a2 + 4) + 1;
        *((void *)a2 + 4) = v16;
      }
      if ((unint64_t)(*((void *)a2 + 3) - v16) > 0x10)
      {
        *(unsigned char *)(v16 + 16) = 32;
        *(_OWORD *)uint64_t v16 = *(_OWORD *)"    NumSegments: ";
        *((void *)a2 + 4) += 17;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    NumSegments: ", 0x11uLL);
      }
      sub_1CD098D14(a2, v7, 0, 0, 0);
      uint64_t v17 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v17)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v18 = (_OWORD *)*((void *)a2 + 4);
      }
      else
      {
        *uint64_t v17 = 10;
        uint64_t v18 = (_OWORD *)(*((void *)a2 + 4) + 1);
        *((void *)a2 + 4) = v18;
      }
      if (*((void *)a2 + 3) - (void)v18 > 0xFuLL)
      {
        _OWORD *v18 = *(_OWORD *)"    NumMibInfo: ";
        *((void *)a2 + 4) += 16;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    NumMibInfo: ", 0x10uLL);
      }
      sub_1CD098D14(a2, v8, 0, 0, 0);
      uint64_t v19 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v19)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v20 = (void *)*((void *)a2 + 4);
      }
      else
      {
        *uint64_t v19 = 10;
        uint64_t v20 = (void *)(*((void *)a2 + 4) + 1);
        *((void *)a2 + 4) = v20;
      }
      if (*((void *)a2 + 3) - (void)v20 > 0x14uLL)
      {
        qmemcpy(v20, "    NumStackOffsets: ", 21);
        *((void *)a2 + 4) += 21;
      }
      else
      {
        llvm::raw_ostream::write(a2, "    NumStackOffsets: ", 0x15uLL);
      }
      this = sub_1CD098D14(a2, v9, 0, 0, 0);
      uint64_t v21 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v21)
      {
        this = llvm::raw_ostream::write(a2, "\n", 1uLL);
      }
      else
      {
        *uint64_t v21 = 10;
        ++*((void *)a2 + 4);
      }
      BOOL v2 = (void *)((char *)v2 + v2[2]);
    }
    while ((unint64_t)v2 < *(void *)(*(void *)v4 + 16));
  }
  return this;
}

void llvm::memprof::RawMemProfReader::readRawProfile(llvm::memprof::RawMemProfReader *this@<X0>, void *a2@<X8>)
{
  v114[7] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)((char *)this + 32);
  uint64_t v4 = *(void **)(*(void *)this + 8);
  unint64_t v5 = (char *)this + 944;
  uint64_t v105 = (char *)this + 992;
  v103 = (char *)this + 32;
  while ((unint64_t)v4 < *(void *)(*(void *)this + 16))
  {
    uint64_t v6 = v4[3];
    unint64_t v8 = (unint64_t)v4 + v6 + 8;
    uint64_t v7 = *(void *)((char *)v4 + v6);
    uint64_t v112 = (char *)v114;
    uint64_t v113 = 0x100000000;
    unsigned int v9 = 0;
    if (v7)
    {
      uint64_t v10 = (uint64_t)v4 + v6 + 8;
      do
      {
        uint64_t v11 = v112;
        unint64_t v12 = (char *)v8;
        if (v9 >= HIDWORD(v113))
        {
          unint64_t v14 = v9 + 1;
          uint64_t v15 = &v112[56 * v9];
          if ((unint64_t)v112 <= v8 && (unint64_t)v15 > v8)
          {
            uint64_t v17 = v10 - (void)v112;
            sub_1CCD03980((uint64_t)&v112, v14);
            uint64_t v11 = v112;
            unint64_t v12 = &v112[v17];
          }
          else
          {
            sub_1CCD03980((uint64_t)&v112, v14);
            uint64_t v11 = v112;
            unint64_t v12 = (char *)v8;
          }
        }
        uint64_t v13 = &v11[56 * v113];
        *(_OWORD *)(v13 + 40) = 0u;
        *(_OWORD *)(v13 + 24) = 0u;
        *(_OWORD *)uint64_t v13 = *(_OWORD *)v12;
        *((void *)v13 + 2) = *((void *)v12 + 2);
        unsigned int v9 = v113 + 1;
        LODWORD(v113) = v113 + 1;
        v8 += 56;
        v10 += 56;
        --v7;
      }
      while (v7);
    }
    int v18 = *((_DWORD *)this + 10);
    if (v18)
    {
      if (v18 == v9)
      {
        uint64_t v19 = 0;
        unint64_t v20 = v9;
        uint64_t v21 = *v3;
        uint64_t v22 = *v3 + 56 * v9;
        uint64_t v23 = v112;
        while (1)
        {
          uint64_t v24 = &v112[v19];
          uint64_t v25 = v21 + v19;
          if (*(void *)(v21 + v19) != *(void *)&v112[v19]
            || *(void *)(v25 + 8) != *((void *)v24 + 1)
            || *(void *)(v25 + 16) != *((void *)v24 + 2))
          {
            break;
          }
          v19 += 56;
          if (v25 + 56 == v22) {
            goto LABEL_24;
          }
        }
      }
      operator new();
    }
    uint64_t v23 = v112;
    unint64_t v20 = v9;
LABEL_24:
    *((_DWORD *)this + 10) = 0;
    if (v20 <= *((unsigned int *)this + 11))
    {
      if (!v20)
      {
        int v29 = 0;
        goto LABEL_31;
      }
      unsigned int v26 = 0;
    }
    else
    {
      sub_1CCD03980((uint64_t)v3, v20);
      unsigned int v26 = *((_DWORD *)this + 10);
    }
    long long v27 = &v23[56 * v20];
    char v28 = (void *)(*v3 + 56 * v26 + 25);
    do
    {
      *((unsigned char *)v28 - 1) = 0;
      v28[1] = 0;
      v28[2] = 0;
      *char v28 = 0;
      *(void *)((char *)v28 + 23) = 0;
      *(_OWORD *)((char *)v28 - 25) = *(_OWORD *)v23;
      *(void *)((char *)v28 - 9) = *((void *)v23 + 2);
      v28 += 7;
      v23 += 56;
    }
    while (v23 != v27);
    int v29 = *((_DWORD *)this + 10);
LABEL_31:
    *((_DWORD *)this + 10) = v29 + v20;
    std::error_code v30 = (void *)((char *)v4 + v4[4]);
    uint64_t v31 = *v30;
    v109 = v111;
    uint64_t v110 = 0x100000000;
    if (v31)
    {
      unsigned int v32 = 0;
      unint64_t v33 = v30 + 1;
      do
      {
        uint64_t v34 = *v33;
        long long v35 = *(_OWORD *)(v33 + 7);
        long long v36 = *(_OWORD *)(v33 + 9);
        long long v37 = *(_OWORD *)(v33 + 11);
        int v108 = *((_DWORD *)v33 + 26);
        long long v38 = *(_OWORD *)(v33 + 3);
        long long v39 = *(_OWORD *)(v33 + 5);
        v107[0] = *(_OWORD *)(v33 + 1);
        v107[1] = v38;
        v107[4] = v36;
        v107[5] = v37;
        v107[2] = v39;
        v107[3] = v35;
        *(void *)v106 = v34;
        *(_OWORD *)&v106[72] = v36;
        *(_OWORD *)&v106[88] = v37;
        *(_DWORD *)&v106[104] = v108;
        *(_OWORD *)&v106[8] = v107[0];
        *(_OWORD *)&v106[24] = v38;
        *(_OWORD *)&v106[40] = v39;
        *(_OWORD *)&v106[56] = v35;
        if (v32 >= HIDWORD(v110))
        {
          BOOL v46 = (char *)v109 + 112 * v32 > v106;
          if (v109 > v106 || !v46) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v40 = (char *)v109 + 112 * v110;
        long long v41 = *(_OWORD *)v106;
        long long v42 = *(_OWORD *)&v106[32];
        v40[1] = *(_OWORD *)&v106[16];
        v40[2] = v42;
        _OWORD *v40 = v41;
        long long v43 = *(_OWORD *)&v106[48];
        long long v44 = *(_OWORD *)&v106[64];
        long long v45 = *(_OWORD *)&v106[96];
        v40[5] = *(_OWORD *)&v106[80];
        v40[6] = v45;
        v40[3] = v43;
        v40[4] = v44;
        unsigned int v32 = v110 + 1;
        LODWORD(v110) = v110 + 1;
        unint64_t v33 = (void *)((char *)v33 + 108);
        --v31;
      }
      while (v31);
      unint64_t v47 = (char *)v109;
      if (v32)
      {
        v48 = (char *)v109 + 112 * v32;
        while (1)
        {
          uint64_t v49 = *((void *)this + 118);
          uint64_t v50 = *((unsigned int *)this + 240);
          if (!v50) {
            goto LABEL_48;
          }
          LODWORD(v51) = (37 * *(void *)v47) & (v50 - 1);
          v52 = (uint64_t *)(v49 + 16 * v51);
          uint64_t v53 = *v52;
          if (*v52 != *(void *)v47) {
            break;
          }
LABEL_49:
          if ((uint64_t *)(v49 + 16 * v50) == v52)
          {
            uint64_t v65 = sub_1CCD03068((uint64_t)v5, (uint64_t *)v47);
            long long v66 = *(_OWORD *)(v47 + 40);
            long long v67 = *(_OWORD *)(v47 + 24);
            *(_OWORD *)uint64_t v65 = *(_OWORD *)(v47 + 8);
            *(_OWORD *)(v65 + 16) = v67;
            *(_OWORD *)(v65 + 32) = v66;
            long long v68 = *(_OWORD *)(v47 + 72);
            long long v69 = *(_OWORD *)(v47 + 88);
            long long v70 = *(_OWORD *)(v47 + 56);
            *(_DWORD *)(v65 + 96) = *((_DWORD *)v47 + 26);
            *(_OWORD *)(v65 + 64) = v68;
            *(_OWORD *)(v65 + 80) = v69;
            *(_OWORD *)(v65 + 48) = v70;
          }
          else
          {
            uint64_t v56 = sub_1CCD03068((uint64_t)v5, (uint64_t *)v47);
            *(_DWORD *)v56 += *((_DWORD *)v47 + 2);
            *(void *)(v56 + 4) += *(void *)(v47 + 12);
            *(int8x16_t *)(v56 + 12) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)(v56 + 12), *(uint64x2_t *)(v47 + 20)), *(int8x16_t *)(v47 + 20), *(int8x16_t *)(v56 + 12));
            *(void *)(v56 + 28) += *(void *)(v47 + 36);
            *(uint32x2_t *)(v56 + 36) = vmin_u32(*(uint32x2_t *)(v47 + 44), *(uint32x2_t *)(v56 + 36));
            *(void *)(v56 + 52) += *(void *)(v47 + 60);
            unsigned int v57 = *((_DWORD *)v47 + 17);
            unsigned int v58 = *(_DWORD *)(v56 + 64);
            if (v57 >= *(_DWORD *)(v56 + 60)) {
              unsigned int v57 = *(_DWORD *)(v56 + 60);
            }
            *(_DWORD *)(v56 + 60) = v57;
            unsigned int v59 = *((_DWORD *)v47 + 18);
            if (v59 <= v58) {
              unsigned int v59 = v58;
            }
            *(_DWORD *)(v56 + 64) = v59;
            unsigned int v60 = *(_DWORD *)(v56 + 48);
            int v61 = *(_DWORD *)(v56 + 80);
            uint64_t v62 = *(void *)(v47 + 52);
            *(void *)(v56 + 44) = v62;
            if (v62 >= v60) {
              int v63 = v61;
            }
            else {
              int v63 = v61 + 1;
            }
            *(_DWORD *)(v56 + 80) = v63;
            int32x2_t v64 = *(int32x2_t *)(v47 + 76);
            *(int32x2_t *)(v56 + 84) = vsub_s32(*(int32x2_t *)(v56 + 84), vceq_s32(*(int32x2_t *)(v56 + 68), v64));
            *(int32x2_t *)(v56 + 68) = v64;
          }
          v47 += 112;
          if (v47 == v48)
          {
            unint64_t v47 = (char *)v109;
            goto LABEL_61;
          }
        }
        int v54 = 1;
        while (v53 != -1)
        {
          int v55 = v51 + v54++;
          uint64_t v51 = v55 & (v50 - 1);
          uint64_t v53 = *(void *)(v49 + 16 * v51);
          if (v53 == *(void *)v47)
          {
            v52 = (uint64_t *)(v49 + 16 * v51);
            goto LABEL_49;
          }
        }
LABEL_48:
        v52 = (uint64_t *)(v49 + 16 * v50);
        goto LABEL_49;
      }
LABEL_61:
      if (v47 != v111) {
        free(v47);
      }
    }
    v71 = (void *)((char *)v4 + v4[5]);
    uint64_t v72 = *v71;
    memset(v106, 0, 20);
    if (v72)
    {
      uint64_t v73 = 0;
      v74 = v71 + 1;
      do
      {
        *(void *)&v107[0] = 0;
        uint64_t v75 = *v74;
        uint64_t v76 = v74[1];
        v74 += 2;
        *(void *)&v107[0] = v75;
        v109 = v111;
        uint64_t v110 = 0x600000000;
        if (v76)
        {
          unsigned int v78 = 0;
          do
          {
            uint64_t v80 = *v74++;
            uint64_t v79 = v80;
            if (v78 >= HIDWORD(v110)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v109 + v78) = v79;
            unsigned int v78 = v110 + 1;
            LODWORD(v110) = v110 + 1;
            --v76;
          }
          while (v76);
        }
        sub_1CCD03AF0((uint64_t)v106, (uint64_t *)v107);
        llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v77 + 8, (uint64_t)&v109);
        if (v109 != v111) {
          free(v109);
        }
        ++v73;
      }
      while (v73 != v72);
    }
    if (*((_DWORD *)this + 250))
    {
      uint64_t v81 = *(void *)v106 + 72 * *(unsigned int *)&v106[16];
      if (*(_DWORD *)&v106[8])
      {
        if (*(_DWORD *)&v106[16])
        {
          uint64_t v82 = 72 * *(unsigned int *)&v106[16];
          uint64_t v83 = *(void *)v106;
          while (*(void *)v83 >= 0xFFFFFFFFFFFFFFFELL)
          {
            v83 += 72;
            v82 -= 72;
            if (!v82) {
              goto LABEL_81;
            }
          }
        }
        else
        {
          uint64_t v83 = *(void *)v106;
        }
      }
      else
      {
LABEL_81:
        uint64_t v83 = *(void *)v106 + 72 * *(unsigned int *)&v106[16];
      }
      uint64_t v97 = *(void *)v106 + 72 * *(unsigned int *)&v106[16];
LABEL_101:
      while (v83 != v97)
      {
        v109 = 0;
        if (sub_1CCD03BDC(*((void *)this + 124), *((_DWORD *)this + 252), *(void *)v83, &v109)) {
          BOOL v98 = v109 == (void *)(*((void *)this + 124) + 72 * *((unsigned int *)this + 252));
        }
        else {
          BOOL v98 = 1;
        }
        if (v98)
        {
          sub_1CCD03AF0((uint64_t)v105, (uint64_t *)v83);
          llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v102 + 8, v83 + 8);
        }
        else
        {
          uint64_t v99 = *(unsigned int *)(v83 + 16);
          if (v99 != *((_DWORD *)v109 + 4)
            || memcmp(*(const void **)(v83 + 8), *((const void **)v109 + 1), 8 * v99))
          {
            operator new();
          }
        }
        uint64_t v100 = (unint64_t *)(v83 + 72);
        while (v100 != (unint64_t *)v81)
        {
          unint64_t v101 = *v100;
          v100 += 9;
          if (v101 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v83 = (uint64_t)(v100 - 9);
            goto LABEL_101;
          }
        }
        uint64_t v83 = v81;
      }
    }
    else if (v106 != v105)
    {
      uint64_t v84 = *((unsigned int *)this + 252);
      uint64_t v85 = *((void *)this + 124);
      if (v84)
      {
        uint64_t v86 = 72 * v84;
        v87 = (void *)(v85 + 24);
        do
        {
          if (*(v87 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v88 = (void *)*(v87 - 2);
            if (v87 != v88) {
              free(v88);
            }
          }
          v87 += 9;
          v86 -= 72;
        }
        while (v86);
        uint64_t v85 = *(void *)v105;
      }
      MEMORY[0x1D25D9CD0](v85, 8);
      uint64_t v89 = *(unsigned int *)&v106[16];
      *((_DWORD *)this + 252) = *(_DWORD *)&v106[16];
      if (v89)
      {
        *((void *)this + 124) = operator new(72 * v89, (std::align_val_t)8uLL);
        *((void *)this + 125) = *(void *)&v106[8];
        unint64_t v90 = *((unsigned int *)this + 252);
        if (v90)
        {
          uint64_t v91 = 0;
          for (unint64_t i = 0; i < v90; ++i)
          {
            uint64_t v93 = *(void *)v105;
            uint64_t v94 = *(void *)v106;
            unint64_t v95 = *(void *)(*(void *)v106 + v91);
            *(void *)(*(void *)v105 + v91) = v95;
            if (v95 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              *(void *)(v93 + v91 + 8) = v93 + v91 + 24;
              uint64_t v96 = v94 + v91;
              *(void *)(v93 + v91 + 16) = 0x600000000;
              if (*(_DWORD *)(v96 + 16))
              {
                llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v93 + v91 + 8, v96 + 8);
                unint64_t v90 = *((unsigned int *)this + 252);
              }
            }
            v91 += 72;
          }
        }
      }
      else
      {
        *(void *)uint64_t v105 = 0;
        *((void *)v105 + 1) = 0;
      }
    }
    uint64_t v4 = (void *)((char *)v4 + v4[2]);
    sub_1CCD03A78((uint64_t *)v106);
    uint64_t v3 = (uint64_t *)v103;
    if (v112 != (char *)v114) {
      free(v112);
    }
  }
  *a2 = 0;
}

void llvm::memprof::RawMemProfReader::symbolizeAndFilterStackFrames(llvm::memprof::RawMemProfReader *this@<X0>, char **a2@<X8>)
{
  v185[6] = *MEMORY[0x1E4F143B8];
  v183 = (void **)v185;
  uint64_t v184 = 0x600000000;
  v172[0] = 0;
  v172[1] = 0;
  unsigned int v173 = 0;
  int v3 = *((_DWORD *)this + 250);
  uint64_t v4 = (unint64_t *)*((void *)this + 124);
  uint64_t v5 = *((unsigned int *)this + 252);
  uint64_t v6 = &v4[9 * v5];
  if (v3)
  {
    if (v5)
    {
      uint64_t v7 = 72 * v5;
      unint64_t v8 = v4;
      while (*v8 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v8 += 9;
        v7 -= 72;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      unint64_t v8 = v4;
    }
  }
  else
  {
LABEL_6:
    unint64_t v8 = &v4[9 * v5];
  }
  v165 = &v4[9 * v5];
  if (v8 == v165) {
    goto LABEL_232;
  }
  uint64_t v170 = (uint64_t)this + 1016;
  v168 = (char *)&v181;
  unsigned int v9 = v178;
  v162 = (uint64_t *)((char *)this + 1040);
  v164 = &v4[9 * v5];
  v167 = v178;
  do
  {
    uint64_t v10 = (uint64_t *)v8[1];
    uint64_t v11 = *((unsigned int *)v8 + 4);
    if (!v11)
    {
      v117 = (uint64_t *)v8[1];
      goto LABEL_171;
    }
    v166 = v8;
    unint64_t v12 = &v10[v11];
    v169 = v12;
    do
    {
      uint64_t v171 = 0;
      uint64_t v13 = *v10;
      uint64_t v171 = *v10;
      int v14 = *((_DWORD *)this + 258);
      if (v14)
      {
        uint64_t v15 = *((void *)this + 127);
        int v16 = v14 - 1;
        unsigned int v17 = v16 & (37 * v13);
        uint64_t v18 = *(void *)(v15 + 72 * v17);
        if (v13 == v18) {
          goto LABEL_155;
        }
        int v19 = 1;
        while (v18 != -1)
        {
          unsigned int v20 = v17 + v19++;
          unsigned int v17 = v20 & v16;
          uint64_t v18 = *(void *)(v15 + 72 * v17);
          if (v13 == v18) {
            goto LABEL_155;
          }
        }
      }
      if (v173)
      {
        LODWORD(v21) = (v173 - 1) & (37 * v13);
        uint64_t v22 = (uint64_t *)(v172[0] + 8 * v21);
        uint64_t v23 = *v22;
        if (*v22 == v13) {
          goto LABEL_25;
        }
        int v24 = 1;
        while (v23 != -1)
        {
          int v25 = v21 + v24++;
          uint64_t v21 = v25 & (v173 - 1);
          uint64_t v23 = *(void *)(v172[0] + 8 * v21);
          if (v23 == v13)
          {
            uint64_t v22 = (uint64_t *)(v172[0] + 8 * v21);
            goto LABEL_25;
          }
        }
      }
      uint64_t v22 = (uint64_t *)(v172[0] + 8 * v173);
LABEL_25:
      if ((uint64_t *)(v172[0] + 8 * v173) != v22) {
        goto LABEL_155;
      }
      (*(void (**)(void **__return_ptr))(**((void **)this + 3) + 24))(&v176);
      v182 &= ~1u;
      v179 = v168;
      uint64_t v180 = 0x400000000;
      if (v177)
      {
        sub_1CCD040B0((uint64_t)&v179, (uint64_t)&v176);
        unsigned int v26 = (char *)v176;
        if (!v177) {
          goto LABEL_37;
        }
        uint64_t v27 = 136 * v177;
        do
        {
          char v28 = (void **)&v26[v27];
          if (v26[v27 - 65] < 0) {
            operator delete(*(v28 - 11));
          }
          if (*((char *)v28 - 89) < 0) {
            operator delete(*(void **)&v26[v27 - 112]);
          }
          if (v26[v27 - 113] < 0) {
            operator delete(*(v28 - 17));
          }
          v27 -= 136;
        }
        while (v27);
      }
      unsigned int v26 = (char *)v176;
LABEL_37:
      if (v26 != v9) {
        free(v26);
      }
      if (v182)
      {
        v133 = v179;
        v179 = 0;
        *a2 = v133;
        sub_1CCD045A0(&v179);
        goto LABEL_235;
      }
      v176 = v9;
      uint64_t v177 = 0x400000000;
      int v29 = v9;
      int v30 = v180;
      if (!v180) {
        goto LABEL_58;
      }
      if (v180 <= 4)
      {
        uint64_t v31 = v179;
        unsigned int v32 = &v179[136 * v180];
        int v29 = v9;
LABEL_45:
        unint64_t v33 = 0;
        do
        {
          uint64_t v34 = (uint64_t)&v29[v33 / 8];
          long long v35 = &v31[v33];
          if (v31[v33 + 23] < 0)
          {
            sub_1CB8BDF7C(v34, *(const void **)v35, *((void *)v35 + 1));
          }
          else
          {
            long long v36 = *(_OWORD *)v35;
            *(void *)(v34 + 16) = *((void *)v35 + 2);
            *(_OWORD *)uint64_t v34 = v36;
          }
          long long v37 = &v29[v33 / 8 + 3];
          long long v38 = (const void **)&v31[v33 + 24];
          if (v31[v33 + 47] < 0)
          {
            sub_1CB8BDF7C((uint64_t)v37, *v38, *(void *)&v31[v33 + 32]);
          }
          else
          {
            long long v39 = *(_OWORD *)v38;
            v29[v33 / 8 + 5] = *(void *)&v31[v33 + 40];
            *long long v37 = v39;
          }
          v40 = &v29[v33 / 8 + 6];
          long long v41 = (const void **)&v31[v33 + 48];
          if (v31[v33 + 71] < 0)
          {
            sub_1CB8BDF7C((uint64_t)v40, *v41, *(void *)&v31[v33 + 56]);
          }
          else
          {
            long long v42 = *(_OWORD *)v41;
            v29[v33 / 8 + 8] = *(void *)&v31[v33 + 64];
            _OWORD *v40 = v42;
          }
          long long v43 = (char *)&v29[v33 / 8];
          long long v44 = *(_OWORD *)&v31[v33 + 72];
          long long v45 = *(_OWORD *)&v31[v33 + 88];
          long long v46 = *(_OWORD *)&v31[v33 + 104];
          *(_OWORD *)(v43 + 116) = *(_OWORD *)&v31[v33 + 116];
          *(_OWORD *)(v43 + 104) = v46;
          *(_OWORD *)(v43 + 88) = v45;
          *(_OWORD *)(v43 + 72) = v44;
          v33 += 136;
        }
        while (&v31[v33] != v32);
        int v29 = v176;
        goto LABEL_57;
      }
      sub_1CC68395C((uint64_t)&v176, v180);
      int v29 = v176;
      if (v180)
      {
        uint64_t v31 = v179;
        unsigned int v32 = &v179[136 * v180];
        goto LABEL_45;
      }
LABEL_57:
      LODWORD(v177) = v30;
LABEL_58:
      unint64_t v47 = *((unsigned __int8 *)v29 + 47);
      if ((v47 & 0x80u) == 0) {
        unint64_t v48 = v47 & 0x7F;
      }
      else {
        unint64_t v48 = v29[4];
      }
      if (v48 == 9)
      {
        uint64_t v49 = v29 + 3;
        if ((v47 & 0x80) != 0)
        {
          uint64_t v49 = (void *)*v49;
          unint64_t v47 = v29[4];
        }
        size_t v50 = v47 >= 9 ? 9 : v47;
        if (!memcmp(v49, "<invalid>", v50) && v47 == 9) {
          goto LABEL_157;
        }
      }
      char v51 = *((unsigned char *)v29 + 23);
      BOOL v52 = v51 < 0;
      if (v51 >= 0) {
        uint64_t v53 = (const std::string::value_type *)v29;
      }
      else {
        uint64_t v53 = (const std::string::value_type *)*v29;
      }
      std::string::size_type v54 = v51 & 0x7F;
      if (v52) {
        std::string::size_type v55 = v29[1];
      }
      else {
        std::string::size_type v55 = v54;
      }
      std::string::__init(&v175, v53, v55);
      int v56 = SHIBYTE(v175.__r_.__value_.__r.__words[2]);
      std::string::size_type size = v175.__r_.__value_.__l.__size_;
      unsigned int v58 = (void *)v175.__r_.__value_.__r.__words[0];
      unsigned int v59 = &v175;
      if ((v175.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v175.__r_.__value_.__r.__words[2]);
      }
      else {
        unsigned int v59 = (std::string *)v175.__r_.__value_.__r.__words[0];
      }
      v174[0] = (uint64_t)v59;
      v174[1] = size;
      uint64_t v60 = llvm::StringRef::find(v174, "memprof/memprof_", 0x10uLL, 0);
      if (v56 < 0) {
        operator delete(v58);
      }
      if (v60 != -1)
      {
LABEL_157:
        sub_1CD4ADCD0((uint64_t)v172, &v171, (uint64_t)&v175);
        goto LABEL_141;
      }
      uint64_t v61 = v177;
      if (!v177)
      {
        v109 = (char *)v176;
        unint64_t v12 = v169;
        goto LABEL_152;
      }
      uint64_t v62 = 0;
      uint64_t v63 = v177 - 1;
      do
      {
        int32x2_t v64 = (char *)v176 + 136 * v62;
        long long v67 = (int *)*((void *)v64 + 3);
        long long v66 = v64 + 24;
        uint64_t v65 = v67;
        char v68 = v66[23];
        int v69 = v68;
        if (v68 >= 0) {
          long long v70 = (int *)v66;
        }
        else {
          long long v70 = v65;
        }
        unint64_t v71 = v68 & 0x7F;
        if (v69 >= 0) {
          unint64_t v72 = v71;
        }
        else {
          unint64_t v72 = *((void *)v66 + 1);
        }
        uint64_t GUID = llvm::memprof::IndexedMemProfRecord::getGUID(v70, v72);
        uint64_t v74 = *((unsigned int *)v66 + 19);
        uint64_t v75 = (*((_DWORD *)v66 + 18) - *((_DWORD *)v66 + 20));
        unint64_t v76 = (((GUID - 0x61C8864680B583EBLL) << 6)
             - 0x61C8864680B583EBLL
             + ((unint64_t)(GUID - 0x61C8864680B583EBLL) >> 2)
             + v75) ^ (GUID - 0x61C8864680B583EBLL);
        unint64_t v77 = (v74 - 0x61C8864680B583EBLL + (v76 << 6) + (v76 >> 2)) ^ v76;
        if (v62 == v63) {
          unint64_t v78 = 0x9E3779B97F4A7C15;
        }
        else {
          unint64_t v78 = 0x9E3779B97F4A7C16;
        }
        unint64_t v79 = (v78 + (v77 << 6) + (v77 >> 2)) ^ v77;
        unsigned int v80 = *((_DWORD *)this + 264);
        if (v80)
        {
          uint64_t v81 = *((void *)this + 130);
          uint64_t v82 = (37 * v79) & (v80 - 1);
          uint64_t v83 = (unint64_t *)(v81 + 32 * v82);
          unint64_t v84 = *v83;
          if (v79 == *v83) {
            goto LABEL_110;
          }
          uint64_t v85 = 0;
          int v86 = 1;
          while (v84 != -1)
          {
            if (v85) {
              BOOL v87 = 0;
            }
            else {
              BOOL v87 = v84 == -2;
            }
            if (v87) {
              uint64_t v85 = v83;
            }
            int v88 = v82 + v86++;
            uint64_t v82 = v88 & (v80 - 1);
            uint64_t v83 = (unint64_t *)(v81 + 32 * v82);
            unint64_t v84 = *v83;
            if (v79 == *v83) {
              goto LABEL_110;
            }
          }
          if (v85) {
            uint64_t v89 = v85;
          }
          else {
            uint64_t v89 = v83;
          }
        }
        else
        {
          uint64_t v89 = 0;
        }
        int v90 = *((_DWORD *)this + 262);
        if (4 * v90 + 4 >= 3 * v80)
        {
          sub_1CCD04678(v162, 2 * v80);
          uint64_t v94 = *((void *)this + 130);
          int v95 = *((_DWORD *)this + 264) - 1;
          uint64_t v96 = v95 & (37 * v79);
          uint64_t v89 = (unint64_t *)(v94 + 32 * v96);
          unint64_t v97 = *v89;
          if (v79 == *v89) {
            goto LABEL_128;
          }
          BOOL v98 = 0;
          int v99 = 1;
          while (v97 != -1)
          {
            if (v98) {
              BOOL v100 = 0;
            }
            else {
              BOOL v100 = v97 == -2;
            }
            if (v100) {
              BOOL v98 = v89;
            }
            int v101 = v96 + v99++;
            uint64_t v96 = v101 & v95;
            uint64_t v89 = (unint64_t *)(v94 + 32 * v96);
            unint64_t v97 = *v89;
            if (v79 == *v89) {
              goto LABEL_128;
            }
          }
LABEL_138:
          if (v98) {
            uint64_t v89 = v98;
          }
          goto LABEL_106;
        }
        if (v80 + ~v90 - *((_DWORD *)this + 263) <= v80 >> 3)
        {
          sub_1CCD04678(v162, v80);
          uint64_t v102 = *((void *)this + 130);
          int v103 = *((_DWORD *)this + 264) - 1;
          uint64_t v104 = v103 & (37 * v79);
          uint64_t v89 = (unint64_t *)(v102 + 32 * v104);
          unint64_t v105 = *v89;
          if (v79 == *v89)
          {
LABEL_128:
            unint64_t v91 = v79;
            goto LABEL_107;
          }
          BOOL v98 = 0;
          int v106 = 1;
          while (v105 != -1)
          {
            if (v98) {
              BOOL v107 = 0;
            }
            else {
              BOOL v107 = v105 == -2;
            }
            if (v107) {
              BOOL v98 = v89;
            }
            int v108 = v104 + v106++;
            uint64_t v104 = v108 & v103;
            uint64_t v89 = (unint64_t *)(v102 + 32 * v104);
            unint64_t v105 = *v89;
            if (v79 == *v89) {
              goto LABEL_128;
            }
          }
          goto LABEL_138;
        }
LABEL_106:
        unint64_t v91 = *v89;
LABEL_107:
        ++*((_DWORD *)this + 262);
        if (v91 != -1) {
          --*((_DWORD *)this + 263);
        }
        unint64_t *v89 = v79;
        v89[1] = GUID;
        *((_DWORD *)v89 + 4) = v75;
        *((_DWORD *)v89 + 5) = v74;
        *((unsigned char *)v89 + 24) = v62 != v63;
LABEL_110:
        sub_1CCD03AF0(v170, &v171);
        unint64_t v93 = *(unsigned int *)(v92 + 16);
        if (v93 >= *(unsigned int *)(v92 + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v92 + 8) + 8 * v93) = v79;
        ++*(_DWORD *)(v92 + 16);
        ++v62;
      }
      while (v62 != v61);
      unsigned int v9 = v167;
LABEL_141:
      v109 = (char *)v176;
      unint64_t v12 = v169;
      if (v177)
      {
        uint64_t v110 = 136 * v177;
        do
        {
          v111 = (void **)&v109[v110];
          if (v109[v110 - 65] < 0) {
            operator delete(*(v111 - 11));
          }
          if (*((char *)v111 - 89) < 0) {
            operator delete(*(void **)&v109[v110 - 112]);
          }
          if (v109[v110 - 113] < 0) {
            operator delete(*(v111 - 17));
          }
          v110 -= 136;
        }
        while (v110);
        v109 = (char *)v176;
      }
LABEL_152:
      if (v109 != v9) {
        free(v109);
      }
      sub_1CCD045A0(&v179);
LABEL_155:
      ++v10;
    }
    while (v10 != v12);
    unint64_t v8 = v166;
    uint64_t v10 = (uint64_t *)v166[1];
    uint64_t v112 = *((unsigned int *)v166 + 4);
    if (!v112)
    {
      v117 = (uint64_t *)v166[1];
      uint64_t v6 = v164;
      goto LABEL_171;
    }
    uint64_t v113 = &v10[v112];
    uint64_t v114 = v172[0];
    uint64_t v115 = v172[0] + 8 * v173;
    unsigned int v116 = v173 - 1;
    v117 = (uint64_t *)v166[1];
    uint64_t v6 = v164;
    while (2)
    {
      if (v173)
      {
        LODWORD(v118) = v116 & (37 * *v117);
        v119 = (uint64_t *)(v172[0] + 8 * v118);
        uint64_t v120 = *v119;
        if (*v119 != *v117)
        {
          int v121 = 1;
          do
          {
            if (v120 == -1) {
              goto LABEL_163;
            }
            int v122 = v118 + v121++;
            uint64_t v118 = v122 & v116;
            uint64_t v120 = *(void *)(v172[0] + 8 * v118);
          }
          while (v120 != *v117);
          v119 = (uint64_t *)(v172[0] + 8 * v118);
        }
        if ((uint64_t *)v115 != v119)
        {
          for (unint64_t i = v117 + 1; ; ++i)
          {
            if (i == v113) {
              goto LABEL_171;
            }
            uint64_t v127 = *i;
            LODWORD(v128) = (37 * *i) & v116;
            v129 = (uint64_t *)(v114 + 8 * v128);
            uint64_t v130 = *v129;
            if (*v129 == *i)
            {
LABEL_184:
              if ((uint64_t *)v115 != v129) {
                continue;
              }
            }
            else
            {
              int v131 = 1;
              while (v130 != -1)
              {
                int v132 = v128 + v131++;
                uint64_t v128 = v132 & v116;
                uint64_t v130 = *(void *)(v114 + 8 * v128);
                if (v130 == v127)
                {
                  v129 = (uint64_t *)(v114 + 8 * v128);
                  goto LABEL_184;
                }
              }
            }
            *v117++ = v127;
          }
        }
      }
LABEL_163:
      if (++v117 != v113) {
        continue;
      }
      break;
    }
    v117 = v113;
LABEL_171:
    unint64_t v123 = (unint64_t)((char *)v117 - (char *)v10) >> 3;
    *((_DWORD *)v8 + 4) = v123;
    if (!v123)
    {
      if (v184 >= (unint64_t)HIDWORD(v184)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v183[v184] = (void *)*v8;
      LODWORD(v184) = v184 + 1;
    }
    v124 = v8 + 9;
    while (v124 != v6)
    {
      unint64_t v125 = *v124;
      v124 += 9;
      if (v125 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unint64_t v8 = v124 - 9;
        goto LABEL_179;
      }
    }
    unint64_t v8 = v6;
LABEL_179:
    ;
  }
  while (v8 != v165);
  if (v184)
  {
    v134 = v183;
    v135 = &v183[v184];
    do
    {
      v176 = *v134;
      v179 = 0;
      if (sub_1CCD03BDC(*((void *)this + 124), *((_DWORD *)this + 252), (uint64_t)v176, &v179))
      {
        v136 = v179;
        v137 = (char *)*((void *)v179 + 1);
        if (v137 != v179 + 24) {
          free(v137);
        }
        *(void *)v136 = -2;
        *((int32x2_t *)this + 125) = vadd_s32(*(int32x2_t *)((char *)this + 1000), (int32x2_t)0x1FFFFFFFFLL);
      }
      v138 = sub_1CD5A11BC((uint64_t *)this + 118, &v176);
      uint64_t v139 = *((void *)this + 118);
      uint64_t v140 = *((unsigned int *)this + 240);
      if ((uint64_t *)(v139 + 16 * v140) != v138)
      {
        v141 = (void *)(*((void *)this + 121) + 112 * *((unsigned int *)v138 + 2));
        v142 = (void *)*((void *)this + 122);
        if (v141 != v142)
        {
          if (v140)
          {
            unsigned int v143 = v140 - 1;
            LODWORD(v140) = (37 * *v141) & (v140 - 1);
            v144 = (uint64_t *)(v139 + 16 * v140);
            uint64_t v145 = *v144;
            if (*v144 == *v141)
            {
LABEL_203:
              uint64_t *v144 = -2;
              *((int32x2_t *)this + 119) = vadd_s32(*(int32x2_t *)((char *)this + 952), (int32x2_t)0x1FFFFFFFFLL);
            }
            else
            {
              int v160 = 1;
              while (v145 != -1)
              {
                int v161 = v140 + v160++;
                uint64_t v140 = v161 & v143;
                uint64_t v145 = *(void *)(v139 + 16 * v140);
                if (v145 == *v141)
                {
                  v144 = (uint64_t *)(v139 + 16 * v140);
                  goto LABEL_203;
                }
              }
            }
          }
          v146 = v141 + 14;
          if (v141 + 14 == v142)
          {
            *((void *)this + 122) = v141;
          }
          else
          {
            uint64_t v147 = 0;
            do
            {
              v148 = &v146[v147];
              *(v148 - 14) = v146[v147];
              *(_OWORD *)(v148 - 7) = *(_OWORD *)&v146[v147 + 7];
              *(_OWORD *)(v148 - 5) = *(_OWORD *)&v146[v147 + 9];
              *(_OWORD *)(v148 - 3) = *(_OWORD *)&v146[v147 + 11];
              *((_DWORD *)v148 - 2) = v146[v147 + 13];
              *(_OWORD *)(v148 - 13) = *(_OWORD *)&v146[v147 + 1];
              *(_OWORD *)(v148 - 11) = *(_OWORD *)&v146[v147 + 3];
              long long v149 = *(_OWORD *)&v146[v147 + 5];
              v147 += 14;
              *(_OWORD *)(v148 - 9) = v149;
            }
            while (v148 + 14 != v142);
            *((void *)this + 122) = &v141[v147];
            if (v147 * 8)
            {
              uint64_t v150 = *((void *)this + 118);
              uint64_t v151 = *((unsigned int *)this + 240);
              v152 = (unint64_t *)(v150 + 16 * v151);
              if (*((_DWORD *)this + 238))
              {
                if (*((_DWORD *)this + 240))
                {
                  uint64_t v153 = 16 * v151;
                  v154 = (unint64_t *)*((void *)this + 118);
                  while (*v154 >= 0xFFFFFFFFFFFFFFFELL)
                  {
                    v154 += 2;
                    v153 -= 16;
                    if (!v153) {
                      goto LABEL_213;
                    }
                  }
                }
                else
                {
                  v154 = (unint64_t *)*((void *)this + 118);
                }
              }
              else
              {
LABEL_213:
                v154 = (unint64_t *)(v150 + 16 * v151);
              }
              v155 = (unint64_t *)(v150 + 16 * v151);
              if (v154 != v155)
              {
                unint64_t v156 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v141 - *((void *)this + 121)) >> 4);
                do
                {
                  unint64_t v157 = *((unsigned int *)v154 + 2);
                  if (v156 < v157) {
                    *((_DWORD *)v154 + 2) = v157 - 1;
                  }
                  v158 = v154 + 2;
                  while (v158 != v152)
                  {
                    unint64_t v159 = *v158;
                    v158 += 2;
                    if (v159 <= 0xFFFFFFFFFFFFFFFDLL)
                    {
                      v154 = v158 - 2;
                      goto LABEL_225;
                    }
                  }
                  v154 = v152;
LABEL_225:
                  ;
                }
                while (v154 != v155);
              }
            }
          }
        }
      }
      ++v134;
    }
    while (v134 != v135);
  }
LABEL_232:
  if (!*((_DWORD *)this + 250)) {
    operator new();
  }
  *a2 = 0;
LABEL_235:
  MEMORY[0x1D25D9CD0](v172[0], 8);
  if (v183 != v185) {
    free(v183);
  }
}

uint64_t llvm::memprof::RawMemProfReader::mapRawProfileToRecords@<X0>(llvm::memprof::RawMemProfReader *this@<X0>, void *a2@<X8>)
{
  v130[6] = *MEMORY[0x1E4F143B8];
  int v99 = 0;
  uint64_t v100 = 0;
  unsigned int v101 = 0;
  int v3 = (void *)*((void *)this + 121);
  uint64_t v4 = &unk_1CD91C000;
  uint64_t v89 = (void *)*((void *)this + 122);
  if (v3 == v89)
  {
    unsigned int v63 = 0;
    uint64_t v62 = 0;
LABEL_100:
    long long v66 = (unint64_t *)(v62 + 56 * v63);
    int32x2_t v64 = v66;
    goto LABEL_104;
  }
  int v90 = (char *)this + 1016;
  int v95 = (void *)((char *)this + 1064);
  do
  {
    uint64_t v5 = *v3;
    uint64_t v98 = *v3;
    uint64_t v6 = *((void *)this + 124);
    unsigned int v7 = *((_DWORD *)this + 252);
    if (v7)
    {
      unsigned int v8 = (v7 - 1) & (37 * v5);
      unsigned int v9 = (uint64_t *)(v6 + 72 * v8);
      uint64_t v10 = *v9;
      if (v5 == *v9) {
        goto LABEL_10;
      }
      int v11 = 1;
      while (v10 != -1)
      {
        unsigned int v12 = v8 + v11++;
        unsigned int v8 = v12 & (v7 - 1);
        unsigned int v9 = (uint64_t *)(v6 + 72 * v8);
        uint64_t v10 = *v9;
        if (v5 == *v9) {
          goto LABEL_10;
        }
      }
    }
    unsigned int v9 = (uint64_t *)(v6 + 72 * v7);
LABEL_10:
    if (v9 == (uint64_t *)(v6 + 72 * v7))
    {
      int v121 = "memprof callstack record does not contain id: ";
      uint64_t v123 = (uint64_t)&v98;
      v124[4] = 3075;
      operator new();
    }
    unint64_t v93 = v3;
    uint64_t v128 = v130;
    uint64_t v129 = 0x600000000;
    if (*((_DWORD *)v9 + 4) >= 7u) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (*((_DWORD *)v9 + 4))
    {
      uint64_t v13 = 0;
      uint64_t v91 = *((unsigned int *)v9 + 4);
      uint64_t v92 = v9[1];
      while (1)
      {
        uint64_t v102 = *(char **)(v92 + 8 * v13);
        sub_1CCD03AF0((uint64_t)v90, (uint64_t *)&v102);
        uint64_t v15 = (unsigned char **)(v14 + 8);
        unint64_t v16 = *(unsigned int *)(v14 + 16);
        if (v16) {
          break;
        }
        unint64_t v16 = 0;
LABEL_17:
        sub_1CBFCBB74((unsigned int *)&v128, *v15, &(*v15)[8 * v16]);
        if (++v13 == v91) {
          goto LABEL_59;
        }
      }
      uint64_t v17 = v14;
      uint64_t v18 = 0;
      while (2)
      {
        if (!(v18 | v13)) {
          goto LABEL_52;
        }
        uint64_t v19 = sub_1CCD0391C(*((void *)this + 130), *((_DWORD *)this + 264), *(void *)&(*v15)[8 * v18])[1];
        int v121 = 0;
        unsigned int v20 = v101;
        int v21 = sub_1CCD03E04((uint64_t)v99, v101, v19, &v121);
        uint64_t v22 = (char *)v121;
        if (v21)
        {
          uint64_t v23 = *((void *)v121 + 1);
          goto LABEL_28;
        }
        if (4 * (int)v100 + 4 >= 3 * v20)
        {
          int v38 = 2 * v20;
        }
        else
        {
          if (v20 + ~v100 - HIDWORD(v100) > v20 >> 3)
          {
LABEL_25:
            LODWORD(v100) = v100 + 1;
            if (*(void *)v22 != -1) {
              --HIDWORD(v100);
            }
            uint64_t v23 = 0;
            *(void *)uint64_t v22 = v19;
            *(_OWORD *)(v22 + 8) = 0u;
            *(_OWORD *)(v22 + 24) = 0u;
            *(_OWORD *)(v22 + 40) = 0u;
LABEL_28:
            int v121 = 0;
            if ((sub_1CC091A20(v23, *((_DWORD *)v22 + 6), (uint64_t)v15, &v121) & 1) == 0)
            {
              unsigned int v24 = *((_DWORD *)v22 + 6);
              int v25 = *((_DWORD *)v22 + 4);
              if (4 * v25 + 4 >= 3 * v24)
              {
                v24 *= 2;
              }
              else if (v24 + ~v25 - *((_DWORD *)v22 + 5) > v24 >> 3)
              {
                goto LABEL_31;
              }
              sub_1CC091AB4((uint64_t)(v22 + 8), v24);
              int v121 = 0;
              sub_1CC091A20(*((void *)v22 + 1), *((_DWORD *)v22 + 6), (uint64_t)v15, &v121);
LABEL_31:
              unsigned int v26 = (char *)v121;
              ++*((_DWORD *)v22 + 4);
              if (*(void *)v26 != -4096) {
                --*((_DWORD *)v22 + 5);
              }
              *(void *)unsigned int v26 = v15;
              char v28 = (void *)*((void *)v22 + 5);
              unint64_t v27 = *((void *)v22 + 6);
              if ((unint64_t)v28 >= v27)
              {
                int v30 = (void *)*((void *)v22 + 4);
                uint64_t v31 = v28 - v30;
                unint64_t v32 = v31 + 1;
                if ((unint64_t)(v31 + 1) >> 61) {
                  abort();
                }
                uint64_t v33 = v27 - (void)v30;
                if (v33 >> 2 > v32) {
                  unint64_t v32 = v33 >> 2;
                }
                if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v34 = v32;
                }
                if (v34)
                {
                  if (v34 >> 61) {
                    sub_1CB833614();
                  }
                  long long v35 = (char *)operator new(8 * v34);
                }
                else
                {
                  long long v35 = 0;
                }
                long long v36 = &v35[8 * v31];
                *(void *)long long v36 = v15;
                int v29 = v36 + 8;
                if (v28 != v30)
                {
                  do
                  {
                    uint64_t v37 = *--v28;
                    *((void *)v36 - 1) = v37;
                    v36 -= 8;
                  }
                  while (v28 != v30);
                  char v28 = (void *)*((void *)v22 + 4);
                }
                *((void *)v22 + 4) = v36;
                *((void *)v22 + 5) = v29;
                *((void *)v22 + 6) = &v35[8 * v34];
                if (v28) {
                  operator delete(v28);
                }
              }
              else
              {
                *char v28 = v15;
                int v29 = v28 + 1;
              }
              *((void *)v22 + 5) = v29;
            }
            unint64_t v16 = *(unsigned int *)(v17 + 16);
LABEL_52:
            if (++v18 >= v16) {
              goto LABEL_17;
            }
            continue;
          }
          int v38 = v20;
        }
        break;
      }
      sub_1CCD03E9C((uint64_t)&v99, v38);
      int v121 = 0;
      sub_1CCD03E04((uint64_t)v99, v101, v19, &v121);
      uint64_t v22 = (char *)v121;
      goto LABEL_25;
    }
LABEL_59:
    uint64_t v39 = 0;
    uint64_t v40 = (uint64_t)(v93 + 1);
    do
    {
      long long v41 = sub_1CCD0391C(*((void *)this + 130), *((_DWORD *)this + 264), v128[v39]);
      uint64_t v120 = 0;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      long long v113 = 0u;
      uint64_t v114 = 0;
      long long v111 = 0u;
      long long v112 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v104 = 0u;
      uint64_t v102 = (char *)&v104;
      uint64_t v103 = 0x100000000;
      uint64_t v115 = (char *)&v116 + 8;
      DWORD1(v116) = 1;
      int v121 = (const char *)v41[1];
      int v122 = (char *)v124;
      uint64_t v123 = 0x100000000;
      unint64_t v125 = v127;
      uint64_t v126 = 0x100000000;
      uint64_t v42 = sub_1CCCEE018(v95, &v121, (uint64_t)&v122);
      long long v43 = (char *)v125;
      if (v126)
      {
        unint64_t v44 = (unint64_t)v126 << 6;
        do
        {
          long long v45 = *(char **)&v43[v44 - 64];
          if (&v43[v44 - 48] != v45) {
            free(v45);
          }
          v44 -= 64;
        }
        while (v44);
        long long v43 = (char *)v125;
      }
      if (v43 != v127) {
        free(v43);
      }
      sub_1CD74EA50(&v122);
      long long v46 = (char *)v115;
      if (v116)
      {
        unint64_t v47 = (unint64_t)v116 << 6;
        do
        {
          unint64_t v48 = *(char **)&v46[v47 - 64];
          if (&v46[v47 - 48] != v48) {
            free(v48);
          }
          v47 -= 64;
        }
        while (v47);
        long long v46 = (char *)v115;
      }
      if (v46 != (char *)&v116 + 8) {
        free(v46);
      }
      sub_1CD74EA50(&v102);
      unsigned int v50 = *(_DWORD *)(v42 + 16);
      uint64_t v49 = *(unsigned int *)(v42 + 20);
      if (v50 >= v49)
      {
        if (v49 == -1) {
          sub_1CD0A89A8(0xFFFFFFFFuLL);
        }
        unint64_t v54 = (2 * v49) | 1;
        if (v54 >= 0xFFFFFFFF) {
          uint64_t v55 = 0xFFFFFFFFLL;
        }
        else {
          uint64_t v55 = v54;
        }
        int v56 = (char *)malloc_type_malloc(168 * v55, 0x4065EBACuLL);
        if (!v56) {
          llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
        }
        uint64_t v57 = (uint64_t)v56;
        unsigned int v58 = &v56[168 * *(unsigned int *)(v42 + 16)];
        unsigned int v59 = v128;
        uint64_t v60 = &v128[v129];
        *(void *)unsigned int v58 = v58 + 16;
        *((void *)v58 + 1) = 0x600000000;
        sub_1CBFCBB74((unsigned int *)v58, v59, v60);
        sub_1CCD04050((uint64_t)(v58 + 64), v40);
        sub_1CD74F7A8(v42 + 8, v57);
        uint64_t v61 = *(void **)(v42 + 8);
        if (v61 != (void *)(v42 + 24)) {
          free(v61);
        }
        *(void *)(v42 + 8) = v57;
        *(_DWORD *)(v42 + 20) = v55;
      }
      else
      {
        uint64_t v51 = *(void *)(v42 + 8) + 168 * v50;
        BOOL v52 = v128;
        uint64_t v53 = &v128[v129];
        *(void *)uint64_t v51 = v51 + 16;
        *(void *)(v51 + 8) = 0x600000000;
        sub_1CBFCBB74((unsigned int *)v51, v52, v53);
        sub_1CCD04050(v51 + 64, v40);
      }
      ++*(_DWORD *)(v42 + 16);
      ++v39;
    }
    while (*((unsigned char *)v41 + 24));
    if (v128 != v130) {
      free(v128);
    }
    int v3 = v93 + 14;
  }
  while (v93 + 14 != v89);
  uint64_t v62 = (uint64_t)v99;
  unsigned int v63 = v101;
  if (!v100)
  {
    uint64_t v4 = (void *)&unk_1CD91C000;
    goto LABEL_100;
  }
  int32x2_t v64 = &v99[7 * v101];
  if (v101)
  {
    uint64_t v65 = 0;
    while (v99[v65] >= 0xFFFFFFFFFFFFFFFELL)
    {
      v65 += 7;
      if (7 * v101 == v65)
      {
        long long v66 = &v99[7 * v101];
        goto LABEL_103;
      }
    }
    long long v66 = &v99[v65];
  }
  else
  {
    long long v66 = v99;
  }
LABEL_103:
  uint64_t v4 = &unk_1CD91C000;
LABEL_104:
  unsigned int v94 = v63;
  uint64_t v96 = (unint64_t *)(v62 + 56 * v63);
  if (v66 != v96)
  {
    long long v67 = (char *)&v116 + 8;
    char v68 = &v122;
    uint64_t v69 = v4[25];
    do
    {
      long long v70 = (const char *)*v66;
      uint64_t v120 = 0;
      long long v118 = 0u;
      long long v119 = 0u;
      long long v116 = 0u;
      long long v117 = 0u;
      long long v113 = 0u;
      uint64_t v114 = 0;
      long long v111 = 0u;
      long long v112 = 0u;
      long long v109 = 0u;
      long long v110 = 0u;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v105 = 0u;
      long long v106 = 0u;
      long long v104 = 0u;
      uint64_t v102 = (char *)&v104;
      uint64_t v103 = v69;
      uint64_t v115 = v67;
      DWORD1(v116) = 1;
      int v121 = v70;
      int v122 = (char *)v124;
      uint64_t v123 = v69;
      unint64_t v125 = v127;
      uint64_t v126 = v69;
      uint64_t v97 = sub_1CCCEE018((void *)this + 133, &v121, (uint64_t)v68);
      unint64_t v71 = (char *)v125;
      if (v126)
      {
        unint64_t v72 = (unint64_t)v126 << 6;
        do
        {
          uint64_t v73 = *(char **)&v71[v72 - 64];
          if (&v71[v72 - 48] != v73) {
            free(v73);
          }
          v72 -= 64;
        }
        while (v72);
        unint64_t v71 = (char *)v125;
      }
      if (v71 != v127) {
        free(v71);
      }
      sub_1CD74EA50(v68);
      uint64_t v74 = (char *)v115;
      if (v116)
      {
        unint64_t v75 = (unint64_t)v116 << 6;
        do
        {
          unint64_t v76 = *(char **)&v74[v75 - 64];
          if (&v74[v75 - 48] != v76) {
            free(v76);
          }
          v75 -= 64;
        }
        while (v75);
        uint64_t v74 = (char *)v115;
      }
      unint64_t v77 = v68;
      unint64_t v78 = v67;
      if (v74 != v67) {
        free(v74);
      }
      sub_1CD74EA50(&v102);
      unsigned int v80 = (unint64_t *)v66[4];
      unint64_t v79 = (unint64_t *)v66[5];
      while (v80 != v79)
      {
        unint64_t v81 = *v80++;
        sub_1CCCF0740(v97 + 192, v81);
      }
      uint64_t v82 = v66 + 7;
      long long v67 = v78;
      char v68 = v77;
      while (v82 != v64)
      {
        unint64_t v83 = *v82;
        v82 += 7;
        if (v83 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          long long v66 = v82 - 7;
          goto LABEL_129;
        }
      }
      long long v66 = v64;
LABEL_129:
      ;
    }
    while (v66 != v96);
  }
  *a2 = 0;
  if (v94)
  {
    uint64_t v84 = 56 * v94;
    uint64_t v85 = (void *)(v62 + 40);
    do
    {
      if (*(v85 - 5) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v86 = (void *)*(v85 - 1);
        if (v86)
        {
          void *v85 = v86;
          operator delete(v86);
        }
        MEMORY[0x1D25D9CD0](*(v85 - 4), 8);
      }
      v85 += 7;
      v84 -= 56;
    }
    while (v84);
  }
  return MEMORY[0x1D25D9CD0](v62, 8);
}

uint64_t llvm::memprof::RawMemProfReader::getModuleOffset(llvm::memprof::RawMemProfReader *this, uint64_t a2)
{
  return a2;
}

uint64_t sub_1CCD03068(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v35 = *a2;
  int v36 = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = *(void *)a1;
    unsigned int v7 = v5 - 1;
    uint64_t v8 = (v5 - 1) & (37 * v4);
    unsigned int v9 = (void *)(*(void *)a1 + 16 * v8);
    uint64_t v10 = *v9;
    if (v4 == *v9)
    {
LABEL_3:
      unsigned int v11 = *(_DWORD *)(v6 + 16 * v8 + 8);
      uint64_t v12 = *(void *)(a1 + 24);
      return v12 + 112 * v11 + 8;
    }
    uint64_t v31 = 0;
    int v32 = 1;
    while (v10 != -1)
    {
      if (v31) {
        BOOL v33 = 0;
      }
      else {
        BOOL v33 = v10 == -2;
      }
      if (v33) {
        uint64_t v31 = v9;
      }
      int v34 = v8 + v32++;
      uint64_t v8 = v34 & v7;
      unsigned int v9 = (void *)(v6 + 16 * v8);
      uint64_t v10 = *v9;
      if (v4 == *v9) {
        goto LABEL_3;
      }
    }
    if (v31) {
      uint64_t v14 = v31;
    }
    else {
      uint64_t v14 = v9;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  uint64_t v15 = sub_1CD541520(a1, (uint64_t)&v35, &v35, v14);
  *uint64_t v15 = v35;
  *((_DWORD *)v15 + 2) = v36;
  uint64_t v16 = *a2;
  uint64_t v18 = *(uint64_t **)(a1 + 32);
  unint64_t v17 = *(void *)(a1 + 40);
  if ((unint64_t)v18 >= v17)
  {
    unsigned int v20 = *(char **)(a1 + 24);
    unint64_t v21 = 0x6DB6DB6DB6DB6DB7 * (((char *)v18 - v20) >> 4) + 1;
    if (v21 > 0x249249249249249) {
      abort();
    }
    unint64_t v22 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v17 - (void)v20) >> 4);
    if (2 * v22 > v21) {
      unint64_t v21 = 2 * v22;
    }
    if (v22 >= 0x124924924924924) {
      unint64_t v23 = 0x249249249249249;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23)
    {
      if (v23 > 0x249249249249249) {
        sub_1CB833614();
      }
      unsigned int v24 = (char *)operator new(112 * v23);
    }
    else
    {
      unsigned int v24 = 0;
    }
    int v25 = &v24[16 * (((char *)v18 - v20) >> 4)];
    *(void *)int v25 = v16;
    *(_OWORD *)(v25 + 8) = 0u;
    *(_OWORD *)(v25 + 24) = 0u;
    *(_OWORD *)(v25 + 40) = 0u;
    uint64_t v19 = v25 + 112;
    *(_OWORD *)(v25 + 56) = 0u;
    *(_OWORD *)(v25 + 72) = 0u;
    *(_OWORD *)(v25 + 88) = 0u;
    *((_DWORD *)v25 + 26) = 0;
    if (v18 != (uint64_t *)v20)
    {
      do
      {
        long long v26 = *((_OWORD *)v18 - 7);
        long long v27 = *((_OWORD *)v18 - 5);
        *((_OWORD *)v25 - 6) = *((_OWORD *)v18 - 6);
        *((_OWORD *)v25 - 5) = v27;
        *((_OWORD *)v25 - 7) = v26;
        long long v28 = *((_OWORD *)v18 - 4);
        long long v29 = *((_OWORD *)v18 - 3);
        long long v30 = *((_OWORD *)v18 - 1);
        *((_OWORD *)v25 - 2) = *((_OWORD *)v18 - 2);
        *((_OWORD *)v25 - 1) = v30;
        *((_OWORD *)v25 - 4) = v28;
        *((_OWORD *)v25 - 3) = v29;
        v25 -= 112;
        v18 -= 14;
      }
      while (v18 != (uint64_t *)v20);
      uint64_t v18 = *(uint64_t **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v25;
    *(void *)(a1 + 32) = v19;
    *(void *)(a1 + 40) = &v24[112 * v23];
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    uint64_t *v18 = v16;
    uint64_t v19 = v18 + 14;
    *(_OWORD *)(v18 + 1) = 0u;
    *(_OWORD *)(v18 + 3) = 0u;
    *(_OWORD *)(v18 + 5) = 0u;
    *(_OWORD *)(v18 + 7) = 0u;
    *(_OWORD *)(v18 + 9) = 0u;
    *(_OWORD *)(v18 + 11) = 0u;
    *((_DWORD *)v18 + 26) = 0;
  }
  *(void *)(a1 + 32) = v19;
  uint64_t v12 = *(void *)(a1 + 24);
  unsigned int v11 = -1227133513 * (((unint64_t)v19 - v12) >> 4) - 1;
  *((_DWORD *)v15 + 2) = v11;
  return v12 + 112 * v11 + 8;
}

char **llvm::memprof::RawMemProfReader::readNextRecord@<X0>(void *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  v18[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t *)a1[137];
  if ((uint64_t *)a1[136] == v4) {
    operator new();
  }
  uint64_t v6 = (uint64_t *)a1[139];
  if (v6 == v4) {
    operator new();
  }
  unsigned int v9 = a1;
  sub_1CCCE7108(&v10, (uint64_t)(v6 + 1), (void (*)(void *__return_ptr, uint64_t, uint64_t))sub_1CCD04814, (uint64_t)&v9);
  uint64_t v14 = *v6;
  v15[0] = (char *)&v16;
  v15[1] = (char *)0x100000000;
  if (v11) {
    sub_1CCCE8F44((uint64_t)v15, (uint64_t)&v10);
  }
  v17[0] = (char *)v18;
  v17[1] = (char *)0x100000000;
  if (v13) {
    sub_1CCCE92C8((uint64_t)v17, (uint64_t)&v12);
  }
  *a2 = v14;
  sub_1CCCE8F44((uint64_t)(a2 + 1), (uint64_t)v15);
  sub_1CCCE92C8((uint64_t)(a2 + 24), (uint64_t)v17);
  sub_1CD4D68AC(v17);
  sub_1CD74EA50(v15);
  sub_1CD4D68AC(&v12);
  uint64_t result = sub_1CD74EA50(&v10);
  a1[139] += 272;
  *a3 = 0;
  return result;
}

char **sub_1CCD03500(uint64_t a1)
{
  v9[10] = *(char **)MEMORY[0x1E4F143B8];
  uint64_t result = llvm::memprof::RawMemProfReader::readNextRecord(*(void **)a1, (void *)(a1 + 8), &v4);
  if (v4)
  {
    int v3 = v4;
    sub_1CD5DD9F0(&v3);
    if (v3) {
      (*(void (**)(void *))(*v3 + 8))(v3);
    }
    memset(&v9[1], 0, 72);
    uint64_t v8 = 0;
    v6[1] = (char *)0x100000000;
    memset(v7, 0, sizeof(v7));
    long long v5 = 0u;
    v6[0] = (char *)v7;
    v9[0] = (char *)&v9[2];
    HIDWORD(v9[1]) = 1;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    sub_1CCCE8F44(a1 + 16, (uint64_t)v6);
    sub_1CCCE92C8(a1 + 200, (uint64_t)v9);
    sub_1CD4D68AC(v9);
    return sub_1CD74EA50(v6);
  }
  return result;
}

llvm::raw_ostream *sub_1CCD03630(uint64_t a1, llvm::raw_ostream *this)
{
  uint64_t v4 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v4 > 7uLL)
  {
    *uint64_t v4 = 0xA2D202020202020;
    uint64_t v5 = *((void *)this + 4) + 8;
    *((void *)this + 4) = v5;
  }
  else
  {
    llvm::raw_ostream::write(this, "      -\n", 8uLL);
    uint64_t v5 = *((void *)this + 4);
  }
  if ((unint64_t)(*((void *)this + 3) - v5) > 0x11)
  {
    *(_WORD *)(v5 + 16) = 8250;
    *(_OWORD *)uint64_t v5 = *(_OWORD *)"        Function: ";
    *((void *)this + 4) += 18;
  }
  else
  {
    llvm::raw_ostream::write(this, "        Function: ", 0x12uLL);
  }
  sub_1CD098D14(this, *(void *)a1, 0, 0, 0);
  uint64_t v6 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v6)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
    uint64_t v7 = *((void *)this + 4);
  }
  else
  {
    *uint64_t v6 = 10;
    uint64_t v7 = *((void *)this + 4) + 1;
    *((void *)this + 4) = v7;
  }
  if ((unint64_t)(*((void *)this + 3) - v7) > 0x13)
  {
    *(_DWORD *)(v7 + 16) = 540701797;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)"        LineOffset: ";
    *((void *)this + 4) += 20;
  }
  else
  {
    llvm::raw_ostream::write(this, "        LineOffset: ", 0x14uLL);
  }
  sub_1CD098D14(this, *(unsigned int *)(a1 + 8), 0, 0, 0);
  uint64_t v8 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v8)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
    unsigned int v9 = (_OWORD *)*((void *)this + 4);
  }
  else
  {
    unsigned char *v8 = 10;
    unsigned int v9 = (_OWORD *)(*((void *)this + 4) + 1);
    *((void *)this + 4) = v9;
  }
  if (*((void *)this + 3) - (void)v9 > 0xFuLL)
  {
    *unsigned int v9 = *(_OWORD *)"        Column: ";
    *((void *)this + 4) += 16;
  }
  else
  {
    llvm::raw_ostream::write(this, "        Column: ", 0x10uLL);
  }
  sub_1CD098D14(this, *(unsigned int *)(a1 + 12), 0, 0, 0);
  uint64_t v10 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v10)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
    int v11 = (_OWORD *)*((void *)this + 4);
  }
  else
  {
    *uint64_t v10 = 10;
    int v11 = (_OWORD *)(*((void *)this + 4) + 1);
    *((void *)this + 4) = v11;
  }
  if (*((void *)this + 3) - (void)v11 > 0xFuLL)
  {
    _OWORD *v11 = *(_OWORD *)"        Inline: ";
    *((void *)this + 4) += 16;
  }
  else
  {
    llvm::raw_ostream::write(this, "        Inline: ", 0x10uLL);
  }
  uint64_t result = sub_1CD098D14(this, *(unsigned __int8 *)(a1 + 16), 0, 0, 0);
  int v13 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v13)
  {
    return llvm::raw_ostream::write(this, "\n", 1uLL);
  }
  else
  {
    *int v13 = 10;
    ++*((void *)this + 4);
  }
  return result;
}

uint64_t *sub_1CCD0391C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2)
  {
    unsigned int v3 = a2 - 1;
    uint64_t v4 = (uint64_t *)(a1 + 32 * ((37 * a3) & (a2 - 1)));
    uint64_t v5 = *v4;
    if (*v4 == a3) {
      return v4;
    }
    int v6 = 1;
    LODWORD(v7) = (37 * a3) & v3;
    while (v5 != -1)
    {
      int v8 = v7 + v6++;
      uint64_t v7 = v8 & v3;
      uint64_t v5 = *(void *)(a1 + 32 * v7);
      if (v5 == a3) {
        return (uint64_t *)(a1 + 32 * v7);
      }
    }
  }
  uint64_t v7 = a2;
  return (uint64_t *)(a1 + 32 * v7);
}

void sub_1CCD03980(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  int v6 = (char *)malloc_type_malloc(56 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  int v8 = *(char **)a1;
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = &v8[56 * v9];
    int v11 = v7 + 25;
    do
    {
      *((unsigned char *)v11 - 1) = 0;
      v11[1] = 0;
      v11[2] = 0;
      void *v11 = 0;
      *(void *)((char *)v11 + 23) = 0;
      *(_OWORD *)((char *)v11 - 25) = *(_OWORD *)v8;
      *(void *)((char *)v11 - 9) = *((void *)v8 + 2);
      v11 += 7;
      v8 += 56;
    }
    while (v8 != v10);
    int v8 = *(char **)a1;
  }
  if (v8 != (char *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

uint64_t *sub_1CCD03A78(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 72 * v2;
    uint64_t v5 = (void *)(v3 + 24);
    do
    {
      if (*(v5 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
      }
      v5 += 9;
      v4 -= 72;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

double sub_1CCD03AF0(uint64_t a1, uint64_t *a2)
{
  unsigned int v9 = 0;
  char v4 = sub_1CCD03BDC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v9);
  int v6 = v9;
  if (v4) {
    return result;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
    goto LABEL_9;
  }
  if (v8 + ~v7 - *(_DWORD *)(a1 + 12) <= v8 >> 3)
  {
LABEL_9:
    sub_1CCD03C74(a1, v8);
    unsigned int v9 = 0;
    sub_1CCD03BDC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v9);
    int v6 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*v6 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  *int v6 = *a2;
  v6[1] = (uint64_t)(v6 + 3);
  *(void *)&double result = 0x600000000;
  v6[2] = 0x600000000;
  return result;
}

uint64_t sub_1CCD03BDC(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    int v6 = (void *)(a1 + 72 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 72 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

void *sub_1CCD03C74(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(72 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 72 * v10;
      do
      {
        void *result = -1;
        result += 9;
        v11 -= 72;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 72 * v3;
      unsigned int v13 = (void *)(v4 + 24);
      do
      {
        unint64_t v14 = *(v13 - 3);
        if (v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          unsigned int v20 = 0;
          sub_1CCD03BDC(*(void *)a1, *(_DWORD *)(a1 + 16), v14, &v20);
          uint64_t v15 = v20;
          *unsigned int v20 = *(v13 - 3);
          _OWORD v15[2] = 0x600000000;
          v15[1] = v15 + 3;
          uint64_t v16 = (uint64_t)(v15 + 1);
          if (*((_DWORD *)v13 - 2)) {
            sub_1CD41C56C(v16, (uint64_t)(v13 - 2));
          }
          ++*(_DWORD *)(a1 + 8);
          unint64_t v17 = (void *)*(v13 - 2);
          if (v13 != v17) {
            free(v17);
          }
        }
        v13 += 9;
        v12 -= 72;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v18 = *(unsigned int *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 72 * v18;
    do
    {
      void *result = -1;
      result += 9;
      v19 -= 72;
    }
    while (v19);
  }
  return result;
}

uint64_t sub_1CCD03E04(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    unint64_t v6 = (void *)(a1 + 56 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unint64_t v6 = (void *)(a1 + 56 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unint64_t v6 = v10;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

void *sub_1CCD03E9C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 56 * v10;
      do
      {
        void *result = -1;
        result += 7;
        v11 -= 56;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 56 * v3;
      uint64_t v13 = v4 + 24;
      do
      {
        unint64_t v14 = *(void *)(v13 - 24);
        if (v14 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v19 = 0;
          sub_1CCD03E04(*(void *)a1, *(_DWORD *)(a1 + 16), v14, &v19);
          uint64_t v15 = v19;
          uint64_t v16 = *(void *)(v13 - 24);
          *(_DWORD *)(v19 + 24) = 0;
          *(void *)(v15 + 8) = 0;
          *(void *)(v15 + 16) = 0;
          *(void *)uint64_t v15 = v16;
          *(void *)(v15 + 8) = *(void *)(v13 - 16);
          *(void *)(v13 - 16) = 0;
          *(_DWORD *)(v15 + 16) = *(_DWORD *)(v13 - 8);
          *(_DWORD *)(v13 - 8) = 0;
          LODWORD(v16) = *(_DWORD *)(v15 + 20);
          *(_DWORD *)(v15 + 20) = *(_DWORD *)(v13 - 4);
          *(_DWORD *)(v13 - 4) = v16;
          LODWORD(v16) = *(_DWORD *)(v15 + 24);
          *(_DWORD *)(v15 + 24) = *(_DWORD *)v13;
          *(_DWORD *)uint64_t v13 = v16;
          *(void *)(v15 + 32) = 0;
          *(void *)(v15 + 40) = 0;
          *(void *)(v15 + 48) = 0;
          *(_OWORD *)(v15 + 32) = *(_OWORD *)(v13 + 8);
          *(void *)(v15 + 48) = *(void *)(v13 + 24);
          *(void *)(v13 + 16) = 0;
          *(void *)(v13 + 24) = 0;
          *(void *)(v13 + 8) = 0;
          ++*(_DWORD *)(a1 + 8);
          MEMORY[0x1D25D9CD0](*(void *)(v13 - 16), 8);
        }
        v13 += 56;
        v12 -= 56;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 56 * v17;
    do
    {
      void *result = -1;
      result += 7;
      v18 -= 56;
    }
    while (v18);
  }
  return result;
}

__n128 sub_1CCD04050(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 4);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 20);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 36);
  *(void *)(a1 + 56) = *(void *)(a2 + 52);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 60);
  __n128 result = *(__n128 *)(a2 + 76);
  *(__n128 *)(a1 + 80) = result;
  *(void *)(a1 + 96) = *(void *)(a2 + 92);
  return result;
}

uint64_t sub_1CCD040B0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 != a2 + 16)
    {
      sub_1CCD044E4((char **)a1, (char **)a2);
      return a1;
    }
    unint64_t v5 = *(unsigned int *)(a2 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    if (v6 >= v5)
    {
      uint64_t v10 = *(char **)a1;
      if (v5)
      {
        uint64_t v11 = &v4[136 * v5];
        do
        {
          if (v10[23] < 0) {
            operator delete(*(void **)v10);
          }
          long long v12 = *(_OWORD *)v4;
          *((void *)v10 + 2) = *((void *)v4 + 2);
          *(_OWORD *)uint64_t v10 = v12;
          v4[23] = 0;
          *uint64_t v4 = 0;
          uint64_t v13 = (void **)(v10 + 24);
          if (v10[47] < 0) {
            operator delete(*v13);
          }
          long long v14 = *(_OWORD *)(v4 + 24);
          *((void *)v10 + 5) = *((void *)v4 + 5);
          *(_OWORD *)uint64_t v13 = v14;
          v4[47] = 0;
          v4[24] = 0;
          uint64_t v15 = (void **)(v10 + 48);
          if (v10[71] < 0) {
            operator delete(*v15);
          }
          long long v16 = *((_OWORD *)v4 + 3);
          *((void *)v10 + 8) = *((void *)v4 + 8);
          *(_OWORD *)uint64_t v15 = v16;
          v4[71] = 0;
          v4[48] = 0;
          long long v17 = *(_OWORD *)(v4 + 72);
          long long v18 = *(_OWORD *)(v4 + 88);
          long long v19 = *(_OWORD *)(v4 + 104);
          *(_OWORD *)(v10 + 116) = *(_OWORD *)(v4 + 116);
          *(_OWORD *)(v10 + 104) = v19;
          *(_OWORD *)(v10 + 88) = v18;
          *(_OWORD *)(v10 + 72) = v17;
          v10 += 136;
          v4 += 136;
        }
        while (v4 != v11);
        LODWORD(v6) = *(_DWORD *)(a1 + 8);
        unsigned int v20 = *(char **)a1;
      }
      else
      {
        unsigned int v20 = *(char **)a1;
      }
      for (unint64_t i = &v20[136 * v6]; i != v10; i -= 136)
      {
        if (*(i - 65) < 0) {
          operator delete(*((void **)i - 11));
        }
        if (*(i - 89) < 0) {
          operator delete(*((void **)i - 14));
        }
        if (*(i - 113) < 0) {
          operator delete(*((void **)i - 17));
        }
      }
      *(_DWORD *)(a1 + 8) = v5;
      uint64_t v47 = *(unsigned int *)(a2 + 8);
      if (v47)
      {
        unint64_t v48 = *(char **)a2;
        uint64_t v49 = 136 * v47;
        do
        {
          unsigned int v50 = &v48[v49];
          if (v48[v49 - 65] < 0) {
            operator delete(*((void **)v50 - 11));
          }
          if (*(v50 - 89) < 0) {
            operator delete(*(void **)&v48[v49 - 112]);
          }
          if (v48[v49 - 113] < 0) {
            operator delete(*((void **)v50 - 17));
          }
          v49 -= 136;
        }
        while (v49);
      }
      goto LABEL_70;
    }
    if (*(_DWORD *)(a1 + 12) >= v5)
    {
      if (v6)
      {
        unint64_t v21 = &v4[136 * v6];
        unint64_t v22 = (char *)(*(void *)a1 + 47);
        do
        {
          unint64_t v23 = (void **)(v22 - 47);
          if (*(v22 - 24) < 0) {
            operator delete(*v23);
          }
          long long v24 = *(_OWORD *)v4;
          *(void *)(v22 - 31) = *((void *)v4 + 2);
          *(_OWORD *)unint64_t v23 = v24;
          v4[23] = 0;
          *uint64_t v4 = 0;
          int v25 = (void **)(v22 - 23);
          if (*v22 < 0) {
            operator delete(*v25);
          }
          long long v26 = *(_OWORD *)(v4 + 24);
          *(void *)(v22 - 7) = *((void *)v4 + 5);
          *(_OWORD *)int v25 = v26;
          v4[47] = 0;
          v4[24] = 0;
          long long v27 = (void **)(v22 + 1);
          if (v22[24] < 0) {
            operator delete(*v27);
          }
          long long v28 = *((_OWORD *)v4 + 3);
          *(void *)(v22 + 17) = *((void *)v4 + 8);
          *(_OWORD *)long long v27 = v28;
          v4[71] = 0;
          v4[48] = 0;
          long long v29 = *(_OWORD *)(v4 + 72);
          long long v30 = *(_OWORD *)(v4 + 88);
          long long v31 = *(_OWORD *)(v4 + 104);
          *(_OWORD *)(v22 + 69) = *(_OWORD *)(v4 + 116);
          *(_OWORD *)(v22 + 57) = v31;
          *(_OWORD *)(v22 + 41) = v30;
          *(_OWORD *)(v22 + 25) = v29;
          v22 += 136;
          v4 += 136;
        }
        while (v4 != v21);
        goto LABEL_37;
      }
    }
    else
    {
      if (v6)
      {
        int v7 = *(char **)a1;
        uint64_t v8 = 136 * v6;
        do
        {
          unsigned int v9 = &v7[v8];
          if (v7[v8 - 65] < 0) {
            operator delete(*((void **)v9 - 11));
          }
          if (*(v9 - 89) < 0) {
            operator delete(*(void **)&v7[v8 - 112]);
          }
          if (v7[v8 - 113] < 0) {
            operator delete(*((void **)v9 - 17));
          }
          v8 -= 136;
        }
        while (v8);
      }
      *(_DWORD *)(a1 + 8) = 0;
      sub_1CC68395C(a1, v5);
    }
    uint64_t v6 = 0;
LABEL_37:
    int v32 = *(char **)a2;
    uint64_t v33 = *(unsigned int *)(a2 + 8);
    if (v6 != v33)
    {
      int v34 = &v32[136 * v33];
      uint64_t v35 = *(void *)a1 + 136 * v6;
      int v36 = &v32[136 * v6];
      do
      {
        long long v37 = *(_OWORD *)v36;
        *(void *)(v35 + 16) = *((void *)v36 + 2);
        *(_OWORD *)uint64_t v35 = v37;
        *((void *)v36 + 1) = 0;
        *((void *)v36 + 2) = 0;
        *(void *)int v36 = 0;
        long long v38 = *(_OWORD *)(v36 + 24);
        *(void *)(v35 + 40) = *((void *)v36 + 5);
        *(_OWORD *)(v35 + 24) = v38;
        *((void *)v36 + 4) = 0;
        *((void *)v36 + 5) = 0;
        *((void *)v36 + 3) = 0;
        long long v39 = *((_OWORD *)v36 + 3);
        *(void *)(v35 + 64) = *((void *)v36 + 8);
        *(_OWORD *)(v35 + 48) = v39;
        *((void *)v36 + 7) = 0;
        *((void *)v36 + 8) = 0;
        *((void *)v36 + 6) = 0;
        long long v40 = *(_OWORD *)(v36 + 72);
        long long v41 = *(_OWORD *)(v36 + 88);
        long long v42 = *(_OWORD *)(v36 + 104);
        *(_OWORD *)(v35 + 116) = *(_OWORD *)(v36 + 116);
        *(_OWORD *)(v35 + 104) = v42;
        *(_OWORD *)(v35 + 88) = v41;
        *(_OWORD *)(v35 + 72) = v40;
        v36 += 136;
        v35 += 136;
      }
      while (v36 != v34);
      int v32 = *(char **)a2;
    }
    *(_DWORD *)(a1 + 8) = v5;
    uint64_t v43 = *(unsigned int *)(a2 + 8);
    if (v43)
    {
      uint64_t v44 = 136 * v43;
      do
      {
        long long v45 = &v32[v44];
        if (v32[v44 - 65] < 0) {
          operator delete(*((void **)v45 - 11));
        }
        if (*(v45 - 89) < 0) {
          operator delete(*(void **)&v32[v44 - 112]);
        }
        if (v32[v44 - 113] < 0) {
          operator delete(*((void **)v45 - 17));
        }
        v44 -= 136;
      }
      while (v44);
    }
LABEL_70:
    *(_DWORD *)(a2 + 8) = 0;
  }
  return a1;
}

double sub_1CCD044E4(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 136 * v5;
    do
    {
      int v7 = (void **)&v4[v6];
      if (v4[v6 - 65] < 0) {
        operator delete(*(v7 - 11));
      }
      if (*((char *)v7 - 89) < 0) {
        operator delete(*(void **)&v4[v6 - 112]);
      }
      if (v4[v6 - 113] < 0) {
        operator delete(*(v7 - 17));
      }
      v6 -= 136;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

char **sub_1CCD045A0(char **a1)
{
  uint64_t v2 = *a1;
  if ((_BYTE)a1[70])
  {
    *a1 = 0;
    if (v2) {
      (*(void (**)(char *))(*(void *)v2 + 8))(v2);
    }
  }
  else
  {
    uint64_t v3 = *((unsigned int *)a1 + 2);
    if (v3)
    {
      uint64_t v4 = 136 * v3;
      do
      {
        uint64_t v5 = (void **)&v2[v4];
        if (v2[v4 - 65] < 0) {
          operator delete(*(v5 - 11));
        }
        if (*((char *)v5 - 89) < 0) {
          operator delete(*(void **)&v2[v4 - 112]);
        }
        if (v2[v4 - 113] < 0) {
          operator delete(*(v5 - 17));
        }
        v4 -= 136;
      }
      while (v4);
      uint64_t v2 = *a1;
    }
    if (v2 != (char *)(a1 + 2)) {
      free(v2);
    }
  }
  return a1;
}

void *sub_1CCD04678(uint64_t *a1, int a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 4);
  uint64_t v4 = (uint64_t *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  double result = operator new(32 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v10 = *((unsigned int *)a1 + 4);
    if (v10)
    {
      uint64_t v11 = 32 * v10;
      long long v12 = result;
      do
      {
        *long long v12 = -1;
        v12 += 4;
        v11 -= 32;
      }
      while (v11);
    }
    if (v3)
    {
      int v13 = 0;
      unsigned int v14 = v10 - 1;
      uint64_t v15 = v4;
      do
      {
        uint64_t v16 = *v15;
        if ((unint64_t)*v15 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v17 = (37 * v16) & v14;
          long long v18 = &result[4 * v17];
          uint64_t v19 = *v18;
          if (v16 != *v18)
          {
            unsigned int v20 = 0;
            int v21 = 1;
            while (v19 != -1)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -2;
              }
              if (v22) {
                unsigned int v20 = v18;
              }
              int v23 = v17 + v21++;
              uint64_t v17 = v23 & v14;
              long long v18 = &result[4 * v17];
              uint64_t v19 = *v18;
              if (v16 == *v18) {
                goto LABEL_12;
              }
            }
            if (v20) {
              long long v18 = v20;
            }
          }
LABEL_12:
          void *v18 = v16;
          v18[1] = v15[1];
          v18[2] = v15[2];
          *((unsigned char *)v18 + 24) = *((unsigned char *)v15 + 24);
          *((_DWORD *)a1 + 2) = ++v13;
        }
        v15 += 4;
      }
      while (v15 != &v4[4 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v24 = *((unsigned int *)a1 + 4);
  if (v24)
  {
    uint64_t v25 = 32 * v24;
    do
    {
      void *result = -1;
      result += 4;
      v25 -= 32;
    }
    while (v25);
  }
  return result;
}

double sub_1CCD04814@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = sub_1CCD0391C(*(void *)(*(void *)a1 + 1040), *(_DWORD *)(*(void *)a1 + 1056), a2);
  *(void *)a3 = v4[1];
  double result = *((double *)v4 + 2);
  *(double *)(a3 + 8) = result;
  *(unsigned char *)(a3 + 16) = *((unsigned char *)v4 + 24);
  return result;
}

uint64_t llvm::remarks::BitstreamMetaParserHelper::BitstreamMetaParserHelper(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)double result = a2;
  *(void *)(result + 8) = a3;
  *(unsigned char *)(result + 16) = 0;
  *(unsigned char *)(result + 24) = 0;
  *(_WORD *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(unsigned char *)(result + 56) = 0;
  *(unsigned char *)(result + 64) = 0;
  *(unsigned char *)(result + 80) = 0;
  *(unsigned char *)(result + 88) = 0;
  *(unsigned char *)(result + 96) = 0;
  return result;
}

{
  *(void *)double result = a2;
  *(void *)(result + 8) = a3;
  *(unsigned char *)(result + 16) = 0;
  *(unsigned char *)(result + 24) = 0;
  *(_WORD *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(unsigned char *)(result + 56) = 0;
  *(unsigned char *)(result + 64) = 0;
  *(unsigned char *)(result + 80) = 0;
  *(unsigned char *)(result + 88) = 0;
  *(unsigned char *)(result + 96) = 0;
  return result;
}

double llvm::remarks::BitstreamRemarkParserHelper::BitstreamRemarkParserHelper(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(_WORD *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 84) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 92) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = a1 + 152;
  *(void *)&double result = 0x800000000;
  *(void *)(a1 + 144) = 0x800000000;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  *(_WORD *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 84) = 0;
  *(unsigned char *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 92) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = a1 + 152;
  *(void *)&double result = 0x800000000;
  *(void *)(a1 + 144) = 0x800000000;
  return result;
}

void llvm::remarks::BitstreamMetaParserHelper::parse(llvm::remarks::BitstreamMetaParserHelper *this@<X0>, void *a2@<X8>)
{
  v33[2] = *MEMORY[0x1E4F143B8];
  int v23 = "META_BLOCK";
  uint64_t v4 = *(void *)this;
  sub_1CC1CA5F4(*(void *)this, 0, (uint64_t)&v27);
  if (v28)
  {
LABEL_47:
    uint64_t v18 = v27;
    uint64_t v27 = 0;
    *a2 = v18;
    goto LABEL_48;
  }
  if (v27 != 0x800000002)
  {
    unsigned int v20 = std::generic_category();
    sub_1CD4F664C(92, (uint64_t)v20, (uint64_t)"Error while parsing %s: expecting [ENTER_SUBBLOCK, %s, ...].", (uint64_t *)&v23, (uint64_t *)&v23);
  }
  llvm::BitstreamCursor::EnterSubBlock((llvm::BitstreamCursor *)v4, 0, 8, &v31);
  if (v31)
  {
    (*(void (**)(void *))(*(void *)v31 + 8))(v31);
    int v21 = std::generic_category();
    BOOL v22 = "Error while entering %s.";
    goto LABEL_56;
  }
  while (1)
  {
    while (1)
    {
      if (!*(_DWORD *)(v4 + 32) && *(void *)(v4 + 8) <= *(void *)(v4 + 16))
      {
        int v21 = std::generic_category();
        BOOL v22 = "Error while parsing %s: unterminated block.";
        goto LABEL_56;
      }
      sub_1CC1CA5F4(v4, 0, (uint64_t)&v31);
      sub_1CC222EE8(&v27, &v31);
      if (v32)
      {
        unint64_t v5 = v31;
        long long v31 = 0;
        if (v5) {
          (*(void (**)(void *))(*(void *)v5 + 8))(v5);
        }
      }
      if (v28) {
        goto LABEL_47;
      }
      if (v27 != 3) {
        break;
      }
      unint64_t v6 = *(void **)this;
      long long v31 = v33;
      uint64_t v32 = 0x200000000;
      long long v24 = 0uLL;
      llvm::BitstreamCursor::readRecord(v6, SHIDWORD(v27), (uint64_t)&v31, (unsigned __int8 **)&v24, (uint64_t)&v29);
      if (v30)
      {
        uint64_t v10 = v29;
        uint64_t v29 = 0;
        *a2 = v10;
        goto LABEL_30;
      }
      switch((int)v29)
      {
        case 1:
          if (v32 != 2)
          {
            long long v26 = "BLOCK_META";
            uint64_t v16 = "RECORD_META_CONTAINER_INFO";
LABEL_44:
            uint64_t v25 = v16;
LABEL_46:
            uint64_t v17 = std::generic_category();
            sub_1CD4F664C(92, (uint64_t)v17, (uint64_t)"Error while parsing %s: malformed record entry (%s).", (uint64_t *)&v26, (uint64_t *)&v25);
          }
          int v7 = v31;
          uint64_t v8 = *(void *)v31;
          if (!*((unsigned char *)this + 24)) {
            *((unsigned char *)this + 24) = 1;
          }
          *((void *)this + 2) = v8;
          int v9 = *((unsigned __int8 *)this + 33);
          *((unsigned char *)this + 32) = v7[1];
          if (!v9) {
            *((unsigned char *)this + 33) = 1;
          }
LABEL_29:
          *a2 = 0;
LABEL_30:
          if (v30)
          {
            uint64_t v15 = v29;
            uint64_t v29 = 0;
            if (v15) {
              (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
            }
          }
          if (v31 != v33) {
            free(v31);
          }
          if (*a2) {
            goto LABEL_48;
          }
          break;
        case 2:
          if (v32 == 1)
          {
            int v12 = *((unsigned __int8 *)this + 96);
            *((void *)this + 11) = *(void *)v31;
            if (!v12) {
              *((unsigned char *)this + 96) = 1;
            }
            goto LABEL_29;
          }
          long long v26 = "BLOCK_META";
          uint64_t v16 = "RECORD_META_REMARK_VERSION";
          goto LABEL_44;
        case 3:
          if (!v32)
          {
            int v13 = *((unsigned __int8 *)this + 56);
            *(_OWORD *)((char *)this + 40) = v24;
            if (!v13) {
              *((unsigned char *)this + 56) = 1;
            }
            goto LABEL_29;
          }
          long long v26 = "BLOCK_META";
          uint64_t v16 = "RECORD_META_STRTAB";
          goto LABEL_44;
        case 4:
          if (!v32)
          {
            int v14 = *((unsigned __int8 *)this + 80);
            *((_OWORD *)this + 4) = v24;
            if (!v14) {
              *((unsigned char *)this + 80) = 1;
            }
            goto LABEL_29;
          }
          uint64_t v25 = "RECORD_META_EXTERNAL_FILE";
          long long v26 = "BLOCK_META";
          goto LABEL_46;
        default:
          long long v26 = "BLOCK_META";
          LODWORD(v25) = v29;
          uint64_t v11 = std::generic_category();
          sub_1CCD0751C((uint64_t)a2, 92, (uint64_t)v11, (uint64_t *)&v26, (int *)&v25);
      }
    }
    if (v27 == 1) {
      break;
    }
    if (!v27 || v27 == 2)
    {
      int v21 = std::generic_category();
      BOOL v22 = "Error while parsing %s: expecting records.";
LABEL_56:
      sub_1CD5E3960(92, (uint64_t)v21, (uint64_t)v22, (uint64_t *)&v23);
    }
  }
  *a2 = 0;
LABEL_48:
  if (v28)
  {
    uint64_t v19 = v27;
    uint64_t v27 = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
}

void llvm::remarks::BitstreamRemarkParserHelper::parse(llvm::remarks::BitstreamRemarkParserHelper *this@<X0>, void *a2@<X8>)
{
  v53[5] = *MEMORY[0x1E4F143B8];
  uint64_t v43 = "REMARK_BLOCK";
  uint64_t v4 = *(void *)this;
  sub_1CC1CA5F4(*(void *)this, 0, (uint64_t)&v47);
  if (v48)
  {
LABEL_73:
    uint64_t v38 = v47;
    uint64_t v47 = 0;
    *a2 = v38;
  }
  else
  {
    if (v47 != 0x900000002)
    {
      long long v40 = std::generic_category();
      sub_1CD4F664C(92, (uint64_t)v40, (uint64_t)"Error while parsing %s: expecting [ENTER_SUBBLOCK, %s, ...].", (uint64_t *)&v43, (uint64_t *)&v43);
    }
    llvm::BitstreamCursor::EnterSubBlock((llvm::BitstreamCursor *)v4, 0, 9, &v51);
    if (v51)
    {
      (*(void (**)(void *))(*(void *)v51 + 8))(v51);
      long long v41 = std::generic_category();
      long long v42 = "Error while entering %s.";
      goto LABEL_82;
    }
    while (1)
    {
      while (1)
      {
        if (!*(_DWORD *)(v4 + 32) && *(void *)(v4 + 8) <= *(void *)(v4 + 16))
        {
          long long v41 = std::generic_category();
          long long v42 = "Error while parsing %s: unterminated block.";
          goto LABEL_82;
        }
        sub_1CC1CA5F4(v4, 0, (uint64_t)&v51);
        sub_1CC222EE8(&v47, &v51);
        if (v52)
        {
          unint64_t v5 = v51;
          uint64_t v51 = 0;
          if (v5) {
            (*(void (**)(void *))(*(void *)v5 + 8))(v5);
          }
        }
        if (v48) {
          goto LABEL_73;
        }
        if (v47 != 3) {
          break;
        }
        unint64_t v6 = *(void **)this;
        uint64_t v51 = v53;
        uint64_t v52 = 0x500000000;
        v44[0] = 0;
        v44[1] = 0;
        llvm::BitstreamCursor::readRecord(v6, SHIDWORD(v47), (uint64_t)&v51, v44, (uint64_t)&v49);
        if (v50)
        {
          uint64_t v12 = v49;
          uint64_t v49 = 0;
          *a2 = v12;
        }
        else
        {
          switch((int)v49)
          {
            case 5:
              if (v52 != 4)
              {
                long long v46 = "BLOCK_REMARK";
                int v36 = "RECORD_REMARK_HEADER";
LABEL_69:
                long long v45 = v36;
                goto LABEL_72;
              }
              int v7 = v51;
              char v8 = *(unsigned char *)v51;
              if (!*((unsigned char *)this + 9)) {
                *((unsigned char *)this + 9) = 1;
              }
              *((unsigned char *)this + 8) = v8;
              uint64_t v9 = v7[1];
              if (!*((unsigned char *)this + 24)) {
                *((unsigned char *)this + 24) = 1;
              }
              *((void *)this + 2) = v9;
              uint64_t v10 = v7[2];
              if (!*((unsigned char *)this + 40)) {
                *((unsigned char *)this + 40) = 1;
              }
              *((void *)this + 4) = v10;
              int v11 = *((unsigned __int8 *)this + 56);
              *((void *)this + 6) = v7[3];
              if (!v11) {
                *((unsigned char *)this + 56) = 1;
              }
              break;
            case 6:
              if (v52 != 3)
              {
                long long v46 = "BLOCK_REMARK";
                int v36 = "RECORD_REMARK_DEBUG_LOC";
                goto LABEL_69;
              }
              int v14 = v51;
              uint64_t v15 = *(void *)v51;
              if (!*((unsigned char *)this + 72)) {
                *((unsigned char *)this + 72) = 1;
              }
              *((void *)this + 8) = v15;
              int v16 = v14[2];
              if (!*((unsigned char *)this + 84)) {
                *((unsigned char *)this + 84) = 1;
              }
              *((_DWORD *)this + 20) = v16;
              int v17 = *((unsigned __int8 *)this + 92);
              *((_DWORD *)this + 22) = *((void *)v14 + 2);
              if (!v17) {
                *((unsigned char *)this + 92) = 1;
              }
              break;
            case 7:
              if (v52 != 1)
              {
                long long v46 = "BLOCK_REMARK";
                int v36 = "RECORD_REMARK_HOTNESS";
                goto LABEL_69;
              }
              int v18 = *((unsigned __int8 *)this + 104);
              *((void *)this + 12) = *(void *)v51;
              if (!v18) {
                *((unsigned char *)this + 104) = 1;
              }
              break;
            case 8:
              if (v52 != 5)
              {
                long long v45 = "RECORD_REMARK_ARG_WITH_DEBUGLOC";
                long long v46 = "BLOCK_REMARK";
                goto LABEL_72;
              }
              sub_1CCD076A4((uint64_t)this + 136);
              unint64_t v19 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              uint64_t v20 = *(void *)v51;
              if (!*(unsigned char *)(v19 - 56)) {
                *(unsigned char *)(v19 - 56) = 1;
              }
              *(void *)(v19 - 64) = v20;
              unint64_t v21 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              uint64_t v22 = *((void *)v51 + 1);
              if (!*(unsigned char *)(v21 - 40)) {
                *(unsigned char *)(v21 - 40) = 1;
              }
              *(void *)(v21 - 48) = v22;
              unint64_t v23 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              uint64_t v24 = *((void *)v51 + 2);
              if (!*(unsigned char *)(v23 - 24)) {
                *(unsigned char *)(v23 - 24) = 1;
              }
              *(void *)(v23 - 32) = v24;
              int v25 = *((_DWORD *)v51 + 6);
              unint64_t v26 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              if (!*(unsigned char *)(v26 - 12)) {
                *(unsigned char *)(v26 - 12) = 1;
              }
              *(_DWORD *)(v26 - 16) = v25;
              int v27 = *((_DWORD *)v51 + 8);
              unint64_t v28 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              if (!*(unsigned char *)(v28 - 4)) {
                *(unsigned char *)(v28 - 4) = 1;
              }
              *(_DWORD *)(v28 - 8) = v27;
              goto LABEL_56;
            case 9:
              if (v52 != 2)
              {
                long long v45 = "RECORD_REMARK_ARG_WITHOUT_DEBUGLOC";
                long long v46 = "BLOCK_REMARK";
LABEL_72:
                long long v37 = std::generic_category();
                sub_1CD4F664C(92, (uint64_t)v37, (uint64_t)"Error while parsing %s: malformed record entry (%s).", (uint64_t *)&v46, (uint64_t *)&v45);
              }
              sub_1CCD076A4((uint64_t)this + 136);
              unint64_t v29 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              uint64_t v30 = *(void *)v51;
              if (!*(unsigned char *)(v29 - 56)) {
                *(unsigned char *)(v29 - 56) = 1;
              }
              *(void *)(v29 - 64) = v30;
              unint64_t v31 = *((void *)this + 17) + ((unint64_t)*((unsigned int *)this + 36) << 6);
              uint64_t v32 = *((void *)v51 + 1);
              if (!*(unsigned char *)(v31 - 40)) {
                *(unsigned char *)(v31 - 40) = 1;
              }
              *(void *)(v31 - 48) = v32;
LABEL_56:
              uint64_t v33 = *((unsigned int *)this + 36);
              int v34 = *((unsigned __int8 *)this + 128);
              *((void *)this + 14) = *((void *)this + 17);
              *((void *)this + 15) = v33;
              if (!v34) {
                *((unsigned char *)this + 128) = 1;
              }
              break;
            default:
              long long v46 = "BLOCK_REMARK";
              LODWORD(v45) = v49;
              int v13 = std::generic_category();
              sub_1CCD0751C((uint64_t)a2, 92, (uint64_t)v13, (uint64_t *)&v46, (int *)&v45);
          }
          *a2 = 0;
        }
        if (v50)
        {
          uint64_t v35 = v49;
          uint64_t v49 = 0;
          if (v35) {
            (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
          }
        }
        if (v51 != v53) {
          free(v51);
        }
        if (*a2) {
          goto LABEL_74;
        }
      }
      if (v47 == 1) {
        break;
      }
      if (!v47 || v47 == 2)
      {
        long long v41 = std::generic_category();
        long long v42 = "Error while parsing %s: expecting records.";
LABEL_82:
        sub_1CD5E3960(92, (uint64_t)v41, (uint64_t)v42, (uint64_t *)&v43);
      }
    }
    *a2 = 0;
  }
LABEL_74:
  if (v48)
  {
    uint64_t v39 = v47;
    uint64_t v47 = 0;
    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
    }
  }
}

double llvm::remarks::BitstreamParserHelper::BitstreamParserHelper(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0x200000000;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a1 + 80;
  *(void *)(a1 + 72) = 0x800000000;
  double result = 0.0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0x200000000;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a1 + 80;
  *(void *)(a1 + 72) = 0x800000000;
  double result = 0.0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  return result;
}

uint64_t llvm::remarks::BitstreamParserHelper::parseMagic@<X0>(llvm::remarks::BitstreamParserHelper *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = 0;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    uint64_t result = sub_1CC1CA844((uint64_t)this, 8u, (uint64_t)&v8);
    if (v9) {
      break;
    }
    *((unsigned char *)&v7 + v4++) = v8;
    if (v4 == 4)
    {
      *(unsigned char *)(a2 + 8) &= ~1u;
      *(_DWORD *)a2 = v7;
      return result;
    }
  }
  uint64_t v6 = v8;
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v6;
  return result;
}

void llvm::remarks::BitstreamParserHelper::parseBlockInfoBlock(void **this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  sub_1CC1CA5F4((uint64_t)this, 0, (uint64_t)&v43);
  if (v44)
  {
    uint64_t v5 = v43;
    uint64_t v43 = 0;
    *a2 = v5;
  }
  else
  {
    if (v43 != 2 || HIDWORD(v43) != 0)
    {
      uint64_t v39 = 92;
      long long v40 = std::generic_category();
      v38[0] = (void **)"Error while parsing BLOCKINFO_BLOCK: expecting [ENTER_SUBBLOCK, BLOCKINFO_BLOCK, ...].";
      sub_1CD06481C();
    }
    llvm::BitstreamCursor::ReadBlockInfoBlock((llvm::BitstreamCursor *)this, 0, (uint64_t)&v39);
    if (v42)
    {
      uint64_t v21 = v39;
      uint64_t v39 = 0;
      *a2 = v21;
    }
    else
    {
      if (!v41)
      {
        v38[0] = (void **)92;
        v38[1] = (void **)std::generic_category();
        sub_1CD06481C();
      }
      uint64_t v6 = (char *)(this + 43);
      if (this + 43 != (void **)&v39)
      {
        uint64_t v7 = v39;
        uint64_t v8 = v40;
        unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v40 - v39) >> 4);
        uint64_t v10 = (char *)this[43];
        if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)this[45] - v10) >> 4) >= v9)
        {
          uint64_t v22 = (char *)this[44];
          if (0xCCCCCCCCCCCCCCCDLL * ((v22 - v10) >> 4) >= v9)
          {
            if ((const std::error_category *)v39 != v40)
            {
              uint64_t v34 = 0;
              do
              {
                *(_DWORD *)&v10[v34] = *(_DWORD *)(v7 + v34);
                if ((char *)v7 == v10)
                {
                  std::string::operator=((std::string *)&v10[v34 + 32], (const std::string *)&v10[v34 + 32]);
                }
                else
                {
                  sub_1CC1CAFD4((uint64_t *)&v10[v34 + 8], *(uint64_t **)(v7 + v34 + 8), *(uint64_t **)(v7 + v34 + 16), (uint64_t)(*(void *)(v7 + v34 + 16) - *(void *)(v7 + v34 + 8)) >> 4);
                  std::string::operator=((std::string *)&v10[v34 + 32], (const std::string *)(v7 + v34 + 32));
                  sub_1CCD071D0((uint64_t)&v10[v34 + 56], *(_DWORD **)(v7 + v34 + 56), *(_DWORD **)(v7 + v34 + 64), (uint64_t)(*(void *)(v7 + v34 + 64) - *(void *)(v7 + v34 + 56)) >> 5);
                }
                v34 += 80;
              }
              while ((const std::error_category *)(v7 + v34) != v8);
              uint64_t v22 = (char *)this[44];
              v10 += v34;
            }
            if (v22 != v10)
            {
              uint64_t v35 = (uint64_t)(v22 - 72);
              do
              {
                v38[0] = (void **)(v35 + 48);
                sub_1CC1CB288(v38);
                if (*(char *)(v35 + 47) < 0) {
                  operator delete(*(void **)(v35 + 24));
                }
                if (*(void *)v35)
                {
                  sub_1CC1CAA74(v35, *(void *)v35);
                  operator delete(*(void **)v35);
                }
                uint64_t v36 = v35 - 8;
                v35 -= 80;
              }
              while ((char *)v36 != v10);
            }
            this[44] = v10;
          }
          else
          {
            uint64_t v23 = v39 + 16 * ((v22 - v10) >> 4);
            if (v22 != v10)
            {
              uint64_t v24 = 0;
              uint64_t v25 = 16 * ((v22 - v10) >> 4);
              do
              {
                *(_DWORD *)&v10[v24] = *(_DWORD *)(v7 + v24);
                if ((char *)v7 == v10)
                {
                  std::string::operator=((std::string *)&v10[v24 + 32], (const std::string *)&v10[v24 + 32]);
                }
                else
                {
                  sub_1CC1CAFD4((uint64_t *)&v10[v24 + 8], *(uint64_t **)(v7 + v24 + 8), *(uint64_t **)(v7 + v24 + 16), (uint64_t)(*(void *)(v7 + v24 + 16) - *(void *)(v7 + v24 + 8)) >> 4);
                  std::string::operator=((std::string *)&v10[v24 + 32], (const std::string *)(v7 + v24 + 32));
                  sub_1CCD071D0((uint64_t)&v10[v24 + 56], *(_DWORD **)(v7 + v24 + 56), *(_DWORD **)(v7 + v24 + 64), (uint64_t)(*(void *)(v7 + v24 + 64) - *(void *)(v7 + v24 + 56)) >> 5);
                }
                v24 += 80;
              }
              while (v25 != v24);
              uint64_t v10 = (char *)this[44];
              uint64_t v6 = (char *)(this + 43);
            }
            unint64_t v26 = v10;
            if ((const std::error_category *)v23 != v8)
            {
              int v27 = v6;
              uint64_t v28 = 0;
              do
              {
                unint64_t v29 = (void *)(v23 + v28);
                uint64_t v30 = &v10[v28];
                *(_DWORD *)uint64_t v30 = *(_DWORD *)(v23 + v28);
                *((void *)v30 + 2) = 0;
                *((void *)v30 + 3) = 0;
                *(void *)&v10[v28 + 8] = 0;
                sub_1CC1CAD70(&v10[v28 + 8], *(void **)(v23 + v28 + 8), *(void **)(v23 + v28 + 16), (uint64_t)(*(void *)(v23 + v28 + 16) - *(void *)(v23 + v28 + 8)) >> 4);
                unint64_t v31 = &v10[v28 + 32];
                uint64_t v32 = (const void **)(v23 + v28 + 32);
                if (*(char *)(v23 + v28 + 55) < 0)
                {
                  sub_1CB8BDF7C((uint64_t)v31, *v32, v29[5]);
                }
                else
                {
                  long long v33 = *(_OWORD *)v32;
                  *((void *)v30 + 6) = v29[6];
                  *(_OWORD *)unint64_t v31 = v33;
                }
                *(void *)&v10[v28 + 56] = 0;
                *(void *)&v10[v28 + 64] = 0;
                *(void *)&v10[v28 + 72] = 0;
                sub_1CCD07110(&v10[v28 + 56], v29[7], v29[8], (uint64_t)(v29[8] - v29[7]) >> 5);
                v28 += 80;
              }
              while (v29 + 10 != (void *)v8);
              unint64_t v26 = &v10[v28];
              uint64_t v6 = v27;
            }
            this[44] = v26;
          }
        }
        else
        {
          sub_1CC1CB1A4(this + 43);
          if (v9 > 0x333333333333333) {
            goto LABEL_66;
          }
          unint64_t v11 = 0x999999999999999ALL * (((unsigned char *)this[45] - (unsigned char *)this[43]) >> 4);
          if (v11 <= v9) {
            unint64_t v11 = v9;
          }
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)this[45] - (unsigned char *)this[43]) >> 4) >= 0x199999999999999
              ? 0x333333333333333
              : v11;
          if (v12 > 0x333333333333333) {
LABEL_66:
          }
            abort();
          uint64_t v13 = 5 * v12;
          int v14 = (char *)operator new(80 * v12);
          this[43] = v14;
          this[44] = v14;
          this[45] = &v14[16 * v13];
          if ((const std::error_category *)v7 != v8)
          {
            uint64_t v15 = v7 + 32;
            uint64_t v16 = (uint64_t)(v14 + 32);
            do
            {
              int v18 = (const std::error_category *)(v15 - 32);
              int v17 = *(_DWORD *)(v15 - 32);
              *(void *)(v16 - 24) = 0;
              uint64_t v19 = v16 - 24;
              *(_DWORD *)(v16 - 32) = v17;
              *(void *)(v19 + 8) = 0;
              *(void *)(v19 + 16) = 0;
              sub_1CC1CAD70((void *)(v16 - 24), *(void **)(v15 - 24), *(void **)(v15 - 16), (uint64_t)(*(void *)(v15 - 16) - *(void *)(v15 - 24)) >> 4);
              if (*(char *)(v15 + 23) < 0)
              {
                sub_1CB8BDF7C(v16, *(const void **)v15, *(void *)(v15 + 8));
              }
              else
              {
                long long v20 = *(_OWORD *)v15;
                *(void *)(v16 + 16) = *(void *)(v15 + 16);
                *(_OWORD *)uint64_t v16 = v20;
              }
              *(void *)(v16 + 24) = 0;
              *(void *)(v16 + 32) = 0;
              *(void *)(v16 + 40) = 0;
              sub_1CCD07110((void *)(v16 + 24), *(void *)(v15 + 24), *(void *)(v15 + 32), (uint64_t)(*(void *)(v15 + 32) - *(void *)(v15 + 24)) >> 5);
              v15 += 80;
              v16 += 80;
            }
            while (&v18[10] != v8);
            int v14 = (char *)(v16 - 32);
          }
          this[44] = v14;
        }
      }
      this[42] = v6;
      *a2 = 0;
    }
    sub_1CC1CB4C8((uint64_t)&v39);
  }
  if (v44)
  {
    uint64_t v37 = v43;
    uint64_t v43 = 0;
    if (v37) {
      (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
    }
  }
}

void llvm::remarks::BitstreamParserHelper::isMetaBlock(llvm::remarks::BitstreamParserHelper *this@<X0>, uint64_t a2@<X8>)
{
}

void sub_1CCD05A54(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = *(unsigned int *)(a2 + 32);
  sub_1CC1CA5F4(a2, 0, (uint64_t)&v11);
  if (v12)
  {
    uint64_t v8 = v11;
    uint64_t v11 = 0;
LABEL_6:
    *(unsigned char *)(a1 + 8) |= 1u;
    *(void *)a1 = v8;
    goto LABEL_12;
  }
  if (!v11)
  {
    unint64_t v9 = std::generic_category();
    uint64_t v13 = 92;
    int v14 = v9;
    sub_1CD06481C();
  }
  unint64_t v6 = 8 * v4 - v5;
  BOOL v7 = v11 == 2 && HIDWORD(v11) == 8;
  *(void *)(a2 + 16) = (v6 >> 3) & 0x1FFFFFFFFFFFFFF8;
  *(_DWORD *)(a2 + 32) = 0;
  if ((v6 & 0x3F) != 0)
  {
    sub_1CC1CA844(a2, v6 & 0x3F, (uint64_t)&v13);
    if (v14)
    {
      uint64_t v8 = v13;
      if (v13) {
        goto LABEL_6;
      }
    }
  }
  *(unsigned char *)(a1 + 8) &= ~1u;
  *(unsigned char *)a1 = v7;
LABEL_12:
  if (v12)
  {
    uint64_t v10 = v11;
    uint64_t v11 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
}

void llvm::remarks::BitstreamParserHelper::isRemarkBlock(llvm::remarks::BitstreamParserHelper *this@<X0>, uint64_t a2@<X8>)
{
}

void llvm::remarks::createBitstreamParserFromMeta(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v9[0] = a1;
  v9[1] = a2;
  _OWORD v9[2] = 0;
  v9[3] = 0;
  v9[4] = 0x200000000;
  memset(__p, 0, sizeof(__p));
  v11[0] = v12;
  v11[1] = (char *)0x800000000;
  memset(&v12[256], 0, 32);
  llvm::remarks::BitstreamParserHelper::parseMagic((llvm::remarks::BitstreamParserHelper *)v9, (uint64_t)&v7);
  if (v8)
  {
    uint64_t v4 = v7;
    uint64_t v7 = 0;
  }
  else
  {
    sub_1CCD05F48(&v6, &v7, 4);
    uint64_t v4 = v6;
    if (!(void)v6) {
      operator new();
    }
  }
  *(unsigned char *)(a3 + 8) |= 1u;
  *(void *)a3 = v4;
  if (v8)
  {
    uint64_t v5 = v7;
    uint64_t v7 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  *(void *)&long long v6 = &v12[264];
  sub_1CC1CB314((void ***)&v6);
  sub_1CC1CB3C4(v11);
  if (__p[0])
  {
    sub_1CC1CAA74((uint64_t)__p, (uint64_t)__p[0]);
    operator delete(__p[0]);
  }
}

void *sub_1CCD05F48(void *result, _DWORD *a2, uint64_t a3)
{
  if (a3 != 4 || *a2 != 1263684946)
  {
    uint64_t v4 = std::generic_category();
    uint64_t v5 = a2;
    long long v6 = "RMRK";
    sub_1CD4F664C(22, (uint64_t)v4, (uint64_t)"Unknown magic number: expecting %s, got %.4s.", (uint64_t *)&v6, (uint64_t *)&v5);
  }
  void *result = 0;
  return result;
}

void llvm::remarks::BitstreamRemarkParser::next(llvm::remarks::BitstreamRemarkParser *this@<X0>, uint64_t a2@<X8>)
{
  if (!*((_DWORD *)this + 18) && *((void *)this + 6) <= *((void *)this + 7)) {
    operator new();
  }
  if (*((unsigned char *)this + 484)) {
    goto LABEL_4;
  }
  llvm::remarks::BitstreamRemarkParser::parseMeta(this, &v5);
  uint64_t v4 = v5;
  if (!v5)
  {
    *((unsigned char *)this + 484) = 1;
LABEL_4:
    llvm::remarks::BitstreamRemarkParser::parseRemark(this, a2);
    return;
  }
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v4;
}

void llvm::remarks::BitstreamRemarkParser::parseMeta(llvm::remarks::BitstreamRemarkParser *this@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = (char *)this + 40;
  sub_1CCD062C4(a2, (llvm::remarks::BitstreamRemarkParser *)((char *)this + 40));
  if (!*a2)
  {
    v7[0] = v4;
    v7[1] = (char *)this + 384;
    char v8 = 0;
    char v9 = 0;
    __int16 v10 = 0;
    char v11 = 0;
    char v12 = 0;
    char v13 = 0;
    char v14 = 0;
    LOBYTE(v15) = 0;
    char v16 = 0;
    llvm::remarks::BitstreamMetaParserHelper::parse((llvm::remarks::BitstreamMetaParserHelper *)v7, a2);
    if (!*a2)
    {
      llvm::remarks::BitstreamRemarkParser::processCommonMeta((uint64_t)this, (uint64_t)v7, a2);
      if (!*a2)
      {
        int v5 = *((_DWORD *)this + 120);
        if (v5)
        {
          if (v5 == 1)
          {
            if (!v16)
            {
              long long v6 = std::generic_category();
              uint64_t v18 = 92;
              uint64_t v19 = v6;
              int v17 = "Error while parsing BLOCK_META: missing remark version.";
              sub_1CD06481C();
            }
            *((void *)this + 59) = v15;
            *a2 = 0;
          }
          else
          {
            llvm::remarks::BitstreamRemarkParser::processStandaloneMeta(this, (llvm::remarks::BitstreamMetaParserHelper *)v7, a2);
          }
        }
        else
        {
          llvm::remarks::BitstreamRemarkParser::processSeparateRemarksMetaMeta(this, (llvm::remarks::BitstreamMetaParserHelper *)v7, a2);
        }
      }
    }
  }
}

void llvm::remarks::BitstreamRemarkParser::parseRemark(llvm::remarks::BitstreamRemarkParser *this@<X0>, uint64_t a2@<X8>)
{
  v26[64] = *MEMORY[0x1E4F143B8];
  long long v6 = (char *)this + 40;
  __int16 v7 = 0;
  char v8 = 0;
  char v9 = 0;
  char v10 = 0;
  char v11 = 0;
  char v12 = 0;
  char v13 = 0;
  char v14 = 0;
  char v15 = 0;
  char v16 = 0;
  char v17 = 0;
  char v18 = 0;
  char v19 = 0;
  char v20 = 0;
  char v21 = 0;
  char v22 = 0;
  char v23 = 0;
  uint64_t v24 = v26;
  uint64_t v25 = 0x800000000;
  llvm::remarks::BitstreamRemarkParserHelper::parse((llvm::remarks::BitstreamRemarkParserHelper *)&v6, &v5);
  uint64_t v4 = v5;
  if (!v5) {
    llvm::remarks::BitstreamRemarkParser::processRemark(this, (llvm::remarks::BitstreamRemarkParserHelper *)&v6);
  }
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v4;
  if (v24 != v26) {
    free(v24);
  }
}

void sub_1CCD062C4(uint64_t *a1, llvm::remarks::BitstreamParserHelper *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  llvm::remarks::BitstreamParserHelper::parseMagic(this, (uint64_t)&v8);
  if (v9)
  {
    uint64_t v4 = v8;
    uint64_t v8 = 0;
LABEL_8:
    *a1 = v4;
    goto LABEL_9;
  }
  sub_1CCD05F48(a1, &v8, 4);
  if (*a1) {
    goto LABEL_9;
  }
  llvm::remarks::BitstreamParserHelper::parseBlockInfoBlock((void **)this, a1);
  if (*a1) {
    goto LABEL_9;
  }
  sub_1CCD05A54((uint64_t)&v6, (uint64_t)this);
  if (v7)
  {
    uint64_t v4 = v6;
    goto LABEL_8;
  }
  if (!(_BYTE)v6)
  {
    std::generic_category();
    sub_1CD06481C();
  }
  *a1 = 0;
LABEL_9:
  if (v9)
  {
    uint64_t v5 = v8;
    uint64_t v8 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
}

uint64_t llvm::remarks::BitstreamRemarkParser::processCommonMeta@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (!*(unsigned char *)(a2 + 24)
    || (*(void *)(result + 464) = *(void *)(a2 + 16), *(unsigned __int16 *)(a2 + 32) < 0x100u)
    || (unsigned int v4 = *(_WORD *)(a2 + 32), v4 >= 3))
  {
    std::generic_category();
    sub_1CD06481C();
  }
  *(_DWORD *)(result + 480) = v4;
  *a3 = 0;
  return result;
}

uint64_t llvm::remarks::BitstreamRemarkParser::processStandaloneMeta@<X0>(llvm::remarks::BitstreamRemarkParser *this@<X0>, llvm::remarks::BitstreamMetaParserHelper *a2@<X1>, void *a3@<X8>)
{
  long long v8 = *(_OWORD *)((char *)a2 + 40);
  uint64_t v9 = *((void *)a2 + 7);
  uint64_t result = sub_1CCD06A90(a3, (uint64_t)this, (uint64_t)&v8);
  if (!*a3)
  {
    if (!*((unsigned char *)a2 + 96))
    {
      char v7 = std::generic_category();
      uint64_t v11 = 92;
      char v12 = v7;
      uint64_t v10 = "Error while parsing BLOCK_META: missing remark version.";
      sub_1CD06481C();
    }
    *((void *)this + 59) = *((void *)a2 + 11);
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::remarks::BitstreamRemarkParser::processSeparateRemarksFileMeta@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (!*(unsigned char *)(a2 + 96))
  {
    std::generic_category();
    sub_1CD06481C();
  }
  *(void *)(result + 472) = *(void *)(a2 + 88);
  *a3 = 0;
  return result;
}

void llvm::remarks::BitstreamRemarkParser::processSeparateRemarksMetaMeta(llvm::remarks::BitstreamRemarkParser *this@<X0>, llvm::remarks::BitstreamMetaParserHelper *a2@<X1>, uint64_t *a3@<X8>)
{
  long long v8 = *(_OWORD *)((char *)a2 + 40);
  uint64_t v9 = *((void *)a2 + 7);
  sub_1CCD06A90(a3, (uint64_t)this, (uint64_t)&v8);
  if (!*a3)
  {
    long long v6 = *((_OWORD *)a2 + 4);
    uint64_t v7 = *((void *)a2 + 10);
    llvm::remarks::BitstreamRemarkParser::processExternalFilePath((uint64_t)this, (uint64_t)&v6, a3);
  }
}

void llvm::remarks::BitstreamRemarkParser::processExternalFilePath(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  v41[10] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a2 + 16))
  {
    *(void *)&long long v27 = 92;
    *((void *)&v27 + 1) = std::generic_category();
    *(void *)long long v40 = "Error while parsing BLOCK_META: missing external file path.";
    sub_1CD06481C();
  }
  char v6 = *(unsigned char *)(a1 + 39);
  if (v6 >= 0) {
    uint64_t v7 = (const void *)(a1 + 16);
  }
  else {
    uint64_t v7 = *(const void **)(a1 + 16);
  }
  if (v6 >= 0) {
    size_t v8 = v6 & 0x7F;
  }
  else {
    size_t v8 = *(void *)(a1 + 24);
  }
  *(void *)long long v40 = v41;
  *(_OWORD *)&v40[8] = xmmword_1CFB2C4C0;
  if (v8 >= 0x51) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v9 = 0;
  if (v8)
  {
    memcpy(v41, v7, v8);
    uint64_t v9 = *(void *)&v40[8];
  }
  *(void *)&v40[8] = v9 + v8;
  LOWORD(v29) = 261;
  uint64_t v10 = *(void *)(a2 + 8);
  *(void *)&long long v27 = *(void *)a2;
  *((void *)&v27 + 1) = v10;
  __int16 v39 = 257;
  __int16 v26 = 257;
  __int16 v23 = 257;
  llvm::sys::path::append(v40, 0, (const char **)&v27, v37, (uint64_t)&v24, (uint64_t)&v22);
  LOWORD(v29) = 261;
  long long v27 = *(_OWORD *)v40;
  sub_1CD096690((unsigned __int8 *)&v27, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)v37);
  if (v38)
  {
    char v12 = v37[0];
    if (LODWORD(v37[0]))
    {
      *(void *)&v11.__val_ = v37[1];
      LOWORD(v29) = 261;
      long long v27 = *(_OWORD *)v40;
      sub_1CD501664((uint64_t)&v27, (llvm *)v37[0], v11);
    }
  }
  else
  {
    std::system_category();
    char v12 = v37[0];
  }
  uint64_t v13 = *(void *)(a1 + 456);
  *(void *)(a1 + 456) = v12;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    char v12 = *(void **)(a1 + 456);
  }
  uint64_t v14 = v12[2] - v12[1];
  if (!v14) {
    operator new();
  }
  *(void *)&long long v27 = v12[1];
  *((void *)&v27 + 1) = v14;
  long long v28 = 0uLL;
  v32[1] = (char *)0x800000000;
  memset(v36, 0, sizeof(v36));
  long long v15 = v27;
  *(_OWORD *)(a1 + 56) = 0uLL;
  uint64_t v29 = 0x200000000;
  long long __p = 0uLL;
  uint64_t v31 = 0;
  v32[0] = &v33;
  *(void *)(a1 + 72) = 0x200000000;
  *(_OWORD *)(a1 + 40) = v15;
  sub_1CC1CAA38((uint64_t *)(a1 + 80));
  *(_OWORD *)(a1 + 80) = __p;
  *(void *)(a1 + 96) = v31;
  uint64_t v31 = 0;
  long long __p = 0uLL;
  sub_1CC1CAB0C(a1 + 104, (uint64_t)v32);
  *(void *)(a1 + 376) = v36[0];
  sub_1CC1CB1A4((void **)(a1 + 384));
  *(_OWORD *)(a1 + 384) = *(_OWORD *)&v36[1];
  *(void *)(a1 + 400) = v36[3];
  memset(&v36[1], 0, 24);
  uint64_t v24 = (uint64_t)&v36[1];
  sub_1CC1CB314((void ***)&v24);
  sub_1CC1CB3C4(v32);
  if ((void)__p)
  {
    sub_1CC1CAA74((uint64_t)&__p, __p);
    operator delete((void *)__p);
  }
  sub_1CCD062C4(a3, (llvm::remarks::BitstreamParserHelper *)(a1 + 40));
  if (!*a3)
  {
    *(void *)&long long v27 = a1 + 40;
    *((void *)&v27 + 1) = a1 + 384;
    LOBYTE(v28) = 0;
    BYTE8(v28) = 0;
    LOWORD(v29) = 0;
    LOBYTE(__p) = 0;
    LOBYTE(v31) = 0;
    LOBYTE(v32[0]) = 0;
    char v33 = 0;
    LOBYTE(v34) = 0;
    char v35 = 0;
    llvm::remarks::BitstreamMetaParserHelper::parse((llvm::remarks::BitstreamMetaParserHelper *)&v27, a3);
    if (!*a3)
    {
      uint64_t v16 = *(void *)(a1 + 464);
      uint64_t v21 = v16;
      llvm::remarks::BitstreamRemarkParser::processCommonMeta(a1, (uint64_t)&v27, a3);
      if (!*a3)
      {
        if (*(_DWORD *)(a1 + 480) == 1)
        {
          if (v16 != *(void *)(a1 + 464))
          {
            char v20 = std::generic_category();
            sub_1CD5E4C08(92, (uint64_t)v20, (uint64_t)"Error while parsing external file's BLOCK_META: mismatching versions: original meta: %lu, external file meta: %lu.", &v21, (uint64_t *)(a1 + 464));
          }
          if (v35)
          {
            *(void *)(a1 + 472) = v34;
            *a3 = 0;
            goto LABEL_28;
          }
          char v19 = std::generic_category();
          uint64_t v24 = 92;
          uint64_t v25 = v19;
          char v18 = "Error while parsing BLOCK_META: missing remark version.";
        }
        else
        {
          char v17 = std::generic_category();
          uint64_t v24 = 92;
          uint64_t v25 = v17;
          char v18 = "Error while parsing external file's BLOCK_META: wrong container type.";
        }
        char v22 = v18;
        sub_1CD06481C();
      }
    }
  }
LABEL_28:
  if (*(void **)v40 != v41) {
    free(*(void **)v40);
  }
}

uint64_t sub_1CCD06A90(void *a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a3 + 16))
  {
    std::generic_category();
    sub_1CD06481C();
  }
  uint64_t v6 = a2 + 408;
  if (*(unsigned char *)(a2 + 448))
  {
    uint64_t v7 = *(void **)(a2 + 424);
    if (v7)
    {
      *(void *)(a2 + 432) = v7;
      operator delete(v7);
    }
    *(unsigned char *)(a2 + 448) = 0;
  }
  uint64_t result = llvm::remarks::ParsedStringTable::ParsedStringTable(v6, *(void *)a3, *(void *)(a3 + 8));
  *(unsigned char *)(a2 + 448) = 1;
  *a1 = 0;
  return result;
}

void llvm::remarks::BitstreamRemarkParser::processRemark(llvm::remarks::BitstreamRemarkParser *this, llvm::remarks::BitstreamRemarkParserHelper *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCD070D8(uint64_t a1)
{
  sub_1CCD0741C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CCD07110(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    uint64_t v7 = result;
    uint64_t result = operator new(32 * a4);
    *uint64_t v7 = result;
    v7[1] = result;
    void v7[2] = &result[4 * a4];
    if (a2 != a3)
    {
      uint64_t v8 = a2 + 8;
      uint64_t v9 = (uint64_t)(result + 1);
      do
      {
        uint64_t v10 = v8 - 8;
        *(_DWORD *)(v9 - 8) = *(_DWORD *)(v8 - 8);
        if (*(char *)(v8 + 23) < 0)
        {
          sub_1CB8BDF7C(v9, *(const void **)v8, *(void *)(v8 + 8));
        }
        else
        {
          *(_OWORD *)uint64_t v9 = *(_OWORD *)v8;
          *(void *)(v9 + 16) = *(void *)(v8 + 16);
        }
        v8 += 32;
        v9 += 32;
      }
      while (v10 + 32 != a3);
      uint64_t result = (void *)(v9 - 8);
    }
    v7[1] = result;
  }
  return result;
}

void sub_1CCD071D0(uint64_t a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(char **)a1;
  if (a4 <= (v8 - *(void *)a1) >> 5)
  {
    char v18 = *(char **)(a1 + 8);
    unint64_t v19 = (v18 - v9) >> 5;
    if (v19 >= a4)
    {
      if (a2 == a3)
      {
        uint64_t v30 = *(char **)a1;
      }
      else
      {
        uint64_t v30 = *(char **)a1;
        do
        {
          uint64_t v31 = (const std::string *)(v6 + 2);
          int v32 = *v6;
          v6 += 8;
          char v33 = (std::string *)(v9 + 8);
          *(_DWORD *)uint64_t v9 = v32;
          v9 += 32;
          std::string::operator=(v33, v31);
          v30 += 32;
        }
        while (v6 != a3);
        char v18 = *(char **)(a1 + 8);
      }
      while (v18 != v30)
      {
        if (*(v18 - 1) < 0) {
          operator delete(*((void **)v18 - 3));
        }
        v18 -= 32;
      }
      *(void *)(a1 + 8) = v30;
    }
    else
    {
      char v20 = &a2[8 * v19];
      if (v18 != v9)
      {
        do
        {
          uint64_t v21 = (const std::string *)(v6 + 2);
          int v22 = *v6;
          v6 += 8;
          __int16 v23 = (std::string *)(v9 + 8);
          *(_DWORD *)uint64_t v9 = v22;
          v9 += 32;
          std::string::operator=(v23, v21);
        }
        while (v6 != v20);
        uint64_t v9 = *(char **)(a1 + 8);
      }
      uint64_t v24 = v9;
      if (v20 != a3)
      {
        uint64_t v25 = 0;
        do
        {
          __int16 v26 = &v20[v25];
          *(_DWORD *)&v9[v25 * 4] = v20[v25];
          long long v27 = &v9[v25 * 4 + 8];
          long long v28 = (const void **)&v20[v25 + 2];
          if (SHIBYTE(v20[v25 + 7]) < 0)
          {
            sub_1CB8BDF7C((uint64_t)v27, *v28, *((void *)v26 + 2));
          }
          else
          {
            long long v29 = *(_OWORD *)v28;
            *(void *)&v9[v25 * 4 + 24] = *(void *)&v20[v25 + 6];
            *(_OWORD *)long long v27 = v29;
          }
          v25 += 8;
        }
        while (v26 + 8 != a3);
        uint64_t v24 = &v9[v25 * 4];
      }
      *(void *)(a1 + 8) = v24;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v10 = *(void ***)(a1 + 8);
      std::error_code v11 = *(char **)a1;
      if (v10 != (void **)v9)
      {
        do
        {
          if (*((char *)v10 - 1) < 0) {
            operator delete(*(v10 - 3));
          }
          v10 -= 4;
        }
        while (v10 != (void **)v9);
        std::error_code v11 = *(char **)a1;
      }
      *(void *)(a1 + 8) = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (a4 >> 59) {
      goto LABEL_46;
    }
    uint64_t v12 = v8 >> 4;
    if (v8 >> 4 <= a4) {
      uint64_t v12 = a4;
    }
    unint64_t v13 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0 ? 0x7FFFFFFFFFFFFFFLL : v12;
    if (v13 >> 59) {
LABEL_46:
    }
      abort();
    uint64_t v14 = (char *)operator new(32 * v13);
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = &v14[32 * v13];
    if (v6 != a3)
    {
      long long v15 = v6 + 2;
      uint64_t v16 = (uint64_t)(v14 + 8);
      do
      {
        char v17 = v15 - 2;
        *(_DWORD *)(v16 - 8) = *(v15 - 2);
        if (*((char *)v15 + 23) < 0)
        {
          sub_1CB8BDF7C(v16, *(const void **)v15, *((void *)v15 + 1));
        }
        else
        {
          *(_OWORD *)uint64_t v16 = *(_OWORD *)v15;
          *(void *)(v16 + 16) = *((void *)v15 + 2);
        }
        v15 += 8;
        v16 += 32;
      }
      while (v17 + 8 != a3);
      uint64_t v14 = (char *)(v16 - 8);
    }
    *(void *)(a1 + 8) = v14;
  }
}

uint64_t sub_1CCD0741C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D0C8;
  uint64_t v2 = *(void *)(a1 + 456);
  *(void *)(a1 + 456) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(unsigned char *)(a1 + 448))
  {
    uint64_t v3 = *(void **)(a1 + 424);
    if (v3)
    {
      *(void *)(a1 + 432) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 448) = 0;
  }
  uint64_t v6 = (void **)(a1 + 384);
  sub_1CC1CB314(&v6);
  sub_1CC1CB3C4((char **)(a1 + 104));
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4)
  {
    sub_1CC1CAA74(a1 + 80, v4);
    operator delete(*(void **)(a1 + 80));
  }
  *(void *)a1 = &unk_1F263D050;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1CCD0751C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int *a5)
{
  memset(__p, 0, sizeof(__p));
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  long long v15 = __p;
  int v14 = 0;
  uint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v5 = *a4;
  int v6 = *a5;
  v17[0] = &unk_1F2619330;
  v17[1] = "Error while parsing %s: unknown record entry (%lu).";
  v17[2] = v5;
  int v18 = v6;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v7, (uint64_t)v17);
  operator new();
}

uint64_t sub_1CCD076A4(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  if (v1 >= *(_DWORD *)(result + 12))
  {
    memset(v4, 0, sizeof(v4));
    BOOL v3 = *(void *)result + (v1 << 6) > (unint64_t)v4;
    if (*(void *)result > (unint64_t)v4 || !v3) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v2 = (_OWORD *)(*(void *)result + (v1 << 6));
  v2[2] = 0u;
  v2[3] = 0u;
  _OWORD *v2 = 0u;
  v2[1] = 0u;
  ++*(_DWORD *)(result + 8);
  return result;
}

void sub_1CCD07784()
{
}

double sub_1CCD07798(int a1, llvm::raw_ostream *this)
{
  uint64_t v2 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v2) > 0x13)
  {
    *(_DWORD *)(v2 + 16) = 778331496;
    double result = *(double *)"End of file reached.";
    *(_OWORD *)uint64_t v2 = *(_OWORD *)"End of file reached.";
    *((void *)this + 4) += 20;
  }
  else
  {
    llvm::raw_ostream::write(this, "End of file reached.", 0x14uLL);
  }
  return result;
}

void *sub_1CCD077F0()
{
  return &llvm::remarks::EndOfFileError::ID;
}

BOOL sub_1CCD077FC(uint64_t a1, void *a2)
{
  return a2 == &llvm::remarks::EndOfFileError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

double llvm::remarks::BitstreamRemarkSerializerHelper::BitstreamRemarkSerializerHelper(uint64_t a1, int a2)
{
  *(void *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1CFB1BC20;
  *(void *)(a1 + 1048) = a1 + 1064;
  *(void *)(a1 + 1056) = 0x4000000000;
  *(void *)(a1 + 1576) = a1;
  *(void *)(a1 + 1584) = 0;
  *(void *)(a1 + 1592) = 0x20000000;
  *(void *)(a1 + 1600) = 0;
  *(_DWORD *)(a1 + 1608) = 2;
  double result = 0.0;
  *(_OWORD *)(a1 + 1616) = 0u;
  *(_OWORD *)(a1 + 1632) = 0u;
  *(_OWORD *)(a1 + 1648) = 0u;
  *(_OWORD *)(a1 + 1664) = 0u;
  *(void *)(a1 + 1680) = 0;
  *(_DWORD *)(a1 + 1688) = a2;
  *(_OWORD *)(a1 + 1696) = 0u;
  *(_OWORD *)(a1 + 1712) = 0u;
  *(_OWORD *)(a1 + 1728) = 0u;
  *(_OWORD *)(a1 + 1744) = 0u;
  *(void *)(a1 + 1760) = 0;
  return result;
}

{
  double result;

  *(void *)a1 = a1 + 24;
  *(_OWORD *)(a1 + 8) = xmmword_1CFB1BC20;
  *(void *)(a1 + 1048) = a1 + 1064;
  *(void *)(a1 + 1056) = 0x4000000000;
  *(void *)(a1 + 1576) = a1;
  *(void *)(a1 + 1584) = 0;
  *(void *)(a1 + 1592) = 0x20000000;
  *(void *)(a1 + 1600) = 0;
  *(_DWORD *)(a1 + 1608) = 2;
  double result = 0.0;
  *(_OWORD *)(a1 + 1616) = 0u;
  *(_OWORD *)(a1 + 1632) = 0u;
  *(_OWORD *)(a1 + 1648) = 0u;
  *(_OWORD *)(a1 + 1664) = 0u;
  *(void *)(a1 + 1680) = 0;
  *(_DWORD *)(a1 + 1688) = a2;
  *(_OWORD *)(a1 + 1696) = 0u;
  *(_OWORD *)(a1 + 1712) = 0u;
  *(_OWORD *)(a1 + 1728) = 0u;
  *(_OWORD *)(a1 + 1744) = 0u;
  *(void *)(a1 + 1760) = 0;
  return result;
}

llvm::raw_ostream *sub_1CCD07894(unsigned int a1, llvm::raw_ostream *a2, uint64_t a3, char *a4, uint64_t a5)
{
  *(_DWORD *)(a3 + 8) = 0;
  if (!*(_DWORD *)(a3 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  **(void **)a3 = a1;
  ++*(_DWORD *)(a3 + 8);
  sub_1CC21152C(a2, 1u, a3, 0);
  *(_DWORD *)(a3 + 8) = 0;
  sub_1CCD07D48(a3, *(void *)a3, a4, &a4[a5]);

  return sub_1CC21152C(a2, 2u, a3, 0);
}

llvm::raw_ostream *sub_1CCD07964(unsigned int a1, llvm::raw_ostream *a2, uint64_t a3, char *a4, uint64_t a5)
{
  *(_DWORD *)(a3 + 8) = 0;
  if (!*(_DWORD *)(a3 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  **(void **)a3 = a1;
  unsigned int v7 = *(_DWORD *)(a3 + 8) + 1;
  *(_DWORD *)(a3 + 8) = v7;
  sub_1CCD07D48(a3, *(void *)a3 + 8 * v7, a4, &a4[a5]);

  return sub_1CC21152C(a2, 3u, a3, 0);
}

llvm::raw_ostream *llvm::remarks::BitstreamRemarkSerializerHelper::flushToStream(llvm::remarks::BitstreamRemarkSerializerHelper *this, llvm::raw_ostream *a2)
{
  double result = llvm::raw_ostream::write(a2, *(const char **)this, *((void *)this + 1));
  *((void *)this + 1) = 0;
  return result;
}

uint64_t llvm::remarks::BitstreamRemarkSerializerHelper::getBuffer(llvm::remarks::BitstreamRemarkSerializerHelper *this)
{
  return *(void *)this;
}

uint64_t llvm::remarks::BitstreamRemarkSerializer::BitstreamRemarkSerializer(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a1 + 8) = 3;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D0F0;
  *(void *)(a1 + 176) = a1 + 200;
  *(unsigned char *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 184) = xmmword_1CFB1BC20;
  *(void *)(a1 + 1224) = a1 + 1240;
  *(void *)(a1 + 1232) = 0x4000000000;
  *(void *)(a1 + 1752) = a1 + 176;
  *(void *)(a1 + 1760) = 0;
  *(void *)(a1 + 1768) = 0x20000000;
  *(void *)(a1 + 1776) = 0;
  *(_DWORD *)(a1 + 1784) = 2;
  *(_OWORD *)(a1 + 1792) = 0u;
  *(_OWORD *)(a1 + 1808) = 0u;
  *(_OWORD *)(a1 + 1824) = 0u;
  *(_OWORD *)(a1 + 1840) = 0u;
  *(void *)(a1 + 1856) = 0;
  *(_DWORD *)(a1 + 1864) = 1;
  *(_OWORD *)(a1 + 1872) = 0u;
  *(_OWORD *)(a1 + 1888) = 0u;
  *(_OWORD *)(a1 + 1904) = 0u;
  *(_OWORD *)(a1 + 1920) = 0u;
  *(void *)(a1 + 1936) = 0;
  sub_1CD75C188(a1 + 32);
  return a1;
}

{
  *(_DWORD *)(a1 + 8) = 3;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D0F0;
  *(void *)(a1 + 176) = a1 + 200;
  *(unsigned char *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 184) = xmmword_1CFB1BC20;
  *(void *)(a1 + 1224) = a1 + 1240;
  *(void *)(a1 + 1232) = 0x4000000000;
  *(void *)(a1 + 1752) = a1 + 176;
  *(void *)(a1 + 1760) = 0;
  *(void *)(a1 + 1768) = 0x20000000;
  *(void *)(a1 + 1776) = 0;
  *(_DWORD *)(a1 + 1784) = 2;
  *(_OWORD *)(a1 + 1792) = 0u;
  *(_OWORD *)(a1 + 1808) = 0u;
  *(_OWORD *)(a1 + 1824) = 0u;
  *(_OWORD *)(a1 + 1840) = 0u;
  *(void *)(a1 + 1856) = 0;
  *(_DWORD *)(a1 + 1864) = 1;
  *(_OWORD *)(a1 + 1872) = 0u;
  *(_OWORD *)(a1 + 1888) = 0u;
  *(_OWORD *)(a1 + 1904) = 0u;
  *(_OWORD *)(a1 + 1920) = 0u;
  *(void *)(a1 + 1936) = 0;
  sub_1CD75C188(a1 + 32);
  return a1;
}

uint64_t llvm::remarks::BitstreamRemarkSerializer::BitstreamRemarkSerializer(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 8) = 3;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 32) = 0;
  uint64_t v5 = a1 + 32;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D0F0;
  *(unsigned char *)(a1 + 168) = 0;
  if (a3) {
    int v6 = 2;
  }
  else {
    int v6 = 1;
  }
  *(void *)(a1 + 176) = a1 + 200;
  *(_OWORD *)(a1 + 184) = xmmword_1CFB1BC20;
  *(void *)(a1 + 1224) = a1 + 1240;
  *(void *)(a1 + 1232) = 0x4000000000;
  *(void *)(a1 + 1752) = a1 + 176;
  *(void *)(a1 + 1760) = 0;
  *(void *)(a1 + 1768) = 0x20000000;
  *(void *)(a1 + 1776) = 0;
  *(_DWORD *)(a1 + 1784) = 2;
  *(_OWORD *)(a1 + 1792) = 0u;
  *(_OWORD *)(a1 + 1808) = 0u;
  *(_OWORD *)(a1 + 1824) = 0u;
  *(_OWORD *)(a1 + 1840) = 0u;
  *(void *)(a1 + 1856) = 0;
  *(_DWORD *)(a1 + 1864) = v6;
  *(_OWORD *)(a1 + 1872) = 0u;
  *(_OWORD *)(a1 + 1888) = 0u;
  *(_OWORD *)(a1 + 1904) = 0u;
  *(_OWORD *)(a1 + 1920) = 0u;
  *(void *)(a1 + 1936) = 0;
  sub_1CCD07FC4(v5, a4);
  return a1;
}

{
  uint64_t v5;
  int v6;

  *(_DWORD *)(a1 + 8) = 3;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 32) = 0;
  uint64_t v5 = a1 + 32;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D0F0;
  *(unsigned char *)(a1 + 168) = 0;
  if (a3) {
    int v6 = 2;
  }
  else {
    int v6 = 1;
  }
  *(void *)(a1 + 176) = a1 + 200;
  *(_OWORD *)(a1 + 184) = xmmword_1CFB1BC20;
  *(void *)(a1 + 1224) = a1 + 1240;
  *(void *)(a1 + 1232) = 0x4000000000;
  *(void *)(a1 + 1752) = a1 + 176;
  *(void *)(a1 + 1760) = 0;
  *(void *)(a1 + 1768) = 0x20000000;
  *(void *)(a1 + 1776) = 0;
  *(_DWORD *)(a1 + 1784) = 2;
  *(_OWORD *)(a1 + 1792) = 0u;
  *(_OWORD *)(a1 + 1808) = 0u;
  *(_OWORD *)(a1 + 1824) = 0u;
  *(_OWORD *)(a1 + 1840) = 0u;
  *(void *)(a1 + 1856) = 0;
  *(_DWORD *)(a1 + 1864) = v6;
  *(_OWORD *)(a1 + 1872) = 0u;
  *(_OWORD *)(a1 + 1888) = 0u;
  *(_OWORD *)(a1 + 1904) = 0u;
  *(_OWORD *)(a1 + 1920) = 0u;
  *(void *)(a1 + 1936) = 0;
  sub_1CCD07FC4(v5, a4);
  return a1;
}

void sub_1CCD07D10(uint64_t a1)
{
  sub_1CCD07EC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCD07D48(uint64_t result, uint64_t a2, char *a3, char *a4)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(result + 8);
  if (*(void *)result + 8 * v5 == a2)
  {
    return sub_1CC208214(result, a3, a4);
  }
  else
  {
    uint64_t v6 = (a2 - v4) >> 3;
    int v8 = a3;
    unint64_t v9 = a4 - a3;
    if (a4 - a3 + v5 > (unint64_t)*(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v10 = (char *)(v4 + 8 * v6);
    uint64_t v11 = (char *)(v4 + 8 * v5);
    unint64_t v12 = (v11 - v10) >> 3;
    if (v12 >= v9)
    {
      double result = sub_1CD4570C8(result, &v11[-8 * v9], (char *)(v4 + 8 * v5));
      if (&v11[-8 * v9] != v10) {
        double result = (uint64_t)memmove(&v10[8 * v9], v10, &v11[-8 * v9] - v10);
      }
      for (; v8 != a4; ++v8)
      {
        *(void *)uint64_t v10 = *v8;
        v10 += 8;
      }
    }
    else
    {
      *(_DWORD *)(result + 8) = v5 + v9;
      if (v6 != v5)
      {
        double result = (uint64_t)memcpy((void *)(v4 + 8 * (v5 + v9) - 8 * v12), v10, v11 - v10);
        do
        {
          uint64_t v13 = *v8++;
          *(void *)uint64_t v10 = v13;
          v10 += 8;
          --v12;
        }
        while (v12);
      }
      for (; v8 != a4; ++v8)
      {
        *(void *)uint64_t v11 = *v8;
        v11 += 8;
      }
    }
  }
  return result;
}

uint64_t sub_1CCD07EC8(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D0F0;
  sub_1CD75C134(a1 + 176);
  *(void *)a1 = &unk_1F263D148;
  if (*(unsigned char *)(a1 + 160))
  {
    free(*(void **)(a1 + 32));
    uint64_t v2 = *(unsigned int *)(a1 + 80);
    if (v2)
    {
      BOOL v3 = *(uint64_t **)(a1 + 72);
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *v3++;
        MEMORY[0x1D25D9CD0](v5, 8);
        v4 -= 8;
      }
      while (v4);
    }
    uint64_t v6 = *(uint64_t **)(a1 + 120);
    uint64_t v7 = *(unsigned int *)(a1 + 128);
    if (v7)
    {
      uint64_t v10 = 16 * v7;
      do
      {
        uint64_t v11 = *v6;
        v6 += 2;
        MEMORY[0x1D25D9CD0](v11, 8);
        v10 -= 16;
      }
      while (v10);
      uint64_t v6 = *(uint64_t **)(a1 + 120);
    }
    if (v6 != (uint64_t *)(a1 + 136)) {
      free(v6);
    }
    int v8 = *(void **)(a1 + 72);
    if (v8 != (void *)(a1 + 88)) {
      free(v8);
    }
    *(unsigned char *)(a1 + 160) = 0;
  }
  return a1;
}

uint64_t sub_1CCD07FC4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 128))
  {
    sub_1CD75C214(a1, a2);
  }
  else
  {
    *(void *)a1 = *(void *)a2;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    sub_1CC056A04(a1 + 24, a2 + 24);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(unsigned char *)(a1 + 128) = 1;
  }
  return a1;
}

void sub_1CCD08038(uint64_t a1, uint64_t a2)
{
  v16[2] = *MEMORY[0x1E4F143B8];
  sub_1CC056A04((uint64_t)v10, a1);
  sub_1CD49A7EC(a1, a2);
  sub_1CD49A7EC(a2, (uint64_t)v10);
  if (v12)
  {
    uint64_t v4 = (uint64_t *)v11;
    uint64_t v5 = 8 * v12;
    do
    {
      uint64_t v6 = *v4++;
      MEMORY[0x1D25D9CD0](v6, 8);
      v5 -= 8;
    }
    while (v5);
  }
  uint64_t v7 = (uint64_t *)v14;
  if (v15)
  {
    uint64_t v8 = 16 * v15;
    do
    {
      uint64_t v9 = *v7;
      v7 += 2;
      MEMORY[0x1D25D9CD0](v9, 8);
      v8 -= 16;
    }
    while (v8);
    uint64_t v7 = (uint64_t *)v14;
  }
  if (v7 != v16) {
    free(v7);
  }
  if (v11 != &v13) {
    free(v11);
  }
}

void llvm::remarks::Remark::getArgsAsMsg(llvm::remarks::Remark *this@<X0>, uint64_t a2@<X8>)
{
  v19[0] = 0;
  v19[1] = 0;
  uint64_t v20 = 0;
  int v11 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  BOOL v3 = v19;
  int v18 = v19;
  int v17 = 0;
  uint64_t v10 = &unk_1F2646F30;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v4 = *((unsigned int *)this + 28);
  if (v4)
  {
    uint64_t v5 = v4 << 6;
    uint64_t v6 = (size_t *)(*((void *)this + 13) + 24);
    do
    {
      uint64_t v7 = (const void *)*(v6 - 1);
      size_t v8 = *v6;
      if (*v6 <= v13 - (uint64_t)v14)
      {
        if (v8)
        {
          memcpy(v14, v7, *v6);
          v14 += v8;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v10, (const char *)v7, *v6);
      }
      v6 += 8;
      v5 -= 64;
    }
    while (v5);
    BOOL v3 = v18;
  }
  if (*((char *)v3 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v3, (unint64_t)v3[1]);
  }
  else
  {
    long long v9 = *(_OWORD *)v3;
    *(void *)(a2 + 16) = v3[2];
    *(_OWORD *)a2 = v9;
  }
  uint64_t v10 = &unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
}

uint64_t LLVMRemarkStringGetData(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t LLVMRemarkStringGetLen(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t LLVMRemarkDebugLocGetSourceLine(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t LLVMRemarkDebugLocGetSourceColumn(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t LLVMRemarkArgGetValue(uint64_t a1)
{
  return a1 + 16;
}

uint64_t LLVMRemarkArgGetDebugLoc(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

uint64_t LLVMRemarkEntryDispose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void **)(result + 104);
    if (v2 != (void *)(v1 + 120)) {
      free(v2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t LLVMRemarkEntryGetType(unsigned int *a1)
{
  return *a1;
}

uint64_t LLVMRemarkEntryGetPassName(uint64_t a1)
{
  return a1 + 8;
}

uint64_t LLVMRemarkEntryGetRemarkName(uint64_t a1)
{
  return a1 + 24;
}

uint64_t LLVMRemarkEntryGetFunctionName(uint64_t a1)
{
  return a1 + 40;
}

uint64_t LLVMRemarkEntryGetDebugLoc(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80)) {
    return a1 + 56;
  }
  else {
    return 0;
  }
}

uint64_t LLVMRemarkEntryGetHotness(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96)) {
    return *(void *)(a1 + 88);
  }
  else {
    return 0;
  }
}

uint64_t LLVMRemarkEntryGetNumArgs(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t LLVMRemarkEntryGetFirstArg(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 112)) {
    return *(void *)(a1 + 104);
  }
  else {
    return 0;
  }
}

uint64_t LLVMRemarkEntryGetNextArg(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (result + 64 == *(void *)(a2 + 104) + ((unint64_t)*(unsigned int *)(a2 + 112) << 6)) {
      return 0;
    }
    else {
      result += 64;
    }
  }
  return result;
}

_DWORD *llvm::remarks::magicToFormat@<X0>(_DWORD *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = (uint64_t)result;
  if (a2 < 4) {
    goto LABEL_16;
  }
  uint64_t v5 = 0x100000001;
  if (*result != 539831597) {
    uint64_t v5 = 0;
  }
  if (a2 >= 7 && *result != 539831597 && !(*result ^ 0x414D4552 | *(_DWORD *)((char *)result + 3) ^ 0x534B5241)) {
    uint64_t v5 = 0x100000002;
  }
  if ((v5 & 0x100000000) == 0 && *result == 1263684946) {
    uint64_t v5 = 0x100000003;
  }
  if ((v5 & 0x100000000) == 0 || v5 == 0)
  {
LABEL_16:
    uint64_t v7 = std::generic_category();
    uint64_t v8 = v3;
    sub_1CD5E3960(22, (uint64_t)v7, (uint64_t)"Unknown remark magic: '%s'", &v8);
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v5;
  return result;
}

void *llvm::remarks::getRemarksSectionContents@<X0>(llvm::remarks *this@<X0>, const llvm::object::ObjectFile *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)this + 2) & 0xFFFFFFFC) != 0x10)
  {
    uint64_t v21 = 92;
    int v22 = std::generic_category();
    v19[0] = "Unsupported file format.";
    sub_1CD06481C();
  }
  uint64_t v5 = (*(uint64_t (**)(llvm::remarks *, const llvm::object::ObjectFile *))(*(void *)this + 344))(this, a2);
  uint64_t v7 = v6;
  double result = (void *)(*(uint64_t (**)(llvm::remarks *))(*(void *)this + 352))(this);
  int v17 = (void *)v5;
  uint64_t v18 = v7;
  if (v7 == v9 && v5 == (void)result)
  {
LABEL_18:
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 1) = 0;
    *(_DWORD *)(a3 + 17) = 0;
    *(_DWORD *)(a3 + 20) = 0;
    *(unsigned char *)(a3 + 24) &= ~1u;
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
    return result;
  }
  int v11 = result;
  uint64_t v12 = v9;
  while (1)
  {
    double result = (*(void *(**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v7 + 136))(v19, v7, v5);
    if (v20)
    {
      uint64_t v15 = v19[0];
      v19[0] = 0;
LABEL_22:
      *(unsigned char *)(a3 + 24) |= 1u;
      *(void *)a3 = v15;
      goto LABEL_25;
    }
    if (v19[1] == 9 && *(void *)v19[0] == 0x6B72616D65725F5FLL && *(unsigned char *)(v19[0] + 8) == 115) {
      break;
    }
    double result = (void *)(*(uint64_t (**)(uint64_t, void **))(*(void *)v18 + 128))(v18, &v17);
    uint64_t v5 = (uint64_t)v17;
    uint64_t v7 = v18;
    if (v18 == v12 && v17 == v11) {
      goto LABEL_18;
    }
  }
  double result = (*(void *(**)(uint64_t *__return_ptr))(*(void *)v18 + 168))(&v21);
  uint64_t v15 = v21;
  if (v23) {
    goto LABEL_22;
  }
  uint64_t v16 = v22;
  *(unsigned char *)(a3 + 24) &= ~1u;
  *(void *)a3 = v15;
  *(void *)(a3 + 8) = v16;
  *(unsigned char *)(a3 + 16) = 1;
LABEL_25:
  if (v20)
  {
    double result = (void *)v19[0];
    v19[0] = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

uint64_t llvm::remarks::RemarkLinker::keep(uint64_t **a1, llvm::remarks::Remark **a2)
{
  return sub_1CCD08E94(a1 + 16, (int **)a2, (uint64_t *)a2)[4];
}

double llvm::remarks::RemarkLinker::setExternalFilePrependPath(uint64_t a1, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    p_dst = (long long *)operator new(v7 + 1);
    *((void *)&__dst + 1) = __len;
    unint64_t v12 = v8 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v12) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_8:
  }
    memmove(p_dst, __src, __len);
  *((unsigned char *)p_dst + __len) = 0;
  uint64_t v9 = (void **)(a1 + 152);
  if (*(unsigned char *)(a1 + 176))
  {
    if (*(char *)(a1 + 175) < 0) {
      operator delete(*v9);
    }
    double result = *(double *)&__dst;
    *(_OWORD *)uint64_t v9 = __dst;
    *(void *)(a1 + 168) = v12;
  }
  else
  {
    double result = *(double *)&__dst;
    *(_OWORD *)uint64_t v9 = __dst;
    *(void *)(a1 + 168) = v12;
    *(unsigned char *)(a1 + 176) = 1;
  }
  return result;
}

_DWORD *llvm::remarks::RemarkLinker::link@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, llvm::remarks::Remark **a5@<X8>)
{
  int v5 = a4;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((a4 & 0xFF00000000) == 0)
  {
    double result = llvm::remarks::magicToFormat(a2, a3, (uint64_t)&v33);
    if (v34)
    {
      *a5 = v33;
      return result;
    }
    int v5 = (int)v33;
  }
  v27[0] = 0;
  char v30 = 0;
  char v11 = *(unsigned char *)(a1 + 176);
  if (v11)
  {
    uint64_t v12 = *(void *)(a1 + 152);
    char v13 = *(unsigned char *)(a1 + 175);
    int v14 = v13;
    if (v13 >= 0) {
      uint64_t v12 = a1 + 152;
    }
    uint64_t v15 = *(void *)(a1 + 160);
    uint64_t v16 = v13 & 0x7F;
    if (v14 >= 0) {
      uint64_t v15 = v16;
    }
    *(void *)&long long v25 = v12;
    *((void *)&v25 + 1) = v15;
    char v11 = 1;
  }
  else
  {
    LOBYTE(v25) = 0;
  }
  char v26 = v11;
  llvm::remarks::createRemarkParserFromMeta(v5, (uint64_t)a2, a3, (uint64_t)v27, &v25, (uint64_t)&v33);
  if (v30)
  {
    if (__p)
    {
      long long v29 = __p;
      operator delete(__p);
    }
    char v30 = 0;
  }
  char v17 = v34;
  if (v34)
  {
    double result = 0;
    *a5 = v33;
  }
  else
  {
    uint64_t v18 = v33;
    (**(void (***)(llvm::remarks::Remark **__return_ptr, llvm::remarks::Remark *))v33)(&v31, v33);
    while ((v32 & 1) == 0)
    {
      unint64_t v19 = (int *)v31;
      if (*((unsigned char *)v31 + 80))
      {
        uint64_t v31 = 0;
        char v23 = v19;
        llvm::remarks::StringTable::internalize((llvm::remarks::StringTable *)a1, (llvm::remarks::Remark *)v19);
        sub_1CCD08E94((uint64_t **)(a1 + 128), &v23, (uint64_t *)&v23);
        char v20 = v23;
        char v23 = 0;
        if (v20)
        {
          uint64_t v21 = (int *)*((void *)v20 + 13);
          if (v21 != v20 + 30) {
            free(v21);
          }
          MEMORY[0x1D25D9CE0](v20, 0x10D2C401DAD59E6);
        }
      }
      sub_1CCD09748((uint64_t)&v31);
      (**(void (***)(llvm::remarks::Remark **__return_ptr, llvm::remarks::Remark *))v18)(&v31, v18);
    }
    int v22 = v31;
    uint64_t v31 = 0;
    *a5 = v22;
    if ((*(uint64_t (**)(llvm::remarks::Remark *, void *))(*(void *)v22 + 48))(v22, &llvm::remarks::EndOfFileError::ID))
    {
      uint64_t v24 = v22;
      sub_1CD4515D0((void **)&v24);
      if (v24) {
        (*(void (**)(llvm::remarks::Remark *))(*(void *)v24 + 8))(v24);
      }
      sub_1CCD09748((uint64_t)&v31);
      *a5 = 0;
    }
    else
    {
      sub_1CCD09748((uint64_t)&v31);
    }
    double result = v33;
    char v17 = v34;
  }
  char v33 = 0;
  if (v17)
  {
    if (result) {
      return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 8))(result);
    }
  }
  else if (result)
  {
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)result + 16))(result);
  }
  return result;
}

void *llvm::remarks::RemarkLinker::link@<X0>(llvm::remarks *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X2>, llvm::remarks::Remark **a4@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  double result = llvm::remarks::getRemarksSectionContents(this, this, (uint64_t)v10);
  if (v12)
  {
    *a4 = (llvm::remarks::Remark *)v10[0];
  }
  else if (v11)
  {
    size_t v8 = (_DWORD *)v10[0];
    unint64_t v9 = v10[1];
    return llvm::remarks::RemarkLinker::link(a2, v8, v9, a3, a4);
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

void llvm::remarks::RemarkLinker::serialize(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  sub_1CC056A04((uint64_t)&v5, a1 + 24);
  uint64_t v6 = *(void *)(a1 + 120);
  llvm::remarks::createRemarkSerializer(a3);
}

uint64_t *sub_1CCD08E94(uint64_t **a1, int **a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (!v5)
  {
    uint64_t v8 = (uint64_t)(a1 + 1);
LABEL_10:
    unint64_t v9 = (uint64_t *)operator new(0x28uLL);
    uint64_t v10 = *a3;
    *a3 = 0;
    v9[4] = v10;
    *unint64_t v9 = 0;
    v9[1] = 0;
    _OWORD v9[2] = v8;
    *uint64_t v6 = v9;
    char v11 = (uint64_t *)**a1;
    char v12 = v9;
    if (v11)
    {
      *a1 = v11;
      char v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return v9;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v8 = (uint64_t)v5;
      if (!sub_1CCD08F80(*a2, (int *)v5[4])) {
        break;
      }
      uint64_t v5 = *(uint64_t **)v8;
      uint64_t v6 = (uint64_t **)v8;
      if (!*(void *)v8) {
        goto LABEL_10;
      }
    }
    if (!sub_1CCD08F80(*(int **)(v8 + 32), *a2)) {
      break;
    }
    uint64_t v6 = (uint64_t **)(v8 + 8);
    uint64_t v5 = *(uint64_t **)(v8 + 8);
    if (!v5) {
      goto LABEL_10;
    }
  }
  unint64_t v9 = *v6;
  if (!*v6) {
    goto LABEL_10;
  }
  return v9;
}

uint64_t sub_1CCD08F80(int *a1, int *a2)
{
  v42[40] = *MEMORY[0x1E4F143B8];
  int v34 = *a1;
  long long __s1 = *(_OWORD *)(a1 + 2);
  long long v36 = *(_OWORD *)(a1 + 6);
  long long v37 = *(_OWORD *)(a1 + 10);
  v38[0] = *(_OWORD *)(a1 + 14);
  v38[1] = *(_OWORD *)(a1 + 18);
  long long v39 = *(_OWORD *)(a1 + 22);
  long long v40 = v42;
  uint64_t v41 = 0x500000000;
  if (a1[28]) {
    sub_1CCD09678((uint64_t)&v40, (uint64_t)(a1 + 26));
  }
  int v3 = *a2;
  int v25 = *a2;
  *(_OWORD *)__s2 = *(_OWORD *)(a2 + 2);
  *(_OWORD *)long long v27 = *(_OWORD *)(a2 + 6);
  *(_OWORD *)long long v28 = *(_OWORD *)(a2 + 10);
  v29[0] = *(_OWORD *)(a2 + 14);
  long long v4 = *(_OWORD *)(a2 + 22);
  v29[1] = *(_OWORD *)(a2 + 18);
  long long v30 = v4;
  uint64_t v31 = v33;
  uint64_t v32 = 0x500000000;
  if (a2[28])
  {
    sub_1CCD09678((uint64_t)&v31, (uint64_t)(a2 + 26));
    int v3 = v25;
  }
  if (v34 < v3) {
    goto LABEL_6;
  }
  if (v3 >= v34)
  {
    uint64_t v7 = (void *)*((void *)&__s1 + 1);
    if (__s2[1] >= (void *)*((void *)&__s1 + 1)) {
      size_t v8 = *((void *)&__s1 + 1);
    }
    else {
      size_t v8 = (size_t)__s2[1];
    }
    if (v8)
    {
      unint64_t v9 = (const void *)__s1;
      int v10 = memcmp((const void *)__s1, __s2[0], v8);
      if (v10 < 0 || !v10 && v7 < __s2[1]) {
        goto LABEL_6;
      }
      int v11 = memcmp(__s2[0], v9, v8);
      if (v11 < 0) {
        goto LABEL_8;
      }
      if (v11 || (BOOL v12 = __s2[1] >= v7, __s2[1] == v7))
      {
LABEL_29:
        uint64_t v13 = (void *)*((void *)&v36 + 1);
        if (v27[1] >= (void *)*((void *)&v36 + 1)) {
          size_t v14 = *((void *)&v36 + 1);
        }
        else {
          size_t v14 = (size_t)v27[1];
        }
        if (v14)
        {
          uint64_t v15 = (const void *)v36;
          int v16 = memcmp((const void *)v36, v27[0], v14);
          if (v16 < 0 || !v16 && v13 < v27[1]) {
            goto LABEL_6;
          }
          int v17 = memcmp(v27[0], v15, v14);
          if (v17 < 0) {
            goto LABEL_8;
          }
          if (v17 || (BOOL v18 = v27[1] >= v13, v27[1] == v13))
          {
LABEL_44:
            unint64_t v19 = (void *)*((void *)&v37 + 1);
            if (v28[1] >= (void *)*((void *)&v37 + 1)) {
              size_t v20 = *((void *)&v37 + 1);
            }
            else {
              size_t v20 = (size_t)v28[1];
            }
            if (v20)
            {
              uint64_t v21 = (const void *)v37;
              int v22 = memcmp((const void *)v37, v28[0], v20);
              if (v22 < 0 || !v22 && v19 < v28[1]) {
                goto LABEL_6;
              }
              int v23 = memcmp(v28[0], v21, v20);
              if (v23 < 0) {
                goto LABEL_8;
              }
              if (v23 || (BOOL v24 = v28[1] >= v19, v28[1] == v19))
              {
LABEL_59:
                if ((sub_1CCD09304((uint64_t)v38, (uint64_t)v29) & 1) == 0)
                {
                  if (sub_1CCD09304((uint64_t)v29, (uint64_t)v38)) {
                    goto LABEL_8;
                  }
                  if (BYTE8(v39) && BYTE8(v30))
                  {
                    if ((unint64_t)v39 < (unint64_t)v30) {
                      goto LABEL_6;
                    }
                  }
                  else if (!BYTE8(v39) && BYTE8(v30))
                  {
                    goto LABEL_6;
                  }
                  if (BYTE8(v39) && BYTE8(v30))
                  {
                    if ((unint64_t)v30 < (unint64_t)v39) {
                      goto LABEL_8;
                    }
                  }
                  else if (BYTE8(v39) && !BYTE8(v30))
                  {
                    goto LABEL_8;
                  }
                  if ((sub_1CCD0940C((long long *)v40, (long long *)v40 + 4 * (unint64_t)v41, (long long *)v31, (long long *)v31 + 4 * (unint64_t)v32) & 1) == 0)
                  {
                    sub_1CCD0940C((long long *)v31, (long long *)v31 + 4 * (unint64_t)v32, (long long *)v40, (long long *)v40 + 4 * (unint64_t)v41);
                    goto LABEL_8;
                  }
                }
LABEL_6:
                uint64_t v5 = 1;
                goto LABEL_9;
              }
            }
            else
            {
              if ((void *)*((void *)&v37 + 1) < v28[1]) {
                goto LABEL_6;
              }
              BOOL v24 = v28[1] >= (void *)*((void *)&v37 + 1);
            }
            if (!v24) {
              goto LABEL_8;
            }
            goto LABEL_59;
          }
        }
        else
        {
          if ((void *)*((void *)&v36 + 1) < v27[1]) {
            goto LABEL_6;
          }
          BOOL v18 = v27[1] >= (void *)*((void *)&v36 + 1);
        }
        if (!v18) {
          goto LABEL_8;
        }
        goto LABEL_44;
      }
    }
    else
    {
      if ((void *)*((void *)&__s1 + 1) < __s2[1]) {
        goto LABEL_6;
      }
      BOOL v12 = __s2[1] >= (void *)*((void *)&__s1 + 1);
    }
    if (!v12) {
      goto LABEL_8;
    }
    goto LABEL_29;
  }
LABEL_8:
  uint64_t v5 = 0;
LABEL_9:
  if (v31 != v33) {
    free(v31);
  }
  if (v40 != v42) {
    free(v40);
  }
  return v5;
}

uint64_t sub_1CCD09304(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 24);
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = v2 == 0;
  }
  if (v3) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v2 == 0;
  }
  if (!v4) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 24) && v2 == 0) {
    return 0;
  }
  unint64_t v6 = *(void *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  unsigned int v8 = *(_DWORD *)(a1 + 20);
  unint64_t v9 = *(void *)(a2 + 8);
  unsigned int v10 = *(_DWORD *)(a2 + 16);
  unsigned int v11 = *(_DWORD *)(a2 + 20);
  if (v9 >= v6) {
    size_t v12 = *(void *)(a1 + 8);
  }
  else {
    size_t v12 = *(void *)(a2 + 8);
  }
  if (!v12)
  {
    if (v6 >= v9)
    {
      BOOL v17 = v9 >= v6;
      goto LABEL_28;
    }
    return 1;
  }
  uint64_t v13 = *(const void **)a2;
  size_t v14 = *(const void **)a1;
  int v15 = memcmp(*(const void **)a1, *(const void **)a2, v12);
  if (v15 < 0 || !v15 && v6 < v9) {
    return 1;
  }
  int v16 = memcmp(v13, v14, v12);
  if (v16 < 0) {
    return 0;
  }
  if (!v16)
  {
    BOOL v17 = v9 >= v6;
    if (v9 != v6)
    {
LABEL_28:
      if (v17) {
        goto LABEL_30;
      }
      return 0;
    }
  }
LABEL_30:
  BOOL v20 = v10 >= v7 && v8 < v11;
  return v7 < v10 || v20;
}

uint64_t sub_1CCD0940C(long long *a1, long long *a2, long long *a3, long long *a4)
{
  if (a3 == a4) {
    return 0;
  }
  uint64_t v28 = v4;
  uint64_t v29 = v5;
  unsigned int v7 = a3;
  while (a1 != a2)
  {
    long long v10 = a1[1];
    long long v24 = *a1;
    long long v25 = v10;
    long long v11 = a1[3];
    long long v26 = a1[2];
    long long v27 = v11;
    long long v12 = v7[1];
    long long v20 = *v7;
    long long v21 = v12;
    long long v13 = v7[3];
    long long v22 = v7[2];
    long long v23 = v13;
    if (sub_1CCD0951C((uint64_t)&v24, (uint64_t)&v20)) {
      break;
    }
    long long v14 = v7[1];
    long long v24 = *v7;
    long long v25 = v14;
    long long v15 = v7[3];
    long long v26 = v7[2];
    long long v27 = v15;
    long long v16 = a1[1];
    long long v20 = *a1;
    long long v21 = v16;
    long long v17 = a1[3];
    long long v22 = a1[2];
    long long v23 = v17;
    char v18 = sub_1CCD0951C((uint64_t)&v24, (uint64_t)&v20);
    uint64_t result = 0;
    if ((v18 & 1) == 0)
    {
      v7 += 4;
      a1 += 4;
      if (v7 != a4) {
        continue;
      }
    }
    return result;
  }
  return 1;
}

uint64_t sub_1CCD0951C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a2 + 8);
  if (v5 >= v4) {
    size_t v6 = *(void *)(a1 + 8);
  }
  else {
    size_t v6 = *(void *)(a2 + 8);
  }
  if (v6)
  {
    unsigned int v7 = *(const void **)a2;
    unsigned int v8 = *(const void **)a1;
    int v9 = memcmp(*(const void **)a1, *(const void **)a2, v6);
    if (v9 < 0) {
      return 1;
    }
    if (!v9 && v4 < v5) {
      return 1;
    }
    int v11 = memcmp(v7, v8, v6);
    if (v11 < 0) {
      return 0;
    }
    BOOL v12 = v11 || v5 == v4;
    if (!v12 && v5 < v4) {
      return 0;
    }
  }
  else
  {
    if (v4 < v5) {
      return 1;
    }
    if (v5 < v4) {
      return 0;
    }
  }
  unint64_t v15 = *(void *)(a1 + 24);
  unint64_t v16 = *(void *)(a2 + 24);
  if (v16 >= v15) {
    size_t v17 = *(void *)(a1 + 24);
  }
  else {
    size_t v17 = *(void *)(a2 + 24);
  }
  if (!v17)
  {
    if (v15 >= v16)
    {
      BOOL v22 = v16 >= v15;
LABEL_38:
      if (v22) {
        goto LABEL_40;
      }
      return 0;
    }
    return 1;
  }
  char v18 = *(const void **)(a2 + 16);
  unint64_t v19 = *(const void **)(a1 + 16);
  int v20 = memcmp(v19, v18, v17);
  if (v20 < 0 || !v20 && v15 < v16) {
    return 1;
  }
  int v21 = memcmp(v18, v19, v17);
  if (v21 < 0) {
    return 0;
  }
  if (!v21)
  {
    BOOL v22 = v16 >= v15;
    if (v16 != v15) {
      goto LABEL_38;
    }
  }
LABEL_40:

  return sub_1CCD09304(a1 + 32, a2 + 32);
}

uint64_t sub_1CCD09678(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, v4 << 6);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, v5 << 6);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + (v5 << 6)), (const void *)(*(void *)a2 + (v5 << 6)), *(void *)a2 + (v6 << 6) - (*(void *)a2 + (v5 << 6)));
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

uint64_t sub_1CCD09748(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(void *)a1;
    *(void *)a1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  else
  {
    sub_1CCD097B0((uint64_t *)a1);
  }
  return a1;
}

uint64_t *sub_1CCD097B0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    BOOL v3 = *(void **)(v2 + 104);
    if (v3 != (void *)(v2 + 120)) {
      free(v3);
    }
    MEMORY[0x1D25D9CE0](v2, 0x10D2C401DAD59E6);
  }
  return a1;
}

uint64_t llvm::remarks::ParsedStringTable::ParsedStringTable(uint64_t a1, uint64_t a2, unint64_t a3)
{
  *(void *)&long long v24 = a2;
  *((void *)&v24 + 1) = a3;
  *(_OWORD *)a1 = v24;
  *(void *)(a1 + 16) = 0;
  uint64_t v4 = (void **)(a1 + 16);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  if (a3)
  {
    unint64_t v5 = a3;
    uint64_t v6 = a2;
    unsigned int v7 = 0;
    do
    {
      uint64_t v8 = v6;
      char v25 = 0;
      uint64_t v9 = llvm::StringRef::find((uint64_t *)&v24, &v25, 1uLL, 0);
      unint64_t v10 = v9 + 1;
      if (v5 < v9 + 1) {
        unint64_t v10 = v5;
      }
      if (v9 == -1) {
        uint64_t v6 = 0;
      }
      else {
        v6 += v10;
      }
      unint64_t v11 = v5 - v10;
      if (v9 == -1) {
        unint64_t v5 = 0;
      }
      else {
        unint64_t v5 = v11;
      }
      uint64_t v12 = v8 - *(void *)a1;
      unint64_t v13 = *(void *)(a1 + 32);
      if ((unint64_t)v7 >= v13)
      {
        unint64_t v15 = (char *)*v4;
        uint64_t v16 = (v7 - (unsigned char *)*v4) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          abort();
        }
        uint64_t v18 = v13 - (void)v15;
        if (v18 >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 >> 61) {
            sub_1CB833614();
          }
          int v20 = (char *)operator new(8 * v19);
        }
        else
        {
          int v20 = 0;
        }
        int v21 = &v20[8 * v16];
        *(void *)int v21 = v12;
        long long v14 = v21 + 8;
        while (v7 != v15)
        {
          uint64_t v22 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }
        *(void *)(a1 + 16) = v21;
        *(void *)(a1 + 24) = v14;
        *(void *)(a1 + 32) = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)unsigned int v7 = v12;
        long long v14 = v7 + 8;
      }
      *(void *)(a1 + 24) = v14;
      unsigned int v7 = v14;
      *(void *)&long long v24 = v6;
      *((void *)&v24 + 1) = v5;
    }
    while (v5);
  }
  return a1;
}

void *llvm::remarks::ParsedStringTable::operator[]@<X0>(void *result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v3 = result;
  unint64_t v16 = a2;
  uint64_t v5 = result[2];
  unint64_t v6 = (result[3] - v5) >> 3;
  if (v6 <= a2)
  {
    long long v14 = std::generic_category();
    uint64_t v15 = (uint64_t)(v3[3] - v3[2]) >> 3;
    sub_1CD4F6FE0(22, (uint64_t)v14, (uint64_t)"String with index %u is out of bounds (std::string::size_type size = %u).", (uint64_t *)&v16, &v15);
  }
  unsigned int v7 = (uint64_t *)(v5 + 8 * a2);
  uint64_t v10 = *v7;
  uint64_t v8 = v7 + 1;
  uint64_t v9 = v10;
  BOOL v11 = v6 - 1 == a2;
  uint64_t v12 = *result;
  if (v11) {
    uint64_t v8 = result + 1;
  }
  uint64_t v13 = *v8 + ~v9;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)(a3 + 8) = v13;
  *(void *)a3 = v12 + v9;
  return result;
}

void llvm::remarks::createRemarkParser(int a1)
{
  switch(a1)
  {
    case 1:
      operator new();
    case 2:
      std::generic_category();
      sub_1CD06481C();
    case 3:
      operator new();
    default:
      std::generic_category();
      sub_1CD06481C();
  }
}

{
  uint64_t v1;
  const std::error_category *v2;
  const char *v3;

  switch(a1)
  {
    case 1:
      uint64_t v1 = 22;
      uint64_t v2 = std::generic_category();
      BOOL v3 = "The YAML format can't be used with a string table. Use yaml-strtab instead.";
      sub_1CD06481C();
    case 2:
      operator new();
    case 3:
      operator new();
    default:
      uint64_t v1 = 22;
      uint64_t v2 = std::generic_category();
      BOOL v3 = "Unknown remark parser format.";
      sub_1CD06481C();
  }
}

void llvm::remarks::createRemarkParserFromMeta(int a1@<W0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, long long *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if ((a1 - 1) < 2)
  {
    LOBYTE(v12[0]) = 0;
    char v14 = 0;
    if (*(unsigned char *)(a4 + 40))
    {
      long long v7 = *(_OWORD *)(a4 + 16);
      v12[0] = *(_OWORD *)a4;
      v12[1] = v7;
      uint64_t v13 = *(void *)(a4 + 32);
      *(void *)(a4 + 16) = 0;
      *(void *)(a4 + 24) = 0;
      *(void *)(a4 + 32) = 0;
      char v14 = 1;
    }
    long long v10 = *a5;
    uint64_t v11 = *((void *)a5 + 2);
    llvm::remarks::createYAMLParserFromMeta(a2, a3, (uint64_t)v12, (uint64_t)&v10);
  }
  if (!a1)
  {
    uint64_t v16 = 22;
    unint64_t v17 = std::generic_category();
    uint64_t v15 = "Unknown remark parser format.";
    sub_1CD06481C();
  }
  char v9 = 0;
  if (*(unsigned char *)(a4 + 40))
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a4 + 16);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 32) = 0;
    char v9 = 1;
  }
  llvm::remarks::createBitstreamParserFromMeta(a2, a3, (uint64_t)&v16);
  *(unsigned char *)(a6 + 8) = *(unsigned char *)(a6 + 8) & 0xFE | v17 & 1;
  *(void *)a6 = v16;
  uint64_t v16 = 0;
  if (v9 && __p[0]) {
    operator delete(__p[0]);
  }
}

void LLVMRemarkParserCreateYAML()
{
}

void sub_1CCD0A058(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)(a5 + 40))
  {
    *(void *)(a5 + 16) = 0;
    *(void *)(a5 + 24) = 0;
    *(void *)(a5 + 32) = 0;
    llvm::remarks::createRemarkParser(a2);
  }
  llvm::remarks::createRemarkParser(a2);
}

void LLVMRemarkParserCreateBitstream()
{
}

void *LLVMRemarkParserGetNext(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  (***(void (****)(void **__return_ptr))a1)(&v10);
  uint64_t v2 = v10;
  if (v11)
  {
    BOOL v3 = 0;
    long long v10 = 0;
    if (!v2) {
      goto LABEL_4;
    }
    if ((*(unsigned int (**)(void *, void *))(*v2 + 48))(v2, &llvm::remarks::EndOfFileError::ID))
    {
      long long v7 = v2;
      sub_1CD4515D0(&v7);
      uint64_t v5 = v7;
      if (!v7)
      {
LABEL_9:
        BOOL v3 = 0;
        goto LABEL_5;
      }
    }
    else
    {
      unint64_t v6 = (void **)(a1 + 8);
      uint64_t v8 = v2;
      sub_1CD4FB504((uint64_t *)&v8, &v9);
      if (*(unsigned char *)(a1 + 32) && *(char *)(a1 + 31) < 0) {
        operator delete(*v6);
      }
      *(_OWORD *)unint64_t v6 = *(_OWORD *)&v9.__r_.__value_.__l.__data_;
      *(void *)(a1 + 24) = *((void *)&v9.__r_.__value_.__l + 2);
      memset(&v9, 0, sizeof(v9));
      *(unsigned char *)(a1 + 32) = 1;
      uint64_t v5 = v8;
      if (!v8) {
        goto LABEL_9;
      }
    }
    (*(void (**)(void *))(*v5 + 8))(v5);
    goto LABEL_9;
  }
  BOOL v3 = v10;
LABEL_4:
  long long v10 = 0;
LABEL_5:
  sub_1CCD09748((uint64_t)&v10);
  return v3;
}

uint64_t LLVMRemarkParserHasError(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

uint64_t LLVMRemarkParserGetErrorMessage(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t *LLVMRemarkParserDispose(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*((unsigned char *)result + 32))
    {
      if (*((char *)result + 31) < 0) {
        operator delete((void *)result[1]);
      }
      *((unsigned char *)v1 + 32) = 0;
    }
    uint64_t v2 = *v1;
    uint64_t *v1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void sub_1CCD0A3FC(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  long long v4 = a4[1];
  long long v5 = *a4;
  *(_OWORD *)long long __p = v4;
  uint64_t v7 = *((void *)a4 + 4);
  *((void *)a4 + 2) = 0;
  *((void *)a4 + 3) = 0;
  *((void *)a4 + 4) = 0;
  char v8 = 1;
  llvm::remarks::YAMLRemarkParser::YAMLRemarkParser(a1, a2, a3, (uint64_t)&v5);
}

void sub_1CCD0A494()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void llvm::remarks::createRemarkSerializer(int a1)
{
  switch(a1)
  {
    case 1:
      sub_1CCD0A6B0();
    case 2:
      sub_1CCD0A824();
    case 3:
      sub_1CCD0AA80();
    default:
      std::generic_category();
      sub_1CD06481C();
  }
}

{
  switch(a1)
  {
    case 1:
      sub_1CCD0A494();
    case 2:
      operator new();
    case 3:
      operator new();
    default:
      std::generic_category();
      sub_1CD06481C();
  }
}

void sub_1CCD0A6B0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCD0A824()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CCD0AA80()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t sub_1CCD0ABE4()
{
  v4.n128_u64[0] = (unint64_t)"Emit a section containing remark diagnostics metadata. By default, this is enabled "
                                     "for the following formats: yaml-strtab, bitstream.";
  v4.n128_u64[1] = 133;
  BOOL v3 = &v2;
  int v1 = 1;
  int v2 = 0;
  sub_1CD75C860(&v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CC243CA8, &qword_1EBCF0698, &dword_1CB82C000);
}

uint64_t llvm::remarks::StringTable::StringTable(uint64_t a1, void *a2)
{
  v9[3] = *(unsigned __int8 **)MEMORY[0x1E4F143B8];
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0x1000000000;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = a1 + 56;
  *(void *)(a1 + 48) = 0x400000000;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = a1 + 104;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 112) = xmmword_1CD91D2E0;
  unint64_t v3 = a2[3] - a2[2];
  if ((v3 & 0x7FFFFFFF8) != 0)
  {
    unint64_t v5 = 0;
    uint64_t v6 = (v3 >> 3);
    do
    {
      llvm::remarks::ParsedStringTable::operator[](a2, v5, (uint64_t)v9);
      llvm::remarks::StringTable::add(a1, v9[0], (size_t)v9[1], (uint64_t)v8);
      ++v5;
    }
    while (v6 != v5);
  }
  return a1;
}

uint64_t *llvm::remarks::StringTable::internalize(llvm::remarks::StringTable *this, llvm::remarks::Remark *a2)
{
  llvm::remarks::StringTable::add((uint64_t)this, *((unsigned __int8 **)a2 + 1), *((void *)a2 + 2), (uint64_t)v10);
  *(_OWORD *)((char *)a2 + 8) = v11;
  llvm::remarks::StringTable::add((uint64_t)this, *((unsigned __int8 **)a2 + 3), *((void *)a2 + 4), (uint64_t)v10);
  *(_OWORD *)((char *)a2 + 24) = v11;
  uint64_t result = llvm::remarks::StringTable::add((uint64_t)this, *((unsigned __int8 **)a2 + 5), *((void *)a2 + 6), (uint64_t)v10);
  *(_OWORD *)((char *)a2 + 40) = v11;
  if (*((unsigned char *)a2 + 80))
  {
    uint64_t result = llvm::remarks::StringTable::add((uint64_t)this, *((unsigned __int8 **)a2 + 7), *((void *)a2 + 8), (uint64_t)v10);
    *(_OWORD *)((char *)a2 + 56) = v11;
  }
  uint64_t v5 = *((unsigned int *)a2 + 28);
  if (v5)
  {
    uint64_t v6 = *((void *)a2 + 13);
    uint64_t v7 = v6 + (v5 << 6);
    uint64_t v8 = v6 + 32;
    do
    {
      uint64_t v9 = v8 - 32;
      llvm::remarks::StringTable::add((uint64_t)this, *(unsigned __int8 **)(v8 - 32), *(void *)(v8 - 24), (uint64_t)v10);
      *(_OWORD *)(v8 - 32) = v11;
      uint64_t result = llvm::remarks::StringTable::add((uint64_t)this, *(unsigned __int8 **)(v8 - 16), *(void *)(v8 - 8), (uint64_t)v10);
      *(_OWORD *)(v8 - 16) = v11;
      if (*(unsigned char *)(v8 + 24))
      {
        uint64_t result = llvm::remarks::StringTable::add((uint64_t)this, *(unsigned __int8 **)v8, *(void *)(v8 + 8), (uint64_t)v10);
        *(_OWORD *)uint64_t v8 = v11;
      }
      v8 += 64;
    }
    while (v9 + 64 != v7);
  }
  return result;
}

void *llvm::remarks::YAMLParseError::YAMLParseError(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm ***a5, uint64_t a6)
{
  *a1 = &unk_1F263D178;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  v10[0] = a2;
  v10[1] = a3;
  void v10[2] = 10;
  __int16 v11 = 1797;
  long long v9 = *(_OWORD *)(a4 + 48);
  *(void *)(a4 + 48) = sub_1CCD0AF08;
  *(void *)(a4 + 56) = a1 + 1;
  llvm::yaml::Stream::printError(a5, a6, (llvm::Twine *)v10, 0);
  *(_OWORD *)(a4 + 48) = v9;
  return a1;
}

void sub_1CCD0AF08(llvm::SMDiagnostic *a1, uint64_t a2)
{
  int v5 = 0;
  char v9 = 0;
  uint64_t v10 = 0;
  uint64_t v12 = a2;
  int v11 = 0;
  __n128 v4 = &unk_1F2646F30;
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  llvm::SMDiagnostic::print(a1, 0, (llvm::raw_ostream *)&v4, 0, 1);
  int v2 = v8;
  if ((unint64_t)v8 >= v7)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v4, 10);
  }
  else
  {
    ++v8;
    char *v2 = 10;
  }
  int64_t v3 = v8 - v6;
  if (v8 != v6)
  {
    uint64_t v8 = v6;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v4, v6);
  }
  __n128 v4 = &unk_1F2646B98;
  if (v11 == 1)
  {
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8077774924, v3);
    }
  }
}

void llvm::remarks::createYAMLParserFromMeta(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (a2 < 7) {
    goto LABEL_6;
  }
  if (*(_DWORD *)a1 != 1095583058 || *(_DWORD *)(a1 + 3) != 1397445185) {
    goto LABEL_6;
  }
  if (a2 < 8 || *(unsigned char *)(a1 + 7))
  {
    *(void *)char v33 = 92;
    *(void *)&v33[8] = std::generic_category();
    uint64_t v6 = "Expecting \\0 after magic number.";
  }
  else
  {
    if ((a2 & 0xFFFFFFFFFFFFFFF8) == 8)
    {
      *(void *)char v33 = 92;
      *(void *)&v33[8] = std::generic_category();
      *(void *)&long long v27 = "Expecting version number.";
      sub_1CD06481C();
    }
    *(void *)char v33 = *(void *)(a1 + 8);
    if (*(void *)v33)
    {
      uint64_t v12 = std::generic_category();
      sub_1CD5E4C08(92, (uint64_t)v12, (uint64_t)"Mismatching remark version. Got %lld, expected %lld.", (uint64_t *)v33, &qword_1CFB2C828);
    }
    if ((a2 & 0xFFFFFFFFFFFFFFF8) != 0x10)
    {
      unint64_t v8 = *(void *)(a1 + 16);
      uint64_t v9 = a1 + 24;
      unint64_t v10 = a2 - 24;
      if (v8)
      {
        if (*(unsigned char *)(a3 + 40))
        {
          *(void *)char v33 = 92;
          *(void *)&v33[8] = std::generic_category();
          *(void *)&long long v27 = "String table already provided.";
          sub_1CD06481C();
        }
        BOOL v11 = v10 >= v8;
        v10 -= v8;
        if (!v11)
        {
          *(void *)&long long v27 = 92;
          *((void *)&v27 + 1) = std::generic_category();
          long long v30 = (llvm *)"Expecting string table.";
          sub_1CD06481C();
        }
        llvm::remarks::ParsedStringTable::ParsedStringTable((uint64_t)&v27, v9, v8);
        v9 += v8;
        char v35 = 0;
        *(_OWORD *)char v33 = v27;
        uint64_t v14 = *((void *)&v28 + 1);
        uint64_t v13 = v28;
        *(_OWORD *)&v33[16] = v28;
        uint64_t v15 = v29;
        uint64_t v34 = v29;
        int v16 = *(unsigned __int8 *)(a3 + 40);
        *(_OWORD *)a3 = v27;
        if (v16)
        {
          unint64_t v17 = *(void **)(a3 + 16);
          if (v17)
          {
            *(void *)(a3 + 24) = v17;
            operator delete(v17);
            uint64_t v14 = *(void *)&v33[24];
            uint64_t v13 = *(void *)&v33[16];
            uint64_t v15 = v34;
          }
          *(void *)(a3 + 16) = v13;
          *(void *)(a3 + 24) = v14;
          *(void *)(a3 + 32) = v15;
          uint64_t v34 = 0;
          *(_OWORD *)&v33[16] = 0uLL;
        }
        else
        {
          *(void *)(a3 + 16) = v13;
          *(void *)(a3 + 24) = v14;
          *(void *)(a3 + 32) = v15;
          uint64_t v34 = 0;
          *(_OWORD *)&v33[16] = 0uLL;
          *(unsigned char *)(a3 + 40) = 1;
        }
        sub_1CCD0D318((uint64_t *)v33);
      }
      if (v10 < 3 || (*(_WORD *)v9 == 11565 ? (BOOL v18 = *(unsigned char *)(v9 + 2) == 45) : (BOOL v18 = 0), !v18))
      {
        *(void *)char v33 = &v33[24];
        *(_OWORD *)&v33[8] = xmmword_1CFB2C4C0;
        if (*(unsigned char *)(a4 + 16))
        {
          unint64_t v19 = *(const void **)a4;
          size_t v20 = *(void *)(a4 + 8);
          if (v20 >= 0x51) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          uint64_t v21 = 0;
          if (v20)
          {
            memcpy(*(void **)v33, v19, v20);
            uint64_t v21 = *(void *)&v33[8];
          }
          *(void *)&v33[8] = v21 + v20;
        }
        LOWORD(v29) = 261;
        *(void *)&long long v27 = v9;
        *((void *)&v27 + 1) = v10;
        __int16 v32 = 257;
        __int16 v26 = 257;
        __int16 v24 = 257;
        llvm::sys::path::append(v33, 0, (const char **)&v27, (void **)&v30, (uint64_t)v25, (uint64_t)v23);
        LOWORD(v29) = 261;
        long long v27 = *(_OWORD *)v33;
        sub_1CD096690((unsigned __int8 *)&v27, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v30);
        if ((uint64_t)v31.__cat_)
        {
          if (v30)
          {
            *(void *)&v22.__val_ = *(void *)&v31.__val_;
            LOWORD(v29) = 261;
            long long v27 = *(_OWORD *)v33;
            sub_1CD501664((uint64_t)&v27, v30, v22);
          }
        }
        else
        {
          std::system_category();
        }
        if (*(unsigned char **)v33 != &v33[24]) {
          free(*(void **)v33);
        }
      }
LABEL_6:
      if (*(unsigned char *)(a3 + 40)) {
        operator new();
      }
      operator new();
    }
    *(void *)char v33 = 92;
    *(void *)&v33[8] = std::generic_category();
    uint64_t v6 = "Expecting string table size.";
  }
  *(void *)&long long v27 = v6;
  sub_1CD06481C();
}

void llvm::remarks::YAMLRemarkParser::YAMLRemarkParser(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = 0;
  char v4 = 0;
  llvm::remarks::YAMLRemarkParser::YAMLRemarkParser(a1, a2, a3, (uint64_t)v3);
}

{
  unsigned char v3[16];
  char v4;

  v3[0] = 0;
  char v4 = 0;
  llvm::remarks::YAMLRemarkParser::YAMLRemarkParser(a1, a2, a3, (uint64_t)v3);
}

void llvm::remarks::YAMLRemarkParser::YAMLRemarkParser(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F263D1C8;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  if (*(unsigned char *)(a4 + 40))
  {
    *(_OWORD *)(a1 + 40) = *(_OWORD *)a4;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 56) = 0;
    *(_OWORD *)(a1 + 56) = *(_OWORD *)(a4 + 16);
    *(void *)(a1 + 72) = *(void *)(a4 + 32);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 32) = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 160) = sub_1CCD0AF08;
  *(void *)(a1 + 168) = a1 + 88;
  llvm::yaml::Stream::Stream();
}

void llvm::remarks::YAMLRemarkParser::error()
{
}

uint64_t llvm::remarks::YAMLRemarkParser::error@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (*(char *)(this + 111) < 0)
  {
    if (*(void *)(this + 96)) {
LABEL_3:
    }
      operator new();
  }
  else if (*(unsigned char *)(this + 111))
  {
    goto LABEL_3;
  }
  *a2 = 0;
  return this;
}

uint64_t llvm::remarks::YAMLRemarkParser::parseRemark@<X0>(llvm::remarks::YAMLRemarkParser *this@<X0>, llvm::yaml::Document *a2@<X1>, uint64_t a3@<X8>)
{
  v9[14] = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::remarks::YAMLRemarkParser::error((uint64_t)this, v9);
  uint64_t v6 = v9[0];
  if (!v9[0])
  {
    uint64_t v7 = *((void *)a2 + 13);
    if (v7 || (uint64_t v7 = llvm::yaml::Document::parseBlockNode(a2), (*((void *)a2 + 13) = v7) != 0))
    {
      if (*(_DWORD *)(v7 + 32) == 4) {
        operator new();
      }
      operator new();
    }
    unint64_t v8 = std::generic_category();
    v9[0] = 22;
    v9[1] = v8;
    v9[9] = "not a valid YAML file.";
    sub_1CD06481C();
  }
  *(unsigned char *)(a3 + 8) |= 1u;
  *(void *)a3 = v6;
  return result;
}

void llvm::remarks::YAMLRemarkParser::parseType(llvm::yaml::MappingNode *a1@<X1>, uint64_t a2@<X8>)
{
  char v4 = (uint64_t *)*((void *)a1 + 7);
  switch(*((void *)a1 + 8))
  {
    case 7:
      BOOL v5 = *(_DWORD *)v4 == 1935757345 && *(_DWORD *)((char *)v4 + 3) == 1684370291;
      if (v5)
      {
        unint64_t v6 = 0x100000001;
      }
      else
      {
        BOOL v5 = (*(_DWORD *)v4 ^ 0x73694D21 | *(_DWORD *)((char *)v4 + 3) ^ 0x64657373) == 0;
        unint64_t v6 = 0x100000002;
        if (!v5) {
          unint64_t v6 = 0;
        }
      }
      break;
    case 8:
      if (*v4 == 0x6572756C69614621) {
        unint64_t v6 = 0x100000006;
      }
      else {
        unint64_t v6 = 0;
      }
      break;
    case 9:
      uint64_t v7 = *v4;
      int v8 = *((unsigned __int8 *)v4 + 8);
      if (v7 != 0x6973796C616E4121 || v8 != 115) {
        goto LABEL_42;
      }
      unint64_t v6 = 0x100000003;
      break;
    case 0x11:
      uint64_t v10 = *v4;
      uint64_t v11 = v4[1];
      int v12 = *((unsigned __int8 *)v4 + 16);
      if (v10 != 0x6973796C616E4121 || v11 != 0x6E697361696C4173 || v12 != 103) {
        goto LABEL_42;
      }
      unint64_t v6 = 0x100000005;
      break;
    case 0x12:
      uint64_t v15 = *v4;
      uint64_t v16 = v4[1];
      int v17 = *((unsigned __int16 *)v4 + 8);
      if (v15 != 0x6973796C616E4121 || v16 != 0x756D6D6F43504673 || v17 != 25972) {
        goto LABEL_42;
      }
      unint64_t v6 = 0x100000004;
      break;
    default:
      goto LABEL_42;
  }
  if (HIDWORD(v6)) {
    BOOL v20 = v6 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (v20) {
LABEL_42:
  }
    operator new();
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(_DWORD *)a2 = v6;
}

uint64_t llvm::remarks::YAMLRemarkParser::parseKey@<X0>(llvm::yaml::KeyValueNode *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t Key = llvm::yaml::KeyValueNode::getKey(a1);
  if (!Key || (uint64_t v5 = Key, *(_DWORD *)(Key + 32) != 1)) {
    operator new();
  }
  uint64_t result = *(void *)(Key + 72);
  uint64_t v7 = *(void *)(v5 + 80);
  char v8 = *(unsigned char *)(a2 + 16) & 0xFE;
  *(void *)(a2 + 8) = v7;
  *(unsigned char *)(a2 + 16) = v8;
  *(void *)a2 = result;
  return result;
}

void llvm::remarks::YAMLRemarkParser::parseUnsigned(llvm::yaml::KeyValueNode *a1@<X1>, uint64_t a2@<X8>)
{
  int v12 = &v14;
  long long v13 = xmmword_1CDB159A0;
  uint64_t Value = llvm::yaml::KeyValueNode::getValue(a1);
  if (!Value || *(_DWORD *)(Value + 32) != 1) {
    operator new();
  }
  uint64_t v5 = llvm::yaml::ScalarNode::getValue(Value, (uint64_t *)&v12);
  if (!v6) {
    goto LABEL_17;
  }
  unint64_t v7 = 0;
  do
  {
    int v8 = *(unsigned __int8 *)v5;
    if ((v8 - 48) >= 0xA)
    {
      if ((v8 - 97) >= 0x1A)
      {
        if ((v8 - 65) > 0x19) {
          goto LABEL_17;
        }
        int v9 = -55;
      }
      else
      {
        int v9 = -87;
      }
    }
    else
    {
      int v9 = -48;
    }
    unsigned int v10 = v9 + v8;
    if (v10 > 9) {
      goto LABEL_17;
    }
    unint64_t v11 = 10 * v7 + v10;
    if (v7 > v11 / 0xA) {
      goto LABEL_17;
    }
    ++v5;
    unint64_t v7 = v11;
    --v6;
  }
  while (v6);
  if (HIDWORD(v11)) {
LABEL_17:
  }
    operator new();
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(_DWORD *)a2 = v11;
  if (v12 != &v14) {
    free(v12);
  }
}

void llvm::remarks::YAMLRemarkParser::parseDebugLoc(llvm::remarks::YAMLRemarkParser *this@<X0>, llvm::yaml::KeyValueNode *a2@<X1>, uint64_t a3@<X8>)
{
  _OWORD v20[2] = *MEMORY[0x1E4F143B8];
  uint64_t Value = llvm::yaml::KeyValueNode::getValue(a2);
  if (!Value || (uint64_t v6 = (llvm::yaml::MappingNode *)Value, *(_DWORD *)(Value + 32) != 4)) {
    operator new();
  }
  *(unsigned char *)(Value + 76) = 0;
  llvm::yaml::MappingNode::increment((llvm::yaml::MappingNode *)Value);
  unint64_t v7 = (llvm::yaml::KeyValueNode *)*((void *)v6 + 10);
  if (!v7) {
    goto LABEL_27;
  }
  uint64_t v14 = 0;
  int v8 = 0;
  int v9 = 0;
  int v10 = 0;
  int v11 = 0;
  while (1)
  {
    llvm::remarks::YAMLRemarkParser::parseKey(v7, (uint64_t)&v17);
    if (v19)
    {
      uint64_t v13 = v17;
      goto LABEL_31;
    }
    if (v18 != 6)
    {
      if (v18 != 4) {
        goto LABEL_28;
      }
      if (*(_DWORD *)v17 == 1701603654)
      {
        (*(void (**)(long long *__return_ptr, llvm::remarks::YAMLRemarkParser *, llvm::yaml::KeyValueNode *))(*(void *)this + 24))(&v15, this, v7);
        if (v16) {
          break;
        }
        v20[0] = *(void *)((char *)&v15 + 1);
        *(void *)((char *)v20 + 7) = *((void *)&v15 + 1);
        LOBYTE(v14) = v15;
        HIDWORD(v14) = 1;
      }
      else
      {
        if (*(_DWORD *)v17 != 1701734732) {
          goto LABEL_28;
        }
        llvm::remarks::YAMLRemarkParser::parseUnsigned(v7, (uint64_t)&v15);
        if (BYTE8(v15)) {
          break;
        }
        int v9 = v15;
        int v8 = 1;
      }
      goto LABEL_21;
    }
    if (*(_DWORD *)v17 != 1970040643 || *(_WORD *)(v17 + 4) != 28269) {
LABEL_28:
    }
      operator new();
    llvm::remarks::YAMLRemarkParser::parseUnsigned(v7, (uint64_t)&v15);
    if (BYTE8(v15)) {
      break;
    }
    int v11 = v15;
    int v10 = 1;
LABEL_21:
    llvm::yaml::MappingNode::increment(v6);
    unint64_t v7 = (llvm::yaml::KeyValueNode *)*((void *)v6 + 10);
    if (!v7)
    {
      if (HIDWORD(v14) && v8 && v10)
      {
        *(void *)(a3 + 1) = v20[0];
        *(void *)(a3 + 8) = *(void *)((char *)v20 + 7);
        *(unsigned char *)(a3 + 24) &= ~1u;
        *(unsigned char *)a3 = v14;
        *(_DWORD *)(a3 + 16) = v9;
        *(_DWORD *)(a3 + 20) = v11;
        return;
      }
LABEL_27:
      operator new();
    }
  }
  uint64_t v13 = v15;
LABEL_31:
  *(unsigned char *)(a3 + 24) |= 1u;
  *(void *)a3 = v13;
}

double llvm::remarks::YAMLRemarkParser::parseArg@<D0>(llvm::remarks::YAMLRemarkParser *this@<X0>, llvm::yaml::Node *a2@<X1>, uint64_t a3@<X8>)
{
  v24[2] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 8) != 4) {
    operator new();
  }
  *((unsigned char *)a2 + 76) = 0;
  llvm::yaml::MappingNode::increment(a2);
  int v8 = (llvm::yaml::KeyValueNode *)*((void *)a2 + 10);
  if (!v8) {
    goto LABEL_21;
  }
  uint64_t v15 = a3;
  unsigned __int8 v9 = 0;
  int v10 = 0;
  uint64_t v17 = 0;
  char v16 = 0;
  while (1)
  {
    llvm::remarks::YAMLRemarkParser::parseKey(v8, (uint64_t)&v20);
    if (v22)
    {
      uint64_t v14 = v20;
      goto LABEL_18;
    }
    unint64_t v13 = (unint64_t)v20;
    uint64_t v12 = v21;
    if (v21 != 8 || *v20 != 0x636F4C6775626544)
    {
      if (v10) {
        operator new();
      }
      (*(void (**)(unsigned char *__return_ptr, llvm::remarks::YAMLRemarkParser *, llvm::yaml::KeyValueNode *))(*(void *)this + 24))(v18, this, v8);
      if (v18[16]) {
        break;
      }
      BYTE4(v17) = v18[0];
      v24[0] = *(void *)&v18[1];
      *(void *)((char *)v24 + 7) = *(void *)&v18[8];
      unint64_t v3 = v13 >> 8;
      int v10 = 1;
      unsigned __int8 v9 = v13;
      uint64_t v4 = v12;
      goto LABEL_11;
    }
    if (v17) {
      operator new();
    }
    llvm::remarks::YAMLRemarkParser::parseDebugLoc(this, v8, (uint64_t)v18);
    if (v19) {
      break;
    }
    *(_OWORD *)long long v23 = *(_OWORD *)&v18[1];
    *(double *)((char *)&v23[1] + 7) = *(double *)&v18[16];
    char v16 = v18[0];
    LODWORD(v17) = 1;
LABEL_11:
    llvm::yaml::MappingNode::increment(a2);
    int v8 = (llvm::yaml::KeyValueNode *)*((void *)a2 + 10);
    if (!v8)
    {
      if (v10)
      {
        *(void *)(v15 + 17) = v24[0];
        *(void *)(v15 + 24) = *(void *)((char *)v24 + 7);
        double result = v23[0];
        *(_OWORD *)(v15 + 33) = *(_OWORD *)v23;
        *(double *)(v15 + 48) = *(double *)((char *)&v23[1] + 7);
        *(unsigned char *)(v15 + 64) &= ~1u;
        *(void *)uint64_t v15 = v9 | (v3 << 8);
        *(void *)(v15 + 8) = v4;
        *(unsigned char *)(v15 + 16) = BYTE4(v17);
        *(unsigned char *)(v15 + 32) = v16;
        *(unsigned char *)(v15 + 56) = v17;
        return result;
      }
LABEL_21:
      operator new();
    }
  }
  uint64_t v14 = *(void **)v18;
LABEL_18:
  *(unsigned char *)(v15 + 64) |= 1u;
  *(void *)uint64_t v15 = v14;
  return result;
}

unsigned char *llvm::remarks::YAMLRemarkParser::parseStr@<X0>(llvm::yaml::KeyValueNode *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t Value = llvm::yaml::KeyValueNode::getValue(a1);
  if (!Value || *(_DWORD *)(Value + 32) != 1) {
    operator new();
  }
  uint64_t v5 = *(unsigned char **)(Value + 72);
  uint64_t v6 = *(void *)(Value + 80);
  if (v6) {
    BOOL v7 = *v5 == 39;
  }
  else {
    BOOL v7 = 0;
  }
  uint64_t v8 = v7;
  if (v7) {
    double result = v5 + 1;
  }
  else {
    double result = *(unsigned char **)(Value + 72);
  }
  unint64_t v10 = v6 - v8;
  unint64_t v11 = v6 - v8 - 1;
  int v12 = result[v11];
  if (v10 < v11) {
    unint64_t v11 = v10;
  }
  if (v12 == 39) {
    unint64_t v10 = v11;
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)(a2 + 8) = v10;
  *(void *)a2 = result;
  return result;
}

uint64_t llvm::remarks::YAMLRemarkParser::next@<X0>(llvm::remarks::YAMLRemarkParser *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::yaml::Document ***)((char *)this + 200);
  unint64_t v3 = (llvm::yaml::Document **)*((void *)this + 25);
  if (!v3 || !*v3) {
    operator new();
  }
  llvm::remarks::YAMLRemarkParser::parseRemark(this, *v3, (uint64_t)&v7);
  if (v8)
  {
    *uint64_t v4 = 0;
    uint64_t v5 = v7;
    *(unsigned char *)(a2 + 8) |= 1u;
  }
  else
  {
    sub_1CD75CD84(v4);
    *(unsigned char *)(a2 + 8) &= ~1u;
    uint64_t v5 = v7;
  }
  uint64_t v7 = 0;
  *(void *)a2 = v5;
  return sub_1CCD09748((uint64_t)&v7);
}

void llvm::remarks::YAMLStrTabRemarkParser::parseStr(llvm::remarks::YAMLStrTabRemarkParser *this@<X0>, llvm::yaml::KeyValueNode *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t Value = llvm::yaml::KeyValueNode::getValue(a2);
  if (!Value || *(_DWORD *)(Value + 32) != 1) {
    operator new();
  }
  llvm::remarks::YAMLRemarkParser::parseUnsigned(a2, (uint64_t)&v13);
  if (v14)
  {
    uint64_t v7 = v13;
    goto LABEL_20;
  }
  llvm::remarks::ParsedStringTable::operator[]((void *)this + 5, v13, (uint64_t)&v13);
  uint64_t v7 = v13;
  if (v15)
  {
LABEL_20:
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v7;
    return;
  }
  if (v14) {
    BOOL v8 = *v13 == 39;
  }
  else {
    BOOL v8 = 0;
  }
  uint64_t v9 = v8;
  if (v8) {
    uint64_t v7 = v13 + 1;
  }
  unint64_t v10 = v14 - v9;
  unint64_t v11 = v10 - 1;
  int v12 = v7[v10 - 1];
  if (v10 < v10 - 1) {
    unint64_t v11 = v10;
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  if (v12 == 39) {
    unint64_t v10 = v11;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v10;
}

uint64_t sub_1CCD0CD6C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D1C8;
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  llvm::yaml::Stream::~Stream((llvm::yaml::Stream *)(a1 + 184));
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)(a1 + 112));
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      *(void *)(a1 + 64) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
  *(void *)a1 = &unk_1F263D050;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1CCD0CE44(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D1C8;
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  llvm::yaml::Stream::~Stream((llvm::yaml::Stream *)(a1 + 184));
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)(a1 + 112));
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      *(void *)(a1 + 64) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
  *(void *)a1 = &unk_1F263D050;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCD0CF3C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D1C8;
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  llvm::yaml::Stream::~Stream((llvm::yaml::Stream *)(a1 + 184));
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)(a1 + 112));
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      *(void *)(a1 + 64) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
  *(void *)a1 = &unk_1F263D050;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  return a1;
}

void sub_1CCD0D014(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D1C8;
  uint64_t v2 = *(void *)(a1 + 208);
  *(void *)(a1 + 208) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  llvm::yaml::Stream::~Stream((llvm::yaml::Stream *)(a1 + 184));
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)(a1 + 112));
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(unsigned char *)(a1 + 80))
  {
    unint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      *(void *)(a1 + 64) = v3;
      operator delete(v3);
    }
    *(unsigned char *)(a1 + 80) = 0;
  }
  *(void *)a1 = &unk_1F263D050;
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCD0D10C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D178;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CCD0D15C(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D178;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CCD0D1CC(uint64_t a1, llvm::raw_ostream *this)
{
  uint64_t v5 = *(const char **)(a1 + 8);
  uint64_t v3 = a1 + 8;
  uint64_t v4 = v5;
  char v6 = *(unsigned char *)(v3 + 23);
  int v7 = v6;
  if (v6 >= 0) {
    BOOL v8 = (const char *)v3;
  }
  else {
    BOOL v8 = v4;
  }
  size_t v9 = v6 & 0x7F;
  if (v7 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *(void *)(v3 + 8);
  }
  return llvm::raw_ostream::write(this, v8, v10);
}

void *sub_1CCD0D1FC()
{
  return &llvm::remarks::YAMLParseError::ID;
}

BOOL sub_1CCD0D208(uint64_t a1, void *a2)
{
  return a2 == &llvm::remarks::YAMLParseError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

uint64_t *sub_1CCD0D228(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  unsigned char *result = a2;
  if (v2)
  {
    sub_1CB833A08(v2 + 112, *(void **)(v2 + 120));
    uint64_t v3 = *(unsigned int *)(v2 + 32);
    if (v3)
    {
      uint64_t v4 = *(uint64_t **)(v2 + 24);
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *v4++;
        MEMORY[0x1D25D9CD0](v6, 8);
        v5 -= 8;
      }
      while (v5);
    }
    int v7 = *(void **)(v2 + 72);
    uint64_t v8 = *(unsigned int *)(v2 + 80);
    if (v8)
    {
      size_t v10 = *(uint64_t **)(v2 + 72);
      uint64_t v11 = 16 * v8;
      do
      {
        uint64_t v12 = *v10;
        v10 += 2;
        MEMORY[0x1D25D9CD0](v12, 8);
        v11 -= 16;
      }
      while (v11);
      int v7 = *(void **)(v2 + 72);
    }
    if (v7 != (void *)(v2 + 88)) {
      free(v7);
    }
    size_t v9 = *(void **)(v2 + 24);
    if (v9 != (void *)(v2 + 40)) {
      free(v9);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t *sub_1CCD0D318(uint64_t *a1)
{
  if (a1[5])
  {
    uint64_t v3 = *a1;
    *a1 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else
  {
    uint64_t v2 = (void *)a1[2];
    if (v2)
    {
      a1[3] = (uint64_t)v2;
      operator delete(v2);
    }
  }
  return a1;
}

uint64_t llvm::remarks::YAMLRemarkSerializer::YAMLRemarkSerializer(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  LOBYTE(v14[0]) = 0;
  char v21 = 0;
  if (*(unsigned char *)(a4 + 128)) {
    sub_1CD75D3EC((uint64_t)v14, a4);
  }
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D228;
  *(void *)(a1 + 168) = &unk_1F2646940;
  *(void *)(a1 + 176) = a1;
  *(void *)(a1 + 184) = a2;
  *(_DWORD *)(a1 + 192) = 70;
  *(void *)(a1 + 200) = a1 + 216;
  *(void *)(a1 + 208) = 0x800000000;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  sub_1CD75D460(a1 + 32, (uint64_t)v14);
  if (v21)
  {
    free(v14[0]);
    if (v16)
    {
      int v7 = (uint64_t *)v15;
      uint64_t v8 = 8 * v16;
      do
      {
        uint64_t v9 = *v7++;
        MEMORY[0x1D25D9CD0](v9, 8);
        v8 -= 8;
      }
      while (v8);
    }
    size_t v10 = (uint64_t *)v18;
    if (v19)
    {
      uint64_t v12 = 16 * v19;
      do
      {
        uint64_t v13 = *v10;
        v10 += 2;
        MEMORY[0x1D25D9CD0](v13, 8);
        v12 -= 16;
      }
      while (v12);
      size_t v10 = (uint64_t *)v18;
    }
    if (v10 != &v20) {
      free(v10);
    }
    if (v15 != &v17) {
      free(v15);
    }
  }
  return a1;
}

{
  void *v8[3];
  uint64_t v9;
  char v10;
  uint64_t v11;

  uint64_t v11 = *MEMORY[0x1E4F143B8];
  LOBYTE(v8[0]) = 0;
  size_t v10 = 0;
  if (*(unsigned char *)(a4 + 128)) {
    sub_1CD75D3EC((uint64_t)v8, a4);
  }
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D228;
  *(void *)(a1 + 168) = &unk_1F2646940;
  *(void *)(a1 + 176) = a1;
  *(void *)(a1 + 184) = a2;
  *(_DWORD *)(a1 + 192) = 70;
  *(void *)(a1 + 200) = a1 + 216;
  *(void *)(a1 + 208) = 0x800000000;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  sub_1CD75D460(a1 + 32, (uint64_t)v8);
  if (v10)
  {
    free(v8[0]);
    sub_1CBFFBA64((uint64_t)&v9);
  }
  return a1;
}

uint64_t llvm::remarks::YAMLRemarkSerializer::YAMLRemarkSerializer(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5)
{
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D228;
  *(void *)(a1 + 168) = &unk_1F2646940;
  *(void *)(a1 + 176) = a1;
  *(void *)(a1 + 184) = a3;
  *(_DWORD *)(a1 + 192) = 70;
  *(void *)(a1 + 200) = a1 + 216;
  *(void *)(a1 + 208) = 0x800000000;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  sub_1CD75D460(a1 + 32, a5);
  return a1;
}

{
  *(_DWORD *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F263D228;
  *(void *)(a1 + 168) = &unk_1F2646940;
  *(void *)(a1 + 176) = a1;
  *(void *)(a1 + 184) = a3;
  *(_DWORD *)(a1 + 192) = 70;
  *(void *)(a1 + 200) = a1 + 216;
  *(void *)(a1 + 208) = 0x800000000;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  sub_1CD75D460(a1 + 32, a5);
  return a1;
}

llvm::raw_ostream *sub_1CCD0D5D4(llvm::raw_ostream *a1)
{
  int v1 = (_DWORD *)*((void *)a1 + 4);
  if (*((void *)a1 + 3) - (void)v1 > 6uLL)
  {
    *(_DWORD *)((char *)v1 + 3) = 1397445185;
    _DWORD *v1 = 1095583058;
    *((void *)a1 + 4) += 7;
  }
  else
  {
    a1 = llvm::raw_ostream::write(a1, "REMARKS", 7uLL);
  }

  return llvm::raw_ostream::write(a1, 0);
}

void sub_1CCD0D644(llvm::raw_ostream *this, uint64_t a2, char a3)
{
  v5[1] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    v5[0] = *(void *)(a2 + 120);
    llvm::raw_ostream::write(this, (const char *)v5, 8uLL);
    llvm::remarks::StringTable::serialize((uint64_t ***)a2, this);
  }
  else
  {
    v5[0] = 0;
    llvm::raw_ostream::write(this, (const char *)v5, 8uLL);
  }
}

void sub_1CCD0D6E0(llvm::raw_ostream *a1, void *__src, size_t __n)
{
  void v9[16] = *MEMORY[0x1E4F143B8];
  int v7 = v9;
  long long v8 = xmmword_1CFAC3020;
  if (__n >= 0x81) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v5 = 0;
  if (__n)
  {
    memcpy(v7, __src, __n);
    uint64_t v5 = v8;
  }
  *(void *)&long long v8 = v5 + __n;
  llvm::sys::fs::make_absolute((uint64_t)&v7);
  uint64_t v6 = llvm::raw_ostream::write(a1, (const char *)v7, v8);
  llvm::raw_ostream::write(v6, 0);
  if (v7 != v9) {
    free(v7);
  }
}

void sub_1CCD0D7DC(uint64_t a1)
{
  sub_1CCD0D850(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD0D818(uint64_t a1)
{
  sub_1CCD0D850(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCD0D850(uint64_t a1)
{
  *(void *)a1 = &unk_1F263D228;
  *(void *)(a1 + 168) = &unk_1F2646940;
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2 != (void *)(a1 + 216)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F263D148;
  if (*(unsigned char *)(a1 + 160))
  {
    free(*(void **)(a1 + 32));
    uint64_t v3 = *(unsigned int *)(a1 + 80);
    if (v3)
    {
      uint64_t v4 = *(uint64_t **)(a1 + 72);
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *v4++;
        MEMORY[0x1D25D9CD0](v6, 8);
        v5 -= 8;
      }
      while (v5);
    }
    int v7 = *(uint64_t **)(a1 + 120);
    uint64_t v8 = *(unsigned int *)(a1 + 128);
    if (v8)
    {
      uint64_t v11 = 16 * v8;
      do
      {
        uint64_t v12 = *v7;
        v7 += 2;
        MEMORY[0x1D25D9CD0](v12, 8);
        v11 -= 16;
      }
      while (v11);
      int v7 = *(uint64_t **)(a1 + 120);
    }
    if (v7 != (uint64_t *)(a1 + 136)) {
      free(v7);
    }
    uint64_t v9 = *(void **)(a1 + 72);
    if (v9 != (void *)(a1 + 88)) {
      free(v9);
    }
    *(unsigned char *)(a1 + 160) = 0;
  }
  return a1;
}

uint64_t sub_1CCD0D97C(llvm::yaml::IO *a1, uint64_t *a2)
{
  if (((*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, BOOL))(*(void *)a1 + 96))(a1, "!Passed", 7, *(_DWORD *)*a2 == 1) & 1) == 0&& ((*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, BOOL))(*(void *)a1 + 96))(a1, "!Missed", 7, *(_DWORD *)*a2 == 2) & 1) == 0&& ((*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, BOOL))(*(void *)a1 + 96))(a1, "!Analysis", 9, *(_DWORD *)*a2 == 3) & 1) == 0&& ((*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, BOOL))(*(void *)a1 + 96))(a1, "!AnalysisFPCommute", 18, *(_DWORD *)*a2 == 4) & 1) == 0
    && ((*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, BOOL))(*(void *)a1 + 96))(a1, "!AnalysisAliasing", 17, *(_DWORD *)*a2 == 5) & 1) == 0)
  {
    (*(void (**)(llvm::yaml::IO *, const char *, uint64_t, BOOL))(*(void *)a1 + 96))(a1, "!Failure", 8, *(_DWORD *)*a2 == 6);
  }
  uint64_t v4 = *((void *)a1 + 1);
  if (v4) {
    BOOL v5 = *(_DWORD *)(v4 + 8) == 2;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    uint64_t v13 = v4 + 32;
    llvm::remarks::StringTable::add(v4 + 32, *(unsigned __int8 **)(*a2 + 8), *(void *)(*a2 + 16), (uint64_t)&v27);
    int v14 = v27;
    llvm::remarks::StringTable::add(v13, *(unsigned __int8 **)(*a2 + 24), *(void *)(*a2 + 32), (uint64_t)&v27);
    int v15 = v27;
    llvm::remarks::StringTable::add(v13, *(unsigned __int8 **)(*a2 + 40), *(void *)(*a2 + 48), (uint64_t)&v27);
    uint64_t v16 = *a2;
    long long v17 = *(_OWORD *)(*a2 + 72);
    v21[0] = *(_OWORD *)(*a2 + 56);
    v21[1] = v17;
    uint64_t v18 = *(void *)(v16 + 104);
    uint64_t v19 = *(unsigned int *)(v16 + 112);
    long long v26 = *(_OWORD *)(v16 + 88);
    *(void *)&long long v25 = v18;
    *((void *)&v25 + 1) = v19;
    LODWORD(v24) = v14;
    LODWORD(v23) = v15;
    LODWORD(v22[0]) = v27;
    sub_1CD3EDEB8(a1, (uint64_t)"Pass", (unsigned int *)&v24, 1);
    sub_1CD3EDEB8(a1, (uint64_t)"Name", (unsigned int *)&v23, 1);
    long long v27 = 0u;
    long long v28 = 0u;
    sub_1CCD0DDA8(a1, v21, &v27);
    sub_1CD3EDEB8(a1, (uint64_t)"Function", (unsigned int *)v22, 1);
    long long v27 = 0uLL;
    sub_1CCD0E094(a1, (uint64_t)&v26, &v27);
    uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 56))(a1);
    if (!result || v19)
    {
      uint64_t v12 = &v25;
      return sub_1CD75D4F8(a1, (uint64_t)v12);
    }
  }
  else
  {
    uint64_t v6 = *a2;
    long long v7 = *(_OWORD *)(*a2 + 72);
    v20[0] = *(_OWORD *)(*a2 + 56);
    v20[1] = v7;
    uint64_t v8 = *(void *)(v6 + 104);
    uint64_t v9 = *(unsigned int *)(v6 + 112);
    long long v26 = *(_OWORD *)(v6 + 8);
    long long v10 = *(_OWORD *)(v6 + 24);
    long long v24 = *(_OWORD *)(v6 + 40);
    long long v25 = v10;
    long long v23 = *(_OWORD *)(v6 + 88);
    v22[0] = v8;
    v22[1] = v9;
    sub_1CD55F4E4(a1, (uint64_t)"Pass", &v26, 1);
    sub_1CD55F4E4(a1, (uint64_t)"Name", &v25, 1);
    long long v27 = 0u;
    long long v28 = 0u;
    sub_1CCD0DDA8(a1, v20, &v27);
    sub_1CD55F4E4(a1, (uint64_t)"Function", &v24, 1);
    long long v27 = 0uLL;
    sub_1CCD0E094(a1, (uint64_t)&v23, &v27);
    uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 56))(a1);
    if (!result || v9)
    {
      uint64_t v12 = (long long *)v22;
      return sub_1CD75D4F8(a1, (uint64_t)v12);
    }
  }
  return result;
}

uint64_t sub_1CCD0DDA8(llvm::yaml::IO *a1, long long *a2, long long *a3)
{
  char v23 = 1;
  unsigned int v6 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*((unsigned char *)a2 + 24)) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (result)
  {
    if (!*((unsigned char *)a2 + 24))
    {
LABEL_30:
      long long v20 = a3[1];
      *a2 = *a3;
      a2[1] = v20;
      return result;
    }
  }
  else if (!*((unsigned char *)a2 + 24))
  {
    *(void *)a2 = 0;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((unsigned char *)a2 + 24) = 1;
  }
  uint64_t v24 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "DebugLoc", 0, v7, &v23, &v24);
  if (!result)
  {
    if (!v23) {
      return result;
    }
    goto LABEL_30;
  }
  if ((*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    goto LABEL_31;
  }
  uint64_t v9 = *((void *)a1 + 37);
  if (!v9) {
    goto LABEL_31;
  }
  uint64_t v10 = *(void *)(v9 + 8);
  if (!v10 || *(_DWORD *)(v10 + 32) != 1) {
    goto LABEL_31;
  }
  uint64_t v12 = *(int **)(v10 + 72);
  unint64_t v13 = *(void *)(v10 + 80);
  unint64_t v14 = v13;
  do
  {
    unint64_t v15 = v14;
    if (!v14) {
      break;
    }
    --v14;
  }
  while (*((unsigned char *)v12 + v15 - 1) == 32);
  if (v15 < v13) {
    unint64_t v13 = v15;
  }
  if (v13 == 6
    && ((int v16 = *v12, v17 = *((unsigned __int16 *)v12 + 2), v16 == 1852796476) ? (v18 = v17 == 15973) : (v18 = 0), v18))
  {
    long long v19 = a3[1];
    *a2 = *a3;
    a2[1] = v19;
  }
  else
  {
LABEL_31:
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
    long long v28 = *a2;
    unsigned int v21 = *((_DWORD *)a2 + 4);
    unsigned int v26 = *((_DWORD *)a2 + 5);
    unsigned int v27 = v21;
    uint64_t v22 = *((void *)a1 + 1);
    if (v22 && *(_DWORD *)(v22 + 8) == 2)
    {
      llvm::remarks::StringTable::add(v22 + 32, (unsigned __int8 *)v28, *((size_t *)&v28 + 1), (uint64_t)v25);
      sub_1CD3EDEB8(a1, (uint64_t)"File", v25, 1);
    }
    else
    {
      sub_1CD55F4E4(a1, (uint64_t)"File", &v28, 1);
    }
    sub_1CD3EDEB8(a1, (uint64_t)"Line", &v27, 1);
    sub_1CD3EDEB8(a1, (uint64_t)"Column", &v26, 1);
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v24);
}

uint64_t sub_1CCD0E094(llvm::yaml::IO *a1, uint64_t a2, _OWORD *a3)
{
  char v19 = 1;
  unsigned int v6 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*(unsigned char *)(a2 + 8)) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (result)
  {
    if (!*(unsigned char *)(a2 + 8))
    {
LABEL_30:
      *(_OWORD *)a2 = *a3;
      return result;
    }
  }
  else if (!*(unsigned char *)(a2 + 8))
  {
    *(void *)a2 = 0;
    *(unsigned char *)(a2 + 8) = 1;
  }
  uint64_t v20 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "Hotness", 0, v7, &v19, &v20);
  if (!result)
  {
    if (!v19) {
      return result;
    }
    goto LABEL_30;
  }
  if ((*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    goto LABEL_31;
  }
  uint64_t v9 = *((void *)a1 + 37);
  if (!v9) {
    goto LABEL_31;
  }
  uint64_t v10 = *(void *)(v9 + 8);
  if (!v10 || *(_DWORD *)(v10 + 32) != 1) {
    goto LABEL_31;
  }
  uint64_t v12 = *(int **)(v10 + 72);
  unint64_t v13 = *(void *)(v10 + 80);
  unint64_t v14 = v13;
  do
  {
    unint64_t v15 = v14;
    if (!v14) {
      break;
    }
    --v14;
  }
  while (*((unsigned char *)v12 + v15 - 1) == 32);
  if (v15 < v13) {
    unint64_t v13 = v15;
  }
  if (v13 == 6
    && ((int v16 = *v12, v17 = *((unsigned __int16 *)v12 + 2), v16 == 1852796476) ? (v18 = v17 == 15973) : (v18 = 0), v18))
  {
    *(_OWORD *)a2 = *a3;
  }
  else
  {
LABEL_31:
    sub_1CD561CFC(a1, (unint64_t *)a2);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v20);
}

uint64_t sub_1CCD0E29C(llvm::yaml::IO *a1, uint64_t a2)
{
  uint64_t v4 = *((void *)a1 + 1);
  if (v4) {
    BOOL v5 = *(_DWORD *)(v4 + 8) == 2;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    llvm::remarks::StringTable::add(v4 + 32, *(unsigned __int8 **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)v10);
    sub_1CD3EDEB8(a1, *(void *)a2, (unsigned int *)v10, 1);
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 24);
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      if (*(unsigned char *)(*(void *)(a2 + 16) + v7) == 10) {
        ++v8;
      }
      ++v7;
    }
    while (v6 != v7);
    if (v8 >= 2)
    {
      *(void *)&v10[0] = *(void *)(a2 + 16);
      *((void *)&v10[0] + 1) = v6;
      sub_1CD75D74C((uint64_t *)a1, *(void *)a2, v10);
    }
    else
    {
LABEL_13:
      sub_1CD55F4E4(a1, *(void *)a2, (void *)(a2 + 16), 1);
    }
  }
  memset(v10, 0, sizeof(v10));
  return sub_1CCD0DDA8(a1, (long long *)(a2 + 32), v10);
}

void llvm::ADCEPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getCachedResultImpl();
}

uint64_t sub_1CCD0E590(uint64_t a1)
{
  v290[18] = *(void **)MEMORY[0x1E4F143B8];
  unint64_t v2 = -1;
  unsigned int v3 = -4;
  uint64_t v4 = 48;
  uint64_t v5 = *(void *)a1 + 72;
  do
  {
    uint64_t v5 = *(void *)(v5 + 8);
    v4 -= 48;
    ++v2;
    v3 += 4;
  }
  while (v5 != *(void *)a1 + 72);
  uint64_t v256 = a1 + 24;
  if (v2)
  {
    unint64_t v6 = (v3 / 3 + 1) | ((unint64_t)(v3 / 3 + 1) >> 1);
    unint64_t v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
    unsigned int v8 = ((v7 | (v7 >> 8)) >> 16) | v7 | (v7 >> 8);
    if (*(_DWORD *)(a1 + 40) <= v8) {
      sub_1CBFAFA0C(v256, v8 + 1);
    }
  }
  uint64_t v9 = *(unsigned char **)(a1 + 48);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 64) - (void)v9) >> 4) < v2)
  {
    if (v2 >= 0x555555555555556) {
LABEL_486:
    }
      abort();
    uint64_t v10 = *(unsigned char **)(a1 + 56);
    uint64_t v11 = (char *)operator new(-v4);
    uint64_t v12 = &v11[48 * ((v10 - v9) / 48)];
    unint64_t v13 = v12;
    if (v10 != v9)
    {
      unint64_t v14 = &v11[48 * ((v10 - v9) / 48)];
      do
      {
        unint64_t v13 = v14 - 48;
        long long v15 = *((_OWORD *)v10 - 3);
        long long v16 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v14 - 1) = v16;
        *((_OWORD *)v14 - 3) = v15;
        v10 -= 48;
        v14 -= 48;
      }
      while (v10 != v9);
    }
    *(void *)(a1 + 48) = v13;
    *(void *)(a1 + 56) = v12;
    *(void *)(a1 + 64) = &v11[-v4];
    if (v9) {
      operator delete(v9);
    }
  }
  uint64_t v17 = *(void *)a1 + 72;
  uint64_t v18 = *(void *)(*(void *)a1 + 80);
  if (v18 == v17)
  {
    uint64_t v31 = a1 + 72;
  }
  else
  {
    int v19 = 0;
    do
    {
      if (v18) {
        uint64_t v20 = (void *)(v18 - 24);
      }
      else {
        uint64_t v20 = 0;
      }
      unsigned int v21 = v20 + 5;
      unsigned int v22 = 4 * v19-- - 4;
      char v23 = v20 + 5;
      do
      {
        char v23 = (void *)v23[1];
        v22 += 4;
        ++v19;
      }
      while (v23 != v21);
      v266 = v20;
      uint64_t v24 = sub_1CCD11070(v256, (uint64_t *)&v266);
      *(void *)(v24 + 16) = v20;
      long long v25 = (void *)v20[5];
      if (v25 == v21)
      {
        BOOL v30 = 0;
        *(void *)(v24 + 24) = 0;
      }
      else
      {
        unsigned int v26 = v25 - 3;
        if (!v25) {
          unsigned int v26 = 0;
        }
        unsigned int v27 = *((unsigned __int8 *)v26 + 16) - 40;
        if (v27 < 0xFFFFFFF5) {
          unsigned int v26 = 0;
        }
        *(void *)(v24 + 24) = v26;
        BOOL v28 = v27 < 0xFFFFFFF5 || v25 == 0;
        BOOL v30 = !v28 && *((unsigned char *)v26 + 16) == 30 && (*((_DWORD *)v26 + 5) & 0x7FFFFFF) == 1;
      }
      *(unsigned char *)(v24 + 1) = v30;
      uint64_t v18 = *(void *)(v18 + 8);
    }
    while (v18 != v17);
    uint64_t v31 = a1 + 72;
    if (v19)
    {
      unint64_t v32 = (v22 / 3 + 1) | ((unint64_t)(v22 / 3 + 1) >> 1);
      unint64_t v33 = v32 | (v32 >> 2) | ((v32 | (v32 >> 2)) >> 4);
      unsigned int v34 = ((v33 | (v33 >> 8)) >> 16) | v33 | (v33 >> 8);
      if (*(_DWORD *)(a1 + 88) <= v34) {
        sub_1CCD11588(a1 + 72, v34 + 1);
      }
    }
  }
  uint64_t v35 = *(void *)(a1 + 48);
  uint64_t v36 = *(void *)(a1 + 56);
  if (v35 != v36)
  {
    do
    {
      uint64_t v37 = *(void *)(v35 + 24);
      uint64_t v38 = v37 + 40;
      uint64_t v39 = *(void *)(v37 + 48);
      if (v39 != v37 + 40)
      {
        do
        {
          long long v40 = (void *)(v39 - 24);
          if (!v39) {
            long long v40 = 0;
          }
          v266 = v40;
          sub_1CCD112AC(v31, (uint64_t *)&v266)[1] = v35 + 8;
          uint64_t v39 = *(void *)(v39 + 8);
        }
        while (v39 != v38);
      }
      v35 += 48;
    }
    while (v35 != v36);
    uint64_t v41 = *(uint64_t **)(a1 + 48);
    char v42 = *(uint64_t **)(a1 + 56);
    if (v41 != v42)
    {
      uint64_t v43 = v41 + 4;
      do
      {
        *(v43 - 2) = (uint64_t)sub_1CCD112AC(v31, v43);
        char v44 = v43 + 2;
        v43 += 6;
      }
      while (v44 != v42);
    }
  }
  uint64_t v255 = v31;
  uint64_t v45 = *(void *)a1 + 72;
  for (uint64_t i = *(void *)(*(void *)a1 + 80); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v45) {
      goto LABEL_103;
    }
    uint64_t v47 = i - 24;
    if (!i) {
      uint64_t v47 = 0;
    }
    uint64_t v48 = *(void *)(v47 + 48);
    if (v48 != v47 + 40) {
      break;
    }
  }
  while (1)
  {
    if (v48) {
      uint64_t v49 = v48 - 24;
    }
    else {
      uint64_t v49 = 0;
    }
    int v50 = *(unsigned __int8 *)(v49 + 16);
    if ((v50 - 38) > 0x38 || ((1 << (v50 - 38)) & 0x100060000000001) == 0)
    {
      int HaveSideEffects = llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v49);
      int v50 = *(unsigned __int8 *)(v49 + 16);
      if (!HaveSideEffects)
      {
        if ((v50 - 29) <= 0xA && ((v50 & 0xFE) != 0x1E || byte_1EBCF07E8 == 0)) {
          goto LABEL_94;
        }
        goto LABEL_95;
      }
    }
    if (v50 != 84) {
      goto LABEL_94;
    }
    uint64_t v52 = *(uint64_t ****)(v49 - 32);
    if (!v52 || *((unsigned char *)v52 + 16) || v52[3] != *(uint64_t ***)(v49 + 72) || (*((unsigned char *)v52 + 23) & 0x10) == 0) {
      goto LABEL_94;
    }
    uint64_t v53 = ***v52;
    uint64_t v54 = *(void *)(v53 + 152);
    uint64_t v55 = *(unsigned int *)(v53 + 168);
    if (!v55) {
      goto LABEL_80;
    }
    LODWORD(v56) = (v55 - 1) & ((v52 >> 4) ^ (v52 >> 9));
    uint64_t v57 = (uint64_t ****)(v54 + 16 * v56);
    unsigned int v58 = *v57;
    if (*v57 != v52)
    {
      int v59 = 1;
      while (v58 != (uint64_t ***)-4096)
      {
        int v60 = v56 + v59++;
        uint64_t v56 = v60 & (v55 - 1);
        unsigned int v58 = *(uint64_t ****)(v54 + 16 * v56);
        if (v58 == v52)
        {
          uint64_t v57 = (uint64_t ****)(v54 + 16 * v56);
          goto LABEL_81;
        }
      }
LABEL_80:
      uint64_t v57 = (uint64_t ****)(v54 + 16 * v55);
    }
LABEL_81:
    unsigned int v63 = v57[1];
    if (*v63 != (uint64_t **)32
      || ((int32x2_t v64 = v63[2], v65 = v63[3], v67 = v63[4], v66 = v63[5], v64 == (uint64_t **)0x705F6D766C6C5F5FLL)
        ? (BOOL v68 = v65 == (uint64_t **)0x695F656C69666F72)
        : (BOOL v68 = 0),
          v68 ? (BOOL v69 = v67 == (uint64_t **)0x6E656D757274736ELL) : (BOOL v69 = 0),
          v69 ? (BOOL v70 = v66 == (uint64_t **)0x7465677261745F74) : (BOOL v70 = 0),
          !v70 || *(unsigned __int8 *)(*(void *)(v49 - 32 * (*(_DWORD *)(v49 + 20) & 0x7FFFFFF)) + 16) >= 0x15u))
    {
LABEL_94:
      sub_1CCD11318(a1, v49);
    }
LABEL_95:
    uint64_t v48 = *(void *)(v48 + 8);
    uint64_t v71 = i - 24;
    if (!i) {
      uint64_t v71 = 0;
    }
    if (v48 == v71 + 40) {
      break;
    }
LABEL_102:
    if (i == v45) {
      goto LABEL_103;
    }
  }
  while (1)
  {
    uint64_t i = *(void *)(i + 8);
    if (i == v45) {
      break;
    }
    uint64_t v72 = i - 24;
    if (!i) {
      uint64_t v72 = 0;
    }
    uint64_t v48 = *(void *)(v72 + 48);
    if (v48 != v72 + 40) {
      goto LABEL_102;
    }
  }
LABEL_103:
  if (!byte_1EBCF07E8) {
    goto LABEL_328;
  }
  if (byte_1EBCF08A8) {
    goto LABEL_237;
  }
  v257 = 0;
  v258 = 0;
  unsigned int v259 = 0;
  uint64_t v73 = *(void *)a1;
  unsigned int v74 = -4;
  int v75 = 1;
  uint64_t v76 = *(void *)a1 + 72;
  do
  {
    uint64_t v76 = *(void *)(v76 + 8);
    v74 += 4;
    --v75;
  }
  while (v76 != *(void *)a1 + 72);
  if (v75)
  {
    unint64_t v77 = (v74 / 3 + 1) | ((unint64_t)(v74 / 3 + 1) >> 1);
    unint64_t v78 = v77 | (v77 >> 2) | ((v77 | (v77 >> 2)) >> 4);
    sub_1CC9A2EA0((uint64_t)&v257, (((v78 | (v78 >> 8)) >> 16) | v78 | (v78 >> 8)) + 1);
    uint64_t v73 = *(void *)a1;
  }
  uint64_t v79 = *(void *)(v73 + 80);
  if (v79) {
    unsigned int v80 = (void *)(v79 - 24);
  }
  else {
    unsigned int v80 = 0;
  }
  v279 = v80;
  v280 = (void *)1;
  sub_1CCD11D88((uint64_t)&v266, (uint64_t)&v257, &v279, &v280);
  if ((_BYTE)v268)
  {
    unint64_t v81 = operator new(0x20uLL);
    *(void *)unint64_t v81 = v80;
    v81[8] = 0;
    v81[24] = 0;
    uint64_t v82 = v81 + 32;
  }
  else
  {
    unint64_t v81 = 0;
    uint64_t v82 = 0;
  }
  v266 = &v257;
  v267 = 0;
  v268 = 0;
  unint64_t v269 = 0;
  sub_1CBFE1720(&v267, v81, v82, (v82 - v81) >> 5);
  if (v81) {
    operator delete(v81);
  }
  unint64_t v83 = v267;
  uint64_t v84 = v268;
  unint64_t v85 = ((char *)v268 - (unsigned char *)v267) >> 5;
  v267 = 0;
  v268 = 0;
  unint64_t v269 = 0;
  long long __p = v83;
  sub_1CBFE1720(&v267, v83, v84, v85);
  int v86 = v268;
  if (v268 == v267)
  {
    uint64_t v126 = v268;
    goto LABEL_232;
  }
  do
  {
    uint64_t v87 = *(v86 - 4);
    int v90 = *(void **)(v87 + 40);
    uint64_t v89 = (void *)(v87 + 40);
    int v88 = v90;
    if (v90 == v89)
    {
      uint64_t v92 = 0;
    }
    else
    {
      if (v88) {
        uint64_t v91 = (unsigned __int8 *)(v88 - 3);
      }
      else {
        uint64_t v91 = 0;
      }
      if (v91[16] - 29 >= 0xB) {
        uint64_t v92 = 0;
      }
      else {
        uint64_t v92 = v91;
      }
    }
    v279 = v92;
    if (!*(unsigned char *)sub_1CCD112AC(v255, (uint64_t *)&v279))
    {
      uint64_t v127 = (void *)*v89;
      if ((void *)*v89 != v89)
      {
        if (v127) {
          uint64_t v128 = v127 - 3;
        }
        else {
          uint64_t v128 = 0;
        }
        if (*((unsigned char *)v128 + 16) != 30)
        {
          int v135 = 2;
          switch(*((unsigned char *)v128 + 16))
          {
            case 0x1E:
LABEL_488:
              __break(1u);
              JUMPOUT(0x1CCD10D90);
            case 0x1F:
              int v135 = (*((_DWORD *)v128 + 5) >> 1) & 0x3FFFFFF;
              goto LABEL_225;
            case 0x20:
            case 0x26:
              int v135 = (*((_DWORD *)v128 + 5) & 0x7FFFFFF) - 1;
              goto LABEL_225;
            case 0x21:
              goto LABEL_208;
            case 0x24:
              int v135 = *((_WORD *)v128 + 9) & 1;
              goto LABEL_225;
            case 0x25:
              int v135 = 1;
              goto LABEL_208;
            case 0x27:
              int v135 = *((_DWORD *)v128 + 20) + 1;
LABEL_225:
              if (!v135) {
                goto LABEL_127;
              }
              goto LABEL_208;
            default:
              goto LABEL_127;
          }
        }
        if ((*((_DWORD *)v128 + 5) & 0x7FFFFFF) == 3) {
          int v135 = 2;
        }
        else {
          int v135 = 1;
        }
LABEL_208:
        for (unsigned int j = 0; v135 != j; ++j)
        {
          uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v128, j);
          if (v259)
          {
            uint64_t v131 = ((Successor >> 4) ^ (Successor >> 9)) & (v259 - 1);
            uint64_t v132 = v257[2 * v131];
            if (Successor == v132)
            {
LABEL_211:
              if (v131 != v259 && LOBYTE(v257[2 * v131 + 1]))
              {
                sub_1CCD11318(a1, (uint64_t)v92);
                break;
              }
            }
            else
            {
              int v133 = 1;
              while (v132 != -4096)
              {
                int v134 = v131 + v133++;
                uint64_t v131 = v134 & (v259 - 1);
                uint64_t v132 = v257[2 * v131];
                if (Successor == v132) {
                  goto LABEL_211;
                }
              }
            }
          }
        }
      }
    }
LABEL_127:
    int v86 = v268;
    do
    {
      uint64_t v93 = *(v86 - 4);
      if (!*((unsigned char *)v86 - 8))
      {
        uint64_t v94 = *(void *)(v93 + 40);
        if (v94 == v93 + 40)
        {
          uint64_t v95 = 0;
        }
        else
        {
          if (v94) {
            uint64_t v95 = v94 - 24;
          }
          else {
            uint64_t v95 = 0;
          }
          if (*(unsigned __int8 *)(v95 + 16) - 29 >= 0xB) {
            uint64_t v95 = 0;
          }
        }
        *(v86 - 3) = v95;
        *(v86 - 2) = 0;
        *((unsigned char *)v86 - 8) = 1;
      }
      uint64_t v96 = (void *)(v93 + 40);
      do
      {
        uint64_t v97 = (void *)*v96;
        if ((void *)*v96 == v96)
        {
LABEL_147:
          int v103 = 0;
        }
        else
        {
          if (v97) {
            uint64_t v98 = v97 - 3;
          }
          else {
            uint64_t v98 = 0;
          }
          if (*((unsigned char *)v98 + 16) != 30)
          {
            int v103 = 0;
            switch(*((unsigned char *)v98 + 16))
            {
              case 0x1D:
              case 0x22:
              case 0x23:
                goto LABEL_148;
              case 0x1E:
                goto LABEL_488;
              case 0x1F:
                int v103 = (*((_DWORD *)v98 + 5) >> 1) & 0x3FFFFFF;
                goto LABEL_148;
              case 0x20:
              case 0x26:
                int v103 = (*((_DWORD *)v98 + 5) & 0x7FFFFFF) - 1;
                goto LABEL_148;
              case 0x21:
                int v103 = 2;
                goto LABEL_148;
              case 0x24:
                int v103 = *((_WORD *)v98 + 9) & 1;
                goto LABEL_148;
              case 0x25:
                int v103 = 1;
                goto LABEL_148;
              case 0x27:
                int v103 = *((_DWORD *)v98 + 20) + 1;
                goto LABEL_148;
              default:
                goto LABEL_147;
            }
          }
          if ((*((_DWORD *)v98 + 5) & 0x7FFFFFF) == 3) {
            int v103 = 2;
          }
          else {
            int v103 = 1;
          }
        }
LABEL_148:
        int v99 = *((_DWORD *)v86 - 4);
        if (v99 == v103)
        {
          long long v104 = (uint64_t *)v266;
          uint64_t v289 = v93;
          unsigned int v105 = *((_DWORD *)v266 + 4);
          if (!v105)
          {
            long long v108 = 0;
            goto LABEL_181;
          }
          unsigned int v106 = v105 - 1;
          unsigned int v107 = (v105 - 1) & ((v93 >> 4) ^ (v93 >> 9));
          long long v108 = (unsigned char *)(*(void *)v266 + 16 * v107);
          uint64_t v109 = *(void *)v108;
          if (v93 != *(void *)v108)
          {
            long long v110 = 0;
            int v111 = 1;
            while (v109 != -4096)
            {
              if (v110) {
                BOOL v112 = 0;
              }
              else {
                BOOL v112 = v109 == -8192;
              }
              if (v112) {
                long long v110 = v108;
              }
              unsigned int v113 = v107 + v111++;
              unsigned int v107 = v113 & v106;
              long long v108 = (unsigned char *)(*(void *)v266 + 16 * (v113 & v106));
              uint64_t v109 = *(void *)v108;
              if (v93 == *(void *)v108) {
                goto LABEL_187;
              }
            }
            if (v110) {
              long long v108 = v110;
            }
LABEL_181:
            int v121 = *((_DWORD *)v266 + 2);
            if (4 * v121 + 4 >= 3 * v105)
            {
              v105 *= 2;
              goto LABEL_198;
            }
            if (v105 + ~v121 - *((_DWORD *)v266 + 3) <= v105 >> 3)
            {
LABEL_198:
              sub_1CC9A2EA0((uint64_t)v266, v105);
              v279 = 0;
              sub_1CC9A2D50(v104, &v289, &v279);
              long long v108 = v279;
            }
            ++*((_DWORD *)v104 + 2);
            if (*(void *)v108 != -4096) {
              --*((_DWORD *)v104 + 3);
            }
            *(void *)long long v108 = v289;
            v108[8] = 0;
          }
LABEL_187:
          v108[8] = 0;
          int v86 = v268 - 4;
          goto LABEL_194;
        }
        uint64_t v100 = (llvm::Instruction *)*(v86 - 3);
        unsigned int v101 = *((_DWORD *)v86 - 4);
        *((_DWORD *)v86 - 4) = v99 + 1;
        uint64_t v102 = llvm::Instruction::getSuccessor(v100, v101);
        uint64_t v289 = v102;
        v290[0] = (void *)1;
        sub_1CCD11D88((uint64_t)&v279, (uint64_t)v266, &v289, v290);
      }
      while (!(_BYTE)v281);
      uint64_t v114 = v268;
      if ((unint64_t)v268 < v269)
      {
        uint64_t *v268 = v102;
        v114[8] = 0;
        v114[24] = 0;
        int v86 = (uint64_t *)(v114 + 32);
        v268 = (uint64_t *)(v114 + 32);
        uint64_t v126 = (uint64_t *)v267;
        break;
      }
      uint64_t v115 = v267;
      uint64_t v116 = ((char *)v268 - (unsigned char *)v267) >> 5;
      unint64_t v117 = v116 + 1;
      if ((unint64_t)(v116 + 1) >> 59) {
        goto LABEL_486;
      }
      uint64_t v118 = v269 - (void)v267;
      if ((uint64_t)(v269 - (void)v267) >> 4 > v117) {
        unint64_t v117 = v118 >> 4;
      }
      if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v119 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v119 = v117;
      }
      if (v119)
      {
        if (v119 >> 59) {
          sub_1CB833614();
        }
        uint64_t v120 = (char *)operator new(32 * v119);
      }
      else
      {
        uint64_t v120 = 0;
      }
      int v122 = &v120[32 * v116];
      *(void *)int v122 = v102;
      v122[8] = 0;
      v122[24] = 0;
      uint64_t v123 = v122;
      if (v114 != v115)
      {
        do
        {
          long long v124 = *((_OWORD *)v114 - 1);
          *((_OWORD *)v123 - 2) = *((_OWORD *)v114 - 2);
          *((_OWORD *)v123 - 1) = v124;
          v123 -= 32;
          v114 -= 32;
        }
        while (v114 != v115);
        uint64_t v114 = v267;
      }
      unint64_t v125 = &v120[32 * v119];
      int v86 = (uint64_t *)(v122 + 32);
      v267 = v123;
      v268 = (uint64_t *)(v122 + 32);
      unint64_t v269 = (unint64_t)v125;
      if (v114) {
        operator delete(v114);
      }
LABEL_194:
      v268 = v86;
      uint64_t v126 = (uint64_t *)v267;
    }
    while (v99 == v103 && v267 != v86);
  }
  while (v86 != v126);
LABEL_232:
  if (v126)
  {
    v268 = v126;
    operator delete(v126);
  }
  if (__p) {
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v257, 8);
LABEL_237:
  uint64_t v136 = *(void *)(*(void *)(a1 + 16) + 72);
  uint64_t v137 = *(unsigned int *)(v136 + 32);
  if (!v137) {
    goto LABEL_298;
  }
  v138 = *(uint64_t **)(v136 + 24);
  uint64_t v139 = &v138[v137];
  while (2)
  {
    uint64_t v289 = *(void *)*v138;
    if (*(unsigned char *)(*(void *)(sub_1CCD11070(v256, &v289) + 24) + 16) == 29) {
      goto LABEL_286;
    }
    sub_1CC076464(v138, (uint64_t)&v266);
    v279 = v284;
    uint64_t v140 = v267;
    if (v267 == v266)
    {
      v280 = v284;
      v141 = v284;
      v142 = v267;
    }
    else
    {
      int v156 = (int)v268;
      v141 = malloc_type_malloc(8 * v268, 0x4065EBACuLL);
      if (!v141 && (v156 || (v141 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_297:
      }
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      v280 = v141;
      v142 = v266;
      uint64_t v140 = v267;
    }
    int v143 = HIDWORD(v268);
    int v281 = (int)v268;
    if (v140 == v142) {
      unsigned int v144 = HIDWORD(v268);
    }
    else {
      unsigned int v144 = v268;
    }
    if (v144)
    {
      memmove(v141, v140, 8 * v144);
      int v143 = HIDWORD(v268);
    }
    int v282 = v143;
    int v283 = v269;
    v286 = 0;
    uint64_t v287 = 0;
    v285 = 0;
    sub_1CBF340A8(&v285, v270, v271, 0xAAAAAAAAAAAAAAABLL * ((v271 - (unsigned char *)v270) >> 3));
    v257 = v262;
    uint64_t v145 = v273;
    if (v273 == v272)
    {
      v258 = v262;
      v146 = v262;
      uint64_t v147 = v273;
    }
    else
    {
      unsigned int v157 = v274;
      v146 = malloc_type_malloc(8 * v274, 0x4065EBACuLL);
      if (!v146)
      {
        if (v157) {
          goto LABEL_297;
        }
        v146 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v146) {
          goto LABEL_297;
        }
      }
      v258 = v146;
      uint64_t v147 = v272;
      uint64_t v145 = v273;
    }
    unsigned int v148 = v275;
    unsigned int v259 = v274;
    if (v145 == v147) {
      unsigned int v149 = v275;
    }
    else {
      unsigned int v149 = v274;
    }
    if (v149)
    {
      memmove(v146, v145, 8 * v149);
      unsigned int v148 = v275;
    }
    unsigned int v260 = v148;
    LODWORD(v261) = v276;
    v264 = 0;
    uint64_t v265 = 0;
    v263 = 0;
    sub_1CBF340A8(&v263, v277, v278, 0xAAAAAAAAAAAAAAABLL * ((v278 - (unsigned char *)v277) >> 3));
    while (2)
    {
      if (v286 - (unsigned char *)v285 != v264 - v263)
      {
LABEL_269:
        uint64_t v288 = **((void **)v286 - 3);
        uint64_t v155 = sub_1CCD11070(v256, &v288);
        sub_1CCD11318(a1, *(void *)(v155 + 24));
        sub_1CBFE66A8((llvm::SmallPtrSetImplBase *)&v279);
        continue;
      }
      break;
    }
    if (v285 != v286)
    {
      uint64_t v150 = v263 + 8;
      uint64_t v151 = (char *)v285 + 8;
      do
      {
        v152 = v151 - 8;
        if (*((void *)v151 - 1) != *((void *)v150 - 1)) {
          goto LABEL_269;
        }
        int v153 = v150[8];
        if (v151[8]) {
          BOOL v154 = v153 == 0;
        }
        else {
          BOOL v154 = 1;
        }
        if (v154)
        {
          if ((v151[8] == 0) == (v153 != 0)) {
            goto LABEL_269;
          }
        }
        else if (*(void *)v151 != *(void *)v150)
        {
          goto LABEL_269;
        }
        v150 += 24;
        v151 += 24;
      }
      while (v152 + 24 != v286);
    }
    if (v263)
    {
      v264 = v263;
      operator delete(v263);
    }
    if (v258 != v257) {
      free(v258);
    }
    if (v285)
    {
      v286 = (char *)v285;
      operator delete(v285);
    }
    if (v280 != v279) {
      free(v280);
    }
    if (v277)
    {
      v278 = v277;
      operator delete(v277);
    }
    if (v273 != v272) {
      free(v273);
    }
    if (v270)
    {
      v271 = v270;
      operator delete(v270);
    }
    if (v267 != v266) {
      free(v267);
    }
LABEL_286:
    if (++v138 != v139) {
      continue;
    }
    break;
  }
LABEL_298:
  uint64_t v158 = *(void *)(*(void *)a1 + 80);
  if (v158) {
    unint64_t v159 = (void *)(v158 - 24);
  }
  else {
    unint64_t v159 = 0;
  }
  v266 = v159;
  uint64_t v160 = sub_1CCD11070(v256, (uint64_t *)&v266);
  *(unsigned char *)uint64_t v160 = 1;
  if (*(unsigned char *)(v160 + 1)) {
    sub_1CCD11318(a1, *(void *)(v160 + 24));
  }
  uint64_t v161 = *(void *)(a1 + 48);
  uint64_t v162 = *(void *)(a1 + 56);
  if (v161 != v162)
  {
    while (2)
    {
      if (!**(unsigned char **)(v161 + 16))
      {
        v163 = (void *)(v161 + 24);
        if (*(unsigned char *)(a1 + 1424))
        {
          int v164 = 16;
          uint64_t v165 = a1 + 1432;
LABEL_309:
          int v166 = v164 - 1;
          unsigned int v167 = ((*v163 >> 4) ^ (*v163 >> 9)) & v166;
          v168 = (void *)(v165 + 8 * v167);
          uint64_t v169 = *v168;
          if (*v163 != *v168)
          {
            uint64_t v170 = 0;
            int v171 = 1;
            while (v169 != -4096)
            {
              if (v170) {
                BOOL v172 = 0;
              }
              else {
                BOOL v172 = v169 == -8192;
              }
              if (v172) {
                uint64_t v170 = v168;
              }
              unsigned int v173 = v167 + v171++;
              unsigned int v167 = v173 & v166;
              v168 = (void *)(v165 + 8 * v167);
              uint64_t v169 = *v168;
              if (*v163 == *v168) {
                goto LABEL_324;
              }
            }
            if (v170) {
              v174 = v170;
            }
            else {
              v174 = v168;
            }
            goto LABEL_322;
          }
        }
        else
        {
          int v164 = *(_DWORD *)(a1 + 1440);
          if (v164)
          {
            uint64_t v165 = *(void *)(a1 + 1432);
            goto LABEL_309;
          }
          v174 = 0;
LABEL_322:
          *sub_1CCD11EEC(a1 + 1424, v161 + 24, (void *)(v161 + 24), v174) = *v163;
          unint64_t v175 = *(unsigned int *)(a1 + 1568);
          if (v175 >= *(unsigned int *)(a1 + 1572)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 1560) + 8 * v175) = *v163;
          ++*(_DWORD *)(a1 + 1568);
        }
      }
LABEL_324:
      v161 += 48;
      if (v161 == v162) {
        break;
      }
      continue;
    }
  }
LABEL_328:
  v176 = (_DWORD *)(a1 + 1724);
  for (unsigned int k = *(_DWORD *)(a1 + 104); k; unsigned int k = *(_DWORD *)(a1 + 104))
  {
    uint64_t v203 = *(void *)(*(void *)(a1 + 96) + 8 * k - 8);
    *(_DWORD *)(a1 + 104) = k - 1;
    int v204 = *(_DWORD *)(v203 + 20);
    if ((v204 & 0x40000000) != 0)
    {
      v206 = *(uint64_t **)(v203 - 8);
      uint64_t v205 = v204 & 0x7FFFFFF;
      if (!v205) {
        goto LABEL_401;
      }
    }
    else
    {
      uint64_t v205 = v204 & 0x7FFFFFF;
      v206 = (uint64_t *)(v203 - 32 * v205);
      if (!v205) {
        goto LABEL_401;
      }
    }
    uint64_t v207 = 32 * v205;
    do
    {
      if (*v206) {
        BOOL v208 = *(unsigned __int8 *)(*v206 + 16) >= 0x1Cu;
      }
      else {
        BOOL v208 = 0;
      }
      if (v208) {
        sub_1CCD11318(a1, *v206);
      }
      v206 += 4;
      v207 -= 32;
    }
    while (v207);
LABEL_401:
    if (v203)
    {
      if (*(unsigned char *)(v203 + 16) == 83)
      {
        v266 = *(void **)(v203 + 40);
        uint64_t v209 = sub_1CCD11070(v256, (uint64_t *)&v266);
        if (!*(unsigned char *)(v209 + 2))
        {
          *(unsigned char *)(v209 + 2) = 1;
          uint64_t v178 = *(void *)(*(void *)(v209 + 16) + 8);
          if (v178)
          {
            while (1)
            {
              uint64_t v179 = *(void *)(v178 + 24);
              unsigned int v180 = *(unsigned __int8 *)(v179 + 16);
              BOOL v181 = v179 && v180 >= 0x1C;
              if (v181 && v180 - 29 <= 0xA) {
                break;
              }
              uint64_t v178 = *(void *)(v178 + 8);
              if (!v178) {
                goto LABEL_404;
              }
            }
LABEL_341:
            v183 = *(void **)(v179 + 40);
            v266 = v183;
            uint64_t v184 = sub_1CCD11070(v256, (uint64_t *)&v266);
            if (*(unsigned char *)(v184 + 3)) {
              goto LABEL_374;
            }
            *(unsigned char *)(v184 + 3) = 1;
            uint64_t v185 = *(void *)(a1 + 1712);
            uint64_t v186 = *(unsigned int *)(a1 + 1724);
            if (v185 == *(void *)(a1 + 1704))
            {
              if (v186)
              {
                v187 = 0;
                uint64_t v188 = 8 * v186;
                v189 = *(void **)(a1 + 1712);
                do
                {
                  if ((void *)*v189 == v183) {
                    goto LABEL_374;
                  }
                  if (*v189 == -2) {
                    v187 = v189;
                  }
                  ++v189;
                  v188 -= 8;
                }
                while (v188);
                if (v187)
                {
                  void *v187 = v183;
                  --*(_DWORD *)(a1 + 1728);
                  goto LABEL_374;
                }
              }
              unsigned int v190 = *(_DWORD *)(a1 + 1720);
              if (v186 < v190)
              {
                _DWORD *v176 = v186 + 1;
                *(void *)(v185 + 8 * v186) = v183;
                goto LABEL_374;
              }
            }
            else
            {
              unsigned int v190 = *(_DWORD *)(a1 + 1720);
            }
            if (3 * v190 <= 4 * ((int)v186 - *(_DWORD *)(a1 + 1728)))
            {
              if (v190 >= 0x40) {
                v190 *= 2;
              }
              else {
                unsigned int v190 = 128;
              }
            }
            else if (v190 - v186 >= v190 >> 3)
            {
              goto LABEL_355;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 1704), v190);
            unsigned int v190 = *(_DWORD *)(a1 + 1720);
            uint64_t v185 = *(void *)(a1 + 1712);
LABEL_355:
            unsigned int v191 = v190 - 1;
            unsigned int v192 = (v190 - 1) & ((v183 >> 4) ^ (v183 >> 9));
            v193 = (void **)(v185 + 8 * v192);
            v194 = *v193;
            if (*v193 == (void *)-1)
            {
              v195 = 0;
            }
            else
            {
              v195 = 0;
              int v196 = 1;
              do
              {
                if (v194 == v183) {
                  goto LABEL_374;
                }
                if (v195) {
                  BOOL v197 = 0;
                }
                else {
                  BOOL v197 = v194 == (void *)-2;
                }
                if (v197) {
                  v195 = v193;
                }
                unsigned int v198 = v192 + v196++;
                unsigned int v192 = v198 & v191;
                v193 = (void **)(v185 + 8 * (v198 & v191));
                v194 = *v193;
              }
              while (*v193 != (void *)-1);
            }
            if (v195) {
              v199 = v195;
            }
            else {
              v199 = v193;
            }
            if (*v199 != v183)
            {
              if (*v199 == (void *)-2) {
                --*(_DWORD *)(a1 + 1728);
              }
              else {
                ++*v176;
              }
              *v199 = v183;
            }
LABEL_374:
            while (1)
            {
              uint64_t v178 = *(void *)(v178 + 8);
              if (!v178) {
                break;
              }
              uint64_t v179 = *(void *)(v178 + 24);
              unsigned int v200 = *(unsigned __int8 *)(v179 + 16);
              if (v179) {
                BOOL v201 = v200 >= 0x1C;
              }
              else {
                BOOL v201 = 0;
              }
              if (v201 && v200 - 29 < 0xB) {
                goto LABEL_341;
              }
            }
          }
        }
      }
    }
LABEL_404:
    ;
  }
  uint64_t v210 = *(unsigned int *)(a1 + 1568);
  if (v210)
  {
    sub_1CC0BED68((llvm::SmallPtrSetImplBase *)&v279, *(uint64_t **)(a1 + 1560), (uint64_t *)(*(void *)(a1 + 1560) + 8 * v210));
    v266 = &v268;
    v267 = (void *)0x2000000000;
    v257 = *(void **)(a1 + 16);
    v258 = 0;
    v261 = &v279;
    v262[0] = a1 + 1704;
    LOBYTE(v259) = 1;
    sub_1CCD122E0();
  }
  uint64_t v211 = *(void *)a1 + 72;
  for (m = *(void **)(*(void *)a1 + 80); m != (void *)v211; m = (void *)m[1])
  {
    v213 = m - 3;
    if (!m) {
      v213 = 0;
    }
    v214 = (uint64_t *)v213[6];
    if (v214 != v213 + 5)
    {
      if ((void *)v211 != m)
      {
        v215 = 0;
        v216 = (void *)(*(void *)a1 + 72);
        do
        {
          v217 = v216;
          for (n = v215; ; n = v220 + 5)
          {
            if (v217 != (void *)v211)
            {
              v219 = v217 - 3;
              if (!v217) {
                v219 = 0;
              }
              if (n != (uint64_t *)v219[6]) {
                break;
              }
            }
            v217 = (void *)*v217;
            v220 = v217 - 3;
            if (!v217) {
              v220 = 0;
            }
          }
          uint64_t v221 = *n;
          if (*n) {
            v222 = (void *)(*n - 24);
          }
          else {
            v222 = 0;
          }
          v266 = v222;
          if (!*(unsigned char *)sub_1CCD112AC(v255, (uint64_t *)&v266))
          {
            if (!sub_1CBF63B28((uint64_t)v222) || v221 == 0) {
              goto LABEL_453;
            }
            uint64_t v224 = *(void *)(v222[6] - 8 * *(unsigned int *)(v222[6] + 8));
            uint64_t v225 = *(void *)(a1 + 1144);
            uint64_t v226 = *(void *)(a1 + 1136);
            if (v225 == v226)
            {
              uint64_t v227 = *(unsigned int *)(a1 + 1156);
              v228 = (void *)(v225 + 8 * v227);
              if (v227)
              {
                uint64_t v229 = 0;
                uint64_t v230 = 8 * v227;
                while (*(void *)(v225 + v229) != v224)
                {
                  v229 += 8;
                  if (v230 == v229) {
                    goto LABEL_449;
                  }
                }
                v228 = (void *)(v225 + v229);
              }
LABEL_449:
              uint64_t v226 = *(void *)(a1 + 1144);
            }
            else
            {
              uint64_t v231 = *(unsigned int *)(a1 + 1152);
              int v232 = v231 - 1;
              unsigned int v233 = (v231 - 1) & ((v224 >> 4) ^ (v224 >> 9));
              v228 = (void *)(v225 + 8 * v233);
              uint64_t v234 = *v228;
              if (*v228 == -1)
              {
                v235 = 0;
LABEL_467:
                if (v235) {
                  v228 = v235;
                }
                if (*v228 != v224) {
                  v228 = (void *)(v225 + 8 * v231);
                }
              }
              else
              {
                v235 = 0;
                int v236 = 1;
                while (v234 != v224)
                {
                  if (v235) {
                    BOOL v237 = 0;
                  }
                  else {
                    BOOL v237 = v234 == -2;
                  }
                  if (v237) {
                    v235 = v228;
                  }
                  unsigned int v238 = v233 + v236++;
                  unsigned int v233 = v238 & v232;
                  v228 = (void *)(v225 + 8 * (v238 & v232));
                  uint64_t v234 = *v228;
                  if (*v228 == -1) {
                    goto LABEL_467;
                  }
                }
              }
            }
            BOOL v28 = v225 == v226;
            v239 = (unsigned int *)(a1 + 1156);
            if (!v28) {
              v239 = (unsigned int *)(a1 + 1152);
            }
            if (v228 == (void *)(v225 + 8 * *v239))
            {
LABEL_453:
              unint64_t v240 = *(unsigned int *)(a1 + 104);
              if (v240 >= *(unsigned int *)(a1 + 108)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(a1 + 96) + 8 * v240) = v222;
              ++*(_DWORD *)(a1 + 104);
              v266 = &v268;
              v267 = (void *)0x100000000;
              llvm::findDbgUsers((uint64_t)&v266, (uint64_t ***)v222);
              llvm::salvageDebugInfoForDbgValues((llvm::CastInst *)v222, (uint64_t *)v266, v267);
              if (v266 != &v268) {
                free(v266);
              }
            }
          }
          while (1)
          {
            if (v216 != (void *)v211)
            {
              v242 = v216 - 3;
              if (!v216) {
                v242 = 0;
              }
              if (v215 != (uint64_t *)v242[6]) {
                break;
              }
            }
            v216 = (void *)*v216;
            v241 = v216 - 3;
            if (!v216) {
              v241 = 0;
            }
            v215 = v241 + 5;
          }
          v215 = (uint64_t *)*v215;
        }
        while (v216 != m || v215 != v214);
      }
      break;
    }
  }
  uint64_t v243 = *(unsigned int *)(a1 + 104);
  if (v243)
  {
    v244 = *(uint64_t **)(a1 + 96);
    v245 = &v244[v243];
    while (1)
    {
      uint64_t v246 = *v244;
      int v247 = *(_DWORD *)(*v244 + 20);
      if ((v247 & 0x40000000) != 0)
      {
        uint64_t v249 = *(void *)(v246 - 8);
        uint64_t v248 = v247 & 0x7FFFFFF;
        if (!v248) {
          goto LABEL_481;
        }
      }
      else
      {
        uint64_t v248 = v247 & 0x7FFFFFF;
        uint64_t v249 = v246 - 32 * v248;
        if (!v248) {
          goto LABEL_481;
        }
      }
      uint64_t v250 = 32 * v248;
      v251 = (void **)(v249 + 16);
      do
      {
        if (*(v251 - 2))
        {
          void **v251 = *(v251 - 1);
          uint64_t v252 = (uint64_t)*(v251 - 1);
          if (v252) {
            *(void *)(v252 + 16) = *v251;
          }
        }
        *(v251 - 2) = 0;
        v251 += 4;
        v250 -= 32;
      }
      while (v250);
LABEL_481:
      if (++v244 == v245) {
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
    }
  }
  return 0;
}

uint64_t sub_1CCD10E6C(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 1712);
  if (v2 != *(void **)(a1 + 1704)) {
    free(v2);
  }
  unsigned int v3 = *(void **)(a1 + 1560);
  if (v3 != (void *)(a1 + 1576)) {
    free(v3);
  }
  if ((*(unsigned char *)(a1 + 1424) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 1432), 8);
  }
  uint64_t v4 = *(void **)(a1 + 1144);
  if (v4 != *(void **)(a1 + 1136)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 96);
  if (v5 != (void *)(a1 + 112)) {
    free(v5);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  unint64_t v6 = *(void **)(a1 + 48);
  if (v6)
  {
    *(void *)(a1 + 56) = v6;
    operator delete(v6);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 24), 8);
  return a1;
}

void sub_1CCD10F20(uint64_t a1)
{
}

uint64_t sub_1CCD10FC0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0758;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D2D8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF0760, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD10F20;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF0760, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD11070(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v32 = *a2;
  int v33 = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = *(void *)a1;
    unsigned int v7 = v5 - 1;
    uint64_t v8 = (v5 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    uint64_t v9 = (void *)(*(void *)a1 + 16 * v8);
    uint64_t v10 = *v9;
    if (v4 == *v9)
    {
LABEL_11:
      unsigned int v15 = *(_DWORD *)(v6 + 16 * v8 + 8);
      uint64_t v16 = *(void *)(a1 + 24);
      return v16 + 48 * v15 + 8;
    }
    uint64_t v11 = 0;
    int v12 = 1;
    while (v10 != -4096)
    {
      if (v11) {
        BOOL v13 = 0;
      }
      else {
        BOOL v13 = v10 == -8192;
      }
      if (v13) {
        uint64_t v11 = v9;
      }
      int v14 = v8 + v12++;
      uint64_t v8 = v14 & v7;
      uint64_t v9 = (void *)(v6 + 16 * v8);
      uint64_t v10 = *v9;
      if (v4 == *v9) {
        goto LABEL_11;
      }
    }
    if (v11) {
      uint64_t v17 = v11;
    }
    else {
      uint64_t v17 = v9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v18 = sub_1CBFAF8D8(a1, (uint64_t)&v32, &v32, v17);
  void *v18 = v32;
  *((_DWORD *)v18 + 2) = v33;
  uint64_t v19 = *a2;
  unsigned int v21 = *(uint64_t **)(a1 + 32);
  unint64_t v20 = *(void *)(a1 + 40);
  if ((unint64_t)v21 >= v20)
  {
    char v23 = *(char **)(a1 + 24);
    unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v21 - v23) >> 4) + 1;
    if (v24 > 0x555555555555555) {
      abort();
    }
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - (void)v23) >> 4);
    if (2 * v25 > v24) {
      unint64_t v24 = 2 * v25;
    }
    if (v25 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v26 = 0x555555555555555;
    }
    else {
      unint64_t v26 = v24;
    }
    if (v26)
    {
      if (v26 > 0x555555555555555) {
        sub_1CB833614();
      }
      unsigned int v27 = (char *)operator new(48 * v26);
    }
    else
    {
      unsigned int v27 = 0;
    }
    BOOL v28 = &v27[16 * (((char *)v21 - v23) >> 4)];
    *(void *)BOOL v28 = v19;
    *(_OWORD *)(v28 + 8) = 0u;
    unsigned int v22 = v28 + 48;
    *(_OWORD *)(v28 + 24) = 0u;
    *((void *)v28 + 5) = 0;
    if (v21 != (uint64_t *)v23)
    {
      do
      {
        long long v29 = *((_OWORD *)v21 - 3);
        long long v30 = *((_OWORD *)v21 - 1);
        *((_OWORD *)v28 - 2) = *((_OWORD *)v21 - 2);
        *((_OWORD *)v28 - 1) = v30;
        *((_OWORD *)v28 - 3) = v29;
        v28 -= 48;
        v21 -= 6;
      }
      while (v21 != (uint64_t *)v23);
      unsigned int v21 = *(uint64_t **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v28;
    *(void *)(a1 + 32) = v22;
    *(void *)(a1 + 40) = &v27[48 * v26];
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    *unsigned int v21 = v19;
    unsigned int v22 = v21 + 6;
    *(_OWORD *)(v21 + 1) = 0u;
    *(_OWORD *)(v21 + 3) = 0u;
    v21[5] = 0;
  }
  *(void *)(a1 + 32) = v22;
  uint64_t v16 = *(void *)(a1 + 24);
  unsigned int v15 = -1431655765 * (((unint64_t)v22 - v16) >> 4) - 1;
  *((_DWORD *)v18 + 2) = v15;
  return v16 + 48 * v15 + 8;
}

void *sub_1CCD112AC(uint64_t a1, uint64_t *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CC01F510(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CCD116E8(a1, a2, v7);
    *int v5 = *a2;
    v5[1] = 0;
    void v5[2] = 0;
  }
  return v5 + 1;
}

void sub_1CCD11318(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = a2;
  char v4 = sub_1CCD112AC(a1 + 72, &v19);
  if (!*(unsigned char *)v4)
  {
    int v5 = v4;
    *(unsigned char *)char v4 = 1;
    unsigned int v6 = *(_DWORD *)(a1 + 104);
    if (v6 >= *(_DWORD *)(a1 + 108)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 96) + 8 * v6) = a2;
    ++*(_DWORD *)(a1 + 104);
    uint64_t v7 = *(void *)(a2 + 48);
    if (v7) {
      sub_1CCD1179C(a1, v7);
    }
    uint64_t v8 = v5[1];
    if (*(void *)(v8 + 24) == a2)
    {
      if (sub_1CCD11CF4(a1 + 1424, (void *)(v8 + 16)))
      {
        uint64_t v9 = *(void **)(a1 + 1560);
        uint64_t v10 = *(unsigned int *)(a1 + 1568);
        uint64_t v11 = &v9[v10];
        if (v10)
        {
          uint64_t v12 = 8 * v10;
          while (*v9 != *(void *)(v8 + 16))
          {
            ++v9;
            v12 -= 8;
            if (!v12)
            {
              uint64_t v9 = v11;
              break;
            }
          }
        }
        if (v11 != v9 + 1)
        {
          memmove(v9, v9 + 1, (char *)v11 - (char *)(v9 + 1));
          LODWORD(v10) = *(_DWORD *)(a1 + 1568);
        }
        *(_DWORD *)(a1 + 1568) = v10 - 1;
      }
      if (!*(unsigned char *)(v8 + 1))
      {
        uint64_t v13 = *(void *)(a2 + 40);
        uint64_t v14 = *(void *)(v13 + 40);
        if (v14 != v13 + 40)
        {
          if (v14) {
            uint64_t v15 = v14 - 24;
          }
          else {
            uint64_t v15 = 0;
          }
          if (*(unsigned char *)(v15 + 16) != 30)
          {
            int v18 = 2;
            switch(*(unsigned char *)(v15 + 16))
            {
              case 0x1E:
                __break(1u);
                goto LABEL_36;
              case 0x1F:
                int v18 = (*(_DWORD *)(v15 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_32;
              case 0x20:
              case 0x26:
LABEL_36:
                int v18 = (*(_DWORD *)(v15 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_32;
              case 0x21:
                goto LABEL_25;
              case 0x24:
                int v18 = *(_WORD *)(v15 + 18) & 1;
                goto LABEL_32;
              case 0x25:
                int v18 = 1;
                goto LABEL_25;
              case 0x27:
                int v18 = *(_DWORD *)(v15 + 80) + 1;
LABEL_32:
                if (!v18) {
                  goto LABEL_27;
                }
                goto LABEL_25;
              default:
                goto LABEL_27;
            }
          }
          if ((*(_DWORD *)(v15 + 20) & 0x7FFFFFF) == 3) {
            int v18 = 2;
          }
          else {
            int v18 = 1;
          }
LABEL_25:
          for (unsigned int i = 0; i != v18; ++i)
          {
            uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v15, i);
            uint64_t v17 = sub_1CCD11070(a1 + 24, &Successor);
            sub_1CCD11B18(a1, v17);
          }
        }
      }
    }
LABEL_27:
    sub_1CCD11B18(a1, v8);
  }
}

void *sub_1CCD11588(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 24 * v10;
      do
      {
        void *result = -4096;
        result += 3;
        v11 -= 24;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 24 * v3;
      uint64_t v13 = (_OWORD *)(v4 + 8);
      do
      {
        uint64_t v14 = *((void *)v13 - 1);
        if ((v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v18 = 0;
          sub_1CC01F510(*(void *)a1, *(_DWORD *)(a1 + 16), v14, &v18);
          uint64_t v15 = v18;
          uint64_t *v18 = v14;
          *(_OWORD *)(v15 + 1) = *v13;
          ++*(_DWORD *)(a1 + 8);
        }
        uint64_t v13 = (_OWORD *)((char *)v13 + 24);
        v12 -= 24;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v16 = *(unsigned int *)(a1 + 16);
  if (v16)
  {
    uint64_t v17 = 24 * v16;
    do
    {
      void *result = -4096;
      result += 3;
      v17 -= 24;
    }
    while (v17);
  }
  return result;
}

void *sub_1CCD116E8(uint64_t a1, uint64_t *a2, void *a3)
{
  unsigned int v8 = a3;
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CCD11588(a1, v6);
  sub_1CC01F510(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  int v5 = *(_DWORD *)(a1 + 8);
  a3 = v8;
LABEL_3:
  *(_DWORD *)(a1 + 8) = v5 + 1;
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CCD1179C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (llvm::SmallPtrSetImplBase *)(a1 + 1136);
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 1144);
    uint64_t v6 = *(unsigned int *)(a1 + 1156);
    if (v5 == *(void *)(a1 + 1136))
    {
      if (v6)
      {
        int v7 = 0;
        uint64_t v8 = 8 * v6;
        uint64_t v9 = *(void **)(a1 + 1144);
        do
        {
          if (*v9 == a2) {
            return;
          }
          if (*v9 == -2) {
            int v7 = v9;
          }
          ++v9;
          v8 -= 8;
        }
        while (v8);
        if (v7)
        {
          *int v7 = a2;
          --*(_DWORD *)(a1 + 1160);
          goto LABEL_34;
        }
      }
      unsigned int v10 = *(_DWORD *)(a1 + 1152);
      if (v6 < v10)
      {
        *(_DWORD *)(a1 + 1156) = v6 + 1;
        *(void *)(v5 + 8 * v6) = a2;
        goto LABEL_34;
      }
    }
    else
    {
      unsigned int v10 = *(_DWORD *)(a1 + 1152);
    }
    if (3 * v10 <= 4 * ((int)v6 - *(_DWORD *)(a1 + 1160)))
    {
      if (v10 >= 0x40) {
        v10 *= 2;
      }
      else {
        unsigned int v10 = 128;
      }
    }
    else if (v10 - v6 >= v10 >> 3)
    {
      goto LABEL_15;
    }
    llvm::SmallPtrSetImplBase::Grow(v4, v10);
    unsigned int v10 = *(_DWORD *)(a1 + 1152);
    uint64_t v5 = *(void *)(a1 + 1144);
LABEL_15:
    unsigned int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v13 = (void *)(v5 + 8 * v12);
    uint64_t v14 = *v13;
    if (*v13 == -1)
    {
      uint64_t v15 = 0;
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      do
      {
        if (v14 == a2) {
          return;
        }
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v13;
        }
        unsigned int v18 = v12 + v16++;
        unsigned int v12 = v18 & v11;
        uint64_t v13 = (void *)(v5 + 8 * (v18 & v11));
        uint64_t v14 = *v13;
      }
      while (*v13 != -1);
    }
    uint64_t v19 = v15 ? v15 : v13;
    if (*v19 == a2) {
      break;
    }
    if (*v19 == -2) {
      --*(_DWORD *)(a1 + 1160);
    }
    else {
      ++*(_DWORD *)(a1 + 1156);
    }
    *uint64_t v19 = a2;
LABEL_34:
    unint64_t v20 = (unsigned __int8 *)(a2 - 8 * *(unsigned int *)(a2 + 8));
LABEL_35:
    unsigned int v21 = *(unsigned __int8 **)v20;
    while (1)
    {
      unsigned int v22 = v21;
      uint64_t v23 = *(void *)(a1 + 1144);
      uint64_t v24 = *(unsigned int *)(a1 + 1156);
      if (v23 != *(void *)(a1 + 1136))
      {
        unsigned int v28 = *(_DWORD *)(a1 + 1152);
        goto LABEL_47;
      }
      if (v24) {
        break;
      }
LABEL_44:
      unsigned int v28 = *(_DWORD *)(a1 + 1152);
      if (v24 < v28)
      {
        *(_DWORD *)(a1 + 1156) = v24 + 1;
        *(void *)(v23 + 8 * v24) = v22;
        goto LABEL_68;
      }
LABEL_47:
      if (3 * v28 <= 4 * ((int)v24 - *(_DWORD *)(a1 + 1160)))
      {
        if (v28 >= 0x40) {
          v28 *= 2;
        }
        else {
          unsigned int v28 = 128;
        }
LABEL_81:
        llvm::SmallPtrSetImplBase::Grow(v4, v28);
        unsigned int v28 = *(_DWORD *)(a1 + 1152);
        uint64_t v23 = *(void *)(a1 + 1144);
        goto LABEL_49;
      }
      if (v28 - v24 < v28 >> 3) {
        goto LABEL_81;
      }
LABEL_49:
      unsigned int v29 = v28 - 1;
      unsigned int v30 = (v28 - 1) & ((v22 >> 4) ^ (v22 >> 9));
      uint64_t v31 = (unsigned __int8 **)(v23 + 8 * v30);
      uint64_t v32 = *v31;
      if (*v31 != (unsigned __int8 *)-1)
      {
        int v33 = 0;
        int v34 = 1;
        while (v32 != v22)
        {
          if (v33) {
            BOOL v35 = 0;
          }
          else {
            BOOL v35 = v32 == (unsigned __int8 *)-2;
          }
          if (v35) {
            int v33 = v31;
          }
          unsigned int v36 = v30 + v34++;
          unsigned int v30 = v36 & v29;
          uint64_t v31 = (unsigned __int8 **)(v23 + 8 * (v36 & v29));
          uint64_t v32 = *v31;
          if (*v31 == (unsigned __int8 *)-1) {
            goto LABEL_61;
          }
        }
        goto LABEL_83;
      }
      int v33 = 0;
LABEL_61:
      if (v33) {
        uint64_t v37 = v33;
      }
      else {
        uint64_t v37 = v31;
      }
      if (*v37 == v22) {
        goto LABEL_83;
      }
      if (*v37 == (unsigned __int8 *)-2) {
        --*(_DWORD *)(a1 + 1160);
      }
      else {
        ++*(_DWORD *)(a1 + 1156);
      }
      *uint64_t v37 = v22;
LABEL_68:
      int v38 = *v22;
      if (v38 == 17) {
        goto LABEL_83;
      }
      if ((v38 - 11) < 4 || v38 == 33 || (v38 & 0xFE) == 0x12 || v38 == 20 || v38 == 21)
      {
        unint64_t v20 = &v22[-8 * *((unsigned int *)v22 + 2) + 8];
        goto LABEL_35;
      }
      unsigned int v21 = 0;
      if (v38 == 31)
      {
        unint64_t v20 = &v22[-8 * *((unsigned int *)v22 + 2)];
        goto LABEL_35;
      }
    }
    unint64_t v25 = 0;
    uint64_t v26 = 8 * v24;
    unsigned int v27 = *(unsigned __int8 ***)(a1 + 1144);
    while (*v27 != v22)
    {
      if (*v27 == (unsigned __int8 *)-2) {
        unint64_t v25 = v27;
      }
      ++v27;
      v26 -= 8;
      if (!v26)
      {
        if (!v25) {
          goto LABEL_44;
        }
        *unint64_t v25 = v22;
        --*(_DWORD *)(a1 + 1160);
        goto LABEL_68;
      }
    }
LABEL_83:
    if (*(_DWORD *)(a2 + 8) == 2)
    {
      a2 = *(void *)(a2 - 8);
      if (a2) {
        continue;
      }
    }
    return;
  }
}

void sub_1CCD11B18(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2) {
    return;
  }
  *(unsigned char *)a2 = 1;
  if (!*(unsigned char *)(a2 + 3))
  {
    *(unsigned char *)(a2 + 3) = 1;
    uint64_t v4 = *(void *)(a2 + 16);
    uint64_t v5 = *(void *)(a1 + 1712);
    uint64_t v6 = *(unsigned int *)(a1 + 1724);
    if (v5 == *(void *)(a1 + 1704))
    {
      if (v6)
      {
        int v7 = 0;
        uint64_t v8 = 8 * v6;
        uint64_t v9 = *(void **)(a1 + 1712);
        while (*v9 != v4)
        {
          if (*v9 == -2) {
            int v7 = v9;
          }
          ++v9;
          v8 -= 8;
          if (!v8)
          {
            if (!v7) {
              goto LABEL_12;
            }
            *int v7 = v4;
            --*(_DWORD *)(a1 + 1728);
            goto LABEL_36;
          }
        }
        goto LABEL_36;
      }
LABEL_12:
      unsigned int v10 = *(_DWORD *)(a1 + 1720);
      if (v6 < v10)
      {
        *(_DWORD *)(a1 + 1724) = v6 + 1;
        *(void *)(v5 + 8 * v6) = v4;
        goto LABEL_36;
      }
    }
    else
    {
      unsigned int v10 = *(_DWORD *)(a1 + 1720);
    }
    if (3 * v10 <= 4 * ((int)v6 - *(_DWORD *)(a1 + 1728)))
    {
      if (v10 >= 0x40) {
        v10 *= 2;
      }
      else {
        unsigned int v10 = 128;
      }
    }
    else if (v10 - v6 >= v10 >> 3)
    {
      goto LABEL_17;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 1704), v10);
    unsigned int v10 = *(_DWORD *)(a1 + 1720);
    uint64_t v5 = *(void *)(a1 + 1712);
LABEL_17:
    unsigned int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    uint64_t v13 = (void *)(v5 + 8 * v12);
    uint64_t v14 = *v13;
    if (*v13 == -1)
    {
      uint64_t v15 = 0;
LABEL_29:
      if (v15) {
        uint64_t v19 = v15;
      }
      else {
        uint64_t v19 = v13;
      }
      if (*v19 != v4)
      {
        if (*v19 == -2) {
          --*(_DWORD *)(a1 + 1728);
        }
        else {
          ++*(_DWORD *)(a1 + 1724);
        }
        *uint64_t v19 = v4;
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != v4)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v13;
        }
        unsigned int v18 = v12 + v16++;
        unsigned int v12 = v18 & v11;
        uint64_t v13 = (void *)(v5 + 8 * (v18 & v11));
        uint64_t v14 = *v13;
        if (*v13 == -1) {
          goto LABEL_29;
        }
      }
    }
  }
LABEL_36:
  if (*(unsigned char *)(a2 + 1))
  {
    uint64_t v20 = *(void *)(a2 + 24);
    sub_1CCD11318(a1, v20);
  }
}

uint64_t sub_1CCD11CF4(uint64_t a1, void *a2)
{
  uint64_t v2 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v3 = 16;
  }
  else
  {
    int v3 = *(_DWORD *)(a1 + 16);
    if (!v3) {
      return 0;
    }
    uint64_t v2 = *(void *)(a1 + 8);
  }
  int v4 = v3 - 1;
  LODWORD(v5) = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
  uint64_t v6 = (uint64_t *)(v2 + 8 * v5);
  uint64_t v7 = *v6;
  if (*a2 == *v6)
  {
LABEL_10:
    *uint64_t v6 = -8192;
    int v10 = *(_DWORD *)(a1 + 4) + 1;
    *(_DWORD *)a1 -= 2;
    *(_DWORD *)(a1 + 4) = v10;
    return 1;
  }
  int v8 = 1;
  while (v7 != -4096)
  {
    int v9 = v5 + v8++;
    uint64_t v5 = v9 & v4;
    uint64_t v7 = *(void *)(v2 + 8 * v5);
    if (*a2 == v7)
    {
      uint64_t v6 = (uint64_t *)(v2 + 8 * v5);
      goto LABEL_10;
    }
  }
  return 0;
}

uint64_t sub_1CCD11D88(uint64_t result, uint64_t a2, void *a3, unsigned char *a4)
{
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  if (v4)
  {
    uint64_t v5 = *(void *)a2;
    unsigned int v6 = v4 - 1;
    unsigned int v7 = ((*a3 >> 4) ^ (*a3 >> 9)) & (v4 - 1);
    uint64_t v8 = *(void *)a2 + 16 * v7;
    uint64_t v9 = *(void *)v8;
    if (*a3 == *(void *)v8)
    {
LABEL_11:
      char v14 = 0;
      goto LABEL_12;
    }
    uint64_t v10 = 0;
    int v11 = 1;
    while (v9 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v9 == -8192;
      }
      if (v12) {
        uint64_t v10 = v8;
      }
      unsigned int v13 = v7 + v11++;
      unsigned int v7 = v13 & v6;
      uint64_t v8 = v5 + 16 * (v13 & v6);
      uint64_t v9 = *(void *)v8;
      if (*a3 == *(void *)v8) {
        goto LABEL_11;
      }
    }
    if (v10) {
      uint64_t v8 = v10;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v15 = *(_DWORD *)(a2 + 8);
  if (4 * v15 + 4 >= 3 * v4)
  {
    v4 *= 2;
    goto LABEL_22;
  }
  if (v4 + ~v15 - *(_DWORD *)(a2 + 12) <= v4 >> 3)
  {
LABEL_22:
    uint64_t v17 = result;
    uint64_t v19 = (uint64_t *)a2;
    int v16 = a4;
    unsigned int v18 = a3;
    sub_1CC9A2EA0(a2, v4);
    uint64_t v20 = 0;
    sub_1CC9A2D50(v19, v18, &v20);
    uint64_t result = v17;
    a3 = v18;
    a4 = v16;
    a2 = (uint64_t)v19;
    uint64_t v8 = v20;
  }
  ++*(_DWORD *)(a2 + 8);
  if (*(void *)v8 != -4096) {
    --*(_DWORD *)(a2 + 12);
  }
  *(void *)uint64_t v8 = *a3;
  *(unsigned char *)(v8 + 8) = *a4;
  uint64_t v5 = *(void *)a2;
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  char v14 = 1;
LABEL_12:
  *(void *)uint64_t result = v8;
  *(void *)(result + 8) = v5 + 16 * v4;
  *(unsigned char *)(result + 16) = v14;
  return result;
}

void *sub_1CCD11EEC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v8 = 16;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    sub_1CCD12064(a1, 2 * v8);
    uint64_t v11 = a1 + 8;
    int v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v12 = 16;
    }
    else
    {
      int v12 = *(_DWORD *)(a1 + 16);
      if (!v12)
      {
        int v9 = 0;
        a4 = 0;
        goto LABEL_7;
      }
      uint64_t v11 = *(void *)(a1 + 8);
    }
    int v9 = *(_DWORD *)a1 & 1;
    int v13 = v12 - 1;
    unsigned int v14 = ((*a3 >> 4) ^ (*a3 >> 9)) & v13;
    a4 = (void *)(v11 + 8 * v14);
    uint64_t v15 = *a4;
    if (*a3 != *a4)
    {
      int v16 = 0;
      int v17 = 1;
      while (v15 != -4096)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == -8192;
        }
        if (v18) {
          int v16 = a4;
        }
        unsigned int v19 = v14 + v17++;
        unsigned int v14 = v19 & v13;
        a4 = (void *)(v11 + 8 * v14);
        uint64_t v15 = *a4;
        if (*a3 == *a4) {
          goto LABEL_7;
        }
      }
      if (v16) {
        a4 = v16;
      }
    }
  }
  else
  {
    if (v8 + ~v7 - *(_DWORD *)(a1 + 4) <= v8 >> 3)
    {
      sub_1CCD12064(a1, v8);
      uint64_t v20 = 0;
      sub_1CBB07564(a1, a3, &v20);
      a4 = v20;
      int v6 = *(_DWORD *)a1;
    }
    int v9 = v6 & 1;
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  return a4;
}

int *sub_1CCD12064(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 <= 0x10)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    sub_1CCD121E0((int *)a1, v11, &v11[v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  int v6 = v14;
  for (uint64_t i = 8; i != 136; i += 8)
  {
    uint64_t v8 = *(void *)(a1 + i);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v6++ = v8;
    }
  }
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CCD121E0((int *)a1, v14, v6);
}

int *sub_1CCD121E0(int *result, uint64_t *a2, uint64_t *a3)
{
  int v3 = *result;
  *result &= 1u;
  result[1] = 0;
  if (v3)
  {
    int v6 = result + 34;
    int v5 = result + 2;
  }
  else
  {
    uint64_t v4 = result[4];
    if (!v4) {
      goto LABEL_5;
    }
    int v5 = (void *)*((void *)result + 1);
    int v6 = &v5[v4];
  }
  do
    *v5++ = -4096;
  while (v5 != v6);
LABEL_5:
  while (a2 != a3)
  {
    uint64_t v7 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      if (*(unsigned char *)result)
      {
        int v9 = 16;
        uint64_t v8 = result + 2;
      }
      else
      {
        uint64_t v8 = (int *)*((void *)result + 1);
        int v9 = result[4];
      }
      int v10 = v9 - 1;
      unsigned int v11 = (v9 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      uint64_t v12 = &v8[2 * v11];
      uint64_t v13 = *(void *)v12;
      if (v7 != *(void *)v12)
      {
        unsigned int v14 = 0;
        int v15 = 1;
        while (v13 != -4096)
        {
          if (v14) {
            BOOL v16 = 0;
          }
          else {
            BOOL v16 = v13 == -8192;
          }
          if (v16) {
            unsigned int v14 = v12;
          }
          unsigned int v17 = v11 + v15++;
          unsigned int v11 = v17 & v10;
          uint64_t v12 = &v8[2 * (v17 & v10)];
          uint64_t v13 = *(void *)v12;
          if (v7 == *(void *)v12) {
            goto LABEL_21;
          }
        }
        if (v14) {
          uint64_t v12 = v14;
        }
      }
LABEL_21:
      *(void *)uint64_t v12 = v7;
      *result += 2;
    }
    ++a2;
  }
  return result;
}

void sub_1CCD122E0()
{
}

unsigned char *sub_1CCD12A10@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a2;
  if (v3) {
    return sub_1CC5ACE40(v3, v4, (char **)a3);
  }
  do
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (!v4) {
      break;
    }
    uint64_t v6 = *(void *)(v4 + 24);
    unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
    BOOL v8 = v6 && v7 >= 0x1C;
  }
  while (!v8 || v7 - 29 >= 0xB);
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x800000000;
  return (unsigned char *)sub_1CBF846A4(a3, v4, 0);
}

void sub_1CCD12A64(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = **a1;
  uint64_t v5 = *(void *)(v4 + 48);
  uint64_t v6 = *(unsigned int *)(v4 + 64);
  if (v6)
  {
    LODWORD(v7) = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    BOOL v8 = (uint64_t *)(v5 + 16 * v7);
    uint64_t v9 = *v8;
    if (*v8 == a2) {
      goto LABEL_3;
    }
    int v12 = 1;
    while (v9 != -4096)
    {
      int v13 = v7 + v12++;
      uint64_t v7 = v13 & (v6 - 1);
      uint64_t v9 = *(void *)(v5 + 16 * v7);
      if (v9 == a2)
      {
        BOOL v8 = (uint64_t *)(v5 + 16 * v7);
        goto LABEL_3;
      }
    }
  }
  BOOL v8 = (uint64_t *)(v5 + 16 * v6);
LABEL_3:
  if (v8 == (uint64_t *)(v5 + 16 * v6)) {
    int v10 = 0;
  }
  else {
    int v10 = (uint64_t *)v8[1];
  }
  uint64_t v11 = *((unsigned int *)v10 + 4);
  if (v11 > *(_DWORD *)a1[1]) {
    return;
  }
  unsigned int v14 = a1[2];
  uint64_t v15 = v14[1];
  uint64_t v16 = *((unsigned int *)v14 + 5);
  if (v15 == *v14)
  {
    if (v16)
    {
      unsigned int v17 = 0;
      uint64_t v18 = 8 * v16;
      unsigned int v19 = (uint64_t **)v14[1];
      while (*v19 != v10)
      {
        if (*v19 == (uint64_t *)-2) {
          unsigned int v17 = v19;
        }
        ++v19;
        v18 -= 8;
        if (!v18)
        {
          if (!v17) {
            goto LABEL_19;
          }
          *unsigned int v17 = v10;
          --*((_DWORD *)v14 + 6);
          goto LABEL_21;
        }
      }
      return;
    }
LABEL_19:
    unsigned int v20 = *((_DWORD *)v14 + 4);
    if (v16 < v20)
    {
      *((_DWORD *)v14 + 5) = v16 + 1;
      *(void *)(v15 + 8 * v16) = v10;
LABEL_21:
      uint64_t v21 = *v10;
      if (!*((unsigned char *)v3 + 16)) {
        goto LABEL_31;
      }
      unsigned int v22 = (uint64_t *)v3[3];
      uint64_t v24 = *v22;
      uint64_t v23 = v22[1];
      if (v23 == *v22)
      {
        uint64_t v25 = *((unsigned int *)v22 + 5);
        uint64_t v26 = (void *)(v23 + 8 * v25);
        if (v25)
        {
          uint64_t v27 = 0;
          uint64_t v28 = 8 * v25;
          while (*(void *)(v23 + v27) != v21)
          {
            v27 += 8;
            if (v28 == v27) {
              goto LABEL_27;
            }
          }
          uint64_t v26 = (void *)(v23 + v27);
        }
LABEL_27:
        uint64_t v24 = v22[1];
      }
      else
      {
        uint64_t v53 = *((unsigned int *)v22 + 4);
        int v54 = v53 - 1;
        unsigned int v55 = (v53 - 1) & ((v21 >> 4) ^ (v21 >> 9));
        uint64_t v26 = (void *)(v23 + 8 * v55);
        uint64_t v56 = *v26;
        if (*v26 == -1)
        {
          uint64_t v57 = 0;
LABEL_91:
          if (v57) {
            uint64_t v26 = v57;
          }
          if (*v26 != v21) {
            uint64_t v26 = (void *)(v23 + 8 * v53);
          }
        }
        else
        {
          uint64_t v57 = 0;
          int v58 = 1;
          while (v56 != v21)
          {
            if (v57) {
              BOOL v59 = 0;
            }
            else {
              BOOL v59 = v56 == -2;
            }
            if (v59) {
              uint64_t v57 = v26;
            }
            unsigned int v60 = v55 + v58++;
            unsigned int v55 = v60 & v54;
            uint64_t v26 = (void *)(v23 + 8 * (v60 & v54));
            uint64_t v56 = *v26;
            if (*v26 == -1) {
              goto LABEL_91;
            }
          }
        }
      }
      BOOL v51 = v23 == v24;
      uint64_t v29 = 16;
      if (v51) {
        uint64_t v29 = 20;
      }
      if (v26 != (void *)(v23 + 8 * *(unsigned int *)((char *)v22 + v29)))
      {
LABEL_31:
        unsigned int v30 = a1[3];
        uint64_t v31 = *((unsigned int *)v30 + 2);
        if (v31 >= *((_DWORD *)v30 + 3)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*v30 + 8 * v31) = v21;
        *((_DWORD *)v30 + 2) = v31 + 1;
        uint64_t v32 = (uint64_t *)v3[4];
        uint64_t v34 = *v32;
        uint64_t v33 = v32[1];
        if (v33 == *v32)
        {
          uint64_t v35 = *((unsigned int *)v32 + 5);
          unsigned int v36 = (void *)(v33 + 8 * v35);
          if (v35)
          {
            uint64_t v37 = 0;
            uint64_t v38 = 8 * v35;
            while (*(void *)(v33 + v37) != v21)
            {
              v37 += 8;
              if (v38 == v37) {
                goto LABEL_37;
              }
            }
            unsigned int v36 = (void *)(v33 + v37);
          }
LABEL_37:
          uint64_t v34 = v32[1];
        }
        else
        {
          uint64_t v61 = *((unsigned int *)v32 + 4);
          int v62 = v61 - 1;
          unsigned int v63 = (v61 - 1) & ((v21 >> 4) ^ (v21 >> 9));
          unsigned int v36 = (void *)(v33 + 8 * v63);
          uint64_t v64 = *v36;
          if (*v36 == -1)
          {
            uint64_t v65 = 0;
LABEL_96:
            if (v65) {
              unsigned int v36 = v65;
            }
            if (*v36 != v21) {
              unsigned int v36 = (void *)(v33 + 8 * v61);
            }
          }
          else
          {
            uint64_t v65 = 0;
            int v66 = 1;
            while (v64 != v21)
            {
              if (v65) {
                BOOL v67 = 0;
              }
              else {
                BOOL v67 = v64 == -2;
              }
              if (v67) {
                uint64_t v65 = v36;
              }
              unsigned int v68 = v63 + v66++;
              unsigned int v63 = v68 & v62;
              unsigned int v36 = (void *)(v33 + 8 * (v68 & v62));
              uint64_t v64 = *v36;
              if (*v36 == -1) {
                goto LABEL_96;
              }
            }
          }
        }
        BOOL v51 = v33 == v34;
        uint64_t v39 = 16;
        if (v51) {
          uint64_t v39 = 20;
        }
        if (v36 == (void *)(v33 + 8 * *(unsigned int *)((char *)v32 + v39)))
        {
          long long v40 = a1[4];
          unint64_t v41 = v11 | ((unint64_t)*((unsigned int *)v10 + 18) << 32);
          unsigned int v42 = *((_DWORD *)v40 + 2);
          if (v42 >= *((_DWORD *)v40 + 3)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v43 = (uint64_t **)(*v40 + 16 * v42);
          uint64_t *v43 = v10;
          v43[1] = (uint64_t *)v41;
          uint64_t v44 = (*((_DWORD *)v40 + 2) + 1);
          *((_DWORD *)v40 + 2) = v44;
          sub_1CC0AFEBC(*v40, *v40 + 16 * v44, (uint64_t)&v70, v44);
        }
      }
      return;
    }
  }
  else
  {
    unsigned int v20 = *((_DWORD *)v14 + 4);
  }
  if (3 * v20 <= 4 * ((int)v16 - *((_DWORD *)v14 + 6)))
  {
    if (v20 >= 0x40) {
      v20 *= 2;
    }
    else {
      unsigned int v20 = 128;
    }
  }
  else if (v20 - v16 >= v20 >> 3)
  {
    goto LABEL_47;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a1[2], v20);
  unsigned int v20 = *((_DWORD *)v14 + 4);
  uint64_t v15 = v14[1];
LABEL_47:
  unsigned int v45 = v20 - 1;
  unsigned int v46 = (v20 - 1) & ((v10 >> 4) ^ (v10 >> 9));
  uint64_t v47 = (uint64_t **)(v15 + 8 * v46);
  uint64_t v48 = *v47;
  if (*v47 != (uint64_t *)-1)
  {
    uint64_t v49 = 0;
    int v50 = 1;
    while (v48 != v10)
    {
      if (v49) {
        BOOL v51 = 0;
      }
      else {
        BOOL v51 = v48 == (uint64_t *)-2;
      }
      if (v51) {
        uint64_t v49 = v47;
      }
      unsigned int v52 = v46 + v50++;
      unsigned int v46 = v52 & v45;
      uint64_t v47 = (uint64_t **)(v15 + 8 * (v52 & v45));
      uint64_t v48 = *v47;
      if (*v47 == (uint64_t *)-1) {
        goto LABEL_82;
      }
    }
    return;
  }
  uint64_t v49 = 0;
LABEL_82:
  if (v49) {
    BOOL v69 = v49;
  }
  else {
    BOOL v69 = v47;
  }
  if (*v69 != v10)
  {
    if (*v69 == (uint64_t *)-2) {
      --*((_DWORD *)v14 + 6);
    }
    else {
      ++*((_DWORD *)v14 + 5);
    }
    _WORD *v69 = v10;
    goto LABEL_21;
  }
}

uint64_t sub_1CCD12F20(uint64_t a1, void **a2)
{
  if ((void **)a1 != a2)
  {
    uint64_t v4 = a2 + 2;
    uint64_t v3 = *a2;
    if (*a2 == a2 + 2)
    {
      uint64_t v6 = a2 + 1;
      uint64_t v8 = *((unsigned int *)a2 + 2);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8)
        {
          uint64_t v11 = &v3[2 * v8];
          int v12 = *(void **)a1;
          do
          {
            *int v12 = *v3;
            v12[1] = v3[1];
            v3 += 2;
            v12 += 2;
          }
          while (v3 != v11);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9)
        {
          int v13 = &v3[2 * v9];
          unsigned int v14 = *(void **)a1;
          do
          {
            *unsigned int v14 = *v3;
            v14[1] = v3[1];
            v3 += 2;
            v14 += 2;
          }
          while (v3 != v13);
        }
        else
        {
          uint64_t v9 = 0;
        }
        if (v9 != v8) {
          memcpy((void *)(*(void *)a1 + 16 * v9), &(*a2)[2 * v9], (char *)&(*a2)[2 * v8] - (char *)&(*a2)[2 * v9]);
        }
      }
      *(_DWORD *)(a1 + 8) = v8;
    }
    else
    {
      uint64_t v5 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        int v10 = a2;
        free(v5);
        a2 = v10;
        uint64_t v3 = *v10;
      }
      *(void *)a1 = v3;
      uint64_t v6 = a2 + 1;
      *(void *)(a1 + 8) = a2[1];
      *a2 = v4;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v6 = 0;
  }
  return a1;
}

void sub_1CCD13090(uint64_t *a1)
{
  int v1 = a1 + 1;
  uint64_t v2 = a1[1] + 16 * *((unsigned int *)a1 + 4);
  uint64_t v5 = *(void *)(v2 - 8);
  uint64_t v3 = (void *)(v2 - 8);
  uint64_t v4 = v5;
  if (v5)
  {
    do
    {
      uint64_t v7 = v4;
      do
      {
        uint64_t v7 = *(void *)(v7 + 8);
        if (!v7) {
          break;
        }
        uint64_t v8 = *(void *)(v7 + 24);
        unsigned int v9 = *(unsigned __int8 *)(v8 + 16);
        BOOL v10 = v8 && v9 >= 0x1C;
      }
      while (!v10 || v9 - 29 > 0xA);
      *uint64_t v3 = v7;
      uint64_t v12 = *(void *)(*(void *)(v4 + 24) + 40);
      uint64_t v13 = *a1;
      uint64_t v14 = *(void *)(*a1 + 8);
      uint64_t v15 = *(unsigned int *)(*a1 + 20);
      if (v14 == *(void *)*a1)
      {
        if (v15)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 8 * v15;
          uint64_t v18 = *(void **)(*a1 + 8);
          while (*v18 != v12)
          {
            if (*v18 == -2) {
              uint64_t v16 = v18;
            }
            ++v18;
            v17 -= 8;
            if (!v17)
            {
              if (!v16) {
                goto LABEL_19;
              }
              *uint64_t v16 = v12;
              --*(_DWORD *)(v13 + 24);
              goto LABEL_43;
            }
          }
          goto LABEL_57;
        }
LABEL_19:
        unsigned int v19 = *(_DWORD *)(v13 + 16);
        if (v15 < v19)
        {
          *(_DWORD *)(v13 + 20) = v15 + 1;
          *(void *)(v14 + 8 * v15) = v12;
LABEL_43:
          for (uint64_t i = *(void *)(v12 + 8); i; uint64_t i = *(void *)(i + 8))
          {
            uint64_t v30 = *(void *)(i + 24);
            unsigned int v31 = *(unsigned __int8 *)(v30 + 16);
            if (v30) {
              BOOL v32 = v31 >= 0x1C;
            }
            else {
              BOOL v32 = 0;
            }
            if (v32 && v31 - 29 < 0xB) {
              break;
            }
          }
          unint64_t v34 = *((unsigned int *)a1 + 4);
          if (v34 >= *((unsigned int *)a1 + 5)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v35 = (void *)(a1[1] + 16 * v34);
          *uint64_t v35 = v12;
          v35[1] = i;
          unsigned int v36 = *((_DWORD *)a1 + 4) + 1;
          *((_DWORD *)a1 + 4) = v36;
          goto LABEL_55;
        }
      }
      else
      {
        unsigned int v19 = *(_DWORD *)(v13 + 16);
      }
      if (3 * v19 <= 4 * ((int)v15 - *(_DWORD *)(v13 + 24)))
      {
        if (v19 >= 0x40) {
          v19 *= 2;
        }
        else {
          unsigned int v19 = 128;
        }
      }
      else if (v19 - v15 >= v19 >> 3)
      {
        goto LABEL_24;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)*a1, v19);
      unsigned int v19 = *(_DWORD *)(v13 + 16);
      uint64_t v14 = *(void *)(v13 + 8);
LABEL_24:
      unsigned int v20 = v19 - 1;
      unsigned int v21 = (v19 - 1) & ((v12 >> 4) ^ (v12 >> 9));
      unsigned int v22 = (void *)(v14 + 8 * v21);
      uint64_t v23 = *v22;
      if (*v22 == -1)
      {
        uint64_t v24 = 0;
LABEL_36:
        if (v24) {
          uint64_t v28 = v24;
        }
        else {
          uint64_t v28 = v22;
        }
        if (*v28 != v12)
        {
          if (*v28 == -2) {
            --*(_DWORD *)(v13 + 24);
          }
          else {
            ++*(_DWORD *)(v13 + 20);
          }
          *uint64_t v28 = v12;
          goto LABEL_43;
        }
      }
      else
      {
        uint64_t v24 = 0;
        int v25 = 1;
        while (v23 != v12)
        {
          if (v24) {
            BOOL v26 = 0;
          }
          else {
            BOOL v26 = v23 == -2;
          }
          if (v26) {
            uint64_t v24 = v22;
          }
          unsigned int v27 = v21 + v25++;
          unsigned int v21 = v27 & v20;
          unsigned int v22 = (void *)(v14 + 8 * (v27 & v20));
          uint64_t v23 = *v22;
          if (*v22 == -1) {
            goto LABEL_36;
          }
        }
      }
LABEL_57:
      unsigned int v36 = *((_DWORD *)a1 + 4);
LABEL_55:
      uint64_t v37 = *v1 + 16 * v36;
      uint64_t v38 = *(void *)(v37 - 8);
      uint64_t v3 = (void *)(v37 - 8);
      uint64_t v4 = v38;
    }
    while (v38);
  }
}

uint64_t sub_1CCD13300(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *(unsigned int *)(a2 + 8);
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if (v4 >= v3)
    {
      if (v3)
      {
        uint64_t v6 = *(void **)a2;
        uint64_t v7 = *(void *)a2 + 16 * v3;
        uint64_t v8 = *(void **)a1;
        do
        {
          void *v8 = *v6;
          v8[1] = v6[1];
          v6 += 2;
          v8 += 2;
        }
        while (v6 != (void *)v7);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v3)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4)
      {
        unsigned int v9 = *(void **)a2;
        uint64_t v10 = *(void *)a2 + 16 * v4;
        uint64_t v11 = *(void **)a1;
        do
        {
          void *v11 = *v9;
          v11[1] = v9[1];
          v9 += 2;
          v11 += 2;
        }
        while (v9 != (void *)v10);
      }
      else
      {
        uint64_t v4 = 0;
      }
      if (v4 != v3) {
        memcpy((void *)(*(void *)a1 + 16 * v4), (const void *)(*(void *)a2 + 16 * v4), *(void *)a2 + 16 * v3 - (*(void *)a2 + 16 * v4));
      }
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
  return a1;
}

void sub_1CCD13410()
{
}

void sub_1CCD13450(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD13488(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
  if (byte_1EBCF07E8)
  {
    sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
    sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
  }
  else
  {
    v5[0] = &unk_1F2617E40;
    v5[1] = a2 + 112;
    atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
    llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  }

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

uint64_t sub_1CCD1354C(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  v26[16] = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass((llvm::PMDataManager *)v5[3], &llvm::DominatorTreeWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t AnalysisPass = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
  }
  if (AnalysisPass) {
    uint64_t v7 = AnalysisPass + 32;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = *v5;
  uint64_t v9 = v5[1];
  if (*v5 == v9)
  {
LABEL_11:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_11;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::PostDominatorTreeWrapperPass::ID);
  v15[0] = a2;
  v15[1] = v7;
  v15[3] = 0;
  v15[4] = 0;
  _OWORD v15[2] = v11 + 32;
  int v16 = 0;
  long long v17 = 0u;
  memset(v18, 0, sizeof(v18));
  unsigned int v19 = v21;
  uint64_t v20 = 0x8000000000;
  v21[128] = v23;
  v21[129] = v23;
  v21[130] = 32;
  int v22 = 0;
  unsigned char v23[32] = 1;
  uint64_t v12 = 179;
  int64x2_t v13 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)&v15[v12] = v13;
    v12 += 2;
  }
  while (v12 != 195);
  v23[49] = v24;
  v23[50] = 0x1000000000;
  v24[16] = v26;
  v24[17] = v26;
  v24[18] = 16;
  int v25 = 0;
  uint64_t v4 = sub_1CCD0E590((uint64_t)v15);
  sub_1CCD10E6C((uint64_t)v15);
  return v4;
}

uint64_t sub_1CCD13740()
{
  char v2 = 1;
  uint64_t v3 = &v2;
  int v1 = 1;
  sub_1CD4D2D28((uint64_t)&unk_1EBCF0768, "adce-remove-control-flow", &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF0768, &dword_1CB82C000);
  char v2 = 0;
  uint64_t v3 = &v2;
  int v1 = 1;
  sub_1CD4D2D28((uint64_t)&unk_1EBCF0828, "adce-remove-loops", &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF0828, &dword_1CB82C000);
}

void sub_1CCD13808(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v2);
  operator new();
}

uint64_t sub_1CCD138B4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF08E8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D378;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF08F0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD13808;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF08F0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t llvm::AlignmentFromAssumptionsPass::processAssumption(llvm::ScalarEvolution **this, llvm::Type ***a2, int a3)
{
  v74[16] = *MEMORY[0x1E4F143B8];
  char v70 = 0;
  uint64_t v71 = 0;
  BOOL v69 = 0;
  uint64_t result = llvm::AlignmentFromAssumptionsPass::extractAlignmentInfo(this, a2, a3, &v71, &v70, (llvm::detail::IEEEFloat ***)&v69);
  if (!result) {
    return result;
  }
  uint64_t v7 = v71;
  if (*((unsigned __int8 *)v71 + 16) - 11 < 0xA) {
    return 0;
  }
  uint64_t v8 = *((void *)*this + 13);
  unsigned int v9 = *((_DWORD *)*this + 30);
  if (v9)
  {
    unsigned int v10 = (v9 - 1) & ((v71 >> 4) ^ (v71 >> 9));
    uint64_t v11 = v8 + 48 * v10;
    uint64_t v12 = *(llvm::Value **)(v11 + 24);
    if (v12 == v71) {
      goto LABEL_11;
    }
    int v13 = 1;
    while (v12 != (llvm::Value *)-4096)
    {
      unsigned int v14 = v10 + v13++;
      unsigned int v10 = v14 & (v9 - 1);
      uint64_t v11 = v8 + 48 * v10;
      uint64_t v12 = *(llvm::Value **)(v11 + 24);
      if (v12 == v71) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v11 = v8 + 48 * v9;
LABEL_11:
  if (v11 == v8 + 48 * v9 || (SCEVIter = *(const llvm::APInt **)(v11 + 40)) == 0) {
    SCEVIter = (const llvm::APInt *)llvm::ScalarEvolution::createSCEVIter(*this, (unint64_t)v71);
  }
  uint64_t v64 = v68;
  uint64_t v65 = v68;
  uint64_t v66 = 32;
  int v67 = 0;
  uint64_t v72 = v74;
  uint64_t v73 = 0x1000000000;
  uint64_t v16 = *((void *)v7 + 1);
  if (v16)
  {
    unsigned int v17 = 0;
    do
    {
      uint64_t v18 = *(unsigned __int8 **)(v16 + 24);
      if (v18 != (unsigned __int8 *)a2 && v18 && v18[16] >= 0x1Cu)
      {
        if (v17 >= HIDWORD(v73)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v72[v17] = v18;
        unsigned int v17 = v73 + 1;
        LODWORD(v73) = v73 + 1;
      }
      uint64_t v16 = *(void *)(v16 + 8);
    }
    while (v16);
    if (v17)
    {
      uint64_t v20 = v70;
      unsigned int v21 = v69;
      do
      {
        uint64_t v22 = v72[v17 - 1];
        LODWORD(v73) = v17 - 1;
        int v23 = *(unsigned __int8 *)(v22 + 16);
        if (v22 && v23 == 60 || v22 && v23 == 61)
        {
          if (llvm::isValidAssumeForContext((llvm *)a2, (const llvm::Instruction *)v22, this[1], v6))
          {
            unsigned __int8 v24 = sub_1CCD13FC4(SCEVIter, v20, (uint64_t)v21, *(llvm::Value **)(v22 - 32), *this);
            unint64_t v25 = *(unsigned __int16 *)(v22 + 18);
            if ((__clz(1 << (v25 >> 1)) ^ 0x3F) < v24) {
              *(_WORD *)(v22 + 18) = v25 & 0xFF81 | (2 * v24);
            }
            goto LABEL_56;
          }
        }
        else
        {
          if (!sub_1CBFB3AB0(v22)) {
            goto LABEL_56;
          }
          if (llvm::isValidAssumeForContext((llvm *)a2, (const llvm::Instruction *)v22, this[1], v6))
          {
            BOOL v26 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v22 - 32 * (*(_DWORD *)(v22 + 20) & 0x7FFFFFF)));
            unsigned __int8 v27 = sub_1CCD13FC4(SCEVIter, v20, (uint64_t)v21, v26, *this);
            uint64_t v28 = *(void *)(v22 + 64);
            if (v28 && *(_DWORD *)(v28 + 8) >= 3u)
            {
              uint64_t v29 = *(llvm::AttributeSetNode **)(v28 + 56);
              if (v29) {
                LOBYTE(v29) = llvm::AttributeSetNode::getAlignment(v29);
              }
            }
            else
            {
              LOBYTE(v29) = 0;
            }
            if (v29 < v27) {
              sub_1CC27C328(v22, v27);
            }
            unsigned int v30 = *(_DWORD *)(*(void *)(v22 - 32) + 36) - 194;
            if (v30 <= 3 && v30 != 1)
            {
              BOOL v32 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v22
                                                                   - 32 * (*(_DWORD *)(v22 + 20) & 0x7FFFFFF)
                                                                   + 32));
              unsigned __int8 v33 = sub_1CCD13FC4(SCEVIter, v20, (uint64_t)v21, v32, *this);
              uint64_t v34 = *(void *)(v22 + 64);
              if (v34 && *(_DWORD *)(v34 + 8) >= 4u)
              {
                uint64_t v35 = *(llvm::AttributeSetNode **)(v34 + 64);
                if (v35) {
                  LOBYTE(v35) = llvm::AttributeSetNode::getAlignment(v35);
                }
              }
              else
              {
                LOBYTE(v35) = 0;
              }
              if (v35 < v33) {
                sub_1CC27C3B8(v22, v33);
              }
            }
LABEL_56:
            unsigned int v36 = v65;
            uint64_t v37 = HIDWORD(v66);
            if (v65 == v64)
            {
              if (HIDWORD(v66))
              {
                uint64_t v38 = 0;
                uint64_t v39 = 8 * HIDWORD(v66);
                long long v40 = (uint64_t *)v65;
                while (*v40 != v22)
                {
                  if (*v40 == -2) {
                    uint64_t v38 = v40;
                  }
                  ++v40;
                  v39 -= 8;
                  if (!v39)
                  {
                    if (!v38) {
                      goto LABEL_64;
                    }
                    *uint64_t v38 = v22;
                    --v67;
                    goto LABEL_88;
                  }
                }
                goto LABEL_88;
              }
LABEL_64:
              unsigned int v41 = v66;
              if (HIDWORD(v66) < v66)
              {
                ++HIDWORD(v66);
                *(void *)&v65[8 * v37] = v22;
LABEL_88:
                while (1)
                {
                  uint64_t v22 = *(void *)(v22 + 8);
                  if (!v22) {
                    goto LABEL_122;
                  }
                  uint64_t v51 = *(void *)(v22 + 24);
                  unsigned int v52 = v64;
                  if (v65 == v64)
                  {
                    int v53 = HIDWORD(v66);
                    int v54 = &v65[8 * HIDWORD(v66)];
                    if (HIDWORD(v66))
                    {
                      uint64_t v55 = 0;
                      while (*(void *)&v65[v55] != v51)
                      {
                        v55 += 8;
                        if (8 * HIDWORD(v66) == v55) {
                          goto LABEL_108;
                        }
                      }
                      int v54 = &v65[v55];
                    }
LABEL_108:
                    unsigned int v52 = v65;
                  }
                  else
                  {
                    int v56 = v66 - 1;
                    unsigned int v57 = (v66 - 1) & ((v51 >> 4) ^ (v51 >> 9));
                    int v54 = &v65[8 * v57];
                    uint64_t v58 = *(void *)v54;
                    if (*(void *)v54 == -1)
                    {
                      BOOL v59 = 0;
LABEL_116:
                      if (v59) {
                        int v54 = v59;
                      }
                      int v53 = HIDWORD(v66);
                      if (*(void *)v54 != v51) {
                        int v54 = &v65[8 * v66];
                      }
                    }
                    else
                    {
                      BOOL v59 = 0;
                      int v60 = 1;
                      while (v58 != v51)
                      {
                        if (v59) {
                          BOOL v61 = 0;
                        }
                        else {
                          BOOL v61 = v58 == -2;
                        }
                        if (v61) {
                          BOOL v59 = v54;
                        }
                        unsigned int v62 = v57 + v60++;
                        unsigned int v57 = v62 & v56;
                        int v54 = &v65[8 * (v62 & v56)];
                        uint64_t v58 = *(void *)v54;
                        if (*(void *)v54 == -1) {
                          goto LABEL_116;
                        }
                      }
                      int v53 = HIDWORD(v66);
                    }
                  }
                  if (v65 == v52) {
                    int v63 = v53;
                  }
                  else {
                    int v63 = v66;
                  }
                  if (v54 == &v65[8 * v63])
                  {
                    if (v73 >= (unint64_t)HIDWORD(v73)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    v72[v73] = v51;
                    LODWORD(v73) = v73 + 1;
                  }
                }
              }
            }
            else
            {
              unsigned int v41 = v66;
            }
            if (3 * v41 <= 4 * (HIDWORD(v66) - v67))
            {
              if (v41 >= 0x40) {
                v41 *= 2;
              }
              else {
                unsigned int v41 = 128;
              }
            }
            else if (v41 - HIDWORD(v66) >= v41 >> 3)
            {
              goto LABEL_69;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v64, v41);
            unsigned int v41 = v66;
            unsigned int v36 = v65;
LABEL_69:
            unsigned int v42 = v41 - 1;
            unsigned int v43 = (v41 - 1) & ((v22 >> 4) ^ (v22 >> 9));
            uint64_t v44 = &v36[8 * v43];
            uint64_t v45 = *(void *)v44;
            if (*(void *)v44 == -1)
            {
              unsigned int v46 = 0;
LABEL_81:
              if (v46) {
                int v50 = v46;
              }
              else {
                int v50 = (uint64_t *)v44;
              }
              if (*v50 != v22)
              {
                if (*v50 == -2) {
                  --v67;
                }
                else {
                  ++HIDWORD(v66);
                }
                uint64_t *v50 = v22;
              }
            }
            else
            {
              unsigned int v46 = 0;
              int v47 = 1;
              while (v45 != v22)
              {
                if (v46) {
                  BOOL v48 = 0;
                }
                else {
                  BOOL v48 = v45 == -2;
                }
                if (v48) {
                  unsigned int v46 = (uint64_t *)v44;
                }
                unsigned int v49 = v43 + v47++;
                unsigned int v43 = v49 & v42;
                uint64_t v44 = &v36[8 * (v49 & v42)];
                uint64_t v45 = *(void *)v44;
                if (*(void *)v44 == -1) {
                  goto LABEL_81;
                }
              }
            }
            goto LABEL_88;
          }
        }
LABEL_122:
        unsigned int v17 = v73;
      }
      while (v73);
    }
  }
  if (v72 != v74) {
    free(v72);
  }
  if (v65 != v64) {
    free(v65);
  }
  return 1;
}

uint64_t sub_1CCD13FC4(const llvm::APInt *a1, llvm::SCEV *a2, uint64_t a3, llvm::Value *a4, llvm::ScalarEvolution *this)
{
  v42[3] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *((void *)this + 13);
  unsigned int v10 = *((_DWORD *)this + 30);
  if (!v10)
  {
LABEL_7:
    uint64_t v12 = v9 + 48 * v10;
    goto LABEL_8;
  }
  unsigned int v11 = (v10 - 1) & ((a4 >> 4) ^ (a4 >> 9));
  uint64_t v12 = v9 + 48 * v11;
  int v13 = *(llvm::Value **)(v12 + 24);
  if (v13 != a4)
  {
    int v14 = 1;
    while (v13 != (llvm::Value *)-4096)
    {
      unsigned int v15 = v11 + v14++;
      unsigned int v11 = v15 & (v10 - 1);
      uint64_t v12 = v9 + 48 * v11;
      int v13 = *(llvm::Value **)(v12 + 24);
      if (v13 == a4) {
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  if (v12 == v9 + 48 * v10 || (SCEVIter = *(llvm::detail::IEEEFloat ***)(v12 + 40)) == 0) {
    SCEVIter = (llvm::detail::IEEEFloat **)llvm::ScalarEvolution::createSCEVIter(this, (unint64_t)a4);
  }
  unsigned int v17 = a1;
  while (2)
  {
    switch(*((_WORD *)v17 + 12))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        unsigned int v19 = (llvm::Type **)((char *)v17 + 40);
        goto LABEL_19;
      case 4:
        unsigned int v19 = (llvm::Type **)((char *)v17 + 48);
        goto LABEL_19;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        uint64_t v18 = (const llvm::APInt **)*((void *)v17 + 4);
        goto LABEL_14;
      case 6:
        uint64_t v18 = (const llvm::APInt **)((char *)v17 + 40);
LABEL_14:
        unsigned int v17 = *v18;
        continue;
      case 0xE:
        unsigned int v19 = (llvm::Type **)*((void *)v17 - 1);
        goto LABEL_19;
      default:
        unsigned int v19 = (llvm::Type **)*((void *)v17 + 4);
LABEL_19:
        uint64_t v20 = *v19;
        if (*((unsigned char *)*v19 + 8) != 13)
        {
          llvm::DataLayout::getIndexType((llvm::DataLayout *)(*(void *)(*(void *)this + 40) + 272), v20);
          uint64_t v20 = v35;
        }
        TruncateOrZeroExtend = llvm::ScalarEvolution::getTruncateOrZeroExtend(this, SCEVIter, v20, 0);
        unint64_t MinusSCEV = llvm::ScalarEvolution::getMinusSCEV(this, (llvm::SCEV *)TruncateOrZeroExtend, a1, 0, 0);
        uint64_t result = 0;
        if (*(_WORD *)(MinusSCEV + 24) != 15)
        {
          uint64_t v24 = a3;
          while (2)
          {
            switch(*(_WORD *)(v24 + 24))
            {
              case 1:
              case 2:
              case 3:
              case 0xD:
                BOOL v26 = (llvm::Type **)(v24 + 40);
                goto LABEL_30;
              case 4:
                BOOL v26 = (llvm::Type **)(v24 + 48);
                goto LABEL_30;
              case 5:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xC:
                unint64_t v25 = *(uint64_t **)(v24 + 32);
                goto LABEL_25;
              case 6:
                unint64_t v25 = (uint64_t *)(v24 + 40);
LABEL_25:
                uint64_t v24 = *v25;
                continue;
              case 0xE:
                BOOL v26 = *(llvm::Type ***)(v24 - 8);
                goto LABEL_30;
              default:
                BOOL v26 = *(llvm::Type ***)(v24 + 32);
LABEL_30:
                NoopOrSignExtend = llvm::ScalarEvolution::getNoopOrSignExtend(this, (llvm::detail::IEEEFloat **)MinusSCEV, *v26);
                long long v40 = v42;
                v42[0] = NoopOrSignExtend;
                v42[1] = a3;
                uint64_t v41 = 0x200000002;
                uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr((uint64_t)this, (unint64_t **)&v40, 0, 0);
                if (v40 != v42) {
                  free(v40);
                }
                uint64_t result = sub_1CCD14978((llvm::SCEV *)AddExpr, a2, this);
                if ((unsigned __int16)result <= 0xFFu)
                {
                  uint64_t result = 0;
                  if (AddExpr)
                  {
                    if (*(_WORD *)(AddExpr + 24) == 7)
                    {
                      unsigned int v30 = *(llvm::SCEV ***)(AddExpr + 32);
                      uint64_t v29 = *(void *)(AddExpr + 40);
                      unsigned int v31 = *v30;
                      if (v29 == 2)
                      {
                        BOOL v32 = v30[1];
                      }
                      else
                      {
                        uint64_t v39 = *(void *)(AddExpr + 32);
                        long long v40 = v42;
                        uint64_t v41 = 0x300000000;
                        uint64_t v36 = v29;
                        size_t v37 = 8 * v29 - 8;
                        if (v37 >= 0x19) {
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        int v38 = 0;
                        if (v36 != 1)
                        {
                          memcpy(v40, (const void *)(v39 + 8), v37);
                          int v38 = v41;
                        }
                        LODWORD(v41) = v38 + (v37 >> 3);
                        BOOL v32 = (llvm::SCEV *)sub_1CD478318(this, (uint64_t)&v40, *(const llvm::Loop **)(AddExpr + 48), 0);
                        if (v40 != v42) {
                          free(v40);
                        }
                      }
                      unsigned int v33 = sub_1CCD14978(v31, a2, this);
                      unsigned int v34 = sub_1CCD14978(v32, a2, this);
                      uint64_t result = 0;
                      if ((unsigned __int16)v33 >= 0x100u && (unsigned __int16)v34 >= 0x100u)
                      {
                        if (v33 <= v34) {
                          uint64_t result = v33;
                        }
                        else {
                          uint64_t result = v34;
                        }
                      }
                    }
                  }
                }
                break;
            }
            break;
          }
        }
        return result;
    }
  }
}

uint64_t llvm::AlignmentFromAssumptionsPass::runImpl(llvm::AlignmentFromAssumptionsPass *this, llvm::Function *a2, llvm::AssumptionCache *a3, llvm::ScalarEvolution *a4, llvm::DominatorTree *a5)
{
  *(void *)this = a4;
  *((void *)this + 1) = a5;
  if (!*((unsigned char *)a3 + 184)) {
    llvm::AssumptionCache::scanFunction(a3);
  }
  uint64_t v7 = *((unsigned int *)a3 + 6);
  if (v7)
  {
    int v8 = 0;
    uint64_t v10 = *((void *)a3 + 2);
    uint64_t v11 = v10 + 32 * v7;
    do
    {
      uint64_t v12 = *(_DWORD **)(v10 + 16);
      if (v12)
      {
        for (unsigned int i = 0; ; ++i)
        {
          if ((v12[5] & 0x80000000) != 0)
          {
            uint64_t v27 = v11;
            uint64_t v23 = v10;
            int v25 = v8;
            unsigned int v20 = i;
            uint64_t v16 = v12;
            Descriptor = llvm::User::getDescriptor((llvm::User *)v12);
            uint64_t v12 = v16;
            if ((v16[5] & 0x80000000) != 0)
            {
              unsigned int v17 = llvm::User::getDescriptor((llvm::User *)v16);
              uint64_t v12 = v16;
              unsigned int v15 = &v17[v18];
            }
            else
            {
              unsigned int v15 = 0;
            }
            unsigned int i = v20;
            int v14 = Descriptor;
            uint64_t v10 = v23;
            int v8 = v25;
            uint64_t v11 = v27;
          }
          else
          {
            int v14 = 0;
            unsigned int v15 = 0;
          }
          if (i >= ((unint64_t)(v15 - v14) >> 4)) {
            break;
          }
          uint64_t v22 = v12;
          int v26 = v8;
          uint64_t v24 = v10;
          uint64_t v28 = v11;
          int v19 = llvm::AlignmentFromAssumptionsPass::processAssumption((llvm::ScalarEvolution **)this, (llvm::Type ***)v12, i);
          uint64_t v11 = v28;
          uint64_t v12 = v22;
          uint64_t v10 = v24;
          int v8 = v26 | v19;
        }
      }
      v10 += 32;
    }
    while (v10 != v11);
  }
  else
  {
    LOBYTE(v8) = 0;
  }
  return v8 & 1;
}

void llvm::AlignmentFromAssumptionsPass::run()
{
}

void sub_1CCD14648()
{
}

void sub_1CCD14688(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD146C0(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::ScalarEvolutionWrapperPass::ID);
}

uint64_t sub_1CCD147C8(void *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::AssumptionCacheTracker::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::AssumptionCacheTracker::ID);
  AssumptionCache = (llvm::AssumptionCache *)llvm::AssumptionCacheTracker::getAssumptionCache(v9, (llvm::Function *)a2);
  uint64_t v11 = (uint64_t *)a1[1];
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_11:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::ScalarEvolutionWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_11;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  unsigned int v15 = *(llvm::ScalarEvolution **)((*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  uint64_t v16 = (uint64_t *)a1[1];
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  if (v17 == v18)
  {
LABEL_16:
    uint64_t v19 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v17 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v17 += 16;
      if (v17 == v18) {
        goto LABEL_16;
      }
    }
    uint64_t v19 = *(void *)(v17 + 8);
  }
  unsigned int v21 = (llvm::DominatorTree *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 96))(v19, &llvm::DominatorTreeWrapperPass::ID)+ 32);

  return llvm::AlignmentFromAssumptionsPass::runImpl((llvm::AlignmentFromAssumptionsPass *)(a1 + 4), v20, AssumptionCache, v15, v21);
}

uint64_t sub_1CCD14978(llvm::SCEV *a1, llvm::SCEV *a2, llvm::ScalarEvolution *this)
{
  uint64_t URemExpr = llvm::ScalarEvolution::getURemExpr(this, a1, a2);
  int v5 = 0;
  if (URemExpr)
  {
    int v6 = 0;
    if (!*(_WORD *)(URemExpr + 24))
    {
      uint64_t v7 = *(void *)(URemExpr + 32);
      unsigned int v8 = *(_DWORD *)(v7 + 32);
      if (v8 > 0x40)
      {
        int64_t v9 = **(void **)(v7 + 24);
        if (v9) {
          goto LABEL_5;
        }
      }
      else
      {
        int64_t v9 = (uint64_t)(*(void *)(v7 + 24) << -(char)v8) >> -(char)v8;
        if (v9)
        {
LABEL_5:
          if (v9 < 0) {
            int64_t v9 = -v9;
          }
          if ((v9 & (v9 - 1)) != 0)
          {
            int v5 = 0;
            int v6 = 0;
            return v5 | (v6 << 8);
          }
          int v5 = __clz(v9) ^ 0x3F;
          goto LABEL_16;
        }
      }
      uint64_t v10 = *((void *)a2 + 4);
      uint64_t v11 = (unint64_t *)(v10 + 24);
      if (*(_DWORD *)(v10 + 32) >= 0x41u) {
        uint64_t v11 = (unint64_t *)*v11;
      }
      unint64_t v12 = *v11;
      int v13 = __clz(v12) ^ 0x3F;
      if (v12) {
        int v5 = v13;
      }
      else {
        int v5 = 0;
      }
LABEL_16:
      int v6 = 1;
    }
  }
  else
  {
    int v6 = 0;
  }
  return v5 | (v6 << 8);
}

void sub_1CCD14A54(uint64_t a1)
{
}

uint64_t sub_1CCD14AF0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF08F8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D418;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF0900, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD14A54;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF0900, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::AnnotationRemarksPass::run()
{
}

uint64_t sub_1CCD14C20(uint64_t ***a1, const char *a2)
{
  v139[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = ***a1;
  if (!*(void *)(v3 + 128))
  {
    uint64_t result = sub_1CC421DEC(*(void *)(v3 + 72), (uint64_t)"annotation-remarks", 18);
    if (!result) {
      return result;
    }
  }
  uint64_t v120 = 0;
  uint64_t v121 = 0;
  unsigned int v122 = 0;
  llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(v118, (const llvm::Function *)a1);
  int v6 = (char *)(a1 + 9);
  v113[0] = 0;
  v113[1] = 0;
  int v114 = 0;
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  uint64_t v115 = 0;
  for (unsigned int i = a1[10]; ; unsigned int i = (uint64_t **)i[1])
  {
    if (i == (uint64_t **)v6) {
      goto LABEL_78;
    }
    unsigned int v8 = i - 3;
    if (!i) {
      unsigned int v8 = 0;
    }
    int64_t v9 = v8[6];
    if (v9 != (uint64_t *)(v8 + 5)) {
      break;
    }
  }
  uint64_t v10 = (char *)v139;
  while (1)
  {
    if (v9) {
      uint64_t v11 = (uint64_t ***)(v9 - 3);
    }
    else {
      uint64_t v11 = 0;
    }
    if ((*((unsigned char *)v11 + 23) & 0x20) == 0) {
      goto LABEL_30;
    }
    uint64_t v12 = ***v11;
    *(void *)&long long v123 = v11;
    int v13 = *(_DWORD *)(v12 + 2496);
    unsigned int v14 = v11 >> 4;
    if (!v13)
    {
      uint64_t v29 = 0;
LABEL_42:
      uint64_t v18 = sub_1CC609054(v12 + 2480, (uint64_t)&v123, (uint64_t *)&v123, v29);
      uint64_t v30 = v123;
      v18[4] = 0;
      v18[3] = 0;
      void *v18 = v30;
      v18[1] = v18 + 3;
      v18[2] = 0x100000000;
      goto LABEL_24;
    }
    uint64_t v15 = *(void *)(v12 + 2480);
    int v16 = v13 - 1;
    unsigned int v17 = v16 & (v14 ^ (v11 >> 9));
    uint64_t v18 = (void *)(v15 + 40 * v17);
    uint64_t v19 = (void ***)*v18;
    if ((uint64_t ***)*v18 != v11)
    {
      unsigned int v20 = 0;
      int v21 = 1;
      while (v19 != (void ***)-4096)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == (void ***)-8192;
        }
        if (v22) {
          unsigned int v20 = v18;
        }
        unsigned int v23 = v17 + v21++;
        unsigned int v17 = v23 & v16;
        uint64_t v18 = (void *)(v15 + 40 * v17);
        uint64_t v19 = (void ***)*v18;
        if ((uint64_t ***)*v18 == v11) {
          goto LABEL_24;
        }
      }
      if (v20) {
        uint64_t v29 = v20;
      }
      else {
        uint64_t v29 = v18;
      }
      goto LABEL_42;
    }
LABEL_24:
    uint64_t v24 = *((unsigned int *)v18 + 4);
    if (v24)
    {
      int v25 = (void *)(v18[1] + 8);
      uint64_t v26 = 16 * v24;
      while (*((_DWORD *)v25 - 2) != 30)
      {
        v25 += 2;
        v26 -= 16;
        if (!v26) {
          goto LABEL_30;
        }
      }
      if (*v25)
      {
        unsigned int v31 = v11[6];
        uint64_t v137 = v10;
        uint64_t v138 = 0x400000000;
        *(void *)&long long v123 = v31;
        *((void *)&v123 + 1) = &v125;
        uint64_t v124 = 0x400000000;
        sub_1CD75DCD4((uint64_t)v112, (uint64_t)&v120, (uint64_t *)&v123, (uint64_t)&v123 + 8);
        if (*((uint64_t **)&v123 + 1) != &v125) {
          free(*((void **)&v123 + 1));
        }
        unsigned int v101 = v10;
        if (v137 != v10) {
          free(v137);
        }
        uint64_t v32 = v112[0];
        unint64_t v33 = *(unsigned int *)(v112[0] + 16);
        if (v33 >= *(unsigned int *)(v112[0] + 20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v112[0] + 8) + 8 * v33) = v11;
        ++*(_DWORD *)(v32 + 16);
        if ((*((unsigned char *)v11 + 23) & 0x20) == 0) {
          goto LABEL_64;
        }
        uint64_t v34 = ***v11;
        *(void *)&long long v123 = v11;
        int v35 = *(_DWORD *)(v34 + 2496);
        if (!v35)
        {
          int v54 = 0;
          goto LABEL_74;
        }
        uint64_t v36 = *(void *)(v34 + 2480);
        int v37 = v35 - 1;
        unsigned int v38 = v37 & (v14 ^ (v11 >> 9));
        uint64_t v39 = (void *)(v36 + 40 * v38);
        long long v40 = (void ***)*v39;
        if ((uint64_t ***)*v39 != v11)
        {
          uint64_t v41 = 0;
          int v42 = 1;
          while (v40 != (void ***)-4096)
          {
            if (v41) {
              BOOL v43 = 0;
            }
            else {
              BOOL v43 = v40 == (void ***)-8192;
            }
            if (v43) {
              uint64_t v41 = v39;
            }
            unsigned int v44 = v38 + v42++;
            unsigned int v38 = v44 & v37;
            uint64_t v39 = (void *)(v36 + 40 * v38);
            long long v40 = (void ***)*v39;
            if ((uint64_t ***)*v39 == v11) {
              goto LABEL_59;
            }
          }
          if (v41) {
            int v54 = v41;
          }
          else {
            int v54 = v39;
          }
LABEL_74:
          uint64_t v39 = sub_1CC609054(v34 + 2480, (uint64_t)&v123, (uint64_t *)&v123, v54);
          uint64_t v55 = v123;
          v39[4] = 0;
          v39[3] = 0;
          void *v39 = v55;
          v39[1] = v39 + 3;
          v39[2] = 0x100000000;
        }
LABEL_59:
        uint64_t v45 = *((unsigned int *)v39 + 4);
        if (v45)
        {
          unsigned int v46 = (void *)(v39[1] + 8);
          uint64_t v47 = 16 * v45;
          while (*((_DWORD *)v46 - 2) != 30)
          {
            uint64_t v48 = 0;
            v46 += 2;
            v47 -= 16;
            if (!v47) {
              goto LABEL_65;
            }
          }
          uint64_t v48 = *v46;
        }
        else
        {
LABEL_64:
          uint64_t v48 = 0;
        }
LABEL_65:
        uint64_t v49 = *(unsigned int *)(v48 + 8);
        if (v49)
        {
          uint64_t v50 = -8 * v49;
          do
          {
            uint64_t v51 = *(uint64_t **)(*(void *)(v48 + v50) + 8);
            uint64_t v52 = *v51;
            *(void *)&long long v123 = v51 + 3;
            *((void *)&v123 + 1) = v52;
            LODWORD(v124) = 0;
            uint64_t v53 = sub_1CD75A1E0(v113, &v123, &v124);
            ++*(_DWORD *)(v53 + 16);
            v50 += 8;
          }
          while (v50);
        }
        uint64_t v10 = v101;
      }
    }
LABEL_30:
    int64_t v9 = (uint64_t *)v9[1];
    uint64_t v27 = i - 3;
    if (!i) {
      uint64_t v27 = 0;
    }
    if (v9 == (uint64_t *)(v27 + 5)) {
      break;
    }
LABEL_37:
    if (i == (uint64_t **)v6) {
      goto LABEL_77;
    }
  }
  while (1)
  {
    unsigned int i = (uint64_t **)i[1];
    if (i == (uint64_t **)v6) {
      break;
    }
    uint64_t v28 = i - 3;
    if (!i) {
      uint64_t v28 = 0;
    }
    int64_t v9 = v28[6];
    if (v9 != (uint64_t *)(v28 + 5)) {
      goto LABEL_37;
    }
  }
LABEL_77:
  uint64_t v56 = v115;
  uint64_t v57 = v116;
  if (v115 != v116)
  {
    unsigned int v62 = (a1 >> 4) ^ (a1 >> 9);
    do
    {
      if ((*((unsigned char *)a1 + 23) & 0x20) == 0)
      {
LABEL_102:
        LODWORD(v77) = 0;
        goto LABEL_103;
      }
      uint64_t v63 = ***a1;
      uint64_t v137 = (char *)a1;
      int v64 = *(_DWORD *)(v63 + 2496);
      if (v64)
      {
        uint64_t v65 = *(void *)(v63 + 2480);
        int v66 = v64 - 1;
        unsigned int v67 = v66 & v62;
        unsigned int v68 = (llvm::Function **)(v65 + 40 * (v66 & v62));
        BOOL v69 = *v68;
        if (*v68 == (llvm::Function *)a1) {
          goto LABEL_97;
        }
        char v70 = 0;
        int v71 = 1;
        while (v69 != (llvm::Function *)-4096)
        {
          if (v70) {
            BOOL v72 = 0;
          }
          else {
            BOOL v72 = v69 == (llvm::Function *)-8192;
          }
          if (v72) {
            char v70 = v68;
          }
          unsigned int v73 = v67 + v71++;
          unsigned int v67 = v73 & v66;
          unsigned int v68 = (llvm::Function **)(v65 + 40 * v67);
          BOOL v69 = *v68;
          if (*v68 == (llvm::Function *)a1) {
            goto LABEL_97;
          }
        }
        if (v70) {
          uint64_t v87 = v70;
        }
        else {
          uint64_t v87 = v68;
        }
      }
      else
      {
        uint64_t v87 = 0;
      }
      unsigned int v68 = (llvm::Function **)sub_1CC609054(v63 + 2480, (uint64_t)&v137, (uint64_t *)&v137, v87);
      int v88 = v137;
      v68[4] = 0;
      v68[3] = 0;
      *unsigned int v68 = (llvm::Function *)v88;
      v68[1] = (llvm::Function *)(v68 + 3);
      v68[2] = (llvm::Function *)0x100000000;
LABEL_97:
      uint64_t v74 = *((unsigned int *)v68 + 4);
      if (!v74) {
        goto LABEL_102;
      }
      int v75 = (void *)((char *)v68[1] + 8);
      uint64_t v76 = 16 * v74;
      while (*((_DWORD *)v75 - 2))
      {
        LODWORD(v77) = 0;
        uint64_t v78 = 0;
        v75 += 2;
        v76 -= 16;
        if (!v76) {
          goto LABEL_104;
        }
      }
      uint64_t v77 = *v75;
      if (*v75)
      {
        uint64_t v78 = *v75;
        if (*(unsigned char *)v77 != 15) {
          uint64_t v78 = *(void *)(v77 - 8 * *(unsigned int *)(v77 + 8));
        }
        LODWORD(v77) = *(_DWORD *)(v77 + 28);
        goto LABEL_104;
      }
LABEL_103:
      uint64_t v78 = 0;
LABEL_104:
      uint64_t v79 = a1[10];
      if (v79) {
        unsigned int v80 = v79 - 3;
      }
      else {
        unsigned int v80 = 0;
      }
      uint64_t v81 = (uint64_t)v80[7];
      DWORD2(v123) = 11;
      BYTE12(v123) = 2;
      uint64_t v124 = v81;
      uint64_t v125 = v78;
      uint64_t v126 = v77;
      uint64_t v127 = "annotation-remarks";
      uint64_t v128 = "AnnotationSummary";
      uint64_t v129 = 17;
      char v130 = 0;
      char v131 = 0;
      uint64_t v132 = v134;
      uint64_t v133 = 0x400000000;
      v134[256] = 0;
      int v135 = -1;
      uint64_t v136 = v80;
      *(void *)&long long v123 = &unk_1F26165E0;
      uint64_t v137 = "Annotated ";
      uint64_t v138 = 10;
      sub_1CC59ADEC((uint64_t *)&v132, (uint64_t)&v137);
      llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v109, "count", 5uLL, *(_DWORD *)(v56 + 16));
      uint64_t v82 = sub_1CD3D6290((uint64_t)&v123, (long long *)&v109);
      uint64_t v137 = " instructions with ";
      uint64_t v138 = 19;
      sub_1CC59ADEC((uint64_t *)(v82 + 80), (uint64_t)&v137);
      llvm::DiagnosticInfoOptimizationBase::Argument::Argument(__dst, "type", 4uLL, *(void **)v56, *(void *)(v56 + 8));
      unint64_t v83 = (llvm::DiagnosticInfoOptimizationBase *)sub_1CD3D6290(v82, (long long *)__dst);
      llvm::OptimizationRemarkEmitter::emit(v118, v83);
      if (v108 < 0) {
        operator delete(__p);
      }
      if (v106 < 0) {
        operator delete(__dst[0]);
      }
      if (v111 < 0) {
        operator delete(v110);
      }
      if (SHIBYTE(v109.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v109.__r_.__value_.__l.__data_);
      }
      *(void *)&long long v123 = &unk_1F2616800;
      uint64_t v84 = (char *)v132;
      if (v133)
      {
        unint64_t v85 = (unint64_t)v133 << 6;
        do
        {
          int v86 = (void **)&v84[v85];
          if (v84[v85 - 17] < 0) {
            operator delete(*(v86 - 5));
          }
          if (*((char *)v86 - 41) < 0) {
            operator delete(*(v86 - 8));
          }
          v85 -= 64;
        }
        while (v85);
        uint64_t v84 = (char *)v132;
      }
      if (v84 != v134) {
        free(v84);
      }
      v56 += 24;
    }
    while (v56 != v57);
  }
LABEL_78:
  uint64_t v58 = v120 + 56 * v122;
  unsigned int v59 = v122;
  uint64_t v60 = v58;
  if (v121)
  {
    if (v122)
    {
      uint64_t v61 = 56 * v122;
      uint64_t v60 = v120;
      while ((*(void *)v60 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v60 += 56;
        v61 -= 56;
        if (!v61)
        {
          unsigned int v59 = v122;
          uint64_t v60 = v120 + 56 * v122;
          goto LABEL_137;
        }
      }
      unsigned int v59 = v122;
    }
    else
    {
      unsigned int v59 = 0;
      uint64_t v60 = v120;
    }
  }
LABEL_137:
  uint64_t v102 = v122;
  uint64_t v103 = v120;
  uint64_t v89 = v120 + 56 * v59;
  while (v60 != v89)
  {
    if (*(void *)v60)
    {
      uint64_t v90 = *(unsigned int *)(v60 + 16);
      if (v90)
      {
        uint64_t v91 = *(uint64_t *****)(v60 + 8);
        uint64_t v92 = 8 * v90;
        do
        {
          uint64_t v93 = *v91;
          if (llvm::AutoInitRemark::canHandle(*v91, v5))
          {
            uint64_t v94 = v93[5][7][5] + 272;
            *((void *)&v123 + 1) = v118;
            uint64_t v124 = (uint64_t)"annotation-remarks";
            uint64_t v125 = 18;
            uint64_t v126 = v94;
            uint64_t v127 = a2;
            *(void *)&long long v123 = &unk_1F2648948;
            llvm::MemoryOpRemark::visit((llvm::MemoryOpRemark *)&v123, (llvm::Instruction *)v93);
          }
          ++v91;
          v92 -= 8;
        }
        while (v92);
      }
    }
    uint64_t v95 = v60 + 56;
    uint64_t v60 = v58;
    if (v95 != v58)
    {
      uint64_t v60 = v95;
      while ((*(void *)v60 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v60 += 56;
        if (v60 == v58)
        {
          uint64_t v60 = v58;
          break;
        }
      }
    }
  }
  sub_1CD456CB4(v113);
  uint64_t v96 = v119;
  unint64_t v119 = 0;
  if (v96)
  {
    uint64_t v97 = *v96;
    *uint64_t v96 = 0;
    if (v97) {
      (*(void (**)(uint64_t))(*(void *)v97 + 8))(v97);
    }
    MEMORY[0x1D25D9CE0](v96, 0x20C4093837F09);
  }
  if (v102)
  {
    uint64_t v98 = 56 * v102;
    int v99 = (void *)(v103 + 24);
    do
    {
      if ((*(v99 - 3) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v100 = (void *)*(v99 - 2);
        if (v99 != v100) {
          free(v100);
        }
      }
      v99 += 7;
      v98 -= 56;
    }
    while (v98);
  }
  return MEMORY[0x1D25D9CD0](v103, 8);
}

void sub_1CCD15588()
{
}

void sub_1CCD155C8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD15600(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
}

void sub_1CCD15618(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(char **)v4 != llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v6 + 96))(v6, llvm::TargetLibraryInfoWrapperPass::ID);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v19 = 0;
  uint64_t v8 = v7 + 32;
  if (!*(unsigned char *)(v7 + 232))
  {
    uint64_t v9 = *(void *)(a2 + 40) + 216;
    __int16 v21 = 260;
    v20[0] = v9;
    llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v20);
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    int v33 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    *(void *)&long long v10 = -1;
    *((void *)&v10 + 1) = -1;
    *(_OWORD *)__src = v10;
    long long v25 = v10;
    long long v26 = v10;
    long long v27 = v10;
    long long v28 = v10;
    long long v29 = v10;
    *(_OWORD *)uint64_t v30 = v10;
    *(void *)&v30[13] = -1;
    sub_1CC153974((uint64_t)__src, (int *)__p);
    sub_1CD4D04B8(v8, (uint64_t)__src);
    sub_1CD4CFA4C((uint64_t *)__src);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1CC1569E8(__src, v8);
}

void llvm::BDCEPass::run()
{
}

uint64_t sub_1CCD15A1C(uint64_t a1, llvm::DemandedBits *a2)
{
  v108[128] = *MEMORY[0x1E4F143B8];
  char v106 = v108;
  uint64_t v107 = 0x8000000000;
  uint64_t v2 = a1 + 72;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3 == a1 + 72)
  {
LABEL_6:
    char v7 = 0;
    return v7 & 1;
  }
  while (1)
  {
    uint64_t v5 = v3 - 24;
    if (!v3) {
      uint64_t v5 = 0;
    }
    uint64_t v6 = *(void *)(v5 + 48);
    if (v6 != v5 + 40) {
      break;
    }
    uint64_t v3 = *(void *)(v3 + 8);
    if (v3 == v2) {
      goto LABEL_6;
    }
  }
  char v7 = 0;
  while (1)
  {
    if (v6) {
      uint64_t v8 = v6 - 24;
    }
    else {
      uint64_t v8 = 0;
    }
    if (llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v8) && !*(void *)(v8 + 8)) {
      goto LABEL_109;
    }
    if (llvm::DemandedBits::isInstructionDead(a2, (llvm::Instruction *)v8))
    {
LABEL_14:
      if (v107 >= (unint64_t)HIDWORD(v107)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v106 + v107) = v8;
      LODWORD(v107) = v107 + 1;
      char v7 = 1;
      goto LABEL_109;
    }
    if ((*(_DWORD *)(*(void *)v8 + 8) & 0xFE) == 0x12) {
      int v9 = *(unsigned __int8 *)(**(void **)(*(void *)v8 + 16) + 8);
    }
    else {
      int v9 = *(_DWORD *)(*(void *)v8 + 8);
    }
    if (v9 == 13)
    {
      llvm::DemandedBits::getDemandedBits(a2, (llvm::Instruction *)v8, (llvm::APInt *)&v90);
      if (v91 > 0x40)
      {
        int v10 = 0;
        int64_t v11 = ((unint64_t)v91 + 63) >> 6;
        do
        {
          BOOL v12 = v11-- < 1;
          if (v12) {
            break;
          }
          unint64_t v13 = *((void *)v90 + v11);
          v10 += __clz(v13);
        }
        while (!v13);
        int v14 = v91 | 0xFFFFFFC0;
        if ((v91 & 0x3F) == 0) {
          int v14 = 0;
        }
        if (v10 + v14 != v91)
        {
          if (v90) {
            MEMORY[0x1D25D9CB0](v90, 0x1000C8000313F17);
          }
          goto LABEL_37;
        }
      }
      else if (v90)
      {
        goto LABEL_37;
      }
      int wouldInstructionBeTriviallyDead = llvm::wouldInstructionBeTriviallyDead(v8, 0);
      if (v91 >= 0x41 && v90)
      {
        MEMORY[0x1D25D9CB0](v90, 0x1000C8000313F17);
        if (wouldInstructionBeTriviallyDead) {
          goto LABEL_14;
        }
      }
      else if (wouldInstructionBeTriviallyDead)
      {
        goto LABEL_14;
      }
    }
LABEL_37:
    int v16 = *(unsigned __int8 *)(v8 + 16);
    if (v16 == 68) {
      uint64_t v17 = (llvm::Instruction *)v8;
    }
    else {
      uint64_t v17 = 0;
    }
    if (v6 && v16 == 68)
    {
      llvm::DemandedBits::getDemandedBits(a2, v17, (llvm::APInt *)&v86);
      uint64_t v18 = **((void **)v17 - 4);
      if ((*(_DWORD *)(v18 + 8) & 0xFE) == 0x12) {
        uint64_t v18 = **(void **)(v18 + 16);
      }
      int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v18);
      uint64_t v20 = *(void *)v17;
      __int16 v21 = *(llvm::Type **)v17;
      if ((*(_DWORD *)(*(void *)v17 + 8) & 0xFE) == 0x12) {
        __int16 v21 = **(llvm::Type ***)(v20 + 16);
      }
      int v22 = llvm::Type::getPrimitiveSizeInBits(v21);
      unsigned int v23 = v87;
      if (v87 > 0x40)
      {
        int v25 = 0;
        int64_t v26 = ((unint64_t)v87 + 63) >> 6;
        do
        {
          BOOL v12 = v26-- < 1;
          if (v12) {
            break;
          }
          unint64_t v27 = *(void *)(v86 + 8 * v26);
          v25 += __clz(v27);
        }
        while (!v27);
        unsigned int v28 = v87 | 0xFFFFFFC0;
        if ((v87 & 0x3F) == 0) {
          unsigned int v28 = 0;
        }
        unsigned int v24 = v25 + v28;
      }
      else
      {
        unsigned int v24 = v87 + __clz(v86) - 64;
      }
      unsigned int v29 = v22 - PrimitiveSizeInBits;
      if (v24 < v22 - PrimitiveSizeInBits)
      {
LABEL_81:
        if (v23 >= 0x41 && v86)
        {
          unsigned int v49 = v24;
          MEMORY[0x1D25D9CB0](v86, 0x1000C8000313F17);
          unsigned int v24 = v49;
        }
        if (v24 >= v29) {
          goto LABEL_109;
        }
        goto LABEL_85;
      }
      unsigned int v83 = v24;
      sub_1CCD16504(*((void *)v17 + 1), a2);
      uint64_t v30 = 0;
      uint64_t v31 = **(void **)v17;
      uint64_t v90 = v92;
      uint64_t v91 = 0x200000000;
      uint64_t v95 = v31;
      uint64_t v96 = &v104;
      uint64_t v97 = &v105;
      uint64_t v98 = 0;
      int v99 = 0;
      __int16 v100 = 512;
      char v101 = 7;
      uint64_t v93 = 0;
      uint64_t v94 = 0;
      uint64_t v102 = 0;
      uint64_t v103 = 0;
      long long v104 = &unk_1F2616E88;
      unsigned int v105 = &unk_1F2617008;
      uint64_t v93 = (void **)*((void *)v17 + 5);
      uint64_t v94 = (void ***)((char *)v17 + 24);
      uint64_t v32 = (unsigned __int8 *)*((void *)v17 + 6);
      v84[0] = v32;
      if (v32)
      {
        llvm::MetadataTracking::track((uint64_t)v84, v32, 2);
        uint64_t v30 = v84[0];
      }
      sub_1CB8461A4((uint64_t)&v90, 0, v30);
      if (!v84[0])
      {
LABEL_58:
        int v33 = (unsigned __int8 *)*((void *)v17 - 4);
        if ((*((unsigned char *)v17 + 23) & 0x10) == 0)
        {
          uint64_t v43 = 0;
          unsigned int v44 = &byte_1CFBCE98E;
          goto LABEL_67;
        }
        uint64_t v34 = ***(void ***)v17;
        uint64_t v35 = *(void *)(v34 + 152);
        uint64_t v36 = *(unsigned int *)(v34 + 168);
        if (v36)
        {
          LODWORD(v37) = (v36 - 1) & ((v17 >> 4) ^ (v17 >> 9));
          unsigned int v38 = (llvm::Instruction **)(v35 + 16 * v37);
          uint64_t v39 = *v38;
          if (*v38 == v17)
          {
LABEL_66:
            int v42 = v38[1];
            uint64_t v45 = *(void *)v42;
            unsigned int v44 = (char *)v42 + 16;
            uint64_t v43 = v45;
LABEL_67:
            __int16 v85 = 261;
            v84[0] = v44;
            v84[1] = v43;
            if (*(void *)v33 != v20)
            {
              if (v33[16] <= 0x14u)
              {
                int v33 = (unsigned __int8 *)(*((uint64_t (**)(void **, uint64_t, unsigned __int8 *, uint64_t))*v96
                                          + 28))(v96, 39, v33, v20);
                if (v33) {
                  BOOL v48 = v33[16] >= 0x1Cu;
                }
                else {
                  BOOL v48 = 0;
                }
                if (v48)
                {
                  (*((void (**)(void **, unsigned __int8 *, void *, void **, void ***))*v97 + 2))(v97, v33, v84, v93, v94);
                  if (v91)
                  {
                    char v70 = (llvm::MDNode **)v90;
                    int v71 = (llvm::MDNode **)((char *)v90 + 16 * v91);
                    do
                    {
                      llvm::Instruction::setMetadata((llvm::Instruction *)v33, *(_DWORD *)v70, v70[1]);
                      v70 += 2;
                    }
                    while (v70 != v71);
                  }
                }
              }
              else
              {
                __int16 v89 = 257;
                int v33 = (unsigned __int8 *)llvm::CastInst::Create(39, (uint64_t)v33, v20, v88, 0);
                (*((void (**)(void **, unsigned __int8 *, void *, void **, void ***))*v97 + 2))(v97, v33, v84, v93, v94);
                if (v91)
                {
                  unsigned int v46 = (llvm::MDNode **)v90;
                  uint64_t v47 = (llvm::MDNode **)((char *)v90 + 16 * v91);
                  do
                  {
                    llvm::Instruction::setMetadata((llvm::Instruction *)v33, *(_DWORD *)v46, v46[1]);
                    v46 += 2;
                  }
                  while (v46 != v47);
                }
              }
            }
            llvm::Value::doRAUW((llvm::ValueAsMetadata *)v8, (llvm::Value *)v33, (llvm::Value *)1);
            if (v107 >= (unint64_t)HIDWORD(v107)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v106 + v107) = v17;
            LODWORD(v107) = v107 + 1;
            if (v90 != v92) {
              free(v90);
            }
            char v7 = 1;
            unsigned int v23 = v87;
            unsigned int v24 = v83;
            goto LABEL_81;
          }
          int v40 = 1;
          while (v39 != (llvm::Instruction *)-4096)
          {
            int v41 = v37 + v40++;
            uint64_t v37 = v41 & (v36 - 1);
            uint64_t v39 = *(llvm::Instruction **)(v35 + 16 * v37);
            if (v39 == v17)
            {
              unsigned int v38 = (llvm::Instruction **)(v35 + 16 * v37);
              goto LABEL_66;
            }
          }
        }
        unsigned int v38 = (llvm::Instruction **)(v35 + 16 * v36);
        goto LABEL_66;
      }
      int v66 = *(unsigned __int8 *)v84[0];
      if ((v66 - 4) > 0x1E)
      {
        if ((v66 - 3) >= 0xFFFFFFFE) {
          uint64_t v69 = v84[0];
        }
        else {
          uint64_t v69 = 0;
        }
        if ((v66 - 3) < 0xFFFFFFFE)
        {
          if (v66 == 3) {
            *(void *)(v84[0] + 8) = 0;
          }
          goto LABEL_58;
        }
        unint64_t v68 = v69 + 8;
      }
      else
      {
        if ((*(unsigned char *)(v84[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v84[0] + 12)) {
          goto LABEL_58;
        }
        uint64_t v67 = *(void *)(v84[0] + 16);
        if ((v67 & 4) == 0) {
          goto LABEL_58;
        }
        unint64_t v68 = v67 & 0xFFFFFFFFFFFFFFF8;
        if (!v68) {
          goto LABEL_58;
        }
      }
      v88[0] = (const char *)v84;
      sub_1CC5FA668(v68 + 16, v88);
      goto LABEL_58;
    }
LABEL_85:
    int v50 = *(_DWORD *)(v8 + 20);
    if ((v50 & 0x40000000) != 0)
    {
      uint64_t v52 = *(void *)(v8 - 8);
      uint64_t v51 = v50 & 0x7FFFFFF;
      if (!v51) {
        goto LABEL_109;
      }
    }
    else
    {
      uint64_t v51 = v50 & 0x7FFFFFF;
      uint64_t v52 = v8 - 32 * v51;
      if (!v51) {
        goto LABEL_109;
      }
    }
    uint64_t v53 = 32 * v51;
    int v54 = (void **)(v52 + 8);
    do
    {
      uint64_t v56 = (llvm::ConstantInt ***)(v54 - 1);
      uint64_t v55 = (unsigned __int8 *)*(v54 - 1);
      if ((*(_DWORD *)(*(void *)v55 + 8) & 0xFE) == 0x12) {
        int v57 = *(unsigned __int8 *)(**(void **)(*(void *)v55 + 16) + 8);
      }
      else {
        int v57 = *(_DWORD *)(*(void *)v55 + 8);
      }
      if (v57 == 13)
      {
        unsigned int v58 = v55[16];
        BOOL v59 = v58 > 0x1B || v58 == 21;
        if (v59 && llvm::DemandedBits::isUseDead(a2, (llvm::Use *)(v54 - 1)))
        {
          sub_1CCD16504(*(void *)(v8 + 8), a2);
          uint64_t v60 = llvm::ConstantInt::get(**v56, 0, 0);
          if (*v56)
          {
            *v54[1] = *v54;
            if (*v54) {
              (*v54)[2] = v54[1];
            }
          }
          char *v56 = (llvm::ConstantInt **)v60;
          if (v60)
          {
            uint64_t v63 = (void *)v60[1];
            uint64_t v61 = (llvm::ConstantInt ****)(v60 + 1);
            unsigned int v62 = v63;
            void *v54 = v63;
            if (v63) {
              v62[2] = v54;
            }
            v54[1] = v61;
            void *v61 = v56;
          }
          char v7 = 1;
        }
      }
      v54 += 4;
      v53 -= 32;
    }
    while (v53);
LABEL_109:
    uint64_t v6 = *(void *)(v6 + 8);
    uint64_t v64 = v3 - 24;
    if (!v3) {
      uint64_t v64 = 0;
    }
    if (v6 == v64 + 40) {
      break;
    }
LABEL_116:
    if (v3 == v2) {
      goto LABEL_139;
    }
  }
  while (1)
  {
    uint64_t v3 = *(void *)(v3 + 8);
    if (v3 == v2) {
      break;
    }
    uint64_t v65 = v3 - 24;
    if (!v3) {
      uint64_t v65 = 0;
    }
    uint64_t v6 = *(void *)(v65 + 48);
    if (v6 != v65 + 40) {
      goto LABEL_116;
    }
  }
LABEL_139:
  BOOL v72 = (char *)v106;
  if (!v107) {
    goto LABEL_156;
  }
  unsigned int v73 = (char *)v106 + 8 * v107;
  while (2)
  {
    uint64_t v74 = (uint64_t ***)*((void *)v73 - 1);
    v73 -= 8;
    uint64_t v90 = v92;
    uint64_t v91 = 0x100000000;
    llvm::findDbgUsers((uint64_t)&v90, v74);
    llvm::salvageDebugInfoForDbgValues((llvm::CastInst *)v74, (uint64_t *)v90, v91);
    if (v90 != v92) {
      free(v90);
    }
    uint64_t v75 = *(void *)v73;
    int v76 = *(_DWORD *)(*(void *)v73 + 20);
    if ((v76 & 0x40000000) != 0)
    {
      uint64_t v78 = *(void *)(v75 - 8);
      uint64_t v77 = v76 & 0x7FFFFFF;
      if (v77) {
        goto LABEL_145;
      }
    }
    else
    {
      uint64_t v77 = v76 & 0x7FFFFFF;
      uint64_t v78 = v75 - 32 * v77;
      if (v77)
      {
LABEL_145:
        uint64_t v79 = 32 * v77;
        unsigned int v80 = (void **)(v78 + 16);
        do
        {
          if (*(v80 - 2))
          {
            **unsigned int v80 = *(v80 - 1);
            uint64_t v81 = (uint64_t)*(v80 - 1);
            if (v81) {
              *(void *)(v81 + 16) = *v80;
            }
          }
          *(v80 - 2) = 0;
          v80 += 4;
          v79 -= 32;
        }
        while (v79);
      }
    }
    if (v73 != v72) {
      continue;
    }
    break;
  }
  BOOL v72 = (char *)v106;
  if (v107) {
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
LABEL_156:
  if (v72 != (char *)v108) {
    free(v72);
  }
  return v7 & 1;
}

void sub_1CCD163B4(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCD16454(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0908;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D4B8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF0910, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD163B4;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF0910, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCD16504(uint64_t a1, llvm::DemandedBits *this)
{
  v56[16] = *MEMORY[0x1E4F143B8];
  unsigned int v49 = v53;
  int v50 = v53;
  uint64_t v51 = 16;
  int v52 = 0;
  int v54 = v56;
  uint64_t v55 = 0x1000000000;
  if (!a1) {
    goto LABEL_124;
  }
  uint64_t v3 = a1;
  do
  {
    uint64_t v4 = *(unsigned __int8 **)(v3 + 24);
    if (v4) {
      BOOL v5 = v4[16] >= 0x1Cu;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      goto LABEL_53;
    }
    int v6 = (*(_DWORD *)(*(void *)v4 + 8) & 0xFE) == 0x12
       ? *(unsigned __int8 *)(**(void **)(*(void *)v4 + 16) + 8)
       : *(_DWORD *)(*(void *)v4 + 8);
    if (v6 != 13) {
      goto LABEL_53;
    }
    llvm::DemandedBits::getDemandedBits(this, *(llvm::Instruction **)(v3 + 24), (llvm::APInt *)&v47);
    unsigned int v7 = v48;
    if (!v48) {
      goto LABEL_53;
    }
    if (v48 <= 0x40)
    {
      if (v47 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v48) {
        goto LABEL_53;
      }
LABEL_19:
      int v9 = v50;
      uint64_t v10 = HIDWORD(v51);
      if (v50 == v49)
      {
        if (HIDWORD(v51))
        {
          int64_t v11 = 0;
          uint64_t v12 = 8 * HIDWORD(v51);
          unint64_t v13 = (unsigned __int8 **)v50;
          while (*v13 != v4)
          {
            if (*v13 == (unsigned __int8 *)-2) {
              int64_t v11 = v13;
            }
            ++v13;
            v12 -= 8;
            if (!v12)
            {
              if (!v11) {
                goto LABEL_27;
              }
              unint64_t *v11 = v4;
              --v52;
              goto LABEL_51;
            }
          }
          goto LABEL_51;
        }
LABEL_27:
        unsigned int v14 = v51;
        if (HIDWORD(v51) < v51)
        {
          ++HIDWORD(v51);
          *(void *)&v50[8 * v10] = v4;
LABEL_51:
          if (v55 >= (unint64_t)HIDWORD(v55)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v54 + v55) = v4;
          LODWORD(v55) = v55 + 1;
          goto LABEL_53;
        }
      }
      else
      {
        unsigned int v14 = v51;
      }
      if (3 * v14 <= 4 * (HIDWORD(v51) - v52))
      {
        if (v14 >= 0x40) {
          v14 *= 2;
        }
        else {
          unsigned int v14 = 128;
        }
      }
      else if (v14 - HIDWORD(v51) >= v14 >> 3)
      {
        goto LABEL_32;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v49, v14);
      unsigned int v14 = v51;
      int v9 = v50;
LABEL_32:
      unsigned int v15 = v14 - 1;
      unsigned int v16 = (v14 - 1) & ((v4 >> 4) ^ (v4 >> 9));
      uint64_t v17 = &v9[8 * v16];
      uint64_t v18 = *(unsigned __int8 **)v17;
      if (*(void *)v17 == -1)
      {
        int v19 = 0;
LABEL_44:
        if (v19) {
          unsigned int v23 = v19;
        }
        else {
          unsigned int v23 = (unsigned __int8 **)v17;
        }
        if (*v23 != v4)
        {
          if (*v23 == (unsigned __int8 *)-2) {
            --v52;
          }
          else {
            ++HIDWORD(v51);
          }
          char *v23 = v4;
        }
      }
      else
      {
        int v19 = 0;
        int v20 = 1;
        while (v18 != v4)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v18 == (unsigned __int8 *)-2;
          }
          if (v21) {
            int v19 = (unsigned __int8 **)v17;
          }
          unsigned int v22 = v16 + v20++;
          unsigned int v16 = v22 & v15;
          uint64_t v17 = &v9[8 * (v22 & v15)];
          uint64_t v18 = *(unsigned __int8 **)v17;
          if (*(void *)v17 == -1) {
            goto LABEL_44;
          }
        }
      }
      goto LABEL_51;
    }
    int v8 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v47);
    if (v47) {
      MEMORY[0x1D25D9CB0](v47, 0x1000C8000313F17);
    }
    if (v8 != v7) {
      goto LABEL_19;
    }
LABEL_53:
    uint64_t v3 = *(void *)(v3 + 8);
  }
  while (v3);
  unsigned int v24 = v55;
  if (v55)
  {
    while (1)
    {
      int v25 = (llvm::Instruction *)*((void *)v54 + v24 - 1);
      LODWORD(v55) = v24 - 1;
      llvm::Instruction::dropPoisonGeneratingFlags(v25);
      uint64_t v26 = *((void *)v25 + 1);
      if (v26) {
        break;
      }
LABEL_123:
      unsigned int v24 = v55;
      if (!v55) {
        goto LABEL_124;
      }
    }
    while (2)
    {
      unint64_t v27 = *(unsigned __int8 **)(v26 + 24);
      if (v27) {
        BOOL v28 = v27[16] >= 0x1Cu;
      }
      else {
        BOOL v28 = 0;
      }
      if (!v28) {
        goto LABEL_114;
      }
      unsigned int v29 = v50;
      uint64_t v30 = HIDWORD(v51);
      if (v50 == v49)
      {
        if (HIDWORD(v51))
        {
          uint64_t v31 = 0;
          uint64_t v32 = 8 * HIDWORD(v51);
          int v33 = (unsigned __int8 **)v50;
          while (*v33 != v27)
          {
            if (*v33 == (unsigned __int8 *)-2) {
              uint64_t v31 = v33;
            }
            ++v33;
            v32 -= 8;
            if (!v32)
            {
              if (!v31) {
                goto LABEL_77;
              }
              llvm::SCEV *v31 = v27;
              --v52;
              goto LABEL_101;
            }
          }
          goto LABEL_114;
        }
LABEL_77:
        unsigned int v34 = v51;
        if (HIDWORD(v51) < v51)
        {
          ++HIDWORD(v51);
          *(void *)&v50[8 * v30] = v27;
          goto LABEL_101;
        }
      }
      else
      {
        unsigned int v34 = v51;
      }
      if (3 * v34 <= 4 * (HIDWORD(v51) - v52))
      {
        if (v34 >= 0x40) {
          v34 *= 2;
        }
        else {
          unsigned int v34 = 128;
        }
      }
      else if (v34 - HIDWORD(v51) >= v34 >> 3)
      {
LABEL_82:
        unsigned int v35 = v34 - 1;
        unsigned int v36 = (v34 - 1) & ((v27 >> 4) ^ (v27 >> 9));
        uint64_t v37 = &v29[8 * v36];
        unsigned int v38 = *(unsigned __int8 **)v37;
        if (*(void *)v37 != -1)
        {
          uint64_t v39 = 0;
          int v40 = 1;
          while (v38 != v27)
          {
            if (v39) {
              BOOL v41 = 0;
            }
            else {
              BOOL v41 = v38 == (unsigned __int8 *)-2;
            }
            if (v41) {
              uint64_t v39 = (unsigned __int8 **)v37;
            }
            unsigned int v42 = v36 + v40++;
            unsigned int v36 = v42 & v35;
            uint64_t v37 = &v29[8 * (v42 & v35)];
            unsigned int v38 = *(unsigned __int8 **)v37;
            if (*(void *)v37 == -1) {
              goto LABEL_94;
            }
          }
          goto LABEL_114;
        }
        uint64_t v39 = 0;
LABEL_94:
        if (v39) {
          uint64_t v43 = v39;
        }
        else {
          uint64_t v43 = (unsigned __int8 **)v37;
        }
        if (*v43 == v27)
        {
LABEL_114:
          uint64_t v26 = *(void *)(v26 + 8);
          if (!v26) {
            goto LABEL_123;
          }
          continue;
        }
        if (*v43 == (unsigned __int8 *)-2) {
          --v52;
        }
        else {
          ++HIDWORD(v51);
        }
        uint64_t *v43 = v27;
LABEL_101:
        if ((*(_DWORD *)(*(void *)v27 + 8) & 0xFE) == 0x12) {
          int v44 = *(unsigned __int8 *)(**(void **)(*(void *)v27 + 16) + 8);
        }
        else {
          int v44 = *(_DWORD *)(*(void *)v27 + 8);
        }
        if (v44 != 13) {
          goto LABEL_114;
        }
        llvm::DemandedBits::getDemandedBits(this, (llvm::Instruction *)v27, (llvm::APInt *)&v47);
        unsigned int v45 = v48;
        if (!v48) {
          goto LABEL_114;
        }
        if (v48 > 0x40)
        {
          int v46 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v47);
          if (v47) {
            MEMORY[0x1D25D9CB0](v47, 0x1000C8000313F17);
          }
          if (v46 == v45) {
            goto LABEL_114;
          }
        }
        else if (v47 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v48)
        {
          goto LABEL_114;
        }
        if (v55 >= (unint64_t)HIDWORD(v55)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v54 + v55) = v27;
        LODWORD(v55) = v55 + 1;
        goto LABEL_114;
      }
      break;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v49, v34);
    unsigned int v34 = v51;
    unsigned int v29 = v50;
    goto LABEL_82;
  }
LABEL_124:
  if (v54 != v56) {
    free(v54);
  }
  if (v50 != v49) {
    free(v50);
  }
}

void sub_1CCD16AB0()
{
}

void sub_1CCD16AF0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD16B28(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DemandedBitsWrapperPass::ID);

  sub_1CB843600(a2, v3, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

uint64_t sub_1CCD16BB4(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  BOOL v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::DemandedBitsWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  int v9 = (llvm::DemandedBits *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::DemandedBitsWrapperPass::ID)+ 32);

  return sub_1CCD15A1C((uint64_t)a2, v9);
}

void sub_1CCD16C70(uint64_t a1)
{
}

uint64_t sub_1CCD16D20(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF09D8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D558;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF09E0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD16C70;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF09E0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD16DD0(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v476 = *MEMORY[0x1E4F143B8];
  v446[0] = v447;
  v446[1] = 0x1000000000;
  v447[33] = 0;
  v447[32] = 0;
  v447[34] = a4;
  v447[35] = 0;
  char v448 = 1;
  v449 = v453;
  v450 = v453;
  uint64_t v451 = 8;
  int v452 = 0;
  uint64_t v4 = a1 + 72;
  memset(&v453[64], 0, 24);
  __int16 v454 = 0;
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5 != a1 + 72)
  {
    uint64_t v6 = a2;
    char v437 = 0;
    uint64_t v426 = a1 + 72;
    while (1)
    {
      uint64_t v7 = (void *)(v5 - 24);
      BOOL v22 = v5 == 0;
      uint64_t v5 = *(void *)(v5 + 8);
      if (v22) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = v7;
      }
      FirstNonPHIOrDbg = llvm::BasicBlock::getFirstNonPHIOrDbg((llvm::BasicBlock *)v8, 1);
      int64_t v11 = v8 + 5;
      uint64_t v10 = (void *)v8[5];
      if (v10 == v8 + 5)
      {
        uint64_t v12 = 0;
      }
      else
      {
        if (v10) {
          uint64_t v12 = v10 - 3;
        }
        else {
          uint64_t v12 = 0;
        }
        if (*((unsigned __int8 *)v12 + 16) - 29 >= 0xB) {
          uint64_t v12 = 0;
        }
      }
      unint64_t v13 = FirstNonPHIOrDbg + 24;
      unsigned int v14 = (char *)(v12 + 3);
      while (v13 != v14)
      {
        unsigned int v15 = v13;
        uint64_t v16 = (uint64_t)(v13 - 24);
        uint64_t v17 = v13 ? (uint64_t)(v13 - 24) : 0;
        uint64_t v18 = (void *)*v11;
        if ((void *)*v11 == v11)
        {
          int v19 = 0;
        }
        else
        {
          if (v18) {
            int v19 = v18 - 3;
          }
          else {
            int v19 = 0;
          }
          if (*((unsigned __int8 *)v19 + 16) - 29 >= 0xB) {
            int v19 = 0;
          }
        }
        if ((void *)v17 == v19) {
          break;
        }
        unint64_t v13 = (char *)*((void *)v13 + 1);
        unsigned int v20 = *(unsigned __int8 *)(v17 + 16) - 33;
        BOOL v87 = v20 > 0x33;
        uint64_t v21 = (1 << v20) & 0x8000000000041;
        BOOL v22 = v87 || v21 == 0;
        if (!v22
          && (*(v15 - 8) != 84
           || (uint64_t v23 = *((void *)v15 - 7)) == 0
           || *(unsigned char *)(v23 + 16)
           || *(void *)(v23 + 24) != *((void *)v15 + 6)
           || (*(unsigned char *)(v23 + 33) & 0x20) == 0))
        {
          if (*((void *)v15 - 2)
            || (BOOL v28 = v11,
                unsigned int v29 = v14,
                uint64_t v30 = (char *)*((void *)v15 + 1),
                char wouldInstructionBeTriviallyDead = llvm::wouldInstructionBeTriviallyDead(v16, v6),
                unint64_t v13 = v30,
                unsigned int v14 = v29,
                int64_t v11 = v28,
                (wouldInstructionBeTriviallyDead & 1) == 0))
          {
            uint64_t v24 = *((void *)v15 - 7);
            if (v24)
            {
              if (!*(unsigned char *)(v24 + 16)
                && *(void *)(v24 + 24) == *((void *)v15 + 6)
                && (*(void *)(v24 + 72) != v24 + 72 || (*(unsigned char *)(v24 + 34) & 0x80) != 0))
              {
                int v25 = *(v15 - 8);
                if (v25 == 33)
                {
                  BOOL k = 0;
                  uint64_t v27 = 2;
                }
                else if (v25 == 39)
                {
                  BOOL k = 0;
                  uint64_t v27 = (*((_DWORD *)v15 + 14) + 1);
                }
                else
                {
                  uint64_t v27 = 0;
                  BOOL k = (*((_WORD *)v15 - 3) & 3) == 2;
                }
                int v32 = *((_DWORD *)v15 - 1);
                if (v32 < 0
                  && (uint64_t v417 = v16 - 32 * (v32 & 0x7FFFFFF), v418 = *(void *)(v417 - 8), (v418 & 0xFFFFFFFF0) != 0))
                {
                  uint64_t v34 = -(uint64_t)(v32 & 0x7FFFFFF);
                  int v33 = *(_DWORD *)(v417 - 12) - *(_DWORD *)(v417 - v418);
                }
                else
                {
                  int v33 = 0;
                  uint64_t v34 = -(uint64_t)(v32 & 0x7FFFFFF);
                }
                long long __p = (char *)v16;
                if (((-32 * v27 + 32 * -v33 - 32 * v34 - 32) & 0x1FFFFFFFE0) == 0
                  || (uint64_t v35 = *((void *)v15 + 5)) != 0 && (*(unsigned char *)(v35 + 12) & 0x40) != 0)
                {
                  LOBYTE(v36) = 0;
                }
                else
                {
                  v423 = v13;
                  v424 = v14;
                  v425 = v11;
                  if ((llvm::CallBase::hasFnAttrOnCalledFunction(v16, 6) & 1) != 0
                    || (uint64_t v37 = *((void *)v15 + 5)) != 0 && (*(unsigned char *)(v37 + 15) & 1) != 0)
                  {
                    LOBYTE(v36) = 0;
                    goto LABEL_57;
                  }
                  LOBYTE(v36) = 0;
                  if (llvm::CallBase::hasFnAttrOnCalledFunction(v16, 24))
                  {
LABEL_57:
                    int64_t v11 = v425;
LABEL_111:
                    unint64_t v13 = v423;
                    unsigned int v14 = v424;
                    goto LABEL_112;
                  }
                  unsigned int v14 = v424;
                  int64_t v11 = v425;
                  unint64_t v13 = v423;
                  if (*(v15 - 8) == 84)
                  {
                    uint64_t v38 = *((void *)v15 + 2);
                    for (uint64_t i = *(void *)(v38 + 8); i; uint64_t i = *(void *)(i + 8))
                    {
                      uint64_t v40 = *(void *)(i + 24);
                      unsigned int v41 = *(unsigned __int8 *)(v40 + 16);
                      if (v40) {
                        BOOL v42 = v41 >= 0x1C;
                      }
                      else {
                        BOOL v42 = 0;
                      }
                      if (v42 && v41 - 29 < 0xB) {
                        break;
                      }
                    }
                    v455 = v457;
                    uint64_t v456 = 0x200000000;
                    sub_1CBF846A4((uint64_t)&v455, i, 0);
                    int v44 = v455;
                    if (v456 == 2)
                    {
                      uint64_t v45 = *(void *)(*(void *)v455 + 40);
                      if (v45) {
                        uint64_t v46 = v45 - 24;
                      }
                      else {
                        uint64_t v46 = 0;
                      }
                      if (*(unsigned __int8 *)(v46 + 16) - 29 >= 0xB) {
                        uint64_t v46 = 0;
                      }
                      int64_t v11 = v425;
                      if (*(unsigned char *)(v46 + 16) == 32) {
                        goto LABEL_106;
                      }
                      uint64_t v47 = *(void *)(*((void *)v455 + 1) + 40);
                      if (v47) {
                        uint64_t v48 = v47 - 24;
                      }
                      else {
                        uint64_t v48 = 0;
                      }
                      if (*(unsigned __int8 *)(v48 + 16) - 29 >= 0xB) {
                        uint64_t v48 = 0;
                      }
                      if (*(unsigned char *)(v48 + 16) == 32) {
                        goto LABEL_106;
                      }
                      unsigned int v49 = (uint64_t *)(v38 + 48);
                      int v50 = (uint64_t *)(v38 + 48);
                      do
                      {
                        uint64_t v51 = *v50;
                        uint64_t v52 = v51 - 24;
                        if (!v51) {
                          uint64_t v52 = 0;
                        }
                        int v53 = *(unsigned __int8 *)(v52 + 16);
                        int v50 = (uint64_t *)(v51 + 8);
                      }
                      while (v53 == 83);
                      if ((v53 - 38) <= 0x2A
                        && ((1 << (v53 - 38)) & 0x60000000001) != 0)
                      {
                        goto LABEL_106;
                      }
                      uint64_t v55 = *v49;
                      uint64_t v56 = *v49 - 24;
                      if (!v55) {
                        uint64_t v56 = 0;
                      }
                      int v57 = *(unsigned __int8 *)(v56 + 16);
                      uint64_t v58 = v55;
                      if (v57 == 83)
                      {
                        uint64_t v58 = v55;
                        do
                        {
                          uint64_t v58 = *(void *)(v58 + 8);
                          uint64_t v59 = v58 - 24;
                          if (!v58) {
                            uint64_t v59 = 0;
                          }
                        }
                        while (*(unsigned char *)(v59 + 16) == 83);
                      }
                      unsigned int v60 = *(unsigned __int8 *)(v58 - 8) - 38;
                      BOOL v87 = v60 > 0x38;
                      uint64_t v61 = (1 << v60) & 0x100060000000001;
                      if (v87 || v61 == 0)
                      {
                        if ((char *)v55 == v15)
                        {
                          int v36 = 1;
                        }
                        else
                        {
                          int64_t v75 = 0;
                          do
                          {
                            if (v55) {
                              uint64_t v76 = v55 - 24;
                            }
                            else {
                              uint64_t v76 = 0;
                            }
                            int v77 = *(_DWORD *)(v76 + 20);
                            if ((v77 & 0x40000000) != 0)
                            {
                              uint64_t v79 = *(uint64_t **)(v76 - 8);
                              unint64_t v78 = v77 & 0x7FFFFFF;
                            }
                            else
                            {
                              unint64_t v78 = v77 & 0x7FFFFFF;
                              uint64_t v79 = (uint64_t *)(v76 - 32 * v78);
                            }
                            v473 = (char *)v475;
                            uint64_t v474 = 0x400000000;
                            if (v78 >= 5) {
                              llvm::SmallVectorBase<unsigned int>::grow_pod();
                            }
                            if (v78)
                            {
                              uint64_t v80 = 32 * v78;
                              uint64_t v81 = v475;
                              do
                              {
                                uint64_t v82 = *v79;
                                v79 += 4;
                                *v81++ = v82;
                                v80 -= 32;
                              }
                              while (v80);
                              unsigned int v83 = v473;
                            }
                            else
                            {
                              unsigned int v83 = (char *)v475;
                            }
                            LODWORD(v474) = v78;
                            uint64_t v84 = (*(uint64_t (**)(void, uint64_t, char *))(*(void *)*a3 + 72))(*a3, v76, v83);
                            int v86 = v85;
                            if (v473 != (char *)v475) {
                              free(v473);
                            }
                            if (__OFADD__(v75, v84)) {
                              int64_t v75 = ((v75 + v84) >> 63) ^ 0x8000000000000000;
                            }
                            else {
                              v75 += v84;
                            }
                            BOOL v87 = v86 != 1 && v75 < dword_1EBCF0998;
                            int v36 = v87;
                            int64_t v11 = v425;
                            if (!v87) {
                              break;
                            }
                            uint64_t v55 = *(void *)(v55 + 8);
                          }
                          while ((char *)v55 != v15);
                          int v44 = v455;
                        }
                      }
                      else
                      {
LABEL_106:
                        int v36 = 0;
                      }
                    }
                    else
                    {
                      int v36 = 0;
                      int64_t v11 = v425;
                    }
                    if (v44 != v457)
                    {
                      free(v44);
                      int64_t v11 = v425;
                    }
                    if (!v36) {
                      goto LABEL_111;
                    }
                    sub_1CCD197D4(&v458, *(void *)(*((void *)v15 + 2) + 8));
                    uint64_t v63 = v458;
                    BOOL v420 = k;
                    if (*(void *)v458 == *((void *)v458 + 1))
                    {
                      v455 = v457;
                      uint64_t v456 = 0x200000000;
                      goto LABEL_248;
                    }
                    uint64_t DomTree = llvm::DomTreeUpdater::getDomTree((llvm::DomTreeUpdater *)v446);
                    uint64_t v65 = *(unsigned int *)(DomTree + 40);
                    if (!v65) {
                      goto LABEL_125;
                    }
                    uint64_t v66 = *((void *)v15 + 2);
                    uint64_t v67 = *(void *)(DomTree + 24);
                    LODWORD(v68) = ((v66 >> 4) ^ (v66 >> 9)) & (v65 - 1);
                    uint64_t v69 = (uint64_t *)(v67 + 16 * v68);
                    uint64_t v70 = *v69;
                    if (v66 != *v69)
                    {
                      int v71 = 1;
                      do
                      {
                        if (v70 == -4096) {
                          goto LABEL_125;
                        }
                        int v72 = v68 + v71++;
                        uint64_t v68 = v72 & (v65 - 1);
                        uint64_t v70 = *(void *)(v67 + 16 * v68);
                      }
                      while (v66 != v70);
                      uint64_t v69 = (uint64_t *)(v67 + 16 * v68);
                    }
                    if (v69 != (uint64_t *)(v67 + 16 * v65) && (uint64_t v73 = v69[1]) != 0) {
                      uint64_t v74 = **(llvm::BasicBlock ***)(v73 + 8);
                    }
                    else {
LABEL_125:
                    }
                      uint64_t v74 = 0;
                    v473 = (char *)v475;
                    uint64_t v474 = 0x200000000;
                    if (!v459) {
                      goto LABEL_246;
                    }
                    int v88 = (char *)v458;
                    __int16 v89 = (char *)v458 + 8 * v459;
                    v443 = (char *)v458;
                    while (2)
                    {
                      uint64_t v91 = *((void *)v89 - 1);
                      v89 -= 8;
                      uint64_t v90 = (llvm::BasicBlock *)v91;
                      v461 = v463;
                      uint64_t v462 = 0x200000000;
                      sub_1CCD19818((uint64_t)__p, v91, *((void *)v15 + 2), (uint64_t)&v461);
                      v464 = v468;
                      v465 = v468;
                      uint64_t v466 = 4;
                      LODWORD(v467) = 0;
                      if ((llvm::BasicBlock *)v91 == v74) {
                        goto LABEL_235;
                      }
                      uint64_t v92 = v5;
                      uint64_t v93 = v468;
                      uint64_t v94 = v468;
                      uint64_t v95 = v90;
LABEL_163:
                      uint64_t v96 = (uint64_t)v95;
                      uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(v95);
                      uint64_t v95 = (llvm::BasicBlock *)SinglePredecessor;
                      if (v94 == v93)
                      {
                        int v98 = HIDWORD(v466);
                        int v99 = &v93[HIDWORD(v466)];
                        if (HIDWORD(v466))
                        {
                          uint64_t v100 = 8 * HIDWORD(v466);
                          char v101 = v93;
                          while (*v101 != SinglePredecessor)
                          {
                            ++v101;
                            v100 -= 8;
                            if (!v100) {
                              goto LABEL_187;
                            }
                          }
                          int v99 = v101;
                        }
                      }
                      else
                      {
                        int v102 = v466 - 1;
                        unsigned int v103 = (v466 - 1) & ((SinglePredecessor >> 4) ^ (SinglePredecessor >> 9));
                        int v99 = &v94[v103];
                        uint64_t v104 = *v99;
                        if (*v99 == -1)
                        {
                          unsigned int v105 = 0;
LABEL_183:
                          if (v105) {
                            int v99 = v105;
                          }
                          int v98 = HIDWORD(v466);
                          if (*v99 != SinglePredecessor) {
                            int v99 = &v94[v466];
                          }
                        }
                        else
                        {
                          unsigned int v105 = 0;
                          int v106 = 1;
                          while (v104 != SinglePredecessor)
                          {
                            if (v105) {
                              BOOL v107 = 0;
                            }
                            else {
                              BOOL v107 = v104 == -2;
                            }
                            if (v107) {
                              unsigned int v105 = v99;
                            }
                            unsigned int v108 = v103 + v106++;
                            unsigned int v103 = v108 & v102;
                            int v99 = &v94[v108 & v102];
                            uint64_t v104 = *v99;
                            if (*v99 == -1) {
                              goto LABEL_183;
                            }
                          }
                          int v98 = HIDWORD(v466);
                        }
                      }
LABEL_187:
                      int v109 = v466;
                      if (v94 == v93) {
                        int v109 = v98;
                      }
                      if (v99 != &v94[v109] || SinglePredecessor == 0)
                      {
LABEL_233:
                        uint64_t v5 = v92;
                        int v88 = v443;
                        if (v94 != v93) {
                          free(v94);
                        }
LABEL_235:
                        v464 = v90;
                        v465 = &v467;
                        uint64_t v466 = 0x200000000;
                        if (v462) {
                          sub_1CCC0065C((uint64_t *)&v465, (uint64_t *)&v461);
                        }
                        sub_1CD75E04C((uint64_t)&v473, (unint64_t)&v464);
                        if (v465 != &v467) {
                          free(v465);
                        }
                        if (v461 != v463) {
                          free(v461);
                        }
                        if (v89 == v88)
                        {
                          uint64_t v6 = a2;
                          BOOL k = v420;
                          if (v474)
                          {
                            uint64_t v126 = v473 + 16;
                            uint64_t v127 = 56 * v474;
                            while (1)
                            {
                              int v128 = *(_DWORD *)v126;
                              v126 += 56;
                              if (v128) {
                                break;
                              }
                              v127 -= 56;
                              if (!v127) {
                                goto LABEL_246;
                              }
                            }
                            v455 = v457;
                            uint64_t v456 = 0x200000000;
                            sub_1CD75E264((uint64_t)&v455, (uint64_t)&v473);
LABEL_247:
                            sub_1CD63E2C8(&v473);
                            uint64_t v63 = v458;
LABEL_248:
                            if (v63 != v460) {
                              free(v63);
                            }
                            int v129 = v456;
                            if (v456) {
                              goto LABEL_294;
                            }
                            char v130 = (llvm::BasicBlock *)*((void *)v15 + 2);
                            if (llvm::BasicBlock::getFirstNonPHIOrDbg(v130, 1) != __p
                              || *((llvm::BasicBlock **)v130 + 5) == (llvm::BasicBlock *)((char *)v130 + 40)
                              || ((uint64_t v131 = *((void *)v130 + 6), v132 = v131 - 24, v131)
                                ? (uint64_t v133 = v131 - 24)
                                : (uint64_t v133 = 0),
                                  !v131 || *(unsigned char *)(v133 + 16) != 83))
                            {
LABEL_291:
                              v473 = (char *)v475;
                              uint64_t v474 = 0x200000000;
                              goto LABEL_292;
                            }
                            int v134 = *((_DWORD *)v15 - 1);
                            int v135 = &__p[-32 * (v134 & 0x7FFFFFF)];
                            int v136 = *(v15 - 8);
                            while (2)
                            {
                              if (v136 == 84)
                              {
                                uint64_t v137 = 0;
                                if ((v134 & 0x80000000) == 0) {
                                  goto LABEL_261;
                                }
LABEL_287:
                                if ((*(void *)&v15[-32 * (v134 & 0x7FFFFFF) - 32] & 0xFFFFFFFF0) != 0) {
                                  uint64_t v138 = (*((_DWORD *)v135 - 3) - *(_DWORD *)&v135[-*((void *)v135 - 1)]);
                                }
                                else {
                                  uint64_t v138 = 0;
                                }
                                uint64_t v6 = a2;
                                BOOL k = v420;
                              }
                              else
                              {
                                if (v136 == 39) {
                                  uint64_t v137 = (*((_DWORD *)v15 + 14) + 1);
                                }
                                else {
                                  uint64_t v137 = 2;
                                }
                                uint64_t v6 = a2;
                                BOOL k = v420;
                                if (v134 < 0) {
                                  goto LABEL_287;
                                }
LABEL_261:
                                uint64_t v138 = 0;
                              }
                              if (v135 == &v15[-32 * v137 - 56 + -32 * v138])
                              {
LABEL_277:
                                uint64_t v151 = *(void *)(v132 + 32);
                                uint64_t v132 = v151 - 24;
                                if (v151) {
                                  uint64_t v152 = v151 - 24;
                                }
                                else {
                                  uint64_t v152 = 0;
                                }
                                if (!v151 || *(unsigned char *)(v152 + 16) != 83) {
                                  goto LABEL_291;
                                }
                                continue;
                              }
                              break;
                            }
                            uint64_t v139 = 32 * (v134 & 0x7FFFFFF) - 32 - 32 * v137 - 32 * v138;
                            uint64_t v140 = &__p[-32 * (v134 & 0x7FFFFFF)];
                            while (2)
                            {
                              if (*(void *)v140 != v132)
                              {
LABEL_265:
                                v140 += 32;
                                v139 -= 32;
                                if (!v139) {
                                  goto LABEL_277;
                                }
                                continue;
                              }
                              break;
                            }
                            int v141 = *(_DWORD *)(v132 + 20);
                            if ((v141 & 0x40000000) != 0)
                            {
                              unsigned int v148 = *(uint64_t **)(v132 - 8);
                              unsigned int v149 = &v148[4 * *(unsigned int *)(v132 + 60)];
                              if (*v149 == v149[1]) {
                                goto LABEL_291;
                              }
                              uint64_t v150 = *v148;
                              uint64_t v147 = v148[4];
                              if (v150 == v147 || *(unsigned __int8 *)(v150 + 16) > 0x14u) {
                                goto LABEL_265;
                              }
                            }
                            else
                            {
                              uint64_t v142 = v141 & 0x7FFFFFF;
                              int v143 = (uint64_t *)(v132 - 32 * v142);
                              unsigned int v144 = &v143[4 * *(unsigned int *)(v132 + 60)];
                              if (*v144 == v144[1]) {
                                goto LABEL_291;
                              }
                              uint64_t v145 = -v142;
                              uint64_t v146 = *v143;
                              uint64_t v147 = *(void *)(v132 + 32 + 32 * v145);
                              if (v146 == v147 || *(unsigned __int8 *)(v146 + 16) >= 0x15u) {
                                goto LABEL_265;
                              }
                            }
                            if (*(unsigned __int8 *)(v147 + 16) < 0x15u)
                            {
                              sub_1CCD197D4(&v471, *(void *)(*((void *)v15 + 2) + 8));
                              v461 = v463;
                              uint64_t v462 = 0x200000000;
                              v464 = *(void **)v471;
                              v465 = &v467;
                              uint64_t v466 = 0x200000000;
                              v458 = v460;
                              uint64_t v459 = 0x200000000;
                              v468[3] = *((void *)v471 + 1);
                              v469[0] = v470;
                              v469[1] = 0x200000000;
                              v473 = (char *)v475;
                              uint64_t v474 = 0x200000000;
                              sub_1CD75E558((uint64_t)&v473, (uint64_t)&v464, 2);
                              for (uint64_t j = 0; j != -14; j -= 7)
                              {
                                v396 = (unsigned char *)v469[j];
                                if (&v470[j * 8] != v396) {
                                  free(v396);
                                }
                              }
                              if (v458 != v460) {
                                free(v458);
                              }
                              if (v461 != v463) {
                                free(v461);
                              }
                              if (v471 != &v472) {
                                free(v471);
                              }
LABEL_292:
                              sub_1CD75E264((uint64_t)&v455, (uint64_t)&v473);
                              sub_1CD63E2C8(&v473);
                              int v129 = v456;
                              if (!v456)
                              {
                                LOBYTE(v36) = 0;
                                goto LABEL_534;
                              }
LABEL_294:
                              BOOL v153 = *(v15 - 8) == 84 && (*((_WORD *)v15 - 3) & 3) == 2;
                              v428 = 0;
                              v436 = (llvm::BasicBlock *)*((void *)v15 + 2);
                              BOOL v427 = v153;
                              if (!v153 && *((void *)v15 - 2))
                              {
                                uint64_t v154 = *(void *)__p;
                                v473 = "phi.call";
                                v475[8] = 259;
                                uint64_t v155 = (char *)operator new(0x48uLL);
                                *((void *)v155 + 1) = v154;
                                *(void *)uint64_t v155 = 0;
                                *((void *)v155 + 2) = 0;
                                *((void *)v155 + 3) = 0x4000000000000053;
                                *((_OWORD *)v155 + 2) = 0u;
                                *((_OWORD *)v155 + 3) = 0u;
                                *((_DWORD *)v155 + 16) = 0;
                                *((_DWORD *)v155 + 17) = v129;
                                v428 = (llvm::Value *)(v155 + 8);
                                llvm::Value::setNameImpl((llvm::Value *)(v155 + 8), (const char **)&v473);
                                if (v155[24]) {
                                  goto LABEL_300;
                                }
                                if ((v155[31] & 0x10) == 0) {
                                  goto LABEL_703;
                                }
                                uint64_t v403 = ***(void ***)v428;
                                uint64_t v404 = *(void *)(v403 + 152);
                                uint64_t v405 = *(unsigned int *)(v403 + 168);
                                if (!v405) {
                                  goto LABEL_695;
                                }
                                LODWORD(v406) = (v405 - 1) & ((v428 >> 4) ^ (v428 >> 9));
                                v407 = (llvm::Value **)(v404 + 16 * v406);
                                v408 = *v407;
                                if (*v407 != v428)
                                {
                                  int v409 = 1;
                                  while (v408 != (llvm::Value *)-4096)
                                  {
                                    int v410 = v406 + v409++;
                                    uint64_t v406 = v410 & (v405 - 1);
                                    v408 = *(llvm::Value **)(v404 + 16 * v406);
                                    if (v408 == v428)
                                    {
                                      v407 = (llvm::Value **)(v404 + 16 * v406);
                                      goto LABEL_696;
                                    }
                                  }
LABEL_695:
                                  v407 = (llvm::Value **)(v404 + 16 * v405);
                                }
LABEL_696:
                                v411 = v407[1];
                                unint64_t v414 = *(void *)v411;
                                v412 = (char *)v411 + 16;
                                unint64_t v413 = v414;
                                if (v414 >= 5
                                  && (*(_DWORD *)v412 == *(_DWORD *)"llvm."
                                    ? (BOOL v415 = v412[4] == aLlvm_1[4])
                                    : (BOOL v415 = 0),
                                      v415))
                                {
                                  *((_DWORD *)v155 + 10) |= 0x2000u;
                                  int v416 = llvm::Function::lookupIntrinsicID(v412, v413);
                                }
                                else
                                {
LABEL_703:
                                  int v416 = 0;
                                  *((_DWORD *)v155 + 10) &= ~0x2000u;
                                }
                                *((_DWORD *)v155 + 11) = v416;
LABEL_300:
                                uint64_t v156 = *((unsigned int *)v155 + 17);
                                unsigned int v157 = operator new(40 * v156);
                                *(void *)uint64_t v155 = v157;
                                if (v156)
                                {
                                  uint64_t v158 = &v157[4 * v156];
                                  do
                                  {
                                    *unsigned int v157 = 0;
                                    v157[1] = 0;
                                    v157[2] = 0;
                                    v157[3] = v428;
                                    v157 += 4;
                                  }
                                  while (v157 != v158);
                                }
                                unint64_t v159 = (void *)*((void *)v15 + 3);
                                v458 = v159;
                                if (v159) {
                                  llvm::MetadataTracking::track((uint64_t)&v458, (unsigned __int8 *)v159, 2);
                                }
                                uint64_t v162 = (unsigned __int8 *)*((void *)v155 + 7);
                                uint64_t v161 = v155 + 56;
                                uint64_t v160 = v162;
                                if (v162)
                                {
                                  int v397 = *v160;
                                  if ((v397 - 4) > 0x1E)
                                  {
                                    if ((v397 - 3) >= 0xFFFFFFFE) {
                                      v402 = v160;
                                    }
                                    else {
                                      v402 = 0;
                                    }
                                    if ((v397 - 3) < 0xFFFFFFFE)
                                    {
                                      if (v397 == 3) {
                                        *((void *)v160 + 1) = 0;
                                      }
                                      goto LABEL_306;
                                    }
                                    unint64_t v399 = (unint64_t)(v402 + 8);
                                  }
                                  else
                                  {
                                    if ((v160[1] & 0x7F) != 2 && !*((_DWORD *)v160 + 3)) {
                                      goto LABEL_306;
                                    }
                                    uint64_t v398 = *((void *)v160 + 2);
                                    if ((v398 & 4) == 0) {
                                      goto LABEL_306;
                                    }
                                    unint64_t v399 = v398 & 0xFFFFFFFFFFFFFFF8;
                                    if (!v399) {
                                      goto LABEL_306;
                                    }
                                  }
                                  v473 = v161;
                                  sub_1CC5FA668(v399 + 16, &v473);
                                }
LABEL_306:
                                v163 = (unsigned __int8 *)v458;
                                *(void *)uint64_t v161 = v458;
                                if (v163)
                                {
                                  llvm::MetadataTracking::retrack((uint64_t)&v458, v163, (uint64_t)v161);
                                  v458 = 0;
                                }
                              }
                              char v164 = 0;
                              uint64_t v165 = 0;
                              do
                              {
                                char v166 = v164;
                                unsigned int v167 = &(&v473)[8 * v165];
                                *((_DWORD *)v167 + 4) = 128;
                                v168 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
                                char *v167 = v168;
                                v167[1] = 0;
                                v465 = (void *)2;
                                uint64_t v466 = 0;
                                uint64_t v467 = -4096;
                                v464 = &unk_1F2615EC8;
                                v468[0] = 0;
                                uint64_t v171 = *((unsigned int *)v167 + 4);
                                if (v171)
                                {
                                  uint64_t v172 = 0;
                                  uint64_t v173 = v171 << 6;
                                  v174 = v168 + 16;
                                  do
                                  {
                                    unint64_t v175 = (unint64_t)v465;
                                    uint64_t v176 = v467;
                                    *(v174 - 1) = v465 & 6;
                                    void *v174 = 0;
                                    v174[1] = v176;
                                    if (v176 != -4096 && v176 != -8192 && v176 != 0)
                                    {
                                      void *v174 = *(void *)(v175 & 0xFFFFFFFFFFFFFFF8);
                                      *(void *)(v175 & 0xFFFFFFFFFFFFFFF8) = v174 - 1;
                                      *(v174 - 1) = v175 & 0xFFFFFFFFFFFFFFFELL;
                                      if (*v174) {
                                        *(void *)void *v174 = *(void *)*v174 & 7 | (unint64_t)(v168 + 16);
                                      }
                                      uint64_t v172 = v468[0];
                                    }
                                    *(v174 - 2) = &unk_1F2615EC8;
                                    uint64_t v174[2] = v172;
                                    v174 += 8;
                                    v168 += 64;
                                    v173 -= 64;
                                  }
                                  while (v173);
                                  if (v467 != -8192 && v467 != -4096 && v467)
                                  {
                                    unint64_t v178 = (unint64_t)v465 & 0xFFFFFFFFFFFFFFF8;
                                    *(void *)((unint64_t)v465 & 0xFFFFFFFFFFFFFFF8) = v466;
                                    if (v466)
                                    {
                                      *(void *)uint64_t v466 = *(void *)v466 & 7 | v178;
                                    }
                                    else
                                    {
                                      uint64_t v179 = v467;
                                      unsigned int v180 = ***(int32x2_t ****)v467;
                                      unint64_t v181 = (unint64_t)v180[303];
                                      if (v181 <= v178)
                                      {
                                        uint64_t v182 = v180[305].u32[0];
                                        if (v181 + 16 * v182 > v178)
                                        {
                                          unsigned int v183 = v182 - 1;
                                          LODWORD(v184) = v183 & ((v467 >> 4) ^ (v467 >> 9));
                                          uint64_t v185 = (uint64_t *)(v181 + 16 * v184);
                                          uint64_t v186 = *v185;
                                          if (v467 == *v185)
                                          {
LABEL_334:
                                            *uint64_t v185 = -8192;
                                            v180[304] = vadd_s32(v180[304], (int32x2_t)0x1FFFFFFFFLL);
                                            uint64_t v179 = v467;
                                          }
                                          else
                                          {
                                            int v187 = 1;
                                            while (v186 != -4096)
                                            {
                                              int v188 = v184 + v187++;
                                              uint64_t v184 = v188 & v183;
                                              uint64_t v186 = *(void *)(v181 + 16 * v184);
                                              if (v467 == v186)
                                              {
                                                uint64_t v185 = (uint64_t *)(v181 + 16 * v184);
                                                goto LABEL_334;
                                              }
                                            }
                                          }
                                          *(unsigned char *)(v179 + 17) &= ~1u;
                                        }
                                      }
                                    }
                                  }
                                }
                                *((unsigned char *)v167 + 24) = 0;
                                *((unsigned char *)v167 + 48) = 0;
                                char v164 = 1;
                                uint64_t v165 = 1;
                              }
                              while ((v166 & 1) == 0);
                              if (!v456)
                              {
LABEL_338:
                                if (v427)
                                {
                                  uint64_t v189 = *((void *)v436 + 1);
                                  uint64_t v6 = a2;
                                  for (BOOL k = v420; v189; v189 = *(void *)(v189 + 8))
                                  {
                                    uint64_t v190 = *(void *)(v189 + 24);
                                    unsigned int v191 = *(unsigned __int8 *)(v190 + 16);
                                    if (v190) {
                                      BOOL v192 = v191 >= 0x1C;
                                    }
                                    else {
                                      BOOL v192 = 0;
                                    }
                                    if (v192 && v191 - 29 < 0xB) {
                                      break;
                                    }
                                  }
                                  v464 = &v466;
                                  v465 = (void *)0x200000000;
                                  sub_1CBF846A4((uint64_t)&v464, v189, 0);
                                  if (v465) {
                                    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                                  }
                                  llvm::DomTreeUpdater::deleteBB((llvm::DomTreeUpdater *)v446, v436);
                                  if (v464 != &v466) {
                                    free(v464);
                                  }
LABEL_529:
                                  for (unint64_t m = 0; m != 0x7FFFFFFFFFFFFFC0; m -= 32)
                                  {
                                    v304 = &(&v473)[m / 4];
                                    if (LOBYTE(v475[m + 48]))
                                    {
                                      sub_1CC009394((uint64_t)(v304 + 11));
                                      MEMORY[0x1D25D9CD0](v304[11], 8);
                                      *((unsigned char *)v304 + 112) = 0;
                                    }
                                    v305 = v304 + 8;
                                    sub_1CC4D021C(v305);
                                    MEMORY[0x1D25D9CD0](*v305, 8);
                                  }
                                  LOBYTE(v36) = 1;
LABEL_534:
                                  sub_1CD63E2C8((char **)&v455);
                                  goto LABEL_57;
                                }
                                uint64_t v299 = *((void *)v436 + 6);
                                if (v299) {
                                  uint64_t v300 = v299 - 24;
                                }
                                else {
                                  uint64_t v300 = 0;
                                }
                                uint64_t v432 = v300;
                                uint64_t v6 = a2;
                                BOOL k = v420;
                                if (v428)
                                {
                                  uint64_t v301 = *(void *)(v300 + 40);
                                  *((void *)v428 + 5) = v301;
                                  *(_WORD *)(v301 + 18) &= ~0x8000u;
                                  if ((*((unsigned char *)v428 + 23) & 0x10) != 0)
                                  {
                                    uint64_t v400 = *(void *)(v301 + 56);
                                    if (v400)
                                    {
                                      v401 = *(llvm::ValueSymbolTable **)(v400 + 104);
                                      if (v401) {
                                        llvm::ValueSymbolTable::reinsertValue(v401, v428);
                                      }
                                    }
                                  }
                                  uint64_t v302 = *(void *)(v432 + 24);
                                  *((void *)v428 + 4) = v432 + 24;
                                  *((void *)v428 + 3) = v302;
                                  *(void *)(v302 + 8) = (char *)v428 + 24;
                                  *(void *)(v432 + 24) = (char *)v428 + 24;
                                  llvm::Value::doRAUW((llvm::ValueAsMetadata *)__p, v428, (llvm::Value *)1);
                                }
                                if (v15 == (char *)v436 + 40) {
                                  goto LABEL_529;
                                }
                                while (1)
                                {
                                  v306 = *(llvm::BasicBlock **)v15;
                                  if (!*((void *)v15 - 2)) {
                                    goto LABEL_624;
                                  }
                                  if (*(v15 - 8) != 83) {
                                    break;
                                  }
                                  unsigned int v15 = *(char **)v15;
                                  if (v306 == (llvm::BasicBlock *)((char *)v436 + 40)) {
                                    goto LABEL_529;
                                  }
                                }
                                uint64_t v307 = *((void *)v15 - 3);
                                int v308 = v456;
                                LOWORD(v468[0]) = 257;
                                v309 = operator new(0x48uLL);
                                v309[1] = v307;
                                void *v309 = 0;
                                v309[2] = 0;
                                v309[3] = 0x4000000000000053;
                                *((_OWORD *)v309 + 2) = 0u;
                                v434 = (char *)(v309 + 4);
                                *((_OWORD *)v309 + 3) = 0u;
                                *((_DWORD *)v309 + 16) = 0;
                                *((_DWORD *)v309 + 17) = v308;
                                v440 = (llvm::Value *)(v309 + 1);
                                llvm::Value::setNameImpl((llvm::Value *)(v309 + 1), (const char **)&v464);
                                if (!*((unsigned char *)v309 + 24))
                                {
                                  if ((*((unsigned char *)v309 + 31) & 0x10) == 0) {
                                    goto LABEL_659;
                                  }
                                  uint64_t v381 = ***(void ***)v440;
                                  uint64_t v382 = *(void *)(v381 + 152);
                                  uint64_t v383 = *(unsigned int *)(v381 + 168);
                                  if (v383)
                                  {
                                    LODWORD(v384) = (v383 - 1) & ((v440 >> 4) ^ (v440 >> 9));
                                    v385 = (llvm::Value **)(v382 + 16 * v384);
                                    v386 = *v385;
                                    if (*v385 != v440)
                                    {
                                      int v387 = 1;
                                      do
                                      {
                                        if (v386 == (llvm::Value *)-4096) {
                                          goto LABEL_651;
                                        }
                                        int v388 = v384 + v387++;
                                        uint64_t v384 = v388 & (v383 - 1);
                                        v386 = *(llvm::Value **)(v382 + 16 * v384);
                                      }
                                      while (v386 != v440);
                                      v385 = (llvm::Value **)(v382 + 16 * v384);
                                    }
                                  }
                                  else
                                  {
LABEL_651:
                                    v385 = (llvm::Value **)(v382 + 16 * v383);
                                  }
                                  v389 = v385[1];
                                  unint64_t v392 = *(void *)v389;
                                  v390 = (char *)v389 + 16;
                                  unint64_t v391 = v392;
                                  if (v392 >= 5
                                    && (*(_DWORD *)v390 == *(_DWORD *)"llvm."
                                      ? (BOOL v393 = v390[4] == aLlvm_1[4])
                                      : (BOOL v393 = 0),
                                        v393))
                                  {
                                    *((_DWORD *)v309 + 10) |= 0x2000u;
                                    int v394 = llvm::Function::lookupIntrinsicID(v390, v391);
                                  }
                                  else
                                  {
LABEL_659:
                                    int v394 = 0;
                                    *((_DWORD *)v309 + 10) &= ~0x2000u;
                                  }
                                  *((_DWORD *)v309 + 11) = v394;
                                }
                                uint64_t v310 = *((unsigned int *)v309 + 17);
                                v311 = operator new(40 * v310);
                                void *v309 = v311;
                                if (v310)
                                {
                                  v312 = &v311[4 * v310];
                                  do
                                  {
                                    void *v311 = 0;
                                    v311[1] = 0;
                                    v311[2] = 0;
                                    v311[3] = v440;
                                    v311 += 4;
                                  }
                                  while (v311 != v312);
                                }
                                v313 = (void *)*((void *)v15 + 3);
                                v461 = v313;
                                if (v313) {
                                  llvm::MetadataTracking::track((uint64_t)&v461, (unsigned __int8 *)v313, 2);
                                }
                                v314 = (unsigned __int8 *)v309[7];
                                if (!v314)
                                {
LABEL_544:
                                  v315 = (unsigned __int8 *)v461;
                                  v309[7] = v461;
                                  if (v315)
                                  {
                                    llvm::MetadataTracking::retrack((uint64_t)&v461, v315, (uint64_t)(v309 + 7));
                                    v461 = 0;
                                  }
                                  char v316 = 0;
                                  uint64_t v317 = 0;
                                  do
                                  {
                                    char v445 = v316;
                                    v465 = (void *)2;
                                    uint64_t v466 = 0;
                                    uint64_t v467 = (uint64_t)(v15 - 24);
                                    if (v15 != (char *)-8168 && v15 != (char *)-4072 && v15 != (char *)24) {
                                      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v465);
                                    }
                                    v318 = &(&v473)[8 * v317];
                                    v464 = &unk_1F2615EC8;
                                    v468[0] = v318;
                                    v319 = sub_1CC4CFF80((uint64_t)v318, &v464);
                                    if (v467 != -8192 && v467 != -4096 && v467 != 0)
                                    {
                                      unint64_t v321 = (unint64_t)v465 & 0xFFFFFFFFFFFFFFF8;
                                      *(void *)((unint64_t)v465 & 0xFFFFFFFFFFFFFFF8) = v466;
                                      if (v466)
                                      {
                                        *(void *)uint64_t v466 = *(void *)v466 & 7 | v321;
                                      }
                                      else
                                      {
                                        uint64_t v322 = v467;
                                        v323 = ***(int32x2_t ****)v467;
                                        unint64_t v324 = (unint64_t)v323[303];
                                        if (v324 <= v321)
                                        {
                                          uint64_t v325 = v323[305].u32[0];
                                          if (v324 + 16 * v325 > v321)
                                          {
                                            unsigned int v326 = v325 - 1;
                                            LODWORD(v327) = v326 & ((v467 >> 4) ^ (v467 >> 9));
                                            v328 = (uint64_t *)(v324 + 16 * v327);
                                            uint64_t v329 = *v328;
                                            if (v467 != *v328)
                                            {
                                              int v330 = 1;
                                              do
                                              {
                                                if (v329 == -4096) {
                                                  goto LABEL_565;
                                                }
                                                int v331 = v327 + v330++;
                                                uint64_t v327 = v331 & v326;
                                                uint64_t v329 = *(void *)(v324 + 16 * v327);
                                              }
                                              while (v467 != v329);
                                              v328 = (uint64_t *)(v324 + 16 * v327);
                                            }
                                            uint64_t *v328 = -8192;
                                            v323[304] = vadd_s32(v323[304], (int32x2_t)0x1FFFFFFFFLL);
                                            uint64_t v322 = v467;
LABEL_565:
                                            *(unsigned char *)(v322 + 17) &= ~1u;
                                          }
                                        }
                                      }
                                    }
                                    uint64_t v332 = v319[7];
                                    v465 = (void *)2;
                                    uint64_t v466 = 0;
                                    uint64_t v467 = (uint64_t)(v15 - 24);
                                    if (v15 != (char *)-8168 && v15 != (char *)-4072 && v15 != (char *)24) {
                                      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v465);
                                    }
                                    v464 = &unk_1F2615EC8;
                                    v468[0] = v318;
                                    v333 = sub_1CC4CFF80((uint64_t)v318, &v464);
                                    if (v467 != -8192 && v467 != -4096 && v467)
                                    {
                                      unint64_t v334 = (unint64_t)v465 & 0xFFFFFFFFFFFFFFF8;
                                      *(void *)((unint64_t)v465 & 0xFFFFFFFFFFFFFFF8) = v466;
                                      if (v466)
                                      {
                                        *(void *)uint64_t v466 = *(void *)v466 & 7 | v334;
                                      }
                                      else
                                      {
                                        uint64_t v335 = v467;
                                        v336 = ***(int32x2_t ****)v467;
                                        unint64_t v337 = (unint64_t)v336[303];
                                        if (v337 <= v334)
                                        {
                                          uint64_t v338 = v336[305].u32[0];
                                          if (v337 + 16 * v338 > v334)
                                          {
                                            unsigned int v339 = v338 - 1;
                                            LODWORD(v340) = v339 & ((v467 >> 4) ^ (v467 >> 9));
                                            v341 = (uint64_t *)(v337 + 16 * v340);
                                            uint64_t v342 = *v341;
                                            if (v467 != *v341)
                                            {
                                              int v343 = 1;
                                              do
                                              {
                                                if (v342 == -4096) {
                                                  goto LABEL_583;
                                                }
                                                int v344 = v340 + v343++;
                                                uint64_t v340 = v344 & v339;
                                                uint64_t v342 = *(void *)(v337 + 16 * v340);
                                              }
                                              while (v467 != v342);
                                              v341 = (uint64_t *)(v337 + 16 * v340);
                                            }
                                            uint64_t *v341 = -8192;
                                            v336[304] = vadd_s32(v336[304], (int32x2_t)0x1FFFFFFFFLL);
                                            uint64_t v335 = v467;
LABEL_583:
                                            *(unsigned char *)(v335 + 17) &= ~1u;
                                          }
                                        }
                                      }
                                    }
                                    uint64_t v345 = *(void *)(v333[7] + 40);
                                    int v346 = *((_DWORD *)v309 + 7);
                                    uint64_t v347 = v346 & 0x7FFFFFF;
                                    if ((v346 & 0x7FFFFFF) == *((_DWORD *)v309 + 17))
                                    {
                                      unsigned int v360 = v347 + (v347 >> 1);
                                      if (v360 <= 2) {
                                        uint64_t v361 = 2;
                                      }
                                      else {
                                        uint64_t v361 = v360;
                                      }
                                      *((_DWORD *)v309 + 17) = v361;
                                      if ((v346 & 0x40000000) != 0) {
                                        v362 = (uint64_t *)*v309;
                                      }
                                      else {
                                        v362 = (uint64_t *)((char *)v440 - 32 * v347);
                                      }
                                      __pa = v362;
                                      v363 = operator new(40 * v361);
                                      void *v309 = v363;
                                      v364 = v363;
                                      do
                                      {
                                        void *v364 = 0;
                                        v364[1] = 0;
                                        v364[2] = 0;
                                        v364[3] = v440;
                                        v364 += 4;
                                      }
                                      while (v364 != &v363[4 * v361]);
                                      int v365 = *((_DWORD *)v309 + 7);
                                      if ((v365 & 0x40000000) != 0) {
                                        uint64_t v366 = (uint64_t)v363;
                                      }
                                      else {
                                        uint64_t v366 = (uint64_t)v440 - 32 * (v365 & 0x7FFFFFF);
                                      }
                                      sub_1CC5E4108((uint64_t)&v464, __pa, &__pa[4 * v347], v366);
                                      if (v347)
                                      {
                                        memmove((void *)(v366 + 32 * v361), &__pa[4 * v347], 8 * v347);
                                        uint64_t v367 = 4 * v347;
                                        do
                                        {
                                          v368 = &__pa[v367];
                                          if (__pa[v367 - 4])
                                          {
                                            *(void *)*(v368 - 2) = *(v368 - 3);
                                            uint64_t v369 = *(v368 - 3);
                                            if (v369) {
                                              *(void *)(v369 + 16) = *(v368 - 2);
                                            }
                                          }
                                          v367 -= 4;
                                        }
                                        while (v367 * 8);
                                      }
                                      operator delete(__pa);
                                      int v346 = *((_DWORD *)v309 + 7);
                                    }
                                    uint64_t v348 = (v346 + 1) & 0x7FFFFFF;
                                    *((_DWORD *)v309 + 7) = v346 & 0xF8000000 | (v346 + 1) & 0x7FFFFFF;
                                    if ((v346 & 0x40000000) != 0) {
                                      v349 = (char *)*v309;
                                    }
                                    else {
                                      v349 = (char *)v440 - 32 * v348;
                                    }
                                    uint64_t v350 = (v348 - 1);
                                    v351 = &v349[32 * v350];
                                    if (*(void *)v351)
                                    {
                                      **((void **)v351 + 2) = *((void *)v351 + 1);
                                      uint64_t v359 = *((void *)v351 + 1);
                                      if (v359) {
                                        *(void *)(v359 + 16) = *((void *)v351 + 2);
                                      }
                                    }
                                    *(void *)v351 = v332;
                                    if (v332)
                                    {
                                      uint64_t v354 = *(void *)(v332 + 8);
                                      v353 = (char **)(v332 + 8);
                                      uint64_t v352 = v354;
                                      v355 = &v349[32 * v350];
                                      *((void *)v355 + 1) = v354;
                                      if (v354) {
                                        *(void *)(v352 + 16) = v355 + 8;
                                      }
                                      *((void *)v355 + 2) = v353;
                                      *v353 = v351;
                                    }
                                    int v356 = *((_DWORD *)v309 + 7);
                                    uint64_t v357 = v356 & 0x7FFFFFF;
                                    if ((v356 & 0x40000000) != 0) {
                                      v358 = (char *)*v309;
                                    }
                                    else {
                                      v358 = (char *)v440 - 32 * v357;
                                    }
                                    *(void *)&v358[32 * *((unsigned int *)v309 + 17) + 8 * (v357 - 1)] = v345;
                                    char v316 = 1;
                                    uint64_t v317 = 1;
                                  }
                                  while ((v445 & 1) == 0);
                                  uint64_t v370 = *((void *)v436 + 6);
                                  if (v370) {
                                    uint64_t v371 = v370 - 24;
                                  }
                                  else {
                                    uint64_t v371 = 0;
                                  }
                                  uint64_t v372 = *(void *)(v371 + 40);
                                  v309[6] = v372;
                                  *(_WORD *)(v372 + 18) &= ~0x8000u;
                                  if ((*((unsigned char *)v309 + 31) & 0x10) != 0)
                                  {
                                    uint64_t v378 = *(void *)(v372 + 56);
                                    if (v378)
                                    {
                                      v379 = *(llvm::ValueSymbolTable **)(v378 + 104);
                                      if (v379) {
                                        llvm::ValueSymbolTable::reinsertValue(v379, v440);
                                      }
                                    }
                                  }
                                  uint64_t v374 = *(void *)(v371 + 24);
                                  v373 = (void *)(v371 + 24);
                                  v309[4] = v374;
                                  v309[5] = v373;
                                  *(void *)(v374 + 8) = v434;
                                  void *v373 = v434;
                                  llvm::Value::doRAUW((llvm::ValueAsMetadata *)(v15 - 24), v440, (llvm::Value *)1);
LABEL_624:
                                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                                }
                                int v375 = *v314;
                                if ((v375 - 4) > 0x1E)
                                {
                                  if ((v375 - 3) >= 0xFFFFFFFE) {
                                    uint64_t v380 = v309[7];
                                  }
                                  else {
                                    uint64_t v380 = 0;
                                  }
                                  if ((v375 - 3) < 0xFFFFFFFE)
                                  {
                                    if (v375 == 3) {
                                      *((void *)v314 + 1) = 0;
                                    }
                                    goto LABEL_544;
                                  }
                                  unint64_t v377 = v380 + 8;
                                }
                                else
                                {
                                  if ((v314[1] & 0x7F) != 2 && !*((_DWORD *)v314 + 3)) {
                                    goto LABEL_544;
                                  }
                                  uint64_t v376 = *((void *)v314 + 2);
                                  if ((v376 & 4) == 0) {
                                    goto LABEL_544;
                                  }
                                  unint64_t v377 = v376 & 0xFFFFFFFFFFFFFFF8;
                                  if (!v377) {
                                    goto LABEL_544;
                                  }
                                }
                                v464 = v309 + 7;
                                sub_1CC5FA668(v377 + 16, &v464);
                                goto LABEL_544;
                              }
                              uint64_t v194 = 0;
                              uint64_t v429 = v5;
                              while (1)
                              {
                                uint64_t v195 = 56 * v194;
                                uint64_t v196 = *((void *)v15 + 1);
                                if (v196) {
                                  BOOL v197 = (int32x2_t ****)(v196 - 24);
                                }
                                else {
                                  BOOL v197 = 0;
                                }
                                uint64_t v433 = v194;
                                v435 = llvm::DuplicateInstructionsInSplitBetween((unint64_t)v436, *((llvm **)v455 + 7 * v194), v197, (uint64_t)&(&v473)[8 * v194], (uint64_t)v446, v169, v170);
                                uint64_t v198 = *((void *)v435 + 5);
                                uint64_t v199 = v198 - 24;
                                if (v198) {
                                  uint64_t v200 = v199;
                                }
                                else {
                                  uint64_t v200 = 0;
                                }
                                if (*(unsigned __int8 *)(v200 + 16) - 29 >= 0xB) {
                                  uint64_t v200 = 0;
                                }
                                uint64_t v201 = *(void *)(v200 + 24);
                                v430 = (void *)((char *)v435 + 40);
                                uint64_t v431 = v201;
                                v202 = v201 ? (llvm::Value *)(v201 - 24) : 0;
                                uint64_t v203 = *(unsigned int *)((char *)v455 + v195 + 16);
                                if (v203) {
                                  break;
                                }
LABEL_425:
                                v241 = v15 - 56;
                                v242 = v428;
                                uint64_t v243 = (uint64_t)v435;
                                if (*((llvm::BasicBlock **)v436 + 5) != (llvm::BasicBlock *)((char *)v436 + 40))
                                {
                                  for (uint64_t n = *((void *)v436 + 6); ; uint64_t n = *(void *)(v245 + 32))
                                  {
                                    uint64_t v245 = n - 24;
                                    uint64_t v246 = n ? n - 24 : 0;
                                    if (!n || *(unsigned char *)(v246 + 16) != 83) {
                                      break;
                                    }
                                    uint64_t v247 = 0;
                                    int v248 = *(v15 - 8);
                                    if (v248 != 84)
                                    {
                                      if (v248 == 39) {
                                        uint64_t v247 = (*((_DWORD *)v15 + 14) + 1);
                                      }
                                      else {
                                        uint64_t v247 = 2;
                                      }
                                      v241 = v15 - 56;
                                      v242 = v428;
                                      uint64_t v243 = (uint64_t)v435;
                                    }
                                    int v249 = *((_DWORD *)v15 - 1);
                                    uint64_t v250 = v249 & 0x7FFFFFF;
                                    v251 = &__p[-32 * v250];
                                    if (v249 < 0)
                                    {
                                      if ((*(void *)&v15[-32 * v250 - 32] & 0xFFFFFFFF0) != 0) {
                                        uint64_t v252 = (*((_DWORD *)v251 - 3)
                                      }
                                                            - *(_DWORD *)&v251[-*((void *)v251 - 1)]);
                                      else {
                                        uint64_t v252 = 0;
                                      }
                                      v241 = v15 - 56;
                                      v242 = v428;
                                      uint64_t v243 = (uint64_t)v435;
                                    }
                                    else
                                    {
                                      uint64_t v252 = 0;
                                    }
                                    if (v251 != &v241[-32 * v247 + -32 * v252])
                                    {
                                      int v253 = 0;
                                      uint64_t v254 = 32 * v250 - 32 * v247 - 32 * v252 - 32;
                                      do
                                      {
                                        if (*(void *)v251 == v245)
                                        {
                                          uint64_t v255 = sub_1CBF73380(v245, v243);
                                          uint64_t v256 = (char *)v202 - 32 * (*((_DWORD *)v202 + 5) & 0x7FFFFFF);
                                          v257 = &v256[32 * v253];
                                          if (*(void *)v257)
                                          {
                                            **((void **)v257 + 2) = *((void *)v257 + 1);
                                            uint64_t v258 = *((void *)v257 + 1);
                                            if (v258) {
                                              *(void *)(v258 + 16) = *((void *)v257 + 2);
                                            }
                                          }
                                          *(void *)v257 = v255;
                                          if (v255)
                                          {
                                            uint64_t v261 = *(void *)(v255 + 8);
                                            unsigned int v259 = (char **)(v255 + 8);
                                            uint64_t v260 = v261;
                                            v262 = &v256[32 * v253];
                                            *((void *)v262 + 1) = v261;
                                            if (v261) {
                                              *(void *)(v260 + 16) = v262 + 8;
                                            }
                                            *((void *)v262 + 2) = v259;
                                            *unsigned int v259 = v257;
                                          }
                                        }
                                        ++v253;
                                        v251 += 32;
                                        v254 -= 32;
                                      }
                                      while (v254);
                                    }
                                  }
                                }
                                uint64_t v5 = v429;
                                if (v242)
                                {
                                  int v263 = *((_DWORD *)v242 + 5);
                                  uint64_t v264 = v263 & 0x7FFFFFF;
                                  if ((v263 & 0x7FFFFFF) == *((_DWORD *)v242 + 15))
                                  {
                                    unsigned int v289 = v264 + (v264 >> 1);
                                    if (v289 <= 2) {
                                      uint64_t v290 = 2;
                                    }
                                    else {
                                      uint64_t v290 = v289;
                                    }
                                    *((_DWORD *)v242 + 15) = v290;
                                    if ((v263 & 0x40000000) != 0) {
                                      v291 = (uint64_t *)*((void *)v242 - 1);
                                    }
                                    else {
                                      v291 = (uint64_t *)((char *)v242 - 32 * v264);
                                    }
                                    v292 = operator new(40 * v290);
                                    *((void *)v242 - 1) = v292;
                                    v293 = v292;
                                    do
                                    {
                                      void *v293 = 0;
                                      v293[1] = 0;
                                      v293[2] = 0;
                                      v293[3] = v242;
                                      v293 += 4;
                                    }
                                    while (v293 != &v292[4 * v290]);
                                    int v294 = *((_DWORD *)v242 + 5);
                                    if ((v294 & 0x40000000) != 0) {
                                      uint64_t v295 = (uint64_t)v292;
                                    }
                                    else {
                                      uint64_t v295 = (uint64_t)v242 - 32 * (v294 & 0x7FFFFFF);
                                    }
                                    sub_1CC5E4108((uint64_t)&v464, v291, &v291[4 * v264], v295);
                                    if (v264)
                                    {
                                      memmove((void *)(v295 + 32 * v290), &v291[4 * v264], 8 * v264);
                                      uint64_t v296 = 4 * v264;
                                      do
                                      {
                                        v297 = &v291[v296];
                                        if (v291[v296 - 4])
                                        {
                                          *(void *)*(v297 - 2) = *(v297 - 3);
                                          uint64_t v298 = *(v297 - 3);
                                          if (v298) {
                                            *(void *)(v298 + 16) = *(v297 - 2);
                                          }
                                        }
                                        v296 -= 4;
                                      }
                                      while (v296 * 8);
                                    }
                                    operator delete(v291);
                                    v242 = v428;
                                    int v263 = *((_DWORD *)v428 + 5);
                                    uint64_t v243 = (uint64_t)v435;
                                  }
                                  uint64_t v265 = (v263 + 1) & 0x7FFFFFF;
                                  *((_DWORD *)v242 + 5) = v263 & 0xF8000000 | (v263 + 1) & 0x7FFFFFF;
                                  if ((v263 & 0x40000000) != 0) {
                                    v266 = (char *)*((void *)v242 - 1);
                                  }
                                  else {
                                    v266 = (char *)v242 - 32 * v265;
                                  }
                                  uint64_t v267 = (v265 - 1);
                                  v268 = &v266[32 * v267];
                                  if (*(void *)v268)
                                  {
                                    **((void **)v268 + 2) = *((void *)v268 + 1);
                                    uint64_t v288 = *((void *)v268 + 1);
                                    if (v288) {
                                      *(void *)(v288 + 16) = *((void *)v268 + 2);
                                    }
                                  }
                                  *(void *)v268 = v202;
                                  if (v431)
                                  {
                                    v270 = (char **)(v431 - 16);
                                    uint64_t v269 = *(void *)(v431 - 16);
                                    v271 = &v266[32 * v267];
                                    *((void *)v271 + 1) = v269;
                                    if (v269) {
                                      *(void *)(v269 + 16) = v271 + 8;
                                    }
                                    *((void *)v271 + 2) = v270;
                                    void *v270 = v268;
                                  }
                                  int v272 = *((_DWORD *)v242 + 5);
                                  uint64_t v273 = v272 & 0x7FFFFFF;
                                  if ((v272 & 0x40000000) != 0) {
                                    unsigned int v274 = (char *)*((void *)v242 - 1);
                                  }
                                  else {
                                    unsigned int v274 = (char *)v242 - 32 * v273;
                                  }
                                  *(void *)&v274[32 * *((unsigned int *)v242 + 15) + 8 * (v273 - 1)] = v243;
                                }
                                if (v427)
                                {
                                  uint64_t v275 = *((void *)v15 + 1);
                                  int v276 = (unsigned __int8 *)(v275 - 24);
                                  if (!v275) {
                                    int v276 = 0;
                                  }
                                  int v277 = v276[16];
                                  if (v277 == 77) {
                                    v278 = (llvm::Instruction *)v276;
                                  }
                                  else {
                                    v278 = 0;
                                  }
                                  BOOL v279 = v277 != 77 || v275 == 0;
                                  if (!v279) {
                                    uint64_t v275 = *(void *)(v275 + 8);
                                  }
                                  if (v275) {
                                    v280 = (unsigned __int8 *)(v275 - 24);
                                  }
                                  else {
                                    v280 = 0;
                                  }
                                  int v281 = (void *)*v430;
                                  if ((void *)*v430 == v430)
                                  {
                                    uint64_t v283 = 0;
                                  }
                                  else
                                  {
                                    if (v281) {
                                      uint64_t v282 = (uint64_t)(v281 - 3);
                                    }
                                    else {
                                      uint64_t v282 = 0;
                                    }
                                    if (*(unsigned __int8 *)(v282 + 16) - 29 >= 0xB) {
                                      uint64_t v283 = 0;
                                    }
                                    else {
                                      uint64_t v283 = v282;
                                    }
                                  }
                                  int v284 = *(unsigned __int8 *)(**(void **)(*(void *)(*(void *)(v243 + 56) + 24)
                                                                          + 16)
                                                            + 8);
                                  int v285 = v280[16];
                                  if (!v279) {
                                    v202 = sub_1CCD19A50(v278, v283, (uint64_t)v202);
                                  }
                                  if (v285 == 29) {
                                    v286 = (llvm::Instruction *)v280;
                                  }
                                  else {
                                    v286 = 0;
                                  }
                                  if (v284 == 7) {
                                    uint64_t v287 = 0;
                                  }
                                  else {
                                    uint64_t v287 = (uint64_t)v202;
                                  }
                                  sub_1CCD19A50(v286, v283, v287);
                                }
                                uint64_t v194 = v433 + 1;
                                if (v433 + 1 >= (unint64_t)v456) {
                                  goto LABEL_338;
                                }
                              }
                              int v204 = *(llvm::Value **)((char *)v455 + v195 + 8);
                              v438 = (char *)v202 - 32;
                              v439 = (llvm::Value *)((char *)v204 + 16 * v203);
                              v444 = (uint64_t *)((char *)v202 + 64);
                              while (2)
                              {
                                uint64_t v205 = *(void *)(*(void *)v204 - 64);
                                uint64_t v206 = *(void *)(*(void *)v204 - 32);
                                if (*((_DWORD *)v204 + 2) == 32)
                                {
                                  int v207 = *((unsigned __int8 *)v202 + 16);
                                  if (v207 == 84)
                                  {
                                    uint64_t v208 = 0;
                                  }
                                  else if (v207 == 39)
                                  {
                                    uint64_t v208 = (*((_DWORD *)v202 + 20) + 1);
                                  }
                                  else
                                  {
                                    uint64_t v208 = 2;
                                  }
                                  int v209 = *((_DWORD *)v202 + 5);
                                  uint64_t v210 = v209 & 0x7FFFFFF;
                                  uint64_t v211 = (char *)v202 - 32 * v210;
                                  if (v209 < 0 && (uint64_t v239 = *((void *)v211 - 1), (v239 & 0xFFFFFFFF0) != 0)) {
                                    uint64_t v212 = (*((_DWORD *)v211 - 3) - *(_DWORD *)&v211[-v239]);
                                  }
                                  else {
                                    uint64_t v212 = 0;
                                  }
                                  if (v211 != &v438[-32 * v208 + -32 * v212])
                                  {
                                    int v213 = 0;
                                    v214 = (char **)(v206 + 8);
                                    unint64_t v215 = (32 * v208 + 32 * v212) ^ 0xFFFFFFFFFFFFFFE0;
                                    uint64_t v216 = -32 * v210;
                                    do
                                    {
                                      if (*(void *)((char *)v202 + v216) == v205)
                                      {
                                        int v217 = v213 + 1;
                                        *((void *)v202 + 8) = llvm::AttributeList::removeAttributeAtIndex(v444, **(uint64_t ***)v202, v213 + 1, 39);
                                        v218 = (char *)v202 - 32 * (*((_DWORD *)v202 + 5) & 0x7FFFFFF);
                                        v219 = &v218[32 * v213];
                                        if (*(void *)v219)
                                        {
                                          **((void **)v219 + 2) = *((void *)v219 + 1);
                                          uint64_t v220 = *((void *)v219 + 1);
                                          if (v220) {
                                            *(void *)(v220 + 16) = *((void *)v219 + 2);
                                          }
                                        }
                                        *(void *)v219 = v206;
                                        if (v206)
                                        {
                                          uint64_t v221 = *v214;
                                          v222 = &v218[32 * v213];
                                          *((void *)v222 + 1) = *v214;
                                          if (v221) {
                                            *((void *)v221 + 2) = v222 + 8;
                                          }
                                          *((void *)v222 + 2) = v214;
                                          uint64_t *v214 = v219;
                                        }
                                      }
                                      else
                                      {
                                        int v217 = v213 + 1;
                                      }
                                      v216 += 32;
                                      int v213 = v217;
                                    }
                                    while (v215 != v216);
                                  }
                                  goto LABEL_404;
                                }
                                if (*(unsigned char *)(*(void *)v206 + 8) != 15) {
                                  goto LABEL_404;
                                }
                                int v223 = *(unsigned __int8 *)(v206 + 16);
                                if (v223 == 16)
                                {
                                  uint64_t v224 = *(unsigned int *)(v206 + 32);
                                  if (v224 < 0x41)
                                  {
                                    if (*(void *)(v206 + 24)) {
                                      goto LABEL_404;
                                    }
                                    goto LABEL_389;
                                  }
                                  int v235 = 0;
                                  int64_t v236 = (unint64_t)(v224 + 63) >> 6;
                                  do
                                  {
                                    BOOL v87 = v236-- < 1;
                                    if (v87) {
                                      break;
                                    }
                                    unint64_t v237 = *(void *)(*(void *)(v206 + 24) + 8 * v236);
                                    v235 += __clz(v237);
                                  }
                                  while (!v237);
                                  int v238 = v224 | 0xFFFFFFC0;
                                  if ((v224 & 0x3F) == 0) {
                                    int v238 = 0;
                                  }
                                  if (v235 + v238 == v224) {
                                    goto LABEL_389;
                                  }
                                }
                                else
                                {
                                  if (v223 == 17)
                                  {
                                    if ((sub_1CB844168(*(void *)(*(void *)v204 - 32), 0.0) & 1) == 0) {
                                      goto LABEL_404;
                                    }
                                  }
                                  else if ((v223 - 18) >= 3 && v223 != 13)
                                  {
                                    goto LABEL_404;
                                  }
LABEL_389:
                                  int v225 = *((unsigned __int8 *)v202 + 16);
                                  if (v225 == 84)
                                  {
                                    uint64_t v226 = 0;
                                  }
                                  else if (v225 == 39)
                                  {
                                    uint64_t v226 = (*((_DWORD *)v202 + 20) + 1);
                                  }
                                  else
                                  {
                                    uint64_t v226 = 2;
                                  }
                                  int v227 = *((_DWORD *)v202 + 5);
                                  uint64_t v228 = v227 & 0x7FFFFFF;
                                  uint64_t v229 = (char *)v202 - 32 * v228;
                                  if (v227 < 0 && (uint64_t v240 = *((void *)v229 - 1), (v240 & 0xFFFFFFFF0) != 0)) {
                                    uint64_t v230 = (*((_DWORD *)v229 - 3) - *(_DWORD *)&v229[-v240]);
                                  }
                                  else {
                                    uint64_t v230 = 0;
                                  }
                                  if (v229 != &v438[-32 * v226 + -32 * v230])
                                  {
                                    int v231 = 0;
                                    unint64_t v232 = (32 * v226 + 32 * v230) ^ 0xFFFFFFFFFFFFFFE0;
                                    uint64_t v233 = -32 * v228;
                                    do
                                    {
                                      ++v231;
                                      if (*(void *)((char *)v202 + v233) == v205) {
                                        *((void *)v202 + 8) = llvm::AttributeList::addAttributeAtIndex(v444, **(uint64_t ***)v202, v231, 39);
                                      }
                                      v233 += 32;
                                    }
                                    while (v232 != v233);
                                  }
                                }
LABEL_404:
                                int v204 = (llvm::Value *)((char *)v204 + 16);
                                if (v204 == v439) {
                                  goto LABEL_425;
                                }
                                continue;
                              }
                            }
                            goto LABEL_265;
                          }
LABEL_246:
                          v455 = v457;
                          uint64_t v456 = 0x200000000;
                          goto LABEL_247;
                        }
                        continue;
                      }
                      break;
                    }
                    sub_1CCD19818((uint64_t)__p, SinglePredecessor, v96, (uint64_t)&v461);
                    char v111 = (char *)v465;
                    uint64_t v112 = HIDWORD(v466);
                    if (v465 != v464)
                    {
                      unsigned int v116 = v466;
                      goto LABEL_204;
                    }
                    if (!HIDWORD(v466)) {
                      goto LABEL_201;
                    }
                    unsigned int v113 = 0;
                    uint64_t v114 = 8 * HIDWORD(v466);
                    uint64_t v115 = (llvm::BasicBlock **)v465;
                    do
                    {
                      if (*v115 == v95) {
                        goto LABEL_225;
                      }
                      if (*v115 == (llvm::BasicBlock *)-2) {
                        unsigned int v113 = v115;
                      }
                      ++v115;
                      v114 -= 8;
                    }
                    while (v114);
                    if (!v113)
                    {
LABEL_201:
                      unsigned int v116 = v466;
                      if (HIDWORD(v466) < v466)
                      {
                        ++HIDWORD(v466);
                        *((void *)v465 + v112) = v95;
                        goto LABEL_225;
                      }
LABEL_204:
                      if (3 * v116 <= 4 * (HIDWORD(v466) - (int)v467))
                      {
                        if (v116 >= 0x40) {
                          v116 *= 2;
                        }
                        else {
                          unsigned int v116 = 128;
                        }
                      }
                      else if (v116 - HIDWORD(v466) >= v116 >> 3)
                      {
LABEL_206:
                        unsigned int v117 = v116 - 1;
                        unsigned int v118 = (v116 - 1) & ((v95 >> 4) ^ (v95 >> 9));
                        unint64_t v119 = &v111[8 * v118];
                        uint64_t v120 = *(llvm::BasicBlock **)v119;
                        if (*(void *)v119 == -1)
                        {
                          uint64_t v121 = 0;
LABEL_218:
                          if (v121) {
                            uint64_t v125 = v121;
                          }
                          else {
                            uint64_t v125 = (llvm::BasicBlock **)v119;
                          }
                          if (*v125 != v95)
                          {
                            if (*v125 == (llvm::BasicBlock *)-2) {
                              LODWORD(v467) = v467 - 1;
                            }
                            else {
                              ++HIDWORD(v466);
                            }
                            *uint64_t v125 = v95;
                          }
                        }
                        else
                        {
                          uint64_t v121 = 0;
                          int v122 = 1;
                          while (v120 != v95)
                          {
                            if (v121) {
                              BOOL v123 = 0;
                            }
                            else {
                              BOOL v123 = v120 == (llvm::BasicBlock *)-2;
                            }
                            if (v123) {
                              uint64_t v121 = (llvm::BasicBlock **)v119;
                            }
                            unsigned int v124 = v118 + v122++;
                            unsigned int v118 = v124 & v117;
                            unint64_t v119 = &v111[8 * (v124 & v117)];
                            uint64_t v120 = *(llvm::BasicBlock **)v119;
                            if (*(void *)v119 == -1) {
                              goto LABEL_218;
                            }
                          }
                        }
LABEL_225:
                        uint64_t v94 = v465;
                        uint64_t v93 = v464;
                        if (v95 == v74) {
                          goto LABEL_233;
                        }
                        goto LABEL_163;
                      }
                      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v464, v116);
                      unsigned int v116 = v466;
                      char v111 = (char *)v465;
                      goto LABEL_206;
                    }
                    *unsigned int v113 = v95;
                    LODWORD(v467) = v467 - 1;
                    goto LABEL_225;
                  }
                }
LABEL_112:
                v437 |= v36;
                uint64_t v4 = v426;
                if (k) {
                  break;
                }
              }
            }
          }
        }
      }
      if (v5 == v4) {
        goto LABEL_710;
      }
    }
  }
  char v437 = 0;
LABEL_710:
  sub_1CC2930C0((uint64_t)v446);
  return v437 & 1;
}

void sub_1CCD192B8()
{
}

void sub_1CCD192F8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD19330(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t sub_1CCD193A8(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2) & 1) == 0)
  {
    uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(char **)v6 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    int v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    int v21 = 0;
    uint64_t v10 = v9 + 32;
    if (!*(unsigned char *)(v9 + 232))
    {
      uint64_t v11 = *(void *)(a2 + 40) + 216;
      __int16 v23 = 260;
      v22[0] = v11;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v22);
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      int v35 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      *(void *)&long long v12 = -1;
      *((void *)&v12 + 1) = -1;
      *(_OWORD *)__src = v12;
      long long v27 = v12;
      long long v28 = v12;
      long long v29 = v12;
      long long v30 = v12;
      long long v31 = v12;
      *(_OWORD *)int v32 = v12;
      *(void *)&v32[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v10, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v10);
  }
  return 0;
}

uint64_t sub_1CCD197D4(void *a1, uint64_t a2)
{
  for (; a2; a2 = *(void *)(a2 + 8))
  {
    uint64_t v2 = *(void *)(a2 + 24);
    unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
    if (v2) {
      BOOL v4 = v3 >= 0x1C;
    }
    else {
      BOOL v4 = 0;
    }
    if (v4 && v3 - 29 < 0xB) {
      break;
    }
  }
  *a1 = a1 + 2;
  a1[1] = 0x200000000;
  return sub_1CBF846A4((uint64_t)a1, a2, 0);
}

uint64_t sub_1CCD19818(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)(a2 + 40);
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4 != a2 + 40)
  {
    uint64_t v6 = v4 - 24;
    if (!v4) {
      uint64_t v6 = 0;
    }
    unsigned int v7 = *(unsigned __int8 *)(v6 + 16) - 40;
    if (v7 < 0xFFFFFFF5) {
      uint64_t v6 = 0;
    }
    if (v4)
    {
      if (*(unsigned char *)(v6 + 16) == 30 && v7 >= 0xFFFFFFF5 && (*(_DWORD *)(v6 + 20) & 0x7FFFFFF) == 3)
      {
        uint64_t v9 = *(void *)(v6 - 96);
        if (v9)
        {
          if (*(unsigned char *)(v9 + 16) == 81 && *(unsigned __int8 *)(*(void *)(v9 - 32) + 16) <= 0x14u)
          {
            __int16 v10 = *(_WORD *)(v9 + 18);
            if ((v10 & 0x3E) == 0x20)
            {
              uint64_t v13 = result;
              int v14 = *(_DWORD *)(result + 20);
              uint64_t v15 = v14 & 0x7FFFFFF;
              int v16 = *(unsigned __int8 *)(result + 16);
              if (v16 == 84) {
                uint64_t v17 = 0;
              }
              else {
                uint64_t v17 = v16 == 39 ? (*(_DWORD *)(result + 80) + 1) : 2;
              }
              uint64_t v18 = result - 32 * v15;
              if (v14 < 0 && (uint64_t v30 = *(void *)(v18 - 8), (v30 & 0xFFFFFFFF0) != 0)) {
                uint64_t v19 = (*(_DWORD *)(v18 - 12) - *(_DWORD *)(v18 - v30));
              }
              else {
                uint64_t v19 = 0;
              }
              if (v18 != result - 32 * v17 - 32 * v19 - 32)
              {
                int v20 = 0;
                unsigned int v21 = v10 & 0x3F;
                uint64_t v22 = *(void *)(v9 - 64);
                unint64_t v23 = (32 * v17 + 32 * v19) ^ 0xFFFFFFFFFFFFFFE0;
                uint64_t v24 = -32 * v15;
                while (1)
                {
                  if (*(unsigned __int8 *)(*(void *)(v13 + v24) + 16) >= 0x15u)
                  {
                    uint64_t result = llvm::CallBase::paramHasAttr(v13, v20, 39);
                    if ((result & 1) == 0 && *(void *)(v13 + v24) == v22) {
                      break;
                    }
                  }
                  ++v20;
                  v24 += 32;
                  if (v23 == v24) {
                    return result;
                  }
                }
                char v25 = (void *)*v5;
                if ((void *)*v5 == v5)
                {
                  long long v27 = 0;
                }
                else
                {
                  if (v25) {
                    uint64_t v26 = (unsigned __int8 *)(v25 - 3);
                  }
                  else {
                    uint64_t v26 = 0;
                  }
                  if (v26[16] - 29 >= 0xB) {
                    long long v27 = 0;
                  }
                  else {
                    long long v27 = (llvm::Instruction *)v26;
                  }
                }
                uint64_t result = llvm::Instruction::getSuccessor(v27, 0);
                if (result != a3) {
                  unsigned int v21 = dword_1CFB2C84C[*(_WORD *)(v9 + 18) & 0x3F];
                }
                unsigned int v28 = *(_DWORD *)(a4 + 8);
                if (v28 >= *(_DWORD *)(a4 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                long long v29 = (void *)(*(void *)a4 + 16 * v28);
                void *v29 = v9;
                v29[1] = v21;
                ++*(_DWORD *)(a4 + 8);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

llvm::Value *sub_1CCD19A50(llvm::Instruction *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (llvm::Value *)llvm::Instruction::clone(a1);
  unsigned int v7 = v6;
  if ((*((unsigned char *)a1 + 23) & 0x10) == 0)
  {
    uint64_t v18 = 0;
    uint64_t v17 = &byte_1CFBCE98E;
    goto LABEL_10;
  }
  uint64_t v8 = ***(void ***)a1;
  uint64_t v9 = *(void *)(v8 + 152);
  uint64_t v10 = *(unsigned int *)(v8 + 168);
  if (!v10) {
    goto LABEL_8;
  }
  LODWORD(v11) = (v10 - 1) & ((a1 >> 4) ^ (a1 >> 9));
  long long v12 = (llvm::Instruction **)(v9 + 16 * v11);
  uint64_t v13 = *v12;
  if (*v12 != a1)
  {
    int v14 = 1;
    while (v13 != (llvm::Instruction *)-4096)
    {
      int v15 = v11 + v14++;
      uint64_t v11 = v15 & (v10 - 1);
      uint64_t v13 = *(llvm::Instruction **)(v9 + 16 * v11);
      if (v13 == a1)
      {
        long long v12 = (llvm::Instruction **)(v9 + 16 * v11);
        goto LABEL_9;
      }
    }
LABEL_8:
    long long v12 = (llvm::Instruction **)(v9 + 16 * v10);
  }
LABEL_9:
  int v16 = v12[1];
  uint64_t v19 = *(const char **)v16;
  uint64_t v17 = (char *)v16 + 16;
  uint64_t v18 = v19;
LABEL_10:
  __int16 v47 = 261;
  v46[0] = v17;
  v46[1] = v18;
  llvm::Value::setNameImpl(v6, v46);
  if (v7 && !*((unsigned char *)v7 + 16))
  {
    if ((*((unsigned char *)v7 + 23) & 0x10) == 0) {
      goto LABEL_42;
    }
    uint64_t v32 = ***(void ***)v7;
    uint64_t v33 = *(void *)(v32 + 152);
    uint64_t v34 = *(unsigned int *)(v32 + 168);
    if (v34)
    {
      LODWORD(v35) = (v34 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      long long v36 = (llvm::Value **)(v33 + 16 * v35);
      long long v37 = *v36;
      if (*v36 == v7)
      {
LABEL_35:
        uint64_t v40 = v36[1];
        unint64_t v43 = *(void *)v40;
        unsigned int v41 = (char *)v40 + 16;
        unint64_t v42 = v43;
        if (v43 >= 5 && *(_DWORD *)v41 == *(_DWORD *)"llvm." && v41[4] == aLlvm_1[4])
        {
          *((_DWORD *)v7 + 8) |= 0x2000u;
          int v45 = llvm::Function::lookupIntrinsicID(v41, v42);
LABEL_43:
          *((_DWORD *)v7 + 9) = v45;
          goto LABEL_12;
        }
LABEL_42:
        int v45 = 0;
        *((_DWORD *)v7 + 8) &= ~0x2000u;
        goto LABEL_43;
      }
      int v38 = 1;
      while (v37 != (llvm::Value *)-4096)
      {
        int v39 = v35 + v38++;
        uint64_t v35 = v39 & (v34 - 1);
        long long v37 = *(llvm::Value **)(v33 + 16 * v35);
        if (v37 == v7)
        {
          long long v36 = (llvm::Value **)(v33 + 16 * v35);
          goto LABEL_35;
        }
      }
    }
    long long v36 = (llvm::Value **)(v33 + 16 * v34);
    goto LABEL_35;
  }
LABEL_12:
  uint64_t v20 = *(void *)(a2 + 40);
  *((void *)v7 + 5) = v20;
  *(_WORD *)(v20 + 18) &= ~0x8000u;
  if ((*((unsigned char *)v7 + 23) & 0x10) != 0)
  {
    uint64_t v30 = *(void *)(v20 + 56);
    if (v30)
    {
      long long v31 = *(llvm::ValueSymbolTable **)(v30 + 104);
      if (v31) {
        llvm::ValueSymbolTable::reinsertValue(v31, v7);
      }
    }
  }
  uint64_t v22 = *(void *)(a2 + 24);
  unsigned int v21 = (void *)(a2 + 24);
  *((void *)v7 + 3) = v22;
  *((void *)v7 + 4) = v21;
  *(void *)(v22 + 8) = (char *)v7 + 24;
  *unsigned int v21 = (char *)v7 + 24;
  if (a3)
  {
    int v23 = *((_DWORD *)v7 + 5);
    if ((v23 & 0x40000000) != 0) {
      uint64_t v24 = (char *)*((void *)v7 - 1);
    }
    else {
      uint64_t v24 = (char *)v7 - 32 * (v23 & 0x7FFFFFF);
    }
    if (*(void *)v24)
    {
      **((void **)v24 + 2) = *((void *)v24 + 1);
      uint64_t v25 = *((void *)v24 + 1);
      if (v25) {
        *(void *)(v25 + 16) = *((void *)v24 + 2);
      }
    }
    *(void *)uint64_t v24 = a3;
    uint64_t v28 = *(void *)(a3 + 8);
    long long v27 = (void *)(a3 + 8);
    uint64_t v26 = v28;
    *((void *)v24 + 1) = v28;
    if (v28) {
      *(void *)(v26 + 16) = v24 + 8;
    }
    *((void *)v24 + 2) = v27;
    void *v27 = v24;
  }
  return v7;
}

uint64_t sub_1CCD19CC0()
{
  int v4 = 1;
  *(void *)&long long v3 = "Only allow instructions before a call, if their cost is below DuplicationThreshold";
  *((void *)&v3 + 1) = 82;
  int v1 = 5;
  uint64_t v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCF0918, "callsite-splitting-duplication-threshold", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF0918, &dword_1CB82C000);
}

void sub_1CCD19D50(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeBlockFrequencyInfoWrapperPassPass(a1, a2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeProfileSummaryInfoWrapperPassPass(a1, v3);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

uint64_t sub_1CCD19E08(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF09E8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D5F8;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 116) = 0u;
  *(void *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = a1 + 176;
  *(void *)(a1 + 168) = 0x800000000;
  *(_OWORD *)(a1 + 5552) = 0u;
  *(_DWORD *)(a1 + 5568) = 0;
  *(_OWORD *)(a1 + 5576) = 0u;
  *(_OWORD *)(a1 + 5592) = 0u;
  *(_OWORD *)(a1 + 5604) = 0u;
  *(void *)(a1 + 5632) = 0;
  *(void *)(a1 + 5624) = 0;
  *(void *)(a1 + 5640) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF09F0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD19D50;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCF09F0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void *llvm::ConstantHoistingPass::findConstantInsertionPoint@<X0>(uint64_t **this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v159[16] = *MEMORY[0x1E4F143B8];
  v137[0] = 0;
  v137[1] = 0;
  int v138 = 0;
  uint64_t v140 = 0;
  uint64_t v141 = 0;
  uint64_t v139 = 0;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 24) = 0;
  unsigned int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *(uint64_t **)(a2 + 16);
    unsigned int v7 = &v6[20 * v5];
    do
    {
      uint64_t v8 = *((unsigned int *)v6 + 2);
      if (v8)
      {
        uint64_t v9 = *v6;
        uint64_t v10 = *v6 + 16 * v8;
        do
        {
          MatInsertPt = (llvm::Instruction *)*((void *)llvm::ConstantHoistingPass::findMatInsertPt((llvm::ConstantHoistingPass *)this, *(llvm::Instruction **)v9, *(_DWORD *)(v9 + 8))+ 5);
          sub_1CBB239A4((uint64_t)v137, &MatInsertPt);
          v9 += 16;
        }
        while (v9 != v10);
      }
      v6 += 20;
    }
    while (v6 != v7);
    uint64_t v11 = (llvm::Instruction **)(this + 5);
    long long v12 = this[5];
    if (v138)
    {
      unsigned int v13 = ((v12 >> 4) ^ (v12 >> 9)) & (v138 - 1);
      int v14 = *(uint64_t **)(*(void *)v137 + 8 * v13);
      if (v12 == v14)
      {
LABEL_9:
        uint64_t v15 = v12[6];
        if (v15) {
          int v16 = (llvm::Instruction *)(v15 - 24);
        }
        else {
          int v16 = 0;
        }
        MatInsertPt = v16;
LABEL_13:
        uint64_t v17 = &MatInsertPt;
        goto LABEL_59;
      }
      int v134 = 1;
      while (v14 != (uint64_t *)-4096)
      {
        unsigned int v135 = v13 + v134++;
        unsigned int v13 = v135 & (v138 - 1);
        int v14 = *(uint64_t **)(*(void *)v137 + 8 * v13);
        if (v12 == v14) {
          goto LABEL_9;
        }
      }
    }
  }
  else
  {
    uint64_t v11 = (llvm::Instruction **)(this + 5);
    long long v12 = this[5];
  }
  uint64_t v18 = this[2];
  if (v18)
  {
    uint64_t v51 = this[1];
    uint64_t v156 = v12;
    uint64_t v151 = v155;
    uint64_t v152 = v155;
    *(void *)BOOL v153 = 8;
    int v154 = 0;
    MatInsertPt = (llvm::Instruction *)v150;
    uint64_t v147 = (llvm::Instruction *)v150;
    uint64_t v148 = 16;
    int v149 = 0;
    if (v139 != v140) {
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
    }
    int v52 = 0;
    unsigned int v157 = (char *)v159;
    v159[0] = v12;
    uint64_t v158 = 0x1000000001;
    uint64_t v53 = 1;
    uint64_t v54 = 1;
    do
    {
      int v55 = v52;
      uint64_t v56 = v51[3];
      uint64_t v57 = *((unsigned int *)v51 + 10);
      if (v57)
      {
        uint64_t v58 = *(void *)&v157[8 * v55];
        LODWORD(v59) = ((v58 >> 4) ^ (v58 >> 9)) & (v57 - 1);
        unsigned int v60 = (uint64_t *)(v56 + 16 * v59);
        uint64_t v61 = *v60;
        if (v58 != *v60)
        {
          int v62 = 1;
          do
          {
            if (v61 == -4096) {
              goto LABEL_73;
            }
            int v63 = v59 + v62++;
            uint64_t v59 = v63 & (v57 - 1);
            uint64_t v61 = *(void *)(v56 + 16 * v59);
          }
          while (v58 != v61);
          unsigned int v60 = (uint64_t *)(v56 + 16 * v59);
        }
      }
      else
      {
LABEL_73:
        unsigned int v60 = (uint64_t *)(v56 + 16 * v57);
      }
      uint64_t v64 = v60[1];
      uint64_t v65 = *(unsigned int *)(v64 + 32);
      if (v65)
      {
        uint64_t v66 = *(uint64_t ***)(v64 + 24);
        uint64_t v67 = &v66[v65];
        do
        {
          uint64_t v68 = **v66;
          uint64_t v69 = MatInsertPt;
          if (v147 == MatInsertPt)
          {
            unsigned int v70 = HIDWORD(v148);
            int v71 = (char *)v147 + 8 * HIDWORD(v148);
            if (HIDWORD(v148))
            {
              uint64_t v72 = 0;
              while (*(void *)((char *)v147 + v72) != v68)
              {
                v72 += 8;
                if (8 * HIDWORD(v148) == v72) {
                  goto LABEL_95;
                }
              }
              int v71 = (char *)v147 + v72;
            }
LABEL_95:
            uint64_t v69 = v147;
          }
          else
          {
            int v73 = v148 - 1;
            unsigned int v74 = (v148 - 1) & ((v68 >> 4) ^ (v68 >> 9));
            int v71 = (char *)v147 + 8 * v74;
            uint64_t v75 = *(void *)v71;
            if (*(void *)v71 == -1)
            {
              uint64_t v76 = 0;
LABEL_105:
              if (v76) {
                int v71 = v76;
              }
              unsigned int v70 = HIDWORD(v148);
              if (*(void *)v71 != v68) {
                int v71 = (char *)v147 + 8 * v148;
              }
            }
            else
            {
              uint64_t v76 = 0;
              int v77 = 1;
              while (v75 != v68)
              {
                if (v76) {
                  BOOL v78 = 0;
                }
                else {
                  BOOL v78 = v75 == -2;
                }
                if (v78) {
                  uint64_t v76 = v71;
                }
                unsigned int v79 = v74 + v77++;
                unsigned int v74 = v79 & v73;
                int v71 = (char *)v147 + 8 * (v79 & v73);
                uint64_t v75 = *(void *)v71;
                if (*(void *)v71 == -1) {
                  goto LABEL_105;
                }
              }
              unsigned int v70 = HIDWORD(v148);
            }
          }
          if (v147 == v69) {
            unsigned int v80 = v70;
          }
          else {
            unsigned int v80 = v148;
          }
          if (v71 != (char *)v147 + 8 * v80)
          {
            if (v54 >= HIDWORD(v158)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)&v157[8 * v54] = v68;
            LODWORD(v158) = v158 + 1;
            uint64_t v53 = v158;
            LODWORD(v54) = v158;
          }
          ++v66;
          uint64_t v81 = v53;
        }
        while (v66 != v67);
      }
      else
      {
        uint64_t v81 = v54;
      }
      int v52 = v55 + 1;
      uint64_t v54 = v81;
    }
    while (v81 != v55 + 1);
    v144[0] = 0;
    v144[1] = 0;
    int v145 = 0;
    sub_1CD75FF88(v144, v55 + 2);
    if (!v158) {
      goto LABEL_178;
    }
    int v136 = v157;
    uint64_t v82 = &v157[8 * v158];
    while (1)
    {
      uint64_t v84 = *((void *)v82 - 1);
      v82 -= 8;
      uint64_t v83 = v84;
      int v143 = (uint64_t *)v84;
      if (v138)
      {
        unsigned int v86 = ((v83 >> 4) ^ (v83 >> 9)) & (v138 - 1);
        uint64_t v87 = *(void *)(*(void *)v137 + 8 * v86);
        if (v83 == v87)
        {
          BOOL v85 = 1;
        }
        else
        {
          int v116 = 1;
          do
          {
            BOOL v85 = v87 != -4096;
            if (v87 == -4096) {
              break;
            }
            unsigned int v117 = v86 + v116++;
            unsigned int v86 = v117 & (v138 - 1);
            uint64_t v87 = *(void *)(*(void *)v137 + 8 * v86);
          }
          while (v83 != v87);
        }
      }
      else
      {
        BOOL v85 = 0;
      }
      int v88 = sub_1CD760178((uint64_t)v144, (uint64_t *)&v143);
      __int16 v89 = sub_1CD760178((uint64_t)v144, (uint64_t *)&v143) + 7;
      if (v143 == v12)
      {
        sub_1CBFC9A80(v137);
        uint64_t v140 = v139;
        uint64_t v118 = *v18;
        if (!*v18 || (unsigned int v119 = sub_1CBF7A45C(*v18, (uint64_t)v143), v119 == -1)) {
          unint64_t v120 = 0;
        }
        else {
          unint64_t v120 = *(void *)(*(void *)(v118 + 8) + 24 * v119 + 16);
        }
        if (*v89 <= v120)
        {
          uint64_t v121 = *v18;
          if (!*v18 || (unsigned int v122 = sub_1CBF7A45C(*v18, (uint64_t)v143), v122 == -1)) {
            uint64_t v123 = 0;
          }
          else {
            uint64_t v123 = *(void *)(*(void *)(v121 + 8) + 24 * v122 + 16);
          }
          if (*v89 == v123)
          {
            unsigned int v124 = (char *)v88[4];
            uint64_t v125 = (char *)v88[5];
            if ((unint64_t)(v125 - v124) >= 9) {
              goto LABEL_169;
            }
          }
          else
          {
            unsigned int v124 = (char *)v88[4];
            uint64_t v125 = (char *)v88[5];
          }
          sub_1CCD1C480((uint64_t)v137, v124, v125);
        }
        else
        {
LABEL_169:
          sub_1CBB239A4((uint64_t)v137, &v156);
        }
LABEL_178:
        sub_1CD7602AC(v144);
        if (v157 != (char *)v159) {
          free(v157);
        }
        if (v147 != MatInsertPt) {
          free(v147);
        }
        if (v152 != v151) {
          free(v152);
        }
        uint64_t v126 = v139;
        for (uint64_t i = v140; v126 != i; ++v126)
        {
          for (uint64_t j = (uint64_t *)(*v126 + 48); ; uint64_t j = (uint64_t *)(v129 + 8))
          {
            uint64_t v129 = *j;
            char v130 = (unsigned __int8 *)(v129 - 24);
            if (!v129) {
              char v130 = 0;
            }
            unsigned int v131 = v130[16] - 38;
            BOOL v104 = v131 > 0x38;
            uint64_t v132 = (1 << v131) & 0x100260000000001;
            if (v104 || v132 == 0) {
              break;
            }
          }
          MatInsertPt = (llvm::Instruction *)v130;
          sub_1CC27C13C((void *)a3, &MatInsertPt);
        }
        return sub_1CC189978(v137);
      }
      uint64_t v90 = v51[3];
      uint64_t v91 = *((unsigned int *)v51 + 10);
      if (v91)
      {
        LODWORD(v92) = (v91 - 1) & ((v143 >> 4) ^ (v143 >> 9));
        uint64_t v93 = (uint64_t **)(v90 + 16 * v92);
        uint64_t v94 = *v93;
        if (v143 != *v93)
        {
          int v95 = 1;
          do
          {
            if (v94 == (uint64_t *)-4096) {
              goto LABEL_126;
            }
            int v96 = v92 + v95++;
            uint64_t v92 = v96 & (v91 - 1);
            uint64_t v94 = *(uint64_t **)(v90 + 16 * v92);
          }
          while (v143 != v94);
          uint64_t v93 = (uint64_t **)(v90 + 16 * v92);
        }
      }
      else
      {
LABEL_126:
        uint64_t v93 = (uint64_t **)(v90 + 16 * v91);
      }
      uint64_t v142 = *(void *)v93[1][1];
      uint64_t v97 = sub_1CD760178((uint64_t)v144, &v142) + 1;
      int v98 = sub_1CD760178((uint64_t)v144, &v142);
      if (v85) {
        goto LABEL_128;
      }
      for (uint64_t k = v143[6]; ; uint64_t k = *(void *)(k + 8))
      {
        uint64_t v102 = k - 24;
        if (!k) {
          uint64_t v102 = 0;
        }
        if (*(unsigned char *)(v102 + 16) != 83) {
          break;
        }
      }
      unsigned int v103 = *(unsigned __int8 *)(k - 8) - 38;
      BOOL v104 = v103 > 0x38;
      uint64_t v105 = (1 << v103) & 0x100060000000001;
      if (!v104 && v105 != 0) {
        goto LABEL_140;
      }
      uint64_t v110 = *v18;
      if (!*v18 || (unsigned int v111 = sub_1CBF7A45C(*v18, (uint64_t)v143), v111 == -1)) {
        unint64_t v112 = 0;
      }
      else {
        unint64_t v112 = *(void *)(*(void *)(v110 + 8) + 24 * v111 + 16);
      }
      if (*v89 > v112
        || ((uint64_t v113 = *v18) == 0 || (v114 = sub_1CBF7A45C(*v18, (uint64_t)v143), v114 == -1)
          ? (uint64_t v115 = 0)
          : (uint64_t v115 = *(void *)(*(void *)(v113 + 8) + 24 * v114 + 16)),
            *v89 == v115 && v88[5] - v88[4] >= 9uLL))
      {
LABEL_128:
        sub_1CBB239A4((uint64_t)v97, &v143);
        uint64_t v99 = *v18;
        if (!*v18 || (unsigned int v100 = sub_1CBF7A45C(*v18, (uint64_t)v143), v100 == -1))
        {
          unint64_t v107 = 0;
          goto LABEL_142;
        }
        __int16 v89 = (unint64_t *)(*(void *)(v99 + 8) + 24 * v100 + 16);
      }
      else
      {
LABEL_140:
        sub_1CCD1C480((uint64_t)v97, (void *)v88[4], (void *)v88[5]);
      }
      unint64_t v107 = *v89;
LABEL_142:
      uint64_t v108 = v98[7];
      BOOL v44 = __CFADD__(v107, v108);
      uint64_t v109 = v107 + v108;
      if (v44) {
        uint64_t v109 = -1;
      }
      v98[7] = v109;
      if (v82 == v136) {
        goto LABEL_178;
      }
    }
  }
  uint64_t v20 = v139;
  uint64_t v19 = v140;
  if ((unint64_t)((char *)v140 - (char *)v139) < 9)
  {
LABEL_61:
    uint64_t v49 = *(void *)(*v20 + 48);
    if (v49) {
      int v50 = (llvm::Instruction *)(v49 - 24);
    }
    else {
      int v50 = 0;
    }
    MatInsertPt = llvm::ConstantHoistingPass::findMatInsertPt((llvm::ConstantHoistingPass *)this, v50, -1);
    goto LABEL_13;
  }
  while (1)
  {
    MatInsertPt = 0;
    unsigned int v21 = (llvm::Instruction *)*(v19 - 1);
    sub_1CD7606BC(v137);
    uint64_t v22 = (llvm::Instruction *)*(v140 - 1);
    sub_1CD7606BC(v137);
    uint64_t v23 = *(void *)(*((void *)v21 + 7) + 80);
    if (v23) {
      uint64_t v24 = (llvm::Instruction *)(v23 - 24);
    }
    else {
      uint64_t v24 = 0;
    }
    if (v24 == v21 || v24 == v22) {
      goto LABEL_50;
    }
    uint64_t v26 = this[1];
    uint64_t v27 = v26[3];
    uint64_t v28 = *((unsigned int *)v26 + 10);
    if (v28)
    {
      LODWORD(v29) = (v28 - 1) & ((v21 >> 4) ^ (v21 >> 9));
      uint64_t v30 = (llvm::Instruction **)(v27 + 16 * v29);
      long long v31 = *v30;
      if (*v30 == v21) {
        goto LABEL_31;
      }
      int v32 = 1;
      while (v31 != (llvm::Instruction *)-4096)
      {
        int v33 = v29 + v32++;
        uint64_t v29 = v33 & (v28 - 1);
        long long v31 = *(llvm::Instruction **)(v27 + 16 * v29);
        if (v31 == v21)
        {
          uint64_t v30 = (llvm::Instruction **)(v27 + 16 * v29);
          goto LABEL_31;
        }
      }
    }
    uint64_t v30 = (llvm::Instruction **)(v27 + 16 * v28);
LABEL_31:
    uint64_t v34 = (llvm::Instruction **)(v27 + 16 * v28);
    if (v30 == v34)
    {
      uint64_t v35 = 0;
      if (!v28) {
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v35 = v30[1];
      if (!v28) {
        goto LABEL_54;
      }
    }
    unsigned int v36 = v28 - 1;
    LODWORD(v28) = (v28 - 1) & ((v22 >> 4) ^ (v22 >> 9));
    long long v37 = (llvm::Instruction **)(v27 + 16 * v28);
    int v38 = *v37;
    if (*v37 != v22)
    {
      int v39 = 1;
      while (v38 != (llvm::Instruction *)-4096)
      {
        int v40 = v28 + v39++;
        uint64_t v28 = v40 & v36;
        int v38 = *(llvm::Instruction **)(v27 + 16 * v28);
        if (v38 == v22)
        {
          long long v37 = (llvm::Instruction **)(v27 + 16 * v28);
          goto LABEL_38;
        }
      }
LABEL_54:
      unsigned int v41 = 0;
      goto LABEL_40;
    }
LABEL_38:
    if (v37 == v34) {
      goto LABEL_54;
    }
    unsigned int v41 = v37[1];
LABEL_40:
    if (v35 == v41)
    {
      unsigned int v41 = v35;
    }
    else
    {
      do
      {
        unsigned int v42 = *((_DWORD *)v35 + 4);
        unsigned int v43 = *((_DWORD *)v41 + 4);
        BOOL v44 = v42 >= v43;
        if (v42 >= v43) {
          int v45 = v35;
        }
        else {
          int v45 = v41;
        }
        if (!v44) {
          unsigned int v41 = v35;
        }
        uint64_t v35 = (llvm::Instruction *)*((void *)v45 + 1);
      }
      while (v35 != v41);
    }
    uint64_t v24 = *(llvm::Instruction **)v41;
LABEL_50:
    MatInsertPt = v24;
    if (v24 == *v11) {
      break;
    }
    sub_1CBB239A4((uint64_t)v137, &MatInsertPt);
    uint64_t v20 = v139;
    uint64_t v19 = v140;
    if ((unint64_t)((char *)v140 - (char *)v139) <= 8) {
      goto LABEL_61;
    }
  }
  uint64_t v46 = *((void *)v24 + 6);
  if (v46) {
    __int16 v47 = (char *)(v46 - 24);
  }
  else {
    __int16 v47 = 0;
  }
  unsigned int v157 = v47;
  uint64_t v17 = (llvm::Instruction **)&v157;
LABEL_59:
  sub_1CC27C13C((void *)a3, v17);
  return sub_1CC189978(&v137[0]);
}

uint64_t llvm::ConstantHoistingPass::collectConstantCandidates(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unsigned int v6 = a4;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v10 = *(unsigned __int8 *)(a3 + 16);
  if (v10 == 84
    && (uint64_t v11 = *(void *)(a3 - 32)) != 0
    && !*(unsigned char *)(v11 + 16)
    && *(void *)(v11 + 24) == *(void *)(a3 + 72)
    && (*(unsigned char *)(v11 + 33) & 0x20) != 0)
  {
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t, unint64_t, void, uint64_t))(**(void **)*a1 + 664))(*(void *)*a1, *(unsigned int *)(v11 + 36), a4, a5 + 24, *(void *)a5, 3);
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t, unint64_t, void, uint64_t, uint64_t))(**(void **)*a1 + 656))(*(void *)*a1, (v10 - 28), a4, a5 + 24, *(void *)a5, 3, a3);
  }
  int v14 = result;
  int v15 = v13;
  BOOL v16 = result > 1;
  if (v13) {
    BOOL v16 = v13 > 0;
  }
  if (v16)
  {
    unint64_t v25 = a5 & 0xFFFFFFFFFFFFFFFBLL;
    int v26 = 0;
    sub_1CD760728((uint64_t)&v27, a2, &v25, &v26);
    uint64_t v17 = v27;
    if (v29[0])
    {
      uint64_t v20 = a1 + 7;
      uint64_t v27 = v29;
      uint64_t v28 = 0x800000000;
      long long v30 = a5;
      int v31 = 0;
      unint64_t v21 = a1[8];
      if (v21 >= a1[9])
      {
        uint64_t v23 = sub_1CCD1C68C(a1 + 7, (uint64_t)&v27);
      }
      else
      {
        *(void *)unint64_t v21 = v21 + 16;
        *(void *)(v21 + 8) = 0x800000000;
        if (v28) {
          sub_1CD727100(v21, (uint64_t)&v27);
        }
        long long v22 = v30;
        *(_DWORD *)(v21 + 160) = v31;
        *(_OWORD *)(v21 + 144) = v22;
        uint64_t v23 = v21 + 168;
      }
      a1[8] = v23;
      if (v27 != v29)
      {
        free(v27);
        uint64_t v23 = a1[8];
      }
      uint64_t v19 = *v20;
      unsigned int v18 = 1022611261 * ((unint64_t)(v23 - *v20) >> 3) - 1;
      v17[2] = v18;
    }
    else
    {
      unsigned int v18 = *((_DWORD *)v27 + 2);
      uint64_t v19 = a1[7];
    }
    if (v15) {
      int v24 = 0;
    }
    else {
      int v24 = v14;
    }
    return sub_1CD75E96C(v19 + 168 * v18, a3, v6, v24);
  }
  return result;
}

uint64_t sub_1CCD1AF3C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CCD1C68C(a1, a2);
  }
  else
  {
    *(void *)unint64_t v4 = v4 + 16;
    *(void *)(v4 + 8) = 0x800000000;
    if (*(_DWORD *)(a2 + 8)) {
      sub_1CD727100(v4, a2);
    }
    long long v5 = *(_OWORD *)(a2 + 144);
    *(_DWORD *)(v4 + 160) = *(_DWORD *)(a2 + 160);
    *(_OWORD *)(v4 + 144) = v5;
    uint64_t result = v4 + 168;
  }
  a1[1] = result;
  return result;
}

uint64_t llvm::ConstantHoistingPass::collectConstantCandidates(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = (uint64_t *)result;
  int v8 = *(_DWORD *)(a3 + 20);
  if ((v8 & 0x40000000) != 0) {
    uint64_t v9 = *(void *)(a3 - 8);
  }
  else {
    uint64_t v9 = a3 - 32 * (v8 & 0x7FFFFFF);
  }
  unint64_t v10 = *(void *)(v9 + 32 * a4);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 16);
  if (v10) {
    BOOL v12 = v11 == 16;
  }
  else {
    BOOL v12 = 0;
  }
  if (v12) {
    goto LABEL_31;
  }
  if (v10) {
    BOOL v13 = v11 >= 0x1C;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    if (v11 - 66 > 0xC) {
      return result;
    }
    int v15 = *(_DWORD *)(v10 + 20);
    if ((v15 & 0x40000000) != 0)
    {
      BOOL v16 = *(unint64_t **)(v10 - 8);
LABEL_26:
      unint64_t v10 = *v16;
      int v17 = *(unsigned __int8 *)(*v16 + 16);
      if (v10) {
        BOOL v18 = v17 == 16;
      }
      else {
        BOOL v18 = 0;
      }
      if (!v18) {
        return result;
      }
LABEL_31:
      return llvm::ConstantHoistingPass::collectConstantCandidates(v7, a2, a3, a4, v10);
    }
LABEL_24:
    BOOL v16 = (unint64_t *)(v10 - 32 * (v15 & 0x7FFFFFF));
    goto LABEL_26;
  }
  if (v10) {
    BOOL v14 = v11 == 5;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    if (byte_1EBCF0B38 && *(_WORD *)(v10 + 18) == 34) {
      uint64_t result = llvm::ConstantHoistingPass::collectConstantCandidates(result, a2, a3, a4, v10);
    }
    if (*(unsigned __int16 *)(v10 + 18) - 38 <= 0xC)
    {
      int v15 = *(_DWORD *)(v10 + 20);
      goto LABEL_24;
    }
  }
  return result;
}

void llvm::ConstantHoistingPass::collectConstantCandidates(llvm::ConstantHoistingPass *this, llvm::Function **a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  int v4 = 0;
  if (a2[10] != (llvm::Function *)(a2 + 9)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }

  JUMPOUT(0x1D25D9CD0);
}

char **llvm::ConstantHoistingPass::findBaseConstants(llvm::TargetTransformInfo **this, llvm::GlobalVariable *a2)
{
  uint64_t v35 = a2;
  if (a2)
  {
    uint64_t v3 = (uint64_t *)sub_1CD75ECB8((uint64_t)(this + 10), (unint64_t *)&v35);
    int v4 = (char *)sub_1CD75F520((uint64_t)(this + 690), (uint64_t)&v35, v5, v6);
  }
  else
  {
    uint64_t v3 = (uint64_t *)(this + 7);
    int v4 = (char *)(this + 16);
  }
  uint64_t v7 = *v3;
  uint64_t v8 = v3[1];
  uint64_t v34 = v3;
  if (v8 - *v3 < 1)
  {
LABEL_8:
    sub_1CCD1CAFC(v7, v8, 0xCF3CF3CF3CF3CF3DLL * ((v8 - v7) >> 3), 0, 0);
  }
  else
  {
    uint64_t v9 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v10 = 0xCF3CF3CF3CF3CF3DLL * ((v8 - v7) >> 3);
    while (1)
    {
      unsigned int v11 = operator new(168 * v10, v9);
      if (v11) {
        break;
      }
      BOOL v12 = v10 > 1;
      v10 >>= 1;
      if (!v12) {
        goto LABEL_8;
      }
    }
    BOOL v13 = v11;
    sub_1CCD1CAFC(v7, v8, 0xCF3CF3CF3CF3CF3DLL * ((v8 - v7) >> 3), v11, v10);
    operator delete(v13);
  }
  uint64_t v15 = *v3;
  uint64_t v14 = v3[1];
  uint64_t v16 = *v3 + 168;
  if (v16 != v14)
  {
    int v17 = (void *)*v3;
    do
    {
      BOOL v18 = v17;
      int v17 = (void *)v16;
      uint64_t v19 = *(void **)(v15 + 144);
      uint64_t v20 = v18[39];
      if (*v19 != *(void *)v20) {
        goto LABEL_32;
      }
      uint64_t v21 = *((unsigned int *)v18 + 44);
      if (v21)
      {
        uint64_t v22 = 16 * v21;
        uint64_t v23 = (unsigned int *)(*v17 + 8);
        while (1)
        {
          int v24 = (uint64_t *)*((void *)v23 - 1);
          int v25 = *((unsigned __int8 *)v24 + 16);
          if (v24)
          {
            if (v25 == 60) {
              break;
            }
          }
          if (v24)
          {
            if (v25 == 61)
            {
              uint64_t v26 = *(v24 - 4);
              uint64_t v27 = v24 - 8;
              if (v26 == v27[4 * *v23])
              {
                int v24 = (uint64_t *)*v27;
                break;
              }
            }
          }
          v23 += 4;
          v22 -= 16;
          if (!v22) {
            goto LABEL_21;
          }
        }
        uint64_t v28 = *v24;
      }
      else
      {
LABEL_21:
        uint64_t v28 = 0;
      }
      unsigned int v29 = *(_DWORD *)(v20 + 32);
      if (v29 >= 0x41) {
        operator new[]();
      }
      uint64_t v30 = *(void *)(v20 + 24) - v19[3];
      unint64_t v31 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v29;
      if (!v29) {
        unint64_t v31 = 0;
      }
      uint64_t v32 = (uint64_t)((v31 & v30) << -(char)v29) >> -(char)v29;
      if (((*(uint64_t (**)(void, uint64_t))(**(void **)*this + 248))(*(void *)*this, v32) & 1) == 0
        || v28
        && ((*(uint64_t (**)(void, uint64_t, void, uint64_t, uint64_t, void, void, void))(**(void **)*this + 264))(*(void *)*this, v28, 0, v32, 1, 0, 0, 0) & 1) == 0)
      {
LABEL_32:
        llvm::ConstantHoistingPass::findAndMakeBaseConstant(this, v15, (uint64_t)v17, (uint64_t)v4);
        uint64_t v15 = (uint64_t)v17;
      }
      uint64_t v16 = (uint64_t)(v17 + 21);
    }
    while (v17 + 21 != (void *)v14);
    uint64_t v14 = v34[1];
  }

  return llvm::ConstantHoistingPass::findAndMakeBaseConstant(this, v15, v14, (uint64_t)v4);
}

uint64_t llvm::ConstantHoistingPass::emitBaseConstants(uint64_t this, void *a2, llvm::Instruction *a3, llvm::Type *a4, uint64_t a5)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  uint64_t v9 = (llvm::ConstantHoistingPass *)this;
  if (!a3 && a4)
  {
    if ((llvm::Type *)*a2 == a4)
    {
LABEL_7:
      int v12 = 1;
      goto LABEL_8;
    }
    uint64_t v10 = **(void **)(this + 24);
    unsigned int v11 = *(llvm::ConstantInt **)(v10 + 1960);
    unsigned int v98 = *(_DWORD *)(v10 + 1968) >> 8;
    if (v98 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&v97);
    }
    uint64_t v97 = 0;
    this = (uint64_t)llvm::ConstantInt::get(v11, (llvm::LLVMContext *)&v97, 0);
    uint64_t v7 = (llvm::Instruction *)this;
    if (v98 >= 0x41)
    {
      this = (uint64_t)v97;
      if (v97) {
        this = MEMORY[0x1D25D9CB0](v97, 0x1000C8000313F17);
      }
    }
  }
  if (!v7) {
    goto LABEL_7;
  }
  MatInsertPt = llvm::ConstantHoistingPass::findMatInsertPt(v9, *(llvm::Instruction **)a5, *(_DWORD *)(a5 + 8));
  if (a4)
  {
    int v24 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)(**((void **)v9 + 3) + 1912), (llvm::Type *)(*((_DWORD *)a4 + 2) >> 8));
    int v25 = (char *)operator new(0x60uLL);
    *((_DWORD *)v25 + 13) = *((_DWORD *)v25 + 13) & 0x38000000 | 1;
    uint64_t v26 = (uint64_t *)(v25 + 32);
    *(void *)int v25 = 0;
    *((void *)v25 + 1) = 0;
    *((void *)v25 + 2) = 0;
    *((void *)v25 + 3) = v25 + 32;
    uint64_t v97 = "base_bitcast";
    __int16 v99 = 259;
    llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v25 + 32), (llvm::Value *)v8, v24, (const char **)&v97, MatInsertPt);
    uint64_t v27 = **((void **)v9 + 3);
    int v96 = v7;
    uint64_t v97 = "mat_gep";
    __int16 v99 = 259;
    uint64_t v28 = (char *)operator new(0x90uLL);
    *((_DWORD *)v28 + 21) = *((_DWORD *)v28 + 21) & 0x38000000 | 2;
    unsigned int v29 = (llvm::Value *)(v28 + 64);
    *(void *)uint64_t v28 = 0;
    *((void *)v28 + 1) = 0;
    *((void *)v28 + 2) = 0;
    *((void *)v28 + 3) = v28 + 64;
    *((void *)v28 + 4) = 0;
    *((void *)v28 + 5) = 0;
    *((void *)v28 + 6) = 0;
    *((void *)v28 + 7) = v28 + 64;
    uint64_t v30 = v27 + 1912;
    sub_1CB845A7C(v30, v26, (uint64_t)&v96, 1);
    *((void *)v28 + 8) = v31;
    *((void *)v28 + 9) = 0;
    unsigned int v32 = *((_DWORD *)v28 + 21) & 0xC0000000 | 2;
    *((_DWORD *)v28 + 20) = 62;
    *((_DWORD *)v28 + 21) = v32;
    *(_OWORD *)(v28 + 88) = 0u;
    int v33 = v28 + 88;
    *(_OWORD *)(v28 + 104) = 0u;
    *((_DWORD *)v28 + 30) = 0;
    if (MatInsertPt)
    {
      uint64_t v71 = *((void *)MatInsertPt + 5);
      uint64_t v72 = (uint64_t *)((char *)MatInsertPt + 24);
      *((void *)v28 + 13) = v71;
      *(_WORD *)(v71 + 18) &= ~0x8000u;
      if ((v28[87] & 0x10) != 0)
      {
        uint64_t v79 = *(void *)(v71 + 56);
        if (v79)
        {
          unsigned int v80 = *(llvm::ValueSymbolTable **)(v79 + 104);
          if (v80)
          {
            llvm::ValueSymbolTable::reinsertValue(v80, v29);
            uint64_t v72 = (uint64_t *)((char *)MatInsertPt + 24);
            int v33 = v28 + 88;
          }
        }
      }
      uint64_t v73 = *v72;
      *((void *)v28 + 11) = *v72;
      *((void *)v28 + 12) = v72;
      *(void *)(v73 + 8) = v33;
      *uint64_t v72 = (uint64_t)v33;
    }
    *((void *)v28 + 16) = v30;
    *((void *)v28 + 17) = llvm::GetElementPtrInst::getIndexedType(v30, (uint64_t)&v96, 1);
    llvm::GetElementPtrInst::init((uint64_t ***)v29, (uint64_t **)v26, (uint64_t *)&v96, 1, (const char **)&v97);
    uint64_t v34 = (char *)operator new(0x60uLL);
    *((_DWORD *)v34 + 13) = *((_DWORD *)v34 + 13) & 0x38000000 | 1;
    uint64_t v8 = v34 + 32;
    *(void *)uint64_t v34 = 0;
    *((void *)v34 + 1) = 0;
    *((void *)v34 + 2) = 0;
    *((void *)v34 + 3) = v34 + 32;
    uint64_t v97 = "mat_bitcast";
    __int16 v99 = 259;
    this = (uint64_t)llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v34 + 32), v29, a4, (const char **)&v97, MatInsertPt);
  }
  else
  {
    uint64_t v97 = "const_mat";
    __int16 v99 = 259;
    this = (uint64_t)llvm::BinaryOperator::Create(13, v8, (uint64_t)v7, (const char **)&v97, (uint64_t)MatInsertPt);
    uint64_t v8 = (void *)this;
  }
  uint64_t v48 = *(unsigned __int8 **)(*(void *)a5 + 48);
  int v95 = v48;
  if (v48) {
    this = llvm::MetadataTracking::track((uint64_t)&v95, v48, 2);
  }
  uint64_t v49 = (unsigned __int8 **)(v8 + 6);
  if (&v95 == v8 + 6)
  {
    if (!v95) {
      goto LABEL_49;
    }
    int v81 = *v95;
    if ((v81 - 4) > 0x1E)
    {
      if ((v81 - 3) >= 0xFFFFFFFE) {
        uint64_t v90 = v95;
      }
      else {
        uint64_t v90 = 0;
      }
      if ((v81 - 3) < 0xFFFFFFFE)
      {
        if (v81 != 3) {
          goto LABEL_49;
        }
        int v12 = 0;
        *((void *)v95 + 1) = 0;
        goto LABEL_8;
      }
      unint64_t v83 = (unint64_t)(v90 + 8);
    }
    else
    {
      if ((v95[1] & 0x7F) != 2 && !*((_DWORD *)v95 + 3)) {
        goto LABEL_49;
      }
      int v12 = 0;
      uint64_t v82 = *((void *)v95 + 2);
      if ((v82 & 4) == 0) {
        goto LABEL_8;
      }
      unint64_t v83 = v82 & 0xFFFFFFFFFFFFFFF8;
      if (!v83) {
        goto LABEL_8;
      }
    }
    uint64_t v97 = (char *)&v95;
    this = sub_1CC5FA668(v83 + 16, &v97);
    goto LABEL_49;
  }
  int v50 = *v49;
  if (*v49)
  {
    int v64 = *v50;
    if ((v64 - 4) > 0x1E)
    {
      if ((v64 - 3) >= 0xFFFFFFFE) {
        unsigned int v70 = *v49;
      }
      else {
        unsigned int v70 = 0;
      }
      if ((v64 - 3) < 0xFFFFFFFE)
      {
        if (v64 == 3) {
          *((void *)v50 + 1) = 0;
        }
        goto LABEL_48;
      }
      unint64_t v66 = (unint64_t)(v70 + 8);
    }
    else
    {
      if ((v50[1] & 0x7F) != 2 && !*((_DWORD *)v50 + 3)) {
        goto LABEL_48;
      }
      uint64_t v65 = *((void *)v50 + 2);
      if ((v65 & 4) == 0) {
        goto LABEL_48;
      }
      unint64_t v66 = v65 & 0xFFFFFFFFFFFFFFF8;
      if (!v66) {
        goto LABEL_48;
      }
    }
    uint64_t v97 = (char *)(v8 + 6);
    this = sub_1CC5FA668(v66 + 16, &v97);
  }
LABEL_48:
  uint64_t v51 = v95;
  uint64_t *v49 = v95;
  if (!v51)
  {
LABEL_49:
    int v12 = 0;
    goto LABEL_8;
  }
  this = llvm::MetadataTracking::retrack((uint64_t)&v95, v51, (uint64_t)(v8 + 6));
  int v12 = 0;
  int v95 = 0;
LABEL_8:
  BOOL v13 = *(llvm::Instruction **)a5;
  uint64_t v14 = *(unsigned int *)(a5 + 8);
  int v15 = *(_DWORD *)(*(void *)a5 + 20);
  if ((v15 & 0x40000000) != 0) {
    uint64_t v16 = (char *)*((void *)v13 - 1);
  }
  else {
    uint64_t v16 = (char *)v13 - 32 * (v15 & 0x7FFFFFF);
  }
  uint64_t v17 = *(void *)&v16[32 * v14];
  unsigned int v18 = *(unsigned __int8 *)(v17 + 16);
  if (v18 == 16)
  {
    this = sub_1CCD1BE70(*(void *)a5, *(_DWORD *)(a5 + 8), (uint64_t)v8);
    if (((v12 | this) & 1) == 0) {
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    return this;
  }
  if (v18 <= 0x1B) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = (llvm::Instruction *)v17;
  }
  int v96 = v19;
  if (v19)
  {
    uint64_t v35 = (llvm::Value **)sub_1CD48CC08((uint64_t)v9 + 5568, (uint64_t *)&v96);
    if (!*v35)
    {
      unsigned int v36 = (llvm::Value *)llvm::Instruction::clone(v96);
      *uint64_t v35 = v36;
      int v37 = *((_DWORD *)v36 + 5);
      if ((v37 & 0x40000000) != 0) {
        int v38 = (void *)*((void *)v36 - 1);
      }
      else {
        int v38 = (void *)((char *)v36 - 32 * (v37 & 0x7FFFFFF));
      }
      if (*v38)
      {
        *(void *)_OWORD v38[2] = v38[1];
        uint64_t v39 = v38[1];
        if (v39) {
          *(void *)(v39 + 16) = v38[2];
        }
      }
      *int v38 = v8;
      if (v8)
      {
        uint64_t v42 = v8[1];
        unsigned int v41 = v8 + 1;
        uint64_t v40 = v42;
        v38[1] = v42;
        if (v42) {
          *(void *)(v40 + 16) = v38 + 1;
        }
        _OWORD v38[2] = v41;
        void *v41 = v38;
      }
      sub_1CC5C6C08((void *)(*((void *)v96 + 5) + 40), (uint64_t)v96 + 24, *v35);
      unsigned int v43 = *v35;
      BOOL v44 = (unsigned __int8 *)*((void *)v96 + 6);
      uint64_t v94 = v44;
      if (v44) {
        llvm::MetadataTracking::track((uint64_t)&v94, v44, 2);
      }
      int v45 = (char *)v43 + 48;
      if (&v94 != (unsigned __int8 **)v45)
      {
        uint64_t v46 = *(unsigned __int8 **)v45;
        if (!*(void *)v45) {
          goto LABEL_40;
        }
        int v74 = *v46;
        if ((v74 - 4) > 0x1E)
        {
          if ((v74 - 3) >= 0xFFFFFFFE) {
            BOOL v78 = *(unsigned __int8 **)v45;
          }
          else {
            BOOL v78 = 0;
          }
          if ((v74 - 3) < 0xFFFFFFFE)
          {
            if (v74 == 3) {
              *((void *)v46 + 1) = 0;
            }
            goto LABEL_40;
          }
          unint64_t v76 = (unint64_t)(v78 + 8);
        }
        else if ((v46[1] & 0x7F) != 2 && !*((_DWORD *)v46 + 3) {
               || (uint64_t v75 = *((void *)v46 + 2), (v75 & 4) == 0)
        }
               || (unint64_t v76 = v75 & 0xFFFFFFFFFFFFFFF8) == 0)
        {
LABEL_40:
          __int16 v47 = v94;
          *(void *)int v45 = v94;
          if (v47)
          {
            llvm::MetadataTracking::retrack((uint64_t)&v94, v47, (uint64_t)v45);
            uint64_t v94 = 0;
          }
          goto LABEL_42;
        }
        uint64_t v97 = v45;
        sub_1CC5FA668(v76 + 16, &v97);
        goto LABEL_40;
      }
      if (v94)
      {
        int v87 = *v94;
        if ((v87 - 4) > 0x1E)
        {
          if ((v87 - 3) >= 0xFFFFFFFE) {
            uint64_t v92 = v94;
          }
          else {
            uint64_t v92 = 0;
          }
          if ((v87 - 3) < 0xFFFFFFFE)
          {
            if (v87 == 3) {
              *((void *)v94 + 1) = 0;
            }
            goto LABEL_42;
          }
          unint64_t v89 = (unint64_t)(v92 + 8);
        }
        else
        {
          if ((v94[1] & 0x7F) != 2 && !*((_DWORD *)v94 + 3)) {
            goto LABEL_42;
          }
          uint64_t v88 = *((void *)v94 + 2);
          if ((v88 & 4) == 0) {
            goto LABEL_42;
          }
          unint64_t v89 = v88 & 0xFFFFFFFFFFFFFFF8;
          if (!v89) {
            goto LABEL_42;
          }
        }
        uint64_t v97 = (char *)&v94;
        sub_1CC5FA668(v89 + 16, &v97);
      }
    }
LABEL_42:
    uint64_t v20 = *(llvm::Instruction **)a5;
    unsigned int v21 = *(_DWORD *)(a5 + 8);
    uint64_t v22 = *v35;
    return sub_1CCD1BE70((uint64_t)v20, v21, (uint64_t)v22);
  }
  if (v18 != 5) {
    return this;
  }
  if (*(_WORD *)(v17 + 18) == 34)
  {
    uint64_t v20 = v13;
    unsigned int v21 = v14;
    uint64_t v22 = (llvm::Value *)v8;
    return sub_1CCD1BE70((uint64_t)v20, v21, (uint64_t)v22);
  }
  int v52 = llvm::ConstantHoistingPass::findMatInsertPt(v9, v13, v14);
  AsInstructiouint64_t n = llvm::ConstantExpr::getAsInstruction((llvm::ConstantExpr *)v17, v52);
  uint64_t v54 = AsInstruction;
  int v55 = *(_DWORD *)(AsInstruction + 20);
  if ((v55 & 0x40000000) != 0) {
    uint64_t v56 = *(void *)(AsInstruction - 8);
  }
  else {
    uint64_t v56 = AsInstruction - 32 * (v55 & 0x7FFFFFF);
  }
  if (*(void *)v56)
  {
    **(void **)(v56 + 16) = *(void *)(v56 + 8);
    uint64_t v57 = *(void *)(v56 + 8);
    if (v57) {
      *(void *)(v57 + 16) = *(void *)(v56 + 16);
    }
  }
  *(void *)uint64_t v56 = v8;
  if (v8)
  {
    uint64_t v58 = v8 + 1;
    uint64_t v59 = v8[1];
    *(void *)(v56 + 8) = v59;
    if (v59) {
      *(void *)(v59 + 16) = v56 + 8;
    }
    *(void *)(v56 + 16) = v58;
    *uint64_t v58 = v56;
  }
  unsigned int v60 = *(unsigned __int8 **)(*(void *)a5 + 48);
  uint64_t v93 = v60;
  if (v60) {
    llvm::MetadataTracking::track((uint64_t)&v93, v60, 2);
  }
  uint64_t v61 = (unsigned __int8 **)(v54 + 48);
  if (&v93 != (unsigned __int8 **)(v54 + 48))
  {
    int v62 = *v61;
    if (!*v61) {
      goto LABEL_63;
    }
    int v67 = *v62;
    if ((v67 - 4) > 0x1E)
    {
      if ((v67 - 3) >= 0xFFFFFFFE) {
        int v77 = *v61;
      }
      else {
        int v77 = 0;
      }
      if ((v67 - 3) < 0xFFFFFFFE)
      {
        if (v67 == 3) {
          *((void *)v62 + 1) = 0;
        }
        goto LABEL_63;
      }
      unint64_t v69 = (unint64_t)(v77 + 8);
    }
    else if ((v62[1] & 0x7F) != 2 && !*((_DWORD *)v62 + 3) {
           || (uint64_t v68 = *((void *)v62 + 2), (v68 & 4) == 0)
    }
           || (unint64_t v69 = v68 & 0xFFFFFFFFFFFFFFF8) == 0)
    {
LABEL_63:
      int v63 = v93;
      void *v61 = v93;
      if (v63)
      {
        llvm::MetadataTracking::retrack((uint64_t)&v93, v63, v54 + 48);
        uint64_t v93 = 0;
      }
      goto LABEL_65;
    }
    uint64_t v97 = (char *)(v54 + 48);
    sub_1CC5FA668(v69 + 16, &v97);
    goto LABEL_63;
  }
  if (v93)
  {
    int v84 = *v93;
    if ((v84 - 4) > 0x1E)
    {
      if ((v84 - 3) >= 0xFFFFFFFE) {
        uint64_t v91 = v93;
      }
      else {
        uint64_t v91 = 0;
      }
      if ((v84 - 3) < 0xFFFFFFFE)
      {
        if (v84 == 3) {
          *((void *)v93 + 1) = 0;
        }
        goto LABEL_65;
      }
      unint64_t v86 = (unint64_t)(v91 + 8);
    }
    else
    {
      if ((v93[1] & 0x7F) != 2 && !*((_DWORD *)v93 + 3)) {
        goto LABEL_65;
      }
      uint64_t v85 = *((void *)v93 + 2);
      if ((v85 & 4) == 0) {
        goto LABEL_65;
      }
      unint64_t v86 = v85 & 0xFFFFFFFFFFFFFFF8;
      if (!v86) {
        goto LABEL_65;
      }
    }
    uint64_t v97 = (char *)&v93;
    sub_1CC5FA668(v86 + 16, &v97);
  }
LABEL_65:
  this = sub_1CCD1BE70(*(void *)a5, *(_DWORD *)(a5 + 8), v54);
  if ((this & 1) == 0) {
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
  return this;
}

uint64_t sub_1CCD1BE70(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a1 + 20);
  if (!a1 || *(unsigned char *)(a1 + 16) != 83) {
    goto LABEL_13;
  }
  if ((v3 & 0x40000000) == 0)
  {
    uint64_t v4 = a1 - 32 * (v3 & 0x7FFFFFF);
    if (!a2) {
      goto LABEL_13;
    }
    goto LABEL_7;
  }
  uint64_t v4 = *(void *)(a1 - 8);
  if (!a2)
  {
LABEL_13:
    if ((v3 & 0x40000000) != 0) {
      uint64_t v9 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v9 = a1 - 32 * (v3 & 0x7FFFFFF);
    }
    uint64_t v10 = v9 + 32 * a2;
    if (*(void *)v10)
    {
      **(void **)(v10 + 16) = *(void *)(v10 + 8);
      uint64_t v11 = *(void *)(v10 + 8);
      if (v11) {
        *(void *)(v11 + 16) = *(void *)(v10 + 16);
      }
    }
    *(void *)uint64_t v10 = a3;
    if (a3)
    {
      uint64_t v14 = *(void *)(a3 + 8);
      int v12 = (void *)(a3 + 8);
      uint64_t v13 = v14;
      uint64_t v15 = v9 + 32 * a2;
      *(void *)(v15 + 8) = v14;
      if (v14) {
        *(void *)(v13 + 16) = v15 + 8;
      }
      *(void *)(v15 + 16) = v12;
      *int v12 = v10;
    }
    return 1;
  }
LABEL_7:
  uint64_t v5 = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 60);
  uint64_t v7 = *(void *)(v4 + 32 * v6 + 8 * a2);
  uint64_t v8 = 32 * v6;
  while ((v3 & 0x40000000) != 0)
  {
    uint64_t v17 = *(void *)(a1 - 8);
    if (*(void *)(v17 + v8) == v7) {
      goto LABEL_23;
    }
LABEL_12:
    v5 += 32;
    v8 += 8;
    if (32 * a2 == v5) {
      goto LABEL_13;
    }
  }
  if (*(void *)(a1 - 32 * (v3 & 0x7FFFFFF) + v8) != v7) {
    goto LABEL_12;
  }
  uint64_t v17 = a1 - 32 * (v3 & 0x7FFFFFF);
LABEL_23:
  uint64_t v18 = *(void *)(v17 + v5);
  uint64_t v19 = v17 + 32 * a2;
  if (*(void *)v19)
  {
    **(void **)(v19 + 16) = *(void *)(v19 + 8);
    uint64_t v20 = *(void *)(v19 + 8);
    if (v20) {
      *(void *)(v20 + 16) = *(void *)(v19 + 16);
    }
  }
  *(void *)uint64_t v19 = v18;
  if (!v18) {
    return 0;
  }
  uint64_t v23 = *(void *)(v18 + 8);
  unsigned int v21 = (void *)(v18 + 8);
  uint64_t v22 = v23;
  uint64_t v24 = v17 + 32 * a2;
  *(void *)(v24 + 8) = v23;
  if (v23) {
    *(void *)(v22 + 16) = v24 + 8;
  }
  uint64_t result = 0;
  *(void *)(v24 + 16) = v21;
  *unsigned int v21 = v19;
  return result;
}

uint64_t llvm::ConstantHoistingPass::deleteDeadCastInst(uint64_t this)
{
  for (uint64_t i = *(void *)(this + 5592); i != *(void *)(this + 5600); i += 16)
  {
    if (!*(void *)(*(void *)i + 8)) {
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
  }
  return this;
}

void sub_1CCD1C04C()
{
}

void sub_1CCD1C088(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F263D5F8;
  sub_1CD719B68((uint64_t)a1 + 32);

  llvm::Pass::~Pass(a1);
}

void sub_1CCD1C0DC(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F263D5F8;
  sub_1CD719B68((uint64_t)a1 + 32);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CCD1C144()
{
  return "Constant Hoisting";
}

void sub_1CCD1C154(llvm::PassRegistry *a1, uint64_t a2)
{
  v4[0] = &unk_1F2617E40;
  v4[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v4);
  if (byte_1EBCF0A78) {
    sub_1CB843600(a2, a2, (uint64_t)&llvm::BlockFrequencyInfoWrapperPass::ID);
  }
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::ProfileSummaryInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
}

uint64_t sub_1CCD1C214(void *a1, uint64_t a2)
{
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, (llvm::LLVMContextImpl ****)a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v9, (const Function *)a2);
  uint64_t v11 = (uint64_t *)a1[1];
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_11:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_11;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  uint64_t v15 = (llvm::DominatorTree *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::DominatorTreeWrapperPass::ID)+ 32);
  if (byte_1EBCF0A78)
  {
    uint64_t v17 = (uint64_t *)a1[1];
    uint64_t v18 = *v17;
    uint64_t v19 = v17[1];
    if (v18 == v19)
    {
LABEL_18:
      uint64_t v20 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v18 != &llvm::BlockFrequencyInfoWrapperPass::ID)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_18;
        }
      }
      uint64_t v20 = *(void *)(v18 + 8);
    }
    uint64_t v16 = (llvm::BlockFrequencyInfo *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::BlockFrequencyInfoWrapperPass::ID)+ 32);
  }
  else
  {
    uint64_t v16 = 0;
  }
  uint64_t v21 = 0;
  uint64_t v22 = *(void *)(a2 + 80);
  if (v22) {
    uint64_t v23 = (llvm::BasicBlock *)(v22 - 24);
  }
  else {
    uint64_t v23 = 0;
  }
  uint64_t v24 = (uint64_t *)a1[1];
  uint64_t v25 = *v24;
  uint64_t v26 = v24[1];
  if (v25 != v26)
  {
    while (*(char **)v25 != llvm::ProfileSummaryInfoWrapperPass::ID)
    {
      v25 += 16;
      if (v25 == v26)
      {
        uint64_t v21 = 0;
        goto LABEL_29;
      }
    }
    uint64_t v21 = *(void *)(v25 + 8);
  }
LABEL_29:
  uint64_t v27 = *(llvm::ProfileSummaryInfo **)((*(uint64_t (**)(uint64_t, char *))(*(void *)v21 + 96))(v21, llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);

  return llvm::ConstantHoistingPass::runImpl((llvm::ConstantHoistingPass *)(a1 + 4), (llvm::Module **)a2, (llvm::TargetTransformInfo *)TTI, v15, v16, v23, v27);
}

void sub_1CCD1C480(uint64_t a1, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    do
    {
      sub_1CBB23C3C((_DWORD *)a1, v4, (uint64_t)v17);
      if (v17[16])
      {
        uint64_t v7 = *(void **)(a1 + 32);
        unint64_t v6 = *(void *)(a1 + 40);
        if ((unint64_t)v7 >= v6)
        {
          uint64_t v9 = *(void **)(a1 + 24);
          uint64_t v10 = v7 - v9;
          unint64_t v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 61) {
            abort();
          }
          uint64_t v12 = v6 - (void)v9;
          if (v12 >> 2 > v11) {
            unint64_t v11 = v12 >> 2;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v11;
          }
          if (v13)
          {
            if (v13 >> 61) {
              sub_1CB833614();
            }
            uint64_t v14 = (char *)operator new(8 * v13);
          }
          else
          {
            uint64_t v14 = 0;
          }
          uint64_t v15 = &v14[8 * v10];
          *(void *)uint64_t v15 = *v4;
          uint64_t v8 = v15 + 8;
          if (v7 != v9)
          {
            do
            {
              uint64_t v16 = *--v7;
              *((void *)v15 - 1) = v16;
              v15 -= 8;
            }
            while (v7 != v9);
            uint64_t v7 = *(void **)(a1 + 24);
          }
          *(void *)(a1 + 24) = v15;
          *(void *)(a1 + 32) = v8;
          *(void *)(a1 + 40) = &v14[8 * v13];
          if (v7) {
            operator delete(v7);
          }
        }
        else
        {
          *uint64_t v7 = *v4;
          uint64_t v8 = v7 + 1;
        }
        *(void *)(a1 + 32) = v8;
      }
      ++v4;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CCD1C5C0(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x186186186186187) {
      abort();
    }
    unint64_t v6 = (void *)result;
    uint64_t v7 = 168 * a4;
    uint64_t result = (uint64_t)operator new(168 * a4);
    *unint64_t v6 = result;
    v6[1] = result;
    for (v6[2] = result + v7; a2 != a3; result += 168)
    {
      *(void *)uint64_t result = result + 16;
      *(void *)(result + 8) = 0x800000000;
      if (*(_DWORD *)(a2 + 8)) {
        uint64_t result = sub_1CD629BB0(result, a2);
      }
      *(_OWORD *)(result + 144) = *(_OWORD *)(a2 + 144);
      *(_DWORD *)(result + 160) = *(_DWORD *)(a2 + 160);
      a2 += 168;
    }
    v6[1] = result;
  }
  return result;
}

uint64_t sub_1CCD1C68C(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x186186186186186) {
    abort();
  }
  if (0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3);
  }
  if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= 0xC30C30C30C30C3) {
    unint64_t v6 = 0x186186186186186;
  }
  else {
    unint64_t v6 = v3;
  }
  uint64_t v20 = a1 + 2;
  if (v6)
  {
    if (v6 > 0x186186186186186) {
      sub_1CB833614();
    }
    uint64_t v7 = (char *)operator new(168 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[168 * v2];
  long long __p = v7;
  uint64_t v17 = v8;
  uint64_t v19 = &v7[168 * v6];
  *(void *)uint64_t v8 = v8 + 16;
  *((void *)v8 + 1) = 0x800000000;
  if (*(_DWORD *)(a2 + 8)) {
    sub_1CD727100((uint64_t)&v7[168 * v2], a2);
  }
  uint64_t v9 = &v7[168 * v2];
  *((_OWORD *)v9 + 9) = *(_OWORD *)(a2 + 144);
  *((_DWORD *)v9 + 40) = *(_DWORD *)(a2 + 160);
  uint64_t v18 = v8 + 168;
  sub_1CD7609A0(a1, &__p);
  uint64_t v10 = a1[1];
  unint64_t v11 = v17;
  uint64_t v12 = v18;
  while (v12 != v11)
  {
    uint64_t v14 = (char *)*((void *)v12 - 21);
    v12 -= 168;
    unint64_t v13 = v14;
    if (v12 + 16 != v14) {
      free(v13);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v10;
}

void sub_1CCD1C80C(uint64_t *a1, long long *a2)
{
  unint64_t v4 = a1[2];
  uint64_t v5 = (void *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = ((uint64_t)v5 - *a1) >> 5;
    unint64_t v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 59) {
      abort();
    }
    uint64_t v9 = v4 - *a1;
    if (v9 >> 4 > v8) {
      unint64_t v8 = v9 >> 4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    uint64_t v22 = a1 + 2;
    if (v10 >> 59) {
      sub_1CB833614();
    }
    unint64_t v11 = (char *)operator new(32 * v10);
    long long v12 = *a2;
    long long v13 = a2[1];
    uint64_t v14 = &v11[32 * v7];
    long long __p = v11;
    uint64_t v19 = v14;
    *((void *)v14 + 2) = 0;
    *((void *)v14 + 3) = 0;
    *(_OWORD *)uint64_t v14 = v12;
    *((_OWORD *)v14 + 1) = v13;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v20 = v14 + 32;
    uint64_t v21 = &v11[32 * v10];
    sub_1CD58F244(a1, &__p);
    unint64_t v6 = (void *)a1[1];
    uint64_t v16 = v19;
    uint64_t v15 = v20;
    if (v20 != v19)
    {
      do
      {
        uint64_t v17 = v15 - 32;
        uint64_t v23 = (void **)(v15 - 24);
        sub_1CCCB6C5C(&v23);
        uint64_t v15 = v17;
      }
      while (v17 != v16);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    *uint64_t v5 = *(void *)a2;
    v5[1] = 0;
    void v5[2] = 0;
    v5[3] = 0;
    *(_OWORD *)(v5 + 1) = *(long long *)((char *)a2 + 8);
    v5[3] = *((void *)a2 + 3);
    unint64_t v6 = v5 + 4;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *((void *)a2 + 3) = 0;
  }
  a1[1] = (uint64_t)v6;
}

void sub_1CCD1C944(uint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v5 = (void *)a1[1];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = 0x54F43E32D21C10BLL * (((uint64_t)v5 - *a1) >> 3);
    if ((unint64_t)(v7 + 1) > 0xC22E450672894) {
      abort();
    }
    unint64_t v8 = 0x54F43E32D21C10BLL * ((uint64_t)(v4 - *a1) >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= v7 + 1) {
      uint64_t v9 = v7 + 1;
    }
    if (v8 >= 0x611722833944ALL) {
      unint64_t v10 = 0xC22E450672894;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t v21 = a1 + 2;
    if (v10 > 0xC22E450672894) {
      sub_1CB833614();
    }
    uint64_t v11 = 5400 * v10;
    long long v12 = (char *)operator new(5400 * v10);
    long long v13 = &v12[5400 * v7];
    long long __p = v12;
    uint64_t v18 = v13;
    uint64_t v20 = &v12[v11];
    *(void *)long long v13 = *(void *)a2;
    *((void *)v13 + 1) = v13 + 24;
    *((void *)v13 + 2) = 0x800000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD726A60((uint64_t)(v13 + 8), a2 + 8);
    }
    uint64_t v19 = v13 + 5400;
    sub_1CD760BF8(a1, &__p);
    unint64_t v6 = (void *)a1[1];
    uint64_t v15 = v18;
    uint64_t v14 = (char **)v19;
    if (v19 != v18)
    {
      do
      {
        uint64_t v16 = v14 - 675;
        sub_1CD719C14(v14 - 674);
        uint64_t v14 = v16;
      }
      while (v16 != (char **)v15);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    *uint64_t v5 = *(void *)a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x800000000;
    if (*(_DWORD *)(a2 + 16)) {
      sub_1CD726A60((uint64_t)(v5 + 1), a2 + 8);
    }
    unint64_t v6 = v5 + 675;
  }
  a1[1] = (uint64_t)v6;
}

void sub_1CCD1CAFC(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  if (a3 < 2) {
    return;
  }
  uint64_t v6 = a1;
  if (a3 == 2)
  {
    uint64_t v8 = a2 - 24;
    uint64_t v7 = *(void *)(a2 - 24);
    unint64_t v10 = (long long *)(a1 + 144);
    uint64_t v9 = *(void **)(a1 + 144);
    if (*(void *)v7 == *v9)
    {
      uint64_t v17 = *(unsigned int *)(v7 + 32);
      if (v17 > 0x40)
      {
        uint64_t v70 = *(void *)(v7 + 24);
        uint64_t v71 = v9[3] - 8;
        unint64_t v72 = ((unint64_t)(v17 + 63) >> 3) & 0x3FFFFFF8;
        uint64_t v73 = v70 - 8;
        while (v72)
        {
          unint64_t v74 = *(void *)(v73 + v72);
          unint64_t v75 = *(void *)(v71 + v72);
          v72 -= 8;
          if (v74 != v75)
          {
            if (v74 <= v75) {
              goto LABEL_13;
            }
            return;
          }
        }
        return;
      }
      if (*(void *)(v7 + 24) >= v9[3]) {
        return;
      }
    }
    else if (*(_DWORD *)(*(void *)v7 + 8) >> 8 >= *(_DWORD *)(*v9 + 8) >> 8)
    {
      return;
    }
LABEL_13:
    unint64_t v76 = v78;
    uint64_t v77 = 0x800000000;
    if (*(_DWORD *)(a1 + 8)) {
      sub_1CD727100((uint64_t)&v76, a1);
    }
    long long v18 = *v10;
    int v80 = *(_DWORD *)(v6 + 160);
    long long v79 = v18;
    sub_1CD727100(v6, v8 - 144);
    int v19 = *(_DWORD *)(v8 + 16);
    *unint64_t v10 = *(_OWORD *)v8;
    *(_DWORD *)(v6 + 160) = v19;
    sub_1CD727100(v8 - 144, (uint64_t)&v76);
    long long v20 = v79;
    *(_DWORD *)(v8 + 16) = v80;
    *(_OWORD *)uint64_t v8 = v20;
    if (v76 != v78) {
      free(v76);
    }
    return;
  }
  if ((uint64_t)a3 <= 0)
  {
    if (a1 == a2) {
      return;
    }
    uint64_t v21 = a1 + 168;
    if (a1 + 168 == a2) {
      return;
    }
    uint64_t v22 = a1;
    while (1)
    {
      uint64_t v23 = v22;
      uint64_t v22 = v21;
      uint64_t v25 = v23 + 144;
      uint64_t v24 = *(void **)(v23 + 144);
      uint64_t v26 = *(void *)(v23 + 312);
      if (*(void *)v26 != *v24) {
        break;
      }
      uint64_t v27 = *(unsigned int *)(v26 + 32);
      if (v27 <= 0x40)
      {
        if (*(void *)(v26 + 24) >= v24[3]) {
          goto LABEL_43;
        }
LABEL_25:
        unint64_t v76 = v78;
        uint64_t v77 = 0x800000000;
        if (*(_DWORD *)(v23 + 176)) {
          sub_1CD727100((uint64_t)&v76, v22);
        }
        long long v79 = *(_OWORD *)(v23 + 312);
        int v80 = *(_DWORD *)(v23 + 328);
        sub_1CD727100(v22, v23);
        int v28 = *(_DWORD *)(v23 + 160);
        *(_OWORD *)(v22 + 144) = *(_OWORD *)v25;
        for (*(_DWORD *)(v22 + 160) = v28; v23 != v6; v23 -= 168)
        {
          uint64_t v29 = v25;
          uint64_t v25 = v23 - 24;
          uint64_t v30 = *(void **)(v23 - 24);
          if (*(void *)v79 == *v30)
          {
            uint64_t v31 = *(unsigned int *)(v79 + 32);
            if (v31 > 0x40)
            {
              uint64_t v32 = v30[3] - 8;
              unint64_t v33 = ((unint64_t)(v31 + 63) >> 3) & 0x3FFFFFF8;
              do
              {
                if (!v33) {
                  goto LABEL_40;
                }
                unint64_t v34 = *(void *)(*(void *)(v79 + 24) - 8 + v33);
                unint64_t v35 = *(void *)(v32 + v33);
                v33 -= 8;
              }
              while (v34 == v35);
              if (v34 > v35)
              {
LABEL_40:
                uint64_t v25 = v29;
                goto LABEL_41;
              }
            }
            else if (*(void *)(v79 + 24) >= v30[3])
            {
              goto LABEL_40;
            }
          }
          else if (*(_DWORD *)(*(void *)v79 + 8) >> 8 >= *(_DWORD *)(*v30 + 8) >> 8)
          {
            goto LABEL_40;
          }
          sub_1CD727100(v23, v23 - 168);
          *(_OWORD *)(v23 + 144) = *(_OWORD *)v25;
          *(_DWORD *)(v23 + 160) = *(_DWORD *)(v23 - 8);
        }
        uint64_t v23 = v6;
LABEL_41:
        sub_1CD727100(v23, (uint64_t)&v76);
        long long v36 = v79;
        *(_DWORD *)(v25 + 16) = v80;
        *(_OWORD *)uint64_t v25 = v36;
        if (v76 != v78) {
          free(v76);
        }
        goto LABEL_43;
      }
      uint64_t v37 = *(void *)(v26 + 24);
      uint64_t v38 = v24[3] - 8;
      unint64_t v39 = ((unint64_t)(v27 + 63) >> 3) & 0x3FFFFFF8;
      uint64_t v40 = v37 - 8;
      do
      {
        if (!v39) {
          goto LABEL_43;
        }
        unint64_t v41 = *(void *)(v40 + v39);
        unint64_t v42 = *(void *)(v38 + v39);
        v39 -= 8;
      }
      while (v41 == v42);
      if (v41 <= v42) {
        goto LABEL_25;
      }
LABEL_43:
      uint64_t v21 = v22 + 168;
      if (v22 + 168 == a2) {
        return;
      }
    }
    if (*(_DWORD *)(*(void *)v26 + 8) >> 8 >= *(_DWORD *)(*v24 + 8) >> 8) {
      goto LABEL_43;
    }
    goto LABEL_25;
  }
  long long v13 = a4;
  unint64_t v14 = a3 >> 1;
  uint64_t v15 = a1 + 168 * (a3 >> 1);
  unint64_t v16 = a3 >> 1;
  if ((uint64_t)a3 > a5)
  {
    sub_1CCD1CAFC(a1, v15, v16, a4, a5);
    sub_1CCD1CAFC(v6 + 168 * (a3 >> 1), a2, a3 - (a3 >> 1), v13, a5);
    sub_1CCD1D7B8(v6, v6 + 168 * (a3 >> 1), a2, a3 >> 1, a3 - (a3 >> 1), v13, a5);
    return;
  }
  sub_1CCD1D134(a1, v15, v16, a4);
  unsigned int v43 = &v13[21 * v14];
  sub_1CCD1D134(v6 + 168 * (a3 >> 1), a2, a3 - (a3 >> 1), v43);
  BOOL v44 = &v13[21 * a3];
  uint64_t v45 = (uint64_t)v43;
  uint64_t v46 = (uint64_t)v13;
  while ((void *)v45 != v44)
  {
    uint64_t v47 = *(void *)(v45 + 144);
    uint64_t v48 = *(void **)(v46 + 144);
    if (*(void *)v47 == *v48)
    {
      uint64_t v49 = *(unsigned int *)(v47 + 32);
      if (v49 > 0x40)
      {
        uint64_t v51 = *(void *)(v47 + 24);
        uint64_t v52 = v48[3] - 8;
        unint64_t v53 = ((unint64_t)(v49 + 63) >> 3) & 0x3FFFFFF8;
        uint64_t v54 = v51 - 8;
        while (v53)
        {
          unint64_t v55 = *(void *)(v54 + v53);
          unint64_t v56 = *(void *)(v52 + v53);
          v53 -= 8;
          if (v55 != v56)
          {
            if (v55 <= v56) {
              goto LABEL_57;
            }
            break;
          }
        }
LABEL_62:
        sub_1CD727100(v6, v46);
        int v57 = *(_DWORD *)(v46 + 160);
        *(_OWORD *)(v6 + 144) = *(_OWORD *)(v46 + 144);
        *(_DWORD *)(v6 + 160) = v57;
        v46 += 168;
        goto LABEL_63;
      }
      if (*(void *)(v47 + 24) >= v48[3]) {
        goto LABEL_62;
      }
    }
    else if (*(_DWORD *)(*(void *)v47 + 8) >> 8 >= *(_DWORD *)(*v48 + 8) >> 8)
    {
      goto LABEL_62;
    }
LABEL_57:
    sub_1CD727100(v6, v45);
    int v50 = *(_DWORD *)(v45 + 160);
    *(_OWORD *)(v6 + 144) = *(_OWORD *)(v45 + 144);
    *(_DWORD *)(v6 + 160) = v50;
    v45 += 168;
LABEL_63:
    v6 += 168;
    if ((void *)v46 == v43)
    {
      if ((void *)v45 != v44)
      {
        uint64_t v58 = 0;
        do
        {
          uint64_t v59 = v45 + v58;
          uint64_t v60 = v6 + v58;
          sub_1CD727100(v6 + v58, v45 + v58);
          int v61 = *(_DWORD *)(v45 + v58 + 160);
          *(_OWORD *)(v60 + 144) = *(_OWORD *)(v45 + v58 + 144);
          *(_DWORD *)(v60 + 160) = v61;
          v58 += 168;
        }
        while ((void *)(v59 + 168) != v44);
      }
      goto LABEL_71;
    }
  }
  if ((void *)v46 != v43)
  {
    uint64_t v62 = 0;
    do
    {
      uint64_t v63 = v46 + v62;
      uint64_t v64 = v6 + v62;
      sub_1CD727100(v6 + v62, v46 + v62);
      int v65 = *(_DWORD *)(v46 + v62 + 160);
      *(_OWORD *)(v64 + 144) = *(_OWORD *)(v46 + v62 + 144);
      *(_DWORD *)(v64 + 160) = v65;
      v62 += 168;
    }
    while ((void *)(v63 + 168) != v43);
  }
LABEL_71:
  if (v13)
  {
    unint64_t v66 = a3;
    do
    {
      unint64_t v69 = (void *)*v13;
      uint64_t v68 = v13 + 2;
      int v67 = v69;
      if (v69 != v68) {
        free(v67);
      }
      long long v13 = v68 + 19;
      --v66;
    }
    while (v66);
  }
}

uint64_t sub_1CCD1D134(uint64_t result, uint64_t a2, unint64_t a3, void *a4)
{
  if (!a3) {
    return result;
  }
  uint64_t v4 = (uint64_t)a4;
  uint64_t v7 = result;
  if (a3 == 2)
  {
    unint64_t v10 = (long long *)(a2 - 24);
    uint64_t v9 = *(void *)(a2 - 24);
    long long v12 = (long long *)(result + 144);
    uint64_t v11 = *(void **)(result + 144);
    if (*(void *)v9 == *v11)
    {
      uint64_t v55 = *(unsigned int *)(v9 + 32);
      if (v55 > 0x40)
      {
        uint64_t v69 = *(void *)(v9 + 24);
        uint64_t v70 = v11[3] - 8;
        unint64_t v71 = ((unint64_t)(v55 + 63) >> 3) & 0x3FFFFFF8;
        uint64_t v72 = v69 - 8;
        do
        {
          if (!v71) {
            goto LABEL_88;
          }
          unint64_t v73 = *(void *)(v72 + v71);
          unint64_t v74 = *(void *)(v70 + v71);
          v71 -= 8;
        }
        while (v73 == v74);
        if (v73 > v74) {
          goto LABEL_88;
        }
      }
      else if (*(void *)(v9 + 24) >= v11[3])
      {
LABEL_88:
        *a4 = a4 + 2;
        a4[1] = 0x800000000;
        if (*(_DWORD *)(result + 8)) {
          sub_1CD727100((uint64_t)a4, result);
        }
        long long v75 = *v12;
        int v76 = *(_DWORD *)(v7 + 160);
        *(void *)(v4 + 168) = v4 + 184;
        uint64_t result = v4 + 168;
        *(_DWORD *)(v4 + 160) = v76;
        *(_OWORD *)(v4 + 144) = v75;
        *(void *)(v4 + 176) = 0x800000000;
        if (*(_DWORD *)(a2 - 160)) {
          uint64_t result = sub_1CD727100(result, a2 - 168);
        }
        uint64_t v58 = (_OWORD *)(v4 + 312);
        long long v59 = *v10;
        int v60 = *(_DWORD *)(a2 - 8);
LABEL_93:
        *(_DWORD *)(v4 + 328) = v60;
        *uint64_t v58 = v59;
        return result;
      }
    }
    else if (*(_DWORD *)(*(void *)v9 + 8) >> 8 >= *(_DWORD *)(*v11 + 8) >> 8)
    {
      goto LABEL_88;
    }
    *a4 = a4 + 2;
    a4[1] = 0x800000000;
    if (*(_DWORD *)(a2 - 160)) {
      sub_1CD727100((uint64_t)a4, a2 - 168);
    }
    long long v56 = *v10;
    int v57 = *(_DWORD *)(a2 - 8);
    *(void *)(v4 + 168) = v4 + 184;
    uint64_t result = v4 + 168;
    *(_DWORD *)(v4 + 160) = v57;
    *(_OWORD *)(v4 + 144) = v56;
    *(void *)(v4 + 176) = 0x800000000;
    if (*(_DWORD *)(v7 + 8)) {
      uint64_t result = sub_1CD727100(result, v7);
    }
    uint64_t v58 = (_OWORD *)(v4 + 312);
    long long v59 = *v12;
    int v60 = *(_DWORD *)(v7 + 160);
    goto LABEL_93;
  }
  if (a3 == 1)
  {
    *a4 = a4 + 2;
    a4[1] = 0x800000000;
    if (*(_DWORD *)(result + 8)) {
      uint64_t result = sub_1CD727100((uint64_t)a4, result);
    }
    long long v8 = *(_OWORD *)(v7 + 144);
    *(_DWORD *)(v4 + 160) = *(_DWORD *)(v7 + 160);
    *(_OWORD *)(v4 + 144) = v8;
    return result;
  }
  if ((uint64_t)a3 > 8)
  {
    uint64_t v41 = 168 * (a3 >> 1);
    uint64_t v42 = result + v41;
    sub_1CCD1CAFC(result, result + v41, a3 >> 1, a4, a3 >> 1);
    uint64_t result = sub_1CCD1CAFC(v7 + v41, a2, a3 - (a3 >> 1), v4 + v41, a3 - (a3 >> 1));
    uint64_t v43 = v7 + v41;
    while (1)
    {
      if (v43 == a2)
      {
        if (v7 != v42)
        {
          uint64_t v61 = 0;
          do
          {
            uint64_t v62 = v4 + v61;
            uint64_t v63 = v7 + v61;
            *(void *)uint64_t v62 = v4 + v61 + 16;
            *(void *)(v62 + 8) = 0x800000000;
            if (*(_DWORD *)(v7 + v61 + 8)) {
              uint64_t result = sub_1CD727100(v4 + v61, v7 + v61);
            }
            v61 += 168;
            long long v64 = *(_OWORD *)(v63 + 144);
            *(_DWORD *)(v62 + 160) = *(_DWORD *)(v63 + 160);
            *(_OWORD *)(v62 + 144) = v64;
          }
          while (v7 + v61 != v42);
        }
        return result;
      }
      uint64_t v44 = *(void *)(v43 + 144);
      uint64_t v45 = *(void **)(v7 + 144);
      if (*(void *)v44 == *v45)
      {
        uint64_t v46 = *(unsigned int *)(v44 + 32);
        if (v46 > 0x40)
        {
          uint64_t v48 = *(void *)(v44 + 24);
          uint64_t v49 = v45[3] - 8;
          unint64_t v50 = ((unint64_t)(v46 + 63) >> 3) & 0x3FFFFFF8;
          uint64_t v51 = v48 - 8;
          do
          {
            if (!v50) {
              goto LABEL_60;
            }
            unint64_t v52 = *(void *)(v51 + v50);
            unint64_t v53 = *(void *)(v49 + v50);
            v50 -= 8;
          }
          while (v52 == v53);
          if (v52 <= v53)
          {
LABEL_53:
            *(void *)uint64_t v4 = v4 + 16;
            *(void *)(v4 + 8) = 0x800000000;
            if (*(_DWORD *)(v43 + 8)) {
              uint64_t result = sub_1CD727100(v4, v43);
            }
            long long v47 = *(_OWORD *)(v43 + 144);
            *(_DWORD *)(v4 + 160) = *(_DWORD *)(v43 + 160);
            *(_OWORD *)(v4 + 144) = v47;
            v43 += 168;
            goto LABEL_63;
          }
        }
        else if (*(void *)(v44 + 24) < v45[3])
        {
          goto LABEL_53;
        }
      }
      else if (*(_DWORD *)(*(void *)v44 + 8) >> 8 < *(_DWORD *)(*v45 + 8) >> 8)
      {
        goto LABEL_53;
      }
LABEL_60:
      *(void *)uint64_t v4 = v4 + 16;
      *(void *)(v4 + 8) = 0x800000000;
      if (*(_DWORD *)(v7 + 8)) {
        uint64_t result = sub_1CD727100(v4, v7);
      }
      long long v54 = *(_OWORD *)(v7 + 144);
      *(_DWORD *)(v4 + 160) = *(_DWORD *)(v7 + 160);
      *(_OWORD *)(v4 + 144) = v54;
      v7 += 168;
LABEL_63:
      v4 += 168;
      if (v7 == v42)
      {
        if (v43 != a2)
        {
          uint64_t v65 = 0;
          do
          {
            uint64_t v66 = v43 + v65;
            uint64_t v67 = v4 + v65;
            *(void *)uint64_t v67 = v4 + v65 + 16;
            *(void *)(v67 + 8) = 0x800000000;
            if (*(_DWORD *)(v43 + v65 + 8)) {
              uint64_t result = sub_1CD727100(v4 + v65, v43 + v65);
            }
            v65 += 168;
            long long v68 = *(_OWORD *)(v66 + 144);
            *(_DWORD *)(v67 + 160) = *(_DWORD *)(v66 + 160);
            *(_OWORD *)(v67 + 144) = v68;
          }
          while (v43 + v65 != a2);
        }
        return result;
      }
    }
  }
  if (result == a2) {
    return result;
  }
  *a4 = a4 + 2;
  a4[1] = 0x800000000;
  if (*(_DWORD *)(result + 8)) {
    uint64_t result = sub_1CD727100((uint64_t)a4, result);
  }
  long long v13 = *(_OWORD *)(v7 + 144);
  *(_DWORD *)(v4 + 160) = *(_DWORD *)(v7 + 160);
  *(_OWORD *)(v4 + 144) = v13;
  uint64_t v14 = v7 + 168;
  if (v7 + 168 == a2) {
    return result;
  }
  uint64_t v15 = v4;
  do
  {
    uint64_t v16 = v14;
    uint64_t v17 = *(void **)(v15 + 144);
    uint64_t v18 = v15 + 168;
    uint64_t v19 = v7 + 312;
    uint64_t v20 = *(void *)(v7 + 312);
    if (*(void *)v20 == *v17)
    {
      uint64_t v21 = *(unsigned int *)(v20 + 32);
      if (v21 > 0x40)
      {
        uint64_t v34 = *(void *)(v20 + 24);
        uint64_t v35 = v17[3] - 8;
        unint64_t v36 = ((unint64_t)(v21 + 63) >> 3) & 0x3FFFFFF8;
        uint64_t v37 = v34 - 8;
        do
        {
          if (!v36) {
            goto LABEL_41;
          }
          unint64_t v38 = *(void *)(v37 + v36);
          unint64_t v39 = *(void *)(v35 + v36);
          v36 -= 8;
        }
        while (v38 == v39);
        if (v38 > v39)
        {
LABEL_41:
          *(void *)(v15 + 168) = v15 + 184;
          *(void *)(v15 + 176) = 0x800000000;
          if (*(_DWORD *)(v7 + 176)) {
            uint64_t result = sub_1CD727100(v15 + 168, v16);
          }
          uint64_t v33 = v15 + 312;
          goto LABEL_44;
        }
      }
      else if (*(void *)(v20 + 24) >= v17[3])
      {
        goto LABEL_41;
      }
    }
    else if (*(_DWORD *)(*(void *)v20 + 8) >> 8 >= *(_DWORD *)(*v17 + 8) >> 8)
    {
      goto LABEL_41;
    }
    *(void *)(v15 + 168) = v15 + 184;
    *(void *)(v15 + 176) = 0x800000000;
    if (*(_DWORD *)(v15 + 8)) {
      sub_1CD727100(v15 + 168, v15);
    }
    *(_OWORD *)(v15 + 312) = *(_OWORD *)(v15 + 144);
    *(_DWORD *)(v15 + 328) = *(_DWORD *)(v15 + 160);
    uint64_t v22 = v4;
    if (v15 == v4) {
      goto LABEL_36;
    }
    while (1)
    {
      uint64_t v23 = *(void **)(v15 - 24);
      uint64_t v24 = *(uint64_t **)v19;
      uint64_t v25 = **(void **)v19;
      if (v25 == *v23) {
        break;
      }
      if (*(_DWORD *)(v25 + 8) >> 8 >= *(_DWORD *)(*v23 + 8) >> 8) {
        goto LABEL_35;
      }
LABEL_29:
      sub_1CD727100(v15, v15 - 168);
      *(_OWORD *)(v15 + 144) = *(_OWORD *)(v15 - 24);
      *(_DWORD *)(v15 + 160) = *(_DWORD *)(v15 - 8);
      v15 -= 168;
      if (v15 == v4)
      {
        uint64_t v22 = v4;
        goto LABEL_36;
      }
    }
    uint64_t v26 = *((unsigned int *)v24 + 8);
    if (v26 <= 0x40)
    {
      if ((unint64_t)v24[3] >= v23[3]) {
        goto LABEL_35;
      }
      goto LABEL_29;
    }
    uint64_t v27 = v24[3];
    uint64_t v28 = v23[3] - 8;
    unint64_t v29 = ((unint64_t)(v26 + 63) >> 3) & 0x3FFFFFF8;
    uint64_t v30 = v27 - 8;
    while (v29)
    {
      unint64_t v31 = *(void *)(v30 + v29);
      unint64_t v32 = *(void *)(v28 + v29);
      v29 -= 8;
      if (v31 != v32)
      {
        if (v31 <= v32) {
          goto LABEL_29;
        }
        break;
      }
    }
LABEL_35:
    uint64_t v22 = v15;
LABEL_36:
    uint64_t result = sub_1CD727100(v22, v16);
    uint64_t v33 = v22 + 144;
LABEL_44:
    long long v40 = *(_OWORD *)v19;
    *(_DWORD *)(v33 + 16) = *(_DWORD *)(v19 + 16);
    *(_OWORD *)uint64_t v33 = v40;
    uint64_t v14 = v16 + 168;
    uint64_t v15 = v18;
    uint64_t v7 = v16;
  }
  while (v16 + 168 != a2);
  return result;
}

void sub_1CCD1D7B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  if (!a5) {
    return;
  }
  uint64_t v7 = a5;
  uint64_t v130 = a7;
  unsigned int v131 = a6;
  do
  {
    if (a4 <= a7 || v7 <= a7)
    {
      unint64_t v71 = a6;
      if (a4 > v7)
      {
        if (a2 == a3) {
          return;
        }
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        do
        {
          uint64_t v74 = a3;
          long long v75 = &a6[v72];
          uint64_t v76 = a2 + v72 * 8;
          void *v75 = &a6[v72 + 2];
          v75[1] = 0x800000000;
          if (*(_DWORD *)(a2 + v72 * 8 + 8))
          {
            sub_1CD727100((uint64_t)&a6[v72], a2 + v72 * 8);
            a6 = v71;
          }
          long long v77 = *(_OWORD *)(v76 + 144);
          *((_DWORD *)v75 + 40) = *(_DWORD *)(v76 + 160);
          *((_OWORD *)v75 + 9) = v77;
          ++v73;
          v72 += 21;
          a3 = v74;
        }
        while (a2 + v72 * 8 != v74);
        if (!(v72 * 8)) {
          goto LABEL_153;
        }
        unint64_t v83 = &a6[v72];
        while (1)
        {
          if (a2 == a1)
          {
            if (v83 != a6)
            {
              uint64_t v113 = a3;
              uint64_t v114 = 0;
              do
              {
                uint64_t v115 = v113 + v114 * 8;
                sub_1CD727100(v113 + v114 * 8 - 168, (uint64_t)&v83[v114 - 21]);
                int v116 = v83[v114 - 1];
                *(_OWORD *)(v115 - 24) = *(_OWORD *)&v83[v114 - 3];
                *(_DWORD *)(v115 - 8) = v116;
                v114 -= 21;
              }
              while (&v83[v114] != v71);
              goto LABEL_152;
            }
            goto LABEL_153;
          }
          uint64_t v85 = a2 - 24;
          int v84 = *(void **)(a2 - 24);
          uint64_t v86 = a2 - 168;
          uint64_t v87 = *(v83 - 3);
          if (*(void *)v87 == *v84)
          {
            uint64_t v88 = *(unsigned int *)(v87 + 32);
            if (v88 > 0x40)
            {
              uint64_t v93 = *(void *)(v87 + 24);
              uint64_t v94 = v84[3] - 8;
              unint64_t v95 = ((unint64_t)(v88 + 63) >> 3) & 0x3FFFFFF8;
              uint64_t v96 = v93 - 8;
              do
              {
                if (!v95) {
                  goto LABEL_121;
                }
                unint64_t v97 = *(void *)(v96 + v95);
                unint64_t v98 = *(void *)(v94 + v95);
                v95 -= 8;
              }
              while (v97 == v98);
              uint64_t v89 = a2 - 168;
              if (v97 <= v98) {
                goto LABEL_122;
              }
LABEL_121:
              uint64_t v86 = (uint64_t)(v83 - 21);
              uint64_t v85 = (uint64_t)(v83 - 3);
              uint64_t v89 = a2;
              v83 -= 21;
              goto LABEL_122;
            }
            uint64_t v89 = a2 - 168;
            if (*(void *)(v87 + 24) >= v84[3]) {
              goto LABEL_121;
            }
          }
          else
          {
            uint64_t v89 = a2 - 168;
            if (*(_DWORD *)(*(void *)v87 + 8) >> 8 >= *(_DWORD *)(*v84 + 8) >> 8) {
              goto LABEL_121;
            }
          }
LABEL_122:
          uint64_t v90 = a3;
          uint64_t v91 = a3 - 168;
          sub_1CD727100(a3 - 168, v86);
          int v92 = *(_DWORD *)(v85 + 16);
          *(_OWORD *)(v90 - 24) = *(_OWORD *)v85;
          *(_DWORD *)(v90 - 8) = v92;
          a2 = v89;
          a3 = v91;
          a6 = v71;
          if (v83 == v71) {
            goto LABEL_153;
          }
        }
      }
      if (a1 == a2) {
        return;
      }
      uint64_t v78 = a3;
      uint64_t v79 = 0;
      uint64_t v73 = 0;
      do
      {
        int v80 = &a6[v79];
        uint64_t v81 = a1 + v79 * 8;
        *int v80 = &a6[v79 + 2];
        v80[1] = 0x800000000;
        if (*(_DWORD *)(a1 + v79 * 8 + 8))
        {
          sub_1CD727100((uint64_t)&a6[v79], a1 + v79 * 8);
          a6 = v71;
        }
        long long v82 = *(_OWORD *)(v81 + 144);
        *((_DWORD *)v80 + 40) = *(_DWORD *)(v81 + 160);
        *((_OWORD *)v80 + 9) = v82;
        ++v73;
        v79 += 21;
      }
      while (a1 + v79 * 8 != a2);
      if (!(v79 * 8)) {
        goto LABEL_153;
      }
      __int16 v99 = &a6[v79];
      uint64_t v100 = (uint64_t)&a6[v79 - 21];
      uint64_t v101 = (uint64_t)a6;
      while (1)
      {
        if (a2 == v78)
        {
          if (v99 != (void *)v101)
          {
            uint64_t v117 = 0;
            do
            {
              uint64_t v118 = a1 + v117;
              uint64_t v119 = v101 + v117;
              sub_1CD727100(a1 + v117, v101 + v117);
              int v120 = *(_DWORD *)(v101 + v117 + 160);
              *(_OWORD *)(v118 + 144) = *(_OWORD *)(v101 + v117 + 144);
              *(_DWORD *)(v118 + 160) = v120;
              v117 += 168;
            }
            while (v100 != v119);
LABEL_152:
            a6 = v71;
          }
LABEL_153:
          if (a6 && v73)
          {
            do
            {
              uint64_t v123 = (void *)*a6;
              unsigned int v122 = a6 + 2;
              uint64_t v121 = v123;
              if (v123 != v122)
              {
                unsigned int v124 = v122;
                free(v121);
                unsigned int v122 = v124;
              }
              a6 = v122 + 19;
              --v73;
            }
            while (v73);
          }
          return;
        }
        uint64_t v102 = *(void *)(a2 + 144);
        unsigned int v103 = *(void **)(v101 + 144);
        if (*(void *)v102 == *v103)
        {
          uint64_t v104 = *(unsigned int *)(v102 + 32);
          if (v104 > 0x40)
          {
            uint64_t v106 = *(void *)(v102 + 24);
            uint64_t v107 = v103[3] - 8;
            unint64_t v108 = ((unint64_t)(v104 + 63) >> 3) & 0x3FFFFFF8;
            uint64_t v109 = v106 - 8;
            do
            {
              if (!v108) {
                goto LABEL_142;
              }
              unint64_t v110 = *(void *)(v109 + v108);
              unint64_t v111 = *(void *)(v107 + v108);
              v108 -= 8;
            }
            while (v110 == v111);
            if (v110 > v111)
            {
LABEL_142:
              sub_1CD727100(a1, v101);
              int v112 = *(_DWORD *)(v101 + 160);
              *(_OWORD *)(a1 + 144) = *(_OWORD *)(v101 + 144);
              *(_DWORD *)(a1 + 160) = v112;
              v101 += 168;
              goto LABEL_143;
            }
          }
          else if (*(void *)(v102 + 24) >= v103[3])
          {
            goto LABEL_142;
          }
        }
        else if (*(_DWORD *)(*(void *)v102 + 8) >> 8 >= *(_DWORD *)(*v103 + 8) >> 8)
        {
          goto LABEL_142;
        }
        sub_1CD727100(a1, a2);
        int v105 = *(_DWORD *)(a2 + 160);
        *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
        *(_DWORD *)(a1 + 160) = v105;
        a2 += 168;
LABEL_143:
        a1 += 168;
        a6 = v71;
        if (v99 == (void *)v101) {
          goto LABEL_153;
        }
      }
    }
    if (!a4) {
      return;
    }
    uint64_t v11 = *(uint64_t **)(a2 + 144);
    uint64_t v12 = *v11;
    while (1)
    {
      long long v13 = *(void **)(a1 + 144);
      if (v12 != *v13)
      {
        if (*(_DWORD *)(v12 + 8) >> 8 < *(_DWORD *)(*v13 + 8) >> 8) {
          break;
        }
        goto LABEL_12;
      }
      uint64_t v14 = *((unsigned int *)v11 + 8);
      if (v14 > 0x40)
      {
        uint64_t v15 = v13[3] - 8;
        unint64_t v16 = ((unint64_t)(v14 + 63) >> 3) & 0x3FFFFFF8;
        while (v16)
        {
          unint64_t v17 = *(void *)(v11[3] - 8 + v16);
          unint64_t v18 = *(void *)(v15 + v16);
          v16 -= 8;
          if (v17 != v18)
          {
            if (v17 > v18) {
              goto LABEL_12;
            }
            goto LABEL_18;
          }
        }
        goto LABEL_12;
      }
      if ((unint64_t)v11[3] < v13[3]) {
        break;
      }
LABEL_12:
      a1 += 168;
      if (!--a4) {
        return;
      }
    }
LABEL_18:
    uint64_t v135 = v7;
    if (a4 < v7)
    {
      if (v7 >= 0) {
        uint64_t v19 = v7;
      }
      else {
        uint64_t v19 = v7 + 1;
      }
      uint64_t v20 = v19 >> 1;
      if (a2 == a1)
      {
        uint64_t v24 = a2;
      }
      else
      {
        unint64_t v21 = 0xCF3CF3CF3CF3CF3DLL * ((a2 - a1) >> 3);
        uint64_t v22 = *(uint64_t **)(a2 + 168 * v20 + 144);
        uint64_t v23 = *v22;
        uint64_t v24 = a1;
        do
        {
          unint64_t v25 = v21 >> 1;
          unint64_t v26 = v24 + 168 * (v21 >> 1);
          uint64_t v27 = *(void **)(v26 + 144);
          if (v23 == *v27)
          {
            uint64_t v29 = *((unsigned int *)v22 + 8);
            if (v29 > 0x40)
            {
              uint64_t v35 = v27[3] - 8;
              unint64_t v36 = ((unint64_t)(v29 + 63) >> 3) & 0x3FFFFFF8;
              do
              {
                if (!v36)
                {
                  unsigned int v33 = 0;
                  goto LABEL_29;
                }
                unint64_t v37 = *(void *)(v22[3] - 8 + v36);
                unint64_t v38 = *(void *)(v35 + v36);
                v36 -= 8;
              }
              while (v37 == v38);
              if (v37 > v38) {
                unsigned int v33 = 1;
              }
              else {
                unsigned int v33 = -1;
              }
            }
            else
            {
              unint64_t v30 = v22[3];
              unint64_t v31 = v27[3];
              BOOL v32 = v30 >= v31;
              unsigned int v33 = v30 > v31;
              if (!v32) {
                unsigned int v33 = -1;
              }
            }
LABEL_29:
            BOOL v28 = v33 >> 31;
          }
          else
          {
            BOOL v28 = *(_DWORD *)(v23 + 8) >> 8 < *(_DWORD *)(*v27 + 8) >> 8;
          }
          uint64_t v34 = v26 + 168;
          v21 += ~v25;
          if (v28) {
            unint64_t v21 = v25;
          }
          else {
            uint64_t v24 = v34;
          }
        }
        while (v21);
      }
      unint64_t v134 = v20;
      uint64_t v41 = a2 + 168 * v20;
      uint64_t v40 = 0xCF3CF3CF3CF3CF3DLL * ((v24 - a1) >> 3);
      goto LABEL_69;
    }
    if (a4 == 1)
    {
      uint64_t v125 = (long long *)(a2 + 144);
      uint64_t v126 = (long long *)(a1 + 144);
      int v138 = v140;
      uint64_t v139 = 0x800000000;
      if (*(_DWORD *)(a1 + 8)) {
        sub_1CD727100((uint64_t)&v138, a1);
      }
      long long v127 = *v126;
      int v142 = *(_DWORD *)(a1 + 160);
      long long v141 = v127;
      sub_1CD727100(a1, a2);
      int v128 = *(_DWORD *)(a2 + 160);
      *uint64_t v126 = *v125;
      *(_DWORD *)(a1 + 160) = v128;
      sub_1CD727100(a2, (uint64_t)&v138);
      int v129 = v142;
      *uint64_t v125 = v141;
      *(_DWORD *)(a2 + 160) = v129;
      if (v138 != v140) {
        free(v138);
      }
      return;
    }
    if (a4 >= 0) {
      uint64_t v39 = a4;
    }
    else {
      uint64_t v39 = a4 + 1;
    }
    uint64_t v40 = v39 >> 1;
    uint64_t v41 = a3;
    if (a3 != a2)
    {
      unint64_t v42 = 0xCF3CF3CF3CF3CF3DLL * ((a3 - a2) >> 3);
      uint64_t v43 = *(uint64_t **)(a1 + 168 * v40 + 144);
      uint64_t v44 = *v43;
      uint64_t v41 = a2;
      do
      {
        unint64_t v45 = v42 >> 1;
        unint64_t v46 = v41 + 168 * (v42 >> 1);
        uint64_t v47 = *(void *)(v46 + 144);
        if (*(void *)v47 == v44)
        {
          uint64_t v49 = *(unsigned int *)(v47 + 32);
          if (v49 > 0x40)
          {
            unint64_t v54 = ((unint64_t)(v49 + 63) >> 3) & 0x3FFFFFF8;
            do
            {
              if (!v54)
              {
                unsigned int v52 = 0;
                goto LABEL_53;
              }
              unint64_t v55 = *(void *)(*(void *)(v47 + 24) - 8 + v54);
              unint64_t v56 = *(void *)(v43[3] - 8 + v54);
              v54 -= 8;
            }
            while (v55 == v56);
            if (v55 > v56) {
              unsigned int v52 = 1;
            }
            else {
              unsigned int v52 = -1;
            }
          }
          else
          {
            unint64_t v50 = *(void *)(v47 + 24);
            unint64_t v51 = v43[3];
            BOOL v32 = v50 >= v51;
            unsigned int v52 = v50 > v51;
            if (!v32) {
              unsigned int v52 = -1;
            }
          }
LABEL_53:
          BOOL v48 = v52 >> 31;
        }
        else
        {
          BOOL v48 = *(_DWORD *)(*(void *)v47 + 8) >> 8 < *(_DWORD *)(v44 + 8) >> 8;
        }
        uint64_t v53 = v46 + 168;
        v42 += ~v45;
        if (v48) {
          uint64_t v41 = v53;
        }
        else {
          unint64_t v42 = v45;
        }
      }
      while (v42);
    }
    uint64_t v24 = a1 + 168 * v40;
    unint64_t v134 = 0xCF3CF3CF3CF3CF3DLL * ((v41 - a2) >> 3);
LABEL_69:
    uint64_t v57 = v41;
    if (v24 != a2)
    {
      uint64_t v57 = v24;
      if (a2 != v41)
      {
        uint64_t v132 = a3;
        uint64_t v58 = v24 + 168;
        uint64_t v136 = v24 + 168;
        uint64_t v59 = a2;
        while (1)
        {
          int v138 = v140;
          uint64_t v139 = 0x800000000;
          if (*(_DWORD *)(v58 - 160)) {
            sub_1CD727100((uint64_t)&v138, v58 - 168);
          }
          long long v60 = *(_OWORD *)(v58 - 24);
          int v142 = *(_DWORD *)(v58 - 8);
          long long v141 = v60;
          sub_1CD727100(v58 - 168, v59);
          int v61 = *(_DWORD *)(v59 + 160);
          *(_OWORD *)(v58 - 24) = *(_OWORD *)(v59 + 144);
          *(_DWORD *)(v58 - 8) = v61;
          sub_1CD727100(v59, (uint64_t)&v138);
          long long v62 = v141;
          *(_DWORD *)(v59 + 160) = v142;
          *(_OWORD *)(v59 + 144) = v62;
          if (v138 != v140) {
            free(v138);
          }
          v59 += 168;
          if (v59 == v41) {
            break;
          }
          if (v58 == a2) {
            a2 = v59;
          }
          v58 += 168;
          v136 += 168;
        }
        a6 = v131;
        if (v58 != a2)
        {
          uint64_t v63 = a2;
          while (1)
          {
            v58 += 168;
            while (1)
            {
              int v138 = v140;
              uint64_t v139 = 0x800000000;
              if (*(_DWORD *)(v58 - 160)) {
                sub_1CD727100((uint64_t)&v138, v58 - 168);
              }
              long long v64 = *(_OWORD *)(v58 - 24);
              int v142 = *(_DWORD *)(v58 - 8);
              long long v141 = v64;
              sub_1CD727100(v58 - 168, v63);
              int v65 = *(_DWORD *)(v63 + 160);
              *(_OWORD *)(v58 - 24) = *(_OWORD *)(v63 + 144);
              *(_DWORD *)(v58 - 8) = v65;
              sub_1CD727100(v63, (uint64_t)&v138);
              int v66 = v142;
              *(_OWORD *)(v63 + 144) = v141;
              *(_DWORD *)(v63 + 160) = v66;
              if (v138 != v140) {
                free(v138);
              }
              v63 += 168;
              a6 = v131;
              if (v63 != v41) {
                break;
              }
              uint64_t v63 = a2;
              BOOL v67 = v58 == a2;
              v58 += 168;
              if (v67) {
                goto LABEL_94;
              }
            }
            if (v58 == a2) {
              a2 = v63;
            }
          }
        }
LABEL_94:
        a3 = v132;
        a7 = v130;
        uint64_t v57 = v136;
      }
    }
    a4 -= v40;
    uint64_t v7 = v134;
    if ((uint64_t)(v40 + v134) >= (uint64_t)(a4 + v135 - v134))
    {
      uint64_t v137 = a1;
      uint64_t v69 = a6;
      uint64_t v70 = a7;
      sub_1CCD1D7B8(v57, v41, a3, a4, v135 - v134);
      uint64_t v41 = v24;
      a4 = v40;
      a3 = v57;
    }
    else
    {
      uint64_t v68 = a1;
      uint64_t v133 = a3;
      uint64_t v69 = a6;
      uint64_t v70 = a7;
      sub_1CCD1D7B8(v68, v24, v57, v40, v134);
      a3 = v133;
      uint64_t v137 = v57;
      uint64_t v7 = v135 - v134;
    }
    a2 = v41;
    a6 = v69;
    a7 = v70;
    a1 = v137;
  }
  while (v7);
}

uint64_t sub_1CCD1E1CC()
{
  LOBYTE(v1) = 1;
  int v2 = 1;
  unint64_t v3 = &v1;
  v4.n128_u64[0] = (unint64_t)"Enable the use of the block frequency analysis to reduce the chance to execute cons"
                                     "t materialization more frequently than without hoisting.";
  v4.n128_u64[1] = 139;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF09F8, "consthoist-with-block-frequency", (unsigned char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF09F8, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  int v2 = 1;
  unint64_t v3 = &v1;
  v4.n128_u64[0] = (unint64_t)"Try hoisting constant gep expressions";
  v4.n128_u64[1] = 37;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF0AB8, "consthoist-gep", (unsigned char **)&v3, &v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF0AB8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Do not rebase if number of dependent constants of a Base is less than this number.";
  v4.n128_u64[1] = 82;
  int v1 = 1;
  int v2 = 0;
  unint64_t v3 = &v2;
  sub_1CD50BCD4((uint64_t)&unk_1EBCF0B78, "consthoist-min-num-to-rebase", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF0B78, &dword_1CB82C000);
}

void sub_1CCD1E314(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1CCD22EB8(llvm *a1)
{
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeScalarEvolutionWrapperPassPass(a1, v2);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLazyValueInfoWrapperPassPass(a1, v3);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v4);
  operator new();
}

uint64_t sub_1CCD22F74(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0C38;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D6D8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)qword_1EBCF0C40, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD22EB8;
    v5[1] = &PassRegistry;
    __n128 v4 = v5;
    std::__call_once(qword_1EBCF0C40, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCD23024(uint64_t a1, int a2, llvm::Value *a3, llvm::Value *a4, int a5, int a6, uint64_t a7)
{
  uint64_t v12 = a1;
  v81[6] = *MEMORY[0x1E4F143B8];
  uint64_t v79 = (void **)v81;
  uint64_t v80 = 0x600000000;
  sub_1CCD2585C((uint64_t)&v71, a1, a2, a3, a4, (uint64_t)&v79, 1);
  if (v72)
  {
    if (!v75) {
      goto LABEL_16;
    }
    uint64_t v15 = (llvm **)v74;
    unint64_t v16 = (llvm **)((char *)v74 + 24 * v75);
    while (sub_1CCD236D0(v12, *(_DWORD *)v15, v15[1], v15[2]))
    {
      v15 += 3;
      if (v15 == v16) {
        goto LABEL_16;
      }
    }
  }
  LODWORD(v80) = 0;
  sub_1CCD2585C((uint64_t)&v64, v12, a2, a3, a4, (uint64_t)&v79, 0);
  sub_1CD41C56C((uint64_t)&v71, (uint64_t)&v64);
  sub_1CB831C80((uint64_t)&v74, (uint64_t)&v67);
  sub_1CD477A94((uint64_t)v77, (uint64_t)v69);
  __int16 v78 = v70;
  sub_1CD4779B0(v69);
  if (v67 != &v68) {
    free(v67);
  }
  if (v64 != v66) {
    free(v64);
  }
  if (!v72) {
    goto LABEL_47;
  }
  if (!v75)
  {
LABEL_16:
    if ((_BYTE)v78) {
      uint64_t v17 = v12 + 392;
    }
    else {
      uint64_t v17 = v12 + 48;
    }
    if (!v72 || !sub_1CD7613CC(v17, (uint64_t *)v71, v72)) {
      goto LABEL_47;
    }
    int v61 = v63;
    uint64_t v62 = 0x200000000;
    if ((_BYTE)v78) {
      v12 += 24;
    }
    int v18 = v80;
    if (v80)
    {
      uint64_t v19 = v79;
      uint64_t v20 = 8 * v80;
      do
      {
        unint64_t v21 = *v19;
        int v22 = *(_DWORD *)(v12 + 8) + 1;
        uint64_t v58 = *v19;
        LODWORD(v59) = v22;
        sub_1CC6125EC(v12, (uint64_t *)&v58, &v59, (uint64_t)&v64);
        if (v62 >= (unint64_t)HIDWORD(v62)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v61 + v62) = v21;
        int v18 = v62 + 1;
        LODWORD(v62) = v62 + 1;
        ++v19;
        v20 -= 8;
      }
      while (v20);
    }
    unsigned int v24 = *(_DWORD *)(a7 + 8);
    uint64_t v23 = *(unsigned int *)(a7 + 12);
    if (v24 >= v23)
    {
      if (v23 == -1) {
        goto LABEL_87;
      }
      if (((2 * v23) | 1uLL) >= 0xFFFFFFFF) {
        uint64_t v39 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v39 = (2 * v23) | 1;
      }
      uint64_t v40 = (char *)malloc_type_malloc(48 * v39, 0x4065EBACuLL);
      if (!v40) {
        goto LABEL_88;
      }
      uint64_t v41 = (uint64_t)v40;
      unsigned int v42 = *(_DWORD *)(a7 + 8);
      uint64_t v43 = &v40[48 * v42];
      char v44 = v78;
      long long v64 = v66;
      uint64_t v65 = 0x200000000;
      if (v62)
      {
        sub_1CBB08064((uint64_t)&v64, (uint64_t)&v61);
        BOOL v45 = v65 == 0;
      }
      else
      {
        BOOL v45 = 1;
      }
      *(_DWORD *)uint64_t v43 = a5;
      uint64_t v54 = v41 + 48 * v42;
      *(void *)(v54 + 16) = v54 + 32;
      uint64_t v55 = v54 + 16;
      *(_DWORD *)(v55 - 12) = a6;
      *(unsigned char *)(v55 - 8) = v44;
      *(void *)(v55 + 8) = 0x200000000;
      if (!v45) {
        sub_1CBB08064(v55, (uint64_t)&v64);
      }
      if (v64 != v66) {
        free(v64);
      }
      sub_1CCD2AD80((uint64_t *)a7, v41);
      if (*(void *)a7 != a7 + 16) {
        free(*(void **)a7);
      }
      *(void *)a7 = v41;
      ++*(_DWORD *)(a7 + 8);
      *(_DWORD *)(a7 + 12) = v39;
      int v30 = a6;
    }
    else
    {
      uint64_t v25 = *(void *)a7;
      unint64_t v26 = (_DWORD *)(*(void *)a7 + 48 * v24);
      char v27 = v78;
      long long v64 = v66;
      uint64_t v65 = 0x200000000;
      if (v18) {
        sub_1CBB08064((uint64_t)&v64, (uint64_t)&v61);
      }
      _DWORD *v26 = a5;
      uint64_t v28 = v25 + 48 * v24;
      *(void *)(v28 + 16) = v28 + 32;
      uint64_t v29 = v28 + 16;
      int v30 = a6;
      *(_DWORD *)(v29 - 12) = a6;
      *(unsigned char *)(v29 - 8) = v27;
      *(void *)(v29 + 8) = 0x200000000;
      if (v65) {
        sub_1CBB08064(v29, (uint64_t)&v64);
      }
      if (v64 != v66) {
        free(v64);
      }
      ++*(_DWORD *)(a7 + 8);
    }
    if (!HIBYTE(v78))
    {
LABEL_45:
      if (v61 != v63) {
        free(v61);
      }
      goto LABEL_47;
    }
    unint64_t v31 = (uint64_t *)v71;
    uint64_t v32 = v72;
    if (v72)
    {
      uint64_t v33 = 8 * v72;
      uint64_t v34 = v71;
      do
      {
        *uint64_t v34 = -*v34;
        ++v34;
        v33 -= 8;
      }
      while (v33);
    }
    sub_1CD7613CC(v17, v31, v32);
    uint64_t v58 = v60;
    uint64_t v59 = 0x200000000;
    unsigned int v35 = *(_DWORD *)(a7 + 8);
    uint64_t v36 = *(unsigned int *)(a7 + 12);
    if (v35 < v36)
    {
      uint64_t v37 = *(void *)a7 + 48 * v35;
      char v38 = v78;
      *(_DWORD *)uint64_t v37 = a5;
      *(_DWORD *)(v37 + 4) = v30;
      *(unsigned char *)(v37 + 8) = v38;
      *(void *)(v37 + 16) = v37 + 32;
      *(void *)(v37 + 24) = 0x200000000;
      ++*(_DWORD *)(a7 + 8);
LABEL_43:
      if (v58 != v60) {
        free(v58);
      }
      goto LABEL_45;
    }
    if (v36 != -1)
    {
      if (((2 * v36) | 1uLL) >= 0xFFFFFFFF) {
        uint64_t v46 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v46 = (2 * v36) | 1;
      }
      uint64_t v47 = (char *)malloc_type_malloc(48 * v46, 0x4065EBACuLL);
      if (v47)
      {
        uint64_t v48 = (uint64_t)v47;
        unsigned int v49 = *(_DWORD *)(a7 + 8);
        unint64_t v50 = &v47[48 * v49];
        char v56 = v78;
        long long v64 = v66;
        uint64_t v65 = 0x200000000;
        int v51 = v59;
        if (v59)
        {
          if (v58 == v60)
          {
            if (v59 >= 3) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v66, v60, 8 * v59);
            LODWORD(v65) = v51;
          }
          else
          {
            long long v64 = v58;
            uint64_t v65 = v59;
            uint64_t v58 = v60;
            HIDWORD(v59) = 0;
          }
          LODWORD(v59) = 0;
        }
        *(_DWORD *)unint64_t v50 = a5;
        uint64_t v52 = v48 + 48 * v49;
        *(void *)(v52 + 16) = v52 + 32;
        uint64_t v53 = v52 + 16;
        *(_DWORD *)(v53 - 12) = a6;
        *(unsigned char *)(v53 - 8) = v56;
        *(void *)(v53 + 8) = 0x200000000;
        if (v51) {
          sub_1CBB08064(v53, (uint64_t)&v64);
        }
        if (v64 != v66) {
          free(v64);
        }
        sub_1CCD2AD80((uint64_t *)a7, v48);
        if (*(void *)a7 != a7 + 16) {
          free(*(void **)a7);
        }
        *(void *)a7 = v48;
        ++*(_DWORD *)(a7 + 8);
        *(_DWORD *)(a7 + 12) = v46;
        goto LABEL_43;
      }
LABEL_88:
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
LABEL_87:
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  long long v13 = (llvm **)v74;
  uint64_t v14 = (llvm **)((char *)v74 + 24 * v75);
  while (sub_1CCD236D0(v12, *(_DWORD *)v13, v13[1], v13[2]))
  {
    v13 += 3;
    if (v13 == v14) {
      goto LABEL_16;
    }
  }
LABEL_47:
  sub_1CD4779B0(v77);
  if (v74 != &v76) {
    free(v74);
  }
  if (v71 != &v73) {
    free(v71);
  }
  if (v79 != v81) {
    free(v79);
  }
}

BOOL sub_1CCD236D0(uint64_t a1, int a2, llvm *a3, llvm *a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  sub_1CCD2559C((uint64_t)&v19, a1, a2, a3, a4, 1);
  if (!v23)
  {
    if (!v20)
    {
      BOOL isConditionImplied = 0;
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  sub_1CCD2559C((uint64_t)v13, a1, a2, a3, a4, 0);
  sub_1CD41C56C((uint64_t)&v19, (uint64_t)v13);
  sub_1CB831C80((uint64_t)&v22, (uint64_t)&v15);
  sub_1CD477A94((uint64_t)v25, (uint64_t)v17);
  __int16 v26 = v18;
  sub_1CD4779B0(v17);
  if (v15 != &v16) {
    free(v15);
  }
  if (v13[0] != &v14) {
    free(v13[0]);
  }
  BOOL isConditionImplied = 0;
  if (!v23 && v20)
  {
LABEL_10:
    if ((_BYTE)v26) {
      uint64_t v9 = a1 + 392;
    }
    else {
      uint64_t v9 = a1 + 48;
    }
    v11[0] = v12;
    v11[1] = (void *)0x800000000;
    llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)v11, (uint64_t)&v19);
    BOOL isConditionImplied = llvm::ConstraintSystem::isConditionImplied(v9, (uint64_t)v11);
    if (v11[0] != v12) {
      free(v11[0]);
    }
  }
LABEL_15:
  sub_1CD4779B0(v25);
  if (v22 != &v24) {
    free(v22);
  }
  if (v19 != &v21) {
    free(v19);
  }
  return isConditionImplied;
}

void *sub_1CCD238A8(uint64_t *a1, int a2)
{
  unsigned int v3 = *((_DWORD *)a1 + 4);
  __n128 v4 = (uint64_t *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  uint64_t result = operator new(40 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v10 = *((unsigned int *)a1 + 4);
    if (v10)
    {
      uint64_t v11 = 40 * v10;
      do
      {
        void *result = -4096;
        result += 5;
        v11 -= 40;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = v4;
      do
      {
        uint64_t v13 = *v12;
        if ((*v12 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v14 = *((_DWORD *)a1 + 4) - 1;
          unsigned int v15 = v14 & ((v13 >> 4) ^ (v13 >> 9));
          uint64_t v16 = *a1 + 40 * v15;
          uint64_t v17 = *(void *)v16;
          if (v13 != *(void *)v16)
          {
            uint64_t v18 = 0;
            int v19 = 1;
            while (v17 != -4096)
            {
              if (v18) {
                BOOL v20 = 0;
              }
              else {
                BOOL v20 = v17 == -8192;
              }
              if (v20) {
                uint64_t v18 = v16;
              }
              unsigned int v21 = v15 + v19++;
              unsigned int v15 = v21 & v14;
              uint64_t v16 = *a1 + 40 * (v21 & v14);
              uint64_t v17 = *(void *)v16;
              if (v13 == *(void *)v16) {
                goto LABEL_12;
              }
            }
            if (v18) {
              uint64_t v16 = v18;
            }
          }
LABEL_12:
          *(void *)uint64_t v16 = v13;
          *(_OWORD *)(v16 + 8) = *(_OWORD *)(v12 + 1);
          *(_DWORD *)(v16 + 32) = *((_DWORD *)v12 + 8);
          *(void *)(v16 + 24) = v12[3];
          *((_DWORD *)v12 + 8) = 0;
          ++*((_DWORD *)a1 + 2);
        }
        v12 += 5;
      }
      while (v12 != &v4[5 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v22 = *((unsigned int *)a1 + 4);
  if (v22)
  {
    uint64_t v23 = 40 * v22;
    do
    {
      void *result = -4096;
      result += 5;
      v23 -= 40;
    }
    while (v23);
  }
  return result;
}

uint64_t sub_1CCD23A64(uint64_t a1, llvm::IntegerType ***a2, uint64_t a3)
{
  uint64_t v6 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  uint64_t v7 = *(void *)(a1 + 24);
  unsigned int v8 = *((_DWORD *)*a2 + 2);
  if ((v8 & 0xFE) == 0x12) {
    unsigned int v8 = *(_DWORD *)(*(void *)(*a2)[2] + 8);
  }
  uint64_t v9 = (const char **)&a2[-4 * v6];
  if (v8 < 0x100) {
    goto LABEL_12;
  }
  unsigned int v10 = v8 >> 8;
  uint64_t v11 = *(unsigned int *)(v7 + 240);
  uint64_t v12 = *(void *)(v7 + 232);
  if (v11)
  {
    uint64_t v12 = *(void *)(v7 + 232);
    unint64_t v13 = *(unsigned int *)(v7 + 240);
    do
    {
      unint64_t v14 = v13 >> 1;
      uint64_t v15 = v12 + 16 * (v13 >> 1);
      unsigned int v16 = *(_DWORD *)(v15 + 8);
      uint64_t v17 = v15 + 16;
      v13 += ~(v13 >> 1);
      if (v16 < v10) {
        uint64_t v12 = v17;
      }
      else {
        unint64_t v13 = v14;
      }
    }
    while (v13);
  }
  if (v12 == *(void *)(v7 + 232) + 16 * v11 || *(_DWORD *)(v12 + 8) != v10) {
LABEL_12:
  }
    uint64_t v12 = *(void *)(v7 + 232);
  uint64_t v18 = *v9;
  int v19 = (llvm::LLVMContext *)*(unsigned int *)(v12 + 12);
  unsigned int v74 = v19;
  if (v19 > 0x40) {
    operator new[]();
  }
  __src = 0;
  v68[0] = 0;
  v68[1] = 0;
  int v69 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v70 = 0;
  if (llvm::GEPOperator::collectOffset((uint64_t)a2, (llvm::DataLayout *)v7, v19, (uint64_t)v68, (unsigned int *)&__src))
  {
    uint64_t v20 = v74;
    if (v74 > 0x40) {
      operator new[]();
    }
    unsigned int v21 = __src;
    v63[0] = 0;
    v63[1] = 0;
    int v64 = 0;
    sub_1CBFCBCC4((uint64_t)v63, (uint64_t)v68);
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    sub_1CCD24644(&v65, v70, v71, 0xAAAAAAAAAAAAAAABLL * ((v71 - v70) >> 3));
    int v22 = 0;
    if (v65 != v66)
    {
      if (v20 > 0x40)
      {
        int v24 = 0;
        int64_t v25 = (unint64_t)(v20 + 63) >> 6;
        do
        {
          if (v25-- < 1) {
            break;
          }
          unint64_t v27 = v21[v25];
          v24 += __clz(v27);
        }
        while (!v27);
        int v28 = v20 | 0xFFFFFFC0;
        if ((v20 & 0x3F) == 0) {
          int v28 = 0;
        }
        BOOL v23 = v24 + v28 == v20;
      }
      else
      {
        BOOL v23 = v21 == 0;
      }
      if (v23) {
        int v22 = 1;
      }
      else {
        int v22 = 2;
      }
    }
    sub_1CD76127C((uint64_t)v63);
    if (v20 >= 0x41 && v21) {
      MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
    }
    if (v22 != 2)
    {
      if (v22 == 1)
      {
        unsigned int v33 = *(_DWORD *)(v70 + 16);
        if (v33 > 0x40) {
          unint64_t v34 = **(void **)(v70 + 8);
        }
        else {
          unint64_t v34 = (uint64_t)(*(void *)(v70 + 8) << -(char)v33) >> -(char)v33;
        }
        unsigned int v35 = llvm::ConstantInt::get(**(llvm::ConstantInt ***)v70, v34, 0);
        Splat = *(llvm::ConstantInt ***)v70;
      }
      else
      {
        uint64_t v30 = llvm::IntegerType::get(**a2, v19);
        Splat = (llvm::ConstantInt **)llvm::ConstantInt::get(*(llvm::ConstantInt **)v30, (llvm::LLVMContext *)&__src, v31);
        if ((*(_DWORD *)(v30 + 8) & 0xFE) == 0x12) {
          Splat = (llvm::ConstantInt **)llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v30 + 32) | ((unint64_t)(*(_DWORD *)(v30 + 8) == 19) << 32)), (uint64_t)Splat);
        }
        unsigned int v35 = 0;
      }
      uint64_t v36 = 0;
      if ((llvm::isKnownNonNegative((llvm *)Splat, *(const llvm::Value **)(a1 + 24), (const llvm::DataLayout *)2, 0, 0, 0, (const llvm::DominatorTree *)1) & 1) == 0)
      {
        uint64_t v37 = operator new(0x80uLL);
        uint64_t v36 = (llvm::Value *)(v37 + 16);
        v37[21] = v37[21] & 0x38000000 | 2;
        *(void *)uint64_t v37 = 0;
        *((void *)v37 + 1) = 0;
        *((void *)v37 + 2) = 0;
        *((void *)v37 + 3) = v37 + 16;
        *((void *)v37 + 4) = 0;
        *((void *)v37 + 5) = 0;
        *((void *)v37 + 6) = 0;
        *((void *)v37 + 7) = v37 + 16;
        char v38 = llvm::ConstantInt::get(*Splat, 0, 0);
        __int16 v82 = 257;
        uint64_t v39 = *Splat;
        uint64_t v40 = **(void **)*Splat + 1888;
        if (*Splat && (*((_DWORD *)v39 + 2) & 0xFE) == 0x12)
        {
          uint64_t v57 = (uint64_t **)(**(void **)*Splat + 1888);
          uint64_t v58 = (llvm::Type *)*((unsigned int *)v39 + 8);
          if (*((_DWORD *)v39 + 2) == 19) {
            llvm::ScalableVectorType::get(v57, v58);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v57, v58);
          }
          uint64_t v40 = v59;
        }
        llvm::CmpInst::CmpInst(v36, v40, 53, 39, (uint64_t)Splat, (uint64_t)v38, &v77, 0, 0);
        unsigned int v41 = *(_DWORD *)(a1 + 40);
        if (v41 >= *(_DWORD *)(a1 + 44)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 32) + 8 * v41) = v36;
        ++*(_DWORD *)(a1 + 40);
      }
      if (v35)
      {
        __int16 v82 = 257;
        Splat = (llvm::ConstantInt **)llvm::BinaryOperator::Create(17, Splat, (uint64_t)v35, &v77, 0);
        *((unsigned char *)Splat + 17) |= 2u;
        unsigned int v42 = *(_DWORD *)(a1 + 40);
        if (v42 >= *(_DWORD *)(a1 + 44)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 32) + 8 * v42) = Splat;
        ++*(_DWORD *)(a1 + 40);
      }
      long long v77 = v18;
      uint64_t v78 = 0;
      sub_1CC27B388(a1 + 2144, &v77, &v78, (uint64_t)&v75);
      if (v76)
      {
        uint64_t v43 = operator new(0x60uLL);
        char v44 = (llvm::Value *)(v43 + 8);
        v43[13] = v43[13] & 0x38000000 | 1;
        *(void *)uint64_t v43 = 0;
        *((void *)v43 + 1) = 0;
        *((void *)v43 + 2) = 0;
        *((void *)v43 + 3) = v43 + 8;
        BOOL v45 = *Splat;
        uint64_t v46 = (llvm::UndefValue *)llvm::PointerType::get(*Splat, 0);
        uint64_t v48 = llvm::UndefValue::get(v46, v47);
        long long v77 = "ub";
        __int16 v82 = 259;
        llvm::LoadInst::LoadInst(v44, (uint64_t)v45, (uint64_t)v48, &v77, 0, 0, 0);
        *(void *)(v75 + 8) = v44;
        unsigned int v49 = *(_DWORD *)(a1 + 40);
        if (v49 >= *(_DWORD *)(a1 + 44)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 32) + 8 * v49) = v44;
        ++*(_DWORD *)(a1 + 40);
      }
      if (**(llvm::ConstantInt ***)(v75 + 8) == *Splat)
      {
        unint64_t v50 = operator new(0x80uLL);
        int v51 = (llvm::Value *)(v50 + 16);
        v50[21] = v50[21] & 0x38000000 | 2;
        *(void *)unint64_t v50 = 0;
        *((void *)v50 + 1) = 0;
        *((void *)v50 + 2) = 0;
        *((void *)v50 + 3) = v50 + 16;
        *((void *)v50 + 4) = 0;
        *((void *)v50 + 5) = 0;
        *((void *)v50 + 6) = 0;
        *((void *)v50 + 7) = v50 + 16;
        uint64_t v52 = *(void **)(v75 + 8);
        __int16 v82 = 257;
        uint64_t v53 = (void **)*v52;
        uint64_t v54 = **(void **)*v52 + 1888;
        if (*v52 && (v53[1] & 0xFE) == 0x12)
        {
          long long v60 = (uint64_t **)(**(void **)*v52 + 1888);
          int v61 = (llvm::Type *)*((unsigned int *)v53 + 8);
          if (*((_DWORD *)v53 + 2) == 19) {
            llvm::ScalableVectorType::get(v60, v61);
          }
          else {
            llvm::FixedVectorType::get((llvm::FixedVectorType *)v60, v61);
          }
          uint64_t v54 = v62;
        }
        llvm::CmpInst::CmpInst(v51, v54, 53, 35, (uint64_t)v52, (uint64_t)Splat, &v77, 0, 0);
        long long v77 = (const char *)(v50 + 16);
        uint64_t v78 = *(void *)(a3 + 72);
        __int16 v79 = 0;
        uint64_t v81 = v36;
        BOOL v80 = *((unsigned __int8 *)v50 + 80) - 81 < 2;
        sub_1CB8BBE7C((unint64_t *)(a1 + 80), (unint64_t)&v77);
        unsigned int v55 = *(_DWORD *)(a1 + 40);
        if (v55 >= *(_DWORD *)(a1 + 44)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 32) + 8 * v55) = v51;
        ++*(_DWORD *)(a1 + 40);
      }
    }
  }
  uint64_t result = sub_1CD76127C((uint64_t)v68);
  if (v74 >= 0x41)
  {
    uint64_t result = (uint64_t)__src;
    if (__src) {
      return MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t sub_1CCD241A0(uint64_t a1, llvm::Loop *a2, llvm::ScalarEvolution *this)
{
  uint64_t v3 = a1;
  if (a1)
  {
    if (*(_WORD *)(a1 + 24) == 4) {
      llvm::ScalarEvolution::applyLoopGuards(this, *(const llvm::SCEV **)(*(void *)(a1 + 32) + 8), a2);
    }
  }
  int v4 = *(unsigned __int16 *)(a1 + 24);
  if (v4 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = *(unsigned __int16 *)(v3 + 24);
    if (*(_WORD *)(v3 + 24)) {
      goto LABEL_6;
    }
LABEL_9:
    uint64_t v5 = v3 + 32;
    return *(void *)v5;
  }
  if (!*(_WORD *)(a1 + 24)) {
    goto LABEL_9;
  }
LABEL_6:
  if (v4 == 14)
  {
    uint64_t v5 = v3 - 8;
    return *(void *)v5;
  }
  return 0;
}

uint64_t sub_1CCD24290(int a1, llvm::BasicBlock **this, uint64_t a3)
{
  if (llvm::BasicBlock::getSingleSuccessor((llvm::BasicBlock *)this))
  {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  uint64_t v5 = this[5];
  if (v5 == (llvm::BasicBlock *)(this + 5)) {
    return 0;
  }
  if (v5) {
    uint64_t v6 = (char *)v5 - 24;
  }
  else {
    uint64_t v6 = 0;
  }
  int v7 = v6[16];
  if (v7 == 30)
  {
    if ((*((_DWORD *)v6 + 5) & 0x7FFFFFF) == 3) {
      int v26 = 2;
    }
    else {
      int v26 = 1;
    }
  }
  else
  {
    int v26 = 2;
    uint64_t result = 0;
    switch(v6[16])
    {
      case 29:
      case 34:
      case 35:
        return result;
      case 30:
LABEL_66:
        __break(1u);
        goto LABEL_67;
      case 31:
        int v26 = (*((_DWORD *)v6 + 5) >> 1) & 0x3FFFFFF;
        break;
      case 32:
      case 38:
LABEL_67:
        int v26 = (*((_DWORD *)v6 + 5) & 0x7FFFFFF) - 1;
        break;
      case 33:
        goto LABEL_14;
      case 36:
        int v26 = *((_WORD *)v6 + 9) & 1;
        break;
      case 37:
        int v26 = 1;
        goto LABEL_14;
      case 39:
        int v26 = *((_DWORD *)v6 + 20) + 1;
        break;
      default:
        return 0;
    }
    if (!v26) {
      return 0;
    }
  }
LABEL_14:
  uint64_t v8 = 0;
  for (uint64_t i = v6 - 32; ; i -= 32)
  {
    unsigned int v10 = i;
    if (v7 != 30)
    {
      unsigned int v10 = v6 - 32;
      switch(v7)
      {
        case ' ':
        case '&':
          int v15 = *((_DWORD *)v6 + 5);
          if ((v15 & 0x40000000) != 0) {
            unsigned int v16 = (char *)*((void *)v6 - 1);
          }
          else {
            unsigned int v16 = &v6[-32 * (v15 & 0x7FFFFFF)];
          }
          unint64_t v14 = &v16[32 * v8];
          goto LABEL_25;
        case '!':
          if (v8) {
            uint64_t v17 = -64;
          }
          else {
            uint64_t v17 = -96;
          }
          unsigned int v10 = &v6[v17];
          break;
        case '""':
        case '#':
          goto LABEL_66;
        case '$':
          if ((*((_WORD *)v6 + 9) & 1) == 0)
          {
            uint64_t v11 = 0;
            goto LABEL_18;
          }
          unsigned int v10 = &v6[-32 * (*((_DWORD *)v6 + 5) & 0x7FFFFFF) + 32];
          break;
        case '%':
          break;
        case '\'':
          if (v8) {
            unsigned int v10 = &v6[32 * (v8 - 1) - 32 + -32 * *((unsigned int *)v6 + 20)];
          }
          else {
            unsigned int v10 = &v6[-32 * *((unsigned int *)v6 + 20) - 64];
          }
          break;
        default:
          int v12 = *((_DWORD *)v6 + 5);
          if ((v12 & 0x40000000) != 0) {
            unint64_t v13 = (char *)*((void *)v6 - 1);
          }
          else {
            unint64_t v13 = &v6[-32 * (v12 & 0x7FFFFFF)];
          }
          unint64_t v14 = &v13[64 * v8];
LABEL_25:
          unsigned int v10 = v14 + 32;
          break;
      }
    }
    uint64_t v11 = *(void *)v10;
LABEL_18:
    if (v11 != a3) {
      break;
    }
    if (v26 == ++v8) {
      return 0;
    }
  }
  uint64_t v18 = *(void *)(a3 + 8);
  if (v18)
  {
    while (1)
    {
      uint64_t v19 = *(void *)(v18 + 24);
      unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
      BOOL v21 = v19 && v20 >= 0x1C;
      if (v21 && v20 - 29 <= 0xA) {
        break;
      }
      uint64_t v18 = *(void *)(v18 + 8);
      if (!v18) {
        return 1;
      }
    }
LABEL_60:
    if (*(llvm::BasicBlock ***)(v19 + 40) != this) {
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
    }
    while (1)
    {
      uint64_t v18 = *(void *)(v18 + 8);
      if (!v18) {
        break;
      }
      uint64_t v19 = *(void *)(v18 + 24);
      unsigned int v23 = *(unsigned __int8 *)(v19 + 16);
      if (v19) {
        BOOL v24 = v23 >= 0x1C;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24 && v23 - 29 < 0xB) {
        goto LABEL_60;
      }
    }
  }
  return 1;
}

llvm::Value *sub_1CCD24580(llvm::Value *result, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  if (v3 >= 0x1C && v3 - 83 >= 0xFFFFFFFE)
  {
    uint64_t v5 = (uint64_t)result;
    uint64_t result = *(llvm::Value **)(a2 - 64);
    if (result)
    {
      uint64_t v6 = *(llvm::Value **)(a2 - 32);
      if (v6)
      {
        if ((*(_WORD *)(a2 + 18) & 0x3F) == 0x23)
        {
          uint64_t v8 = llvm::Value::stripPointerCastsSameRepresentation(result);
          uint64_t result = llvm::Value::stripPointerCastsSameRepresentation(v6);
          BOOL v9 = *((unsigned char *)v8 + 16) != 62 || v8 == 0;
          if (!v9 && *((llvm::Value **)v8 - 4 * (*((_DWORD *)v8 + 5) & 0x7FFFFFF)) == result)
          {
            return (llvm::Value *)sub_1CCD23A64(v5, (llvm::IntegerType ***)v8, a3);
          }
        }
      }
    }
  }
  return result;
}

void *sub_1CCD24644(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v6 = result;
    uint64_t v7 = 3 * a4;
    uint64_t result = operator new(24 * a4);
    uint64_t v8 = result;
    *uint64_t v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    if (a2 != a3)
    {
      uint64_t v9 = a2 + 8;
      do
      {
        uint64_t v10 = v9 - 8;
        void *v8 = *(void *)(v9 - 8);
        unsigned int v11 = *(_DWORD *)(v9 + 8);
        *((_DWORD *)v8 + 4) = v11;
        if (v11 > 0x40) {
          operator new[]();
        }
        v8[1] = *(void *)v9;
        v8 += 3;
        v9 += 24;
      }
      while (v10 + 24 != a3);
    }
    v6[1] = v8;
  }
  return result;
}

void sub_1CCD2473C(void ***a1)
{
  int v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((_DWORD *)v4 - 2) >= 0x41u)
        {
          uint64_t v6 = *((void *)v4 - 2);
          if (v6) {
            MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
          }
        }
        v4 -= 24;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCD247E0(uint64_t *a1, uint64_t *a2, unint64_t a3, uint64_t *a4, uint64_t a5, __n128 a6)
{
  if (a3 < 2) {
    return;
  }
  uint64_t v7 = a1;
  if (a3 == 2)
  {
    uint64_t v8 = a2 - 4;
    if (sub_1CCD24BCC(a2 - 4, a1))
    {
      long long v10 = *(_OWORD *)v7;
      long long v9 = *((_OWORD *)v7 + 1);
      long long v11 = *((_OWORD *)v8 + 1);
      *(_OWORD *)uint64_t v7 = *(_OWORD *)v8;
      *((_OWORD *)v7 + 1) = v11;
      *(_OWORD *)uint64_t v8 = v10;
      *((_OWORD *)v8 + 1) = v9;
    }
    return;
  }
  if ((uint64_t)a3 <= 128)
  {
    if (a1 == a2) {
      return;
    }
    unint64_t v13 = a1 + 4;
    if (a1 + 4 == a2) {
      return;
    }
    unint64_t v14 = a1;
    while (1)
    {
      int v15 = v13;
      if (!sub_1CCD24BCC(v13, v14)) {
        goto LABEL_48;
      }
      uint64_t v16 = v14[4];
      uint64_t v17 = v14[5];
      int v18 = *((unsigned __int8 *)v14 + 48);
      char v19 = *((unsigned char *)v14 + 49);
      int v20 = *((unsigned __int8 *)v14 + 50);
      *(void *)char v56 = *(uint64_t *)((char *)v14 + 51);
      *(void *)&v56[5] = v14[7];
      long long v21 = *((_OWORD *)v14 + 1);
      int v22 = v7;
      *(_OWORD *)int v15 = *(_OWORD *)v14;
      *((_OWORD *)v15 + 1) = v21;
      if (v14 == v7) {
        goto LABEL_47;
      }
      do
      {
        int v22 = v14;
        v14 -= 4;
        unsigned int v23 = *((_DWORD *)v22 - 6);
        BOOL v24 = v17 >= v23;
        if (v17 != v23) {
          goto LABEL_26;
        }
        if (v18 || !*((unsigned char *)v22 - 16))
        {
          if (v18 && !*((unsigned char *)v22 - 16)) {
            goto LABEL_47;
          }
          if (!v20 || *((unsigned char *)v22 - 14))
          {
            if (!v20 && *((unsigned char *)v22 - 14)) {
              goto LABEL_47;
            }
            if (!v20 || !*((unsigned char *)v22 - 14))
            {
              uint64_t v27 = *v14;
              uint64_t v28 = *(void *)(v16 + 40);
              int v29 = *(__int16 *)(v28 + 18);
              if ((v29 & 0x80000000) == 0)
              {
                uint64_t v36 = *(void *)(v28 + 48);
                if (v36 != v28 + 40)
                {
                  int v37 = 0;
                  do
                  {
                    uint64_t v38 = v36 - 24;
                    if (!v36) {
                      uint64_t v38 = 0;
                    }
                    *(_DWORD *)(v38 + 56) = v37++;
                    uint64_t v36 = *(void *)(v36 + 8);
                  }
                  while (v36 != v28 + 40);
                }
                *(_WORD *)(v28 + 18) = v29 | 0x8000;
              }
              BOOL v24 = *(_DWORD *)(v16 + 56) >= *(_DWORD *)(v27 + 56);
LABEL_26:
              if (v24) {
                goto LABEL_47;
              }
              goto LABEL_27;
            }
            int v25 = *(_DWORD *)(v16 + 20);
            if ((v25 & 0x40000000) != 0) {
              int v26 = *(void **)(v16 - 8);
            }
            else {
              int v26 = (void *)(v16 - 32 * (v25 & 0x7FFFFFF));
            }
            BOOL v31 = *(unsigned char *)(*v26 + 16) == 16 || *(unsigned char *)(v26[4] + 16) == 16;
            uint64_t v32 = *v14;
            int v33 = *(_DWORD *)(*v14 + 20);
            if ((v33 & 0x40000000) != 0) {
              unint64_t v34 = *(void **)(v32 - 8);
            }
            else {
              unint64_t v34 = (void *)(v32 - 32 * (v33 & 0x7FFFFFF));
            }
            if (*(unsigned char *)(*v34 + 16) == 16) {
              goto LABEL_47;
            }
            char v35 = !v31;
            if (*(unsigned char *)(v34[4] + 16) == 16) {
              char v35 = 1;
            }
            if (v35) {
              goto LABEL_47;
            }
          }
        }
LABEL_27:
        long long v30 = *((_OWORD *)v14 + 1);
        *(_OWORD *)int v22 = *(_OWORD *)v14;
        *((_OWORD *)v22 + 1) = v30;
      }
      while (v14 != v7);
      int v22 = v7;
LABEL_47:
      uint64_t *v22 = v16;
      v22[1] = v17;
      *((unsigned char *)v22 + 16) = v18;
      *((unsigned char *)v22 + 17) = v19;
      *((unsigned char *)v22 + 18) = v20;
      *(uint64_t *)((char *)v22 + 19) = *(void *)v56;
      v22[3] = *(void *)&v56[5];
LABEL_48:
      unint64_t v13 = v15 + 4;
      unint64_t v14 = v15;
      if (v15 + 4 == a2) {
        return;
      }
    }
  }
  uint64_t v40 = (long long *)a4;
  unint64_t v41 = a3 >> 1;
  uint64_t v42 = (uint64_t)&a1[4 * (a3 >> 1)];
  unint64_t v43 = a3 >> 1;
  if ((uint64_t)a3 > a5)
  {
    sub_1CCD247E0(a1, v42, v43, a4, a5);
    sub_1CCD247E0(&v7[4 * (a3 >> 1)], a2, a3 - (a3 >> 1), v40, a5);
    sub_1CCD24F28((uint64_t)v7, &v7[4 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v40, a5);
    return;
  }
  __n128 v44 = sub_1CCD24D20((uint64_t)a1, v42, v43, a4, a6);
  BOOL v45 = (uint64_t *)&v40[2 * v41];
  sub_1CCD24D20((uint64_t)&v7[4 * (a3 >> 1)], (uint64_t)a2, a3 - (a3 >> 1), v45, v44);
  uint64_t v46 = &v40[2 * a3];
  uint64_t v47 = (long long *)v45;
  while (v47 != v46)
  {
    if (sub_1CCD24BCC((uint64_t *)v47, (uint64_t *)v40))
    {
      long long v48 = *v47;
      long long v49 = v47[1];
      v47 += 2;
    }
    else
    {
      long long v48 = *v40;
      long long v49 = v40[1];
      v40 += 2;
    }
    *(_OWORD *)uint64_t v7 = v48;
    *((_OWORD *)v7 + 1) = v49;
    v7 += 4;
    if (v40 == (long long *)v45)
    {
      if (v47 != v46)
      {
        unint64_t v50 = 0;
        do
        {
          int v51 = &v7[v50 / 8];
          long long v52 = v47[v50 / 0x10 + 1];
          *(_OWORD *)int v51 = v47[v50 / 0x10];
          *((_OWORD *)v51 + 1) = v52;
          v50 += 32;
        }
        while (&v47[v50 / 0x10] != v46);
      }
      return;
    }
  }
  if (v40 != (long long *)v45)
  {
    unint64_t v53 = 0;
    do
    {
      uint64_t v54 = &v7[v53 / 8];
      long long v55 = v40[v53 / 0x10 + 1];
      *(_OWORD *)uint64_t v54 = v40[v53 / 0x10];
      *((_OWORD *)v54 + 1) = v55;
      v53 += 32;
    }
    while (&v40[v53 / 0x10] != (long long *)v45);
  }
}

uint64_t sub_1CCD24BCC(uint64_t *a1, uint64_t *a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  unsigned int v3 = *((_DWORD *)a2 + 2);
  BOOL v4 = v2 >= v3;
  if (v2 != v3) {
    return !v4;
  }
  int v5 = *((unsigned __int8 *)a2 + 16);
  if (*((unsigned char *)a1 + 16)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v5 == 0;
  }
  if (!v6) {
    return 1;
  }
  if (*((unsigned char *)a1 + 16)) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    return 0;
  }
  if (*((unsigned char *)a1 + 18) && !*((unsigned char *)a2 + 18)) {
    return 1;
  }
  if (!*((unsigned char *)a1 + 18) && *((unsigned char *)a2 + 18)) {
    return 0;
  }
  uint64_t v9 = *a1;
  if (!*((unsigned char *)a1 + 18) || !*((unsigned char *)a2 + 18))
  {
    uint64_t v12 = *a2;
    uint64_t v13 = *(void *)(v9 + 40);
    int v14 = *(__int16 *)(v13 + 18);
    if ((v14 & 0x80000000) == 0)
    {
      uint64_t v20 = *(void *)(v13 + 48);
      if (v20 != v13 + 40)
      {
        int v21 = 0;
        do
        {
          uint64_t v22 = v20 - 24;
          if (!v20) {
            uint64_t v22 = 0;
          }
          *(_DWORD *)(v22 + 56) = v21++;
          uint64_t v20 = *(void *)(v20 + 8);
        }
        while (v20 != v13 + 40);
      }
      *(_WORD *)(v13 + 18) = v14 | 0x8000;
    }
    BOOL v4 = *(_DWORD *)(v9 + 56) >= *(_DWORD *)(v12 + 56);
    return !v4;
  }
  int v10 = *(_DWORD *)(v9 + 20);
  if ((v10 & 0x40000000) != 0) {
    long long v11 = *(void **)(v9 - 8);
  }
  else {
    long long v11 = (void *)(v9 - 32 * (v10 & 0x7FFFFFF));
  }
  BOOL v15 = *(unsigned char *)(*v11 + 16) == 16 || *(unsigned __int8 *)(v11[4] + 16) == 16;
  uint64_t v16 = *a2;
  int v17 = *(_DWORD *)(*a2 + 20);
  if ((v17 & 0x40000000) != 0) {
    int v18 = *(void **)(v16 - 8);
  }
  else {
    int v18 = (void *)(v16 - 32 * (v17 & 0x7FFFFFF));
  }
  BOOL v19 = *(unsigned char *)(*v18 + 16) != 16 && *(unsigned __int8 *)(v18[4] + 16) != 16;
  return v15 & v19;
}

__n128 sub_1CCD24D20(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, __n128 result)
{
  if (a3)
  {
    int v5 = a4;
    uint64_t v8 = a1;
    if (a3 == 2)
    {
      int v10 = (_OWORD *)(a2 - 32);
      if (sub_1CCD24BCC((uint64_t *)(a2 - 32), (uint64_t *)a1))
      {
        long long v11 = v10[1];
        *(_OWORD *)int v5 = *v10;
        *((_OWORD *)v5 + 1) = v11;
        uint64_t result = *(__n128 *)v8;
        long long v12 = *(_OWORD *)(v8 + 16);
      }
      else
      {
        long long v23 = *(_OWORD *)(v8 + 16);
        *(_OWORD *)int v5 = *(_OWORD *)v8;
        *((_OWORD *)v5 + 1) = v23;
        uint64_t result = *(__n128 *)v10;
        long long v12 = v10[1];
      }
      *((__n128 *)v5 + 2) = result;
      *((_OWORD *)v5 + 3) = v12;
    }
    else if (a3 == 1)
    {
      uint64_t result = *(__n128 *)a1;
      long long v9 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)a4 = *(_OWORD *)a1;
      *((_OWORD *)a4 + 1) = v9;
    }
    else if ((uint64_t)a3 > 8)
    {
      uint64_t v24 = a1 + 32 * (a3 >> 1);
      sub_1CCD247E0(a1, v24, a3 >> 1, a4, a3 >> 1);
      sub_1CCD247E0(v8 + 32 * (a3 >> 1), a2, a3 - (a3 >> 1), &v5[4 * (a3 >> 1)], a3 - (a3 >> 1));
      uint64_t v25 = v8 + 32 * (a3 >> 1);
      while (v25 != a2)
      {
        if (sub_1CCD24BCC((uint64_t *)v25, (uint64_t *)v8))
        {
          uint64_t result = *(__n128 *)v25;
          long long v26 = *(_OWORD *)(v25 + 16);
          v25 += 32;
        }
        else
        {
          uint64_t result = *(__n128 *)v8;
          long long v26 = *(_OWORD *)(v8 + 16);
          v8 += 32;
        }
        *(__n128 *)int v5 = result;
        *((_OWORD *)v5 + 1) = v26;
        v5 += 4;
        if (v8 == v24)
        {
          if (v25 != a2)
          {
            unint64_t v27 = 0;
            do
            {
              uint64_t v28 = &v5[v27 / 8];
              uint64_t result = *(__n128 *)(v25 + v27);
              long long v29 = *(_OWORD *)(v25 + v27 + 16);
              *(__n128 *)uint64_t v28 = result;
              *((_OWORD *)v28 + 1) = v29;
              v27 += 32;
            }
            while (v25 + v27 != a2);
          }
          return result;
        }
      }
      if (v8 != v24)
      {
        unint64_t v30 = 0;
        do
        {
          BOOL v31 = &v5[v30 / 8];
          uint64_t result = *(__n128 *)(v8 + v30);
          long long v32 = *(_OWORD *)(v8 + v30 + 16);
          *(__n128 *)BOOL v31 = result;
          *((_OWORD *)v31 + 1) = v32;
          v30 += 32;
        }
        while (v8 + v30 != v24);
      }
    }
    else if (a1 != a2)
    {
      uint64_t result = *(__n128 *)a1;
      long long v14 = *(_OWORD *)(a1 + 16);
      uint64_t v13 = a1 + 32;
      *(_OWORD *)a4 = *(_OWORD *)a1;
      *((_OWORD *)a4 + 1) = v14;
      if (a1 + 32 != a2)
      {
        uint64_t v15 = 0;
        uint64_t v16 = a4;
        do
        {
          int v17 = v16;
          v16 += 4;
          int v18 = v16;
          if (sub_1CCD24BCC((uint64_t *)v13, v17))
          {
            long long v19 = *((_OWORD *)v17 + 1);
            *(_OWORD *)uint64_t v16 = *(_OWORD *)v17;
            *((_OWORD *)v16 + 1) = v19;
            int v18 = v5;
            if (v17 != v5)
            {
              uint64_t v20 = v15;
              while (1)
              {
                int v18 = (uint64_t *)((char *)v5 + v20);
                if (!sub_1CCD24BCC((uint64_t *)v13, (uint64_t *)((char *)v5 + v20 - 32))) {
                  break;
                }
                long long v21 = *(_OWORD *)((char *)v5 + v20 - 16);
                *(_OWORD *)int v18 = *(_OWORD *)((char *)v5 + v20 - 32);
                *((_OWORD *)v18 + 1) = v21;
                v20 -= 32;
                if (!v20)
                {
                  int v18 = v5;
                  break;
                }
              }
            }
          }
          uint64_t result = *(__n128 *)v13;
          long long v22 = *(_OWORD *)(v13 + 16);
          v13 += 32;
          *(__n128 *)int v18 = result;
          *((_OWORD *)v18 + 1) = v22;
          v15 += 32;
        }
        while (v13 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CCD24F28(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, long long *a6, uint64_t a7)
{
  if (!a5) {
    return result;
  }
  uint64_t v9 = a5;
  uint64_t v13 = result;
  while (a4 > a7 && v9 > a7)
  {
    if (!a4) {
      return result;
    }
    for (uint64_t i = v13; ; i += 32)
    {
      uint64_t result = sub_1CCD24BCC(a2, (uint64_t *)v13);
      if (result) {
        break;
      }
      v13 += 32;
      if (!--a4) {
        return result;
      }
    }
    uint64_t v63 = a6;
    int v64 = a3;
    uint64_t v62 = a7;
    if (a4 < v9)
    {
      if (v9 >= 0) {
        uint64_t v15 = v9;
      }
      else {
        uint64_t v15 = v9 + 1;
      }
      unint64_t v16 = v15 >> 1;
      a3 = &a2[4 * (v15 >> 1)];
      unint64_t v17 = ((uint64_t)a2 - i) >> 5;
      if ((uint64_t *)v13 == a2)
      {
        uint64_t v13 = (uint64_t)a2;
        goto LABEL_45;
      }
      uint64_t v61 = v9;
      uint64_t v18 = v13;
      do
      {
        if (sub_1CCD24BCC(a3, (uint64_t *)(v18 + 32 * (v17 >> 1))))
        {
          v17 >>= 1;
        }
        else
        {
          v18 += 32 * (v17 >> 1) + 32;
          v17 += ~(v17 >> 1);
        }
      }
      while (v17);
      unint64_t v17 = (v18 - i) >> 5;
      goto LABEL_34;
    }
    if (a4 == 1)
    {
      long long v68 = *(_OWORD *)v13;
      long long v73 = *(_OWORD *)(v13 + 16);
      long long v57 = *((_OWORD *)a2 + 1);
      *(_OWORD *)uint64_t v13 = *(_OWORD *)a2;
      *(_OWORD *)(v13 + 16) = v57;
      *(_OWORD *)a2 = v68;
      *((_OWORD *)a2 + 1) = v73;
      return result;
    }
    if (a4 >= 0) {
      uint64_t v19 = a4;
    }
    else {
      uint64_t v19 = a4 + 1;
    }
    unint64_t v17 = v19 >> 1;
    uint64_t v18 = v13 + 32 * (v19 >> 1);
    unint64_t v16 = ((char *)a3 - (char *)a2) >> 5;
    if (a3 != a2)
    {
      uint64_t v61 = v9;
      a3 = a2;
      do
      {
        uint64_t v20 = &a3[4 * (v16 >> 1)];
        int v21 = sub_1CCD24BCC(v20, (uint64_t *)v18);
        if (v21) {
          v16 += ~(v16 >> 1);
        }
        else {
          v16 >>= 1;
        }
        if (v21) {
          a3 = v20 + 4;
        }
      }
      while (v16);
      unint64_t v16 = ((char *)a3 - (char *)a2) >> 5;
LABEL_34:
      uint64_t v9 = v61;
    }
    if ((uint64_t *)v18 != a2)
    {
      if (a2 == a3)
      {
        a3 = a2;
        a2 = (uint64_t *)v18;
      }
      else if ((uint64_t *)(v18 + 32) == a2)
      {
        long long v66 = *(_OWORD *)v18;
        long long v70 = *(_OWORD *)(v18 + 16);
        memmove((void *)v18, a2, (char *)a3 - (char *)a2);
        a2 = (uint64_t *)(v18 + (char *)a3 - (char *)a2);
        *(_OWORD *)a2 = v66;
        *((_OWORD *)a2 + 1) = v70;
      }
      else if (a2 + 4 == a3)
      {
        a2 = (uint64_t *)(v18 + 32);
        long long v67 = *((_OWORD *)a3 - 2);
        long long v71 = *((_OWORD *)a3 - 1);
        if (a3 - 4 != (uint64_t *)v18) {
          memmove((void *)(v18 + 32), (const void *)v18, (size_t)a3 - v18 - 32);
        }
        *(_OWORD *)uint64_t v18 = v67;
        *(_OWORD *)(v18 + 16) = v71;
      }
      else
      {
        uint64_t v22 = ((uint64_t)a2 - v18) >> 5;
        if (v22 == ((char *)a3 - (char *)a2) >> 5)
        {
          uint64_t v23 = 0;
          do
          {
            uint64_t v24 = &a2[v23];
            uint64_t v25 = (_OWORD *)(v18 + v23 * 8);
            long long v65 = *(_OWORD *)(v18 + v23 * 8);
            long long v69 = *(_OWORD *)(v18 + v23 * 8 + 16);
            long long v26 = *(_OWORD *)&a2[v23 + 2];
            *uint64_t v25 = *(_OWORD *)&a2[v23];
            v25[1] = v26;
            *(_OWORD *)uint64_t v24 = v65;
            *((_OWORD *)v24 + 1) = v69;
            if ((uint64_t *)(v18 + v23 * 8 + 32) == a2) {
              break;
            }
            v23 += 4;
          }
          while (v24 + 4 != a3);
        }
        else
        {
          uint64_t v27 = ((char *)a3 - (char *)a2) >> 5;
          uint64_t v28 = ((uint64_t)a2 - v18) >> 5;
          do
          {
            uint64_t v29 = v28;
            uint64_t v28 = v27;
            uint64_t v27 = v29 % v27;
          }
          while (v27);
          if (v28)
          {
            unint64_t v30 = (_OWORD *)(v18 + 32 * v28);
            do
            {
              long long v31 = *(v30 - 2);
              long long v32 = *(v30 - 1);
              v30 -= 2;
              long long v72 = v32;
              int v33 = &v30[2 * v22];
              unint64_t v34 = v30;
              do
              {
                char v35 = v34;
                unint64_t v34 = v33;
                long long v36 = v33[1];
                *char v35 = *v33;
                v35[1] = v36;
                BOOL v37 = __OFSUB__(v22, ((char *)a3 - (char *)v33) >> 5);
                uint64_t v39 = v22 - (((char *)a3 - (char *)v33) >> 5);
                char v38 = (v39 < 0) ^ v37;
                int v33 = (_OWORD *)(v18 + 32 * v39);
                if (v38) {
                  int v33 = &v34[2 * v22];
                }
              }
              while (v33 != v30);
              *unint64_t v34 = v31;
              v34[1] = v72;
            }
            while (v30 != (_OWORD *)v18);
          }
          a2 = (uint64_t *)(v18 + 32 * (((char *)a3 - (char *)a2) >> 5));
        }
      }
      goto LABEL_61;
    }
LABEL_45:
    uint64_t v18 = (uint64_t)a2;
    a2 = a3;
LABEL_61:
    unint64_t v40 = a4 - v17;
    unint64_t v41 = v9 - v16;
    if ((uint64_t)(v16 + v17) >= (uint64_t)(v9 - (v16 + v17) + a4))
    {
      uint64_t result = sub_1CCD24F28(a2, a3, v64, a4 - v17, v41, v63, v62);
      a3 = (uint64_t *)v18;
      a7 = v62;
      unint64_t v41 = v16;
      a6 = v63;
      unint64_t v40 = v17;
      int v64 = a2;
    }
    else
    {
      uint64_t v42 = v18;
      unint64_t v43 = v16;
      a7 = v62;
      a6 = v63;
      uint64_t result = sub_1CCD24F28(v13, v42, a2, v17, v43, v63, v62);
      uint64_t v13 = (uint64_t)a2;
    }
    a4 = v40;
    uint64_t v9 = v41;
    a2 = a3;
    a3 = v64;
    if (!v41) {
      return result;
    }
  }
  if (a4 <= v9)
  {
    if ((uint64_t *)v13 != a2)
    {
      unint64_t v51 = 0;
      do
      {
        long long v52 = &a6[v51 / 0x10];
        long long v53 = *(_OWORD *)(v13 + v51 + 16);
        long long *v52 = *(_OWORD *)(v13 + v51);
        v52[1] = v53;
        v51 += 32;
      }
      while ((uint64_t *)(v13 + v51) != a2);
      if (v51)
      {
        uint64_t v54 = (uint64_t *)a6;
        while (a2 != a3)
        {
          uint64_t result = sub_1CCD24BCC(a2, v54);
          if (result)
          {
            long long v55 = *(_OWORD *)a2;
            long long v56 = *((_OWORD *)a2 + 1);
            a2 += 4;
          }
          else
          {
            long long v55 = *(_OWORD *)v54;
            long long v56 = *((_OWORD *)v54 + 1);
            v54 += 4;
          }
          *(_OWORD *)uint64_t v13 = v55;
          *(_OWORD *)(v13 + 16) = v56;
          v13 += 32;
          if (&a6[v51 / 0x10] == (long long *)v54) {
            return result;
          }
        }
        return (uint64_t)memmove((void *)v13, v54, (char *)a6 - (char *)v54 + v51);
      }
    }
  }
  else if (a2 != a3)
  {
    unint64_t v44 = 0;
    do
    {
      BOOL v45 = &a6[v44 / 0x10];
      long long v46 = *(_OWORD *)&a2[v44 / 8 + 2];
      long long *v45 = *(_OWORD *)&a2[v44 / 8];
      v45[1] = v46;
      v44 += 32;
    }
    while (&a2[v44 / 8] != a3);
    if (v44)
    {
      uint64_t v47 = &a6[v44 / 0x10];
      long long v48 = a3 - 4;
      while (a2 != (uint64_t *)v13)
      {
        uint64_t result = sub_1CCD24BCC((uint64_t *)v47 - 4, a2 - 4);
        if (result) {
          long long v49 = a2 - 4;
        }
        else {
          long long v49 = (uint64_t *)(v47 - 2);
        }
        if (result) {
          a2 -= 4;
        }
        long long v50 = *((_OWORD *)v49 + 1);
        if (!result) {
          v47 -= 2;
        }
        *(_OWORD *)long long v48 = *(_OWORD *)v49;
        *((_OWORD *)v48 + 1) = v50;
        v48 -= 4;
        if (v47 == a6) {
          return result;
        }
      }
      if (v47 != a6)
      {
        unint64_t v58 = 0;
        do
        {
          uint64_t v59 = &v48[v58 / 8];
          long long v60 = v47[v58 / 0x10 - 1];
          *(_OWORD *)uint64_t v59 = v47[v58 / 0x10 - 2];
          *((_OWORD *)v59 + 1) = v60;
          v58 -= 32;
        }
        while (&v47[v58 / 0x10] != a6);
      }
    }
  }
  return result;
}

BOOL sub_1CCD25430(llvm *a1, llvm *a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  sub_1CCD2559C((uint64_t)&v12, a3, 39, a1, a2, 1);
  if (v13 < 2)
  {
LABEL_2:
    BOOL isConditionImplied = 0;
    goto LABEL_15;
  }
  BOOL v5 = v16;
  if (v16)
  {
    BOOL v6 = (llvm **)v15;
    BOOL v7 = (llvm **)((char *)v15 + 24 * v16);
    while (sub_1CCD236D0(a3, *(_DWORD *)v6, v6[1], v6[2]))
    {
      v6 += 3;
      if (v6 == v7)
      {
        BOOL v5 = v13 == 0;
        goto LABEL_8;
      }
    }
    goto LABEL_2;
  }
LABEL_8:
  if (v19) {
    uint64_t v8 = a3 + 392;
  }
  else {
    uint64_t v8 = a3 + 48;
  }
  v10[0] = v11;
  v10[1] = (void *)0x800000000;
  if (!v5) {
    llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)v10, (uint64_t)&v12);
  }
  BOOL isConditionImplied = llvm::ConstraintSystem::isConditionImplied(v8, (uint64_t)v10);
  if (v10[0] != v11) {
    free(v10[0]);
  }
LABEL_15:
  sub_1CD4779B0(&v18);
  if (v15 != &v17) {
    free(v15);
  }
  if (v12 != &v14) {
    free(v12);
  }
  return isConditionImplied;
}

void sub_1CCD2559C(uint64_t a1, uint64_t a2, int a3, llvm *a4, llvm *a5, int a6)
{
  void v36[4] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)(*(void *)(a2 + 736) + 24);
  __int16 v27 = 0;
  __int16 v28 = 0;
  uint64_t v29 = v31;
  long long v30 = xmmword_1CD96EEC0;
  v31[1] = v32;
  v31[2] = 0x1000000000;
  memset(&v32[128], 0, 24);
  int v33 = v35;
  uint64_t v34 = 0x800000000;
  v35[16] = 0;
  v35[17] = v36;
  v35[18] = 0x800000000;
  sub_1CB94E404((uint64_t)v26, v12);
  if ((a3 - 38) <= 3
    && llvm::isKnownNonNegative(a4, (const llvm::Value *)v26, (const llvm::DataLayout *)5, 0, 0, 0, (const llvm::DominatorTree *)1)&& llvm::isKnownNonNegative(a5, (const llvm::Value *)v26, (const llvm::DataLayout *)5, 0, 0, 0, (const llvm::DominatorTree *)1))
  {
    a3 -= 4;
  }
  uint64_t v23 = v25;
  uint64_t v24 = 0x600000000;
  sub_1CCD2585C((uint64_t)&v14, a2, a3, a4, a5, (uint64_t)&v23, a6);
  unsigned int v13 = (_OWORD *)(a1 + 16);
  if (HIBYTE(v22) || v24)
  {
    *(void *)(a1 + 240) = 0;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *unsigned int v13 = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = 0x800000000;
    *(void *)(a1 + 80) = a1 + 96;
    *(_DWORD *)(a1 + 92) = 2;
    *(void *)(a1 + 144) = a1 + 160;
    *(_DWORD *)(a1 + 156) = 1;
  }
  else
  {
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = 0x800000000;
    if (v15) {
      sub_1CD41C56C(a1, (uint64_t)&v14);
    }
    *(void *)(a1 + 80) = a1 + 96;
    *(void *)(a1 + 88) = 0x200000000;
    if (v18) {
      sub_1CB831C80(a1 + 80, (uint64_t)&v17);
    }
    *(void *)(a1 + 144) = a1 + 160;
    *(void *)(a1 + 152) = 0x100000000;
    if (v21) {
      sub_1CD477A94(a1 + 144, (uint64_t)&v20);
    }
    *(_WORD *)(a1 + 240) = v22;
  }
  sub_1CD4779B0(&v20);
  if (v17 != &v19) {
    free(v17);
  }
  if (v14 != &v16) {
    free(v14);
  }
  if (v23 != v25) {
    free(v23);
  }
  llvm::DataLayout::~DataLayout((llvm::DataLayout *)v26);
}

void sub_1CCD2585C(uint64_t a1, uint64_t a2, int a3, llvm::Value *a4, llvm::Value *this, uint64_t a6, int a7)
{
  v173[12] = *MEMORY[0x1E4F143B8];
  char v13 = 0;
  int v14 = 40;
  int v15 = this;
  switch(a3)
  {
    case ' ':
      char v16 = 0;
      if (!this) {
        goto LABEL_22;
      }
      unsigned int v17 = *((unsigned __int8 *)this + 16);
      if (v17 > 0x14) {
        goto LABEL_22;
      }
      if (v17 == 16)
      {
        uint64_t v18 = *((unsigned int *)this + 8);
        if (v18 >= 0x41)
        {
          int v120 = 0;
          int64_t v121 = (unint64_t)(v18 + 63) >> 6;
          do
          {
            BOOL v122 = v121-- < 1;
            if (v122) {
              break;
            }
            unint64_t v123 = *(void *)(*((void *)this + 3) + 8 * v121);
            v120 += __clz(v123);
          }
          while (!v123);
          int v124 = v18 | 0xFFFFFFC0;
          if ((v18 & 0x3F) == 0) {
            int v124 = 0;
          }
          if (v120 + v124 == v18) {
            goto LABEL_7;
          }
        }
        else if (!*((void *)this + 3))
        {
LABEL_7:
          char v16 = 1;
LABEL_22:
          char v13 = v16 ^ 1;
          int v14 = 37;
          goto LABEL_23;
        }
      }
      else if (v17 == 17)
      {
        if (sub_1CB844168((uint64_t)this, 0.0)) {
          goto LABEL_7;
        }
      }
      else
      {
        char v16 = 1;
        if (v17 - 18 < 3 || v17 == 13) {
          goto LABEL_22;
        }
      }
      char v16 = sub_1CC03F414((uint64_t)&v151, this);
      goto LABEL_22;
    case '!':
      if (!this) {
        goto LABEL_14;
      }
      unsigned int v19 = *((unsigned __int8 *)this + 16);
      if (v19 > 0x14) {
        goto LABEL_14;
      }
      if (v19 == 16)
      {
        uint64_t v20 = *((unsigned int *)this + 8);
        if (v20 >= 0x41)
        {
          int v125 = 0;
          int64_t v126 = (unint64_t)(v20 + 63) >> 6;
          do
          {
            BOOL v122 = v126-- < 1;
            if (v122) {
              break;
            }
            unint64_t v127 = *(void *)(*((void *)this + 3) + 8 * v126);
            v125 += __clz(v127);
          }
          while (!v127);
          int v128 = v20 | 0xFFFFFFC0;
          if ((v20 & 0x3F) == 0) {
            int v128 = 0;
          }
          if (v125 + v128 == v20) {
            goto LABEL_31;
          }
        }
        else if (!*((void *)this + 3))
        {
          goto LABEL_31;
        }
      }
      else if (v19 == 17)
      {
        if (sub_1CB844168((uint64_t)this, 0.0)) {
          goto LABEL_31;
        }
      }
      else if (v19 - 18 < 3 || v19 == 13)
      {
        goto LABEL_31;
      }
      if ((sub_1CC03F414((uint64_t)&v151, this) & 1) == 0)
      {
LABEL_14:
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 144) = 0u;
        *(void *)(a1 + 240) = 0;
        *(_OWORD *)(a1 + 208) = 0u;
        *(_OWORD *)(a1 + 224) = 0u;
        *(_OWORD *)(a1 + 176) = 0u;
        *(_OWORD *)(a1 + 192) = 0u;
        *(_OWORD *)(a1 + 112) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 80) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 160) = 0u;
        *(_OWORD *)(a1 + 96) = 0u;
        *(_OWORD *)(a1 + 16) = 0u;
        *(void *)a1 = a1 + 16;
        *(void *)(a1 + 8) = 0x800000000;
        *(void *)(a1 + 80) = a1 + 96;
        *(_DWORD *)(a1 + 92) = 2;
        *(void *)(a1 + 144) = a1 + 160;
        *(_DWORD *)(a1 + 156) = 1;
        return;
      }
LABEL_31:
      char v13 = 0;
      int v14 = 36;
LABEL_32:
      int v15 = this;
LABEL_33:
      char v133 = v13;
      int v129 = v14;
      unsigned int v21 = v14 - 38;
      if ((v14 - 38) >= 4) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = 24;
      }
      if (v21 >= 4) {
        uint64_t v23 = a2;
      }
      else {
        uint64_t v23 = a2 + 24;
      }
      uint64_t v130 = a1;
      v172[0] = v173;
      v172[1] = (void *)0x400000000;
      uint64_t v24 = llvm::Value::stripPointerCastsSameRepresentation(v15);
      unsigned int v167 = 0;
      v168 = v170;
      unsigned int v25 = 1;
      v170[0] = 1;
      v170[1] = v24;
      char v171 = 0;
      uint64_t v169 = 0x300000001;
      long long v26 = llvm::Value::stripPointerCastsSameRepresentation(a4);
      uint64_t v162 = 0;
      v163 = v165;
      v165[0] = 1;
      v165[1] = v26;
      char v166 = 0;
      uint64_t v164 = 0x300000001;
      unsigned int v134 = v21;
      if (a7)
      {
        __int16 v27 = llvm::Value::stripPointerCastsSameRepresentation(v15);
        sub_1CCD26730((uint64_t)&v151, (uint64_t)v27, (uint64_t)v172, v21 < 4, *(void *)(a2 + 736));
        unsigned int v167 = v151;
        sub_1CCD2873C((uint64_t)&v168, (uint64_t)&v152);
        if (v152 != v154) {
          free(v152);
        }
        __int16 v28 = llvm::Value::stripPointerCastsSameRepresentation(a4);
        sub_1CCD26730((uint64_t)&v151, (uint64_t)v28, (uint64_t)v172, v21 < 4, *(void *)(a2 + 736));
        uint64_t v162 = v151;
        sub_1CCD2873C((uint64_t)&v163, (uint64_t)&v152);
        if (v152 != v154) {
          free(v152);
        }
        uint64_t v132 = v162;
        uint64_t v29 = v163;
        unsigned int v25 = v164;
      }
      else
      {
        uint64_t v132 = 0;
        uint64_t v29 = v165;
      }
      uint64_t v138 = 0;
      int32x2_t v139 = 0;
      int v140 = 0;
      uint64_t v131 = (uint64_t)v167;
      long long v30 = (char *)v168;
      uint64_t v151 = v168;
      uint64_t v152 = v29;
      long long v31 = (char *)v168 + 24 * v169;
      long long v32 = &v29[3 * v25];
      BOOL v153 = v31;
      v154[0] = v32;
      while (2)
      {
        if (v30 != v31 || v29 != v32 || (v153 == v31 ? (BOOL v33 = v154[0] == (void)v32) : (BOOL v33 = 0), !v33))
        {
          uint64_t v34 = 0;
          do
          {
            uint64_t v35 = (*(uint64_t (**)(void **))((char *)&off_1F263D688 + v34))(&v151);
            v34 += 16;
          }
          while (!v35);
          uint64_t v36 = *(void *)(v35 + 8);
          uint64_t v37 = *(void *)(a2 + v22);
          uint64_t v38 = *(unsigned int *)(v23 + 16);
          if (v38)
          {
            LODWORD(v39) = ((v36 >> 4) ^ (v36 >> 9)) & (v38 - 1);
            unint64_t v40 = (uint64_t *)(v37 + 16 * v39);
            uint64_t v41 = *v40;
            if (v36 != *v40)
            {
              int v42 = 1;
              do
              {
                if (v41 == -4096) {
                  goto LABEL_61;
                }
                int v43 = v39 + v42++;
                uint64_t v39 = v43 & (v38 - 1);
                uint64_t v41 = *(void *)(v37 + 16 * v39);
              }
              while (v36 != v41);
              unint64_t v40 = (uint64_t *)(v37 + 16 * v39);
            }
          }
          else
          {
LABEL_61:
            unint64_t v40 = (uint64_t *)(v37 + 16 * v38);
          }
          if (v40 == (uint64_t *)(v37 + 16 * v38))
          {
            int v44 = *(_DWORD *)(v23 + 8) + *(_DWORD *)(a6 + 8) + 1;
            uint64_t v143 = *(void *)(v35 + 8);
            int v144 = v44;
            sub_1CC6125EC((uint64_t)&v138, &v143, &v144, (uint64_t)v146);
            if (v147[0])
            {
              unint64_t v45 = *(unsigned int *)(a6 + 8);
              if (v45 >= *(unsigned int *)(a6 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)a6 + 8 * v45) = v36;
              ++*(_DWORD *)(a6 + 8);
            }
          }
          uint64_t v46 = 0;
          do
          {
            if ((*(uint64_t (**)(void **))((char *)&off_1F263D6A8 + v46))(&v151)) {
              break;
            }
            BOOL v33 = v46 == 16;
            v46 += 16;
          }
          while (!v33);
          long long v30 = (char *)v151;
          uint64_t v29 = v152;
          continue;
        }
        break;
      }
      unint64_t v47 = *(unsigned int *)(v23 + 8) + (unint64_t)*(unsigned int *)(a6 + 8) + 1;
      uint64_t v148 = v150;
      uint64_t v149 = 0x800000000;
      sub_1CD614194((uint64_t)&v148, v47, 0);
      uint64_t v151 = &v153;
      uint64_t v152 = (void *)0x800000000;
      if (v149) {
        llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)&v151, (uint64_t)&v148);
      }
      uint64_t v155 = v157;
      uint64_t v156 = 0x200000000;
      uint64_t v158 = (char *)&v160;
      uint64_t v159 = 0x100000000;
      __int16 v161 = v134 < 4;
      if (v148 != v150) {
        free(v148);
      }
      uint64_t v135 = 0;
      uint64_t v136 = 0;
      unsigned int v137 = 0;
      HIBYTE(v161) = v133;
      if (!v169) {
        goto LABEL_77;
      }
      long long v49 = (char *)v168;
      long long v50 = (char *)v168 + 24 * v169;
      break;
    case '""':
      goto LABEL_31;
    case '#':
      char v13 = 0;
      int v14 = 37;
      goto LABEL_32;
    case '$':
    case '%':
    case '(':
    case ')':
      char v13 = 0;
      int v14 = a3;
LABEL_23:
      int v15 = a4;
      a4 = this;
      goto LABEL_33;
    case '&':
      goto LABEL_33;
    case '\'':
      char v13 = 0;
      int v14 = 41;
      goto LABEL_32;
    default:
      goto LABEL_14;
  }
  do
  {
    uint64_t v51 = *((void *)v49 + 1);
    uint64_t v52 = *(void *)(a2 + v22);
    uint64_t v53 = *(unsigned int *)(v23 + 16);
    if (v53)
    {
      LODWORD(v54) = ((v51 >> 4) ^ (v51 >> 9)) & (v53 - 1);
      long long v55 = (uint64_t *)(v52 + 16 * v54);
      uint64_t v56 = *v55;
      if (v51 == *v55) {
        goto LABEL_89;
      }
      int v57 = 1;
      while (v56 != -4096)
      {
        int v58 = v54 + v57++;
        uint64_t v54 = v58 & (v53 - 1);
        uint64_t v56 = *(void *)(v52 + 16 * v54);
        if (v51 == v56)
        {
          long long v55 = (uint64_t *)(v52 + 16 * v54);
          goto LABEL_89;
        }
      }
    }
    long long v55 = (uint64_t *)(v52 + 16 * v53);
LABEL_89:
    uint64_t v59 = *(void *)v49;
    if (v55 == (uint64_t *)(v52 + 16 * v53))
    {
      int v60 = *(_DWORD *)(v23 + 8) + *(_DWORD *)(a6 + 8) + 1;
      uint64_t v143 = *((void *)v49 + 1);
      int v144 = v60;
      sub_1CC6125EC((uint64_t)&v138, &v143, &v144, (uint64_t)v146);
      if (v147[0])
      {
        unint64_t v61 = *(unsigned int *)(a6 + 8);
        if (v61 >= *(unsigned int *)(a6 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a6 + 8 * v61) = v51;
        ++*(_DWORD *)(a6 + 8);
      }
      uint64_t v62 = *((unsigned int *)v146[0] + 2);
      uint64_t v51 = *((void *)v49 + 1);
    }
    else
    {
      uint64_t v62 = *((unsigned int *)v55 + 2);
    }
    *((void *)v151 + v62) += v59;
    uint64_t v143 = v51;
    LOBYTE(v144) = v49[16];
    sub_1CD761330((uint64_t)v146, (uint64_t)&v135, &v143, &v144);
    *((unsigned char *)v146[0] + 8) &= v49[16];
    v49 += 24;
  }
  while (v49 != v50);
LABEL_77:
  if (v164)
  {
    uint64_t v63 = (char *)v163;
    int v64 = (char *)v163 + 24 * v164;
    while (1)
    {
      uint64_t v65 = *((void *)v63 + 1);
      uint64_t v66 = *(void *)(a2 + v22);
      uint64_t v67 = *(unsigned int *)(v23 + 16);
      if (!v67) {
        goto LABEL_105;
      }
      LODWORD(v68) = ((v65 >> 4) ^ (v65 >> 9)) & (v67 - 1);
      long long v69 = (uint64_t *)(v66 + 16 * v68);
      uint64_t v70 = *v69;
      if (v65 != *v69) {
        break;
      }
LABEL_106:
      uint64_t v73 = *(void *)v63;
      if (v69 == (uint64_t *)(v66 + 16 * v67))
      {
        int v74 = *(_DWORD *)(v23 + 8) + *(_DWORD *)(a6 + 8) + 1;
        uint64_t v143 = *((void *)v63 + 1);
        int v144 = v74;
        sub_1CC6125EC((uint64_t)&v138, &v143, &v144, (uint64_t)v146);
        if (v147[0])
        {
          unint64_t v75 = *(unsigned int *)(a6 + 8);
          if (v75 >= *(unsigned int *)(a6 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a6 + 8 * v75) = v65;
          ++*(_DWORD *)(a6 + 8);
        }
        uint64_t v76 = *((unsigned int *)v146[0] + 2);
        uint64_t v65 = *((void *)v63 + 1);
      }
      else
      {
        uint64_t v76 = *((unsigned int *)v69 + 2);
      }
      *((void *)v151 + v76) -= v73;
      uint64_t v143 = v65;
      LOBYTE(v144) = v63[16];
      sub_1CD761330((uint64_t)v146, (uint64_t)&v135, &v143, &v144);
      *((unsigned char *)v146[0] + 8) &= v63[16];
      v63 += 24;
      if (v63 == v64) {
        goto LABEL_78;
      }
    }
    int v71 = 1;
    while (v70 != -4096)
    {
      int v72 = v68 + v71++;
      uint64_t v68 = v72 & (v67 - 1);
      uint64_t v70 = *(void *)(v66 + 16 * v68);
      if (v65 == v70)
      {
        long long v69 = (uint64_t *)(v66 + 16 * v68);
        goto LABEL_106;
      }
    }
LABEL_105:
    long long v69 = (uint64_t *)(v66 + 16 * v67);
    goto LABEL_106;
  }
LABEL_78:
  int64_t v48 = (int64_t)&v132[-v131];
  if (!__OFADD__(-v131, v132))
  {
    int v77 = v134 >= 4 ? 36 : 40;
    if (v129 != v77 || (BOOL v78 = __OFSUB__(v48, 1), --v48, !v78))
    {
      *(void *)uint64_t v151 = v48;
      sub_1CB831C80((uint64_t)&v155, (uint64_t)v172);
      unsigned int v79 = *(_DWORD *)(a6 + 8);
      if (v79)
      {
        unsigned int v82 = v152;
        int32x2_t v83 = v139;
        int v84 = v140;
        unsigned int v85 = v140 - 1;
        do
        {
          if (*((void *)v151 + v82 - 1)) {
            break;
          }
          LODWORD(v152) = --v82;
          uint64_t v86 = *(void *)(*(void *)a6 + 8 * v79-- - 8);
          *(_DWORD *)(a6 + 8) = v79;
          if (v84)
          {
            LODWORD(v87) = ((v86 >> 4) ^ (v86 >> 9)) & v85;
            uint64_t v88 = (uint64_t *)(v138 + 16 * v87);
            uint64_t v89 = *v88;
            if (v86 == *v88)
            {
LABEL_128:
              *uint64_t v88 = -8192;
              int32x2_t v83 = vadd_s32(v83, (int32x2_t)0x1FFFFFFFFLL);
              int32x2_t v139 = v83;
              unsigned int v79 = *(_DWORD *)(a6 + 8);
            }
            else
            {
              int v90 = 1;
              while (v89 != -4096)
              {
                int v91 = v87 + v90++;
                uint64_t v87 = v91 & v85;
                uint64_t v89 = *(void *)(v138 + 16 * v87);
                if (v86 == v89)
                {
                  uint64_t v88 = (uint64_t *)(v138 + 16 * v87);
                  goto LABEL_128;
                }
              }
            }
          }
        }
        while (v79);
      }
      BOOL v80 = &v135[2 * v137];
      if (v136)
      {
        if (v137)
        {
          uint64_t v92 = 16 * v137;
          uint64_t v81 = v135;
          while ((*v81 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v81 += 2;
            v92 -= 16;
            if (!v92) {
              goto LABEL_138;
            }
          }
        }
        else
        {
          uint64_t v81 = v135;
        }
      }
      else
      {
LABEL_138:
        uint64_t v81 = &v135[2 * v137];
      }
      uint64_t v93 = &v135[2 * v137];
      if (v81 == v93)
      {
LABEL_140:
        *(void *)uint64_t v130 = v130 + 16;
        *(void *)(v130 + 8) = 0x800000000;
        if (v152) {
          sub_1CD41C56C(v130, (uint64_t)&v151);
        }
        *(void *)(v130 + 80) = v130 + 96;
        *(void *)(v130 + 88) = 0x200000000;
        if (v156) {
          sub_1CB831C80(v130 + 80, (uint64_t)&v155);
        }
        *(void *)(v130 + 144) = v130 + 160;
        *(void *)(v130 + 152) = 0x100000000;
        if (v159) {
          sub_1CD477A94(v130 + 144, (uint64_t)&v158);
        }
        *(_WORD *)(v130 + 240) = v161;
        goto LABEL_147;
      }
      while (2)
      {
        if (*((unsigned char *)v81 + 8))
        {
          uint64_t v94 = *v81;
          uint64_t v95 = *(void *)(a2 + v22);
          uint64_t v96 = *(unsigned int *)(v23 + 16);
          unsigned int v97 = *v81 >> 4;
          if (!v96) {
            goto LABEL_165;
          }
          LODWORD(v98) = (v97 ^ (v94 >> 9)) & (v96 - 1);
          __int16 v99 = (uint64_t *)(v95 + 16 * v98);
          uint64_t v100 = *v99;
          if (v94 != *v99)
          {
            int v101 = 1;
            while (v100 != -4096)
            {
              int v102 = v98 + v101++;
              uint64_t v98 = v102 & (v96 - 1);
              uint64_t v100 = *(void *)(v95 + 16 * v98);
              if (v94 == v100)
              {
                __int16 v99 = (uint64_t *)(v95 + 16 * v98);
                goto LABEL_166;
              }
            }
LABEL_165:
            __int16 v99 = (uint64_t *)(v95 + 16 * v96);
          }
LABEL_166:
          if (v99 != (uint64_t *)(v95 + 16 * v96)) {
            goto LABEL_177;
          }
          if (!v140) {
            goto LABEL_170;
          }
          unsigned int v103 = (v140 - 1) & (v97 ^ (v94 >> 9));
          uint64_t v104 = *(void *)(v138 + 16 * v103);
          if (v94 == v104)
          {
LABEL_169:
            if (v103 == v140) {
              goto LABEL_170;
            }
LABEL_177:
            unint64_t v106 = *(unsigned int *)(v23 + 8) + (unint64_t)*(unsigned int *)(a6 + 8) + 1;
            v146[0] = v147;
            v146[1] = (void *)0x800000000;
            sub_1CD614194((uint64_t)v146, v106, 0);
            uint64_t v107 = *v81;
            uint64_t v108 = *(void *)(a2 + v22);
            uint64_t v109 = *(unsigned int *)(v23 + 16);
            if (v109)
            {
              LODWORD(v110) = ((v107 >> 4) ^ (v107 >> 9)) & (v109 - 1);
              unint64_t v111 = (uint64_t *)(v108 + 16 * v110);
              uint64_t v112 = *v111;
              if (v107 != *v111)
              {
                int v113 = 1;
                while (v112 != -4096)
                {
                  int v114 = v110 + v113++;
                  uint64_t v110 = v114 & (v109 - 1);
                  uint64_t v112 = *(void *)(v108 + 16 * v110);
                  if (v107 == v112)
                  {
                    unint64_t v111 = (uint64_t *)(v108 + 16 * v110);
                    goto LABEL_184;
                  }
                }
                goto LABEL_183;
              }
            }
            else
            {
LABEL_183:
              unint64_t v111 = (uint64_t *)(v108 + 16 * v109);
            }
LABEL_184:
            if (v111 == (uint64_t *)(v108 + 16 * v109))
            {
              int v115 = *(_DWORD *)(v23 + 8) + *(_DWORD *)(a6 + 8) + 1;
              uint64_t v141 = *v81;
              int v142 = v115;
              sub_1CC6125EC((uint64_t)&v138, &v141, &v142, (uint64_t)&v143);
              if (v145)
              {
                unint64_t v116 = *(unsigned int *)(a6 + 8);
                if (v116 >= *(unsigned int *)(a6 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*(void *)a6 + 8 * v116) = v107;
                ++*(_DWORD *)(a6 + 8);
              }
              uint64_t v117 = *(unsigned int *)(v143 + 8);
            }
            else
            {
              uint64_t v117 = *((unsigned int *)v111 + 2);
            }
            *((void *)v146[0] + v117) = -1;
            sub_1CD7612C4((uint64_t)&v158, (unint64_t)v146);
            if (v146[0] != v147) {
              free(v146[0]);
            }
          }
          else
          {
            int v118 = 1;
            while (v104 != -4096)
            {
              unsigned int v119 = v103 + v118++;
              unsigned int v103 = v119 & (v140 - 1);
              uint64_t v104 = *(void *)(v138 + 16 * v103);
              if (v94 == v104) {
                goto LABEL_169;
              }
            }
          }
        }
LABEL_170:
        int v105 = v81 + 2;
        uint64_t v81 = v80;
        if (v105 != v80)
        {
          uint64_t v81 = v105;
          while ((*v81 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v81 += 2;
            if (v81 == v80)
            {
              uint64_t v81 = v80;
              break;
            }
          }
        }
        if (v81 == v93) {
          goto LABEL_140;
        }
        continue;
      }
    }
  }
  *(_OWORD *)(v130 + 128) = 0u;
  *(_OWORD *)(v130 + 144) = 0u;
  *(void *)(v130 + 240) = 0;
  *(_OWORD *)(v130 + 208) = 0u;
  *(_OWORD *)(v130 + 224) = 0u;
  *(_OWORD *)(v130 + 176) = 0u;
  *(_OWORD *)(v130 + 192) = 0u;
  *(_OWORD *)(v130 + 112) = 0u;
  *(_OWORD *)(v130 + 64) = 0u;
  *(_OWORD *)(v130 + 80) = 0u;
  *(_OWORD *)(v130 + 160) = 0u;
  *(_OWORD *)(v130 + 96) = 0u;
  *(_OWORD *)(v130 + 32) = 0u;
  *(_OWORD *)(v130 + 48) = 0u;
  *(_OWORD *)(v130 + 16) = 0u;
  *(void *)uint64_t v130 = v130 + 16;
  *(void *)(v130 + 8) = 0x800000000;
  *(void *)(v130 + 80) = v130 + 96;
  *(_DWORD *)(v130 + 92) = 2;
  *(void *)(v130 + 144) = v130 + 160;
  *(_DWORD *)(v130 + 156) = 1;
LABEL_147:
  MEMORY[0x1D25D9CD0](v135, 8);
  sub_1CD4779B0(&v158);
  if (v155 != v157) {
    free(v155);
  }
  if (v151 != &v153) {
    free(v151);
  }
  MEMORY[0x1D25D9CD0](v138, 8);
  if (v163 != v165) {
    free(v163);
  }
  if (v168 != v170) {
    free(v168);
  }
  if (v172[0] != v173) {
    free(v172[0]);
  }
}

void sub_1CCD26730(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v333 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(a5 + 24);
  __int16 v315 = 0;
  __int16 v316 = 0;
  uint64_t v317 = v319;
  long long v318 = xmmword_1CD96EEC0;
  v319[1] = v320;
  v319[2] = 0x1000000000;
  memset(&v320[128], 0, 24);
  unint64_t v321 = v323;
  uint64_t v322 = 0x800000000;
  v323[16] = 0;
  v323[17] = &v324;
  v323[18] = 0x800000000;
  sub_1CB94E404((uint64_t)v314, v10);
  int v11 = *(unsigned __int8 *)(a2 + 16);
  if (a2) {
    BOOL v12 = v11 == 16;
  }
  else {
    BOOL v12 = 0;
  }
  char v13 = !v12;
  if (a4)
  {
    if ((v13 & 1) == 0)
    {
      int v14 = (llvm::APInt *)(a2 + 24);
      uint64_t v15 = *(unsigned int *)(a2 + 32);
      if (v15 < 0x41)
      {
        unint64_t v16 = (uint64_t)(*(void *)v14 << -(char)v15) >> -(char)v15;
        if (v16 - 0x7FFFFFFFFFFFFFFFLL < 2) {
          goto LABEL_11;
        }
LABEL_415:
        *(void *)a1 = v16;
        *(void *)(a1 + 8) = a1 + 24;
        uint64_t v181 = 0x300000000;
        goto LABEL_416;
      }
      v262 = *(unint64_t **)v14;
      int v263 = v15 - 64;
      if ((*(void *)(*(void *)v14 + 8 * ((v15 - 1) >> 6)) >> (v15 - 1)))
      {
        if (v263 - llvm::APInt::countLeadingOnesSlowCase(v14) < 0xFFFFFFBF) {
          goto LABEL_11;
        }
        unint64_t v16 = *v262;
        if (*v262 == 0x8000000000000000) {
          goto LABEL_11;
        }
      }
      else
      {
        int v264 = 0;
        int64_t v265 = (unint64_t)(v15 + 63) >> 6;
        uint64_t v266 = v265;
        do
        {
          char v56 = v266-- < 1;
          if (v56) {
            break;
          }
          unint64_t v267 = v262[v266];
          v264 += __clz(v267);
        }
        while (!v267);
        if ((v15 & 0x3F) != 0) {
          int v268 = v15 | 0xFFFFFFC0;
        }
        else {
          int v268 = 0;
        }
        if ((v263 - v264 - v268) > 0xFFFFFFBE && *v262 == 0x8000000000000000) {
          goto LABEL_11;
        }
        int v269 = 0;
        do
        {
          char v56 = v265-- < 1;
          if (v56) {
            break;
          }
          unint64_t v270 = v262[v265];
          v269 += __clz(v270);
        }
        while (!v270);
        if ((v263 - (v268 + v269)) < 0xFFFFFFBF) {
          goto LABEL_11;
        }
        unint64_t v16 = *v262;
      }
      if (v16 != 0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_415;
      }
    }
LABEL_11:
    v325.n128_u64[0] = 0;
    uint64_t v328 = (uint64_t)&v325;
    int v17 = sub_1CBC5BE40((void **)&v328, a2);
    char v18 = v17;
    if (v17) {
      a2 = v325.n128_u64[0];
    }
    v308[0] = 0;
    uint64_t v328 = (uint64_t)&v325;
    uint64_t v329 = (uint64_t)v308;
    if (sub_1CCD285B4((void **)&v328, a2))
    {
      unsigned int v19 = v308[0];
      sub_1CCD26730(a1, v325.n128_u64[0], a3, 1, a5);
      sub_1CCD26730(&v328, v19, a3, 1, a5);
      uint64_t v20 = (unsigned char *)v329;
      *(void *)a1 += v328;
      unsigned int v21 = &v20[24 * v330];
      uint64_t v22 = (unsigned int *)(a1 + 8);
LABEL_15:
      sub_1CCD286A0(v22, v20, v21);
      uint64_t v23 = (void *)v329;
      goto LABEL_16;
    }
    uint64_t v328 = (uint64_t)&v325;
    int v34 = sub_1CBC5BEAC((void **)&v328, a2);
    unint64_t v35 = v325.n128_u64[0];
    if (!v34) {
      unint64_t v35 = a2;
    }
    *(void *)(a1 + 24) = 1;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = a1 + 24;
    *(void *)(a1 + 32) = v35;
    goto LABEL_270;
  }
  if ((v13 & 1) == 0)
  {
    uint64_t v33 = *(unsigned int *)(a2 + 32);
    if (v33 >= 0x41)
    {
      int v54 = 0;
      int64_t v55 = (unint64_t)(v33 + 63) >> 6;
      do
      {
        char v56 = v55-- < 1;
        if (v56) {
          break;
        }
        unint64_t v57 = *(void *)(*(void *)(a2 + 24) + 8 * v55);
        v54 += __clz(v57);
      }
      while (!v57);
      int v58 = v33 | 0xFFFFFFC0;
      if ((v33 & 0x3F) == 0) {
        int v58 = 0;
      }
      if ((v33 - v54 - v58) < 0x41)
      {
        unint64_t v16 = **(void **)(a2 + 24);
        if (v16 < 0x7FFFFFFFFFFFFFFFLL) {
          goto LABEL_415;
        }
      }
    }
    else
    {
      unint64_t v16 = *(void *)(a2 + 24);
      if (v16 <= 0x7FFFFFFFFFFFFFFELL) {
        goto LABEL_415;
      }
    }
    goto LABEL_65;
  }
  if (a2 && v11 == 83)
  {
    int v24 = *(_DWORD *)(a5 + 2184);
    if (v24)
    {
      uint64_t v25 = *(void *)(a5 + 2168);
      unsigned int v26 = (v24 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      __int16 v27 = (uint64_t *)(v25 + 40 * v26);
      uint64_t v28 = *v27;
      if (*v27 == a2)
      {
LABEL_23:
        if (v26 != v24)
        {
          uint64_t v30 = v27[1];
          uint64_t v29 = v27[2];
          unsigned int v31 = *((_DWORD *)v27 + 8);
          if (v31 > 0x40) {
            uint64_t v32 = *(void *)v27[3];
          }
          else {
            uint64_t v32 = v27[3] << -(char)v31 >> -(char)v31;
          }
          *(void *)(a1 + 24) = 1;
          *(void *)(a1 + 8) = a1 + 24;
          *(void *)a1 = 0;
          *(void *)(a1 + 32) = v30;
          *(unsigned char *)(a1 + 40) = 0;
          *(void *)(a1 + 16) = 0x300000001;
          sub_1CCD26730(&v328, v29, a3, 0, a5);
          uint64_t v72 = v328;
          uint64_t v20 = (unsigned char *)v329;
          if (v32 >= 0) {
            uint64_t v73 = v32;
          }
          else {
            uint64_t v73 = -v32;
          }
          if (v328 < 0) {
            uint64_t v72 = -v328;
          }
          uint64_t v74 = v72 * v73;
          if ((v328 ^ v32) < 0) {
            uint64_t v74 = -v74;
          }
          uint64_t v328 = v74;
          unsigned int v21 = (unsigned char *)(v329 + 24 * v330);
          if (v330)
          {
            uint64_t v75 = 24 * v330;
            uint64_t v76 = (uint64_t *)v329;
            do
            {
              uint64_t v77 = *v76;
              if (*v76 < 0) {
                uint64_t v77 = -v77;
              }
              uint64_t v78 = v77 * v73;
              if ((*v76 ^ v32) < 0) {
                uint64_t v78 = -v78;
              }
              uint64_t *v76 = v78;
              v76 += 3;
              v75 -= 24;
            }
            while (v75);
          }
          *(void *)a1 += v74;
          uint64_t v22 = (unsigned int *)(a1 + 8);
          goto LABEL_15;
        }
      }
      else
      {
        int v259 = 1;
        while (v28 != -4096)
        {
          unsigned int v260 = v26 + v259++;
          unsigned int v26 = v260 & (v24 - 1);
          __int16 v27 = (uint64_t *)(v25 + 40 * v26);
          uint64_t v28 = *v27;
          if (*v27 == a2) {
            goto LABEL_23;
          }
        }
      }
    }
    goto LABEL_65;
  }
  if (a2 && v11 == 62)
  {
    uint64_t v36 = *(void *)(a5 + 24);
    uint64_t v37 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
    uint64_t v38 = *(unsigned __int8 **)(a2 - 32 * v37);
    unsigned int v39 = *(_DWORD *)(*(void *)v38 + 8);
    if ((v39 & 0xFE) == 0x12) {
      unsigned int v39 = *(_DWORD *)(**(void **)(*(void *)v38 + 16) + 8);
    }
    uint64_t v40 = *(void *)(v36 + 232);
    if (v39 < 0x100) {
      goto LABEL_45;
    }
    unsigned int v41 = v39 >> 8;
    unint64_t v42 = *(unsigned int *)(v36 + 240);
    uint64_t v43 = *(void *)(v36 + 232);
    if (v42)
    {
      uint64_t v43 = v40;
      unint64_t v44 = v42;
      do
      {
        unint64_t v45 = v44 >> 1;
        uint64_t v46 = v43 + 16 * (v44 >> 1);
        unsigned int v47 = *(_DWORD *)(v46 + 8);
        uint64_t v48 = v46 + 16;
        v44 += ~(v44 >> 1);
        if (v47 < v41) {
          uint64_t v43 = v48;
        }
        else {
          unint64_t v44 = v45;
        }
      }
      while (v44);
    }
    if (v43 == v40 + 16 * v42 || *(_DWORD *)(v43 + 8) != v41) {
LABEL_45:
    }
      uint64_t v43 = v40;
    if (*(_DWORD *)(v43 + 12) >= 0x41u) {
      goto LABEL_65;
    }
    int v49 = v38[16];
    if (v49 == 62) {
      uint64_t v50 = *(void *)(a2 - 32 * v37);
    }
    else {
      uint64_t v50 = 0;
    }
    if (v37 == 2 && v49 == 62 && (*(unsigned char *)(a2 + 17) & 2) == 0)
    {
      v325.n128_u64[0] = *(void *)(v50 - 32 * (*(_DWORD *)(v50 + 20) & 0x7FFFFFF));
      uint64_t v328 = 0;
      if (sub_1CBA0E618(a5 + 2144, &v325, &v328))
      {
        if (v328 != *(void *)(a5 + 2144) + 16 * *(unsigned int *)(a5 + 2160))
        {
          uint64_t v51 = *(unsigned __int8 **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32);
          LODWORD(v329) = 64;
          uint64_t v328 = 1;
          if (sub_1CBF53154((llvm::APInt *)&v328, v51))
          {
            uint64_t v52 = *(_DWORD *)(v50 + 20) & 0x7FFFFFF;
            if (v52 == 2)
            {
              BOOL v53 = 1;
            }
            else
            {
              int v125 = *(unsigned __int8 **)(v50 - 32 * v52 + 32 * (v52 - 1));
              v325.n128_u32[2] = 64;
              v325.n128_u64[0] = 0;
              BOOL v53 = sub_1CBF53154((llvm::APInt *)&v325, v125);
              if (v325.n128_u32[2] >= 0x41 && v325.n128_u64[0]) {
                MEMORY[0x1D25D9CB0](v325.n128_u64[0], 0x1000C8000313F17);
              }
            }
          }
          else
          {
            BOOL v53 = 0;
          }
          if (v329 >= 0x41 && v328) {
            MEMORY[0x1D25D9CB0](v328, 0x1000C8000313F17);
          }
          if (v53)
          {
            uint64_t v85 = 24;
            if (*(unsigned char *)(a2 + 16) == 62) {
              uint64_t v85 = 64;
            }
            uint64_t v86 = *(void *)(a2 + v85);
            int v87 = *(_DWORD *)(a2 + 20);
            if ((v87 & 0x40000000) != 0) {
              uint64_t v88 = *(void *)(a2 - 8);
            }
            else {
              uint64_t v88 = a2 - 32 * (v87 & 0x7FFFFFF);
            }
            uint64_t v89 = (llvm::Type *)(v86 & 0xFFFFFFFFFFFFFFF8);
            if ((v86 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              if (*((unsigned char *)v89 + 8) != 19)
              {
                int v90 = *(llvm::DataLayout **)(a5 + 24);
                goto LABEL_138;
              }
            }
            else
            {
              AggregateElement = *(llvm::Constant **)(v88 + 32);
              if (!AggregateElement || *((unsigned char *)AggregateElement + 16) != 16) {
                AggregateElement = (llvm::Constant *)llvm::Constant::getAggregateElement(AggregateElement, 0);
              }
              unsigned int v97 = (unsigned int *)*((void *)AggregateElement + 3);
              uint64_t v95 = (unsigned int *)((char *)AggregateElement + 24);
              uint64_t v96 = v97;
              if (v95[2] < 0x41) {
                uint64_t v96 = v95;
              }
              uint64_t v98 = *v96;
              uint64_t v99 = MEMORY[0x10];
              if (*(unsigned char *)(*(void *)(MEMORY[0x10] + 8 * v98) + 8) != 19)
              {
                int v90 = *(llvm::DataLayout **)(a5 + 24);
                uint64_t v100 = *(llvm::Constant **)(v88 + 32);
                if (!v100 || *((unsigned char *)v100 + 16) != 16)
                {
                  uint64_t v100 = (llvm::Constant *)llvm::Constant::getAggregateElement(v100, 0);
                  uint64_t v99 = MEMORY[0x10];
                }
                unsigned int v103 = (unsigned int *)*((void *)v100 + 3);
                int v101 = (unsigned int *)((char *)v100 + 24);
                int v102 = v103;
                if (v101[2] < 0x41) {
                  int v102 = v101;
                }
                uint64_t v89 = *(llvm::Type **)(v99 + 8 * *v102);
LABEL_138:
                unint64_t v104 = (unint64_t)(sub_1CB83544C((uint64_t)v90, (uint64_t)v89) + 7) >> 3;
                uint64_t v105 = 1 << llvm::DataLayout::getAlignment(v90, v89, 1);
                unint64_t v106 = v105 + v104;
                uint64_t v328 = (uint64_t)&v330;
                uint64_t v329 = 0x400000000;
                sub_1CCD26730(a1, v50, &v328, 0, a5);
                uint64_t v107 = (llvm **)v328;
                if (v329)
                {
                  uint64_t v108 = 24 * v329;
                  do
                  {
                    if (*(_DWORD *)v107 == 37)
                    {
                      v308[0] = v107[2];
                      v325.n128_u64[0] = 0;
                      if (sub_1CBA0E618(a5 + 2144, v308, &v325))
                      {
                        if (v325.n128_u64[0] != *(void *)(a5 + 2144) + 16 * *(unsigned int *)(a5 + 2160)) {
                          *(_DWORD *)uint64_t v107 = 36;
                        }
                      }
                    }
                    v107 += 3;
                    v108 -= 24;
                  }
                  while (v108);
                  uint64_t v107 = (llvm **)v328;
                  unsigned int v109 = v329;
                }
                else
                {
                  unsigned int v109 = 0;
                }
                uint64_t v131 = *(unsigned int *)(a3 + 8);
                if (v131 + (unint64_t)v109 > *(unsigned int *)(a3 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v109)
                {
                  memcpy((void *)(*(void *)a3 + 24 * v131), v107, 24 * v109);
                  LODWORD(v131) = *(_DWORD *)(a3 + 8);
                }
                *(_DWORD *)(a3 + 8) = v131 + v109;
                *(void *)a1 += (v106 - 1) & -v105;
                uint64_t v23 = (void *)v328;
                if ((uint64_t *)v328 != &v330) {
                  goto LABEL_17;
                }
                goto LABEL_417;
              }
            }
LABEL_65:
            *(void *)(a1 + 24) = 1;
            *(void *)a1 = 0;
            *(void *)(a1 + 8) = a1 + 24;
            *(void *)(a1 + 32) = a2;
LABEL_66:
            *(unsigned char *)(a1 + 40) = 0;
LABEL_271:
            uint64_t v181 = 0x300000001;
LABEL_416:
            *(void *)(a1 + 16) = v181;
            goto LABEL_417;
          }
        }
      }
    }
    uint64_t v110 = *(void *)a2;
    unsigned int v111 = *(_DWORD *)(*(void *)a2 + 8);
    if ((v111 & 0xFE) == 0x12)
    {
      uint64_t v110 = **(void **)(v110 + 16);
      unsigned int v111 = *(_DWORD *)(v110 + 8);
    }
    uint64_t v112 = *(void *)(a5 + 24);
    if ((v111 & 0xFE) == 0x12) {
      unsigned int v111 = *(_DWORD *)(**(void **)(v110 + 16) + 8);
    }
    if (v111 < 0x100) {
      goto LABEL_159;
    }
    unsigned int v113 = v111 >> 8;
    uint64_t v114 = *(unsigned int *)(v112 + 240);
    uint64_t v115 = *(void *)(v112 + 232);
    if (v114)
    {
      uint64_t v115 = *(void *)(v112 + 232);
      unint64_t v116 = *(unsigned int *)(v112 + 240);
      do
      {
        unint64_t v117 = v116 >> 1;
        uint64_t v118 = v115 + 16 * (v116 >> 1);
        unsigned int v119 = *(_DWORD *)(v118 + 8);
        uint64_t v120 = v118 + 16;
        v116 += ~(v116 >> 1);
        if (v119 < v113) {
          uint64_t v115 = v120;
        }
        else {
          unint64_t v116 = v117;
        }
      }
      while (v116);
    }
    if (v115 == *(void *)(v112 + 232) + 16 * v114 || *(_DWORD *)(v115 + 8) != v113) {
LABEL_159:
    }
      uint64_t v115 = *(void *)(v112 + 232);
    unsigned int v121 = *(_DWORD *)(v115 + 12);
    v308[0] = 0;
    v308[1] = 0;
    int v309 = 0;
    uint64_t v311 = 0;
    uint64_t v312 = 0;
    uint64_t v310 = 0;
    unsigned int v307 = v121;
    if (v121 > 0x40) {
      operator new[]();
    }
    __src = 0;
    if ((llvm::GEPOperator::collectOffset(a2, (llvm::DataLayout *)v112, v121, (uint64_t)v308, (unsigned int *)&__src) & 1) == 0)
    {
      *(void *)(a1 + 24) = 1;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = a1 + 24;
      *(void *)(a1 + 32) = a2;
      *(unsigned char *)(a1 + 40) = 0;
      *(void *)(a1 + 16) = 0x300000001;
      goto LABEL_388;
    }
    char v122 = *(unsigned char *)(a2 + 17);
    if ((v122 & 2) != 0 && v310 == v311 && v49 == 62 && (*(_DWORD *)(v50 + 20) & 0x7FFFFFF) == 2)
    {
      sub_1CCD26730(&v328, v50, a3, 0, a5);
      if (v307 > 0x40) {
        uint64_t v200 = *(void *)__src;
      }
      else {
        uint64_t v200 = (uint64_t)((void)__src << -(char)v307) >> -(char)v307;
      }
      v328 += v200;
      p_src = &__src;
      if (v307 >= 0x41) {
        p_src = (void **)((char *)__src + 8 * ((v307 - 1) >> 6));
      }
      if (((unint64_t)*p_src >> (v307 - 1)))
      {
        v219 = *(llvm::DataLayout **)(a5 + 24);
        uint64_t v220 = *(llvm::Type **)(v50 + 72);
        unint64_t v221 = (unint64_t)(sub_1CB83544C((uint64_t)v219, (uint64_t)v220) + 7) >> 3;
        BOOL v223 = v222 == 1;
        char Alignment = llvm::DataLayout::getAlignment(v219, v220, 1);
        unint64_t v226 = (1 << Alignment) + 0xFFFFFFFFLL + v221;
        uint64_t v227 = -(1 << Alignment);
        if (v223) {
        if (v307 > 0x40)
        }
          uint64_t v228 = *(void *)__src;
        else {
          uint64_t v228 = (uint64_t)((void)__src << -(uint64_t)v307) >> -(uint64_t)v307;
        }
        uint64_t v232 = v227 & v226;
        if (v228 % v232)
        {
          *(void *)(a1 + 24) = 1;
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = a1 + 24;
          *(void *)(a1 + 32) = a2;
          *(unsigned char *)(a1 + 40) = 0;
          *(void *)(a1 + 16) = 0x300000001;
          goto LABEL_354;
        }
        uint64_t v233 = *(llvm::ConstantInt ***)(v50 - 32 * (*(_DWORD *)(v50 + 20) & 0x7FFFFFF) + 32);
        uint64_t v234 = llvm::ConstantInt::get(*v233, -(v228 / v232), 0);
        unsigned int v235 = *(_DWORD *)(a3 + 8);
        if (v235 >= *(_DWORD *)(a3 + 12))
        {
          v325.n128_u32[0] = 39;
          v325.n128_u64[1] = (unint64_t)v233;
          unsigned int v326 = v234;
          sub_1CBC0D590(a3, &v325);
        }
        else
        {
          uint64_t v236 = *(void *)a3 + 24 * v235;
          *(_DWORD *)uint64_t v236 = 39;
          *(void *)(v236 + 8) = v233;
          *(void *)(v236 + 16) = v234;
          *(_DWORD *)(a3 + 8) = v235 + 1;
        }
      }
      *(void *)a1 = v328;
      *(void *)(a1 + 8) = a1 + 24;
      *(void *)(a1 + 16) = 0x300000000;
      if (v330) {
        sub_1CCD2873C(a1 + 8, (uint64_t)&v329);
      }
LABEL_354:
      unint64_t v237 = (void *)v329;
      if ((void *)v329 == v331)
      {
LABEL_388:
        if (v307 >= 0x41 && __src) {
          MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
        }
        sub_1CD76127C((uint64_t)v308);
        goto LABEL_417;
      }
LABEL_387:
      free(v237);
      goto LABEL_388;
    }
    unint64_t v123 = __src;
    if (v307 > 0x40) {
      uint64_t v124 = *(void *)__src;
    }
    else {
      uint64_t v124 = (uint64_t)((void)__src << -(char)v307) >> -(char)v307;
    }
    uint64_t v201 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
    uint64_t v328 = v124;
    uint64_t v329 = (uint64_t)v331;
    v331[0] = 1;
    v331[1] = v201;
    char v332 = 0;
    uint64_t v330 = 0x300000001;
    if ((v122 & 2) == 0)
    {
      if (v307 >= 0x41) {
        operator new[]();
      }
      sub_1CD761220((uint64_t)v303, (uint64_t)v308);
      if (v304 == v305)
      {
        int v202 = 0;
      }
      else if (v123)
      {
        int v202 = 2;
      }
      else
      {
        int v202 = 1;
      }
      sub_1CD76127C((uint64_t)v303);
      if (v202 == 2
        || (uint64_t v313 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)),
            v325.n128_u64[0] = 0,
            !sub_1CBA0E618(a5 + 2144, &v313, &v325))
        || (unint64_t v206 = v325.n128_u64[0], v325.n128_u64[0] == *(void *)(a5 + 2144) + 16 * *(unsigned int *)(a5 + 2160)))
      {
        *(void *)(a1 + 24) = 1;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = a1 + 24;
        *(void *)(a1 + 32) = a2;
        *(unsigned char *)(a1 + 40) = 0;
        *(void *)(a1 + 16) = 0x300000001;
        goto LABEL_386;
      }
      if (v310 == v311)
      {
        int v207 = *(llvm::ConstantInt ****)(v325.n128_u64[0] + 8);
        uint64_t v208 = *v207;
        Splat = llvm::ConstantInt::get(**v207, (llvm::LLVMContext *)&__src, v205);
        if ((v208[1] & 0xFE) == 0x12) {
          Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v208 + 8) | ((unint64_t)(*((_DWORD *)v208 + 2) == 19) << 32)), (uint64_t)Splat);
        }
      }
      else
      {
        uint64_t v229 = *(llvm::ConstantInt ***)v310;
        unsigned int v230 = *(_DWORD *)(v310 + 16);
        if (v230 > 0x40) {
          unint64_t v231 = **(void **)(v310 + 8);
        }
        else {
          unint64_t v231 = (uint64_t)(*(void *)(v310 + 8) << -(char)v230) >> -(char)v230;
        }
        int v238 = llvm::ConstantInt::get(**(llvm::ConstantInt ***)v310, v231, 0);
        v327[4] = 257;
        Splat = llvm::BinaryOperator::Create(17, v229, (uint64_t)v238, (const char **)&v325, 0);
        Splat[17] |= 2u;
        unsigned int v239 = *(_DWORD *)(a5 + 40);
        if (v239 >= *(_DWORD *)(a5 + 44)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a5 + 32) + 8 * v239) = Splat;
        ++*(_DWORD *)(a5 + 40);
      }
      unsigned int v240 = *(_DWORD *)(a3 + 8);
      if (v240 >= *(_DWORD *)(a3 + 12))
      {
        uint64_t v261 = *(void **)(v206 + 8);
        v325.n128_u32[0] = 37;
        v325.n128_u64[1] = (unint64_t)Splat;
        unsigned int v326 = v261;
        sub_1CBC0D590(a3, &v325);
      }
      else
      {
        uint64_t v241 = *(void *)(v206 + 8);
        uint64_t v242 = *(void *)a3 + 24 * v240;
        *(_DWORD *)uint64_t v242 = 37;
        *(void *)(v242 + 8) = Splat;
        *(void *)(v242 + 16) = v241;
        *(_DWORD *)(a3 + 8) = v240 + 1;
      }
    }
    uint64_t v243 = v310;
    for (uint64_t i = v311; v243 != i; v243 += 24)
    {
      uint64_t v245 = *(llvm::ConstantInt ***)v243;
      unsigned int v246 = *(_DWORD *)(v243 + 16);
      if (v246 > 0x40) {
        operator new[]();
      }
      uint64_t v247 = *(void *)(v243 + 8);
      sub_1CCD26730(&v325, v245, a3, 0, a5);
      uint64_t v248 = v247 << -(char)v246 >> -(char)v246;
      int v249 = (unsigned char *)v325.n128_u64[1];
      unint64_t v250 = v325.n128_u64[0];
      if (v248 >= 0) {
        uint64_t v251 = v247 << -(char)v246 >> -(char)v246;
      }
      else {
        uint64_t v251 = -v248;
      }
      if (v325.n128_i64[0] < 0) {
        unint64_t v250 = -v325.n128_u64[0];
      }
      unint64_t v252 = v250 * v251;
      if (((v325.n128_u64[0] ^ v248) & 0x8000000000000000) != 0) {
        unint64_t v252 = -(uint64_t)v252;
      }
      v325.n128_u64[0] = v252;
      int v253 = (int)v326;
      if (v326)
      {
        uint64_t v254 = 24 * v326;
        uint64_t v255 = (uint64_t *)v325.n128_u64[1];
        do
        {
          uint64_t v256 = *v255;
          if (*v255 < 0) {
            uint64_t v256 = -v256;
          }
          uint64_t v257 = v256 * v251;
          if ((*v255 ^ v248) < 0) {
            uint64_t v257 = -v257;
          }
          *uint64_t v255 = v257;
          v255 += 3;
          v254 -= 24;
        }
        while (v254);
      }
      v328 += v252;
      sub_1CCD286A0((unsigned int *)&v329, v249, &v249[24 * v253]);
      if ((llvm::isKnownNonNegative((llvm *)v245, *(const llvm::Value **)(a5 + 24), 0, 0, 0, 0, (const llvm::DominatorTree *)1) & 1) == 0)
      {
        uint64_t v258 = llvm::ConstantInt::get(*v245, 0, 0);
        sub_1CCD2855C(a3, 0x27u, (unint64_t)v245, (uint64_t)v258);
      }
      if ((_WORD *)v325.n128_u64[1] != v327) {
        free((void *)v325.n128_u64[1]);
      }
    }
    *(void *)a1 = v328;
    *(void *)(a1 + 8) = a1 + 24;
    *(void *)(a1 + 16) = 0x300000000;
    if (v330) {
      sub_1CCD2873C(a1 + 8, (uint64_t)&v329);
    }
LABEL_386:
    unint64_t v237 = (void *)v329;
    if ((void *)v329 == v331) {
      goto LABEL_388;
    }
    goto LABEL_387;
  }
  v325.n128_u64[0] = 0;
  v308[0] = 0;
  uint64_t v328 = (uint64_t)&v325;
  int v59 = sub_1CBC5BE40((void **)&v328, a2);
  char v18 = v59;
  if (v59) {
    a2 = v325.n128_u64[0];
  }
  uint64_t v328 = (uint64_t)&v325;
  if (sub_1CBC5BEAC((void **)&v328, a2))
  {
    a2 = v325.n128_u64[0];
    int v60 = llvm::ConstantInt::get(*(llvm::ConstantInt **)v325.n128_u64[0], 0, 0);
    sub_1CCD2855C(a3, 0x27u, v325.n128_u64[0], (uint64_t)v60);
  }
  unsigned int v61 = *(unsigned __int8 *)(a2 + 16);
  if (v61 < 0x1C)
  {
    if (v61 != 5) {
      goto LABEL_82;
    }
    unsigned int v66 = *(unsigned __int16 *)(a2 + 18);
    HIDWORD(v68) = v66 - 13;
    LODWORD(v68) = v66 - 13;
    unsigned int v67 = v68 >> 1;
    if (v67 > 6 || ((1 << v67) & 0x47) == 0) {
      goto LABEL_82;
    }
  }
  else
  {
    HIDWORD(v63) = v61 - 41;
    LODWORD(v63) = v61 - 41;
    unsigned int v62 = v63 >> 1;
    char v56 = v62 > 6;
    int v64 = (1 << v62) & 0x47;
    if (v56) {
      BOOL v65 = 1;
    }
    else {
      BOOL v65 = v64 == 0;
    }
    if (v65) {
      goto LABEL_82;
    }
    unsigned int v66 = v61 - 28;
  }
  if (v66 == 13 && (*(unsigned char *)(a2 + 17) & 2) != 0)
  {
    int v91 = *(_DWORD *)(a2 + 20);
    if ((v91 & 0x40000000) != 0)
    {
      int64_t v126 = *(unint64_t **)(a2 - 8);
      unint64_t v93 = *v126;
      if (!*v126) {
        goto LABEL_82;
      }
      v325.n128_u64[0] = *v126;
      uint64_t v92 = *(unint64_t **)(a2 - 8);
    }
    else
    {
      uint64_t v92 = (unint64_t *)(a2 - 32 * (v91 & 0x7FFFFFF));
      unint64_t v93 = *v92;
      if (!*v92) {
        goto LABEL_82;
      }
      v325.n128_u64[0] = *v92;
    }
    unint64_t v127 = v92[4];
    if (v127)
    {
      v308[0] = (llvm *)v92[4];
      sub_1CCD26730(a1, v93, a3, 0, a5);
      unint64_t v128 = v127;
      uint64_t v129 = a3;
      uint64_t v130 = 0;
LABEL_296:
      sub_1CCD26730(&v328, v128, v129, v130, a5);
      uint64_t v199 = (unsigned char *)v329;
      *(void *)a1 += v328;
      sub_1CCD286A0((unsigned int *)(a1 + 8), v199, &v199[24 * v330]);
      uint64_t v23 = (void *)v329;
      goto LABEL_16;
    }
  }
LABEL_82:
  uint64_t v328 = (uint64_t)&v325;
  uint64_t v329 = (uint64_t)v308;
  if (!sub_1CCD285B4((void **)&v328, a2))
  {
    unsigned int v69 = *(unsigned __int8 *)(a2 + 16);
    if (v69 == 5)
    {
      int v79 = *(unsigned __int16 *)(a2 + 18);
      if (v79 != 13) {
        goto LABEL_190;
      }
      uint64_t v80 = a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF);
      uint64_t v70 = *(llvm::ConstantInt ***)v80;
      if (!*(void *)v80)
      {
        int v79 = 13;
        goto LABEL_190;
      }
      v325.n128_u64[0] = *(void *)v80;
      unint64_t v71 = *(void *)(v80 + 32);
      int v79 = 13;
      if (!v71 || *(unsigned char *)(v71 + 16) != 16) {
        goto LABEL_190;
      }
    }
    else
    {
      if (v69 != 41) {
        goto LABEL_183;
      }
      uint64_t v70 = *(llvm::ConstantInt ***)(a2 - 64);
      if (!v70) {
        goto LABEL_184;
      }
      v325.n128_u64[0] = *(void *)(a2 - 64);
      unint64_t v71 = *(void *)(a2 - 32);
      if (!v71 || *(unsigned char *)(v71 + 16) != 16) {
        goto LABEL_184;
      }
    }
    uint64_t v81 = (llvm::APInt *)(v71 + 24);
    unsigned int v82 = *(_DWORD *)(v71 + 32);
    unsigned int v83 = v82 - 1;
    if (v82 > 0x40)
    {
      uint64_t v132 = *(uint64_t **)v81;
      if (((*(void *)(*(void *)v81 + 8 * (v83 >> 6)) >> v83) & 1) == 0
        || v82 - llvm::APInt::countLeadingOnesSlowCase(v81) - 64 < 0xFFFFFFBF)
      {
        goto LABEL_183;
      }
      uint64_t v84 = *v132;
      goto LABEL_182;
    }
    if ((*(void *)v81 >> v83))
    {
      uint64_t v84 = (uint64_t)(*(void *)v81 << -(char)v82) >> -(char)v82;
LABEL_182:
      if ((unint64_t)(v84 - 0x7FFFFFFFFFFFFFFFLL) < 2) {
        goto LABEL_183;
      }
      uint64_t v198 = llvm::ConstantInt::get(*v70, -v84, 0);
      sub_1CCD2855C(a3, 0x23u, v325.n128_u64[0], (uint64_t)v198);
      sub_1CCD26730(a1, v325.n128_u64[0], a3, 0, a5);
      unint64_t v128 = v71;
      uint64_t v129 = a3;
      uint64_t v130 = 1;
      goto LABEL_296;
    }
LABEL_183:
    if (v69 >= 0x1C)
    {
LABEL_184:
      HIDWORD(v134) = v69 - 41;
      LODWORD(v134) = v69 - 41;
      unsigned int v133 = v134 >> 1;
      if (v133 > 6 || ((1 << v133) & 0x47) == 0) {
        goto LABEL_196;
      }
      int v79 = v69 - 28;
      int v135 = 1;
      goto LABEL_193;
    }
    if (v69 != 5) {
      goto LABEL_269;
    }
    int v79 = *(unsigned __int16 *)(a2 + 18);
LABEL_190:
    HIDWORD(v137) = v79 - 13;
    LODWORD(v137) = v79 - 13;
    unsigned int v136 = v137 >> 1;
    if (v136 > 6 || ((1 << v136) & 0x47) == 0) {
      goto LABEL_200;
    }
    int v135 = 0;
LABEL_193:
    if (v79 != 25 || (*(unsigned char *)(a2 + 17) & 2) == 0) {
      goto LABEL_195;
    }
    int v149 = *(_DWORD *)(a2 + 20);
    if ((v149 & 0x40000000) != 0)
    {
      uint64_t v155 = *(llvm ***)(a2 - 8);
      uint64_t v151 = *v155;
      if (!*v155) {
        goto LABEL_195;
      }
      v308[0] = *v155;
      uint64_t v150 = *(llvm ***)(a2 - 8);
    }
    else
    {
      uint64_t v150 = (llvm **)(a2 - 32 * (v149 & 0x7FFFFFF));
      uint64_t v151 = *v150;
      if (!*v150) {
        goto LABEL_195;
      }
      v308[0] = *v150;
    }
    uint64_t v156 = v150[4];
    if (!v156 || *((unsigned char *)v156 + 16) != 16) {
      goto LABEL_195;
    }
    unsigned int v157 = (llvm *)((char *)v156 + 24);
    uint64_t v158 = *((unsigned int *)v156 + 8);
    if (v158 >= 0x41)
    {
      v271 = *(uint64_t **)v157;
      int v272 = v158 - 64;
      if ((*(void *)(*(void *)v157 + 8 * ((v158 - 1) >> 6)) >> (v158 - 1)))
      {
        if (v272 - llvm::APInt::countLeadingOnesSlowCase(v157) < 0xFFFFFFBF) {
          goto LABEL_195;
        }
        uint64_t v159 = *v271;
        if (*v271 == 0x8000000000000000) {
          goto LABEL_195;
        }
      }
      else
      {
        int v273 = 0;
        int64_t v274 = (unint64_t)(v158 + 63) >> 6;
        uint64_t v275 = v274;
        do
        {
          char v56 = v275-- < 1;
          if (v56) {
            break;
          }
          unint64_t v276 = v271[v275];
          v273 += __clz(v276);
        }
        while (!v276);
        if ((v158 & 0x3F) != 0) {
          int v277 = v158 | 0xFFFFFFC0;
        }
        else {
          int v277 = 0;
        }
        if ((v272 - v273 - v277) > 0xFFFFFFBE && *v271 == 0x8000000000000000) {
          goto LABEL_195;
        }
        int v278 = 0;
        do
        {
          char v56 = v274-- < 1;
          if (v56) {
            break;
          }
          unint64_t v279 = v271[v274];
          v278 += __clz(v279);
        }
        while (!v279);
        if ((v272 - (v277 + v278)) < 0xFFFFFFBF) {
          goto LABEL_195;
        }
        uint64_t v159 = *v271;
      }
      if (v159 != 0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_223;
      }
    }
    else
    {
      uint64_t v159 = (uint64_t)(*(void *)v157 << -(char)v158) >> -(char)v158;
      if ((unint64_t)(v159 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
      {
LABEL_223:
        uint64_t v160 = (uint64_t)exp2((double)v159);
        sub_1CCD26730(a1, v151, a3, 0, a5);
        uint64_t v161 = *(void *)a1;
        if (v160 >= 0) {
          uint64_t v162 = v160;
        }
        else {
          uint64_t v162 = -v160;
        }
        if (v161 < 0) {
          uint64_t v161 = -v161;
        }
        uint64_t v163 = v161 * v162;
        if ((*(void *)a1 ^ v160) < 0) {
          uint64_t v163 = -v163;
        }
        *(void *)a1 = v163;
        uint64_t v164 = *(unsigned int *)(a1 + 16);
        if (v164)
        {
          uint64_t v165 = *(uint64_t **)(a1 + 8);
          uint64_t v166 = 24 * v164;
          do
          {
            uint64_t v167 = *v165;
            if (*v165 < 0) {
              uint64_t v167 = -v167;
            }
            uint64_t v168 = v167 * v162;
            if ((*v165 ^ v160) < 0) {
              uint64_t v168 = -v168;
            }
            uint64_t *v165 = v168;
            v165 += 3;
            v166 -= 24;
          }
          while (v166);
        }
        goto LABEL_417;
      }
    }
LABEL_195:
    if (v135)
    {
LABEL_196:
      HIDWORD(v139) = v69 - 41;
      LODWORD(v139) = v69 - 41;
      unsigned int v138 = v139 >> 1;
      if (v138 > 6 || ((1 << v138) & 0x47) == 0) {
        goto LABEL_208;
      }
      unsigned int v140 = v69 - 28;
      int v141 = 1;
LABEL_205:
      if (v140 != 17 || (*(unsigned char *)(a2 + 17) & 2) == 0) {
        goto LABEL_207;
      }
      int v152 = *(_DWORD *)(a2 + 20);
      if ((v152 & 0x40000000) != 0)
      {
        uint64_t v169 = *(llvm ***)(a2 - 8);
        int v154 = *v169;
        if (!*v169) {
          goto LABEL_207;
        }
        v308[0] = *v169;
        BOOL v153 = *(llvm ***)(a2 - 8);
      }
      else
      {
        BOOL v153 = (llvm **)(a2 - 32 * (v152 & 0x7FFFFFF));
        int v154 = *v153;
        if (!*v153) {
          goto LABEL_207;
        }
        v308[0] = *v153;
      }
      uint64_t v170 = v153[4];
      if (!v170 || *((unsigned char *)v170 + 16) != 16)
      {
LABEL_207:
        if (v141) {
          goto LABEL_208;
        }
LABEL_247:
        if (v69 != 5) {
          goto LABEL_269;
        }
        unsigned int v140 = *(unsigned __int16 *)(a2 + 18);
        HIDWORD(v175) = v140 - 13;
        LODWORD(v175) = v140 - 13;
        unsigned int v142 = v175 >> 1;
        goto LABEL_249;
      }
      char v171 = (void **)((char *)v170 + 24);
      uint64_t v172 = *((unsigned int *)v170 + 8);
      if (v172 >= 0x41)
      {
        int v301 = v141;
        uint64_t v302 = *v171;
        uint64_t v173 = (uint64_t *)(*v171)[(v172 - 1) >> 6];
        int v300 = v172 - 64;
        uint64_t v299 = 1 << (v172 - 1);
        int v280 = v173 & v299;
        if (((unint64_t)v173 & v299) != 0)
        {
          int v298 = llvm::APInt::countLeadingOnesSlowCase((llvm *)((char *)v170 + 24));
          int v141 = v301;
          if ((v300 - v298) < 0xFFFFFFBF) {
            goto LABEL_246;
          }
          uint64_t v288 = *v302;
          if (*v302 == 0x8000000000000000) {
            goto LABEL_246;
          }
        }
        else
        {
          int64_t v281 = (unint64_t)(v172 + 63) >> 6;
          uint64_t v282 = v281;
          do
          {
            char v56 = v282-- < 1;
            if (v56) {
              break;
            }
            unint64_t v283 = v302[v282];
            v280 += __clz(v283);
          }
          while (!v283);
          if ((v172 & 0x3F) != 0) {
            int v284 = v172 | 0xFFFFFFC0;
          }
          else {
            int v284 = 0;
          }
          char v56 = (v300 - v280 - v284 != -66) & __CFADD__(v300 - v280 - v284, 66);
          int v141 = v301;
          if (v56 && *v302 == 0x8000000000000000) {
            goto LABEL_246;
          }
          int v285 = 0;
          do
          {
            char v56 = v281-- < 1;
            if (v56) {
              break;
            }
            unint64_t v286 = v302[v281];
            v285 += __clz(v286);
          }
          while (!v286);
          BOOL v287 = __CFADD__(v300 - (v284 + v285), 65);
          int v141 = v301;
          if (!v287) {
            goto LABEL_246;
          }
          uint64_t v288 = *v302;
        }
        if (v288 == 0x7FFFFFFFFFFFFFFFLL) {
          goto LABEL_246;
        }
        uint64_t v174 = v299;
      }
      else
      {
        uint64_t v173 = *v171;
        if ((unint64_t)(((uint64_t)((void)*v171 << -(char)v172) >> -(char)v172) - 0x7FFFFFFFFFFFFFFFLL) < 2) {
          goto LABEL_246;
        }
        uint64_t v174 = 1 << (v172 - 1);
      }
      if ((v174 & (unint64_t)v173) == 0)
      {
        sub_1CCD26730(a1, v154, a3, 0, a5);
        unsigned int v203 = *((_DWORD *)v170 + 8);
        if (v203 > 0x40) {
          uint64_t v204 = **v171;
        }
        else {
          uint64_t v204 = (uint64_t)((void)*v171 << -(char)v203) >> -(char)v203;
        }
        uint64_t v210 = *(void *)a1;
        if (v204 >= 0) {
          uint64_t v211 = v204;
        }
        else {
          uint64_t v211 = -v204;
        }
        if (v210 < 0) {
          uint64_t v210 = -v210;
        }
        uint64_t v212 = v210 * v211;
        if ((*(void *)a1 ^ v204) < 0) {
          uint64_t v212 = -v212;
        }
        *(void *)a1 = v212;
        uint64_t v213 = *(unsigned int *)(a1 + 16);
        if (v213)
        {
          v214 = *(uint64_t **)(a1 + 8);
          uint64_t v215 = 24 * v213;
          do
          {
            uint64_t v216 = *v214;
            if (*v214 < 0) {
              uint64_t v216 = -v216;
            }
            uint64_t v217 = v216 * v211;
            if ((*v214 ^ v204) < 0) {
              uint64_t v217 = -v217;
            }
            uint64_t *v214 = v217;
            v214 += 3;
            v215 -= 24;
          }
          while (v215);
        }
        goto LABEL_417;
      }
LABEL_246:
      if (v141)
      {
LABEL_208:
        HIDWORD(v147) = v69 - 41;
        LODWORD(v147) = v69 - 41;
        unsigned int v146 = v147 >> 1;
        if (v146 > 6 || ((1 << v146) & 0x47) == 0) {
          goto LABEL_258;
        }
        unsigned int v140 = v69 - 28;
        int v148 = 1;
        goto LABEL_254;
      }
      goto LABEL_247;
    }
    if (v69 != 5) {
      goto LABEL_269;
    }
LABEL_200:
    unsigned int v140 = *(unsigned __int16 *)(a2 + 18);
    HIDWORD(v143) = v140 - 13;
    LODWORD(v143) = v140 - 13;
    unsigned int v142 = v143 >> 1;
    int v144 = (1 << (v143 >> 1)) & 0x47;
    if (v142 > 6 || v144 == 0)
    {
LABEL_249:
      if (v142 > 6 || ((1 << v142) & 0x47) == 0) {
        goto LABEL_263;
      }
      int v148 = 0;
LABEL_254:
      if (v140 != 15 || (*(unsigned char *)(a2 + 17) & 2) == 0) {
        goto LABEL_256;
      }
      int v182 = *(_DWORD *)(a2 + 20);
      if ((v182 & 0x40000000) != 0)
      {
        BOOL v192 = *(unint64_t **)(a2 - 8);
        unint64_t v184 = *v192;
        if (!*v192) {
          goto LABEL_256;
        }
        v325.n128_u64[0] = *v192;
        unsigned int v183 = *(unint64_t **)(a2 - 8);
      }
      else
      {
        unsigned int v183 = (unint64_t *)(a2 - 32 * (v182 & 0x7FFFFFF));
        unint64_t v184 = *v183;
        if (!*v183) {
          goto LABEL_256;
        }
        v325.n128_u64[0] = *v183;
      }
      unint64_t v193 = v183[4];
      if (!v193 || *(unsigned char *)(v193 + 16) != 16) {
        goto LABEL_256;
      }
      uint64_t v194 = (llvm::APInt *)(v193 + 24);
      uint64_t v195 = *(unsigned int *)(v193 + 32);
      if (v195 >= 0x41)
      {
        unsigned int v289 = *(uint64_t **)v194;
        int v290 = v195 - 64;
        if ((*(void *)(*(void *)v194 + 8 * ((v195 - 1) >> 6)) >> (v195 - 1)))
        {
          if (v290 - llvm::APInt::countLeadingOnesSlowCase(v194) < 0xFFFFFFBF) {
            goto LABEL_256;
          }
          uint64_t v196 = *v289;
          if (*v289 == 0x8000000000000000) {
            goto LABEL_256;
          }
        }
        else
        {
          int v291 = 0;
          int64_t v292 = (unint64_t)(v195 + 63) >> 6;
          uint64_t v293 = v292;
          do
          {
            char v56 = v293-- < 1;
            if (v56) {
              break;
            }
            unint64_t v294 = v289[v293];
            v291 += __clz(v294);
          }
          while (!v294);
          if ((v195 & 0x3F) != 0) {
            int v295 = v195 | 0xFFFFFFC0;
          }
          else {
            int v295 = 0;
          }
          if ((v290 - v291 - v295) > 0xFFFFFFBE && *v289 == 0x8000000000000000) {
            goto LABEL_256;
          }
          int v296 = 0;
          do
          {
            char v56 = v292-- < 1;
            if (v56) {
              break;
            }
            unint64_t v297 = v289[v292];
            v296 += __clz(v297);
          }
          while (!v297);
          if ((v290 - (v295 + v296)) < 0xFFFFFFBF) {
            goto LABEL_256;
          }
          uint64_t v196 = *v289;
        }
        if (v196 != 0x7FFFFFFFFFFFFFFFLL) {
          goto LABEL_290;
        }
      }
      else
      {
        uint64_t v196 = (uint64_t)(*(void *)v194 << -(char)v195) >> -(char)v195;
        if ((unint64_t)(v196 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
        {
LABEL_290:
          *(void *)(a1 + 24) = 1;
          *(void *)a1 = -v196;
          *(void *)(a1 + 8) = a1 + 24;
          *(void *)(a1 + 32) = v184;
          goto LABEL_66;
        }
      }
LABEL_256:
      if (v148)
      {
        HIDWORD(v177) = v69 - 41;
        LODWORD(v177) = v69 - 41;
        unsigned int v146 = v177 >> 1;
LABEL_258:
        if (v146 > 6 || ((1 << v146) & 0x47) == 0) {
          goto LABEL_269;
        }
        unsigned int v140 = v69 - 28;
LABEL_267:
        if (v140 != 15 || (*(unsigned char *)(a2 + 17) & 2) == 0) {
          goto LABEL_269;
        }
        int v185 = *(_DWORD *)(a2 + 20);
        if ((v185 & 0x40000000) != 0)
        {
          unint64_t v187 = **(void **)(a2 - 8);
          if (v187)
          {
            v325.n128_u64[0] = **(void **)(a2 - 8);
            uint64_t v186 = *(unint64_t **)(a2 - 8);
LABEL_293:
            BOOL v197 = (llvm *)v186[4];
            if (v197)
            {
              *(void *)(a1 + 24) = 1;
              v308[0] = v197;
              *(void *)a1 = 0;
              *(void *)(a1 + 8) = a1 + 24;
              *(void *)(a1 + 32) = v187;
              *(unsigned char *)(a1 + 40) = 0;
              *(void *)(a1 + 48) = -1;
              *(void *)(a1 + 56) = v197;
              *(unsigned char *)(a1 + 64) = 0;
              uint64_t v181 = 0x300000002;
              goto LABEL_416;
            }
          }
        }
        else
        {
          uint64_t v186 = (unint64_t *)(a2 - 32 * (v185 & 0x7FFFFFF));
          unint64_t v187 = *v186;
          if (*v186)
          {
            v325.n128_u64[0] = *v186;
            goto LABEL_293;
          }
        }
LABEL_269:
        *(void *)(a1 + 24) = 1;
        *(void *)a1 = 0;
        *(void *)(a1 + 8) = a1 + 24;
        *(void *)(a1 + 32) = a2;
LABEL_270:
        *(unsigned char *)(a1 + 40) = v18;
        goto LABEL_271;
      }
      if (v69 != 5) {
        goto LABEL_269;
      }
      unsigned int v140 = *(unsigned __int16 *)(a2 + 18);
      HIDWORD(v178) = v140 - 13;
      LODWORD(v178) = v140 - 13;
      unsigned int v142 = v178 >> 1;
LABEL_263:
      char v56 = v142 > 6;
      int v179 = (1 << v142) & 0x47;
      if (v56) {
        BOOL v180 = 1;
      }
      else {
        BOOL v180 = v179 == 0;
      }
      if (v180) {
        goto LABEL_269;
      }
      goto LABEL_267;
    }
    int v141 = 0;
    goto LABEL_205;
  }
  if ((llvm::isKnownNonNegative((llvm *)v325.n128_u64[0], (const llvm::Value *)v314, 0, 0, 0, 0, (const llvm::DominatorTree *)1) & 1) == 0)
  {
    int v188 = llvm::ConstantInt::get(*(llvm::ConstantInt **)v325.n128_u64[0], 0, 0);
    sub_1CCD2855C(a3, 0x27u, v325.n128_u64[0], (uint64_t)v188);
  }
  if ((llvm::isKnownNonNegative(v308[0], (const llvm::Value *)v314, 0, 0, 0, 0, (const llvm::DominatorTree *)1) & 1) == 0)
  {
    uint64_t v189 = llvm::ConstantInt::get(*(llvm::ConstantInt **)v308[0], 0, 0);
    sub_1CCD2855C(a3, 0x27u, (unint64_t)v308[0], (uint64_t)v189);
  }
  uint64_t v190 = v308[0];
  sub_1CCD26730(a1, v325.n128_u64[0], a3, 0, a5);
  sub_1CCD26730(&v328, v190, a3, 0, a5);
  unsigned int v191 = (unsigned char *)v329;
  *(void *)a1 += v328;
  sub_1CCD286A0((unsigned int *)(a1 + 8), v191, &v191[24 * v330]);
  uint64_t v23 = (void *)v329;
LABEL_16:
  if (v23 != v331) {
LABEL_17:
  }
    free(v23);
LABEL_417:
  llvm::DataLayout::~DataLayout((llvm::DataLayout *)v314);
}

double sub_1CCD2855C(uint64_t a1, unsigned __int32 a2, unint64_t a3, uint64_t a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    v7.n128_u32[0] = a2;
    v7.n128_u64[1] = a3;
    uint64_t v8 = a4;
    *(void *)&double result = sub_1CBC0D590(a1, &v7).n128_u64[0];
  }
  else
  {
    uint64_t v5 = *(void *)a1 + 24 * v4;
    *(_DWORD *)uint64_t v5 = a2;
    *(void *)(v5 + 8) = a3;
    *(void *)(v5 + 16) = a4;
    *(_DWORD *)(a1 + 8) = v4 + 1;
  }
  return result;
}

uint64_t sub_1CCD285B4(void **a1, uint64_t a2)
{
  LODWORD(v2) = *(unsigned __int8 *)(a2 + 16);
  if (v2 < 0x1C)
  {
    if (v2 == 5)
    {
      LODWORD(v2) = *(unsigned __int16 *)(a2 + 18);
      HIDWORD(v9) = v2 - 13;
      LODWORD(v9) = v2 - 13;
      unsigned int v8 = v9 >> 1;
      BOOL v5 = v8 > 6;
      int v10 = (1 << v8) & 0x47;
      if (!v5 && v10 != 0) {
        goto LABEL_12;
      }
    }
LABEL_16:
    int v12 = 0;
    return v12 & v2;
  }
  HIDWORD(v4) = v2 - 41;
  LODWORD(v4) = v2 - 41;
  unsigned int v3 = v4 >> 1;
  BOOL v5 = v3 > 6;
  int v6 = (1 << v3) & 0x47;
  if (v5 || v6 == 0) {
    goto LABEL_16;
  }
  LODWORD(v2) = v2 - 28;
LABEL_12:
  if (v2 == 13 && (*(unsigned char *)(a2 + 17) & 4) != 0)
  {
    int v14 = *(_DWORD *)(a2 + 20);
    if ((v14 & 0x40000000) != 0) {
      uint64_t v15 = *(uint64_t **)(a2 - 8);
    }
    else {
      uint64_t v15 = (uint64_t *)(a2 - 32 * (v14 & 0x7FFFFFF));
    }
    uint64_t v2 = *v15;
    if (v2)
    {
      **a1 = v2;
      int v16 = *(_DWORD *)(a2 + 20);
      uint64_t v17 = (v16 & 0x40000000) != 0 ? *(void *)(a2 - 8) : a2 - 32 * (v16 & 0x7FFFFFF);
      uint64_t v2 = *(void *)(v17 + 32);
      if (v2)
      {
        *a1[1] = v2;
        int v12 = 1;
        LODWORD(v2) = 1;
        return v12 & v2;
      }
    }
  }
  else
  {
    LODWORD(v2) = 0;
  }
  int v12 = 1;
  return v12 & v2;
}

unsigned int *sub_1CCD286A0(unsigned int *result, unsigned char *__src, unsigned char *a3)
{
  unsigned int v3 = result;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a3 - __src) >> 3);
  uint64_t v5 = result[2];
  if (v4 + v5 > result[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (__src != a3)
  {
    double result = (unsigned int *)memcpy((void *)(*(void *)result + 24 * v5), __src, a3 - __src);
    LODWORD(v5) = v3[2];
  }
  v3[2] = v5 + v4;
  return result;
}

uint64_t sub_1CCD2873C(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = (const void *)(a2 + 16);
    unint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      __n128 v7 = (_DWORD *)(a2 + 8);
      unsigned int v8 = *(_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8) {
          memmove(*(void **)a1, v4, 24 * v8 - 7);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9) {
          memmove(*(void **)a1, v4, 24 * v9 - 7);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = *v7;
        if (v9 != v10) {
          memcpy((void *)(*(void *)a1 + 24 * v9), (const void *)(*(void *)a2 + 24 * v9), *(void *)a2 + 24 * v10 - (*(void *)a2 + 24 * v9));
        }
      }
      *(_DWORD *)(a1 + 8) = v8;
    }
    else
    {
      int v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        unint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      __n128 v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *__n128 v7 = 0;
  }
  return a1;
}

uint64_t sub_1CCD28870(void *a1)
{
  if (*a1 == a1[2]) {
    return 0;
  }
  else {
    return *a1;
  }
}

uint64_t sub_1CCD28884(uint64_t a1)
{
  if (*(void *)(a1 + 8) == *(void *)(a1 + 24)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 8);
  }
}

BOOL sub_1CCD28898(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[2];
  if (*a1 != v2) {
    *a1 = v1 + 24;
  }
  return v1 != v2;
}

BOOL sub_1CCD288BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  if (v1 != v2) {
    *(void *)(a1 + 8) = v1 + 24;
  }
  return v1 != v2;
}

unint64_t sub_1CCD288E0(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  v218[6] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    unint64_t v10 = result;
    uint64_t v196 = **(llvm::LLVMContext ***)a6;
    unsigned int v200 = 128;
    int v11 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    v199[0] = v11;
    v199[1] = 0;
    uint64_t v206 = 2;
    int v207 = 0;
    uint64_t v208 = -4096;
    v209[0] = 0;
    uint64_t v205 = &unk_1F2615EC8;
    do
    {
      int v14 = &v11[v12];
      uint64_t v15 = v206;
      uint64_t v16 = v208;
      *(void *)&v11[v12 + 8] = v206 & 6;
      *((void *)v14 + 2) = 0;
      *((void *)v14 + 3) = v16;
      if (v16 != -4096 && v16 != -8192 && v16 != 0)
      {
        *((void *)v14 + 2) = *(void *)(v15 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v15 & 0xFFFFFFFFFFFFFFF8) = &v11[v12 + 8];
        *((void *)v14 + 1) = v15 & 0xFFFFFFFFFFFFFFFELL;
        char v18 = (void *)*((void *)v14 + 2);
        if (v18) {
          void *v18 = &v11[v12 + 16 + (*v18 & 7)];
        }
        uint64_t v13 = v209[0];
      }
      *(void *)int v14 = &unk_1F2615EC8;
      *((void *)v14 + 4) = v13;
      v12 += 64;
    }
    while (v12 != 0x2000);
    if (v208 != -8192 && v208 != -4096 && v208 != 0)
    {
      unint64_t v185 = v206 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v206 & 0xFFFFFFFFFFFFFFF8) = v207;
      if (v207)
      {
        *(void *)int v207 = *(void *)v207 & 7 | v185;
      }
      else
      {
        uint64_t v186 = v208;
        unint64_t v187 = ***(int32x2_t ****)v208;
        unint64_t v188 = (unint64_t)v187[303];
        if (v188 <= v185)
        {
          uint64_t v189 = v187[305].u32[0];
          if (v188 + 16 * v189 > v185)
          {
            unsigned int v190 = v189 - 1;
            LODWORD(v191) = v190 & ((v208 >> 4) ^ (v208 >> 9));
            BOOL v192 = (uint64_t *)(v188 + 16 * v191);
            uint64_t v193 = *v192;
            if (v208 != *v192)
            {
              int v194 = 1;
              do
              {
                if (v193 == -4096) {
                  goto LABEL_246;
                }
                int v195 = v191 + v194++;
                uint64_t v191 = v195 & v190;
                uint64_t v193 = *(void *)(v188 + 16 * v191);
              }
              while (v208 != v193);
              BOOL v192 = (uint64_t *)(v188 + 16 * v191);
            }
            *BOOL v192 = -8192;
            v187[304] = vadd_s32(v187[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v186 = v208;
LABEL_246:
            *(unsigned char *)(v186 + 17) &= ~1u;
          }
        }
      }
    }
    LOBYTE(v201[0]) = 0;
    char v202 = 0;
    uint64_t v216 = v218;
    uint64_t v217 = 0x600000000;
    uint64_t v20 = a2 + 48 * a3;
    if (a3)
    {
      uint64_t v21 = a2 + 16;
      do
      {
        uint64_t v23 = v21 - 16;
        uint64_t v22 = *(void **)(v21 - 16);
        LOBYTE(v206) = *(unsigned char *)(v21 - 8);
        uint64_t v205 = v22;
        int v207 = v209;
        uint64_t v208 = 0x200000000;
        if (*(_DWORD *)(v21 + 8))
        {
          sub_1CBB08064((uint64_t)&v207, v21);
          if (v207 != v209) {
            free(v207);
          }
        }
        v21 += 48;
      }
      while (v23 + 48 != v20);
    }
    uint64_t v213 = v215;
    uint64_t v214 = 0x400000000;
    int v24 = *(_DWORD *)(a6 + 20);
    if ((v24 & 0x40000000) != 0)
    {
      unsigned int v26 = *(char **)(a6 - 8);
      uint64_t v25 = v24 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v25 = v24 & 0x7FFFFFF;
      unsigned int v26 = (char *)(a6 - 32 * v25);
    }
    sub_1CBF74A6C((uint64_t)&v213, (uint64_t)v215, v26, &v26[32 * v25]);
    int v27 = v214;
    if (!v214)
    {
LABEL_132:
      uint64_t v210 = v212;
      uint64_t v211 = 0x600000000;
      if (v217)
      {
        unsigned int v98 = 0;
        uint64_t v99 = (void **)v216;
        uint64_t v100 = 8 * v217;
        do
        {
          if (v98 >= HIDWORD(v211)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v210 + v98) = **v99;
          unsigned int v98 = v211 + 1;
          LODWORD(v211) = v211 + 1;
          ++v99;
          v100 -= 8;
        }
        while (v100);
        int v101 = v210;
      }
      else
      {
        unsigned int v98 = 0;
        int v101 = v212;
      }
      int v102 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)(*(void *)v196 + 1888), (uint64_t)v101, v98, 0);
      unsigned int v103 = *(uint64_t ****)(*(void *)(a4 + 40) + 56);
      unint64_t v104 = v103[5];
      uint64_t v107 = v104[21];
      unint64_t v106 = v104 + 21;
      uint64_t v105 = v107;
      char v108 = *((unsigned char *)v106 + 23);
      int v109 = v108;
      if (v108 >= 0) {
        uint64_t v105 = v106;
      }
      uint64_t v110 = v106[1];
      unsigned int v111 = (uint64_t *)(v108 & 0x7F);
      if (v109 >= 0) {
        uint64_t v110 = v111;
      }
      if ((*((unsigned char *)v103 + 23) & 0x10) != 0)
      {
        uint64_t v112 = ***v103;
        uint64_t v113 = *(void *)(v112 + 152);
        uint64_t v114 = *(unsigned int *)(v112 + 168);
        if (v114)
        {
          LODWORD(v115) = (v114 - 1) & ((v103 >> 4) ^ (v103 >> 9));
          unint64_t v116 = (uint64_t ****)(v113 + 16 * v115);
          unint64_t v117 = *v116;
          if (*v116 != v103)
          {
            int v118 = 1;
            do
            {
              if (v117 == (uint64_t ***)-4096) {
                goto LABEL_150;
              }
              int v119 = v115 + v118++;
              uint64_t v115 = v119 & (v114 - 1);
              unint64_t v117 = *(uint64_t ****)(v113 + 16 * v115);
            }
            while (v117 != v103);
            unint64_t v116 = (uint64_t ****)(v113 + 16 * v115);
          }
        }
        else
        {
LABEL_150:
          unint64_t v116 = (uint64_t ****)(v113 + 16 * v114);
        }
        uint64_t v120 = v116[1];
        unint64_t v123 = *v120;
        unsigned int v121 = (char *)(v120 + 2);
        char v122 = v123;
      }
      else
      {
        char v122 = 0;
        unsigned int v121 = &byte_1CFBCE98E;
      }
      v203[0] = v105;
      v203[1] = v110;
      v203[2] = v121;
      v203[3] = v122;
      __int16 v204 = 1285;
      uint64_t v205 = v203;
      int v207 = "repro";
      LOWORD(v209[0]) = 770;
      uint64_t v124 = (unint64_t *)operator new(0x80uLL);
      *((_DWORD *)v124 + 7) = *((_DWORD *)v124 + 7) & 0x38000000 | 0x40000000;
      unint64_t *v124 = 0;
      uint64_t v198 = (llvm::Function *)(v124 + 1);
      llvm::Function::Function(v124 + 1, v102, 0, (llvm::Type *)0xFFFFFFFFLL, (const char **)&v205, v10);
      if (v217)
      {
        unint64_t v125 = 0;
        do
        {
          if (*((_WORD *)v124 + 13)) {
            llvm::Function::BuildLazyArguments(v198);
          }
          unint64_t v126 = v124[12];
          unint64_t v127 = (uint64_t ***)v216[v125];
          if ((*((unsigned char *)v127 + 23) & 0x10) != 0)
          {
            uint64_t v128 = ***v127;
            uint64_t v129 = *(void *)(v128 + 152);
            uint64_t v130 = *(unsigned int *)(v128 + 168);
            if (v130)
            {
              LODWORD(v131) = (v130 - 1) & ((v127 >> 4) ^ (v127 >> 9));
              uint64_t v132 = (uint64_t ****)(v129 + 16 * v131);
              unsigned int v133 = *v132;
              if (*v132 != v127)
              {
                int v134 = 1;
                do
                {
                  if (v133 == (uint64_t ***)-4096) {
                    goto LABEL_163;
                  }
                  int v135 = v131 + v134++;
                  uint64_t v131 = v135 & (v130 - 1);
                  unsigned int v133 = *(uint64_t ****)(v129 + 16 * v131);
                }
                while (v133 != v127);
                uint64_t v132 = (uint64_t ****)(v129 + 16 * v131);
              }
            }
            else
            {
LABEL_163:
              uint64_t v132 = (uint64_t ****)(v129 + 16 * v130);
            }
            unsigned int v136 = v132[1];
            uint64_t v139 = (uint64_t)*v136;
            unsigned int v138 = (char *)(v136 + 2);
            uint64_t v137 = v139;
          }
          else
          {
            uint64_t v137 = 0;
            unsigned int v138 = &byte_1CFBCE98E;
          }
          LOWORD(v209[0]) = 261;
          unsigned int v140 = (llvm::Value *)(v126 + 40 * v125);
          uint64_t v205 = v138;
          uint64_t v206 = v137;
          llvm::Value::setNameImpl(v140, (const char **)&v205);
          if (v126 && !*((unsigned char *)v140 + 16))
          {
            if ((*((unsigned char *)v140 + 23) & 0x10) == 0) {
              goto LABEL_185;
            }
            uint64_t v141 = ***(void ***)v140;
            uint64_t v142 = *(void *)(v141 + 152);
            uint64_t v143 = *(unsigned int *)(v141 + 168);
            if (v143)
            {
              LODWORD(v144) = (v143 - 1) & ((v140 >> 4) ^ (v140 >> 9));
              char v145 = (llvm::Value **)(v142 + 16 * v144);
              unsigned int v146 = *v145;
              if (*v145 != v140)
              {
                int v147 = 1;
                do
                {
                  if (v146 == (llvm::Value *)-4096) {
                    goto LABEL_177;
                  }
                  int v148 = v144 + v147++;
                  uint64_t v144 = v148 & (v143 - 1);
                  unsigned int v146 = *(llvm::Value **)(v142 + 16 * v144);
                }
                while (v146 != v140);
                char v145 = (llvm::Value **)(v142 + 16 * v144);
              }
            }
            else
            {
LABEL_177:
              char v145 = (llvm::Value **)(v142 + 16 * v143);
            }
            int v149 = v145[1];
            unint64_t v152 = *(void *)v149;
            uint64_t v150 = (char *)v149 + 16;
            unint64_t v151 = v152;
            if (v152 >= 5
              && (*(_DWORD *)v150 == *(_DWORD *)"llvm." ? (BOOL v153 = v150[4] == aLlvm_1[4]) : (BOOL v153 = 0), v153))
            {
              *((_DWORD *)v140 + 8) |= 0x2000u;
              int v154 = llvm::Function::lookupIntrinsicID(v150, v151);
            }
            else
            {
LABEL_185:
              int v154 = 0;
              *((_DWORD *)v140 + 8) &= ~0x2000u;
            }
            *((_DWORD *)v140 + 9) = v154;
          }
          ++v125;
        }
        while (v125 < v217);
      }
      sub_1CC7B6DC8((char *)v199);
      if (v202)
      {
        sub_1CC009394((uint64_t)v201);
        MEMORY[0x1D25D9CD0](v201[0], 8);
        char v202 = 0;
      }
      if (v217)
      {
        unint64_t v155 = 0;
        do
        {
          if (*((_WORD *)v124 + 13)) {
            llvm::Function::BuildLazyArguments(v198);
          }
          unint64_t v156 = v124[12];
          uint64_t v157 = v216[v155];
          uint64_t v206 = 2;
          int v207 = 0;
          uint64_t v208 = v157;
          if (v157 != -8192 && v157 != -4096 && v157 != 0) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v206);
          }
          uint64_t v205 = &unk_1F2615EC8;
          v209[0] = v199;
          uint64_t v159 = sub_1CC4CFF80((uint64_t)v199, &v205);
          if (v208 != -8192 && v208 != -4096 && v208)
          {
            unint64_t v160 = v206 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v206 & 0xFFFFFFFFFFFFFFF8) = v207;
            if (v207)
            {
              *(void *)int v207 = *(void *)v207 & 7 | v160;
            }
            else
            {
              uint64_t v161 = v208;
              uint64_t v162 = ***(int32x2_t ****)v208;
              unint64_t v163 = (unint64_t)v162[303];
              if (v163 <= v160)
              {
                uint64_t v164 = v162[305].u32[0];
                if (v163 + 16 * v164 > v160)
                {
                  unsigned int v165 = v164 - 1;
                  LODWORD(v166) = v165 & ((v208 >> 4) ^ (v208 >> 9));
                  uint64_t v167 = (uint64_t *)(v163 + 16 * v166);
                  uint64_t v168 = *v167;
                  if (v208 != *v167)
                  {
                    int v169 = 1;
                    do
                    {
                      if (v168 == -4096) {
                        goto LABEL_211;
                      }
                      int v170 = v166 + v169++;
                      uint64_t v166 = v170 & v165;
                      uint64_t v168 = *(void *)(v163 + 16 * v166);
                    }
                    while (v208 != v168);
                    uint64_t v167 = (uint64_t *)(v163 + 16 * v166);
                  }
                  uint64_t *v167 = -8192;
                  v162[304] = vadd_s32(v162[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v161 = v208;
LABEL_211:
                  *(unsigned char *)(v161 + 17) &= ~1u;
                }
              }
            }
          }
          unint64_t v171 = v156 + 40 * v155;
          uint64_t v172 = v159[7];
          if (v172 != v171)
          {
            if (v172 && v172 != -8192 && v172 != -4096)
            {
              unint64_t v173 = v159[5] & 0xFFFFFFFFFFFFFFF8;
              *(void *)unint64_t v173 = v159[6];
              uint64_t v174 = (unint64_t *)v159[6];
              if (v174)
              {
                unint64_t *v174 = *v174 & 7 | v173;
              }
              else
              {
                uint64_t v175 = v159[7];
                uint64_t v176 = ***(int32x2_t ****)v175;
                unint64_t v177 = (unint64_t)v176[303];
                if (v177 <= v173)
                {
                  uint64_t v178 = v176[305].u32[0];
                  if (v177 + 16 * v178 > v173)
                  {
                    unsigned int v179 = v178 - 1;
                    LODWORD(v180) = v179 & ((v175 >> 4) ^ (v175 >> 9));
                    uint64_t v181 = (uint64_t *)(v177 + 16 * v180);
                    uint64_t v182 = *v181;
                    if (v175 != *v181)
                    {
                      int v183 = 1;
                      do
                      {
                        if (v182 == -4096) {
                          goto LABEL_232;
                        }
                        int v184 = v180 + v183++;
                        uint64_t v180 = v184 & v179;
                        uint64_t v182 = *(void *)(v177 + 16 * v180);
                      }
                      while (v175 != v182);
                      uint64_t v181 = (uint64_t *)(v177 + 16 * v180);
                    }
                    *uint64_t v181 = -8192;
                    v176[304] = vadd_s32(v176[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v175 = v159[7];
LABEL_232:
                    *(unsigned char *)(v175 + 17) &= ~1u;
                  }
                }
              }
            }
            v159[7] = v171;
            if (v171 != -8192 && v171 != -4096)
            {
              if (v171) {
                llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v159 + 5));
              }
            }
          }
          ++v155;
        }
        while (v155 < v217);
      }
      uint64_t v205 = "entry";
      LOWORD(v209[0]) = 259;
      operator new();
    }
    while (1)
    {
      uint64_t v28 = *(void *)&v213[8 * v27 - 8];
      LODWORD(v214) = v27 - 1;
      unsigned int v29 = v28 >> 4;
      if (v200)
      {
        uint64_t v30 = (v29 ^ (v28 >> 9)) & (v200 - 1);
        uint64_t v31 = v199[0] + (v30 << 6);
        uint64_t v32 = *(void *)(v31 + 24);
        if (v28 == v32)
        {
LABEL_34:
          if (v31 != v199[0] + ((unint64_t)v200 << 6)) {
            goto LABEL_103;
          }
        }
        else
        {
          int v33 = 1;
          while (v32 != -4096)
          {
            int v34 = v30 + v33++;
            uint64_t v30 = v34 & (v200 - 1);
            uint64_t v31 = v199[0] + (v30 << 6);
            uint64_t v32 = *(void *)(v31 + 24);
            if (v28 == v32) {
              goto LABEL_34;
            }
          }
        }
      }
      unsigned int v35 = *(unsigned __int8 *)(v28 + 16);
      if (v35 >= 0x15)
      {
        if (v35 <= 0x1B) {
          uint64_t v36 = 0;
        }
        else {
          uint64_t v36 = v28;
        }
        uint64_t v37 = *a5;
        uint64_t v38 = *((unsigned int *)a5 + 4);
        if (v38)
        {
          LODWORD(v39) = (v38 - 1) & (v29 ^ (v28 >> 9));
          uint64_t v40 = (uint64_t *)(v37 + 16 * v39);
          uint64_t v41 = *v40;
          if (v28 != *v40)
          {
            int v42 = 1;
            do
            {
              if (v41 == -4096) {
                goto LABEL_47;
              }
              int v43 = v39 + v42++;
              uint64_t v39 = v43 & (v38 - 1);
              uint64_t v41 = *(void *)(v37 + 16 * v39);
            }
            while (v28 != v41);
            uint64_t v40 = (uint64_t *)(v37 + 16 * v39);
          }
          unint64_t v44 = (uint64_t *)(v37 + 16 * v38);
          if (!v36) {
            goto LABEL_66;
          }
        }
        else
        {
LABEL_47:
          unint64_t v44 = (uint64_t *)(v37 + 16 * v38);
          uint64_t v40 = v44;
          if (!v36)
          {
LABEL_66:
            uint64_t v206 = 2;
            int v207 = 0;
            uint64_t v208 = v28;
            if (v28 != -8192 && v28 != -4096 && v28) {
              llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v206);
            }
            uint64_t v205 = &unk_1F2615EC8;
            v209[0] = v199;
            unint64_t v57 = sub_1CC4CFF80((uint64_t)v199, &v205);
            if (v208 != -8192 && v208 != -4096 && v208)
            {
              unint64_t v58 = v206 & 0xFFFFFFFFFFFFFFF8;
              *(void *)(v206 & 0xFFFFFFFFFFFFFFF8) = v207;
              if (v207)
              {
                *(void *)int v207 = *(void *)v207 & 7 | v58;
              }
              else
              {
                uint64_t v59 = v208;
                int v60 = ***(int32x2_t ****)v208;
                unint64_t v61 = (unint64_t)v60[303];
                if (v61 <= v58)
                {
                  uint64_t v62 = v60[305].u32[0];
                  if (v61 + 16 * v62 > v58)
                  {
                    unsigned int v63 = v62 - 1;
                    LODWORD(v64) = v63 & ((v208 >> 4) ^ (v208 >> 9));
                    BOOL v65 = (uint64_t *)(v61 + 16 * v64);
                    uint64_t v66 = *v65;
                    if (v208 != *v65)
                    {
                      int v67 = 1;
                      do
                      {
                        if (v66 == -4096) {
                          goto LABEL_82;
                        }
                        int v68 = v64 + v67++;
                        uint64_t v64 = v68 & v63;
                        uint64_t v66 = *(void *)(v61 + 16 * v64);
                      }
                      while (v208 != v66);
                      BOOL v65 = (uint64_t *)(v61 + 16 * v64);
                    }
                    uint64_t *v65 = -8192;
                    v60[304] = vadd_s32(v60[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v59 = v208;
LABEL_82:
                    *(unsigned char *)(v59 + 17) &= ~1u;
                  }
                }
              }
            }
            uint64_t v69 = v57[7];
            if (v69 != v28)
            {
              if (v69 && v69 != -8192 && v69 != -4096)
              {
                unint64_t v74 = v57[5] & 0xFFFFFFFFFFFFFFF8;
                *(void *)unint64_t v74 = v57[6];
                uint64_t v75 = (unint64_t *)v57[6];
                if (v75)
                {
                  unint64_t *v75 = *v75 & 7 | v74;
                }
                else
                {
                  uint64_t v76 = v57[7];
                  uint64_t v77 = ***(int32x2_t ****)v76;
                  unint64_t v78 = (unint64_t)v77[303];
                  if (v78 <= v74)
                  {
                    uint64_t v79 = v77[305].u32[0];
                    if (v78 + 16 * v79 > v74)
                    {
                      unsigned int v80 = v79 - 1;
                      LODWORD(v81) = v80 & ((v76 >> 4) ^ (v76 >> 9));
                      unsigned int v82 = (uint64_t *)(v78 + 16 * v81);
                      uint64_t v83 = *v82;
                      if (v76 != *v82)
                      {
                        int v84 = 1;
                        do
                        {
                          if (v83 == -4096) {
                            goto LABEL_116;
                          }
                          int v85 = v81 + v84++;
                          uint64_t v81 = v85 & v80;
                          uint64_t v83 = *(void *)(v78 + 16 * v81);
                        }
                        while (v76 != v83);
                        unsigned int v82 = (uint64_t *)(v78 + 16 * v81);
                      }
                      uint64_t *v82 = -8192;
                      v77[304] = vadd_s32(v77[304], (int32x2_t)0x1FFFFFFFFLL);
                      uint64_t v76 = v57[7];
LABEL_116:
                      *(unsigned char *)(v76 + 17) &= ~1u;
                    }
                  }
                }
              }
              v57[7] = v28;
              if (v28 != -8192 && v28 != -4096 && v28) {
                llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v57 + 5));
              }
            }
            if (v217 >= (unint64_t)HIDWORD(v217)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v216[v217] = v28;
            LODWORD(v217) = v217 + 1;
            goto LABEL_103;
          }
        }
        if (v40 == v44)
        {
          uint64_t v206 = 2;
          int v207 = 0;
          uint64_t v208 = v28;
          if (v28 != -8192 && v28 != -4096 && v28) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v206);
          }
          uint64_t v205 = &unk_1F2615EC8;
          v209[0] = v199;
          unint64_t v45 = sub_1CC4CFF80((uint64_t)v199, &v205);
          if (v208 != -8192 && v208 != -4096 && v208)
          {
            unint64_t v46 = v206 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v206 & 0xFFFFFFFFFFFFFFF8) = v207;
            if (v207)
            {
              *(void *)int v207 = *(void *)v207 & 7 | v46;
            }
            else
            {
              uint64_t v47 = v208;
              uint64_t v48 = ***(int32x2_t ****)v208;
              unint64_t v49 = (unint64_t)v48[303];
              if (v49 <= v46)
              {
                uint64_t v50 = v48[305].u32[0];
                if (v49 + 16 * v50 > v46)
                {
                  unsigned int v51 = v50 - 1;
                  LODWORD(v52) = v51 & ((v208 >> 4) ^ (v208 >> 9));
                  BOOL v53 = (uint64_t *)(v49 + 16 * v52);
                  uint64_t v54 = *v53;
                  if (v208 != *v53)
                  {
                    int v55 = 1;
                    do
                    {
                      if (v54 == -4096) {
                        goto LABEL_65;
                      }
                      int v56 = v52 + v55++;
                      uint64_t v52 = v56 & v51;
                      uint64_t v54 = *(void *)(v49 + 16 * v52);
                    }
                    while (v208 != v54);
                    BOOL v53 = (uint64_t *)(v49 + 16 * v52);
                  }
                  uint64_t *v53 = -8192;
                  v48[304] = vadd_s32(v48[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v47 = v208;
LABEL_65:
                  *(unsigned char *)(v47 + 17) &= ~1u;
                }
              }
            }
          }
          uint64_t v70 = v45[7];
          if (v70 != v28)
          {
            if (v70 && v70 != -8192 && v70 != -4096)
            {
              unint64_t v86 = v45[5] & 0xFFFFFFFFFFFFFFF8;
              *(void *)unint64_t v86 = v45[6];
              int v87 = (unint64_t *)v45[6];
              if (v87)
              {
                unint64_t *v87 = *v87 & 7 | v86;
              }
              else
              {
                uint64_t v88 = v45[7];
                uint64_t v89 = ***(int32x2_t ****)v88;
                unint64_t v90 = (unint64_t)v89[303];
                if (v90 <= v86)
                {
                  uint64_t v91 = v89[305].u32[0];
                  if (v90 + 16 * v91 > v86)
                  {
                    unsigned int v92 = v91 - 1;
                    LODWORD(v93) = v92 & ((v88 >> 4) ^ (v88 >> 9));
                    uint64_t v94 = (uint64_t *)(v90 + 16 * v93);
                    uint64_t v95 = *v94;
                    if (v88 != *v94)
                    {
                      int v96 = 1;
                      do
                      {
                        if (v95 == -4096) {
                          goto LABEL_128;
                        }
                        int v97 = v93 + v96++;
                        uint64_t v93 = v97 & v92;
                        uint64_t v95 = *(void *)(v90 + 16 * v93);
                      }
                      while (v88 != v95);
                      uint64_t v94 = (uint64_t *)(v90 + 16 * v93);
                    }
                    uint64_t *v94 = -8192;
                    v89[304] = vadd_s32(v89[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v88 = v45[7];
LABEL_128:
                    *(unsigned char *)(v88 + 17) &= ~1u;
                  }
                }
              }
            }
            v45[7] = v28;
            if (v28 != -8192 && v28 != -4096 && v28) {
              llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v45 + 5));
            }
          }
          int v71 = *(_DWORD *)(v36 + 20);
          if ((v71 & 0x40000000) != 0)
          {
            uint64_t v73 = *(char **)(v36 - 8);
            uint64_t v72 = v71 & 0x7FFFFFF;
          }
          else
          {
            uint64_t v72 = v71 & 0x7FFFFFF;
            uint64_t v73 = (char *)(v36 - 32 * v72);
          }
          sub_1CBF74A6C((uint64_t)&v213, (uint64_t)&v213[8 * v214], v73, &v73[32 * v72]);
          goto LABEL_103;
        }
        goto LABEL_66;
      }
LABEL_103:
      int v27 = v214;
      if (!v214) {
        goto LABEL_132;
      }
    }
  }
  return result;
}

BOOL sub_1CCD2AD30(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  return *(unsigned char *)(v2 + 16) != 84
      || (uint64_t v3 = *(void *)(v2 - 32)) == 0
      || *(unsigned char *)(v3 + 16)
      || *(void *)(v3 + 24) != *(void *)(v2 + 72)
      || (*(unsigned char *)(v3 + 33) & 0x20) == 0
      || *(_DWORD *)(v3 + 36) != 7;
}

void sub_1CCD2AD80(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a1;
    uint64_t v7 = 48 * v2;
    do
    {
      uint64_t v8 = a2 + v5;
      uint64_t v9 = v6 + v5;
      uint64_t v10 = *(void *)(v6 + v5);
      *(unsigned char *)(v8 + 8) = *(unsigned char *)(v6 + v5 + 8);
      *(void *)uint64_t v8 = v10;
      int v11 = (void *)(a2 + v5 + 32);
      *(void *)(a2 + v5 + 16) = v11;
      *(void *)(v8 + 24) = 0x200000000;
      unsigned int v12 = *(_DWORD *)(v6 + v5 + 24);
      if (v12) {
        BOOL v13 = v9 == v8;
      }
      else {
        BOOL v13 = 1;
      }
      if (!v13)
      {
        int v14 = *(const void **)(v9 + 16);
        if ((const void *)(v9 + 32) == v14)
        {
          if (v12 >= 3) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v11, v14, 8 * *(unsigned int *)(v6 + v5 + 24));
          *(_DWORD *)(v8 + 24) = v12;
        }
        else
        {
          *(void *)(v8 + 16) = v14;
          int v15 = *(_DWORD *)(v6 + v5 + 28);
          *(_DWORD *)(v8 + 24) = v12;
          *(_DWORD *)(v8 + 28) = v15;
          *(void *)(v9 + 16) = v9 + 32;
          *(_DWORD *)(v6 + v5 + 28) = 0;
        }
        *(_DWORD *)(v9 + 24) = 0;
      }
      v5 += 48;
    }
    while (v7 != v5);
    uint64_t v16 = *((unsigned int *)a1 + 2);
    if (v16)
    {
      uint64_t v17 = *a1;
      uint64_t v18 = 48 * v16;
      do
      {
        unsigned int v19 = *(void **)(v17 + v18 - 32);
        if ((void *)(v17 + v18 - 16) != v19) {
          free(v19);
        }
        v18 -= 48;
      }
      while (v18);
    }
  }
}

void sub_1CCD2AEE0()
{
}

void sub_1CCD2AF20(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD2AF58(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::ScalarEvolutionWrapperPass::ID);
}

void sub_1CCD2B03C(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t v9 = *(uint64_t **)(a1 + 8);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_9:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::LoopInfoWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::LoopInfoWrapperPass::ID);
  int v14 = *(uint64_t **)(a1 + 8);
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_14:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_14;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  (*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::OptimizationRemarkEmitterWrapperPass::ID);
  uint64_t v18 = *(uint64_t **)(a1 + 8);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  if (v19 == v20)
  {
LABEL_19:
    uint64_t v21 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v19 != &llvm::ScalarEvolutionWrapperPass::ID)
    {
      v19 += 16;
      if (v19 == v20) {
        goto LABEL_19;
      }
    }
    uint64_t v21 = *(void *)(v19 + 8);
  }
  uint64_t v22 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v21 + 96))(v21, &llvm::ScalarEvolutionWrapperPass::ID)+ 32);

  sub_1CCD1E314(a2, v8 + 32, v13 + 32, v22);
}

uint64_t sub_1CCD2B248()
{
  dword_1EBCF0C3C = sub_1CBF64200((llvm::DebugCounter *)"conds-eliminated", 0x10uLL, "Controls which conditions are eliminated", 0x28uLL);
  char v3 = 0;
  unint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Dump IR to reproduce successful transformations.";
  v1.n128_u64[1] = 48;
  sub_1CBA9E5B0((llvm::cl::Option *)&qword_1EBCF0C40[1], "constraint-elimination-dump-repros", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF0C40[1], &dword_1CB82C000);
}

void sub_1CCD2B2F4(llvm *a1)
{
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeLazyValueInfoWrapperPassPass(a1, v2);
  operator new();
}

uint64_t sub_1CCD2B39C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0DC8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D778;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF0DD0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD2B2F4;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCF0DD0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t getDomain(llvm::ConstantInt **a1, llvm::LazyValueInfo *a2, llvm::Instruction *a3)
{
  uint64_t v6 = (llvm::Constant *)llvm::ConstantInt::get(*a1, 0, 0);
  if (llvm::LazyValueInfo::getPredicateAt(a2, 39, (llvm::Value *)a1, v6, a3, 1) == 1) {
    return 0;
  }
  uint64_t v7 = (llvm::Constant *)llvm::ConstantInt::get(*a1, 0, 0);
  if (llvm::LazyValueInfo::getPredicateAt(a2, 41, (llvm::Value *)a1, v7, a3, 1) == 1) {
    return 1;
  }
  else {
    return 2;
  }
}

void llvm::CorrelatedValuePropagationPass::run()
{
}

uint64_t sub_1CCD2B67C(uint64_t a1, llvm::LazyValueInfo *a2, llvm::DominatorTree *a3, uint64_t a4)
{
  uint64_t v730 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5) {
    uint64_t v6 = (void *)(v5 - 24);
  }
  else {
    uint64_t v6 = 0;
  }
  p_p_src = v6;
  sub_1CCADB4C0((uint64_t *)&p_p_src, (uint64_t)&v673);
  uint64_t v7 = v669;
  v664 = v669;
  uint64_t v8 = v674;
  v657 = a2;
  if (v674 == v673)
  {
    v665 = v669;
    uint64_t v9 = v674;
  }
  else
  {
    int v643 = v675;
    uint64_t v7 = malloc_type_malloc(8 * v675, 0x4065EBACuLL);
    if (!v7)
    {
LABEL_1143:
      if (v643) {
        goto LABEL_1148;
      }
      uint64_t v7 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      a2 = v657;
      if (!v7) {
        goto LABEL_1148;
      }
    }
    v665 = v7;
    uint64_t v9 = v673;
    uint64_t v8 = v674;
  }
  unsigned int v10 = v676;
  unsigned int v666 = v675;
  if (v8 == v9) {
    unsigned int v11 = v676;
  }
  else {
    unsigned int v11 = v675;
  }
  if (v11)
  {
    memmove(v7, v8, 8 * v11);
    unsigned int v10 = v676;
  }
  unsigned int v667 = v10;
  int v668 = v677;
  v671 = 0;
  uint64_t v672 = 0;
  long long __p = 0;
  sub_1CBFE1720(&__p, v678, v679, (v679 - (unsigned char *)v678) >> 5);
  uint64_t v12 = v660;
  uint64_t v13 = v681;
  if (v681 != v680)
  {
    unsigned int v650 = v682;
    uint64_t v12 = malloc_type_malloc(8 * v682, 0x4065EBACuLL);
    if (v12 || !v650 && (uint64_t v12 = malloc_type_malloc(1uLL, 0x4065EBACuLL), a2 = v657, v12))
    {
      v659 = v12;
      int v14 = v680;
      uint64_t v13 = v681;
      goto LABEL_13;
    }
LABEL_1148:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  v659 = v660;
  int v14 = v681;
LABEL_13:
  if (v13 == v14) {
    unsigned int v15 = v683;
  }
  else {
    unsigned int v15 = v682;
  }
  if (v15) {
    memmove(v12, v13, 8 * v15);
  }
  v662 = 0;
  uint64_t v663 = 0;
  v661 = 0;
  sub_1CBFE1720(&v661, v684, v685, (v685 - (unsigned char *)v684) >> 5);
  int v21 = 0;
  while (1)
  {
    if (v671 - (unsigned char *)__p != v662 - v661) {
      goto LABEL_33;
    }
    if (__p == v671) {
      break;
    }
    uint64_t v22 = v661 + 16;
    uint64_t v23 = (char *)__p + 16;
    while (1)
    {
      int v24 = v23 - 16;
      if (*((void *)v23 - 2) != *((void *)v22 - 2)) {
        break;
      }
      int v25 = v22[8];
      if (v23[8]) {
        BOOL v26 = v25 == 0;
      }
      else {
        BOOL v26 = 1;
      }
      if (v26)
      {
        if ((v23[8] == 0) == (v25 != 0)) {
          break;
        }
      }
      else if (*(_DWORD *)v23 != *(_DWORD *)v22)
      {
        break;
      }
      v22 += 32;
      v23 += 32;
      if (v24 + 32 == v671) {
        goto LABEL_1121;
      }
    }
LABEL_33:
    int v653 = v21;
    uint64_t v27 = *((void *)v671 - 4);
    uint64_t v28 = (void *)(v27 + 40);
    unsigned int v29 = *(void **)(v27 + 48);
    if (v29 != (void *)(v27 + 40))
    {
      int v30 = 0;
      v658 = (void *)(v27 + 40);
      while (2)
      {
        uint64_t v31 = (void *)v29[1];
        if (v29) {
          uint64_t v32 = (llvm::Instruction *)(v29 - 3);
        }
        else {
          uint64_t v32 = 0;
        }
        int v33 = *((unsigned __int8 *)v32 + 16);
        switch(*((unsigned char *)v32 + 16))
        {
          case ')':
          case '+':
          case '-':
          case '5':
            int v34 = sub_1CCD30964(v32, a2);
            goto LABEL_55;
          case '*':
          case ',':
          case '.':
          case '1':
          case '4':
          case '6':
          case '9':
          case ':':
          case ';':
          case '>':
          case '?':
          case '@':
          case 'A':
          case 'B':
          case 'C':
          case 'E':
          case 'F':
          case 'G':
          case 'H':
          case 'I':
          case 'J':
          case 'K':
          case 'L':
          case 'M':
          case 'N':
          case 'O':
          case 'P':
            goto LABEL_660;
          case '/':
          case '2':
            int v34 = sub_1CCD30204(v32, a2);
LABEL_55:
            v30 |= v34;
            goto LABEL_660;
          case '0':
          case '3':
            if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) != 0x12)
            {
              if (v33 != 48) {
                goto LABEL_347;
              }
              int v120 = *((_DWORD *)v32 + 5);
              if ((v120 & 0x40000000) == 0)
              {
                int v121 = v30;
                uint64_t v122 = v120 & 0x7FFFFFF;
                unint64_t v123 = (llvm::SwitchInstProfUpdateWrapper **)((char *)v32 - 32 * v122);
                if (!v122) {
                  goto LABEL_275;
                }
LABEL_271:
                uint64_t v188 = 0;
                uint64_t v189 = 32 * v122 - 32;
                while (1)
                {
                  unsigned int v190 = *v123;
                  (&Successor)[v188] = (const char **)*v123;
                  Domaiuint64_t n = getDomain((llvm::ConstantInt **)v190, a2, v32);
                  LODWORD((&Successor)[v188 + 1]) = Domain;
                  if (Domain == 2) {
                    break;
                  }
                  if (v188 != 2)
                  {
                    v123 += 4;
                    uint64_t v192 = v189;
                    v189 -= 32;
                    v188 += 2;
                    if (v192) {
                      continue;
                    }
                  }
                  goto LABEL_275;
                }
                int v33 = *((unsigned __int8 *)v32 + 16);
                int v30 = v121;
                uint64_t v28 = v658;
LABEL_347:
                if (v33 != 51 || (*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12) {
                  goto LABEL_459;
                }
                int v242 = *((_DWORD *)v32 + 5);
                if ((v242 & 0x40000000) == 0)
                {
                  int v243 = v30;
                  uint64_t v244 = v242 & 0x7FFFFFF;
                  uint64_t v245 = (llvm::SwitchInstProfUpdateWrapper **)((char *)v32 - 32 * v244);
                  if (!v244) {
                    goto LABEL_384;
                  }
LABEL_380:
                  uint64_t v265 = 0;
                  uint64_t v266 = 32 * v244 - 32;
                  while (1)
                  {
                    unint64_t v267 = *v245;
                    (&Successor)[v265] = (const char **)*v245;
                    int v268 = getDomain((llvm::ConstantInt **)v267, a2, v32);
                    LODWORD((&Successor)[v265 + 1]) = v268;
                    if (v268 == 2) {
                      break;
                    }
                    if (v265 != 2)
                    {
                      v245 += 4;
                      uint64_t v269 = v266;
                      v266 -= 32;
                      v265 += 2;
                      if (v269) {
                        continue;
                      }
                    }
                    goto LABEL_384;
                  }
                  int v30 = v243;
                  uint64_t v28 = v658;
LABEL_459:
                  int v655 = v30;
                  unint64_t v326 = *(unsigned int *)(*(void *)v32 + 8);
                  if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12)
                  {
                    BOOL v46 = 0;
LABEL_461:
                    int v30 = v655;
                    goto LABEL_599;
                  }
                  LOBYTE(Successor) = 0;
                  LOBYTE(v695[0]) = 0;
                  v696[0] = 0;
                  v699[0] = 0;
                  int v327 = *((_DWORD *)v32 + 5);
                  if ((v327 & 0x40000000) != 0)
                  {
                    uint64_t v329 = (llvm::Value **)*((void *)v32 - 1);
                    uint64_t v328 = v327 & 0x7FFFFFF;
                    if (v328) {
                      goto LABEL_464;
                    }
                  }
                  else
                  {
                    uint64_t v328 = v327 & 0x7FFFFFF;
                    uint64_t v329 = (llvm::Value **)((char *)v32 - 32 * v328);
                    if (v328)
                    {
LABEL_464:
                      unint64_t v330 = 0;
                      unsigned int v331 = 0;
                      uint64_t v332 = 32 * v328 - 32;
                      do
                      {
                        uint64_t v333 = &(&Successor)[v330 / 8];
                        llvm::LazyValueInfo::getConstantRange(a2, *v329, v32, 1, (unint64_t *)&p_p_src);
                        if (LOBYTE(v695[v330 / 2]))
                        {
                          if (*((_DWORD *)v333 + 2) >= 0x41u && *v333) {
                            MEMORY[0x1D25D9CB0](*v333, 0x1000C8000313F17);
                          }
                          unint64_t v334 = &(&Successor)[v330 / 8];
                          (&Successor)[v330 / 8] = (const char **)p_p_src;
                          *((_DWORD *)v333 + 2) = v701;
                          LODWORD(v701) = 0;
                          if (v694[v330 / 4] >= 0x41u && (v336 = v334[2]) != 0)
                          {
                            MEMORY[0x1D25D9CB0](v336, 0x1000C8000313F17);
                            unsigned int v337 = v701;
                            v334[2] = (const char **)v702;
                            *((_DWORD *)v334 + 6) = v703;
                            unsigned int v703 = 0;
                            if (v337 >= 0x41 && p_p_src) {
                              MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
                            }
                          }
                          else
                          {
                            v334[2] = (const char **)v702;
                            *((_DWORD *)v334 + 6) = v703;
                          }
                        }
                        else
                        {
                          *((_DWORD *)v333 + 2) = v701;
                          void *v333 = (const char **)p_p_src;
                          LODWORD(v701) = 0;
                          *((_DWORD *)v333 + 6) = v703;
                          v333[2] = (const char **)v702;
                          *((unsigned char *)v333 + 32) = 1;
                        }
                        unsigned int MinSignedBits = llvm::ConstantRange::getMinSignedBits((const void **)&(&Successor)[v330 / 8]);
                        if (MinSignedBits > v331) {
                          unsigned int v331 = MinSignedBits;
                        }
                        if (!v332) {
                          break;
                        }
                        v329 += 4;
                        v332 -= 32;
                        BOOL v26 = v330 == 40;
                        v330 += 40;
                      }
                      while (!v26);
                      goto LABEL_484;
                    }
                  }
                  unsigned int v331 = 0;
LABEL_484:
                  unint64_t v338 = v326 >> 8;
                  LODWORD(v701) = v326 >> 8;
                  if (v326 >> 8 > 0x40) {
                    operator new[]();
                  }
                  unsigned int v339 = (void *)(0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v326) + 63));
                  if (v326 <= 0xFF) {
                    unsigned int v339 = 0;
                  }
                  p_p_src = v339;
                  uint64_t v28 = v658;
                  if (llvm::ConstantRange::contains((llvm::ConstantRange *)v696, (const llvm::APInt *)&p_p_src))
                  {
                    LODWORD(v688) = v331;
                    if (v331 > 0x40) {
                      operator new[]();
                    }
                    __src = (void *)(1 << (v331 - 1));
                    if (v688 < v338)
                    {
                      llvm::APInt::sext((uint64_t)&__src, v326 >> 8, (uint64_t)&p_src);
                      unsigned int v365 = v726;
                      BOOL v340 = llvm::ConstantRange::contains((llvm::ConstantRange *)&Successor, (const llvm::APInt *)&p_src);
                      if (v365 >= 0x41 && p_src) {
                        MEMORY[0x1D25D9CB0](p_src, 0x1000C8000313F17);
                      }
                    }
                    else
                    {
                      LODWORD(v726) = v688;
                      if (v688 > 0x40) {
                        operator new[]();
                      }
                      p_src = (char *)__src;
                      BOOL v340 = llvm::ConstantRange::contains((llvm::ConstantRange *)&Successor, (const llvm::APInt *)&p_src);
                    }
                    if (v688 >= 0x41 && __src) {
                      MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
                    }
                  }
                  else
                  {
                    BOOL v340 = 0;
                  }
                  if (v701 >= 0x41 && p_p_src) {
                    MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
                  }
                  unint64_t v341 = v340 + v331;
                  if (v340 + v331)
                  {
                    unint64_t v342 = (v341 - 1) | ((v341 - 1) >> 1) | (((v341 - 1) | ((v341 - 1) >> 1)) >> 2);
                    unint64_t v341 = v342 | (v342 >> 4) | ((v342 | (v342 >> 4)) >> 8);
                    LODWORD(v341) = ((v341 >> 16) | v341) + 1;
                  }
                  if (v341 <= 8) {
                    uint64_t v343 = 8;
                  }
                  else {
                    uint64_t v343 = v341;
                  }
                  BOOL v46 = v343 < v338;
                  if (v343 < v338)
                  {
                    v439 = 0;
                    uint64_t v440 = **(void **)v32;
                    p_p_src = &v702;
                    uint64_t v701 = 0x200000000;
                    uint64_t v707 = v440;
                    v708 = &v716;
                    v709 = v717;
                    uint64_t v710 = 0;
                    int v711 = 0;
                    __int16 v712 = 512;
                    char v713 = 7;
                    v705 = 0;
                    v706 = 0;
                    uint64_t v714 = 0;
                    uint64_t v715 = 0;
                    v716 = &unk_1F2616E88;
                    v717[0] = &unk_1F2617008;
                    v705 = (void **)*((void *)v32 + 5);
                    v706 = (void ***)((char *)v32 + 24);
                    v441 = (void **)*((void *)v32 + 6);
                    __src = v441;
                    if (v441)
                    {
                      llvm::MetadataTracking::track((uint64_t)&__src, (unsigned __int8 *)v441, 2);
                      v439 = __src;
                    }
                    sub_1CB8461A4((uint64_t)&p_p_src, 0, (uint64_t)v439);
                    if (!__src)
                    {
LABEL_643:
                      v443 = (llvm::Type ***)llvm::IntegerType::get(**(llvm::IntegerType ***)v32, (llvm::LLVMContext *)v343);
                      v444 = (llvm::CastInst *)*((void *)v32 - 8);
                      if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                      {
                        uint64_t v445 = ***(void ***)v32;
                        uint64_t v446 = *(void *)(v445 + 152);
                        uint64_t v447 = *(unsigned int *)(v445 + 168);
                        if (v447)
                        {
                          LODWORD(v448) = (v447 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                          v449 = (llvm::Instruction **)(v446 + 16 * v448);
                          v450 = *v449;
                          if (*v449 != v32)
                          {
                            int v451 = 1;
                            do
                            {
                              if (v450 == (llvm::Instruction *)-4096) {
                                goto LABEL_751;
                              }
                              int v452 = v448 + v451++;
                              uint64_t v448 = v452 & (v447 - 1);
                              v450 = *(llvm::Instruction **)(v446 + 16 * v448);
                            }
                            while (v450 != v32);
                            v449 = (llvm::Instruction **)(v446 + 16 * v448);
                          }
                        }
                        else
                        {
LABEL_751:
                          v449 = (llvm::Instruction **)(v446 + 16 * v447);
                        }
                        v493 = v449[1];
                        v496 = *(void **)v493;
                        v495 = (char *)v493 + 16;
                        v494 = v496;
                      }
                      else
                      {
                        v494 = 0;
                        v495 = &byte_1CFBCE98E;
                      }
                      __int16 v729 = 773;
                      p_src = (char *)v495;
                      v726 = v494;
                      v727 = ".lhs.trunc";
                      v498 = sub_1CD5AB4EC((uint64_t)&p_p_src, v444, v443, (uint64_t)&p_src, v442);
                      v499 = (llvm::CastInst *)*((void *)v32 - 4);
                      if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                      {
                        uint64_t v500 = ***(void ***)v32;
                        uint64_t v501 = *(void *)(v500 + 152);
                        uint64_t v502 = *(unsigned int *)(v500 + 168);
                        if (v502)
                        {
                          LODWORD(v503) = (v502 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                          v504 = (llvm::Instruction **)(v501 + 16 * v503);
                          v505 = *v504;
                          if (*v504 != v32)
                          {
                            int v506 = 1;
                            do
                            {
                              if (v505 == (llvm::Instruction *)-4096) {
                                goto LABEL_760;
                              }
                              int v507 = v503 + v506++;
                              uint64_t v503 = v507 & (v502 - 1);
                              v505 = *(llvm::Instruction **)(v501 + 16 * v503);
                            }
                            while (v505 != v32);
                            v504 = (llvm::Instruction **)(v501 + 16 * v503);
                          }
                        }
                        else
                        {
LABEL_760:
                          v504 = (llvm::Instruction **)(v501 + 16 * v502);
                        }
                        v508 = v504[1];
                        v511 = *(void **)v508;
                        v510 = (char *)v508 + 16;
                        v509 = v511;
                      }
                      else
                      {
                        v509 = 0;
                        v510 = &byte_1CFBCE98E;
                      }
                      __int16 v729 = 773;
                      p_src = (char *)v510;
                      v726 = v509;
                      v727 = ".rhs.trunc";
                      v512 = sub_1CD5AB4EC((uint64_t)&p_p_src, v499, v443, (uint64_t)&p_src, v497);
                      int v513 = *((unsigned __int8 *)v32 + 16);
                      if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                      {
                        uint64_t v514 = ***(void ***)v32;
                        uint64_t v515 = *(void *)(v514 + 152);
                        uint64_t v516 = *(unsigned int *)(v514 + 168);
                        if (v516)
                        {
                          LODWORD(v517) = (v516 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                          v518 = (llvm::Instruction **)(v515 + 16 * v517);
                          v519 = *v518;
                          if (*v518 != v32)
                          {
                            int v520 = 1;
                            do
                            {
                              if (v519 == (llvm::Instruction *)-4096) {
                                goto LABEL_769;
                              }
                              int v521 = v517 + v520++;
                              uint64_t v517 = v521 & (v516 - 1);
                              v519 = *(llvm::Instruction **)(v515 + 16 * v517);
                            }
                            while (v519 != v32);
                            v518 = (llvm::Instruction **)(v515 + 16 * v517);
                          }
                        }
                        else
                        {
LABEL_769:
                          v518 = (llvm::Instruction **)(v515 + 16 * v516);
                        }
                        v522 = v518[1];
                        v525 = *(void **)v522;
                        v524 = (char *)v522 + 16;
                        v523 = v525;
                      }
                      else
                      {
                        v523 = 0;
                        v524 = &byte_1CFBCE98E;
                      }
                      __int16 v729 = 261;
                      p_src = (char *)v524;
                      v726 = v523;
                      v526 = sub_1CB844E98((uint64_t)&p_p_src, (v513 - 28), (uint64_t)v498, (uint64_t)v512, (uint64_t)&p_src, 0);
                      v527 = v526;
                      v528 = *(llvm::IntegerType ***)v32;
                      if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                      {
                        uint64_t v529 = *(void *)*v528;
                        uint64_t v530 = *(void *)(v529 + 152);
                        uint64_t v531 = *(unsigned int *)(v529 + 168);
                        if (v531)
                        {
                          LODWORD(v532) = (v531 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                          v533 = (llvm::Instruction **)(v530 + 16 * v532);
                          v534 = *v533;
                          if (*v533 != v32)
                          {
                            int v535 = 1;
                            do
                            {
                              if (v534 == (llvm::Instruction *)-4096) {
                                goto LABEL_778;
                              }
                              int v536 = v532 + v535++;
                              uint64_t v532 = v536 & (v531 - 1);
                              v534 = *(llvm::Instruction **)(v530 + 16 * v532);
                            }
                            while (v534 != v32);
                            v533 = (llvm::Instruction **)(v530 + 16 * v532);
                          }
                        }
                        else
                        {
LABEL_778:
                          v533 = (llvm::Instruction **)(v530 + 16 * v531);
                        }
                        v537 = v533[1];
                        uint64_t v540 = *(void *)v537;
                        v539 = (char *)v537 + 16;
                        uint64_t v538 = v540;
                      }
                      else
                      {
                        uint64_t v538 = 0;
                        v539 = &byte_1CFBCE98E;
                      }
                      __int16 v690 = 773;
                      __src = v539;
                      uint64_t v688 = v538;
                      v689 = ".sext";
                      v541 = (unsigned __int8 *)v526;
                      if (*(llvm::IntegerType ***)v526 != v528)
                      {
                        if (*((unsigned __int8 *)v526 + 16) <= 0x14u)
                        {
                          v541 = (unsigned __int8 *)(*((uint64_t (**)(void **, uint64_t, llvm::Instruction *, llvm::IntegerType **))*v708
                                                     + 28))(v708, 40, v526, v528);
                          if (v541) {
                            BOOL v544 = v541[16] >= 0x1Cu;
                          }
                          else {
                            BOOL v544 = 0;
                          }
                          if (v544)
                          {
                            (*(void (**)(void *, unsigned __int8 *, void **, void **, void ***))(*v709 + 16))(v709, v541, &__src, v705, v706);
                            if (v701)
                            {
                              v591 = (llvm::MDNode **)p_p_src;
                              v592 = (llvm::MDNode **)((char *)p_p_src + 16 * v701);
                              do
                              {
                                llvm::Instruction::setMetadata((llvm::Instruction *)v541, *(_DWORD *)v591, v591[1]);
                                v591 += 2;
                              }
                              while (v591 != v592);
                            }
                          }
                        }
                        else
                        {
                          __int16 v729 = 257;
                          v541 = (unsigned __int8 *)llvm::CastInst::Create(40, (uint64_t)v526, (uint64_t)v528, (const char **)&p_src, 0);
                          (*(void (**)(void *, unsigned __int8 *, void **, void **, void ***))(*v709 + 16))(v709, v541, &__src, v705, v706);
                          if (v701)
                          {
                            v542 = (llvm::MDNode **)p_p_src;
                            v543 = (llvm::MDNode **)((char *)p_p_src + 16 * v701);
                            do
                            {
                              llvm::Instruction::setMetadata((llvm::Instruction *)v541, *(_DWORD *)v542, v542[1]);
                              v542 += 2;
                            }
                            while (v542 != v543);
                          }
                        }
                      }
                      if (*((unsigned char *)v527 + 16) == 48) {
                        *((unsigned char *)v527 + 17) = *((unsigned char *)v527 + 17) & 0xFD | *((unsigned char *)v32 + 17) & 2;
                      }
                      llvm::Value::doRAUW(v32, (llvm::Value *)v541, (llvm::Value *)1);
                      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                    }
                    int v557 = *(unsigned __int8 *)__src;
                    if ((v557 - 4) > 0x1E)
                    {
                      if ((v557 - 3) >= 0xFFFFFFFE) {
                        v561 = __src;
                      }
                      else {
                        v561 = 0;
                      }
                      if ((v557 - 3) < 0xFFFFFFFE)
                      {
                        if (v557 == 3) {
                          *((void *)__src + 1) = 0;
                        }
                        goto LABEL_643;
                      }
                      unint64_t v559 = (unint64_t)v561 + 8;
                    }
                    else
                    {
                      if ((*((unsigned char *)__src + 1) & 0x7F) != 2 && !*((_DWORD *)__src + 3)) {
                        goto LABEL_643;
                      }
                      uint64_t v558 = *((void *)__src + 2);
                      if ((v558 & 4) == 0) {
                        goto LABEL_643;
                      }
                      unint64_t v559 = v558 & 0xFFFFFFFFFFFFFFF8;
                      if (!v559) {
                        goto LABEL_643;
                      }
                    }
                    p_src = (char *)&__src;
                    sub_1CC5FA668(v559 + 16, &p_src);
                    goto LABEL_643;
                  }
                  for (uint64_t i = 0; i != -10; i -= 5)
                  {
                    uint64_t v345 = &(&Successor)[i];
                    if (v699[i * 8])
                    {
                      if (*((_DWORD *)v345 + 16) >= 0x41u)
                      {
                        uint64_t v346 = *(void *)&v697[i * 8];
                        if (v346) {
                          MEMORY[0x1D25D9CB0](v346, 0x1000C8000313F17);
                        }
                      }
                      if (*(_DWORD *)&v696[i * 8 + 8] >= 0x41u)
                      {
                        uint64_t v347 = v345[5];
                        if (v347) {
                          MEMORY[0x1D25D9CB0](v347, 0x1000C8000313F17);
                        }
                      }
                      *((unsigned char *)v345 + 72) = 0;
                    }
                  }
                  goto LABEL_461;
                }
                int v243 = v30;
                uint64_t v245 = (llvm::SwitchInstProfUpdateWrapper **)*((void *)v32 - 1);
                uint64_t v244 = v242 & 0x7FFFFFF;
                if (v244) {
                  goto LABEL_380;
                }
LABEL_384:
                uint64_t v270 = 0;
                v271 = (llvm::SwitchInstProfUpdateWrapper **)&Successor;
                while (2)
                {
                  if (LODWORD((&Successor)[2 * v270 + 1]))
                  {
                    int v272 = *v271;
                    if ((*((unsigned char *)*v271 + 23) & 0x10) != 0)
                    {
                      uint64_t v273 = ***(void ***)v272;
                      uint64_t v274 = *(void *)(v273 + 152);
                      uint64_t v275 = *(unsigned int *)(v273 + 168);
                      if (v275)
                      {
                        LODWORD(v276) = (v275 - 1) & ((v272 >> 4) ^ (v272 >> 9));
                        int v277 = (llvm::BinaryOperator **)(v274 + 16 * v276);
                        int v278 = *v277;
                        if (*v277 != v272)
                        {
                          int v279 = 1;
                          do
                          {
                            if (v278 == (llvm::BinaryOperator *)-4096) {
                              goto LABEL_393;
                            }
                            int v280 = v276 + v279++;
                            uint64_t v276 = v280 & (v275 - 1);
                            int v278 = *(llvm::BinaryOperator **)(v274 + 16 * v276);
                          }
                          while (v278 != v272);
                          int v277 = (llvm::BinaryOperator **)(v274 + 16 * v276);
                        }
                      }
                      else
                      {
LABEL_393:
                        int v277 = (llvm::BinaryOperator **)(v274 + 16 * v275);
                      }
                      int64_t v281 = v277[1];
                      uint64_t v284 = *(void *)v281;
                      unint64_t v283 = (char *)v281 + 16;
                      uint64_t v282 = v284;
                    }
                    else
                    {
                      uint64_t v282 = 0;
                      unint64_t v283 = &byte_1CFBCE98E;
                    }
                    __int16 v704 = 773;
                    p_p_src = v283;
                    uint64_t v701 = v282;
                    v702 = ".nonneg";
                    Neg = llvm::BinaryOperator::CreateNeg(v272, (llvm::Value *)&p_p_src, v32, (llvm::Instruction *)v17);
                    unint64_t v286 = (char *)*((void *)v32 + 6);
                    p_src = v286;
                    if (v286) {
                      llvm::MetadataTracking::track((uint64_t)&p_src, (unsigned __int8 *)v286, 2);
                    }
                    BOOL v287 = (char **)((char *)Neg + 48);
                    if (&p_src == (char **)((char *)Neg + 48))
                    {
                      if (!p_src) {
                        goto LABEL_401;
                      }
                      int v295 = *p_src;
                      if ((v295 - 4) > 0x1E)
                      {
                        if ((v295 - 3) >= 0xFFFFFFFE) {
                          int v298 = p_src;
                        }
                        else {
                          int v298 = 0;
                        }
                        if ((v295 - 3) < 0xFFFFFFFE)
                        {
                          if (v295 == 3) {
                            *((void *)p_src + 1) = 0;
                          }
                          goto LABEL_401;
                        }
                        unint64_t v297 = (unint64_t)(v298 + 8);
                      }
                      else
                      {
                        if ((p_src[1] & 0x7F) != 2 && !*((_DWORD *)p_src + 3)) {
                          goto LABEL_401;
                        }
                        uint64_t v296 = *((void *)p_src + 2);
                        if ((v296 & 4) == 0) {
                          goto LABEL_401;
                        }
                        unint64_t v297 = v296 & 0xFFFFFFFFFFFFFFF8;
                        if (!v297) {
                          goto LABEL_401;
                        }
                      }
                      p_p_src = &p_src;
                      sub_1CC5FA668(v297 + 16, &p_p_src);
                      goto LABEL_401;
                    }
                    uint64_t v288 = *v287;
                    if (!*v287) {
                      goto LABEL_399;
                    }
                    int v291 = *v288;
                    if ((v291 - 4) <= 0x1E)
                    {
                      if ((v288[1] & 0x7F) != 2 && !*((_DWORD *)v288 + 3)) {
                        goto LABEL_399;
                      }
                      uint64_t v292 = *((void *)v288 + 2);
                      if ((v292 & 4) == 0) {
                        goto LABEL_399;
                      }
                      unint64_t v293 = v292 & 0xFFFFFFFFFFFFFFF8;
                      if (!v293) {
                        goto LABEL_399;
                      }
                      goto LABEL_416;
                    }
                    if ((v291 - 3) >= 0xFFFFFFFE) {
                      unint64_t v294 = *v287;
                    }
                    else {
                      unint64_t v294 = 0;
                    }
                    if ((v291 - 3) >= 0xFFFFFFFE)
                    {
                      unint64_t v293 = (unint64_t)(v294 + 8);
LABEL_416:
                      p_p_src = (char *)Neg + 48;
                      sub_1CC5FA668(v293 + 16, &p_p_src);
                      goto LABEL_399;
                    }
                    if (v291 == 3) {
                      *((void *)v288 + 1) = 0;
                    }
LABEL_399:
                    unsigned int v289 = (unsigned __int8 *)p_src;
                    *BOOL v287 = p_src;
                    if (v289)
                    {
                      llvm::MetadataTracking::retrack((uint64_t)&p_src, v289, (uint64_t)Neg + 48);
                      p_src = 0;
                    }
LABEL_401:
                    uint64_t *v271 = Neg;
                  }
                  uint64_t v290 = v270 + 1;
                  v271 = (llvm::SwitchInstProfUpdateWrapper **)&(&Successor)[2 * v270 + 2];
                  uint64_t v270 = 1;
                  if (v290 == 2)
                  {
                    if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                    {
                      uint64_t v299 = ***(void ***)v32;
                      uint64_t v300 = *(void *)(v299 + 152);
                      uint64_t v301 = *(unsigned int *)(v299 + 168);
                      if (v301)
                      {
                        LODWORD(v302) = (v301 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                        v303 = (llvm::Instruction **)(v300 + 16 * v302);
                        uint64_t v304 = *v303;
                        if (*v303 != v32)
                        {
                          int v305 = 1;
                          do
                          {
                            if (v304 == (llvm::Instruction *)-4096) {
                              goto LABEL_579;
                            }
                            int v306 = v302 + v305++;
                            uint64_t v302 = v306 & (v301 - 1);
                            uint64_t v304 = *(llvm::Instruction **)(v300 + 16 * v302);
                          }
                          while (v304 != v32);
                          v303 = (llvm::Instruction **)(v300 + 16 * v302);
                        }
                      }
                      else
                      {
LABEL_579:
                        v303 = (llvm::Instruction **)(v300 + 16 * v301);
                      }
                      v390 = v303[1];
                      uint64_t v393 = *(void *)v390;
                      unint64_t v392 = (char *)v390 + 16;
                      uint64_t v391 = v393;
                    }
                    else
                    {
                      uint64_t v391 = 0;
                      unint64_t v392 = &byte_1CFBCE98E;
                    }
                    __int16 v704 = 261;
                    p_p_src = v392;
                    uint64_t v701 = v391;
                    uint64_t v312 = llvm::BinaryOperator::Create(22, Successor, v693, (const char **)&p_p_src, (uint64_t)v32);
                    int v394 = (void **)*((void *)v32 + 6);
                    __src = v394;
                    if (v394) {
                      llvm::MetadataTracking::track((uint64_t)&__src, (unsigned __int8 *)v394, 2);
                    }
                    v395 = (void **)((char *)v312 + 48);
                    if (&__src != (void **)((char *)v312 + 48))
                    {
                      v396 = (unsigned __int8 *)*v395;
                      if (!*v395) {
                        goto LABEL_585;
                      }
                      int v459 = *v396;
                      if ((v459 - 4) <= 0x1E)
                      {
                        if ((v396[1] & 0x7F) != 2 && !*((_DWORD *)v396 + 3)) {
                          goto LABEL_585;
                        }
                        uint64_t v460 = *((void *)v396 + 2);
                        if ((v460 & 4) == 0) {
                          goto LABEL_585;
                        }
                        unint64_t v461 = v460 & 0xFFFFFFFFFFFFFFF8;
                        if (!v461) {
                          goto LABEL_585;
                        }
                        goto LABEL_807;
                      }
                      if ((v459 - 3) >= 0xFFFFFFFE) {
                        v546 = *v395;
                      }
                      else {
                        v546 = 0;
                      }
                      if ((v459 - 3) >= 0xFFFFFFFE)
                      {
                        unint64_t v461 = (unint64_t)v546 + 8;
LABEL_807:
                        p_p_src = (char *)v312 + 48;
                        sub_1CC5FA668(v461 + 16, &p_p_src);
                        goto LABEL_585;
                      }
                      if (v459 == 3) {
                        *((void *)v396 + 1) = 0;
                      }
LABEL_585:
                      int v397 = (unsigned __int8 *)__src;
                      *v395 = __src;
                      if (v397)
                      {
                        llvm::MetadataTracking::retrack((uint64_t)&__src, v397, (uint64_t)v312 + 48);
                        __src = 0;
                      }
LABEL_587:
                      uint64_t v317 = v312;
                      if (v692 == 1)
                      {
                        if ((*((unsigned char *)v312 + 23) & 0x10) == 0) {
                          goto LABEL_686;
                        }
                        uint64_t v398 = ***(void ***)v312;
                        uint64_t v319 = *(void *)(v398 + 152);
                        uint64_t v320 = *(unsigned int *)(v398 + 168);
                        if (!v320) {
                          goto LABEL_595;
                        }
                        LODWORD(v321) = (v320 - 1) & ((v312 >> 4) ^ (v312 >> 9));
                        uint64_t v322 = (llvm::Value **)(v319 + 16 * v321);
                        unint64_t v399 = *v322;
                        if (*v322 != v312)
                        {
                          int v400 = 1;
                          do
                          {
                            if (v399 == (llvm::Value *)-4096) {
                              goto LABEL_595;
                            }
                            int v401 = v321 + v400++;
                            uint64_t v321 = v401 & (v320 - 1);
                            unint64_t v399 = *(llvm::Value **)(v319 + 16 * v321);
                          }
                          while (v399 != v312);
LABEL_594:
                          uint64_t v322 = (llvm::Value **)(v319 + 16 * v321);
                        }
LABEL_596:
                        v402 = v322[1];
                        uint64_t v405 = *(void *)v402;
                        uint64_t v404 = (char *)v402 + 16;
                        uint64_t v403 = v405;
LABEL_597:
                        __int16 v704 = 773;
                        p_p_src = v404;
                        uint64_t v701 = v403;
                        v702 = ".neg";
                        uint64_t v317 = llvm::BinaryOperator::CreateNeg(v312, (llvm::Value *)&p_p_src, v32, v311);
                      }
LABEL_598:
                      llvm::Value::doRAUW(v32, v317, (llvm::Value *)1);
                      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                    }
                    if (!__src) {
                      goto LABEL_587;
                    }
                    int v580 = *(unsigned __int8 *)__src;
                    if ((v580 - 4) > 0x1E)
                    {
                      if ((v580 - 3) >= 0xFFFFFFFE) {
                        v589 = __src;
                      }
                      else {
                        v589 = 0;
                      }
                      if ((v580 - 3) < 0xFFFFFFFE)
                      {
                        if (v580 == 3) {
                          *((void *)__src + 1) = 0;
                        }
                        goto LABEL_587;
                      }
                      unint64_t v582 = (unint64_t)v589 + 8;
                    }
                    else
                    {
                      if ((*((unsigned char *)__src + 1) & 0x7F) != 2 && !*((_DWORD *)__src + 3)) {
                        goto LABEL_587;
                      }
                      uint64_t v581 = *((void *)__src + 2);
                      if ((v581 & 4) == 0) {
                        goto LABEL_587;
                      }
                      unint64_t v582 = v581 & 0xFFFFFFFFFFFFFFF8;
                      if (!v582) {
                        goto LABEL_587;
                      }
                    }
                    p_p_src = &__src;
                    sub_1CC5FA668(v582 + 16, &p_p_src);
                    goto LABEL_587;
                  }
                  continue;
                }
              }
              int v121 = v30;
              unint64_t v123 = (llvm::SwitchInstProfUpdateWrapper **)*((void *)v32 - 1);
              uint64_t v122 = v120 & 0x7FFFFFF;
              if (v122) {
                goto LABEL_271;
              }
LABEL_275:
              uint64_t v193 = 0;
              int v194 = (llvm::SwitchInstProfUpdateWrapper **)&Successor;
              while (2)
              {
                if (LODWORD((&Successor)[2 * v193 + 1]))
                {
                  int v195 = *v194;
                  if ((*((unsigned char *)*v194 + 23) & 0x10) != 0)
                  {
                    uint64_t v196 = ***(void ***)v195;
                    uint64_t v197 = *(void *)(v196 + 152);
                    uint64_t v198 = *(unsigned int *)(v196 + 168);
                    if (v198)
                    {
                      LODWORD(v199) = (v198 - 1) & ((v195 >> 4) ^ (v195 >> 9));
                      unsigned int v200 = (llvm::BinaryOperator **)(v197 + 16 * v199);
                      uint64_t v201 = *v200;
                      if (*v200 != v195)
                      {
                        int v202 = 1;
                        do
                        {
                          if (v201 == (llvm::BinaryOperator *)-4096) {
                            goto LABEL_284;
                          }
                          int v203 = v199 + v202++;
                          uint64_t v199 = v203 & (v198 - 1);
                          uint64_t v201 = *(llvm::BinaryOperator **)(v197 + 16 * v199);
                        }
                        while (v201 != v195);
                        unsigned int v200 = (llvm::BinaryOperator **)(v197 + 16 * v199);
                      }
                    }
                    else
                    {
LABEL_284:
                      unsigned int v200 = (llvm::BinaryOperator **)(v197 + 16 * v198);
                    }
                    __int16 v204 = v200[1];
                    uint64_t v207 = *(void *)v204;
                    uint64_t v206 = (char *)v204 + 16;
                    uint64_t v205 = v207;
                  }
                  else
                  {
                    uint64_t v205 = 0;
                    uint64_t v206 = &byte_1CFBCE98E;
                  }
                  __int16 v704 = 773;
                  p_p_src = v206;
                  uint64_t v701 = v205;
                  v702 = ".nonneg";
                  uint64_t v208 = llvm::BinaryOperator::CreateNeg(v195, (llvm::Value *)&p_p_src, v32, (llvm::Instruction *)v17);
                  int v209 = (char *)*((void *)v32 + 6);
                  p_src = v209;
                  if (v209) {
                    llvm::MetadataTracking::track((uint64_t)&p_src, (unsigned __int8 *)v209, 2);
                  }
                  uint64_t v210 = (char **)((char *)v208 + 48);
                  if (&p_src == (char **)((char *)v208 + 48))
                  {
                    if (!p_src) {
                      goto LABEL_292;
                    }
                    int v218 = *p_src;
                    if ((v218 - 4) > 0x1E)
                    {
                      if ((v218 - 3) >= 0xFFFFFFFE) {
                        unint64_t v221 = p_src;
                      }
                      else {
                        unint64_t v221 = 0;
                      }
                      if ((v218 - 3) < 0xFFFFFFFE)
                      {
                        if (v218 == 3) {
                          *((void *)p_src + 1) = 0;
                        }
                        goto LABEL_292;
                      }
                      unint64_t v220 = (unint64_t)(v221 + 8);
                    }
                    else
                    {
                      if ((p_src[1] & 0x7F) != 2 && !*((_DWORD *)p_src + 3)) {
                        goto LABEL_292;
                      }
                      uint64_t v219 = *((void *)p_src + 2);
                      if ((v219 & 4) == 0) {
                        goto LABEL_292;
                      }
                      unint64_t v220 = v219 & 0xFFFFFFFFFFFFFFF8;
                      if (!v220) {
                        goto LABEL_292;
                      }
                    }
                    p_p_src = &p_src;
                    sub_1CC5FA668(v220 + 16, &p_p_src);
                    goto LABEL_292;
                  }
                  uint64_t v211 = *v210;
                  if (!*v210) {
                    goto LABEL_290;
                  }
                  int v214 = *v211;
                  if ((v214 - 4) <= 0x1E)
                  {
                    if ((v211[1] & 0x7F) != 2 && !*((_DWORD *)v211 + 3)) {
                      goto LABEL_290;
                    }
                    uint64_t v215 = *((void *)v211 + 2);
                    if ((v215 & 4) == 0) {
                      goto LABEL_290;
                    }
                    unint64_t v216 = v215 & 0xFFFFFFFFFFFFFFF8;
                    if (!v216) {
                      goto LABEL_290;
                    }
                    goto LABEL_307;
                  }
                  if ((v214 - 3) >= 0xFFFFFFFE) {
                    uint64_t v217 = *v210;
                  }
                  else {
                    uint64_t v217 = 0;
                  }
                  if ((v214 - 3) >= 0xFFFFFFFE)
                  {
                    unint64_t v216 = (unint64_t)(v217 + 8);
LABEL_307:
                    p_p_src = (char *)v208 + 48;
                    sub_1CC5FA668(v216 + 16, &p_p_src);
                    goto LABEL_290;
                  }
                  if (v214 == 3) {
                    *((void *)v211 + 1) = 0;
                  }
LABEL_290:
                  uint64_t v212 = (unsigned __int8 *)p_src;
                  *uint64_t v210 = p_src;
                  if (v212)
                  {
                    llvm::MetadataTracking::retrack((uint64_t)&p_src, v212, (uint64_t)v208 + 48);
                    p_src = 0;
                  }
LABEL_292:
                  llvm::APInt *v194 = v208;
                }
                uint64_t v213 = v193 + 1;
                int v194 = (llvm::SwitchInstProfUpdateWrapper **)&(&Successor)[2 * v193 + 2];
                uint64_t v193 = 1;
                if (v213 == 2)
                {
                  if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                  {
                    uint64_t v222 = ***(void ***)v32;
                    uint64_t v223 = *(void *)(v222 + 152);
                    uint64_t v224 = *(unsigned int *)(v222 + 168);
                    if (v224)
                    {
                      LODWORD(v225) = (v224 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                      unint64_t v226 = (llvm::Instruction **)(v223 + 16 * v225);
                      uint64_t v227 = *v226;
                      if (*v226 != v32)
                      {
                        int v228 = 1;
                        do
                        {
                          if (v227 == (llvm::Instruction *)-4096) {
                            goto LABEL_441;
                          }
                          int v229 = v225 + v228++;
                          uint64_t v225 = v229 & (v224 - 1);
                          uint64_t v227 = *(llvm::Instruction **)(v223 + 16 * v225);
                        }
                        while (v227 != v32);
                        unint64_t v226 = (llvm::Instruction **)(v223 + 16 * v225);
                      }
                    }
                    else
                    {
LABEL_441:
                      unint64_t v226 = (llvm::Instruction **)(v223 + 16 * v224);
                    }
                    unsigned int v307 = v226[1];
                    uint64_t v310 = *(void *)v307;
                    int v309 = (char *)v307 + 16;
                    uint64_t v308 = v310;
                  }
                  else
                  {
                    uint64_t v308 = 0;
                    int v309 = &byte_1CFBCE98E;
                  }
                  __int16 v704 = 261;
                  p_p_src = v309;
                  uint64_t v701 = v308;
                  uint64_t v312 = llvm::BinaryOperator::Create(19, Successor, v693, (const char **)&p_p_src, (uint64_t)v32);
                  uint64_t v313 = (void **)*((void *)v32 + 6);
                  __src = v313;
                  if (v313) {
                    llvm::MetadataTracking::track((uint64_t)&__src, (unsigned __int8 *)v313, 2);
                  }
                  v314 = (void **)((char *)v312 + 48);
                  if (&__src == (void **)((char *)v312 + 48))
                  {
                    if (!__src) {
                      goto LABEL_449;
                    }
                    int v571 = *(unsigned __int8 *)__src;
                    if ((v571 - 4) > 0x1E)
                    {
                      if ((v571 - 3) >= 0xFFFFFFFE) {
                        v586 = __src;
                      }
                      else {
                        v586 = 0;
                      }
                      if ((v571 - 3) < 0xFFFFFFFE)
                      {
                        if (v571 == 3) {
                          *((void *)__src + 1) = 0;
                        }
                        goto LABEL_449;
                      }
                      unint64_t v573 = (unint64_t)v586 + 8;
                    }
                    else
                    {
                      if ((*((unsigned char *)__src + 1) & 0x7F) != 2 && !*((_DWORD *)__src + 3)) {
                        goto LABEL_449;
                      }
                      uint64_t v572 = *((void *)__src + 2);
                      if ((v572 & 4) == 0) {
                        goto LABEL_449;
                      }
                      unint64_t v573 = v572 & 0xFFFFFFFFFFFFFFF8;
                      if (!v573) {
                        goto LABEL_449;
                      }
                    }
                    p_p_src = &__src;
                    sub_1CC5FA668(v573 + 16, &p_p_src);
                    goto LABEL_449;
                  }
                  __int16 v315 = (unsigned __int8 *)*v314;
                  if (!*v314) {
                    goto LABEL_447;
                  }
                  int v377 = *v315;
                  if ((v377 - 4) <= 0x1E)
                  {
                    if ((v315[1] & 0x7F) != 2 && !*((_DWORD *)v315 + 3)) {
                      goto LABEL_447;
                    }
                    uint64_t v378 = *((void *)v315 + 2);
                    if ((v378 & 4) == 0) {
                      goto LABEL_447;
                    }
                    unint64_t v379 = v378 & 0xFFFFFFFFFFFFFFF8;
                    if (!v379) {
                      goto LABEL_447;
                    }
                    goto LABEL_685;
                  }
                  if ((v377 - 3) >= 0xFFFFFFFE) {
                    uint64_t v462 = *v314;
                  }
                  else {
                    uint64_t v462 = 0;
                  }
                  if ((v377 - 3) >= 0xFFFFFFFE)
                  {
                    unint64_t v379 = (unint64_t)v462 + 8;
LABEL_685:
                    p_p_src = (char *)v312 + 48;
                    sub_1CC5FA668(v379 + 16, &p_p_src);
                    goto LABEL_447;
                  }
                  if (v377 == 3) {
                    *((void *)v315 + 1) = 0;
                  }
LABEL_447:
                  __int16 v316 = (unsigned __int8 *)__src;
                  unsigned __int8 *v314 = __src;
                  if (v316)
                  {
                    llvm::MetadataTracking::retrack((uint64_t)&__src, v316, (uint64_t)v312 + 48);
                    __src = 0;
                  }
LABEL_449:
                  *((unsigned char *)v312 + 17) = *((unsigned char *)v312 + 17) & 0xFD | *((unsigned char *)v32 + 17) & 2;
                  uint64_t v317 = v312;
                  if (v692 != v694[0])
                  {
                    if ((*((unsigned char *)v312 + 23) & 0x10) != 0)
                    {
                      uint64_t v318 = ***(void ***)v312;
                      uint64_t v319 = *(void *)(v318 + 152);
                      uint64_t v320 = *(unsigned int *)(v318 + 168);
                      if (!v320) {
                        goto LABEL_595;
                      }
                      LODWORD(v321) = (v320 - 1) & ((v312 >> 4) ^ (v312 >> 9));
                      uint64_t v322 = (llvm::Value **)(v319 + 16 * v321);
                      v323 = *v322;
                      if (*v322 != v312)
                      {
                        int v324 = 1;
                        while (v323 != (llvm::Value *)-4096)
                        {
                          int v325 = v321 + v324++;
                          uint64_t v321 = v325 & (v320 - 1);
                          v323 = *(llvm::Value **)(v319 + 16 * v321);
                          if (v323 == v312) {
                            goto LABEL_594;
                          }
                        }
LABEL_595:
                        uint64_t v322 = (llvm::Value **)(v319 + 16 * v320);
                      }
                      goto LABEL_596;
                    }
LABEL_686:
                    uint64_t v403 = 0;
                    uint64_t v404 = &byte_1CFBCE98E;
                    goto LABEL_597;
                  }
                  goto LABEL_598;
                }
                continue;
              }
            }
            BOOL v46 = 0;
LABEL_599:
            v30 |= v46;
LABEL_660:
            unsigned int v29 = v31;
            if (v31 == v28) {
              goto LABEL_1013;
            }
            continue;
          case '7':
            if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12) {
              goto LABEL_658;
            }
            llvm::LazyValueInfo::getConstantRange(a2, *((llvm::Value **)v32 - 8), v32, 1, (unint64_t *)&Successor);
            unint64_t v64 = *(unsigned int *)(*(void *)v32 + 8);
            if (v64 >> 8 > 0x40) {
              operator new[]();
            }
            if (v64 >= 0x100) {
              unint64_t v65 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v64);
            }
            else {
              unint64_t v65 = 0;
            }
            LODWORD(v726) = *(_DWORD *)(*(void *)v32 + 8) >> 8;
            p_src = (char *)v65;
            unsigned int v728 = v64 >> 8;
            v727 = (const char *)(v65 & 1);
            BOOL v66 = llvm::ConstantRange::contains((llvm::ConstantRange *)&p_src, (const llvm::ConstantRange *)&Successor);
            int v67 = (llvm::Value *)*((void *)v32 - 8);
            if (v66) {
              goto LABEL_572;
            }
            int v68 = (llvm::Constant *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v67, 0, 0);
            LODWORD(v54) = 0;
            if (llvm::LazyValueInfo::getPredicateAt(a2, 39, v67, v68, v32, 1) != 1)
            {
              if (v728 >= 0x41 && v727) {
                MEMORY[0x1D25D9CB0](v727, 0x1000C8000313F17);
              }
              if (v726 >= 0x41 && p_src) {
                MEMORY[0x1D25D9CB0](p_src, 0x1000C8000313F17);
              }
              if (v694[0] >= 0x41u && v693) {
                MEMORY[0x1D25D9CB0](v693, 0x1000C8000313F17);
              }
              if (v692 >= 0x41 && Successor) {
                MEMORY[0x1D25D9CB0](Successor, 0x1000C8000313F17);
              }
              goto LABEL_659;
            }
            if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
            {
              uint64_t v69 = ***(void ***)v32;
              uint64_t v70 = *(void *)(v69 + 152);
              uint64_t v71 = *(unsigned int *)(v69 + 168);
              if (v71)
              {
                LODWORD(v72) = (v71 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                uint64_t v73 = (llvm::Instruction **)(v70 + 16 * v72);
                unint64_t v74 = *v73;
                if (*v73 != v32)
                {
                  int v75 = 1;
                  do
                  {
                    if (v74 == (llvm::Instruction *)-4096) {
                      goto LABEL_563;
                    }
                    int v76 = v72 + v75++;
                    uint64_t v72 = v76 & (v71 - 1);
                    unint64_t v74 = *(llvm::Instruction **)(v70 + 16 * v72);
                  }
                  while (v74 != v32);
                  uint64_t v73 = (llvm::Instruction **)(v70 + 16 * v72);
                }
              }
              else
              {
LABEL_563:
                uint64_t v73 = (llvm::Instruction **)(v70 + 16 * v71);
              }
              uint64_t v380 = v73[1];
              uint64_t v383 = *(void *)v380;
              uint64_t v382 = (char *)v380 + 16;
              uint64_t v381 = v383;
            }
            else
            {
              uint64_t v381 = 0;
              uint64_t v382 = &byte_1CFBCE98E;
            }
            uint64_t v384 = (void *)*((void *)v32 - 8);
            uint64_t v385 = *((void *)v32 - 4);
            __int16 v704 = 261;
            p_p_src = v382;
            uint64_t v701 = v381;
            int v67 = llvm::BinaryOperator::Create(26, v384, v385, (const char **)&p_p_src, (uint64_t)v32);
            v386 = (void **)*((void *)v32 + 6);
            __src = v386;
            if (v386) {
              llvm::MetadataTracking::track((uint64_t)&__src, (unsigned __int8 *)v386, 2);
            }
            int v387 = (void **)((char *)v67 + 48);
            if (&__src != (void **)((char *)v67 + 48))
            {
              int v388 = (unsigned __int8 *)*v387;
              if (!*v387) {
                goto LABEL_569;
              }
              int v456 = *v388;
              if ((v456 - 4) > 0x1E)
              {
                if ((v456 - 3) >= 0xFFFFFFFE) {
                  v545 = *v387;
                }
                else {
                  v545 = 0;
                }
                if ((v456 - 3) < 0xFFFFFFFE)
                {
                  if (v456 == 3) {
                    *((void *)v388 + 1) = 0;
                  }
                  goto LABEL_569;
                }
                unint64_t v458 = (unint64_t)v545 + 8;
              }
              else if ((v388[1] & 0x7F) != 2 && !*((_DWORD *)v388 + 3) {
                     || (uint64_t v457 = *((void *)v388 + 2), (v457 & 4) == 0)
              }
                     || (unint64_t v458 = v457 & 0xFFFFFFFFFFFFFFF8) == 0)
              {
LABEL_569:
                v389 = (unsigned __int8 *)__src;
                *int v387 = __src;
                if (v389)
                {
                  llvm::MetadataTracking::retrack((uint64_t)&__src, v389, (uint64_t)v67 + 48);
                  __src = 0;
                }
                goto LABEL_571;
              }
              p_p_src = (char *)v67 + 48;
              sub_1CC5FA668(v458 + 16, &p_p_src);
              goto LABEL_569;
            }
            if (!__src) {
              goto LABEL_571;
            }
            int v577 = *(unsigned __int8 *)__src;
            if ((v577 - 4) > 0x1E)
            {
              if ((v577 - 3) >= 0xFFFFFFFE) {
                v588 = __src;
              }
              else {
                v588 = 0;
              }
              if ((v577 - 3) < 0xFFFFFFFE)
              {
                if (v577 == 3) {
                  *((void *)__src + 1) = 0;
                }
                goto LABEL_571;
              }
              unint64_t v579 = (unint64_t)v588 + 8;
            }
            else
            {
              if ((*((unsigned char *)__src + 1) & 0x7F) != 2 && !*((_DWORD *)__src + 3)) {
                goto LABEL_571;
              }
              uint64_t v578 = *((void *)__src + 2);
              if ((v578 & 4) == 0) {
                goto LABEL_571;
              }
              unint64_t v579 = v578 & 0xFFFFFFFFFFFFFFF8;
              if (!v579) {
                goto LABEL_571;
              }
            }
            p_p_src = &__src;
            sub_1CC5FA668(v579 + 16, &p_p_src);
LABEL_571:
            *((unsigned char *)v67 + 17) = *((unsigned char *)v67 + 17) & 0xFD | *((unsigned char *)v32 + 17) & 2;
LABEL_572:
            llvm::Value::doRAUW(v32, v67, (llvm::Value *)1);
            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
          case '8':
            if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12) {
              goto LABEL_107;
            }
            uint64_t v80 = *((void *)v32 - 4);
            if (!v80 || *(unsigned char *)(v80 + 16) != 16) {
              goto LABEL_107;
            }
            int v82 = v30;
            uint64_t v83 = (llvm::Value *)*((void *)v32 - 8);
            int v84 = (void *)(v80 + 24);
            uint64_t v85 = *(unsigned int *)(v80 + 32);
            if (v85 <= 0x40)
            {
              if (*v84) {
                BOOL v86 = ((*v84 + 1) & *v84) == 0;
              }
              else {
                BOOL v86 = 0;
              }
              int v30 = v82;
              if (!v86) {
                goto LABEL_107;
              }
LABEL_900:
              llvm::LazyValueInfo::getConstantRange(v657, v83, v32, 0, (unint64_t *)&p_p_src);
              llvm::ConstantRange::getUnsignedMax((char **)&p_p_src, (uint64_t)&Successor);
              if (v692 > 0x40)
              {
                unint64_t v567 = (((unint64_t)v692 + 63) >> 3) & 0x3FFFFFF8;
                do
                {
                  if (!v567)
                  {
                    if (Successor) {
                      MEMORY[0x1D25D9CB0](Successor, 0x1000C8000313F17);
                    }
LABEL_907:
                    llvm::Value::doRAUW(v32, v83, (llvm::Value *)1);
                    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                  }
                  unint64_t v568 = *(unint64_t *)((char *)Successor + v567 - 8);
                  unint64_t v569 = *(void *)(*v84 - 8 + v567);
                  v567 -= 8;
                }
                while (v568 == v569);
                MEMORY[0x1D25D9CB0](Successor, 0x1000C8000313F17);
                BOOL v35 = v568 > v569;
                int v30 = v82;
                if (!v35) {
                  goto LABEL_907;
                }
              }
              else if ((unint64_t)Successor <= *v84)
              {
                goto LABEL_907;
              }
              if (v703 >= 0x41 && v702) {
                MEMORY[0x1D25D9CB0](v702, 0x1000C8000313F17);
              }
              if (v701 >= 0x41 && p_p_src) {
                MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
              }
              goto LABEL_107;
            }
            int v562 = llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)(v80 + 24));
            if (!v562)
            {
              int v30 = v82;
              goto LABEL_107;
            }
            int v563 = 0;
            int64_t v564 = (unint64_t)(v85 + 63) >> 6;
            do
            {
              BOOL v35 = v564-- < 1;
              if (v35) {
                break;
              }
              unint64_t v565 = *(void *)(*v84 + 8 * v564);
              v563 += __clz(v565);
            }
            while (!v565);
            int v566 = v85 | 0xFFFFFFC0;
            if ((v85 & 0x3F) == 0) {
              int v566 = 0;
            }
            BOOL v26 = v566 + v562 + v563 == v85;
            int v30 = v82;
            uint64_t v28 = v658;
            if (v26) {
              goto LABEL_900;
            }
LABEL_107:
            a2 = v657;
            goto LABEL_660;
          case '<':
          case '=':
            int v43 = (unsigned __int8 *)*((void *)v32 - 4);
            if (v43[16] >= 0x15u
              && (Constant = (llvm::Value *)llvm::LazyValueInfo::getConstant(a2, *((llvm::Value **)v32 - 4), v32)) != 0)
            {
              llvm::User::replaceUsesOfWith(v32, (llvm::Value *)v43, Constant);
              int v45 = 1;
            }
            else
            {
              int v45 = 0;
            }
            v30 |= v45;
            goto LABEL_660;
          case 'D':
            if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12) {
              goto LABEL_658;
            }
            uint64_t v52 = (llvm::ConstantInt **)*((void *)v32 - 4);
            BOOL v53 = (llvm::Constant *)llvm::ConstantInt::get(*v52, 0, 0);
            LODWORD(v54) = 0;
            if (llvm::LazyValueInfo::getPredicateAt(a2, 39, (llvm::Value *)v52, v53, v32, 1) != 1) {
              goto LABEL_659;
            }
            int v55 = *(llvm::Type ****)v32;
            if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
            {
              int v56 = **v55;
              uint64_t v57 = *((void *)v56 + 19);
              uint64_t v58 = *((unsigned int *)v56 + 42);
              if (v58)
              {
                LODWORD(v59) = (v58 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                int v60 = (llvm::Instruction **)(v57 + 16 * v59);
                unint64_t v61 = *v60;
                if (*v60 != v32)
                {
                  int v62 = 1;
                  do
                  {
                    if (v61 == (llvm::Instruction *)-4096) {
                      goto LABEL_520;
                    }
                    int v63 = v59 + v62++;
                    uint64_t v59 = v63 & (v58 - 1);
                    unint64_t v61 = *(llvm::Instruction **)(v57 + 16 * v59);
                  }
                  while (v61 != v32);
                  int v60 = (llvm::Instruction **)(v57 + 16 * v59);
                }
              }
              else
              {
LABEL_520:
                int v60 = (llvm::Instruction **)(v57 + 16 * v58);
              }
              uint64_t v350 = v60[1];
              uint64_t v353 = *(void *)v350;
              uint64_t v352 = (char *)v350 + 16;
              uint64_t v351 = v353;
            }
            else
            {
              uint64_t v351 = 0;
              uint64_t v352 = &byte_1CFBCE98E;
            }
            __int16 v704 = 261;
            p_p_src = v352;
            uint64_t v701 = v351;
            ZExtOrBitCast = llvm::CastInst::CreateZExtOrBitCast((llvm::CastInst *)v52, v55, (const char **)&p_p_src, v32, v18);
            v355 = (llvm::SwitchInstProfUpdateWrapper *)*((void *)v32 + 6);
            uint64_t Successor = (const char **)v355;
            if (v355) {
              llvm::MetadataTracking::track((uint64_t)&Successor, (unsigned __int8 *)v355, 2);
            }
            int v356 = (const char ***)((char *)ZExtOrBitCast + 48);
            if (&Successor != (const char ***)((char *)ZExtOrBitCast + 48))
            {
              uint64_t v357 = *v356;
              if (!*v356) {
                goto LABEL_526;
              }
              int v422 = *(unsigned __int8 *)v357;
              if ((v422 - 4) > 0x1E)
              {
                if ((v422 - 3) >= 0xFFFFFFFE) {
                  v487 = *v356;
                }
                else {
                  v487 = 0;
                }
                if ((v422 - 3) < 0xFFFFFFFE)
                {
                  if (v422 == 3) {
                    v357[1] = 0;
                  }
                  goto LABEL_526;
                }
                unint64_t v424 = (unint64_t)(v487 + 1);
              }
              else if ((*((unsigned char *)v357 + 1) & 0x7F) != 2 && !*((_DWORD *)v357 + 3) {
                     || (v423 = v357[2], (v423 & 4) == 0)
              }
                     || (unint64_t v424 = (unint64_t)v423 & 0xFFFFFFFFFFFFFFF8) == 0)
              {
LABEL_526:
                v358 = (unsigned __int8 *)Successor;
                *int v356 = Successor;
                if (v358)
                {
                  llvm::MetadataTracking::retrack((uint64_t)&Successor, v358, (uint64_t)ZExtOrBitCast + 48);
                  uint64_t Successor = 0;
                }
                goto LABEL_528;
              }
              p_p_src = (char *)ZExtOrBitCast + 48;
              sub_1CC5FA668(v424 + 16, &p_p_src);
              goto LABEL_526;
            }
            if (!Successor) {
              goto LABEL_528;
            }
            int v574 = *(unsigned __int8 *)Successor;
            if ((v574 - 4) > 0x1E)
            {
              if ((v574 - 3) >= 0xFFFFFFFE) {
                v587 = (llvm::SwitchInstProfUpdateWrapper *)Successor;
              }
              else {
                v587 = 0;
              }
              if ((v574 - 3) < 0xFFFFFFFE)
              {
                if (v574 == 3) {
                  Successor[1] = 0;
                }
                goto LABEL_528;
              }
              unint64_t v576 = (unint64_t)v587 + 8;
            }
            else
            {
              if ((*((unsigned char *)Successor + 1) & 0x7F) != 2 && !*((_DWORD *)Successor + 3)) {
                goto LABEL_528;
              }
              unint64_t v575 = (unint64_t)Successor[2];
              if ((v575 & 4) == 0) {
                goto LABEL_528;
              }
              unint64_t v576 = v575 & 0xFFFFFFFFFFFFFFF8;
              if (!v576) {
                goto LABEL_528;
              }
            }
            p_p_src = &Successor;
            sub_1CC5FA668(v576 + 16, &p_p_src);
LABEL_528:
            unsigned int v240 = v32;
            uint64_t v241 = ZExtOrBitCast;
            goto LABEL_657;
          case 'Q':
          case 'R':
            uint64_t v17 = (unsigned __int8 *)*((void *)v32 - 4);
            if (v17) {
              BOOL v35 = v17[16] > 0x14u;
            }
            else {
              BOOL v35 = 1;
            }
            if (!v35)
            {
              int PredicateAt = llvm::LazyValueInfo::getPredicateAt(a2, *((_WORD *)v32 + 9) & 0x3F, *((llvm::Value **)v32 - 8), (llvm::Constant *)v17, v32, 1);
              if (PredicateAt != -1)
              {
                uint64_t v38 = ***(void ***)v32;
                uint64_t v39 = *(llvm::ConstantInt **)(v38 + 1888);
                unint64_t v40 = *(unsigned int *)(v38 + 1896);
                LODWORD(v701) = v40 >> 8;
                if (v40 >> 8 <= 0x40)
                {
                  if (v40 <= 0xFF) {
                    unint64_t v41 = 0;
                  }
                  else {
                    unint64_t v41 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v40) + 63);
                  }
                  p_p_src = (void *)(v41 & PredicateAt);
                  int v42 = (llvm::Value *)llvm::ConstantInt::get(v39, (llvm::LLVMContext *)&p_p_src, v37);
                  if (v701 >= 0x41 && p_p_src) {
                    MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
                  }
                  llvm::Value::doRAUW(v32, v42, (llvm::Value *)1);
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
                operator new[]();
              }
              int v33 = *((unsigned __int8 *)v32 + 16);
            }
            int v183 = v30;
            int v184 = 0;
            if (v33 != 81) {
              uint64_t v32 = 0;
            }
            if (v29)
            {
              if (v33 == 81 && byte_1EBCF0D88 != 0)
              {
                if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12) {
                  goto LABEL_268;
                }
                uint64_t v16 = (unsigned __int8 *)*((void *)v32 - 8);
                if (*(unsigned char *)(*(void *)v16 + 8) != 13) {
                  goto LABEL_268;
                }
                int v186 = *((_WORD *)v32 + 9) & 0x3F;
                if ((v186 - 38) > 3) {
                  goto LABEL_268;
                }
                llvm::LazyValueInfo::getConstantRange(a2, (llvm::Value *)v16, v32, 1, (unint64_t *)&p_p_src);
                llvm::LazyValueInfo::getConstantRange(a2, *((llvm::Value **)v32 - 4), v32, 1, (unint64_t *)&Successor);
                int EquivalentPredWithFlippedSignedness = llvm::ConstantRange::getEquivalentPredWithFlippedSignedness(v186, (const void **)&p_p_src, (const llvm::ConstantRange *)&Successor);
                if (v694[0] >= 0x41u && v693) {
                  MEMORY[0x1D25D9CB0](v693, 0x1000C8000313F17);
                }
                if (v692 >= 0x41 && Successor) {
                  MEMORY[0x1D25D9CB0](Successor, 0x1000C8000313F17);
                }
                if (v703 >= 0x41 && v702) {
                  MEMORY[0x1D25D9CB0](v702, 0x1000C8000313F17);
                }
                if (v701 >= 0x41 && p_p_src) {
                  MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
                }
                if (EquivalentPredWithFlippedSignedness == 42)
                {
LABEL_268:
                  int v184 = 0;
                }
                else
                {
                  *((_WORD *)v32 + 9) = *((_WORD *)v32 + 9) & 0xFFC0 | EquivalentPredWithFlippedSignedness;
                  int v184 = 1;
                }
              }
            }
            int v30 = v183 | v184;
            uint64_t v28 = v658;
            goto LABEL_660;
          case 'S':
            int v87 = *((_DWORD *)v32 + 5);
            uint64_t v88 = v87 & 0x7FFFFFF;
            if ((v87 & 0x7FFFFFF) == 0)
            {
              p_p_src = &v702;
              uint64_t v701 = 0x800000000;
              uint64_t v182 = llvm::SimplifyInstructionWithOperands(v32, (uint64_t)&v702, 0, a4, v18, v19, v20);
              if (p_p_src == &v702)
              {
                if (v182) {
                  goto LABEL_345;
                }
                goto LABEL_694;
              }
              free(p_p_src);
              if (!v182) {
                goto LABEL_694;
              }
              goto LABEL_345;
            }
            int v654 = v30;
            uint64_t v89 = 0;
            char v90 = 0;
            uint64_t v91 = (llvm::BasicBlock *)*((void *)v32 + 5);
            break;
          case 'T':
            goto LABEL_59;
          case 'U':
            if ((*(_DWORD *)(*(void *)v32 + 8) & 0xFE) == 0x12) {
              goto LABEL_658;
            }
            uint64_t v16 = (unsigned __int8 *)*((void *)v32 - 12);
            if (v16[16] < 0x15u) {
              goto LABEL_658;
            }
            uint64_t v77 = llvm::LazyValueInfo::getConstant(a2, (llvm::Value *)v16, v32);
            if (!v77 || *((unsigned char *)v77 + 16) != 16) {
              goto LABEL_658;
            }
            uint64_t v78 = *((unsigned int *)v77 + 8);
            if (v78 > 0x40)
            {
              int v359 = 0;
              int64_t v360 = (unint64_t)(v78 + 63) >> 6;
              do
              {
                BOOL v35 = v360-- < 1;
                if (v35) {
                  break;
                }
                unint64_t v361 = *(void *)(v77[3] + 8 * v360);
                v359 += __clz(v361);
              }
              while (!v361);
              int v362 = v78 | 0xFFFFFFC0;
              if ((v78 & 0x3F) == 0) {
                int v362 = 0;
              }
              BOOL v79 = v359 + v362 == v78 - 1;
            }
            else
            {
              BOOL v79 = v77[3] == 1;
            }
            int v363 = v79;
            BOOL v26 = v363 == 0;
            uint64_t v364 = -32;
            if (!v26) {
              uint64_t v364 = -64;
            }
            uint64_t v241 = *(llvm::Value **)((char *)v32 + v364);
            goto LABEL_656;
          default:
            if (v33 != 33) {
              goto LABEL_660;
            }
LABEL_59:
            uint64_t v47 = *((void *)v32 - 4);
            if (v47
              && !*(unsigned char *)(v47 + 16)
              && *(void *)(v47 + 24) == *((void *)v32 + 9)
              && *(_DWORD *)(v47 + 36) == 1)
            {
              uint64_t v48 = (llvm::Value **)((char *)v32 - 32 * (*((_DWORD *)v32 + 5) & 0x7FFFFFF));
              unint64_t v49 = v48[4];
              uint64_t v50 = *((unsigned int *)v49 + 8);
              if (v50 > 0x40)
              {
                int v168 = 0;
                int64_t v169 = (unint64_t)(v50 + 63) >> 6;
                do
                {
                  BOOL v35 = v169-- < 1;
                  if (v35) {
                    break;
                  }
                  unint64_t v170 = *(void *)(*((void *)v49 + 3) + 8 * v169);
                  v168 += __clz(v170);
                }
                while (!v170);
                int v171 = v50 | 0xFFFFFFC0;
                if ((v50 & 0x3F) == 0) {
                  int v171 = 0;
                }
                BOOL v51 = v168 + v171 == v50 - 1;
              }
              else
              {
                BOOL v51 = *((void *)v49 + 3) == 1;
              }
              uint64_t v172 = v51;
              unint64_t v173 = *v48;
              uint64_t v174 = *(void *)*v48;
              uint64_t v175 = (llvm::Type *)v174;
              if ((*(_DWORD *)(v174 + 8) & 0xFE) == 0x12) {
                uint64_t v175 = **(llvm::Type ***)(v174 + 16);
              }
              unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v175);
              LODWORD(v701) = PrimitiveSizeInBits;
              if (PrimitiveSizeInBits > 0x40) {
                operator new[]();
              }
              p_p_src = (void *)(1 << (PrimitiveSizeInBits - 1));
              Splat = (llvm::Constant *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v174, (llvm::LLVMContext *)&p_p_src, v177);
              if ((*(_DWORD *)(v174 + 8) & 0xFE) == 0x12) {
                Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v174 + 32) | ((unint64_t)(*(_DWORD *)(v174 + 8) == 19) << 32)), (uint64_t)Splat);
              }
              if (v701 >= 0x41 && p_p_src) {
                MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
              }
              if (llvm::LazyValueInfo::getPredicateAt(a2, 37, v173, Splat, v32, 1) == 1)
              {
                llvm::Value::doRAUW(v32, v173, (llvm::Value *)1);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              Nulluint64_t Value = llvm::Constant::getNullValue((llvm::Constant *)v174, v179, v180);
              if (llvm::LazyValueInfo::getPredicateAt(a2, 41, v173, NullValue, v32, 1) == -1)
              {
                if (v172)
                {
                  LODWORD(v54) = 0;
                  uint64_t v28 = v658;
                }
                else
                {
                  uint64_t v28 = v658;
                  if (llvm::LazyValueInfo::getPredicateAt(a2, 33, v173, Splat, v32, 1) == 1)
                  {
                    unint64_t v231 = **(uint64_t ***)v32;
                    uint64_t v232 = *v231;
                    uint64_t v233 = *(void **)(*v231 + 1560);
                    if (!v233)
                    {
                      v554 = *(llvm::ConstantInt **)(v232 + 1888);
                      unsigned int v555 = *(_DWORD *)(v232 + 1896);
                      LODWORD(v701) = v555 >> 8;
                      if (v555 >> 8 > 0x40) {
                        operator new[]();
                      }
                      if (v555 <= 0xFF) {
                        char v556 = 0;
                      }
                      else {
                        char v556 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v555) + 63);
                      }
                      p_p_src = (void *)(v556 & 1);
                      uint64_t v233 = llvm::ConstantInt::get(v554, (llvm::LLVMContext *)&p_p_src, v230);
                      if (v701 >= 0x41 && p_p_src) {
                        MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
                      }
                      *(void *)(v232 + 1560) = v233;
                    }
                    uint64_t v234 = (void ***)((char *)v32 - 32 * (*((_DWORD *)v32 + 5) & 0x7FFFFFF));
                    unsigned int v235 = v234 + 4;
                    if (v234[4])
                    {
                      *v234[6] = v234[5];
                      uint64_t v236 = v234[5];
                      if (v236) {
                        v236[2] = v234[6];
                      }
                    }
                    void *v235 = v233;
                    if (v233)
                    {
                      unsigned int v239 = (void **)v233[1];
                      int v238 = v233 + 1;
                      unint64_t v237 = v239;
                      v234[5] = v239;
                      if (v239) {
                        v237[2] = v234 + 5;
                      }
                      v234[6] = (void **)v238;
                      *int v238 = v235;
                    }
                    goto LABEL_664;
                  }
                  LODWORD(v54) = 0;
                }
                goto LABEL_659;
              }
              uint64_t v366 = 0;
              uint64_t v367 = **(void **)v32;
              p_p_src = &v702;
              uint64_t v701 = 0x200000000;
              uint64_t v707 = v367;
              v708 = &v716;
              v709 = v717;
              uint64_t v710 = 0;
              int v711 = 0;
              __int16 v712 = 512;
              char v713 = 7;
              v705 = 0;
              v706 = 0;
              uint64_t v714 = 0;
              uint64_t v715 = 0;
              v716 = &unk_1F2616E88;
              v717[0] = &unk_1F2617008;
              v705 = (void **)*((void *)v32 + 5);
              v706 = (void ***)((char *)v32 + 24);
              v368 = (char *)*((void *)v32 + 6);
              p_src = v368;
              if (v368)
              {
                llvm::MetadataTracking::track((uint64_t)&p_src, (unsigned __int8 *)v368, 2);
                uint64_t v366 = p_src;
              }
              sub_1CB8461A4((uint64_t)&p_p_src, 0, (uint64_t)v366);
              if (!p_src)
              {
LABEL_550:
                if ((*((unsigned char *)v32 + 23) & 0x10) != 0)
                {
                  uint64_t v369 = ***(void ***)v32;
                  uint64_t v370 = *(void *)(v369 + 152);
                  uint64_t v371 = *(unsigned int *)(v369 + 168);
                  if (v371)
                  {
                    LODWORD(v372) = (v371 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                    v373 = (llvm::Instruction **)(v370 + 16 * v372);
                    uint64_t v374 = *v373;
                    if (*v373 != v32)
                    {
                      int v375 = 1;
                      do
                      {
                        if (v374 == (llvm::Instruction *)-4096) {
                          goto LABEL_743;
                        }
                        int v376 = v372 + v375++;
                        uint64_t v372 = v376 & (v371 - 1);
                        uint64_t v374 = *(llvm::Instruction **)(v370 + 16 * v372);
                      }
                      while (v374 != v32);
                      v373 = (llvm::Instruction **)(v370 + 16 * v372);
                    }
                  }
                  else
                  {
LABEL_743:
                    v373 = (llvm::Instruction **)(v370 + 16 * v371);
                  }
                  v488 = (uint64_t *)v373[1];
                  uint64_t v491 = *v488;
                  v490 = (llvm::SwitchInstProfUpdateWrapper *)(v488 + 2);
                  uint64_t v489 = v491;
                }
                else
                {
                  uint64_t v489 = 0;
                  v490 = (llvm::SwitchInstProfUpdateWrapper *)&byte_1CFBCE98E;
                }
                v695[0] = 261;
                uint64_t Successor = (const char **)v490;
                uint64_t v692 = v489;
                v492 = sub_1CD5A6358((uint64_t)&p_p_src, v173, (uint64_t)&Successor, 0, v172);
                llvm::Value::doRAUW(v32, v492, (llvm::Value *)1);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              int v551 = *p_src;
              if ((v551 - 4) > 0x1E)
              {
                if ((v551 - 3) >= 0xFFFFFFFE) {
                  v560 = p_src;
                }
                else {
                  v560 = 0;
                }
                if ((v551 - 3) < 0xFFFFFFFE)
                {
                  if (v551 == 3) {
                    *((void *)p_src + 1) = 0;
                  }
                  goto LABEL_550;
                }
                unint64_t v553 = (unint64_t)(v560 + 8);
              }
              else
              {
                if ((p_src[1] & 0x7F) != 2 && !*((_DWORD *)p_src + 3)) {
                  goto LABEL_550;
                }
                uint64_t v552 = *((void *)p_src + 2);
                if ((v552 & 4) == 0) {
                  goto LABEL_550;
                }
                unint64_t v553 = v552 & 0xFFFFFFFFFFFFFFF8;
                if (!v553) {
                  goto LABEL_550;
                }
              }
              uint64_t Successor = (const char **)&p_src;
              sub_1CC5FA668(v553 + 16, &Successor);
              goto LABEL_550;
            }
            if (sub_1CC9FAA9C((uint64_t)v32))
            {
              int v348 = *(_DWORD *)(*((void *)v32 - 4) + 36);
              if (v348 > 304)
              {
                if (v348 == 306) {
                  uint64_t v349 = 36;
                }
                else {
                  uint64_t v349 = 34;
                }
              }
              else if (v348 == 274)
              {
                uint64_t v349 = 38;
              }
              else
              {
                uint64_t v349 = 40;
              }
              unsigned int v453 = (v349 - 2) >> 1;
              if (v453 <= 0x13 && ((0xF0033u >> v453) & 1) != 0) {
                uint64_t v349 = dword_1CFB2C99C[v453];
              }
              __int16 v454 = (llvm::Value **)((char *)v32 - 32 * (*((_DWORD *)v32 + 5) & 0x7FFFFFF));
              int v455 = llvm::LazyValueInfo::getPredicateAt(a2, v349, *v454, v454[4], v32, 1);
              if (v455 == -1)
              {
LABEL_658:
                LODWORD(v54) = 0;
                goto LABEL_659;
              }
              uint64_t v241 = (llvm::Value *)*((void *)v32 + 4 * (v455 == 0) + -4 * (*((_DWORD *)v32 + 5) & 0x7FFFFFF));
LABEL_656:
              unsigned int v240 = v32;
              goto LABEL_657;
            }
            if (sub_1CC062BC4((uint64_t)v32)
              && *(unsigned char *)(**((void **)v32 - 4 * (*((_DWORD *)v32 + 5) & 0x7FFFFFF)) + 8) == 13
              && sub_1CCD30C24((llvm::Value **)v32, a2))
            {
              uint64_t v124 = 0;
              uint64_t v125 = **(void **)v32;
              p_p_src = &v702;
              uint64_t v701 = 0x200000000;
              uint64_t v707 = v125;
              v708 = &v716;
              v709 = v717;
              uint64_t v710 = 0;
              int v711 = 0;
              __int16 v712 = 512;
              char v713 = 7;
              v705 = 0;
              v706 = 0;
              uint64_t v714 = 0;
              uint64_t v715 = 0;
              v716 = &unk_1F2616E88;
              v717[0] = &unk_1F2617008;
              v705 = (void **)*((void *)v32 + 5);
              v706 = (void ***)((char *)v32 + 24);
              unint64_t v126 = (char *)*((void *)v32 + 6);
              p_src = v126;
              if (v126)
              {
                llvm::MetadataTracking::track((uint64_t)&p_src, (unsigned __int8 *)v126, 2);
                uint64_t v124 = p_src;
              }
              sub_1CB8461A4((uint64_t)&p_p_src, 0, (uint64_t)v124);
              if (!p_src)
              {
LABEL_183:
                uint64_t v127 = 13;
                unsigned int v128 = *(_DWORD *)(*((void *)v32 - 4) + 36) - 262;
                if (((1 << (*(unsigned char *)(*((void *)v32 - 4) + 36) - 6)) & 0xC000000003) == 0)
                {
                  if (((1 << v128) & 0x6000000600000) != 0) {
                    uint64_t v127 = 15;
                  }
                  else {
                    uint64_t v127 = 17;
                  }
                }
                int v129 = *((_DWORD *)v32 + 5);
                uint64_t v130 = (uint64_t *)((char *)v32 - 32 * (v129 & 0x7FFFFFF));
                uint64_t v131 = *v130;
                uint64_t v132 = v130[4];
                if ((v129 & 0x10000000) != 0)
                {
                  uint64_t v133 = ***(void ***)v32;
                  uint64_t v134 = *(void *)(v133 + 152);
                  uint64_t v135 = *(unsigned int *)(v133 + 168);
                  if (v135)
                  {
                    LODWORD(v136) = (v135 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                    uint64_t v137 = (llvm::Instruction **)(v134 + 16 * v136);
                    unsigned int v138 = *v137;
                    if (*v137 != v32)
                    {
                      int v139 = 1;
                      do
                      {
                        if (v138 == (llvm::Instruction *)-4096) {
                          goto LABEL_600;
                        }
                        int v140 = v136 + v139++;
                        uint64_t v136 = v140 & (v135 - 1);
                        unsigned int v138 = *(llvm::Instruction **)(v134 + 16 * v136);
                      }
                      while (v138 != v32);
                      uint64_t v137 = (llvm::Instruction **)(v134 + 16 * v136);
                    }
                  }
                  else
                  {
LABEL_600:
                    uint64_t v137 = (llvm::Instruction **)(v134 + 16 * v135);
                  }
                  uint64_t v406 = (uint64_t *)v137[1];
                  uint64_t v409 = *v406;
                  v408 = (llvm::SwitchInstProfUpdateWrapper *)(v406 + 2);
                  uint64_t v407 = v409;
                }
                else
                {
                  uint64_t v407 = 0;
                  v408 = (llvm::SwitchInstProfUpdateWrapper *)&byte_1CFBCE98E;
                }
                v695[0] = 261;
                uint64_t Successor = (const char **)v408;
                uint64_t v692 = v407;
                int v410 = sub_1CB844E98((uint64_t)&p_p_src, v127, v131, v132, (uint64_t)&Successor, 0);
                uint64_t v412 = (uint64_t)v410;
                if (*((unsigned __int8 *)v410 + 16) <= 0x1Bu) {
                  unint64_t v413 = 0;
                }
                else {
                  unint64_t v413 = v410;
                }
                if (v413) {
                  unsigned int v414 = (v128 < 0x17) & (0x610003u >> v128);
                }
                else {
                  unsigned int v414 = 0;
                }
                if (v414 == 1) {
                  *((unsigned char *)v413 + 17) |= 4u;
                }
                if ((((v128 > 0x16) | (0x1EFFFCu >> v128)) & (v413 != 0)) == 1) {
                  *((unsigned char *)v413 + 17) |= 2u;
                }
                BOOL v415 = *(llvm::PoisonValue **)v32;
                p_src = (char *)llvm::UndefValue::get(**(llvm::UndefValue ***)(*(void *)v32 + 16), v411);
                uint64_t v417 = *(uint64_t ***)(*((void *)v415 + 2) + 8);
                uint64_t v418 = **v417;
                v419 = *(void **)(v418 + 1568);
                if (!v419)
                {
                  v548 = *(llvm::ConstantInt **)(v418 + 1888);
                  unsigned int v549 = *(_DWORD *)(v418 + 1896);
                  LODWORD(v692) = v549 >> 8;
                  if (v549 >> 8 > 0x40) {
                    operator new[]();
                  }
                  uint64_t Successor = 0;
                  v419 = llvm::ConstantInt::get(v548, (llvm::LLVMContext *)&Successor, v416);
                  if (v692 >= 0x41 && Successor) {
                    MEMORY[0x1D25D9CB0](Successor, 0x1000C8000313F17);
                  }
                  *(void *)(v418 + 1568) = v419;
                }
                if ((v417[1] & 0xFE) == 0x12) {
                  v419 = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v417 + 8) | ((unint64_t)(*((_DWORD *)v417 + 2) == 19) << 32)), (uint64_t)v419);
                }
                v726 = v419;
                BOOL v420 = llvm::ConstantStruct::get(v415, (llvm::Type *)&p_src, 2);
                LODWORD(p_src) = 0;
                v695[0] = 257;
                v421 = sub_1CC2411F8((uint64_t)&p_p_src, (uint64_t)v420, v412, &p_src, 1, (uint64_t)&Successor);
                llvm::Value::doRAUW(v32, v421, (llvm::Value *)1);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              int v484 = *p_src;
              if ((v484 - 4) > 0x1E)
              {
                if ((v484 - 3) >= 0xFFFFFFFE) {
                  v550 = p_src;
                }
                else {
                  v550 = 0;
                }
                if ((v484 - 3) < 0xFFFFFFFE)
                {
                  if (v484 == 3) {
                    *((void *)p_src + 1) = 0;
                  }
                  goto LABEL_183;
                }
                unint64_t v486 = (unint64_t)(v550 + 8);
              }
              else
              {
                if ((p_src[1] & 0x7F) != 2 && !*((_DWORD *)p_src + 3)) {
                  goto LABEL_183;
                }
                uint64_t v485 = *((void *)p_src + 2);
                if ((v485 & 4) == 0) {
                  goto LABEL_183;
                }
                unint64_t v486 = v485 & 0xFFFFFFFFFFFFFFF8;
                if (!v486) {
                  goto LABEL_183;
                }
              }
              uint64_t Successor = (const char **)&p_src;
              sub_1CC5FA668(v486 + 16, &Successor);
              goto LABEL_183;
            }
            if (sub_1CCD30E34((uint64_t)v32)
              && *(unsigned char *)(*(void *)v32 + 8) == 13
              && sub_1CCD30C24((llvm::Value **)v32, a2))
            {
              char v141 = 13;
              unsigned int v142 = *(_DWORD *)(*((void *)v32 - 4) + 36) - 262;
              if (((1 << (*(unsigned char *)(*((void *)v32 - 4) + 36) - 6)) & 0xC000000003) == 0)
              {
                if (((1 << v142) & 0x6000000600000) != 0) {
                  char v141 = 15;
                }
                else {
                  char v141 = 17;
                }
              }
              int v143 = *((_DWORD *)v32 + 5);
              if ((v143 & 0x10000000) != 0)
              {
                uint64_t v144 = ***(void ***)v32;
                uint64_t v145 = *(void *)(v144 + 152);
                uint64_t v146 = *(unsigned int *)(v144 + 168);
                if (v146)
                {
                  LODWORD(v147) = (v146 - 1) & ((v32 >> 4) ^ (v32 >> 9));
                  int v148 = (llvm::Instruction **)(v145 + 16 * v147);
                  int v149 = *v148;
                  if (*v148 != v32)
                  {
                    int v150 = 1;
                    do
                    {
                      if (v149 == (llvm::Instruction *)-4096) {
                        goto LABEL_622;
                      }
                      int v151 = v147 + v150++;
                      uint64_t v147 = v151 & (v146 - 1);
                      int v149 = *(llvm::Instruction **)(v145 + 16 * v147);
                    }
                    while (v149 != v32);
                    int v148 = (llvm::Instruction **)(v145 + 16 * v147);
                  }
                }
                else
                {
LABEL_622:
                  int v148 = (llvm::Instruction **)(v145 + 16 * v146);
                }
                v425 = v148[1];
                uint64_t v428 = *(void *)v425;
                BOOL v427 = (char *)v425 + 16;
                uint64_t v426 = v428;
              }
              else
              {
                uint64_t v426 = 0;
                BOOL v427 = &byte_1CFBCE98E;
              }
              uint64_t v429 = (void ***)((char *)v32 - 32 * (v143 & 0x7FFFFFF));
              v430 = *v429;
              uint64_t v431 = (uint64_t)v429[4];
              __int16 v704 = 261;
              p_p_src = v427;
              uint64_t v701 = v426;
              uint64_t v432 = (unsigned __int8 *)llvm::BinaryOperator::Create(v141, v430, v431, (const char **)&p_p_src, (uint64_t)v32);
              uint64_t v433 = (llvm::SwitchInstProfUpdateWrapper *)*((void *)v32 + 6);
              uint64_t Successor = (const char **)v433;
              if (v433) {
                llvm::MetadataTracking::track((uint64_t)&Successor, (unsigned __int8 *)v433, 2);
              }
              v434 = (const char ***)(v432 + 48);
              if (&Successor != (const char ***)(v432 + 48))
              {
                v435 = *v434;
                if (!*v434) {
                  goto LABEL_628;
                }
                int v463 = *(unsigned __int8 *)v435;
                if ((v463 - 4) <= 0x1E)
                {
                  if ((*((unsigned char *)v435 + 1) & 0x7F) != 2 && !*((_DWORD *)v435 + 3)) {
                    goto LABEL_628;
                  }
                  v464 = v435[2];
                  if ((v464 & 4) == 0) {
                    goto LABEL_628;
                  }
                  unint64_t v465 = (unint64_t)v464 & 0xFFFFFFFFFFFFFFF8;
                  if (!v465) {
                    goto LABEL_628;
                  }
                  goto LABEL_813;
                }
                if ((v463 - 3) >= 0xFFFFFFFE) {
                  v547 = *v434;
                }
                else {
                  v547 = 0;
                }
                if ((v463 - 3) >= 0xFFFFFFFE)
                {
                  unint64_t v465 = (unint64_t)(v547 + 1);
LABEL_813:
                  p_p_src = v432 + 48;
                  sub_1CC5FA668(v465 + 16, &p_p_src);
                  goto LABEL_628;
                }
                if (v463 == 3) {
                  v435[1] = 0;
                }
LABEL_628:
                v436 = (unsigned __int8 *)Successor;
                char *v434 = Successor;
                if (v436)
                {
                  llvm::MetadataTracking::retrack((uint64_t)&Successor, v436, (uint64_t)(v432 + 48));
                  uint64_t Successor = 0;
                }
LABEL_630:
                unsigned int v437 = (v142 < 0x17) & (0x610003u >> v142);
                if (v432[16] <= 0x1Bu) {
                  v438 = 0;
                }
                else {
                  v438 = v432;
                }
                if (!v438) {
                  unsigned int v437 = 0;
                }
                if (v437 == 1) {
                  v438[17] |= 4u;
                }
                if ((((v142 > 0x16) | (0x1EFFFCu >> v142)) & (v438 != 0)) == 1) {
                  v438[17] |= 2u;
                }
                llvm::Value::doRAUW(v32, (llvm::Value *)v432, (llvm::Value *)1);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              if (!Successor) {
                goto LABEL_630;
              }
              int v583 = *(unsigned __int8 *)Successor;
              if ((v583 - 4) > 0x1E)
              {
                if ((v583 - 3) >= 0xFFFFFFFE) {
                  v590 = (llvm::SwitchInstProfUpdateWrapper *)Successor;
                }
                else {
                  v590 = 0;
                }
                if ((v583 - 3) < 0xFFFFFFFE)
                {
                  if (v583 == 3) {
                    Successor[1] = 0;
                  }
                  goto LABEL_630;
                }
                unint64_t v585 = (unint64_t)v590 + 8;
              }
              else
              {
                if ((*((unsigned char *)Successor + 1) & 0x7F) != 2 && !*((_DWORD *)Successor + 3)) {
                  goto LABEL_630;
                }
                unint64_t v584 = (unint64_t)Successor[2];
                if ((v584 & 4) == 0) {
                  goto LABEL_630;
                }
                unint64_t v585 = v584 & 0xFFFFFFFFFFFFFFF8;
                if (!v585) {
                  goto LABEL_630;
                }
              }
              p_p_src = &Successor;
              sub_1CC5FA668(v585 + 16, &p_p_src);
              goto LABEL_630;
            }
            sub_1CC233A58((char *)v32, 0, (uint64_t *)&p_p_src);
            if ((_BYTE)v703)
            {
              int v152 = v30;
              if (v701)
              {
                char v153 = 0;
                uint64_t v154 = 32 * v701;
                unint64_t v155 = (void **)((char *)p_p_src + 8);
                do
                {
                  unint64_t v156 = v155 - 1;
                  uint64_t v16 = (unsigned __int8 *)*(v155 - 1);
                  if ((*(_DWORD *)(*(void *)v16 + 8) & 0xFE) != 0x12 && v16[16] >= 0x15u)
                  {
                    uint64_t v157 = llvm::LazyValueInfo::getConstant(v657, (llvm::Value *)v16, v32);
                    if (v157)
                    {
                      if (*v156)
                      {
                        *v155[1] = *v155;
                        if (*v155) {
                          (*v155)[2] = v155[1];
                        }
                      }
                      *(v155 - 1) = v157;
                      unint64_t v160 = (void *)v157[1];
                      uint64_t v158 = v157 + 1;
                      uint64_t v159 = v160;
                      void *v155 = v160;
                      if (v160) {
                        v159[2] = v155;
                      }
                      v155[1] = v158;
                      void *v158 = v156;
                      char v153 = 1;
                    }
                  }
                  v155 += 4;
                  v154 -= 32;
                }
                while (v154);
              }
              else
              {
                char v153 = 0;
              }
              LODWORD(v54) = v153 & 1;
              int v30 = v152;
            }
            else
            {
              LODWORD(v54) = 0;
            }
            p_p_src = &v702;
            uint64_t v701 = 0x400000000;
            int v246 = *((_DWORD *)v32 + 5);
            int v247 = *((unsigned __int8 *)v32 + 16);
            if (v247 == 84)
            {
              uint64_t v248 = 0;
            }
            else if (v247 == 39)
            {
              uint64_t v248 = (*((_DWORD *)v32 + 20) + 1);
            }
            else
            {
              uint64_t v248 = 2;
            }
            uint64_t v249 = v246 & 0x7FFFFFF;
            unint64_t v250 = (void ***)((char *)v32 - 32 * v249);
            int v251 = v30;
            if (v246 < 0)
            {
              uint64_t v570 = (uint64_t)*(v250 - 1);
              if ((v570 & 0xFFFFFFFF0) != 0) {
                uint64_t v252 = (*((_DWORD *)v250 - 3) - *(_DWORD *)((char *)v250 - v570));
              }
              else {
                uint64_t v252 = 0;
              }
            }
            else
            {
              uint64_t v252 = 0;
            }
            if (v250 == (void ***)((char *)v32 + -32 * v252 + -32 * v248 - 32))
            {
              a2 = v657;
              uint64_t v28 = v658;
              goto LABEL_659;
            }
            int v253 = 0;
            unint64_t v254 = (32 * v248 + 32 * v252) ^ 0xFFFFFFFFFFFFFFE0;
            uint64_t v255 = -32 * v249;
            do
            {
              uint64_t v256 = *(unsigned __int8 **)((char *)v32 + v255);
              uint64_t v257 = *(llvm::ConstantPointerNull **)v256;
              if (*(void *)v256) {
                BOOL v258 = *(unsigned char *)(*(void *)v256 + 8) == 15;
              }
              else {
                BOOL v258 = 0;
              }
              if (v258 && (llvm::CallBase::paramHasAttr((uint64_t)v32, v253, 39) & 1) == 0 && v256[16] >= 0x15u)
              {
                int v259 = (llvm::Constant *)llvm::ConstantPointerNull::get(v257, (llvm::PointerType *)v16);
                if (!llvm::LazyValueInfo::getPredicateAt(v657, 32, (llvm::Value *)v256, v259, v32, 0))
                {
                  if (v701 >= (unint64_t)HIDWORD(v701)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((_DWORD *)p_p_src + v701) = v253;
                  LODWORD(v701) = v701 + 1;
                }
              }
              ++v253;
              v255 += 32;
            }
            while (v254 != v255);
            uint64_t v260 = v701;
            uint64_t v261 = (const char **)p_p_src;
            if (v701)
            {
              uint64_t Successor = (const char **)*((void *)v32 + 8);
              v262 = **(uint64_t ***)v32;
              unint64_t v263 = llvm::Attribute::get(v262, 0x27u, 0);
              *((void *)v32 + 8) = llvm::AttributeList::addParamAttribute(&Successor, v262, v261, v260, v263);
              LODWORD(v54) = 1;
              uint64_t v261 = (const char **)p_p_src;
            }
            int v30 = v251;
            a2 = v657;
            uint64_t v28 = v658;
            if (v261 != &v702)
            {
              int v264 = v261;
              goto LABEL_720;
            }
LABEL_659:
            v30 |= v54;
            goto LABEL_660;
        }
        break;
      }
      while (2)
      {
        int v92 = *((_DWORD *)v32 + 5);
        if ((v92 & 0x40000000) != 0) {
          uint64_t v93 = (void ***)*((void *)v32 - 1);
        }
        else {
          uint64_t v93 = (void ***)((char *)v32 - 32 * (v92 & 0x7FFFFFF));
        }
        uint64_t v94 = (llvm::ConstantInt ***)v93[4 * v89];
        if (*((unsigned __int8 *)v94 + 16) < 0x15u) {
          goto LABEL_143;
        }
        uint64_t v95 = (llvm::BasicBlock *)(&v93[4 * *((unsigned int *)v32 + 15)])[v89];
        ConstantOnEdge = llvm::LazyValueInfo::getConstantOnEdge(a2, v94, v95, v91, v32);
        if (ConstantOnEdge) {
          goto LABEL_115;
        }
        if (*((unsigned char *)v94 + 16) != 85) {
          goto LABEL_143;
        }
        unsigned int v103 = (llvm::ConstantInt ***)*(v94 - 12);
        if (((*v103)[1] & 0xFE) == 0x12) {
          goto LABEL_130;
        }
        unint64_t v104 = (llvm::Constant *)llvm::LazyValueInfo::getConstantOnEdge(a2, v103, v95, v91, v32);
        if (!v104) {
          goto LABEL_130;
        }
        uint64_t v105 = (uint64_t)v104;
        if (!llvm::Constant::isOneValue(v104))
        {
          if (*(unsigned char *)(v105 + 16) == 17)
          {
            if (*(_UNKNOWN **)(v105 + 32) == &unk_1CFB2E344) {
              int v118 = *(char **)(v105 + 40);
            }
            else {
              int v118 = (char *)(v105 + 24);
            }
LABEL_163:
            a2 = v657;
            if ((v118[28] & 7) == 3) {
              goto LABEL_153;
            }
          }
          else
          {
            if ((*(_DWORD *)(*(void *)v105 + 8) & 0xFE) == 0x12)
            {
              Splatuint64_t Value = llvm::Constant::getSplatValue((llvm::Constant *)v105, 0);
              if (SplatValue)
              {
                if (*((unsigned char *)SplatValue + 16) == 17)
                {
                  if ((_UNKNOWN *)SplatValue[4] == &unk_1CFB2E344) {
                    int v118 = (char *)SplatValue[5];
                  }
                  else {
                    int v118 = (char *)(SplatValue + 3);
                  }
                  goto LABEL_163;
                }
              }
            }
            int v106 = *(unsigned __int8 *)(v105 + 16);
            if (v106 == 16)
            {
              uint64_t v107 = *(unsigned int *)(v105 + 32);
              if (v107 < 0x41)
              {
                if (*(void *)(v105 + 24)) {
                  goto LABEL_130;
                }
LABEL_153:
                int v109 = v94 - 4;
LABEL_142:
                ConstantOnEdge = *v109;
                if (*v109)
                {
LABEL_115:
                  int v97 = *((_DWORD *)v32 + 5);
                  if ((v97 & 0x40000000) != 0) {
                    unsigned int v98 = (void ***)*((void *)v32 - 1);
                  }
                  else {
                    unsigned int v98 = (void ***)((char *)v32 - 32 * (v97 & 0x7FFFFFF));
                  }
                  uint64_t v99 = &v98[4 * v89];
                  if (*v99)
                  {
                    *v99[2] = v99[1];
                    uint64_t v112 = v99[1];
                    if (v112) {
                      v112[2] = v99[2];
                    }
                  }
                  *uint64_t v99 = (void **)ConstantOnEdge;
                  int v102 = (void **)ConstantOnEdge[1];
                  uint64_t v100 = ConstantOnEdge + 1;
                  int v101 = v102;
                  v99[1] = v102;
                  if (v102) {
                    v101[2] = v99 + 1;
                  }
                  v98[4 * v89 + 2] = (void **)v100;
                  *uint64_t v100 = v99;
                  char v90 = 1;
                }
LABEL_143:
                if (++v89 == v88)
                {
                  int v161 = *((_DWORD *)v32 + 5);
                  if ((v161 & 0x40000000) != 0)
                  {
                    unint64_t v163 = (const char **)*((void *)v32 - 1);
                    unint64_t v162 = v161 & 0x7FFFFFF;
                  }
                  else
                  {
                    unint64_t v162 = v161 & 0x7FFFFFF;
                    unint64_t v163 = (const char **)((char *)v32 - 32 * v162);
                  }
                  uint64_t v28 = v658;
                  p_p_src = &v702;
                  uint64_t v701 = 0x800000000;
                  if (v162 >= 9) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v162)
                  {
                    uint64_t v164 = 32 * v162;
                    unsigned int v165 = &v702;
                    do
                    {
                      uint64_t v166 = *v163;
                      v163 += 4;
                      *v165++ = v166;
                      v164 -= 32;
                    }
                    while (v164);
                    uint64_t v167 = (const char **)p_p_src;
                  }
                  else
                  {
                    uint64_t v167 = &v702;
                  }
                  LODWORD(v701) = v162;
                  uint64_t v182 = llvm::SimplifyInstructionWithOperands(v32, (uint64_t)v167, v162, a4, v18, v19, v20);
                  int v30 = v654;
                  if (p_p_src == &v702)
                  {
                    if (v182) {
                      goto LABEL_345;
                    }
LABEL_663:
                    if (v90)
                    {
LABEL_664:
                      LODWORD(v54) = 1;
                      goto LABEL_659;
                    }
LABEL_694:
                    p_p_src = &v702;
                    uint64_t v701 = 0x400000000;
                    int v466 = *((_DWORD *)v32 + 5);
                    uint64_t v54 = (unsigned __int8 *)(v466 & 0x7FFFFFF);
                    if ((v466 & 0x7FFFFFF) != 0)
                    {
                      int v467 = v30;
                      uint64_t v468 = 0;
                      unsigned int v469 = 0;
                      v470 = 0;
                      v471 = 0;
                      do
                      {
                        int v472 = *((_DWORD *)v32 + 5);
                        if ((v472 & 0x40000000) != 0) {
                          v473 = (void ***)*((void *)v32 - 1);
                        }
                        else {
                          v473 = (void ***)((char *)v32 - 32 * (v472 & 0x7FFFFFF));
                        }
                        uint64_t v474 = (unsigned __int8 *)v473[v468];
                        if (v474) {
                          BOOL v475 = v474[16] > 0x14u;
                        }
                        else {
                          BOOL v475 = 1;
                        }
                        if (v475)
                        {
                          if (v471)
                          {
                            if (v474 != v471) {
                              goto LABEL_718;
                            }
                          }
                          else
                          {
                            v471 = (unsigned __int8 *)v473[v468];
                          }
                        }
                        else
                        {
                          if (v469 >= HIDWORD(v701)) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          uint64_t v476 = (unsigned __int8 **)((char *)p_p_src + 16 * v469);
                          *uint64_t v476 = v474;
                          v476[1] = v470;
                          unsigned int v469 = v701 + 1;
                          LODWORD(v701) = v701 + 1;
                        }
                        ++v470;
                        v468 += 4;
                      }
                      while (v54 != v470);
                      if (v471) {
                        BOOL v477 = v469 == 0;
                      }
                      else {
                        BOOL v477 = 1;
                      }
                      if (!v477)
                      {
                        v478 = (llvm::BasicBlock *)*((void *)v32 + 5);
                        if (v471[16] > 0x1Bu) {
                          llvm::DominatorTree::dominates(a3, (const llvm::Instruction *)v471, *((const llvm::BasicBlock **)v32 + 5));
                        }
                        v479 = (void **)p_p_src;
                        v480 = (void **)((char *)p_p_src + 16 * v469);
                        while (1)
                        {
                          int v481 = *((_DWORD *)v32 + 5);
                          v482 = (v481 & 0x40000000) != 0
                               ? (llvm::Instruction *)*((void *)v32 - 1)
                               : (llvm::Instruction *)((char *)v32 - 32 * (v481 & 0x7FFFFFF));
                          v483 = *v479;
                          if (v483 != llvm::LazyValueInfo::getConstantOnEdge(a2, (llvm::ConstantInt ***)v471, *((llvm::BasicBlock **)v482+ 4 * *((unsigned int *)v32 + 15)+ *((unsigned int *)v479 + 2)), v478, v32))break; {
                          v479 += 2;
                          }
                          if (v479 == v480)
                          {
                            LODWORD(v54) = 0;
                            int v30 = v467;
                            uint64_t v28 = v658;
                            if (sub_1CC16A22C((uint64_t ***)v471, 0, (uint64_t)v32, (uint64_t)a3, 0, 1))
                            {
                              llvm::Value::doRAUW(v32, (llvm::Value *)v471, (llvm::Value *)1);
                              llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                            }
                            goto LABEL_719;
                          }
                        }
                      }
LABEL_718:
                      LODWORD(v54) = 0;
                      int v30 = v467;
                      uint64_t v28 = v658;
                    }
LABEL_719:
                    int v264 = p_p_src;
                    if (p_p_src != &v702) {
LABEL_720:
                    }
                      free(v264);
                    goto LABEL_659;
                  }
                  free(p_p_src);
                  if (!v182) {
                    goto LABEL_663;
                  }
LABEL_345:
                  unsigned int v240 = v32;
                  uint64_t v241 = v182;
LABEL_657:
                  llvm::Value::doRAUW(v240, v241, (llvm::Value *)1);
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
                continue;
              }
              int v114 = 0;
              int64_t v115 = (unint64_t)(v107 + 63) >> 6;
              do
              {
                BOOL v35 = v115-- < 1;
                if (v35) {
                  break;
                }
                unint64_t v116 = *(void *)(*(void *)(v105 + 24) + 8 * v115);
                v114 += __clz(v116);
              }
              while (!v116);
              int v117 = v107 | 0xFFFFFFC0;
              if ((v107 & 0x3F) == 0) {
                int v117 = 0;
              }
              if (v114 + v117 == v107) {
                goto LABEL_153;
              }
            }
            else if (v106 == 17)
            {
              if (sub_1CB844168(v105, 0.0)) {
                goto LABEL_153;
              }
            }
            else if ((v106 - 18) < 3 || v106 == 13)
            {
              goto LABEL_153;
            }
          }
LABEL_130:
          int v109 = v94 - 4;
          char v108 = (unsigned __int8 *)*(v94 - 4);
          if (v108) {
            BOOL v110 = v108[16] > 0x14u;
          }
          else {
            BOOL v110 = 1;
          }
          if (v110
            || llvm::LazyValueInfo::getPredicateOnEdge(a2, 32, (llvm::Value *)v94, (llvm::Constant *)v108, v95, v91, v32))
          {
            unsigned int v111 = (unsigned __int8 *)*(v94 - 8);
            if (v111
              && v111[16] <= 0x14u
              && !llvm::LazyValueInfo::getPredicateOnEdge(a2, 32, (llvm::Value *)v94, (llvm::Constant *)v111, v95, v91, v32))
            {
              goto LABEL_142;
            }
            goto LABEL_143;
          }
        }
        break;
      }
      int v109 = v94 - 8;
      goto LABEL_142;
    }
    int v30 = 0;
LABEL_1013:
    v593 = (void *)*v28;
    if ((void *)*v28 == v28)
    {
      v595 = 0;
    }
    else
    {
      if (v593) {
        v594 = v593 - 3;
      }
      else {
        v594 = 0;
      }
      if (*((unsigned __int8 *)v594 + 16) - 29 >= 0xB) {
        v595 = 0;
      }
      else {
        v595 = v594;
      }
    }
    int v596 = *((unsigned __int8 *)v595 + 16);
    if (v596 == 29)
    {
      uint64_t v599 = *((_DWORD *)v595 + 5) & 0x7FFFFFF;
      if (!v599) {
        goto LABEL_1079;
      }
      v600 = (llvm::Value *)v595[-4 * v599];
      if (!v600 || *((unsigned __int8 *)v600 + 16) < 0x15u) {
        goto LABEL_1079;
      }
      v601 = (llvm::Value *)llvm::LazyValueInfo::getConstant(a2, v600, (llvm::Instruction *)v595);
      if (!v601)
      {
        unsigned int v632 = *((unsigned __int8 *)v600 + 16);
        if (v632 < 0x1C || v632 - 83 < 0xFFFFFFFE) {
          goto LABEL_1079;
        }
        v634 = (unsigned __int8 *)*((void *)v600 - 4);
        if (!v634 || v634[16] > 0x14u) {
          goto LABEL_1079;
        }
        int v636 = llvm::LazyValueInfo::getPredicateAt(a2, *((_WORD *)v600 + 9) & 0x3F, *((llvm::Value **)v600 - 8), (llvm::Constant *)v634, (llvm::Instruction *)v595, 0);
        if (v636 == -1) {
          goto LABEL_1079;
        }
        if (v636 == 1)
        {
          v638 = **(uint64_t ***)v600;
          uint64_t v639 = *v638;
          v601 = *(llvm::Value **)(*v638 + 1560);
          if (v601) {
            goto LABEL_1029;
          }
          v640 = *(llvm::ConstantInt **)(v639 + 1888);
          unsigned int v641 = *(_DWORD *)(v639 + 1896);
          LODWORD(v701) = v641 >> 8;
          if (v641 >> 8 > 0x40) {
            operator new[]();
          }
          if (v641 <= 0xFF) {
            char v642 = 0;
          }
          else {
            char v642 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v641) + 63);
          }
          p_p_src = (void *)(v642 & 1);
          v601 = (llvm::Value *)llvm::ConstantInt::get(v640, (llvm::LLVMContext *)&p_p_src, v637);
          if (v701 >= 0x41 && p_p_src) {
            MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
          }
          *(void *)(v639 + 1560) = v601;
          a2 = v657;
        }
        else
        {
          v645 = **(uint64_t ***)v600;
          uint64_t v646 = *v645;
          v601 = *(llvm::Value **)(*v645 + 1568);
          if (v601) {
            goto LABEL_1029;
          }
          v647 = *(llvm::ConstantInt **)(v646 + 1888);
          unsigned int v648 = *(_DWORD *)(v646 + 1896);
          LODWORD(v701) = v648 >> 8;
          if (v648 >> 8 > 0x40) {
            operator new[]();
          }
          p_p_src = 0;
          v601 = (llvm::Value *)llvm::ConstantInt::get(v647, (llvm::LLVMContext *)&p_p_src, v637);
          if (v701 >= 0x41 && p_p_src) {
            MEMORY[0x1D25D9CB0](p_p_src, 0x1000C8000313F17);
          }
          *(void *)(v646 + 1568) = v601;
        }
        if (!v601) {
          goto LABEL_1079;
        }
      }
LABEL_1029:
      llvm::User::replaceUsesOfWith((llvm::User *)v595, v600, v601);
      int v30 = 1;
      goto LABEL_1079;
    }
    if (v596 != 31) {
      goto LABEL_1079;
    }
    p_p_src = &v702;
    uint64_t v701 = 0x1000000000;
    v717[18] = 0;
    v717[19] = 0;
    v717[20] = a3;
    v717[21] = 0;
    char v718 = 1;
    v719 = v723;
    v720 = v723;
    uint64_t v721 = 8;
    int v722 = 0;
    memset(&v723[64], 0, 24);
    __int16 v724 = 0;
    int v597 = *((_DWORD *)v595 + 5);
    if ((v597 & 0x40000000) != 0) {
      v598 = (llvm::Value **)*(v595 - 1);
    }
    else {
      v598 = (llvm::Value **)&v595[-4 * (v597 & 0x7FFFFFF)];
    }
    int v656 = v30;
    v602 = *v598;
    v603 = (llvm::BasicBlock *)v595[5];
    p_src = 0;
    v726 = 0;
    LODWORD(v727) = 0;
    v604 = (void *)*((void *)v603 + 5);
    if (v604 != (void *)((char *)v603 + 40))
    {
      if (v604) {
        v605 = v604 - 3;
      }
      else {
        v605 = 0;
      }
      if (*((unsigned char *)v605 + 16) != 30)
      {
        int v643 = 2;
        switch(*((unsigned char *)v605 + 16))
        {
          case 0x1E:
            __break(1u);
            goto LABEL_1143;
          case 0x1F:
            int v643 = (*((_DWORD *)v605 + 5) >> 1) & 0x3FFFFFF;
            goto LABEL_1100;
          case 0x20:
          case 0x26:
            int v643 = (*((_DWORD *)v605 + 5) & 0x7FFFFFF) - 1;
            goto LABEL_1100;
          case 0x21:
            goto LABEL_1040;
          case 0x24:
            int v643 = *((_WORD *)v605 + 9) & 1;
            goto LABEL_1100;
          case 0x25:
            int v643 = 1;
            goto LABEL_1040;
          case 0x27:
            int v643 = *((_DWORD *)v605 + 20) + 1;
LABEL_1100:
            if (!v643) {
              goto LABEL_1042;
            }
            goto LABEL_1040;
          default:
            goto LABEL_1042;
        }
      }
      if ((*((_DWORD *)v605 + 5) & 0x7FFFFFF) == 3) {
        int v643 = 2;
      }
      else {
        int v643 = 1;
      }
LABEL_1040:
      for (unsigned int j = 0; j != v643; ++j)
      {
        uint64_t Successor = (const char **)llvm::Instruction::getSuccessor((llvm::Instruction *)v605, j);
        uint64_t v607 = sub_1CCD30E9C((uint64_t)&p_src, (uint64_t *)&Successor);
        ++*(_DWORD *)(v607 + 8);
      }
    }
LABEL_1042:
    uint64_t Successor = (const char **)v595;
    LOBYTE(v692) = 0;
    v697[0] = 0;
    char v698 = 0;
    llvm::SwitchInstProfUpdateWrapper::init((llvm::SwitchInstProfUpdateWrapper **)&Successor, (const llvm::SwitchInst *)v16);
    v608 = (llvm::SwitchInstProfUpdateWrapper *)Successor;
    int v609 = (*((_DWORD *)Successor + 5) >> 1) & 0x3FFFFFF;
    uint64_t v610 = (v609 - 1);
    if (v609 == 1)
    {
      sub_1CCD3104C((uint64_t)&Successor);
      goto LABEL_1078;
    }
    char v611 = 0;
    uint64_t v612 = 0;
LABEL_1044:
    unsigned int v613 = 2 * v612 + 3;
    do
    {
      int v614 = *((_DWORD *)v608 + 5);
      if ((v614 & 0x40000000) != 0) {
        v615 = (char *)*((void *)v608 - 1);
      }
      else {
        v615 = (char *)v608 - 32 * (v614 & 0x7FFFFFF);
      }
      v616 = *(const char ****)&v615[32 * ((v613 - 1) & 0xFFFFFFFE)];
      int v617 = llvm::LazyValueInfo::getPredicateAt(a2, 32, v602, (llvm::Constant *)v616, (llvm::Instruction *)v595, 1);
      if (v617 == 1)
      {
        int v627 = *((_DWORD *)Successor + 5);
        if ((v627 & 0x40000000) != 0) {
          v628 = (const char **)*(Successor - 1);
        }
        else {
          v628 = &Successor[-4 * (v627 & 0x7FFFFFF)];
        }
        if (*v628)
        {
          *(void *)v628[2] = v628[1];
          v644 = v628[1];
          if (v644) {
            *((void *)v644 + 2) = v628[2];
          }
        }
        *v628 = (const char *)v616;
        if (v616)
        {
          v631 = (const char *)v616[1];
          v630 = v616 + 1;
          v629 = v631;
          v628[1] = v631;
          if (v631) {
            *((void *)v629 + 2) = v628 + 1;
          }
          v628[2] = (const char *)v630;
          *v630 = v628;
        }
LABEL_1065:
        sub_1CCD3104C((uint64_t)&Successor);
LABEL_1076:
        llvm::ConstantFoldTerminator(v603, 0, 0, (uint64_t)&p_p_src);
        LODWORD(v610) = 1;
        goto LABEL_1078;
      }
      if (!v617)
      {
        unint64_t v686 = 0;
        int v618 = *((_DWORD *)v608 + 5);
        if ((v618 & 0x40000000) != 0) {
          v619 = (char *)*((void *)v608 - 1);
        }
        else {
          v619 = (char *)v608 - 32 * (v618 & 0x7FFFFFF);
        }
        uint64_t v620 = v613;
        if (v612 == -2) {
          uint64_t v620 = 1;
        }
        unint64_t v621 = *(void *)&v619[32 * v620];
        unint64_t v686 = v621;
        llvm::BasicBlock::removePredecessor((llvm::Type *)v621, v603, 0);
        if (v697[0])
        {
          char v698 = 1;
          *(_DWORD *)(v692 + 4 * (v612 + 1)) = *(_DWORD *)(v692 + 4 * v693 - 4);
          LODWORD(v693) = v693 - 1;
        }
        v608 = (llvm::SwitchInstProfUpdateWrapper *)llvm::SwitchInst::removeCase((uint64_t)Successor, (uint64_t)v608, v612);
        uint64_t v612 = v622;
        unsigned int v623 = *((_DWORD *)Successor + 5);
        if ((v623 & 0x40000000) != 0) {
          v624 = (llvm::Value **)*(Successor - 1);
        }
        else {
          v624 = (llvm::Value **)&Successor[-4 * (v623 & 0x7FFFFFF)];
        }
        v602 = *v624;
        uint64_t v625 = sub_1CCD30E9C((uint64_t)&p_src, (uint64_t *)&v686);
        int v626 = *(_DWORD *)(v625 + 8) - 1;
        *(_DWORD *)(v625 + 8) = v626;
        if (!v626)
        {
          __src = v603;
          uint64_t v688 = v621 | 4;
          llvm::DomTreeUpdater::applyUpdatesPermissive((uint64_t)&p_p_src, (uint64_t *)&__src, 1);
        }
        uint64_t v610 = ((v623 >> 1) & 0x3FFFFFF) - 1;
        char v611 = 1;
        if (v612 == v610) {
          goto LABEL_1065;
        }
        goto LABEL_1044;
      }
      ++v612;
      v613 += 2;
    }
    while (v610 != v612);
    sub_1CCD3104C((uint64_t)&Successor);
    if (v611) {
      goto LABEL_1076;
    }
    LODWORD(v610) = 0;
LABEL_1078:
    MEMORY[0x1D25D9CD0](p_src, 8);
    sub_1CC2930C0((uint64_t)&p_p_src);
    int v30 = v656 | v610;
LABEL_1079:
    int v21 = v653 | v30;
    sub_1CC0D3E0C((uint64_t)&v664);
  }
LABEL_1121:
  if (v661)
  {
    v662 = v661;
    operator delete(v661);
  }
  if (v659 != v660) {
    free(v659);
  }
  if (__p)
  {
    v671 = (char *)__p;
    operator delete(__p);
  }
  if (v665 != v664) {
    free(v665);
  }
  if (v684)
  {
    v685 = v684;
    operator delete(v684);
  }
  if (v681 != v680) {
    free(v681);
  }
  if (v678)
  {
    v679 = v678;
    operator delete(v678);
  }
  if (v674 != v673) {
    free(v674);
  }
  return v21 & 1;
}

void sub_1CCD2FFB4()
{
}

void sub_1CCD2FFF4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD3002C(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LazyValueInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::LazyValueInfoWrapperPass::ID);
}

uint64_t sub_1CCD300C4(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::LazyValueInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::LazyValueInfo *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::LazyValueInfoWrapperPass::ID)+ 32);
  unsigned int v10 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_11:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  int v14 = (llvm::DominatorTree *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::DominatorTreeWrapperPass::ID)+ 32);
  llvm::getBestSimplifyQuery(a1, (llvm::Pass *)a2, (uint64_t)v15);
  return sub_1CCD2B67C((uint64_t)a2, v9, v14, (uint64_t)v15);
}

uint64_t sub_1CCD30204(llvm::Instruction *a1, llvm::LazyValueInfo *this)
{
  v108[1] = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(*(void *)a1 + 8) & 0xFE) == 0x12) {
    return 0;
  }
  int v4 = *((_DWORD *)a1 + 5);
  if ((v4 & 0x40000000) != 0)
  {
    uint64_t v6 = (llvm::Value **)*((void *)a1 - 1);
    unint64_t v5 = v4 & 0x7FFFFFF;
    if (!v5) {
      goto LABEL_21;
    }
  }
  else
  {
    unint64_t v5 = v4 & 0x7FFFFFF;
    uint64_t v6 = (llvm::Value **)((char *)a1 - 32 * v5);
    if (!v5) {
      goto LABEL_21;
    }
  }
  LODWORD(v7) = 0;
  uint64_t v8 = 32 * v5;
  do
  {
    llvm::LazyValueInfo::getConstantRange(this, *v6, a1, 1, (unint64_t *)&v92);
    unsigned int ActiveBits = llvm::ConstantRange::getActiveBits((llvm::ConstantRange *)&v92);
    if (ActiveBits <= v7) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = ActiveBits;
    }
    if (v95 >= 0x41 && v94) {
      MEMORY[0x1D25D9CB0](v94, 0x1000C8000313F17);
    }
    if (v93 >= 0x41 && v92) {
      MEMORY[0x1D25D9CB0](v92, 0x1000C8000313F17);
    }
    v6 += 4;
    v8 -= 32;
  }
  while (v8);
  if (v7)
  {
    unint64_t v10 = (v7 - 1) | ((unint64_t)(v7 - 1) >> 1) | (((v7 - 1) | ((unint64_t)(v7 - 1) >> 1)) >> 2);
    unint64_t v5 = v10 | (v10 >> 4) | ((v10 | (v10 >> 4)) >> 8);
    LODWORD(v5) = ((v5 >> 16) | v5) + 1;
  }
  else
  {
    LODWORD(v5) = 0;
  }
LABEL_21:
  if (v5 <= 8) {
    uint64_t v11 = 8;
  }
  else {
    uint64_t v11 = v5;
  }
  if (v11 < *(_DWORD *)(*(void *)a1 + 8) >> 8)
  {
    uint64_t v13 = 0;
    uint64_t v14 = **(void **)a1;
    int v92 = &v94;
    uint64_t v93 = 0x200000000;
    uint64_t v98 = v14;
    uint64_t v99 = &v107;
    uint64_t v100 = v108;
    uint64_t v101 = 0;
    int v102 = 0;
    __int16 v103 = 512;
    char v104 = 7;
    uint64_t v105 = 0;
    uint64_t v106 = 0;
    uint64_t v107 = &unk_1F2616E88;
    v108[0] = &unk_1F2617008;
    unsigned int v15 = (unsigned __int8 *)*((void *)a1 + 6);
    uint64_t v96 = *((void *)a1 + 5);
    int v97 = (char *)a1 + 24;
    v86[0] = v15;
    if (v15)
    {
      llvm::MetadataTracking::track((uint64_t)v86, v15, 2);
      uint64_t v13 = v86[0];
    }
    sub_1CB8461A4((uint64_t)&v92, 0, v13);
    if (!v86[0])
    {
LABEL_29:
      uint64_t v17 = (llvm::Type ***)llvm::IntegerType::get(**(llvm::IntegerType ***)a1, (llvm::LLVMContext *)v11);
      uint64_t v18 = (llvm::CastInst *)*((void *)a1 - 8);
      unsigned int v19 = a1 >> 4;
      if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
      {
        uint64_t v20 = ***(void ***)a1;
        uint64_t v21 = *(void *)(v20 + 152);
        uint64_t v22 = *(unsigned int *)(v20 + 168);
        if (v22)
        {
          LODWORD(v23) = (v22 - 1) & (v19 ^ (a1 >> 9));
          uint64_t v24 = v21 + 16 * v23;
          int v25 = *(llvm::Instruction **)v24;
          if (*(llvm::Instruction **)v24 != a1)
          {
            int v26 = 1;
            do
            {
              if (v25 == (llvm::Instruction *)-4096) {
                goto LABEL_36;
              }
              int v27 = v23 + v26++;
              uint64_t v23 = v27 & (v22 - 1);
              int v25 = *(llvm::Instruction **)(v21 + 16 * v23);
            }
            while (v25 != a1);
            uint64_t v24 = v21 + 16 * v23;
          }
        }
        else
        {
LABEL_36:
          uint64_t v24 = v21 + 16 * v22;
        }
        uint64_t v28 = *(void **)(v24 + 8);
        uint64_t v31 = *v28;
        unsigned int v29 = (const char *)(v28 + 2);
        uint64_t v30 = v31;
      }
      else
      {
        uint64_t v30 = 0;
        unsigned int v29 = &byte_1CFBCE98E;
      }
      __int16 v91 = 773;
      uint64_t v88 = v29;
      uint64_t v89 = v30;
      char v90 = ".lhs.trunc";
      int v33 = sub_1CD5AB4EC((uint64_t)&v92, v18, v17, (uint64_t)&v88, v16);
      int v34 = (llvm::CastInst *)*((void *)a1 - 4);
      if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
      {
        uint64_t v35 = ***(void ***)a1;
        uint64_t v36 = *(void *)(v35 + 152);
        uint64_t v37 = *(unsigned int *)(v35 + 168);
        if (v37)
        {
          LODWORD(v38) = (v37 - 1) & (v19 ^ (a1 >> 9));
          uint64_t v39 = v36 + 16 * v38;
          unint64_t v40 = *(llvm::Instruction **)v39;
          if (*(llvm::Instruction **)v39 != a1)
          {
            int v41 = 1;
            do
            {
              if (v40 == (llvm::Instruction *)-4096) {
                goto LABEL_45;
              }
              int v42 = v38 + v41++;
              uint64_t v38 = v42 & (v37 - 1);
              unint64_t v40 = *(llvm::Instruction **)(v36 + 16 * v38);
            }
            while (v40 != a1);
            uint64_t v39 = v36 + 16 * v38;
          }
        }
        else
        {
LABEL_45:
          uint64_t v39 = v36 + 16 * v37;
        }
        int v43 = *(void **)(v39 + 8);
        uint64_t v46 = *v43;
        unint64_t v44 = (const char *)(v43 + 2);
        uint64_t v45 = v46;
      }
      else
      {
        uint64_t v45 = 0;
        unint64_t v44 = &byte_1CFBCE98E;
      }
      __int16 v91 = 773;
      uint64_t v88 = v44;
      uint64_t v89 = v45;
      char v90 = ".rhs.trunc";
      uint64_t v47 = sub_1CD5AB4EC((uint64_t)&v92, v34, v17, (uint64_t)&v88, v32);
      uint64_t v48 = *((unsigned __int8 *)a1 + 16) - 28;
      if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
      {
        uint64_t v49 = ***(void ***)a1;
        uint64_t v50 = *(void *)(v49 + 152);
        uint64_t v51 = *(unsigned int *)(v49 + 168);
        if (v51)
        {
          LODWORD(v52) = (v51 - 1) & (v19 ^ (a1 >> 9));
          uint64_t v53 = v50 + 16 * v52;
          uint64_t v54 = *(llvm::Instruction **)v53;
          if (*(llvm::Instruction **)v53 != a1)
          {
            int v55 = 1;
            do
            {
              if (v54 == (llvm::Instruction *)-4096) {
                goto LABEL_54;
              }
              int v56 = v52 + v55++;
              uint64_t v52 = v56 & (v51 - 1);
              uint64_t v54 = *(llvm::Instruction **)(v50 + 16 * v52);
            }
            while (v54 != a1);
            uint64_t v53 = v50 + 16 * v52;
          }
        }
        else
        {
LABEL_54:
          uint64_t v53 = v50 + 16 * v51;
        }
        uint64_t v57 = *(void **)(v53 + 8);
        uint64_t v60 = *v57;
        uint64_t v58 = (const char *)(v57 + 2);
        uint64_t v59 = v60;
      }
      else
      {
        uint64_t v59 = 0;
        uint64_t v58 = &byte_1CFBCE98E;
      }
      __int16 v91 = 261;
      uint64_t v88 = v58;
      uint64_t v89 = v59;
      unint64_t v61 = sub_1CB844E98((uint64_t)&v92, v48, (uint64_t)v33, (uint64_t)v47, (uint64_t)&v88, 0);
      int v62 = v61;
      int v63 = *(uint64_t ***)a1;
      if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
      {
        uint64_t v64 = **v63;
        uint64_t v65 = *(void *)(v64 + 152);
        uint64_t v66 = *(unsigned int *)(v64 + 168);
        if (v66)
        {
          LODWORD(v67) = (v66 - 1) & (v19 ^ (a1 >> 9));
          uint64_t v68 = v65 + 16 * v67;
          uint64_t v69 = *(llvm::Instruction **)v68;
          if (*(llvm::Instruction **)v68 != a1)
          {
            int v70 = 1;
            do
            {
              if (v69 == (llvm::Instruction *)-4096) {
                goto LABEL_63;
              }
              int v71 = v67 + v70++;
              uint64_t v67 = v71 & (v66 - 1);
              uint64_t v69 = *(llvm::Instruction **)(v65 + 16 * v67);
            }
            while (v69 != a1);
            uint64_t v68 = v65 + 16 * v67;
          }
        }
        else
        {
LABEL_63:
          uint64_t v68 = v65 + 16 * v66;
        }
        uint64_t v72 = *(void **)(v68 + 8);
        uint64_t v75 = *v72;
        uint64_t v73 = (char *)(v72 + 2);
        uint64_t v74 = v75;
      }
      else
      {
        uint64_t v74 = 0;
        uint64_t v73 = &byte_1CFBCE98E;
      }
      __int16 v87 = 773;
      v86[0] = v73;
      v86[1] = v74;
      v86[2] = ".zext";
      int v76 = (unsigned __int8 *)v61;
      if (*(uint64_t ***)v61 != v63)
      {
        if (*((unsigned __int8 *)v61 + 16) <= 0x14u)
        {
          int v76 = (unsigned __int8 *)(*((uint64_t (**)(void **, uint64_t, llvm::Instruction *, uint64_t **))*v99
                                    + 28))(v99, 39, v61, v63);
          if (v76) {
            BOOL v79 = v76[16] >= 0x1Cu;
          }
          else {
            BOOL v79 = 0;
          }
          if (v79)
          {
            (*(void (**)(void *, unsigned __int8 *, void *, uint64_t, char *))(*v100 + 16))(v100, v76, v86, v96, v97);
            if (v93)
            {
              int v84 = (llvm::MDNode **)v92;
              uint64_t v85 = (llvm::MDNode **)((char *)v92 + 16 * v93);
              do
              {
                llvm::Instruction::setMetadata((llvm::Instruction *)v76, *(_DWORD *)v84, v84[1]);
                v84 += 2;
              }
              while (v84 != v85);
            }
          }
        }
        else
        {
          __int16 v91 = 257;
          int v76 = (unsigned __int8 *)llvm::CastInst::Create(39, (uint64_t)v61, (uint64_t)v63, &v88, 0);
          (*(void (**)(void *, unsigned __int8 *, void *, uint64_t, char *))(*v100 + 16))(v100, v76, v86, v96, v97);
          if (v93)
          {
            uint64_t v77 = (llvm::MDNode **)v92;
            uint64_t v78 = (llvm::MDNode **)((char *)v92 + 16 * v93);
            do
            {
              llvm::Instruction::setMetadata((llvm::Instruction *)v76, *(_DWORD *)v77, v77[1]);
              v77 += 2;
            }
            while (v77 != v78);
          }
        }
      }
      if (*((unsigned char *)v62 + 16) == 47) {
        *((unsigned char *)v62 + 17) = *((unsigned char *)v62 + 17) & 0xFD | *((unsigned char *)a1 + 17) & 2;
      }
      llvm::Value::doRAUW(a1, (llvm::Value *)v76, (llvm::Value *)1);
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    int v80 = *(unsigned __int8 *)v86[0];
    if ((v80 - 4) > 0x1E)
    {
      if ((v80 - 3) >= 0xFFFFFFFE) {
        uint64_t v83 = v86[0];
      }
      else {
        uint64_t v83 = 0;
      }
      if ((v80 - 3) < 0xFFFFFFFE)
      {
        if (v80 == 3) {
          *(void *)(v86[0] + 8) = 0;
        }
        goto LABEL_29;
      }
      unint64_t v82 = v83 + 8;
    }
    else
    {
      if ((*(unsigned char *)(v86[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v86[0] + 12)) {
        goto LABEL_29;
      }
      uint64_t v81 = *(void *)(v86[0] + 16);
      if ((v81 & 4) == 0) {
        goto LABEL_29;
      }
      unint64_t v82 = v81 & 0xFFFFFFFFFFFFFFF8;
      if (!v82) {
        goto LABEL_29;
      }
    }
    uint64_t v88 = (const char *)v86;
    sub_1CC5FA668(v82 + 16, &v88);
    goto LABEL_29;
  }
  return 0;
}

BOOL sub_1CCD30964(llvm::Instruction *a1, llvm::LazyValueInfo *this)
{
  if ((*(_DWORD *)(*(void *)a1 + 8) & 0xFE) == 0x12) {
    return 0;
  }
  int v3 = *((unsigned __int8 *)a1 + 17);
  if ((~v3 & 6) == 0) {
    return 0;
  }
  int v6 = *((unsigned __int8 *)a1 + 16) - 28;
  uint64_t v7 = (llvm::Value *)*((void *)a1 - 4);
  llvm::LazyValueInfo::getConstantRange(this, *((llvm::Value **)a1 - 8), a1, 1, &v25);
  llvm::LazyValueInfo::getConstantRange(this, v7, a1, 1, &v21);
  if ((v3 & 2) != 0)
  {
    BOOL v8 = 0;
  }
  else
  {
    llvm::ConstantRange::makeGuaranteedNoWrapRegion((llvm::APInt *)&v21, v6, 1, (uint64_t)&v17);
    BOOL v8 = llvm::ConstantRange::contains((llvm::ConstantRange *)&v17, (const llvm::ConstantRange *)&v25);
    if (v20 >= 0x41 && v19) {
      MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
    }
    if (v18 >= 0x41 && v17) {
      MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
    }
  }
  if ((v3 & 4) != 0)
  {
    unsigned int v15 = *((unsigned __int8 *)a1 + 16);
    BOOL v12 = v15 > 0x1B;
    if (v15 <= 0x1B) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = a1;
    }
    BOOL v4 = v8;
  }
  else
  {
    llvm::ConstantRange::makeGuaranteedNoWrapRegion((llvm::APInt *)&v21, v6, 2, (uint64_t)&v17);
    BOOL v9 = llvm::ConstantRange::contains((llvm::ConstantRange *)&v17, (const llvm::ConstantRange *)&v25);
    if (v20 >= 0x41 && v19) {
      MEMORY[0x1D25D9CB0](v19, 0x1000C8000313F17);
    }
    BOOL v4 = v8 | v9;
    if (v18 >= 0x41 && v17) {
      MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
    }
    unsigned int v10 = *((unsigned __int8 *)a1 + 16);
    BOOL v11 = v10 > 0x1B;
    BOOL v12 = v10 > 0x1B;
    if (v10 <= 0x1B) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = a1;
    }
    if (v11 && v9)
    {
      *((unsigned char *)v13 + 17) |= 4u;
      BOOL v12 = 1;
      uint64_t v13 = a1;
    }
  }
  if (v8 && v12) {
    *((unsigned char *)v13 + 17) |= 2u;
  }
  if (v24 >= 0x41 && v23) {
    MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
  }
  if (v22 >= 0x41 && v21) {
    MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
  }
  if (v28 >= 0x41 && v27) {
    MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
  }
  if (v26 >= 0x41 && v25) {
    MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
  }
  return v4;
}

BOOL sub_1CCD30C24(llvm::Value **a1, llvm::LazyValueInfo *this)
{
  llvm::LazyValueInfo::getConstantRange(this, a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)], (llvm::Instruction *)a1, 1, &v20);
  llvm::LazyValueInfo::getConstantRange(this, a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF) + 4], (llvm::Instruction *)a1, 1, &v16);
  int v4 = 13;
  unsigned int v5 = *((_DWORD *)*(a1 - 4) + 9) - 262;
  if (((1 << (*((unsigned char *)*(a1 - 4) + 36) - 6)) & 0xC000000003) == 0)
  {
    if (((1 << v5) & 0x6000000600000) != 0) {
      int v4 = 15;
    }
    else {
      int v4 = 17;
    }
  }
  BOOL v6 = v5 > 0x16;
  int v7 = (1 << v5) & 0x610003;
  if (v6 || v7 == 0) {
    int v9 = 1;
  }
  else {
    int v9 = 2;
  }
  llvm::ConstantRange::makeGuaranteedNoWrapRegion((llvm::APInt *)&v16, v4, v9, (uint64_t)&v12);
  BOOL v10 = llvm::ConstantRange::contains((llvm::ConstantRange *)&v12, (const llvm::ConstantRange *)&v20);
  if (v15 >= 0x41 && v14) {
    MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
  }
  if (v13 >= 0x41 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8000313F17);
  }
  if (v19 >= 0x41 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  if (v17 >= 0x41 && v16) {
    MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
  }
  if (v23 >= 0x41 && v22) {
    MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
  }
  if (v21 >= 0x41 && v20) {
    MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
  }
  return v10;
}

unint64_t sub_1CCD30E34(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) == 84
    && (uint64_t v1 = *(void *)(a1 - 32)) != 0
    && !*(unsigned char *)(v1 + 16)
    && *(void *)(v1 + 24) == *(void *)(a1 + 72)
    && (*(unsigned char *)(v1 + 33) & 0x20) != 0
    && (unsigned int v2 = *(_DWORD *)(v1 + 36) - 262, v2 <= 0x31))
  {
    return (0x2004000200001uLL >> v2) & 1;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1CCD30E9C(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CC137310(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CCD30F80(a1, v7);
    uint64_t v8 = 0;
    sub_1CC137310(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)result != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)uint64_t result = *a2;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

void *sub_1CCD30F80(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD761570(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CCD3104C(uint64_t result)
{
  if (*(unsigned char *)(result + 64))
  {
    uint64_t v1 = *(llvm::Instruction **)result;
    uint64_t v4 = result;
    unsigned int v2 = llvm::SwitchInstProfUpdateWrapper::buildProfBranchWeightsMD((llvm::SwitchInstProfUpdateWrapper *)result);
    llvm::Instruction::setMetadata(v1, 2, v2);
    uint64_t result = v4;
  }
  if (*(unsigned char *)(result + 56))
  {
    uint64_t v3 = result;
    if (*(void *)(result + 8) != result + 24) {
      free(*(void **)(result + 8));
    }
    uint64_t result = v3;
    *(unsigned char *)(v3 + 56) = 0;
  }
  return result;
}

uint64_t sub_1CCD310CC()
{
  char v3 = 1;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Enables canonicalization of signed relational predicates to unsigned (e.g. sgt => ugt)";
  v1.n128_u64[1] = 86;
  sub_1CD761620(&v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF0D08, &dword_1CB82C000);
}

void sub_1CCD31140()
{
}

uint64_t sub_1CCD311DC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0DE0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D818;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF0DE8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD31140;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF0DE8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD3128C(uint64_t a1, uint64_t *a2)
{
  v30[16] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 1;
  uint64_t v3 = 8;
  int64x2_t v4 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)((char *)&v25 + v3) = v4;
    v3 += 16;
  }
  while (v3 != 136);
  unsigned int v28 = v30;
  uint64_t v29 = 0x1000000000;
  uint64_t v5 = a1 + 72;
  for (uint64_t i = *(void *)(a1 + 80); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v5)
    {
      LOBYTE(v9) = 0;
      goto LABEL_39;
    }
    uint64_t v7 = i - 24;
    if (!i) {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(void *)(v7 + 48);
    if (v8 != v7 + 40) {
      break;
    }
  }
  int v9 = 0;
  do
  {
    uint64_t v10 = v8;
    uint64_t v8 = *(void *)(v8 + 8);
    uint64_t v11 = i - 24;
    if (!i) {
      uint64_t v11 = 0;
    }
    if (v8 == v11 + 40)
    {
      uint64_t v20 = *(void *)(i + 8);
      uint64_t i = v5;
      if (v20 != v5)
      {
        while (1)
        {
          uint64_t v21 = v20 - 24;
          if (!v20) {
            uint64_t v21 = 0;
          }
          uint64_t v8 = *(void *)(v21 + 48);
          if (v8 != v21 + 40) {
            break;
          }
          uint64_t v20 = *(void *)(v20 + 8);
          if (v20 == v5)
          {
            uint64_t i = v5;
            goto LABEL_13;
          }
        }
        uint64_t i = v20;
      }
    }
LABEL_13:
    if (v10) {
      uint64_t v12 = v10 - 24;
    }
    else {
      uint64_t v12 = 0;
    }
    if (v25)
    {
      int v13 = 16;
      uint64_t v14 = &v26;
    }
    else
    {
      int v13 = v27;
      if (!v27) {
        goto LABEL_25;
      }
      uint64_t v14 = v26;
    }
    int v15 = v13 - 1;
    unsigned int v16 = v15 & ((v12 >> 4) ^ (v12 >> 9));
    uint64_t v17 = v14[v16];
    if (v12 == v17) {
      continue;
    }
    int v18 = 1;
    while (v17 != -4096)
    {
      unsigned int v19 = v16 + v18++;
      unsigned int v16 = v19 & v15;
      uint64_t v17 = v14[v16];
      if (v12 == v17) {
        goto LABEL_26;
      }
    }
LABEL_25:
    v9 |= sub_1CCD3175C(v12, (uint64_t)&v25, a2);
LABEL_26:
    ;
  }
  while (i != v5);
  while (v29)
  {
    uint64_t v22 = (char *)v28 + 8 * v29;
    uint64_t v23 = *((void *)v22 - 1);
    sub_1CBFD6090((uint64_t)&v25, (void *)v22 - 1);
    LODWORD(v29) = v29 - 1;
    v9 |= sub_1CCD3175C(v23, (uint64_t)&v25, a2);
  }
LABEL_39:
  if (v28 != v30) {
    free(v28);
  }
  if ((v25 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v26, 8);
  }
  return v9 & 1;
}

void sub_1CCD314DC()
{
}

uint64_t sub_1CCD31578(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0DE1;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D8B8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF0DF0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD314DC;
    v5[1] = &PassRegistry;
    int64x2_t v4 = v5;
    std::__call_once(&qword_1EBCF0DF0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCD31628()
{
}

void sub_1CCD31668(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD316A0(llvm::PassRegistry *a1, uint64_t a2)
{
  v3[0] = &unk_1F2617E40;
  v3[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v3);
}

uint64_t sub_1CCD316EC(llvm::FunctionPass *a1, uint64_t a2)
{
  if ((llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2) & 1) != 0
    || (uint64_t v4 = a2 + 72, v5 = *(void *)(a2 + 80), v5 == v4))
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    int v6 = 0;
    do
    {
      if (v5) {
        uint64_t v7 = (llvm *)(v5 - 24);
      }
      else {
        uint64_t v7 = 0;
      }
      v6 |= llvm::RemoveRedundantDbgInstrs(v7, v3);
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != v4);
  }
  return v6 & 1;
}

uint64_t sub_1CCD3175C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  v36[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 8)) {
    return 0;
  }
  uint64_t result = llvm::wouldInstructionBeTriviallyDead(a1, a3);
  if (result)
  {
    int v34 = v36;
    uint64_t v35 = 0x100000000;
    llvm::findDbgUsers((uint64_t)&v34, (uint64_t ***)a1);
    llvm::salvageDebugInfoForDbgValues((llvm::CastInst *)a1, (uint64_t *)v34, v35);
    if (v34 != v36) {
      free(v34);
    }
    llvm::salvageKnowledge((llvm *)a1, 0, 0, v7, v8, v9, v10);
    int v11 = *(_DWORD *)(a1 + 20);
    uint64_t v12 = v11 & 0x7FFFFFF;
    if ((v11 & 0x7FFFFFF) == 0) {
LABEL_49:
    }
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    uint64_t v13 = 0;
    while (1)
    {
      int v14 = *(_DWORD *)(a1 + 20);
      if ((v14 & 0x40000000) != 0) {
        uint64_t v15 = *(void *)(a1 - 8);
      }
      else {
        uint64_t v15 = a1 - 32 * (v14 & 0x7FFFFFF);
      }
      uint64_t v16 = v15 + 32 * v13;
      uint64_t v17 = *(void *)v16;
      if (*(void *)v16)
      {
        **(void **)(v16 + 16) = *(void *)(v16 + 8);
        uint64_t v18 = *(void *)(v16 + 8);
        if (v18) {
          *(void *)(v18 + 16) = *(void *)(v16 + 16);
        }
      }
      *(void *)uint64_t v16 = 0;
      if (v17 == a1 || *(void *)(v17 + 8) != 0) {
        goto LABEL_25;
      }
      uint64_t v20 = *(unsigned __int8 *)(v17 + 16) <= 0x1Bu ? 0 : (void *)v17;
      int v34 = v20;
      if (!v20 || v20[1] || !llvm::wouldInstructionBeTriviallyDead((uint64_t)v20, a3)) {
        goto LABEL_25;
      }
      if (*(unsigned char *)a2)
      {
        int v21 = 16;
        uint64_t v22 = a2 + 8;
      }
      else
      {
        int v21 = *(_DWORD *)(a2 + 16);
        if (!v21)
        {
          uint64_t v31 = 0;
LABEL_44:
          uint64_t v32 = sub_1CBFD5BBC(a2, (uint64_t)&v34, &v34, v31);
          void *v32 = v34;
          unint64_t v33 = *(unsigned int *)(a2 + 144);
          if (v33 >= *(unsigned int *)(a2 + 148)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a2 + 136) + 8 * v33) = v34;
          ++*(_DWORD *)(a2 + 144);
          goto LABEL_25;
        }
        uint64_t v22 = *(void *)(a2 + 8);
      }
      int v23 = v21 - 1;
      unsigned int v24 = ((v34 >> 4) ^ (v34 >> 9)) & v23;
      uint64_t v25 = (void *)(v22 + 8 * v24);
      unsigned int v26 = (void *)*v25;
      if (v34 != (void *)*v25)
      {
        int v27 = 0;
        int v28 = 1;
        while (v26 != (void *)-4096)
        {
          if (v27) {
            BOOL v29 = 0;
          }
          else {
            BOOL v29 = v26 == (void *)-8192;
          }
          if (v29) {
            int v27 = v25;
          }
          unsigned int v30 = v24 + v28++;
          unsigned int v24 = v30 & v23;
          uint64_t v25 = (void *)(v22 + 8 * v24);
          unsigned int v26 = (void *)*v25;
          if (v34 == (void *)*v25) {
            goto LABEL_25;
          }
        }
        if (v27) {
          uint64_t v31 = v27;
        }
        else {
          uint64_t v31 = v25;
        }
        goto LABEL_44;
      }
LABEL_25:
      if (++v13 == v12) {
        goto LABEL_49;
      }
    }
  }
  return result;
}

void sub_1CCD31A1C()
{
}

void sub_1CCD31A5C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD31A94(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
}

uint64_t sub_1CCD31AFC(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2) & 1) == 0)
  {
    uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(char **)v6 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    int v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    int v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    int v21 = 0;
    uint64_t v10 = v9 + 32;
    if (!*(unsigned char *)(v9 + 232))
    {
      uint64_t v11 = *(void *)(a2 + 40) + 216;
      __int16 v23 = 260;
      v22[0] = v11;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v22);
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      int v35 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      *(void *)&long long v12 = -1;
      *((void *)&v12 + 1) = -1;
      *(_OWORD *)__src = v12;
      long long v27 = v12;
      long long v28 = v12;
      long long v29 = v12;
      long long v30 = v12;
      long long v31 = v12;
      *(_OWORD *)uint64_t v32 = v12;
      *(void *)&v32[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v10, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v10);
  }
  return 0;
}

uint64_t sub_1CCD31E44()
{
  uint64_t result = sub_1CBF64200((llvm::DebugCounter *)"dce-transform", 0xDuLL, "Controls which instructions are eliminated", 0x2AuLL);
  dword_1EBCF0DD8 = result;
  return result;
}

void llvm::DSEPass::run()
{
}

uint64_t sub_1CCD320DC(llvm *a1, uint64_t a2, llvm::MemorySSA *this, llvm::DominatorTree *a4, size_t a5, llvm::AssumptionCache *a6, uint64_t *a7, const llvm::Function *a8)
{
  v734[2] = *MEMORY[0x1E4F143B8];
  llvm::MemorySSA::ensureOptimizedUses(this);
  v633[0] = a1;
  v633[1] = a2;
  v634[0] = &unk_1F2600D90;
  v634[1] = a4;
  uint64_t v636 = 0;
  v634[2] = a8;
  uint64_t v635 = 0;
  int v637 = 0;
  v638[1] = 0;
  v638[0] = 0;
  int v639 = 0;
  v640 = &v676;
  uint64_t v641 = a2;
  uint64_t v642 = 1;
  uint64_t v15 = 14;
  do
  {
    uint64_t v16 = &v633[v15];
    *(_OWORD *)uint64_t v16 = xmmword_1CFAC3060;
    *((_OWORD *)v16 + 1) = xmmword_1CFAC3060;
    v15 += 5;
  }
  while (v16 + 5 != v644);
  v644[0] = v634;
  v644[1] = 0;
  v645 = v647;
  uint64_t v646 = 0x400000000;
  v647[16] = &unk_1F2600DB8;
  uint64_t v648 = 1;
  for (uint64_t i = 76; i != 92; i += 2)
    v633[i] = -4096;
  unsigned int v650 = this;
  v651 = a4;
  size_t v652 = a5;
  int v653 = a7;
  int v654 = (llvm::Value *)(*((void *)a1 + 5) + 272);
  int v655 = a8;
  v657 = v659;
  uint64_t v658 = 0x4000000000;
  v660 = v664;
  v661 = v664;
  uint64_t v662 = 4;
  int v663 = 0;
  long long v665 = 0u;
  int v666 = 0;
  long long v667 = 0u;
  int v668 = 0;
  v669 = v673;
  v670 = v673;
  uint64_t v671 = 16;
  int v672 = 0;
  long long v674 = 0u;
  unsigned int v675 = 0;
  unsigned int v676 = &v680;
  int v677 = &v680;
  uint64_t v678 = 32;
  int v679 = 0;
  int v682 = 0;
  long long v681 = 0u;
  uint64_t v685 = 0;
  unsigned int v683 = 0;
  v684 = 0;
  *(void *)&long long v694 = a1;
  sub_1CCD3822C((uint64_t)&v694, (uint64_t)v712);
  uint64_t v19 = &v696;
  *(void *)&long long v694 = &v696;
  uint64_t v20 = v712[1];
  v605 = a4;
  unsigned int v613 = a1;
  size_t v611 = a5;
  int v609 = a8;
  if (v712[1] == v712[0])
  {
    *((void *)&v694 + 1) = &v696;
    int v21 = v712[1];
  }
  else
  {
    int v592 = (int)v712[2];
    uint64_t v19 = (long long *)malloc_type_malloc(8 * LODWORD(v712[2]), 0x4065EBACuLL);
    if (!v19)
    {
      if (v592) {
        goto LABEL_1339;
      }
      uint64_t v19 = (long long *)malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v19) {
        goto LABEL_1339;
      }
    }
    *((void *)&v694 + 1) = v19;
    int v21 = v712[0];
    uint64_t v20 = v712[1];
  }
  unsigned int v22 = HIDWORD(v712[2]);
  LODWORD(v695) = v712[2];
  if (v20 == v21) {
    unsigned int v23 = HIDWORD(v712[2]);
  }
  else {
    unsigned int v23 = v712[2];
  }
  if (v23)
  {
    memmove(v19, v20, 8 * v23);
    unsigned int v22 = HIDWORD(v712[2]);
  }
  unsigned int v24 = v716;
  *(void *)((char *)&v695 + 4) = __PAIR64__(v712[3], v22);
  unsigned int v703 = &v705;
  uint64_t v704 = 0x800000000;
  if (v716)
  {
    if (v716 >= 9) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(&v705, v715, 24 * v716);
    LODWORD(v704) = v24;
  }
  char v25 = &v689;
  *(void *)&long long v687 = &v689;
  unsigned int v26 = v722;
  if (v722 != v721)
  {
    unsigned int v593 = v723;
    char v25 = (long long *)malloc_type_malloc(8 * v723, 0x4065EBACuLL);
    if (v25 || !v593 && (char v25 = (long long *)malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      *((void *)&v687 + 1) = v25;
      long long v27 = v721;
      unsigned int v26 = v722;
      goto LABEL_17;
    }
LABEL_1339:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  *((void *)&v687 + 1) = &v689;
  long long v27 = v722;
LABEL_17:
  LODWORD(v688) = v723;
  unsigned int v28 = v724;
  if (v26 == v27) {
    unsigned int v29 = v724;
  }
  else {
    unsigned int v29 = v723;
  }
  if (v29)
  {
    memmove(v25, v26, 8 * v29);
    unsigned int v28 = v724;
  }
  *(void *)((char *)&v688 + 4) = __PAIR64__(v725, v28);
  v691 = v693;
  uint64_t v692 = 0x800000000;
  uint64_t v30 = v727;
  if (v727)
  {
    if (v727 >= 9uLL) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v693, v726, 24 * v727);
    LODWORD(v692) = v30;
  }
  int v31 = 0;
LABEL_26:
  if (v704 != v30) {
    goto LABEL_36;
  }
  if (v30)
  {
    uint64_t v32 = v691;
    uint64_t v33 = v703;
    while (1)
    {
      BOOL v34 = *(void *)v33 == *(void *)v32 && v33[4] == v32[4];
      if (!v34) {
        break;
      }
      v33 += 6;
      v32 += 6;
      if (v33 == (_DWORD *)((char *)v703 + 24 * v30)) {
        goto LABEL_132;
      }
    }
LABEL_36:
    *(void *)&v629[0] = 0;
    uint64_t v35 = *((void *)v703 + 3 * v704 - 3);
    *(void *)&v629[0] = v35;
    if (v675)
    {
      unsigned int v36 = ((v35 >> 4) ^ (v35 >> 9)) & (v675 - 1);
      long long v37 = (void *)(v674 + 16 * v36);
      uint64_t v38 = *v37;
      if (v35 == *v37)
      {
LABEL_51:
        *((_DWORD *)v37 + 2) = v31;
        uint64_t v44 = v35 + 40;
        for (uint64_t j = *(void *)(v35 + 48); ; uint64_t j = *(void *)(j + 8))
        {
          if (j == v44)
          {
            LODWORD(v704) = v704 - 1;
            if (v704) {
              sub_1CC82F454((llvm::SmallPtrSetImplBase *)&v694);
            }
            ++v31;
            uint64_t v30 = v692;
            goto LABEL_26;
          }
          if (j) {
            uint64_t v46 = j - 24;
          }
          else {
            uint64_t v46 = 0;
          }
          int v47 = *((_DWORD *)this + 10);
          if (!v47) {
            goto LABEL_62;
          }
          uint64_t v48 = *((void *)this + 3);
          unsigned int v49 = v47 - 1;
          uint64_t v50 = ((v46 >> 4) ^ (v46 >> 9)) & (v47 - 1);
          uint64_t v51 = *(void *)(v48 + 16 * v50);
          if (v46 != v51) {
            break;
          }
LABEL_61:
          uint64_t v54 = *(void *)(v48 + 16 * v50 + 8);
LABEL_63:
          int v55 = *(unsigned __int8 *)(v46 + 16);
          if (j && v55 == 84)
          {
            uint64_t v74 = *(void *)(v46 + 64);
            if (v74 && (*(unsigned char *)(v74 + 16) & 0x20) != 0) {
              goto LABEL_77;
            }
            int v57 = llvm::CallBase::hasFnAttrOnCalledFunction(v46, 37) ^ 1;
          }
          else
          {
            if (j && v55 == 36 || j && v55 == 38) {
              BOOL v56 = (*(_WORD *)(v46 + 18) & 1) == 0;
            }
            else {
              BOOL v56 = v55 == 34;
            }
            int v57 = v56;
          }
          if (v57) {
            BOOL v58 = v54 == 0;
          }
          else {
            BOOL v58 = 0;
          }
          if (!v58) {
            goto LABEL_77;
          }
          uint64_t v59 = *(void *)(v46 + 40);
          uint64_t v60 = (char *)v670;
          uint64_t v61 = HIDWORD(v671);
          if (v670 == v669)
          {
            if (HIDWORD(v671))
            {
              int v62 = 0;
              uint64_t v63 = 8 * HIDWORD(v671);
              uint64_t v64 = v670;
              while (*v64 != v59)
              {
                if (*v64 == -2) {
                  int v62 = v64;
                }
                ++v64;
                v63 -= 8;
                if (!v63)
                {
                  if (!v62) {
                    goto LABEL_92;
                  }
                  void *v62 = v59;
                  --v672;
                  goto LABEL_119;
                }
              }
LABEL_77:
              if (v54)
              {
                if (*(unsigned char *)(v54 + 16) == 26 && v658 < dword_1EBCF1248)
                {
                  sub_1CCD36F44(&v708, (uint64_t)v633, (llvm::Instruction *)v46);
                  if ((_BYTE)v711 || sub_1CCD36C14(v653, v46))
                  {
                    if (v658 >= (unint64_t)HIDWORD(v658)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v657 + v658) = v54;
                    LODWORD(v658) = v658 + 1;
                  }
                }
              }
              continue;
            }
LABEL_92:
            unsigned int v65 = v671;
            if (HIDWORD(v671) < v671)
            {
              ++HIDWORD(v671);
              *((void *)v670 + v61) = v59;
              continue;
            }
          }
          else
          {
            unsigned int v65 = v671;
          }
          if (3 * v65 <= 4 * (HIDWORD(v671) - v672))
          {
            if (v65 >= 0x40) {
              v65 *= 2;
            }
            else {
              unsigned int v65 = 128;
            }
          }
          else if (v65 - HIDWORD(v671) >= v65 >> 3)
          {
            goto LABEL_97;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v669, v65);
          unsigned int v65 = v671;
          uint64_t v60 = (char *)v670;
LABEL_97:
          unsigned int v66 = v65 - 1;
          unsigned int v67 = (v65 - 1) & ((v59 >> 4) ^ (v59 >> 9));
          uint64_t v68 = &v60[8 * v67];
          uint64_t v69 = *(void *)v68;
          if (*(void *)v68 == -1)
          {
            int v70 = 0;
LABEL_112:
            if (v70) {
              uint64_t v75 = v70;
            }
            else {
              uint64_t v75 = v68;
            }
            if (*(void *)v75 != v59)
            {
              if (*(void *)v75 == -2) {
                --v672;
              }
              else {
                ++HIDWORD(v671);
              }
              *(void *)uint64_t v75 = v59;
            }
          }
          else
          {
            int v70 = 0;
            int v71 = 1;
            while (v69 != v59)
            {
              if (v70) {
                BOOL v72 = 0;
              }
              else {
                BOOL v72 = v69 == -2;
              }
              if (v72) {
                int v70 = v68;
              }
              unsigned int v73 = v67 + v71++;
              unsigned int v67 = v73 & v66;
              uint64_t v68 = &v60[8 * (v73 & v66)];
              uint64_t v69 = *(void *)v68;
              if (*(void *)v68 == -1) {
                goto LABEL_112;
              }
            }
          }
LABEL_119:
          ;
        }
        int v52 = 1;
        while (v51 != -4096)
        {
          int v53 = v50 + v52++;
          uint64_t v50 = v53 & v49;
          uint64_t v51 = *(void *)(v48 + 16 * v50);
          if (v46 == v51) {
            goto LABEL_61;
          }
        }
LABEL_62:
        uint64_t v54 = 0;
        goto LABEL_63;
      }
      uint64_t v39 = 0;
      int v40 = 1;
      while (v38 != -4096)
      {
        if (v39) {
          BOOL v41 = 0;
        }
        else {
          BOOL v41 = v38 == -8192;
        }
        if (v41) {
          uint64_t v39 = v37;
        }
        unsigned int v42 = v36 + v40++;
        unsigned int v36 = v42 & (v675 - 1);
        long long v37 = (void *)(v674 + 16 * v36);
        uint64_t v38 = *v37;
        if (v35 == *v37) {
          goto LABEL_51;
        }
      }
      if (v39) {
        int v43 = v39;
      }
      else {
        int v43 = v37;
      }
    }
    else
    {
      int v43 = 0;
    }
    long long v37 = sub_1CBFAF8D8((uint64_t)&v674, (uint64_t)v629, (uint64_t *)v629, v43);
    *long long v37 = *(void *)&v629[0];
    *((_DWORD *)v37 + 2) = 0;
    uint64_t v35 = *(void *)&v629[0];
    goto LABEL_51;
  }
LABEL_132:
  if (v691 != v693) {
    free(v691);
  }
  if (*((void *)&v687 + 1) != (void)v687) {
    free(*((void **)&v687 + 1));
  }
  if (v703 != &v705) {
    free(v703);
  }
  if (*((void *)&v694 + 1) != (void)v694) {
    free(*((void **)&v694 + 1));
  }
  if (v726 != v728) {
    free(v726);
  }
  if (v722 != v721) {
    free(v722);
  }
  if (v715 != &v717) {
    free(v715);
  }
  if (v712[1] != v712[0]) {
    free(v712[1]);
  }
  if (*((_WORD *)v613 + 9))
  {
    llvm::Function::BuildLazyArguments(v613);
    int v76 = (llvm::Argument *)*((void *)v613 + 11);
    if (*((_WORD *)v613 + 9))
    {
      llvm::Function::BuildLazyArguments(v613);
      uint64_t v77 = (llvm::Argument *)*((void *)v613 + 11);
      goto LABEL_151;
    }
  }
  else
  {
    int v76 = (llvm::Argument *)*((void *)v613 + 11);
  }
  uint64_t v77 = v76;
LABEL_151:
  for (uint64_t k = (llvm::Argument *)((char *)v77 + 40 * *((void *)v613 + 12));
        v76 != k;
        int v76 = (llvm::Argument *)((char *)v76 + 40))
  {
    if (llvm::Argument::hasPassPointeeByValueCopyAttr(v76))
    {
      *(void *)&long long v694 = v76;
      BYTE8(v694) = 1;
      sub_1CCD38374((uint64_t)&v667, &v694, (unsigned char *)&v694 + 8, (uint64_t)v712);
    }
  }
  unsigned __int8 v656 = llvm::mayContainIrreducibleControl(v613, v609, v18);
  uint64_t v79 = *(unsigned int *)(v611 + 8);
  if (v79)
  {
    int v80 = *(uint64_t **)v611;
    uint64_t v81 = 8 * v79 - 8;
    do
    {
      uint64_t v82 = *v80++;
      uint64_t v83 = *(void *)(v82 + 40);
      if (v83) {
        uint64_t v84 = v83 - 24;
      }
      else {
        uint64_t v84 = 0;
      }
      if (*(unsigned __int8 *)(v84 + 16) - 29 >= 0xB) {
        uint64_t v84 = 0;
      }
      BOOL v85 = *(unsigned char *)(v84 + 16) == 35;
      BOOL v86 = v85 || v81 == 0;
      v81 -= 8;
    }
    while (!v86);
  }
  else
  {
    BOOL v85 = 0;
  }
  BOOL v686 = v85;
  llvm::CodeMetrics::collectEphemeralValues((int)v613, a6, (llvm::SmallPtrSetImplBase *)&v676);
  unint64_t v87 = v658;
  if (!v658)
  {
    unint64_t v87 = 0;
    char v612 = 0;
    goto LABEL_1039;
  }
  unint64_t v88 = 0;
  char v612 = 0;
  int64x2_t v604 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    uint64_t v89 = *((void *)v657 + v88);
    char v90 = v660;
    if (v661 == v660)
    {
      unsigned int v91 = HIDWORD(v662);
      int v92 = (char *)v661 + 8 * HIDWORD(v662);
      if (HIDWORD(v662))
      {
        uint64_t v93 = 0;
        while (*(void *)((char *)v661 + v93) != v89)
        {
          v93 += 8;
          if (8 * HIDWORD(v662) == v93) {
            goto LABEL_190;
          }
        }
        int v92 = (char *)v661 + v93;
      }
LABEL_190:
      char v90 = v661;
    }
    else
    {
      int v94 = v662 - 1;
      unsigned int v95 = (v662 - 1) & ((v89 >> 4) ^ (v89 >> 9));
      int v92 = (char *)v661 + 8 * v95;
      uint64_t v96 = *(void *)v92;
      if (*(void *)v92 == -1)
      {
        int v97 = 0;
LABEL_201:
        if (v97) {
          int v92 = v97;
        }
        unsigned int v91 = HIDWORD(v662);
        if (*(void *)v92 != v89) {
          int v92 = (char *)v661 + 8 * v662;
        }
      }
      else
      {
        int v97 = 0;
        int v98 = 1;
        while (v96 != v89)
        {
          if (v97) {
            BOOL v99 = 0;
          }
          else {
            BOOL v99 = v96 == -2;
          }
          if (v99) {
            int v97 = v92;
          }
          unsigned int v100 = v95 + v98++;
          unsigned int v95 = v100 & v94;
          int v92 = (char *)v661 + 8 * (v100 & v94);
          uint64_t v96 = *(void *)v92;
          if (*(void *)v92 == -1) {
            goto LABEL_201;
          }
        }
        unsigned int v91 = HIDWORD(v662);
      }
    }
    if (v661 == v90) {
      unsigned int v101 = v91;
    }
    else {
      unsigned int v101 = v662;
    }
    if (v92 != (char *)v661 + 8 * v101) {
      goto LABEL_941;
    }
    int v102 = *(llvm::Instruction **)(v89 + 72);
    if (sub_1CCD36C14(v653, (uint64_t)v102))
    {
      sub_1CCD36D34((uint64_t)v712, (uint64_t)v633, (uint64_t)v102);
      if (!v714) {
        goto LABEL_940;
      }
      char v103 = (char)v712[0];
      long long v631 = *(_OWORD *)((char *)v712 + 1);
      v632[0] = *(_OWORD *)((char *)&v712[2] + 1);
      *(_OWORD *)((char *)v632 + 15) = *(_OWORD *)&v712[4];
    }
    else
    {
      sub_1CCD36F44(v712, (uint64_t)v633, v102);
      char v103 = (char)v712[0];
      long long v631 = *(_OWORD *)((char *)v712 + 1);
      v632[0] = *(_OWORD *)((char *)&v712[2] + 1);
      *(_OWORD *)((char *)v632 + 15) = *(_OWORD *)&v712[4];
      if (!(_BYTE)v713) {
        goto LABEL_940;
      }
    }
    unint64_t v608 = v88;
    v624[0] = v103;
    *(_OWORD *)&v624[1] = v631;
    *(_OWORD *)uint64_t v625 = v632[0];
    *(_OWORD *)&v625[15] = *(_OWORD *)((char *)v632 + 15);
    UnderlyingObject = llvm::getUnderlyingObject(*(llvm **)v624, (const llvm::Value *)6);
    int v105 = dword_1EBCF1008;
    uint64_t v106 = dword_1EBCF10C8;
    int v107 = dword_1EBCF1188;
    v619[0] = 0;
    v619[1] = 0;
    int v620 = 0;
    uint64_t v622 = 0;
    uint64_t v623 = 0;
    unint64_t v621 = 0;
    if (*(unsigned char *)(v89 + 16) == 25) {
      uint64_t v108 = v89;
    }
    else {
      uint64_t v108 = 0;
    }
    if (v108) {
      int v109 = (llvm::Value **)(v108 - 32);
    }
    else {
      int v109 = (llvm::Value **)(v89 - 64);
    }
    v712[0] = *v109;
    sub_1CCD370D8((uint64_t)v619, (uint64_t *)v712);
    uint64_t v610 = (uint64_t)v102;
    BOOL v607 = sub_1CCD36C14(v653, (uint64_t)v102);
    unsigned int v111 = v621;
    int v617 = UnderlyingObject;
    if (v622 == v621) {
      goto LABEL_846;
    }
    unsigned int v606 = v107;
    uint64_t v112 = 0;
    unsigned int v113 = 0;
    do
    {
      uint64_t v114 = v111[v112];
      int64_t v115 = v660;
      if (v661 == v660)
      {
        unsigned int v116 = HIDWORD(v662);
        int v117 = (char *)v661 + 8 * HIDWORD(v662);
        if (HIDWORD(v662))
        {
          uint64_t v118 = 0;
          while (*(void *)((char *)v661 + v118) != v114)
          {
            v118 += 8;
            if (8 * HIDWORD(v662) == v118) {
              goto LABEL_234;
            }
          }
          int v117 = (char *)v661 + v118;
        }
LABEL_234:
        int64_t v115 = v661;
      }
      else
      {
        int v119 = v662 - 1;
        unsigned int v120 = (v662 - 1) & ((v114 >> 4) ^ (v114 >> 9));
        int v117 = (char *)v661 + 8 * v120;
        uint64_t v121 = *(void *)v117;
        if (*(void *)v117 == -1)
        {
          uint64_t v122 = 0;
LABEL_257:
          if (v122) {
            int v117 = v122;
          }
          unsigned int v116 = HIDWORD(v662);
          if (*(void *)v117 != v114) {
            int v117 = (char *)v661 + 8 * v662;
          }
        }
        else
        {
          uint64_t v122 = 0;
          int v123 = 1;
          while (v121 != v114)
          {
            if (v122) {
              BOOL v124 = 0;
            }
            else {
              BOOL v124 = v121 == -2;
            }
            if (v124) {
              uint64_t v122 = v117;
            }
            unsigned int v125 = v120 + v123++;
            unsigned int v120 = v125 & v119;
            int v117 = (char *)v661 + 8 * (v125 & v119);
            uint64_t v121 = *(void *)v117;
            if (*(void *)v117 == -1) {
              goto LABEL_257;
            }
          }
          unsigned int v116 = HIDWORD(v662);
        }
      }
      if (v661 == v115) {
        unsigned int v126 = v116;
      }
      else {
        unsigned int v126 = v662;
      }
      if (v117 != (char *)v661 + 8 * v126 || v105 == 0 || v106 == 0) {
        goto LABEL_246;
      }
      uint64_t v129 = *(void *)(v89 + 72);
      if (byte_1EBCF1548)
      {
        if (*(unsigned char *)(v89 + 16) == 25) {
          uint64_t v130 = v89;
        }
        else {
          uint64_t v130 = 0;
        }
        uint64_t v131 = (void *)(v130 - 32);
        BOOL v34 = v130 == 0;
        uint64_t v132 = (void *)(v89 - 64);
        if (!v34) {
          uint64_t v132 = v131;
        }
        if (*v132 == v114)
        {
          int v134 = 0;
          uint64_t v135 = *(unsigned __int8 *)(v129 + 16) - 33;
          if (v135 <= 0x37)
          {
            if (((1 << (*(unsigned char *)(v129 + 16) - 33)) & 0x8000000000041) == 0)
            {
              if (((1 << (*(unsigned char *)(v129 + 16) - 33)) & 0x808001C8000010) == 0)
              {
                if (v135 == 28) {
                  int v134 = (*(_WORD *)(v129 + 18) & 0x301) != 0;
                }
                goto LABEL_279;
              }
LABEL_278:
              int v134 = 1;
              goto LABEL_279;
            }
            uint64_t v136 = *(void *)(v129 + 64);
            if (v136 && ((*(unsigned char *)(v136 + 20) & 4) != 0 || (*(unsigned char *)(v136 + 17) & 0x10) != 0)) {
              goto LABEL_273;
            }
            LODWORD(v712[0]) = 7;
            if (sub_1CC5CB59C(v129, (__int32 *)v712, 1uLL))
            {
              uint64_t v137 = *(void *)(v129 - 32);
              if (!v137 || *(unsigned char *)(v137 + 16) || *(void *)(v137 + 24) != *(void *)(v129 + 72))
              {
                int v134 = 1;
                UnderlyingObject = v617;
                goto LABEL_279;
              }
              UnderlyingObject = v617;
              if (*(_DWORD *)(v137 + 36) != 7) {
                goto LABEL_278;
              }
            }
            if (llvm::CallBase::hasFnAttrOnCalledFunction(v129, 66)) {
LABEL_273:
            }
              int v134 = 0;
            else {
              int v134 = llvm::CallBase::hasFnAttrOnCalledFunction(v129, 44) ^ 1;
            }
          }
LABEL_279:
          int v133 = v134 ^ 1;
          goto LABEL_280;
        }
      }
      int v133 = 0;
LABEL_280:
      unsigned int v614 = v105;
      LOBYTE(v708) = 0;
      LOBYTE(v711) = 0;
      if (*((void *)v650 + 12) == v114)
      {
        uint64_t v138 = v114;
LABEL_428:
        if (v133)
        {
          if (*(unsigned char *)(v89 + 16) == 25) {
            uint64_t v181 = v89;
          }
          else {
            uint64_t v181 = 0;
          }
          uint64_t v182 = (void *)(v181 - 32);
          BOOL v34 = v181 == 0;
          int v183 = (void *)(v89 - 64);
          if (!v34) {
            int v183 = v182;
          }
          if (v138 != *v183) {
            sub_1CC0ABD0C(v89, v138);
          }
        }
LABEL_438:
        int v105 = v614;
        goto LABEL_246;
      }
      uint64_t v138 = v114;
      while (1)
      {
        uint64_t v139 = v106;
        if (*(void *)(v89 + 64) == *(void *)(v138 + 64)) {
          int v140 = (unsigned int *)&unk_1EBCF1308;
        }
        else {
          int v140 = (unsigned int *)&unk_1EBCF13C8;
        }
        unsigned int v141 = *v140;
        BOOL v504 = v106 >= v141;
        uint64_t v106 = v106 - v141;
        if (v106 == 0 || !v504) {
          goto LABEL_437;
        }
        if (*(unsigned char *)(v138 + 16) == 27) {
          goto LABEL_677;
        }
        uint64_t v142 = *(void *)(v138 + 72);
        BOOL v143 = sub_1CCD38834((uint64_t)v633, UnderlyingObject, v110);
        uint64_t v144 = *(void *)(v138 + 72);
        int v145 = *(unsigned __int8 *)(v144 + 16);
        if ((v145 - 33) <= 0x33 && ((1 << (v145 - 33)) & 0x8000000000041) != 0)
        {
          uint64_t v147 = *(void *)(v144 + 64);
          if (v147 && (*(unsigned char *)(v147 + 13) & 8) != 0) {
            goto LABEL_307;
          }
          LODWORD(v712[0]) = 7;
          if ((!sub_1CC5CB59C(v144, (__int32 *)v712, 1uLL)
             || (uint64_t v179 = *(void *)(v144 - 32)) != 0
             && !*(unsigned char *)(v179 + 16)
             && *(void *)(v179 + 24) == *(void *)(v144 + 72)
             && *(_DWORD *)(v179 + 36) == 7)
            && (llvm::CallBase::hasFnAttrOnCalledFunction(v144, 11) & 1) != 0)
          {
            goto LABEL_307;
          }
          int v145 = *(unsigned __int8 *)(v144 + 16);
        }
        if (v145 <= 35)
        {
          if (v145 != 34) {
            goto LABEL_305;
          }
          int v148 = 1;
          goto LABEL_300;
        }
        if (v145 == 84) {
          break;
        }
        if (v145 != 36 && v145 != 38) {
          goto LABEL_305;
        }
        int v148 = (*(_WORD *)(v144 + 18) & 1) == 0;
LABEL_300:
        if (v143 & v148) {
          goto LABEL_307;
        }
LABEL_305:
        if (*(unsigned char *)(v144 + 16) != 63) {
          goto LABEL_306;
        }
LABEL_307:
        int v133 = 0;
        UnderlyingObject = v617;
LABEL_308:
        if (*(unsigned char *)(v138 + 16) == 25) {
          uint64_t v149 = v138;
        }
        else {
          uint64_t v149 = 0;
        }
        if (v149) {
          int v150 = (uint64_t *)(v149 - 32);
        }
        else {
          int v150 = (uint64_t *)(v138 - 64);
        }
        uint64_t v138 = *v150;
        if (*((void *)v650 + 12) == *v150) {
          goto LABEL_428;
        }
      }
      uint64_t v152 = *(void *)(v144 + 64);
      if (!v152 || (*(unsigned char *)(v152 + 16) & 0x20) == 0)
      {
        int v148 = llvm::CallBase::hasFnAttrOnCalledFunction(v144, 37) ^ 1;
        goto LABEL_300;
      }
LABEL_306:
      if (sub_1CCD38EE0(v144)) {
        goto LABEL_307;
      }
      UnderlyingObject = v617;
      if (!v617 || !sub_1CCD38834((uint64_t)v633, v617, v110))
      {
        uint64_t v151 = *(void *)(v129 + 40);
        if (v151 == *(void *)(v142 + 40))
        {
          char v153 = v669;
          if (v670 == v669)
          {
            unsigned int v154 = HIDWORD(v671);
            unint64_t v155 = (char *)v670 + 8 * HIDWORD(v671);
            if (HIDWORD(v671))
            {
              uint64_t v156 = 0;
              while (*(void *)((char *)v670 + v156) != v151)
              {
                v156 += 8;
                if (8 * HIDWORD(v671) == v156) {
                  goto LABEL_343;
                }
              }
              unint64_t v155 = (char *)v670 + v156;
            }
LABEL_343:
            char v153 = v670;
          }
          else
          {
            int v157 = v671 - 1;
            unsigned int v158 = (v671 - 1) & ((v151 >> 4) ^ (v151 >> 9));
            unint64_t v155 = (char *)v670 + 8 * v158;
            uint64_t v159 = *(void *)v155;
            if (*(void *)v155 == -1)
            {
              unint64_t v160 = 0;
LABEL_397:
              if (v160) {
                unint64_t v155 = v160;
              }
              unsigned int v154 = HIDWORD(v671);
              if (*(void *)v155 != v151) {
                unint64_t v155 = (char *)v670 + 8 * v671;
              }
            }
            else
            {
              unint64_t v160 = 0;
              int v161 = 1;
              while (v159 != v151)
              {
                if (v160) {
                  BOOL v162 = 0;
                }
                else {
                  BOOL v162 = v159 == -2;
                }
                if (v162) {
                  unint64_t v160 = v155;
                }
                unsigned int v163 = v158 + v161++;
                unsigned int v158 = v163 & v157;
                unint64_t v155 = (char *)v670 + 8 * (v163 & v157);
                uint64_t v159 = *(void *)v155;
                if (*(void *)v155 == -1) {
                  goto LABEL_397;
                }
              }
              unsigned int v154 = HIDWORD(v671);
            }
          }
          unsigned int v164 = v671;
          if (v670 == v153) {
            unsigned int v164 = v154;
          }
          if (v155 != (char *)v670 + 8 * v164)
          {
LABEL_426:
            uint64_t v139 = v106;
            goto LABEL_437;
          }
        }
        else if (HIDWORD(v671) != v672)
        {
          goto LABEL_426;
        }
      }
      int v165 = *(unsigned __int8 *)(v142 + 16);
      if (v142 && v165 == 84)
      {
        uint64_t v172 = *(void *)(v142 + 64);
        if ((!v172 || (*(unsigned char *)(v172 + 16) & 0x20) == 0)
          && (llvm::CallBase::hasFnAttrOnCalledFunction(v142, 37) & 1) == 0)
        {
          goto LABEL_354;
        }
      }
      else if (v142 && v165 == 36 || v142 && v165 == 38)
      {
        if ((*(_WORD *)(v142 + 18) & 1) == 0) {
          goto LABEL_354;
        }
      }
      else if (v165 == 34)
      {
LABEL_354:
        if (!sub_1CCD38834((uint64_t)v633, v617, v110)) {
          goto LABEL_426;
        }
      }
      int v166 = *(unsigned __int8 *)(v142 + 16);
      if (v166 == 60 || v166 == 61)
      {
        if (v142)
        {
          unint64_t v167 = *(unsigned __int16 *)(v142 + 18);
          if ((v167 & 0x380) != 0 && ((v167 >> 7) & 7) - 3 < 5) {
            goto LABEL_426;
          }
        }
      }
      else
      {
        if (v166 == 84)
        {
          uint64_t v171 = *(void *)(v142 - 32);
          if (v171
            && !*(unsigned char *)(v171 + 16)
            && *(void *)(v171 + 24) == *(void *)(v142 + 72)
            && (*(unsigned char *)(v171 + 33) & 0x20) != 0)
          {
            goto LABEL_360;
          }
          goto LABEL_359;
        }
        if ((v166 - 63) < 3)
        {
          if (v142 && v166 == 65)
          {
            unint64_t v178 = ((unint64_t)*(unsigned __int16 *)(v142 + 18) >> 1) & 7;
LABEL_425:
            UnderlyingObject = v617;
            if (v178 - 3 < 5) {
              goto LABEL_426;
            }
          }
          else
          {
            UnderlyingObject = v617;
            if (v142 && v166 == 64)
            {
              unint64_t v180 = *(unsigned __int16 *)(v142 + 18);
              if (((v180 >> 2) & 7) - 3 < 5) {
                goto LABEL_436;
              }
              unint64_t v178 = v180 >> 5;
              goto LABEL_425;
            }
          }
        }
      }
LABEL_359:
      if (sub_1CCD38910((uint64_t)v633, (long long *)v624, v142)) {
        goto LABEL_426;
      }
LABEL_360:
      uint64_t v168 = *(void *)(v138 + 8);
      if (v168)
      {
        while (1)
        {
          uint64_t v169 = *(void *)(v168 + 24);
          BOOL v170 = !v169 || *(unsigned __int8 *)(v169 + 16) - 25 > 1;
          if (!v170
            && !llvm::MemorySSA::dominates(v650, v114, *(void *)(v168 + 24))
            && sub_1CCD38910((uint64_t)v633, (long long *)v624, *(void *)(v169 + 72)))
          {
            break;
          }
          uint64_t v168 = *(void *)(v168 + 8);
          if (!v168) {
            goto LABEL_368;
          }
        }
LABEL_436:
        uint64_t v139 = v106;
        UnderlyingObject = v617;
LABEL_437:
        uint64_t v106 = v139;
        goto LABEL_438;
      }
LABEL_368:
      sub_1CCD36F44(v712, (uint64_t)v633, (llvm::Instruction *)v142);
      uint64_t v711 = v713;
      long long v708 = *(_OWORD *)v712;
      long long v709 = *(_OWORD *)&v712[2];
      long long v710 = *(_OWORD *)&v712[4];
      UnderlyingObject = v617;
      if (!(_BYTE)v713
        || !sub_1CCD38B34(v142)
        || !sub_1CCD38C68((uint64_t)v633, *(void *)(v142 + 40), *(void *)(v129 + 40), (llvm::Value *)v708))
      {
        goto LABEL_405;
      }
      if (v607)
      {
        if (sub_1CCD38D5C((uint64_t)v633, (llvm **)&v708, v142, v129)) {
          goto LABEL_441;
        }
LABEL_405:
        int v133 = 0;
        goto LABEL_308;
      }
      v712[0] = 0;
      *(void *)&long long v694 = 0;
      int v173 = sub_1CCD3782C((uint64_t)v633, v129, v142, (uint64_t)v624, (uint64_t)&v708, (uint64_t *)v712, (uint64_t *)&v694);
      int v174 = v173;
      if ((v133 & 1) == 0) {
        goto LABEL_404;
      }
      if (*(unsigned char *)(v89 + 16) == 25) {
        uint64_t v175 = v89;
      }
      else {
        uint64_t v175 = 0;
      }
      uint64_t v176 = (void *)(v175 - 32);
      BOOL v34 = v175 == 0;
      unint64_t v177 = (void *)(v89 - 64);
      if (!v34) {
        unint64_t v177 = v176;
      }
      if (v138 == *v177)
      {
        if (v173 != 5) {
          goto LABEL_404;
        }
LABEL_403:
        int v133 = 1;
        goto LABEL_308;
      }
      if (v173 == 1) {
        goto LABEL_395;
      }
      if (v173 == 5) {
        goto LABEL_403;
      }
      if (v173 != 4)
      {
LABEL_404:
        if ((v173 - 5) >= 2) {
          goto LABEL_406;
        }
        goto LABEL_405;
      }
LABEL_395:
      sub_1CC0ABD0C(v89, v138);
LABEL_406:
      if (v174 != 4) {
        goto LABEL_441;
      }
      if (v606 <= 1)
      {
        int v133 = 0;
        uint64_t v106 = (v106 - 1);
        goto LABEL_308;
      }
      --v606;
LABEL_441:
      *(void *)&long long v694 = &v696;
      *((void *)&v694 + 1) = &v696;
      DWORD2(v695) = 0;
      uint64_t v184 = *(void *)(v89 + 72);
      *(void *)&long long v695 = 0x100000010;
      *(void *)&long long v696 = v184;
      v629[0] = v708;
      v629[1] = v709;
      v629[2] = v710;
      uint64_t v185 = *(void *)(v138 + 72);
      uint64_t v186 = 1;
      v712[0] = (llvm::Value *)1;
      do
      {
        *(int64x2_t *)&v712[v186] = v604;
        v186 += 2;
      }
      while (v186 != 33);
      char v718 = v720;
      uint64_t v719 = 0x2000000000;
      uint64_t v187 = *(void *)(v138 + 8);
      if (!v187) {
        goto LABEL_595;
      }
      do
      {
        *(void *)&long long v687 = *(void *)(v187 + 24);
        sub_1CCD39148((uint64_t)v712, (uint64_t *)&v687);
        uint64_t v187 = *(void *)(v187 + 8);
      }
      while (v187);
      uint64_t v188 = v719;
      if (!v719)
      {
LABEL_595:
        if (sub_1CCD39028((uint64_t)v633, UnderlyingObject))
        {
          int v254 = 1;
          goto LABEL_670;
        }
        *(void *)&long long v687 = &v689;
        *((void *)&v687 + 1) = &v689;
        *(void *)&long long v688 = 16;
        DWORD2(v688) = 0;
        if (*((void *)&v694 + 1) == (void)v694) {
          unint64_t v250 = (unsigned int *)&v695 + 1;
        }
        else {
          unint64_t v250 = (unsigned int *)&v695;
        }
        uint64_t v251 = *v250;
        if (v251)
        {
          uint64_t v252 = 8 * v251;
          int v253 = (unint64_t *)*((void *)&v694 + 1);
          while (*v253 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v253;
            v252 -= 8;
            if (!v252) {
              goto LABEL_648;
            }
          }
        }
        else
        {
          int v253 = (unint64_t *)*((void *)&v694 + 1);
        }
        uint64_t v255 = *((void *)&v694 + 1) + 8 * v251;
        if (v253 == (unint64_t *)v255)
        {
LABEL_648:
          LODWORD(v256) = 0;
          unsigned int v258 = 16;
          int v259 = (uint64_t *)&v689;
          uint64_t v260 = (uint64_t *)&v689;
LABEL_649:
          uint64_t v630 = 0;
          if (v259 == v260) {
            uint64_t v256 = v256;
          }
          else {
            uint64_t v256 = v258;
          }
          uint64_t v275 = &v259[v256];
          if (v256)
          {
            uint64_t v276 = 8 * v256;
            uint64_t v277 = 8 * v256;
            int v278 = v259;
            do
            {
              uint64_t v279 = *v278;
              if ((unint64_t)*v278 < 0xFFFFFFFFFFFFFFFELL) {
                goto LABEL_657;
              }
              ++v278;
              v277 -= 8;
            }
            while (v277);
            uint64_t v279 = *v275;
LABEL_657:
            uint64_t v630 = v279;
            do
            {
              if ((unint64_t)*v259 < 0xFFFFFFFFFFFFFFFELL) {
                goto LABEL_662;
              }
              ++v259;
              v276 -= 8;
            }
            while (v276);
            int v259 = v275;
          }
          else
          {
            uint64_t v279 = *v259;
            uint64_t v630 = *v259;
          }
LABEL_662:
          int v280 = (unint64_t *)(v259 + 1);
          do
          {
            if (v280 == (unint64_t *)v275) {
              goto LABEL_667;
            }
            unint64_t v281 = *v280++;
          }
          while (v281 > 0xFFFFFFFFFFFFFFFDLL);
          if (v279) {
            llvm::DominatorTreeBase<llvm::BasicBlock,true>::findNearestCommonDominator();
          }
LABEL_667:
          llvm::DominatorTreeBase<llvm::BasicBlock,true>::dominates();
        }
        LODWORD(v256) = 0;
        unint64_t v257 = *v253;
        unsigned int v258 = 16;
        int v259 = (uint64_t *)&v689;
        uint64_t v260 = (uint64_t *)&v689;
        while (2)
        {
          uint64_t v261 = *(void *)(v257 + 40);
          if (v259 == v260)
          {
            if (v256)
            {
              v262 = 0;
              uint64_t v263 = 8 * v256;
              int v264 = v260;
              do
              {
                if (*v264 == v261) {
                  goto LABEL_638;
                }
                if (*v264 == -2) {
                  v262 = v264;
                }
                ++v264;
                v263 -= 8;
              }
              while (v263);
              if (v262)
              {
                uint64_t *v262 = v261;
                --DWORD2(v688);
LABEL_638:
                int v259 = (uint64_t *)*((void *)&v687 + 1);
                uint64_t v260 = (uint64_t *)v687;
                uint64_t v273 = v253 + 1;
                LODWORD(v256) = DWORD1(v688);
                unsigned int v258 = v688;
                do
                {
                  if (v273 == (unint64_t *)v255) {
                    goto LABEL_649;
                  }
                  unint64_t v274 = *v273++;
                  unint64_t v257 = v274;
                }
                while (v274 > 0xFFFFFFFFFFFFFFFDLL);
                int v253 = v273 - 1;
                continue;
              }
            }
            if (v258 > v256)
            {
              DWORD1(v688) = v256 + 1;
              v260[v256] = v261;
              goto LABEL_638;
            }
          }
          break;
        }
        if (3 * v258 <= 4 * ((int)v256 - DWORD2(v688)))
        {
          if (v258 >= 0x40) {
            v258 *= 2;
          }
          else {
            unsigned int v258 = 128;
          }
        }
        else if (v258 - v256 >= v258 >> 3)
        {
          goto LABEL_620;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v687, v258);
        unsigned int v258 = v688;
        int v259 = (uint64_t *)*((void *)&v687 + 1);
LABEL_620:
        unsigned int v265 = v258 - 1;
        unsigned int v266 = (v258 - 1) & ((v261 >> 4) ^ (v261 >> 9));
        unint64_t v267 = &v259[v266];
        uint64_t v268 = *v267;
        if (*v267 == -1)
        {
          uint64_t v269 = 0;
LABEL_632:
          if (v269) {
            unint64_t v267 = v269;
          }
          if (*v267 != v261)
          {
            if (*v267 == -2) {
              --DWORD2(v688);
            }
            else {
              ++DWORD1(v688);
            }
            uint64_t *v267 = v261;
          }
        }
        else
        {
          uint64_t v269 = 0;
          int v270 = 1;
          while (v268 != v261)
          {
            if (v269) {
              BOOL v271 = 0;
            }
            else {
              BOOL v271 = v268 == -2;
            }
            if (v271) {
              uint64_t v269 = v267;
            }
            unsigned int v272 = v266 + v270++;
            unsigned int v266 = v272 & v265;
            unint64_t v267 = &v259[v272 & v265];
            uint64_t v268 = *v267;
            if (*v267 == -1) {
              goto LABEL_632;
            }
          }
        }
        goto LABEL_638;
      }
      unint64_t v189 = 0;
      while (2)
      {
        if (v188 - v189 > v614)
        {
LABEL_604:
          uint64_t v138 = 0;
          int v254 = 0;
          goto LABEL_670;
        }
        uint64_t v190 = *((void *)v718 + v189);
        --v614;
        if (*(unsigned char *)(v190 + 16) == 27)
        {
          if (*((void *)&v694 + 1) == (void)v694) {
            uint64_t v191 = (unsigned int *)&v695 + 1;
          }
          else {
            uint64_t v191 = (unsigned int *)&v695;
          }
          uint64_t v192 = *v191;
          if (v192)
          {
            uint64_t v193 = 8 * v192;
            int v194 = (void *)*((void *)&v694 + 1);
            while (*v194 >= 0xFFFFFFFFFFFFFFFELL)
            {
              ++v194;
              v193 -= 8;
              if (!v193) {
                goto LABEL_468;
              }
            }
          }
          else
          {
            int v194 = (void *)*((void *)&v694 + 1);
          }
          if (v194 != (void *)(*((void *)&v694 + 1) + 8 * v192)) {
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
          }
LABEL_468:
          for (uint64_t m = *(void *)(v190 + 8); m; uint64_t m = *(void *)(m + 8))
          {
            *(void *)&long long v687 = *(void *)(m + 24);
            sub_1CCD39148((uint64_t)v712, (uint64_t *)&v687);
          }
          goto LABEL_503;
        }
        uint64_t v195 = *(void *)(v190 + 72);
        if (*((void *)&v694 + 1) == (void)v694) {
          uint64_t v196 = (unsigned int *)&v695 + 1;
        }
        else {
          uint64_t v196 = (unsigned int *)&v695;
        }
        uint64_t v197 = *v196;
        if (v197)
        {
          uint64_t v198 = 8 * v197;
          uint64_t v199 = (const llvm::Value **)*((void *)&v694 + 1);
          while ((unint64_t)*v199 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v199;
            v198 -= 8;
            if (!v198) {
              goto LABEL_478;
            }
          }
        }
        else
        {
          uint64_t v199 = (const llvm::Value **)*((void *)&v694 + 1);
        }
        uint64_t v201 = *((void *)&v694 + 1) + 8 * v197;
        if (v199 != (const llvm::Value **)v201)
        {
          int v202 = *v199;
LABEL_474:
          if ((llvm::DominatorTree::dominates(v651, v202, (const llvm::Instruction *)v195) & 1) == 0)
          {
            while (1)
            {
              if (++v199 == (const llvm::Value **)v201) {
                goto LABEL_478;
              }
              int v202 = *v199;
              if ((unint64_t)*v199 < 0xFFFFFFFFFFFFFFFELL) {
                goto LABEL_474;
              }
            }
          }
LABEL_503:
          ++v189;
          uint64_t v188 = v719;
          UnderlyingObject = v617;
          if (v189 >= v719) {
            goto LABEL_595;
          }
          continue;
        }
        break;
      }
LABEL_478:
      if (sub_1CCD38D5C((uint64_t)v633, (llvm **)v629, v185, v195)) {
        goto LABEL_503;
      }
      if (sub_1CCD38EE0(*(void *)(v190 + 72)))
      {
        for (uint64_t n = *(void *)(v190 + 8); n; uint64_t n = *(void *)(n + 8))
        {
          *(void *)&long long v687 = *(void *)(n + 24);
          sub_1CCD39148((uint64_t)v712, (uint64_t *)&v687);
        }
        goto LABEL_503;
      }
      int v204 = *(unsigned __int8 *)(v195 + 16);
      if (v195 && v204 == 84)
      {
        uint64_t v208 = *(void *)(v195 + 64);
        UnderlyingObject = v617;
        if ((!v208 || (*(unsigned char *)(v208 + 16) & 0x20) == 0)
          && (llvm::CallBase::hasFnAttrOnCalledFunction(v195, 37) & 1) == 0)
        {
          goto LABEL_490;
        }
      }
      else
      {
        UnderlyingObject = v617;
        if (v195 && v204 == 36 || v195 && v204 == 38)
        {
          if ((*(_WORD *)(v195 + 18) & 1) == 0) {
            goto LABEL_490;
          }
        }
        else if (v204 == 34)
        {
LABEL_490:
          if (!sub_1CCD38834((uint64_t)v633, UnderlyingObject, v110)) {
            goto LABEL_604;
          }
        }
      }
      if (sub_1CCD38910((uint64_t)v633, v629, v195)) {
        goto LABEL_604;
      }
      if (v138 == v190)
      {
        if (!sub_1CCD38F54(*(llvm::Value **)&v629[0])) {
          goto LABEL_815;
        }
        goto LABEL_503;
      }
      if (v190 == v89 || *(unsigned char *)(v190 + 16) != 26) {
        goto LABEL_503;
      }
      int v205 = *(unsigned __int8 *)(v195 + 16);
      uint64_t v206 = (v205 - 33);
      if (v206 > 0x37) {
        goto LABEL_499;
      }
      if (((1 << (v205 - 33)) & 0x8000000000041) != 0)
      {
        uint64_t v209 = *(void *)(v195 + 64);
        if (!v209 || (*(unsigned char *)(v209 + 17) & 0x30) == 0)
        {
          int v210 = *(_DWORD *)(v195 + 20);
          if (v210 < 0)
          {
            uint64_t v241 = v195 - 32 * (v210 & 0x7FFFFFF);
            uint64_t v244 = *(void *)(v241 - 8);
            uint64_t v242 = v241 - 8;
            uint64_t v243 = v244;
            if (v244)
            {
              uint64_t v245 = -v243;
              do
              {
                unsigned int v246 = *(_DWORD *)(*(void *)(v242 + v245) + 8);
                BOOL v170 = v246 > 7;
                int v247 = (1 << v246) & 0x83;
                if (v170 || v247 == 0) {
                  goto LABEL_515;
                }
                v245 += 16;
              }
              while (v245);
            }
          }
          if ((llvm::CallBase::hasFnAttrOnCalledFunction(v195, 45) & 1) == 0
            && (llvm::CallBase::hasFnAttrOnCalledFunction(v195, 44) & 1) == 0)
          {
            int v205 = *(unsigned __int8 *)(v195 + 16);
            goto LABEL_515;
          }
        }
        goto LABEL_499;
      }
      if (v206 == 27)
      {
        if ((*(_WORD *)(v195 + 18) & 0x301) != 0) {
          goto LABEL_523;
        }
LABEL_499:
        for (iuint64_t i = *(void *)(v190 + 8); ii; iuint64_t i = *(void *)(ii + 8))
        {
          *(void *)&long long v687 = *(void *)(ii + 24);
          sub_1CCD39148((uint64_t)v712, (uint64_t *)&v687);
        }
        goto LABEL_503;
      }
      if (((1 << (v205 - 33)) & 0x808001D0000010) == 0) {
        goto LABEL_499;
      }
LABEL_515:
      unsigned int v211 = v205 - 33;
      if (v211 <= 0x33 && ((1 << v211) & 0x8000000000041) != 0)
      {
        uint64_t v212 = *(void *)(v195 + 64);
        if (v212)
        {
          if ((*(unsigned char *)(v212 + 13) & 8) != 0) {
            goto LABEL_499;
          }
        }
        LODWORD(v687) = 7;
        if ((!sub_1CC5CB59C(v195, (__int32 *)&v687, 1uLL)
           || (uint64_t v249 = *(void *)(v195 - 32)) != 0
           && !*(unsigned char *)(v249 + 16)
           && *(void *)(v249 + 24) == *(void *)(v195 + 72)
           && *(_DWORD *)(v249 + 36) == 7)
          && (llvm::CallBase::hasFnAttrOnCalledFunction(v195, 11) & 1) != 0)
        {
          goto LABEL_499;
        }
      }
LABEL_523:
      uint64_t v627 = 0;
      uint64_t v630 = 0;
      sub_1CCD36F44(&v687, (uint64_t)v633, (llvm::Instruction *)v195);
      if (!v690
        || sub_1CCD3782C((uint64_t)v633, v195, v185, (uint64_t)&v687, (uint64_t)v629, &v627, &v630) != 1)
      {
        goto LABEL_499;
      }
      uint64_t v213 = v674;
      if (v675)
      {
        uint64_t v214 = *(void *)(v195 + 40);
        unsigned int v215 = v675 - 1;
        uint64_t v216 = ((v214 >> 4) ^ (v214 >> 9)) & (v675 - 1);
        uint64_t v217 = *(void *)(v674 + 16 * v216);
        if (v214 != v217)
        {
          int v237 = 1;
          while (v217 != -4096)
          {
            int v238 = v216 + v237++;
            uint64_t v216 = v238 & v215;
            uint64_t v217 = *(void *)(v674 + 16 * v216);
            if (v214 == v217) {
              goto LABEL_527;
            }
          }
          uint64_t v216 = v675;
        }
LABEL_527:
        unsigned int v218 = *(_DWORD *)(v674 + 16 * v216 + 8);
        uint64_t v219 = *(void *)(v138 + 64);
        LODWORD(v220) = ((v219 >> 4) ^ (v219 >> 9)) & v215;
        uint64_t v221 = *(void *)(v674 + 16 * v220);
        if (v219 == v221)
        {
          uint64_t v213 = v674 + 16 * v220;
        }
        else
        {
          int v239 = 1;
          while (v221 != -4096)
          {
            int v240 = v220 + v239++;
            uint64_t v220 = v240 & v215;
            uint64_t v221 = *(void *)(v674 + 16 * v220);
            if (v219 == v221)
            {
              uint64_t v213 = v674 + 16 * v220;
              goto LABEL_530;
            }
          }
          uint64_t v213 = v674 + 16 * v675;
        }
      }
      else
      {
        unsigned int v218 = *(_DWORD *)(v674 + 8);
      }
LABEL_530:
      if (v218 < *(_DWORD *)(v213 + 8))
      {
        if (sub_1CCD39028((uint64_t)v633, v617)) {
          goto LABEL_503;
        }
        uint64_t v222 = *((void *)&v694 + 1);
        uint64_t v223 = DWORD1(v695);
        if (*((void *)&v694 + 1) == (void)v694)
        {
          if (DWORD1(v695))
          {
            uint64_t v224 = 0;
            uint64_t v225 = 8 * DWORD1(v695);
            unint64_t v226 = (uint64_t *)*((void *)&v694 + 1);
            while (*v226 != v195)
            {
              if (*v226 == -2) {
                uint64_t v224 = v226;
              }
              ++v226;
              v225 -= 8;
              if (!v225)
              {
                if (!v224) {
                  goto LABEL_540;
                }
                *uint64_t v224 = v195;
                --DWORD2(v695);
                goto LABEL_503;
              }
            }
            goto LABEL_503;
          }
LABEL_540:
          unsigned int v227 = v695;
          if (DWORD1(v695) < v695)
          {
            ++DWORD1(v695);
            *(void *)(*((void *)&v694 + 1) + 8 * v223) = v195;
            goto LABEL_503;
          }
        }
        else
        {
          unsigned int v227 = v695;
        }
        if (3 * v227 <= 4 * (DWORD1(v695) - DWORD2(v695)))
        {
          if (v227 >= 0x40) {
            v227 *= 2;
          }
          else {
            unsigned int v227 = 128;
          }
        }
        else if (v227 - DWORD1(v695) >= v227 >> 3)
        {
          goto LABEL_545;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v694, v227);
        unsigned int v227 = v695;
        uint64_t v222 = *((void *)&v694 + 1);
LABEL_545:
        unsigned int v228 = v227 - 1;
        unsigned int v229 = (v227 - 1) & ((v195 >> 4) ^ (v195 >> 9));
        unsigned int v230 = (uint64_t *)(v222 + 8 * v229);
        uint64_t v231 = *v230;
        if (*v230 == -1)
        {
          uint64_t v232 = 0;
LABEL_557:
          if (v232) {
            uint64_t v236 = v232;
          }
          else {
            uint64_t v236 = v230;
          }
          if (*v236 != v195)
          {
            if (*v236 == -2) {
              --DWORD2(v695);
            }
            else {
              ++DWORD1(v695);
            }
            *uint64_t v236 = v195;
          }
        }
        else
        {
          uint64_t v232 = 0;
          int v233 = 1;
          while (v231 != v195)
          {
            if (v232) {
              BOOL v234 = 0;
            }
            else {
              BOOL v234 = v231 == -2;
            }
            if (v234) {
              uint64_t v232 = v230;
            }
            unsigned int v235 = v229 + v233++;
            unsigned int v229 = v235 & v228;
            unsigned int v230 = (uint64_t *)(v222 + 8 * (v235 & v228));
            uint64_t v231 = *v230;
            if (*v230 == -1) {
              goto LABEL_557;
            }
          }
        }
        goto LABEL_503;
      }
LABEL_815:
      uint64_t v138 = 0;
      int v254 = 0;
      UnderlyingObject = v617;
LABEL_670:
      if (v718 != v720) {
        free(v718);
      }
      if (((uint64_t)v712[0] & 1) == 0) {
        MEMORY[0x1D25D9CD0](v712[1], 8);
      }
      if (*((void *)&v694 + 1) != (void)v694) {
        free(*((void **)&v694 + 1));
      }
      if (!v254) {
        goto LABEL_438;
      }
LABEL_677:
      int v282 = *(unsigned __int8 *)(v138 + 16);
      if (v282 == 27)
      {
        int v283 = *(_DWORD *)(v138 + 20);
        if ((v283 & 0x40000000) != 0)
        {
          int v285 = *(llvm::Value ***)(v138 - 8);
          uint64_t v284 = v283 & 0x7FFFFFF;
          if (!v284) {
            goto LABEL_438;
          }
        }
        else
        {
          uint64_t v284 = v283 & 0x7FFFFFF;
          int v285 = (llvm::Value **)(v138 - 32 * v284);
          if (!v284) {
            goto LABEL_438;
          }
        }
        unsigned int v289 = &v285[4 * v284];
        while (2)
        {
          v712[0] = *v285;
          uint64_t v290 = *((void *)v712[0] + 8);
          *(void *)&long long v694 = v290;
          uint64_t v291 = *(void *)(v138 + 64);
          *(void *)&long long v687 = v291;
          unsigned int v292 = v675;
          if (v675)
          {
            uint64_t v293 = v674;
            unsigned int v294 = v675 - 1;
            unsigned int v295 = (v675 - 1) & ((v290 >> 4) ^ (v290 >> 9));
            uint64_t v296 = (uint64_t *)(v674 + 16 * v295);
            uint64_t v297 = *v296;
            if (v290 == *v296)
            {
              unsigned int v298 = *((_DWORD *)v296 + 2);
              goto LABEL_710;
            }
            uint64_t v299 = 0;
            int v300 = 1;
            while (v297 != -4096)
            {
              if (v299) {
                BOOL v301 = 0;
              }
              else {
                BOOL v301 = v297 == -8192;
              }
              if (v301) {
                uint64_t v299 = v296;
              }
              unsigned int v302 = v295 + v300++;
              unsigned int v295 = v302 & v294;
              uint64_t v296 = (uint64_t *)(v674 + 16 * v295);
              uint64_t v297 = *v296;
              if (v290 == *v296)
              {
                unsigned int v298 = *((_DWORD *)v296 + 2);
                goto LABEL_709;
              }
            }
            if (v299) {
              uint64_t v304 = v299;
            }
            else {
              uint64_t v304 = v296;
            }
          }
          else
          {
            uint64_t v304 = 0;
          }
          int v305 = sub_1CBFAF8D8((uint64_t)&v674, (uint64_t)&v694, (uint64_t *)&v694, v304);
          unsigned int v298 = 0;
          void *v305 = v694;
          *((_DWORD *)v305 + 2) = 0;
          uint64_t v293 = v674;
          unsigned int v292 = v675;
          if (v675)
          {
LABEL_709:
            uint64_t v291 = v687;
            unsigned int v294 = v292 - 1;
LABEL_710:
            unsigned int v306 = ((v291 >> 4) ^ (v291 >> 9)) & v294;
            unsigned int v307 = (void *)(v293 + 16 * v306);
            uint64_t v308 = *v307;
            if (v291 != *v307)
            {
              int v309 = 0;
              int v310 = 1;
              while (v308 != -4096)
              {
                if (v309) {
                  BOOL v311 = 0;
                }
                else {
                  BOOL v311 = v308 == -8192;
                }
                if (v311) {
                  int v309 = v307;
                }
                unsigned int v312 = v306 + v310++;
                unsigned int v306 = v312 & v294;
                unsigned int v307 = (void *)(v293 + 16 * v306);
                uint64_t v308 = *v307;
                if (v291 == *v307) {
                  goto LABEL_724;
                }
              }
              if (v309) {
                v303 = v309;
              }
              else {
                v303 = v307;
              }
LABEL_723:
              unsigned int v307 = sub_1CBFAF8D8((uint64_t)&v674, (uint64_t)&v687, (uint64_t *)&v687, v303);
              *unsigned int v307 = v687;
              *((_DWORD *)v307 + 2) = 0;
            }
LABEL_724:
            if (v298 > *((_DWORD *)v307 + 2)) {
              sub_1CCD370D8((uint64_t)v619, (uint64_t *)v712);
            }
            v285 += 4;
            if (v285 == v289) {
              goto LABEL_438;
            }
            continue;
          }
          break;
        }
        v303 = 0;
        goto LABEL_723;
      }
      uint64_t v286 = *(void *)(v138 + 72);
      if (v282 == 25) {
        uint64_t v287 = v138;
      }
      else {
        uint64_t v287 = 0;
      }
      if (v287) {
        uint64_t v288 = (llvm::Value **)(v287 - 32);
      }
      else {
        uint64_t v288 = (llvm::Value **)(v138 - 64);
      }
      v712[0] = *v288;
      sub_1CCD370D8((uint64_t)v619, (uint64_t *)v712);
      sub_1CCD36F44(v712, (uint64_t)v633, (llvm::Instruction *)v286);
      long long v694 = *(_OWORD *)v712;
      long long v695 = *(_OWORD *)&v712[2];
      long long v696 = *(_OWORD *)&v712[4];
      if (!v607)
      {
        uint64_t v630 = 0;
        uint64_t v626 = 0;
        int v313 = sub_1CCD3782C((uint64_t)v633, v610, v286, (uint64_t)v624, (uint64_t)&v694, &v630, &v626);
        int v105 = v614;
        if (v313 != 4) {
          goto LABEL_730;
        }
        v712[0] = *(llvm::Value **)(v286 + 40);
        memset(&v712[1], 0, 20);
        long long v687 = 0uLL;
        LODWORD(v688) = 0;
        uint64_t v331 = sub_1CD761C70((uint64_t)&v681, (uint64_t *)v712, (uint64_t)&v712[1]);
        sub_1CD6881A8((uint64_t *)&v712[1]);
        sub_1CD6881A8((uint64_t *)&v687);
        uint64_t v332 = v630;
        uint64_t v333 = v626;
        v712[0] = (llvm::Value *)v286;
        uint64_t v334 = *(void *)&v624[8] & 0x7FFFFFFFFFFFFFFFLL;
        unint64_t v335 = *((void *)&v694 + 1) & 0x7FFFFFFFFFFFFFFFLL;
        uint64_t v336 = (*((void *)&v694 + 1) & 0x7FFFFFFFFFFFFFFFLL) + v626;
        if (byte_1EBCF0E88 && v336 > v630 && v334 + v630 >= v626)
        {
          uint64_t v600 = *((void *)&v694 + 1) & 0x7FFFFFFFFFFFFFFFLL;
          uint64_t v347 = sub_1CD687DFC(v331 + 8, (uint64_t *)v712);
          uint64_t v348 = v334 + v332;
          uint64_t v351 = (void *)v347[2];
          uint64_t v349 = v347 + 2;
          uint64_t v350 = v351;
          uint64_t v352 = (uint64_t **)(v349 - 1);
          *(void *)&long long v687 = v334 + v332;
          if (!v351) {
            goto LABEL_803;
          }
          uint64_t v353 = v349;
          do
          {
            uint64_t v354 = v350[4];
            BOOL v355 = v354 < v332;
            if (v354 >= v332) {
              int v356 = v350;
            }
            else {
              int v356 = v350 + 1;
            }
            if (!v355) {
              uint64_t v353 = v350;
            }
            uint64_t v350 = (void *)*v356;
          }
          while (*v356);
          if (v353 != v349)
          {
            uint64_t v359 = v353[5];
            uint64_t v357 = (uint64_t *)v332;
            if (v359 <= v348)
            {
              if (v359 >= v332) {
                uint64_t v359 = v332;
              }
              v594 = (uint64_t *)v359;
              int v596 = v349;
              if (v348 <= v353[4]) {
                uint64_t v348 = v353[4];
              }
              uint64_t v602 = v348;
              *(void *)&long long v687 = v348;
              v598 = (uint64_t **)(v349 - 1);
              int64_t v360 = sub_1CD508918((uint64_t **)v349 - 1, v353);
              operator delete(v353);
              if (v596 == v360)
              {
                uint64_t v348 = v602;
              }
              else
              {
                uint64_t v361 = v602;
                do
                {
                  if (v360[5] > v361) {
                    break;
                  }
                  if (v361 <= v360[4]) {
                    uint64_t v361 = v360[4];
                  }
                  v603 = sub_1CD508918(v598, v360);
                  operator delete(v360);
                  int64_t v360 = v603;
                }
                while (v596 != v603);
                *(void *)&long long v687 = v361;
                uint64_t v348 = v361;
              }
              uint64_t v352 = v598;
              uint64_t v357 = v594;
            }
          }
          else
          {
LABEL_803:
            uint64_t v357 = (uint64_t *)v332;
          }
          v358 = v352;
          sub_1CD65A160(v352, v348, (uint64_t **)&v687)[5] = v357;
          if ((*v358)[5] <= v333 && (*v358)[4] >= v336)
          {
            int v313 = 1;
            UnderlyingObject = v617;
            int v105 = v614;
            goto LABEL_730;
          }
          int v105 = v614;
          unint64_t v335 = v600;
        }
        if (v332 >= v333 && byte_1EBCF0F48 && v336 > v332 && v332 - v333 + v334 <= v335)
        {
          int v313 = 3;
          UnderlyingObject = v617;
          goto LABEL_730;
        }
        if (v332 <= v333 || byte_1EBCF0E88)
        {
          uint64_t v337 = v334 + v332;
        }
        else
        {
          uint64_t v337 = v334 + v332;
          if (v336 > v332)
          {
            UnderlyingObject = v617;
            if (v337 >= v336)
            {
              int v313 = 2;
              goto LABEL_730;
            }
            goto LABEL_771;
          }
        }
        UnderlyingObject = v617;
LABEL_771:
        if (v337 > v333 && byte_1EBCF0E88 == 0 && v332 <= v333) {
          int v313 = 0;
        }
        else {
          int v313 = 6;
        }
LABEL_730:
        if (!byte_1EBCF0F48 || v313 != 3)
        {
          if (v313 == 1) {
            goto LABEL_756;
          }
          goto LABEL_246;
        }
        if (*(unsigned char *)(v286 + 16) != 61) {
          uint64_t v286 = 0;
        }
        if (*(unsigned char *)(v610 + 16) == 61) {
          v314 = (const llvm::Instruction *)v610;
        }
        else {
          v314 = 0;
        }
        if (!v286) {
          goto LABEL_246;
        }
        if (!v314) {
          goto LABEL_246;
        }
        if (!llvm::DominatorTree::dominates(v605, (const llvm::Value *)v286, v314)) {
          goto LABEL_246;
        }
        uint64_t v315 = *(void *)(v286 - 64);
        v601 = (uint64_t **)(v286 - 64);
        if (*(unsigned char *)(v315 + 16) != 16) {
          goto LABEL_246;
        }
        int v599 = v630;
        int v316 = v626;
        uint64_t v317 = v654;
        uint64_t v318 = *(void *)v315;
        uint64_t v319 = sub_1CB83544C((uint64_t)v654, *(void *)v315);
        int v321 = v320;
        BOOL v34 = v319 == ((sub_1CB83544C((uint64_t)v317, v318) + 7) & 0xFFFFFFFFFFFFFFF8);
        int v105 = v614;
        BOOL v323 = v34 && v321 == (v322 == 1);
        UnderlyingObject = v617;
        if (!v323) {
          goto LABEL_246;
        }
        uint64_t v324 = *((void *)v314 - 8);
        if (*(unsigned char *)(v324 + 16) != 16) {
          goto LABEL_246;
        }
        uint64_t v325 = *(void *)v324;
        uint64_t v326 = sub_1CB83544C((uint64_t)v317, *(void *)v324);
        int v328 = v327;
        BOOL v34 = v326 == ((sub_1CB83544C((uint64_t)v317, v325) + 7) & 0xFFFFFFFFFFFFFFF8);
        int v105 = v614;
        BOOL v330 = v34 && v328 == (v329 == 1);
        UnderlyingObject = v617;
        if (!v330
          || !sub_1CCD39678(*(void *)(v286 + 32), *(llvm::BasicBlock **)(v286 + 40), (uint64_t)v314, &v641, (uint64_t)v317, v605))
        {
          goto LABEL_246;
        }
        unsigned int v597 = *((_DWORD *)*v601 + 8);
        if (v597 > 0x40) {
          operator new[]();
        }
        uint64_t v595 = (*v601)[3];
        uint64_t v340 = *((void *)v314 - 8);
        unsigned int v341 = *(_DWORD *)(v340 + 32);
        LODWORD(v712[1]) = v341;
        if (v341 > 0x40) {
          operator new[]();
        }
        unint64_t v342 = *(llvm::Value **)(v340 + 24);
        v712[0] = v342;
        unsigned int v343 = v597;
        int v105 = v614;
        DWORD2(v687) = v597;
        unint64_t v344 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v597;
        if (!v597) {
          unint64_t v344 = 0;
        }
        *(void *)&long long v687 = v344 & (unint64_t)v342;
        v712[0] = (llvm::Value *)(v344 & (unint64_t)v342);
        LODWORD(v712[1]) = DWORD2(v687);
        if (*(unsigned char *)v317) {
          unsigned int v345 = v597 - (v341 + 8 * (v599 - v316));
        }
        else {
          unsigned int v345 = 8 * (v599 - v316);
        }
        DWORD2(v687) = v597;
        unint64_t v346 = 0;
        *(void *)&long long v687 = 0;
        if (v341)
        {
          BOOL v110 = (BOOL *)(v345 + v341);
          if (v345 <= 0x3F && v110 <= 0x40)
          {
            unint64_t v346 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v341 << v345;
            *(void *)&long long v687 = v346;
LABEL_825:
            UnderlyingObject = v617;
            if (v343) {
              unint64_t v362 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v343;
            }
            else {
              unint64_t v362 = 0;
            }
            *(void *)&v629[0] = v362 & ~v346;
            DWORD2(v629[0]) = 0;
            LODWORD(v628) = v712[1];
            if (LODWORD(v712[1]) > 0x40) {
              operator new[]();
            }
            uint64_t v363 = (uint64_t)v712[0] << v345;
            if (LODWORD(v712[1]) == v345) {
              uint64_t v363 = 0;
            }
            unint64_t v364 = 0xFFFFFFFFFFFFFFFFLL >> -LOBYTE(v712[1]);
            if (!LODWORD(v712[1])) {
              unint64_t v364 = 0;
            }
            DWORD2(v708) = v712[1];
            *(void *)&long long v708 = v364 & v363 | v362 & ~v346 & v595;
            uint64_t v365 = **v601;
            Splat = llvm::ConstantInt::get(*(llvm::ConstantInt **)v365, (llvm::LLVMContext *)&v708, (const llvm::APInt *)v110);
            if ((*(_DWORD *)(v365 + 8) & 0xFE) == 0x12) {
              Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*(unsigned int *)(v365 + 32) | ((unint64_t)(*(_DWORD *)(v365 + 8) == 19) << 32)), (uint64_t)Splat);
            }
            if (DWORD2(v708) >= 0x41 && (void)v708) {
              MEMORY[0x1D25D9CB0](v708, 0x1000C8000313F17);
            }
            if (LODWORD(v712[1]) >= 0x41 && v712[0]) {
              MEMORY[0x1D25D9CB0](v712[0], 0x1000C8000313F17);
            }
            if (Splat)
            {
              if (*(void *)(v286 - 64))
              {
                **(void **)(v286 - 48) = *(void *)(v286 - 56);
                uint64_t v440 = *(void *)(v286 - 56);
                if (v440) {
                  *(void *)(v440 + 16) = *(void *)(v286 - 48);
                }
              }
              *(void *)(v286 - 64) = Splat;
              uint64_t v443 = Splat[1];
              v442 = (uint64_t ***)(Splat + 1);
              uint64_t v441 = v443;
              *(void *)(v286 - 56) = v443;
              if (v443) {
                *(void *)(v441 + 16) = v286 - 56;
              }
              *(void *)(v286 - 48) = v442;
              llvm::Instruction *v442 = v601;
              sub_1CCD37280((uint64_t)v633, (uint64_t)v314);
            }
            goto LABEL_246;
          }
          llvm::APInt::setBitsSlowCase(&v687, v345, v110);
          unsigned int v343 = v597;
        }
        DWORD2(v629[0]) = v343;
        goto LABEL_825;
      }
      int v105 = v614;
      if (UnderlyingObject == llvm::getUnderlyingObject((llvm *)v694, (const llvm::Value *)6)) {
LABEL_756:
      }
        sub_1CCD37280((uint64_t)v633, v286);
LABEL_246:
      unsigned int v111 = v621;
      uint64_t v112 = ++v113;
    }
    while (v113 < (unint64_t)((v622 - (unsigned char *)v621) >> 3));
LABEL_846:
    uint64_t v367 = *(void *)(v89 + 72);
    if (*(unsigned char *)(v367 + 16) == 61) {
      uint64_t v368 = *(void *)(v89 + 72);
    }
    else {
      uint64_t v368 = 0;
    }
    if (sub_1CC5818F8(*(void *)(v89 + 72))) {
      uint64_t v369 = v367;
    }
    else {
      uint64_t v369 = 0;
    }
    if (v368)
    {
      uint64_t v370 = (uint64_t *)(v368 - 64);
      unint64_t v88 = v608;
      uint64_t v371 = v610;
    }
    else
    {
      unint64_t v88 = v608;
      uint64_t v371 = v610;
      if (!v369) {
        goto LABEL_869;
      }
      uint64_t v370 = (uint64_t *)(v369 - 32 * (*(_DWORD *)(v369 + 20) & 0x7FFFFFF) + 32);
    }
    uint64_t v372 = *v370;
    if (*(unsigned __int8 *)(v372 + 16) >= 0x15u) {
      v373 = 0;
    }
    else {
      v373 = (llvm::UndefValue **)v372;
    }
    if (sub_1CCD38B34(v367))
    {
      if (v373
        && (byte_1EBD04470 ? (int v374 = 59) : (int v374 = 63),
            (sub_1CC095244((uint64_t)v617, v374, v653, v712), LOBYTE(v712[3]))
         && ((InitialValueOfAllocatiouint64_t n = llvm::getInitialValueOfAllocation((uint64_t)v617, v653, *v373)) != 0
           ? (BOOL v421 = InitialValueOfAllocation == (llvm::UndefValue *)v373)
           : (BOOL v421 = 0),
             v421)))
      {
        int v422 = v650;
        uint64_t SkipSelfWalker = llvm::MemorySSA::getSkipSelfWalker(v650);
        if (*((void *)v422 + 12) != (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)SkipSelfWalker + 16))(SkipSelfWalker, v89))goto LABEL_869; {
      }
        }
      else
      {
        if (!v368) {
          goto LABEL_869;
        }
        uint64_t v375 = *(void *)(v368 - 64);
        if (!v375 || *(unsigned char *)(v375 + 16) != 60 || *(void *)(v375 - 32) != *(void *)(v368 - 32)) {
          goto LABEL_869;
        }
        int v391 = *((_DWORD *)v650 + 10);
        if (!v391) {
          goto LABEL_894;
        }
        uint64_t v392 = *((void *)v650 + 3);
        unsigned int v393 = v391 - 1;
        uint64_t v394 = (v391 - 1) & ((v375 >> 4) ^ (v375 >> 9));
        uint64_t v395 = *(void *)(v392 + 16 * v394);
        if (v375 == v395)
        {
LABEL_893:
          uint64_t v398 = *(void *)(v392 + 16 * v394 + 8);
        }
        else
        {
          int v396 = 1;
          while (v395 != -4096)
          {
            int v397 = v394 + v396++;
            uint64_t v394 = v397 & v393;
            uint64_t v395 = *(void *)(v392 + 16 * v394);
            if (v375 == v395) {
              goto LABEL_893;
            }
          }
LABEL_894:
          uint64_t v398 = 0;
        }
        if (*(unsigned char *)(v398 + 16) == 25) {
          uint64_t v399 = v398;
        }
        else {
          uint64_t v399 = 0;
        }
        int v400 = (uint64_t *)(v398 - 64);
        if (v399) {
          int v400 = (uint64_t *)(v399 - 32);
        }
        uint64_t v401 = *v400;
        if (*(unsigned char *)(v89 + 16) == 25) {
          uint64_t v402 = v89;
        }
        else {
          uint64_t v402 = 0;
        }
        uint64_t v403 = (void *)(v402 - 32);
        BOOL v34 = v402 == 0;
        uint64_t v404 = (void *)(v89 - 64);
        if (!v34) {
          uint64_t v404 = v403;
        }
        if (v401 != *v404)
        {
          memset(v712, 0, 20);
          memset(&v712[3], 0, 24);
          uint64_t WalkerImpl = llvm::MemorySSA::getWalkerImpl(v650);
          *(void *)&long long v694 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)WalkerImpl + 16))(WalkerImpl, v89);
          *(void *)&long long v687 = v89;
          sub_1CCD370D8((uint64_t)v712, (uint64_t *)&v687);
          sub_1CCD370D8((uint64_t)v712, (uint64_t *)&v694);
          uint64_t v406 = v712[4];
          uint64_t v407 = v712[3];
          if ((llvm::Value *)(v712[4] - v712[3]) < (llvm::Value *)9)
          {
LABEL_928:
            char v418 = 0;
            if (!v407) {
              goto LABEL_930;
            }
            goto LABEL_929;
          }
          unint64_t v408 = 1;
          while (2)
          {
            uint64_t v409 = *((void *)v407 + v408);
            *(void *)&long long v694 = v409;
            if (v409) {
              BOOL v410 = *(unsigned char *)(v409 + 16) == 27;
            }
            else {
              BOOL v410 = 0;
            }
            char v411 = v410;
            if (!v410)
            {
LABEL_923:
              char v417 = v411 ^ 1;
              if (v401 == v409) {
                char v417 = 0;
              }
              if (v417)
              {
                char v418 = 1;
                if (!v407)
                {
LABEL_930:
                  MEMORY[0x1D25D9CD0](v712[0], 8);
                  if ((v418 & 1) == 0) {
                    goto LABEL_931;
                  }
                  goto LABEL_869;
                }
LABEL_929:
                v712[4] = v407;
                operator delete(v407);
                goto LABEL_930;
              }
              uint64_t v406 = v712[4];
              goto LABEL_927;
            }
            int v412 = *(_DWORD *)(v409 + 20);
            if ((v412 & 0x40000000) != 0)
            {
              unsigned int v414 = *(uint64_t **)(v409 - 8);
              uint64_t v413 = v412 & 0x7FFFFFF;
              if (!v413) {
                goto LABEL_927;
              }
            }
            else
            {
              uint64_t v413 = v412 & 0x7FFFFFF;
              unsigned int v414 = (uint64_t *)(v409 - 32 * v413);
              if (!v413)
              {
LABEL_927:
                unint64_t v408 = (v408 + 1);
                if (v408 >= (v406 - v407) >> 3) {
                  goto LABEL_928;
                }
                continue;
              }
            }
            break;
          }
          uint64_t v415 = 32 * v413;
          do
          {
            uint64_t v416 = *v414;
            v414 += 4;
            *(void *)&long long v687 = v416;
            sub_1CCD370D8((uint64_t)v712, (uint64_t *)&v687);
            v415 -= 32;
          }
          while (v415);
          uint64_t v407 = v712[3];
          goto LABEL_923;
        }
      }
LABEL_931:
      sub_1CCD37280((uint64_t)v633, v371);
    }
LABEL_869:
    uint64_t v376 = *(void *)(v89 + 72);
    BOOL v377 = sub_1CC5818F8(v376);
    if (!v376 || !v377) {
      goto LABEL_937;
    }
    uint64_t v378 = *(void *)(v376 - 32 * (*(_DWORD *)(v376 + 20) & 0x7FFFFFF) + 32);
    unsigned int v379 = *(unsigned __int8 *)(v378 + 16);
    if (!v378 || v379 > 0x14) {
      goto LABEL_937;
    }
    if (v379 != 16)
    {
      if (v379 == 17)
      {
        if (sub_1CB844168(v378, 0.0)) {
          goto LABEL_878;
        }
        goto LABEL_937;
      }
      if (v379 - 18 >= 3 && v379 != 13) {
        goto LABEL_937;
      }
LABEL_878:
      if (!sub_1CCD38B34(v376)) {
        goto LABEL_937;
      }
      uint64_t v382 = *(void *)(v633[0] + 112);
      if (v382)
      {
        if ((*(unsigned char *)(v382 + 18) & 0x2C) != 0) {
          goto LABEL_937;
        }
      }
      if ((*(unsigned char *)(v633[0] + 23) & 0x10) == 0) {
        goto LABEL_960;
      }
      uint64_t v383 = ***(void ***)v633[0];
      uint64_t v384 = *(void *)(v383 + 152);
      uint64_t v385 = *(unsigned int *)(v383 + 168);
      if (v385)
      {
        LODWORD(v386) = (v385 - 1) & ((LODWORD(v633[0]) >> 4) ^ (LODWORD(v633[0]) >> 9));
        int v387 = (uint64_t *)(v384 + 16 * v386);
        uint64_t v388 = *v387;
        if (*v387 == v633[0])
        {
LABEL_955:
          uint64_t v424 = v387[1];
          if (*(void *)v424 == 6)
          {
            int v425 = *(_DWORD *)(v424 + 16);
            int v426 = *(unsigned __int16 *)(v424 + 20);
            if (v425 == 1819042147 && v426 == 25455) {
              goto LABEL_937;
            }
          }
LABEL_960:
          if (!v617) {
            goto LABEL_937;
          }
          if (*((unsigned char *)v617 + 16) != 84) {
            goto LABEL_937;
          }
          uint64_t v428 = *((void *)v617 - 4);
          if (!v428) {
            goto LABEL_937;
          }
          if (*(unsigned char *)(v428 + 16)) {
            goto LABEL_937;
          }
          if (*(void *)(v428 + 24) != *((void *)v617 + 9)) {
            goto LABEL_937;
          }
          LODWORD(v629[0]) = 0;
          if (!llvm::TargetLibraryInfoImpl::getLibFunc(*v653, (uint64_t ***)v428, v629)) {
            goto LABEL_937;
          }
          if ((*(void *)(v653[1] + (((unint64_t)LODWORD(v629[0]) >> 3) & 0x1FFFFFF8)) >> SLOBYTE(v629[0]))) {
            goto LABEL_937;
          }
          if (LODWORD(v629[0]) != 317) {
            goto LABEL_937;
          }
          if ((*(unsigned char *)(*v653 + 79) & 0xC) == 0) {
            goto LABEL_937;
          }
          uint64_t v429 = (llvm::IntegerType ***)v617;
          uint64_t v430 = v376 - 32 * (*(_DWORD *)(v376 + 20) & 0x7FFFFFF);
          if (*((void *)v617 - 4 * (*((_DWORD *)v617 + 5) & 0x7FFFFFF)) != *(void *)(v430 + 64)) {
            goto LABEL_937;
          }
          uint64_t v431 = *((void *)v617 + 5);
          uint64_t v432 = *(void *)(v376 + 40);
          if (v431 != v432)
          {
            uint64_t v433 = *(void *)(v431 + 40);
            if (v433 == v431 + 40)
            {
              uint64_t v435 = 0;
            }
            else
            {
              uint64_t v434 = v433 - 24;
              if (!v433) {
                uint64_t v434 = 0;
              }
              if (*(unsigned __int8 *)(v434 + 16) - 29 >= 0xB) {
                uint64_t v435 = 0;
              }
              else {
                uint64_t v435 = v434;
              }
            }
            v444 = *(llvm::Value **)v430;
            LODWORD(v708) = 0;
            *(void *)&long long v694 = 0;
            *(void *)&long long v687 = 0;
            v712[0] = (llvm::Value *)&v708;
            v712[1] = v444;
            v712[3] = (llvm::Value *)&v694;
            v712[4] = (llvm::Value *)&v687;
            if (!v435) {
              goto LABEL_1012;
            }
            if (*(unsigned char *)(v435 + 16) != 30) {
              goto LABEL_1012;
            }
            if ((*(_DWORD *)(v435 + 20) & 0x7FFFFFF) != 3) {
              goto LABEL_1012;
            }
            if (!sub_1CD761ED0((uint64_t)v712, *(void *)(v435 - 96))) {
              goto LABEL_1012;
            }
            if (!*(void *)(v435 - 32)) {
              goto LABEL_1012;
            }
            *(void *)&long long v694 = *(void *)(v435 - 32);
            uint64_t v445 = *(void *)(v435 - 64);
            if (!v445) {
              goto LABEL_1012;
            }
            unint64_t v88 = v608;
            uint64_t v429 = (llvm::IntegerType ***)v617;
            if (v708 != 32 || v432 != v445) {
              goto LABEL_937;
            }
          }
          if (!llvm::DominatorTree::dominates(v651, (const llvm::Value *)v429, (const llvm::Instruction *)v376)|| !sub_1CCD39678((uint64_t)v429[4], (llvm::BasicBlock *)v429[5], v376, &v641, (uint64_t)v654, v651))
          {
            goto LABEL_937;
          }
          uint64_t v446 = 0;
          uint64_t v447 = **v429;
          *(void *)&long long v694 = &v695;
          *((void *)&v694 + 1) = 0x200000000;
          v699 = v447;
          v700 = &v706;
          uint64_t v701 = &v707;
          uint64_t v702 = 0;
          LODWORD(v703) = 0;
          WORD2(v703) = 512;
          BYTE6(v703) = 7;
          v697 = 0;
          char v698 = 0;
          uint64_t v704 = 0;
          uint64_t v705 = 0;
          v706 = &unk_1F2616E88;
          uint64_t v707 = &unk_1F2617008;
          v697 = v429[5];
          char v698 = v429 + 3;
          uint64_t v448 = (unsigned __int8 *)v429[6];
          *(void *)&long long v687 = v448;
          if (v448)
          {
            llvm::MetadataTracking::track((uint64_t)&v687, v448, 2);
            uint64_t v446 = v687;
          }
          sub_1CB8461A4((uint64_t)&v694, 0, v446);
          if (!(void)v687)
          {
LABEL_1004:
            uint64_t v449 = llvm::IntegerType::get(v699, (llvm::LLVMContext *)*(unsigned int *)(*(void *)(*(void *)(*(void *)(*((void *)v617 + 5)+ 56)+ 40)+ 504)+ 4));
            int v451 = *(llvm::ConstantInt **)v449;
            unsigned int v452 = *(_DWORD *)(v449 + 8);
            LODWORD(v712[1]) = v452 >> 8;
            if (v452 >> 8 > 0x40) {
              operator new[]();
            }
            if (v452 <= 0xFF) {
              LOBYTE(v453) = 0;
            }
            else {
              unint64_t v453 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v452) + 63);
            }
            v712[0] = (llvm::Value *)(v453 & 1);
            __int16 v454 = llvm::ConstantInt::get(v451, (llvm::LLVMContext *)v712, v450);
            if (LODWORD(v712[1]) >= 0x41 && v712[0]) {
              MEMORY[0x1D25D9CB0](v712[0], 0x1000C8000313F17);
            }
            int v455 = (llvm::Instruction *)llvm::emitCalloc((uint64_t)v454, *((void *)v617 - 4 * (*((_DWORD *)v617 + 5) & 0x7FFFFFF)), (uint64_t)&v694, v653);
            if (!v455)
            {
              if ((long long *)v694 != &v695) {
                free((void *)v694);
              }
LABEL_1012:
              unint64_t v88 = v608;
              goto LABEL_937;
            }
            v712[0] = v650;
            v712[1] = (llvm::Value *)&v712[3];
            v712[2] = (llvm::Value *)0x1000000000;
            v727 = v730;
            v728[0] = v730;
            v728[1] = (void *)8;
            int v729 = 0;
            v731 = v733;
            uint64_t v732 = 0x800000000;
            v734[0] = 0;
            v734[1] = 0;
            v733[8] = v734;
            int v456 = *((_DWORD *)v650 + 10);
            if (v456)
            {
              uint64_t v457 = *((void *)v650 + 3);
              unsigned int v458 = v456 - 1;
              uint64_t v459 = (v456 - 1) & ((v617 >> 4) ^ (v617 >> 9));
              uint64_t v460 = *(llvm::Value **)(v457 + 16 * v459);
              if (v617 == v460)
              {
LABEL_1018:
                int v463 = *(llvm::MemoryAccess **)(v457 + 16 * v459 + 8);
                goto LABEL_1026;
              }
              int v461 = 1;
              while (v460 != (llvm::Value *)-4096)
              {
                int v462 = v459 + v461++;
                uint64_t v459 = v462 & v458;
                uint64_t v460 = *(llvm::Value **)(v457 + 16 * v459);
                if (v617 == v460) {
                  goto LABEL_1018;
                }
              }
            }
            int v463 = 0;
LABEL_1026:
            MemoryAccessAfter = llvm::MemorySSAUpdater::createMemoryAccessAfter((uint64_t **)v712, v455, v463, (const llvm::BasicBlock **)v463);
            llvm::MemorySSAUpdater::insertDef((llvm::MemorySSAUpdater *)v712, (llvm::MemoryDef *)MemoryAccessAfter);
          }
          int v464 = *(unsigned __int8 *)v687;
          if ((v464 - 4) > 0x1E)
          {
            if ((v464 - 3) >= 0xFFFFFFFE) {
              uint64_t v468 = v687;
            }
            else {
              uint64_t v468 = 0;
            }
            if ((v464 - 3) < 0xFFFFFFFE)
            {
              if (v464 == 3) {
                *(void *)(v687 + 8) = 0;
              }
              goto LABEL_1004;
            }
            unint64_t v466 = v468 + 8;
          }
          else
          {
            if ((*(unsigned char *)(v687 + 1) & 0x7F) != 2 && !*(_DWORD *)(v687 + 12)) {
              goto LABEL_1004;
            }
            uint64_t v465 = *(void *)(v687 + 16);
            if ((v465 & 4) == 0) {
              goto LABEL_1004;
            }
            unint64_t v466 = v465 & 0xFFFFFFFFFFFFFFF8;
            if (!v466) {
              goto LABEL_1004;
            }
          }
          v712[0] = (llvm::Value *)&v687;
          sub_1CC5FA668(v466 + 16, v712);
          goto LABEL_1004;
        }
        int v389 = 1;
        while (v388 != -4096)
        {
          int v390 = v386 + v389++;
          uint64_t v386 = v390 & (v385 - 1);
          uint64_t v388 = *(void *)(v384 + 16 * v386);
          if (v388 == v633[0])
          {
            int v387 = (uint64_t *)(v384 + 16 * v386);
            goto LABEL_955;
          }
        }
      }
      int v387 = (uint64_t *)(v384 + 16 * v385);
      goto LABEL_955;
    }
    uint64_t v381 = *(unsigned int *)(v378 + 32);
    if (v381 >= 0x41)
    {
      int v436 = 0;
      int64_t v437 = (unint64_t)(v381 + 63) >> 6;
      do
      {
        BOOL v170 = v437-- < 1;
        if (v170) {
          break;
        }
        unint64_t v438 = *(void *)(*(void *)(v378 + 24) + 8 * v437);
        v436 += __clz(v438);
      }
      while (!v438);
      int v439 = v381 | 0xFFFFFFC0;
      if ((v381 & 0x3F) == 0) {
        int v439 = 0;
      }
      if (v436 + v439 != v381) {
        goto LABEL_937;
      }
      goto LABEL_878;
    }
    if (!*(void *)(v378 + 24)) {
      goto LABEL_878;
    }
LABEL_937:
    if (v621) {
      operator delete(v621);
    }
    MEMORY[0x1D25D9CD0](v619[0], 8);
LABEL_940:
    unint64_t v87 = v658;
LABEL_941:
    ++v88;
  }
  while (v88 < v87);
LABEL_1039:
  if (byte_1EBCF0E88)
  {
    unsigned int v469 = (llvm *)v683;
    v615 = v684;
    if (v683 != v684)
    {
      while (1)
      {
        uint64_t v470 = *((void *)v469 + 1);
        uint64_t v471 = *((unsigned int *)v469 + 6);
        int v472 = (uint64_t *)(v470 + 32 * v471);
        if (*((_DWORD *)v469 + 4))
        {
          if (*((_DWORD *)v469 + 6))
          {
            uint64_t v473 = 32 * v471;
            uint64_t v474 = (uint64_t *)*((void *)v469 + 1);
            while ((*v474 | 0x1000) == 0xFFFFFFFFFFFFF000)
            {
              v474 += 4;
              v473 -= 32;
              if (!v473) {
                goto LABEL_1046;
              }
            }
          }
          else
          {
            uint64_t v474 = (uint64_t *)*((void *)v469 + 1);
          }
        }
        else
        {
LABEL_1046:
          uint64_t v474 = (uint64_t *)(v470 + 32 * v471);
        }
        int v618 = (llvm::Value *)(v470 + 32 * v471);
        if (v474 != (uint64_t *)v618) {
          break;
        }
        LOBYTE(v475) = 0;
LABEL_1128:
        v612 |= v475;
        unsigned int v469 = (llvm *)((char *)v469 + 32);
        if (v469 == v615)
        {
          unint64_t v87 = v658;
          goto LABEL_1130;
        }
      }
      int v475 = 0;
      while (2)
      {
        uint64_t v476 = *v474;
        long long v695 = 0uLL;
        *(void *)&long long v694 = v476;
        *((void *)&v694 + 1) = &v695;
        BOOL v477 = (uint64_t *)v474[1];
        if (v477 != v474 + 2)
        {
          do
          {
            sub_1CD65A22C((void **)&v694 + 1, &v695, v477[4], (_OWORD *)v477 + 2);
            v478 = (uint64_t *)v477[1];
            if (v478)
            {
              do
              {
                v479 = v478;
                v478 = (uint64_t *)*v478;
              }
              while (v478);
            }
            else
            {
              do
              {
                v479 = (uint64_t *)v477[2];
                BOOL v34 = *v479 == (void)v477;
                BOOL v477 = v479;
              }
              while (!v34);
            }
            BOOL v477 = v479;
          }
          while (v479 != v474 + 2);
          uint64_t v476 = v694;
        }
        sub_1CCD36F44(v712, (uint64_t)v633, (llvm::Instruction *)v476);
        unint64_t v480 = (unint64_t)v712[1];
        int v481 = llvm::Value::stripPointerCasts(v712[0]);
        unint64_t v483 = v480 & 0x7FFFFFFFFFFFFFFFLL;
        *(void *)&long long v708 = v480 & 0x7FFFFFFFFFFFFFFFLL;
        unsigned int v484 = *(_DWORD *)(*(void *)v481 + 8);
        if ((v484 & 0xFE) == 0x12) {
          unsigned int v484 = *(_DWORD *)(**(void **)(*(void *)v481 + 16) + 8);
        }
        if (v484 < 0x100) {
          goto LABEL_1069;
        }
        unsigned int v485 = v484 >> 8;
        uint64_t v486 = *((unsigned int *)v654 + 60);
        uint64_t v487 = *((void *)v654 + 29);
        if (v486)
        {
          uint64_t v487 = *((void *)v654 + 29);
          unint64_t v488 = *((unsigned int *)v654 + 60);
          do
          {
            unint64_t v489 = v488 >> 1;
            uint64_t v490 = v487 + 16 * (v488 >> 1);
            unsigned int v491 = *(_DWORD *)(v490 + 8);
            uint64_t v492 = v490 + 16;
            v488 += ~(v488 >> 1);
            if (v491 < v485) {
              uint64_t v487 = v492;
            }
            else {
              unint64_t v488 = v489;
            }
          }
          while (v488);
        }
        if (v487 == *((void *)v654 + 29) + 16 * v486 || *(_DWORD *)(v487 + 8) != v485) {
LABEL_1069:
        }
          uint64_t v487 = *((void *)v654 + 29);
        LODWORD(v712[1]) = *(_DWORD *)(v487 + 12);
        if (LODWORD(v712[1]) > 0x40) {
          operator new[]();
        }
        v712[0] = 0;
        llvm::Value::stripAndAccumulateConstantOffsets(v481, v654, (llvm::APInt *)v712, 1, 0, 0, v482);
        if (LODWORD(v712[1]) > 0x40)
        {
          uint64_t v493 = *(void *)v712[0];
          MEMORY[0x1D25D9CB0]();
        }
        else
        {
          uint64_t v493 = (uint64_t)v712[0] << -(uint64_t)LODWORD(v712[1]) >> -(uint64_t)LODWORD(v712[1]);
        }
        *(void *)&long long v687 = v493;
        if (*((void *)&v695 + 1))
        {
          if (*(unsigned char *)(v476 + 16) != 84) {
            goto LABEL_1106;
          }
          uint64_t v494 = *(void *)(v476 - 32);
          if (!v494
            || *(unsigned char *)(v494 + 16)
            || *(void *)(v494 + 24) != *(void *)(v476 + 72)
            || (*(unsigned char *)(v494 + 33) & 0x20) == 0)
          {
            goto LABEL_1100;
          }
          int v495 = 0;
          unsigned int v496 = *(_DWORD *)(v494 + 36) - 194;
          if (v496 > 6 || ((1 << v496) & 0x63) == 0) {
            goto LABEL_1101;
          }
          v497 = (uint64_t *)v695;
          v498 = (uint64_t *)&v695;
          if ((void)v695)
          {
            do
            {
              v499 = v497;
              v497 = (uint64_t *)v497[1];
            }
            while (v497);
          }
          else
          {
            do
            {
              v499 = (uint64_t *)v498[2];
              BOOL v34 = *v499 == (void)v498;
              v498 = v499;
            }
            while (v34);
          }
          uint64_t v500 = v499[5];
          unint64_t v501 = v500 - v493;
          if (v500 <= v493
            || ((unint64_t v502 = v499[4] - v500, v504 = v483 >= v501, v503 = v483 - v501, v503 != 0 && v504)
              ? (BOOL v504 = v502 >= v503)
              : (BOOL v504 = 0),
                !v504
             || !sub_1CCD39CE8((uint64_t ***)v476, &v687, (unint64_t *)&v708, v500, v502, 1)))
          {
LABEL_1100:
            int v495 = 0;
            goto LABEL_1101;
          }
          v505 = (uint64_t *)v499[1];
          int v506 = v499;
          if (v505)
          {
            do
            {
              int v507 = v505;
              v505 = (uint64_t *)*v505;
            }
            while (v505);
          }
          else
          {
            do
            {
              int v507 = (uint64_t *)v506[2];
              BOOL v34 = *v507 == (void)v506;
              int v506 = v507;
            }
            while (!v34);
          }
          if (*((uint64_t **)&v694 + 1) == v499) {
            *((void *)&v694 + 1) = v507;
          }
          --*((void *)&v695 + 1);
          sub_1CB91F7C8((uint64_t *)v695, v499);
          operator delete(v499);
          int v495 = 1;
LABEL_1101:
          v475 |= v495;
          if (*((void *)&v695 + 1))
          {
LABEL_1106:
            if (sub_1CBF63B78(v476)
              && ((v508 = (uint64_t *)*((void *)&v694 + 1),
                   uint64_t v509 = *(void *)(*((void *)&v694 + 1) + 40),
                   unint64_t v510 = *(void *)(*((void *)&v694 + 1) + 32) - v509,
                   (uint64_t)v687 >= v509)
                ? (BOOL v511 = v510 > (uint64_t)v687 - v509)
                : (BOOL v511 = 0),
                  v511))
            {
              int v514 = sub_1CCD39CE8((uint64_t ***)v476, &v687, (unint64_t *)&v708, v509, v510, 0);
              int v512 = 0;
              if (v514)
              {
                uint64_t v515 = (uint64_t *)v508[1];
                uint64_t v516 = v508;
                if (v515)
                {
                  do
                  {
                    uint64_t v517 = v515;
                    uint64_t v515 = (uint64_t *)*v515;
                  }
                  while (v515);
                }
                else
                {
                  do
                  {
                    uint64_t v517 = (uint64_t *)v516[2];
                    BOOL v34 = *v517 == (void)v516;
                    uint64_t v516 = v517;
                  }
                  while (!v34);
                }
                if (*((uint64_t **)&v694 + 1) == v508) {
                  *((void *)&v694 + 1) = v517;
                }
                --*((void *)&v695 + 1);
                sub_1CB91F7C8((uint64_t *)v695, v508);
                operator delete(v508);
                int v512 = 1;
              }
            }
            else
            {
              int v512 = 0;
            }
            v475 |= v512;
          }
        }
        sub_1CD40B1BC((void *)v695);
        int v513 = v474 + 4;
        uint64_t v474 = v472;
        if (v513 != v472)
        {
          uint64_t v474 = v513;
          while ((*v474 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v474 += 4;
            if (v474 == v472)
            {
              uint64_t v474 = v472;
              break;
            }
          }
        }
        if (v474 == (uint64_t *)v618) {
          goto LABEL_1128;
        }
        continue;
      }
    }
  }
LABEL_1130:
  if (!v87) {
    goto LABEL_1306;
  }
  v518 = (uint64_t *)v657;
  v519 = (char *)v657 + 8 * v87;
  while (2)
  {
    uint64_t v520 = *v518;
    int v521 = v660;
    if (v661 == v660)
    {
      unsigned int v522 = HIDWORD(v662);
      v523 = (char *)v661 + 8 * HIDWORD(v662);
      if (HIDWORD(v662))
      {
        uint64_t v524 = 0;
        while (*(void *)((char *)v661 + v524) != v520)
        {
          v524 += 8;
          if (8 * HIDWORD(v662) == v524) {
            goto LABEL_1151;
          }
        }
        v523 = (char *)v661 + v524;
      }
LABEL_1151:
      int v521 = v661;
    }
    else
    {
      int v525 = v662 - 1;
      unsigned int v526 = (v662 - 1) & ((v520 >> 4) ^ (v520 >> 9));
      v523 = (char *)v661 + 8 * v526;
      uint64_t v527 = *(void *)v523;
      if (*(void *)v523 == -1)
      {
        v528 = 0;
LABEL_1166:
        if (v528) {
          v523 = v528;
        }
        unsigned int v522 = HIDWORD(v662);
        if (*(void *)v523 != v520) {
          v523 = (char *)v661 + 8 * v662;
        }
      }
      else
      {
        v528 = 0;
        int v529 = 1;
        while (v527 != v520)
        {
          if (v528) {
            BOOL v530 = 0;
          }
          else {
            BOOL v530 = v527 == -2;
          }
          if (v530) {
            v528 = v523;
          }
          unsigned int v531 = v526 + v529++;
          unsigned int v526 = v531 & v525;
          v523 = (char *)v661 + 8 * (v531 & v525);
          uint64_t v527 = *(void *)v523;
          if (*(void *)v523 == -1) {
            goto LABEL_1166;
          }
        }
        unsigned int v522 = HIDWORD(v662);
      }
    }
    if (v661 == v521) {
      unsigned int v532 = v522;
    }
    else {
      unsigned int v532 = v662;
    }
    if (v523 == (char *)v661 + 8 * v532 && *((void *)v650 + 12) != v520)
    {
      v533 = *(llvm::Instruction **)(v520 + 72);
      sub_1CCD36F44(&v694, (uint64_t)v633, v533);
      if ((_BYTE)v697)
      {
        if (sub_1CCD38B34((uint64_t)v533))
        {
          uint64_t v534 = *(void *)(v520 - 32);
          if (!v534) {
            goto LABEL_1172;
          }
          int v535 = *(_DWORD *)(v520 + 92);
          if (*(unsigned char *)(v534 + 16) == 26)
          {
            if (v535 == *(_DWORD *)(v534 + 88)) {
              goto LABEL_1179;
            }
            goto LABEL_1172;
          }
          if (v535 != *(_DWORD *)(v534 + 72))
          {
LABEL_1172:
            if (*(unsigned char *)(v520 + 16) == 25) {
              uint64_t v536 = v520;
            }
            else {
              uint64_t v536 = 0;
            }
            if (v536) {
              v537 = (uint64_t *)(v536 - 32);
            }
            else {
              v537 = (uint64_t *)(v520 - 64);
            }
            uint64_t v534 = *v537;
            if (*(unsigned char *)(v534 + 16) == 26)
            {
LABEL_1179:
              if (*((void *)v650 + 12) != v534)
              {
                uint64_t v538 = *(void *)(v534 + 72);
                if (llvm::Instruction::isIdenticalToWhenDefined(v533, (const llvm::Instruction *)v538))
                {
                  if ((*(unsigned __int8 *)(v538 + 17) ^ *((unsigned __int8 *)v533 + 17)) < 2) {
                    goto LABEL_1194;
                  }
                }
                BOOL v539 = sub_1CC5818F8(v538);
                if (v538 && v539)
                {
                  if (v533)
                  {
                    if (*((unsigned char *)v533 + 16) == 61)
                    {
                      sub_1CCD36F44(v712, (uint64_t)v633, (llvm::Instruction *)v538);
                      long long v687 = *(_OWORD *)v712;
                      long long v688 = *(_OWORD *)&v712[2];
                      long long v689 = *(_OWORD *)&v712[4];
                      v712[0] = 0;
                      *(void *)&long long v708 = 0;
                      int v541 = sub_1CCD3782C((uint64_t)v633, v538, (uint64_t)v533, (uint64_t)&v687, (uint64_t)&v694, (uint64_t *)v712, (uint64_t *)&v708);
                      v543 = llvm::isBytewiseValue(*((llvm **)v533 - 8), v654, v542);
                      if (v543)
                      {
                        if (v543 == *(llvm::Value **)(v538 - 32 * (*(_DWORD *)(v538 + 20) & 0x7FFFFFF) + 32)
                          && v541 == 1)
                        {
LABEL_1194:
                          if (!sub_1CCD38910((uint64_t)v633, &v694, (uint64_t)v533)) {
                            sub_1CCD37280((uint64_t)v633, (uint64_t)v533);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (++v518 != (uint64_t *)v519) {
      continue;
    }
    break;
  }
  if (v658)
  {
    v545 = (char *)v657;
    v546 = (char *)v657 + 8 * v658;
    do
    {
      uint64_t v548 = *((void *)v546 - 1);
      v546 -= 8;
      uint64_t v547 = v548;
      unsigned int v549 = v660;
      if (v661 == v660)
      {
        unsigned int v550 = HIDWORD(v662);
        int v551 = (char *)v661 + 8 * HIDWORD(v662);
        if (HIDWORD(v662))
        {
          uint64_t v552 = 0;
          while (*(void *)((char *)v661 + v552) != v547)
          {
            v552 += 8;
            if (8 * HIDWORD(v662) == v552) {
              goto LABEL_1217;
            }
          }
          int v551 = (char *)v661 + v552;
        }
LABEL_1217:
        unsigned int v549 = v661;
      }
      else
      {
        int v553 = v662 - 1;
        unsigned int v554 = (v662 - 1) & ((v547 >> 4) ^ (v547 >> 9));
        int v551 = (char *)v661 + 8 * v554;
        uint64_t v555 = *(void *)v551;
        if (*(void *)v551 == -1)
        {
          char v556 = 0;
LABEL_1235:
          if (v556) {
            int v551 = v556;
          }
          unsigned int v550 = HIDWORD(v662);
          if (*(void *)v551 != v547) {
            int v551 = (char *)v661 + 8 * v662;
          }
        }
        else
        {
          char v556 = 0;
          int v557 = 1;
          while (v555 != v547)
          {
            if (v556) {
              BOOL v558 = 0;
            }
            else {
              BOOL v558 = v555 == -2;
            }
            if (v558) {
              char v556 = v551;
            }
            unsigned int v559 = v554 + v557++;
            unsigned int v554 = v559 & v553;
            int v551 = (char *)v661 + 8 * (v559 & v553);
            uint64_t v555 = *(void *)v551;
            if (*(void *)v551 == -1) {
              goto LABEL_1235;
            }
          }
          unsigned int v550 = HIDWORD(v662);
        }
      }
      if (v661 == v549) {
        unsigned int v560 = v550;
      }
      else {
        unsigned int v560 = v662;
      }
      if (v551 == (char *)v661 + 8 * v560)
      {
        v561 = *(llvm::Instruction **)(v547 + 72);
        sub_1CCD36F44(&v687, (uint64_t)v633, v561);
        if (v690)
        {
          if (sub_1CCD38B34((uint64_t)v561))
          {
            int v562 = llvm::getUnderlyingObject((llvm *)v687, (const llvm::Value *)6);
            if (sub_1CCD39028((uint64_t)v633, v562))
            {
              sub_1CCD36F44(&v694, (uint64_t)v633, *(llvm::Instruction **)(v547 + 72));
              if ((_BYTE)v697)
              {
                *(void *)&long long v708 = &v709;
                *((void *)&v708 + 1) = 0x400000000;
                v712[0] = (llvm::Value *)&v712[4];
                v712[1] = (llvm::Value *)&v712[4];
                LODWORD(v712[3]) = 0;
                v712[2] = (llvm::Value *)0x100000008;
                v712[4] = (llvm::Value *)v547;
                uint64_t v563 = *(void *)(v547 + 8);
                if (!v563)
                {
                  BOOL v565 = 1;
                  goto LABEL_1300;
                }
                unsigned int v564 = 0;
                do
                {
                  if (v564 >= HIDWORD(v708)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(v708 + 8 * v564) = *(void *)(v563 + 24);
                  unsigned int v564 = ++DWORD2(v708);
                  uint64_t v563 = *(void *)(v563 + 8);
                }
                while (v563);
                BOOL v565 = v564 == 0;
                if (v564) {
                  BOOL v566 = v564 >= dword_1EBCF1008;
                }
                else {
                  BOOL v566 = 1;
                }
                if (!v566)
                {
                  unint64_t v567 = 0;
                  while (1)
                  {
                    uint64_t v568 = *(void *)(v708 + 8 * v567);
                    if (*(unsigned char *)(v568 + 16) == 27 || sub_1CCD38910((uint64_t)v633, &v694, *(void *)(v568 + 72)))
                    {
                      BOOL v565 = 0;
                      goto LABEL_1300;
                    }
                    if (*(unsigned char *)(v568 + 16) == 26) {
                      break;
                    }
LABEL_1286:
                    BOOL v565 = ++v567 >= DWORD2(v708);
                    if (v567 >= DWORD2(v708) || DWORD2(v708) >= dword_1EBCF1008) {
                      goto LABEL_1300;
                    }
                  }
                  unint64_t v569 = v712[1];
                  uint64_t v570 = HIDWORD(v712[2]);
                  if (v712[1] == v712[0])
                  {
                    if (HIDWORD(v712[2]))
                    {
                      int v571 = 0;
                      uint64_t v572 = 8 * HIDWORD(v712[2]);
                      unint64_t v573 = v712[1];
                      while (*(void *)v573 != v568)
                      {
                        if (*(void *)v573 == -2) {
                          int v571 = v573;
                        }
                        unint64_t v573 = (llvm::Value *)((char *)v573 + 8);
                        v572 -= 8;
                        if (!v572)
                        {
                          if (!v571) {
                            goto LABEL_1256;
                          }
                          *(void *)int v571 = v568;
                          --LODWORD(v712[3]);
                          goto LABEL_1280;
                        }
                      }
                      goto LABEL_1286;
                    }
LABEL_1256:
                    unsigned int v574 = v712[2];
                    if (HIDWORD(v712[2]) < LODWORD(v712[2]))
                    {
                      ++HIDWORD(v712[2]);
                      *((void *)v712[1] + v570) = v568;
LABEL_1280:
                      uint64_t v584 = *(void *)(v568 + 8);
                      if (v584)
                      {
                        unsigned int v585 = DWORD2(v708);
                        do
                        {
                          if (v585 >= HIDWORD(v708)) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          *(void *)(v708 + 8 * v585) = *(void *)(v584 + 24);
                          unsigned int v585 = ++DWORD2(v708);
                          uint64_t v584 = *(void *)(v584 + 8);
                        }
                        while (v584);
                      }
                      goto LABEL_1286;
                    }
                  }
                  else
                  {
                    unsigned int v574 = v712[2];
                  }
                  if (3 * v574 <= 4 * (HIDWORD(v712[2]) - LODWORD(v712[3])))
                  {
                    if (v574 >= 0x40) {
                      v574 *= 2;
                    }
                    else {
                      unsigned int v574 = 128;
                    }
                  }
                  else if (v574 - HIDWORD(v712[2]) >= v574 >> 3)
                  {
LABEL_1261:
                    unsigned int v575 = v574 - 1;
                    unsigned int v576 = (v574 - 1) & ((v568 >> 4) ^ (v568 >> 9));
                    int v577 = (void *)((char *)v569 + 8 * v576);
                    uint64_t v578 = *v577;
                    if (*v577 != -1)
                    {
                      unint64_t v579 = 0;
                      int v580 = 1;
                      while (v578 != v568)
                      {
                        if (v579) {
                          BOOL v581 = 0;
                        }
                        else {
                          BOOL v581 = v578 == -2;
                        }
                        if (v581) {
                          unint64_t v579 = v577;
                        }
                        unsigned int v582 = v576 + v580++;
                        unsigned int v576 = v582 & v575;
                        int v577 = (void *)((char *)v569 + 8 * (v582 & v575));
                        uint64_t v578 = *v577;
                        if (*v577 == -1) {
                          goto LABEL_1273;
                        }
                      }
                      goto LABEL_1286;
                    }
                    unint64_t v579 = 0;
LABEL_1273:
                    if (v579) {
                      int v583 = v579;
                    }
                    else {
                      int v583 = v577;
                    }
                    if (*v583 == v568) {
                      goto LABEL_1286;
                    }
                    if (*v583 == -2) {
                      --LODWORD(v712[3]);
                    }
                    else {
                      ++HIDWORD(v712[2]);
                    }
                    *int v583 = v568;
                    goto LABEL_1280;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v712, v574);
                  unsigned int v574 = v712[2];
                  unint64_t v569 = v712[1];
                  goto LABEL_1261;
                }
LABEL_1300:
                if (v712[1] != v712[0]) {
                  free(v712[1]);
                }
                if ((long long *)v708 != &v709) {
                  free((void *)v708);
                }
                if (v565) {
                  sub_1CCD37280((uint64_t)v633, (uint64_t)v561);
                }
              }
            }
          }
        }
      }
    }
    while (v546 != v545);
  }
LABEL_1306:
  v587 = (llvm *)v683;
  if (v683)
  {
    v588 = v684;
    v589 = v683;
    if (v684 != v683)
    {
      do
      {
        v590 = (llvm *)((char *)v588 - 32);
        sub_1CD6881A8((uint64_t *)v588 - 3);
        v588 = v590;
      }
      while (v590 != v587);
      v589 = v683;
    }
    v684 = v587;
    operator delete(v589);
  }
  MEMORY[0x1D25D9CD0](v681, 8);
  if (v677 != v676) {
    free(v677);
  }
  MEMORY[0x1D25D9CD0](v674, 8);
  if (v670 != v669) {
    free(v670);
  }
  MEMORY[0x1D25D9CD0](v667, 8);
  MEMORY[0x1D25D9CD0](v665, 8);
  if (v661 != v660) {
    free(v661);
  }
  if (v657 != v659) {
    free(v657);
  }
  if ((v648 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v649, 8);
  }
  if (v645 != v647) {
    free(v645);
  }
  if ((v642 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v643, 8);
  }
  sub_1CBF74588(v638);
  MEMORY[0x1D25D9CD0](v635, 8);
  return v612 & 1;
}

void sub_1CCD36A84(llvm *a1)
{
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializePostDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v2);
  llvm::initializeGlobalsAAWrapperPassPass(a1, v3);
  llvm::initializeMemorySSAWrapperPassPass(a1, v4);
  llvm::initializeMemoryDependenceWrapperPassPass(a1, v5);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  operator new();
}

uint64_t sub_1CCD36B64(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF0DF8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263D958;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)qword_1EBCF0E00, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD36A84;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(qword_1EBCF0E00, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

BOOL sub_1CCD36C14(uint64_t *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16) == 84)
  {
    uint64_t v4 = *(void *)(a2 - 32);
    if (v4)
    {
      if (!*(unsigned char *)(v4 + 16)
        && *(void *)(v4 + 24) == *(void *)(a2 + 72)
        && (*(unsigned char *)(v4 + 33) & 0x20) != 0
        && *(_DWORD *)(v4 + 36) == 167)
      {
        return 1;
      }
    }
  }
  char v10 = 0;
  uint64_t v6 = (uint64_t ***)sub_1CC0960E8(a2, &v10);
  uint64_t v7 = 0;
  if (v6 && !v10)
  {
    unsigned int v9 = 0;
    if (a1
      && (uint64_t v8 = (llvm::Function *)v6, llvm::TargetLibraryInfoImpl::getLibFunc(*a1, v6, &v9))
      && ((*(void *)(a1[1] + (((unint64_t)v9 >> 3) & 0x1FFFFFF8)) >> v9) & 1) == 0
      && ((*(unsigned __int8 *)(*a1 + ((unint64_t)v9 >> 2)) >> (2 * (v9 & 3))) & 3) != 0
      && llvm::isLibFreeFunction(v8, v9))
    {
      if (*(unsigned char *)(a2 + 16) == 84) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = 0;
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
  }
  return v7 != 0;
}

uint64_t sub_1CCD36D34(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  int v5 = *(unsigned __int8 *)(a3 + 16);
  if (!a3 || v5 != 84) {
    goto LABEL_3;
  }
  uint64_t v12 = *(void *)(a3 - 32);
  if (!v12 || *(unsigned char *)(v12 + 16) || *(void *)(v12 + 24) != *(void *)(a3 + 72) || *(_DWORD *)(v12 + 36) != 167) {
    goto LABEL_7;
  }
  uint64_t v13 = (void *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
  uint64_t v14 = *v13;
  if (!*v13 || *(unsigned char *)(*v13 + 16) != 16) {
    goto LABEL_7;
  }
  uint64_t v16 = (uint64_t *)(v14 + 24);
  uint64_t v17 = *(unsigned int *)(v14 + 32);
  if (v17 >= 0x41)
  {
    int v21 = 0;
    int64_t v22 = (unint64_t)(v17 + 63) >> 6;
    do
    {
      BOOL v7 = v22-- < 1;
      if (v7) {
        break;
      }
      unint64_t v23 = *(void *)(*v16 + 8 * v22);
      v21 += __clz(v23);
    }
    while (!v23);
    int v24 = v17 | 0xFFFFFFC0;
    if ((v17 & 0x3F) == 0) {
      int v24 = 0;
    }
    if ((v17 - v21 - v24) > 0x40)
    {
LABEL_3:
      unsigned int v6 = v5 - 33;
      BOOL v7 = v6 > 0x33;
      uint64_t v8 = (1 << v6) & 0x8000000000041;
      if (v7 || v8 == 0)
      {
LABEL_9:
        char v11 = 0;
        *(unsigned char *)uint64_t v4 = 0;
        goto LABEL_10;
      }
LABEL_7:
      char v10 = *(uint64_t **)(a2 + 760);
      char v26 = 0;
      uint64_t result = sub_1CC0960E8(a3, &v26);
      if (result)
      {
        if (!v26)
        {
          unsigned int v25 = 0;
          if (v10)
          {
            uint64_t v20 = (llvm::Function *)result;
            uint64_t result = llvm::TargetLibraryInfoImpl::getLibFunc(*v10, (uint64_t ***)result, &v25);
            if (result)
            {
              if (((*(void *)(v10[1] + (((unint64_t)v25 >> 3) & 0x1FFFFFF8)) >> v25) & 1) == 0
                && ((*(unsigned __int8 *)(*v10 + ((unint64_t)v25 >> 2)) >> (2 * (v25 & 3))) & 3) != 0)
              {
                uint64_t result = llvm::isLibFreeFunction(v20, v25);
                if (result)
                {
                  if (*(unsigned char *)(a3 + 16) == 84)
                  {
                    *(void *)uint64_t v4 = *(void *)(a3 - 32 * (*(_DWORD *)(a3 + 20) & 0x7FFFFFF));
                    *(void *)(v4 + 8) = -2;
                    *(_OWORD *)(v4 + 16) = 0u;
                    *(_OWORD *)(v4 + 32) = 0u;
                    char v11 = 1;
                    *(unsigned char *)(v4 + 48) = 1;
                    goto LABEL_10;
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_9;
    }
    uint64_t v16 = (uint64_t *)*v16;
  }
  uint64_t v18 = v13[4];
  if (!v18) {
    goto LABEL_3;
  }
  uint64_t v19 = *v16;
  if ((unint64_t)*v16 > 0x7FFFFFFFFFFFFFFBLL) {
    uint64_t v19 = -2;
  }
  *(void *)uint64_t result = v18;
  *(void *)(result + 8) = v19;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(unsigned char *)(result + 48) = 0;
  char v11 = 1;
LABEL_10:
  *(unsigned char *)(v4 + 56) = v11;
  return result;
}

void sub_1CCD36F44(unsigned char *a1, uint64_t a2, llvm::Instruction *this)
{
  int v4 = *((unsigned __int8 *)this + 16);
  uint64_t v5 = (v4 - 33);
  if (v5 > 0x37) {
    goto LABEL_5;
  }
  if (((1 << (v4 - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v8 = *((void *)this + 8);
    if (v8 && (*(unsigned char *)(v8 + 17) & 0x30) != 0) {
      goto LABEL_5;
    }
    int v9 = *((_DWORD *)this + 5);
    if (v9 < 0
      && (uint64_t v12 = (char *)this - 32 * (v9 & 0x7FFFFFF), v15 = *((void *)v12 - 1), v13 = v12 - 8, (v14 = v15) != 0))
    {
      uint64_t v16 = -v14;
      while (1)
      {
        unsigned int v17 = *(_DWORD *)(*(void *)&v13[v16] + 8);
        BOOL v18 = v17 > 7;
        int v19 = (1 << v17) & 0x83;
        if (v18 || v19 == 0) {
          break;
        }
        v16 += 16;
        if (!v16) {
          goto LABEL_9;
        }
      }
    }
    else
    {
LABEL_9:
      if ((llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 45) & 1) != 0
        || (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 44) & 1) != 0)
      {
        goto LABEL_5;
      }
      int v4 = *((unsigned __int8 *)this + 16);
    }
  }
  else
  {
    if (v5 == 27)
    {
      if ((*((_WORD *)this + 9) & 0x301) == 0) {
        goto LABEL_5;
      }
      goto LABEL_18;
    }
    if (((1 << (v4 - 33)) & 0x808001D0000010) == 0)
    {
LABEL_5:
      *a1 = 0;
      a1[48] = 0;
      return;
    }
  }
  unsigned int v10 = v4 - 33;
  if (v10 <= 0x33 && ((1 << v10) & 0x8000000000041) != 0)
  {
    char v11 = *(uint64_t **)(a2 + 760);
    llvm::MemoryLocation::getForDest(this, v11, (uint64_t)a1);
    return;
  }
LABEL_18:

  llvm::MemoryLocation::getOrNone((uint64_t ***)this, (uint64_t)a1);
}

void sub_1CCD370D8(uint64_t a1, uint64_t *a2)
{
  BOOL v18 = 0;
  if (sub_1CCD386D4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v18)) {
    return;
  }
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 8);
  if (4 * v5 + 4 >= 3 * v4)
  {
    v4 *= 2;
    goto LABEL_26;
  }
  if (v4 + ~v5 - *(_DWORD *)(a1 + 12) <= v4 >> 3)
  {
LABEL_26:
    sub_1CCD38768(a1, v4);
    BOOL v18 = 0;
    sub_1CCD386D4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v18);
  }
  unsigned int v6 = v18;
  ++*(_DWORD *)(a1 + 8);
  if (*v6 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *unsigned int v6 = *a2;
  uint64_t v8 = *(uint64_t **)(a1 + 32);
  unint64_t v7 = *(void *)(a1 + 40);
  if ((unint64_t)v8 >= v7)
  {
    unsigned int v10 = *(void **)(a1 + 24);
    uint64_t v11 = v8 - v10;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      abort();
    }
    uint64_t v13 = v7 - (void)v10;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 61) {
        sub_1CB833614();
      }
      uint64_t v15 = (char *)operator new(8 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    uint64_t v16 = (uint64_t *)&v15[8 * v11];
    *uint64_t v16 = *a2;
    int v9 = v16 + 1;
    if (v8 != v10)
    {
      do
      {
        uint64_t v17 = *--v8;
        *--uint64_t v16 = v17;
      }
      while (v8 != v10);
      uint64_t v8 = *(uint64_t **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v16;
    *(void *)(a1 + 32) = v9;
    *(void *)(a1 + 40) = &v15[8 * v14];
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    uint64_t *v8 = *a2;
    int v9 = v8 + 1;
  }
  *(void *)(a1 + 32) = v9;
}

void sub_1CCD37280(uint64_t a1, uint64_t a2)
{
  v62[27] = *MEMORY[0x1E4F143B8];
  v49[0] = *(int32x2_t **)(a1 + 736);
  v49[1] = (int32x2_t *)v50;
  v49[2] = (int32x2_t *)0x1000000000;
  v50[48] = v52;
  v50[49] = v52;
  v50[50] = 8;
  int v51 = 0;
  int v53 = v55;
  uint64_t v54 = 0x800000000;
  v56[1] = 0;
  v56[0] = 0;
  v55[8] = v56;
  v48[0] = a2;
  uint64_t v46 = (llvm::SmallPtrSetImplBase *)(a1 + 1320);
  uint64_t v3 = (uint64_t *)(a1 + 1904);
  unsigned int v4 = (llvm::EarliestEscapeInfo *)(a1 + 16);
  unsigned int v47 = 0;
  int v57 = v59;
  uint64_t v58 = 0x100000000;
  llvm::findDbgUsers((uint64_t)&v57, (uint64_t ***)a2);
  llvm::salvageDebugInfoForDbgValues((llvm::CastInst *)a2, (uint64_t *)v57, v58);
  if (v57 != v59) {
    free(v57);
  }
  if (byte_1EBD0C1D8 && *(unsigned __int8 *)(a2 + 16) - 29 >= 0xB)
  {
    int v57 = *(void **)(*(void *)(*(void *)(a2 + 40) + 56) + 40);
    uint64_t v58 = 1;
    for (uint64_t i = 16; i != 208; i += 24)
      *(_OWORD *)((char *)&v57 + i) = xmmword_1CFAC3080;
    uint64_t v60 = v62;
    uint64_t v61 = 0x800000000;
    v62[24] = a2;
    v62[25] = 0;
    v62[26] = 0;
    sub_1CD11CA2C((uint64_t)&v57, a2, v6, v7, v8, v9, v10);
    uint64_t v45 = (llvm::Instruction *)sub_1CD11CB94((uint64_t ***)&v57);
    if (v45) {
      llvm::Instruction::insertBefore(v45, (llvm::Instruction *)a2);
    }
    if (v60 != v62) {
      free(v60);
    }
    if ((v58 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v59[0], 8);
    }
  }
  uint64_t v11 = *(void *)(a1 + 736);
  int v12 = *(_DWORD *)(v11 + 40);
  if (!v12) {
    goto LABEL_44;
  }
  uint64_t v13 = *(void *)(v11 + 24);
  unsigned int v14 = v12 - 1;
  uint64_t v15 = (v12 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v16 = *(void *)(v13 + 16 * v15);
  if (a2 != v16)
  {
    int v17 = 1;
    while (v16 != -4096)
    {
      int v18 = v15 + v17++;
      uint64_t v15 = v18 & v14;
      uint64_t v16 = *(void *)(v13 + 16 * v15);
      if (a2 == v16) {
        goto LABEL_9;
      }
    }
LABEL_44:
    uint64_t v35 = sub_1CCD381A4(v3, *(void *)(a2 + 40));
    if (*(void *)(a1 + 1936) != v35) {
      sub_1CD761B58(v35 + 8, a2);
    }
    int v36 = *(_DWORD *)(a2 + 20);
    if ((v36 & 0x40000000) != 0)
    {
      uint64_t v38 = *(void *)(a2 - 8);
      uint64_t v37 = v36 & 0x7FFFFFF;
      if (!v37) {
        goto LABEL_65;
      }
    }
    else
    {
      uint64_t v37 = v36 & 0x7FFFFFF;
      uint64_t v38 = a2 - 32 * v37;
      if (!v37) {
        goto LABEL_65;
      }
    }
    uint64_t v39 = 32 * v37;
    int v40 = (void **)(v38 + 16);
    do
    {
      uint64_t v41 = (uint64_t)*(v40 - 2);
      if (v41) {
        BOOL v42 = *(unsigned __int8 *)(v41 + 16) >= 0x1Cu;
      }
      else {
        BOOL v42 = 0;
      }
      if (v42)
      {
        *llvm::Instruction *v40 = *(v40 - 1);
        uint64_t v43 = (uint64_t)*(v40 - 1);
        if (v43) {
          *(void *)(v43 + 16) = *v40;
        }
        *(v40 - 2) = 0;
        if (!*(void *)(v41 + 8) && llvm::wouldInstructionBeTriviallyDead(v41, *(uint64_t **)(a1 + 760)))
        {
          if (v47 >= 0x20uLL) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v48[v47++] = v41;
        }
      }
      v40 += 4;
      v39 -= 32;
    }
    while (v39);
LABEL_65:
    llvm::EarliestEscapeInfo::removeInstruction(v4, (llvm::Instruction *)a2);
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
LABEL_9:
  int v19 = *(llvm::MemoryAccess **)(v13 + 16 * v15 + 8);
  if (!v19) {
    goto LABEL_44;
  }
  if (*((unsigned char *)v19 + 16) != 26)
  {
LABEL_43:
    llvm::MemorySSAUpdater::removeMemoryAccess(v49, v19, 0);
    goto LABEL_44;
  }
  uint64_t v20 = *(void *)(a1 + 1328);
  uint64_t v21 = *(unsigned int *)(a1 + 1340);
  if (v20 == *(void *)(a1 + 1320))
  {
    if (v21)
    {
      int64_t v22 = 0;
      uint64_t v23 = 8 * v21;
      int v24 = *(llvm::MemoryAccess ***)(a1 + 1328);
      do
      {
        if (*v24 == v19) {
          goto LABEL_43;
        }
        if (*v24 == (llvm::MemoryAccess *)-2) {
          int64_t v22 = v24;
        }
        ++v24;
        v23 -= 8;
      }
      while (v23);
      if (v22)
      {
        char *v22 = v19;
        --*(_DWORD *)(a1 + 1344);
        goto LABEL_43;
      }
    }
    unsigned int v25 = *(_DWORD *)(a1 + 1336);
    if (v21 < v25)
    {
      *(_DWORD *)(a1 + 1340) = v21 + 1;
      *(void *)(v20 + 8 * v21) = v19;
      goto LABEL_43;
    }
  }
  else
  {
    unsigned int v25 = *(_DWORD *)(a1 + 1336);
  }
  if (3 * v25 <= 4 * ((int)v21 - *(_DWORD *)(a1 + 1344)))
  {
    if (v25 >= 0x40) {
      v25 *= 2;
    }
    else {
      unsigned int v25 = 128;
    }
  }
  else if (v25 - v21 >= v25 >> 3)
  {
    goto LABEL_24;
  }
  llvm::SmallPtrSetImplBase::Grow(v46, v25);
  unsigned int v25 = *(_DWORD *)(a1 + 1336);
  uint64_t v20 = *(void *)(a1 + 1328);
LABEL_24:
  unsigned int v26 = v25 - 1;
  unsigned int v27 = (v25 - 1) & ((v19 >> 4) ^ (v19 >> 9));
  unsigned int v28 = (llvm::MemoryAccess **)(v20 + 8 * v27);
  unsigned int v29 = *v28;
  if (*v28 == (llvm::MemoryAccess *)-1)
  {
    uint64_t v30 = 0;
LABEL_36:
    if (v30) {
      BOOL v34 = v30;
    }
    else {
      BOOL v34 = v28;
    }
    if (*v34 != v19)
    {
      if (*v34 == (llvm::MemoryAccess *)-2) {
        --*(_DWORD *)(a1 + 1344);
      }
      else {
        ++*(_DWORD *)(a1 + 1340);
      }
      *BOOL v34 = v19;
    }
  }
  else
  {
    uint64_t v30 = 0;
    int v31 = 1;
    while (v29 != v19)
    {
      if (v30) {
        BOOL v32 = 0;
      }
      else {
        BOOL v32 = v29 == (llvm::MemoryAccess *)-2;
      }
      if (v32) {
        uint64_t v30 = v28;
      }
      unsigned int v33 = v27 + v31++;
      unsigned int v27 = v33 & v26;
      unsigned int v28 = (llvm::MemoryAccess **)(v20 + 8 * (v33 & v26));
      unsigned int v29 = *v28;
      if (*v28 == (llvm::MemoryAccess *)-1) {
        goto LABEL_36;
      }
    }
  }
  goto LABEL_43;
}

uint64_t sub_1CCD3782C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  if (!sub_1CCD38C68(a1, *(void *)(a3 + 40), *(void *)(a2 + 40), *(llvm::Value **)a5)) {
    return 6;
  }
  unint64_t v14 = *(void *)(a4 + 8);
  unsigned int v15 = *(unsigned __int8 *)(a2 + 16) - 33;
  BOOL v16 = v15 > 0x33;
  uint64_t v17 = (1 << v15) & 0x8000000000041;
  if (!v16 && v17 != 0)
  {
    LODWORD(v109) = 0;
    if (sub_1CC0A4DF4(*(uint64_t **)(a1 + 760), a2, &v109))
    {
      int v19 = *(void **)(a1 + 760);
      if (((*(void *)(v19[1] + (((unint64_t)v109 >> 3) & 0x1FFFFFF8)) >> v109) & 1) == 0
        && ((*(unsigned __int8 *)(*v19 + ((unint64_t)v109 >> 2)) >> (2 * (v109 & 3))) & 3) != 0
        && (v109 == 106 || v109 == 103))
      {
        uint64_t v53 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 64);
        if (v53 && *(unsigned char *)(v53 + 16) == 16)
        {
          int v55 = (unint64_t *)(v53 + 24);
          if (*(_DWORD *)(v53 + 32) >= 0x41u) {
            int v55 = (unint64_t *)*v55;
          }
          unint64_t v56 = *v55;
          if (v56 <= 0x7FFFFFFFFFFFFFFBLL) {
            unint64_t v14 = v56;
          }
          else {
            unint64_t v14 = -2;
          }
        }
      }
    }
  }
  uint64_t v20 = llvm::Value::stripPointerCasts(*(llvm::Value **)a5);
  uint64_t v21 = llvm::Value::stripPointerCasts(*(llvm::Value **)a4);
  int v105 = v20;
  UnderlyingObject = llvm::getUnderlyingObject(v20, (const llvm::Value *)6);
  char v104 = v21;
  int v24 = llvm::getUnderlyingObject(v21, (const llvm::Value *)6);
  if (UnderlyingObject != v24 || (v14 & 0x8000000000000000) != 0)
  {
    if ((v14 & 0x8000000000000000) != 0) {
      goto LABEL_45;
    }
  }
  else
  {
    uint64_t v25 = *(void *)(a1 + 768);
    uint64_t v26 = *(void *)(a1 + 760);
    uint64_t v27 = *(void *)a1;
    uint64_t v109 = 0;
    if (v27 && (uint64_t v28 = *(void *)(v27 + 112)) != 0)
    {
      if (*(unsigned char *)(v28 + 17)) {
        uint64_t v29 = 0x10000;
      }
      else {
        uint64_t v29 = 0;
      }
    }
    else
    {
      uint64_t v29 = 0;
    }
    BOOL ObjectSize = llvm::getObjectSize(UnderlyingObject, &v109, v25, v26, v29, 0, v23);
    uint64_t v31 = v109;
    if (!ObjectSize) {
      uint64_t v31 = -1;
    }
    if (v31 != -1 && v31 == v14) {
      return 1;
    }
  }
  if ((*(void *)(a5 + 8) & 0x8000000000000000) != 0)
  {
LABEL_45:
    if (sub_1CBFB3AB0(a2)) {
      uint64_t v44 = a2;
    }
    else {
      uint64_t v44 = 0;
    }
    if (sub_1CBFB3AB0(a3)) {
      uint64_t v45 = a3;
    }
    else {
      uint64_t v45 = 0;
    }
    if (v44
      && v45
      && *(void *)(v44 - 32 * (*(_DWORD *)(v44 + 20) & 0x7FFFFFF) + 64) == *(void *)(v45
                                                                                         - 32
                                                                                         * (*(_DWORD *)(v45 + 20) & 0x7FFFFFF)
                                                                                         + 64))
    {
      uint64_t v46 = *(void *)(a1 + 96);
      int v47 = *(_DWORD *)(a1 + 440);
      *(_DWORD *)(a1 + 440) = v47 + 1;
      uint64_t v48 = *(void *)(v46 + 8);
      uint64_t v49 = *(void *)(v46 + 16);
      if (v48 == v49)
      {
        *(_DWORD *)(a1 + 440) = v47;
      }
      else
      {
        uint64_t v50 = v48 + 8;
        do
        {
          int v51 = (*(unsigned __int8 (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v50 - 8) + 24))(*(void *)(v50 - 8), a5, a4, a1 + 104);
          BOOL v52 = v51 != 1 || v50 == v49;
          v50 += 8;
        }
        while (!v52);
        --*(_DWORD *)(a1 + 440);
        if (v51 == 3) {
          return 1;
        }
      }
    }
    if (*(unsigned char *)(a2 + 16) == 84
      && (uint64_t v81 = *(void *)(a2 - 32)) != 0
      && !*(unsigned char *)(v81 + 16)
      && *(void *)(v81 + 24) == *(void *)(a2 + 72))
    {
      if ((*(unsigned char *)(v81 + 33) & 0x20) != 0) {
        uint64_t v82 = a2;
      }
      else {
        uint64_t v82 = 0;
      }
    }
    else
    {
      uint64_t v82 = 0;
    }
    if (*(unsigned char *)(a3 + 16) != 84) {
      return 6;
    }
    uint64_t v83 = *(void *)(a3 - 32);
    if (!v83 || *(unsigned char *)(v83 + 16) || *(void *)(v83 + 24) != *(void *)(a3 + 72)) {
      return 6;
    }
    if ((*(unsigned char *)(v83 + 33) & 0x20) != 0) {
      uint64_t v84 = a3;
    }
    else {
      uint64_t v84 = 0;
    }
    uint64_t result = 6;
    if (v82
      && v84
      && *(_DWORD *)(*(void *)(v82 - 32) + 36) == 187
      && *(_DWORD *)(*(void *)(v84 - 32) + 36) == 187)
    {
      uint64_t v85 = v82 - 32 * (*(_DWORD *)(v82 + 20) & 0x7FFFFFF);
      uint64_t v86 = **(void **)v85;
      uint64_t v87 = **(void **)(v84 - 32 * (*(_DWORD *)(v84 + 20) & 0x7FFFFFF));
      int v88 = *(_DWORD *)(v86 + 8);
      uint64_t v89 = (llvm::Type *)v86;
      if ((v88 & 0xFE) == 0x12) {
        uint64_t v89 = **(llvm::Type ***)(v86 + 16);
      }
      int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v89);
      int v91 = *(_DWORD *)(v87 + 8);
      int v92 = (llvm::Type *)v87;
      if ((v91 & 0xFE) == 0x12) {
        int v92 = **(llvm::Type ***)(v87 + 16);
      }
      if (PrimitiveSizeInBits != llvm::Type::getPrimitiveSizeInBits(v92)) {
        return 6;
      }
      uint64_t result = 6;
      if ((v88 == 19) == (v91 == 19)
        && *(_DWORD *)(v86 + 32) == *(_DWORD *)(v87 + 32))
      {
        uint64_t v93 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v85 + 32));
        int v94 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v84 - 32 * (*(_DWORD *)(v84 + 20) & 0x7FFFFFF) + 32));
        if (v93 != v94)
        {
          uint64_t v109 = (uint64_t)v93;
          uint64_t v110 = 1;
          long long v111 = 0u;
          long long v112 = 0u;
          v106[0] = v94;
          v106[1] = 1;
          long long v107 = 0u;
          long long v108 = 0u;
          uint64_t v95 = *(void *)(a1 + 96);
          int v96 = *(_DWORD *)(a1 + 440);
          *(_DWORD *)(a1 + 440) = v96 + 1;
          uint64_t v97 = *(void *)(v95 + 8);
          uint64_t v98 = *(void *)(v95 + 16);
          if (v97 == v98)
          {
            *(_DWORD *)(a1 + 440) = v96;
            return 6;
          }
          uint64_t v99 = v97 + 8;
          do
          {
            int v100 = (*(unsigned __int8 (**)(void, uint64_t *, void *, uint64_t))(**(void **)(v99 - 8)
                                                                                           + 24))(*(void *)(v99 - 8), &v109, v106, a1 + 104);
            BOOL v101 = v100 != 1 || v99 == v98;
            v99 += 8;
          }
          while (!v101);
          --*(_DWORD *)(a1 + 440);
          if (v100 != 3) {
            return 6;
          }
        }
        if (*(void *)(v82 - 32 * (*(_DWORD *)(v82 + 20) & 0x7FFFFFF) + 96) == *(void *)(v84
                                                                                             - 32
                                                                                             * (*(_DWORD *)(v84 + 20) & 0x7FFFFFF)
                                                                                             + 96))
          return 1;
        else {
          return 6;
        }
      }
    }
    return result;
  }
  unint64_t v103 = *(void *)(a5 + 8);
  uint64_t v33 = *(void *)(a1 + 96);
  int v34 = *(_DWORD *)(a1 + 440);
  *(_DWORD *)(a1 + 440) = v34 + 1;
  uint64_t v35 = *(void *)(v33 + 8);
  uint64_t v36 = *(void *)(v33 + 16);
  if (v35 == v36)
  {
    *(_DWORD *)(a1 + 440) = v34;
    LODWORD(result) = 1;
LABEL_41:
    if (UnderlyingObject != v24)
    {
      if (result) {
        return 6;
      }
      else {
        return 5;
      }
    }
    *a7 = 0;
    *a6 = 0;
    uint64_t v57 = *(void *)(a1 + 768);
    unsigned int v58 = *(_DWORD *)(*(void *)v105 + 8);
    if ((v58 & 0xFE) == 0x12) {
      unsigned int v58 = *(_DWORD *)(**(void **)(*(void *)v105 + 16) + 8);
    }
    if (v58 < 0x100) {
      goto LABEL_90;
    }
    unsigned int v59 = v58 >> 8;
    uint64_t v60 = *(unsigned int *)(v57 + 240);
    uint64_t v61 = *(void *)(v57 + 232);
    if (v60)
    {
      uint64_t v61 = *(void *)(v57 + 232);
      unint64_t v62 = *(unsigned int *)(v57 + 240);
      do
      {
        unint64_t v63 = v62 >> 1;
        uint64_t v64 = v61 + 16 * (v62 >> 1);
        unsigned int v65 = *(_DWORD *)(v64 + 8);
        uint64_t v66 = v64 + 16;
        v62 += ~(v62 >> 1);
        if (v65 < v59) {
          uint64_t v61 = v66;
        }
        else {
          unint64_t v62 = v63;
        }
      }
      while (v62);
    }
    if (v61 == *(void *)(v57 + 232) + 16 * v60 || *(_DWORD *)(v61 + 8) != v59) {
LABEL_90:
    }
      uint64_t v61 = *(void *)(v57 + 232);
    LODWORD(v110) = *(_DWORD *)(v61 + 12);
    if (v110 > 0x40) {
      operator new[]();
    }
    uint64_t v109 = 0;
    uint64_t v68 = llvm::Value::stripAndAccumulateConstantOffsets(v105, (llvm::DataLayout *)v57, (llvm::APInt *)&v109, 1, 0, 0, v23);
    if (v110 > 0x40)
    {
      *a7 = *(void *)v109;
      MEMORY[0x1D25D9CB0]();
    }
    else
    {
      *a7 = v109 << -(uint64_t)v110 >> -(uint64_t)v110;
    }
    uint64_t v69 = *(void *)(a1 + 768);
    unsigned int v70 = *(_DWORD *)(*(void *)v104 + 8);
    if ((v70 & 0xFE) == 0x12) {
      unsigned int v70 = *(_DWORD *)(**(void **)(*(void *)v104 + 16) + 8);
    }
    if (v70 < 0x100) {
      goto LABEL_105;
    }
    unsigned int v71 = v70 >> 8;
    uint64_t v72 = *(unsigned int *)(v69 + 240);
    uint64_t v73 = *(void *)(v69 + 232);
    if (v72)
    {
      uint64_t v73 = *(void *)(v69 + 232);
      unint64_t v74 = *(unsigned int *)(v69 + 240);
      do
      {
        unint64_t v75 = v74 >> 1;
        uint64_t v76 = v73 + 16 * (v74 >> 1);
        unsigned int v77 = *(_DWORD *)(v76 + 8);
        uint64_t v78 = v76 + 16;
        v74 += ~(v74 >> 1);
        if (v77 < v71) {
          uint64_t v73 = v78;
        }
        else {
          unint64_t v74 = v75;
        }
      }
      while (v74);
    }
    if (v73 == *(void *)(v69 + 232) + 16 * v72 || *(_DWORD *)(v73 + 8) != v71) {
LABEL_105:
    }
      uint64_t v73 = *(void *)(v69 + 232);
    LODWORD(v110) = *(_DWORD *)(v73 + 12);
    if (v110 > 0x40) {
      operator new[]();
    }
    uint64_t v109 = 0;
    uint64_t v79 = llvm::Value::stripAndAccumulateConstantOffsets(v104, (llvm::DataLayout *)v69, (llvm::APInt *)&v109, 1, 0, 0, v67);
    if (v110 > 0x40)
    {
      *a6 = *(void *)v109;
      MEMORY[0x1D25D9CB0]();
    }
    else
    {
      *a6 = v109 << -(uint64_t)v110 >> -(uint64_t)v110;
    }
    if (v68 == v79)
    {
      unint64_t v80 = *a7 - *a6;
      if (*a7 < *a6)
      {
        if (*a6 - *a7 < v103) {
          return 4;
        }
        return 5;
      }
      if (v80 + v103 > v14)
      {
        if (v80 < v14) {
          return 4;
        }
        return 5;
      }
      return 1;
    }
    return 6;
  }
  int v102 = a7;
  uint64_t v37 = a6;
  uint64_t v38 = v35 + 8;
  do
  {
    int v39 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v38 - 8) + 24))(*(void *)(v38 - 8), a4, a5, a1 + 104);
    LODWORD(result) = v39;
    BOOL v41 = v39 != 1 || v38 == v36;
    v38 += 8;
  }
  while (!v41);
  --*(_DWORD *)(a1 + 440);
  if (v39 == 3 && v14 >= v103) {
    return 1;
  }
  a6 = v37;
  BOOL v43 = v39 != 2 || (v39 & 0x100) == 0;
  a7 = v102;
  if (v43) {
    goto LABEL_41;
  }
  uint64_t result = 1;
  if (v39 < 0 || v103 + (v39 >> 9) > v14) {
    goto LABEL_41;
  }
  return result;
}

uint64_t sub_1CCD381A4(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    int v5 = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_3;
    }
    int v8 = 1;
    while (v6 != -4096)
    {
      int v9 = v4 + v8++;
      uint64_t v4 = v9 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        int v5 = (uint64_t *)(v2 + 16 * v4);
        goto LABEL_3;
      }
    }
  }
  int v5 = (uint64_t *)(v2 + 16 * v3);
LABEL_3:
  if (v5 == (uint64_t *)(v2 + 16 * v3)) {
    return a1[4];
  }
  else {
    return a1[3] + 32 * *((unsigned int *)v5 + 2);
  }
}

void sub_1CCD3822C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v15[24] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(*(void *)a1 + 80);
  if (v3) {
    uint64_t v4 = v3 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  sub_1CC82F3B8((llvm::SmallPtrSetImplBase *)&v12, v4);
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9[0] = 0;
  memset(v8, 0, sizeof(v8));
  int v5 = (char *)v8 + 8;
  uint64_t v6 = (char *)v8 + 8;
  uint64_t v7 = 8;
  v9[1] = (char *)v10 + 8;
  DWORD1(v10[0]) = 8;
  sub_1CC08CC00((uint64_t)&v12, (uint64_t)&v5, a2);
  if (v9[1] != (char *)v10 + 8) {
    free(v9[1]);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v14 != v15) {
    free(v14);
  }
  if (v13 != v12) {
    free(v13);
  }
}

uint64_t sub_1CCD38374@<X0>(uint64_t a1@<X0>, void *a2@<X1>, unsigned char *a3@<X2>, uint64_t a4@<X8>)
{
  int v12 = 0;
  uint64_t result = sub_1CCD38408((uint64_t *)a1, a2, &v12);
  int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CCD384A4(a1, (uint64_t)a2, a2, v12);
    int v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(unsigned char *)(result + 8) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CCD38408(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v7 = (void *)(*a1 + 16 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      char v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          char v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        uint64_t v7 = (void *)(v4 + 16 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v7 = v10;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

void *sub_1CCD384A4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_3:
    sub_1CCD38558(a1, v7);
    int v9 = 0;
    sub_1CCD38408((uint64_t *)a1, a3, &v9);
    a4 = v9;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CCD38558(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CCD38624(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CCD38624(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CCD38408((uint64_t *)v5, (void *)a2, &v10);
      int v9 = v10;
      *uint64_t v10 = *(void *)a2;
      *((unsigned char *)v9 + 8) = *(unsigned char *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CCD386D4(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 8 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v10 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v8 = v6;
        }
        unsigned int v13 = v5 + v9++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 8 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v10 = 1;
        if (*v6 == a3) {
          goto LABEL_7;
        }
      }
      uint64_t v10 = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v10 = 0;
  }
LABEL_7:
  *a4 = v6;
  return v10;
}

void *sub_1CCD38768(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD761BC8(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

BOOL sub_1CCD38834(uint64_t a1, llvm *this, BOOL *a3)
{
  char v10 = 0;
  int isNotVisibleOnUnwind = llvm::isNotVisibleOnUnwind(this, (const llvm::Value *)&v10, a3);
  BOOL result = 0;
  if (isNotVisibleOnUnwind)
  {
    BOOL result = 1;
    if (v10)
    {
      uint64_t v11 = this;
      LOBYTE(v12) = 1;
      sub_1CCD38374(a1 + 1384, &v11, &v12, (uint64_t)&v8);
      if (v9)
      {
        uint64_t v11 = (llvm *)&unk_1F2601EB8;
        uint64_t v12 = a1 + 1616;
        __int16 v13 = 0;
        llvm::PointerMayBeCaptured(this, (const llvm::Value *)&v11, 0);
        int v7 = HIBYTE(v13);
        *(unsigned char *)(v8 + 8) = HIBYTE(v13);
      }
      else
      {
        int v7 = *(unsigned __int8 *)(v8 + 8);
      }
      return v7 == 0;
    }
  }
  return result;
}

BOOL sub_1CCD38910(uint64_t a1, long long *a2, uint64_t a3)
{
  if (sub_1CCD38EE0(a3)) {
    return 0;
  }
  int v7 = *(unsigned __int8 *)(a3 + 16);
  if (a3 && v7 == 61) {
    return (((unint64_t)*(unsigned __int16 *)(a3 + 18) >> 7) & 7) - 3 < 5;
  }
  BOOL result = 0;
  uint64_t v8 = (v7 - 33);
  if (v8 <= 0x37)
  {
    if (((1 << (v7 - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v9 = *(void *)(a3 + 64);
      if (v9 && ((*(unsigned char *)(v9 + 20) & 4) != 0 || (*(unsigned char *)(v9 + 17) & 0x10) != 0)) {
        return 0;
      }
      LODWORD(v15[0]) = 7;
      if ((!sub_1CC5CB59C(a3, (__int32 *)v15, 1uLL)
         || (uint64_t v13 = *(void *)(a3 - 32)) != 0
         && !*(unsigned char *)(v13 + 16)
         && *(void *)(v13 + 24) == *(void *)(a3 + 72)
         && *(_DWORD *)(v13 + 36) == 7)
        && ((llvm::CallBase::hasFnAttrOnCalledFunction(a3, 66) & 1) != 0
         || (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) & 1) != 0))
      {
        return 0;
      }
    }
    else
    {
      if (((1 << (v7 - 33)) & 0x808001C8000010) != 0)
      {
LABEL_18:
        unsigned int v10 = v7 - 33;
        if (v10 <= 0x33 && ((1 << v10) & 0x8000000000041) != 0)
        {
          uint64_t v11 = *(void *)(a3 + 64);
          if (v11)
          {
            if ((*(unsigned char *)(v11 + 13) & 8) != 0) {
              return 0;
            }
          }
          LODWORD(v15[0]) = 7;
          if ((!sub_1CC5CB59C(a3, (__int32 *)v15, 1uLL)
             || (uint64_t v14 = *(void *)(a3 - 32)) != 0
             && !*(unsigned char *)(v14 + 16)
             && *(void *)(v14 + 24) == *(void *)(a3 + 72)
             && *(_DWORD *)(v14 + 36) == 7)
            && (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 11) & 1) != 0)
          {
            return 0;
          }
        }
        long long v12 = a2[1];
        v15[0] = *a2;
        v15[1] = v12;
        _OWORD v15[2] = a2[2];
        char v16 = 1;
        return llvm::AAResults::getModRefInfo(*(void *)(a1 + 96), (llvm::Instruction *)a3, v15, a1 + 104) & 1;
      }
      if (v8 != 28) {
        return result;
      }
      if ((*(_WORD *)(a3 + 18) & 0x301) == 0) {
        return 0;
      }
    }
    int v7 = *(unsigned __int8 *)(a3 + 16);
    goto LABEL_18;
  }
  return result;
}

uint64_t sub_1CCD38B34(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v2 == 61) {
    return (*(_WORD *)(a1 + 18) & 0x301) == 0;
  }
  unsigned int v5 = v2 - 33;
  BOOL v6 = v5 > 0x33;
  uint64_t v7 = (1 << v5) & 0x8000000000041;
  if (v6 || v7 == 0) {
    return 0;
  }
  if (sub_1CBFB3AB0(a1))
  {
    uint64_t v9 = *(void *)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF) + 96);
    uint64_t v10 = *(unsigned int *)(v9 + 32);
    if (v10 > 0x40)
    {
      int v11 = 0;
      int64_t v12 = (unint64_t)(v10 + 63) >> 6;
      do
      {
        BOOL v6 = v12-- < 1;
        if (v6) {
          break;
        }
        unint64_t v13 = *(void *)(*(void *)(v9 + 24) + 8 * v12);
        v11 += __clz(v13);
      }
      while (!v13);
      int v14 = v10 | 0xFFFFFFC0;
      if ((v10 & 0x3F) == 0) {
        int v14 = 0;
      }
      return v11 + v14 == v10;
    }
    else
    {
      return *(void *)(v9 + 24) == 0;
    }
  }
  if (llvm::Instruction::isLifetimeStartOrEnd((llvm::Instruction *)a1) || *(void *)(a1 + 8)) {
    return 0;
  }
  uint64_t result = llvm::Instruction::willReturn((llvm::Instruction *)a1);
  if (result)
  {
    uint64_t v15 = *(void *)(a1 + 64);
    if (v15)
    {
      if ((*(unsigned char *)(v15 + 16) & 0x20) != 0) {
        return *(unsigned __int8 *)(a1 + 16) - 40 < 0xFFFFFFF5;
      }
    }
    uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(a1, 37);
    if (result) {
      return *(unsigned __int8 *)(a1 + 16) - 40 < 0xFFFFFFF5;
    }
  }
  return result;
}

uint64_t sub_1CCD38C68(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Value *a4)
{
  if (a2 != a3)
  {
    int v4 = *(uint64_t **)(a1 + 776);
    int v5 = *((_DWORD *)v4 + 4);
    if (!v5) {
      return sub_1CCD38F54(a4);
    }
    uint64_t v6 = *v4;
    unsigned int v7 = v5 - 1;
    LODWORD(v8) = v7 & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v9 = (uint64_t *)(v6 + 16 * v8);
    uint64_t v10 = *v9;
    if (*v9 != a2)
    {
      int v11 = 1;
      while (v10 != -4096)
      {
        int v12 = v8 + v11++;
        uint64_t v8 = v12 & v7;
        uint64_t v10 = *(void *)(v6 + 16 * v8);
        if (v10 == a2)
        {
          if (!*(unsigned char *)(a1 + 784))
          {
            uint64_t v13 = *(void *)(v6 + 16 * v8 + 8);
            if (v13) {
              goto LABEL_12;
            }
          }
          return sub_1CCD38F54(a4);
        }
      }
      return sub_1CCD38F54(a4);
    }
    if (*(unsigned char *)(a1 + 784)) {
      return sub_1CCD38F54(a4);
    }
    uint64_t v13 = v9[1];
    if (!v13) {
      return sub_1CCD38F54(a4);
    }
LABEL_12:
    uint64_t v14 = v7 & ((a3 >> 4) ^ (a3 >> 9));
    uint64_t v15 = *(void *)(v6 + 16 * v14);
    if (v15 == a3)
    {
LABEL_16:
      uint64_t v18 = *(void *)(v6 + 16 * v14 + 8);
    }
    else
    {
      int v16 = 1;
      while (v15 != -4096)
      {
        int v17 = v14 + v16++;
        uint64_t v14 = v17 & v7;
        uint64_t v15 = *(void *)(v6 + 16 * v14);
        if (v15 == a3) {
          goto LABEL_16;
        }
      }
      uint64_t v18 = 0;
    }
    if (v13 != v18) {
      return sub_1CCD38F54(a4);
    }
  }
  return 1;
}

BOOL sub_1CCD38D5C(uint64_t a1, llvm **a2, uint64_t a3, uint64_t a4)
{
  sub_1CCD36D34((uint64_t)v19, a1, a4);
  if (!v23) {
    return 0;
  }
  UnderlyingObject = llvm::getUnderlyingObject(*a2, (const llvm::Value *)6);
  if (UnderlyingObject != llvm::getUnderlyingObject(v19[0], (const llvm::Value *)6)) {
    return 0;
  }
  v18[0] = *(_OWORD *)v19;
  v18[1] = v20;
  v18[2] = v21;
  if (v22)
  {
    uint64_t v10 = llvm::getUnderlyingObject(*a2, (const llvm::Value *)6);
    v27[0] = *(void *)&v18[0];
    v27[1] = 1;
    long long v28 = 0u;
    long long v29 = 0u;
    v24[0] = (uint64_t)v10;
    v24[1] = 1;
    long long v25 = 0u;
    long long v26 = 0u;
    uint64_t v11 = *(void *)(a1 + 96);
    int v12 = *(_DWORD *)(a1 + 440);
    *(_DWORD *)(a1 + 440) = v12 + 1;
    uint64_t v13 = *(void *)(v11 + 8);
    uint64_t v14 = *(void *)(v11 + 16);
    if (v13 == v14)
    {
      BOOL result = 0;
    }
    else
    {
      uint64_t v15 = v13 + 8;
      do
      {
        int v16 = (*(unsigned __int8 (**)(void, uint64_t *, uint64_t *, uint64_t))(**(void **)(v15 - 8) + 24))(*(void *)(v15 - 8), v27, v24, a1 + 104);
        BOOL v17 = v16 != 1 || v15 == v14;
        v15 += 8;
      }
      while (!v17);
      int v12 = *(_DWORD *)(a1 + 440) - 1;
      BOOL result = v16 == 3;
    }
    *(_DWORD *)(a1 + 440) = v12;
  }
  else
  {
    v27[0] = 0;
    v24[0] = 0;
    return sub_1CCD3782C(a1, a4, a3, (uint64_t)v18, (uint64_t)a2, v27, v24) == 1;
  }
  return result;
}

uint64_t sub_1CCD38EE0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) != 84) {
    goto LABEL_6;
  }
  uint64_t v2 = *(void *)(a1 - 32);
  if (v2)
  {
    LODWORD(v1) = *(unsigned __int8 *)(v2 + 16);
    if (*(unsigned char *)(v2 + 16)
      || (uint64_t v1 = *(void *)(v2 + 24), v1 != *(void *)(a1 + 72))
      || (LODWORD(v1) = *(unsigned __int8 *)(v2 + 33), (v1 & 0x20) == 0))
    {
LABEL_6:
      LODWORD(v2) = 0;
      return v2 & v1;
    }
    int v4 = *(_DWORD *)(v2 + 36);
    LODWORD(v2) = 1;
    BOOL v6 = (v4 - 163) <= 5 && ((1 << (v4 + 93)) & 0x39) != 0 || v4 == 7;
    LODWORD(v1) = v6;
  }
  return v2 & v1;
}

BOOL sub_1CCD38F54(llvm::Value *a1)
{
  uint64_t v1 = llvm::Value::stripPointerCasts(a1);
  unsigned int v2 = *((unsigned __int8 *)v1 + 16);
  if (v2 == 62)
  {
LABEL_4:
    int v3 = *((_DWORD *)v1 + 5);
    if ((v3 & 0x40000000) != 0)
    {
      int v5 = (char *)*((void *)v1 - 1);
      uint64_t v4 = v3 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v4 = v3 & 0x7FFFFFF;
      int v5 = (char *)v1 - 32 * v4;
    }
    BOOL v6 = (uint64_t *)(v5 + 32);
    uint64_t v7 = 32 * v4 - 32;
    while (v7)
    {
      uint64_t v8 = *v6;
      v6 += 4;
      v7 -= 32;
      if (*(unsigned char *)(v8 + 16) != 16) {
        goto LABEL_16;
      }
    }
    if ((v3 & 0x40000000) != 0) {
      uint64_t v9 = (llvm::Value **)*((void *)v1 - 1);
    }
    else {
      uint64_t v9 = (llvm::Value **)((char *)v1 - 32 * v4);
    }
    uint64_t v1 = llvm::Value::stripPointerCasts(*v9);
    unsigned int v2 = *((unsigned __int8 *)v1 + 16);
    goto LABEL_16;
  }
  if (v2 == 5)
  {
    if (*((_WORD *)v1 + 9) != 34) {
      return 1;
    }
    goto LABEL_4;
  }
LABEL_16:
  uint64_t v10 = 1;
  if (v2 >= 0x1C && v1)
  {
    uint64_t v11 = *((void *)v1 + 5);
    uint64_t v12 = *(void *)(*(void *)(v11 + 56) + 80);
    if (v12) {
      uint64_t v13 = v12 - 24;
    }
    else {
      uint64_t v13 = 0;
    }
    return v13 == v11;
  }
  return v10;
}

BOOL sub_1CCD39028(uint64_t a1, unsigned char *a2)
{
  if (a2[16] == 59) {
    return 1;
  }
  uint64_t v10 = a2;
  LOBYTE(v11) = 0;
  sub_1CCD38374(a1 + 1408, &v10, &v11, (uint64_t)&v8);
  if (v9)
  {
    if (sub_1CCD38834(a1, (llvm *)a2, v5))
    {
      unsigned int v6 = a2[16];
      if (v6 >= 0x1C)
      {
        unsigned int v7 = v6 - 33;
        if (v7 <= 0x33 && ((1 << v7) & 0x8000000000041) != 0)
        {
          if (sub_1CBF5BCC4((uint64_t)a2, 19))
          {
            uint64_t v10 = &unk_1F2601EB8;
            uint64_t v11 = a1 + 1616;
            __int16 v12 = 1;
            llvm::PointerMayBeCaptured((llvm *)a2, (const llvm::Value *)&v10, 0);
            *(unsigned char *)(v8 + 8) = HIBYTE(v12) ^ 1;
          }
        }
      }
    }
    else
    {
      *(unsigned char *)(v8 + 8) = 0;
    }
  }
  return *(unsigned char *)(v8 + 8) != 0;
}

uint64_t sub_1CCD39148(uint64_t a1, uint64_t *a2)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CCD39268(a1, *a2, &v10);
  if (result) {
    return result;
  }
  int v5 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v6 = 32;
  }
  else {
    unsigned int v6 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_13;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 4) <= v6 >> 3)
  {
LABEL_13:
    sub_1CCD3930C(a1, v6);
    uint64_t v10 = 0;
    uint64_t result = sub_1CCD39268(a1, *a2, &v10);
  }
  unsigned int v7 = v10;
  *(_DWORD *)a1 += 2;
  if (*v7 != -4096) {
    --*(_DWORD *)(a1 + 4);
  }
  *unsigned int v7 = *a2;
  uint64_t v8 = *a2;
  unsigned int v9 = *(_DWORD *)(a1 + 272);
  if (v9 >= *(_DWORD *)(a1 + 276)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 264) + 8 * v9) = v8;
  ++*(_DWORD *)(a1 + 272);
  return result;
}

uint64_t sub_1CCD39268(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 32;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unsigned int v7 = 0;
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unsigned int v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
LABEL_13:
    uint64_t result = 1;
  }
  else
  {
    unsigned int v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v8 == -8192;
      }
      if (v11) {
        unsigned int v9 = v7;
      }
      unsigned int v12 = v6 + v10++;
      unsigned int v6 = v12 & v5;
      unsigned int v7 = (void *)(v3 + 8 * (v12 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_13;
      }
    }
    uint64_t result = 0;
    if (v9) {
      unsigned int v7 = v9;
    }
  }
LABEL_16:
  *a3 = v7;
  return result;
}

uint64_t sub_1CCD3930C(uint64_t a1, unsigned int a2)
{
  v14[32] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x21)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 <= 0x20)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      uint64_t v8 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v8;
    }
    sub_1CCD39494(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  unsigned int v9 = v14;
  for (uint64_t i = 8; i != 264; i += 8)
  {
    uint64_t v11 = *(void *)(a1 + i);
    if ((v11 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v9++ = v11;
    }
  }
  if (a2 > 0x20)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
  return sub_1CCD39494(a1, v14, v9);
}

uint64_t sub_1CCD39494(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    unsigned int v9 = (void *)(result + 264);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    unsigned int v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CCD39268((uint64_t)v5, v10, &v11);
      uint64_t *v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CCD39550(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = (a1[1] - *a1) >> 5;
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) >> 59) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 4 > v4) {
    unint64_t v4 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v4;
  }
  long long v25 = a1 + 2;
  if (v7 >> 59) {
    sub_1CB833614();
  }
  uint64_t v10 = (char *)operator new(32 * v7);
  uint64_t v11 = &v10[32 * v3];
  long long __p = v10;
  char v22 = v11;
  uint64_t v12 = *a2;
  *((_DWORD *)v11 + 6) = 0;
  uint64_t v13 = *a3;
  *(void *)uint64_t v11 = v12;
  *((void *)v11 + 1) = v13;
  *((void *)v11 + 2) = 0;
  *a3 = 0;
  uint64_t v14 = a3[1];
  *((_DWORD *)a3 + 2) = 0;
  LODWORD(v12) = *((_DWORD *)a3 + 4);
  uint64_t v15 = *(void *)(v11 + 20);
  *((void *)v11 + 2) = v14;
  *((_DWORD *)v11 + 6) = v12;
  *(uint64_t *)((char *)a3 + 12) = v15;
  char v23 = v11 + 32;
  int v24 = &v10[32 * v7];
  sub_1CD761D94(a1, &__p);
  uint64_t v16 = a1[1];
  uint64_t v18 = v22;
  BOOL v17 = v23;
  if (v23 != v22)
  {
    do
    {
      int v19 = v17 - 32;
      sub_1CD6881A8((uint64_t *)v17 - 3);
      BOOL v17 = v19;
    }
    while (v19 != v18);
  }
  if (__p) {
    operator delete(__p);
  }
  return v16;
}

BOOL sub_1CCD39678(uint64_t a1, llvm::BasicBlock *a2, uint64_t a3, uint64_t *a4, uint64_t a5, const llvm::DominatorTree *a6)
{
  v78[176] = *MEMORY[0x1E4F143B8];
  uint64_t v76 = (char *)v78;
  uint64_t v77 = 0x1000000000;
  v61[0] = 0;
  v61[1] = 0;
  int v62 = 0;
  uint64_t v8 = *(void *)(a3 + 40);
  if (sub_1CC5818F8(a3)) {
    llvm::MemoryLocation::getForArgument(a3, 0, 0, (uint64_t)&v71);
  }
  else {
    llvm::MemoryLocation::getOrNone((uint64_t ***)a3, (uint64_t)&v71);
  }
  uint64_t v9 = v71;
  uint64_t v58 = *(void *)v72;
  long long v56 = *(_OWORD *)&v72[24];
  long long v57 = *(_OWORD *)&v72[8];
  *(void *)unint64_t v63 = v71;
  *(void *)&v63[8] = a5;
  *(_OWORD *)&unsigned char v63[16] = 0uLL;
  *(void *)&v63[32] = &v64;
  *(void *)&v63[40] = 0x400000000;
  if (v71 && *(unsigned __int8 *)(v71 + 16) > 0x1Bu)
  {
    uint64_t v64 = v71;
    *(_OWORD *)uint64_t v72 = *(_OWORD *)v63;
    *(_OWORD *)&v72[16] = *(_OWORD *)&v63[16];
    uint64_t v71 = v8;
    *(void *)&v72[32] = v75;
    v75[0] = v9;
    int v10 = 1;
  }
  else
  {
    int v10 = 0;
    *(_OWORD *)uint64_t v72 = *(_OWORD *)v63;
    *(_OWORD *)&v72[16] = *(_OWORD *)&v63[16];
    uint64_t v71 = v8;
    *(void *)&v72[32] = v75;
  }
  unsigned int v73 = v10;
  int v74 = 4;
  sub_1CC09FBF0((uint64_t)&v76, (unint64_t)&v71);
  if (*(void **)&v72[32] != v75) {
    free(*(void **)&v72[32]);
  }
  if (*(uint64_t **)&v63[32] != &v64) {
    free(*(void **)&v63[32]);
  }
  char v11 = 1;
  do
  {
    int v12 = v77;
    if (!v77) {
      break;
    }
    sub_1CD761E2C(&v71, (uint64_t *)&v76);
    uint64_t v13 = (llvm::BasicBlock *)v71;
    uint64_t v14 = a1;
    if ((llvm::BasicBlock *)v71 != a2) {
      uint64_t v14 = *(void *)(v71 + 48);
    }
    if (v11) {
      uint64_t v15 = a3 + 24;
    }
    else {
      uint64_t v15 = v71 + 40;
    }
    if (v14 != v15)
    {
      uint64_t v16 = *(void *)v72;
      while (1)
      {
        if (v14) {
          uint64_t v17 = v14 - 24;
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v18 = *(unsigned __int8 *)(v17 + 16) - 33;
        if (v18 > 0x37) {
          goto LABEL_28;
        }
        if (((1 << (*(unsigned char *)(v17 + 16) - 33)) & 0x8000000000041) != 0) {
          break;
        }
        if (v18 != 27)
        {
          if (((1 << (*(unsigned char *)(v17 + 16) - 33)) & 0x808001D0000010) == 0) {
            goto LABEL_28;
          }
LABEL_44:
          int v21 = 1;
          goto LABEL_45;
        }
        int v21 = (*(_WORD *)(v17 + 18) & 0x301) != 0;
LABEL_45:
        if (v17 != a3)
        {
          if (v21)
          {
            *(void *)unint64_t v63 = v16;
            *(void *)&v63[8] = v58;
            *(_OWORD *)&unsigned char v63[16] = v57;
            *(_OWORD *)&v63[32] = v56;
            int v30 = 1;
            LOBYTE(v64) = 1;
            if ((llvm::AAResults::getModRefInfo(*a4, (llvm::Instruction *)v17, (long long *)v63, (uint64_t)(a4 + 1)) & 2) != 0) {
              goto LABEL_61;
            }
          }
        }
LABEL_28:
        uint64_t v14 = *(void *)(v14 + 8);
        if (v14 == v15) {
          goto LABEL_49;
        }
      }
      uint64_t v19 = *(void *)(v17 + 64);
      if (v19 && (*(unsigned char *)(v19 + 17) & 0x30) != 0) {
        goto LABEL_28;
      }
      int v20 = *(_DWORD *)(v17 + 20);
      if ((v20 & 0x80000000) == 0
        || (v22 = v17 - 32 * (v20 & 0x7FFFFFF), uint64_t v25 = *(void *)(v22 - 8), v23 = v22 - 8, (v24 = v25) == 0))
      {
LABEL_33:
        if (llvm::CallBase::hasFnAttrOnCalledFunction(v17, 45)) {
          goto LABEL_28;
        }
        int v21 = llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44) ^ 1;
        goto LABEL_45;
      }
      uint64_t v26 = -v24;
      while (1)
      {
        unsigned int v27 = *(_DWORD *)(*(void *)(v23 + v26) + 8);
        BOOL v35 = v27 > 7;
        int v28 = (1 << v27) & 0x83;
        if (v35 || v28 == 0) {
          goto LABEL_44;
        }
        v26 += 16;
        if (!v26) {
          goto LABEL_33;
        }
      }
    }
LABEL_49:
    if (v13 == a2) {
      goto LABEL_60;
    }
    uint64_t v31 = *((void *)v13 + 1);
    if (!v31) {
      goto LABEL_60;
    }
    while (1)
    {
      uint64_t v32 = *(void *)(v31 + 24);
      unsigned int v33 = *(unsigned __int8 *)(v32 + 16);
      BOOL v34 = v32 && v33 >= 0x1C;
      BOOL v35 = !v34 || v33 - 29 > 0xA;
      if (!v35) {
        break;
      }
      uint64_t v31 = *(void *)(v31 + 8);
      if (!v31) {
        goto LABEL_60;
      }
    }
LABEL_77:
    int v40 = *(llvm::BasicBlock **)(v32 + 40);
    long long v66 = *(_OWORD *)v72;
    long long v67 = *(_OWORD *)&v72[16];
    uint64_t v68 = v70;
    uint64_t v69 = 0x400000000;
    uint64_t v41 = v73;
    if (!v73) {
      goto LABEL_91;
    }
    if (v73 >= 5) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v70, *(const void **)&v72[32], 8 * v73);
    LODWORD(v69) = v41;
    BOOL v42 = (char *)v68;
    while (*(llvm::BasicBlock **)(*(void *)v42 + 40) != v13)
    {
      v42 += 8;
      if (!--v41) {
        goto LABEL_91;
      }
    }
    BOOL v43 = (void)v66 && *(unsigned __int8 *)(v66 + 16) >= 0x1Cu;
    if (v43 && !sub_1CC0CC938(v66)
      || (llvm::PHITransAddr::PHITranslateValue((llvm::PHITransAddr *)&v66, v13, v40, a6) & 1) != 0)
    {
      int v30 = 1;
    }
    else
    {
LABEL_91:
      *(void *)unint64_t v63 = v40;
      *(void *)&v63[8] = v66;
      if (!v62)
      {
        int v39 = 0;
LABEL_107:
        int v51 = sub_1CC0A3E2C((uint64_t)v61, (uint64_t)v63, (uint64_t *)v63, v39);
        *(_OWORD *)int v51 = *(_OWORD *)v63;
        *(_OWORD *)&v63[8] = v66;
        *(_OWORD *)&v63[24] = v67;
        *(void *)unint64_t v63 = v40;
        *(void *)&v63[40] = v65;
        uint64_t v64 = 0x400000000;
        int v52 = v69;
        if (v69)
        {
          if (v69 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v65, v68, 8 * v69);
          LODWORD(v64) = v52;
        }
        sub_1CC09FBF0((uint64_t)&v76, (unint64_t)v63);
        if (*(unsigned char **)&v63[40] != v65) {
          free(*(void **)&v63[40]);
        }
        int v30 = 0;
        goto LABEL_113;
      }
      uint64_t v44 = (v62 - 1) & ((v40 >> 4) ^ (v40 >> 9));
      uint64_t v45 = (uint64_t *)(v61[0] + 16 * v44);
      uint64_t v46 = (llvm::BasicBlock *)*v45;
      if (v40 != (llvm::BasicBlock *)*v45)
      {
        int v47 = 0;
        int v48 = 1;
        while (v46 != (llvm::BasicBlock *)-4096)
        {
          if (v47) {
            BOOL v49 = 0;
          }
          else {
            BOOL v49 = v46 == (llvm::BasicBlock *)-8192;
          }
          if (v49) {
            int v47 = v45;
          }
          int v50 = v44 + v48++;
          uint64_t v44 = v50 & (v62 - 1);
          uint64_t v45 = (uint64_t *)(v61[0] + 16 * v44);
          uint64_t v46 = (llvm::BasicBlock *)*v45;
          if (v40 == (llvm::BasicBlock *)*v45) {
            goto LABEL_101;
          }
        }
        if (v47) {
          int v39 = v47;
        }
        else {
          int v39 = v45;
        }
        goto LABEL_107;
      }
LABEL_101:
      if ((void)v66 == *(void *)(v61[0] + 16 * v44 + 8)) {
        int v30 = 8;
      }
      else {
        int v30 = 1;
      }
    }
LABEL_113:
    if (v68 != v70) {
      free(v68);
    }
    if ((v30 | 8) != 8) {
      goto LABEL_61;
    }
    while (1)
    {
      uint64_t v31 = *(void *)(v31 + 8);
      if (!v31) {
        break;
      }
      uint64_t v32 = *(void *)(v31 + 24);
      unsigned int v36 = *(unsigned __int8 *)(v32 + 16);
      if (v32) {
        BOOL v37 = v36 >= 0x1C;
      }
      else {
        BOOL v37 = 0;
      }
      if (v37 && v36 - 29 < 0xB) {
        goto LABEL_77;
      }
    }
LABEL_60:
    int v30 = 0;
LABEL_61:
    if (*(void **)&v72[32] != v75) {
      free(*(void **)&v72[32]);
    }
    char v11 = 0;
  }
  while (!v30);
  MEMORY[0x1D25D9CD0](v61[0], 8);
  sub_1CC0A3FF0(&v76);
  return v12 == 0;
}

uint64_t sub_1CCD39CE8(uint64_t ***a1, void *a2, unint64_t *a3, uint64_t a4, uint64_t a5, int a6)
{
  v80[1] = *MEMORY[0x1E4F143B8];
  int v12 = a1[8];
  if (v12)
  {
    if (*((_DWORD *)v12 + 2) >= 3u)
    {
      uint64_t v13 = (llvm::AttributeSetNode *)v12[7];
      if (v13)
      {
        LOWORD(v13) = llvm::AttributeSetNode::getAlignment(v13);
        LODWORD(v12) = BYTE1(v13);
      }
      else
      {
        LODWORD(v12) = 0;
      }
      goto LABEL_7;
    }
    LODWORD(v12) = 0;
  }
  LOBYTE(v13) = 0;
LABEL_7:
  unsigned int v14 = v13 | (v12 << 8);
  if (v14 <= 0x100) {
    char v15 = 0;
  }
  else {
    char v15 = v14;
  }
  uint64_t v16 = *a2;
  if (a6)
  {
    unint64_t v17 = (~v16 + a4 + (1 << v15)) & -(1 << v15);
    BOOL v18 = *a3 >= v17;
    unint64_t v19 = *a3 - v17;
    if (v18) {
      unint64_t v20 = v19;
    }
    else {
      unint64_t v20 = 0;
    }
    if (v19 == 0 || !v18) {
      return 0;
    }
LABEL_19:
    unint64_t v23 = *a3 - v20;
    if (*((unsigned char *)a1 + 16) == 84
      && (uint64_t v24 = (uint64_t)*(a1 - 4)) != 0
      && !*(unsigned char *)(v24 + 16)
      && *(uint64_t ***)(v24 + 24) == a1[9]
      && (*(unsigned char *)(v24 + 33) & 0x20) != 0
      && (unsigned int v71 = *(_DWORD *)(v24 + 36) - 195, v71 <= 5)
      && ((1 << v71) & 0x29) != 0)
    {
      uint64_t v25 = *((_DWORD *)a1 + 5) & 0x7FFFFFF;
      uint64_t v72 = a1[-4 * v25 + 12];
      unsigned int v73 = (unsigned int *)(v72 + 3);
      if (*((_DWORD *)v72 + 8) >= 0x41u) {
        unsigned int v73 = *(unsigned int **)v73;
      }
      if (v23 % *v73) {
        return 0;
      }
    }
    else
    {
      uint64_t v25 = *((_DWORD *)a1 + 5) & 0x7FFFFFF;
    }
    uint64_t v26 = (llvm::ConstantInt **)a1[-4 * v25 + 8];
    unsigned int v27 = llvm::ConstantInt::get(*v26, *a3 - v20, 0);
    int v28 = &a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
    long long v29 = (uint64_t *)(v28 + 8);
    if (v28[8])
    {
      *v28[10] = (uint64_t *)v28[9];
      int v30 = v28[9];
      if (v30) {
        v30[2] = (uint64_t *)v28[10];
      }
    }
    uint64_t *v29 = (uint64_t)v27;
    if (v27)
    {
      unsigned int v33 = (void **)v27[1];
      uint64_t v31 = (uint64_t **)(v27 + 1);
      uint64_t v32 = v33;
      v28[9] = v33;
      if (v33) {
        v32[2] = v28 + 9;
      }
      v28[10] = v31;
      void *v31 = v29;
    }
    sub_1CC27C328((uint64_t)a1, v15);
    if (a6)
    {
LABEL_53:
      *a3 = v23;
      return 1;
    }
    BOOL v34 = (llvm::CastInst *)a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)];
    unsigned int v35 = *(_DWORD *)(*(void *)v34 + 8);
    if ((v35 & 0xFE) == 0x12) {
      unsigned int v35 = *(_DWORD *)(**(void **)(*(void *)v34 + 16) + 8);
    }
    unint64_t v75 = v23;
    uint64_t v76 = a2;
    unsigned int v36 = (llvm::Value *)llvm::PointerType::get((llvm::PointerType *)(***a1 + 1912), (llvm::Type *)(v35 >> 8));
    PointerCast = (uint64_t *)v34;
    if (*(llvm::Value **)v34 != v36)
    {
      __int16 v79 = 257;
      PointerCast = (uint64_t *)llvm::CastInst::CreatePointerCast(v34, v36, v78, (const llvm::Twine *)a1, v37);
    }
    v80[0] = (uint64_t)llvm::ConstantInt::get(*v26, v20, 0);
    uint64_t v39 = ***a1;
    __int16 v79 = 257;
    int v40 = (char *)operator new(0x90uLL);
    *((_DWORD *)v40 + 21) = *((_DWORD *)v40 + 21) & 0x38000000 | 2;
    uint64_t v41 = (llvm::Value *)(v40 + 64);
    *(void *)int v40 = 0;
    *((void *)v40 + 1) = 0;
    *((void *)v40 + 2) = 0;
    *((void *)v40 + 3) = v40 + 64;
    *((void *)v40 + 4) = 0;
    *((void *)v40 + 5) = 0;
    *((void *)v40 + 6) = 0;
    *((void *)v40 + 7) = v40 + 64;
    sub_1CB845A7C(v39 + 1912, PointerCast, (uint64_t)v80, 1);
    *((void *)v40 + 8) = v42;
    *((void *)v40 + 9) = 0;
    unsigned int v43 = *((_DWORD *)v40 + 21) & 0xC0000000 | 2;
    *((_DWORD *)v40 + 20) = 62;
    *((_DWORD *)v40 + 21) = v43;
    *(_OWORD *)(v40 + 88) = 0u;
    uint64_t v44 = (uint64_t *)(v40 + 88);
    *(_OWORD *)(v40 + 104) = 0u;
    *((_DWORD *)v40 + 30) = 0;
    uint64_t v45 = a1[5];
    *((void *)v40 + 13) = v45;
    *((_WORD *)v45 + 9) &= ~0x8000u;
    if ((v40[87] & 0x10) != 0)
    {
      uint64_t v69 = v45[7];
      if (v69)
      {
        unsigned int v70 = (llvm::ValueSymbolTable *)v69[13];
        if (v70) {
          llvm::ValueSymbolTable::reinsertValue(v70, v41);
        }
      }
    }
    uint64_t v46 = a1[3];
    *((void *)v40 + 11) = v46;
    *((void *)v40 + 12) = a1 + 3;
    v46[1] = v44;
    a1[3] = (uint64_t **)v44;
    *((void *)v40 + 16) = v39 + 1912;
    *((void *)v40 + 17) = llvm::GetElementPtrInst::getIndexedType(v39 + 1912, (uint64_t)v80, 1);
    llvm::GetElementPtrInst::init((uint64_t ***)v41, (uint64_t **)PointerCast, v80, 1, v78);
    v40[81] |= 2u;
    int v48 = (unsigned __int8 *)a1[6];
    uint64_t v77 = v48;
    if (v48) {
      llvm::MetadataTracking::track((uint64_t)&v77, v48, 2);
    }
    int v51 = (unsigned __int8 *)*((void *)v40 + 14);
    int v50 = v40 + 112;
    BOOL v49 = v51;
    unint64_t v23 = v75;
    if (v51)
    {
      int v66 = *v49;
      if ((v66 - 4) > 0x1E)
      {
        if ((v66 - 3) >= 0xFFFFFFFE) {
          int v74 = v49;
        }
        else {
          int v74 = 0;
        }
        if ((v66 - 3) < 0xFFFFFFFE)
        {
          if (v66 == 3) {
            *((void *)v49 + 1) = 0;
          }
          goto LABEL_41;
        }
        unint64_t v68 = (unint64_t)(v74 + 8);
      }
      else
      {
        if ((v49[1] & 0x7F) != 2 && !*((_DWORD *)v49 + 3)) {
          goto LABEL_41;
        }
        uint64_t v67 = *((void *)v49 + 2);
        if ((v67 & 4) == 0) {
          goto LABEL_41;
        }
        unint64_t v68 = v67 & 0xFFFFFFFFFFFFFFF8;
        if (!v68) {
          goto LABEL_41;
        }
      }
      v78[0] = v50;
      sub_1CC5FA668(v68 + 16, v78);
    }
LABEL_41:
    int v52 = v77;
    *(void *)int v50 = v77;
    if (v52)
    {
      llvm::MetadataTracking::retrack((uint64_t)&v77, v52, (uint64_t)v50);
      uint64_t v77 = 0;
    }
    uint64_t v53 = *(llvm::Value **)v34;
    if (*(void *)v41 != *(void *)v34)
    {
      __int16 v79 = 257;
      uint64_t v41 = llvm::CastInst::CreatePointerCast(v41, v53, v78, (const llvm::Twine *)a1, v47);
    }
    uint64_t v54 = *((_DWORD *)a1 + 5) & 0x7FFFFFF;
    uint64_t v55 = -v54;
    long long v56 = (llvm::Value **)&a1[-4 * v54];
    if (*v56)
    {
      long long v57 = &a1[4 * v55];
      unsigned int v59 = v57[2];
      uint64_t v58 = v57 + 2;
      *unsigned int v59 = (uint64_t *)*(v58 - 1);
      uint64_t v60 = *(v58 - 1);
      if (v60) {
        *(void *)(v60 + 16) = *v58;
      }
    }
    llvm::Type *v56 = v41;
    if (v41)
    {
      unint64_t v63 = (void **)*((void *)v41 + 1);
      int v62 = (llvm::Value ***)((char *)v41 + 8);
      uint64_t v61 = v63;
      uint64_t v64 = &a1[4 * v55];
      v64[1] = v63;
      if (v63) {
        void v61[2] = v64 + 1;
      }
      v64[2] = (uint64_t **)v62;
      void *v62 = v56;
    }
    *v76 += v20;
    goto LABEL_53;
  }
  unint64_t v20 = a4 - v16 + a5;
  uint64_t v21 = 1 << v15;
  unint64_t v22 = ((v20 + (1 << v15) - 1) & -(1 << v15)) - v20;
  if (!v22) {
    goto LABEL_19;
  }
  if (v20 > v21 - v22)
  {
    unint64_t v20 = ((v20 + (1 << v15) - 1) & -(1 << v15)) - v21;
    goto LABEL_19;
  }
  return 0;
}

void sub_1CCD3A24C()
{
}

void sub_1CCD3A28C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD3A2C4(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);
  sub_1CB843600(a2, v3, (uint64_t)&llvm::LoopInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
}

uint64_t sub_1CCD3A420(llvm::FunctionPass *a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, (llvm::LLVMContextImpl ****)a2) & 1) == 0)
  {
    int v5 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_6:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v6 != &llvm::AAResultsWrapperPass::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_6;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::AAResultsWrapperPass::ID);
    uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (v10 == v11)
    {
LABEL_11:
      uint64_t v12 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v10 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v10 += 16;
        if (v10 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *(void *)(v10 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v13 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (v14 == v15)
    {
LABEL_16:
      uint64_t v16 = 0;
    }
    else
    {
      while (*(char **)v14 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v14 += 16;
        if (v14 == v15) {
          goto LABEL_16;
        }
      }
      uint64_t v16 = *(void *)(v14 + 8);
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v16 + 96))(v16, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v18 = v17 + 32;
    if (!*(unsigned char *)(v17 + 232))
    {
      uint64_t v19 = *(void *)(a2 + 40) + 216;
      __int16 v22 = 260;
      v21[0] = v19;
      llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v21);
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      int v34 = 0;
      long long v35 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      *(void *)&long long v20 = -1;
      *((void *)&v20 + 1) = -1;
      *(_OWORD *)__src = v20;
      long long v26 = v20;
      long long v27 = v20;
      long long v28 = v20;
      long long v29 = v20;
      long long v30 = v20;
      *(_OWORD *)uint64_t v31 = v20;
      *(void *)&v31[13] = -1;
      sub_1CC153974((uint64_t)__src, (int *)__p);
      sub_1CD4D04B8(v18, (uint64_t)__src);
      sub_1CD4CFA4C((uint64_t *)__src);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
    }
    sub_1CC1569E8(__src, v18);
  }
  return 0;
}

uint64_t sub_1CCD3AB00()
{
  dword_1EBCF0DFC = sub_1CBF64200((llvm::DebugCounter *)"dse-memoryssa", 0xDuLL, "Controls which MemoryDefs are eliminated.", 0x29uLL);
  LOBYTE(v1) = 1;
  unint64_t v4 = &v1;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Enable partial-overwrite tracking in DSE";
  v2.n128_u64[1] = 40;
  sub_1CBA9E5B0((llvm::cl::Option *)&qword_1EBCF0E00[1], "enable-dse-partial-overwrite-tracking", (unsigned char **)&v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF0E00[1], &dword_1CB82C000);
  LOBYTE(v1) = 1;
  unint64_t v4 = &v1;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Enable partial store merging in DSE";
  v2.n128_u64[1] = 35;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF0EC8, "enable-dse-partial-store-merging", (unsigned char **)&v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF0EC8, &dword_1CB82C000);
  int v3 = 150;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The number of memory instructions to scan for dead store elimination (default = 150)";
  v2.n128_u64[1] = 84;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF0F88, "dse-memoryssa-scanlimit", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF0F88, &dword_1CB82C000);
  int v3 = 90;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The maximum number of steps while walking upwards to find MemoryDefs that may be ki"
                                     "lled (default = 90)";
  v2.n128_u64[1] = 102;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF1048, "dse-memoryssa-walklimit", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1048, &dword_1CB82C000);
  int v3 = 5;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The maximum number candidates that only partially overwrite the killing MemoryDef t"
                                     "o consider (default = 5)";
  v2.n128_u64[1] = 107;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF1108, "dse-memoryssa-partial-store-limit", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1108, &dword_1CB82C000);
  int v3 = 5000;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The number of MemoryDefs we consider as candidates to eliminated other stores per b"
                                     "asic block (default = 5000)";
  v2.n128_u64[1] = 110;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF11C8, "dse-memoryssa-defs-per-block-limit", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF11C8, &dword_1CB82C000);
  int v3 = 1;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The cost of a step in the same basic block as the killing MemoryDef(default = 1)";
  v2.n128_u64[1] = 80;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF1288, "dse-memoryssa-samebb-cost", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1288, &dword_1CB82C000);
  int v3 = 5;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The cost of a step in a different basic block than the killing MemoryDef(default = 5)";
  v2.n128_u64[1] = 85;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF1348, "dse-memoryssa-otherbb-cost", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1348, &dword_1CB82C000);
  int v3 = 50;
  unint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"The maximum number of blocks to check when trying to prove that all paths to an exi"
                                     "t go through a killing block (default = 50)";
  v2.n128_u64[1] = 126;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF1408, "dse-memoryssa-path-check-limit", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1408, &dword_1CB82C000);
  LOBYTE(v1) = 1;
  unint64_t v4 = &v1;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Allow DSE to optimize memory accesses.";
  v2.n128_u64[1] = 38;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF14C8, "dse-optimize-memoryssa", (unsigned char **)&v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF14C8, &dword_1CB82C000);
}

void sub_1CCD3AEA8(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v2);
  operator new();
}

uint64_t sub_1CCD3AF5C(uint64_t a1, llvm::Function *this)
{
  v827[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 14);
  if (v3 && ((*(unsigned char *)(v3 + 17) & 4) != 0 || *(char *)(v3 + 13) < 0))
  {
    char v325 = 0;
    return v325 & 1;
  }
  if (byte_1EBCF1610) {
    llvm::Function::viewCFG(this, 0, 0, 0);
  }
  v765 = v767;
  uint64_t v766 = 0x200000000;
  unint64_t v4 = (char *)this + 72;
  int v5 = (char *)*((void *)this + 10);
  if (v5 != (char *)this + 72)
  {
    char v702 = 0;
    int v696 = (int)this;
    long long v6 = 0uLL;
    char v698 = (char *)this + 72;
    while (1)
    {
      if (v5) {
        uint64_t v7 = v5 - 24;
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t v8 = (char *)*((void *)v7 + 5);
      if (v8 == v7 + 40) {
        goto LABEL_343;
      }
      uint64_t v9 = v8 ? (uint64_t)(v8 - 24) : 0;
      unsigned int v10 = *(unsigned __int8 *)(v9 + 16) - 40;
      uint64_t v11 = v10 >= 0xFFFFFFF5 ? v9 : 0;
      if (!v8) {
        goto LABEL_343;
      }
      if (*(unsigned char *)(v11 + 16) != 31 || v10 < 0xFFFFFFF5) {
        goto LABEL_343;
      }
      uint64_t v13 = *(uint64_t ****)(a1 + 24);
      v747 = (uint64_t *)&unk_1F263DA98;
      v748.i64[0] = 0;
      v748.i64[1] = (uint64_t)&v749 + 8;
      *(_OWORD *)v774 = v6;
      long long v773 = v6;
      *(_OWORD *)v772 = v6;
      __b[0] = v801;
      __b[1] = v801;
      *(void *)&long long v800 = 16;
      DWORD2(v800) = 0;
      *(void *)&long long v749 = 0x400000000;
      int v14 = *(_DWORD *)(v11 + 20);
      if ((v14 & 0x40000000) != 0) {
        uint64_t v15 = *(void *)(v11 - 8);
      }
      else {
        uint64_t v15 = v11 - 32 * (v14 & 0x7FFFFFF);
      }
      uint64_t v16 = *(unsigned char **)v15;
      if (*(unsigned __int8 *)(*(void *)v15 + 16) <= 0x1Bu) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = *(unsigned char **)v15;
      }
      v759 = v17;
      unsigned int v703 = v5;
      if (!v17 || v17[16] != 83) {
        goto LABEL_32;
      }
      sub_1CD3F21B0(v772, &v759);
      uint64_t v222 = (char *)__b[1];
      uint64_t v223 = DWORD1(v800);
      if (__b[1] != __b[0]) {
        break;
      }
      if (DWORD1(v800))
      {
        uint64_t v224 = 0;
        uint64_t v225 = 8 * DWORD1(v800);
        unint64_t v226 = __b[1];
        while ((unsigned char *)*v226 != v16)
        {
          if (*v226 == -2) {
            uint64_t v224 = v226;
          }
          ++v226;
          v225 -= 8;
          if (!v225)
          {
            if (!v224) {
              goto LABEL_353;
            }
            *uint64_t v224 = v16;
            --DWORD2(v800);
            goto LABEL_400;
          }
        }
        goto LABEL_400;
      }
LABEL_353:
      unsigned int v227 = v800;
      if (DWORD1(v800) >= v800) {
        goto LABEL_379;
      }
      ++DWORD1(v800);
      *((void *)__b[1] + v223) = v16;
LABEL_400:
      uint64_t v244 = *(void *)&v774[8];
      if (!*(void *)&v774[8])
      {
        int v18 = 1;
        goto LABEL_33;
      }
      while (1)
      {
        uint64_t v245 = *(void *)(*(void *)((char *)v772[1] + ((*(void *)v774 >> 6) & 0x3FFFFFFFFFFFFF8))
                         + 8 * (*(_WORD *)v774 & 0x1FF));
        *(void *)&v774[8] = v244 - 1;
        if (++*(void *)v774 >= 0x400uLL)
        {
          operator delete(*(void **)v772[1]);
          v772[1] = (char *)v772[1] + 8;
          *(void *)v774 -= 512;
        }
        int v246 = *(unsigned __int8 *)(v245 + 16);
        if (v246 != 83 || v245 == 0) {
          break;
        }
        int v264 = *(_DWORD *)(v245 + 20);
        if ((v264 & 0x40000000) != 0)
        {
          unsigned int v266 = *(uint64_t **)(v245 - 8);
          uint64_t v265 = v264 & 0x7FFFFFF;
          if (v265)
          {
LABEL_447:
            unint64_t v267 = &v266[4 * v265];
            do
            {
              uint64_t v268 = *v266;
              uint64_t v269 = __b[0];
              if (__b[1] == __b[0])
              {
                int v270 = DWORD1(v800);
                BOOL v271 = (char *)__b[1] + 8 * DWORD1(v800);
                if (DWORD1(v800))
                {
                  uint64_t v272 = 0;
                  while (*(void *)((char *)__b[1] + v272) != v268)
                  {
                    v272 += 8;
                    if (8 * DWORD1(v800) == v272) {
                      goto LABEL_467;
                    }
                  }
                  BOOL v271 = (char *)__b[1] + v272;
                }
LABEL_467:
                uint64_t v269 = __b[1];
              }
              else
              {
                int v273 = v800 - 1;
                unsigned int v274 = (v800 - 1) & ((v268 >> 4) ^ (v268 >> 9));
                BOOL v271 = (char *)__b[1] + 8 * v274;
                uint64_t v275 = *(void *)v271;
                if (*(void *)v271 == -1)
                {
                  uint64_t v276 = 0;
LABEL_480:
                  if (v276) {
                    BOOL v271 = v276;
                  }
                  int v270 = DWORD1(v800);
                  if (*(void *)v271 != v268) {
                    BOOL v271 = (char *)__b[1] + 8 * v800;
                  }
                }
                else
                {
                  uint64_t v276 = 0;
                  int v277 = 1;
                  while (v275 != v268)
                  {
                    if (v276) {
                      BOOL v278 = 0;
                    }
                    else {
                      BOOL v278 = v275 == -2;
                    }
                    if (v278) {
                      uint64_t v276 = v271;
                    }
                    unsigned int v279 = v274 + v277++;
                    unsigned int v274 = v279 & v273;
                    BOOL v271 = (char *)__b[1] + 8 * (v279 & v273);
                    uint64_t v275 = *(void *)v271;
                    if (*(void *)v271 == -1) {
                      goto LABEL_480;
                    }
                  }
                  int v270 = DWORD1(v800);
                }
              }
              unsigned int v280 = __b[1] == v269 ? v270 : v800;
              if (v271 == (char *)__b[1] + 8 * v280)
              {
                unsigned int v281 = *(unsigned __int8 *)(v268 + 16);
                if (v281 != 16 && v281 < 0x1C) {
                  goto LABEL_32;
                }
              }
              sub_1CCD4233C(v268, v772, (llvm::SmallPtrSetImplBase *)__b);
              v266 += 4;
            }
            while (v266 != v267);
          }
        }
        else
        {
          uint64_t v265 = v264 & 0x7FFFFFF;
          unsigned int v266 = (uint64_t *)(v245 - 32 * v265);
          if (v265) {
            goto LABEL_447;
          }
        }
LABEL_546:
        uint64_t v244 = *(void *)&v774[8];
        int v18 = 1;
        if (!*(void *)&v774[8]) {
          goto LABEL_33;
        }
      }
      if (v246 != 85 || v245 == 0) {
        goto LABEL_32;
      }
      uint64_t v249 = *(void *)(v245 + 8);
      if (!v249) {
        goto LABEL_32;
      }
      if (*(void *)(v249 + 8)) {
        goto LABEL_32;
      }
      uint64_t v250 = *(void *)(v249 + 24);
      if (!v250 && MEMORY[0x10] != 85 && MEMORY[0x10] != 83) {
        goto LABEL_32;
      }
      uint64_t v251 = *(void *)(v245 + 40);
      uint64_t v252 = *(void *)(v251 + 40);
      if (v252 == v251 + 40) {
        goto LABEL_32;
      }
      int v18 = 0;
      uint64_t v253 = v252 - 24;
      if (!v252) {
        uint64_t v253 = 0;
      }
      unsigned int v254 = *(unsigned __int8 *)(v253 + 16) - 40;
      if (v254 < 0xFFFFFFF5) {
        uint64_t v253 = 0;
      }
      if (!v252) {
        goto LABEL_33;
      }
      if (*(unsigned char *)(v253 + 16) != 30 || v254 < 0xFFFFFFF5) {
        goto LABEL_33;
      }
      if ((*(_DWORD *)(v253 + 20) & 0x7FFFFFF) != 1
        || *(unsigned char *)(v250 + 16) == 83
        && llvm::BasicBlock::getSingleSuccessor(*(llvm::BasicBlock **)(v245 + 40)) != *(void *)(v250 + 40))
      {
        goto LABEL_32;
      }
      if (!v749)
      {
LABEL_437:
        uint64_t v259 = *(void *)(v245 - 64);
        uint64_t v260 = __b[0];
        if (__b[1] == __b[0])
        {
          unsigned int v261 = DWORD1(v800);
          v262 = (char *)__b[1] + 8 * DWORD1(v800);
          if (DWORD1(v800))
          {
            uint64_t v263 = 0;
            while (*(void *)((char *)__b[1] + v263) != v259)
            {
              v263 += 8;
              if (8 * DWORD1(v800) == v263) {
                goto LABEL_498;
              }
            }
            v262 = (char *)__b[1] + v263;
          }
LABEL_498:
          uint64_t v290 = __b[1];
        }
        else
        {
          int v283 = v800 - 1;
          unsigned int v284 = (v800 - 1) & ((v259 >> 4) ^ (v259 >> 9));
          v262 = (char *)__b[1] + 8 * v284;
          uint64_t v285 = *(void *)v262;
          if (*(void *)v262 == -1)
          {
            uint64_t v286 = 0;
LABEL_500:
            if (v286) {
              v262 = v286;
            }
            unsigned int v261 = DWORD1(v800);
            if (*(void *)v262 != v259) {
              v262 = (char *)__b[1] + 8 * v800;
            }
          }
          else
          {
            uint64_t v286 = 0;
            int v287 = 1;
            while (v285 != v259)
            {
              if (v286) {
                BOOL v288 = 0;
              }
              else {
                BOOL v288 = v285 == -2;
              }
              if (v288) {
                uint64_t v286 = v262;
              }
              unsigned int v289 = v284 + v287++;
              unsigned int v284 = v289 & v283;
              v262 = (char *)__b[1] + 8 * (v289 & v283);
              uint64_t v285 = *(void *)v262;
              if (*(void *)v262 == -1) {
                goto LABEL_500;
              }
            }
            unsigned int v261 = DWORD1(v800);
          }
          uint64_t v290 = __b[0];
        }
        if (__b[1] == v290) {
          unsigned int v291 = v261;
        }
        else {
          unsigned int v291 = v800;
        }
        if (v262 == (char *)__b[1] + 8 * v291)
        {
          unsigned int v292 = *(unsigned __int8 *)(v259 + 16);
          if (v292 != 16 && v292 < 0x1C) {
            goto LABEL_32;
          }
        }
        uint64_t v294 = *(void *)(v245 - 32);
        if (__b[1] == v290)
        {
          unsigned int v295 = (char *)__b[1] + 8 * v261;
          if (v261)
          {
            uint64_t v296 = 0;
            while (*(void *)((char *)__b[1] + v296) != v294)
            {
              v296 += 8;
              if (8 * v261 == v296) {
                goto LABEL_532;
              }
            }
            unsigned int v295 = (char *)__b[1] + v296;
          }
LABEL_532:
          uint64_t v260 = __b[1];
        }
        else
        {
          int v297 = v800 - 1;
          unsigned int v298 = ((v294 >> 4) ^ (v294 >> 9)) & (v800 - 1);
          unsigned int v295 = (char *)__b[1] + 8 * v298;
          uint64_t v299 = *(void *)v295;
          if (*(void *)v295 == -1)
          {
            int v300 = 0;
LABEL_549:
            if (v300) {
              unsigned int v295 = v300;
            }
            if (*(void *)v295 != v294)
            {
              if (__b[1] == __b[0]) {
                unsigned int v309 = v261;
              }
              else {
                unsigned int v309 = v800;
              }
              unsigned int v295 = (char *)__b[1] + 8 * v309;
            }
          }
          else
          {
            int v300 = 0;
            int v301 = 1;
            while (v299 != v294)
            {
              if (v300) {
                BOOL v302 = 0;
              }
              else {
                BOOL v302 = v299 == -2;
              }
              if (v302) {
                int v300 = v295;
              }
              unsigned int v303 = v298 + v301++;
              unsigned int v298 = v303 & v297;
              unsigned int v295 = (char *)__b[1] + 8 * (v303 & v297);
              uint64_t v299 = *(void *)v295;
              if (*(void *)v295 == -1) {
                goto LABEL_549;
              }
            }
          }
        }
        unsigned int v304 = __b[1] == v260 ? v261 : v800;
        if (v295 == (char *)__b[1] + 8 * v304)
        {
          unsigned int v305 = *(unsigned __int8 *)(v294 + 16);
          if (v305 != 16 && v305 < 0x1C) {
            goto LABEL_32;
          }
        }
        sub_1CCD4233C(v259, v772, (llvm::SmallPtrSetImplBase *)__b);
        sub_1CCD4233C(*(void *)(v245 - 32), v772, (llvm::SmallPtrSetImplBase *)__b);
        uint64_t v307 = *(void *)(*(void *)(v245 + 8) + 24);
        if (v307 && *(unsigned char *)(v307 + 16) == 83)
        {
          if (v749 >= (unint64_t)DWORD1(v749)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v308 = (void *)(v748.i64[1] + 16 * v749);
          *uint64_t v308 = v245;
          v308[1] = v307;
          LODWORD(v749) = v749 + 1;
        }
        goto LABEL_546;
      }
      uint64_t v256 = (uint64_t *)v748.i64[1];
      uint64_t v257 = 16 * v749;
      while (1)
      {
        uint64_t v258 = *v256;
        if (*(void *)(*v256 - 64) != v245
          && *(void *)(v258 - 32) != v245
          && *(void *)(v258 + 40) == *(void *)(v245 + 40))
        {
          break;
        }
        v256 += 2;
        v257 -= 16;
        if (!v257) {
          goto LABEL_437;
        }
      }
LABEL_32:
      int v18 = 0;
LABEL_33:
      if (__b[1] != __b[0]) {
        free(__b[1]);
      }
      sub_1CB904DFC(v772);
      if (!v18)
      {
        uint64_t v32 = *(void *)***v13;
        if (*(void *)(v32 + 128)
          || (*(unsigned int (**)(void))(**(void **)(v32 + 72) + 48))(*(void *)(v32 + 72)))
        {
          llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)__b, (uint64_t)"dfa-jump-threading", (uint64_t)"SwitchNotPredictable", 20, v11);
          v759 = "Switch instruction is not predictable.";
          __src = (void *)38;
          sub_1CC59ADEC((uint64_t *)&v803, (uint64_t)&v759);
          LODWORD(v772[1]) = __b[1];
          BYTE4(v772[1]) = BYTE4(__b[1]);
          long long v773 = v800;
          *(void *)v774 = *(void *)v801;
          *(_OWORD *)&v774[8] = *(_OWORD *)&v801[8];
          long long v775 = *(_OWORD *)&v801[24];
          uint64_t v776 = v802;
          v772[0] = &unk_1F2616800;
          v777 = v779;
          uint64_t v778 = 0x400000000;
          if (v804)
          {
            sub_1CD494D68((uint64_t)&v777, (uint64_t)&v803);
            uint64_t v228 = v804;
          }
          else
          {
            uint64_t v228 = 0;
          }
          uint64_t v786 = v812;
          uint64_t v787 = v813;
          v772[0] = &unk_1F26165A8;
          __b[0] = &unk_1F2616800;
          unsigned int v229 = (char *)v803;
          if (v228)
          {
            uint64_t v230 = v228 << 6;
            do
            {
              uint64_t v231 = (void **)&v229[v230];
              if (v229[v230 - 17] < 0) {
                operator delete(*(v231 - 5));
              }
              if (*((char *)v231 - 41) < 0) {
                operator delete(*(v231 - 8));
              }
              v230 -= 64;
            }
            while (v230);
            unsigned int v229 = (char *)v803;
          }
          if (v229 != (char *)v805) {
            free(v229);
          }
          llvm::OptimizationRemarkEmitter::emit(v13, (llvm::DiagnosticInfoOptimizationBase *)v772);
          v772[0] = &unk_1F2616800;
          uint64_t v232 = (char *)v777;
          if (v778)
          {
            unint64_t v233 = (unint64_t)v778 << 6;
            do
            {
              BOOL v234 = (void **)&v232[v233];
              if (v232[v233 - 17] < 0) {
                operator delete(*(v234 - 5));
              }
              if (*((char *)v234 - 41) < 0) {
                operator delete(*(v234 - 8));
              }
              v233 -= 64;
            }
            while (v233);
            uint64_t v232 = (char *)v777;
          }
          if (v232 != (char *)v779) {
            free(v232);
          }
        }
        if (!v748.i64[0]) {
          goto LABEL_62;
        }
LABEL_37:
        uint64_t v19 = *(void *)(a1 + 8);
        sub_1CCD421DC(&v759, (uint64_t)&v747);
        __b[0] = &v800;
        __b[1] = (void *)0x1000000000;
        v805[22] = 0;
        v805[23] = 0;
        v805[24] = v19;
        v805[25] = 0;
        char v806 = 0;
        v807 = &v811;
        v808 = &v811;
        uint64_t v809 = 8;
        int v810 = 0;
        uint64_t v816 = 0;
        uint64_t v817 = 0;
        uint64_t v815 = 0;
        LOWORD(v818) = 0;
        v772[0] = &v773;
        v772[1] = (void *)0x400000000;
        if (__src)
        {
          unsigned int v20 = 0;
          uint64_t v21 = v759;
          uint64_t v22 = 16 * __src;
          do
          {
            if (v20 >= HIDWORD(v772[1])) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_OWORD *)v772[0] + v20) = *v21;
            unsigned int v20 = ++LODWORD(v772[1]);
            ++v21;
            v22 -= 16;
          }
          while (v22);
          if (v20)
          {
            uint64_t v23 = *((void *)v772[0] + 2 * v20 - 2);
            LODWORD(v772[1]) = v20 - 1;
            memset(&v794, 0, sizeof(v794));
            int v729 = 0;
            long long __p = 0;
            uint64_t v730 = 0;
            v735 = 0;
            *(void *)&long long v723 = 0;
            v792[0] = 0;
            v746.__r_.__value_.__r.__words[0] = 0;
            uint64_t v24 = *(void *)(v23 - 64);
            if (v24 && *(unsigned char *)(v24 + 16) == 85) {
              sub_1CCD425DC();
            }
            uint64_t v25 = *(void *)(v23 - 32);
            if (v25 && *(unsigned char *)(v25 + 16) == 85) {
              sub_1CCD425DC();
            }
            v768.__r_.__value_.__r.__words[0] = (std::string::size_type)"si.unfold.false";
            LOWORD(v770) = 259;
            operator new();
          }
        }
        if (v772[0] != &v773) {
          free(v772[0]);
        }
        sub_1CC2930C0((uint64_t)__b);
        if (v759 != &v761) {
          free(v759);
        }
        sub_1CCD421DC(__b, (uint64_t)&v747);
        int v26 = (int)__b[1];
        if (__b[0] != &v800) {
          free(__b[0]);
        }
        BOOL v27 = v26 != 0;
        std::string::size_type v28 = *(void *)(a1 + 24);
        long long v29 = *(void **)(v748.i64[0] + 40);
        v794.__r_.__value_.__r.__words[0] = v748.i64[0];
        v794.__r_.__value_.__l.__size_ = (std::string::size_type)v29;
        v794.__r_.__value_.__r.__words[2] = v28;
        v795 = 0;
        v796 = 0;
        unint64_t v797 = 0;
        v772[0] = v774;
        v772[1] = v774;
        *(void *)&long long v773 = 8;
        DWORD2(v773) = 0;
        sub_1CCD42888((uint64_t *)&v735, (uint64_t)&v794, v29, (uint64_t *)v772, 1u);
        long long v723 = 0uLL;
        LODWORD(v724) = 0;
        int v30 = *(_DWORD *)(v794.__r_.__value_.__r.__words[0] + 20);
        if ((v30 & 0x40000000) != 0) {
          uint64_t v31 = *(uint64_t **)(v794.__r_.__value_.__r.__words[0] - 8);
        }
        else {
          uint64_t v31 = (uint64_t *)(v794.__r_.__value_.__r.__words[0] - 32 * (v30 & 0x7FFFFFF));
        }
        v702 |= v27;
        uint64_t v34 = *v31;
        v759 = &v761;
        HIDWORD(__src) = 8;
        if (*(unsigned char *)(v34 + 16) == 83) {
          uint64_t v35 = v34;
        }
        else {
          uint64_t v35 = 0;
        }
        uint64_t v761 = v35;
        __b[0] = v801;
        __b[1] = v801;
        *(void *)&long long v800 = 16;
        DWORD2(v800) = 0;
        unsigned int v36 = 1;
        while (2)
        {
          uint64_t v37 = *((void *)v759 + v36 - 1);
          LODWORD(__src) = v36 - 1;
          v768.__r_.__value_.__r.__words[0] = *(void *)(v37 + 40);
          sub_1CD467E2C((uint64_t)&v723, (uint64_t *)&v768)[1] = v37;
          uint64_t v38 = (char *)__b[1];
          uint64_t v39 = DWORD1(v800);
          if (__b[1] == __b[0])
          {
            if (DWORD1(v800))
            {
              int v40 = 0;
              uint64_t v41 = 8 * DWORD1(v800);
              uint64_t v42 = __b[1];
              while (*v42 != v37)
              {
                if (*v42 == -2) {
                  int v40 = v42;
                }
                ++v42;
                v41 -= 8;
                if (!v41)
                {
                  if (!v40) {
                    goto LABEL_76;
                  }
                  void *v40 = v37;
                  --DWORD2(v800);
                  break;
                }
              }
LABEL_100:
              int v53 = *(_DWORD *)(v37 + 20);
              if ((v53 & 0x40000000) != 0)
              {
                uint64_t v55 = *(uint64_t **)(v37 - 8);
                uint64_t v54 = v53 & 0x7FFFFFF;
                if (!v54) {
                  goto LABEL_142;
                }
              }
              else
              {
                uint64_t v54 = v53 & 0x7FFFFFF;
                uint64_t v55 = (uint64_t *)(v37 - 32 * v54);
                if (!v54) {
                  goto LABEL_142;
                }
              }
              long long v56 = &v55[4 * v54];
              do
              {
                uint64_t v57 = *v55;
                if (*v55 != v34 && *(unsigned char *)(v57 + 16) != 16)
                {
                  uint64_t v58 = __b[0];
                  if (__b[1] == __b[0])
                  {
                    unsigned int v59 = DWORD1(v800);
                    uint64_t v60 = (char *)__b[1] + 8 * DWORD1(v800);
                    if (DWORD1(v800))
                    {
                      uint64_t v61 = 0;
                      while (*(void *)((char *)__b[1] + v61) != v57)
                      {
                        v61 += 8;
                        if (8 * DWORD1(v800) == v61) {
                          goto LABEL_126;
                        }
                      }
                      uint64_t v60 = (char *)__b[1] + v61;
                    }
LABEL_126:
                    uint64_t v58 = __b[1];
                  }
                  else
                  {
                    int v62 = v800 - 1;
                    unsigned int v63 = (v800 - 1) & ((v57 >> 4) ^ (v57 >> 9));
                    uint64_t v60 = (char *)__b[1] + 8 * v63;
                    uint64_t v64 = *(void *)v60;
                    if (*(void *)v60 == -1)
                    {
                      unsigned int v65 = 0;
LABEL_136:
                      if (v65) {
                        uint64_t v60 = v65;
                      }
                      unsigned int v59 = DWORD1(v800);
                      if (*(void *)v60 != v57) {
                        uint64_t v60 = (char *)__b[1] + 8 * v800;
                      }
                    }
                    else
                    {
                      unsigned int v65 = 0;
                      int v66 = 1;
                      while (v64 != v57)
                      {
                        if (v65) {
                          BOOL v67 = 0;
                        }
                        else {
                          BOOL v67 = v64 == -2;
                        }
                        if (v67) {
                          unsigned int v65 = v60;
                        }
                        unsigned int v68 = v63 + v66++;
                        unsigned int v63 = v68 & v62;
                        uint64_t v60 = (char *)__b[1] + 8 * (v68 & v62);
                        uint64_t v64 = *(void *)v60;
                        if (*(void *)v60 == -1) {
                          goto LABEL_136;
                        }
                      }
                      unsigned int v59 = DWORD1(v800);
                    }
                  }
                  if (__b[1] == v58) {
                    unsigned int v69 = v59;
                  }
                  else {
                    unsigned int v69 = v800;
                  }
                  if (v60 == (char *)__b[1] + 8 * v69)
                  {
                    if (__src >= (unint64_t)HIDWORD(__src)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v759 + __src) = v57;
                    LODWORD(__src) = __src + 1;
                  }
                }
                v55 += 4;
              }
              while (v55 != v56);
LABEL_142:
              unsigned int v36 = __src;
              if (__src) {
                continue;
              }
              if (__b[1] != __b[0]) {
                free(__b[1]);
              }
              if (v759 != &v761) {
                free(v759);
              }
              unsigned int v70 = v735;
              unsigned int v71 = v736;
              while (2)
              {
                if (v70 == v71)
                {
                  MEMORY[0x1D25D9CD0](v723, 8);
                  __b[0] = &v735;
                  sub_1CCD43AC4((void ***)__b);
                  if (v772[1] != v772[0]) {
                    free(v772[1]);
                  }
                  uint64_t v201 = (void **)v795;
                  if (954437177 * ((unint64_t)((char *)v796 - (unsigned char *)v795) >> 3))
                  {
                    int v202 = v766;
                    int v203 = (char *)v765;
                    if (v766 >= HIDWORD(v766))
                    {
                      BOOL v310 = v765 <= &v794 && (char *)v765 + 48 * v766 > (char *)&v794;
                      int v311 = v310;
                      if (v311 == 1) {
                        unint64_t v312 = 0xAAAAAAAAAAAAAAABLL * (((char *)&v794 - (unsigned char *)v765) >> 4);
                      }
                      else {
                        unint64_t v312 = -1;
                      }
                      unint64_t v313 = v766 + 1;
                      if (v766 == -1) {
LABEL_1279:
                      }
                        sub_1CD0A88F0(v313);
                      if (HIDWORD(v766) == -1) {
                        sub_1CD0A89A8(0xFFFFFFFFuLL);
                      }
                      unint64_t v314 = (2 * HIDWORD(v766)) | 1;
                      if (v314 <= v313) {
                        unint64_t v314 = v766 + 1;
                      }
                      if (v314 >= 0xFFFFFFFF) {
                        uint64_t v315 = 0xFFFFFFFFLL;
                      }
                      else {
                        uint64_t v315 = v314;
                      }
                      int v316 = (char *)malloc_type_malloc(48 * v315, 0x4065EBACuLL);
                      if (!v316)
                      {
                        long long v694 = "Allocation failed";
                        goto LABEL_1283;
                      }
                      int v203 = v316;
                      uint64_t v317 = (char *)v765;
                      if (v766)
                      {
                        uint64_t v318 = (char *)v765 + 48 * v766;
                        uint64_t v319 = v203;
                        do
                        {
                          uint64_t v320 = *((void *)v317 + 2);
                          *(_OWORD *)uint64_t v319 = *(_OWORD *)v317;
                          *((void *)v319 + 2) = v320;
                          *((void *)v319 + 3) = 0;
                          *((void *)v319 + 4) = 0;
                          *((void *)v319 + 5) = 0;
                          *(_OWORD *)(v319 + 24) = *(_OWORD *)(v317 + 24);
                          *((void *)v319 + 5) = *((void *)v317 + 5);
                          *((void *)v317 + 3) = 0;
                          *((void *)v317 + 4) = 0;
                          *((void *)v317 + 5) = 0;
                          v317 += 48;
                          v319 += 48;
                        }
                        while (v317 != v318);
                        uint64_t v317 = (char *)v765;
                        if (v766)
                        {
                          int v321 = (char *)v765 - 24;
                          uint64_t v322 = 48 * v766;
                          do
                          {
                            sub_1CCD43B48((void **)&v321[v322]);
                            v322 -= 48;
                          }
                          while (v322);
                          uint64_t v317 = (char *)v765;
                        }
                      }
                      if (v317 != v767) {
                        free(v317);
                      }
                      v765 = v203;
                      HIDWORD(v766) = v315;
                      BOOL v323 = &v203[48 * v312];
                      int v204 = &v794;
                      if (v311) {
                        int v204 = (std::string *)&v203[48 * v312];
                      }
                      int v205 = (void **)(v323 + 24);
                      uint64_t v324 = (void **)(v323 + 32);
                      uint64_t v206 = (void **)&v796;
                      if (v311) {
                        uint64_t v206 = v324;
                      }
                      else {
                        int v205 = &v795;
                      }
                      int v202 = v766;
                    }
                    else
                    {
                      int v204 = &v794;
                      int v205 = &v795;
                      uint64_t v206 = (void **)&v796;
                    }
                    uint64_t v207 = &v203[48 * v202];
                    long long v208 = *(_OWORD *)&v204->__r_.__value_.__l.__data_;
                    *((void *)v207 + 2) = *((void *)&v204->__r_.__value_.__l + 2);
                    *((void *)v207 + 3) = 0;
                    uint64_t v209 = v207 + 24;
                    *((void *)v207 + 4) = 0;
                    int v210 = v207 + 32;
                    *(_OWORD *)uint64_t v207 = v208;
                    *((void *)v207 + 5) = 0;
                    unsigned int v211 = v207 + 40;
                    uint64_t v212 = *v205;
                    uint64_t v213 = (char *)*v206;
                    int64_t v214 = (unsigned char *)*v206 - (unsigned char *)*v205;
                    if (*v206 != *v205)
                    {
                      unint64_t v215 = 0x8E38E38E38E38E39 * (v214 >> 3);
                      if (v215 > 0x38E38E38E38E38ELL) {
LABEL_1276:
                      }
                        abort();
                      uint64_t v216 = (char *)operator new(v214);
                      uint64_t v217 = 0;
                      *uint64_t v209 = v216;
                      *int v210 = v216;
                      *unsigned int v211 = &v216[72 * v215];
                      do
                      {
                        uint64_t v218 = sub_1CD76248C((uint64_t)&v216[v217], &v212[v217]);
                        long long v219 = *(_OWORD *)&v212[v217 + 48];
                        *(unsigned char *)(v218 + 64) = v212[v217 + 64];
                        *(_OWORD *)(v218 + 48) = v219;
                        v217 += 72;
                      }
                      while (&v212[v217] != v213);
                      *int v210 = &v216[v217];
                    }
                    LODWORD(v766) = v766 + 1;
                    int v33 = 6;
                    uint64_t v201 = (void **)v795;
                    if (!v795) {
                      goto LABEL_337;
                    }
                  }
                  else
                  {
                    int v33 = 0;
                    if (!v795) {
                      goto LABEL_337;
                    }
                  }
                  uint64_t v220 = v796;
                  uint64_t v221 = v201;
                  if (v796 != v201)
                  {
                    do
                      uint64_t v220 = sub_1CB904DFC(v220 - 9);
                    while (v220 != v201);
                    uint64_t v221 = v795;
                  }
                  v796 = v201;
                  operator delete(v221);
                  goto LABEL_337;
                }
                sub_1CD76248C((uint64_t)&v768, v70);
                *(void *)&v801[24] = 0;
                v801[32] = 0;
                *(_OWORD *)__b = 0u;
                long long v800 = 0u;
                *(_OWORD *)v801 = 0u;
                if (v768.__r_.__value_.__r.__words[2] == v768.__r_.__value_.__l.__size_) {
                  goto LABEL_188;
                }
                uint64_t v72 = (void *)(v768.__r_.__value_.__l.__size_ + 8 * (v770 >> 9));
                unsigned int v73 = (void **)(*v72 + 8 * (v770 & 0x1FF));
                uint64_t v74 = *(void *)(v768.__r_.__value_.__l.__size_ + (((v771 + v770) >> 6) & 0x3FFFFFFFFFFFFF8))
                    + 8 * ((v771 + v770) & 0x1FF);
                if (v73 == (void **)v74) {
                  goto LABEL_188;
                }
                uint64_t v75 = *(void *)(*(void *)(v768.__r_.__value_.__l.__size_
                                            + (((v771 + v770 - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                                + 8 * ((v771 + v770 - 1) & 0x1FF));
                do
                {
                  v759 = 0;
                  uint64_t v76 = *v73;
                  v759 = *v73;
                  if (v724)
                  {
                    unsigned int v77 = ((v76 >> 4) ^ (v76 >> 9)) & (v724 - 1);
                    uint64_t v78 = *(void **)(v723 + 16 * v77);
                    if (v76 == v78)
                    {
LABEL_161:
                      __int16 v79 = sub_1CD467E2C((uint64_t)&v723, (uint64_t *)&v759);
                      uint64_t v80 = sub_1CBF73380(v79[1], v75);
                      if (v80) {
                        BOOL v81 = *(unsigned char *)(v80 + 16) == 16;
                      }
                      else {
                        BOOL v81 = 0;
                      }
                      if (v81)
                      {
                        uint64_t v83 = (void *)(v80 + 24);
                        if (*(_DWORD *)(v80 + 32) >= 0x41u) {
                          uint64_t v83 = (void *)*v83;
                        }
                        uint64_t v84 = (void *)*v83;
                        v801[32] = 1;
                        *(void *)&v801[16] = v84;
                        *(void *)&v801[24] = v76;
                        sub_1CD762554(__b, &v768);
                      }
                    }
                    else
                    {
                      int v85 = 1;
                      while (v78 != (void *)-4096)
                      {
                        unsigned int v86 = v77 + v85++;
                        unsigned int v77 = v86 & (v724 - 1);
                        uint64_t v78 = *(void **)(v723 + 16 * v77);
                        if (v76 == v78) {
                          goto LABEL_161;
                        }
                      }
                    }
                  }
                  if (v801[32]
                    && v76 == *(void **)(*(void *)(v768.__r_.__value_.__l.__size_ + ((v770 >> 6) & 0x3FFFFFFFFFFFFF8))
                                       + 8 * (v770 & 0x1FF)))
                  {
                    goto LABEL_179;
                  }
                  if ((void **)((char *)++v73 - *v72) == (void **)4096)
                  {
                    uint64_t v82 = (void **)v72[1];
                    ++v72;
                    unsigned int v73 = v82;
                  }
                  uint64_t v75 = (uint64_t)v76;
                }
                while (v73 != (void **)v74);
                if (!v801[32]) {
                  goto LABEL_188;
                }
LABEL_179:
                int v87 = *(_DWORD *)(v794.__r_.__value_.__r.__words[0] + 20);
                if ((v87 & 0x40000000) != 0) {
                  int v88 = *(uint64_t **)(v794.__r_.__value_.__r.__words[0] - 8);
                }
                else {
                  int v88 = (uint64_t *)(v794.__r_.__value_.__r.__words[0] - 32 * (v87 & 0x7FFFFFF));
                }
                uint64_t v89 = *v88;
                if (v89) {
                  BOOL v90 = *(unsigned __int8 *)(v89 + 16) >= 0x1Cu;
                }
                else {
                  BOOL v90 = 0;
                }
                if (!v90
                  || (uint64_t v91 = *(void *)(v89 + 40),
                      uint64_t v92 = *(void *)(v794.__r_.__value_.__r.__words[0] + 40),
                      v746.__r_.__value_.__r.__words[0] = *(void *)&v801[24],
                      v92 != *(void *)(*(void *)((char *)__b[1] + ((*(void *)v801 >> 6) & 0x3FFFFFFFFFFFFF8))
                                       + 8 * (*(_WORD *)v801 & 0x1FF))))
                {
LABEL_188:
                  sub_1CB904DFC(__b);
                  sub_1CB904DFC((void **)&v768.__r_.__value_.__l.__data_);
                  v70 += 6;
                  continue;
                }
                break;
              }
              uint64_t v712 = v91;
              sub_1CD76248C((uint64_t)&v759, __b);
              unint64_t v93 = v763;
              int v94 = (char *)__src;
              uint64_t v95 = (char *)v761;
              int v96 = (char *)__src + 8 * (v763 >> 9);
              if ((void *)v761 == __src)
              {
                uint64_t v97 = 0;
                int v100 = 0;
                uint64_t v98 = v764;
                uint64_t v99 = (void **)((char *)__src + 8 * ((v764 + v763) >> 9));
              }
              else
              {
                uint64_t v97 = (void *)(*v96 + 8 * (v763 & 0x1FF));
                uint64_t v98 = v764;
                uint64_t v99 = (void **)((char *)__src + 8 * ((v764 + v763) >> 9));
                int v100 = &(*v99)[(v764 + v763) & 0x1FF];
              }
              BOOL v101 = (char *)sub_1CCD43998((void *)__src + (v763 >> 9), v97, v99, v100, &v746);
              if (v95 == v94)
              {
                unint64_t v103 = 0;
                uint64_t v106 = 0;
                int v105 = &v94[8 * ((v98 + v93) >> 9)];
              }
              else
              {
                unint64_t v103 = (char *)(*v96 + 8 * (v93 & 0x1FF));
                __int16 v104 = v98 + v93;
                int v105 = &v94[8 * ((v98 + v93) >> 9)];
                uint64_t v106 = (char *)(*(void *)v105 + 8 * (v104 & 0x1FF));
              }
              if (v103 != v102 && v102 != v106)
              {
                uint64_t v107 = (uint64_t)&v103[-*v96];
                uint64_t v108 = v107 >> 3;
                if (v107 < -7)
                {
                  uint64_t v112 = 1021 - v108;
                  if (v108 <= 510) {
                    uint64_t v112 = 510 - v108;
                  }
                  uint64_t v109 = (char *)&v96[-(v112 >> 9)];
                  uint64_t v110 = *(void *)v109;
                  if (v108 - 510 >= 0) {
                    uint64_t v113 = -((v108 - 510) & 0x1FF);
                  }
                  else {
                    uint64_t v113 = (510 - (_WORD)v108) & 0x1FF;
                  }
                  uint64_t v111 = 511 - v113;
                }
                else
                {
                  uint64_t v109 = (char *)&v96[(unint64_t)(v108 + 1) >> 9];
                  uint64_t v110 = *(void *)v109;
                  uint64_t v111 = (v108 + 1) & 0x1FF;
                }
                if ((char *)(v110 + 8 * v111) == v102)
                {
                  uint64_t v118 = *(void **)v103;
                  long long __p = v96;
                  int v729 = (void **)v103;
                  v792[0] = &__p;
                  if (v109 != v105)
                  {
                    sub_1CC08F37C((void ****)v792, v102, (unsigned char *)(v110 + 4096));
                    for (uint64_t i = v109 + 8; i != v105; i += 8)
                    {
                      unsigned int v120 = *(unsigned char **)i;
                      sub_1CC08F37C((void ****)v792, v120, v120 + 4096);
                    }
                    int v102 = *(char **)v105;
                  }
                  sub_1CC08F37C((void ****)v792, v102, v106);
                  *int v729 = v118;
                }
                else
                {
                  uint64_t v114 = (uint64_t)&v102[-*(void *)v101];
                  uint64_t v115 = v114 >> 3;
                  if (v114 < -7)
                  {
                    uint64_t v121 = 1021 - v115;
                    if (v115 <= 510) {
                      uint64_t v121 = 510 - v115;
                    }
                    uint64_t v116 = *(void *)&v101[-8 * (v121 >> 9)];
                    if (v115 - 510 >= 0) {
                      uint64_t v122 = -((v115 - 510) & 0x1FF);
                    }
                    else {
                      uint64_t v122 = (510 - (_WORD)v115) & 0x1FF;
                    }
                    uint64_t v117 = 511 - v122;
                  }
                  else
                  {
                    uint64_t v116 = *(void *)&v101[((unint64_t)(v115 + 1) >> 6) & 0x3FFFFFFFFFFFFF8];
                    uint64_t v117 = (v115 + 1) & 0x1FF;
                  }
                  if ((char *)(v116 + 8 * v117) == v106)
                  {
                    uint64_t v134 = (uint64_t)&v106[-*(void *)v105];
                    uint64_t v135 = v134 >> 3;
                    if (v134 < 9)
                    {
                      BOOL v310 = v135 > 512;
                      uint64_t v140 = 512 - v135;
                      uint64_t v141 = 1023 - v135;
                      if (!v310) {
                        uint64_t v141 = v140;
                      }
                      uint64_t v137 = (char **)&v105[-8 * (v141 >> 9)];
                      uint64_t v138 = *v137;
                      uint64_t v142 = v140 & 0x1FF;
                      uint64_t v144 = -v140;
                      BOOL v143 = v144 < 0;
                      uint64_t v145 = v144 & 0x1FF;
                      if (!v143) {
                        uint64_t v142 = -v145;
                      }
                      unint64_t v139 = 511 - v142;
                    }
                    else
                    {
                      unint64_t v136 = v135 - 1;
                      uint64_t v137 = (char **)&v105[8 * (v136 >> 9)];
                      uint64_t v138 = *v137;
                      unint64_t v139 = v136 & 0x1FF;
                    }
                    uint64_t v146 = &v138[8 * v139];
                    uint64_t v147 = *(void *)v146;
                    if (v137 == v96)
                    {
                      sub_1CC08ECDC(&__p, v103, v146, v105, v106);
                    }
                    else
                    {
                      uint64_t v706 = *(void *)v146;
                      sub_1CC08ECDC(&__p, v138, v146, v105, v106);
                      int v148 = v729;
                      uint64_t v149 = v730;
                      int v150 = v137 - 1;
                      if (v137 - 1 != v96)
                      {
                        uint64_t v151 = *v729;
                        do
                        {
                          uint64_t v152 = *v150;
                          char v153 = *v150 + 4096;
                          while (1)
                          {
                            uint64_t v154 = (char *)v149 - v151;
                            if ((v153 - v152) >> 3 >= v154 >> 3) {
                              uint64_t v155 = v154 >> 3;
                            }
                            else {
                              uint64_t v155 = (v153 - v152) >> 3;
                            }
                            v153 -= 8 * v155;
                            v149 -= v155;
                            if (v155) {
                              memmove(v149, v153, 8 * v155);
                            }
                            if (v153 == v152) {
                              break;
                            }
                            uint64_t v156 = (char *)*--v148;
                            uint64_t v151 = v156;
                            uint64_t v149 = (void **)(v156 + 4096);
                          }
                          uint64_t v151 = *v148;
                          if ((char *)*v148 + 4096 == (char *)v149)
                          {
                            int v157 = (char *)v148[1];
                            ++v148;
                            uint64_t v151 = v157;
                            uint64_t v149 = (void **)v157;
                          }
                          --v150;
                        }
                        while (v150 != v96);
                      }
                      sub_1CC08ECDC(&__p, v103, (char *)(*v96 + 4096), v148, (char *)v149);
                      uint64_t v147 = v706;
                    }
                    *(void *)unint64_t v103 = v147;
                  }
                  else
                  {
                    uint64_t v123 = v115 - v108 + ((v101 - (char *)v96) << 6);
                    uint64_t v124 = ((v105 - v101) << 6) - v115 + ((uint64_t)&v106[-*(void *)v105] >> 3);
                    uint64_t v125 = v123;
                    if (v123 == v124)
                    {
                      unsigned int v126 = v102;
                      do
                      {
                        uint64_t v127 = *(void **)v103;
                        *(void *)unint64_t v103 = *(void *)v126;
                        v103 += 8;
                        *(void *)unsigned int v126 = v127;
                        if (&v103[-*v96] == (char *)4096)
                        {
                          unsigned int v128 = (char *)v96[1];
                          ++v96;
                          unint64_t v103 = v128;
                        }
                        v126 += 8;
                        if (&v126[-*(void *)v101] == (char *)4096)
                        {
                          uint64_t v129 = (char *)*((void *)v101 + 1);
                          v101 += 8;
                          unsigned int v126 = v129;
                        }
                      }
                      while (v103 != v102 && v126 != v106);
                      goto LABEL_261;
                    }
                    do
                    {
                      uint64_t v131 = v125;
                      uint64_t v125 = v124;
                      uint64_t v124 = v131 % v124;
                    }
                    while (v124);
                    if (v125)
                    {
                      uint64_t v132 = v125 + v108;
                      if (v132 < 1)
                      {
                        unint64_t v183 = 511 - v132;
                        LOWORD(v132) = ~(511 - v132);
                        int v133 = (char *)&v96[-(v183 >> 9)];
                      }
                      else
                      {
                        int v133 = (char *)&v96[(unint64_t)v132 >> 9];
                      }
                      uint64_t v184 = *(void *)v133 + 8 * (v132 & 0x1FF);
LABEL_295:
                      if ((char *)v184 != v103)
                      {
                        uint64_t v185 = *(void *)v133;
                        if (v184 == *(void *)v133)
                        {
                          uint64_t v186 = *((void *)v133 - 1);
                          v133 -= 8;
                          uint64_t v185 = v186;
                          uint64_t v184 = v186 + 4096;
                        }
                        uint64_t v188 = *(void *)(v184 - 8);
                        v184 -= 8;
                        uint64_t v187 = v188;
                        unint64_t v189 = (char *)v184;
                        uint64_t v190 = v133;
                        if (v123)
                        {
                          uint64_t v191 = v123 + ((v184 - v185) >> 3);
                          if (v191 < 1)
                          {
                            unint64_t v192 = 511 - v191;
                            LOWORD(v191) = ~(511 - v191);
                            uint64_t v190 = &v133[-8 * (v192 >> 9)];
                          }
                          else
                          {
                            uint64_t v190 = &v133[8 * ((unint64_t)v191 >> 9)];
                          }
                          unint64_t v189 = (char *)(*(void *)v190 + 8 * (v191 & 0x1FF));
                        }
                        uint64_t v193 = (void *)v184;
                        while (1)
                        {
                          int v194 = v189;
                          *uint64_t v193 = *(void *)v189;
                          if (v189 == v106) {
                            uint64_t v195 = 0;
                          }
                          else {
                            uint64_t v195 = ((uint64_t)&v106[-*(void *)v105] >> 3)
                          }
                                 + ((v105 - v190) << 6)
                                 - ((uint64_t)&v189[-*(void *)v190] >> 3);
                          uint64_t v197 = v123 - v195;
                          BOOL v196 = v123 == v195;
                          if (v123 >= v195)
                          {
                            unint64_t v189 = v103;
                            uint64_t v190 = (char *)v96;
                            if (!v196)
                            {
                              uint64_t v198 = v197 + ((uint64_t)&v103[-*v96] >> 3);
                              if (v198 < 1)
                              {
                                unint64_t v200 = 511 - v198;
                                LOWORD(v198) = ~(511 - v198);
                                uint64_t v190 = (char *)&v96[-(v200 >> 9)];
                              }
                              else
                              {
                                uint64_t v190 = (char *)&v96[(unint64_t)v198 >> 9];
                              }
                              goto LABEL_317;
                            }
                          }
                          else if (v123)
                          {
                            uint64_t v198 = v123 + ((uint64_t)&v194[-*(void *)v190] >> 3);
                            if (v198 >= 1)
                            {
                              v190 += 8 * ((unint64_t)v198 >> 9);
LABEL_317:
                              unint64_t v189 = (char *)(*(void *)v190 + 8 * (v198 & 0x1FF));
                              goto LABEL_318;
                            }
                            unint64_t v199 = 511 - v198;
                            v190 -= 8 * (v199 >> 9);
                            unint64_t v189 = (char *)(*(void *)v190 + 8 * (~(_WORD)v199 & 0x1FF));
                          }
                          else
                          {
                            unint64_t v189 = v194;
                          }
LABEL_318:
                          uint64_t v193 = v194;
                          if (v189 == (char *)v184)
                          {
                            *(void *)int v194 = v187;
                            goto LABEL_295;
                          }
                        }
                      }
                    }
                  }
                }
              }
LABEL_261:
              if ((void *)v761 == __src
                || (unsigned int v158 = (char **)((char *)__src + 8 * (v763 >> 9)),
                    uint64_t v159 = *v158,
                    unint64_t v160 = &(*v158)[8 * (v763 & 0x1FF)],
                    uint64_t v161 = *(void *)((char *)__src + (((v764 + v763) >> 6) & 0x3FFFFFFFFFFFFF8))
                         + 8 * ((v764 + v763) & 0x1FF),
                    v160 == (char *)v161))
              {
LABEL_270:
                sub_1CB904DFC(&v759);
                if ((unint64_t)v796 >= v797)
                {
                  unint64_t v169 = 0x8E38E38E38E38E39 * (((char *)v796 - (unsigned char *)v795) >> 3);
                  unint64_t v170 = v169 + 1;
                  if (v169 + 1 > 0x38E38E38E38E38ELL) {
                    goto LABEL_1276;
                  }
                  if (0x1C71C71C71C71C72 * ((uint64_t)(v797 - (void)v795) >> 3) > v170) {
                    unint64_t v170 = 0x1C71C71C71C71C72 * ((uint64_t)(v797 - (void)v795) >> 3);
                  }
                  if (0x8E38E38E38E38E39 * ((uint64_t)(v797 - (void)v795) >> 3) >= 0x1C71C71C71C71C7) {
                    unint64_t v171 = 0x38E38E38E38E38ELL;
                  }
                  else {
                    unint64_t v171 = v170;
                  }
                  if (v171)
                  {
                    if (v171 > 0x38E38E38E38E38ELL) {
LABEL_1277:
                    }
                      sub_1CB833614();
                    uint64_t v172 = (char *)operator new(72 * v171);
                  }
                  else
                  {
                    uint64_t v172 = 0;
                  }
                  int v173 = &v172[72 * v171];
                  uint64_t v174 = sub_1CD76248C((uint64_t)&v172[72 * v169], __b);
                  *(_OWORD *)(v174 + 48) = *(_OWORD *)&v801[16];
                  *(unsigned char *)(v174 + 64) = v801[32];
                  uint64_t v168 = (void **)(v174 + 72);
                  uint64_t v175 = v796;
                  uint64_t v176 = (void **)v795;
                  if (v796 == v795)
                  {
                    v795 = (void *)v174;
                    v796 = (void **)(v174 + 72);
                    unint64_t v797 = (unint64_t)v173;
                  }
                  else
                  {
                    uint64_t v177 = 0;
                    do
                    {
                      uint64_t v178 = v174 + v177 * 8;
                      uint64_t v179 = &v175[v177];
                      *(void *)(v178 - 72) = v175[v177 - 9];
                      *(void *)(v178 - 64) = v175[v177 - 8];
                      *(void *)(v178 - 56) = v175[v177 - 7];
                      *(void *)(v178 - 48) = v175[v177 - 6];
                      *(_OWORD *)(v179 - 7) = 0uLL;
                      unint64_t v180 = v175[v177 - 5];
                      *(_OWORD *)(v179 - 9) = 0uLL;
                      *(void *)(v178 - 40) = v180;
                      *(void *)(v178 - 32) = v175[v177 - 4];
                      *(v179 - 5) = 0;
                      *(v179 - 4) = 0;
                      long long v181 = *(_OWORD *)&v175[v177 - 3];
                      *(unsigned char *)(v178 - 8) = v175[v177 - 1];
                      *(_OWORD *)(v178 - 24) = v181;
                      v177 -= 9;
                    }
                    while (&v175[v177] != v176);
                    uint64_t v175 = (void **)v795;
                    uint64_t v182 = v796;
                    v795 = (void *)(v174 + v177 * 8);
                    v796 = (void **)(v174 + 72);
                    unint64_t v797 = (unint64_t)v173;
                    while (v182 != v175)
                    {
                      v182 -= 9;
                      sub_1CB904DFC(v182);
                    }
                  }
                  if (v175) {
                    operator delete(v175);
                  }
                }
                else
                {
                  uint64_t v166 = sub_1CD76248C((uint64_t)v796, __b);
                  long long v167 = *(_OWORD *)&v801[16];
                  *(unsigned char *)(v166 + 64) = v801[32];
                  *(_OWORD *)(v166 + 48) = v167;
                  uint64_t v168 = (void **)(v166 + 72);
                }
                v796 = v168;
              }
              else
              {
                char v162 = 0;
                char v163 = 0;
                int v164 = 0;
                while (1)
                {
                  v164 |= *(void *)v160 == v746.__r_.__value_.__r.__words[0];
                  v163 |= *(void *)v160 == v712;
                  v162 |= *(void *)v160 == v92;
                  if ((v164 & 1) != 0 && (v162 & 1) != 0 && (v163 & 1) == 0) {
                    break;
                  }
                  v160 += 8;
                  if (v160 - v159 == 4096)
                  {
                    int v165 = v158[1];
                    ++v158;
                    uint64_t v159 = v165;
                    unint64_t v160 = v165;
                  }
                  if (v160 == (char *)v161) {
                    goto LABEL_270;
                  }
                }
                sub_1CB904DFC(&v759);
              }
              goto LABEL_188;
            }
LABEL_76:
            unsigned int v43 = v800;
            if (DWORD1(v800) < v800)
            {
              ++DWORD1(v800);
              *((void *)__b[1] + v39) = v37;
              goto LABEL_100;
            }
          }
          else
          {
            unsigned int v43 = v800;
          }
          break;
        }
        if (3 * v43 <= 4 * (DWORD1(v800) - DWORD2(v800)))
        {
          if (v43 >= 0x40) {
            v43 *= 2;
          }
          else {
            unsigned int v43 = 128;
          }
        }
        else if (v43 - DWORD1(v800) >= v43 >> 3)
        {
          goto LABEL_81;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)__b, v43);
        unsigned int v43 = v800;
        uint64_t v38 = (char *)__b[1];
LABEL_81:
        unsigned int v44 = v43 - 1;
        unsigned int v45 = (v43 - 1) & ((v37 >> 4) ^ (v37 >> 9));
        uint64_t v46 = &v38[8 * v45];
        uint64_t v47 = *(void *)v46;
        if (*(void *)v46 == -1)
        {
          int v48 = 0;
LABEL_93:
          if (v48) {
            int v52 = v48;
          }
          else {
            int v52 = v46;
          }
          if (*(void *)v52 != v37)
          {
            if (*(void *)v52 == -2) {
              --DWORD2(v800);
            }
            else {
              ++DWORD1(v800);
            }
            *(void *)int v52 = v37;
          }
        }
        else
        {
          int v48 = 0;
          int v49 = 1;
          while (v47 != v37)
          {
            if (v48) {
              BOOL v50 = 0;
            }
            else {
              BOOL v50 = v47 == -2;
            }
            if (v50) {
              int v48 = v46;
            }
            unsigned int v51 = v45 + v49++;
            unsigned int v45 = v51 & v44;
            uint64_t v46 = &v38[8 * (v51 & v44)];
            uint64_t v47 = *(void *)v46;
            if (*(void *)v46 == -1) {
              goto LABEL_93;
            }
          }
        }
        goto LABEL_100;
      }
      v748.i64[0] = v11;
      if (v11) {
        goto LABEL_37;
      }
LABEL_62:
      int v33 = 7;
LABEL_337:
      v747 = (uint64_t *)&unk_1F263DA98;
      if ((long long *)v748.i64[1] != (long long *)((char *)&v749 + 8)) {
        free((void *)v748.i64[1]);
      }
      if (v33 == 7)
      {
        unint64_t v4 = v698;
        int v5 = v703;
        long long v6 = 0uLL;
      }
      else
      {
        unint64_t v4 = v698;
        int v5 = v703;
        long long v6 = 0uLL;
        if (v33) {
          goto LABEL_597;
        }
      }
LABEL_343:
      int v5 = (char *)*((void *)v5 + 1);
      if (v5 == v4)
      {
LABEL_597:
        v759 = &v763;
        __src = &v763;
        uint64_t v761 = 32;
        int v762 = 0;
        if (v766)
        {
          llvm::CodeMetrics::collectEphemeralValues(v696, *(llvm::AssumptionCache **)a1, (llvm::SmallPtrSetImplBase *)&v759);
          char v325 = v702;
          if (!v766) {
            goto LABEL_1267;
          }
          uint64_t v326 = v765;
          long long v695 = (char *)v765 + 48 * v766;
          while (1)
          {
            long long v327 = *(_OWORD *)v326;
            uint64_t v724 = v326[2];
            long long v723 = v327;
            v726 = 0;
            v727 = 0;
            unsigned int v725 = 0;
            uint64_t v328 = v326[3];
            uint64_t v329 = v326[4];
            v700 = v326;
            int64_t v330 = v329 - v328;
            if (v329 != v328)
            {
              unint64_t v331 = 0x8E38E38E38E38E39 * (v330 >> 3);
              if (v331 > 0x38E38E38E38E38ELL) {
                goto LABEL_1276;
              }
              uint64_t v332 = (char *)operator new(v330);
              uint64_t v333 = 0;
              unsigned int v725 = v332;
              v726 = (void **)v332;
              v727 = &v332[72 * v331];
              do
              {
                uint64_t v334 = sub_1CD76248C((uint64_t)&v332[v333], (void *)(v328 + v333));
                long long v335 = *(_OWORD *)(v328 + v333 + 48);
                *(unsigned char *)(v334 + 64) = *(unsigned char *)(v328 + v333 + 64);
                *(_OWORD *)(v334 + 48) = v335;
                v333 += 72;
              }
              while (v328 + v333 != v329);
              v726 = (void **)&v332[v333];
            }
            int8x16_t v336 = *(int8x16_t *)a1;
            long long v337 = *(_OWORD *)(a1 + 16);
            unint64_t v338 = __src;
            if (__src == v759)
            {
              char v718 = v722;
              unsigned int v339 = v722;
              uint64_t v340 = __src;
              unsigned int v341 = v755;
            }
            else
            {
              int8x16_t v711 = *(int8x16_t *)a1;
              *(_OWORD *)uint64_t v717 = *(_OWORD *)(a1 + 16);
              int v665 = v761;
              unsigned int v339 = malloc_type_malloc(8 * v761, 0x4065EBACuLL);
              if (!v339 && (v665 || (unsigned int v339 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0))
              {
LABEL_1282:
                long long v694 = "Allocation failed";
LABEL_1283:
                llvm::report_bad_alloc_error((llvm *)v694, (const char *)1);
              }
              char v718 = v339;
              uint64_t v340 = v759;
              unint64_t v338 = __src;
              unsigned int v341 = v755;
              int8x16_t v336 = v711;
              long long v337 = *(_OWORD *)v717;
            }
            unsigned int v342 = HIDWORD(v761);
            unsigned int v719 = v761;
            if (v338 == v340) {
              unsigned int v343 = HIDWORD(v761);
            }
            else {
              unsigned int v343 = v761;
            }
            if (v343)
            {
              int8x16_t v707 = v336;
              *(_OWORD *)uint64_t v713 = v337;
              memmove(v339, v338, 8 * v343);
              int8x16_t v336 = v707;
              long long v337 = *(_OWORD *)v713;
              unsigned int v341 = v755;
              unsigned int v342 = HIDWORD(v761);
              unsigned int v339 = v718;
            }
            unsigned int v720 = v342;
            int v721 = v762;
            int8x16_t v748 = vextq_s8(v336, v336, 8uLL);
            long long v749 = v337;
            v747 = (uint64_t *)&v723;
            v750 = v755;
            if (v339 == v722)
            {
              v751 = v755;
              unint64_t v344 = v339;
            }
            else
            {
              unsigned int v341 = malloc_type_malloc(8 * v719, 0x4065EBACuLL);
              if (!v341)
              {
                if (v719) {
                  goto LABEL_1282;
                }
                unsigned int v341 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
                if (!v341) {
                  goto LABEL_1282;
                }
              }
              v751 = v341;
              unint64_t v344 = v722;
              unsigned int v339 = v718;
              unsigned int v342 = v720;
            }
            unsigned int v345 = v719;
            unsigned int v752 = v719;
            if (v339 == v344) {
              unsigned int v345 = v342;
            }
            if (v345)
            {
              memmove(v341, v339, 8 * v345);
              unsigned int v342 = v720;
              unint64_t v344 = v722;
              unsigned int v339 = v718;
            }
            unsigned int v753 = v342;
            int v754 = v721;
            v757 = 0;
            uint64_t v758 = 0;
            v756 = 0;
            if (v339 != v344) {
              free(v339);
            }
            BYTE4(__p) = 0;
            LODWORD(__p) = 0;
            uint64_t v730 = 0;
            uint64_t v731 = 0;
            int v729 = 0;
            LODWORD(v732) = 0;
            uint64_t v733 = 0;
            uint64_t v734 = 0;
            uint64_t v708 = *v747;
            v736 = 0;
            v735 = 0;
            int v737 = 0;
            uint64_t v347 = v747[3];
            uint64_t v346 = v747[4];
            for (uint64_t j = v346; ; v346 = j)
            {
              if (v347 == v346)
              {
                LODWORD(v746.__r_.__value_.__l.__data_) = 0;
                (*(void (**)(void, uint64_t, std::string *, void, void))(**(void **)v749 + 64))(*(void *)v749, v708, &v746, 0, 0);
                unsigned int data = v746.__r_.__value_.__l.__data_;
                if (!LODWORD(v746.__r_.__value_.__l.__data_))
                {
                  int v390 = (void *)(((unint64_t)*(unsigned int *)(v708 + 20) >> 1) & 0x3FFFFFF);
                  LODWORD(__b[1]) = 32;
                  __b[0] = v390;
                  unsigned int data = sub_1CC1755AC((uint64_t)__b);
                  if (LODWORD(__b[1]) >= 0x41)
                  {
                    if (__b[0]) {
                      MEMORY[0x1D25D9CB0](__b[0], 0x1000C8000313F17);
                    }
                  }
                }
                unsigned int v391 = v729 / data;
                unsigned int v392 = dword_1EBCF1790;
                unsigned int v393 = (uint64_t ***)*((void *)&v749 + 1);
                uint64_t v394 = *****((void *****)&v749 + 1);
                if (*(void *)(v394 + 128))
                {
                  if (v391 <= dword_1EBCF1790) {
                    goto LABEL_1231;
                  }
LABEL_685:
                  llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)__b, (uint64_t)"dfa-jump-threading", (uint64_t)"NotProfitable", 13, v708);
                  v768.__r_.__value_.__r.__words[0] = (std::string::size_type)"Duplication cost exceeds the cost threshold (cost=";
                  v768.__r_.__value_.__l.__size_ = 50;
                  sub_1CC59ADEC((uint64_t *)&v803, (uint64_t)&v768);
                  llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v768, "Cost", 4uLL, v391);
                  uint64_t v396 = sub_1CD3D6290((uint64_t)__b, (long long *)&v768);
                  v794.__r_.__value_.__r.__words[0] = (std::string::size_type)", threshold=";
                  v794.__r_.__value_.__l.__size_ = 12;
                  sub_1CC59ADEC((uint64_t *)(v396 + 80), (uint64_t)&v794);
                  llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v794, "Threshold", 9uLL, dword_1EBCF1790);
                  uint64_t v397 = sub_1CD3D6290(v396, (long long *)&v794);
                  v792[0] = ").";
                  v792[1] = (void *)2;
                  sub_1CC59ADEC((uint64_t *)(v397 + 80), (uint64_t)v792);
                  int v398 = *(_DWORD *)(v397 + 8);
                  BYTE4(v772[1]) = *(unsigned char *)(v397 + 12);
                  LODWORD(v772[1]) = v398;
                  long long v399 = *(_OWORD *)(v397 + 16);
                  *(void *)v774 = *(void *)(v397 + 32);
                  long long v773 = v399;
                  uint64_t v400 = *(void *)(v397 + 72);
                  long long v401 = *(_OWORD *)(v397 + 56);
                  *(_OWORD *)&v774[8] = *(_OWORD *)(v397 + 40);
                  long long v775 = v401;
                  uint64_t v776 = v400;
                  v772[0] = &unk_1F2616800;
                  v777 = v779;
                  uint64_t v778 = 0x400000000;
                  if (*(_DWORD *)(v397 + 88)) {
                    sub_1CD494D68((uint64_t)&v777, v397 + 80);
                  }
                  uint64_t v402 = *(void *)(v397 + 360);
                  uint64_t v786 = *(void *)(v397 + 352);
                  uint64_t v787 = v402;
                  v772[0] = &unk_1F26165A8;
                  if (SHIBYTE(v797) < 0) {
                    operator delete(v795);
                  }
                  if (SHIBYTE(v794.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v794.__r_.__value_.__l.__data_);
                  }
                  if (SHIBYTE(v771) < 0) {
                    operator delete(v769);
                  }
                  if (SHIBYTE(v768.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v768.__r_.__value_.__l.__data_);
                  }
                  __b[0] = &unk_1F2616800;
                  uint64_t v403 = (char *)v803;
                  if (v804)
                  {
                    unint64_t v404 = (unint64_t)v804 << 6;
                    do
                    {
                      uint64_t v405 = (void **)&v403[v404];
                      if (v403[v404 - 17] < 0) {
                        operator delete(*(v405 - 5));
                      }
                      if (*((char *)v405 - 41) < 0) {
                        operator delete(*(v405 - 8));
                      }
                      v404 -= 64;
                    }
                    while (v404);
                    uint64_t v403 = (char *)v803;
                  }
                  if (v403 != (char *)v805) {
                    free(v403);
                  }
                  llvm::OptimizationRemarkEmitter::emit(v393, (llvm::DiagnosticInfoOptimizationBase *)v772);
                  v772[0] = &unk_1F2616800;
                  int v666 = (char *)v777;
                  if (v778)
                  {
                    unint64_t v667 = (unint64_t)v778 << 6;
                    do
                    {
                      int v668 = (void **)&v666[v667];
                      if (v666[v667 - 17] < 0) {
                        operator delete(*(v668 - 5));
                      }
                      if (*((char *)v668 - 41) < 0) {
                        operator delete(*(v668 - 8));
                      }
                      v667 -= 64;
                    }
                    while (v667);
                    goto LABEL_1251;
                  }
                }
                else
                {
                  int v395 = (*(uint64_t (**)(void))(**(void **)(v394 + 72) + 48))(*(void *)(v394 + 72));
                  if (v391 > v392)
                  {
                    if (v395) {
                      goto LABEL_685;
                    }
LABEL_704:
                    sub_1CCD43E64((uint64_t *)&v735);
                    unint64_t v313 = MEMORY[0x1D25D9CD0](v730, 8);
                    if (v391 > v392) {
                      goto LABEL_1147;
                    }
                    v772[0] = &v773;
                    v772[1] = (void *)0x1000000000;
                    v779[22] = 0;
                    v779[23] = 0;
                    v779[24] = v748.i64[0];
                    v779[25] = 0;
                    char v780 = 0;
                    v781 = &v785;
                    v782 = &v785;
                    uint64_t v783 = 8;
                    int v784 = 0;
                    uint64_t v789 = 0;
                    uint64_t v790 = 0;
                    uint64_t v788 = 0;
                    __int16 v791 = 0;
                    uint64_t v406 = v747[1];
                    uint64_t v743 = v406;
                    uint64_t v407 = (void *)v747[3];
                    unint64_t v408 = (void *)v747[4];
                    while (v407 != v408)
                    {
                      sub_1CD76248C((uint64_t)__b, v407);
                      sub_1CD45F140(__b, &v743);
                      sub_1CD762554(v407, __b);
                      unint64_t v313 = (unint64_t)sub_1CB904DFC(__b);
                      v407 += 9;
                    }
                    v741[1] = 0;
                    v741[0] = 0;
                    int v742 = 0;
                    v736 = 0;
                    v735 = 0;
                    int v737 = 0;
                    v739 = 0;
                    uint64_t v740 = 0;
                    v738 = 0;
                    v768.__r_.__value_.__r.__words[0] = (std::string::size_type)&v770;
                    v768.__r_.__value_.__l.__size_ = (std::string::size_type)&v770;
                    v768.__r_.__value_.__r.__words[2] = 16;
                    LODWORD(v769) = 0;
                    uint64_t v409 = *(void *)(v406 + 40);
                    if (v409 != v406 + 40)
                    {
                      if (v409) {
                        uint64_t v410 = v409 - 24;
                      }
                      else {
                        uint64_t v410 = 0;
                      }
                      int v411 = *(unsigned __int8 *)(v410 + 16);
                      int v412 = v411 - 29;
                      if (v411 != 30)
                      {
                        unsigned int v440 = 2;
                        switch(v412)
                        {
                          case 1:
LABEL_1278:
                            __break(1u);
                            goto LABEL_1279;
                          case 2:
                            unsigned int v440 = (*(_DWORD *)(v410 + 20) >> 1) & 0x3FFFFFF;
                            goto LABEL_1183;
                          case 3:
                          case 9:
                            unsigned int v440 = (*(_DWORD *)(v410 + 20) & 0x7FFFFFF) - 1;
                            goto LABEL_1183;
                          case 4:
                            goto LABEL_717;
                          case 7:
                            unsigned int v440 = *(_WORD *)(v410 + 18) & 1;
                            goto LABEL_1183;
                          case 8:
                            unsigned int v440 = 1;
                            goto LABEL_717;
                          case 10:
                            unsigned int v440 = *(_DWORD *)(v410 + 80) + 1;
LABEL_1183:
                            if (!v440) {
                              goto LABEL_779;
                            }
                            goto LABEL_717;
                          default:
                            goto LABEL_779;
                        }
                      }
                      if ((*(_DWORD *)(v410 + 20) & 0x7FFFFFF) == 3) {
                        unsigned int v440 = 2;
                      }
                      else {
                        unsigned int v440 = 1;
                      }
LABEL_717:
                      uint64_t v413 = 0;
                      uint64_t v414 = v410 - 32;
                      unsigned int v415 = 16;
                      uint64_t v416 = v440;
                      while (2)
                      {
                        int v417 = *(unsigned __int8 *)(v410 + 16);
                        if (v417 == 30)
                        {
                          uint64_t v434 = (uint64_t *)(v414 - 32 * v413);
                        }
                        else
                        {
                          uint64_t v433 = (v417 - 31);
                          uint64_t v434 = (uint64_t *)(v410 - 32);
                          switch(v433)
                          {
                            case 1:
                            case 7:
                              int v437 = *(_DWORD *)(v410 + 20);
                              if ((v437 & 0x40000000) != 0) {
                                uint64_t v438 = *(void *)(v410 - 8);
                              }
                              else {
                                uint64_t v438 = v410 - 32 * (v437 & 0x7FFFFFF);
                              }
                              uint64_t v434 = (uint64_t *)(v438 + 32 * v413 + 32);
                              break;
                            case 2:
                              uint64_t v439 = -64;
                              if (!v413) {
                                uint64_t v439 = -96;
                              }
                              uint64_t v434 = (uint64_t *)(v410 + v439);
                              break;
                            case 3:
                            case 4:
                              goto LABEL_1278;
                            case 5:
                              if ((*(_WORD *)(v410 + 18) & 1) == 0)
                              {
                                uint64_t v418 = 0;
                                goto LABEL_722;
                              }
                              uint64_t v434 = (uint64_t *)(v410 + 32 - 32 * (*(_DWORD *)(v410 + 20) & 0x7FFFFFF));
                              break;
                            case 6:
                              break;
                            case 8:
                              if (v413) {
                                uint64_t v434 = (uint64_t *)(v414 - 32 * *(unsigned int *)(v410 + 80) + 32 * v413 - 32);
                              }
                              else {
                                uint64_t v434 = (uint64_t *)(v410 - 64 - 32 * *(unsigned int *)(v410 + 80));
                              }
                              break;
                            default:
                              int v435 = *(_DWORD *)(v410 + 20);
                              if ((v435 & 0x40000000) != 0) {
                                uint64_t v436 = *(void *)(v410 - 8);
                              }
                              else {
                                uint64_t v436 = v410 - 32 * (v435 & 0x7FFFFFF);
                              }
                              uint64_t v434 = (uint64_t *)(v436 + 32 * (2 * v413) + 32);
                              break;
                          }
                        }
                        uint64_t v418 = *v434;
LABEL_722:
                        std::string::size_type size = v768.__r_.__value_.__l.__size_;
                        uint64_t v420 = HIDWORD(v768.__r_.__value_.__r.__words[2]);
                        if (v768.__r_.__value_.__l.__size_ == v768.__r_.__value_.__r.__words[0])
                        {
                          if (HIDWORD(v768.__r_.__value_.__r.__words[2]))
                          {
                            BOOL v421 = 0;
                            uint64_t v422 = 8 * HIDWORD(v768.__r_.__value_.__r.__words[2]);
                            v423 = (void *)v768.__r_.__value_.__l.__size_;
                            while (*v423 != v418)
                            {
                              if (*v423 == -2) {
                                BOOL v421 = v423;
                              }
                              ++v423;
                              v422 -= 8;
                              if (!v422)
                              {
                                if (!v421) {
                                  goto LABEL_730;
                                }
                                void *v421 = v418;
                                LODWORD(v769) = v769 - 1;
                                goto LABEL_753;
                              }
                            }
                            goto LABEL_753;
                          }
LABEL_730:
                          if (HIDWORD(v768.__r_.__value_.__r.__words[2]) < v415)
                          {
                            ++HIDWORD(v768.__r_.__value_.__r.__words[2]);
                            *(void *)(v768.__r_.__value_.__l.__size_ + 8 * v420) = v418;
                            goto LABEL_753;
                          }
                        }
                        if (3 * v415 <= 4 * (HIDWORD(v768.__r_.__value_.__r.__words[2]) - (int)v769))
                        {
                          if (v415 >= 0x40) {
                            v415 *= 2;
                          }
                          else {
                            unsigned int v415 = 128;
                          }
                        }
                        else if (v415 - HIDWORD(v768.__r_.__value_.__r.__words[2]) >= v415 >> 3)
                        {
                          goto LABEL_734;
                        }
                        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v768, v415);
                        unsigned int v415 = v768.__r_.__value_.__r.__words[2];
                        std::string::size_type size = v768.__r_.__value_.__l.__size_;
LABEL_734:
                        unsigned int v424 = v415 - 1;
                        unsigned int v425 = (v415 - 1) & ((v418 >> 4) ^ (v418 >> 9));
                        int v426 = (void *)(size + 8 * v425);
                        uint64_t v427 = *v426;
                        if (*v426 == -1)
                        {
                          uint64_t v431 = 0;
LABEL_745:
                          if (v431) {
                            uint64_t v432 = v431;
                          }
                          else {
                            uint64_t v432 = v426;
                          }
                          if (*v432 != v418)
                          {
                            if (*v432 == -2) {
                              LODWORD(v769) = v769 - 1;
                            }
                            else {
                              ++HIDWORD(v768.__r_.__value_.__r.__words[2]);
                            }
                            *uint64_t v432 = v418;
                          }
                        }
                        else
                        {
                          uint64_t v431 = 0;
                          int v428 = 1;
                          while (v427 != v418)
                          {
                            if (v431) {
                              BOOL v429 = 0;
                            }
                            else {
                              BOOL v429 = v427 == -2;
                            }
                            if (v429) {
                              uint64_t v431 = v426;
                            }
                            unsigned int v430 = v425 + v428++;
                            unsigned int v425 = v430 & v424;
                            int v426 = (void *)(size + 8 * (v430 & v424));
                            uint64_t v427 = *v426;
                            if (*v426 == -1) {
                              goto LABEL_745;
                            }
                          }
                        }
LABEL_753:
                        if (++v413 == v416) {
                          break;
                        }
                        continue;
                      }
                    }
LABEL_779:
                    uint64_t v441 = (void *)v747[3];
                    v697 = (void *)v747[4];
                    if (v441 != v697)
                    {
                      while (2)
                      {
                        unint64_t __val = v441[6];
                        uint64_t v745 = v441[7];
                        v699 = v441;
                        sub_1CD76248C((uint64_t)&__p, v441);
                        v442 = v729;
                        unint64_t v443 = v732;
                        if ((*(void **)((char *)v729 + ((v732 >> 6) & 0x3FFFFFFFFFFFFF8)))[v732 & 0x1FF] == v745)
                        {
                          unint64_t v443 = v732 + 1;
                          --v733;
                          unint64_t v732 = v443;
                          if (v443 >= 0x400)
                          {
                            operator delete(*v729);
                            v442 = v729 + 1;
                            unint64_t v443 = v732 - 512;
                            ++v729;
                            v732 -= 512;
                          }
                        }
                        v444 = &v442[v443 >> 9];
                        uint64_t v445 = v730;
                        if (v730 == v442)
                        {
                          uint64_t v446 = 0;
                          uint64_t v449 = 0;
                          uint64_t v448 = &v442[(v733 + v443) >> 9];
                        }
                        else
                        {
                          uint64_t v446 = (char *)*v444 + 8 * (v443 & 0x1FF);
                          unint64_t v447 = v733 + v443;
                          uint64_t v448 = &v442[v447 >> 9];
                          uint64_t v449 = (char *)*v448 + 8 * (v447 & 0x1FF);
                        }
                        v450 = sub_1CCD43998(v444, v446, (void **)v448, v449, &v745);
                        int v451 = v450;
                        unint64_t v453 = v452;
                        uint64_t v454 = (uint64_t)v452 - *v450;
                        uint64_t v455 = v454 >> 3;
                        if (v454 < 9)
                        {
                          BOOL v310 = v455 > 512;
                          uint64_t v457 = 512 - v455;
                          uint64_t v458 = 1023 - v455;
                          if (!v310) {
                            uint64_t v458 = v457;
                          }
                          uint64_t v459 = v450[-(v458 >> 9)];
                          uint64_t v460 = v457 & 0x1FF;
                          uint64_t v461 = -v457;
                          BOOL v143 = v461 < 0;
                          uint64_t v462 = v461 & 0x1FF;
                          if (v143) {
                            uint64_t v463 = v460;
                          }
                          else {
                            uint64_t v463 = -v462;
                          }
                          int v456 = (uint64_t *)(v459 + 8 * (511 - v463));
                        }
                        else
                        {
                          int v456 = (uint64_t *)(*(void *)((char *)v450
                                                       + (((unint64_t)(v455 - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                                           + 8 * ((v455 - 1) & 0x1FF));
                        }
                        for (uint64_t k = *v456; ; uint64_t k = (uint64_t)v483)
                        {
                          uint64_t v465 = v445 == v442
                               ? 0
                               : (uint64_t)(*(char **)((char *)v442 + (((v732 + v733) >> 6) & 0x3FFFFFFFFFFFFF8))
                                         + 8 * ((v732 + v733) & 0x1FF));
                          if (v453 == (unint64_t *)v465) {
                            break;
                          }
                          unint64_t v744 = 0;
                          unint64_t v466 = *v453;
                          unint64_t v744 = *v453;
                          std::string::size_type v467 = v768.__r_.__value_.__l.__size_;
                          uint64_t v468 = HIDWORD(v768.__r_.__value_.__r.__words[2]);
                          if (v768.__r_.__value_.__l.__size_ != v768.__r_.__value_.__r.__words[0])
                          {
                            unsigned int v472 = v768.__r_.__value_.__r.__words[2];
                            goto LABEL_810;
                          }
                          if (!HIDWORD(v768.__r_.__value_.__r.__words[2]))
                          {
LABEL_807:
                            unsigned int v472 = v768.__r_.__value_.__r.__words[2];
                            if (HIDWORD(v768.__r_.__value_.__r.__words[2]) < LODWORD(v768.__r_.__value_.__r.__words[2]))
                            {
                              ++HIDWORD(v768.__r_.__value_.__r.__words[2]);
                              *(void *)(v768.__r_.__value_.__l.__size_ + 8 * v468) = v466;
                              goto LABEL_831;
                            }
LABEL_810:
                            if (3 * v472 <= 4 * (HIDWORD(v768.__r_.__value_.__r.__words[2]) - (int)v769))
                            {
                              if (v472 >= 0x40) {
                                v472 *= 2;
                              }
                              else {
                                unsigned int v472 = 128;
                              }
                            }
                            else if (v472 - HIDWORD(v768.__r_.__value_.__r.__words[2]) >= v472 >> 3)
                            {
                              goto LABEL_812;
                            }
                            uint64_t v494 = v453;
                            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v768, v472);
                            unint64_t v453 = v494;
                            unsigned int v472 = v768.__r_.__value_.__r.__words[2];
                            std::string::size_type v467 = v768.__r_.__value_.__l.__size_;
LABEL_812:
                            unsigned int v473 = v472 - 1;
                            unsigned int v474 = (v472 - 1) & ((v466 >> 4) ^ (v466 >> 9));
                            int v475 = (unint64_t *)(v467 + 8 * v474);
                            unint64_t v476 = *v475;
                            if (*v475 == -1)
                            {
                              BOOL v477 = 0;
LABEL_824:
                              if (v477) {
                                int v481 = v477;
                              }
                              else {
                                int v481 = v475;
                              }
                              if (*v481 != v466)
                              {
                                if (*v481 == -2) {
                                  LODWORD(v769) = v769 - 1;
                                }
                                else {
                                  ++HIDWORD(v768.__r_.__value_.__r.__words[2]);
                                }
                                *int v481 = v466;
                              }
                            }
                            else
                            {
                              BOOL v477 = 0;
                              int v478 = 1;
                              while (v476 != v466)
                              {
                                if (v477) {
                                  BOOL v479 = 0;
                                }
                                else {
                                  BOOL v479 = v476 == -2;
                                }
                                if (v479) {
                                  BOOL v477 = v475;
                                }
                                unsigned int v480 = v474 + v478++;
                                unsigned int v474 = v480 & v473;
                                int v475 = (unint64_t *)(v467 + 8 * (v480 & v473));
                                unint64_t v476 = *v475;
                                if (*v475 == -1) {
                                  goto LABEL_824;
                                }
                              }
                            }
                            goto LABEL_831;
                          }
                          unsigned int v469 = 0;
                          uint64_t v470 = 8 * HIDWORD(v768.__r_.__value_.__r.__words[2]);
                          uint64_t v471 = (unint64_t *)v768.__r_.__value_.__l.__size_;
                          while (*v471 != v466)
                          {
                            if (*v471 == -2) {
                              unsigned int v469 = v471;
                            }
                            ++v471;
                            v470 -= 8;
                            if (!v470)
                            {
                              if (!v469) {
                                goto LABEL_807;
                              }
                              *unsigned int v469 = v466;
                              LODWORD(v769) = v769 - 1;
                              break;
                            }
                          }
LABEL_831:
                          uint64_t v704 = v453;
                          uint64_t v482 = (llvm::BasicBlock *)sub_1CCD43BA4(v466, __val, (uint64_t)v741);
                          if (!v482)
                          {
                            LODWORD(v794.__r_.__value_.__r.__words[2]) = 128;
                            unsigned int v484 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
                            *(_OWORD *)&v794.__r_.__value_.__l.__data_ = (unint64_t)v484;
                            __b[1] = (void *)2;
                            *(void *)&long long v800 = 0;
                            *((void *)&v800 + 1) = -4096;
                            __b[0] = &unk_1F2615EC8;
                            *(void *)v801 = 0;
                            if (LODWORD(v794.__r_.__value_.__r.__words[2]))
                            {
                              uint64_t v485 = 0;
                              unint64_t v486 = (unint64_t)LODWORD(v794.__r_.__value_.__r.__words[2]) << 6;
                              uint64_t v487 = v484 + 16;
                              do
                              {
                                unint64_t v488 = (unint64_t)__b[1];
                                uint64_t v489 = *((void *)&v800 + 1);
                                *(v487 - 1) = (uint64_t)__b[1] & 6;
                                *uint64_t v487 = 0;
                                v487[1] = v489;
                                if (v489 != -4096 && v489 != -8192 && v489 != 0)
                                {
                                  *uint64_t v487 = *(void *)(v488 & 0xFFFFFFFFFFFFFFF8);
                                  *(void *)(v488 & 0xFFFFFFFFFFFFFFF8) = v487 - 1;
                                  *(v487 - 1) = v488 & 0xFFFFFFFFFFFFFFFELL;
                                  if (*v487) {
                                    *(void *)*uint64_t v487 = *(void *)*v487 & 7 | (unint64_t)(v484 + 16);
                                  }
                                  uint64_t v485 = *(void *)v801;
                                }
                                *(v487 - 2) = &unk_1F2615EC8;
                                v487[2] = v485;
                                v487 += 8;
                                v484 += 64;
                                v486 -= 64;
                              }
                              while (v486);
                              if (*((void *)&v800 + 1) != -8192
                                && *((void *)&v800 + 1) != -4096
                                && *((void *)&v800 + 1))
                              {
                                unint64_t v495 = (unint64_t)__b[1] & 0xFFFFFFFFFFFFFFF8;
                                *(void *)((unint64_t)__b[1] & 0xFFFFFFFFFFFFFFF8) = v800;
                                if ((void)v800)
                                {
                                  *(void *)long long v800 = *(void *)v800 & 7 | v495;
                                }
                                else
                                {
                                  uint64_t v496 = *((void *)&v800 + 1);
                                  v497 = (int32x2_t *)****((void ****)&v800 + 1);
                                  unint64_t v498 = (unint64_t)v497[303];
                                  if (v498 <= v495)
                                  {
                                    uint64_t v499 = v497[305].u32[0];
                                    if (v498 + 16 * v499 > v495)
                                    {
                                      unsigned int v500 = v499 - 1;
                                      LODWORD(v501) = v500 & ((DWORD2(v800) >> 4) ^ (DWORD2(v800) >> 9));
                                      unint64_t v502 = (uint64_t *)(v498 + 16 * v501);
                                      uint64_t v503 = *v502;
                                      if (*((void *)&v800 + 1) != *v502)
                                      {
                                        int v504 = 1;
                                        do
                                        {
                                          if (v503 == -4096) {
                                            goto LABEL_867;
                                          }
                                          int v505 = v501 + v504++;
                                          uint64_t v501 = v505 & v500;
                                          uint64_t v503 = *(void *)(v498 + 16 * v501);
                                        }
                                        while (*((void *)&v800 + 1) != v503);
                                        unint64_t v502 = (uint64_t *)(v498 + 16 * v501);
                                      }
                                      *unint64_t v502 = -8192;
                                      v497[304] = vadd_s32(v497[304], (int32x2_t)0x1FFFFFFFFLL);
                                      uint64_t v496 = *((void *)&v800 + 1);
LABEL_867:
                                      *(unsigned char *)(v496 + 17) &= ~1u;
                                    }
                                  }
                                }
                              }
                            }
                            LOBYTE(v795) = 0;
                            char v798 = 0;
                            std::to_string(&v746, __val);
                            unsigned int v491 = std::string::insert(&v746, 0, ".jt");
                            std::string::size_type v492 = v491->__r_.__value_.__r.__words[2];
                            *(_OWORD *)v792 = *(_OWORD *)&v491->__r_.__value_.__l.__data_;
                            std::string::size_type v793 = v492;
                            v491->__r_.__value_.__l.__size_ = 0;
                            v491->__r_.__value_.__r.__words[2] = 0;
                            v491->__r_.__value_.__r.__words[0] = 0;
                            *(_WORD *)v801 = 260;
                            __b[0] = v792;
                            llvm::CloneBasicBlock();
                          }
                          unint64_t v483 = v482;
                          sub_1CCD43EDC(k, v466, v482, (uint64_t)v772);
                          unint64_t v453 = v704 + 1;
                          if ((unint64_t *)((char *)v704 - *v451 + 8) == (unint64_t *)4096)
                          {
                            uint64_t v493 = (unint64_t *)v451[1];
                            ++v451;
                            unint64_t v453 = v493;
                          }
                          v442 = v729;
                          uint64_t v445 = v730;
                        }
                        sub_1CB904DFC(&__p);
                        uint64_t v441 = v699 + 9;
                        if (v699 + 9 != v697) {
                          continue;
                        }
                        break;
                      }
                      int v506 = (void *)v747[3];
                      int v507 = (void *)v747[4];
                      if (v506 != v507)
                      {
                        while (1)
                        {
                          uint64_t v508 = v506[6];
                          unint64_t v509 = v506[5] + v506[4] - 1;
                          uint64_t v715 = sub_1CCD43BA4(*(void *)(*(void *)(v506[1] + ((v509 >> 6) & 0x3FFFFFFFFFFFFF8))+ 8 * (v509 & 0x1FF)), v508, (uint64_t)v741);
                          uint64_t v510 = *(void *)(v715 + 40);
                          uint64_t v511 = v510 ? v510 - 24 : 0;
                          int v512 = *(unsigned __int8 *)(v511 + 16);
                          uint64_t v513 = (v512 - 29) >= 0xB ? 0 : v511;
                          if (*(unsigned char *)(v513 + 16) == 31) {
                            break;
                          }
                          v506 += 9;
                          if (v506 == v507) {
                            goto LABEL_978;
                          }
                        }
                        unint64_t v313 = sub_1CCD443C4(v513, v508);
                        unint64_t v514 = v313;
                        __b[0] = v801;
                        __b[1] = v801;
                        *(void *)&long long v800 = 4;
                        DWORD2(v800) = 0;
                        if (v512 != 30)
                        {
                          unsigned int v515 = 2;
                          switch(v512)
                          {
                            case 30:
                              goto LABEL_1278;
                            case 31:
                              unsigned int v515 = (*(_DWORD *)(v511 + 20) >> 1) & 0x3FFFFFF;
                              goto LABEL_972;
                            case 32:
                            case 38:
                              unsigned int v515 = (*(_DWORD *)(v511 + 20) & 0x7FFFFFF) - 1;
                              goto LABEL_972;
                            case 33:
                              goto LABEL_882;
                            case 36:
                              unsigned int v515 = *(_WORD *)(v511 + 18) & 1;
                              goto LABEL_972;
                            case 37:
                              unsigned int v515 = 1;
                              goto LABEL_882;
                            case 39:
                              unsigned int v515 = *(_DWORD *)(v511 + 80) + 1;
LABEL_972:
                              if (!v515) {
                                goto LABEL_968;
                              }
                              goto LABEL_882;
                            default:
                              goto LABEL_968;
                          }
                        }
                        if ((*(_DWORD *)(v511 + 20) & 0x7FFFFFF) == 3) {
                          unsigned int v515 = 2;
                        }
                        else {
                          unsigned int v515 = 1;
                        }
LABEL_882:
                        uint64_t v516 = 0;
                        unint64_t v517 = 0;
                        v518 = 0;
                        v519 = 0;
                        uint64_t v520 = v511 - 32;
                        uint64_t v521 = v515;
                        unint64_t v709 = v313;
                        while (2)
                        {
                          int v522 = *(unsigned __int8 *)(v511 + 16);
                          if (v522 == 30)
                          {
                            v523 = (uint64_t *)(v520 - 32 * v516);
                            goto LABEL_885;
                          }
                          uint64_t v547 = (v522 - 31);
                          v523 = (uint64_t *)(v511 - 32);
                          switch(v547)
                          {
                            case 1:
                            case 7:
                              int v550 = *(_DWORD *)(v511 + 20);
                              if ((v550 & 0x40000000) != 0) {
                                uint64_t v551 = *(void *)(v511 - 8);
                              }
                              else {
                                uint64_t v551 = v511 - 32 * (v550 & 0x7FFFFFF);
                              }
                              v523 = (uint64_t *)(v551 + 32 * v516 + 32);
                              goto LABEL_966;
                            case 2:
                              uint64_t v552 = -64;
                              if (!v516) {
                                uint64_t v552 = -96;
                              }
                              v523 = (uint64_t *)(v511 + v552);
                              goto LABEL_885;
                            case 3:
                            case 4:
                              goto LABEL_1278;
                            case 5:
                              if ((*(_WORD *)(v511 + 18) & 1) == 0)
                              {
                                uint64_t v524 = 0;
                                unint64_t v514 = v709;
                                goto LABEL_886;
                              }
                              uint64_t v553 = *(_DWORD *)(v511 + 20) & 0x7FFFFFF;
                              uint64_t v554 = v511 + 32;
                              goto LABEL_965;
                            case 6:
                              goto LABEL_885;
                            case 8:
                              if (v516)
                              {
                                v523 = (uint64_t *)(v520 - 32 * *(unsigned int *)(v511 + 80) + 32 * v516 - 32);
                              }
                              else
                              {
                                uint64_t v553 = *(unsigned int *)(v511 + 80);
                                uint64_t v554 = v511 - 64;
LABEL_965:
                                v523 = (uint64_t *)(v554 - 32 * v553);
                              }
LABEL_966:
                              unint64_t v514 = v709;
LABEL_885:
                              uint64_t v524 = *v523;
LABEL_886:
                              if (v524 == v514)
                              {
LABEL_921:
                                int v541 = v518;
LABEL_939:
                                ++v516;
                                v518 = v541;
                                if (v516 == v521) {
LABEL_968:
                                }
                                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                                continue;
                              }
                              int v525 = (char *)__b[1];
                              uint64_t v526 = DWORD1(v800);
                              if (__b[1] == __b[0])
                              {
                                if (DWORD1(v800))
                                {
                                  uint64_t v527 = 0;
                                  uint64_t v528 = 8 * DWORD1(v800);
                                  int v529 = __b[1];
                                  do
                                  {
                                    if (*v529 == v524) {
                                      goto LABEL_921;
                                    }
                                    if (*v529 == -2) {
                                      uint64_t v527 = v529;
                                    }
                                    ++v529;
                                    v528 -= 8;
                                  }
                                  while (v528);
                                  if (v527)
                                  {
                                    void *v527 = v524;
                                    --DWORD2(v800);
                                    goto LABEL_919;
                                  }
                                }
                                unsigned int v530 = v800;
                                if (DWORD1(v800) < v800)
                                {
                                  ++DWORD1(v800);
                                  *((void *)__b[1] + v526) = v524;
                                  goto LABEL_919;
                                }
                              }
                              else
                              {
                                unsigned int v530 = v800;
                              }
                              if (3 * v530 <= 4 * (DWORD1(v800) - DWORD2(v800)))
                              {
                                if (v530 >= 0x40) {
                                  v530 *= 2;
                                }
                                else {
                                  unsigned int v530 = 128;
                                }
                              }
                              else if (v530 - DWORD1(v800) >= v530 >> 3)
                              {
LABEL_900:
                                unsigned int v531 = v530 - 1;
                                unsigned int v532 = (v530 - 1) & ((v524 >> 4) ^ (v524 >> 9));
                                v533 = &v525[8 * v532];
                                uint64_t v534 = *(void *)v533;
                                if (*(void *)v533 != -1)
                                {
                                  int v535 = 0;
                                  int v536 = 1;
                                  while (v534 != v524)
                                  {
                                    if (v535) {
                                      BOOL v537 = 0;
                                    }
                                    else {
                                      BOOL v537 = v534 == -2;
                                    }
                                    if (v537) {
                                      int v535 = v533;
                                    }
                                    unsigned int v538 = v532 + v536++;
                                    unsigned int v532 = v538 & v531;
                                    v533 = &v525[8 * (v538 & v531)];
                                    uint64_t v534 = *(void *)v533;
                                    if (*(void *)v533 == -1) {
                                      goto LABEL_912;
                                    }
                                  }
                                  goto LABEL_921;
                                }
                                int v535 = 0;
LABEL_912:
                                if (v535) {
                                  BOOL v539 = v535;
                                }
                                else {
                                  BOOL v539 = v533;
                                }
                                if (*(void *)v539 == v524) {
                                  goto LABEL_921;
                                }
                                if (*(void *)v539 == -2) {
                                  --DWORD2(v800);
                                }
                                else {
                                  ++DWORD1(v800);
                                }
                                *(void *)BOOL v539 = v524;
LABEL_919:
                                uint64_t v540 = v524 | 4;
                                if ((unint64_t)v518 >= v517)
                                {
                                  uint64_t v542 = ((char *)v518 - (char *)v519) >> 4;
                                  unint64_t v543 = v542 + 1;
                                  if ((unint64_t)(v542 + 1) >> 60) {
                                    goto LABEL_1276;
                                  }
                                  if ((uint64_t)(v517 - (void)v519) >> 3 > v543) {
                                    unint64_t v543 = (uint64_t)(v517 - (void)v519) >> 3;
                                  }
                                  if (v517 - (unint64_t)v519 >= 0x7FFFFFFFFFFFFFF0) {
                                    unint64_t v544 = 0xFFFFFFFFFFFFFFFLL;
                                  }
                                  else {
                                    unint64_t v544 = v543;
                                  }
                                  if (v544)
                                  {
                                    if (v544 >> 60) {
                                      goto LABEL_1277;
                                    }
                                    unint64_t v313 = (unint64_t)operator new(16 * v544);
                                  }
                                  else
                                  {
                                    unint64_t v313 = 0;
                                  }
                                  v545 = (uint64_t *)(v313 + 16 * v542);
                                  uint64_t *v545 = v715;
                                  v545[1] = v540;
                                  if (v518 == v519)
                                  {
                                    v519 = (uint64_t *)(v313 + 16 * v542);
                                    unint64_t v514 = v709;
                                  }
                                  else
                                  {
                                    unint64_t v546 = v313 + 16 * v542;
                                    unint64_t v514 = v709;
                                    do
                                    {
                                      *(_OWORD *)(v546 - 16) = *((_OWORD *)v518 - 1);
                                      v546 -= 16;
                                      v518 -= 2;
                                    }
                                    while (v518 != v519);
                                    v518 = v519;
                                    v519 = (uint64_t *)v546;
                                  }
                                  unint64_t v517 = v313 + 16 * v544;
                                  int v541 = v545 + 2;
                                  if (v518) {
                                    operator delete(v518);
                                  }
                                }
                                else
                                {
                                  uint64_t *v518 = v715;
                                  v518[1] = v540;
                                  int v541 = v518 + 2;
                                }
                                goto LABEL_939;
                              }
                              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)__b, v530);
                              unsigned int v530 = v800;
                              int v525 = (char *)__b[1];
                              goto LABEL_900;
                            default:
                              int v548 = *(_DWORD *)(v511 + 20);
                              if ((v548 & 0x40000000) != 0) {
                                uint64_t v549 = *(void *)(v511 - 8);
                              }
                              else {
                                uint64_t v549 = v511 - 32 * (v548 & 0x7FFFFFF);
                              }
                              v523 = (uint64_t *)(v549 + 32 * (2 * v516) + 32);
                              goto LABEL_885;
                          }
                        }
                      }
                    }
LABEL_978:
                    __b[0] = &v800;
                    __b[1] = (void *)0x400000000;
                    uint64_t v814 = 0;
                    uint64_t v815 = 0;
                    LODWORD(v816) = 0;
                    uint64_t v817 = 0;
                    uint64_t v818 = 0;
                    int v819 = 0;
                    uint64_t v820 = 0;
                    uint64_t v821 = 0;
                    v822 = v824;
                    uint64_t v823 = 0x400000000;
                    v825 = v827;
                    uint64_t v826 = 0;
                    v827[0] = 0;
                    v827[1] = 1;
                    v794.__r_.__value_.__r.__words[0] = (std::string::size_type)&v794.__r_.__value_.__r.__words[2];
                    v794.__r_.__value_.__l.__size_ = 0x1000000000;
                    uint64_t v555 = v738;
                    char v556 = v739;
                    while (2)
                    {
                      if (v555 == v556)
                      {
                        llvm::SSAUpdaterBulk::RewriteAllUses((uint64_t *)__b, v748.i64[0]);
                        if ((std::string::size_type *)v794.__r_.__value_.__l.__data_ != &v794.__r_.__value_.__r.__words[2]) {
                          free(v794.__r_.__value_.__l.__data_);
                        }
                        if (v823)
                        {
                          v588 = (uint64_t *)v822;
                          uint64_t v589 = 8 * v823;
                          do
                          {
                            uint64_t v590 = *v588++;
                            MEMORY[0x1D25D9CD0](v590, 8);
                            v589 -= 8;
                          }
                          while (v589);
                        }
                        v591 = (uint64_t *)v825;
                        if (v826)
                        {
                          uint64_t v681 = 16 * v826;
                          do
                          {
                            uint64_t v682 = *v591;
                            v591 += 2;
                            MEMORY[0x1D25D9CD0](v682, 8);
                            v681 -= 16;
                          }
                          while (v681);
                          v591 = (uint64_t *)v825;
                        }
                        if (v591 != v827) {
                          free(v591);
                        }
                        if (v822 != v824) {
                          free(v822);
                        }
                        MEMORY[0x1D25D9CD0](v817, 8);
                        MEMORY[0x1D25D9CD0](v814, 8);
                        unsigned int v593 = (long long *)__b[0];
                        if (LODWORD(__b[1]))
                        {
                          uint64_t v594 = 96 * LODWORD(__b[1]);
                          uint64_t v595 = (char *)__b[0] - 96;
                          do
                          {
                            sub_1CD76275C(&v595[v594]);
                            v594 -= 96;
                          }
                          while (v594);
                          unsigned int v593 = (long long *)__b[0];
                        }
                        if (v593 != &v800) {
                          free(v593);
                        }
                        int v596 = (void *)v768.__r_.__value_.__l.__size_;
                        std::string::size_type v597 = v768.__r_.__value_.__r.__words[0];
                        v598 = &v768.__r_.__value_.__s.__data_[20];
                        if (v768.__r_.__value_.__l.__size_ != v768.__r_.__value_.__r.__words[0]) {
                          v598 = &v768.__r_.__value_.__s.__data_[16];
                        }
                        uint64_t v599 = *(unsigned int *)v598;
                        uint64_t v600 = (unint64_t *)v768.__r_.__value_.__l.__size_;
                        if (v599)
                        {
                          uint64_t v601 = 0;
                          while (*(void *)(v768.__r_.__value_.__l.__size_ + v601) >= 0xFFFFFFFFFFFFFFFELL)
                          {
                            v601 += 8;
                            if (8 * v599 == v601) {
                              goto LABEL_1144;
                            }
                          }
                          uint64_t v600 = (unint64_t *)(v768.__r_.__value_.__l.__size_ + v601);
                        }
                        std::string::size_type v602 = v768.__r_.__value_.__l.__size_ + 8 * v599;
                        if (v600 == (unint64_t *)v602) {
                          goto LABEL_1144;
                        }
                        long long v710 = (unint64_t *)v602;
                        unsigned int v716 = v600;
                        unint64_t v603 = *v600;
                        while (1)
                        {
                          uint64_t v604 = *(void *)(v603 + 8);
                          if (v604)
                          {
                            while (1)
                            {
                              uint64_t v605 = *(void *)(v604 + 24);
                              unsigned int v606 = *(unsigned __int8 *)(v605 + 16);
                              BOOL v607 = v605 && v606 >= 0x1C;
                              if (v607 && v606 - 29 < 0xB) {
                                break;
                              }
                              uint64_t v604 = *(void *)(v604 + 8);
                              if (!v604) {
                                goto LABEL_1056;
                              }
                            }
                            uint64_t v626 = *(void *)(v603 + 48);
                            uint64_t v627 = (_DWORD *)(v626 - 24);
                            if (v626) {
                              uint64_t v628 = v626 - 24;
                            }
                            else {
                              uint64_t v628 = 0;
                            }
                            if (v626 && *(unsigned char *)(v628 + 16) == 83)
                            {
                              do
                              {
                                int v629 = v627[5];
                                if ((v629 & 0x40000000) != 0)
                                {
                                  long long v631 = (_DWORD *)*((void *)v627 - 1);
                                  uint64_t v630 = v629 & 0x7FFFFFF;
                                  if (v630)
                                  {
LABEL_1100:
                                    unsigned int v632 = 0;
                                    v633 = 0;
                                    v634 = 0;
                                    uint64_t v635 = (uint64_t *)&v631[8 * v627[15]];
                                    uint64_t v636 = &v635[v630];
                                    do
                                    {
                                      uint64_t v637 = *v635;
                                      if (!sub_1CCD4435C(*(void *)(v603 + 8), *v635))
                                      {
                                        if (v633 >= v632)
                                        {
                                          uint64_t v638 = v633 - v634;
                                          unint64_t v639 = v638 + 1;
                                          if ((unint64_t)(v638 + 1) >> 61) {
                                            goto LABEL_1276;
                                          }
                                          if (((char *)v632 - (char *)v634) >> 2 > v639) {
                                            unint64_t v639 = ((char *)v632 - (char *)v634) >> 2;
                                          }
                                          if ((unint64_t)((char *)v632 - (char *)v634) >= 0x7FFFFFFFFFFFFFF8) {
                                            unint64_t v640 = 0x1FFFFFFFFFFFFFFFLL;
                                          }
                                          else {
                                            unint64_t v640 = v639;
                                          }
                                          if (v640)
                                          {
                                            if (v640 >> 61) {
                                              goto LABEL_1277;
                                            }
                                            uint64_t v641 = (char *)operator new(8 * v640);
                                          }
                                          else
                                          {
                                            uint64_t v641 = 0;
                                          }
                                          uint64_t v642 = (uint64_t *)&v641[8 * v638];
                                          *uint64_t v642 = v637;
                                          uint64_t v643 = v642 + 1;
                                          if (v633 != v634)
                                          {
                                            do
                                            {
                                              uint64_t v644 = *--v633;
                                              *--uint64_t v642 = v644;
                                            }
                                            while (v633 != v634);
                                            v633 = v634;
                                          }
                                          v634 = v642;
                                          unsigned int v632 = (uint64_t *)&v641[8 * v640];
                                          if (v633) {
                                            operator delete(v633);
                                          }
                                          v633 = v643;
                                        }
                                        else
                                        {
                                          *v633++ = v637;
                                        }
                                      }
                                      ++v635;
                                    }
                                    while (v635 != v636);
                                    for (uint64_t m = v634; m != v633; ++m)
                                    {
                                      int v646 = v627[5];
                                      uint64_t v647 = v646 & 0x7FFFFFF;
                                      if ((v646 & 0x7FFFFFF) != 0)
                                      {
                                        uint64_t v648 = 0;
                                        while (1)
                                        {
                                          uint64_t v649 = &v627[-8 * v647];
                                          if ((v646 & 0x40000000) != 0) {
                                            uint64_t v649 = (_DWORD *)*((void *)v627 - 1);
                                          }
                                          if (*(void *)&v649[8 * v627[15] + 2 * v648] == *m) {
                                            break;
                                          }
                                          if (v647 == ++v648) {
                                            goto LABEL_1128;
                                          }
                                        }
                                      }
                                      else
                                      {
LABEL_1128:
                                        LODWORD(v648) = -1;
                                      }
                                      llvm::PHINode::removeIncomingValue((llvm::PHINode *)v627, v648, 1);
                                    }
                                    if (v634) {
                                      operator delete(v634);
                                    }
                                  }
                                }
                                else
                                {
                                  uint64_t v630 = v629 & 0x7FFFFFF;
                                  long long v631 = &v627[-8 * v630];
                                  if (v630) {
                                    goto LABEL_1100;
                                  }
                                }
                                uint64_t v626 = *(void *)(v626 + 8);
                                uint64_t v650 = v626 - 24;
                                if (!v626) {
                                  uint64_t v650 = 0;
                                }
                                int v651 = *(unsigned __int8 *)(v650 + 16);
                                if (v651 == 83) {
                                  uint64_t v627 = (_DWORD *)v650;
                                }
                                else {
                                  uint64_t v627 = 0;
                                }
                              }
                              while (v626 && v651 == 83);
                            }
                          }
                          else
                          {
LABEL_1056:
                            uint64_t v609 = *(void *)(v603 + 48);
                            uint64_t v610 = (llvm::UndefValue **)(v609 - 24);
                            if (v609) {
                              uint64_t v611 = v609 - 24;
                            }
                            else {
                              uint64_t v611 = 0;
                            }
                            if (v609 && *(unsigned char *)(v611 + 16) == 83)
                            {
                              char v612 = 0;
                              unsigned int v613 = 0;
                              unsigned int v614 = 0;
                              do
                              {
                                if (v613 >= v612)
                                {
                                  uint64_t v615 = v613 - v614;
                                  unint64_t v616 = v615 + 1;
                                  if ((unint64_t)(v615 + 1) >> 61) {
                                    goto LABEL_1276;
                                  }
                                  if (((char *)v612 - (char *)v614) >> 2 > v616) {
                                    unint64_t v616 = ((char *)v612 - (char *)v614) >> 2;
                                  }
                                  if ((unint64_t)((char *)v612 - (char *)v614) >= 0x7FFFFFFFFFFFFFF8) {
                                    unint64_t v617 = 0x1FFFFFFFFFFFFFFFLL;
                                  }
                                  else {
                                    unint64_t v617 = v616;
                                  }
                                  if (v617)
                                  {
                                    if (v617 >> 61) {
                                      goto LABEL_1277;
                                    }
                                    int v618 = (char *)operator new(8 * v617);
                                  }
                                  else
                                  {
                                    int v618 = 0;
                                  }
                                  v619 = (llvm::UndefValue ***)&v618[8 * v615];
                                  char *v619 = v610;
                                  int v620 = v619 + 1;
                                  if (v613 != v614)
                                  {
                                    do
                                    {
                                      unint64_t v621 = *--v613;
                                      *--v619 = v621;
                                    }
                                    while (v613 != v614);
                                    unsigned int v613 = v614;
                                  }
                                  unsigned int v614 = v619;
                                  char v612 = (llvm::UndefValue ***)&v618[8 * v617];
                                  if (v613) {
                                    operator delete(v613);
                                  }
                                  unsigned int v613 = v620;
                                }
                                else
                                {
                                  *v613++ = v610;
                                }
                                uint64_t v609 = *(void *)(v609 + 8);
                                uint64_t v622 = v609 - 24;
                                if (!v609) {
                                  uint64_t v622 = 0;
                                }
                                int v623 = *(unsigned __int8 *)(v622 + 16);
                                if (v623 == 83) {
                                  uint64_t v610 = (llvm::UndefValue **)v622;
                                }
                                else {
                                  uint64_t v610 = 0;
                                }
                              }
                              while (v609 && v623 == 83);
                              if (v614 != v613)
                              {
                                v624 = *v614;
                                uint64_t v625 = llvm::UndefValue::get(**v614, v592);
                                llvm::Value::doRAUW((llvm::ValueAsMetadata *)v624, v625, (llvm::Value *)1);
                                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                              }
                              if (v614) {
                                operator delete(v614);
                              }
                            }
                          }
                          size_t v652 = v716 + 1;
                          do
                          {
                            if (v652 == v710)
                            {
                              int v596 = (void *)v768.__r_.__value_.__l.__size_;
                              std::string::size_type v597 = v768.__r_.__value_.__r.__words[0];
LABEL_1144:
                              if (v596 != (void *)v597) {
                                free(v596);
                              }
                              sub_1CD58F044((uint64_t)&v735);
                              sub_1CCD43E64(v741);
                              sub_1CC2930C0((uint64_t)v772);
                              goto LABEL_1147;
                            }
                            unint64_t v653 = *v652++;
                            unint64_t v603 = v653;
                          }
                          while (v653 > 0xFFFFFFFFFFFFFFFDLL);
                          unsigned int v716 = v652 - 1;
                        }
                      }
                      uint64_t v558 = *v555;
                      int v557 = (unsigned char *)v555[1];
                      unsigned int v559 = (unsigned char *)v555[2];
                      size_t v560 = v559 - v557;
                      if (v559 == v557)
                      {
                        v561 = 0;
                        int v562 = 0;
                        uint64_t v563 = 0;
                        unsigned int v564 = *(void **)(v558 + 40);
                      }
                      else
                      {
                        if ((v560 & 0x8000000000000000) != 0) {
                          goto LABEL_1276;
                        }
                        v561 = operator new(v559 - v557);
                        memmove(v561, v557, v560);
                        unsigned int v564 = *(void **)(v558 + 40);
                        uint64_t v563 = (uint64_t *)operator new(v560);
                        memcpy(v563, v561, v560);
                        int v562 = (uint64_t *)((char *)v563 + v560);
                      }
                      for (uint64_t n = *(void *)(v558 + 8); n; uint64_t n = *(void *)(n + 8))
                      {
                        uint64_t v566 = *(void *)(n + 24);
                        if (v566 && *(unsigned char *)(v566 + 16) == 83)
                        {
                          int v567 = *(_DWORD *)(v566 + 20);
                          if ((v567 & 0x40000000) != 0) {
                            uint64_t v568 = *(void *)(v566 - 8);
                          }
                          else {
                            uint64_t v568 = v566 - 32 * (v567 & 0x7FFFFFF);
                          }
                          unint64_t v569 = *(void **)(v568
                                          + 32 * *(unsigned int *)(v566 + 60)
                                          + 8 * ((unint64_t)(n - v568) >> 5));
                        }
                        else
                        {
                          unint64_t v569 = *(void **)(v566 + 40);
                        }
                        if (v569 != v564)
                        {
                          if (LODWORD(v794.__r_.__value_.__r.__words[1]) >= (unint64_t)HIDWORD(v794.__r_.__value_.__r.__words[1])) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          *(void *)(v794.__r_.__value_.__r.__words[0]
                                    + 8 * LODWORD(v794.__r_.__value_.__r.__words[1])) = n;
                          ++LODWORD(v794.__r_.__value_.__r.__words[1]);
                        }
                      }
                      if (!LODWORD(v794.__r_.__value_.__r.__words[1]))
                      {
LABEL_999:
                        if (v563) {
                          operator delete(v563);
                        }
                        if (v561) {
                          operator delete(v561);
                        }
                        v555 += 4;
                        continue;
                      }
                      break;
                    }
                    uint64_t v570 = *(uint64_t ***)v558;
                    if ((*(unsigned char *)(v558 + 23) & 0x10) != 0)
                    {
                      uint64_t v571 = **v570;
                      uint64_t v572 = *(void *)(v571 + 152);
                      uint64_t v573 = *(unsigned int *)(v571 + 168);
                      if (!v573) {
                        goto LABEL_1011;
                      }
                      LODWORD(v574) = (v573 - 1) & ((v558 >> 4) ^ (v558 >> 9));
                      unsigned int v575 = (uint64_t *)(v572 + 16 * v574);
                      uint64_t v576 = *v575;
                      if (*v575 != v558)
                      {
                        int v577 = 1;
                        while (v576 != -4096)
                        {
                          int v578 = v574 + v577++;
                          uint64_t v574 = v578 & (v573 - 1);
                          uint64_t v576 = *(void *)(v572 + 16 * v574);
                          if (v576 == v558)
                          {
                            unsigned int v575 = (uint64_t *)(v572 + 16 * v574);
                            goto LABEL_1012;
                          }
                        }
LABEL_1011:
                        unsigned int v575 = (uint64_t *)(v572 + 16 * v573);
                      }
LABEL_1012:
                      unint64_t v579 = (void *)v575[1];
                      uint64_t v582 = *v579;
                      int v580 = (char *)(v579 + 2);
                      uint64_t v581 = v582;
                    }
                    else
                    {
                      uint64_t v581 = 0;
                      int v580 = &byte_1CFBCE98E;
                    }
                    unsigned int v583 = llvm::SSAUpdaterBulk::AddVariable((uint64_t)__b, (uint64_t)v580, v581, (uint64_t)v570);
                    long long __p = v564;
                    unsigned int v584 = v583;
                    sub_1CD209A88((uint64_t)__b[0] + 96 * v583, (uint64_t *)&__p)[1] = v558;
                    for (iuint64_t i = v563; ii != v562; sub_1CD209A88((uint64_t)__b[0] + 96 * v584, (uint64_t *)&__p)[1] = v586)
                    {
                      uint64_t v586 = *ii++;
                      long long __p = *(void **)(v586 + 40);
                    }
                    while (LODWORD(v794.__r_.__value_.__r.__words[1]))
                    {
                      v587 = *(llvm::Use **)(v794.__r_.__value_.__r.__words[0]
                                           + 8 * LODWORD(v794.__r_.__value_.__r.__words[1])
                                           - 8);
                      --LODWORD(v794.__r_.__value_.__r.__words[1]);
                      llvm::SSAUpdaterBulk::AddUse(__b, v584, v587);
                    }
                    goto LABEL_999;
                  }
                  if (!v395) {
                    goto LABEL_704;
                  }
LABEL_1231:
                  llvm::OptimizationRemark::OptimizationRemark((uint64_t)__b, (uint64_t)"dfa-jump-threading", (uint64_t)"JumpThreaded", 12, v708);
                  v768.__r_.__value_.__r.__words[0] = (std::string::size_type)"Switch statement jump-threaded.";
                  v768.__r_.__value_.__l.__size_ = 31;
                  sub_1CC59ADEC((uint64_t *)&v803, (uint64_t)&v768);
                  LODWORD(v772[1]) = __b[1];
                  BYTE4(v772[1]) = BYTE4(__b[1]);
                  long long v773 = v800;
                  *(void *)v774 = *(void *)v801;
                  *(_OWORD *)&v774[8] = *(_OWORD *)&v801[8];
                  long long v775 = *(_OWORD *)&v801[24];
                  uint64_t v776 = v802;
                  v772[0] = &unk_1F2616800;
                  v777 = v779;
                  uint64_t v778 = 0x400000000;
                  if (v804)
                  {
                    sub_1CD494D68((uint64_t)&v777, (uint64_t)&v803);
                    uint64_t v683 = v804;
                  }
                  else
                  {
                    uint64_t v683 = 0;
                  }
                  uint64_t v786 = v812;
                  uint64_t v787 = v813;
                  v772[0] = &unk_1F2616570;
                  __b[0] = &unk_1F2616800;
                  v684 = (char *)v803;
                  if (v683)
                  {
                    uint64_t v685 = v683 << 6;
                    do
                    {
                      BOOL v686 = (void **)&v684[v685];
                      if (v684[v685 - 17] < 0) {
                        operator delete(*(v686 - 5));
                      }
                      if (*((char *)v686 - 41) < 0) {
                        operator delete(*(v686 - 8));
                      }
                      v685 -= 64;
                    }
                    while (v685);
                    v684 = (char *)v803;
                  }
                  if (v684 != (char *)v805) {
                    free(v684);
                  }
                  llvm::OptimizationRemarkEmitter::emit(v393, (llvm::DiagnosticInfoOptimizationBase *)v772);
                  v772[0] = &unk_1F2616800;
                  int v666 = (char *)v777;
                  if (v778)
                  {
                    unint64_t v687 = (unint64_t)v778 << 6;
                    do
                    {
                      long long v688 = (void **)&v666[v687];
                      if (v666[v687 - 17] < 0) {
                        operator delete(*(v688 - 5));
                      }
                      if (*((char *)v688 - 41) < 0) {
                        operator delete(*(v688 - 8));
                      }
                      v687 -= 64;
                    }
                    while (v687);
LABEL_1251:
                    int v666 = (char *)v777;
                  }
                }
                if (v666 != (char *)v779) {
                  free(v666);
                }
                goto LABEL_704;
              }
              sub_1CD76248C((uint64_t)&v768, (void *)v347);
              uint64_t v348 = *(void *)(v347 + 48);
              v792[0] = *(void **)(v347 + 56);
              uint64_t v349 = (llvm::BasicBlock *)v747[1];
              v746.__r_.__value_.__r.__words[0] = (std::string::size_type)v349;
              if (!sub_1CCD43BA4((uint64_t)v349, v348, (uint64_t)&v735))
              {
                llvm::CodeMetrics::analyzeBasicBlock((uint64_t)&__p, v349, (void *)v749, (uint64_t *)&v750, 0);
                uint64_t v350 = sub_1CCD43C60((uint64_t)&v735, (uint64_t *)&v746);
                uint64_t v351 = v350;
                uint64_t v353 = (llvm::BasicBlock **)v350[1];
                unint64_t v352 = v350[2];
                if ((unint64_t)v353 >= v352)
                {
                  BOOL v355 = (llvm::BasicBlock **)*v350;
                  uint64_t v356 = ((uint64_t)v353 - *v350) >> 4;
                  unint64_t v357 = v356 + 1;
                  if ((unint64_t)(v356 + 1) >> 60) {
                    goto LABEL_1276;
                  }
                  uint64_t v358 = v352 - (void)v355;
                  if (v358 >> 3 > v357) {
                    unint64_t v357 = v358 >> 3;
                  }
                  if ((unint64_t)v358 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v359 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v359 = v357;
                  }
                  if (v359)
                  {
                    if (v359 >> 60) {
                      goto LABEL_1277;
                    }
                    int64_t v360 = (char *)operator new(16 * v359);
                  }
                  else
                  {
                    int64_t v360 = 0;
                  }
                  uint64_t v361 = (llvm::BasicBlock **)&v360[16 * v356];
                  *uint64_t v361 = v349;
                  v361[1] = (llvm::BasicBlock *)v348;
                  unint64_t v362 = v361;
                  if (v353 != v355)
                  {
                    do
                    {
                      *((_OWORD *)v362 - 1) = *((_OWORD *)v353 - 1);
                      v362 -= 2;
                      v353 -= 2;
                    }
                    while (v353 != v355);
                    uint64_t v353 = (llvm::BasicBlock **)*v351;
                  }
                  uint64_t v354 = v361 + 2;
                  uint64_t *v351 = (uint64_t)v362;
                  v351[1] = (uint64_t)(v361 + 2);
                  v351[2] = (uint64_t)&v360[16 * v359];
                  if (v353) {
                    operator delete(v353);
                  }
                }
                else
                {
                  *uint64_t v353 = v349;
                  v353[1] = (llvm::BasicBlock *)v348;
                  uint64_t v354 = v353 + 2;
                }
                v351[1] = (uint64_t)v354;
              }
              std::string::size_type v363 = v768.__r_.__value_.__l.__size_;
              unint64_t v364 = (void *)(v768.__r_.__value_.__l.__size_ + 8 * (v770 >> 9));
              if (*(void **)(*v364 + 8 * (v770 & 0x1FF)) == v792[0]) {
                goto LABEL_677;
              }
              std::string::size_type v365 = v768.__r_.__value_.__r.__words[2];
              uint64_t v366 = (void **)(v768.__r_.__value_.__l.__size_ + 8 * ((v771 + v770) >> 9));
              uint64_t v367 = v768.__r_.__value_.__r.__words[2] == v768.__r_.__value_.__l.__size_
                   ? 0
                   : (void *)(*v364 + 8 * (v770 & 0x1FF));
              uint64_t v368 = v768.__r_.__value_.__r.__words[2] == v768.__r_.__value_.__l.__size_
                   ? 0
                   : &(*v366)[((_WORD)v771 + (_WORD)v770) & 0x1FF];
              uint64_t v369 = sub_1CCD43998(v364, v367, v366, v368, v792);
              uint64_t v371 = v370;
              while (1)
              {
                uint64_t v372 = v365 == v363
                     ? 0
                     : *(void *)(v363 + (((v770 + v771) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v770 + v771) & 0x1FF);
                if (v371 == (llvm::BasicBlock **)v372) {
                  break;
                }
                v373 = *v371;
                v746.__r_.__value_.__r.__words[0] = (std::string::size_type)v373;
                if (!sub_1CCD43BA4((uint64_t)v373, v348, (uint64_t)&v735))
                {
                  llvm::CodeMetrics::analyzeBasicBlock((uint64_t)&__p, v373, (void *)v749, (uint64_t *)&v750, 0);
                  int v374 = sub_1CCD43C60((uint64_t)&v735, (uint64_t *)&v746);
                  uint64_t v375 = v374;
                  BOOL v377 = (llvm::BasicBlock **)v374[1];
                  unint64_t v376 = v374[2];
                  if ((unint64_t)v377 >= v376)
                  {
                    unsigned int v379 = (llvm::BasicBlock **)*v374;
                    uint64_t v380 = ((uint64_t)v377 - *v374) >> 4;
                    unint64_t v381 = v380 + 1;
                    if ((unint64_t)(v380 + 1) >> 60) {
                      goto LABEL_1276;
                    }
                    uint64_t v382 = v376 - (void)v379;
                    if (v382 >> 3 > v381) {
                      unint64_t v381 = v382 >> 3;
                    }
                    if ((unint64_t)v382 >= 0x7FFFFFFFFFFFFFF0) {
                      unint64_t v383 = 0xFFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v383 = v381;
                    }
                    if (v383)
                    {
                      if (v383 >> 60) {
                        goto LABEL_1277;
                      }
                      uint64_t v384 = (char *)operator new(16 * v383);
                    }
                    else
                    {
                      uint64_t v384 = 0;
                    }
                    uint64_t v385 = (llvm::BasicBlock **)&v384[16 * v380];
                    *uint64_t v385 = v373;
                    v385[1] = (llvm::BasicBlock *)v348;
                    uint64_t v386 = v385;
                    if (v377 != v379)
                    {
                      do
                      {
                        *((_OWORD *)v386 - 1) = *((_OWORD *)v377 - 1);
                        v386 -= 2;
                        v377 -= 2;
                      }
                      while (v377 != v379);
                      BOOL v377 = (llvm::BasicBlock **)*v375;
                    }
                    int v387 = &v384[16 * v383];
                    uint64_t v378 = v385 + 2;
                    *uint64_t v375 = (uint64_t)v386;
                    v375[1] = (uint64_t)(v385 + 2);
                    v375[2] = (uint64_t)v387;
                    if (v377) {
                      operator delete(v377);
                    }
                  }
                  else
                  {
                    *BOOL v377 = v373;
                    v377[1] = (llvm::BasicBlock *)v348;
                    uint64_t v378 = v377 + 2;
                  }
                  v375[1] = (uint64_t)v378;
                }
                if ((llvm::BasicBlock **)((char *)++v371 - *v369) == (llvm::BasicBlock **)4096)
                {
                  uint64_t v388 = (llvm::BasicBlock **)v369[1];
                  ++v369;
                  uint64_t v371 = v388;
                }
                std::string::size_type v365 = v768.__r_.__value_.__r.__words[2];
                std::string::size_type v363 = v768.__r_.__value_.__l.__size_;
              }
              if (BYTE2(__p)) {
                break;
              }
              if (BYTE3(__p))
              {
                int v663 = (uint64_t ***)*((void *)&v749 + 1);
                uint64_t v664 = *****((void *****)&v749 + 1);
                if (*(void *)(v664 + 128)
                  || (*(unsigned int (**)(void))(**(void **)(v664 + 72) + 48))(*(void *)(v664 + 72)))
                {
                  llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)__b, (uint64_t)"dfa-jump-threading", (uint64_t)"ConvergentInst", 14, v708);
                  v794.__r_.__value_.__r.__words[0] = (std::string::size_type)"Contains convergent instructions.";
                  v794.__r_.__value_.__l.__size_ = 33;
                  sub_1CC59ADEC((uint64_t *)&v803, (uint64_t)&v794);
                  LODWORD(v772[1]) = __b[1];
                  BYTE4(v772[1]) = BYTE4(__b[1]);
                  long long v773 = v800;
                  *(void *)v774 = *(void *)v801;
                  *(_OWORD *)&v774[8] = *(_OWORD *)&v801[8];
                  long long v775 = *(_OWORD *)&v801[24];
                  uint64_t v776 = v802;
                  v772[0] = &unk_1F2616800;
                  v777 = v779;
                  uint64_t v778 = 0x400000000;
                  if (v804)
                  {
                    sub_1CD494D68((uint64_t)&v777, (uint64_t)&v803);
                    uint64_t v669 = v804;
                  }
                  else
                  {
                    uint64_t v669 = 0;
                  }
                  uint64_t v786 = v812;
                  uint64_t v787 = v813;
                  v772[0] = &unk_1F26165A8;
                  __b[0] = &unk_1F2616800;
                  unsigned int v676 = (char *)v803;
                  if (v669)
                  {
                    uint64_t v677 = v669 << 6;
                    do
                    {
                      uint64_t v678 = (void **)&v676[v677];
                      if (v676[v677 - 17] < 0) {
                        operator delete(*(v678 - 5));
                      }
                      if (*((char *)v678 - 41) < 0) {
                        operator delete(*(v678 - 8));
                      }
                      v677 -= 64;
                    }
                    while (v677);
                    unsigned int v676 = (char *)v803;
                  }
                  if (v676 != (char *)v805) {
                    free(v676);
                  }
                  llvm::OptimizationRemarkEmitter::emit(v663, (llvm::DiagnosticInfoOptimizationBase *)v772);
                  v772[0] = &unk_1F2616800;
                  v673 = (char *)v777;
                  if (v778)
                  {
                    unint64_t v679 = (unint64_t)v778 << 6;
                    do
                    {
                      char v680 = (void **)&v673[v679];
                      if (v673[v679 - 17] < 0) {
                        operator delete(*(v680 - 5));
                      }
                      if (*((char *)v680 - 41) < 0) {
                        operator delete(*(v680 - 8));
                      }
                      v679 -= 64;
                    }
                    while (v679);
                    goto LABEL_1224;
                  }
                  goto LABEL_1225;
                }
                goto LABEL_1167;
              }
LABEL_677:
              sub_1CB904DFC((void **)&v768.__r_.__value_.__l.__data_);
              v347 += 72;
            }
            v660 = (uint64_t ***)*((void *)&v749 + 1);
            uint64_t v661 = *****((void *****)&v749 + 1);
            if (*(void *)(v661 + 128)
              || (*(unsigned int (**)(void))(**(void **)(v661 + 72) + 48))(*(void *)(v661 + 72)))
            {
              llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)__b, (uint64_t)"dfa-jump-threading", (uint64_t)"NonDuplicatableInst", 19, v708);
              v794.__r_.__value_.__r.__words[0] = (std::string::size_type)"Contains non-duplicatable instructions.";
              v794.__r_.__value_.__l.__size_ = 39;
              sub_1CC59ADEC((uint64_t *)&v803, (uint64_t)&v794);
              LODWORD(v772[1]) = __b[1];
              BYTE4(v772[1]) = BYTE4(__b[1]);
              long long v773 = v800;
              *(void *)v774 = *(void *)v801;
              *(_OWORD *)&v774[8] = *(_OWORD *)&v801[8];
              long long v775 = *(_OWORD *)&v801[24];
              uint64_t v776 = v802;
              v772[0] = &unk_1F2616800;
              v777 = v779;
              uint64_t v778 = 0x400000000;
              if (v804)
              {
                sub_1CD494D68((uint64_t)&v777, (uint64_t)&v803);
                uint64_t v662 = v804;
              }
              else
              {
                uint64_t v662 = 0;
              }
              uint64_t v786 = v812;
              uint64_t v787 = v813;
              v772[0] = &unk_1F26165A8;
              __b[0] = &unk_1F2616800;
              v670 = (char *)v803;
              if (v662)
              {
                uint64_t v671 = v662 << 6;
                do
                {
                  int v672 = (void **)&v670[v671];
                  if (v670[v671 - 17] < 0) {
                    operator delete(*(v672 - 5));
                  }
                  if (*((char *)v672 - 41) < 0) {
                    operator delete(*(v672 - 8));
                  }
                  v671 -= 64;
                }
                while (v671);
                v670 = (char *)v803;
              }
              if (v670 != (char *)v805) {
                free(v670);
              }
              llvm::OptimizationRemarkEmitter::emit(v660, (llvm::DiagnosticInfoOptimizationBase *)v772);
              v772[0] = &unk_1F2616800;
              v673 = (char *)v777;
              if (v778)
              {
                unint64_t v674 = (unint64_t)v778 << 6;
                do
                {
                  unsigned int v675 = (void **)&v673[v674];
                  if (v673[v674 - 17] < 0) {
                    operator delete(*(v675 - 5));
                  }
                  if (*((char *)v675 - 41) < 0) {
                    operator delete(*(v675 - 8));
                  }
                  v674 -= 64;
                }
                while (v674);
LABEL_1224:
                v673 = (char *)v777;
              }
LABEL_1225:
              if (v673 != (char *)v779) {
                free(v673);
              }
            }
LABEL_1167:
            sub_1CB904DFC((void **)&v768.__r_.__value_.__l.__data_);
            sub_1CCD43E64((uint64_t *)&v735);
            MEMORY[0x1D25D9CD0](v730, 8);
LABEL_1147:
            int v654 = (void **)v756;
            if (v756)
            {
              int v655 = v757;
              unsigned __int8 v656 = v756;
              if (v757 != v756)
              {
                do
                  int v655 = sub_1CB904DFC(v655 - 9);
                while (v655 != v654);
                unsigned __int8 v656 = v756;
              }
              v757 = v654;
              operator delete(v656);
            }
            if (v751 != v750) {
              free(v751);
            }
            v657 = (void **)v725;
            if (v725)
            {
              uint64_t v658 = v726;
              v659 = v725;
              if (v726 != v725)
              {
                do
                  uint64_t v658 = sub_1CB904DFC(v658 - 9);
                while (v658 != v657);
                v659 = v725;
              }
              v726 = v657;
              operator delete(v659);
            }
            uint64_t v326 = v700 + 6;
            if (v700 + 6 == (void *)v695)
            {
              char v325 = 1;
              goto LABEL_1267;
            }
          }
        }
        char v325 = v702;
        goto LABEL_1267;
      }
    }
    unsigned int v227 = v800;
LABEL_379:
    if (3 * v227 <= 4 * (DWORD1(v800) - DWORD2(v800)))
    {
      if (v227 >= 0x40) {
        v227 *= 2;
      }
      else {
        unsigned int v227 = 128;
      }
    }
    else if (v227 - DWORD1(v800) >= v227 >> 3)
    {
      goto LABEL_381;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)__b, v227);
    unsigned int v227 = v800;
    uint64_t v222 = (char *)__b[1];
LABEL_381:
    unsigned int v235 = v227 - 1;
    unsigned int v236 = (v227 - 1) & ((v16 >> 4) ^ (v16 >> 9));
    int v237 = &v222[8 * v236];
    int v238 = *(unsigned char **)v237;
    if (*(void *)v237 == -1)
    {
      int v239 = 0;
LABEL_393:
      if (v239) {
        uint64_t v243 = v239;
      }
      else {
        uint64_t v243 = v237;
      }
      if (*(unsigned char **)v243 != v16)
      {
        if (*(void *)v243 == -2) {
          --DWORD2(v800);
        }
        else {
          ++DWORD1(v800);
        }
        *(void *)uint64_t v243 = v16;
      }
    }
    else
    {
      int v239 = 0;
      int v240 = 1;
      while (v238 != v16)
      {
        if (v239) {
          BOOL v241 = 0;
        }
        else {
          BOOL v241 = v238 == (unsigned char *)-2;
        }
        if (v241) {
          int v239 = v237;
        }
        unsigned int v242 = v236 + v240++;
        unsigned int v236 = v242 & v235;
        int v237 = &v222[8 * (v242 & v235)];
        int v238 = *(unsigned char **)v237;
        if (*(void *)v237 == -1) {
          goto LABEL_393;
        }
      }
    }
    goto LABEL_400;
  }
  char v325 = 0;
  v759 = &v763;
  __src = &v763;
  uint64_t v761 = 32;
  int v762 = 0;
LABEL_1267:
  if (__src != v759) {
    free(__src);
  }
  long long v689 = v765;
  if (v766)
  {
    char v690 = v325;
    v691 = (char *)v765 - 24;
    uint64_t v692 = 48 * v766;
    do
    {
      sub_1CCD43B48((void **)&v691[v692]);
      v692 -= 48;
    }
    while (v692);
    long long v689 = v765;
    char v325 = v690;
  }
  if (v689 != v767) {
    free(v689);
  }
  return v325 & 1;
}

void sub_1CCD41E98()
{
}

void sub_1CCD41EF8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD41F30(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);
}

uint64_t sub_1CCD41FBC(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  int v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::AssumptionCacheTracker::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::AssumptionCacheTracker::ID);
  uint64_t AssumptionCache = llvm::AssumptionCacheTracker::getAssumptionCache(v9, (llvm::Function *)a2);
  uint64_t v11 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_11:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_11;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::DominatorTreeWrapperPass::ID)
      + 32;
  uint64_t v16 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  if (v17 == v18)
  {
LABEL_16:
    uint64_t v19 = 0;
  }
  else
  {
    while (*(char **)v17 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v17 += 16;
      if (v17 == v18) {
        goto LABEL_16;
      }
    }
    uint64_t v19 = *(void *)(v17 + 8);
  }
  unsigned int v20 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v19 + 96))(v19, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v20, (const Function *)a2);
  uint64_t v22 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v23 = *v22;
  uint64_t v24 = v22[1];
  if (v23 == v24)
  {
LABEL_21:
    uint64_t v25 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v23 != &llvm::OptimizationRemarkEmitterWrapperPass::ID)
    {
      v23 += 16;
      if (v23 == v24) {
        goto LABEL_21;
      }
    }
    uint64_t v25 = *(void *)(v23 + 8);
  }
  uint64_t v26 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v25 + 96))(v25, &llvm::OptimizationRemarkEmitterWrapperPass::ID)+ 32);
  v27[0] = AssumptionCache;
  v27[1] = v15;
  uint64_t v27[2] = TTI;
  v27[3] = v26;
  return sub_1CCD3AF5C((uint64_t)v27, (llvm::Function *)a2);
}

void *sub_1CCD421DC(void *result, uint64_t a2)
{
  void *result = result + 2;
  result[1] = 0x400000000;
  if ((void *)(a2 + 16) != result)
  {
    unsigned int v2 = *(_DWORD *)(a2 + 24);
    if (v2)
    {
      uint64_t v3 = result;
      if (v2 >= 5) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t result = memcpy(result + 2, *(const void **)(a2 + 16), 16 * *(unsigned int *)(a2 + 24));
      *((_DWORD *)v3 + 2) = v2;
    }
  }
  return result;
}

void *sub_1CCD42274(void *a1)
{
  *a1 = &unk_1F263DA98;
  unsigned int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

void sub_1CCD422C8(void *a1)
{
  *a1 = &unk_1F263DA98;
  unsigned int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD4233C(uint64_t a1, void *a2, llvm::SmallPtrSetImplBase *this)
{
  uint64_t v6 = *(void **)this;
  int v5 = (void *)*((void *)this + 1);
  if (v5 == *(void **)this)
  {
    uint64_t v7 = *((unsigned int *)this + 5);
    uint64_t v8 = &v5[v7];
    if (v7)
    {
      uint64_t v9 = 0;
      while (v5[v9] != a1)
      {
        if (v7 == ++v9) {
          goto LABEL_19;
        }
      }
      uint64_t v8 = &v5[v9];
    }
LABEL_19:
    uint64_t v6 = (void *)*((void *)this + 1);
  }
  else
  {
    uint64_t v10 = *((unsigned int *)this + 4);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    uint64_t v8 = &v5[v12];
    uint64_t v13 = *v8;
    if (*v8 == -1)
    {
      uint64_t v14 = 0;
LABEL_21:
      if (v14) {
        uint64_t v8 = v14;
      }
      if (*v8 != a1)
      {
        LODWORD(v7) = *((_DWORD *)this + 5);
        uint64_t v8 = &v5[v10];
        goto LABEL_26;
      }
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v13 != a1)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == -2;
        }
        if (v16) {
          uint64_t v14 = v8;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v8 = &v5[v17 & v11];
        uint64_t v13 = *v8;
        if (*v8 == -1) {
          goto LABEL_21;
        }
      }
    }
    LODWORD(v7) = *((_DWORD *)this + 5);
  }
LABEL_26:
  int v18 = *((_DWORD *)this + 4);
  if (v5 == v6) {
    int v18 = v7;
  }
  if (v8 != &v5[v18]) {
    return;
  }
  if (*(unsigned __int8 *)(a1 + 16) <= 0x1Bu) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = a1;
  }
  uint64_t v32 = v19;
  if (v19)
  {
    sub_1CD3F21B0(a2, &v32);
    uint64_t v6 = *(void **)this;
    int v5 = (void *)*((void *)this + 1);
    LODWORD(v7) = *((_DWORD *)this + 5);
  }
  if (v5 != v6)
  {
    unsigned int v23 = *((_DWORD *)this + 4);
    goto LABEL_45;
  }
  if (!v7)
  {
LABEL_42:
    unsigned int v23 = *((_DWORD *)this + 4);
    if (v7 < v23)
    {
      *((_DWORD *)this + 5) = v7 + 1;
      v6[v7] = a1;
      return;
    }
LABEL_45:
    if (3 * v23 <= 4 * ((int)v7 - *((_DWORD *)this + 6)))
    {
      if (v23 >= 0x40) {
        v23 *= 2;
      }
      else {
        unsigned int v23 = 128;
      }
    }
    else if (v23 - v7 >= v23 >> 3)
    {
      goto LABEL_47;
    }
    llvm::SmallPtrSetImplBase::Grow(this, v23);
    unsigned int v23 = *((_DWORD *)this + 4);
    int v5 = (void *)*((void *)this + 1);
LABEL_47:
    unsigned int v24 = v23 - 1;
    unsigned int v25 = (v23 - 1) & ((a1 >> 4) ^ (a1 >> 9));
    uint64_t v26 = &v5[v25];
    uint64_t v27 = *v26;
    if (*v26 == -1)
    {
      std::string::size_type v28 = 0;
LABEL_59:
      if (v28) {
        uint64_t v26 = v28;
      }
      if (*v26 != a1)
      {
        if (*v26 == -2) {
          --*((_DWORD *)this + 6);
        }
        else {
          ++*((_DWORD *)this + 5);
        }
        void *v26 = a1;
      }
    }
    else
    {
      std::string::size_type v28 = 0;
      int v29 = 1;
      while (v27 != a1)
      {
        if (v28) {
          BOOL v30 = 0;
        }
        else {
          BOOL v30 = v27 == -2;
        }
        if (v30) {
          std::string::size_type v28 = v26;
        }
        unsigned int v31 = v25 + v29++;
        unsigned int v25 = v31 & v24;
        uint64_t v26 = &v5[v31 & v24];
        uint64_t v27 = *v26;
        if (*v26 == -1) {
          goto LABEL_59;
        }
      }
    }
    return;
  }
  unsigned int v20 = 0;
  uint64_t v21 = 8 * v7;
  uint64_t v22 = v6;
  while (*v22 != a1)
  {
    if (*v22 == -2) {
      unsigned int v20 = v22;
    }
    ++v22;
    v21 -= 8;
    if (!v21)
    {
      if (!v20) {
        goto LABEL_42;
      }
      *unsigned int v20 = a1;
      --*((_DWORD *)this + 6);
      return;
    }
  }
}

void sub_1CCD425DC()
{
}

void sub_1CCD42888(uint64_t *a1, uint64_t a2, void *a3, uint64_t *a4, unsigned int a5)
{
  int v5 = (uint64_t *)a2;
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  a1[2] = 0;
  BOOL v143 = a1 + 2;
  uint64_t v145 = a3;
  *a1 = 0;
  a1[1] = 0;
  if (dword_1EBCF16D0 < a5)
  {
    uint64_t v6 = *(uint64_t ****)(a2 + 16);
    uint64_t v7 = *(void *)***v6;
    if (*(void *)(v7 + 128)
      || (*(unsigned int (**)(void))(**(void **)(v7 + 72) + 48))(*(void *)(v7 + 72)))
    {
      llvm::OptimizationRemarkAnalysis::OptimizationRemarkAnalysis((uint64_t)&v156, (uint64_t)"dfa-jump-threading", (uint64_t)"MaxPathLengthReached", 20, *v5);
      *(void *)&long long v150 = "Exploration stopped after visiting MaxPathLength=";
      *((void *)&v150 + 1) = 49;
      sub_1CC59ADEC((uint64_t *)&v161, (uint64_t)&v150);
      llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v146, "MaxPathLength", 0xDuLL, dword_1EBCF16D0);
      uint64_t v8 = sub_1CD3D6290((uint64_t)&v156, (long long *)&v146);
      *(void *)&long long v150 = " blocks.";
      *((void *)&v150 + 1) = 8;
      sub_1CC59ADEC((uint64_t *)(v8 + 80), (uint64_t)&v150);
      int v9 = *(_DWORD *)(v8 + 8);
      BYTE12(v150) = *(unsigned char *)(v8 + 12);
      DWORD2(v150) = v9;
      long long v10 = *(_OWORD *)(v8 + 16);
      v152[0] = *(void *)(v8 + 32);
      long long v151 = v10;
      uint64_t v11 = *(void *)(v8 + 72);
      long long v12 = *(_OWORD *)(v8 + 56);
      *(_OWORD *)&v152[1] = *(_OWORD *)(v8 + 40);
      *(_OWORD *)&v152[3] = v12;
      *(void *)&long long v150 = &unk_1F2616800;
      v152[5] = v11;
      char v153 = v155;
      uint64_t v154 = 0x400000000;
      if (*(_DWORD *)(v8 + 88)) {
        sub_1CD494D68((uint64_t)&v153, v8 + 80);
      }
      uint64_t v13 = *(void *)(v8 + 360);
      v155[32] = *(void *)(v8 + 352);
      v155[33] = v13;
      *(void *)&long long v150 = &unk_1F26165E0;
      if (v149 < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v146.__r_.__value_.__l.__data_);
      }
      uint64_t v156 = &unk_1F2616800;
      uint64_t v14 = (char *)v161;
      if (v162)
      {
        unint64_t v15 = (unint64_t)v162 << 6;
        do
        {
          BOOL v16 = (void **)&v14[v15];
          if (v14[v15 - 17] < 0) {
            operator delete(*(v16 - 5));
          }
          if (*((char *)v16 - 41) < 0) {
            operator delete(*(v16 - 8));
          }
          v15 -= 64;
        }
        while (v15);
        uint64_t v14 = (char *)v161;
      }
      if (v14 != (char *)&v163) {
        free(v14);
      }
      llvm::OptimizationRemarkEmitter::emit(v6, (llvm::DiagnosticInfoOptimizationBase *)&v150);
      *(void *)&long long v150 = &unk_1F2616800;
      unint64_t v139 = v153;
      if (v154)
      {
        unint64_t v140 = (unint64_t)v154 << 6;
        do
        {
          uint64_t v141 = (void **)((char *)v139 + v140);
          if (*((char *)v139 + v140 - 17) < 0) {
            operator delete(*(v141 - 5));
          }
          if (*((char *)v141 - 41) < 0) {
            operator delete(*(v141 - 8));
          }
          v140 -= 64;
        }
        while (v140);
        unint64_t v139 = v153;
      }
      if (v139 != v155)
      {
        unint64_t v136 = v139;
        goto LABEL_235;
      }
    }
    return;
  }
  LODWORD(v17) = a5;
  uint64_t v19 = a3;
  uint64_t v21 = a4[1];
  uint64_t v22 = *((unsigned int *)a4 + 5);
  if (v21 != *a4)
  {
    unsigned int v26 = *((_DWORD *)a4 + 4);
    goto LABEL_29;
  }
  if (v22)
  {
    unsigned int v23 = 0;
    uint64_t v24 = 8 * v22;
    unsigned int v25 = (void *)a4[1];
    while ((void *)*v25 != a3)
    {
      if (*v25 == -2) {
        unsigned int v23 = v25;
      }
      ++v25;
      v24 -= 8;
      if (!v24)
      {
        if (!v23) {
          goto LABEL_26;
        }
        void *v23 = a3;
        --*((_DWORD *)a4 + 6);
        goto LABEL_50;
      }
    }
    goto LABEL_50;
  }
LABEL_26:
  unsigned int v26 = *((_DWORD *)a4 + 4);
  if (v22 >= v26)
  {
LABEL_29:
    if (3 * v26 <= 4 * ((int)v22 - *((_DWORD *)a4 + 6)))
    {
      if (v26 >= 0x40) {
        v26 *= 2;
      }
      else {
        unsigned int v26 = 128;
      }
    }
    else if (v26 - v22 >= v26 >> 3)
    {
      goto LABEL_31;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a4, v26);
    unsigned int v26 = *((_DWORD *)a4 + 4);
    uint64_t v21 = a4[1];
LABEL_31:
    unsigned int v27 = v26 - 1;
    unsigned int v28 = (v26 - 1) & ((v19 >> 4) ^ (v19 >> 9));
    int v29 = (void **)(v21 + 8 * v28);
    BOOL v30 = *v29;
    if (*v29 == (void *)-1)
    {
      unsigned int v31 = 0;
LABEL_43:
      if (v31) {
        uint64_t v35 = v31;
      }
      else {
        uint64_t v35 = v29;
      }
      if (*v35 != v19)
      {
        if (*v35 == (void *)-2) {
          --*((_DWORD *)a4 + 6);
        }
        else {
          ++*((_DWORD *)a4 + 5);
        }
        *uint64_t v35 = v19;
      }
    }
    else
    {
      unsigned int v31 = 0;
      int v32 = 1;
      while (v30 != v19)
      {
        if (v31) {
          BOOL v33 = 0;
        }
        else {
          BOOL v33 = v30 == (void *)-2;
        }
        if (v33) {
          unsigned int v31 = v29;
        }
        unsigned int v34 = v28 + v32++;
        unsigned int v28 = v34 & v27;
        int v29 = (void **)(v21 + 8 * (v34 & v27));
        BOOL v30 = *v29;
        if (*v29 == (void *)-1) {
          goto LABEL_43;
        }
      }
    }
    goto LABEL_50;
  }
  *((_DWORD *)a4 + 5) = v22 + 1;
  *(void *)(v21 + 8 * v22) = a3;
LABEL_50:
  uint64_t v156 = v160;
  int v157 = v160;
  uint64_t v158 = 4;
  int v159 = 0;
  unsigned int v36 = (void *)v19[5];
  if (v36 == v19 + 5) {
    goto LABEL_209;
  }
  if (v36) {
    uint64_t v37 = v36 - 3;
  }
  else {
    uint64_t v37 = 0;
  }
  int v38 = *((unsigned __int8 *)v37 + 16);
  int v39 = v38 - 29;
  if (v38 != 30)
  {
    unsigned int v138 = 2;
    switch(v39)
    {
      case 1:
LABEL_267:
        __break(1u);
        goto LABEL_268;
      case 2:
        unsigned int v138 = (*((_DWORD *)v37 + 5) >> 1) & 0x3FFFFFF;
        goto LABEL_245;
      case 3:
      case 9:
LABEL_268:
        unsigned int v138 = (*((_DWORD *)v37 + 5) & 0x7FFFFFF) - 1;
        goto LABEL_245;
      case 4:
        goto LABEL_59;
      case 7:
        unsigned int v138 = *((_WORD *)v37 + 9) & 1;
        goto LABEL_245;
      case 8:
        unsigned int v138 = 1;
        goto LABEL_59;
      case 10:
        unsigned int v138 = *((_DWORD *)v37 + 20) + 1;
LABEL_245:
        if (!v138) {
          goto LABEL_209;
        }
        goto LABEL_59;
      default:
        goto LABEL_209;
    }
  }
  if ((*((_DWORD *)v37 + 5) & 0x7FFFFFF) == 3) {
    unsigned int v138 = 2;
  }
  else {
    unsigned int v138 = 1;
  }
LABEL_59:
  uint64_t v40 = 0;
  unsigned int v142 = v17 + 1;
  uint64_t v19 = v37 - 4;
  uint64_t v41 = v138;
  do
  {
    int v42 = *((unsigned __int8 *)v37 + 16);
    if (v42 == 30)
    {
      uint64_t v95 = (void **)&v19[-4 * v40];
    }
    else
    {
      uint64_t v94 = (v42 - 31);
      uint64_t v95 = (void **)v19;
      switch(v94)
      {
        case 1:
        case 7:
          int v117 = *((_DWORD *)v37 + 5);
          if ((v117 & 0x40000000) != 0) {
            uint64_t v118 = (void *)*(v37 - 1);
          }
          else {
            uint64_t v118 = &v37[-4 * (v117 & 0x7FFFFFF)];
          }
          uint64_t v95 = (void **)&v118[4 * (v40 + 1)];
          goto LABEL_208;
        case 2:
          uint64_t v119 = 0x1FFFFFFFFFFFFFF8;
          if (!v40) {
            uint64_t v119 = 0x1FFFFFFFFFFFFFF4;
          }
          uint64_t v95 = (void **)&v37[v119];
          break;
        case 3:
        case 4:
          goto LABEL_267;
        case 5:
          if ((*((_WORD *)v37 + 9) & 1) == 0)
          {
            unsigned int v17 = 0;
            uint64_t v19 = v37 - 4;
            goto LABEL_64;
          }
          uint64_t v120 = *((_DWORD *)v37 + 5) & 0x7FFFFFF;
          uint64_t v121 = v37 + 4;
          goto LABEL_207;
        case 6:
          break;
        case 8:
          if (v40)
          {
            uint64_t v19 = v37 - 4;
            uint64_t v95 = (void **)&v37[4 * v40 - 8 + -4 * *((unsigned int *)v37 + 20)];
          }
          else
          {
            uint64_t v120 = *((unsigned int *)v37 + 20);
            uint64_t v121 = v37 - 8;
LABEL_207:
            uint64_t v95 = (void **)&v121[-4 * v120];
LABEL_208:
            uint64_t v19 = v37 - 4;
          }
          break;
        default:
          int v96 = *((_DWORD *)v37 + 5);
          if ((v96 & 0x40000000) != 0) {
            uint64_t v97 = (void *)*(v37 - 1);
          }
          else {
            uint64_t v97 = &v37[-4 * (v96 & 0x7FFFFFF)];
          }
          uint64_t v95 = (void **)&v97[4 * (2 * v40) + 4];
          break;
      }
    }
    unsigned int v17 = *v95;
LABEL_64:
    unsigned int v43 = (char *)v157;
    uint64_t v44 = HIDWORD(v158);
    if (v157 == v156)
    {
      if (HIDWORD(v158))
      {
        unsigned int v45 = 0;
        uint64_t v46 = 8 * HIDWORD(v158);
        uint64_t v47 = v157;
        while ((void *)*v47 != v17)
        {
          if (*v47 == -2) {
            unsigned int v45 = v47;
          }
          ++v47;
          v46 -= 8;
          if (!v46)
          {
            if (!v45) {
              goto LABEL_73;
            }
            void *v45 = v17;
            --v159;
            goto LABEL_96;
          }
        }
        goto LABEL_145;
      }
LABEL_73:
      unsigned int v48 = v158;
      if (HIDWORD(v158) < v158)
      {
        ++HIDWORD(v158);
        *((void *)v157 + v44) = v17;
        goto LABEL_96;
      }
    }
    else
    {
      unsigned int v48 = v158;
    }
    if (3 * v48 <= 4 * (HIDWORD(v158) - v159))
    {
      if (v48 >= 0x40) {
        v48 *= 2;
      }
      else {
        unsigned int v48 = 128;
      }
    }
    else if (v48 - HIDWORD(v158) >= v48 >> 3)
    {
      goto LABEL_77;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v156, v48);
    unsigned int v48 = v158;
    unsigned int v43 = (char *)v157;
LABEL_77:
    unsigned int v49 = v48 - 1;
    unsigned int v50 = (v48 - 1) & ((v17 >> 4) ^ (v17 >> 9));
    unsigned int v51 = &v43[8 * v50];
    int v52 = *(void **)v51;
    if (*(void *)v51 == -1)
    {
      long long v56 = 0;
LABEL_88:
      if (v56) {
        uint64_t v57 = v56;
      }
      else {
        uint64_t v57 = v51;
      }
      if (*(void **)v57 != v17)
      {
        if (*(void *)v57 == -2) {
          --v159;
        }
        else {
          ++HIDWORD(v158);
        }
        *(void *)uint64_t v57 = v17;
LABEL_96:
        if (v17 == (void *)v5[1])
        {
          int v164 = v145;
          long long v150 = 0u;
          long long v151 = 0u;
          *(_OWORD *)uint64_t v152 = 0u;
          sub_1CD76222C((uint64_t)&v150, 1uLL);
          uint64_t v86 = v152[1];
          uint64_t v87 = v152[0];
          int v88 = (uint64_t *)(*((void *)&v150 + 1) + 8 * ((v152[0] + v152[1]) >> 9));
          uint64_t v89 = *v88;
          uint64_t v90 = *v88 + 8 * ((v152[0] + v152[1]) & 0x1FFLL);
          if ((void)v151 == *((void *)&v150 + 1)) {
            uint64_t v90 = 0;
          }
          uint64_t v91 = (v90 - v89) >> 3;
          if (v90 - v89 < -7)
          {
            unint64_t v98 = 510 - v91;
            __int16 v92 = ~(_WORD)v98;
            unint64_t v93 = &v88[-(v98 >> 9)];
          }
          else
          {
            __int16 v92 = v91 + 1;
            unint64_t v93 = &v88[(unint64_t)(v91 + 1) >> 9];
          }
          uint64_t v99 = *v93 + 8 * (v92 & 0x1FF);
          if (v90 != v99)
          {
            int v100 = &v164;
            do
            {
              BOOL v101 = (void *)(v89 + 4096);
              if (v88 == v93) {
                BOOL v101 = (void *)v99;
              }
              if ((void *)v90 == v101)
              {
                BOOL v101 = (void *)v90;
              }
              else
              {
                int v102 = (void *)v90;
                do
                {
                  uint64_t v103 = (uint64_t)*v100++;
                  *v102++ = v103;
                }
                while (v102 != v101);
              }
              v86 += ((uint64_t)v101 - v90) >> 3;
              if (v88 == v93) {
                break;
              }
              uint64_t v104 = v88[1];
              ++v88;
              uint64_t v89 = v104;
              uint64_t v90 = v104;
            }
            while (v104 != v99);
            v152[1] = v86;
          }
          int v105 = (_OWORD *)a1[1];
          unint64_t v106 = a1[2];
          if ((unint64_t)v105 >= v106)
          {
            uint64_t v107 = v5;
            unint64_t v108 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v105 - *a1) >> 4);
            unint64_t v109 = v108 + 1;
            if (v108 + 1 > 0x555555555555555) {
LABEL_265:
            }
              abort();
            unint64_t v110 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v106 - *a1) >> 4);
            if (2 * v110 > v109) {
              unint64_t v109 = 2 * v110;
            }
            if (v110 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v109 = 0x555555555555555;
            }
            int v148 = v143;
            if (v109 > 0x555555555555555) {
LABEL_266:
            }
              sub_1CB833614();
            uint64_t v111 = 3 * v109;
            uint64_t v112 = (char *)operator new(48 * v109);
            std::string::size_type v113 = (std::string::size_type)&v112[48 * v108];
            v146.__r_.__value_.__r.__words[0] = (std::string::size_type)v112;
            v146.__r_.__value_.__l.__size_ = v113;
            *(_OWORD *)std::string::size_type v113 = v150;
            uint64_t v114 = *((void *)&v151 + 1);
            *(void *)(v113 + 16) = v151;
            *(void *)(v113 + 24) = v114;
            long long v150 = 0u;
            long long v151 = 0u;
            *(void *)(v113 + 32) = v87;
            *(void *)(v113 + 40) = v86;
            *(_OWORD *)uint64_t v152 = 0uLL;
            v146.__r_.__value_.__r.__words[2] = v113 + 48;
            long long __p = &v112[16 * v111];
            sub_1CD762184(a1, &v146);
            unsigned int v17 = (void *)a1[1];
            uint64_t v115 = (void **)v146.__r_.__value_.__r.__words[2];
            std::string::size_type size = v146.__r_.__value_.__l.__size_;
            while (v115 != (void **)size)
              uint64_t v115 = sub_1CB904DFC(v115 - 6);
            if (v146.__r_.__value_.__r.__words[0]) {
              operator delete(v146.__r_.__value_.__l.__data_);
            }
            int v5 = v107;
            uint64_t v19 = v37 - 4;
          }
          else
          {
            *int v105 = v150;
            v105[1] = v151;
            long long v150 = 0u;
            long long v151 = 0u;
            v105[2] = *(_OWORD *)v152;
            unsigned int v17 = v105 + 3;
            *(_OWORD *)uint64_t v152 = 0uLL;
          }
          a1[1] = (uint64_t)v17;
          sub_1CB904DFC((void **)&v150);
        }
        else
        {
          uint64_t v59 = *a4;
          uint64_t v58 = a4[1];
          if (v58 == *a4)
          {
            uint64_t v60 = *((unsigned int *)a4 + 5);
            uint64_t v61 = (void *)(v58 + 8 * v60);
            if (v60)
            {
              uint64_t v62 = 0;
              while (*(void **)(v58 + v62) != v17)
              {
                v62 += 8;
                if (8 * v60 == v62) {
                  goto LABEL_118;
                }
              }
              uint64_t v61 = (void *)(v58 + v62);
            }
LABEL_118:
            uint64_t v59 = a4[1];
          }
          else
          {
            uint64_t v63 = *((unsigned int *)a4 + 4);
            int v64 = v63 - 1;
            unsigned int v65 = (v63 - 1) & ((v17 >> 4) ^ (v17 >> 9));
            uint64_t v61 = (void *)(v58 + 8 * v65);
            int v66 = (void *)*v61;
            if (*v61 == -1)
            {
              uint64_t v84 = 0;
LABEL_147:
              if (v84) {
                uint64_t v61 = v84;
              }
              LODWORD(v60) = *((_DWORD *)a4 + 5);
              int v85 = (void *)(v58 + 8 * v63);
              if ((void *)*v61 != v17) {
                uint64_t v61 = v85;
              }
            }
            else
            {
              uint64_t v84 = 0;
              int v67 = 1;
              while (v66 != v17)
              {
                if (v84) {
                  BOOL v68 = 0;
                }
                else {
                  BOOL v68 = v66 == (void *)-2;
                }
                if (v68) {
                  uint64_t v84 = v61;
                }
                unsigned int v69 = v65 + v67++;
                unsigned int v65 = v69 & v64;
                uint64_t v61 = (void *)(v58 + 8 * (v69 & v64));
                int v66 = (void *)*v61;
                if (*v61 == -1) {
                  goto LABEL_147;
                }
              }
              LODWORD(v60) = *((_DWORD *)a4 + 5);
            }
          }
          if (v58 == v59) {
            unsigned int v70 = v60;
          }
          else {
            unsigned int v70 = *((_DWORD *)a4 + 4);
          }
          if (v61 == (void *)(v58 + 8 * v70))
          {
            sub_1CCD42888(v144, v5, v17, a4, v142);
            unsigned int v17 = (void *)v144[0];
            unsigned int v71 = (void *)v144[1];
            while (v17 != v71)
            {
              sub_1CD76248C((uint64_t)&v150, v17);
              sub_1CD76248C((uint64_t)&v146, &v150);
              sub_1CD460B24(&v146, &v145);
              unint64_t v72 = a1[1];
              unint64_t v73 = a1[2];
              if (v72 >= v73)
              {
                unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v72 - *a1) >> 4);
                unint64_t v76 = v75 + 1;
                if (v75 + 1 > 0x555555555555555) {
                  goto LABEL_265;
                }
                unsigned int v77 = v5;
                unint64_t v78 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - *a1) >> 4);
                if (2 * v78 > v76) {
                  unint64_t v76 = 2 * v78;
                }
                if (v78 >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v79 = 0x555555555555555;
                }
                else {
                  unint64_t v79 = v76;
                }
                uint64_t v168 = v143;
                if (v79)
                {
                  if (v79 > 0x555555555555555) {
                    goto LABEL_266;
                  }
                  uint64_t v80 = (char *)operator new(48 * v79);
                }
                else
                {
                  uint64_t v80 = 0;
                }
                uint64_t v81 = (uint64_t)&v80[48 * v75];
                int v164 = v80;
                uint64_t v165 = v81;
                long long v167 = &v80[48 * v79];
                sub_1CD76248C(v81, &v146);
                uint64_t v166 = (void **)(v81 + 48);
                sub_1CD762184(a1, &v164);
                uint64_t v74 = a1[1];
                uint64_t v83 = (void **)v165;
                for (uint64_t i = v166; i != v83; uint64_t i = sub_1CB904DFC(i - 6))
                  ;
                if (v164) {
                  operator delete(v164);
                }
                int v5 = v77;
                uint64_t v19 = v37 - 4;
              }
              else
              {
                uint64_t v74 = sub_1CD76248C(v72, &v146) + 48;
              }
              a1[1] = v74;
              sub_1CB904DFC((void **)&v146.__r_.__value_.__l.__data_);
              sub_1CB904DFC((void **)&v150);
              v17 += 6;
            }
            *(void *)&long long v150 = v144;
            sub_1CCD43AC4((void ***)&v150);
          }
        }
      }
    }
    else
    {
      long long v56 = 0;
      int v53 = 1;
      while (v52 != v17)
      {
        if (v56) {
          BOOL v54 = 0;
        }
        else {
          BOOL v54 = v52 == (void *)-2;
        }
        if (v54) {
          long long v56 = v51;
        }
        unsigned int v55 = v50 + v53++;
        unsigned int v50 = v55 & v49;
        unsigned int v51 = &v43[8 * (v55 & v49)];
        int v52 = *(void **)v51;
        if (*(void *)v51 == -1) {
          goto LABEL_88;
        }
      }
    }
LABEL_145:
    ++v40;
  }
  while (v40 != v41);
  uint64_t v19 = v145;
LABEL_209:
  uint64_t v123 = *a4;
  uint64_t v122 = a4[1];
  if (v122 == *a4)
  {
    uint64_t v124 = *((unsigned int *)a4 + 5);
    uint64_t v125 = (void *)(v122 + 8 * v124);
    if (v124)
    {
      uint64_t v126 = 0;
      while (*(void **)(v122 + v126) != v19)
      {
        v126 += 8;
        if (8 * v124 == v126) {
          goto LABEL_228;
        }
      }
      uint64_t v125 = (void *)(v122 + v126);
    }
LABEL_228:
    uint64_t v123 = a4[1];
  }
  else
  {
    uint64_t v127 = *((unsigned int *)a4 + 4);
    int v128 = v127 - 1;
    unsigned int v129 = (v127 - 1) & ((v19 >> 4) ^ (v19 >> 9));
    uint64_t v125 = (void *)(v122 + 8 * v129);
    uint64_t v130 = (void *)*v125;
    if (*v125 == -1)
    {
      uint64_t v131 = 0;
LABEL_238:
      if (v131) {
        uint64_t v125 = v131;
      }
      LODWORD(v124) = *((_DWORD *)a4 + 5);
      uint64_t v137 = (void *)(v122 + 8 * v127);
      if ((void *)*v125 != v19) {
        uint64_t v125 = v137;
      }
    }
    else
    {
      uint64_t v131 = 0;
      int v132 = 1;
      while (v130 != v19)
      {
        if (v131) {
          BOOL v133 = 0;
        }
        else {
          BOOL v133 = v130 == (void *)-2;
        }
        if (v133) {
          uint64_t v131 = v125;
        }
        unsigned int v134 = v129 + v132++;
        unsigned int v129 = v134 & v128;
        uint64_t v125 = (void *)(v122 + 8 * (v134 & v128));
        uint64_t v130 = (void *)*v125;
        if (*v125 == -1) {
          goto LABEL_238;
        }
      }
      LODWORD(v124) = *((_DWORD *)a4 + 5);
    }
  }
  if (v122 == v123) {
    unsigned int v135 = v124;
  }
  else {
    unsigned int v135 = *((_DWORD *)a4 + 4);
  }
  if (v125 != (void *)(v122 + 8 * v135))
  {
    *uint64_t v125 = -2;
    ++*((_DWORD *)a4 + 6);
  }
  unint64_t v136 = v157;
  if (v157 != v156) {
LABEL_235:
  }
    free(v136);
}

void sub_1CCD4368C(void *a1, void *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = ((v9 - v8) << 6) - 1;
  }
  uint64_t v11 = a1[5];
  unint64_t v12 = v11 + a1[4];
  unint64_t v13 = v10 - v12;
  if (a4 > v13)
  {
    sub_1CD76222C((uint64_t)a1, a4 - v13);
    uint64_t v11 = a1[5];
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v12 = a1[4] + v11;
  }
  uint64_t v14 = (void *)(v8 + 8 * (v12 >> 9));
  if (v9 == v8)
  {
    uint64_t v15 = 0;
    if (a4) {
      goto LABEL_8;
    }
LABEL_11:
    uint64_t v18 = v15;
    unsigned int v17 = v14;
    goto LABEL_14;
  }
  uint64_t v15 = *v14 + 8 * (v12 & 0x1FF);
  if (!a4) {
    goto LABEL_11;
  }
LABEL_8:
  uint64_t v16 = a4 + ((v15 - *v14) >> 3);
  if (v16 < 1)
  {
    unint64_t v19 = 511 - v16;
    LOWORD(v16) = ~(511 - v16);
    unsigned int v17 = &v14[-(v19 >> 9)];
  }
  else
  {
    unsigned int v17 = &v14[(unint64_t)v16 >> 9];
  }
  uint64_t v18 = *v17 + 8 * (v16 & 0x1FF);
LABEL_14:
  if (v15 != v18)
  {
    do
    {
      uint64_t v20 = v18;
      if (v14 != v17) {
        uint64_t v20 = *v14 + 4096;
      }
      if (v15 == v20)
      {
        uint64_t v20 = v15;
      }
      else
      {
        uint64_t v21 = (void *)v15;
        do
        {
          uint64_t v22 = *a3++;
          *v21++ = v22;
          if ((uint64_t *)((char *)a3 - *a2) == (uint64_t *)4096)
          {
            unsigned int v23 = (uint64_t *)a2[1];
            ++a2;
            a3 = v23;
          }
        }
        while (v21 != (void *)v20);
      }
      v11 += (v20 - v15) >> 3;
      if (v14 == v17) {
        break;
      }
      uint64_t v24 = v14[1];
      ++v14;
      uint64_t v15 = v24;
    }
    while (v24 != v18);
    a1[5] = v11;
  }
}

void sub_1CCD437EC(void *a1, void *a2, unsigned char *a3, unint64_t a4)
{
  unint64_t v7 = a1[5];
  if (v7 >= a4)
  {
    uint64_t v14 = a1[1];
    uint64_t v15 = (void **)(v14 + 8 * (a1[4] >> 9));
    if (a1[2] == v14)
    {
      uint64_t v16 = 0;
      if (a4) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v16 = (uint64_t)*v15 + 8 * (a1[4] & 0x1FFLL);
      if (a4)
      {
LABEL_14:
        uint64_t v17 = a4 + ((uint64_t)&a3[-*a2] >> 3);
        if (v17 < 1)
        {
          unint64_t v20 = 511 - v17;
          uint64_t v18 = (unsigned char **)&a2[-(v20 >> 9)];
          unint64_t v19 = &(*v18)[8 * (~(_WORD)v20 & 0x1FF)];
        }
        else
        {
          uint64_t v18 = (unsigned char **)&a2[(unint64_t)v17 >> 9];
          unint64_t v19 = &(*v18)[8 * (v17 & 0x1FF)];
        }
        goto LABEL_19;
      }
    }
    unint64_t v19 = a3;
    uint64_t v18 = (unsigned char **)a2;
LABEL_19:
    uint64_t v21 = v15;
    uint64_t v22 = v16;
    sub_1CC3806EC(a2, a3, v18, v19, &v21);
    sub_1CD762618((BOOL)a1, (char *)v21, v22);
    return;
  }
  if (v7)
  {
    uint64_t v8 = v7 + ((uint64_t)&a3[-*a2] >> 3);
    if (v8 < 1)
    {
      unint64_t v11 = 511 - v8;
      uint64_t v9 = (unsigned char **)&a2[-(v11 >> 9)];
      uint64_t v10 = (uint64_t *)&(*v9)[8 * (~(_WORD)v11 & 0x1FF)];
    }
    else
    {
      uint64_t v9 = (unsigned char **)&a2[(unint64_t)v8 >> 9];
      uint64_t v10 = (uint64_t *)&(*v9)[8 * (v8 & 0x1FF)];
    }
  }
  else
  {
    uint64_t v10 = (uint64_t *)a3;
    uint64_t v9 = (unsigned char **)a2;
  }
  uint64_t v12 = a1[1];
  if (a1[2] == v12) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)(v12 + 8 * (a1[4] >> 9)) + 8 * (a1[4] & 0x1FFLL);
  }
  uint64_t v21 = (void **)(v12 + 8 * (a1[4] >> 9));
  uint64_t v22 = v13;
  sub_1CC3806EC(a2, a3, v9, v10, &v21);
  sub_1CCD4368C(a1, v9, v10, a4 - a1[5]);
}

void *sub_1CCD43998(void *a1, void *a2, void **a3, void *a4, void *a5)
{
  if (a1 == a3)
  {
    if (a2 != a4)
    {
      while (*a2 != *a5)
      {
        if (++a2 == a4)
        {
          a2 = a4;
          break;
        }
      }
    }
    if (a1)
    {
      if ((void *)(*a1 + 4096) == a2) {
        ++a1;
      }
      return a1;
    }
    return 0;
  }
  else
  {
    uint64_t v5 = *a1 + 4096;
    if ((void *)v5 != a2)
    {
      while (*a2 != *a5)
      {
        if (++a2 == (void *)v5) {
          goto LABEL_5;
        }
      }
      return a1;
    }
LABEL_5:
    uint64_t v6 = a1 + 1;
    if (a1 + 1 != a3)
    {
LABEL_6:
      uint64_t v7 = 0;
      a1 = v6;
      uint64_t v8 = *v6;
      while (*(void *)(v8 + v7) != *a5)
      {
        v7 += 8;
        if (v7 == 4096)
        {
          uint64_t v6 = a1 + 1;
          if (a1 + 1 != a3) {
            goto LABEL_6;
          }
          goto LABEL_10;
        }
      }
      return a1;
    }
LABEL_10:
    uint64_t v9 = *a3;
    if (*a3 != a4)
    {
      uint64_t v10 = 0;
      do
      {
        if (*v9 == *a5) {
          break;
        }
        ++v10;
        ++v9;
      }
      while (v9 != a4);
      if (v10 == 512)
      {
        a1 += 2;
        return a1;
      }
    }
  }
  return a3;
}

void sub_1CCD43AC4(void ***a1)
{
  int v1 = *a1;
  unsigned int v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        unint64_t v4 = sub_1CB904DFC(v4 - 6);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void **sub_1CCD43B48(void **a1)
{
  unsigned int v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    unint64_t v4 = v2;
    if (v3 != v2)
    {
      do
        uint64_t v3 = sub_1CB904DFC(v3 - 9);
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1CCD43BA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a1;
  unint64_t v4 = sub_1CCD43C60(a3, &v12);
  uint64_t v6 = (const void *)*v4;
  uint64_t v5 = v4[1];
  int64_t v7 = v5 - *v4;
  if (v5 == *v4) {
    return 0;
  }
  if (v7 < 0) {
    abort();
  }
  uint64_t v8 = (char *)operator new(v5 - *v4);
  memmove(v8, v6, v7);
  uint64_t v9 = 0;
  while (*(void *)&v8[v9 + 8] != a2)
  {
    v9 += 16;
    if (16 * (v7 >> 4) == v9)
    {
      uint64_t v10 = 0;
      goto LABEL_9;
    }
  }
  uint64_t v10 = *(void *)&v8[v9];
LABEL_9:
  operator delete(v8);
  return v10;
}

uint64_t *sub_1CCD43C60(uint64_t a1, uint64_t *a2)
{
  unsigned int v25 = 0;
  char v4 = sub_1CBF98030(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v25);
  uint64_t v5 = v25;
  if (v4) {
    return v5 + 1;
  }
  unsigned int v26 = v25;
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (4 * v6 + 4 >= (3 * v7))
  {
    int v8 = 2 * v7;
    goto LABEL_9;
  }
  int v8 = *(_DWORD *)(a1 + 16);
  if ((int)v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    uint64_t v10 = *(void *)a1;
    unint64_t v11 = (v8 - 1) | ((unint64_t)(v8 - 1) >> 1);
    unint64_t v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
    int v13 = ((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8);
    if ((v13 + 1) > 0x40) {
      unsigned int v14 = v13 + 1;
    }
    else {
      unsigned int v14 = 64;
    }
    *(_DWORD *)(a1 + 16) = v14;
    uint64_t v15 = operator new(32 * v14, (std::align_val_t)8uLL);
    *(void *)a1 = v15;
    if (v10)
    {
      *(void *)(a1 + 8) = 0;
      uint64_t v16 = *(unsigned int *)(a1 + 16);
      if (v16)
      {
        uint64_t v17 = 32 * v16;
        do
        {
          *uint64_t v15 = -4096;
          v15 += 4;
          v17 -= 32;
        }
        while (v17);
      }
      if (v7)
      {
        int v18 = 0;
        uint64_t v19 = 32 * v7;
        uint64_t v20 = v10;
        do
        {
          uint64_t v21 = *(void *)v20;
          if ((*(void *)v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            unsigned int v27 = 0;
            sub_1CBF98030(*(void *)a1, *(_DWORD *)(a1 + 16), v21, &v27);
            uint64_t v22 = v27;
            uint64_t *v27 = v21;
            v22[1] = 0;
            void v22[2] = 0;
            v22[3] = 0;
            *(_OWORD *)(v22 + 1) = *(_OWORD *)(v20 + 8);
            v22[3] = *(void *)(v20 + 24);
            ++v18;
            *(void *)(v20 + 8) = 0;
            *(void *)(v20 + 16) = 0;
            *(void *)(v20 + 24) = 0;
            *(_DWORD *)(a1 + 8) = v18;
          }
          v20 += 32;
          v19 -= 32;
        }
        while (v19);
      }
      MEMORY[0x1D25D9CD0](v10, 8);
      uint64_t v15 = *(void **)a1;
      LODWORD(v23) = *(_DWORD *)(a1 + 16);
    }
    else
    {
      *(void *)(a1 + 8) = 0;
      uint64_t v23 = *(unsigned int *)(a1 + 16);
      if (v23)
      {
        uint64_t v24 = 0;
        do
        {
          v15[v24] = -4096;
          v24 += 4;
        }
        while (4 * v23 != v24);
      }
    }
    sub_1CBF98030((uint64_t)v15, v23, *a2, &v26);
    int v6 = *(_DWORD *)(a1 + 8);
    uint64_t v5 = v26;
  }
  *(_DWORD *)(a1 + 8) = v6 + 1;
  if (*v5 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *uint64_t v5 = *a2;
  v5[1] = 0;
  void v5[2] = 0;
  v5[3] = 0;
  return v5 + 1;
}

uint64_t *sub_1CCD43E64(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = (void *)(v3 + 16);
    do
    {
      if ((*(v5 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int v6 = (void *)*(v5 - 1);
        if (v6)
        {
          *uint64_t v5 = v6;
          operator delete(v6);
        }
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CCD43EDC(uint64_t a1, unint64_t a2, llvm::BasicBlock *a3, uint64_t a4)
{
  v54[4] = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CCD4435C(*(void *)(a2 + 8), a1);
  if (result)
  {
    uint64_t v52 = a4;
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8 == a1 + 40)
    {
      uint64_t v10 = 0;
    }
    else
    {
      if (v8) {
        uint64_t v9 = v8 - 24;
      }
      else {
        uint64_t v9 = 0;
      }
      if (*(unsigned __int8 *)(v9 + 16) - 29 >= 0xB) {
        uint64_t v10 = 0;
      }
      else {
        uint64_t v10 = v9;
      }
    }
    unint64_t v11 = 0;
    uint64_t v12 = v10 - 32;
    while (1)
    {
      int v13 = *(unsigned __int8 *)(v10 + 16);
      if (v13 == 30)
      {
        unsigned int v14 = (*(_DWORD *)(v10 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
      }
      else
      {
        unsigned int v14 = 0;
        switch(*(unsigned char *)(v10 + 16))
        {
          case 0x1E:
LABEL_86:
            __break(1u);
            JUMPOUT(0x1CCD4430CLL);
          case 0x1F:
            unsigned int v14 = (*(_DWORD *)(v10 + 20) >> 1) & 0x3FFFFFF;
            break;
          case 0x20:
          case 0x26:
            unsigned int v14 = (*(_DWORD *)(v10 + 20) & 0x7FFFFFF) - 1;
            break;
          case 0x21:
            unsigned int v14 = 2;
            break;
          case 0x24:
            unsigned int v14 = *(_WORD *)(v10 + 18) & 1;
            break;
          case 0x25:
            unsigned int v14 = 1;
            break;
          case 0x27:
            unsigned int v14 = *(_DWORD *)(v10 + 80) + 1;
            break;
          default:
            break;
        }
      }
      if (v11 >= v14) {
        break;
      }
      if (v13 == 30)
      {
        uint64_t v15 = (uint64_t **)(v12 - 32 * v11);
      }
      else
      {
        uint64_t v20 = (v13 - 31);
        uint64_t v15 = (uint64_t **)(v10 - 32);
        switch(v20)
        {
          case 1:
          case 7:
            int v47 = *(_DWORD *)(v10 + 20);
            if ((v47 & 0x40000000) != 0) {
              uint64_t v48 = *(void *)(v10 - 8);
            }
            else {
              uint64_t v48 = v10 - 32 * (v47 & 0x7FFFFFF);
            }
            uint64_t v15 = (uint64_t **)(v48 + 32 * v11 + 32);
            break;
          case 2:
            uint64_t v49 = -64;
            if (!v11) {
              uint64_t v49 = -96;
            }
            uint64_t v15 = (uint64_t **)(v10 + v49);
            break;
          case 3:
          case 4:
            goto LABEL_86;
          case 5:
            if ((*(_WORD *)(v10 + 18) & 1) == 0)
            {
              uint64_t v16 = 0;
              goto LABEL_19;
            }
            uint64_t v50 = *(_DWORD *)(v10 + 20) & 0x7FFFFFF;
            uint64_t v51 = v10 + 32;
            goto LABEL_82;
          case 6:
            break;
          case 8:
            if (v11)
            {
              uint64_t v15 = (uint64_t **)(v12 - 32 * *(unsigned int *)(v10 + 80) + 32 * v11 - 32);
            }
            else
            {
              uint64_t v50 = *(unsigned int *)(v10 + 80);
              uint64_t v51 = v10 - 64;
LABEL_82:
              uint64_t v15 = (uint64_t **)(v51 - 32 * v50);
            }
            break;
          default:
            int v21 = *(_DWORD *)(v10 + 20);
            if ((v21 & 0x40000000) != 0) {
              uint64_t v22 = *(void *)(v10 - 8);
            }
            else {
              uint64_t v22 = v10 - 32 * (v21 & 0x7FFFFFF);
            }
            uint64_t v15 = (uint64_t **)(v22 + 32 * (2 * v11) + 32);
            break;
        }
      }
      uint64_t v16 = *v15;
LABEL_19:
      if (v16 == (uint64_t *)a2)
      {
        if (*(void *)(a2 + 40) != a2 + 40)
        {
          uint64_t v17 = *(void *)(a2 + 48);
          uint64_t v18 = v17 - 24;
          uint64_t v19 = v17 ? v17 - 24 : 0;
          if (*(unsigned char *)(v19 + 16) == 83)
          {
            do
            {
              uint64_t v32 = *(void *)(v18 + 32);
              uint64_t v33 = v32 - 24;
              if (!v32) {
                uint64_t v33 = 0;
              }
              int v34 = *(unsigned __int8 *)(v33 + 16);
              if (v34 == 83) {
                uint64_t v35 = v33;
              }
              else {
                uint64_t v35 = 0;
              }
              int v36 = *(_DWORD *)(v18 + 20);
              uint64_t v37 = v36 & 0x7FFFFFF;
              if ((v36 & 0x7FFFFFF) != 0)
              {
                uint64_t v38 = 0;
                while (1)
                {
                  uint64_t v39 = v18 - 32 * v37;
                  if ((v36 & 0x40000000) != 0) {
                    uint64_t v39 = *(void *)(v18 - 8);
                  }
                  if (*(void *)(v39 + 32 * *(unsigned int *)(v18 + 60) + 8 * v38) == a1) {
                    break;
                  }
                  if (v37 == ++v38) {
                    goto LABEL_47;
                  }
                }
                uint64_t v40 = v38;
              }
              else
              {
LABEL_47:
                uint64_t v40 = 0xFFFFFFFFLL;
              }
              uint64_t v41 = v37;
              if ((v36 & 0x40000000) != 0)
              {
                uint64_t v23 = *(void *)(v18 - 8);
                uint64_t v24 = v23 + 32 * v40;
                unsigned int v25 = (uint64_t *)(v23 + 32 * v41);
              }
              else
              {
                uint64_t v23 = v18 - 32 * v37;
                uint64_t v24 = v23 + 32 * v40;
                unsigned int v25 = (uint64_t *)v18;
              }
              sub_1CC5E4108((uint64_t)v54, (uint64_t *)(v24 + 32), v25, v23 + 32 * v40);
              int v42 = *(_DWORD *)(v18 + 20);
              if ((v42 & 0x40000000) != 0)
              {
                uint64_t v27 = *(void *)(v18 - 8);
                uint64_t v28 = *(unsigned int *)(v18 + 60);
                uint64_t v29 = v27 + 32 * v28;
                uint64_t v26 = v42 & 0x7FFFFFF;
              }
              else
              {
                uint64_t v26 = v42 & 0x7FFFFFF;
                uint64_t v27 = v18 - 32 * v26;
                uint64_t v28 = *(unsigned int *)(v18 + 60);
                uint64_t v29 = v27 + 32 * v28;
              }
              unsigned int v43 = (unsigned char *)(v29 + 8 * v26);
              uint64_t v44 = (unsigned char *)(v29 + 8 * v40 + 8);
              if (v43 != v44)
              {
                memmove((void *)(v27 + 32 * v28 + 8 * v40), v44, v43 - v44);
                int v42 = *(_DWORD *)(v18 + 20);
              }
              if ((v42 & 0x40000000) != 0)
              {
                uint64_t v31 = *(void *)(v18 - 8);
                uint64_t v30 = v42 & 0x7FFFFFF;
              }
              else
              {
                uint64_t v30 = v42 & 0x7FFFFFF;
                uint64_t v31 = v18 - 32 * v30;
              }
              uint64_t v45 = v31 + 32 * v30;
              if (*(void *)(v45 - 32))
              {
                **(void **)(v45 - 16) = *(void *)(v45 - 24);
                uint64_t v46 = *(void *)(v45 - 24);
                if (v46) {
                  *(void *)(v46 + 16) = *(void *)(v45 - 16);
                }
              }
              *(void *)(v45 - 32) = 0;
              *(_DWORD *)(v18 + 20) = *(_DWORD *)(v18 + 20) & 0xF8000000 | (*(_DWORD *)(v18 + 20) - 1) & 0x7FFFFFF;
              if (!v32) {
                break;
              }
              uint64_t v18 = v35;
            }
            while (v34 == 83);
          }
        }
        llvm::Instruction::setSuccessor(v10, v11, a3);
      }
      ++v11;
    }
    v54[0] = a1;
    v54[1] = a2 | 4;
    v54[2] = a1;
    v54[3] = (unint64_t)a3 & 0xFFFFFFFFFFFFFFFBLL;
    return llvm::DomTreeUpdater::applyUpdates(v52, v54, 2);
  }
  return result;
}

BOOL sub_1CCD4435C(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    while (1)
    {
      uint64_t v2 = *(void *)(a1 + 24);
      unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
      BOOL v4 = v2 && v3 >= 0x1C;
      if (v4 && v3 - 29 <= 0xA) {
        break;
      }
      a1 = *(void *)(a1 + 8);
      if (!a1) {
        return a1 != 0;
      }
    }
LABEL_20:
    if (*(void *)(v2 + 40) != a2)
    {
      while (1)
      {
        a1 = *(void *)(a1 + 8);
        if (!a1) {
          break;
        }
        uint64_t v2 = *(void *)(a1 + 24);
        unsigned int v6 = *(unsigned __int8 *)(v2 + 16);
        if (v2) {
          BOOL v7 = v6 >= 0x1C;
        }
        else {
          BOOL v7 = 0;
        }
        if (v7 && v6 - 29 <= 0xA) {
          goto LABEL_20;
        }
      }
    }
  }
  return a1 != 0;
}

uint64_t sub_1CCD443C4(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20);
  int v3 = (v2 >> 1) & 0x3FFFFFF;
  uint64_t v4 = (v3 - 1);
  if (v3 == 1) {
    goto LABEL_16;
  }
  uint64_t v5 = 0;
  uint64_t v6 = a1 - 32 * (v2 & 0x7FFFFFF);
  uint64_t v7 = 2 * v4;
  while (1)
  {
    uint64_t v8 = a1 - 32 * (v2 & 0x7FFFFFF);
    if ((v2 & 0x40000000) != 0) {
      uint64_t v8 = *(void *)(a1 - 8);
    }
    uint64_t v9 = *(void *)(v8 + 32 * ((v5 + 2) & 0xFFFFFFFE));
    uint64_t v10 = (void *)(v9 + 24);
    if (*(_DWORD *)(v9 + 32) >= 0x41u) {
      uint64_t v10 = (void *)*v10;
    }
    if (*v10 == a2) {
      break;
    }
    v5 += 2;
    if (v7 == v5) {
      goto LABEL_16;
    }
  }
  if ((v2 & 0x40000000) != 0) {
    uint64_t v6 = *(void *)(a1 - 8);
  }
  uint64_t v11 = v5 == 0x1FFFFFFFCLL ? 1 : (v5 + 3);
  uint64_t v12 = *(void *)(v6 + 32 * v11);
  if (!v12)
  {
LABEL_16:
    if ((v2 & 0x40000000) != 0) {
      uint64_t v13 = *(void *)(a1 - 8);
    }
    else {
      uint64_t v13 = a1 - 32 * (v2 & 0x7FFFFFF);
    }
    return *(void *)(v13 + 32);
  }
  return v12;
}

uint64_t sub_1CCD44474(uint64_t result, char *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (char *)result;
LABEL_2:
  uint64_t v10 = a2 - 16;
  uint64_t v11 = v9;
  while (1)
  {
    uint64_t v9 = v11;
    uint64_t v12 = a2 - v11;
    uint64_t v13 = (a2 - v11) >> 4;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v188 = *((void *)a2 - 2);
          uint64_t v189 = *(void *)v11;
          if (v188 == *(void *)v11)
          {
            uint64_t v372 = *((void *)a2 - 1);
            uint64_t v373 = *((void *)v11 + 1);
            uint64_t v374 = *(void *)(v372 + 40);
            int v375 = *(__int16 *)(v374 + 18);
            if ((v375 & 0x80000000) == 0)
            {
              uint64_t v380 = *(void *)(v374 + 48);
              if (v380 != v374 + 40)
              {
                int v381 = 0;
                do
                {
                  uint64_t v382 = v380 - 24;
                  if (!v380) {
                    uint64_t v382 = 0;
                  }
                  *(_DWORD *)(v382 + 56) = v381++;
                  uint64_t v380 = *(void *)(v380 + 8);
                }
                while (v380 != v374 + 40);
              }
              *(_WORD *)(v374 + 18) = v375 | 0x8000;
            }
            unsigned int v192 = *(_DWORD *)(v372 + 56);
            unsigned int v193 = *(_DWORD *)(v373 + 56);
          }
          else
          {
            uint64_t v190 = *(void *)(v188 + 40);
            int v191 = *(__int16 *)(v190 + 18);
            if ((v191 & 0x80000000) == 0)
            {
              uint64_t v377 = *(void *)(v190 + 48);
              if (v377 != v190 + 40)
              {
                int v378 = 0;
                do
                {
                  uint64_t v379 = v377 - 24;
                  if (!v377) {
                    uint64_t v379 = 0;
                  }
                  *(_DWORD *)(v379 + 56) = v378++;
                  uint64_t v377 = *(void *)(v377 + 8);
                }
                while (v377 != v190 + 40);
              }
              *(_WORD *)(v190 + 18) = v191 | 0x8000;
            }
            unsigned int v192 = *(_DWORD *)(v188 + 56);
            unsigned int v193 = *(_DWORD *)(v189 + 56);
          }
          if (v192 < v193)
          {
            *(void *)uint64_t v11 = v188;
            *((void *)a2 - 2) = v189;
            uint64_t v376 = *((void *)v11 + 1);
            *((void *)v11 + 1) = *((void *)a2 - 1);
            *((void *)a2 - 1) = v376;
          }
          break;
        case 3:
          uint64_t result = (uint64_t)sub_1CCD46198(v11, (uint64_t *)v11 + 2, (uint64_t *)a2 - 2);
          break;
        case 4:
          uint64_t result = (uint64_t)sub_1CCD469EC((uint64_t *)v11, (uint64_t *)v11 + 2, (uint64_t *)v11 + 4, (uint64_t *)a2 - 2);
          break;
        case 5:
          uint64_t result = (uint64_t)sub_1CCD45DC4((uint64_t *)v11, (uint64_t *)v11 + 2, (uint64_t *)v11 + 4, (uint64_t *)v11 + 6, (uint64_t *)a2 - 2);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 383) {
      break;
    }
    if (!a3)
    {
      if (v11 == a2) {
        return result;
      }
      int64_t v225 = (unint64_t)(v13 - 2) >> 1;
      int64_t v226 = v225;
      while (1)
      {
        int64_t v227 = v226;
        if (v225 < v226) {
          goto LABEL_358;
        }
        uint64_t v228 = (2 * v226) | 1;
        unsigned int v229 = &v11[16 * v228];
        if (2 * v227 + 2 < v13) {
          break;
        }
LABEL_349:
        int v239 = &v11[16 * v227];
        uint64_t v240 = *(void *)v229;
        uint64_t v241 = *(void *)v239;
        if (*(void *)v229 == *(void *)v239)
        {
          uint64_t v245 = *((void *)v229 + 1);
          uint64_t v244 = *(void *)&v11[16 * v227 + 8];
          uint64_t v246 = *(void *)(v245 + 40);
          int v247 = *(__int16 *)(v246 + 18);
          if ((v247 & 0x80000000) == 0)
          {
            uint64_t v281 = *(void *)(v246 + 48);
            if (v281 != v246 + 40)
            {
              int v282 = 0;
              do
              {
                uint64_t v283 = v281 - 24;
                if (!v281) {
                  uint64_t v283 = 0;
                }
                *(_DWORD *)(v283 + 56) = v282++;
                uint64_t v281 = *(void *)(v281 + 8);
              }
              while (v281 != v246 + 40);
            }
            *(_WORD *)(v246 + 18) = v247 | 0x8000;
          }
          uint64_t result = *(unsigned int *)(v244 + 56);
          if (*(_DWORD *)(v245 + 56) >= result) {
            goto LABEL_355;
          }
        }
        else
        {
          uint64_t v242 = *(void *)(v240 + 40);
          int v243 = *(__int16 *)(v242 + 18);
          if ((v243 & 0x80000000) == 0)
          {
            uint64_t result = v242 + 40;
            uint64_t v278 = *(void *)(v242 + 48);
            if (v278 != v242 + 40)
            {
              int v279 = 0;
              do
              {
                uint64_t v280 = v278 - 24;
                if (!v278) {
                  uint64_t v280 = 0;
                }
                *(_DWORD *)(v280 + 56) = v279++;
                uint64_t v278 = *(void *)(v278 + 8);
              }
              while (v278 != result);
            }
            *(_WORD *)(v242 + 18) = v243 | 0x8000;
          }
          if (*(_DWORD *)(v240 + 56) >= *(_DWORD *)(v241 + 56))
          {
            uint64_t v244 = *((void *)v239 + 1);
LABEL_355:
            *(void *)int v239 = v240;
            *((void *)v239 + 1) = *((void *)v229 + 1);
            if (v225 < v228)
            {
LABEL_356:
              uint64_t v248 = v229;
LABEL_357:
              *(void *)uint64_t v248 = v241;
              *((void *)v248 + 1) = v244;
              goto LABEL_358;
            }
            while (2)
            {
              uint64_t v249 = 2 * v228;
              uint64_t v228 = (2 * v228) | 1;
              uint64_t v248 = &v11[16 * v228];
              uint64_t v250 = v249 + 2;
              if (v250 < v13)
              {
                uint64_t v251 = *((void *)v248 + 2);
                uint64_t v252 = *(void *)v248;
                if (*(void *)v248 == v251)
                {
                  uint64_t v252 = *(void *)&v11[16 * v228 + 8];
                  uint64_t v251 = *((void *)v248 + 3);
                  uint64_t v260 = *(void *)(v252 + 40);
                  unsigned int v254 = (_WORD *)(v260 + 18);
                  __int16 v255 = *(_WORD *)(v260 + 18);
                  if ((v255 & 0x80000000) == 0)
                  {
                    uint64_t v274 = v260 + 40;
                    uint64_t v275 = *(void *)(v260 + 48);
                    if (v275 != v274)
                    {
                      int v276 = 0;
                      do
                      {
                        uint64_t v277 = v275 - 24;
                        if (!v275) {
                          uint64_t v277 = 0;
                        }
                        *(_DWORD *)(v277 + 56) = v276++;
                        uint64_t v275 = *(void *)(v275 + 8);
                      }
                      while (v275 != v274);
                    }
LABEL_397:
                    *unsigned int v254 = v255 | 0x8000;
                  }
                }
                else
                {
                  uint64_t v253 = *(void *)(v252 + 40);
                  unsigned int v254 = (_WORD *)(v253 + 18);
                  __int16 v255 = *(_WORD *)(v253 + 18);
                  if ((v255 & 0x80000000) == 0)
                  {
                    uint64_t v256 = v253 + 40;
                    uint64_t v257 = *(void *)(v253 + 48);
                    if (v257 != v256)
                    {
                      int v258 = 0;
                      do
                      {
                        uint64_t v259 = v257 - 24;
                        if (!v257) {
                          uint64_t v259 = 0;
                        }
                        *(_DWORD *)(v259 + 56) = v258++;
                        uint64_t v257 = *(void *)(v257 + 8);
                      }
                      while (v257 != v256);
                    }
                    goto LABEL_397;
                  }
                }
                if (*(_DWORD *)(v252 + 56) < *(_DWORD *)(v251 + 56))
                {
                  v248 += 16;
                  uint64_t v228 = v250;
                }
              }
              uint64_t v261 = *(void *)v248;
              if (*(void *)v248 == v241)
              {
                uint64_t v265 = *((void *)v248 + 1);
                uint64_t v266 = *(void *)(v265 + 40);
                int v267 = *(__int16 *)(v266 + 18);
                if ((v267 & 0x80000000) == 0)
                {
                  uint64_t v271 = *(void *)(v266 + 48);
                  if (v271 != v266 + 40)
                  {
                    int v272 = 0;
                    do
                    {
                      uint64_t v273 = v271 - 24;
                      if (!v271) {
                        uint64_t v273 = 0;
                      }
                      *(_DWORD *)(v273 + 56) = v272++;
                      uint64_t v271 = *(void *)(v271 + 8);
                    }
                    while (v271 != v266 + 40);
                  }
                  *(_WORD *)(v266 + 18) = v267 | 0x8000;
                }
                unsigned int v264 = *(_DWORD *)(v265 + 56);
                uint64_t result = *(unsigned int *)(v244 + 56);
              }
              else
              {
                uint64_t v262 = *(void *)(v261 + 40);
                int v263 = *(__int16 *)(v262 + 18);
                if ((v263 & 0x80000000) == 0)
                {
                  uint64_t v268 = *(void *)(v262 + 48);
                  if (v268 != v262 + 40)
                  {
                    int v269 = 0;
                    do
                    {
                      uint64_t v270 = v268 - 24;
                      if (!v268) {
                        uint64_t v270 = 0;
                      }
                      *(_DWORD *)(v270 + 56) = v269++;
                      uint64_t v268 = *(void *)(v268 + 8);
                    }
                    while (v268 != v262 + 40);
                  }
                  *(_WORD *)(v262 + 18) = v263 | 0x8000;
                }
                unsigned int v264 = *(_DWORD *)(v261 + 56);
                uint64_t result = *(unsigned int *)(v241 + 56);
              }
              if (v264 < result) {
                goto LABEL_356;
              }
              *(void *)unsigned int v229 = v261;
              *((void *)v229 + 1) = *((void *)v248 + 1);
              unsigned int v229 = v248;
              if (v225 < v228) {
                goto LABEL_357;
              }
              continue;
            }
          }
        }
LABEL_358:
        int64_t v226 = v227 - 1;
        if (!v227)
        {
          while (1)
          {
            uint64_t v311 = 0;
            uint64_t v312 = *(void *)v11;
            uint64_t v313 = *((void *)v11 + 1);
            unint64_t v314 = v11;
            do
            {
              uint64_t v315 = v311 + 1;
              int v316 = &v314[16 * v311 + 16];
              uint64_t v317 = (2 * v311) | 1;
              uint64_t v318 = 2 * v311 + 2;
              if (v318 >= v13) {
                goto LABEL_461;
              }
              uint64_t v319 = *((void *)v316 + 2);
              uint64_t v320 = *(void *)v316;
              if (*(void *)v316 == v319)
              {
                uint64_t v320 = *(void *)&v314[16 * v315 + 8];
                uint64_t v319 = *((void *)v316 + 3);
                uint64_t v328 = *(void *)(v320 + 40);
                uint64_t v322 = (_WORD *)(v328 + 18);
                __int16 v323 = *(_WORD *)(v328 + 18);
                if (v323 < 0) {
                  goto LABEL_459;
                }
                uint64_t v329 = v328 + 40;
                uint64_t v330 = *(void *)(v328 + 48);
                if (v330 != v329)
                {
                  int v331 = 0;
                  do
                  {
                    uint64_t v332 = v330 - 24;
                    if (!v330) {
                      uint64_t v332 = 0;
                    }
                    *(_DWORD *)(v332 + 56) = v331++;
                    uint64_t v330 = *(void *)(v330 + 8);
                  }
                  while (v330 != v329);
                }
              }
              else
              {
                uint64_t v321 = *(void *)(v320 + 40);
                uint64_t v322 = (_WORD *)(v321 + 18);
                __int16 v323 = *(_WORD *)(v321 + 18);
                if (v323 < 0) {
                  goto LABEL_459;
                }
                uint64_t v324 = v321 + 40;
                uint64_t v325 = *(void *)(v321 + 48);
                if (v325 != v324)
                {
                  int v326 = 0;
                  do
                  {
                    uint64_t v327 = v325 - 24;
                    if (!v325) {
                      uint64_t v327 = 0;
                    }
                    *(_DWORD *)(v327 + 56) = v326++;
                    uint64_t v325 = *(void *)(v325 + 8);
                  }
                  while (v325 != v324);
                }
              }
              *uint64_t v322 = v323 | 0x8000;
LABEL_459:
              uint64_t result = *(unsigned int *)(v319 + 56);
              if (*(_DWORD *)(v320 + 56) < result)
              {
                v316 += 16;
                uint64_t v317 = v318;
              }
LABEL_461:
              *(void *)unint64_t v314 = *(void *)v316;
              *((void *)v314 + 1) = *((void *)v316 + 1);
              unint64_t v314 = v316;
              uint64_t v311 = v317;
            }
            while (v317 <= (uint64_t)((unint64_t)(v13 - 2) >> 1));
            if (v316 == a2 - 16)
            {
              *(void *)int v316 = v312;
              *((void *)v316 + 1) = v313;
            }
            else
            {
              *(void *)int v316 = *((void *)a2 - 2);
              *((void *)v316 + 1) = *((void *)a2 - 1);
              *((void *)a2 - 2) = v312;
              *((void *)a2 - 1) = v313;
              uint64_t v333 = v316 - v11 + 16;
              if (v333 >= 17)
              {
                unint64_t v334 = ((unint64_t)v333 >> 4) - 2;
                unint64_t v289 = v334 >> 1;
                unsigned int v298 = &v11[16 * (v334 >> 1)];
                uint64_t v335 = *(void *)v298;
                uint64_t v336 = *(void *)v316;
                if (*(void *)v298 == *(void *)v316)
                {
                  uint64_t v341 = *((void *)v298 + 1);
                  uint64_t v342 = *((void *)v316 + 1);
                  uint64_t result = *(void *)(v341 + 40);
                  int v343 = *(__int16 *)(result + 18);
                  if ((v343 & 0x80000000) == 0)
                  {
                    uint64_t v308 = *(void *)(result + 48);
                    if (v308 != result + 40)
                    {
                      int v309 = 0;
                      do
                      {
                        uint64_t v310 = v308 - 24;
                        if (!v308) {
                          uint64_t v310 = 0;
                        }
                        *(_DWORD *)(v310 + 56) = v309++;
                        uint64_t v308 = *(void *)(v308 + 8);
                      }
                      while (v308 != result + 40);
                    }
                    *(_WORD *)(result + 18) = v343 | 0x8000;
                  }
                  unsigned int v339 = *(_DWORD *)(v341 + 56);
                  unsigned int v340 = *(_DWORD *)(v342 + 56);
                }
                else
                {
                  uint64_t v337 = *(void *)(v335 + 40);
                  int v338 = *(__int16 *)(v337 + 18);
                  if ((v338 & 0x80000000) == 0)
                  {
                    uint64_t result = v337 + 40;
                    uint64_t v305 = *(void *)(v337 + 48);
                    if (v305 != v337 + 40)
                    {
                      int v306 = 0;
                      do
                      {
                        uint64_t v307 = v305 - 24;
                        if (!v305) {
                          uint64_t v307 = 0;
                        }
                        *(_DWORD *)(v307 + 56) = v306++;
                        uint64_t v305 = *(void *)(v305 + 8);
                      }
                      while (v305 != result);
                    }
                    *(_WORD *)(v337 + 18) = v338 | 0x8000;
                  }
                  unsigned int v339 = *(_DWORD *)(v335 + 56);
                  unsigned int v340 = *(_DWORD *)(v336 + 56);
                }
                if (v339 < v340)
                {
                  uint64_t v344 = *((void *)v316 + 1);
                  *(void *)int v316 = v335;
                  *((void *)v316 + 1) = *(void *)&v11[16 * v289 + 8];
                  if (v334 >= 2)
                  {
                    while (1)
                    {
                      unint64_t v288 = v289 - 1;
                      unint64_t v289 = (v289 - 1) >> 1;
                      uint64_t v290 = &v11[16 * v289];
                      uint64_t v291 = *(void *)v290;
                      if (*(void *)v290 == v336)
                      {
                        uint64_t v295 = *((void *)v290 + 1);
                        uint64_t v296 = *(void *)(v295 + 40);
                        int v297 = *(__int16 *)(v296 + 18);
                        if ((v297 & 0x80000000) == 0)
                        {
                          uint64_t v302 = *(void *)(v296 + 48);
                          if (v302 != v296 + 40)
                          {
                            int v303 = 0;
                            do
                            {
                              uint64_t v304 = v302 - 24;
                              if (!v302) {
                                uint64_t v304 = 0;
                              }
                              *(_DWORD *)(v304 + 56) = v303++;
                              uint64_t v302 = *(void *)(v302 + 8);
                            }
                            while (v302 != v296 + 40);
                          }
                          *(_WORD *)(v296 + 18) = v297 | 0x8000;
                        }
                        unsigned int v294 = *(_DWORD *)(v295 + 56);
                        uint64_t result = *(unsigned int *)(v344 + 56);
                      }
                      else
                      {
                        uint64_t v292 = *(void *)(v291 + 40);
                        int v293 = *(__int16 *)(v292 + 18);
                        if ((v293 & 0x80000000) == 0)
                        {
                          uint64_t v299 = *(void *)(v292 + 48);
                          if (v299 != v292 + 40)
                          {
                            int v300 = 0;
                            do
                            {
                              uint64_t v301 = v299 - 24;
                              if (!v299) {
                                uint64_t v301 = 0;
                              }
                              *(_DWORD *)(v301 + 56) = v300++;
                              uint64_t v299 = *(void *)(v299 + 8);
                            }
                            while (v299 != v292 + 40);
                          }
                          *(_WORD *)(v292 + 18) = v293 | 0x8000;
                        }
                        unsigned int v294 = *(_DWORD *)(v291 + 56);
                        uint64_t result = *(unsigned int *)(v336 + 56);
                      }
                      if (v294 >= result) {
                        break;
                      }
                      *(void *)unsigned int v298 = v291;
                      *((void *)v298 + 1) = *(void *)&v11[16 * v289 + 8];
                      unsigned int v298 = &v11[16 * v289];
                      if (v288 <= 1) {
                        goto LABEL_480;
                      }
                    }
                  }
                  uint64_t v290 = v298;
LABEL_480:
                  *(void *)uint64_t v290 = v336;
                  *((void *)v290 + 1) = v344;
                }
              }
            }
            a2 -= 16;
            if (v13-- <= 2) {
              return result;
            }
          }
        }
      }
      uint64_t v230 = *((void *)v229 + 2);
      uint64_t v231 = *(void *)v229;
      if (*(void *)v229 == v230)
      {
        uint64_t v231 = *(void *)&v11[16 * v228 + 8];
        uint64_t v230 = *((void *)v229 + 3);
        uint64_t v238 = *(void *)(v231 + 40);
        unint64_t v233 = (_WORD *)(v238 + 18);
        uint64_t result = *(__int16 *)(v238 + 18);
        if (*(__int16 *)(v238 + 18) < 0) {
          goto LABEL_347;
        }
        uint64_t v284 = v238 + 40;
        uint64_t v285 = *(void *)(v238 + 48);
        if (v285 != v284)
        {
          int v286 = 0;
          do
          {
            uint64_t v287 = v285 - 24;
            if (!v285) {
              uint64_t v287 = 0;
            }
            *(_DWORD *)(v287 + 56) = v286++;
            uint64_t v285 = *(void *)(v285 + 8);
          }
          while (v285 != v284);
        }
      }
      else
      {
        uint64_t v232 = *(void *)(v231 + 40);
        unint64_t v233 = (_WORD *)(v232 + 18);
        uint64_t result = *(__int16 *)(v232 + 18);
        if (*(__int16 *)(v232 + 18) < 0) {
          goto LABEL_347;
        }
        uint64_t v234 = v232 + 40;
        uint64_t v235 = *(void *)(v232 + 48);
        if (v235 != v234)
        {
          int v236 = 0;
          do
          {
            uint64_t v237 = v235 - 24;
            if (!v235) {
              uint64_t v237 = 0;
            }
            *(_DWORD *)(v237 + 56) = v236++;
            uint64_t v235 = *(void *)(v235 + 8);
          }
          while (v235 != v234);
        }
      }
      uint64_t result = result | 0x8000;
      *unint64_t v233 = result;
LABEL_347:
      if (*(_DWORD *)(v231 + 56) < *(_DWORD *)(v230 + 56))
      {
        v229 += 16;
        uint64_t v228 = 2 * v227 + 2;
      }
      goto LABEL_349;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    uint64_t v15 = (uint64_t *)&v11[16 * ((unint64_t)v13 >> 1)];
    if ((unint64_t)v12 >= 0x801)
    {
      sub_1CCD46198(v9, (uint64_t *)&v9[16 * ((unint64_t)v13 >> 1)], (uint64_t *)a2 - 2);
      sub_1CCD46198((void *)v9 + 2, v15 - 2, (uint64_t *)a2 - 4);
      sub_1CCD46198((void *)v9 + 4, (uint64_t *)&v9[16 * v14 + 16], (uint64_t *)a2 - 6);
      uint64_t result = (uint64_t)sub_1CCD46198(v15 - 2, v15, (uint64_t *)&v9[16 * v14 + 16]);
      long long v16 = *(_OWORD *)v9;
      *(_OWORD *)uint64_t v9 = *(_OWORD *)v15;
      *(_OWORD *)uint64_t v15 = v16;
    }
    else
    {
      uint64_t result = (uint64_t)sub_1CCD46198(&v9[16 * ((unint64_t)v13 >> 1)], (uint64_t *)v9, (uint64_t *)a2 - 2);
    }
    --a3;
    uint64_t v17 = *(void *)v9;
    if (a4) {
      goto LABEL_17;
    }
    uint64_t v18 = *((void *)v9 - 2);
    if (v18 == v17)
    {
      uint64_t v22 = *((void *)v9 - 1);
      uint64_t v21 = *((void *)v9 + 1);
      uint64_t v23 = *(void *)(v22 + 40);
      int v24 = *(__int16 *)(v23 + 18);
      if ((v24 & 0x80000000) == 0)
      {
        uint64_t v125 = *(void *)(v23 + 48);
        if (v125 != v23 + 40)
        {
          int v126 = 0;
          do
          {
            uint64_t v127 = v125 - 24;
            if (!v125) {
              uint64_t v127 = 0;
            }
            *(_DWORD *)(v127 + 56) = v126++;
            uint64_t v125 = *(void *)(v125 + 8);
          }
          while (v125 != v23 + 40);
        }
        *(_WORD *)(v23 + 18) = v24 | 0x8000;
      }
      if (*(_DWORD *)(v22 + 56) < *(_DWORD *)(v21 + 56)) {
        goto LABEL_17;
      }
LABEL_136:
      uint64_t v109 = *(void *)v10;
      if (v17 == *(void *)v10)
      {
        uint64_t v128 = *((void *)a2 - 1);
        uint64_t v129 = *(void *)(v21 + 40);
        int v130 = *(__int16 *)(v129 + 18);
        if ((v130 & 0x80000000) == 0)
        {
          uint64_t v185 = *(void *)(v129 + 48);
          if (v185 != v129 + 40)
          {
            int v186 = 0;
            do
            {
              uint64_t v187 = v185 - 24;
              if (!v185) {
                uint64_t v187 = 0;
              }
              *(_DWORD *)(v187 + 56) = v186++;
              uint64_t v185 = *(void *)(v185 + 8);
            }
            while (v185 != v129 + 40);
          }
          *(_WORD *)(v129 + 18) = v130 | 0x8000;
        }
        if (*(_DWORD *)(v21 + 56) < *(_DWORD *)(v128 + 56))
        {
LABEL_139:
          uint64_t v112 = v9;
          do
          {
            uint64_t v11 = v112 + 16;
            uint64_t v113 = *((void *)v112 + 2);
            if (v17 == v113)
            {
              uint64_t v113 = *((void *)v112 + 3);
              uint64_t v117 = *(void *)(v21 + 40);
              int v118 = *(__int16 *)(v117 + 18);
              if ((v118 & 0x80000000) == 0)
              {
                uint64_t v122 = *(void *)(v117 + 48);
                if (v122 != v117 + 40)
                {
                  int v123 = 0;
                  do
                  {
                    uint64_t v124 = v122 - 24;
                    if (!v122) {
                      uint64_t v124 = 0;
                    }
                    *(_DWORD *)(v124 + 56) = v123++;
                    uint64_t v122 = *(void *)(v122 + 8);
                  }
                  while (v122 != v117 + 40);
                }
                *(_WORD *)(v117 + 18) = v118 | 0x8000;
              }
              unsigned int v116 = *(_DWORD *)(v21 + 56);
            }
            else
            {
              uint64_t v114 = *(void *)(v17 + 40);
              int v115 = *(__int16 *)(v114 + 18);
              if ((v115 & 0x80000000) == 0)
              {
                uint64_t v119 = *(void *)(v114 + 48);
                if (v119 != v114 + 40)
                {
                  int v120 = 0;
                  do
                  {
                    uint64_t v121 = v119 - 24;
                    if (!v119) {
                      uint64_t v121 = 0;
                    }
                    *(_DWORD *)(v121 + 56) = v120++;
                    uint64_t v119 = *(void *)(v119 + 8);
                  }
                  while (v119 != v114 + 40);
                }
                *(_WORD *)(v114 + 18) = v115 | 0x8000;
              }
              unsigned int v116 = *(_DWORD *)(v17 + 56);
            }
            uint64_t v112 = v11;
          }
          while (v116 >= *(_DWORD *)(v113 + 56));
          goto LABEL_188;
        }
      }
      else
      {
        uint64_t v110 = *(void *)(v17 + 40);
        int v111 = *(__int16 *)(v110 + 18);
        if ((v111 & 0x80000000) == 0)
        {
          uint64_t v182 = *(void *)(v110 + 48);
          if (v182 != v110 + 40)
          {
            int v183 = 0;
            do
            {
              uint64_t v184 = v182 - 24;
              if (!v182) {
                uint64_t v184 = 0;
              }
              *(_DWORD *)(v184 + 56) = v183++;
              uint64_t v182 = *(void *)(v182 + 8);
            }
            while (v182 != v110 + 40);
          }
          *(_WORD *)(v110 + 18) = v111 | 0x8000;
        }
        if (*(_DWORD *)(v17 + 56) < *(_DWORD *)(v109 + 56)) {
          goto LABEL_139;
        }
      }
      uint64_t v11 = v9 + 16;
      for (uint64_t i = v9; v11 < a2; uint64_t i = v132)
      {
        int v132 = v11;
        uint64_t v133 = *((void *)i + 2);
        if (v17 == v133)
        {
          uint64_t v133 = *((void *)i + 3);
          uint64_t v137 = *(void *)(v21 + 40);
          int v138 = *(__int16 *)(v137 + 18);
          if ((v138 & 0x80000000) == 0)
          {
            uint64_t v141 = *(void *)(v137 + 48);
            if (v141 != v137 + 40)
            {
              int v142 = 0;
              do
              {
                uint64_t result = v141 - 24;
                if (!v141) {
                  uint64_t result = 0;
                }
                *(_DWORD *)(result + 56) = v142++;
                uint64_t v141 = *(void *)(v141 + 8);
              }
              while (v141 != v137 + 40);
            }
            *(_WORD *)(v137 + 18) = v138 | 0x8000;
          }
          unsigned int v136 = *(_DWORD *)(v21 + 56);
        }
        else
        {
          uint64_t v134 = *(void *)(v17 + 40);
          int v135 = *(__int16 *)(v134 + 18);
          if ((v135 & 0x80000000) == 0)
          {
            uint64_t v139 = *(void *)(v134 + 48);
            if (v139 != v134 + 40)
            {
              int v140 = 0;
              do
              {
                uint64_t result = v139 - 24;
                if (!v139) {
                  uint64_t result = 0;
                }
                *(_DWORD *)(result + 56) = v140++;
                uint64_t v139 = *(void *)(v139 + 8);
              }
              while (v139 != v134 + 40);
            }
            *(_WORD *)(v134 + 18) = v135 | 0x8000;
          }
          unsigned int v136 = *(_DWORD *)(v17 + 56);
        }
        if (v136 < *(_DWORD *)(v133 + 56)) {
          break;
        }
        v11 += 16;
      }
LABEL_188:
      BOOL v143 = a2;
      if (v11 < a2)
      {
        for (uint64_t j = a2; ; j -= 16)
        {
          BOOL v143 = j - 16;
          if (v17 == v109)
          {
            uint64_t v109 = *((void *)j - 1);
            uint64_t v148 = *(void *)(v21 + 40);
            int v149 = *(__int16 *)(v148 + 18);
            if ((v149 & 0x80000000) == 0)
            {
              uint64_t v152 = *(void *)(v148 + 48);
              if (v152 != v148 + 40)
              {
                int v153 = 0;
                do
                {
                  uint64_t result = v152 - 24;
                  if (!v152) {
                    uint64_t result = 0;
                  }
                  *(_DWORD *)(result + 56) = v153++;
                  uint64_t v152 = *(void *)(v152 + 8);
                }
                while (v152 != v148 + 40);
              }
              *(_WORD *)(v148 + 18) = v149 | 0x8000;
            }
            unsigned int v147 = *(_DWORD *)(v21 + 56);
          }
          else
          {
            uint64_t v145 = *(void *)(v17 + 40);
            int v146 = *(__int16 *)(v145 + 18);
            if ((v146 & 0x80000000) == 0)
            {
              uint64_t v150 = *(void *)(v145 + 48);
              if (v150 != v145 + 40)
              {
                int v151 = 0;
                do
                {
                  uint64_t result = v150 - 24;
                  if (!v150) {
                    uint64_t result = 0;
                  }
                  *(_DWORD *)(result + 56) = v151++;
                  uint64_t v150 = *(void *)(v150 + 8);
                }
                while (v150 != v145 + 40);
              }
              *(_WORD *)(v145 + 18) = v146 | 0x8000;
            }
            unsigned int v147 = *(_DWORD *)(v17 + 56);
          }
          if (v147 >= *(_DWORD *)(v109 + 56)) {
            break;
          }
          uint64_t v109 = *((void *)j - 4);
        }
      }
      if (v11 < v143)
      {
        uint64_t v154 = *(void *)v11;
        uint64_t v155 = *(void *)v143;
        do
        {
          *(void *)uint64_t v11 = v155;
          *(void *)BOOL v143 = v154;
          uint64_t v156 = *((void *)v11 + 1);
          *((void *)v11 + 1) = *((void *)v143 + 1);
          *((void *)v143 + 1) = v156;
          int v157 = v11;
          do
          {
            uint64_t v11 = v157 + 16;
            uint64_t v154 = *((void *)v157 + 2);
            if (v17 == v154)
            {
              uint64_t v162 = *((void *)v157 + 3);
              uint64_t v163 = *(void *)(v21 + 40);
              int v164 = *(__int16 *)(v163 + 18);
              if ((v164 & 0x80000000) == 0)
              {
                uint64_t v168 = *(void *)(v163 + 48);
                if (v168 != v163 + 40)
                {
                  int v169 = 0;
                  do
                  {
                    uint64_t result = v168 - 24;
                    if (!v168) {
                      uint64_t result = 0;
                    }
                    *(_DWORD *)(result + 56) = v169++;
                    uint64_t v168 = *(void *)(v168 + 8);
                  }
                  while (v168 != v163 + 40);
                }
                *(_WORD *)(v163 + 18) = v164 | 0x8000;
              }
              unsigned int v160 = *(_DWORD *)(v21 + 56);
              unsigned int v161 = *(_DWORD *)(v162 + 56);
            }
            else
            {
              uint64_t v158 = *(void *)(v17 + 40);
              int v159 = *(__int16 *)(v158 + 18);
              if ((v159 & 0x80000000) == 0)
              {
                uint64_t v165 = *(void *)(v158 + 48);
                if (v165 != v158 + 40)
                {
                  int v166 = 0;
                  do
                  {
                    uint64_t v167 = v165 - 24;
                    if (!v165) {
                      uint64_t v167 = 0;
                    }
                    *(_DWORD *)(v167 + 56) = v166++;
                    uint64_t v165 = *(void *)(v165 + 8);
                  }
                  while (v165 != v158 + 40);
                }
                *(_WORD *)(v158 + 18) = v159 | 0x8000;
              }
              unsigned int v160 = *(_DWORD *)(v17 + 56);
              unsigned int v161 = *(_DWORD *)(v154 + 56);
            }
            int v157 = v11;
          }
          while (v160 >= v161);
          unint64_t v170 = v143;
          do
          {
            BOOL v143 = v170 - 16;
            uint64_t v155 = *((void *)v170 - 2);
            if (v17 == v155)
            {
              uint64_t v175 = *((void *)v170 - 1);
              uint64_t v176 = *(void *)(v21 + 40);
              int v177 = *(__int16 *)(v176 + 18);
              if ((v177 & 0x80000000) == 0)
              {
                uint64_t v180 = *(void *)(v176 + 48);
                if (v180 != v176 + 40)
                {
                  LODWORD(result) = 0;
                  do
                  {
                    uint64_t v181 = v180 - 24;
                    if (!v180) {
                      uint64_t v181 = 0;
                    }
                    *(_DWORD *)(v181 + 56) = result;
                    uint64_t result = (result + 1);
                    uint64_t v180 = *(void *)(v180 + 8);
                  }
                  while (v180 != v176 + 40);
                }
                *(_WORD *)(v176 + 18) = v177 | 0x8000;
              }
              unsigned int v173 = *(_DWORD *)(v21 + 56);
              unsigned int v174 = *(_DWORD *)(v175 + 56);
            }
            else
            {
              uint64_t v171 = *(void *)(v17 + 40);
              int v172 = *(__int16 *)(v171 + 18);
              if ((v172 & 0x80000000) == 0)
              {
                uint64_t v178 = *(void *)(v171 + 48);
                if (v178 != v171 + 40)
                {
                  int v179 = 0;
                  do
                  {
                    uint64_t result = v178 - 24;
                    if (!v178) {
                      uint64_t result = 0;
                    }
                    *(_DWORD *)(result + 56) = v179++;
                    uint64_t v178 = *(void *)(v178 + 8);
                  }
                  while (v178 != v171 + 40);
                }
                *(_WORD *)(v171 + 18) = v172 | 0x8000;
              }
              unsigned int v173 = *(_DWORD *)(v17 + 56);
              unsigned int v174 = *(_DWORD *)(v155 + 56);
            }
            unint64_t v170 = v143;
          }
          while (v173 < v174);
        }
        while (v11 < v143);
      }
      BOOL v4 = v11 - 16 >= v9;
      BOOL v5 = v11 - 16 == v9;
      if (v11 - 16 != v9)
      {
        *(void *)uint64_t v9 = *((void *)v11 - 2);
        *((void *)v9 + 1) = *((void *)v11 - 1);
      }
      a4 = 0;
      *((void *)v11 - 2) = v17;
      *((void *)v11 - 1) = v21;
    }
    else
    {
      uint64_t v19 = *(void *)(v18 + 40);
      int v20 = *(__int16 *)(v19 + 18);
      if ((v20 & 0x80000000) == 0)
      {
        uint64_t v106 = *(void *)(v19 + 48);
        if (v106 != v19 + 40)
        {
          int v107 = 0;
          do
          {
            uint64_t v108 = v106 - 24;
            if (!v106) {
              uint64_t v108 = 0;
            }
            *(_DWORD *)(v108 + 56) = v107++;
            uint64_t v106 = *(void *)(v106 + 8);
          }
          while (v106 != v19 + 40);
        }
        *(_WORD *)(v19 + 18) = v20 | 0x8000;
      }
      if (*(_DWORD *)(v18 + 56) >= *(_DWORD *)(v17 + 56))
      {
        uint64_t v21 = *((void *)v9 + 1);
        goto LABEL_136;
      }
LABEL_17:
      uint64_t v25 = *((void *)v9 + 1);
      uint64_t v26 = v9;
      do
      {
        uint64_t v27 = v26;
        uint64_t v29 = *((void *)v26 + 2);
        v26 += 16;
        uint64_t v28 = v29;
        if (v29 == v17)
        {
          uint64_t v34 = *((void *)v27 + 3);
          uint64_t v35 = *(void *)(v34 + 40);
          int v36 = *(__int16 *)(v35 + 18);
          if ((v36 & 0x80000000) == 0)
          {
            uint64_t v40 = *(void *)(v35 + 48);
            if (v40 != v35 + 40)
            {
              int v41 = 0;
              do
              {
                uint64_t v42 = v40 - 24;
                if (!v40) {
                  uint64_t v42 = 0;
                }
                *(_DWORD *)(v42 + 56) = v41++;
                uint64_t v40 = *(void *)(v40 + 8);
              }
              while (v40 != v35 + 40);
            }
            *(_WORD *)(v35 + 18) = v36 | 0x8000;
          }
          unsigned int v32 = *(_DWORD *)(v34 + 56);
          unsigned int v33 = *(_DWORD *)(v25 + 56);
        }
        else
        {
          uint64_t v30 = *(void *)(v28 + 40);
          int v31 = *(__int16 *)(v30 + 18);
          if ((v31 & 0x80000000) == 0)
          {
            uint64_t v37 = *(void *)(v30 + 48);
            if (v37 != v30 + 40)
            {
              int v38 = 0;
              do
              {
                uint64_t v39 = v37 - 24;
                if (!v37) {
                  uint64_t v39 = 0;
                }
                *(_DWORD *)(v39 + 56) = v38++;
                uint64_t v37 = *(void *)(v37 + 8);
              }
              while (v37 != v30 + 40);
            }
            *(_WORD *)(v30 + 18) = v31 | 0x8000;
          }
          unsigned int v32 = *(_DWORD *)(v28 + 56);
          unsigned int v33 = *(_DWORD *)(v17 + 56);
        }
      }
      while (v32 < v33);
      unsigned int v43 = a2;
      if (v27 == v9)
      {
        uint64_t v44 = a2;
        if (v26 < a2)
        {
          uint64_t v59 = a2;
          do
          {
            uint64_t v44 = v59 - 16;
            uint64_t v60 = *((void *)v59 - 2);
            if (v60 == v17)
            {
              uint64_t v65 = *((void *)v59 - 1);
              uint64_t v66 = *(void *)(v65 + 40);
              int v67 = *(__int16 *)(v66 + 18);
              if ((v67 & 0x80000000) == 0)
              {
                uint64_t v71 = *(void *)(v66 + 48);
                if (v71 != v66 + 40)
                {
                  int v72 = 0;
                  do
                  {
                    uint64_t v73 = v71 - 24;
                    if (!v71) {
                      uint64_t v73 = 0;
                    }
                    *(_DWORD *)(v73 + 56) = v72++;
                    uint64_t v71 = *(void *)(v71 + 8);
                  }
                  while (v71 != v66 + 40);
                }
                *(_WORD *)(v66 + 18) = v67 | 0x8000;
              }
              if (v26 >= v44) {
                break;
              }
              unsigned int v63 = *(_DWORD *)(v65 + 56);
              unsigned int v64 = *(_DWORD *)(v25 + 56);
            }
            else
            {
              uint64_t v61 = *(void *)(v60 + 40);
              int v62 = *(__int16 *)(v61 + 18);
              if ((v62 & 0x80000000) == 0)
              {
                uint64_t v68 = *(void *)(v61 + 48);
                if (v68 != v61 + 40)
                {
                  int v69 = 0;
                  do
                  {
                    uint64_t v70 = v68 - 24;
                    if (!v68) {
                      uint64_t v70 = 0;
                    }
                    *(_DWORD *)(v70 + 56) = v69++;
                    uint64_t v68 = *(void *)(v68 + 8);
                  }
                  while (v68 != v61 + 40);
                }
                *(_WORD *)(v61 + 18) = v62 | 0x8000;
              }
              if (v26 >= v44) {
                break;
              }
              unsigned int v63 = *(_DWORD *)(v60 + 56);
              unsigned int v64 = *(_DWORD *)(v17 + 56);
            }
            uint64_t v59 = v44;
          }
          while (v63 >= v64);
        }
      }
      else
      {
        do
        {
          uint64_t v44 = v43 - 16;
          uint64_t v45 = *((void *)v43 - 2);
          if (v45 == v17)
          {
            uint64_t v50 = *((void *)v43 - 1);
            uint64_t v51 = *(void *)(v50 + 40);
            int v52 = *(__int16 *)(v51 + 18);
            if ((v52 & 0x80000000) == 0)
            {
              uint64_t v56 = *(void *)(v51 + 48);
              if (v56 != v51 + 40)
              {
                int v57 = 0;
                do
                {
                  uint64_t v58 = v56 - 24;
                  if (!v56) {
                    uint64_t v58 = 0;
                  }
                  *(_DWORD *)(v58 + 56) = v57++;
                  uint64_t v56 = *(void *)(v56 + 8);
                }
                while (v56 != v51 + 40);
              }
              *(_WORD *)(v51 + 18) = v52 | 0x8000;
            }
            unsigned int v48 = *(_DWORD *)(v50 + 56);
            unsigned int v49 = *(_DWORD *)(v25 + 56);
          }
          else
          {
            uint64_t v46 = *(void *)(v45 + 40);
            int v47 = *(__int16 *)(v46 + 18);
            if ((v47 & 0x80000000) == 0)
            {
              uint64_t v53 = *(void *)(v46 + 48);
              if (v53 != v46 + 40)
              {
                int v54 = 0;
                do
                {
                  uint64_t v55 = v53 - 24;
                  if (!v53) {
                    uint64_t v55 = 0;
                  }
                  *(_DWORD *)(v55 + 56) = v54++;
                  uint64_t v53 = *(void *)(v53 + 8);
                }
                while (v53 != v46 + 40);
              }
              *(_WORD *)(v46 + 18) = v47 | 0x8000;
            }
            unsigned int v48 = *(_DWORD *)(v45 + 56);
            unsigned int v49 = *(_DWORD *)(v17 + 56);
          }
          unsigned int v43 = v44;
        }
        while (v48 >= v49);
      }
      if (v26 >= v44)
      {
        uint64_t v11 = v26;
      }
      else
      {
        uint64_t v74 = *(void *)v44;
        uint64_t v11 = v26;
        unint64_t v75 = v44;
        do
        {
          *(void *)uint64_t v11 = v74;
          *(void *)unint64_t v75 = v28;
          uint64_t v76 = *((void *)v11 + 1);
          *((void *)v11 + 1) = *((void *)v75 + 1);
          *((void *)v75 + 1) = v76;
          unsigned int v77 = v11;
          do
          {
            uint64_t v11 = v77 + 16;
            uint64_t v28 = *((void *)v77 + 2);
            if (v28 == v17)
            {
              uint64_t v82 = *((void *)v77 + 3);
              uint64_t v83 = *(void *)(v82 + 40);
              int v84 = *(__int16 *)(v83 + 18);
              if ((v84 & 0x80000000) == 0)
              {
                uint64_t v88 = *(void *)(v83 + 48);
                if (v88 != v83 + 40)
                {
                  int v89 = 0;
                  do
                  {
                    uint64_t v90 = v88 - 24;
                    if (!v88) {
                      uint64_t v90 = 0;
                    }
                    *(_DWORD *)(v90 + 56) = v89++;
                    uint64_t v88 = *(void *)(v88 + 8);
                  }
                  while (v88 != v83 + 40);
                }
                *(_WORD *)(v83 + 18) = v84 | 0x8000;
              }
              unsigned int v80 = *(_DWORD *)(v82 + 56);
              unsigned int v81 = *(_DWORD *)(v25 + 56);
            }
            else
            {
              uint64_t v78 = *(void *)(v28 + 40);
              int v79 = *(__int16 *)(v78 + 18);
              if ((v79 & 0x80000000) == 0)
              {
                uint64_t v85 = *(void *)(v78 + 48);
                if (v85 != v78 + 40)
                {
                  int v86 = 0;
                  do
                  {
                    uint64_t v87 = v85 - 24;
                    if (!v85) {
                      uint64_t v87 = 0;
                    }
                    *(_DWORD *)(v87 + 56) = v86++;
                    uint64_t v85 = *(void *)(v85 + 8);
                  }
                  while (v85 != v78 + 40);
                }
                *(_WORD *)(v78 + 18) = v79 | 0x8000;
              }
              unsigned int v80 = *(_DWORD *)(v28 + 56);
              unsigned int v81 = *(_DWORD *)(v17 + 56);
            }
            unsigned int v77 = v11;
          }
          while (v80 < v81);
          uint64_t v91 = v75;
          do
          {
            unint64_t v75 = v91 - 16;
            uint64_t v74 = *((void *)v91 - 2);
            if (v74 == v17)
            {
              uint64_t v96 = *((void *)v91 - 1);
              uint64_t v97 = *(void *)(v96 + 40);
              int v98 = *(__int16 *)(v97 + 18);
              if ((v98 & 0x80000000) == 0)
              {
                uint64_t v102 = *(void *)(v97 + 48);
                if (v102 != v97 + 40)
                {
                  int v103 = 0;
                  do
                  {
                    uint64_t v104 = v102 - 24;
                    if (!v102) {
                      uint64_t v104 = 0;
                    }
                    *(_DWORD *)(v104 + 56) = v103++;
                    uint64_t v102 = *(void *)(v102 + 8);
                  }
                  while (v102 != v97 + 40);
                }
                *(_WORD *)(v97 + 18) = v98 | 0x8000;
              }
              unsigned int v94 = *(_DWORD *)(v96 + 56);
              unsigned int v95 = *(_DWORD *)(v25 + 56);
            }
            else
            {
              uint64_t v92 = *(void *)(v74 + 40);
              int v93 = *(__int16 *)(v92 + 18);
              if ((v93 & 0x80000000) == 0)
              {
                uint64_t v99 = *(void *)(v92 + 48);
                if (v99 != v92 + 40)
                {
                  int v100 = 0;
                  do
                  {
                    uint64_t v101 = v99 - 24;
                    if (!v99) {
                      uint64_t v101 = 0;
                    }
                    *(_DWORD *)(v101 + 56) = v100++;
                    uint64_t v99 = *(void *)(v99 + 8);
                  }
                  while (v99 != v92 + 40);
                }
                *(_WORD *)(v92 + 18) = v93 | 0x8000;
              }
              unsigned int v94 = *(_DWORD *)(v74 + 56);
              unsigned int v95 = *(_DWORD *)(v17 + 56);
            }
            uint64_t v91 = v75;
          }
          while (v94 >= v95);
        }
        while (v11 < v75);
      }
      if (v11 - 16 != v9)
      {
        *(void *)uint64_t v9 = *((void *)v11 - 2);
        *((void *)v9 + 1) = *((void *)v11 - 1);
      }
      *((void *)v11 - 2) = v17;
      *((void *)v11 - 1) = v25;
      if (v26 < v44)
      {
LABEL_129:
        uint64_t result = sub_1CCD44474(v9, v11 - 16, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v105 = sub_1CCD46604((uint64_t *)v9, v11 - 16);
        uint64_t result = sub_1CCD46604((uint64_t *)v11, a2);
        if (result)
        {
          a2 = v11 - 16;
          if (v105) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v105) {
          goto LABEL_129;
        }
      }
    }
  }
  int v194 = v11 + 16;
  BOOL v196 = v11 == a2 || v194 == a2;
  if ((a4 & 1) == 0)
  {
    if (v196) {
      return result;
    }
    while (1)
    {
      uint64_t v346 = v9;
      uint64_t v9 = v194;
      uint64_t v347 = *((void *)v346 + 2);
      uint64_t v348 = *(void *)v346;
      if (v347 == *(void *)v346)
      {
        uint64_t v351 = *((void *)v346 + 3);
        uint64_t v352 = *((void *)v346 + 1);
        uint64_t v353 = *(void *)(v351 + 40);
        int v354 = *(__int16 *)(v353 + 18);
        if ((v354 & 0x80000000) == 0)
        {
          uint64_t v370 = *(void *)(v353 + 48);
          if (v370 != v353 + 40)
          {
            int v371 = 0;
            do
            {
              uint64_t result = v370 - 24;
              if (!v370) {
                uint64_t result = 0;
              }
              *(_DWORD *)(result + 56) = v371++;
              uint64_t v370 = *(void *)(v370 + 8);
            }
            while (v370 != v353 + 40);
          }
          *(_WORD *)(v353 + 18) = v354 | 0x8000;
        }
        if (*(_DWORD *)(v351 + 56) >= *(_DWORD *)(v352 + 56)) {
          goto LABEL_512;
        }
      }
      else
      {
        uint64_t v349 = *(void *)(v347 + 40);
        int v350 = *(__int16 *)(v349 + 18);
        if ((v350 & 0x80000000) == 0)
        {
          uint64_t v367 = *(void *)(v349 + 48);
          if (v367 != v349 + 40)
          {
            int v368 = 0;
            do
            {
              uint64_t v369 = v367 - 24;
              if (!v367) {
                uint64_t v369 = 0;
              }
              *(_DWORD *)(v369 + 56) = v368++;
              uint64_t v367 = *(void *)(v367 + 8);
            }
            while (v367 != v349 + 40);
          }
          *(_WORD *)(v349 + 18) = v350 | 0x8000;
        }
        if (*(_DWORD *)(v347 + 56) >= *(_DWORD *)(v348 + 56)) {
          goto LABEL_512;
        }
        uint64_t v351 = *((void *)v346 + 3);
      }
      BOOL v355 = v9;
      do
      {
        while (1)
        {
          uint64_t v356 = v355;
          BOOL v355 = v346;
          *(void *)uint64_t v356 = v348;
          *((void *)v356 + 1) = *((void *)v346 + 1);
          uint64_t v357 = *((void *)v346 - 2);
          v346 -= 16;
          uint64_t v348 = v357;
          if (v347 == v357) {
            break;
          }
          uint64_t v358 = *(void *)(v347 + 40);
          int v359 = *(__int16 *)(v358 + 18);
          if ((v359 & 0x80000000) == 0)
          {
            uint64_t v363 = *(void *)(v358 + 48);
            if (v363 != v358 + 40)
            {
              int v364 = 0;
              do
              {
                uint64_t result = v363 - 24;
                if (!v363) {
                  uint64_t result = 0;
                }
                *(_DWORD *)(result + 56) = v364++;
                uint64_t v363 = *(void *)(v363 + 8);
              }
              while (v363 != v358 + 40);
            }
            *(_WORD *)(v358 + 18) = v359 | 0x8000;
          }
          if (*(_DWORD *)(v347 + 56) >= *(_DWORD *)(v348 + 56)) {
            goto LABEL_511;
          }
        }
        uint64_t v360 = *((void *)v355 - 1);
        uint64_t v361 = *(void *)(v351 + 40);
        int v362 = *(__int16 *)(v361 + 18);
        if ((v362 & 0x80000000) == 0)
        {
          uint64_t v365 = *(void *)(v361 + 48);
          if (v365 != v361 + 40)
          {
            LODWORD(result) = 0;
            do
            {
              uint64_t v366 = v365 - 24;
              if (!v365) {
                uint64_t v366 = 0;
              }
              *(_DWORD *)(v366 + 56) = result;
              uint64_t result = (result + 1);
              uint64_t v365 = *(void *)(v365 + 8);
            }
            while (v365 != v361 + 40);
          }
          *(_WORD *)(v361 + 18) = v362 | 0x8000;
        }
      }
      while (*(_DWORD *)(v351 + 56) < *(_DWORD *)(v360 + 56));
LABEL_511:
      *(void *)BOOL v355 = v347;
      *((void *)v355 + 1) = v351;
LABEL_512:
      int v194 = v9 + 16;
      if (v9 + 16 == a2) {
        return result;
      }
    }
  }
  if (v196) {
    return result;
  }
  uint64_t v197 = v11;
  while (2)
  {
    uint64_t v198 = v197;
    uint64_t v197 = v194;
    uint64_t v199 = *((void *)v198 + 2);
    uint64_t v200 = *(void *)v198;
    if (v199 == *(void *)v198)
    {
      uint64_t v203 = *((void *)v198 + 3);
      uint64_t v204 = *((void *)v198 + 1);
      uint64_t v205 = *(void *)(v203 + 40);
      int v206 = *(__int16 *)(v205 + 18);
      if ((v206 & 0x80000000) == 0)
      {
        uint64_t v223 = *(void *)(v205 + 48);
        if (v223 != v205 + 40)
        {
          LODWORD(result) = 0;
          do
          {
            uint64_t v224 = v223 - 24;
            if (!v223) {
              uint64_t v224 = 0;
            }
            *(_DWORD *)(v224 + 56) = result;
            uint64_t result = (result + 1);
            uint64_t v223 = *(void *)(v223 + 8);
          }
          while (v223 != v205 + 40);
        }
        *(_WORD *)(v205 + 18) = v206 | 0x8000;
      }
      if (*(_DWORD *)(v203 + 56) >= *(_DWORD *)(v204 + 56)) {
        goto LABEL_320;
      }
    }
    else
    {
      uint64_t v201 = *(void *)(v199 + 40);
      int v202 = *(__int16 *)(v201 + 18);
      if ((v202 & 0x80000000) == 0)
      {
        uint64_t v220 = *(void *)(v201 + 48);
        if (v220 != v201 + 40)
        {
          int v221 = 0;
          do
          {
            uint64_t v222 = v220 - 24;
            if (!v220) {
              uint64_t v222 = 0;
            }
            *(_DWORD *)(v222 + 56) = v221++;
            uint64_t v220 = *(void *)(v220 + 8);
          }
          while (v220 != v201 + 40);
        }
        *(_WORD *)(v201 + 18) = v202 | 0x8000;
      }
      if (*(_DWORD *)(v199 + 56) >= *(_DWORD *)(v200 + 56)) {
        goto LABEL_320;
      }
      uint64_t v203 = *((void *)v198 + 3);
    }
    *((void *)v198 + 2) = v200;
    *((void *)v197 + 1) = *((void *)v198 + 1);
    uint64_t v207 = v11;
    if (v198 == v11) {
      goto LABEL_319;
    }
    long long v208 = v198;
    while (2)
    {
      uint64_t v210 = *((void *)v208 - 2);
      v208 -= 16;
      uint64_t v209 = v210;
      if (v199 != v210)
      {
        uint64_t v211 = *(void *)(v199 + 40);
        int v212 = *(__int16 *)(v211 + 18);
        if ((v212 & 0x80000000) == 0)
        {
          uint64_t v216 = *(void *)(v211 + 48);
          if (v216 != v211 + 40)
          {
            LODWORD(result) = 0;
            do
            {
              uint64_t v217 = v216 - 24;
              if (!v216) {
                uint64_t v217 = 0;
              }
              *(_DWORD *)(v217 + 56) = result;
              uint64_t result = (result + 1);
              uint64_t v216 = *(void *)(v216 + 8);
            }
            while (v216 != v211 + 40);
          }
          *(_WORD *)(v211 + 18) = v212 | 0x8000;
        }
        if (*(_DWORD *)(v199 + 56) >= *(_DWORD *)(v209 + 56)) {
          break;
        }
        uint64_t v213 = *((void *)v198 - 1);
        goto LABEL_304;
      }
      uint64_t v213 = *((void *)v198 - 1);
      uint64_t v214 = *(void *)(v203 + 40);
      int v215 = *(__int16 *)(v214 + 18);
      if ((v215 & 0x80000000) == 0)
      {
        uint64_t result = *(void *)(v214 + 48);
        if (result != v214 + 40)
        {
          int v218 = 0;
          do
          {
            uint64_t v219 = result - 24;
            if (!result) {
              uint64_t v219 = 0;
            }
            *(_DWORD *)(v219 + 56) = v218++;
            uint64_t result = *(void *)(result + 8);
          }
          while (result != v214 + 40);
        }
        *(_WORD *)(v214 + 18) = v215 | 0x8000;
      }
      if (*(_DWORD *)(v203 + 56) < *(_DWORD *)(v213 + 56))
      {
LABEL_304:
        *(void *)uint64_t v198 = v209;
        *((void *)v198 + 1) = v213;
        uint64_t v198 = v208;
        if (v208 == v11)
        {
          uint64_t v207 = v11;
          goto LABEL_319;
        }
        continue;
      }
      break;
    }
    uint64_t v207 = v198;
LABEL_319:
    *(void *)uint64_t v207 = v199;
    *((void *)v207 + 1) = v203;
LABEL_320:
    int v194 = v197 + 16;
    if (v197 + 16 != a2) {
      continue;
    }
    return result;
  }
}

void *sub_1CCD45DC4(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = sub_1CCD469EC(a1, a2, a3, a4);
  uint64_t v11 = *a5;
  uint64_t v12 = *a4;
  if (*a5 == *a4)
  {
    uint64_t v17 = a5[1];
    uint64_t v18 = a4[1];
    uint64_t v19 = *(void *)(v17 + 40);
    int v20 = *(__int16 *)(v19 + 18);
    if ((v20 & 0x80000000) == 0)
    {
      uint64_t v58 = *(void *)(v19 + 48);
      if (v58 != v19 + 40)
      {
        int v59 = 0;
        do
        {
          uint64_t v60 = v58 - 24;
          if (!v58) {
            uint64_t v60 = 0;
          }
          *(_DWORD *)(v60 + 56) = v59++;
          uint64_t v58 = *(void *)(v58 + 8);
        }
        while (v58 != v19 + 40);
      }
      *(_WORD *)(v19 + 18) = v20 | 0x8000;
    }
    unsigned int v15 = *(_DWORD *)(v17 + 56);
    unsigned int v16 = *(_DWORD *)(v18 + 56);
  }
  else
  {
    uint64_t v13 = *(void *)(v11 + 40);
    int v14 = *(__int16 *)(v13 + 18);
    if ((v14 & 0x80000000) == 0)
    {
      uint64_t v55 = *(void *)(v13 + 48);
      if (v55 != v13 + 40)
      {
        int v56 = 0;
        do
        {
          uint64_t v57 = v55 - 24;
          if (!v55) {
            uint64_t v57 = 0;
          }
          *(_DWORD *)(v57 + 56) = v56++;
          uint64_t v55 = *(void *)(v55 + 8);
        }
        while (v55 != v13 + 40);
      }
      *(_WORD *)(v13 + 18) = v14 | 0x8000;
    }
    unsigned int v15 = *(_DWORD *)(v11 + 56);
    unsigned int v16 = *(_DWORD *)(v12 + 56);
  }
  if (v15 < v16)
  {
    *a4 = v11;
    *a5 = v12;
    uint64_t v21 = a4[1];
    a4[1] = a5[1];
    a5[1] = v21;
    uint64_t v22 = *a4;
    uint64_t v23 = *a3;
    if (*a4 == *a3)
    {
      uint64_t v28 = a4[1];
      uint64_t v29 = a3[1];
      uint64_t v30 = *(void *)(v28 + 40);
      int v31 = *(__int16 *)(v30 + 18);
      if ((v31 & 0x80000000) == 0)
      {
        uint64_t v64 = *(void *)(v30 + 48);
        if (v64 != v30 + 40)
        {
          int v65 = 0;
          do
          {
            uint64_t v66 = v64 - 24;
            if (!v64) {
              uint64_t v66 = 0;
            }
            *(_DWORD *)(v66 + 56) = v65++;
            uint64_t v64 = *(void *)(v64 + 8);
          }
          while (v64 != v30 + 40);
        }
        *(_WORD *)(v30 + 18) = v31 | 0x8000;
      }
      unsigned int v26 = *(_DWORD *)(v28 + 56);
      unsigned int v27 = *(_DWORD *)(v29 + 56);
    }
    else
    {
      uint64_t v24 = *(void *)(v22 + 40);
      int v25 = *(__int16 *)(v24 + 18);
      if ((v25 & 0x80000000) == 0)
      {
        uint64_t v61 = *(void *)(v24 + 48);
        if (v61 != v24 + 40)
        {
          int v62 = 0;
          do
          {
            uint64_t v63 = v61 - 24;
            if (!v61) {
              uint64_t v63 = 0;
            }
            *(_DWORD *)(v63 + 56) = v62++;
            uint64_t v61 = *(void *)(v61 + 8);
          }
          while (v61 != v24 + 40);
        }
        *(_WORD *)(v24 + 18) = v25 | 0x8000;
      }
      unsigned int v26 = *(_DWORD *)(v22 + 56);
      unsigned int v27 = *(_DWORD *)(v23 + 56);
    }
    if (v26 < v27)
    {
      *a3 = v22;
      *a4 = v23;
      uint64_t v32 = a3[1];
      a3[1] = a4[1];
      a4[1] = v32;
      uint64_t v33 = *a3;
      uint64_t v34 = *a2;
      if (*a3 == *a2)
      {
        uint64_t v39 = a3[1];
        uint64_t v40 = a2[1];
        uint64_t v41 = *(void *)(v39 + 40);
        int v42 = *(__int16 *)(v41 + 18);
        if ((v42 & 0x80000000) == 0)
        {
          uint64_t v70 = *(void *)(v41 + 48);
          if (v70 != v41 + 40)
          {
            int v71 = 0;
            do
            {
              uint64_t v72 = v70 - 24;
              if (!v70) {
                uint64_t v72 = 0;
              }
              *(_DWORD *)(v72 + 56) = v71++;
              uint64_t v70 = *(void *)(v70 + 8);
            }
            while (v70 != v41 + 40);
          }
          *(_WORD *)(v41 + 18) = v42 | 0x8000;
        }
        unsigned int v37 = *(_DWORD *)(v39 + 56);
        unsigned int v38 = *(_DWORD *)(v40 + 56);
      }
      else
      {
        uint64_t v35 = *(void *)(v33 + 40);
        int v36 = *(__int16 *)(v35 + 18);
        if ((v36 & 0x80000000) == 0)
        {
          uint64_t v67 = *(void *)(v35 + 48);
          if (v67 != v35 + 40)
          {
            int v68 = 0;
            do
            {
              uint64_t v69 = v67 - 24;
              if (!v67) {
                uint64_t v69 = 0;
              }
              *(_DWORD *)(v69 + 56) = v68++;
              uint64_t v67 = *(void *)(v67 + 8);
            }
            while (v67 != v35 + 40);
          }
          *(_WORD *)(v35 + 18) = v36 | 0x8000;
        }
        unsigned int v37 = *(_DWORD *)(v33 + 56);
        unsigned int v38 = *(_DWORD *)(v34 + 56);
      }
      if (v37 < v38)
      {
        *a2 = v33;
        *a3 = v34;
        uint64_t v43 = a2[1];
        a2[1] = a3[1];
        a3[1] = v43;
        uint64_t v44 = *a2;
        uint64_t v45 = *a1;
        if (*a2 == *a1)
        {
          uint64_t v50 = a2[1];
          uint64_t v51 = a1[1];
          uint64_t v52 = *(void *)(v50 + 40);
          int v53 = *(__int16 *)(v52 + 18);
          if ((v53 & 0x80000000) == 0)
          {
            uint64_t v76 = *(void *)(v52 + 48);
            if (v76 != v52 + 40)
            {
              int v77 = 0;
              do
              {
                uint64_t v78 = v76 - 24;
                if (!v76) {
                  uint64_t v78 = 0;
                }
                *(_DWORD *)(v78 + 56) = v77++;
                uint64_t v76 = *(void *)(v76 + 8);
              }
              while (v76 != v52 + 40);
            }
            *(_WORD *)(v52 + 18) = v53 | 0x8000;
          }
          unsigned int v48 = *(_DWORD *)(v50 + 56);
          unsigned int v49 = *(_DWORD *)(v51 + 56);
        }
        else
        {
          uint64_t v46 = *(void *)(v44 + 40);
          int v47 = *(__int16 *)(v46 + 18);
          if ((v47 & 0x80000000) == 0)
          {
            uint64_t v73 = *(void *)(v46 + 48);
            if (v73 != v46 + 40)
            {
              int v74 = 0;
              do
              {
                uint64_t v75 = v73 - 24;
                if (!v73) {
                  uint64_t v75 = 0;
                }
                *(_DWORD *)(v75 + 56) = v74++;
                uint64_t v73 = *(void *)(v73 + 8);
              }
              while (v73 != v46 + 40);
            }
            *(_WORD *)(v46 + 18) = v47 | 0x8000;
          }
          unsigned int v48 = *(_DWORD *)(v44 + 56);
          unsigned int v49 = *(_DWORD *)(v45 + 56);
        }
        if (v48 < v49)
        {
          *a1 = v44;
          *a2 = v45;
          uint64_t v54 = a1[1];
          a1[1] = a2[1];
          a2[1] = v54;
        }
      }
    }
  }
  return result;
}

void *sub_1CCD46198(void *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  if (*a2 == *result)
  {
    uint64_t v9 = a2[1];
    uint64_t v10 = result[1];
    uint64_t v11 = *(void *)(v9 + 40);
    int v12 = *(__int16 *)(v11 + 18);
    if ((v12 & 0x80000000) == 0)
    {
      uint64_t v56 = *(void *)(v11 + 48);
      if (v56 != v11 + 40)
      {
        int v57 = 0;
        do
        {
          uint64_t v58 = v56 - 24;
          if (!v56) {
            uint64_t v58 = 0;
          }
          *(_DWORD *)(v58 + 56) = v57++;
          uint64_t v56 = *(void *)(v56 + 8);
        }
        while (v56 != v11 + 40);
      }
      *(_WORD *)(v11 + 18) = v12 | 0x8000;
    }
    unsigned int v7 = *(_DWORD *)(v9 + 56);
    unsigned int v8 = *(_DWORD *)(v10 + 56);
  }
  else
  {
    uint64_t v5 = *(void *)(v3 + 40);
    int v6 = *(__int16 *)(v5 + 18);
    if ((v6 & 0x80000000) == 0)
    {
      uint64_t v53 = *(void *)(v5 + 48);
      if (v53 != v5 + 40)
      {
        int v54 = 0;
        do
        {
          uint64_t v55 = v53 - 24;
          if (!v53) {
            uint64_t v55 = 0;
          }
          *(_DWORD *)(v55 + 56) = v54++;
          uint64_t v53 = *(void *)(v53 + 8);
        }
        while (v53 != v5 + 40);
      }
      *(_WORD *)(v5 + 18) = v6 | 0x8000;
    }
    unsigned int v7 = *(_DWORD *)(v3 + 56);
    unsigned int v8 = *(_DWORD *)(v4 + 56);
  }
  if (v7 >= v8)
  {
    uint64_t v18 = *a3;
    if (*a3 == v3)
    {
      uint64_t v33 = a3[1];
      uint64_t v34 = a2[1];
      uint64_t v35 = *(void *)(v33 + 40);
      int v36 = *(__int16 *)(v35 + 18);
      if ((v36 & 0x80000000) == 0)
      {
        uint64_t v68 = *(void *)(v35 + 48);
        if (v68 != v35 + 40)
        {
          int v69 = 0;
          do
          {
            uint64_t v70 = v68 - 24;
            if (!v68) {
              uint64_t v70 = 0;
            }
            *(_DWORD *)(v70 + 56) = v69++;
            uint64_t v68 = *(void *)(v68 + 8);
          }
          while (v68 != v35 + 40);
        }
        *(_WORD *)(v35 + 18) = v36 | 0x8000;
      }
      unsigned int v21 = *(_DWORD *)(v33 + 56);
      unsigned int v22 = *(_DWORD *)(v34 + 56);
    }
    else
    {
      uint64_t v19 = *(void *)(v18 + 40);
      int v20 = *(__int16 *)(v19 + 18);
      if ((v20 & 0x80000000) == 0)
      {
        uint64_t v62 = *(void *)(v19 + 48);
        if (v62 != v19 + 40)
        {
          int v63 = 0;
          do
          {
            uint64_t v64 = v62 - 24;
            if (!v62) {
              uint64_t v64 = 0;
            }
            *(_DWORD *)(v64 + 56) = v63++;
            uint64_t v62 = *(void *)(v62 + 8);
          }
          while (v62 != v19 + 40);
        }
        *(_WORD *)(v19 + 18) = v20 | 0x8000;
      }
      unsigned int v21 = *(_DWORD *)(v18 + 56);
      unsigned int v22 = *(_DWORD *)(v3 + 56);
    }
    if (v21 < v22)
    {
      *a2 = v18;
      *a3 = v3;
      unsigned int v37 = a2 + 1;
      uint64_t v38 = a2[1];
      a2[1] = a3[1];
      a3[1] = v38;
      uint64_t v39 = *a2;
      uint64_t v40 = *result;
      if (*a2 == *result)
      {
        uint64_t v48 = *v37;
        uint64_t v49 = result[1];
        uint64_t v50 = *(void *)(*v37 + 40);
        int v51 = *(__int16 *)(v50 + 18);
        if ((v51 & 0x80000000) == 0)
        {
          uint64_t v79 = *(void *)(v50 + 48);
          if (v79 != v50 + 40)
          {
            int v80 = 0;
            do
            {
              uint64_t v81 = v79 - 24;
              if (!v79) {
                uint64_t v81 = 0;
              }
              *(_DWORD *)(v81 + 56) = v80++;
              uint64_t v79 = *(void *)(v79 + 8);
            }
            while (v79 != v50 + 40);
          }
          *(_WORD *)(v50 + 18) = v51 | 0x8000;
        }
        unsigned int v43 = *(_DWORD *)(v48 + 56);
        unsigned int v44 = *(_DWORD *)(v49 + 56);
      }
      else
      {
        uint64_t v41 = *(void *)(v39 + 40);
        int v42 = *(__int16 *)(v41 + 18);
        if ((v42 & 0x80000000) == 0)
        {
          uint64_t v74 = *(void *)(v41 + 48);
          if (v74 != v41 + 40)
          {
            int v75 = 0;
            do
            {
              uint64_t v76 = v74 - 24;
              if (!v74) {
                uint64_t v76 = 0;
              }
              *(_DWORD *)(v76 + 56) = v75++;
              uint64_t v74 = *(void *)(v74 + 8);
            }
            while (v74 != v41 + 40);
          }
          *(_WORD *)(v41 + 18) = v42 | 0x8000;
        }
        unsigned int v43 = *(_DWORD *)(v39 + 56);
        unsigned int v44 = *(_DWORD *)(v40 + 56);
      }
      if (v43 < v44)
      {
        *result++ = v39;
        *a2 = v40;
        goto LABEL_35;
      }
    }
  }
  else
  {
    uint64_t v13 = *a3;
    if (*a3 == v3)
    {
      uint64_t v23 = a3[1];
      uint64_t v24 = a2[1];
      uint64_t v25 = *(void *)(v23 + 40);
      int v26 = *(__int16 *)(v25 + 18);
      if ((v26 & 0x80000000) == 0)
      {
        uint64_t v65 = *(void *)(v25 + 48);
        if (v65 != v25 + 40)
        {
          int v66 = 0;
          do
          {
            uint64_t v67 = v65 - 24;
            if (!v65) {
              uint64_t v67 = 0;
            }
            *(_DWORD *)(v67 + 56) = v66++;
            uint64_t v65 = *(void *)(v65 + 8);
          }
          while (v65 != v25 + 40);
        }
        *(_WORD *)(v25 + 18) = v26 | 0x8000;
      }
      unsigned int v16 = *(_DWORD *)(v23 + 56);
      unsigned int v17 = *(_DWORD *)(v24 + 56);
    }
    else
    {
      uint64_t v14 = *(void *)(v13 + 40);
      int v15 = *(__int16 *)(v14 + 18);
      if ((v15 & 0x80000000) == 0)
      {
        uint64_t v59 = *(void *)(v14 + 48);
        if (v59 != v14 + 40)
        {
          int v60 = 0;
          do
          {
            uint64_t v61 = v59 - 24;
            if (!v59) {
              uint64_t v61 = 0;
            }
            *(_DWORD *)(v61 + 56) = v60++;
            uint64_t v59 = *(void *)(v59 + 8);
          }
          while (v59 != v14 + 40);
        }
        *(_WORD *)(v14 + 18) = v15 | 0x8000;
      }
      unsigned int v16 = *(_DWORD *)(v13 + 56);
      unsigned int v17 = *(_DWORD *)(v3 + 56);
    }
    if (v16 < v17)
    {
      *result++ = v13;
      *a3 = v4;
      unsigned int v27 = a3 + 1;
LABEL_30:
      unsigned int v37 = v27;
LABEL_35:
      uint64_t v52 = *result;
      void *result = *v37;
      *unsigned int v37 = v52;
      return result;
    }
    void *result = v3;
    *a2 = v4;
    uint64_t v28 = result[1];
    result[1] = a2[1];
    a2[1] = v28;
    uint64_t v29 = *a3;
    uint64_t v30 = *a2;
    if (*a3 != *a2)
    {
      uint64_t v31 = *(void *)(v29 + 40);
      int v32 = *(__int16 *)(v31 + 18);
      if ((v32 & 0x80000000) == 0)
      {
        uint64_t v71 = *(void *)(v31 + 48);
        if (v71 != v31 + 40)
        {
          int v72 = 0;
          do
          {
            uint64_t v73 = v71 - 24;
            if (!v71) {
              uint64_t v73 = 0;
            }
            *(_DWORD *)(v73 + 56) = v72++;
            uint64_t v71 = *(void *)(v71 + 8);
          }
          while (v71 != v31 + 40);
        }
        *(_WORD *)(v31 + 18) = v32 | 0x8000;
      }
      if (*(_DWORD *)(v29 + 56) >= *(_DWORD *)(v30 + 56)) {
        return result;
      }
LABEL_29:
      *a2 = v29;
      *a3 = v30;
      unsigned int v27 = a3 + 1;
      uint64_t result = a2 + 1;
      goto LABEL_30;
    }
    uint64_t v45 = a3[1];
    uint64_t v46 = *(void *)(v45 + 40);
    int v47 = *(__int16 *)(v46 + 18);
    if ((v47 & 0x80000000) == 0)
    {
      uint64_t v77 = *(void *)(v46 + 48);
      if (v77 != v46 + 40)
      {
        int v78 = 0;
        do
        {
          uint64_t result = (void *)(v77 - 24);
          if (!v77) {
            uint64_t result = 0;
          }
          *((_DWORD *)result + 14) = v78++;
          uint64_t v77 = *(void *)(v77 + 8);
        }
        while (v77 != v46 + 40);
      }
      *(_WORD *)(v46 + 18) = v47 | 0x8000;
    }
    if (*(_DWORD *)(v45 + 56) < *(_DWORD *)(v28 + 56)) {
      goto LABEL_29;
    }
  }
  return result;
}

BOOL sub_1CCD46604(uint64_t *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *((void *)a2 - 2);
      uint64_t v7 = *a1;
      if (v6 == *a1)
      {
        uint64_t v44 = *((void *)a2 - 1);
        uint64_t v45 = a1[1];
        uint64_t v46 = *(void *)(v44 + 40);
        int v47 = *(__int16 *)(v46 + 18);
        if ((v47 & 0x80000000) == 0)
        {
          uint64_t v52 = *(void *)(v46 + 48);
          if (v52 != v46 + 40)
          {
            int v53 = 0;
            do
            {
              uint64_t v54 = v52 - 24;
              if (!v52) {
                uint64_t v54 = 0;
              }
              *(_DWORD *)(v54 + 56) = v53++;
              uint64_t v52 = *(void *)(v52 + 8);
            }
            while (v52 != v46 + 40);
          }
          *(_WORD *)(v46 + 18) = v47 | 0x8000;
        }
        unsigned int v10 = *(_DWORD *)(v44 + 56);
        unsigned int v11 = *(_DWORD *)(v45 + 56);
      }
      else
      {
        uint64_t v8 = *(void *)(v6 + 40);
        int v9 = *(__int16 *)(v8 + 18);
        if ((v9 & 0x80000000) == 0)
        {
          uint64_t v49 = *(void *)(v8 + 48);
          if (v49 != v8 + 40)
          {
            int v50 = 0;
            do
            {
              uint64_t v51 = v49 - 24;
              if (!v49) {
                uint64_t v51 = 0;
              }
              *(_DWORD *)(v51 + 56) = v50++;
              uint64_t v49 = *(void *)(v49 + 8);
            }
            while (v49 != v8 + 40);
          }
          *(_WORD *)(v8 + 18) = v9 | 0x8000;
        }
        unsigned int v10 = *(_DWORD *)(v6 + 56);
        unsigned int v11 = *(_DWORD *)(v7 + 56);
      }
      if (v10 < v11)
      {
        *a1 = v6;
        *((void *)a2 - 2) = v7;
        uint64_t v48 = a1[1];
        a1[1] = *((void *)a2 - 1);
        *((void *)a2 - 1) = v48;
      }
      return 1;
    case 3:
      sub_1CCD46198(a1, a1 + 2, (uint64_t *)a2 - 2);
      return 1;
    case 4:
      sub_1CCD469EC(a1, a1 + 2, a1 + 4, (uint64_t *)a2 - 2);
      return 1;
    case 5:
      sub_1CCD45DC4(a1, a1 + 2, a1 + 4, a1 + 6, (uint64_t *)a2 - 2);
      return 1;
    default:
      int v12 = a1 + 4;
      sub_1CCD46198(a1, a1 + 2, a1 + 4);
      uint64_t v13 = (char *)(a1 + 6);
      if (a1 + 6 == (uint64_t *)a2) {
        return 1;
      }
      int v14 = 0;
      break;
  }
  while (2)
  {
    uint64_t v15 = *(void *)v13;
    uint64_t v16 = *v12;
    if (*(void *)v13 == *v12)
    {
      uint64_t v19 = *((void *)v13 + 1);
      uint64_t v20 = v12[1];
      uint64_t v21 = *(void *)(v19 + 40);
      int v22 = *(__int16 *)(v21 + 18);
      if ((v22 & 0x80000000) == 0)
      {
        uint64_t v41 = *(void *)(v21 + 48);
        if (v41 != v21 + 40)
        {
          int v42 = 0;
          do
          {
            uint64_t v43 = v41 - 24;
            if (!v41) {
              uint64_t v43 = 0;
            }
            *(_DWORD *)(v43 + 56) = v42++;
            uint64_t v41 = *(void *)(v41 + 8);
          }
          while (v41 != v21 + 40);
        }
        *(_WORD *)(v21 + 18) = v22 | 0x8000;
      }
      if (*(_DWORD *)(v19 + 56) >= *(_DWORD *)(v20 + 56)) {
        goto LABEL_37;
      }
    }
    else
    {
      uint64_t v17 = *(void *)(v15 + 40);
      int v18 = *(__int16 *)(v17 + 18);
      if ((v18 & 0x80000000) == 0)
      {
        uint64_t v38 = *(void *)(v17 + 48);
        if (v38 != v17 + 40)
        {
          int v39 = 0;
          do
          {
            uint64_t v40 = v38 - 24;
            if (!v38) {
              uint64_t v40 = 0;
            }
            *(_DWORD *)(v40 + 56) = v39++;
            uint64_t v38 = *(void *)(v38 + 8);
          }
          while (v38 != v17 + 40);
        }
        *(_WORD *)(v17 + 18) = v18 | 0x8000;
      }
      if (*(_DWORD *)(v15 + 56) >= *(_DWORD *)(v16 + 56)) {
        goto LABEL_37;
      }
      uint64_t v19 = *((void *)v13 + 1);
    }
    *(void *)uint64_t v13 = v16;
    *((void *)v13 + 1) = v12[1];
    uint64_t v23 = a1;
    if (v12 == a1) {
      goto LABEL_36;
    }
    uint64_t v24 = v12;
    while (1)
    {
      uint64_t v26 = *(v24 - 2);
      v24 -= 2;
      uint64_t v25 = v26;
      if (v15 == v26) {
        break;
      }
      uint64_t v27 = *(void *)(v15 + 40);
      int v28 = *(__int16 *)(v27 + 18);
      if ((v28 & 0x80000000) == 0)
      {
        uint64_t v32 = *(void *)(v27 + 48);
        if (v32 != v27 + 40)
        {
          int v33 = 0;
          do
          {
            uint64_t v34 = v32 - 24;
            if (!v32) {
              uint64_t v34 = 0;
            }
            *(_DWORD *)(v34 + 56) = v33++;
            uint64_t v32 = *(void *)(v32 + 8);
          }
          while (v32 != v27 + 40);
        }
        *(_WORD *)(v27 + 18) = v28 | 0x8000;
      }
      if (*(_DWORD *)(v15 + 56) >= *(_DWORD *)(v25 + 56)) {
        goto LABEL_35;
      }
      uint64_t v29 = *(v12 - 1);
LABEL_21:
      *int v12 = v25;
      v12[1] = v29;
      int v12 = v24;
      if (v24 == a1)
      {
        uint64_t v23 = a1;
        goto LABEL_36;
      }
    }
    uint64_t v29 = *(v12 - 1);
    uint64_t v30 = *(void *)(v19 + 40);
    int v31 = *(__int16 *)(v30 + 18);
    if ((v31 & 0x80000000) == 0)
    {
      uint64_t v35 = *(void *)(v30 + 48);
      if (v35 != v30 + 40)
      {
        int v36 = 0;
        do
        {
          uint64_t v37 = v35 - 24;
          if (!v35) {
            uint64_t v37 = 0;
          }
          *(_DWORD *)(v37 + 56) = v36++;
          uint64_t v35 = *(void *)(v35 + 8);
        }
        while (v35 != v30 + 40);
      }
      *(_WORD *)(v30 + 18) = v31 | 0x8000;
    }
    if (*(_DWORD *)(v19 + 56) < *(_DWORD *)(v29 + 56)) {
      goto LABEL_21;
    }
LABEL_35:
    uint64_t v23 = v12;
LABEL_36:
    uint64_t *v23 = v15;
    v23[1] = v19;
    if (++v14 != 8)
    {
LABEL_37:
      int v12 = (uint64_t *)v13;
      v13 += 16;
      if (v13 == a2) {
        return 1;
      }
      continue;
    }
    return v13 + 16 == a2;
  }
}

void *sub_1CCD469EC(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = sub_1CCD46198(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  if (*a4 == *a3)
  {
    uint64_t v15 = a4[1];
    uint64_t v16 = a3[1];
    uint64_t v17 = *(void *)(v15 + 40);
    int v18 = *(__int16 *)(v17 + 18);
    if ((v18 & 0x80000000) == 0)
    {
      uint64_t v45 = *(void *)(v17 + 48);
      if (v45 != v17 + 40)
      {
        int v46 = 0;
        do
        {
          uint64_t v47 = v45 - 24;
          if (!v45) {
            uint64_t v47 = 0;
          }
          *(_DWORD *)(v47 + 56) = v46++;
          uint64_t v45 = *(void *)(v45 + 8);
        }
        while (v45 != v17 + 40);
      }
      *(_WORD *)(v17 + 18) = v18 | 0x8000;
    }
    unsigned int v13 = *(_DWORD *)(v15 + 56);
    unsigned int v14 = *(_DWORD *)(v16 + 56);
  }
  else
  {
    uint64_t v11 = *(void *)(v9 + 40);
    int v12 = *(__int16 *)(v11 + 18);
    if ((v12 & 0x80000000) == 0)
    {
      uint64_t v42 = *(void *)(v11 + 48);
      if (v42 != v11 + 40)
      {
        int v43 = 0;
        do
        {
          uint64_t v44 = v42 - 24;
          if (!v42) {
            uint64_t v44 = 0;
          }
          *(_DWORD *)(v44 + 56) = v43++;
          uint64_t v42 = *(void *)(v42 + 8);
        }
        while (v42 != v11 + 40);
      }
      *(_WORD *)(v11 + 18) = v12 | 0x8000;
    }
    unsigned int v13 = *(_DWORD *)(v9 + 56);
    unsigned int v14 = *(_DWORD *)(v10 + 56);
  }
  if (v13 < v14)
  {
    *a3 = v9;
    *a4 = v10;
    uint64_t v19 = a3[1];
    a3[1] = a4[1];
    a4[1] = v19;
    uint64_t v20 = *a3;
    uint64_t v21 = *a2;
    if (*a3 == *a2)
    {
      uint64_t v26 = a3[1];
      uint64_t v27 = a2[1];
      uint64_t v28 = *(void *)(v26 + 40);
      int v29 = *(__int16 *)(v28 + 18);
      if ((v29 & 0x80000000) == 0)
      {
        uint64_t v51 = *(void *)(v28 + 48);
        if (v51 != v28 + 40)
        {
          int v52 = 0;
          do
          {
            uint64_t v53 = v51 - 24;
            if (!v51) {
              uint64_t v53 = 0;
            }
            *(_DWORD *)(v53 + 56) = v52++;
            uint64_t v51 = *(void *)(v51 + 8);
          }
          while (v51 != v28 + 40);
        }
        *(_WORD *)(v28 + 18) = v29 | 0x8000;
      }
      unsigned int v24 = *(_DWORD *)(v26 + 56);
      unsigned int v25 = *(_DWORD *)(v27 + 56);
    }
    else
    {
      uint64_t v22 = *(void *)(v20 + 40);
      int v23 = *(__int16 *)(v22 + 18);
      if ((v23 & 0x80000000) == 0)
      {
        uint64_t v48 = *(void *)(v22 + 48);
        if (v48 != v22 + 40)
        {
          int v49 = 0;
          do
          {
            uint64_t v50 = v48 - 24;
            if (!v48) {
              uint64_t v50 = 0;
            }
            *(_DWORD *)(v50 + 56) = v49++;
            uint64_t v48 = *(void *)(v48 + 8);
          }
          while (v48 != v22 + 40);
        }
        *(_WORD *)(v22 + 18) = v23 | 0x8000;
      }
      unsigned int v24 = *(_DWORD *)(v20 + 56);
      unsigned int v25 = *(_DWORD *)(v21 + 56);
    }
    if (v24 < v25)
    {
      *a2 = v20;
      *a3 = v21;
      uint64_t v30 = a2[1];
      a2[1] = a3[1];
      a3[1] = v30;
      uint64_t v31 = *a2;
      uint64_t v32 = *a1;
      if (*a2 == *a1)
      {
        uint64_t v37 = a2[1];
        uint64_t v38 = a1[1];
        uint64_t v39 = *(void *)(v37 + 40);
        int v40 = *(__int16 *)(v39 + 18);
        if ((v40 & 0x80000000) == 0)
        {
          uint64_t v57 = *(void *)(v39 + 48);
          if (v57 != v39 + 40)
          {
            int v58 = 0;
            do
            {
              uint64_t v59 = v57 - 24;
              if (!v57) {
                uint64_t v59 = 0;
              }
              *(_DWORD *)(v59 + 56) = v58++;
              uint64_t v57 = *(void *)(v57 + 8);
            }
            while (v57 != v39 + 40);
          }
          *(_WORD *)(v39 + 18) = v40 | 0x8000;
        }
        unsigned int v35 = *(_DWORD *)(v37 + 56);
        unsigned int v36 = *(_DWORD *)(v38 + 56);
      }
      else
      {
        uint64_t v33 = *(void *)(v31 + 40);
        int v34 = *(__int16 *)(v33 + 18);
        if ((v34 & 0x80000000) == 0)
        {
          uint64_t v54 = *(void *)(v33 + 48);
          if (v54 != v33 + 40)
          {
            int v55 = 0;
            do
            {
              uint64_t v56 = v54 - 24;
              if (!v54) {
                uint64_t v56 = 0;
              }
              *(_DWORD *)(v56 + 56) = v55++;
              uint64_t v54 = *(void *)(v54 + 8);
            }
            while (v54 != v33 + 40);
          }
          *(_WORD *)(v33 + 18) = v34 | 0x8000;
        }
        unsigned int v35 = *(_DWORD *)(v31 + 56);
        unsigned int v36 = *(_DWORD *)(v32 + 56);
      }
      if (v35 < v36)
      {
        *a1 = v31;
        *a2 = v32;
        uint64_t v41 = a1[1];
        a1[1] = a2[1];
        a2[1] = v41;
      }
    }
  }
  return result;
}

uint64_t sub_1CCD46CD0()
{
  v4.n128_u64[0] = (unint64_t)"View the CFG before DFA Jump Threading";
  v4.n128_u64[1] = 38;
  int v3 = 1;
  LOBYTE(v1) = 0;
  unsigned int v2 = &v1;
  sub_1CD4BCE90((llvm::cl::Option *)&unk_1EBCF1590, "dfa-jump-view-cfg-before", &v4, &v3, (unsigned char **)&v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF1590, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Max number of blocks searched to find a threading path";
  v4.n128_u64[1] = 54;
  int v3 = 1;
  int v1 = 20;
  unsigned int v2 = &v1;
  sub_1CD7627A0((long long *)&v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF1650, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Maximum cost accepted for the transformation";
  v4.n128_u64[1] = 44;
  int v3 = 1;
  int v1 = 50;
  unsigned int v2 = &v1;
  sub_1CD5165E4((uint64_t)&unk_1EBCF1710, "dfa-cost-threshold", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1710, &dword_1CB82C000);
}

void sub_1CCD46E10(uint64_t a1)
{
}

uint64_t sub_1CCD46EB0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF17D8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263DAB8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF17E0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD46E10;
    v5[1] = &PassRegistry;
    __n128 v4 = v5;
    std::__call_once(&qword_1EBCF17E0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD46F60(uint64_t a1, void *a2, llvm::DominatorTree *a3)
{
  uint64_t v230 = *MEMORY[0x1E4F143B8];
  v222[0] = 0;
  v222[1] = 0;
  unsigned int v223 = 0;
  uint64_t v216 = 0;
  uint64_t v217 = 0;
  LODWORD(v218) = 0;
  uint64_t v220 = 0;
  uint64_t v221 = 0;
  uint64_t v219 = 0;
  uint64_t v3 = *(void *)(a1 + 80);
  uint64_t v215 = a1 + 72;
  if (v3 == a1 + 72)
  {
    __n128 v4 = a3;
    uint64_t v5 = 0;
    *(void *)&long long v226 = &v227;
    *((void *)&v226 + 1) = 0x400000000;
  }
  else
  {
    do
    {
      uint64_t v6 = v3 - 24;
      if (!v3) {
        uint64_t v6 = 0;
      }
      uint64_t v7 = v6 + 40;
      uint64_t v8 = *(void *)(v6 + 48);
      while (v8 != v7)
      {
        if (v8) {
          uint64_t v9 = v8 - 24;
        }
        else {
          uint64_t v9 = 0;
        }
        int v10 = *(unsigned __int8 *)(v9 + 16);
        switch(*(unsigned char *)(v9 + 16))
        {
          case '/':
            int v23 = *(_DWORD *)(v9 + 20);
            if ((v23 & 0x40000000) != 0) {
              unsigned int v24 = *(uint64_t **)(v9 - 8);
            }
            else {
              unsigned int v24 = (uint64_t *)(v9 - 32 * (v23 & 0x7FFFFFF));
            }
            uint64_t v31 = *v24;
            uint64_t v32 = (uint64_t *)v24[4];
            LOBYTE(v226) = 0;
            goto LABEL_67;
          case '0':
            int v27 = *(_DWORD *)(v9 + 20);
            if ((v27 & 0x40000000) != 0) {
              uint64_t v28 = *(uint64_t **)(v9 - 8);
            }
            else {
              uint64_t v28 = (uint64_t *)(v9 - 32 * (v27 & 0x7FFFFFF));
            }
            uint64_t v31 = *v28;
            uint64_t v32 = (uint64_t *)v28[4];
            LOBYTE(v226) = 1;
LABEL_67:
            *((void *)&v226 + 1) = v31;
            int64_t v227 = v32;
            *(void *)(sub_1CD762B40((uint64_t)v222, (uint64_t)&v226) + 24) = v9;
            goto LABEL_68;
          case '2':
            int v25 = *(_DWORD *)(v9 + 20);
            if ((v25 & 0x40000000) != 0) {
              uint64_t v26 = *(uint64_t **)(v9 - 8);
            }
            else {
              uint64_t v26 = (uint64_t *)(v9 - 32 * (v25 & 0x7FFFFFF));
            }
            uint64_t v29 = *v26;
            uint64_t v30 = (uint64_t *)v26[4];
            LOBYTE(v226) = 0;
            goto LABEL_63;
          case '3':
            int v21 = *(_DWORD *)(v9 + 20);
            if ((v21 & 0x40000000) != 0) {
              uint64_t v22 = *(uint64_t **)(v9 - 8);
            }
            else {
              uint64_t v22 = (uint64_t *)(v9 - 32 * (v21 & 0x7FFFFFF));
            }
            uint64_t v29 = *v22;
            uint64_t v30 = (uint64_t *)v22[4];
            LOBYTE(v226) = 1;
LABEL_63:
            *((void *)&v226 + 1) = v29;
            int64_t v227 = v30;
            goto LABEL_64;
          default:
            if (v10 == 5)
            {
              if (*(_WORD *)(v9 + 18) != 15) {
                goto LABEL_68;
              }
              unsigned int v13 = (uint64_t *)(v9 - 32 * (*(_DWORD *)(v9 + 20) & 0x7FFFFFF));
              uint64_t v11 = *v13;
              if (!*v13) {
                goto LABEL_68;
              }
              uint64_t v12 = v13[4];
              if (!v12) {
                goto LABEL_68;
              }
            }
            else
            {
              if (v10 != 43) {
                goto LABEL_68;
              }
              uint64_t v11 = *(void *)(v9 - 64);
              if (!v11) {
                goto LABEL_68;
              }
              uint64_t v12 = *(void *)(v9 - 32);
              if (!v12) {
                goto LABEL_68;
              }
            }
            uint64_t v224 = 0;
            int64_t v225 = 0;
            *(void *)&long long v226 = v11;
            *((void *)&v226 + 1) = &v225;
            int64_t v227 = &v224;
            uint64_t v228 = &v225;
            int v14 = *(unsigned __int8 *)(v12 + 16);
            if (v14 == 5)
            {
              if (*(_WORD *)(v12 + 18) != 17) {
                goto LABEL_68;
              }
              uint64_t v15 = *(void *)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF));
              if (sub_1CCD485B8((uint64_t)&v226, v15))
              {
                if (v15 && *(unsigned __int8 *)(v15 + 16) >= 0x1Cu)
                {
                  uint64_t v224 = v15;
                  int v18 = *(uint64_t **)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) + 32);
                  if (v225 == v18) {
                    goto LABEL_48;
                  }
                }
              }
              uint64_t v15 = *(void *)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) + 32);
              if (!sub_1CCD485B8((uint64_t)&v226, v15)) {
                goto LABEL_68;
              }
              if (!v15 || *(unsigned __int8 *)(v15 + 16) < 0x1Cu) {
                goto LABEL_68;
              }
              uint64_t v224 = v15;
              uint64_t v16 = (uint64_t **)(v12 - 32 * (*(_DWORD *)(v12 + 20) & 0x7FFFFFF));
            }
            else
            {
              if (v14 != 45) {
                goto LABEL_68;
              }
              uint64_t v16 = (uint64_t **)(v12 - 64);
              uint64_t v15 = *(void *)(v12 - 64);
              if (sub_1CCD485B8((uint64_t)&v226, v15))
              {
                if (v15 && *(unsigned __int8 *)(v15 + 16) >= 0x1Cu)
                {
                  uint64_t v224 = v15;
                  int v18 = *(uint64_t **)(v12 - 32);
                  if (v225 == v18) {
                    goto LABEL_48;
                  }
                }
              }
              uint64_t v15 = *(void *)(v12 - 32);
              if (!sub_1CCD485B8((uint64_t)&v226, v15) || !v15 || *(unsigned __int8 *)(v15 + 16) < 0x1Cu) {
                goto LABEL_68;
              }
              uint64_t v224 = v15;
            }
            int v18 = *v16;
            if (v225 != *v16) {
              goto LABEL_68;
            }
LABEL_48:
            LOBYTE(v226) = *(unsigned char *)(v15 + 16) == 48;
            *((void *)&v226 + 1) = v11;
            int64_t v227 = v18;
            uint64_t v228 = (uint64_t **)v9;
            char v229 = 1;
LABEL_64:
            *(void *)sub_1CD762A6C((uint64_t)&v216, &v226) = v9;
LABEL_68:
            uint64_t v8 = *(void *)(v8 + 8);
            break;
        }
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v215);
    uint64_t v34 = v219;
    uint64_t v33 = v220;
    *(void *)&long long v226 = &v227;
    *((void *)&v226 + 1) = 0x400000000;
    uint64_t v5 = v222[0];
    if (v219 != v220)
    {
      int v208 = v223;
      uint64_t v209 = v222[0] + 32 * v223;
      do
      {
        int64_t v225 = 0;
        if (sub_1CCD48364(v5, v208, (unsigned __int8 *)v34, &v225) && v225 != (uint64_t *)v209)
        {
          uint64_t v210 = *(void *)(v34 + 24);
          int v211 = DWORD2(v226);
          if (DWORD2(v226) >= HIDWORD(v226)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v212 = (void *)(v226 + 16 * DWORD2(v226));
          *int v212 = v225[3];
          v212[1] = v210;
          DWORD2(v226) = v211 + 1;
        }
        v34 += 32;
      }
      while (v34 != v33);
    }
    __n128 v4 = a3;
  }
  sub_1CD456CB4(&v216);
  MEMORY[0x1D25D9CD0](v5, 8);
  unsigned int v35 = (const llvm::Instruction **)v226;
  if (DWORD2(v226))
  {
    char v36 = 0;
    uint64_t v37 = (const llvm::Instruction **)(v226 + 16 * DWORD2(v226));
    while (1)
    {
      int v38 = (*(uint64_t (**)(void, void, BOOL))(*(void *)*a2 + 416))(*a2, *(void *)*v35, *((unsigned char *)*v35 + 16) == 48);
      uint64_t v39 = v35[1];
      if (v38 && (*((unsigned char *)v39 + 16) & 0xFE) != 0x32)
      {
        int v40 = *v35;
        int v41 = *((_DWORD *)*v35 + 5);
        if ((v41 & 0x40000000) != 0) {
          uint64_t v42 = (void *)*((void *)v40 - 1);
        }
        else {
          uint64_t v42 = (void *)((char *)v40 - 32 * (v41 & 0x7FFFFFF));
        }
        int v43 = (void *)*v42;
        uint64_t v44 = v42[4];
        if (*((unsigned char *)v40 + 16) == 48)
        {
          LOWORD(v220) = 257;
          char v45 = 23;
        }
        else
        {
          LOWORD(v220) = 257;
          char v45 = 22;
        }
        int v46 = llvm::BinaryOperator::Create(v45, v43, v44, &v216, 0);
        uint64_t v47 = v46;
        uint64_t v48 = v35[1];
        if ((*((unsigned char *)v48 + 23) & 0x10) != 0)
        {
          uint64_t v49 = ***(void ***)v48;
          uint64_t v50 = *(void *)(v49 + 152);
          uint64_t v51 = *(unsigned int *)(v49 + 168);
          if (v51)
          {
            LODWORD(v52) = (v51 - 1) & ((v48 >> 4) ^ (v48 >> 9));
            uint64_t v53 = (const llvm::Instruction **)(v50 + 16 * v52);
            uint64_t v54 = *v53;
            if (*v53 != v48)
            {
              int v55 = 1;
              do
              {
                if (v54 == (const llvm::Instruction *)-4096) {
                  goto LABEL_89;
                }
                int v56 = v52 + v55++;
                uint64_t v52 = v56 & (v51 - 1);
                uint64_t v54 = *(const llvm::Instruction **)(v50 + 16 * v52);
              }
              while (v54 != v48);
              uint64_t v53 = (const llvm::Instruction **)(v50 + 16 * v52);
            }
          }
          else
          {
LABEL_89:
            uint64_t v53 = (const llvm::Instruction **)(v50 + 16 * v51);
          }
          uint64_t v57 = v53[1];
          int v60 = *(void *)v57;
          uint64_t v59 = (char *)v57 + 16;
          int v58 = v60;
        }
        else
        {
          int v58 = 0;
          uint64_t v59 = &byte_1CFBCE98E;
        }
        LOWORD(v220) = 773;
        uint64_t v216 = v59;
        uint64_t v217 = v58;
        int v218 = ".recomposed";
        llvm::Value::setNameImpl(v46, &v216);
        if (v47 && !*((unsigned char *)v47 + 16))
        {
          if ((*((unsigned char *)v47 + 23) & 0x10) == 0) {
            goto LABEL_299;
          }
          uint64_t v163 = ***(void ***)v47;
          uint64_t v164 = *(void *)(v163 + 152);
          uint64_t v165 = *(unsigned int *)(v163 + 168);
          if (v165)
          {
            LODWORD(v166) = (v165 - 1) & ((v47 >> 4) ^ (v47 >> 9));
            uint64_t v167 = (llvm::Value **)(v164 + 16 * v166);
            uint64_t v168 = *v167;
            if (*v167 != v47)
            {
              int v169 = 1;
              do
              {
                if (v168 == (llvm::Value *)-4096) {
                  goto LABEL_291;
                }
                int v170 = v166 + v169++;
                uint64_t v166 = v170 & (v165 - 1);
                uint64_t v168 = *(llvm::Value **)(v164 + 16 * v166);
              }
              while (v168 != v47);
              uint64_t v167 = (llvm::Value **)(v164 + 16 * v166);
            }
          }
          else
          {
LABEL_291:
            uint64_t v167 = (llvm::Value **)(v164 + 16 * v165);
          }
          uint64_t v195 = v167[1];
          unint64_t v198 = *(void *)v195;
          BOOL v196 = (char *)v195 + 16;
          unint64_t v197 = v198;
          if (v198 >= 5 && (*(_DWORD *)v196 == *(_DWORD *)"llvm." ? (BOOL v199 = v196[4] == aLlvm_1[4]) : (BOOL v199 = 0), v199))
          {
            *((_DWORD *)v47 + 8) |= 0x2000u;
            int v200 = llvm::Function::lookupIntrinsicID(v196, v197);
          }
          else
          {
LABEL_299:
            int v200 = 0;
            *((_DWORD *)v47 + 8) &= ~0x2000u;
          }
          *((_DWORD *)v47 + 9) = v200;
        }
        sub_1CC5C6C08((void *)(*((void *)v35[1] + 5) + 40), (uint64_t)v35[1] + 24, v47);
        uint64_t v61 = v35[1];
        v35[1] = v47;
        llvm::Value::doRAUW(v61, v47, (llvm::Value *)1);
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      uint64_t v62 = *v35;
      if (!v38) {
        break;
      }
      if (*((void *)v39 + 5) != *((void *)v62 + 5))
      {
        if (llvm::DominatorTree::dominates(v4, v62, v39))
        {
          int v63 = v35[1];
          uint64_t v64 = *v35;
          goto LABEL_107;
        }
        if (llvm::DominatorTree::dominates(v4, v35[1], *v35))
        {
          int v63 = *v35;
          uint64_t v64 = v35[1];
LABEL_107:
          llvm::Instruction::moveAfter(v63, v64);
LABEL_108:
          char v36 = 1;
          goto LABEL_228;
        }
LABEL_109:
        int v69 = (llvm::BasicBlock *)*((void *)*v35 + 5);
        uint64_t v70 = (llvm::BasicBlock *)*((void *)v35[1] + 5);
        if ((llvm::BasicBlock *)llvm::BasicBlock::getSingleSuccessor(v70) != v69) {
          goto LABEL_228;
        }
        uint64_t UniquePredecessor = llvm::BasicBlock::getUniquePredecessor(v70);
        if (!UniquePredecessor) {
          goto LABEL_228;
        }
        uint64_t v73 = UniquePredecessor;
        uint64_t v74 = (uint64_t)v35[1] + 24;
        for (uint64_t i = *((void *)v70 + 6); i != v74; uint64_t i = *(void *)(i + 8))
        {
          if (i) {
            uint64_t v76 = (llvm *)(i - 24);
          }
          else {
            uint64_t v76 = 0;
          }
          if ((llvm::isGuaranteedToTransferExecutionToSuccessor(v76, v72) & 1) == 0) {
            goto LABEL_271;
          }
        }
        uint64_t v90 = (uint64_t)*v35 + 24;
        for (uint64_t j = *((void *)v69 + 6); j != v90; uint64_t j = *(void *)(j + 8))
        {
          if (j) {
            uint64_t v92 = (llvm *)(j - 24);
          }
          else {
            uint64_t v92 = 0;
          }
          if ((llvm::isGuaranteedToTransferExecutionToSuccessor(v92, v72) & 1) == 0) {
            goto LABEL_271;
          }
        }
        unsigned int v94 = (void *)(v73 + 40);
        int v93 = *(void **)(v73 + 40);
        if (v93 != (void *)(v73 + 40))
        {
          unsigned int v95 = v93 - 3;
          if (!v93) {
            unsigned int v95 = 0;
          }
          int v96 = *((unsigned __int8 *)v95 + 16);
          if (v96 != 30)
          {
            int v171 = 2;
            switch(*((unsigned char *)v95 + 16))
            {
              case 0x1E:
LABEL_334:
                __break(1u);
                JUMPOUT(0x1CCD48090);
              case 0x1F:
                int v171 = (*((_DWORD *)v95 + 5) >> 1) & 0x3FFFFFF;
                goto LABEL_302;
              case 0x20:
              case 0x26:
                int v171 = (*((_DWORD *)v95 + 5) & 0x7FFFFFF) - 1;
                goto LABEL_302;
              case 0x21:
                goto LABEL_144;
              case 0x24:
                int v171 = *((_WORD *)v95 + 9) & 1;
                goto LABEL_302;
              case 0x25:
                int v171 = 1;
                goto LABEL_144;
              case 0x27:
                int v171 = *((_DWORD *)v95 + 20) + 1;
LABEL_302:
                if (!v171) {
                  goto LABEL_242;
                }
                goto LABEL_144;
              default:
                goto LABEL_242;
            }
          }
          if ((*((_DWORD *)v95 + 5) & 0x7FFFFFF) == 3) {
            int v171 = 2;
          }
          else {
            int v171 = 1;
          }
LABEL_144:
          uint64_t v97 = 0;
          int v98 = (llvm::BasicBlock **)(v95 - 4);
          while (1)
          {
            uint64_t v99 = v98;
            if (v96 != 30)
            {
              uint64_t v99 = (llvm::BasicBlock **)(v95 - 4);
              switch(*((unsigned char *)v95 + 16))
              {
                case ' ':
                case '&':
                  int v105 = *((_DWORD *)v95 + 5);
                  if ((v105 & 0x40000000) != 0) {
                    uint64_t v106 = (void *)*(v95 - 1);
                  }
                  else {
                    uint64_t v106 = &v95[-4 * (v105 & 0x7FFFFFF)];
                  }
                  uint64_t v104 = &v106[4 * v97];
                  goto LABEL_159;
                case '!':
                  uint64_t v107 = 0x1FFFFFFFFFFFFFF8;
                  if (!v97) {
                    uint64_t v107 = 0x1FFFFFFFFFFFFFF4;
                  }
                  uint64_t v99 = (llvm::BasicBlock **)&v95[v107];
                  break;
                case '""':
                case '#':
                  goto LABEL_334;
                case '$':
                  if ((*((_WORD *)v95 + 9) & 1) == 0)
                  {
                    int v100 = 0;
                    goto LABEL_148;
                  }
                  uint64_t v99 = (llvm::BasicBlock **)&v95[-4 * (*((_DWORD *)v95 + 5) & 0x7FFFFFF) + 4];
                  break;
                case '%':
                  break;
                case '\'':
                  if (v97) {
                    uint64_t v99 = (llvm::BasicBlock **)&v95[4 * (v97 - 1) - 4 + -4 * *((unsigned int *)v95 + 20)];
                  }
                  else {
                    uint64_t v99 = (llvm::BasicBlock **)&v95[-4 * *((unsigned int *)v95 + 20) - 8];
                  }
                  break;
                default:
                  int v102 = *((_DWORD *)v95 + 5);
                  if ((v102 & 0x40000000) != 0) {
                    int v103 = (void *)*(v95 - 1);
                  }
                  else {
                    int v103 = &v95[-4 * (v102 & 0x7FFFFFF)];
                  }
                  uint64_t v104 = &v103[8 * v97];
LABEL_159:
                  uint64_t v99 = (llvm::BasicBlock **)(v104 + 4);
                  break;
              }
            }
            int v100 = *v99;
LABEL_148:
            if (v69 != v100 && v70 != v100) {
              break;
            }
            ++v97;
            v98 -= 4;
            if (v171 == v97) {
              goto LABEL_242;
            }
          }
LABEL_271:
          __n128 v4 = a3;
          goto LABEL_228;
        }
LABEL_242:
        uint64_t v172 = *((void *)v69 + 1);
        if (v172)
        {
          while (1)
          {
            uint64_t v173 = *(void *)(v172 + 24);
            unsigned int v174 = *(unsigned __int8 *)(v173 + 16);
            BOOL v175 = v173 && v174 >= 0x1C;
            if (v175 && v174 - 29 <= 0xA) {
              break;
            }
            uint64_t v172 = *(void *)(v172 + 8);
            if (!v172) {
              goto LABEL_252;
            }
          }
LABEL_267:
          uint64_t v182 = *(void **)(v173 + 40);
          if (v70 != (llvm::BasicBlock *)v182 && v73 != (void)v182) {
            goto LABEL_271;
          }
          while (1)
          {
            uint64_t v172 = *(void *)(v172 + 8);
            if (!v172) {
              break;
            }
            uint64_t v173 = *(void *)(v172 + 24);
            unsigned int v179 = *(unsigned __int8 *)(v173 + 16);
            if (v173) {
              BOOL v180 = v179 >= 0x1C;
            }
            else {
              BOOL v180 = 0;
            }
            if (v180 && v179 - 29 <= 0xA) {
              goto LABEL_267;
            }
          }
        }
LABEL_252:
        if (v93 == v94)
        {
          uint64_t v178 = 0;
        }
        else
        {
          if (v93) {
            int v177 = (unsigned __int8 *)(v93 - 3);
          }
          else {
            int v177 = 0;
          }
          if (v177[16] - 29 >= 0xB) {
            uint64_t v178 = 0;
          }
          else {
            uint64_t v178 = (llvm::Instruction *)v177;
          }
        }
        llvm::Instruction::moveBefore(*v35, v178);
        if (!v38)
        {
          char v36 = 1;
          char v65 = 1;
          __n128 v4 = a3;
LABEL_102:
          if ((*((unsigned char *)v35[1] + 16) & 0xFE) == 0x32)
          {
            int v66 = *v35;
            int v67 = *((_DWORD *)*v35 + 5);
            if ((v67 & 0x40000000) != 0) {
              uint64_t v68 = (char *)*((void *)v66 - 1);
            }
            else {
              uint64_t v68 = (char *)v66 - 32 * (v67 & 0x7FFFFFF);
            }
            uint64_t v77 = *(uint64_t ****)v68;
            int v78 = (llvm::Value *)*((void *)v68 + 4);
            LOWORD(v220) = 257;
            uint64_t v79 = llvm::BinaryOperator::Create(17, v66, (uint64_t)v78, &v216, 0);
            LOWORD(v220) = 257;
            int v80 = llvm::BinaryOperator::Create(15, v77, (uint64_t)v79, &v216, 0);
            if ((v65 & 1) == 0) {
              llvm::Instruction::moveBefore(*v35, v35[1]);
            }
            sub_1CC5C6C08((void *)(*((void *)v35[1] + 5) + 40), (uint64_t)v35[1] + 24, v79);
            sub_1CC5C6C08((void *)(*((void *)v79 + 5) + 40), (uint64_t)v79 + 24, v80);
            if ((sub_1CC16A22C(v77, 0, (uint64_t)*v35, (uint64_t)v4, 0, 0) & 1) == 0)
            {
              uint64_t v81 = (char *)operator new(0x60uLL);
              *((_DWORD *)v81 + 13) = *((_DWORD *)v81 + 13) & 0x38000000 | 1;
              *(void *)uint64_t v81 = 0;
              *((void *)v81 + 1) = 0;
              *((void *)v81 + 2) = 0;
              *((void *)v81 + 3) = v81 + 32;
              if ((*((unsigned char *)v77 + 23) & 0x10) != 0)
              {
                uint64_t v82 = ***v77;
                uint64_t v83 = *(void *)(v82 + 152);
                uint64_t v84 = *(unsigned int *)(v82 + 168);
                if (v84)
                {
                  LODWORD(v85) = (v84 - 1) & ((v77 >> 4) ^ (v77 >> 9));
                  int v86 = (uint64_t ****)(v83 + 16 * v85);
                  uint64_t v87 = *v86;
                  if (*v86 != v77)
                  {
                    int v88 = 1;
                    do
                    {
                      if (v87 == (uint64_t ***)-4096) {
                        goto LABEL_174;
                      }
                      int v89 = v85 + v88++;
                      uint64_t v85 = v89 & (v84 - 1);
                      uint64_t v87 = *(uint64_t ****)(v83 + 16 * v85);
                    }
                    while (v87 != v77);
                    int v86 = (uint64_t ****)(v83 + 16 * v85);
                  }
                }
                else
                {
LABEL_174:
                  int v86 = (uint64_t ****)(v83 + 16 * v84);
                }
                uint64_t v108 = v86[1];
                int v111 = *v108;
                uint64_t v110 = (const char *)(v108 + 2);
                uint64_t v109 = v111;
              }
              else
              {
                uint64_t v109 = 0;
                uint64_t v110 = &byte_1CFBCE98E;
              }
              LOWORD(v220) = 773;
              uint64_t v216 = v110;
              uint64_t v217 = (uint64_t)v109;
              int v218 = ".frozen";
              uint64_t v112 = llvm::FreezeInst::FreezeInst((llvm::FreezeInst *)(v81 + 32), (llvm::Value *)v77, &v216, *v35);
              uint64_t v113 = *v35;
              int v114 = *((_DWORD *)*v35 + 5);
              if ((v114 & 0x40000000) != 0) {
                int v115 = (char *)*((void *)v113 - 1);
              }
              else {
                int v115 = (char *)v113 - 32 * (v114 & 0x7FFFFFF);
              }
              if (*(void *)v115)
              {
                **((void **)v115 + 2) = *((void *)v115 + 1);
                uint64_t v116 = *((void *)v115 + 1);
                if (v116) {
                  *(void *)(v116 + 16) = *((void *)v115 + 2);
                }
              }
              *(void *)int v115 = v112;
              uint64_t v119 = *((void *)v81 + 5);
              int v118 = (uint64_t *)(v81 + 40);
              uint64_t v117 = v119;
              *((void *)v115 + 1) = v119;
              if (v119) {
                *(void *)(v117 + 16) = v115 + 8;
              }
              *((void *)v115 + 2) = v118;
              *int v118 = (uint64_t)v115;
              int v120 = *((_DWORD *)v80 + 5);
              if ((v120 & 0x40000000) != 0) {
                uint64_t v121 = (char *)*((void *)v80 - 1);
              }
              else {
                uint64_t v121 = (char *)v80 - 32 * (v120 & 0x7FFFFFF);
              }
              if (*(void *)v121)
              {
                **((void **)v121 + 2) = *((void *)v121 + 1);
                uint64_t v122 = *((void *)v121 + 1);
                if (v122) {
                  *(void *)(v122 + 16) = *((void *)v121 + 2);
                }
              }
              *(void *)uint64_t v121 = v112;
              uint64_t v123 = *v118;
              *((void *)v121 + 1) = *v118;
              if (v123) {
                *(void *)(v123 + 16) = v121 + 8;
              }
              *((void *)v121 + 2) = v118;
              *int v118 = (uint64_t)v121;
            }
            if ((sub_1CC16A22C((uint64_t ***)v78, 0, (uint64_t)*v35, (uint64_t)v4, 0, 0) & 1) == 0)
            {
              uint64_t v124 = (char *)operator new(0x60uLL);
              *((_DWORD *)v124 + 13) = *((_DWORD *)v124 + 13) & 0x38000000 | 1;
              *(void *)uint64_t v124 = 0;
              *((void *)v124 + 1) = 0;
              *((void *)v124 + 2) = 0;
              *((void *)v124 + 3) = v124 + 32;
              if ((*((unsigned char *)v78 + 23) & 0x10) != 0)
              {
                uint64_t v125 = ***(void ***)v78;
                uint64_t v126 = *(void *)(v125 + 152);
                uint64_t v127 = *(unsigned int *)(v125 + 168);
                if (v127)
                {
                  LODWORD(v128) = (v127 - 1) & ((v78 >> 4) ^ (v78 >> 9));
                  uint64_t v129 = (llvm::Value **)(v126 + 16 * v128);
                  int v130 = *v129;
                  if (*v129 != v78)
                  {
                    int v131 = 1;
                    do
                    {
                      if (v130 == (llvm::Value *)-4096) {
                        goto LABEL_199;
                      }
                      int v132 = v128 + v131++;
                      uint64_t v128 = v132 & (v127 - 1);
                      int v130 = *(llvm::Value **)(v126 + 16 * v128);
                    }
                    while (v130 != v78);
                    uint64_t v129 = (llvm::Value **)(v126 + 16 * v128);
                  }
                }
                else
                {
LABEL_199:
                  uint64_t v129 = (llvm::Value **)(v126 + 16 * v127);
                }
                uint64_t v133 = v129[1];
                unsigned int v136 = *(void *)v133;
                int v135 = (char *)v133 + 16;
                uint64_t v134 = v136;
              }
              else
              {
                uint64_t v134 = 0;
                int v135 = &byte_1CFBCE98E;
              }
              LOWORD(v220) = 773;
              uint64_t v216 = v135;
              uint64_t v217 = v134;
              int v218 = ".frozen";
              uint64_t v137 = llvm::FreezeInst::FreezeInst((llvm::FreezeInst *)(v124 + 32), v78, &v216, *v35);
              int v138 = *v35;
              int v139 = *((_DWORD *)*v35 + 5);
              if ((v139 & 0x40000000) != 0) {
                int v140 = (char *)*((void *)v138 - 1);
              }
              else {
                int v140 = (char *)v138 - 32 * (v139 & 0x7FFFFFF);
              }
              if (*((void *)v140 + 4))
              {
                **((void **)v140 + 6) = *((void *)v140 + 5);
                uint64_t v141 = *((void *)v140 + 5);
                if (v141) {
                  *(void *)(v141 + 16) = *((void *)v140 + 6);
                }
              }
              *((void *)v140 + 4) = v137;
              uint64_t v144 = *((void *)v124 + 5);
              BOOL v143 = (uint64_t *)(v124 + 40);
              uint64_t v142 = v144;
              *((void *)v140 + 5) = v144;
              if (v144) {
                *(void *)(v142 + 16) = v140 + 40;
              }
              *((void *)v140 + 6) = v143;
              *BOOL v143 = (uint64_t)(v140 + 32);
              int v145 = *((_DWORD *)v79 + 5);
              if ((v145 & 0x40000000) != 0) {
                int v146 = (char *)*((void *)v79 - 1);
              }
              else {
                int v146 = (char *)v79 - 32 * (v145 & 0x7FFFFFF);
              }
              if (*((void *)v146 + 4))
              {
                **((void **)v146 + 6) = *((void *)v146 + 5);
                uint64_t v147 = *((void *)v146 + 5);
                if (v147) {
                  *(void *)(v147 + 16) = *((void *)v146 + 6);
                }
              }
              *((void *)v146 + 4) = v137;
              uint64_t v148 = *v143;
              *((void *)v146 + 5) = *v143;
              if (v148) {
                *(void *)(v148 + 16) = v146 + 40;
              }
              *((void *)v146 + 6) = v143;
              *BOOL v143 = (uint64_t)(v146 + 32);
            }
            int v149 = v35[1];
            if ((*((unsigned char *)v149 + 23) & 0x10) != 0)
            {
              uint64_t v150 = ***(void ***)v149;
              uint64_t v151 = *(void *)(v150 + 152);
              uint64_t v152 = *(unsigned int *)(v150 + 168);
              if (v152)
              {
                LODWORD(v153) = (v152 - 1) & ((v149 >> 4) ^ (v149 >> 9));
                uint64_t v154 = (const llvm::Instruction **)(v151 + 16 * v153);
                uint64_t v155 = *v154;
                if (*v154 != v149)
                {
                  int v156 = 1;
                  do
                  {
                    if (v155 == (const llvm::Instruction *)-4096) {
                      goto LABEL_223;
                    }
                    int v157 = v153 + v156++;
                    uint64_t v153 = v157 & (v152 - 1);
                    uint64_t v155 = *(const llvm::Instruction **)(v151 + 16 * v153);
                  }
                  while (v155 != v149);
                  uint64_t v154 = (const llvm::Instruction **)(v151 + 16 * v153);
                }
              }
              else
              {
LABEL_223:
                uint64_t v154 = (const llvm::Instruction **)(v151 + 16 * v152);
              }
              uint64_t v158 = v154[1];
              unsigned int v161 = *(void *)v158;
              unsigned int v160 = (char *)v158 + 16;
              int v159 = v161;
            }
            else
            {
              int v159 = 0;
              unsigned int v160 = &byte_1CFBCE98E;
            }
            LOWORD(v220) = 773;
            uint64_t v216 = v160;
            uint64_t v217 = v159;
            int v218 = ".decomposed";
            llvm::Value::setNameImpl(v80, &v216);
            if (v80 && !*((unsigned char *)v80 + 16))
            {
              if ((*((unsigned char *)v80 + 23) & 0x10) == 0) {
                goto LABEL_312;
              }
              uint64_t v187 = ***(void ***)v80;
              uint64_t v188 = *(void *)(v187 + 152);
              uint64_t v189 = *(unsigned int *)(v187 + 168);
              if (v189)
              {
                LODWORD(v190) = (v189 - 1) & ((v80 >> 4) ^ (v80 >> 9));
                int v191 = (llvm::Value **)(v188 + 16 * v190);
                unsigned int v192 = *v191;
                if (*v191 != v80)
                {
                  int v193 = 1;
                  do
                  {
                    if (v192 == (llvm::Value *)-4096) {
                      goto LABEL_304;
                    }
                    int v194 = v190 + v193++;
                    uint64_t v190 = v194 & (v189 - 1);
                    unsigned int v192 = *(llvm::Value **)(v188 + 16 * v190);
                  }
                  while (v192 != v80);
                  int v191 = (llvm::Value **)(v188 + 16 * v190);
                }
              }
              else
              {
LABEL_304:
                int v191 = (llvm::Value **)(v188 + 16 * v189);
              }
              uint64_t v201 = v191[1];
              unint64_t v204 = *(void *)v201;
              int v202 = (char *)v201 + 16;
              unint64_t v203 = v204;
              if (v204 >= 5
                && (*(_DWORD *)v202 == *(_DWORD *)"llvm." ? (BOOL v205 = v202[4] == aLlvm_1[4]) : (BOOL v205 = 0), v205))
              {
                *((_DWORD *)v80 + 8) |= 0x2000u;
                int v206 = llvm::Function::lookupIntrinsicID(v202, v203);
              }
              else
              {
LABEL_312:
                int v206 = 0;
                *((_DWORD *)v80 + 8) &= ~0x2000u;
              }
              *((_DWORD *)v80 + 9) = v206;
            }
            uint64_t v162 = v35[1];
            v35[1] = v80;
            llvm::Value::doRAUW(v162, v80, (llvm::Value *)1);
            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
          }
          goto LABEL_228;
        }
        uint64_t v184 = (void *)*v94;
        if ((void *)*v94 == v94)
        {
          int v186 = 0;
        }
        else
        {
          if (v184) {
            uint64_t v185 = (unsigned __int8 *)(v184 - 3);
          }
          else {
            uint64_t v185 = 0;
          }
          if (v185[16] - 29 >= 0xB) {
            int v186 = 0;
          }
          else {
            int v186 = (llvm::Instruction *)v185;
          }
        }
        __n128 v4 = a3;
        llvm::Instruction::moveBefore(v35[1], v186);
        goto LABEL_108;
      }
LABEL_228:
      v35 += 2;
      if (v35 == v37)
      {
        unsigned int v35 = (const llvm::Instruction **)v226;
        goto LABEL_323;
      }
    }
    if (llvm::DominatorTree::dominates(v4, v62, v39))
    {
      char v65 = 1;
      goto LABEL_102;
    }
    if (llvm::DominatorTree::dominates(v4, v35[1], *v35))
    {
      char v65 = 0;
      goto LABEL_102;
    }
    goto LABEL_109;
  }
  char v36 = 0;
LABEL_323:
  if (v35 != (const llvm::Instruction **)&v227) {
    free(v35);
  }
  return v36 & 1;
}

void sub_1CCD480F4()
{
}

void sub_1CCD48134(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD4816C(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

uint64_t sub_1CCD48224(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::TargetTransformInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::TargetTransformInfoWrapperPass::ID);
  TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v9, (const Function *)a2);
  uint64_t v11 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v12 = *v11;
  uint64_t v13 = v11[1];
  if (v12 == v13)
  {
LABEL_11:
    uint64_t v14 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v12 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v12 += 16;
      if (v12 == v13) {
        goto LABEL_11;
      }
    }
    uint64_t v14 = *(void *)(v12 + 8);
  }
  uint64_t v15 = (llvm::DominatorTree *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::DominatorTreeWrapperPass::ID)+ 32);

  return sub_1CCD46F60((uint64_t)a2, TTI, v15);
}

uint64_t sub_1CCD48364(uint64_t a1, int a2, unsigned __int8 *a3, void *a4)
{
  if (!a2)
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
    goto LABEL_23;
  }
  __n128 v4 = 0;
  uint64_t v5 = *((void *)a3 + 1);
  uint64_t v6 = *((void *)a3 + 2);
  int v7 = *a3;
  int v8 = v6 ^ v5 ^ v7;
  for (int i = 1; ; ++i)
  {
    uint64_t v10 = v8 & (a2 - 1);
    uint64_t v11 = (unsigned __int8 *)(a1 + 32 * v10);
    uint64_t v12 = *((void *)v11 + 1);
    if (v7 == *v11 && v5 == v12)
    {
      uint64_t v12 = *((void *)a3 + 1);
      if (v6 == *((void *)v11 + 2))
      {
        uint64_t result = 1;
        goto LABEL_23;
      }
    }
    if (!*v11) {
      break;
    }
    if (!v12)
    {
      BOOL v14 = *((void *)v11 + 2) == 0;
      goto LABEL_14;
    }
LABEL_13:
    BOOL v14 = 0;
LABEL_14:
    if (v14 && v4 == 0) {
      __n128 v4 = (unsigned __int8 *)(a1 + 32 * v10);
    }
    int v8 = v10 + i;
  }
  if (v12 || *((void *)v11 + 2)) {
    goto LABEL_13;
  }
  uint64_t result = 0;
  if (v4) {
    uint64_t v11 = v4;
  }
LABEL_23:
  *a4 = v11;
  return result;
}

uint64_t sub_1CCD48420(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)result;
    uint64_t v8 = *(void *)result + 32 * v6;
    do
    {
      *(unsigned char *)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
      *(void *)(v7 + 16) = 0;
      v7 += 32;
    }
    while (v7 != v8);
  }
  while (a2 != a3)
  {
    if (*(void *)(a2 + 8) || *(void *)(a2 + 16))
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CCD48364(*(void *)v5, *(_DWORD *)(v5 + 16), (unsigned __int8 *)a2, &v10);
      uint64_t v9 = v10;
      *uint64_t v10 = *(unsigned char *)a2;
      v9[1] = *(void *)(a2 + 8);
      _OWORD v9[2] = *(void *)(a2 + 16);
      v9[3] = *(void *)(a2 + 24);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

uint64_t sub_1CCD484EC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)result;
    uint64_t v8 = *(void *)result + 32 * v6;
    do
    {
      *(unsigned char *)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
      *(void *)(v7 + 16) = 0;
      v7 += 32;
    }
    while (v7 != v8);
  }
  while (a2 != a3)
  {
    if (*(void *)(a2 + 8) || *(void *)(a2 + 16))
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CCD48364(*(void *)v5, *(_DWORD *)(v5 + 16), (unsigned __int8 *)a2, &v10);
      uint64_t v9 = v10;
      *uint64_t v10 = *(unsigned char *)a2;
      *((void *)v9 + 1) = *(void *)(a2 + 8);
      *((void *)v9 + 2) = *(void *)(a2 + 16);
      *((_DWORD *)v9 + 6) = *(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

uint64_t sub_1CCD485B8(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  if (a2 && v3 >= 0x1C)
  {
    if (v3 - 47 <= 1
      && ((int v4 = *(_DWORD *)(a2 + 20), (v4 & 0x40000000) != 0)
        ? (uint64_t v5 = *(void **)(a2 - 8))
        : (uint64_t v5 = (void *)(a2 - 32 * (v4 & 0x7FFFFFF))),
          *(void *)a1 == *v5 && (uint64_t v8 = v5[4]) != 0))
    {
      **(void **)(a1 + 8) = v8;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (v3 == 5)
    {
      if (*(unsigned __int16 *)(a2 + 18) - 19 <= 1
        && (uint64_t v6 = (void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)), *(void *)a1 == *v6))
      {
        uint64_t v2 = v6[4];
        if (v2)
        {
          **(void **)(a1 + 8) = v2;
          LOBYTE(v2) = 1;
        }
      }
      else
      {
        LOBYTE(v2) = 0;
      }
    }
    return (v3 == 5) & v2;
  }
}

uint64_t sub_1CCD4867C()
{
  uint64_t result = sub_1CBF64200((llvm::DebugCounter *)"div-rem-pairs-transform", 0x17uLL, "Controls transformations in div-rem-pairs pass", 0x2EuLL);
  dword_1EBCF17D0 = result;
  return result;
}

void llvm::EarlyCSEPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void sub_1CCD48988()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  long long v1 = 0u;
  long long v2 = 0u;
  *(_OWORD *)long long __p = 0u;
  operator new();
}

uint64_t sub_1CCD4A884(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 504), 8);
  *(void *)(a1 + 400) = 0;
  uint64_t v2 = *(unsigned int *)(a1 + 432);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 424);
    uint64_t v4 = 8 * v2;
    do
    {
      uint64_t v5 = *v3++;
      MEMORY[0x1D25D9CD0](v5, 8);
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v6 = *(uint64_t **)(a1 + 472);
  uint64_t v7 = *(unsigned int *)(a1 + 480);
  if (v7)
  {
    uint64_t v27 = 16 * v7;
    do
    {
      uint64_t v28 = *v6;
      v6 += 2;
      MEMORY[0x1D25D9CD0](v28, 8);
      v27 -= 16;
    }
    while (v27);
    uint64_t v6 = *(uint64_t **)(a1 + 472);
  }
  if (v6 != (uint64_t *)(a1 + 488)) {
    free(v6);
  }
  uint64_t v8 = *(void **)(a1 + 424);
  if (v8 != (void *)(a1 + 440)) {
    free(v8);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 368), 8);
  *(void *)(a1 + 264) = 0;
  uint64_t v9 = *(unsigned int *)(a1 + 296);
  if (v9)
  {
    uint64_t v10 = *(uint64_t **)(a1 + 288);
    uint64_t v11 = 8 * v9;
    do
    {
      uint64_t v12 = *v10++;
      MEMORY[0x1D25D9CD0](v12, 8);
      v11 -= 8;
    }
    while (v11);
  }
  uint64_t v13 = *(uint64_t **)(a1 + 336);
  uint64_t v14 = *(unsigned int *)(a1 + 344);
  if (v14)
  {
    uint64_t v29 = 16 * v14;
    do
    {
      uint64_t v30 = *v13;
      v13 += 2;
      MEMORY[0x1D25D9CD0](v30, 8);
      v29 -= 16;
    }
    while (v29);
    uint64_t v13 = *(uint64_t **)(a1 + 336);
  }
  if (v13 != (uint64_t *)(a1 + 352)) {
    free(v13);
  }
  uint64_t v15 = *(void **)(a1 + 288);
  if (v15 != (void *)(a1 + 304)) {
    free(v15);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 232), 8);
  *(void *)(a1 + 128) = 0;
  uint64_t v16 = *(unsigned int *)(a1 + 160);
  if (v16)
  {
    uint64_t v17 = *(uint64_t **)(a1 + 152);
    uint64_t v18 = 8 * v16;
    do
    {
      uint64_t v19 = *v17++;
      MEMORY[0x1D25D9CD0](v19, 8);
      v18 -= 8;
    }
    while (v18);
  }
  uint64_t v20 = *(uint64_t **)(a1 + 200);
  uint64_t v21 = *(unsigned int *)(a1 + 208);
  if (v21)
  {
    uint64_t v31 = 16 * v21;
    do
    {
      uint64_t v32 = *v20;
      v20 += 2;
      MEMORY[0x1D25D9CD0](v32, 8);
      v31 -= 16;
    }
    while (v31);
    uint64_t v20 = *(uint64_t **)(a1 + 200);
  }
  if (v20 != (uint64_t *)(a1 + 216)) {
    free(v20);
  }
  uint64_t v22 = *(void **)(a1 + 152);
  if (v22 != (void *)(a1 + 168)) {
    free(v22);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 96), 8);
  uint64_t v23 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v23)
  {
    sub_1CD3C5048(v23 + 584, *(void **)(v23 + 592));
    unsigned int v24 = *(void **)(v23 + 504);
    if (v24 != (void *)(v23 + 520)) {
      free(v24);
    }
    int v25 = *(void **)(v23 + 416);
    if (v25 != *(void **)(v23 + 408)) {
      free(v25);
    }
    sub_1CC0BD0FC((char **)(v23 + 8));
    MEMORY[0x1D25D9CE0](v23, 0x10E0C40B8556DDDLL);
  }
  return a1;
}

void sub_1CCD4AAD0(uint64_t a1)
{
}

uint64_t sub_1CCD4AB84(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF17E9;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263DB58;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)qword_1EBCF17F8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD4ACE4;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(qword_1EBCF17F8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD4AC34(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF17E8;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263DBF8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF17F0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD4AAD0;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF17F0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCD4ACE4(llvm *a1)
{
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeMemorySSAWrapperPassPass(a1, v3);
  operator new();
}

void sub_1CCD4ADAC(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  uint64_t v5 = *(char **)(a1 + 16);
  uint64_t v6 = v5 - v4;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v5 - v4) << 6) - 1;
  }
  unint64_t v8 = *(void *)(a1 + 32);
  if (v7 == *(void *)(a1 + 40) + v8)
  {
    BOOL v9 = v8 >= 0x200;
    unint64_t v10 = v8 - 512;
    if (v9)
    {
      *(void *)(a1 + 32) = v10;
      uint64_t v13 = *(void *)v4;
      uint64_t v11 = v4 + 8;
      uint64_t v12 = v13;
      *(void *)(a1 + 8) = v11;
      if (v5 == *(char **)(a1 + 24))
      {
        uint64_t v14 = *(char **)a1;
        if ((unint64_t)v11 <= *(void *)a1)
        {
          if (v5 == v14) {
            unint64_t v34 = 1;
          }
          else {
            unint64_t v34 = (v5 - v14) >> 2;
          }
          if (v34 >> 61) {
            goto LABEL_96;
          }
          unsigned int v35 = (char *)operator new(8 * v34);
          char v36 = &v35[8 * (v34 >> 2)];
          uint64_t v38 = v5 - v11;
          BOOL v37 = v5 == v11;
          uint64_t v5 = v36;
          if (!v37)
          {
            uint64_t v5 = &v36[v38 & 0xFFFFFFFFFFFFFFF8];
            uint64_t v39 = 8 * (v38 >> 3);
            int v40 = &v35[8 * (v34 >> 2)];
            do
            {
              uint64_t v41 = *(void *)v11;
              v11 += 8;
              *(void *)int v40 = v41;
              v40 += 8;
              v39 -= 8;
            }
            while (v39);
          }
          *(void *)a1 = v35;
          *(void *)(a1 + 8) = v36;
          *(void *)(a1 + 16) = v5;
          *(void *)(a1 + 24) = &v35[8 * v34];
          if (v14)
          {
            operator delete(v14);
            uint64_t v5 = *(char **)(a1 + 16);
          }
        }
        else
        {
          uint64_t v15 = (uint64_t)&v11[-*(void *)a1] >> 3;
          if (v15 >= -1) {
            uint64_t v16 = v15 + 1;
          }
          else {
            uint64_t v16 = v15 + 2;
          }
          uint64_t v17 = -(v16 >> 1);
          uint64_t v18 = v16 >> 1;
          uint64_t v19 = &v11[-8 * v18];
          int64_t v20 = v5 - v11;
          if (v5 != v11)
          {
            memmove(&v11[-8 * v18], v11, v5 - v11);
            uint64_t v5 = *(char **)(a1 + 8);
          }
          uint64_t v21 = &v5[8 * v17];
          uint64_t v5 = &v19[v20];
          *(void *)(a1 + 8) = v21;
          *(void *)(a1 + 16) = &v19[v20];
        }
      }
      *(void *)uint64_t v5 = v12;
      goto LABEL_37;
    }
    uint64_t v22 = v6 >> 3;
    uint64_t v23 = *(char **)(a1 + 24);
    unsigned int v24 = *(char **)a1;
    uint64_t v25 = (uint64_t)&v23[-*(void *)a1];
    if (v6 >> 3 < (unint64_t)(v25 >> 3))
    {
      uint64_t v26 = operator new(0x1000uLL);
      uint64_t v27 = v26;
      if (v23 != v5)
      {
        *(void *)uint64_t v5 = v26;
LABEL_37:
        *(void *)(a1 + 16) += 8;
        goto LABEL_38;
      }
      if (v4 == v24)
      {
        if (v5 == v4) {
          unint64_t v61 = 1;
        }
        else {
          unint64_t v61 = v25 >> 2;
        }
        if (v61 >> 61) {
          goto LABEL_96;
        }
        uint64_t v62 = (char *)operator new(8 * v61);
        int v43 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
        int v63 = v43;
        if (v5 != v4)
        {
          uint64_t v64 = 8 * v22;
          char v65 = &v62[(2 * v61 + 6) & 0xFFFFFFFFFFFFFFF8];
          int v66 = v4;
          int v63 = &v43[8 * v22];
          do
          {
            uint64_t v67 = *(void *)v66;
            v66 += 8;
            *(void *)char v65 = v67;
            v65 += 8;
            v64 -= 8;
          }
          while (v64);
        }
        *(void *)a1 = v62;
        *(void *)(a1 + 8) = v43;
        *(void *)(a1 + 16) = v63;
        *(void *)(a1 + 24) = &v62[8 * v61];
        if (v4)
        {
          operator delete(v4);
          int v43 = *(char **)(a1 + 8);
        }
      }
      else
      {
        int v43 = v4;
      }
      *((void *)v43 - 1) = v27;
      uint64_t v68 = *(char **)(a1 + 8);
      int v69 = *(char **)(a1 + 16);
      *(void *)(a1 + 8) = v68 - 8;
      uint64_t v70 = *((void *)v68 - 1);
      *(void *)(a1 + 8) = v68;
      if (v69 != *(char **)(a1 + 24))
      {
LABEL_95:
        *(void *)int v69 = v70;
        goto LABEL_37;
      }
      uint64_t v71 = *(char **)a1;
      if ((unint64_t)v68 > *(void *)a1)
      {
        uint64_t v72 = (uint64_t)&v68[-*(void *)a1] >> 3;
        if (v72 >= -1) {
          uint64_t v73 = v72 + 1;
        }
        else {
          uint64_t v73 = v72 + 2;
        }
        uint64_t v74 = -(v73 >> 1);
        uint64_t v75 = v73 >> 1;
        uint64_t v76 = &v68[-8 * v75];
        size_t v77 = v69 - v68;
        if (v77)
        {
          memmove(&v68[-8 * v75], v68, v77);
          uint64_t v68 = *(char **)(a1 + 8);
        }
        int v69 = &v76[v77];
        *(void *)(a1 + 8) = &v68[8 * v74];
        *(void *)(a1 + 16) = v69;
        goto LABEL_95;
      }
      if (v69 == v71) {
        unint64_t v78 = 1;
      }
      else {
        unint64_t v78 = (v69 - v71) >> 2;
      }
      if (!(v78 >> 61))
      {
        uint64_t v79 = (char *)operator new(8 * v78);
        int v80 = &v79[8 * (v78 >> 2)];
        uint64_t v81 = v69 - v68;
        BOOL v37 = v69 == v68;
        int v69 = v80;
        if (!v37)
        {
          int v69 = &v80[v81 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v82 = 8 * (v81 >> 3);
          uint64_t v83 = &v79[8 * (v78 >> 2)];
          do
          {
            uint64_t v84 = *(void *)v68;
            v68 += 8;
            *(void *)uint64_t v83 = v84;
            v83 += 8;
            v82 -= 8;
          }
          while (v82);
        }
        *(void *)a1 = v79;
        *(void *)(a1 + 8) = v80;
        *(void *)(a1 + 16) = v69;
        *(void *)(a1 + 24) = &v79[8 * v78];
        if (v71)
        {
          operator delete(v71);
          int v69 = *(char **)(a1 + 16);
        }
        goto LABEL_95;
      }
LABEL_96:
      sub_1CB833614();
    }
    if (v23 == v24) {
      unint64_t v28 = 1;
    }
    else {
      unint64_t v28 = v25 >> 2;
    }
    if (v28 >> 61) {
      goto LABEL_96;
    }
    uint64_t v29 = (char *)operator new(8 * v28);
    uint64_t v30 = &v29[8 * v22];
    uint64_t v31 = &v29[8 * v28];
    uint64_t v32 = operator new(0x1000uLL);
    if (v22 == v28)
    {
      if (v6 < 1)
      {
        if (v5 == v4) {
          unint64_t v44 = 1;
        }
        else {
          unint64_t v44 = v6 >> 2;
        }
        if (v44 >> 61) {
          goto LABEL_96;
        }
        char v45 = v32;
        uint64_t v30 = (char *)operator new(8 * v44);
        uint64_t v31 = &v30[8 * v44];
        operator delete(v29);
        uint64_t v4 = *(char **)(a1 + 8);
        uint64_t v5 = *(char **)(a1 + 16);
        uint64_t v29 = v30;
        uint64_t v32 = v45;
      }
      else
      {
        unint64_t v33 = v22 + 2;
        if (v22 >= -1) {
          unint64_t v33 = v22 + 1;
        }
        v30 -= 8 * (v33 >> 1);
      }
    }
    *(void *)uint64_t v30 = v32;
    int v46 = v30 + 8;
    if (v5 != v4)
    {
      while (1)
      {
        if (v30 == v29)
        {
          if (v46 >= v31)
          {
            if (v31 == v30) {
              unint64_t v51 = 1;
            }
            else {
              unint64_t v51 = (v31 - v30) >> 2;
            }
            if (v51 >> 61) {
              goto LABEL_96;
            }
            uint64_t v52 = (char *)operator new(8 * v51);
            uint64_t v29 = v52;
            uint64_t v47 = &v52[(2 * v51 + 6) & 0xFFFFFFFFFFFFFFF8];
            uint64_t v48 = v47;
            uint64_t v53 = v46 - v30;
            if (v46 != v30)
            {
              uint64_t v48 = &v47[v53 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v54 = 8 * (v53 >> 3);
              int v55 = &v52[(2 * v51 + 6) & 0xFFFFFFFFFFFFFFF8];
              int v56 = v30;
              do
              {
                uint64_t v57 = *(void *)v56;
                v56 += 8;
                *(void *)int v55 = v57;
                v55 += 8;
                v54 -= 8;
              }
              while (v54);
            }
            uint64_t v31 = &v52[8 * v51];
            operator delete(v30);
          }
          else
          {
            uint64_t v49 = (v31 - v46) >> 3;
            if (v49 >= -1) {
              unint64_t v50 = v49 + 1;
            }
            else {
              unint64_t v50 = v49 + 2;
            }
            uint64_t v48 = &v46[8 * (v50 >> 1)];
            uint64_t v47 = &v30[8 * (v50 >> 1)];
            if (v46 == v30)
            {
              uint64_t v29 = v46;
            }
            else
            {
              memmove(&v30[8 * (v50 >> 1)], v30, v46 - v30);
              uint64_t v29 = v30;
            }
          }
        }
        else
        {
          uint64_t v47 = v30;
          uint64_t v48 = v46;
        }
        uint64_t v58 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v47 - 1) = v58;
        uint64_t v59 = v47 - 8;
        int v46 = v48;
        uint64_t v30 = v59;
        if (v5 == *(char **)(a1 + 8)) {
          goto LABEL_67;
        }
      }
    }
    uint64_t v59 = v30;
    uint64_t v48 = v30 + 8;
LABEL_67:
    int v60 = *(char **)a1;
    *(void *)a1 = v29;
    *(void *)(a1 + 8) = v59;
    *(void *)(a1 + 16) = v48;
    *(void *)(a1 + 24) = v31;
    if (v60) {
      operator delete(v60);
    }
  }
LABEL_38:
  uint64_t v42 = *(void *)(a1 + 40);
  *(void *)(*(void *)(*(void *)(a1 + 8)
                        + (((unint64_t)(*(void *)(a1 + 32) + v42) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*(void *)(a1 + 32) + v42) & 0x1FF)) = *a2;
  *(void *)(a1 + 40) = v42 + 1;
}

BOOL sub_1CCD4B29C(llvm::ConstrainedFPIntrinsic *this)
{
  unsigned int v1 = *((unsigned __int8 *)this + 16);
  if (!this || *((unsigned char *)this + 16) != 84)
  {
    uint64_t v10 = *(void *)&vdup_n_s16(v1) & 0xFF00FF00FF00FFLL;
    BOOL v11 = (v1 - 89) < 5u;
    char v12 = vmaxv_u16((uint16x4_t)vceq_s16((int16x4_t)v10, (int16x4_t)0x5F0055003E0028)) | (*((unsigned __int8 *)this + 16)
                                                                                          - 66 < 0xD);
    BOOL v14 = *((unsigned __int8 *)this + 16) - 41 < 0x12
       || *((unsigned __int8 *)this + 16) - 81 < 2;
    char v9 = v12 | (v14 || v11);
    return v9 & 1;
  }
  uint64_t v3 = *((void *)this - 4);
  if (!v3
    || *(unsigned char *)(v3 + 16)
    || *(void *)(v3 + 24) != *((void *)this + 9)
    || ((unsigned int v4 = *(_DWORD *)(v3 + 36) - 83, v5 = v4 > 0x23, v6 = (1 << v4) & 0x90000364FLL, !v5)
      ? (BOOL v7 = v6 == 0)
      : (BOOL v7 = 1),
        v7))
  {
    uint64_t v8 = *((void *)this + 8);
    if ((v8 && (*(unsigned char *)(v8 + 17) & 0x10) != 0
       || ((__int32 v18 = 7, !sub_1CC5CB59C((uint64_t)this, &v18, 1uLL))
        || (uint64_t v17 = *((void *)this - 4)) != 0
        && !*(unsigned char *)(v17 + 16)
        && *(void *)(v17 + 24) == *((void *)this + 9)
        && *(_DWORD *)(v17 + 36) == 7)
       && llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 44))
      && *(unsigned char *)(*(void *)this + 8) != 7
      && ((uint64_t v16 = *((void *)this + 8)) == 0 || (*(unsigned char *)(v16 + 12) & 0x40) == 0))
    {
      char v9 = llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 6) ^ 1;
    }
    else
    {
      char v9 = 0;
    }
    return v9 & 1;
  }

  return llvm::ConstrainedFPIntrinsic::isDefaultFPEnvironment(this);
}

void sub_1CCD4B44C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 80))
  {
    uint64_t v2 = *(int32x2_t ***)(a1 + 88);
    __int32 v3 = (*v2)[5].i32[0];
    if (v3)
    {
      int32x2_t v4 = (*v2)[3];
      __int32 v5 = v3 - 1;
      uint64_t v6 = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v7 = *(void *)(*(void *)&v4 + 16 * v6);
      if (v7 == a2)
      {
LABEL_7:
        uint64_t v10 = *(llvm::MemoryAccess **)(*(void *)&v4 + 16 * v6 + 8);
        if (v10) {
          llvm::MemorySSAUpdater::removeMemoryAccess(v2, v10, (llvm::Value *)1);
        }
      }
      else
      {
        int v8 = 1;
        while (v7 != -4096)
        {
          int v9 = v6 + v8++;
          uint64_t v6 = v9 & v5;
          uint64_t v7 = *(void *)(*(void *)&v4 + 16 * v6);
          if (v7 == a2) {
            goto LABEL_7;
          }
        }
      }
    }
  }
}

void *sub_1CCD4B4C8(uint64_t a1, llvm::Instruction **a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t result = sub_1CCD4BEE8(a1, a2);
  int v8 = result;
  uint64_t v9 = *(void *)(v6 + 16);
  uint64_t v10 = *result;
  BOOL v11 = *(void **)(a1 + 32);
  if (v11)
  {
    *(void *)(a1 + 32) = *v11;
  }
  else
  {
    *(void *)(a1 + 120) += 32;
    uint64_t v12 = *(void *)(a1 + 40);
    if (((v12 + 7) & 0xFFFFFFFFFFFFFFF8) - v12 + 32 > *(void *)(a1 + 48) - v12)
    {
      unsigned int v13 = *(_DWORD *)(a1 + 64) >> 7;
      if (v13 >= 0x1E) {
        LOBYTE(v13) = 30;
      }
      uint64_t v14 = 4096 << v13;
      uint64_t result = operator new(4096 << v13, (std::align_val_t)8uLL);
      BOOL v11 = result;
      unsigned int v15 = *(_DWORD *)(a1 + 64);
      if (v15 >= *(_DWORD *)(a1 + 68)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 56) + 8 * v15) = result;
      ++*(_DWORD *)(a1 + 64);
      *(void *)(a1 + 40) = result + 4;
      *(void *)(a1 + 48) = (char *)result + v14;
    }
    else
    {
      BOOL v11 = (void *)((v12 + 7) & 0xFFFFFFFFFFFFFFF8);
      *(void *)(a1 + 40) = v11 + 4;
    }
  }
  v11[2] = *a2;
  v11[3] = *a3;
  void *v11 = v9;
  v11[1] = v10;
  void *v8 = v11;
  *(void *)(v6 + 16) = v11;
  return result;
}

int *sub_1CCD4B604(int *a1, uint64_t a2, void *a3)
{
  *((void *)a1 + 1) = 0;
  *a1 = 0;
  *((void *)a1 + 2) = 0;
  *((unsigned char *)a1 + 24) = 0;
  *((void *)a1 + 4) = a2;
  if (*(unsigned char *)(a2 + 16) == 84)
  {
    uint64_t v5 = *(void *)(a2 - 32);
    if (v5)
    {
      if (!*(unsigned char *)(v5 + 16) && *(void *)(v5 + 24) == *(void *)(a2 + 72) && (*(unsigned char *)(v5 + 33) & 0x20) != 0)
      {
        *a1 = *(_DWORD *)(v5 + 36);
        if (((*(uint64_t (**)(void, uint64_t, int *))(*(void *)*a3 + 992))(*a3, a2, a1 + 2) & 1) == 0)
        {
          int v6 = *a1;
          if (((*a1 - 185) & 0xFFFFFFFD) == 0)
          {
            if (v6 == 187)
            {
              int v10 = *(_DWORD *)(a2 + 20);
              if ((v10 & 0x40000000) != 0) {
                uint64_t v11 = *(void *)(a2 - 8);
              }
              else {
                uint64_t v11 = a2 - 32 * (v10 & 0x7FFFFFF);
              }
              char v12 = 0;
              uint64_t v9 = (void *)(v11 + 32);
              char v8 = 1;
              goto LABEL_18;
            }
            if (v6 == 185)
            {
              int v7 = *(_DWORD *)(a2 + 20);
              char v8 = 0;
              if ((v7 & 0x40000000) != 0) {
                uint64_t v9 = *(void **)(a2 - 8);
              }
              else {
                uint64_t v9 = (void *)(a2 - 32 * (v7 & 0x7FFFFFF));
              }
              char v12 = 1;
LABEL_18:
              *((void *)a1 + 1) = *v9;
              *((_WORD *)a1 + 10) = 185;
              *((unsigned char *)a1 + 22) = v12;
              *((unsigned char *)a1 + 23) = v8;
              *((unsigned char *)a1 + 24) = 0;
            }
          }
        }
      }
    }
  }
  return a1;
}

BOOL sub_1CCD4B744(uint64_t a1)
{
  if (*(_DWORD *)a1)
  {
    if (*(_DWORD *)(a1 + 16) > 1u) {
      return 0;
    }
    return *(unsigned char *)(a1 + 24) == 0;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 16);
  if (v2 && v3 == 60 || v2 && v3 == 61) {
    return (*(_WORD *)(v2 + 18) & 0x301) == 0;
  }
  if (v3 == 60 || v3 == 61) {
    BOOL v5 = (*(_WORD *)(v2 + 18) & 0x380) != 0;
  }
  else {
    BOOL v5 = (v3 - 63) <= 2;
  }
  return !v5;
}

uint64_t sub_1CCD4B7D8(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a3)
  {
    LODWORD(v4) = ((a4 >> 4) ^ (a4 >> 9)) & (a3 - 1);
    BOOL v5 = (uint64_t *)(a2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a4) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (a3 - 1);
      uint64_t v6 = *(void *)(a2 + 16 * v4);
      if (v6 == a4)
      {
        BOOL v5 = (uint64_t *)(a2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  BOOL v5 = (uint64_t *)(a2 + 16 * a3);
LABEL_8:
  if (v5 == (uint64_t *)(a2 + 16 * a3))
  {
    *(void *)uint64_t result = 0;
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(_DWORD *)(result + 12) = -1;
  }
  else
  {
    uint64_t v9 = v5[1];
    *(_OWORD *)uint64_t result = *(_OWORD *)(v9 + 24);
    *(void *)(result + 16) = *(void *)(v9 + 40);
  }
  return result;
}

uint64_t sub_1CCD4B868(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)a2;
  if (!*(void *)a2) {
    return 0;
  }
  int v7 = *(unsigned __int16 *)(a3 + 20);
  if (!*(_DWORD *)a3) {
    int v7 = -1;
  }
  if (*(_DWORD *)(a2 + 12) != v7) {
    return 0;
  }
  if (*(_DWORD *)a3)
  {
    if (*(unsigned char *)(a3 + 24)
      || !sub_1CCD4B744(a3)
      || *(unsigned char *)(a3 + 22) && !*(unsigned char *)(a2 + 16) && *(_DWORD *)(a3 + 16))
    {
      return 0;
    }
    int v10 = (uint64_t *)(a3 + 32);
    if (*(unsigned char *)(a3 + 22)) {
      uint64_t v11 = v4;
    }
    else {
      uint64_t v11 = *(void *)(a3 + 32);
    }
    if (*(unsigned char *)(a3 + 22)) {
      uint64_t v12 = *(void *)(a3 + 32);
    }
    else {
      uint64_t v12 = v4;
    }
    int v13 = *(unsigned __int8 *)(a3 + 23);
    if (!*(unsigned char *)(a3 + 23))
    {
      uint64_t v14 = 0;
      goto LABEL_39;
    }
LABEL_35:
    uint64_t v14 = sub_1CCD4DA88(a1, v11, *(void *)v12);
    if (*(_DWORD *)a3) {
      int v13 = *(unsigned char *)(a3 + 23) != 0;
    }
    else {
      int v13 = *(unsigned __int8 *)(*v10 + 16) == 61;
    }
    goto LABEL_39;
  }
  int v10 = (uint64_t *)(a3 + 32);
  uint64_t v12 = *(void *)(a3 + 32);
  int v15 = *(unsigned __int8 *)(v12 + 16);
  if (v12 && v15 == 60 || (uint64_t v14 = 0, v12) && v15 == 61)
  {
    __int16 v16 = *(_WORD *)(v12 + 18);
    if ((v16 & 1) != 0 || !sub_1CCD4B744(a3)) {
      return 0;
    }
    if (v15 != 60 || *(unsigned char *)(a2 + 16))
    {
      if (v15 == 60) {
        uint64_t v11 = v4;
      }
      else {
        uint64_t v11 = v12;
      }
      if (v15 != 60) {
        uint64_t v12 = v4;
      }
      if (v15 == 61) {
        goto LABEL_35;
      }
      uint64_t v14 = 0;
      int v13 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      if ((v16 & 0x380) != 0) {
        return v14;
      }
      int v13 = 0;
      uint64_t v11 = v4;
    }
LABEL_39:
    uint64_t v17 = *(void *)a2;
    if (v13 && v17 != v14) {
      return 0;
    }
    int v18 = sub_1CCD4DB40(v11);
    int v19 = sub_1CCD4DB40(v12);
    if (v18 != v19) {
      return 0;
    }
    int v20 = v18 & v19;
    uint64_t v21 = (uint64_t ***)*v10;
    if (v20 == 1 && !sub_1CCD4DB90(v17, *v10)) {
      return 0;
    }
    unsigned int v22 = *(_DWORD *)(a2 + 8);
    if (!v21 || *((unsigned char *)v21 + 16) != 60 || (*((unsigned char *)v21 + 23) & 0x20) == 0) {
      goto LABEL_61;
    }
    uint64_t v23 = ***v21;
    *(void *)&v44[0] = v21;
    int v24 = *(_DWORD *)(v23 + 2496);
    if (v24)
    {
      uint64_t v25 = *(void *)(v23 + 2480);
      int v26 = v24 - 1;
      unsigned int v27 = v26 & ((v21 >> 4) ^ (v21 >> 9));
      unint64_t v28 = (uint64_t ****)(v25 + 40 * v27);
      uint64_t v29 = *v28;
      if (*v28 == v21)
      {
LABEL_57:
        uint64_t v34 = *((unsigned int *)v28 + 4);
        if (v34)
        {
          unsigned int v35 = v28[1] + 1;
          uint64_t v36 = 16 * v34;
          while (*((_DWORD *)v35 - 2) != 6)
          {
            v35 += 2;
            v36 -= 16;
            if (!v36) {
              goto LABEL_61;
            }
          }
          if (*v35) {
            goto LABEL_69;
          }
        }
LABEL_61:
        llvm::MemoryLocation::getOrNone(v21, (uint64_t)v44);
        if (v45)
        {
          v43[0] = v44[0];
          v43[1] = v44[1];
          v43[2] = v44[2];
          if (sub_1CCD4D85C(*(void *)(a1 + 368), *(_DWORD *)(a1 + 384), (uint64_t)v43, &v46))
          {
            uint64_t v46 = 0;
            if (sub_1CCD4D85C(*(void *)(a1 + 368), *(_DWORD *)(a1 + 384), (uint64_t)v43, &v46))
            {
              uint64_t v37 = v46;
              uint64_t v38 = *(void *)(a1 + 368);
              unsigned int v39 = *(_DWORD *)(a1 + 384);
            }
            else
            {
              uint64_t v38 = *(void *)(a1 + 368);
              unsigned int v39 = *(_DWORD *)(a1 + 384);
              uint64_t v37 = v38 + 56 * v39;
            }
            if (v37 == v38 + 56 * v39 || *(_DWORD *)(*(void *)(v37 + 48) + 64) <= v22) {
              goto LABEL_69;
            }
          }
        }
        if (sub_1CCD4BD70(a1, *(_DWORD *)(a2 + 8), a4, *(void *)a2, *v10))
        {
LABEL_69:
          if (!v14) {
            return sub_1CCD4DA88(a1, v11, *(void *)v12);
          }
          return v14;
        }
        return 0;
      }
      uint64_t v30 = 0;
      int v31 = 1;
      while (v29 != (uint64_t ***)-4096)
      {
        if (v30) {
          BOOL v32 = 0;
        }
        else {
          BOOL v32 = v29 == (uint64_t ***)-8192;
        }
        if (v32) {
          uint64_t v30 = v28;
        }
        unsigned int v33 = v27 + v31++;
        unsigned int v27 = v33 & v26;
        unint64_t v28 = (uint64_t ****)(v25 + 40 * v27);
        uint64_t v29 = *v28;
        if (*v28 == v21) {
          goto LABEL_57;
        }
      }
      if (v30) {
        uint64_t v41 = v30;
      }
      else {
        uint64_t v41 = v28;
      }
    }
    else
    {
      uint64_t v41 = 0;
    }
    unint64_t v28 = (uint64_t ****)sub_1CC609054(v23 + 2480, (uint64_t)v44, (uint64_t *)v44, v41);
    uint64_t v42 = *(uint64_t ****)&v44[0];
    v28[3] = 0;
    v28[4] = 0;
    *unint64_t v28 = v42;
    v28[1] = (uint64_t ***)(v28 + 3);
    v28[2] = (uint64_t ***)0x100000000;
    goto LABEL_57;
  }
  return v14;
}

__n128 sub_1CCD4BC2C(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  uint64_t v6 = *(void *)(a1 + 24);
  int v7 = sub_1CC959744(a1, a2);
  uint64_t v8 = *(void *)(v6 + 16);
  uint64_t v9 = *v7;
  unint64_t v10 = *(void *)(a1 + 32);
  if (v10)
  {
    *(void *)(a1 + 32) = *(void *)v10;
  }
  else
  {
    *(void *)(a1 + 120) += 48;
    uint64_t v11 = *(void *)(a1 + 40);
    if (((v11 + 7) & 0xFFFFFFFFFFFFFFF8) - v11 + 48 > *(void *)(a1 + 48) - v11)
    {
      unsigned int v13 = *(_DWORD *)(a1 + 64) >> 7;
      if (v13 >= 0x1E) {
        LOBYTE(v13) = 30;
      }
      uint64_t v14 = 4096 << v13;
      unint64_t v10 = (unint64_t)operator new(4096 << v13, (std::align_val_t)8uLL);
      unsigned int v15 = *(_DWORD *)(a1 + 64);
      if (v15 >= *(_DWORD *)(a1 + 68)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 56) + 8 * v15) = v10;
      ++*(_DWORD *)(a1 + 64);
      *(void *)(a1 + 40) = v10 + 48;
      *(void *)(a1 + 48) = v10 + v14;
    }
    else
    {
      unint64_t v10 = (v11 + 7) & 0xFFFFFFFFFFFFFFF8;
      *(void *)(a1 + 40) = v10 + 48;
    }
  }
  *(void *)(v10 + 16) = *a2;
  __n128 result = *a3;
  *(void *)(v10 + 40) = a3[1].n128_u64[0];
  *(__n128 *)(v10 + 24) = result;
  *(void *)unint64_t v10 = v8;
  *(void *)(v10 + 8) = v9;
  *int v7 = v10;
  *(void *)(v6 + 16) = v10;
  return result;
}

uint64_t sub_1CCD4BD70(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a2 == a3) {
    return 1;
  }
  uint64_t result = *(void *)(a1 + 80);
  if (result)
  {
    int v7 = *(_DWORD *)(result + 40);
    if (v7)
    {
      uint64_t v9 = *(void *)(result + 24);
      unsigned int v10 = v7 - 1;
      LODWORD(v11) = v10 & ((a4 >> 4) ^ (a4 >> 9));
      uint64_t v12 = (uint64_t *)(v9 + 16 * v11);
      uint64_t v13 = *v12;
      if (*v12 != a4)
      {
        int v14 = 1;
        while (v13 != -4096)
        {
          int v15 = v11 + v14++;
          uint64_t v11 = v15 & v10;
          uint64_t v13 = *(void *)(v9 + 16 * v11);
          if (v13 == a4)
          {
            uint64_t v16 = *(void *)(v9 + 16 * v11 + 8);
            if (!v16) {
              return 1;
            }
            goto LABEL_13;
          }
        }
        return 1;
      }
      uint64_t v16 = v12[1];
      if (v16)
      {
LABEL_13:
        uint64_t v17 = v10 & ((a5 >> 4) ^ (a5 >> 9));
        uint64_t v18 = *(void *)(v9 + 16 * v17);
        if (v18 != a5)
        {
          int v19 = 1;
          while (v18 != -4096)
          {
            int v20 = v17 + v19++;
            uint64_t v17 = v20 & v10;
            uint64_t v18 = *(void *)(v9 + 16 * v17);
            if (v18 == a5) {
              goto LABEL_17;
            }
          }
          return 1;
        }
LABEL_17:
        uint64_t v21 = *(void *)(v9 + 16 * v17 + 8);
        if (v21)
        {
          if (*(_DWORD *)(a1 + 548) >= dword_1EBCF1880)
          {
            if (*(unsigned char *)(v21 + 16) == 25) {
              uint64_t v24 = v21;
            }
            else {
              uint64_t v24 = 0;
            }
            uint64_t v25 = (uint64_t *)(v21 - 64);
            if (v24) {
              uint64_t v25 = (uint64_t *)(v24 - 32);
            }
            uint64_t v23 = *v25;
          }
          else
          {
            uint64_t WalkerImpl = (void *)llvm::MemorySSA::getWalkerImpl((llvm::MemorySSA *)result);
            uint64_t v23 = sub_1CCD4E10C(WalkerImpl, a5);
            ++*(_DWORD *)(a1 + 548);
            uint64_t result = *(void *)(a1 + 80);
          }
          return llvm::MemorySSA::dominates((llvm::MemorySSA *)result, v23, v16);
        }
      }
    }
    return 1;
  }
  return result;
}

const llvm::Instruction **sub_1CCD4BEE8(uint64_t a1, llvm::Instruction **a2)
{
  uint64_t v9 = 0;
  char v4 = sub_1CCD4BFC4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v9);
  BOOL v5 = v9;
  if (v4) {
    return v5 + 1;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CCD4D714(a1, v7);
    uint64_t v9 = 0;
    sub_1CCD4BFC4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v9);
    BOOL v5 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*v5 != (const llvm::Instruction *)-4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *BOOL v5 = *a2;
  v5[1] = 0;
  return v5 + 1;
}

uint64_t sub_1CCD4BFC4(uint64_t a1, int a2, llvm::Instruction **a3, const llvm::Instruction ***a4)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    uint64_t v18 = 0;
    uint64_t result = 0;
    goto LABEL_136;
  }
  uint64_t v8 = (uint64_t)*a3;
  int v9 = *((unsigned __int8 *)*a3 + 16);
  if (*a3) {
    BOOL v10 = (v9 - 59) >= 0xFFFFFFEE;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    unint64_t v20 = *(void *)(v8 - 64);
    unint64_t v21 = *(void *)(v8 - 32);
    int isCommutative = llvm::Instruction::isCommutative(*a3);
    BOOL v23 = v20 > v21;
    if ((isCommutative & v23) != 0) {
      unint64_t v24 = v20;
    }
    else {
      unint64_t v24 = v21;
    }
    if ((isCommutative & v23) != 0) {
      unint64_t v20 = v21;
    }
    uint64_t v161 = 0;
    long long v159 = 0u;
    long long v160 = 0u;
    long long v157 = 0u;
    long long v158 = 0u;
    long long v156 = 0u;
    memset(__dst, 0, sizeof(__dst));
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCBE588))
    {
      unint64_t v110 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v110 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v110;
      __cxa_guard_release(&qword_1EBCBE588);
    }
    unint64_t v25 = qword_1EBCBE580;
    uint64_t v162 = qword_1EBCBE580;
    LODWORD(__dst[0]) = v9 - 28;
  }
  else
  {
    if (v8) {
      BOOL v11 = (v9 - 83) >= 0xFFFFFFFE;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11)
    {
      unint64_t v26 = *(void *)(v8 - 64);
      unint64_t v27 = *(void *)(v8 - 32);
      uint64_t v28 = *(_WORD *)(v8 + 18) & 0x3F;
      if (v27 >= v26 && (v26 >= v27 ? (BOOL v29 = dword_1CFB2CB44[v28] >= v28) : (BOOL v29 = 1), v29))
      {
        uint64_t v30 = *(void *)(v8 - 32);
        unint64_t v27 = v26;
      }
      else
      {
        LODWORD(v28) = dword_1CFB2CB44[v28];
        uint64_t v30 = *(void *)(v8 - 64);
      }
      unsigned int v31 = v9 - 28;
      uint64_t v161 = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      long long v156 = 0u;
      memset(__dst, 0, sizeof(__dst));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCBE588))
      {
        unint64_t v111 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v111 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v111;
        __cxa_guard_release(&qword_1EBCBE588);
      }
      uint64_t v162 = qword_1EBCBE580;
      *(void *)&__dst[0] = __PAIR64__(v28, v31);
      uint64_t BasePtr = 0;
      BOOL v32 = sub_1CC2E96A4(__dst, &BasePtr, (void *)__dst + 1, (unint64_t)&v158, v27);
      uint64_t v154 = BasePtr;
      uint64_t v33 = v30;
LABEL_37:
      uint64_t v34 = (char *)sub_1CC2E96A4(__dst, &v154, v32, (unint64_t)&v158, v33);
      int v15 = v34;
      uint64_t v35 = v154;
      if (!v154)
      {
        unint64_t v17 = v34 - (char *)__dst;
        goto LABEL_39;
      }
      if (v34 == (char *)__dst) {
        goto LABEL_252;
      }
LABEL_229:
      if (v15 != (char *)&v158)
      {
        if ((char *)__dst + 1 == v15)
        {
          char v120 = __dst[0];
          memmove(__dst, v15, (char *)&v158 - v15);
          *((unsigned char *)__dst + (char *)&v158 - v15) = v120;
        }
        else if (v15 + 1 == (char *)&v158)
        {
          char v121 = HIBYTE(v157);
          memmove((char *)__dst + 1, __dst, 0x3FuLL);
          LOBYTE(__dst[0]) = v121;
        }
        else
        {
          sub_1CBFFD29C(__dst, v15, &v158);
        }
      }
LABEL_252:
      *(void *)&long long v158 = 0xB492B66FBE98F273
                       * __ROR8__(*((void *)&v158 + 1) + v158 + *((void *)&v159 + 1) + *((void *)&__dst[0] + 1), 37);
      *((void *)&v158 + 1) = 0xB492B66FBE98F273 * __ROR8__(v160 + *((void *)&v158 + 1) + v157, 42);
      unint64_t v122 = *((void *)&v158 + 1) + *((void *)&v159 + 1) + *((void *)&v156 + 1);
      uint64_t v123 = *(void *)&__dst[0] - 0x4B6D499041670D8DLL * v160;
      uint64_t v124 = v123 + *((void *)&__dst[0] + 1) + *(void *)&__dst[1];
      uint64_t v125 = v161 ^ v158;
      uint64_t v126 = __ROR8__(v123 + *((void *)&v160 + 1) + *((void *)&__dst[1] + 1) + (v161 ^ v158), 21)
           + v123
           + __ROR8__(v124, 44);
      uint64_t v127 = __ROR8__(*((void *)&v160 + 1) + v159, 33);
      uint64_t v128 = v124 + *((void *)&__dst[1] + 1);
      uint64_t v129 = v156 + v161 - 0x4B6D499041670D8DLL * v127;
      uint64_t v130 = *((void *)&v156 + 1) + v157 + v129;
      uint64_t v131 = __ROR8__(v129 + *((void *)&v157 + 1) + *(void *)&__dst[1] + v122, 21) + v129 + __ROR8__(v130, 44);
      uint64_t v132 = v130 + *((void *)&v157 + 1);
      uint64_t v133 = v35 - (void)__dst;
      goto LABEL_253;
    }
    unsigned int v151 = 0;
    unint64_t v149 = 0;
    uint64_t v150 = 0;
    unint64_t v148 = 0;
    if (sub_1CCD4D3F0(v8, &v150, &v149, &v148, (int *)&v151))
    {
      if (v151 - 1 <= 3)
      {
        unint64_t v12 = v148;
        if (v149 > v148)
        {
          unint64_t v148 = v149;
          unint64_t v149 = v12;
        }
        int v13 = *(unsigned __int8 *)(v8 + 16) - 28;
        uint64_t v161 = 0;
        long long v159 = 0u;
        long long v160 = 0u;
        long long v157 = 0u;
        long long v158 = 0u;
        long long v156 = 0u;
        memset(__dst, 0, sizeof(__dst));
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EBCBE588))
        {
          unint64_t v112 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v112 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v112;
          __cxa_guard_release(&qword_1EBCBE588);
        }
        *(void *)&__dst[0] = __PAIR64__(v151, v13);
        uint64_t v162 = qword_1EBCBE580;
        *((void *)&__dst[0] + 1) = v149;
        uint64_t v154 = 0;
        int v14 = (long long *)sub_1CC2E96A4(__dst, &v154, &__dst[1], (unint64_t)&v158, v148);
        int v15 = (char *)v14;
        uint64_t v16 = v154;
        if (!v154)
        {
          unint64_t v17 = (char *)v14 - (char *)__dst;
LABEL_39:
          unint64_t v25 = v162;
          goto LABEL_40;
        }
        if (v14 != __dst && v14 != &v158)
        {
          if ((_OWORD *)((char *)__dst + 1) == v14)
          {
            char v137 = __dst[0];
            memmove(__dst, v14, (char *)&v158 - (char *)v14);
            *((unsigned char *)__dst + (char *)&v158 - v15) = v137;
          }
          else if ((long long *)((char *)v14 + 1) == &v158)
          {
            char v139 = HIBYTE(v157);
            memmove((char *)__dst + 1, __dst, 0x3FuLL);
            LOBYTE(__dst[0]) = v139;
          }
          else
          {
            sub_1CBFFD29C(__dst, v14, &v158);
          }
        }
        *(void *)&long long v158 = 0xB492B66FBE98F273
                         * __ROR8__(*((void *)&v158 + 1) + v158 + *((void *)&v159 + 1) + *((void *)&__dst[0] + 1), 37);
        *((void *)&v158 + 1) = 0xB492B66FBE98F273 * __ROR8__(v160 + *((void *)&v158 + 1) + v157, 42);
        unint64_t v122 = *((void *)&v158 + 1) + *((void *)&v159 + 1) + *((void *)&v156 + 1);
        uint64_t v140 = *(void *)&__dst[0] - 0x4B6D499041670D8DLL * v160;
        uint64_t v141 = v140 + *((void *)&__dst[0] + 1) + *(void *)&__dst[1];
        uint64_t v125 = v161 ^ v158;
        uint64_t v126 = __ROR8__(v140 + *((void *)&v160 + 1) + *((void *)&__dst[1] + 1) + (v161 ^ v158), 21)
             + v140
             + __ROR8__(v141, 44);
        uint64_t v127 = __ROR8__(*((void *)&v160 + 1) + v159, 33);
        uint64_t v128 = v141 + *((void *)&__dst[1] + 1);
        uint64_t v142 = v156 + v161 - 0x4B6D499041670D8DLL * v127;
        uint64_t v143 = *((void *)&v156 + 1) + v157 + v142;
        uint64_t v131 = __ROR8__(v142 + *((void *)&v157 + 1) + *(void *)&__dst[1] + v122, 21) + v142 + __ROR8__(v143, 44);
        uint64_t v132 = v143 + *((void *)&v157 + 1);
        uint64_t v133 = v16 - (void)__dst;
LABEL_253:
        unint64_t v134 = v125
             - 0x4B6D499041670D8DLL * (v122 ^ (v122 >> 47))
             - 0x622015F714C7D297
             * ((0x9DDFEA08EB382D69
               * (v132 ^ ((0x9DDFEA08EB382D69 * (v132 ^ v128)) >> 47) ^ (0x9DDFEA08EB382D69 * (v132 ^ v128)))) ^ ((0x9DDFEA08EB382D69 * (v132 ^ ((0x9DDFEA08EB382D69 * (v132 ^ v128)) >> 47) ^ (0x9DDFEA08EB382D69 * (v132 ^ v128)))) >> 47));
        unint64_t v135 = 0x9DDFEA08EB382D69
             * (v131 ^ ((0x9DDFEA08EB382D69 * (v131 ^ v126)) >> 47) ^ (0x9DDFEA08EB382D69 * (v131 ^ v126)));
        unint64_t v136 = 0xB492B66FBE98F273 * (v127 + ((unint64_t)&v15[v133] ^ ((unint64_t)&v15[v133] >> 47)))
             - 0x622015F714C7D297 * (v135 ^ (v135 >> 47));
        unint64_t v36 = 0x9DDFEA08EB382D69
            * ((0x9DDFEA08EB382D69
              * (v136 ^ ((0x9DDFEA08EB382D69 * (v136 ^ v134)) >> 47) ^ (0x9DDFEA08EB382D69 * (v136 ^ v134)))) ^ ((0x9DDFEA08EB382D69 * (v136 ^ ((0x9DDFEA08EB382D69 * (v136 ^ v134)) >> 47) ^ (0x9DDFEA08EB382D69 * (v136 ^ v134)))) >> 47));
        goto LABEL_41;
      }
      if (v150)
      {
        unsigned int v73 = *(unsigned __int8 *)(v150 + 16);
        if (v73 >= 0x1C && v73 - 83 >= 0xFFFFFFFE)
        {
          uint64_t v75 = *(void *)(v150 - 64);
          if (v75)
          {
            uint64_t v76 = *(void *)(v150 - 32);
            if (v76)
            {
              uint64_t v77 = *(_WORD *)(v150 + 18) & 0x3F;
              if (dword_1CFB2CA9C[v77] < v77)
              {
                LODWORD(v77) = dword_1CFB2C9F8[(*(_WORD *)(v150 + 18) & 0x3F) - 1];
                unint64_t v78 = v148;
                unint64_t v148 = v149;
                unint64_t v149 = v78;
              }
              int v79 = *(unsigned __int8 *)(v8 + 16) - 28;
              uint64_t v161 = 0;
              long long v159 = 0u;
              long long v160 = 0u;
              long long v157 = 0u;
              long long v158 = 0u;
              long long v156 = 0u;
              memset(__dst, 0, sizeof(__dst));
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EBCBE588))
              {
                unint64_t v117 = llvm::hashing::detail::fixed_seed_override;
                if (!llvm::hashing::detail::fixed_seed_override) {
                  unint64_t v117 = 0xFF51AFD7ED558CCDLL;
                }
                qword_1EBCBE580 = v117;
                __cxa_guard_release(&qword_1EBCBE588);
              }
              *(void *)&__dst[0] = __PAIR64__(v77, v79);
              uint64_t v162 = qword_1EBCBE580;
              *((void *)&__dst[0] + 1) = v75;
              uint64_t DerivedPtr = 0;
              int v80 = sub_1CC2E96A4(__dst, &DerivedPtr, &__dst[1], (unint64_t)&v158, v76);
              uint64_t BasePtr = DerivedPtr;
              BOOL v32 = sub_1CC2E96A4(__dst, &BasePtr, v80, (unint64_t)&v158, v149);
              uint64_t v154 = BasePtr;
              uint64_t v33 = v148;
              goto LABEL_37;
            }
          }
        }
      }
      int v81 = *(unsigned __int8 *)(v8 + 16) - 28;
      uint64_t v161 = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      long long v156 = 0u;
      memset(__dst, 0, sizeof(__dst));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCBE588))
      {
        unint64_t v114 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v114 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v114;
        __cxa_guard_release(&qword_1EBCBE588);
      }
      uint64_t v162 = qword_1EBCBE580;
      uint64_t v82 = &v150;
      p_uint64_t BasePtr = (uint64_t *)&v149;
      p_uint64_t DerivedPtr = (uint64_t *)&v148;
      int v85 = v81;
LABEL_159:
      LODWORD(v36) = sub_1CCD4D5F4((char *)__dst, __dst, (char *)&v158, v85, v82, p_BasePtr, p_DerivedPtr);
      goto LABEL_41;
    }
    int v69 = *(unsigned __int8 *)(v8 + 16);
    if (v8 && (v69 - 79) >= 0xFFFFFFF3)
    {
      int v70 = v69 - 28;
      uint64_t v71 = *(void *)v8;
      unint64_t v24 = *(void *)(v8 - 32);
      uint64_t v161 = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      long long v156 = 0u;
      memset(__dst, 0, sizeof(__dst));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCBE588))
      {
        unint64_t v113 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v113 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v113;
        __cxa_guard_release(&qword_1EBCBE588);
      }
      unint64_t v25 = qword_1EBCBE580;
      uint64_t v162 = qword_1EBCBE580;
      LODWORD(__dst[0]) = v70;
      *(void *)((char *)__dst + 4) = v71;
      goto LABEL_26;
    }
    if (v8 && v69 == 95)
    {
      uint64_t v72 = *(void *)(v8 - 32);
      uint64_t v161 = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      long long v156 = 0u;
      memset(__dst, 0, sizeof(__dst));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCBE588))
      {
        unint64_t v115 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v115 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v115;
        __cxa_guard_release(&qword_1EBCBE588);
      }
      unint64_t v25 = qword_1EBCBE580;
      uint64_t v162 = qword_1EBCBE580;
      LODWORD(__dst[0]) = 67;
      *(void *)((char *)__dst + 4) = v72;
      unint64_t v17 = 12;
      goto LABEL_40;
    }
    if (!v8 || v69 != 92)
    {
      if (v8 && v69 == 93)
      {
        uint64_t v86 = *(void *)(v8 - 64);
        uint64_t v87 = *(void *)(v8 - 32);
        unint64_t v88 = sub_1CC13A6B8(*(void **)(v8 + 64), *(void *)(v8 + 64) + 4 * *(unsigned int *)(v8 + 72));
        uint64_t v161 = 0;
        long long v159 = 0u;
        long long v160 = 0u;
        long long v157 = 0u;
        long long v158 = 0u;
        long long v156 = 0u;
        memset(__dst, 0, sizeof(__dst));
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EBCBE588))
        {
          unint64_t v118 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v118 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v118;
          __cxa_guard_release(&qword_1EBCBE588);
        }
        uint64_t v162 = qword_1EBCBE580;
        LODWORD(__dst[0]) = 65;
        *(void *)((char *)__dst + 4) = v86;
        uint64_t BasePtr = 0;
        int v89 = sub_1CC2E96A4(__dst, &BasePtr, (void *)((unint64_t)__dst | 0xC), (unint64_t)&v158, v87);
        uint64_t v154 = BasePtr;
        uint64_t v90 = (char *)sub_1CBFFCBA0(__dst, &v154, v89, (unint64_t)&v158, v88);
        int v15 = v90;
        uint64_t v35 = v154;
        if (!v154)
        {
          unint64_t v17 = v90 - (char *)__dst;
          goto LABEL_39;
        }
        if (v90 == (char *)__dst) {
          goto LABEL_252;
        }
        goto LABEL_229;
      }
      if (v69 == 84)
      {
        uint64_t v91 = *(void *)(v8 - 32);
        if (v91)
        {
          if (!*(unsigned char *)(v91 + 16)
            && *(void *)(v91 + 24) == *(void *)(v8 + 72)
            && (*(unsigned char *)(v91 + 33) & 0x20) != 0)
          {
            if ((int v92 = *(_DWORD *)(v91 + 36), (v92 - 142) <= 0x3C)
              && ((1 << (v92 + 114)) & 0x180C000000000003) != 0
              || (unsigned int v101 = v92 - 262, v101 <= 0x2F) && ((1 << v101) & 0xF8C00001F003) != 0)
            {
              int v93 = *(_DWORD *)(v8 + 20);
              if (v93 < 0
                && (uint64_t v145 = v8 - 32 * (v93 & 0x7FFFFFF), v146 = *(void *)(v145 - 8), (v146 & 0xFFFFFFFF0) != 0))
              {
                uint64_t v95 = -(uint64_t)(v93 & 0x7FFFFFF);
                int v94 = *(_DWORD *)(v145 - 12) - *(_DWORD *)(v145 - v146);
              }
              else
              {
                int v94 = 0;
                uint64_t v95 = -(uint64_t)(v93 & 0x7FFFFFF);
              }
              int v96 = (unint64_t *)(v8 + 32 * v95);
              if (((32 * -v94 - 32 - 32 * v95) & 0x1FFFFFFFE0) == 0x40)
              {
                unint64_t v97 = *v96;
                unint64_t v98 = v96[4];
                if (v97 <= v98) {
                  unint64_t v99 = v97;
                }
                else {
                  unint64_t v99 = v98;
                }
                if (v97 <= v98) {
                  unint64_t v100 = v98;
                }
                else {
                  unint64_t v100 = v97;
                }
                uint64_t v161 = 0;
                long long v159 = 0u;
                long long v160 = 0u;
                long long v157 = 0u;
                long long v158 = 0u;
                long long v156 = 0u;
                memset(__dst, 0, sizeof(__dst));
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EBCBE588))
                {
                  unint64_t v144 = llvm::hashing::detail::fixed_seed_override;
                  if (!llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v144 = 0xFF51AFD7ED558CCDLL;
                  }
                  qword_1EBCBE580 = v144;
                  __cxa_guard_release(&qword_1EBCBE588);
                }
                uint64_t v162 = qword_1EBCBE580;
                LODWORD(__dst[0]) = 56;
                *(void *)((char *)__dst + 4) = v99;
                *(void *)((char *)__dst + 12) = v100;
                LODWORD(v36) = sub_1CBAE06B8(__dst, 0x14uLL, qword_1EBCBE580);
                goto LABEL_41;
              }
            }
          }
        }
      }
      BOOL v102 = sub_1CC070820(v8);
      int v103 = *(unsigned __int8 *)(v8 + 16) - 28;
      if (!v102)
      {
        int v104 = *(_DWORD *)(v8 + 20);
        if ((v104 & 0x40000000) != 0)
        {
          uint64_t v106 = *(uint64_t **)(v8 - 8);
          uint64_t v105 = v104 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v105 = v104 & 0x7FFFFFF;
          uint64_t v106 = (uint64_t *)(v8 - 32 * v105);
        }
        unint64_t v107 = sub_1CC87323C(v106, &v106[4 * v105]);
        DWORD2(__dst[0]) = 0;
        *(void *)&__dst[0] = 0;
        if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
          && __cxa_guard_acquire(&qword_1EBCBE588))
        {
          unint64_t v119 = llvm::hashing::detail::fixed_seed_override;
          if (!llvm::hashing::detail::fixed_seed_override) {
            unint64_t v119 = 0xFF51AFD7ED558CCDLL;
          }
          qword_1EBCBE580 = v119;
          __cxa_guard_release(&qword_1EBCBE588);
        }
        LODWORD(__dst[0]) = v103;
        *(void *)((char *)__dst + 4) = v107;
        unint64_t v108 = 0x9DDFEA08EB382D69 * (qword_1EBCBE580 ^ *(void *)&__dst[0] ^ __ROR8__(v107 + 12, 12));
        unint64_t v109 = __ROR8__(v107 + 12, 12) ^ (v108 >> 47);
        unint64_t v36 = (0x9DDFEA08EB382D69
             * ((0x9DDFEA08EB382D69 * (v109 ^ v108)) ^ ((0x9DDFEA08EB382D69 * (v109 ^ v108)) >> 47))) ^ v107;
        goto LABEL_41;
      }
      uint64_t v154 = *(void *)(v8 - 32 * (*(_DWORD *)(v8 + 20) & 0x7FFFFFF));
      uint64_t BasePtr = llvm::GCRelocateInst::getBasePtr((llvm::GCRelocateInst *)v8);
      uint64_t DerivedPtr = llvm::GCRelocateInst::getDerivedPtr((llvm::GCRelocateInst *)v8);
      uint64_t v161 = 0;
      long long v159 = 0u;
      long long v160 = 0u;
      long long v157 = 0u;
      long long v158 = 0u;
      long long v156 = 0u;
      memset(__dst, 0, sizeof(__dst));
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCBE588))
      {
        unint64_t v138 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v138 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v138;
        __cxa_guard_release(&qword_1EBCBE588);
      }
      uint64_t v162 = qword_1EBCBE580;
      uint64_t v82 = &v154;
      p_uint64_t BasePtr = &BasePtr;
      p_uint64_t DerivedPtr = &DerivedPtr;
      int v85 = v103;
      goto LABEL_159;
    }
    unint64_t v20 = *(void *)(v8 - 32);
    unint64_t v24 = sub_1CC13A6B8(*(void **)(v8 + 64), *(void *)(v8 + 64) + 4 * *(unsigned int *)(v8 + 72));
    uint64_t v161 = 0;
    long long v159 = 0u;
    long long v160 = 0u;
    long long v157 = 0u;
    long long v158 = 0u;
    long long v156 = 0u;
    memset(__dst, 0, sizeof(__dst));
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCBE588))
    {
      unint64_t v116 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v116 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v116;
      __cxa_guard_release(&qword_1EBCBE588);
    }
    unint64_t v25 = qword_1EBCBE580;
    uint64_t v162 = qword_1EBCBE580;
    LODWORD(__dst[0]) = 64;
  }
  *(void *)((char *)__dst + 4) = v20;
LABEL_26:
  *(void *)((char *)__dst + 12) = v24;
  unint64_t v17 = 20;
LABEL_40:
  LODWORD(v36) = sub_1CBAE06B8(__dst, v17, v25);
LABEL_41:
  uint64_t v37 = 0;
  int v38 = a2 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v40 = v36 & v38;
    uint64_t v18 = (const llvm::Instruction **)(a1 + 16 * (v36 & v38));
    uint64_t v41 = *a3;
    uint64_t v42 = *v18;
    if (((unint64_t)*a3 | 0x1000) == 0xFFFFFFFFFFFFF000
      || ((unint64_t)v42 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      if (v41 == v42) {
        goto LABEL_135;
      }
      goto LABEL_86;
    }
    if (*((unsigned __int8 *)v41 + 16) != *((unsigned __int8 *)v42 + 16)) {
      goto LABEL_86;
    }
    if (llvm::Instruction::isIdenticalToWhenDefined(*a3, *v18)) {
      goto LABEL_135;
    }
    int v43 = *((unsigned __int8 *)v41 + 16);
    if ((v43 - 59) >= 0xFFFFFFEE)
    {
      if (!llvm::Instruction::isCommutative(v41) || *((void *)v41 - 8) != *((void *)v42 - 4)) {
        goto LABEL_86;
      }
      uint64_t v47 = *((void *)v41 - 4);
      uint64_t v48 = *((void *)v42 - 8);
      goto LABEL_68;
    }
    if ((v43 - 83) >= 0xFFFFFFFE)
    {
      if (*((void *)v41 - 8) == *((void *)v42 - 4)
        && *((void *)v41 - 4) == *((void *)v42 - 8)
        && dword_1CFB2CB44[*((_WORD *)v41 + 9) & 0x3F] == (*((_WORD *)v42 + 9) & 0x3F))
      {
        goto LABEL_135;
      }
      goto LABEL_86;
    }
    if (v43 == 84)
    {
      unint64_t v44 = (llvm::Instruction *)*((void *)v41 - 4);
      if (!v44) {
        goto LABEL_55;
      }
      if (!*((unsigned char *)v44 + 16) && *((void *)v44 + 3) == *((void *)v41 + 9))
      {
        if ((*((unsigned char *)v44 + 33) & 0x20) != 0) {
          unint64_t v44 = v41;
        }
        else {
          unint64_t v44 = 0;
        }
        goto LABEL_55;
      }
    }
    unint64_t v44 = 0;
LABEL_55:
    if (*((unsigned char *)v42 + 16) == 84)
    {
      uint64_t v45 = *((void *)v42 - 4);
      if (v45)
      {
        if (!*(unsigned char *)(v45 + 16) && *(void *)(v45 + 24) == *((void *)v42 + 9))
        {
          uint64_t v52 = (*(unsigned char *)(v45 + 33) & 0x20) != 0 ? v42 : 0;
          if (v44)
          {
            if (v52)
            {
              int v53 = *(_DWORD *)(*((void *)v44 - 4) + 36);
              if (v53 == *(_DWORD *)(*((void *)v52 - 4) + 36))
              {
                if ((v53 - 142) <= 0x3C
                  && ((1 << (v53 + 114)) & 0x180C000000000003) != 0
                  || (unsigned int v66 = v53 - 262, v66 <= 0x2F) && ((1 << v66) & 0xF8C00001F003) != 0)
                {
                  int v54 = *((unsigned __int8 *)v44 + 16);
                  if (v54 == 84) {
                    uint64_t v55 = 0;
                  }
                  else {
                    uint64_t v55 = v54 == 39 ? (*((_DWORD *)v44 + 20) + 1) : 2;
                  }
                  int v56 = *((_DWORD *)v44 + 5);
                  if (v56 < 0
                    && (uint64_t v67 = (char *)v44 - 32 * (v56 & 0x7FFFFFF),
                        uint64_t v68 = *((void *)v67 - 1),
                        (v68 & 0xFFFFFFFF0) != 0))
                  {
                    uint64_t v58 = -(uint64_t)(v56 & 0x7FFFFFF);
                    int v57 = *((_DWORD *)v67 - 3) - *(_DWORD *)&v67[-v68];
                  }
                  else
                  {
                    int v57 = 0;
                    uint64_t v58 = -(uint64_t)(v56 & 0x7FFFFFF);
                  }
                  uint64_t v59 = (uint64_t)v44 + 32 * -v57 + -32 * v55;
                  int v60 = (void *)((char *)v44 + 32 * v58);
                  if (((v59 - (void)v60 - 32) & 0x1FFFFFFFE0) == 0x40)
                  {
                    unint64_t v61 = (uint64_t *)((char *)v52 - 32 * (*((_DWORD *)v52 + 5) & 0x7FFFFFF));
                    if (*v60 != v61[4]) {
                      goto LABEL_86;
                    }
                    uint64_t v47 = v60[4];
                    uint64_t v48 = *v61;
LABEL_68:
                    if (v47 == v48) {
                      goto LABEL_135;
                    }
                    goto LABEL_86;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (sub_1CC070820((uint64_t)v41) && sub_1CC070820((uint64_t)v42))
    {
      if (*((void *)v41 - 4 * (*((_DWORD *)v41 + 5) & 0x7FFFFFF)) == *((void *)v42
                                                                        - 4 * (*((_DWORD *)v42 + 5) & 0x7FFFFFF)))
      {
        uint64_t v147 = llvm::GCRelocateInst::getBasePtr(v41);
        if (v147 == llvm::GCRelocateInst::getBasePtr(v42))
        {
          uint64_t v46 = llvm::GCRelocateInst::getDerivedPtr(v41);
          if (v46 == llvm::GCRelocateInst::getDerivedPtr(v42)) {
            goto LABEL_135;
          }
        }
      }
      goto LABEL_86;
    }
    LODWORD(v148) = 0;
    unsigned int v151 = 0;
    uint64_t v154 = 0;
    *(void *)&__dst[0] = 0;
    uint64_t DerivedPtr = 0;
    uint64_t BasePtr = 0;
    unint64_t v149 = 0;
    uint64_t v150 = 0;
    if (!sub_1CCD4D3F0((uint64_t)v41, __dst, &BasePtr, &v150, (int *)&v148)
      || !sub_1CCD4D3F0((uint64_t)v42, &v154, &DerivedPtr, &v149, (int *)&v151))
    {
      goto LABEL_86;
    }
    if (v148 != v151)
    {
      uint64_t v49 = BasePtr;
      unint64_t v50 = v149;
LABEL_84:
      if (v49 == v50 && v150 == DerivedPtr)
      {
        if (*(void *)&__dst[0])
        {
          unsigned int v62 = *(unsigned __int8 *)(*(void *)&__dst[0] + 16);
          if (v62 >= 0x1C && v62 - 83 >= 0xFFFFFFFE)
          {
            uint64_t v63 = *(void *)(*(void *)&__dst[0] - 64);
            if (v63)
            {
              uint64_t v64 = *(void *)(*(void *)&__dst[0] - 32);
              if (v64)
              {
                if (v154)
                {
                  unsigned int v65 = *(unsigned __int8 *)(v154 + 16);
                  if (v65 >= 0x1C
                    && v65 - 83 >= 0xFFFFFFFE
                    && v63 == *(void *)(v154 - 64)
                    && v64 == *(void *)(v154 - 32)
                    && dword_1CFB2CA9C[*(_WORD *)(*(void *)&__dst[0] + 18) & 0x3F] == (*(_WORD *)(v154 + 18) & 0x3F))
                  {
                    goto LABEL_135;
                  }
                }
              }
            }
          }
        }
      }
      goto LABEL_86;
    }
    if ((v148 - 1) > 3)
    {
      uint64_t v49 = BasePtr;
      unint64_t v50 = v149;
      if (*(void *)&__dst[0] == v154 && BasePtr == DerivedPtr && v150 == v149) {
        goto LABEL_135;
      }
      goto LABEL_84;
    }
    if (BasePtr == DerivedPtr && v150 == v149 || BasePtr == v149 && v150 == DerivedPtr)
    {
LABEL_135:
      uint64_t result = 1;
      goto LABEL_136;
    }
LABEL_86:
    if (*v18 == (const llvm::Instruction *)-4096) {
      break;
    }
    if (v37) {
      BOOL v51 = 0;
    }
    else {
      BOOL v51 = *v18 == (const llvm::Instruction *)-8192;
    }
    if (v51) {
      uint64_t v37 = (const llvm::Instruction **)(a1 + 16 * v40);
    }
    LODWORD(v36) = i + v40;
  }
  uint64_t result = 0;
  if (v37) {
    uint64_t v18 = v37;
  }
LABEL_136:
  *a4 = v18;
  return result;
}

uint64_t sub_1CCD4D3F0(uint64_t a1, void *a2, void *a3, void *a4, int *a5)
{
  v19[0] = a2;
  v19[1] = a3;
  void v19[2] = a4;
  uint64_t v9 = sub_1CC189B48(v19, a1);
  if (v9)
  {
    uint64_t v10 = *a2;
    uint64_t v18 = 0;
    v19[0] = &v18;
    if (sub_1CBF686A0(v19, 30, v10))
    {
      *a2 = v18;
      uint64_t v11 = *a3;
      *a3 = *a4;
      *a4 = v11;
    }
    else
    {
      uint64_t v11 = *a4;
    }
    *a5 = 0;
    uint64_t v12 = *a2;
    if (*a2)
    {
      if (*(unsigned char *)(v12 + 16) == 81)
      {
        uint64_t v13 = *(void *)(v12 - 64);
        if (*a3 == v13 && v11 == *(void *)(v12 - 32))
        {
          LODWORD(v14) = *(_WORD *)(v12 + 18) & 0x3F;
LABEL_14:
          uint64_t v16 = v14 - 34;
          if (v16 < 8)
          {
            int v15 = dword_1CFB2CBEC[v16];
LABEL_16:
            *a5 = v15;
          }
        }
        else if (v11 == v13 && *a3 == *(void *)(v12 - 32))
        {
          uint64_t v14 = *(_WORD *)(v12 + 18) & 0x3F;
          int v15 = 4;
          switch(v14)
          {
            case 2:
            case 3:
            case 4:
            case 5:
            case 10:
            case 11:
            case 12:
            case 13:
              return v9;
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              __break(1u);
              JUMPOUT(0x1CCD4D54CLL);
            case 34:
            case 35:
              int v15 = 2;
              goto LABEL_16;
            case 36:
            case 37:
              goto LABEL_16;
            case 38:
            case 39:
              int v15 = 1;
              goto LABEL_16;
            case 40:
            case 41:
              int v15 = 3;
              goto LABEL_16;
            default:
              goto LABEL_14;
          }
        }
      }
    }
  }
  return v9;
}

unint64_t sub_1CCD4D5F4(char *a1, _DWORD *__dst, char *a3, int a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v20 = 0;
  uint64_t v12 = sub_1CC0AC9D0(a1, &v20, __dst, (unint64_t)a3, a4);
  uint64_t v21 = v20;
  uint64_t v13 = sub_1CC2E96A4(a1, &v21, v12, (unint64_t)a3, *a5);
  uint64_t v22 = v21;
  uint64_t v14 = sub_1CC2E96A4(a1, &v22, v13, (unint64_t)a3, *a6);
  uint64_t v23 = v22;
  int v15 = (char *)sub_1CC2E96A4(a1, &v23, v14, (unint64_t)a3, *a7);
  uint64_t v16 = v23;
  if (!v23) {
    return sub_1CBAE06B8(a1, v15 - a1, *((void *)a1 + 15));
  }
  int v19 = v15;
  if (v15 != a1 && v15 != a3) {
    sub_1CBFFD1E8(a1, v15, a3);
  }
  sub_1CBFFCF68((unint64_t *)a1 + 8, a1);
  return sub_1CBFFD150((void *)a1 + 8, (unint64_t)&v19[v16 - (void)a1]);
}

void *sub_1CCD4D714(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        void *result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 16 * v3;
      uint64_t v13 = v4;
      do
      {
        if ((*(void *)v13 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unint64_t v17 = 0;
          sub_1CCD4BFC4(*(void *)a1, *(_DWORD *)(a1 + 16), (llvm::Instruction **)v13, &v17);
          uint64_t v14 = v17;
          *unint64_t v17 = *(const llvm::Instruction **)v13;
          v14[1] = *(const llvm::Instruction **)(v13 + 8);
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 16;
        v12 -= 16;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v15 = *(unsigned int *)(a1 + 16);
  if (v15)
  {
    uint64_t v16 = 16 * v15;
    do
    {
      void *result = -4096;
      result += 2;
      v16 -= 16;
    }
    while (v16);
  }
  return result;
}

uint64_t sub_1CCD4D85C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (!a2)
  {
    uint64_t v4 = 0;
    uint64_t result = 0;
    goto LABEL_3;
  }
  unint64_t v6 = a4;
  v7.i32[0] = *(_DWORD *)a3;
  v7.i32[1] = *(_DWORD *)(a3 + 16);
  int32x4_t v8 = vmovn_hight_s64(v7, *(int64x2_t *)(a3 + 24));
  int8x16_t v9 = (int8x16_t)vshlq_u32((uint32x4_t)veorq_s8((int8x16_t)vzip1q_s32(v8, v8), (int8x16_t)vzip2q_s32(v8, v8)), (uint32x4_t)xmmword_1CFAC4300);
  *(int8x8_t *)v9.i8 = veor_s8(*(int8x8_t *)v9.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  int v10 = a2 - 1;
  unsigned int v11 = (v9.i32[0] ^ v9.i32[1] ^ (*(_DWORD *)(a3 + 40) >> 9) ^ (37 * *(_DWORD *)(a3 + 8)) ^ (*(_DWORD *)(a3 + 40) >> 4)) & (a2 - 1);
  uint64_t v4 = (void *)(a1 + 56 * v11);
  if (sub_1CCD4DA1C((void *)a3, v4))
  {
    uint64_t result = 1;
    goto LABEL_6;
  }
  uint64_t v13 = 0;
  int v14 = 1;
  while (*v4 == -8192)
  {
    if (v4[1] == -4 && !v4[2] && !v4[3] && !v4[4])
    {
      BOOL v15 = v4[5] == 0;
      goto LABEL_14;
    }
LABEL_13:
    BOOL v15 = 0;
LABEL_14:
    if (v15 && v13 == 0) {
      uint64_t v13 = v4;
    }
    int v16 = v14 + 1;
    unsigned int v11 = (v11 + v14) & v10;
    uint64_t v4 = (void *)(a1 + 56 * v11);
    BOOL v17 = sub_1CCD4DA1C((void *)a3, v4);
    uint64_t result = 1;
    int v14 = v16;
    a4 = v6;
    if (v17) {
      goto LABEL_3;
    }
  }
  if (*v4 != -4096 || v4[1] != -3 || v4[2] || v4[3] || v4[4] || v4[5]) {
    goto LABEL_13;
  }
  uint64_t result = 0;
  if (v13) {
    uint64_t v4 = v13;
  }
LABEL_6:
  a4 = v6;
LABEL_3:
  *a4 = v4;
  return result;
}

BOOL sub_1CCD4DA1C(void *a1, void *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4] && a1[5] == a2[5];
}

uint64_t sub_1CCD4DA88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(unsigned __int8 *)(a2 + 16);
  if (a2 && v3 == 60)
  {
    if (*(void *)a2 != a3) {
      return 0;
    }
    return a2;
  }
  if (a2 && v3 == 61)
  {
    if (**(void **)(a2 - 64) == a3) {
      return *(void *)(a2 - 64);
    }
    else {
      return 0;
    }
  }
  int v5 = *(_DWORD *)(*(void *)(a2 - 32) + 36);
  if (((v5 - 185) & 0xFFFFFFFD) == 0)
  {
    if (v5 != 185)
    {
      if (v5 == 187) {
        return *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
      }
      else {
        return 0;
      }
    }
    return a2;
  }
  return (*(uint64_t (**)(void))(***(void ***)(a1 + 8) + 1008))();
}

BOOL sub_1CCD4DB40(uint64_t a1)
{
  return *(unsigned char *)(a1 + 16) == 84
      && (uint64_t v1 = *(void *)(a1 - 32)) != 0
      && !*(unsigned char *)(v1 + 16)
      && *(void *)(v1 + 24) == *(void *)(a1 + 72)
      && (*(unsigned char *)(v1 + 33) & 0x20) != 0
      && ((*(_DWORD *)(v1 + 36) - 185) & 0xFFFFFFFD) == 0;
}

uint64_t sub_1CCD4DB90(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(*(void *)(a1 - 32) + 36);
  int v3 = *(_DWORD *)(a1 + 20);
  if (v2 == 185) {
    uint64_t v4 = (uint64_t *)(a1 - 32 * (v3 & 0x7FFFFFF));
  }
  else {
    uint64_t v4 = (uint64_t *)(a1 - 32 * (v3 & 0x7FFFFFF) + 32);
  }
  uint64_t v5 = *v4;
  int v6 = *(_DWORD *)(*(void *)(a2 - 32) + 36);
  int v7 = *(_DWORD *)(a2 + 20);
  if (v6 == 185) {
    int32x4_t v8 = (void *)(a2 - 32 * (v7 & 0x7FFFFFF));
  }
  else {
    int32x4_t v8 = (void *)(a2 - 32 * (v7 & 0x7FFFFFF) + 32);
  }
  if (v5 != *v8) {
    return 0;
  }
  if (v2 == 185 && v6 == 185)
  {
    uint64_t v11 = a1 - 32 * (v3 & 0x7FFFFFF);
    uint64_t v12 = *(void *)(v11 + 64);
    uint64_t v13 = a2 - 32 * (v7 & 0x7FFFFFF);
    uint64_t v14 = *(void *)(v13 + 64);
    if (v12 == v14)
    {
      uint64_t v19 = *(void *)(v11 + 96);
      uint64_t v15 = *(void *)(v13 + 96);
      if (v19 == v15) {
        return 1;
      }
    }
    else
    {
      uint64_t v15 = *(void *)(v13 + 96);
    }
    if (*(unsigned __int8 *)(v15 + 16) - 11 > 1) {
      return 0;
    }
    uint64_t v18 = v12;
  }
  else
  {
    if (v2 == 187 && v6 == 185)
    {
      uint64_t v16 = a2 - 32 * (v7 & 0x7FFFFFF);
      if (sub_1CCD4DD50(*(void *)(v16 + 64), *(void *)(a1 - 32 * (v3 & 0x7FFFFFF) + 96))) {
        return *(unsigned __int8 *)(*(void *)(v16 + 96) + 16) - 11 < 2;
      }
      return 0;
    }
    if (v2 == 185 && v6 == 187)
    {
      uint64_t v17 = *(void *)(a2 - 32 * (v7 & 0x7FFFFFF) + 96);
      uint64_t v18 = *(void *)(a1 - 32 * (v3 & 0x7FFFFFF) + 64);
      uint64_t v14 = v17;
    }
    else
    {
      uint64_t v9 = 0;
      if (v2 != 187 || v6 != 187) {
        return v9;
      }
      uint64_t v14 = *(void *)(a1 - 32 * (v3 & 0x7FFFFFF) + 96);
      uint64_t v18 = *(void *)(a2 - 32 * (v7 & 0x7FFFFFF) + 96);
    }
  }

  return sub_1CCD4DD50(v14, v18);
}

uint64_t sub_1CCD4DD50(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v2 = *(unsigned __int8 *)(a1 + 16);
    if ((v2 - 11) < 2) {
      return 0;
    }
    int v3 = *(unsigned __int8 *)(a2 + 16);
    if ((v3 - 11) < 2) {
      return 0;
    }
    uint64_t v4 = v2 == 10 ? a1 : 0;
    uint64_t v5 = v3 == 10 ? a2 : 0;
    if (!v4 || v5 == 0) {
      return 0;
    }
    uint64_t v8 = *(_DWORD *)(v4 + 20) & 0x7FFFFFF;
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = v4 - 32 * v8;
      uint64_t v11 = v5 - 32 * (*(_DWORD *)(v5 + 20) & 0x7FFFFFF);
      do
      {
        uint64_t v12 = *(void *)(v10 + 32 * v9);
        uint64_t v13 = *(void *)(v11 + 32 * v9);
        int v14 = *(unsigned __int8 *)(v12 + 16);
        if (v12) {
          BOOL v15 = v14 == 16;
        }
        else {
          BOOL v15 = 0;
        }
        if (v15)
        {
          uint64_t v16 = *(unsigned int *)(v12 + 32);
          if (v16 > 0x40)
          {
            int v17 = 0;
            int64_t v18 = (unint64_t)(v16 + 63) >> 6;
            do
            {
              BOOL v19 = v18-- < 1;
              if (v19) {
                break;
              }
              unint64_t v20 = *(void *)(*(void *)(v12 + 24) + 8 * v18);
              v17 += __clz(v20);
            }
            while (!v20);
            int v21 = v16 | 0xFFFFFFC0;
            if ((v16 & 0x3F) == 0) {
              int v21 = 0;
            }
            if (v17 + v21 == v16) {
              goto LABEL_48;
            }
          }
          else if (!*(void *)(v12 + 24))
          {
            goto LABEL_48;
          }
        }
        int v22 = *(unsigned __int8 *)(v13 + 16);
        if (v22 == 16 && v13 != 0)
        {
          uint64_t v24 = *(unsigned int *)(v13 + 32);
          if (v24 > 0x40)
          {
            int v25 = 0;
            int64_t v26 = (unint64_t)(v24 + 63) >> 6;
            do
            {
              BOOL v19 = v26-- < 1;
              if (v19) {
                break;
              }
              unint64_t v27 = *(void *)(*(void *)(v13 + 24) + 8 * v26);
              v25 += __clz(v27);
            }
            while (!v27);
            int v28 = v24 | 0xFFFFFFC0;
            if ((v24 & 0x3F) == 0) {
              int v28 = 0;
            }
            if (v25 + v28 != v24) {
              goto LABEL_48;
            }
          }
          else if (*(void *)(v13 + 24))
          {
            goto LABEL_48;
          }
        }
        uint64_t result = 0;
        if ((v14 - 13) > 0xFFFFFFFD || (v22 - 13) > 0xFFFFFFFD || v12 != v13) {
          return result;
        }
LABEL_48:
        ++v9;
      }
      while (v9 != v8);
    }
  }
  return 1;
}

uint64_t sub_1CCD4DED0(uint64_t a1, int a2, llvm::Instruction **a3, const llvm::Instruction ***a4)
{
  if (a2)
  {
    uint64_t v8 = *a3;
    int v9 = *((_DWORD *)*a3 + 5);
    if ((v9 & 0x40000000) != 0)
    {
      uint64_t v11 = (uint64_t *)*((void *)v8 - 1);
      uint64_t v10 = v9 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v10 = v9 & 0x7FFFFFF;
      uint64_t v11 = (uint64_t *)((char *)v8 - 32 * v10);
    }
    int v14 = *((unsigned __int8 *)*a3 + 16) - 28;
    unint64_t v15 = sub_1CC87323C(v11, &v11[4 * v10]);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
    {
      unint64_t v26 = v15;
      int v27 = __cxa_guard_acquire(&qword_1EBCBE588);
      unint64_t v15 = v26;
      if (v27)
      {
        unint64_t v28 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v28 = 0xFF51AFD7ED558CCDLL;
        }
        qword_1EBCBE580 = v28;
        __cxa_guard_release(&qword_1EBCBE588);
        unint64_t v15 = v26;
      }
    }
    uint64_t v16 = 0;
    uint64_t v17 = __ROR8__(v15 + 12, 12);
    unint64_t v18 = 0x9DDFEA08EB382D69
        * (v17 ^ ((0x9DDFEA08EB382D69 * (qword_1EBCBE580 ^ __PAIR64__(v15, v14) ^ v17)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                                  * (qword_1EBCBE580 ^ __PAIR64__(v15, v14) ^ v17)));
    int v19 = a2 - 1;
    unsigned int v20 = (a2 - 1) & ((-348639895 * ((v18 >> 47) ^ v18)) ^ v15);
    for (int i = 1; ; ++i)
    {
      uint64_t v12 = (const llvm::Instruction **)(a1 + 16 * v20);
      int v22 = (unsigned __int8 *)*a3;
      uint64_t v23 = *v12;
      if (((unint64_t)*a3 | 0x1000) == 0xFFFFFFFFFFFFF000
        || ((unint64_t)v23 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (v22 == (unsigned __int8 *)v23) {
          goto LABEL_22;
        }
      }
      else
      {
        if (llvm::Instruction::isIdenticalToWhenDefined(*a3, *v12)
          && (*((unsigned __int8 *)v23 + 17) ^ v22[17]) < 2)
        {
LABEL_22:
          uint64_t result = 1;
          goto LABEL_23;
        }
        uint64_t v23 = *v12;
      }
      if (v23 == (const llvm::Instruction *)-4096) {
        break;
      }
      if (v16) {
        BOOL v24 = 0;
      }
      else {
        BOOL v24 = v23 == (const llvm::Instruction *)-8192;
      }
      if (v24) {
        uint64_t v16 = (const llvm::Instruction **)(a1 + 16 * v20);
      }
      unsigned int v25 = v20 + i;
      unsigned int v20 = v25 & v19;
    }
    uint64_t result = 0;
    if (v16) {
      uint64_t v12 = v16;
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
LABEL_23:
  *a4 = v12;
  return result;
}

uint64_t sub_1CCD4E10C(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  int v3 = *(_DWORD *)(v2 + 40);
  if (!v3)
  {
LABEL_7:
    uint64_t v10 = 0;
    return (*(uint64_t (**)(void *, uint64_t))(*a1 + 16))(a1, v10);
  }
  uint64_t v4 = *(void *)(v2 + 24);
  unsigned int v5 = v3 - 1;
  uint64_t v6 = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = *(void *)(v4 + 16 * v6);
  if (v7 != a2)
  {
    int v8 = 1;
    while (v7 != -4096)
    {
      int v9 = v6 + v8++;
      uint64_t v6 = v9 & v5;
      uint64_t v7 = *(void *)(v4 + 16 * v6);
      if (v7 == a2) {
        goto LABEL_6;
      }
    }
    goto LABEL_7;
  }
LABEL_6:
  uint64_t v10 = *(void *)(v4 + 16 * v6 + 8);
  return (*(uint64_t (**)(void *, uint64_t))(*a1 + 16))(a1, v10);
}

const llvm::Instruction **sub_1CCD4E198(uint64_t a1, llvm::Instruction **a2)
{
  int v9 = 0;
  char v4 = sub_1CCD4DED0(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v9);
  unsigned int v5 = v9;
  if (v4) {
    return v5 + 1;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CCD4E274(a1, v7);
    int v9 = 0;
    sub_1CCD4DED0(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v9);
    unsigned int v5 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*v5 != (const llvm::Instruction *)-4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *unsigned int v5 = *a2;
  v5[1] = 0;
  return v5 + 1;
}

void *sub_1CCD4E274(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        void *result = -4096;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 16 * v3;
      uint64_t v13 = v4;
      do
      {
        if ((*(void *)v13 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v17 = 0;
          sub_1CCD4DED0(*(void *)a1, *(_DWORD *)(a1 + 16), (llvm::Instruction **)v13, &v17);
          int v14 = v17;
          *uint64_t v17 = *(const llvm::Instruction **)v13;
          v14[1] = *(const llvm::Instruction **)(v13 + 8);
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 16;
        v12 -= 16;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v15 = *(unsigned int *)(a1 + 16);
  if (v15)
  {
    uint64_t v16 = 16 * v15;
    do
    {
      void *result = -4096;
      result += 2;
      v16 -= 16;
    }
    while (v16);
  }
  return result;
}

uint64_t sub_1CCD4E3BC(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 16);
  if (v1 == 60) {
    return *(void *)a1;
  }
  if (v1 != 84
    || (uint64_t v2 = *(void *)(a1 - 32)) == 0
    || *(unsigned char *)(v2 + 16)
    || *(void *)(v2 + 24) != *(void *)(a1 + 72)
    || (*(unsigned char *)(v2 + 33) & 0x20) == 0)
  {
    uint64_t v3 = -2;
LABEL_8:
    a1 = *(void *)(a1 + 32 * v3);
    return *(void *)a1;
  }
  int v5 = *(_DWORD *)(v2 + 36);
  if (v5 == 185) {
    return *(void *)a1;
  }
  if (v5 == 187)
  {
    uint64_t v3 = -(uint64_t)(*(_DWORD *)(a1 + 20) & 0x7FFFFFF);
    goto LABEL_8;
  }
  return 0;
}

void sub_1CCD4E438()
{
}

void sub_1CCD4E474()
{
}

void sub_1CCD4E4B4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD4E4EC(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
}

uint64_t sub_1CCD4E5FC(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(char **)v5 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::TargetLibraryInfoWrapperPass::ID);
    sub_1CBF5AC74(v8, (uint64_t)a2);
  }
  return 0;
}

void sub_1CCD4E9FC(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD4EA34(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::AAResultsWrapperPass::ID);
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
}

uint64_t sub_1CCD4EB00(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((llvm::FunctionPass::skipFunction(a1, a2) & 1) == 0)
  {
    uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(char **)v5 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::TargetLibraryInfoWrapperPass::ID);
    sub_1CBF5AC74(v8, (uint64_t)a2);
  }
  return 0;
}

uint64_t sub_1CCD4EE84()
{
  dword_1EBCF17EC = sub_1CBF64200((llvm::DebugCounter *)"early-cse", 9uLL, "Controls which instructions are removed", 0x27uLL);
  int v3 = 500;
  uint64_t v4 = &v3;
  int v1 = 1;
  v2.n128_u64[0] = (unint64_t)"Enable imprecision in EarlyCSE in pathological cases, in exchange for faster compil"
                                     "e. Caps the MemorySSA clobbering calls.";
  v2.n128_u64[1] = 122;
  sub_1CBF7A9F8((uint64_t)&qword_1EBCF17F8[1], "earlycse-mssa-optimization-cap", &v4, &v1, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF17F8[1], &dword_1CB82C000);
  LOBYTE(v1) = 0;
  uint64_t v4 = &v1;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Perform extra assertion checking to verify that SimpleValue's hash function is well"
                                     "-behaved w.r.t. its isEqual predicate";
  v2.n128_u64[1] = 120;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCF18C0, "earlycse-debug-hash", (unsigned char **)&v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF18C0, &dword_1CB82C000);
}

void sub_1CCD4EFA8(llvm *a1, llvm::PassRegistry *a2)
{
}

void llvm::createFlattenCFGPass(llvm *this)
{
}

uint64_t sub_1CCD4F084(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF1980;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263DC98;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF1988, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD4EFA8;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF1988, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD4F134(uint64_t a1, llvm::BasicBlock *a2)
{
  uint64_t v4 = a1 + 72;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  unint64_t v48 = 0;
  unint64_t v5 = -1;
  uint64_t v6 = a1 + 72;
  do
  {
    uint64_t v6 = *(void *)(v6 + 8);
    ++v5;
  }
  while (v6 != v4);
  sub_1CD763788((uint64_t *)&v46, v5);
  for (uint64_t i = *(void *)(a1 + 80); i != v4; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v10 = (int32x2_t ****)(i - 24);
    if (!i) {
      uint64_t v10 = 0;
    }
    uint64_t v43 = 4;
    unint64_t v44 = 0;
    uint64_t v45 = v10;
    if (v10 != (int32x2_t ****)-8192 && v10 != (int32x2_t ****)-4096 && v10 != 0) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v43);
    }
    uint64_t v12 = v47;
    if ((unint64_t)v47 >= v48)
    {
      unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (v47 - v46);
      unint64_t v30 = v29 + 1;
      if (v29 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      uint64_t v31 = v43;
      BOOL v32 = v45;
      if (0x5555555555555556 * ((uint64_t)(v48 - (void)v46) >> 3) > v30) {
        unint64_t v30 = 0x5555555555555556 * ((uint64_t)(v48 - (void)v46) >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v48 - (void)v46) >> 3) >= 0x555555555555555) {
        unint64_t v33 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v33 = v30;
      }
      v49[4] = (void **)&v48;
      if (v33)
      {
        if (v33 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        uint64_t v34 = (void **)operator new(24 * v33);
      }
      else
      {
        uint64_t v34 = 0;
      }
      uint64_t v35 = &v34[3 * v29];
      v49[0] = v34;
      v49[1] = v35;
      v49[3] = &v34[3 * v33];
      *uint64_t v35 = (void *)4;
      v35[1] = 0;
      v35[2] = v32;
      if (v32 != (int32x2_t ****)-8192 && v32 != (int32x2_t ****)-4096)
      {
        if (v32)
        {
          v35[1] = *(void **)(v31 & 0xFFFFFFFFFFFFFFF8);
          *(void *)(v31 & 0xFFFFFFFFFFFFFFF8) = v35;
          *uint64_t v35 = (void *)(v31 & 0xFFFFFFFFFFFFFFF8 | 4);
          unint64_t v36 = (uint64_t *)v35[1];
          if (v36) {
            *unint64_t v36 = *v36 & 7 | (unint64_t)(v35 + 1);
          }
        }
      }
      v49[2] = v35 + 3;
      sub_1CD45ACEC((uint64_t *)&v46, v49);
      uint64_t v17 = v47;
      sub_1CD45AC84((uint64_t)v49);
    }
    else
    {
      *uint64_t v47 = 4;
      v12[1] = 0;
      uint64_t v13 = v45;
      _OWORD v12[2] = (unint64_t)v45;
      if (v13 != (int32x2_t ****)-8192 && v13 != (int32x2_t ****)-4096 && v13 != 0)
      {
        unint64_t v15 = v43 & 0xFFFFFFFFFFFFFFF8;
        v12[1] = *(void *)(v43 & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v15 = v12;
        *uint64_t v12 = v15 | 4;
        uint64_t v16 = (unint64_t *)v12[1];
        if (v16) {
          *uint64_t v16 = *v16 & 7 | (unint64_t)(v12 + 1);
        }
      }
      uint64_t v17 = v12 + 3;
    }
    uint64_t v47 = v17;
    if (v45 != (int32x2_t ****)-8192 && v45 != (int32x2_t ****)-4096 && v45)
    {
      unint64_t v18 = v43 & 0xFFFFFFFFFFFFFFF8;
      *(void *)(v43 & 0xFFFFFFFFFFFFFFF8) = v44;
      if (v44)
      {
        unint64_t *v44 = *v44 & 7 | v18;
      }
      else
      {
        int v19 = v45;
        unsigned int v20 = ***v45;
        unint64_t v21 = (unint64_t)v20[303];
        if (v21 <= v18)
        {
          uint64_t v22 = v20[305].u32[0];
          if (v21 + 16 * v22 > v18)
          {
            unsigned int v23 = v22 - 1;
            LODWORD(v24) = v23 & ((v45 >> 4) ^ (v45 >> 9));
            unsigned int v25 = (int32x2_t *****)(v21 + 16 * v24);
            unint64_t v26 = *v25;
            if (v45 == *v25)
            {
LABEL_32:
              *unsigned int v25 = (int32x2_t ****)-8192;
              v20[304] = vadd_s32(v20[304], (int32x2_t)0x1FFFFFFFFLL);
              int v19 = v45;
            }
            else
            {
              int v27 = 1;
              while (v26 != (int32x2_t ****)-4096)
              {
                int v28 = v24 + v27++;
                uint64_t v24 = v28 & v23;
                unint64_t v26 = *(int32x2_t *****)(v21 + 16 * v24);
                if (v45 == v26)
                {
                  unsigned int v25 = (int32x2_t *****)(v21 + 16 * v24);
                  goto LABEL_32;
                }
              }
            }
            *((unsigned char *)v19 + 17) &= ~1u;
          }
        }
      }
    }
  }
  char v37 = 0;
  do
  {
    uint64_t v38 = (uint64_t)v46;
    unsigned int v39 = v47;
    if (v46 == v47) {
      break;
    }
    char v40 = 0;
    do
    {
      uint64_t v41 = *(llvm **)(v38 + 16);
      if (v41 && llvm::FlattenCFG(v41, a2, v7, v8)) {
        char v40 = 1;
      }
      v38 += 24;
    }
    while ((unint64_t *)v38 != v39);
    char v37 = (v40 | v37) & 1;
  }
  while ((v40 & 1) != 0);
  v49[0] = (void **)&v46;
  sub_1CBF6385C(v49);
  return v37 & 1;
}

void sub_1CCD4F4D4()
{
}

void sub_1CCD4F514(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD4F54C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CCD4F55C(uint64_t a1, llvm *a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::AAResultsWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = *(llvm::BasicBlock **)((*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::AAResultsWrapperPass::ID)+ 32);
  *(void *)(a1 + 32) = v8;
  uint64_t v11 = sub_1CCD4F134((uint64_t)a2, v8);
  if (v11)
  {
    do
      llvm::removeUnreachableBlocks(a2, 0, 0, v9, v10);
    while ((sub_1CCD4F134((uint64_t)a2, *(llvm::BasicBlock **)(a1 + 32)) & 1) != 0);
  }
  return v11;
}

void sub_1CCD4F62C()
{
}

void llvm::Float2IntPass::findRoots(llvm::Float2IntPass *this, llvm::Function **a2, const llvm::DominatorTree *a3)
{
  if (a2[10] != (llvm::Function *)(a2 + 9)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
  }
}

unint64_t *llvm::Float2IntPass::badRange@<X0>(unint64_t *a1@<X8>)
{
  return llvm::ConstantRange::ConstantRange(a1, dword_1EBCF1A10 + 1, 1);
}

void llvm::Float2IntPass::unknownRange(uint64_t a1@<X8>)
{
  unsigned int v2 = dword_1EBCF1A10 + 1;
  *(_DWORD *)(a1 + 8) = dword_1EBCF1A10 + 1;
  if (v2 > 0x40) {
    operator new[]();
  }
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 24) = v2;
  *(void *)(a1 + 16) = 0;
}

unint64_t *llvm::Float2IntPass::validateRange@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 > dword_1EBCF1A10 + 1) {
    return llvm::ConstantRange::ConstantRange((unint64_t *)a2, dword_1EBCF1A10 + 1, 1);
  }
  *(_DWORD *)(a2 + 8) = v2;
  *(void *)a2 = *(void *)a1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 16);
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

void **llvm::Float2IntPass::walkBackwards(llvm::Float2IntPass *this)
{
  unsigned int v2 = (uint64_t *)*((void *)this + 15);
  unint64_t v3 = *((unsigned int *)this + 32);
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  if (v3)
  {
    sub_1CD543E14((uint64_t)&v69, v3);
    uint64_t v5 = *((void *)&v71 + 1);
    uint64_t v6 = (void *)(*((void *)&v69 + 1) + 8 * (((void)v71 + *((void *)&v71 + 1)) >> 9));
    if ((void)v70 == *((void *)&v69 + 1)) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = *v6 + 8 * (((_WORD)v71 + WORD4(v71)) & 0x1FF);
    }
    uint64_t v42 = v3 + ((v4 - *v6) >> 3);
    if (v42 < 1)
    {
      unint64_t v43 = 511 - v42;
      LOWORD(v42) = ~(511 - v42);
      uint64_t v8 = &v6[-(v43 >> 9)];
    }
    else
    {
      uint64_t v8 = &v6[(unint64_t)v42 >> 9];
    }
    uint64_t v7 = *v8 + 8 * (v42 & 0x1FF);
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  if (v4 != v7)
  {
    do
    {
      uint64_t v9 = v7;
      if (v6 != v8) {
        uint64_t v9 = *v6 + 4096;
      }
      if (v4 == v9)
      {
        uint64_t v9 = v4;
      }
      else
      {
        uint64_t v10 = (void *)v4;
        do
        {
          uint64_t v11 = *v2++;
          *v10++ = v11;
        }
        while (v10 != (void *)v9);
      }
      v5 += (v9 - v4) >> 3;
      if (v6 == v8) {
        break;
      }
      uint64_t v12 = v6[1];
      ++v6;
      uint64_t v4 = v12;
    }
    while (v12 != v7);
    *((void *)&v71 + 1) = v5;
  }
  if (v5)
  {
    do
    {
      uint64_t v13 = *(void *)(*(void *)(*((void *)&v69 + 1)
                                  + (((unint64_t)(v5 - 1 + v71) >> 6) & 0x3FFFFFFFFFFFFF8))
                      + 8 * ((v5 - 1 + v71) & 0x1FF));
      if ((void)v70 == *((void *)&v69 + 1)) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = (((void)v70 - *((void *)&v69 + 1)) << 6) - 1;
      }
      *((void *)&v71 + 1) = v5 - 1;
      if ((unint64_t)(v14 - (v5 + v71) + 1) >= 0x400)
      {
        operator delete(*(void **)(v70 - 8));
        *(void *)&long long v70 = v70 - 8;
      }
      if (*((void *)this + 4) != sub_1CD763964((uint64_t)this, v13)) {
        goto LABEL_21;
      }
      unsigned int v15 = *(unsigned __int8 *)(v13 + 16) - 40;
      if (v15 <= 0x2A)
      {
        if (((1 << v15) & 0x40060000055) != 0)
        {
          unsigned int v50 = dword_1EBCF1A10 + 1;
          if ((dword_1EBCF1A10 + 1) >= 0x41) {
            operator new[]();
          }
          unsigned int v52 = dword_1EBCF1A10 + 1;
          uint64_t v49 = 0;
          uint64_t v51 = 0;
          llvm::Float2IntPass::seen((uint64_t)this, v13, (uint64_t)&v49);
          if (v52 >= 0x41 && v51) {
            MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
          }
          if (v50 >= 0x41)
          {
            char v40 = v49;
            if (v49) {
              goto LABEL_99;
            }
          }
          goto LABEL_28;
        }
        if (((1 << v15) & 0x180000000) != 0)
        {
          int v33 = *(_DWORD *)(v13 + 20);
          if ((v33 & 0x40000000) != 0) {
            uint64_t v34 = *(llvm::Type ****)(v13 - 8);
          }
          else {
            uint64_t v34 = (llvm::Type ***)(v13 - 32 * (v33 & 0x7FFFFFF));
          }
          unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(**v34);
          if (v35 == 1) {
          unsigned int v62 = PrimitiveSizeInBits;
          }
          if (PrimitiveSizeInBits > 0x40) {
            operator new[]();
          }
          char v37 = (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)PrimitiveSizeInBits);
          if (!PrimitiveSizeInBits) {
            char v37 = 0;
          }
          unint64_t v61 = v37;
          unsigned int v64 = PrimitiveSizeInBits;
          uint64_t v63 = v37;
          llvm::ConstantRange::castOp((unint64_t *)&v61, *(unsigned __int8 *)(v13 + 16) - 28, dword_1EBCF1A10 + 1, (uint64_t)&v53);
          if (v54 <= dword_1EBCF1A10 + 1)
          {
            unsigned int v58 = v54;
            int v57 = v53;
            unsigned int v60 = v56;
            uint64_t v59 = v55;
            unsigned int v54 = 0;
            unsigned int v56 = 0;
          }
          else
          {
            unsigned int v58 = dword_1EBCF1A10 + 1;
            if ((dword_1EBCF1A10 + 1) > 0x40) {
              operator new[]();
            }
            if (dword_1EBCF1A10 == -1) {
              uint64_t v38 = 0;
            }
            else {
              uint64_t v38 = (void *)(0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)dword_1EBCF1A10);
            }
            int v57 = v38;
            unsigned int v60 = dword_1EBCF1A10 + 1;
            uint64_t v59 = v38;
          }
          llvm::Float2IntPass::seen((uint64_t)this, v13, (uint64_t)&v57);
          if (v60 >= 0x41 && v59) {
            MEMORY[0x1D25D9CB0](v59, 0x1000C8000313F17);
          }
          if (v58 >= 0x41 && v57) {
            MEMORY[0x1D25D9CB0](v57, 0x1000C8000313F17);
          }
          if (v56 >= 0x41 && v55) {
            MEMORY[0x1D25D9CB0](v55, 0x1000C8000313F17);
          }
          if (v54 >= 0x41 && v53) {
            MEMORY[0x1D25D9CB0](v53, 0x1000C8000313F17);
          }
          if (v64 >= 0x41 && v63) {
            MEMORY[0x1D25D9CB0](v63, 0x1000C8000313F17);
          }
          if (v62 >= 0x41 && v61) {
            MEMORY[0x1D25D9CB0](v61, 0x1000C8000313F17);
          }
          goto LABEL_21;
        }
      }
      unsigned int v66 = dword_1EBCF1A10 + 1;
      if ((dword_1EBCF1A10 + 1) > 0x40) {
        operator new[]();
      }
      unint64_t v39 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)dword_1EBCF1A10;
      if (dword_1EBCF1A10 == -1) {
        unint64_t v39 = 0;
      }
      unsigned int v65 = (void *)v39;
      unsigned int v68 = dword_1EBCF1A10 + 1;
      unint64_t v67 = v39;
      llvm::Float2IntPass::seen((uint64_t)this, v13, (uint64_t)&v65);
      if (v68 >= 0x41 && v67) {
        MEMORY[0x1D25D9CB0](v67, 0x1000C8000313F17);
      }
      if (v66 >= 0x41)
      {
        char v40 = v65;
        if (v65) {
LABEL_99:
        }
          MEMORY[0x1D25D9CB0](v40, 0x1000C8000313F17);
      }
LABEL_28:
      int v16 = *(_DWORD *)(v13 + 20);
      if ((v16 & 0x40000000) != 0)
      {
        uint64_t v18 = *(void *)(v13 - 8);
        uint64_t v17 = v16 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v17 = v16 & 0x7FFFFFF;
        uint64_t v18 = v13 - 32 * v17;
      }
      if (v17)
      {
        uint64_t v19 = v18 + 32 * v17;
        while (1)
        {
          unsigned int v20 = *(void **)v18;
          unsigned int v21 = *(unsigned __int8 *)(*(void *)v18 + 16);
          if (v21 <= 0x1B) {
            unsigned int v20 = 0;
          }
          unint64_t v61 = v20;
          if (v20) {
            break;
          }
          if (v21 != 17)
          {
            unsigned int v46 = dword_1EBCF1A10 + 1;
            if ((dword_1EBCF1A10 + 1) > 0x40) {
              operator new[]();
            }
            unint64_t v29 = (void *)(0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)dword_1EBCF1A10);
            if (dword_1EBCF1A10 == -1) {
              unint64_t v29 = 0;
            }
            __src = v29;
            unsigned int v48 = dword_1EBCF1A10 + 1;
            uint64_t v47 = v29;
            llvm::Float2IntPass::seen((uint64_t)this, v13, (uint64_t)&__src);
            if (v48 >= 0x41 && v47) {
              MEMORY[0x1D25D9CB0](v47, 0x1000C8000313F17);
            }
            if (v46 >= 0x41 && __src) {
              MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
            }
          }
LABEL_37:
          v18 += 32;
          if (v18 == v19) {
            goto LABEL_21;
          }
        }
        sub_1CD7639D0((uint64_t **)this + 25, v13, (uint64_t *)&v61);
        uint64_t v22 = sub_1CD763964((uint64_t)this, v13);
        if ((dword_1EBCF1A10 + 1) > 0x40) {
          operator new[]();
        }
        if (dword_1EBCF1A10 == -1)
        {
          unsigned int v23 = 0;
          uint64_t v24 = 0;
        }
        else
        {
          unsigned int v23 = (const void *)(0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)dword_1EBCF1A10);
          uint64_t v24 = v23;
        }
        uint64_t v25 = *(unsigned int *)(v22 + 16);
        if (v25 > 0x40)
        {
          uint64_t v44 = v22;
          unint64_t v30 = v24;
          int v31 = memcmp(*(const void **)(v22 + 8), v23, ((unint64_t)(v25 + 63) >> 3) & 0x3FFFFFF8);
          uint64_t v24 = v30;
          int v32 = v31;
          uint64_t v22 = v44;
          if (v32) {
            goto LABEL_65;
          }
LABEL_44:
          uint64_t v26 = *(unsigned int *)(v22 + 32);
          if (v26 > 0x40) {
            BOOL v27 = memcmp(*(const void **)(v22 + 24), v24, ((unint64_t)(v26 + 63) >> 3) & 0x3FFFFFF8) == 0;
          }
          else {
            BOOL v27 = *(void *)(v22 + 24) == (void)v24;
          }
          char v28 = v27;
        }
        else
        {
          if (*(const void **)(v22 + 8) == v23) {
            goto LABEL_44;
          }
LABEL_65:
          char v28 = 0;
        }
        if ((v28 & 1) == 0) {
          sub_1CD3F21B0(&v69, &v61);
        }
        goto LABEL_37;
      }
LABEL_21:
      uint64_t v5 = *((void *)&v71 + 1);
    }
    while (*((void *)&v71 + 1));
  }
  return sub_1CB904DFC((void **)&v69);
}

unint64_t *sub_1CCD50670(unint64_t *result, unint64_t a2)
{
  uint64_t v2 = *((unsigned int *)result + 2);
  unint64_t v3 = *result;
  if (v2 >= *((_DWORD *)result + 3))
  {
    unint64_t v5 = v3 + 32 * v2;
    if (v3 > a2 || v5 <= a2) {
      sub_1CD49B310();
    }
    sub_1CD49B310();
  }
  unint64_t v4 = v3 + 32 * *((unsigned int *)result + 2);
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)unint64_t v4 = *(void *)a2;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(v4 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(v4 + 16) = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = 0;
  ++*((_DWORD *)result + 2);
  return result;
}

void **llvm::Float2IntPass::walkForwards(llvm::Float2IntPass *this)
{
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return sub_1CB904DFC((void **)&v26);
  }
  do
  {
    if ((dword_1EBCF1A10 + 1) >= 0x41) {
      operator new[]();
    }
    uint64_t v4 = *(unsigned int *)(v1 + 16);
    if (v4 > 0x40)
    {
      if (memcmp(*(const void **)(v1 + 8), 0, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8))
      {
LABEL_16:
        int v7 = 0;
        goto LABEL_10;
      }
    }
    else if (*(void *)(v1 + 8))
    {
      goto LABEL_16;
    }
    uint64_t v5 = *(unsigned int *)(v1 + 32);
    if (v5 > 0x40) {
      BOOL v6 = memcmp(*(const void **)(v1 + 24), 0, ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8) == 0;
    }
    else {
      BOOL v6 = *(void *)(v1 + 24) == 0;
    }
    int v7 = v6;
LABEL_10:
    if (v7) {
      sub_1CD3F21B0(&v26, (void *)v1);
    }
    v1 += 40;
  }
  while (v1 != v2);
  while (1)
  {
    uint64_t v14 = *((void *)&v28 + 1);
    if (!*((void *)&v28 + 1)) {
      break;
    }
    uint64_t v8 = (((void)v27 - *((void *)&v26 + 1)) << 6) - 1;
    if ((void)v27 == *((void *)&v26 + 1)) {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(llvm::Instruction **)(*(void *)(*((void *)&v26 + 1)
                                           + (((unint64_t)(v28 + *((void *)&v28 + 1) - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                               + 8 * ((v28 + *((void *)&v28 + 1) - 1) & 0x1FF));
    uint64_t v25 = v9;
    --*((void *)&v28 + 1);
    if ((unint64_t)(v8 - (v14 + v28) + 1) >= 0x400)
    {
      operator delete(*(void **)(v27 - 8));
      *(void *)&long long v27 = v27 - 8;
    }
    llvm::Float2IntPass::calcRange(this, v9, (uint64_t)&__src);
    if (v24)
    {
      unsigned int v10 = v21;
      unsigned int v17 = v21;
      if (v21 > 0x40) {
        operator new[]();
      }
      uint64_t v11 = __src;
      int v16 = __src;
      unsigned int v12 = v23;
      unsigned int v19 = v23;
      if (v23 > 0x40) {
        operator new[]();
      }
      uint64_t v13 = v22;
      uint64_t v18 = v22;
      llvm::Float2IntPass::seen((uint64_t)this, (uint64_t)v9, (uint64_t)&v16);
      if (v19 >= 0x41 && v18) {
        MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
      }
      if (v17 >= 0x41 && v16) {
        MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
      }
      if (v12 >= 0x41 && v13) {
        MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
      }
      if (v10 >= 0x41 && v11) {
        MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
      }
    }
    else
    {
      sub_1CD540070(&v26, &v25);
    }
  }
  return sub_1CB904DFC((void **)&v26);
}

uint64_t llvm::Float2IntPass::validateAndTransform(llvm::Float2IntPass *this)
{
  uint64_t v1 = (char *)*((void *)this + 25);
  uint64_t v2 = (char *)this + 208;
  if (v1 == (char *)this + 208)
  {
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    uint64_t v47 = (char *)this + 48;
    unsigned int v46 = (char *)this + 56;
    do
    {
      unsigned int v53 = dword_1EBCF1A10 + 1;
      if ((dword_1EBCF1A10 + 1) >= 0x41) {
        operator new[]();
      }
      unsigned int v55 = dword_1EBCF1A10 + 1;
      __src = 0;
      __s2 = 0;
      if (v1[40])
      {
        uint64_t v5 = 0;
        unint64_t v6 = (unint64_t)(v1 + 32);
        unint64_t v7 = (unint64_t)(v1 + 32);
        do
        {
          uint64_t v8 = *(uint64_t **)(v7 + 16);
          uint64_t v9 = sub_1CD763964((uint64_t)this, (uint64_t)v8);
          if (*((void *)this + 4) != v9)
          {
            llvm::ConstantRange::unionWith((uint64_t)&__src, (unsigned int *)(v9 + 8), 0, (uint64_t)&v48);
            if (v53 >= 0x41 && __src) {
              MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
            }
            __src = v48;
            unsigned int v53 = v49;
            unsigned int v49 = 0;
            if (v55 >= 0x41 && __s2)
            {
              MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
              __s2 = v50;
              unsigned int v55 = v51;
              unsigned int v51 = 0;
              if (v49 >= 0x41 && v48) {
                MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
              }
            }
            else
            {
              __s2 = v50;
              unsigned int v55 = v51;
            }
            uint64_t v10 = sub_1CD764774((uint64_t)v47, (uint64_t)v8);
            if (*v47)
            {
              uint64_t v11 = v46;
              uint64_t v12 = 8;
            }
            else
            {
              uint64_t v11 = (char *)*((void *)this + 7);
              uint64_t v12 = *((unsigned int *)this + 16);
            }
            if (&v11[8 * v12] == (char *)v10)
            {
              if (!v5) {
                uint64_t v5 = *v8;
              }
              for (uint64_t i = v8[1]; i; uint64_t i = *(void *)(i + 8))
              {
                uint64_t v14 = *(void *)(i + 24);
                BOOL v15 = v14 && *(unsigned __int8 *)(v14 + 16) >= 0x1Cu;
                if (!v15 || *((void *)this + 4) == sub_1CD763964((uint64_t)this, v14)) {
                  goto LABEL_64;
                }
              }
            }
          }
          unint64_t v7 = *(void *)(v7 + 8) & 0xFFFFFFFFFFFFFFFELL;
        }
        while (v7);
        if ((v1[40] & 1) == 0) {
          goto LABEL_64;
        }
        unsigned int v16 = v53;
        if (v53 > 0x40)
        {
          if (!memcmp(__src, __s2, (((unint64_t)v53 + 63) >> 3) & 0x3FFFFFF8)
            && llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&__src) == v16)
          {
            goto LABEL_64;
          }
        }
        else if (__src == __s2 && (!v53 || __src == (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v53)))
        {
          goto LABEL_64;
        }
        if (!llvm::ConstantRange::isSignWrappedSet((llvm::ConstantRange *)&__src))
        {
          unsigned int v17 = v53;
          unsigned int v18 = v53 - 1;
          if (v53 > 0x40)
          {
            if ((*((void *)__src + (v18 >> 6)) >> v18))
            {
              int v19 = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&__src);
            }
            else
            {
              int v37 = 0;
              int64_t v38 = ((unint64_t)v53 + 63) >> 6;
              do
              {
                BOOL v29 = v38-- < 1;
                if (v29) {
                  break;
                }
                unint64_t v39 = *((void *)__src + v38);
                v37 += __clz(v39);
              }
              while (!v39);
              unsigned int v40 = v53 | 0xFFFFFFC0;
              if ((v53 & 0x3F) == 0) {
                unsigned int v40 = 0;
              }
              int v19 = v37 + v40;
            }
          }
          else if (((unint64_t)__src >> v18))
          {
            if (v53) {
              int v19 = __clz(~((void)__src << -(char)v53));
            }
            else {
              int v19 = 0;
            }
          }
          else
          {
            int v19 = v53 + __clz((unint64_t)__src) - 64;
          }
          unsigned int v20 = v55;
          unsigned int v21 = v55 - 1;
          if (v55 > 0x40)
          {
            if ((*((void *)__s2 + (v21 >> 6)) >> v21))
            {
              int v25 = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&__s2);
            }
            else
            {
              int v41 = 0;
              int64_t v42 = ((unint64_t)v55 + 63) >> 6;
              do
              {
                BOOL v29 = v42-- < 1;
                if (v29) {
                  break;
                }
                unint64_t v43 = *((void *)__s2 + v42);
                v41 += __clz(v43);
              }
              while (!v43);
              unsigned int v44 = v55 | 0xFFFFFFC0;
              if ((v55 & 0x3F) == 0) {
                unsigned int v44 = 0;
              }
              int v25 = v41 + v44;
            }
          }
          else
          {
            unint64_t v22 = (unint64_t)__s2 >> v21;
            int v23 = v55 + __clz((unint64_t)__s2) - 64;
            int v24 = __clz(~((void)__s2 << -(char)v55));
            if (!v55) {
              int v24 = 0;
            }
            if (v22) {
              int v25 = v24;
            }
            else {
              int v25 = v23;
            }
          }
          if (v17 - v19 + 1 <= v20 - v25 + 1) {
            int v26 = v20 - v25 + 1;
          }
          else {
            int v26 = v17 - v19 + 1;
          }
          if (*(unsigned char *)(v5 + 8) == 2)
          {
            long long v27 = &unk_1CFB2E308;
          }
          else
          {
            long long v27 = &unk_1CFB2E2E0;
            switch(*(unsigned char *)(v5 + 8))
            {
              case 1:
                long long v27 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)&unk_1CFB2E2E0);
                break;
              case 2:
                __break(1u);
                JUMPOUT(0x1CCD5113CLL);
              case 3:
                long long v27 = llvm::APFloatBase::IEEEdouble((llvm::APFloatBase *)&unk_1CFB2E2E0);
                break;
              case 4:
                long long v27 = llvm::APFloatBase::x87DoubleExtended((llvm::APFloatBase *)&unk_1CFB2E2E0);
                break;
              case 5:
                long long v27 = llvm::APFloatBase::IEEEquad((llvm::APFloatBase *)&unk_1CFB2E2E0);
                break;
              case 6:
                long long v27 = &unk_1CFB2E344;
                break;
              default:
                break;
            }
          }
          unsigned int v28 = v26 + 1;
          BOOL v29 = (v26 + 1) > 0x40 || v28 > v27[2] - 1;
          if (!v29)
          {
            uint64_t v30 = **((void **)this + 35);
            int v31 = (llvm::Type *)(v30 + 1984);
            int v32 = (llvm::Type *)(v30 + 1960);
            if (v28 <= 0x20) {
              int v33 = v32;
            }
            else {
              int v33 = v31;
            }
            if (v1[40])
            {
              do
              {
                llvm::Float2IntPass::convert(this, *(llvm::Instruction **)(v6 + 16), v33);
                char v4 = 1;
                unint64_t v6 = *(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFFELL;
              }
              while (v6);
            }
            else
            {
              char v4 = 1;
            }
          }
        }
      }
LABEL_64:
      if (v55 >= 0x41 && __s2) {
        MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
      }
      if (v53 >= 0x41 && __src) {
        MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
      }
      uint64_t v34 = (char *)*((void *)v1 + 1);
      if (v34)
      {
        do
        {
          uint64_t v35 = v34;
          uint64_t v34 = *(char **)v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          uint64_t v35 = (char *)*((void *)v1 + 2);
          BOOL v36 = *(void *)v35 == (void)v1;
          uint64_t v1 = v35;
        }
        while (!v36);
      }
      uint64_t v1 = v35;
    }
    while (v35 != v2);
  }
  return v4 & 1;
}

uint64_t llvm::Float2IntPass::cleanup(uint64_t this)
{
  if (*(void *)(this + 264) != *(void *)(this + 256)) {
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
  return this;
}

uint64_t sub_1CCD511E4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF1A50;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263DD38;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 80) = 1;
  int64x2_t v2 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 88) = v2;
  *(int64x2_t *)(a1 + 104) = v2;
  *(int64x2_t *)(a1 + 120) = v2;
  *(int64x2_t *)(a1 + 136) = v2;
  *(void *)(a1 + 152) = a1 + 168;
  *(void *)(a1 + 160) = 0x800000000;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = a1 + 240;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF1A58, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CCD4F62C;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCF1A58, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCD512FC()
{
}

void sub_1CCD51338(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F263DD38;
  sub_1CD719D3C((uint64_t)a1 + 32);

  llvm::Pass::~Pass(a1);
}

void sub_1CCD5138C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F263DD38;
  sub_1CD719D3C((uint64_t)a1 + 32);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD513F4(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);

  sub_1CB843600(a2, v3, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

uint64_t sub_1CCD51480(void *a1, llvm::LLVMContextImpl ****a2)
{
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, a2)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_6:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_6;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (const llvm::DominatorTree *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::DominatorTreeWrapperPass::ID)+ 32);

  return llvm::Float2IntPass::runImpl((llvm::Float2IntPass *)(a1 + 4), (llvm::Function *)a2, v9);
}

char *sub_1CCD51540(char **a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  char v4 = a1[1];
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x666666666666666) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - v3) >> 3) > v6) {
    unint64_t v6 = 0x999999999999999ALL * ((a1[2] - v3) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3) >= 0x333333333333333) {
    unint64_t v6 = 0x666666666666666;
  }
  if (v6 > 0x666666666666666) {
    sub_1CB833614();
  }
  uint64_t v10 = 5 * v6;
  uint64_t v11 = (char *)operator new(40 * v6);
  uint64_t v12 = *a2;
  uint64_t v13 = &v11[40 * v5];
  uint64_t v14 = &v11[8 * v10];
  *((_DWORD *)v13 + 4) = *((_DWORD *)a3 + 2);
  uint64_t v15 = *a3;
  *(void *)uint64_t v13 = v12;
  *((void *)v13 + 1) = v15;
  *((_DWORD *)a3 + 2) = 0;
  *((_DWORD *)v13 + 8) = *((_DWORD *)a3 + 6);
  *((void *)v13 + 3) = a3[2];
  *((_DWORD *)a3 + 6) = 0;
  unsigned int v16 = v13 + 40;
  if (v4 == v3)
  {
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
  }
  else
  {
    uint64_t v17 = 0;
    do
    {
      unsigned int v18 = &v13[v17];
      int v19 = &v4[v17];
      *((void *)v18 - 5) = *(void *)&v4[v17 - 40];
      *((_DWORD *)v18 - 6) = *(_DWORD *)&v4[v17 - 24];
      *((void *)v18 - 4) = *(void *)&v4[v17 - 32];
      *((_DWORD *)v19 - 6) = 0;
      *((_DWORD *)v18 - 2) = *(_DWORD *)&v4[v17 - 8];
      *((void *)v18 - 2) = *(void *)&v4[v17 - 16];
      *((_DWORD *)v19 - 2) = 0;
      v17 -= 40;
    }
    while (&v4[v17] != v3);
    *a1 = &v13[v17];
    a1[1] = v16;
    a1[2] = v14;
    do
    {
      if (*((_DWORD *)v4 - 2) >= 0x41u)
      {
        uint64_t v20 = *((void *)v4 - 2);
        if (v20) {
          MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
        }
      }
      if (*((_DWORD *)v4 - 6) >= 0x41u)
      {
        uint64_t v21 = *((void *)v4 - 4);
        if (v21) {
          MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
        }
      }
      v4 -= 40;
    }
    while (v4 != v3);
  }
  if (v3) {
    operator delete(v3);
  }
  return v16;
}

uint64_t sub_1CCD51710(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_8;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

uint64_t sub_1CCD517BC()
{
  int v4 = &v3;
  int v2 = 1;
  int v3 = 64;
  *(void *)&long long v1 = "Max integer bitwidth to consider in float2int(default=64)";
  *((void *)&v1 + 1) = 57;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCF1990, "float2int-max-integer-bw", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCF1990, &dword_1CB82C000);
}

llvm *sub_1CCD51848(llvm::Value **a1)
{
  int v2 = llvm::dbgs((llvm *)a1);
  int v3 = v2;
  uint64_t v4 = *((void *)v2 + 4);
  if ((unint64_t)(*((void *)v2 + 3) - v4) > 5)
  {
    *(_WORD *)(v4 + 4) = 8250;
    *(_DWORD *)uint64_t v4 = 1702060354;
    *((void *)v2 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v2, "Base: ", 6uLL);
  }
  llvm::Value::printAsOperand(*a1, v3, 0, 0);
  uint64_t v5 = *((void *)v3 + 4);
  if ((unint64_t)(*((void *)v3 + 3) - v5) > 8)
  {
    *(unsigned char *)(v5 + 8) = 32;
    *(void *)uint64_t v5 = *(void *)" Offset: ";
    *((void *)v3 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(v3, " Offset: ", 9uLL);
  }
  llvm::Value::printAsOperand(a1[1], v3, 0, 0);
  uint64_t v6 = *((void *)v3 + 4);
  if ((unint64_t)(*((void *)v3 + 3) - v6) > 8)
  {
    *(unsigned char *)(v6 + 8) = 32;
    *(void *)uint64_t v6 = *(void *)" Length: ";
    *((void *)v3 + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(v3, " Length: ", 9uLL);
  }
  uint64_t v7 = (llvm *)llvm::Value::printAsOperand(a1[2], v3, 0, 0);
  uint64_t result = llvm::dbgs(v7);
  uint64_t v9 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v9)
  {
    return llvm::raw_ostream::write(result, "\n", 1uLL);
  }
  else
  {
    *uint64_t v9 = 10;
    ++*((void *)result + 4);
  }
  return result;
}

void llvm::GuardWideningPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

{
  uint64_t v0;

  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
}

uint64_t sub_1CCD51D6C(uint64_t a1)
{
  v119[0] = 0;
  v119[1] = 0;
  unsigned int v120 = 0;
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v111 = v115;
  unint64_t v112 = v115;
  int v114 = 0;
  uint64_t v113 = 0x100000008;
  v115[0] = v2;
  int v3 = (char *)operator new(0x18uLL);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  int v6 = 0;
  *(void *)int v3 = v2;
  v3[8] = 0;
  uint64_t v7 = v3 + 24;
  unsigned char v3[16] = 0;
  unint64_t v117 = v3 + 24;
  unint64_t v118 = v3 + 24;
  long long __p = v3;
  uint64_t v107 = 0;
  unint64_t v108 = 0;
  memset(v106, 0, sizeof(v106));
  int v103 = (char *)v106 + 8;
  int v104 = (char *)v106 + 8;
  int v94 = (uint64_t *)(a1 + 216);
  uint64_t v105 = 8;
  unint64_t v109 = 0;
  uint64_t v110 = 0;
  while (1)
  {
    if (v7 - v3 != v5 - v4) {
      goto LABEL_16;
    }
    if (v3 == v7) {
      break;
    }
    uint64_t v8 = v4 + 8;
    uint64_t v9 = v3 + 8;
    while (1)
    {
      int v10 = v9 - 8;
      if (*((void *)v9 - 1) != *((void *)v8 - 1)) {
        break;
      }
      int v11 = v8[8];
      if (v9[8]) {
        BOOL v12 = v11 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        if ((v9[8] == 0) == (v11 != 0)) {
          break;
        }
      }
      else if (*(void *)v9 != *(void *)v8)
      {
        break;
      }
      v8 += 24;
      v9 += 24;
      if (v10 + 24 == v7) {
        goto LABEL_126;
      }
    }
LABEL_16:
    unsigned int v13 = (llvm::Value *)**((void **)v7 - 3);
    BOOL v102 = v13;
    unint64_t v122 = v13;
    uint64_t v14 = *(void *)(a1 + 64);
    if (!v14)
    {
LABEL_156:
      sub_1CB920400();
      return llvm::GuardWideningPass::run();
    }
    if ((*(unsigned int (**)(uint64_t, llvm::Value **))(*(void *)v14 + 48))(v14, &v122))
    {
      unsigned int v16 = sub_1CD641974((uint64_t)v119, (uint64_t *)&v102);
      uint64_t v17 = (void *)((char *)v13 + 40);
      for (uint64_t i = (void *)*((void *)v13 + 6); i != v17; uint64_t i = (void *)i[1])
      {
        if (i) {
          int v19 = i - 3;
        }
        else {
          int v19 = 0;
        }
        if (i
          && *((unsigned char *)v19 + 16) == 84
          && (uint64_t v21 = *(v19 - 4)) != 0
          && !*(unsigned char *)(v21 + 16)
          && *(void *)(v21 + 24) == v19[9]
          && *(_DWORD *)(v21 + 36) == 125
          || byte_1EBCF1AE0 && llvm::isGuardAsWidenableBranch((llvm *)v19, v15))
        {
          unint64_t v20 = *((unsigned int *)v16 + 4);
          if (v20 >= *((unsigned int *)v16 + 5)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(v16[1] + 8 * v20) = v19;
          ++*((_DWORD *)v16 + 4);
        }
      }
      uint64_t v22 = *((unsigned int *)v16 + 4);
      if (v22)
      {
        int v23 = (uint64_t *)v16[1];
        int v24 = &v23[v22];
        int v93 = v24;
        while (1)
        {
          uint64_t v25 = *v23;
          if (*((unsigned char *)sub_1CCD52E20(*v23) + 16) != 16) {
            break;
          }
          LODWORD(v26) = 0;
LABEL_107:
          v6 |= v26;
          if (++v23 == v24) {
            goto LABEL_18;
          }
        }
        char v121 = 0;
        uint64_t v26 = -1431655765 * ((unint64_t)(v117 - (unsigned char *)__p) >> 3);
        uint64_t v101 = v26;
        if (!v26) {
          goto LABEL_107;
        }
        uint64_t v95 = v23;
        uint64_t v27 = 0;
        int v28 = 0;
        int v96 = v6;
        unsigned int v97 = v120 - 1;
        uint64_t v98 = v119[0];
        unsigned int v99 = v120;
        uint64_t v100 = v119[0] + 88 * v120;
        while (2)
        {
          BOOL v29 = (llvm::Value *)**((void **)__p + 3 * v27);
          unint64_t v122 = v29;
          uint64_t v30 = *(void *)(a1 + 64);
          if (!v30) {
            goto LABEL_156;
          }
          if (!(*(unsigned int (**)(uint64_t, llvm::Value **))(*(void *)v30 + 48))(v30, &v122)) {
            goto LABEL_105;
          }
          uint64_t v31 = v100;
          if (v99)
          {
            unsigned int v32 = v97 & ((v29 >> 4) ^ (v29 >> 9));
            uint64_t v31 = v98 + 88 * v32;
            int v33 = *(llvm::Value **)v31;
            if (*(llvm::Value **)v31 != v29)
            {
              int v67 = 1;
              while (v33 != (llvm::Value *)-4096)
              {
                unsigned int v68 = v32 + v67++;
                unsigned int v32 = v68 & v97;
                uint64_t v31 = v98 + 88 * v32;
                int v33 = *(llvm::Value **)v31;
                if (*(llvm::Value **)v31 == v29) {
                  goto LABEL_47;
                }
              }
              uint64_t v31 = v100;
            }
          }
LABEL_47:
          uint64_t v34 = *(void ***)(v31 + 8);
          uint64_t v35 = *(unsigned int *)(v31 + 16);
          if (*(llvm::Value **)(v25 + 40) != v29)
          {
            if (*(_DWORD *)(v31 + 16)) {
              goto LABEL_56;
            }
LABEL_98:
            if (++v27 == v101)
            {
LABEL_105:
              if (v28)
              {
                long long v69 = v121;
                long long v70 = sub_1CCD52E20(v25);
                unint64_t v122 = 0;
                long long v71 = sub_1CCD52E20((uint64_t)v69);
                sub_1CCD534B4((llvm::DominatorTree **)a1, (uint64_t)v71, (uint64_t)v70, v69, &v122);
                if (llvm::isGuardAsWidenableBranch(v69, v72)) {
                  llvm::setWidenableBranchCond((llvm::Instruction **)v69, v122, v73);
                }
                else {
                  sub_1CCD52FC8((uint64_t)v69, (uint64_t)v122);
                }
                uint64_t v75 = **(uint64_t ***)v25;
                uint64_t v76 = *v75;
                uint64_t v77 = *(void **)(*v75 + 1560);
                int v24 = v93;
                if (!v77)
                {
                  int v79 = *(llvm::ConstantInt **)(v76 + 1888);
                  unsigned int v80 = *(_DWORD *)(v76 + 1896);
                  LODWORD(v123) = v80 >> 8;
                  if (v80 >> 8 > 0x40) {
                    operator new[]();
                  }
                  if (v80 <= 0xFF) {
                    char v81 = 0;
                  }
                  else {
                    char v81 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v80) + 63);
                  }
                  unint64_t v122 = (llvm::Value *)(v81 & 1);
                  uint64_t v77 = llvm::ConstantInt::get(v79, (llvm::LLVMContext *)&v122, v74);
                  if (v123 >= 0x41 && v122) {
                    MEMORY[0x1D25D9CB0](v122, 0x1000C8000313F17);
                  }
                  *(void *)(v76 + 1560) = v77;
                }
                sub_1CCD52FC8(v25, (uint64_t)v77);
                unint64_t v78 = *(unsigned int *)(a1 + 80);
                if (v78 >= *(unsigned int *)(a1 + 84)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                int v6 = v96;
                int v23 = v95;
                *(void *)(*(void *)(a1 + 72) + 8 * v78) = v25;
                ++*(_DWORD *)(a1 + 80);
                sub_1CD50F67C((uint64_t)v94, &v121, (uint64_t)&v122);
                LODWORD(v26) = 1;
              }
              else
              {
                LODWORD(v26) = 0;
                int v6 = v96;
                int v23 = v95;
                int v24 = v93;
              }
              goto LABEL_107;
            }
            continue;
          }
          break;
        }
        BOOL v36 = *(void **)(v31 + 8);
        if (v35)
        {
          uint64_t v37 = 8 * v35;
          BOOL v36 = v34;
          int64_t v38 = &v34[v35];
          while (*v36 != v25)
          {
            ++v36;
            v37 -= 8;
            if (!v37)
            {
              BOOL v36 = v38;
              break;
            }
          }
        }
        uint64_t v35 = (void **)v36 - v34;
        if (!v35) {
          goto LABEL_98;
        }
LABEL_56:
        unint64_t v39 = &v34[v35];
        while (2)
        {
          unsigned int v40 = (const llvm::Instruction *)*v34;
          int v41 = *(uint64_t **)(a1 + 16);
          int v42 = *((_DWORD *)v41 + 4);
          if (!v42)
          {
            unsigned int v50 = 0;
            goto LABEL_76;
          }
          uint64_t v43 = *(void *)(v25 + 40);
          uint64_t v44 = *v41;
          unsigned int v45 = v42 - 1;
          uint64_t v46 = ((v43 >> 4) ^ (v43 >> 9)) & v45;
          uint64_t v47 = *(void *)(v44 + 16 * v46);
          if (v43 == v47)
          {
LABEL_62:
            unsigned int v50 = *(void **)(v44 + 16 * v46 + 8);
          }
          else
          {
            int v48 = 1;
            while (v47 != -4096)
            {
              int v49 = v46 + v48++;
              uint64_t v46 = v49 & v45;
              uint64_t v47 = *(void *)(v44 + 16 * v46);
              if (v43 == v47) {
                goto LABEL_62;
              }
            }
            unsigned int v50 = 0;
          }
          uint64_t v51 = *((void *)v40 + 5);
          uint64_t v52 = ((v51 >> 4) ^ (v51 >> 9)) & v45;
          uint64_t v53 = *(void *)(v44 + 16 * v52);
          if (v51 == v53)
          {
LABEL_68:
            unsigned int v56 = *(void **)(v44 + 16 * v52 + 8);
            BOOL v57 = v56 == v50;
            if (v56 == v50 || v56 == 0) {
              goto LABEL_77;
            }
            while (v50)
            {
              BOOL v57 = 0;
              unsigned int v50 = (void *)*v50;
              if (v50 == v56) {
                goto LABEL_77;
              }
            }
          }
          else
          {
            int v54 = 1;
            while (v53 != -4096)
            {
              int v55 = v52 + v54++;
              uint64_t v52 = v55 & v45;
              uint64_t v53 = *(void *)(v44 + 16 * v52);
              if (v51 == v53) {
                goto LABEL_68;
              }
            }
LABEL_76:
            BOOL v57 = v50 == 0;
LABEL_77:
            uint64_t v59 = sub_1CCD52E20(v25);
            unint64_t v122 = (llvm::Value *)v126;
            uint64_t v123 = (llvm::Value *)v126;
            uint64_t v124 = 8;
            int v125 = 0;
            int v60 = sub_1CCD530A8((llvm::DominatorTree **)a1, (uint64_t)v59, v40, (uint64_t *)&v122);
            if (v123 != v122) {
              free(v123);
            }
            if (v60)
            {
              unint64_t v61 = sub_1CCD52E20(v25);
              unsigned int v62 = sub_1CCD52E20((uint64_t)v40);
              unint64_t v122 = 0;
              if (sub_1CCD534B4((llvm::DominatorTree **)a1, (uint64_t)v61, (uint64_t)v62, 0, &v122))
              {
                if (v57) {
                  LODWORD(v64) = 2;
                }
                else {
                  LODWORD(v64) = 3;
                }
              }
              else if (v57)
              {
                unsigned int v65 = (llvm::BasicBlock *)*((void *)v40 + 5);
                unsigned int v66 = *(llvm::BasicBlock **)(v25 + 40);
                if (llvm::isGuardAsWidenableBranch(v40, v63)) {
                  unsigned int v65 = (llvm::BasicBlock *)*((void *)v40 - 4);
                }
                if (v66 == v65 || v66 == (llvm::BasicBlock *)llvm::BasicBlock::getUniqueSuccessor(v65))
                {
                  LODWORD(v64) = 1;
                }
                else
                {
                  uint64_t v64 = *(void *)(a1 + 8);
                  if (v64) {
                    llvm::DominatorTreeBase<llvm::BasicBlock,true>::dominates();
                  }
                }
              }
              else
              {
                LODWORD(v64) = 2;
              }
LABEL_85:
              if ((int)v64 > v28)
              {
                char v121 = v40;
                int v28 = v64;
              }
              if (++v34 == v39) {
                goto LABEL_98;
              }
              continue;
            }
          }
          break;
        }
        LODWORD(v64) = 0;
        goto LABEL_85;
      }
    }
LABEL_18:
    sub_1CBFE66A8((llvm::SmallPtrSetImplBase *)&v111);
    int v3 = (char *)__p;
    uint64_t v7 = v117;
    uint64_t v4 = v108;
    uint64_t v5 = v109;
  }
LABEL_126:
  if (v4)
  {
    unint64_t v109 = v4;
    operator delete(v4);
  }
  if (v104 != v103) {
    free(v104);
  }
  if (__p)
  {
    unint64_t v117 = (char *)__p;
    operator delete(__p);
  }
  if (v112 != v111) {
    free(v112);
  }
  uint64_t v82 = *(unsigned int *)(a1 + 80);
  if (v82)
  {
    uint64_t v83 = *(void **)(a1 + 72);
    uint64_t v84 = &v83[v82];
    do
    {
      int v85 = (void *)*v83;
      unint64_t v111 = (void *)*v83;
      int v103 = 0;
      if ((sub_1CD50F704(v94, &v111, &v103) & 1) == 0
        && (v85
         && *((unsigned char *)v85 + 16) == 84
         && (uint64_t v87 = *(v85 - 4)) != 0
         && !*(unsigned char *)(v87 + 16)
         && *(void *)(v87 + 24) == v85[9]
         && *(_DWORD *)(v87 + 36) == 125
         || byte_1EBCF1AE0 && llvm::isGuardAsWidenableBranch((llvm *)v85, v86)))
      {
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      ++v83;
    }
    while (v83 != v84);
  }
  uint64_t v88 = v119[0];
  if (v120)
  {
    uint64_t v89 = 88 * v120;
    uint64_t v90 = v119[0] + 24;
    do
    {
      if ((*(void *)(v90 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v91 = *(void **)(v90 - 16);
        if ((void *)v90 != v91) {
          free(v91);
        }
      }
      v90 += 88;
      v89 -= 88;
    }
    while (v89);
  }
  MEMORY[0x1D25D9CD0](v88, 8);
  return v6 & 1;
}

void sub_1CCD52B60(uint64_t a1)
{
}

void sub_1CCD52C10(uint64_t a1)
{
}

uint64_t sub_1CCD52CC0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF1B20;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263DDD8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF1B28, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD52B60;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF1B28, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD52D70(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF1B21;
  *(_DWORD *)(a1 + 24) = 1;
  *(void *)a1 = &unk_1F263DEC0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF1B30, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD52C10;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF1B30, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void *sub_1CCD52E20(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) == 84)
  {
    uint64_t v2 = *(void *)(a1 - 32);
    if (v2)
    {
      if (!*(unsigned char *)(v2 + 16) && *(void *)(v2 + 24) == *(void *)(a1 + 72) && (*(unsigned char *)(v2 + 33) & 0x20) != 0)
      {
        uint64_t v6 = a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF);
        return *(void **)v6;
      }
    }
  }
  unsigned int v13 = 0;
  uint64_t v15 = 0;
  if (!llvm::parseWidenableBranch(a1, &v15, &v14, &v13, &v12)) {
    return *(void **)(a1 - 96);
  }
  uint64_t v6 = v15;
  if (v15) {
    return *(void **)v6;
  }
  uint64_t v7 = **v13;
  uint64_t v8 = *v7;
  uint64_t v4 = *(void **)(*v7 + 1560);
  if (!v4)
  {
    uint64_t v9 = *(llvm::ConstantInt **)(v8 + 1888);
    unsigned int v10 = *(_DWORD *)(v8 + 1896);
    unsigned int v17 = v10 >> 8;
    if (v10 >> 8 > 0x40) {
      operator new[]();
    }
    if (v10 <= 0xFF) {
      LOBYTE(v11) = 0;
    }
    else {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v10) + 63);
    }
    unint64_t v16 = v11 & 1;
    uint64_t v4 = llvm::ConstantInt::get(v9, (llvm::LLVMContext *)&v16, v3);
    if (v17 >= 0x41 && v16) {
      MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
    }
    *(void *)(v8 + 1560) = v4;
  }
  return v4;
}

uint64_t sub_1CCD52FC8(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 16) == 84
    && (uint64_t v2 = *(void *)(result - 32)) != 0
    && !*(unsigned char *)(v2 + 16)
    && *(void *)(v2 + 24) == *(void *)(result + 72)
    && (*(unsigned char *)(v2 + 33) & 0x20) != 0)
  {
    uint64_t v8 = *(_DWORD *)(result + 20) & 0x7FFFFFF;
    uint64_t v9 = -v8;
    int v3 = (void *)(result - 32 * v8);
    if (*v3)
    {
      uint64_t v10 = result + 32 * v9;
      uint64_t v12 = *(void **)(v10 + 16);
      unint64_t v11 = (void *)(v10 + 16);
      *uint64_t v12 = *(v11 - 1);
      uint64_t v13 = *(v11 - 1);
      if (v13) {
        *(void *)(v13 + 16) = *v11;
      }
    }
    *int v3 = a2;
    if (a2)
    {
      uint64_t v15 = *(void *)(a2 + 8);
      uint64_t v5 = (void *)(a2 + 8);
      uint64_t v14 = v15;
      uint64_t v16 = result + 32 * v9;
      *(void *)(v16 + 8) = v15;
      if (v15) {
        *(void *)(v14 + 16) = v16 + 8;
      }
      *(void *)(v16 + 16) = v5;
      goto LABEL_13;
    }
  }
  else
  {
    int v3 = (void *)(result - 96);
    if (*(void *)(result - 96))
    {
      **(void **)(result - 80) = *(void *)(result - 88);
      uint64_t v4 = *(void *)(result - 88);
      if (v4) {
        *(void *)(v4 + 16) = *(void *)(result - 80);
      }
    }
    *int v3 = a2;
    if (a2)
    {
      uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v5 = (void *)(a2 + 8);
      uint64_t v6 = v7;
      *(void *)(result - 88) = v7;
      if (v7) {
        *(void *)(v6 + 16) = result - 88;
      }
      *(void *)(result - 80) = v5;
LABEL_13:
      *uint64_t v5 = v3;
    }
  }
  return result;
}

uint64_t sub_1CCD530A8(llvm::DominatorTree **a1, uint64_t a2, const llvm::Instruction *a3, uint64_t *a4)
{
  uint64_t result = 1;
  if (!a2 || *(unsigned __int8 *)(a2 + 16) < 0x1Cu) {
    return result;
  }
  if (llvm::DominatorTree::dominates(*a1, (const llvm::Value *)a2, a3)) {
    return 1;
  }
  uint64_t v10 = *a4;
  uint64_t v9 = a4[1];
  if (v9 == *a4)
  {
    uint64_t v11 = *((unsigned int *)a4 + 5);
    uint64_t v12 = (void *)(v9 + 8 * v11);
    if (v11)
    {
      uint64_t v13 = 0;
      while (*(void *)(v9 + v13) != a2)
      {
        v13 += 8;
        if (8 * v11 == v13) {
          goto LABEL_22;
        }
      }
      uint64_t v12 = (void *)(v9 + v13);
    }
LABEL_22:
    uint64_t v10 = a4[1];
  }
  else
  {
    uint64_t v14 = *((unsigned int *)a4 + 4);
    int v15 = v14 - 1;
    unsigned int v16 = (v14 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v12 = (void *)(v9 + 8 * v16);
    uint64_t v17 = *v12;
    if (*v12 == -1)
    {
      unsigned int v18 = 0;
LABEL_24:
      if (v18) {
        uint64_t v12 = v18;
      }
      if (*v12 != a2)
      {
        LODWORD(v11) = *((_DWORD *)a4 + 5);
        uint64_t v12 = (void *)(v9 + 8 * v14);
        goto LABEL_29;
      }
    }
    else
    {
      unsigned int v18 = 0;
      int v19 = 1;
      while (v17 != a2)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == -2;
        }
        if (v20) {
          unsigned int v18 = v12;
        }
        unsigned int v21 = v16 + v19++;
        unsigned int v16 = v21 & v15;
        uint64_t v12 = (void *)(v9 + 8 * (v21 & v15));
        uint64_t v17 = *v12;
        if (*v12 == -1) {
          goto LABEL_24;
        }
      }
    }
    LODWORD(v11) = *((_DWORD *)a4 + 5);
  }
LABEL_29:
  if (v9 == v10) {
    unsigned int v22 = v11;
  }
  else {
    unsigned int v22 = *((_DWORD *)a4 + 4);
  }
  if (v12 != (void *)(v9 + 8 * v22)) {
    return 1;
  }
  uint64_t result = llvm::isSafeToSpeculativelyExecute(a2, (uint64_t *)a3, (unsigned __int8 *)*a1, 0);
  if (result)
  {
    uint64_t v23 = *(unsigned __int8 *)(a2 + 16) - 33;
    if (v23 > 0x37) {
      goto LABEL_40;
    }
    if (((1 << (*(unsigned char *)(a2 + 16) - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (*(unsigned char *)(a2 + 16) - 33)) & 0x808001C8000010) != 0
        || v23 == 28 && (*(_WORD *)(a2 + 18) & 0x301) != 0)
      {
        return 0;
      }
      goto LABEL_40;
    }
    uint64_t v38 = *(void *)(a2 + 64);
    if (v38 && ((*(unsigned char *)(v38 + 20) & 4) != 0 || (*(unsigned char *)(v38 + 17) & 0x10) != 0)) {
      goto LABEL_40;
    }
    __int32 v47 = 7;
    if (sub_1CC5CB59C(a2, &v47, 1uLL))
    {
      uint64_t v46 = *(void *)(a2 - 32);
      if (!v46 || *(unsigned char *)(v46 + 16) || *(void *)(v46 + 24) != *(void *)(a2 + 72) || *(_DWORD *)(v46 + 36) != 7) {
        return 0;
      }
    }
    if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 66) & 1) != 0
      || (uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44), result))
    {
LABEL_40:
      uint64_t v24 = a4[1];
      uint64_t v25 = *((unsigned int *)a4 + 5);
      if (v24 == *a4)
      {
        if (v25)
        {
          uint64_t v26 = 0;
          uint64_t v27 = 8 * v25;
          int v28 = (uint64_t *)a4[1];
          while (*v28 != a2)
          {
            if (*v28 == -2) {
              uint64_t v26 = v28;
            }
            ++v28;
            v27 -= 8;
            if (!v27)
            {
              if (!v26) {
                goto LABEL_48;
              }
              uint64_t *v26 = a2;
              --*((_DWORD *)a4 + 6);
              break;
            }
          }
LABEL_79:
          int v40 = *(_DWORD *)(a2 + 20);
          if ((v40 & 0x40000000) != 0)
          {
            int v42 = *(uint64_t **)(a2 - 8);
            uint64_t v41 = v40 & 0x7FFFFFF;
          }
          else
          {
            uint64_t v41 = v40 & 0x7FFFFFF;
            int v42 = (uint64_t *)(a2 - 32 * v41);
          }
          if (v41)
          {
            uint64_t v43 = 32 * v41 - 32;
            do
            {
              uint64_t v44 = *v42;
              v42 += 4;
              uint64_t result = sub_1CCD530A8(a1, v44, a3, a4);
              if (result) {
                BOOL v45 = v43 == 0;
              }
              else {
                BOOL v45 = 1;
              }
              v43 -= 32;
            }
            while (!v45);
            return result;
          }
          return 1;
        }
LABEL_48:
        unsigned int v29 = *((_DWORD *)a4 + 4);
        if (v25 < v29)
        {
          *((_DWORD *)a4 + 5) = v25 + 1;
          *(void *)(v24 + 8 * v25) = a2;
          goto LABEL_79;
        }
      }
      else
      {
        unsigned int v29 = *((_DWORD *)a4 + 4);
      }
      if (3 * v29 <= 4 * ((int)v25 - *((_DWORD *)a4 + 6)))
      {
        if (v29 >= 0x40) {
          v29 *= 2;
        }
        else {
          unsigned int v29 = 128;
        }
      }
      else if (v29 - v25 >= v29 >> 3)
      {
        goto LABEL_53;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a4, v29);
      unsigned int v29 = *((_DWORD *)a4 + 4);
      uint64_t v24 = a4[1];
LABEL_53:
      unsigned int v30 = v29 - 1;
      unsigned int v31 = (v29 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unsigned int v32 = (uint64_t *)(v24 + 8 * v31);
      uint64_t v33 = *v32;
      if (*v32 == -1)
      {
        uint64_t v34 = 0;
LABEL_72:
        if (v34) {
          unint64_t v39 = v34;
        }
        else {
          unint64_t v39 = v32;
        }
        if (*v39 != a2)
        {
          if (*v39 == -2) {
            --*((_DWORD *)a4 + 6);
          }
          else {
            ++*((_DWORD *)a4 + 5);
          }
          uint64_t *v39 = a2;
        }
      }
      else
      {
        uint64_t v34 = 0;
        int v35 = 1;
        while (v33 != a2)
        {
          if (v34) {
            BOOL v36 = 0;
          }
          else {
            BOOL v36 = v33 == -2;
          }
          if (v36) {
            uint64_t v34 = v32;
          }
          unsigned int v37 = v31 + v35++;
          unsigned int v31 = v37 & v30;
          unsigned int v32 = (uint64_t *)(v24 + 8 * (v37 & v30));
          uint64_t v33 = *v32;
          if (*v32 == -1) {
            goto LABEL_72;
          }
        }
      }
      goto LABEL_79;
    }
  }
  return result;
}

uint64_t sub_1CCD534B4(llvm::DominatorTree **a1, uint64_t a2, uint64_t a3, const llvm::Instruction *a4, llvm::Value **a5)
{
  uint64_t v5 = (uint64_t *)a5;
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v8 = (llvm::ConstantInt ***)a2;
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*(unsigned char *)(a2 + 16) == 81)
    {
      uint64_t v9 = *(void **)(a2 - 64);
      if (v9)
      {
        uint64_t v10 = *(void *)(a2 - 32);
        if (v10)
        {
          if (*(unsigned char *)(v10 + 16) == 16)
          {
            if (a3)
            {
              if (*(unsigned char *)(a3 + 16) == 81 && v9 == *(void **)(a3 - 64))
              {
                uint64_t v54 = *(void *)(a3 - 32);
                if (v54)
                {
                  if (*(unsigned char *)(v54 + 16) == 16)
                  {
                    uint64_t v55 = *(_WORD *)(a3 + 18) & 0x3F;
                    llvm::ConstantRange::makeExactICmpRegion(*(_WORD *)(a2 + 18) & 0x3F, v10 + 24, (uint64_t)&v100);
                    llvm::ConstantRange::makeExactICmpRegion(v55, v54 + 24, (uint64_t)&v90);
                    llvm::ConstantRange::exactIntersectWith((llvm::ConstantRange *)&v100, (const llvm::ConstantRange *)&v90, (uint64_t)&v95);
                    if ((_BYTE)v99)
                    {
                      unsigned int v89 = 1;
                      uint64_t v88 = 0;
                      int v87 = 0;
                      if (llvm::ConstantRange::getEquivalentICmp((llvm::ConstantRange *)&v95, &v87, (unsigned int *)&v88))
                      {
                        if (v6)
                        {
                          unsigned int v56 = llvm::ConstantInt::get(**v8, (llvm::LLVMContext *)&v88, (const llvm::APInt *)a3);
                          BOOL v57 = operator new(0x80uLL);
                          unsigned int v58 = (llvm::Value *)(v57 + 16);
                          v57[21] = v57[21] & 0x38000000 | 2;
                          *(void *)BOOL v57 = 0;
                          *((void *)v57 + 1) = 0;
                          *((void *)v57 + 2) = 0;
                          *((void *)v57 + 3) = v57 + 16;
                          *((void *)v57 + 4) = 0;
                          *((void *)v57 + 5) = 0;
                          *((void *)v57 + 6) = 0;
                          *((void *)v57 + 7) = v57 + 16;
                          __int16 v59 = v87;
                          int v92 = "wide.chk";
                          v94[8] = 259;
                          int v60 = (void **)*v9;
                          uint64_t v61 = **(void **)*v9 + 1888;
                          if (*v9 && (v60[1] & 0xFE) == 0x12)
                          {
                            unint64_t v78 = (uint64_t **)(**(void **)*v9 + 1888);
                            int v79 = (llvm::Type *)*((unsigned int *)v60 + 8);
                            if (*((_DWORD *)v60 + 2) == 19) {
                              llvm::ScalableVectorType::get(v78, v79);
                            }
                            else {
                              llvm::FixedVectorType::get((llvm::FixedVectorType *)v78, v79);
                            }
                            uint64_t v61 = v80;
                            uint64_t v6 = a4;
                          }
                          llvm::CmpInst::CmpInst(v58, v61, 53, v59, (uint64_t)v9, (uint64_t)v56, (const char **)&v92, (uint64_t)v6, 0);
                          *a5 = v58;
                        }
                        if (v89 >= 0x41 && v88) {
                          MEMORY[0x1D25D9CB0](v88, 0x1000C8000313F17);
                        }
                        if ((_BYTE)v99)
                        {
                          if (v98 >= 0x41 && v97) {
                            MEMORY[0x1D25D9CB0](v97, 0x1000C8000313F17);
                          }
                          if (v96 >= 0x41 && v95) {
                            MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
                          }
                        }
                        if (DWORD2(v91) >= 0x41 && (void)v91) {
                          MEMORY[0x1D25D9CB0](v91, 0x1000C8000313F17);
                        }
                        if (DWORD2(v90) >= 0x41 && (void)v90) {
                          MEMORY[0x1D25D9CB0](v90, 0x1000C8000313F17);
                        }
                        if (v103 >= 0x41 && v102) {
                          MEMORY[0x1D25D9CB0](v102, 0x1000C8000313F17);
                        }
                        if (v101 >= 0x41 && v100) {
                          MEMORY[0x1D25D9CB0](v100, 0x1000C8000313F17);
                        }
                        return 1;
                      }
                      if (v89 >= 0x41 && v88) {
                        MEMORY[0x1D25D9CB0](v88, 0x1000C8000313F17);
                      }
                      if ((_BYTE)v99)
                      {
                        if (v98 >= 0x41 && v97) {
                          MEMORY[0x1D25D9CB0](v97, 0x1000C8000313F17);
                        }
                        if (v96 >= 0x41 && v95) {
                          MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
                        }
                      }
                    }
                    if (DWORD2(v91) >= 0x41 && (void)v91) {
                      MEMORY[0x1D25D9CB0](v91, 0x1000C8000313F17);
                    }
                    if (DWORD2(v90) >= 0x41 && (void)v90) {
                      MEMORY[0x1D25D9CB0](v90, 0x1000C8000313F17);
                    }
                    if (v103 >= 0x41 && v102) {
                      MEMORY[0x1D25D9CB0](v102, 0x1000C8000313F17);
                    }
                    if (v101 >= 0x41 && v100) {
                      MEMORY[0x1D25D9CB0](v100, 0x1000C8000313F17);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  uint64_t v95 = (char *)&v97;
  uint64_t v96 = 0x400000000;
  int v92 = v94;
  uint64_t v93 = 0x400000000;
  if (!sub_1CCD54308((uint64_t)v8, (llvm::Type *)&v95, (const llvm::APFloat *)a3)
    || !sub_1CCD54308(v7, (llvm::Type *)&v95, v11))
  {
    int v48 = 1;
    goto LABEL_104;
  }
  uint64_t v81 = v7;
  uint64_t v82 = v8;
  uint64_t v83 = v96;
  if (v96)
  {
    uint64_t v12 = v96;
    do
    {
      uint64_t v13 = v95;
      uint64_t v14 = *(void *)v95;
      uint64_t v15 = *((void *)v95 + 2);
      uint64_t v100 = (char *)&v102;
      uint64_t v101 = 0x300000000;
      uint64_t v16 = 32 * v12;
      do
      {
        if (*(void *)v13 == v14 && *((void *)v13 + 2) == v15) {
          sub_1CB8BBE7C((unint64_t *)&v100, (unint64_t)v13);
        }
        v13 += 32;
        v16 -= 32;
      }
      while (v16);
      uint64_t v17 = v95;
      if (v96)
      {
        uint64_t v18 = 0;
        uint64_t v19 = 32 * v96 - 32;
        while (1)
        {
          if (*(void *)&v95[v18] == v14)
          {
            BOOL v20 = &v95[v18];
            if (*(void *)&v95[v18 + 16] == v15) {
              break;
            }
          }
          v18 += 32;
          v19 -= 32;
          if (32 * v96 == v18)
          {
            BOOL v20 = &v95[32 * v96];
            goto LABEL_32;
          }
        }
        if (32 * v96 - 32 != v18)
        {
          unsigned int v21 = v20 + 32;
          do
          {
            if (*(void *)v21 != v14 || *((void *)v21 + 2) != v15)
            {
              long long v22 = v21[1];
              *(_OWORD *)BOOL v20 = *v21;
              *((_OWORD *)v20 + 1) = v22;
              v20 += 32;
            }
            v21 += 2;
            v19 -= 32;
          }
          while (v19);
          uint64_t v17 = v95;
        }
      }
      else
      {
        BOOL v20 = v95;
      }
LABEL_32:
      LODWORD(v96) = (unint64_t)(v20 - v17) >> 5;
      int v23 = v101;
      if (v101 > 2)
      {
        sub_1CCD54A0C((uint64_t)v100, (long long *)&v100[32 * v101], 126 - 2 * __clz(v101), 1);
        uint64_t v26 = *((void *)v100 + 1);
        uint64_t v27 = *(void *)&v100[32 * v101 - 24];
        unsigned int v28 = *(_DWORD *)(v27 + 32);
        if (v28 >= 0x41) {
          operator new[]();
        }
        uint64_t v30 = *(void *)(v26 + 24);
        unsigned int v29 = (void *)(v26 + 24);
        uint64_t v31 = *(void *)(v27 + 24) - v30;
        char v32 = (v28 - 1) & 0x3F;
        unint64_t v33 = 0xFFFFFFFFFFFFFFFFLL >> (v32 ^ 0x3Fu);
        if (!v28) {
          unint64_t v33 = 0;
        }
        int v25 = 1;
        if ((v33 & v31) <= 1 << v32)
        {
          uint64_t v34 = *(void *)(v27 + 24) - *v29;
          unint64_t v35 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v28;
          if (!v28) {
            unint64_t v35 = 0;
          }
          unint64_t v36 = v35 & v34;
          if ((v35 & v34) != 0)
          {
            for (uint64_t i = v100; i + 32 != &v100[32 * v101]; i += 32)
            {
              unsigned int v38 = *(_DWORD *)(v27 + 32);
              if (v38 >= 0x41) {
                operator new[]();
              }
              unint64_t v39 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v38;
              if (!v38) {
                unint64_t v39 = 0;
              }
              if ((v39 & (*(void *)(v27 + 24) - *(void *)(*((void *)i + 5) + 24))) >= v36)
              {
                int v25 = 1;
                uint64_t v5 = (uint64_t *)a5;
                goto LABEL_38;
              }
            }
            if (v93 >= HIDWORD(v93))
            {
              long long v46 = *((_OWORD *)v100 + 1);
              long long v90 = *(_OWORD *)v100;
              long long v91 = v46;
              sub_1CB8BBE7C((unint64_t *)&v92, (unint64_t)&v90);
              unsigned int v42 = v93;
            }
            else
            {
              int v40 = (char *)v92 + 32 * v93;
              long long v41 = *((_OWORD *)v100 + 1);
              _OWORD *v40 = *(_OWORD *)v100;
              v40[1] = v41;
              unsigned int v42 = v93 + 1;
              LODWORD(v93) = v93 + 1;
            }
            uint64_t v5 = (uint64_t *)a5;
            uint64_t v43 = &v100[32 * v101 - 32];
            if (v42 >= HIDWORD(v93))
            {
              long long v47 = *(_OWORD *)&v100[32 * v101 - 16];
              long long v90 = *(_OWORD *)v43;
              long long v91 = v47;
              sub_1CB8BBE7C((unint64_t *)&v92, (unint64_t)&v90);
              int v25 = 0;
            }
            else
            {
              int v25 = 0;
              uint64_t v44 = (char *)v92 + 32 * v42;
              long long v45 = *(_OWORD *)&v100[32 * v101 - 16];
              _OWORD *v44 = *(_OWORD *)v43;
              v44[1] = v45;
              LODWORD(v93) = v93 + 1;
            }
          }
          else
          {
            int v25 = 1;
          }
        }
      }
      else
      {
        int v24 = v93;
        if (v93 + (unint64_t)v101 > HIDWORD(v93)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v101)
        {
          memcpy((char *)v92 + 32 * v93, v100, 32 * v101);
          int v24 = v93;
        }
        LODWORD(v93) = v24 + v23;
        int v25 = 2;
      }
LABEL_38:
      if (v100 != (char *)&v102) {
        free(v100);
      }
      if ((v25 | 2) != 2) {
        goto LABEL_70;
      }
      uint64_t v12 = v96;
    }
    while (v96);
  }
  uint64_t v49 = v93;
  if (v93 == v83)
  {
LABEL_70:
    int v48 = 1;
    uint64_t v8 = v82;
LABEL_71:
    uint64_t v7 = v81;
    goto LABEL_104;
  }
  uint64_t v8 = v82;
  if (!v6)
  {
    int v48 = 0;
    goto LABEL_71;
  }
  *uint64_t v5 = 0;
  if (v49)
  {
    uint64_t v50 = 32 * v49;
    uint64_t v51 = (uint64_t *)((char *)v92 + 24);
    do
    {
      sub_1CCD54948(a1, *v51, v6);
      uint64_t v52 = *v5;
      uint64_t v53 = (llvm::Value *)*v51;
      if (*v5)
      {
        __int16 v104 = 257;
        uint64_t v53 = llvm::BinaryOperator::Create(28, v53, v52, (const char **)&v100, (uint64_t)v6);
      }
      *uint64_t v5 = (uint64_t)v53;
      v51 += 4;
      v50 -= 32;
    }
    while (v50);
  }
  else
  {
    uint64_t v53 = 0;
  }
  uint64_t v100 = "wide.chk";
  __int16 v104 = 259;
  llvm::Value::setNameImpl(v53, (const char **)&v100);
  uint64_t v7 = v81;
  uint64_t v8 = v82;
  if (v53 && !*((unsigned char *)v53 + 16))
  {
    if ((*((unsigned char *)v53 + 23) & 0x10) == 0) {
      goto LABEL_140;
    }
    uint64_t v64 = ***(void ***)v53;
    uint64_t v65 = *(void *)(v64 + 152);
    uint64_t v66 = *(unsigned int *)(v64 + 168);
    if (v66)
    {
      LODWORD(v67) = (v66 - 1) & ((v53 >> 4) ^ (v53 >> 9));
      unsigned int v68 = (llvm::Value **)(v65 + 16 * v67);
      long long v69 = *v68;
      if (*v68 == v53)
      {
LABEL_133:
        uint64_t v72 = v68[1];
        unint64_t v75 = *(void *)v72;
        unsigned int v73 = (char *)v72 + 16;
        unint64_t v74 = v75;
        if (v75 >= 5 && *(_DWORD *)v73 == *(_DWORD *)"llvm." && v73[4] == aLlvm_1[4])
        {
          *((_DWORD *)v53 + 8) |= 0x2000u;
          int v77 = llvm::Function::lookupIntrinsicID(v73, v74);
LABEL_141:
          *((_DWORD *)v53 + 9) = v77;
          goto LABEL_103;
        }
LABEL_140:
        int v77 = 0;
        *((_DWORD *)v53 + 8) &= ~0x2000u;
        goto LABEL_141;
      }
      int v70 = 1;
      while (v69 != (llvm::Value *)-4096)
      {
        int v71 = v67 + v70++;
        uint64_t v67 = v71 & (v66 - 1);
        long long v69 = *(llvm::Value **)(v65 + 16 * v67);
        if (v69 == v53)
        {
          unsigned int v68 = (llvm::Value **)(v65 + 16 * v67);
          goto LABEL_133;
        }
      }
    }
    unsigned int v68 = (llvm::Value **)(v65 + 16 * v66);
    goto LABEL_133;
  }
LABEL_103:
  int v48 = 0;
LABEL_104:
  if (v92 != v94) {
    free(v92);
  }
  if (v95 != (char *)&v97) {
    free(v95);
  }
  if (!v48) {
    return 1;
  }
  if (!v6) {
    return 0;
  }
  sub_1CCD54948(a1, (uint64_t)v8, v6);
  sub_1CCD54948(a1, v7, v6);
  uint64_t v95 = "wide.chk";
  __int16 v99 = 259;
  unsigned int v62 = llvm::BinaryOperator::Create(28, v8, v7, (const char **)&v95, (uint64_t)v6);
  uint64_t result = 0;
  *uint64_t v5 = (uint64_t)v62;
  return result;
}

uint64_t sub_1CCD54308(uint64_t a1, llvm::Type *a2, const llvm::APFloat *a3)
{
  int v5 = *(unsigned __int8 *)(a1 + 16);
  if (v5 == 5)
  {
    if (*(_WORD *)(a1 + 18) != 28) {
      return 0;
    }
    uint64_t v7 = (void *)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
    if (!*v7) {
      return 0;
    }
    unint64_t isKnownNonNegative = v7[4];
    if (!isKnownNonNegative) {
      return isKnownNonNegative;
    }
    goto LABEL_10;
  }
  if (v5 != 81)
  {
    unint64_t isKnownNonNegative = 0;
    if (v5 != 56) {
      return isKnownNonNegative;
    }
    if (!*(void *)(a1 - 64)) {
      return 0;
    }
    unint64_t isKnownNonNegative = *(void *)(a1 - 32);
    if (!isKnownNonNegative) {
      return isKnownNonNegative;
    }
LABEL_10:
    if (((uint64_t (*)(void))sub_1CCD54308)()) {
      return sub_1CCD54308(isKnownNonNegative, a2);
    }
    return 0;
  }
  if (*(unsigned char *)(**(void **)(a1 - 64) + 8) != 13) {
    return 0;
  }
  int v8 = *(_WORD *)(a1 + 18) & 0x3F;
  if (v8 != 36 && v8 != 34) {
    return 0;
  }
  if (v8 == 34) {
    uint64_t v10 = *(llvm::Constant ***)(a1 - 64);
  }
  else {
    uint64_t v10 = *(llvm::Constant ***)(a1 - 32);
  }
  if (v8 == 34) {
    uint64_t v11 = *(void *)(a1 - 32);
  }
  else {
    uint64_t v11 = *(void *)(a1 - 64);
  }
  uint64_t v12 = (const llvm::Value *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 56) + 40) + 272);
  Nulluint64_t Value = llvm::Constant::getNullValue(*v10, a2, a3);
  uint64_t v40 = v11;
  long long v41 = NullValue;
  unsigned int v42 = v10;
  uint64_t v43 = a1;
  unint64_t v35 = v12;
  unint64_t isKnownNonNegative = llvm::isKnownNonNegative((llvm *)v10, v12, 0, 0, 0, 0, (const llvm::DominatorTree *)1);
  if (!isKnownNonNegative) {
    return isKnownNonNegative;
  }
  uint64_t v15 = **(llvm::ConstantInt ***)a1;
  while (1)
  {
    while (1)
    {
      int v16 = *(unsigned __int8 *)(v11 + 16);
      if (v16 == 5) {
        break;
      }
      if (v16 == 57)
      {
        if (!*(void *)(v11 - 64)) {
          goto LABEL_81;
        }
        uint64_t v24 = *(void *)(v11 - 32);
        if (!v24 || *(unsigned char *)(v24 + 16) != 16) {
          goto LABEL_81;
        }
        uint64_t v11 = *(void *)(v11 - 64);
        goto LABEL_58;
      }
      if (v16 != 41) {
        goto LABEL_81;
      }
      if (!*(void *)(v11 - 64)) {
        goto LABEL_81;
      }
      uint64_t v17 = *(void *)(v11 - 32);
      if (!v17 || *(unsigned char *)(v17 + 16) != 16) {
        goto LABEL_81;
      }
      uint64_t v11 = *(void *)(v11 - 64);
LABEL_40:
      uint64_t v40 = v11;
      unsigned int v21 = *((_DWORD *)NullValue + 8);
      if (v21 >= 0x41) {
        operator new[]();
      }
      uint64_t v22 = *(void *)(v17 + 24) + *((void *)NullValue + 3);
      unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
      if (!v21) {
        unint64_t v23 = 0;
      }
      LODWORD(v45) = *((_DWORD *)NullValue + 8);
      uint64_t v44 = (const llvm::DataLayout *)(v23 & v22);
      int v25 = (llvm::Value *)llvm::ConstantInt::get(v15, (llvm::LLVMContext *)&v44, v14);
      Nulluint64_t Value = v25;
      long long v41 = v25;
      if (v45 >= 0x41)
      {
        uint64_t v26 = v44;
        if (v44) {
          goto LABEL_51;
        }
      }
    }
    int v18 = *(unsigned __int16 *)(v11 + 18);
    if (v18 != 29)
    {
      if (v18 != 13) {
        goto LABEL_81;
      }
      uint64_t v19 = (uint64_t *)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF));
      uint64_t v11 = *v19;
      if (!*v19) {
        goto LABEL_81;
      }
      uint64_t v17 = v19[4];
      if (!v17 || *(unsigned char *)(v17 + 16) != 16) {
        goto LABEL_81;
      }
      goto LABEL_40;
    }
    uint64_t v27 = (uint64_t *)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF));
    uint64_t v11 = *v27;
    if (!*v27) {
      goto LABEL_81;
    }
    uint64_t v24 = v27[4];
    if (!v24 || *(unsigned char *)(v24 + 16) != 16) {
      goto LABEL_81;
    }
LABEL_58:
    if (*(unsigned __int8 *)(v11 + 16) < 0x1Cu || (uint64_t v29 = v11, !*(void *)(v11 + 40))) {
      uint64_t v29 = 0;
    }
    uint64_t v44 = v35;
    uint64_t v45 = 0;
    uint64_t v46 = v29;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    char v49 = 1;
    sub_1CC16089C((uint64_t *)v11, 0, &v44, (uint64_t)&v36);
    if (*(_DWORD *)(v24 + 32) >= 0x41u) {
      operator new[]();
    }
    if ((*(void *)(v24 + 24) & ~(unint64_t)v36) != 0) {
      break;
    }
    uint64_t v40 = v11;
    unsigned int v31 = *((_DWORD *)NullValue + 8);
    if (v31 >= 0x41) {
      operator new[]();
    }
    uint64_t v32 = *(void *)(v24 + 24) + *((void *)NullValue + 3);
    unint64_t v33 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v31;
    if (!v31) {
      unint64_t v33 = 0;
    }
    LODWORD(v45) = *((_DWORD *)NullValue + 8);
    uint64_t v44 = (const llvm::DataLayout *)(v33 & v32);
    uint64_t v34 = (llvm::Value *)llvm::ConstantInt::get(v15, (llvm::LLVMContext *)&v44, v30);
    Nulluint64_t Value = v34;
    long long v41 = v34;
    if (v45 >= 0x41 && v44) {
      MEMORY[0x1D25D9CB0](v44, 0x1000C8000313F17);
    }
    if (v39 >= 0x41 && v38) {
      MEMORY[0x1D25D9CB0](v38, 0x1000C8000313F17);
    }
    if (v37 >= 0x41)
    {
      uint64_t v26 = v36;
      if (v36) {
LABEL_51:
      }
        MEMORY[0x1D25D9CB0](v26, 0x1000C8000313F17);
    }
  }
  if (v39 >= 0x41 && v38) {
    MEMORY[0x1D25D9CB0](v38, 0x1000C8000313F17);
  }
  if (v37 >= 0x41 && v36) {
    MEMORY[0x1D25D9CB0](v36, 0x1000C8000313F17);
  }
LABEL_81:
  sub_1CB8BBE7C((unint64_t *)a2, (unint64_t)&v40);
  return isKnownNonNegative;
}

void sub_1CCD54948(llvm::DominatorTree **a1, uint64_t a2, const llvm::Instruction *a3)
{
  if (!a2
    || *(unsigned __int8 *)(a2 + 16) < 0x1Cu
    || (llvm::DominatorTree::dominates(*a1, (const llvm::Value *)a2, a3) & 1) != 0)
  {
    return;
  }
  int v6 = *(_DWORD *)(a2 + 20);
  if ((v6 & 0x40000000) != 0)
  {
    int v8 = *(uint64_t **)(a2 - 8);
    uint64_t v7 = v6 & 0x7FFFFFF;
    if (!v7) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v7 = v6 & 0x7FFFFFF;
    int v8 = (uint64_t *)(a2 - 32 * v7);
    if (!v7) {
      goto LABEL_11;
    }
  }
  uint64_t v9 = 32 * v7;
  do
  {
    uint64_t v10 = *v8;
    v8 += 4;
    sub_1CCD54948(a1, v10, a3);
    v9 -= 32;
  }
  while (v9);
LABEL_11:

  llvm::Instruction::moveBefore((llvm::Instruction *)a2, a3);
}

uint64_t sub_1CCD54A0C(uint64_t result, long long *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = v9;
LABEL_3:
  while (1)
  {
    unint64_t v9 = v10;
    uint64_t v11 = (uint64_t)a2 - v10;
    uint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 5;
    if (v5 || !v4) {
      break;
    }
    if (v11 <= 767)
    {
      int v206 = (long long *)(v10 + 32);
      BOOL v208 = (long long *)v10 == a2 || v206 == a2;
      if (a4)
      {
        if (!v208)
        {
          uint64_t v209 = (_OWORD *)v10;
          while (1)
          {
            uint64_t v210 = v209;
            uint64_t v209 = v206;
            uint64_t v211 = *((void *)v210 + 5);
            uint64_t v212 = *((void *)v210 + 1);
            uint64_t v213 = (void *)(v212 + 24);
            uint64_t v214 = *(unsigned int *)(v211 + 32);
            if (v214 <= 0x40) {
              break;
            }
            uint64_t v233 = *(void *)(v211 + 24);
            uint64_t v234 = *(void *)(v233 + 8 * ((v214 - 1) >> 6)) & (1 << (v214 - 1));
            uint64_t result = *(unsigned int *)(v212 + 32);
            unsigned int v235 = result - 1;
            uint64_t v236 = *(void *)(v212 + 24);
            if (result >= 0x41) {
              uint64_t v213 = (void *)(v236 + 8 * (v235 >> 6));
            }
            if ((v234 != 0) != ((*v213 >> v235) & 1))
            {
              if (!v234) {
                goto LABEL_252;
              }
              goto LABEL_236;
            }
            unint64_t v237 = v214 + 63;
            uint64_t v238 = v236 - 8;
            uint64_t v239 = (v237 >> 3) & 0x3FFFFFF8;
            uint64_t v240 = v233 - 8;
            do
            {
              if (!v239) {
                goto LABEL_252;
              }
              unint64_t v241 = *(void *)(v240 + v239);
              unint64_t v242 = *(void *)(v238 + v239);
              v239 -= 8;
            }
            while (v241 == v242);
            if (v241 <= v242) {
              goto LABEL_236;
            }
LABEL_252:
            int v206 = v209 + 2;
            if (v209 + 2 == a2) {
              return result;
            }
          }
          if ((uint64_t)(*(void *)(v211 + 24) << -(char)v214) >> -(char)v214 >= (uint64_t)(*v213 << -(char)v214) >> -(char)v214) {
            goto LABEL_252;
          }
LABEL_236:
          uint64_t v215 = *((void *)v210 + 4);
          long long v464 = v210[3];
          long long v216 = v210[1];
          *uint64_t v209 = *v210;
          v209[1] = v216;
          unint64_t v217 = v10;
          if (v210 == (_OWORD *)v10) {
            goto LABEL_251;
          }
          while (1)
          {
            uint64_t v218 = *((void *)v210 - 3);
            uint64_t v219 = (void *)(v218 + 24);
            uint64_t v220 = *(unsigned int *)(v211 + 32);
            if (v220 > 0x40)
            {
              uint64_t v222 = *(void *)(v211 + 24);
              uint64_t v223 = *(void *)(v222 + 8 * ((v220 - 1) >> 6)) & (1 << (v220 - 1));
              uint64_t result = v223 != 0;
              unsigned int v224 = *(_DWORD *)(v218 + 32);
              unsigned int v225 = v224 - 1;
              uint64_t v226 = *(void *)(v218 + 24);
              if (v224 >= 0x41) {
                uint64_t v219 = (void *)(v226 + 8 * (v225 >> 6));
              }
              if (result == ((*v219 >> v225) & 1))
              {
                unint64_t v227 = v220 + 63;
                uint64_t v228 = v226 - 8;
                uint64_t v229 = (v227 >> 3) & 0x3FFFFFF8;
                uint64_t v230 = v222 - 8;
                while (v229)
                {
                  unint64_t v231 = *(void *)(v230 + v229);
                  unint64_t v232 = *(void *)(v228 + v229);
                  v229 -= 8;
                  if (v231 != v232)
                  {
                    if (v231 <= v232) {
                      goto LABEL_239;
                    }
                    break;
                  }
                }
LABEL_250:
                unint64_t v217 = (unint64_t)v210;
LABEL_251:
                *(void *)unint64_t v217 = v215;
                *(void *)(v217 + 8) = v211;
                *(_OWORD *)(v217 + 16) = v464;
                goto LABEL_252;
              }
              if (!v223) {
                goto LABEL_250;
              }
            }
            else if ((uint64_t)(*(void *)(v211 + 24) << -(char)v220) >> -(char)v220 >= (uint64_t)(*v219 << -(char)v220) >> -(char)v220)
            {
              goto LABEL_250;
            }
LABEL_239:
            long long v221 = *(v210 - 1);
            *uint64_t v210 = *(v210 - 2);
            v210[1] = v221;
            v210 -= 2;
            if (v210 == (_OWORD *)v10)
            {
              unint64_t v217 = v10;
              goto LABEL_251;
            }
          }
        }
        return result;
      }
      if (v208) {
        return result;
      }
      while (2)
      {
        unint64_t v368 = v9;
        unint64_t v9 = (unint64_t)v206;
        uint64_t v369 = *(void *)(v368 + 40);
        uint64_t v370 = *(void *)(v368 + 8);
        int v371 = (void *)(v370 + 24);
        uint64_t v372 = *(unsigned int *)(v369 + 32);
        if (v372 <= 0x40)
        {
          if ((uint64_t)(*(void *)(v369 + 24) << -(char)v372) >> -(char)v372 < (uint64_t)(*v371 << -(char)v372) >> -(char)v372)
          {
LABEL_387:
            uint64_t v373 = *(void *)v9;
            long long v467 = *(_OWORD *)(v368 + 48);
            unint64_t v374 = v9;
            while (1)
            {
LABEL_388:
              while (1)
              {
                int v375 = (_OWORD *)v374;
                unint64_t v374 = v368;
                long long v376 = *(_OWORD *)v368;
                long long v377 = *(_OWORD *)(v368 + 16);
                v368 -= 32;
                *int v375 = v376;
                v375[1] = v377;
                uint64_t v378 = *(void *)(v374 - 24);
                uint64_t v379 = (void *)(v378 + 24);
                uint64_t v380 = *(unsigned int *)(v369 + 32);
                if (v380 > 0x40) {
                  break;
                }
                if ((uint64_t)(*(void *)(v369 + 24) << -(char)v380) >> -(char)v380 >= (uint64_t)(*v379 << -(char)v380) >> -(char)v380) {
                  goto LABEL_400;
                }
              }
              uint64_t v381 = *(void *)(v369 + 24);
              uint64_t v382 = *(void *)(v381 + 8 * ((v380 - 1) >> 6)) & (1 << (v380 - 1));
              uint64_t result = v382 != 0;
              unsigned int v383 = *(_DWORD *)(v378 + 32);
              unsigned int v384 = v383 - 1;
              uint64_t v385 = *(void *)(v378 + 24);
              if (v383 >= 0x41) {
                uint64_t v379 = (void *)(v385 + 8 * (v384 >> 6));
              }
              if (result == ((*v379 >> v384) & 1)) {
                break;
              }
              if (!v382) {
                goto LABEL_400;
              }
            }
            unint64_t v386 = v380 + 63;
            uint64_t v387 = v385 - 8;
            uint64_t v388 = (v386 >> 3) & 0x3FFFFFF8;
            uint64_t v389 = v381 - 8;
            while (v388)
            {
              unint64_t v390 = *(void *)(v389 + v388);
              unint64_t v391 = *(void *)(v387 + v388);
              v388 -= 8;
              if (v390 != v391)
              {
                if (v390 <= v391) {
                  goto LABEL_388;
                }
                break;
              }
            }
LABEL_400:
            *(void *)unint64_t v374 = v373;
            *(void *)(v374 + 8) = v369;
            *(_OWORD *)(v374 + 16) = v467;
          }
        }
        else
        {
          uint64_t v392 = *(void *)(v369 + 24);
          uint64_t v393 = *(void *)(v392 + 8 * ((v372 - 1) >> 6)) & (1 << (v372 - 1));
          unsigned int v394 = *(_DWORD *)(v370 + 32);
          uint64_t result = v394 - 1;
          uint64_t v395 = *(void *)(v370 + 24);
          if (v394 >= 0x41) {
            int v371 = (void *)(v395 + 8 * (result >> 6));
          }
          if ((v393 != 0) == ((*v371 >> (v394 - 1)) & 1))
          {
            unint64_t v396 = v372 + 63;
            uint64_t v397 = v395 - 8;
            uint64_t v398 = (v396 >> 3) & 0x3FFFFFF8;
            uint64_t v399 = v392 - 8;
            while (v398)
            {
              unint64_t v400 = *(void *)(v399 + v398);
              unint64_t v401 = *(void *)(v397 + v398);
              v398 -= 8;
              if (v400 != v401)
              {
                if (v400 <= v401) {
                  goto LABEL_387;
                }
                break;
              }
            }
          }
          else if (v393)
          {
            goto LABEL_387;
          }
        }
        int v206 = (long long *)(v9 + 32);
        if ((long long *)(v9 + 32) == a2) {
          return result;
        }
        continue;
      }
    }
    if (!a3)
    {
      if ((long long *)v10 == a2) {
        return result;
      }
      int64_t v243 = (unint64_t)(v12 - 2) >> 1;
      int64_t v244 = v243;
      while (2)
      {
        int64_t v245 = v244;
        if (v243 < v244) {
          goto LABEL_305;
        }
        uint64_t v246 = (2 * v244) | 1;
        unint64_t v247 = v10 + 32 * v246;
        if (2 * v245 + 2 < v12)
        {
          uint64_t v248 = *(void *)(v247 + 8);
          uint64_t v249 = *(void *)(v247 + 40);
          uint64_t v250 = (void *)(v249 + 24);
          uint64_t v251 = *(unsigned int *)(v248 + 32);
          if (v251 > 0x40)
          {
            uint64_t v296 = *(void *)(v248 + 24);
            uint64_t v297 = *(void *)(v296 + 8 * ((v251 - 1) >> 6)) & (1 << (v251 - 1));
            unsigned int v298 = *(_DWORD *)(v249 + 32);
            unsigned int v299 = v298 - 1;
            uint64_t v300 = *(void *)(v249 + 24);
            if (v298 >= 0x41) {
              uint64_t v250 = (void *)(v300 + 8 * (v299 >> 6));
            }
            if ((v297 != 0) == ((*v250 >> v299) & 1))
            {
              unint64_t v306 = v251 + 63;
              uint64_t v307 = v300 - 8;
              uint64_t v308 = (v306 >> 3) & 0x3FFFFFF8;
              uint64_t v309 = v296 - 8;
              do
              {
                if (!v308) {
                  goto LABEL_271;
                }
                unint64_t v310 = *(void *)(v309 + v308);
                unint64_t v311 = *(void *)(v307 + v308);
                v308 -= 8;
              }
              while (v310 == v311);
              if (v310 > v311) {
                goto LABEL_271;
              }
            }
            else if (!v297)
            {
              goto LABEL_271;
            }
LABEL_270:
            v247 += 32;
            uint64_t v246 = 2 * v245 + 2;
            goto LABEL_271;
          }
          if ((uint64_t)(*(void *)(v248 + 24) << -(char)v251) >> -(char)v251 < (uint64_t)(*v250 << -(char)v251) >> -(char)v251) {
            goto LABEL_270;
          }
        }
LABEL_271:
        uint64_t v252 = *(void *)(v247 + 8);
        uint64_t v253 = *(void *)(v10 + 32 * v245 + 8);
        unsigned int v254 = (void *)(v253 + 24);
        uint64_t v255 = *(unsigned int *)(v252 + 32);
        if (v255 > 0x40)
        {
          uint64_t v291 = *(void *)(v252 + 24);
          uint64_t result = *(void *)(v291 + 8 * ((v255 - 1) >> 6)) & (1 << (v255 - 1));
          unsigned int v292 = *(_DWORD *)(v253 + 32);
          unsigned int v293 = v292 - 1;
          uint64_t v294 = *(void *)(v253 + 24);
          if (v292 >= 0x41) {
            uint64_t v295 = (void *)(v294 + 8 * (v293 >> 6));
          }
          else {
            uint64_t v295 = (void *)(v253 + 24);
          }
          if ((result != 0) == ((*v295 >> v293) & 1))
          {
            unint64_t v301 = v255 + 63;
            uint64_t v302 = v294 - 8;
            uint64_t result = (v301 >> 3) & 0x3FFFFFF8;
            uint64_t v303 = v291 - 8;
            do
            {
              if (!result) {
                goto LABEL_273;
              }
              unint64_t v304 = *(void *)(v303 + result);
              unint64_t v305 = *(void *)(v302 + result);
              result -= 8;
            }
            while (v304 == v305);
            if (v304 <= v305) {
              goto LABEL_305;
            }
          }
          else if (result)
          {
            goto LABEL_305;
          }
        }
        else
        {
          uint64_t v256 = -v255;
          uint64_t result = *v254 << v256;
          if ((uint64_t)(*(void *)(v252 + 24) << v256) >> v256 < result >> v256) {
            goto LABEL_305;
          }
        }
LABEL_273:
        unint64_t v257 = v10 + 32 * v245;
        uint64_t v258 = *(void *)v257;
        long long v465 = *(_OWORD *)(v257 + 16);
LABEL_274:
        long long v259 = *(_OWORD *)(v247 + 16);
        *(_OWORD *)unint64_t v257 = *(_OWORD *)v247;
        *(_OWORD *)(v257 + 16) = v259;
        if (v243 < v246) {
          goto LABEL_304;
        }
        unint64_t v257 = v247;
        uint64_t v260 = 2 * v246;
        uint64_t v246 = (2 * v246) | 1;
        unint64_t v247 = v10 + 32 * v246;
        uint64_t v261 = v260 + 2;
        if (v261 < v12)
        {
          uint64_t v262 = *(void *)(v247 + 8);
          uint64_t v263 = *(void *)(v247 + 40);
          unsigned int v264 = (void *)(v263 + 24);
          uint64_t v265 = *(unsigned int *)(v262 + 32);
          if (v265 > 0x40)
          {
            uint64_t v275 = *(void *)(v262 + 24);
            uint64_t v276 = *(void *)(v275 + 8 * ((v265 - 1) >> 6)) & (1 << (v265 - 1));
            unsigned int v277 = *(_DWORD *)(v263 + 32);
            unsigned int v278 = v277 - 1;
            uint64_t v279 = *(void *)(v263 + 24);
            if (v277 >= 0x41) {
              unsigned int v264 = (void *)(v279 + 8 * (v278 >> 6));
            }
            if ((v276 != 0) == ((*v264 >> v278) & 1))
            {
              unint64_t v285 = v265 + 63;
              uint64_t v286 = v279 - 8;
              uint64_t v287 = (v285 >> 3) & 0x3FFFFFF8;
              uint64_t v288 = v275 - 8;
              do
              {
                if (!v287) {
                  goto LABEL_279;
                }
                unint64_t v289 = *(void *)(v288 + v287);
                unint64_t v290 = *(void *)(v286 + v287);
                v287 -= 8;
              }
              while (v289 == v290);
              if (v289 > v290) {
                goto LABEL_279;
              }
            }
            else if (!v276)
            {
              goto LABEL_279;
            }
LABEL_278:
            v247 += 32;
            uint64_t v246 = v261;
            goto LABEL_279;
          }
          if ((uint64_t)(*(void *)(v262 + 24) << -(char)v265) >> -(char)v265 < (uint64_t)(*v264 << -(char)v265) >> -(char)v265) {
            goto LABEL_278;
          }
        }
LABEL_279:
        uint64_t v266 = *(void *)(v247 + 8);
        uint64_t result = *(unsigned int *)(v266 + 32);
        if (result > 0x40)
        {
          uint64_t v269 = *(void *)(v266 + 24);
          uint64_t v270 = *(void *)(v269 + 8 * ((result - 1) >> 6)) & (1 << (result - 1));
          unsigned int v271 = *(_DWORD *)(v253 + 32);
          unsigned int v272 = v271 - 1;
          uint64_t v273 = *(void *)(v253 + 24);
          if (v271 >= 0x41) {
            uint64_t v274 = (void *)(v273 + 8 * (v272 >> 6));
          }
          else {
            uint64_t v274 = (void *)(v253 + 24);
          }
          if ((v270 != 0) == ((*v274 >> v272) & 1))
          {
            unint64_t v280 = result + 63;
            uint64_t result = v273 - 8;
            uint64_t v281 = (v280 >> 3) & 0x3FFFFFF8;
            uint64_t v282 = v269 - 8;
            do
            {
              if (!v281) {
                goto LABEL_274;
              }
              unint64_t v283 = *(void *)(v282 + v281);
              unint64_t v284 = *(void *)(result + v281);
              v281 -= 8;
            }
            while (v283 == v284);
            if (v283 <= v284)
            {
LABEL_303:
              unint64_t v247 = v257;
LABEL_304:
              *(void *)unint64_t v247 = v258;
              *(void *)(v247 + 8) = v253;
              *(_OWORD *)(v247 + 16) = v465;
LABEL_305:
              int64_t v244 = v245 - 1;
              if (v245) {
                continue;
              }
              while (2)
              {
                uint64_t v312 = 0;
                long long v466 = *(_OWORD *)v10;
                long long v474 = *(_OWORD *)(v10 + 16);
                unint64_t v313 = v10;
LABEL_329:
                unint64_t v314 = (_OWORD *)v313;
                v313 += 32 * (v312 + 1);
                uint64_t v315 = 2 * v312;
                uint64_t v312 = (2 * v312) | 1;
                uint64_t v316 = v315 + 2;
                if (v316 < v12)
                {
                  uint64_t v317 = *(void *)(v313 + 8);
                  uint64_t result = *(void *)(v313 + 40);
                  uint64_t v318 = (void *)(result + 24);
                  uint64_t v319 = *(unsigned int *)(v317 + 32);
                  if (v319 > 0x40)
                  {
                    uint64_t v321 = *(void *)(v317 + 24);
                    uint64_t v322 = *(void *)(v321 + 8 * ((v319 - 1) >> 6)) & (1 << (v319 - 1));
                    unsigned int v323 = *(_DWORD *)(result + 32);
                    unsigned int v324 = v323 - 1;
                    uint64_t result = *(void *)(result + 24);
                    if (v323 >= 0x41) {
                      uint64_t v318 = (void *)(result + 8 * (v324 >> 6));
                    }
                    if ((v322 != 0) == ((*v318 >> v324) & 1))
                    {
                      unint64_t v325 = v319 + 63;
                      uint64_t v326 = result - 8;
                      uint64_t v327 = (v325 >> 3) & 0x3FFFFFF8;
                      uint64_t v328 = v321 - 8;
                      while (v327)
                      {
                        uint64_t result = *(void *)(v328 + v327);
                        unint64_t v329 = *(void *)(v326 + v327);
                        v327 -= 8;
                        if (result != v329)
                        {
                          if (result <= v329) {
                            goto LABEL_332;
                          }
                          break;
                        }
                      }
                    }
                    else if (v322)
                    {
LABEL_332:
                      v313 += 32;
                      uint64_t v312 = v316;
                    }
                  }
                  else if ((uint64_t)(*(void *)(v317 + 24) << -(char)v319) >> -(char)v319 < (uint64_t)(*v318 << -(char)v319) >> -(char)v319)
                  {
                    goto LABEL_332;
                  }
                }
                long long v320 = *(_OWORD *)(v313 + 16);
                _OWORD *v314 = *(_OWORD *)v313;
                v314[1] = v320;
                if (v312 > (uint64_t)((unint64_t)(v12 - 2) >> 1))
                {
                  a2 -= 2;
                  if ((long long *)v313 == a2)
                  {
                    *(_OWORD *)unint64_t v313 = v466;
                    *(_OWORD *)(v313 + 16) = v474;
                    goto LABEL_368;
                  }
                  long long v330 = a2[1];
                  *(_OWORD *)unint64_t v313 = *a2;
                  *(_OWORD *)(v313 + 16) = v330;
                  *a2 = v466;
                  a2[1] = v474;
                  uint64_t v331 = v313 - v10 + 32;
                  if (v331 >= 33)
                  {
                    unint64_t v332 = ((unint64_t)v331 >> 5) - 2;
                    unint64_t v333 = v332 >> 1;
                    uint64_t v334 = *(void *)(v10 + 32 * (v332 >> 1) + 8);
                    uint64_t v335 = *(void *)(v313 + 8);
                    uint64_t v336 = (void *)(v335 + 24);
                    uint64_t v337 = *(unsigned int *)(v334 + 32);
                    if (v337 > 0x40)
                    {
                      uint64_t v358 = *(void *)(v334 + 24);
                      uint64_t v359 = *(void *)(v358 + 8 * ((v337 - 1) >> 6)) & (1 << (v337
                                                                                                - 1));
                      unsigned int v360 = *(_DWORD *)(v335 + 32);
                      unsigned int v361 = v360 - 1;
                      uint64_t result = *(void *)(v335 + 24);
                      if (v360 >= 0x41) {
                        int v362 = (void *)(result + 8 * (v361 >> 6));
                      }
                      else {
                        int v362 = (void *)(v335 + 24);
                      }
                      if ((v359 != 0) == ((*v362 >> v361) & 1))
                      {
                        unint64_t v363 = v337 + 63;
                        uint64_t v364 = result - 8;
                        uint64_t v365 = (v363 >> 3) & 0x3FFFFFF8;
                        uint64_t v366 = v358 - 8;
                        while (v365)
                        {
                          uint64_t result = *(void *)(v366 + v365);
                          unint64_t v367 = *(void *)(v364 + v365);
                          v365 -= 8;
                          if (result != v367)
                          {
                            if (result <= v367) {
                              goto LABEL_350;
                            }
                            break;
                          }
                        }
                      }
                      else if (v359)
                      {
LABEL_350:
                        uint64_t v338 = *(void *)v313;
                        long long v459 = *(_OWORD *)(v313 + 16);
                        unsigned int v339 = (_OWORD *)(v10 + 32 * v333);
                        long long v340 = v339[1];
                        *(_OWORD *)unint64_t v313 = *v339;
                        *(_OWORD *)(v313 + 16) = v340;
                        if (v332 >= 2)
                        {
                          while (1)
                          {
                            unint64_t v342 = v333 - 1;
                            unint64_t v333 = (v333 - 1) >> 1;
                            uint64_t v343 = *(void *)(v10 + 32 * v333 + 8);
                            uint64_t v344 = *(unsigned int *)(v343 + 32);
                            if (v344 > 0x40)
                            {
                              uint64_t v347 = *(void *)(v343 + 24);
                              uint64_t result = *(void *)(v347 + 8 * ((v344 - 1) >> 6)) & (1 << (v344 - 1));
                              unsigned int v348 = *(_DWORD *)(v335 + 32);
                              unsigned int v349 = v348 - 1;
                              uint64_t v350 = *(void *)(v335 + 24);
                              if (v348 >= 0x41) {
                                uint64_t v351 = (void *)(v350 + 8 * (v349 >> 6));
                              }
                              else {
                                uint64_t v351 = (void *)(v335 + 24);
                              }
                              if ((result != 0) == ((*v351 >> v349) & 1))
                              {
                                unint64_t v352 = v344 + 63;
                                uint64_t v353 = v350 - 8;
                                uint64_t result = (v352 >> 3) & 0x3FFFFFF8;
                                uint64_t v354 = v347 - 8;
                                while (result)
                                {
                                  unint64_t v355 = *(void *)(v354 + result);
                                  unint64_t v356 = *(void *)(v353 + result);
                                  result -= 8;
                                  if (v355 != v356)
                                  {
                                    if (v355 <= v356) {
                                      goto LABEL_355;
                                    }
                                    goto LABEL_351;
                                  }
                                }
                                break;
                              }
                              if (!result) {
                                break;
                              }
                            }
                            else
                            {
                              uint64_t v345 = -v344;
                              uint64_t result = *v336 << v345;
                              if ((uint64_t)(*(void *)(v343 + 24) << v345) >> v345 >= result >> v345) {
                                break;
                              }
                            }
LABEL_355:
                            uint64_t v341 = (_OWORD *)(v10 + 32 * v333);
                            long long v346 = v341[1];
                            *unsigned int v339 = *v341;
                            v339[1] = v346;
                            unsigned int v339 = v341;
                            if (v342 <= 1) {
                              goto LABEL_352;
                            }
                          }
                        }
LABEL_351:
                        uint64_t v341 = v339;
LABEL_352:
                        *(void *)uint64_t v341 = v338;
                        *((void *)v341 + 1) = v335;
                        v341[1] = v459;
                      }
                    }
                    else if ((uint64_t)(*(void *)(v334 + 24) << -(char)v337) >> -(char)v337 < (uint64_t)(*v336 << -(char)v337) >> -(char)v337)
                    {
                      goto LABEL_350;
                    }
                  }
LABEL_368:
                  if (v12-- <= 2) {
                    return result;
                  }
                  continue;
                }
                goto LABEL_329;
              }
            }
          }
          else if (v270)
          {
            goto LABEL_303;
          }
        }
        else
        {
          uint64_t v267 = -result;
          uint64_t v268 = (uint64_t)(*(void *)(v266 + 24) << v267) >> v267;
          uint64_t result = (uint64_t)(*v254 << v267) >> v267;
          if (v268 < result) {
            goto LABEL_303;
          }
        }
        goto LABEL_274;
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    uint64_t v14 = (long long *)(v10 + 32 * ((unint64_t)v12 >> 1));
    if ((unint64_t)v11 > 0x1000)
    {
      sub_1CCD5659C((long long *)v9, (long long *)(v9 + 32 * ((unint64_t)v12 >> 1)), a2 - 2);
      sub_1CCD5659C((long long *)(v9 + 32), v14 - 2, a2 - 4);
      sub_1CCD5659C((long long *)(v9 + 64), (long long *)(v9 + 32 + 32 * v13), a2 - 6);
      uint64_t result = (uint64_t)sub_1CCD5659C(v14 - 2, v14, (long long *)(v9 + 32 + 32 * v13));
      long long v460 = *(_OWORD *)v9;
      long long v468 = *(_OWORD *)(v9 + 16);
      long long v15 = v14[1];
      *(_OWORD *)unint64_t v9 = *v14;
      *(_OWORD *)(v9 + 16) = v15;
      *uint64_t v14 = v460;
      v14[1] = v468;
    }
    else
    {
      uint64_t result = (uint64_t)sub_1CCD5659C((long long *)(v9 + 32 * ((unint64_t)v12 >> 1)), (long long *)v9, a2 - 2);
    }
    --a3;
    if (a4)
    {
      uint64_t v16 = *(void *)(v9 + 8);
    }
    else
    {
      uint64_t v17 = *(void *)(v9 - 24);
      uint64_t v16 = *(void *)(v9 + 8);
      int v18 = (uint64_t *)(v16 + 24);
      uint64_t v19 = *(unsigned int *)(v17 + 32);
      if (v19 > 0x40)
      {
        uint64_t v149 = *(void *)(v17 + 24);
        uint64_t v150 = *(void *)(v149 + 8 * ((v19 - 1) >> 6)) & (1 << (v19 - 1));
        unsigned int v97 = *(_DWORD *)(v16 + 32);
        uint64_t v22 = *(void *)(v16 + 24);
        unsigned int v151 = (void *)(v22 + 8 * ((v97 - 1) >> 6));
        if (v97 < 0x41) {
          unsigned int v151 = (void *)(v16 + 24);
        }
        if ((v150 != 0) == ((*v151 >> (v97 - 1)) & 1))
        {
          unint64_t v152 = ((unint64_t)(v19 + 63) >> 3) & 0x3FFFFFF8;
          uint64_t v153 = v149 - 8;
          do
          {
            if (!v152) {
              goto LABEL_108;
            }
            unint64_t v154 = *(void *)(v153 + v152);
            unint64_t v155 = *(void *)(v22 + v152 - 8);
            v152 -= 8;
          }
          while (v154 == v155);
          if (v154 > v155) {
            goto LABEL_108;
          }
        }
        else if (!v150)
        {
          goto LABEL_108;
        }
      }
      else
      {
        uint64_t v20 = -v19;
        uint64_t v21 = (uint64_t)(*(void *)(v17 + 24) << v20) >> v20;
        uint64_t v22 = *v18;
        if (v21 >= *v18 << v20 >> v20)
        {
          unsigned int v97 = *(_DWORD *)(v16 + 32);
LABEL_108:
          uint64_t v98 = *(void *)v9;
          long long v458 = *(_OWORD *)(v9 + 16);
          uint64_t v99 = *((void *)a2 - 3);
          uint64_t v100 = (void *)(v99 + 24);
          if (v97 > 0x40)
          {
            uint64_t v156 = *(void *)(v22 + 8 * ((v97 - 1) >> 6)) & (1 << (v97 - 1));
            uint64_t result = *(unsigned int *)(v99 + 32);
            unsigned int v157 = result - 1;
            uint64_t v158 = *(void *)(v99 + 24);
            if (result >= 0x41) {
              uint64_t v100 = (void *)(v158 + 8 * (v157 >> 6));
            }
            if ((v156 != 0) == ((*v100 >> v157) & 1))
            {
              unint64_t v171 = (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8;
              while (v171)
              {
                unint64_t v172 = *(void *)(v22 - 8 + v171);
                uint64_t result = *(void *)(v158 - 8 + v171);
                v171 -= 8;
                if (v172 != result)
                {
                  if (v172 <= result) {
                    goto LABEL_110;
                  }
                  break;
                }
              }
            }
            else if (v156)
            {
              goto LABEL_110;
            }
          }
          else if (v22 << -(char)v97 >> -(char)v97 < (uint64_t)(*v100 << -(char)v97) >> -(char)v97)
          {
LABEL_110:
            uint64_t v101 = (v97 - 1) >> 6;
            uint64_t v102 = 1 << (v97 - 1);
            uint64_t result = (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8;
            unint64_t v10 = v9;
            do
            {
LABEL_111:
              while (1)
              {
                uint64_t v103 = *(void *)(v10 + 40);
                v10 += 32;
                __int16 v104 = (void *)(v103 + 24);
                if (v97 <= 0x40) {
                  break;
                }
                unsigned int v105 = *(_DWORD *)(v103 + 32);
                unsigned int v106 = v105 - 1;
                uint64_t v107 = *(void *)(v103 + 24);
                if (v105 >= 0x41) {
                  __int16 v104 = (void *)(v107 + 8 * (v106 >> 6));
                }
                if ((((*(void *)(v22 + 8 * v101) & v102) != 0) ^ (*v104 >> v106)))
                {
                  if ((*(void *)(v22 + 8 * v101) & v102) != 0) {
                    goto LABEL_123;
                  }
                }
                else
                {
                  uint64_t v108 = v107 - 8;
                  unint64_t v109 = (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8;
                  while (v109)
                  {
                    unint64_t v110 = *(void *)(v22 - 8 + v109);
                    unint64_t v111 = *(void *)(v108 + v109);
                    v109 -= 8;
                    if (v110 != v111)
                    {
                      if (v110 <= v111) {
                        goto LABEL_123;
                      }
                      goto LABEL_111;
                    }
                  }
                }
              }
            }
            while (v22 << -(char)v97 >> -(char)v97 >= (uint64_t)(*v104 << (64 - v97)) >> (64 - v97));
LABEL_123:
            unint64_t v112 = a2;
            if (v10 >= (unint64_t)a2) {
              goto LABEL_164;
            }
            uint64_t v113 = (v97 - 1) >> 6;
            uint64_t v114 = 1 << (v97 - 1);
            uint64_t result = v22 << -(char)v97 >> -(char)v97;
            for (uint64_t i = a2; ; i -= 2)
            {
              unint64_t v112 = i - 2;
              unint64_t v116 = (void *)(v99 + 24);
              if (v97 > 0x40)
              {
                unsigned int v117 = *(_DWORD *)(v99 + 32);
                unsigned int v118 = v117 - 1;
                uint64_t v119 = *(void *)(v99 + 24);
                if (v117 >= 0x41) {
                  unint64_t v116 = (void *)(v119 + 8 * (v118 >> 6));
                }
                if (((((*(void *)(v22 + 8 * v113) & v114) != 0) ^ (*v116 >> v118)) & 1) == 0)
                {
                  uint64_t v120 = v119 - 8;
                  unint64_t v121 = (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8;
                  while (v121)
                  {
                    unint64_t v122 = *(void *)(v22 + v121 - 8);
                    unint64_t v123 = *(void *)(v120 + v121);
                    v121 -= 8;
                    if (v122 != v123)
                    {
                      if (v122 <= v123) {
                        goto LABEL_127;
                      }
                      break;
                    }
                  }
LABEL_164:
                  while (v10 < (unint64_t)v112)
                  {
                    long long v461 = *(_OWORD *)v10;
                    long long v470 = *(_OWORD *)(v10 + 16);
                    long long v124 = v112[1];
                    *(_OWORD *)unint64_t v10 = *v112;
                    *(_OWORD *)(v10 + 16) = v124;
                    *unint64_t v112 = v461;
                    v112[1] = v470;
                    uint64_t v125 = *(unsigned int *)(v16 + 32);
                    uint64_t v126 = (v125 - 1) >> 6;
                    uint64_t v127 = 1 << (v125 - 1);
                    char v128 = 64 - v125;
                    do
                    {
                      while (1)
                      {
LABEL_139:
                        while (1)
                        {
                          uint64_t v129 = *(void *)(v10 + 40);
                          v10 += 32;
                          uint64_t v130 = (void *)(v129 + 24);
                          if (v125 > 0x40) {
                            break;
                          }
                          uint64_t v131 = *v18;
                          if (*v18 << v128 >> v128 < (uint64_t)(*v130 << v128) >> v128) {
                            goto LABEL_151;
                          }
                        }
                        uint64_t v131 = *v18;
                        unsigned int v132 = *(_DWORD *)(v129 + 32);
                        unsigned int v133 = v132 - 1;
                        uint64_t v134 = *(void *)(v129 + 24);
                        if (v132 >= 0x41) {
                          uint64_t v130 = (void *)(v134 + 8 * (v133 >> 6));
                        }
                        if ((((*(void *)(*v18 + 8 * v126) & v127) != 0) ^ (*v130 >> v133))) {
                          break;
                        }
                        uint64_t v135 = v134 - 8;
                        unint64_t v136 = ((unint64_t)(v125 + 63) >> 3) & 0x3FFFFFF8;
                        while (v136)
                        {
                          unint64_t v137 = *(void *)(v131 + v136 - 8);
                          unint64_t v138 = *(void *)(v135 + v136);
                          v136 -= 8;
                          if (v137 != v138)
                          {
                            if (v137 > v138) {
                              goto LABEL_139;
                            }
                            goto LABEL_151;
                          }
                        }
                      }
                    }
                    while ((*(void *)(*v18 + 8 * v126) & v127) == 0);
LABEL_151:
                    uint64_t result = v131 << v128 >> v128;
                    while (1)
                    {
LABEL_152:
                      while (1)
                      {
                        uint64_t v139 = *((void *)v112 - 3);
                        v112 -= 2;
                        uint64_t v140 = (void *)(v139 + 24);
                        if (v125 > 0x40) {
                          break;
                        }
                        if (result >= (uint64_t)(*v140 << v128) >> v128) {
                          goto LABEL_164;
                        }
                      }
                      unsigned int v141 = *(_DWORD *)(v139 + 32);
                      unsigned int v142 = v141 - 1;
                      uint64_t v143 = *(void *)(v139 + 24);
                      if (v141 >= 0x41) {
                        uint64_t v140 = (void *)(v143 + 8 * (v142 >> 6));
                      }
                      if (((((*(void *)(v131 + 8 * v126) & v127) != 0) ^ (*v140 >> v142)) & 1) == 0) {
                        break;
                      }
                      if ((*(void *)(v131 + 8 * v126) & v127) == 0) {
                        goto LABEL_164;
                      }
                    }
                    uint64_t v144 = v143 - 8;
                    unint64_t v145 = ((unint64_t)(v125 + 63) >> 3) & 0x3FFFFFF8;
                    while (v145)
                    {
                      unint64_t v146 = *(void *)(v131 - 8 + v145);
                      unint64_t v147 = *(void *)(v144 + v145);
                      v145 -= 8;
                      if (v146 != v147)
                      {
                        if (v146 <= v147) {
                          goto LABEL_152;
                        }
                        goto LABEL_164;
                      }
                    }
                  }
                  BOOL v4 = v10 - 32 >= v9;
                  BOOL v5 = v10 - 32 == v9;
                  if (v10 - 32 != v9)
                  {
                    long long v148 = *(_OWORD *)(v10 - 16);
                    *(_OWORD *)unint64_t v9 = *(_OWORD *)(v10 - 32);
                    *(_OWORD *)(v9 + 16) = v148;
                  }
                  a4 = 0;
                  *(void *)(v10 - 32) = v98;
                  *(void *)(v10 - 24) = v16;
                  *(_OWORD *)(v10 - 16) = v458;
                  goto LABEL_3;
                }
                if ((*(void *)(v22 + 8 * v113) & v114) == 0) {
                  goto LABEL_164;
                }
              }
              else if (result >= (uint64_t)(*v116 << (64 - v97)) >> (64 - v97))
              {
                goto LABEL_164;
              }
LABEL_127:
              uint64_t v99 = *((void *)i - 7);
            }
          }
          unint64_t v10 = v9 + 32;
          if (v9 + 32 < (unint64_t)a2)
          {
            uint64_t v159 = (v97 - 1) >> 6;
            uint64_t v160 = 1 << (v97 - 1);
            uint64_t result = (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8;
            unint64_t v161 = v9;
            while (1)
            {
              uint64_t v162 = *(void *)(v161 + 40);
              unint64_t v161 = v10;
              uint64_t v163 = (void *)(v162 + 24);
              if (v97 > 0x40)
              {
                unsigned int v164 = *(_DWORD *)(v162 + 32);
                unsigned int v165 = v164 - 1;
                uint64_t v166 = *(void *)(v162 + 24);
                if (v164 >= 0x41) {
                  uint64_t v163 = (void *)(v166 + 8 * (v165 >> 6));
                }
                if ((((*(void *)(v22 + 8 * v159) & v160) != 0) ^ (*v163 >> v165)))
                {
                  if ((*(void *)(v22 + 8 * v159) & v160) != 0) {
                    goto LABEL_123;
                  }
                }
                else
                {
                  uint64_t v167 = v166 - 8;
                  unint64_t v168 = (((unint64_t)v97 + 63) >> 3) & 0x3FFFFFF8;
                  while (v168)
                  {
                    unint64_t v169 = *(void *)(v22 + v168 - 8);
                    unint64_t v170 = *(void *)(v167 + v168);
                    v168 -= 8;
                    if (v169 != v170)
                    {
                      if (v169 > v170) {
                        break;
                      }
                      goto LABEL_123;
                    }
                  }
                }
              }
              else if (v22 << -(char)v97 >> -(char)v97 < (uint64_t)(*v163 << (64 - v97)) >> (64 - v97))
              {
                goto LABEL_123;
              }
              v10 += 32;
              if (v161 + 32 >= (unint64_t)a2) {
                goto LABEL_123;
              }
            }
          }
          goto LABEL_123;
        }
      }
    }
    uint64_t v23 = *(void *)v9;
    long long v457 = *(_OWORD *)(v9 + 16);
    uint64_t v24 = (uint64_t *)(v16 + 24);
    unint64_t v25 = v9;
    while (1)
    {
LABEL_15:
      while (1)
      {
        unint64_t v26 = v25;
        v25 += 32;
        uint64_t v27 = *(void *)(v26 + 40);
        uint64_t v28 = *(unsigned int *)(v27 + 32);
        if (v28 > 0x40) {
          break;
        }
        uint64_t v29 = -v28;
        uint64_t v30 = (uint64_t)(*(void *)(v27 + 24) << v29) >> v29;
        uint64_t v31 = *v24;
        if (v30 >= *v24 << v29 >> v29) {
          goto LABEL_28;
        }
      }
      uint64_t v32 = *(void *)(v27 + 24);
      uint64_t v33 = *(void *)(v32 + 8 * ((v28 - 1) >> 6)) & (1 << (v28 - 1));
      unsigned int v34 = *(_DWORD *)(v16 + 32);
      unsigned int v35 = v34 - 1;
      uint64_t v31 = *(void *)(v16 + 24);
      unint64_t v36 = (void *)(v34 >= 0x41 ? v31 + 8 * (v35 >> 6) : v16 + 24);
      if ((v33 != 0) == ((*v36 >> v35) & 1)) {
        break;
      }
      if (!v33) {
        goto LABEL_28;
      }
    }
    unint64_t v37 = ((unint64_t)(v28 + 63) >> 3) & 0x3FFFFFF8;
    uint64_t v38 = v32 - 8;
    while (v37)
    {
      unint64_t v39 = *(void *)(v38 + v37);
      unint64_t v40 = *(void *)(v31 + v37 - 8);
      v37 -= 8;
      if (v39 != v40)
      {
        if (v39 <= v40) {
          goto LABEL_15;
        }
        break;
      }
    }
LABEL_28:
    if (v26 == v9)
    {
      long long v41 = a2;
      if (v25 < (unint64_t)a2)
      {
        long long v41 = a2;
        do
        {
LABEL_46:
          while (1)
          {
            uint64_t v53 = *((void *)v41 - 3);
            v41 -= 2;
            uint64_t v54 = *(unsigned int *)(v53 + 32);
            if (v54 <= 0x40) {
              break;
            }
            uint64_t v55 = *(void *)(v53 + 24);
            uint64_t v56 = *(void *)(v55 + 8 * ((v54 - 1) >> 6)) & (1 << (v54 - 1));
            unsigned int v57 = *(_DWORD *)(v16 + 32);
            unsigned int v58 = v57 - 1;
            if (v57 >= 0x41) {
              __int16 v59 = (void *)(v31 + 8 * (v58 >> 6));
            }
            else {
              __int16 v59 = (void *)(v16 + 24);
            }
            if ((v56 != 0) == ((*v59 >> v58) & 1))
            {
              unint64_t v61 = ((unint64_t)(v54 + 63) >> 3) & 0x3FFFFFF8;
              uint64_t v62 = v55 - 8;
              do
              {
                if (!v61)
                {
                  if (v25 < (unint64_t)v41) {
                    goto LABEL_46;
                  }
                  goto LABEL_71;
                }
                unint64_t v63 = *(void *)(v62 + v61);
                unint64_t v64 = *(void *)(v31 - 8 + v61);
                v61 -= 8;
              }
              while (v63 == v64);
              if (v63 <= v64 || v25 >= (unint64_t)v41) {
                goto LABEL_71;
              }
            }
            else
            {
              if (v56) {
                BOOL v60 = 1;
              }
              else {
                BOOL v60 = v25 >= (unint64_t)v41;
              }
              if (v60) {
                goto LABEL_71;
              }
            }
          }
        }
        while ((uint64_t)(*(void *)(v53 + 24) << -(char)v54) >> -(char)v54 >= v31 << -(char)v54 >> -(char)v54
             && v25 < (unint64_t)v41);
      }
    }
    else
    {
      long long v41 = a2;
      do
      {
LABEL_30:
        while (1)
        {
          uint64_t v42 = *((void *)v41 - 3);
          v41 -= 2;
          uint64_t v43 = *(unsigned int *)(v42 + 32);
          if (v43 <= 0x40) {
            break;
          }
          uint64_t v44 = *(void *)(v42 + 24);
          uint64_t v45 = *(void *)(v44 + 8 * ((v43 - 1) >> 6)) & (1 << (v43 - 1));
          unsigned int v46 = *(_DWORD *)(v16 + 32);
          unsigned int v47 = v46 - 1;
          if (v46 >= 0x41) {
            uint64_t v48 = (void *)(v31 + 8 * (v47 >> 6));
          }
          else {
            uint64_t v48 = (void *)(v16 + 24);
          }
          if ((v45 != 0) == ((*v48 >> v47) & 1))
          {
            unint64_t v49 = ((unint64_t)(v43 + 63) >> 3) & 0x3FFFFFF8;
            uint64_t v50 = v44 - 8;
            while (v49)
            {
              unint64_t v51 = *(void *)(v50 + v49);
              unint64_t v52 = *(void *)(v31 - 8 + v49);
              v49 -= 8;
              if (v51 != v52)
              {
                if (v51 <= v52) {
                  goto LABEL_71;
                }
                goto LABEL_30;
              }
            }
          }
          else if (v45)
          {
            goto LABEL_71;
          }
        }
      }
      while ((uint64_t)(*(void *)(v42 + 24) << -(char)v43) >> -(char)v43 >= v31 << -(char)v43 >> -(char)v43);
    }
LABEL_71:
    unint64_t v10 = v25;
    if (v25 < (unint64_t)v41)
    {
      uint64_t v67 = v41;
      do
      {
        long long v68 = *(_OWORD *)v10;
        long long v469 = *(_OWORD *)(v10 + 16);
        long long v69 = v67[1];
        *(_OWORD *)unint64_t v10 = *v67;
        *(_OWORD *)(v10 + 16) = v69;
        long long *v67 = v68;
        v67[1] = v469;
        do
        {
          while (1)
          {
            while (1)
            {
              uint64_t v70 = *(void *)(v10 + 40);
              v10 += 32;
              uint64_t v71 = *(unsigned int *)(v70 + 32);
              if (v71 > 0x40) {
                break;
              }
              uint64_t v72 = -v71;
              uint64_t v73 = (uint64_t)(*(void *)(v70 + 24) << v72) >> v72;
              uint64_t v74 = *v24;
              if (v73 >= *v24 << v72 >> v72) {
                goto LABEL_87;
              }
            }
            uint64_t v75 = *(void *)(v70 + 24);
            uint64_t v76 = *(void *)(v75 + 8 * ((v71 - 1) >> 6)) & (1 << (v71 - 1));
            unsigned int v77 = *(_DWORD *)(v16 + 32);
            unsigned int v78 = v77 - 1;
            uint64_t v74 = *(void *)(v16 + 24);
            int v79 = (void *)(v77 >= 0x41 ? v74 + 8 * (v78 >> 6) : v16 + 24);
            if ((v76 != 0) == ((*v79 >> v78) & 1)) {
              break;
            }
            if (!v76) {
              goto LABEL_87;
            }
          }
          unint64_t v80 = ((unint64_t)(v71 + 63) >> 3) & 0x3FFFFFF8;
          uint64_t v81 = v75 - 8;
          do
          {
            if (!v80) {
              goto LABEL_87;
            }
            unint64_t v82 = *(void *)(v81 + v80);
            unint64_t v83 = *(void *)(v74 + v80 - 8);
            v80 -= 8;
          }
          while (v82 == v83);
        }
        while (v82 <= v83);
        do
        {
LABEL_87:
          while (1)
          {
            uint64_t v84 = *((void *)v67 - 3);
            v67 -= 2;
            uint64_t v85 = *(unsigned int *)(v84 + 32);
            if (v85 <= 0x40) {
              break;
            }
            uint64_t v86 = *(void *)(v84 + 24);
            uint64_t v87 = *(void *)(v86 + 8 * ((v85 - 1) >> 6)) & (1 << (v85 - 1));
            unsigned int v88 = *(_DWORD *)(v16 + 32);
            unsigned int v89 = v88 - 1;
            if (v88 >= 0x41) {
              long long v90 = (void *)(v74 + 8 * (v89 >> 6));
            }
            else {
              long long v90 = (void *)(v16 + 24);
            }
            if ((v87 != 0) == ((*v90 >> v89) & 1))
            {
              unint64_t v91 = ((unint64_t)(v85 + 63) >> 3) & 0x3FFFFFF8;
              uint64_t v92 = v86 - 8;
              while (v91)
              {
                unint64_t v93 = *(void *)(v92 + v91);
                unint64_t v94 = *(void *)(v74 - 8 + v91);
                v91 -= 8;
                if (v93 != v94)
                {
                  if (v93 <= v94) {
                    goto LABEL_100;
                  }
                  goto LABEL_87;
                }
              }
            }
            else if (v87)
            {
              goto LABEL_100;
            }
          }
        }
        while ((uint64_t)(*(void *)(v84 + 24) << -(char)v85) >> -(char)v85 >= v74 << -(char)v85 >> -(char)v85);
LABEL_100:
        ;
      }
      while (v10 < (unint64_t)v67);
    }
    if (v10 - 32 != v9)
    {
      long long v95 = *(_OWORD *)(v10 - 16);
      *(_OWORD *)unint64_t v9 = *(_OWORD *)(v10 - 32);
      *(_OWORD *)(v9 + 16) = v95;
    }
    *(void *)(v10 - 32) = v23;
    *(void *)(v10 - 24) = v16;
    *(_OWORD *)(v10 - 16) = v457;
    if (v25 >= (unint64_t)v41)
    {
      BOOL v96 = sub_1CCD568F4(v9, v10 - 32);
      uint64_t result = sub_1CCD568F4(v10, (uint64_t)a2);
      if (result)
      {
        a2 = (long long *)(v10 - 32);
        if (v96) {
          return result;
        }
        goto LABEL_2;
      }
      if (v96) {
        continue;
      }
    }
    uint64_t result = sub_1CCD54A0C(v9, v10 - 32, a3, a4 & 1);
    a4 = 0;
  }
  switch(v12)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v173 = *((void *)a2 - 3);
      uint64_t v174 = *(void *)(v10 + 8);
      BOOL v175 = (void *)(v174 + 24);
      uint64_t v176 = *(unsigned int *)(v173 + 32);
      if (v176 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v173 + 24) << -(char)v176) >> -(char)v176 >= (uint64_t)(*v175 << -(char)v176) >> -(char)v176) {
          return result;
        }
        goto LABEL_208;
      }
      uint64_t v402 = *(void *)(v173 + 24);
      uint64_t v403 = *(void *)(v402 + 8 * ((v176 - 1) >> 6)) & (1 << (v176 - 1));
      unsigned int v404 = *(_DWORD *)(v174 + 32);
      unsigned int v405 = v404 - 1;
      uint64_t v406 = *(void *)(v174 + 24);
      if (v404 >= 0x41) {
        BOOL v175 = (void *)(v406 + 8 * (v405 >> 6));
      }
      if ((v403 != 0) == ((*v175 >> v405) & 1))
      {
        unint64_t v427 = v176 + 63;
        uint64_t v428 = v406 - 8;
        uint64_t v429 = (v427 >> 3) & 0x3FFFFFF8;
        uint64_t v430 = v402 - 8;
        do
        {
          if (!v429) {
            return result;
          }
          unint64_t v431 = *(void *)(v430 + v429);
          unint64_t v432 = *(void *)(v428 + v429);
          v429 -= 8;
        }
        while (v431 == v432);
        if (v431 <= v432)
        {
LABEL_208:
          long long v462 = *(_OWORD *)v10;
          long long v471 = *(_OWORD *)(v10 + 16);
          long long v177 = *(a2 - 1);
          *(_OWORD *)unint64_t v10 = *(a2 - 2);
          *(_OWORD *)(v10 + 16) = v177;
          *(a2 - 2) = v462;
          *(a2 - 1) = v471;
          return result;
        }
      }
      else if (v403)
      {
        goto LABEL_208;
      }
      return result;
    case 3:
      return (uint64_t)sub_1CCD5659C((long long *)v10, (long long *)(v10 + 32), a2 - 2);
    case 4:
      return (uint64_t)sub_1CCD57038(v10, v10 + 32, v10 + 64, (uint64_t)(a2 - 2));
    case 5:
      uint64_t v178 = (long long *)(v10 + 32);
      unsigned int v179 = (long long *)(v10 + 64);
      BOOL v180 = (long long *)(v10 + 96);
      uint64_t result = (uint64_t)sub_1CCD57038(v10, v10 + 32, v10 + 64, v10 + 96);
      uint64_t v181 = *((void *)a2 - 3);
      uint64_t v182 = *(void *)(v10 + 104);
      int v183 = (void *)(v182 + 24);
      uint64_t v184 = *(unsigned int *)(v181 + 32);
      if (v184 > 0x40)
      {
        uint64_t v407 = *(void *)(v181 + 24);
        uint64_t v408 = *(void *)(v407 + 8 * ((v184 - 1) >> 6)) & (1 << (v184 - 1));
        unsigned int v409 = *(_DWORD *)(v182 + 32);
        unsigned int v410 = v409 - 1;
        uint64_t v411 = *(void *)(v182 + 24);
        if (v409 >= 0x41) {
          int v183 = (void *)(v411 + 8 * (v410 >> 6));
        }
        if ((v408 != 0) == ((*v183 >> v410) & 1))
        {
          unint64_t v433 = v184 + 63;
          uint64_t v434 = v411 - 8;
          uint64_t v435 = (v433 >> 3) & 0x3FFFFFF8;
          uint64_t v436 = v407 - 8;
          do
          {
            if (!v435) {
              return result;
            }
            unint64_t v437 = *(void *)(v436 + v435);
            unint64_t v438 = *(void *)(v434 + v435);
            v435 -= 8;
          }
          while (v437 == v438);
          if (v437 > v438) {
            return result;
          }
        }
        else if (!v408)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v181 + 24) << -(char)v184) >> -(char)v184 >= (uint64_t)(*v183 << -(char)v184) >> -(char)v184)
      {
        return result;
      }
      long long v185 = *v180;
      long long v472 = *(_OWORD *)(v10 + 112);
      long long v186 = *(a2 - 1);
      *BOOL v180 = *(a2 - 2);
      *(_OWORD *)(v10 + 112) = v186;
      *(a2 - 2) = v185;
      *(a2 - 1) = v472;
      uint64_t v187 = *(void *)(v10 + 104);
      uint64_t v188 = *(void *)(v10 + 72);
      uint64_t v189 = (void *)(v188 + 24);
      uint64_t v190 = *(unsigned int *)(v187 + 32);
      if (v190 > 0x40)
      {
        uint64_t v412 = *(void *)(v187 + 24);
        uint64_t v413 = *(void *)(v412 + 8 * ((v190 - 1) >> 6)) & (1 << (v190 - 1));
        unsigned int v414 = *(_DWORD *)(v188 + 32);
        unsigned int v415 = v414 - 1;
        uint64_t v416 = *(void *)(v188 + 24);
        if (v414 >= 0x41) {
          uint64_t v189 = (void *)(v416 + 8 * (v415 >> 6));
        }
        if ((v413 != 0) == ((*v189 >> v415) & 1))
        {
          unint64_t v439 = v190 + 63;
          uint64_t v440 = v416 - 8;
          uint64_t v441 = (v439 >> 3) & 0x3FFFFFF8;
          uint64_t v442 = v412 - 8;
          do
          {
            if (!v441) {
              return result;
            }
            unint64_t v443 = *(void *)(v442 + v441);
            unint64_t v444 = *(void *)(v440 + v441);
            v441 -= 8;
          }
          while (v443 == v444);
          if (v443 > v444) {
            return result;
          }
        }
        else if (!v413)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v187 + 24) << -(char)v190) >> -(char)v190 >= (uint64_t)(*v189 << -(char)v190) >> -(char)v190)
      {
        return result;
      }
      long long v192 = *v179;
      long long v191 = *(_OWORD *)(v10 + 80);
      long long v193 = *(_OWORD *)(v10 + 112);
      long long *v179 = *v180;
      *(_OWORD *)(v10 + 80) = v193;
      *BOOL v180 = v192;
      *(_OWORD *)(v10 + 112) = v191;
      uint64_t v194 = *(void *)(v10 + 72);
      uint64_t v195 = *(void *)(v10 + 40);
      BOOL v196 = (void *)(v195 + 24);
      uint64_t v197 = *(unsigned int *)(v194 + 32);
      if (v197 > 0x40)
      {
        uint64_t v417 = *(void *)(v194 + 24);
        uint64_t v418 = *(void *)(v417 + 8 * ((v197 - 1) >> 6)) & (1 << (v197 - 1));
        unsigned int v419 = *(_DWORD *)(v195 + 32);
        unsigned int v420 = v419 - 1;
        uint64_t v421 = *(void *)(v195 + 24);
        if (v419 >= 0x41) {
          BOOL v196 = (void *)(v421 + 8 * (v420 >> 6));
        }
        if ((v418 != 0) == ((*v196 >> v420) & 1))
        {
          unint64_t v445 = v197 + 63;
          uint64_t v446 = v421 - 8;
          uint64_t v447 = (v445 >> 3) & 0x3FFFFFF8;
          uint64_t v448 = v417 - 8;
          do
          {
            if (!v447) {
              return result;
            }
            unint64_t v449 = *(void *)(v448 + v447);
            unint64_t v450 = *(void *)(v446 + v447);
            v447 -= 8;
          }
          while (v449 == v450);
          if (v449 > v450) {
            return result;
          }
        }
        else if (!v418)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v194 + 24) << -(char)v197) >> -(char)v197 >= (uint64_t)(*v196 << -(char)v197) >> -(char)v197)
      {
        return result;
      }
      long long v199 = *v178;
      long long v198 = *(_OWORD *)(v10 + 48);
      long long v200 = *(_OWORD *)(v10 + 80);
      *uint64_t v178 = *v179;
      *(_OWORD *)(v10 + 48) = v200;
      long long *v179 = v199;
      *(_OWORD *)(v10 + 80) = v198;
      uint64_t v201 = *(void *)(v10 + 40);
      uint64_t v202 = *(void *)(v10 + 8);
      unint64_t v203 = (void *)(v202 + 24);
      uint64_t v204 = *(unsigned int *)(v201 + 32);
      if (v204 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v201 + 24) << -(char)v204) >> -(char)v204 >= (uint64_t)(*v203 << -(char)v204) >> -(char)v204) {
          return result;
        }
        goto LABEL_223;
      }
      uint64_t v422 = *(void *)(v201 + 24);
      uint64_t v423 = *(void *)(v422 + 8 * ((v204 - 1) >> 6)) & (1 << (v204 - 1));
      unsigned int v424 = *(_DWORD *)(v202 + 32);
      unsigned int v425 = v424 - 1;
      uint64_t v426 = *(void *)(v202 + 24);
      if (v424 >= 0x41) {
        unint64_t v203 = (void *)(v426 + 8 * (v425 >> 6));
      }
      if ((v423 != 0) == ((*v203 >> v425) & 1))
      {
        unint64_t v451 = v204 + 63;
        uint64_t v452 = v426 - 8;
        uint64_t v453 = (v451 >> 3) & 0x3FFFFFF8;
        uint64_t v454 = v422 - 8;
        do
        {
          if (!v453) {
            return result;
          }
          unint64_t v455 = *(void *)(v454 + v453);
          unint64_t v456 = *(void *)(v452 + v453);
          v453 -= 8;
        }
        while (v455 == v456);
        if (v455 <= v456)
        {
LABEL_223:
          long long v463 = *(_OWORD *)v10;
          long long v473 = *(_OWORD *)(v10 + 16);
          long long v205 = *(_OWORD *)(v10 + 48);
          *(_OWORD *)unint64_t v10 = *v178;
          *(_OWORD *)(v10 + 16) = v205;
          *uint64_t v178 = v463;
          *(_OWORD *)(v10 + 48) = v473;
          return result;
        }
      }
      else if (v423)
      {
        goto LABEL_223;
      }
      break;
    default:
      JUMPOUT(0);
  }
  return result;
}

long long *sub_1CCD5659C(long long *result, long long *a2, long long *a3)
{
  uint64_t v3 = *((void *)a2 + 1);
  BOOL v4 = (uint64_t *)(v3 + 24);
  uint64_t v5 = *((void *)result + 1);
  int v6 = (void *)(v5 + 24);
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  if (v7 > 0x40)
  {
    uint64_t v8 = *v4;
    uint64_t v9 = *(void *)(*v4 + 8 * ((v7 - 1) >> 6)) >> (v7 - 1);
    unsigned int v25 = *(_DWORD *)(v5 + 32);
    unsigned int v26 = v25 - 1;
    uint64_t v27 = *(void *)(v5 + 24);
    if (v25 >= 0x41) {
      int v6 = (void *)(v27 + 8 * (v26 >> 6));
    }
    if (((v9 ^ (*v6 >> v26)) & 1) == 0)
    {
      uint64_t v28 = v27 - 8;
      unint64_t v29 = ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8;
      while (v29)
      {
        unint64_t v30 = *(void *)(v8 + v29 - 8);
        unint64_t v31 = *(void *)(v28 + v29);
        v29 -= 8;
        if (v30 != v31)
        {
          LOBYTE(v9) = v30 <= v31;
          goto LABEL_3;
        }
      }
      LOBYTE(v9) = 0;
    }
  }
  else
  {
    uint64_t v8 = *v4;
    LOBYTE(v9) = *v4 << -(char)v7 >> -(char)v7 < (uint64_t)(*v6 << -(char)v7) >> -(char)v7;
  }
LABEL_3:
  unint64_t v10 = *((void *)a3 + 1);
  uint64_t v11 = *(unsigned int *)(v10 + 32);
  if (v11 > 0x40)
  {
    uint64_t v32 = *(void *)(v10 + 24);
    unint64_t v10 = *(void *)(v32 + 8 * ((v11 - 1) >> 6)) >> (v11 - 1);
    unsigned int v33 = v7 - 1;
    if (v7 >= 0x41) {
      BOOL v4 = (uint64_t *)(v8 + 8 * (v33 >> 6));
    }
    if (((v10 ^ ((unint64_t)*v4 >> v33)) & 1) == 0)
    {
      uint64_t v34 = v8 - 8;
      unint64_t v35 = ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8;
      while (v35)
      {
        unint64_t v36 = *(void *)(v32 - 8 + v35);
        unint64_t v10 = *(void *)(v34 + v35);
        v35 -= 8;
        if (v36 != v10)
        {
          LOBYTE(v10) = v36 <= v10;
          goto LABEL_5;
        }
      }
      if ((v9 & 1) == 0) {
        return result;
      }
      goto LABEL_28;
    }
  }
  else
  {
    LOBYTE(v10) = (uint64_t)(*(void *)(v10 + 24) << -(char)v11) >> -(char)v11 < v8 << -(char)v11 >> -(char)v11;
  }
LABEL_5:
  if ((v9 & 1) == 0)
  {
    if ((v10 & 1) == 0) {
      return result;
    }
    long long v16 = *a2;
    long long v15 = a2[1];
    long long v17 = a3[1];
    *a2 = *a3;
    a2[1] = v17;
    *a3 = v16;
    a3[1] = v15;
    uint64_t v18 = *((void *)a2 + 1);
    uint64_t v19 = *((void *)result + 1);
    uint64_t v20 = (void *)(v19 + 24);
    uint64_t v21 = *(unsigned int *)(v18 + 32);
    if (v21 > 0x40)
    {
      uint64_t v50 = *(void *)(v18 + 24);
      uint64_t v51 = *(void *)(v50 + 8 * ((v21 - 1) >> 6)) & (1 << (v21 - 1));
      unsigned int v52 = *(_DWORD *)(v19 + 32);
      unsigned int v53 = v52 - 1;
      uint64_t v54 = *(void *)(v19 + 24);
      if (v52 >= 0x41) {
        uint64_t v20 = (void *)(v54 + 8 * (v53 >> 6));
      }
      if ((v51 != 0) == ((*v20 >> v53) & 1))
      {
        unint64_t v61 = v21 + 63;
        uint64_t v62 = v54 - 8;
        uint64_t v63 = (v61 >> 3) & 0x3FFFFFF8;
        uint64_t v64 = v50 - 8;
        while (v63)
        {
          unint64_t v65 = *(void *)(v64 + v63);
          unint64_t v66 = *(void *)(v62 + v63);
          v63 -= 8;
          if (v65 != v66)
          {
            if (v65 <= v66) {
              goto LABEL_11;
            }
            return result;
          }
        }
        return result;
      }
      if (!v51) {
        return result;
      }
    }
    else if ((uint64_t)(*(void *)(v18 + 24) << -(char)v21) >> -(char)v21 >= (uint64_t)(*v20 << -(char)v21) >> -(char)v21)
    {
      return result;
    }
LABEL_11:
    long long v23 = *result;
    long long v22 = result[1];
    long long v24 = a2[1];
    llvm *result = *a2;
    result[1] = v24;
    *a2 = v23;
    a2[1] = v22;
    return result;
  }
  if (v10)
  {
    long long v13 = *result;
    long long v12 = result[1];
    long long v14 = a3[1];
    llvm *result = *a3;
    result[1] = v14;
LABEL_31:
    *a3 = v13;
    a3[1] = v12;
    return result;
  }
LABEL_28:
  long long v38 = *result;
  long long v37 = result[1];
  long long v39 = a2[1];
  llvm *result = *a2;
  result[1] = v39;
  *a2 = v38;
  a2[1] = v37;
  uint64_t v40 = *((void *)a3 + 1);
  uint64_t v41 = *((void *)a2 + 1);
  uint64_t v42 = (void *)(v41 + 24);
  uint64_t v43 = *(unsigned int *)(v40 + 32);
  if (v43 <= 0x40)
  {
    if ((uint64_t)(*(void *)(v40 + 24) << -(char)v43) >> -(char)v43 >= (uint64_t)(*v42 << -(char)v43) >> -(char)v43) {
      return result;
    }
    goto LABEL_30;
  }
  uint64_t v45 = *(void *)(v40 + 24);
  uint64_t v46 = *(void *)(v45 + 8 * ((v43 - 1) >> 6)) & (1 << (v43 - 1));
  unsigned int v47 = *(_DWORD *)(v41 + 32);
  unsigned int v48 = v47 - 1;
  uint64_t v49 = *(void *)(v41 + 24);
  if (v47 >= 0x41) {
    uint64_t v42 = (void *)(v49 + 8 * (v48 >> 6));
  }
  if ((v46 != 0) == ((*v42 >> v48) & 1))
  {
    unint64_t v55 = v43 + 63;
    uint64_t v56 = v49 - 8;
    uint64_t v57 = (v55 >> 3) & 0x3FFFFFF8;
    uint64_t v58 = v45 - 8;
    while (v57)
    {
      unint64_t v59 = *(void *)(v58 + v57);
      unint64_t v60 = *(void *)(v56 + v57);
      v57 -= 8;
      if (v59 != v60)
      {
        if (v59 <= v60) {
          goto LABEL_30;
        }
        return result;
      }
    }
  }
  else if (v46)
  {
LABEL_30:
    long long v13 = *a2;
    long long v12 = a2[1];
    long long v44 = a3[1];
    *a2 = *a3;
    a2[1] = v44;
    goto LABEL_31;
  }
  return result;
}

BOOL sub_1CCD568F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(void *)(a2 - 24);
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = (void *)(v7 + 24);
      uint64_t v9 = *(unsigned int *)(v6 + 32);
      if (v9 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v6 + 24) << -(char)v9) >> -(char)v9 >= (uint64_t)(*v8 << -(char)v9) >> -(char)v9) {
          return result;
        }
        goto LABEL_4;
      }
      uint64_t v80 = *(void *)(v6 + 24);
      uint64_t v81 = *(void *)(v80 + 8 * ((v9 - 1) >> 6)) & (1 << (v9 - 1));
      unsigned int v82 = *(_DWORD *)(v7 + 32);
      unsigned int v83 = v82 - 1;
      uint64_t v84 = *(void *)(v7 + 24);
      if (v82 >= 0x41) {
        uint64_t v8 = (void *)(v84 + 8 * (v83 >> 6));
      }
      if ((v81 != 0) != ((*v8 >> v83) & 1))
      {
        if (!v81) {
          return result;
        }
LABEL_4:
        long long v11 = *(_OWORD *)a1;
        long long v10 = *(_OWORD *)(a1 + 16);
        long long v12 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v12;
        *(_OWORD *)(a2 - 32) = v11;
        *(_OWORD *)(a2 - 16) = v10;
        return 1;
      }
      unint64_t v105 = v9 + 63;
      uint64_t v106 = v84 - 8;
      uint64_t v107 = (v105 >> 3) & 0x3FFFFFF8;
      uint64_t v108 = v80 - 8;
      do
      {
        if (!v107) {
          return 1;
        }
        unint64_t v109 = *(void *)(v108 + v107);
        unint64_t v110 = *(void *)(v106 + v107);
        v107 -= 8;
      }
      while (v109 == v110);
      if (v109 <= v110) {
        goto LABEL_4;
      }
      return 1;
    case 3:
      sub_1CCD5659C((long long *)a1, (long long *)(a1 + 32), (long long *)(a2 - 32));
      return 1;
    case 4:
      sub_1CCD57038(a1, a1 + 32, a1 + 64, a2 - 32);
      return 1;
    case 5:
      uint64_t v49 = (long long *)(a1 + 32);
      uint64_t v50 = (long long *)(a1 + 64);
      uint64_t v51 = (long long *)(a1 + 96);
      sub_1CCD57038(a1, a1 + 32, a1 + 64, a1 + 96);
      uint64_t v52 = *(void *)(a2 - 24);
      uint64_t v53 = *(void *)(a1 + 104);
      uint64_t v54 = (void *)(v53 + 24);
      uint64_t v55 = *(unsigned int *)(v52 + 32);
      if (v55 > 0x40)
      {
        uint64_t v85 = *(void *)(v52 + 24);
        uint64_t v86 = *(void *)(v85 + 8 * ((v55 - 1) >> 6)) & (1 << (v55 - 1));
        unsigned int v87 = *(_DWORD *)(v53 + 32);
        unsigned int v88 = v87 - 1;
        uint64_t v89 = *(void *)(v53 + 24);
        if (v87 >= 0x41) {
          uint64_t v54 = (void *)(v89 + 8 * (v88 >> 6));
        }
        if ((v86 != 0) == ((*v54 >> v88) & 1))
        {
          unint64_t v111 = v55 + 63;
          uint64_t v112 = v89 - 8;
          uint64_t v113 = (v111 >> 3) & 0x3FFFFFF8;
          uint64_t v114 = v85 - 8;
          do
          {
            if (!v113) {
              return 1;
            }
            unint64_t v115 = *(void *)(v114 + v113);
            unint64_t v116 = *(void *)(v112 + v113);
            v113 -= 8;
          }
          while (v115 == v116);
          if (v115 > v116) {
            return 1;
          }
        }
        else if (!v86)
        {
          return 1;
        }
      }
      else if ((uint64_t)(*(void *)(v52 + 24) << -(char)v55) >> -(char)v55 >= (uint64_t)(*v54 << -(char)v55) >> -(char)v55)
      {
        return 1;
      }
      long long v57 = *v51;
      long long v56 = *(_OWORD *)(a1 + 112);
      long long v58 = *(_OWORD *)(a2 - 16);
      long long *v51 = *(_OWORD *)(a2 - 32);
      *(_OWORD *)(a1 + 112) = v58;
      *(_OWORD *)(a2 - 32) = v57;
      *(_OWORD *)(a2 - 16) = v56;
      uint64_t v59 = *(void *)(a1 + 104);
      uint64_t v60 = *(void *)(a1 + 72);
      unint64_t v61 = (void *)(v60 + 24);
      uint64_t v62 = *(unsigned int *)(v59 + 32);
      if (v62 > 0x40)
      {
        uint64_t v90 = *(void *)(v59 + 24);
        uint64_t v91 = *(void *)(v90 + 8 * ((v62 - 1) >> 6)) & (1 << (v62 - 1));
        unsigned int v92 = *(_DWORD *)(v60 + 32);
        unsigned int v93 = v92 - 1;
        uint64_t v94 = *(void *)(v60 + 24);
        if (v92 >= 0x41) {
          unint64_t v61 = (void *)(v94 + 8 * (v93 >> 6));
        }
        if ((v91 != 0) == ((*v61 >> v93) & 1))
        {
          unint64_t v117 = v62 + 63;
          uint64_t v118 = v94 - 8;
          uint64_t v119 = (v117 >> 3) & 0x3FFFFFF8;
          uint64_t v120 = v90 - 8;
          do
          {
            if (!v119) {
              return 1;
            }
            unint64_t v121 = *(void *)(v120 + v119);
            unint64_t v122 = *(void *)(v118 + v119);
            v119 -= 8;
          }
          while (v121 == v122);
          if (v121 > v122) {
            return 1;
          }
        }
        else if (!v91)
        {
          return 1;
        }
      }
      else if ((uint64_t)(*(void *)(v59 + 24) << -(char)v62) >> -(char)v62 >= (uint64_t)(*v61 << -(char)v62) >> -(char)v62)
      {
        return 1;
      }
      long long v64 = *v50;
      long long v63 = *(_OWORD *)(a1 + 80);
      long long v65 = *(_OWORD *)(a1 + 112);
      long long *v50 = *v51;
      *(_OWORD *)(a1 + 80) = v65;
      long long *v51 = v64;
      *(_OWORD *)(a1 + 112) = v63;
      uint64_t v66 = *(void *)(a1 + 72);
      uint64_t v67 = *(void *)(a1 + 40);
      long long v68 = (void *)(v67 + 24);
      uint64_t v69 = *(unsigned int *)(v66 + 32);
      if (v69 > 0x40)
      {
        uint64_t v95 = *(void *)(v66 + 24);
        uint64_t v96 = *(void *)(v95 + 8 * ((v69 - 1) >> 6)) & (1 << (v69 - 1));
        unsigned int v97 = *(_DWORD *)(v67 + 32);
        unsigned int v98 = v97 - 1;
        uint64_t v99 = *(void *)(v67 + 24);
        if (v97 >= 0x41) {
          long long v68 = (void *)(v99 + 8 * (v98 >> 6));
        }
        if ((v96 != 0) == ((*v68 >> v98) & 1))
        {
          unint64_t v123 = v69 + 63;
          uint64_t v124 = v99 - 8;
          uint64_t v125 = (v123 >> 3) & 0x3FFFFFF8;
          uint64_t v126 = v95 - 8;
          do
          {
            if (!v125) {
              return 1;
            }
            unint64_t v127 = *(void *)(v126 + v125);
            unint64_t v128 = *(void *)(v124 + v125);
            v125 -= 8;
          }
          while (v127 == v128);
          if (v127 > v128) {
            return 1;
          }
        }
        else if (!v96)
        {
          return 1;
        }
      }
      else if ((uint64_t)(*(void *)(v66 + 24) << -(char)v69) >> -(char)v69 >= (uint64_t)(*v68 << -(char)v69) >> -(char)v69)
      {
        return 1;
      }
      long long v71 = *v49;
      long long v70 = *(_OWORD *)(a1 + 48);
      long long v72 = *(_OWORD *)(a1 + 80);
      long long *v49 = *v50;
      *(_OWORD *)(a1 + 48) = v72;
      long long *v50 = v71;
      *(_OWORD *)(a1 + 80) = v70;
      uint64_t v73 = *(void *)(a1 + 40);
      uint64_t v74 = *(void *)(a1 + 8);
      uint64_t v75 = (void *)(v74 + 24);
      uint64_t v76 = *(unsigned int *)(v73 + 32);
      if (v76 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v73 + 24) << -(char)v76) >> -(char)v76 >= (uint64_t)(*v75 << -(char)v76) >> -(char)v76) {
          return 1;
        }
        goto LABEL_47;
      }
      uint64_t v100 = *(void *)(v73 + 24);
      uint64_t v101 = *(void *)(v100 + 8 * ((v76 - 1) >> 6)) & (1 << (v76 - 1));
      unsigned int v102 = *(_DWORD *)(v74 + 32);
      unsigned int v103 = v102 - 1;
      uint64_t v104 = *(void *)(v74 + 24);
      if (v102 >= 0x41) {
        uint64_t v75 = (void *)(v104 + 8 * (v103 >> 6));
      }
      if ((v101 != 0) == ((*v75 >> v103) & 1))
      {
        unint64_t v129 = v76 + 63;
        uint64_t v130 = v104 - 8;
        uint64_t v131 = (v129 >> 3) & 0x3FFFFFF8;
        uint64_t v132 = v100 - 8;
        do
        {
          if (!v131) {
            return 1;
          }
          unint64_t v133 = *(void *)(v132 + v131);
          unint64_t v134 = *(void *)(v130 + v131);
          v131 -= 8;
        }
        while (v133 == v134);
        if (v133 <= v134)
        {
LABEL_47:
          long long v78 = *(_OWORD *)a1;
          long long v77 = *(_OWORD *)(a1 + 16);
          long long v79 = *(_OWORD *)(a1 + 48);
          *(_OWORD *)a1 = *v49;
          *(_OWORD *)(a1 + 16) = v79;
          long long *v49 = v78;
          *(_OWORD *)(a1 + 48) = v77;
        }
      }
      else if (v101)
      {
        goto LABEL_47;
      }
      return 1;
    default:
      uint64_t v13 = a1 + 64;
      sub_1CCD5659C((long long *)a1, (long long *)(a1 + 32), (long long *)(a1 + 64));
      uint64_t v14 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      int v15 = 0;
      while (2)
      {
        uint64_t v16 = *(void *)(v14 + 8);
        uint64_t v17 = *(void *)(v13 + 8);
        uint64_t v18 = (void *)(v17 + 24);
        uint64_t v19 = *(unsigned int *)(v16 + 32);
        if (v19 > 0x40)
        {
          uint64_t v38 = *(void *)(v16 + 24);
          uint64_t v39 = *(void *)(v38 + 8 * ((v19 - 1) >> 6)) & (1 << (v19 - 1));
          unsigned int v40 = *(_DWORD *)(v17 + 32);
          unsigned int v41 = v40 - 1;
          uint64_t v42 = *(void *)(v17 + 24);
          if (v40 >= 0x41) {
            uint64_t v18 = (void *)(v42 + 8 * (v41 >> 6));
          }
          if ((v39 != 0) == ((*v18 >> v41) & 1))
          {
            unint64_t v43 = v19 + 63;
            uint64_t v44 = v42 - 8;
            uint64_t v45 = (v43 >> 3) & 0x3FFFFFF8;
            uint64_t v46 = v38 - 8;
            do
            {
              if (!v45) {
                goto LABEL_25;
              }
              unint64_t v47 = *(void *)(v46 + v45);
              unint64_t v48 = *(void *)(v44 + v45);
              v45 -= 8;
            }
            while (v47 == v48);
            if (v47 > v48)
            {
LABEL_25:
              uint64_t v13 = v14;
              v14 += 32;
              if (v14 == a2) {
                return 1;
              }
              continue;
            }
          }
          else if (!v39)
          {
            goto LABEL_25;
          }
        }
        else if ((uint64_t)(*(void *)(v16 + 24) << -(char)v19) >> -(char)v19 >= (uint64_t)(*v18 << -(char)v19) >> -(char)v19)
        {
          goto LABEL_25;
        }
        break;
      }
      uint64_t v20 = *(void *)v14;
      long long v135 = *(_OWORD *)(v14 + 16);
      long long v21 = *(_OWORD *)(v13 + 16);
      *(_OWORD *)uint64_t v14 = *(_OWORD *)v13;
      *(_OWORD *)(v14 + 16) = v21;
      uint64_t v22 = a1;
      if (v13 == a1) {
        goto LABEL_24;
      }
      while (2)
      {
        uint64_t v23 = *(void *)(v13 - 24);
        long long v24 = (void *)(v23 + 24);
        uint64_t v25 = *(unsigned int *)(v16 + 32);
        if (v25 <= 0x40)
        {
          if ((uint64_t)(*(void *)(v16 + 24) << -(char)v25) >> -(char)v25 >= (uint64_t)(*v24 << -(char)v25) >> -(char)v25) {
            goto LABEL_23;
          }
LABEL_12:
          long long v26 = *(_OWORD *)(v13 - 16);
          *(_OWORD *)uint64_t v13 = *(_OWORD *)(v13 - 32);
          *(_OWORD *)(v13 + 16) = v26;
          v13 -= 32;
          if (v13 == a1)
          {
            uint64_t v22 = a1;
            goto LABEL_24;
          }
          continue;
        }
        break;
      }
      uint64_t v27 = *(void *)(v16 + 24);
      uint64_t v28 = *(void *)(v27 + 8 * ((v25 - 1) >> 6)) & (1 << (v25 - 1));
      unsigned int v29 = *(_DWORD *)(v23 + 32);
      unsigned int v30 = v29 - 1;
      uint64_t v31 = *(void *)(v23 + 24);
      if (v29 >= 0x41) {
        long long v24 = (void *)(v31 + 8 * (v30 >> 6));
      }
      if ((v28 != 0) != ((*v24 >> v30) & 1))
      {
        if (!v28) {
          goto LABEL_23;
        }
        goto LABEL_12;
      }
      unint64_t v32 = v25 + 63;
      uint64_t v33 = v31 - 8;
      uint64_t v34 = (v32 >> 3) & 0x3FFFFFF8;
      uint64_t v35 = v27 - 8;
      while (v34)
      {
        unint64_t v36 = *(void *)(v35 + v34);
        unint64_t v37 = *(void *)(v33 + v34);
        v34 -= 8;
        if (v36 != v37)
        {
          if (v36 <= v37) {
            goto LABEL_12;
          }
          break;
        }
      }
LABEL_23:
      uint64_t v22 = v13;
LABEL_24:
      *(void *)uint64_t v22 = v20;
      *(void *)(v22 + 8) = v16;
      *(_OWORD *)(v22 + 16) = v135;
      if (++v15 != 8) {
        goto LABEL_25;
      }
      return v14 + 32 == a2;
  }
}

long long *sub_1CCD57038(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = sub_1CCD5659C((long long *)a1, (long long *)a2, (long long *)a3);
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(void *)(a3 + 8);
  long long v11 = (void *)(v10 + 24);
  uint64_t v12 = *(unsigned int *)(v9 + 32);
  if (v12 > 0x40)
  {
    uint64_t v30 = *(void *)(v9 + 24);
    uint64_t v31 = *(void *)(v30 + 8 * ((v12 - 1) >> 6)) & (1 << (v12 - 1));
    unsigned int v32 = *(_DWORD *)(v10 + 32);
    unsigned int v33 = v32 - 1;
    uint64_t v34 = *(void *)(v10 + 24);
    if (v32 >= 0x41) {
      long long v11 = (void *)(v34 + 8 * (v33 >> 6));
    }
    if ((v31 != 0) == ((*v11 >> v33) & 1))
    {
      unint64_t v45 = v12 + 63;
      uint64_t v46 = v34 - 8;
      uint64_t v47 = (v45 >> 3) & 0x3FFFFFF8;
      uint64_t v48 = v30 - 8;
      while (v47)
      {
        unint64_t v49 = *(void *)(v48 + v47);
        unint64_t v50 = *(void *)(v46 + v47);
        v47 -= 8;
        if (v49 != v50)
        {
          if (v49 <= v50) {
            goto LABEL_3;
          }
          return result;
        }
      }
      return result;
    }
    if (!v31) {
      return result;
    }
  }
  else if ((uint64_t)(*(void *)(v9 + 24) << -(char)v12) >> -(char)v12 >= (uint64_t)(*v11 << -(char)v12) >> -(char)v12)
  {
    return result;
  }
LABEL_3:
  long long v14 = *(_OWORD *)a3;
  long long v13 = *(_OWORD *)(a3 + 16);
  long long v15 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(_OWORD *)(a3 + 16) = v15;
  *(_OWORD *)a4 = v14;
  *(_OWORD *)(a4 + 16) = v13;
  uint64_t v16 = *(void *)(a3 + 8);
  uint64_t v17 = *(void *)(a2 + 8);
  uint64_t v18 = (void *)(v17 + 24);
  uint64_t v19 = *(unsigned int *)(v16 + 32);
  if (v19 > 0x40)
  {
    uint64_t v35 = *(void *)(v16 + 24);
    uint64_t v36 = *(void *)(v35 + 8 * ((v19 - 1) >> 6)) & (1 << (v19 - 1));
    unsigned int v37 = *(_DWORD *)(v17 + 32);
    unsigned int v38 = v37 - 1;
    uint64_t v39 = *(void *)(v17 + 24);
    if (v37 >= 0x41) {
      uint64_t v18 = (void *)(v39 + 8 * (v38 >> 6));
    }
    if ((v36 != 0) == ((*v18 >> v38) & 1))
    {
      unint64_t v51 = v19 + 63;
      uint64_t v52 = v39 - 8;
      uint64_t v53 = (v51 >> 3) & 0x3FFFFFF8;
      uint64_t v54 = v35 - 8;
      while (v53)
      {
        unint64_t v55 = *(void *)(v54 + v53);
        unint64_t v56 = *(void *)(v52 + v53);
        v53 -= 8;
        if (v55 != v56)
        {
          if (v55 <= v56) {
            goto LABEL_5;
          }
          return result;
        }
      }
      return result;
    }
    if (!v36) {
      return result;
    }
  }
  else if ((uint64_t)(*(void *)(v16 + 24) << -(char)v19) >> -(char)v19 >= (uint64_t)(*v18 << -(char)v19) >> -(char)v19)
  {
    return result;
  }
LABEL_5:
  long long v21 = *(_OWORD *)a2;
  long long v20 = *(_OWORD *)(a2 + 16);
  long long v22 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v22;
  *(_OWORD *)a3 = v21;
  *(_OWORD *)(a3 + 16) = v20;
  uint64_t v23 = *(void *)(a2 + 8);
  uint64_t v24 = *(void *)(a1 + 8);
  uint64_t v25 = (void *)(v24 + 24);
  uint64_t v26 = *(unsigned int *)(v23 + 32);
  if (v26 <= 0x40)
  {
    if ((uint64_t)(*(void *)(v23 + 24) << -(char)v26) >> -(char)v26 >= (uint64_t)(*v25 << -(char)v26) >> -(char)v26) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v40 = *(void *)(v23 + 24);
  uint64_t v41 = *(void *)(v40 + 8 * ((v26 - 1) >> 6)) & (1 << (v26 - 1));
  unsigned int v42 = *(_DWORD *)(v24 + 32);
  unsigned int v43 = v42 - 1;
  uint64_t v44 = *(void *)(v24 + 24);
  if (v42 >= 0x41) {
    uint64_t v25 = (void *)(v44 + 8 * (v43 >> 6));
  }
  if ((v41 != 0) == ((*v25 >> v43) & 1))
  {
    unint64_t v57 = v26 + 63;
    uint64_t v58 = v44 - 8;
    uint64_t v59 = (v57 >> 3) & 0x3FFFFFF8;
    uint64_t v60 = v40 - 8;
    while (v59)
    {
      unint64_t v61 = *(void *)(v60 + v59);
      unint64_t v62 = *(void *)(v58 + v59);
      v59 -= 8;
      if (v61 != v62)
      {
        if (v61 <= v62) {
          goto LABEL_7;
        }
        return result;
      }
    }
  }
  else if (v41)
  {
LABEL_7:
    long long v28 = *(_OWORD *)a1;
    long long v27 = *(_OWORD *)(a1 + 16);
    long long v29 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v29;
    *(_OWORD *)a2 = v28;
    *(_OWORD *)(a2 + 16) = v27;
  }
  return result;
}

void sub_1CCD57300()
{
}

void sub_1CCD5733C()
{
}

void sub_1CCD5737C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD573B4(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LoopInfoWrapperPass::ID);

  sub_1CB843600(a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
}

uint64_t sub_1CCD57468(llvm::FunctionPass *a1, llvm::LLVMContextImpl ****a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction(a1, a2)) {
    return 0;
  }
  uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_6:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_6;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  uint64_t v9 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_11:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::LoopInfoWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_11;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::LoopInfoWrapperPass::ID) + 32;
  long long v14 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_16:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::PostDominatorTreeWrapperPass::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_16;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::PostDominatorTreeWrapperPass::ID)+ 32;
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(*((void *)a1 + 1) + 24), &llvm::MemorySSAWrapperPass::ID, 1);
  if (AnalysisPass
    && (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::MemorySSAWrapperPass::ID))
  {
    operator new();
  }
  uint64_t v20 = *(void *)(v8 + 80);
  v22[0] = &unk_1F263DE78;
  uint64_t v23 = v22;
  v24[0] = v8 + 32;
  v24[1] = v18;
  uint64_t v24[2] = v13;
  void v24[3] = 0;
  v24[4] = v20;
  v25[0] = &unk_1F263DE78;
  uint64_t v26 = v25;
  long long v27 = v29;
  uint64_t v28 = 0x1000000000;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  int v32 = 0;
  uint64_t v3 = sub_1CCD51D6C((uint64_t)v24);
  MEMORY[0x1D25D9CD0](v30, 8);
  if (v27 != v29) {
    free(v27);
  }
  if (v26 == v25)
  {
    (*(void (**)(void *))(v25[0] + 32))(v25);
  }
  else if (v26)
  {
    (*(void (**)(void))(*v26 + 40))();
  }
  if (v23 == v22)
  {
    (*(void (**)(void *))(v22[0] + 32))(v22);
  }
  else if (v23)
  {
    (*(void (**)(void))(*v23 + 40))();
  }
  return v3;
}

void sub_1CCD578B0()
{
}

void *sub_1CCD578C4()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1F263DE78;
  return result;
}

void sub_1CCD578FC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F263DE78;
}

uint64_t sub_1CCD57924()
{
  return 1;
}

void sub_1CCD57930(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCD57968(llvm::PassRegistry *a1, llvm *a2)
{
  uint64_t v3 = (uint64_t)a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = (char *)a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  llvm::getLoopAnalysisUsage(a2, v5);
  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::PostDominatorTreeWrapperPass::ID);

  sub_1CB843600((uint64_t)a2, v3, (uint64_t)&llvm::MemorySSAWrapperPass::ID);
}

uint64_t sub_1CCD579FC(llvm::LoopPass *a1, const llvm::Loop *a2)
{
  if ((llvm::LoopPass::skipLoop(a1, a2) & 1) == 0)
  {
    uint64_t v3 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v4 = *v3;
    uint64_t v5 = v3[1];
    if (v4 == v5)
    {
LABEL_6:
      uint64_t v6 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v4 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v4 += 16;
        if (v4 == v5) {
          goto LABEL_6;
        }
      }
      uint64_t v6 = *(void *)(v4 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::DominatorTreeWrapperPass::ID);
    uint64_t v7 = (uint64_t *)*((void *)a1 + 1);
    uint64_t v8 = *v7;
    uint64_t v9 = v7[1];
    if (v8 == v9)
    {
LABEL_11:
      uint64_t v10 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v8 != &llvm::LoopInfoWrapperPass::ID)
      {
        v8 += 16;
        if (v8 == v9) {
          goto LABEL_11;
        }
      }
      uint64_t v10 = *(void *)(v8 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::LoopInfoWrapperPass::ID);
    uint64_t v11 = *(llvm::PMDataManager **)(*((void *)a1 + 1) + 24);
    uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(v11, &llvm::PostDominatorTreeWrapperPass::ID, 1);
    if (AnalysisPass)
    {
      (*(void (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::PostDominatorTreeWrapperPass::ID);
      uint64_t v11 = *(llvm::PMDataManager **)(*((void *)a1 + 1) + 24);
    }
    uint64_t v13 = llvm::PMDataManager::findAnalysisPass(v11, &llvm::MemorySSAWrapperPass::ID, 1);
    if (v13
      && (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::MemorySSAWrapperPass::ID))
    {
      operator new();
    }
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPredecessor();
  }
  return 0;
}

void sub_1CCD57EE0()
{
}

__n128 sub_1CCD57EF4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F263DF70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CCD57F40(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F263DF70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CCD57F70(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (**(void **)(a1 + 8) == *a2) {
    return 1;
  }
  uint64_t v3 = **(void **)(a1 + 16);
  uint64_t v5 = *(void *)(v3 + 56);
  uint64_t v4 = *(void *)(v3 + 64);
  if (v4 == v5)
  {
    uint64_t v6 = *(unsigned int *)(v3 + 76);
    uint64_t v7 = (void *)(v4 + 8 * v6);
    if (v6)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while (*(void *)(v4 + v8) != v2)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_21;
        }
      }
      uint64_t v7 = (void *)(v4 + v8);
    }
LABEL_21:
    uint64_t v5 = *(void *)(v3 + 64);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(v3 + 72);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((v2 >> 4) ^ (v2 >> 9));
    uint64_t v7 = (void *)(v4 + 8 * v13);
    uint64_t v14 = *v7;
    if (*v7 == -1)
    {
      uint64_t v15 = 0;
LABEL_26:
      if (v15) {
        uint64_t v7 = v15;
      }
      if (*v7 != v2) {
        uint64_t v7 = (void *)(v4 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != v2)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v7;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v7 = (void *)(v4 + 8 * (v18 & v12));
        uint64_t v14 = *v7;
        if (*v7 == -1) {
          goto LABEL_26;
        }
      }
    }
  }
  uint64_t v19 = 72;
  if (v4 == v5) {
    uint64_t v19 = 76;
  }
  return v7 != (void *)(v4 + 8 * *(unsigned int *)(v3 + v19));
}

void sub_1CCD58084()
{
}

void *sub_1CCD58098()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F263DFB8;
  return result;
}

void sub_1CCD580D0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F263DFB8;
}

uint64_t sub_1CCD580F8()
{
  return 1;
}

void sub_1CCD58104()
{
}

__n128 sub_1CCD58118(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F263E000;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CCD58164(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F263E000;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CCD58194(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (**(void **)(a1 + 8) == *a2) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v3 + 56);
  uint64_t v4 = *(void *)(v3 + 64);
  if (v4 == v5)
  {
    uint64_t v6 = *(unsigned int *)(v3 + 76);
    uint64_t v7 = (void *)(v4 + 8 * v6);
    if (v6)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v6;
      while (*(void *)(v4 + v8) != v2)
      {
        v8 += 8;
        if (v9 == v8) {
          goto LABEL_21;
        }
      }
      uint64_t v7 = (void *)(v4 + v8);
    }
LABEL_21:
    uint64_t v5 = *(void *)(v3 + 64);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(v3 + 72);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((v2 >> 4) ^ (v2 >> 9));
    uint64_t v7 = (void *)(v4 + 8 * v13);
    uint64_t v14 = *v7;
    if (*v7 == -1)
    {
      uint64_t v15 = 0;
LABEL_26:
      if (v15) {
        uint64_t v7 = v15;
      }
      if (*v7 != v2) {
        uint64_t v7 = (void *)(v4 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != v2)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v7;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v7 = (void *)(v4 + 8 * (v18 & v12));
        uint64_t v14 = *v7;
        if (*v7 == -1) {
          goto LABEL_26;
        }
      }
    }
  }
  uint64_t v19 = 72;
  if (v4 == v5) {
    uint64_t v19 = 76;
  }
  return v7 != (void *)(v4 + 8 * *(unsigned int *)(v3 + v19));
}

uint64_t sub_1CCD582A0()
{
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"Whether or not we should widen guards  expressed as branches by widenable conditions";
  v3.n128_u64[1] = 84;
  char v1 = 1;
  uint64_t v2 = &v1;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCF1A60, "guard-widening-widen-branch-guards", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCF1A60, &dword_1CB82C000);
}

void *llvm::GVNPass::ValueTable::createExpr@<X0>(llvm::GVNPass::ValueTable *this@<X0>, llvm::Instruction *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 4) = 0;
  *(void *)(a3 + 16) = a3 + 32;
  uint64_t v6 = (unsigned int **)(a3 + 16);
  *(void *)(a3 + 24) = 0x400000000;
  int v7 = *((unsigned __int8 *)a2 + 16);
  BOOL v8 = v7 != 62 || a2 == 0;
  uint64_t v9 = 64;
  if (v8) {
    uint64_t v9 = 0;
  }
  *(void *)(a3 + 8) = *(void *)((char *)a2 + v9);
  *(_DWORD *)a3 = v7 - 28;
  BOOL v10 = sub_1CC070820((uint64_t)a2);
  int v11 = *((_DWORD *)a2 + 5);
  if (v10)
  {
    int v17 = llvm::GVNPass::ValueTable::lookupOrAdd(this, *((llvm::Value **)a2 - 4 * (v11 & 0x7FFFFFF)));
    unsigned int v18 = *(_DWORD *)(a3 + 24);
    if (v18 >= *(_DWORD *)(a3 + 28)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)(a3 + 16) + 4 * v18) = v17;
    ++*(_DWORD *)(a3 + 24);
    uint64_t BasePtr = (llvm::Value *)llvm::GCRelocateInst::getBasePtr(a2);
    int v20 = llvm::GVNPass::ValueTable::lookupOrAdd(this, BasePtr);
    unsigned int v21 = *(_DWORD *)(a3 + 24);
    if (v21 >= *(_DWORD *)(a3 + 28)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)(a3 + 16) + 4 * v21) = v20;
    ++*(_DWORD *)(a3 + 24);
    uint64_t DerivedPtr = (llvm::Value *)llvm::GCRelocateInst::getDerivedPtr(a2);
    int v23 = llvm::GVNPass::ValueTable::lookupOrAdd(this, DerivedPtr);
    unsigned int v24 = *(_DWORD *)(a3 + 24);
    if (v24 >= *(_DWORD *)(a3 + 28)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)(a3 + 16) + 4 * v24) = v23;
    ++*(_DWORD *)(a3 + 24);
  }
  else
  {
    if ((v11 & 0x40000000) != 0)
    {
      unsigned int v13 = (llvm::Value **)*((void *)a2 - 1);
      uint64_t v12 = v11 & 0x7FFFFFF;
      if (!v12) {
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v12 = v11 & 0x7FFFFFF;
      unsigned int v13 = (llvm::Value **)((char *)a2 - 32 * v12);
      if (!v12) {
        goto LABEL_20;
      }
    }
    uint64_t v14 = 32 * v12;
    do
    {
      int v15 = llvm::GVNPass::ValueTable::lookupOrAdd(this, *v13);
      unint64_t v16 = *(unsigned int *)(a3 + 24);
      if (v16 >= *(unsigned int *)(a3 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)(a3 + 16) + 4 * v16) = v15;
      ++*(_DWORD *)(a3 + 24);
      v13 += 4;
      v14 -= 32;
    }
    while (v14);
  }
LABEL_20:
  __n128 result = (void *)llvm::Instruction::isCommutative(a2);
  if (result)
  {
    uint64_t v26 = *v6;
    unsigned int v27 = **v6;
    unsigned int v28 = (*v6)[1];
    if (v27 > v28)
    {
      unsigned int *v26 = v28;
      v26[1] = v27;
    }
    *(unsigned char *)(a3 + 4) = 1;
  }
  int v29 = *((unsigned __int8 *)a2 + 16);
  if (!a2 || (v29 - 83) < 0xFFFFFFFE)
  {
    if (a2 && v29 == 93)
    {
      uint64_t v34 = (const void *)*((void *)a2 + 8);
      uint64_t v35 = *((unsigned int *)a2 + 18);
      uint64_t v36 = *(unsigned int *)(a3 + 24);
      if (v36 + v35 > (unint64_t)*(unsigned int *)(a3 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (!v35) {
        goto LABEL_42;
      }
      __n128 result = memcpy((void *)(*(void *)(a3 + 16) + 4 * v36), v34, 4 * v35);
    }
    else
    {
      if (!a2 || v29 != 91) {
        return result;
      }
      unsigned int v37 = (int *)*((void *)a2 + 8);
      uint64_t v35 = *((unsigned int *)a2 + 18);
      uint64_t v36 = *(unsigned int *)(a3 + 24);
      if (v36 + v35 > (unint64_t)*(unsigned int *)(a3 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (!v35)
      {
LABEL_42:
        *(_DWORD *)(a3 + 24) = v36 + v35;
        return result;
      }
      unsigned int v38 = &(*v6)[v36];
      uint64_t v39 = 4 * v35;
      do
      {
        unsigned int v40 = *v37++;
        *v38++ = v40;
        v39 -= 4;
      }
      while (v39);
    }
    LODWORD(v36) = *(_DWORD *)(a3 + 24);
    goto LABEL_42;
  }
  uint64_t v30 = *((_WORD *)a2 + 9) & 0x3F;
  uint64_t v31 = *v6;
  unsigned int v32 = **v6;
  unsigned int v33 = (*v6)[1];
  if (v32 > v33)
  {
    unsigned int *v31 = v33;
    v31[1] = v32;
    LODWORD(v30) = dword_1CFB2CC60[v30];
  }
  *(_DWORD *)a3 = v30 | ((v29 << 8) - 7168);
  *(unsigned char *)(a3 + 4) = 1;
  return result;
}

uint64_t llvm::GVNPass::ValueTable::lookupOrAdd(llvm::GVNPass::ValueTable *this, llvm::Value *a2)
{
  uint64_t v2 = a2;
  v67[3] = *MEMORY[0x1E4F143B8];
  uint64_t v59 = a2;
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *((unsigned int *)this + 4);
  unsigned int v6 = a2 >> 4;
  if (v5)
  {
    LODWORD(v7) = (v5 - 1) & (v6 ^ (a2 >> 9));
    uint64_t v8 = v4 + 16 * v7;
    uint64_t v9 = *(llvm::Value **)v8;
    if (*(llvm::Value **)v8 == a2) {
      goto LABEL_8;
    }
    int v10 = 1;
    while (v9 != (llvm::Value *)-4096)
    {
      int v11 = v7 + v10++;
      uint64_t v7 = v11 & (v5 - 1);
      uint64_t v9 = *(llvm::Value **)(v4 + 16 * v7);
      if (v9 == a2)
      {
        uint64_t v8 = v4 + 16 * v7;
        goto LABEL_8;
      }
    }
  }
  uint64_t v8 = v4 + 16 * v5;
LABEL_8:
  if (v8 != v4 + 16 * v5) {
    return *(unsigned int *)(v8 + 8);
  }
  unsigned int v14 = *((unsigned __int8 *)a2 + 16);
  if (v14 <= 0x1B)
  {
    int v42 = *((_DWORD *)this + 44);
    if (v5)
    {
      int v43 = v5 - 1;
      unsigned int v44 = v43 & (v6 ^ (a2 >> 9));
      unint64_t v45 = (uint64_t *)(v4 + 16 * v44);
      uint64_t v46 = (llvm::Value *)*v45;
      if ((llvm::Value *)*v45 == a2)
      {
LABEL_63:
        *((_DWORD *)v45 + 2) = v42;
        uint64_t v12 = *((unsigned int *)this + 44);
        *((_DWORD *)this + 44) = v12 + 1;
        return v12;
      }
      uint64_t v47 = 0;
      int v48 = 1;
      while (v46 != (llvm::Value *)-4096)
      {
        if (v47) {
          BOOL v56 = 0;
        }
        else {
          BOOL v56 = v46 == (llvm::Value *)-8192;
        }
        if (v56) {
          uint64_t v47 = v45;
        }
        unsigned int v57 = v44 + v48++;
        unsigned int v44 = v57 & v43;
        unint64_t v45 = (uint64_t *)(v4 + 16 * v44);
        uint64_t v46 = (llvm::Value *)*v45;
        if ((llvm::Value *)*v45 == a2) {
          goto LABEL_63;
        }
      }
      if (v47) {
        unint64_t v49 = v47;
      }
      else {
        unint64_t v49 = v45;
      }
    }
    else
    {
      unint64_t v49 = 0;
    }
    unint64_t v45 = sub_1CBFFD5B4((uint64_t)this, (uint64_t)&v59, (uint64_t *)&v59, v49);
    uint64_t *v45 = (uint64_t)v59;
    *((_DWORD *)v45 + 2) = 0;
    goto LABEL_63;
  }
  LODWORD(v64) = -3;
  BYTE4(v64) = 0;
  *((void *)&v64 + 1) = 0;
  long long __dst = v67;
  uint64_t v66 = 0x400000000;
  switch(v14)
  {
    case '(':
    case ')':
    case '*':
    case '+':
    case ',':
    case '-':
    case '.':
    case '/':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
    case ':':
    case '>':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'Q':
    case 'R':
    case 'U':
    case 'Y':
    case 'Z':
    case '[':
    case ']':
    case '_':
      llvm::GVNPass::ValueTable::createExpr(this, a2, (uint64_t)&v60);
      goto LABEL_14;
    case 'S':
      int v34 = *((_DWORD *)this + 44);
      if (!v5)
      {
        uint64_t v41 = 0;
LABEL_53:
        unsigned int v37 = sub_1CBFFD5B4((uint64_t)this, (uint64_t)&v59, (uint64_t *)&v59, v41);
        *unsigned int v37 = (uint64_t)v59;
        *((_DWORD *)v37 + 2) = 0;
        uint64_t v2 = v59;
        goto LABEL_54;
      }
      int v35 = v5 - 1;
      unsigned int v36 = v35 & (v6 ^ (a2 >> 9));
      unsigned int v37 = (uint64_t *)(v4 + 16 * v36);
      uint64_t v38 = *v37;
      if ((llvm::Value *)*v37 == a2) {
        goto LABEL_54;
      }
      uint64_t v39 = 0;
      int v40 = 1;
      do
      {
        if (v38 == -4096)
        {
          if (v39) {
            uint64_t v41 = v39;
          }
          else {
            uint64_t v41 = v37;
          }
          goto LABEL_53;
        }
        if (v39) {
          BOOL v54 = 0;
        }
        else {
          BOOL v54 = v38 == -8192;
        }
        if (v54) {
          uint64_t v39 = v37;
        }
        unsigned int v55 = v36 + v40++;
        unsigned int v36 = v55 & v35;
        unsigned int v37 = (uint64_t *)(v4 + 16 * v36);
        uint64_t v38 = *v37;
      }
      while ((llvm::Value *)*v37 != a2);
LABEL_54:
      *((_DWORD *)v37 + 2) = v34;
      *(void *)(sub_1CCD6494C((uint64_t)this + 104, (_DWORD *)this + 44) + 8) = v2;
LABEL_44:
      uint64_t v12 = *((unsigned int *)this + 44);
      *((_DWORD *)this + 44) = v12 + 1;
LABEL_33:
      if (__dst != v67) {
        free(__dst);
      }
      return v12;
    case 'T':
      uint64_t v12 = llvm::GVNPass::ValueTable::lookupOrAddCall(this, a2);
      goto LABEL_33;
    case '\\':
      llvm::GVNPass::ValueTable::createExtractvalueExpr(this, a2, (uint64_t)&v60);
LABEL_14:
      long long v64 = v60;
      int v15 = __src;
      if (__src == v63)
      {
        int v16 = v62;
        if (v66 >= v62)
        {
          if (v62) {
            memmove(__dst, __src, 4 * v62);
          }
        }
        else
        {
          if (HIDWORD(v66) < v62)
          {
            LODWORD(v66) = 0;
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          if (v66)
          {
            uint64_t v58 = v66;
            memmove(__dst, __src, 4 * v66);
            uint64_t v17 = v58;
          }
          else
          {
            uint64_t v17 = 0;
          }
          if (v17 != v62) {
            memcpy((char *)__dst + 4 * v17, (char *)__src + 4 * v17, 4 * v62 - 4 * v17);
          }
        }
        LODWORD(v66) = v16;
      }
      else
      {
        if (__dst != v67)
        {
          free(__dst);
          int v15 = __src;
        }
        long long __dst = v15;
        uint64_t v66 = v62;
        __src = v63;
        HIDWORD(v62) = 0;
      }
      LODWORD(v62) = 0;
      if (__src != v63) {
        free(__src);
      }
      uint64_t v12 = llvm::GVNPass::ValueTable::assignExpNewValueNum((uint64_t)this, (uint64_t)&v64);
      int v18 = *((_DWORD *)this + 4);
      if (v18)
      {
        int v19 = v18 - 1;
        unsigned int v20 = ((v59 >> 4) ^ (v59 >> 9)) & v19;
        unsigned int v21 = (uint64_t *)(*(void *)this + 16 * v20);
        uint64_t v22 = *v21;
        if (v59 == (llvm::Value *)*v21) {
          goto LABEL_32;
        }
        int v23 = 0;
        int v24 = 1;
        while (v22 != -4096)
        {
          if (v23) {
            BOOL v50 = 0;
          }
          else {
            BOOL v50 = v22 == -8192;
          }
          if (v50) {
            int v23 = v21;
          }
          unsigned int v51 = v20 + v24++;
          unsigned int v20 = v51 & v19;
          unsigned int v21 = (uint64_t *)(*(void *)this + 16 * v20);
          uint64_t v22 = *v21;
          if (v59 == (llvm::Value *)*v21)
          {
LABEL_32:
            *((_DWORD *)v21 + 2) = v12;
            goto LABEL_33;
          }
        }
        if (v23) {
          uint64_t v25 = v23;
        }
        else {
          uint64_t v25 = v21;
        }
      }
      else
      {
        uint64_t v25 = 0;
      }
      unsigned int v21 = sub_1CBFFD5B4((uint64_t)this, (uint64_t)&v59, (uint64_t *)&v59, v25);
      *unsigned int v21 = (uint64_t)v59;
      *((_DWORD *)v21 + 2) = 0;
      goto LABEL_32;
    default:
      int v26 = *((_DWORD *)this + 44);
      if (v5)
      {
        int v27 = v5 - 1;
        unsigned int v28 = v27 & (v6 ^ (a2 >> 9));
        int v29 = (uint64_t *)(v4 + 16 * v28);
        uint64_t v30 = (llvm::Value *)*v29;
        if ((llvm::Value *)*v29 == a2) {
          goto LABEL_43;
        }
        uint64_t v31 = 0;
        int v32 = 1;
        while (v30 != (llvm::Value *)-4096)
        {
          if (v31) {
            BOOL v52 = 0;
          }
          else {
            BOOL v52 = v30 == (llvm::Value *)-8192;
          }
          if (v52) {
            uint64_t v31 = v29;
          }
          unsigned int v53 = v28 + v32++;
          unsigned int v28 = v53 & v27;
          int v29 = (uint64_t *)(v4 + 16 * v28);
          uint64_t v30 = (llvm::Value *)*v29;
          if ((llvm::Value *)*v29 == a2)
          {
LABEL_43:
            *((_DWORD *)v29 + 2) = v26;
            goto LABEL_44;
          }
        }
        if (v31) {
          unsigned int v33 = v31;
        }
        else {
          unsigned int v33 = v29;
        }
      }
      else
      {
        unsigned int v33 = 0;
      }
      int v29 = sub_1CBFFD5B4((uint64_t)this, (uint64_t)&v59, (uint64_t *)&v59, v33);
      uint64_t *v29 = (uint64_t)v59;
      *((_DWORD *)v29 + 2) = 0;
      goto LABEL_43;
  }
}

uint64_t llvm::GVNPass::ValueTable::createCmpExpr@<X0>(llvm::GVNPass::ValueTable *this@<X0>, llvm::Value *a2@<X3>, int a3@<W1>, int a4@<W2>, llvm::Value *a5@<X4>, uint64_t a6@<X8>)
{
  *(_DWORD *)a6 = -3;
  *(unsigned char *)(a6 + 4) = 0;
  *(void *)(a6 + 8) = 0;
  *(void *)(a6 + 16) = a6 + 32;
  *(void *)(a6 + 24) = 0x400000000;
  uint64_t v12 = *(void ***)a2;
  unsigned int v13 = (uint64_t **)(***(void ***)a2 + 1888);
  if (*(void *)a2 && (v12[1] & 0xFE) == 0x12)
  {
    unsigned int v21 = (llvm::Type *)*((unsigned int *)v12 + 8);
    if (*((_DWORD *)v12 + 2) == 19) {
      llvm::ScalableVectorType::get(v13, v21);
    }
    else {
      llvm::FixedVectorType::get((llvm::FixedVectorType *)v13, v21);
    }
  }
  *(void *)(a6 + 8) = v13;
  int v14 = llvm::GVNPass::ValueTable::lookupOrAdd(this, a2);
  unsigned int v15 = *(_DWORD *)(a6 + 24);
  if (v15 >= *(_DWORD *)(a6 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)(a6 + 16) + 4 * v15) = v14;
  ++*(_DWORD *)(a6 + 24);
  uint64_t result = llvm::GVNPass::ValueTable::lookupOrAdd(this, a5);
  unsigned int v17 = *(_DWORD *)(a6 + 24);
  if (v17 >= *(_DWORD *)(a6 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)(a6 + 16) + 4 * v17) = result;
  ++*(_DWORD *)(a6 + 24);
  int v18 = *(unsigned int **)(a6 + 16);
  unsigned int v19 = *v18;
  unsigned int v20 = v18[1];
  if (*v18 > v20)
  {
    unsigned int *v18 = v20;
    v18[1] = v19;
    a4 = dword_1CFB2CC60[a4];
  }
  *(_DWORD *)a6 = a4 | (a3 << 8);
  *(unsigned char *)(a6 + 4) = 1;
  return result;
}

unsigned char *llvm::GVNPass::ValueTable::createExtractvalueExpr@<X0>(llvm::GVNPass::ValueTable *this@<X0>, llvm::ExtractValueInst *a2@<X1>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 4) = 0;
  *(void *)(a3 + 16) = a3 + 32;
  unsigned int v6 = (void *)(a3 + 16);
  *(void *)(a3 + 24) = 0x400000000;
  *(void *)(a3 + 8) = *(void *)a2;
  *(_DWORD *)a3 = 0;
  uint64_t v7 = *((void *)a2 - 4);
  int v8 = sub_1CC062BC4(v7);
  if (v7) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9 || *((_DWORD *)a2 + 18) != 1 || **((_DWORD **)a2 + 8))
  {
    *(_DWORD *)a3 = *((unsigned __int8 *)a2 + 16) - 28;
    int v10 = *((_DWORD *)a2 + 5);
    if ((v10 & 0x40000000) != 0)
    {
      uint64_t v12 = (llvm::Value **)*((void *)a2 - 1);
      uint64_t v11 = v10 & 0x7FFFFFF;
      if (v11)
      {
LABEL_9:
        uint64_t v13 = 32 * v11;
        do
        {
          int v14 = llvm::GVNPass::ValueTable::lookupOrAdd(this, *v12);
          unint64_t v15 = *(unsigned int *)(a3 + 24);
          if (v15 >= *(unsigned int *)(a3 + 28)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)(a3 + 16) + 4 * v15) = v14;
          unsigned int v16 = *(_DWORD *)(a3 + 24) + 1;
          *(_DWORD *)(a3 + 24) = v16;
          v12 += 4;
          v13 -= 32;
        }
        while (v13);
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v11 = v10 & 0x7FFFFFF;
      uint64_t v12 = (llvm::Value **)((char *)a2 - 32 * v11);
      if (v11) {
        goto LABEL_9;
      }
    }
    unsigned int v16 = *(_DWORD *)(a3 + 24);
LABEL_16:
    unsigned int v17 = (char *)*((void *)a2 + 8);
    int v18 = &v17[4 * *((unsigned int *)a2 + 18)];
    uint64_t v19 = *v6 + 4 * v16;
    return sub_1CC1E3C8C((uint64_t)v6, v19, v17, v18);
  }
  int v21 = 13;
  if (((1 << (*(unsigned char *)(*(void *)(v7 - 32) + 36) - 6)) & 0xC000000003) == 0)
  {
    if (((1 << (*(unsigned char *)(*(void *)(v7 - 32) + 36) - 6)) & 0x6000000600000) != 0) {
      int v21 = 15;
    }
    else {
      int v21 = 17;
    }
  }
  *(_DWORD *)a3 = v21;
  int v22 = llvm::GVNPass::ValueTable::lookupOrAdd(this, *(llvm::Value **)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF)));
  unsigned int v23 = *(_DWORD *)(a3 + 24);
  if (v23 >= *(_DWORD *)(a3 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)(a3 + 16) + 4 * v23) = v22;
  ++*(_DWORD *)(a3 + 24);
  uint64_t result = (unsigned char *)llvm::GVNPass::ValueTable::lookupOrAdd(this, *(llvm::Value **)(v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF) + 32));
  unsigned int v24 = *(_DWORD *)(a3 + 24);
  if (v24 >= *(_DWORD *)(a3 + 28)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)(a3 + 16) + 4 * v24) = result;
  ++*(_DWORD *)(a3 + 24);
  return result;
}

double llvm::GVNPass::ValueTable::ValueTable(llvm::GVNPass::ValueTable *this)
{
  *((_DWORD *)this + 12) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 44) = 1;
  return result;
}

{
  double result;

  *((_DWORD *)this + 12) = 0;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 44) = 1;
  return result;
}

llvm::GVNPass::ValueTable *llvm::GVNPass::ValueTable::ValueTable(llvm::GVNPass::ValueTable *this, const llvm::GVNPass::ValueTable *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  sub_1CBFCBCC4((uint64_t)this, (uint64_t)a2);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  sub_1CCD64730((uint64_t)this + 24, (char **)a2 + 3);
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  uint64_t v4 = *((void *)a2 + 7);
  uint64_t v5 = *((void *)a2 + 8);
  int64_t v6 = v5 - v4;
  if (v5 != v4)
  {
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 4);
    if (v7 >= 0x555555555555556) {
      abort();
    }
    int v8 = (char *)operator new(v6);
    uint64_t v9 = 0;
    *((void *)this + 7) = v8;
    *((void *)this + 8) = v8;
    *((void *)this + 9) = &v8[48 * v7];
    do
    {
      uint64_t v10 = v4 + v9;
      uint64_t v11 = &v8[v9];
      *(_OWORD *)uint64_t v11 = *(_OWORD *)(v4 + v9);
      uint64_t v12 = &v8[v9 + 32];
      *(void *)&v8[v9 + 16] = v12;
      *((void *)v11 + 3) = 0x400000000;
      unsigned int v13 = *(_DWORD *)(v4 + v9 + 24);
      if (v13) {
        BOOL v14 = v11 == (char *)v10;
      }
      else {
        BOOL v14 = 1;
      }
      if (!v14)
      {
        if (v13 >= 5) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v12, *(const void **)(v10 + 16), 4 * *(unsigned int *)(v4 + v9 + 24));
        *((_DWORD *)v11 + 6) = v13;
      }
      v9 += 48;
    }
    while (v4 + v9 != v5);
    *((void *)this + 8) = &v8[v9];
  }
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = 0;
  sub_1CBA85A80((void *)this + 10, *((const void **)a2 + 10), *((void *)a2 + 11), (uint64_t)(*((void *)a2 + 11) - *((void *)a2 + 10)) >> 2);
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 13) = 0;
  sub_1CBFCBCC4((uint64_t)this + 104, (uint64_t)a2 + 104);
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 16) = 0;
  sub_1CCD64878((char **)this + 16, (uint64_t)a2 + 128);
  long long v15 = *(_OWORD *)((char *)a2 + 152);
  *(_OWORD *)((char *)this + 164) = *(_OWORD *)((char *)a2 + 164);
  *(_OWORD *)((char *)this + 152) = v15;
  return this;
}

void llvm::GVNPass::ValueTable::~ValueTable(llvm::GVNPass::ValueTable *this)
{
  MEMORY[0x1D25D9CD0](*((void *)this + 16), 8);
  MEMORY[0x1D25D9CD0](*((void *)this + 13), 8);
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    operator delete(v2);
  }
  __n128 v3 = (void **)((char *)this + 56);
  sub_1CCD6469C(&v3);
  sub_1CCD645A0((uint64_t)this + 24);
  MEMORY[0x1D25D9CD0](*((void *)this + 3), 8);
  MEMORY[0x1D25D9CD0](*(void *)this, 8);
}

uint64_t llvm::GVNPass::ValueTable::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  if (a2 != a1)
  {
    sub_1CBFCBCC4(a1, a2);
    sub_1CCD64730(v3 + 24, (char **)(v2 + 24));
    uint64_t v4 = (void **)(v3 + 56);
    uint64_t v5 = *(char **)(v3 + 56);
    *(_DWORD *)(v3 + 48) = *(_DWORD *)(v2 + 48);
    unint64_t v7 = *(char **)(v2 + 56);
    int64_t v6 = *(char **)(v2 + 64);
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4);
    uint64_t v9 = *(void *)(v3 + 72);
    if (0xAAAAAAAAAAAAAAABLL * ((v9 - (uint64_t)v5) >> 4) >= v8)
    {
      unsigned int v28 = *(char **)(v3 + 64);
      if (0xAAAAAAAAAAAAAAABLL * ((v28 - v5) >> 4) >= v8)
      {
        if (v7 != v6)
        {
          uint64_t v59 = v2;
          uint64_t v37 = v3;
          uint64_t v38 = 0;
          do
          {
            uint64_t v39 = &v5[v38];
            int v40 = &v7[v38];
            *(_OWORD *)&v5[v38] = *(_OWORD *)&v7[v38];
            if (v7 != v5)
            {
              uint64_t v41 = (void **)(v39 + 16);
              uint64_t v42 = *((unsigned int *)v40 + 6);
              uint64_t v43 = *((unsigned int *)v39 + 6);
              if (v43 >= v42)
              {
                if (v42) {
                  memmove(*v41, *((const void **)v40 + 2), 4 * v42);
                }
              }
              else
              {
                if (*(_DWORD *)&v5[v38 + 28] < v42)
                {
                  *((_DWORD *)v39 + 6) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v43) {
                  memmove(*v41, *((const void **)v40 + 2), 4 * v43);
                }
                else {
                  uint64_t v43 = 0;
                }
                uint64_t v44 = *((unsigned int *)v40 + 6);
                if (v43 != v44) {
                  memcpy((char *)*v41 + 4 * v43, (const void *)(*((void *)v40 + 2) + 4 * v43), 4 * v44 - 4 * v43);
                }
              }
              *((_DWORD *)v39 + 6) = v42;
            }
            v38 += 48;
          }
          while (&v7[v38] != v6);
          uint64_t v3 = v37;
          unsigned int v28 = *(char **)(v37 + 64);
          v5 += v38;
          uint64_t v2 = v59;
        }
        if (v28 != v5)
        {
          BOOL v52 = v28 - 16;
          do
          {
            unsigned int v53 = (char *)*((void *)v52 - 2);
            if (v52 != v53) {
              free(v53);
            }
            BOOL v54 = v52 - 32;
            v52 -= 48;
          }
          while (v54 != v5);
        }
        *(void *)(v3 + 64) = v5;
      }
      else
      {
        uint64_t v57 = v3;
        uint64_t v58 = v2;
        int v29 = &v7[16 * ((v28 - v5) >> 4)];
        if (v28 != v5)
        {
          uint64_t v30 = 0;
          uint64_t v60 = 16 * ((v28 - v5) >> 4);
          do
          {
            uint64_t v31 = &v5[v30];
            int v32 = &v7[v30];
            *(_OWORD *)&v5[v30] = *(_OWORD *)&v7[v30];
            if (v7 != v5)
            {
              unsigned int v33 = (void **)(v31 + 16);
              uint64_t v34 = *((unsigned int *)v32 + 6);
              uint64_t v35 = *((unsigned int *)v31 + 6);
              if (v35 >= v34)
              {
                if (v34) {
                  memmove(*v33, *((const void **)v32 + 2), 4 * v34);
                }
              }
              else
              {
                if (*(_DWORD *)&v5[v30 + 28] < v34)
                {
                  *((_DWORD *)v31 + 6) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v35) {
                  memmove(*v33, *((const void **)v32 + 2), 4 * v35);
                }
                else {
                  uint64_t v35 = 0;
                }
                uint64_t v36 = *((unsigned int *)v32 + 6);
                if (v35 != v36) {
                  memcpy((char *)*v33 + 4 * v35, (const void *)(*((void *)v32 + 2) + 4 * v35), 4 * v36 - 4 * v35);
                }
              }
              *((_DWORD *)v31 + 6) = v34;
            }
            v30 += 48;
          }
          while (v60 != v30);
          uint64_t v5 = *(char **)(v57 + 64);
        }
        unint64_t v45 = v5;
        if (v29 != v6)
        {
          uint64_t v46 = 0;
          do
          {
            uint64_t v47 = &v29[v46];
            int v48 = &v5[v46];
            *(_OWORD *)int v48 = *(_OWORD *)&v29[v46];
            unint64_t v49 = &v5[v46 + 32];
            *(void *)&v5[v46 + 16] = v49;
            *((void *)v48 + 3) = 0x400000000;
            unsigned int v50 = *(_DWORD *)&v29[v46 + 24];
            if (v50) {
              BOOL v51 = v48 == v47;
            }
            else {
              BOOL v51 = 1;
            }
            if (!v51)
            {
              if (v50 >= 5) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v49, *((const void **)v47 + 2), 4 * *(unsigned int *)&v29[v46 + 24]);
              *((_DWORD *)v48 + 6) = v50;
            }
            v46 += 48;
          }
          while (&v29[v46] != v6);
          unint64_t v45 = &v5[v46];
        }
        uint64_t v3 = v57;
        uint64_t v2 = v58;
        *(void *)(v57 + 64) = v45;
      }
    }
    else
    {
      if (v5)
      {
        uint64_t v10 = *(char **)(v3 + 64);
        uint64_t v11 = v5;
        if (v10 != v5)
        {
          uint64_t v12 = v10 - 16;
          do
          {
            unsigned int v13 = (char *)*((void *)v12 - 2);
            if (v12 != v13) {
              free(v13);
            }
            BOOL v14 = v12 - 32;
            v12 -= 48;
          }
          while (v14 != v5);
          uint64_t v11 = *v4;
        }
        *(void *)(v3 + 64) = v5;
        operator delete(v11);
        uint64_t v9 = 0;
        *uint64_t v4 = 0;
        *(void *)(v3 + 64) = 0;
        *(void *)(v3 + 72) = 0;
      }
      if (v8 > 0x555555555555555) {
        goto LABEL_83;
      }
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 4);
      uint64_t v16 = 2 * v15;
      if (2 * v15 <= v8) {
        uint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4);
      }
      unint64_t v17 = v15 >= 0x2AAAAAAAAAAAAAALL ? 0x555555555555555 : v16;
      if (v17 > 0x555555555555555) {
LABEL_83:
      }
        abort();
      uint64_t v18 = 3 * v17;
      uint64_t v19 = (char *)operator new(48 * v17);
      *(void *)(v3 + 56) = v19;
      *(void *)(v3 + 64) = v19;
      *(void *)(v3 + 72) = &v19[16 * v18];
      if (v7 != v6)
      {
        uint64_t v20 = v2;
        uint64_t v21 = v3;
        uint64_t v22 = 0;
        do
        {
          unsigned int v23 = &v7[v22];
          unsigned int v24 = &v19[v22];
          *(_OWORD *)unsigned int v24 = *(_OWORD *)&v7[v22];
          uint64_t v25 = &v19[v22 + 32];
          *(void *)&v19[v22 + 16] = v25;
          *((void *)v24 + 3) = 0x400000000;
          unsigned int v26 = *(_DWORD *)&v7[v22 + 24];
          if (v26) {
            BOOL v27 = v24 == v23;
          }
          else {
            BOOL v27 = 1;
          }
          if (!v27)
          {
            if (v26 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v25, *((const void **)v23 + 2), 4 * *(unsigned int *)&v7[v22 + 24]);
            *((_DWORD *)v24 + 6) = v26;
          }
          v22 += 48;
        }
        while (&v7[v22] != v6);
        v19 += v22;
        uint64_t v3 = v21;
        uint64_t v2 = v20;
      }
      *(void *)(v3 + 64) = v19;
    }
    sub_1CC19E0C8((void *)(v3 + 80), *(char **)(v2 + 80), *(char **)(v2 + 88), (uint64_t)(*(void *)(v2 + 88) - *(void *)(v2 + 80)) >> 2);
    sub_1CBFCBCC4(v3 + 104, v2 + 104);
    sub_1CCD64878((char **)(v3 + 128), v2 + 128);
  }
  long long v55 = *(_OWORD *)(v2 + 152);
  *(_OWORD *)(v3 + 164) = *(_OWORD *)(v2 + 164);
  *(_OWORD *)(v3 + 152) = v55;
  return v3;
}

uint64_t llvm::GVNPass::ValueTable::add(llvm::GVNPass::ValueTable *this, llvm::Value *a2, unsigned int a3)
{
  unsigned int v9 = a3;
  unint64_t v7 = a2;
  uint64_t v8 = a3;
  uint64_t result = (uint64_t)sub_1CC6125EC((uint64_t)this, (uint64_t *)&v7, &v8, (uint64_t)&v6);
  if (a2)
  {
    if (*((unsigned char *)a2 + 16) == 83)
    {
      uint64_t result = sub_1CCD6494C((uint64_t)this + 104, &v9);
      *(void *)(result + 8) = a2;
    }
  }
  return result;
}

uint64_t llvm::GVNPass::ValueTable::lookupOrAddCall(llvm::GVNPass::ValueTable *this, llvm::CallInst *a2)
{
  v42[2] = *MEMORY[0x1E4F143B8];
  if (llvm::AAResults::getModRefBehavior(*((void *)this + 19), (uint64_t)a2) == 4)
  {
    llvm::GVNPass::ValueTable::createExpr(this, a2, (uint64_t)v40);
    uint64_t v4 = llvm::GVNPass::ValueTable::assignExpNewValueNum((uint64_t)this, (uint64_t)v40);
    uint64_t v39 = a2;
    *((_DWORD *)sub_1CC0779FC((uint64_t)this, (uint64_t *)&v39) + 2) = v4;
    uint64_t v5 = v41;
    goto LABEL_12;
  }
  if (!*((void *)this + 20) || (llvm::AAResults::getModRefBehavior(*((void *)this + 19), (uint64_t)a2) & 2) != 0)
  {
    int v9 = *((_DWORD *)this + 44);
    v40[0] = (uint64_t)a2;
    *((_DWORD *)sub_1CC0779FC((uint64_t)this, v40) + 2) = v9;
    uint64_t v4 = *((unsigned int *)this + 44);
    *((_DWORD *)this + 44) = v4 + 1;
    return v4;
  }
  llvm::GVNPass::ValueTable::createExpr(this, a2, (uint64_t)v40);
  unint64_t v6 = llvm::GVNPass::ValueTable::assignExpNewValueNum((uint64_t)this, (uint64_t)v40);
  if (HIDWORD(v6))
  {
    uint64_t v4 = v6;
    uint64_t v39 = a2;
    *((_DWORD *)sub_1CC0779FC((uint64_t)this, (uint64_t *)&v39) + 2) = v6;
  }
  else
  {
    uint64_t Dependency = llvm::MemoryDependenceResults::getDependency(*((llvm::MemoryDependenceResults **)this + 20), a2);
    if ((Dependency & 7) == 2 || (Dependency & 0xE000000000000007) == 0x2000000000000003)
    {
      if ((Dependency & 7) == 2)
      {
        unint64_t v11 = Dependency & 0xFFFFFFFFFFFFFFF8;
        if ((Dependency & 0xFFFFFFFFFFFFFFF8) != 0 && *(unsigned char *)(v11 + 16) == 84)
        {
          int v12 = 0;
          int v13 = *(_DWORD *)(v11 + 20);
          uint64_t v14 = -(uint64_t)(v13 & 0x7FFFFFF);
          if (v13 < 0)
          {
            unint64_t v34 = v11 - 32 * (v13 & 0x7FFFFFF);
            uint64_t v35 = *(void *)(v34 - 8);
            if ((v35 & 0xFFFFFFFF0) != 0) {
              int v12 = *(_DWORD *)(v34 - 12) - *(_DWORD *)(v34 - v35);
            }
            else {
              int v12 = 0;
            }
          }
          unint64_t v15 = (32 * (unint64_t)-v12 - 32 * v14 - 32) >> 5;
          int v16 = *((unsigned __int8 *)a2 + 16);
          if (v16 == 84)
          {
            uint64_t v17 = 0;
          }
          else if (v16 == 39)
          {
            uint64_t v17 = (*((_DWORD *)a2 + 20) + 1);
          }
          else
          {
            uint64_t v17 = 2;
          }
          int v18 = 0;
          int v19 = *((_DWORD *)a2 + 5);
          if (v19 < 0)
          {
            uint64_t v36 = (char *)a2 - 32 * (v19 & 0x7FFFFFF);
            uint64_t v37 = *((void *)v36 - 1);
            if ((v37 & 0xFFFFFFFF0) != 0) {
              int v18 = *((_DWORD *)v36 - 3) - *(_DWORD *)&v36[-v37];
            }
            else {
              int v18 = 0;
            }
          }
          uint64_t v20 = (char *)a2 + 32 * -v18 + -32 * v17;
          uint64_t v21 = (char *)a2 - 32 * (v19 & 0x7FFFFFF);
          if (v15 == ((unint64_t)(v20 - v21 - 32) >> 5))
          {
            if (v16 == 84)
            {
              uint64_t v22 = 0;
            }
            else if (v16 == 39)
            {
              uint64_t v22 = (*((_DWORD *)a2 + 20) + 1);
            }
            else
            {
              uint64_t v22 = 2;
            }
            if (v19 < 0 && (uint64_t v38 = *((void *)v21 - 1), (v38 & 0xFFFFFFFF0) != 0)) {
              uint64_t v23 = (*((_DWORD *)v21 - 3) - *(_DWORD *)&v21[-v38]);
            }
            else {
              uint64_t v23 = 0;
            }
            unint64_t v24 = (llvm::CallInst *)((char *)a2 - 32 * v22 + -32 * v23) - (llvm::CallInst *)v21 - 32;
            if ((v24 & 0x1FFFFFFFE0) == 0)
            {
LABEL_42:
              uint64_t v4 = llvm::GVNPass::ValueTable::lookupOrAdd(this, (llvm::Value *)v11);
              uint64_t v39 = a2;
              *((_DWORD *)sub_1CC0779FC((uint64_t)this, (uint64_t *)&v39) + 2) = v4;
              goto LABEL_11;
            }
            uint64_t v25 = 0;
            uint64_t v26 = -(uint64_t)(v24 >> 5);
            while (1)
            {
              int v27 = llvm::GVNPass::ValueTable::lookupOrAdd(this, *(llvm::Value **)((char *)a2 + v25 + -32 * (*((_DWORD *)a2 + 5) & 0x7FFFFFF)));
              if (v27 != llvm::GVNPass::ValueTable::lookupOrAdd(this, *(llvm::Value **)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + v25)))break; {
              v25 += 32;
              }
              if (__CFADD__(v26++, 1)) {
                goto LABEL_42;
              }
            }
          }
        }
      }
      else
      {
        int v29 = llvm::MemoryDependenceResults::getNonLocalCallDependency(*((llvm::MemoryDependenceResults **)this + 20), a2);
        unint64_t v30 = v29[1] - *v29;
        if ((v30 & 0xFFFFFFFF0) != 0)
        {
          uint64_t v31 = 0;
          uint64_t v32 = (v30 >> 4);
          while (1)
          {
            uint64_t v33 = *(void *)(*v29 + v31 + 8);
            if ((v33 & 0xE000000000000007) != 0x2000000000000003) {
              break;
            }
            v31 += 16;
            if (!--v32) {
              goto LABEL_8;
            }
          }
          if ((*(void *)(*v29 + v31 + 8) & 7) == 2
            && (v33 & 0xFFFFFFFFFFFFFFF8) != 0
            && *(unsigned char *)((v33 & 0xFFFFFFFFFFFFFFF8) + 16) == 84)
          {
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
          }
        }
      }
    }
LABEL_8:
    int v8 = *((_DWORD *)this + 44);
    uint64_t v39 = a2;
    *((_DWORD *)sub_1CC0779FC((uint64_t)this, (uint64_t *)&v39) + 2) = v8;
    uint64_t v4 = *((unsigned int *)this + 44);
    *((_DWORD *)this + 44) = v4 + 1;
  }
LABEL_11:
  uint64_t v5 = v41;
LABEL_12:
  if (v5 != v42) {
    free(v5);
  }
  return v4;
}

uint64_t llvm::GVNPass::ValueTable::assignExpNewValueNum(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1CCD64F74(a1 + 24, a2);
  unsigned int v5 = v4[12];
  if (v5)
  {
    uint64_t v16 = 0;
    return v16 | v5;
  }
  unint64_t v6 = v4;
  int v8 = *(char **)(a1 + 64);
  unint64_t v7 = *(void *)(a1 + 72);
  if ((unint64_t)v8 >= v7)
  {
    int v18 = *(char **)(a1 + 56);
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v18) >> 4) + 1;
    if (v19 > 0x555555555555555) {
      abort();
    }
    int v40 = v4;
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)v18) >> 4);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v21 = 0x555555555555555;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21 > 0x555555555555555) {
      sub_1CB833614();
    }
    uint64_t v22 = 3 * v21;
    uint64_t v23 = (char *)operator new(48 * v21);
    unint64_t v24 = &v23[16 * ((v8 - v18) >> 4)];
    *(_OWORD *)unint64_t v24 = *(_OWORD *)a2;
    *((void *)v24 + 2) = v24 + 32;
    *((void *)v24 + 3) = 0x400000000;
    unsigned int v25 = *(_DWORD *)(a2 + 24);
    if (v25 && v24 + 16 != (char *)(a2 + 16))
    {
      if (v25 >= 5)
      {
        *((_DWORD *)v24 + 6) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v24 + 32, *(const void **)(a2 + 16), 4 * *(unsigned int *)(a2 + 24));
      *((_DWORD *)v24 + 6) = v25;
      int v18 = *(char **)(a1 + 56);
      int v8 = *(char **)(a1 + 64);
    }
    uint64_t v10 = v24 + 48;
    if (v8 == v18)
    {
      *(void *)(a1 + 56) = v24;
      *(void *)(a1 + 64) = v10;
      *(void *)(a1 + 72) = &v23[16 * v22];
    }
    else
    {
      uint64_t v39 = &v23[16 * v22];
      uint64_t v26 = 0;
      do
      {
        int v27 = &v8[v26];
        unsigned int v28 = &v24[v26];
        *((_OWORD *)v28 - 3) = *(_OWORD *)&v8[v26 - 48];
        int v29 = &v24[v26 - 16];
        *(void *)&v24[v26 - 32] = v29;
        *((void *)v28 - 3) = 0x400000000;
        unsigned int v30 = *(_DWORD *)&v8[v26 - 24];
        if (v30) {
          BOOL v31 = v28 == v27;
        }
        else {
          BOOL v31 = 1;
        }
        if (!v31)
        {
          uint64_t v32 = (char *)*((void *)v27 - 4);
          if (v27 - 16 == v32)
          {
            if (v30 >= 5) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v29, v32, 4 * *(unsigned int *)&v8[v26 - 24]);
            *((_DWORD *)v28 - 6) = v30;
          }
          else
          {
            *(void *)&v24[v26 - 32] = v32;
            int v33 = *(_DWORD *)&v8[v26 - 20];
            *((_DWORD *)v28 - 6) = v30;
            *((_DWORD *)v28 - 5) = v33;
            *((void *)v27 - 4) = v27 - 16;
            *(_DWORD *)&v8[v26 - 20] = 0;
          }
          *((_DWORD *)v27 - 6) = 0;
        }
        v26 -= 48;
      }
      while (&v8[v26] != v18);
      int v18 = *(char **)(a1 + 56);
      unint64_t v34 = *(char **)(a1 + 64);
      *(void *)(a1 + 56) = &v24[v26];
      *(void *)(a1 + 64) = v10;
      *(void *)(a1 + 72) = v39;
      if (v34 != v18)
      {
        uint64_t v35 = v34 - 16;
        unint64_t v6 = v40;
        do
        {
          uint64_t v36 = (char *)*((void *)v35 - 2);
          if (v35 != v36) {
            free(v36);
          }
          uint64_t v37 = v35 - 32;
          v35 -= 48;
        }
        while (v37 != v18);
        goto LABEL_41;
      }
    }
    unint64_t v6 = v40;
LABEL_41:
    if (v18) {
      operator delete(v18);
    }
    goto LABEL_8;
  }
  *(_OWORD *)int v8 = *(_OWORD *)a2;
  *((void *)v8 + 2) = v8 + 32;
  *((void *)v8 + 3) = 0x400000000;
  unsigned int v9 = *(_DWORD *)(a2 + 24);
  if (v9 && v8 != (char *)a2)
  {
    if (v9 >= 5) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v8 + 32, *(const void **)(a2 + 16), 4 * *(unsigned int *)(a2 + 24));
    *((_DWORD *)v8 + 6) = v9;
  }
  uint64_t v10 = v8 + 48;
LABEL_8:
  uint64_t v11 = *(void *)(a1 + 80);
  *(void *)(a1 + 64) = v10;
  unint64_t v12 = (*(void *)(a1 + 88) - v11) >> 2;
  int v13 = *(_DWORD *)(a1 + 176);
  if (v12 < (v13 + 1))
  {
    unint64_t v38 = (2 * v13);
    if (v38 <= v12)
    {
      if (v38 < v12) {
        *(void *)(a1 + 88) = v11 + 4 * v38;
      }
    }
    else
    {
      sub_1CBF2A8C4((char **)(a1 + 80), v38 - v12);
      int v13 = *(_DWORD *)(a1 + 176);
      uint64_t v11 = *(void *)(a1 + 80);
    }
  }
  v6[12] = v13;
  int v14 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = v14 + 1;
  uint64_t v15 = *(unsigned int *)(a1 + 176);
  *(_DWORD *)(a1 + 176) = v15 + 1;
  *(_DWORD *)(v11 + 4 * v15) = v14;
  unsigned int v5 = v6[12];
  uint64_t v16 = 0x100000000;
  return v16 | v5;
}

BOOL llvm::GVNPass::ValueTable::exists(llvm::GVNPass::ValueTable *this, llvm::Value *a2)
{
  int v2 = *((_DWORD *)this + 4);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void *)this;
  int v4 = v2 - 1;
  unsigned int v5 = v4 & ((a2 >> 4) ^ (a2 >> 9));
  unint64_t v6 = *(llvm::Value **)(*(void *)this + 16 * v5);
  if (v6 == a2) {
    return 1;
  }
  int v7 = 1;
  do
  {
    BOOL result = v6 != (llvm::Value *)-4096;
    if (v6 == (llvm::Value *)-4096) {
      break;
    }
    unsigned int v9 = v5 + v7++;
    unsigned int v5 = v9 & v4;
    unint64_t v6 = *(llvm::Value **)(v3 + 16 * v5);
  }
  while (v6 != a2);
  return result;
}

uint64_t llvm::GVNPass::ValueTable::lookup(llvm::GVNPass::ValueTable *this, llvm::Value *a2, char a3)
{
  uint64_t v3 = *(void *)this;
  uint64_t v4 = *((unsigned int *)this + 4);
  if (!v4) {
    goto LABEL_9;
  }
  LODWORD(v5) = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v6 = v3 + 16 * v5;
  int v7 = *(llvm::Value **)v6;
  if (*(llvm::Value **)v6 != a2)
  {
    int v8 = 1;
    while (v7 != (llvm::Value *)-4096)
    {
      int v9 = v5 + v8++;
      uint64_t v5 = v9 & (v4 - 1);
      int v7 = *(llvm::Value **)(v3 + 16 * v5);
      if (v7 == a2)
      {
        uint64_t v6 = v3 + 16 * v5;
        goto LABEL_7;
      }
    }
LABEL_9:
    uint64_t v6 = v3 + 16 * v4;
    if (a3) {
      return *(unsigned int *)(v6 + 8);
    }
    goto LABEL_10;
  }
LABEL_7:
  if (a3) {
    return *(unsigned int *)(v6 + 8);
  }
LABEL_10:
  if (v6 == v3 + 16 * v4) {
    return 0;
  }
  return *(unsigned int *)(v6 + 8);
}

uint64_t llvm::GVNPass::ValueTable::lookupOrAddCmp(llvm::GVNPass::ValueTable *a1, int a2, int a3, llvm::Value *a4, llvm::Value *a5)
{
  long long v10[2] = *MEMORY[0x1E4F143B8];
  llvm::GVNPass::ValueTable::createCmpExpr(a1, a4, a2, a3, a5, (uint64_t)v8);
  uint64_t result = llvm::GVNPass::ValueTable::assignExpNewValueNum((uint64_t)a1, (uint64_t)v8);
  if (v9 != v10)
  {
    uint64_t v7 = result;
    free(v9);
    return v7;
  }
  return result;
}

void llvm::GVNPass::ValueTable::clear(llvm::GVNPass::ValueTable *this)
{
  sub_1CC27F058(this);
  sub_1CCD5A48C((uint64_t)this + 24);
  sub_1CCD5A750((_DWORD *)this + 26);
  sub_1CCD5A7A0((_DWORD *)this + 32);
  *((_DWORD *)this + 44) = 1;
  uint64_t v3 = (char *)*((void *)this + 7);
  int v2 = (char *)*((void *)this + 8);
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 16;
    do
    {
      uint64_t v5 = (char *)*((void *)v4 - 2);
      if (v4 != v5) {
        free(v5);
      }
      uint64_t v6 = v4 - 32;
      v4 -= 48;
    }
    while (v6 != v3);
  }
  *((void *)this + 8) = v3;
  *((void *)this + 11) = *((void *)this + 10);
  *((_DWORD *)this + 12) = 0;
}

void sub_1CCD5A48C(uint64_t a1)
{
  _OWORD v15[2] = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
    if (v3 <= 4 * v2 || v3 < 0x41)
    {
      LODWORD(v12) = -1;
      BYTE4(v12) = 0;
      *((void *)&v12 + 1) = 0;
      __src = v15;
      uint64_t v14 = 0x400000000;
      if (v3)
      {
        uint64_t v8 = *(void *)a1 + 16;
        uint64_t v9 = 56 * v3;
        do
        {
          *(_OWORD *)(v8 - 16) = v12;
          if ((long long *)(v8 - 16) != &v12)
          {
            int v10 = v14;
            uint64_t v11 = *(unsigned int *)(v8 + 8);
            if (v11 >= v14)
            {
              if (v14) {
                memmove(*(void **)v8, __src, 4 * v14);
              }
            }
            else
            {
              if (*(_DWORD *)(v8 + 12) < v14)
              {
                *(_DWORD *)(v8 + 8) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v11) {
                memmove(*(void **)v8, __src, 4 * v11);
              }
              else {
                uint64_t v11 = 0;
              }
              if (v11 != v14) {
                memcpy((void *)(*(void *)v8 + 4 * v11), (char *)__src + 4 * v11, 4 * v14 - 4 * v11);
              }
            }
            *(_DWORD *)(v8 + 8) = v10;
          }
          v8 += 56;
          v9 -= 56;
        }
        while (v9);
        *(void *)(a1 + 8) = 0;
      }
      else
      {
        *(void *)(a1 + 8) = 0;
      }
      if (__src != v15) {
        free(__src);
      }
    }
    else
    {
      sub_1CCD645A0(a1);
      int v4 = 1 << (33 - __clz(v2 - 1));
      if (v4 <= 64) {
        int v4 = 64;
      }
      if (v2) {
        int v5 = v4;
      }
      else {
        int v5 = 0;
      }
      if (v5 != *(_DWORD *)(a1 + 16))
      {
        MEMORY[0x1D25D9CD0](*(void *)a1, 8);
        if (!v5)
        {
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          *(_DWORD *)(a1 + 16) = 0;
          return;
        }
        unint64_t v6 = (4 * v5 / 3u + 1) | ((unint64_t)(4 * v5 / 3u + 1) >> 1);
        unint64_t v7 = v6 | (v6 >> 2) | ((v6 | (v6 >> 2)) >> 4);
        LODWORD(v7) = (((v7 | (v7 >> 8)) >> 16) | v7 | (v7 >> 8)) + 1;
        *(_DWORD *)(a1 + 16) = v7;
        *(void *)a1 = operator new(56 * v7, (std::align_val_t)8uLL);
      }
      sub_1CCD64410(a1);
    }
  }
}

_DWORD *sub_1CCD5A750(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if (v1)
      {
        int v2 = *(_DWORD **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          _DWORD *v2 = -1;
          v2 += 4;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
    else
    {
      return sub_1CBC04D20(result);
    }
  }
  return result;
}

_DWORD *sub_1CCD5A7A0(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    unsigned int v1 = result[4];
    if (v1 <= 4 * result[2] || v1 < 0x41)
    {
      if (v1)
      {
        uint64_t v2 = *(void *)result;
        uint64_t v3 = *(void *)result + 24 * v1;
        do
        {
          *(_DWORD *)uint64_t v2 = -1;
          *(void *)(v2 + 8) = -4096;
          v2 += 24;
        }
        while (v2 != v3);
      }
      *((void *)result + 1) = 0;
    }
    else
    {
      return sub_1CCD64CE8(result);
    }
  }
  return result;
}

int32x2_t llvm::GVNPass::ValueTable::erase(int32x2_t *this, llvm::Value *a2)
{
  __int32 v2 = this[2].i32[0];
  if (v2)
  {
    int32x2_t v3 = *this;
    __int32 v4 = v2 - 1;
    LODWORD(v5) = (v2 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unint64_t v6 = (llvm::Value **)(*(void *)this + 16 * v5);
    unint64_t v7 = *v6;
    if (*v6 == a2)
    {
      uint64_t v10 = v4 & ((a2 >> 4) ^ (a2 >> 9));
LABEL_8:
      __int32 v2 = *(_DWORD *)(*(void *)&v3 + 16 * v10 + 8);
    }
    else
    {
      int v8 = 1;
      uint64_t v9 = *v6;
      LODWORD(v10) = v4 & ((a2 >> 4) ^ (a2 >> 9));
      while (v9 != (llvm::Value *)-4096)
      {
        int v11 = v10 + v8++;
        uint64_t v10 = v11 & v4;
        uint64_t v9 = *(llvm::Value **)(*(void *)&v3 + 16 * v10);
        if (v9 == a2) {
          goto LABEL_8;
        }
      }
      __int32 v2 = 0;
    }
    if (v7 == a2)
    {
LABEL_17:
      *unint64_t v6 = (llvm::Value *)-8192;
      int32x2_t result = vadd_s32(this[1], (int32x2_t)0x1FFFFFFFFLL);
      this[1] = result;
    }
    else
    {
      int v12 = 1;
      while (v7 != (llvm::Value *)-4096)
      {
        int v13 = v5 + v12++;
        uint64_t v5 = v13 & v4;
        unint64_t v7 = *(llvm::Value **)(*(void *)&v3 + 16 * v5);
        if (v7 == a2)
        {
          unint64_t v6 = (llvm::Value **)(*(void *)&v3 + 16 * v5);
          goto LABEL_17;
        }
      }
    }
  }
  if (*((unsigned char *)a2 + 16) == 83)
  {
    __int32 v15 = this[15].i32[0];
    if (v15)
    {
      int32x2_t v16 = this[13];
      __int32 v17 = v15 - 1;
      LODWORD(v18) = (v15 - 1) & (37 * v2);
      unint64_t v19 = (int *)(*(void *)&v16 + 16 * v18);
      int v20 = *v19;
      if (*v19 == v2)
      {
LABEL_24:
        *unint64_t v19 = -2;
        int32x2_t result = vadd_s32(this[14], (int32x2_t)0x1FFFFFFFFLL);
        this[14] = result;
      }
      else
      {
        int v21 = 1;
        while (v20 != -1)
        {
          int v22 = v18 + v21++;
          uint64_t v18 = v22 & v17;
          int v20 = *(_DWORD *)(*(void *)&v16 + 16 * v18);
          if (v20 == v2)
          {
            unint64_t v19 = (int *)(*(void *)&v16 + 16 * v18);
            goto LABEL_24;
          }
        }
      }
    }
  }
  return result;
}

uint64_t llvm::GVNPass::isPREEnabled(llvm::GVNPass *this)
{
  if (*((unsigned char *)this + 1)) {
    unsigned int v1 = (char *)this;
  }
  else {
    unsigned int v1 = &byte_1EBCF1BC8;
  }
  return *v1;
}

uint64_t llvm::GVNPass::isLoadPREEnabled(llvm::GVNPass *this)
{
  unsigned int v1 = (char *)this + 2;
  if (!*((unsigned char *)this + 3)) {
    unsigned int v1 = &byte_1EBCF1C88;
  }
  return *v1;
}

uint64_t llvm::GVNPass::isLoadInLoopPREEnabled(llvm::GVNPass *this)
{
  unsigned int v1 = (char *)this + 4;
  if (!*((unsigned char *)this + 5)) {
    unsigned int v1 = &byte_1EBCF1D48;
  }
  return *v1;
}

uint64_t llvm::GVNPass::isLoadPRESplitBackedgeEnabled(llvm::GVNPass *this)
{
  unsigned int v1 = (char *)this + 6;
  if (!*((unsigned char *)this + 7)) {
    unsigned int v1 = &byte_1EBCF1E08;
  }
  return *v1;
}

uint64_t llvm::GVNPass::isMemDepEnabled(llvm::GVNPass *this)
{
  unsigned int v1 = (char *)this + 8;
  if (!*((unsigned char *)this + 9)) {
    unsigned int v1 = &byte_1EBD0B2F8;
  }
  return *v1;
}

void llvm::GVNPass::run()
{
}

uint64_t llvm::GVNPass::runImpl(uint64_t a1, llvm::Function *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, llvm::DomTreeUpdater *a8, uint64_t a9, uint64_t a10)
{
  v48[2] = *(void **)MEMORY[0x1E4F143B8];
  *(void *)(a1 + 288) = a7;
  *(void *)(a1 + 296) = a4;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 280) = a6;
  *(void *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a4;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  int v26 = 0;
  uint64_t v23 = &unk_1F26048A8;
  *(void *)(a1 + 96) = a9;
  *(void *)(a1 + 104) = &v23;
  *(unsigned char *)(a1 + 688) = 1;
  int v12 = &v36;
  uint64_t v36 = a10;
  v37[0] = (char *)&v38;
  v37[1] = (char *)0x1000000000;
  uint64_t v39 = v43;
  int v40 = v43;
  uint64_t v41 = 8;
  int v42 = 0;
  uint64_t v44 = v46;
  uint64_t v45 = 0x800000000;
  v48[1] = 0;
  v48[0] = 0;
  uint64_t v47 = v48;
  if (!a10) {
    int v12 = 0;
  }
  *(void *)(a1 + 112) = a8;
  *(void *)(a1 + 120) = v12;
  v27[0] = v28;
  v27[1] = 0x1000000000;
  v28[32] = 0;
  v28[33] = 0;
  v28[34] = a4;
  v28[35] = 0;
  char v29 = 0;
  unsigned int v30 = v34;
  BOOL v31 = v34;
  uint64_t v32 = 8;
  int v33 = 0;
  int v13 = (void *)((char *)a2 + 72);
  memset(&v34[64], 0, 24);
  __int16 v35 = 0;
  uint64_t v14 = (void *)*((void *)a2 + 10);
  if (v14 == (void *)((char *)a2 + 72))
  {
    LOBYTE(v16) = 0;
  }
  else
  {
    int v16 = 0;
    do
    {
      __int32 v17 = (void *)v14[1];
      if (v14) {
        uint64_t v18 = (llvm *)(v14 - 3);
      }
      else {
        uint64_t v18 = 0;
      }
      v16 |= llvm::MergeBlockIntoPredecessor(v18, (unint64_t)v27, a8, *(void *)(a1 + 120), *(llvm::MemorySSAUpdater **)(a1 + 16), 0);
      uint64_t v14 = v17;
    }
    while (v17 != v13);
  }
  do
  {
    char v19 = v16;
    LOBYTE(v16) = 1;
  }
  while ((llvm::GVNPass::iterateOnFunction((llvm::GVNPass *)a1, a2) & 1) != 0);
  if (*(unsigned char *)(a1 + 1)) {
    int v20 = (char *)a1;
  }
  else {
    int v20 = &byte_1EBCF1BC8;
  }
  if (*v20)
  {
    llvm::GVNPass::assignValNumForDeadCode((void *)a1);
    do
    {
      char v21 = v19;
      char v19 = 1;
    }
    while ((llvm::GVNPass::performPRE((llvm::GVNPass *)a1, a2) & 1) != 0);
  }
  else
  {
    char v21 = v19;
  }
  llvm::GVNPass::cleanupGlobalSets((llvm::GVNPass *)a1);
  sub_1CBFC9A80((_DWORD *)(a1 + 48));
  *(void *)(a1 + 80) = *(void *)(a1 + 72);
  if (a10 && llvm::VerifyMemorySSA) {
    llvm::MemorySSA::verifyMemorySSA(a10, 0);
  }
  sub_1CC2930C0((uint64_t)v27);
  sub_1CD3C5048((uint64_t)&v47, v48[0]);
  if (v44 != v46) {
    free(v44);
  }
  if (v40 != v39) {
    free(v40);
  }
  sub_1CC0BD0FC(v37);
  uint64_t v23 = &unk_1F26048F8;
  MEMORY[0x1D25D9CD0](v24, 8);
  return v21 & 1;
}

llvm::Value *sub_1CCD5AF1C(uint64_t a1, llvm::IntegerType **a2, uint64_t a3, llvm::Type *a4, uint64_t a5, const llvm::DataLayout *a6)
{
  int v8 = (llvm::Instruction *)(a3 + 272);
  int v9 = *(_DWORD *)(a1 + 8);
  if (v9 == 1)
  {
    uint64_t v10 = *(llvm::Instruction **)a1;
    int v11 = (llvm::LoadInst *)*(unsigned int *)(a1 + 12);
    if (**(llvm::IntegerType ****)a1 != a2 || v11 != 0)
    {
      LoadValueForLoad = llvm::VNCoercion::getLoadValueForLoad(*(llvm::VNCoercion **)a1, v11, a2, a4, v8, a6);
      llvm::MemoryDependenceResults::removeInstruction(*(llvm::MemoryDependenceResults **)(a5 + 16), v10);
      return LoadValueForLoad;
    }
    return v10;
  }
  if (!v9)
  {
    uint64_t v10 = *(llvm::Instruction **)a1;
    if (**(llvm::IntegerType ****)a1 != a2)
    {
      int v13 = (llvm::Value *)*(unsigned int *)(a1 + 12);
      uint64_t v14 = *(llvm::VNCoercion **)a1;
      return llvm::VNCoercion::getStoreValueForLoad(v14, v13, (uint64_t)a2, a4, v8, a6);
    }
    return v10;
  }
  if (v9 != 2)
  {
    char v19 = *(llvm::Instruction **)a1;
    char v21 = (uint64_t *)sub_1CCD5B088(*(void *)(*(void *)(*(void *)a1 - 64) + 8), (uint64_t)a2, *(llvm::Instruction **)a1, *(llvm::DominatorTree **)(a5 + 24));
    uint64_t v22 = sub_1CCD5B088(*(void *)(*((void *)v19 - 4) + 8), (uint64_t)a2, v19, *(llvm::DominatorTree **)(a5 + 24));
    uint64_t v23 = *((void *)v19 - 12);
    __int16 v25 = 257;
    return sub_1CC199EFC(v23, v21, v22, &v24, (uint64_t)v19, 0);
  }
  unsigned int v17 = *(_DWORD *)(a1 + 12);
  uint64_t v18 = *(llvm::VNCoercion **)a1;

  return llvm::VNCoercion::getMemInstValueForLoad((uint64_t)v18, v17, a2, (uint64_t **)a4, v8);
}

uint64_t sub_1CCD5B088(uint64_t a1, uint64_t a2, llvm::Instruction *a3, llvm::DominatorTree *this)
{
  if (!a1) {
    return 0;
  }
  uint64_t v7 = a1;
  while (1)
  {
    uint64_t v8 = *(void *)(v7 + 24);
    if (v8)
    {
      if (*(unsigned char *)(v8 + 16) == 60
        && *(void *)v8 == a2
        && *(void *)(v8 + 40) == *((void *)a3 + 5)
        && (llvm::DominatorTree::dominates(this, *(const llvm::Value **)(v7 + 24), a3) & 1) != 0)
      {
        break;
      }
    }
    uint64_t v7 = *(void *)(v7 + 8);
    if (!v7) {
      return 0;
    }
  }
  return v8;
}

uint64_t llvm::GVNPass::AnalyzeLoadAvailability(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Instruction *a4, const llvm::DataLayout *a5)
{
  v79[34] = *MEMORY[0x1E4F143B8];
  if ((unint64_t)(a3 & 7) - 1 >= 2)
  {
    sub_1CCD5BA54((uint64_t)&v74, *(void *)(a2 + 40), a2 + 24, a4, *(void *)a2, *(llvm::DominatorTree **)(a1 + 24), *(void *)(a1 + 280));
    uint64_t result = v75 != 0;
    if (v75) {
      *(_OWORD *)a5 = v74;
    }
    return result;
  }
  uint64_t v10 = (llvm::Type *)(*(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272);
  uint64_t v11 = a3 & 7;
  unint64_t v12 = 0;
  if (v11 != 3) {
    unint64_t v12 = a3 & 0xFFFFFFFFFFFFFFF8;
  }
  int v13 = *(unsigned __int8 *)(v12 + 16);
  if ((a3 & 7) != 1)
  {
    if (v13 == 59
      || v13 == 84
      && (uint64_t v21 = *(void *)(v12 - 32)) != 0
      && !*(unsigned char *)(v21 + 16)
      && *(void *)(v21 + 24) == *(void *)(v12 + 72)
      && (*(unsigned char *)(v21 + 33) & 0x20) != 0
      && *(_DWORD *)(v21 + 36) == 168)
    {
      InitialValueOfAllocatiouint64_t n = llvm::UndefValue::get(*(llvm::UndefValue **)a2, (llvm::Type *)a2);
LABEL_27:
      *(void *)a5 = InitialValueOfAllocation;
LABEL_28:
      *((void *)a5 + 1) = 0;
      return 1;
    }
    if (byte_1EBD04470) {
      int v23 = 59;
    }
    else {
      int v23 = 63;
    }
    sub_1CC095244(v12, v23, *(uint64_t **)(a1 + 32), &v74);
    if (v76)
    {
      InitialValueOfAllocatiouint64_t n = llvm::getInitialValueOfAllocation(v12, *(uint64_t **)(a1 + 32), *(llvm::UndefValue **)a2);
      if (InitialValueOfAllocation) {
        goto LABEL_27;
      }
    }
    int v25 = *(unsigned __int8 *)(v12 + 16);
    if (v25 == 61)
    {
      uint64_t result = llvm::VNCoercion::canCoerceMustAliasedValueToLoad(*(llvm::VNCoercion **)(v12 - 64), *(llvm::Value ****)a2, v10, v24);
      if (!result) {
        return result;
      }
      int v26 = *(unsigned __int8 *)(v12 + 16);
      if (v26 == 60 || v26 == 61) {
        BOOL v27 = (*(_WORD *)(v12 + 18) & 0x380) != 0;
      }
      else {
        BOOL v27 = (v26 - 63) <= 2;
      }
      int v28 = *(unsigned __int8 *)(a2 + 16);
      if ((v28 - 60) >= 2)
      {
        if ((v28 - 63) < 3)
        {
LABEL_40:
          if (!v27) {
            return 0;
          }
        }
      }
      else if ((*(_WORD *)(a2 + 18) & 0x380) != 0)
      {
        goto LABEL_40;
      }
      *(void *)a5 = *(void *)(v12 - 64);
      goto LABEL_28;
    }
    if (v25 != 60)
    {
      unsigned int v32 = 1;
      goto LABEL_155;
    }
    if (!llvm::VNCoercion::canCoerceMustAliasedValueToLoad((llvm::VNCoercion *)v12, *(llvm::Value ****)a2, v10, v24))
    {
LABEL_49:
      unsigned int v32 = 0;
      goto LABEL_155;
    }
    int v29 = *(unsigned __int8 *)(v12 + 16);
    if (v29 == 60 || v29 == 61) {
      BOOL v30 = (*(_WORD *)(v12 + 18) & 0x380) != 0;
    }
    else {
      BOOL v30 = (v29 - 63) <= 2;
    }
    int v31 = *(unsigned __int8 *)(a2 + 16);
    if ((v31 - 60) >= 2)
    {
      if ((v31 - 63) < 3)
      {
LABEL_48:
        if (!v30) {
          goto LABEL_49;
        }
      }
    }
    else if ((*(_WORD *)(a2 + 18) & 0x380) != 0)
    {
      goto LABEL_48;
    }
    unsigned int v32 = 1;
    *(void *)a5 = v12;
    *((void *)a5 + 1) = 1;
LABEL_155:
    if (v25 == 60) {
      return v32;
    }
    else {
      return 0;
    }
  }
  if (v13 == 61) {
    unint64_t v14 = v12;
  }
  else {
    unint64_t v14 = 0;
  }
  if (!a4 || !v14) {
    goto LABEL_52;
  }
  int v15 = *(unsigned __int8 *)(a2 + 16);
  if (v15 == 60 || v15 == 61) {
    BOOL v16 = (*(_WORD *)(a2 + 18) & 0x380) != 0;
  }
  else {
    BOOL v16 = (v15 - 63) <= 2;
  }
  int v17 = *(unsigned __int8 *)(v14 + 16);
  if ((v17 - 60) < 2)
  {
    BOOL v18 = (*(_WORD *)(v14 + 18) & 0x380) != 0;
    goto LABEL_14;
  }
  if ((v17 - 63) >= 3)
  {
    BOOL v18 = 0;
LABEL_14:
    if (v16 && !v18) {
      goto LABEL_52;
    }
  }
  uint64_t v19 = llvm::VNCoercion::analyzeLoadFromClobberingStore(*(llvm::Value ****)a2, a4, (llvm::Value *)v14, (llvm::StoreInst *)(*(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) + 272), a5);
  if (v19 != -1)
  {
    *(void *)a5 = *(void *)(v14 - 64);
    *((void *)a5 + 1) = v19 << 32;
    return 1;
  }
  int v13 = *(unsigned __int8 *)(v12 + 16);
LABEL_52:
  if (v13 == 60) {
    uint64_t v33 = v12;
  }
  else {
    uint64_t v33 = 0;
  }
  if (!a4) {
    goto LABEL_68;
  }
  if (v33 == a2 || v33 == 0) {
    goto LABEL_68;
  }
  int v35 = *(unsigned __int8 *)(a2 + 16);
  if (v35 == 60 || v35 == 61) {
    BOOL v36 = (*(_WORD *)(a2 + 18) & 0x380) != 0;
  }
  else {
    BOOL v36 = (v35 - 63) <= 2;
  }
  int v37 = *(unsigned __int8 *)(v33 + 16);
  if ((v37 - 60) < 2)
  {
    BOOL v38 = (*(_WORD *)(v33 + 18) & 0x380) != 0;
    goto LABEL_64;
  }
  if ((v37 - 63) >= 3)
  {
    BOOL v38 = 0;
LABEL_64:
    if (v36 && !v38) {
      goto LABEL_68;
    }
  }
  uint64_t v39 = *(llvm::Value ****)a2;
  if (llvm::VNCoercion::canCoerceMustAliasedValueToLoad((llvm::VNCoercion *)v33, *(llvm::Value ****)a2, v10, a4))
  {
    uint64_t v57 = *(void *)(a1 + 16);
    *(void *)&long long v74 = 0;
    uint64_t v61 = v57;
    if (sub_1CD40EA84(*(void *)(v57 + 384), *(_DWORD *)(v57 + 400), v33, &v74))
    {
      uint64_t v58 = v74;
      uint64_t v59 = *(void *)(v61 + 384);
      uint64_t v60 = *(unsigned int *)(v61 + 400);
    }
    else
    {
      uint64_t v59 = *(void *)(v61 + 384);
      uint64_t v60 = *(unsigned int *)(v61 + 400);
      uint64_t v58 = v59 + 16 * v60;
    }
    if (v58 != v59 + 16 * v60)
    {
      uint64_t v41 = *(unsigned int *)(v58 + 8);
      if ((v41 & 0x80000000) == 0) {
        goto LABEL_67;
      }
    }
  }
  uint64_t v41 = llvm::VNCoercion::analyzeLoadFromClobberingLoad(v39, a4, (llvm::Value *)v33, v10, v40);
  if (v41 != -1)
  {
LABEL_67:
    uint64_t result = 1;
    *(void *)a5 = v33;
    *((void *)a5 + 1) = (v41 << 32) | 1;
    return result;
  }
LABEL_68:
  if (!sub_1CBFB3AB0(v12)) {
    unint64_t v12 = 0;
  }
  if (a4 && v12)
  {
    int v42 = *(unsigned __int8 *)(a2 + 16);
    if (v42 == 60 || v42 == 61)
    {
      if ((*(_WORD *)(a2 + 18) & 0x380) == 0) {
        goto LABEL_130;
      }
    }
    else if ((v42 - 63) >= 3)
    {
LABEL_130:
      uint64_t v56 = llvm::VNCoercion::analyzeLoadFromClobberingMemInst(*(void *)a2, a4, v12, (uint64_t)v10);
      if (v56 != -1)
      {
        *(void *)a5 = v12;
        *((void *)a5 + 1) = (v56 << 32) | 2;
        return 1;
      }
    }
  }
  uint64_t v43 = *(uint64_t ****)(a1 + 96);
  uint64_t v44 = *(void *)***v43;
  if (*(void *)(v44 + 128)) {
    goto LABEL_77;
  }
  uint64_t result = sub_1CC421DEC(*(void *)(v44 + 72), (uint64_t)"gvn", 3);
  if (result)
  {
    uint64_t v43 = *(uint64_t ****)(a1 + 96);
LABEL_77:
    uint64_t v45 = *(llvm::DominatorTree **)(a1 + 24);
    llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v74, (uint64_t)"gvn", (uint64_t)"LoadClobbered", 13, a2);
    v70[0] = "load of type ";
    v70[1] = (void *)13;
    sub_1CC59ADEC((uint64_t *)&v77, (uint64_t)v70);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v70, "Type", 4uLL, *(llvm::Type **)a2);
    uint64_t v46 = sub_1CD3D6290((uint64_t)&v74, (long long *)v70);
    v66[0] = " not eliminated";
    v66[1] = (void *)15;
    sub_1CC59ADEC((uint64_t *)(v46 + 80), (uint64_t)v66);
    *(_DWORD *)(v46 + 356) = *(_DWORD *)(v46 + 88);
    if (v73 < 0) {
      operator delete(__p);
    }
    if (v71 < 0) {
      operator delete(v70[0]);
    }
    uint64_t v47 = *(void *)(*(void *)(a2 - 32) + 8);
    if (v47)
    {
      int v48 = 0;
      do
      {
        uint64_t v49 = *(void *)(v47 + 24);
        if (v49 != a2
          && (*(unsigned char *)(v49 + 16) & 0xFE) == 0x3C
          && *(void *)(*(void *)(v49 + 40) + 56) == *(void *)(*(void *)(a2 + 40) + 56)
          && llvm::DominatorTree::dominates(v45, *(const llvm::Value **)(v47 + 24), (const llvm::Instruction *)a2))
        {
          if (v48)
          {
            if (llvm::DominatorTree::dominates(v45, v48, (const llvm::Instruction *)v49)) {
              int v48 = (const llvm::Value *)v49;
            }
          }
          else
          {
            int v48 = (const llvm::Value *)v49;
          }
        }
        uint64_t v47 = *(void *)(v47 + 8);
      }
      while (v47);
      if (v48) {
        goto LABEL_106;
      }
      uint64_t v50 = *(void *)(*(void *)(a2 - 32) + 8);
      if (v50)
      {
        int v48 = 0;
        do
        {
          uint64_t v51 = *(void *)(v50 + 24);
          if (v51 != a2
            && (*(unsigned char *)(v51 + 16) & 0xFE) == 0x3C
            && *(void *)(*(void *)(v51 + 40) + 56) == *(void *)(*(void *)(a2 + 40) + 56)
            && llvm::isPotentiallyReachable(*(void *)(v50 + 24), a2, 0, (uint64_t)v45, 0))
          {
            if (v48 && (sub_1CCD63D58(v48, (llvm::Instruction *)v51, a2, v45) & 1) == 0)
            {
              if (!sub_1CCD63D58((llvm::Value *)v51, v48, a2, v45)) {
                goto LABEL_110;
              }
            }
            else
            {
              int v48 = (const llvm::Value *)v51;
            }
          }
          uint64_t v50 = *(void *)(v50 + 8);
        }
        while (v50);
        if (v48)
        {
LABEL_106:
          v66[0] = " in favor of ";
          v66[1] = (void *)13;
          sub_1CC59ADEC((uint64_t *)&v77, (uint64_t)v66);
          llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v66, "OtherAccess", 0xBuLL, (unsigned __int8 *)v48);
          sub_1CD3D6290((uint64_t)&v74, (long long *)v66);
          if (v69 < 0) {
            operator delete(v68);
          }
          if (v67 < 0) {
            operator delete(v66[0]);
          }
        }
      }
    }
LABEL_110:
    v62[0] = " because it is clobbered by ";
    v62[1] = (void *)28;
    sub_1CC59ADEC((uint64_t *)&v77, (uint64_t)v62);
    BOOL v52 = 0;
    if (v11 != 3) {
      BOOL v52 = (unsigned __int8 *)(a3 & 0xFFFFFFFFFFFFFFF8);
    }
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v62, "ClobberedBy", 0xBuLL, v52);
    sub_1CD3D6290((uint64_t)&v74, (long long *)v62);
    if (v65 < 0) {
      operator delete(v64);
    }
    if (v63 < 0) {
      operator delete(v62[0]);
    }
    llvm::OptimizationRemarkEmitter::emit(v43, (llvm::DiagnosticInfoOptimizationBase *)&v74);
    *(void *)&long long v74 = &unk_1F2616800;
    unsigned int v53 = (char *)v77;
    if (v78)
    {
      unint64_t v54 = (unint64_t)v78 << 6;
      do
      {
        long long v55 = (void **)&v53[v54];
        if (v53[v54 - 17] < 0) {
          operator delete(*(v55 - 5));
        }
        if (*((char *)v55 - 41) < 0) {
          operator delete(*(v55 - 8));
        }
        v54 -= 64;
      }
      while (v54);
      unsigned int v53 = (char *)v77;
    }
    if (v53 != (char *)v79) {
      free(v53);
    }
    return 0;
  }
  return result;
}

void sub_1CCD5BA54(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Instruction *a4, uint64_t a5, llvm::DominatorTree *this, uint64_t a7)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (!a4
    || *((unsigned char *)a4 + 16) != 85
    || *((void *)a4 + 5) != a2
    || ((uint64_t v13 = sub_1CCD5B088(*(void *)(*((void *)a4 - 8) + 8), a5, a4, this),
         uint64_t v14 = sub_1CCD5B088(*(void *)(*((void *)a4 - 4) + 8), a5, a4, this),
         v13)
      ? (BOOL v15 = v14 == 0)
      : (BOOL v15 = 1),
        v15))
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 16) = 0;
    return;
  }
  BOOL v16 = (uint64_t *)v14;
  uint64_t v17 = *(void *)(v13 + 40);
  int v18 = *(__int16 *)(v17 + 18);
  if ((v18 & 0x80000000) == 0)
  {
    uint64_t v41 = *(void *)(v17 + 48);
    if (v41 != v17 + 40)
    {
      int v42 = 0;
      do
      {
        uint64_t v43 = v41 - 24;
        if (!v41) {
          uint64_t v43 = 0;
        }
        *(_DWORD *)(v43 + 56) = v42++;
        uint64_t v41 = *(void *)(v41 + 8);
      }
      while (v41 != v17 + 40);
    }
    *(_WORD *)(v17 + 18) = v18 | 0x8000;
  }
  uint64_t v44 = a7;
  if (*(_DWORD *)(v13 + 56) >= *(_DWORD *)(v14 + 56)) {
    uint64_t v19 = v14;
  }
  else {
    uint64_t v19 = v13;
  }
  uint64_t v20 = *(void *)(v13 - 32);
  uint64_t v21 = sub_1CB83544C(*(void *)(*(void *)(v17 + 56) + 40) + 272, *(void *)v13);
  if (v22 == 1) {
    unint64_t v23 = -2;
  }
  else {
    unint64_t v23 = (unint64_t)(v21 + 7) >> 3;
  }
  llvm::Instruction::getAAMetadata((uint64_t ***)v13, v48);
  *(void *)&long long v47 = v20;
  *((void *)&v47 + 1) = v23;
  uint64_t v24 = *(v16 - 4);
  uint64_t v25 = sub_1CB83544C(*(void *)(*(void *)(v16[5] + 56) + 40) + 272, *v16);
  if (v26 == 1) {
    unint64_t v27 = -2;
  }
  else {
    unint64_t v27 = (unint64_t)(v25 + 7) >> 3;
  }
  llvm::Instruction::getAAMetadata((uint64_t ***)v16, v46);
  *(void *)&long long v45 = v24;
  *((void *)&v45 + 1) = v27;
  uint64_t v28 = v19 + 24;
  if (v19 + 24 == a3)
  {
LABEL_51:
    *(void *)a1 = a4;
    *(void *)(a1 + 8) = 4;
    char v40 = 1;
    goto LABEL_53;
  }
  long long v29 = xmmword_1CFAC3060;
  while (1)
  {
    v51[0] = v47;
    v51[1] = v48[0];
    v51[2] = v48[1];
    char v52 = 1;
    uint64_t v53 = 1;
    uint64_t v30 = 8;
    do
    {
      int v31 = (char *)&v53 + v30;
      *(_OWORD *)int v31 = v29;
      *((_OWORD *)v31 + 1) = v29;
      v30 += 40;
    }
    while (v31 + 40 != (char *)&v55);
    long long v55 = &v60;
    uint64_t v56 = 0;
    uint64_t v57 = v59;
    uint64_t v58 = 0x400000000;
    uint64_t v60 = &unk_1F2600DB8;
    uint64_t v32 = 504;
    uint64_t v61 = 1;
    do
    {
      *(uint64_t *)((char *)&v53 + v32) = -4096;
      v32 += 16;
    }
    while (v32 != 632);
    if (v28) {
      uint64_t v33 = (llvm::Instruction *)(v28 - 24);
    }
    else {
      uint64_t v33 = 0;
    }
    char ModRefInfo = llvm::AAResults::getModRefInfo(v44, v33, v51, (uint64_t)&v53);
    if ((v61 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v62, 8);
    }
    long long v35 = xmmword_1CFAC3060;
    if (v57 != v59)
    {
      free(v57);
      long long v35 = xmmword_1CFAC3060;
    }
    if (v53)
    {
      if ((ModRefInfo & 2) != 0) {
        goto LABEL_52;
      }
    }
    else
    {
      MEMORY[0x1D25D9CD0](v54, 8);
      long long v35 = xmmword_1CFAC3060;
      if ((ModRefInfo & 2) != 0) {
        goto LABEL_52;
      }
    }
    v49[0] = v45;
    v49[1] = v46[0];
    v49[2] = v46[1];
    char v50 = 1;
    uint64_t v53 = 1;
    uint64_t v36 = 8;
    do
    {
      int v37 = (char *)&v53 + v36;
      *(_OWORD *)int v37 = v35;
      *((_OWORD *)v37 + 1) = v35;
      v36 += 40;
    }
    while (v37 + 40 != (char *)&v55);
    long long v55 = &v60;
    uint64_t v56 = 0;
    uint64_t v57 = v59;
    uint64_t v58 = 0x400000000;
    uint64_t v60 = &unk_1F2600DB8;
    uint64_t v38 = 504;
    uint64_t v61 = 1;
    do
    {
      *(uint64_t *)((char *)&v53 + v38) = -4096;
      v38 += 16;
    }
    while (v38 != 632);
    char v39 = llvm::AAResults::getModRefInfo(v44, v33, v49, (uint64_t)&v53);
    if ((v61 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v62, 8);
    }
    long long v29 = xmmword_1CFAC3060;
    if (v57 != v59)
    {
      free(v57);
      long long v29 = xmmword_1CFAC3060;
    }
    if ((v53 & 1) == 0) {
      break;
    }
    if ((v39 & 2) != 0) {
      goto LABEL_52;
    }
LABEL_45:
    uint64_t v28 = *(void *)(v28 + 8);
    if (v28 == a3) {
      goto LABEL_51;
    }
  }
  MEMORY[0x1D25D9CD0](v54, 8);
  long long v29 = xmmword_1CFAC3060;
  if ((v39 & 2) == 0) {
    goto LABEL_45;
  }
LABEL_52:
  char v40 = 0;
  *(unsigned char *)a1 = 0;
LABEL_53:
  *(unsigned char *)(a1 + 16) = v40;
}

void llvm::GVNPass::AnalyzeLoadAvailability(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(unsigned int *)(a3 + 8);
  if (v5)
  {
    uint64_t v11 = 0;
    unint64_t v12 = (uint64_t *)(a1 + 48);
    uint64_t v13 = 24 * v5;
    while (1)
    {
      uint64_t v14 = (uint64_t *)(*(void *)a3 + v11);
      uint64_t v15 = *v14;
      uint64_t v16 = v14[1];
      *(void *)uint64_t v24 = *v14;
      *(void *)unint64_t v23 = 0;
      if (sub_1CBFFBBB4(v12, v24, v23)) {
        break;
      }
      uint64_t v17 = *(llvm::Instruction **)(*(void *)a3 + v11 + 16);
      if ((unint64_t)(v16 & 7) - 1 < 2)
      {
        *(_DWORD *)&v23[12] = 0;
        if (!llvm::GVNPass::AnalyzeLoadAvailability(a1, (uint64_t)a2, v16, v17, (const llvm::DataLayout *)v23))goto LABEL_6; {
        *(void *)uint64_t v24 = v15;
        }
        *(_OWORD *)&v24[8] = *(_OWORD *)v23;
        goto LABEL_11;
      }
      sub_1CCD5BA54((uint64_t)v24, v15, v15 + 40, v17, *a2, *(llvm::DominatorTree **)(a1 + 24), *(void *)(a1 + 280));
      if (!v24[16])
      {
LABEL_6:
        unint64_t v18 = *(unsigned int *)(a5 + 8);
        if (v18 >= *(unsigned int *)(a5 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a5 + 8 * v18) = v15;
        ++*(_DWORD *)(a5 + 8);
        goto LABEL_8;
      }
      *(void *)unint64_t v23 = v15;
      *(_OWORD *)&v23[8] = *(_OWORD *)v24;
      uint64_t v19 = v23;
LABEL_12:
      unint64_t v20 = sub_1CD46398C(a4, (unint64_t)v19);
      uint64_t v21 = *(void *)a4 + 24 * *(unsigned int *)(a4 + 8);
      long long v22 = *(_OWORD *)v20;
      *(void *)(v21 + 16) = *(void *)(v20 + 16);
      *(_OWORD *)uint64_t v21 = v22;
      ++*(_DWORD *)(a4 + 8);
LABEL_8:
      v11 += 24;
      if (v13 == v11) {
        return;
      }
    }
    *(void *)uint64_t v24 = v15;
    *(_OWORD *)&v24[8] = xmmword_1CFB2CC50;
LABEL_11:
    uint64_t v19 = v24;
    goto LABEL_12;
  }
}

void llvm::GVNPass::eliminatePartiallyRedundantLoad(uint64_t a1, uint64_t ***a2, uint64_t a3, uint64_t a4)
{
  v184[34] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *(const char ***)(a4 + 24);
  uint64_t v159 = *(const char ***)(a4 + 32);
  if (v6 != v159)
  {
    unsigned int v7 = (a2 >> 4) ^ (a2 >> 9);
    while (1)
    {
      unint64_t v161 = (llvm::Value *)v6[1];
      uint64_t v162 = *v6;
      uint64_t v8 = (char *)operator new(0x60uLL);
      int v9 = v8;
      uint64_t v10 = (uint64_t ***)(v8 + 32);
      *((_DWORD *)v8 + 13) = *((_DWORD *)v8 + 13) & 0x38000000 | 1;
      *(void *)uint64_t v8 = 0;
      *((void *)v8 + 1) = 0;
      *((void *)v8 + 2) = 0;
      *((void *)v8 + 3) = v8 + 32;
      uint64_t v11 = *a2;
      if ((*((unsigned char *)a2 + 23) & 0x10) != 0) {
        break;
      }
      uint64_t v21 = 0;
      long long v22 = &byte_1CFBCE98E;
LABEL_12:
      LOWORD(v178) = 773;
      BOOL v175 = (llvm::MDNode *)v22;
      uint64_t v176 = v21;
      *(void *)&long long v177 = ".pre";
      uint64_t v24 = (const char *)*((void *)v162 + 5);
      if (v24 == v162 + 40)
      {
        uint64_t v25 = 0;
      }
      else
      {
        if (v24) {
          uint64_t v25 = (uint64_t)(v24 - 24);
        }
        else {
          uint64_t v25 = 0;
        }
        if (*(unsigned __int8 *)(v25 + 16) - 29 >= 0xB) {
          uint64_t v25 = 0;
        }
      }
      llvm::LoadInst::LoadInst((llvm::Value *)(v8 + 32), (uint64_t)v11, (uint64_t)v161, (const char **)&v175, *((_WORD *)a2 + 9) & 1, ((unint64_t)*((unsigned __int16 *)a2 + 9) >> 1) & 0x3F, (*((_WORD *)a2 + 9) >> 7) & 7, *((unsigned char *)a2 + 60), v25);
      int v26 = (unsigned __int8 *)a2[6];
      unsigned int v164 = v26;
      if (v26) {
        llvm::MetadataTracking::track((uint64_t)&v164, v26, 2);
      }
      uint64_t v28 = (unsigned __int8 **)(v9 + 80);
      unint64_t v27 = (unsigned __int8 *)*((void *)v9 + 10);
      if (v27)
      {
        int v118 = *v27;
        if ((v118 - 4) > 0x1E)
        {
          if ((v118 - 3) >= 0xFFFFFFFE) {
            uint64_t v134 = *((void *)v9 + 10);
          }
          else {
            uint64_t v134 = 0;
          }
          if ((v118 - 3) >= 0xFFFFFFFE)
          {
            unint64_t v120 = v134 + 8;
LABEL_181:
            BOOL v175 = (llvm::MDNode *)(v9 + 80);
            sub_1CC5FA668(v120 + 16, &v175);
            goto LABEL_23;
          }
          if (v118 == 3) {
            *((void *)v27 + 1) = 0;
          }
        }
        else if ((v27[1] & 0x7F) == 2 || *((_DWORD *)v27 + 3))
        {
          uint64_t v119 = *((void *)v27 + 2);
          if ((v119 & 4) != 0)
          {
            unint64_t v120 = v119 & 0xFFFFFFFFFFFFFFF8;
            if (v120) {
              goto LABEL_181;
            }
          }
        }
      }
LABEL_23:
      long long v29 = v164;
      *uint64_t v28 = v164;
      if (v29)
      {
        llvm::MetadataTracking::retrack((uint64_t)&v164, v29, (uint64_t)(v9 + 80));
        unsigned int v164 = 0;
      }
      uint64_t v30 = *(uint64_t **)(a1 + 120);
      if (v30)
      {
        int v31 = (uint64_t *)*v30;
        int v32 = *(_DWORD *)(*v30 + 40);
        if (!v32) {
          goto LABEL_32;
        }
        uint64_t v33 = v31[3];
        unsigned int v34 = v32 - 1;
        uint64_t v35 = (v32 - 1) & v7;
        uint64_t v36 = *(uint64_t ****)(v33 + 16 * v35);
        if (v36 == a2)
        {
LABEL_31:
          uint64_t v39 = *(void *)(v33 + 16 * v35 + 8);
        }
        else
        {
          int v37 = 1;
          while (v36 != (uint64_t ***)-4096)
          {
            int v38 = v35 + v37++;
            uint64_t v35 = v38 & v34;
            uint64_t v36 = *(uint64_t ****)(v33 + 16 * v35);
            if (v36 == a2) {
              goto LABEL_31;
            }
          }
LABEL_32:
          uint64_t v39 = 0;
        }
        int v40 = *(unsigned __int8 *)(v39 + 16);
        if (v40 != 26)
        {
          if (v40 == 25) {
            uint64_t v41 = v39;
          }
          else {
            uint64_t v41 = 0;
          }
          if (v41) {
            int v42 = (uint64_t *)(v41 - 32);
          }
          else {
            int v42 = (uint64_t *)(v39 - 64);
          }
          uint64_t v39 = *v42;
        }
        uint64_t v43 = (llvm::BasicBlock *)*((void *)v9 + 9);
        DefinedAccess = llvm::MemorySSA::createDefinedAccess(v31, (uint64_t)v10, v39, 0);
        llvm::MemorySSA::insertIntoListsForBlock(*v30, (uint64_t)DefinedAccess, v43, 2);
        long long v45 = *(llvm::MemorySSAUpdater **)(a1 + 120);
        if (DefinedAccess && DefinedAccess[16] == 26) {
          llvm::MemorySSAUpdater::insertDef(v45, (llvm::MemoryDef *)DefinedAccess);
        }
        llvm::MemorySSAUpdater::insertUse(v45, (llvm::MemoryUse *)DefinedAccess, 1);
      }
      llvm::Instruction::getAAMetadata(a2, &v175);
      uint64_t v46 = v176;
      long long v47 = v177;
      if (v175 || v176 || v177 != 0)
      {
        if (v175 || *v28 || (v9[55] & 0x20) != 0) {
          llvm::Value::setMetadata(v10, 1, v175);
        }
        if (v46 || *v28 || (v9[55] & 0x20) != 0) {
          llvm::Value::setMetadata(v10, 5, v46);
        }
        if ((void)v47 || *v28 || (v9[55] & 0x20) != 0) {
          llvm::Value::setMetadata(v10, 7, (llvm::MDNode *)v47);
        }
        if (*((void *)&v47 + 1) || *v28 || (v9[55] & 0x20) != 0) {
          llvm::Value::setMetadata(v10, 8, *((llvm::MDNode **)&v47 + 1));
        }
      }
      if ((*((unsigned char *)a2 + 23) & 0x20) == 0) {
        goto LABEL_80;
      }
      uint64_t v48 = ***a2;
      unsigned int v165 = (const char *)a2;
      int v49 = *(_DWORD *)(v48 + 2496);
      if (v49)
      {
        uint64_t v50 = *(void *)(v48 + 2480);
        int v51 = v49 - 1;
        unsigned int v52 = v51 & v7;
        uint64_t v53 = (uint64_t ****)(v50 + 40 * (v51 & v7));
        uint64_t v54 = *v53;
        if (*v53 == a2) {
          goto LABEL_73;
        }
        long long v55 = 0;
        int v56 = 1;
        while (v54 != (uint64_t ***)-4096)
        {
          if (v55) {
            BOOL v57 = 0;
          }
          else {
            BOOL v57 = v54 == (uint64_t ***)-8192;
          }
          if (v57) {
            long long v55 = v53;
          }
          unsigned int v58 = v52 + v56++;
          unsigned int v52 = v58 & v51;
          uint64_t v53 = (uint64_t ****)(v50 + 40 * v52);
          uint64_t v54 = *v53;
          if (*v53 == a2) {
            goto LABEL_73;
          }
        }
        if (v55) {
          unint64_t v121 = v55;
        }
        else {
          unint64_t v121 = v53;
        }
      }
      else
      {
        unint64_t v121 = 0;
      }
      uint64_t v53 = (uint64_t ****)sub_1CC609054(v48 + 2480, (uint64_t)&v165, (uint64_t *)&v165, v121);
      unint64_t v122 = v165;
      v53[4] = 0;
      v53[3] = 0;
      char *v53 = (uint64_t ***)v122;
      v53[1] = (uint64_t ***)(v53 + 3);
      v53[2] = (uint64_t ***)0x100000000;
LABEL_73:
      uint64_t v59 = *((unsigned int *)v53 + 4);
      if (v59)
      {
        uint64_t v60 = (llvm::MDNode **)(v53[1] + 1);
        uint64_t v61 = 16 * v59;
        while (*((_DWORD *)v60 - 2) != 6)
        {
          v60 += 2;
          v61 -= 16;
          if (!v61) {
            goto LABEL_80;
          }
        }
        if (*v60) {
          llvm::Value::setMetadata(v10, 6, *v60);
        }
      }
LABEL_80:
      if ((*((unsigned char *)a2 + 23) & 0x20) == 0) {
        goto LABEL_98;
      }
      uint64_t v62 = ***a2;
      unsigned int v165 = (const char *)a2;
      int v63 = *(_DWORD *)(v62 + 2496);
      if (v63)
      {
        uint64_t v64 = *(void *)(v62 + 2480);
        int v65 = v63 - 1;
        unsigned int v66 = v65 & v7;
        char v67 = (uint64_t ****)(v64 + 40 * (v65 & v7));
        long long v68 = *v67;
        if (*v67 == a2) {
          goto LABEL_91;
        }
        char v69 = 0;
        int v70 = 1;
        while (v68 != (uint64_t ***)-4096)
        {
          if (v69) {
            BOOL v71 = 0;
          }
          else {
            BOOL v71 = v68 == (uint64_t ***)-8192;
          }
          if (v71) {
            char v69 = v67;
          }
          unsigned int v72 = v66 + v70++;
          unsigned int v66 = v72 & v65;
          char v67 = (uint64_t ****)(v64 + 40 * v66);
          long long v68 = *v67;
          if (*v67 == a2) {
            goto LABEL_91;
          }
        }
        if (v69) {
          unint64_t v123 = v69;
        }
        else {
          unint64_t v123 = v67;
        }
      }
      else
      {
        unint64_t v123 = 0;
      }
      char v67 = (uint64_t ****)sub_1CC609054(v62 + 2480, (uint64_t)&v165, (uint64_t *)&v165, v123);
      uint64_t v124 = v165;
      void v67[4] = 0;
      v67[3] = 0;
      long long *v67 = (uint64_t ***)v124;
      v67[1] = (uint64_t ***)(v67 + 3);
      v67[2] = (uint64_t ***)0x100000000;
LABEL_91:
      uint64_t v73 = *((unsigned int *)v67 + 4);
      if (v73)
      {
        long long v74 = (llvm::MDNode **)(v67[1] + 1);
        uint64_t v75 = 16 * v73;
        while (*((_DWORD *)v74 - 2) != 16)
        {
          v74 += 2;
          v75 -= 16;
          if (!v75) {
            goto LABEL_98;
          }
        }
        if (*v74) {
          llvm::Value::setMetadata(v10, 16, *v74);
        }
      }
LABEL_98:
      if ((*((unsigned char *)a2 + 23) & 0x20) == 0) {
        goto LABEL_116;
      }
      uint64_t v76 = ***a2;
      unsigned int v165 = (const char *)a2;
      int v77 = *(_DWORD *)(v76 + 2496);
      if (v77)
      {
        uint64_t v78 = *(void *)(v76 + 2480);
        int v79 = v77 - 1;
        unsigned int v80 = v79 & v7;
        uint64_t v81 = (uint64_t ****)(v78 + 40 * (v79 & v7));
        unsigned int v82 = *v81;
        if (*v81 == a2) {
          goto LABEL_109;
        }
        unsigned int v83 = 0;
        int v84 = 1;
        while (v82 != (uint64_t ***)-4096)
        {
          if (v83) {
            BOOL v85 = 0;
          }
          else {
            BOOL v85 = v82 == (uint64_t ***)-8192;
          }
          if (v85) {
            unsigned int v83 = v81;
          }
          unsigned int v86 = v80 + v84++;
          unsigned int v80 = v86 & v79;
          uint64_t v81 = (uint64_t ****)(v78 + 40 * v80);
          unsigned int v82 = *v81;
          if (*v81 == a2) {
            goto LABEL_109;
          }
        }
        if (v83) {
          uint64_t v125 = v83;
        }
        else {
          uint64_t v125 = v81;
        }
      }
      else
      {
        uint64_t v125 = 0;
      }
      uint64_t v81 = (uint64_t ****)sub_1CC609054(v76 + 2480, (uint64_t)&v165, (uint64_t *)&v165, v125);
      uint64_t v126 = v165;
      v81[4] = 0;
      v81[3] = 0;
      char *v81 = (uint64_t ***)v126;
      v81[1] = (uint64_t ***)(v81 + 3);
      v81[2] = (uint64_t ***)0x100000000;
LABEL_109:
      uint64_t v87 = *((unsigned int *)v81 + 4);
      if (v87)
      {
        unsigned int v88 = (llvm::MDNode **)(v81[1] + 1);
        uint64_t v89 = 16 * v87;
        while (*((_DWORD *)v88 - 2) != 4)
        {
          v88 += 2;
          v89 -= 16;
          if (!v89) {
            goto LABEL_116;
          }
        }
        if (*v88) {
          llvm::Value::setMetadata(v10, 4, *v88);
        }
      }
LABEL_116:
      if ((*((unsigned char *)a2 + 23) & 0x20) != 0)
      {
        uint64_t v90 = ***a2;
        unsigned int v165 = (const char *)a2;
        int v91 = *(_DWORD *)(v90 + 2496);
        if (v91)
        {
          uint64_t v92 = *(void *)(v90 + 2480);
          int v93 = v91 - 1;
          unsigned int v94 = v93 & v7;
          uint64_t v95 = (void *)(v92 + 40 * (v93 & v7));
          uint64_t v96 = (void ***)*v95;
          if ((uint64_t ***)*v95 != a2)
          {
            unsigned int v97 = 0;
            int v98 = 1;
            while (v96 != (void ***)-4096)
            {
              if (v97) {
                BOOL v99 = 0;
              }
              else {
                BOOL v99 = v96 == (void ***)-8192;
              }
              if (v99) {
                unsigned int v97 = v95;
              }
              unsigned int v100 = v94 + v98++;
              unsigned int v94 = v100 & v93;
              uint64_t v95 = (void *)(v92 + 40 * v94);
              uint64_t v96 = (void ***)*v95;
              if ((uint64_t ***)*v95 == a2) {
                goto LABEL_127;
              }
            }
            if (v97) {
              unint64_t v127 = v97;
            }
            else {
              unint64_t v127 = v95;
            }
LABEL_166:
            uint64_t v95 = sub_1CC609054(v90 + 2480, (uint64_t)&v165, (uint64_t *)&v165, v127);
            unint64_t v128 = v165;
            v95[4] = 0;
            v95[3] = 0;
            void *v95 = v128;
            v95[1] = v95 + 3;
            v95[2] = 0x100000000;
          }
LABEL_127:
          uint64_t v101 = *((unsigned int *)v95 + 4);
          if (v101)
          {
            unsigned int v102 = (llvm::MDNode **)(v95[1] + 8);
            uint64_t v103 = 16 * v101;
            while (*((_DWORD *)v102 - 2) != 25)
            {
              v102 += 2;
              v103 -= 16;
              if (!v103) {
                goto LABEL_131;
              }
            }
            uint64_t v107 = *v102;
            if (*v102)
            {
              uint64_t v108 = *(uint64_t **)(a1 + 112);
              if (v108)
              {
                int v109 = *((_DWORD *)v108 + 4);
                if (!v109) {
                  goto LABEL_175;
                }
                unint64_t v110 = a2[5];
                uint64_t v111 = *v108;
                unsigned int v112 = v109 - 1;
                uint64_t v113 = ((v110 >> 4) ^ (v110 >> 9)) & v112;
                uint64_t v114 = *(uint64_t ***)(v111 + 16 * v113);
                if (v110 == v114)
                {
LABEL_140:
                  uint64_t v117 = *(void *)(v111 + 16 * v113 + 8);
                }
                else
                {
                  int v115 = 1;
                  while (v114 != (uint64_t **)-4096)
                  {
                    int v116 = v113 + v115++;
                    uint64_t v113 = v116 & v112;
                    uint64_t v114 = *(uint64_t ***)(v111 + 16 * v113);
                    if (v110 == v114) {
                      goto LABEL_140;
                    }
                  }
                  uint64_t v117 = 0;
                }
                uint64_t v129 = v112 & ((v162 >> 4) ^ (v162 >> 9));
                uint64_t v130 = *(const char **)(v111 + 16 * v129);
                if (v162 == v130)
                {
LABEL_172:
                  uint64_t v133 = *(void *)(v111 + 16 * v129 + 8);
                }
                else
                {
                  int v131 = 1;
                  while (v130 != (const char *)-4096)
                  {
                    int v132 = v129 + v131++;
                    uint64_t v129 = v132 & v112;
                    uint64_t v130 = *(const char **)(v111 + 16 * v129);
                    if (v162 == v130) {
                      goto LABEL_172;
                    }
                  }
                  uint64_t v133 = 0;
                }
                if (v117 == v133) {
LABEL_175:
                }
                  llvm::Value::setMetadata(v10, 25, v107);
              }
            }
          }
          goto LABEL_131;
        }
        unint64_t v127 = 0;
        goto LABEL_166;
      }
LABEL_131:
      unsigned int v165 = v162;
      uint64_t v166 = (uint64_t)v10;
      *(void *)&long long v167 = 0;
      unint64_t v104 = sub_1CD46398C(a3, (unint64_t)&v165);
      uint64_t v105 = *(void *)a3 + 24 * *(unsigned int *)(a3 + 8);
      long long v106 = *(_OWORD *)v104;
      *(void *)(v105 + 16) = *(void *)(v104 + 16);
      *(_OWORD *)uint64_t v105 = v106;
      ++*(_DWORD *)(a3 + 8);
      llvm::MemoryDependenceResults::invalidateCachedPointerInfo(*(llvm::MemoryDependenceResults **)(a1 + 16), v161);
      v6 += 2;
      if (v6 == v159) {
        goto LABEL_188;
      }
    }
    uint64_t v12 = **v11;
    uint64_t v13 = *(void *)(v12 + 152);
    uint64_t v14 = *(unsigned int *)(v12 + 168);
    if (v14)
    {
      LODWORD(v15) = (v14 - 1) & v7;
      uint64_t v16 = (uint64_t ****)(v13 + 16 * v15);
      uint64_t v17 = *v16;
      if (*v16 == a2)
      {
LABEL_11:
        unint64_t v20 = v16[1];
        unint64_t v23 = (llvm::MDNode *)*v20;
        long long v22 = (const char *)(v20 + 2);
        uint64_t v21 = v23;
        goto LABEL_12;
      }
      int v18 = 1;
      while (v17 != (uint64_t ***)-4096)
      {
        int v19 = v15 + v18++;
        uint64_t v15 = v19 & (v14 - 1);
        uint64_t v17 = *(uint64_t ****)(v13 + 16 * v15);
        if (v17 == a2)
        {
          uint64_t v16 = (uint64_t ****)(v13 + 16 * v15);
          goto LABEL_11;
        }
      }
    }
    uint64_t v16 = (uint64_t ****)(v13 + 16 * v14);
    goto LABEL_11;
  }
LABEL_188:
  long long v135 = sub_1CCD5CDB8((uint64_t)a2, (uint64_t *)a3, a1);
  llvm::Value::doRAUW((llvm::ValueAsMetadata *)a2, v135, (llvm::Value *)1);
  unsigned int v136 = *((unsigned __int8 *)v135 + 16);
  if (v136 == 83)
  {
    llvm::Value::takeName((int32x2_t ****)v135, (llvm::Value *)a2);
    unsigned int v136 = *((unsigned __int8 *)v135 + 16);
  }
  if (v136 >= 0x1C)
  {
    unint64_t v137 = (unsigned __int8 *)a2[6];
    uint64_t v163 = v137;
    if (v137) {
      llvm::MetadataTracking::track((uint64_t)&v163, v137, 2);
    }
    unint64_t v138 = (unsigned __int8 **)((char *)v135 + 48);
    if (&v163 != (unsigned __int8 **)((char *)v135 + 48))
    {
      uint64_t v139 = *v138;
      if (!*v138) {
        goto LABEL_195;
      }
      int v148 = *v139;
      if ((v148 - 4) > 0x1E)
      {
        if ((v148 - 3) >= 0xFFFFFFFE) {
          unint64_t v154 = *v138;
        }
        else {
          unint64_t v154 = 0;
        }
        if ((v148 - 3) < 0xFFFFFFFE)
        {
          if (v148 == 3) {
            *((void *)v139 + 1) = 0;
          }
          goto LABEL_195;
        }
        unint64_t v150 = (unint64_t)(v154 + 8);
      }
      else if ((v139[1] & 0x7F) != 2 && !*((_DWORD *)v139 + 3) {
             || (uint64_t v149 = *((void *)v139 + 2), (v149 & 4) == 0)
      }
             || (unint64_t v150 = v149 & 0xFFFFFFFFFFFFFFF8) == 0)
      {
LABEL_195:
        uint64_t v140 = v163;
        const llvm::Instruction *v138 = v163;
        if (v140)
        {
          llvm::MetadataTracking::retrack((uint64_t)&v163, v140, (uint64_t)v135 + 48);
          uint64_t v163 = 0;
        }
        goto LABEL_197;
      }
      BOOL v175 = (llvm::UndefValue *)((char *)v135 + 48);
      sub_1CC5FA668(v150 + 16, &v175);
      goto LABEL_195;
    }
    if (!v163) {
      goto LABEL_197;
    }
    int v155 = *v163;
    if ((v155 - 4) <= 0x1E)
    {
      if ((v163[1] & 0x7F) != 2 && !*((_DWORD *)v163 + 3)) {
        goto LABEL_197;
      }
      uint64_t v156 = *((void *)v163 + 2);
      if ((v156 & 4) == 0) {
        goto LABEL_197;
      }
      unint64_t v157 = v156 & 0xFFFFFFFFFFFFFFF8;
      if (!v157) {
        goto LABEL_197;
      }
LABEL_253:
      BOOL v175 = (llvm::MDNode *)&v163;
      sub_1CC5FA668(v157 + 16, &v175);
      goto LABEL_197;
    }
    if ((v155 - 3) >= 0xFFFFFFFE) {
      uint64_t v158 = v163;
    }
    else {
      uint64_t v158 = 0;
    }
    if ((v155 - 3) >= 0xFFFFFFFE)
    {
      unint64_t v157 = (unint64_t)(v158 + 8);
      goto LABEL_253;
    }
    if (v155 == 3) {
      *((void *)v163 + 1) = 0;
    }
  }
LABEL_197:
  if ((*(_DWORD *)(*(void *)v135 + 8) & 0xFE) == 0x12) {
    int v141 = *(unsigned __int8 *)(**(void **)(*(void *)v135 + 16) + 8);
  }
  else {
    int v141 = *(_DWORD *)(*(void *)v135 + 8);
  }
  if (v141 == 15) {
    llvm::MemoryDependenceResults::invalidateCachedPointerInfo(*(llvm::MemoryDependenceResults **)(a1 + 16), v135);
  }
  sub_1CCD5D120((int32x2_t *)a1, (llvm::Value *)a2);
  unsigned int v142 = *(uint64_t ****)(a1 + 96);
  uint64_t v143 = *(void *)***v142;
  if (*(void *)(v143 + 128)
    || (*(unsigned int (**)(void))(**(void **)(v143 + 72) + 48))(*(void *)(v143 + 72)))
  {
    llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v175, (uint64_t)"gvn", (uint64_t)"LoadPRE", 7, (uint64_t)a2);
    unsigned int v165 = "load eliminated by PRE";
    uint64_t v166 = 22;
    sub_1CC59ADEC((uint64_t *)&v182, (uint64_t)&v165);
    LODWORD(v166) = v176;
    BYTE4(v166) = BYTE4(v176);
    long long v167 = v177;
    uint64_t v168 = v178;
    unsigned int v165 = (const char *)&unk_1F2616800;
    long long v169 = v179;
    long long v170 = v180;
    uint64_t v171 = v181;
    unint64_t v172 = v174;
    uint64_t v173 = 0x400000000;
    unsigned int v144 = v183;
    if (v183)
    {
      sub_1CD494D68((uint64_t)&v172, (uint64_t)&v182);
      unsigned int v144 = v183;
    }
    v174[32] = v184[32];
    v174[33] = v184[33];
    unsigned int v165 = (const char *)&unk_1F2616570;
    BOOL v175 = (llvm::MDNode *)&unk_1F2616800;
    unint64_t v145 = (char *)v182;
    if (v144)
    {
      unint64_t v146 = (unint64_t)v144 << 6;
      do
      {
        unint64_t v147 = (void **)&v145[v146];
        if (v145[v146 - 17] < 0) {
          operator delete(*(v147 - 5));
        }
        if (*((char *)v147 - 41) < 0) {
          operator delete(*(v147 - 8));
        }
        v146 -= 64;
      }
      while (v146);
      unint64_t v145 = (char *)v182;
    }
    if (v145 != (char *)v184) {
      free(v145);
    }
    llvm::OptimizationRemarkEmitter::emit(v142, (llvm::DiagnosticInfoOptimizationBase *)&v165);
    unsigned int v165 = (const char *)&unk_1F2616800;
    unsigned int v151 = (char *)v172;
    if (v173)
    {
      unint64_t v152 = (unint64_t)v173 << 6;
      do
      {
        uint64_t v153 = (void **)&v151[v152];
        if (v151[v152 - 17] < 0) {
          operator delete(*(v153 - 5));
        }
        if (*((char *)v153 - 41) < 0) {
          operator delete(*(v153 - 8));
        }
        v152 -= 64;
      }
      while (v152);
      unsigned int v151 = (char *)v172;
    }
    if (v151 != (char *)v174) {
      free(v151);
    }
  }
}

llvm::UndefValue *sub_1CCD5CDB8(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  v48[8] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 2) == 1) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  v47[0] = v48;
  v47[1] = (void *)0x800000000;
  memset(v43, 0, sizeof(v43));
  uint64_t v44 = 0;
  long long v45 = v47;
  unint64_t v6 = *(llvm::IntegerType ***)a1;
  if ((*(unsigned char *)(a1 + 23) & 0x10) != 0)
  {
    uint64_t v7 = *(void *)*v6;
    uint64_t v8 = *(void *)(v7 + 152);
    uint64_t v9 = *(unsigned int *)(v7 + 168);
    if (v9)
    {
      LODWORD(v10) = (v9 - 1) & ((a1 >> 4) ^ (a1 >> 9));
      uint64_t v11 = (uint64_t *)(v8 + 16 * v10);
      uint64_t v12 = *v11;
      if (*v11 == a1)
      {
LABEL_11:
        uint64_t v15 = (void *)v11[1];
        size_t v18 = *v15;
        uint64_t v16 = (char *)(v15 + 2);
        size_t v17 = v18;
        goto LABEL_12;
      }
      int v13 = 1;
      while (v12 != -4096)
      {
        int v14 = v10 + v13++;
        uint64_t v10 = v14 & (v9 - 1);
        uint64_t v12 = *(void *)(v8 + 16 * v10);
        if (v12 == a1)
        {
          uint64_t v11 = (uint64_t *)(v8 + 16 * v10);
          goto LABEL_11;
        }
      }
    }
    uint64_t v11 = (uint64_t *)(v8 + 16 * v9);
    goto LABEL_11;
  }
  size_t v17 = 0;
  uint64_t v16 = &byte_1CFBCE98E;
LABEL_12:
  llvm::SSAUpdater::Initialize((uint64_t)v43, (uint64_t)v6, v16, v17);
  unsigned int v19 = *((_DWORD *)a2 + 2);
  if (v19)
  {
    uint64_t v20 = *a2;
    uint64_t v21 = *a2 + 24 * v19;
    while (1)
    {
      unsigned int v22 = *(_DWORD *)(v20 + 16);
      if (v22 == 3) {
        goto LABEL_43;
      }
      unint64_t v23 = *(llvm::BasicBlock **)v20;
      if (llvm::SSAUpdater::HasValueForBlock((uint64_t **)v43, *(llvm::BasicBlock **)v20)) {
        goto LABEL_43;
      }
      uint64_t v25 = (void *)(v20 + 8);
      int v26 = *(llvm::BasicBlock **)(a1 + 40);
      if (v23 == v26 && v22 <= 1 && *v25 == a1) {
        goto LABEL_43;
      }
      unint64_t v27 = (llvm::BasicBlock *)*((void *)v23 + 5);
      if (v27 == (llvm::BasicBlock *)((char *)v23 + 40))
      {
        long long v29 = 0;
      }
      else
      {
        uint64_t v28 = v27 ? (uint64_t)v27 - 24 : 0;
        long long v29 = *(unsigned __int8 *)(v28 + 16) - 29 >= 0xB ? 0 : (llvm::Type *)v28;
      }
      uint64_t v30 = sub_1CCD5AF1C((uint64_t)v25, *(llvm::IntegerType ***)a1, *(void *)(*((void *)v26 + 7) + 40), v29, a3, v24);
      uint64_t v46 = v23;
      int v31 = *(_DWORD *)(*(void *)&v43[0] + 16);
      if (!v31) {
        break;
      }
      int v32 = v31 - 1;
      unsigned int v33 = (v31 - 1) & ((v23 >> 4) ^ (v23 >> 9));
      unsigned int v34 = (uint64_t *)(**(void **)&v43[0] + 16 * v33);
      uint64_t v35 = *v34;
      if ((llvm::BasicBlock *)*v34 != v23)
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != -4096)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -8192;
          }
          if (v38) {
            uint64_t v36 = v34;
          }
          unsigned int v39 = v33 + v37++;
          unsigned int v33 = v39 & v32;
          unsigned int v34 = (uint64_t *)(**(void **)&v43[0] + 16 * (v39 & v32));
          uint64_t v35 = *v34;
          if ((llvm::BasicBlock *)*v34 == v23) {
            goto LABEL_42;
          }
        }
        if (v36) {
          int v40 = v36;
        }
        else {
          int v40 = v34;
        }
        goto LABEL_41;
      }
LABEL_42:
      v34[1] = (uint64_t)v30;
LABEL_43:
      v20 += 24;
      if (v20 == v21) {
        goto LABEL_46;
      }
    }
    int v40 = 0;
LABEL_41:
    unsigned int v34 = sub_1CC0A3E2C(*(uint64_t *)&v43[0], (uint64_t)&v46, (uint64_t *)&v46, v40);
    *unsigned int v34 = (uint64_t)v46;
    v34[1] = 0;
    goto LABEL_42;
  }
LABEL_46:
  ValueInMiddleOfBlocuint64_t k = llvm::SSAUpdater::GetValueInMiddleOfBlock((llvm::UndefValue **)v43, *(llvm::BasicBlock **)(a1 + 40));
  llvm::SSAUpdater::~SSAUpdater((void **)v43);
  if (v47[0] != v48) {
    free(v47[0]);
  }
  return ValueInMiddleOfBlock;
}

void sub_1CCD5D120(int32x2_t *a1, llvm::Value *a2)
{
  llvm::GVNPass::ValueTable::erase(a1 + 16, a2);
  unsigned __int32 v4 = a1[74].u32[0];
  if (v4 >= a1[74].i32[1]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)&a1[73] + 8 * v4) = a2;
  ++a1[74].i32[0];
}

BOOL llvm::GVNPass::PerformLoadPRE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v183[32] = *MEMORY[0x1E4F143B8];
  sub_1CC874DB4((llvm::SmallPtrSetImplBase *)&v166, *(uint64_t **)a4, (uint64_t *)(*(void *)a4 + 8 * *(unsigned int *)(a4 + 8)));
  uint64_t v8 = *(llvm::BasicBlock **)(a2 + 40);
  isPreceededBySpecialInstructiouint64_t n = llvm::InstructionPrecedenceTracking::isPreceededBySpecialInstruction(*(int32x2_t **)(a1 + 104), (const llvm::BasicBlock **)a2);
  uint64_t SinglePredecessor = (llvm::BasicBlock *)llvm::BasicBlock::getSinglePredecessor(v8);
  if (SinglePredecessor)
  {
    do
    {
      if (SinglePredecessor == v8) {
        goto LABEL_55;
      }
      uint64_t v11 = SinglePredecessor;
      uint64_t v12 = v166;
      if (v167 == v166)
      {
        unsigned int v13 = v169;
        int v14 = &v167[8 * v169];
        if (v169)
        {
          uint64_t v15 = 0;
          while (*(llvm::BasicBlock **)&v167[v15] != SinglePredecessor)
          {
            v15 += 8;
            if (8 * v169 == v15) {
              goto LABEL_22;
            }
          }
          int v14 = &v167[v15];
        }
LABEL_22:
        uint64_t v12 = v167;
      }
      else
      {
        unsigned int v16 = v168 - 1;
        unsigned int v17 = (v168 - 1) & ((SinglePredecessor >> 4) ^ (SinglePredecessor >> 9));
        int v14 = &v167[8 * v17];
        size_t v18 = *(llvm::BasicBlock **)v14;
        if (*(void *)v14 == -1)
        {
          unsigned int v19 = 0;
LABEL_43:
          if (v19) {
            int v14 = v19;
          }
          unsigned int v13 = v169;
          if (*(llvm::BasicBlock **)v14 != SinglePredecessor) {
            int v14 = &v167[8 * v168];
          }
        }
        else
        {
          unsigned int v19 = 0;
          int v20 = 1;
          while (v18 != SinglePredecessor)
          {
            if (v19) {
              BOOL v21 = 0;
            }
            else {
              BOOL v21 = v18 == (llvm::BasicBlock *)-2;
            }
            if (v21) {
              unsigned int v19 = v14;
            }
            unsigned int v22 = v17 + v20++;
            unsigned int v17 = v22 & v16;
            int v14 = &v167[8 * (v22 & v16)];
            size_t v18 = *(llvm::BasicBlock **)v14;
            if (*(void *)v14 == -1) {
              goto LABEL_43;
            }
          }
          unsigned int v13 = v169;
        }
      }
      int v23 = v167 == v12 ? v13 : v168;
      if (v14 != &v167[8 * v23]) {
        goto LABEL_55;
      }
      uint64_t v24 = (void *)*((void *)SinglePredecessor + 5);
      if (v24 == (void *)((char *)SinglePredecessor + 40))
      {
        uint64_t v25 = 0;
      }
      else
      {
        if (v24) {
          uint64_t v25 = v24 - 3;
        }
        else {
          uint64_t v25 = 0;
        }
        if (*((unsigned __int8 *)v25 + 16) - 29 >= 0xB) {
          uint64_t v25 = 0;
        }
      }
      if (*((unsigned char *)v25 + 16) != 30)
      {
        BOOL v26 = 0;
        switch(*((unsigned char *)v25 + 16))
        {
          case 0x1E:
LABEL_339:
            __break(1u);
            JUMPOUT(0x1CCD5E100);
          case 0x1F:
            int v27 = (*((_DWORD *)v25 + 5) >> 1) & 0x3FFFFFF;
            goto LABEL_50;
          case 0x20:
          case 0x26:
            int v27 = (*((_DWORD *)v25 + 5) & 0x7FFFFFF) - 1;
            goto LABEL_50;
          case 0x24:
            int v27 = *((_WORD *)v25 + 9) & 1;
            goto LABEL_50;
          case 0x25:
            goto LABEL_37;
          case 0x27:
            int v27 = *((_DWORD *)v25 + 20) + 1;
LABEL_50:
            if (v27 != 1) {
              goto LABEL_55;
            }
            goto LABEL_37;
          default:
            goto LABEL_336;
        }
      }
      if ((*((_DWORD *)v25 + 5) & 0x7FFFFFF) == 3)
      {
LABEL_55:
        BOOL v26 = 0;
        goto LABEL_336;
      }
LABEL_37:
      isPreceededBySpecialInstructiouint64_t n = (isPreceededBySpecialInstruction & 1) != 0
                                     || llvm::InstructionPrecedenceTracking::getFirstSpecialInstruction(*(int32x2_t **)(a1 + 104), SinglePredecessor) != 0;
      uint64_t SinglePredecessor = (llvm::BasicBlock *)llvm::BasicBlock::getSinglePredecessor(v11);
    }
    while (SinglePredecessor);
  }
  else
  {
    uint64_t v11 = v8;
  }
  int v156 = isPreceededBySpecialInstruction;
  v161[0] = 0;
  v161[1] = 0;
  int v162 = 0;
  unsigned int v164 = 0;
  uint64_t v165 = 0;
  long long __p = 0;
  v159[0] = 0;
  v159[1] = 0;
  int v160 = 0;
  uint64_t v28 = *(unsigned int *)(a3 + 8);
  if (v28)
  {
    long long v29 = *(uint64_t **)a3;
    uint64_t v30 = 24 * v28;
    do
    {
      *((unsigned char *)sub_1CCD64D9C((uint64_t)v159, v29) + 8) = 1;
      v29 += 3;
      v30 -= 24;
    }
    while (v30);
  }
  uint64_t v31 = *(unsigned int *)(a4 + 8);
  if (v31)
  {
    int v32 = *(uint64_t **)a4;
    uint64_t v33 = 8 * v31;
    do
    {
      unsigned int v34 = (void *)*v32++;
      uint64_t v181 = v34;
      *((unsigned char *)sub_1CCD64D9C((uint64_t)v159, (uint64_t *)&v181) + 8) = 0;
      v33 -= 8;
    }
    while (v33);
  }
  uint64_t v178 = v180;
  uint64_t v179 = 0x400000000;
  uint64_t v35 = *((void *)v11 + 1);
  if (!v35)
  {
LABEL_73:
    int v40 = 0;
    goto LABEL_272;
  }
  while (1)
  {
    uint64_t v36 = *(void *)(v35 + 24);
    unsigned int v37 = *(unsigned __int8 *)(v36 + 16);
    BOOL v38 = v36 && v37 >= 0x1C;
    if (v38 && v37 - 29 < 0xB) {
      break;
    }
    uint64_t v35 = *(void *)(v35 + 8);
    if (!v35) {
      goto LABEL_73;
    }
  }
  uint64_t v153 = a3;
LABEL_74:
  uint64_t v158 = *(void *)(v36 + 40);
  uint64_t v154 = v158;
  int v42 = (void *)(v158 + 40);
  uint64_t v41 = *(void *)(v158 + 40);
  if (v41) {
    uint64_t v43 = v41 - 24;
  }
  else {
    uint64_t v43 = 0;
  }
  if (*(unsigned __int8 *)(v43 + 16) - 29 >= 0xB) {
    uint64_t v43 = 0;
  }
  unsigned int v44 = *(unsigned __int8 *)(v43 + 16) - 38;
  BOOL v58 = v44 > 0x38;
  uint64_t v45 = (1 << v44) & 0x100060000000001;
  if (!v58 && v45 != 0)
  {
LABEL_330:
    BOOL v26 = 0;
    goto LABEL_331;
  }
  uint64_t v47 = a2;
  int v48 = 0;
  uint64_t v181 = v183;
  HIDWORD(v182) = 32;
  v183[0] = v158;
  unsigned int v49 = 1;
  uint64_t v50 = v159[0];
  while (1)
  {
    uint64_t v51 = *((void *)v181 + v49 - 1);
    LODWORD(v182) = v49 - 1;
    uint64_t v170 = v51;
    uint64_t v171 = 0;
    if (!sub_1CBF8BDAC(v50, v160, v51, &v171)) {
      break;
    }
    uint64_t v50 = v159[0];
    if (!*((unsigned char *)v171 + 8)) {
      goto LABEL_112;
    }
LABEL_109:
    unsigned int v49 = v182;
    if (!v182)
    {
      char v63 = 1;
      a2 = v47;
      goto LABEL_215;
    }
  }
  unsigned int v52 = sub_1CCD63E04((uint64_t)v159, &v170, v171);
  void *v52 = v51;
  *((unsigned char *)v52 + 8) = 2;
  uint64_t v50 = v159[0];
  if (++v48 <= dword_1EBCF1F88)
  {
    uint64_t v53 = *(void *)(v51 + 8);
    uint64_t v54 = v53;
    if (v53)
    {
      while (1)
      {
        uint64_t v55 = *(void *)(v54 + 24);
        unsigned int v56 = *(unsigned __int8 *)(v55 + 16);
        BOOL v57 = v55 && v56 >= 0x1C;
        BOOL v58 = !v57 || v56 - 29 > 0xA;
        if (!v58) {
          break;
        }
        uint64_t v54 = *(void *)(v54 + 8);
        if (!v54) {
          goto LABEL_111;
        }
      }
      do
      {
        uint64_t v59 = *(void *)(v53 + 24);
        unsigned int v60 = *(unsigned __int8 *)(v59 + 16);
        if (v59) {
          BOOL v61 = v60 >= 0x1C;
        }
        else {
          BOOL v61 = 0;
        }
        if (v61 && v60 - 29 < 0xB) {
          break;
        }
        uint64_t v53 = *(void *)(v53 + 8);
      }
      while (v53);
      sub_1CBF846A4((uint64_t)&v181, v53, 0);
      goto LABEL_109;
    }
  }
LABEL_111:
  *((unsigned char *)v52 + 8) = 0;
LABEL_112:
  LODWORD(v182) = 0;
  uint64_t v64 = *(void *)(v51 + 40);
  if (v64 == v51 + 40)
  {
LABEL_123:
    uint64_t v65 = 0;
    uint64_t v69 = 0;
    a2 = v47;
  }
  else
  {
    uint64_t v65 = v64 - 24;
    if (v64) {
      uint64_t v66 = v64 - 24;
    }
    else {
      uint64_t v66 = 0;
    }
    int v67 = *(unsigned __int8 *)(v66 + 16);
    int v68 = v67 - 29;
    if (v67 != 30)
    {
      unsigned int v82 = 0;
      a2 = v47;
      switch(v68)
      {
        case 0:
        case 5:
        case 6:
          goto LABEL_122;
        case 1:
          goto LABEL_339;
        case 2:
          unsigned int v82 = (*(_DWORD *)(v66 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_122;
        case 3:
        case 9:
          unsigned int v82 = (*(_DWORD *)(v66 + 20) & 0x7FFFFFF) - 1;
          goto LABEL_122;
        case 4:
          unsigned int v82 = 2;
          goto LABEL_122;
        case 7:
          unsigned int v82 = *(_WORD *)(v66 + 18) & 1;
          goto LABEL_122;
        case 8:
          unsigned int v82 = 1;
          goto LABEL_122;
        case 10:
          unsigned int v82 = *(_DWORD *)(v66 + 80) + 1;
          goto LABEL_122;
        default:
          goto LABEL_123;
      }
    }
    if ((*(_DWORD *)(v66 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v82 = 2;
    }
    else {
      unsigned int v82 = 1;
    }
    a2 = v47;
LABEL_122:
    uint64_t v69 = v82;
  }
  if ((int)v69 > (unint64_t)HIDWORD(v182)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v69)
  {
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    unsigned int v72 = v181;
    int v73 = *(unsigned __int8 *)(v65 + 16);
    uint64_t v74 = v65 - 64;
    do
    {
      if (v73 == 30)
      {
        uint64_t v76 = (uint64_t *)(v65 - 32 - 32 * v71);
      }
      else
      {
        uint64_t v76 = (uint64_t *)(v65 - 32);
        switch(v73)
        {
          case ' ':
          case '&':
            int v79 = *(_DWORD *)(v65 + 20);
            if ((v79 & 0x40000000) != 0) {
              uint64_t v80 = *(void *)(v65 - 8);
            }
            else {
              uint64_t v80 = v65 - 32 * (v79 & 0x7FFFFFF);
            }
            uint64_t v76 = (uint64_t *)(v80 + 32 * v71 + 32);
            goto LABEL_152;
          case '!':
            uint64_t v81 = -64;
            if (!v70) {
              uint64_t v81 = -96;
            }
            uint64_t v76 = (uint64_t *)(v65 + v81);
            break;
          case '""':
          case '#':
            goto LABEL_339;
          case '$':
            if ((*(_WORD *)(v65 + 18) & 1) == 0)
            {
              uint64_t v75 = 0;
              a2 = v47;
              goto LABEL_132;
            }
            uint64_t v76 = (uint64_t *)(v65 + 32 - 32 * (*(_DWORD *)(v65 + 20) & 0x7FFFFFF));
LABEL_152:
            a2 = v47;
            break;
          case '%':
            break;
          case '\'':
            if (v70) {
              uint64_t v76 = (uint64_t *)(v74 - 32 * *(unsigned int *)(v65 + 80));
            }
            else {
              uint64_t v76 = (uint64_t *)(v65 - 64 - 32 * *(unsigned int *)(v65 + 80));
            }
            goto LABEL_152;
          default:
            int v77 = *(_DWORD *)(v65 + 20);
            if ((v77 & 0x40000000) != 0) {
              uint64_t v78 = *(void *)(v65 - 8);
            }
            else {
              uint64_t v78 = v65 - 32 * (v77 & 0x7FFFFFF);
            }
            uint64_t v76 = (uint64_t *)(v78 + 32 * (v70 & 0xFFFFFFFE) + 32);
            break;
        }
      }
      uint64_t v75 = *v76;
LABEL_132:
      *v72++ = v75;
      ++v71;
      v70 += 2;
      v74 += 32;
    }
    while (2 * v69 != v70);
  }
  LODWORD(v83) = v69;
  LODWORD(v182) = v69;
  if (v69)
  {
    int v84 = v160;
    unsigned int v85 = v160 - 1;
    do
    {
      uint64_t v86 = *((void *)v181 + v83 - 1);
      uint64_t v83 = (v83 - 1);
      LODWORD(v182) = v83;
      if (v84)
      {
        uint64_t v87 = ((v86 >> 4) ^ (v86 >> 9)) & v85;
        uint64_t v88 = *(void *)(v50 + 16 * v87);
        if (v86 == v88)
        {
LABEL_161:
          if (v87 != v84)
          {
            uint64_t v89 = v50 + 16 * v87;
            int v91 = *(unsigned __int8 *)(v89 + 8);
            uint64_t v90 = (unsigned char *)(v89 + 8);
            if (v91 == 2)
            {
              unsigned char *v90 = 0;
              uint64_t v92 = *(void *)(v86 + 40);
              if (v92 == v86 + 40)
              {
LABEL_173:
                uint64_t v93 = 0;
                uint64_t v97 = 0;
              }
              else
              {
                uint64_t v93 = v92 - 24;
                if (v92) {
                  uint64_t v94 = v92 - 24;
                }
                else {
                  uint64_t v94 = 0;
                }
                int v95 = *(unsigned __int8 *)(v94 + 16);
                int v96 = v95 - 29;
                if (v95 != 30)
                {
                  unsigned int v110 = 0;
                  switch(v96)
                  {
                    case 0:
                    case 5:
                    case 6:
                      goto LABEL_172;
                    case 1:
                      goto LABEL_339;
                    case 2:
                      unsigned int v110 = (*(_DWORD *)(v94 + 20) >> 1) & 0x3FFFFFF;
                      goto LABEL_172;
                    case 3:
                    case 9:
                      unsigned int v110 = (*(_DWORD *)(v94 + 20) & 0x7FFFFFF) - 1;
                      goto LABEL_172;
                    case 4:
                      unsigned int v110 = 2;
                      goto LABEL_172;
                    case 7:
                      unsigned int v110 = *(_WORD *)(v94 + 18) & 1;
                      goto LABEL_172;
                    case 8:
                      unsigned int v110 = 1;
                      goto LABEL_172;
                    case 10:
                      unsigned int v110 = *(_DWORD *)(v94 + 80) + 1;
                      goto LABEL_172;
                    default:
                      goto LABEL_173;
                  }
                }
                if ((*(_DWORD *)(v94 + 20) & 0x7FFFFFF) == 3) {
                  unsigned int v110 = 2;
                }
                else {
                  unsigned int v110 = 1;
                }
LABEL_172:
                uint64_t v97 = v110;
              }
              if ((int)v97 + (unint64_t)v83 > HIDWORD(v182)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v97)
              {
                uint64_t v98 = 0;
                uint64_t v99 = 0;
                unsigned int v100 = (char *)v181 + 8 * v83;
                int v101 = *(unsigned __int8 *)(v93 + 16);
                uint64_t v102 = v93 - 64;
                do
                {
                  if (v101 == 30)
                  {
                    unint64_t v104 = (uint64_t *)(v93 - 32 - 32 * v99);
                  }
                  else
                  {
                    unint64_t v104 = (uint64_t *)(v93 - 32);
                    switch(v101)
                    {
                      case ' ':
                      case '&':
                        int v107 = *(_DWORD *)(v93 + 20);
                        if ((v107 & 0x40000000) != 0) {
                          uint64_t v108 = *(void *)(v93 - 8);
                        }
                        else {
                          uint64_t v108 = v93 - 32 * (v107 & 0x7FFFFFF);
                        }
                        unint64_t v104 = (uint64_t *)(v108 + 32 * v99 + 32);
                        break;
                      case '!':
                        uint64_t v109 = -64;
                        if (!v98) {
                          uint64_t v109 = -96;
                        }
                        unint64_t v104 = (uint64_t *)(v93 + v109);
                        break;
                      case '""':
                      case '#':
                        goto LABEL_339;
                      case '$':
                        if ((*(_WORD *)(v93 + 18) & 1) == 0)
                        {
                          uint64_t v103 = 0;
                          goto LABEL_182;
                        }
                        unint64_t v104 = (uint64_t *)(v93 + 32 - 32 * (*(_DWORD *)(v93 + 20) & 0x7FFFFFF));
                        break;
                      case '%':
                        break;
                      case '\'':
                        if (v98) {
                          unint64_t v104 = (uint64_t *)(v102 - 32 * *(unsigned int *)(v93 + 80));
                        }
                        else {
                          unint64_t v104 = (uint64_t *)(v93 - 64 - 32 * *(unsigned int *)(v93 + 80));
                        }
                        break;
                      default:
                        int v105 = *(_DWORD *)(v93 + 20);
                        if ((v105 & 0x40000000) != 0) {
                          uint64_t v106 = *(void *)(v93 - 8);
                        }
                        else {
                          uint64_t v106 = v93 - 32 * (v105 & 0x7FFFFFF);
                        }
                        unint64_t v104 = (uint64_t *)(v106 + 32 * (v98 & 0xFFFFFFFE) + 32);
                        break;
                    }
                  }
                  uint64_t v103 = *v104;
LABEL_182:
                  *v100++ = v103;
                  ++v99;
                  v98 += 2;
                  v102 += 32;
                }
                while (2 * v97 != v98);
              }
              LODWORD(v83) = v83 + v97;
              LODWORD(v182) = v83;
            }
          }
        }
        else
        {
          int v111 = 1;
          while (v88 != -4096)
          {
            int v112 = v87 + v111++;
            uint64_t v87 = v112 & v85;
            uint64_t v88 = *(void *)(v50 + 16 * v87);
            if (v86 == v88) {
              goto LABEL_161;
            }
          }
        }
      }
    }
    while (v83);
    char v63 = 0;
    a2 = v47;
  }
  else
  {
    char v63 = 0;
  }
LABEL_215:
  a3 = v153;
  if (v181 != v183) {
    free(v181);
  }
  if ((v63 & 1) == 0)
  {
    uint64_t v113 = (void *)*v42;
    if ((void *)*v42 == v42)
    {
      uint64_t v114 = 0;
    }
    else
    {
      uint64_t v114 = v113 - 3;
      if (!v113) {
        uint64_t v114 = 0;
      }
      if (*((unsigned __int8 *)v114 + 16) - 29 >= 0xB) {
        uint64_t v114 = 0;
      }
    }
    if (*((unsigned char *)v114 + 16) != 30)
    {
      switch(*((unsigned char *)v114 + 16))
      {
        case 0x1E:
          goto LABEL_339;
        case 0x1F:
          int v123 = (*((_DWORD *)v114 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_252;
        case 0x20:
        case 0x26:
          int v123 = (*((_DWORD *)v114 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_252;
        case 0x24:
          int v123 = *((_WORD *)v114 + 9) & 1;
          goto LABEL_252;
        case 0x25:
          goto LABEL_253;
        case 0x27:
          int v123 = *((_DWORD *)v114 + 20) + 1;
LABEL_252:
          if (v123 == 1) {
            goto LABEL_253;
          }
          goto LABEL_226;
        default:
          goto LABEL_226;
      }
    }
    if ((*((_DWORD *)v114 + 5) & 0x7FFFFFF) != 3)
    {
LABEL_253:
      *(void *)sub_1CCD5E1F8((uint64_t)v161, &v158) = 0;
      goto LABEL_254;
    }
LABEL_226:
    if (v113) {
      int v115 = v113 - 3;
    }
    else {
      int v115 = 0;
    }
    if (*((unsigned __int8 *)v115 + 16) - 29 >= 0xB) {
      int v115 = 0;
    }
    int v116 = *((unsigned __int8 *)v115 + 16);
    if (v116 != 32 && v116 != 39)
    {
      for (uint64_t i = *((void *)v11 + 6); ; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v118 = i - 24;
        if (!i) {
          uint64_t v118 = 0;
        }
        if (*(unsigned char *)(v118 + 16) != 83) {
          break;
        }
      }
      unsigned int v119 = *(unsigned __int8 *)(i - 8) - 38;
      BOOL v58 = v119 > 0x38;
      uint64_t v120 = (1 << v119) & 0x100060000000001;
      if (v58 || v120 == 0)
      {
        unint64_t v122 = (char *)(a1 + 6);
        if (!*(unsigned char *)(a1 + 7)) {
          unint64_t v122 = &byte_1EBCF1E08;
        }
        if (!*v122) {
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
        }
        if (v179 >= (unint64_t)HIDWORD(v179)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v178 + v179) = v154;
        LODWORD(v179) = v179 + 1;
        goto LABEL_254;
      }
    }
    goto LABEL_330;
  }
LABEL_254:
  while (1)
  {
    uint64_t v35 = *(void *)(v35 + 8);
    if (!v35) {
      break;
    }
    uint64_t v36 = *(void *)(v35 + 24);
    unsigned int v124 = *(unsigned __int8 *)(v36 + 16);
    if (v36) {
      BOOL v125 = v124 >= 0x1C;
    }
    else {
      BOOL v125 = 0;
    }
    if (v125 && v124 - 29 < 0xB) {
      goto LABEL_74;
    }
  }
  int v40 = v179;
LABEL_272:
  unint64_t v127 = (char *)__p;
  unint64_t v128 = v164;
  if (v40 + ((unint64_t)(v164 - (unsigned char *)__p) >> 4) != 1) {
    goto LABEL_330;
  }
  if (v156)
  {
    if (!v40) {
      goto LABEL_295;
    }
    for (uint64_t j = (void *)*((void *)v11 + 6); j != (void *)((char *)v11 + 40); uint64_t j = (void *)j[1])
    {
      int v131 = j - 3;
      if (j) {
        uint64_t v130 = j - 3;
      }
      else {
        uint64_t v130 = 0;
      }
      if (*((unsigned char *)v130 + 16) != 83) {
        goto LABEL_283;
      }
    }
    int v131 = 0;
LABEL_283:
    if (!llvm::isSafeToSpeculativelyExecute(a2, v131, *(unsigned __int8 **)(a1 + 24), 0)) {
      goto LABEL_330;
    }
    unint64_t v127 = (char *)__p;
    unint64_t v128 = v164;
LABEL_295:
    while (v127 != v128)
    {
      uint64_t v132 = *(void *)(*(void *)v127 + 40);
      if (v132 == *(void *)v127 + 40)
      {
        uint64_t v134 = 0;
      }
      else
      {
        if (v132) {
          uint64_t v133 = v132 - 24;
        }
        else {
          uint64_t v133 = 0;
        }
        if (*(unsigned __int8 *)(v133 + 16) - 29 >= 0xB) {
          uint64_t v134 = 0;
        }
        else {
          uint64_t v134 = (uint64_t *)v133;
        }
      }
      if ((llvm::isSafeToSpeculativelyExecute(a2, v134, *(unsigned __int8 **)(a1 + 24), 0) & 1) == 0) {
        goto LABEL_330;
      }
      v127 += 16;
    }
  }
  if (v179)
  {
    long long v135 = (llvm::BasicBlock **)v178;
    uint64_t v136 = 8 * v179;
    do
    {
      unint64_t v137 = *v135++;
      uint64_t v181 = 0;
      uint64_t v181 = (void *)llvm::GVNPass::splitCriticalEdges((llvm::GVNPass *)a1, v137, v11);
      *(void *)sub_1CCD5E1F8((uint64_t)v161, (uint64_t *)&v181) = 0;
      v136 -= 8;
    }
    while (v136);
  }
  uint64_t v138 = *(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40);
  uint64_t v181 = v183;
  uint64_t v182 = 0x800000000;
  uint64_t v139 = (llvm::BasicBlock **)__p;
  int v155 = (llvm::BasicBlock **)v164;
  if (__p != v164)
  {
    uint64_t v157 = a2;
    uint64_t v140 = v138 + 272;
    char v141 = 1;
    while (2)
    {
      unsigned int v142 = *v139;
      uint64_t v143 = *(unsigned __int8 ***)(v157 - 32);
      unsigned int v144 = *(llvm::BasicBlock **)(v157 + 40);
      while (v144 != v11)
      {
        uint64_t v145 = *(void *)(a1 + 40);
        uint64_t v171 = v143;
        uint64_t v172 = v140;
        uint64_t v173 = 0;
        uint64_t v174 = v145;
        BOOL v175 = v177;
        uint64_t v176 = 0x400000000;
        if (v143 && *((unsigned __int8 *)v143 + 16) >= 0x1Cu)
        {
          v177[0] = v143;
          LODWORD(v176) = 1;
        }
        unint64_t v146 = (llvm::BasicBlock *)llvm::BasicBlock::getSinglePredecessor(v144);
        uint64_t v143 = llvm::PHITransAddr::PHITranslateWithInsertion((uint64_t *)&v171, v144, v146, *(const llvm::DominatorTree **)(a1 + 24), (uint64_t)&v181);
        if (v143) {
          unsigned int v144 = (llvm::BasicBlock *)llvm::BasicBlock::getSinglePredecessor(v144);
        }
        else {
          char v141 = 0;
        }
        if (v175 != v177) {
          free(v175);
        }
        if (!v143) {
          goto LABEL_326;
        }
      }
      if (!v143) {
        goto LABEL_326;
      }
      uint64_t v147 = *(void *)(a1 + 40);
      uint64_t v171 = v143;
      uint64_t v172 = v140;
      uint64_t v173 = 0;
      uint64_t v174 = v147;
      BOOL v175 = v177;
      uint64_t v176 = 0x400000000;
      if (*((unsigned __int8 *)v143 + 16) >= 0x1Cu)
      {
        v177[0] = v143;
        LODWORD(v176) = 1;
      }
      int v148 = llvm::PHITransAddr::PHITranslateWithInsertion((uint64_t *)&v171, v11, v142, *(const llvm::DominatorTree **)(a1 + 24), (uint64_t)&v181);
      if (v175 != v177) {
        free(v175);
      }
      if (!v148) {
        goto LABEL_326;
      }
      v139[1] = (llvm::BasicBlock *)v148;
      v139 += 2;
      if (v139 != v155) {
        continue;
      }
      break;
    }
    if ((v141 & 1) == 0)
    {
LABEL_326:
      if (v182)
      {
        LODWORD(v182) = v182 - 1;
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      BOOL v26 = v179 != 0;
      goto LABEL_328;
    }
    a2 = v157;
    if (v182)
    {
      uint64_t v149 = (unsigned __int8 ***)v181;
      uint64_t v150 = 8 * v182;
      do
      {
        unsigned int v151 = *v149++;
        llvm::Instruction::dropLocation(v151);
        llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass::ValueTable *)(a1 + 128), (llvm::Value *)v151);
        v150 -= 8;
      }
      while (v150);
    }
  }
  llvm::GVNPass::eliminatePartiallyRedundantLoad(a1, (uint64_t ***)a2, a3, (uint64_t)v161);
  BOOL v26 = 1;
LABEL_328:
  if (v181 != v183) {
    free(v181);
  }
LABEL_331:
  if (v178 != v180) {
    free(v178);
  }
  MEMORY[0x1D25D9CD0](v159[0], 8);
  if (__p)
  {
    unsigned int v164 = (char *)__p;
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v161[0], 8);
LABEL_336:
  if (v167 != v166) {
    free(v167);
  }
  return v26;
}

uint64_t sub_1CCD5E1F8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v31 = *a2;
  int v32 = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = *(void *)a1;
    unsigned int v7 = v5 - 1;
    uint64_t v8 = (v5 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    uint64_t v9 = (void *)(*(void *)a1 + 16 * v8);
    uint64_t v10 = *v9;
    if (v4 == *v9)
    {
LABEL_3:
      unsigned int v11 = *(_DWORD *)(v6 + 16 * v8 + 8);
      uint64_t v12 = *(void *)(a1 + 24);
      return v12 + 16 * v11 + 8;
    }
    int v14 = 0;
    int v15 = 1;
    while (v10 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v10 == -8192;
      }
      if (v16) {
        int v14 = v9;
      }
      int v17 = v8 + v15++;
      uint64_t v8 = v17 & v7;
      uint64_t v9 = (void *)(v6 + 16 * v8);
      uint64_t v10 = *v9;
      if (v4 == *v9) {
        goto LABEL_3;
      }
    }
    if (v14) {
      size_t v18 = v14;
    }
    else {
      size_t v18 = v9;
    }
  }
  else
  {
    size_t v18 = 0;
  }
  unsigned int v19 = sub_1CBFAF8D8(a1, (uint64_t)&v31, &v31, v18);
  *unsigned int v19 = v31;
  *((_DWORD *)v19 + 2) = v32;
  uint64_t v20 = *a2;
  unsigned int v22 = *(uint64_t **)(a1 + 32);
  unint64_t v21 = *(void *)(a1 + 40);
  if ((unint64_t)v22 < v21)
  {
    uint64_t *v22 = v20;
    v22[1] = 0;
    uint64_t v30 = v22 + 2;
  }
  else
  {
    int v23 = *(char **)(a1 + 24);
    uint64_t v24 = ((char *)v22 - v23) >> 4;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 60) {
      abort();
    }
    uint64_t v26 = v21 - (void)v23;
    if (v26 >> 3 > v25) {
      unint64_t v25 = v26 >> 3;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27)
    {
      if (v27 >> 60) {
        sub_1CB833614();
      }
      uint64_t v28 = (char *)operator new(16 * v27);
    }
    else
    {
      uint64_t v28 = 0;
    }
    long long v29 = (uint64_t *)&v28[16 * v24];
    uint64_t *v29 = v20;
    v29[1] = 0;
    uint64_t v30 = v29 + 2;
    if (v22 != (uint64_t *)v23)
    {
      do
      {
        *((_OWORD *)v29 - 1) = *((_OWORD *)v22 - 1);
        v29 -= 2;
        v22 -= 2;
      }
      while (v22 != (uint64_t *)v23);
      unsigned int v22 = *(uint64_t **)(a1 + 24);
    }
    *(void *)(a1 + 24) = v29;
    *(void *)(a1 + 32) = v30;
    *(void *)(a1 + 40) = &v28[16 * v27];
    if (v22) {
      operator delete(v22);
    }
  }
  *(void *)(a1 + 32) = v30;
  uint64_t v12 = *(void *)(a1 + 24);
  unsigned int v11 = (((unint64_t)v30 - v12) >> 4) - 1;
  *((_DWORD *)v19 + 2) = v11;
  return v12 + 16 * v11 + 8;
}

uint64_t llvm::GVNPass::processNonLocalLoad(llvm::GVNPass *this, llvm::LoadInst *a2)
{
  v51[192] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)(*((void *)a2 + 5) + 56) + 112);
  if (v4 && (*(unsigned char *)(v4 + 18) & 0xC) != 0) {
    return 0;
  }
  unsigned int v49 = v51;
  uint64_t v50 = 0x4000000000;
  llvm::MemoryDependenceResults::getNonLocalPointerDependency(*((void *)this + 2), (uint64_t)a2, (uint64_t)&v49);
  if (dword_1EBCF1EC8 >= v50 && (v50 != 1 || (*((void *)v49 + 1) & 7uLL) - 1 <= 1))
  {
    uint64_t PRE = 0;
    uint64_t v6 = *((void *)a2 - 4);
    if (v6 && *(unsigned char *)(v6 + 16) == 62)
    {
      uint64_t v7 = *(_DWORD *)(v6 + 20) & 0x7FFFFFF;
      if (v6 - 32 * v7 + 32 == v6)
      {
        char v8 = 0;
      }
      else
      {
        char v8 = 0;
        uint64_t v9 = 32 - 32 * v7;
        do
        {
          uint64_t v10 = *(unsigned __int8 **)(v6 + v9);
          if (v10) {
            BOOL v11 = v10[16] >= 0x1Cu;
          }
          else {
            BOOL v11 = 0;
          }
          if (v11) {
            char v8 = v8 & 1 | llvm::GVNPass::performScalarPRE(this, (llvm::Instruction *)v10);
          }
          v9 += 32;
        }
        while (v9);
      }
      uint64_t PRE = v8 & 1;
    }
    uint64_t v46 = v48;
    uint64_t v47 = 0x4000000000;
    uint64_t v43 = v45;
    uint64_t v44 = 0x4000000000;
    llvm::GVNPass::AnalyzeLoadAvailability((uint64_t)this, (uint64_t *)a2, (uint64_t)&v49, (uint64_t)&v46, (uint64_t)&v43);
    if (!v47) {
      goto LABEL_63;
    }
    if (v44)
    {
      if (*((unsigned char *)this + 1)) {
        uint64_t v12 = (char *)this;
      }
      else {
        uint64_t v12 = &byte_1EBCF1BC8;
      }
      if (!*v12) {
        goto LABEL_63;
      }
      unsigned int v13 = (char *)this + 2;
      if (!*((unsigned char *)this + 3)) {
        unsigned int v13 = &byte_1EBCF1C88;
      }
      if (!*v13) {
        goto LABEL_63;
      }
      int v14 = (char *)this + 4;
      if (!*((unsigned char *)this + 5)) {
        int v14 = &byte_1EBCF1D48;
      }
      if (!*v14)
      {
        unsigned int v22 = (uint64_t *)*((void *)this + 14);
        if (v22)
        {
          int v23 = *((_DWORD *)v22 + 4);
          if (v23)
          {
            uint64_t v24 = *((void *)a2 + 5);
            uint64_t v25 = *v22;
            unsigned int v26 = v23 - 1;
            uint64_t v27 = ((v24 >> 4) ^ (v24 >> 9)) & (v23 - 1);
            uint64_t v28 = *(void *)(v25 + 16 * v27);
            if (v24 == v28)
            {
LABEL_58:
              BOOL v31 = *(void *)(v25 + 16 * v27 + 8) != 0;
              goto LABEL_60;
            }
            int v29 = 1;
            while (v28 != -4096)
            {
              int v30 = v27 + v29++;
              uint64_t v27 = v30 & v26;
              uint64_t v28 = *(void *)(v25 + 16 * v27);
              if (v24 == v28) {
                goto LABEL_58;
              }
            }
          }
          BOOL v31 = 0;
LABEL_60:
          if ((v31 | PRE))
          {
            uint64_t PRE = !v31 | PRE;
            goto LABEL_63;
          }
LABEL_62:
          uint64_t PRE = llvm::GVNPass::PerformLoadPRE((uint64_t)this, (uint64_t)a2, (uint64_t)&v46, (uint64_t)&v43);
          goto LABEL_63;
        }
      }
      if ((PRE & 1) == 0) {
        goto LABEL_62;
      }
LABEL_51:
      uint64_t PRE = 1;
LABEL_63:
      if (v43 != v45) {
        free(v43);
      }
      if (v46 != v48) {
        free(v46);
      }
      goto LABEL_67;
    }
    int v15 = sub_1CCD5CDB8((uint64_t)a2, (uint64_t *)&v46, (uint64_t)this);
    llvm::Value::doRAUW(a2, v15, (llvm::Value *)1);
    unsigned int v16 = *((unsigned __int8 *)v15 + 16);
    if (v16 == 83)
    {
      llvm::Value::takeName((int32x2_t ****)v15, a2);
      unsigned int v16 = *((unsigned __int8 *)v15 + 16);
    }
    if (v16 >= 0x1C)
    {
      int v17 = (unsigned __int8 *)*((void *)a2 + 6);
      if (v17)
      {
        if (*((void *)a2 + 5) == *((void *)v15 + 5))
        {
          uint64_t v41 = (unsigned __int8 *)*((void *)a2 + 6);
          llvm::MetadataTracking::track((uint64_t)&v41, v17, 2);
          size_t v18 = (unsigned __int8 **)((char *)v15 + 48);
          if (&v41 != (unsigned __int8 **)((char *)v15 + 48))
          {
            unsigned int v19 = *v18;
            if (!*v18) {
              goto LABEL_43;
            }
            int v33 = *v19;
            if ((v33 - 4) > 0x1E)
            {
              if ((v33 - 3) >= 0xFFFFFFFE) {
                uint64_t v36 = *v18;
              }
              else {
                uint64_t v36 = 0;
              }
              if ((v33 - 3) < 0xFFFFFFFE)
              {
                if (v33 == 3) {
                  *((void *)v19 + 1) = 0;
                }
                goto LABEL_43;
              }
              unint64_t v35 = (unint64_t)(v36 + 8);
            }
            else if ((v19[1] & 0x7F) != 2 && !*((_DWORD *)v19 + 3) {
                   || (uint64_t v34 = *((void *)v19 + 2), (v34 & 4) == 0)
            }
                   || (unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFF8) == 0)
            {
LABEL_43:
              uint64_t v20 = v41;
              void *v18 = v41;
              if (v20)
              {
                llvm::MetadataTracking::retrack((uint64_t)&v41, v20, (uint64_t)v18);
                uint64_t v41 = 0;
              }
              goto LABEL_45;
            }
            int v42 = (unsigned __int8 **)((char *)v15 + 48);
            sub_1CC5FA668(v35 + 16, &v42);
            size_t v18 = (unsigned __int8 **)((char *)v15 + 48);
            goto LABEL_43;
          }
          if (v41)
          {
            int v37 = *v41;
            if ((v37 - 4) > 0x1E)
            {
              if ((v37 - 3) >= 0xFFFFFFFE) {
                int v40 = v41;
              }
              else {
                int v40 = 0;
              }
              if ((v37 - 3) < 0xFFFFFFFE)
              {
                if (v37 == 3) {
                  *((void *)v41 + 1) = 0;
                }
                goto LABEL_45;
              }
              unint64_t v39 = (unint64_t)(v40 + 8);
            }
            else
            {
              if ((v41[1] & 0x7F) != 2 && !*((_DWORD *)v41 + 3)) {
                goto LABEL_45;
              }
              uint64_t v38 = *((void *)v41 + 2);
              if ((v38 & 4) == 0) {
                goto LABEL_45;
              }
              unint64_t v39 = v38 & 0xFFFFFFFFFFFFFFF8;
              if (!v39) {
                goto LABEL_45;
              }
            }
            int v42 = &v41;
            sub_1CC5FA668(v39 + 16, &v42);
          }
        }
      }
    }
LABEL_45:
    if ((*(_DWORD *)(*(void *)v15 + 8) & 0xFE) == 0x12) {
      int v21 = *(unsigned __int8 *)(**(void **)(*(void *)v15 + 16) + 8);
    }
    else {
      int v21 = *(_DWORD *)(*(void *)v15 + 8);
    }
    if (v21 == 15) {
      llvm::MemoryDependenceResults::invalidateCachedPointerInfo(*((llvm::MemoryDependenceResults **)this + 2), v15);
    }
    sub_1CCD5D120((int32x2_t *)this, a2);
    sub_1CCD5F7FC((llvm::Type **)a2, (unsigned __int8 *)v15, *((uint64_t ****)this + 12));
    goto LABEL_51;
  }
  uint64_t PRE = 0;
LABEL_67:
  if (v49 != v51) {
    free(v49);
  }
  return PRE;
}

uint64_t llvm::GVNPass::performScalarPRE(llvm::GVNPass *this, llvm::Instruction *a2)
{
  v25[16] = *MEMORY[0x1E4F143B8];
  int v2 = *((unsigned __int8 *)a2 + 16);
  if ((v2 - 29) < 0xB || v2 == 59 || v2 == 83 || *(unsigned char *)(*(void *)a2 + 8) == 7) {
    return 0;
  }
  uint64_t v6 = *((unsigned __int8 *)a2 + 16) - 33;
  if (v6 <= 0x37)
  {
    if (((1 << (*((unsigned char *)a2 + 16) - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v16 = *((void *)a2 + 8);
      if (!v16 || (*(unsigned char *)(v16 + 20) & 4) == 0 && (*(unsigned char *)(v16 + 17) & 0x10) == 0)
      {
        LODWORD(v24[0]) = 7;
        if (sub_1CC5CB59C((uint64_t)a2, (__int32 *)v24, 1uLL))
        {
          uint64_t v23 = *((void *)a2 - 4);
          if (!v23
            || *(unsigned char *)(v23 + 16)
            || *(void *)(v23 + 24) != *((void *)a2 + 9)
            || *(_DWORD *)(v23 + 36) != 7)
          {
            return 0;
          }
        }
        if ((llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 66) & 1) == 0
          && !llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 44))
        {
          return 0;
        }
      }
    }
    else if (((1 << (*((unsigned char *)a2 + 16) - 33)) & 0x808001C8000010) != 0 {
           || v6 == 28 && (*((_WORD *)a2 + 9) & 0x301) != 0)
    }
    {
      return 0;
    }
  }
  if ((llvm::Instruction::mayHaveSideEffects(a2) & 1) == 0 && !sub_1CBF63B28((uint64_t)a2))
  {
    int v7 = *((unsigned __int8 *)a2 + 16);
    if (v7 != 62 && (v7 - 81) >= 2)
    {
      if ((unsigned int v8 = v7 - 33, v8 > 0x33)
        || ((1 << v8) & 0x8000000000041) == 0
        || *(unsigned char *)(*((void *)a2 - 4) + 16) != 24
        && ((uint64_t v9 = *((void *)a2 + 8)) == 0 || (*(unsigned char *)(v9 + 12) & 0x40) == 0)
        && (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)a2, 6) & 1) == 0)
      {
        uint64_t v10 = *((void *)this + 16);
        int v11 = *((_DWORD *)this + 36);
        if (v11)
        {
          unsigned int v12 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
          unsigned int v13 = *(llvm::Instruction **)(v10 + 16 * v12);
          if (v13 != a2)
          {
            int v14 = 1;
            do
            {
              if (v13 == (llvm::Instruction *)-4096) {
                break;
              }
              unsigned int v15 = v12 + v14++;
              unsigned int v12 = v15 & (v11 - 1);
              unsigned int v13 = *(llvm::Instruction **)(v10 + 16 * v12);
            }
            while (v13 != a2);
          }
        }
        uint64_t v17 = *((void *)a2 + 5);
        if (*((unsigned char *)this + 688)) {
          llvm::GVNPass::assignBlockRPONumber(this, *(llvm::Function **)(v17 + 56));
        }
        v24[0] = v25;
        v24[1] = (void *)0x800000000;
        for (uint64_t i = *(void *)(v17 + 8); i; uint64_t i = *(void *)(i + 8))
        {
          uint64_t v19 = *(void *)(i + 24);
          unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
          if (v19) {
            BOOL v21 = v20 >= 0x1C;
          }
          else {
            BOOL v21 = 0;
          }
          if (v21 && v20 - 29 < 0xB) {
            llvm::DominatorTreeBase<llvm::BasicBlock,false>::isReachableFromEntry();
          }
        }
        if (v24[0] != v25) {
          free(v24[0]);
        }
      }
    }
  }
  return 0;
}

void sub_1CCD5F7FC(llvm::Type **a1, unsigned __int8 *a2, uint64_t ***a3)
{
  v41[34] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)***a3;
  if (*(void *)(v6 + 128)
    || (*(unsigned int (**)(void))(**(void **)(v6 + 72) + 48))(*(void *)(v6 + 72)))
  {
    llvm::OptimizationRemark::OptimizationRemark((uint64_t)v38, (uint64_t)"gvn", (uint64_t)"LoadElim", 8, (uint64_t)a1);
    uint64_t v28 = "load of type ";
    uint64_t v29 = 13;
    sub_1CC59ADEC((uint64_t *)&v39, (uint64_t)&v28);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v24, "Type", 4uLL, *a1);
    uint64_t v7 = sub_1CD3D6290((uint64_t)v38, (long long *)v24);
    uint64_t v28 = " eliminated";
    uint64_t v29 = 11;
    sub_1CC59ADEC((uint64_t *)(v7 + 80), (uint64_t)&v28);
    *(_DWORD *)(v7 + 356) = *(_DWORD *)(v7 + 88);
    uint64_t v28 = " in favor of ";
    uint64_t v29 = 13;
    sub_1CC59ADEC((uint64_t *)(v7 + 80), (uint64_t)&v28);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v20, "InfavorOfValue", 0xEuLL, a2);
    uint64_t v8 = sub_1CD3D6290(v7, (long long *)v20);
    int v9 = *(_DWORD *)(v8 + 8);
    BYTE4(v29) = *(unsigned char *)(v8 + 12);
    LODWORD(v29) = v9;
    long long v10 = *(_OWORD *)(v8 + 16);
    uint64_t v31 = *(void *)(v8 + 32);
    long long v30 = v10;
    uint64_t v11 = *(void *)(v8 + 72);
    long long v12 = *(_OWORD *)(v8 + 56);
    long long v32 = *(_OWORD *)(v8 + 40);
    long long v33 = v12;
    uint64_t v28 = (const char *)&unk_1F2616800;
    uint64_t v34 = v11;
    unint64_t v35 = v37;
    uint64_t v36 = 0x400000000;
    if (*(_DWORD *)(v8 + 88)) {
      sub_1CD494D68((uint64_t)&v35, v8 + 80);
    }
    uint64_t v13 = *(void *)(v8 + 360);
    v37[32] = *(void *)(v8 + 352);
    v37[33] = v13;
    uint64_t v28 = (const char *)&unk_1F2616570;
    if (v23 < 0) {
      operator delete(__p);
    }
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    if (v27 < 0) {
      operator delete(v26);
    }
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    v38[0] = &unk_1F2616800;
    int v14 = (char *)v39;
    if (v40)
    {
      unint64_t v15 = (unint64_t)v40 << 6;
      do
      {
        uint64_t v16 = (void **)&v14[v15];
        if (v14[v15 - 17] < 0) {
          operator delete(*(v16 - 5));
        }
        if (*((char *)v16 - 41) < 0) {
          operator delete(*(v16 - 8));
        }
        v15 -= 64;
      }
      while (v15);
      int v14 = (char *)v39;
    }
    if (v14 != (char *)v41) {
      free(v14);
    }
    llvm::OptimizationRemarkEmitter::emit(a3, (llvm::DiagnosticInfoOptimizationBase *)&v28);
    uint64_t v28 = (const char *)&unk_1F2616800;
    uint64_t v17 = (char *)v35;
    if (v36)
    {
      unint64_t v18 = (unint64_t)v36 << 6;
      do
      {
        uint64_t v19 = (void **)&v17[v18];
        if (v17[v18 - 17] < 0) {
          operator delete(*(v19 - 5));
        }
        if (*((char *)v19 - 41) < 0) {
          operator delete(*(v19 - 8));
        }
        v18 -= 64;
      }
      while (v18);
      uint64_t v17 = (char *)v35;
    }
    if (v17 != (char *)v37) {
      free(v17);
    }
  }
}

uint64_t llvm::GVNPass::processAssumeIntrinsic(uint64_t a1, uint64_t a2, const llvm::APInt *a3)
{
  uint64_t v4 = *(unsigned __int8 **)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
  uint64_t v94 = v4;
  unsigned int v5 = v4[16];
  if (v4) {
    BOOL v6 = v5 == 16;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6)
  {
    uint64_t v30 = *((unsigned int *)v4 + 8);
    if (v30 > 0x40)
    {
      int v31 = 0;
      int64_t v32 = (unint64_t)(v30 + 63) >> 6;
      do
      {
        if (v32-- < 1) {
          break;
        }
        unint64_t v34 = *(void *)(*((void *)v4 + 3) + 8 * v32);
        v31 += __clz(v34);
      }
      while (!v34);
      int v35 = v30 | 0xFFFFFFC0;
      if ((v30 & 0x3F) == 0) {
        int v35 = 0;
      }
      if (v31 + v35 == v30)
      {
LABEL_51:
        uint64_t v36 = ***(void ***)v4;
        int v37 = (char *)operator new(0x80uLL);
        *((_DWORD *)v37 + 21) = *((_DWORD *)v37 + 21) & 0x38000000 | 2;
        uint64_t v38 = (uint64_t)(v37 + 64);
        *(void *)int v37 = 0;
        *((void *)v37 + 1) = 0;
        *((void *)v37 + 2) = 0;
        *((void *)v37 + 3) = v37 + 64;
        *((void *)v37 + 4) = 0;
        *((void *)v37 + 5) = 0;
        *((void *)v37 + 6) = 0;
        *((void *)v37 + 7) = v37 + 64;
        unsigned int v40 = (llvm::Type **)llvm::PoisonValue::get((llvm::PoisonValue *)(v36 + 1912), v39);
        uint64_t v41 = (llvm::Constant *)llvm::PointerType::get((llvm::PointerType *)(v36 + 1912), 0);
        Nulluint64_t Value = llvm::Constant::getNullValue(v41, v42, v43);
        llvm::StoreInst::StoreInst((llvm::StoreInst *)(v37 + 64), v40, NullValue, 0, (llvm::Instruction *)a2);
        uint64_t v45 = *(uint64_t **)(a1 + 120);
        if (v45)
        {
          uint64_t v46 = (uint64_t *)*v45;
          uint64_t v47 = *(void *)(*v45 + 48);
          uint64_t v48 = *(unsigned int *)(*v45 + 64);
          if (v48)
          {
            uint64_t v49 = *(void *)(a2 + 40);
            LODWORD(v50) = ((v49 >> 4) ^ (v49 >> 9)) & (v48 - 1);
            uint64_t v51 = (uint64_t *)(v47 + 16 * v50);
            uint64_t v52 = *v51;
            if (v49 != *v51)
            {
              int v53 = 1;
              do
              {
                if (v52 == -4096) {
                  goto LABEL_58;
                }
                int v54 = v50 + v53++;
                uint64_t v50 = v54 & (v48 - 1);
                uint64_t v52 = *(void *)(v47 + 16 * v50);
              }
              while (v49 != v52);
              uint64_t v51 = (uint64_t *)(v47 + 16 * v50);
            }
          }
          else
          {
LABEL_58:
            uint64_t v51 = (uint64_t *)(v47 + 16 * v48);
          }
          if (v51 == (uint64_t *)(v47 + 16 * v48) || (uint64_t v55 = v51[1]) == 0)
          {
LABEL_77:
            uint64_t v64 = (llvm::BasicBlock *)*((void *)v37 + 13);
            DefinedAccess = llvm::MemorySSA::createDefinedAccess(v46, v38, v46[12], 0);
            llvm::MemorySSA::insertIntoListsForBlock(*v45, (uint64_t)DefinedAccess, v64, 2);
          }
          else
          {
            for (uint64_t i = *(void *)(v55 + 8); ; uint64_t i = *(void *)(i + 8))
            {
              if (i == v55) {
                goto LABEL_77;
              }
              uint64_t v57 = i ? i - 32 : 0;
              if (i && *(unsigned __int8 *)(v57 + 16) - 27 >= 0xFFFFFFFE)
              {
                uint64_t v58 = *(void *)(v57 + 72);
                uint64_t v59 = *(void *)(v58 + 40);
                int v60 = *(__int16 *)(v59 + 18);
                if ((v60 & 0x80000000) == 0)
                {
                  uint64_t v61 = *(void *)(v59 + 48);
                  if (v61 != v59 + 40)
                  {
                    int v62 = 0;
                    do
                    {
                      uint64_t v63 = v61 - 24;
                      if (!v61) {
                        uint64_t v63 = 0;
                      }
                      *(_DWORD *)(v63 + 56) = v62++;
                      uint64_t v61 = *(void *)(v61 + 8);
                    }
                    while (v61 != v59 + 40);
                  }
                  *(_WORD *)(v59 + 18) = v60 | 0x8000;
                }
                if (*(_DWORD *)(v58 + 56) >= *((_DWORD *)v37 + 30)) {
                  break;
                }
              }
            }
            DefinedAccess = llvm::MemorySSAUpdater::createMemoryAccessBefore((uint64_t **)v45, v38, v46[12], i - 32);
          }
          llvm::MemorySSAUpdater::insertDef(*(llvm::MemorySSAUpdater **)(a1 + 120), (llvm::MemoryDef *)DefinedAccess);
        }
      }
    }
    else if (!*((void *)v4 + 3))
    {
      goto LABEL_51;
    }
    if (llvm::isAssumeWithEmptyBundle(a2)) {
      sub_1CCD5D120((int32x2_t *)a1, (llvm::Value *)a2);
    }
    goto LABEL_81;
  }
  if (v5 < 0x15)
  {
LABEL_81:
    LOBYTE(v68) = 0;
    return v68 & 1;
  }
  uint64_t v7 = **(uint64_t ***)v4;
  uint64_t v8 = *v7;
  int v9 = *(llvm::Value **)(*v7 + 1560);
  if (!v9)
  {
    uint64_t v87 = *(llvm::ConstantInt **)(v8 + 1888);
    unsigned int v88 = *(_DWORD *)(v8 + 1896);
    LODWORD(v96) = v88 >> 8;
    if (v88 >> 8 > 0x40) {
      operator new[]();
    }
    if (v88 <= 0xFF) {
      LOBYTE(v89) = 0;
    }
    else {
      unint64_t v89 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v88) + 63);
    }
    int v95 = (uint64_t *)(v89 & 1);
    int v9 = (llvm::Value *)llvm::ConstantInt::get(v87, (llvm::LLVMContext *)&v95, a3);
    if (v96 >= 0x41 && v95) {
      MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
    }
    *(void *)(v8 + 1560) = v9;
  }
  uint64_t v10 = *(void *)(a2 + 40);
  uint64_t v11 = *(void *)(v10 + 40);
  if (v11 == v10 + 40) {
    goto LABEL_118;
  }
  if (v11) {
    uint64_t v12 = v11 - 24;
  }
  else {
    uint64_t v12 = 0;
  }
  int v13 = *(unsigned __int8 *)(v12 + 16);
  int v14 = v13 - 29;
  if (v13 == 30)
  {
    if ((*(_DWORD *)(v12 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v67 = 2;
    }
    else {
      unsigned int v67 = 1;
    }
  }
  else
  {
    unsigned int v67 = 2;
    LOBYTE(v68) = 0;
    switch(v14)
    {
      case 0:
      case 5:
      case 6:
        goto LABEL_84;
      case 1:
LABEL_135:
        __break(1u);
        goto LABEL_136;
      case 2:
        unsigned int v67 = (*(_DWORD *)(v12 + 20) >> 1) & 0x3FFFFFF;
        break;
      case 3:
      case 9:
LABEL_136:
        unsigned int v67 = (*(_DWORD *)(v12 + 20) & 0x7FFFFFF) - 1;
        break;
      case 4:
        goto LABEL_16;
      case 7:
        unsigned int v67 = *(_WORD *)(v12 + 18) & 1;
        break;
      case 8:
        unsigned int v67 = 1;
        goto LABEL_16;
      case 10:
        unsigned int v67 = *(_DWORD *)(v12 + 80) + 1;
        break;
      default:
        goto LABEL_118;
    }
    if (!v67)
    {
LABEL_118:
      LOBYTE(v68) = 0;
      goto LABEL_84;
    }
  }
LABEL_16:
  int v15 = 0;
  uint64_t v16 = 0;
  int v68 = 0;
  uint64_t v17 = v12 - 64;
  uint64_t v18 = v67;
  do
  {
    int v19 = *(unsigned __int8 *)(v12 + 16);
    if (v19 == 30)
    {
      unsigned int v22 = (uint64_t *)(v12 - 32 - 32 * v16);
    }
    else
    {
      uint64_t v21 = (v19 - 31);
      unsigned int v22 = (uint64_t *)(v12 - 32);
      switch(v21)
      {
        case 1:
        case 7:
          int v25 = *(_DWORD *)(v12 + 20);
          if ((v25 & 0x40000000) != 0) {
            uint64_t v26 = *(void *)(v12 - 8);
          }
          else {
            uint64_t v26 = v12 - 32 * (v25 & 0x7FFFFFF);
          }
          unsigned int v22 = (uint64_t *)(v26 + 32 * (v16 + 1));
          break;
        case 2:
          uint64_t v27 = -64;
          if (!v16) {
            uint64_t v27 = -96;
          }
          unsigned int v22 = (uint64_t *)(v12 + v27);
          break;
        case 3:
        case 4:
          goto LABEL_135;
        case 5:
          if ((*(_WORD *)(v12 + 18) & 1) == 0)
          {
            uint64_t v20 = 0;
            goto LABEL_21;
          }
          uint64_t v28 = *(_DWORD *)(v12 + 20) & 0x7FFFFFF;
          uint64_t v29 = v12 + 32;
          goto LABEL_41;
        case 6:
          break;
        case 8:
          if (v16)
          {
            unsigned int v22 = (uint64_t *)(v17 - 32 * *(unsigned int *)(v12 + 80));
          }
          else
          {
            uint64_t v28 = *(unsigned int *)(v12 + 80);
            uint64_t v29 = v12 - 64;
LABEL_41:
            unsigned int v22 = (uint64_t *)(v29 - 32 * v28);
          }
          break;
        default:
          int v23 = *(_DWORD *)(v12 + 20);
          if ((v23 & 0x40000000) != 0) {
            uint64_t v24 = *(void *)(v12 - 8);
          }
          else {
            uint64_t v24 = v12 - 32 * (v23 & 0x7FFFFFF);
          }
          unsigned int v22 = (uint64_t *)(v24 + 32 * (v15 & 0xFFFFFFFE) + 32);
          break;
      }
    }
    uint64_t v20 = *v22;
LABEL_21:
    int v95 = *(uint64_t **)(a2 + 40);
    uint64_t v96 = v20;
    v68 |= llvm::GVNPass::propagateEquality((llvm::GVNPass *)a1, (llvm::Value *)v4, v9, (llvm::BasicBlock **)&v95, 0);
    ++v16;
    v15 += 2;
    v17 += 32;
  }
  while (v18 != v16);
LABEL_84:
  uint64_t v69 = a1 + 432;
  *(void *)sub_1CCD60A4C(a1 + 432, (uint64_t *)&v94) = v9;
  uint64_t v93 = 0;
  int v95 = &v93;
  if (sub_1CBF686A0(&v95, 30, (uint64_t)v4))
  {
    uint64_t v71 = **(uint64_t ***)v4;
    uint64_t v72 = *v71;
    int v73 = *(void **)(*v71 + 1568);
    if (!v73)
    {
      uint64_t v90 = *(llvm::ConstantInt **)(v72 + 1888);
      unsigned int v91 = *(_DWORD *)(v72 + 1896);
      LODWORD(v96) = v91 >> 8;
      if (v91 >> 8 > 0x40) {
        operator new[]();
      }
      int v95 = 0;
      int v73 = llvm::ConstantInt::get(v90, (llvm::LLVMContext *)&v95, v70);
      if (v96 >= 0x41 && v95) {
        MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
      }
      *(void *)(v72 + 1568) = v73;
    }
    *(void *)sub_1CCD60A4C(v69, &v93) = v73;
  }
  unsigned int v74 = v4[16];
  if (v74 < 0x1C || v74 - 83 < 0xFFFFFFFE || !sub_1CCD60B24((uint64_t)v4)) {
    return v68 & 1;
  }
  uint64_t v75 = (uint64_t *)*((void *)v4 - 8);
  int v95 = v75;
  uint64_t v76 = *((void *)v4 - 4);
  unsigned int v77 = *((unsigned __int8 *)v75 + 16);
  if (v77 > 0x14)
  {
    uint64_t v78 = v75;
    uint64_t v75 = (uint64_t *)*((void *)v4 - 4);
  }
  else
  {
    unsigned int v77 = *(unsigned __int8 *)(v76 + 16);
    if (v77 < 0x15)
    {
      uint64_t v78 = v75;
      uint64_t v75 = (uint64_t *)*((void *)v4 - 4);
      goto LABEL_108;
    }
    int v95 = (uint64_t *)*((void *)v4 - 4);
    uint64_t v78 = (uint64_t *)v76;
  }
  if (v77 > 0x1B)
  {
    int v79 = v78;
    uint64_t v78 = v75;
    goto LABEL_99;
  }
  unsigned int v80 = *((unsigned __int8 *)v75 + 16);
  if (v80 >= 0x1C)
  {
    int v95 = v75;
    int v79 = v75;
    uint64_t v75 = v78;
LABEL_99:
    unsigned int v81 = *((unsigned __int8 *)v78 + 16);
    uint64_t v78 = v79;
    if (v81 < 0x1C) {
      goto LABEL_108;
    }
    goto LABEL_103;
  }
  if (v77 != 21 || v80 != 21) {
    goto LABEL_108;
  }
LABEL_103:
  unsigned int v82 = llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass::ValueTable *)(a1 + 128), (llvm::Value *)v78);
  unsigned int v83 = llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass::ValueTable *)(a1 + 128), (llvm::Value *)v75);
  int v84 = v95;
  if (v82 >= v83) {
    uint64_t v78 = v95;
  }
  else {
    uint64_t v78 = v75;
  }
  int v95 = v78;
  if (v82 < v83) {
    uint64_t v75 = v84;
  }
LABEL_108:
  if (*((unsigned __int8 *)v78 + 16) > 0x14u || *((unsigned __int8 *)v75 + 16) >= 0x15u)
  {
    uint64_t v85 = v78[1];
    if (v85)
    {
      while (1)
      {
        uint64_t v86 = *(void *)(v85 + 24);
        if (*(unsigned __int8 *)(v86 + 16) >= 0x1Cu && *(void *)(v86 + 40) == *(void *)(a2 + 40)) {
          break;
        }
        uint64_t v85 = *(void *)(v85 + 8);
        if (!v85) {
          return v68 & 1;
        }
      }
      *(void *)sub_1CCD60A4C(v69, (uint64_t *)&v95) = v75;
    }
  }
  return v68 & 1;
}

uint64_t llvm::GVNPass::propagateEquality(llvm::GVNPass *this, llvm::Value *a2, llvm::Value *a3, llvm::BasicBlock **a4, int a5)
{
  v70[8] = *MEMORY[0x1E4F143B8];
  int v68 = v70;
  v70[0] = a2;
  v70[1] = a3;
  uint64_t v69 = 0x400000001;
  int v6 = 0;
  uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(a4[1]);
  int v62 = (llvm::GVNPass *)((char *)this + 128);
  unsigned int v7 = 1;
  do
  {
    uint64_t v8 = (char *)v68 + 16 * v7;
    uint64_t v10 = *((void *)v8 - 2);
    uint64_t v9 = *((void *)v8 - 1);
    LODWORD(v69) = --v7;
    if (v10 == v9) {
      continue;
    }
    unsigned int v11 = *(unsigned __int8 *)(v10 + 16);
    if (v11 > 0x14)
    {
      if (v11 != 21 || *(unsigned __int8 *)(v9 + 16) < 0x15u)
      {
        uint64_t v12 = v10;
        uint64_t v10 = v9;
        uint64_t v9 = v12;
      }
LABEL_9:
      unsigned int v14 = llvm::GVNPass::ValueTable::lookupOrAdd(v62, (llvm::Value *)v9);
      unsigned int v15 = *(unsigned __int8 *)(v9 + 16);
      if (v15 == 21)
      {
        if (*(unsigned char *)(v10 + 16) != 21) {
          goto LABEL_20;
        }
      }
      else if (v15 < 0x1C || *(unsigned __int8 *)(v10 + 16) < 0x1Cu)
      {
        goto LABEL_20;
      }
      unsigned int v16 = llvm::GVNPass::ValueTable::lookupOrAdd(v62, (llvm::Value *)v10);
      if (v14 < v16) {
        uint64_t v17 = v9;
      }
      else {
        uint64_t v17 = v10;
      }
      if (v14 < v16)
      {
        uint64_t v9 = v10;
        unsigned int v14 = v16;
      }
      uint64_t v10 = v17;
LABEL_20:
      if (SinglePredecessor && *(unsigned __int8 *)(v10 + 16) <= 0x1Bu) {
        sub_1CCD61790((uint64_t)this, v14, v10, (uint64_t)a4[1]);
      }
      uint64_t v18 = *(void *)(v9 + 8);
      if (v18)
      {
        if (!*(void *)(v18 + 8)) {
          goto LABEL_44;
        }
        int v19 = (llvm::DominatorTree *)*((void *)this + 3);
        if (a5)
        {
          int v20 = 0;
          uint64_t v21 = (uint64_t *)(v10 + 8);
          do
          {
            unsigned int v22 = (uint64_t *)(v18 + 8);
            uint64_t v23 = *(void *)(v18 + 8);
            if (llvm::DominatorTree::dominates(v19, (const llvm::BasicBlockEdge *)a4, (const llvm::Use *)v18))
            {
              if (*(void *)v18)
              {
                **(void **)(v18 + 16) = *(void *)(v18 + 8);
                uint64_t v24 = *(void *)(v18 + 8);
                if (v24) {
                  *(void *)(v24 + 16) = *(void *)(v18 + 16);
                }
              }
              *(void *)uint64_t v18 = v10;
              if (v10)
              {
                uint64_t v25 = *v21;
                uint64_t *v22 = *v21;
                if (v25) {
                  *(void *)(v25 + 16) = v22;
                }
                *(void *)(v18 + 16) = v21;
                *uint64_t v21 = v18;
              }
              ++v20;
            }
            uint64_t v18 = v23;
          }
          while (v23);
          goto LABEL_42;
        }
      }
      else
      {
        if (a5)
        {
          int v20 = 0;
          goto LABEL_42;
        }
        int v19 = (llvm::DominatorTree *)*((void *)this + 3);
      }
      int v20 = llvm::replaceDominatedUsesWith((llvm *)v9, (llvm::Value *)v10, v19, *a4, v13);
LABEL_42:
      v6 |= v20 != 0;
      uint64_t v26 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
      if (v26) {
        llvm::MemoryDependenceResults::invalidateCachedPointerInfo(v26, (llvm::Value *)v9);
      }
LABEL_44:
      if (*(_DWORD *)(*(void *)v10 + 8) != 269 || *(unsigned char *)(v10 + 16) != 16) {
        goto LABEL_104;
      }
      unsigned int v27 = *(_DWORD *)(v10 + 32);
      if (v27)
      {
        uint64_t v28 = (llvm::APInt *)(v10 + 24);
        if (v27 > 0x40)
        {
          int v30 = llvm::APInt::countTrailingOnesSlowCase(v28);
          uint64_t v66 = 0;
          uint64_t v67 = 0;
          if (v30 != v27)
          {
LABEL_54:
            v64[0] = &v67;
            v64[1] = &v66;
            if (sub_1CB90D1A4(v64, v9))
            {
LABEL_55:
              if (v69 >= (unint64_t)HIDWORD(v69)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              long long v33 = (char *)v68 + 16 * v69;
              *long long v33 = v67;
              v33[1] = v10;
              unsigned int v34 = v69 + 1;
              LODWORD(v69) = v34;
              if (v34 >= HIDWORD(v69)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              int v35 = (char *)v68 + 16 * v34;
              *int v35 = v66;
              v35[1] = v10;
              LODWORD(v69) = v69 + 1;
              goto LABEL_104;
            }
            int v32 = 0;
            unint64_t v31 = 1;
LABEL_59:
            unsigned int v36 = *(unsigned __int8 *)(v9 + 16);
            if (v36 < 0x1C || v36 - 83 < 0xFFFFFFFE) {
              goto LABEL_104;
            }
            uint64_t v37 = *(void *)(v9 - 64);
            uint64_t v38 = *(void *)(v9 - 32);
            if (v32)
            {
              if ((sub_1CCD60B24(v9) & 1) == 0)
              {
LABEL_81:
                int v43 = dword_1CFB2CD08[*(_WORD *)(v9 + 18) & 0x3F];
                uint64_t v44 = (llvm::Value *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v9, v31, 0);
                unsigned int v45 = *((_DWORD *)this + 76);
                unsigned int v46 = llvm::GVNPass::ValueTable::lookupOrAddCmp(v62, *(unsigned __int8 *)(v9 + 16) - 28, v43, (llvm::Value *)v37, (llvm::Value *)v38);
                if (v46 < v45)
                {
                  uint64_t Leader = llvm::GVNPass::findLeader(this, a4[1], v46);
                  if (Leader)
                  {
                    uint64_t v49 = (llvm::Value *)Leader;
                    if (*(unsigned __int8 *)(Leader + 16) >= 0x1Cu)
                    {
                      uint64_t v50 = (llvm::DominatorTree *)*((void *)this + 3);
                      if (a5)
                      {
                        uint64_t v51 = *(void *)(Leader + 8);
                        if (v51)
                        {
                          int v59 = 0;
                          uint64_t v52 = (uint64_t *)((char *)v44 + 8);
                          do
                          {
                            int v53 = (uint64_t *)(v51 + 8);
                            uint64_t v54 = *(void *)(v51 + 8);
                            if (llvm::DominatorTree::dominates(v50, (const llvm::BasicBlockEdge *)a4, (const llvm::Use *)v51))
                            {
                              if (*(void *)v51)
                              {
                                **(void **)(v51 + 16) = *(void *)(v51 + 8);
                                uint64_t v55 = *(void *)(v51 + 8);
                                if (v55) {
                                  *(void *)(v55 + 16) = *(void *)(v51 + 16);
                                }
                              }
                              *(void *)uint64_t v51 = v44;
                              if (v44)
                              {
                                uint64_t v56 = *v52;
                                uint64_t *v53 = *v52;
                                if (v56) {
                                  *(void *)(v56 + 16) = v53;
                                }
                                *(void *)(v51 + 16) = v52;
                                uint64_t *v52 = v51;
                              }
                              ++v59;
                            }
                            uint64_t v51 = v54;
                          }
                          while (v54);
                        }
                        else
                        {
                          int v59 = 0;
                        }
                      }
                      else
                      {
                        int v59 = llvm::replaceDominatedUsesWith((llvm *)Leader, v44, v50, *a4, v48);
                      }
                      v6 |= v59 != 0;
                      uint64_t v57 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
                      if (v57) {
                        llvm::MemoryDependenceResults::invalidateCachedPointerInfo(v57, v49);
                      }
                    }
                  }
                }
                if (SinglePredecessor) {
                  sub_1CCD61790((uint64_t)this, v46, (uint64_t)v44, (uint64_t)a4[1]);
                }
                goto LABEL_104;
              }
            }
            else
            {
              int v39 = *(_WORD *)(v9 + 18) & 0x3F;
              if (v39 != 33)
              {
                if (v39 == 6)
                {
                  if ((*(unsigned char *)(v9 + 17) & 4) == 0) {
                    goto LABEL_81;
                  }
                }
                else if (v39 != 14)
                {
                  goto LABEL_81;
                }
                if (*(unsigned char *)(v37 + 16) != 17
                  || (*(_UNKNOWN **)(v37 + 32) == &unk_1CFB2E344 ? (uint64_t v40 = *(void *)(v37 + 40)) : (uint64_t v40 = v37 + 24),
                      (*(unsigned char *)(v40 + 28) & 7) == 3))
                {
                  if (*(unsigned char *)(v38 + 16) != 17) {
                    goto LABEL_81;
                  }
                  uint64_t v41 = *(_UNKNOWN **)(v38 + 32) == &unk_1CFB2E344 ? *(void *)(v38 + 40) : v38 + 24;
                  if ((*(unsigned char *)(v41 + 28) & 7) == 3) {
                    goto LABEL_81;
                  }
                }
              }
            }
            if (v69 >= (unint64_t)HIDWORD(v69)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v42 = (char *)v68 + 16 * v69;
            void *v42 = v37;
            v42[1] = v38;
            LODWORD(v69) = v69 + 1;
            goto LABEL_81;
          }
        }
        else
        {
          uint64_t v29 = *(void *)v28;
          uint64_t v66 = 0;
          uint64_t v67 = 0;
          if (v29 != 0xFFFFFFFFFFFFFFFFLL >> -(char)v27) {
            goto LABEL_54;
          }
        }
      }
      else
      {
        uint64_t v66 = 0;
        uint64_t v67 = 0;
      }
      v65[0] = &v67;
      v65[1] = &v66;
      if (sub_1CB90D004(v65, v9)) {
        goto LABEL_55;
      }
      unint64_t v31 = 0;
      int v32 = 1;
      goto LABEL_59;
    }
    if (*(unsigned __int8 *)(v9 + 16) >= 0x15u) {
      goto LABEL_9;
    }
LABEL_104:
    unsigned int v7 = v69;
  }
  while (v7);
  if (v68 != v70) {
    free(v68);
  }
  return v6 & 1;
}

uint64_t sub_1CCD60A4C(uint64_t a1, uint64_t *a2)
{
  uint64_t v10 = *a2;
  int v11 = 0;
  uint64_t v12 = 0;
  if (sub_1CCD64E08(a1, &v10, &v12))
  {
    unsigned int v8 = *((_DWORD *)v12 + 2);
  }
  else
  {
    uint64_t v4 = sub_1CCD64EB0((_DWORD *)a1, (uint64_t)&v10, &v10, v12);
    *uint64_t v4 = v10;
    *((_DWORD *)v4 + 2) = v11;
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 80);
    if (v6 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unsigned int v7 = (void *)(*(void *)(a1 + 72) + 16 * v6);
    *unsigned int v7 = v5;
    v7[1] = 0;
    unsigned int v8 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = v8 + 1;
    *((_DWORD *)v4 + 2) = v8;
  }
  return *(void *)(a1 + 72) + 16 * v8 + 8;
}

uint64_t sub_1CCD60B24(uint64_t a1)
{
  int v1 = *(_WORD *)(a1 + 18) & 0x3F;
  if (v1 != 1)
  {
    if (v1 == 32) {
      return 1;
    }
    if (v1 != 9 || (*(unsigned char *)(a1 + 17) & 4) == 0) {
      return 0;
    }
  }
  uint64_t v2 = *(void *)(a1 - 64);
  uint64_t v3 = *(void *)(a1 - 32);
  if (*(unsigned char *)(v2 + 16) != 17
    || (*(_UNKNOWN **)(v2 + 32) == &unk_1CFB2E344 ? (uint64_t v4 = *(void *)(v2 + 40)) : (uint64_t v4 = v2 + 24),
        (*(unsigned char *)(v4 + 28) & 7) == 3))
  {
    if (*(unsigned char *)(v3 + 16) != 17) {
      return 0;
    }
    uint64_t v5 = *(_UNKNOWN **)(v3 + 32) == &unk_1CFB2E344 ? *(void *)(v3 + 40) : v3 + 24;
    if ((*(unsigned char *)(v5 + 28) & 7) == 3) {
      return 0;
    }
  }
  return 1;
}

uint64_t llvm::GVNPass::processLoad(llvm::GVNPass *this, llvm::LoadInst *a2)
{
  uint64_t v3 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
  if (!v3 || (*((_WORD *)a2 + 9) & 0x301) != 0) {
    return 0;
  }
  if (!*((void *)a2 + 1))
  {
    sub_1CCD5D120((int32x2_t *)this, a2);
    return 1;
  }
  uint64_t Dependency = llvm::MemoryDependenceResults::getDependency(v3, a2);
  if ((Dependency & 0xE000000000000007) != 0x2000000000000003)
  {
    unsigned int v7 = (llvm::Instruction *)*((void *)a2 - 4);
    if ((unint64_t)(Dependency & 7) - 1 < 2 || *((unsigned char *)v7 + 16) == 85)
    {
      void v15[3] = 0;
      uint64_t Availability = llvm::GVNPass::AnalyzeLoadAvailability((uint64_t)this, (uint64_t)a2, Dependency, v7, (const llvm::DataLayout *)v15);
      if (Availability)
      {
        uint64_t v10 = sub_1CCD5AF1C((uint64_t)v15, *(llvm::IntegerType ***)a2, *(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40), a2, (uint64_t)this, v9);
        llvm::patchReplacementInstruction(a2, v10, v11);
        llvm::Value::doRAUW(a2, v10, (llvm::Value *)1);
        sub_1CCD5D120((int32x2_t *)this, a2);
        uint64_t v12 = (int32x2_t **)*((void *)this + 15);
        if (v12) {
          sub_1CC0BCCDC(v12, (uint64_t)a2, 0);
        }
        sub_1CCD5F7FC((llvm::Type **)a2, (unsigned __int8 *)v10, *((uint64_t ****)this + 12));
        int v13 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
        if (v13)
        {
          int v14 = (*(_DWORD *)(*(void *)v10 + 8) & 0xFE) == 0x12
              ? *(unsigned __int8 *)(**(void **)(*(void *)v10 + 16) + 8)
              : *(_DWORD *)(*(void *)v10 + 8);
          if (v14 == 15) {
            llvm::MemoryDependenceResults::invalidateCachedPointerInfo(v13, v10);
          }
        }
      }
      return Availability;
    }
    return 0;
  }

  return llvm::GVNPass::processNonLocalLoad(this, a2);
}

BOOL llvm::GVNPass::ValueTable::areAllValsInBB(llvm::GVNPass::ValueTable *this, int a2, const llvm::BasicBlock *a3, llvm::GVNPass *a4)
{
  int v8 = a2;
  uint64_t v5 = sub_1CCD64000((uint64_t)a4 + 312, &v8) + 8;
  do
  {
    unsigned int v6 = *(const llvm::BasicBlock **)(v5 + 8);
    if (v6 != a3) {
      break;
    }
    uint64_t v5 = *(void *)(v5 + 16);
  }
  while (v5);
  return v6 == a3;
}

uint64_t llvm::GVNPass::ValueTable::phiTranslate(llvm::GVNPass::ValueTable *this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3, uint64_t a4, llvm::GVNPass *a5)
{
  int v11 = (char *)this + 128;
  uint64_t v10 = *((void *)this + 16);
  uint64_t v18 = 0;
  if (sub_1CCD658D4(v10, *((_DWORD *)v11 + 4), a4, (uint64_t)a2, &v18)) {
    BOOL v12 = v18 == *(void *)v11 + 24 * *((unsigned int *)v11 + 4);
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12) {
    return *(unsigned int *)(v18 + 16);
  }
  uint64_t v13 = llvm::GVNPass::ValueTable::phiTranslateImpl(this, a2, a3, a4, a5);
  uint64_t v18 = 0;
  if (sub_1CCD658D4(*((void *)this + 16), *((_DWORD *)this + 36), a4, (uint64_t)a2, &v18)) {
    return v13;
  }
  int v15 = *((_DWORD *)this + 34);
  unsigned int v16 = *((_DWORD *)this + 36);
  if (4 * v15 + 4 >= 3 * v16)
  {
    v16 *= 2;
  }
  else if (v16 + ~v15 - *((_DWORD *)this + 35) > v16 >> 3)
  {
    goto LABEL_10;
  }
  sub_1CCD659C0((uint64_t)v11, v16);
  uint64_t v18 = 0;
  sub_1CCD658D4(*((void *)this + 16), *((_DWORD *)this + 36), a4, (uint64_t)a2, &v18);
LABEL_10:
  uint64_t v17 = v18;
  ++*((_DWORD *)this + 34);
  if (*(_DWORD *)v17 != -1 || *(void *)(v17 + 8) != -4096) {
    --*((_DWORD *)this + 35);
  }
  *(_DWORD *)uint64_t v17 = a4;
  *(void *)(v17 + 8) = a2;
  *(_DWORD *)(v17 + 16) = v13;
  return v13;
}

uint64_t llvm::GVNPass::ValueTable::phiTranslateImpl(llvm::GVNPass::ValueTable *this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3, uint64_t a4, llvm::GVNPass *a5)
{
  v47[3] = *MEMORY[0x1E4F143B8];
  int v43 = a4;
  uint64_t v10 = *(void *)(sub_1CCD6494C((uint64_t)this + 104, &v43) + 8);
  if (!v10)
  {
    LODWORD(v44) = a4;
    uint64_t v11 = sub_1CCD64000((uint64_t)a5 + 312, &v44) + 8;
    while (*(const llvm::BasicBlock **)(v11 + 8) == a3)
    {
      uint64_t v11 = *(void *)(v11 + 16);
      if (!v11)
      {
        uint64_t v12 = *((void *)this + 10);
        if (a4 >= (unint64_t)((*((void *)this + 11) - v12) >> 2)) {
          return a4;
        }
        unsigned int v13 = *(_DWORD *)(v12 + 4 * a4);
        if (!v13) {
          return a4;
        }
        uint64_t v14 = *((void *)this + 7) + 48 * v13;
        long long v44 = *(_OWORD *)v14;
        unsigned int v45 = v47;
        uint64_t v46 = 0x400000000;
        unint64_t v15 = *(unsigned int *)(v14 + 24);
        unsigned int v16 = (void **)(v14 + 16);
        if (v15) {
          BOOL v17 = &v45 == v16;
        }
        else {
          BOOL v17 = 1;
        }
        if (!v17)
        {
          if (v15 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v47, *v16, 4 * v15);
          unint64_t v18 = 0;
          LODWORD(v46) = v15;
          do
          {
            if (v18 < 2 || v44 != 65)
            {
              BOOL v19 = v18 > 1 && v44 == 63;
              BOOL v20 = v19;
              BOOL v21 = v44 != 64 || v18 == 0;
              if (v21 && !v20)
              {
                int v22 = llvm::GVNPass::ValueTable::phiTranslate(this, a2, a3, *((_DWORD *)v45 + v18), a5);
                *((_DWORD *)v45 + v18) = v22;
                unint64_t v15 = v46;
              }
            }
            ++v18;
          }
          while (v18 < v15);
        }
        if (BYTE4(v44))
        {
          uint64_t v23 = v45;
          int v24 = *(_DWORD *)v45;
          unsigned int v25 = *((_DWORD *)v45 + 1);
          if (*(_DWORD *)v45 > v25)
          {
            *(_DWORD *)unsigned int v45 = v25;
            v23[1] = v24;
            if ((v44 >> 8) - 53 <= 1)
            {
              int v42 = v44 & 0xFFFFFF00;
              LODWORD(v44) = llvm::CmpInst::getSwappedPredicate(v44) | v42;
            }
          }
        }
        uint64_t v28 = sub_1CCD64F74((uint64_t)this + 24, (uint64_t)&v44)[12];
        if (v28)
        {
          if (v28 != a4 && v44 == 56)
          {
            if (llvm::GVNPass::ValueTable::areCallValsEqual(this, a4, v26, v27, a3, a5)) {
              uint64_t v28 = v28;
            }
            else {
              uint64_t v28 = a4;
            }
          }
        }
        else
        {
          uint64_t v28 = a4;
        }
        if (v45 != v47) {
          free(v45);
        }
        return v28;
      }
    }
    return a4;
  }
  int v29 = *(_DWORD *)(v10 + 20);
  uint64_t v30 = v29 & 0x7FFFFFF;
  if ((v29 & 0x7FFFFFF) != 0)
  {
    uint64_t v31 = 0;
    while (1)
    {
      if (*(const llvm::BasicBlock **)(v10 + 40) != a3) {
        goto LABEL_39;
      }
      uint64_t v32 = (v29 & 0x40000000) != 0 ? *(void *)(v10 - 8) : v10 - 32 * v30;
      if (*(const llvm::BasicBlock **)(v32 + 32 * *(unsigned int *)(v10 + 60) + 8 * v31) != a2) {
        goto LABEL_39;
      }
      uint64_t v33 = *(void *)this;
      uint64_t v34 = *((unsigned int *)this + 4);
      if (!v34) {
        goto LABEL_56;
      }
      uint64_t v35 = *(void *)(v32 + 32 * v31);
      LODWORD(v36) = ((v35 >> 4) ^ (v35 >> 9)) & (v34 - 1);
      uint64_t v37 = (uint64_t *)(v33 + 16 * v36);
      uint64_t v38 = *v37;
      if (v35 != *v37) {
        break;
      }
LABEL_50:
      if (v37 != (uint64_t *)(v33 + 16 * v34))
      {
        uint64_t v28 = *((unsigned int *)v37 + 2);
        if (v28) {
          return v28;
        }
      }
LABEL_39:
      if (++v31 == v30) {
        return a4;
      }
    }
    int v39 = 1;
    while (v38 != -4096)
    {
      int v40 = v36 + v39++;
      uint64_t v36 = v40 & (v34 - 1);
      uint64_t v38 = *(void *)(v33 + 16 * v36);
      if (v35 == v38)
      {
        uint64_t v37 = (uint64_t *)(v33 + 16 * v36);
        goto LABEL_50;
      }
    }
LABEL_56:
    uint64_t v37 = (uint64_t *)(v33 + 16 * v34);
    goto LABEL_50;
  }
  return a4;
}

uint64_t llvm::GVNPass::ValueTable::eraseTranslateCacheEntry(uint64_t this, int a2, const llvm::BasicBlock *a3)
{
  uint64_t v3 = *((void *)a3 + 1);
  if (v3)
  {
    uint64_t v5 = this;
    while (1)
    {
      uint64_t v6 = *(void *)(v3 + 24);
      unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
      BOOL v8 = v6 && v7 >= 0x1C;
      if (v8 && v7 - 29 < 0xB) {
        break;
      }
      uint64_t v3 = *(void *)(v3 + 8);
      if (!v3) {
        return this;
      }
    }
LABEL_13:
    uint64_t v10 = *(void *)(v6 + 40);
    unint64_t v15 = 0;
    this = sub_1CCD658D4(*(void *)(v5 + 128), *(_DWORD *)(v5 + 144), a2, v10, &v15);
    if (this)
    {
      uint64_t v11 = v15;
      *unint64_t v15 = -2;
      *((void *)v11 + 1) = -8192;
      *(int32x2_t *)(v5 + 136) = vadd_s32(*(int32x2_t *)(v5 + 136), (int32x2_t)0x1FFFFFFFFLL);
    }
    while (1)
    {
      uint64_t v3 = *(void *)(v3 + 8);
      if (!v3) {
        break;
      }
      uint64_t v6 = *(void *)(v3 + 24);
      unsigned int v12 = *(unsigned __int8 *)(v6 + 16);
      if (v6) {
        BOOL v13 = v12 >= 0x1C;
      }
      else {
        BOOL v13 = 0;
      }
      if (v13 && v12 - 29 < 0xB) {
        goto LABEL_13;
      }
    }
  }
  return this;
}

uint64_t llvm::GVNPass::findLeader(llvm::GVNPass *this, const llvm::BasicBlock *a2, int a3)
{
  int v4 = a3;
  if (*(void *)(sub_1CCD64000((uint64_t)this + 312, &v4) + 8)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
  }
  return 0;
}

void llvm::GVNPass::assignBlockRPONumber(llvm::GVNPass *this, llvm::Function *a2)
{
  int v4 = (char *)this + 664;
  sub_1CCD61504((_DWORD *)this + 166);
  uint64_t v9 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CC86D39C(&v10, (uint64_t)&v9);
  uint64_t v6 = v10;
  uint64_t v5 = v11;
  if (v11 != v10)
  {
    int v7 = 1;
    do
    {
      uint64_t v8 = *((void *)v5 - 1);
      v5 -= 8;
      uint64_t v9 = (llvm::Function *)v8;
      *(_DWORD *)(sub_1CCD65B3C((uint64_t)v4, (uint64_t *)&v9) + 8) = v7++;
    }
    while (v5 != v6);
    uint64_t v5 = v10;
  }
  *((unsigned char *)this + 688) = 0;
  if (v5)
  {
    uint64_t v11 = v5;
    operator delete(v5);
  }
}

_DWORD *sub_1CCD61504(_DWORD *result)
{
  int v1 = result;
  int v2 = result[2];
  if (v2)
  {
    unsigned int v3 = result[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      int v6 = 1 << (33 - __clz(v2 - 1));
      if (v6 <= 64) {
        int v7 = 64;
      }
      else {
        int v7 = v6;
      }
LABEL_13:
      if (v7 == v3)
      {
        *((void *)result + 1) = 0;
        uint64_t v12 = 16 * v3;
        BOOL v13 = *(void **)result;
        do
        {
          *BOOL v13 = -4096;
          v13 += 2;
          v12 -= 16;
        }
        while (v12);
      }
      else
      {
        uint64_t result = (_DWORD *)MEMORY[0x1D25D9CD0](*(void *)result, 8);
        if (v7)
        {
          unint64_t v8 = (4 * v7 / 3u + 1) | ((unint64_t)(4 * v7 / 3u + 1) >> 1);
          unint64_t v9 = v8 | (v8 >> 2) | ((v8 | (v8 >> 2)) >> 4);
          LODWORD(v9) = (((v9 | (v9 >> 8)) >> 16) | v9 | (v9 >> 8)) + 1;
          v1[4] = v9;
          uint64_t result = operator new(16 * v9, (std::align_val_t)8uLL);
          *(void *)int v1 = result;
          *((void *)v1 + 1) = 0;
          uint64_t v10 = v1[4];
          if (v10)
          {
            uint64_t v11 = 16 * v10;
            do
            {
              *(void *)uint64_t result = -4096;
              result += 4;
              v11 -= 16;
            }
            while (v11);
          }
        }
        else
        {
          *(void *)int v1 = 0;
          *((void *)v1 + 1) = 0;
          v1[4] = 0;
        }
      }
      return result;
    }
  }
  else
  {
    if (!result[3]) {
      return result;
    }
    unsigned int v3 = result[4];
    if (v3 > 0x40)
    {
      int v7 = 0;
      goto LABEL_13;
    }
  }
  if (v3)
  {
    int v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *int v4 = -4096;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  *((void *)result + 1) = 0;
  return result;
}

uint64_t llvm::GVNPass::replaceOperandsForInBlockEquality(llvm::GVNPass *this, llvm::Instruction *a2)
{
  int v2 = *((_DWORD *)a2 + 5);
  unint64_t v3 = v2 & 0x7FFFFFF;
  if ((v2 & 0x7FFFFFF) != 0)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    char v8 = 0;
    unint64_t v9 = (int *)((char *)this + 432);
    uint64_t v10 = (unsigned int *)((char *)this + 512);
    uint64_t v11 = (char *)this + 440;
    do
    {
      if ((v2 & 0x40000000) != 0) {
        uint64_t v12 = (char *)*((void *)a2 - 1);
      }
      else {
        uint64_t v12 = (char *)a2 - 32 * v3;
      }
      uint64_t v13 = *(void *)&v12[v6];
      int v24 = 0;
      uint64_t v25 = v13;
      if (sub_1CCD64E08((uint64_t)v9, &v25, &v24))
      {
        BOOL v17 = v24;
        int v14 = *v9;
      }
      else
      {
        int v14 = *v9;
        if (*v9)
        {
          unint64_t v15 = v11;
          uint64_t v16 = 4;
        }
        else
        {
          unint64_t v15 = (char *)*((void *)this + 55);
          uint64_t v16 = *((unsigned int *)this + 112);
        }
        BOOL v17 = &v15[16 * v16];
      }
      if (v14)
      {
        unint64_t v18 = v11;
        uint64_t v19 = 4;
      }
      else
      {
        unint64_t v18 = (char *)*((void *)this + 55);
        uint64_t v19 = *((unsigned int *)this + 112);
      }
      BOOL v20 = &v18[16 * v19] == v17;
      BOOL v21 = (unsigned int *)(v17 + 8);
      if (v20) {
        BOOL v21 = v10;
      }
      uint64_t v22 = *v21;
      if (v22 != *v10)
      {
        sub_1CC808490((uint64_t)a2, v7, *(void *)(*((void *)this + 63) + 16 * v22 + 8));
        char v8 = 1;
      }
      ++v7;
      int v2 = *((_DWORD *)a2 + 5);
      unint64_t v3 = v2 & 0x7FFFFFF;
      v6 += 32;
    }
    while (v7 < v3);
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

void *sub_1CCD61790(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v13 = a2;
  uint64_t result = (void *)sub_1CCD64000(a1 + 312, &v13);
  char v8 = result;
  if (result[1])
  {
    *(void *)(a1 + 416) += 24;
    uint64_t v9 = *(void *)(a1 + 336);
    if (((v9 + 7) & 0xFFFFFFFFFFFFFFF8) - v9 + 24 > *(void *)(a1 + 344) - v9)
    {
      unsigned int v10 = *(_DWORD *)(a1 + 360) >> 7;
      if (v10 >= 0x1E) {
        LOBYTE(v10) = 30;
      }
      uint64_t v11 = 4096 << v10;
      uint64_t result = operator new(4096 << v10, (std::align_val_t)8uLL);
      unsigned int v12 = *(_DWORD *)(a1 + 360);
      if (v12 >= *(_DWORD *)(a1 + 364)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 352) + 8 * v12) = result;
      ++*(_DWORD *)(a1 + 360);
      *(void *)(a1 + 344) = (char *)result + v11;
    }
    else
    {
      uint64_t result = (void *)((v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
    *(void *)(a1 + 336) = result + 3;
    void *result = a3;
    result[1] = a4;
    result[2] = v8[3];
    v8[3] = result;
  }
  else
  {
    result[1] = a3;
    result[2] = a4;
  }
  return result;
}

uint64_t llvm::GVNPass::processInstruction(llvm::GVNPass *this, llvm::Instruction *a2)
{
  v83[31] = *MEMORY[0x1E4F143B8];
  if (sub_1CBF63B28((uint64_t)a2)) {
    goto LABEL_2;
  }
  uint64_t v8 = *((void *)this + 5);
  uint64_t v75 = (llvm::BasicBlock *)(*(void *)(*(void *)(*((void *)a2 + 5) + 56) + 40) + 272);
  int8x16_t v76 = vextq_s8(*(int8x16_t *)((char *)this + 24), *(int8x16_t *)((char *)this + 24), 8uLL);
  uint64_t v77 = v8;
  uint64_t v78 = 0;
  __int16 v79 = 257;
  int v9 = *((_DWORD *)a2 + 5);
  if ((v9 & 0x40000000) != 0)
  {
    uint64_t v11 = (uint64_t *)*((void *)a2 - 1);
    unint64_t v10 = v9 & 0x7FFFFFF;
  }
  else
  {
    unint64_t v10 = v9 & 0x7FFFFFF;
    uint64_t v11 = (uint64_t *)((char *)a2 - 32 * v10);
  }
  unsigned int v81 = v83;
  uint64_t v82 = 0x800000000;
  if (v10 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v10)
  {
    uint64_t v12 = 32 * v10;
    int v13 = v83;
    do
    {
      uint64_t v14 = *v11;
      v11 += 4;
      *v13++ = v14;
      v12 -= 32;
    }
    while (v12);
    unint64_t v15 = v81;
  }
  else
  {
    unint64_t v15 = v83;
  }
  LODWORD(v82) = v10;
  uint64_t v16 = llvm::SimplifyInstructionWithOperands(a2, (uint64_t)v15, v10, (uint64_t)&v75, v4, v5, v6);
  if (v81 == v83)
  {
    if (!v16) {
      goto LABEL_27;
    }
  }
  else
  {
    free(v81);
    if (!v16) {
      goto LABEL_27;
    }
  }
  if (*((void *)a2 + 1))
  {
    llvm::InstructionPrecedenceTracking::removeUsersOf(*((int32x2_t **)this + 13), a2);
    llvm::Value::doRAUW(a2, v16, (llvm::Value *)1);
    if (*((void *)a2 + 1)
      || !llvm::wouldInstructionBeTriviallyDead((uint64_t)a2, *((uint64_t **)this + 4)))
    {
LABEL_19:
      BOOL v17 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
      if (v17)
      {
        if ((*(_DWORD *)(*(void *)v16 + 8) & 0xFE) == 0x12) {
          int v18 = *(unsigned __int8 *)(**(void **)(*(void *)v16 + 16) + 8);
        }
        else {
          int v18 = *(_DWORD *)(*(void *)v16 + 8);
        }
        if (v18 == 15) {
          llvm::MemoryDependenceResults::invalidateCachedPointerInfo(v17, v16);
        }
      }
      goto LABEL_34;
    }
LABEL_18:
    sub_1CCD5D120((int32x2_t *)this, a2);
    goto LABEL_19;
  }
  if (llvm::wouldInstructionBeTriviallyDead((uint64_t)a2, *((uint64_t **)this + 4))) {
    goto LABEL_18;
  }
LABEL_27:
  BOOL v19 = sub_1CBF698E4((uint64_t)a2);
  if (a2 && v19)
  {
    char v21 = llvm::GVNPass::processAssumeIntrinsic((uint64_t)this, (uint64_t)a2, v20);
LABEL_30:
    LOBYTE(v7) = v21;
    return v7 & 1;
  }
  int v22 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v22 == 60)
  {
    if (llvm::GVNPass::processLoad(this, a2))
    {
LABEL_34:
      LOBYTE(v7) = 1;
      return v7 & 1;
    }
    int v25 = llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass *)((char *)this + 128), a2);
    uint64_t v26 = *((void *)a2 + 5);
    unsigned int v27 = this;
    goto LABEL_42;
  }
  if (a2 && v22 == 30)
  {
    if ((*((_DWORD *)a2 + 5) & 0x7FFFFFF) == 3)
    {
      int v24 = (unsigned __int8 *)*((void *)a2 - 12);
      if (v24[16] <= 0x14u)
      {
        char v21 = llvm::GVNPass::processFoldableCondBr(this, a2);
        goto LABEL_30;
      }
      uint64_t v34 = (uint64_t ***)*((void *)a2 - 4);
      uint64_t v35 = (uint64_t ***)*((void *)a2 - 8);
      if (v34 != v35)
      {
        uint64_t v36 = (llvm::BasicBlock *)*((void *)a2 + 5);
        uint64_t v37 = **v34;
        uint64_t v38 = *v37;
        int v39 = *(llvm::Value **)(*v37 + 1560);
        if (!v39)
        {
          uint64_t v72 = *(llvm::ConstantInt **)(v38 + 1888);
          unsigned int v73 = *(_DWORD *)(v38 + 1896);
          LODWORD(v82) = v73 >> 8;
          if (v73 >> 8 > 0x40) {
            operator new[]();
          }
          if (v73 <= 0xFF) {
            LOBYTE(v74) = 0;
          }
          else {
            unint64_t v74 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v73) + 63);
          }
          unsigned int v81 = (void *)(v74 & 1);
          int v39 = (llvm::Value *)llvm::ConstantInt::get(v72, (llvm::LLVMContext *)&v81, v20);
          if (v82 >= 0x41 && v81) {
            MEMORY[0x1D25D9CB0](v81, 0x1000C8000313F17);
          }
          *(void *)(v38 + 1560) = v39;
        }
        uint64_t v75 = v36;
        v76.i64[0] = (uint64_t)v34;
        char v41 = llvm::GVNPass::propagateEquality(this, (llvm::Value *)v24, v39, &v75, 1);
        int v42 = **v35;
        uint64_t v43 = *v42;
        unint64_t v7 = *(llvm::Value **)(*v42 + 1568);
        if (!v7)
        {
          uint64_t v70 = *(llvm::ConstantInt **)(v43 + 1888);
          unsigned int v71 = *(_DWORD *)(v43 + 1896);
          LODWORD(v82) = v71 >> 8;
          if (v71 >> 8 > 0x40) {
            operator new[]();
          }
          unsigned int v81 = 0;
          unint64_t v7 = (llvm::Value *)llvm::ConstantInt::get(v70, (llvm::LLVMContext *)&v81, v40);
          if (v82 >= 0x41 && v81) {
            MEMORY[0x1D25D9CB0](v81, 0x1000C8000313F17);
          }
          *(void *)(v43 + 1568) = v7;
        }
        unsigned int v81 = v36;
        uint64_t v82 = (uint64_t)v35;
        LOBYTE(v7) = v41 | llvm::GVNPass::propagateEquality(this, (llvm::Value *)v24, v7, (llvm::BasicBlock **)&v81, 1);
        return v7 & 1;
      }
    }
LABEL_2:
    LOBYTE(v7) = 0;
    return v7 & 1;
  }
  if (!a2 || v22 != 31)
  {
    if (*(unsigned char *)(*(void *)a2 + 8) == 7) {
      goto LABEL_2;
    }
    unsigned int v30 = *((_DWORD *)this + 76);
    unsigned int v31 = llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass *)((char *)this + 128), a2);
    unsigned int v32 = v31;
    int v33 = *((unsigned __int8 *)a2 + 16);
    if ((v33 - 29) >= 0xB && v33 != 83 && v33 != 59)
    {
      uint64_t v26 = *((void *)a2 + 5);
      if (v31 >= v30) {
        goto LABEL_52;
      }
      uint64_t Leader = (llvm::Instruction *)llvm::GVNPass::findLeader(this, *((const llvm::BasicBlock **)a2 + 5), v31);
      if (Leader)
      {
        uint64_t v67 = Leader;
        if (Leader != a2)
        {
          llvm::patchReplacementInstruction(a2, Leader, v66);
          llvm::Value::doRAUW(a2, v67, (llvm::Value *)1);
          int v68 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
          if (v68)
          {
            int v69 = (*(_DWORD *)(*(void *)v67 + 8) & 0xFE) == 0x12
                ? *(unsigned __int8 *)(**(void **)(*(void *)v67 + 16) + 8)
                : *(_DWORD *)(*(void *)v67 + 8);
            if (v69 == 15) {
              llvm::MemoryDependenceResults::invalidateCachedPointerInfo(v68, v67);
            }
          }
          sub_1CCD5D120((int32x2_t *)this, a2);
          goto LABEL_34;
        }
        goto LABEL_2;
      }
    }
    uint64_t v26 = *((void *)a2 + 5);
LABEL_52:
    unsigned int v27 = this;
    int v25 = v32;
LABEL_42:
    sub_1CCD61790((uint64_t)v27, v25, (uint64_t)a2, v26);
    goto LABEL_2;
  }
  unsigned int v28 = *((_DWORD *)a2 + 5);
  if ((v28 & 0x40000000) != 0) {
    int v29 = (llvm::Value **)*((void *)a2 - 1);
  }
  else {
    int v29 = (llvm::Value **)((char *)a2 - 32 * (v28 & 0x7FFFFFF));
  }
  long long v44 = *v29;
  unsigned int v45 = (llvm::BasicBlock *)*((void *)a2 + 5);
  unsigned int v81 = (void *)1;
  for (uint64_t i = 8; i != 264; i += 16)
    *(void **)((char *)&v81 + i) = (void *)-4096;
  unsigned int v47 = (v28 >> 1) & 0x3FFFFFF;
  if (!v47)
  {
    uint64_t v56 = 0xFFFFFFFFLL;
    goto LABEL_74;
  }
  uint64_t v48 = 0;
  unint64_t v49 = (unint64_t)v47 << 6;
  do
  {
    int v50 = *((_DWORD *)a2 + 5);
    if ((v50 & 0x40000000) != 0) {
      uint64_t v51 = (char *)*((void *)a2 - 1);
    }
    else {
      uint64_t v51 = (char *)a2 - 32 * (v50 & 0x7FFFFFF);
    }
    uint64_t v80 = *(void *)&v51[v48 + 32];
    uint64_t v75 = 0;
    int v52 = sub_1CCD65CF0((uint64_t)&v81, &v80, &v75);
    int v53 = v75;
    if (v52)
    {
      int v54 = *((_DWORD *)v75 + 2);
    }
    else
    {
      int v53 = (llvm::BasicBlock *)sub_1CCD65D98(&v81, (uint64_t)&v80, &v80, v75);
      int v54 = 0;
      *(void *)int v53 = v80;
      *((_DWORD *)v53 + 2) = 0;
    }
    *((_DWORD *)v53 + 2) = v54 + 1;
    v48 += 64;
  }
  while (v49 != v48);
  int v55 = (*((_DWORD *)a2 + 5) >> 1) & 0x3FFFFFF;
  uint64_t v56 = (v55 - 1);
  if (v55 != 1)
  {
LABEL_74:
    LODWORD(v7) = 0;
    int v57 = 2;
    uint64_t v58 = 4294967294;
    do
    {
      int v59 = *((_DWORD *)a2 + 5);
      if ((v59 & 0x40000000) != 0) {
        int v60 = (char *)*((void *)a2 - 1);
      }
      else {
        int v60 = (char *)a2 - 32 * (v59 & 0x7FFFFFF);
      }
      uint64_t v61 = (v57 + 1);
      if (!v58) {
        uint64_t v61 = 1;
      }
      int v62 = *(llvm::BasicBlock **)&v60[32 * v61];
      uint64_t v75 = v62;
      uint64_t v80 = 0;
      if ((sub_1CCD660BC((uint64_t)&v81, &v75, &v80) & 1) != 0 && *(_DWORD *)(v80 + 8) == 1)
      {
        uint64_t v75 = v45;
        v76.i64[0] = (uint64_t)v62;
        int v63 = *((_DWORD *)a2 + 5);
        if ((v63 & 0x40000000) != 0) {
          uint64_t v64 = (char *)*((void *)a2 - 1);
        }
        else {
          uint64_t v64 = (char *)a2 - 32 * (v63 & 0x7FFFFFF);
        }
        LODWORD(v7) = v7 | llvm::GVNPass::propagateEquality(this, v44, *(llvm::Value **)&v64[32 * (v57 & 0xFFFFFFFE)], &v75, 1);
      }
      v57 += 2;
      --v58;
      --v56;
    }
    while (v56);
    goto LABEL_87;
  }
  LOBYTE(v7) = 0;
LABEL_87:
  if ((v81 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v82, 8);
  }
  return v7 & 1;
}

uint64_t llvm::GVNPass::processFoldableCondBr(llvm::GVNPass *this, llvm::BranchInst *a2)
{
  if (!a2) {
    return 0;
  }
  if ((*((_DWORD *)a2 + 5) & 0x7FFFFFF) == 1) {
    return 0;
  }
  unint64_t v3 = (llvm::BasicBlock **)((char *)a2 - 32);
  if (*((void *)a2 - 4) == *((void *)a2 - 8)) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v6 = *((void *)a2 - 12);
  if (v6 && *(unsigned char *)(v6 + 16) == 16)
  {
    unint64_t v7 = (void *)(v6 + 24);
    if (*(_DWORD *)(v6 + 32) >= 0x41u) {
      unint64_t v7 = (void *)*v7;
    }
    if (*v7) {
      unint64_t v3 = (llvm::BasicBlock **)((char *)a2 - 64);
    }
    uint64_t v8 = *v3;
    uint64_t v9 = 0;
    unint64_t v10 = v8;
    if (sub_1CBFFBBB4((uint64_t *)this + 6, &v10, &v9)) {
      return 0;
    }
    if (!llvm::BasicBlock::getSinglePredecessor(v8)) {
      uint64_t v8 = (llvm::BasicBlock *)llvm::GVNPass::splitCriticalEdges(this, *((llvm::BasicBlock **)a2 + 5), v8);
    }
    llvm::GVNPass::addDeadBlock((llvm::MemoryDependenceResults **)this, v8);
    return 1;
  }
  return result;
}

uint64_t llvm::GVNPass::iterateOnFunction(llvm::GVNPass *this, llvm::Function *a2)
{
  llvm::GVNPass::cleanupGlobalSets(this);
  uint64_t v9 = a2;
  long long __p = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CC86D39C((char **)&__p, (uint64_t)&v9);
  uint64_t v5 = (char *)__p;
  int v4 = v11;
  if (v11 == __p)
  {
    LOBYTE(v6) = 0;
  }
  else
  {
    int v6 = 0;
    do
    {
      unint64_t v7 = (llvm::BasicBlock *)*((void *)v4 - 1);
      v4 -= 8;
      v6 |= llvm::GVNPass::processBlock(this, v7);
    }
    while (v4 != v5);
    int v4 = (char *)__p;
  }
  if (v4)
  {
    uint64_t v11 = v4;
    operator delete(v4);
  }
  return v6 & 1;
}

void *llvm::GVNPass::assignValNumForDeadCode(void *this)
{
  int v1 = (uint64_t *)this[9];
  int v2 = (uint64_t *)this[10];
  if (v1 != v2)
  {
    uint64_t v3 = (uint64_t)this;
    do
    {
      uint64_t v4 = *v1;
      uint64_t v5 = *v1 + 40;
      for (uint64_t i = *(void *)(*v1 + 48); i != v5; uint64_t i = *(void *)(i + 8))
      {
        if (i) {
          unint64_t v7 = (llvm::Value *)(i - 24);
        }
        else {
          unint64_t v7 = 0;
        }
        int v8 = llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass::ValueTable *)(v3 + 128), v7);
        this = sub_1CCD61790(v3, v8, (uint64_t)v7, v4);
      }
      ++v1;
    }
    while (v1 != v2);
  }
  return this;
}

uint64_t llvm::GVNPass::performPRE(llvm::GVNPass *this, llvm::Function *a2)
{
  uint64_t v4 = *((void *)a2 + 10);
  if (v4) {
    uint64_t v5 = v4 - 24;
  }
  else {
    uint64_t v5 = 0;
  }
  long long v44 = (unsigned char *)v5;
  sub_1CCADB4C0((uint64_t *)&v44, (uint64_t)&v53);
  int v6 = v49;
  long long v44 = v49;
  unint64_t v7 = v54;
  if (v54 == v53)
  {
    unsigned int v45 = v49;
    int v8 = v54;
  }
  else
  {
    unsigned int v37 = v55;
    int v6 = malloc_type_malloc(8 * v55, 0x4065EBACuLL);
    if (!v6)
    {
      if (v37) {
        goto LABEL_81;
      }
      int v6 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v6) {
        goto LABEL_81;
      }
    }
    unsigned int v45 = v6;
    int v8 = v53;
    unint64_t v7 = v54;
  }
  unsigned int v9 = v56;
  unsigned int v46 = v55;
  if (v7 == v8) {
    unsigned int v10 = v56;
  }
  else {
    unsigned int v10 = v55;
  }
  if (v10)
  {
    memmove(v6, v7, 8 * v10);
    unsigned int v9 = v56;
  }
  unsigned int v47 = v9;
  int v48 = v57;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  long long __p = 0;
  sub_1CBFE1720(&__p, v58, v59, (v59 - (unsigned char *)v58) >> 5);
  uint64_t v11 = v40;
  uint64_t v12 = v61;
  if (v61 != v60)
  {
    unsigned int v38 = v62;
    uint64_t v11 = malloc_type_malloc(8 * v62, 0x4065EBACuLL);
    if (v11 || !v38 && (uint64_t v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      int v39 = v11;
      int v13 = v60;
      uint64_t v12 = v61;
      goto LABEL_13;
    }
LABEL_81:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  int v39 = v40;
  int v13 = v61;
LABEL_13:
  if (v12 == v13) {
    unsigned int v14 = v63;
  }
  else {
    unsigned int v14 = v62;
  }
  if (v14) {
    memmove(v11, v12, 8 * v14);
  }
  int v42 = 0;
  uint64_t v43 = 0;
  char v41 = 0;
  sub_1CBFE1720(&v41, v64, v65, (v65 - (unsigned char *)v64) >> 5);
  int v15 = 0;
  while (1)
  {
    if (v51 - (unsigned char *)__p != v42 - v41) {
      goto LABEL_33;
    }
    if (__p == v51) {
      break;
    }
    uint64_t v16 = v41 + 16;
    BOOL v17 = (char *)__p + 16;
    while (1)
    {
      int v18 = v17 - 16;
      if (*((void *)v17 - 2) != *((void *)v16 - 2)) {
        break;
      }
      int v19 = v16[8];
      if (v17[8]) {
        BOOL v20 = v19 == 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (v20)
      {
        if ((v17[8] == 0) == (v19 != 0)) {
          break;
        }
      }
      else if (*(_DWORD *)v17 != *(_DWORD *)v16)
      {
        break;
      }
      v16 += 32;
      v17 += 32;
      if (v18 + 32 == v51) {
        goto LABEL_55;
      }
    }
LABEL_33:
    uint64_t v21 = *((void *)v51 - 4);
    uint64_t v22 = *((void *)a2 + 10);
    if (v22) {
      uint64_t v23 = v22 - 24;
    }
    else {
      uint64_t v23 = 0;
    }
    if (v21 != v23)
    {
      uint64_t v24 = *(void *)(v21 + 48);
      uint64_t v25 = v24 - 24;
      if (!v24) {
        uint64_t v25 = 0;
      }
      int v26 = *(unsigned __int8 *)(v25 + 16);
      uint64_t v27 = *(void *)(v21 + 48);
      if (v26 == 83)
      {
        uint64_t v27 = *(void *)(v21 + 48);
        do
        {
          uint64_t v27 = *(void *)(v27 + 8);
          uint64_t v28 = v27 - 24;
          if (!v27) {
            uint64_t v28 = 0;
          }
        }
        while (*(unsigned char *)(v28 + 16) == 83);
      }
      unsigned int v29 = *(unsigned __int8 *)(v27 - 8) - 38;
      BOOL v30 = v29 > 0x38;
      uint64_t v31 = (1 << v29) & 0x100060000000001;
      if (v30 || v31 == 0)
      {
        uint64_t v33 = v21 + 40;
        do
        {
          uint64_t v34 = *(void *)(v24 + 8);
          if (v24) {
            uint64_t v35 = (llvm::Instruction *)(v24 - 24);
          }
          else {
            uint64_t v35 = 0;
          }
          v15 |= llvm::GVNPass::performScalarPRE(this, v35);
          uint64_t v24 = v34;
        }
        while (v34 != v33);
      }
    }
    sub_1CC0D3E0C((uint64_t)&v44);
  }
LABEL_55:
  if (v41)
  {
    int v42 = v41;
    operator delete(v41);
  }
  if (v39 != v40) {
    free(v39);
  }
  if (__p)
  {
    uint64_t v51 = (char *)__p;
    operator delete(__p);
  }
  if (v45 != v44) {
    free(v45);
  }
  if (v64)
  {
    uint64_t v65 = v64;
    operator delete(v64);
  }
  if (v61 != v60) {
    free(v61);
  }
  if (v58)
  {
    int v59 = v58;
    operator delete(v58);
  }
  if (v54 != v53) {
    free(v54);
  }
  return (llvm::GVNPass::splitCriticalEdges(this) | v15) & 1;
}

_DWORD *llvm::GVNPass::cleanupGlobalSets(llvm::GVNPass *this)
{
  llvm::GVNPass::ValueTable::clear((llvm::GVNPass *)((char *)this + 128));
  int v2 = (void *)((char *)this + 312);
  int v3 = *((_DWORD *)this + 80);
  if (v3)
  {
    unsigned int v9 = *((_DWORD *)this + 82);
    if (v9 <= 4 * v3 || v9 < 0x41)
    {
LABEL_27:
      if (v9)
      {
        uint64_t v23 = (_DWORD *)*v2;
        uint64_t v24 = 32 * v9;
        do
        {
          _DWORD *v23 = -1;
          v23 += 8;
          v24 -= 32;
        }
        while (v24);
      }
      *((void *)this + 40) = 0;
      goto LABEL_3;
    }
    int v10 = 1 << (33 - __clz(v3 - 1));
    if (v10 <= 64) {
      int v11 = 64;
    }
    else {
      int v11 = v10;
    }
  }
  else
  {
    if (!*((_DWORD *)this + 81)) {
      goto LABEL_3;
    }
    unsigned int v9 = *((_DWORD *)this + 82);
    if (v9 <= 0x40) {
      goto LABEL_27;
    }
    int v11 = 0;
  }
  if (v11 == v9)
  {
    *((void *)this + 40) = 0;
    uint64_t v25 = 32 * v9;
    int v26 = (_DWORD *)*((void *)this + 39);
    do
    {
      _DWORD *v26 = -1;
      v26 += 8;
      v25 -= 32;
    }
    while (v25);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v2, 8);
    if (v11)
    {
      unint64_t v12 = (4 * v11 / 3u + 1) | ((unint64_t)(4 * v11 / 3u + 1) >> 1);
      unint64_t v13 = v12 | (v12 >> 2) | ((v12 | (v12 >> 2)) >> 4);
      LODWORD(v13) = (((v13 | (v13 >> 8)) >> 16) | v13 | (v13 >> 8)) + 1;
      *((_DWORD *)this + 82) = v13;
      unsigned int v14 = operator new(32 * v13, (std::align_val_t)8uLL);
      *((void *)this + 39) = v14;
      *((void *)this + 40) = 0;
      uint64_t v15 = *((unsigned int *)this + 82);
      if (v15)
      {
        uint64_t v16 = 32 * v15;
        do
        {
          *unsigned int v14 = -1;
          v14 += 8;
          v16 -= 32;
        }
        while (v16);
      }
    }
    else
    {
      void *v2 = 0;
      *((void *)this + 40) = 0;
      *((_DWORD *)this + 82) = 0;
    }
  }
LABEL_3:
  sub_1CCD61504((_DWORD *)this + 166);
  uint64_t v4 = *((unsigned int *)this + 102);
  if (v4)
  {
    BOOL v20 = (uint64_t *)*((void *)this + 50);
    uint64_t v21 = 16 * v4;
    do
    {
      uint64_t v22 = *v20;
      v20 += 2;
      MEMORY[0x1D25D9CD0](v22, 8);
      v21 -= 16;
    }
    while (v21);
  }
  *((_DWORD *)this + 102) = 0;
  uint64_t v5 = *((unsigned int *)this + 90);
  if (v5)
  {
    *((void *)this + 52) = 0;
    int v6 = (void *)*((void *)this + 44);
    uint64_t v7 = *v6 + 4096;
    *((void *)this + 42) = *v6;
    *((void *)this + 43) = v7;
    if (v5 != 1)
    {
      BOOL v17 = v6 + 1;
      uint64_t v18 = 8 * v5 - 8;
      do
      {
        uint64_t v19 = *v17++;
        MEMORY[0x1D25D9CD0](v19, 8);
        v18 -= 8;
      }
      while (v18);
    }
    *((_DWORD *)this + 90) = 1;
  }
  uint64_t result = sub_1CBB8977C((_DWORD *)(*((void *)this + 13) + 8));
  *((unsigned char *)this + 688) = 1;
  return result;
}

uint64_t llvm::GVNPass::processBlock(llvm::GVNPass *this, llvm::BasicBlock *a2)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  if (sub_1CBFFBBB4((uint64_t *)this + 6, &v22, &v21))
  {
    LOBYTE(v5) = 0;
  }
  else
  {
    sub_1CCD6616C((void *)this + 54);
    *((_DWORD *)this + 128) = 0;
    int v5 = llvm::EliminateDuplicatePHINodes(a2, v4);
    uint64_t v8 = *((void *)a2 + 6);
    int v6 = (char *)a2 + 48;
    for (uint64_t i = v8; (char *)i != v6 - 8; uint64_t i = *(void *)(i + 8))
    {
      if (*((_DWORD *)this + 128))
      {
        if (i) {
          uint64_t v19 = (llvm::Instruction *)(i - 24);
        }
        else {
          uint64_t v19 = 0;
        }
        v5 |= llvm::GVNPass::replaceOperandsForInBlockEquality(this, v19);
      }
      if (i) {
        unsigned int v9 = (llvm::Instruction *)(i - 24);
      }
      else {
        unsigned int v9 = 0;
      }
      int v14 = llvm::GVNPass::processInstruction(this, v9);
      if (*((_DWORD *)this + 148))
      {
        uint64_t v15 = (llvm **)*((void *)this + 73);
        uint64_t v16 = *v15;
        llvm::salvageKnowledge(*v15, *((char ***)this + 5), 0, v10, v11, v12, v13);
        uint64_t v22 = v24;
        uint64_t v23 = 0x100000000;
        llvm::findDbgUsers((uint64_t)&v22, (uint64_t ***)v16);
        llvm::salvageDebugInfoForDbgValues(v16, (uint64_t *)v22, v23);
        if (v22 != v24) {
          free(v22);
        }
        BOOL v17 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
        if (v17) {
          llvm::MemoryDependenceResults::removeInstruction(v17, v16);
        }
        uint64_t v18 = (int32x2_t **)*((void *)this + 15);
        if (v18) {
          sub_1CC0BCCDC(v18, (uint64_t)v16, 0);
        }
        llvm::InstructionPrecedenceTracking::removeInstruction(*((int32x2_t **)this + 13), v16);
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
      v5 |= v14;
    }
  }
  return v5 & 1;
}

uint64_t llvm::GVNPass::performScalarPREInsertion(llvm::InstructionPrecedenceTracking **this, llvm::Instruction *a2, llvm::BasicBlock *a3, llvm::BasicBlock *a4)
{
  int v7 = *((_DWORD *)a2 + 5);
  uint64_t v8 = v7 & 0x7FFFFFF;
  if ((v7 & 0x7FFFFFF) == 0)
  {
LABEL_25:
    uint64_t v35 = (llvm::BasicBlock *)*((void *)a3 + 5);
    if (v35 == (llvm::BasicBlock *)((char *)a3 + 40))
    {
      unsigned int v37 = 0;
    }
    else
    {
      if (v35) {
        uint64_t v36 = (char *)v35 - 24;
      }
      else {
        uint64_t v36 = 0;
      }
      if (v36[16] - 29 >= 0xB) {
        unsigned int v37 = 0;
      }
      else {
        unsigned int v37 = v36;
      }
    }
    uint64_t v38 = *((void *)v37 + 5);
    *((void *)a2 + 5) = v38;
    *(_WORD *)(v38 + 18) &= ~0x8000u;
    if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
    {
      uint64_t v57 = *(void *)(v38 + 56);
      if (v57)
      {
        uint64_t v58 = *(llvm::ValueSymbolTable **)(v57 + 104);
        if (v58) {
          llvm::ValueSymbolTable::reinsertValue(v58, a2);
        }
      }
    }
    uint64_t v40 = *((void *)v37 + 3);
    int v39 = v37 + 24;
    *((void *)a2 + 3) = v40;
    *((void *)a2 + 4) = v39;
    *(void *)(v40 + 8) = (char *)a2 + 24;
    void *v39 = (char *)a2 + 24;
    if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
    {
      uint64_t v51 = 0;
      int v50 = &byte_1CFBCE98E;
      goto LABEL_41;
    }
    uint64_t v41 = ***(void ***)a2;
    uint64_t v42 = *(void *)(v41 + 152);
    uint64_t v43 = *(unsigned int *)(v41 + 168);
    if (v43)
    {
      LODWORD(v44) = (v43 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v45 = v42 + 16 * v44;
      unsigned int v46 = *(llvm::Instruction **)v45;
      if (*(llvm::Instruction **)v45 == a2)
      {
LABEL_40:
        unint64_t v49 = *(void **)(v45 + 8);
        uint64_t v52 = (const char *)*v49;
        int v50 = (const char *)(v49 + 2);
        uint64_t v51 = v52;
LABEL_41:
        __int16 v75 = 773;
        v74[0] = v50;
        v74[1] = v51;
        v74[2] = ".pre";
        llvm::Value::setNameImpl(a2, v74);
        if (!a2 || *((unsigned char *)a2 + 16)) {
          goto LABEL_43;
        }
        if ((*((unsigned char *)a2 + 23) & 0x10) == 0) {
          goto LABEL_74;
        }
        uint64_t v59 = ***(void ***)a2;
        uint64_t v60 = *(void *)(v59 + 152);
        uint64_t v61 = *(unsigned int *)(v59 + 168);
        if (v61)
        {
          LODWORD(v62) = (v61 - 1) & ((a2 >> 4) ^ (a2 >> 9));
          uint64_t v63 = v60 + 16 * v62;
          uint64_t v64 = *(llvm::Instruction **)v63;
          if (*(llvm::Instruction **)v63 == a2)
          {
LABEL_66:
            uint64_t v67 = *(void **)(v63 + 8);
            unint64_t v70 = *v67;
            int v68 = v67 + 2;
            unint64_t v69 = v70;
            if (v70 >= 5 && *(_DWORD *)v68 == *(_DWORD *)"llvm." && v68[4] == aLlvm_1[4])
            {
              *((_DWORD *)a2 + 8) |= 0x2000u;
              int v72 = llvm::Function::lookupIntrinsicID(v68, v69);
LABEL_73:
              *((_DWORD *)a2 + 9) = v72;
LABEL_43:
              int v54 = (unsigned __int8 **)((char *)a2 + 48);
              int v53 = (unsigned __int8 *)*((void *)a2 + 6);
              unsigned int v73 = v53;
              if (v53) {
                llvm::MetadataTracking::track((uint64_t)&v73, v53, 2);
              }
              if (&v73 == v54)
              {
                if (v73) {
                  llvm::MetadataTracking::untrack((uint64_t)&v73, v73);
                }
              }
              else
              {
                if (*v54) {
                  llvm::MetadataTracking::untrack((uint64_t)a2 + 48, *v54);
                }
                unsigned int v55 = v73;
                void *v54 = v73;
                if (v55)
                {
                  llvm::MetadataTracking::retrack((uint64_t)&v73, v55, (uint64_t)a2 + 48);
                  unsigned int v73 = 0;
                }
              }
              llvm::InstructionPrecedenceTracking::insertInstructionTo(this[13], a2, a3);
              unsigned int v56 = llvm::GVNPass::ValueTable::lookupOrAdd((llvm::GVNPass::ValueTable *)(this + 16), a2);
              llvm::GVNPass::ValueTable::add((llvm::GVNPass::ValueTable *)(this + 16), a2, v56);
              sub_1CCD61790((uint64_t)this, v56, (uint64_t)a2, (uint64_t)a3);
              return 1;
            }
LABEL_74:
            int v72 = 0;
            *((_DWORD *)a2 + 8) &= ~0x2000u;
            goto LABEL_73;
          }
          int v65 = 1;
          while (v64 != (llvm::Instruction *)-4096)
          {
            int v66 = v62 + v65++;
            uint64_t v62 = v66 & (v61 - 1);
            uint64_t v64 = *(llvm::Instruction **)(v60 + 16 * v62);
            if (v64 == a2)
            {
              uint64_t v63 = v60 + 16 * v62;
              goto LABEL_66;
            }
          }
        }
        uint64_t v63 = v60 + 16 * v61;
        goto LABEL_66;
      }
      int v47 = 1;
      while (v46 != (llvm::Instruction *)-4096)
      {
        int v48 = v44 + v47++;
        uint64_t v44 = v48 & (v43 - 1);
        unsigned int v46 = *(llvm::Instruction **)(v42 + 16 * v44);
        if (v46 == a2)
        {
          uint64_t v45 = v42 + 16 * v44;
          goto LABEL_40;
        }
      }
    }
    uint64_t v45 = v42 + 16 * v43;
    goto LABEL_40;
  }
  uint64_t v10 = 0;
  while (1)
  {
    int v11 = *((_DWORD *)a2 + 5);
    uint64_t v12 = (v11 & 0x40000000) != 0
        ? (llvm::Instruction *)*((void *)a2 - 1)
        : (llvm::Instruction *)((char *)a2 - 32 * (v11 & 0x7FFFFFF));
    uint64_t v13 = *((void *)v12 + 4 * v10);
    if (*(unsigned __int8 *)(v13 + 16) >= 0x16u) {
      break;
    }
LABEL_24:
    if (++v10 == v8) {
      goto LABEL_25;
    }
  }
  uint64_t v14 = *((unsigned int *)this + 36);
  if (!v14) {
    return 0;
  }
  uint64_t v15 = this[16];
  unsigned int v16 = v14 - 1;
  LODWORD(v17) = (v14 - 1) & ((v13 >> 4) ^ (v13 >> 9));
  uint64_t v18 = (char *)v15 + 16 * v17;
  uint64_t v19 = *(void *)v18;
  if (v13 == *(void *)v18)
  {
LABEL_15:
    int v26 = llvm::GVNPass::ValueTable::phiTranslate((llvm::GVNPass::ValueTable *)(this + 16), a3, a4, *((unsigned int *)v18 + 2), (llvm::GVNPass *)this);
    uint64_t result = llvm::GVNPass::findLeader((llvm::GVNPass *)this, a3, v26);
    if (!result) {
      return result;
    }
    int v28 = *((_DWORD *)a2 + 5);
    if ((v28 & 0x40000000) != 0) {
      unsigned int v29 = (char *)*((void *)a2 - 1);
    }
    else {
      unsigned int v29 = (char *)a2 - 32 * (v28 & 0x7FFFFFF);
    }
    BOOL v30 = &v29[32 * v10];
    if (*(void *)v30)
    {
      **((void **)v30 + 2) = *((void *)v30 + 1);
      uint64_t v31 = *((void *)v30 + 1);
      if (v31) {
        *(void *)(v31 + 16) = *((void *)v30 + 2);
      }
    }
    *(void *)BOOL v30 = result;
    uint64_t v34 = *(void *)(result + 8);
    unsigned int v32 = (char **)(result + 8);
    uint64_t v33 = v34;
    *((void *)v30 + 1) = v34;
    if (v34) {
      *(void *)(v33 + 16) = v30 + 8;
    }
    *(void *)&v29[32 * v10 + 16] = v32;
    uint64_t *v32 = v30;
    goto LABEL_24;
  }
  int v20 = 1;
  uint64_t v21 = *(void *)v18;
  unsigned int v22 = v16 & ((v13 >> 4) ^ (v13 >> 9));
  while (v21 != -4096)
  {
    unsigned int v23 = v22 + v20++;
    unsigned int v22 = v23 & v16;
    uint64_t v21 = *((void *)v15 + 2 * v22);
    if (v13 == v21)
    {
      int v24 = 1;
      while (v19 != -4096)
      {
        int v25 = v17 + v24++;
        uint64_t v17 = v25 & v16;
        uint64_t v19 = *((void *)v15 + 2 * v17);
        if (v13 == v19)
        {
          uint64_t v18 = (char *)v15 + 16 * v17;
          goto LABEL_15;
        }
      }
      uint64_t v18 = (char *)v15 + 16 * v14;
      goto LABEL_15;
    }
  }
  return 0;
}

uint64_t llvm::GVNPass::splitCriticalEdges(llvm::GVNPass *this)
{
  unsigned int v1 = *((_DWORD *)this + 176);
  if (!v1) {
    return 0;
  }
  char v4 = 0;
  do
  {
    uint64_t v5 = *((void *)this + 87) + 16 * v1;
    int v6 = *(llvm::Instruction **)(v5 - 16);
    unsigned int v7 = *(_DWORD *)(v5 - 8);
    *((_DWORD *)this + 176) = v1 - 1;
    v10[0] = *((void *)this + 3);
    v10[1] = 0;
    long long v11 = *((_OWORD *)this + 7);
    int v12 = 0;
    char v13 = 1;
    void v9[16] = 257;
    v4 |= llvm::SplitCriticalEdge(v6, v7, (uint64_t)v10, (llvm::Twine *)v9) != 0;
    unsigned int v1 = *((_DWORD *)this + 176);
  }
  while (v1);
  if ((v4 & 1) == 0) {
    return 0;
  }
  uint64_t v8 = (llvm::MemoryDependenceResults *)*((void *)this + 2);
  if (v8) {
    llvm::MemoryDependenceResults::invalidateCachedPredecessors(v8);
  }
  uint64_t result = 1;
  *((unsigned char *)this + 688) = 1;
  return result;
}

uint64_t sub_1CCD62FD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 == a1 + 40)
  {
LABEL_20:
    uint64_t v5 = 0;
  }
  else
  {
    if (v3) {
      uint64_t v4 = v3 - 24;
    }
    else {
      uint64_t v4 = 0;
    }
    if (*(unsigned __int8 *)(v4 + 16) - 29 >= 0xB) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v4;
    }
  }
  unsigned int v6 = 0;
  uint64_t v7 = v5 - 32;
  unsigned int v8 = 1;
  do
  {
    if (*(unsigned char *)(v5 + 16) == 30)
    {
      unsigned int v9 = (uint64_t *)(v7 - 32 * v6);
    }
    else
    {
      unsigned int v9 = (uint64_t *)(v5 - 32);
      switch(*(unsigned char *)(v5 + 16))
      {
        case ' ':
        case '&':
          int v15 = *(_DWORD *)(v5 + 20);
          if ((v15 & 0x40000000) != 0) {
            uint64_t v13 = *(void *)(v5 - 8);
          }
          else {
            uint64_t v13 = v5 - 32 * (v15 & 0x7FFFFFF);
          }
          uint64_t v14 = v6 + 1;
          goto LABEL_18;
        case '!':
          uint64_t v16 = -64;
          if (!v6) {
            uint64_t v16 = -96;
          }
          unsigned int v9 = (uint64_t *)(v5 + v16);
          break;
        case '""':
        case '#':
          __break(1u);
          goto LABEL_20;
        case '$':
          if ((*(_WORD *)(v5 + 18) & 1) == 0)
          {
            uint64_t v10 = 0;
            goto LABEL_12;
          }
          unsigned int v9 = (uint64_t *)(v5 - 32 * (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) + 32);
          break;
        case '%':
          break;
        case '\'':
          unsigned int v9 = (uint64_t *)(v5 - 32 * *(unsigned int *)(v5 + 80) - 64);
          if (v6) {
            unsigned int v9 = (uint64_t *)(v7 - 32 * *(unsigned int *)(v5 + 80) + 32 * (v6 - 1));
          }
          break;
        default:
          int v12 = *(_DWORD *)(v5 + 20);
          if ((v12 & 0x40000000) != 0) {
            uint64_t v13 = *(void *)(v5 - 8);
          }
          else {
            uint64_t v13 = v5 - 32 * (v12 & 0x7FFFFFF);
          }
          uint64_t v14 = v8;
LABEL_18:
          unsigned int v9 = (uint64_t *)(v13 + 32 * v14);
          break;
      }
    }
    uint64_t v10 = *v9;
LABEL_12:
    ++v6;
    v8 += 2;
  }
  while (v10 != a2);
  __int16 v18 = 257;
  return llvm::SplitCriticalEdge((llvm::Instruction *)v5, v6 - 1, a3, (llvm::Twine *)v17);
}

uint64_t llvm::GVNPass::verifyRemoved(uint64_t this, const llvm::Instruction *a2)
{
  uint64_t v2 = *(void *)(this + 312);
  uint64_t v3 = *(unsigned int *)(this + 328);
  uint64_t v4 = (_DWORD *)(v2 + 32 * v3);
  if (*(_DWORD *)(this + 320))
  {
    if (v3)
    {
      uint64_t v5 = 32 * v3;
      unsigned int v6 = *(_DWORD **)(this + 312);
      while (*v6 >= 0xFFFFFFFE)
      {
        v6 += 8;
        v5 -= 32;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      unsigned int v6 = *(_DWORD **)(this + 312);
    }
  }
  else
  {
LABEL_6:
    unsigned int v6 = (_DWORD *)(v2 + 32 * v3);
  }
  uint64_t v7 = (_DWORD *)(v2 + 32 * v3);
  while (v6 != v7)
  {
    do
    {
      unsigned int v8 = v6 + 8;
      unsigned int v6 = v4;
      if (v8 == v4) {
        break;
      }
      unsigned int v6 = v8;
    }
    while (*v8 > 0xFFFFFFFD);
  }
  return this;
}

void llvm::GVNPass::addDeadBlock(llvm::MemoryDependenceResults **this, llvm::BasicBlock *a2)
{
  v62[4] = *MEMORY[0x1E4F143B8];
  uint64_t v59 = v62;
  int v61 = 4;
  uint64_t v53 = 1;
  int64x2_t v54 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v55 = v54;
  unsigned int v56 = v58;
  uint64_t v57 = 0x400000000;
  v62[0] = a2;
  uint64_t v2 = (uint64_t *)(this + 6);
  unsigned int v3 = 1;
  do
  {
    uint64_t v4 = (void *)v59[v3 - 1];
    unsigned int v60 = v3 - 1;
    int v50 = v4;
    v49[0] = 0;
    if ((sub_1CBFFBBB4(v2, &v50, v49) & 1) == 0)
    {
      int v50 = v52;
      uint64_t v51 = 0x800000000;
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::getDescendants();
    }
    unsigned int v3 = v60;
  }
  while (v60);
  uint64_t v5 = (void **)v56;
  if (v57)
  {
    unsigned int v6 = (void **)((char *)v56 + 8 * v57);
    do
    {
      uint64_t v7 = (llvm::BasicBlock *)*v5;
      int v50 = *v5;
      v49[0] = 0;
      if ((sub_1CBFFBBB4(v2, &v50, v49) & 1) == 0)
      {
        for (uint64_t i = *((void *)v7 + 1); i; uint64_t i = *(void *)(i + 8))
        {
          uint64_t v9 = *(void *)(i + 24);
          unsigned int v10 = *(unsigned __int8 *)(v9 + 16);
          if (v9) {
            BOOL v11 = v10 >= 0x1C;
          }
          else {
            BOOL v11 = 0;
          }
          if (v11 && v10 - 29 < 0xB) {
            break;
          }
        }
        int v50 = v52;
        uint64_t v51 = 0x400000000;
        sub_1CBF846A4((uint64_t)&v50, i, 0);
        if (v51)
        {
          uint64_t v13 = (llvm::BasicBlock **)v50;
          uint64_t v14 = (llvm::BasicBlock **)((char *)v50 + 8 * v51);
          do
          {
            int v47 = 0;
            int v47 = *v13;
            uint64_t v48 = 0;
            v49[0] = v47;
            if (sub_1CBFFBBB4(v2, v49, &v48))
            {
              int v15 = (llvm::BasicBlock *)*((void *)v47 + 5);
              if (v15 != (llvm::BasicBlock *)((char *)v47 + 40))
              {
                if (v15) {
                  uint64_t v16 = (uint64_t)v15 - 24;
                }
                else {
                  uint64_t v16 = 0;
                }
                int v17 = *(unsigned __int8 *)(v16 + 16);
                if (v17 != 30)
                {
                  int v29 = 2;
                  switch(*(unsigned char *)(v16 + 16))
                  {
                    case 0x1E:
LABEL_112:
                      __break(1u);
                      JUMPOUT(0x1CCD63BE8);
                    case 0x1F:
                      int v29 = (*(_DWORD *)(v16 + 20) >> 1) & 0x3FFFFFF;
                      goto LABEL_63;
                    case 0x20:
                    case 0x26:
                      int v29 = (*(_DWORD *)(v16 + 20) & 0x7FFFFFF) - 1;
                      goto LABEL_63;
                    case 0x21:
                      goto LABEL_31;
                    case 0x24:
                      int v29 = *(_WORD *)(v16 + 18) & 1;
                      goto LABEL_63;
                    case 0x25:
                      int v29 = 1;
                      goto LABEL_31;
                    case 0x27:
                      int v29 = *(_DWORD *)(v16 + 80) + 1;
LABEL_63:
                      if (!v29) {
                        goto LABEL_59;
                      }
                      goto LABEL_31;
                    default:
                      goto LABEL_59;
                  }
                }
                if ((*(_DWORD *)(v16 + 20) & 0x7FFFFFF) == 3) {
                  int v29 = 2;
                }
                else {
                  int v29 = 1;
                }
LABEL_31:
                uint64_t v18 = 0;
                uint64_t v19 = (llvm::BasicBlock **)(v16 - 32);
                while (1)
                {
                  int v20 = v19;
                  if (v17 != 30)
                  {
                    int v20 = (llvm::BasicBlock **)(v16 - 32);
                    switch(*(unsigned char *)(v16 + 16))
                    {
                      case ' ':
                      case '&':
                        int v25 = *(_DWORD *)(v16 + 20);
                        if ((v25 & 0x40000000) != 0) {
                          uint64_t v26 = *(void *)(v16 - 8);
                        }
                        else {
                          uint64_t v26 = v16 - 32 * (v25 & 0x7FFFFFF);
                        }
                        uint64_t v24 = v26 + 32 * v18;
                        goto LABEL_43;
                      case '!':
                        uint64_t v27 = -64;
                        if (!v18) {
                          uint64_t v27 = -96;
                        }
                        int v20 = (llvm::BasicBlock **)(v16 + v27);
                        break;
                      case '""':
                      case '#':
                        goto LABEL_112;
                      case '$':
                        if ((*(_WORD *)(v16 + 18) & 1) == 0)
                        {
                          uint64_t v21 = 0;
                          goto LABEL_35;
                        }
                        int v20 = (llvm::BasicBlock **)(v16 + 32 - 32 * (*(_DWORD *)(v16 + 20) & 0x7FFFFFF));
                        break;
                      case '%':
                        break;
                      case '\'':
                        if (v18) {
                          int v20 = (llvm::BasicBlock **)(v16
                        }
                                                    - 32
                                                    - 32 * *(unsigned int *)(v16 + 80)
                                                    + 32 * (v18 - 1));
                        else {
                          int v20 = (llvm::BasicBlock **)(v16 - 64 - 32 * *(unsigned int *)(v16 + 80));
                        }
                        break;
                      default:
                        int v22 = *(_DWORD *)(v16 + 20);
                        if ((v22 & 0x40000000) != 0) {
                          uint64_t v23 = *(void *)(v16 - 8);
                        }
                        else {
                          uint64_t v23 = v16 - 32 * (v22 & 0x7FFFFFF);
                        }
                        uint64_t v24 = v23 + (v18 << 6);
LABEL_43:
                        int v20 = (llvm::BasicBlock **)(v24 + 32);
                        break;
                    }
                  }
                  uint64_t v21 = *v20;
LABEL_35:
                  if (v21 == v7) {
                    break;
                  }
                  ++v18;
                  v19 -= 4;
                  if (v29 == v18) {
                    goto LABEL_59;
                  }
                }
                if (llvm::isCriticalEdge(v16, (uint64_t)v7, 0))
                {
                  BOOL v30 = (llvm::BasicBlock *)llvm::GVNPass::splitCriticalEdges((llvm::GVNPass *)this, v47, v7);
                  if (v30)
                  {
                    int v47 = v30;
                    sub_1CBB239A4((uint64_t)v2, &v47);
                  }
                }
              }
            }
LABEL_59:
            ++v13;
          }
          while (v13 != v14);
        }
        uint64_t v31 = *((void *)v7 + 1);
        if (v31)
        {
          while (1)
          {
            uint64_t v32 = *(void *)(v31 + 24);
            unsigned int v33 = *(unsigned __int8 *)(v32 + 16);
            BOOL v34 = v32 && v33 >= 0x1C;
            if (v34 && v33 - 29 <= 0xA) {
              break;
            }
            uint64_t v31 = *(void *)(v31 + 8);
            if (!v31) {
              goto LABEL_81;
            }
          }
LABEL_85:
          uint64_t v36 = *(void *)(v32 + 40);
          uint64_t v48 = 0;
          v49[0] = v36;
          if (sub_1CBFFBBB4(v2, v49, &v48)
            && *((llvm::BasicBlock **)v7 + 5) != (llvm::BasicBlock *)((char *)v7 + 40))
          {
            for (uint64_t j = *((void *)v7 + 6); ; uint64_t j = *(void *)(v39 + 32))
            {
              uint64_t v39 = j - 24;
              uint64_t v40 = j ? j - 24 : 0;
              if (!j || *(unsigned char *)(v40 + 16) != 83) {
                break;
              }
              uint64_t v41 = llvm::PoisonValue::get(*(llvm::PoisonValue **)v39, v37);
              sub_1CC45E7A4(v39, v36, (uint64_t)v41);
              uint64_t v42 = this[2];
              if (v42) {
                llvm::MemoryDependenceResults::invalidateCachedPointerInfo(v42, (llvm::Value *)v39);
              }
            }
          }
          while (1)
          {
            uint64_t v31 = *(void *)(v31 + 8);
            if (!v31) {
              break;
            }
            uint64_t v32 = *(void *)(v31 + 24);
            unsigned int v43 = *(unsigned __int8 *)(v32 + 16);
            if (v32) {
              BOOL v44 = v43 >= 0x1C;
            }
            else {
              BOOL v44 = 0;
            }
            if (v44 && v43 - 29 < 0xB) {
              goto LABEL_85;
            }
          }
        }
LABEL_81:
        if (v50 != v52) {
          free(v50);
        }
      }
      ++v5;
    }
    while (v5 != v6);
    uint64_t v5 = (void **)v56;
  }
  if (v5 != (void **)v58) {
    free(v5);
  }
  if ((v53 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v54.i64[0], 8);
  }
  if (v59 != v62) {
    free(v59);
  }
}

void sub_1CCD63C88(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeMemoryDependenceWrapperPassPass(a1, v2);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v3);
  llvm::initializeGlobalsAAWrapperPassPass(a1, v4);
  llvm::initializeOptimizationRemarkEmitterWrapperPassPass(a1, v5);
  operator new();
}

uint64_t sub_1CCD63D58(llvm::Value *a1, llvm::Instruction *a2, uint64_t a3, llvm::DominatorTree *this)
{
  uint64_t v4 = *((void *)a2 + 5);
  if (*((void *)a1 + 5) == v4)
  {
    return llvm::DominatorTree::dominates(this, a1, a2);
  }
  else
  {
    uint64_t v7 = &v11;
    unsigned int v8 = &v11;
    int v10 = 0;
    uint64_t v9 = 0x100000001;
    uint64_t v11 = v4;
    uint64_t v5 = llvm::isPotentiallyReachable((uint64_t)a1, a3, (uint64_t *)&v7, (uint64_t)this, 0) ^ 1;
    if (v8 != v7) {
      free(v8);
    }
    return v5;
  }
}

void *sub_1CCD63E04(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CCD63EBC(a1, v6);
  unsigned int v8 = 0;
  sub_1CBF8BDAC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CCD63EBC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (v12)
    {
      uint64_t v13 = 16 * v12;
      do
      {
        void *result = -4096;
        result += 2;
        v13 -= 16;
      }
      while (v13);
    }
    if (v3)
    {
      uint64_t v14 = 16 * v3;
      uint64_t v15 = v4;
      do
      {
        uint64_t v16 = *(void *)v15;
        if ((*(void *)v15 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v18 = 0;
          sub_1CBF8BDAC(*(void *)a1, *(_DWORD *)(a1 + 16), v16, &v18);
          int v17 = v18;
          void *v18 = *(void *)v15;
          *((unsigned char *)v17 + 8) = *(unsigned char *)(v15 + 8);
          ++*(_DWORD *)(a1 + 8);
        }
        v15 += 16;
        v14 -= 16;
      }
      while (v14);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CCD64000(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = a1;
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = (37 * *a2) & (v3 - 1);
    uint64_t result = *(void *)a1 + 32 * v4;
    int v6 = *(_DWORD *)result;
    if (*a2 == *(_DWORD *)result) {
      return result;
    }
    uint64_t v7 = 0;
    int v8 = 1;
    while (v6 != -1)
    {
      if (v7) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = v6 == -2;
      }
      if (v10) {
        uint64_t v7 = result;
      }
      int v11 = v4 + v8++;
      uint64_t v4 = v11 & (v3 - 1);
      uint64_t result = *(void *)v2 + 32 * v4;
      int v6 = *(_DWORD *)result;
      if (*a2 == *(_DWORD *)result) {
        return result;
      }
    }
    if (v7) {
      uint64_t result = v7;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  int v9 = *(_DWORD *)(v2 + 8);
  if (4 * v9 + 4 >= 3 * v3)
  {
    uint64_t v12 = a2;
    uint64_t v30 = v2;
    sub_1CCD6426C((uint64_t *)v2, 2 * v3);
    uint64_t v2 = v30;
    int v13 = *(_DWORD *)(v30 + 16);
    if (v13)
    {
      a2 = v12;
      unsigned int v14 = v13 - 1;
      uint64_t v15 = (37 * *v12) & v14;
      uint64_t result = *(void *)v30 + 32 * v15;
      int v16 = *(_DWORD *)result;
      if (*v12 != *(_DWORD *)result)
      {
        uint64_t v17 = 0;
        int v18 = 1;
        while (v16 != -1)
        {
          if (v17) {
            BOOL v24 = 0;
          }
          else {
            BOOL v24 = v16 == -2;
          }
          if (v24) {
            uint64_t v17 = result;
          }
          int v25 = v15 + v18++;
          uint64_t v15 = v25 & v14;
          uint64_t result = *(void *)v30 + 32 * v15;
          int v16 = *(_DWORD *)result;
          if (*v12 == *(_DWORD *)result) {
            goto LABEL_10;
          }
        }
        if (v17) {
          uint64_t result = v17;
        }
      }
    }
    else
    {
      uint64_t result = 0;
      a2 = v12;
    }
  }
  else if (v3 + ~v9 - *(_DWORD *)(v2 + 12) <= v3 >> 3)
  {
    uint64_t v31 = a2;
    uint64_t v19 = v2;
    sub_1CCD6426C((uint64_t *)v2, v3);
    int v20 = *(_DWORD *)(v19 + 16);
    if (v20)
    {
      unsigned int v21 = v20 - 1;
      uint64_t v22 = (37 * *v31) & (v20 - 1);
      uint64_t result = *(void *)v19 + 32 * v22;
      int v23 = *(_DWORD *)result;
      if (*v31 != *(_DWORD *)result)
      {
        uint64_t v26 = 0;
        int v27 = 1;
        a2 = v31;
        while (v23 != -1)
        {
          if (v26) {
            BOOL v28 = 0;
          }
          else {
            BOOL v28 = v23 == -2;
          }
          if (v28) {
            uint64_t v26 = result;
          }
          int v29 = v22 + v27++;
          uint64_t v22 = v29 & v21;
          uint64_t result = *(void *)v19 + 32 * v22;
          int v23 = *(_DWORD *)result;
          uint64_t v2 = v19;
          if (*v31 == *(_DWORD *)result) {
            goto LABEL_10;
          }
        }
        if (v26) {
          uint64_t result = v26;
        }
      }
    }
    else
    {
      uint64_t result = 0;
    }
    a2 = v31;
    uint64_t v2 = v19;
  }
LABEL_10:
  ++*(_DWORD *)(v2 + 8);
  if (*(_DWORD *)result != -1) {
    --*(_DWORD *)(v2 + 12);
  }
  *(_DWORD *)uint64_t result = *a2;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 8) = 0;
  return result;
}

_DWORD *sub_1CCD6426C(uint64_t *a1, int a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 4);
  uint64_t v4 = (int *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v10 = *((unsigned int *)a1 + 4);
    if (v10)
    {
      uint64_t v11 = 32 * v10;
      do
      {
        _DWORD *result = -1;
        result += 8;
        v11 -= 32;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = v4;
      do
      {
        int v13 = *v12;
        if (*v12 <= 0xFFFFFFFD)
        {
          int v14 = *((_DWORD *)a1 + 4);
          if (v14)
          {
            unsigned int v15 = v14 - 1;
            uint64_t v16 = (v14 - 1) & (37 * v13);
            uint64_t v17 = *a1 + 32 * v16;
            int v18 = *(_DWORD *)v17;
            if (v13 != *(_DWORD *)v17)
            {
              uint64_t v22 = 0;
              int v23 = 1;
              while (v18 != -1)
              {
                if (v22) {
                  BOOL v24 = 0;
                }
                else {
                  BOOL v24 = v18 == -2;
                }
                if (v24) {
                  uint64_t v22 = v17;
                }
                int v25 = v16 + v23++;
                uint64_t v16 = v25 & v15;
                uint64_t v17 = *a1 + 32 * v16;
                int v18 = *(_DWORD *)v17;
                if (v13 == *(_DWORD *)v17) {
                  goto LABEL_13;
                }
              }
              if (v22) {
                uint64_t v17 = v22;
              }
            }
          }
          else
          {
            uint64_t v17 = 0;
          }
LABEL_13:
          *(_DWORD *)uint64_t v17 = v13;
          long long v19 = *(_OWORD *)(v12 + 2);
          *(void *)(v17 + 24) = *((void *)v12 + 3);
          *(_OWORD *)(v17 + 8) = v19;
          ++*((_DWORD *)a1 + 2);
        }
        v12 += 8;
      }
      while (v12 != &v4[8 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v20 = *((unsigned int *)a1 + 4);
  if (v20)
  {
    uint64_t v21 = 32 * v20;
    do
    {
      _DWORD *result = -1;
      result += 8;
      v21 -= 32;
    }
    while (v21);
  }
  return result;
}

void sub_1CCD64410(uint64_t a1)
{
  _OWORD v15[2] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  LODWORD(v12) = -1;
  BYTE4(v12) = 0;
  unsigned int v1 = v15;
  *((void *)&v12 + 1) = 0;
  int v13 = v15;
  uint64_t v2 = 0x400000000;
  uint64_t v14 = 0x400000000;
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (v3)
  {
    uint64_t v4 = &v13;
    uint64_t v5 = 56 * v3;
    unint64_t v6 = (void *)(*(void *)a1 + 16);
    do
    {
      *((_OWORD *)v6 - 1) = v12;
      *unint64_t v6 = v6 + 2;
      v6[1] = v2;
      if (v14)
      {
        uint64_t v10 = v4;
        uint64_t v11 = v6;
        uint64_t v8 = v5;
        int v9 = v1;
        uint64_t v7 = v2;
        sub_1CC077ABC((uint64_t)v6, (uint64_t)v4);
        uint64_t v5 = v8;
        unsigned int v1 = v9;
        uint64_t v2 = v7;
        uint64_t v4 = v10;
        unint64_t v6 = v11;
      }
      v6 += 7;
      v5 -= 56;
    }
    while (v5);
    if (v13 != v1) {
      free(v13);
    }
  }
}

_DWORD *sub_1CCD64500(_DWORD *result, int a2)
{
  uint64_t v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(24 * v4, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 24 * v5;
      do
      {
        *(_OWORD *)uint64_t result = xmmword_1CFB1B6D0;
        result += 6;
        v6 -= 24;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

void sub_1CCD645A0(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 56 * v1;
    uint64_t v3 = *(void *)a1 + 32;
    do
    {
      unint64_t v4 = *(void **)(v3 - 16);
      if ((void *)v3 != v4) {
        free(v4);
      }
      v3 += 56;
      v2 -= 56;
    }
    while (v2);
  }
}

void sub_1CCD6469C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 16;
      do
      {
        uint64_t v7 = (char *)*((void *)v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
        uint64_t v8 = v6 - 32;
        v6 -= 48;
      }
      while (v8 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *sub_1CCD64730(uint64_t a1, char **a2)
{
  sub_1CCD645A0(a1);
  uint64_t result = (char *)MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  uint64_t v5 = *((unsigned int *)a2 + 4);
  *(_DWORD *)(a1 + 16) = v5;
  if (v5)
  {
    uint64_t result = (char *)operator new(56 * v5, (std::align_val_t)8uLL);
    *(void *)a1 = result;
    *(void *)(a1 + 8) = a2[1];
    if (*(_DWORD *)(a1 + 16))
    {
      unint64_t v6 = 0;
      uint64_t v7 = 48;
      do
      {
        uint64_t v8 = &result[v7];
        int v9 = *a2;
        uint64_t v10 = (uint64_t)&(*a2)[v7];
        *((_OWORD *)v8 - 3) = *(_OWORD *)(v10 - 48);
        uint64_t v11 = &result[v7 - 16];
        *(void *)&result[v7 - 32] = v11;
        *((void *)v8 - 3) = 0x400000000;
        unsigned int v12 = *(_DWORD *)(v10 - 24);
        if (v12) {
          BOOL v13 = result == v9;
        }
        else {
          BOOL v13 = 1;
        }
        if (!v13)
        {
          if (v12 >= 5) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v11, *(const void **)(v10 - 32), 4 * *(unsigned int *)(v10 - 24));
          *((_DWORD *)v8 - 6) = v12;
        }
        uint64_t result = *(char **)a1;
        if (*(_DWORD *)(*(void *)a1 + v7 - 48) <= 0xFFFFFFFD) {
          *(_DWORD *)&result[v7] = *(_DWORD *)&(*a2)[v7];
        }
        ++v6;
        v7 += 56;
      }
      while (v6 < *(unsigned int *)(a1 + 16));
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

char *sub_1CCD64878(char **a1, uint64_t a2)
{
  uint64_t result = (char *)MEMORY[0x1D25D9CD0](*a1, 8);
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  *((_DWORD *)a1 + 4) = v5;
  if (v5)
  {
    uint64_t result = (char *)operator new(24 * v5, (std::align_val_t)8uLL);
    *a1 = result;
    a1[1] = *(char **)(a2 + 8);
    if (*((_DWORD *)a1 + 4))
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      do
      {
        *(_OWORD *)&result[v6] = *(_OWORD *)(*(void *)a2 + v6);
        uint64_t result = *a1;
        uint64_t v8 = &(*a1)[v6];
        int v9 = *(_DWORD *)v8;
        uint64_t v10 = *((void *)v8 + 1);
        if ((v9 != -1 || v10 != -4096) && (v9 != -2 || v10 != -8192)) {
          *(_DWORD *)&result[v6 + 16] = *(_DWORD *)(*(void *)a2 + v6 + 16);
        }
        ++v7;
        v6 += 24;
      }
      while (v7 < *((unsigned int *)a1 + 4));
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

uint64_t sub_1CCD6494C(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    unsigned int v5 = (37 * *a2) & (v4 - 1);
    uint64_t result = *(void *)a1 + 16 * v5;
    int v7 = *(_DWORD *)result;
    if (*a2 == *(_DWORD *)result) {
      return result;
    }
    uint64_t v8 = 0;
    int v9 = 1;
    while (v7 != -1)
    {
      if (v8) {
        BOOL v10 = 0;
      }
      else {
        BOOL v10 = v7 == -2;
      }
      if (v10) {
        uint64_t v8 = result;
      }
      unsigned int v11 = v5 + v9++;
      unsigned int v5 = v11 & (v4 - 1);
      uint64_t result = *(void *)a1 + 16 * v5;
      int v7 = *(_DWORD *)result;
      if (*a2 == *(_DWORD *)result) {
        return result;
      }
    }
    if (v8) {
      uint64_t result = v8;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  int v12 = *(_DWORD *)(a1 + 8);
  if (4 * v12 + 4 >= 3 * v4)
  {
    sub_1CCD64B5C((uint64_t *)a1, 2 * v4);
    int v13 = *(_DWORD *)(a1 + 16);
    if (v13)
    {
      int v14 = v13 - 1;
      unsigned int v15 = (37 * *a2) & v14;
      uint64_t result = *(void *)a1 + 16 * v15;
      int v16 = *(_DWORD *)result;
      if (*a2 == *(_DWORD *)result) {
        goto LABEL_16;
      }
      uint64_t v17 = 0;
      int v18 = 1;
      while (v16 != -1)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == -2;
        }
        if (v19) {
          uint64_t v17 = result;
        }
        unsigned int v20 = v15 + v18++;
        unsigned int v15 = v20 & v14;
        uint64_t result = *(void *)a1 + 16 * v15;
        int v16 = *(_DWORD *)result;
        if (*a2 == *(_DWORD *)result) {
          goto LABEL_16;
        }
      }
LABEL_24:
      if (v17) {
        uint64_t result = v17;
      }
      goto LABEL_16;
    }
LABEL_46:
    uint64_t result = 0;
    goto LABEL_16;
  }
  if (v4 + ~v12 - *(_DWORD *)(a1 + 12) <= v4 >> 3)
  {
    sub_1CCD64B5C((uint64_t *)a1, v4);
    int v21 = *(_DWORD *)(a1 + 16);
    if (v21)
    {
      int v22 = v21 - 1;
      unsigned int v23 = (37 * *a2) & v22;
      uint64_t result = *(void *)a1 + 16 * v23;
      int v24 = *(_DWORD *)result;
      if (*a2 == *(_DWORD *)result) {
        goto LABEL_16;
      }
      uint64_t v17 = 0;
      int v25 = 1;
      while (v24 != -1)
      {
        if (v17) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v24 == -2;
        }
        if (v26) {
          uint64_t v17 = result;
        }
        unsigned int v27 = v23 + v25++;
        unsigned int v23 = v27 & v22;
        uint64_t result = *(void *)a1 + 16 * v23;
        int v24 = *(_DWORD *)result;
        if (*a2 == *(_DWORD *)result) {
          goto LABEL_16;
        }
      }
      goto LABEL_24;
    }
    goto LABEL_46;
  }
LABEL_16:
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)result != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  *(_DWORD *)uint64_t result = *a2;
  *(void *)(result + 8) = 0;
  return result;
}

_DWORD *sub_1CCD64B5C(uint64_t *a1, int a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 4);
  unsigned int v4 = (int *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *a1 = (uint64_t)result;
  if (v4)
  {
    a1[1] = 0;
    uint64_t v10 = *((unsigned int *)a1 + 4);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        _DWORD *result = -1;
        result += 4;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = v4;
      do
      {
        int v13 = *v12;
        if (*v12 <= 0xFFFFFFFD)
        {
          int v14 = *((_DWORD *)a1 + 4) - 1;
          unsigned int v15 = v14 & (37 * v13);
          uint64_t v16 = *a1 + 16 * v15;
          int v17 = *(_DWORD *)v16;
          if (v13 != *(_DWORD *)v16)
          {
            uint64_t v18 = 0;
            int v19 = 1;
            while (v17 != -1)
            {
              if (v18) {
                BOOL v20 = 0;
              }
              else {
                BOOL v20 = v17 == -2;
              }
              if (v20) {
                uint64_t v18 = v16;
              }
              unsigned int v21 = v15 + v19++;
              unsigned int v15 = v21 & v14;
              uint64_t v16 = *a1 + 16 * (v21 & v14);
              int v17 = *(_DWORD *)v16;
              if (v13 == *(_DWORD *)v16) {
                goto LABEL_16;
              }
            }
            if (v18) {
              uint64_t v16 = v18;
            }
          }
LABEL_16:
          *(_DWORD *)uint64_t v16 = v13;
          *(void *)(v16 + 8) = *((void *)v12 + 1);
          ++*((_DWORD *)a1 + 2);
        }
        v12 += 4;
      }
      while (v12 != &v4[4 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  a1[1] = 0;
  uint64_t v22 = *((unsigned int *)a1 + 4);
  if (v22)
  {
    uint64_t v23 = 16 * v22;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v23 -= 16;
    }
    while (v23);
  }
  return result;
}

_DWORD *sub_1CCD64CE8(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      unint64_t v6 = *(_OWORD **)result;
      uint64_t v7 = 24 * v2;
      do
      {
        *unint64_t v6 = xmmword_1CFB1B6D0;
        unint64_t v6 = (_OWORD *)((char *)v6 + 24);
        v7 -= 24;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CCD64500(v1, v5);
  }
  return result;
}

void *sub_1CCD64D9C(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBF8BDAC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CCD63E04(a1, a2, v7);
    *int v5 = *a2;
    *((unsigned char *)v5 + 8) = 0;
  }
  return v5;
}

uint64_t sub_1CCD64E08(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_9;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_17:
    uint64_t result = 1;
  }
  else
  {
    int v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        int v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_17;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_9:
  *a3 = v7;
  return result;
}

void *sub_1CCD64EB0(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CD765F40((uint64_t)a1, v7);
  int v9 = 0;
  sub_1CCD64E08((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

_DWORD *sub_1CCD64F74(uint64_t a1, uint64_t a2)
{
  unsigned int v13 = 0;
  char v4 = sub_1CCD65108(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v13);
  int v5 = v13;
  if (v4) {
    return v5;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_21;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_21:
    sub_1CCD65528(a1, v7);
    unsigned int v13 = 0;
    sub_1CCD65108(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v13);
    int v5 = v13;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*v5 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  *(_OWORD *)int v5 = *(_OWORD *)a2;
  if (v5 != (_DWORD *)a2)
  {
    uint64_t v8 = (void **)(v5 + 4);
    uint64_t v9 = *(unsigned int *)(a2 + 24);
    uint64_t v10 = v5[6];
    if (v10 >= v9)
    {
      if (v9) {
        memmove(*v8, *(const void **)(a2 + 16), 4 * v9);
      }
    }
    else
    {
      if (v5[7] < v9)
      {
        v5[6] = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v10) {
        memmove(*v8, *(const void **)(a2 + 16), 4 * v10);
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = *(unsigned int *)(a2 + 24);
      if (v10 != v11) {
        memcpy((char *)*v8 + 4 * v10, (const void *)(*(void *)(a2 + 16) + 4 * v10), 4 * v11 - 4 * v10);
      }
    }
    v5[6] = v9;
  }
  v5[12] = 0;
  return v5;
}

uint64_t sub_1CCD65108(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    unsigned int v45 = -1;
    char v46 = 0;
    uint64_t v47 = 0;
    __s2 = v50;
    uint64_t v49 = 0x400000000;
    unsigned int v39 = -2;
    char v40 = 0;
    uint64_t v41 = 0;
    uint64_t v42 = v44;
    unsigned int v7 = (uint64_t *)(a3 + 8);
    uint64_t v8 = *(void **)(a3 + 16);
    uint64_t v9 = (uint64_t)v8 + 4 * *(unsigned int *)(a3 + 24);
    uint64_t v43 = 0x400000000;
    unint64_t v38 = sub_1CC13A6B8(v8, v9);
    uint64_t v53 = 0;
    memset(v52, 0, sizeof(v52));
    memset(v51, 0, sizeof(v51));
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCBE588))
    {
      unint64_t v30 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v30 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v30;
      __cxa_guard_release(&qword_1EBCBE588);
    }
    uint64_t v54 = qword_1EBCBE580;
    LODWORD(v51[0]) = *(_DWORD *)a3;
    uint64_t v36 = v7;
    uint64_t v10 = 0;
    int v11 = a2 - 1;
    unsigned int v12 = (a2 - 1) & sub_1CCD65460((char *)v51, 0, (_OWORD *)((char *)v51 + 4), v52, v7, (uint64_t *)&v38);
    unsigned int v13 = *(_DWORD *)a3;
    int v14 = __s2;
    int v15 = 1;
    uint64_t v16 = v42;
    while (1)
    {
      uint64_t v17 = a1;
      uint64_t v18 = (int *)(a1 + 56 * v12);
      int v19 = *v18;
      if (v13 == *v18)
      {
        if (v13 > 0xFFFFFFFD
          || *v36 == *((void *)v18 + 1)
          && (uint64_t v24 = *(unsigned int *)(a3 + 24), v24 == v18[6])
          && (uint64_t v31 = v16,
              unsigned int v33 = v14,
              int v25 = memcmp(*(const void **)(a3 + 16), *((const void **)v18 + 2), 4 * v24),
              uint64_t v16 = v31,
              int v14 = v33,
              !v25))
        {
          uint64_t v23 = 1;
          goto LABEL_24;
        }
      }
      if (v19 == v45)
      {
        if (v45 > 0xFFFFFFFD) {
          break;
        }
        if (*((void *)v18 + 1) == v47 && v18[6] == v49)
        {
          uint64_t v32 = v16;
          BOOL v34 = v14;
          int v27 = memcmp(*((const void **)v18 + 2), v14, 4 * v49);
          uint64_t v16 = v32;
          int v14 = v34;
          if (!v27) {
            break;
          }
        }
      }
      BOOL v20 = v19 == v39;
      if (v39 <= 0xFFFFFFFD && v19 == v39)
      {
        a1 = v17;
        if (*((void *)v18 + 1) == v41 && v18[6] == v43)
        {
          uint64_t v35 = v14;
          BOOL v28 = v16;
          int v29 = memcmp(*((const void **)v18 + 2), v16, 4 * v43);
          uint64_t v16 = v28;
          int v14 = v35;
          BOOL v20 = v29 == 0;
        }
        else
        {
          BOOL v20 = 0;
        }
      }
      else
      {
        a1 = v17;
      }
      if (v20 && v10 == 0) {
        uint64_t v10 = v18;
      }
      unsigned int v22 = v12 + v15++;
      unsigned int v12 = v22 & v11;
    }
    uint64_t v23 = 0;
    if (v10) {
      uint64_t v18 = v10;
    }
LABEL_24:
    *a4 = v18;
    if (v16 != v44)
    {
      free(v16);
      int v14 = __s2;
    }
    if (v14 != v50) {
      free(v14);
    }
  }
  else
  {
    uint64_t v23 = 0;
    *a4 = 0;
  }
  return v23;
}

unint64_t sub_1CCD65460(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v15 = a2;
  uint64_t v9 = sub_1CC2E96A4(a1, &v15, a3, (unint64_t)a4, *a5);
  uint64_t v16 = v15;
  uint64_t v10 = (char *)sub_1CBFFCBA0(a1, &v16, v9, (unint64_t)a4, *a6);
  uint64_t v11 = v16;
  if (!v16) {
    return sub_1CBAE06B8(a1, v10 - a1, *((void *)a1 + 15));
  }
  int v14 = v10;
  if (v10 != a1 && v10 != a4) {
    sub_1CBFFD1E8(a1, v10, a4);
  }
  sub_1CBFFCF68((unint64_t *)a1 + 8, a1);
  return sub_1CBFFD150((void *)a1 + 8, (unint64_t)&v14[v11 - (void)a1]);
}

void sub_1CCD65528(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(56 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CCD655F0(a1, v4, v4 + 56 * v3);
    JUMPOUT(0x1D25D9CD0);
  }

  sub_1CCD64410(a1);
}

void sub_1CCD655F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  sub_1CCD64410(a1);
  int v27 = -1;
  char v28 = 0;
  uint64_t v29 = 0;
  __s2 = v32;
  uint64_t v31 = 0x400000000;
  int v21 = -2;
  char v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = v26;
  uint64_t v25 = 0x400000000;
  if (a2 != a3)
  {
    do
    {
      unsigned int v6 = *(_DWORD *)a2;
      if (*(_DWORD *)a2 != v27
        || v6 <= 0xFFFFFFFD
        && (*(void *)(a2 + 8) != v29
         || (uint64_t v16 = *(unsigned int *)(a2 + 24), v16 != v31)
         || memcmp(*(const void **)(a2 + 16), __s2, 4 * v16)))
      {
        if (v6 != v21
          || v6 <= 0xFFFFFFFD
          && (*(void *)(a2 + 8) != v23
           || (uint64_t v17 = *(unsigned int *)(a2 + 24), v17 != v25)
           || memcmp(*(const void **)(a2 + 16), v24, 4 * v17)))
        {
          BOOL v20 = 0;
          sub_1CCD65108(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v20);
          int v7 = v20;
          *BOOL v20 = *(_OWORD *)a2;
          if ((_OWORD *)a2 != v7)
          {
            unsigned int v8 = *(const void **)(a2 + 16);
            if ((const void *)(a2 + 32) == v8)
            {
              uint64_t v9 = (void **)(v7 + 1);
              uint64_t v11 = (_DWORD *)(a2 + 24);
              uint64_t v10 = *(unsigned int *)(a2 + 24);
              uint64_t v12 = *((unsigned int *)v7 + 6);
              if (v12 >= v10)
              {
                if (v10) {
                  memmove(*v9, v8, 4 * v10);
                }
              }
              else
              {
                if (*((_DWORD *)v7 + 7) < v10)
                {
                  *((_DWORD *)v7 + 6) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v12)
                {
                  uint64_t v19 = *((unsigned int *)v7 + 6);
                  memmove(*v9, v8, 4 * v12);
                  uint64_t v13 = v19;
                }
                else
                {
                  uint64_t v13 = 0;
                }
                uint64_t v14 = *v11;
                if (v13 != v14) {
                  memcpy((char *)*v9 + 4 * v13, (const void *)(*(void *)(a2 + 16) + 4 * v13), 4 * v14 - 4 * v13);
                }
              }
              *((_DWORD *)v7 + 6) = v10;
            }
            else
            {
              uint64_t v18 = (_OWORD *)*((void *)v7 + 2);
              if (v18 != v7 + 2)
              {
                free(v18);
                unsigned int v8 = *(const void **)(a2 + 16);
              }
              *((void *)v7 + 2) = v8;
              uint64_t v11 = (_DWORD *)(a2 + 24);
              *((void *)v7 + 3) = *(void *)(a2 + 24);
              *(void *)(a2 + 16) = a2 + 32;
              *(_DWORD *)(a2 + 28) = 0;
            }
            _DWORD *v11 = 0;
          }
          *((_DWORD *)v7 + 12) = *(_DWORD *)(a2 + 48);
          ++*(_DWORD *)(a1 + 8);
        }
      }
      uint64_t v15 = *(void **)(a2 + 16);
      if ((void *)(a2 + 32) != v15) {
        free(v15);
      }
      a2 += 56;
    }
    while (a2 != a3);
    if (v24 != v26) {
      free(v24);
    }
  }
  if (__s2 != v32) {
    free(__s2);
  }
}

uint64_t sub_1CCD658D4(uint64_t a1, int a2, int a3, uint64_t a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((a4 >> 4) ^ (a4 >> 9) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)((a4 >> 4) ^ (a4 >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (int *)(a1 + 24 * v9);
    int v11 = *v10;
    uint64_t v12 = *((void *)v10 + 1);
    if (*v10 == a3 && v12 == a4)
    {
LABEL_22:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v11 != -1 || v12 != -4096)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v12 == -8192;
        }
        if (v16 && v11 == -2) {
          uint64_t v14 = v10;
        }
        unsigned int v18 = v9 + v15++;
        unsigned int v9 = v18 & v8;
        uint64_t v10 = (int *)(a1 + 24 * (v18 & v8));
        int v11 = *v10;
        uint64_t v12 = *((void *)v10 + 1);
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_22;
        }
      }
      uint64_t result = 0;
      if (v14) {
        uint64_t v10 = v14;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t result = 0;
  }
  *a5 = v10;
  return result;
}

_OWORD *sub_1CCD659C0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 24 * v10;
      do
      {
        _OWORD *result = xmmword_1CFB1B6D0;
        uint64_t result = (_OWORD *)((char *)result + 24);
        v11 -= 24;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 24 * v3;
      uint64_t v13 = v4 + 8;
      do
      {
        int v14 = *(_DWORD *)(v13 - 8);
        uint64_t v15 = *(void *)v13;
        if ((v14 != -1 || v15 != -4096) && (v14 != -2 || v15 != -8192))
        {
          uint64_t v19 = 0;
          sub_1CCD658D4(*(void *)a1, *(_DWORD *)(a1 + 16), v14, v15, &v19);
          BOOL v16 = v19;
          *uint64_t v19 = *(_DWORD *)(v13 - 8);
          *((void *)v16 + 1) = *(void *)v13;
          v16[4] = *(_DWORD *)(v13 + 8);
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 24;
        v12 -= 24;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 24 * v17;
    do
    {
      _OWORD *result = xmmword_1CFB1B6D0;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v18 -= 24;
    }
    while (v18);
  }
  return result;
}

uint64_t sub_1CCD65B3C(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CC152E2C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_8;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_8:
    sub_1CCD65C24(a1, v7);
    uint64_t v8 = 0;
    sub_1CC152E2C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)result != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)uint64_t result = *a2;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

void *sub_1CCD65C24(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC152F8C(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CCD65CF0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 16;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      int v7 = 0;
      uint64_t result = 0;
      goto LABEL_15;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  int v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_12:
    uint64_t result = 1;
  }
  else
  {
    unsigned int v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v8 == -8192;
      }
      if (v11) {
        unsigned int v9 = v7;
      }
      unsigned int v12 = v6 + v10++;
      unsigned int v6 = v12 & v5;
      int v7 = (void *)(v3 + 16 * (v12 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_12;
      }
    }
    uint64_t result = 0;
    if (v9) {
      int v7 = v9;
    }
  }
LABEL_15:
  *a3 = v7;
  return result;
}

void *sub_1CCD65D98(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 16;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CCD65E5C((uint64_t)a1, v7);
  unsigned int v9 = 0;
  sub_1CCD65CF0((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CCD65E5C(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x10)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CCD65FF4(a1, v11, v11 + 16 * v12);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  unsigned int v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)unsigned int v7 = v8;
      *((_DWORD *)v7 + 2) = *(_DWORD *)(a1 + v6 + 16);
      v7 += 16;
    }
    v6 += 16;
  }
  while (v6 != 256);
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CCD65FF4(a1, (uint64_t)v14, (uint64_t)v7);
}

uint64_t sub_1CCD65FF4(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 264);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CCD65CF0((uint64_t)v5, (void *)a2, &v11);
      int v10 = v11;
      void *v11 = *(void *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CCD660BC(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 16;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_5;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    int v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        int v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_5;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_5:
  *a3 = v7;
  return result;
}

void *sub_1CCD6616C(void *result)
{
  int v1 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if (v1)
    {
      uint64_t v3 = result + 1;
      int v4 = result + 9;
      goto LABEL_8;
    }
    uint64_t v2 = *((unsigned int *)result + 4);
    if (((2 * v1) & 0xFFFFFFFC) >= v2 || v2 < 0x41)
    {
      if (!v2)
      {
        int v5 = 0;
LABEL_10:
        *(_DWORD *)uint64_t result = v5;
        *((_DWORD *)result + 1) = 0;
        return result;
      }
      uint64_t v3 = (void *)result[1];
      int v4 = &v3[2 * v2];
      do
      {
LABEL_8:
        *uint64_t v3 = -4096;
        v3 += 2;
      }
      while (v3 != v4);
      int v5 = *(_DWORD *)result & 1;
      goto LABEL_10;
    }
    return sub_1CD463F6C(result);
  }
  return result;
}

uint64_t sub_1CCD661E8()
{
  LOBYTE(v5) = 1;
  v1.n128_u64[0] = (unint64_t)&v5;
  LODWORD(v4) = 1;
  sub_1CD765708((char **)&v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCF1B48, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD765828((char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCF1C08, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD765924((char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCF1CC8, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD765A20((char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCF1D88, &dword_1CB82C000);
  LOBYTE(v4) = 1;
  v1.n128_u64[0] = (unint64_t)&v4;
  sub_1CD765B1C((char **)&v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBD0B278, &dword_1CB82C000);
  int v5 = 1;
  int v2 = 1;
  int v3 = 100;
  int v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Max number of dependences to attempt Load PRE (default = 100)";
  v1.n128_u64[1] = 61;
  sub_1CD765C18(&v5, &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF1E48, &dword_1CB82C000);
  int v5 = 1;
  int v2 = 1;
  int v3 = 600;
  int v4 = &v3;
  v1.n128_u64[0] = (unint64_t)"Max number of blocks we're willing to speculate on (and recurse into) when deducing"
                                     " if a value is fully available or not in GVN (default = 600)";
  v1.n128_u64[1] = 143;
  sub_1CD765DAC(&v5, &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCF1F08, &dword_1CB82C000);
}

uint64_t llvm::GVNHoist::run(llvm::GVNHoist *this, llvm::Function *a2)
{
  *((_DWORD *)this + 144) = *((void *)a2 + 12);
  *((void *)this + 21) = *((void *)this + 23);
  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)this + 200);
  uint64_t v4 = *((void *)a2 + 10);
  if (v4) {
    uint64_t v5 = v4 - 24;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v43 = (unsigned char *)v5;
  sub_1CCADB4C0((uint64_t *)&v43, (uint64_t)&v52);
  unsigned int v6 = v48;
  uint64_t v43 = v48;
  uint64_t v7 = v53;
  if (v53 == v52)
  {
    BOOL v44 = v48;
    uint64_t v8 = v53;
  }
  else
  {
    unsigned int v31 = v54;
    unsigned int v6 = malloc_type_malloc(8 * v54, 0x4065EBACuLL);
    if (!v6)
    {
      if (v31) {
        goto LABEL_71;
      }
      unsigned int v6 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v6) {
        goto LABEL_71;
      }
    }
    BOOL v44 = v6;
    uint64_t v8 = v52;
    uint64_t v7 = v53;
  }
  unsigned int v9 = v55;
  unsigned int v45 = v54;
  if (v7 == v8) {
    unsigned int v10 = v55;
  }
  else {
    unsigned int v10 = v54;
  }
  if (v10)
  {
    memmove(v6, v7, 8 * v10);
    unsigned int v9 = v55;
  }
  unsigned int v46 = v9;
  int v47 = v56;
  int v50 = 0;
  uint64_t v51 = 0;
  long long __p = 0;
  sub_1CBFE1720(&__p, v57, v58, (v58 - (unsigned char *)v57) >> 5);
  int v11 = v39;
  BOOL v34 = v39;
  BOOL v12 = v60;
  if (v60 != v59)
  {
    unsigned int v32 = v61;
    int v11 = malloc_type_malloc(8 * v61, 0x4065EBACuLL);
    if (v11 || !v32 && (int v11 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      uint64_t v35 = v11;
      unsigned int v13 = v59;
      BOOL v12 = v60;
      goto LABEL_13;
    }
LABEL_71:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v35 = v39;
  unsigned int v13 = v60;
LABEL_13:
  unsigned int v14 = v62;
  unsigned int v36 = v61;
  if (v12 == v13) {
    unsigned int v15 = v62;
  }
  else {
    unsigned int v15 = v61;
  }
  if (v15)
  {
    memmove(v11, v12, 8 * v15);
    unsigned int v14 = v62;
  }
  unsigned int v37 = v14;
  int v38 = v63;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  char v40 = 0;
  sub_1CBFE1720(&v40, v64, v65, (v65 - (unsigned char *)v64) >> 5);
  int v16 = 0;
  while (1)
  {
    if (v50 - (unsigned char *)__p != v41 - v40) {
      goto LABEL_33;
    }
    if (__p == v50) {
      break;
    }
    uint64_t v17 = v40 + 16;
    uint64_t v18 = (char *)__p + 16;
    while (1)
    {
      uint64_t v19 = v18 - 16;
      if (*((void *)v18 - 2) != *((void *)v17 - 2)) {
        break;
      }
      int v20 = v17[8];
      if (v18[8]) {
        BOOL v21 = v20 == 0;
      }
      else {
        BOOL v21 = 1;
      }
      if (v21)
      {
        if ((v18[8] == 0) == (v20 != 0)) {
          break;
        }
      }
      else if (*(_DWORD *)v18 != *(_DWORD *)v17)
      {
        break;
      }
      v17 += 32;
      v18 += 32;
      if (v19 + 32 == v50) {
        goto LABEL_39;
      }
    }
LABEL_33:
    ++v16;
    uint64_t v33 = *((void *)v50 - 4);
    uint64_t v22 = v33;
    *((_DWORD *)sub_1CC220A0C((uint64_t)this + 232, &v33) + 2) = v16;
    uint64_t v23 = v22 + 40;
    uint64_t v24 = *(void *)(v22 + 48);
    if (v24 != v23)
    {
      int v25 = 1;
      do
      {
        uint64_t v26 = v24 - 24;
        if (!v24) {
          uint64_t v26 = 0;
        }
        uint64_t v33 = v26;
        *((_DWORD *)sub_1CC220A0C((uint64_t)this + 232, &v33) + 2) = v25;
        uint64_t v24 = *(void *)(v24 + 8);
        ++v25;
      }
      while (v24 != v23);
    }
    sub_1CC0D3E0C((uint64_t)&v43);
  }
LABEL_39:
  if (v40)
  {
    uint64_t v41 = v40;
    operator delete(v40);
  }
  if (v35 != v34) {
    free(v35);
  }
  if (__p)
  {
    int v50 = (char *)__p;
    operator delete(__p);
  }
  if (v44 != v43) {
    free(v44);
  }
  if (v64)
  {
    int v65 = v64;
    operator delete(v64);
  }
  if (v60 != v59) {
    free(v60);
  }
  if (v57)
  {
    uint64_t v58 = v57;
    operator delete(v57);
  }
  if (v53 != v52) {
    free(v53);
  }
  int v27 = 0;
  for (char i = 0; dword_1EBCF2290 == -1 || ++v27 < dword_1EBCF2290; char i = 1)
  {
    unint64_t v29 = llvm::GVNHoist::hoistExpressions(this, a2);
    if (!(v29 + HIDWORD(v29))) {
      break;
    }
    if (HIDWORD(v29)) {
      llvm::GVNPass::ValueTable::clear(this);
    }
  }
  return i & 1;
}

unint64_t llvm::GVNHoist::hoistExpressions(llvm::GVNHoist *this, llvm::Function *a2)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  v63[0] = 0;
  v63[1] = 0;
  int v64 = 0;
  v61[0] = 0;
  v61[1] = 0;
  int v62 = 0;
  v59[0] = 0;
  v59[1] = 0;
  int v60 = 0;
  v53[0] = 0;
  v53[1] = 0;
  int v54 = 0;
  v55[0] = 0;
  v55[1] = 0;
  int v56 = 0;
  v57[0] = 0;
  v57[1] = 0;
  int v58 = 0;
  uint64_t v3 = *((void *)a2 + 10);
  if (v3) {
    uint64_t v4 = v3 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  BOOL v44 = (unsigned char *)v4;
  sub_1CCADB4C0((uint64_t *)&v44, (uint64_t)&v66);
  uint64_t v5 = v49;
  BOOL v44 = v49;
  unsigned int v6 = (char *)v67;
  if ((char *)v67 == v66)
  {
    unsigned int v45 = v49;
    uint64_t v7 = (char *)v67;
  }
  else
  {
    unsigned int v32 = v68;
    uint64_t v5 = malloc_type_malloc(8 * v68, 0x4065EBACuLL);
    if (!v5)
    {
      if (v32) {
        goto LABEL_100;
      }
      uint64_t v5 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v5) {
        goto LABEL_100;
      }
    }
    unsigned int v45 = v5;
    uint64_t v7 = v66;
    unsigned int v6 = (char *)v67;
  }
  unsigned int v8 = v69;
  unsigned int v46 = v68;
  if (v6 == v7) {
    unsigned int v9 = v69;
  }
  else {
    unsigned int v9 = v68;
  }
  if (v9)
  {
    memmove(v5, v6, 8 * v9);
    unsigned int v8 = v69;
  }
  unsigned int v47 = v8;
  int v48 = v70;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  long long __p = 0;
  sub_1CBFE1720(&__p, v71, v72, (v72 - (unsigned char *)v71) >> 5);
  unsigned int v10 = v40;
  uint64_t v35 = v40;
  int v11 = __src;
  if (__src != v73)
  {
    unsigned int v33 = v75;
    unsigned int v10 = malloc_type_malloc(8 * v75, 0x4065EBACuLL);
    if (v10 || !v33 && (unsigned int v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      unsigned int v36 = v10;
      BOOL v12 = v73;
      int v11 = __src;
      goto LABEL_13;
    }
LABEL_100:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unsigned int v36 = v40;
  BOOL v12 = __src;
LABEL_13:
  unsigned int v13 = v76;
  unsigned int v37 = v75;
  if (v11 == v12) {
    unsigned int v14 = v76;
  }
  else {
    unsigned int v14 = v75;
  }
  if (v14)
  {
    memmove(v10, v11, 8 * v14);
    unsigned int v13 = v76;
  }
  unsigned int v38 = v13;
  int v39 = v77;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  sub_1CBFE1720(&v41, v78, v79, (v79 - (unsigned char *)v78) >> 5);
  while (1)
  {
    if (v51 - (unsigned char *)__p != v42 - v41) {
      goto LABEL_33;
    }
    if (__p == v51) {
      break;
    }
    int v16 = v41 + 16;
    uint64_t v17 = (char *)__p + 16;
    while (1)
    {
      uint64_t v18 = v17 - 16;
      if (*((void *)v17 - 2) != *((void *)v16 - 2)) {
        break;
      }
      int v19 = v16[8];
      if (v17[8]) {
        BOOL v20 = v19 == 0;
      }
      else {
        BOOL v20 = 1;
      }
      if (v20)
      {
        if ((v17[8] == 0) == (v19 != 0)) {
          break;
        }
      }
      else if (*(_DWORD *)v17 != *(_DWORD *)v16)
      {
        break;
      }
      v16 += 32;
      v17 += 32;
      if (v18 + 32 == v51) {
        goto LABEL_74;
      }
    }
LABEL_33:
    uint64_t v34 = 0;
    uint64_t v34 = *((void *)v51 - 4);
    uint64_t v21 = v34 + 40;
    uint64_t v22 = *(void *)(v34 + 48);
    if (v22 != v34 + 40)
    {
      int v23 = 0;
      while (1)
      {
        uint64_t v24 = v22 ? (unsigned __int8 *)(v22 - 24) : 0;
        if ((llvm::isGuaranteedToTransferExecutionToSuccessor((llvm *)v24, v15) & 1) == 0) {
          break;
        }
        if (dword_1EBCF21D0 != -1)
        {
          if (v23 >= dword_1EBCF21D0) {
            goto LABEL_73;
          }
          ++v23;
        }
        int v25 = v24[16];
        if ((v25 - 29) < 0xB) {
          goto LABEL_73;
        }
        if (v22 && v25 == 60)
        {
          sub_1CD7675D8((uint64_t)v61, (llvm::Instruction *)v24, this);
        }
        else if (v22 && v25 == 61)
        {
          sub_1CD767694((uint64_t)v59, (llvm::Instruction *)v24, this);
        }
        else
        {
          if (v25 == 84) {
            uint64_t v26 = v24;
          }
          else {
            uint64_t v26 = 0;
          }
          if (v22 && v25 == 84)
          {
            uint64_t v27 = *((void *)v26 - 4);
            if (!v27
              || *(unsigned char *)(v27 + 16)
              || *(void *)(v27 + 24) != *((void *)v26 + 9)
              || (*(unsigned char *)(v27 + 33) & 0x20) == 0
              || ((unsigned int v29 = *(_DWORD *)(*((void *)v24 - 4) + 36), v29 > 0x3A)
               || ((1 << v29) & 0x780000000000080) == 0)
              && v29 != 272)
            {
              if (llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)v26)) {
                goto LABEL_73;
              }
              uint64_t v28 = *((void *)v26 + 8);
              if (v28)
              {
                if ((*(unsigned char *)(v28 + 12) & 0x40) != 0) {
                  goto LABEL_73;
                }
              }
              if (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)v26, 6)) {
                goto LABEL_73;
              }
              sub_1CD767764((uint64_t)v53, (llvm::Value *)v26, this);
            }
          }
          else if (v25 != 62 || *((unsigned char *)this + 580))
          {
            sub_1CD76783C((uint64_t)v63, (llvm::Value *)v24, this);
          }
        }
        uint64_t v22 = *(void *)(v22 + 8);
        if (v22 == v21) {
          goto LABEL_73;
        }
      }
      sub_1CD4201D0((uint64_t)this + 280, &v34, (uint64_t)v65);
    }
LABEL_73:
    sub_1CC0D3E0C((uint64_t)&v44);
  }
LABEL_74:
  if (v41)
  {
    uint64_t v42 = v41;
    operator delete(v41);
  }
  if (v36 != v35) {
    free(v36);
  }
  if (__p)
  {
    uint64_t v51 = (char *)__p;
    operator delete(__p);
  }
  if (v45 != v44) {
    free(v45);
  }
  if (v78)
  {
    __int16 v79 = v78;
    operator delete(v78);
  }
  if (__src != v73) {
    free(__src);
  }
  if (v71)
  {
    int v72 = v71;
    operator delete(v71);
  }
  if ((char *)v67 != v66) {
    free((void *)v67);
  }
  int v66 = (char *)&v68;
  uint64_t v67 = 0x400000000;
  sub_1CD7678C8((char *)this, v63, (uint64_t)&v66, 1);
  sub_1CD7678C8((char *)this, v61, (uint64_t)&v66, 2);
  sub_1CD7678C8((char *)this, v59, (uint64_t)&v66, 3);
  sub_1CD7678C8((char *)this, v53, (uint64_t)&v66, 1);
  sub_1CD7678C8((char *)this, v55, (uint64_t)&v66, 2);
  sub_1CD7678C8((char *)this, v57, (uint64_t)&v66, 3);
  unint64_t v30 = llvm::GVNHoist::hoist((llvm::MemoryDependenceResults **)this, (uint64_t *)&v66);
  sub_1CD63E2C8(&v66);
  sub_1CD769594(v53);
  sub_1CD7695F4((uint64_t)v59);
  MEMORY[0x1D25D9CD0](v59[0], 8);
  sub_1CD7695F4((uint64_t)v61);
  MEMORY[0x1D25D9CD0](v61[0], 8);
  sub_1CD7695F4((uint64_t)v63);
  MEMORY[0x1D25D9CD0](v63[0], 8);
  return v30;
}

uint64_t llvm::GVNHoist::hasMemoryUse(llvm::GVNHoist *this, const llvm::Instruction *a2, llvm::MemoryDef *a3, const llvm::BasicBlock *a4)
{
  uint64_t v8 = *((void *)this + 27);
  uint64_t v9 = *(void *)(v8 + 48);
  uint64_t v10 = *(unsigned int *)(v8 + 64);
  if (!v10)
  {
LABEL_7:
    uint64_t v12 = v9 + 16 * v10;
    goto LABEL_8;
  }
  LODWORD(v11) = (v10 - 1) & ((a4 >> 4) ^ (a4 >> 9));
  uint64_t v12 = v9 + 16 * v11;
  unsigned int v13 = *(const llvm::BasicBlock **)v12;
  if (*(const llvm::BasicBlock **)v12 != a4)
  {
    int v14 = 1;
    while (v13 != (const llvm::BasicBlock *)-4096)
    {
      int v15 = v11 + v14++;
      uint64_t v11 = v15 & (v10 - 1);
      unsigned int v13 = *(const llvm::BasicBlock **)(v9 + 16 * v11);
      if (v13 == a4)
      {
        uint64_t v12 = v9 + 16 * v11;
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  if (v12 != v9 + 16 * v10)
  {
    uint64_t v16 = *(void *)(v12 + 8);
    if (v16)
    {
      uint64_t v17 = *(void *)(v16 + 8);
      if (v17 != v16)
      {
        char v18 = 0;
        uint64_t v19 = *((void *)a3 + 9);
        int v25 = (const llvm::BasicBlock *)*((void *)a2 + 5);
        uint64_t v26 = *(const llvm::BasicBlock **)(v19 + 40);
        do
        {
          uint64_t v20 = v17 - 32;
          if (!v17) {
            uint64_t v20 = 0;
          }
          int v21 = *(unsigned __int8 *)(v20 + 16);
          if (v21 == 25) {
            uint64_t v22 = v20;
          }
          else {
            uint64_t v22 = 0;
          }
          if (!v17 || v21 != 25) {
            goto LABEL_19;
          }
          uint64_t v23 = *(void *)(v22 + 72);
          if (v26 == a4 && sub_1CD766368((uint64_t)this, v19, *(void *)(v22 + 72))) {
            return 0;
          }
          if (!((v25 != a4) | v18 & 1))
          {
            if (sub_1CD766368((uint64_t)this, v23, (uint64_t)a2))
            {
              char v18 = 0;
              goto LABEL_19;
            }
            char v18 = 1;
          }
          if (llvm::MemorySSAUtil::defClobbersUseOrDef((uint64_t)a3, v22, *((llvm::AAResults **)this + 25))) {
            return 1;
          }
LABEL_19:
          uint64_t v17 = *(void *)(v17 + 8);
        }
        while (v17 != v16);
      }
    }
  }
  return 0;
}

uint64_t llvm::GVNHoist::safeToHoistLdSt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
  }
  return 1;
}

uint64_t llvm::GVNHoist::fillRenameStack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD4A8B14(*(void *)a3, *(_DWORD *)(a3 + 16), a2, &v12);
  if (result) {
    BOOL v7 = v12 == *(void *)a3 + 72 * *(unsigned int *)(a3 + 16);
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = *(unsigned int *)(v12 + 16);
    if (v8)
    {
      uint64_t v9 = *(void *)(v12 + 8);
      uint64_t v10 = 24 * v8;
      do
      {
        uint64_t result = sub_1CD769FC8(a4, v9 + v10 - 24);
        unint64_t v11 = *(unsigned int *)(result + 24);
        if (v11 >= *(unsigned int *)(result + 28)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(result + 16) + 8 * v11) = *(void *)(v9 + v10 - 8);
        ++*(_DWORD *)(result + 24);
        v10 -= 24;
      }
      while (v10);
    }
  }
  return result;
}

void llvm::GVNHoist::fillChiArgs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    while (1)
    {
      uint64_t v7 = *(void *)(v4 + 24);
      unsigned int v8 = *(unsigned __int8 *)(v7 + 16);
      BOOL v9 = v7 && v8 >= 0x1C;
      if (v9 && v8 - 29 < 0xB) {
        break;
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        return;
      }
    }
LABEL_12:
    uint64_t v11 = *(void *)(v7 + 40);
    uint64_t v26 = 0;
    int v12 = sub_1CD513A78(*(void *)a3, *(_DWORD *)(a3 + 16), v11, &v26);
    uint64_t v13 = v26;
    if (v12) {
      BOOL v14 = v26 == *(void *)a3 + 88 * *(unsigned int *)(a3 + 16);
    }
    else {
      BOOL v14 = 1;
    }
    if (!v14)
    {
      uint64_t v15 = *(unsigned int *)(v26 + 16);
      if (v15)
      {
        uint64_t v16 = *(void *)(v26 + 8);
        uint64_t v17 = v16 + 32 * v15;
        do
        {
          if (*(void *)(v16 + 16))
          {
            v16 += 32;
          }
          else
          {
            uint64_t v26 = 0;
            if (sub_1CD76A050(*(void *)a4, *(_DWORD *)(a4 + 16), *(_DWORD *)v16, *(void *)(v16 + 8), &v26))BOOL v18 = v26 == *(void *)a4 + 48 * *(unsigned int *)(a4 + 16); {
            else
            }
              BOOL v18 = 1;
            if (!v18 && *(_DWORD *)(v26 + 24)) {
              llvm::DominatorTreeBase<llvm::BasicBlock,false>::properlyDominates();
            }
            uint64_t v19 = *(void *)(v13 + 8) + 32 * *(unsigned int *)(v13 + 16);
            if (v16 != v19)
            {
              int v20 = *(_DWORD *)v16;
              uint64_t v21 = *(void *)(v16 + 8);
              do
              {
                if (*(_DWORD *)v16 != v20 || *(void *)(v16 + 8) != v21) {
                  goto LABEL_20;
                }
                v16 += 32;
              }
              while (v16 != v19);
              uint64_t v16 = *(void *)(v13 + 8) + 32 * *(unsigned int *)(v13 + 16);
            }
          }
LABEL_20:
          ;
        }
        while (v16 != v17);
      }
    }
    while (1)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        break;
      }
      uint64_t v7 = *(void *)(v4 + 24);
      unsigned int v23 = *(unsigned __int8 *)(v7 + 16);
      if (v7) {
        BOOL v24 = v23 >= 0x1C;
      }
      else {
        BOOL v24 = 0;
      }
      if (v24 && v23 - 29 < 0xB) {
        goto LABEL_12;
      }
    }
  }
}

uint64_t llvm::GVNHoist::allOperandsAvailable(llvm::GVNHoist *this, const llvm::Instruction *a2, const llvm::BasicBlock *a3)
{
  int v3 = *((_DWORD *)a2 + 5);
  if ((v3 & 0x40000000) != 0)
  {
    uint64_t v5 = (char *)*((void *)a2 - 1);
    uint64_t v4 = v3 & 0x7FFFFFF;
    if (!v4) {
      return 1;
    }
  }
  else
  {
    uint64_t v4 = v3 & 0x7FFFFFF;
    uint64_t v5 = (char *)a2 - 32 * v4;
    if (!v4) {
      return 1;
    }
  }
  uint64_t v6 = 32 * v4;
  do
  {
    if (*(void *)v5) {
      BOOL v7 = *(unsigned __int8 *)(*(void *)v5 + 16) >= 0x1Cu;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7) {
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
    }
    v5 += 32;
    v6 -= 32;
  }
  while (v6);
  return 1;
}

uint64_t llvm::GVNHoist::allGepOperandsAvailable(llvm::GVNHoist *this, const llvm::Instruction *a2, const llvm::BasicBlock *a3)
{
  int v3 = *((_DWORD *)a2 + 5);
  if ((v3 & 0x40000000) != 0)
  {
    uint64_t v5 = (char *)*((void *)a2 - 1);
    uint64_t v4 = v3 & 0x7FFFFFF;
    if (!v4) {
      return 1;
    }
  }
  else
  {
    uint64_t v4 = v3 & 0x7FFFFFF;
    uint64_t v5 = (char *)a2 - 32 * v4;
    if (!v4) {
      return 1;
    }
  }
  uint64_t v6 = 32 * v4;
  do
  {
    if (*(void *)v5) {
      BOOL v7 = *(unsigned __int8 *)(*(void *)v5 + 16) >= 0x1Cu;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7) {
      llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
    }
    v5 += 32;
    v6 -= 32;
  }
  while (v6);
  return 1;
}

void llvm::GVNHoist::makeGepsAvailable(uint64_t a1, llvm::User *a2, uint64_t a3, uint64_t a4, llvm::Instruction *a5)
{
  BOOL v9 = (llvm::Value *)llvm::Instruction::clone(a5);
  uint64_t v10 = *((_DWORD *)a5 + 5) & 0x7FFFFFF;
  if (v10)
  {
    unint64_t v11 = 0;
    uint64_t v12 = 32 * v10;
    do
    {
      int v13 = *((_DWORD *)a5 + 5);
      if ((v13 & 0x40000000) != 0) {
        BOOL v14 = (_DWORD *)*((void *)a5 - 1);
      }
      else {
        BOOL v14 = (_DWORD *)((char *)a5 - 32 * (v13 & 0x7FFFFFF));
      }
      uint64_t v15 = *(void *)&v14[v11 / 4];
      if (v15) {
        BOOL v16 = *(unsigned __int8 *)(v15 + 16) >= 0x1Cu;
      }
      else {
        BOOL v16 = 0;
      }
      if (v16) {
        llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
      }
      v11 += 32;
    }
    while (v12 != v11);
  }
  uint64_t v17 = *(void *)(a3 + 40);
  if (v17 == a3 + 40)
  {
    uint64_t v19 = 0;
  }
  else
  {
    if (v17) {
      uint64_t v18 = v17 - 24;
    }
    else {
      uint64_t v18 = 0;
    }
    if (*(unsigned __int8 *)(v18 + 16) - 29 >= 0xB) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = v18;
    }
  }
  uint64_t v20 = *(void *)(v19 + 40);
  *((void *)v9 + 5) = v20;
  *(_WORD *)(v20 + 18) &= ~0x8000u;
  if ((*((unsigned char *)v9 + 23) & 0x10) != 0)
  {
    uint64_t v27 = *(void *)(v20 + 56);
    if (v27)
    {
      uint64_t v28 = *(llvm::ValueSymbolTable **)(v27 + 104);
      if (v28) {
        llvm::ValueSymbolTable::reinsertValue(v28, v9);
      }
    }
  }
  uint64_t v22 = *(void *)(v19 + 24);
  uint64_t v21 = (void *)(v19 + 24);
  *((void *)v9 + 4) = v21;
  *((void *)v9 + 3) = v22;
  *(void *)(v22 + 8) = (char *)v9 + 24;
  *uint64_t v21 = (char *)v9 + 24;
  llvm::Instruction::dropUnknownNonDebugMetadata((uint64_t)v9, 0, 0);
  uint64_t v23 = *(unsigned int *)(a4 + 8);
  if (v23)
  {
    BOOL v24 = *(uint64_t **)a4;
    uint64_t v25 = 8 * v23;
    do
    {
      uint64_t v26 = *v24++;
      llvm::Instruction::andIRFlags((uint64_t)v9, *(void *)(v26 - 32));
      v25 -= 8;
    }
    while (v25);
  }

  llvm::User::replaceUsesOfWith(a2, a5, v9);
}

void llvm::GVNHoist::raMPHIuw(uint64_t a1, llvm::Value *a2)
{
  uint64_t v4 = (unint64_t *)v36;
  unsigned int v32 = (unint64_t *)v36;
  unsigned int v33 = (unint64_t *)v36;
  uint64_t v34 = 4;
  int v35 = 0;
  uint64_t v5 = *((void *)a2 + 1);
  if (v5)
  {
    LODWORD(v6) = 0;
    unsigned int v7 = 4;
    unsigned int v8 = (unint64_t *)v36;
    while (1)
    {
      unint64_t v9 = *(void *)(v5 + 24);
      if (v9) {
        BOOL v10 = *(unsigned char *)(v9 + 16) == 27;
      }
      else {
        BOOL v10 = 0;
      }
      if (!v10) {
        goto LABEL_39;
      }
      if (v8 != v4) {
        break;
      }
      if (v6)
      {
        unint64_t v11 = 0;
        uint64_t v12 = 8 * v6;
        int v13 = v4;
        while (*v13 != v9)
        {
          if (*v13 == -2) {
            unint64_t v11 = v13;
          }
          ++v13;
          v12 -= 8;
          if (!v12)
          {
            if (!v11) {
              goto LABEL_16;
            }
            unint64_t *v11 = v9;
            --v35;
            goto LABEL_38;
          }
        }
        goto LABEL_38;
      }
LABEL_16:
      if (v7 <= v6) {
        break;
      }
      HIDWORD(v34) = v6 + 1;
      v4[v6] = v9;
LABEL_38:
      uint64_t v4 = v32;
      unsigned int v8 = v33;
      unsigned int v7 = v34;
      LODWORD(v6) = HIDWORD(v34);
LABEL_39:
      uint64_t v5 = *(void *)(v5 + 8);
      if (!v5) {
        goto LABEL_48;
      }
    }
    if (3 * v7 <= 4 * ((int)v6 - v35))
    {
      if (v7 >= 0x40) {
        v7 *= 2;
      }
      else {
        unsigned int v7 = 128;
      }
    }
    else if (v7 - v6 >= v7 >> 3)
    {
      goto LABEL_20;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v32, v7);
    unsigned int v7 = v34;
    unsigned int v8 = v33;
LABEL_20:
    unsigned int v14 = v7 - 1;
    unsigned int v15 = (v7 - 1) & ((v9 >> 4) ^ (v9 >> 9));
    BOOL v16 = &v8[v15];
    unint64_t v17 = *v16;
    if (*v16 == -1)
    {
      uint64_t v18 = 0;
LABEL_32:
      if (v18) {
        BOOL v16 = v18;
      }
      if (*v16 != v9)
      {
        if (*v16 == -2) {
          --v35;
        }
        else {
          ++HIDWORD(v34);
        }
        *BOOL v16 = v9;
      }
    }
    else
    {
      uint64_t v18 = 0;
      int v19 = 1;
      while (v17 != v9)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v17 == -2;
        }
        if (v20) {
          uint64_t v18 = v16;
        }
        unsigned int v21 = v15 + v19++;
        unsigned int v15 = v21 & v14;
        BOOL v16 = &v8[v21 & v14];
        unint64_t v17 = *v16;
        if (*v16 == -1) {
          goto LABEL_32;
        }
      }
    }
    goto LABEL_38;
  }
  LODWORD(v6) = 0;
  unsigned int v7 = 4;
  unsigned int v8 = (unint64_t *)v36;
LABEL_48:
  if (v8 == v4) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = v7;
  }
  uint64_t v22 = v8;
  if (v6)
  {
    uint64_t v23 = 0;
    while (v8[v23] >= 0xFFFFFFFFFFFFFFFELL)
    {
      if (v6 == ++v23) {
        goto LABEL_72;
      }
    }
    uint64_t v22 = &v8[v23];
  }
  BOOL v24 = &v8[v6];
  if (v22 != v24)
  {
    uint64_t v25 = (_DWORD *)*v22;
LABEL_59:
    int v26 = v25[5];
    if ((v26 & 0x40000000) != 0)
    {
      uint64_t v28 = (llvm::Value **)*((void *)v25 - 1);
      uint64_t v27 = v26 & 0x7FFFFFF;
      if (!v27)
      {
LABEL_66:
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)v25, a2, (llvm::Value *)1);
        llvm::MemorySSAUpdater::removeMemoryAccess(*(int32x2_t ***)(a1 + 224), (llvm::MemoryAccess *)v25, 0);
LABEL_67:
        unint64_t v30 = v22 + 1;
        while (v30 != v24)
        {
          unint64_t v31 = *v30++;
          uint64_t v25 = (_DWORD *)v31;
          if (v31 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v22 = v30 - 1;
            goto LABEL_59;
          }
        }
        uint64_t v4 = v32;
        unsigned int v8 = v33;
        goto LABEL_72;
      }
    }
    else
    {
      uint64_t v27 = v26 & 0x7FFFFFF;
      uint64_t v28 = (llvm::Value **)&v25[-8 * v27];
      if (!v27) {
        goto LABEL_66;
      }
    }
    uint64_t v29 = 32 * v27;
    while (*v28 == a2)
    {
      v28 += 4;
      v29 -= 32;
      if (!v29) {
        goto LABEL_66;
      }
    }
    goto LABEL_67;
  }
LABEL_72:
  if (v8 != v4) {
    free(v8);
  }
}

void sub_1CCD678A0(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeMemoryDependenceWrapperPassPass(a1, a2);
  llvm::initializeMemorySSAWrapperPassPass(a1, v3);
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializePostDominatorTreeWrapperPassPass((uint64_t)a1);
  llvm::initializeAAResultsWrapperPassPass(a1, v4);
  operator new();
}

uint64_t sub_1CCD67978(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 16;
    if (result + 16 != a2)
    {
      uint64_t v7 = 0;
      uint64_t v8 = result;
      do
      {
        uint64_t v9 = v8;
        uint64_t v8 = v5;
        uint64_t result = sub_1CD768B54(a3, *(_DWORD *)(v9 + 16), *(void *)(v5 + 8), v9);
        if (result)
        {
          int v10 = *(_DWORD *)v8;
          uint64_t v11 = *(void *)(v8 + 8);
          uint64_t v12 = v7;
          while (1)
          {
            uint64_t v13 = v4 + v12;
            *(_DWORD *)(v13 + 16) = *(_DWORD *)(v4 + v12);
            *(void *)(v13 + 24) = *(void *)(v4 + v12 + 8);
            if (!v12) {
              break;
            }
            v12 -= 16;
            uint64_t result = sub_1CD768B54(a3, v10, v11, v12 + v4);
            if ((result & 1) == 0)
            {
              uint64_t v14 = v4 + v12 + 16;
              goto LABEL_10;
            }
          }
          uint64_t v14 = v4;
LABEL_10:
          *(_DWORD *)uint64_t v14 = v10;
          *(void *)(v14 + 8) = v11;
        }
        uint64_t v5 = v8 + 16;
        v7 += 16;
      }
      while (v8 + 16 != a2);
    }
  }
  return result;
}

uint64_t sub_1CCD67A5C(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = result + 16;
    if (result + 16 != a2)
    {
      uint64_t v7 = result - 16;
      do
      {
        uint64_t v8 = v4;
        uint64_t v4 = v5;
        uint64_t result = sub_1CD768B54(a3, *(_DWORD *)(v8 + 16), *(void *)(v5 + 8), v8);
        if (result)
        {
          int v9 = *(_DWORD *)v4;
          uint64_t v10 = *(void *)(v4 + 8);
          uint64_t v11 = v7;
          do
          {
            *(_DWORD *)(v11 + 32) = *(_DWORD *)(v11 + 16);
            *(void *)(v11 + 40) = *(void *)(v11 + 24);
            uint64_t result = sub_1CD768B54(a3, v9, v10, v11);
            v11 -= 16;
          }
          while ((result & 1) != 0);
          *(_DWORD *)(v11 + 32) = v9;
          *(void *)(v11 + 40) = v10;
        }
        uint64_t v5 = v4 + 16;
        v7 += 16;
      }
      while (v4 + 16 != a2);
    }
  }
  return result;
}

BOOL sub_1CCD67B24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (uint64_t *)(a2 + 8);
  BOOL v9 = sub_1CD768B54(a4, *(_DWORD *)a2, *(void *)(a2 + 8), a1);
  BOOL result = sub_1CD768B54(a4, *(_DWORD *)a3, *(void *)(a3 + 8), a2);
  if (v9)
  {
    int v11 = *(_DWORD *)a1;
    if (result)
    {
      *(_DWORD *)a1 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v11;
      uint64_t v12 = (uint64_t *)(a1 + 8);
LABEL_4:
      uint64_t v8 = (uint64_t *)(a3 + 8);
LABEL_5:
      uint64_t v13 = *v12;
      *uint64_t v12 = *v8;
      uint64_t *v8 = v13;
      return result;
    }
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v11;
    uint64_t v14 = *(void *)(a1 + 8);
    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = v14;
    BOOL result = sub_1CD768B54(a4, *(_DWORD *)a3, *(void *)(a3 + 8), a2);
    if (result)
    {
      int v15 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v15;
      uint64_t v12 = (uint64_t *)(a2 + 8);
      goto LABEL_4;
    }
  }
  else if (result)
  {
    int v16 = *(_DWORD *)a2;
    *(_DWORD *)a2 = *(_DWORD *)a3;
    *(_DWORD *)a3 = v16;
    uint64_t v17 = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = v17;
    BOOL result = sub_1CD768B54(a4, *(_DWORD *)a2, *(void *)(a2 + 8), a1);
    if (result)
    {
      int v18 = *(_DWORD *)a1;
      *(_DWORD *)a1 = *(_DWORD *)a2;
      uint64_t v12 = (uint64_t *)(a1 + 8);
      *(_DWORD *)a2 = v18;
      goto LABEL_5;
    }
  }
  return result;
}

unint64_t sub_1CCD67C70(unint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  if (sub_1CD768B54(a3, *(_DWORD *)a1, v7, a2 - 16))
  {
    unint64_t v8 = a1;
    do
      v8 += 16;
    while (!sub_1CD768B54(a3, v6, v7, v8));
  }
  else
  {
    unint64_t v12 = a1 + 16;
    do
    {
      unint64_t v8 = v12;
      if (v12 >= v4) {
        break;
      }
      BOOL v13 = sub_1CD768B54(a3, v6, v7, v12);
      unint64_t v12 = v8 + 16;
    }
    while (!v13);
  }
  if (v8 < v4)
  {
    do
      v4 -= 16;
    while (sub_1CD768B54(a3, v6, v7, v4));
  }
  while (v8 < v4)
  {
    int v9 = *(_DWORD *)v8;
    *(_DWORD *)unint64_t v8 = *(_DWORD *)v4;
    *(_DWORD *)unint64_t v4 = v9;
    uint64_t v10 = *(void *)(v8 + 8);
    *(void *)(v8 + 8) = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = v10;
    do
      v8 += 16;
    while (!sub_1CD768B54(a3, v6, v7, v8));
    do
      v4 -= 16;
    while (sub_1CD768B54(a3, v6, v7, v4));
  }
  if (v8 - 16 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v8 - 16);
    *(void *)(a1 + 8) = *(void *)(v8 - 8);
  }
  *(_DWORD *)(v8 - 16) = v6;
  *(void *)(v8 - 8) = v7;
  return v8;
}

int *sub_1CCD67DC8(int *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  long long v18 = *(_OWORD *)a1;
  do
  {
    BOOL v7 = sub_1CD768B54(a3, a1[v6 + 4], *(void *)&a1[v6 + 6], (uint64_t)&v18);
    v6 += 4;
  }
  while (v7);
  unint64_t v8 = (unint64_t)&a1[v6];
  if (v6 == 4)
  {
    do
    {
      if (v8 >= a2) {
        break;
      }
      int v10 = *(_DWORD *)(a2 - 16);
      a2 -= 16;
    }
    while (!sub_1CD768B54(a3, v10, *(void *)(a2 + 8), (uint64_t)&v18));
  }
  else
  {
    do
    {
      int v9 = *(_DWORD *)(a2 - 16);
      a2 -= 16;
    }
    while (!sub_1CD768B54(a3, v9, *(void *)(a2 + 8), (uint64_t)&v18));
  }
  int v11 = (long long *)&a1[v6];
  if (v8 < a2)
  {
    unint64_t v12 = a2;
    do
    {
      int v13 = *(_DWORD *)v11;
      *(_DWORD *)int v11 = *(_DWORD *)v12;
      *(_DWORD *)unint64_t v12 = v13;
      uint64_t v14 = *((void *)v11 + 1);
      *((void *)v11 + 1) = *(void *)(v12 + 8);
      *(void *)(v12 + 8) = v14;
      do
        int v15 = *((_DWORD *)v11++ + 4);
      while (sub_1CD768B54(a3, v15, *((void *)v11 + 1), (uint64_t)&v18));
      do
      {
        int v16 = *(_DWORD *)(v12 - 16);
        v12 -= 16;
      }
      while (!sub_1CD768B54(a3, v16, *(void *)(v12 + 8), (uint64_t)&v18));
    }
    while ((unint64_t)v11 < v12);
  }
  BOOL result = (int *)(v11 - 1);
  if (v11 - 1 != (long long *)a1)
  {
    *a1 = *((_DWORD *)v11 - 4);
    *((void *)a1 + 1) = *((void *)v11 - 1);
  }
  *((_DWORD *)v11 - 4) = v18;
  *((void *)v11 - 1) = *((void *)&v18 + 1);
  return result;
}

BOOL sub_1CCD67F18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (sub_1CD768B54(a3, *(_DWORD *)(a2 - 16), *(void *)(a2 - 8), a1))
      {
        int v17 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v17;
        uint64_t v18 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v18;
      }
      return 1;
    case 3:
      sub_1CCD67B24(a1, a1 + 16, a2 - 16, a3);
      return 1;
    case 4:
      sub_1CCD68118(a1, a1 + 16, a1 + 32, a2 - 16, a3);
      return 1;
    case 5:
      sub_1CCD6820C(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16, a3);
      return 1;
    default:
      uint64_t v8 = a1 + 32;
      sub_1CCD67B24(a1, a1 + 16, a1 + 32, a3);
      uint64_t v9 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      break;
  }
  while (1)
  {
    if (sub_1CD768B54(a3, *(_DWORD *)v9, *(void *)(v9 + 8), v8))
    {
      int v12 = *(_DWORD *)v9;
      uint64_t v13 = *(void *)(v9 + 8);
      uint64_t v14 = v10;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        *(_DWORD *)(v15 + 48) = *(_DWORD *)(a1 + v14 + 32);
        *(void *)(v15 + 56) = *(void *)(a1 + v14 + 40);
        if (v14 == -32) {
          break;
        }
        v14 -= 16;
        if (!sub_1CD768B54(a3, v12, v13, v15 + 16))
        {
          uint64_t v16 = a1 + v14 + 48;
          goto LABEL_11;
        }
      }
      uint64_t v16 = a1;
LABEL_11:
      *(_DWORD *)uint64_t v16 = v12;
      *(void *)(v16 + 8) = v13;
      if (++v11 == 8) {
        return v9 + 16 == a2;
      }
    }
    uint64_t v8 = v9;
    v10 += 16;
    BOOL result = 1;
    v9 += 16;
    if (v9 == a2) {
      return result;
    }
  }
}

BOOL sub_1CCD68118(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1CCD67B24(a1, a2, a3, a5);
  BOOL result = sub_1CD768B54(a5, *(_DWORD *)a4, *(void *)(a4 + 8), a3);
  if (result)
  {
    int v11 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v11;
    uint64_t v12 = *(void *)(a3 + 8);
    *(void *)(a3 + 8) = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = v12;
    BOOL result = sub_1CD768B54(a5, *(_DWORD *)a3, *(void *)(a3 + 8), a2);
    if (result)
    {
      int v13 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v13;
      uint64_t v14 = *(void *)(a2 + 8);
      *(void *)(a2 + 8) = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = v14;
      BOOL result = sub_1CD768B54(a5, *(_DWORD *)a2, *(void *)(a2 + 8), a1);
      if (result)
      {
        int v15 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v15;
        uint64_t v16 = *(void *)(a1 + 8);
        *(void *)(a1 + 8) = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = v16;
      }
    }
  }
  return result;
}

BOOL sub_1CCD6820C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  sub_1CCD68118(a1, a2, a3, a4, a6);
  BOOL result = sub_1CD768B54(a6, *(_DWORD *)a5, *(void *)(a5 + 8), a4);
  if (result)
  {
    int v13 = *(_DWORD *)a4;
    *(_DWORD *)a4 = *(_DWORD *)a5;
    *(_DWORD *)a5 = v13;
    uint64_t v14 = *(void *)(a4 + 8);
    *(void *)(a4 + 8) = *(void *)(a5 + 8);
    *(void *)(a5 + 8) = v14;
    BOOL result = sub_1CD768B54(a6, *(_DWORD *)a4, *(void *)(a4 + 8), a3);
    if (result)
    {
      int v15 = *(_DWORD *)a3;
      *(_DWORD *)a3 = *(_DWORD *)a4;
      *(_DWORD *)a4 = v15;
      uint64_t v16 = *(void *)(a3 + 8);
      *(void *)(a3 + 8) = *(void *)(a4 + 8);
      *(void *)(a4 + 8) = v16;
      BOOL result = sub_1CD768B54(a6, *(_DWORD *)a3, *(void *)(a3 + 8), a2);
      if (result)
      {
        int v17 = *(_DWORD *)a2;
        *(_DWORD *)a2 = *(_DWORD *)a3;
        *(_DWORD *)a3 = v17;
        uint64_t v18 = *(void *)(a2 + 8);
        *(void *)(a2 + 8) = *(void *)(a3 + 8);
        *(void *)(a3 + 8) = v18;
        BOOL result = sub_1CD768B54(a6, *(_DWORD *)a2, *(void *)(a2 + 8), a1);
        if (result)
        {
          int v19 = *(_DWORD *)a1;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          *(_DWORD *)a2 = v19;
          uint64_t v20 = *(void *)(a1 + 8);
          *(void *)(a1 + 8) = *(void *)(a2 + 8);
          *(void *)(a2 + 8) = v20;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCD6833C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result != a2)
  {
    uint64_t v34 = v4;
    uint64_t v35 = v5;
    uint64_t v8 = a2;
    uint64_t v9 = result;
    uint64_t v10 = a2 - result;
    uint64_t v11 = (a2 - result) >> 4;
    if (a2 - result >= 17)
    {
      unint64_t v12 = (unint64_t)(v11 - 2) >> 1;
      unint64_t v13 = v12 + 1;
      uint64_t v14 = result + 16 * v12;
      do
      {
        BOOL result = sub_1CCD685BC(v9, a4, v11, v14);
        v14 -= 16;
        --v13;
      }
      while (v13);
    }
    if (v8 != a3)
    {
      uint64_t v15 = v8;
      do
      {
        BOOL result = sub_1CD768B54(a4, *(_DWORD *)v15, *(void *)(v15 + 8), v9);
        if (result)
        {
          int v16 = *(_DWORD *)v15;
          *(_DWORD *)uint64_t v15 = *(_DWORD *)v9;
          *(_DWORD *)uint64_t v9 = v16;
          uint64_t v17 = *(void *)(v15 + 8);
          *(void *)(v15 + 8) = *(void *)(v9 + 8);
          *(void *)(v9 + 8) = v17;
          BOOL result = sub_1CCD685BC(v9, a4, v11, v9);
        }
        v15 += 16;
      }
      while (v15 != a3);
    }
    if (v10 >= 17)
    {
      do
      {
        uint64_t v18 = 0;
        int v32 = *(_DWORD *)v9;
        uint64_t v19 = v9;
        uint64_t v20 = v11 - 2;
        uint64_t v31 = *(void *)(v9 + 8);
        if (v11 < 2) {
          uint64_t v20 = v11 - 1;
        }
        uint64_t v21 = v20 >> 1;
        do
        {
          uint64_t v22 = v19 + 16 * v18 + 16;
          uint64_t v23 = (2 * v18) | 1;
          uint64_t v24 = 2 * v18 + 2;
          if (v24 < v11)
          {
            BOOL result = sub_1CD768B54(a4, *(_DWORD *)v22, *(void *)(v19 + 16 * v18 + 24), v19 + 16 * v18 + 32);
            if (result)
            {
              v22 += 16;
              uint64_t v23 = v24;
            }
          }
          *(_DWORD *)uint64_t v19 = *(_DWORD *)v22;
          *(void *)(v19 + 8) = *(void *)(v22 + 8);
          uint64_t v19 = v22;
          uint64_t v18 = v23;
        }
        while (v23 <= v21);
        uint64_t v25 = v8 - 16;
        if (v22 == v8 - 16)
        {
          *(_DWORD *)uint64_t v22 = v32;
          *(void *)(v22 + 8) = v31;
        }
        else
        {
          *(_DWORD *)uint64_t v22 = *(_DWORD *)(v8 - 16);
          *(void *)(v22 + 8) = *(void *)(v8 - 8);
          *(_DWORD *)(v8 - 16) = v32;
          *(void *)(v8 - 8) = v31;
          uint64_t v26 = v22 - v9 + 16;
          if (v26 >= 17)
          {
            unint64_t v27 = (((unint64_t)v26 >> 4) - 2) >> 1;
            unint64_t v28 = v9 + 16 * v27;
            BOOL result = sub_1CD768B54(a4, *(_DWORD *)v28, *(void *)(v28 + 8), v22);
            if (result)
            {
              long long v33 = *(_OWORD *)v22;
              do
              {
                uint64_t v29 = v28;
                *(_DWORD *)uint64_t v22 = *(_DWORD *)v28;
                *(void *)(v22 + 8) = *(void *)(v28 + 8);
                if (!v27) {
                  break;
                }
                unint64_t v27 = (v27 - 1) >> 1;
                unint64_t v28 = v9 + 16 * v27;
                BOOL result = sub_1CD768B54(a4, *(_DWORD *)v28, *(void *)(v28 + 8), (uint64_t)&v33);
                uint64_t v22 = v29;
              }
              while ((result & 1) != 0);
              *(_DWORD *)uint64_t v29 = v33;
              *(void *)(v29 + 8) = *((void *)&v33 + 1);
            }
          }
        }
        uint64_t v8 = v25;
      }
      while (v11-- > 2);
    }
  }
  return result;
}

BOOL sub_1CCD685BC(BOOL result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    uint64_t v20 = v4;
    uint64_t v21 = v5;
    uint64_t v7 = a4;
    BOOL v8 = result;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= (a4 - result) >> 4)
    {
      uint64_t v12 = (a4 - result) >> 3;
      uint64_t v13 = v12 + 1;
      uint64_t v14 = result + 16 * (v12 + 1);
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3 && sub_1CD768B54(a2, *(_DWORD *)v14, *(void *)(v14 + 8), v14 + 16))
      {
        v14 += 16;
        uint64_t v13 = v15;
      }
      BOOL result = sub_1CD768B54(a2, *(_DWORD *)v14, *(void *)(v14 + 8), v7);
      if (!result)
      {
        long long v19 = *(_OWORD *)v7;
        do
        {
          uint64_t v16 = v14;
          *(_DWORD *)uint64_t v7 = *(_DWORD *)v14;
          *(void *)(v7 + 8) = *(void *)(v14 + 8);
          if (v9 < v13) {
            break;
          }
          uint64_t v17 = (2 * v13) | 1;
          uint64_t v14 = v8 + 16 * v17;
          uint64_t v18 = 2 * v13 + 2;
          if (v18 < a3 && sub_1CD768B54(a2, *(_DWORD *)v14, *(void *)(v14 + 8), v14 + 16))
          {
            v14 += 16;
            uint64_t v17 = v18;
          }
          BOOL result = sub_1CD768B54(a2, *(_DWORD *)v14, *(void *)(v14 + 8), (uint64_t)&v19);
          uint64_t v7 = v16;
          uint64_t v13 = v17;
        }
        while (!result);
        *(_DWORD *)uint64_t v16 = v19;
        *(void *)(v16 + 8) = *((void *)&v19 + 1);
      }
    }
  }
  return result;
}

uint64_t sub_1CCD68718(uint64_t a1)
{
  sub_1CD3C5048(a1 + 584, *(void **)(a1 + 592));
  int v2 = *(void **)(a1 + 504);
  if (v2 != (void *)(a1 + 520)) {
    free(v2);
  }
  int v3 = *(void **)(a1 + 416);
  if (v3 != *(void **)(a1 + 408)) {
    free(v3);
  }
  sub_1CC0BD0FC((char **)(a1 + 8));
  return a1;
}

__n128 sub_1CCD6877C(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, uint64_t a5, __n128 result)
{
  if (a3 < 2) {
    return result;
  }
  if (a3 == 2)
  {
    unsigned __int32 v8 = a2[-2].n128_u32[0];
    unsigned __int32 v9 = a1->n128_u32[0];
    if (v8 >= a1->n128_u32[0])
    {
      if (v9 < v8) {
        return result;
      }
      unint64_t v11 = a2[-2].n128_u64[1];
      unint64_t v10 = a1->n128_u64[1];
      if (v11 >= v10) {
        return result;
      }
    }
    else
    {
      unint64_t v10 = a1->n128_u64[1];
      unint64_t v11 = a2[-2].n128_u64[1];
    }
    BOOL result = a1[1];
    a1->n128_u32[0] = v8;
    a1->n128_u64[1] = v11;
    a1[1] = a2[-1];
    a2[-2].n128_u32[0] = v9;
    a2[-2].n128_u64[1] = v10;
    a2[-1] = result;
    return result;
  }
  if ((uint64_t)a3 <= 0)
  {
    if (a1 == a2) {
      return result;
    }
    uint64_t v18 = a1 + 2;
    if (&a1[2] == a2) {
      return result;
    }
    uint64_t v19 = 0;
    uint64_t v20 = a1;
    while (1)
    {
      uint64_t v21 = v20;
      uint64_t v20 = v18;
      unsigned __int32 v22 = v21[2].n128_u32[0];
      if (v22 >= v21->n128_u32[0])
      {
        if (v21->n128_u32[0] < v22) {
          goto LABEL_31;
        }
        unint64_t v23 = v21[2].n128_u64[1];
        if (v23 >= v21->n128_u64[1]) {
          goto LABEL_31;
        }
      }
      else
      {
        unint64_t v23 = v21[2].n128_u64[1];
      }
      __n128 v44 = v21[3];
      v21[2].n128_u32[0] = v21->n128_u32[0];
      v20->n128_u64[1] = v21->n128_u64[1];
      uint64_t v24 = v21 + 1;
      v20[1] = v21[1];
      if (v21 == a1) {
        goto LABEL_29;
      }
      uint64_t v25 = v19;
      while (1)
      {
        unsigned __int32 v26 = *(unsigned __int32 *)((char *)a1[-2].n128_u32 + v25);
        if (v22 >= v26) {
          break;
        }
        unint64_t v27 = *(void *)((char *)&a1[-1] + v25 - 8);
LABEL_27:
        uint64_t v24 = v21 - 1;
        v21 -= 2;
        unint64_t v28 = (__n128 *)((char *)a1 + v25);
        v28->n128_u32[0] = v26;
        v28->n128_u64[1] = v27;
        v28[1] = *(__n128 *)((char *)a1 + v25 - 16);
        v25 -= 32;
        if (!v25)
        {
          uint64_t v24 = a1 + 1;
LABEL_29:
          uint64_t v21 = a1;
          goto LABEL_30;
        }
      }
      if (v26 < v22) {
        goto LABEL_30;
      }
      unint64_t v27 = *(void *)((char *)&a1[-1] + v25 - 8);
      if (v23 < v27) {
        goto LABEL_27;
      }
      uint64_t v24 = (__n128 *)((char *)a1 + v25 + 16);
      uint64_t v21 = (__n128 *)((char *)a1 + v25);
LABEL_30:
      v21->n128_u32[0] = v22;
      v21->n128_u64[1] = v23;
      BOOL result = v44;
      __n128 *v24 = v44;
LABEL_31:
      uint64_t v18 = v20 + 2;
      v19 += 32;
      if (&v20[2] == a2) {
        return result;
      }
    }
  }
  uint64_t v14 = a4;
  unint64_t v15 = a3 >> 1;
  uint64_t v16 = &a1[2 * (a3 >> 1)];
  unint64_t v17 = a3 >> 1;
  if ((uint64_t)a3 > a5)
  {
    sub_1CCD6877C(a1, v16, v17, a4, a5);
    sub_1CCD6877C(&a1[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v14, a5);
    result.n128_u64[0] = sub_1CCD68D94(a1, &a1[2 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v14, a5).n128_u64[0];
    return result;
  }
  __n128 v29 = sub_1CCD68AF0(a1, v16, v17, a4, result);
  unint64_t v30 = &v14[2 * v15];
  result.n128_u64[0] = sub_1CCD68AF0(&a1[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v30, v29).n128_u64[0];
  uint64_t v31 = &v14[2 * a3];
  int v32 = a1 + 1;
  long long v33 = v30;
  while (v33 != v31)
  {
    unsigned __int32 v34 = v33->n128_u32[0];
    unsigned __int32 v35 = v14->n128_u32[0];
    if (v33->n128_u32[0] >= v14->n128_u32[0])
    {
      if (v35 < v34)
      {
        unint64_t v37 = v14->n128_u64[1];
LABEL_42:
        v32[-1].n128_u32[0] = v35;
        v32[-1].n128_u64[1] = v37;
        BOOL result = v14[1];
        __n128 *v32 = result;
        v14 += 2;
        goto LABEL_43;
      }
      unint64_t v36 = v33->n128_u64[1];
      unint64_t v37 = v14->n128_u64[1];
      if (v36 >= v37) {
        goto LABEL_42;
      }
    }
    else
    {
      unint64_t v36 = v33->n128_u64[1];
    }
    v32[-1].n128_u32[0] = v34;
    v32[-1].n128_u64[1] = v36;
    BOOL result = v33[1];
    __n128 *v32 = result;
    v33 += 2;
LABEL_43:
    v32 += 2;
    if (v14 == v30)
    {
      if (v33 != v31)
      {
        uint64_t v38 = 0;
        do
        {
          int v39 = &v33[v38];
          char v40 = &v32[v38];
          v40[-1].n128_u32[0] = v33[v38].n128_u32[0];
          v40[-1].n128_u64[1] = v33[v38].n128_u64[1];
          BOOL result = v33[v38 + 1];
          __n128 *v40 = result;
          v38 += 2;
        }
        while (&v39[2] != v31);
      }
      return result;
    }
  }
  if (v14 != v30)
  {
    uint64_t v41 = 0;
    do
    {
      uint64_t v42 = &v32[v41];
      uint64_t v43 = &v14[v41];
      v42[-1].n128_u32[0] = v14[v41].n128_u32[0];
      v42[-1].n128_u64[1] = v14[v41].n128_u64[1];
      BOOL result = v14[v41 + 1];
      __n128 *v42 = result;
      v41 += 2;
    }
    while (&v43[2] != v30);
  }
  return result;
}

__n128 sub_1CCD68AF0(__n128 *a1, __n128 *a2, unint64_t a3, __n128 *a4, __n128 result)
{
  if (!a3) {
    return result;
  }
  uint64_t v5 = a4;
  unsigned __int32 v8 = a1;
  if (a3 == 2)
  {
    unint64_t v10 = a2 - 2;
    unsigned int v11 = a2[-2].n128_u32[0];
    if (v11 < a1->n128_u32[0] || a1->n128_u32[0] >= v11 && a2[-2].n128_u64[1] < a1->n128_u64[1])
    {
      __n128 v12 = a2[-1];
      *a4 = *v10;
      a4[1] = v12;
      BOOL result = *a1;
      __n128 v13 = a1[1];
    }
    else
    {
      __n128 v30 = a1[1];
      *a4 = *a1;
      a4[1] = v30;
      BOOL result = *v10;
      __n128 v13 = a2[-1];
    }
    a4[2] = result;
    a4[3] = v13;
    return result;
  }
  if (a3 == 1)
  {
    BOOL result = *a1;
    __n128 v9 = a1[1];
    *a4 = *a1;
    a4[1] = v9;
    return result;
  }
  if ((uint64_t)a3 <= 8)
  {
    if (a1 == a2) {
      return result;
    }
    BOOL result = *a1;
    __n128 v14 = a1[1];
    *a4 = *a1;
    a4[1] = v14;
    unint64_t v15 = a1 + 2;
    if (&a1[2] == a2) {
      return result;
    }
    uint64_t v16 = 0;
    unint64_t v17 = a4;
    uint64_t v18 = (unsigned int *)a4;
    while (1)
    {
      uint64_t v19 = v15;
      unsigned int v21 = *v18;
      v18 += 8;
      unsigned int v20 = v21;
      unsigned int v22 = v8[2].n128_u32[0];
      if (v22 >= v21 && (v20 < v22 || v8[2].n128_u64[1] >= v17->n128_u64[1]))
      {
        BOOL result = *v19;
        __n128 v29 = v19[1];
        *(__n128 *)uint64_t v18 = *v19;
        *((__n128 *)v18 + 1) = v29;
        goto LABEL_25;
      }
      __n128 v23 = v17[1];
      *(__n128 *)uint64_t v18 = *v17;
      *((__n128 *)v18 + 1) = v23;
      uint64_t v24 = a4;
      if (v17 == a4) {
        goto LABEL_24;
      }
      uint64_t v25 = v16;
      while (1)
      {
        unsigned int v26 = *(unsigned __int32 *)((char *)a4[-2].n128_u32 + v25);
        if (v19->n128_u32[0] >= v26) {
          break;
        }
        unint64_t v27 = *(void *)((char *)&a4[-1] + v25 - 8);
LABEL_18:
        v17 -= 2;
        unint64_t v28 = (__n128 *)((char *)a4 + v25);
        v28->n128_u32[0] = v26;
        v28->n128_u64[1] = v27;
        v28[1] = *(__n128 *)((char *)a4 + v25 - 16);
        v25 -= 32;
        if (!v25)
        {
          uint64_t v24 = a4;
          goto LABEL_24;
        }
      }
      if (v26 >= v19->n128_u32[0]) {
        break;
      }
      uint64_t v24 = v17;
LABEL_24:
      v24->n128_u32[0] = v19->n128_u32[0];
      v24->n128_u64[1] = v8[2].n128_u64[1];
      BOOL result = v8[3];
      v24[1] = result;
LABEL_25:
      unint64_t v15 = v19 + 2;
      v16 += 32;
      unint64_t v17 = (__n128 *)v18;
      unsigned __int32 v8 = v19;
      if (&v19[2] == a2) {
        return result;
      }
    }
    uint64_t v24 = (__n128 *)((char *)a4 + v25);
    unint64_t v27 = *(void *)((char *)&a4[-1] + v25 - 8);
    if (v8[2].n128_u64[1] >= v27) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }
  uint64_t v31 = &a1[2 * (a3 >> 1)];
  sub_1CCD6877C(a1, v31, a3 >> 1, a4, a3 >> 1);
  sub_1CCD6877C(&v8[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), &v5[2 * (a3 >> 1)], a3 - (a3 >> 1));
  int v32 = &v8[2 * (a3 >> 1)];
  while (v32 != a2)
  {
    if (v32->n128_u32[0] >= v8->n128_u32[0]
      && (v8->n128_u32[0] < v32->n128_u32[0] || v32->n128_u64[1] >= v8->n128_u64[1]))
    {
      BOOL result = *v8;
      __n128 v33 = v8[1];
      v8 += 2;
    }
    else
    {
      BOOL result = *v32;
      __n128 v33 = v32[1];
      v32 += 2;
    }
    *uint64_t v5 = result;
    v5[1] = v33;
    v5 += 2;
    if (v8 == v31)
    {
      if (v32 != a2)
      {
        unint64_t v34 = 0;
        do
        {
          unsigned __int32 v35 = (int *)&v5[v34];
          BOOL result = v32[v34];
          __n128 v36 = (__int128)v32[v34 + 1];
          *(__n128 *)unsigned __int32 v35 = result;
          *((_OWORD *)v35 + 1) = v36;
          v34 += 2;
        }
        while (&v32[v34] != a2);
      }
      return result;
    }
  }
  if (v8 != v31)
  {
    unint64_t v37 = 0;
    do
    {
      uint64_t v38 = (int *)&v5[v37];
      BOOL result = v8[v37];
      __n128 v39 = v8[v37 + 1];
      *(__n128 *)uint64_t v38 = result;
      *((__n128 *)v38 + 1) = v39;
      v37 += 2;
    }
    while (&v8[v37] != v31);
  }
  return result;
}

__n128 sub_1CCD68D94(__n128 *a1, __n128 *a2, __n128 *a3, uint64_t a4, uint64_t a5, __n128 *a6, uint64_t a7)
{
  if (!a5) {
    return result;
  }
  do
  {
    if (a4 <= a7 || a5 <= a7)
    {
      if (a4 > a5)
      {
        if (a2 == a3) {
          return result;
        }
        uint64_t v42 = 0;
        do
        {
          uint64_t v43 = &a6[v42];
          __n128 result = a2[v42];
          __n128 v44 = a2[v42 + 1];
          __n128 *v43 = result;
          v43[1] = v44;
          v42 += 2;
        }
        while (&a2[v42] != a3);
        if (!(v42 * 16)) {
          return result;
        }
        unsigned int v45 = &a6[v42];
        while (1)
        {
          if (a2 == a1)
          {
            if (v45 != a6)
            {
              uint64_t v61 = 0;
              do
              {
                int v62 = &a3[v61];
                v62[-2].n128_u32[0] = v45[v61 - 2].n128_u32[0];
                v62[-2].n128_u64[1] = *((void *)&v45[v61 - 1] - 1);
                __n128 result = v45[v61 - 1];
                v62[-1] = result;
                v61 -= 2;
              }
              while (&v45[v61] != a6);
            }
            return result;
          }
          unsigned __int32 v46 = a2[-2].n128_u32[0];
          unsigned __int32 v47 = v45[-2].n128_u32[0];
          if (v47 >= v46)
          {
            if (v46 < v47 || (unint64_t v48 = a2[-2].n128_u64[1], v45[-2].n128_u64[1] >= v48))
            {
              unsigned __int32 v46 = v45[-2].n128_u32[0];
              unint64_t v48 = v45[-2].n128_u64[1];
              uint64_t v49 = v45;
              v45 -= 2;
              goto LABEL_69;
            }
          }
          else
          {
            unint64_t v48 = a2[-2].n128_u64[1];
          }
          uint64_t v49 = a2;
          a2 -= 2;
LABEL_69:
          a3[-2].n128_u32[0] = v46;
          a3 -= 2;
          a3->n128_u64[1] = v48;
          __n128 result = v49[-1];
          a3[1] = result;
          if (v45 == a6) {
            return result;
          }
        }
      }
      if (a1 == a2) {
        return result;
      }
      uint64_t v50 = 0;
      do
      {
        uint64_t v51 = &a6[v50];
        __n128 result = a1[v50];
        __n128 v52 = a1[v50 + 1];
        __n128 *v51 = result;
        v51[1] = v52;
        v50 += 2;
      }
      while (&a1[v50] != a2);
      if (!(v50 * 16)) {
        return result;
      }
      uint64_t v53 = &a6[v50];
      uint64_t v54 = (uint64_t)&a6[v50 - 2];
      while (1)
      {
        if (a2 == a3)
        {
          if (v53 != a6)
          {
            uint64_t v63 = 0;
            do
            {
              int v64 = &a1[v63];
              int v65 = &a6[v63];
              v64->n128_u32[0] = a6[v63].n128_u32[0];
              v64->n128_u64[1] = a6[v63].n128_u64[1];
              __n128 result = a6[v63 + 1];
              v64[1] = result;
              v63 += 2;
            }
            while ((__n128 *)v54 != v65);
          }
          return result;
        }
        unsigned __int32 v55 = a2->n128_u32[0];
        unsigned __int32 v56 = a6->n128_u32[0];
        if (a2->n128_u32[0] >= a6->n128_u32[0])
        {
          if (v56 < v55)
          {
            unint64_t v58 = a6->n128_u64[1];
LABEL_83:
            a1->n128_u32[0] = v56;
            a1->n128_u64[1] = v58;
            __n128 result = a6[1];
            a1[1] = result;
            a6 += 2;
            goto LABEL_84;
          }
          unint64_t v57 = a2->n128_u64[1];
          unint64_t v58 = a6->n128_u64[1];
          if (v57 >= v58) {
            goto LABEL_83;
          }
        }
        else
        {
          unint64_t v57 = a2->n128_u64[1];
        }
        a1->n128_u32[0] = v55;
        a1->n128_u64[1] = v57;
        __n128 result = a2[1];
        a1[1] = result;
        a2 += 2;
LABEL_84:
        a1 += 2;
        if (v53 == a6) {
          return result;
        }
      }
    }
    if (!a4) {
      return result;
    }
    uint64_t v9 = 0;
    unsigned __int32 v10 = a2->n128_u32[0];
    uint64_t v11 = -a4;
    while (1)
    {
      unsigned __int32 v12 = a1[v9].n128_u32[0];
      if (v10 < v12 || v12 >= v10 && a2->n128_u64[1] < a1[v9].n128_u64[1]) {
        break;
      }
      v9 += 2;
      if (__CFADD__(v11++, 1)) {
        return result;
      }
    }
    __n128 v14 = &a1[v9];
    if (-v11 >= a5)
    {
      if (v11 == -1)
      {
        uint64_t v59 = &a1[v9];
        unint64_t v60 = a1[v9].n128_u64[1];
        __n128 v68 = v59[1];
        v59->n128_u32[0] = a2->n128_u32[0];
        v59->n128_u64[1] = a2->n128_u64[1];
        v59[1] = a2[1];
        a2->n128_u32[0] = v12;
        a2->n128_u64[1] = v60;
        __n128 result = v68;
        a2[1] = v68;
        return result;
      }
      if (v11 <= 0) {
        uint64_t v24 = -v11;
      }
      else {
        uint64_t v24 = 1 - v11;
      }
      uint64_t v23 = v24 >> 1;
      uint64_t v18 = &a1[2 * (v24 >> 1) + v9];
      unint64_t v17 = a3;
      if (a3 != a2)
      {
        unint64_t v25 = ((char *)a3 - (char *)a2) >> 5;
        unsigned __int32 v26 = v18->n128_u32[0];
        unint64_t v17 = a2;
        do
        {
          unint64_t v27 = v25 >> 1;
          unint64_t v28 = &v17[2 * (v25 >> 1)];
          if (v28->n128_u32[0] < v26 || v26 >= v28->n128_u32[0] && v28->n128_u64[1] < v18->n128_u64[1])
          {
            unint64_t v17 = v28 + 2;
            unint64_t v27 = v25 + ~v27;
          }
          unint64_t v25 = v27;
        }
        while (v27);
      }
      uint64_t v16 = ((char *)v17 - (char *)a2) >> 5;
    }
    else
    {
      if (a5 >= 0) {
        uint64_t v15 = a5;
      }
      else {
        uint64_t v15 = a5 + 1;
      }
      uint64_t v16 = v15 >> 1;
      unint64_t v17 = &a2[2 * (v15 >> 1)];
      uint64_t v18 = a2;
      if (v14 != a2)
      {
        unint64_t v19 = ((char *)a2 - (char *)a1 - v9 * 16) >> 5;
        unsigned __int32 v20 = v17->n128_u32[0];
        uint64_t v18 = &a1[v9];
        do
        {
          unint64_t v21 = v19 >> 1;
          unsigned int v22 = &v18[2 * (v19 >> 1)];
          if (v20 >= v22->n128_u32[0] && (v22->n128_u32[0] < v20 || v17->n128_u64[1] >= v22->n128_u64[1]))
          {
            uint64_t v18 = v22 + 2;
            unint64_t v21 = v19 + ~v21;
          }
          unint64_t v19 = v21;
        }
        while (v21);
      }
      uint64_t v23 = ((char *)v18 - (char *)a1 - v9 * 16) >> 5;
    }
    __n128 v29 = v17;
    if (v18 != a2)
    {
      __n128 v29 = v18;
      if (a2 != v17)
      {
        __n128 v30 = v18 + 2;
        __n128 v29 = a2;
        while (1)
        {
          unsigned __int32 v31 = v30[-2].n128_u32[0];
          unint64_t v32 = v30[-2].n128_u64[1];
          __n128 v66 = v30[-1];
          v30[-2].n128_u32[0] = a2->n128_u32[0];
          v30[-2].n128_u64[1] = a2->n128_u64[1];
          v30[-1] = a2[1];
          a2->n128_u32[0] = v31;
          a2->n128_u64[1] = v32;
          a2[1] = v66;
          a2 += 2;
          if (a2 == v17) {
            break;
          }
          if (v30 == v29) {
            __n128 v29 = a2;
          }
          v30 += 2;
        }
        if (v30 != v29)
        {
          __n128 v33 = v30;
          unint64_t v34 = v29;
          do
          {
            while (1)
            {
              unsigned __int32 v35 = v33->n128_u32[0];
              unint64_t v36 = v33->n128_u64[1];
              __n128 v67 = v33[1];
              v33->n128_u32[0] = v29->n128_u32[0];
              v33->n128_u64[1] = v29->n128_u64[1];
              v33[1] = v29[1];
              v29->n128_u32[0] = v35;
              v29->n128_u64[1] = v36;
              v29[1] = v67;
              v33 += 2;
              v29 += 2;
              if (v29 == v17) {
                break;
              }
              if (v33 == v34) {
                unint64_t v34 = v29;
              }
            }
            __n128 v29 = v34;
          }
          while (v33 != v34);
          __n128 v29 = v30;
        }
      }
    }
    a4 = -v23 - v11;
    uint64_t v37 = a5 - v16;
    if (v23 + v16 >= a5 - (v23 + v16) - v11)
    {
      char v40 = a6;
      sub_1CCD68D94(v29, v17, a3, a4, a5 - v16, a6, a7);
      unint64_t v17 = v18;
      uint64_t v37 = v16;
      a4 = v23;
      a3 = v29;
    }
    else
    {
      uint64_t v38 = v14;
      __n128 v39 = a3;
      char v40 = a6;
      sub_1CCD68D94(v38, v18, v29, v23, v16, a6, a7);
      a3 = v39;
      __n128 v14 = v29;
    }
    a5 = v37;
    a1 = v14;
    a2 = v17;
    a6 = v40;
  }
  while (v37);
  return result;
}

uint64_t sub_1CCD692EC()
{
  int v4 = 1;
  int v2 = -1;
  int v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Max number of instructions to hoist (default unlimited = -1)";
  v1.n128_u64[1] = 60;
  sub_1CD769CD8(&v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBCF1FD0, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 4;
  int v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Max number of basic blocks on the path between hoisting locations (default = 4, unlimited = -1)";
  v1.n128_u64[1] = 95;
  sub_1CD4954D8((llvm::cl::Option *)&unk_1EBCF2090, "gvn-hoist-max-bbs", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &unk_1EBCF2090, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 100;
  int v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Hoist instructions from the beginning of the BB up to the maximum specified depth ("
                                     "default = 100, unlimited = -1)";
  v1.n128_u64[1] = 113;
  sub_1CD4954D8((llvm::cl::Option *)&unk_1EBCF2150, "gvn-hoist-max-depth", &v4, &v3, &v1);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &unk_1EBCF2150, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 10;
  int v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Maximum length of dependent chains to hoist (default = 10, unlimited = -1)";
  v1.n128_u64[1] = 74;
  sub_1CD769E50(&v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBCF2210, &dword_1CB82C000);
}

BOOL sub_1CCD69468(size_t a1, void *a2)
{
  v499[4] = *MEMORY[0x1E4F143B8];
  long long v466 = a2;
  uint64_t v442 = 0;
  uint64_t v443 = 0;
  uint64_t v441 = 0;
  sub_1CC86D39C((char **)&v441, (uint64_t)&v466);
  int v2 = v442;
  unint64_t v437 = (char *)v441;
  if (v442 != v441)
  {
    int v3 = 0;
    int64x2_t v423 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
LABEL_3:
    uint64_t v5 = *((void *)v2 - 1);
    v2 -= 8;
    uint64_t v4 = v5;
    __base = v482;
    uint64_t v481 = 0x400000000;
    uint64_t v6 = *(void *)(v5 + 8);
    if (!v6) {
      goto LABEL_41;
    }
    uint64_t v438 = v4;
    while (1)
    {
      uint64_t v7 = *(void *)(v6 + 24);
      unsigned int v8 = *(unsigned __int8 *)(v7 + 16);
      BOOL v9 = v7 && v8 >= 0x1C;
      BOOL v10 = !v9 || v8 - 29 > 0xA;
      if (!v10) {
        break;
      }
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6) {
        goto LABEL_41;
      }
    }
    uint64_t v11 = *(void *)(v7 + 40);
    uint64_t v12 = *(void *)(v11 + 40);
    if (v12) {
      uint64_t v13 = v12 - 24;
    }
    else {
      uint64_t v13 = 0;
    }
    if (*(unsigned __int8 *)(v13 + 16) - 29 >= 0xB) {
      uint64_t v13 = 0;
    }
    if ((*(unsigned char *)(v13 + 16) & 0xFE) != 0x1E) {
      goto LABEL_41;
    }
    LODWORD(v14) = 0;
LABEL_22:
    if (v14 >= HIDWORD(v481)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)__base + v14) = v11;
    size_t v14 = (v481 + 1);
    LODWORD(v481) = v481 + 1;
    while (1)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      if (!v6) {
        break;
      }
      uint64_t v15 = *(void *)(v6 + 24);
      unsigned int v16 = *(unsigned __int8 *)(v15 + 16);
      if (v15) {
        BOOL v17 = v16 >= 0x1C;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17 && v16 - 29 <= 0xA)
      {
        int v19 = 0;
        uint64_t v11 = *(void *)(v15 + 40);
        uint64_t v20 = *(void *)(v11 + 40);
        if (v20) {
          uint64_t v21 = v20 - 24;
        }
        else {
          uint64_t v21 = 0;
        }
        if (*(unsigned __int8 *)(v21 + 16) - 29 >= 0xB) {
          uint64_t v21 = 0;
        }
        if ((*(unsigned char *)(v21 + 16) & 0xFE) != 0x1E) {
          goto LABEL_42;
        }
        goto LABEL_22;
      }
    }
    if (v14 < 2)
    {
LABEL_41:
      int v19 = 0;
      goto LABEL_42;
    }
    qsort(__base, v14, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CB848318);
    LODWORD(v22) = v481;
    uint64_t v23 = (void **)__base;
    unsigned int __p = v481;
    if (v481)
    {
      uint64_t v24 = (char *)__base;
      do
      {
        uint64_t v25 = *(void *)(*(void *)v24 + 40);
        if (v25 == *(void *)v24 + 40)
        {
          uint64_t v26 = 0;
        }
        else
        {
          if (v25) {
            uint64_t v26 = v25 - 24;
          }
          else {
            uint64_t v26 = 0;
          }
          if (*(unsigned __int8 *)(v26 + 16) - 29 >= 0xB) {
            uint64_t v26 = 0;
          }
        }
        if (*(unsigned char *)(v26 + 16) == 30)
        {
          if ((*(_DWORD *)(v26 + 20) & 0x7FFFFFF) == 3)
          {
LABEL_59:
            unint64_t v27 = v24 + 8;
LABEL_60:
            unint64_t v28 = (char *)&v23[v22];
            if (v28 != v27)
            {
              memmove(v24, v27, v28 - v27);
              LODWORD(v22) = v481;
              uint64_t v23 = (void **)__base;
            }
            LODWORD(v22) = v22 - 1;
            LODWORD(v481) = v22;
          }
          else
          {
LABEL_67:
            v24 += 8;
          }
        }
        else
        {
          switch(*(unsigned char *)(v26 + 16))
          {
            case 0x1E:
              __break(1u);
              goto LABEL_867;
            case 0x1F:
              int v29 = (*(_DWORD *)(v26 + 20) >> 1) & 0x3FFFFFF;
              goto LABEL_65;
            case 0x20:
            case 0x26:
              int v29 = (*(_DWORD *)(v26 + 20) & 0x7FFFFFF) - 1;
              goto LABEL_65;
            case 0x24:
              int v29 = *(_WORD *)(v26 + 18) & 1;
              goto LABEL_65;
            case 0x25:
              goto LABEL_67;
            case 0x27:
              int v29 = *(_DWORD *)(v26 + 80) + 1;
LABEL_65:
              unint64_t v27 = v24 + 8;
              if (v29 != 1) {
                goto LABEL_60;
              }
              v24 += 8;
              break;
            default:
              goto LABEL_59;
          }
        }
      }
      while (v24 != (char *)&v23[v22]);
      uint64_t v22 = v22;
    }
    else
    {
      uint64_t v22 = 0;
    }
    long long v469 = v23;
    uint64_t v470 = v22;
    uint64_t v471 = 1;
    v472[0] = v423;
    v472[1] = v423;
    long long v473 = v475;
    uint64_t v474 = 0x400000000;
    unint64_t v476 = v478;
    uint64_t v477 = 0x400000000;
    char v479 = 0;
    sub_1CD646000(&v471);
    LODWORD(v474) = 0;
    if (!v470)
    {
      LODWORD(v477) = 0;
      goto LABEL_123;
    }
    __n128 v30 = v469;
    unsigned __int32 v31 = &v469[v470];
    while (1)
    {
      long long v466 = 0;
      unint64_t v32 = *v30;
      long long v466 = *v30;
      if (v471)
      {
        int v33 = 4;
        unint64_t v34 = v472;
      }
      else
      {
        int v33 = DWORD2(v472[0]);
        if (!DWORD2(v472[0]))
        {
          uint64_t v43 = 0;
LABEL_90:
          __n128 v44 = sub_1CC875030((uint64_t)&v471, (uint64_t)&v466, &v466, v43);
          void *v44 = v466;
          if (v474 >= (unint64_t)HIDWORD(v474)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v473 + v474) = v466;
          LODWORD(v474) = v474 + 1;
          goto LABEL_92;
        }
        unint64_t v34 = *(_OWORD **)&v472[0];
      }
      int v35 = v33 - 1;
      unsigned int v36 = v35 & ((v32 >> 4) ^ (v32 >> 9));
      uint64_t v37 = (void *)v34 + v36;
      uint64_t v38 = (void *)*v37;
      if (v32 != (void *)*v37)
      {
        __n128 v39 = 0;
        int v40 = 1;
        while (v38 != (void *)-4096)
        {
          if (v39) {
            BOOL v41 = 0;
          }
          else {
            BOOL v41 = v38 == (void *)-8192;
          }
          if (v41) {
            __n128 v39 = v37;
          }
          unsigned int v42 = v36 + v40++;
          unsigned int v36 = v42 & v35;
          uint64_t v37 = (void *)v34 + v36;
          uint64_t v38 = (void *)*v37;
          if (v32 == (void *)*v37) {
            goto LABEL_92;
          }
        }
        if (v39) {
          uint64_t v43 = v39;
        }
        else {
          uint64_t v43 = v37;
        }
        goto LABEL_90;
      }
LABEL_92:
      if (++v30 == v31)
      {
        unsigned int v45 = v469;
        LODWORD(v477) = 0;
        if (!v470) {
          goto LABEL_123;
        }
        unsigned __int32 v46 = &v469[v470];
        do
        {
          long long v466 = 0;
          long long v466 = *v45;
          unsigned __int32 v47 = (char *)v466 + 40;
          unint64_t v48 = -1;
          uint64_t v49 = (char *)v466 + 40;
          do
          {
            uint64_t v49 = (char *)*((void *)v49 + 1);
            ++v48;
          }
          while (v49 != v47);
          if (v48 <= 1)
          {
            sub_1CD76A7FC((uint64_t)&v471, &v466);
          }
          else
          {
            uint64_t v50 = *(void *)v47;
            if (v50) {
              uint64_t v51 = v50 - 24;
            }
            else {
              uint64_t v51 = 0;
            }
            if (*(unsigned __int8 *)(v51 + 16) - 29 >= 0xB) {
              uint64_t v52 = 0;
            }
            else {
              uint64_t v52 = v51;
            }
            if (*(void *)(*(void *)(v52 + 40) + 48) == v52 + 24)
            {
              uint64_t v54 = 0;
            }
            else
            {
              uint64_t v53 = *(void *)(v52 + 24);
              if (v53) {
                uint64_t v54 = v53 - 24;
              }
              else {
                uint64_t v54 = 0;
              }
            }
            if (v477 >= (unint64_t)HIDWORD(v477)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v476 + v477) = v54;
            LODWORD(v477) = v477 + 1;
          }
          ++v45;
        }
        while (v45 != v46);
        if (!v477) {
LABEL_123:
        }
          char v479 = 1;
        int v428 = v3;
        long long v466 = v468;
        uint64_t v467 = 0x400000000;
        unint64_t v449 = 0;
        int32x2_t v450 = 0;
        unsigned int v451 = 0;
        unint64_t v444 = v448;
        unint64_t v445 = v448;
        uint64_t v446 = 4;
        int v447 = 0;
        if (*(void *)(v438 + 40) == v438 + 40)
        {
          __int32 v55 = 0;
        }
        else
        {
          __int32 v55 = 0;
          uint64_t v56 = *(void *)(v438 + 48);
          uint64_t v57 = v56 - 24;
          if (v56) {
            uint64_t v58 = v56 - 24;
          }
          else {
            uint64_t v58 = 0;
          }
          if (v56 && *(unsigned char *)(v58 + 16) == 83)
          {
            while (1)
            {
              __src[0] = &v490;
              __src[1] = (void *)0x400000000;
              long long __dst = v496;
              uint64_t v495 = 0x400000000;
              uint64_t v59 = &v484;
              v483[0] = &v484;
              v483[1] = (void *)0x400000000;
              int v60 = *(_DWORD *)(v57 + 20);
              uint64_t v61 = v60 & 0x7FFFFFF;
              if ((v60 & 0x7FFFFFF) == 0) {
                break;
              }
              uint64_t v62 = 0;
              uint64_t v63 = 0;
              LODWORD(v64) = 0;
              uint64_t v65 = 8 * v61;
              do
              {
                int v66 = *(_DWORD *)(v57 + 20);
                if ((v66 & 0x40000000) != 0) {
                  uint64_t v67 = *(void *)(v57 - 8);
                }
                else {
                  uint64_t v67 = v57 - 32 * (v66 & 0x7FFFFFF);
                }
                uint64_t v68 = *(void *)(v67 + v62);
                if (v64 >= HIDWORD(v483[1])) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                unsigned int v69 = (char *)v483[0] + 16 * v64;
                void *v69 = *(void *)(v67 + 32 * *(unsigned int *)(v57 + 60) + v63);
                v69[1] = v68;
                unint64_t v64 = ++LODWORD(v483[1]);
                v63 += 8;
                v62 += 32;
              }
              while (v65 != v63);
              uint64_t v59 = (long long *)v483[0];
              int v70 = (unint64_t *)((char *)v483[0] + 16 * v64);
              if (!v64) {
                goto LABEL_142;
              }
              uint64_t v71 = 126 - 2 * __clz(v64);
LABEL_143:
              sub_1CC63E95C((uint64_t)v59, v70, (uint64_t)v460, v71, 1);
              int v72 = (char *)v483[0];
              unsigned int v73 = (char *)v483[0] + 16 * LODWORD(v483[1]);
              if (LODWORD(v483[1]))
              {
                do
                {
                  if (v495 >= (unint64_t)HIDWORD(v495)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__dst + v495) = *(void *)v72;
                  LODWORD(v495) = v495 + 1;
                  if (LODWORD(__src[1]) >= (unint64_t)HIDWORD(__src[1])) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__src[0] + LODWORD(__src[1])) = *((void *)v72 + 1);
                  ++LODWORD(__src[1]);
                  v72 += 16;
                }
                while (v72 != v73);
                int v72 = (char *)v483[0];
              }
              if (v72 != (char *)&v484) {
                free(v72);
              }
              sub_1CCD6C6D4((uint64_t)v483, (uint64_t)&v449, (uint64_t)__src);
              if (LODWORD(__src[1]))
              {
                unint64_t v74 = (uint64_t *)__src[0];
                unsigned int v75 = (char *)__src[0] + 8 * LODWORD(__src[1]);
                unsigned int v76 = v445;
                while (1)
                {
                  uint64_t v77 = *v74;
                  uint64_t v78 = HIDWORD(v446);
                  if (v76 != v444) {
                    break;
                  }
                  if (!HIDWORD(v446)) {
                    goto LABEL_163;
                  }
                  __int16 v79 = 0;
                  uint64_t v80 = 8 * HIDWORD(v446);
                  unsigned int v81 = v76;
                  do
                  {
                    if (*v81 == v77) {
                      goto LABEL_187;
                    }
                    if (*v81 == -2) {
                      __int16 v79 = v81;
                    }
                    ++v81;
                    v80 -= 8;
                  }
                  while (v80);
                  if (v79)
                  {
                    void *v79 = v77;
                    --v447;
                  }
                  else
                  {
LABEL_163:
                    unsigned int v82 = v446;
                    if (HIDWORD(v446) >= v446) {
                      goto LABEL_166;
                    }
                    ++HIDWORD(v446);
                    *(void *)&v76[8 * v78] = v77;
                  }
LABEL_187:
                  unsigned int v76 = v445;
                  if (++v74 == (uint64_t *)v75) {
                    goto LABEL_195;
                  }
                }
                unsigned int v82 = v446;
LABEL_166:
                if (3 * v82 <= 4 * (HIDWORD(v446) - v447))
                {
                  if (v82 >= 0x40) {
                    v82 *= 2;
                  }
                  else {
                    unsigned int v82 = 128;
                  }
                }
                else if (v82 - HIDWORD(v446) >= v82 >> 3)
                {
                  goto LABEL_168;
                }
                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v444, v82);
                unsigned int v82 = v446;
                unsigned int v76 = v445;
LABEL_168:
                unsigned int v83 = v82 - 1;
                unsigned int v84 = (v82 - 1) & ((v77 >> 4) ^ (v77 >> 9));
                uint64_t v85 = &v76[8 * v84];
                uint64_t v86 = *(void *)v85;
                if (*(void *)v85 == -1)
                {
                  uint64_t v87 = 0;
LABEL_180:
                  if (v87) {
                    unsigned int v91 = v87;
                  }
                  else {
                    unsigned int v91 = v85;
                  }
                  if (*(void *)v91 != v77)
                  {
                    if (*(void *)v91 == -2) {
                      --v447;
                    }
                    else {
                      ++HIDWORD(v446);
                    }
                    *(void *)unsigned int v91 = v77;
                  }
                }
                else
                {
                  uint64_t v87 = 0;
                  int v88 = 1;
                  while (v86 != v77)
                  {
                    if (v87) {
                      BOOL v89 = 0;
                    }
                    else {
                      BOOL v89 = v86 == -2;
                    }
                    if (v89) {
                      uint64_t v87 = v85;
                    }
                    unsigned int v90 = v84 + v88++;
                    unsigned int v84 = v90 & v83;
                    uint64_t v85 = &v76[8 * (v90 & v83)];
                    uint64_t v86 = *(void *)v85;
                    if (*(void *)v85 == -1) {
                      goto LABEL_180;
                    }
                  }
                }
                goto LABEL_187;
              }
LABEL_195:
              if (__dst != v496) {
                free(__dst);
              }
              if (__src[0] != &v490) {
                free(__src[0]);
              }
              uint64_t v92 = *(void *)(v57 + 32);
              uint64_t v57 = v92 - 24;
              if (v92) {
                uint64_t v93 = v92 - 24;
              }
              else {
                uint64_t v93 = 0;
              }
              if (!v92 || *(unsigned char *)(v93 + 16) != 83)
              {
                __int32 v55 = v450.i32[0];
                goto LABEL_205;
              }
            }
            int v70 = (unint64_t *)&v484;
LABEL_142:
            uint64_t v71 = 0;
            goto LABEL_143;
          }
        }
LABEL_205:
        unsigned int v424 = v2;
        if (v479) {
          goto LABEL_206;
        }
        unsigned int v434 = 0;
        int v432 = 0;
        while (2)
        {
          uint64_t v99 = (uint64_t *)v476;
          uint64_t v100 = v477;
          long long v457 = 0;
          uint64_t v458 = 0;
          unsigned int v459 = 0;
          if (v477)
          {
            uint64_t v101 = 8 * v477;
            uint64_t v102 = (uint64_t *)v476;
            do
            {
              uint64_t v103 = *v102;
              LODWORD(__src[0]) = 0;
              LODWORD(__src[0]) = sub_1CCD6D534(a1, v103);
              if (LODWORD(__src[0]) == -1) {
                goto LABEL_236;
              }
              unint64_t v104 = sub_1CB8387D8((uint64_t)&v457, __src);
              ++v104[1];
              ++v102;
              v101 -= 8;
            }
            while (v101);
            int v456 = 0;
            int v105 = v457;
            uint64_t v106 = v459;
            if (v458)
            {
              int v107 = &v457[2 * v459];
              if (v459)
              {
                uint64_t v108 = 0;
                while (v457[v108] >= 0xFFFFFFFE)
                {
                  v108 += 2;
                  if (2 * v459 == v108)
                  {
                    uint64_t v109 = &v457[2 * v459];
                    goto LABEL_224;
                  }
                }
                uint64_t v109 = &v457[v108];
              }
              else
              {
                uint64_t v109 = v457;
              }
LABEL_224:
              unsigned int v110 = &v105[2 * v106];
              if (v109 != v110)
              {
                int v111 = v109;
                while (1)
                {
                  int v112 = v111 + 2;
                  while (1)
                  {
                    uint64_t v113 = v112;
                    if (v112 == v107) {
                      break;
                    }
                    v112 += 2;
                    if (*v113 <= 0xFFFFFFFD)
                    {
                      int v111 = v113;
                      goto LABEL_231;
                    }
                  }
                  int v111 = v107;
LABEL_231:
                  if (v111 == v110) {
                    break;
                  }
                  if (v109[1] < v113[1]) {
                    uint64_t v109 = v111;
                  }
                }
              }
              int v456 = *v109;
              if (sub_1CB8387D8((uint64_t)&v457, &v456)[1] == 1)
              {
LABEL_236:
                LOBYTE(v460[0]) = 0;
                char v465 = 0;
                goto LABEL_558;
              }
              int v114 = v474;
              int v115 = &v99[v100];
              v497 = v499;
              uint64_t v498 = 0x400000000;
              if (v100)
              {
                do
                {
                  uint64_t v116 = *v99;
                  uint64_t v117 = *(void *)a1;
                  uint64_t v118 = *(unsigned int *)(a1 + 16);
                  if (v118)
                  {
                    LODWORD(v119) = ((v116 >> 4) ^ (v116 >> 9)) & (v118 - 1);
                    uint64_t v120 = (uint64_t *)(v117 + 16 * v119);
                    uint64_t v121 = *v120;
                    if (v116 != *v120)
                    {
                      int v122 = 1;
                      do
                      {
                        if (v121 == -4096) {
                          goto LABEL_244;
                        }
                        int v123 = v119 + v122++;
                        uint64_t v119 = v123 & (v118 - 1);
                        uint64_t v121 = *(void *)(v117 + 16 * v119);
                      }
                      while (v116 != v121);
                      uint64_t v120 = (uint64_t *)(v117 + 16 * v119);
                    }
                  }
                  else
                  {
LABEL_244:
                    uint64_t v120 = (uint64_t *)(v117 + 16 * v118);
                  }
                  if (*((_DWORD *)v120 + 2) == v456)
                  {
                    if (v498 >= (unint64_t)HIDWORD(v498)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    v497[v498] = v116;
                    LODWORD(v498) = v498 + 1;
                  }
                  else
                  {
                    __src[0] = *(void **)(v116 + 40);
                    sub_1CD76A7FC((uint64_t)&v471, __src);
                  }
                  ++v99;
                }
                while (v99 != v115);
                unsigned int v124 = v497;
                uint64_t v125 = v498;
                if (v498)
                {
                  uint64_t v126 = 0;
                  do
                  {
                    unint64_t v127 = (unsigned __int8 *)v497[v126];
                    unsigned int v128 = v127[16] - 38;
                    BOOL v10 = v128 > 0x38;
                    uint64_t v129 = (1 << v128) & 0x100260000200001;
                    BOOL v130 = v10 || v129 == 0;
                    if (!v130 || *(unsigned char *)(*(void *)v127 + 8) == 12)
                    {
                      LOBYTE(v460[0]) = 0;
                      char v465 = 0;
                      goto LABEL_556;
                    }
                    ++v126;
                  }
                  while (v498 != v126);
                }
                else
                {
                  uint64_t v125 = 0;
                }
              }
              else
              {
                uint64_t v125 = 0;
                unsigned int v124 = v499;
              }
              int v131 = v474;
              if (v474 != v114)
              {
                uint64_t v453 = 0;
                int32x2_t v454 = 0;
                unsigned int v455 = 0;
                uint64_t v132 = v449;
                uint64_t v133 = &v449[96 * v451];
                if (v450.i32[0])
                {
                  __src[0] = v449;
                  __src[1] = &v449[96 * v451];
                  sub_1CCD6CCEC((uint64_t *)__src);
                  int64x2_t v134 = *(int64x2_t *)__src;
                }
                else
                {
                  int64x2_t v134 = vdupq_n_s64((unint64_t)v133);
                }
                int64x2_t v452 = v134;
                uint64_t v135 = v134.i64[0];
                if (v133 == (char *)v134.i64[0])
                {
                  uint64_t v146 = 0;
                }
                else
                {
                  do
                  {
                    __src[0] = &v490;
                    __src[1] = (void *)0x400000000;
                    if (*(_DWORD *)(v135 + 8)) {
                      sub_1CBB08064((uint64_t)__src, v135);
                    }
                    long long __dst = v496;
                    uint64_t v495 = 0x400000000;
                    if (*(_DWORD *)(v135 + 56))
                    {
                      sub_1CBB08064((uint64_t)&__dst, v135 + 48);
                      int v136 = v495;
                      if (v495)
                      {
                        unint64_t v137 = (char *)__dst;
                        uint64_t v138 = (char *)__src[0];
                        uint64_t v139 = (char *)__dst + 8 * v495;
                        uint64_t v140 = (char *)__dst;
                        do
                        {
                          if (v474)
                          {
                            uint64_t v141 = 8 * v474;
                            unsigned int v142 = (char *)v473;
                            do
                            {
                              if (*(void *)v142 == *(void *)v140) {
                                goto LABEL_283;
                              }
                              v142 += 8;
                              v141 -= 8;
                            }
                            while (v141);
                            unsigned int v142 = (char *)v473 + 8 * v474;
                          }
                          else
                          {
                            unsigned int v142 = (char *)v473;
                          }
LABEL_283:
                          uint64_t v143 = v140 + 8;
                          if (v474 == (v142 - (unsigned char *)v473) >> 3)
                          {
                            if (v139 != v143)
                            {
                              memmove(v140, v143, v139 - v143);
                              int v136 = v495;
                            }
                            LODWORD(v495) = --v136;
                            int v144 = (int)__src[1];
                            uint64_t v145 = (char *)__src[0] + 8 * LODWORD(__src[1]);
                            if (v145 != v138 + 8)
                            {
                              memmove(v138, v138 + 8, v145 - (v138 + 8));
                              int v144 = (int)__src[1];
                              int v136 = v495;
                            }
                            LODWORD(__src[1]) = v144 - 1;
                            unint64_t v137 = (char *)__dst;
                          }
                          else
                          {
                            v138 += 8;
                            v140 += 8;
                          }
                          uint64_t v139 = &v137[8 * v136];
                        }
                        while (v140 != v139);
                      }
                    }
                    sub_1CCD6C6D4((uint64_t)v483, (uint64_t)&v453, (uint64_t)__src);
                    if (__dst != v496) {
                      free(__dst);
                    }
                    if (__src[0] != &v490) {
                      free(__src[0]);
                    }
                    v452.i64[0] += 96;
                    sub_1CCD6CCEC(v452.i64);
                    uint64_t v135 = v452.i64[0];
                  }
                  while ((char *)v452.i64[0] != v133);
                  uint64_t v132 = v449;
                  uint64_t v146 = v455;
                }
                sub_1CCD6E0A8((uint64_t *)&v449);
                MEMORY[0x1D25D9CD0](v132, 8);
                unsigned int v451 = v146;
                if (v146)
                {
                  uint64_t v147 = (char *)operator new(96 * v146, (std::align_val_t)8uLL);
                  unint64_t v148 = 0;
                  unint64_t v449 = v147;
                  int32x2_t v450 = v454;
                  uint64_t v149 = 48;
                  do
                  {
                    uint64_t v150 = &v449[v149];
                    unsigned int v151 = &v449[v149];
                    *((void *)v151 - 6) = &v449[v149 - 32];
                    uint64_t v152 = (uint64_t)(v151 - 48);
                    uint64_t v153 = v453;
                    uint64_t v154 = v453 + v149;
                    *(void *)(v152 + 8) = 0x400000000;
                    if (*(_DWORD *)(v154 - 40)) {
                      sub_1CBB08064(v152, v154 - 48);
                    }
                    *(void *)uint64_t v150 = v150 + 16;
                    *((void *)v150 + 1) = 0x400000000;
                    if (*(_DWORD *)(v154 + 8)) {
                      sub_1CBB08064((uint64_t)v150, v153 + v149);
                    }
                    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
                      && __cxa_guard_acquire(&qword_1EBCF22E0))
                    {
                      qword_1EBCF2300 = 0;
                      qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
                      qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
                      qword_1EBCF2328 = 0x400000000;
                      qword_1EBCF22F8 = 0x400000001;
                      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
                      __cxa_guard_release(&qword_1EBCF22E0);
                    }
                    __src[0] = &v490;
                    __src[1] = (void *)0x400000000;
                    if (qword_1EBCF22F8) {
                      sub_1CBB08064((uint64_t)__src, (uint64_t)&qword_1EBCF22F0);
                    }
                    long long __dst = v496;
                    uint64_t v495 = 0x400000000;
                    if (qword_1EBCF2328) {
                      sub_1CBB08064((uint64_t)&__dst, (uint64_t)&qword_1EBCF2320);
                    }
                    if (!sub_1CCD6CC74(v152, (uint64_t)__src))
                    {
                      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E8, memory_order_acquire) & 1) == 0
                        && __cxa_guard_acquire(&qword_1EBCF22E8))
                      {
                        qword_1EBCF2360 = 1;
                        qword_1EBCF2350 = (uint64_t)&qword_1EBCF2360;
                        qword_1EBCF2380 = (uint64_t)&unk_1EBCF2390;
                        qword_1EBCF2388 = 0x400000000;
                        qword_1EBCF2358 = 0x400000001;
                        __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF2350, &dword_1CB82C000);
                        __cxa_guard_release(&qword_1EBCF22E8);
                      }
                      v483[0] = &v484;
                      v483[1] = (void *)0x400000000;
                      if (qword_1EBCF2358) {
                        sub_1CBB08064((uint64_t)v483, (uint64_t)&qword_1EBCF2350);
                      }
                      unint64_t v486 = v488;
                      uint64_t v487 = 0x400000000;
                      if (qword_1EBCF2388)
                      {
                        sub_1CBB08064((uint64_t)&v486, (uint64_t)&qword_1EBCF2380);
                        if (v486 != v488) {
                          free(v486);
                        }
                      }
                      if (v483[0] != &v484) {
                        free(v483[0]);
                      }
                    }
                    if (__dst != v496) {
                      free(__dst);
                    }
                    if (__src[0] != &v490) {
                      free(__src[0]);
                    }
                    ++v148;
                    v149 += 96;
                  }
                  while (v148 < v451);
                }
                else
                {
                  unint64_t v449 = 0;
                  int32x2_t v450 = 0;
                }
                int v155 = v477;
                if (v477)
                {
                  int v156 = (char *)v476;
                  uint64_t v157 = (char *)v476;
                  do
                  {
                    if (v474)
                    {
                      uint64_t v158 = 8 * v474;
                      uint64_t v159 = (char *)v473;
                      do
                      {
                        if (*(void *)v159 == *(void *)(*(void *)v157 + 40)) {
                          goto LABEL_337;
                        }
                        v159 += 8;
                        v158 -= 8;
                      }
                      while (v158);
                      uint64_t v159 = (char *)v473 + 8 * v474;
                    }
                    else
                    {
                      uint64_t v159 = (char *)v473;
                    }
LABEL_337:
                    if (v474 == (v159 - (unsigned char *)v473) >> 3)
                    {
                      __src[0] = *(void **)(*(void *)v157 + 40);
                      sub_1CD76A7FC((uint64_t)&v471, __src);
                      int v156 = (char *)v476;
                      int v160 = v477;
                      unint64_t v161 = (char *)v476 + 8 * v477;
                      if (v161 != v157 + 8)
                      {
                        memmove(v157, v157 + 8, v161 - (v157 + 8));
                        int v160 = v477;
                        int v156 = (char *)v476;
                      }
                      int v155 = v160 - 1;
                      LODWORD(v477) = v155;
                    }
                    else
                    {
                      v157 += 8;
                    }
                  }
                  while (v157 != &v156[8 * v155]);
                }
                sub_1CCD6E0A8(&v453);
                MEMORY[0x1D25D9CD0](v453, 8);
                unsigned int v124 = v497;
                uint64_t v125 = v498;
              }
              v483[0] = &v484;
              v483[1] = (void *)0x400000000;
              unint64_t v486 = v488;
              uint64_t v487 = 0x400000000;
              if (v125)
              {
                unsigned int v162 = 0;
                uint64_t v163 = 8 * v125;
                do
                {
                  if (v162 >= HIDWORD(v483[1])) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v483[0] + v162) = *v124;
                  unsigned int v162 = ++LODWORD(v483[1]);
                  ++v124;
                  v163 -= 8;
                }
                while (v163);
              }
              sub_1CCD6E34C(v473, (void *)v473 + v474, (uint64_t)&v486);
              __src[0] = 0;
              if (sub_1CCD6C930((uint64_t)v449, v451, (uint64_t)v483, (uint64_t *)__src))
              {
                unsigned int v164 = __src[0];
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E8, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EBCF22E8))
                {
                  qword_1EBCF2360 = 1;
                  qword_1EBCF2350 = (uint64_t)&qword_1EBCF2360;
                  qword_1EBCF2380 = (uint64_t)&unk_1EBCF2390;
                  qword_1EBCF2388 = 0x400000000;
                  qword_1EBCF2358 = 0x400000001;
                  __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF2350, &dword_1CB82C000);
                  __cxa_guard_release(&qword_1EBCF22E8);
                }
                __src[0] = &v490;
                __src[1] = (void *)0x400000000;
                if (qword_1EBCF2358) {
                  sub_1CBB08064((uint64_t)__src, (uint64_t)&qword_1EBCF2350);
                }
                long long __dst = v496;
                uint64_t v495 = 0x400000000;
                if (qword_1EBCF2388) {
                  sub_1CBB08064((uint64_t)&__dst, (uint64_t)&qword_1EBCF2380);
                }
                sub_1CBB08064((uint64_t)v164, (uint64_t)__src);
                sub_1CBB08064((uint64_t)v164 + 48, (uint64_t)&__dst);
                if (__dst != v496) {
                  free(__dst);
                }
                if (__src[0] != &v490) {
                  free(__src[0]);
                }
                int32x2_t v450 = vadd_s32(v450, (int32x2_t)0x1FFFFFFFFLL);
LABEL_363:
                if (v445 == v444)
                {
LABEL_364:
                  int v447 = 0;
                  HIDWORD(v446) = 0;
                }
                else
                {
                  if (v446 < 0x21 || 4 * (HIDWORD(v446) - v447) >= v446)
                  {
                    memset(v445, 255, 8 * v446);
                    goto LABEL_364;
                  }
                  llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v444);
                }
                uint64_t v165 = &v449[96 * v451];
                if (v450.i32[0])
                {
                  __src[0] = v449;
                  __src[1] = &v449[96 * v451];
                  sub_1CCD6CCEC((uint64_t *)__src);
                  uint64_t v166 = (char *)__src[0];
                  long long v167 = (char *)__src[1];
                }
                else
                {
                  uint64_t v166 = &v449[96 * v451];
                  long long v167 = v166;
                }
                __src[1] = v167;
                if (v165 != v166)
                {
                  while (1)
                  {
                    uint64_t v168 = *((unsigned int *)v166 + 2);
                    if (v168) {
                      break;
                    }
LABEL_411:
                    __src[0] = v166 + 96;
                    sub_1CCD6CCEC((uint64_t *)__src);
                    uint64_t v166 = (char *)__src[0];
                    if (__src[0] == v165) {
                      goto LABEL_412;
                    }
                  }
                  unsigned int v169 = *(uint64_t **)v166;
                  uint64_t v170 = *(void *)v166 + 8 * v168;
                  uint64_t v171 = v445;
                  while (2)
                  {
                    uint64_t v172 = *v169;
                    uint64_t v173 = HIDWORD(v446);
                    if (v171 != v444)
                    {
                      unsigned int v177 = v446;
                      goto LABEL_382;
                    }
                    if (!HIDWORD(v446)) {
                      goto LABEL_379;
                    }
                    uint64_t v174 = 0;
                    uint64_t v175 = 8 * HIDWORD(v446);
                    uint64_t v176 = v171;
                    do
                    {
                      if (*v176 == v172) {
                        goto LABEL_403;
                      }
                      if (*v176 == -2) {
                        uint64_t v174 = v176;
                      }
                      ++v176;
                      v175 -= 8;
                    }
                    while (v175);
                    if (!v174)
                    {
LABEL_379:
                      unsigned int v177 = v446;
                      if (HIDWORD(v446) < v446)
                      {
                        ++HIDWORD(v446);
                        *(void *)&v171[8 * v173] = v172;
                        goto LABEL_403;
                      }
LABEL_382:
                      if (3 * v177 <= 4 * (HIDWORD(v446) - v447))
                      {
                        if (v177 >= 0x40) {
                          v177 *= 2;
                        }
                        else {
                          unsigned int v177 = 128;
                        }
                      }
                      else if (v177 - HIDWORD(v446) >= v177 >> 3)
                      {
LABEL_384:
                        unsigned int v178 = v177 - 1;
                        unsigned int v179 = (v177 - 1) & ((v172 >> 4) ^ (v172 >> 9));
                        long long v180 = &v171[8 * v179];
                        uint64_t v181 = *(void *)v180;
                        if (*(void *)v180 == -1)
                        {
                          uint64_t v182 = 0;
LABEL_396:
                          if (v182) {
                            long long v186 = v182;
                          }
                          else {
                            long long v186 = v180;
                          }
                          if (*(void *)v186 != v172)
                          {
                            if (*(void *)v186 == -2) {
                              --v447;
                            }
                            else {
                              ++HIDWORD(v446);
                            }
                            *(void *)long long v186 = v172;
                          }
                        }
                        else
                        {
                          uint64_t v182 = 0;
                          int v183 = 1;
                          while (v181 != v172)
                          {
                            if (v182) {
                              BOOL v184 = 0;
                            }
                            else {
                              BOOL v184 = v181 == -2;
                            }
                            if (v184) {
                              uint64_t v182 = v180;
                            }
                            unsigned int v185 = v179 + v183++;
                            unsigned int v179 = v185 & v178;
                            long long v180 = &v171[8 * (v185 & v178)];
                            uint64_t v181 = *(void *)v180;
                            if (*(void *)v180 == -1) {
                              goto LABEL_396;
                            }
                          }
                        }
LABEL_403:
                        uint64_t v171 = v445;
                        if (++v169 == (uint64_t *)v170) {
                          goto LABEL_411;
                        }
                        continue;
                      }
                      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v444, v177);
                      unsigned int v177 = v446;
                      uint64_t v171 = v445;
                      goto LABEL_384;
                    }
                    break;
                  }
                  void *v174 = v172;
                  --v447;
                  goto LABEL_403;
                }
              }
              else if (v131 != v114)
              {
                goto LABEL_363;
              }
LABEL_412:
              if (LODWORD(v483[1]))
              {
                uint64_t v187 = (uint64_t *)v483[0];
                int v188 = v446 - 1;
                if (v445 == v444) {
                  int v189 = HIDWORD(v446);
                }
                else {
                  int v189 = v446;
                }
                uint64_t v190 = &v445[8 * v189];
                long long v191 = v445;
                while (1)
                {
                  uint64_t v192 = *v187;
                  if (v191 == v444)
                  {
                    if (HIDWORD(v446))
                    {
                      uint64_t v193 = 0;
                      while (*(void *)&v444[v193] != v192)
                      {
                        v193 += 8;
                        if (8 * HIDWORD(v446) == v193)
                        {
                          int v194 = HIDWORD(v446);
                          goto LABEL_437;
                        }
                      }
                      unint64_t v203 = &v444[v193];
                      int v194 = HIDWORD(v446);
                      long long v191 = v444;
                    }
                    else
                    {
                      int v194 = 0;
LABEL_437:
                      long long v191 = v444;
                      unint64_t v203 = &v444[8 * HIDWORD(v446)];
                    }
                  }
                  else
                  {
                    unsigned int v195 = v188 & ((v192 >> 4) ^ (v192 >> 9));
                    BOOL v196 = &v445[8 * v195];
                    uint64_t v197 = *(void *)v196;
                    if (*(void *)v196 == -1)
                    {
                      long long v198 = 0;
LABEL_439:
                      if (v198) {
                        BOOL v196 = v198;
                      }
                      uint64_t v202 = *(void *)v196;
                    }
                    else
                    {
                      long long v198 = 0;
                      int v199 = 1;
                      while (v197 != v192)
                      {
                        if (v198) {
                          BOOL v200 = 0;
                        }
                        else {
                          BOOL v200 = v197 == -2;
                        }
                        if (v200) {
                          long long v198 = v196;
                        }
                        unsigned int v201 = v195 + v199++;
                        unsigned int v195 = v201 & v188;
                        BOOL v196 = &v445[8 * (v201 & v188)];
                        uint64_t v197 = *(void *)v196;
                        if (*(void *)v196 == -1) {
                          goto LABEL_439;
                        }
                      }
                      uint64_t v202 = *v187;
                    }
                    unint64_t v203 = v202 == v192 ? v196 : v190;
                    int v194 = HIDWORD(v446);
                    long long v191 = v445;
                  }
                  if (v191 != v444) {
                    int v194 = v446;
                  }
                  if (v203 != &v191[8 * v194]) {
                    break;
                  }
                  if (++v187 == (uint64_t *)((char *)v483[0] + 8 * LODWORD(v483[1]))) {
                    goto LABEL_450;
                  }
                }
LABEL_543:
                LOBYTE(v460[0]) = 0;
                char v465 = 0;
                goto LABEL_551;
              }
LABEL_450:
              uint64_t v204 = (char *)v497;
              long long v205 = (unsigned __int8 *)*v497;
              int v206 = *(_DWORD *)(*v497 + 20);
              if (v498)
              {
                uint64_t v207 = 8 * v498;
                while (((*(_DWORD *)(*(void *)v204 + 20) ^ v206) & 0x7FFFFFF) == 0)
                {
                  v204 += 8;
                  v207 -= 8;
                  if (!v207) {
                    goto LABEL_454;
                  }
                }
                goto LABEL_543;
              }
LABEL_454:
              BOOL v208 = (const llvm::Instruction *)(v206 & 0x7FFFFFF);
              if ((v206 & 0x7FFFFFF) == 0) {
                goto LABEL_544;
              }
              uint64_t v209 = 0;
              unint64_t v430 = (v208 - 1);
LABEL_456:
              uint64_t v210 = (char *)v497;
              uint64_t v211 = v498;
              __src[0] = &v490;
              __src[1] = (void *)0x400000000;
              long long __dst = v496;
              uint64_t v495 = 0x400000000;
              sub_1CCD6E34C(v473, (void *)v473 + v474, (uint64_t)&__dst);
              if (v211)
              {
                uint64_t v212 = 8 * v211;
                do
                {
                  uint64_t v213 = *(void *)v210;
                  int v214 = *(_DWORD *)(*(void *)v210 + 20);
                  if ((v214 & 0x40000000) != 0) {
                    uint64_t v215 = *(void *)(v213 - 8);
                  }
                  else {
                    uint64_t v215 = v213 - 32 * (v214 & 0x7FFFFFF);
                  }
                  if (LODWORD(__src[1]) >= (unint64_t)HIDWORD(__src[1])) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__src[0] + LODWORD(__src[1])) = *(void *)(v215 + 32 * (void)v209);
                  unsigned int v216 = ++LODWORD(__src[1]);
                  v210 += 8;
                  v212 -= 8;
                }
                while (v212);
              }
              else
              {
                unsigned int v216 = __src[1];
              }
              if (v216)
              {
                unint64_t v217 = __src[0];
                uint64_t v218 = 8 * v216;
                while (*(void *)__src[0] == *v217)
                {
                  ++v217;
                  v218 -= 8;
                  if (!v218) {
                    goto LABEL_473;
                  }
                }
                if (llvm::canReplaceOperandWithVariable((llvm *)v205, v209))
                {
                  unsigned int v219 = v451;
                  if (sub_1CCD6C930((uint64_t)v449, v451, (uint64_t)__src, &v453)) {
                    goto LABEL_473;
                  }
                  long long v221 = (char *)__src[0];
                  if (LODWORD(__src[1]))
                  {
                    uint64_t v222 = 8 * LODWORD(__src[1]);
                    uint64_t v223 = (void **)__src[0];
                    while (**v223 == **(void **)__src[0])
                    {
                      ++v223;
                      v222 -= 8;
                      if (!v222) {
                        goto LABEL_478;
                      }
                    }
                    goto LABEL_533;
                  }
LABEL_478:
                  int v224 = v205[16];
                  if (v224 == 84)
                  {
                    if (v209 != (const llvm::Instruction *)v430 || !LODWORD(__src[1])) {
                      goto LABEL_488;
                    }
LABEL_485:
                    uint64_t v225 = 8 * LODWORD(__src[1]);
                    while (*(unsigned __int8 *)(*(void *)v221 + 16) > 0x14u)
                    {
                      v221 += 8;
                      v225 -= 8;
                      if (!v225) {
                        goto LABEL_488;
                      }
                    }
                    goto LABEL_533;
                  }
                  if (LODWORD(__src[1]) && v209 == (const llvm::Instruction *)v430 && v224 == 33) {
                    goto LABEL_485;
                  }
LABEL_488:
                  if (v450.i32[0])
                  {
                    unint64_t v226 = (4 * v450.i32[0] / 3u + 1) | ((unint64_t)(4 * v450.i32[0] / 3u + 1) >> 1);
                    unint64_t v227 = v226 | (v226 >> 2) | ((v226 | (v226 >> 2)) >> 4);
                    unsigned int v228 = ((v227 | (v227 >> 8)) >> 16) | v227 | (v227 >> 8);
                    if (v219 <= v228) {
                      sub_1CCD6CF78((void **)&v449, v228 + 1);
                    }
                  }
                  sub_1CCD6C6D4((uint64_t)&v453, (uint64_t)&v449, (uint64_t)__src);
                  if (LODWORD(__src[1]))
                  {
                    uint64_t v229 = (uint64_t *)__src[0];
                    uint64_t v230 = (char *)__src[0] + 8 * LODWORD(__src[1]);
                    unint64_t v231 = v445;
                    while (1)
                    {
                      uint64_t v232 = *v229;
                      uint64_t v233 = HIDWORD(v446);
                      if (v231 != v444) {
                        break;
                      }
                      if (HIDWORD(v446))
                      {
                        uint64_t v234 = 0;
                        uint64_t v235 = 8 * HIDWORD(v446);
                        uint64_t v236 = v231;
                        while (*v236 != v232)
                        {
                          if (*v236 == -2) {
                            uint64_t v234 = v236;
                          }
                          ++v236;
                          v235 -= 8;
                          if (!v235)
                          {
                            if (!v234) {
                              goto LABEL_501;
                            }
                            *uint64_t v234 = v232;
                            --v447;
                            goto LABEL_525;
                          }
                        }
                        goto LABEL_525;
                      }
LABEL_501:
                      unsigned int v237 = v446;
                      if (HIDWORD(v446) >= v446) {
                        goto LABEL_504;
                      }
                      ++HIDWORD(v446);
                      *(void *)&v231[8 * v233] = v232;
LABEL_525:
                      int v220 = 0;
                      unint64_t v231 = v445;
                      if (++v229 == (uint64_t *)v230) {
                        goto LABEL_534;
                      }
                    }
                    unsigned int v237 = v446;
LABEL_504:
                    if (3 * v237 <= 4 * (HIDWORD(v446) - v447))
                    {
                      if (v237 >= 0x40) {
                        v237 *= 2;
                      }
                      else {
                        unsigned int v237 = 128;
                      }
                    }
                    else if (v237 - HIDWORD(v446) >= v237 >> 3)
                    {
                      goto LABEL_506;
                    }
                    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v444, v237);
                    unsigned int v237 = v446;
                    unint64_t v231 = v445;
LABEL_506:
                    unsigned int v238 = v237 - 1;
                    unsigned int v239 = (v237 - 1) & ((v232 >> 4) ^ (v232 >> 9));
                    uint64_t v240 = &v231[8 * v239];
                    uint64_t v241 = *(void *)v240;
                    if (*(void *)v240 == -1)
                    {
                      unint64_t v242 = 0;
LABEL_518:
                      if (v242) {
                        uint64_t v246 = v242;
                      }
                      else {
                        uint64_t v246 = v240;
                      }
                      if (*(void *)v246 != v232)
                      {
                        if (*(void *)v246 == -2) {
                          --v447;
                        }
                        else {
                          ++HIDWORD(v446);
                        }
                        *(void *)uint64_t v246 = v232;
                      }
                    }
                    else
                    {
                      unint64_t v242 = 0;
                      int v243 = 1;
                      while (v241 != v232)
                      {
                        if (v242) {
                          BOOL v244 = 0;
                        }
                        else {
                          BOOL v244 = v241 == -2;
                        }
                        if (v244) {
                          unint64_t v242 = v240;
                        }
                        unsigned int v245 = v239 + v243++;
                        unsigned int v239 = v245 & v238;
                        uint64_t v240 = &v231[8 * (v245 & v238)];
                        uint64_t v241 = *(void *)v240;
                        if (*(void *)v240 == -1) {
                          goto LABEL_518;
                        }
                      }
                    }
                    goto LABEL_525;
                  }
                  int v220 = 0;
                }
                else
                {
LABEL_533:
                  LOBYTE(v460[0]) = 0;
                  char v465 = 0;
                  int v220 = 1;
                }
              }
              else
              {
LABEL_473:
                int v220 = 20;
              }
LABEL_534:
              if (__dst != v496) {
                free(__dst);
              }
              if (__src[0] != &v490) {
                free(__src[0]);
              }
              if (v220 != 20 && v220) {
                goto LABEL_551;
              }
              uint64_t v209 = (const llvm::Instruction *)((char *)v209 + 1);
              if (v209 == v208)
              {
                long long v205 = (unsigned __int8 *)*v497;
LABEL_544:
                int v247 = sub_1CCD6D958((uint64_t)v205);
                int v490 = -1;
                unsigned int v491 = &v493;
                *(void *)std::string::size_type v492 = 0x400000000;
                __src[0] = (void *)__PAIR64__(++v432, v474);
                v434 += v247;
                __src[1] = (void *)__PAIR64__(v434, v450.u32[0]);
                sub_1CC0A3870((uint64_t)&v491, (uint64_t)&v493, (uint64_t *)v473, (uint64_t *)v473 + v474);
                *(_OWORD *)long long v460 = *(_OWORD *)__src;
                int v461 = v490;
                long long v462 = v464;
                uint64_t v463 = 0x400000000;
                int v248 = v492[0];
                uint64_t v249 = (uint64_t *)v491;
                if (v492[0])
                {
                  if (v491 == &v493)
                  {
                    if (v492[0] >= 5u) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    memcpy(v464, &v493, 8 * v492[0]);
                    uint64_t v249 = (uint64_t *)v491;
                    LODWORD(v463) = v248;
                  }
                  else
                  {
                    long long v462 = v491;
                    uint64_t v463 = *(void *)v492;
                    unsigned int v491 = &v493;
                    v492[1] = 0;
                    uint64_t v249 = &v493;
                  }
                  v492[0] = 0;
                }
                char v465 = 1;
                if (v249 != &v493) {
                  free(v249);
                }
LABEL_551:
                if (v486 != v488) {
                  free(v486);
                }
                if (v483[0] != &v484) {
                  free(v483[0]);
                }
                unsigned int v124 = v497;
LABEL_556:
                if (v124 != v499) {
                  free(v124);
                }
LABEL_558:
                MEMORY[0x1D25D9CD0](v457, 4);
                if (!v465) {
                  goto LABEL_206;
                }
                int v250 = LODWORD(v460[0]) >= v481 ? 0 : -2;
                int v461 = HIDWORD(v460[0]) * (LODWORD(v460[0]) - 1)
                     - (LODWORD(v460[1]) - v55) * (LODWORD(v460[1]) - v55)
                     + v250;
                if (v467 >= HIDWORD(v467))
                {
                  if (HIDWORD(v467) == -1) {
LABEL_867:
                  }
                    sub_1CD0A89A8(0xFFFFFFFFuLL);
                  if (((2 * HIDWORD(v467)) | 1uLL) >= 0xFFFFFFFF) {
                    uint64_t v263 = 0xFFFFFFFFLL;
                  }
                  else {
                    uint64_t v263 = (2 * HIDWORD(v467)) | 1;
                  }
                  unsigned int v264 = (char *)malloc_type_malloc(72 * v263, 0x4065EBACuLL);
                  if (!v264) {
                    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
                  }
                  uint64_t v265 = v264;
                  uint64_t v266 = &v264[72 * v467];
                  long long v267 = *(_OWORD *)v460;
                  *((_DWORD *)v266 + 4) = v461;
                  *(_OWORD *)uint64_t v266 = v267;
                  *((void *)v266 + 4) = 0x400000000;
                  *((void *)v266 + 3) = v266 + 40;
                  uint64_t v268 = (uint64_t)(v266 + 24);
                  if (v463) {
                    sub_1CBB08064(v268, (uint64_t)&v462);
                  }
                  uint64_t v269 = (char *)v466;
                  if (v467)
                  {
                    uint64_t v270 = 0;
                    uint64_t v271 = 72 * v467;
                    do
                    {
                      unsigned int v272 = &v265[v270];
                      uint64_t v273 = &v269[v270];
                      long long v274 = *(_OWORD *)&v269[v270];
                      *((_DWORD *)v272 + 4) = *(_DWORD *)&v269[v270 + 16];
                      *(_OWORD *)unsigned int v272 = v274;
                      uint64_t v275 = &v265[v270 + 40];
                      *(void *)&v265[v270 + 24] = v275;
                      *((void *)v272 + 4) = 0x400000000;
                      unsigned int v276 = *(_DWORD *)&v269[v270 + 32];
                      if (v276) {
                        BOOL v277 = v273 == v272;
                      }
                      else {
                        BOOL v277 = 1;
                      }
                      if (!v277)
                      {
                        unsigned int v278 = (char *)*((void *)v273 + 3);
                        if (v273 + 40 == v278)
                        {
                          if (v276 >= 5) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          memcpy(v275, v278, 8 * *(unsigned int *)&v269[v270 + 32]);
                          *((_DWORD *)v272 + 8) = v276;
                        }
                        else
                        {
                          *((void *)v272 + 3) = v278;
                          *((_DWORD *)v272 + 8) = v276;
                          *((_DWORD *)v272 + 9) = *(_DWORD *)&v269[v270 + 36];
                          *((void *)v273 + 3) = v273 + 40;
                          *(_DWORD *)&v269[v270 + 36] = 0;
                        }
                        *((_DWORD *)v273 + 8) = 0;
                      }
                      v270 += 72;
                    }
                    while (v271 != v270);
                    uint64_t v269 = (char *)v466;
                    if (v467)
                    {
                      uint64_t v279 = 72 * v467;
                      do
                      {
                        unint64_t v280 = *(char **)&v269[v279 - 48];
                        if (&v269[v279 - 32] != v280) {
                          free(v280);
                        }
                        v279 -= 72;
                      }
                      while (v279);
                      uint64_t v269 = (char *)v466;
                    }
                  }
                  if (v269 != v468) {
                    free(v269);
                  }
                  long long v466 = v265;
                  HIDWORD(v467) = v263;
                }
                else
                {
                  uint64_t v251 = (char *)v466 + 72 * v467;
                  long long v252 = *(_OWORD *)v460;
                  *((_DWORD *)v251 + 4) = v461;
                  *(_OWORD *)uint64_t v251 = v252;
                  *((void *)v251 + 4) = 0x400000000;
                  *((void *)v251 + 3) = v251 + 40;
                  uint64_t v253 = (uint64_t)(v251 + 24);
                  if (v463) {
                    sub_1CBB08064(v253, (uint64_t)&v462);
                  }
                }
                LODWORD(v467) = v467 + 1;
                if (!v479)
                {
                  __src[0] = &v490;
                  __src[1] = (void *)0x400000000;
                  if (!v477) {
                    goto LABEL_590;
                  }
                  unsigned int v254 = (char *)v476;
                  uint64_t v255 = 8 * v477;
                  do
                  {
                    uint64_t v256 = *(void *)v254;
                    uint64_t v257 = *(void *)(*(void *)(*(void *)v254 + 40) + 48);
                    uint64_t v258 = v257 - 24;
                    if (!v257) {
                      uint64_t v258 = 0;
                    }
                    if (v256 == v258)
                    {
                      v483[0] = *(void **)(*(void *)v254 + 40);
                      sub_1CD76A7FC((uint64_t)&v471, v483);
                    }
                    else
                    {
                      if (v257 == v256 + 24)
                      {
                        uint64_t v260 = 0;
                      }
                      else
                      {
                        uint64_t v259 = *(void *)(v256 + 24);
                        if (v259) {
                          uint64_t v260 = v259 - 24;
                        }
                        else {
                          uint64_t v260 = 0;
                        }
                      }
                      if (LODWORD(__src[1]) >= (unint64_t)HIDWORD(__src[1])) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      *((void *)__src[0] + LODWORD(__src[1])) = v260;
                      ++LODWORD(__src[1]);
                    }
                    v254 += 8;
                    v255 -= 8;
                  }
                  while (v255);
                  int v261 = (int)__src[1];
                  if (LODWORD(__src[1]))
                  {
                    uint64_t v262 = v477;
                    if (v477 >= LODWORD(__src[1]))
                    {
                      memmove(v476, __src[0], 8 * LODWORD(__src[1]));
                    }
                    else
                    {
                      if (HIDWORD(v477) < LODWORD(__src[1]))
                      {
                        LODWORD(v477) = 0;
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      if (v477) {
                        memmove(v476, __src[0], 8 * v477);
                      }
                      else {
                        uint64_t v262 = 0;
                      }
                      if (v262 != LODWORD(__src[1])) {
                        memcpy((char *)v476 + 8 * v262, (char *)__src[0] + 8 * v262, 8 * LODWORD(__src[1]) - 8 * v262);
                      }
                    }
                    LODWORD(v477) = v261;
                  }
                  else
                  {
LABEL_590:
                    char v479 = 1;
                  }
                  if (__src[0] != &v490) {
                    free(__src[0]);
                  }
                }
                if (v465 && v462 != v464) {
                  free(v462);
                }
                if (v479)
                {
LABEL_206:
                  uint64_t v94 = (long long *)v466;
                  unint64_t v95 = v467;
                  uint64_t v96 = (long long *)((char *)v466 + 72 * v467);
                  if (v467)
                  {
                    unint64_t v97 = v467;
                    while (1)
                    {
                      uint64_t v98 = (long long *)operator new(72 * v97, MEMORY[0x1E4FBA2D0]);
                      if (v98) {
                        break;
                      }
                      BOOL v10 = v97 > 1;
                      v97 >>= 1;
                      if (!v10) {
                        goto LABEL_210;
                      }
                    }
                    uint64_t v281 = v98;
                    sub_1CCD6E3EC(v94, v96, v95, v98, v97);
                    operator delete(v281);
                  }
                  else
                  {
LABEL_210:
                    sub_1CCD6E3EC(v94, v96, v95, 0, 0);
                  }
                  int v2 = v424;
                  int v3 = v428;
                  if (v467 && *((int *)v466 + 4) >= 1)
                  {
                    long long v282 = *(_OWORD *)v466;
                    int v490 = *((_DWORD *)v466 + 4);
                    *(_OWORD *)__src = v282;
                    unsigned int v491 = &v493;
                    *(void *)std::string::size_type v492 = 0x400000000;
                    if (*((_DWORD *)v466 + 8))
                    {
                      sub_1CBB08064((uint64_t)&v491, (uint64_t)v466 + 24);
                      unsigned int v283 = v492[0];
                    }
                    else
                    {
                      unsigned int v283 = 0;
                    }
                    if (v283 >= __p
                      || (uint64_t v438 = sub_1CD1271B8((uint64_t **)v438, (int)v491, v283, ".gvnsink.split", 0, 0, 0, 0, 0)) != 0)
                    {
                      if (HIDWORD(__src[0]))
                      {
                        int v425 = 0;
                        uint64_t v426 = v438 + 40;
                        while (1)
                        {
                          unint64_t v284 = (char *)v491;
                          unint64_t v285 = (llvm::Instruction **)&v461;
                          v460[0] = &v461;
                          v460[1] = (void *)0x400000000;
                          if (v492[0])
                          {
                            unsigned int v286 = 0;
                            uint64_t v287 = 8 * v492[0];
                            do
                            {
                              uint64_t v288 = *(void *)(*(void *)v284 + 40);
                              if (v288) {
                                uint64_t v289 = v288 - 24;
                              }
                              else {
                                uint64_t v289 = 0;
                              }
                              if (*(unsigned __int8 *)(v289 + 16) - 29 >= 0xB) {
                                uint64_t v290 = 0;
                              }
                              else {
                                uint64_t v290 = v289;
                              }
                              if (*(void *)(*(void *)(v290 + 40) + 48) == v290 + 24)
                              {
                                uint64_t v292 = 0;
                              }
                              else
                              {
                                uint64_t v291 = *(void *)(v290 + 24);
                                if (v291) {
                                  uint64_t v292 = v291 - 24;
                                }
                                else {
                                  uint64_t v292 = 0;
                                }
                              }
                              if (v286 >= HIDWORD(v460[1])) {
                                llvm::SmallVectorBase<unsigned int>::grow_pod();
                              }
                              *((void *)v460[0] + v286) = v292;
                              unsigned int v286 = ++LODWORD(v460[1]);
                              v284 += 8;
                              v287 -= 8;
                            }
                            while (v287);
                            unint64_t v285 = (llvm::Instruction **)v460[0];
                          }
                          unsigned int v293 = *v285;
                          v497 = v499;
                          uint64_t v498 = 0x400000000;
                          int v294 = *((_DWORD *)v293 + 5);
                          uint64_t v295 = v294 & 0x7FFFFFF;
                          if ((v294 & 0x7FFFFFF) != 0) {
                            break;
                          }
LABEL_778:
                          uint64_t v394 = v438 + 40;
                          if (*(void *)(v438 + 48) != v426)
                          {
                            uint64_t v394 = *(void *)(v438 + 48);
                            while (1)
                            {
                              uint64_t v395 = v394 - 24;
                              if (!v394) {
                                uint64_t v395 = 0;
                              }
                              if (*(unsigned char *)(v395 + 16) != 83) {
                                break;
                              }
                              uint64_t v394 = *(void *)(v394 + 8);
                              if (v394 == v426)
                              {
                                uint64_t v394 = v438 + 40;
                                goto LABEL_790;
                              }
                            }
                            unsigned int v396 = *(unsigned __int8 *)(v394 - 8) - 38;
                            BOOL v10 = v396 > 0x38;
                            uint64_t v397 = (1 << v396) & 0x100060000000001;
                            if (!v10 && v397 != 0) {
                              uint64_t v394 = *(void *)(v394 + 8);
                            }
                          }
LABEL_790:
                          if (v394) {
                            uint64_t v399 = (llvm::Instruction *)(v394 - 24);
                          }
                          else {
                            uint64_t v399 = 0;
                          }
                          llvm::Instruction::moveBefore(v293, v399);
                          if (LODWORD(v460[1]))
                          {
                            unint64_t v400 = (llvm::Instruction **)v460[0];
                            uint64_t v401 = 8 * LODWORD(v460[1]);
                            do
                            {
                              uint64_t v402 = *v400;
                              if (*v400 != v293)
                              {
                                *(_OWORD *)unint64_t v483 = xmmword_1CFB32AC0;
                                long long v484 = unk_1CFB32AD0;
                                long long v485 = xmmword_1CFB32AE0;
                                llvm::combineMetadata(v293, v402, (unsigned int *)v483, 12, 1);
                                llvm::Instruction::andIRFlags((uint64_t)v293, (uint64_t)v402);
                              }
                              ++v400;
                              v401 -= 8;
                            }
                            while (v401);
                            if (LODWORD(v460[1]))
                            {
                              uint64_t v403 = (llvm::ValueAsMetadata **)v460[0];
                              uint64_t v404 = 8 * LODWORD(v460[1]);
                              do
                              {
                                if (*v403 != v293) {
                                  llvm::Value::doRAUW(*v403, v293, (llvm::Value *)1);
                                }
                                ++v403;
                                v404 -= 8;
                              }
                              while (v404);
                            }
                          }
                          uint64_t v405 = *(void *)(v438 + 48);
                          uint64_t v406 = v405 - 24;
                          if (v405) {
                            uint64_t v407 = v405 - 24;
                          }
                          else {
                            uint64_t v407 = 0;
                          }
                          if (v405 && *(unsigned char *)(v407 + 16) == 83)
                          {
                            do
                            {
                              int v408 = *(_DWORD *)(v406 + 20);
                              if ((v408 & 0x40000000) != 0)
                              {
                                unsigned int v410 = *(void **)(v406 - 8);
                                uint64_t v409 = v408 & 0x7FFFFFF;
                              }
                              else
                              {
                                uint64_t v409 = v408 & 0x7FFFFFF;
                                unsigned int v410 = (void *)(v406 - 32 * v409);
                              }
                              uint64_t v405 = *(void *)(v405 + 8);
                              if (!v409)
                              {
LABEL_817:
                                if ((v408 & 0x40000000) != 0) {
                                  uint64_t v413 = *(llvm::UndefValue ***)(v406 - 8);
                                }
                                else {
                                  uint64_t v413 = (llvm::UndefValue **)(v406 - 32 * v409);
                                }
                                unsigned int v414 = *v413;
                                if (*v413 == (llvm::UndefValue *)v406) {
                                  unsigned int v414 = llvm::UndefValue::get(*(llvm::UndefValue **)v406, v414);
                                }
                                llvm::Value::doRAUW((llvm::ValueAsMetadata *)v406, v414, (llvm::Value *)1);
                                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                              }
                              uint64_t v411 = 32 * v409;
                              while (1)
                              {
                                uint64_t v412 = (void *)(v406 - 32 * v409);
                                if ((v408 & 0x40000000) != 0) {
                                  uint64_t v412 = *(void **)(v406 - 8);
                                }
                                if (*v412 != *v410) {
                                  break;
                                }
                                v410 += 4;
                                v411 -= 32;
                                if (!v411) {
                                  goto LABEL_817;
                                }
                              }
                              uint64_t v415 = v405 - 24;
                              if (!v405) {
                                uint64_t v415 = 0;
                              }
                              int v416 = *(unsigned __int8 *)(v415 + 16);
                              if (v416 == 83) {
                                uint64_t v406 = v415;
                              }
                              else {
                                uint64_t v406 = 0;
                              }
                            }
                            while (v405 && v416 == 83);
                          }
                          int v2 = v424;
                          if (LODWORD(v460[1]))
                          {
                            uint64_t v417 = (llvm::Instruction **)v460[0];
                            uint64_t v418 = 8 * LODWORD(v460[1]);
                            do
                            {
                              if (*v417 != v293) {
                                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                              }
                              ++v417;
                              v418 -= 8;
                            }
                            while (v418);
                          }
                          if (v497 != v499) {
                            free(v497);
                          }
                          if (v460[0] != &v461) {
                            free(v460[0]);
                          }
                          int v19 = HIDWORD(__src[0]);
                          if (++v425 >= HIDWORD(__src[0])) {
                            goto LABEL_842;
                          }
                        }
                        unsigned int v296 = 0;
                        uint64_t v297 = 0;
                        uint64_t v435 = v293;
                        uint64_t v427 = v295;
                        while (2)
                        {
                          int v298 = (int)v460[1];
                          int v299 = *((_DWORD *)v293 + 5);
                          uint64_t v300 = 32 * v297;
                          if (!LODWORD(v460[1]))
                          {
                            if ((v299 & 0x40000000) == 0) {
                              goto LABEL_683;
                            }
LABEL_681:
                            uint64_t v309 = (_DWORD *)*((void *)v293 - 1);
LABEL_684:
                            unint64_t v310 = *(llvm::Value **)&v309[8 * v297];
                            if (v296 >= HIDWORD(v498)) {
LABEL_741:
                            }
                              llvm::SmallVectorBase<unsigned int>::grow_pod();
LABEL_685:
                            v497[v296] = v310;
                            unsigned int v296 = v498 + 1;
                            LODWORD(v498) = v498 + 1;
                            if (++v297 == v295)
                            {
                              int v380 = *((_DWORD *)v293 + 5);
                              uint64_t v381 = v380 & 0x7FFFFFF;
                              if ((v380 & 0x7FFFFFF) != 0)
                              {
                                uint64_t v382 = 0;
                                unint64_t v383 = 0;
                                uint64_t v384 = 8 * v381;
                                do
                                {
                                  int v385 = *((_DWORD *)v293 + 5);
                                  if ((v385 & 0x40000000) != 0) {
                                    unint64_t v386 = (_DWORD *)*((void *)v293 - 1);
                                  }
                                  else {
                                    unint64_t v386 = (_DWORD *)((char *)v293 - 32 * (v385 & 0x7FFFFFF));
                                  }
                                  uint64_t v387 = &v386[v382];
                                  uint64_t v388 = v497[v383 / 8];
                                  if (*(void *)&v386[v382])
                                  {
                                    **((void **)v387 + 2) = *((void *)v387 + 1);
                                    uint64_t v389 = *((void *)v387 + 1);
                                    if (v389) {
                                      *(void *)(v389 + 16) = *((void *)v387 + 2);
                                    }
                                  }
                                  *(void *)uint64_t v387 = v388;
                                  if (v388)
                                  {
                                    uint64_t v392 = *(void *)(v388 + 8);
                                    unint64_t v390 = (void *)(v388 + 8);
                                    uint64_t v391 = v392;
                                    uint64_t v393 = &v386[v382];
                                    *((void *)v393 + 1) = v392;
                                    if (v392) {
                                      *(void *)(v391 + 16) = v393 + 2;
                                    }
                                    *((void *)v393 + 2) = v390;
                                    void *v390 = v387;
                                  }
                                  v383 += 8;
                                  v382 += 8;
                                }
                                while (v384 != v383);
                              }
                              goto LABEL_778;
                            }
                            continue;
                          }
                          break;
                        }
                        unint64_t v301 = (char *)v460[0];
                        int v302 = v299 & 0x40000000;
                        uint64_t v303 = 8 * LODWORD(v460[1]);
                        while (1)
                        {
                          uint64_t v304 = *(void *)v301;
                          int v305 = *(_DWORD *)(*(void *)v301 + 20);
                          uint64_t v306 = (v305 & 0x40000000) != 0 ? *(void *)(v304 - 8) : v304 - 32 * (v305 & 0x7FFFFFF);
                          uint64_t v307 = *(void *)(v306 + 32 * v297);
                          uint64_t v308 = v302
                               ? *(void *)(*((void *)v293 - 1) + 32 * v297)
                               : *((void *)v293 + 4 * v297 + -4 * (v299 & 0x7FFFFFF));
                          if (v307 != v308) {
                            break;
                          }
                          v301 += 8;
                          v303 -= 8;
                          if (!v303)
                          {
                            if (v302) {
                              goto LABEL_681;
                            }
LABEL_683:
                            uint64_t v309 = (_DWORD *)((char *)v293 - 32 * (v299 & 0x7FFFFFF));
                            goto LABEL_684;
                          }
                        }
                        unint64_t v311 = *(uint64_t ***)v308;
                        uint64_t v429 = v297;
                        if ((*(unsigned char *)(v308 + 23) & 0x10) != 0)
                        {
                          uint64_t v312 = **v311;
                          uint64_t v313 = *(void *)(v312 + 152);
                          uint64_t v314 = *(unsigned int *)(v312 + 168);
                          if (!v314) {
                            goto LABEL_694;
                          }
                          LODWORD(v315) = (v314 - 1) & ((v308 >> 4) ^ (v308 >> 9));
                          uint64_t v316 = (uint64_t *)(v313 + 16 * v315);
                          uint64_t v317 = *v316;
                          if (*v316 != v308)
                          {
                            int v318 = 1;
                            while (v317 != -4096)
                            {
                              int v319 = v315 + v318++;
                              uint64_t v315 = v319 & (v314 - 1);
                              uint64_t v317 = *(void *)(v313 + 16 * v315);
                              if (v317 == v308)
                              {
                                uint64_t v316 = (uint64_t *)(v313 + 16 * v315);
                                goto LABEL_695;
                              }
                            }
LABEL_694:
                            uint64_t v316 = (uint64_t *)(v313 + 16 * v314);
                          }
LABEL_695:
                          long long v320 = (void *)v316[1];
                          unsigned int v323 = (void *)*v320;
                          uint64_t v322 = (char *)(v320 + 2);
                          uint64_t v321 = v323;
                        }
                        else
                        {
                          uint64_t v321 = 0;
                          uint64_t v322 = &byte_1CFBCE98E;
                        }
                        LOWORD(v485) = 773;
                        v483[0] = v322;
                        v483[1] = v321;
                        *(void *)&long long v484 = ".sink";
                        unsigned int v324 = *(uint64_t **)(v438 + 48);
                        unint64_t v325 = operator new(0x48uLL);
                        uint64_t v326 = v325;
                        v325[1] = v311;
                        unint64_t v310 = (llvm::Value *)(v325 + 1);
                        *unint64_t v325 = 0;
                        v325[2] = 0;
                        v325[3] = 0x4000000000000053;
                        *((_OWORD *)v325 + 2) = 0u;
                        uint64_t v327 = (char *)(v325 + 4);
                        *((_OWORD *)v325 + 3) = 0u;
                        *((_DWORD *)v325 + 16) = 0;
                        if (v324)
                        {
                          uint64_t v362 = v324[2];
                          v325[6] = v362;
                          *(_WORD *)(v362 + 18) &= ~0x8000u;
                          if ((*((unsigned char *)v325 + 31) & 0x10) != 0)
                          {
                            uint64_t v372 = *(void *)(v362 + 56);
                            if (v372)
                            {
                              uint64_t v373 = *(llvm::ValueSymbolTable **)(v372 + 104);
                              if (v373) {
                                llvm::ValueSymbolTable::reinsertValue(v373, v310);
                              }
                            }
                          }
                          uint64_t v363 = *v324;
                          v326[4] = *v324;
                          v326[5] = v324;
                          *(void *)(v363 + 8) = v327;
                          *unsigned int v324 = (uint64_t)v327;
                        }
                        *((_DWORD *)v326 + 17) = v298;
                        llvm::Value::setNameImpl(v310, (const char **)v483);
                        unsigned int v293 = v435;
                        if (*((unsigned char *)v326 + 24))
                        {
LABEL_698:
                          uint64_t v328 = *((unsigned int *)v326 + 17);
                          unint64_t v329 = operator new(40 * v328);
                          *uint64_t v326 = v329;
                          if (v328)
                          {
                            long long v330 = &v329[4 * v328];
                            do
                            {
                              *unint64_t v329 = 0;
                              v329[1] = 0;
                              v329[2] = 0;
                              v329[3] = v310;
                              v329 += 4;
                            }
                            while (v329 != v330);
                          }
                          if (LODWORD(v460[1]))
                          {
                            uint64_t v331 = (char *)v460[0];
                            unint64_t v332 = (char *)v460[0] + 8 * LODWORD(v460[1]);
                            unint64_t v431 = v332;
                            unint64_t v433 = v310;
                            do
                            {
                              uint64_t v333 = *(void *)v331;
                              int v334 = *(_DWORD *)(*(void *)v331 + 20);
                              if ((v334 & 0x40000000) != 0) {
                                uint64_t v335 = *(void *)(v333 - 8);
                              }
                              else {
                                uint64_t v335 = v333 - 32 * (v334 & 0x7FFFFFF);
                              }
                              uint64_t v336 = *(void *)(v335 + v300);
                              uint64_t v337 = *(void *)(v333 + 40);
                              int v338 = *((_DWORD *)v326 + 7);
                              uint64_t v339 = v338 & 0x7FFFFFF;
                              if ((v338 & 0x7FFFFFF) == *((_DWORD *)v326 + 17))
                              {
                                unsigned int v352 = v339 + (v339 >> 1);
                                if (v352 <= 2) {
                                  uint64_t v353 = 2;
                                }
                                else {
                                  uint64_t v353 = v352;
                                }
                                *((_DWORD *)v326 + 17) = v353;
                                if ((v338 & 0x40000000) != 0) {
                                  uint64_t v354 = (uint64_t *)*v326;
                                }
                                else {
                                  uint64_t v354 = (uint64_t *)((char *)v310 - 32 * v339);
                                }
                                __pa = v354;
                                unint64_t v355 = operator new(40 * v353);
                                *uint64_t v326 = v355;
                                unint64_t v356 = v355;
                                do
                                {
                                  *unint64_t v356 = 0;
                                  v356[1] = 0;
                                  v356[2] = 0;
                                  v356[3] = v310;
                                  v356 += 4;
                                }
                                while (v356 != &v355[4 * v353]);
                                int v357 = *((_DWORD *)v326 + 7);
                                if ((v357 & 0x40000000) != 0) {
                                  uint64_t v358 = (uint64_t)v355;
                                }
                                else {
                                  uint64_t v358 = (uint64_t)v310 - 32 * (v357 & 0x7FFFFFF);
                                }
                                sub_1CC5E4108((uint64_t)v483, __pa, &__pa[4 * v339], v358);
                                if (v339)
                                {
                                  memmove((void *)(v358 + 32 * v353), &__pa[4 * v339], 8 * v339);
                                  uint64_t v359 = 4 * v339;
                                  do
                                  {
                                    unsigned int v360 = &__pa[v359];
                                    if (__pa[v359 - 4])
                                    {
                                      *(void *)*(v360 - 2) = *(v360 - 3);
                                      uint64_t v361 = *(v360 - 3);
                                      if (v361) {
                                        *(void *)(v361 + 16) = *(v360 - 2);
                                      }
                                    }
                                    v359 -= 4;
                                  }
                                  while (v359 * 8);
                                }
                                operator delete(__pa);
                                int v338 = *((_DWORD *)v326 + 7);
                                int v3 = v428;
                                unint64_t v310 = v433;
                                unsigned int v293 = v435;
                                unint64_t v332 = v431;
                              }
                              uint64_t v340 = (v338 + 1) & 0x7FFFFFF;
                              *((_DWORD *)v326 + 7) = v338 & 0xF8000000 | (v338 + 1) & 0x7FFFFFF;
                              if ((v338 & 0x40000000) != 0) {
                                uint64_t v341 = (char *)*v326;
                              }
                              else {
                                uint64_t v341 = (char *)v310 - 32 * v340;
                              }
                              uint64_t v342 = (v340 - 1);
                              uint64_t v343 = &v341[32 * v342];
                              if (*(void *)v343)
                              {
                                **((void **)v343 + 2) = *((void *)v343 + 1);
                                uint64_t v351 = *((void *)v343 + 1);
                                if (v351) {
                                  *(void *)(v351 + 16) = *((void *)v343 + 2);
                                }
                              }
                              *(void *)uint64_t v343 = v336;
                              if (v336)
                              {
                                uint64_t v346 = *(void *)(v336 + 8);
                                uint64_t v345 = (char **)(v336 + 8);
                                uint64_t v344 = v346;
                                uint64_t v347 = &v341[32 * v342];
                                *((void *)v347 + 1) = v346;
                                if (v346) {
                                  *(void *)(v344 + 16) = v347 + 8;
                                }
                                *((void *)v347 + 2) = v345;
                                *uint64_t v345 = v343;
                              }
                              int v348 = *((_DWORD *)v326 + 7);
                              uint64_t v349 = v348 & 0x7FFFFFF;
                              if ((v348 & 0x40000000) != 0) {
                                uint64_t v350 = (char *)*v326;
                              }
                              else {
                                uint64_t v350 = (char *)v310 - 32 * v349;
                              }
                              *(void *)&v350[32 * *((unsigned int *)v326 + 17) + 8 * (v349 - 1)] = v337;
                              v331 += 8;
                            }
                            while (v331 != v332);
                          }
                          unsigned int v296 = v498;
                          uint64_t v295 = v427;
                          uint64_t v297 = v429;
                          if (v498 >= HIDWORD(v498)) {
                            goto LABEL_741;
                          }
                          goto LABEL_685;
                        }
                        if ((*((unsigned char *)v326 + 31) & 0x10) == 0) {
                          goto LABEL_763;
                        }
                        uint64_t v364 = ***(void ***)v310;
                        uint64_t v365 = *(void *)(v364 + 152);
                        uint64_t v366 = *(unsigned int *)(v364 + 168);
                        if (!v366) {
                          goto LABEL_755;
                        }
                        LODWORD(v367) = (v366 - 1) & ((v310 >> 4) ^ (v310 >> 9));
                        unint64_t v368 = (llvm::Value **)(v365 + 16 * v367);
                        uint64_t v369 = *v368;
                        if (*v368 != v310)
                        {
                          int v370 = 1;
                          while (v369 != (llvm::Value *)-4096)
                          {
                            int v371 = v367 + v370++;
                            uint64_t v367 = v371 & (v366 - 1);
                            uint64_t v369 = *(llvm::Value **)(v365 + 16 * v367);
                            if (v369 == v310)
                            {
                              unint64_t v368 = (llvm::Value **)(v365 + 16 * v367);
                              goto LABEL_756;
                            }
                          }
LABEL_755:
                          unint64_t v368 = (llvm::Value **)(v365 + 16 * v366);
                        }
LABEL_756:
                        unint64_t v374 = v368[1];
                        unint64_t v377 = *(void *)v374;
                        int v375 = (char *)v374 + 16;
                        unint64_t v376 = v377;
                        if (v377 >= 5
                          && (*(_DWORD *)v375 == *(_DWORD *)"llvm." ? (BOOL v378 = v375[4] == aLlvm_1[4]) : (BOOL v378 = 0), v378))
                        {
                          *((_DWORD *)v326 + 10) |= 0x2000u;
                          int v379 = llvm::Function::lookupIntrinsicID(v375, v376);
                        }
                        else
                        {
LABEL_763:
                          int v379 = 0;
                          *((_DWORD *)v326 + 10) &= ~0x2000u;
                        }
                        *((_DWORD *)v326 + 11) = v379;
                        goto LABEL_698;
                      }
                    }
                    int v19 = 0;
LABEL_842:
                    if (v491 != &v493) {
                      free(v491);
                    }
                  }
                  else
                  {
                    int v19 = 0;
                  }
                  if (v445 != v444) {
                    free(v445);
                  }
                  sub_1CCD6E0A8((uint64_t *)&v449);
                  MEMORY[0x1D25D9CD0](v449, 8);
                  unsigned int v419 = (char *)v466;
                  if (v467)
                  {
                    uint64_t v420 = 72 * v467;
                    do
                    {
                      uint64_t v421 = *(char **)&v419[v420 - 48];
                      if (&v419[v420 - 32] != v421) {
                        free(v421);
                      }
                      v420 -= 72;
                    }
                    while (v420);
                    unsigned int v419 = (char *)v466;
                  }
                  if (v419 != v468) {
                    free(v419);
                  }
                  if (v476 != v478) {
                    free(v476);
                  }
                  if (v473 != v475) {
                    free(v473);
                  }
                  if ((v471 & 1) == 0) {
                    MEMORY[0x1D25D9CD0](*(void *)&v472[0], 8);
                  }
LABEL_42:
                  if (__base != v482) {
                    free(__base);
                  }
                  v3 += v19;
                  if (v2 == v437)
                  {
                    int v2 = (char *)v441;
                    if (v441) {
                      goto LABEL_862;
                    }
                    return v3 != 0;
                  }
                  goto LABEL_3;
                }
                continue;
              }
              goto LABEL_456;
            }
          }
          else
          {
            uint64_t v106 = 0;
            int v105 = 0;
            int v456 = 0;
          }
          break;
        }
        uint64_t v109 = &v105[2 * v106];
        int v107 = v109;
        goto LABEL_224;
      }
    }
  }
  int v3 = 0;
  if (v442)
  {
LABEL_862:
    uint64_t v442 = v2;
    operator delete(v2);
  }
  return v3 != 0;
}

uint64_t sub_1CCD6C220(uint64_t a1)
{
  int v2 = *(void **)(a1 + 168);
  if (v2 != (void *)(a1 + 184)) {
    free(v2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 96);
  if (v3)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 88);
    uint64_t v5 = 8 * v3;
    do
    {
      uint64_t v6 = *v4++;
      MEMORY[0x1D25D9CD0](v6, 8);
      v5 -= 8;
    }
    while (v5);
  }
  uint64_t v7 = *(uint64_t **)(a1 + 136);
  uint64_t v8 = *(unsigned int *)(a1 + 144);
  if (v8)
  {
    uint64_t v11 = 16 * v8;
    do
    {
      uint64_t v12 = *v7;
      v7 += 2;
      MEMORY[0x1D25D9CD0](v12, 8);
      v11 -= 16;
    }
    while (v11);
    uint64_t v7 = *(uint64_t **)(a1 + 136);
  }
  if (v7 != (uint64_t *)(a1 + 152)) {
    free(v7);
  }
  BOOL v9 = *(void **)(a1 + 88);
  if (v9 != (void *)(a1 + 104)) {
    free(v9);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 48), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 24), 8);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

void sub_1CCD6C304(uint64_t a1)
{
}

uint64_t sub_1CCD6C3AC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCF22D0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F263E1C8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCF22D8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCD6C304;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCF22D8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCD6C45C(_DWORD *a1, void *a2)
{
  uint64_t v5 = 0;
  uint64_t result = sub_1CC874F80((uint64_t)a1, a2, &v5);
  if (result)
  {
    *uint64_t v5 = -8192;
    int v4 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v4;
  }
  return result;
}

void sub_1CCD6C4B0(uint64_t *a1)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  a1[1] = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCF22E0))
  {
    qword_1EBCF2300 = 0;
    qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
    qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
    qword_1EBCF2328 = 0x400000000;
    qword_1EBCF22F8 = 0x400000001;
    __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCF22E0);
  }
  uint64_t v8 = v10;
  uint64_t v9 = 0x400000000;
  if (qword_1EBCF22F8) {
    sub_1CBB08064((uint64_t)&v8, (uint64_t)&qword_1EBCF22F0);
  }
  uint64_t v11 = v13;
  uint64_t v12 = 0x400000000;
  if (qword_1EBCF2328) {
    sub_1CBB08064((uint64_t)&v11, (uint64_t)&qword_1EBCF2320);
  }
  uint64_t v2 = *((unsigned int *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *a1;
    uint64_t v5 = 96 * v2;
    do
    {
      uint64_t v6 = (void *)(v4 + v3);
      *uint64_t v6 = v4 + v3 + 16;
      v6[1] = 0x400000000;
      if (v9) {
        sub_1CBB08064(v4 + v3, (uint64_t)&v8);
      }
      v6[6] = v6 + 8;
      uint64_t v7 = (uint64_t)(v6 + 6);
      *(void *)(v7 + 8) = 0x400000000;
      if (v12) {
        sub_1CBB08064(v7, (uint64_t)&v11);
      }
      v3 += 96;
    }
    while (v5 != v3);
  }
  if (v11 != v13) {
    free(v11);
  }
  if (v8 != v10) {
    free(v8);
  }
}

uint64_t sub_1CCD6C688(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2 != (void *)(a1 + 64)) {
    free(v2);
  }
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCD6C6D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD v15[4] = *MEMORY[0x1E4F143B8];
  v12[0] = 0;
  uint64_t result = sub_1CCD6C930(*(void *)a2, *(unsigned int *)(a2 + 16), a3, (uint64_t *)v12);
  uint64_t v7 = v12[0];
  if (result)
  {
    char v8 = 0;
    goto LABEL_17;
  }
  int v9 = *(_DWORD *)(a2 + 8);
  unsigned int v10 = *(_DWORD *)(a2 + 16);
  if (4 * v9 + 4 >= 3 * v10)
  {
    v10 *= 2;
  }
  else if (v10 + ~v9 - *(_DWORD *)(a2 + 12) > v10 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CCD6CF78((void **)a2, v10);
  v12[0] = 0;
  sub_1CCD6C930(*(void *)a2, *(unsigned int *)(a2 + 16), a3, (uint64_t *)v12);
  uint64_t v7 = v12[0];
LABEL_5:
  ++*(_DWORD *)(a2 + 8);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCF22E0))
  {
    qword_1EBCF2300 = 0;
    qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
    qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
    qword_1EBCF2328 = 0x400000000;
    qword_1EBCF22F8 = 0x400000001;
    __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCF22E0);
  }
  v12[0] = v13;
  v12[1] = (void *)0x400000000;
  if (qword_1EBCF22F8) {
    sub_1CBB08064((uint64_t)v12, (uint64_t)&qword_1EBCF22F0);
  }
  v14[0] = v15;
  v14[1] = (void *)0x400000000;
  if (qword_1EBCF2328) {
    sub_1CBB08064((uint64_t)v14, (uint64_t)&qword_1EBCF2320);
  }
  if (!sub_1CCD6CC74((uint64_t)v7, (uint64_t)v12)) {
    --*(_DWORD *)(a2 + 12);
  }
  if (v14[0] != v15) {
    free(v14[0]);
  }
  if (v12[0] != v13) {
    free(v12[0]);
  }
  sub_1CBB08064((uint64_t)v7, a3);
  uint64_t result = sub_1CBB08064((uint64_t)v7 + 48, a3 + 48);
  char v8 = 1;
LABEL_17:
  uint64_t v11 = *(void *)a2 + 96 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CCD6C930(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a2;
  v23[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCF22E0))
    {
      qword_1EBCF2300 = 0;
      qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
      qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
      qword_1EBCF2328 = 0x400000000;
      qword_1EBCF22F8 = 0x400000001;
      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCF22E0);
    }
    v20[0] = v21;
    v20[1] = (void *)0x400000000;
    if (qword_1EBCF22F8) {
      sub_1CBB08064((uint64_t)v20, (uint64_t)&qword_1EBCF22F0);
    }
    v22[0] = v23;
    v22[1] = (void *)0x400000000;
    if (qword_1EBCF2328) {
      sub_1CBB08064((uint64_t)v22, (uint64_t)&qword_1EBCF2320);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCF22E8))
    {
      qword_1EBCF2360 = 1;
      qword_1EBCF2350 = (uint64_t)&qword_1EBCF2360;
      qword_1EBCF2380 = (uint64_t)&unk_1EBCF2390;
      qword_1EBCF2388 = 0x400000000;
      qword_1EBCF2358 = 0x400000001;
      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF2350, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCF22E8);
    }
    v16[0] = v17;
    v16[1] = (void *)0x400000000;
    if (qword_1EBCF2358) {
      sub_1CBB08064((uint64_t)v16, (uint64_t)&qword_1EBCF2350);
    }
    v18[0] = v19;
    v18[1] = (void *)0x400000000;
    if (qword_1EBCF2388) {
      sub_1CBB08064((uint64_t)v18, (uint64_t)&qword_1EBCF2380);
    }
    int v9 = v5 - 1;
    unsigned int v10 = v9 & sub_1CD48BB60(*(void **)a3, *(void *)a3 + 8 * *(unsigned int *)(a3 + 8));
    uint64_t v11 = a1 + 96 * v10;
    if (sub_1CCD6CC74(a3, v11))
    {
      uint64_t v5 = 1;
    }
    else
    {
      unsigned int v15 = v10;
      uint64_t v12 = 0;
      int v13 = v9;
      int v14 = 1;
      uint64_t v5 = 1;
      while (!sub_1CCD6CC74(v11, (uint64_t)v20))
      {
        if (sub_1CCD6CC74(v11, (uint64_t)v16) && v12 == 0) {
          uint64_t v12 = v11;
        }
        unsigned int v15 = (v15 + v14) & v13;
        uint64_t v11 = a1 + 96 * v15;
        ++v14;
        if (sub_1CCD6CC74(a3, v11)) {
          goto LABEL_16;
        }
      }
      uint64_t v5 = 0;
      if (v12) {
        uint64_t v11 = v12;
      }
    }
LABEL_16:
    *a4 = v11;
    if (v18[0] != v19) {
      free(v18[0]);
    }
    if (v16[0] != v17) {
      free(v16[0]);
    }
    if (v22[0] != v23) {
      free(v22[0]);
    }
    if (v20[0] != v21) {
      free(v20[0]);
    }
  }
  else
  {
    *a4 = 0;
  }
  return v5;
}

BOOL sub_1CCD6CC74(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 == *(_DWORD *)(a2 + 8)
    && !memcmp(*(const void **)a1, *(const void **)a2, 8 * v2)
    && (uint64_t v5 = *(unsigned int *)(a1 + 56), v5 == *(_DWORD *)(a2 + 56)))
  {
    return memcmp(*(const void **)(a1 + 48), *(const void **)(a2 + 48), 8 * v5) == 0;
  }
  else
  {
    return 0;
  }
}

void sub_1CCD6CCEC(uint64_t *a1)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCF22E0))
  {
    qword_1EBCF2300 = 0;
    qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
    qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
    qword_1EBCF2328 = 0x400000000;
    qword_1EBCF22F8 = 0x400000001;
    __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCF22E0);
  }
  v8[0] = v9;
  v8[1] = (void *)0x400000000;
  if (qword_1EBCF22F8) {
    sub_1CBB08064((uint64_t)v8, (uint64_t)&qword_1EBCF22F0);
  }
  v10[0] = v11;
  v10[1] = (void *)0x400000000;
  if (qword_1EBCF2328) {
    sub_1CBB08064((uint64_t)v10, (uint64_t)&qword_1EBCF2320);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCF22E8))
  {
    qword_1EBCF2360 = 1;
    qword_1EBCF2350 = (uint64_t)&qword_1EBCF2360;
    qword_1EBCF2380 = (uint64_t)&unk_1EBCF2390;
    qword_1EBCF2388 = 0x400000000;
    qword_1EBCF2358 = 0x400000001;
    __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF2350, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCF22E8);
  }
  v4[0] = v5;
  v4[1] = (void *)0x400000000;
  if (qword_1EBCF2358) {
    sub_1CBB08064((uint64_t)v4, (uint64_t)&qword_1EBCF2350);
  }
  v6[0] = v7;
  v6[1] = (void *)0x400000000;
  if (qword_1EBCF2388) {
    sub_1CBB08064((uint64_t)v6, (uint64_t)&qword_1EBCF2380);
  }
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  while (v2 != v3 && (sub_1CCD6CC74(v2, (uint64_t)v8) || sub_1CCD6CC74(v2, (uint64_t)v4)))
  {
    v2 += 96;
    *a1 = v2;
  }
  if (v6[0] != v7) {
    free(v6[0]);
  }
  if (v4[0] != v5) {
    free(v4[0]);
  }
  if (v10[0] != v11) {
    free(v10[0]);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

void sub_1CCD6CF78(void **a1, int a2)
{
  uint64_t v2 = (uint64_t *)a1;
  v43[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((unsigned int *)a1 + 4);
  uint64_t v4 = (char *)*a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *((_DWORD *)a1 + 4) = v8;
  *a1 = operator new(96 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CCD6C4B0(v2);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E0, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCF22E0))
    {
      qword_1EBCF2300 = 0;
      qword_1EBCF22F0 = (uint64_t)&qword_1EBCF2300;
      qword_1EBCF2320 = (uint64_t)&unk_1EBCF2330;
      qword_1EBCF2328 = 0x400000000;
      qword_1EBCF22F8 = 0x400000001;
      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF22F0, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCF22E0);
    }
    v40[0] = v41;
    v40[1] = (void *)0x400000000;
    if (qword_1EBCF22F8) {
      sub_1CBB08064((uint64_t)v40, (uint64_t)&qword_1EBCF22F0);
    }
    v42[0] = v43;
    v42[1] = (void *)0x400000000;
    if (qword_1EBCF2328) {
      sub_1CBB08064((uint64_t)v42, (uint64_t)&qword_1EBCF2320);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCF22E8, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EBCF22E8))
    {
      qword_1EBCF2360 = 1;
      qword_1EBCF2350 = (uint64_t)&qword_1EBCF2360;
      qword_1EBCF2380 = (uint64_t)&unk_1EBCF2390;
      qword_1EBCF2388 = 0x400000000;
      qword_1EBCF2358 = 0x400000001;
      __cxa_atexit((void (*)(void *))sub_1CCD6C688, &qword_1EBCF2350, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCF22E8);
    }
    v36[0] = v37;
    v36[1] = (void *)0x400000000;
    if (qword_1EBCF2358) {
      sub_1CBB08064((uint64_t)v36, (uint64_t)&qword_1EBCF2350);
    }
    v38[0] = v39;
    v38[1] = (void *)0x400000000;
    if (qword_1EBCF2388) {
      sub_1CBB08064((uint64_t)v38, (uint64_t)&qword_1EBCF2380);
    }
    if (v3)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 96 * v3;
      uint64_t v11 = v4;
      unint64_t v34 = (void **)v2;
      do
      {
        uint64_t v12 = (const void **)&v4[v9];
        if (!sub_1CCD6CC74((uint64_t)&v4[v9], (uint64_t)v40) && !sub_1CCD6CC74((uint64_t)&v4[v9], (uint64_t)v36))
        {
          uint64_t v35 = 0;
          sub_1CCD6C930(*v2, *((unsigned int *)v2 + 4), (uint64_t)&v4[v9], &v35);
          uint64_t v13 = v35;
          if (v12 != (const void **)v35)
          {
            int v14 = &v4[v9];
            uint64_t v16 = (uint64_t)&v4[v9 + 16];
            unsigned int v15 = *(const void **)&v4[v9];
            if ((const void *)v16 == v15)
            {
              unsigned int v19 = *((_DWORD *)v14 + 2);
              uint64_t v18 = v14 + 8;
              uint64_t v17 = v19;
              uint64_t v20 = *(unsigned int *)(v35 + 8);
              if (v20 >= v19)
              {
                if (v17) {
                  memmove(*(void **)v35, v15, 8 * v17);
                }
              }
              else
              {
                if (*(_DWORD *)(v35 + 12) < v17)
                {
                  *(_DWORD *)(v35 + 8) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v20) {
                  memmove(*(void **)v35, v15, 8 * v20);
                }
                else {
                  uint64_t v20 = 0;
                }
                uint64_t v21 = *v18;
                if (v20 != v21) {
                  memcpy((void *)(*(void *)v13 + 8 * v20), (char *)*v12 + 8 * v20, (unsigned char *)*v12 + 8 * v21 - ((unsigned char *)*v12 + 8 * v20));
                }
              }
              *(_DWORD *)(v13 + 8) = v17;
            }
            else
            {
              if (*(void *)v35 != v35 + 16)
              {
                free(*(void **)v35);
                unsigned int v15 = *v12;
              }
              *(void *)uint64_t v13 = v15;
              uint64_t v18 = v11 + 8;
              int v33 = &v4[v9];
              *(void *)(v13 + 8) = *(void *)&v4[v9 + 8];
              *(void *)int v33 = v16;
              *((_DWORD *)v33 + 3) = 0;
            }
            _DWORD *v18 = 0;
            uint64_t v22 = &v4[v9];
            uint64_t v23 = *(const void **)&v4[v9 + 48];
            uint64_t v24 = (uint64_t)&v4[v9 + 64];
            if ((const void *)v24 == v23)
            {
              uint64_t v25 = (void **)(v13 + 48);
              unint64_t v27 = v22 + 56;
              uint64_t v26 = *((unsigned int *)v22 + 14);
              uint64_t v28 = *(unsigned int *)(v13 + 56);
              if (v28 >= v26)
              {
                if (v26) {
                  memmove(*v25, v23, 8 * v26);
                }
              }
              else
              {
                if (*(_DWORD *)(v13 + 60) < v26)
                {
                  *(_DWORD *)(v13 + 56) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v28)
                {
                  memmove(*v25, v23, 8 * v28);
                  uint64_t v25 = (void **)(v13 + 48);
                }
                else
                {
                  uint64_t v28 = 0;
                }
                uint64_t v29 = *v27;
                if (v28 != v29) {
                  memcpy((char *)*v25 + 8 * v28, (const void *)(*((void *)v22 + 6) + 8 * v28), 8 * v29 - 8 * v28);
                }
              }
              *(_DWORD *)(v13 + 56) = v26;
            }
            else
            {
              unint64_t v32 = *(void **)(v13 + 48);
              if (v32 != (void *)(v13 + 64))
              {
                free(v32);
                uint64_t v23 = (const void *)*((void *)v22 + 6);
              }
              *(void *)(v13 + 48) = v23;
              unint64_t v27 = v11 + 56;
              *(void *)(v13 + 56) = *(void *)&v4[v9 + 56];
              *((void *)v22 + 6) = v24;
              *(_DWORD *)&v4[v9 + 60] = 0;
            }
            _DWORD *v27 = 0;
            uint64_t v2 = (uint64_t *)v34;
          }
          ++*((_DWORD *)v2 + 2);
        }
        __n128 v30 = (const void **)v12[6];
        if (v12 + 8 != v30) {
          free(v30);
        }
        unsigned __int32 v31 = *(char **)&v4[v9];
        if (&v4[v9 + 16] != v31) {
          free(v31);
        }
        v11 += 96;
        v9 += 96;
      }
      while (v10 != v9);
    }
    if (v38[0] != v39) {
      free(v38[0]);
    }
    if (v36[0] != v37) {
      free(v36[0]);
    }
    if (v42[0] != v43) {
      free(v42[0]);
    }
    if (v40[0] != v41) {
      free(v40[0]);
    }
    MEMORY[0x1D25D9CD0](v4, 8);
  }
  else
  {
    sub_1CCD6C4B0(v2);
  }
}

uint64_t sub_1CCD6D534(size_t a1, uint64_t a2)
{
  uint64_t v56 = a2;
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  unsigned int v6 = a2 >> 4;
  if (v5)
  {
    LODWORD(v7) = (v5 - 1) & (v6 ^ (a2 >> 9));
    unsigned int v8 = (uint64_t *)(v4 + 16 * v7);
    uint64_t v9 = *v8;
    if (*v8 == a2) {
      goto LABEL_8;
    }
    int v10 = 1;
    while (v9 != -4096)
    {
      int v11 = v7 + v10++;
      uint64_t v7 = v11 & (v5 - 1);
      uint64_t v9 = *(void *)(v4 + 16 * v7);
      if (v9 == a2)
      {
        unsigned int v8 = (uint64_t *)(v4 + 16 * v7);
        goto LABEL_8;
      }
    }
  }
  unsigned int v8 = (uint64_t *)(v4 + 16 * v5);
LABEL_8:
  if (v8 == (uint64_t *)(v4 + 16 * v5))
  {
    unsigned int v13 = *(unsigned __int8 *)(a2 + 16);
    if (v13 <= 0x1B)
    {
      int v16 = *(_DWORD *)(a1 + 248);
      if (v5)
      {
        int v25 = v5 - 1;
        unsigned int v26 = v25 & (v6 ^ (a2 >> 9));
        unsigned int v19 = (uint64_t *)(v4 + 16 * v26);
        uint64_t v27 = *v19;
        if (*v19 != a2)
        {
          uint64_t v21 = 0;
          int v28 = 1;
          while (v27 != -4096)
          {
            if (v21) {
              BOOL v29 = 0;
            }
            else {
              BOOL v29 = v27 == -8192;
            }
            if (v29) {
              uint64_t v21 = v19;
            }
            unsigned int v30 = v26 + v28++;
            unsigned int v26 = v30 & v25;
            unsigned int v19 = (uint64_t *)(v4 + 16 * v26);
            uint64_t v27 = *v19;
            if (*v19 == a2) {
              goto LABEL_41;
            }
          }
          goto LABEL_37;
        }
LABEL_41:
        *((_DWORD *)v19 + 2) = v16;
        uint64_t v12 = *(unsigned int *)(a1 + 248);
        *(_DWORD *)(a1 + 248) = v12 + 1;
        return v12;
      }
LABEL_43:
      unsigned __int32 v31 = 0;
LABEL_40:
      unsigned int v19 = sub_1CBFFD5B4(a1, (uint64_t)&v56, &v56, v31);
      *unsigned int v19 = v56;
      *((_DWORD *)v19 + 2) = 0;
      goto LABEL_41;
    }
    uint64_t v14 = v13 - 33;
    if (v14 <= 0x3C)
    {
      if (((1 << v14) & 0x171B3FFE23FFFF81) != 0)
      {
        unint64_t v15 = sub_1CCD6DA8C(a1, a2);
        if (!v15)
        {
          uint64_t v4 = *(void *)a1;
          LODWORD(v5) = *(_DWORD *)(a1 + 16);
          goto LABEL_15;
        }
        unint64_t v33 = v15;
LABEL_49:
        unint64_t v59 = v33;
        uint64_t v12 = *((unsigned int *)sub_1CD40EB18(a1 + 24, (uint64_t *)&v59) + 2);
        if (v12) {
          goto LABEL_50;
        }
        unint64_t v59 = 0;
        int v58 = *(_DWORD *)(v33 + 12);
        uint64_t v57 = *(void *)(v33 + 40);
        unint64_t v44 = sub_1CD76AC64(&v58, &v57, (int *)(v33 + 48), (char *)(v33 + 52), v33 + 56);
        unint64_t v59 = v44;
        uint64_t v45 = *(unsigned int *)(v33 + 36);
        if (v45)
        {
          unsigned __int32 v46 = *(uint64_t **)(v33 + 24);
          uint64_t v47 = 8 * v45;
          do
          {
            uint64_t v48 = *v46++;
            LODWORD(v57) = sub_1CCD6D534(a1, v48);
            unint64_t v44 = sub_1CC0AC638((uint64_t *)&v59, (int *)&v57);
            unint64_t v59 = v44;
            v47 -= 8;
          }
          while (v47);
        }
        uint64_t v49 = *(void *)(a1 + 48);
        uint64_t v50 = *(unsigned int *)(a1 + 64);
        if (v50)
        {
          LODWORD(v51) = (v50 - 1) & (37 * v44);
          uint64_t v52 = (uint64_t *)(v49 + 16 * v51);
          uint64_t v53 = *v52;
          if (*v52 == v44) {
            goto LABEL_77;
          }
          int v54 = 1;
          while (v53 != -1)
          {
            int v55 = v51 + v54++;
            uint64_t v51 = v55 & (v50 - 1);
            uint64_t v53 = *(void *)(v49 + 16 * v51);
            if (v53 == v44)
            {
              uint64_t v52 = (uint64_t *)(v49 + 16 * v51);
              goto LABEL_77;
            }
          }
        }
        uint64_t v52 = (uint64_t *)(v49 + 16 * v50);
LABEL_77:
        if ((uint64_t *)(v49 + 16 * v50) == v52)
        {
          uint64_t v12 = *(unsigned int *)(a1 + 248);
          *(_DWORD *)(a1 + 248) = v12 + 1;
          unint64_t v59 = v44;
          *((_DWORD *)sub_1CD76ADC8(a1 + 48, (uint64_t *)&v59) + 2) = v12;
          unint64_t v59 = v33;
          *((_DWORD *)sub_1CD40EB18(a1 + 24, (uint64_t *)&v59) + 2) = v12;
        }
        else
        {
          uint64_t v12 = *((unsigned int *)v52 + 2);
        }
LABEL_50:
        int v34 = *(_DWORD *)(a1 + 16);
        if (v34)
        {
          int v35 = v34 - 1;
          unsigned int v36 = ((v56 >> 4) ^ (v56 >> 9)) & v35;
          uint64_t v37 = (uint64_t *)(*(void *)a1 + 16 * v36);
          uint64_t v38 = *v37;
          if (v56 == *v37)
          {
LABEL_65:
            *((_DWORD *)v37 + 2) = v12;
            return v12;
          }
          __n128 v39 = 0;
          int v40 = 1;
          while (v38 != -4096)
          {
            if (v39) {
              BOOL v41 = 0;
            }
            else {
              BOOL v41 = v38 == -8192;
            }
            if (v41) {
              __n128 v39 = v37;
            }
            unsigned int v42 = v36 + v40++;
            unsigned int v36 = v42 & v35;
            uint64_t v37 = (uint64_t *)(*(void *)a1 + 16 * v36);
            uint64_t v38 = *v37;
            if (v56 == *v37) {
              goto LABEL_65;
            }
          }
          if (v39) {
            uint64_t v43 = v39;
          }
          else {
            uint64_t v43 = v37;
          }
        }
        else
        {
          uint64_t v43 = 0;
        }
        uint64_t v37 = sub_1CBFFD5B4(a1, (uint64_t)&v56, &v56, v43);
        *uint64_t v37 = v56;
        *((_DWORD *)v37 + 2) = 0;
        goto LABEL_65;
      }
      if ((v14 == 27 || v14 == 28) && (*(_WORD *)(a2 + 18) & 0x380) == 0)
      {
        unint64_t v33 = sub_1CCD6DA8C(a1, a2);
        *(unsigned char *)(v33 + 52) = *(unsigned char *)(a2 + 18) & 1;
        goto LABEL_49;
      }
    }
LABEL_15:
    int v16 = *(_DWORD *)(a1 + 248);
    if (v5)
    {
      int v17 = v5 - 1;
      unsigned int v18 = v17 & (v6 ^ (a2 >> 9));
      unsigned int v19 = (uint64_t *)(v4 + 16 * v18);
      uint64_t v20 = *v19;
      if (*v19 != a2)
      {
        uint64_t v21 = 0;
        int v22 = 1;
        while (v20 != -4096)
        {
          if (v21) {
            BOOL v23 = 0;
          }
          else {
            BOOL v23 = v20 == -8192;
          }
          if (v23) {
            uint64_t v21 = v19;
          }
          unsigned int v24 = v18 + v22++;
          unsigned int v18 = v24 & v17;
          unsigned int v19 = (uint64_t *)(v4 + 16 * v18);
          uint64_t v20 = *v19;
          if (*v19 == a2) {
            goto LABEL_41;
          }
        }
LABEL_37:
        if (v21) {
          unsigned __int32 v31 = v21;
        }
        else {
          unsigned __int32 v31 = v19;
        }
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    goto LABEL_43;
  }
  return *((unsigned int *)v8 + 2);
}

uint64_t sub_1CCD6D958(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 16);
  if ((v1 - 60) < 2) {
    return 1;
  }
  if (v1 == 33)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4 && (*(unsigned char *)(v4 + 17) & 0x10) != 0) {
      return 0;
    }
    __int32 v8 = 7;
    if (sub_1CC5CB59C(a1, &v8, 1uLL))
    {
      uint64_t v6 = *(void *)(a1 - 32);
      if (!v6 || *(unsigned char *)(v6 + 16) || *(void *)(v6 + 24) != *(void *)(a1 + 72) || *(_DWORD *)(v6 + 36) != 7) {
        return 1;
      }
    }
    if (!llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44)) {
      return 1;
    }
    int v1 = *(unsigned __int8 *)(a1 + 16);
  }
  if (v1 != 84) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 64);
  if (v5)
  {
    if ((*(unsigned char *)(v5 + 17) & 0x10) != 0) {
      return 0;
    }
  }
  __int32 v9 = 7;
  if (sub_1CC5CB59C(a1, &v9, 1uLL))
  {
    uint64_t v7 = *(void *)(a1 - 32);
    if (!v7 || *(unsigned char *)(v7 + 16) || *(void *)(v7 + 24) != *(void *)(a1 + 72) || *(_DWORD *)(v7 + 36) != 7) {
      return 1;
    }
  }
  return llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44) ^ 1;
}

unint64_t sub_1CCD6DA8C(size_t __sz, uint64_t a2)
{
  uint64_t v5 = (uint64_t *)(__sz + 72);
  uint64_t v4 = *(void *)(__sz + 72);
  *(void *)(__sz + 152) += 72;
  if (((v4 + 7) & 0xFFFFFFFFFFFFFFF8) - v4 + 72 > *(void *)(__sz + 80) - v4)
  {
    unsigned int v48 = *(_DWORD *)(__sz + 96) >> 7;
    if (v48 >= 0x1E) {
      LOBYTE(v48) = 30;
    }
    uint64_t v49 = 4096 << v48;
    unint64_t v6 = (unint64_t)operator new(4096 << v48, (std::align_val_t)8uLL);
    unsigned int v50 = *(_DWORD *)(__sz + 96);
    if (v50 >= *(_DWORD *)(__sz + 100)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(__sz + 88) + 8 * v50) = v6;
    ++*(_DWORD *)(__sz + 96);
    *(void *)(__sz + 80) = v6 + v49;
  }
  else
  {
    unint64_t v6 = (v4 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(__sz + 72) = v6 + 72;
  uint64_t v7 = *(void *)(a2 + 8);
  if (v7)
  {
    unsigned int v8 = 0;
    do
    {
      ++v8;
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7);
  }
  else
  {
    unsigned int v8 = 0;
  }
  *(void *)(v6 + 8) = 0xFFFFFFFD00000006;
  *(void *)(v6 + 16) = 0;
  *(void *)(v6 + 24) = 0;
  *(_DWORD *)(v6 + 32) = v8;
  *(_DWORD *)(v6 + 36) = 0;
  *(void *)(v6 + 40) = 0;
  *(void *)unint64_t v6 = &unk_1F263E188;
  *(_DWORD *)(v6 + 48) = -1;
  *(unsigned char *)(v6 + 52) = 0;
  unint64_t v9 = 64 - __clz(v8 - 1);
  if (v8) {
    unsigned __int8 v10 = v9;
  }
  else {
    unsigned __int8 v10 = 0;
  }
  *(void *)(v6 + 56) = 0;
  *(void *)(v6 + 64) = 0;
  *(void *)(v6 + 24) = sub_1CCD6DEF0((uint64_t *)(__sz + 168), v10, v5);
  int v11 = *(unsigned __int8 *)(a2 + 16);
  *(_DWORD *)(v6 + 12) = v11 - 28;
  *(void *)(v6 + 40) = *(void *)a2;
  if (v11 == 91)
  {
    uint64_t v12 = *(int **)(a2 + 64);
    uint64_t v13 = *(unsigned int *)(a2 + 72);
    uint64_t v14 = 4 * v13;
    uint64_t v15 = sub_1CB906F34(v5, 4 * v13, 2);
    if (v13)
    {
      int v16 = (_DWORD *)v15;
      do
      {
        int v17 = *v12++;
        *v16++ = v17;
        v14 -= 4;
      }
      while (v14);
    }
    *(void *)(v6 + 56) = v15;
    *(void *)(v6 + 64) = v13;
  }
  uint64_t v18 = *(void *)(a2 + 8);
  unsigned int v19 = *(_DWORD *)(v6 + 36);
  if (v18)
  {
    do
    {
      *(void *)(*(void *)(v6 + 24) + 8 * v19++) = *(void *)(v18 + 24);
      uint64_t v18 = *(void *)(v18 + 8);
    }
    while (v18);
    *(_DWORD *)(v6 + 36) = v19;
  }
  if (v19 >= 2) {
    qsort(*(void **)(v6 + 24), v19, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD76AA50);
  }
  if (sub_1CCD6D958(a2))
  {
    uint64_t v20 = *(void *)(a2 + 32);
    uint64_t v21 = *(void *)(a2 + 40) + 40;
    if (v20 != v21)
    {
      while (1)
      {
        if (v20) {
          uint64_t v22 = v20 - 24;
        }
        else {
          uint64_t v22 = 0;
        }
        if (*(unsigned __int8 *)(v22 + 16) - 29 < 0xB) {
          goto LABEL_60;
        }
        if (!sub_1CCD6D958(v22)) {
          goto LABEL_42;
        }
        int v23 = *(unsigned __int8 *)(v22 + 16);
        if (v23 == 60) {
          goto LABEL_42;
        }
        if (!v20 || v23 != 84) {
          goto LABEL_35;
        }
        uint64_t v24 = *(void *)(v22 + 64);
        if (!v24 || (*(unsigned char *)(v24 + 17) & 0x30) == 0)
        {
          int v25 = *(_DWORD *)(v22 + 20);
          if (v25 < 0)
          {
            uint64_t v37 = v22 - 32 * (v25 & 0x7FFFFFF);
            uint64_t v40 = *(void *)(v37 - 8);
            uint64_t v38 = v37 - 8;
            uint64_t v39 = v40;
            if (v40)
            {
              uint64_t v41 = -v39;
              do
              {
                unsigned int v42 = *(_DWORD *)(*(void *)(v38 + v41) + 8);
                BOOL v34 = v42 > 7;
                int v43 = (1 << v42) & 0x83;
                if (v34 || v43 == 0) {
                  goto LABEL_66;
                }
                v41 += 16;
              }
              while (v41);
            }
          }
          if ((llvm::CallBase::hasFnAttrOnCalledFunction(v22, 45) & 1) == 0
            && (llvm::CallBase::hasFnAttrOnCalledFunction(v22, 44) & 1) == 0)
          {
            break;
          }
        }
LABEL_42:
        uint64_t v20 = *(void *)(v20 + 8);
        if (v20 == v21) {
          goto LABEL_60;
        }
      }
      int v23 = *(unsigned __int8 *)(v22 + 16);
LABEL_35:
      if (!v20 || v23 != 33) {
        goto LABEL_66;
      }
      uint64_t v26 = *(void *)(v22 + 64);
      if (!v26 || (*(unsigned char *)(v26 + 17) & 0x30) == 0)
      {
        int v27 = *(_DWORD *)(v22 + 20);
        if (v27 < 0)
        {
          uint64_t v28 = v22 - 32 * (v27 & 0x7FFFFFF);
          uint64_t v31 = *(void *)(v28 - 8);
          uint64_t v29 = v28 - 8;
          uint64_t v30 = v31;
          if (v31)
          {
            uint64_t v32 = -v30;
            while (1)
            {
              unsigned int v33 = *(_DWORD *)(*(void *)(v29 + v32) + 8);
              BOOL v34 = v33 > 7;
              int v35 = (1 << v33) & 0x83;
              if (v34 || v35 == 0) {
                break;
              }
              v32 += 16;
              if (!v32) {
                goto LABEL_40;
              }
            }
LABEL_66:
            int v45 = sub_1CCD6D534(__sz, v22);
            goto LABEL_61;
          }
        }
LABEL_40:
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v22, 45) & 1) == 0
          && (llvm::CallBase::hasFnAttrOnCalledFunction(v22, 44) & 1) == 0)
        {
          goto LABEL_66;
        }
      }
      goto LABEL_42;
    }
LABEL_60:
    int v45 = 0;
LABEL_61:
    *(_DWORD *)(v6 + 48) = v45;
  }
  int v46 = *(unsigned __int8 *)(a2 + 16);
  if ((v46 - 83) >= 0xFFFFFFFE) {
    *(_DWORD *)(v6 + 12) = (*(_WORD *)(a2 + 18) & 0x3F | (v46 << 8)) - 7168;
  }
  return v6;
}