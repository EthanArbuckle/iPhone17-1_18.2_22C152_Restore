void llvm::initializeArgPromotionPass(llvm *this, llvm::PassRegistry *a2)
{
  llvm *v2;
  void *v3;
  void v4[2];

  v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDD750, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8A6CF8;
    v4[1] = &v2;
    v3 = v4;
    std::__call_once(&qword_1EBCDD750, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8A6CF8(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeCallGraphWrapperPassPass(a1, v2);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeTargetTransformInfoWrapperPassPass((uint64_t)a1);
  operator new();
}

uint64_t sub_1CC8A6DB0(uint64_t a1, int a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDD748;
  *(_DWORD *)(a1 + 24) = 3;
  *(_DWORD *)(a1 + 28) = a2;
  *(void *)a1 = &unk_1F2620718;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDD750, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC8A6CF8;
    v6[1] = &PassRegistry;
    v5 = v6;
    std::__call_once(&qword_1EBCDD750, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CC8A6E60(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  v14[0] = a1;
  v14[1] = a2;
  if (!a3) {
    return 1;
  }
  uint64_t v5 = a3;
  while (1)
  {
    uint64_t v6 = *(void *)(v5 + 24);
    unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
    if (v7 < 0x1C) {
      break;
    }
    unsigned int v8 = v7 - 33;
    BOOL v9 = v8 > 0x33;
    uint64_t v10 = (1 << v8) & 0x8000000000041;
    if (v9 || v10 == 0) {
      break;
    }
    uint64_t v12 = *(void *)(v6 - 32);
    if (!v12 || *(unsigned char *)(v12 + 16) || *(void *)(v12 + 24) != *(void *)(v6 + 72)) {
      uint64_t v12 = 0;
    }
    if (((*(uint64_t (**)(void, void, uint64_t, void *))(*(void *)*a4 + 1040))(*a4, *(void *)(*(void *)(v6 + 40) + 56), v12, v14) & 1) == 0)break; {
    uint64_t v5 = *(void *)(v5 + 8);
    }
    if (!v5) {
      return 1;
    }
  }
  return 0;
}

uint64_t sub_1CC8A6F48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)a1;
  uint64_t v6 = (a2 - *(void *)a1) >> 3;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (*(void *)a1 + 8 * v7 == a2)
  {
    sub_1CC472E24(a1, a3, a4);
    return *(void *)a1 + 8 * v6;
  }
  else
  {
    uint64_t v10 = a3;
    if (a3 == a4)
    {
      unint64_t v11 = 0;
    }
    else
    {
      unint64_t v11 = 0;
      uint64_t v12 = a3;
      do
      {
        ++v11;
        uint64_t v12 = *(void *)(v12 + 8);
      }
      while (v12 != a4);
    }
    if (v11 + v7 > *(unsigned int *)(a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v13 = (char *)(v5 + 8 * v7);
    __src = (unsigned char *)(v5 + 8 * v6);
    unint64_t v14 = (v13 - __src) >> 3;
    if (v14 >= v11)
    {
      sub_1CD4570C8(a1, &v13[-8 * v11], (char *)(v5 + 8 * v7));
      if (&v13[-8 * v11] != __src) {
        memmove(&__src[8 * v11], __src, &v13[-8 * v11] - __src);
      }
      if (v10 != a4)
      {
        v16 = __src;
        do
        {
          *v16++ = *(void *)(v10 + 24);
          uint64_t v10 = *(void *)(v10 + 8);
        }
        while (v10 != a4);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = v7 + v11;
      if (v6 != v7)
      {
        v15 = (void *)(v5 + 8 * v6);
        memcpy((void *)(v5 + 8 * (v7 + v11) - 8 * v14), __src, v13 - __src);
        do
        {
          *v15++ = *(void *)(v10 + 24);
          uint64_t v10 = *(void *)(v10 + 8);
          --v14;
        }
        while (v14);
      }
      for (; v10 != a4; uint64_t v10 = *(void *)(v10 + 8))
      {
        *(void *)v13 = *(void *)(v10 + 24);
        v13 += 8;
      }
    }
    return (uint64_t)__src;
  }
}

uint64_t sub_1CC8A70EC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v10 = *(unsigned __int8 *)(a2 + 16);
  if (v10 == 60 || v10 == 61)
  {
    __int16 v11 = *(_WORD *)(a2 + 18);
    if (v11 & 0x380) != 0 || (v11)
    {
LABEL_30:
      int v24 = 0;
      int v25 = 1;
      return v24 | (v25 << 8);
    }
  }
  else if (v10 - 63) < 3 || (*(_WORD *)(a2 + 18))
  {
    goto LABEL_30;
  }
  uint64_t v12 = *(llvm::GlobalValue **)(a2 - 32);
  uint64_t v13 = *(void *)a1;
  unsigned int v14 = *(_DWORD *)(*(void *)v12 + 8);
  if ((v14 & 0xFE) == 0x12) {
    unsigned int v14 = *(_DWORD *)(**(void **)(*(void *)v12 + 16) + 8);
  }
  if (v14 < 0x100) {
    goto LABEL_15;
  }
  unsigned int v15 = v14 >> 8;
  uint64_t v16 = *(unsigned int *)(v13 + 240);
  uint64_t v17 = *(void *)(v13 + 232);
  if (v16)
  {
    uint64_t v17 = *(void *)(v13 + 232);
    unint64_t v18 = *(unsigned int *)(v13 + 240);
    do
    {
      unint64_t v19 = v18 >> 1;
      uint64_t v20 = v17 + 16 * (v18 >> 1);
      unsigned int v21 = *(_DWORD *)(v20 + 8);
      uint64_t v22 = v20 + 16;
      v18 += ~(v18 >> 1);
      if (v21 < v15) {
        uint64_t v17 = v22;
      }
      else {
        unint64_t v18 = v19;
      }
    }
    while (v18);
  }
  if (v17 == *(void *)(v13 + 232) + 16 * v16 || *(_DWORD *)(v17 + 8) != v15) {
LABEL_15:
  }
    uint64_t v17 = *(void *)(v13 + 232);
  unsigned int v58 = *(_DWORD *)(v17 + 12);
  if (v58 > 0x40) {
    operator new[]();
  }
  unint64_t v57 = 0;
  v23 = llvm::Value::stripAndAccumulateConstantOffsets(v12, (llvm::DataLayout *)v13, (llvm::APInt *)&v57, 1, 0, 0, a7);
  int v24 = 0;
  int v25 = 0;
  if (v23 == **(llvm::GlobalValue ***)(a1 + 8))
  {
    unsigned int v26 = v58;
    unsigned int v27 = v58 - 1;
    if (v58 > 0x40)
    {
      if ((*(void *)(v57 + 8 * (v27 >> 6)) >> v27))
      {
        int v28 = llvm::APInt::countLeadingOnesSlowCase((llvm::APInt *)&v57);
      }
      else
      {
        int v52 = 0;
        int64_t v53 = ((unint64_t)v58 + 63) >> 6;
        do
        {
          if (v53-- < 1) {
            break;
          }
          unint64_t v55 = *(void *)(v57 + 8 * v53);
          v52 += __clz(v55);
        }
        while (!v55);
        unsigned int v56 = v58 | 0xFFFFFFC0;
        if ((v58 & 0x3F) == 0) {
          unsigned int v56 = 0;
        }
        int v28 = v52 + v56;
      }
    }
    else if ((v57 >> v27))
    {
      if (v58) {
        int v28 = __clz(~(v57 << -(char)v58));
      }
      else {
        int v28 = 0;
      }
    }
    else
    {
      int v28 = v58 + __clz(v57) - 64;
    }
    if (v26 - v28 - 63 < 0xFFFFFFC0) {
      goto LABEL_48;
    }
    uint64_t v29 = *(void *)a2;
    uint64_t v30 = sub_1CB83544C(*(void *)a1, *(void *)a2);
    if (v31 == 1) {
      goto LABEL_48;
    }
    uint64_t v32 = v30;
    if (**(unsigned char **)(a1 + 16))
    {
      if (*(unsigned char *)(v29 + 8) == 15) {
        goto LABEL_48;
      }
    }
    if (v58 > 0x40) {
      uint64_t v33 = *(void *)v57;
    }
    else {
      uint64_t v33 = (uint64_t)(v57 << -(uint64_t)v58) >> -(uint64_t)v58;
    }
    v35 = *(_DWORD **)(a1 + 24);
    unint64_t v36 = *(unsigned __int16 *)(a2 + 18);
    if (a3) {
      uint64_t v37 = a2;
    }
    else {
      uint64_t v37 = 0;
    }
    uint64_t v59 = 0;
    int v38 = sub_1CC8A75CC((uint64_t)v35, v33, &v59);
    uint64_t v39 = v59;
    if (v38)
    {
LABEL_45:
      unsigned int v44 = **(_DWORD **)(a1 + 32);
      if (v44 && v44 <= **(_DWORD **)(a1 + 24) >> 1 || *(void *)(v39 + 8) != v29) {
        goto LABEL_48;
      }
      if ((a3 & 1) == 0
        && (!v38
         || (__clz(1 << ((unint64_t)*(unsigned __int16 *)(a2 + 18) >> 1)) ^ 0x3F) > *(unsigned __int8 *)(v39 + 16)))
      {
        if (v33 < 0 || (unint64_t v46 = *(unsigned __int16 *)(a2 + 18), (v33 & ~(-1 << (v46 >> 1))) != 0))
        {
LABEL_48:
          int v24 = 0;
LABEL_49:
          int v25 = 1;
          goto LABEL_50;
        }
        uint64_t v47 = (v46 >> 1) & 0x3F;
        v48 = *(unint64_t **)(a1 + 40);
        unint64_t v49 = v33 + ((unint64_t)(v32 + 7) >> 3);
        if (*v48 > v49) {
          unint64_t v49 = *v48;
        }
        unint64_t *v48 = v49;
        v50 = *(unsigned char **)(a1 + 48);
        unsigned int v51 = __clz(1 << v47) ^ 0x3F;
        if (*v50 > v51) {
          LOBYTE(v51) = *v50;
        }
        unsigned char *v50 = v51;
      }
      int v24 = 1;
      unsigned int v45 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(a2 + 18) >> 1)) ^ 0x3F;
      if (*(unsigned __int8 *)(v39 + 16) > v45) {
        LOBYTE(v45) = *(unsigned char *)(v39 + 16);
      }
      *(unsigned char *)(v39 + 16) = v45;
      goto LABEL_49;
    }
    char v40 = __clz(1 << (v36 >> 1));
    int v41 = *v35 >> 1;
    if (*v35) {
      unsigned int v42 = 4;
    }
    else {
      unsigned int v42 = v35[4];
    }
    char v43 = v40 ^ 0x3F;
    if (4 * v41 + 4 >= 3 * v42)
    {
      v42 *= 2;
    }
    else if (v42 + ~v41 - v35[1] > v42 >> 3)
    {
LABEL_42:
      *v35 += 2;
      if (*(void *)v39 != 0x7FFFFFFFFFFFFFFFLL) {
        --v35[1];
      }
      *(void *)uint64_t v39 = v33;
      *(void *)(v39 + 8) = v29;
      *(unsigned char *)(v39 + 16) = v43;
      *(void *)(v39 + 24) = v37;
      goto LABEL_45;
    }
    sub_1CC8A7674((uint64_t)v35, v42);
    uint64_t v59 = 0;
    sub_1CC8A75CC((uint64_t)v35, v33, &v59);
    uint64_t v39 = v59;
    goto LABEL_42;
  }
LABEL_50:
  if (v58 >= 0x41 && v57) {
    MEMORY[0x1D25D9CB0](v57, 0x1000C8000313F17);
  }
  return v24 | (v25 << 8);
}

uint64_t sub_1CC8A75CC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  uint64_t v6 = (v4 - 1) & (37 * a2);
  uint64_t v7 = (void *)(v3 + 32 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
LABEL_13:
    uint64_t result = 1;
  }
  else
  {
    BOOL v9 = 0;
    int v10 = 1;
    while (v8 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v9) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v8 == 0x8000000000000000;
      }
      if (v11) {
        BOOL v9 = v7;
      }
      int v12 = v6 + v10++;
      uint64_t v6 = v12 & v5;
      uint64_t v7 = (void *)(v3 + 32 * v6);
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_13;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_16:
  *a3 = v7;
  return result;
}

uint64_t sub_1CC8A7674(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v13 = *(void *)(a1 + 8);
    uint64_t v14 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v15 = a2;
      *(void *)(a1 + 8) = operator new(32 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v15;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC8A780C(a1, v13, v13 + 32 * v14);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  uint64_t v7 = v16;
  do
  {
    uint64_t v8 = a1 + v6;
    uint64_t v9 = *(void *)(a1 + v6 + 8);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      *(void *)uint64_t v7 = v9;
      long long v10 = *(_OWORD *)(v8 + 16);
      *((void *)v7 + 3) = *(void *)(v8 + 32);
      *(_OWORD *)(v7 + 8) = v10;
      v7 += 32;
    }
    v6 += 32;
  }
  while (v6 != 128);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(32 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CC8A780C(a1, (uint64_t)v16, (uint64_t)v7);
}

uint64_t sub_1CC8A780C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[4 * v7];
  }
  do
  {
    *uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    v8 += 4;
  }
  while (v8 != v9);
LABEL_5:
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *(void *)v4;
      if ((unint64_t)(*(void *)v4 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
      {
        uint64_t v13 = 0;
        uint64_t result = sub_1CC8A75CC((uint64_t)v5, v10, &v13);
        uint64_t v11 = v13;
        void *v13 = *(void *)v4;
        long long v12 = *(_OWORD *)(v4 + 8);
        v11[3] = *(void *)(v4 + 24);
        *(_OWORD *)(v11 + 1) = v12;
        *v5 += 2;
      }
      v4 += 32;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_1CC8A78E0(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          uint64_t v12 = (uint64_t)(a2 - v10) >> 5;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return;
              case 2:
                uint64_t v41 = *(void *)(a2 - 32);
                uint64_t v42 = *(void *)v10;
                if (v41 < *(void *)v10)
                {
                  *(void *)unint64_t v10 = v41;
                  *(void *)(a2 - 32) = v42;
                  uint64_t v123 = *(void *)(v10 + 24);
                  long long v114 = *(_OWORD *)(v10 + 8);
                  long long v43 = *(_OWORD *)(a2 - 24);
                  *(void *)(v10 + 24) = *(void *)(a2 - 8);
                  *(_OWORD *)(v10 + 8) = v43;
                  *(void *)(a2 - 8) = v123;
                  *(_OWORD *)(a2 - 24) = v114;
                }
                break;
              case 3:
                sub_1CC8A8288((uint64_t *)v10, (uint64_t *)(v10 + 32), (uint64_t *)(a2 - 32));
                break;
              case 4:
                sub_1CC8A8660(v10, v10 + 32, v10 + 64, a2 - 32);
                break;
              case 5:
                sub_1CC8A8660(v10, v10 + 32, v10 + 64, v10 + 96);
                uint64_t v44 = *(void *)(a2 - 32);
                uint64_t v45 = *(void *)(v10 + 96);
                if (v44 < v45)
                {
                  *(void *)(v10 + 96) = v44;
                  *(void *)(a2 - 32) = v45;
                  long long v46 = *(_OWORD *)(v10 + 104);
                  uint64_t v47 = *(void *)(v10 + 120);
                  uint64_t v48 = *(void *)(a2 - 8);
                  *(_OWORD *)(v10 + 104) = *(_OWORD *)(a2 - 24);
                  *(void *)(v10 + 120) = v48;
                  *(void *)(a2 - 8) = v47;
                  *(_OWORD *)(a2 - 24) = v46;
                  uint64_t v49 = *(void *)(v10 + 96);
                  uint64_t v50 = *(void *)(v10 + 64);
                  if (v49 < v50)
                  {
                    *(void *)(v10 + 64) = v49;
                    uint64_t v51 = *(void *)(v10 + 88);
                    long long v52 = *(_OWORD *)(v10 + 72);
                    *(_OWORD *)(v10 + 72) = *(_OWORD *)(v10 + 104);
                    *(void *)(v10 + 88) = *(void *)(v10 + 120);
                    *(void *)(v10 + 96) = v50;
                    *(_OWORD *)(v10 + 104) = v52;
                    *(void *)(v10 + 120) = v51;
                    uint64_t v53 = *(void *)(v10 + 32);
                    if (v49 < v53)
                    {
                      *(void *)(v10 + 32) = v49;
                      uint64_t v54 = *(void *)(v10 + 56);
                      long long v55 = *(_OWORD *)(v10 + 40);
                      *(_OWORD *)(v10 + 40) = *(_OWORD *)(v10 + 72);
                      *(void *)(v10 + 56) = *(void *)(v10 + 88);
                      *(void *)(v10 + 64) = v53;
                      *(_OWORD *)(v10 + 72) = v55;
                      *(void *)(v10 + 88) = v54;
                      uint64_t v56 = *(void *)v10;
                      if (v49 < *(void *)v10)
                      {
                        *(void *)unint64_t v10 = v49;
                        long long v115 = *(_OWORD *)(v10 + 8);
                        uint64_t v124 = *(void *)(v10 + 24);
                        *(void *)(v10 + 24) = *(void *)(v10 + 56);
                        *(void *)(v10 + 32) = v56;
                        *(_OWORD *)(v10 + 8) = *(_OWORD *)(v10 + 40);
                        *(_OWORD *)(v10 + 40) = v115;
                        *(void *)(v10 + 56) = v124;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 767)
          {
            unint64_t v57 = v10 + 32;
            BOOL v59 = v10 == a2 || v57 == a2;
            if (a4)
            {
              if (!v59)
              {
                uint64_t v60 = 0;
                unint64_t v61 = v10;
                do
                {
                  unint64_t v62 = v57;
                  uint64_t v63 = *(void *)(v61 + 32);
                  if (v63 < *(void *)v61)
                  {
                    long long v116 = *(_OWORD *)(v61 + 40);
                    uint64_t v125 = *(void *)(v61 + 56);
                    uint64_t v64 = *(void *)v61;
                    uint64_t v65 = v60;
                    while (1)
                    {
                      uint64_t v66 = v10 + v65;
                      *(void *)(v66 + 32) = v64;
                      *(_OWORD *)(v66 + 40) = *(_OWORD *)(v10 + v65 + 8);
                      *(void *)(v66 + 56) = *(void *)(v10 + v65 + 24);
                      if (!v65) {
                        break;
                      }
                      uint64_t v64 = *(void *)(v66 - 32);
                      v65 -= 32;
                      if (v63 >= v64)
                      {
                        v67 = (void *)(v10 + v65 + 32);
                        goto LABEL_83;
                      }
                    }
                    v67 = (void *)v10;
LABEL_83:
                    void *v67 = v63;
                    *(void *)(v66 + 24) = v125;
                    *(_OWORD *)(v66 + 8) = v116;
                  }
                  unint64_t v57 = v62 + 32;
                  v60 += 32;
                  unint64_t v61 = v62;
                }
                while (v62 + 32 != a2);
              }
            }
            else if (!v59)
            {
              unint64_t v100 = v10 + 40;
              do
              {
                unint64_t v101 = v57;
                uint64_t v102 = *(void *)(a1 + 32);
                if (v102 < *(void *)a1)
                {
                  long long v119 = *(_OWORD *)(a1 + 40);
                  uint64_t v128 = *(void *)(a1 + 56);
                  uint64_t v103 = *(void *)a1;
                  unint64_t v104 = v100;
                  do
                  {
                    *(void *)(v104 - 8) = v103;
                    *(_OWORD *)unint64_t v104 = *(_OWORD *)(v104 - 32);
                    *(void *)(v104 + 16) = *(void *)(v104 - 16);
                    uint64_t v103 = *(void *)(v104 - 72);
                    v104 -= 32;
                  }
                  while (v102 < v103);
                  *(void *)(v104 - 8) = v102;
                  *(void *)(v104 + 16) = v128;
                  *(_OWORD *)unint64_t v104 = v119;
                }
                unint64_t v57 = v101 + 32;
                v100 += 32;
                a1 = v101;
              }
              while (v101 + 32 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v68 = (unint64_t)(v12 - 2) >> 1;
              int64_t v69 = v68;
              do
              {
                int64_t v70 = v69;
                if (v68 >= v69)
                {
                  uint64_t v71 = (2 * v69) | 1;
                  unint64_t v72 = v10 + 32 * v71;
                  if (2 * v70 + 2 < v12)
                  {
                    uint64_t v74 = *(void *)(v72 + 32);
                    BOOL v73 = *(void *)v72 < v74;
                    if (*(void *)v72 > v74) {
                      uint64_t v74 = *(void *)v72;
                    }
                    if (v73)
                    {
                      v72 += 32;
                      uint64_t v71 = 2 * v70 + 2;
                    }
                  }
                  else
                  {
                    uint64_t v74 = *(void *)v72;
                  }
                  unint64_t v75 = v10 + 32 * v70;
                  uint64_t v76 = *(void *)v75;
                  if (v74 >= *(void *)v75)
                  {
                    uint64_t v126 = *(void *)(v75 + 24);
                    long long v117 = *(_OWORD *)(v75 + 8);
                    do
                    {
                      unint64_t v77 = v75;
                      unint64_t v75 = v72;
                      *(void *)unint64_t v77 = v74;
                      long long v78 = *(_OWORD *)(v72 + 8);
                      *(void *)(v77 + 24) = *(void *)(v72 + 24);
                      *(_OWORD *)(v77 + 8) = v78;
                      if (v68 < v71) {
                        break;
                      }
                      uint64_t v79 = (2 * v71) | 1;
                      unint64_t v72 = v10 + 32 * v79;
                      uint64_t v71 = 2 * v71 + 2;
                      if (v71 < v12)
                      {
                        uint64_t v74 = *(void *)v72;
                        uint64_t v80 = *(void *)(v72 + 32);
                        BOOL v81 = *(void *)v72 < v80;
                        if (*(void *)v72 <= v80) {
                          uint64_t v74 = *(void *)(v72 + 32);
                        }
                        if (*(void *)v72 < v80) {
                          v72 += 32;
                        }
                        if (!v81) {
                          uint64_t v71 = v79;
                        }
                      }
                      else
                      {
                        uint64_t v74 = *(void *)v72;
                        uint64_t v71 = v79;
                      }
                    }
                    while (v74 >= v76);
                    *(void *)unint64_t v75 = v76;
                    *(void *)(v75 + 24) = v126;
                    *(_OWORD *)(v75 + 8) = v117;
                  }
                }
                int64_t v69 = v70 - 1;
              }
              while (v70);
              do
              {
                uint64_t v82 = 0;
                uint64_t v83 = *(void *)v10;
                long long v107 = *(_OWORD *)(v10 + 8);
                uint64_t v110 = *(void *)(v10 + 24);
                unint64_t v84 = v10;
                do
                {
                  uint64_t v85 = v84 + 32 * v82 + 32;
                  uint64_t v86 = (2 * v82) | 1;
                  uint64_t v82 = 2 * v82 + 2;
                  if (v82 < v12)
                  {
                    uint64_t v89 = *(void *)v85;
                    uint64_t v87 = *(void *)(v85 + 32);
                    BOOL v88 = *(void *)v85 < v87;
                    if (*(void *)v85 <= v87) {
                      uint64_t v89 = *(void *)(v85 + 32);
                    }
                    if (*(void *)v85 < v87) {
                      v85 += 32;
                    }
                    if (!v88) {
                      uint64_t v82 = v86;
                    }
                  }
                  else
                  {
                    uint64_t v89 = *(void *)v85;
                    uint64_t v82 = v86;
                  }
                  *(void *)unint64_t v84 = v89;
                  long long v90 = *(_OWORD *)(v85 + 8);
                  *(void *)(v84 + 24) = *(void *)(v85 + 24);
                  *(_OWORD *)(v84 + 8) = v90;
                  unint64_t v84 = v85;
                }
                while (v82 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                v91 = (long long *)(v85 + 8);
                if (v85 == a2 - 32)
                {
                  *(void *)uint64_t v85 = v83;
                  *(void *)(v85 + 24) = v110;
                  long long *v91 = v107;
                }
                else
                {
                  *(void *)uint64_t v85 = *(void *)(a2 - 32);
                  long long v92 = *(_OWORD *)(a2 - 24);
                  *(void *)(v85 + 24) = *(void *)(a2 - 8);
                  long long *v91 = v92;
                  *(void *)(a2 - 32) = v83;
                  *(void *)(a2 - 8) = v110;
                  *(_OWORD *)(a2 - 24) = v107;
                  uint64_t v93 = v85 - v10 + 32;
                  if (v93 >= 33)
                  {
                    unint64_t v94 = (((unint64_t)v93 >> 5) - 2) >> 1;
                    uint64_t v95 = v10 + 32 * v94;
                    uint64_t v96 = *(void *)v85;
                    if (*(void *)v95 < *(void *)v85)
                    {
                      uint64_t v127 = *(void *)(v85 + 24);
                      long long v118 = *v91;
                      uint64_t v97 = *(void *)v95;
                      do
                      {
                        uint64_t v98 = v85;
                        uint64_t v85 = v95;
                        *(void *)uint64_t v98 = v97;
                        long long v99 = *(_OWORD *)(v95 + 8);
                        *(void *)(v98 + 24) = *(void *)(v95 + 24);
                        *(_OWORD *)(v98 + 8) = v99;
                        if (!v94) {
                          break;
                        }
                        unint64_t v94 = (v94 - 1) >> 1;
                        uint64_t v95 = v10 + 32 * v94;
                        uint64_t v97 = *(void *)v95;
                      }
                      while (*(void *)v95 < v96);
                      *(void *)uint64_t v85 = v96;
                      *(void *)(v85 + 24) = v127;
                      *(_OWORD *)(v85 + 8) = v118;
                    }
                  }
                }
                a2 -= 32;
                BOOL v73 = v12-- <= 2;
              }
              while (!v73);
            }
            return;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = v10 + 32 * ((unint64_t)v12 >> 1);
          if ((unint64_t)v11 > 0x1000)
          {
            sub_1CC8A8288((uint64_t *)a1, (uint64_t *)(a1 + 32 * ((unint64_t)v12 >> 1)), (uint64_t *)(a2 - 32));
            sub_1CC8A8288((uint64_t *)(a1 + 32), (uint64_t *)(v14 - 32), (uint64_t *)(a2 - 64));
            sub_1CC8A8288((uint64_t *)(a1 + 64), (uint64_t *)(a1 + 32 + 32 * v13), (uint64_t *)(a2 - 96));
            sub_1CC8A8288((uint64_t *)(v14 - 32), (uint64_t *)v14, (uint64_t *)(a1 + 32 + 32 * v13));
            uint64_t v15 = *(void *)a1;
            *(void *)a1 = *(void *)v14;
            *(void *)unint64_t v14 = v15;
            uint64_t v120 = *(void *)(a1 + 24);
            long long v111 = *(_OWORD *)(a1 + 8);
            long long v16 = *(_OWORD *)(v14 + 8);
            *(void *)(a1 + 24) = *(void *)(v14 + 24);
            *(_OWORD *)(a1 + 8) = v16;
            *(void *)(v14 + 24) = v120;
            *(_OWORD *)(v14 + 8) = v111;
          }
          else
          {
            sub_1CC8A8288((uint64_t *)(a1 + 32 * ((unint64_t)v12 >> 1)), (uint64_t *)a1, (uint64_t *)(a2 - 32));
          }
          --a3;
          uint64_t v17 = *(void *)a1;
          if ((a4 & 1) != 0 || *(void *)(a1 - 32) < v17) {
            break;
          }
          uint64_t v109 = *(void *)(a1 + 24);
          long long v106 = *(_OWORD *)(a1 + 8);
          if (v17 >= *(void *)(a2 - 32))
          {
            unint64_t v32 = a1 + 32;
            do
            {
              unint64_t v10 = v32;
              if (v32 >= a2) {
                break;
              }
              v32 += 32;
            }
            while (v17 >= *(void *)v10);
          }
          else
          {
            unint64_t v10 = a1;
            do
            {
              uint64_t v31 = *(void *)(v10 + 32);
              v10 += 32;
            }
            while (v17 >= v31);
          }
          unint64_t v33 = a2;
          if (v10 < a2)
          {
            unint64_t v33 = a2;
            do
            {
              uint64_t v34 = *(void *)(v33 - 32);
              v33 -= 32;
            }
            while (v17 < v34);
          }
          if (v10 < v33)
          {
            uint64_t v35 = *(void *)v10;
            uint64_t v36 = *(void *)v33;
            do
            {
              *(void *)unint64_t v10 = v36;
              *(void *)unint64_t v33 = v35;
              uint64_t v122 = *(void *)(v10 + 24);
              long long v113 = *(_OWORD *)(v10 + 8);
              long long v37 = *(_OWORD *)(v33 + 8);
              *(void *)(v10 + 24) = *(void *)(v33 + 24);
              *(_OWORD *)(v10 + 8) = v37;
              *(void *)(v33 + 24) = v122;
              *(_OWORD *)(v33 + 8) = v113;
              do
              {
                uint64_t v38 = *(void *)(v10 + 32);
                v10 += 32;
                uint64_t v35 = v38;
              }
              while (v17 >= v38);
              do
              {
                uint64_t v39 = *(void *)(v33 - 32);
                v33 -= 32;
                uint64_t v36 = v39;
              }
              while (v17 < v39);
            }
            while (v10 < v33);
          }
          BOOL v4 = v10 - 32 >= a1;
          BOOL v5 = v10 - 32 == a1;
          if (v10 - 32 != a1)
          {
            *(void *)a1 = *(void *)(v10 - 32);
            long long v40 = *(_OWORD *)(v10 - 24);
            *(void *)(a1 + 24) = *(void *)(v10 - 8);
            *(_OWORD *)(a1 + 8) = v40;
          }
          a4 = 0;
          *(void *)(v10 - 32) = v17;
          *(void *)(v10 - 8) = v109;
          *(_OWORD *)(v10 - 24) = v106;
        }
        uint64_t v18 = 0;
        uint64_t v108 = *(void *)(a1 + 24);
        long long v105 = *(_OWORD *)(a1 + 8);
        do
        {
          uint64_t v19 = *(void *)(a1 + v18 + 32);
          v18 += 32;
        }
        while (v19 < v17);
        unint64_t v20 = a1 + v18;
        unsigned int v21 = (uint64_t *)a2;
        if (v18 == 32)
        {
          unsigned int v21 = (uint64_t *)a2;
          do
          {
            if (v20 >= (unint64_t)v21) {
              break;
            }
            uint64_t v23 = *(v21 - 4);
            v21 -= 4;
          }
          while (v23 >= v17);
        }
        else
        {
          do
          {
            uint64_t v22 = *(v21 - 4);
            v21 -= 4;
          }
          while (v22 >= v17);
        }
        if (v20 >= (unint64_t)v21)
        {
          unint64_t v10 = a1 + v18;
        }
        else
        {
          uint64_t v24 = *v21;
          unint64_t v10 = a1 + v18;
          int v25 = v21;
          do
          {
            *(void *)unint64_t v10 = v24;
            *int v25 = v19;
            uint64_t v121 = *(void *)(v10 + 24);
            long long v112 = *(_OWORD *)(v10 + 8);
            long long v26 = *(_OWORD *)(v25 + 1);
            *(void *)(v10 + 24) = v25[3];
            *(_OWORD *)(v10 + 8) = v26;
            v25[3] = v121;
            *(_OWORD *)(v25 + 1) = v112;
            do
            {
              uint64_t v27 = *(void *)(v10 + 32);
              v10 += 32;
              uint64_t v19 = v27;
            }
            while (v27 < v17);
            do
            {
              uint64_t v28 = *(v25 - 4);
              v25 -= 4;
              uint64_t v24 = v28;
            }
            while (v28 >= v17);
          }
          while (v10 < (unint64_t)v25);
        }
        if (v10 - 32 != a1)
        {
          *(void *)a1 = *(void *)(v10 - 32);
          long long v29 = *(_OWORD *)(v10 - 24);
          *(void *)(a1 + 24) = *(void *)(v10 - 8);
          *(_OWORD *)(a1 + 8) = v29;
        }
        *(void *)(v10 - 32) = v17;
        *(void *)(v10 - 8) = v108;
        *(_OWORD *)(v10 - 24) = v105;
        if (v20 >= (unint64_t)v21) {
          break;
        }
LABEL_32:
        sub_1CC8A78E0(a1, v10 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v30 = sub_1CC8A83AC(a1, v10 - 32);
      if (sub_1CC8A83AC(v10, a2)) {
        break;
      }
      if (!v30) {
        goto LABEL_32;
      }
    }
    a2 = v10 - 32;
    if (!v30) {
      continue;
    }
    break;
  }
}

uint64_t *sub_1CC8A8288(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  uint64_t v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      *a2 = v5;
      *a3 = v3;
      uint64_t v10 = a2[3];
      long long v11 = *(_OWORD *)(a2 + 1);
      uint64_t v12 = a3[3];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)(a3 + 1);
      a2[3] = v12;
      *(_OWORD *)(a3 + 1) = v11;
      a3[3] = v10;
      uint64_t v13 = *result;
      if (*a2 < *result)
      {
        *uint64_t result = *a2;
        *a2 = v13;
        uint64_t v14 = result[3];
        long long v15 = *(_OWORD *)(result + 1);
        uint64_t v16 = a2[3];
        *(_OWORD *)(result + 1) = *(_OWORD *)(a2 + 1);
        result[3] = v16;
        *(_OWORD *)(a2 + 1) = v15;
        a2[3] = v14;
      }
    }
  }
  else
  {
    int v6 = (long long *)(result + 1);
    if (v5 >= v3)
    {
      *uint64_t result = v3;
      *a2 = v4;
      uint64_t v17 = result[3];
      long long v18 = *v6;
      uint64_t v19 = a2[3];
      *int v6 = *(_OWORD *)(a2 + 1);
      result[3] = v19;
      *(_OWORD *)(a2 + 1) = v18;
      a2[3] = v17;
      uint64_t v20 = *a2;
      if (*a3 >= *a2) {
        return result;
      }
      *a2 = *a3;
      *a3 = v20;
      uint64_t v7 = a2[3];
      long long v8 = *(_OWORD *)(a2 + 1);
      uint64_t v21 = a3[3];
      *(_OWORD *)(a2 + 1) = *(_OWORD *)(a3 + 1);
      a2[3] = v21;
    }
    else
    {
      *uint64_t result = v5;
      *a3 = v4;
      uint64_t v7 = result[3];
      long long v8 = *v6;
      uint64_t v9 = a3[3];
      *int v6 = *(_OWORD *)(a3 + 1);
      result[3] = v9;
    }
    *(_OWORD *)(a3 + 1) = v8;
    a3[3] = v7;
  }
  return result;
}

BOOL sub_1CC8A83AC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(void *)(a2 - 32);
      uint64_t v7 = *(void *)a1;
      if (v6 < *(void *)a1)
      {
        *(void *)a1 = v6;
        *(void *)(a2 - 32) = v7;
        uint64_t v8 = *(void *)(a1 + 24);
        long long v9 = *(_OWORD *)(a1 + 8);
        uint64_t v10 = *(void *)(a2 - 8);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 - 24);
        *(void *)(a1 + 24) = v10;
        *(_OWORD *)(a2 - 24) = v9;
        *(void *)(a2 - 8) = v8;
      }
      return result;
    case 3:
      sub_1CC8A8288((uint64_t *)a1, (uint64_t *)(a1 + 32), (uint64_t *)(a2 - 32));
      return 1;
    case 4:
      sub_1CC8A8660(a1, a1 + 32, a1 + 64, a2 - 32);
      return 1;
    case 5:
      sub_1CC8A8660(a1, a1 + 32, a1 + 64, a1 + 96);
      uint64_t v20 = *(void *)(a2 - 32);
      uint64_t v21 = *(void *)(a1 + 96);
      if (v20 < v21)
      {
        *(void *)(a1 + 96) = v20;
        *(void *)(a2 - 32) = v21;
        uint64_t v22 = *(void *)(a1 + 120);
        long long v23 = *(_OWORD *)(a1 + 104);
        uint64_t v24 = *(void *)(a2 - 8);
        *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 - 24);
        *(void *)(a1 + 120) = v24;
        *(_OWORD *)(a2 - 24) = v23;
        *(void *)(a2 - 8) = v22;
        uint64_t v25 = *(void *)(a1 + 96);
        uint64_t v26 = *(void *)(a1 + 64);
        if (v25 < v26)
        {
          *(void *)(a1 + 64) = v25;
          uint64_t v27 = *(void *)(a1 + 88);
          long long v28 = *(_OWORD *)(a1 + 72);
          *(_OWORD *)(a1 + 72) = *(_OWORD *)(a1 + 104);
          *(void *)(a1 + 88) = *(void *)(a1 + 120);
          *(void *)(a1 + 96) = v26;
          *(_OWORD *)(a1 + 104) = v28;
          *(void *)(a1 + 120) = v27;
          uint64_t v29 = *(void *)(a1 + 32);
          if (v25 < v29)
          {
            *(void *)(a1 + 32) = v25;
            uint64_t v30 = *(void *)(a1 + 56);
            long long v31 = *(_OWORD *)(a1 + 40);
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 72);
            *(void *)(a1 + 56) = *(void *)(a1 + 88);
            *(void *)(a1 + 64) = v29;
            *(_OWORD *)(a1 + 72) = v31;
            *(void *)(a1 + 88) = v30;
            uint64_t v32 = *(void *)a1;
            if (v25 < *(void *)a1)
            {
              *(void *)a1 = v25;
              uint64_t v33 = *(void *)(a1 + 24);
              long long v34 = *(_OWORD *)(a1 + 8);
              *(_OWORD *)(a1 + 8) = *(_OWORD *)(a1 + 40);
              *(void *)(a1 + 24) = *(void *)(a1 + 56);
              *(void *)(a1 + 32) = v32;
              *(_OWORD *)(a1 + 40) = v34;
              *(void *)(a1 + 56) = v33;
            }
          }
        }
      }
      return 1;
    default:
      long long v11 = (uint64_t *)(a1 + 64);
      sub_1CC8A8288((uint64_t *)a1, (uint64_t *)(a1 + 32), (uint64_t *)(a1 + 64));
      uint64_t v12 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    uint64_t v15 = *(void *)v12;
    if (*(void *)v12 < *v11)
    {
      long long v35 = *(_OWORD *)(v12 + 8);
      uint64_t v36 = *(void *)(v12 + 24);
      uint64_t v16 = *v11;
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        *(void *)(v18 + 96) = v16;
        *(_OWORD *)(v18 + 104) = *(_OWORD *)(a1 + v17 + 72);
        *(void *)(v18 + 120) = *(void *)(a1 + v17 + 88);
        if (v17 == -64) {
          break;
        }
        uint64_t v16 = *(void *)(v18 + 32);
        v17 -= 32;
        if (v15 >= v16)
        {
          uint64_t v19 = (void *)(a1 + v17 + 96);
          goto LABEL_13;
        }
      }
      uint64_t v19 = (void *)a1;
LABEL_13:
      *uint64_t v19 = v15;
      *(_OWORD *)(v18 + 72) = v35;
      *(void *)(v18 + 88) = v36;
      if (++v14 == 8) {
        return v12 + 32 == a2;
      }
    }
    long long v11 = (uint64_t *)v12;
    v13 += 32;
    v12 += 32;
    if (v12 == a2) {
      return 1;
    }
  }
}

__n128 sub_1CC8A8660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1CC8A8288((uint64_t *)a1, (uint64_t *)a2, (uint64_t *)a3);
  uint64_t v9 = *(void *)a3;
  if (*(void *)a4 < *(void *)a3)
  {
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v9;
    uint64_t v10 = *(void *)(a3 + 24);
    __n128 result = *(__n128 *)(a3 + 8);
    uint64_t v11 = *(void *)(a4 + 24);
    *(_OWORD *)(a3 + 8) = *(_OWORD *)(a4 + 8);
    *(void *)(a3 + 24) = v11;
    *(__n128 *)(a4 + 8) = result;
    *(void *)(a4 + 24) = v10;
    uint64_t v12 = *(void *)a2;
    if (*(void *)a3 < *(void *)a2)
    {
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v12;
      uint64_t v13 = *(void *)(a2 + 24);
      __n128 result = *(__n128 *)(a2 + 8);
      uint64_t v14 = *(void *)(a3 + 24);
      *(_OWORD *)(a2 + 8) = *(_OWORD *)(a3 + 8);
      *(void *)(a2 + 24) = v14;
      *(__n128 *)(a3 + 8) = result;
      *(void *)(a3 + 24) = v13;
      uint64_t v15 = *(void *)a1;
      if (*(void *)a2 < *(void *)a1)
      {
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v15;
        uint64_t v16 = *(void *)(a1 + 24);
        __n128 result = *(__n128 *)(a1 + 8);
        uint64_t v17 = *(void *)(a2 + 24);
        *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
        *(void *)(a1 + 24) = v17;
        *(__n128 *)(a2 + 8) = result;
        *(void *)(a2 + 24) = v16;
      }
    }
  }
  return result;
}

uint64_t sub_1CC8A8750(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 152 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v10 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v8 = v6;
        }
        unsigned int v13 = v5 + v9++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 152 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v10 = 1;
        if (*v6 == a3) {
          goto LABEL_7;
        }
      }
      uint64_t v10 = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v10 = 0;
  }
LABEL_7:
  *a4 = v6;
  return v10;
}

void *sub_1CC8A87E8(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(152 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC8A88C0(a1, v4, v4 + 152 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 152 * v10;
    do
    {
      *__n128 result = -4096;
      result += 19;
      v11 -= 152;
    }
    while (v11);
  }
  return result;
}

void sub_1CC8A88C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 152 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 19;
      v8 -= 152;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CC8A8750(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        unsigned int v10 = v13;
        void *v13 = *(void *)v4;
        v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (char **)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CC8A89BC(v11, (char **)(v4 + 8));
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 152;
    }
    while (v4 != a3);
  }
}

char **sub_1CC8A89BC(char **a1, char **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = (char *)(a2 + 2);
    unsigned int v3 = *a2;
    if (*a2 == (char *)(a2 + 2))
    {
      unsigned int v6 = a2 + 1;
      uint64_t v5 = *((unsigned int *)a2 + 2);
      uint64_t v7 = *((unsigned int *)a1 + 2);
      if (v7 >= v5)
      {
        if (v5)
        {
          uint64_t v11 = &v3[32 * v5];
          BOOL v12 = *a1;
          do
          {
            *(void *)BOOL v12 = *(void *)v3;
            long long v13 = *(_OWORD *)(v3 + 8);
            *((void *)v12 + 3) = *((void *)v3 + 3);
            *(_OWORD *)(v12 + 8) = v13;
            v3 += 32;
            v12 += 32;
          }
          while (v3 != v11);
        }
      }
      else
      {
        if (*((_DWORD *)a1 + 3) < v5)
        {
          *((_DWORD *)a1 + 2) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v7)
        {
          uint64_t v14 = &v3[32 * v7];
          uint64_t v15 = *a1;
          do
          {
            *(void *)uint64_t v15 = *(void *)v3;
            long long v16 = *(_OWORD *)(v3 + 8);
            *((void *)v15 + 3) = *((void *)v3 + 3);
            *(_OWORD *)(v15 + 8) = v16;
            v3 += 32;
            v15 += 32;
          }
          while (v3 != v14);
        }
        else
        {
          uint64_t v7 = 0;
        }
        uint64_t v8 = *v6;
        if (v7 != v8) {
          memcpy(&(*a1)[32 * v7], &(*a2)[32 * v7], &(*a2)[32 * v8] - &(*a2)[32 * v7]);
        }
      }
      *((_DWORD *)a1 + 2) = v5;
    }
    else
    {
      unsigned int v10 = *a1;
      if (*a1 != (char *)(a1 + 2))
      {
        uint64_t v17 = a2;
        free(v10);
        a2 = v17;
        unsigned int v3 = *v17;
      }
      *a1 = v3;
      unsigned int v6 = a2 + 1;
      a1[1] = a2[1];
      *a2 = v4;
      *((_DWORD *)a2 + 3) = 0;
    }
    *unsigned int v6 = 0;
  }
  return a1;
}

uint64_t sub_1CC8A8B34(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  if (sub_1CC8A8DA0(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v4)) {
    return v4;
  }
  else {
    return *(void *)a1 + 152 * *(unsigned int *)(a1 + 16);
  }
}

char *sub_1CC8A8B90(uint64_t a1, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = *(unsigned char **)a1;
  uint64_t v6 = a2 - *(void *)a1;
  uint64_t v7 = (char *)(*(void *)a1 + (v6 & 0xFFFFFFFFFFFFFFF8));
  if (a5 < 1) {
    return v7;
  }
  BOOL v12 = *(uint64_t **)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  if (a5 > (v11 - (uint64_t)v12) >> 3)
  {
    unint64_t v13 = a5 + (((char *)v12 - v5) >> 3);
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = v11 - (void)v5;
    if (v14 >> 2 > v13) {
      unint64_t v13 = v14 >> 2;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 >> 61) {
        sub_1CB833614();
      }
      long long v16 = (char *)operator new(8 * v15);
    }
    else
    {
      long long v16 = 0;
    }
    uint64_t v25 = &v16[8 * (v6 >> 3)];
    memcpy(v25, __src, 8 * a5);
    __srcb = v25;
    if ((unint64_t)v6 >= 8)
    {
      uint64_t v26 = 8 * (v6 >> 3);
      do
      {
        *(void *)&v16[v26 - 8] = *(void *)&v5[v26 - 8];
        v26 -= 8;
      }
      while (v26);
      BOOL v12 = *(uint64_t **)(a1 + 8);
      uint64_t v25 = v16;
    }
    uint64_t v27 = &v16[8 * a5 + (v6 & 0xFFFFFFFFFFFFFFF8)];
    long long v28 = &v16[8 * v15];
    if (v12 != (uint64_t *)v7) {
      memmove(v27, v7, (char *)v12 - v7);
    }
    uint64_t v29 = *(unsigned char **)a1;
    *(void *)a1 = v25;
    *(void *)(a1 + 8) = &v27[(char *)v12 - v7];
    *(void *)(a1 + 16) = v28;
    if (v29) {
      operator delete(v29);
    }
    return __srcb;
  }
  uint64_t v17 = ((char *)v12 - v7) >> 3;
  if (v17 >= a5)
  {
    uint64_t v18 = &__src[8 * a5];
    uint64_t v20 = *(char **)(a1 + 8);
LABEL_18:
    uint64_t v21 = &v7[8 * a5];
    uint64_t v22 = (uint64_t *)&v20[-8 * a5];
    long long v23 = v20;
    if (v22 < v12)
    {
      long long v23 = v20;
      do
      {
        uint64_t v24 = *v22++;
        *(void *)long long v23 = v24;
        v23 += 8;
      }
      while (v22 < v12);
    }
    *(void *)(a1 + 8) = v23;
    if (v20 != v21) {
      memmove(&v20[-8 * ((v20 - v21) >> 3)], v7, v20 - v21);
    }
    if (v18 != __src) {
      memmove(v7, __src, v18 - __src);
    }
    return v7;
  }
  uint64_t v18 = &__src[8 * v17];
  int64_t v19 = a4 - v18;
  if (a4 != v18) {
    memmove(*(void **)(a1 + 8), &__src[8 * v17], a4 - v18);
  }
  uint64_t v20 = (char *)v12 + v19;
  *(void *)(a1 + 8) = (char *)v12 + v19;
  if ((char *)v12 - v7 >= 1) {
    goto LABEL_18;
  }
  return v7;
}

uint64_t sub_1CC8A8DA0(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 152 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v10 = 1;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 1;
      while (v7 != -4096)
      {
        if (v8) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v8 = v6;
        }
        unsigned int v13 = v5 + v9++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 152 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v10 = 1;
        if (*v6 == a3) {
          goto LABEL_7;
        }
      }
      uint64_t v10 = 0;
      if (v8) {
        uint64_t v6 = v8;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v10 = 0;
  }
LABEL_7:
  *a4 = v6;
  return v10;
}

uint64_t sub_1CC8A8E38(uint64_t a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = 0;
  uint64_t v8 = **a2;
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x200000000;
  *(void *)(a1 + 64) = v8;
  *(void *)(a1 + 72) = a1 + 120;
  *(void *)(a1 + 80) = a1 + 128;
  *(void *)(a1 + 88) = a3;
  *(_DWORD *)(a1 + 96) = 0;
  *(_WORD *)(a1 + 100) = 512;
  *(unsigned char *)(a1 + 102) = 7;
  *(void *)(a1 + 104) = a4;
  *(void *)(a1 + 112) = a5;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 120) = &unk_1F2616D08;
  *(void *)(a1 + 128) = &unk_1F2617008;
  *(void *)(a1 + 48) = a2[5];
  *(void *)(a1 + 56) = a2 + 3;
  int v9 = (unsigned __int8 *)a2[6];
  unint64_t v15 = v9;
  if (v9)
  {
    llvm::MetadataTracking::track((uint64_t)&v15, v9, 2);
    uint64_t v7 = (uint64_t)v15;
  }
  sub_1CB8461A4(a1, 0, v7);
  if (v15)
  {
    int v11 = *v15;
    if ((v11 - 4) > 0x1E)
    {
      if ((v11 - 3) >= 0xFFFFFFFE) {
        uint64_t v14 = v15;
      }
      else {
        uint64_t v14 = 0;
      }
      if ((v11 - 3) < 0xFFFFFFFE)
      {
        if (v11 == 3) {
          *((void *)v15 + 1) = 0;
        }
        return a1;
      }
      unint64_t v13 = (unint64_t)(v14 + 8);
    }
    else
    {
      if ((v15[1] & 0x7F) != 2 && !*((_DWORD *)v15 + 3)) {
        return a1;
      }
      uint64_t v12 = *((void *)v15 + 2);
      if ((v12 & 4) == 0) {
        return a1;
      }
      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
      if (!v13) {
        return a1;
      }
    }
    long long v16 = &v15;
    sub_1CC5FA668(v13 + 16, &v16);
  }
  return a1;
}

uint64_t sub_1CC8A8FA4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_16;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & (37 * a2);
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    int v9 = 0;
    int v10 = 1;
    uint64_t result = 1;
    while (v8 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == 0x8000000000000000;
      }
      if (v12) {
        int v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_16;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_16:
  *a3 = v7;
  return result;
}

void *sub_1CC8A9054(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CC8A911C((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CC8A8FA4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_5:
  *a1 += 2;
  if (*a3 != 0x7FFFFFFFFFFFFFFFLL) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CC8A911C(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC8A92AC(a1, v11, &v11[2 * v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  uint64_t v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((unint64_t)(v8 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      *uint64_t v7 = v8;
      v7[1] = *(void *)(a1 + v6 + 16);
      v7 += 2;
    }
    v6 += 16;
  }
  while (v6 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CC8A92AC(a1, v14, v7);
}

uint64_t sub_1CC8A92AC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v4 = a2;
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_5;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_5:
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *v4;
      if ((unint64_t)(*v4 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
      {
        uint64_t v13 = 0;
        uint64_t result = sub_1CC8A8FA4((uint64_t)v5, v10, &v13);
        int v11 = v13;
        uint64_t v12 = v4[1];
        uint64_t *v13 = *v4;
        v11[1] = v12;
        *v5 += 2;
      }
      v4 += 2;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_1CC8A9370()
{
}

void sub_1CC8A93B4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8A93EC(llvm::CallGraphSCCPass *a1, llvm *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  llvm::getAAResultsAnalysisUsage(a2, v4);

  llvm::CallGraphSCCPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC8A9468()
{
  return 0;
}

uint64_t sub_1CC8A9470(uint64_t a1, uint64_t a2)
{
  if (llvm::CallGraphSCCPass::skipSCC(a1, a2))
  {
    char v3 = 0;
  }
  else
  {
    unint64_t v4 = *(uint64_t **)(a1 + 8);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::CallGraphWrapperPass::ID)
      {
        v5 += 16;
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *(void *)(v5 + 8);
    }
    uint64_t v8 = *(llvm::CallGraph **)((*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::CallGraphWrapperPass::ID)+ 32);
    uint64_t v58 = a1;
    char v59 = 0;
    char v64 = 0;
    v65[0] = 0;
    char v66 = 0;
    uint64_t v10 = *(uint64_t **)(a2 + 16);
    uint64_t v9 = *(uint64_t **)(a2 + 24);
    if (v10 == v9)
    {
      char v3 = 0;
    }
    else
    {
      char v53 = 0;
      int64_t v11 = (char *)v9 - (char *)v10;
      do
      {
        char v12 = 0;
        uint64_t v13 = v11 & 0x7FFFFFFF0;
        do
        {
          uint64_t v14 = *v10;
          uint64_t v15 = *(void *)(*v10 + 8);
          if (v15)
          {
            unint64_t v57 = v8;
            long long v16 = *(uint64_t **)(a1 + 8);
            uint64_t v17 = *v16;
            uint64_t v18 = v16[1];
            while (1)
            {
              if (v17 == v18)
              {
                uint64_t v19 = 0;
                goto LABEL_18;
              }
              if (*(char **)v17 == llvm::TargetTransformInfoWrapperPass::ID) {
                break;
              }
              v17 += 16;
            }
            uint64_t v19 = *(void *)(v17 + 8);
LABEL_18:
            uint64_t v20 = (llvm::TargetTransformInfoWrapperPass *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v19 + 96))(v19, llvm::TargetTransformInfoWrapperPass::ID);
            TTI = llvm::TargetTransformInfoWrapperPass::getTTI(v20, (const Function *)v15);
            unsigned int v22 = *(_DWORD *)(a1 + 28);
            v55[0] = sub_1CC8A9A14;
            v55[1] = &v57;
            char v56 = 1;
            long long v23 = sub_1CC8A198C((llvm::Function *)v15, (uint64_t (*)(uint64_t, llvm::Function *))sub_1CC8A9878, (uint64_t)&v58, v22, (uint64_t)v55, TTI, v13 != 0);
            if (v23)
            {
              inserted = llvm::CallGraph::getOrInsertFunction(v8, (const llvm::Function *)v23);
              uint64_t v25 = inserted[2];
              inserted[2] = *(void *)(v14 + 16);
              *(void *)(v14 + 16) = v25;
              uint64_t v26 = inserted[3];
              inserted[3] = *(void *)(v14 + 24);
              *(void *)(v14 + 24) = v26;
              uint64_t v27 = inserted[4];
              inserted[4] = *(void *)(v14 + 32);
              *(void *)(v14 + 32) = v27;
              if (*(_DWORD *)(v14 + 40))
              {
                int v28 = *(_DWORD *)(v15 + 32);
                *(_DWORD *)(v15 + 32) = v28 & 0xFFFFFFF0;
                if ((v28 & 0x30) != 0 && (llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)v15) & 1) == 0) {
                  *(_DWORD *)(v15 + 32) |= 0x4000u;
                }
              }
              else
              {
                uint64_t v29 = (int32x2_t ****)llvm::CallGraph::removeFunctionFromModule((uint64_t)v8, v14);
                if (v29)
                {
                  uint64_t v30 = v29;
                  llvm::Function::~Function(v29);
                  int v32 = *(_DWORD *)(v31 + 20);
                  if ((v32 & 0x40000000) != 0)
                  {
                    uint64_t v45 = (char *)*(v30 - 1);
                    uint64_t v44 = v30 - 1;
                    long long v43 = v45;
                    uint64_t v46 = v32 & 0x7FFFFFF;
                    if (v46)
                    {
                      uint64_t v47 = 32 * v46;
                      do
                      {
                        uint64_t v48 = &v43[v47];
                        if (*(void *)&v43[v47 - 32])
                        {
                          **((void **)v48 - 2) = *((void *)v48 - 3);
                          uint64_t v49 = *((void *)v48 - 3);
                          if (v49) {
                            *(void *)(v49 + 16) = *((void *)v48 - 2);
                          }
                        }
                        v47 -= 32;
                      }
                      while (v47);
                    }
                    operator delete(v43);
                    long long v37 = (char *)v44;
                  }
                  else
                  {
                    uint64_t v33 = v32 & 0x7FFFFFF;
                    if (v33)
                    {
                      long long v34 = v30 - 2;
                      uint64_t v35 = -32 * v33;
                      do
                      {
                        if (*(v34 - 2))
                        {
                          **long long v34 = (int32x2_t **)*(v34 - 1);
                          uint64_t v36 = (uint64_t)*(v34 - 1);
                          if (v36) {
                            *(void *)(v36 + 16) = *v34;
                          }
                        }
                        v34 -= 4;
                        v35 += 32;
                      }
                      while (v35);
                    }
                    long long v37 = (char *)&v30[-4 * v33];
                    if (v32 < 0) {
                      long long v37 = &v37[-*((void *)v37 - 1) - 8];
                    }
                  }
                  operator delete(v37);
                }
              }
              unsigned int v38 = 0;
              uint64_t v39 = *(void *)(a2 + 16);
              do
              {
                unsigned int v40 = v38;
                uint64_t v41 = *(void *)(v39 + 8 * v38++);
              }
              while (v41 != v14);
              uint64_t v42 = (uint64_t **)(v39 + 8 * v40);
              if (inserted)
              {
                *uint64_t v42 = inserted;
              }
              else
              {
                uint64_t v50 = *(char **)(a2 + 24);
                int64_t v51 = v50 - (char *)(v42 + 1);
                if (v50 != (char *)(v42 + 1)) {
                  memmove(v42, v42 + 1, v50 - (char *)(v42 + 1));
                }
                *(void *)(a2 + 24) = (char *)v42 + v51;
              }
              sub_1CBFAE2F8(*(int32x2_t **)(a2 + 8), v14, (uint64_t)inserted);
              char v12 = 1;
            }
          }
          ++v10;
        }
        while (v10 != v9);
        if ((v12 & 1) == 0) {
          break;
        }
        uint64_t v10 = *(uint64_t **)(a2 + 16);
        uint64_t v9 = *(uint64_t **)(a2 + 24);
        char v53 = 1;
        int64_t v11 = (char *)v9 - (char *)v10;
      }
      while (v9 != v10);
      if (v66)
      {
        llvm::AAResults::~AAResults((llvm::AAResults *)v65);
        char v66 = 0;
      }
      char v3 = v53;
    }
    if (v64)
    {
      if (v63 != v62) {
        free(v63);
      }
      if (v61 != v60) {
        free(v61);
      }
    }
  }
  return v3 & 1;
}

void sub_1CC8A987C(llvm **a1, llvm::Pass *a2, llvm::Function *a3)
{
}

double sub_1CC8A9948(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 320))
  {
    unint64_t v4 = *(void **)(a1 + 168);
    if (v4 != *(void **)(a1 + 160))
    {
      uint64_t v7 = a2;
      uint64_t v9 = a1;
      free(v4);
      a2 = v7;
      a1 = v9;
    }
    uint64_t v5 = *(void **)(a1 + 72);
    if (v5 != *(void **)(a1 + 64))
    {
      uint64_t v6 = a2;
      uint64_t v8 = a1;
      free(v5);
      a2 = v6;
      a1 = v8;
    }
  }
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = v2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = a1 + 96;
  *(void *)(a1 + 72) = a1 + 96;
  *(void *)(a1 + 80) = 8;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 160) = a1 + 192;
  *(void *)(a1 + 168) = a1 + 192;
  *(void *)&double result = 16;
  *(void *)(a1 + 176) = 16;
  *(_DWORD *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 320) = 1;
  return result;
}

void sub_1CC8A9A14(llvm::CallGraph **a1, uint64_t a2, llvm::CallBase *a3)
{
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v7 = *a1;
  uint64_t v8 = *((void *)a3 - 4);
  if (!v8 || *(unsigned char *)(v8 + 16) || *(void *)(v8 + 24) != *((void *)a3 + 9)) {
    uint64_t v8 = 0;
  }
  unint64_t v9 = *(void *)(v6 + 56);
  inserted = llvm::CallGraph::getOrInsertFunction(v7, (const llvm::Function *)v8);
  int64_t v11 = (void *)*((void *)*a1 + 2);
  if (!v11) {
    goto LABEL_16;
  }
  uint64_t v12 = (uint64_t)*a1 + 16;
  do
  {
    unint64_t v13 = v11[4];
    BOOL v14 = v13 >= v9;
    if (v13 >= v9) {
      uint64_t v15 = v11;
    }
    else {
      uint64_t v15 = v11 + 1;
    }
    if (v14) {
      uint64_t v12 = (uint64_t)v11;
    }
    int64_t v11 = (void *)*v15;
  }
  while (*v15);
  if ((llvm::CallGraph *)v12 == (llvm::CallGraph *)((char *)*a1 + 16) || *(void *)(v12 + 32) > v9) {
LABEL_16:
  }
    uint64_t v12 = (uint64_t)*a1 + 16;
  long long v16 = *(llvm::CallGraphNode **)(v12 + 40);

  llvm::CallGraphNode::replaceCallEdge(v16, (uint64_t ****)a2, a3, (llvm::CallGraphNode *)inserted);
}

void sub_1CC8A9ADC()
{
}

uint64_t llvm::operator&(int a1, unsigned int a2)
{
  if (a1 == 1) {
    return 1;
  }
  else {
    return a2;
  }
}

int *llvm::operator&=(int *result, int a2)
{
  if (*result == 1) {
    a2 = 1;
  }
  *double result = a2;
  return result;
}

llvm::UndefValue *llvm::AA::getWithType(llvm::AA *this, llvm::Value *a2, llvm::Type *a3)
{
  char v3 = this;
  unint64_t v4 = *(llvm::Type **)this;
  if (v4 == a2) {
    return v3;
  }
  unsigned int v6 = *((unsigned __int8 *)v3 + 16);
  if (v6 == 12)
  {
    return (llvm::UndefValue *)llvm::PoisonValue::get(a2, a2);
  }
  if (v6 - 11 <= 1)
  {
    return llvm::UndefValue::get(a2, a2);
  }
  if (v6 > 0x14) {
    return 0;
  }
  if (v6 == 16)
  {
    uint64_t v8 = *((unsigned int *)v3 + 8);
    if (v8 < 0x41)
    {
      if (*((void *)v3 + 3)) {
        goto LABEL_16;
      }
LABEL_40:
      return llvm::Constant::getNullValue(a2, a2, a3);
    }
    int v16 = 0;
    int64_t v17 = (unint64_t)(v8 + 63) >> 6;
    do
    {
      if (v17-- < 1) {
        break;
      }
      unint64_t v19 = *(void *)(*((void *)v3 + 3) + 8 * v17);
      v16 += __clz(v19);
    }
    while (!v19);
    int v20 = v8 | 0xFFFFFFC0;
    if ((v8 & 0x3F) == 0) {
      int v20 = 0;
    }
    if (v16 + v20 == v8) {
      goto LABEL_40;
    }
  }
  else
  {
    if (v6 == 17)
    {
      if ((sub_1CB844168((uint64_t)v3, 0.0) & 1) == 0)
      {
        unint64_t v4 = *(llvm::Type **)v3;
        goto LABEL_16;
      }
      goto LABEL_40;
    }
    if (v6 - 18 < 3 || v6 == 13) {
      goto LABEL_40;
    }
  }
LABEL_16:
  if (*((unsigned char *)v4 + 8) == 15 && *((unsigned char *)a2 + 8) == 15)
  {
    return llvm::ConstantExpr::getPointerCast(v3, a2, a3);
  }
  else
  {
    unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(v4);
    if (v9 == 1) {
    unint64_t v11 = llvm::Type::getPrimitiveSizeInBits(a2);
    }
    if (v12 == 1)
    {
      unint64_t v21 = v11;
      unint64_t v11 = v21;
    }
    if (PrimitiveSizeInBits < v11) {
      return 0;
    }
    unsigned int v14 = *(unsigned __int8 *)(*(void *)v3 + 8);
    if (v14 == 13)
    {
      if (*((unsigned char *)a2 + 8) != 13) {
        return 0;
      }
      uint64_t v15 = 38;
    }
    else
    {
      if (v14 > 6 || *((unsigned __int8 *)a2 + 8) > 6u) {
        return 0;
      }
      uint64_t v15 = 45;
    }
    return llvm::ConstantFoldCastInstruction((llvm *)v15, v3, a2, v13);
  }
}

BOOL llvm::AA::isValidInScope(llvm::AA *this, const llvm::Value *a2, const llvm::Function *a3)
{
  unsigned int v3 = *((unsigned __int8 *)this + 16);
  if (v3 < 0x15) {
    return 1;
  }
  if (v3 >= 0x1C)
  {
    uint64_t v5 = (void *)(*((void *)this + 5) + 56);
    return *v5 == (void)a2;
  }
  if (v3 == 21)
  {
    uint64_t v5 = (void *)((char *)this + 24);
    return *v5 == (void)a2;
  }
  return 0;
}

BOOL llvm::AA::isValidAtPosition(llvm::AA *this, const llvm::Value *a2, const llvm::Instruction *a3, llvm::InformationCache *a4)
{
  BOOL result = 1;
  if (this != a2)
  {
    unsigned int v6 = *((unsigned __int8 *)this + 16);
    if (v6 >= 0x15)
    {
      uint64_t v8 = *((void *)a2 + 5);
      uint64_t v9 = *(void *)(v8 + 56);
      if (v6 == 21)
      {
        return *((void *)this + 3) == v9;
      }
      else
      {
        if (v6 < 0x1C) {
          return 0;
        }
        uint64_t v10 = *((void *)this + 5);
        if (*(void *)(v10 + 56) != v9) {
          return 0;
        }
        if (**((void **)a3 + 55)) {
          BOOL v11 = *(void *)(v9 + 40) == 0;
        }
        else {
          BOOL v11 = 1;
        }
        if (!v11) {
          llvm::AnalysisManager<llvm::Function>::getResultImpl();
        }
        if (v10 == v8
          && (uint64_t v12 = (llvm::AA *)((char *)this + 24), v13 = (llvm::AA *)(v8 + 40), (llvm::AA *)((char *)this + 24) != v13))
        {
          do
          {
            if (v12) {
              BOOL v14 = (llvm::AA *)((char *)v12 - 24) == a2;
            }
            else {
              BOOL v14 = 0;
            }
            BOOL result = v14;
            if (v14) {
              break;
            }
            uint64_t v12 = (llvm::AA *)*((void *)v12 + 1);
          }
          while (v12 != v13);
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

llvm::UndefValue *llvm::AA::combineOptionalValuesInAAValueLatice(unsigned __int8 *a1, uint64_t a2, llvm::Value *a3)
{
  int v4 = a1[8];
  int v5 = *(unsigned __int8 *)(a2 + 8);
  if (a1[8]) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if ((v4 == 0) != (v5 != 0) || !*(unsigned char *)(a2 + 8)) {
      return *(llvm::UndefValue **)a1;
    }
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2)
    {
      if (v4)
      {
        uint64_t v8 = *(unsigned __int8 **)a1;
        goto LABEL_13;
      }
      if (a3) {
        return llvm::AA::getWithType((llvm::AA *)v7, a3, a3);
      }
    }
    return 0;
  }
  uint64_t v8 = *(unsigned __int8 **)a1;
  uint64_t v7 = *(unsigned __int8 **)a2;
  if (*(void *)a1 == *(void *)a2) {
    return (llvm::UndefValue *)v8;
  }
  if (!v7) {
    return 0;
  }
LABEL_13:
  if (v8)
  {
    if (!a3) {
      a3 = *(llvm::Value **)v8;
    }
    if (v8[16] - 11 > 1)
    {
      if (v7[16] - 11 <= 1) {
        return (llvm::UndefValue *)v8;
      }
      if (v8 == (unsigned __int8 *)llvm::AA::getWithType((llvm::AA *)v7, a3, a3)) {
        return *(llvm::UndefValue **)a1;
      }
      return 0;
    }
    return llvm::AA::getWithType((llvm::AA *)v7, a3, a3);
  }
  return (llvm::UndefValue *)v8;
}

uint64_t llvm::AA::getPotentiallyLoadedValues(llvm::Attributor *a1, uint64_t a2, void *a3, void *a4, const llvm::AbstractAttribute *a5, BOOL *a6, char a7)
{
  v56[8] = *MEMORY[0x1E4F143B8];
  char v40 = a7;
  uint64_t v13 = *(void *)(a2 - 32);
  uint64_t v54 = v56;
  uint64_t v55 = 0x800000000;
  if (llvm::AA::getAssumedUnderlyingObjects(a1, v13, (uint64_t)&v54, a5, a2, a6, 2))
  {
    int64_t v51 = (uint64_t *)v53;
    uint64_t v52 = 0x600000000;
    uint64_t v48 = v50;
    uint64_t v49 = 0x600000000;
    uint64_t v45 = v47;
    uint64_t v46 = 0x600000000;
    if (**(void **)(*((void *)a1 + 11) + 440)) {
      BOOL v14 = *(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40) == 0;
    }
    else {
      BOOL v14 = 1;
    }
    long long v37 = a3;
    unsigned int v38 = a4;
    uint64_t v39 = a6;
    if (!v14) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    if (v55)
    {
      int v16 = v54;
      for (uint64_t i = 8 * v55; i; i -= 8)
      {
        uint64_t v18 = *v16;
        int v19 = *(unsigned __int8 *)(*v16 + 16);
        if ((v19 - 11) < 2) {
          goto LABEL_52;
        }
        if (v19 != 3 && v19 != 59)
        {
          if (v19 == 19)
          {
            unsigned int v20 = *(_DWORD *)(*(void *)v13 + 8);
            if ((v20 & 0xFE) == 0x12) {
              unsigned int v20 = *(_DWORD *)(**(void **)(*(void *)v13 + 16) + 8);
            }
            uint64_t v21 = *(void *)(*(void *)(a2 + 40) + 56);
            if (v21 && (uint64_t v22 = *(void *)(v21 + 112)) != 0)
            {
              uint64_t InitialValueForObj = 0;
              if ((*(unsigned char *)(v22 + 17) & 1) != 0 || v20 > 0xFF) {
                goto LABEL_58;
              }
            }
            else if (v20 > 0xFF)
            {
              goto LABEL_57;
            }
            unsigned int v27 = *(unsigned __int8 *)(v13 + 16);
            uint64_t v28 = v13;
            if (v27 != 21)
            {
              if (v27 < 0x1C)
              {
                uint64_t v28 = v13 | 2;
                if (*(unsigned char *)(v13 + 16)) {
                  goto LABEL_49;
                }
              }
              else
              {
                unsigned int v29 = v27 - 33;
                if (v29 > 0x33 || (uint64_t v28 = v13 | 1, ((1 << v29) & 0x8000000000041) == 0)) {
LABEL_49:
                }
                  uint64_t v28 = v13;
              }
            }
            uint64_t v41 = (char *)v28;
            uint64_t v42 = 0;
            unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a1, (const llvm::IRPosition *)&v41, a5, v39);
            uint64_t InitialValueForObj = 0;
            if (!v31 || v18 != AssumedSimplified) {
              goto LABEL_58;
            }
            goto LABEL_52;
          }
          if (byte_1EBD04470) {
            int v23 = 59;
          }
          else {
            int v23 = 63;
          }
          sub_1CC095244(*v16, v23, 0, &v41);
          if (!v44) {
            goto LABEL_57;
          }
          int v19 = *(unsigned __int8 *)(v18 + 16);
        }
        if (v19 == 3 && (*(_DWORD *)(v18 + 32) & 0xFu) - 7 > 1) {
          goto LABEL_57;
        }
        uint64_t InitialValueForObj = (uint64_t)llvm::AA::getInitialValueForObj(v18, *(llvm::UndefValue **)a2, 0);
        if (!InitialValueForObj) {
          goto LABEL_58;
        }
        if (v49 >= (unint64_t)HIDWORD(v49)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v48 + v49) = InitialValueForObj;
        LODWORD(v49) = v49 + 1;
        if (v46 >= (unint64_t)HIDWORD(v46)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v45 + v46) = 0;
        LODWORD(v46) = v46 + 1;
        uint64_t v41 = &v40;
        uint64_t v42 = &v48;
        long long v43 = &v45;
        unsigned int v24 = *(unsigned __int8 *)(v18 + 16);
        if (v24 != 21)
        {
          if (v24 < 0x1C)
          {
            if (!*(unsigned char *)(v18 + 16)) {
              v18 |= 2uLL;
            }
          }
          else
          {
            unsigned int v25 = v24 - 33;
            if (v25 <= 0x33 && ((1 << v25) & 0x8000000000041) != 0) {
              v18 |= 1uLL;
            }
          }
        }
        uint64_t v26 = sub_1CC8B5800((uint64_t)a1, v18, 0, (uint64_t)a5, 2, 0, 1);
        if (((*(uint64_t (**)(llvm::AbstractAttribute *, llvm::Attributor *, const llvm::AbstractAttribute *, uint64_t, uint64_t (*)(uint64_t, uint64_t, char), char **))(*(void *)v26 + 120))(v26, a1, a5, a2, sub_1CC8B5D38, &v41) & 1) == 0)
        {
LABEL_57:
          uint64_t InitialValueForObj = 0;
          goto LABEL_58;
        }
        if (v52 >= (unint64_t)HIDWORD(v52)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v51[v52] = (uint64_t)v26;
        LODWORD(v52) = v52 + 1;
LABEL_52:
        ++v16;
      }
    }
    if (v52)
    {
      uint64_t v33 = v51;
      uint64_t v34 = 8 * v52;
      do
      {
        uint64_t v35 = *v33;
        uint64_t v36 = (*(uint64_t (**)(uint64_t))(*(void *)*v33 + 48))(*v33);
        if (((*(uint64_t (**)(uint64_t))(*(void *)v36 + 24))(v36) & 1) == 0) {
          *uint64_t v39 = 1;
        }
        llvm::Attributor::recordDependence((uint64_t)a1, v35, (uint64_t)a5, 1);
        ++v33;
        v34 -= 8;
      }
      while (v34);
    }
    sub_1CD650920(v37, v48, (void *)v48 + v49);
    sub_1CD6509D4(v38, v45, (void *)v45 + v46);
    uint64_t InitialValueForObj = 1;
LABEL_58:
    if (v45 != v47) {
      free(v45);
    }
    if (v48 != v50) {
      free(v48);
    }
    if (v51 != (uint64_t *)v53) {
      free(v51);
    }
  }
  else
  {
    uint64_t InitialValueForObj = 0;
  }
  if (v54 != v56) {
    free(v54);
  }
  return InitialValueForObj;
}

uint64_t llvm::AA::getPotentialCopiesOfStoredValue(llvm::Attributor *a1, uint64_t a2, void *a3, const llvm::AbstractAttribute *a4, BOOL *a5, char a6)
{
  v59[8] = *MEMORY[0x1E4F143B8];
  uint64_t v42 = 1;
  int64x2_t v43 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v44 = v43;
  uint64_t v45 = v47;
  uint64_t v46 = 0x400000000;
  char v41 = a6;
  uint64_t v11 = *(void *)(a2 - 32);
  unint64_t v57 = v59;
  uint64_t v58 = 0x800000000;
  if (llvm::AA::getAssumedUnderlyingObjects(a1, v11, (uint64_t)&v57, a4, a2, a5, 2))
  {
    uint64_t v54 = (uint64_t *)v56;
    uint64_t v55 = 0x600000000;
    int64_t v51 = v53;
    uint64_t v52 = 0x600000000;
    uint64_t v48 = v50;
    uint64_t v49 = 0x600000000;
    if (**(void **)(*((void *)a1 + 11) + 440) && *(void *)(*(void *)(*(void *)(a2 + 40) + 56) + 40)) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    if (v58)
    {
      uint64_t v12 = v57;
      for (uint64_t i = 8 * v58; i; i -= 8)
      {
        uint64_t v14 = *v12;
        unsigned int v15 = *(unsigned __int8 *)(*v12 + 16);
        if (v15 - 11 < 2) {
          goto LABEL_48;
        }
        if (v15 != 3 && v15 != 59)
        {
          if (v15 == 19)
          {
            unsigned int v16 = *(_DWORD *)(*(void *)v11 + 8);
            if ((v16 & 0xFE) == 0x12) {
              unsigned int v16 = *(_DWORD *)(**(void **)(*(void *)v11 + 16) + 8);
            }
            uint64_t v17 = *(void *)(*(void *)(a2 + 40) + 56);
            if (v17 && (uint64_t v18 = *(void *)(v17 + 112)) != 0)
            {
              uint64_t v19 = 0;
              if ((*(unsigned char *)(v18 + 17) & 1) != 0 || v16 > 0xFF) {
                goto LABEL_55;
              }
            }
            else if (v16 > 0xFF)
            {
              goto LABEL_54;
            }
            unsigned int v27 = *(unsigned __int8 *)(v11 + 16);
            uint64_t v28 = v11;
            if (v27 == 21) {
              goto LABEL_40;
            }
            if (v27 < 0x1C)
            {
              uint64_t v28 = v11 | 2;
              if (!*(unsigned char *)(v11 + 16)) {
                goto LABEL_40;
              }
            }
            else
            {
              unsigned int v29 = v27 - 33;
              if (v29 <= 0x33)
              {
                uint64_t v28 = v11 | 1;
                if (((1 << v29) & 0x8000000000041) != 0)
                {
LABEL_40:
                  unsigned int v38 = (char *)v28;
                  uint64_t v39 = 0;
                  unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a1, (const llvm::IRPosition *)&v38, a4, a5);
                  uint64_t v19 = 0;
                  if (!v31 || v14 != AssumedSimplified) {
                    goto LABEL_55;
                  }
                  goto LABEL_48;
                }
              }
            }
            uint64_t v28 = v11;
            goto LABEL_40;
          }
          if (v15 < 0x1C) {
            goto LABEL_54;
          }
          unsigned int v20 = v15 - 33;
          BOOL v21 = v20 > 0x33;
          uint64_t v22 = (1 << v20) & 0x8000000000041;
          BOOL v23 = v21 || v22 == 0;
          if (v23 || !sub_1CBF5BCC4(*v12, 19)) {
            goto LABEL_54;
          }
          unsigned int v15 = *(unsigned __int8 *)(v14 + 16);
        }
        if (v15 == 3)
        {
          if ((*(_DWORD *)(v14 + 32) & 0xFu) - 7 > 1) {
            goto LABEL_54;
          }
          unsigned int v38 = &v41;
          uint64_t v39 = &v51;
          char v40 = &v48;
        }
        else
        {
          unsigned int v38 = &v41;
          uint64_t v39 = &v51;
          char v40 = &v48;
          if (v15 != 21)
          {
            if (v15 < 0x1C)
            {
              if (!v15) {
                v14 |= 2uLL;
              }
            }
            else
            {
              unsigned int v24 = v15 - 33;
              BOOL v21 = v24 > 0x33;
              uint64_t v25 = (1 << v24) & 0x8000000000041;
              if (!v21 && v25 != 0) {
                v14 |= 1uLL;
              }
            }
          }
        }
        int v32 = sub_1CC8B5800((uint64_t)a1, v14, 0, (uint64_t)a4, 2, 0, 1);
        if (((*(uint64_t (**)(llvm::AbstractAttribute *, llvm::Attributor *, const llvm::AbstractAttribute *, uint64_t, uint64_t (*)(uint64_t, uint64_t, char), char **))(*(void *)v32 + 120))(v32, a1, a4, a2, sub_1CC8B5FE8, &v38) & 1) == 0)
        {
LABEL_54:
          uint64_t v19 = 0;
          goto LABEL_55;
        }
        if (v55 >= (unint64_t)HIDWORD(v55)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v54[v55] = (uint64_t)v32;
        LODWORD(v55) = v55 + 1;
LABEL_48:
        ++v12;
      }
    }
    if (v55)
    {
      uint64_t v34 = v54;
      uint64_t v35 = 8 * v55;
      do
      {
        uint64_t v36 = *v34;
        uint64_t v37 = (*(uint64_t (**)(uint64_t))(*(void *)*v34 + 48))(*v34);
        if (((*(uint64_t (**)(uint64_t))(*(void *)v37 + 24))(v37) & 1) == 0) {
          *a5 = 1;
        }
        llvm::Attributor::recordDependence((uint64_t)a1, v36, (uint64_t)a4, 1);
        ++v34;
        v35 -= 8;
      }
      while (v35);
    }
    sub_1CD650920(a3, v51, (void *)v51 + v52);
    sub_1CD6509D4(&v42, v48, (void *)v48 + v49);
    uint64_t v19 = 1;
LABEL_55:
    if (v48 != v50) {
      free(v48);
    }
    if (v51 != v53) {
      free(v51);
    }
    if (v54 != (uint64_t *)v56) {
      free(v54);
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  if (v57 != v59) {
    free(v57);
  }
  if (v45 != v47) {
    free(v45);
  }
  if ((v42 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v43.i64[0], 8);
  }
  return v19;
}

uint64_t sub_1CC8AAAB0(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, unsigned char *a5)
{
  if ((sub_1CD647DEC(a2) & 0xFFFFFFFE) == 4)
  {
    uint64_t v10 = sub_1CC8B27E4(a1, *a2, a2[1], a3, 2, 0, 1);
    if ((~*((_DWORD *)v10 + 11) & 0xFC) == 0)
    {
      uint64_t v11 = (uint64_t)v10;
      BOOL v12 = *((unsigned __int8 *)v10 + 40) == 255;
      goto LABEL_9;
    }
  }
  uint64_t v13 = sub_1CC8B2D1C(a1, *a2, a2[1], a3, 2, 0, 1);
  uint64_t v11 = (uint64_t)v13;
  int v14 = *((unsigned __int8 *)v13 + 41);
  if ((~v14 & 3) == 0 || (uint64_t v15 = 0, (v14 & 2) != 0) && (a4 & 1) == 0)
  {
    char v16 = *((unsigned char *)v13 + 40);
    if (!a4)
    {
      *a5 = (v16 & 2) != 0;
      if ((v16 & 2) == 0)
      {
LABEL_17:
        uint64_t v15 = 1;
        llvm::Attributor::recordDependence(a1, v11, a3, 1);
        return v15;
      }
      return 1;
    }
    BOOL v12 = (v16 & 3) == 3;
LABEL_9:
    char v17 = v12;
    *a5 = v17;
    if (!v12) {
      goto LABEL_17;
    }
    return 1;
  }
  return v15;
}

uint64_t llvm::AA::isAssumedReadNone(llvm::AA *this, llvm::Attributor *a2, const llvm::IRPosition *a3, const llvm::AbstractAttribute *a4, BOOL *a5)
{
  return sub_1CC8AAAB0((uint64_t)this, (uint64_t *)a2, (uint64_t)a3, 1, a4);
}

uint64_t llvm::AA::isPotentiallyReachable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(*(void *)(a3 + 40) + 56);
  sub_1CB93141C((uint64_t)v12, a5);
  uint64_t v10 = sub_1CC8AACDC(a1, a2, a3, v9, a4, (uint64_t)v12);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  return v10;
}

{
  uint64_t v9;
  void v11[3];
  void *v12;
  uint64_t v13;

  uint64_t v13 = *MEMORY[0x1E4F143B8];
  sub_1CB93141C((uint64_t)v11, a5);
  uint64_t v9 = sub_1CC8AACDC(a1, a2, 0, a3, a4, (uint64_t)v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  return v9;
}

uint64_t sub_1CC8AACDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v45[6] = *MEMORY[0x1E4F143B8];
  unsigned int v38 = v42;
  uint64_t v39 = v42;
  uint64_t v40 = 8;
  int v41 = 0;
  int64x2_t v43 = v45;
  v45[0] = a2;
  uint64_t v44 = 0x600000001;
  uint64_t v11 = sub_1CC8B3300(a1, a4, 0, a5, 1, 0, 1);
  unsigned int v12 = v44;
  if (!v44)
  {
    uint64_t v31 = 0;
    goto LABEL_55;
  }
  uint64_t v13 = v11;
  while (1)
  {
    uint64_t v14 = *((void *)v43 + v12 - 1);
    LODWORD(v44) = v12 - 1;
    uint64_t v15 = v39;
    uint64_t v16 = HIDWORD(v40);
    if (v39 == v38)
    {
      if (HIDWORD(v40))
      {
        char v17 = 0;
        uint64_t v18 = 8 * HIDWORD(v40);
        uint64_t v19 = (uint64_t *)v39;
        while (*v19 != v14)
        {
          if (*v19 == -2) {
            char v17 = v19;
          }
          ++v19;
          v18 -= 8;
          if (!v18)
          {
            if (!v17) {
              goto LABEL_11;
            }
            *char v17 = v14;
            --v41;
            goto LABEL_35;
          }
        }
        goto LABEL_45;
      }
LABEL_11:
      unsigned int v20 = v40;
      if (HIDWORD(v40) < v40)
      {
        ++HIDWORD(v40);
        *(void *)&v39[8 * v16] = v14;
        goto LABEL_35;
      }
    }
    else
    {
      unsigned int v20 = v40;
    }
    if (3 * v20 <= 4 * (HIDWORD(v40) - v41))
    {
      if (v20 >= 0x40) {
        v20 *= 2;
      }
      else {
        unsigned int v20 = 128;
      }
LABEL_52:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v38, v20);
      unsigned int v20 = v40;
      uint64_t v15 = v39;
      goto LABEL_16;
    }
    if (v20 - HIDWORD(v40) < v20 >> 3) {
      goto LABEL_52;
    }
LABEL_16:
    unsigned int v21 = v20 - 1;
    unsigned int v22 = (v20 - 1) & ((v14 >> 4) ^ (v14 >> 9));
    BOOL v23 = &v15[8 * v22];
    uint64_t v24 = *(void *)v23;
    if (*(void *)v23 != -1)
    {
      uint64_t v25 = 0;
      int v26 = 1;
      while (v24 != v14)
      {
        if (v25) {
          BOOL v27 = 0;
        }
        else {
          BOOL v27 = v24 == -2;
        }
        if (v27) {
          uint64_t v25 = (uint64_t *)v23;
        }
        unsigned int v28 = v22 + v26++;
        unsigned int v22 = v28 & v21;
        BOOL v23 = &v15[8 * (v28 & v21)];
        uint64_t v24 = *(void *)v23;
        if (*(void *)v23 == -1) {
          goto LABEL_28;
        }
      }
      goto LABEL_45;
    }
    uint64_t v25 = 0;
LABEL_28:
    if (v25) {
      unsigned int v29 = v25;
    }
    else {
      unsigned int v29 = (uint64_t *)v23;
    }
    if (*v29 == v14) {
      goto LABEL_45;
    }
    if (*v29 == -2) {
      --v41;
    }
    else {
      ++HIDWORD(v40);
    }
    *unsigned int v29 = v14;
LABEL_35:
    uint64_t v30 = *(void *)(*(void *)(v14 + 40) + 56);
    if (v30 == a4) {
      break;
    }
LABEL_36:
    if (!*(void *)(a6 + 24)) {
      goto LABEL_54;
    }
    uint64_t v31 = 1;
    int v32 = sub_1CC8B3D70(a1, v30, 0, a5, 1, 0, 1);
    if (((*(uint64_t (**)(llvm::AbstractAttribute *, uint64_t, uint64_t, uint64_t, void))(*(void *)v32
                                                                                                  + 128))(v32, a1, v14, a4, 0) & 1) != 0)goto LABEL_55;
    uint64_t v33 = *(void *)(a6 + 24);
    if (!v33) {
      sub_1CB920400();
    }
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v33 + 48))(v33, v30))
    {
      uint64_t v37 = &v43;
      if (!llvm::Attributor::checkForAllCallSites(a1, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8B42A8, (uint64_t)&v37, v30, 1, a5, &v36))goto LABEL_55; {
    }
      }
LABEL_45:
    unsigned int v12 = v44;
    if (!v44)
    {
      uint64_t v31 = 0;
      goto LABEL_55;
    }
  }
  if (a3)
  {
    uint64_t v31 = 1;
    uint64_t v34 = sub_1CC8B3838(a1, a4, 0, a5, 1, 0, 1);
    if (sub_1CC8B3254((uint64_t)v34, a1, v14, a3)) {
      goto LABEL_55;
    }
    if (*((unsigned char *)v13 + 41)) {
      goto LABEL_45;
    }
    goto LABEL_36;
  }
LABEL_54:
  uint64_t v31 = 1;
LABEL_55:
  if (v43 != v45) {
    free(v43);
  }
  if (v39 != v38) {
    free(v39);
  }
  return v31;
}

uint64_t llvm::AbstractAttribute::update(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4)) {
    return 1;
  }
  BOOL v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 104);

  return v6(a1, a2);
}

llvm::SubsumingPositionIterator *llvm::SubsumingPositionIterator::SubsumingPositionIterator(llvm::SubsumingPositionIterator *this, const llvm::IRPosition *a2)
{
  *(void *)this = (char *)this + 16;
  *((void *)this + 1) = 0x400000000;
  *((_OWORD *)this + 1) = *(_OWORD *)a2;
  *((_DWORD *)this + 2) = 1;
  unint64_t v4 = *(void *)a2 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*(_DWORD *)a2 & 3) == 0) {
    unint64_t v4 = *(void *)(v4 + 24);
  }
  unsigned int v5 = *(unsigned __int8 *)(v4 + 16);
  if (v5 < 0x1C
    || ((unsigned int v6 = v5 - 33, v7 = v6 > 0x33, v8 = (1 << v6) & 0x8000000000041, !v7) ? (v9 = v8 == 0) : (v9 = 1), v9))
  {
    unint64_t v4 = 0;
  }
  switch(sub_1CD647DEC(a2))
  {
    case 2u:
    case 6u:
      uint64_t v15 = sub_1CD6482A0(a2);
      goto LABEL_23;
    case 3u:
      int v10 = *(_DWORD *)(v4 + 20);
      if (v10 < 0 && (*(void *)(v4 - 32 * (v10 & 0x7FFFFFF) - 8) & 0xFFFFFFFF0) != 0)
      {
        if (*(unsigned char *)(v4 + 16) != 84) {
          goto LABEL_15;
        }
        uint64_t v11 = *(void *)(v4 - 32);
        if (!v11
          || *(unsigned char *)(v11 + 16)
          || *(void *)(v11 + 24) != *(void *)(v4 + 72)
          || (*(unsigned char *)(v11 + 33) & 0x20) == 0
          || *(_DWORD *)(v11 + 36) != 7)
        {
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v11 = *(void *)(v4 - 32);
        if (!v11 || *(unsigned char *)(v11 + 16)) {
          goto LABEL_15;
        }
      }
      if (*(void *)(v11 + 24) == *(void *)(v4 + 72))
      {
        uint64_t v17 = v11 | 1;
        uint64_t v19 = *((unsigned int *)this + 2);
        unsigned int v18 = *((_DWORD *)this + 3);
        if (v19 >= v18)
        {
          sub_1CD4C2394((uint64_t)this, v17, 0);
          unsigned int v21 = *((_DWORD *)this + 2);
          unsigned int v18 = *((_DWORD *)this + 3);
        }
        else
        {
          unsigned int v20 = (uint64_t *)(*(void *)this + 16 * v19);
          *unsigned int v20 = v17;
          v20[1] = 0;
          unsigned int v21 = v19 + 1;
          *((_DWORD *)this + 2) = v21;
        }
        if (v21 >= v18)
        {
          sub_1CD4C2394((uint64_t)this, v11, 0);
        }
        else
        {
          unsigned int v22 = (uint64_t *)(*(void *)this + 16 * v21);
          *unsigned int v22 = v11;
          v22[1] = 0;
          *((_DWORD *)this + 2) = v21 + 1;
        }
        uint64_t v23 = sub_1CB923B44((llvm::Function *)v11);
        if (v23 != v24)
        {
          uint64_t v25 = v23;
          uint64_t v26 = v23;
          do
          {
            uint64_t v27 = *(void *)(*(void *)(v26 + 24) + 112);
            if (v27)
            {
              uint64_t v28 = *(unsigned int *)(v26 + 32);
              if ((v28 + 2) < *(_DWORD *)(v27 + 8))
              {
                uint64_t v29 = *(void *)(v27 + 8 * (v28 + 2) + 40);
                if (v29)
                {
                  if ((*(unsigned char *)(v29 + 17) & 0x40) != 0)
                  {
                    int v30 = *(_DWORD *)(v4 + 20);
                    if ((v30 & 0x40000000) != 0) {
                      unint64_t v31 = *(void *)(v4 - 8);
                    }
                    else {
                      unint64_t v31 = v4 - 32 * (v30 & 0x7FFFFFF);
                    }
                    uint64_t v32 = (v31 + 32 * v28) | 3;
                    uint64_t v33 = *((unsigned int *)this + 2);
                    if (v33 >= *((_DWORD *)this + 3))
                    {
                      uint64_t v59 = v25;
                      uint64_t v62 = v24;
                      uint64_t v56 = v26;
                      sub_1CD4C2394((uint64_t)this, v32, 0);
                      uint64_t v26 = v56;
                      uint64_t v25 = v59;
                      uint64_t v24 = v62;
                      uint64_t v28 = *(unsigned int *)(v56 + 32);
                    }
                    else
                    {
                      uint64_t v34 = (uint64_t *)(*(void *)this + 16 * v33);
                      *uint64_t v34 = v32;
                      v34[1] = 0;
                      *((_DWORD *)this + 2) = v33 + 1;
                    }
                    uint64_t v35 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v28);
                    unsigned int v36 = *(unsigned __int8 *)(v35 + 16);
                    if (v36 != 21)
                    {
                      if (v36 < 0x1C)
                      {
                        if (!*(unsigned char *)(v35 + 16)) {
                          v35 |= 2uLL;
                        }
                      }
                      else
                      {
                        unsigned int v37 = v36 - 33;
                        BOOL v7 = v37 > 0x33;
                        uint64_t v38 = (1 << v37) & 0x8000000000041;
                        if (!v7 && v38 != 0) {
                          v35 |= 1uLL;
                        }
                      }
                    }
                    unint64_t v41 = *((unsigned int *)this + 2);
                    unint64_t v40 = *((unsigned int *)this + 3);
                    if (v41 >= v40)
                    {
                      uint64_t v60 = v25;
                      uint64_t v63 = v24;
                      uint64_t v57 = v26;
                      sub_1CD4C2394((uint64_t)this, v35, 0);
                      uint64_t v26 = v57;
                      uint64_t v25 = v60;
                      uint64_t v24 = v63;
                      unint64_t v43 = *((unsigned int *)this + 2);
                      unint64_t v40 = *((unsigned int *)this + 3);
                    }
                    else
                    {
                      uint64_t v42 = (uint64_t *)(*(void *)this + 16 * v41);
                      *uint64_t v42 = v35;
                      v42[1] = 0;
                      unint64_t v43 = v41 + 1;
                      *((_DWORD *)this + 2) = v41 + 1;
                    }
                    if (v43 >= v40)
                    {
                      uint64_t v61 = v25;
                      uint64_t v64 = v24;
                      uint64_t v58 = v26;
                      sub_1CD4C2394((uint64_t)this, v25, 0);
                      uint64_t v26 = v58;
                      uint64_t v25 = v61;
                      uint64_t v24 = v64;
                    }
                    else
                    {
                      uint64_t v44 = (uint64_t *)(*(void *)this + 16 * v43);
                      *uint64_t v44 = v25;
                      v44[1] = 0;
                      *((_DWORD *)this + 2) = v43 + 1;
                    }
                  }
                }
              }
            }
            v26 += 40;
            v25 += 40;
          }
          while (v26 != v24);
        }
      }
LABEL_15:
      uint64_t v12 = *((unsigned int *)this + 2);
      if (v12 < *((_DWORD *)this + 3))
      {
        uint64_t v13 = (void *)(*(void *)this + 16 * v12);
        void *v13 = v4;
        goto LABEL_25;
      }
      uint64_t v55 = this;
      uint64_t v15 = v4;
      goto LABEL_78;
    case 5u:
      int v14 = *(_DWORD *)(v4 + 20);
      if (v14 < 0 && (*(void *)(v4 - 32 * (v14 & 0x7FFFFFF) - 8) & 0xFFFFFFFF0) != 0)
      {
        if (*(unsigned char *)(v4 + 16) != 84) {
          return this;
        }
        uint64_t v15 = *(void *)(v4 - 32);
        if (!v15
          || *(unsigned char *)(v15 + 16)
          || *(void *)(v15 + 24) != *(void *)(v4 + 72)
          || (*(unsigned char *)(v15 + 33) & 0x20) == 0
          || *(_DWORD *)(v15 + 36) != 7)
        {
          return this;
        }
      }
      else
      {
        uint64_t v15 = *(void *)(v4 - 32);
        if (!v15 || *(unsigned char *)(v15 + 16)) {
          return this;
        }
      }
      if (*(void *)(v15 + 24) != *(void *)(v4 + 72)) {
        return this;
      }
      goto LABEL_23;
    case 7u:
      int v45 = *(_DWORD *)(v4 + 20);
      if (v45 < 0 && (*(void *)(v4 - 32 * (v45 & 0x7FFFFFF) - 8) & 0xFFFFFFFF0) != 0)
      {
        if (*(unsigned char *)(v4 + 16) != 84) {
          goto LABEL_69;
        }
        uint64_t v46 = *(void *)(v4 - 32);
        if (!v46
          || *(unsigned char *)(v46 + 16)
          || *(void *)(v46 + 24) != *(void *)(v4 + 72)
          || (*(unsigned char *)(v46 + 33) & 0x20) == 0
          || *(_DWORD *)(v46 + 36) != 7)
        {
          goto LABEL_69;
        }
      }
      else
      {
        uint64_t v46 = *(void *)(v4 - 32);
        if (!v46 || *(unsigned char *)(v46 + 16)) {
          goto LABEL_69;
        }
      }
      if (*(void *)(v46 + 24) == *(void *)(v4 + 72))
      {
        unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument(a2);
        uint64_t v48 = *((unsigned int *)this + 2);
        unsigned int v49 = *((_DWORD *)this + 3);
        if (AssociatedArgument)
        {
          if (v48 >= v49)
          {
            sub_1CD4C2394((uint64_t)this, AssociatedArgument, 0);
            LODWORD(v48) = *((_DWORD *)this + 2);
            unsigned int v49 = *((_DWORD *)this + 3);
          }
          else
          {
            uint64_t v50 = (unint64_t *)(*(void *)this + 16 * v48);
            unint64_t *v50 = AssociatedArgument;
            v50[1] = 0;
            LODWORD(v48) = v48 + 1;
            *((_DWORD *)this + 2) = v48;
          }
        }
        if (v48 >= v49)
        {
          sub_1CD4C2394((uint64_t)this, v46, 0);
        }
        else
        {
          int64_t v51 = (uint64_t *)(*(void *)this + 16 * v48);
          *int64_t v51 = v46;
          v51[1] = 0;
          *((_DWORD *)this + 2) = v48 + 1;
        }
      }
LABEL_69:
      unint64_t v52 = sub_1CD6482F0(a2);
      uint64_t v15 = v52;
      unsigned int v53 = *(unsigned __int8 *)(v52 + 16);
      if (v53 != 21)
      {
        if (v53 < 0x1C)
        {
          if (!*(unsigned char *)(v52 + 16)) {
            uint64_t v15 = v52 | 2;
          }
        }
        else
        {
          unsigned int v54 = v53 - 33;
          if (v54 <= 0x33 && ((1 << v54) & 0x8000000000041) != 0) {
            uint64_t v15 = v52 | 1;
          }
        }
      }
LABEL_23:
      uint64_t v12 = *((unsigned int *)this + 2);
      if (v12 >= *((_DWORD *)this + 3))
      {
        uint64_t v55 = this;
LABEL_78:
        sub_1CD4C2394((uint64_t)v55, v15, 0);
      }
      else
      {
        uint64_t v13 = (void *)(*(void *)this + 16 * v12);
        void *v13 = v15;
LABEL_25:
        v13[1] = 0;
        *((_DWORD *)this + 2) = v12 + 1;
      }
      return this;
    default:
      return this;
  }
}

unint64_t sub_1CC8AB830(_DWORD *a1)
{
  int v1 = ~*a1;
  unint64_t result = *(void *)a1 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v1 & 3) == 0) {
    unint64_t result = *(void *)(result + 24);
  }
  unsigned int v3 = *(unsigned __int8 *)(result + 16);
  if (result) {
    BOOL v4 = v3 > 0x1B;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    if (!*(unsigned char *)(result + 16))
    {
      if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0) {
        return 0;
      }
      uint64_t v7 = *(void *)(result + 80);
      goto LABEL_22;
    }
    if (v3 == 21)
    {
      uint64_t v5 = *(void *)(result + 24);
      if (v5) {
        BOOL v6 = *(unsigned char *)(v5 + 16) == 3;
      }
      else {
        BOOL v6 = 0;
      }
      if (!v6)
      {
        if (!*(unsigned char *)(v5 + 16) && *(void *)(v5 + 72) == v5 + 72 && (*(unsigned char *)(v5 + 34) & 0x80) == 0) {
          return 0;
        }
        goto LABEL_21;
      }
      if ((*(_DWORD *)(v5 + 20) & 0x7FFFFFF) != 0)
      {
LABEL_21:
        uint64_t v7 = *(void *)(v5 + 80);
LABEL_22:
        if (v7) {
          uint64_t v8 = v7 - 24;
        }
        else {
          uint64_t v8 = 0;
        }
        uint64_t v9 = *(void *)(v8 + 48);
        if (v9) {
          return v9 - 24;
        }
        else {
          return 0;
        }
      }
    }
    return 0;
  }
  return result;
}

llvm::AbstractAttribute *sub_1CC8AB8F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD650F6C(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AAValueSimplify::createForPosition((llvm::AAValueSimplify *)&v56, (uint64_t **)a1, v14);
  sub_1CD6510B8(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAValueSimplify::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    unsigned int v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    unsigned int v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  uint64_t v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    uint64_t v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      unint64_t v43 = v52;
    }
    else {
      unint64_t v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      int v45 = __p;
    }
    else {
      int v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    int64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t llvm::Attributor::isAssumedDead(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, unsigned char *a5, int a6, int a7)
{
  uint64_t v13 = a2[3];
  unsigned int v14 = *(unsigned __int8 *)(v13 + 16);
  if (v13) {
    BOOL v15 = v14 > 0x1B;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15)
  {
    uint64_t v21 = *a2;
    unsigned int v29 = *(unsigned __int8 *)(*a2 + 16);
    if (v29 == 21) {
      goto LABEL_49;
    }
    if (v29 < 0x1C)
    {
      if (!*(unsigned char *)(*a2 + 16)) {
        v21 |= 2uLL;
      }
      goto LABEL_49;
    }
    unsigned int v30 = v29 - 33;
    BOOL v15 = v30 > 0x33;
    uint64_t v31 = (1 << v30) & 0x8000000000041;
    if (v15 || v31 == 0)
    {
LABEL_49:
      v40[0] = v21;
LABEL_60:
      v40[1] = 0;
      return llvm::Attributor::isAssumedDead(a1, (uint64_t)v40, a3, a4, a5, a6, a7);
    }
LABEL_48:
    v21 |= 1uLL;
    goto LABEL_49;
  }
  if (*(unsigned __int8 *)(v13 + 16) <= 0x26u)
  {
    if (v14 == 29)
    {
      uint64_t v21 = *(void *)(*(void *)(v13 + 40) + 56);
      goto LABEL_48;
    }
    if (v14 == 33) {
      goto LABEL_10;
    }
  }
  else
  {
    switch(v14)
    {
      case 'T':
LABEL_10:
        int v16 = *(_DWORD *)(v13 + 20);
        unint64_t v17 = v13 - 32 * (v16 & 0x7FFFFFF);
        if (v17 <= (unint64_t)a2)
        {
          if (v14 == 84) {
            uint64_t v18 = 0;
          }
          else {
            uint64_t v18 = v14 == 39 ? (*(_DWORD *)(v13 + 80) + 1) : 2;
          }
          if (v16 < 0 && (uint64_t v39 = *(void *)(v17 - 8), (v39 & 0xFFFFFFFF0) != 0)) {
            uint64_t v19 = (*(_DWORD *)(v17 - 12) - *(_DWORD *)(v17 - v39));
          }
          else {
            uint64_t v19 = 0;
          }
          if (v13 - 32 * v18 - 32 * v19 - 32 > (unint64_t)a2)
          {
            unint64_t v20 = (unint64_t)a2 - v17;
            if ((v16 & 0x40000000) != 0) {
              unint64_t v17 = *(void *)(v13 - 8);
            }
            uint64_t v21 = (v17 + (v20 & 0x1FFFFFFFE0)) | 3;
            goto LABEL_49;
          }
        }
        goto LABEL_54;
      case 'S':
        int v33 = *(_DWORD *)(v13 + 20);
        if ((v33 & 0x40000000) != 0) {
          uint64_t v34 = *(void *)(v13 - 8);
        }
        else {
          uint64_t v34 = v13 - 32 * (v33 & 0x7FFFFFF);
        }
        uint64_t v36 = *(void *)(*(void *)(v34
                                    + 32 * *(unsigned int *)(v13 + 60)
                                    + 8 * (((unint64_t)a2 - v34) >> 5))
                        + 40);
        if (v36) {
          uint64_t v37 = v36 - 24;
        }
        else {
          uint64_t v37 = 0;
        }
        if (*(unsigned __int8 *)(v37 + 16) - 29 >= 0xB) {
          uint64_t v38 = 0;
        }
        else {
          uint64_t v38 = v37;
        }
        return llvm::Attributor::isAssumedDead(a1, v38, a3, a4, a5, a6, a7);
      case '\'':
        goto LABEL_10;
    }
  }
  if (v14 == 61) {
    uint64_t v22 = a2[3];
  }
  else {
    uint64_t v22 = 0;
  }
  if (!v22 || (a6 & 1) != 0 || *(void *)(v22 - 32) == *a2) {
    goto LABEL_54;
  }
  unsigned int v23 = *(unsigned __int8 *)(v22 + 16);
  if (!*(unsigned char *)(v22 + 16)
    || v23 >= 0x1C
    && ((v24 = v23 - 33, BOOL v15 = v24 > 0x33, v25 = (1 << v24) & 0x8000000000041, !v15) ? (v26 = v25 == 0) : (v26 = 1),
        !v26))
  {
    v22 |= 2uLL;
  }
  uint64_t v27 = sub_1CC8AC178(a1, v22, 0, a3, 2, 0, 1);
  if (!(*(unsigned int (**)(llvm::AbstractAttribute *))(*(void *)v27 + 160))(v27))
  {
    unsigned int v14 = *(unsigned __int8 *)(v13 + 16);
    if (!*(unsigned char *)(v13 + 16))
    {
LABEL_58:
      v13 |= 2uLL;
      goto LABEL_59;
    }
    if (v14 < 0x1C)
    {
LABEL_59:
      v40[0] = v13;
      goto LABEL_60;
    }
LABEL_54:
    if (v14 - 33 > 0x33 || ((1 << (v14 - 33)) & 0x8000000000041) == 0) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  if (a3) {
    llvm::Attributor::recordDependence(a1, (uint64_t)v27, a3, a7);
  }
  uint64_t result = 1;
  if ((*((unsigned char *)v27 + 40) & 2) == 0) {
    *a5 = 1;
  }
  return result;
}

llvm::AbstractAttribute *sub_1CC8AC178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v57 = a2;
  *((void *)&v57 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD649A14(a1, &v57, a4, a5, 1);
  BOOL v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  llvm::AAIsDead::createForPosition((llvm::AAIsDead *)&v57, (uint64_t **)a1, v14);
  BOOL v15 = (llvm::AbstractAttribute *)v17;
  sub_1CD651128(a1, v17);
  uint64_t v18 = *(uint64_t **)(a1 + 5480);
  if (v18)
  {
    __p[0] = &llvm::AAIsDead::ID;
    v53[0] = 0;
    int v19 = sub_1CD420258(v18, __p, v53) ^ 1;
  }
  else
  {
    int v19 = 0;
  }
  uint64_t v20 = v57 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v57 & 3) == 0) {
    uint64_t v20 = *(void *)(v20 + 24);
  }
  unsigned int v21 = *(unsigned __int8 *)(v20 + 16);
  if (!*(unsigned char *)(v20 + 16)) {
    goto LABEL_20;
  }
  if (v21 == 21)
  {
    uint64_t v22 = (uint64_t *)(v20 + 24);
  }
  else
  {
    if (v21 < 0x1C)
    {
      uint64_t v20 = 0;
      goto LABEL_27;
    }
    uint64_t v22 = (uint64_t *)(*(void *)(v20 + 40) + 56);
  }
  uint64_t v20 = *v22;
  if (!*v22)
  {
LABEL_27:
    char v25 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v23 = *(void *)(v20 + 112);
  if (v23 && ((*(unsigned char *)(v23 + 14) & 2) != 0 || (*(unsigned char *)(v23 + 17) & 8) != 0))
  {
    BOOL v24 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v24 = 0;
  }
  else
  {
    BOOL v26 = *(uint64_t **)(a1 + 88);
    uint64_t v28 = *v26;
    uint64_t v27 = v26[1];
    if (v27 == *v26)
    {
      uint64_t v29 = *((unsigned int *)v26 + 5);
      unsigned int v30 = (void *)(v27 + 8 * v29);
      if (v29)
      {
        uint64_t v31 = 0;
        uint64_t v32 = 8 * v29;
        while (*(void *)(v27 + v31) != v20)
        {
          v31 += 8;
          if (v32 == v31) {
            goto LABEL_47;
          }
        }
        unsigned int v30 = (void *)(v27 + v31);
      }
LABEL_47:
      uint64_t v28 = v26[1];
    }
    else
    {
      uint64_t v33 = *((unsigned int *)v26 + 4);
      int v34 = v33 - 1;
      unsigned int v35 = (v33 - 1) & ((v20 >> 4) ^ (v20 >> 9));
      unsigned int v30 = (void *)(v27 + 8 * v35);
      uint64_t v36 = *v30;
      if (*v30 == -1)
      {
        uint64_t v37 = 0;
LABEL_90:
        if (v37) {
          unsigned int v30 = v37;
        }
        if (*v30 != v20) {
          unsigned int v30 = (void *)(v27 + 8 * v33);
        }
      }
      else
      {
        uint64_t v37 = 0;
        int v38 = 1;
        while (v36 != v20)
        {
          if (v37) {
            BOOL v39 = 0;
          }
          else {
            BOOL v39 = v36 == -2;
          }
          if (v39) {
            uint64_t v37 = v30;
          }
          unsigned int v40 = v35 + v38++;
          unsigned int v35 = v40 & v34;
          unsigned int v30 = (void *)(v27 + 8 * (v40 & v34));
          uint64_t v36 = *v30;
          if (*v30 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v39 = v27 == v28;
    uint64_t v41 = 16;
    if (v39) {
      uint64_t v41 = 20;
    }
    BOOL v24 = v30 == (void *)(v27 + 8 * *(unsigned int *)((char *)v26 + v41));
  }
  char v25 = 0;
  LOBYTE(v19) = (v24 | v19) != 0;
LABEL_52:
  if ((v19 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v53, v15);
  if (v54 >= 0) {
    size_t v42 = v54 & 0x7F;
  }
  else {
    size_t v42 = (size_t)v53[1];
  }
  unint64_t v43 = __p;
  sub_1CB907098((uint64_t)__p, v42 + 12);
  if (v56 < 0) {
    unint64_t v43 = (void **)__p[0];
  }
  if (v42)
  {
    if (v54 >= 0) {
      uint64_t v44 = v53;
    }
    else {
      uint64_t v44 = (void **)v53[0];
    }
    memmove(v43, v44, v42);
  }
  strcpy((char *)v43 + v42, "::initialize");
  int v45 = (uint64_t *)off_1EC7DFC00();
  if (*v45)
  {
    if (v56 >= 0) {
      uint64_t v46 = __p;
    }
    else {
      uint64_t v46 = (void **)__p[0];
    }
    if (v56 >= 0) {
      uint64_t v47 = v56 & 0x7F;
    }
    else {
      uint64_t v47 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v46, v47, (uint64_t)"", 0);
  }
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v54 < 0) {
    operator delete(v53[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v45)
  {
    sub_1CD84B62C(*v45);
    if (v25) {
      goto LABEL_78;
    }
  }
  else if (v25)
  {
    goto LABEL_78;
  }
  int64_t v51 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v20;
  v53[0] = 0;
  if ((sub_1CD420258(v51, __p, v53) & 1) == 0)
  {
    unint64_t v52 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v57);
    v53[0] = 0;
    if ((sub_1CD420258(v52, __p, v53) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v48 = *(_DWORD *)(a1 + 4368);
  if (v48 == 2)
  {
LABEL_79:
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v49 + 40))(v49);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v48;
  }
  if (a4)
  {
    uint64_t v50 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v50 + 16))(v50)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t llvm::Attributor::isAssumedDead(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = a4;
  if (!a4)
  {
    long long v13 = *(unint64_t *)(a2 + 56);
    uint64_t v6 = sub_1CD649A14(a1, &v13, a3, 2, 0);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 128))(v6, a2);
  uint64_t v11 = v10;
  if (a3 && v10) {
    llvm::Attributor::recordDependence(a1, v6, a3, a5);
  }
  return v11;
}

uint64_t llvm::Attributor::checkForAllUses(llvm::Attributor *a1, unsigned int (*a2)(uint64_t, uint64_t *, uint64_t *), uint64_t a3, const llvm::AbstractAttribute *a4, uint64_t a5, int a6, int a7, int a8, uint64_t (*a9)(void, void, void), uint64_t a10)
{
  v85[16] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(a5 + 8);
  if (!v10) {
    return 1;
  }
  unsigned int v20 = 0;
  uint64_t v84 = 0x1000000000;
  unint64_t v72 = v76;
  BOOL v73 = v76;
  uint64_t v83 = v85;
  uint64_t v74 = 16;
  int v75 = 0;
  do
  {
    if (v20 >= HIDWORD(v84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v83[v20] = v10;
    unsigned int v20 = v84 + 1;
    LODWORD(v84) = v84 + 1;
    uint64_t v10 = *(void *)(v10 + 8);
  }
  while (v10);
  unint64_t v21 = sub_1CD6482A0((_DWORD *)a4 + 4);
  if (v21) {
    int64_t v70 = sub_1CC8AC178((uint64_t)a1, v21, 0, (uint64_t)a4, 2, 0, 1);
  }
  else {
    int64_t v70 = 0;
  }
  unsigned int v22 = v84;
  if (!v84)
  {
LABEL_137:
    uint64_t v11 = 1;
    goto LABEL_138;
  }
  uint64_t v69 = a3;
  int64x2_t v68 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  while (1)
  {
    uint64_t v23 = (uint64_t *)v83[v22 - 1];
    LODWORD(v84) = v22 - 1;
    if (*(unsigned char *)(v23[3] + 16) != 83) {
      goto LABEL_47;
    }
    BOOL v24 = v73;
    uint64_t v25 = HIDWORD(v74);
    if (v73 == v72)
    {
      if (HIDWORD(v74))
      {
        BOOL v26 = 0;
        uint64_t v27 = 8 * HIDWORD(v74);
        uint64_t v28 = (uint64_t **)v73;
        while (*v28 != v23)
        {
          if (*v28 == (uint64_t *)-2) {
            BOOL v26 = v28;
          }
          ++v28;
          v27 -= 8;
          if (!v27)
          {
            if (!v26) {
              goto LABEL_23;
            }
            *BOOL v26 = v23;
            --v75;
            goto LABEL_47;
          }
        }
        goto LABEL_122;
      }
LABEL_23:
      unsigned int v29 = v74;
      if (HIDWORD(v74) < v74)
      {
        ++HIDWORD(v74);
        *(void *)&v73[8 * v25] = v23;
        goto LABEL_47;
      }
    }
    else
    {
      unsigned int v29 = v74;
    }
    if (3 * v29 <= 4 * (HIDWORD(v74) - v75))
    {
      if (v29 >= 0x40) {
        v29 *= 2;
      }
      else {
        unsigned int v29 = 128;
      }
LABEL_128:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v72, v29);
      unsigned int v29 = v74;
      BOOL v24 = v73;
      goto LABEL_28;
    }
    if (v29 - HIDWORD(v74) < v29 >> 3) {
      goto LABEL_128;
    }
LABEL_28:
    unsigned int v30 = v29 - 1;
    unsigned int v31 = (v29 - 1) & ((v23 >> 4) ^ (v23 >> 9));
    uint64_t v32 = &v24[8 * v31];
    uint64_t v33 = *(uint64_t **)v32;
    if (*(void *)v32 != -1)
    {
      int v34 = 0;
      int v35 = 1;
      while (v33 != v23)
      {
        if (v34) {
          BOOL v36 = 0;
        }
        else {
          BOOL v36 = v33 == (uint64_t *)-2;
        }
        if (v36) {
          int v34 = (uint64_t **)v32;
        }
        unsigned int v37 = v31 + v35++;
        unsigned int v31 = v37 & v30;
        uint64_t v32 = &v24[8 * (v37 & v30)];
        uint64_t v33 = *(uint64_t **)v32;
        if (*(void *)v32 == -1) {
          goto LABEL_40;
        }
      }
      goto LABEL_122;
    }
    int v34 = 0;
LABEL_40:
    if (v34) {
      int v38 = v34;
    }
    else {
      int v38 = (uint64_t **)v32;
    }
    if (*v38 == v23) {
      goto LABEL_122;
    }
    if (*v38 == (uint64_t *)-2) {
      --v75;
    }
    else {
      ++HIDWORD(v74);
    }
    *int v38 = v23;
LABEL_47:
    BOOL v71 = 0;
    if (llvm::Attributor::isAssumedDead((uint64_t)a1, v23, (uint64_t)a4, v70, &v71, a6, a7)) {
      goto LABEL_122;
    }
    if (a8)
    {
      uint64_t v39 = v23[3];
      if (sub_1CBF698E4(v39) || sub_1CC27D470(v39)) {
        goto LABEL_122;
      }
    }
    uint64_t v40 = v23[3];
    if (!v40 || *(unsigned char *)(v40 + 16) != 61) {
      goto LABEL_110;
    }
    int v41 = *(_DWORD *)(v40 + 20);
    size_t v42 = (v41 & 0x40000000) != 0 ? *(uint64_t **)(v40 - 8) : (uint64_t *)(v40 - 32 * (v41 & 0x7FFFFFF));
    if (v42 != v23) {
      goto LABEL_110;
    }
    unint64_t v43 = v73;
    uint64_t v44 = HIDWORD(v74);
    if (v73 == v72)
    {
      if (HIDWORD(v74))
      {
        int v45 = 0;
        uint64_t v46 = 8 * HIDWORD(v74);
        uint64_t v47 = (uint64_t **)v73;
        while (*v47 != v23)
        {
          if (*v47 == (uint64_t *)-2) {
            int v45 = v47;
          }
          ++v47;
          v46 -= 8;
          if (!v46)
          {
            if (!v45) {
              goto LABEL_65;
            }
            *int v45 = v23;
            --v75;
            goto LABEL_90;
          }
        }
        goto LABEL_122;
      }
LABEL_65:
      unsigned int v48 = v74;
      if (HIDWORD(v74) < v74)
      {
        ++HIDWORD(v74);
        *(void *)&v73[8 * v44] = v23;
        goto LABEL_90;
      }
    }
    else
    {
      unsigned int v48 = v74;
    }
    if (3 * v48 <= 4 * (HIDWORD(v74) - v75))
    {
      if (v48 >= 0x40) {
        v48 *= 2;
      }
      else {
        unsigned int v48 = 128;
      }
LABEL_136:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v72, v48);
      unsigned int v48 = v74;
      unint64_t v43 = v73;
      goto LABEL_70;
    }
    if (v48 - HIDWORD(v74) < v48 >> 3) {
      goto LABEL_136;
    }
LABEL_70:
    unsigned int v49 = v48 - 1;
    unsigned int v50 = (v48 - 1) & ((v23 >> 4) ^ (v23 >> 9));
    int64_t v51 = &v43[8 * v50];
    unint64_t v52 = *(uint64_t **)v51;
    if (*(void *)v51 != -1)
    {
      char v53 = 0;
      int v54 = 1;
      while (v52 != v23)
      {
        if (v53) {
          BOOL v55 = 0;
        }
        else {
          BOOL v55 = v52 == (uint64_t *)-2;
        }
        if (v55) {
          char v53 = (uint64_t **)v51;
        }
        unsigned int v56 = v50 + v54++;
        unsigned int v50 = v56 & v49;
        int64_t v51 = &v43[8 * (v56 & v49)];
        unint64_t v52 = *(uint64_t **)v51;
        if (*(void *)v51 == -1) {
          goto LABEL_83;
        }
      }
      goto LABEL_122;
    }
    char v53 = 0;
LABEL_83:
    if (v53) {
      long long v57 = v53;
    }
    else {
      long long v57 = (uint64_t **)v51;
    }
    if (*v57 == v23) {
      goto LABEL_122;
    }
    if (*v57 == (uint64_t *)-2) {
      --v75;
    }
    else {
      ++HIDWORD(v74);
    }
    *long long v57 = v23;
LABEL_90:
    uint64_t v77 = 1;
    int64x2_t v78 = v68;
    int64x2_t v79 = v68;
    uint64_t v80 = v82;
    uint64_t v81 = 0x400000000;
    int PotentialCopiesOfStoredValue = llvm::AA::getPotentialCopiesOfStoredValue(a1, v40, &v77, a4, &v71, 1);
    char v59 = PotentialCopiesOfStoredValue;
    if (PotentialCopiesOfStoredValue)
    {
      uint64_t v60 = a9;
      if (v81)
      {
        char v66 = PotentialCopiesOfStoredValue;
        uint64_t v61 = v80;
        v67 = &v80[8 * v81];
        while (1)
        {
          uint64_t v62 = *(void *)(*(void *)v61 + 8);
          if (v62) {
            break;
          }
LABEL_100:
          v61 += 8;
          if (v61 == v67)
          {
            LODWORD(v64) = 6;
            goto LABEL_104;
          }
        }
        while (1)
        {
          if (v60)
          {
            int v63 = a9(a10, v23, v62);
            uint64_t v60 = a9;
            if (!v63) {
              break;
            }
          }
          if (v84 >= (unint64_t)HIDWORD(v84)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v83[v84] = v62;
          LODWORD(v84) = v84 + 1;
          uint64_t v62 = *(void *)(v62 + 8);
          if (!v62) {
            goto LABEL_100;
          }
        }
        LODWORD(v64) = 1;
LABEL_104:
        char v59 = v66;
      }
      else
      {
        LODWORD(v64) = 6;
      }
    }
    else
    {
      LODWORD(v64) = 0;
    }
    if (v80 != v82) {
      free(v80);
    }
    if (v77)
    {
      if (v59) {
        goto LABEL_120;
      }
    }
    else
    {
      MEMORY[0x1D25D9CD0](v78.i64[0], 8);
      if (v59) {
        goto LABEL_120;
      }
    }
LABEL_110:
    LOBYTE(v77) = 0;
    if (a2(v69, v23, &v77))
    {
      if ((_BYTE)v77)
      {
        uint64_t v64 = *(void *)(v23[3] + 8);
        if (v64)
        {
          unsigned int v65 = v84;
          do
          {
            if (v65 >= HIDWORD(v84)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v83[v65] = v64;
            unsigned int v65 = v84 + 1;
            LODWORD(v84) = v84 + 1;
            uint64_t v64 = *(void *)(v64 + 8);
          }
          while (v64);
        }
      }
      else
      {
        LODWORD(v64) = 6;
      }
    }
    else
    {
      LODWORD(v64) = 1;
    }
LABEL_120:
    if (v64 != 6 && v64) {
      break;
    }
LABEL_122:
    unsigned int v22 = v84;
    if (!v84) {
      goto LABEL_137;
    }
  }
  uint64_t v11 = 0;
LABEL_138:
  if (v73 != v72) {
    free(v73);
  }
  if (v83 != v85) {
    free(v83);
  }
  return v11;
}

uint64_t llvm::Attributor::checkForAllCallSites(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *), uint64_t a3, uint64_t a4, int a5, uint64_t a6, unsigned char *a7)
{
  v53[8] = *MEMORY[0x1E4F143B8];
  if (a5 && (*(_DWORD *)(a4 + 32) & 0xFu) - 7 > 1) {
    return 0;
  }
  uint64_t v16 = *(void *)(a4 + 8);
  uint64_t v17 = v53;
  int64_t v51 = v53;
  uint64_t v52 = 0x800000000;
  sub_1CD651198((uint64_t)&v51, v16);
  if (v52)
  {
    unint64_t v18 = 0;
    uint64_t v44 = a3;
    if (a5) {
      int v19 = 1;
    }
    else {
      int v19 = 6;
    }
    int v45 = v19;
    do
    {
      unsigned int v20 = (uint64_t *)*((void *)v51 + v18);
      if (llvm::Attributor::isAssumedDead(a1, v20, a6, 0, a7, 1, 1)) {
        goto LABEL_53;
      }
      uint64_t v21 = v20[3];
      if (v21) {
        BOOL v22 = *(unsigned char *)(v21 + 16) == 5;
      }
      else {
        BOOL v22 = 0;
      }
      if (v22 && *(unsigned __int16 *)(v21 + 18) - 38 <= 0xC && *(unsigned char *)(*(void *)v21 + 8) == 15)
      {
        uint64_t v23 = *(void *)(v21 + 8);
        if (v23)
        {
          unsigned int v24 = v52;
          do
          {
            if (v24 >= HIDWORD(v52)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v51 + v24) = v23;
            unsigned int v24 = v52 + 1;
            LODWORD(v52) = v52 + 1;
            uint64_t v23 = *(void *)(v23 + 8);
          }
          while (v23);
        }
        goto LABEL_53;
      }
      llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v48, (const llvm::Use *)v20);
      if (!v48)
      {
        if (*(unsigned char *)(v20[3] + 16) == 4) {
          int v27 = 6;
        }
        else {
          int v27 = 1;
        }
        goto LABEL_50;
      }
      if (v50)
      {
        int v25 = *(_DWORD *)(v48 + 20);
        if ((v25 & 0x40000000) != 0) {
          uint64_t v26 = *(void *)(v48 - 8);
        }
        else {
          uint64_t v26 = v48 - 32 * (v25 & 0x7FFFFFF);
        }
        unsigned int v20 = (uint64_t *)(v26 + 32 * *(unsigned int *)v49);
      }
      else
      {
        unsigned int v28 = *(unsigned __int8 *)(*(void *)(v48 - 32) + 16);
        if (v28 < 0x15 || v28 == 24)
        {
          int v27 = v45;
          if ((uint64_t *)(v48 - 32) != v20) {
            goto LABEL_50;
          }
LABEL_55:
          unint64_t v43 = v17;
          unsigned int v33 = sub_1CD647E8C(&v48);
          if (*(void *)(a4 + 96) >= (unint64_t)v33) {
            uint64_t v34 = v33;
          }
          else {
            uint64_t v34 = *(void *)(a4 + 96);
          }
          if (!v34)
          {
LABEL_74:
            uint64_t v46 = v48;
            v47[0] = &v48;
            v47[1] = 0;
            if (v50) {
              sub_1CD41B6B0((uint64_t)v47, (uint64_t)&v49);
            }
            int v42 = sub_1CD649BF0(a2, v44, &v46);
            uint64_t v17 = v43;
            if (v47[0] != &v48) {
              free(v47[0]);
            }
            if (v42) {
              int v27 = 6;
            }
            else {
              int v27 = 1;
            }
            goto LABEL_50;
          }
          uint64_t v35 = 0;
          uint64_t v36 = 0;
          while (2)
          {
            if (v50
              || ((uint64_t v37 = v48, v38 = *(unsigned __int8 *)(*(void *)(v48 - 32) + 16), v38 >= 0x15)
                ? (BOOL v39 = v38 == 24)
                : (BOOL v39 = 1),
                  !v39))
            {
              uint64_t v40 = *((unsigned int *)v49 + v36 + 1);
              if ((v40 & 0x80000000) == 0)
              {
                uint64_t v37 = v48;
LABEL_69:
                int v41 = *(void **)(v37 - 32 * (*(_DWORD *)(v37 + 20) & 0x7FFFFFF) + 32 * v40);
                if (v41)
                {
                  if (*(_WORD *)(a4 + 18)) {
                    llvm::Function::BuildLazyArguments((llvm::Function *)a4);
                  }
                  if (*(void *)(*(void *)(a4 + 88) + v35) != *v41)
                  {
                    int v27 = 1;
                    uint64_t v17 = v43;
                    goto LABEL_50;
                  }
                }
              }
              ++v36;
              v35 += 40;
              if (v34 == v36) {
                goto LABEL_74;
              }
              continue;
            }
            break;
          }
          uint64_t v40 = v36;
          goto LABEL_69;
        }
      }
      uint64_t v30 = v20[3];
      if (v30) {
        BOOL v31 = *(unsigned char *)(v30 + 16) == 5;
      }
      else {
        BOOL v31 = 0;
      }
      if (v31)
      {
        uint64_t v32 = *(void *)(v30 + 8);
        if (v32)
        {
          if (!*(void *)(v32 + 8) && *(unsigned __int16 *)(v30 + 18) - 38 < 0xD) {
            unsigned int v20 = *(uint64_t **)(v30 + 8);
          }
        }
      }
      int v27 = v45;
      if (*(_DWORD *)v49 == (((unint64_t)&v20[4 * (*(_DWORD *)(v48 + 20) & 0x7FFFFFF)] - v48) >> 5)) {
        goto LABEL_55;
      }
LABEL_50:
      if (v49 != &v51) {
        free(v49);
      }
      if (v27 != 6)
      {
        uint64_t v14 = 0;
        goto LABEL_83;
      }
LABEL_53:
      ++v18;
    }
    while (v18 < v52);
  }
  uint64_t v14 = 1;
LABEL_83:
  if (v51 != v17) {
    free(v51);
  }
  return v14;
}

uint64_t llvm::Attributor::checkForAllReturnedValuesAndReturnInsts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = sub_1CD648A0C((llvm::IRPosition *)(a4 + 16));
  if (!v8) {
    return 0;
  }
  uint64_t v9 = sub_1CC8B670C(a1, v8, 0, a4, 0, 0, 1);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10)) {
    return 0;
  }
  uint64_t v11 = *(uint64_t (**)(llvm::AbstractAttribute *, uint64_t, uint64_t))(*(void *)v9 + 120);

  return v11(v9, a2, a3);
}

uint64_t sub_1CC8AD398(uint64_t a1, uint64_t *a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, uint64_t a5, _DWORD *a6, int *a7, uint64_t a8, unsigned char *a9, unsigned __int8 a10, char a11)
{
  if (!a8) {
    return 1;
  }
  uint64_t v11 = a7;
  uint64_t v16 = &a7[a8];
  if (!a1) {
    a11 = 1;
  }
  while (1)
  {
    int v33 = *v11;
    uint64_t v18 = sub_1CD64E2A8(a2, &v33);
    if (v18)
    {
      uint64_t v19 = *(unsigned int *)(v18 + 8);
      if (v19) {
        break;
      }
    }
LABEL_22:
    if (++v11 == v16) {
      return 1;
    }
  }
  unsigned int v20 = *(uint64_t **)v18;
  uint64_t v21 = 8 * v19;
  while (1)
  {
    uint64_t v22 = *v20;
    if (a11) {
      goto LABEL_26;
    }
    unsigned int v24 = *(unsigned __int8 *)(v22 + 16);
    if (*(unsigned char *)(v22 + 16)
      && (v24 < 0x1C
       || ((unsigned int v25 = v24 - 33, v26 = v25 > 0x33, v27 = (1 << v25) & 0x8000000000041, !v26)
         ? (BOOL v28 = v27 == 0)
         : (BOOL v28 = 1),
           v28)))
    {
      uint64_t v29 = *v20;
    }
    else
    {
      uint64_t v29 = v22 | 2;
    }
    v32[0] = v29;
    v32[1] = 0;
    if ((llvm::Attributor::isAssumedDead(a1, (uint64_t)v32, a5, a6, a9, a10, 1) & 1) == 0)
    {
LABEL_26:
      uint64_t result = a3(a4, v22);
      if (!result) {
        return result;
      }
    }
    ++v20;
    v21 -= 8;
    if (!v21) {
      goto LABEL_22;
    }
  }
}

uint64_t llvm::Attributor::runTillFixpoint(llvm::Attributor *this)
{
  v140[34] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = (uint64_t *)off_1EC7DFC00();
  if (*v3) {
    llvm::timeTraceProfilerBegin((uint64_t)"Attributor::runTillFixpoint", 27, (uint64_t)"", 0);
  }
  if (*((unsigned char *)this + 5492)) {
    BOOL v4 = (unsigned int *)((char *)this + 5488);
  }
  else {
    BOOL v4 = (unsigned int *)&unk_1EBCDD7F8;
  }
  unsigned int v5 = *v4;
  uint64_t v120 = v122;
  uint64_t v121 = 0x2000000000;
  v112[0] = 0;
  v112[1] = 0;
  int v113 = 0;
  long long v115 = 0;
  long long v116 = 0;
  long long v114 = 0;
  uint64_t v7 = (uint64_t *)((char *)this + 104);
  unint64_t v6 = *((void *)this + 13);
  v107[0] = 0;
  v107[1] = 0;
  int v108 = 0;
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  uint64_t v109 = 0;
  unint64_t v104 = v3;
  unsigned int v105 = v5;
  if ((v6 & 2) != 0)
  {
    unint64_t v10 = v6 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v9 = *(char **)v10;
    uint64_t v8 = *(void *)v10 + 8 * *(unsigned int *)(v10 + 8);
  }
  else
  {
    uint64_t v8 = (uint64_t)&v7[v6 > 3];
    uint64_t v9 = (char *)this + 104;
  }
  sub_1CD64A05C((uint64_t)v112, (uint64_t)v9, (uint64_t (*)(uint64_t))sub_1CD64E318, v8);
  unsigned int v11 = 1;
  uint64_t v12 = 0x7FFFFFFFFFFFFFF8;
  long long v106 = (unint64_t *)((char *)this + 104);
  while (1)
  {
    uint64_t v13 = *v7;
    if ((unint64_t)*v7 < 4) {
      goto LABEL_11;
    }
    unint64_t v39 = v13 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v13 & 2) == 0 || !v39)
    {
      if ((v13 & 2) != 0) {
        uint64_t v14 = *(unsigned int *)(v39 + 8);
      }
      else {
        uint64_t v14 = 1;
      }
      goto LABEL_12;
    }
    uint64_t v14 = *(unsigned int *)(v39 + 8);
    if (!v14) {
LABEL_11:
    }
      uint64_t v14 = 0;
LABEL_12:
    uint64_t v16 = v109;
    uint64_t v15 = v110;
    if (v110 == v109) {
      goto LABEL_35;
    }
    unint64_t v17 = 0;
    LODWORD(v1) = 0;
    do
    {
      uint64_t v18 = *(void *)(v16 + 8 * v17);
      unint64_t v19 = *(void *)(v18 + 8);
      if (v19 < 4) {
        goto LABEL_34;
      }
      do
      {
        unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v19 & 2) != 0 && v20)
        {
          uint64_t v21 = *(unsigned int *)(v20 + 8);
          if (!v21) {
            break;
          }
          unint64_t v22 = *(void *)(*(void *)v20 + 8 * v21 - 8);
LABEL_22:
          *(_DWORD *)(v20 + 8) = v21 - 1;
          goto LABEL_23;
        }
        if ((v19 & 2) == 0)
        {
          *(void *)(v18 + 8) = 0;
          unint64_t v22 = v19 & 0xFFFFFFFFFFFFFFFCLL;
          goto LABEL_23;
        }
        uint64_t v21 = *(unsigned int *)(v20 + 8);
        unint64_t v22 = *(void *)(*(void *)v20 + 8 * v21 - 8);
        if (v20) {
          goto LABEL_22;
        }
LABEL_23:
        unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFF8;
        v133 = (unsigned char *)(v22 & 0xFFFFFFFFFFFFFFF8);
        if ((v22 & 4) != 0)
        {
          BOOL v26 = v112;
LABEL_29:
          sub_1CC37AF14(v26, (uint64_t *)&v133);
          goto LABEL_30;
        }
        uint64_t v24 = (*(uint64_t (**)(unint64_t))(*(void *)v23 + 40))(v23);
        (*(void (**)(uint64_t))(*(void *)v24 + 40))(v24);
        uint64_t v25 = (*(uint64_t (**)(unint64_t))(*(void *)v23 + 40))(v23);
        if (((*(uint64_t (**)(uint64_t))(*(void *)v25 + 16))(v25) & 1) == 0)
        {
          BOOL v26 = v107;
          goto LABEL_29;
        }
        if (v121 >= (unint64_t)HIDWORD(v121)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v120 + v121) = v23;
        LODWORD(v121) = v121 + 1;
LABEL_30:
        unint64_t v19 = *(void *)(v18 + 8);
      }
      while (v19 > 3);
      uint64_t v16 = v109;
      uint64_t v15 = v110;
LABEL_34:
      unint64_t v17 = (v1 + 1);
      uint64_t v1 = v17;
    }
    while (v17 < (v15 - v16) >> 3);
LABEL_35:
    if (!v121) {
      goto LABEL_50;
    }
    uint64_t v27 = (char *)v120;
    BOOL v28 = (char *)v120 + 8 * v121;
    while (2)
    {
      uint64_t v29 = *(void *)v27;
      unint64_t v30 = *(void *)(*(void *)v27 + 8);
      if (v30 < 4) {
        goto LABEL_49;
      }
      while (2)
      {
        unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v30 & 2) != 0 && v31)
        {
          uint64_t v32 = *(unsigned int *)(v31 + 8);
          if (!v32) {
            goto LABEL_49;
          }
LABEL_44:
          unint64_t v31 = *(void *)(*(void *)v31 + 8 * v32 - 8);
        }
        else if ((v30 & 2) != 0)
        {
          uint64_t v32 = *(unsigned int *)(v31 + 8);
          goto LABEL_44;
        }
        v133 = (unsigned char *)(v31 & 0xFFFFFFFFFFFFFFF8);
        sub_1CC37AF14(v112, (uint64_t *)&v133);
        unint64_t v30 = *(void *)(v29 + 8);
        if ((v30 & 2) != 0)
        {
          if ((v30 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
            goto LABEL_49;
          }
          --*(_DWORD *)((v30 & 0xFFFFFFFFFFFFFFFCLL) + 8);
          continue;
        }
        break;
      }
      *(void *)(v29 + 8) = 0;
LABEL_49:
      v27 += 8;
      if (v27 != v28) {
        continue;
      }
      break;
    }
LABEL_50:
    LODWORD(v121) = 0;
    sub_1CD47558C(v107);
    uint64_t v110 = v109;
    int v33 = v114;
    unint64_t v34 = (unint64_t)v115;
    while (v33 != (uint64_t *)v34)
    {
      uint64_t v1 = *v33;
      v133 = (unsigned char *)v1;
      uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 40))(v1);
      if (((*(uint64_t (**)(uint64_t))(*(void *)v35 + 24))(v35) & 1) == 0
        && !llvm::Attributor::updateAA(this, (llvm::AbstractAttribute *)v1))
      {
        if (v121 >= (unint64_t)HIDWORD(v121)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v120 + v121) = v1;
        LODWORD(v121) = v121 + 1;
      }
      if (((*(uint64_t (**)(uint64_t))(*(void *)v35 + 16))(v35) & 1) == 0) {
        sub_1CC37AF14(v107, (uint64_t *)&v133);
      }
      ++v33;
    }
    unint64_t v36 = *v106;
    if ((*v106 & 2) != 0)
    {
      unint64_t v40 = v36 & 0xFFFFFFFFFFFFFFFCLL;
      unsigned int v38 = *(char **)(v36 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v37 = (uint64_t)&v38[8 * *(unsigned int *)(v40 + 8)];
    }
    else
    {
      uint64_t v37 = (uint64_t)&v106[v36 > 3];
      unsigned int v38 = (char *)this + 104;
    }
    sub_1CD64A100((uint64_t)&v120, (uint64_t)&v38[8 * v14], (uint64_t (*)(uint64_t))sub_1CD64E318, v37);
    sub_1CD47558C(v112);
    long long v115 = v114;
    if (v121)
    {
      int v41 = (uint64_t *)v120;
      int v42 = (uint64_t *)((char *)v120 + 8 * v121);
      do
      {
        sub_1CD4C96F8((uint64_t)&v133, (uint64_t)v112, v41);
        if ((_BYTE)v135)
        {
          uint64_t v1 = (uint64_t)v115;
          if (v115 >= (uint64_t *)v116)
          {
            uint64_t v44 = v114;
            uint64_t v45 = v115 - v114;
            unint64_t v46 = v45 + 1;
            if ((unint64_t)(v45 + 1) >> 61) {
LABEL_220:
            }
              abort();
            uint64_t v47 = v116 - (char *)v114;
            if ((v116 - (char *)v114) >> 2 > v46) {
              unint64_t v46 = v47 >> 2;
            }
            if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v46;
            }
            if (v34)
            {
              if (v34 >> 61) {
LABEL_221:
              }
                sub_1CB833614();
              uint64_t v48 = (char *)operator new(8 * v34);
            }
            else
            {
              uint64_t v48 = 0;
            }
            unsigned int v49 = (uint64_t *)&v48[8 * v45];
            *unsigned int v49 = *v41;
            unint64_t v43 = v49 + 1;
            if ((uint64_t *)v1 != v44)
            {
              do
              {
                uint64_t v50 = *(void *)(v1 - 8);
                v1 -= 8;
                *--unsigned int v49 = v50;
              }
              while ((uint64_t *)v1 != v44);
              uint64_t v1 = (uint64_t)v114;
            }
            long long v114 = v49;
            long long v116 = &v48[8 * v34];
            if (v1) {
              operator delete((void *)v1);
            }
          }
          else
          {
            *long long v115 = *v41;
            v1 += 8;
            unint64_t v43 = (uint64_t *)v1;
          }
          long long v115 = v43;
        }
        ++v41;
      }
      while (v41 != v42);
    }
    uint64_t v51 = *((unsigned int *)this + 1332);
    if (v51)
    {
      uint64_t v52 = (uint64_t *)*((void *)this + 665);
      char v53 = &v52[v51];
      do
      {
        sub_1CD4C96F8((uint64_t)&v133, (uint64_t)v112, v52);
        if ((_BYTE)v135)
        {
          uint64_t v1 = (uint64_t)v115;
          if (v115 >= (uint64_t *)v116)
          {
            BOOL v55 = v114;
            uint64_t v56 = v115 - v114;
            unint64_t v57 = v56 + 1;
            if ((unint64_t)(v56 + 1) >> 61) {
              goto LABEL_220;
            }
            uint64_t v58 = v116 - (char *)v114;
            if ((v116 - (char *)v114) >> 2 > v57) {
              unint64_t v57 = v58 >> 2;
            }
            if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v57;
            }
            if (v34)
            {
              if (v34 >> 61) {
                goto LABEL_221;
              }
              char v59 = (char *)operator new(8 * v34);
            }
            else
            {
              char v59 = 0;
            }
            uint64_t v60 = (uint64_t *)&v59[8 * v56];
            *uint64_t v60 = *v52;
            int v54 = v60 + 1;
            if ((uint64_t *)v1 != v55)
            {
              do
              {
                uint64_t v61 = *(void *)(v1 - 8);
                v1 -= 8;
                *--uint64_t v60 = v61;
              }
              while ((uint64_t *)v1 != v55);
              uint64_t v1 = (uint64_t)v114;
            }
            long long v114 = v60;
            long long v116 = &v59[8 * v34];
            if (v1) {
              operator delete((void *)v1);
            }
          }
          else
          {
            *long long v115 = *v52;
            v1 += 8;
            int v54 = (uint64_t *)v1;
          }
          long long v115 = v54;
        }
        ++v52;
      }
      while (v52 != v53);
    }
    uint64_t v62 = (uint64_t)sub_1CD6513DC((void *)this + 648);
    *((_DWORD *)this + 1332) = 0;
    if (v114 == v115)
    {
      unsigned int v63 = v11;
      break;
    }
    unsigned int v63 = v11 + 1;
    BOOL v64 = v11++ >= v105;
    uint64_t v7 = (uint64_t *)((char *)this + 104);
    if (v64)
    {
      unsigned int v11 = v63;
      if (!byte_1EBCDD978) {
        break;
      }
    }
  }
  if (v63 <= v105) {
    goto LABEL_150;
  }
  uint64_t v65 = *((void *)this + 10);
  char v66 = *(uint64_t **)(v65 + 24);
  if (v66 == *(uint64_t **)(v65 + 32)) {
    goto LABEL_150;
  }
  v67 = (uint64_t (*)(void, uint64_t))*((void *)this + 687);
  if (!v67) {
    goto LABEL_150;
  }
  uint64_t v1 = *v66;
  unint64_t v34 = v67(*((void *)this + 688), *v66);
  uint64_t v68 = ****(void ****)v34;
  if (!*(void *)(v68 + 128))
  {
    uint64_t v62 = (*(uint64_t (**)(void))(**(void **)(v68 + 72) + 48))(*(void *)(v68 + 72));
    if (!v62) {
      goto LABEL_150;
    }
  }
  llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v133, *((void *)this + 689), (uint64_t)"FixedPoint", 10, (llvm::Function *)v1);
  uint64_t v123 = "Attributor did not reach a fixpoint after ";
  uint64_t v124 = 42;
  sub_1CC59ADEC((uint64_t *)&v138, (uint64_t)&v123);
  llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v117, "Iterations", 0xAuLL, v105);
  uint64_t v69 = sub_1CD3D6290((uint64_t)&v133, (long long *)&v117);
  uint64_t v123 = " iterations.";
  uint64_t v124 = 12;
  sub_1CC59ADEC((uint64_t *)(v69 + 80), (uint64_t)&v123);
  int v70 = *(_DWORD *)(v69 + 8);
  BYTE4(v124) = *(unsigned char *)(v69 + 12);
  LODWORD(v124) = v70;
  long long v71 = *(_OWORD *)(v69 + 16);
  uint64_t v126 = *(void *)(v69 + 32);
  long long v125 = v71;
  this = (llvm::Attributor *)&unk_1F2616800;
  uint64_t v72 = *(void *)(v69 + 72);
  long long v73 = *(_OWORD *)(v69 + 56);
  long long v127 = *(_OWORD *)(v69 + 40);
  long long v128 = v73;
  uint64_t v123 = (const char *)&unk_1F2616800;
  uint64_t v129 = v72;
  uint64_t v12 = (uint64_t)v132;
  v130 = v132;
  uint64_t v131 = 0x400000000;
  if (*(_DWORD *)(v69 + 88)) {
    sub_1CD494D68((uint64_t)&v130, v69 + 80);
  }
  uint64_t v74 = *(void *)(v69 + 360);
  v132[32] = *(void *)(v69 + 352);
  v132[33] = v74;
  uint64_t v123 = (const char *)&unk_1F26165A8;
  if (v119 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v117.__r_.__value_.__l.__data_);
  }
  v133 = &unk_1F2616800;
  uint64_t v1 = (uint64_t)v138;
  if (v139)
  {
    unint64_t v75 = (unint64_t)v139 << 6;
    do
    {
      unint64_t v76 = v1 + v75;
      if (*(char *)(v1 + v75 - 17) < 0) {
        operator delete(*(void **)(v76 - 40));
      }
      if (*(char *)(v76 - 41) < 0) {
        operator delete(*(void **)(v76 - 64));
      }
      v75 -= 64;
    }
    while (v75);
    uint64_t v1 = (uint64_t)v138;
  }
  if ((void *)v1 != v140) {
    goto LABEL_222;
  }
  while (2)
  {
    uint64_t v62 = llvm::OptimizationRemarkEmitter::emit((uint64_t ***)v34, (llvm::DiagnosticInfoOptimizationBase *)&v123);
    uint64_t v123 = (const char *)this;
    this = (llvm::Attributor *)v130;
    if (v131)
    {
      unint64_t v77 = (unint64_t)v131 << 6;
      do
      {
        int64x2_t v78 = (void **)((char *)this + v77);
        if (*((char *)this + v77 - 17) < 0) {
          operator delete(*(v78 - 5));
        }
        if (*((char *)v78 - 41) < 0) {
          operator delete(*(v78 - 8));
        }
        v77 -= 64;
      }
      while (v77);
      this = (llvm::Attributor *)v130;
    }
    if (this != (llvm::Attributor *)v12) {
      free(this);
    }
LABEL_150:
    v133 = v137;
    v134 = v137;
    uint64_t v135 = 32;
    int v136 = 0;
    if (v121)
    {
      uint64_t v12 = 0;
      uint64_t v1 = 128;
      while (1)
      {
        this = (llvm::Attributor *)*((void *)v120 + v12);
        uint64_t v81 = (char *)v134;
        uint64_t v82 = HIDWORD(v135);
        if (v134 == v133)
        {
          if (HIDWORD(v135))
          {
            uint64_t v83 = 0;
            uint64_t v84 = 8 * HIDWORD(v135);
            uint64_t v85 = (llvm::Attributor **)v134;
            do
            {
              if (*v85 == this) {
                goto LABEL_212;
              }
              if (*v85 == (llvm::Attributor *)-2) {
                uint64_t v83 = v85;
              }
              ++v85;
              v84 -= 8;
            }
            while (v84);
            if (v83)
            {
              *uint64_t v83 = this;
              --v136;
              goto LABEL_196;
            }
          }
          unsigned int v86 = v135;
          if (HIDWORD(v135) < v135)
          {
            ++HIDWORD(v135);
            *((void *)v134 + v82) = this;
            goto LABEL_196;
          }
        }
        else
        {
          unsigned int v86 = v135;
        }
        if (3 * v86 <= 4 * (HIDWORD(v135) - v136)) {
          break;
        }
        if (v86 - HIDWORD(v135) < v86 >> 3) {
          goto LABEL_219;
        }
LABEL_177:
        unsigned int v87 = v86 - 1;
        unsigned int v88 = (v86 - 1) & ((this >> 4) ^ (this >> 9));
        uint64_t v89 = (llvm::Attributor **)&v81[8 * v88];
        long long v90 = *v89;
        if (*v89 == (llvm::Attributor *)-1)
        {
          v91 = 0;
        }
        else
        {
          v91 = 0;
          int v92 = 1;
          do
          {
            if (v90 == this) {
              goto LABEL_212;
            }
            if (v91) {
              BOOL v93 = 0;
            }
            else {
              BOOL v93 = v90 == (llvm::Attributor *)-2;
            }
            if (v93) {
              v91 = v89;
            }
            unsigned int v94 = v88 + v92++;
            unsigned int v88 = v94 & v87;
            uint64_t v89 = (llvm::Attributor **)&v81[8 * (v94 & v87)];
            long long v90 = *v89;
          }
          while (*v89 != (llvm::Attributor *)-1);
        }
        if (v91) {
          uint64_t v95 = v91;
        }
        else {
          uint64_t v95 = v89;
        }
        if (*v95 == this) {
          goto LABEL_212;
        }
        if (*v95 == (llvm::Attributor *)-2) {
          --v136;
        }
        else {
          ++HIDWORD(v135);
        }
        *uint64_t v95 = this;
LABEL_196:
        unint64_t v34 = (*(uint64_t (**)(llvm::Attributor *))(*(void *)this + 40))(this);
        uint64_t v62 = (*(uint64_t (**)(unint64_t))(*(void *)v34 + 24))(v34);
        if ((v62 & 1) == 0) {
          uint64_t v62 = (*(uint64_t (**)(unint64_t))(*(void *)v34 + 40))(v34);
        }
        unint64_t v96 = *((void *)this + 1);
        if (v96 >= 4)
        {
          while (1)
          {
            unint64_t v97 = v96 & 0xFFFFFFFFFFFFFFFCLL;
            if ((v96 & 2) != 0 && v97)
            {
              uint64_t v98 = *(unsigned int *)(v97 + 8);
              if (!v98) {
                break;
              }
            }
            else
            {
              if ((v96 & 2) == 0) {
                goto LABEL_206;
              }
              uint64_t v98 = *(unsigned int *)(v97 + 8);
            }
            unint64_t v97 = *(void *)(*(void *)v97 + 8 * v98 - 8);
LABEL_206:
            if (v121 >= (unint64_t)HIDWORD(v121)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v120 + v121) = v97 & 0xFFFFFFFFFFFFFFF8;
            LODWORD(v121) = v121 + 1;
            unint64_t v96 = *((void *)this + 1);
            if ((v96 & 2) == 0)
            {
              *((void *)this + 1) = 0;
              break;
            }
            if ((v96 & 0xFFFFFFFFFFFFFFFCLL) == 0) {
              break;
            }
            --*(_DWORD *)((v96 & 0xFFFFFFFFFFFFFFFCLL) + 8);
          }
        }
LABEL_212:
        if (++v12 >= (unint64_t)v121) {
          goto LABEL_151;
        }
      }
      if (v86 >= 0x40) {
        v86 *= 2;
      }
      else {
        unsigned int v86 = 128;
      }
LABEL_219:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v133, v86);
      unsigned int v86 = v135;
      uint64_t v81 = (char *)v134;
      goto LABEL_177;
    }
LABEL_151:
    if (byte_1EBCDD978) {
      BOOL v79 = v63 == v105;
    }
    else {
      BOOL v79 = 1;
    }
    if (!v79)
    {
      long long v99 = (llvm::raw_ostream *)llvm::errs((llvm *)v62);
      unint64_t v100 = sub_1CB8E509C(v99, "\n[Attributor] Fixpoint iteration done after: ");
      unint64_t v101 = sub_1CD4901A4(v100, v63);
      uint64_t v102 = sub_1CB8E509C(v101, "/");
      uint64_t v103 = sub_1CD4901A4(v102, v105);
      sub_1CB8E509C(v103, " iterations\n");
      __break(1u);
LABEL_222:
      free((void *)v1);
      continue;
    }
    break;
  }
  if (v134 != v133) {
    free(v134);
  }
  sub_1CD456CB4(v107);
  sub_1CD456CB4(v112);
  if (v120 != v122) {
    free(v120);
  }
  uint64_t result = *v104;
  if (*v104) {
    return sub_1CD84B62C(result);
  }
  return result;
}

uint64_t llvm::Attributor::updateAA(llvm::Attributor *this, llvm::AbstractAttribute *a2)
{
  v28[25] = *MEMORY[0x1E4F143B8];
  BOOL v4 = (void *)((char *)a2 + 16);
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)a2 + 72))(v24, a2);
  int v5 = sub_1CD647DEC(v4);
  std::to_string(&v23, v5);
  if (v25 >= 0) {
    unint64_t v6 = v24;
  }
  else {
    unint64_t v6 = (void **)v24[0];
  }
  if (v25 >= 0) {
    std::string::size_type v7 = v25 & 0x7F;
  }
  else {
    std::string::size_type v7 = (std::string::size_type)v24[1];
  }
  uint64_t v8 = std::string::insert(&v23, 0, (const std::string::value_type *)v6, v7);
  std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v26.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v26.__r_.__value_.__r.__words[2] = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  unint64_t v10 = std::string::append(&v26, "::updateAA");
  std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v28[0] = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v14 = (uint64_t *)off_1EC7DFC00();
  if (*v14)
  {
    if (v13 >= 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    uint64_t v16 = (void *)(v12 & 0x7F);
    if (v13 >= 0) {
      unint64_t v17 = v16;
    }
    else {
      unint64_t v17 = __p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v15, (uint64_t)v17, (uint64_t)"", 0);
    LOBYTE(v13) = HIBYTE(v28[0]);
  }
  if ((v13 & 0x80) != 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (v25 < 0) {
    operator delete(v24[0]);
  }
  __p[0] = v28;
  __p[1] = (void *)0x800000000;
  unsigned int v18 = *((_DWORD *)this + 68);
  if (v18 >= *((_DWORD *)this + 69)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)this + 33) + 8 * v18) = __p;
  ++*((_DWORD *)this + 68);
  uint64_t v19 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)a2 + 40))(a2);
  uint64_t v20 = 1;
  if ((llvm::Attributor::isAssumedDead((uint64_t)this, (uint64_t)a2, 0, &v26, 1, 1) & 1) == 0)
  {
    uint64_t v21 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)a2 + 40))(a2);
    if (((*(uint64_t (**)(uint64_t))(*(void *)v21 + 24))(v21) & 1) == 0) {
      uint64_t v20 = (*(uint64_t (**)(llvm::AbstractAttribute *, llvm::Attributor *))(*(void *)a2 + 104))(a2, this);
    }
  }
  if (((*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)a2 + 32))(a2) & 1) == 0 && !LODWORD(__p[1])) {
    (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v19 + 24))(v19) & 1) == 0) {
    llvm::Attributor::rememberDependences((unint64_t *)this);
  }
  --*((_DWORD *)this + 68);
  if (__p[0] != v28) {
    free(__p[0]);
  }
  if (*v14) {
    sub_1CD84B62C(*v14);
  }
  return v20;
}

uint64_t llvm::Attributor::manifestAttributes(llvm::Attributor *this)
{
  uint64_t isAssumedDead = off_1EC7DFC00();
  unsigned int v3 = (uint64_t *)isAssumedDead;
  if (*(void *)isAssumedDead) {
    llvm::timeTraceProfilerBegin((uint64_t)"Attributor::manifestAttributes", 30, (uint64_t)"", 0);
  }
  int v5 = (unint64_t *)((char *)this + 104);
  unint64_t v4 = *((void *)this + 13);
  if (v4 >= 4)
  {
    unint64_t v7 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v4 & 2) != 0 && v7 || (v4 & 2) != 0)
    {
      unsigned int v6 = *(_DWORD *)(v7 + 8);
      goto LABEL_12;
    }
    unsigned int v6 = 1;
LABEL_10:
    uint64_t v8 = (uint64_t)&v5[v4 > 3];
    std::string::size_type v9 = (void *)((char *)this + 104);
    goto LABEL_13;
  }
  unsigned int v6 = 0;
  if ((v4 & 2) == 0) {
    goto LABEL_10;
  }
  unint64_t v7 = 0;
LABEL_12:
  std::string::size_type v9 = *(void **)v7;
  uint64_t v8 = *(void *)v7 + 8 * *(unsigned int *)(v7 + 8);
LABEL_13:
  uint64_t v10 = 1;
  if (v9 != (void *)v8)
  {
    do
    {
      unint64_t v11 = *v9 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v12 = (*(uint64_t (**)(unint64_t))(*(void *)v11 + 40))(v11);
      uint64_t isAssumedDead = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 24))(v12);
      if ((isAssumedDead & 1) == 0) {
        uint64_t isAssumedDead = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 32))(v12);
      }
      if (!*(void *)(v11 + 24))
      {
        uint64_t isAssumedDead = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
        if (isAssumedDead)
        {
          if (!sub_1CC8AB830((_DWORD *)(v11 + 16))
            || (v13 = sub_1CD6482A0((_DWORD *)(v11 + 16)), uint64_t v14 = (uint64_t *)*((void *)this + 10), v14[3] == v14[4])
            || (uint64_t v29 = 0, v30 = v13, isAssumedDead = sub_1CD420258(v14, &v30, &v29), isAssumedDead))
          {
            uint64_t isAssumedDead = llvm::Attributor::isAssumedDead((uint64_t)this, v11, 0, &v30, 1, 1);
            if ((isAssumedDead & 1) == 0)
            {
              uint64_t isAssumedDead = (*(uint64_t (**)(unint64_t, llvm::Attributor *))(*(void *)v11 + 88))(v11, this);
              unsigned int v15 = isAssumedDead;
              if (!isAssumedDead && ((byte_1EBD0C080 & 1) != 0 || byte_1EA61F098)) {
                uint64_t isAssumedDead = (*(uint64_t (**)(unint64_t))(*(void *)v11 + 96))(v11);
              }
              if (v10) {
                uint64_t v10 = v15;
              }
              else {
                uint64_t v10 = 0;
              }
            }
          }
        }
      }
      ++v9;
    }
    while (v9 != (void *)v8);
    unint64_t v4 = *v5;
  }
  if (v4 >= 4)
  {
    unint64_t v17 = v4 & 0xFFFFFFFFFFFFFFFCLL;
    if ((v4 & 2) != 0 && v17 || (v4 & 2) != 0) {
      int v16 = *(_DWORD *)(v17 + 8);
    }
    else {
      int v16 = 1;
    }
  }
  else
  {
    int v16 = 0;
  }
  if (v6 != v16)
  {
    uint64_t v19 = v6;
    qmemcpy(v28, "ract attribute: Unexpected abstr", sizeof(v28));
    while (1)
    {
      uint64_t v20 = (llvm::raw_ostream *)llvm::errs((llvm *)isAssumedDead);
      uint64_t v21 = v20;
      unint64_t v22 = (_OWORD *)*((void *)v20 + 4);
      if (*((void *)v20 + 3) - (void)v22 > 0x1EuLL)
      {
        *unint64_t v22 = v28[1];
        *(_OWORD *)((char *)v22 + 15) = v28[0];
        *((void *)v20 + 4) += 31;
      }
      else
      {
        llvm::raw_ostream::write(v20, "Unexpected abstract attribute: ", 0x1FuLL);
      }
      unint64_t v23 = *v5 & 0xFFFFFFFFFFFFFFFCLL;
      if ((*v5 & 2) != 0) {
        unint64_t v23 = *(void *)(*(void *)v23 + 8 * v19);
      }
      llvm::write_hex(v21, v23 & 0xFFFFFFFFFFFFFFF8, 3, 0, 0);
      uint64_t v24 = (_DWORD *)*((void *)v21 + 4);
      if (*((void *)v21 + 3) - (void)v24 > 3uLL)
      {
        *uint64_t v24 = 540686880;
        *((void *)v21 + 4) += 4;
      }
      else
      {
        llvm::raw_ostream::write(v21, " :: ", 4uLL);
      }
      unint64_t v25 = *v5 & 0xFFFFFFFFFFFFFFFCLL;
      if ((*v5 & 2) != 0) {
        unint64_t v25 = *(void *)(*(void *)v25 + 8 * v19);
      }
      std::string v26 = (llvm::Value *)sub_1CD6482F0((llvm::IRPosition *)((v25 & 0xFFFFFFFFFFFFFFF8) + 16));
      llvm::Value::print(v26, v21, 0);
      uint64_t v27 = (unsigned char *)*((void *)v21 + 4);
      if (*((unsigned char **)v21 + 3) == v27)
      {
        uint64_t isAssumedDead = (uint64_t)llvm::raw_ostream::write(v21, "\n", 1uLL);
      }
      else
      {
        *uint64_t v27 = 10;
        ++*((void *)v21 + 4);
      }
      ++v19;
    }
  }
  if (*v3) {
    sub_1CD84B62C(*v3);
  }
  return v10;
}

BOOL sub_1CC8AEA28(uint64_t a1, uint64_t *a2)
{
  sub_1CC8B4B6C(a1, a2, (uint64_t)v8);
  int v4 = v9;
  if (v9)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 80);
    if (v6 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 72) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 80);
  }
  return v4 != 0;
}

uint64_t llvm::Attributor::cleanupIR(llvm::Attributor *this)
{
  v197[96] = *MEMORY[0x1E4F143B8];
  v181 = (uint64_t *)off_1EC7DFC00();
  if (*v181) {
    llvm::timeTraceProfilerBegin((uint64_t)"Attributor::cleanupIR", 21, (uint64_t)"", 0);
  }
  v195 = (char *)v197;
  uint64_t v196 = 0x2000000000;
  v192 = v194;
  uint64_t v193 = 0x2000000000;
  v182[0] = (uint64_t)this;
  v182[1] = (uint64_t)&v195;
  v182[2] = (uint64_t)&v192;
  uint64_t v4 = *((unsigned int *)this + 240);
  if (v4)
  {
    uint64_t v5 = (unint64_t *)*((void *)this + 119);
    unsigned int v6 = &v5[2 * v4];
    do
    {
      unint64_t v7 = *v5;
      uint64_t v8 = v5[1];
      v5 += 2;
      sub_1CC8AFBAC(v182, v7, v8);
    }
    while (v5 != v6);
  }
  v189 = v191;
  uint64_t v190 = 0x400000000;
  unsigned int v9 = *((_DWORD *)this + 502);
  if (v9)
  {
    uint64_t v10 = (uint64_t *)*((void *)this + 250);
    unint64_t v11 = &v10[3 * v9];
    do
    {
      uint64_t v12 = *v10;
      uint64_t v13 = v10[1];
      LODWORD(v190) = 0;
      uint64_t v14 = *(void *)(v12 + 8);
      if (v14)
      {
        do
        {
          if (*((unsigned char *)v10 + 16) || (uint64_t v15 = *(void *)(v14 + 24), !sub_1CBF698E4(v15)) && !sub_1CC27D470(v15))
          {
            if (v190 >= (unint64_t)HIDWORD(v190)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v189 + v190) = v14;
            LODWORD(v190) = v190 + 1;
          }
          uint64_t v14 = *(void *)(v14 + 8);
        }
        while (v14);
        if (v190)
        {
          int v16 = (unint64_t *)v189;
          uint64_t v17 = 8 * v190;
          do
          {
            unint64_t v18 = *v16++;
            sub_1CC8AFBAC(v182, v18, v13);
            v17 -= 8;
          }
          while (v17);
        }
      }
      v10 += 3;
    }
    while (v10 != v11);
  }
  unsigned int v19 = *((_DWORD *)this + 994);
  if (v19)
  {
    uint64_t v31 = *((void *)this + 496);
    uint64_t v32 = v31 + 24 * v19;
    do
    {
      uint64_t v33 = *(void *)(v31 + 16);
      if (!v33 || *(unsigned char *)(v33 + 16) != 33) {
        goto LABEL_37;
      }
      uint64_t v34 = *(void *)(v33 + 64);
      if (v34 && (*(unsigned char *)(v34 + 16) & 0x20) != 0)
      {
        char hasFnAttrOnCalledFunction = 1;
      }
      else
      {
        char hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction(*(void *)(v31 + 16), 37);
        uint64_t v34 = *(void *)(v33 + 64);
        if (!v34) {
          goto LABEL_43;
        }
      }
      if ((*(unsigned char *)(v34 + 16) & 1) == 0)
      {
LABEL_43:
        int v36 = llvm::CallBase::hasFnAttrOnCalledFunction(v33, 32);
        goto LABEL_44;
      }
      int v36 = 1;
LABEL_44:
      uint64_t v37 = *(void **)(v33 + 40);
      unsigned int v38 = (llvm *)v37[7];
      if ((*((_WORD *)v38 + 9) & 8) == 0)
      {
        if (hasFnAttrOnCalledFunction) {
          goto LABEL_46;
        }
        uint64_t v40 = *(void *)(v33 - 96);
LABEL_69:
        if (!llvm::BasicBlock::getUniquePredecessor((llvm::BasicBlock *)v40))
        {
          v184 = v37;
          uint64_t v40 = sub_1CD1271B8((uint64_t **)v40, (int)&v184, 1, ".dead", 0, 0, 0, 0, 0);
        }
        uint64_t v55 = *(void *)(v40 + 48);
        if (v55) {
          uint64_t v56 = v55 - 24;
        }
        else {
          uint64_t v56 = 0;
        }
        v184 = (void *)4;
        uint64_t v185 = 0;
        v186[0] = v56;
        if (v56 != -8192 && v56 != -4096 && v56 != 0) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v184);
        }
        sub_1CD64A470((uint64_t)this + 2784, (uint64_t *)&v184);
        if (v186[0] == -8192 || v186[0] == -4096 || !v186[0]) {
          goto LABEL_37;
        }
        unint64_t v43 = (unint64_t)v184 & 0xFFFFFFFFFFFFFFF8;
        *(void *)((unint64_t)v184 & 0xFFFFFFFFFFFFFFF8) = v185;
        uint64_t v44 = (void *)v185;
        if (v185)
        {
LABEL_93:
          *uint64_t v44 = *v44 & 7 | v43;
          goto LABEL_37;
        }
        uint64_t v45 = v186[0];
        unint64_t v46 = ***(int32x2_t ****)v186[0];
        unint64_t v47 = (unint64_t)v46[303];
        if (v47 > v43) {
          goto LABEL_37;
        }
        uint64_t v58 = v46[305].u32[0];
        if (v47 + 16 * v58 <= v43) {
          goto LABEL_37;
        }
        unsigned int v59 = v58 - 1;
        LODWORD(v50) = v59 & ((LODWORD(v186[0]) >> 4) ^ (LODWORD(v186[0]) >> 9));
        uint64_t v51 = (uint64_t *)(v47 + 16 * v50);
        uint64_t v60 = *v51;
        if (v186[0] == *v51) {
          goto LABEL_91;
        }
        int v61 = 1;
        while (v60 != -4096)
        {
          int v62 = v50 + v61++;
          uint64_t v50 = v62 & v59;
          uint64_t v60 = *(void *)(v47 + 16 * v50);
          if (v186[0] == v60) {
            goto LABEL_90;
          }
        }
        goto LABEL_92;
      }
      BOOL v39 = llvm::canSimplifyInvokeNoUnwind(v38, v2);
      uint64_t v37 = *(void **)(v33 + 40);
      uint64_t v40 = *(void *)(v33 - 96);
      if ((hasFnAttrOnCalledFunction & 1) == 0) {
        goto LABEL_69;
      }
      uint64_t v41 = *(void *)(v40 + 48);
      if (v41) {
        uint64_t v42 = v41 - 24;
      }
      else {
        uint64_t v42 = 0;
      }
      if (v39) {
LABEL_46:
      }
        llvm::changeToCall((llvm::BasicBlock **)v33, 0, v3);
      if (v36)
      {
        v184 = (void *)4;
        uint64_t v185 = 0;
        v186[0] = v42;
        if (v42 != -8192 && v42 != -4096 && v42) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v184);
        }
        sub_1CD64A470((uint64_t)this + 2784, (uint64_t *)&v184);
        if (v186[0] != -8192 && v186[0] != -4096 && v186[0])
        {
          unint64_t v43 = (unint64_t)v184 & 0xFFFFFFFFFFFFFFF8;
          *(void *)((unint64_t)v184 & 0xFFFFFFFFFFFFFFF8) = v185;
          uint64_t v44 = (void *)v185;
          if (v185) {
            goto LABEL_93;
          }
          uint64_t v45 = v186[0];
          unint64_t v46 = ***(int32x2_t ****)v186[0];
          unint64_t v47 = (unint64_t)v46[303];
          if (v47 > v43) {
            goto LABEL_37;
          }
          uint64_t v48 = v46[305].u32[0];
          if (v47 + 16 * v48 <= v43) {
            goto LABEL_37;
          }
          unsigned int v49 = v48 - 1;
          LODWORD(v50) = v49 & ((LODWORD(v186[0]) >> 4) ^ (LODWORD(v186[0]) >> 9));
          uint64_t v51 = (uint64_t *)(v47 + 16 * v50);
          uint64_t v52 = *v51;
          if (v186[0] != *v51)
          {
            int v53 = 1;
            while (v52 != -4096)
            {
              int v54 = v50 + v53++;
              uint64_t v50 = v54 & v49;
              uint64_t v52 = *(void *)(v47 + 16 * v50);
              if (v186[0] == v52)
              {
LABEL_90:
                uint64_t v51 = (uint64_t *)(v47 + 16 * v50);
                goto LABEL_91;
              }
            }
            goto LABEL_92;
          }
LABEL_91:
          *uint64_t v51 = -8192;
          v46[304] = vadd_s32(v46[304], (int32x2_t)0x1FFFFFFFFLL);
          uint64_t v45 = v186[0];
LABEL_92:
          *(unsigned char *)(v45 + 17) &= ~1u;
        }
      }
LABEL_37:
      v31 += 24;
    }
    while (v31 != v32);
  }
  if (v193)
  {
    uint64_t v20 = (uint64_t *)v192;
    uint64_t v21 = 8 * v193;
    do
    {
      uint64_t v22 = *v20++;
      v184 = *(void **)(*(void *)(v22 + 40) + 56);
      sub_1CC8AEA28((uint64_t)this + 112, (uint64_t *)&v184);
      llvm::ConstantFoldTerminator(*(llvm::BasicBlock **)(v22 + 40), 0, 0, 0);
      v21 -= 8;
    }
    while (v21);
  }
  uint64_t v23 = *((unsigned int *)this + 796);
  if (v23)
  {
    uint64_t v24 = 24 * v23;
    unint64_t v25 = (uint64_t *)(*((void *)this + 397) + 16);
    do
    {
      uint64_t v26 = *v25;
      if (*v25 && *(unsigned __int8 *)(v26 + 16) >= 0x1Cu)
      {
        v184 = *(void **)(*(void *)(v26 + 40) + 56);
        sub_1CC8AEA28((uint64_t)this + 112, (uint64_t *)&v184);
        llvm::changeToUnreachable((llvm *)v26, 0, 0, 0, v27);
      }
      v25 += 3;
      v24 -= 24;
    }
    while (v24);
  }
  unsigned int v28 = *((_DWORD *)this + 1246);
  if (v28)
  {
    uint64_t v63 = *((void *)this + 622);
    uint64_t v64 = v63 + 24 * v28;
    while (1)
    {
      uint64_t v65 = *(void *)(v63 + 16);
      if (v65)
      {
        unsigned int v66 = *(unsigned __int8 *)(v65 + 16);
        if (v66 >= 0x1C) {
          break;
        }
      }
LABEL_113:
      v63 += 24;
      if (v63 == v64) {
        goto LABEL_32;
      }
    }
    if (v66 == 84)
    {
      uint64_t v67 = *(void *)(v65 - 32);
      if (!v67
        || *(unsigned char *)(v67 + 16)
        || *(void *)(v67 + 24) != *(void *)(v65 + 72)
        || (*(unsigned char *)(v67 + 33) & 0x20) == 0)
      {
        goto LABEL_107;
      }
    }
    else if (v66 == 33 || v66 == 39)
    {
LABEL_107:
      llvm::CallGraphUpdater::removeCallSite(*((llvm::CallGraphUpdater **)this + 684), *(llvm::CallBase **)(v63 + 16));
    }
    llvm::Value::dropDroppableUses(v65, (unsigned int (*)(uint64_t, uint64_t))sub_1CD6515AC, (uint64_t)&v184);
    v184 = *(void **)(*(void *)(v65 + 40) + 56);
    sub_1CC8AEA28((uint64_t)this + 112, (uint64_t *)&v184);
    if (*(unsigned char *)(*(void *)v65 + 8) != 7)
    {
      uint64_t v69 = llvm::UndefValue::get(*(llvm::UndefValue **)v65, v68);
      llvm::Value::doRAUW((llvm::ValueAsMetadata *)v65, v69, (llvm::Value *)1);
    }
    if (*(unsigned char *)(v65 + 16) == 83
      || *(void *)(v65 + 8)
      || !llvm::wouldInstructionBeTriviallyDead(v65, 0))
    {
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    v184 = (void *)6;
    uint64_t v185 = 0;
    v186[0] = v65;
    if (v65 != -8192 && v65 != -4096) {
      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v184);
    }
    int v70 = v195;
    if (v196 >= HIDWORD(v196))
    {
      unint64_t v88 = v196 + 1;
      if (v195 <= (char *)&v184 && &v195[24 * v196] > (char *)&v184)
      {
        uint64_t v89 = (char *)&v184 - v195;
        sub_1CC261F80((unsigned int *)&v195, v88);
        int v70 = v195;
        long long v71 = (void **)&v195[v89];
      }
      else
      {
        sub_1CC261F80((unsigned int *)&v195, v88);
        long long v71 = &v184;
        int v70 = v195;
      }
    }
    else
    {
      long long v71 = &v184;
    }
    int v72 = v196;
    long long v73 = (unint64_t *)&v70[24 * v196];
    *long long v73 = 6;
    v73[1] = 0;
    uint64_t v74 = v71[2];
    v73[2] = (unint64_t)v74;
    if (v74 != (void *)-8192 && v74 != (void *)-4096)
    {
      if (v74)
      {
        unint64_t v75 = (unint64_t)*v71 & 0xFFFFFFFFFFFFFFF8;
        v73[1] = *(void *)v75;
        *(void *)unint64_t v75 = v73;
        *long long v73 = v75 | 6;
        unint64_t v76 = (unint64_t *)v73[1];
        if (v76) {
          *unint64_t v76 = *v76 & 7 | (unint64_t)(v73 + 1);
        }
      }
    }
    LODWORD(v196) = v72 + 1;
    if (v186[0] != -8192 && v186[0] != -4096 && v186[0])
    {
      unint64_t v77 = (unint64_t)v184 & 0xFFFFFFFFFFFFFFF8;
      *(void *)((unint64_t)v184 & 0xFFFFFFFFFFFFFFF8) = v185;
      if (v185)
      {
        *(void *)uint64_t v185 = *(void *)v185 & 7 | v77;
      }
      else
      {
        uint64_t v78 = v186[0];
        BOOL v79 = ***(int32x2_t ****)v186[0];
        unint64_t v80 = (unint64_t)v79[303];
        if (v80 <= v77)
        {
          uint64_t v81 = v79[305].u32[0];
          if (v80 + 16 * v81 > v77)
          {
            unsigned int v82 = v81 - 1;
            LODWORD(v83) = v82 & ((LODWORD(v186[0]) >> 4) ^ (LODWORD(v186[0]) >> 9));
            uint64_t v84 = (uint64_t *)(v80 + 16 * v83);
            uint64_t v85 = *v84;
            if (v186[0] == *v84)
            {
LABEL_137:
              *uint64_t v84 = -8192;
              v79[304] = vadd_s32(v79[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v78 = v186[0];
            }
            else
            {
              int v86 = 1;
              while (v85 != -4096)
              {
                int v87 = v83 + v86++;
                uint64_t v83 = v87 & v82;
                uint64_t v85 = *(void *)(v80 + 16 * v83);
                if (v186[0] == v85)
                {
                  uint64_t v84 = (uint64_t *)(v80 + 16 * v83);
                  goto LABEL_137;
                }
              }
            }
            *(unsigned char *)(v78 + 17) &= ~1u;
          }
        }
      }
    }
    goto LABEL_113;
  }
LABEL_32:
  uint64_t v29 = v195;
  int v30 = v196;
  if (!v196) {
    goto LABEL_169;
  }
  long long v90 = &v195[24 * v196];
  do
  {
    uint64_t v91 = 0;
    v184 = (void *)6;
    uint64_t v185 = 0;
    uint64_t v92 = *((void *)v29 + 2);
    v186[0] = v92;
    if (v92 != -8192 && v92 != -4096 && v92 != 0)
    {
      unint64_t v94 = *(void *)v29 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v185 = *(void *)v94;
      *(void *)unint64_t v94 = &v184;
      v184 = (void *)(v94 | 6);
      uint64_t v91 = v185;
      if (v185) {
        *(void *)uint64_t v185 = *(void *)v185 & 7 | (unint64_t)&v185;
      }
      uint64_t v92 = v186[0];
    }
    if (v92 == -8192 || v92 == -4096) {
      goto LABEL_167;
    }
    if (!v92)
    {
      uint64_t v129 = v29 + 24;
      if (v29 + 24 == v90) {
        goto LABEL_169;
      }
      long long v106 = (unint64_t *)v29;
      while (1)
      {
        uint64_t v130 = 0;
        uint64_t v131 = v129;
        v184 = (void *)6;
        uint64_t v185 = 0;
        uint64_t v132 = *((void *)v29 + 5);
        v186[0] = v132;
        if (v132 != -8192 && v132 != -4096 && v132 != 0)
        {
          unint64_t v134 = *(void *)v131 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v185 = *(void *)v134;
          *(void *)unint64_t v134 = &v184;
          v184 = (void *)(v134 | 6);
          uint64_t v130 = v185;
          if (v185) {
            *(void *)uint64_t v185 = *(void *)v185 & 7 | (unint64_t)&v185;
          }
          uint64_t v132 = v186[0];
        }
        if (v132 == -8192 || v132 == -4096) {
          goto LABEL_227;
        }
        if (v132) {
          break;
        }
LABEL_241:
        uint64_t v129 = v131 + 24;
        uint64_t v29 = v131;
        if (v131 + 24 == v90) {
          goto LABEL_170;
        }
      }
      unint64_t v135 = (unint64_t)v184 & 0xFFFFFFFFFFFFFFF8;
      *(void *)((unint64_t)v184 & 0xFFFFFFFFFFFFFFF8) = v130;
      if (v185)
      {
        *(void *)uint64_t v185 = *(void *)v185 & 7 | v135;
      }
      else
      {
        uint64_t v136 = v186[0];
        v137 = ***(int32x2_t ****)v186[0];
        unint64_t v138 = (unint64_t)v137[303];
        if (v138 <= v135)
        {
          uint64_t v139 = v137[305].u32[0];
          if (v138 + 16 * v139 > v135)
          {
            unsigned int v140 = v139 - 1;
            LODWORD(v141) = v140 & ((LODWORD(v186[0]) >> 4) ^ (LODWORD(v186[0]) >> 9));
            v142 = (uint64_t *)(v138 + 16 * v141);
            uint64_t v143 = *v142;
            if (v186[0] == *v142)
            {
LABEL_224:
              uint64_t *v142 = -8192;
              v137[304] = vadd_s32(v137[304], (int32x2_t)0x1FFFFFFFFLL);
              uint64_t v136 = v186[0];
            }
            else
            {
              int v144 = 1;
              while (v143 != -4096)
              {
                int v145 = v141 + v144++;
                uint64_t v141 = v145 & v140;
                uint64_t v143 = *(void *)(v138 + 16 * v141);
                if (v186[0] == v143)
                {
                  v142 = (uint64_t *)(v138 + 16 * v141);
                  goto LABEL_224;
                }
              }
            }
            *(unsigned char *)(v136 + 17) &= ~1u;
          }
        }
      }
LABEL_227:
      unint64_t v146 = v106[2];
      unint64_t v147 = *((void *)v29 + 5);
      if (v146 != v147)
      {
        BOOL v148 = v146 == -4096 || v146 == 0;
        if (!v148 && v146 != -8192)
        {
          unint64_t v153 = *v106 & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v153 = v106[1];
          v154 = (unint64_t *)v106[1];
          if (v154)
          {
            unint64_t *v154 = *v154 & 7 | v153;
          }
          else
          {
            unint64_t v155 = v106[2];
            v156 = ***(int32x2_t ****)v155;
            unint64_t v157 = (unint64_t)v156[303];
            if (v157 <= v153)
            {
              uint64_t v158 = v156[305].u32[0];
              if (v157 + 16 * v158 > v153)
              {
                unsigned int v159 = v158 - 1;
                LODWORD(v160) = v159 & ((v155 >> 4) ^ (v155 >> 9));
                v161 = (uint64_t *)(v157 + 16 * v160);
                uint64_t v162 = *v161;
                if (v155 == *v161)
                {
LABEL_252:
                  uint64_t *v161 = -8192;
                  v156[304] = vadd_s32(v156[304], (int32x2_t)0x1FFFFFFFFLL);
                  unint64_t v155 = v106[2];
                }
                else
                {
                  int v163 = 1;
                  while (v162 != -4096)
                  {
                    int v164 = v160 + v163++;
                    uint64_t v160 = v164 & v159;
                    uint64_t v162 = *(void *)(v157 + 16 * v160);
                    if (v155 == v162)
                    {
                      v161 = (uint64_t *)(v157 + 16 * v160);
                      goto LABEL_252;
                    }
                  }
                }
                *(unsigned char *)(v155 + 17) &= ~1u;
              }
            }
          }
          unint64_t v147 = *((void *)v29 + 5);
        }
        v106[2] = v147;
        if (v147 != -4096 && v147 != -8192 && v147 != 0)
        {
          uint64_t v150 = *(void *)v131;
          v151 = (unint64_t *)(*(void *)v131 & 0xFFFFFFFFFFFFFFF8);
          v106[1] = *v151;
          unint64_t *v151 = (unint64_t)v106;
          *long long v106 = v150 & 0xFFFFFFFFFFFFFFF8 | *v106 & 7;
          v152 = (unint64_t *)v106[1];
          if (v152) {
            unint64_t *v152 = *v152 & 7 | (unint64_t)(v106 + 1);
          }
        }
      }
      v106 += 3;
      goto LABEL_241;
    }
    unint64_t v95 = (unint64_t)v184 & 0xFFFFFFFFFFFFFFF8;
    *(void *)((unint64_t)v184 & 0xFFFFFFFFFFFFFFF8) = v91;
    if (v185)
    {
      *(void *)uint64_t v185 = *(void *)v185 & 7 | v95;
    }
    else
    {
      uint64_t v96 = v186[0];
      unint64_t v97 = ***(int32x2_t ****)v186[0];
      unint64_t v98 = (unint64_t)v97[303];
      if (v98 <= v95)
      {
        uint64_t v99 = v97[305].u32[0];
        if (v98 + 16 * v99 > v95)
        {
          unsigned int v100 = v99 - 1;
          LODWORD(v101) = v100 & ((LODWORD(v186[0]) >> 4) ^ (LODWORD(v186[0]) >> 9));
          uint64_t v102 = (uint64_t *)(v98 + 16 * v101);
          uint64_t v103 = *v102;
          if (v186[0] == *v102)
          {
LABEL_164:
            *uint64_t v102 = -8192;
            v97[304] = vadd_s32(v97[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v96 = v186[0];
          }
          else
          {
            int v104 = 1;
            while (v103 != -4096)
            {
              int v105 = v101 + v104++;
              uint64_t v101 = v105 & v100;
              uint64_t v103 = *(void *)(v98 + 16 * v101);
              if (v186[0] == v103)
              {
                uint64_t v102 = (uint64_t *)(v98 + 16 * v101);
                goto LABEL_164;
              }
            }
          }
          *(unsigned char *)(v96 + 17) &= ~1u;
        }
      }
    }
LABEL_167:
    v29 += 24;
  }
  while (v29 != v90);
  uint64_t v29 = v90;
LABEL_169:
  long long v106 = (unint64_t *)v29;
LABEL_170:
  sub_1CD6515B4((uint64_t *)&v195, v106, (uint64_t *)&v195[24 * v30]);
  v188 = 0;
  llvm::RecursivelyDeleteTriviallyDeadInstructions((unsigned int *)&v195, 0, 0, (uint64_t)v187);
  if (v188 == v187)
  {
    (*(void (**)(void *))(v187[0] + 32))(v187);
  }
  else if (v188)
  {
    (*(void (**)(void))(*v188 + 40))();
  }
  uint64_t v107 = *((unsigned int *)this + 1176);
  if (v107)
  {
    v184 = v186;
    uint64_t v185 = 0x800000000;
    if (v107 > 8) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    long long v127 = (uint64_t *)*((void *)this + 587);
    long long v128 = &v127[v107];
    do
    {
      uint64_t v165 = *v127;
      uint64_t v183 = *(void *)(*v127 + 56);
      sub_1CC8AEA28((uint64_t)this + 112, &v183);
      uint64_t v166 = *((void *)this + 548);
      uint64_t v167 = *((void *)this + 547);
      if (v166 == v167)
      {
        uint64_t v168 = *((unsigned int *)this + 1099);
        v169 = (void *)(v166 + 8 * v168);
        if (v168)
        {
          uint64_t v170 = 0;
          uint64_t v171 = 8 * v168;
          while (*(void *)(v166 + v170) != v165)
          {
            v170 += 8;
            if (v171 == v170) {
              goto LABEL_274;
            }
          }
          v169 = (void *)(v166 + v170);
        }
LABEL_274:
        uint64_t v167 = *((void *)this + 548);
      }
      else
      {
        uint64_t v172 = *((unsigned int *)this + 1098);
        int v173 = v172 - 1;
        unsigned int v174 = (v172 - 1) & ((v165 >> 4) ^ (v165 >> 9));
        v169 = (void *)(v166 + 8 * v174);
        uint64_t v175 = *v169;
        if (*v169 == -1)
        {
          v176 = 0;
LABEL_284:
          if (v176) {
            v169 = v176;
          }
          if (*v169 != v165) {
            v169 = (void *)(v166 + 8 * v172);
          }
        }
        else
        {
          v176 = 0;
          int v177 = 1;
          while (v175 != v165)
          {
            if (v176) {
              BOOL v178 = 0;
            }
            else {
              BOOL v178 = v175 == -2;
            }
            if (v178) {
              v176 = v169;
            }
            unsigned int v179 = v174 + v177++;
            unsigned int v174 = v179 & v173;
            v169 = (void *)(v166 + 8 * (v179 & v173));
            uint64_t v175 = *v169;
            if (*v169 == -1) {
              goto LABEL_284;
            }
          }
        }
      }
      if (v166 == v167) {
        v180 = (char *)this + 4396;
      }
      else {
        v180 = (char *)this + 4392;
      }
      if (v169 == (void *)(v166 + 8 * *(unsigned int *)v180))
      {
        if (v185 >= (unint64_t)HIDWORD(v185)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v184 + v185) = v165;
        LODWORD(v185) = v185 + 1;
      }
      ++v127;
    }
    while (v127 != v128);
    llvm::detachDeadBlocks((uint64_t *)v184, (llvm::Type *)v185, 0, 0);
    if (v184 != v186) {
      free(v184);
    }
  }
  llvm::Attributor::identifyDeadInternalFunctions(this);
  unsigned int v108 = llvm::Attributor::rewriteFunctionSignatures((uint64_t)this, (uint64_t)this + 112);
  uint64_t v109 = *((unsigned int *)this + 48);
  if (v109)
  {
    long long v112 = (void **)*((void *)this + 23);
    uint64_t v113 = 8 * v109;
    do
    {
      long long v114 = *v112;
      uint64_t v183 = 0;
      v184 = v114;
      if ((sub_1CC8B6C50((uint64_t)this + 4472, &v184, &v183) & 1) == 0)
      {
        long long v115 = (uint64_t *)*((void *)this + 10);
        uint64_t v183 = 0;
        v184 = v114;
        if (sub_1CD420258(v115, &v184, &v183)) {
          llvm::CallGraphUpdater::reanalyzeFunction(*((llvm::CallGraphUpdater **)this + 684), (llvm::Function *)v114);
        }
      }
      ++v112;
      v113 -= 8;
    }
    while (v113);
  }
  uint64_t v110 = *((unsigned int *)this + 1138);
  if (v110)
  {
    long long v116 = (void **)*((void *)this + 568);
    uint64_t v117 = 8 * v110;
    do
    {
      long long v118 = *v116;
      char v119 = (uint64_t *)*((void *)this + 10);
      uint64_t v183 = 0;
      v184 = v118;
      if (sub_1CD420258(v119, &v184, &v183)) {
        llvm::CallGraphUpdater::removeFunction(*((llvm::CallGraphUpdater **)this + 684), (llvm::Function *)v118);
      }
      ++v116;
      v117 -= 8;
    }
    while (v117);
    int v111 = *((_DWORD *)this + 1138);
  }
  else
  {
    int v111 = 0;
  }
  int v120 = *((_DWORD *)this + 240);
  int v121 = *((_DWORD *)this + 796);
  int v122 = *((_DWORD *)this + 1176);
  int v123 = *((_DWORD *)this + 1246);
  int v124 = *((_DWORD *)this + 994);
  int v125 = v196;
  if (v189 != v191) {
    free(v189);
  }
  if (v192 != v194) {
    free(v192);
  }
  sub_1CD651528(&v195);
  if (*v181) {
    sub_1CD84B62C(*v181);
  }
  if (v125 | v124 | v123 | v122 | v111 | v121 | v120) {
    return 0;
  }
  else {
    return v108;
  }
}

void sub_1CC8AFBAC(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)a2;
  uint64_t v8 = *a1 + 1480;
  uint64_t v9 = v8;
  for (uint64_t i = a3; ; uint64_t i = v3)
  {
    uint64_t v11 = sub_1CD64E324(v9, i);
    if (!v11) {
      break;
    }
    uint64_t v3 = v11;
    uint64_t v9 = v8;
  }
  uint64_t v12 = *(void *)(a2 + 24);
  unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
  if (v12) {
    BOOL v14 = v13 >= 0x1C;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14)
  {
LABEL_25:
    if (*(void *)a2)
    {
      **(void **)(a2 + 16) = *(void *)(a2 + 8);
      uint64_t v25 = *(void *)(a2 + 8);
      if (v25) {
        *(void *)(v25 + 16) = *(void *)(a2 + 16);
      }
    }
    *(void *)a2 = v3;
    if (v3)
    {
      uint64_t v26 = (unint64_t *)(v3 + 8);
      uint64_t v27 = *(void *)(v3 + 8);
      *(void *)(a2 + 8) = v27;
      if (v27) {
        *(void *)(v27 + 16) = a2 + 8;
      }
      *(void *)(a2 + 16) = v26;
      *uint64_t v26 = a2;
    }
    if (*(unsigned __int8 *)(v7 + 16) >= 0x1Cu && v7 != 0)
    {
      uint64_t v101 = *(void *)(*(void *)(v7 + 40) + 56);
      sub_1CC8AEA28(v6 + 112, &v101);
      if (*(unsigned char *)(v7 + 16) != 83)
      {
        uint64_t v101 = 4;
        uint64_t v102 = 0;
        uint64_t v103 = (int32x2_t ****)v7;
        if (v7 != -8192 && v7 != -4096 && v7) {
          llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v101);
        }
        uint64_t v104 = 0;
        if ((sub_1CD64E38C(v6 + 4776, (uint64_t)&v101, &v104) & 1) != 0 || *(void *)(v7 + 8)) {
          int wouldInstructionBeTriviallyDead = 0;
        }
        else {
          int wouldInstructionBeTriviallyDead = llvm::wouldInstructionBeTriviallyDead(v7, 0);
        }
        if (v103 != (int32x2_t ****)-8192 && v103 != (int32x2_t ****)-4096 && v103)
        {
          unint64_t v43 = v101 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v101 & 0xFFFFFFFFFFFFFFF8) = v102;
          if (v102)
          {
            *uint64_t v102 = *v102 & 7 | v43;
          }
          else
          {
            uint64_t v44 = v103;
            uint64_t v45 = ***v103;
            unint64_t v46 = (unint64_t)v45[303];
            if (v46 <= v43)
            {
              uint64_t v47 = v45[305].u32[0];
              if (v46 + 16 * v47 > v43)
              {
                unsigned int v48 = v47 - 1;
                LODWORD(v49) = v48 & ((v103 >> 4) ^ (v103 >> 9));
                uint64_t v50 = (int32x2_t *****)(v46 + 16 * v49);
                uint64_t v51 = *v50;
                if (v103 == *v50)
                {
LABEL_79:
                  uint64_t *v50 = (int32x2_t ****)-8192;
                  v45[304] = vadd_s32(v45[304], (int32x2_t)0x1FFFFFFFFLL);
                  uint64_t v44 = v103;
                }
                else
                {
                  int v52 = 1;
                  while (v51 != (int32x2_t ****)-4096)
                  {
                    int v53 = v49 + v52++;
                    uint64_t v49 = v53 & v48;
                    uint64_t v51 = *(int32x2_t *****)(v46 + 16 * v49);
                    if (v103 == v51)
                    {
                      uint64_t v50 = (int32x2_t *****)(v46 + 16 * v49);
                      goto LABEL_79;
                    }
                  }
                }
                *((unsigned char *)v44 + 17) &= ~1u;
              }
            }
          }
        }
        if (wouldInstructionBeTriviallyDead)
        {
          unint64_t v77 = (unsigned int *)a1[1];
          uint64_t v101 = 6;
          uint64_t v102 = 0;
          uint64_t v103 = (int32x2_t ****)v7;
          if (v7 != -8192 && v7 != -4096 && v7) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v101);
          }
          uint64_t v78 = v77[2];
          unint64_t v79 = *(void *)v77;
          unint64_t v80 = &v101;
          if (v78 >= v77[3])
          {
            unint64_t v97 = v78 + 1;
            BOOL v98 = v79 + 24 * v78 > (unint64_t)&v101;
            if (v79 <= (unint64_t)&v101 && v98)
            {
              unsigned int v100 = (char *)&v101 - v79;
              sub_1CC261F80(v77, v97);
              unint64_t v79 = *(void *)v77;
              unint64_t v80 = (uint64_t *)&v100[*(void *)v77];
            }
            else
            {
              sub_1CC261F80(v77, v97);
              unint64_t v79 = *(void *)v77;
              unint64_t v80 = &v101;
            }
          }
          unsigned int v81 = v77[2];
          unsigned int v82 = (unint64_t *)(v79 + 24 * v81);
          *unsigned int v82 = 6;
          v82[1] = 0;
          uint64_t v83 = v80[2];
          v82[2] = v83;
          if (v83 != -8192 && v83 != -4096)
          {
            if (v83)
            {
              unint64_t v84 = *v80 & 0xFFFFFFFFFFFFFFF8;
              v82[1] = *(void *)v84;
              *(void *)unint64_t v84 = v82;
              *unsigned int v82 = v84 | 6;
              uint64_t v85 = (unint64_t *)v82[1];
              if (v85) {
                *uint64_t v85 = *v85 & 7 | (unint64_t)(v82 + 1);
              }
            }
          }
          v77[2] = v81 + 1;
          if (v103 != (int32x2_t ****)-8192 && v103 != (int32x2_t ****)-4096 && v103)
          {
            unint64_t v86 = v101 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v101 & 0xFFFFFFFFFFFFFFF8) = v102;
            if (v102)
            {
              *uint64_t v102 = *v102 & 7 | v86;
            }
            else
            {
              int v87 = v103;
              unint64_t v88 = ***v103;
              unint64_t v89 = (unint64_t)v88[303];
              if (v89 <= v86)
              {
                uint64_t v90 = v88[305].u32[0];
                if (v89 + 16 * v90 > v86)
                {
                  unsigned int v91 = v90 - 1;
                  LODWORD(v92) = v91 & ((v103 >> 4) ^ (v103 >> 9));
                  BOOL v93 = (int32x2_t *****)(v89 + 16 * v92);
                  unint64_t v94 = *v93;
                  if (v103 == *v93)
                  {
LABEL_139:
                    *BOOL v93 = (int32x2_t ****)-8192;
                    v88[304] = vadd_s32(v88[304], (int32x2_t)0x1FFFFFFFFLL);
                    int v87 = v103;
                  }
                  else
                  {
                    int v95 = 1;
                    while (v94 != (int32x2_t ****)-4096)
                    {
                      int v96 = v92 + v95++;
                      uint64_t v92 = v96 & v91;
                      unint64_t v94 = *(int32x2_t *****)(v89 + 16 * v92);
                      if (v103 == v94)
                      {
                        BOOL v93 = (int32x2_t *****)(v89 + 16 * v92);
                        goto LABEL_139;
                      }
                    }
                  }
                  *((unsigned char *)v87 + 17) &= ~1u;
                }
              }
            }
          }
        }
      }
    }
    unsigned int v29 = *(unsigned __int8 *)(v3 + 16);
    if (v29 - 11 <= 1)
    {
      uint64_t v30 = *(void *)(a2 + 24);
      unsigned int v31 = *(unsigned __int8 *)(v30 + 16);
      if (v31 >= 0x1C && v31 - 33 <= 0x33 && ((1 << (v31 - 33)) & 0x8000000000041) != 0)
      {
        int v33 = *(_DWORD *)(v30 + 20);
        unint64_t v34 = v30 - 32 * (v33 & 0x7FFFFFF);
        if (v34 <= a2)
        {
          if (v31 == 84) {
            uint64_t v35 = 0;
          }
          else {
            uint64_t v35 = v31 == 39 ? (*(_DWORD *)(v30 + 80) + 1) : 2;
          }
          if (v33 < 0 && (uint64_t v99 = *(void *)(v34 - 8), (v99 & 0xFFFFFFFF0) != 0)) {
            uint64_t v36 = (*(_DWORD *)(v34 - 12) - *(_DWORD *)(v34 - v99));
          }
          else {
            uint64_t v36 = 0;
          }
          if (v30 - 32 * v35 - 32 * v36 - 32 > a2)
          {
            unint64_t v37 = (a2 - v34) >> 5;
            *(void *)(v30 + 64) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v30 + 64), **(uint64_t ***)v30, (int)v37 + 1, 36);
            uint64_t v38 = *(void *)(v30 - 32);
            if (v38)
            {
              if (!*(unsigned char *)(v38 + 16)
                && *(void *)(v38 + 24) == *(void *)(v30 + 72)
                && *(void *)(v38 + 96) > (unint64_t)v37)
              {
                *(void *)(v38 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v38 + 112), **(uint64_t ***)v38, (int)v37 + 1, 36);
              }
            }
          }
        }
      }
      unsigned int v29 = *(unsigned __int8 *)(v3 + 16);
    }
    if (v29 <= 0x14)
    {
      uint64_t v39 = *(void *)(a2 + 24);
      if (*(unsigned char *)(v39 + 16) == 30)
      {
        if (v29 - 11 <= 1)
        {
          uint64_t v101 = 4;
          uint64_t v102 = 0;
          uint64_t v103 = (int32x2_t ****)v39;
          if (v39 != -8192 && v39 != -4096 && v39) {
            llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v101);
          }
          sub_1CD64A470(v6 + 2784, &v101);
          if (v103 != (int32x2_t ****)-8192 && v103 != (int32x2_t ****)-4096 && v103)
          {
            unint64_t v54 = v101 & 0xFFFFFFFFFFFFFFF8;
            *(void *)(v101 & 0xFFFFFFFFFFFFFFF8) = v102;
            if (v102)
            {
              *uint64_t v102 = *v102 & 7 | v54;
            }
            else
            {
              uint64_t v55 = v103;
              uint64_t v56 = ***v103;
              unint64_t v57 = (unint64_t)v56[303];
              if (v57 <= v54)
              {
                uint64_t v58 = v56[305].u32[0];
                if (v57 + 16 * v58 > v54)
                {
                  unsigned int v59 = v58 - 1;
                  LODWORD(v60) = v59 & ((v103 >> 4) ^ (v103 >> 9));
                  int v61 = (int32x2_t *****)(v57 + 16 * v60);
                  int v62 = *v61;
                  if (v103 == *v61)
                  {
LABEL_98:
                    *int v61 = (int32x2_t ****)-8192;
                    v56[304] = vadd_s32(v56[304], (int32x2_t)0x1FFFFFFFFLL);
                    uint64_t v55 = v103;
                  }
                  else
                  {
                    int v63 = 1;
                    while (v62 != (int32x2_t ****)-4096)
                    {
                      int v64 = v60 + v63++;
                      uint64_t v60 = v64 & v59;
                      int v62 = *(int32x2_t *****)(v57 + 16 * v60);
                      if (v103 == v62)
                      {
                        int v61 = (int32x2_t *****)(v57 + 16 * v60);
                        goto LABEL_98;
                      }
                    }
                  }
                  *((unsigned char *)v55 + 17) &= ~1u;
                }
              }
            }
          }
        }
        else
        {
          uint64_t v40 = a1[2];
          unsigned int v41 = *(_DWORD *)(v40 + 8);
          if (v41 >= *(_DWORD *)(v40 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)v40 + 8 * v41) = v39;
          ++*(_DWORD *)(v40 + 8);
        }
      }
    }
    return;
  }
  if (v13 != 29) {
    goto LABEL_20;
  }
  uint64_t v15 = llvm::Value::stripPointerCasts((llvm::Value *)v7);
  if (!v15 || *((unsigned char *)v15 + 16) != 84 || (*((_WORD *)v15 + 9) & 3) != 2) {
    goto LABEL_13;
  }
  uint64_t v101 = 4;
  uint64_t v102 = 0;
  uint64_t v103 = (int32x2_t ****)v15;
  if (v15 != (llvm::Value *)-8192 && v15 != (llvm::Value *)-4096) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v101);
  }
  uint64_t v104 = 0;
  int v65 = sub_1CD64E38C(v6 + 4776, (uint64_t)&v101, &v104);
  if (v103 != (int32x2_t ****)-8192 && v103 != (int32x2_t ****)-4096 && v103)
  {
    unint64_t v66 = v101 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v101 & 0xFFFFFFFFFFFFFFF8) = v102;
    if (v102)
    {
      *uint64_t v102 = *v102 & 7 | v66;
    }
    else
    {
      uint64_t v67 = v103;
      uint64_t v68 = ***v103;
      unint64_t v69 = (unint64_t)v68[303];
      if (v69 <= v66)
      {
        uint64_t v70 = v68[305].u32[0];
        if (v69 + 16 * v70 > v66)
        {
          unsigned int v71 = v70 - 1;
          LODWORD(v72) = v71 & ((v103 >> 4) ^ (v103 >> 9));
          long long v73 = (int32x2_t *****)(v69 + 16 * v72);
          uint64_t v74 = *v73;
          if (v103 == *v73)
          {
LABEL_114:
            *long long v73 = (int32x2_t ****)-8192;
            v68[304] = vadd_s32(v68[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v67 = v103;
          }
          else
          {
            int v75 = 1;
            while (v74 != (int32x2_t ****)-4096)
            {
              int v76 = v72 + v75++;
              uint64_t v72 = v76 & v71;
              uint64_t v74 = *(int32x2_t *****)(v69 + 16 * v72);
              if (v103 == v74)
              {
                long long v73 = (int32x2_t *****)(v69 + 16 * v72);
                goto LABEL_114;
              }
            }
          }
          *((unsigned char *)v67 + 17) &= ~1u;
        }
      }
    }
  }
  if (v65)
  {
LABEL_13:
    if (*(unsigned char *)(v3 + 16) != 21)
    {
      uint64_t v16 = *(void *)(*(void *)(v12 + 40) + 56);
      if (*(_WORD *)(v16 + 18))
      {
        llvm::Function::BuildLazyArguments(*(llvm::Function **)(*(void *)(v12 + 40) + 56));
        uint64_t v17 = *(void *)(v16 + 88);
        if (*(_WORD *)(v16 + 18))
        {
          llvm::Function::BuildLazyArguments((llvm::Function *)v16);
          uint64_t v18 = *(void *)(v16 + 88);
LABEL_17:
          uint64_t v19 = v18 + 40 * *(void *)(v16 + 96);
          while (v17 != v19)
          {
            uint64_t v20 = *(void *)(v17 + 24);
            *(void *)(v20 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v20 + 112), **(uint64_t ***)v20, *(_DWORD *)(v17 + 32) + 1, 46);
            v17 += 40;
          }
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v17 = *(void *)(v16 + 88);
      }
      uint64_t v18 = v17;
      goto LABEL_17;
    }
LABEL_20:
    unsigned int v21 = *(unsigned __int8 *)(v12 + 16) - 33;
    BOOL v22 = v21 > 0x33;
    uint64_t v23 = (1 << v21) & 0x8000000000041;
    BOOL v24 = v22 || v23 == 0;
    if (!v24 && v12 - 32 == a2) {
      return;
    }
    goto LABEL_25;
  }
}

uint64_t llvm::Attributor::rewriteFunctionSignatures(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  v111[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 56);
  unsigned int v5 = *(_DWORD *)(a1 + 72);
  uint64_t v6 = v4 + 88 * v5;
  if (*(_DWORD *)(a1 + 64))
  {
    if (v5)
    {
      uint64_t v7 = 88 * v5;
      uint64_t v8 = *(void *)(a1 + 56);
      while ((*(void *)v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 88;
        v7 -= 88;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 56);
    }
  }
  else
  {
LABEL_6:
    uint64_t v8 = v4 + 88 * v5;
  }
  uint64_t v9 = v4 + 88 * v5;
  if (v8 != v9)
  {
    uint64_t v10 = a1 + 4472;
    uint64_t v11 = (llvm::Function *)v111;
    uint64_t v12 = &v108;
    uint64_t v13 = 1;
    while (1)
    {
      BOOL v98 = 0;
      BOOL v98 = *(llvm::Function **)v8;
      BOOL v14 = *(uint64_t **)(v3 + 80);
      uint64_t v109 = v98;
      long long v106 = 0;
      if (sub_1CD420258(v14, &v109, &v106))
      {
        uint64_t v109 = v98;
        long long v106 = 0;
        if ((sub_1CC8B6C50(v10, &v109, &v106) & 1) == 0) {
          break;
        }
      }
LABEL_12:
      uint64_t v15 = v8 + 88;
      uint64_t v8 = v6;
      if (v15 != v6)
      {
        uint64_t v8 = v15;
        while ((*(void *)v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v8 += 88;
          if (v8 == v6)
          {
            uint64_t v8 = v6;
            break;
          }
        }
      }
      if (v8 == v9) {
        return v13;
      }
    }
    uint64_t v89 = v10;
    BOOL v93 = v12;
    unint64_t v94 = v11;
    uint64_t v109 = v11;
    uint64_t v110 = 0x1000000000;
    long long v106 = v12;
    uint64_t v107 = 0x1000000000;
    uint64_t v16 = v98;
    uint64_t v17 = *((void *)v98 + 14);
    uint64_t v91 = v3;
    uint64_t v92 = a2;
    if (*((unsigned char *)v98 + 18))
    {
      llvm::Function::BuildLazyArguments(v98);
      uint64_t v18 = *((void *)v16 + 11);
      if (*((_WORD *)v16 + 9))
      {
        llvm::Function::BuildLazyArguments(v16);
        uint64_t v19 = *((void *)v16 + 11);
LABEL_22:
        uint64_t v90 = v9;
        uint64_t v20 = (uint64_t *)(v8 + 8);
        uint64_t v21 = v19 + 40 * *((void *)v16 + 12);
        if (v18 != v21)
        {
          uint64_t v56 = v17 + 40;
          do
          {
            uint64_t v57 = *(unsigned int *)(v18 + 32);
            uint64_t v58 = *v20;
            uint64_t v59 = *(void *)(*v20 + 8 * v57);
            if (v59)
            {
              int v62 = *(const void **)(v59 + 24);
              uint64_t v63 = *(unsigned int *)(v59 + 32);
              int v64 = v110;
              if ((unint64_t)v110 + v63 > HIDWORD(v110)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v63)
              {
                memcpy((char *)v109 + 8 * v110, v62, 8 * v63);
                int v64 = v110;
              }
              LODWORD(v110) = v64 + v63;
              sub_1CC2FCB18((uint64_t)&v106, *(unsigned int *)(*(void *)(v58 + 8 * v57) + 32), 0);
              uint64_t v56 = v17 + 40;
            }
            else
            {
              if (v110 >= (unint64_t)HIDWORD(v110)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v109 + v110) = *(void *)v18;
              LODWORD(v110) = v110 + 1;
              if (v17 && (unsigned int v60 = *(_DWORD *)(v18 + 32) + 2, v60 < *(_DWORD *)(v17 + 8))) {
                uint64_t v61 = *(void *)(v56 + 8 * v60);
              }
              else {
                uint64_t v61 = 0;
              }
              if (v107 >= (unint64_t)HIDWORD(v107)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v106[v107] = v61;
              LODWORD(v107) = v107 + 1;
            }
            v18 += 40;
          }
          while (v18 != v21);
        }
        BOOL v22 = (llvm::PointerType *)llvm::FunctionType::get(**(uint64_t ****)(*((void *)v98 + 3) + 16), (uint64_t)v109, v110, *(_DWORD *)(*((void *)v98 + 3) + 8) > 0xFFu);
        unint64_t v97 = 0;
        int v23 = *((_DWORD *)v98 + 8) & 0xF;
        BOOL v24 = (llvm::Type *)(*(_DWORD *)(*(void *)v98 + 8) >> 8);
        v102[8] = 257;
        uint64_t v25 = (unint64_t *)operator new(0x80uLL);
        uint64_t v26 = (llvm::BlockAddress *)(v25 + 1);
        *((_DWORD *)v25 + 7) = *((_DWORD *)v25 + 7) & 0x38000000 | 0x40000000;
        *uint64_t v25 = 0;
        llvm::Function::Function(v25 + 1, v22, v23, v24, (const char **)&v100, 0);
        unint64_t v97 = v26;
        uint64_t v3 = v91;
        sub_1CC8B0F60(*(void **)(v91 + 80), &v97);
        unsigned int v28 = v97;
        uint64_t v27 = v98;
        uint64_t v29 = *((void *)v98 + 5);
        *((void *)v97 + 5) = v29;
        uint64_t v30 = v27;
        unsigned int v31 = (int32x2_t ****)v28;
        if ((*((unsigned char *)v28 + 23) & 0x10) != 0)
        {
          uint64_t v32 = *(llvm::ValueSymbolTable **)(v29 + 112);
          uint64_t v30 = v27;
          unsigned int v31 = (int32x2_t ****)v28;
          if (v32)
          {
            llvm::ValueSymbolTable::reinsertValue(v32, v28);
            unsigned int v31 = (int32x2_t ****)v97;
            uint64_t v30 = v98;
          }
        }
        uint64_t v33 = *((void *)v27 + 7);
        *((void *)v28 + 7) = v33;
        *((void *)v28 + 8) = (char *)v27 + 56;
        unint64_t v34 = (char *)v28 + 56;
        *(void *)(v33 + 8) = v34;
        *((void *)v27 + 7) = v34;
        llvm::Value::takeName(v31, v30);
        llvm::Function::copyAttributesFrom(v97, v98);
        uint64_t v35 = (uint64_t ***)v97;
        if ((*((unsigned char *)v98 + 23) & 0x20) == 0) {
          goto LABEL_42;
        }
        uint64_t v36 = ***(void ***)v98;
        unsigned int v100 = v98;
        int v37 = *(_DWORD *)(v36 + 2496);
        if (v37)
        {
          uint64_t v38 = *(void *)(v36 + 2480);
          int v39 = v37 - 1;
          unsigned int v40 = v39 & ((v98 >> 4) ^ (v98 >> 9));
          unsigned int v41 = (llvm::Function **)(v38 + 40 * v40);
          uint64_t v42 = *v41;
          if (*v41 == v98) {
            goto LABEL_37;
          }
          unint64_t v43 = 0;
          int v44 = 1;
          while (v42 != (llvm::Function *)-4096)
          {
            if (v43) {
              BOOL v45 = 0;
            }
            else {
              BOOL v45 = v42 == (llvm::Function *)-8192;
            }
            if (v45) {
              unint64_t v43 = v41;
            }
            unsigned int v46 = v40 + v44++;
            unsigned int v40 = v46 & v39;
            unsigned int v41 = (llvm::Function **)(v38 + 40 * v40);
            uint64_t v42 = *v41;
            if (*v41 == v98) {
              goto LABEL_37;
            }
          }
          if (v43) {
            unint64_t v86 = v43;
          }
          else {
            unint64_t v86 = v41;
          }
        }
        else
        {
          unint64_t v86 = 0;
        }
        unsigned int v41 = (llvm::Function **)sub_1CC609054(v36 + 2480, (uint64_t)&v100, (uint64_t *)&v100, v86);
        int v87 = (llvm::Function *)v100;
        v41[4] = 0;
        v41[3] = 0;
        *unsigned int v41 = v87;
        v41[1] = (llvm::Function *)(v41 + 3);
        v41[2] = (llvm::Function *)0x100000000;
LABEL_37:
        uint64_t v47 = *((unsigned int *)v41 + 4);
        if (v47)
        {
          unsigned int v48 = (llvm::MDNode **)((char *)v41[1] + 8);
          uint64_t v49 = 16 * v47;
          while (*((_DWORD *)v48 - 2))
          {
            uint64_t v50 = 0;
            v48 += 2;
            v49 -= 16;
            if (!v49) {
              goto LABEL_43;
            }
          }
          uint64_t v50 = *v48;
LABEL_43:
          llvm::Value::setMetadata(v35, 0, v50);
          llvm::Value::setMetadata((uint64_t ***)v98, 0, 0);
          uint64_t v51 = v97;
          uint64_t v52 = **(void **)v98;
          if (v17 && (int v53 = *(_DWORD *)(v17 + 8)) != 0)
          {
            uint64_t v54 = *(void *)(v17 + 40);
            if (v53 != 1)
            {
              uint64_t v55 = *(void *)(v17 + 48);
LABEL_67:
              *((void *)v51 + 14) = llvm::AttributeList::get(**(uint64_t ***)v98, v54, v55, v106, v107);
              sub_1CC89D864((uint64_t)v97 + 72, *((uint64_t **)v97 + 10), (uint64_t *)v98 + 9);
              uint64_t v103 = (llvm::ValueAsMetadata **)v105;
              uint64_t v104 = 0x800000000;
              uint64_t v66 = *((void *)v98 + 1);
              if (v66)
              {
                unsigned int v67 = 0;
                do
                {
                  uint64_t v68 = *(llvm::ValueAsMetadata **)(v66 + 24);
                  if (v68) {
                    BOOL v69 = *((unsigned char *)v68 + 16) == 4;
                  }
                  else {
                    BOOL v69 = 0;
                  }
                  if (v69)
                  {
                    if (v67 >= HIDWORD(v104)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    v103[v67] = v68;
                    unsigned int v67 = v104 + 1;
                    LODWORD(v104) = v104 + 1;
                  }
                  uint64_t v66 = *(void *)(v66 + 8);
                }
                while (v66);
                if (v67)
                {
                  uint64_t v70 = v103;
                  uint64_t v71 = 8 * v67;
                  do
                  {
                    uint64_t v72 = *v70++;
                    long long v73 = llvm::BlockAddress::get(v97, *((llvm::Function **)v72 - 4), v65);
                    llvm::Value::doRAUW(v72, v73, (llvm::Value *)1);
                    v71 -= 8;
                  }
                  while (v71);
                }
              }
              unsigned int v100 = v102;
              uint64_t v101 = 0x800000000;
              v96[0] = v8 + 8;
              v96[1] = &v97;
              v96[2] = v52;
              v96[3] = &v100;
              char v95 = 0;
              llvm::Attributor::checkForAllCallSites(v91, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8B71D8, (uint64_t)v96, (uint64_t)v98, 1, 0, &v95);
              uint64_t v74 = v98;
              if (*((_WORD *)v98 + 9)) {
                llvm::Function::BuildLazyArguments(v98);
              }
              int v75 = (llvm::PoisonValue **)*((void *)v74 + 11);
              int v76 = v97;
              if (*((_WORD *)v97 + 9)) {
                llvm::Function::BuildLazyArguments(v97);
              }
              if (*(_DWORD *)(v8 + 16))
              {
                unint64_t v77 = 0;
                uint64_t v78 = (int32x2_t ****)*((void *)v76 + 11);
                do
                {
                  uint64_t v79 = *v20;
                  uint64_t v80 = *(void *)(*v20 + 8 * v77);
                  if (v80)
                  {
                    uint64_t v81 = *(void *)(v80 + 128);
                    if (v81)
                    {
                      uint64_t v99 = v78;
                      (*(void (**)(uint64_t))(*(void *)v81 + 48))(v81);
                      uint64_t v80 = *(void *)(v79 + 8 * v77);
                    }
                    unsigned int v82 = *(_DWORD *)(v80 + 32);
                    if (!v82)
                    {
                      uint64_t v83 = (llvm::Value *)llvm::PoisonValue::get(*v75, (llvm::Type *)v80);
                      llvm::Value::doRAUW((llvm::ValueAsMetadata *)v75, v83, (llvm::Value *)1);
                      unsigned int v82 = *(_DWORD *)(*(void *)(v79 + 8 * v77) + 32);
                    }
                  }
                  else
                  {
                    llvm::Value::takeName(v78, (llvm::Value *)v75);
                    llvm::Value::doRAUW((llvm::ValueAsMetadata *)v75, (llvm::Value *)v78, (llvm::Value *)1);
                    unsigned int v82 = 1;
                  }
                  v78 += 5 * v82;
                  ++v77;
                  v75 += 5;
                }
                while (v77 < *(unsigned int *)(v8 + 16));
              }
              a2 = v92;
              if (v101)
              {
                unint64_t v84 = *(llvm::CallBase **)v100;
                uint64_t v85 = (llvm::CallBase *)*((void *)v100 + 1);
                uint64_t v99 = *(int32x2_t *****)(*(void *)(*(void *)v100 + 40) + 56);
                sub_1CC8AEA28(v92, (uint64_t *)&v99);
                llvm::CallGraphUpdater::replaceCallSite(*(llvm::CallGraphUpdater **)(v91 + 5472), v84, v85);
                llvm::Value::doRAUW(v84, v85, (llvm::Value *)1);
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              llvm::CallGraphUpdater::replaceFunctionWith(*(llvm::CallGraphUpdater **)(v91 + 5472), v98, v97);
              uint64_t v12 = v93;
              if (sub_1CD64B6C4(v92, &v98)) {
                sub_1CC8AEA28(v92, (uint64_t *)&v97);
              }
              uint64_t v10 = v89;
              uint64_t v9 = v90;
              uint64_t v11 = v94;
              if (v100 != v102) {
                free(v100);
              }
              if (v103 != (llvm::ValueAsMetadata **)v105) {
                free(v103);
              }
              if (v106 != v93) {
                free(v106);
              }
              if (v109 != v94) {
                free(v109);
              }
              uint64_t v13 = 0;
              goto LABEL_12;
            }
          }
          else
          {
            uint64_t v54 = 0;
          }
          uint64_t v55 = 0;
          goto LABEL_67;
        }
LABEL_42:
        uint64_t v50 = 0;
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v18 = *((void *)v98 + 11);
    }
    uint64_t v19 = v18;
    goto LABEL_22;
  }
  return 1;
}

void llvm::AADepGraph::viewGraph(llvm::AADepGraph *this)
{
  unsigned int v5 = this;
  uint64_t v3 = "Dependency Graph";
  __int16 v4 = 259;
  __int16 v2 = 257;
  sub_1CD64C5D8((llvm::raw_ostream *)&v5, (llvm::Twine *)&v3, 0, (llvm::Twine *)v1, 0);
}

void *sub_1CC8B0DF4(uint64_t a1, int32x2_t *****a2)
{
  uint64_t v3 = *a2;
  uint64_t v20 = 2;
  uint64_t v21 = 0;
  BOOL v22 = v3;
  if (v3 != (int32x2_t ****)-8192 && v3 != (int32x2_t ****)-4096 && v3 != 0) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v20);
  }
  uint64_t v19 = &unk_1F2615EC8;
  uint64_t v23 = a1;
  unsigned int v5 = sub_1CC4CFF80(a1, &v19);
  if (v22 != (int32x2_t ****)-8192 && v22 != (int32x2_t ****)-4096 && v22 != 0)
  {
    unint64_t v7 = v20 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v20 & 0xFFFFFFFFFFFFFFF8) = v21;
    if (v21)
    {
      *uint64_t v21 = *v21 & 7 | v7;
    }
    else
    {
      uint64_t v8 = v22;
      uint64_t v9 = ***v22;
      unint64_t v10 = (unint64_t)v9[303];
      if (v10 <= v7)
      {
        uint64_t v11 = v9[305].u32[0];
        if (v10 + 16 * v11 > v7)
        {
          unsigned int v12 = v11 - 1;
          LODWORD(v13) = v12 & ((v22 >> 4) ^ (v22 >> 9));
          BOOL v14 = (int32x2_t *****)(v10 + 16 * v13);
          uint64_t v15 = *v14;
          if (v22 == *v14)
          {
LABEL_20:
            *BOOL v14 = (int32x2_t ****)-8192;
            v9[304] = vadd_s32(v9[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v8 = v22;
          }
          else
          {
            int v16 = 1;
            while (v15 != (int32x2_t ****)-4096)
            {
              int v17 = v13 + v16++;
              uint64_t v13 = v17 & v12;
              uint64_t v15 = *(int32x2_t *****)(v10 + 16 * v13);
              if (v22 == v15)
              {
                BOOL v14 = (int32x2_t *****)(v10 + 16 * v13);
                goto LABEL_20;
              }
            }
          }
          *((unsigned char *)v8 + 17) &= ~1u;
        }
      }
    }
  }
  return v5 + 5;
}

BOOL sub_1CC8B0F60(void *a1, void *a2)
{
  sub_1CD651F58((uint64_t)a1, a2, (uint64_t)&v17);
  int v4 = v18;
  if (v18)
  {
    uint64_t v6 = (void *)a1[4];
    unint64_t v5 = a1[5];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = (void *)a1[3];
      uint64_t v9 = v6 - v8;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v5 - (void)v8;
      if (v11 >> 2 > v10) {
        unint64_t v10 = v11 >> 2;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 61) {
          sub_1CB833614();
        }
        uint64_t v13 = (char *)operator new(8 * v12);
      }
      else
      {
        uint64_t v13 = 0;
      }
      BOOL v14 = &v13[8 * v9];
      *(void *)BOOL v14 = *a2;
      unint64_t v7 = v14 + 8;
      if (v6 != v8)
      {
        do
        {
          uint64_t v15 = *--v6;
          *((void *)v14 - 1) = v15;
          v14 -= 8;
        }
        while (v6 != v8);
        uint64_t v6 = (void *)a1[3];
      }
      a1[3] = v14;
      a1[4] = v7;
      a1[5] = &v13[8 * v12];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *uint64_t v6 = *a2;
      unint64_t v7 = v6 + 1;
    }
    a1[4] = v7;
  }
  return v4 != 0;
}

uint64_t llvm::InformationCache::initializeInformationCache(llvm::InformationCache *this, const llvm::Function *a2, llvm::InformationCache::FunctionInfo *a3)
{
  int v4 = this;
  v94[6] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = (char *)a2 + 72;
  v86[0] = 0;
  v86[1] = 0;
  int v87 = 0;
  uint64_t v6 = (char *)*((void *)a2 + 10);
  if (v6 == (char *)a2 + 72) {
    goto LABEL_6;
  }
  while (1)
  {
    uint64_t v8 = v6 - 24;
    if (!v6) {
      uint64_t v8 = 0;
    }
    uint64_t v9 = (char *)*((void *)v8 + 6);
    if (v9 != v8 + 40) {
      break;
    }
    uint64_t v6 = (char *)*((void *)v6 + 1);
    if (v6 == v5) {
      goto LABEL_6;
    }
  }
  uint64_t v83 = (char *)this + 368;
  unint64_t v84 = (char *)this + 392;
  while (1)
  {
    if (v9) {
      uint64_t v17 = (uint64_t)(v9 - 24);
    }
    else {
      uint64_t v17 = 0;
    }
    int v18 = *(unsigned __int8 *)(v17 + 16);
    uint64_t v19 = (v18 - 29);
    if (v19 <= 0x37)
    {
      if (((1 << (v18 - 29)) & 0x20019C00006B3) != 0) {
        goto LABEL_25;
      }
      if (v19 == 55)
      {
        BOOL v23 = sub_1CBF698E4(v17);
        if (v9 && v23)
        {
          llvm::fillMapFromAssume(v17, (uint64_t)v83);
          uint64_t v24 = *(void *)(v17 - 32 * (*(_DWORD *)(v17 + 20) & 0x7FFFFFF));
          uint64_t v91 = v94;
          unsigned int v93 = 6;
          if (*(unsigned __int8 *)(v24 + 16) < 0x1Cu) {
            goto LABEL_25;
          }
          v94[0] = v24;
          unsigned int v25 = 1;
          while (1)
          {
            uint64_t v88 = 0;
            uint64_t v26 = *((void *)v91 + v25 - 1);
            unsigned int v92 = v25 - 1;
            uint64_t v88 = v26;
            v89[0] = v26;
            uint64_t v27 = sub_1CD40EB18((uint64_t)v86, v89);
            if (*((unsigned char *)v27 + 10))
            {
              __int16 v29 = *((_WORD *)v27 + 4);
            }
            else
            {
              uint64_t v28 = *(void *)(v88 + 8);
              if (v28)
              {
                __int16 v29 = 0;
                do
                {
                  ++v29;
                  uint64_t v28 = *(void *)(v28 + 8);
                }
                while (v28);
              }
              else
              {
                __int16 v29 = 0;
              }
              *((unsigned char *)v27 + 10) = 1;
            }
            __int16 v30 = v29 - 1;
            *((_WORD *)v27 + 4) = v30;
            if (!v30)
            {
              sub_1CD484194((uint64_t)v89, (uint64_t)v84, &v88);
              if (v90)
              {
                unsigned int v31 = this;
                uint64_t v33 = (uint64_t *)*((void *)this + 53);
                unint64_t v32 = *((void *)this + 54);
                if ((unint64_t)v33 >= v32)
                {
                  uint64_t v35 = (void *)*((void *)this + 52);
                  uint64_t v36 = v33 - v35;
                  unint64_t v37 = v36 + 1;
                  if ((unint64_t)(v36 + 1) >> 61) {
                    abort();
                  }
                  uint64_t v38 = v32 - (void)v35;
                  if (v38 >> 2 > v37) {
                    unint64_t v37 = v38 >> 2;
                  }
                  if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v39 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v39 = v37;
                  }
                  if (v39)
                  {
                    if (v39 >> 61) {
                      sub_1CB833614();
                    }
                    unint64_t v81 = v39;
                    unsigned int v40 = (char *)operator new(8 * v39);
                    unint64_t v39 = v81;
                  }
                  else
                  {
                    unsigned int v40 = 0;
                  }
                  unsigned int v41 = (uint64_t *)&v40[8 * v36];
                  *unsigned int v41 = v88;
                  unint64_t v34 = v41 + 1;
                  if (v33 == v35)
                  {
                    unsigned int v31 = this;
                  }
                  else
                  {
                    do
                    {
                      uint64_t v42 = *--v33;
                      *--unsigned int v41 = v42;
                    }
                    while (v33 != v35);
                    unsigned int v31 = this;
                    uint64_t v33 = (uint64_t *)*((void *)this + 52);
                  }
                  *((void *)v31 + 52) = v41;
                  *((void *)v31 + 53) = v34;
                  *((void *)v31 + 54) = &v40[8 * v39];
                  if (v33) {
                    operator delete(v33);
                  }
                }
                else
                {
                  *uint64_t v33 = v88;
                  unint64_t v34 = v33 + 1;
                }
                *((void *)v31 + 53) = v34;
              }
              int v43 = *(_DWORD *)(v88 + 20);
              if ((v43 & 0x40000000) != 0)
              {
                uint64_t v45 = *(void *)(v88 - 8);
                uint64_t v44 = v43 & 0x7FFFFFF;
                if (v44)
                {
LABEL_66:
                  uint64_t v46 = 32 * v44;
                  do
                  {
                    if (*(void *)v45) {
                      BOOL v47 = *(unsigned __int8 *)(*(void *)v45 + 16) >= 0x1Cu;
                    }
                    else {
                      BOOL v47 = 0;
                    }
                    if (v47)
                    {
                      if (v92 >= (unint64_t)v93) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      *((void *)v91 + v92++) = *(void *)v45;
                    }
                    v45 += 32;
                    v46 -= 32;
                  }
                  while (v46);
                }
              }
              else
              {
                uint64_t v44 = v43 & 0x7FFFFFF;
                uint64_t v45 = v88 - 32 * v44;
                if (v44) {
                  goto LABEL_66;
                }
              }
            }
            unsigned int v25 = v92;
            if (!v92)
            {
              int v4 = this;
              if (v91 != v94) {
                free(v91);
              }
              goto LABEL_25;
            }
          }
        }
        if ((*(_WORD *)(v17 + 18) & 3) == 2)
        {
          *((unsigned char *)a3 + 105) = 1;
          uint64_t v58 = *(void *)(v17 - 32);
          if (v58)
          {
            if (!*(unsigned char *)(v58 + 16) && *(void *)(v58 + 24) == *(void *)(v17 + 72)) {
              *(unsigned char *)(sub_1CD64B750(v4) + 104) = 1;
            }
          }
        }
LABEL_25:
        LODWORD(v91) = *(unsigned __int8 *)(v17 + 16) - 28;
        uint64_t v20 = sub_1CD52C224((uint64_t)a3, &v91);
        unint64_t v21 = *((void *)v20 + 1);
        if (v21)
        {
          unint64_t v22 = *(unsigned int *)(v21 + 8);
          if (v22 >= *(unsigned int *)(v21 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
        }
        else
        {
          unsigned int v48 = v20;
          uint64_t v49 = *((void *)v4 + 16);
          *(void *)(v49 + 80) += 80;
          if (((*(void *)v49 + 7) & 0xFFFFFFFFFFFFFFF8) - *(void *)v49 + 80 > *(void *)(v49 + 8)
                                                                                     - *(void *)v49)
          {
            unsigned int v59 = *(_DWORD *)(v49 + 24) >> 7;
            if (v59 >= 0x1E) {
              LOBYTE(v59) = 30;
            }
            uint64_t v82 = 4096 << v59;
            unint64_t v21 = (unint64_t)operator new(4096 << v59, (std::align_val_t)8uLL);
            unint64_t v60 = *(unsigned int *)(v49 + 24);
            if (v60 >= *(unsigned int *)(v49 + 28)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v49 + 16) + 8 * v60) = v21;
            ++*(_DWORD *)(v49 + 24);
            *(void *)(v49 + 8) = v21 + v82;
          }
          else
          {
            unint64_t v21 = (*(void *)v49 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          unint64_t v22 = 0;
          *(void *)uint64_t v49 = v21 + 80;
          *(void *)unint64_t v21 = v21 + 16;
          *(void *)(v21 + 8) = 0x800000000;
          *((void *)v48 + 1) = v21;
          int v4 = this;
        }
        *(void *)(*(void *)v21 + 8 * v22) = v17;
        ++*(_DWORD *)(v21 + 8);
        int v18 = *(unsigned __int8 *)(v17 + 16);
      }
    }
    uint64_t v50 = (v18 - 33);
    if (v50 <= 0x37)
    {
      if (((1 << v50) & 0x8000000000041) != 0)
      {
        uint64_t v52 = *(void *)(v17 + 64);
        if (!v52 || (*(unsigned char *)(v52 + 20) & 4) == 0 && (*(unsigned char *)(v52 + 17) & 0x10) == 0)
        {
          LODWORD(v91) = 7;
          if (sub_1CC5CB59C(v17, (__int32 *)&v91, 1uLL))
          {
            uint64_t v61 = *(void *)(v17 - 32);
            if (!v61 || *(unsigned char *)(v61 + 16) || *(void *)(v61 + 24) != *(void *)(v17 + 72))
            {
              int v4 = this;
              goto LABEL_107;
            }
            int v4 = this;
            if (*(_DWORD *)(v61 + 36) != 7) {
              goto LABEL_107;
            }
          }
          if ((llvm::CallBase::hasFnAttrOnCalledFunction(v17, 66) & 1) == 0
            && !llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44))
          {
            goto LABEL_107;
          }
        }
      }
      else if (((1 << v50) & 0x808001C8000010) != 0 || v50 == 28 && (*(_WORD *)(v17 + 18) & 0x301) != 0)
      {
        goto LABEL_107;
      }
    }
    uint64_t v51 = *(unsigned __int8 *)(v17 + 16) - 33;
    if (v51 > 0x37) {
      goto LABEL_109;
    }
    if (((1 << (*(unsigned char *)(v17 + 16) - 33)) & 0x8000000000041) != 0)
    {
      uint64_t v53 = *(void *)(v17 + 64);
      if (v53 && (*(unsigned char *)(v53 + 17) & 0x30) != 0) {
        goto LABEL_109;
      }
      int v54 = *(_DWORD *)(v17 + 20);
      if (v54 < 0
        && (uint64_t v62 = v17 - 32 * (v54 & 0x7FFFFFF), v65 = *(void *)(v62 - 8), v63 = v62 - 8, (v64 = v65) != 0))
      {
        uint64_t v66 = -v64;
        while (1)
        {
          unsigned int v67 = *(_DWORD *)(*(void *)(v63 + v66) + 8);
          BOOL v68 = v67 > 7;
          int v69 = (1 << v67) & 0x83;
          if (v68 || v69 == 0) {
            break;
          }
          v66 += 16;
          if (!v66) {
            goto LABEL_101;
          }
        }
      }
      else
      {
LABEL_101:
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v17, 45) & 1) != 0
          || (llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44) & 1) != 0)
        {
          goto LABEL_109;
        }
      }
    }
    else if (v51 == 27)
    {
      if ((*(_WORD *)(v17 + 18) & 0x301) == 0) {
        goto LABEL_109;
      }
    }
    else if (((1 << (*(unsigned char *)(v17 + 16) - 33)) & 0x808001D0000010) == 0)
    {
      goto LABEL_109;
    }
LABEL_107:
    unint64_t v55 = *((unsigned int *)a3 + 8);
    if (v55 >= *((unsigned int *)a3 + 9)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*((void *)a3 + 3) + 8 * v55) = v17;
    ++*((_DWORD *)a3 + 8);
LABEL_109:
    uint64_t v9 = (char *)*((void *)v9 + 1);
    uint64_t v56 = v6 - 24;
    if (!v6) {
      uint64_t v56 = 0;
    }
    if (v9 == v56 + 40) {
      break;
    }
LABEL_116:
    if (v6 == v5) {
      goto LABEL_6;
    }
  }
  while (1)
  {
    uint64_t v6 = (char *)*((void *)v6 + 1);
    if (v6 == v5) {
      break;
    }
    uint64_t v57 = v6 - 24;
    if (!v6) {
      uint64_t v57 = 0;
    }
    uint64_t v9 = (char *)*((void *)v57 + 6);
    if (v9 != v57 + 40) {
      goto LABEL_116;
    }
  }
LABEL_6:
  uint64_t v10 = *((void *)a2 + 14);
  if (v10 && (*(unsigned char *)(v10 + 12) & 4) != 0 && !llvm::isInlineViable(a2, a2, a3))
  {
    uint64_t v11 = *((void *)v4 + 57);
    uint64_t v12 = *((unsigned int *)v4 + 117);
    if (v11 == *((void *)v4 + 56))
    {
      if (v12)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 8 * v12;
        uint64_t v15 = (void *)*((void *)v4 + 57);
        while ((const llvm::Function *)*v15 != a2)
        {
          if (*v15 == -2) {
            uint64_t v13 = v15;
          }
          ++v15;
          v14 -= 8;
          if (!v14)
          {
            if (!v13) {
              goto LABEL_17;
            }
            void *v13 = a2;
            --*((_DWORD *)v4 + 118);
            return MEMORY[0x1D25D9CD0](v86[0], 8);
          }
        }
        return MEMORY[0x1D25D9CD0](v86[0], 8);
      }
LABEL_17:
      unsigned int v16 = *((_DWORD *)v4 + 116);
      if (v12 < v16)
      {
        *((_DWORD *)v4 + 117) = v12 + 1;
        *(void *)(v11 + 8 * v12) = a2;
        return MEMORY[0x1D25D9CD0](v86[0], 8);
      }
    }
    else
    {
      unsigned int v16 = *((_DWORD *)v4 + 116);
    }
    if (3 * v16 <= 4 * ((int)v12 - *((_DWORD *)v4 + 118)))
    {
      if (v16 >= 0x40) {
        v16 *= 2;
      }
      else {
        unsigned int v16 = 128;
      }
    }
    else if (v16 - v12 >= v16 >> 3)
    {
      goto LABEL_148;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::InformationCache *)((char *)v4 + 448), v16);
    unsigned int v16 = *((_DWORD *)v4 + 116);
    uint64_t v11 = *((void *)v4 + 57);
LABEL_148:
    unsigned int v71 = v16 - 1;
    unsigned int v72 = (v16 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    long long v73 = (const llvm::Function **)(v11 + 8 * v72);
    uint64_t v74 = *v73;
    if (*v73 == (const llvm::Function *)-1)
    {
      int v75 = 0;
LABEL_160:
      if (v75) {
        uint64_t v79 = v75;
      }
      else {
        uint64_t v79 = v73;
      }
      if (*v79 != a2)
      {
        if (*v79 == (const llvm::Function *)-2) {
          --*((_DWORD *)v4 + 118);
        }
        else {
          ++*((_DWORD *)v4 + 117);
        }
        *uint64_t v79 = a2;
      }
    }
    else
    {
      int v75 = 0;
      int v76 = 1;
      while (v74 != a2)
      {
        if (v75) {
          BOOL v77 = 0;
        }
        else {
          BOOL v77 = v74 == (const llvm::Function *)-2;
        }
        if (v77) {
          int v75 = v73;
        }
        unsigned int v78 = v72 + v76++;
        unsigned int v72 = v78 & v71;
        long long v73 = (const llvm::Function **)(v11 + 8 * (v78 & v71));
        uint64_t v74 = *v73;
        if (*v73 == (const llvm::Function *)-1) {
          goto LABEL_160;
        }
      }
    }
  }
  return MEMORY[0x1D25D9CD0](v86[0], 8);
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *this, int a2)
{
  BOOL v3 = a2 == 0;
  if (a2) {
    int v4 = "unchanged";
  }
  else {
    int v4 = "changed";
  }
  if (v3) {
    size_t v5 = 7;
  }
  else {
    size_t v5 = 9;
  }
  uint64_t v7 = *((void *)this + 3);
  uint64_t v6 = (void *)*((void *)this + 4);
  if (v5 <= v7 - (uint64_t)v6)
  {
    memcpy(v6, v4, v5);
    *((void *)this + 4) += v5;
  }
  else
  {
    llvm::raw_ostream::write(this, v4, v5);
  }
  return this;
}

uint64_t llvm::operator<<(uint64_t a1, uint64_t a2)
{
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1);
  return a1;
}

BOOL sub_1CC8B20B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (*(void *)(v5 + 24) != *(void *)(v5 + 32))
  {
    uint64_t v11 = v6;
    uint64_t v12 = (uint64_t *)v5;
    LOBYTE(v40) = v8;
    BYTE1(v40) = v7;
    WORD1(v40) = 257;
    *((void *)&v40 + 1) = v6;
    uint64_t v41 = 0;
    char v42 = 0;
    char v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    sub_1CD64F008((uint64_t)v48, v5, v4, &v40);
    uint64_t v13 = (llvm::GlobalValue **)v12[3];
    uint64_t v14 = (llvm::GlobalValue **)v12[4];
    if (byte_1EBCDDBB8)
    {
      if (v13 == v14)
      {
        uint64_t v14 = (llvm::GlobalValue **)v12[3];
      }
      else
      {
        do
        {
          uint64_t v15 = *v13;
          if (!sub_1CD64EF44((uint64_t)v48, *v13)) {
            llvm::Attributor::createShallowWrapper(v15, v16);
          }
          ++v13;
        }
        while (v13 != v14);
        uint64_t v13 = (llvm::GlobalValue **)v12[3];
        uint64_t v14 = (llvm::GlobalValue **)v12[4];
      }
    }
    if (byte_1EBCDDC78)
    {
      unint64_t v17 = (char *)v14 - (char *)v13;
      if ((((char *)v14 - (char *)v13) & 0x7FFFFFFF8) != 0)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (v17 >> 3);
        while (1)
        {
          uint64_t v20 = *(void *)(v12[3] + 8 * v18);
          if (v20) {
            BOOL v21 = *(unsigned char *)(v20 + 16) == 3;
          }
          else {
            BOOL v21 = 0;
          }
          if (v21)
          {
            if ((*(_DWORD *)(v20 + 20) & 0x7FFFFFF) != 0) {
              goto LABEL_23;
            }
          }
          else if (*(unsigned char *)(v20 + 16) || *(void *)(v20 + 72) != v20 + 72 || (*(unsigned char *)(v20 + 34) & 0x80) != 0)
          {
LABEL_23:
            if (((1 << (*(_DWORD *)(v20 + 32) & 0xF)) & 0x7D5) == 0
              || (llvm::GlobalValue::isInterposable(*(llvm::GlobalValue **)(v12[3] + 8 * v18)) & 1) != 0)
            {
              uint64_t v22 = *(void *)(v20 + 8);
              if (v22)
              {
                int v23 = 0;
                do
                {
                  uint64_t v22 = *(void *)(v22 + 8);
                  --v23;
                }
                while (v22);
                if (v23)
                {
                  if (((1 << (*(_DWORD *)(v20 + 32) & 0xF)) & 0x614) == 0)
                  {
                    BOOL v47 = 0;
                    BOOL v47 = (llvm::Function *)llvm::Attributor::internalizeFunction((llvm::Attributor *)v20, 0);
                    sub_1CC8B0F60(v12, &v47);
                    llvm::CallGraphUpdater::replaceFunctionWith(v11, (llvm::Function *)v20, v47);
                    for (uint64_t i = *((void *)v47 + 1); i; uint64_t i = *(void *)(i + 8))
                    {
                      uint64_t v25 = *(void *)(i + 24);
                      unsigned int v26 = *(unsigned __int8 *)(v25 + 16);
                      if (v26 >= 0x1C)
                      {
                        unsigned int v27 = v26 - 33;
                        BOOL v28 = v27 > 0x33;
                        uint64_t v29 = (1 << v27) & 0x8000000000041;
                        if (!v28 && v29 != 0) {
                          llvm::CallGraphUpdater::reanalyzeFunction(v11, *(llvm::Function **)(*(void *)(v25 + 40) + 56));
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v18 == v19)
          {
            uint64_t v13 = (llvm::GlobalValue **)v12[3];
            uint64_t v14 = (llvm::GlobalValue **)v12[4];
            break;
          }
        }
      }
    }
    if (v13 == v14)
    {
LABEL_66:
      BOOL v9 = llvm::Attributor::run((llvm::Attributor *)v48) == 0;
      llvm::Attributor::~Attributor((llvm::Attributor *)v48);
      return v9;
    }
    while (1)
    {
      unsigned int v31 = *v13;
      if (*v13) {
        BOOL v32 = *((unsigned char *)*v13 + 16) == 3;
      }
      else {
        BOOL v32 = 0;
      }
      if (v32)
      {
        if ((*((_DWORD *)v31 + 5) & 0x7FFFFFF) == 0) {
          goto LABEL_53;
        }
      }
      else if (!*((unsigned char *)*v13 + 16) {
             && *((llvm::GlobalValue **)v31 + 9) == (llvm::GlobalValue *)((char *)v31 + 72)
      }
             && (*((unsigned char *)v31 + 34) & 0x80) == 0)
      {
        goto LABEL_53;
      }
      if (((1 << (*((_DWORD *)v31 + 8) & 0xF)) & 0x7D5) != 0) {
        llvm::GlobalValue::isInterposable(*v13);
      }
LABEL_53:
      if ((*((_DWORD *)v31 + 8) & 0xFu) - 7 > 1) {
        goto LABEL_64;
      }
      uint64_t v33 = *((void *)v31 + 1);
      if (v33)
      {
        while (1)
        {
          uint64_t v34 = *(void *)(v33 + 24);
          unsigned int v35 = *(unsigned __int8 *)(v34 + 16);
          if (v35 < 0x1C) {
            break;
          }
          unsigned int v36 = v35 - 33;
          BOOL v28 = v36 > 0x33;
          uint64_t v37 = (1 << v36) & 0x8000000000041;
          if (v28 || v37 == 0) {
            break;
          }
          if (v34 - 32 != v33) {
            break;
          }
          unint64_t v39 = *(llvm::Function **)(*(void *)(v34 + 40) + 56);
          uint64_t v46 = 0;
          BOOL v47 = v39;
          if ((sub_1CD420258(v12, &v47, &v46) & 1) == 0) {
            break;
          }
          uint64_t v33 = *(void *)(v33 + 8);
          if (!v33) {
            goto LABEL_65;
          }
        }
LABEL_64:
        llvm::Attributor::identifyDefaultAbstractAttributes((llvm::Attributor *)v48, (uint64_t)v31);
      }
LABEL_65:
      if (++v13 == v14) {
        goto LABEL_66;
      }
    }
  }
  return 0;
}

uint64_t sub_1CC8B245C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDD758;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F26208D0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDD768, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC8B262C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCDD768, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CC8B250C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDD759;
  *(_DWORD *)(a1 + 24) = 3;
  *(void *)a1 = &unk_1F2620970;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDD770, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC8B273C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCDD770, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::initializeAttributorLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  __int16 v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDD768, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8B262C;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCDD768, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8B262C(uint64_t a1)
{
}

void llvm::initializeAttributorCGSCCLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  __int16 v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDD770, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8B273C;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCDD770, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8B273C(llvm *a1)
{
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)a1);
  llvm::initializeCallGraphWrapperPassPass(a1, v2);
  operator new();
}

llvm::AbstractAttribute *sub_1CC8B27E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD64CC34(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AAMemoryLocation::createForPosition((llvm::AAMemoryLocation *)&v56, (uint64_t **)a1, v14);
  sub_1CD64CD80(a1, (uint64_t)v15);
  unint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAMemoryLocation::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B2D1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD64D2AC(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AAMemoryBehavior::createForPosition((llvm::AAMemoryBehavior *)&v56, (uint64_t **)a1, v14);
  sub_1CD64D3F8(a1, (uint64_t)v15);
  unint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAMemoryBehavior::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

BOOL sub_1CC8B3254(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7)) {
    return 1;
  }
  uint64_t v9 = *(void *)(a2 + 88);

  return sub_1CD64D7E0(v9, a3, a4);
}

llvm::AbstractAttribute *sub_1CC8B3300(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD64D468(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AANoRecurse::createForPosition((llvm::AANoRecurse *)&v56, (uint64_t **)a1, v14);
  sub_1CD64D5B4(a1, (uint64_t)v15);
  unint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoRecurse::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B3838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD64D624(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AAReachability::createForPosition((llvm::AAReachability *)&v56, (uint64_t **)a1, v14);
  sub_1CD64D770(a1, (uint64_t)v15);
  unint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAReachability::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B3D70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD64DC44(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AAFunctionReachability::createForPosition((llvm::AAFunctionReachability *)&v56, (uint64_t **)a1, v14);
  sub_1CD64DD90(a1, (uint64_t)v15);
  unint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAFunctionReachability::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t sub_1CC8B42A8(uint64_t *a1, uint64_t a2)
{
  BOOL v3 = *(llvm::Instruction **)a2;
  uint64_t v9 = *(llvm::Instruction **)a2;
  v10[0] = &v11;
  v10[1] = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)v10, a2 + 8);
    BOOL v3 = v9;
    if (!v9) {
      goto LABEL_4;
    }
  }
  else if (!v3)
  {
LABEL_4:
    uint64_t v4 = 0;
    goto LABEL_7;
  }
  if (*((unsigned char *)v3 + 16) == 33) {
    goto LABEL_4;
  }
  uint64_t NextNonDebugInstruction = llvm::Instruction::getNextNonDebugInstruction(v3, 0);
  uint64_t v6 = *a1;
  unsigned int v7 = *(_DWORD *)(v6 + 8);
  if (v7 >= *(_DWORD *)(v6 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)v6 + 8 * v7) = NextNonDebugInstruction;
  ++*(_DWORD *)(v6 + 8);
  uint64_t v4 = 1;
LABEL_7:
  if (v10[0] != &v11) {
    free(v10[0]);
  }
  return v4;
}

void sub_1CC8B4388(llvm::SmallPtrSetImplBase **a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  if (v2) {
    BOOL v3 = *(unsigned __int8 *)(v2 + 16) >= 0x1Cu;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3) {
    return;
  }
  uint64_t v5 = *a1;
  uint64_t v6 = *(void *)(*(void *)(v2 + 40) + 56);
  uint64_t v7 = *((void *)*a1 + 1);
  uint64_t v8 = *((unsigned int *)*a1 + 5);
  if (v7 == *(void *)*a1)
  {
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v8;
      uint64_t v11 = (void *)*((void *)*a1 + 1);
      while (*v11 != v6)
      {
        if (*v11 == -2) {
          uint64_t v9 = v11;
        }
        ++v11;
        v10 -= 8;
        if (!v10)
        {
          if (!v9) {
            goto LABEL_14;
          }
          *uint64_t v9 = v6;
          --*((_DWORD *)v5 + 6);
          goto LABEL_38;
        }
      }
      return;
    }
LABEL_14:
    unsigned int v12 = *((_DWORD *)v5 + 4);
    if (v8 < v12)
    {
      *((_DWORD *)v5 + 5) = v8 + 1;
      *(void *)(v7 + 8 * v8) = v6;
LABEL_38:
      uint64_t v22 = a1[1];
      unsigned int v23 = *((_DWORD *)v22 + 2);
      if (v23 >= *((_DWORD *)v22 + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v22 + 8 * v23) = *(void *)(*(void *)(v2 + 40) + 56);
      ++*((_DWORD *)v22 + 2);
      return;
    }
  }
  else
  {
    unsigned int v12 = *((_DWORD *)v5 + 4);
  }
  if (3 * v12 <= 4 * ((int)v8 - *((_DWORD *)v5 + 6)))
  {
    if (v12 >= 0x40) {
      v12 *= 2;
    }
    else {
      unsigned int v12 = 128;
    }
  }
  else if (v12 - v8 >= v12 >> 3)
  {
    goto LABEL_19;
  }
  llvm::SmallPtrSetImplBase::Grow(*a1, v12);
  unsigned int v12 = *((_DWORD *)v5 + 4);
  uint64_t v7 = *((void *)v5 + 1);
LABEL_19:
  unsigned int v13 = v12 - 1;
  unsigned int v14 = (v12 - 1) & ((v6 >> 4) ^ (v6 >> 9));
  uint64_t v15 = (void *)(v7 + 8 * v14);
  uint64_t v16 = *v15;
  if (*v15 != -1)
  {
    unint64_t v17 = 0;
    int v18 = 1;
    while (v16 != v6)
    {
      if (v17) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v16 == -2;
      }
      if (v19) {
        unint64_t v17 = v15;
      }
      unsigned int v20 = v14 + v18++;
      unsigned int v14 = v20 & v13;
      uint64_t v15 = (void *)(v7 + 8 * (v20 & v13));
      uint64_t v16 = *v15;
      if (*v15 == -1) {
        goto LABEL_31;
      }
    }
    return;
  }
  unint64_t v17 = 0;
LABEL_31:
  if (v17) {
    BOOL v21 = v17;
  }
  else {
    BOOL v21 = v15;
  }
  if (*v21 != v6)
  {
    if (*v21 == -2) {
      --*((_DWORD *)v5 + 6);
    }
    else {
      ++*((_DWORD *)v5 + 5);
    }
    *BOOL v21 = v6;
    goto LABEL_38;
  }
}

void sub_1CC8B4578(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8B45B0(uint64_t a1, uint64_t a2)
{
}

BOOL sub_1CC8B45C0(llvm::ModulePass *a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (llvm::ModulePass::skipModule(a1, (llvm::LLVMContextImpl ***)a2)) {
    return 0;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  v14[0] = 0;
  v14[1] = 0;
  int v15 = 0;
  __p = 0;
  unint64_t v17 = 0;
  for (uint64_t i = *(void *)(a2 + 32); i != a2 + 24; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v6 = i - 56;
    if (!i) {
      uint64_t v6 = 0;
    }
    v20[0] = v6;
    sub_1CC8B0F60(v14, v20);
  }
  v28[0] = v30;
  v28[1] = v30;
  _OWORD v28[2] = 16;
  int v29 = 0;
  v30[16] = v31;
  v30[17] = 0x1000000000;
  v31[16] = v32;
  v31[17] = 0x1000000000;
  memset(&v32[128], 0, 48);
  uint64_t v33 = 0;
  v21[1] = 0;
  v21[0] = 0;
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  uint64_t v25 = v27;
  uint64_t v26 = 0;
  v27[0] = 0;
  v27[1] = 1;
  sub_1CD64E580((uint64_t)v20, a2, (uint64_t)&v19, (uint64_t)v21, 0);
  BOOL v3 = sub_1CC8B20B0((uint64_t)v20, (uint64_t)v14, (uint64_t)v28, 1);
  sub_1CD64F398((uint64_t)v20);
  if (v23)
  {
    uint64_t v7 = (uint64_t *)v22;
    uint64_t v8 = 8 * v23;
    do
    {
      uint64_t v9 = *v7++;
      MEMORY[0x1D25D9CD0](v9, 8);
      v8 -= 8;
    }
    while (v8);
  }
  uint64_t v10 = v25;
  if (v26)
  {
    uint64_t v11 = (uint64_t *)v25;
    uint64_t v12 = 16 * v26;
    do
    {
      uint64_t v13 = *v11;
      v11 += 2;
      MEMORY[0x1D25D9CD0](v13, 8);
      v12 -= 16;
    }
    while (v12);
    uint64_t v10 = v25;
  }
  if (v10 != v27) {
    free(v10);
  }
  if (v22 != v24) {
    free(v22);
  }
  sub_1CD64F554((llvm::CallGraphUpdater *)v28);
  if (__p)
  {
    unint64_t v17 = __p;
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v14[0], 8);
  return v3;
}

void sub_1CC8B47E8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8B4820(llvm::CallGraphSCCPass *a1, llvm::AnalysisUsage *a2)
{
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);

  llvm::CallGraphSCCPass::getAnalysisUsage(a1, a2);
}

BOOL sub_1CC8B486C(uint64_t a1, uint64_t *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (llvm::CallGraphSCCPass::skipSCC(a1, (uint64_t)a2)) {
    return 0;
  }
  v19[0] = 0;
  v19[1] = 0;
  int v20 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  BOOL v21 = 0;
  uint64_t v4 = a2[2];
  uint64_t v5 = a2[3];
  if (v4 == v5)
  {
    BOOL v3 = 0;
    goto LABEL_17;
  }
  do
  {
    uint64_t v6 = *(void *)(*(void *)v4 + 8);
    v24[0] = v6;
    if (!v6) {
      goto LABEL_12;
    }
    if (*(unsigned char *)(v6 + 16))
    {
      if (*(unsigned char *)(v6 + 16) != 3 || (*(_DWORD *)(v6 + 20) & 0x7FFFFFF) != 0) {
        goto LABEL_11;
      }
    }
    else if (*(void *)(v6 + 72) != v6 + 72 || (*(unsigned char *)(v6 + 34) & 0x80) != 0)
    {
LABEL_11:
      sub_1CC8B0F60(v19, v24);
    }
LABEL_12:
    v4 += 8;
  }
  while (v4 != v5);
  uint64_t v7 = v21;
  if (v21 == v22)
  {
    BOOL v3 = 0;
    if (v21) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v18 = 0;
    uint64_t v9 = *a2;
    v32[0] = v34;
    v32[1] = v34;
    void v32[2] = 16;
    int v33 = 0;
    v34[16] = v35;
    v34[17] = 0x1000000000;
    v35[16] = v36;
    v35[17] = 0x1000000000;
    uint64_t v39 = 0;
    long long v38 = 0u;
    long long v37 = 0u;
    v36[16] = v9;
    v36[17] = a2;
    uint64_t v10 = *(void *)(*(v22 - 1) + 40);
    v25[1] = 0;
    v25[0] = 0;
    uint64_t v26 = v28;
    uint64_t v27 = 0x400000000;
    int v29 = v31;
    uint64_t v30 = 0;
    v31[0] = 0;
    v31[1] = 1;
    sub_1CD64E580((uint64_t)v24, v10, (uint64_t)&v18, (uint64_t)v25, (uint64_t)v19);
    BOOL v3 = sub_1CC8B20B0((uint64_t)v24, (uint64_t)v19, (uint64_t)v32, 0);
    sub_1CD64F398((uint64_t)v24);
    if (v27)
    {
      uint64_t v11 = (uint64_t *)v26;
      uint64_t v12 = 8 * v27;
      do
      {
        uint64_t v13 = *v11++;
        MEMORY[0x1D25D9CD0](v13, 8);
        v12 -= 8;
      }
      while (v12);
    }
    unsigned int v14 = v29;
    if (v30)
    {
      int v15 = (uint64_t *)v29;
      uint64_t v16 = 16 * v30;
      do
      {
        uint64_t v17 = *v15;
        v15 += 2;
        MEMORY[0x1D25D9CD0](v17, 8);
        v16 -= 16;
      }
      while (v16);
      unsigned int v14 = v29;
    }
    if (v14 != v31) {
      free(v14);
    }
    if (v26 != v28) {
      free(v26);
    }
    sub_1CD64F554((llvm::CallGraphUpdater *)v32);
    uint64_t v7 = v21;
    if (v21)
    {
LABEL_15:
      uint64_t v22 = v7;
      operator delete(v7);
    }
  }
LABEL_17:
  MEMORY[0x1D25D9CD0](v19[0], 8);
  return v3;
}

void sub_1CC8B4AF4()
{
}

void sub_1CC8B4B30()
{
}

void *sub_1CC8B4B6C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v14 = 0;
  uint64_t result = (void *)sub_1CC8B4C28(a1, a2, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    char v11 = 0;
    uint64_t v10 = v12 + 8 * v13;
  }
  else
  {
    uint64_t result = sub_1CC8B4CD0((_DWORD *)a1, (uint64_t)a2, a2, v14);
    uint64_t v7 = result;
    *uint64_t result = *a2;
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v10 = v8 + 8 * v9;
    char v11 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v10;
  *(unsigned char *)(a3 + 16) = v11;
  return result;
}

uint64_t sub_1CC8B4C28(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_17:
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_17;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

void *sub_1CC8B4CD0(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v4 = *a1 >> 1;
  if (*a1) {
    unsigned int v5 = 8;
  }
  else {
    unsigned int v5 = a1[4];
  }
  if (4 * v4 + 4 >= 3 * v5)
  {
    v5 *= 2;
  }
  else if (v5 + ~v4 - a1[1] > v5 >> 3)
  {
    goto LABEL_5;
  }
  uint64_t v8 = (uint64_t)a1;
  sub_1CD64FCA0((uint64_t)a1, v5);
  uint64_t v9 = 0;
  sub_1CC8B4C28(v8, a3, &v9);
  a1 = (_DWORD *)v8;
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

llvm::AbstractAttribute *sub_1CC8B4D90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  unsigned int v13 = (llvm::AbstractAttribute *)sub_1CD6505A8(a1, &v56, a4, a5, 1);
  int v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  int v15 = (llvm::AbstractAttribute *)llvm::AANoSync::createForPosition((llvm::AANoSync *)&v56, (uint64_t **)a1, v14);
  sub_1CD6506F4(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoSync::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      int v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        int v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      int v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          int v29 = v36;
        }
        if (*v29 != v19) {
          int v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          int v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B52C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  unsigned int v13 = (llvm::AbstractAttribute *)sub_1CD650764(a1, &v56, a4, a5, 1);
  int v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  int v15 = (llvm::AbstractAttribute *)llvm::AAInstanceInfo::createForPosition((llvm::AAInstanceInfo *)&v56, (uint64_t **)a1, v14);
  sub_1CD6508B0(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAInstanceInfo::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      int v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        int v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      int v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          int v29 = v36;
        }
        if (*v29 != v19) {
          int v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          int v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B5800(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  unsigned int v13 = (llvm::AbstractAttribute *)sub_1CD650A8C(a1, &v56, a4, a5, 1);
  int v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  int v15 = (llvm::AbstractAttribute *)llvm::AAPointerInfo::createForPosition((llvm::AAPointerInfo *)&v56, (uint64_t **)a1, v14);
  sub_1CD650BD8(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAPointerInfo::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    BOOL v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    BOOL v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      int v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        int v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      int v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          int v29 = v36;
        }
        if (*v29 != v19) {
          int v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          int v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t sub_1CC8B5D38(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = 1;
  if ((*(unsigned char *)(a2 + 32) & 2) == 0 || !*(unsigned char *)(a2 + 24)) {
    return v3;
  }
  uint64_t v4 = *(void *)(a2 + 16);
  if (!**(unsigned char **)a1 || (a3 & 1) != 0)
  {
    if (!v4)
    {
      uint64_t v3 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8 || *(unsigned char *)(v8 + 16) != 61) {
        return v3;
      }
      uint64_t v11 = *(void *)(a1 + 8);
      unsigned int v12 = *(_DWORD *)(v11 + 8);
      if (v12 >= *(_DWORD *)(v11 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v11 + 8 * v12) = *(void *)(v8 - 64);
      ++*(_DWORD *)(v11 + 8);
      uint64_t v7 = *(void *)(a1 + 16);
      goto LABEL_11;
    }
  }
  else if (!v4 || *(unsigned __int8 *)(v4 + 16) - 11 >= 2)
  {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(v5 + 8);
  if (v6 >= *(_DWORD *)(v5 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)v5 + 8 * v6) = v4;
  ++*(_DWORD *)(v5 + 8);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(a2 + 8);
LABEL_11:
  unsigned int v9 = *(_DWORD *)(v7 + 8);
  if (v9 >= *(_DWORD *)(v7 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)v7 + 8 * v9) = v8;
  ++*(_DWORD *)(v7 + 8);
  return 1;
}

void *sub_1CC8B5EC4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = a2 + 8;
  if (*(_DWORD *)a2)
  {
    int v7 = 4;
    uint64_t v8 = a2 + 8;
  }
  else
  {
    int v7 = *(_DWORD *)(a2 + 16);
    if (!v7)
    {
      int v15 = 0;
LABEL_9:
      uint64_t result = sub_1CC00AEB8(a2, (uint64_t)a3, a3, v15);
      *uint64_t result = *a3;
      if (*(unsigned char *)a2)
      {
        uint64_t v16 = 4;
      }
      else
      {
        uint64_t v6 = *(void *)(a2 + 8);
        uint64_t v16 = *(unsigned int *)(a2 + 16);
      }
      uint64_t v17 = v6 + 8 * v16;
      char v18 = 1;
      goto LABEL_12;
    }
    uint64_t v8 = *(void *)(a2 + 8);
  }
  int v9 = v7 - 1;
  unsigned int v10 = ((*a3 >> 4) ^ (*a3 >> 9)) & v9;
  uint64_t result = (void *)(v8 + 8 * v10);
  uint64_t v12 = *result;
  if (*a3 != *result)
  {
    unsigned int v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v12 == -8192;
      }
      if (v19) {
        unsigned int v13 = result;
      }
      unsigned int v20 = v10 + v14++;
      unsigned int v10 = v20 & v9;
      uint64_t result = (void *)(v8 + 8 * v10);
      uint64_t v12 = *result;
      if (*a3 == *result) {
        goto LABEL_22;
      }
    }
    if (v13) {
      int v15 = v13;
    }
    else {
      int v15 = result;
    }
    goto LABEL_9;
  }
LABEL_22:
  if (*(_DWORD *)a2)
  {
    uint64_t v21 = 4;
  }
  else
  {
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v21 = *(unsigned int *)(a2 + 16);
  }
  char v18 = 0;
  uint64_t v17 = v6 + 8 * v21;
LABEL_12:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v17;
  *(unsigned char *)(a1 + 16) = v18;
  return result;
}

uint64_t sub_1CC8B5FE8(uint64_t a1, uint64_t a2, char a3)
{
  if ((*(unsigned char *)(a2 + 32) & 1) == 0) {
    return 1;
  }
  if (!**(unsigned char **)a1
    || (a3 & 1) != 0
    || (uint64_t v3 = *(void *)(a2 + 16)) != 0 && *(unsigned __int8 *)(v3 + 16) - 11 <= 1)
  {
    uint64_t v4 = *(void *)(a2 + 8);
    BOOL v5 = v4 && *(unsigned char *)(v4 + 16) == 60;
    BOOL v6 = v5;
    if (!**(unsigned char **)a1 || v6)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      unsigned int v9 = *(_DWORD *)(v8 + 8);
      if (v9 >= *(_DWORD *)(v8 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v8 + 8 * v9) = v4;
      ++*(_DWORD *)(v8 + 8);
      return 1;
    }
  }
  return 0;
}

void *sub_1CC8B60AC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  *(_DWORD *)(a1 + 16) = v5;
  if (v5)
  {
    BOOL v6 = operator new(24 * v5, (std::align_val_t)8uLL);
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    int v7 = *(const void **)a2;
    size_t v8 = 24 * *(unsigned int *)(a1 + 16);
    return memcpy(v6, v7, v8);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  return result;
}

unsigned int *sub_1CC8B6134(unsigned int *a1, uint64_t a2)
{
  if (a1 != (unsigned int *)a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = a1[2];
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v10 = 0;
        uint64_t v11 = *(void *)a2;
        uint64_t v12 = *(void **)a1;
        do
        {
          sub_1CC8B6390(&v12[v10], v11 + v10 * 8);
          v10 += 4;
        }
        while (4 * v4 != v10);
        uint64_t v5 = a1[2];
        unsigned int v13 = *(void **)a1;
        int v14 = &v12[v10];
      }
      else
      {
        unsigned int v13 = *(void **)a1;
        int v14 = *(void **)a1;
      }
      int v15 = &v13[4 * v5];
      if (v15 != v14)
      {
        uint64_t v16 = v15 - 4;
        uint64_t v17 = v15 - 4;
        do
        {
          char v18 = (void *)v17[3];
          if (v17 == v18)
          {
            (*(void (**)(void *))(*v17 + 32))(v17);
          }
          else if (v18)
          {
            (*(void (**)(void *))(*v18 + 40))(v18);
          }
          v16 -= 4;
          BOOL v19 = v17 == v14;
          v17 -= 4;
        }
        while (!v19);
      }
    }
    else
    {
      if (a1[3] < v4)
      {
        sub_1CC8B62E4(a1);
        sub_1CD650D18();
      }
      if (v5)
      {
        uint64_t v6 = *(void *)a2;
        int v7 = *(void **)a1;
        uint64_t v8 = 32 * v5;
        do
        {
          unsigned int v9 = sub_1CC8B6390(v7, v6);
          v6 += 32;
          int v7 = v9 + 4;
          v8 -= 32;
        }
        while (v8);
      }
      else
      {
        uint64_t v5 = 0;
      }
      uint64_t v20 = *(unsigned int *)(a2 + 8);
      if (v5 != v20)
      {
        uint64_t v21 = *(void *)a1 + 32 * v5;
        uint64_t v22 = *(void *)a2 + 32 * v5;
        uint64_t v23 = 32 * v20 - 32 * v5;
        do
        {
          uint64_t v24 = sub_1CC8B6674(v21, v22);
          v22 += 32;
          uint64_t v21 = v24 + 32;
          v23 -= 32;
        }
        while (v23);
      }
    }
    a1[2] = v4;
  }
  return a1;
}

unsigned int *sub_1CC8B62E4(unsigned int *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[2];
  if (v2)
  {
    uint64_t v3 = 32 * v2;
    uint64_t v4 = *(void *)result - 32;
    do
    {
      uint64_t result = *(unsigned int **)(v4 + v3 + 24);
      if ((unsigned int *)(v4 + v3) == result)
      {
        uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)(v4 + v3) + 32))(v4 + v3);
      }
      else if (result)
      {
        uint64_t result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)result + 40))(result);
      }
      v3 -= 32;
    }
    while (v3);
  }
  v1[2] = 0;
  return result;
}

void *sub_1CC8B6390(void *a1, uint64_t a2)
{
  v8[3] = *MEMORY[0x1E4F143B8];
  sub_1CC8B6674((uint64_t)v6, a2);
  if (v6 != a1)
  {
    uint64_t v3 = v7;
    uint64_t v4 = (void *)a1[3];
    if (v7 == v6)
    {
      if (v4 == a1)
      {
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, v8);
        (*(void (**)(void *))(*v7 + 32))(v7);
        int v7 = 0;
        (*(void (**)(void, void *))(*(void *)a1[3] + 24))(a1[3], v6);
        (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        int v7 = v6;
        (*(void (**)(void *, void *))(v8[0] + 24))(v8, a1);
        (*(void (**)(void *))(v8[0] + 32))(v8);
      }
      else
      {
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a1);
        (*(void (**)(void *))(*v7 + 32))(v7);
        int v7 = (void *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v4 == a1)
    {
      (*(void (**)(void *, void *))(*a1 + 24))(a1, v6);
      (*(void (**)(void))(*(void *)a1[3] + 32))(a1[3]);
      a1[3] = v7;
      int v7 = v6;
    }
    else
    {
      int v7 = (void *)a1[3];
      a1[3] = v3;
    }
  }
  if (v7 == v6)
  {
    (*(void (**)(void *))(v6[0] + 32))(v6);
  }
  else if (v7)
  {
    (*(void (**)(void))(*v7 + 40))();
  }
  return a1;
}

uint64_t sub_1CC8B6674(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

llvm::AbstractAttribute *sub_1CC8B670C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  unsigned int v13 = (llvm::AbstractAttribute *)sub_1CD651220(a1, &v56, a4, a5, 1);
  int v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  int v15 = (llvm::AbstractAttribute *)llvm::AAReturnedValues::createForPosition((llvm::AAReturnedValues *)&v56, (uint64_t **)a1, v14);
  sub_1CD65136C(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAReturnedValues::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      int v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        int v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      int v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        unsigned int v36 = 0;
LABEL_90:
        if (v36) {
          int v29 = v36;
        }
        if (*v29 != v19) {
          int v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          int v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t sub_1CC8B6C44(uint64_t a1)
{
  return (**(uint64_t (***)(void))a1)(*(void *)(*(void *)a1 + 8));
}

uint64_t sub_1CC8B6C50(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      int v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  int v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
LABEL_15:
    uint64_t result = 1;
  }
  else
  {
    unsigned int v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        unsigned int v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      int v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_15;
      }
    }
    uint64_t result = 0;
    if (v9) {
      int v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

BOOL sub_1CC8B6CF8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v26 = *a2;
  v27[0] = &v28;
  v27[1] = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)v27, (uint64_t)(a2 + 1));
    uint64_t v3 = v26;
  }
  uint64_t v4 = *a1;
  uint64_t v5 = *(void *)(*(void *)(v3 + 40) + 56);
  uint64_t v6 = *a1 + 4472;
  uint64_t v28 = 0;
  uint64_t v29 = v5;
  if (sub_1CC8B6C50(v6, &v29, &v28))
  {
    BOOL v7 = 1;
  }
  else
  {
    unsigned int v9 = *(uint64_t **)(v4 + 80);
    uint64_t v28 = 0;
    uint64_t v29 = v5;
    if (sub_1CD420258(v9, &v29, &v28) && (*(_DWORD *)(v5 + 32) & 0xFu) - 7 <= 1)
    {
      int v10 = (uint64_t *)a1[1];
      uint64_t v12 = *v10;
      uint64_t v11 = v10[1];
      if (v11 == *v10)
      {
        uint64_t v13 = *((unsigned int *)v10 + 5);
        int v14 = (void *)(v11 + 8 * v13);
        if (v13)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 8 * v13;
          while (*(void *)(v11 + v15) != v5)
          {
            v15 += 8;
            if (v16 == v15) {
              goto LABEL_29;
            }
          }
          int v14 = (void *)(v11 + v15);
        }
LABEL_29:
        uint64_t v12 = v10[1];
      }
      else
      {
        uint64_t v17 = *((unsigned int *)v10 + 4);
        int v18 = v17 - 1;
        unsigned int v19 = (v17 - 1) & ((v5 >> 4) ^ (v5 >> 9));
        int v14 = (void *)(v11 + 8 * v19);
        uint64_t v20 = *v14;
        if (*v14 == -1)
        {
          uint64_t v21 = 0;
LABEL_34:
          if (v21) {
            int v14 = v21;
          }
          if (*v14 != v5) {
            int v14 = (void *)(v11 + 8 * v17);
          }
        }
        else
        {
          uint64_t v21 = 0;
          int v22 = 1;
          while (v20 != v5)
          {
            if (v21) {
              BOOL v23 = 0;
            }
            else {
              BOOL v23 = v20 == -2;
            }
            if (v23) {
              uint64_t v21 = v14;
            }
            unsigned int v24 = v19 + v22++;
            unsigned int v19 = v24 & v18;
            int v14 = (void *)(v11 + 8 * (v24 & v18));
            uint64_t v20 = *v14;
            if (*v14 == -1) {
              goto LABEL_34;
            }
          }
        }
      }
      BOOL v23 = v11 == v12;
      uint64_t v25 = 16;
      if (v23) {
        uint64_t v25 = 20;
      }
      BOOL v7 = v14 == (void *)(v11 + 8 * *(unsigned int *)((char *)v10 + v25));
    }
    else
    {
      BOOL v7 = 0;
    }
  }
  if (v27[0] != &v28) {
    free(v27[0]);
  }
  return v7;
}

BOOL sub_1CC8B6EBC(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 24);
  unsigned int v3 = *(unsigned __int8 *)(v2 + 16);
  if (v3 < 0x1C) {
    return 0;
  }
  unsigned int v4 = v3 - 33;
  BOOL v5 = v4 > 0x33;
  uint64_t v6 = (1 << v4) & 0x8000000000041;
  if (v5 || v6 == 0) {
    return 0;
  }
  uint64_t v9 = *a1;
  uint64_t v10 = *(void *)(*(void *)(v2 + 40) + 56);
  uint64_t v12 = 0;
  return !sub_1CD40EA84(*(void *)v9, *(_DWORD *)(v9 + 16), v10, &v12) || *(void *)(v12 + 8) == 0;
}

BOOL sub_1CC8B6F50(void **a1, uint64_t a2)
{
  uint64_t v9 = *(llvm::CallBase **)a2;
  uint64_t v10 = &v12;
  uint64_t v11 = 0;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD41B598((uint64_t)&v10, a2 + 8);
  }
  if (sub_1CD46F814(&v9) && (uint64_t v5 = *(void *)v9, v5 == **(void **)(*((void *)sub_1CD46F814(&v9) + 3) + 16)))
  {
    if (v11
      || ((uint64_t v6 = *((void *)v9 - 4), v7 = *(unsigned __int8 *)(v6 + 16), v7 >= 0x15) ? (v8 = v7 == 24) : (v8 = 1), !v8))
    {
      uint64_t v6 = *((void *)v9 + 4 * *(unsigned int *)v10 + -4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF));
    }
    BOOL v3 = 0;
    if (!v11 && *(void *)v6 == **a1) {
      BOOL v3 = *((unsigned char *)v9 + 16) != 84 || (*((_WORD *)v9 + 9) & 3) != 2;
    }
  }
  else
  {
    BOOL v3 = 0;
  }
  if (v10 != &v12) {
    free(v10);
  }
  return v3;
}

BOOL sub_1CC8B7070(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 16) != 84 || (*(_WORD *)(a2 + 18) & 3) != 2;
}

void **sub_1CC8B708C(void *a1, void *a2, void **a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      uint64_t v6 = (void *)*v5;
      void *v5 = 0;
      unsigned int v7 = *a3;
      *a3 = v6;
      if (v7)
      {
        BOOL v8 = sub_1CD651E58(v7);
        MEMORY[0x1D25D9CE0](v8, 0x10E0C40D6C35413);
      }
      ++v5;
      ++a3;
    }
    while (v5 != a2);
  }
  return a3;
}

void *sub_1CC8B710C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD652130(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CC8B71D8(uint64_t a1, uint64_t a2)
{
  v80[16] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)a2;
  uint64_t v65 = *(void *)a2;
  uint64_t v66 = &v68;
  uint64_t v67 = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)&v66, a2 + 8);
    uint64_t v3 = v65;
  }
  uint64_t v4 = *(void *)(v3 + 64);
  unsigned int v78 = v80;
  uint64_t v79 = 0x1000000000;
  __src = v77;
  size_t __n = 0x1000000000;
  unint64_t v5 = *(uint64_t **)a1;
  if (*(_DWORD *)(*(void *)a1 + 8))
  {
    for (unint64_t i = 0; i < *(unsigned int *)(*(void *)a1 + 8); ++i)
    {
      uint64_t v7 = *v5;
      uint64_t v8 = *(void *)(*v5 + 8 * i);
      if (v8)
      {
        uint64_t v15 = *(void *)(v8 + 160);
        if (v15)
        {
          uint64_t v68 = v65;
          v69[0] = v70;
          v69[1] = 0;
          if (v67)
          {
            sub_1CD41B6B0((uint64_t)v69, (uint64_t)&v66);
            uint64_t v15 = *(void *)(v8 + 160);
            if (!v15) {
              sub_1CB920400();
            }
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t **))(*(void *)v15 + 48))(v15, v8, &v68, &v78);
          if (v69[0] != v70) {
            free(v69[0]);
          }
        }
        sub_1CC2FCB18((uint64_t)&__src, *(unsigned int *)(*(void *)(v7 + 8 * i) + 32), 0);
        goto LABEL_23;
      }
      if (!v67
        && ((uint64_t v9 = v65, v10 = *(unsigned __int8 *)(*(void *)(v65 - 32) + 16), v10 >= 0x15)
          ? (BOOL v11 = v10 == 24)
          : (BOOL v11 = 1),
            v11))
      {
        uint64_t v12 = i;
      }
      else
      {
        uint64_t v12 = *((unsigned int *)v66 + i + 1);
        if ((v12 & 0x80000000) != 0)
        {
          uint64_t v13 = 0;
          goto LABEL_17;
        }
        uint64_t v9 = v65;
      }
      uint64_t v13 = *(void *)(v9 - 32 * (*(_DWORD *)(v9 + 20) & 0x7FFFFFF) + 32 * v12);
LABEL_17:
      if (v79 >= (unint64_t)HIDWORD(v79)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v78[v79] = v13;
      LODWORD(v79) = v79 + 1;
      if (v4 && (i + 2) < *(_DWORD *)(v4 + 8)) {
        uint64_t v14 = *(void *)(v4 + 40 + 8 * (i + 2));
      }
      else {
        uint64_t v14 = 0;
      }
      if (__n >= (unint64_t)HIDWORD(__n)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)__src + __n) = v14;
      LODWORD(__n) = __n + 1;
LABEL_23:
      unint64_t v5 = *(uint64_t **)a1;
    }
  }
  unsigned int v72 = v74;
  uint64_t v73 = 0x400000000;
  int v16 = *(_DWORD *)(v3 + 20);
  if (v16 < 0)
  {
    unint64_t v48 = *(void *)(v3 - 32 * (v16 & 0x7FFFFFF) - 8);
    if ((v48 & 0xFFFFFFFF0) != 0)
    {
      uint64_t v49 = (v48 >> 4);
      uint64_t v50 = v3;
      do
      {
        uint64_t v51 = *(_DWORD *)(v3 + 20) & 0x7FFFFFF;
        uint64_t v52 = v3 - 32 * v51;
        char v53 = (unsigned int *)(v50 - (*(void *)(v52 - 8) + 32 * v51));
        uint64_t v54 = *v53;
        uint64_t v55 = v53[1];
        long long v56 = (const char *)*((void *)v53 - 1);
        v70[0] = (const char *)(v52 + 32 * v54);
        v70[1] = (const char *)(v55 - v54);
        v70[2] = v56;
        sub_1CD5C74F0((uint64_t)&v72, (uint64_t)v70);
        v50 += 16;
        --v49;
      }
      while (v49);
    }
  }
  uint64_t v17 = **(void **)(a1 + 8);
  if (*(unsigned char *)(v3 + 16) == 33)
  {
    if (v17) {
      uint64_t v43 = *(void *)(v17 + 24);
    }
    else {
      uint64_t v43 = 0;
    }
    uint64_t v46 = *(void *)(v3 - 96);
    uint64_t v47 = *(void *)(v3 - 64);
    __int16 v71 = 257;
    uint64_t v27 = sub_1CD4EF89C(v43, v17, v46, v47, v78, v79, (uint64_t)v72, v73, v70, (llvm::Instruction *)v3);
  }
  else
  {
    if (v17) {
      int v18 = *(uint64_t ***)(v17 + 24);
    }
    else {
      int v18 = 0;
    }
    uint64_t v63 = v78;
    uint64_t v61 = (char *)v72;
    uint64_t v19 = v73;
    __int16 v71 = 257;
    uint64_t v64 = (uint64_t **)v17;
    int v20 = 0;
    if (v73)
    {
      uint64_t v57 = 48 * v73;
      uint64_t v58 = (char *)v72 + 32;
      do
      {
        v20 += (*v58 - *(v58 - 1)) >> 3;
        v58 += 6;
        v57 -= 48;
      }
      while (v57);
    }
    uint64_t v62 = v79;
    int v21 = v79 + 1;
    uint64_t v22 = (v20 + v79 + 1);
    uint64_t v23 = (16 * v73);
    if (v23) {
      uint64_t v24 = (16 * v73) | 8u;
    }
    else {
      uint64_t v24 = 0;
    }
    uint64_t v25 = (char *)operator new(v24 + 32 * v22 + 80);
    uint64_t v26 = &v25[v24];
    uint64_t v27 = &v25[32 * v22 + v24];
    *((_DWORD *)v27 + 5) = v22 & 0x7FFFFFF | ((v23 != 0) << 31) | *((_DWORD *)v27 + 5) & 0x38000000;
    if (v22)
    {
      do
      {
        *(void *)uint64_t v26 = 0;
        *((void *)v26 + 1) = 0;
        *((void *)v26 + 2) = 0;
        *((void *)v26 + 3) = v27;
        v26 += 32;
      }
      while (v26 != v27);
    }
    if (v23) {
      *(void *)&v25[v23] = v23;
    }
    int v28 = 0;
    if (v19)
    {
      uint64_t v59 = 48 * v19;
      unint64_t v60 = v61 + 32;
      do
      {
        v28 += (*v60 - *(v60 - 1)) >> 3;
        v60 += 6;
        v59 -= 48;
      }
      while (v59);
    }
    *(void *)uint64_t v27 = *v18[2];
    *((void *)v27 + 1) = 0;
    unsigned int v29 = *((_DWORD *)v27 + 5) & 0xC0000000 | (v28 + v21) & 0x7FFFFFF;
    *((_DWORD *)v27 + 4) = 84;
    *((_DWORD *)v27 + 5) = v29;
    *(_OWORD *)(v27 + 24) = 0u;
    uint64_t v30 = v27 + 24;
    *(_OWORD *)(v27 + 40) = 0u;
    *((_DWORD *)v27 + 14) = 0;
    uint64_t v31 = *(void *)(v3 + 40);
    *((void *)v27 + 5) = v31;
    *(_WORD *)(v31 + 18) &= ~0x8000u;
    if ((v27[23] & 0x10) != 0)
    {
      uint64_t v44 = *(void *)(v31 + 56);
      if (v44)
      {
        uint64_t v45 = *(llvm::ValueSymbolTable **)(v44 + 104);
        if (v45) {
          llvm::ValueSymbolTable::reinsertValue(v45, (llvm::Value *)v27);
        }
      }
    }
    uint64_t v32 = *(void *)(v3 + 24);
    *((void *)v27 + 3) = v32;
    *((void *)v27 + 4) = v3 + 24;
    *(void *)(v32 + 8) = v30;
    *(void *)(v3 + 24) = v30;
    *((void *)v27 + 8) = 0;
    llvm::CallInst::init((uint64_t ***)v27, v18, v64, v63, v62, (uint64_t)v61, v19, v70);
    *((_WORD *)v27 + 9) = *((_WORD *)v27 + 9) & 0xFFFC | *(_WORD *)(v3 + 18) & 3;
  }
  v70[0] = (const char *)2;
  llvm::Instruction::copyMetadata((uint64_t)v27, v3, (int *)v70, 2);
  *((_WORD *)v27 + 9) = *((_WORD *)v27 + 9) & 0xF003 | *(_WORD *)(v3 + 18) & 0xFFC;
  llvm::Value::takeName((int32x2_t ****)v27, (llvm::Value *)v3);
  if (v4 && (int v33 = *(_DWORD *)(v4 + 8)) != 0)
  {
    uint64_t v34 = *(void *)(v4 + 40);
    if (v33 != 1)
    {
      uint64_t v35 = *(void *)(v4 + 48);
      goto LABEL_56;
    }
  }
  else
  {
    uint64_t v34 = 0;
  }
  uint64_t v35 = 0;
LABEL_56:
  *((void *)v27 + 8) = llvm::AttributeList::get(*(uint64_t **)(a1 + 16), v34, v35, __src, __n);
  uint64_t v36 = *(void *)(a1 + 24);
  unsigned int v37 = *(_DWORD *)(v36 + 8);
  if (v37 >= *(_DWORD *)(v36 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  BOOL v38 = (uint64_t *)(*(void *)v36 + 16 * v37);
  *BOOL v38 = v3;
  v38[1] = (uint64_t)v27;
  ++*(_DWORD *)(v36 + 8);
  unsigned int v39 = v72;
  if (v73)
  {
    uint64_t v40 = 48 * v73;
    size_t v41 = (char *)v72 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v41[v40]);
      v40 -= 48;
    }
    while (v40);
    unsigned int v39 = v72;
  }
  if (v39 != v74) {
    free(v39);
  }
  if (__src != v77) {
    free(__src);
  }
  if (v78 != v80) {
    free(v78);
  }
  if (v66 != &v68) {
    free(v66);
  }
  return 1;
}

uint64_t sub_1CC8B7874(_DWORD *a1, void *a2)
{
  unint64_t v5 = 0;
  uint64_t result = sub_1CC8B4C28((uint64_t)a1, a2, &v5);
  if (result)
  {
    void *v5 = -8192;
    int v4 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v4;
  }
  return result;
}

llvm::AbstractAttribute *sub_1CC8B78C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD652268(a1, &v56, a4, a5, 1);
  uint64_t v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  uint64_t v15 = (llvm::AbstractAttribute *)llvm::AAWillReturn::createForPosition((llvm::AAWillReturn *)&v56, (uint64_t **)a1, v14);
  sub_1CD6523B4(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAWillReturn::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    int v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    int v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    uint64_t v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      unsigned int v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        unsigned int v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      unsigned int v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          unsigned int v29 = v36;
        }
        if (*v29 != v19) {
          unsigned int v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          unsigned int v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      uint64_t v43 = v52;
    }
    else {
      uint64_t v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  uint64_t v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t sub_1CC8B7E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (byte_1EBD07860) {
    uint64_t v4 = a3;
  }
  else {
    uint64_t v4 = 0;
  }
  *(void *)&long long v44 = a2;
  *((void *)&v44 + 1) = v4;
  __p = &llvm::AAUndefinedBehavior::ID;
  long long v46 = v44;
  v42[0] = 0;
  uint64_t result = sub_1CD64CDF0((uint64_t *)(a1 + 32), (uint64_t)&__p, (uint64_t **)v42);
  if ((result & 1) != 0 && *((void *)v42[0] + 3)) {
    return result;
  }
  uint64_t v7 = (llvm::AbstractAttribute *)llvm::AAUndefinedBehavior::createForPosition((llvm::AAUndefinedBehavior *)&v44, (uint64_t **)a1, v6);
  sub_1CD652424(a1, (uint64_t)v7);
  uint64_t v8 = *(uint64_t **)(a1 + 5480);
  if (v8)
  {
    __p = &llvm::AAUndefinedBehavior::ID;
    v42[0] = 0;
    int v9 = sub_1CD420258(v8, &__p, v42) ^ 1;
  }
  else
  {
    int v9 = 0;
  }
  unint64_t v10 = v44 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v44 & 3) == 0) {
    unint64_t v10 = *(void *)(v10 + 24);
  }
  unsigned int v11 = *(unsigned __int8 *)(v10 + 16);
  if (!*(unsigned char *)(v10 + 16)) {
    goto LABEL_16;
  }
  if (v11 == 21)
  {
    uint64_t v12 = (unint64_t *)(v10 + 24);
  }
  else
  {
    if (v11 < 0x1C)
    {
      unint64_t v10 = 0;
      goto LABEL_23;
    }
    uint64_t v12 = (unint64_t *)(*(void *)(v10 + 40) + 56);
  }
  unint64_t v10 = *v12;
  if (*v12)
  {
LABEL_16:
    uint64_t v13 = *(void *)(v10 + 112);
    if (v13 && ((*(unsigned char *)(v13 + 14) & 2) != 0 || (*(unsigned char *)(v13 + 17) & 8) != 0))
    {
      BOOL v14 = 1;
    }
    else if (*(unsigned char *)(a1 + 5464))
    {
      BOOL v14 = 0;
    }
    else
    {
      int v16 = *(uint64_t **)(a1 + 88);
      uint64_t v18 = *v16;
      uint64_t v17 = v16[1];
      if (v17 == *v16)
      {
        uint64_t v19 = *((unsigned int *)v16 + 5);
        unsigned int v20 = (void *)(v17 + 8 * v19);
        if (v19)
        {
          uint64_t v21 = 0;
          uint64_t v22 = 8 * v19;
          while (*(void *)(v17 + v21) != v10)
          {
            v21 += 8;
            if (v22 == v21) {
              goto LABEL_44;
            }
          }
          unsigned int v20 = (void *)(v17 + v21);
        }
LABEL_44:
        uint64_t v18 = v16[1];
      }
      else
      {
        uint64_t v23 = *((unsigned int *)v16 + 4);
        int v24 = v23 - 1;
        unsigned int v25 = (v23 - 1) & ((v10 >> 4) ^ (v10 >> 9));
        unsigned int v20 = (void *)(v17 + 8 * v25);
        uint64_t v26 = *v20;
        if (*v20 == -1)
        {
          uint64_t v27 = 0;
LABEL_82:
          if (v27) {
            unsigned int v20 = v27;
          }
          if (*v20 != v10) {
            unsigned int v20 = (void *)(v17 + 8 * v23);
          }
        }
        else
        {
          uint64_t v27 = 0;
          int v28 = 1;
          while (v26 != v10)
          {
            if (v27) {
              BOOL v29 = 0;
            }
            else {
              BOOL v29 = v26 == -2;
            }
            if (v29) {
              uint64_t v27 = v20;
            }
            unsigned int v30 = v25 + v28++;
            unsigned int v25 = v30 & v24;
            unsigned int v20 = (void *)(v17 + 8 * (v30 & v24));
            uint64_t v26 = *v20;
            if (*v20 == -1) {
              goto LABEL_82;
            }
          }
        }
      }
      BOOL v29 = v17 == v18;
      uint64_t v31 = 16;
      if (v29) {
        uint64_t v31 = 20;
      }
      BOOL v14 = v20 == (void *)(v17 + 8 * *(unsigned int *)((char *)v16 + v31));
    }
    char v15 = 0;
    if (v14 | v9) {
      goto LABEL_75;
    }
    goto LABEL_49;
  }
LABEL_23:
  char v15 = 1;
  if (v9) {
    goto LABEL_75;
  }
LABEL_49:
  if (*(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength)
  {
LABEL_75:
    uint64_t v39 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 40))(v7);
    return (*(uint64_t (**)(uint64_t))(*(void *)v39 + 40))(v39);
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v7 + 72))(v42, v7);
  if (v43 >= 0) {
    size_t v32 = v43 & 0x7F;
  }
  else {
    size_t v32 = (size_t)v42[1];
  }
  p_p = &__p;
  sub_1CB907098((uint64_t)&__p, v32 + 12);
  if (v46 < 0) {
    p_p = __p;
  }
  if (v32)
  {
    if (v43 >= 0) {
      unsigned int v34 = v42;
    }
    else {
      unsigned int v34 = (void **)v42[0];
    }
    memmove(p_p, v34, v32);
  }
  strcpy((char *)p_p + v32, "::initialize");
  uint64_t v35 = (uint64_t *)off_1EC7DFC00();
  if (*v35)
  {
    if (v46 >= 0) {
      uint64_t v36 = &__p;
    }
    else {
      uint64_t v36 = __p;
    }
    if (v46 >= 0) {
      uint64_t v37 = HIBYTE(v46) & 0x7F;
    }
    else {
      uint64_t v37 = v46;
    }
    llvm::timeTraceProfilerBegin((uint64_t)v36, v37, (uint64_t)"", 0);
  }
  if (SHIBYTE(v46) < 0) {
    operator delete(__p);
  }
  if (v43 < 0) {
    operator delete(v42[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v7 + 24))(v7, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v35)
  {
    sub_1CD84B62C(*v35);
    if (v15) {
      goto LABEL_74;
    }
LABEL_78:
    uint64_t v40 = *(uint64_t **)(a1 + 80);
    __p = (void *)v10;
    v42[0] = 0;
    if ((sub_1CD420258(v40, &__p, v42) & 1) == 0)
    {
      size_t v41 = *(uint64_t **)(a1 + 80);
      __p = (void *)sub_1CD648A0C((llvm::IRPosition *)&v44);
      v42[0] = 0;
      if ((sub_1CD420258(v41, &__p, v42) & 1) == 0) {
        goto LABEL_75;
      }
    }
    goto LABEL_74;
  }
  if ((v15 & 1) == 0) {
    goto LABEL_78;
  }
LABEL_74:
  int v38 = *(_DWORD *)(a1 + 4368);
  if (v38 == 2) {
    goto LABEL_75;
  }
  *(_DWORD *)(a1 + 4368) = 1;
  uint64_t result = llvm::Attributor::updateAA((llvm::Attributor *)a1, v7);
  *(_DWORD *)(a1 + 4368) = v38;
  return result;
}

llvm::AbstractAttribute *sub_1CC8B82A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD652494(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANoUnwind::createForPosition((llvm::AANoUnwind *)&v56, (uint64_t **)a1, v14);
  sub_1CD6525E0(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoUnwind::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B87DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD652650(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANoFree::createForPosition((llvm::AANoFree *)&v56, (uint64_t **)a1, v14);
  sub_1CD65279C(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoFree::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B8D14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD65280C(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANoReturn::createForPosition((llvm::AANoReturn *)&v56, (uint64_t **)a1, v14);
  sub_1CD652958(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoReturn::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B924C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD6529C8(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AAAssumptionInfo::createForPosition((llvm::AAAssumptionInfo *)&v56, (uint64_t **)a1, v14);
  sub_1CD652B14(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAAssumptionInfo::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B9784(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD652B84(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AAHeapToStack::createForPosition((llvm::AAHeapToStack *)&v56, (uint64_t **)a1, v14);
  sub_1CD652CD0(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAHeapToStack::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8B9CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD652D40(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANoUndef::createForPosition((llvm::AANoUndef *)&v56, (uint64_t **)a1, v14);
  sub_1CD652E8C(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoUndef::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8BA1F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD652EFC(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AAAlign::createForPosition((llvm::AAAlign *)&v56, (uint64_t **)a1, v14);
  sub_1CD653048(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAAlign::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8BA72C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD6530B8(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANonNull::createForPosition((llvm::AANonNull *)&v56, (uint64_t **)a1, v14);
  sub_1CD653204(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANonNull::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8BAC64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD653274(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANoAlias::createForPosition((llvm::AANoAlias *)&v56, (uint64_t **)a1, v14);
  sub_1CD6533C0(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoAlias::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    uint64_t v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    uint64_t v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    unsigned int v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      BOOL v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        BOOL v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      BOOL v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          BOOL v29 = v36;
        }
        if (*v29 != v19) {
          BOOL v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          BOOL v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  char v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    char v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8BB19C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v57 = a2;
  *((void *)&v57 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD653430(a1, &v57, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  llvm::AADereferenceable::createForPosition((llvm::AADereferenceable *)&v57, (uint64_t **)a1, v14);
  char v15 = (llvm::AbstractAttribute *)v17;
  sub_1CD65357C(a1, v17);
  int v18 = *(uint64_t **)(a1 + 5480);
  if (v18)
  {
    __p[0] = &llvm::AADereferenceable::ID;
    v53[0] = 0;
    int v19 = sub_1CD420258(v18, __p, v53) ^ 1;
  }
  else
  {
    int v19 = 0;
  }
  uint64_t v20 = v57 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v57 & 3) == 0) {
    uint64_t v20 = *(void *)(v20 + 24);
  }
  unsigned int v21 = *(unsigned __int8 *)(v20 + 16);
  if (!*(unsigned char *)(v20 + 16)) {
    goto LABEL_20;
  }
  if (v21 == 21)
  {
    uint64_t v22 = (uint64_t *)(v20 + 24);
  }
  else
  {
    if (v21 < 0x1C)
    {
      uint64_t v20 = 0;
      goto LABEL_27;
    }
    uint64_t v22 = (uint64_t *)(*(void *)(v20 + 40) + 56);
  }
  uint64_t v20 = *v22;
  if (!*v22)
  {
LABEL_27:
    char v25 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v23 = *(void *)(v20 + 112);
  if (v23 && ((*(unsigned char *)(v23 + 14) & 2) != 0 || (*(unsigned char *)(v23 + 17) & 8) != 0))
  {
    BOOL v24 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v24 = 0;
  }
  else
  {
    uint64_t v26 = *(uint64_t **)(a1 + 88);
    uint64_t v28 = *v26;
    uint64_t v27 = v26[1];
    if (v27 == *v26)
    {
      uint64_t v29 = *((unsigned int *)v26 + 5);
      uint64_t v30 = (void *)(v27 + 8 * v29);
      if (v29)
      {
        uint64_t v31 = 0;
        uint64_t v32 = 8 * v29;
        while (*(void *)(v27 + v31) != v20)
        {
          v31 += 8;
          if (v32 == v31) {
            goto LABEL_47;
          }
        }
        uint64_t v30 = (void *)(v27 + v31);
      }
LABEL_47:
      uint64_t v28 = v26[1];
    }
    else
    {
      uint64_t v33 = *((unsigned int *)v26 + 4);
      int v34 = v33 - 1;
      unsigned int v35 = (v33 - 1) & ((v20 >> 4) ^ (v20 >> 9));
      uint64_t v30 = (void *)(v27 + 8 * v35);
      uint64_t v36 = *v30;
      if (*v30 == -1)
      {
        int v37 = 0;
LABEL_90:
        if (v37) {
          uint64_t v30 = v37;
        }
        if (*v30 != v20) {
          uint64_t v30 = (void *)(v27 + 8 * v33);
        }
      }
      else
      {
        int v37 = 0;
        int v38 = 1;
        while (v36 != v20)
        {
          if (v37) {
            BOOL v39 = 0;
          }
          else {
            BOOL v39 = v36 == -2;
          }
          if (v39) {
            int v37 = v30;
          }
          unsigned int v40 = v35 + v38++;
          unsigned int v35 = v40 & v34;
          uint64_t v30 = (void *)(v27 + 8 * (v40 & v34));
          uint64_t v36 = *v30;
          if (*v30 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v39 = v27 == v28;
    uint64_t v41 = 16;
    if (v39) {
      uint64_t v41 = 20;
    }
    BOOL v24 = v30 == (void *)(v27 + 8 * *(unsigned int *)((char *)v26 + v41));
  }
  char v25 = 0;
  LOBYTE(v19) = (v24 | v19) != 0;
LABEL_52:
  if ((v19 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v53, v15);
  if (v54 >= 0) {
    size_t v42 = v54 & 0x7F;
  }
  else {
    size_t v42 = (size_t)v53[1];
  }
  char v43 = __p;
  sub_1CB907098((uint64_t)__p, v42 + 12);
  if (v56 < 0) {
    char v43 = (void **)__p[0];
  }
  if (v42)
  {
    if (v54 >= 0) {
      long long v44 = v53;
    }
    else {
      long long v44 = (void **)v53[0];
    }
    memmove(v43, v44, v42);
  }
  strcpy((char *)v43 + v42, "::initialize");
  uint64_t v45 = (uint64_t *)off_1EC7DFC00();
  if (*v45)
  {
    if (v56 >= 0) {
      uint64_t v46 = __p;
    }
    else {
      uint64_t v46 = (void **)__p[0];
    }
    if (v56 >= 0) {
      uint64_t v47 = v56 & 0x7F;
    }
    else {
      uint64_t v47 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v46, v47, (uint64_t)"", 0);
  }
  if (v56 < 0) {
    operator delete(__p[0]);
  }
  if (v54 < 0) {
    operator delete(v53[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v45)
  {
    sub_1CD84B62C(*v45);
    if (v25) {
      goto LABEL_78;
    }
  }
  else if (v25)
  {
    goto LABEL_78;
  }
  uint64_t v51 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v20;
  v53[0] = 0;
  if ((sub_1CD420258(v51, __p, v53) & 1) == 0)
  {
    uint64_t v52 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v57);
    v53[0] = 0;
    if ((sub_1CD420258(v52, __p, v53) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v48 = *(_DWORD *)(a1 + 4368);
  if (v48 == 2)
  {
LABEL_79:
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v49 + 40))(v49);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v48;
  }
  if (a4)
  {
    uint64_t v50 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v50 + 16))(v50)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8BB6D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD6535EC(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AANoCapture::createForPosition((llvm::AANoCapture *)&v56, (uint64_t **)a1, v14);
  sub_1CD653738(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AANoCapture::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    unsigned int v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    unsigned int v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    char v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  size_t v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    size_t v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

llvm::AbstractAttribute *sub_1CC8BBC0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (byte_1EBD07860) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 0;
  }
  *(void *)&long long v56 = a2;
  *((void *)&v56 + 1) = v12;
  uint64_t v13 = (llvm::AbstractAttribute *)sub_1CD6537A8(a1, &v56, a4, a5, 1);
  char v15 = v13;
  if (v13 && a6)
  {
    if (*(_DWORD *)(a1 + 4368) == 1) {
      llvm::Attributor::updateAA((llvm::Attributor *)a1, v13);
    }
    return v15;
  }
  if (v13) {
    return v15;
  }
  char v15 = (llvm::AbstractAttribute *)llvm::AAPrivatizablePtr::createForPosition((llvm::AAPrivatizablePtr *)&v56, (uint64_t **)a1, v14);
  sub_1CD6538F4(a1, (uint64_t)v15);
  uint64_t v17 = *(uint64_t **)(a1 + 5480);
  if (v17)
  {
    __p[0] = &llvm::AAPrivatizablePtr::ID;
    v52[0] = 0;
    int v18 = sub_1CD420258(v17, __p, v52) ^ 1;
  }
  else
  {
    int v18 = 0;
  }
  uint64_t v19 = v56 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v56 & 3) == 0) {
    uint64_t v19 = *(void *)(v19 + 24);
  }
  unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
  if (!*(unsigned char *)(v19 + 16)) {
    goto LABEL_20;
  }
  if (v20 == 21)
  {
    unsigned int v21 = (uint64_t *)(v19 + 24);
  }
  else
  {
    if (v20 < 0x1C)
    {
      uint64_t v19 = 0;
      goto LABEL_27;
    }
    unsigned int v21 = (uint64_t *)(*(void *)(v19 + 40) + 56);
  }
  uint64_t v19 = *v21;
  if (!*v21)
  {
LABEL_27:
    char v24 = 1;
    goto LABEL_52;
  }
LABEL_20:
  uint64_t v22 = *(void *)(v19 + 112);
  if (v22 && ((*(unsigned char *)(v22 + 14) & 2) != 0 || (*(unsigned char *)(v22 + 17) & 8) != 0))
  {
    BOOL v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v23 = 0;
  }
  else
  {
    char v25 = *(uint64_t **)(a1 + 88);
    uint64_t v27 = *v25;
    uint64_t v26 = v25[1];
    if (v26 == *v25)
    {
      uint64_t v28 = *((unsigned int *)v25 + 5);
      uint64_t v29 = (void *)(v26 + 8 * v28);
      if (v28)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 8 * v28;
        while (*(void *)(v26 + v30) != v19)
        {
          v30 += 8;
          if (v31 == v30) {
            goto LABEL_47;
          }
        }
        uint64_t v29 = (void *)(v26 + v30);
      }
LABEL_47:
      uint64_t v27 = v25[1];
    }
    else
    {
      uint64_t v32 = *((unsigned int *)v25 + 4);
      int v33 = v32 - 1;
      unsigned int v34 = (v32 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v29 = (void *)(v26 + 8 * v34);
      uint64_t v35 = *v29;
      if (*v29 == -1)
      {
        uint64_t v36 = 0;
LABEL_90:
        if (v36) {
          uint64_t v29 = v36;
        }
        if (*v29 != v19) {
          uint64_t v29 = (void *)(v26 + 8 * v32);
        }
      }
      else
      {
        uint64_t v36 = 0;
        int v37 = 1;
        while (v35 != v19)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v35 == -2;
          }
          if (v38) {
            uint64_t v36 = v29;
          }
          unsigned int v39 = v34 + v37++;
          unsigned int v34 = v39 & v33;
          uint64_t v29 = (void *)(v26 + 8 * (v39 & v33));
          uint64_t v35 = *v29;
          if (*v29 == -1) {
            goto LABEL_90;
          }
        }
      }
    }
    BOOL v38 = v26 == v27;
    uint64_t v40 = 16;
    if (v38) {
      uint64_t v40 = 20;
    }
    BOOL v23 = v29 == (void *)(v26 + 8 * *(unsigned int *)((char *)v25 + v40));
  }
  char v24 = 0;
  LOBYTE(v18) = (v23 | v18) != 0;
LABEL_52:
  if ((v18 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_79;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v15 + 72))(v52, v15);
  if (v53 >= 0) {
    size_t v41 = v53 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v52[1];
  }
  size_t v42 = __p;
  sub_1CB907098((uint64_t)__p, v41 + 12);
  if (v55 < 0) {
    size_t v42 = (void **)__p[0];
  }
  if (v41)
  {
    if (v53 >= 0) {
      char v43 = v52;
    }
    else {
      char v43 = (void **)v52[0];
    }
    memmove(v42, v43, v41);
  }
  strcpy((char *)v42 + v41, "::initialize");
  long long v44 = (uint64_t *)off_1EC7DFC00();
  if (*v44)
  {
    if (v55 >= 0) {
      uint64_t v45 = __p;
    }
    else {
      uint64_t v45 = (void **)__p[0];
    }
    if (v55 >= 0) {
      uint64_t v46 = v55 & 0x7F;
    }
    else {
      uint64_t v46 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v45, v46, (uint64_t)"", 0);
  }
  if (v55 < 0) {
    operator delete(__p[0]);
  }
  if (v53 < 0) {
    operator delete(v52[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v15 + 24))(v15, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v44)
  {
    sub_1CD84B62C(*v44);
    if (v24) {
      goto LABEL_78;
    }
  }
  else if (v24)
  {
    goto LABEL_78;
  }
  uint64_t v50 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v19;
  v52[0] = 0;
  if ((sub_1CD420258(v50, __p, v52) & 1) == 0)
  {
    uint64_t v51 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v56);
    v52[0] = 0;
    if ((sub_1CD420258(v51, __p, v52) & 1) == 0) {
      goto LABEL_79;
    }
  }
LABEL_78:
  int v47 = *(_DWORD *)(a1 + 4368);
  if (v47 == 2)
  {
LABEL_79:
    uint64_t v48 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    (*(void (**)(uint64_t))(*(void *)v48 + 40))(v48);
    return v15;
  }
  if (a7)
  {
    *(_DWORD *)(a1 + 4368) = 1;
    llvm::Attributor::updateAA((llvm::Attributor *)a1, v15);
    *(_DWORD *)(a1 + 4368) = v47;
  }
  if (a4)
  {
    uint64_t v49 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 40))(v15);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v49 + 16))(v49)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v15, a4, a5);
    }
  }
  return v15;
}

uint64_t sub_1CC8BC144(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = (llvm::Attributor *)*a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (!*(unsigned char *)(a2 + 16)
    || v4 >= 0x1C
    && ((unsigned int v5 = v4 - 33, v6 = v5 > 0x33, v7 = (1 << v5) & 0x8000000000041, !v6) ? (v8 = v7 == 0) : (v8 = 1), !v8))
  {
    a2 |= 2uLL;
  }
  sub_1CC8AC178(*a1, a2, 0, 0, 2, 0, 1);
  uint64_t v9 = *(void *)(v2 - 32);
  if (!v9 || *(unsigned char *)(v9 + 16) || *(void *)(v9 + 24) != *(void *)(v2 + 72)) {
    return 1;
  }
  sub_1CC8B924C((uint64_t)v3, v2, 0, 0, 2, 0, 1);
  if (byte_1EBCDDA38) {
    goto LABEL_12;
  }
  if (!*(unsigned char *)(v9 + 16))
  {
    if (*(void *)(v9 + 72) == v9 + 72 && (*(unsigned char *)(v9 + 34) & 0x80) == 0)
    {
      int v22 = *(_DWORD *)(v9 + 20);
      goto LABEL_36;
    }
LABEL_12:
    if (*(unsigned char *)(**(void **)(*(void *)(v9 + 24) + 16) + 8) != 7 && *(void *)(v2 + 8) != 0) {
      sub_1CC8AB8F0((uint64_t)v3, v2 | 1, 0, 0, 2, 0, 1);
    }
    int v11 = *(unsigned __int8 *)(v2 + 16);
    if (v11 == 84)
    {
      uint64_t v12 = 0;
    }
    else if (v11 == 39)
    {
      uint64_t v12 = (*(_DWORD *)(v2 + 80) + 1);
    }
    else
    {
      uint64_t v12 = 2;
    }
    uint64_t v13 = 0;
    int v14 = *(_DWORD *)(v2 + 20);
    uint64_t v15 = -(uint64_t)(v14 & 0x7FFFFFF);
    if (v14 < 0)
    {
      uint64_t v39 = v2 - 32 * (v14 & 0x7FFFFFF);
      uint64_t v40 = *(void *)(v39 - 8);
      if ((v40 & 0xFFFFFFFF0) != 0) {
        uint64_t v13 = (*(_DWORD *)(v39 - 12) - *(_DWORD *)(v39 - v40));
      }
      else {
        uint64_t v13 = 0;
      }
    }
    unint64_t v16 = -32 * v12 - 32 * v13 - 32 * v15 - 32;
    if ((int)(v16 >> 5) >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = v16 & 0x1FFFFFFFE0;
      do
      {
        int v19 = *(_DWORD *)(v2 + 20);
        if ((v19 & 0x40000000) != 0) {
          uint64_t v20 = *(void *)(v2 - 8);
        }
        else {
          uint64_t v20 = v2 - 32 * (v19 & 0x7FFFFFF);
        }
        uint64_t v42 = (v17 + v20) | 3;
        uint64_t v43 = 0;
        sub_1CC8AC178((uint64_t)v3, v42, 0, 0, 2, 0, 1);
        BOOL v41 = 0;
        llvm::Attributor::getAssumedSimplified(v3, (const llvm::IRPosition *)&v42, 0, &v41);
        sub_1CC8B9CBC((uint64_t)v3, v42, v43, 0, 2, 0, 1);
        if (*(unsigned char *)(**(void **)(v2 - 32 * (*(_DWORD *)(v2 + 20) & 0x7FFFFFF) + v17) + 8) == 15)
        {
          sub_1CC8BA72C((uint64_t)v3, v42, v43, 0, 2, 0, 1);
          sub_1CC8BB6D4((uint64_t)v3, v42, v43, 0, 2, 0, 1);
          sub_1CC8BAC64((uint64_t)v3, v42, v43, 0, 2, 0, 1);
          sub_1CC8BB19C((uint64_t)v3, v42, v43, 0, 2, 0, 1);
          sub_1CC8BA1F4((uint64_t)v3, v42, v43, 0, 2, 0, 1);
          sub_1CC8B2D1C((uint64_t)v3, v42, v43, 0, 2, 0, 1);
          sub_1CC8B87DC((uint64_t)v3, v42, v43, 0, 2, 0, 1);
        }
        v17 += 32;
      }
      while (v18 != v17);
    }
    return 1;
  }
  if (*(unsigned char *)(v9 + 16) != 3) {
    goto LABEL_12;
  }
  int v22 = *(_DWORD *)(v9 + 20);
  if ((v22 & 0x7FFFFFF) != 0) {
    goto LABEL_12;
  }
LABEL_36:
  if ((v22 & 0x20000000) == 0) {
    return 1;
  }
  uint64_t v23 = ***(void ***)v9;
  uint64_t v42 = v9;
  int v24 = *(_DWORD *)(v23 + 2496);
  if (!v24)
  {
    int v37 = 0;
LABEL_57:
    uint64_t v28 = sub_1CC609054(v23 + 2480, (uint64_t)&v42, &v42, v37);
    uint64_t v38 = v42;
    void v28[3] = 0;
    v28[4] = 0;
    *uint64_t v28 = v38;
    v28[1] = v28 + 3;
    _OWORD v28[2] = 0x100000000;
    goto LABEL_47;
  }
  uint64_t v25 = *(void *)(v23 + 2480);
  int v26 = v24 - 1;
  unsigned int v27 = v26 & ((v9 >> 4) ^ (v9 >> 9));
  uint64_t v28 = (void *)(v25 + 40 * v27);
  uint64_t v29 = *v28;
  if (*v28 != v9)
  {
    uint64_t v30 = 0;
    int v31 = 1;
    while (v29 != -4096)
    {
      if (v30) {
        BOOL v32 = 0;
      }
      else {
        BOOL v32 = v29 == -8192;
      }
      if (v32) {
        uint64_t v30 = v28;
      }
      unsigned int v33 = v27 + v31++;
      unsigned int v27 = v33 & v26;
      uint64_t v28 = (void *)(v25 + 40 * v27);
      uint64_t v29 = *v28;
      if (*v28 == v9) {
        goto LABEL_47;
      }
    }
    if (v30) {
      int v37 = v30;
    }
    else {
      int v37 = v28;
    }
    goto LABEL_57;
  }
LABEL_47:
  uint64_t v34 = *((unsigned int *)v28 + 4);
  if (v34)
  {
    uint64_t v35 = (void *)(v28[1] + 8);
    uint64_t v36 = 16 * v34;
    while (*((_DWORD *)v35 - 2) != 26)
    {
      v35 += 2;
      v36 -= 16;
      if (!v36) {
        return 1;
      }
    }
    if (*v35) {
      goto LABEL_12;
    }
  }
  return 1;
}

uint64_t sub_1CC8BC598(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *a1;
  int v4 = *(unsigned __int8 *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 - 32);
  unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v4 == 60)
  {
    if (v6 != 21)
    {
      if (v6 < 0x1C)
      {
        if (!*(unsigned char *)(v5 + 16)) {
          v5 |= 2uLL;
        }
      }
      else
      {
        unsigned int v7 = v6 - 33;
        BOOL v8 = v7 > 0x33;
        uint64_t v9 = (1 << v7) & 0x8000000000041;
        if (!v8 && v9 != 0) {
          v5 |= 1uLL;
        }
      }
    }
    sub_1CC8BA1F4(*a1, v5, 0, 0, 2, 0, 1);
    if (byte_1EBCDDD38)
    {
      unsigned int v14 = *(unsigned __int8 *)(v2 + 16);
      if (v14 != 21)
      {
        if (v14 < 0x1C)
        {
          if (!*(unsigned char *)(v2 + 16)) {
            v2 |= 2uLL;
          }
        }
        else
        {
          unsigned int v15 = v14 - 33;
          if (v15 <= 0x33 && ((1 << v15) & 0x8000000000041) != 0) {
            v2 |= 1uLL;
          }
        }
      }
      sub_1CC8AB8F0(v3, v2, 0, 0, 2, 0, 1);
    }
  }
  else
  {
    if (v6 != 21)
    {
      if (v6 < 0x1C)
      {
        if (!*(unsigned char *)(v5 + 16)) {
          v5 |= 2uLL;
        }
      }
      else
      {
        unsigned int v11 = v6 - 33;
        BOOL v8 = v11 > 0x33;
        uint64_t v12 = (1 << v11) & 0x8000000000041;
        if (!v8 && v12 != 0) {
          v5 |= 1uLL;
        }
      }
    }
    sub_1CC8BA1F4(*a1, v5, 0, 0, 2, 0, 1);
  }
  return 1;
}

void sub_1CC8BC70C(uint64_t a1, llvm::raw_ostream *a2, llvm::Twine *this, char a4, llvm::Twine *a5, uint64_t a6)
{
  if (*(char *)(a6 + 23) < 0) {
    uint64_t v11 = *(void *)(a6 + 8);
  }
  else {
    uint64_t v11 = *(unsigned __int8 *)(a6 + 23);
  }
  int v49 = 0;
  if (v11)
  {
    __int16 v44 = 260;
    uint64_t v42 = a6;
    *(void *)&long long v47 = llvm::sys::fs::openFile((unsigned __int8 *)&v42, &v49, 0, 2, 1, 438);
    *((void *)&v47 + 1) = v12;
    uint64_t v13 = std::generic_category();
    uint64_t v42 = 17;
    uint64_t v43 = v13;
    unsigned int v14 = (llvm *)(*(uint64_t (**)(void, void, uint64_t *))(**((void **)&v47 + 1) + 32))(*((void *)&v47 + 1), v47, &v42);
    if (v14
      || (unsigned int v14 = (llvm *)((uint64_t (*)(const std::error_category *, long long *, void))v43->equivalent_0)(v43, &v47, v42), v14))
    {
      uint64_t v20 = (llvm::raw_ostream *)llvm::errs(v14);
      unsigned int v21 = (void *)*((void *)v20 + 4);
      if (*((void *)v20 + 3) - (void)v21 > 0x17uLL)
      {
        qmemcpy(v21, "file exists, overwriting", 24);
        int v22 = (unsigned char *)(*((void *)v20 + 4) + 24);
        *((void *)v20 + 4) = v22;
      }
      else
      {
        uint64_t v20 = llvm::raw_ostream::write(v20, "file exists, overwriting", 0x18uLL);
        int v22 = (unsigned char *)*((void *)v20 + 4);
      }
      uint64_t v23 = (unsigned char *)*((void *)v20 + 3);
    }
    else
    {
      int v15 = v47;
      unint64_t v16 = (llvm::raw_ostream *)llvm::errs(v14);
      uint64_t v17 = (char *)*((void *)v16 + 4);
      unint64_t v18 = *((void *)v16 + 3) - (void)v17;
      if (v15)
      {
        if (v18 > 0x16)
        {
          qmemcpy(v17, "error writing into file", 23);
          int v19 = (unsigned char *)(*((void *)v16 + 4) + 23);
          *((void *)v16 + 4) = v19;
        }
        else
        {
          unint64_t v16 = llvm::raw_ostream::write(v16, "error writing into file", 0x17uLL);
          int v19 = (unsigned char *)*((void *)v16 + 4);
        }
        if (*((unsigned char **)v16 + 3) == v19)
        {
          llvm::raw_ostream::write(v16, "\n", 1uLL);
        }
        else
        {
          *int v19 = 10;
          ++*((void *)v16 + 4);
        }
        *(unsigned char *)(a1 + 23) = 0;
        *(unsigned char *)a1 = 0;
        return;
      }
      if (v18 > 0x21)
      {
        qmemcpy(v17, "writing to the newly created file ", 34);
        *((void *)v16 + 4) += 34;
      }
      else
      {
        unint64_t v16 = llvm::raw_ostream::write(v16, "writing to the newly created file ", 0x22uLL);
      }
      char v24 = *(unsigned char *)(a6 + 23);
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        int v26 = (const char *)a6;
      }
      else {
        int v26 = *(const char **)a6;
      }
      size_t v27 = v24 & 0x7F;
      if (v25) {
        size_t v28 = *(void *)(a6 + 8);
      }
      else {
        size_t v28 = v27;
      }
      uint64_t v20 = llvm::raw_ostream::write(v16, v26, v28);
      uint64_t v23 = (unsigned char *)*((void *)v20 + 3);
      int v22 = (unsigned char *)*((void *)v20 + 4);
    }
    if (v23 == v22)
    {
      llvm::raw_ostream::write(v20, "\n", 1uLL);
    }
    else
    {
      *int v22 = 10;
      ++*((void *)v20 + 4);
    }
  }
  else
  {
    llvm::Twine::str(this, __p);
    __int16 v44 = 260;
    uint64_t v42 = (uint64_t)__p;
    llvm::createGraphFilename((llvm *)&v42, (const llvm::Twine *)&v49, (uint64_t)&v47);
    if (*(char *)(a6 + 23) < 0) {
      operator delete(*(void **)a6);
    }
    *(_OWORD *)a6 = v47;
    *(void *)(a6 + 16) = v48;
    HIBYTE(v48) = 0;
    LOBYTE(v47) = 0;
    if (v46 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v29 = (llvm *)llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v42, v49, 1, 0, 0);
  if (v49 == -1)
  {
    uint64_t v30 = (llvm::raw_ostream *)llvm::errs(v29);
    uint64_t v31 = *((void *)v30 + 4);
    if ((unint64_t)(*((void *)v30 + 3) - v31) > 0x13)
    {
      *(_DWORD *)(v31 + 16) = 656434540;
      *(_OWORD *)uint64_t v31 = *(_OWORD *)"error opening file '";
      *((void *)v30 + 4) += 20;
    }
    else
    {
      uint64_t v30 = llvm::raw_ostream::write(v30, "error opening file '", 0x14uLL);
    }
    char v32 = *(unsigned char *)(a6 + 23);
    BOOL v33 = v32 < 0;
    if (v32 >= 0) {
      uint64_t v34 = (const char *)a6;
    }
    else {
      uint64_t v34 = *(const char **)a6;
    }
    size_t v35 = v32 & 0x7F;
    if (v33) {
      size_t v36 = *(void *)(a6 + 8);
    }
    else {
      size_t v36 = v35;
    }
    int v37 = llvm::raw_ostream::write(v30, v34, v36);
    uint64_t v38 = (void *)*((void *)v37 + 4);
    if (*((void *)v37 + 3) - (void)v38 > 0xEuLL)
    {
      qmemcpy(v38, "' for writing!\n", 15);
      *((void *)v37 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v37, "' for writing!\n", 0xFuLL);
    }
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
  }
  else
  {
    uint64_t v39 = sub_1CD64C67C((llvm::raw_ostream *)&v42, a2, a4, a5);
    uint64_t v40 = (llvm::raw_ostream *)llvm::errs(v39);
    BOOL v41 = (void *)*((void *)v40 + 4);
    if (*((void *)v40 + 3) - (void)v41 > 7uLL)
    {
      *BOOL v41 = 0xA202E656E6F6420;
      *((void *)v40 + 4) += 8;
    }
    else
    {
      llvm::raw_ostream::write(v40, " done. \n", 8uLL);
    }
    *(_OWORD *)a1 = *(_OWORD *)a6;
    *(void *)(a1 + 16) = *(void *)(a6 + 16);
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
    *(void *)a6 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v42);
}

void sub_1CC8BCB60(uint64_t a1, void *a2)
{
  char v63 = 0;
  LOBYTE(v62[0]) = 0;
  int v4 = *(llvm::raw_ostream **)a1;
  uint64_t v5 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v5) > 4)
  {
    *(unsigned char *)(v5 + 4) = 101;
    *(_DWORD *)uint64_t v5 = 1685016073;
    *((void *)v4 + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "\tNode", 5uLL);
  }
  llvm::write_hex(v4, (unint64_t)a2, 3, 0, 0);
  unsigned int v6 = (void *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 7uLL)
  {
    *unsigned int v6 = 0x3D65706168735B20;
    *((void *)v4 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v4, " [shape=", 8uLL);
  }
  unsigned int v7 = *(llvm::raw_ostream **)a1;
  uint64_t v8 = *(void *)(*(void *)a1 + 32);
  unint64_t v9 = *(void *)(*(void *)a1 + 24) - v8;
  if (*(unsigned char *)(a1 + 16))
  {
    if (v9 <= 4)
    {
      unint64_t v10 = "none,";
      size_t v11 = 5;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(unsigned char *)(v8 + 4) = 44;
    *(_DWORD *)uint64_t v8 = 1701736302;
    uint64_t v57 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      unint64_t v10 = "record,";
      size_t v11 = 7;
      goto LABEL_10;
    }
    *(_DWORD *)(v8 + 3) = 744780399;
    *(_DWORD *)uint64_t v8 = 1868785010;
    uint64_t v57 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v57;
LABEL_11:
  if (v63 >= 0) {
    size_t v12 = v63 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v62[1];
  }
  if (v12)
  {
    if (v63 >= 0) {
      uint64_t v13 = v62;
    }
    else {
      uint64_t v13 = (void **)v62[0];
    }
    unsigned int v14 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, (const char *)v13, v12);
    int v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      unsigned char *v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  unint64_t v16 = *(llvm::raw_ostream **)a1;
  uint64_t v17 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v17) > 5)
  {
    *(_WORD *)(v17 + 4) = 15724;
    *(_DWORD *)uint64_t v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    int v19 = a2 + 1;
    unint64_t v18 = a2[1];
    if ((v18 & 2) != 0)
    {
      unint64_t v24 = v18 & 0xFFFFFFFFFFFFFFFCLL;
      int v19 = *(void **)v24;
      uint64_t v20 = *(void *)v24 + 8 * *(unsigned int *)(v24 + 8);
    }
    else
    {
      uint64_t v20 = (uint64_t)&v19[v18 > 3];
    }
    if (v19 == (void *)v20)
    {
      unsigned int v27 = 0;
      BOOL v28 = 0;
    }
    else
    {
      int v25 = 0;
      int v26 = v19 + 1;
      do
      {
        unsigned int v27 = v25 + 1;
        BOOL v28 = v26 != (void *)v20;
        if (v26 == (void *)v20) {
          break;
        }
        ++v26;
      }
      while (v25++ != 63);
    }
    if (v27 <= 1) {
      int v30 = 1;
    }
    else {
      int v30 = v27;
    }
    uint64_t v31 = *(llvm::raw_ostream **)a1;
    char v32 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v32 > 0x30uLL)
    {
      qmemcpy(v32, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
      BOOL v33 = (void *)(*((void *)v31 + 4) + 49);
      *((void *)v31 + 4) = v33;
    }
    else
    {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
      BOOL v33 = (void *)*((void *)v31 + 4);
    }
    unint64_t v34 = (v30 + v28);
    if (*((void *)v31 + 3) - (void)v33 > 0x2EuLL)
    {
      qmemcpy(v33, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
      *((void *)v31 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v31, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
    }
    sub_1CD098D14(v31, v34, 0, 0, 0);
    size_t v35 = (_WORD *)*((void *)v31 + 4);
    if (*((void *)v31 + 3) - (void)v35 <= 1uLL)
    {
      uint64_t v23 = "\">";
      unsigned int v21 = v31;
      goto LABEL_44;
    }
    _WORD *v35 = 15906;
    *((void *)v31 + 4) += 2;
  }
  else
  {
    unsigned int v21 = *(llvm::raw_ostream **)a1;
    int v22 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v22 <= 1uLL)
    {
      uint64_t v23 = "\"{";
LABEL_44:
      llvm::raw_ostream::write(v21, v23, 2uLL);
      goto LABEL_45;
    }
    *int v22 = 31522;
    *((void *)v21 + 4) += 2;
  }
LABEL_45:
  size_t v36 = *(llvm::raw_ostream **)a1;
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v59 = 0;
    size_t v60 = 0;
    uint64_t v61 = 0;
    LODWORD(v65) = 0;
    char v69 = 0;
    uint64_t v70 = 0;
    unsigned int v72 = &v59;
    int v71 = 0;
    __p = &unk_1F2646F30;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    (*(void (**)(void *, void **))(*a2 + 16))(a2, &__p);
    __p = &unk_1F2646B98;
    if (v71 == 1 && v66) {
      MEMORY[0x1D25D9CB0](v66, 0x1000C8077774924);
    }
    if (v61 >= 0) {
      int v37 = (const char *)&v59;
    }
    else {
      int v37 = (const char *)v59;
    }
    if (v61 >= 0) {
      size_t v38 = HIBYTE(v61) & 0x7F;
    }
    else {
      size_t v38 = v60;
    }
    llvm::raw_ostream::write(v36, v37, v38);
    uint64_t v39 = *((void *)v36 + 4);
    if ((unint64_t)(*((void *)v36 + 3) - v39) > 4)
    {
      *(unsigned char *)(v39 + 4) = 62;
      *(_DWORD *)uint64_t v39 = 1685335868;
      *((void *)v36 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v36, "</td>", 5uLL);
    }
  }
  else
  {
    uint64_t v59 = 0;
    size_t v60 = 0;
    uint64_t v61 = 0;
    LODWORD(v65) = 0;
    char v69 = 0;
    uint64_t v70 = 0;
    unsigned int v72 = &v59;
    int v71 = 0;
    __p = &unk_1F2646F30;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = 0;
    (*(void (**)(void *, void **))(*a2 + 16))(a2, &__p);
    __p = &unk_1F2646B98;
    if (v71 == 1 && v66) {
      MEMORY[0x1D25D9CB0](v66, 0x1000C8077774924);
    }
    llvm::DOT::EscapeString((char *)&v59, (uint64_t)&__p);
    if (v66 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    if (v66 >= 0) {
      size_t v41 = HIBYTE(v66) & 0x7F;
    }
    else {
      size_t v41 = v65;
    }
    llvm::raw_ostream::write(v36, p_p, v41);
    if (SHIBYTE(v66) < 0) {
      operator delete(__p);
    }
  }
  if (SHIBYTE(v61) < 0) {
    operator delete(v59);
  }
  uint64_t v59 = 0;
  size_t v60 = 0;
  uint64_t v61 = 0;
  LODWORD(v65) = 0;
  char v69 = 0;
  uint64_t v70 = 0;
  unsigned int v72 = &v59;
  int v71 = 0;
  __p = &unk_1F2646F30;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  if (*(unsigned char *)(a1 + 16)
    && (llvm::raw_ostream::write((llvm::raw_ostream *)&__p, "</tr><tr>", 9uLL), *(unsigned char *)(a1 + 16)))
  {
    uint64_t v42 = *(llvm::raw_ostream **)a1;
    uint64_t v43 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v43 <= 0xDuLL)
    {
      __int16 v44 = "</tr></table>>";
      size_t v45 = 14;
LABEL_72:
      llvm::raw_ostream::write(v42, v44, v45);
      goto LABEL_73;
    }
    qmemcpy(v43, "</tr></table>>", 14);
    uint64_t v58 = *((void *)v42 + 4) + 14;
  }
  else
  {
    uint64_t v42 = *(llvm::raw_ostream **)a1;
    char v46 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v46 <= 1uLL)
    {
      __int16 v44 = "}\"";
      size_t v45 = 2;
      goto LABEL_72;
    }
    *char v46 = 8829;
    uint64_t v58 = *((void *)v42 + 4) + 2;
  }
  *((void *)v42 + 4) = v58;
LABEL_73:
  long long v47 = *(llvm::raw_ostream **)a1;
  uint64_t v48 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v48) > 2)
  {
    *(unsigned char *)(v48 + 2) = 10;
    *(_WORD *)uint64_t v48 = 15197;
    *((void *)v47 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v47, "];\n", 3uLL);
  }
  uint64_t v50 = a2 + 1;
  unint64_t v49 = a2[1];
  if ((v49 & 2) != 0)
  {
    unint64_t v52 = v49 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v50 = *(void **)v52;
    uint64_t v51 = *(void *)v52 + 8 * *(unsigned int *)(v52 + 8);
  }
  else
  {
    uint64_t v51 = (uint64_t)&v50[v49 > 3];
  }
  if (v50 != (void *)v51)
  {
    uint64_t v53 = 0;
    do
    {
      char v54 = &v50[v53];
      sub_1CD6539E4((llvm::raw_ostream **)a1, (unint64_t)a2, (uint64_t)&v50[v53], (uint64_t (*)(uint64_t))sub_1CD6539D8);
      uint64_t v55 = v53 * 8 + 8;
      if ((v53 * 8) == 504) {
        break;
      }
      ++v53;
    }
    while (v54 + 1 != (void *)v51);
    uint64_t v50 = (void *)((char *)v50 + v55);
  }
  if (v50 != (void *)v51)
  {
    uint64_t v56 = (uint64_t)v50;
    do
    {
      sub_1CD6539E4((llvm::raw_ostream **)a1, (unint64_t)a2, v56, (uint64_t (*)(uint64_t))sub_1CD6539D8);
      ++v50;
      v56 += 8;
    }
    while (v50 != (void *)v51);
  }
  __p = &unk_1F2646B98;
  if (v71 == 1 && v66) {
    MEMORY[0x1D25D9CB0](v66, 0x1000C8077774924);
  }
  if (SHIBYTE(v61) < 0) {
    operator delete(v59);
  }
  if (v63 < 0) {
    operator delete(v62[0]);
  }
}

double sub_1CC8BD3D8()
{
  dword_1EBCDD75C = sub_1CBF64200((llvm::DebugCounter *)"attributor-manifest", 0x13uLL, "Determine what attributes are manifested in the IR", 0x32uLL);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Maximal number of fixpoint iterations.";
  v5.n128_u64[1] = 38;
  int v3 = 32;
  int v4 = &v3;
  sub_1CD413D64((uint64_t)&unk_1EBCDD778, "attributor-max-iterations", &v2, &v5, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCDD778, &dword_1CB82C000);
  int v3 = 1;
  v5.n128_u64[0] = (unint64_t)"Maximal number of chained initializations (to avoid stack overflows)";
  v5.n128_u64[1] = 68;
  int v4 = &llvm::MaxInitializationChainLength;
  int v1 = 1024;
  uint64_t v2 = &v1;
  sub_1CD64FEDC(&v3, (long long *)&v5, &v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC0708F8, &qword_1EBCDD838, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Verify that max-iterations is a tight bound for a fixpoint";
  v5.n128_u64[1] = 58;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCDD8F8, "attributor-max-iterations-verify", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDD8F8, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Annotate call sites of function declarations.";
  v5.n128_u64[1] = 45;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCDD9B8, "attributor-annotate-decl-cs", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDD9B8, &dword_1CB82C000);
  LOBYTE(v2) = 1;
  v5.n128_u64[0] = (unint64_t)&v2;
  LODWORD(v4) = 1;
  sub_1CD650080((char **)&v5, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCDDA78, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Allow the Attributor to create shallow wrappers for non-exact definitions.";
  v5.n128_u64[1] = 74;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCDDB38, "attributor-allow-shallow-wrappers", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDDB38, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Allow the Attributor to use IP information derived from non-exact functions via cloning";
  v5.n128_u64[1] = 87;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCDDBF8, "attributor-allow-deep-wrappers", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDDBF8, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Dump the dependency graph to dot files.";
  v5.n128_u64[1] = 39;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBD075A0, "attributor-dump-dep-graph", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD075A0, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v5.n128_u64[0] = (unint64_t)"The prefix used for the CallGraph dot file names.";
  v5.n128_u64[1] = 49;
  sub_1CD6501A0(&v4, (long long *)&v5);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &qword_1EBCDDD78, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"View the dependency graph.";
  v5.n128_u64[1] = 26;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBD07660, "attributor-view-dep-graph", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD07660, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Print attribute dependencies";
  v5.n128_u64[1] = 28;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD6502B8(&v2, &v5, (char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBD07720, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Allow the Attributor to do call site specific analysis";
  v5.n128_u64[1] = 54;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD650430(&v2, &v5, (char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBD077E0, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Print Attributor's internal call graph";
  v5.n128_u64[1] = 38;
  LOBYTE(v3) = 0;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBD078A0, "attributor-print-call-graph", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD078A0, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Try to simplify all loads.";
  v5.n128_u64[1] = 26;
  LOBYTE(v3) = 1;
  int v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCDDCB8, "attributor-simplify-all-loads", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDDCB8, &dword_1CB82C000);
  llvm::IRPosition::EmptyKey = xmmword_1CFB27310;
  double result = NAN;
  llvm::IRPosition::TombstoneKey = xmmword_1CFB27320;
  return result;
}

uint64_t llvm::AA::getAssumedUnderlyingObjects(llvm::Attributor *a1, uint64_t a2, uint64_t a3, const llvm::AbstractAttribute *a4, uint64_t a5, BOOL *a6, char a7)
{
  v160[12] = *MEMORY[0x1E4F143B8];
  uint64_t v130 = v134;
  uint64_t v131 = v134;
  uint64_t v132 = 8;
  int v133 = 0;
  unsigned int v11 = *(unsigned __int8 *)(a2 + 16);
  if (v11 != 21)
  {
    if (v11 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v12 = v11 - 33;
      BOOL v13 = v12 > 0x33;
      uint64_t v14 = (1 << v12) & 0x8000000000041;
      if (!v13 && v14 != 0) {
        a2 |= 1uLL;
      }
    }
  }
  v137[0] = a2;
  v137[1] = 0;
  v157[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v157[i] = -4096;
  uint64_t v158 = v160;
  uint64_t v159 = 0x400000000;
  unint64_t v17 = sub_1CD6482F0((llvm::IRPosition *)v137);
  int v18 = 0;
  v154[0] = v155;
  v154[1] = (void *)0x1000000000;
  v156[1] = 0;
  v156[0] = 0;
  v155[32] = v156;
  uint64_t v150 = v153;
  unsigned int v152 = 16;
  v153[0] = v17;
  v153[1] = a5;
  unint64_t v124 = v17;
  int64x2_t v123 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v19 = 1;
  int v125 = a4;
  uint64_t v126 = a1;
  do
  {
    uint64_t v20 = (char *)v150 + 16 * v19;
    unsigned int v21 = (llvm *)*((void *)v20 - 2);
    unint64_t v22 = *((void *)v20 - 1);
    unsigned int v151 = v19 - 1;
    v136[0] = (unint64_t)v21;
    v136[1] = v22;
    UnderlyingObject = llvm::getUnderlyingObject(v21, (const llvm::Value *)6);
    if ((sub_1CD65837C((uint64_t)v154, v136) & 0x100000000) == 0) {
      goto LABEL_158;
    }
    if (v18 >= 32) {
      goto LABEL_230;
    }
    ++v18;
    if (*(unsigned char *)(*(void *)UnderlyingObject + 8) != 15)
    {
      unsigned int v27 = *((unsigned __int8 *)UnderlyingObject + 16);
      if (v27 < 0x1C) {
        goto LABEL_42;
      }
      unsigned int v28 = v27 - 33;
      BOOL v13 = v28 > 0x33;
      uint64_t v29 = (1 << v28) & 0x8000000000041;
      if (v13 || v29 == 0) {
        goto LABEL_42;
      }
      uint64_t v31 = *((void *)UnderlyingObject - 4);
      if (!v31 || *(unsigned char *)(v31 + 16) || *(void *)(v31 + 24) != *((void *)UnderlyingObject + 9)) {
        goto LABEL_42;
      }
      if (*(_WORD *)(v31 + 18))
      {
        llvm::Function::BuildLazyArguments(*((llvm::Function **)UnderlyingObject - 4));
        uint64_t v32 = *(void *)(v31 + 88);
        if (*(_WORD *)(v31 + 18))
        {
          llvm::Function::BuildLazyArguments((llvm::Function *)v31);
          uint64_t v33 = *(void *)(v31 + 88);
LABEL_34:
          uint64_t v34 = v33 + 40 * *(void *)(v31 + 96);
          while (v32 != v34)
          {
            uint64_t v35 = *(void *)(*(void *)(v32 + 24) + 112);
            if (v35)
            {
              uint64_t v36 = *(unsigned int *)(v32 + 32);
              if ((v36 + 2) < *(_DWORD *)(v35 + 8))
              {
                uint64_t v37 = *(void *)(v35 + 8 * (v36 + 2) + 40);
                if (v37)
                {
                  if ((*(unsigned char *)(v37 + 17) & 0x40) != 0)
                  {
                    unint64_t v24 = (llvm::Value *)*((void *)UnderlyingObject
                                         + 4 * v36
                                         + -4 * (*((_DWORD *)UnderlyingObject + 5) & 0x7FFFFFF));
                    goto LABEL_17;
                  }
                }
              }
            }
            v32 += 40;
          }
          goto LABEL_42;
        }
      }
      else
      {
        uint64_t v32 = *(void *)(v31 + 88);
      }
      uint64_t v33 = v32;
      goto LABEL_34;
    }
    unint64_t v24 = llvm::Value::stripPointerCasts(UnderlyingObject);
LABEL_17:
    if (v24) {
      BOOL v25 = v24 == UnderlyingObject;
    }
    else {
      BOOL v25 = 1;
    }
    if (!v25)
    {
LABEL_21:
      if (v151 >= (unint64_t)v152) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v26 = (char *)v150 + 16 * v151;
      *(void *)int v26 = v24;
LABEL_127:
      *((void *)v26 + 1) = v22;
      char v90 = &v151;
LABEL_157:
      ++*v90;
      goto LABEL_158;
    }
LABEL_42:
    int v38 = *((unsigned __int8 *)UnderlyingObject + 16);
    if (v38 == 83)
    {
      uint64_t v44 = *(void *)(*((void *)UnderlyingObject + 5) + 56);
      uint64_t v138 = v44;
      int v139 = 0;
      sub_1CD645794((uint64_t)&__src, (uint64_t)v157, &v138, &v139);
      size_t v45 = __src;
      int v129 = v18;
      if (BYTE8(v146[0]))
      {
        *(_DWORD *)&v140[20] = 0;
        *(_DWORD *)&v140[17] = 0;
        *(void *)unsigned int v140 = v44;
        *(void *)&v140[8] = 0;
        v140[16] = 0;
        if (v159 >= HIDWORD(v159))
        {
          if (v158 > v140 || (char *)v158 + 24 * v159 <= v140) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v58 = (char *)v158 + 24 * v159;
        long long v59 = *(_OWORD *)v140;
        *((void *)v58 + 2) = *(void *)&v140[16];
        *(_OWORD *)uint64_t v58 = v59;
        unsigned int v46 = v159;
        LODWORD(v159) = v159 + 1;
        v45[2] = v46;
      }
      else
      {
        unsigned int v46 = *((_DWORD *)__src + 2);
      }
      size_t v60 = (char *)v158;
      uint64_t v61 = (char *)v158 + 24 * v46;
      uint64_t v63 = *((void *)v61 + 1);
      uint64_t v62 = (llvm::AbstractAttribute **)(v61 + 8);
      if (!v63) {
        *uint64_t v62 = sub_1CC8AC178((uint64_t)a1, v44, 0, (uint64_t)a4, 2, 0, 1);
      }
      uint64_t v64 = *((_DWORD *)UnderlyingObject + 5) & 0x7FFFFFF;
      if (v64)
      {
        uint64_t v65 = 0;
        uint64_t v66 = 0;
        uint64_t v67 = &v60[24 * v46 + 16];
        uint64_t v68 = 8 * v64;
        do
        {
          int v69 = *((_DWORD *)UnderlyingObject + 5);
          if ((v69 & 0x40000000) != 0) {
            uint64_t v70 = (char *)*((void *)UnderlyingObject - 1);
          }
          else {
            uint64_t v70 = (char *)UnderlyingObject - 32 * (v69 & 0x7FFFFFF);
          }
          uint64_t v71 = *(void *)&v70[32 * *((unsigned int *)UnderlyingObject + 15) + v66];
          if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v62 + 168))(*v62, v71, *((void *)UnderlyingObject + 5)))
          {
            char *v67 = 1;
            *a6 |= (*(unsigned __int8 (**)(void))(*((void *)*v62 + 4) + 24))() ^ 1;
          }
          else
          {
            int v72 = *((_DWORD *)UnderlyingObject + 5);
            if ((v72 & 0x40000000) != 0) {
              uint64_t v73 = (char *)*((void *)UnderlyingObject - 1);
            }
            else {
              uint64_t v73 = (char *)UnderlyingObject - 32 * (v72 & 0x7FFFFFF);
            }
            uint64_t v74 = *(void *)(v71 + 40);
            if (v74 == v71 + 40)
            {
              uint64_t v76 = 0;
            }
            else
            {
              if (v74) {
                uint64_t v75 = v74 - 24;
              }
              else {
                uint64_t v75 = 0;
              }
              if (*(unsigned __int8 *)(v75 + 16) - 29 >= 0xB) {
                uint64_t v76 = 0;
              }
              else {
                uint64_t v76 = v75;
              }
            }
            uint64_t v77 = *(void *)&v73[v65];
            if (v151 >= (unint64_t)v152) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unsigned int v78 = (char *)v150 + 16 * v151;
            *unsigned int v78 = v77;
            v78[1] = v76;
            ++v151;
          }
          v66 += 8;
          v65 += 32;
        }
        while (v68 != v66);
        a4 = v125;
        a1 = v126;
      }
      int v18 = v129;
      goto LABEL_158;
    }
    if (v38 != 85)
    {
      if (v38 == 21) {
        long long v47 = UnderlyingObject;
      }
      else {
        long long v47 = 0;
      }
      uint64_t v138 = (uint64_t)v47;
      if ((a7 & 2) != 0 && v47 && (llvm::Argument::hasPassPointeeByValueCopyAttr(v47) & 1) == 0)
      {
        __src = (char *)v146 + 8;
        *(void *)&v146[0] = 0x300000000;
        char v135 = 0;
        *(void *)unsigned int v140 = &v138;
        *(void *)&v140[8] = &__src;
        int v48 = llvm::Attributor::checkForAllCallSites((uint64_t)a1, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8F8684, (uint64_t)v140, *(void *)(v138 + 24), 1, (uint64_t)a4, &v135);
        char v49 = v48;
        int v50 = 0;
        if (v48)
        {
          sub_1CD3D61B4((unsigned int *)&v150, __src, (unsigned char *)__src + 16 * LODWORD(v146[0]));
          int v50 = 3;
        }
        if (__src != (char *)v146 + 8) {
          free(__src);
        }
        if (v49) {
          goto LABEL_64;
        }
      }
      unsigned int v51 = *((unsigned __int8 *)UnderlyingObject + 16);
      if (v51 < 0x15)
      {
LABEL_67:
        unint64_t v52 = v131;
        uint64_t v53 = HIDWORD(v132);
        if (v131 == v130)
        {
          if (HIDWORD(v132))
          {
            char v54 = 0;
            uint64_t v55 = 8 * HIDWORD(v132);
            uint64_t v56 = v131;
            while (*(llvm **)v56 != UnderlyingObject)
            {
              if (*(void *)v56 == -2) {
                char v54 = v56;
              }
              v56 += 8;
              v55 -= 8;
              if (!v55)
              {
                if (!v54) {
                  goto LABEL_75;
                }
                *(void *)char v54 = UnderlyingObject;
                --v133;
                goto LABEL_155;
              }
            }
            goto LABEL_158;
          }
LABEL_75:
          unsigned int v57 = v132;
          if (HIDWORD(v132) < v132)
          {
            ++HIDWORD(v132);
            *(void *)&v131[8 * v53] = UnderlyingObject;
LABEL_155:
            unint64_t v102 = *(unsigned int *)(a3 + 8);
            if (v102 >= *(unsigned int *)(a3 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)a3 + 8 * v102) = UnderlyingObject;
            char v90 = (unsigned int *)(a3 + 8);
            goto LABEL_157;
          }
        }
        else
        {
          unsigned int v57 = v132;
        }
        if (3 * v57 <= 4 * (HIDWORD(v132) - v133))
        {
          if (v57 >= 0x40) {
            v57 *= 2;
          }
          else {
            unsigned int v57 = 128;
          }
        }
        else if (v57 - HIDWORD(v132) >= v57 >> 3)
        {
          goto LABEL_136;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v130, v57);
        unsigned int v57 = v132;
        unint64_t v52 = v131;
LABEL_136:
        unsigned int v93 = v57 - 1;
        unsigned int v94 = (v57 - 1) & ((UnderlyingObject >> 4) ^ (UnderlyingObject >> 9));
        char v95 = &v52[8 * v94];
        int v96 = *(llvm **)v95;
        if (*(void *)v95 == -1)
        {
          unint64_t v97 = 0;
LABEL_148:
          if (v97) {
            uint64_t v101 = v97;
          }
          else {
            uint64_t v101 = (llvm **)v95;
          }
          if (*v101 != UnderlyingObject)
          {
            if (*v101 == (llvm *)-2) {
              --v133;
            }
            else {
              ++HIDWORD(v132);
            }
            *uint64_t v101 = UnderlyingObject;
            goto LABEL_155;
          }
        }
        else
        {
          unint64_t v97 = 0;
          int v98 = 1;
          while (v96 != UnderlyingObject)
          {
            if (v97) {
              BOOL v99 = 0;
            }
            else {
              BOOL v99 = v96 == (llvm *)-2;
            }
            if (v99) {
              unint64_t v97 = (llvm **)v95;
            }
            unsigned int v100 = v94 + v98++;
            unsigned int v94 = v100 & v93;
            char v95 = &v52[8 * (v100 & v93)];
            int v96 = *(llvm **)v95;
            if (*(void *)v95 == -1) {
              goto LABEL_148;
            }
          }
        }
        goto LABEL_158;
      }
      if (v51 >= 0x1C && (unsigned int v79 = v51 - 33, v79 <= 0x33) && ((1 << v79) & 0x8000000000041) != 0) {
        uint64_t v80 = (void *)((unint64_t)UnderlyingObject | 1);
      }
      else {
        uint64_t v80 = UnderlyingObject;
      }
      __src = v80;
      *(void *)&v146[0] = 0;
      unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a1, (const llvm::IRPosition *)&__src, a4, a6);
      if (!v82) {
        goto LABEL_158;
      }
      unint64_t v24 = (llvm::Value *)AssumedSimplified;
      if (AssumedSimplified && UnderlyingObject != (llvm *)AssumedSimplified)
      {
        if ((a7 & 2) != 0) {
          goto LABEL_21;
        }
        if (!v22) {
          goto LABEL_21;
        }
        unsigned int v83 = *(unsigned __int8 *)(AssumedSimplified + 16);
        if (v83 < 0x15) {
          goto LABEL_21;
        }
        if (v83 >= 0x1C)
        {
          unint64_t v84 = (void *)(*(void *)(AssumedSimplified + 40) + 56);
        }
        else
        {
          if (v83 != 21) {
            goto LABEL_172;
          }
          unint64_t v84 = (void *)(AssumedSimplified + 24);
        }
        if (*v84 == *(void *)(*(void *)(v22 + 40) + 56)) {
          goto LABEL_21;
        }
      }
LABEL_172:
      if (*((unsigned char *)UnderlyingObject + 16) != 60) {
        goto LABEL_67;
      }
      int v107 = v18;
      LOBYTE(v138) = 0;
      if (*((void *)UnderlyingObject - 4) == v124) {
        goto LABEL_210;
      }
      __src = (void *)1;
      v146[0] = v123;
      v146[1] = v123;
      unint64_t v147 = v149;
      uint64_t v148 = 0x400000000;
      *(void *)unsigned int v140 = 1;
      *(int64x2_t *)&v140[8] = v123;
      int64x2_t v141 = v123;
      v142 = v144;
      uint64_t v143 = 0x400000000;
      LODWORD(v108) = 1;
      if (llvm::AA::getPotentiallyLoadedValues(a1, UnderlyingObject, &__src, v140, a4, &v138, 1))
      {
        if (!v148)
        {
LABEL_176:
          LODWORD(v108) = 0;
LABEL_177:
          int v50 = 3;
          goto LABEL_202;
        }
        uint64_t v109 = (int64_t *)v147;
        uint64_t v110 = 8 * v148;
        do
        {
          LODWORD(v108) = 1;
          if (!llvm::AA::isDynamicallyUnique(v126, a4, *v109, (const llvm::Value *)1))
          {
            int v50 = 0;
            a1 = v126;
            goto LABEL_202;
          }
          ++v109;
          v110 -= 8;
        }
        while (v110);
        int v111 = v147;
        a1 = v126;
        if ((a7 & 2) != 0 || !v22)
        {
LABEL_195:
          if (!v148) {
            goto LABEL_176;
          }
          unsigned int v117 = v151;
          uint64_t v108 = 8 * v148;
          do
          {
            if (v117 >= v152) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            long long v118 = (char *)v150 + 16 * v117;
            *long long v118 = *v111;
            v118[1] = v22;
            unsigned int v117 = ++v151;
            ++v111;
            v108 -= 8;
          }
          while (v108);
          goto LABEL_177;
        }
        if (!v148) {
          goto LABEL_176;
        }
        uint64_t v112 = 8 * v148;
        uint64_t v113 = (char *)v147;
        while (1)
        {
          uint64_t v114 = *(void *)v113;
          unsigned int v115 = *(unsigned __int8 *)(*(void *)v113 + 16);
          if (v115 >= 0x15)
          {
            if (v115 >= 0x1C)
            {
              long long v116 = (void *)(*(void *)(v114 + 40) + 56);
            }
            else
            {
              if (v115 != 21) {
                break;
              }
              long long v116 = (void *)(v114 + 24);
            }
            if (*v116 != *(void *)(*(void *)(v22 + 40) + 56)) {
              break;
            }
          }
          v113 += 8;
          v112 -= 8;
          if (!v112) {
            goto LABEL_195;
          }
        }
        int v50 = 0;
        LODWORD(v108) = 1;
      }
      else
      {
        int v50 = 0;
      }
LABEL_202:
      if (v142 != v144) {
        free(v142);
      }
      if ((v140[0] & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)&v140[8], 8);
      }
      if (v147 != v149) {
        free(v147);
      }
      if (__src)
      {
        if (!v108) {
          goto LABEL_219;
        }
      }
      else
      {
        MEMORY[0x1D25D9CD0](*(void *)&v146[0], 8);
        if (!v108)
        {
LABEL_219:
          int v18 = v107;
LABEL_64:
          if (v50 != 3)
          {
LABEL_230:
            uint64_t v119 = 0;
            goto LABEL_236;
          }
          goto LABEL_158;
        }
      }
LABEL_210:
      int v18 = v107;
      goto LABEL_67;
    }
    unint64_t v39 = *((void *)UnderlyingObject - 12);
    unsigned int v40 = *(unsigned __int8 *)(v39 + 16);
    if (v40 != 21)
    {
      if (v40 < 0x1C)
      {
        if (!*(unsigned char *)(v39 + 16)) {
          v39 |= 2uLL;
        }
      }
      else
      {
        unsigned int v41 = v40 - 33;
        BOOL v13 = v41 > 0x33;
        uint64_t v42 = (1 << v41) & 0x8000000000041;
        if (!v13 && v42 != 0) {
          v39 |= 1uLL;
        }
      }
    }
    __src = (void *)v39;
    *(void *)&v146[0] = 0;
    AssumedConstant = llvm::Attributor::getAssumedConstant(a1, (const llvm::IRPosition *)&__src, a4, a6);
    if (v86)
    {
      if (!AssumedConstant) {
        goto LABEL_123;
      }
      int v91 = *((unsigned __int8 *)AssumedConstant + 16);
      if ((v91 - 11) < 2) {
        goto LABEL_158;
      }
      if (v91 == 16)
      {
        uint64_t v92 = *((unsigned int *)AssumedConstant + 8);
        if (v92 > 0x40)
        {
          int v103 = 0;
          int64_t v104 = (unint64_t)(v92 + 63) >> 6;
          do
          {
            BOOL v13 = v104-- < 1;
            if (v13) {
              break;
            }
            unint64_t v105 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v104);
            v103 += __clz(v105);
          }
          while (!v105);
          int v106 = v92 | 0xFFFFFFC0;
          if ((v92 & 0x3F) == 0) {
            int v106 = 0;
          }
          if (v103 + v106 == v92) {
            goto LABEL_166;
          }
LABEL_132:
          uint64_t v89 = *((void *)UnderlyingObject - 8);
        }
        else
        {
          if (*((void *)AssumedConstant + 3)) {
            goto LABEL_132;
          }
LABEL_166:
          uint64_t v89 = *((void *)UnderlyingObject - 4);
        }
        if (v151 >= (unint64_t)v152) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v26 = (char *)v150 + 16 * v151;
      }
      else
      {
LABEL_123:
        if (v151 >= (unint64_t)v152) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v87 = (char *)v150 + 16 * v151;
        *int v87 = *((void *)UnderlyingObject - 8);
        v87[1] = v22;
        unsigned int v88 = v151 + 1;
        unsigned int v151 = v88;
        uint64_t v89 = *((void *)UnderlyingObject - 4);
        if (v88 >= v152) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v26 = (char *)v150 + 16 * v88;
      }
      *(void *)int v26 = v89;
      goto LABEL_127;
    }
LABEL_158:
    unsigned int v19 = v151;
  }
  while (v151);
  if (v159)
  {
    uint64_t v120 = 24 * v159;
    int v121 = (char *)v158 + 16;
    do
    {
      if (*v121) {
        llvm::Attributor::recordDependence((uint64_t)a1, *((void *)v121 - 1), (uint64_t)a4, 1);
      }
      v121 += 24;
      v120 -= 24;
    }
    while (v120);
    uint64_t v119 = 1;
  }
  else
  {
    uint64_t v119 = 1;
  }
LABEL_236:
  if (v150 != v153) {
    free(v150);
  }
  sub_1CD40B1BC(v156[0]);
  if (v154[0] != v155) {
    free(v154[0]);
  }
  if (v158 != v160) {
    free(v158);
  }
  if ((v157[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v157[1], 8);
  }
  if (v131 != v130) {
    free(v131);
  }
  return v119;
}

BOOL llvm::AANoSync::isNoSyncIntrinsic(llvm::AANoSync *this, const llvm::Instruction *a2)
{
  int v3 = sub_1CBFB3AB0((uint64_t)this);
  BOOL result = 0;
  if (this && v3)
  {
    uint64_t v5 = ((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[12];
    uint64_t v6 = *(unsigned int *)(v5 + 32);
    if (v6 > 0x40)
    {
      int v8 = 0;
      int64_t v9 = (unint64_t)(v6 + 63) >> 6;
      do
      {
        if (v9-- < 1) {
          break;
        }
        unint64_t v11 = *(void *)(*(void *)(v5 + 24) + 8 * v9);
        v8 += __clz(v11);
      }
      while (!v11);
      int v12 = v6 | 0xFFFFFFC0;
      if ((v6 & 0x3F) == 0) {
        int v12 = 0;
      }
      return v8 + v12 == v6;
    }
    else
    {
      return *(void *)(v5 + 24) == 0;
    }
  }
  return result;
}

BOOL llvm::ValueSimplifyStateType::unionAssumed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = a2;
  v8[1] = a3;
  int v4 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(a1 + 32), (uint64_t)v8, *(llvm::Value **)(a1 + 8));
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 40) = v5;
  if ((_BYTE)v5) {
    BOOL v6 = v4 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  return !v6;
}

void *sub_1CC8BF1F0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8BF234(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8BF298@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    int v3 = "nounwind";
  }
  else {
    int v3 = "may-unwind";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 8;
  }
  else {
    size_t v4 = 10;
  }
  a2[23] = v4;
  BOOL result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8BF2F4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFA0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFA0))
  {
    __cxa_guard_release(&qword_1EA61BFA0);
  }
}

uint64_t sub_1CC8BF348(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v9 = xmmword_1CFB27384;
  uint64_t v10 = 0x60000000ALL;
  v8[0] = a2;
  v8[1] = a1;
  v6[0] = &v9;
  v6[1] = 6;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8BF4D8, (uint64_t)v8, v4, a1, (uint64_t)v6, &v7, 0, 0))return 1; {
  else
  }
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
}

uint64_t *sub_1CC8BF448(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8BF470(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8BF4D8(uint64_t *a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  uint64_t result = 1;
  if (v3 > 0x23)
  {
    if (v3 == 84)
    {
      uint64_t v7 = a1[1];
      uint64_t v8 = *(void *)(a2 + 64);
      if (!v8 || (*(unsigned char *)(v8 + 16) & 0x20) == 0)
      {
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 37) & 1) == 0)
        {
          int v5 = 0;
          unsigned int v3 = *(unsigned __int8 *)(a2 + 16) - 33;
          if (v3 <= 0x33 && ((1 << v3) & 0x8000000000041) != 0)
          {
            int v5 = 1;
            unsigned int v3 = *((unsigned char *)sub_1CC8B82A4(*a1, a2, 0, v7, 0, 0, 1) + 41) != 0;
          }
          return v5 & v3;
        }
        return 1;
      }
    }
    else if (v3 == 36 || v3 == 38)
    {
      unsigned int v3 = *(unsigned __int16 *)(a2 + 18);
      if ((v3 & 1) == 0) {
        goto LABEL_3;
      }
    }
  }
  else if (v3 == 34)
  {
LABEL_3:
    int v5 = 0;
    return v5 & v3;
  }
  return result;
}

void *sub_1CC8BF5D8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8BF61C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8BF680(uint64_t a1, uint64_t a2)
{
  sub_1CD656DF4((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8BF6F0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFA8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFA8))
  {
    __cxa_guard_release(&qword_1EA61BFA8);
  }
}

uint64_t sub_1CC8BF744(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  int v5 = sub_1CC8B82A4(a2, v4, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned char *)(v3 + 9) == 0;
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 ^ (*(unsigned char *)(v3 + 9) != 0);
}

uint64_t *sub_1CC8BF7FC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8BF824(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8BF88C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8BF8D0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8BF934@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "nosync";
  }
  else {
    uint64_t v3 = "may-sync";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 8;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8BF990()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFB0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFB0))
  {
    __cxa_guard_release(&qword_1EA61BFB0);
  }
}

uint64_t sub_1CC8BF9E4(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  v8[0] = a2;
  v8[1] = a1;
  if llvm::Attributor::checkForAllReadWriteInstructions(a2, (unsigned int (*)(uint64_t, uint64_t))sub_1CC8BFB94, (uint64_t)v8, a1, &v6)&& (v10 = 0xB00000005, v11 = 56, v9[0] = &v10, v9[1] = 3, unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16)), (llvm::Attributor::checkForAllInstructions(a2, sub_1CC8BFB9C, (uint64_t)&v7, v5, a1, (uint64_t)v9, &v6, 0, 0)))
  {
    return 1;
  }
  else
  {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
}

uint64_t *sub_1CC8BFB04(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8BFB2C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8BFB94(llvm::AA **a1, llvm::Attributor *a2, uint64_t a3, const llvm::AbstractAttribute *a4)
{
  return llvm::AA::isNoSyncInst(*a1, a2, a1[1], a4);
}

uint64_t sub_1CC8BFB9C(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a2 + 16);
  uint64_t v4 = (v3 - 33);
  if (v4 > 0x37) {
    goto LABEL_5;
  }
  if (((1 << (v3 - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v8 = *(void *)(a2 + 64);
    if (!v8 || (*(unsigned char *)(v8 + 20) & 4) == 0 && (*(unsigned char *)(v8 + 17) & 0x10) == 0)
    {
      __int32 v21 = 7;
      if (sub_1CC5CB59C(a2, &v21, 1uLL))
      {
        uint64_t v11 = *(void *)(a2 - 32);
        if (!v11 || *(unsigned char *)(v11 + 16) || *(void *)(v11 + 24) != *(void *)(a2 + 72) || *(_DWORD *)(v11 + 36) != 7) {
          return 1;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 66) & 1) == 0
        && !llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44))
      {
        return 1;
      }
    }
LABEL_18:
    int v3 = *(unsigned __int8 *)(a2 + 16);
    goto LABEL_5;
  }
  if (((1 << (v3 - 33)) & 0x808001C8000010) != 0) {
    return 1;
  }
  if (v4 == 28)
  {
    if ((*(_WORD *)(a2 + 18) & 0x301) != 0) {
      return 1;
    }
    goto LABEL_18;
  }
LABEL_5:
  uint64_t v5 = (v3 - 33);
  if (v5 <= 0x37)
  {
    if (((1 << v5) & 0x8000000000041) == 0)
    {
      if (v5 == 27)
      {
        if ((*(_WORD *)(a2 + 18) & 0x301) == 0) {
          goto LABEL_9;
        }
      }
      else if (((1 << v5) & 0x808001D0000010) == 0)
      {
        goto LABEL_9;
      }
      return 1;
    }
    uint64_t v9 = *(void *)(a2 + 64);
    if (!v9 || (*(unsigned char *)(v9 + 17) & 0x30) == 0)
    {
      int v10 = *(_DWORD *)(a2 + 20);
      if (v10 < 0)
      {
        uint64_t v12 = a2 - 32 * (v10 & 0x7FFFFFF);
        uint64_t v15 = *(void *)(v12 - 8);
        uint64_t v13 = v12 - 8;
        uint64_t v14 = v15;
        if (v15)
        {
          uint64_t v16 = -v14;
          do
          {
            unsigned int v17 = *(_DWORD *)(*(void *)(v13 + v16) + 8);
            BOOL v18 = v17 > 7;
            int v19 = (1 << v17) & 0x83;
            if (v18 || v19 == 0) {
              return 1;
            }
            v16 += 16;
          }
          while (v16);
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 45) & 1) == 0
        && !llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44))
      {
        return 1;
      }
    }
  }
LABEL_9:
  uint64_t v6 = *(void *)(a2 + 64);
  if (v6 && (*(unsigned char *)(v6 + 12) & 0x40) != 0) {
    return 0;
  }
  else {
    return llvm::CallBase::hasFnAttrOnCalledFunction(a2, 6) ^ 1;
  }
}

void *sub_1CC8BFDC4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8BFE08(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8BFE6C(uint64_t a1, uint64_t a2)
{
  sub_1CD6571EC((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8BFEDC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFB8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFB8))
  {
    __cxa_guard_release(&qword_1EA61BFB8);
  }
}

uint64_t sub_1CC8BFF30(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  uint64_t v5 = sub_1CC8B4D90(a2, v4, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned char *)(v3 + 9) == 0;
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 ^ (*(unsigned char *)(v3 + 9) != 0);
}

uint64_t *sub_1CC8BFFE8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C0010(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C0078(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C00BC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C0120@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "norecurse";
  }
  else {
    uint64_t v3 = "may-recurse";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 9;
  }
  else {
    size_t v4 = 11;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8C017C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFC0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFC0))
  {
    __cxa_guard_release(&qword_1EA61BFC0);
  }
}

uint64_t sub_1CC8C01D0(uint64_t a1, uint64_t a2)
{
  v9[0] = a2;
  v9[1] = a1;
  char v8 = 0;
  if (llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8C0360, (uint64_t)v9, a1, 1, &v8))
  {
    if (!v8) {
      *(unsigned char *)(a1 + 40) = *(unsigned char *)(a1 + 41);
    }
    return 1;
  }
  else
  {
    uint64_t v4 = 1;
    uint64_t v6 = sub_1CC8B3D70(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 0, 0, 1);
    unint64_t v7 = sub_1CD6482A0((_DWORD *)(a1 + 16));
    if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, unint64_t))(*(void *)v6 + 112))(v6, a2, v7))
    {
      uint64_t v4 = 0;
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
    }
  }
  return v4;
}

uint64_t *sub_1CC8C02D0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C02F8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8C0360(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v6 = *a2;
  v7[0] = &v8;
  v7[1] = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)v7, (uint64_t)(a2 + 1));
    uint64_t v3 = v6;
  }
  int v4 = *((unsigned __int8 *)sub_1CC8B3300(*a1, *(void *)(*(void *)(v3 + 40) + 56), 0, a1[1], 2, 0, 1) + 40);
  if (v7[0] != &v8) {
    free(v7[0]);
  }
  return v4 != 0;
}

void *sub_1CC8C03F4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C0438(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8C049C(uint64_t a1, uint64_t a2)
{
  sub_1CD657514((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8C050C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFC8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFC8))
  {
    __cxa_guard_release(&qword_1EA61BFC8);
  }
}

uint64_t sub_1CC8C0560(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  uint64_t v5 = sub_1CC8B3300(a2, v4, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned char *)(v3 + 9) == 0;
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 ^ (*(unsigned char *)(v3 + 9) != 0);
}

uint64_t *sub_1CC8C0618(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C0640(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C06A8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C06EC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C0750(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  sub_1CC8C0B80((void *)a1, a2);
  unint64_t result = (void *)sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (!result) {
    goto LABEL_18;
  }
  uint64_t v5 = result;
  if (*((unsigned char *)result + 16))
  {
    if (*((unsigned char *)result + 16) == 3 && (*((_DWORD *)result + 5) & 0x7FFFFFF) == 0) {
      goto LABEL_18;
    }
  }
  else if ((void *)result[9] == result + 9 && (*((unsigned char *)result + 34) & 0x80) == 0)
  {
    goto LABEL_18;
  }
  uint64_t v6 = **(void **)(*(void *)(a2 + 88) + 440);
  uint64_t v7 = v5[5];
  if (v6) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  int v10 = v5;
  sub_1CD47573C((uint64_t)&v10, (uint64_t)&v11);
  while (1)
  {
    if (v12 == v13) {
      return sub_1CD4750A4(&v11);
    }
    if (sub_1CD657B74(v12, (uint64_t)v13)) {
      break;
    }
    sub_1CD47588C(&v11);
  }
  unint64_t result = sub_1CD4750A4(&v11);
LABEL_18:
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  return result;
}

void *sub_1CC8C093C@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "willreturn";
  }
  else {
    uint64_t v3 = "may-noreturn";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 10;
  }
  else {
    size_t v4 = 12;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8C0998()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFD0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFD0))
  {
    __cxa_guard_release(&qword_1EA61BFD0);
  }
}

uint64_t sub_1CC8C09EC(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (sub_1CC8C0BFC(a1, a2, 0)) {
    return 1;
  }
  v7[0] = a2;
  v7[1] = a1;
  uint64_t v9 = 0xB00000005;
  int v10 = 56;
  v8[0] = &v9;
  v8[1] = 3;
  unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8C0CD4, (uint64_t)v7, v5, a1, (uint64_t)v8, &v6, 0, 0))return 1; {
  else
  }
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
}

uint64_t *sub_1CC8C0AF0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C0B18(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8C0B80(void *a1, uint64_t a2)
{
  sub_1CD657A14(a1, a2);
  unint64_t result = sub_1CC8C0BFC((uint64_t)a1, a2, 1);
  if (result)
  {
    unint64_t v5 = *(uint64_t (**)(void *))(a1[4] + 32);
    return v5(a1 + 4);
  }
  return result;
}

unint64_t sub_1CC8C0BFC(uint64_t a1, uint64_t a2, int a3)
{
  char v6 = (llvm::IRPosition *)(a1 + 16);
  if (!sub_1CD6482A0((_DWORD *)(a1 + 16))
    || (uint64_t v7 = *(void *)(sub_1CD6482A0(v6) + 112)) == 0
    || (*(unsigned char *)(v7 + 14) & 1) == 0 && (*(unsigned char *)(v7 + 20) & 2) == 0)
  {
    unint64_t result = sub_1CD648A0C(v6);
    if (!result) {
      return result;
    }
    uint64_t v10 = *(void *)(sub_1CD648A0C(v6) + 112);
    if (!v10 || (*(unsigned char *)(v10 + 14) & 1) == 0 && (*(unsigned char *)(v10 + 20) & 2) == 0) {
      return 0;
    }
  }
  char v11 = 0;
  int v8 = sub_1CC8AAAB0(a2, (uint64_t *)v6, a1, 0, &v11);
  unint64_t result = 0;
  if (v8)
  {
    if (v11) {
      return 1;
    }
    else {
      return a3 ^ 1u;
    }
  }
  return result;
}

BOOL sub_1CC8C0CD4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = 1;
  char v6 = sub_1CC8B78C8(*a1, a2, 0, v4, 0, 0, 1);
  if (!*((unsigned char *)v6 + 40)) {
    return *((unsigned char *)v6 + 41) && *((unsigned char *)sub_1CC8B3300(*a1, a2, 0, v4, 0, 0, 1) + 41) != 0;
  }
  return v5;
}

void *sub_1CC8C0D68(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C0DAC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8C0E10(uint64_t a1, uint64_t a2)
{
  sub_1CC8C0B80((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result || (unint64_t result = sub_1CD64EF44(a2, (llvm::GlobalValue *)result), (result & 1) == 0)) {
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  return result;
}

void sub_1CC8C0E60()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFD8))
  {
    __cxa_guard_release(&qword_1EA61BFD8);
  }
}

uint64_t sub_1CC8C0EB4(uint64_t a1, uint64_t a2)
{
  if (sub_1CC8C0BFC(a1, a2, 0)) {
    return 1;
  }
  unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  char v6 = sub_1CC8B78C8(a2, v5, 0, a1, 0, 0, 1);
  uint64_t v7 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v6 + 48))(v6);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v8 = a1 + 32;
  BOOL v10 = *(unsigned char *)(v8 + 9) == 0;
  (*(void (**)(uint64_t, void))(v9 + 48))(v8, *(unsigned __int8 *)(v7 + 9));
  return v10 ^ (*(unsigned char *)(v8 + 9) != 0);
}

uint64_t *sub_1CC8C0F80(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C0FA8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C1010(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C1054(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8C10B8(void *a1, uint64_t a2)
{
  sub_1CD657DF4(a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 2));
  if (result)
  {
    if (*(unsigned char *)(result + 16))
    {
      if (*(unsigned char *)(result + 16) != 3 || (*(_DWORD *)(result + 20) & 0x7FFFFFF) != 0) {
        return result;
      }
    }
    else if (*(void *)(result + 72) != result + 72 || (*(unsigned char *)(result + 34) & 0x80) != 0)
    {
      return result;
    }
  }
  uint64_t v4 = *(uint64_t (**)(void *))(a1[4] + 40);

  return v4(a1 + 4);
}

void *sub_1CC8C1160@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "noreturn";
  }
  else {
    uint64_t v3 = "may-return";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 8;
  }
  else {
    size_t v4 = 10;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8C11BC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFE0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFE0))
  {
    __cxa_guard_release(&qword_1EA61BFE0);
  }
}

uint64_t sub_1CC8C1210(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 1;
  int v7 = 1;
  v8[0] = &v7;
  v8[1] = 1;
  unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if ((llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8C1358, (uint64_t)&v10, v5, a1, (uint64_t)v8, &v9, 0, 0) & 1) == 0)return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32); {
  return v4;
  }
}

uint64_t *sub_1CC8C12C8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C12F0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C1358()
{
  return 0;
}

void *sub_1CC8C1360(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C13A4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C1408(uint64_t a1, uint64_t a2)
{
  sub_1CC8C10B8((void *)a1, a2);
  uint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (result)
  {
    uint64_t result = (uint64_t)sub_1CC8B8D14(a2, result, 0, a1, 0, 0, 1);
    if (!*(unsigned char *)(result + 41)) {
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
    }
  }
  return result;
}

void sub_1CC8C146C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFE8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFE8))
  {
    __cxa_guard_release(&qword_1EA61BFE8);
  }
}

uint64_t sub_1CC8C14C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  unint64_t v5 = sub_1CC8B8D14(a2, v4, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned char *)(v3 + 9) == 0;
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 ^ (*(unsigned char *)(v3 + 9) != 0);
}

uint64_t *sub_1CC8C1578(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C15A0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C1608(void *a1)
{
  *a1 = &unk_1F2621540;
  a1[4] = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 5));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C1694(void *a1)
{
  *a1 = &unk_1F2621540;
  a1[4] = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 5));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C1740(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a1 + 88) = 256;
  uint64_t v4 = a1 + 40;
  sub_1CC27F058((_DWORD *)(a1 + 40));
  sub_1CC8C1FE4((char **)(a1 + 64));
  unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!v5) {
    goto LABEL_8;
  }
  unint64_t v6 = v5;
  if (*(unsigned char *)(v5 + 16))
  {
    if (*(unsigned char *)(v5 + 16) != 3 || (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) != 0) {
      goto LABEL_11;
    }
LABEL_8:
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 176);
    return v7(a1);
  }
  if (*(void *)(v5 + 72) == v5 + 72 && (*(unsigned char *)(v5 + 34) & 0x80) == 0) {
    goto LABEL_8;
  }
LABEL_11:
  char v9 = (uint64_t *)sub_1CD64B750(*(void *)(a2 + 88), (const llvm::Function *)v5);
  if ((*(_WORD *)(v6 + 18) & 1) == 0)
  {
    uint64_t v10 = *(void *)(v6 + 88);
LABEL_13:
    uint64_t v11 = v10;
    goto LABEL_14;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)v6);
  uint64_t v10 = *(void *)(v6 + 88);
  if ((*(_WORD *)(v6 + 18) & 1) == 0) {
    goto LABEL_13;
  }
  uint64_t v22 = *(void *)(v6 + 88);
  llvm::Function::BuildLazyArguments((llvm::Function *)v6);
  uint64_t v10 = v22;
  uint64_t v11 = *(void *)(v6 + 88);
LABEL_14:
  uint64_t v12 = v11 + 40 * *(void *)(v6 + 96);
  while (v10 != v12)
  {
    uint64_t v13 = *(void *)(*(void *)(v10 + 24) + 112);
    if (v13)
    {
      unsigned int v14 = *(_DWORD *)(v10 + 32) + 2;
      if (v14 < *(_DWORD *)(v13 + 8))
      {
        uint64_t v15 = *(void *)(v13 + 8 * v14 + 40);
        if (v15)
        {
          if ((*(unsigned char *)(v15 + 17) & 0x40) != 0)
          {
            uint64_t v23 = v10;
            uint64_t v16 = sub_1CD658164(v4, &v23);
            LODWORD(v23) = 1;
            uint64_t v17 = sub_1CD64E2A8(v9, &v23);
            if (v17)
            {
              uint64_t v18 = *(unsigned int *)(v17 + 8);
              if (v18)
              {
                int v19 = *(uint64_t **)v17;
                uint64_t v20 = 8 * v18;
                do
                {
                  uint64_t v21 = *v19++;
                  uint64_t v23 = v21;
                  sub_1CD6582E8(v16, &v23);
                  v20 -= 8;
                }
                while (v20);
              }
            }
            return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 168))(a1);
          }
        }
      }
    }
    v10 += 40;
  }
  uint64_t result = sub_1CD64EF44(a2, (llvm::GlobalValue *)v6);
  if ((result & 1) == 0) {
    goto LABEL_8;
  }
  return result;
}

uint64_t sub_1CC8C195C(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CC8C1964(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CC8C196C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 152))(a1);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 160))(a1))
  {
    unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
    std::to_string(&v10, v5);
  }
  else
  {
    *((unsigned char *)&v10.__r_.__value_.__s + 23) = 1;
    LOWORD(v10.__r_.__value_.__l.__data_) = 63;
  }
  if (v4) {
    unint64_t v6 = "returns(#";
  }
  else {
    unint64_t v6 = "may-return(#";
  }
  uint64_t v7 = std::string::insert(&v10, 0, v6);
  std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  char v9 = std::string::append(&v11, ")");
  *a2 = *v9;
  v9->__r_.__value_.__r.__words[0] = 0;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8C1ABC(uint64_t a1, uint64_t a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCDDE60, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCDDE60))
  {
    __cxa_guard_release(&qword_1EBCDDE60);
  }
  LOBYTE(v11) = 0;
  char v12 = 0;
  uint64_t v4 = **(void **)(*(void *)(sub_1CD648A0C((llvm::IRPosition *)(a1 + 16)) + 24) + 16);
  v9[0] = &v11;
  v9[1] = &v10;
  uint64_t v10 = v4;
  if ((llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8C21E4, (uint64_t)v9, a1) & 1) == 0) {
    return 1;
  }
  uint64_t result = 1;
  if (v12)
  {
    uint64_t v6 = v11;
    if (v11)
    {
      if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCDDE68, memory_order_acquire) & 1) == 0
        && __cxa_guard_acquire(&qword_1EBCDDE68))
      {
        __cxa_guard_release(&qword_1EBCDDE68);
      }
      if (*(unsigned char *)(v6 + 16) == 21)
      {
        uint64_t v7 = *(llvm::Type **)v6;
        unint64_t v8 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
        if (llvm::Type::canLosslesslyBitCastTo(v7, **(llvm::Type ***)(*(void *)(v8 + 24) + 16)))
        {
          *(void *)(a1 + 16) = v6;
          *(void *)(a1 + 24) = 0;
          return sub_1CD657FF8(a1, a2);
        }
      }
      return 1;
    }
  }
  return result;
}

void sub_1CC8C1C08()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFF0))
  {
    __cxa_guard_release(&qword_1EA61BFF0);
  }
}

uint64_t sub_1CC8C1C5C(uint64_t a1, uint64_t a2)
{
  unsigned int v11 = 1;
  v10[0] = a1;
  v10[1] = &v11;
  char v9 = 0;
  v8[0] = a2;
  v8[1] = a1;
  void v8[2] = v10;
  v8[3] = &v9;
  int v6 = 1;
  v7[0] = &v6;
  v7[1] = 1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (llvm::Attributor::checkForAllInstructions(a2, sub_1CC8C2250, (uint64_t)v8, v4, a1, (uint64_t)v7, &v9, 0, 0)) {
    return v11;
  }
  else {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 176))(a1);
  }
}

uint64_t sub_1CC8C1D34(void *a1, uint64_t (*a2)(uint64_t, uint64_t, void *), uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 160))(a1);
  if (result)
  {
    unint64_t v8 = (uint64_t *)a1[8];
    uint64_t v7 = (uint64_t *)a1[9];
    if (v8 == v7)
    {
      return 1;
    }
    else
    {
      do
      {
        char v9 = v8 + 1;
        uint64_t v10 = *v8;
        v8 += 12;
        uint64_t result = a2(a3, v10, v9);
        if (result) {
          BOOL v11 = v8 == v7;
        }
        else {
          BOOL v11 = 1;
        }
      }
      while (!v11);
    }
  }
  return result;
}

uint64_t sub_1CC8C1DBC(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_1CC8C1DC8(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

unint64_t sub_1CC8C1DD4(void *a1)
{
  if ((*(unsigned int (**)(void *))(*a1 + 160))(a1)) {
    return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[9] - a1[8]) >> 5);
  }
  else {
    return -1;
  }
}

uint64_t sub_1CC8C1E3C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 88);
}

uint64_t sub_1CC8C1E44(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 89);
}

uint64_t sub_1CC8C1E4C(uint64_t a1)
{
  *(unsigned char *)(a1 + 88) = 1;
  return 1;
}

uint64_t sub_1CC8C1E5C(uint64_t a1)
{
  *(_WORD *)(a1 + 88) = 1;
  return 0;
}

uint64_t *sub_1CC8C1E6C(void *a1)
{
  *(a1 - 4) = &unk_1F2621540;
  *a1 = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 1));
  *(a1 - 4) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 3);
}

void sub_1CC8C1EFC(void *a1)
{
  *(a1 - 4) = &unk_1F2621540;
  *a1 = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 1));
  *(a1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C1FA4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 57);
}

uint64_t sub_1CC8C1FAC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t sub_1CC8C1FB4(uint64_t a1)
{
  *(unsigned char *)(a1 + 56) = 1;
  return 1;
}

uint64_t sub_1CC8C1FC4(uint64_t a1)
{
  *(_WORD *)(a1 + 56) = 1;
  return 0;
}

void sub_1CC8C1FE4(char **a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    unint64_t v4 = v2 - 32;
    do
    {
      unint64_t v5 = (char *)*((void *)v4 - 2);
      if (v4 != v5) {
        free(v5);
      }
      if ((*(v4 - 56) & 1) == 0) {
        MEMORY[0x1D25D9CD0](*((void *)v4 - 6), 8);
      }
      int v6 = v4 - 64;
      v4 -= 96;
    }
    while (v6 != v3);
  }
  a1[1] = v3;
}

void sub_1CC8C2054(unsigned int **a1, uint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 < v4)
  {
    *(void *)unint64_t v5 = *(void *)a2;
    int v6 = v5 + 24;
    sub_1CD4B575C((uint64_t)(v5 + 2), (unsigned int *)(a2 + 8));
    goto LABEL_24;
  }
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)*a1) >> 5);
  unint64_t v8 = v7 + 1;
  if (v7 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - (void)*a1) >> 5);
  if (2 * v9 > v8) {
    unint64_t v8 = 2 * v9;
  }
  if (v9 >= 0x155555555555555) {
    unint64_t v10 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v10 = v8;
  }
  if (v10)
  {
    if (v10 > 0x2AAAAAAAAAAAAAALL) {
      sub_1CB833614();
    }
    BOOL v11 = (char *)operator new(96 * v10);
  }
  else
  {
    BOOL v11 = 0;
  }
  char v12 = &v11[96 * v7];
  uint64_t v13 = (unsigned int *)&v11[96 * v10];
  *(void *)char v12 = *(void *)a2;
  int v6 = (unsigned int *)(v12 + 96);
  sub_1CD4B575C((uint64_t)(v12 + 8), (unsigned int *)(a2 + 8));
  uint64_t v15 = *a1;
  unsigned int v14 = a1[1];
  if (v14 == *a1)
  {
    *a1 = (unsigned int *)v12;
    a1[1] = v6;
    a1[2] = v13;
    if (!v14) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  do
  {
    uint64_t v16 = *((void *)v14 - 12);
    v14 -= 24;
    *((void *)v12 - 12) = v16;
    v12 -= 96;
    sub_1CD4B575C((uint64_t)(v12 + 8), v14 + 2);
  }
  while (v14 != v15);
  unsigned int v14 = *a1;
  uint64_t v17 = a1[1];
  *a1 = (unsigned int *)v12;
  a1[1] = v6;
  a1[2] = v13;
  if (v17 != v14)
  {
    uint64_t v18 = v17 - 8;
    do
    {
      int v19 = (unsigned int *)*((void *)v18 - 2);
      if (v18 != v19) {
        free(v19);
      }
      if ((*(unsigned char *)(v18 - 14) & 1) == 0) {
        MEMORY[0x1D25D9CD0](*((void *)v18 - 6), 8);
      }
      uint64_t v20 = v18 - 16;
      v18 -= 24;
    }
    while (v20 != v14);
  }
  if (v14) {
LABEL_23:
  }
    operator delete(v14);
LABEL_24:
  a1[1] = v6;
}

BOOL sub_1CC8C21E4(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a2;
  uint64_t v3 = 1;
  char v9 = 1;
  unint64_t v4 = llvm::AA::combineOptionalValuesInAAValueLatice(*(unsigned __int8 **)a1, (uint64_t)&v8, **(llvm::Value ***)(a1 + 8));
  unint64_t v5 = *(unsigned __int8 **)a1;
  *(void *)unint64_t v5 = v4;
  *((void *)v5 + 1) = v6;
  if (*(unsigned char *)(*(void *)a1 + 8)) {
    return **(void **)a1 != 0;
  }
  return v3;
}

uint64_t sub_1CC8C2250(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  v133[12] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(llvm::Attributor **)a1;
  uint64_t v3 = *(const llvm::AbstractAttribute **)(a1 + 8);
  uint64_t v5 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
  unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 != 21)
  {
    if (v6 < 0x1C)
    {
      if (!*(unsigned char *)(v5 + 16)) {
        v5 |= 2uLL;
      }
    }
    else
    {
      unsigned int v7 = v6 - 33;
      BOOL v8 = v7 > 0x33;
      uint64_t v9 = (1 << v7) & 0x8000000000041;
      if (!v8 && v9 != 0) {
        v5 |= 1uLL;
      }
    }
  }
  uint64_t v11 = *(void *)(a1 + 16);
  char v12 = *(BOOL **)(a1 + 24);
  v109[0] = v5;
  v109[1] = 0;
  v130[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v130[i] = -4096;
  uint64_t v131 = v133;
  uint64_t v132 = 0x400000000;
  unint64_t v14 = sub_1CD6482F0((llvm::IRPosition *)v109);
  int v107 = 0;
  v127[0] = v128;
  v127[1] = (void *)0x1000000000;
  v129[1] = 0;
  v129[0] = 0;
  v128[32] = v129;
  int64x2_t v123 = v126;
  unsigned int v125 = 16;
  v126[0] = v14;
  v126[1] = v2;
  unint64_t v105 = v3;
  uint64_t v103 = v2;
  unint64_t v102 = v14;
  int64x2_t v101 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v15 = 1;
  int64_t v104 = v4;
  uint64_t v106 = v11;
  do
  {
    uint64_t v16 = (char *)v123 + 16 * v15;
    uint64_t v18 = *((void *)v16 - 2);
    unint64_t v17 = *((void *)v16 - 1);
    unsigned int v124 = v15 - 1;
    v108[0] = v18;
    v108[1] = v17;
    if ((sub_1CD65837C((uint64_t)v127, v108) & 0x100000000) == 0) {
      goto LABEL_104;
    }
    if (v107 >= 16) {
      goto LABEL_174;
    }
    ++v107;
    if (*(unsigned char *)(*(void *)v18 + 8) == 15)
    {
      int v19 = llvm::Value::stripPointerCasts((llvm::Value *)v18);
      goto LABEL_17;
    }
    unsigned int v22 = *(unsigned __int8 *)(v18 + 16);
    if (v22 < 0x1C) {
      goto LABEL_42;
    }
    unsigned int v23 = v22 - 33;
    BOOL v8 = v23 > 0x33;
    uint64_t v24 = (1 << v23) & 0x8000000000041;
    if (v8 || v24 == 0) {
      goto LABEL_42;
    }
    uint64_t v26 = *(void *)(v18 - 32);
    if (!v26 || *(unsigned char *)(v26 + 16) || *(void *)(v26 + 24) != *(void *)(v18 + 72)) {
      goto LABEL_42;
    }
    if ((*(_WORD *)(v26 + 18) & 1) == 0)
    {
      uint64_t v27 = *(void *)(v26 + 88);
LABEL_33:
      uint64_t v28 = v27;
      goto LABEL_34;
    }
    llvm::Function::BuildLazyArguments(*(llvm::Function **)(v18 - 32));
    uint64_t v27 = *(void *)(v26 + 88);
    if ((*(_WORD *)(v26 + 18) & 1) == 0) {
      goto LABEL_33;
    }
    llvm::Function::BuildLazyArguments((llvm::Function *)v26);
    uint64_t v28 = *(void *)(v26 + 88);
LABEL_34:
    uint64_t v29 = v28 + 40 * *(void *)(v26 + 96);
    while (1)
    {
      if (v27 == v29) {
        goto LABEL_42;
      }
      uint64_t v30 = *(void *)(*(void *)(v27 + 24) + 112);
      if (v30)
      {
        uint64_t v31 = *(unsigned int *)(v27 + 32);
        if ((v31 + 2) < *(_DWORD *)(v30 + 8))
        {
          uint64_t v32 = *(void *)(v30 + 8 * (v31 + 2) + 40);
          if (v32)
          {
            if ((*(unsigned char *)(v32 + 17) & 0x40) != 0) {
              break;
            }
          }
        }
      }
      v27 += 40;
    }
    int v19 = *(llvm::Value **)(v18 - 32 * (*(_DWORD *)(v18 + 20) & 0x7FFFFFF) + 32 * v31);
LABEL_17:
    if (v19) {
      BOOL v20 = v19 == (llvm::Value *)v18;
    }
    else {
      BOOL v20 = 1;
    }
    if (!v20)
    {
LABEL_21:
      if (v124 >= (unint64_t)v125) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v21 = (char *)v123 + 16 * v124;
      *(void *)uint64_t v21 = v19;
      goto LABEL_103;
    }
LABEL_42:
    unsigned int v33 = *(unsigned __int8 *)(v18 + 16);
    if (v33 == 83)
    {
      uint64_t v39 = *(void *)(*(void *)(v18 + 40) + 56);
      uint64_t v110 = v39;
      int v111 = 0;
      sub_1CD645794((uint64_t)&v117, (uint64_t)v130, &v110, &v111);
      uint64_t v40 = v117;
      if (v118.i8[8])
      {
        *(_DWORD *)&v112[20] = 0;
        *(_DWORD *)&v112[17] = 0;
        *(void *)uint64_t v112 = v39;
        *(void *)&v112[8] = 0;
        v112[16] = 0;
        if (v132 >= HIDWORD(v132))
        {
          if (v131 > v112 || (char *)v131 + 24 * v132 <= v112) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        size_t v45 = (char *)v131 + 24 * v132;
        long long v46 = *(_OWORD *)v112;
        *((void *)v45 + 2) = *(void *)&v112[16];
        *(_OWORD *)size_t v45 = v46;
        unsigned int v41 = v132;
        LODWORD(v132) = v132 + 1;
        *(_DWORD *)(v40 + 8) = v41;
      }
      else
      {
        unsigned int v41 = *(_DWORD *)(v117 + 8);
      }
      long long v47 = (char *)v131;
      int v48 = (char *)v131 + 24 * v41;
      uint64_t v50 = *((void *)v48 + 1);
      char v49 = (llvm::AbstractAttribute **)(v48 + 8);
      if (!v50) {
        *char v49 = sub_1CC8AC178((uint64_t)v4, v39, 0, (uint64_t)v3, 2, 0, 1);
      }
      uint64_t v51 = *(_DWORD *)(v18 + 20) & 0x7FFFFFF;
      if (v51)
      {
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        char v54 = &v47[24 * v41 + 16];
        uint64_t v55 = 8 * v51;
        do
        {
          int v56 = *(_DWORD *)(v18 + 20);
          if ((v56 & 0x40000000) != 0) {
            uint64_t v57 = *(void *)(v18 - 8);
          }
          else {
            uint64_t v57 = v18 - 32 * (v56 & 0x7FFFFFF);
          }
          uint64_t v58 = *(void *)(v57 + 32 * *(unsigned int *)(v18 + 60) + v53);
          if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v49 + 168))(*v49, v58, *(void *)(v18 + 40)))
          {
            *char v54 = 1;
            *v12 |= (*(unsigned __int8 (**)(void))(*((void *)*v49 + 4) + 24))() ^ 1;
          }
          else
          {
            int v59 = *(_DWORD *)(v18 + 20);
            if ((v59 & 0x40000000) != 0) {
              uint64_t v60 = *(void *)(v18 - 8);
            }
            else {
              uint64_t v60 = v18 - 32 * (v59 & 0x7FFFFFF);
            }
            uint64_t v61 = *(void *)(v58 + 40);
            if (v61 == v58 + 40)
            {
              uint64_t v63 = 0;
            }
            else
            {
              if (v61) {
                uint64_t v62 = v61 - 24;
              }
              else {
                uint64_t v62 = 0;
              }
              if (*(unsigned __int8 *)(v62 + 16) - 29 >= 0xB) {
                uint64_t v63 = 0;
              }
              else {
                uint64_t v63 = v62;
              }
            }
            uint64_t v64 = *(void *)(v60 + v52);
            if (v124 >= (unint64_t)v125) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v65 = (char *)v123 + 16 * v124;
            *uint64_t v65 = v64;
            v65[1] = v63;
            ++v124;
          }
          v53 += 8;
          v52 += 32;
        }
        while (v55 != v53);
        unint64_t v4 = v104;
        uint64_t v3 = v105;
        uint64_t v2 = v103;
      }
      goto LABEL_104;
    }
    if (v33 == 85)
    {
      uint64_t v34 = *(void *)(v18 - 96);
      unsigned int v35 = *(unsigned __int8 *)(v34 + 16);
      if (v35 != 21)
      {
        if (v35 < 0x1C)
        {
          if (!*(unsigned char *)(v34 + 16)) {
            v34 |= 2uLL;
          }
        }
        else
        {
          unsigned int v36 = v35 - 33;
          BOOL v8 = v36 > 0x33;
          uint64_t v37 = (1 << v36) & 0x8000000000041;
          if (!v8 && v37 != 0) {
            v34 |= 1uLL;
          }
        }
      }
      uint64_t v117 = v34;
      v118.i64[0] = 0;
      AssumedConstant = llvm::Attributor::getAssumedConstant(v4, (const llvm::IRPosition *)&v117, v3, v12);
      if (!v73) {
        goto LABEL_104;
      }
      if (!AssumedConstant) {
        goto LABEL_99;
      }
      int v77 = *((unsigned __int8 *)AssumedConstant + 16);
      if ((v77 - 11) < 2) {
        goto LABEL_104;
      }
      if (v77 != 16)
      {
LABEL_99:
        if (v124 >= (unint64_t)v125) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v74 = (char *)v123 + 16 * v124;
        *uint64_t v74 = *(void *)(v18 - 64);
        v74[1] = v17;
        unsigned int v75 = v124 + 1;
        unsigned int v124 = v75;
        uint64_t v76 = *(void *)(v18 - 32);
        if (v75 >= v125) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v21 = (char *)v123 + 16 * v75;
LABEL_102:
        *(void *)uint64_t v21 = v76;
LABEL_103:
        *((void *)v21 + 1) = v17;
        ++v124;
        goto LABEL_104;
      }
      uint64_t v78 = *((unsigned int *)AssumedConstant + 8);
      if (v78 > 0x40)
      {
        int v79 = 0;
        int64_t v80 = (unint64_t)(v78 + 63) >> 6;
        do
        {
          BOOL v8 = v80-- < 1;
          if (v8) {
            break;
          }
          unint64_t v81 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v80);
          v79 += __clz(v81);
        }
        while (!v81);
        int v82 = v78 | 0xFFFFFFC0;
        if ((v78 & 0x3F) == 0) {
          int v82 = 0;
        }
        if (v79 + v82 != v78) {
          goto LABEL_110;
        }
      }
      else if (*((void *)AssumedConstant + 3))
      {
LABEL_110:
        uint64_t v76 = *(void *)(v18 - 64);
LABEL_118:
        if (v124 >= (unint64_t)v125) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v21 = (char *)v123 + 16 * v124;
        goto LABEL_102;
      }
      uint64_t v76 = *(void *)(v18 - 32);
      goto LABEL_118;
    }
    uint64_t v42 = v106;
    if (v33 < 0x15) {
      goto LABEL_54;
    }
    uint64_t v66 = v18;
    if (v33 >= 0x1C)
    {
      unsigned int v67 = v33 - 33;
      uint64_t v66 = v18;
      if (v67 <= 0x33)
      {
        uint64_t v66 = v18;
        if (((1 << v67) & 0x8000000000041) != 0) {
          uint64_t v66 = v18 | 1;
        }
      }
    }
    uint64_t v117 = v66;
    v118.i64[0] = 0;
    unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(v4, (const llvm::IRPosition *)&v117, v3, v12);
    if (!v69) {
      goto LABEL_104;
    }
    int v19 = (llvm::Value *)AssumedSimplified;
    if (!AssumedSimplified || v18 == AssumedSimplified) {
      goto LABEL_122;
    }
    if (!v17) {
      goto LABEL_21;
    }
    unsigned int v70 = *(unsigned __int8 *)(AssumedSimplified + 16);
    if (v70 < 0x15) {
      goto LABEL_21;
    }
    if (v70 >= 0x1C)
    {
      uint64_t v71 = (void *)(*(void *)(AssumedSimplified + 40) + 56);
LABEL_121:
      if (*v71 == *(void *)(*(void *)(v17 + 40) + 56)) {
        goto LABEL_21;
      }
      goto LABEL_122;
    }
    if (v70 == 21)
    {
      uint64_t v71 = (void *)(AssumedSimplified + 24);
      goto LABEL_121;
    }
LABEL_122:
    if (*(unsigned char *)(v18 + 16) != 60) {
      goto LABEL_54;
    }
    LOBYTE(v110) = 0;
    if (*(void *)(v18 - 32) == v102) {
      goto LABEL_159;
    }
    uint64_t v117 = 1;
    int64x2_t v118 = v101;
    int64x2_t v119 = v101;
    uint64_t v120 = v122;
    uint64_t v121 = 0x400000000;
    *(void *)uint64_t v112 = 1;
    *(int64x2_t *)&v112[8] = v101;
    int64x2_t v113 = v101;
    uint64_t v114 = v116;
    uint64_t v115 = 0x400000000;
    int v83 = 1;
    if (!llvm::AA::getPotentiallyLoadedValues(v4, v18, &v117, v112, v3, (BOOL *)&v110, 1))
    {
      int v84 = 0;
      goto LABEL_151;
    }
    if (!v121)
    {
LABEL_126:
      int v83 = 0;
      int v84 = 1;
      goto LABEL_151;
    }
    uint64_t v85 = v2;
    char v86 = (int64_t *)v120;
    uint64_t v87 = 8 * v121;
    do
    {
      int v83 = 1;
      if (!llvm::AA::isDynamicallyUnique(v4, v3, *v86, (const llvm::Value *)1))
      {
        int v84 = 0;
LABEL_150:
        uint64_t v2 = v85;
        goto LABEL_151;
      }
      ++v86;
      v87 -= 8;
    }
    while (v87);
    unsigned int v88 = v120;
    uint64_t v2 = v85;
    if (!v17)
    {
LABEL_143:
      if (!v121) {
        goto LABEL_126;
      }
      unsigned int v94 = v124;
      uint64_t v95 = 8 * v121;
      do
      {
        if (v94 >= v125) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v96 = (char *)v123 + 16 * v94;
        *int v96 = *v88;
        v96[1] = v17;
        unsigned int v94 = ++v124;
        ++v88;
        v95 -= 8;
      }
      while (v95);
      int v83 = 0;
      int v84 = 1;
      goto LABEL_150;
    }
    if (!v121) {
      goto LABEL_126;
    }
    uint64_t v89 = 8 * v121;
    char v90 = (char *)v120;
    while (1)
    {
      uint64_t v91 = *(void *)v90;
      unsigned int v92 = *(unsigned __int8 *)(*(void *)v90 + 16);
      if (v92 >= 0x15)
      {
        if (v92 >= 0x1C)
        {
          unsigned int v93 = (void *)(*(void *)(v91 + 40) + 56);
        }
        else
        {
          if (v92 != 21) {
            break;
          }
          unsigned int v93 = (void *)(v91 + 24);
        }
        if (*v93 != *(void *)(*(void *)(v17 + 40) + 56)) {
          break;
        }
      }
      v90 += 8;
      v89 -= 8;
      if (!v89) {
        goto LABEL_143;
      }
    }
    int v84 = 0;
    int v83 = 1;
LABEL_151:
    if (v114 != v116) {
      free(v114);
    }
    if ((v112[0] & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)&v112[8], 8);
    }
    if (v120 != v122) {
      free(v120);
    }
    if ((v117 & 1) == 0)
    {
      MEMORY[0x1D25D9CD0](v118.i64[0], 8);
      if (!v83) {
        goto LABEL_163;
      }
LABEL_159:
      uint64_t v42 = v106;
LABEL_54:
      uint64_t v43 = *(void *)v42 + 40;
      uint64_t v117 = v18;
      uint64_t v44 = sub_1CD658164(v43, &v117);
      *(void *)uint64_t v112 = v2;
      if (sub_1CD6582E8(v44, (uint64_t *)v112)) {
        **(_DWORD **)(v42 + 8) = 0;
      }
      goto LABEL_104;
    }
    if (v83) {
      goto LABEL_159;
    }
LABEL_163:
    if (!v84)
    {
LABEL_174:
      uint64_t v97 = 0;
      goto LABEL_175;
    }
LABEL_104:
    unsigned int v15 = v124;
  }
  while (v124);
  if (v132)
  {
    uint64_t v99 = 24 * v132;
    unsigned int v100 = (char *)v131 + 16;
    do
    {
      if (*v100) {
        llvm::Attributor::recordDependence((uint64_t)v4, *((void *)v100 - 1), (uint64_t)v3, 1);
      }
      v100 += 24;
      v99 -= 24;
    }
    while (v99);
  }
  uint64_t v97 = 1;
LABEL_175:
  if (v123 != v126) {
    free(v123);
  }
  sub_1CD40B1BC(v129[0]);
  if (v127[0] != v128) {
    free(v127[0]);
  }
  if (v131 != v133) {
    free(v131);
  }
  if ((v130[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v130[1], 8);
  }
  return v97;
}

void *sub_1CC8C2DC8(void *a1)
{
  *a1 = &unk_1F2621540;
  a1[4] = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 5));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C2E54(void *a1)
{
  *a1 = &unk_1F2621540;
  a1[4] = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 5));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C2F08(uint64_t a1)
{
  *(_WORD *)(a1 + 88) = 1;
  return 0;
}

uint64_t *sub_1CC8C2F18(void *a1)
{
  *(a1 - 4) = &unk_1F2621540;
  *a1 = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 1));
  *(a1 - 4) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 3);
}

void sub_1CC8C2FA8(void *a1)
{
  *(a1 - 4) = &unk_1F2621540;
  *a1 = &unk_1F2621608;
  sub_1CD658118((uint64_t)(a1 + 1));
  *(a1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8C3054(void *a1)
{
  sub_1CC8C3B74(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8C308C(_DWORD *a1, uint64_t a2)
{
  v18[2] = *MEMORY[0x1E4F143B8];
  a1[11] = a1[11] & 0x1FF | a1[10];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 4);
  uint64_t v5 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD6482A0(v4);
  BOOL v9 = !v6
    || (unsigned int v7 = (_DWORD *)v6, v8 = *(uint64_t **)(a2 + 80), v8[3] != v8[4])
    && (uint64_t v15 = 0, v16 = v7, !sub_1CD420258(v8, &v16, &v15))
    || (v7[8] & 0xFu) - 9 < 0xFFFFFFFE;
  uint64_t v16 = v18;
  uint64_t v17 = 0x200000000;
  llvm::IRPosition::getAttrs(v4, (unsigned int *)dword_1CFB2739C, 4, (uint64_t)&v16, 0, 0);
  unint64_t v10 = (char *)v16;
  if (v17)
  {
    uint64_t v11 = 8 * v17;
    while (1)
    {
      int v12 = *(_DWORD *)(*(void *)v10 + 12);
      if (v12 > 11)
      {
        if (v12 == 12)
        {
          if (!v9)
          {
            LODWORD(v15) = 12;
            goto LABEL_22;
          }
          uint64_t v13 = *(void *)(v5 + 8) | 0xCC000000CCLL;
        }
        else
        {
          uint64_t v13 = *(void *)(v5 + 8) | 0x300000003;
        }
      }
      else if (v12 == 3)
      {
        if (!v9)
        {
          LODWORD(v15) = 3;
LABEL_22:
          sub_1CD658824(v4, (int *)&v15, 1);
          goto LABEL_18;
        }
        uint64_t v13 = *(void *)(v5 + 8) | 0xEC000000ECLL;
      }
      else
      {
        uint64_t v13 = *(void *)(v5 + 8) | 0xDC000000DCLL;
      }
      *(void *)(v5 + 8) = v13;
LABEL_18:
      v10 += 8;
      v11 -= 8;
      if (!v11)
      {
        unint64_t v10 = (char *)v16;
        break;
      }
    }
  }
  if (v10 != (char *)v18) {
    free(v10);
  }
  return sub_1CD65857C(a1, a2);
}

uint64_t sub_1CC8C3288(uint64_t a1, uint64_t a2)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 16);
  unint64_t v14 = v16;
  uint64_t v15 = 0x400000000;
  char v6 = ~(_BYTE)v4;
  unint64_t v7 = v4 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v6 & 3) == 0) {
    unint64_t v7 = *(void *)(v7 + 24);
  }
  (*(void (**)(uint64_t, void, void **))(*(void *)a1 + 112))(a1, **(void **)v7, &v14);
  if (v15)
  {
    BOOL v8 = (uint64_t *)v14;
    uint64_t v9 = 8 * v15;
    while (1)
    {
      uint64_t v10 = *v8;
      if (*v8) {
        LODWORD(v10) = *(_DWORD *)(v10 + 12);
      }
      unsigned int v13 = v10;
      if (!llvm::IRPosition::hasAttr(v5, &v13, 1, 1, 0)) {
        break;
      }
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_9;
      }
    }
    sub_1CD658824(v5, dword_1CFB2739C, 4);
    if ((~*(_DWORD *)(a1 + 44) & 0xFC) == 0) {
      sub_1CD658824(v5, dword_1CFB273AC, 3);
    }
    uint64_t v11 = sub_1CD6586DC(a1, a2);
  }
  else
  {
LABEL_9:
    uint64_t v11 = 1;
  }
  if (v14 != v16) {
    free(v14);
  }
  return v11;
}

void sub_1CC8C3404(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 44);
  if ((~v1 & 0xFC) != 0)
  {
    if ((~v1 & 0xEC) != 0)
    {
      if ((~v1 & 0xDC) != 0)
      {
        if (~v1 & 0xCC) != 0 || (atomic_load_explicit(byte_1EBCDDE88, memory_order_acquire)) {
          return;
        }
        uint64_t v2 = (__guard *)byte_1EBCDDE88;
      }
      else
      {
        if (atomic_load_explicit(byte_1EBCDDE80, memory_order_acquire)) {
          return;
        }
        uint64_t v2 = (__guard *)byte_1EBCDDE80;
      }
    }
    else
    {
      if (atomic_load_explicit(byte_1EBCDDE78, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDE78;
    }
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDE70, memory_order_acquire)) {
      return;
    }
    uint64_t v2 = (__guard *)byte_1EBCDDE70;
  }
  if (__cxa_guard_acquire(v2))
  {
    __cxa_guard_release(v2);
  }
}

BOOL sub_1CC8C34EC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1CC8B2D1C(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 2, 0, 1);
  if ((~*((unsigned __int8 *)v4 + 41) & 3) != 0)
  {
    int v7 = *(_DWORD *)(a1 + 44);
    unsigned __int8 v10 = 0;
    v9[0] = a1;
    v9[1] = a2;
    void v9[2] = &v10;
    if (llvm::Attributor::checkForAllReadWriteInstructions(a2, (unsigned int (*)(uint64_t, uint64_t))sub_1CC8C3C34, (uint64_t)v9, a1, &v8))
    {
      return (v10 | (v7 != *(_DWORD *)(a1 + 44))) == 0;
    }
    else
    {
      sub_1CC8C382C((_DWORD *)a1);
      return 0;
    }
  }
  else if ((~*((unsigned __int8 *)v4 + 40) & 3) != 0)
  {
    uint64_t v5 = 1;
    llvm::Attributor::recordDependence(a2, (uint64_t)v4, a1, 1);
  }
  else
  {
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
    return 1;
  }
  return v5;
}

unint64_t sub_1CC8C35F0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if ((~*(_DWORD *)(a1 + 44) & 0xFC) != 0)
  {
    unint64_t result = sub_1CD647DEC((void *)(a1 + 16));
    if (result != 4) {
      return result;
    }
    int v10 = *(_DWORD *)(a1 + 44);
    if ((~v10 & 0xDC) != 0)
    {
      if ((~v10 & 0xEC) != 0)
      {
        if ((~v10 & 0xCC) != 0) {
          return result;
        }
        uint64_t v5 = a2;
        unsigned int v6 = 12;
      }
      else
      {
        uint64_t v5 = a2;
        unsigned int v6 = 3;
      }
    }
    else
    {
      uint64_t v5 = a2;
      unsigned int v6 = 11;
    }
  }
  else
  {
    uint64_t v5 = a2;
    unsigned int v6 = 44;
  }
  unint64_t result = llvm::Attribute::get(v5, v6, 0);
  unsigned int v8 = *(_DWORD *)(a3 + 8);
  if (v8 >= *(_DWORD *)(a3 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a3 + 8 * v8) = result;
  ++*(_DWORD *)(a3 + 8);
  return result;
}

uint64_t sub_1CC8C36E0(uint64_t a1, uint64_t (*a2)(uint64_t, void, void, void, uint64_t), uint64_t a3, int a4)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (result)
  {
    if (*(_DWORD *)(a1 + 44) == 255)
    {
      return 1;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = 1;
      while (1)
      {
        if ((v10 & a4) == 0)
        {
          uint64_t v11 = *(void *)(a1 + 8 * v9 + 48);
          if (v11)
          {
            uint64_t v12 = *(void *)(v11 + 80);
            if (v12)
            {
              uint64_t v13 = v11 + 72;
              unint64_t v14 = *(void **)(v11 + 64);
            }
            else
            {
              unint64_t v14 = *(void **)v11;
              uint64_t v13 = *(void *)v11 + 24 * *(unsigned int *)(v11 + 8);
            }
            if (v14 != (void *)v13) {
              break;
            }
          }
        }
LABEL_7:
        uint64_t v10 = (2 * v10);
        if (++v9 == 8) {
          return 1;
        }
      }
      while (1)
      {
        uint64_t v15 = v14 + 4;
        if (!v12) {
          uint64_t v15 = v14;
        }
        uint64_t result = a2(a3, *v15, v15[1], *((unsigned int *)v15 + 4), v10);
        if (!result) {
          break;
        }
        if (v12)
        {
          uint64_t v16 = (void *)v14[1];
          if (v16)
          {
            do
            {
              uint64_t v17 = v16;
              uint64_t v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              uint64_t v17 = (void *)v14[2];
              BOOL v18 = *v17 == (void)v14;
              unint64_t v14 = v17;
            }
            while (!v18);
          }
        }
        else
        {
          uint64_t v17 = v14 + 3;
        }
        unint64_t v14 = v17;
        if (v17 == (void *)v13) {
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CC8C382C(_DWORD *a1)
{
  char v28 = 0;
  int v2 = a1[10];
  unint64_t v3 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 4));
  uint64_t v4 = v3;
  unsigned int v5 = *(unsigned __int8 *)(v3 + 16);
  if (v5 >= 0x1C) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = 0;
  }
  unint64_t v27 = v3 - 8;
  unsigned int v7 = 1;
  do
  {
    if ((v7 & v2) != 0) {
      goto LABEL_42;
    }
    uint64_t v8 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 40))(a1);
    if (v5 >= 0x1C)
    {
      int v10 = 0;
      int v11 = *(unsigned __int8 *)(v4 + 16);
      uint64_t v12 = (v11 - 33);
      if (v12 > 0x37) {
        goto LABEL_26;
      }
      if (((1 << (v11 - 33)) & 0x8000000000041) == 0)
      {
        if (((1 << (v11 - 33)) & 0x808001C8000010) == 0)
        {
          if (v12 != 28) {
            goto LABEL_26;
          }
          int v10 = (*(_WORD *)(v4 + 18) & 0x301) != 0;
LABEL_25:
          int v11 = *(unsigned __int8 *)(v4 + 16);
LABEL_26:
          int v15 = 0;
          uint64_t v16 = (v11 - 33);
          if (v16 > 0x37) {
            goto LABEL_40;
          }
          if (((1 << v16) & 0x8000000000041) != 0)
          {
            uint64_t v17 = *(void *)(v4 + 64);
            if (!v17 || (*(unsigned char *)(v17 + 17) & 0x30) == 0)
            {
              int v18 = *(_DWORD *)(v4 + 20);
              if (v18 < 0)
              {
                BOOL v20 = (void *)(v27 - 32 * (v18 & 0x7FFFFFF));
                if (*v20)
                {
                  uint64_t v21 = -*v20;
                  do
                  {
                    unsigned int v22 = *(_DWORD *)(*(void *)((char *)v20 + v21) + 8);
                    BOOL v23 = v22 > 7;
                    int v24 = (1 << v22) & 0x83;
                    if (v23 || v24 == 0) {
                      goto LABEL_38;
                    }
                    v21 += 16;
                  }
                  while (v21);
                }
              }
              if ((llvm::CallBase::hasFnAttrOnCalledFunction(v4, 45) & 1) == 0
                && (llvm::CallBase::hasFnAttrOnCalledFunction(v4, 44) & 1) == 0)
              {
                goto LABEL_38;
              }
            }
          }
          else
          {
            if (v16 != 27)
            {
              if (((1 << v16) & 0x808001D0000010) != 0) {
                goto LABEL_38;
              }
LABEL_40:
              int v9 = v15 | v10;
              goto LABEL_41;
            }
            if ((*(_WORD *)(v4 + 18) & 0x301) != 0)
            {
LABEL_38:
              int v15 = 2;
              goto LABEL_40;
            }
          }
          int v15 = 0;
          goto LABEL_40;
        }
LABEL_24:
        int v10 = 1;
        goto LABEL_25;
      }
      uint64_t v13 = *(void *)(v4 + 64);
      if (!v13 || (*(unsigned char *)(v13 + 20) & 4) == 0 && (*(unsigned char *)(v13 + 17) & 0x10) == 0)
      {
        __int32 v29 = 7;
        if (sub_1CC5CB59C(v4, &v29, 1uLL))
        {
          uint64_t v14 = *(void *)(v4 - 32);
          if (!v14
            || *(unsigned char *)(v14 + 16)
            || *(void *)(v14 + 24) != *(void *)(v4 + 72)
            || *(_DWORD *)(v14 + 36) != 7)
          {
            goto LABEL_24;
          }
        }
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v4, 66) & 1) == 0)
        {
          int v10 = llvm::CallBase::hasFnAttrOnCalledFunction(v4, 44) ^ 1;
          goto LABEL_25;
        }
      }
      int v10 = 0;
      goto LABEL_25;
    }
    int v9 = 3;
LABEL_41:
    sub_1CC8C4528((uint64_t)a1, v8, v7, v6, 0, &v28, v9);
LABEL_42:
    BOOL v19 = v7 >= 0x80;
    v7 *= 2;
  }
  while (!v19);
  a1[11] = a1[10];
  return 0;
}

void *sub_1CC8C3B00(uint64_t a1)
{
  return sub_1CC8C3B74((void *)(a1 - 32));
}

void sub_1CC8C3B08(uint64_t a1)
{
  sub_1CC8C3B74((void *)(a1 - 32));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C3B44(uint64_t a1)
{
  return 0;
}

void *sub_1CC8C3B74(void *a1)
{
  *a1 = &unk_1F2621848;
  a1[4] = &unk_1F26218E0;
  for (uint64_t i = 6; i != 14; ++i)
  {
    uint64_t v3 = a1[i];
    if (v3)
    {
      sub_1CBB0D544(*(void **)(v3 + 72));
      if (*(void *)v3 != v3 + 16) {
        free(*(void **)v3);
      }
    }
  }
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

BOOL sub_1CC8C3C34(uint64_t *a1, uint64_t a2)
{
  BOOL v3 = 0;
  uint64_t v4 = *a1;
  unsigned int v5 = (llvm::Attributor *)a1[1];
  uint64_t v6 = (unsigned char *)a1[2];
  int v82 = &unk_1F2621940;
  uint64_t v83 = 0xFF00000000;
  unsigned int v7 = *(unsigned __int8 *)(a2 + 16);
  if (v7 <= 0x3B)
  {
    if (v7 != 33 && v7 != 39)
    {
      if (v7 != 37) {
        goto LABEL_26;
      }
      goto LABEL_104;
    }
  }
  else
  {
    if (*(unsigned __int8 *)(a2 + 16) <= 0x4Fu)
    {
      uint64_t v8 = -1;
      switch(*(unsigned char *)(a2 + 16))
      {
        case '<':
        case '=':
          break;
        case '?':
          goto LABEL_104;
        case '@':
          uint64_t v8 = -3;
          break;
        case 'A':
          uint64_t v8 = -2;
          break;
        default:
          goto LABEL_26;
      }
      uint64_t v15 = *(void *)(a2 + 32 * v8);
      if (v15)
      {
        sub_1CC8C483C(v4, v5, a2, v15, (uint64_t)&v82, v6);
        goto LABEL_155;
      }
      if (v7 != 60)
      {
        if (v7 == 61)
        {
          BOOL v3 = (*(_WORD *)(a2 + 18) & 0x301) != 0;
          goto LABEL_25;
        }
        if (v7 - 63 > 2)
        {
          BOOL v3 = 0;
LABEL_25:
          unsigned int v7 = *(unsigned __int8 *)(a2 + 16);
          goto LABEL_26;
        }
      }
LABEL_104:
      BOOL v3 = 1;
      goto LABEL_25;
    }
    if (v7 != 84)
    {
      if (v7 != 80 && v7 != 88)
      {
LABEL_26:
        int v16 = 0;
        uint64_t v17 = v7 - 33;
        if (v17 > 0x37) {
          goto LABEL_109;
        }
        if (((1 << v17) & 0x8000000000041) != 0)
        {
          uint64_t v50 = *(void *)(a2 + 64);
          if (!v50 || (*(unsigned char *)(v50 + 17) & 0x30) == 0)
          {
            int v51 = *(_DWORD *)(a2 + 20);
            if (v51 < 0)
            {
              uint64_t v56 = a2 - 32 * (v51 & 0x7FFFFFF);
              uint64_t v59 = *(void *)(v56 - 8);
              uint64_t v57 = v56 - 8;
              uint64_t v58 = v59;
              if (v59)
              {
                uint64_t v60 = -v58;
                do
                {
                  unsigned int v61 = *(_DWORD *)(*(void *)(v57 + v60) + 8);
                  BOOL v33 = v61 > 7;
                  int v62 = (1 << v61) & 0x83;
                  if (v33 || v62 == 0) {
                    goto LABEL_107;
                  }
                  v60 += 16;
                }
                while (v60);
              }
            }
            if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 45) & 1) == 0
              && (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) & 1) == 0)
            {
              goto LABEL_107;
            }
          }
        }
        else
        {
          if (v17 != 27)
          {
            if (((1 << v17) & 0x808001D0000010) != 0) {
              goto LABEL_107;
            }
LABEL_109:
            int v52 = v16 | v3;
            uint64_t v53 = v4;
            unsigned int v54 = 128;
LABEL_154:
            sub_1CC8C4528(v53, (uint64_t)&v82, v54, a2, 0, v6, v52);
            goto LABEL_155;
          }
          if ((*(_WORD *)(a2 + 18) & 0x301) != 0)
          {
LABEL_107:
            int v16 = 2;
            goto LABEL_109;
          }
        }
        int v16 = 0;
        goto LABEL_109;
      }
      goto LABEL_104;
    }
  }
  int v9 = sub_1CC8B27E4((uint64_t)v5, a2, 0, v4, 1, 0, 1);
  int v10 = *((_DWORD *)v9 + 11);
  if ((~v10 & 0xFC) == 0)
  {
    char v11 = -1;
    goto LABEL_156;
  }
  if ((~v10 & 0xDC) == 0)
  {
    int v12 = 0;
    int v13 = *(unsigned __int8 *)(a2 + 16);
    uint64_t v14 = (v13 - 33);
    if (v14 > 0x37) {
      goto LABEL_139;
    }
    if (((1 << (v13 - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (v13 - 33)) & 0x808001C8000010) == 0)
      {
        if (v14 != 28) {
          goto LABEL_139;
        }
        int v12 = (*(_WORD *)(a2 + 18) & 0x301) != 0;
LABEL_138:
        int v13 = *(unsigned __int8 *)(a2 + 16);
LABEL_139:
        int v67 = 0;
        uint64_t v68 = (v13 - 33);
        if (v68 > 0x37) {
          goto LABEL_153;
        }
        if (((1 << v68) & 0x8000000000041) != 0)
        {
          uint64_t v69 = *(void *)(a2 + 64);
          if (!v69 || (*(unsigned char *)(v69 + 17) & 0x30) == 0)
          {
            int v70 = *(_DWORD *)(a2 + 20);
            if (v70 < 0)
            {
              uint64_t v73 = a2 - 32 * (v70 & 0x7FFFFFF);
              uint64_t v76 = *(void *)(v73 - 8);
              uint64_t v74 = v73 - 8;
              uint64_t v75 = v76;
              if (v76)
              {
                uint64_t v77 = -v75;
                do
                {
                  unsigned int v78 = *(_DWORD *)(*(void *)(v74 + v77) + 8);
                  BOOL v33 = v78 > 7;
                  int v79 = (1 << v78) & 0x83;
                  if (v33 || v79 == 0) {
                    goto LABEL_151;
                  }
                  v77 += 16;
                }
                while (v77);
              }
            }
            if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 45) & 1) == 0
              && (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) & 1) == 0)
            {
              goto LABEL_151;
            }
          }
        }
        else
        {
          if (v68 != 27)
          {
            if (((1 << v68) & 0x808001D0000010) != 0) {
              goto LABEL_151;
            }
LABEL_153:
            int v52 = v67 | v12;
            uint64_t v53 = v4;
            unsigned int v54 = 32;
            goto LABEL_154;
          }
          if ((*(_WORD *)(a2 + 18) & 0x301) != 0)
          {
LABEL_151:
            int v67 = 2;
            goto LABEL_153;
          }
        }
        int v67 = 0;
        goto LABEL_153;
      }
LABEL_137:
      int v12 = 1;
      goto LABEL_138;
    }
    uint64_t v55 = *(void *)(a2 + 64);
    if (!v55 || (*(unsigned char *)(v55 + 20) & 4) == 0 && (*(unsigned char *)(v55 + 17) & 0x10) == 0)
    {
      LODWORD(v81[0]) = 7;
      if (sub_1CC5CB59C(a2, (__int32 *)v81, 1uLL))
      {
        uint64_t v66 = *(void *)(a2 - 32);
        if (!v66 || *(unsigned char *)(v66 + 16) || *(void *)(v66 + 24) != *(void *)(a2 + 72) || *(_DWORD *)(v66 + 36) != 7) {
          goto LABEL_137;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 66) & 1) == 0)
      {
        int v12 = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) ^ 1;
        goto LABEL_138;
      }
    }
    int v12 = 0;
    goto LABEL_138;
  }
  int v18 = v9;
  unsigned int v19 = 1;
  do
  {
    if ((v19 & (v10 | 0x1C)) != 0) {
      goto LABEL_66;
    }
    int v20 = 0;
    int v21 = *(unsigned __int8 *)(a2 + 16);
    uint64_t v22 = (v21 - 33);
    if (v22 <= 0x37)
    {
      if (((1 << (v21 - 33)) & 0x8000000000041) == 0)
      {
        if (((1 << (v21 - 33)) & 0x808001C8000010) == 0)
        {
          if (v22 != 28) {
            goto LABEL_51;
          }
          int v20 = (*(_WORD *)(a2 + 18) & 0x301) != 0;
          goto LABEL_50;
        }
        goto LABEL_49;
      }
      uint64_t v23 = *(void *)(a2 + 64);
      if (v23 && ((*(unsigned char *)(v23 + 20) & 4) != 0 || (*(unsigned char *)(v23 + 17) & 0x10) != 0)) {
        goto LABEL_44;
      }
      LODWORD(v81[0]) = 7;
      if (sub_1CC5CB59C(a2, (__int32 *)v81, 1uLL))
      {
        uint64_t v24 = *(void *)(a2 - 32);
        if (!v24 || *(unsigned char *)(v24 + 16) || *(void *)(v24 + 24) != *(void *)(a2 + 72) || *(_DWORD *)(v24 + 36) != 7)
        {
LABEL_49:
          int v20 = 1;
          goto LABEL_50;
        }
      }
      if (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 66)) {
LABEL_44:
      }
        int v20 = 0;
      else {
        int v20 = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) ^ 1;
      }
LABEL_50:
      int v21 = *(unsigned __int8 *)(a2 + 16);
    }
LABEL_51:
    int v25 = 0;
    uint64_t v26 = (v21 - 33);
    if (v26 > 0x37) {
      goto LABEL_65;
    }
    if (((1 << v26) & 0x8000000000041) != 0)
    {
      uint64_t v27 = *(void *)(a2 + 64);
      if (v27 && (*(unsigned char *)(v27 + 17) & 0x30) != 0)
      {
LABEL_64:
        int v25 = 0;
        goto LABEL_65;
      }
      int v28 = *(_DWORD *)(a2 + 20);
      if (v28 < 0 && (uint64_t v30 = (void *)(a2 - 8 - 32 * (v28 & 0x7FFFFFF)), *v30))
      {
        uint64_t v31 = -*v30;
        while (1)
        {
          unsigned int v32 = *(_DWORD *)(*(void *)((char *)v30 + v31) + 8);
          BOOL v33 = v32 > 7;
          int v34 = (1 << v32) & 0x83;
          if (v33 || v34 == 0) {
            break;
          }
          v31 += 16;
          if (!v31) {
            goto LABEL_59;
          }
        }
      }
      else
      {
LABEL_59:
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 45) & 1) != 0
          || (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) & 1) != 0)
        {
          goto LABEL_64;
        }
      }
      goto LABEL_63;
    }
    if (v26 == 27)
    {
      if ((*(_WORD *)(a2 + 18) & 0x301) == 0) {
        goto LABEL_64;
      }
LABEL_63:
      int v25 = 2;
      goto LABEL_65;
    }
    if (((1 << v26) & 0x808001D0000010) != 0) {
      goto LABEL_63;
    }
LABEL_65:
    sub_1CC8C4528(v4, (uint64_t)&v82, v19, a2, 0, v6, v25 | v20);
LABEL_66:
    BOOL v29 = v19 >= 0x80;
    v19 *= 2;
  }
  while (!v29);
  if ((~v10 & 0xC) != 0
    && (v81[0] = v4,
        v81[1] = &v82,
        v81[2] = a2,
        v81[3] = v6,
        !(*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t, unsigned int), void *, uint64_t))(*(void *)v18 + 120))(v18, sub_1CC8C4FD0, v81, 243)))
  {
    char v11 = 0;
  }
  else
  {
    unsigned int v36 = (void *)(a2 - 8);
    if ((~v10 & 0x10) != 0)
    {
      int v37 = *(unsigned __int8 *)(a2 + 16);
      if (v37 == 84)
      {
        uint64_t v38 = 0;
      }
      else
      {
        if (v37 == 39) {
          uint64_t v38 = (*(_DWORD *)(a2 + 80) + 1);
        }
        else {
          uint64_t v38 = 2;
        }
        unsigned int v36 = (void *)(a2 - 8);
      }
      uint64_t v39 = 0;
      int v40 = *(_DWORD *)(a2 + 20);
      uint64_t v41 = -(uint64_t)(v40 & 0x7FFFFFF);
      if (v40 < 0)
      {
        uint64_t v64 = a2 - 32 * (v40 & 0x7FFFFFF);
        uint64_t v65 = *(void *)(v64 - 8);
        if ((v65 & 0xFFFFFFFF0) != 0) {
          uint64_t v39 = (*(_DWORD *)(v64 - 12) - *(_DWORD *)(v64 - v65));
        }
        else {
          uint64_t v39 = 0;
        }
        unsigned int v36 = (void *)(a2 - 8);
      }
      unint64_t v42 = -32 * v38 - 32 * v39 - 32 * v41 - 32;
      if ((v42 & 0x1FFFFFFFE0) != 0)
      {
        uint64_t v43 = 0;
        uint64_t v44 = (v42 >> 5);
        uint64_t v45 = a2;
        do
        {
          int v46 = *(_DWORD *)(a2 + 20);
          uint64_t v47 = *(void *)(v45 - 32 * (v46 & 0x7FFFFFF));
          if ((*(_DWORD *)(*(void *)v47 + 8) & 0xFE) == 0x12) {
            int v48 = *(unsigned __int8 *)(**(void **)(*(void *)v47 + 16) + 8);
          }
          else {
            int v48 = *(_DWORD *)(*(void *)v47 + 8);
          }
          if (v48 == 15)
          {
            uint64_t v49 = (v46 & 0x40000000) != 0 ? *v36 : a2 - 32 * (v46 & 0x7FFFFFF);
            if ((~*((unsigned __int8 *)sub_1CC8B2D1C((uint64_t)v5, (v49 + 32 * v43) | 3, 0, v4, 1, 0, 1)+ 41) & 3) != 0)sub_1CC8C483C(v4, v5, a2, v47, (uint64_t)&v82, v6); {
          }
            }
          ++v43;
          v45 += 32;
        }
        while (v44 != v43);
      }
    }
LABEL_155:
    char v11 = BYTE4(v83);
  }
LABEL_156:
  unsigned int v71 = *(_DWORD *)(v4 + 44) & (*(_DWORD *)&v11 | 0xFFFFFF00) | *(_DWORD *)(v4 + 40);
  *(_DWORD *)(v4 + 44) = v71;
  return v71 != 256;
}

uint64_t sub_1CC8C4528(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, unsigned char *a6, int a7)
{
  uint64_t v13 = result + 8 * (31 - __clz(a3));
  unint64_t v16 = *(void *)(v13 + 48);
  uint64_t v15 = (unint64_t *)(v13 + 48);
  unint64_t v14 = v16;
  if (!v16)
  {
    uint64_t v19 = *(void *)(result + 112);
    *(void *)(v19 + 80) += 112;
    if (((*(void *)v19 + 7) & 0xFFFFFFFFFFFFFFF8) - *(void *)v19 + 112 > *(void *)(v19 + 8) - *(void *)v19)
    {
      unsigned int v28 = *(_DWORD *)(v19 + 24) >> 7;
      if (v28 >= 0x1E) {
        LOBYTE(v28) = 30;
      }
      uint64_t v29 = 4096 << v28;
      uint64_t result = (uint64_t)operator new(4096 << v28, (std::align_val_t)8uLL);
      unint64_t v14 = result;
      unsigned int v30 = *(_DWORD *)(v19 + 24);
      if (v30 >= *(_DWORD *)(v19 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v19 + 16) + 8 * v30) = result;
      ++*(_DWORD *)(v19 + 24);
      *(void *)(v19 + 8) = result + v29;
    }
    else
    {
      unint64_t v14 = (*(void *)v19 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    unsigned int v20 = 0;
    *(void *)uint64_t v19 = v14 + 112;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_OWORD *)(v14 + 48) = 0u;
    *(_OWORD *)(v14 + 16) = 0u;
    *(void *)unint64_t v14 = v14 + 16;
    *(_OWORD *)(v14 + 72) = 0u;
    *(void *)(v14 + 64) = v14 + 72;
    *(void *)(v14 + 8) = 0x200000000;
    int v21 = (_DWORD *)(v14 + 8);
    *(_OWORD *)(v14 + 88) = 0u;
    *(void *)(v14 + 104) = 0;
    unint64_t *v15 = v14;
    *(void *)&long long v31 = a4;
    *((void *)&v31 + 1) = a5;
    LODWORD(v32) = a7;
    unint64_t v22 = *(void *)v14;
    unint64_t v23 = *(void *)v14;
    goto LABEL_7;
  }
  uint64_t v17 = *(void *)(v14 + 80);
  *(void *)&long long v31 = a4;
  *((void *)&v31 + 1) = a5;
  LODWORD(v32) = a7;
  if (!v17)
  {
    int v21 = (_DWORD *)(v14 + 8);
    uint64_t v26 = *(unsigned int *)(v14 + 8);
    unint64_t v23 = *(void *)v14;
    unint64_t v22 = *(void *)v14 + 24 * v26;
    if (v26)
    {
      uint64_t v27 = 0;
      while (*(void *)(v23 + v27) != a4 || *(void *)(v23 + v27 + 8) != a5 || *(_DWORD *)(v23 + v27 + 16) != a7)
      {
        v27 += 24;
        if (24 * v26 == v27) {
          goto LABEL_17;
        }
      }
      if (24 * v26 != v27)
      {
        char v18 = 0;
        goto LABEL_10;
      }
LABEL_17:
      if (v26 <= 1)
      {
        unsigned int v20 = *(_DWORD *)(v14 + 8);
        goto LABEL_7;
      }
      do
      {
        sub_1CC8C4EBC((uint64_t **)(v14 + 64), (unint64_t *)(*(void *)v14 + 24 * v26 - 24));
        LODWORD(v26) = *(_DWORD *)(v14 + 8) - 1;
        *(_DWORD *)(v14 + 8) = v26;
      }
      while (v26);
      uint64_t result = sub_1CC8C4EBC((uint64_t **)(v14 + 64), (unint64_t *)&v31);
      goto LABEL_9;
    }
    unsigned int v20 = 0;
LABEL_7:
    if (v20 >= *(_DWORD *)(v14 + 12))
    {
      if (v23 > (unint64_t)&v31 || v22 <= (unint64_t)&v31) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v24 = v23 + 24 * *v21;
    long long v25 = v31;
    *(void *)(v24 + 16) = v32;
    *(_OWORD *)uint64_t v24 = v25;
    ++*v21;
LABEL_9:
    char v18 = 1;
    goto LABEL_10;
  }
  uint64_t result = sub_1CC8C4EBC((uint64_t **)(v14 + 64), (unint64_t *)&v31);
  char v18 = result & 1;
LABEL_10:
  *a6 |= v18;
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 12) & ~a3 | *(_DWORD *)(a2 + 8);
  return result;
}

void sub_1CC8C483C(uint64_t a1, llvm::Attributor *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  v61[8] = *MEMORY[0x1E4F143B8];
  uint64_t v59 = v61;
  uint64_t v60 = 0x800000000;
  BOOL v57 = 0;
  if ((llvm::AA::getAssumedUnderlyingObjects(a2, a4, (uint64_t)&v59, (const llvm::AbstractAttribute *)a1, a3, &v57, 1) & 1) == 0)
  {
    int v39 = 0;
    int v40 = *(unsigned __int8 *)(a3 + 16);
    uint64_t v41 = (v40 - 33);
    if (v41 > 0x37) {
      goto LABEL_95;
    }
    if (((1 << (v40 - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (v40 - 33)) & 0x808001C8000010) == 0)
      {
        if (v41 != 28) {
          goto LABEL_95;
        }
        int v39 = (*(_WORD *)(a3 + 18) & 0x301) != 0;
LABEL_94:
        int v40 = *(unsigned __int8 *)(a3 + 16);
LABEL_95:
        int v44 = 0;
        uint64_t v45 = (v40 - 33);
        if (v45 > 0x37) {
          goto LABEL_109;
        }
        if (((1 << v45) & 0x8000000000041) != 0)
        {
          uint64_t v46 = *(void *)(a3 + 64);
          if (!v46 || (*(unsigned char *)(v46 + 17) & 0x30) == 0)
          {
            int v47 = *(_DWORD *)(a3 + 20);
            if (v47 < 0)
            {
              uint64_t v48 = a3 - 32 * (v47 & 0x7FFFFFF);
              uint64_t v51 = *(void *)(v48 - 8);
              uint64_t v49 = v48 - 8;
              uint64_t v50 = v51;
              if (v51)
              {
                uint64_t v52 = -v50;
                do
                {
                  unsigned int v53 = *(_DWORD *)(*(void *)(v49 + v52) + 8);
                  BOOL v18 = v53 > 7;
                  int v54 = (1 << v53) & 0x83;
                  if (v18 || v54 == 0) {
                    goto LABEL_107;
                  }
                  v52 += 16;
                }
                while (v52);
              }
            }
            if ((llvm::CallBase::hasFnAttrOnCalledFunction(a3, 45) & 1) == 0
              && (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) & 1) == 0)
            {
              goto LABEL_107;
            }
          }
        }
        else
        {
          if (v45 != 27)
          {
            if (((1 << v45) & 0x808001D0000010) != 0) {
              goto LABEL_107;
            }
LABEL_109:
            sub_1CC8C4528(a1, a5, 0x80u, a3, 0, a6, v44 | v39);
            goto LABEL_110;
          }
          if ((*(_WORD *)(a3 + 18) & 0x301) != 0)
          {
LABEL_107:
            int v44 = 2;
            goto LABEL_109;
          }
        }
        int v44 = 0;
        goto LABEL_109;
      }
LABEL_93:
      int v39 = 1;
      goto LABEL_94;
    }
    uint64_t v42 = *(void *)(a3 + 64);
    if (!v42 || (*(unsigned char *)(v42 + 20) & 4) == 0 && (*(unsigned char *)(v42 + 17) & 0x10) == 0)
    {
      __int32 v58 = 7;
      if (sub_1CC5CB59C(a3, &v58, 1uLL))
      {
        uint64_t v43 = *(void *)(a3 - 32);
        if (!v43 || *(unsigned char *)(v43 + 16) || *(void *)(v43 + 24) != *(void *)(a3 + 72) || *(_DWORD *)(v43 + 36) != 7) {
          goto LABEL_93;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a3, 66) & 1) == 0)
      {
        int v39 = llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) ^ 1;
        goto LABEL_94;
      }
    }
    int v39 = 0;
    goto LABEL_94;
  }
  uint64_t v56 = (uint64_t)a2;
  if (v60)
  {
    int v12 = (uint64_t *)v59;
    uint64_t v13 = (uint64_t *)((char *)v59 + 8 * v60);
    do
    {
      uint64_t v14 = *v12;
      unsigned int v15 = *(unsigned __int8 *)(*v12 + 16);
      if (v15 - 11 >= 2)
      {
        if (v15 == 21)
        {
          unsigned int v16 = 16;
          goto LABEL_25;
        }
        if (v15 <= 3)
        {
          if (v15 == 3 && (*(unsigned char *)(v14 + 80) & 1) != 0) {
            goto LABEL_67;
          }
          if ((*(_DWORD *)(v14 + 32) & 0xFu) - 7 >= 2) {
            unsigned int v16 = 8;
          }
          else {
            unsigned int v16 = 4;
          }
          goto LABEL_25;
        }
        if (v15 != 19) {
          goto LABEL_9;
        }
        unint64_t v26 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
        unsigned int v27 = *(_DWORD *)(*(void *)a4 + 8);
        if ((v27 & 0xFE) == 0x12) {
          unsigned int v27 = *(_DWORD *)(**(void **)(*(void *)a4 + 16) + 8);
        }
        if (v26)
        {
          uint64_t v28 = *(void *)(v26 + 112);
          if (v28)
          {
            if ((*(unsigned char *)(v28 + 17) & 1) == 0 && v27 <= 0xFF) {
              goto LABEL_67;
            }
LABEL_45:
            unsigned int v15 = *(unsigned __int8 *)(v14 + 16);
LABEL_9:
            if (v15 == 59)
            {
              unsigned int v16 = 1;
            }
            else if (v15 < 0x1C {
                   || ((unsigned int v17 = v15 - 33, v18 = v17 > 0x33, v19 = (1 << v17) & 0x8000000000041, !v18)
            }
                     ? (BOOL v20 = v19 == 0)
                     : (BOOL v20 = 1),
                       v20))
            {
              unsigned int v16 = 128;
            }
            else if (*((unsigned char *)sub_1CC8BAC64(v56, v14 | 1, 0, a1, 1, 0, 1) + 41))
            {
              unsigned int v16 = 64;
            }
            else
            {
              unsigned int v16 = 128;
            }
LABEL_25:
            uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
            int v22 = 0;
            int v23 = *(unsigned __int8 *)(a3 + 16);
            uint64_t v24 = (v23 - 33);
            if (v24 > 0x37) {
              goto LABEL_52;
            }
            if (((1 << (v23 - 33)) & 0x8000000000041) != 0)
            {
              uint64_t v25 = *(void *)(a3 + 64);
              if (v25 && ((*(unsigned char *)(v25 + 20) & 4) != 0 || (*(unsigned char *)(v25 + 17) & 0x10) != 0)) {
                goto LABEL_43;
              }
              __int32 v58 = 7;
              if (sub_1CC5CB59C(a3, &v58, 1uLL))
              {
                uint64_t v29 = *(void *)(a3 - 32);
                if (!v29
                  || *(unsigned char *)(v29 + 16)
                  || *(void *)(v29 + 24) != *(void *)(a3 + 72)
                  || *(_DWORD *)(v29 + 36) != 7)
                {
                  goto LABEL_50;
                }
              }
              if (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 66)) {
LABEL_43:
              }
                int v22 = 0;
              else {
                int v22 = llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) ^ 1;
              }
            }
            else
            {
              if (((1 << (v23 - 33)) & 0x808001C8000010) == 0)
              {
                if (v24 == 28)
                {
                  int v22 = (*(_WORD *)(a3 + 18) & 0x301) != 0;
                  goto LABEL_51;
                }
LABEL_52:
                int v30 = 0;
                uint64_t v31 = (v23 - 33);
                if (v31 > 0x37) {
                  goto LABEL_66;
                }
                if (((1 << v31) & 0x8000000000041) == 0)
                {
                  if (v31 != 27)
                  {
                    if (((1 << v31) & 0x808001D0000010) != 0) {
                      goto LABEL_64;
                    }
LABEL_66:
                    sub_1CC8C4528(a1, v21, v16, a3, v14, a6, v30 | v22);
                    goto LABEL_67;
                  }
                  if ((*(_WORD *)(a3 + 18) & 0x301) != 0) {
                    goto LABEL_64;
                  }
LABEL_65:
                  int v30 = 0;
                  goto LABEL_66;
                }
                uint64_t v32 = *(void *)(a3 + 64);
                if (v32 && (*(unsigned char *)(v32 + 17) & 0x30) != 0) {
                  goto LABEL_65;
                }
                int v33 = *(_DWORD *)(a3 + 20);
                if (v33 < 0 && (int v34 = (void *)(a3 - 8 - 32 * (v33 & 0x7FFFFFF)), *v34))
                {
                  uint64_t v35 = -*v34;
                  while (1)
                  {
                    unsigned int v36 = *(_DWORD *)(*(void *)((char *)v34 + v35) + 8);
                    BOOL v18 = v36 > 7;
                    int v37 = (1 << v36) & 0x83;
                    if (v18 || v37 == 0) {
                      break;
                    }
                    v35 += 16;
                    if (!v35) {
                      goto LABEL_60;
                    }
                  }
                }
                else
                {
LABEL_60:
                  if ((llvm::CallBase::hasFnAttrOnCalledFunction(a3, 45) & 1) != 0
                    || (llvm::CallBase::hasFnAttrOnCalledFunction(a3, 44) & 1) != 0)
                  {
                    goto LABEL_65;
                  }
                }
LABEL_64:
                int v30 = 2;
                goto LABEL_66;
              }
LABEL_50:
              int v22 = 1;
            }
LABEL_51:
            int v23 = *(unsigned __int8 *)(a3 + 16);
            goto LABEL_52;
          }
        }
        if (v27 >= 0x100) {
          goto LABEL_45;
        }
      }
LABEL_67:
      ++v12;
    }
    while (v12 != v13);
  }
LABEL_110:
  if (v59 != v61) {
    free(v59);
  }
}

uint64_t sub_1CC8C4EBC(uint64_t **a1, unint64_t *a2)
{
  unsigned int v5 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    unint64_t v6 = *a2;
    unint64_t v7 = a2[1];
    int v8 = *((_DWORD *)a2 + 4);
    while (1)
    {
      while (1)
      {
        int v9 = v4;
        unint64_t v10 = v4[4];
        if (v6 == v10) {
          break;
        }
        if (v6 >= v10)
        {
          if (v10 >= v6) {
            return 0;
          }
          goto LABEL_15;
        }
LABEL_12:
        uint64_t v4 = (uint64_t *)*v9;
        unsigned int v5 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_18;
        }
      }
      unint64_t v11 = v9[5];
      if (v7 == v11)
      {
        int v12 = *((_DWORD *)v9 + 12);
        if (v8 < v12) {
          goto LABEL_12;
        }
        if (v12 >= v8) {
          return 0;
        }
      }
      else
      {
        if (v7 < v11) {
          goto LABEL_12;
        }
        if (v11 >= v7) {
          return 0;
        }
      }
LABEL_15:
      uint64_t v4 = (uint64_t *)v9[1];
      if (!v4)
      {
        unsigned int v5 = (uint64_t **)(v9 + 1);
        goto LABEL_18;
      }
    }
  }
  int v9 = (uint64_t *)(a1 + 1);
LABEL_18:
  uint64_t v13 = operator new(0x38uLL);
  v13[2] = *(_OWORD *)a2;
  *((void *)v13 + 6) = a2[2];
  *(void *)uint64_t v13 = 0;
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = v9;
  llvm::Attributor *v5 = (uint64_t *)v13;
  uint64_t v14 = (uint64_t *)**a1;
  if (v14)
  {
    *a1 = v14;
    unsigned int v15 = *v5;
  }
  else
  {
    unsigned int v15 = (uint64_t *)v13;
  }
  sub_1CB8358B8(a1[1], v15);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return 1;
}

uint64_t sub_1CC8C4FD0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  uint64_t v10 = a1[2];
  int v9 = (unsigned char *)a1[3];
  if (v10)
  {
    int v11 = 0;
    int v12 = *(unsigned __int8 *)(v10 + 16);
    uint64_t v13 = (v12 - 33);
    if (v13 > 0x37) {
      goto LABEL_21;
    }
    if (((1 << (v12 - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (v12 - 33)) & 0x808001C8000010) == 0)
      {
        if (v13 != 28) {
          goto LABEL_21;
        }
        int v11 = (*(_WORD *)(v10 + 18) & 0x301) != 0;
LABEL_20:
        int v12 = *(unsigned __int8 *)(v10 + 16);
LABEL_21:
        int v17 = 0;
        uint64_t v18 = (v12 - 33);
        if (v18 > 0x37) {
          goto LABEL_35;
        }
        if (((1 << v18) & 0x8000000000041) != 0)
        {
          uint64_t v19 = *(void *)(v10 + 64);
          if (!v19 || (*(unsigned char *)(v19 + 17) & 0x30) == 0)
          {
            int v20 = *(_DWORD *)(v10 + 20);
            if (v20 < 0)
            {
              uint64_t v22 = v10 - 32 * (v20 & 0x7FFFFFF);
              uint64_t v25 = *(void *)(v22 - 8);
              uint64_t v23 = v22 - 8;
              uint64_t v24 = v25;
              if (v25)
              {
                uint64_t v26 = -v24;
                do
                {
                  unsigned int v27 = *(_DWORD *)(*(void *)(v23 + v26) + 8);
                  BOOL v28 = v27 > 7;
                  int v29 = (1 << v27) & 0x83;
                  if (v28 || v29 == 0) {
                    goto LABEL_33;
                  }
                  v26 += 16;
                }
                while (v26);
              }
            }
            if ((llvm::CallBase::hasFnAttrOnCalledFunction(v10, 45) & 1) == 0
              && (llvm::CallBase::hasFnAttrOnCalledFunction(v10, 44) & 1) == 0)
            {
              goto LABEL_33;
            }
          }
        }
        else
        {
          if (v18 != 27)
          {
            if (((1 << v18) & 0x808001D0000010) != 0) {
              goto LABEL_33;
            }
LABEL_35:
            int v14 = v17 | v11;
            goto LABEL_36;
          }
          if ((*(_WORD *)(v10 + 18) & 0x301) != 0)
          {
LABEL_33:
            int v17 = 2;
            goto LABEL_35;
          }
        }
        int v17 = 0;
        goto LABEL_35;
      }
LABEL_19:
      int v11 = 1;
      goto LABEL_20;
    }
    uint64_t v15 = *(void *)(v10 + 64);
    if (!v15 || (*(unsigned char *)(v15 + 20) & 4) == 0 && (*(unsigned char *)(v15 + 17) & 0x10) == 0)
    {
      __int32 v31 = 7;
      if (sub_1CC5CB59C(v10, &v31, 1uLL))
      {
        uint64_t v16 = *(void *)(v10 - 32);
        if (!v16
          || *(unsigned char *)(v16 + 16)
          || *(void *)(v16 + 24) != *(void *)(v10 + 72)
          || *(_DWORD *)(v16 + 36) != 7)
        {
          goto LABEL_19;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v10, 66) & 1) == 0)
      {
        int v11 = llvm::CallBase::hasFnAttrOnCalledFunction(v10, 44) ^ 1;
        goto LABEL_20;
      }
    }
    int v11 = 0;
    goto LABEL_20;
  }
  int v14 = 3;
LABEL_36:
  sub_1CC8C4528(v7, v8, a5, v10, a3, v9, v14);
  return 1;
}

void sub_1CC8C5240(void *a1)
{
  sub_1CC8C3B74(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8C5278(_DWORD *a1, uint64_t a2)
{
  sub_1CC8C308C(a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 4));
  if (result)
  {
    if (*(unsigned char *)(result + 16))
    {
      if (*(unsigned char *)(result + 16) != 3 || (*(_DWORD *)(result + 20) & 0x7FFFFFF) != 0) {
        return result;
      }
    }
    else if (*(void *)(result + 72) != result + 72 || (*(unsigned char *)(result + 34) & 0x80) != 0)
    {
      return result;
    }
  }

  return sub_1CC8C382C(a1);
}

void sub_1CC8C5300(uint64_t a1)
{
  if ((~*(_DWORD *)(a1 + 44) & 0xFC) == 0
    && (atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61BFF8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61BFF8))
  {
    __cxa_guard_release(&qword_1EA61BFF8);
  }
}

BOOL sub_1CC8C5364(_DWORD *a1, uint64_t a2)
{
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 4));
  unsigned int v5 = sub_1CC8B27E4(a2, v4, 0, (uint64_t)a1, 0, 0, 1);
  char v8 = 0;
  v7[0] = a1;
  v7[1] = &v8;
  if ((*(uint64_t (**)(llvm::AbstractAttribute *, uint64_t (*)(uint64_t *, uint64_t, uint64_t, uint64_t, unsigned int), void *, void))(*(void *)v5 + 120))(v5, sub_1CC8C5464, v7, 0))return v8 == 0; {
  sub_1CC8C382C(a1);
  }
  return 0;
}

void *sub_1CC8C5420(uint64_t a1)
{
  return sub_1CC8C3B74((void *)(a1 - 32));
}

void sub_1CC8C5428(uint64_t a1)
{
  sub_1CC8C3B74((void *)(a1 - 32));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C5464(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v9 = *a1;
  char v8 = (unsigned char *)a1[1];
  if (a2)
  {
    int v10 = 0;
    int v11 = *(unsigned __int8 *)(a2 + 16);
    uint64_t v12 = (v11 - 33);
    if (v12 > 0x37) {
      goto LABEL_21;
    }
    if (((1 << (v11 - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (v11 - 33)) & 0x808001C8000010) == 0)
      {
        if (v12 != 28) {
          goto LABEL_21;
        }
        int v10 = (*(_WORD *)(a2 + 18) & 0x301) != 0;
LABEL_20:
        int v11 = *(unsigned __int8 *)(a2 + 16);
LABEL_21:
        int v16 = 0;
        uint64_t v17 = (v11 - 33);
        if (v17 > 0x37) {
          goto LABEL_35;
        }
        if (((1 << v17) & 0x8000000000041) != 0)
        {
          uint64_t v18 = *(void *)(a2 + 64);
          if (!v18 || (*(unsigned char *)(v18 + 17) & 0x30) == 0)
          {
            int v19 = *(_DWORD *)(a2 + 20);
            if (v19 < 0)
            {
              uint64_t v21 = a2 - 32 * (v19 & 0x7FFFFFF);
              uint64_t v24 = *(void *)(v21 - 8);
              uint64_t v22 = v21 - 8;
              uint64_t v23 = v24;
              if (v24)
              {
                uint64_t v25 = -v23;
                do
                {
                  unsigned int v26 = *(_DWORD *)(*(void *)(v22 + v25) + 8);
                  BOOL v27 = v26 > 7;
                  int v28 = (1 << v26) & 0x83;
                  if (v27 || v28 == 0) {
                    goto LABEL_33;
                  }
                  v25 += 16;
                }
                while (v25);
              }
            }
            if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 45) & 1) == 0
              && (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) & 1) == 0)
            {
              goto LABEL_33;
            }
          }
        }
        else
        {
          if (v17 != 27)
          {
            if (((1 << v17) & 0x808001D0000010) != 0) {
              goto LABEL_33;
            }
LABEL_35:
            int v13 = v16 | v10;
            goto LABEL_36;
          }
          if ((*(_WORD *)(a2 + 18) & 0x301) != 0)
          {
LABEL_33:
            int v16 = 2;
            goto LABEL_35;
          }
        }
        int v16 = 0;
        goto LABEL_35;
      }
LABEL_19:
      int v10 = 1;
      goto LABEL_20;
    }
    uint64_t v14 = *(void *)(a2 + 64);
    if (!v14 || (*(unsigned char *)(v14 + 20) & 4) == 0 && (*(unsigned char *)(v14 + 17) & 0x10) == 0)
    {
      __int32 v30 = 7;
      if (sub_1CC5CB59C(a2, &v30, 1uLL))
      {
        uint64_t v15 = *(void *)(a2 - 32);
        if (!v15 || *(unsigned char *)(v15 + 16) || *(void *)(v15 + 24) != *(void *)(a2 + 72) || *(_DWORD *)(v15 + 36) != 7) {
          goto LABEL_19;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a2, 66) & 1) == 0)
      {
        int v10 = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44) ^ 1;
        goto LABEL_20;
      }
    }
    int v10 = 0;
    goto LABEL_20;
  }
  int v13 = 3;
LABEL_36:
  sub_1CC8C4528(v9, v9 + 32, a5, a2, a3, v8, v13);
  return 1;
}

void *sub_1CC8C56C8(void *a1)
{
  *a1 = &unk_1F2621BD0;
  a1[4] = &unk_1F2621C78;
  a1[6] = &unk_1F2621CD8;
  int v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[8], 8);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C578C(void *a1)
{
  *a1 = &unk_1F2621BD0;
  a1[4] = &unk_1F2621C78;
  a1[6] = &unk_1F2621CD8;
  int v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[8], 8);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8C5870(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  std::to_string(&v14, *(unsigned __int8 *)(a1 + 112));
  unint64_t v4 = std::string::insert(&v14, 0, "CallEdges[");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  unint64_t v6 = std::string::append(&v15, ",");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, (uint64_t)(*(void *)(a1 + 96) - *(void *)(a1 + 88)) >> 3);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  int v10 = std::string::append(&v16, (const std::string::value_type *)p_p, size);
  std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = std::string::append(&v17, "]");
  *a2 = *v12;
  v12->__r_.__value_.__r.__words[0] = 0;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8C59CC(unsigned char *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = 1;
  v7[0] = a2;
  v7[1] = a1;
  void v7[2] = &v8;
  uint64_t v10 = 0xB00000005;
  int v11 = 56;
  v9[0] = &v10;
  v9[1] = 3;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if ((llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8C5E58, (uint64_t)v7, v4, (uint64_t)a1, (uint64_t)v9, &v6, 1u, 0) & 1) == 0)
  {
    if (!a1[112]) {
      unsigned int v8 = 0;
    }
    if (!a1[113]) {
      unsigned int v8 = 0;
    }
    *((_WORD *)a1 + 56) = 257;
  }
  return v8;
}

uint64_t sub_1CC8C5AC8(uint64_t a1)
{
  return a1 + 64;
}

uint64_t sub_1CC8C5AD0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 112);
}

uint64_t sub_1CC8C5AD8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 113);
}

uint64_t *sub_1CC8C5AE0(void *a1)
{
  *(a1 - 4) = &unk_1F2621BD0;
  *a1 = &unk_1F2621C78;
  a1[2] = &unk_1F2621CD8;
  int v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[4], 8);
  *(a1 - 4) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 3);
}

void sub_1CC8C5BAC(void *a1)
{
  *(a1 - 4) = &unk_1F2621BD0;
  *a1 = &unk_1F2621C78;
  a1[2] = &unk_1F2621CD8;
  int v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[4], 8);
  *(a1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CC8C5C90(void *a1)
{
  *(a1 - 6) = &unk_1F2621BD0;
  *(a1 - 2) = &unk_1F2621C78;
  *a1 = &unk_1F2621CD8;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[2], 8);
  *(a1 - 6) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 5);
}

void sub_1CC8C5D5C(void *a1)
{
  *(a1 - 6) = &unk_1F2621BD0;
  *(a1 - 2) = &unk_1F2621C78;
  *a1 = &unk_1F2621CD8;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[2], 8);
  *(a1 - 6) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 5);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C5E58(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = sub_1CC8C5FA0(*a1, a2, 0, v3, 0);
  if ((*(unsigned int (**)(llvm::AbstractAttribute *))(*(void *)v4 + 128))(v4))
  {
    std::string::size_type v5 = (_DWORD *)a1[2];
    if (!*(unsigned char *)(v3 + 112)) {
      _DWORD *v5 = 0;
    }
    if (!*(unsigned char *)(v3 + 113)) {
      _DWORD *v5 = 0;
    }
    *(_WORD *)(v3 + 112) = 257;
  }
  if ((*(unsigned int (**)(llvm::AbstractAttribute *))(*(void *)v4 + 120))(v4))
  {
    if (!*(unsigned char *)(v3 + 112)) {
      *(_DWORD *)a1[2] = 0;
    }
    *(unsigned char *)(v3 + 112) = 1;
  }
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v4 + 112))(v4);
  std::string::size_type v7 = *(uint64_t **)(v6 + 24);
  unsigned int v8 = *(uint64_t **)(v6 + 32);
  if (v7 != v8)
  {
    uint64_t v9 = (void *)(v3 + 64);
    do
    {
      uint64_t v10 = (_DWORD *)a1[2];
      uint64_t v12 = *v7;
      if (sub_1CC8B0F60(v9, &v12)) {
        *uint64_t v10 = 0;
      }
      ++v7;
    }
    while (v7 != v8);
  }
  return 1;
}

llvm::AbstractAttribute *sub_1CC8C5FA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (byte_1EBD07860) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)&long long v51 = a2;
  *((void *)&v51 + 1) = v8;
  uint64_t v10 = (llvm::AbstractAttribute *)sub_1CD658B0C(a1, &v51, a4, a5);
  if (v10) {
    return v10;
  }
  uint64_t v10 = (llvm::AbstractAttribute *)llvm::AACallEdges::createForPosition((llvm::AACallEdges *)&v51, (uint64_t **)a1, v9);
  sub_1CD658BF8(a1, (uint64_t)v10);
  uint64_t v12 = *(uint64_t **)(a1 + 5480);
  if (v12)
  {
    __p[0] = &llvm::AACallEdges::ID;
    v47[0] = 0;
    int v13 = sub_1CD420258(v12, __p, v47) ^ 1;
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v14 = v51 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v51 & 3) == 0) {
    uint64_t v14 = *(void *)(v14 + 24);
  }
  unsigned int v15 = *(unsigned __int8 *)(v14 + 16);
  if (!*(unsigned char *)(v14 + 16)) {
    goto LABEL_16;
  }
  if (v15 == 21)
  {
    std::string v16 = (uint64_t *)(v14 + 24);
  }
  else
  {
    if (v15 < 0x1C)
    {
      uint64_t v14 = 0;
      goto LABEL_23;
    }
    std::string v16 = (uint64_t *)(*(void *)(v14 + 40) + 56);
  }
  uint64_t v14 = *v16;
  if (!*v16)
  {
LABEL_23:
    char v19 = 1;
    goto LABEL_48;
  }
LABEL_16:
  uint64_t v17 = *(void *)(v14 + 112);
  if (v17 && ((*(unsigned char *)(v17 + 14) & 2) != 0 || (*(unsigned char *)(v17 + 17) & 8) != 0))
  {
    BOOL v18 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v18 = 0;
  }
  else
  {
    int v20 = *(uint64_t **)(a1 + 88);
    uint64_t v22 = *v20;
    uint64_t v21 = v20[1];
    if (v21 == *v20)
    {
      uint64_t v23 = *((unsigned int *)v20 + 5);
      uint64_t v24 = (void *)(v21 + 8 * v23);
      if (v23)
      {
        uint64_t v25 = 0;
        uint64_t v26 = 8 * v23;
        while (*(void *)(v21 + v25) != v14)
        {
          v25 += 8;
          if (v26 == v25) {
            goto LABEL_43;
          }
        }
        uint64_t v24 = (void *)(v21 + v25);
      }
LABEL_43:
      uint64_t v22 = v20[1];
    }
    else
    {
      uint64_t v27 = *((unsigned int *)v20 + 4);
      int v28 = v27 - 1;
      unsigned int v29 = (v27 - 1) & ((v14 >> 4) ^ (v14 >> 9));
      uint64_t v24 = (void *)(v21 + 8 * v29);
      uint64_t v30 = *v24;
      if (*v24 == -1)
      {
        __int32 v31 = 0;
LABEL_84:
        if (v31) {
          uint64_t v24 = v31;
        }
        if (*v24 != v14) {
          uint64_t v24 = (void *)(v21 + 8 * v27);
        }
      }
      else
      {
        __int32 v31 = 0;
        int v32 = 1;
        while (v30 != v14)
        {
          if (v31) {
            BOOL v33 = 0;
          }
          else {
            BOOL v33 = v30 == -2;
          }
          if (v33) {
            __int32 v31 = v24;
          }
          unsigned int v34 = v29 + v32++;
          unsigned int v29 = v34 & v28;
          uint64_t v24 = (void *)(v21 + 8 * (v34 & v28));
          uint64_t v30 = *v24;
          if (*v24 == -1) {
            goto LABEL_84;
          }
        }
      }
    }
    BOOL v33 = v21 == v22;
    uint64_t v35 = 16;
    if (v33) {
      uint64_t v35 = 20;
    }
    BOOL v18 = v24 == (void *)(v21 + 8 * *(unsigned int *)((char *)v20 + v35));
  }
  char v19 = 0;
  LOBYTE(v13) = (v18 | v13) != 0;
LABEL_48:
  if ((v13 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_75;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v10 + 72))(v47, v10);
  if (v48 >= 0) {
    size_t v36 = v48 & 0x7F;
  }
  else {
    size_t v36 = (size_t)v47[1];
  }
  int v37 = __p;
  sub_1CB907098((uint64_t)__p, v36 + 12);
  if (v50 < 0) {
    int v37 = (void **)__p[0];
  }
  if (v36)
  {
    if (v48 >= 0) {
      uint64_t v38 = v47;
    }
    else {
      uint64_t v38 = (void **)v47[0];
    }
    memmove(v37, v38, v36);
  }
  strcpy((char *)v37 + v36, "::initialize");
  int v39 = (uint64_t *)off_1EC7DFC00();
  if (*v39)
  {
    if (v50 >= 0) {
      int v40 = __p;
    }
    else {
      int v40 = (void **)__p[0];
    }
    if (v50 >= 0) {
      uint64_t v41 = v50 & 0x7F;
    }
    else {
      uint64_t v41 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v40, v41, (uint64_t)"", 0);
  }
  if (v50 < 0) {
    operator delete(__p[0]);
  }
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v10 + 24))(v10, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v39)
  {
    sub_1CD84B62C(*v39);
    if (v19) {
      goto LABEL_74;
    }
  }
  else if (v19)
  {
    goto LABEL_74;
  }
  uint64_t v45 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v14;
  v47[0] = 0;
  if ((sub_1CD420258(v45, __p, v47) & 1) == 0)
  {
    uint64_t v46 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v51);
    v47[0] = 0;
    if ((sub_1CD420258(v46, __p, v47) & 1) == 0) {
      goto LABEL_75;
    }
  }
LABEL_74:
  int v42 = *(_DWORD *)(a1 + 4368);
  if (v42 == 2)
  {
LABEL_75:
    uint64_t v43 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 40))(v10);
    (*(void (**)(uint64_t))(*(void *)v43 + 40))(v43);
    return v10;
  }
  *(_DWORD *)(a1 + 4368) = 1;
  llvm::Attributor::updateAA((llvm::Attributor *)a1, v10);
  *(_DWORD *)(a1 + 4368) = v42;
  if (a4)
  {
    uint64_t v44 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 40))(v10);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 16))(v44)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v10, a4, a5);
    }
  }
  return v10;
}

void *sub_1CC8C64A8(void *a1)
{
  *a1 = &unk_1F2621BD0;
  a1[4] = &unk_1F2621C78;
  a1[6] = &unk_1F2621CD8;
  int v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[8], 8);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C656C(void *a1)
{
  *a1 = &unk_1F2621BD0;
  a1[4] = &unk_1F2621C78;
  a1[6] = &unk_1F2621CD8;
  int v2 = (void *)a1[11];
  if (v2)
  {
    a1[12] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[8], 8);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C6650(uint64_t a1, llvm::Attributor *a2)
{
  v52[4] = *MEMORY[0x1E4F143B8];
  unsigned int v48 = 1;
  v47[0] = a1;
  v47[1] = &v48;
  unint64_t v4 = (_DWORD *)(a1 + 16);
  unint64_t v5 = sub_1CC8AB830((_DWORD *)(a1 + 16));
  uint64_t v6 = (uint64_t ****)v5;
  if (*(unsigned char *)(*(void *)(v5 - 32) + 16) == 24)
  {
    uint64_t v43 = *(void *)(*(void *)(v5 + 40) + 56);
    char v50 = "ompx_no_call_asm";
    uint64_t v51 = 16;
    sub_1CC0D7F54((llvm::StringMapImpl *)&llvm::KnownAssumptionStrings, "ompx_no_call_asm", 0x10uLL);
    if (!llvm::hasAssumption(v43, (uint64_t)&v50))
    {
      v46[0] = "ompx_no_call_asm";
      v46[1] = 16;
      sub_1CC0D7F54((llvm::StringMapImpl *)&llvm::KnownAssumptionStrings, "ompx_no_call_asm", 0x10uLL);
      if (!llvm::hasAssumption((uint64_t)v6, (uint64_t)v46))
      {
        if (!*(unsigned char *)(a1 + 112)) {
          unsigned int v48 = 0;
        }
        *(unsigned char *)(a1 + 112) = 1;
      }
    }
    return v48;
  }
  std::string::size_type v7 = (unsigned char *)sub_1CC8AB830(v4);
  if ((v7[23] & 0x20) != 0)
  {
    uint64_t v8 = ***(void ***)v7;
    char v50 = v7;
    int v9 = *(_DWORD *)(v8 + 2496);
    if (v9)
    {
      uint64_t v10 = *(void *)(v8 + 2480);
      int v11 = v9 - 1;
      unsigned int v12 = (v9 - 1) & ((v7 >> 4) ^ (v7 >> 9));
      int v13 = (void *)(v10 + 40 * v12);
      uint64_t v14 = (unsigned char *)*v13;
      if ((unsigned char *)*v13 == v7)
      {
LABEL_13:
        uint64_t v19 = *((unsigned int *)v13 + 4);
        if (v19)
        {
          int v20 = (void *)(v13[1] + 8);
          uint64_t v21 = 16 * v19;
          while (*((_DWORD *)v20 - 2) != 23)
          {
            v20 += 2;
            v21 -= 16;
            if (!v21) {
              goto LABEL_17;
            }
          }
          uint64_t v37 = *v20;
          if (*v20)
          {
            uint64_t v38 = *(unsigned int *)(v37 + 8);
            if (v38)
            {
              int v39 = (void *)(a1 + 64);
              uint64_t v40 = -8 * v38;
              do
              {
                uint64_t v41 = *(void *)(v37 + v40);
                if (v41)
                {
                  if (*(unsigned char *)v41 == 1)
                  {
                    int v42 = *(unsigned char **)(v41 + 128);
                    if (!v42[16])
                    {
                      char v50 = v42;
                      if (sub_1CC8B0F60(v39, &v50)) {
                        unsigned int v48 = 0;
                      }
                    }
                  }
                }
                v40 += 8;
              }
              while (v40);
            }
            return v48;
          }
        }
        goto LABEL_17;
      }
      unsigned int v15 = 0;
      int v16 = 1;
      while (v14 != (unsigned char *)-4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == (unsigned char *)-8192;
        }
        if (v17) {
          unsigned int v15 = v13;
        }
        unsigned int v18 = v12 + v16++;
        unsigned int v12 = v18 & v11;
        int v13 = (void *)(v10 + 40 * (v18 & v11));
        uint64_t v14 = (unsigned char *)*v13;
        if ((unsigned char *)*v13 == v7) {
          goto LABEL_13;
        }
      }
      if (v15) {
        uint64_t v44 = v15;
      }
      else {
        uint64_t v44 = v13;
      }
    }
    else
    {
      uint64_t v44 = 0;
    }
    int v13 = sub_1CC609054(v8 + 2480, (uint64_t)&v50, (uint64_t *)&v50, v44);
    uint64_t v45 = v50;
    v13[3] = 0;
    v13[4] = 0;
    void *v13 = v45;
    v13[1] = v13 + 3;
    v13[2] = 0x100000000;
    goto LABEL_13;
  }
LABEL_17:
  uint64_t v22 = (uint64_t)*(v6 - 4);
  LOBYTE(v50) = 0;
  LOBYTE(v46[0]) = 0;
  unsigned int v23 = *(unsigned __int8 *)(v22 + 16);
  if (v23 != 21)
  {
    if (v23 < 0x1C)
    {
      if (!*(unsigned char *)(v22 + 16)) {
        v22 |= 2uLL;
      }
    }
    else
    {
      unsigned int v24 = v23 - 33;
      BOOL v25 = v24 > 0x33;
      uint64_t v26 = (1 << v24) & 0x8000000000041;
      if (!v25 && v26 != 0) {
        v22 |= 1uLL;
      }
    }
  }
  if ((sub_1CC8C6DEC(a2, v22, 0, (const llvm::AbstractAttribute *)a1, (uint64_t)&v50, (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL))sub_1CC8C79B4, (uint64_t)v47, 0, (BOOL *)v46) & 1) == 0)
  {
    if (!*(unsigned char *)(a1 + 112)) {
      unsigned int v48 = 0;
    }
    if (!*(unsigned char *)(a1 + 113)) {
      unsigned int v48 = 0;
    }
    *(_WORD *)(a1 + 112) = 257;
  }
  char v50 = v52;
  uint64_t v51 = 0x400000000;
  llvm::AbstractCallSite::getCallbackUses(v6, (uint64_t)&v50);
  int v28 = (uint64_t **)v50;
  if (v51)
  {
    uint64_t v29 = 8 * v51;
    do
    {
      uint64_t v30 = **v28;
      LOBYTE(v46[0]) = 0;
      BOOL v49 = 0;
      unsigned int v31 = *(unsigned __int8 *)(v30 + 16);
      if (v31 != 21)
      {
        if (v31 < 0x1C)
        {
          if (!*(unsigned char *)(v30 + 16)) {
            v30 |= 2uLL;
          }
        }
        else
        {
          unsigned int v32 = v31 - 33;
          BOOL v25 = v32 > 0x33;
          uint64_t v33 = (1 << v32) & 0x8000000000041;
          if (!v25 && v33 != 0) {
            v30 |= 1uLL;
          }
        }
      }
      if ((sub_1CC8C6DEC(a2, v30, 0, (const llvm::AbstractAttribute *)a1, (uint64_t)v46, (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL))sub_1CC8C79B4, (uint64_t)v47, 0, &v49) & 1) == 0)
      {
        if (!*(unsigned char *)(a1 + 112)) {
          unsigned int v48 = 0;
        }
        if (!*(unsigned char *)(a1 + 113)) {
          unsigned int v48 = 0;
        }
        *(_WORD *)(a1 + 112) = 257;
      }
      ++v28;
      v29 -= 8;
    }
    while (v29);
    int v28 = (uint64_t **)v50;
  }
  uint64_t v35 = v48;
  if (v28 != v52) {
    free(v28);
  }
  return v35;
}

uint64_t *sub_1CC8C6A8C(void *a1)
{
  *(a1 - 4) = &unk_1F2621BD0;
  *a1 = &unk_1F2621C78;
  a1[2] = &unk_1F2621CD8;
  int v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[4], 8);
  *(a1 - 4) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 3);
}

void sub_1CC8C6B58(void *a1)
{
  *(a1 - 4) = &unk_1F2621BD0;
  *a1 = &unk_1F2621C78;
  a1[2] = &unk_1F2621CD8;
  int v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[4], 8);
  *(a1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CC8C6C3C(void *a1)
{
  *(a1 - 6) = &unk_1F2621BD0;
  *(a1 - 2) = &unk_1F2621C78;
  *a1 = &unk_1F2621CD8;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[2], 8);
  *(a1 - 6) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 5);
}

void sub_1CC8C6D08(void *a1)
{
  *(a1 - 6) = &unk_1F2621BD0;
  *(a1 - 2) = &unk_1F2621C78;
  *a1 = &unk_1F2621CD8;
  int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[2], 8);
  *(a1 - 6) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 5);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C6DEC(llvm::Attributor *a1, uint64_t a2, uint64_t a3, const llvm::AbstractAttribute *a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL), uint64_t a7, uint64_t a8, BOOL *a9)
{
  v122[12] = *MEMORY[0x1E4F143B8];
  v99[0] = a2;
  v99[1] = a3;
  v119[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v119[i] = -4096;
  uint64_t v120 = (char *)v122;
  uint64_t v121 = 0x400000000;
  unint64_t v13 = sub_1CD6482F0((llvm::IRPosition *)v99);
  int v14 = 0;
  v116[0] = v117;
  v116[1] = (void *)0x1000000000;
  v118[1] = 0;
  v118[0] = 0;
  v117[32] = v118;
  unint64_t v90 = v13;
  uint64_t v112 = (char *)v115;
  unsigned int v114 = 16;
  v115[0] = v13;
  v115[1] = a8;
  int64x2_t v89 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v15 = 1;
  uint64_t v94 = (uint64_t)a4;
  uint64_t v95 = a1;
  do
  {
    int v16 = &v112[16 * v15];
    uint64_t v17 = *((void *)v16 - 2);
    unint64_t v18 = *((void *)v16 - 1);
    unsigned int v113 = v15 - 1;
    v98[0] = v17;
    v98[1] = v18;
    if ((sub_1CD65837C((uint64_t)v116, v98) & 0x100000000) == 0) {
      goto LABEL_125;
    }
    if (v14 >= 16) {
      goto LABEL_150;
    }
    int v96 = v14 + 1;
    if (*(unsigned char *)(*(void *)v17 + 8) != 15)
    {
      unsigned int v22 = *(unsigned __int8 *)(v17 + 16);
      if (v22 < 0x1C) {
        goto LABEL_33;
      }
      unsigned int v23 = v22 - 33;
      BOOL v24 = v23 > 0x33;
      uint64_t v25 = (1 << v23) & 0x8000000000041;
      if (v24 || v25 == 0) {
        goto LABEL_33;
      }
      uint64_t v27 = *(void *)(v17 - 32);
      if (!v27 || *(unsigned char *)(v27 + 16) || *(void *)(v27 + 24) != *(void *)(v17 + 72)) {
        goto LABEL_33;
      }
      if (*(_WORD *)(v27 + 18))
      {
        llvm::Function::BuildLazyArguments(*(llvm::Function **)(v17 - 32));
        uint64_t v28 = *(void *)(v27 + 88);
        if (*(_WORD *)(v27 + 18))
        {
          llvm::Function::BuildLazyArguments((llvm::Function *)v27);
          uint64_t v29 = *(void *)(v27 + 88);
LABEL_25:
          uint64_t v30 = v29 + 40 * *(void *)(v27 + 96);
          while (v28 != v30)
          {
            uint64_t v31 = *(void *)(*(void *)(v28 + 24) + 112);
            if (v31)
            {
              uint64_t v32 = *(unsigned int *)(v28 + 32);
              if ((v32 + 2) < *(_DWORD *)(v31 + 8))
              {
                uint64_t v33 = *(void *)(v31 + 8 * (v32 + 2) + 40);
                if (v33)
                {
                  if ((*(unsigned char *)(v33 + 17) & 0x40) != 0)
                  {
                    uint64_t v19 = *(llvm::Value **)(v17 - 32 * (*(_DWORD *)(v17 + 20) & 0x7FFFFFF) + 32 * v32);
                    goto LABEL_8;
                  }
                }
              }
            }
            v28 += 40;
          }
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v28 = *(void *)(v27 + 88);
      }
      uint64_t v29 = v28;
      goto LABEL_25;
    }
    uint64_t v19 = llvm::Value::stripPointerCasts((llvm::Value *)v17);
LABEL_8:
    if (v19) {
      BOOL v20 = v19 == (llvm::Value *)v17;
    }
    else {
      BOOL v20 = 1;
    }
    if (!v20)
    {
      if (v113 >= (unint64_t)v114) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      ++v14;
      uint64_t v21 = &v112[16 * v113];
      *(void *)uint64_t v21 = v19;
      goto LABEL_97;
    }
LABEL_33:
    int v34 = *(unsigned __int8 *)(v17 + 16);
    switch(v34)
    {
      case 83:
        uint64_t v40 = *(void *)(*(void *)(v17 + 40) + 56);
        uint64_t v100 = v40;
        int v101 = 0;
        sub_1CD645794((uint64_t)&v107, (uint64_t)v119, &v100, &v101);
        uint64_t v41 = v107;
        if (BYTE8(v108[0]))
        {
          *(_DWORD *)&v102[20] = 0;
          *(_DWORD *)&v102[17] = 0;
          *(void *)unint64_t v102 = v40;
          *(void *)&v102[8] = 0;
          v102[16] = 0;
          if (v121 >= HIDWORD(v121))
          {
            if (v120 > v102 || &v120[24 * v121] <= v102) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unsigned int v48 = &v120[24 * v121];
          long long v49 = *(_OWORD *)v102;
          *((void *)v48 + 2) = *(void *)&v102[16];
          *(_OWORD *)unsigned int v48 = v49;
          int v42 = v121;
          LODWORD(v121) = v121 + 1;
          *(_DWORD *)(v41 + 8) = v42;
        }
        else
        {
          int v42 = *(_DWORD *)(v107 + 8);
        }
        char v50 = v120;
        uint64_t v51 = &v120[24 * v42];
        uint64_t v53 = *((void *)v51 + 1);
        uint64_t v52 = (llvm::AbstractAttribute **)(v51 + 8);
        if (!v53) {
          *uint64_t v52 = sub_1CC8AC178((uint64_t)v95, v40, 0, v94, 2, 0, 1);
        }
        uint64_t v54 = *(_DWORD *)(v17 + 20) & 0x7FFFFFF;
        if (v54)
        {
          uint64_t v55 = 0;
          uint64_t v56 = 0;
          BOOL v57 = &v50[24 * v42 + 16];
          uint64_t v58 = 8 * v54;
          do
          {
            int v59 = *(_DWORD *)(v17 + 20);
            if ((v59 & 0x40000000) != 0) {
              uint64_t v60 = *(void *)(v17 - 8);
            }
            else {
              uint64_t v60 = v17 - 32 * (v59 & 0x7FFFFFF);
            }
            uint64_t v61 = *(void *)(v60 + 32 * *(unsigned int *)(v17 + 60) + v56);
            if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v52 + 168))(*v52, v61, *(void *)(v17 + 40)))
            {
              *BOOL v57 = 1;
              *a9 |= (*(unsigned __int8 (**)(void))(*((void *)*v52 + 4) + 24))() ^ 1;
            }
            else
            {
              int v62 = *(_DWORD *)(v17 + 20);
              if ((v62 & 0x40000000) != 0) {
                uint64_t v63 = *(void *)(v17 - 8);
              }
              else {
                uint64_t v63 = v17 - 32 * (v62 & 0x7FFFFFF);
              }
              uint64_t v64 = *(void *)(v61 + 40);
              if (v64 == v61 + 40)
              {
                uint64_t v66 = 0;
              }
              else
              {
                if (v64) {
                  uint64_t v65 = v64 - 24;
                }
                else {
                  uint64_t v65 = 0;
                }
                if (*(unsigned __int8 *)(v65 + 16) - 29 >= 0xB) {
                  uint64_t v66 = 0;
                }
                else {
                  uint64_t v66 = v65;
                }
              }
              uint64_t v67 = *(void *)(v63 + v55);
              if (v113 >= (unint64_t)v114) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v68 = &v112[16 * v113];
              *(void *)uint64_t v68 = v67;
              *((void *)v68 + 1) = v66;
              ++v113;
            }
            v56 += 8;
            v55 += 32;
          }
          while (v58 != v56);
        }
        a4 = (const llvm::AbstractAttribute *)v94;
        a1 = v95;
LABEL_91:
        int v14 = v96;
        goto LABEL_125;
      case 85:
        unint64_t v35 = *(void *)(v17 - 96);
        unsigned int v36 = *(unsigned __int8 *)(v35 + 16);
        if (v36 != 21)
        {
          if (v36 < 0x1C)
          {
            if (!*(unsigned char *)(v35 + 16)) {
              v35 |= 2uLL;
            }
          }
          else
          {
            unsigned int v37 = v36 - 33;
            BOOL v24 = v37 > 0x33;
            uint64_t v38 = (1 << v37) & 0x8000000000041;
            if (!v24 && v38 != 0) {
              v35 |= 1uLL;
            }
          }
        }
        uint64_t v107 = v35;
        *(void *)&v108[0] = 0;
        AssumedConstant = llvm::Attributor::getAssumedConstant(a1, (const llvm::IRPosition *)&v107, a4, a9);
        if (!v70) {
          goto LABEL_91;
        }
        if (!AssumedConstant) {
          goto LABEL_93;
        }
        int v74 = *((unsigned __int8 *)AssumedConstant + 16);
        if ((v74 - 11) < 2) {
          goto LABEL_91;
        }
        if (v74 != 16)
        {
LABEL_93:
          if (v113 >= (unint64_t)v114) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unsigned int v71 = &v112[16 * v113];
          *(void *)unsigned int v71 = *(void *)(v17 - 64);
          *((void *)v71 + 1) = v18;
          unsigned int v72 = v113 + 1;
          unsigned int v113 = v72;
          uint64_t v73 = *(void *)(v17 - 32);
          if (v72 >= v114) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v21 = &v112[16 * v72];
LABEL_96:
          *(void *)uint64_t v21 = v73;
          ++v14;
LABEL_97:
          *((void *)v21 + 1) = v18;
          ++v113;
          goto LABEL_125;
        }
        uint64_t v75 = *((unsigned int *)AssumedConstant + 8);
        if (v75 > 0x40)
        {
          int v81 = 0;
          int64_t v82 = (unint64_t)(v75 + 63) >> 6;
          do
          {
            BOOL v24 = v82-- < 1;
            if (v24) {
              break;
            }
            unint64_t v83 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v82);
            v81 += __clz(v83);
          }
          while (!v83);
          int v84 = v75 | 0xFFFFFFC0;
          if ((v75 & 0x3F) == 0) {
            int v84 = 0;
          }
          if (v81 + v84 != v75) {
            goto LABEL_102;
          }
        }
        else if (*((void *)AssumedConstant + 3))
        {
LABEL_102:
          uint64_t v73 = *(void *)(v17 - 64);
LABEL_134:
          if (v113 >= (unint64_t)v114) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v21 = &v112[16 * v113];
          goto LABEL_96;
        }
        uint64_t v73 = *(void *)(v17 - 32);
        goto LABEL_134;
      case 21:
        uint64_t v43 = (llvm::Argument *)v17;
        break;
      default:
        uint64_t v43 = 0;
        break;
    }
    uint64_t v100 = (uint64_t)v43;
    if (!v43 || (llvm::Argument::hasPassPointeeByValueCopyAttr(v43) & 1) != 0) {
      goto LABEL_54;
    }
    uint64_t v107 = (uint64_t)v108 + 8;
    *(void *)&v108[0] = 0x300000000;
    char v97 = 0;
    *(void *)unint64_t v102 = &v100;
    *(void *)&v102[8] = &v107;
    int v44 = llvm::Attributor::checkForAllCallSites((uint64_t)a1, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8C7890, (uint64_t)v102, *(void *)(v100 + 24), 1, (uint64_t)a4, &v97);
    char v45 = v44;
    int v46 = 0;
    if (v44)
    {
      sub_1CD3D61B4((unsigned int *)&v112, (unsigned char *)v107, (unsigned char *)(v107 + 16 * LODWORD(v108[0])));
      int v46 = 3;
    }
    if ((_OWORD *)v107 != (_OWORD *)((char *)v108 + 8)) {
      free((void *)v107);
    }
    if ((v45 & 1) == 0)
    {
LABEL_54:
      if (*(unsigned char *)(v17 + 16) == 60)
      {
        LOBYTE(v100) = 0;
        if (*(void *)(v17 - 32) != v90)
        {
          uint64_t v107 = 1;
          v108[0] = v89;
          v108[1] = v89;
          uint64_t v109 = (int64_t *)v111;
          uint64_t v110 = 0x400000000;
          *(void *)unint64_t v102 = 1;
          *(int64x2_t *)&v102[8] = v89;
          int64x2_t v103 = v89;
          int64_t v104 = v106;
          uint64_t v105 = 0x400000000;
          LODWORD(v47) = 1;
          if (llvm::AA::getPotentiallyLoadedValues(v95, v17, &v107, v102, a4, (BOOL *)&v100, 1))
          {
            if (!v110)
            {
LABEL_58:
              LODWORD(v47) = 0;
LABEL_59:
              int v46 = 3;
              goto LABEL_113;
            }
            uint64_t v76 = v109;
            uint64_t v77 = 8 * v110;
            while (1)
            {
              LODWORD(v47) = 1;
              if (!llvm::AA::isDynamicallyUnique(v95, a4, *v76, (const llvm::Value *)1)) {
                break;
              }
              ++v76;
              v77 -= 8;
              if (!v77)
              {
                if (!v110) {
                  goto LABEL_58;
                }
                unsigned int v78 = v109;
                unsigned int v79 = v113;
                uint64_t v47 = 8 * v110;
                do
                {
                  if (v79 >= v114) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  int64_t v80 = &v112[16 * v79];
                  *(void *)int64_t v80 = *v78;
                  *((void *)v80 + 1) = v18;
                  unsigned int v79 = ++v113;
                  ++v78;
                  v47 -= 8;
                }
                while (v47);
                goto LABEL_59;
              }
            }
          }
          int v46 = 0;
LABEL_113:
          if (v104 != v106) {
            free(v104);
          }
          if ((v102[0] & 1) == 0) {
            MEMORY[0x1D25D9CD0](*(void *)&v102[8], 8);
          }
          if (v109 != (int64_t *)v111) {
            free(v109);
          }
          if (v107)
          {
            if (!v47) {
              goto LABEL_139;
            }
          }
          else
          {
            MEMORY[0x1D25D9CD0](*(void *)&v108[0], 8);
            if (!v47)
            {
LABEL_139:
              a1 = v95;
              goto LABEL_123;
            }
          }
        }
        a1 = v95;
      }
      int v46 = a6(a7, v17, v18, a5, v14 > 0) ^ 1;
    }
LABEL_123:
    ++v14;
    if (v46 != 3 && v46)
    {
LABEL_150:
      uint64_t v85 = 0;
      goto LABEL_156;
    }
LABEL_125:
    unsigned int v15 = v113;
  }
  while (v113);
  if (v121)
  {
    uint64_t v86 = 24 * v121;
    uint64_t v87 = v120 + 16;
    do
    {
      if (*v87) {
        llvm::Attributor::recordDependence((uint64_t)a1, *((void *)v87 - 1), (uint64_t)a4, 1);
      }
      v87 += 24;
      v86 -= 24;
    }
    while (v86);
    uint64_t v85 = 1;
  }
  else
  {
    uint64_t v85 = 1;
  }
LABEL_156:
  if (v112 != (char *)v115) {
    free(v112);
  }
  sub_1CD40B1BC(v118[0]);
  if (v116[0] != v117) {
    free(v116[0]);
  }
  if (v120 != (char *)v122) {
    free(v120);
  }
  if ((v119[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v119[1], 8);
  }
  return v85;
}

uint64_t sub_1CC8C7890(void *a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = &v16;
  uint64_t v15 = 0;
  if (!*((_DWORD *)a2 + 4))
  {
    unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
    goto LABEL_3;
  }
  sub_1CD41B598((uint64_t)&v14, (uint64_t)(a2 + 1));
  unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
  if (!v15)
  {
LABEL_3:
    uint64_t v4 = v13;
    unsigned int v5 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
    if (v5 < 0x15 || v5 == 24) {
      goto LABEL_9;
    }
  }
  unsigned int v3 = *((_DWORD *)v14 + v3 + 1);
  if ((v3 & 0x80000000) != 0)
  {
LABEL_12:
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = v13;
LABEL_9:
  uint64_t v7 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v3);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = a1[1];
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 >= *(_DWORD *)(v8 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v10 = (void *)(*(void *)v8 + 16 * v9);
  *uint64_t v10 = v7;
  v10[1] = v4;
  ++*(_DWORD *)(v8 + 8);
  uint64_t v11 = 1;
LABEL_13:
  if (v14 != &v16) {
    free(v14);
  }
  return v11;
}

uint64_t sub_1CC8C79B4(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  unsigned int v3 = (_DWORD *)a1[1];
  if (*(unsigned char *)(a2 + 16))
  {
    if (!*(unsigned char *)(v2 + 112)) {
      *unsigned int v3 = 0;
    }
    if (!*(unsigned char *)(v2 + 113)) {
      *unsigned int v3 = 0;
    }
    *(_WORD *)(v2 + 112) = 257;
  }
  else
  {
    uint64_t v5 = a2;
    if (sub_1CC8B0F60((void *)(v2 + 64), &v5)) {
      *unsigned int v3 = 0;
    }
  }
  return 1;
}

void *sub_1CC8C7A24(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C7A74(void *a1)
{
  sub_1CD658E34(a1 + 4);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8C7AE4(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = *(const std::string::value_type ***)(a1 + 48);
  uint64_t v5 = *(unsigned int *)(a1 + 64);
  uint64_t v6 = &v4[2 * v5];
  if (*(_DWORD *)(a1 + 56))
  {
    if (v5)
    {
      uint64_t v16 = 16 * v5;
      while ((unint64_t)*v4 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v4 += 2;
        v16 -= 16;
        if (!v16) {
          goto LABEL_2;
        }
      }
    }
  }
  else
  {
LABEL_2:
    uint64_t v4 = v6;
  }
  sub_1CD658E8C(&v26, v4, v6, v6);
  if (*(unsigned char *)(a1 + 72))
  {
    *((unsigned char *)&v25.__r_.__value_.__s + 23) = 9;
    strcpy((char *)&v25, "Universal");
  }
  else
  {
    uint64_t v17 = *(const std::string::value_type ***)(a1 + 80);
    uint64_t v18 = *(unsigned int *)(a1 + 96);
    uint64_t v19 = &v17[2 * v18];
    if (*(_DWORD *)(a1 + 88))
    {
      if (v18)
      {
        uint64_t v20 = 16 * v18;
        while ((unint64_t)*v17 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v17 += 2;
          v20 -= 16;
          if (!v20) {
            goto LABEL_30;
          }
        }
      }
    }
    else
    {
LABEL_30:
      uint64_t v17 = v19;
    }
    sub_1CD658E8C(&v25, v17, v19, v19);
  }
  std::operator+<char>();
  uint64_t v7 = std::string::append(&v21, "],");
  std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__r.__words[2] = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  unsigned int v9 = std::string::append(&v22, " Assumed [");
  std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v25;
  }
  else {
    uint64_t v11 = (std::string *)v25.__r_.__value_.__r.__words[0];
  }
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&v25.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = v25.__r_.__value_.__l.__size_;
  }
  uint64_t v13 = std::string::append(&v23, (const std::string::value_type *)v11, size);
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  uint64_t v15 = std::string::append(&v24, "]");
  *a2 = *v15;
  v15->__r_.__value_.__r.__words[0] = 0;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8C7D08(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 1;
  }
  unsigned int v3 = (llvm::Function *)sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  return llvm::addAssumptions(v3, a1 + 48) ^ 1;
}

BOOL sub_1CC8C7D50(unsigned char *a1, uint64_t a2)
{
  char v6 = 0;
  v5[0] = a2;
  v5[1] = a1;
  void v5[2] = &v6;
  if (llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8C7FE8, (uint64_t)v5, (uint64_t)a1, 1, &v4))return v6 == 0; {
  a1[104] = 1;
  }
  a1[72] = a1[40];
  sub_1CBFCBCC4((uint64_t)(a1 + 80), (uint64_t)(a1 + 48));
  return 0;
}

uint64_t sub_1CC8C7DE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = a2;
  v5[1] = a3;
  uint64_t v3 = a1 + 32;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32);
  if (result) {
    return sub_1CD659154(v3, (uint64_t)v5);
  }
  return result;
}

uint64_t *sub_1CC8C7E4C(void *a1)
{
  int v1 = sub_1CD658E34(a1);
  *(v1 - 4) = &unk_1F2620AA0;
  uint64_t v2 = v1 - 3;

  return sub_1CD64E248(v2);
}

void sub_1CC8C7EA0(void *a1)
{
  int v1 = sub_1CD658E34(a1);
  *(v1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(v1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C7F1C(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 16) = *a2;
  *(void *)a1 = &unk_1F2620A20;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = &unk_1F2622158;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1CBFCBCC4(a1 + 48, a3);
  *(unsigned char *)(a1 + 72) = 1;
  *(unsigned char *)(a1 + 104) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)a1 = &unk_1F2622098;
  *(void *)(a1 + 32) = &unk_1F2622118;
  return a1;
}

BOOL sub_1CC8C7FE8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v9 = v4;
  v10[0] = &v11;
  v10[1] = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)v10, a2 + 8);
    uint64_t v4 = v9;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  BOOL v6 = 1;
  uint64_t v7 = sub_1CC8B924C(*(void *)a1, v4, 0, v5, 0, 0, 1);
  **(unsigned char **)(a1 + 16) |= sub_1CC8C80C4(v5 + 32, (uint64_t)v7 + 72);
  if (!*(_DWORD *)(v5 + 88) && !*(unsigned char *)(v5 + 72) && !*(_DWORD *)(v5 + 56)) {
    BOOL v6 = *(unsigned char *)(v5 + 40) != 0;
  }
  if (v10[0] != &v11) {
    free(v10[0]);
  }
  return v6;
}

BOOL sub_1CC8C80C4(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 56);
  sub_1CD658FB8(a1 + 40, a2);
  if (*(unsigned __int8 *)(a1 + 8) | *(unsigned __int8 *)(a1 + 40))
  {
    char v4 = 1;
  }
  else
  {
    sub_1CD5A4F8C(a1 + 48, a1 + 16);
    char v4 = *(unsigned char *)(a1 + 40) | *(unsigned char *)(a1 + 8);
  }
  *(unsigned char *)(a1 + 40) = v4;
  return v3 != *(_DWORD *)(a1 + 56);
}

void *sub_1CC8C8130(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C8180(void *a1)
{
  sub_1CD658E34(a1 + 4);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::AbstractAttribute *sub_1CC8C81F0(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_1CD6482A0((_DWORD *)(a1 + 16));

  return sub_1CC8B924C(a2, v4, 0, a1, 0, 0, 1);
}

uint64_t sub_1CC8C8248(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    return 1;
  }
  unint64_t v3 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  return llvm::addAssumptions(v3, a1 + 80) ^ 1;
}

BOOL sub_1CC8C8290(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_1CD6482A0((_DWORD *)(a1 + 16));
  uint64_t v5 = sub_1CC8B924C(a2, v4, 0, a1, 0, 0, 1);
  return !sub_1CC8C80C4(a1 + 32, (uint64_t)v5 + 72);
}

uint64_t *sub_1CC8C82F0(void *a1)
{
  int v1 = sub_1CD658E34(a1);
  *(v1 - 4) = &unk_1F2620AA0;
  uint64_t v2 = v1 - 3;

  return sub_1CD64E248(v2);
}

void sub_1CC8C8344(void *a1)
{
  int v1 = sub_1CD658E34(a1);
  *(v1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(v1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C83B0(uint64_t a1, _OWORD *a2)
{
  unint64_t v3 = (llvm::IRPosition *)(a1 + 16);
  *(_OWORD *)(a1 + 16) = *a2;
  *(_WORD *)(a1 + 40) = 256;
  *(void *)a1 = &unk_1F2622348;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = &unk_1F26223D0;
  unint64_t v4 = sub_1CD6482A0((_DWORD *)(a1 + 16));
  unint64_t v5 = sub_1CD6482F0(v3);
  unsigned int v6 = *(_DWORD *)(*(void *)v5 + 8);
  if ((v6 & 0xFE) == 0x12) {
    unsigned int v6 = *(_DWORD *)(**(void **)(*(void *)v5 + 16) + 8);
  }
  v8 = v4 && (uint64_t v7 = *(void *)(v4 + 112)) != 0 && (*(unsigned char *)(v7 + 17) & 1) != 0 || v6 > 0xFF;
  *(unsigned char *)(a1 + 42) = v8;
  return a1;
}

void *sub_1CC8C8488(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8C84CC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8C8530(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v5 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (!*(unsigned char *)(a1 + 42))
  {
    v38[0] = 0x4C00000027;
    if (llvm::IRPosition::hasAttr(v4, (unsigned int *)v38, 2, 0, a2)) {
      return (void *)(*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
    }
  }
  if (*(unsigned char *)(v5 + 16) == 19) {
    return (void *)(*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  sub_1CD6593CC((void *)a1, a2);
  *(_WORD *)uint64_t v29 = 0;
  if (llvm::Value::getPointerDereferenceableBytes((uint64_t ***)v5, *(const llvm::DataLayout **)(*(void *)(a2 + 88) + 120), &v29[1], v29))
  {
    BOOL v7 = !v29[1];
  }
  else
  {
    BOOL v7 = 0;
  }
  if (v7) {
    return (void *)(*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
  }
  if (*(unsigned __int8 *)(sub_1CD6482F0(v4) + 16) <= 3u) {
    return (void *)(*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  uint64_t result = (void *)sub_1CC8AB830(v4);
  if (result)
  {
    uint64_t v8 = (uint64_t)result;
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    v38[0] = 0;
    v38[1] = 0;
    int v39 = 0;
    uint64_t v42 = 0;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    for (uint64_t i = *(void **)(sub_1CD6482F0(v4) + 8); i; uint64_t i = (void *)i[1])
    {
      unint64_t v35 = i;
      sub_1CC61C590(v38, &v35);
    }
    uint64_t v11 = *(void *)(a2 + 88) + 136;
    sub_1CC8C8C94(a1, a2, v11, v8, v38, v9);
    uint64_t v28 = v9;
    if (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9) & 1) == 0)
    {
      int v34 = &v35;
      unint64_t v35 = v37;
      uint64_t v36 = 0x400000000;
      sub_1CD65952C(v11, v8, (unsigned int (*)(uint64_t))sub_1CC8C9C34, (uint64_t)&v34);
      unsigned int v12 = (char *)v35;
      if (v36)
      {
        uint64_t v13 = (char *)v35 + 8 * v36;
        uint64_t v27 = v13;
        do
        {
          uint64_t v14 = *(void *)v12;
          uint64_t v32 = &unk_1F2620BB0;
          __int16 v33 = 257;
          int v15 = *(_DWORD *)(v14 + 20);
          if ((v15 & 0x40000000) != 0)
          {
            uint64_t v17 = *(void *)(v14 - 8);
            uint64_t v16 = v15 & 0x7FFFFFF;
          }
          else
          {
            uint64_t v16 = v15 & 0x7FFFFFF;
            uint64_t v17 = v14 - 32 * v16;
          }
          uint64_t v18 = v16 == 3;
          if (v16 == v18)
          {
            int v19 = 1;
          }
          else
          {
            uint64_t v20 = (uint64_t *)(v17 + 32 * v16);
            std::string v21 = (uint64_t *)(v17 + 32 * v18);
            do
            {
              uint64_t v22 = *v21;
              __int16 v31 = 256;
              uint64_t v30 = &unk_1F2620BB0;
              std::string v23 = &v41[-v40];
              uint64_t v24 = *(void *)(v22 + 48);
              if (v24) {
                uint64_t v25 = v24 - 24;
              }
              else {
                uint64_t v25 = 0;
              }
              sub_1CC8C8C94(a1, a2, v11, v25, v38, (uint64_t)&v30);
              for (j = &v23[v40]; v41 != j; j = sub_1CD659618((uint64_t)v38, j))
                ;
              (*((void (**)(void **, void, void))v32 + 9))(&v32, HIBYTE(v31), v31);
              v21 += 4;
            }
            while (v21 != v20);
            int v19 = v33;
            uint64_t v13 = v27;
            uint64_t v9 = v28;
          }
          (*(void (**)(uint64_t, BOOL))(*(void *)v9 + 56))(v9, v19 != 0);
          v12 += 8;
        }
        while (v12 != v13);
        unsigned int v12 = (char *)v35;
      }
      if (v12 != v37) {
        free(v12);
      }
    }
    return sub_1CD456CB4(v38);
  }
  return result;
}

void *sub_1CC8C8958@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    unint64_t v3 = "nonnull";
  }
  else {
    unint64_t v3 = "may-null";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 7;
  }
  else {
    size_t v4 = 8;
  }
  a2[23] = v4;
  uint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8C89B0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C000, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C000))
  {
    __cxa_guard_release(&qword_1EA61C000);
  }
}

uint64_t sub_1CC8C8A04(uint64_t a1, llvm::Attributor *a2)
{
  uint64_t v4 = *((void *)a2 + 11);
  uint64_t v5 = *(void *)(v4 + 120);
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  unsigned int v6 = (_DWORD *)(a1 + 16);
  unint64_t v7 = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (v7)
  {
    unint64_t v8 = v7;
    uint64_t v9 = **(void **)(v4 + 440);
    uint64_t v10 = *(void *)(v8 + 40);
    if (v9) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    uint64_t v24 = 0;
    if (v9) {
      BOOL v12 = v10 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    uint64_t v23 = 0;
  }
  v22[0] = a2;
  v22[1] = a1;
  v22[2] = v5;
  v22[3] = &v23;
  v22[4] = &v24;
  __int16 v21 = 256;
  uint64_t v20 = &unk_1F2620BB0;
  BOOL v19 = 0;
  uint64_t v13 = *(void *)(a1 + 16);
  uint64_t v14 = *(void *)(a1 + 24);
  unint64_t v15 = sub_1CC8AB830(v6);
  if ((sub_1CC8C9CC4(a2, v13, v14, (const llvm::AbstractAttribute *)a1, (uint64_t)&v20, (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL))sub_1CC8CA900, (uint64_t)v22, v15, &v19) & 1) == 0)return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32); {
  uint64_t v16 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  }
  BOOL v17 = v16[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v16 + 48))(v16, HIBYTE(v21));
  return v17 ^ (v16[9] != 0);
}

uint64_t *sub_1CC8C8BF4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8C8C1C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8C8C94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v11 = sub_1CD4B25C4(a3, a4);
  v28[0] = 0;
  v28[1] = 0;
  int v29 = 0;
  sub_1CBFCB9AC((uint64_t)v28, v11);
  long long v12 = *(_OWORD *)(v11 + 24);
  long long v31 = *(_OWORD *)(v11 + 40);
  long long v30 = v12;
  v24[0] = 0;
  v24[1] = 0;
  int v25 = 0;
  sub_1CBFCB9AC((uint64_t)v24, a3 + 176);
  long long v13 = *(_OWORD *)(a3 + 216);
  long long v26 = *(_OWORD *)(a3 + 200);
  long long v27 = v13;
  uint64_t v14 = a5[3];
  if (a5[4] != v14)
  {
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    do
    {
      BOOL v17 = *(unint64_t **)(v14 + 8 * v15);
      unint64_t v18 = v17[3];
      if (v18) {
        BOOL v19 = *(unsigned __int8 *)(v18 + 16) >= 0x1Cu;
      }
      else {
        BOOL v19 = 0;
      }
      if (v19)
      {
        if (sub_1CD648B2C(a3, v17[3], v28, v24))
        {
          LOBYTE(v23) = 0;
          char v32 = 0;
          uint64_t v20 = (llvm::GlobalValue *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
          sub_1CC8C8E2C(a2, a1, v20, (llvm::MemoryLocation *)v17, (llvm::MemoryLocation *)v18, &v23, &v32);
          char v21 = v23;
          *(unsigned char *)(a6 + 8) |= v23;
          *(unsigned char *)(a6 + 9) |= v21;
          if (v32)
          {
            while (1)
            {
              unint64_t v18 = *(void *)(v18 + 8);
              if (!v18) {
                break;
              }
              unint64_t v23 = v18;
              sub_1CC61C590(a5, &v23);
            }
          }
        }
      }
      uint64_t v14 = a5[3];
      uint64_t v15 = ++v16;
    }
    while (v16 < (unint64_t)((a5[4] - v14) >> 3));
  }
  MEMORY[0x1D25D9CD0](v24[0], 8);
  return MEMORY[0x1D25D9CD0](v28[0], 8);
}

uint64_t sub_1CC8C8E2C(uint64_t a1, uint64_t a2, llvm::GlobalValue *a3, llvm::MemoryLocation *a4, llvm::MemoryLocation *this, unsigned char *a6, unsigned char *a7)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  *a7 = 0;
  unint64_t v7 = *(llvm::GlobalValue **)a4;
  uint64_t v8 = **(void **)a4;
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 != 15) {
    return 0;
  }
  int v11 = *((unsigned __int8 *)this + 16);
  if ((v11 - 66) <= 0xC || v11 == 62)
  {
    uint64_t result = 0;
    *a7 = 1;
    return result;
  }
  uint64_t v17 = *(void *)(*((void *)this + 5) + 56);
  if (v17)
  {
    if ((v9 & 0xFE) == 0x12) {
      unsigned int v9 = *(_DWORD *)(**(void **)(v8 + 16) + 8);
    }
    uint64_t v18 = *(void *)(v17 + 112);
    BOOL v19 = v18 && (*(unsigned char *)(v18 + 17) & 1) != 0 || v9 > 0xFF;
    char v20 = !v19;
  }
  else
  {
    char v20 = 0;
  }
  unsigned int v21 = v11 - 33;
  BOOL v22 = v21 > 0x33;
  uint64_t v23 = (1 << v21) & 0x8000000000041;
  if (v22 || v23 == 0)
  {
    uint64_t v30 = *(void *)(*(void *)(a1 + 88) + 120);
    llvm::MemoryLocation::getOrNone((uint64_t ***)this, (uint64_t)&v60);
    uint64_t result = 0;
    if (!v62 || v60 != v7) {
      return result;
    }
    if (v61 < 0 || (llvm::Instruction::isVolatile(this) & 1) != 0) {
      return 0;
    }
    unsigned int v31 = *(_DWORD *)(*(void *)v60 + 8);
    if ((v31 & 0xFE) == 0x12) {
      unsigned int v31 = *(_DWORD *)(**(void **)(*(void *)v60 + 16) + 8);
    }
    if (v31 < 0x100) {
      goto LABEL_43;
    }
    unsigned int v32 = v31 >> 8;
    uint64_t v33 = *(unsigned int *)(v30 + 240);
    uint64_t v34 = *(void *)(v30 + 232);
    if (v33)
    {
      uint64_t v34 = *(void *)(v30 + 232);
      unint64_t v35 = *(unsigned int *)(v30 + 240);
      do
      {
        unint64_t v36 = v35 >> 1;
        uint64_t v37 = v34 + 16 * (v35 >> 1);
        unsigned int v38 = *(_DWORD *)(v37 + 8);
        uint64_t v39 = v37 + 16;
        v35 += ~(v35 >> 1);
        if (v38 < v32) {
          uint64_t v34 = v39;
        }
        else {
          unint64_t v35 = v36;
        }
      }
      while (v35);
    }
    if (v34 == *(void *)(v30 + 232) + 16 * v33 || *(_DWORD *)(v34 + 8) != v32) {
LABEL_43:
    }
      uint64_t v34 = *(void *)(v30 + 232);
    unsigned int v64 = *(_DWORD *)(v34 + 12);
    if (v64 > 0x40) {
      operator new[]();
    }
    uint64_t v63 = 0;
    char v66 = 1;
    char v65 = 0;
    uint64_t v67 = a1;
    uint64_t v68 = a2;
    uint64_t v69 = &v65;
    char v70 = &v66;
    uint64_t v41 = llvm::Value::stripAndAccumulateConstantOffsets(v60, (llvm::DataLayout *)v30, (llvm::APInt *)&v63, 0, 1, (unsigned int (*)(uint64_t, llvm::Constant *, void **))sub_1CC8C93FC, (uint64_t)&v67);
    if (v64 > 0x40)
    {
      uint64_t v42 = *v63;
      MEMORY[0x1D25D9CB0]();
    }
    else
    {
      uint64_t v42 = (uint64_t)((void)v63 << -(uint64_t)v64) >> -(uint64_t)v64;
    }
    if (v41 && v41 == a3)
    {
      uint64_t v43 = (v61 & 0x7FFFFFFFFFFFFFFFLL) + v42;
      *a6 |= v20;
      return v43 & ~(v43 >> 63);
    }
    unsigned int v44 = *(_DWORD *)(*(void *)v60 + 8);
    if ((v44 & 0xFE) == 0x12) {
      unsigned int v44 = *(_DWORD *)(**(void **)(*(void *)v60 + 16) + 8);
    }
    if (v44 < 0x100) {
      goto LABEL_62;
    }
    unsigned int v45 = v44 >> 8;
    uint64_t v46 = *(unsigned int *)(v30 + 240);
    uint64_t v47 = *(void *)(v30 + 232);
    if (v46)
    {
      uint64_t v47 = *(void *)(v30 + 232);
      unint64_t v48 = *(unsigned int *)(v30 + 240);
      do
      {
        unint64_t v49 = v48 >> 1;
        uint64_t v50 = v47 + 16 * (v48 >> 1);
        unsigned int v51 = *(_DWORD *)(v50 + 8);
        uint64_t v52 = v50 + 16;
        v48 += ~(v48 >> 1);
        if (v51 < v45) {
          uint64_t v47 = v52;
        }
        else {
          unint64_t v48 = v49;
        }
      }
      while (v48);
    }
    if (v47 == *(void *)(v30 + 232) + 16 * v46 || *(_DWORD *)(v47 + 8) != v45) {
LABEL_62:
    }
      uint64_t v47 = *(void *)(v30 + 232);
    LODWORD(v68) = *(_DWORD *)(v47 + 12);
    if (v68 > 0x40) {
      operator new[]();
    }
    uint64_t v67 = 0;
    uint64_t v53 = llvm::Value::stripAndAccumulateConstantOffsets(v60, (llvm::DataLayout *)v30, (llvm::APInt *)&v67, 1, 0, 0, v40);
    uint64_t v54 = v53;
    if (v68 > 0x40)
    {
      uint64_t v55 = *(void *)v67;
      MEMORY[0x1D25D9CB0]();
      if (!v54) {
        return 0;
      }
    }
    else
    {
      uint64_t v55 = v67 << -(uint64_t)v68 >> -(uint64_t)v68;
      if (!v53) {
        return 0;
      }
    }
    uint64_t result = 0;
    if (v54 != a3 || v55) {
      return result;
    }
    uint64_t result = v61 & 0x7FFFFFFFFFFFFFFFLL;
LABEL_25:
    *a6 |= v20;
    return result;
  }
  int v25 = *((_DWORD *)this + 5);
  if (v25 < 0)
  {
    uint64_t v56 = (char *)this - 32 * (v25 & 0x7FFFFFF);
    uint64_t v57 = *((void *)v56 - 1);
    if ((v57 & 0xFFFFFFFF0) != 0)
    {
      unint64_t v58 = (unint64_t)(a4 - (llvm::MemoryLocation *)v56) >> 5;
      if (*(_DWORD *)&v56[-v57] <= v58 && *((_DWORD *)v56 - 3) > v58)
      {
        uint64_t v67 = 0x4C00000027;
        llvm::getKnowledgeFromUse((uint64_t)a4, &v67, 2, (uint64_t)&v60);
        if (v60)
        {
          if (v60 == 39) {
            char v59 = 1;
          }
          else {
            char v59 = v20;
          }
          *a6 |= v59;
          return v61;
        }
        return 0;
      }
    }
  }
  if ((llvm::MemoryLocation *)((char *)this - 32) == a4)
  {
    uint64_t result = 0;
    goto LABEL_25;
  }
  long long v26 = (llvm::MemoryLocation *)((char *)this - 32 * (v25 & 0x7FFFFFF));
  int64_t v27 = a4 - v26;
  if ((v25 & 0x40000000) != 0) {
    long long v26 = (llvm::MemoryLocation *)*((void *)this - 1);
  }
  uint64_t v28 = sub_1CC8BB19C(a1, ((unint64_t)v26 + (v27 & 0x1FFFFFFFE0)) | 3, 0, a2, 2, 0, 1);
  uint64_t v29 = *((void *)v28 + 12);
  if (v29) {
    LOBYTE(v29) = *(unsigned char *)(v29 + 40) != 0;
  }
  *a6 |= v29;
  return *((unsigned int *)v28 + 12);
}

uint64_t sub_1CC8C93FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 != 21)
  {
    if (v5 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v6 = v5 - 33;
      BOOL v7 = v6 > 0x33;
      uint64_t v8 = (1 << v6) & 0x8000000000041;
      if (!v7 && v8 != 0) {
        a2 |= 1uLL;
      }
    }
  }
  uint64_t v10 = *(void *)a1;
  if (**(unsigned char **)(a1 + 16)) {
    int v11 = 1;
  }
  else {
    int v11 = 2;
  }
  long long v12 = sub_1CC8C972C(v10, a2, 0, *(void *)(a1 + 8), v11);
  if (**(unsigned char **)(a1 + 16))
  {
    unsigned int v13 = *((_DWORD *)v12 + 14);
    unsigned int v21 = v13;
    if (v13 > 0x40) {
      operator new[]();
    }
    uint64_t v14 = *((void *)v12 + 6);
    uint64_t v20 = v14;
    unsigned int v23 = *((_DWORD *)v12 + 18);
    if (v23 > 0x40) {
      operator new[]();
    }
    uint64_t v15 = *((void *)v12 + 8);
    uint64_t v22 = v15;
  }
  else
  {
    unsigned int v13 = *((_DWORD *)v12 + 22);
    unsigned int v21 = v13;
    if (v13 > 0x40) {
      operator new[]();
    }
    uint64_t v14 = *((void *)v12 + 10);
    uint64_t v20 = v14;
    unsigned int v23 = *((_DWORD *)v12 + 26);
    if (v23 > 0x40) {
      operator new[]();
    }
    uint64_t v15 = *((void *)v12 + 12);
    uint64_t v22 = v15;
  }
  if (v15 == v14)
  {
    if (!v13)
    {
      uint64_t v16 = 0;
      goto LABEL_28;
    }
    uint64_t v16 = 0;
    if (v15 == 0xFFFFFFFFFFFFFFFFLL >> -(char)v13) {
      goto LABEL_28;
    }
  }
  if (**(unsigned char **)(a1 + 24)) {
    llvm::ConstantRange::getSignedMin((uint64_t)&v20, (uint64_t)&v18);
  }
  else {
    llvm::ConstantRange::getSignedMax(&v20, (uint64_t)&v18);
  }
  if (*(_DWORD *)(a3 + 8) >= 0x41u && *(void *)a3) {
    MEMORY[0x1D25D9CB0](*(void *)a3, 0x1000C8000313F17);
  }
  *(void *)a3 = v18;
  *(_DWORD *)(a3 + 8) = v19;
  uint64_t v16 = 1;
LABEL_28:
  if (v23 >= 0x41 && v22) {
    MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
  }
  if (v21 >= 0x41 && v20) {
    MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
  }
  return v16;
}

llvm::AbstractAttribute *sub_1CC8C972C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (byte_1EBD07860) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)&long long v51 = a2;
  *((void *)&v51 + 1) = v8;
  uint64_t v10 = (llvm::AbstractAttribute *)sub_1CD6596A4(a1, &v51, a4, a5);
  if (v10) {
    return v10;
  }
  uint64_t v10 = (llvm::AbstractAttribute *)llvm::AAValueConstantRange::createForPosition((llvm::AAValueConstantRange *)&v51, (uint64_t **)a1, v9);
  sub_1CD659790(a1, (uint64_t)v10);
  long long v12 = *(uint64_t **)(a1 + 5480);
  if (v12)
  {
    __p[0] = &llvm::AAValueConstantRange::ID;
    v47[0] = 0;
    int v13 = sub_1CD420258(v12, __p, v47) ^ 1;
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v14 = v51 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v51 & 3) == 0) {
    uint64_t v14 = *(void *)(v14 + 24);
  }
  unsigned int v15 = *(unsigned __int8 *)(v14 + 16);
  if (!*(unsigned char *)(v14 + 16)) {
    goto LABEL_16;
  }
  if (v15 == 21)
  {
    uint64_t v16 = (uint64_t *)(v14 + 24);
  }
  else
  {
    if (v15 < 0x1C)
    {
      uint64_t v14 = 0;
      goto LABEL_23;
    }
    uint64_t v16 = (uint64_t *)(*(void *)(v14 + 40) + 56);
  }
  uint64_t v14 = *v16;
  if (!*v16)
  {
LABEL_23:
    char v19 = 1;
    goto LABEL_48;
  }
LABEL_16:
  uint64_t v17 = *(void *)(v14 + 112);
  if (v17 && ((*(unsigned char *)(v17 + 14) & 2) != 0 || (*(unsigned char *)(v17 + 17) & 8) != 0))
  {
    BOOL v18 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v18 = 0;
  }
  else
  {
    uint64_t v20 = *(uint64_t **)(a1 + 88);
    uint64_t v22 = *v20;
    uint64_t v21 = v20[1];
    if (v21 == *v20)
    {
      uint64_t v23 = *((unsigned int *)v20 + 5);
      uint64_t v24 = (void *)(v21 + 8 * v23);
      if (v23)
      {
        uint64_t v25 = 0;
        uint64_t v26 = 8 * v23;
        while (*(void *)(v21 + v25) != v14)
        {
          v25 += 8;
          if (v26 == v25) {
            goto LABEL_43;
          }
        }
        uint64_t v24 = (void *)(v21 + v25);
      }
LABEL_43:
      uint64_t v22 = v20[1];
    }
    else
    {
      uint64_t v27 = *((unsigned int *)v20 + 4);
      int v28 = v27 - 1;
      unsigned int v29 = (v27 - 1) & ((v14 >> 4) ^ (v14 >> 9));
      uint64_t v24 = (void *)(v21 + 8 * v29);
      uint64_t v30 = *v24;
      if (*v24 == -1)
      {
        unsigned int v31 = 0;
LABEL_84:
        if (v31) {
          uint64_t v24 = v31;
        }
        if (*v24 != v14) {
          uint64_t v24 = (void *)(v21 + 8 * v27);
        }
      }
      else
      {
        unsigned int v31 = 0;
        int v32 = 1;
        while (v30 != v14)
        {
          if (v31) {
            BOOL v33 = 0;
          }
          else {
            BOOL v33 = v30 == -2;
          }
          if (v33) {
            unsigned int v31 = v24;
          }
          unsigned int v34 = v29 + v32++;
          unsigned int v29 = v34 & v28;
          uint64_t v24 = (void *)(v21 + 8 * (v34 & v28));
          uint64_t v30 = *v24;
          if (*v24 == -1) {
            goto LABEL_84;
          }
        }
      }
    }
    BOOL v33 = v21 == v22;
    uint64_t v35 = 16;
    if (v33) {
      uint64_t v35 = 20;
    }
    BOOL v18 = v24 == (void *)(v21 + 8 * *(unsigned int *)((char *)v20 + v35));
  }
  char v19 = 0;
  LOBYTE(v13) = (v18 | v13) != 0;
LABEL_48:
  if ((v13 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_75;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v10 + 72))(v47, v10);
  if (v48 >= 0) {
    size_t v36 = v48 & 0x7F;
  }
  else {
    size_t v36 = (size_t)v47[1];
  }
  uint64_t v37 = __p;
  sub_1CB907098((uint64_t)__p, v36 + 12);
  if (v50 < 0) {
    uint64_t v37 = (void **)__p[0];
  }
  if (v36)
  {
    if (v48 >= 0) {
      unsigned int v38 = v47;
    }
    else {
      unsigned int v38 = (void **)v47[0];
    }
    memmove(v37, v38, v36);
  }
  strcpy((char *)v37 + v36, "::initialize");
  uint64_t v39 = (uint64_t *)off_1EC7DFC00();
  if (*v39)
  {
    if (v50 >= 0) {
      uint64_t v40 = __p;
    }
    else {
      uint64_t v40 = (void **)__p[0];
    }
    if (v50 >= 0) {
      uint64_t v41 = v50 & 0x7F;
    }
    else {
      uint64_t v41 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v40, v41, (uint64_t)"", 0);
  }
  if (v50 < 0) {
    operator delete(__p[0]);
  }
  if (v48 < 0) {
    operator delete(v47[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v10 + 24))(v10, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v39)
  {
    sub_1CD84B62C(*v39);
    if (v19) {
      goto LABEL_74;
    }
  }
  else if (v19)
  {
    goto LABEL_74;
  }
  unsigned int v45 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v14;
  v47[0] = 0;
  if ((sub_1CD420258(v45, __p, v47) & 1) == 0)
  {
    uint64_t v46 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v51);
    v47[0] = 0;
    if ((sub_1CD420258(v46, __p, v47) & 1) == 0) {
      goto LABEL_75;
    }
  }
LABEL_74:
  int v42 = *(_DWORD *)(a1 + 4368);
  if (v42 == 2)
  {
LABEL_75:
    uint64_t v43 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 40))(v10);
    (*(void (**)(uint64_t))(*(void *)v43 + 40))(v43);
    return v10;
  }
  *(_DWORD *)(a1 + 4368) = 1;
  llvm::Attributor::updateAA((llvm::Attributor *)a1, v10);
  *(_DWORD *)(a1 + 4368) = v42;
  if (a4)
  {
    uint64_t v44 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 40))(v10);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v44 + 16))(v44)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v10, a4, a5);
    }
  }
  return v10;
}

uint64_t sub_1CC8C9C34(uint64_t *a1, uint64_t a2)
{
  if (a2 && *(unsigned char *)(a2 + 16) == 30 && (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3)
  {
    uint64_t v2 = *a1;
    unsigned int v3 = *(_DWORD *)(*a1 + 8);
    if (v3 >= *(_DWORD *)(*a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v2 + 8 * v3) = a2;
    ++*(_DWORD *)(v2 + 8);
  }
  return 1;
}

uint64_t sub_1CC8C9CC4(llvm::Attributor *a1, uint64_t a2, uint64_t a3, const llvm::AbstractAttribute *a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL), uint64_t a7, uint64_t a8, BOOL *a9)
{
  v129[12] = *MEMORY[0x1E4F143B8];
  v106[0] = a2;
  v106[1] = a3;
  v126[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v126[i] = -4096;
  long long v127 = (char *)v129;
  uint64_t v128 = 0x400000000;
  unint64_t v13 = sub_1CD6482F0((llvm::IRPosition *)v106);
  uint64_t v14 = 0;
  v123[0] = v124;
  v123[1] = (void *)0x1000000000;
  v125[1] = 0;
  v125[0] = 0;
  v124[32] = v125;
  int64x2_t v119 = (char *)v122;
  unsigned int v121 = 16;
  v122[0] = v13;
  v122[1] = a8;
  unint64_t v96 = v13;
  int64x2_t v95 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v15 = 1;
  uint64_t v100 = (uint64_t)a1;
  uint64_t v101 = (uint64_t)a4;
  do
  {
    uint64_t v16 = &v119[16 * v15];
    uint64_t v18 = *((void *)v16 - 2);
    unint64_t v17 = *((void *)v16 - 1);
    unsigned int v120 = v15 - 1;
    v105[0] = v18;
    v105[1] = v17;
    if ((sub_1CD65837C((uint64_t)v123, v105) & 0x100000000) == 0)
    {
      uint64_t v19 = v14;
      goto LABEL_110;
    }
    if ((int)v14 >= 16) {
      goto LABEL_159;
    }
    uint64_t v19 = (v14 + 1);
    if (*(unsigned char *)(*(void *)v18 + 8) != 15)
    {
      unsigned int v23 = *(unsigned __int8 *)(v18 + 16);
      if (v23 < 0x1C) {
        goto LABEL_34;
      }
      unsigned int v24 = v23 - 33;
      BOOL v25 = v24 > 0x33;
      uint64_t v26 = (1 << v24) & 0x8000000000041;
      if (v25 || v26 == 0) {
        goto LABEL_34;
      }
      uint64_t v28 = *(void *)(v18 - 32);
      if (!v28 || *(unsigned char *)(v28 + 16) || *(void *)(v28 + 24) != *(void *)(v18 + 72)) {
        goto LABEL_34;
      }
      if (*(_WORD *)(v28 + 18))
      {
        llvm::Function::BuildLazyArguments(*(llvm::Function **)(v18 - 32));
        uint64_t v29 = *(void *)(v28 + 88);
        if (*(_WORD *)(v28 + 18))
        {
          llvm::Function::BuildLazyArguments((llvm::Function *)v28);
          uint64_t v30 = *(void *)(v28 + 88);
LABEL_26:
          uint64_t v31 = v30 + 40 * *(void *)(v28 + 96);
          while (v29 != v31)
          {
            uint64_t v32 = *(void *)(*(void *)(v29 + 24) + 112);
            if (v32)
            {
              uint64_t v33 = *(unsigned int *)(v29 + 32);
              if ((v33 + 2) < *(_DWORD *)(v32 + 8))
              {
                uint64_t v34 = *(void *)(v32 + 8 * (v33 + 2) + 40);
                if (v34)
                {
                  if ((*(unsigned char *)(v34 + 17) & 0x40) != 0)
                  {
                    uint64_t v20 = *(llvm::Value **)(v18 - 32 * (*(_DWORD *)(v18 + 20) & 0x7FFFFFF) + 32 * v33);
                    goto LABEL_9;
                  }
                }
              }
            }
            v29 += 40;
          }
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v29 = *(void *)(v28 + 88);
      }
      uint64_t v30 = v29;
      goto LABEL_26;
    }
    uint64_t v20 = llvm::Value::stripPointerCasts((llvm::Value *)v18);
LABEL_9:
    if (v20) {
      BOOL v21 = v20 == (llvm::Value *)v18;
    }
    else {
      BOOL v21 = 1;
    }
    if (!v21)
    {
LABEL_13:
      if (v120 >= (unint64_t)v121) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v22 = &v119[16 * v120];
      *(void *)uint64_t v22 = v20;
      goto LABEL_109;
    }
LABEL_34:
    int v35 = *(unsigned __int8 *)(v18 + 16);
    if (v35 == 83)
    {
      uint64_t v41 = *(void *)(*(void *)(v18 + 40) + 56);
      uint64_t v107 = v41;
      int v108 = 0;
      sub_1CD645794((uint64_t)&v114, (uint64_t)v126, &v107, &v108);
      uint64_t v42 = v114;
      unsigned int v102 = v19;
      if (BYTE8(v115[0]))
      {
        *(_DWORD *)&v109[20] = 0;
        *(_DWORD *)&v109[17] = 0;
        *(void *)uint64_t v109 = v41;
        *(void *)&v109[8] = 0;
        v109[16] = 0;
        if (v128 >= HIDWORD(v128))
        {
          if (v127 > v109 || &v127[24 * v128] <= v109) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unint64_t v49 = &v127[24 * v128];
        long long v50 = *(_OWORD *)v109;
        *((void *)v49 + 2) = *(void *)&v109[16];
        *(_OWORD *)unint64_t v49 = v50;
        int v43 = v128;
        LODWORD(v128) = v128 + 1;
        *(_DWORD *)(v42 + 8) = v43;
      }
      else
      {
        int v43 = *(_DWORD *)(v114 + 8);
      }
      long long v51 = v127;
      uint64_t v52 = &v127[24 * v43];
      uint64_t v54 = *((void *)v52 + 1);
      uint64_t v53 = (llvm::AbstractAttribute **)(v52 + 8);
      if (!v54) {
        *uint64_t v53 = sub_1CC8AC178(v100, v41, 0, v101, 2, 0, 1);
      }
      uint64_t v55 = *(_DWORD *)(v18 + 20) & 0x7FFFFFF;
      if (v55)
      {
        uint64_t v56 = 0;
        uint64_t v57 = 0;
        unint64_t v58 = &v51[24 * v43 + 16];
        uint64_t v59 = 8 * v55;
        do
        {
          int v60 = *(_DWORD *)(v18 + 20);
          if ((v60 & 0x40000000) != 0) {
            uint64_t v61 = *(void *)(v18 - 8);
          }
          else {
            uint64_t v61 = v18 - 32 * (v60 & 0x7FFFFFF);
          }
          uint64_t v62 = *(void *)(v61 + 32 * *(unsigned int *)(v18 + 60) + v57);
          if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v53 + 168))(*v53, v62, *(void *)(v18 + 40)))
          {
            *unint64_t v58 = 1;
            *a9 |= (*(unsigned __int8 (**)(void))(*((void *)*v53 + 4) + 24))() ^ 1;
          }
          else
          {
            int v63 = *(_DWORD *)(v18 + 20);
            if ((v63 & 0x40000000) != 0) {
              uint64_t v64 = *(void *)(v18 - 8);
            }
            else {
              uint64_t v64 = v18 - 32 * (v63 & 0x7FFFFFF);
            }
            uint64_t v65 = *(void *)(v62 + 40);
            if (v65 == v62 + 40)
            {
              uint64_t v67 = 0;
            }
            else
            {
              if (v65) {
                uint64_t v66 = v65 - 24;
              }
              else {
                uint64_t v66 = 0;
              }
              if (*(unsigned __int8 *)(v66 + 16) - 29 >= 0xB) {
                uint64_t v67 = 0;
              }
              else {
                uint64_t v67 = v66;
              }
            }
            uint64_t v68 = *(void *)(v64 + v56);
            if (v120 >= (unint64_t)v121) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v69 = &v119[16 * v120];
            *(void *)uint64_t v69 = v68;
            *((void *)v69 + 1) = v67;
            ++v120;
          }
          v57 += 8;
          v56 += 32;
        }
        while (v59 != v57);
      }
      a1 = (llvm::Attributor *)v100;
      a4 = (const llvm::AbstractAttribute *)v101;
      uint64_t v19 = v102;
      goto LABEL_110;
    }
    if (v35 != 85)
    {
      if (v35 == 21) {
        uint64_t v44 = (llvm::Argument *)v18;
      }
      else {
        uint64_t v44 = 0;
      }
      uint64_t v107 = (uint64_t)v44;
      if (v44 && (llvm::Argument::hasPassPointeeByValueCopyAttr(v44) & 1) == 0)
      {
        uint64_t v114 = (uint64_t)v115 + 8;
        *(void *)&v115[0] = 0x300000000;
        char v104 = 0;
        *(void *)uint64_t v109 = &v107;
        *(void *)&v109[8] = &v114;
        int v45 = llvm::Attributor::checkForAllCallSites((uint64_t)a1, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8CA7DC, (uint64_t)v109, *(void *)(v107 + 24), 1, (uint64_t)a4, &v104);
        char v46 = v45;
        int v47 = 0;
        if (v45)
        {
          sub_1CD3D61B4((unsigned int *)&v119, (unsigned char *)v114, (unsigned char *)(v114 + 16 * LODWORD(v115[0])));
          int v47 = 3;
        }
        if ((_OWORD *)v114 != (_OWORD *)((char *)v115 + 8)) {
          free((void *)v114);
        }
        if (v46)
        {
LABEL_57:
          if (v47 != 3 && v47)
          {
LABEL_159:
            uint64_t v91 = 0;
            goto LABEL_160;
          }
          goto LABEL_110;
        }
      }
      unsigned int v48 = *(unsigned __int8 *)(v18 + 16);
      if (v48 < 0x15) {
        goto LABEL_56;
      }
      uint64_t v70 = v18;
      if (v48 >= 0x1C)
      {
        unsigned int v71 = v48 - 33;
        uint64_t v70 = v18;
        if (v71 <= 0x33)
        {
          uint64_t v70 = v18;
          if (((1 << v71) & 0x8000000000041) != 0) {
            uint64_t v70 = v18 | 1;
          }
        }
      }
      uint64_t v114 = v70;
      *(void *)&v115[0] = 0;
      unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a1, (const llvm::IRPosition *)&v114, a4, a9);
      if (!v73) {
        goto LABEL_110;
      }
      uint64_t v20 = (llvm::Value *)AssumedSimplified;
      if (AssumedSimplified && v18 != AssumedSimplified) {
        goto LABEL_13;
      }
      if (*(unsigned char *)(v18 + 16) != 60)
      {
LABEL_56:
        int v47 = a6(a7, v18, v17, a5, (int)v14 > 0) ^ 1;
        goto LABEL_57;
      }
      unsigned int v103 = v14 + 1;
      LOBYTE(v107) = 0;
      if (*(void *)(v18 - 32) == v96)
      {
LABEL_146:
        uint64_t v19 = v103;
        goto LABEL_56;
      }
      uint64_t v114 = 1;
      v115[0] = v95;
      v115[1] = v95;
      long long v116 = v118;
      uint64_t v117 = 0x400000000;
      *(void *)uint64_t v109 = 1;
      *(int64x2_t *)&v109[8] = v95;
      int64x2_t v110 = v95;
      int v111 = v113;
      uint64_t v112 = 0x400000000;
      LODWORD(v74) = 1;
      if (llvm::AA::getPotentiallyLoadedValues(a1, v18, &v114, v109, a4, (BOOL *)&v107, 1))
      {
        if (!v117)
        {
LABEL_99:
          LODWORD(v74) = 0;
LABEL_100:
          int v47 = 3;
LABEL_138:
          if (v111 != v113) {
            free(v111);
          }
          if ((v109[0] & 1) == 0) {
            MEMORY[0x1D25D9CD0](*(void *)&v109[8], 8);
          }
          if (v116 != v118) {
            free(v116);
          }
          if (v114)
          {
            if (v74) {
              goto LABEL_146;
            }
          }
          else
          {
            MEMORY[0x1D25D9CD0](*(void *)&v115[0], 8);
            if (v74) {
              goto LABEL_146;
            }
          }
          uint64_t v19 = v103;
          goto LABEL_57;
        }
        uint64_t v86 = (int64_t *)v116;
        uint64_t v87 = 8 * v117;
        while (1)
        {
          LODWORD(v74) = 1;
          if (!llvm::AA::isDynamicallyUnique(a1, a4, *v86, (const llvm::Value *)1)) {
            break;
          }
          ++v86;
          v87 -= 8;
          if (!v87)
          {
            if (!v117) {
              goto LABEL_99;
            }
            unsigned int v88 = v116;
            unsigned int v89 = v120;
            uint64_t v74 = 8 * v117;
            do
            {
              if (v89 >= v121) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              unint64_t v90 = &v119[16 * v89];
              *(void *)unint64_t v90 = *v88;
              *((void *)v90 + 1) = v17;
              unsigned int v89 = ++v120;
              ++v88;
              v74 -= 8;
            }
            while (v74);
            goto LABEL_100;
          }
        }
      }
      int v47 = 0;
      goto LABEL_138;
    }
    unint64_t v36 = *(void *)(v18 - 96);
    unsigned int v37 = *(unsigned __int8 *)(v36 + 16);
    if (v37 != 21)
    {
      if (v37 < 0x1C)
      {
        if (!*(unsigned char *)(v36 + 16)) {
          v36 |= 2uLL;
        }
      }
      else
      {
        unsigned int v38 = v37 - 33;
        BOOL v25 = v38 > 0x33;
        uint64_t v39 = (1 << v38) & 0x8000000000041;
        if (!v25 && v39 != 0) {
          v36 |= 1uLL;
        }
      }
    }
    uint64_t v114 = v36;
    *(void *)&v115[0] = 0;
    AssumedConstant = llvm::Attributor::getAssumedConstant(a1, (const llvm::IRPosition *)&v114, a4, a9);
    if (v76)
    {
      if (!AssumedConstant) {
        goto LABEL_105;
      }
      int v80 = *((unsigned __int8 *)AssumedConstant + 16);
      if ((v80 - 11) >= 2)
      {
        if (v80 == 16)
        {
          uint64_t v81 = *((unsigned int *)AssumedConstant + 8);
          if (v81 > 0x40)
          {
            int v82 = 0;
            int64_t v83 = (unint64_t)(v81 + 63) >> 6;
            do
            {
              BOOL v25 = v83-- < 1;
              if (v25) {
                break;
              }
              unint64_t v84 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v83);
              v82 += __clz(v84);
            }
            while (!v84);
            int v85 = v81 | 0xFFFFFFC0;
            if ((v81 & 0x3F) == 0) {
              int v85 = 0;
            }
            if (v82 + v85 == v81) {
              goto LABEL_123;
            }
LABEL_116:
            uint64_t v79 = *(void *)(v18 - 64);
          }
          else
          {
            if (*((void *)AssumedConstant + 3)) {
              goto LABEL_116;
            }
LABEL_123:
            uint64_t v79 = *(void *)(v18 - 32);
          }
          if (v120 >= (unint64_t)v121) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v22 = &v119[16 * v120];
        }
        else
        {
LABEL_105:
          if (v120 >= (unint64_t)v121) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v77 = &v119[16 * v120];
          *(void *)uint64_t v77 = *(void *)(v18 - 64);
          *((void *)v77 + 1) = v17;
          unsigned int v78 = v120 + 1;
          unsigned int v120 = v78;
          uint64_t v79 = *(void *)(v18 - 32);
          if (v78 >= v121) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v22 = &v119[16 * v78];
        }
        *(void *)uint64_t v22 = v79;
LABEL_109:
        *((void *)v22 + 1) = v17;
        ++v120;
      }
    }
LABEL_110:
    unsigned int v15 = v120;
    uint64_t v14 = v19;
  }
  while (v120);
  if (v128)
  {
    uint64_t v93 = 24 * v128;
    uint64_t v94 = v127 + 16;
    do
    {
      if (*v94) {
        llvm::Attributor::recordDependence((uint64_t)a1, *((void *)v94 - 1), (uint64_t)a4, 1);
      }
      v94 += 24;
      v93 -= 24;
    }
    while (v93);
  }
  uint64_t v91 = 1;
LABEL_160:
  if (v119 != (char *)v122) {
    free(v119);
  }
  sub_1CD40B1BC(v125[0]);
  if (v123[0] != v124) {
    free(v123[0]);
  }
  if (v127 != (char *)v129) {
    free(v127);
  }
  if ((v126[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v126[1], 8);
  }
  return v91;
}

uint64_t sub_1CC8CA7DC(void *a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  uint64_t v14 = &v16;
  uint64_t v15 = 0;
  if (!*((_DWORD *)a2 + 4))
  {
    unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
    goto LABEL_3;
  }
  sub_1CD41B598((uint64_t)&v14, (uint64_t)(a2 + 1));
  unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
  if (!v15)
  {
LABEL_3:
    uint64_t v4 = v13;
    unsigned int v5 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
    if (v5 < 0x15 || v5 == 24) {
      goto LABEL_9;
    }
  }
  unsigned int v3 = *((_DWORD *)v14 + v3 + 1);
  if ((v3 & 0x80000000) != 0)
  {
LABEL_12:
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = v13;
LABEL_9:
  uint64_t v7 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v3);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = a1[1];
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 >= *(_DWORD *)(v8 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v10 = (void *)(*(void *)v8 + 16 * v9);
  *uint64_t v10 = v7;
  v10[1] = v4;
  ++*(_DWORD *)(v8 + 8);
  uint64_t v11 = 1;
LABEL_13:
  if (v14 != &v16) {
    free(v14);
  }
  return v11;
}

uint64_t sub_1CC8CA900(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v8 = a2;
  uint64_t v10 = *(void *)a1;
  uint64_t v11 = *(void *)(a1 + 8);
  unsigned int v13 = *(unsigned __int8 *)(a2 + 16);
  if (v13 != 21)
  {
    if (v13 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v14 = v13 - 33;
      BOOL v15 = v14 > 0x33;
      uint64_t v16 = (1 << v14) & 0x8000000000041;
      if (!v15 && v16 != 0) {
        a2 |= 1uLL;
      }
    }
  }
  uint64_t v18 = sub_1CC8BA72C(v10, a2, 0, v11, 0, 0, 1);
  if ((a5 & 1) != 0 || (llvm::AbstractAttribute *)v11 != v18)
  {
    uint64_t v21 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v18 + 48))(v18);
    (*(void (**)(uint64_t, void))(*(void *)a4 + 48))(a4, *(unsigned __int8 *)(v21 + 9));
  }
  else
  {
    uint64_t v19 = **(void **)(a1 + 24);
    uint64_t v20 = **(void **)(a1 + 32);
    if (!a3 || !*(void *)(a3 + 40))
    {
      if (*(unsigned __int8 *)(v8 + 16) < 0x1Cu || (a3 = v8, !*(void *)(v8 + 40))) {
        a3 = 0;
      }
    }
    v24[0] = *(void *)(a1 + 16);
    v24[1] = v19;
    void v24[2] = a3;
    v24[3] = v20;
    v24[4] = 0;
    char v25 = 1;
    if (!sub_1CC1620B8(v8, 0, (uint64_t)v24)) {
      (*(void (**)(uint64_t))(*(void *)a4 + 40))(a4);
    }
  }
  uint64_t v22 = *(uint64_t (**)(uint64_t))(*(void *)a4 + 16);

  return v22(a4);
}

void *sub_1CC8CAAE8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CAB2C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8CAB90()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C008, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C008))
  {
    __cxa_guard_release(&qword_1EA61C008);
  }
}

uint64_t sub_1CC8CABE4(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  __int16 v8 = 256;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2620BB0;
  v12[0] = 0;
  char v13 = 0;
  int v11 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  v10[0] = &v11;
  v10[1] = a2;
  void v10[2] = a1;
  v10[3] = v12;
  if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8CAE1C, (uint64_t)v10, a1, 1, &v9))
  {
    if (v13) {
      v7[6]((void **)&v7, v12[9]);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  uint64_t v4 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  BOOL v5 = v4[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v4 + 48))(v4, HIBYTE(v8));
  return v5 ^ (v4[9] != 0);
}

uint64_t *sub_1CC8CAD8C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CADB4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CAE1C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  int v11 = &v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v13 = v10;
    unsigned int v14 = &v16;
    uint64_t v15 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v14, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v13 = v3;
    unsigned int v14 = &v16;
    uint64_t v15 = 0;
  }
  uint64_t v16 = sub_1CD659800((uint64_t)&v13, **(_DWORD **)a1);
  uint64_t v17 = v4;
  if (v14 != &v16) {
    free(v14);
  }
  if (sub_1CD647DEC(&v16))
  {
    BOOL v5 = sub_1CC8BA72C(*(void *)(a1 + 8), v16, v17, *(void *)(a1 + 16), 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v7 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v7 + 16))
    {
      (*(void (**)(uint64_t, void, void))(*(void *)v7 + 72))(v7, *(unsigned __int8 *)(v6 + 9), *(unsigned __int8 *)(v6 + 8));
    }
    else
    {
      *(void *)uint64_t v7 = &unk_1F26275E0;
      *(_WORD *)(v7 + 8) = *(_WORD *)(v6 + 8);
      *(void *)uint64_t v7 = &unk_1F2620BB0;
      *(unsigned char *)(v7 + 16) = 1;
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v11 != &v13) {
    free(v11);
  }
  return v8;
}

void *sub_1CC8CAFF0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CB034(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8CB098@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "nonnull";
  }
  else {
    uint64_t v3 = "may-null";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 7;
  }
  else {
    size_t v4 = 8;
  }
  a2[23] = v4;
  uint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8CB0F0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C010, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C010))
  {
    __cxa_guard_release(&qword_1EA61C010);
  }
}

uint64_t sub_1CC8CB144(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  __int16 v8 = 256;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2620BB0;
  uint64_t v12 = 0;
  v10[0] = 0;
  char v11 = 0;
  v9[0] = &v12;
  v9[1] = a2;
  void v9[2] = a1;
  void v9[3] = v10;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8CB368, (uint64_t)v9, a1))
  {
    if (v11) {
      v7[6]((void **)&v7, v10[9]);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  size_t v4 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  BOOL v5 = v4[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v4 + 48))(v4, HIBYTE(v8));
  return v5 ^ (v4[9] != 0);
}

uint64_t *sub_1CC8CB2D8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CB300(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CB368(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 != 21)
  {
    if (v4 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v5 = v4 - 33;
      BOOL v6 = v5 > 0x33;
      uint64_t v7 = (1 << v5) & 0x8000000000041;
      if (!v6 && v7 != 0)
      {
        uint64_t v3 = 0;
        a2 |= 1uLL;
      }
    }
  }
  char v9 = sub_1CC8BA72C(*(void *)(a1 + 8), a2, v3, *(void *)(a1 + 16), 0, 0, 1);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v11 + 16))
  {
    (*(void (**)(uint64_t, void, void))(*(void *)v11 + 72))(v11, *(unsigned __int8 *)(v10 + 9), *(unsigned __int8 *)(v10 + 8));
  }
  else
  {
    *(void *)uint64_t v11 = &unk_1F26275E0;
    *(_WORD *)(v11 + 8) = *(_WORD *)(v10 + 8);
    *(void *)uint64_t v11 = &unk_1F2620BB0;
    *(unsigned char *)(v11 + 16) = 1;
  }
  uint64_t v12 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);

  return v12();
}

void *sub_1CC8CB4D0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CB514(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8CB578()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C018, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C018))
  {
    __cxa_guard_release(&qword_1EA61C018);
  }
}

uint64_t sub_1CC8CB5CC(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v5 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD648A0C(v4);
  if (v6)
  {
    uint64_t v7 = sub_1CC8BA72C(a2, v6 | 1, 0, a1, 0, 0, 1);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    BOOL v9 = v5[9] == 0;
    (*(void (**)(unsigned char *, void))(*(void *)v5 + 48))(v5, *(unsigned __int8 *)(v8 + 9));
    return v9 ^ (v5[9] != 0);
  }
  else
  {
    uint64_t v11 = *(uint64_t (**)(unsigned char *))(*(void *)v5 + 40);
    return v11(v5);
  }
}

uint64_t *sub_1CC8CB700(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CB728(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8CB790(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CB7D4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8CB838()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C020, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C020))
  {
    __cxa_guard_release(&qword_1EA61C020);
  }
}

uint64_t *sub_1CC8CB88C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CB8B4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8CB91C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CB960(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8CB9C4(uint64_t a1, uint64_t a2)
{
  sub_1CD659A60((void *)a1, a2);
  unint64_t result = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  do
  {
    int64_t v5 = result;
    unsigned int v6 = *(unsigned __int8 *)(result + 16);
    if (v6 < 0x1C || v6 - 79 < 0xFFFFFFF3) {
      break;
    }
    unint64_t result = *(void *)(result - 32);
    uint64_t v8 = *(void *)(result + 8);
    if (!v8) {
      break;
    }
  }
  while (!*(void *)(v8 + 8));
  if (*(unsigned char *)(*(void *)v5 + 8) == 15)
  {
    if (v6 == 59) {
      goto LABEL_11;
    }
    if (v6 == 19)
    {
      unint64_t result = sub_1CD6482A0((_DWORD *)(a1 + 16));
      unsigned int v9 = *(_DWORD *)(*(void *)v5 + 8);
      if ((v9 & 0xFE) == 0x12) {
        unsigned int v9 = *(_DWORD *)(**(void **)(*(void *)v5 + 16) + 8);
      }
      if ((!result || (uint64_t v10 = *(void *)(result + 112)) == 0 || (*(unsigned char *)(v10 + 17) & 1) == 0) && v9 <= 0xFF) {
        goto LABEL_11;
      }
    }
    unint64_t result = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    if (v5 != result)
    {
      unsigned int v11 = *(unsigned __int8 *)(v5 + 16);
      if (v11 != 21)
      {
        if (v11 < 0x1C)
        {
          if (!*(unsigned char *)(v5 + 16)) {
            v5 |= 2uLL;
          }
        }
        else
        {
          unsigned int v12 = v11 - 33;
          if (v12 <= 0x33 && ((1 << v12) & 0x8000000000041) != 0) {
            v5 |= 1uLL;
          }
        }
      }
      unint64_t result = (unint64_t)sub_1CC8BAC64(a2, v5, 0, a1, 1, 0, 1);
      if (*(unsigned char *)(result + 40)) {
LABEL_11:
      }
        *(unsigned char *)(a1 + 40) = *(unsigned char *)(a1 + 41);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  return result;
}

void *sub_1CC8CBB28@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "noalias";
  }
  else {
    uint64_t v3 = "may-alias";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 7;
  }
  else {
    size_t v4 = 9;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8CBB84()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C028, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C028))
  {
    __cxa_guard_release(&qword_1EA61C028);
  }
}

uint64_t sub_1CC8CBBD8(uint64_t a1)
{
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  return 0;
}

uint64_t *sub_1CC8CBBE8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CBC10(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8CBC78(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CBCBC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8CBD20(uint64_t a1, uint64_t a2)
{
  sub_1CD659A60((void *)a1, a2);
  unsigned int v4 = 69;
  BOOL result = llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), &v4, 1, 0, 0);
  if (result) {
    *(unsigned char *)(a1 + 40) = *(unsigned char *)(a1 + 41);
  }
  return result;
}

void sub_1CC8CBD78()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C030, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C030))
  {
    __cxa_guard_release(&qword_1EA61C030);
  }
}

unint64_t sub_1CC8CBDCC(unsigned char *a1, uint64_t a2)
{
  unsigned int v4 = (uint64_t *)(a1 + 16);
  unint64_t v5 = sub_1CD659BC0((llvm::IRPosition *)(a1 + 16));
  if (*((unsigned char *)sub_1CC8B4D90(a2, v5, v6, (uint64_t)a1, 1, 0, 1) + 41)
    || sub_1CC8AAAB0(a2, v4, (uint64_t)a1, 0, &v10))
  {
    return sub_1CC8CBF58((uint64_t)a1, a2);
  }
  else
  {
    unint64_t result = llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8CC2D4, (uint64_t)&v8, (uint64_t)a1, 1, &v9);
    if (result) {
      return sub_1CC8CBF58((uint64_t)a1, a2);
    }
    else {
      a1[41] = a1[40];
    }
  }
  return result;
}

uint64_t *sub_1CC8CBEC8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CBEF0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CBF58(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  __int16 v8 = 256;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2620BB0;
  v12[0] = 0;
  char v13 = 0;
  int v11 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  v10[0] = &v11;
  v10[1] = a2;
  void v10[2] = a1;
  v10[3] = v12;
  if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8CC100, (uint64_t)v10, a1, 1, &v9))
  {
    if (v13) {
      v7[6]((void **)&v7, v12[9]);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  unsigned int v4 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  BOOL v5 = v4[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v4 + 48))(v4, HIBYTE(v8));
  return v5 ^ (v4[9] != 0);
}

uint64_t sub_1CC8CC100(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  int v11 = &v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v13 = v10;
    unsigned int v14 = &v16;
    uint64_t v15 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v14, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v13 = v3;
    unsigned int v14 = &v16;
    uint64_t v15 = 0;
  }
  uint64_t v16 = sub_1CD659800((uint64_t)&v13, **(_DWORD **)a1);
  uint64_t v17 = v4;
  if (v14 != &v16) {
    free(v14);
  }
  if (sub_1CD647DEC(&v16))
  {
    BOOL v5 = sub_1CC8BAC64(*(void *)(a1 + 8), v16, v17, *(void *)(a1 + 16), 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v7 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v7 + 16))
    {
      (*(void (**)(uint64_t, void, void))(*(void *)v7 + 72))(v7, *(unsigned __int8 *)(v6 + 9), *(unsigned __int8 *)(v6 + 8));
    }
    else
    {
      *(void *)uint64_t v7 = &unk_1F26275E0;
      *(_WORD *)(v7 + 8) = *(_WORD *)(v6 + 8);
      *(void *)uint64_t v7 = &unk_1F2620BB0;
      *(unsigned char *)(v7 + 16) = 1;
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v11 != &v13) {
    free(v11);
  }
  return v8;
}

BOOL sub_1CC8CC2D4(uint64_t a1, uint64_t a2)
{
  int v2 = 0;
  uint64_t v4 = &v6;
  uint64_t v5 = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)&v4, a2 + 8);
    int v2 = v5;
    if (v4 != &v6) {
      free(v4);
    }
  }
  return v2 == 0;
}

void *sub_1CC8CC344(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CC388(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8CC3EC(uint64_t a1, uint64_t a2)
{
  sub_1CD659A60((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8CC45C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C038, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C038))
  {
    __cxa_guard_release(&qword_1EA61C038);
  }
}

uint64_t sub_1CC8CC4B0(uint64_t a1, uint64_t a2)
{
  v4[0] = a2;
  v4[1] = a1;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8CC5A4, (uint64_t)v4, a1)) {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  return result;
}

uint64_t *sub_1CC8CC514(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CC53C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8CC5A4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 > 0x14) {
    goto LABEL_2;
  }
  if (v5 == 16)
  {
    uint64_t v12 = *(unsigned int *)(a2 + 32);
    if (v12 >= 0x41)
    {
      int v14 = 0;
      int64_t v15 = (unint64_t)(v12 + 63) >> 6;
      do
      {
        BOOL v7 = v15-- < 1;
        if (v7) {
          break;
        }
        unint64_t v16 = *(void *)(*(void *)(a2 + 24) + 8 * v15);
        v14 += __clz(v16);
      }
      while (!v16);
      int v17 = v12 | 0xFFFFFFC0;
      if ((v12 & 0x3F) == 0) {
        int v17 = 0;
      }
      if (v14 + v17 != v12) {
        return 0;
      }
    }
    else if (*(void *)(a2 + 24))
    {
      return 0;
    }
  }
  else
  {
    if (v5 == 17)
    {
      if (sub_1CB844168(a2, 0.0)) {
        return 1;
      }
      unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
    }
    else if (v5 - 18 < 3 || v5 == 13)
    {
      return 1;
    }
    if (v5 - 11 >= 2)
    {
LABEL_2:
      if (v5 >= 0x1C)
      {
        unsigned int v6 = v5 - 33;
        BOOL v7 = v6 > 0x33;
        uint64_t v8 = (1 << v6) & 0x8000000000041;
        if (!v7 && v8 != 0)
        {
          uint64_t v10 = a2 | 1;
          if (*((unsigned char *)sub_1CC8BAC64(*a1, v10, 0, v4, 0, 0, 1) + 41)) {
            return (~*((unsigned __int16 *)sub_1CC8BB6D4(*a1, v10, 0, v4, 0, 0, 1) + 21) & 3) == 0;
          }
        }
      }
      return 0;
    }
  }
  return 1;
}

void *sub_1CC8CC714(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CC758(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8CC7BC(uint64_t a1, uint64_t a2)
{
  sub_1CD659A60((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8CC82C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C040, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C040))
  {
    __cxa_guard_release(&qword_1EA61C040);
  }
}

uint64_t sub_1CC8CC880(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  unsigned int v5 = sub_1CC8BAC64(a2, v4 | 1, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned char *)(v3 + 9) == 0;
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 ^ (*(unsigned char *)(v3 + 9) != 0);
}

uint64_t *sub_1CC8CC938(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CC960(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8CC9C8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CCA0C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8CCA70(unsigned char *a1)
{
  int v2 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v3 = *((void *)a1 + 2) & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*((_DWORD *)a1 + 4) & 3) == 0) {
    unint64_t v3 = *(void *)(v3 + 24);
  }
  int v4 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  if (llvm::CallBase::paramHasAttr(v3, v4, 19)) {
    a1[40] = a1[41];
  }
  unint64_t result = sub_1CD6482F0(v2);
  if (*(unsigned char *)(result + 16) == 19)
  {
    unint64_t v6 = result;
    unint64_t result = sub_1CD6482A0(v2);
    unsigned int v7 = *(_DWORD *)(*(void *)v6 + 8);
    if ((v7 & 0xFE) == 0x12) {
      unsigned int v7 = *(_DWORD *)(**(void **)(*(void *)v6 + 16) + 8);
    }
    if ((!result || (uint64_t v8 = *(void *)(result + 112)) == 0 || (*(unsigned char *)(v8 + 17) & 1) == 0) && v7 <= 0xFF) {
      a1[40] = a1[41];
    }
  }
  return result;
}

void sub_1CC8CCB44()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C048, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C048))
  {
    __cxa_guard_release(&qword_1EA61C048);
  }
}

uint64_t sub_1CC8CCB98(uint64_t a1, llvm::Attributor *a2)
{
  int v4 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v5 = sub_1CC8B2D1C((uint64_t)a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 2, 0, 1);
  if ((~*((unsigned __int8 *)v5 + 41) & 3) != 0)
  {
    unint64_t v7 = sub_1CD6482F0(v4);
    uint64_t v8 = v7;
    unsigned int v9 = *(unsigned __int8 *)(v7 + 16);
    if (v9 != 21)
    {
      if (v9 < 0x1C)
      {
        if (!*(unsigned char *)(v7 + 16)) {
          uint64_t v8 = v7 | 2;
        }
      }
      else
      {
        unsigned int v10 = v9 - 33;
        BOOL v11 = v10 > 0x33;
        uint64_t v12 = (1 << v10) & 0x8000000000041;
        if (!v11 && v12 != 0) {
          uint64_t v8 = v7 | 1;
        }
      }
    }
    int v14 = sub_1CC8BAC64((uint64_t)a2, v8, 0, a1, 2, 0, 1);
    if (!*((unsigned char *)v14 + 41))
    {
LABEL_13:
      uint64_t v6 = 0;
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
      return v6;
    }
    v47[0] = a2;
    v47[1] = a1;
    llvm::Attributor::recordDependence((uint64_t)a2, (uint64_t)v14, a1, 1);
    unint64_t v16 = sub_1CD6482F0(v4);
    uint64_t v17 = v16;
    unsigned int v18 = *(unsigned __int8 *)(v16 + 16);
    if (v18 != 21)
    {
      if (v18 < 0x1C)
      {
        if (!*(unsigned char *)(v16 + 16)) {
          uint64_t v17 = v16 | 2;
        }
      }
      else
      {
        unsigned int v19 = v18 - 33;
        if (v19 <= 0x33 && ((1 << v19) & 0x8000000000041) != 0) {
          uint64_t v17 = v16 | 1;
        }
      }
    }
    unint64_t v20 = v17 & 0xFFFFFFFFFFFFFFFCLL;
    if ((~(_BYTE)v17 & 3) == 0) {
      unint64_t v20 = *(void *)(v20 + 24);
    }
    unsigned int v21 = *(unsigned __int8 *)(v20 + 16);
    if (*(unsigned char *)(v20 + 16))
    {
      if (v21 == 21)
      {
        uint64_t v22 = (unint64_t *)(v20 + 24);
LABEL_29:
        unint64_t v20 = *v22;
        goto LABEL_31;
      }
      if (v21 >= 0x1C)
      {
        uint64_t v22 = (unint64_t *)(*(void *)(v20 + 40) + 56);
        goto LABEL_29;
      }
      unint64_t v20 = 0;
    }
LABEL_31:
    unint64_t v46 = v20;
    unsigned int v23 = sub_1CC8BB6D4((uint64_t)a2, v17, 0, a1, 2, 0, 1);
    v45[0] = a1;
    v45[1] = &v46;
    v45[2] = a2;
    v45[3] = v47;
    if ((~*((unsigned __int16 *)v23 + 21) & 3) != 0)
    {
      unint64_t v42 = sub_1CD6482F0(v4);
      if (!llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8CD0E0, (uint64_t)v45, (const llvm::AbstractAttribute *)a1, v42, 0, 1, 1, 0, v43))goto LABEL_13; {
    }
      }
    llvm::Attributor::recordDependence((uint64_t)a2, (uint64_t)v23, a1, 1);
    unint64_t v24 = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
    if ((~*(_DWORD *)(a1 + 16) & 3) == 0) {
      unint64_t v24 = *(void *)(v24 + 24);
    }
    uint64_t v25 = 0;
    unint64_t v26 = 0;
    uint64_t v44 = (unint64_t *)(v24 - 8);
    while (1)
    {
      int v27 = *(unsigned __int8 *)(v24 + 16);
      if (v27 == 84)
      {
        uint64_t v28 = 0;
      }
      else if (v27 == 39)
      {
        uint64_t v28 = (*(_DWORD *)(v24 + 80) + 1);
      }
      else
      {
        uint64_t v28 = 2;
      }
      int v29 = *(_DWORD *)(v24 + 20);
      if (v29 < 0 && (uint64_t v41 = v29 & 0x7FFFFFF, (v44[-4 * v41] & 0xFFFFFFFF0) != 0))
      {
        uint64_t v31 = -v41;
        int v30 = *(_DWORD *)(v24 - 32 * v41 - 12) - *(_DWORD *)(v24 - 32 * v41 - *(void *)(v24 - 32 * v41 - 8));
      }
      else
      {
        int v30 = 0;
        uint64_t v31 = -(uint64_t)(v29 & 0x7FFFFFF);
      }
      if (v26 >= ((-32 - 32 * v28 + 32 * (unint64_t)-v30 - 32 * v31) >> 5)) {
        return 1;
      }
      if (v26 != sub_1CD64DE00(v4, 1))
      {
        int v32 = *(_DWORD *)(v24 + 20);
        unint64_t v33 = v24 - 32 * (v32 & 0x7FFFFFF);
        uint64_t v34 = *(void *)(v33 + v25);
        int v35 = (*(_DWORD *)(*(void *)v34 + 8) & 0xFE) == 0x12
            ? *(unsigned __int8 *)(**(void **)(*(void *)v34 + 16) + 8)
            : *(_DWORD *)(*(void *)v34 + 8);
        if (v35 == 15)
        {
          if ((v32 & 0x40000000) != 0) {
            unint64_t v33 = *v44;
          }
          unint64_t v36 = sub_1CC8B2D1C((uint64_t)a2, (v25 + v33) | 3, 0, a1, 2, 0, 1);
          int v37 = *((unsigned __int8 *)v36 + 41);
          if ((~v37 & 3) != 0)
          {
            if ((v37 & 2) == 0 || (*((unsigned char *)v5 + 41) & 2) == 0)
            {
              uint64_t v39 = *((void *)a2 + 11);
              unint64_t v40 = sub_1CD6482A0(v4);
              if (**(void **)(v39 + 440) && *(void *)(v40 + 40)) {
                llvm::AnalysisManager<llvm::Function>::getResultImpl();
              }
              goto LABEL_13;
            }
            unsigned int v38 = v36;
            llvm::Attributor::recordDependence((uint64_t)a2, (uint64_t)v5, a1, 1);
            unint64_t v36 = v38;
          }
          llvm::Attributor::recordDependence((uint64_t)a2, (uint64_t)v36, a1, 1);
        }
      }
      ++v26;
      v25 += 32;
    }
  }
  uint64_t v6 = 1;
  llvm::Attributor::recordDependence((uint64_t)a2, (uint64_t)v5, a1, 1);
  return v6;
}

uint64_t *sub_1CC8CD050(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CD078(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CD0E0(uint64_t a1, unint64_t a2, unsigned char *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)a1;
  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v8 = (_DWORD *)(*(void *)a1 + 16);
  if (v7 == sub_1CC8AB830(v8) && (*(_DWORD *)(v7 + 20) & 0x7FFFFFF) == 1) {
    return 1;
  }
  if (!**(void **)(a1 + 8)) {
    goto LABEL_23;
  }
  int v9 = *(unsigned __int8 *)(v7 + 16);
  if ((v9 - 33) > 0x33 || ((1 << (v9 - 33)) & 0x8000000000041) == 0) {
    goto LABEL_17;
  }
  int v11 = *(_DWORD *)(v7 + 20);
  unint64_t v12 = v7 - 32 * (v11 & 0x7FFFFFF);
  if (v12 > a2) {
    goto LABEL_17;
  }
  if (v9 == 84) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = v9 == 39 ? (*(_DWORD *)(v7 + 80) + 1) : 2;
  }
  if (v11 < 0 && (uint64_t v22 = *(void *)(v12 - 8), (v22 & 0xFFFFFFFF0) != 0)) {
    uint64_t v14 = (*(_DWORD *)(v12 - 12) - *(_DWORD *)(v12 - v22));
  }
  else {
    uint64_t v14 = 0;
  }
  if (v7 - 32 * v13 - 32 * v14 - 32 <= a2) {
    goto LABEL_17;
  }
  unint64_t v15 = a2 - v12;
  if ((v11 & 0x40000000) != 0) {
    unint64_t v12 = *(void *)(v7 - 8);
  }
  uint64_t v16 = 1;
  if ((~*((unsigned __int16 *)sub_1CC8BB6D4(*(void *)(a1 + 16), (v12 + (v15 & 0x1FFFFFFFE0)) | 3, 0, v6, 1, 0, 1)
         + 21) & 7) != 0)
  {
LABEL_17:
    uint64_t v17 = *(void *)(a1 + 16);
    unint64_t v18 = sub_1CC8AB830(v8);
    unint64_t v24 = 0;
    int isPotentiallyReachable = llvm::AA::isPotentiallyReachable(v17, v7, v18, v6, (uint64_t)v23);
    if (v24 == v23)
    {
      (*(void (**)(void *))(v23[0] + 32))(v23);
      if (!isPotentiallyReachable) {
        return 1;
      }
    }
    else
    {
      if (v24) {
        (*(void (**)(void))(*v24 + 40))();
      }
      if (!isPotentiallyReachable) {
        return 1;
      }
    }
LABEL_23:
    int v20 = llvm::DetermineUseCaptureKind(a2, (uint64_t (*)(uint64_t, llvm::Value *, uint64_t))sub_1CC8CD350, *(void *)(a1 + 24));
    if (v20)
    {
      if (v20 != 2) {
        return 0;
      }
      uint64_t v16 = 1;
      *a3 = 1;
      return v16;
    }
    return 1;
  }
  return v16;
}

BOOL sub_1CC8CD350(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 != 21)
  {
    if (v5 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v6 = v5 - 33;
      BOOL v7 = v6 > 0x33;
      uint64_t v8 = (1 << v6) & 0x8000000000041;
      if (!v7 && v8 != 0) {
        a2 |= 1uLL;
      }
    }
  }
  return *((_DWORD *)sub_1CC8BB19C(v2, a2, 0, v3, 1, 0, 1) + 13) != 0;
}

void *sub_1CC8CD3D0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CD414(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CD478(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 120))();
}

void *sub_1CC8CD49C@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "[priv]";
  }
  else {
    uint64_t v3 = "[no-priv]";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 9;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8CD4F8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C050, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C050))
  {
    __cxa_guard_release(&qword_1EA61C050);
  }
}

uint64_t sub_1CC8CD550(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t sub_1CC8CD55C(uint64_t a1)
{
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 56)) {
    *(unsigned char *)(a1 + 56) = 1;
  }
  *(void *)(a1 + 48) = 0;
  return 0;
}

llvm *sub_1CC8CD580(uint64_t a1, uint64_t a2)
{
  size_t v4 = (llvm *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  unint64_t result = llvm::getUnderlyingObject(v4, (const llvm::Value *)6);
  if (result)
  {
    int v6 = *((unsigned __int8 *)result + 16);
    if (v6 != 21)
    {
      if (v6 != 59) {
        return 0;
      }
      uint64_t v7 = *((void *)result - 4);
      if (!v7 || *(unsigned char *)(v7 + 16) != 16) {
        return 0;
      }
      uint64_t v9 = *(unsigned int *)(v7 + 32);
      if (v9 > 0x40)
      {
        int v11 = 0;
        int64_t v12 = (unint64_t)(v9 + 63) >> 6;
        do
        {
          if (v12-- < 1) {
            break;
          }
          unint64_t v14 = *(void *)(*(void *)(v7 + 24) + 8 * v12);
          v11 += __clz(v14);
        }
        while (!v14);
        int v15 = v9 | 0xFFFFFFC0;
        if ((v9 & 0x3F) == 0) {
          int v15 = 0;
        }
        if (v11 + v15 != v9 - 1) {
          return 0;
        }
      }
      else if (*(void *)(v7 + 24) != 1)
      {
        return 0;
      }
      return (llvm *)*((void *)result + 8);
    }
    unsigned int v10 = sub_1CC8BBC0C(a2, (uint64_t)result, 0, a1, 0, 0, 1);
    if (*((unsigned char *)v10 + 41)) {
      return (llvm *)(*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 112))(v10);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t *sub_1CC8CD6C8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CD6F0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CD758(uint64_t a1)
{
  *(unsigned char *)(a1 + 9) = *(unsigned char *)(a1 + 8);
  if (!*(unsigned char *)(a1 + 24)) {
    *(unsigned char *)(a1 + 24) = 1;
  }
  *(void *)(a1 + 16) = 0;
  return 0;
}

void *sub_1CC8CD77C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CD7C0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CD824(uint64_t a1, uint64_t a2)
{
  v31[16] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 56)) {
    return 1;
  }
  int v29 = v31;
  uint64_t v30 = 0x1000000000;
  v27[0] = &v29;
  LODWORD(v21[0]) = 56;
  uint64_t v2 = 1;
  unint64_t v18 = v21;
  uint64_t v19 = 1;
  int v6 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v7 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8CE1BC, (uint64_t)v27, v7, a1, (uint64_t)&v18, &v17, 0, 0))
  {
    unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument(v6);
    uint64_t v9 = AssociatedArgument;
    unsigned int v10 = *(unsigned __int8 *)(AssociatedArgument + 16);
    if (v10 != 21)
    {
      if (v10 < 0x1C)
      {
        if (!*(unsigned char *)(AssociatedArgument + 16))
        {
          uint64_t v12 = AssociatedArgument | 2;
          goto LABEL_15;
        }
      }
      else
      {
        unsigned int v11 = v10 - 33;
        if (v11 <= 0x33 && ((1 << v11) & 0x8000000000041) != 0)
        {
          uint64_t v12 = AssociatedArgument | 1;
LABEL_15:
          BOOL v13 = 1;
          unint64_t v14 = sub_1CC8BA1F4(a2, v12, 0, a1, 2, 0, 1);
          *(void *)&long long v23 = a1;
          *((void *)&v23 + 1) = v9;
          unint64_t v24 = v26;
          uint64_t v25 = 0x1000000000;
          if (v30)
          {
            llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)&v24, (uint64_t)&v29);
            BOOL v13 = v25 == 0;
          }
          int v15 = (char *)operator new(0xA8uLL);
          *(void *)int v15 = &unk_1F2622E48;
          *(_OWORD *)(v15 + 8) = v23;
          *((void *)v15 + 3) = v15 + 40;
          *((void *)v15 + 4) = 0x1000000000;
          if (!v13) {
            sub_1CD41C56C((uint64_t)(v15 + 24), (uint64_t)&v24);
          }
          uint64_t v28 = v15;
          if (v24 != v26) {
            free(v24);
          }
          v21[0] = &unk_1F2622E90;
          v21[1] = v14;
          void v21[2] = a1;
          uint64_t v22 = v21;
          unint64_t v18 = v20;
          uint64_t v19 = 0x1000000000;
          sub_1CC8CE094(*(void *)(a1 + 48), (uint64_t)&v18);
          int v16 = llvm::Attributor::registerFunctionSignatureRewrite(a2, v9, (uint64_t)v18, v19);
          if (v18 != v20) {
            free(v18);
          }
          if (v22 == v21)
          {
            (*(void (**)(void *))(v21[0] + 32))(v21);
          }
          else if (v22)
          {
            (*(void (**)(void *))(*v22 + 40))(v22);
          }
          uint64_t v2 = v16 ^ 1u;
          if (v28 == v27)
          {
            (*(void (**)(void *))(v27[0] + 32))(v27);
          }
          else if (v28)
          {
            (*(void (**)(void *))(*v28 + 40))(v28);
          }
          goto LABEL_5;
        }
      }
    }
    uint64_t v12 = AssociatedArgument;
    goto LABEL_15;
  }
LABEL_5:
  if (v29 != v31) {
    free(v29);
  }
  return v2;
}

void sub_1CC8CDB94()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C058, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C058))
  {
    __cxa_guard_release(&qword_1EA61C058);
  }
}

uint64_t sub_1CC8CDBE8(uint64_t a1, uint64_t a2)
{
  v21[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = sub_1CC8CDE98(a1, a2);
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 56) = v5;
  if (!(_BYTE)v5) {
    return 1;
  }
  if (v4)
  {
    unint64_t v8 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    uint64_t v9 = v8;
    unsigned int v10 = *(unsigned __int8 *)(v8 + 16);
    if (v10 != 21)
    {
      if (v10 < 0x1C)
      {
        if (!*(unsigned char *)(v8 + 16)) {
          uint64_t v9 = v8 | 2;
        }
      }
      else
      {
        unsigned int v11 = v10 - 33;
        BOOL v12 = v11 > 0x33;
        uint64_t v13 = (1 << v11) & 0x8000000000041;
        if (!v12 && v13 != 0) {
          uint64_t v9 = v8 | 1;
        }
      }
    }
    sub_1CC8BA1F4(a2, v9, 0, a1, 1, 0, 1);
    LODWORD(v20[0]) = 69;
    if (llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), (unsigned int *)v20, 1, 0, 0)
      || (llvm::ArgumentPromotionPass::isDenselyPacked(*(llvm::ArgumentPromotionPass **)(a1 + 48), *(llvm::Type **)(*(void *)(a2 + 88) + 120), v15) & 1) != 0)
    {
      v20[0] = v21;
      v20[1] = (void *)0x1000000000;
      sub_1CC8CE094(*(void *)(a1 + 48), (uint64_t)v20);
      uint64_t v17 = *(void *)(sub_1CD6482A0((_DWORD *)(a1 + 16)) + 40);
      if (**(void **)(*(void *)(a2 + 88) + 440)) {
        BOOL v18 = v17 == 0;
      }
      else {
        BOOL v18 = 1;
      }
      if (!v18) {
        llvm::AnalysisManager<llvm::Function>::getResultImpl();
      }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
      int v19 = *(unsigned __int8 *)(a1 + 56);
      *(void *)(a1 + 48) = 0;
      uint64_t v6 = 0;
      if (!v19) {
        *(unsigned char *)(a1 + 56) = 1;
      }
      if (v20[0] != v21) {
        free(v20[0]);
      }
    }
    else
    {
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
      int v16 = *(unsigned __int8 *)(a1 + 56);
      *(void *)(a1 + 48) = 0;
      uint64_t v6 = 0;
      if (!v16) {
        *(unsigned char *)(a1 + 56) = 1;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
    *(void *)(a1 + 48) = 0;
  }
  return v6;
}

uint64_t sub_1CC8CDE98(uint64_t a1, uint64_t a2)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  unint64_t v14 = v16;
  uint64_t v15 = 0x100000000;
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  LODWORD(v9[0]) = 69;
  llvm::IRPosition::getAttrs((llvm::IRPosition *)(a1 + 16), (unsigned int *)v9, 1, (uint64_t)&v14, 1, 0);
  if (v15
    && llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8CFD04, (uint64_t)v9, a1, 1, &v13))
  {
    unint64_t v7 = v14;
    if (*(void *)v14) {
      uint64_t v6 = *(void *)(*(void *)v14 + 16);
    }
    else {
      uint64_t v6 = 0;
    }
  }
  else
  {
    LOBYTE(v11) = 0;
    LOBYTE(v12) = 0;
    int v10 = sub_1CD64DE00(v4, 0);
    v9[0] = &v10;
    v9[1] = a2;
    void v9[2] = a1;
    void v9[3] = &v11;
    if (llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8CFD68, (uint64_t)v9, a1, 1, &v13))uint64_t v6 = v11; {
    else
    }
      uint64_t v6 = 0;
    unint64_t v7 = v14;
  }
  if (v7 != v16) {
    free(v7);
  }
  return v6;
}

uint64_t *sub_1CC8CE004(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8CE02C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CE094(uint64_t result, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(result + 8);
  if (result && v3 == 16)
  {
    uint64_t v4 = *(unsigned int *)(result + 12);
    if (v4)
    {
      uint64_t v5 = 0;
      unsigned int v6 = *(_DWORD *)(a2 + 8);
      do
      {
        if (v6 >= *(_DWORD *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v6) = *(void *)(*(void *)(result + 16) + v5);
        unsigned int v6 = *(_DWORD *)(a2 + 8) + 1;
        *(_DWORD *)(a2 + 8) = v6;
        v5 += 8;
      }
      while (8 * v4 != v5);
    }
  }
  else if (result && v3 == 17)
  {
    uint64_t v9 = *(void *)(result + 24);
    uint64_t v8 = *(void *)(result + 32);
    return sub_1CC2FCB18(a2, v8, v9);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(a2 + 8);
    if (v7 >= *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v7) = result;
    ++*(_DWORD *)(a2 + 8);
  }
  return result;
}

uint64_t sub_1CC8CE1BC(uint64_t *a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 18) & 3u) - 1 <= 1)
  {
    uint64_t v2 = *a1;
    unsigned int v3 = *(_DWORD *)(*a1 + 8);
    if (v3 >= *(_DWORD *)(*a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v2 + 8 * v3) = a2;
    ++*(_DWORD *)(v2 + 8);
  }
  return 1;
}

void *sub_1CC8CE234(void *a1)
{
  *a1 = &unk_1F2622E48;
  uint64_t v2 = (void *)a1[3];
  if (v2 != a1 + 5) {
    free(v2);
  }
  return a1;
}

void sub_1CC8CE288(void *a1)
{
  *a1 = &unk_1F2622E48;
  uint64_t v2 = (void *)a1[3];
  if (v2 != a1 + 5) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

char *sub_1CC8CE2FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0xA8uLL);
  *(void *)uint64_t v2 = &unk_1F2622E48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *((void *)v2 + 3) = v2 + 40;
  *((void *)v2 + 4) = 0x1000000000;
  if (*(_DWORD *)(a1 + 32)) {
    llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)(v2 + 24), a1 + 24);
  }
  return v2;
}

uint64_t sub_1CC8CE378(uint64_t result, void *a2)
{
  *a2 = &unk_1F2622E48;
  long long v2 = *(_OWORD *)(result + 8);
  a2[3] = a2 + 5;
  uint64_t v3 = (uint64_t)(a2 + 3);
  *(_OWORD *)(v3 - 16) = v2;
  *(void *)(v3 + 8) = 0x1000000000;
  if (*(_DWORD *)(result + 32)) {
    return llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(v3, result + 24);
  }
  return result;
}

void sub_1CC8CE3CC(uint64_t a1)
{
  long long v2 = *(void **)(a1 + 24);
  if (v2 != (void *)(a1 + 40)) {
    free(v2);
  }
}

void sub_1CC8CE3E8(void *__p)
{
  long long v2 = (void *)__p[3];
  if (v2 != __p + 5) {
    free(v2);
  }

  operator delete(__p);
}

void sub_1CC8CE430(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a3 + 80);
  uint64_t v9 = v8 - 24;
  if (!v8) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = v9 + 40;
  for (uint64_t i = *(void *)(v9 + 48); i != v10; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v12 = i - 24;
    if (!i) {
      uint64_t v12 = 0;
    }
    if (*(unsigned char *)(v12 + 16) != 83)
    {
      unsigned int v13 = *(unsigned __int8 *)(i - 8) - 38;
      BOOL v14 = v13 > 0x38;
      uint64_t v15 = (1 << v13) & 0x100060000000001;
      if (v14 || v15 == 0) {
        uint64_t v10 = i;
      }
      else {
        uint64_t v10 = *(void *)(i + 8);
      }
      break;
    }
  }
  if (v10) {
    uint64_t v17 = (llvm::Instruction *)(v10 - 24);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v68 = v17;
  BOOL v18 = (llvm::Type *)*(unsigned int *)(*(void *)(*(void *)(*((void *)v17 + 5) + 56) + 40) + 276);
  int v19 = operator new(0x68uLL);
  int v20 = (llvm::Value *)(v19 + 8);
  v19[13] = v19[13] & 0x38000000 | 1;
  *(void *)int v19 = 0;
  *((void *)v19 + 1) = 0;
  *((void *)v19 + 2) = 0;
  *((void *)v19 + 3) = v19 + 8;
  unsigned int v21 = *(llvm::Type **)(v7 + 48);
  uint64_t v22 = *(uint64_t ****)(a1 + 16);
  if ((*((unsigned char *)v22 + 23) & 0x10) == 0)
  {
    unint64_t v33 = 0;
    int v32 = &byte_1CFBCE98E;
    goto LABEL_27;
  }
  uint64_t v23 = ***v22;
  uint64_t v24 = *(void *)(v23 + 152);
  uint64_t v25 = *(unsigned int *)(v23 + 168);
  if (!v25) {
    goto LABEL_25;
  }
  LODWORD(v26) = (v25 - 1) & ((v22 >> 4) ^ (v22 >> 9));
  int v27 = (uint64_t ****)(v24 + 16 * v26);
  uint64_t v28 = *v27;
  if (*v27 != v22)
  {
    int v29 = 1;
    while (v28 != (uint64_t ***)-4096)
    {
      int v30 = v26 + v29++;
      uint64_t v26 = v30 & (v25 - 1);
      uint64_t v28 = *(uint64_t ****)(v24 + 16 * v26);
      if (v28 == v22)
      {
        int v27 = (uint64_t ****)(v24 + 16 * v26);
        goto LABEL_26;
      }
    }
LABEL_25:
    int v27 = (uint64_t ****)(v24 + 16 * v25);
  }
LABEL_26:
  uint64_t v31 = v27[1];
  uint64_t v34 = *v31;
  int v32 = (char *)(v31 + 2);
  unint64_t v33 = v34;
LABEL_27:
  __int16 v71 = 773;
  v69[0] = v32;
  v69[1] = v33;
  uint64_t v70 = ".priv";
  llvm::AllocaInst::AllocaInst((llvm::AllocaInst *)(v19 + 8), v21, v18, 0, (const char **)v69, v68);
  uint64_t v35 = *(void *)(v7 + 48);
  unsigned int v36 = *(_DWORD *)(v6 + 32);
  sub_1CC8A8E38((uint64_t)v69, (uint64_t **)v68, 0, 0, 0);
  int v37 = (llvm::DataLayout *)(*(void *)(a3 + 40) + 272);
  int v38 = *(unsigned __int8 *)(v35 + 8);
  uint64_t v66 = a1;
  if (v35 && v38 == 16)
  {
    PointerBitCastOrAddrSpaceCast = v20;
    StructLayout = llvm::DataLayout::getStructLayout(v37, (llvm::StructType *)v35);
    uint64_t v42 = *(unsigned int *)(v35 + 12);
    if (v42)
    {
      uint64_t v43 = 0;
      uint64_t v44 = (char *)StructLayout + 16;
      do
      {
        int v45 = (llvm::Value *)llvm::PointerType::get(*(llvm::PointerType **)(*(void *)(v35 + 16) + 8 * v43), 0);
        unint64_t v46 = sub_1CC8CE908(v45, (llvm::Type *)v35, PointerBitCastOrAddrSpaceCast, *(void *)&v44[8 * v43], (uint64_t)v69, v37);
        int v47 = operator new(0x80uLL);
        unsigned int v48 = (llvm::StoreInst *)(v47 + 16);
        v47[21] = v47[21] & 0x38000000 | 2;
        *(void *)int v47 = 0;
        *((void *)v47 + 1) = 0;
        *((void *)v47 + 2) = 0;
        *((void *)v47 + 3) = v47 + 16;
        *((void *)v47 + 4) = 0;
        *((void *)v47 + 5) = 0;
        *((void *)v47 + 6) = 0;
        *((void *)v47 + 7) = v47 + 16;
        if (*(unsigned char *)(a3 + 18)) {
          llvm::Function::BuildLazyArguments((llvm::Function *)a3);
        }
        llvm::StoreInst::StoreInst(v48, (llvm::Type **)(*(void *)(a3 + 88) + 40 * (v36 + v43++)), v46, 0, v68);
      }
      while (v42 != v43);
    }
  }
  else if (v35 && v38 == 17)
  {
    PointerBitCastOrAddrSpaceCast = v20;
    unint64_t v49 = *(llvm::PointerType **)(v35 + 24);
    uint64_t v67 = (llvm::Value *)llvm::PointerType::get(v49, 0);
    uint64_t v51 = sub_1CB83544C((uint64_t)v37, (uint64_t)v49);
    if (v50 == 1) {
    uint64_t v52 = *(unsigned int *)(v35 + 32);
    }
    if (*(_DWORD *)(v35 + 32))
    {
      uint64_t v53 = 0;
      unint64_t v54 = (unint64_t)(v51 + 7) >> 3;
      do
      {
        uint64_t v55 = sub_1CC8CE908(v67, (llvm::Type *)v35, PointerBitCastOrAddrSpaceCast, v53, (uint64_t)v69, v37);
        uint64_t v56 = operator new(0x80uLL);
        uint64_t v57 = (llvm::StoreInst *)(v56 + 16);
        v56[21] = v56[21] & 0x38000000 | 2;
        *(void *)uint64_t v56 = 0;
        *((void *)v56 + 1) = 0;
        *((void *)v56 + 2) = 0;
        *((void *)v56 + 3) = v56 + 16;
        *((void *)v56 + 4) = 0;
        *((void *)v56 + 5) = 0;
        *((void *)v56 + 6) = 0;
        *((void *)v56 + 7) = v56 + 16;
        if (*(unsigned char *)(a3 + 18)) {
          llvm::Function::BuildLazyArguments((llvm::Function *)a3);
        }
        llvm::StoreInst::StoreInst(v57, (llvm::Type **)(*(void *)(a3 + 88) + 40 * v36++), v55, 0, v68);
        v53 += v54;
        --v52;
      }
      while (v52);
    }
  }
  else
  {
    unint64_t v58 = operator new(0x80uLL);
    uint64_t v59 = (llvm::StoreInst *)(v58 + 16);
    v58[21] = v58[21] & 0x38000000 | 2;
    *(void *)unint64_t v58 = 0;
    *((void *)v58 + 1) = 0;
    *((void *)v58 + 2) = 0;
    *((void *)v58 + 3) = v58 + 16;
    *((void *)v58 + 4) = 0;
    *((void *)v58 + 5) = 0;
    *((void *)v58 + 6) = 0;
    *((void *)v58 + 7) = v58 + 16;
    if (*(unsigned char *)(a3 + 18)) {
      llvm::Function::BuildLazyArguments((llvm::Function *)a3);
    }
    PointerBitCastOrAddrSpaceCast = v20;
    llvm::StoreInst::StoreInst(v59, (llvm::Type **)(*(void *)(a3 + 88) + 40 * v36), v20, 0, v68);
  }
  if (v69[0] != &v70) {
    free(v69[0]);
  }
  int v60 = *(llvm::ValueAsMetadata **)(v66 + 16);
  uint64_t v61 = *(llvm::Value **)v60;
  if (*(void *)PointerBitCastOrAddrSpaceCast != *(void *)v60)
  {
    __int16 v71 = 257;
    PointerBitCastOrAddrSpaceCast = llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(PointerBitCastOrAddrSpaceCast, v61, (const char **)v69, v68, v41);
    int v60 = *(llvm::ValueAsMetadata **)(v66 + 16);
  }
  llvm::Value::doRAUW(v60, PointerBitCastOrAddrSpaceCast, (llvm::Value *)1);
  uint64_t v62 = *(unsigned int *)(v66 + 32);
  if (v62)
  {
    int v63 = *(uint64_t **)(v66 + 24);
    uint64_t v64 = 8 * v62;
    do
    {
      uint64_t v65 = *v63++;
      *(_WORD *)(v65 + 18) &= 0xFFFCu;
      v64 -= 8;
    }
    while (v64);
  }
}

llvm::CastInst *sub_1CC8CE908(llvm::Value *a1, llvm::Type *a2, llvm::CastInst *this, uint64_t a4, uint64_t a5, llvm::DataLayout *a6)
{
  PointerBitCastOrAddrSpaceCast = this;
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  if (!a4) {
    goto LABEL_102;
  }
  unint64_t v96 = a2;
  unsigned int v10 = *(_DWORD *)(*(void *)this + 8);
  if ((v10 & 0xFE) == 0x12) {
    unsigned int v10 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  if (v10 < 0x100) {
    goto LABEL_13;
  }
  unsigned int v11 = v10 >> 8;
  uint64_t v12 = *((unsigned int *)a6 + 60);
  uint64_t v13 = *((void *)a6 + 29);
  if (v12)
  {
    uint64_t v13 = *((void *)a6 + 29);
    unint64_t v14 = *((unsigned int *)a6 + 60);
    do
    {
      unint64_t v15 = v14 >> 1;
      uint64_t v16 = v13 + 16 * (v14 >> 1);
      unsigned int v17 = *(_DWORD *)(v16 + 8);
      uint64_t v18 = v16 + 16;
      v14 += ~(v14 >> 1);
      if (v17 < v11) {
        uint64_t v13 = v18;
      }
      else {
        unint64_t v14 = v15;
      }
    }
    while (v14);
  }
  if (v13 == *((void *)a6 + 29) + 16 * v12 || *(_DWORD *)(v13 + 8) != v11) {
LABEL_13:
  }
    uint64_t v13 = *((void *)a6 + 29);
  unsigned int v19 = *(_DWORD *)(v13 + 12);
  unsigned int v95 = v19;
  if (v19 > 0x40) {
    operator new[]();
  }
  if (v19) {
    unint64_t v20 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v19;
  }
  else {
    unint64_t v20 = 0;
  }
  uint64_t v94 = (void *)(v20 & a4);
  llvm::DataLayout::getGEPIndicesForOffset(a6, &v96, (llvm::APInt *)&v94, (uint64_t)&v104);
  uint64_t v100 = v102;
  uint64_t v101 = 0x400000000;
  if ((*((unsigned char *)PointerBitCastOrAddrSpaceCast + 23) & 0x10) == 0)
  {
    std::string::size_type v31 = 0;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
    p_dst = &__dst;
    goto LABEL_33;
  }
  uint64_t v22 = ***(void ***)PointerBitCastOrAddrSpaceCast;
  uint64_t v23 = *(void *)(v22 + 152);
  uint64_t v24 = *(unsigned int *)(v22 + 168);
  if (v24)
  {
    LODWORD(v25) = (v24 - 1) & ((PointerBitCastOrAddrSpaceCast >> 4) ^ (PointerBitCastOrAddrSpaceCast >> 9));
    uint64_t v26 = (llvm::CastInst **)(v23 + 16 * v25);
    int v27 = *v26;
    if (*v26 == PointerBitCastOrAddrSpaceCast) {
      goto LABEL_25;
    }
    int v28 = 1;
    while (v27 != (llvm::CastInst *)-4096)
    {
      int v29 = v25 + v28++;
      uint64_t v25 = v29 & (v24 - 1);
      int v27 = *(llvm::CastInst **)(v23 + 16 * v25);
      if (v27 == PointerBitCastOrAddrSpaceCast)
      {
        uint64_t v26 = (llvm::CastInst **)(v23 + 16 * v25);
        goto LABEL_25;
      }
    }
  }
  uint64_t v26 = (llvm::CastInst **)(v23 + 16 * v24);
LABEL_25:
  int v30 = (unint64_t *)v26[1];
  unint64_t v33 = *v30;
  int v32 = v30 + 2;
  std::string::size_type v31 = v33;
  if (v33 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v31 >= 0x17)
  {
    uint64_t v35 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v31 | 7) != 0x17) {
      uint64_t v35 = v31 | 7;
    }
    uint64_t v36 = v35 + 1;
    p_dst = (std::string *)operator new(v35 + 1);
    __dst.__r_.__value_.__l.__size_ = v31;
    __dst.__r_.__value_.__r.__words[2] = v36 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_32;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v31;
  p_dst = &__dst;
  if (v31) {
LABEL_32:
  }
    memmove(p_dst, v32, v31);
LABEL_33:
  p_dst->__r_.__value_.__s.__data_[v31] = 0;
  if (v105)
  {
    int v37 = v104;
    uint64_t v38 = 16 * v105;
    do
    {
      uint64_t v39 = llvm::ConstantInt::get(*(llvm::ConstantInt **)(a5 + 64), (llvm::LLVMContext *)v37, v21);
      if (v101 >= (unint64_t)HIDWORD(v101)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v100 + v101) = v39;
      LODWORD(v101) = v101 + 1;
      unint64_t v40 = (unint64_t *)v37;
      if (*((_DWORD *)v37 + 2) >= 0x41u) {
        unint64_t v40 = *(unint64_t **)v37;
      }
      std::to_string(&v91, *v40);
      uint64_t v41 = std::string::insert(&v91, 0, ".");
      uint64_t v42 = (uint64_t *)v41->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
      int v98 = v42;
      v41->__r_.__value_.__l.__size_ = 0;
      v41->__r_.__value_.__r.__words[2] = 0;
      v41->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v98) >= 0) {
        uint64_t v43 = __p;
      }
      else {
        uint64_t v43 = (void **)__p[0];
      }
      if (SHIBYTE(v98) >= 0) {
        std::string::size_type v44 = HIBYTE(v98) & 0x7F;
      }
      else {
        std::string::size_type v44 = (std::string::size_type)__p[1];
      }
      std::string::append(&__dst, (const std::string::value_type *)v43, v44);
      if (SHIBYTE(v98) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v91.__r_.__value_.__l.__data_);
      }
      v37 += 16;
      v38 -= 16;
    }
    while (v38);
  }
  __int16 v99 = 260;
  __p[0] = &__dst;
  PointerBitCastOrAddrSpaceCast = (llvm::CastInst *)sub_1CC27CEC0((uint64_t *)a5, (uint64_t)a2, (uint64_t *)PointerBitCastOrAddrSpaceCast, (uint64_t *)v100, v101, (uint64_t)__p);
  int v45 = v94;
  if (v95 >= 0x41)
  {
    int v46 = 0;
    int64_t v47 = ((unint64_t)v95 + 63) >> 6;
    do
    {
      if (v47-- < 1) {
        break;
      }
      unint64_t v49 = v94[v47];
      v46 += __clz(v49);
    }
    while (!v49);
    unsigned int v50 = v95 | 0xFFFFFFC0;
    if ((v95 & 0x3F) == 0) {
      unsigned int v50 = 0;
    }
    if (v95 - v46 - v50 > 0x40) {
      goto LABEL_60;
    }
    int v45 = (void *)*v94;
  }
  if (v45)
  {
LABEL_60:
    unint64_t v51 = llvm::PointerType::get((llvm::PointerType *)(**(void **)(a5 + 64) + 1912), 0);
    __int16 v92 = 257;
    if (*(void *)PointerBitCastOrAddrSpaceCast != v51)
    {
      if (*((unsigned __int8 *)PointerBitCastOrAddrSpaceCast + 16) <= 0x14u)
      {
        PointerBitCastOrAddrSpaceCast = (llvm::CastInst *)(*(uint64_t (**)(void, uint64_t, llvm::CastInst *, unint64_t))(**(void **)(a5 + 72) + 224))(*(void *)(a5 + 72), 49, PointerBitCastOrAddrSpaceCast, v51);
        if (PointerBitCastOrAddrSpaceCast) {
          BOOL v56 = *((unsigned __int8 *)PointerBitCastOrAddrSpaceCast + 16) >= 0x1Cu;
        }
        else {
          BOOL v56 = 0;
        }
        if (v56)
        {
          (*(void (**)(void, llvm::CastInst *, std::string *, void, void))(**(void **)(a5 + 80) + 16))(*(void *)(a5 + 80), PointerBitCastOrAddrSpaceCast, &v91, *(void *)(a5 + 48), *(void *)(a5 + 56));
          uint64_t v87 = *(unsigned int *)(a5 + 8);
          if (v87)
          {
            uint64_t v88 = *(void *)a5;
            uint64_t v89 = *(void *)a5 + 16 * v87;
            do
            {
              llvm::Instruction::setMetadata(PointerBitCastOrAddrSpaceCast, *(_DWORD *)v88, *(llvm::MDNode **)(v88 + 8));
              v88 += 16;
            }
            while (v88 != v89);
          }
        }
      }
      else
      {
        __int16 v99 = 257;
        PointerBitCastOrAddrSpaceCast = llvm::CastInst::Create(49, (uint64_t)PointerBitCastOrAddrSpaceCast, v51, (const char **)__p, 0);
        (*(void (**)(void, llvm::CastInst *, std::string *, void, void))(**(void **)(a5 + 80) + 16))(*(void *)(a5 + 80), PointerBitCastOrAddrSpaceCast, &v91, *(void *)(a5 + 48), *(void *)(a5 + 56));
        uint64_t v53 = *(unsigned int *)(a5 + 8);
        if (v53)
        {
          uint64_t v54 = *(void *)a5;
          uint64_t v55 = *(void *)a5 + 16 * v53;
          do
          {
            llvm::Instruction::setMetadata(PointerBitCastOrAddrSpaceCast, *(_DWORD *)v54, *(llvm::MDNode **)(v54 + 8));
            v54 += 16;
          }
          while (v54 != v55);
        }
      }
    }
    uint64_t v57 = *(llvm::ConstantInt **)(a5 + 64);
    uint64_t v58 = *(void *)v57 + 1912;
    uint64_t v59 = (const char *)llvm::ConstantInt::get(v57, (llvm::LLVMContext *)&v94, v52);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __dst.__r_.__value_.__l.__size_;
    }
    sub_1CB907098((uint64_t)&v91, size + 2);
    if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v61 = &v91;
    }
    else {
      uint64_t v61 = (std::string *)v91.__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v62 = &__dst;
      }
      else {
        uint64_t v62 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      memmove(v61, v62, size);
    }
    strcpy((char *)v61 + size, ".b");
    if (v95 >= 0x41) {
      int v63 = v94;
    }
    else {
      int v63 = (uint64_t *)&v94;
    }
    uint64_t v90 = *v63;
    __p[0] = &v91;
    int v98 = &v90;
    __int16 v99 = 3076;
    PointerBitCastOrAddrSpaceCast = sub_1CB930F7C((uint64_t *)a5, v58, (uint64_t *)PointerBitCastOrAddrSpaceCast, v59, (uint64_t)__p);
    if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v91.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v100 != v102) {
    free(v100);
  }
  uint64_t v64 = v104;
  if (v105)
  {
    uint64_t v65 = 16 * v105;
    do
    {
      if (*(_DWORD *)&v64[v65 - 8] >= 0x41u)
      {
        uint64_t v66 = *(void *)&v64[v65 - 16];
        if (v66) {
          MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
        }
      }
      v65 -= 16;
    }
    while (v65);
    uint64_t v64 = v104;
  }
  if (v64 != (char *)v106) {
    free(v64);
  }
  if (v95 >= 0x41 && v94) {
    MEMORY[0x1D25D9CB0](v94, 0x1000C8000313F17);
  }
LABEL_102:
  if ((*((unsigned char *)PointerBitCastOrAddrSpaceCast + 23) & 0x10) != 0)
  {
    uint64_t v67 = ***(void ***)PointerBitCastOrAddrSpaceCast;
    uint64_t v68 = *(void *)(v67 + 152);
    uint64_t v69 = *(unsigned int *)(v67 + 168);
    if (v69)
    {
      LODWORD(v70) = (v69 - 1) & ((PointerBitCastOrAddrSpaceCast >> 4) ^ (PointerBitCastOrAddrSpaceCast >> 9));
      __int16 v71 = (llvm::CastInst **)(v68 + 16 * v70);
      uint64_t v72 = *v71;
      if (*v71 == PointerBitCastOrAddrSpaceCast)
      {
LABEL_110:
        uint64_t v75 = v71[1];
        uint64_t v78 = *(void *)v75;
        char v76 = (char *)v75 + 16;
        uint64_t v77 = v78;
        goto LABEL_111;
      }
      int v73 = 1;
      while (v72 != (llvm::CastInst *)-4096)
      {
        int v74 = v70 + v73++;
        uint64_t v70 = v74 & (v69 - 1);
        uint64_t v72 = *(llvm::CastInst **)(v68 + 16 * v70);
        if (v72 == PointerBitCastOrAddrSpaceCast)
        {
          __int16 v71 = (llvm::CastInst **)(v68 + 16 * v70);
          goto LABEL_110;
        }
      }
    }
    __int16 v71 = (llvm::CastInst **)(v68 + 16 * v69);
    goto LABEL_110;
  }
  uint64_t v77 = 0;
  char v76 = &byte_1CFBCE98E;
LABEL_111:
  __int16 v103 = 773;
  uint64_t v100 = v76;
  uint64_t v101 = v77;
  v102[0] = ".cast";
  if (*(llvm::Value **)PointerBitCastOrAddrSpaceCast != a1)
  {
    if (*((unsigned __int8 *)PointerBitCastOrAddrSpaceCast + 16) <= 0x14u)
    {
      PointerBitCastOrAddrSpaceCast = (llvm::CastInst *)(*(uint64_t (**)(void, llvm::CastInst *, llvm::Value *))(**(void **)(a5 + 72) + 240))(*(void *)(a5 + 72), PointerBitCastOrAddrSpaceCast, a1);
      if (PointerBitCastOrAddrSpaceCast) {
        BOOL v83 = *((unsigned __int8 *)PointerBitCastOrAddrSpaceCast + 16) >= 0x1Cu;
      }
      else {
        BOOL v83 = 0;
      }
      if (v83)
      {
        (*(void (**)(void, llvm::CastInst *, void **, void, void))(**(void **)(a5 + 80) + 16))(*(void *)(a5 + 80), PointerBitCastOrAddrSpaceCast, &v100, *(void *)(a5 + 48), *(void *)(a5 + 56));
        uint64_t v84 = *(unsigned int *)(a5 + 8);
        if (v84)
        {
          uint64_t v85 = *(void *)a5;
          uint64_t v86 = v85 + 16 * v84;
          do
          {
            llvm::Instruction::setMetadata(PointerBitCastOrAddrSpaceCast, *(_DWORD *)v85, *(llvm::MDNode **)(v85 + 8));
            v85 += 16;
          }
          while (v85 != v86);
        }
      }
    }
    else
    {
      v106[8] = 257;
      PointerBitCastOrAddrSpaceCast = llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(PointerBitCastOrAddrSpaceCast, a1, (const char **)&v104, 0, (llvm::Instruction *)a5);
      (*(void (**)(void, llvm::CastInst *, void **, void, void))(**(void **)(a5 + 80) + 16))(*(void *)(a5 + 80), PointerBitCastOrAddrSpaceCast, &v100, *(void *)(a5 + 48), *(void *)(a5 + 56));
      uint64_t v79 = *(unsigned int *)(a5 + 8);
      if (v79)
      {
        uint64_t v81 = *(void *)a5;
        uint64_t v82 = v81 + 16 * v79;
        do
        {
          llvm::Instruction::setMetadata(PointerBitCastOrAddrSpaceCast, *(_DWORD *)v81, *(llvm::MDNode **)(v81 + 8));
          v81 += 16;
        }
        while (v81 != v82);
      }
    }
  }
  return PointerBitCastOrAddrSpaceCast;
}

void sub_1CC8CF258()
{
}

__n128 sub_1CC8CF26C(uint64_t a1)
{
  long long v2 = (char *)operator new(0x18uLL);
  *(void *)long long v2 = &unk_1F2622E90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CC8CF2B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2622E90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_1CC8CF2E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v60[15] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(llvm::Twine **)a3;
  uint64_t v52 = *(llvm::Twine **)a3;
  uint64_t v53 = &v55;
  uint64_t v54 = 0;
  int v8 = *(_DWORD *)(a3 + 16);
  if (v8)
  {
    sub_1CD41B598((uint64_t)&v53, a3 + 8);
    uint64_t v7 = v52;
    int v8 = v54;
    BOOL v9 = v54 == 0;
  }
  else
  {
    BOOL v9 = 1;
  }
  unint64_t v10 = *(void *)(*(void *)(a1 + 8) + 48);
  unsigned __int8 v11 = 63 - __clz(v10);
  uint64_t v12 = *(void *)(*(void *)(a1 + 16) + 48);
  uint64_t v55 = v7;
  v56[0] = v57;
  v56[1] = 0;
  if (!v9)
  {
    sub_1CD41B6B0((uint64_t)v56, (uint64_t)&v53);
    int v8 = v54;
  }
  unsigned int v13 = *(_DWORD *)(*(void *)(a2 + 16) + 32);
  if (!v8)
  {
    unint64_t v14 = v52;
    unsigned int v15 = *(unsigned __int8 *)(*((void *)v52 - 4) + 16);
    if (v15 < 0x15 || v15 == 24) {
      goto LABEL_12;
    }
  }
  unsigned int v13 = *((_DWORD *)v53 + v13 + 1);
  if ((v13 & 0x80000000) == 0)
  {
    unint64_t v14 = v52;
LABEL_12:
    PointerBitCastOrAddrSpaceCast = (llvm::Value *)*((void *)v14 + 4 * v13 + -4 * (*((_DWORD *)v14 + 5) & 0x7FFFFFF));
    goto LABEL_14;
  }
  PointerBitCastOrAddrSpaceCast = 0;
LABEL_14:
  if (v10) {
    __int16 v18 = v11;
  }
  else {
    __int16 v18 = 0;
  }
  unsigned int v19 = v55;
  sub_1CC8A8E38((uint64_t)v59, (uint64_t **)v55, 0, 0, 0);
  unsigned int v50 = v19;
  unint64_t v51 = (llvm::DataLayout *)(*(void *)(*(void *)(*((void *)v19 + 5) + 56) + 40) + 272);
  unint64_t v20 = (llvm::Value *)llvm::PointerType::get((llvm::PointerType *)v12, 0);
  if (*(llvm::Value **)PointerBitCastOrAddrSpaceCast != v20)
  {
    __int16 v58 = 257;
    PointerBitCastOrAddrSpaceCast = llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(PointerBitCastOrAddrSpaceCast, v20, v57, v55, v21);
  }
  int v22 = *(unsigned __int8 *)(v12 + 8);
  unint64_t v49 = (llvm::Type *)v12;
  if (v12 && v22 == 16)
  {
    StructLayout = llvm::DataLayout::getStructLayout(v51, (llvm::StructType *)v12);
    uint64_t v24 = *(unsigned int *)(v12 + 12);
    if (v24)
    {
      uint64_t v25 = 0;
      uint64_t v26 = (char *)StructLayout + 16;
      __int16 v27 = 2 * v18;
      uint64_t v28 = 8 * v24;
      do
      {
        int v29 = *(llvm::PointerType **)(*(void *)(v12 + 16) + v25);
        int v30 = (llvm::Value *)llvm::PointerType::get(v29, 0);
        std::string::size_type v31 = sub_1CC8CE908(v30, (llvm::Type *)v12, PointerBitCastOrAddrSpaceCast, *(void *)&v26[v25], (uint64_t)v59, v51);
        int v32 = operator new(0x60uLL);
        v32[13] = v32[13] & 0x38000000 | 1;
        *(void *)int v32 = 0;
        *((void *)v32 + 1) = 0;
        *((void *)v32 + 2) = 0;
        *((void *)v32 + 3) = v32 + 8;
        __int16 v58 = 257;
        llvm::LoadInst::LoadInst((llvm::LoadInst *)(v32 + 8), v29, v31, v57, 0, v50);
        *((_WORD *)v32 + 25) = *((_WORD *)v32 + 25) & 0xFF81 | v27;
        unint64_t v33 = *(unsigned int *)(a4 + 8);
        if (v33 >= *(unsigned int *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a4 + 8 * v33) = v32 + 8;
        ++*(_DWORD *)(a4 + 8);
        v25 += 8;
      }
      while (v28 != v25);
    }
  }
  else if (v12 && v22 == 17)
  {
    unsigned int v48 = PointerBitCastOrAddrSpaceCast;
    uint64_t v34 = *(llvm::PointerType **)(v12 + 24);
    uint64_t v36 = sub_1CB83544C((uint64_t)v51, (uint64_t)v34);
    if (v35 == 1) {
    unint64_t v37 = llvm::PointerType::get(v34, 0);
    }
    uint64_t v38 = *(unsigned int *)(v12 + 32);
    if (*(_DWORD *)(v12 + 32))
    {
      uint64_t v39 = (llvm::Value *)v37;
      unint64_t v40 = v34;
      uint64_t v41 = 0;
      unint64_t v42 = (unint64_t)(v36 + 7) >> 3;
      do
      {
        uint64_t v43 = sub_1CC8CE908(v39, v49, v48, v41, (uint64_t)v59, v51);
        std::string::size_type v44 = operator new(0x60uLL);
        v44[13] = v44[13] & 0x38000000 | 1;
        *(void *)std::string::size_type v44 = 0;
        *((void *)v44 + 1) = 0;
        *((void *)v44 + 2) = 0;
        *((void *)v44 + 3) = v44 + 8;
        __int16 v58 = 257;
        llvm::LoadInst::LoadInst((llvm::LoadInst *)(v44 + 8), v40, v43, v57, 0, v50);
        *((_WORD *)v44 + 25) = *((_WORD *)v44 + 25) & 0xFF81 | (2 * v18);
        unint64_t v45 = *(unsigned int *)(a4 + 8);
        if (v45 >= *(unsigned int *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a4 + 8 * v45) = v44 + 8;
        ++*(_DWORD *)(a4 + 8);
        v41 += v42;
        --v38;
      }
      while (v38);
    }
  }
  else
  {
    int v46 = operator new(0x60uLL);
    v46[13] = v46[13] & 0x38000000 | 1;
    *(void *)int v46 = 0;
    *((void *)v46 + 1) = 0;
    *((void *)v46 + 2) = 0;
    *((void *)v46 + 3) = v46 + 8;
    __int16 v58 = 257;
    llvm::LoadInst::LoadInst((llvm::LoadInst *)(v46 + 8), (llvm::Type *)v12, PointerBitCastOrAddrSpaceCast, v57, 0, v19);
    *((_WORD *)v46 + 25) = *((_WORD *)v46 + 25) & 0xFF81 | (2 * v18);
    unsigned int v47 = *(_DWORD *)(a4 + 8);
    if (v47 >= *(_DWORD *)(a4 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a4 + 8 * v47) = v46 + 8;
    ++*(_DWORD *)(a4 + 8);
  }
  if (v59[0] != v60) {
    free(v59[0]);
  }
  if (v56[0] != v57) {
    free(v56[0]);
  }
  if (v53 != &v55) {
    free(v53);
  }
}

uint64_t sub_1CC8CF7E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v12 = *a2;
  v13[0] = v14;
  v13[1] = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)v13, (uint64_t)(a2 + 1));
    uint64_t v3 = v12;
  }
  uint64_t v4 = **(void ***)a1;
  uint64_t v5 = *(void *)(*(void *)(v3 + 40) + 56);
  uint64_t v6 = *(void *)(v3 - 32);
  if (!v6 || *(unsigned char *)(v6 + 16) || *(void *)(v6 + 24) != *(void *)(v3 + 72)) {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(uint64_t **)(a1 + 8);
  uint64_t v8 = *v7;
  uint64_t v9 = *((unsigned int *)v7 + 2);
  v14[0] = v8;
  v14[1] = v9;
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t, void *))(*(void *)*v4 + 1040))(*v4, v5, v6, v14);
  if (v13[0] != v14) {
    free(v13[0]);
  }
  return v10;
}

BOOL sub_1CC8CF8D0(void *a1, uint64_t a2)
{
  v49[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(uint64_t *****)a2;
  uint64_t v38 = *(uint64_t *****)a2;
  uint64_t v39 = &v41;
  uint64_t v40 = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)&v39, a2 + 8);
    uint64_t v3 = v38;
    if (v40)
    {
      uint64_t v25 = (unsigned int **)a1[1];
      uint64_t v41 = v38;
      unint64_t v42 = &v44;
      uint64_t v43 = 0;
      sub_1CD41B6B0((uint64_t)&v42, (uint64_t)&v39);
      unsigned int v26 = **v25;
      uint64_t v27 = (uint64_t)*(v41 - 4);
      if (v43)
      {
        unsigned int v26 = *((_DWORD *)v42 + v26 + 1);
        if (!v27) {
          goto LABEL_54;
        }
      }
      else
      {
        unsigned int v28 = *(unsigned __int8 *)(v27 + 16);
        if (v28 >= 0x15 && v28 != 24) {
          unsigned int v26 = *((_DWORD *)v42 + v26 + 1);
        }
      }
      if (!*(unsigned char *)(v27 + 16) && *(uint64_t ****)(v27 + 24) == v41[9])
      {
        if (*(void *)(v27 + 96) <= (unint64_t)v26) {
          goto LABEL_63;
        }
LABEL_55:
        unsigned int v30 = v26;
        unint64_t v33 = (int **)(v25 + 1);
        uint64_t v32 = (uint64_t)v25[1];
        uint64_t v31 = (uint64_t)v33[1];
        if (*(_WORD *)(v27 + 18)) {
          llvm::Function::BuildLazyArguments((llvm::Function *)v27);
        }
        uint64_t v34 = sub_1CC8BBC0C(v32, *(void *)(v27 + 88) + 40 * v30, 0, v31, 0, 0, 1);
        if ((*(unsigned int (**)(void))(*((void *)v34 + 4) + 16))()
          && ((uint64_t v35 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v34 + 112))(v34), !v36)
           || *(unsigned char *)(v31 + 56) && *(void *)(v31 + 48) == v35))
        {
          BOOL v23 = 1;
        }
        else
        {
LABEL_63:
          BOOL v23 = 0;
        }
        if (v42 != &v44) {
          free(v42);
        }
        goto LABEL_40;
      }
LABEL_54:
      uint64_t v27 = 0;
      goto LABEL_55;
    }
  }
  unsigned int v4 = *((unsigned __int8 *)*(v3 - 4) + 16);
  if (v4 >= 0x15 && v4 != 24)
  {
    BOOL v23 = 0;
    goto LABEL_40;
  }
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)(*a1 + 16);
  unsigned int v47 = v49;
  uint64_t v48 = 0x400000000;
  llvm::AbstractCallSite::getCallbackUses(v3, (uint64_t)&v47);
  uint64_t v8 = (const llvm::Use **)v47;
  if (!v48)
  {
    int v18 = 2;
    goto LABEL_37;
  }
  unint64_t v37 = (const llvm::Use **)((char *)v47 + 8 * v48);
  while (2)
  {
    llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v44, *v8);
    uint64_t v9 = sub_1CD46F814(&v44);
    uint64_t v10 = v9;
    if (*((_WORD *)v9 + 9))
    {
      llvm::Function::BuildLazyArguments(v9);
      uint64_t v11 = *((void *)v10 + 11);
      if (*((_WORD *)v10 + 9))
      {
        llvm::Function::BuildLazyArguments(v10);
        uint64_t v12 = *((void *)v10 + 11);
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v11 = *((void *)v9 + 11);
    }
    uint64_t v12 = v11;
LABEL_12:
    uint64_t v13 = v12 + 40 * *((void *)v10 + 12);
    if (v11 == v13)
    {
LABEL_26:
      int v18 = 0;
      char v22 = 1;
      goto LABEL_27;
    }
    uint64_t v14 = v11;
    while (1)
    {
      int v15 = *(_DWORD *)(v11 + 32);
      if (v46
        || ((unsigned int v16 = *(unsigned __int8 *)(*((void *)v44 - 4) + 16), v16 >= 0x15) ? (v17 = v16 == 24) : (v17 = 1), !v17))
      {
        int v15 = *((_DWORD *)v45 + (v15 + 1));
      }
      if (v15 != **(_DWORD **)v6) {
        goto LABEL_25;
      }
      int v18 = 1;
      unsigned int v19 = sub_1CC8BBC0C(*(void *)(v6 + 8), v14, 0, v7, 0, 0, 1);
      if (!(*(unsigned int (**)(void))(*((void *)v19 + 4) + 16))()) {
        break;
      }
      uint64_t v20 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v19 + 112))(v19);
      if (v21)
      {
        char v22 = 0;
        if (!*(unsigned char *)(v7 + 56) || *(void *)(v7 + 48) != v20) {
          goto LABEL_27;
        }
      }
LABEL_25:
      v11 += 40;
      v14 += 40;
      if (v11 == v13) {
        goto LABEL_26;
      }
    }
    char v22 = 0;
LABEL_27:
    if (v45 != &v47) {
      free(v45);
    }
    if (v22)
    {
      if (++v8 == v37)
      {
        int v18 = 2;
        break;
      }
      continue;
    }
    break;
  }
  uint64_t v8 = (const llvm::Use **)v47;
LABEL_37:
  if (v8 != v49) {
    free(v8);
  }
  BOOL v23 = v18 == 2;
LABEL_40:
  if (v39 != &v41) {
    free(v39);
  }
  return v23;
}

uint64_t sub_1CC8CFD04(uint64_t a1, uint64_t a2)
{
  v3[0] = &v4;
  v3[1] = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)v3, a2 + 8);
    if (v3[0] != &v4) {
      free(v3[0]);
    }
  }
  return 1;
}

BOOL sub_1CC8CFD68(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v21 = *a2;
  char v22 = &v24;
  uint64_t v23 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v22, (uint64_t)(a2 + 1));
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v24 = v21;
    uint64_t v25 = &v27;
    uint64_t v26 = 0;
    if (v23) {
      sub_1CD41B6B0((uint64_t)&v25, (uint64_t)&v22);
    }
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v24 = v3;
    uint64_t v25 = &v27;
    uint64_t v26 = 0;
  }
  uint64_t v27 = sub_1CD659800((uint64_t)&v24, **(_DWORD **)a1);
  uint64_t v28 = v5;
  if (v25 != &v27) {
    free(v25);
  }
  if (sub_1CD647DEC(&v27))
  {
    uint64_t v6 = sub_1CC8BBC0C(*(void *)(a1 + 8), v27, v28, v4, 0, 0, 1);
    uint64_t v7 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v6 + 112))(v6);
    uint64_t v9 = *(uint64_t **)(a1 + 24);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    LOBYTE(v12) = 1;
    unint64_t v13 = v11 & 0xFFFFFFFFFFFFFF00;
    if (*v9 == v7) {
      uint64_t v14 = *v9;
    }
    else {
      uint64_t v14 = 0;
    }
    if (*v9 == v7)
    {
      uint64_t v12 = v9[1];
      unint64_t v15 = v11 & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
      unint64_t v15 = 0;
    }
    if ((_BYTE)v8) {
      uint64_t v10 = v14;
    }
    else {
      uint64_t v12 = v9[1];
    }
    if ((_BYTE)v8) {
      unint64_t v13 = v15;
    }
    if (v9[1])
    {
      unsigned __int8 v16 = v12;
    }
    else
    {
      uint64_t v10 = v7;
      unsigned __int8 v16 = v8;
    }
    if (v9[1]) {
      unint64_t v17 = v13;
    }
    else {
      unint64_t v17 = v8 & 0xFFFFFFFFFFFFFF00;
    }
    *uint64_t v9 = v10;
    v9[1] = v17 | v16;
    uint64_t v18 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v18 + 8)) {
      BOOL v19 = *(void *)v18 != 0;
    }
    else {
      BOOL v19 = 1;
    }
  }
  else
  {
    BOOL v19 = 0;
  }
  if (v22 != &v24) {
    free(v22);
  }
  return v19;
}

void *sub_1CC8CFF0C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8CFF50(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8CFFB4(uint64_t result)
{
  *(unsigned char *)(result + 41) = *(unsigned char *)(result + 40);
  if (!*(unsigned char *)(result + 56)) {
    *(unsigned char *)(result + 56) = 1;
  }
  *(void *)(result + 48) = 0;
  return result;
}

void sub_1CC8CFFD4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C060))
  {
    __cxa_guard_release(&qword_1EA61C060);
  }
}

uint64_t *sub_1CC8D0028(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D0050(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D00B8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D00FC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D0160(uint64_t result)
{
  *(unsigned char *)(result + 41) = *(unsigned char *)(result + 40);
  if (!*(unsigned char *)(result + 56)) {
    *(unsigned char *)(result + 56) = 1;
  }
  *(void *)(result + 48) = 0;
  return result;
}

void sub_1CC8D0180()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C068, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C068))
  {
    __cxa_guard_release(&qword_1EA61C068);
  }
}

uint64_t *sub_1CC8D01D4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D01FC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D0264(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D02A8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8D030C(unsigned char *a1)
{
  unsigned int v3 = 69;
  BOOL result = llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), &v3, 1, 0, 0);
  if (result) {
    a1[40] = a1[41];
  }
  return result;
}

void sub_1CC8D0360()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C070, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C070))
  {
    __cxa_guard_release(&qword_1EA61C070);
  }
}

uint64_t sub_1CC8D03B4(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)sub_1CC8CD580(a1, a2);
  *(void *)(a1 + 48) = result;
  *(void *)(a1 + 56) = v5;
  if (!(_BYTE)v5) {
    return 1;
  }
  if (result)
  {
    if ((~*((unsigned __int16 *)sub_1CC8BB6D4(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 0, 0, 1) + 21) & 7) == 0
      && *((unsigned char *)sub_1CC8BAC64(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 0, 0, 1) + 41)
      && (sub_1CC8AAAB0(a2, (uint64_t *)(a1 + 16), a1, 0, &v7) & 1) != 0)
    {
      return 1;
    }
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
    int v6 = *(unsigned __int8 *)(a1 + 56);
    *(void *)(a1 + 48) = 0;
    uint64_t result = 0;
    if (!v6) {
      *(unsigned char *)(a1 + 56) = 1;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
    *(void *)(a1 + 48) = 0;
  }
  return result;
}

uint64_t *sub_1CC8D04A8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D04D0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D0538(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8D05A8(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D0638(uint64_t a1, uint64_t a2)
{
  v62[4] = *MEMORY[0x1E4F143B8];
  uint64_t v53 = (uint64_t *)v55;
  uint64_t v54 = 0x400000000;
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  v56[0] = 0x4D0000004CLL;
  llvm::IRPosition::getAttrs((llvm::IRPosition *)(a1 + 16), (unsigned int *)v56, 2, (uint64_t)&v53, 0, a2);
  if (v54)
  {
    uint64_t v5 = v53;
    uint64_t v6 = 8 * v54;
    do
    {
      uint64_t v7 = *v5;
      if (*v5) {
        uint64_t v7 = *(void *)(v7 + 16);
      }
      *(uint32x2_t *)(a1 + 48) = vmax_u32(*(uint32x2_t *)(a1 + 48), (uint32x2_t)vdup_n_s32(v7));
      sub_1CD659FCC(a1 + 32);
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  *(void *)(a1 + 96) = sub_1CC8BA72C(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 2, 0, 1);
  *(_WORD *)uint64_t v35 = 0;
  uint64_t v8 = (uint64_t ***)sub_1CD6482F0(v4);
  *(uint32x2_t *)(a1 + 48) = vmax_u32(*(uint32x2_t *)(a1 + 48), (uint32x2_t)vdup_n_s32(llvm::Value::getPointerDereferenceableBytes(v8, *(const llvm::DataLayout **)(*(void *)(a2 + 88) + 120), &v35[1], v35)));
  sub_1CD659FCC(a1 + 32);
  unsigned int v9 = sub_1CD647DEC(v4);
  if (v9 <= 6 && ((1 << v9) & 0x54) != 0)
  {
    uint64_t v10 = (llvm::GlobalValue *)sub_1CD6482A0(v4);
    if (!v10 || !sub_1CD64EF44(a2, v10))
    {
      (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
      goto LABEL_12;
    }
  }
  else
  {
    sub_1CD6482A0(v4);
  }
  unint64_t v11 = sub_1CC8AB830(v4);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    v48[0] = 0;
    v48[1] = 0;
    int v49 = 0;
    unint64_t v51 = 0;
    uint64_t v52 = 0;
    uint64_t v50 = 0;
    for (uint64_t i = *(void *)(sub_1CD6482F0(v4) + 8); i; uint64_t i = *(void *)(i + 8))
    {
      v56[0] = i;
      sub_1CC61C590(v48, v56);
    }
    uint64_t v15 = *(void *)(a2 + 88) + 136;
    sub_1CC8D229C(a1, a2, v15, v12, v48, v13);
    if (((*(uint64_t (**)(uint64_t))(*(void *)v13 + 24))(v13) & 1) == 0)
    {
      int v60 = v62;
      uint64_t v61 = 0x400000000;
      unsigned int v47 = &v60;
      sub_1CD65952C(v15, v12, (unsigned int (*)(uint64_t))sub_1CC8D2668, (uint64_t)&v47);
      unsigned __int8 v16 = v60;
      if (v61)
      {
        unint64_t v17 = &v60[v61];
        uint64_t v34 = (void *)(v13 + 24);
        uint64_t v32 = v13;
        uint64_t v31 = v17;
        do
        {
          uint64_t v18 = *v16;
          v56[0] = &unk_1F2623348;
          v56[1] = &unk_1F2623388;
          v57[0] = 0;
          v57[1] = 0;
          v56[3] = v57;
          v57[2] = &unk_1F2620BB0;
          uint64_t v59 = 0;
          v56[2] = -1;
          __int16 v58 = 257;
          int v19 = *(_DWORD *)(v18 + 20);
          if ((v19 & 0x40000000) != 0)
          {
            uint64_t v21 = *(void *)(v18 - 8);
            uint64_t v20 = v19 & 0x7FFFFFF;
          }
          else
          {
            uint64_t v20 = v19 & 0x7FFFFFF;
            uint64_t v21 = v18 - 32 * v20;
          }
          uint64_t v22 = v20 == 3;
          if (v20 != v22)
          {
            unint64_t v33 = v16;
            uint64_t v23 = (uint64_t *)(v21 + 32 * v20);
            uint64_t v24 = (uint64_t *)(v21 + 32 * v22);
            do
            {
              uint64_t v25 = *v24;
              v43[2] = 0xFFFFFFFF00000000;
              v43[0] = &unk_1F2623348;
              v43[1] = &unk_1F2623388;
              v44[0] = 0;
              v44[1] = 0;
              v43[3] = v44;
              __int16 v45 = 256;
              v44[2] = &unk_1F2620BB0;
              uint64_t v46 = 0;
              uint64_t v26 = &v51[-v50];
              uint64_t v27 = *(void *)(v25 + 48);
              if (v27) {
                uint64_t v28 = v27 - 24;
              }
              else {
                uint64_t v28 = 0;
              }
              sub_1CC8D229C(a1, a2, v15, v28, v48, (uint64_t)v43);
              for (j = &v26[v50]; v51 != j; j = sub_1CD659618((uint64_t)v48, j))
                ;
              sub_1CD65A058((uint64_t)v42, v56, (uint64_t)v43);
              v42[0] = &unk_1F2623348;
              sub_1CD40B1BC((void *)v42[4]);
              v43[0] = &unk_1F2623348;
              sub_1CD40B1BC(v44[0]);
              v24 += 4;
            }
            while (v24 != v23);
            uint64_t v13 = v32;
            unsigned __int8 v16 = v33;
            unint64_t v17 = v31;
          }
          (*(void (**)(void))(*(void *)(v13 + 8) + 56))();
          (*(void (**)(void))(*(void *)(v13 + 48) + 56))();
          uint64_t v30 = *(void *)(v13 + 16);
          char v36 = &unk_1F2623348;
          unint64_t v37 = &unk_1F2623388;
          uint64_t v38 = v30;
          sub_1CC8D26F8((uint64_t)v39, v34);
          __int16 v40 = *(_WORD *)(v13 + 56);
          uint64_t v41 = *(void *)(v13 + 64);
          v39[3] = &unk_1F2620BB0;
          char v36 = &unk_1F2623348;
          sub_1CD40B1BC(v39[1]);
          v56[0] = &unk_1F2623348;
          sub_1CD40B1BC(v57[0]);
          ++v16;
        }
        while (v16 != v17);
        unsigned __int8 v16 = v60;
      }
      if (v16 != v62) {
        free(v16);
      }
    }
    sub_1CD456CB4(v48);
  }
LABEL_12:
  if (v53 != (uint64_t *)v55) {
    free(v53);
  }
}

uint64_t sub_1CC8D0CAC(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CC8D0CB4(uint64_t a1)
{
  return a1 + 32;
}

void sub_1CC8D0CBC(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(_DWORD *)(a1 + 52))
  {
    *((unsigned char *)&v27.__r_.__value_.__s + 23) = 15;
    strcpy((char *)&v27, "dereferenceable");
    uint64_t v4 = *(void *)(a1 + 96);
    uint64_t v5 = "_or_null";
    if (v4 && *(unsigned char *)(v4 + 41)) {
      uint64_t v5 = "";
    }
    uint64_t v6 = std::string::append(&v27, v5);
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v28.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    if (*(unsigned char *)(a1 + 89)) {
      uint64_t v8 = "_globally";
    }
    else {
      uint64_t v8 = "";
    }
    unsigned int v9 = std::string::append(&v28, v8);
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    unint64_t v11 = std::string::append(&v29, "<");
    std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v26, *(_DWORD *)(a1 + 48));
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v13 = &v26;
    }
    else {
      uint64_t v13 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v26.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v26.__r_.__value_.__l.__size_;
    }
    uint64_t v15 = std::string::append(&v30, (const std::string::value_type *)v13, size);
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    unint64_t v17 = std::string::append(&v31, "-");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v25, *(_DWORD *)(a1 + 52));
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v19 = &v25;
    }
    else {
      int v19 = (std::string *)v25.__r_.__value_.__r.__words[0];
    }
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v20 = *((unsigned char *)&v25.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type v20 = v25.__r_.__value_.__l.__size_;
    }
    uint64_t v21 = std::string::append(&v32, (const std::string::value_type *)v19, v20);
    std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    uint64_t v23 = std::string::append(&v33, ">");
    *(std::string *)a2 = *v23;
    v23->__r_.__value_.__r.__words[0] = 0;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v33.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v27.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v24 = (char *)operator new(0x19uLL);
    *(void *)a2 = v24;
    *(_OWORD *)(a2 + 8) = xmmword_1CD91A420;
    strcpy(v24, "unknown-dereferenceable");
  }
}

uint64_t sub_1CC8D0F78(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1CD659D3C(a1, a2);
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4)
  {
    if (*(unsigned char *)(v4 + 41))
    {
      uint64_t v6 = (llvm::IRPosition *)(a1 + 16);
      unsigned int v8 = 77;
      if (llvm::IRPosition::hasAttr(v6, &v8, 1, 0, 0))
      {
        int v7 = 77;
        sub_1CD658824(v6, &v7, 1);
        return 0;
      }
    }
  }
  return v3;
}

void sub_1CC8D1008()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C078, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C078))
  {
    __cxa_guard_release(&qword_1EA61C078);
  }
}

uint64_t sub_1CC8D105C(uint64_t a1, llvm::Attributor *a2)
{
  long long v2 = (llvm::AbstractAttribute *)a1;
  v155[12] = *MEMORY[0x1E4F143B8];
  int64x2_t v118 = *(llvm::DataLayout **)(*((void *)a2 + 11) + 120);
  v122[0] = &unk_1F2623348;
  unint64_t v123 = 0xFFFFFFFF00000000;
  v125[0] = 0;
  v125[1] = 0;
  v122[1] = &unk_1F2623388;
  unsigned int v124 = v125;
  __int16 v127 = 256;
  uint64_t v126 = (void (**)(void))&unk_1F2620BB0;
  uint64_t v128 = 0;
  BOOL v121 = 0;
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  unint64_t v5 = sub_1CC8AB830((_DWORD *)(a1 + 16));
  v130[0] = v3;
  v130[1] = v4;
  v152[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v152[i] = -4096;
  unint64_t v153 = (char *)v155;
  uint64_t v154 = 0x400000000;
  unint64_t v7 = sub_1CD6482F0((llvm::IRPosition *)v130);
  uint64_t v8 = 0;
  v149[0] = v150;
  v149[1] = (void *)0x1000000000;
  v151[1] = 0;
  v151[0] = 0;
  v150[32] = v151;
  int v145 = (char *)v148;
  unsigned int v147 = 16;
  v148[0] = v7;
  v148[1] = v5;
  unint64_t v116 = v7;
  int64x2_t v115 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v9 = 1;
  uint64_t v117 = v2;
  do
  {
    std::string::size_type v10 = &v145[16 * v9];
    uint64_t v11 = *((void *)v10 - 2);
    unint64_t v12 = *((void *)v10 - 1);
    unsigned int v146 = v9 - 1;
    v129[0] = v11;
    v129[1] = v12;
    if ((sub_1CD65837C((uint64_t)v149, v129) & 0x100000000) == 0)
    {
      uint64_t v13 = v8;
      goto LABEL_126;
    }
    if ((int)v8 >= 16) {
      goto LABEL_210;
    }
    uint64_t v13 = (v8 + 1);
    if (*(unsigned char *)(*(void *)v11 + 8) != 15)
    {
      unsigned int v17 = *(unsigned __int8 *)(v11 + 16);
      if (v17 < 0x1C) {
        goto LABEL_34;
      }
      unsigned int v18 = v17 - 33;
      BOOL v19 = v18 > 0x33;
      uint64_t v20 = (1 << v18) & 0x8000000000041;
      if (v19 || v20 == 0) {
        goto LABEL_34;
      }
      uint64_t v22 = *(void *)(v11 - 32);
      if (!v22 || *(unsigned char *)(v22 + 16) || *(void *)(v22 + 24) != *(void *)(v11 + 72)) {
        goto LABEL_34;
      }
      if (*(_WORD *)(v22 + 18))
      {
        llvm::Function::BuildLazyArguments(*(llvm::Function **)(v11 - 32));
        uint64_t v23 = *(void *)(v22 + 88);
        if (*(_WORD *)(v22 + 18))
        {
          llvm::Function::BuildLazyArguments((llvm::Function *)v22);
          uint64_t v24 = *(void *)(v22 + 88);
LABEL_26:
          uint64_t v25 = v24 + 40 * *(void *)(v22 + 96);
          while (v23 != v25)
          {
            uint64_t v26 = *(void *)(*(void *)(v23 + 24) + 112);
            if (v26)
            {
              uint64_t v27 = *(unsigned int *)(v23 + 32);
              if ((v27 + 2) < *(_DWORD *)(v26 + 8))
              {
                uint64_t v28 = *(void *)(v26 + 8 * (v27 + 2) + 40);
                if (v28)
                {
                  if ((*(unsigned char *)(v28 + 17) & 0x40) != 0)
                  {
                    uint64_t v14 = *(llvm::Value **)(v11 - 32 * (*(_DWORD *)(v11 + 20) & 0x7FFFFFF) + 32 * v27);
                    goto LABEL_9;
                  }
                }
              }
            }
            v23 += 40;
          }
          goto LABEL_34;
        }
      }
      else
      {
        uint64_t v23 = *(void *)(v22 + 88);
      }
      uint64_t v24 = v23;
      goto LABEL_26;
    }
    uint64_t v14 = llvm::Value::stripPointerCasts((llvm::Value *)v11);
LABEL_9:
    if (v14) {
      BOOL v15 = v14 == (llvm::Value *)v11;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15)
    {
LABEL_13:
      if (v146 >= (unint64_t)v147) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      std::string::size_type v16 = &v145[16 * v146];
      *(void *)std::string::size_type v16 = v14;
      goto LABEL_125;
    }
LABEL_34:
    int v29 = *(unsigned __int8 *)(v11 + 16);
    if (v29 == 83)
    {
      uint64_t v33 = *(void *)(*(void *)(v11 + 40) + 56);
      *(void *)uint64_t v131 = v33;
      v132[0] = 0;
      sub_1CD645794((uint64_t)&v139, (uint64_t)v152, (uint64_t *)v131, v132);
      uint64_t v34 = v139;
      unsigned int v119 = v8 + 1;
      if (v140.i8[8])
      {
        *(_DWORD *)&v134[20] = 0;
        *(_DWORD *)&v134[17] = 0;
        *(void *)unint64_t v134 = v33;
        *(void *)&v134[8] = 0;
        v134[16] = 0;
        if (v154 >= HIDWORD(v154))
        {
          if (v153 > v134 || &v153[24 * v154] <= v134) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v57 = &v153[24 * v154];
        long long v58 = *(_OWORD *)v134;
        *((void *)v57 + 2) = *(void *)&v134[16];
        *(_OWORD *)uint64_t v57 = v58;
        int v35 = v154;
        LODWORD(v154) = v154 + 1;
        *(_DWORD *)(v34 + 8) = v35;
      }
      else
      {
        int v35 = *(_DWORD *)(v139 + 8);
      }
      uint64_t v59 = v153;
      int v60 = &v153[24 * v35];
      uint64_t v62 = *((void *)v60 + 1);
      uint64_t v61 = (llvm::AbstractAttribute **)(v60 + 8);
      if (!v62) {
        *uint64_t v61 = sub_1CC8AC178((uint64_t)a2, v33, 0, (uint64_t)v2, 2, 0, 1);
      }
      uint64_t v63 = *(_DWORD *)(v11 + 20) & 0x7FFFFFF;
      if (v63)
      {
        uint64_t v64 = 0;
        uint64_t v65 = 0;
        uint64_t v66 = &v59[24 * v35 + 16];
        uint64_t v67 = 8 * v63;
        do
        {
          int v68 = *(_DWORD *)(v11 + 20);
          if ((v68 & 0x40000000) != 0) {
            uint64_t v69 = *(void *)(v11 - 8);
          }
          else {
            uint64_t v69 = v11 - 32 * (v68 & 0x7FFFFFF);
          }
          uint64_t v70 = *(void *)(v69 + 32 * *(unsigned int *)(v11 + 60) + v65);
          if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v61 + 168))(*v61, v70, *(void *)(v11 + 40)))
          {
            *uint64_t v66 = 1;
            v121 |= (*(unsigned __int8 (**)(void))(*((void *)*v61 + 4) + 24))() ^ 1;
          }
          else
          {
            int v71 = *(_DWORD *)(v11 + 20);
            if ((v71 & 0x40000000) != 0) {
              uint64_t v72 = *(void *)(v11 - 8);
            }
            else {
              uint64_t v72 = v11 - 32 * (v71 & 0x7FFFFFF);
            }
            uint64_t v73 = *(void *)(v70 + 40);
            if (v73 == v70 + 40)
            {
              uint64_t v75 = 0;
            }
            else
            {
              if (v73) {
                uint64_t v74 = v73 - 24;
              }
              else {
                uint64_t v74 = 0;
              }
              if (*(unsigned __int8 *)(v74 + 16) - 29 >= 0xB) {
                uint64_t v75 = 0;
              }
              else {
                uint64_t v75 = v74;
              }
            }
            uint64_t v76 = *(void *)(v72 + v64);
            if (v146 >= (unint64_t)v147) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v77 = &v145[16 * v146];
            *(void *)uint64_t v77 = v76;
            *((void *)v77 + 1) = v75;
            ++v146;
          }
          v65 += 8;
          v64 += 32;
        }
        while (v67 != v65);
        long long v2 = v117;
      }
      uint64_t v13 = v119;
      goto LABEL_126;
    }
    if (v29 != 85)
    {
      if (v29 == 21) {
        char v36 = (llvm::Argument *)v11;
      }
      else {
        char v36 = 0;
      }
      *(void *)uint64_t v131 = v36;
      if (v36 && (llvm::Argument::hasPassPointeeByValueCopyAttr(v36) & 1) == 0)
      {
        uint64_t v139 = (uint64_t)&v140.i64[1];
        v140.i64[0] = 0x300000000;
        char v133 = 0;
        *(void *)unint64_t v134 = v131;
        *(void *)&v134[8] = &v139;
        int v37 = llvm::Attributor::checkForAllCallSites((uint64_t)a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8D279C, (uint64_t)v134, *(void *)(*(void *)v131 + 24), 1, (uint64_t)v2, &v133);
        char v38 = v37;
        int v39 = 0;
        if (v37)
        {
          sub_1CD3D61B4((unsigned int *)&v145, (unsigned char *)v139, (unsigned char *)(v139 + 16 * v140.u32[0]));
          int v39 = 3;
        }
        if ((unint64_t *)v139 != &v140.u64[1]) {
          free((void *)v139);
        }
        if (v38)
        {
LABEL_161:
          if (v39 != 3 && v39)
          {
LABEL_210:
            char v108 = 0;
            goto LABEL_216;
          }
          goto LABEL_126;
        }
      }
      unsigned int v40 = *(unsigned __int8 *)(v11 + 16);
      if (v40 < 0x15) {
        goto LABEL_51;
      }
      uint64_t v78 = v11;
      if (v40 >= 0x1C)
      {
        unsigned int v79 = v40 - 33;
        uint64_t v78 = v11;
        if (v79 <= 0x33)
        {
          uint64_t v78 = v11;
          if (((1 << v79) & 0x8000000000041) != 0) {
            uint64_t v78 = v11 | 1;
          }
        }
      }
      uint64_t v139 = v78;
      v140.i64[0] = 0;
      unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v139, v2, &v121);
      if (!v81) {
        goto LABEL_126;
      }
      uint64_t v14 = (llvm::Value *)AssumedSimplified;
      if (AssumedSimplified && v11 != AssumedSimplified) {
        goto LABEL_13;
      }
      if (*(unsigned char *)(v11 + 16) != 60)
      {
LABEL_51:
        unsigned int v41 = *(_DWORD *)(*(void *)v11 + 8);
        if ((v41 & 0xFE) == 0x12) {
          unsigned int v41 = *(_DWORD *)(**(void **)(*(void *)v11 + 16) + 8);
        }
        if (v41 < 0x100) {
          goto LABEL_62;
        }
        unsigned int v42 = v41 >> 8;
        uint64_t v43 = *((unsigned int *)v118 + 60);
        uint64_t v44 = *((void *)v118 + 29);
        if (v43)
        {
          uint64_t v44 = *((void *)v118 + 29);
          unint64_t v45 = *((unsigned int *)v118 + 60);
          do
          {
            unint64_t v46 = v45 >> 1;
            uint64_t v47 = v44 + 16 * (v45 >> 1);
            unsigned int v48 = *(_DWORD *)(v47 + 8);
            uint64_t v49 = v47 + 16;
            v45 += ~(v45 >> 1);
            if (v48 < v42) {
              uint64_t v44 = v49;
            }
            else {
              unint64_t v45 = v46;
            }
          }
          while (v45);
        }
        if (v44 == *((void *)v118 + 29) + 16 * v43 || *(_DWORD *)(v44 + 8) != v42) {
LABEL_62:
        }
          uint64_t v44 = *((void *)v118 + 29);
        *(_DWORD *)&v134[8] = *(_DWORD *)(v44 + 12);
        if (*(_DWORD *)&v134[8] > 0x40u) {
          operator new[]();
        }
        *(void *)unint64_t v134 = 0;
        v131[0] = 0;
        char v133 = 0;
        uint64_t v139 = (uint64_t)a2;
        v140.i64[0] = (uint64_t)v2;
        v140.i64[1] = (uint64_t)&v133;
        v141.i64[0] = (uint64_t)v131;
        uint64_t v50 = (uint64_t)llvm::Value::stripAndAccumulateConstantOffsets((llvm::GlobalValue *)v11, v118, (llvm::APInt *)v134, 1, 1, (unsigned int (*)(uint64_t, llvm::Constant *, void **))sub_1CC8C93FC, (uint64_t)&v139);
        unint64_t v51 = (uint64_t ***)v50;
        unsigned int v52 = *(unsigned __int8 *)(v50 + 16);
        if (v52 != 21)
        {
          if (v52 < 0x1C)
          {
            if (!*(unsigned char *)(v50 + 16))
            {
              uint64_t v53 = v50 | 2;
              goto LABEL_135;
            }
          }
          else
          {
            unsigned int v83 = v52 - 33;
            if (v83 <= 0x33 && ((1 << v83) & 0x8000000000041) != 0)
            {
              uint64_t v53 = v50 | 1;
              goto LABEL_135;
            }
          }
        }
        uint64_t v53 = v50;
LABEL_135:
        std::string v91 = sub_1CC8BB19C((uint64_t)a2, v53, 0, (uint64_t)v2, 0, 0, 1);
        __int16 v92 = v91;
        if ((int)v8 <= 0 && v91 == v2)
        {
          LOBYTE(v139) = 0;
          v131[0] = 0;
          uint64_t PointerDereferenceableBytes = llvm::Value::getPointerDereferenceableBytes(v51, v118, (BOOL *)&v139, v131);
          HIBYTE(v127) = v127;
        }
        else
        {
          uint64_t PointerDereferenceableBytes = *(unsigned int *)((*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v91 + 48))(v91)
                                                        + 20);
          v126[9]();
        }
        if (*(_DWORD *)&v134[8] > 0x40u) {
          uint64_t v94 = **(void **)v134;
        }
        else {
          uint64_t v94 = (uint64_t)(*(void *)v134 << -v134[8]) >> -v134[8];
        }
        unsigned int v95 = (PointerDereferenceableBytes - (v94 & ~(v94 >> 63))) & ~((PointerDereferenceableBytes
                                                                                                  - (v94 & ~(v94 >> 63))) >> 63);
        unsigned int v96 = HIDWORD(v123);
        if (HIDWORD(v123) >= v95) {
          unsigned int v96 = (PointerDereferenceableBytes - (v94 & ~(v94 >> 63))) & ~((PointerDereferenceableBytes - (v94 & ~(v94 >> 63))) >> 63);
        }
        if (v96 <= v123) {
          unsigned int v96 = v123;
        }
        HIDWORD(v123) = v96;
        if (v92 != v2) {
          goto LABEL_157;
        }
        if ((int)v8 <= 0)
        {
          if (v96 <= v95) {
            unsigned int v97 = (PointerDereferenceableBytes - (v94 & ~(v94 >> 63))) & ~((PointerDereferenceableBytes - (v94 & ~(v94 >> 63))) >> 63);
          }
          else {
            unsigned int v97 = v96;
          }
          if (v123 > v95) {
            unsigned int v95 = v123;
          }
          unint64_t v123 = __PAIR64__(v97, v95);
          sub_1CD659FCC((uint64_t)v122);
        }
        else if (v94 < 1)
        {
LABEL_157:
          int v98 = (*(uint64_t (**)(void *))(v122[0] + 16))(v122);
          if (*(_DWORD *)&v134[8] >= 0x41u && *(void *)v134) {
            MEMORY[0x1D25D9CB0](*(void *)v134, 0x1000C8000313F17);
          }
          int v39 = v98 ^ 1;
          goto LABEL_161;
        }
        (*(void (**)(void *))(v122[0] + 40))(v122);
        goto LABEL_157;
      }
      v131[0] = 0;
      if (*(void *)(v11 - 32) != v116)
      {
        uint64_t v139 = 1;
        int64x2_t v140 = v115;
        int64x2_t v141 = v115;
        v142 = (int64_t *)v144;
        uint64_t v143 = 0x400000000;
        *(void *)unint64_t v134 = 1;
        *(int64x2_t *)&v134[8] = v115;
        int64x2_t v135 = v115;
        uint64_t v136 = v138;
        uint64_t v137 = 0x400000000;
        LODWORD(v82) = 1;
        if (llvm::AA::getPotentiallyLoadedValues(a2, v11, &v139, v134, v2, v131, 1))
        {
          if (v143)
          {
            __int16 v103 = v142;
            uint64_t v104 = 8 * v143;
            do
            {
              LODWORD(v82) = 1;
              if (!llvm::AA::isDynamicallyUnique(a2, v117, *v103, (const llvm::Value *)1))
              {
                int v39 = 0;
                goto LABEL_182;
              }
              ++v103;
              v104 -= 8;
            }
            while (v104);
            if (!v143)
            {
              LODWORD(v82) = 0;
              int v39 = 3;
LABEL_182:
              long long v2 = v117;
              goto LABEL_183;
            }
            unsigned int v105 = v142;
            unsigned int v106 = v146;
            uint64_t v82 = 8 * v143;
            long long v2 = v117;
            do
            {
              if (v106 >= v147) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v107 = &v145[16 * v106];
              *(void *)uint64_t v107 = *v105;
              *((void *)v107 + 1) = v12;
              unsigned int v106 = ++v146;
              ++v105;
              v82 -= 8;
            }
            while (v82);
          }
          else
          {
            LODWORD(v82) = 0;
          }
          int v39 = 3;
        }
        else
        {
          int v39 = 0;
        }
LABEL_183:
        if (v136 != v138) {
          free(v136);
        }
        if ((v134[0] & 1) == 0) {
          MEMORY[0x1D25D9CD0](*(void *)&v134[8], 8);
        }
        if (v142 != (int64_t *)v144) {
          free(v142);
        }
        if (v139)
        {
          if (v82) {
            goto LABEL_191;
          }
        }
        else
        {
          MEMORY[0x1D25D9CD0](v140.i64[0], 8);
          if (v82) {
            goto LABEL_191;
          }
        }
        uint64_t v13 = (v8 + 1);
        goto LABEL_161;
      }
LABEL_191:
      uint64_t v13 = (v8 + 1);
      goto LABEL_51;
    }
    unint64_t v30 = *(void *)(v11 - 96);
    unsigned int v31 = *(unsigned __int8 *)(v30 + 16);
    if (v31 == 21)
    {
      std::string v32 = a2;
    }
    else
    {
      std::string v32 = a2;
      if (v31 < 0x1C)
      {
        if (!*(unsigned char *)(v30 + 16)) {
          v30 |= 2uLL;
        }
      }
      else
      {
        unsigned int v54 = v31 - 33;
        BOOL v19 = v54 > 0x33;
        uint64_t v55 = (1 << v54) & 0x8000000000041;
        if (!v19 && v55 != 0) {
          v30 |= 1uLL;
        }
      }
    }
    uint64_t v139 = v30;
    v140.i64[0] = 0;
    AssumedConstant = llvm::Attributor::getAssumedConstant(v32, (const llvm::IRPosition *)&v139, v2, &v121);
    if (v85)
    {
      if (!AssumedConstant) {
        goto LABEL_121;
      }
      int v89 = *((unsigned __int8 *)AssumedConstant + 16);
      if ((v89 - 11) >= 2)
      {
        if (v89 == 16)
        {
          uint64_t v90 = *((unsigned int *)AssumedConstant + 8);
          if (v90 > 0x40)
          {
            int v99 = 0;
            int64_t v100 = (unint64_t)(v90 + 63) >> 6;
            do
            {
              BOOL v19 = v100-- < 1;
              if (v19) {
                break;
              }
              unint64_t v101 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v100);
              v99 += __clz(v101);
            }
            while (!v101);
            int v102 = v90 | 0xFFFFFFC0;
            if ((v90 & 0x3F) == 0) {
              int v102 = 0;
            }
            if (v99 + v102 == v90) {
              goto LABEL_170;
            }
LABEL_132:
            uint64_t v88 = *(void *)(v11 - 64);
          }
          else
          {
            if (*((void *)AssumedConstant + 3)) {
              goto LABEL_132;
            }
LABEL_170:
            uint64_t v88 = *(void *)(v11 - 32);
          }
          if (v146 >= (unint64_t)v147) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          std::string::size_type v16 = &v145[16 * v146];
        }
        else
        {
LABEL_121:
          if (v146 >= (unint64_t)v147) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v86 = &v145[16 * v146];
          *(void *)uint64_t v86 = *(void *)(v11 - 64);
          *((void *)v86 + 1) = v12;
          unsigned int v87 = v146 + 1;
          unsigned int v146 = v87;
          uint64_t v88 = *(void *)(v11 - 32);
          if (v87 >= v147) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          std::string::size_type v16 = &v145[16 * v87];
        }
        *(void *)std::string::size_type v16 = v88;
LABEL_125:
        *((void *)v16 + 1) = v12;
        ++v146;
      }
    }
LABEL_126:
    unsigned int v9 = v146;
    uint64_t v8 = v13;
  }
  while (v146);
  if (v154)
  {
    uint64_t v109 = 24 * v154;
    int64x2_t v110 = v153 + 16;
    do
    {
      if (*v110) {
        llvm::Attributor::recordDependence((uint64_t)a2, *((void *)v110 - 1), (uint64_t)v2, 1);
      }
      v110 += 24;
      v109 -= 24;
    }
    while (v109);
    char v108 = 1;
  }
  else
  {
    char v108 = 1;
  }
LABEL_216:
  if (v145 != (char *)v148) {
    free(v145);
  }
  sub_1CD40B1BC(v151[0]);
  if (v149[0] != v150) {
    free(v149[0]);
  }
  if (v153 != (char *)v155) {
    free(v153);
  }
  if ((v152[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v152[1], 8);
  }
  if (v108)
  {
    uint64_t v111 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v2 + 40))(v2);
    uint64_t v112 = llvm::clampStateAndIndicateChange<llvm::DerefState>(v111, (uint64_t)v122);
  }
  else
  {
    uint64_t v112 = (*(uint64_t (**)(void *))(*((void *)v2 + 4) + 40))((void *)v2 + 4);
  }
  uint64_t v113 = v112;
  v122[0] = &unk_1F2623348;
  sub_1CD40B1BC(v125[0]);
  return v113;
}

unint64_t sub_1CC8D200C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 96);
  if (!v4 || !*(unsigned char *)(v4 + 41))
  {
    unint64_t result = llvm::Attribute::get(a2, 0x4Du, *(unsigned int *)(a1 + 52));
    uint64_t v6 = *(unsigned int *)(a3 + 8);
    unint64_t v7 = (_DWORD *)(a3 + 8);
    if (v6 < *(_DWORD *)(a3 + 12))
    {
      *(void *)(*(void *)a3 + 8 * v6) = result;
      goto LABEL_7;
    }
LABEL_8:
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t result = llvm::Attribute::get(a2, 0x4Cu, *(unsigned int *)(a1 + 52));
  uint64_t v6 = *(unsigned int *)(a3 + 8);
  unint64_t v7 = (_DWORD *)(a3 + 8);
  if (v6 >= *(_DWORD *)(a3 + 12)) {
    goto LABEL_8;
  }
  *(void *)(*(void *)a3 + 8 * v6) = result;
LABEL_7:
  *unint64_t v7 = v6 + 1;
  return result;
}

uint64_t *sub_1CC8D20D0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D2148(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D21D8(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CC8D21E0(uint64_t a1)
{
  return a1 + 32;
}

double sub_1CC8D21E8(uint64_t a1, _OWORD *a2)
{
  *(_OWORD *)(a1 + 16) = *a2;
  *(void *)(a1 + 88) = 256;
  *(void *)(a1 + 96) = 0;
  double result = NAN;
  *(void *)(a1 + 48) = 0xFFFFFFFF00000000;
  *(void *)(a1 + 40) = &unk_1F2623388;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = &unk_1F2620BB0;
  *(void *)a1 = &unk_1F2623288;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = &unk_1F2623308;
  return result;
}

uint64_t sub_1CC8D229C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v11 = sub_1CD4B25C4(a3, a4);
  v48[0] = 0;
  v48[1] = 0;
  int v49 = 0;
  sub_1CBFCB9AC((uint64_t)v48, v11);
  long long v12 = *(_OWORD *)(v11 + 24);
  long long v51 = *(_OWORD *)(v11 + 40);
  long long v50 = v12;
  v44[0] = 0;
  v44[1] = 0;
  int v45 = 0;
  sub_1CBFCB9AC((uint64_t)v44, a3 + 176);
  long long v13 = *(_OWORD *)(a3 + 216);
  long long v46 = *(_OWORD *)(a3 + 200);
  long long v47 = v13;
  uint64_t v14 = a5[3];
  if (a5[4] != v14)
  {
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    while (1)
    {
      unsigned int v17 = *(unint64_t **)(v14 + 8 * v15);
      unint64_t v18 = v17[3];
      if (v18) {
        BOOL v19 = *(unsigned __int8 *)(v18 + 16) >= 0x1Cu;
      }
      else {
        BOOL v19 = 0;
      }
      if (!v19 || !sub_1CD648B2C(a3, v17[3], v48, v44)) {
        goto LABEL_7;
      }
      __int16 v52 = 0;
      uint64_t v20 = (llvm::GlobalValue *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
      unsigned int v21 = sub_1CC8C8E2C(a2, a1, v20, (llvm::MemoryLocation *)v17, (llvm::MemoryLocation *)v18, (unsigned char *)&v52 + 1, &v52);
      uint64_t v22 = (llvm::GlobalValue *)*v17;
      if (*(unsigned char *)(*(void *)v22 + 8) == 15) {
        break;
      }
LABEL_35:
      *(uint32x2_t *)(a6 + 16) = vmax_u32(*(uint32x2_t *)(a6 + 16), (uint32x2_t)vdup_n_s32(v21));
      sub_1CD659FCC(a6);
      if ((_BYTE)v52)
      {
        while (1)
        {
          unint64_t v18 = *(void *)(v18 + 8);
          if (!v18) {
            break;
          }
          uint64_t v53 = (llvm::GlobalValue *)v18;
          sub_1CC61C590(a5, &v53);
        }
      }
LABEL_7:
      uint64_t v14 = a5[3];
      uint64_t v15 = ++v16;
      if (v16 >= (unint64_t)((a5[4] - v14) >> 3)) {
        goto LABEL_43;
      }
    }
    unsigned int v43 = v21;
    llvm::MemoryLocation::getOrNone((uint64_t ***)v18, (uint64_t)&v53);
    if (v55
      && v53 == v22
      && (v54 & 0x8000000000000000) == 0
      && (llvm::Instruction::isVolatile((llvm::Instruction *)v18) & 1) == 0)
    {
      unsigned int v24 = *(_DWORD *)(*(void *)v53 + 8);
      if ((v24 & 0xFE) == 0x12) {
        unsigned int v24 = *(_DWORD *)(**(void **)(*(void *)v53 + 16) + 8);
      }
      uint64_t v25 = *(void *)(*(void *)(a2 + 88) + 120);
      if (v24 < 0x100) {
        goto LABEL_26;
      }
      unsigned int v26 = v24 >> 8;
      uint64_t v27 = *(unsigned int *)(v25 + 240);
      uint64_t v28 = *(void *)(v25 + 232);
      if (v27)
      {
        uint64_t v28 = *(void *)(v25 + 232);
        unint64_t v29 = *(unsigned int *)(v25 + 240);
        do
        {
          unint64_t v30 = v29 >> 1;
          uint64_t v31 = v28 + 16 * (v29 >> 1);
          unsigned int v32 = *(_DWORD *)(v31 + 8);
          uint64_t v33 = v31 + 16;
          v29 += ~(v29 >> 1);
          if (v32 < v26) {
            uint64_t v28 = v33;
          }
          else {
            unint64_t v29 = v30;
          }
        }
        while (v29);
      }
      if (v28 == *(void *)(v25 + 232) + 16 * v27 || *(_DWORD *)(v28 + 8) != v26) {
LABEL_26:
      }
        uint64_t v28 = *(void *)(v25 + 232);
      unsigned int v57 = *(_DWORD *)(v28 + 12);
      if (v57 > 0x40) {
        operator new[]();
      }
      BOOL v56 = 0;
      uint64_t v34 = llvm::Value::stripAndAccumulateConstantOffsets(v53, (llvm::DataLayout *)v25, (llvm::APInt *)&v56, 1, 0, 0, v23);
      int v35 = v34;
      if (v57 > 0x40)
      {
        uint64_t v42 = *v56;
        MEMORY[0x1D25D9CB0]();
        uint64_t v36 = v42;
        if (v35)
        {
LABEL_30:
          unsigned int v41 = (uint64_t *)v36;
          if (v35 == (llvm::GlobalValue *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)))
          {
            unint64_t v37 = v54 & 0x7FFFFFFFFFFFFFFFLL;
            BOOL v56 = v41;
            char v38 = sub_1CD65A160((uint64_t **)(a6 + 24), (uint64_t)v41, &v56);
            int v39 = v38[5];
            if ((unint64_t)v39 <= v37) {
              int v39 = (uint64_t *)v37;
            }
            v38[5] = v39;
            sub_1CD659FCC(a6);
          }
        }
      }
      else
      {
        uint64_t v36 = (uint64_t)((void)v56 << -(char)v57) >> -(char)v57;
        if (v34) {
          goto LABEL_30;
        }
      }
    }
    unsigned int v21 = v43;
    goto LABEL_35;
  }
LABEL_43:
  MEMORY[0x1D25D9CD0](v44[0], 8);
  return MEMORY[0x1D25D9CD0](v48[0], 8);
}

uint64_t sub_1CC8D2668(uint64_t *a1, uint64_t a2)
{
  if (a2 && *(unsigned char *)(a2 + 16) == 30 && (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3)
  {
    uint64_t v2 = *a1;
    unsigned int v3 = *(_DWORD *)(*a1 + 8);
    if (v3 >= *(_DWORD *)(*a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v2 + 8 * v3) = a2;
    ++*(_DWORD *)(v2 + 8);
  }
  return 1;
}

uint64_t sub_1CC8D26F8(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v3 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  uint64_t v4 = a2 + 1;
  unint64_t v5 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      sub_1CD65A22C((void **)a1, v3, v5[4], (_OWORD *)v5 + 2);
      uint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          unint64_t v5 = v7;
        }
        while (!v8);
      }
      unint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

uint64_t sub_1CC8D279C(void *a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  uint64_t v14 = &v16;
  uint64_t v15 = 0;
  if (!*((_DWORD *)a2 + 4))
  {
    unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
    goto LABEL_3;
  }
  sub_1CD41B598((uint64_t)&v14, (uint64_t)(a2 + 1));
  unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
  if (!v15)
  {
LABEL_3:
    uint64_t v4 = v13;
    unsigned int v5 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
    if (v5 < 0x15 || v5 == 24) {
      goto LABEL_9;
    }
  }
  unsigned int v3 = *((_DWORD *)v14 + v3 + 1);
  if ((v3 & 0x80000000) != 0)
  {
LABEL_12:
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = v13;
LABEL_9:
  uint64_t v7 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v3);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = a1[1];
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 >= *(_DWORD *)(v8 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  std::string::size_type v10 = (void *)(*(void *)v8 + 16 * v9);
  *std::string::size_type v10 = v7;
  v10[1] = v4;
  ++*(_DWORD *)(v8 + 8);
  uint64_t v11 = 1;
LABEL_13:
  if (v14 != &v16) {
    free(v14);
  }
  return v11;
}

uint64_t sub_1CC8D28C0(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8D2930(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D29C0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C080, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C080))
  {
    __cxa_guard_release(&qword_1EA61C080);
  }
}

uint64_t sub_1CC8D2A14(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  v8[3] = (void *)256;
  void v8[4] = 0;
  v7[0] = &unk_1F2623348;
  void v7[2] = 0xFFFFFFFF00000000;
  v8[0] = 0;
  v8[1] = 0;
  v7[1] = &unk_1F2623388;
  void v7[3] = v8;
  void v8[2] = &unk_1F2620BB0;
  LOBYTE(v13[0]) = 0;
  char v14 = 0;
  int v12 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  v11[0] = &v12;
  v11[1] = a2;
  v11[2] = a1;
  v11[3] = v13;
  if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8D2E34, (uint64_t)v11, a1, 1, &v10))
  {
    if (!v14) {
      goto LABEL_7;
    }
    sub_1CC8D2D30((uint64_t)v9, v7, (uint64_t)v13);
    v9[0] = &unk_1F2623348;
    sub_1CD40B1BC((void *)v9[4]);
  }
  else
  {
    (*(void (**)(void *))(v7[0] + 40))(v7);
  }
  if (v14)
  {
    v13[0] = &unk_1F2623348;
    sub_1CD40B1BC((void *)v13[4]);
  }
LABEL_7:
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v5 = llvm::clampStateAndIndicateChange<llvm::DerefState>(v4, (uint64_t)v7);
  v7[0] = &unk_1F2623348;
  sub_1CD40B1BC(v8[0]);
  return v5;
}

uint64_t *sub_1CC8D2C28(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D2CA0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D2D30(uint64_t a1, void *a2, uint64_t a3)
{
  (*(void (**)(void *, void))(a2[1] + 48))(a2 + 1, *(unsigned int *)(a3 + 20));
  uint64_t v6 = a2[6];
  a2 += 6;
  (*(void (**)(void *, void))(v6 + 48))(a2, *(unsigned __int8 *)(a3 + 57));
  *(void *)a1 = &unk_1F2623348;
  uint64_t v7 = *(a2 - 4);
  *(void *)(a1 + 8) = &unk_1F2623388;
  *(void *)(a1 + 16) = v7;
  uint64_t result = sub_1CC8D26F8(a1 + 24, a2 - 3);
  *(_WORD *)(a1 + 56) = *((_WORD *)a2 + 4);
  *(void *)(a1 + 48) = &unk_1F2620BB0;
  *(void *)(a1 + 64) = a2[2];
  return result;
}

uint64_t sub_1CC8D2E34(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  uint64_t v11 = v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v14 = v10;
    uint64_t v15 = &v17;
    uint64_t v16 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v15, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v14 = v3;
    uint64_t v15 = &v17;
    uint64_t v16 = 0;
  }
  uint64_t v17 = sub_1CD659800((uint64_t)&v14, **(_DWORD **)a1);
  uint64_t v18 = v4;
  if (v15 != &v17) {
    free(v15);
  }
  if (sub_1CD647DEC(&v17))
  {
    uint64_t v7 = sub_1CC8BB19C(*(void *)(a1 + 8), v17, v18, *(void *)(a1 + 16), 0, 0, 1);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    uint64_t v9 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v9 + 72))
    {
      sub_1CD65A058((uint64_t)v13, (void *)v9, v8);
      v13[0] = &unk_1F2623348;
      sub_1CD40B1BC((void *)v13[4]);
    }
    else
    {
      sub_1CD65A454(*(void *)(a1 + 24), v8);
    }
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (v11 != v13) {
    free(v11);
  }
  return v5;
}

uint64_t sub_1CC8D2FD0(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8D3040(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D30D0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C088, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C088))
  {
    __cxa_guard_release(&qword_1EA61C088);
  }
}

uint64_t sub_1CC8D3124(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  v8[3] = (void *)256;
  void v8[4] = 0;
  v7[0] = &unk_1F2623348;
  void v7[2] = 0xFFFFFFFF00000000;
  v8[0] = 0;
  v8[1] = 0;
  v7[1] = &unk_1F2623388;
  void v7[3] = v8;
  void v8[2] = &unk_1F2620BB0;
  uint64_t v13 = 0;
  LOBYTE(v11[0]) = 0;
  char v12 = 0;
  v10[0] = &v13;
  v10[1] = a2;
  void v10[2] = a1;
  v10[3] = v11;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8D342C, (uint64_t)v10, a1))
  {
    if (!v12) {
      goto LABEL_7;
    }
    sub_1CC8D2D30((uint64_t)v9, v7, (uint64_t)v11);
    v9[0] = &unk_1F2623348;
    sub_1CD40B1BC((void *)v9[4]);
  }
  else
  {
    (*(void (**)(void *))(v7[0] + 40))(v7);
  }
  if (v12)
  {
    v11[0] = &unk_1F2623348;
    sub_1CD40B1BC((void *)v11[4]);
  }
LABEL_7:
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v5 = llvm::clampStateAndIndicateChange<llvm::DerefState>(v4, (uint64_t)v7);
  v7[0] = &unk_1F2623348;
  sub_1CD40B1BC(v8[0]);
  return v5;
}

uint64_t *sub_1CC8D3324(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D339C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D342C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 != 21)
  {
    if (v4 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v5 = v4 - 33;
      BOOL v6 = v5 > 0x33;
      uint64_t v7 = (1 << v5) & 0x8000000000041;
      if (!v6 && v7 != 0)
      {
        uint64_t v3 = 0;
        a2 |= 1uLL;
      }
    }
  }
  uint64_t v9 = sub_1CC8BB19C(*(void *)(a1 + 8), a2, v3, *(void *)(a1 + 16), 0, 0, 1);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v11 + 72))
  {
    sub_1CD65A058((uint64_t)v13, (void *)v11, v10);
    v13[0] = &unk_1F2623348;
    sub_1CD40B1BC((void *)v13[4]);
  }
  else
  {
    sub_1CD65A454(*(void *)(a1 + 24), v10);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
}

uint64_t sub_1CC8D3558(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8D35C8(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D3658()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C090, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C090))
  {
    __cxa_guard_release(&qword_1EA61C090);
  }
}

uint64_t sub_1CC8D36AC(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD648A0C(v4);
  if (v6)
  {
    uint64_t v9 = sub_1CC8BB19C(a2, v6 | 1, 0, a1, 0, 0, 1);
    uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
    return llvm::clampStateAndIndicateChange<llvm::DerefState>(v5, v10);
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v5 + 40);
    return v7(v5);
  }
}

uint64_t *sub_1CC8D37B0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D3828(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D38B8(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8D3928(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 64));
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D39B8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C098, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C098))
  {
    __cxa_guard_release(&qword_1EA61C098);
  }
}

uint64_t *sub_1CC8D3A0C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D3A84(uint64_t a1)
{
  *(void *)a1 = &unk_1F2623348;
  sub_1CD40B1BC(*(void **)(a1 + 32));
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D3B14(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D3B58(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D3BBC(uint64_t a1, uint64_t a2)
{
  v51[4] = *MEMORY[0x1E4F143B8];
  long long v46 = v48;
  uint64_t v47 = 0x400000000;
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  LODWORD(v41[0]) = 74;
  llvm::IRPosition::getAttrs((llvm::IRPosition *)(a1 + 16), (unsigned int *)v41, 1, (uint64_t)&v46, 0, 0);
  if (v47)
  {
    uint64_t v5 = (unint64_t *)v46;
    int8x16_t v6 = *(int8x16_t *)(a1 + 40);
    uint64_t v7 = 8 * v47;
    do
    {
      unint64_t v8 = *v5;
      if (*v5) {
        unint64_t v8 = *(void *)(v8 + 16);
      }
      int8x16_t v9 = (int8x16_t)vdupq_n_s64(v8);
      int8x16_t v6 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v6, (uint64x2_t)v9), v6, v9);
      ++v5;
      v7 -= 8;
    }
    while (v7);
    *(int8x16_t *)(a1 + 40) = v6;
  }
  uint64_t v10 = (llvm::Value *)sub_1CD6482F0(v4);
  int8x16_t v11 = (int8x16_t)vdupq_n_s64(1 << llvm::Value::getPointerAlignment(v10, *(const llvm::DataLayout **)(*(void *)(a2 + 88) + 120)));
  *(int8x16_t *)(a1 + 40) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)(a1 + 40), (uint64x2_t)v11), *(int8x16_t *)(a1 + 40), v11);
  unsigned int v12 = sub_1CD647DEC(v4);
  if (v12 > 6
    || ((1 << v12) & 0x54) == 0
    || sub_1CD6482A0(v4) && (uint64_t v33 = (llvm::GlobalValue *)sub_1CD648A0C(v4), sub_1CD64EF44(a2, v33)))
  {
    unint64_t v13 = sub_1CC8AB830(v4);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      v41[0] = 0;
      v41[1] = 0;
      int v42 = 0;
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      uint64_t v43 = 0;
      for (uint64_t i = *(uint64_t **)(sub_1CD6482F0(v4) + 8); i; uint64_t i = (uint64_t *)i[1])
      {
        int v49 = i;
        sub_1CC61C590(v41, &v49);
      }
      uint64_t v17 = *(void *)(a2 + 88) + 136;
      sub_1CC8D5498(a1, a2, v17, v14, v41, v15);
      if (((*(uint64_t (**)(uint64_t))(*(void *)v15 + 24))(v15) & 1) == 0)
      {
        int v49 = v51;
        uint64_t v50 = 0x400000000;
        unsigned int v40 = &v49;
        sub_1CD65952C(v17, v14, (unsigned int (*)(uint64_t))sub_1CC8D59CC, (uint64_t)&v40);
        uint64_t v18 = v49;
        if (v50)
        {
          BOOL v19 = &v49[v50];
          int64x2_t v35 = vdupq_n_s64(0x100000000uLL);
          uint64_t v34 = v19;
          do
          {
            uint64_t v20 = *v18;
            char v38 = &unk_1F2623850;
            int64x2_t v39 = v35;
            int v21 = *(_DWORD *)(v20 + 20);
            if ((v21 & 0x40000000) != 0)
            {
              uint64_t v23 = *(void *)(v20 - 8);
              uint64_t v22 = v21 & 0x7FFFFFF;
            }
            else
            {
              uint64_t v22 = v21 & 0x7FFFFFF;
              uint64_t v23 = v20 - 32 * v22;
            }
            uint64_t v24 = v22 == 3;
            if (v22 == v24)
            {
              uint64_t v25 = 0x100000000;
            }
            else
            {
              unsigned int v26 = (uint64_t *)(v23 + 32 * v22);
              uint64_t v27 = (uint64_t *)(v23 + 32 * v24);
              do
              {
                uint64_t v28 = *v27;
                long long v37 = xmmword_1CFB27360;
                uint64_t v36 = &unk_1F2623850;
                unint64_t v29 = &v44[-v43];
                uint64_t v30 = *(void *)(v28 + 48);
                if (v30) {
                  uint64_t v31 = v30 - 24;
                }
                else {
                  uint64_t v31 = 0;
                }
                sub_1CC8D5498(a1, a2, v17, v31, v41, (uint64_t)&v36);
                for (j = &v29[v43]; v44 != j; j = sub_1CD659618((uint64_t)v41, j))
                  ;
                (*((void (**)(void **, void, void))v38 + 9))(&v38, *((void *)&v37 + 1), v37);
                v27 += 4;
              }
              while (v27 != v26);
              uint64_t v25 = v39.i64[0];
              BOOL v19 = v34;
            }
            (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 56))(v15, v25);
            ++v18;
          }
          while (v18 != v19);
          uint64_t v18 = v49;
        }
        if (v18 != v51) {
          free(v18);
        }
      }
      sub_1CD456CB4(v41);
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 40))();
  }
  if (v46 != v48) {
    free(v46);
  }
}

void sub_1CC8D4020(uint64_t a1@<X0>, char *a2@<X8>)
{
  if (*(void *)(a1 + 48))
  {
    std::to_string(&v14, *(void *)(a1 + 40));
    unsigned int v4 = std::string::insert(&v14, 0, "align<");
    std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v15.__r_.__value_.__r.__words[2] = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    int8x16_t v6 = std::string::append(&v15, "-");
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v16.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&__p, *(void *)(a1 + 48));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v10 = std::string::append(&v16, (const std::string::value_type *)p_p, size);
    std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v17.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v17.__r_.__value_.__r.__words[2] = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    unsigned int v12 = std::string::append(&v17, ">");
    *(std::string *)a2 = *v12;
    v12->__r_.__value_.__r.__words[0] = 0;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v16.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    a2[23] = 13;
    strcpy(a2, "unknown-align");
  }
}

uint64_t sub_1CC8D41A0(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v5 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  uint64_t v6 = *(void *)(v5 + 8);
  if (v6)
  {
    unint64_t v13 = (__guard *)&unk_1EBCDDE98;
    unsigned int v7 = 1;
    do
    {
      uint64_t v14 = *(void *)(v6 + 24);
      int v15 = *(unsigned __int8 *)(v14 + 16);
      if (v14 && v15 == 61)
      {
        if (*(void *)(v14 - 32) == v5
          && (unint64_t)(1 << ((unint64_t)*(unsigned __int16 *)(v14 + 18) >> 1)) < *(void *)(a1 + 48))
        {
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCDDE90, memory_order_acquire) & 1) == 0)
          {
            uint64_t v21 = v14;
            unint64_t v23 = v5;
            uint64_t v18 = v13;
            int v19 = __cxa_guard_acquire(&qword_1EBCDDE90);
            unint64_t v13 = v18;
            uint64_t v14 = v21;
            unint64_t v5 = v23;
            if (v19)
            {
              __cxa_guard_release(&qword_1EBCDDE90);
              uint64_t v14 = v21;
              unint64_t v5 = v23;
              unint64_t v13 = v18;
            }
          }
          unsigned int v7 = 0;
          *(_WORD *)(v14 + 18) = *(_WORD *)(v14 + 18) & 0xFF81 | (2 * (63 - __clz(*(void *)(a1 + 48))));
        }
      }
      else if (v14)
      {
        if (v15 == 60 && *(void *)(v14 - 32) == v5)
        {
          unint64_t v16 = *(unsigned __int16 *)(v14 + 18);
          unint64_t v17 = *(void *)(a1 + 48);
          if (1 << (v16 >> 1) < v17)
          {
            *(_WORD *)(v14 + 18) = v16 & 0xFF81 | (2 * __clz(v17)) ^ 0x7E;
            if (atomic_load_explicit((atomic_uchar *volatile)v13, memory_order_acquire))
            {
              unsigned int v7 = 0;
            }
            else
            {
              uint64_t v22 = v6;
              unint64_t v24 = v5;
              uint64_t v20 = v13;
              if (__cxa_guard_acquire(v13))
              {
                __cxa_guard_release(v20);
                unint64_t v13 = v20;
                unsigned int v7 = 0;
                unint64_t v5 = v24;
              }
              else
              {
                unsigned int v7 = 0;
                unint64_t v5 = v24;
                unint64_t v13 = v20;
              }
              uint64_t v6 = v22;
            }
          }
        }
      }
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while (v6);
  }
  else
  {
    unsigned int v7 = 1;
  }
  int v8 = sub_1CD65A914(a1, a2);
  int8x16_t v9 = (llvm::Value *)sub_1CD6482F0(v4);
  char PointerAlignment = llvm::Value::getPointerAlignment(v9, *(const llvm::DataLayout **)(*(void *)(a2 + 88) + 120));
  if (v8) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = (unint64_t)(1 << PointerAlignment) >= *(void *)(a1 + 48);
  }
  if (v11) {
    return v7;
  }
  else {
    return 0;
  }
}

void sub_1CC8D43C4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0A0))
  {
    __cxa_guard_release(&qword_1EA61C0A0);
  }
}

uint64_t sub_1CC8D4418(uint64_t a1, llvm::Attributor *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = (llvm::AbstractAttribute *)a1;
  v151[12] = *MEMORY[0x1E4F143B8];
  unsigned int v119 = *(llvm::DataLayout **)(*((void *)a2 + 11) + 120);
  int8x16_t v125 = (int8x16_t)xmmword_1CFB27360;
  unsigned int v124 = (void (**)(void **))&unk_1F2623850;
  BOOL v123 = 0;
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 24);
  unint64_t v6 = sub_1CC8AB830((_DWORD *)(a1 + 16));
  v128[0] = v4;
  v128[1] = v5;
  v148[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v148[i] = -4096;
  v149 = (char *)v151;
  uint64_t v150 = 0x400000000;
  unint64_t v8 = sub_1CD6482F0((llvm::IRPosition *)v128);
  int v9 = 0;
  v145[0] = v146;
  v145[1] = (void *)0x1000000000;
  v147[1] = 0;
  v147[0] = 0;
  v146[32] = v147;
  int64x2_t v141 = (char *)v144;
  unsigned int v143 = 16;
  v144[0] = v8;
  v144[1] = v6;
  unint64_t v118 = v8;
  int64x2_t v117 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v10 = 1;
  unsigned int v120 = v2;
  BOOL v121 = v3;
  do
  {
    BOOL v11 = &v141[16 * v10];
    uint64_t v13 = *((void *)v11 - 2);
    unint64_t v12 = *((void *)v11 - 1);
    unsigned int v142 = v10 - 1;
    v127[0] = v13;
    v127[1] = v12;
    if ((sub_1CD65837C((uint64_t)v145, v127) & 0x100000000) == 0) {
      goto LABEL_107;
    }
    if (v9 >= 16) {
      goto LABEL_205;
    }
    int v122 = v9 + 1;
    if (*(unsigned char *)(*(void *)v13 + 8) != 15)
    {
      unsigned int v17 = *(unsigned __int8 *)(v13 + 16);
      if (v17 < 0x1C) {
        goto LABEL_33;
      }
      unsigned int v18 = v17 - 33;
      BOOL v19 = v18 > 0x33;
      uint64_t v20 = (1 << v18) & 0x8000000000041;
      if (v19 || v20 == 0) {
        goto LABEL_33;
      }
      uint64_t v22 = *(void *)(v13 - 32);
      if (!v22 || *(unsigned char *)(v22 + 16) || *(void *)(v22 + 24) != *(void *)(v13 + 72)) {
        goto LABEL_33;
      }
      if (*(_WORD *)(v22 + 18))
      {
        llvm::Function::BuildLazyArguments(*(llvm::Function **)(v13 - 32));
        uint64_t v23 = *(void *)(v22 + 88);
        if (*(_WORD *)(v22 + 18))
        {
          llvm::Function::BuildLazyArguments((llvm::Function *)v22);
          uint64_t v24 = *(void *)(v22 + 88);
LABEL_25:
          uint64_t v25 = v24 + 40 * *(void *)(v22 + 96);
          while (v23 != v25)
          {
            uint64_t v26 = *(void *)(*(void *)(v23 + 24) + 112);
            if (v26)
            {
              uint64_t v27 = *(unsigned int *)(v23 + 32);
              if ((v27 + 2) < *(_DWORD *)(v26 + 8))
              {
                uint64_t v28 = *(void *)(v26 + 8 * (v27 + 2) + 40);
                if (v28)
                {
                  if ((*(unsigned char *)(v28 + 17) & 0x40) != 0)
                  {
                    uint64_t v14 = *(llvm::Value **)(v13 - 32 * (*(_DWORD *)(v13 + 20) & 0x7FFFFFF) + 32 * v27);
                    goto LABEL_8;
                  }
                }
              }
            }
            v23 += 40;
          }
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v23 = *(void *)(v22 + 88);
      }
      uint64_t v24 = v23;
      goto LABEL_25;
    }
    uint64_t v14 = llvm::Value::stripPointerCasts((llvm::Value *)v13);
LABEL_8:
    if (v14) {
      BOOL v15 = v14 == (llvm::Value *)v13;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15) {
      goto LABEL_12;
    }
LABEL_33:
    int v29 = *(unsigned __int8 *)(v13 + 16);
    switch(v29)
    {
      case 83:
        uint64_t v35 = *(void *)(*(void *)(v13 + 40) + 56);
        uint64_t v129 = v35;
        int v130 = 0;
        sub_1CD645794((uint64_t)&v136, (uint64_t)v148, &v129, &v130);
        uint64_t v36 = v136;
        if (BYTE8(v137[0]))
        {
          *(_DWORD *)&v131[20] = 0;
          *(_DWORD *)&v131[17] = 0;
          *(void *)uint64_t v131 = v35;
          *(void *)&BOOL v131[8] = 0;
          v131[16] = 0;
          if (v150 >= HIDWORD(v150))
          {
            if (v149 > v131 || &v149[24 * v150] <= v131) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v37 = (uint64_t)v2;
          uint64_t v45 = &v149[24 * v150];
          long long v46 = *(_OWORD *)v131;
          *((void *)v45 + 2) = *(void *)&v131[16];
          *(_OWORD *)uint64_t v45 = v46;
          int v38 = v150;
          LODWORD(v150) = v150 + 1;
          *(_DWORD *)(v36 + 8) = v38;
        }
        else
        {
          uint64_t v37 = (uint64_t)v2;
          int v38 = *(_DWORD *)(v136 + 8);
        }
        uint64_t v47 = v149;
        unsigned int v48 = &v149[24 * v38];
        uint64_t v50 = *((void *)v48 + 1);
        int v49 = (llvm::AbstractAttribute **)(v48 + 8);
        if (!v50) {
          *int v49 = sub_1CC8AC178(v37, v35, 0, (uint64_t)v3, 2, 0, 1);
        }
        uint64_t v51 = *(_DWORD *)(v13 + 20) & 0x7FFFFFF;
        if (!v51)
        {
          int v9 = v122;
          uint64_t v2 = (llvm::Attributor *)v37;
          goto LABEL_107;
        }
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        uint64_t v54 = &v47[24 * v38 + 16];
        uint64_t v55 = 8 * v51;
        do
        {
          int v56 = *(_DWORD *)(v13 + 20);
          if ((v56 & 0x40000000) != 0) {
            uint64_t v57 = *(void *)(v13 - 8);
          }
          else {
            uint64_t v57 = v13 - 32 * (v56 & 0x7FFFFFF);
          }
          uint64_t v58 = *(void *)(v57 + 32 * *(unsigned int *)(v13 + 60) + v53);
          if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v49 + 168))(*v49, v58, *(void *)(v13 + 40)))
          {
            *uint64_t v54 = 1;
            v123 |= (*(unsigned __int8 (**)(void))(*((void *)*v49 + 4) + 24))() ^ 1;
          }
          else
          {
            int v59 = *(_DWORD *)(v13 + 20);
            if ((v59 & 0x40000000) != 0) {
              uint64_t v60 = *(void *)(v13 - 8);
            }
            else {
              uint64_t v60 = v13 - 32 * (v59 & 0x7FFFFFF);
            }
            uint64_t v61 = *(void *)(v58 + 40);
            if (v61 == v58 + 40)
            {
              uint64_t v63 = 0;
            }
            else
            {
              if (v61) {
                uint64_t v62 = v61 - 24;
              }
              else {
                uint64_t v62 = 0;
              }
              if (*(unsigned __int8 *)(v62 + 16) - 29 >= 0xB) {
                uint64_t v63 = 0;
              }
              else {
                uint64_t v63 = v62;
              }
            }
            uint64_t v64 = *(void *)(v60 + v52);
            if (v142 >= (unint64_t)v143) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v65 = &v141[16 * v142];
            *(void *)uint64_t v65 = v64;
            *((void *)v65 + 1) = v63;
            ++v142;
          }
          v53 += 8;
          v52 += 32;
        }
        while (v55 != v53);
        uint64_t v2 = v120;
        uint64_t v3 = v121;
LABEL_100:
        int v9 = v122;
        goto LABEL_107;
      case 85:
        unint64_t v30 = *(void *)(v13 - 96);
        unsigned int v31 = *(unsigned __int8 *)(v30 + 16);
        if (v31 != 21)
        {
          if (v31 < 0x1C)
          {
            if (!*(unsigned char *)(v30 + 16)) {
              v30 |= 2uLL;
            }
          }
          else
          {
            unsigned int v32 = v31 - 33;
            BOOL v19 = v32 > 0x33;
            uint64_t v33 = (1 << v32) & 0x8000000000041;
            if (!v19 && v33 != 0) {
              v30 |= 1uLL;
            }
          }
        }
        uint64_t v136 = v30;
        *(void *)&v137[0] = 0;
        AssumedConstant = llvm::Attributor::getAssumedConstant(v2, (const llvm::IRPosition *)&v136, v3, &v123);
        if (!v71) {
          goto LABEL_100;
        }
        if (!AssumedConstant) {
          goto LABEL_102;
        }
        int v75 = *((unsigned __int8 *)AssumedConstant + 16);
        if ((v75 - 11) < 2) {
          goto LABEL_100;
        }
        if (v75 != 16)
        {
LABEL_102:
          if (v142 >= (unint64_t)v143) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v72 = &v141[16 * v142];
          *(void *)uint64_t v72 = *(void *)(v13 - 64);
          *((void *)v72 + 1) = v12;
          unsigned int v73 = v142 + 1;
          unsigned int v142 = v73;
          uint64_t v74 = *(void *)(v13 - 32);
          if (v73 >= v143) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          ++v9;
          unint64_t v16 = &v141[16 * v73];
LABEL_105:
          *(void *)unint64_t v16 = v74;
LABEL_106:
          *((void *)v16 + 1) = v12;
          ++v142;
          goto LABEL_107;
        }
        uint64_t v76 = *((unsigned int *)AssumedConstant + 8);
        if (v76 > 0x40)
        {
          int v95 = 0;
          int64_t v96 = (unint64_t)(v76 + 63) >> 6;
          do
          {
            BOOL v19 = v96-- < 1;
            if (v19) {
              break;
            }
            unint64_t v97 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v96);
            v95 += __clz(v97);
          }
          while (!v97);
          int v98 = v76 | 0xFFFFFFC0;
          if ((v76 & 0x3F) == 0) {
            int v98 = 0;
          }
          if (v95 + v98 != v76) {
            goto LABEL_113;
          }
        }
        else if (*((void *)AssumedConstant + 3))
        {
LABEL_113:
          uint64_t v74 = *(void *)(v13 - 64);
LABEL_148:
          if (v142 >= (unint64_t)v143) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          ++v9;
          unint64_t v16 = &v141[16 * v142];
          goto LABEL_105;
        }
        uint64_t v74 = *(void *)(v13 - 32);
        goto LABEL_148;
      case 21:
        int64x2_t v39 = (llvm::Argument *)v13;
        break;
      default:
        int64x2_t v39 = 0;
        break;
    }
    uint64_t v129 = (uint64_t)v39;
    if (v39 && (llvm::Argument::hasPassPointeeByValueCopyAttr(v39) & 1) == 0)
    {
      uint64_t v136 = (uint64_t)v137 + 8;
      *(void *)&v137[0] = 0x300000000;
      char v126 = 0;
      *(void *)uint64_t v131 = &v129;
      *(void *)&BOOL v131[8] = &v136;
      int v40 = llvm::Attributor::checkForAllCallSites((uint64_t)v2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8D5A5C, (uint64_t)v131, *(void *)(v129 + 24), 1, (uint64_t)v3, &v126);
      char v41 = v40;
      int v42 = 0;
      if (v40)
      {
        sub_1CD3D61B4((unsigned int *)&v141, (unsigned char *)v136, (unsigned char *)(v136 + 16 * LODWORD(v137[0])));
        int v42 = 3;
      }
      if ((_OWORD *)v136 != (_OWORD *)((char *)v137 + 8)) {
        free((void *)v136);
      }
      if (v41) {
        goto LABEL_54;
      }
    }
    unsigned int v43 = *(unsigned __int8 *)(v13 + 16);
    if (v43 < 0x15) {
      goto LABEL_56;
    }
    uint64_t v66 = v13;
    if (v43 >= 0x1C)
    {
      unsigned int v67 = v43 - 33;
      uint64_t v66 = v13;
      if (v67 <= 0x33)
      {
        uint64_t v66 = v13;
        if (((1 << v67) & 0x8000000000041) != 0) {
          uint64_t v66 = v13 | 1;
        }
      }
    }
    uint64_t v136 = v66;
    *(void *)&v137[0] = 0;
    unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)&v136, v3, &v123);
    if (!v69) {
      goto LABEL_100;
    }
    uint64_t v14 = (llvm::Value *)AssumedSimplified;
    if (AssumedSimplified && v13 != AssumedSimplified)
    {
LABEL_12:
      if (v142 >= (unint64_t)v143) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      ++v9;
      unint64_t v16 = &v141[16 * v142];
      *(void *)unint64_t v16 = v14;
      goto LABEL_106;
    }
    unsigned int v43 = *(unsigned __int8 *)(v13 + 16);
    if (v43 != 60) {
      goto LABEL_56;
    }
    LOBYTE(v129) = 0;
    if (*(void *)(v13 - 32) == v118)
    {
      unsigned int v43 = 60;
LABEL_56:
      if (v43 <= 0x13 && ((1 << v43) & 0x81800) != 0)
      {
        int v44 = 1;
        ++v9;
LABEL_199:
        int v42 = v44 ^ 1;
        goto LABEL_200;
      }
      uint64_t v77 = v13;
      if (v43 != 21)
      {
        if (v43 < 0x1C)
        {
          if (v43) {
            uint64_t v77 = v13;
          }
          else {
            uint64_t v77 = v13 | 2;
          }
        }
        else
        {
          unsigned int v78 = v43 - 33;
          uint64_t v77 = v13;
          if (v78 <= 0x33)
          {
            uint64_t v77 = v13;
            if (((1 << v78) & 0x8000000000041) != 0) {
              uint64_t v77 = v13 | 1;
            }
          }
        }
      }
      unsigned int v79 = sub_1CC8BA1F4((uint64_t)v2, v77, 0, (uint64_t)v3, 0, 0, 1);
      if (v9 <= 0 && v79 == v3)
      {
        unsigned int v81 = *(_DWORD *)(*(void *)v13 + 8);
        if ((v81 & 0xFE) == 0x12) {
          unsigned int v81 = *(_DWORD *)(**(void **)(*(void *)v13 + 16) + 8);
        }
        if (v81 < 0x100) {
          goto LABEL_135;
        }
        unsigned int v82 = v81 >> 8;
        uint64_t v83 = *((unsigned int *)v119 + 60);
        uint64_t v84 = *((void *)v119 + 29);
        if (v83)
        {
          uint64_t v84 = *((void *)v119 + 29);
          unint64_t v85 = *((unsigned int *)v119 + 60);
          do
          {
            unint64_t v86 = v85 >> 1;
            uint64_t v87 = v84 + 16 * (v85 >> 1);
            unsigned int v88 = *(_DWORD *)(v87 + 8);
            uint64_t v89 = v87 + 16;
            v85 += ~(v85 >> 1);
            if (v88 < v82) {
              uint64_t v84 = v89;
            }
            else {
              unint64_t v85 = v86;
            }
          }
          while (v85);
        }
        if (v84 == *((void *)v119 + 29) + 16 * v83 || *(_DWORD *)(v84 + 8) != v82) {
LABEL_135:
        }
          uint64_t v84 = *((void *)v119 + 29);
        LODWORD(v137[0]) = *(_DWORD *)(v84 + 12);
        if (LODWORD(v137[0]) > 0x40) {
          operator new[]();
        }
        uint64_t v136 = 0;
        uint64_t v90 = llvm::Value::stripAndAccumulateConstantOffsets((llvm::GlobalValue *)v13, v119, (llvm::APInt *)&v136, 1, 0, 0, v80);
        std::string v91 = v90;
        if (LODWORD(v137[0]) > 0x40)
        {
          uint64_t v92 = *(void *)v136;
          MEMORY[0x1D25D9CB0]();
          if (v91) {
            goto LABEL_187;
          }
LABEL_139:
          uint64_t v93 = 1 << llvm::Value::getPointerAlignment((llvm::Value *)v13, v119);
          ++v9;
        }
        else
        {
          uint64_t v92 = v136 << -(uint64_t)LODWORD(v137[0]) >> -(uint64_t)LODWORD(v137[0]);
          if (!v90) {
            goto LABEL_139;
          }
LABEL_187:
          unsigned __int8 PointerAlignment = llvm::Value::getPointerAlignment(v91, v119);
          if ((int)v92 >= 0) {
            unsigned int v106 = v92;
          }
          else {
            unsigned int v106 = -(int)v92;
          }
          if (PointerAlignment <= 0x1Fu)
          {
            uint64_t v108 = 1 << PointerAlignment;
            ++v9;
            do
            {
              unsigned int v107 = v108;
              LODWORD(v108) = v106 % v108;
              unsigned int v106 = v107;
            }
            while (v108);
          }
          else
          {
            unsigned int v107 = v106;
            ++v9;
          }
          uint64_t v109 = 1 << ~__clz(v107);
          if (v107) {
            LODWORD(v93) = v109;
          }
          else {
            LODWORD(v93) = 0;
          }
        }
        int8x16_t v110 = (int8x16_t)vdupq_n_s64(v93);
        int8x16_t v125 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v125, (uint64x2_t)v110), v125, v110);
        v124[5]((void **)&v124);
      }
      else
      {
        uint64_t v94 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v79 + 48))(v79);
        ((void (*)(void (***)(void **), void))v124[6])(&v124, *(void *)(v94 + 16));
        ++v9;
      }
      int v44 = ((uint64_t (*)(void **))v124[2])((void **)&v124);
      goto LABEL_199;
    }
    uint64_t v136 = 1;
    v137[0] = v117;
    v137[1] = v117;
    uint64_t v138 = (int64_t *)v140;
    uint64_t v139 = 0x400000000;
    *(void *)uint64_t v131 = 1;
    *(int64x2_t *)&BOOL v131[8] = v117;
    int64x2_t v132 = v117;
    char v133 = v135;
    uint64_t v134 = 0x400000000;
    LODWORD(v99) = 1;
    if (!llvm::AA::getPotentiallyLoadedValues(v2, v13, &v136, v131, v3, (BOOL *)&v129, 1)) {
      goto LABEL_165;
    }
    if (v139)
    {
      int64_t v100 = v138;
      uint64_t v101 = 8 * v139;
      while (1)
      {
        LODWORD(v99) = 1;
        if (!llvm::AA::isDynamicallyUnique(v2, v3, *v100, (const llvm::Value *)1)) {
          break;
        }
        ++v100;
        v101 -= 8;
        if (!v101)
        {
          if (!v139) {
            goto LABEL_152;
          }
          int v102 = v138;
          unsigned int v103 = v142;
          uint64_t v99 = 8 * v139;
          do
          {
            if (v103 >= v143) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v104 = &v141[16 * v103];
            *(void *)uint64_t v104 = *v102;
            *((void *)v104 + 1) = v12;
            unsigned int v103 = ++v142;
            ++v102;
            v99 -= 8;
          }
          while (v99);
          goto LABEL_153;
        }
      }
LABEL_165:
      int v42 = 0;
      goto LABEL_166;
    }
LABEL_152:
    LODWORD(v99) = 0;
LABEL_153:
    int v42 = 3;
LABEL_166:
    if (v133 != v135) {
      free(v133);
    }
    if ((v131[0] & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)&v131[8], 8);
    }
    if (v138 != (int64_t *)v140) {
      free(v138);
    }
    if (v136)
    {
      if (v99) {
        goto LABEL_174;
      }
    }
    else
    {
      MEMORY[0x1D25D9CD0](*(void *)&v137[0], 8);
      if (v99)
      {
LABEL_174:
        unsigned int v43 = *(unsigned __int8 *)(v13 + 16);
        goto LABEL_56;
      }
    }
LABEL_54:
    ++v9;
LABEL_200:
    if (v42 != 3 && v42)
    {
LABEL_205:
      char v111 = 0;
      goto LABEL_211;
    }
LABEL_107:
    unsigned int v10 = v142;
  }
  while (v142);
  if (v150)
  {
    uint64_t v112 = 24 * v150;
    uint64_t v113 = v149 + 16;
    do
    {
      if (*v113) {
        llvm::Attributor::recordDependence((uint64_t)v2, *((void *)v113 - 1), (uint64_t)v3, 1);
      }
      v113 += 24;
      v112 -= 24;
    }
    while (v112);
    char v111 = 1;
  }
  else
  {
    char v111 = 1;
  }
LABEL_211:
  if (v141 != (char *)v144) {
    free(v141);
  }
  sub_1CD40B1BC(v147[0]);
  if (v145[0] != v146) {
    free(v145[0]);
  }
  if (v149 != (char *)v151) {
    free(v149);
  }
  if ((v148[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v148[1], 8);
  }
  if ((v111 & 1) == 0) {
    return (*(uint64_t (**)(void *))(*((void *)v3 + 4) + 40))((void *)v3 + 4);
  }
  uint64_t v114 = (void *)(*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v3 + 40))(v3);
  uint64_t v115 = v114[2];
  (*(void (**)(void *, uint64_t))(*v114 + 48))(v114, v125.i64[1]);
  return v115 == v114[2];
}

unint64_t sub_1CC8D5378(unint64_t result, uint64_t *a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(result + 48);
  if (v3 >= 2)
  {
    uint64_t result = llvm::Attribute::get(a2, 0x4Au, 1 << (__clz(v3) ^ 0x3Fu));
    uint64_t v5 = *(unsigned int *)(a3 + 8);
    if (v5 >= *(_DWORD *)(a3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v5) = result;
    *(_DWORD *)(a3 + 8) = v5 + 1;
  }
  return result;
}

uint64_t *sub_1CC8D5408(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D5430(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D5498(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v11 = sub_1CD4B25C4(a3, a4);
  v62[0] = 0;
  v62[1] = 0;
  int v63 = 0;
  sub_1CBFCB9AC((uint64_t)v62, v11);
  long long v12 = *(_OWORD *)(v11 + 24);
  long long v65 = *(_OWORD *)(v11 + 40);
  long long v64 = v12;
  v58[0] = 0;
  v58[1] = 0;
  int v59 = 0;
  sub_1CBFCB9AC((uint64_t)v58, a3 + 176);
  long long v13 = *(_OWORD *)(a3 + 216);
  long long v60 = *(_OWORD *)(a3 + 200);
  long long v61 = v13;
  uint64_t v14 = a5[3];
  if (a5[4] != v14)
  {
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    while (1)
    {
      uint64_t v17 = *(void *)(v14 + 8 * v15);
      uint64_t v18 = *(void *)(v17 + 24);
      if (v18) {
        BOOL v19 = *(unsigned __int8 *)(v18 + 16) >= 0x1Cu;
      }
      else {
        BOOL v19 = 0;
      }
      if (!v19 || !sub_1CD648B2C(a3, *(void *)(v17 + 24), v62, v58)) {
        goto LABEL_7;
      }
      unint64_t v20 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
      int v22 = *(unsigned __int8 *)(v18 + 16);
      if ((v22 - 66) > 0xC) {
        break;
      }
      if (v22 != 75) {
        goto LABEL_12;
      }
LABEL_7:
      uint64_t v14 = a5[3];
      uint64_t v15 = ++v16;
      if (v16 >= (unint64_t)((a5[4] - v14) >> 3)) {
        goto LABEL_80;
      }
    }
    unsigned int v24 = 0;
    LOBYTE(v25) = 0;
    if (*(unsigned __int8 *)(v18 + 16) > 0x3Du)
    {
      if (v22 == 62)
      {
        uint64_t v34 = *(_DWORD *)(v18 + 20) & 0x7FFFFFF;
        if (v34 != 1)
        {
          unsigned int v35 = 1;
          while (*(unsigned char *)(*(void *)(v18 - 32 * v34 + 32 * v35) + 16) == 16)
          {
            if (v34 == ++v35) {
              goto LABEL_12;
            }
          }
          goto LABEL_7;
        }
LABEL_12:
        for (uint64_t i = *(uint64_t **)(v18 + 8); i; uint64_t i = (uint64_t *)i[1])
        {
          uint64_t v66 = i;
          sub_1CC61C590(a5, &v66);
        }
        goto LABEL_7;
      }
      uint64_t v57 = (llvm::GlobalValue *)v20;
      if (v22 != 84) {
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v57 = (llvm::GlobalValue *)v20;
      if (v22 != 33 && v22 != 39) {
        goto LABEL_30;
      }
    }
    int v26 = *(_DWORD *)(v18 + 20);
    if (v26 < 0 && (uint64_t v51 = v18 - 32 * (v26 & 0x7FFFFFF), v52 = *(void *)(v51 - 8), (v52 & 0xFFFFFFFF0) != 0))
    {
      unint64_t v53 = (unint64_t)(v17 - v51) >> 5;
      BOOL v54 = *(_DWORD *)(v51 - v52) <= v53 && *(_DWORD *)(v51 - 12) > v53;
      LODWORD(v36) = 0;
      if (v54 || v18 - 32 == v17) {
        goto LABEL_43;
      }
      uint64_t v27 = -(uint64_t)(v26 & 0x7FFFFFF);
    }
    else
    {
      if (v18 - 32 == v17)
      {
LABEL_42:
        LODWORD(v36) = 0;
LABEL_43:
        int8x16_t v37 = (int8x16_t)vdupq_n_s64(v36);
        *(int8x16_t *)(a6 + 8) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)(a6 + 8), (uint64x2_t)v37), *(int8x16_t *)(a6 + 8), v37);
        goto LABEL_7;
      }
      uint64_t v27 = -(uint64_t)(v26 & 0x7FFFFFF);
    }
    uint64_t v28 = v18 + 32 * v27;
    uint64_t v29 = v28;
    if ((v26 & 0x40000000) != 0) {
      uint64_t v29 = *(void *)(v18 - 8);
    }
    unint64_t v30 = *((void *)sub_1CC8BA1F4(a2, (v29 + ((v17 - v28) & 0x1FFFFFFFE0)) | 3, 0, a1, 2, 0, 1) + 5);
    int v31 = __clz(v30) ^ 0x3F | 0x100;
    if (v30) {
      LODWORD(v25) = v31;
    }
    else {
      LODWORD(v25) = 0;
    }
    unsigned int v24 = v25 >> 8;
    int v22 = *(unsigned __int8 *)(v18 + 16);
LABEL_30:
    uint64_t v32 = *(void *)(*(void *)(a2 + 88) + 120);
    uint64_t v33 = *(llvm::GlobalValue **)v17;
    if ((v22 == 60 || v22 == 61) && *(llvm::GlobalValue **)(v18 - 32) == v33)
    {
      unint64_t v25 = ((unint64_t)*(unsigned __int16 *)(v18 + 18) >> 1) & 0x3F;
    }
    else if (!v24)
    {
      goto LABEL_42;
    }
    if (!(*(void *)(a1 + 40) >> v25))
    {
      unsigned __int8 v56 = v25;
      unsigned int v38 = *(_DWORD *)(*(void *)v33 + 8);
      if ((v38 & 0xFE) == 0x12) {
        unsigned int v38 = *(_DWORD *)(**(void **)(*(void *)v33 + 16) + 8);
      }
      if (v38 < 0x100) {
        goto LABEL_55;
      }
      unsigned int v39 = v38 >> 8;
      uint64_t v40 = *(unsigned int *)(v32 + 240);
      uint64_t v41 = *(void *)(v32 + 232);
      if (v40)
      {
        uint64_t v41 = *(void *)(v32 + 232);
        unint64_t v42 = *(unsigned int *)(v32 + 240);
        do
        {
          unint64_t v43 = v42 >> 1;
          uint64_t v44 = v41 + 16 * (v42 >> 1);
          unsigned int v45 = *(_DWORD *)(v44 + 8);
          uint64_t v46 = v44 + 16;
          v42 += ~(v42 >> 1);
          if (v45 < v39) {
            uint64_t v41 = v46;
          }
          else {
            unint64_t v42 = v43;
          }
        }
        while (v42);
      }
      if (v41 == *(void *)(v32 + 232) + 16 * v40 || *(_DWORD *)(v41 + 8) != v39) {
LABEL_55:
      }
        uint64_t v41 = *(void *)(v32 + 232);
      unsigned int v67 = *(_DWORD *)(v41 + 12);
      if (v67 > 0x40) {
        operator new[]();
      }
      uint64_t v66 = 0;
      uint64_t v47 = llvm::Value::stripAndAccumulateConstantOffsets(v33, (llvm::DataLayout *)v32, (llvm::APInt *)&v66, 1, 0, 0, v21);
      if (v67 > 0x40)
      {
        uint64_t v48 = *v66;
        MEMORY[0x1D25D9CB0]();
      }
      else
      {
        uint64_t v48 = (uint64_t)((void)v66 << -(char)v67) >> -(char)v67;
      }
      uint64_t v36 = 1 << v56;
      if (v47 && v47 == v57)
      {
        unsigned int v49 = (int)v48 >= 0 ? v48 : -(int)v48;
        if (v56 <= 0x1FuLL)
        {
          do
          {
            unsigned int v50 = v36;
            LODWORD(v36) = v49 % v36;
            unsigned int v49 = v50;
          }
          while (v36);
        }
        else
        {
          unsigned int v50 = v49;
        }
        uint64_t v36 = 1 << ~__clz(v50);
        if (!v50) {
          LODWORD(v36) = 0;
        }
      }
      goto LABEL_43;
    }
    goto LABEL_42;
  }
LABEL_80:
  MEMORY[0x1D25D9CD0](v58[0], 8);
  return MEMORY[0x1D25D9CD0](v62[0], 8);
}

uint64_t sub_1CC8D59CC(uint64_t *a1, uint64_t a2)
{
  if (a2 && *(unsigned char *)(a2 + 16) == 30 && (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3)
  {
    uint64_t v2 = *a1;
    unsigned int v3 = *(_DWORD *)(*a1 + 8);
    if (v3 >= *(_DWORD *)(*a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v2 + 8 * v3) = a2;
    ++*(_DWORD *)(v2 + 8);
  }
  return 1;
}

uint64_t sub_1CC8D5A5C(void *a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  uint64_t v14 = &v16;
  uint64_t v15 = 0;
  if (!*((_DWORD *)a2 + 4))
  {
    unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
    goto LABEL_3;
  }
  sub_1CD41B598((uint64_t)&v14, (uint64_t)(a2 + 1));
  unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
  if (!v15)
  {
LABEL_3:
    uint64_t v4 = v13;
    unsigned int v5 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
    if (v5 < 0x15 || v5 == 24) {
      goto LABEL_9;
    }
  }
  unsigned int v3 = *((_DWORD *)v14 + v3 + 1);
  if ((v3 & 0x80000000) != 0)
  {
LABEL_12:
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = v13;
LABEL_9:
  uint64_t v7 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v3);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = a1[1];
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 >= *(_DWORD *)(v8 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v10 = (void *)(*(void *)v8 + 16 * v9);
  *unsigned int v10 = v7;
  v10[1] = v4;
  ++*(_DWORD *)(v8 + 8);
  uint64_t v11 = 1;
LABEL_13:
  if (v14 != &v16) {
    free(v14);
  }
  return v11;
}

void *sub_1CC8D5B80(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D5BC4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D5C28(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 88);
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  uint64_t v6 = sub_1CD64B750(v4, *(const llvm::Function **)(AssociatedArgument + 24));
  if (*(unsigned __int8 *)(v6 + 104) | *(unsigned __int8 *)(v6 + 105)) {
    return 1;
  }

  return sub_1CC8D41A0(a1, a2);
}

void sub_1CC8D5CA8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0A8))
  {
    __cxa_guard_release(&qword_1EA61C0A8);
  }
}

BOOL sub_1CC8D5CFC(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  long long v8 = xmmword_1CFB27360;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2623850;
  char v12 = 0;
  char v14 = 0;
  int v11 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  v10[0] = &v11;
  v10[1] = a2;
  void v10[2] = a1;
  v10[3] = &v12;
  if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8D5F2C, (uint64_t)v10, a1, 1, &v9))
  {
    if (v14) {
      v7[6]((void **)&v7, v13);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  uint64_t v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v5 = v4[2];
  (*(void (**)(void *, void))(*v4 + 48))(v4, *((void *)&v8 + 1));
  return v5 == v4[2];
}

uint64_t *sub_1CC8D5E9C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D5EC4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D5F2C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  int v11 = &v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v13 = v10;
    char v14 = &v16;
    uint64_t v15 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v14, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v13 = v3;
    char v14 = &v16;
    uint64_t v15 = 0;
  }
  uint64_t v16 = sub_1CD659800((uint64_t)&v13, **(_DWORD **)a1);
  uint64_t v17 = v4;
  if (v14 != &v16) {
    free(v14);
  }
  if (sub_1CD647DEC(&v16))
  {
    uint64_t v5 = sub_1CC8BA1F4(*(void *)(a1 + 8), v16, v17, *(void *)(a1 + 16), 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v7 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v7 + 24))
    {
      (*(void (**)(uint64_t, void, void))(*(void *)v7 + 72))(v7, *(void *)(v6 + 16), *(void *)(v6 + 8));
    }
    else
    {
      *(void *)uint64_t v7 = &unk_1F26238B0;
      *(_OWORD *)(v7 + 8) = *(_OWORD *)(v6 + 8);
      *(void *)uint64_t v7 = &unk_1F2623850;
      *(unsigned char *)(v7 + 24) = 1;
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v11 != &v13) {
    free(v11);
  }
  return v8;
}

void *sub_1CC8D60FC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D6140(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D61A4(void *a1, uint64_t a2)
{
  sub_1CC8D3BBC((uint64_t)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 2));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      a1[6] = a1[5];
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8D6214()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0B0))
  {
    __cxa_guard_release(&qword_1EA61C0B0);
  }
}

BOOL sub_1CC8D6268(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  long long v8 = xmmword_1CFB27360;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2623850;
  uint64_t v13 = 0;
  char v10 = 0;
  char v12 = 0;
  v9[0] = &v13;
  v9[1] = a2;
  void v9[2] = a1;
  void v9[3] = &v10;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8D6484, (uint64_t)v9, a1))
  {
    if (v12) {
      v7[6]((void **)&v7, v11);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  uint64_t v4 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v5 = v4[2];
  (*(void (**)(void *, void))(*v4 + 48))(v4, *((void *)&v8 + 1));
  return v5 == v4[2];
}

uint64_t *sub_1CC8D63F4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D641C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D6484(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 != 21)
  {
    if (v4 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v5 = v4 - 33;
      BOOL v6 = v5 > 0x33;
      uint64_t v7 = (1 << v5) & 0x8000000000041;
      if (!v6 && v7 != 0)
      {
        uint64_t v3 = 0;
        a2 |= 1uLL;
      }
    }
  }
  char v9 = sub_1CC8BA1F4(*(void *)(a1 + 8), a2, v3, *(void *)(a1 + 16), 0, 0, 1);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v11 + 24))
  {
    (*(void (**)(uint64_t, void, void))(*(void *)v11 + 72))(v11, *(void *)(v10 + 16), *(void *)(v10 + 8));
  }
  else
  {
    *(void *)uint64_t v11 = &unk_1F26238B0;
    *(_OWORD *)(v11 + 8) = *(_OWORD *)(v10 + 8);
    *(void *)uint64_t v11 = &unk_1F2623850;
    *(unsigned char *)(v11 + 24) = 1;
  }
  char v12 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);

  return v12();
}

void *sub_1CC8D65E8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D662C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D6690(void *a1, uint64_t a2)
{
  sub_1CC8D3BBC((uint64_t)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 2));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      a1[6] = a1[5];
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8D6700()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0B8))
  {
    __cxa_guard_release(&qword_1EA61C0B8);
  }
}

uint64_t sub_1CC8D6754(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v5 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD648A0C(v4);
  if (v6)
  {
    uint64_t v7 = sub_1CC8BA1F4(a2, v6 | 1, 0, a1, 0, 0, 1);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    uint64_t v9 = v5[2];
    (*(void (**)(void *, void))(*v5 + 48))(v5, *(void *)(v8 + 16));
    return v9 == v5[2];
  }
  else
  {
    uint64_t v11 = *(uint64_t (**)(void *))(*v5 + 40);
    return v11(v5);
  }
}

uint64_t *sub_1CC8D687C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D68A4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D690C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D6950(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D69B4(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (AssociatedArgument)
  {
    uint64_t v9 = sub_1CD64B750(*(void *)(a2 + 88), *(const llvm::Function **)(AssociatedArgument + 24));
    if (*(unsigned __int8 *)(v9 + 104) | *(unsigned __int8 *)(v9 + 105)) {
      return 1;
    }
  }
  unsigned int v6 = sub_1CC8D41A0(a1, a2);
  uint64_t v7 = (llvm::Value *)sub_1CD6482F0(v4);
  if ((unint64_t)(1 << llvm::Value::getPointerAlignment(v7, *(const llvm::DataLayout **)(*(void *)(a2 + 88) + 120))) >= *(void *)(a1 + 48))return 1; {
  else
  }
    return v6;
}

void sub_1CC8D6A50()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0C0))
  {
    __cxa_guard_release(&qword_1EA61C0C0);
  }
}

uint64_t sub_1CC8D6AA4(uint64_t a1, llvm::Attributor *a2)
{
  uint64_t v4 = sub_1CC8D4418(a1, a2);
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (AssociatedArgument)
  {
    unsigned int v6 = (const double *)((char *)sub_1CC8BA1F4((uint64_t)a2, AssociatedArgument, 0, a1, 2, 0, 1) + 40);
    int8x16_t v7 = (int8x16_t)vld1q_dup_f64(v6);
    *(int8x16_t *)(a1 + 40) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)(a1 + 40), (uint64x2_t)v7), *(int8x16_t *)(a1 + 40), v7);
  }
  return v4;
}

uint64_t *sub_1CC8D6B20(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D6B48(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D6BB0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D6BF4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D6C58(uint64_t a1)
{
  uint64_t result = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  uint64_t v3 = result;
  unsigned int v4 = *(unsigned __int8 *)(result + 16);
  if (v4 <= 0x14)
  {
    int isThreadDependent = llvm::Constant::isThreadDependent((llvm::Constant *)result);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v8 = a1 + 32;
    uint64_t v7 = v9;
    if (isThreadDependent)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t))(v7 + 40);
      uint64_t v11 = v8;
    }
    else
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t))(v7 + 32);
      uint64_t v11 = v8;
    }
    return v10(v11);
  }
  else
  {
    if (v4 < 0x1C) {
      return result;
    }
    switch(v4)
    {
      case 'T':
        uint64_t v5 = 0;
        break;
      case '\'':
        uint64_t v5 = (*(_DWORD *)(result + 80) + 1);
        break;
      case '!':
        uint64_t v5 = 2;
        break;
      default:
        return result;
    }
    int v12 = 0;
    int v13 = *(_DWORD *)(result + 20);
    uint64_t v14 = -(uint64_t)(v13 & 0x7FFFFFF);
    if (v13 < 0)
    {
      uint64_t v18 = result - 32 * (v13 & 0x7FFFFFF);
      uint64_t v19 = *(void *)(v18 - 8);
      if ((v19 & 0xFFFFFFFF0) != 0) {
        int v12 = *(_DWORD *)(v18 - 12) - *(_DWORD *)(v18 - v19);
      }
      else {
        int v12 = 0;
      }
    }
    if (((-32 * v5 + 32 * -v12 - 32 * v14 - 32) & 0x1FFFFFFFE0) == 0)
    {
      uint64_t result = llvm::Instruction::mayHaveSideEffects((llvm::Instruction *)result);
      if ((result & 1) == 0)
      {
        uint64_t v15 = *(unsigned __int8 *)(v3 + 16) - 33;
        if (v15 <= 0x37)
        {
          if (((1 << (*(unsigned char *)(v3 + 16) - 33)) & 0x8000000000041) != 0)
          {
            uint64_t v17 = *(void *)(v3 + 64);
            if (!v17 || (*(unsigned char *)(v17 + 20) & 4) == 0 && (*(unsigned char *)(v17 + 17) & 0x10) == 0)
            {
              __int32 v21 = 7;
              uint64_t result = sub_1CC5CB59C(v3, &v21, 1uLL);
              if (result)
              {
                uint64_t v20 = *(void *)(v3 - 32);
                if (!v20
                  || *(unsigned char *)(v20 + 16)
                  || *(void *)(v20 + 24) != *(void *)(v3 + 72)
                  || *(_DWORD *)(v20 + 36) != 7)
                {
                  return result;
                }
              }
              if ((llvm::CallBase::hasFnAttrOnCalledFunction(v3, 66) & 1) == 0)
              {
                uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(v3, 44);
                if (!result) {
                  return result;
                }
              }
            }
          }
          else if (((1 << (*(unsigned char *)(v3 + 16) - 33)) & 0x808001C8000010) != 0 {
                 || v15 == 28 && (*(_WORD *)(v3 + 18) & 0x301) != 0)
          }
          {
            return result;
          }
        }
        uint64_t v16 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32);
        return v16(a1 + 32);
      }
    }
  }
  return result;
}

void *sub_1CC8D6F00@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "<unique [fAa]>";
  }
  else {
    uint64_t v3 = "<unknown>";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 14;
  }
  else {
    size_t v4 = 9;
  }
  a2[23] = v4;
  uint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

uint64_t sub_1CC8D6F60(void *a1, llvm::Attributor *a2)
{
  unint64_t v4 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 2));
  uint64_t v5 = v4;
  unsigned int v6 = *(unsigned __int8 *)(v4 + 16);
  if (v6 > 0x1B)
  {
    uint64_t v7 = *(void *)(*(void *)(v4 + 40) + 56);
    if (v7) {
      goto LABEL_6;
    }
  }
  else if (v6 == 21)
  {
    uint64_t v7 = *(void *)(v4 + 24);
    if ((*(_DWORD *)(v7 + 32) & 0xFu) - 7 >= 2) {
      return 1;
    }
LABEL_6:
    uint64_t v8 = 1;
    if (!*((unsigned char *)sub_1CC8B3300((uint64_t)a2, v7, 0, (uint64_t)a1, 1, 0, 1) + 41))
    {
      v12[0] = a2;
      v12[1] = a1;
      v11[0] = a2;
      v11[1] = a1;
      if ((llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8D7160, (uint64_t)v12, (const llvm::AbstractAttribute *)a1, v5, 1, 1, 1, (uint64_t (*)(void, void, void))sub_1CC8D7318, (uint64_t)v11) & 1) == 0)return (*(uint64_t (**)(void *))(a1[4] + 40))(a1 + 4); {
    }
      }
    return v8;
  }
  uint64_t v10 = *(uint64_t (**)(void *))(a1[4] + 32);

  return v10(a1 + 4);
}

uint64_t *sub_1CC8D70D0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D70F8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8D7160(uint64_t *a1, void *a2, unsigned char *a3)
{
  uint64_t v3 = a2[3];
  unsigned int v4 = *(unsigned __int8 *)(v3 + 16);
  BOOL v6 = v4 != 62 && v3 != 0 && v4 >= 0x1C;
  if (!v6 || v4 - 66 < 0xD || *(unsigned char *)(v3 + 16) == 85 || *(unsigned char *)(v3 + 16) == 83)
  {
    uint64_t v7 = 1;
    *a3 = 1;
    return v7;
  }
  int v9 = *(unsigned __int8 *)(v3 + 16);
  unsigned int v10 = v4 - 81;
  if (v9 == 60 || v10 < 2) {
    return 1;
  }
  uint64_t v12 = a1[1];
  if (*(unsigned __int8 *)(v3 + 16) > 0x3Cu)
  {
    if (v9 != 84) {
      return v9 == 61 && *(void *)(v3 - 64) != *a2;
    }
  }
  else if (v9 != 33 && v9 != 39)
  {
    return 0;
  }
  uint64_t v13 = *(void *)(v3 - 32);
  if (!v13
    || *(unsigned char *)(v13 + 16)
    || *(void *)(v13 + 24) != *(void *)(v3 + 72)
    || (*(_DWORD *)(v13 + 32) & 0xFu) - 7 > 1)
  {
    return 1;
  }
  int v14 = *(_DWORD *)(v3 + 20);
  unint64_t v15 = v3 - 32 * (v14 & 0x7FFFFFF);
  if (v15 > (unint64_t)a2) {
    return 0;
  }
  int v16 = *(unsigned __int8 *)(v3 + 16);
  if (v16 == 84) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v16 == 39 ? (*(_DWORD *)(v3 + 80) + 1) : 2;
  }
  if (v14 < 0 && (uint64_t v21 = *(void *)(v15 - 8), (v21 & 0xFFFFFFFF0) != 0)) {
    uint64_t v18 = (*(_DWORD *)(v15 - 12) - *(_DWORD *)(v15 - v21));
  }
  else {
    uint64_t v18 = 0;
  }
  if (v3 - 32 * v17 - 32 * v18 - 32 <= (unint64_t)a2) {
    return 0;
  }
  uint64_t v19 = *a1;
  unint64_t v20 = (unint64_t)a2 - v15;
  if ((v14 & 0x40000000) != 0) {
    unint64_t v15 = *(void *)(v3 - 8);
  }
  uint64_t v7 = 1;
  if (!*((unsigned char *)sub_1CC8B52C8(v19, (v15 + (v20 & 0x1FFFFFFFE0)) | 3, 0, v12, 1, 0, 1) + 41)) {
    return 0;
  }
  return v7;
}

uint64_t sub_1CC8D7318(llvm::AA **a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (*(unsigned char *)(v3 + 16) == 61)
    {
      uint64_t v5 = a1[1];
      BOOL v6 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v3 - 32));
      if (*((unsigned char *)v6 + 16) != 59
        || (uint64_t v2 = 1, !llvm::AA::isDynamicallyUnique(*a1, v5, (int64_t)v6, (const llvm::Value *)1)))
      {
        if (**(void **)(*((void *)*a1 + 11) + 440)) {
          BOOL v7 = *(void *)(*(void *)(*(void *)(v3 + 40) + 56) + 40) == 0;
        }
        else {
          BOOL v7 = 1;
        }
        if (!v7) {
          llvm::AnalysisManager<llvm::Function>::getResultImpl();
        }
        if (byte_1EBD04470) {
          int v8 = 59;
        }
        else {
          int v8 = 63;
        }
        sub_1CC095244((uint64_t)v6, v8, 0, v10);
        if (!v10[24]) {
          return 0;
        }
        uint64_t v2 = 1;
        if (!llvm::AA::isDynamicallyUnique(*a1, v5, (int64_t)v6, (const llvm::Value *)1)) {
          return 0;
        }
      }
    }
  }
  return v2;
}

void *sub_1CC8D7438(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D747C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CC8D74E0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D7508(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D7570(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D75B4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CC8D7618(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D7640(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D76A8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D76EC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D7750(uint64_t a1, uint64_t a2)
{
  unint64_t result = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (result)
  {
    uint64_t v5 = sub_1CC8B52C8(a2, result, 0, a1, 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = a1 + 32;
    BOOL v9 = *(unsigned char *)(v7 + 9) == 0;
    (*(void (**)(uint64_t, void))(v8 + 48))(v7, *(unsigned __int8 *)(v6 + 9));
    return v9 ^ (*(unsigned char *)(v7 + 9) != 0);
  }
  else
  {
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  return result;
}

uint64_t *sub_1CC8D7818(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D7840(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D78A8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D78EC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D7950(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v11 = 22;
  if (llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), &v11, 1, 1, 0)) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
  }
  uint64_t v6 = (llvm::GlobalValue *)sub_1CD6482A0(v4);
  unsigned int v7 = sub_1CD647DEC(v4);
  if (v7 <= 6 && ((1 << v7) & 0x54) != 0 && (!v6 || !sub_1CD64EF44(a2, v6))) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  if (*(unsigned char *)(sub_1CD6482F0(v4) + 16) == 19)
  {
    unint64_t v8 = sub_1CD6482F0(v4);
    unsigned int v9 = *(_DWORD *)(*(void *)v8 + 8);
    if ((v9 & 0xFE) == 0x12) {
      unsigned int v9 = *(_DWORD *)(**(void **)(*(void *)v8 + 16) + 8);
    }
    if (v9 <= 0xFF) {
      return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
    }
  }
  if ((sub_1CD647DEC(v4) & 0xFFFFFFFE) == 6) {
    uint64_t v6 = (llvm::GlobalValue *)sub_1CD648A0C(v4);
  }
  uint64_t v10 = a1 + 32;
  if (v6) {
    return sub_1CC8D8200((unint64_t)v4, (uint64_t)v6, v10);
  }
  else {
    return (*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(a1 + 32);
  }
}

char *sub_1CC8D7AE4@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  int v3 = *((unsigned __int16 *)result + 20);
  if ((~v3 & 7) != 0)
  {
    int v4 = *((unsigned __int16 *)result + 21);
    if ((~v4 & 7) != 0)
    {
      if ((~v3 & 3) != 0)
      {
        if ((~v4 & 3) != 0)
        {
          *(unsigned char *)(a2 + 23) = 16;
          strcpy((char *)a2, "assumed-captured");
        }
        else
        {
          unint64_t result = (char *)operator new(0x28uLL);
          *(void *)a2 = result;
          *(_OWORD *)(a2 + 8) = xmmword_1CFAC7AC0;
          strcpy(result, "assumed not-captured-maybe-returned");
        }
      }
      else
      {
        unint64_t result = (char *)operator new(0x28uLL);
        *(void *)a2 = result;
        *(_OWORD *)(a2 + 8) = xmmword_1CFAC7E80;
        strcpy(result, "known not-captured-maybe-returned");
      }
    }
    else
    {
      *(unsigned char *)(a2 + 23) = 20;
      strcpy((char *)a2, "assumed not-captured");
    }
  }
  else
  {
    *(unsigned char *)(a2 + 23) = 18;
    strcpy((char *)a2, "known not-captured");
  }
  return result;
}

void sub_1CC8D7C14()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0C8))
  {
    __cxa_guard_release(&qword_1EA61C0C8);
  }
}

uint64_t sub_1CC8D7C68(uint64_t a1, llvm::Attributor *a2)
{
  int v4 = (llvm::IRPosition *)(a1 + 16);
  if ((sub_1CD647DEC((void *)(a1 + 16)) & 0xFFFFFFFE) == 6)
  {
    unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument(v4);
    if (!AssociatedArgument)
    {
      uint64_t v6 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);
      return v6(a1 + 32);
    }
  }
  else
  {
    unint64_t AssociatedArgument = sub_1CD6482F0(v4);
  }
  uint64_t v8 = AssociatedArgument;
  if ((sub_1CD647DEC(v4) & 0xFFFFFFFE) == 6) {
    unint64_t v9 = sub_1CD648A0C(v4);
  }
  else {
    unint64_t v9 = sub_1CD6482A0(v4);
  }
  unint64_t v10 = v9;
  unint64_t v35 = v9;
  uint64_t v36 = 0;
  int v34 = 458752;
  uint64_t v33 = &unk_1F2624118;
  char v32 = 0;
  if (sub_1CC8AAAB0((uint64_t)a2, (uint64_t *)&v35, a1, 0, &v32))
  {
    v34 |= 0x10001u;
    if (v32)
    {
      *(_WORD *)(a1 + 42) |= 1u;
      *(_WORD *)(a1 + 40) |= 1u;
    }
  }
  unsigned int v11 = sub_1CC8B82A4((uint64_t)a2, v35, v36, a1, 1, 0, 1);
  if (!*((unsigned char *)v11 + 41)) {
    goto LABEL_30;
  }
  uint64_t v12 = v11;
  int v13 = *(unsigned __int8 *)(**(void **)(*(void *)(v10 + 24) + 16) + 8);
  if (v13 == 7)
  {
    int v14 = 0;
  }
  else
  {
    int v14 = sub_1CC8B670C((uint64_t)a2, v35, v36, a1, 1, 0, 1);
    uint64_t v15 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v14 + 136))(v14);
    if (v15 != v16)
    {
      uint64_t v17 = v15;
      uint64_t v18 = v16;
      int v29 = v13;
      char v19 = 0;
      do
      {
        unsigned int v21 = *(unsigned __int8 *)(*(void *)v17 + 16);
        if (v21 > 0x14)
        {
          if (v21 != 21) {
            goto LABEL_30;
          }
          uint64_t v20 = *(void *)v17;
          if (v20 == llvm::IRPosition::getAssociatedArgument(v4)) {
            goto LABEL_30;
          }
        }
        else
        {
          if (v19) {
            goto LABEL_30;
          }
          char v19 = 1;
        }
        v17 += 96;
      }
      while (v17 != v18);
      int v13 = v29;
    }
  }
  char v22 = v34;
  v34 |= 0x40004u;
  if (v22) {
    return 1;
  }
  if (*((unsigned char *)v12 + 40))
  {
    if (v13 == 7
      || (uint64_t v23 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v14 + 48))(v14),
          (*(unsigned int (**)(uint64_t))(*(void *)v23 + 24))(v23)))
    {
      *(_WORD *)(a1 + 42) |= 4u;
      __int16 v24 = *(_WORD *)(a1 + 40);
      *(_WORD *)(a1 + 40) = v24 | 4;
      if (v24) {
        return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
      }
    }
  }
LABEL_30:
  v31[0] = a2;
  v31[1] = a1;
  v30[0] = v31;
  v30[1] = a1;
  v30[2] = a2;
  v30[3] = &v33;
  if ((llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8D8364, (uint64_t)v30, (const llvm::AbstractAttribute *)a1, v8, 0, 1, 1, 0, v28) & 1) == 0)return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32); {
  uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  }
  int v26 = *(unsigned __int16 *)(v25 + 10);
  int v27 = (unsigned __int16)(HIWORD(v34) & v26) | *(unsigned __int16 *)(v25 + 8);
  *(_WORD *)(v25 + 10) = HIWORD(v34) & v26 | *(_WORD *)(v25 + 8);
  if ((~*(unsigned __int16 *)(a1 + 42) & 3) != 0) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  else {
    return v26 == v27;
  }
}

unint64_t sub_1CC8D8064(unint64_t result, uint64_t *a2, uint64_t a3)
{
  if ((~*(unsigned __int16 *)(result + 42) & 3) == 0)
  {
    unint64_t v5 = result;
    unint64_t result = sub_1CD647DEC((void *)(result + 16));
    if ((result & 0xFFFFFFFE) == 6)
    {
      if ((~*(unsigned __int16 *)(v5 + 42) & 7) == 0)
      {
        unint64_t result = llvm::Attribute::get(a2, 0x16u, 0);
        uint64_t v6 = *(unsigned int *)(a3 + 8);
        unsigned int v7 = (_DWORD *)(a3 + 8);
        if (v6 < *(_DWORD *)(a3 + 12))
        {
          *(void *)(*(void *)a3 + 8 * v6) = result;
LABEL_10:
          *unsigned int v7 = v6 + 1;
          return result;
        }
        goto LABEL_11;
      }
      if (byte_1EBCDDFA8)
      {
        unint64_t result = (unint64_t)llvm::Attribute::get(a2, "no-capture-maybe-returned", 0x19uLL, 0, 0);
        uint64_t v6 = *(unsigned int *)(a3 + 8);
        unsigned int v7 = (_DWORD *)(a3 + 8);
        if (v6 < *(_DWORD *)(a3 + 12))
        {
          *(void *)(*(void *)a3 + 8 * v6) = result;
          goto LABEL_10;
        }
LABEL_11:
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
    }
  }
  return result;
}

uint64_t *sub_1CC8D8170(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D8198(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D8200(unint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 112);
  if (!v5) {
    goto LABEL_13;
  }
  if ((*(unsigned char *)(v5 + 17) & 0x30) != 0)
  {
    if ((*(unsigned char *)(v5 + 16) & 0x20) != 0 && *(unsigned char *)(**(void **)(*(void *)(a2 + 24) + 16) + 8) == 7)
    {
      __int16 v6 = *(_WORD *)(a3 + 10);
      goto LABEL_6;
    }
    goto LABEL_9;
  }
  if ((*(unsigned char *)(v5 + 17) & 0x20) != 0)
  {
LABEL_9:
    *(_WORD *)(a3 + 10) |= 1u;
    *(_WORD *)(a3 + 8) |= 1u;
  }
  if ((*(unsigned char *)(v5 + 16) & 0x20) != 0 && *(unsigned char *)(**(void **)(*(void *)(a2 + 24) + 16) + 8) == 7)
  {
    *(_WORD *)(a3 + 10) |= 4u;
    *(_WORD *)(a3 + 8) |= 4u;
  }
LABEL_13:
  unint64_t result = sub_1CD64DE00((llvm::IRPosition *)result, 1);
  uint64_t v8 = *(void *)(a2 + 112);
  if (v8 && (*(unsigned char *)(v8 + 16) & 0x20) != 0 && (result & 0x80000000) == 0 && *(_DWORD *)(a2 + 96))
  {
    uint64_t v9 = 0;
    while (1)
    {
      if ((v9 + 2) < *(_DWORD *)(v8 + 8))
      {
        uint64_t v10 = *(void *)(v8 + 40 + 8 * (v9 + 2));
        if (v10)
        {
          if ((*(unsigned char *)(v10 + 17) & 0x40) != 0) {
            break;
          }
        }
      }
      if (*(_DWORD *)(a2 + 96) == ++v9) {
        return result;
      }
    }
    if (result != v9)
    {
      char v11 = *(unsigned char *)(v8 + 17);
      __int16 v6 = *(_WORD *)(a3 + 10);
      if ((v11 & 0x30) == 0)
      {
        *(_WORD *)(a3 + 10) = v6 | 4;
        __int16 v7 = *(_WORD *)(a3 + 8) | 4;
        goto LABEL_7;
      }
LABEL_6:
      *(_WORD *)(a3 + 10) = v6 | 7;
      __int16 v7 = *(_WORD *)(a3 + 8) | 7;
LABEL_7:
      *(_WORD *)(a3 + 8) = v7;
      return result;
    }
    *(_WORD *)(a3 + 10) = *(_WORD *)(a3 + 10) & 0xFFFB | *(_WORD *)(a3 + 8);
  }
  return result;
}

BOOL sub_1CC8D8364(uint64_t *a1, unint64_t a2, unsigned char *a3)
{
  uint64_t v6 = a1[1];
  int v7 = llvm::DetermineUseCaptureKind(a2, (uint64_t (*)(uint64_t, llvm::Value *, uint64_t))sub_1CC8D8560, *a1);
  if (!v7) {
    return 1;
  }
  if (v7 == 2)
  {
    BOOL result = 1;
    *a3 = 1;
    return result;
  }
  uint64_t v9 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v11 = *(void *)(a2 + 24);
  unsigned int v12 = *(unsigned __int8 *)(v11 + 16);
  if (v12 <= 0x3C)
  {
    if (v12 != 33 && v12 != 39)
    {
      if (v12 == 29)
      {
        uint64_t v21 = *(void *)(*(void *)(v11 + 40) + 56);
        unint64_t v22 = sub_1CD6482A0((_DWORD *)(v6 + 16));
        int v23 = *(unsigned __int16 *)(v10 + 10);
        if (v21 == v22) {
          unsigned int v24 = v23 & 0xFFFFFFFB;
        }
        else {
          unsigned int v24 = v23 & 0xFFF8;
        }
        int v20 = v24 | *(unsigned __int16 *)(v10 + 8);
        goto LABEL_26;
      }
      goto LABEL_28;
    }
  }
  else
  {
    if (v12 == 61)
    {
      int v13 = *(_WORD *)(v10 + 10) & 0xFFFE;
      goto LABEL_25;
    }
    if (v12 != 84)
    {
      if (v12 == 75)
      {
LABEL_9:
        int v13 = *(_WORD *)(v10 + 10) & 0xFFF8;
LABEL_25:
        int v20 = v13 | *(unsigned __int16 *)(v10 + 8);
LABEL_26:
        *(_WORD *)(v10 + 10) = v20;
        return (~v20 & 3) == 0;
      }
LABEL_28:
      int v20 = *(unsigned __int16 *)(v10 + 8);
      *(_WORD *)(v10 + 10) = *(_WORD *)(v10 + 10) & 0xFFF8 | v20;
      return (~v20 & 3) == 0;
    }
  }
  int v14 = *(_DWORD *)(v11 + 20);
  unint64_t v15 = v11 - 32 * (v14 & 0x7FFFFFF);
  if (v15 > a2) {
    goto LABEL_28;
  }
  if (v12 == 84) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = v12 == 39 ? (*(_DWORD *)(v11 + 80) + 1) : 2;
  }
  if (v14 < 0 && (uint64_t v25 = *(void *)(v15 - 8), (v25 & 0xFFFFFFFF0) != 0)) {
    uint64_t v17 = (*(_DWORD *)(v15 - 12) - *(_DWORD *)(v15 - v25));
  }
  else {
    uint64_t v17 = 0;
  }
  if (v11 - 32 * v16 - 32 * v17 - 32 <= a2) {
    goto LABEL_28;
  }
  unint64_t v18 = a2 - v15;
  if ((v14 & 0x40000000) != 0) {
    unint64_t v15 = *(void *)(v11 - 8);
  }
  int v19 = *((unsigned __int16 *)sub_1CC8BB6D4(v9, (v15 + (v18 & 0x1FFFFFFFE0)) | 3, 0, v6, 0, 0, 1) + 21);
  if ((~v19 & 7) != 0)
  {
    if ((~v19 & 3) != 0) {
      goto LABEL_9;
    }
    *a3 = 1;
  }
  int v20 = *(unsigned __int16 *)(v10 + 10);
  return (~v20 & 3) == 0;
}

BOOL sub_1CC8D8560(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  unsigned int v5 = *(unsigned __int8 *)(a2 + 16);
  if (v5 != 21)
  {
    if (v5 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v6 = v5 - 33;
      BOOL v7 = v6 > 0x33;
      uint64_t v8 = (1 << v6) & 0x8000000000041;
      if (!v7 && v8 != 0) {
        a2 |= 1uLL;
      }
    }
  }
  return *((_DWORD *)sub_1CC8BB19C(v2, a2, 0, v3, 1, 0, 1) + 13) != 0;
}

void *sub_1CC8D85E0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D8624(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8D8688()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0D0))
  {
    __cxa_guard_release(&qword_1EA61C0D0);
  }
}

uint64_t *sub_1CC8D86DC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D8704(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D876C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D87B0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D8814(uint64_t a1)
{
  unint64_t v2 = a1 + 16;
  unint64_t v3 = sub_1CD6482A0((_DWORD *)(a1 + 16));

  return sub_1CC8D8200(v2, v3, a1 + 32);
}

void sub_1CC8D885C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0D8))
  {
    __cxa_guard_release(&qword_1EA61C0D8);
  }
}

uint64_t *sub_1CC8D88B0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D88D8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8D8940(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8D8984(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8D89E8(_WORD *a1, uint64_t a2)
{
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 8));
  if (AssociatedArgument)
  {
    if (*(unsigned char *)(*(void *)AssociatedArgument + 8) == 15)
    {
      uint64_t v5 = *(void *)(*(void *)(AssociatedArgument + 24) + 112);
      if (v5)
      {
        unsigned int v6 = *(_DWORD *)(AssociatedArgument + 32) + 2;
        if (v6 < *(_DWORD *)(v5 + 8))
        {
          uint64_t v8 = *(void *)(v5 + 8 * v6 + 40);
          if (v8)
          {
            if ((*(unsigned char *)(v8 + 20) & 0x20) != 0) {
              a1[20] = a1[21];
            }
          }
        }
      }
    }
  }

  return sub_1CC8D7950((uint64_t)a1, a2);
}

void sub_1CC8D8A80()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0E0))
  {
    __cxa_guard_release(&qword_1EA61C0E0);
  }
}

unint64_t sub_1CC8D8AD4(uint64_t a1, uint64_t a2)
{
  unint64_t result = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (result)
  {
    uint64_t v5 = sub_1CC8BB6D4(a2, result, 0, a1, 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = a1 + 32;
    int v9 = *(unsigned __int16 *)(v7 + 10);
    (*(void (**)(uint64_t, void))(v8 + 48))(v7, *(unsigned __int16 *)(v6 + 10));
    return v9 == *(unsigned __int16 *)(v7 + 10);
  }
  else
  {
    *(_WORD *)(a1 + 42) = *(_WORD *)(a1 + 40);
  }
  return result;
}

uint64_t *sub_1CC8D8B90(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8D8BB8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D8C20(uint64_t a1, llvm::IRPosition *a2)
{
  uint64_t v4 = sub_1CD648FA4(a2);
  sub_1CC8DCAFC(a1, a2, *(_DWORD *)(v4 + 8) >> 8);
  *(void *)a1 = &unk_1F2624430;
  *(void *)(a1 + 32) = &unk_1F26244C0;
  *(_DWORD *)(a1 + 112) = 0;
  return a1;
}

uint64_t sub_1CC8D8CA4(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 80);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8D8DBC(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8D8EF4(uint64_t a1, uint64_t *a2)
{
  sub_1CC8DC980(a1, a2);
  uint64_t v3 = a1 + 32;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 24))(a1 + 32);
  if (result) {
    return result;
  }
  uint64_t result = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  uint64_t v5 = result;
  unsigned int v6 = *(unsigned __int8 *)(result + 16);
  if (v6 == 16)
  {
    unsigned int v9 = *(_DWORD *)(result + 32);
    if (v9 > 0x40) {
      operator new[]();
    }
    uint64_t v10 = *(void *)(result + 24);
    unsigned int v29 = *(_DWORD *)(result + 32);
    uint64_t v28 = v10;
    unsigned int v33 = v9;
    goto LABEL_23;
  }
  if (v6 - 11 <= 1)
  {
    unsigned int v11 = *(_DWORD *)(a1 + 40);
    if (v11 > 0x40) {
      operator new[]();
    }
    uint64_t v10 = 0;
    unsigned int v29 = *(_DWORD *)(a1 + 40);
    uint64_t v28 = 0;
    unsigned int v33 = v11;
LABEL_23:
    uint64_t v32 = v10;
    llvm::APInt::operator+=((uint64_t)&v32, 1uLL);
    unsigned int v31 = v33;
    uint64_t v30 = v32;
    sub_1CD65AED8(v3, (unsigned int *)&v28);
    if (v31 >= 0x41 && v30) {
      MEMORY[0x1D25D9CB0](v30, 0x1000C8000313F17);
    }
    if (v29 >= 0x41 && v28) {
      MEMORY[0x1D25D9CB0](v28, 0x1000C8000313F17);
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  if (v6 < 0x1C) {
    goto LABEL_44;
  }
  BOOL v7 = v6 - 33 > 0x33 || ((1 << (v6 - 33)) & 0x8000000000041) == 0;
  if (!v7 || v6 - 41 < 0x12 || v6 - 81 < 2 || v6 - 66 < 0xD) {
    return result;
  }
  if (v6 != 60)
  {
LABEL_44:
    if (v6 == 83 || v6 == 85) {
      return result;
    }
    goto LABEL_46;
  }
  int v8 = *(_DWORD *)(result + 20);
  if (*(void *)(result + 48))
  {
    if ((v8 & 0x20000000) == 0)
    {
LABEL_43:
      unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
      goto LABEL_44;
    }
  }
  else if ((v8 & 0x20000000) == 0)
  {
LABEL_46:
    uint64_t v25 = *(uint64_t (**)(uint64_t))(*(void *)v3 + 40);
    return v25(a1 + 32);
  }
  uint64_t v12 = ***(void ***)result;
  uint64_t v28 = result;
  int v13 = *(_DWORD *)(v12 + 2496);
  if (v13)
  {
    uint64_t v14 = *(void *)(v12 + 2480);
    int v15 = v13 - 1;
    unsigned int v16 = v15 & ((result >> 4) ^ (result >> 9));
    uint64_t result = v14 + 40 * v16;
    uint64_t v17 = *(uint64_t ***)result;
    if (*(void *)result == v5) {
      goto LABEL_37;
    }
    unint64_t v18 = 0;
    int v19 = 1;
    while (v17 != (uint64_t **)-4096)
    {
      if (v18) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v17 == (uint64_t **)-8192;
      }
      if (v20) {
        unint64_t v18 = (void *)result;
      }
      unsigned int v21 = v16 + v19++;
      unsigned int v16 = v21 & v15;
      uint64_t result = v14 + 40 * v16;
      uint64_t v17 = *(uint64_t ***)result;
      if (*(void *)result == v5) {
        goto LABEL_37;
      }
    }
    if (v18) {
      int v26 = v18;
    }
    else {
      int v26 = (void *)result;
    }
  }
  else
  {
    int v26 = 0;
  }
  uint64_t result = (uint64_t)sub_1CC609054(v12 + 2480, (uint64_t)&v28, &v28, v26);
  uint64_t v27 = v28;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)uint64_t result = v27;
  *(void *)(result + 8) = result + 24;
  *(void *)(result + 16) = 0x100000000;
LABEL_37:
  uint64_t v22 = *(unsigned int *)(result + 16);
  if (!v22) {
    goto LABEL_43;
  }
  int v23 = (uint64_t *)(*(void *)(result + 8) + 8);
  uint64_t v24 = 16 * v22;
  while (*((_DWORD *)v23 - 2) != 4)
  {
    v23 += 2;
    v24 -= 16;
    if (!v24) {
      goto LABEL_43;
    }
  }
  uint64_t result = *v23;
  if (!*v23) {
    goto LABEL_43;
  }
  llvm::getConstantRangeFromMetadata(result, (uint64_t)&v28);
  uint64_t result = sub_1CD65AE50(a1 + 32, (llvm::ConstantRange *)&v28);
  if (v31 >= 0x41)
  {
    uint64_t result = v30;
    if (v30) {
      uint64_t result = MEMORY[0x1D25D9CB0](v30, 0x1000C8000313F17);
    }
  }
  if (v29 >= 0x41)
  {
    uint64_t result = v28;
    if (v28) {
      return MEMORY[0x1D25D9CB0](v28, 0x1000C8000313F17);
    }
  }
  return result;
}

void sub_1CC8D936C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v19[0] = 0;
  v19[1] = 0;
  uint64_t v20 = 0;
  int v11 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  unint64_t v18 = v19;
  int v17 = 0;
  uint64_t v10 = &unk_1F2646F30;
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v10, "range(", 6uLL);
  sub_1CD098D14((llvm::raw_ostream *)&v10, *(unsigned int *)(a1 + 40), 0, 0, 0);
  if ((unint64_t)(v13 - v14) > 1)
  {
    *(_WORD *)uint64_t v14 = 15401;
    v14 += 2;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v10, ")<", 2uLL);
  }
  unsigned int v7 = *(_DWORD *)(a1 + 88);
  if (v7 > 0x40) {
    operator new[]();
  }
  uint64_t v6 = *(void *)(a1 + 80);
  unsigned int v9 = *(_DWORD *)(a1 + 104);
  if (v9 > 0x40) {
    operator new[]();
  }
  uint64_t v8 = *(void *)(a1 + 96);
  llvm::ConstantRange::print((llvm::ConstantRange *)&v6, (llvm::raw_ostream *)&v10);
  if (v9 >= 0x41 && v8) {
    MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
  }
  if (v7 >= 0x41 && v6) {
    MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
  }
  uint64_t v4 = v14;
  if ((unint64_t)(v13 - v14) > 2)
  {
    void v14[2] = 32;
    *uint64_t v4 = 12064;
    v14 += 3;
  }
  else
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v10, " / ", 3uLL);
  }
  unsigned int v7 = *(_DWORD *)(a1 + 56);
  if (v7 > 0x40) {
    operator new[]();
  }
  uint64_t v6 = *(void *)(a1 + 48);
  unsigned int v9 = *(_DWORD *)(a1 + 72);
  if (v9 > 0x40) {
    operator new[]();
  }
  uint64_t v8 = *(void *)(a1 + 64);
  llvm::ConstantRange::print((llvm::ConstantRange *)&v6, (llvm::raw_ostream *)&v10);
  if (v9 >= 0x41 && v8) {
    MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
  }
  if (v7 >= 0x41 && v6) {
    MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
  }
  if (v13 == v14) {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v10, ">", 1uLL);
  }
  else {
    *v14++ = 62;
  }
  if (*((char *)v18 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v18, (unint64_t)v18[1]);
  }
  else
  {
    long long v5 = *(_OWORD *)v18;
    *(void *)(a2 + 16) = v18[2];
    *(_OWORD *)a2 = v5;
  }
  uint64_t v10 = &unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  if (SHIBYTE(v20) < 0) {
    operator delete(v19[0]);
  }
}

uint64_t sub_1CC8D976C(uint64_t a1)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  int v1 = (llvm::IRPosition *)(a1 + 16);
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 112))(&__s1);
  uint64_t v2 = (llvm::ConstantInt ***)sub_1CD6482F0(v1);
  uint64_t v3 = v61;
  if (v61 >= 0x41)
  {
    uint64_t v48 = __s1;
    if (memcmp(__s1, __s2, (((unint64_t)v61 + 63) >> 3) & 0x3FFFFFF8)) {
      goto LABEL_75;
    }
    int v49 = 0;
    int64_t v50 = (unint64_t)(v3 + 63) >> 6;
    do
    {
      BOOL v51 = v50-- < 1;
      if (v51) {
        break;
      }
      unint64_t v52 = v48[v50];
      v49 += __clz(v52);
    }
    while (!v52);
    int v53 = v3 | 0xFFFFFFC0;
    if ((v3 & 0x3F) == 0) {
      int v53 = 0;
    }
    if (v49 + v53 != v3)
    {
LABEL_75:
      LODWORD(v65) = v3;
      operator new[]();
    }
    goto LABEL_66;
  }
  if (!((unint64_t)__s2 | (unint64_t)__s1)) {
    goto LABEL_66;
  }
  LODWORD(v65) = v61;
  long long v64 = __s1;
  llvm::APInt::operator+=((uint64_t)&v64, 1uLL);
  unsigned int v5 = v65;
  uint64_t v6 = v64;
  LODWORD(v65) = 0;
  if (v63 > 0x40) {
    BOOL v7 = memcmp(__s2, v64, (((unint64_t)v63 + 63) >> 3) & 0x3FFFFFF8) == 0;
  }
  else {
    BOOL v7 = __s2 == v64;
  }
  char v8 = v7;
  if (v5 >= 0x41)
  {
    if (v6)
    {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
      if (v65 >= 0x41)
      {
        if (v64) {
          MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
        }
      }
    }
  }
  unsigned int v9 = *((unsigned __int8 *)v2 + 16);
  char v10 = v9 < 0x1C ? 1 : v8;
  if ((v10 & 1) != 0 || v9 != 84 && v9 != 60) {
    goto LABEL_66;
  }
  int v11 = *((_DWORD *)v2 + 5);
  if (v2[6])
  {
    if ((v11 & 0x20000000) == 0) {
      goto LABEL_39;
    }
LABEL_24:
    uint64_t v13 = *(void *)**v2;
    long long v64 = v2;
    int v14 = *(_DWORD *)(v13 + 2496);
    if (v14)
    {
      uint64_t v15 = *(void *)(v13 + 2480);
      int v16 = v14 - 1;
      unsigned int v17 = v16 & ((v2 >> 4) ^ (v2 >> 9));
      unint64_t v18 = (llvm::ConstantInt ****)(v15 + 40 * v17);
      int v19 = *v18;
      if (*v18 == v2) {
        goto LABEL_34;
      }
      uint64_t v20 = 0;
      int v21 = 1;
      while (v19 != (llvm::ConstantInt ***)-4096)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == (llvm::ConstantInt ***)-8192;
        }
        if (v22) {
          uint64_t v20 = v18;
        }
        unsigned int v23 = v17 + v21++;
        unsigned int v17 = v23 & v16;
        unint64_t v18 = (llvm::ConstantInt ****)(v15 + 40 * v17);
        int v19 = *v18;
        if (*v18 == v2) {
          goto LABEL_34;
        }
      }
      if (v20) {
        uint64_t v46 = v20;
      }
      else {
        uint64_t v46 = v18;
      }
    }
    else
    {
      uint64_t v46 = 0;
    }
    unint64_t v18 = (llvm::ConstantInt ****)sub_1CC609054(v13 + 2480, (uint64_t)&v64, (uint64_t *)&v64, v46);
    uint64_t v47 = (llvm::ConstantInt ***)v64;
    void v18[3] = 0;
    v18[4] = 0;
    *unint64_t v18 = v47;
    v18[1] = (llvm::ConstantInt ***)(v18 + 3);
    v18[2] = (llvm::ConstantInt ***)0x100000000;
LABEL_34:
    uint64_t v24 = *((unsigned int *)v18 + 4);
    if (v24)
    {
      uint64_t v25 = v18[1] + 1;
      uint64_t v26 = 16 * v24;
      while (*((_DWORD *)v25 - 2) != 4)
      {
        uint64_t v27 = 0;
        v25 += 2;
        v26 -= 16;
        if (!v26) {
          goto LABEL_40;
        }
      }
      uint64_t v27 = *v25;
LABEL_40:
      unsigned int v28 = v61;
      if (v61 > 0x40)
      {
        if (!memcmp(__s1, __s2, (((unint64_t)v61 + 63) >> 3) & 0x3FFFFFF8)
          && llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&__s1) == v28)
        {
          goto LABEL_66;
        }
      }
      else if (__s1 == __s2 && (!v61 || __s1 == (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v61)))
      {
        goto LABEL_66;
      }
      if (v27)
      {
        uint64_t v29 = *(unsigned int *)(v27 + 8);
        if (v29 > 2) {
          goto LABEL_66;
        }
        uint64_t v30 = (void *)(v27 - 8 * v29);
        uint64_t v31 = *(void *)(*v30 + 128);
        uint64_t v32 = *(void *)(v30[1] + 128);
        if (*(_DWORD *)(v31 + 32) > 0x40u) {
          operator new[]();
        }
        unsigned int v33 = *(void **)(v31 + 24);
        unsigned int v34 = *(_DWORD *)(v32 + 32);
        if (v34 > 0x40) {
          operator new[]();
        }
        unint64_t v35 = *(void **)(v32 + 24);
        LODWORD(v65) = *(_DWORD *)(v31 + 32);
        long long v64 = v33;
        unsigned int v67 = v34;
        uint64_t v66 = v35;
        if (!llvm::ConstantRange::contains((llvm::ConstantRange *)&v64, (const llvm::ConstantRange *)&__s1)) {
          goto LABEL_66;
        }
        if (v33 == __s1 && v35 == __s2) {
          goto LABEL_66;
        }
        unsigned int v28 = v61;
      }
      unsigned int v12 = v28;
      if (v28 < 0x41)
      {
LABEL_60:
        if ((unint64_t)__s2 | (unint64_t)__s1) {
          goto LABEL_61;
        }
LABEL_66:
        uint64_t v44 = 1;
        goto LABEL_67;
      }
      goto LABEL_91;
    }
LABEL_39:
    uint64_t v27 = 0;
    goto LABEL_40;
  }
  if ((v11 & 0x20000000) != 0) {
    goto LABEL_24;
  }
  unsigned int v12 = v61;
  if (v61 <= 0x40)
  {
    if (__s1 == __s2 && (!v61 || __s1 == (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v61))) {
      goto LABEL_66;
    }
    goto LABEL_60;
  }
  if (!memcmp(__s1, __s2, (((unint64_t)v61 + 63) >> 3) & 0x3FFFFFF8)
    && llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&__s1) == v12)
  {
    goto LABEL_66;
  }
LABEL_91:
  unint64_t v54 = v12 + 63;
  uint64_t v55 = __s1;
  if (!memcmp(__s1, __s2, (v54 >> 3) & 0x3FFFFFF8))
  {
    int v56 = 0;
    uint64_t v57 = v54 >> 6;
    do
    {
      BOOL v51 = v57-- < 1;
      if (v51) {
        break;
      }
      unint64_t v58 = v55[v57];
      v56 += __clz(v58);
    }
    while (!v58);
    unsigned int v59 = v12 | 0xFFFFFFC0;
    if ((v12 & 0x3F) == 0) {
      unsigned int v59 = 0;
    }
    if (v56 + v59 == v12) {
      goto LABEL_66;
    }
  }
LABEL_61:
  unsigned int v38 = *v2;
  unsigned int v39 = **v2;
  Splat = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v39, (llvm::LLVMContext *)&__s1, v4);
  if ((v38[1] & 0xFE) == 0x12) {
    Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v38 + 8) | ((unint64_t)(*((_DWORD *)v38 + 2) == 19) << 32)), (uint64_t)Splat);
  }
  long long v64 = (void *)llvm::ValueAsMetadata::get(Splat, Splat);
  unint64_t v42 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(*v38, (llvm::LLVMContext *)&__s2, v41);
  if ((v38[1] & 0xFE) == 0x12) {
    unint64_t v42 = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v38 + 8) | ((unint64_t)(*((_DWORD *)v38 + 2) == 19) << 32)), (uint64_t)v42);
  }
  uint64_t v65 = llvm::ValueAsMetadata::get(v42, v42);
  Impl = llvm::MDTuple::getImpl((uint64_t)v39, &v64, 2, 0, 1);
  llvm::Instruction::setMetadata((llvm::Instruction *)v2, 4, Impl);
  uint64_t v44 = 0;
LABEL_67:
  if (v63 >= 0x41 && __s2) {
    MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
  }
  if (v61 >= 0x41 && __s1) {
    MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
  }
  return v44;
}

void sub_1CC8D9F18()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0E8))
  {
    __cxa_guard_release(&qword_1EA61C0E8);
  }
}

uint64_t sub_1CC8D9F6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (llvm::Attributor *)a2;
  uint64_t v3 = a1;
  v252[12] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(_DWORD *)(a1 + 40);
  v204 = (uint64_t (**)(void **))&unk_1F26245C0;
  unsigned int v205 = v4;
  unsigned int v207 = v4;
  if (v4 >= 0x41) {
    operator new[]();
  }
  unsigned int v209 = v4;
  __src = 0;
  v208 = 0;
  unsigned int v5 = (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v4);
  if (!v4) {
    unsigned int v5 = 0;
  }
  v210 = v5;
  unsigned int v211 = v4;
  unsigned int v213 = v4;
  v212 = v5;
  BOOL v203 = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(a1 + 24);
  unint64_t v8 = sub_1CC8AB830((_DWORD *)(a1 + 16));
  v215[0] = v6;
  v215[1] = v7;
  v249[0] = 1;
  for (uint64_t i = 1; i != 9; i += 2)
    v249[i] = -4096;
  uint64_t v195 = v3 + 32;
  v250 = (char *)v252;
  uint64_t v251 = 0x400000000;
  unint64_t v10 = sub_1CD6482F0((llvm::IRPosition *)v215);
  int v11 = 0;
  v246[0] = v247;
  v246[1] = (void *)0x1000000000;
  v248[1] = 0;
  v248[0] = 0;
  v247[32] = v248;
  unint64_t v196 = v10;
  v242 = (char *)v245;
  unsigned int v244 = 16;
  v245[0] = v10;
  v245[1] = v8;
  int64x2_t v194 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  unsigned int v12 = 1;
  do
  {
    uint64_t v13 = &v242[16 * v12];
    uint64_t v15 = *((void *)v13 - 2);
    unint64_t v14 = *((void *)v13 - 1);
    unsigned int v243 = v12 - 1;
    v214[0] = v15;
    v214[1] = v14;
    if ((sub_1CD65837C((uint64_t)v246, v214) & 0x100000000) == 0) {
      goto LABEL_274;
    }
    if (v11 >= 16) {
      goto LABEL_436;
    }
    ++v11;
    if (*(unsigned char *)(*(void *)v15 + 8) == 15)
    {
      int v16 = llvm::Value::stripPointerCasts((llvm::Value *)v15);
      goto LABEL_11;
    }
    unsigned int v19 = *(unsigned __int8 *)(v15 + 16);
    if (v19 < 0x1C) {
      goto LABEL_36;
    }
    unsigned int v20 = v19 - 33;
    BOOL v21 = v20 > 0x33;
    uint64_t v22 = (1 << v20) & 0x8000000000041;
    if (v21 || v22 == 0) {
      goto LABEL_36;
    }
    uint64_t v24 = *(void *)(v15 - 32);
    if (!v24 || *(unsigned char *)(v24 + 16) || *(void *)(v24 + 24) != *(void *)(v15 + 72)) {
      goto LABEL_36;
    }
    if ((*(_WORD *)(v24 + 18) & 1) == 0)
    {
      uint64_t v25 = *(void *)(v24 + 88);
LABEL_27:
      uint64_t v26 = v25;
      goto LABEL_28;
    }
    llvm::Function::BuildLazyArguments(*(llvm::Function **)(v15 - 32));
    uint64_t v25 = *(void *)(v24 + 88);
    if ((*(_WORD *)(v24 + 18) & 1) == 0) {
      goto LABEL_27;
    }
    llvm::Function::BuildLazyArguments((llvm::Function *)v24);
    uint64_t v26 = *(void *)(v24 + 88);
LABEL_28:
    uint64_t v27 = v26 + 40 * *(void *)(v24 + 96);
    while (1)
    {
      if (v25 == v27) {
        goto LABEL_36;
      }
      uint64_t v28 = *(void *)(*(void *)(v25 + 24) + 112);
      if (v28)
      {
        uint64_t v29 = *(unsigned int *)(v25 + 32);
        if ((v29 + 2) < *(_DWORD *)(v28 + 8))
        {
          uint64_t v30 = *(void *)(v28 + 8 * (v29 + 2) + 40);
          if (v30)
          {
            if ((*(unsigned char *)(v30 + 17) & 0x40) != 0) {
              break;
            }
          }
        }
      }
      v25 += 40;
    }
    int v16 = *(llvm::Value **)(v15 - 32 * (*(_DWORD *)(v15 + 20) & 0x7FFFFFF) + 32 * v29);
LABEL_11:
    if (v16) {
      BOOL v17 = v16 == (llvm::Value *)v15;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17)
    {
      if (v243 >= (unint64_t)v244) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unint64_t v18 = &v242[16 * v243];
      *(void *)unint64_t v18 = v16;
      goto LABEL_96;
    }
LABEL_36:
    int v31 = *(unsigned __int8 *)(v15 + 16);
    if (v31 == 83)
    {
      int64_t v37 = *(void *)(*(void *)(v15 + 40) + 56);
      unint64_t v225 = v37;
      unsigned int v226 = 0;
      sub_1CD645794((uint64_t)&v236, (uint64_t)v249, (uint64_t *)&v225, &v226);
      uint64_t v38 = v236;
      if (v237.i8[8])
      {
        *(_DWORD *)&v231[20] = 0;
        *(_DWORD *)&v231[17] = 0;
        *(void *)v231 = v37;
        *(void *)&v231[8] = 0;
        v231[16] = 0;
        if (v251 >= HIDWORD(v251))
        {
          if (v250 > v231 || &v250[24 * v251] <= v231) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unsigned int v45 = &v250[24 * v251];
        long long v46 = *(_OWORD *)v231;
        *((void *)v45 + 2) = *(void *)&v231[16];
        *(_OWORD *)unsigned int v45 = v46;
        int v39 = v251;
        LODWORD(v251) = v251 + 1;
        *(_DWORD *)(v38 + 8) = v39;
      }
      else
      {
        int v39 = *(_DWORD *)(v236 + 8);
      }
      uint64_t v47 = v250;
      uint64_t v48 = &v250[24 * v39];
      uint64_t v50 = *((void *)v48 + 1);
      int v49 = (llvm::AbstractAttribute **)(v48 + 8);
      if (!v50) {
        *int v49 = sub_1CC8AC178(a2, v37, 0, v3, 2, 0, 1);
      }
      uint64_t v51 = *(_DWORD *)(v15 + 20) & 0x7FFFFFF;
      if (v51)
      {
        int v197 = v11;
        uint64_t v52 = 0;
        uint64_t v53 = 0;
        unint64_t v54 = &v47[24 * v39 + 16];
        uint64_t v55 = 8 * v51;
        do
        {
          int v56 = *(_DWORD *)(v15 + 20);
          if ((v56 & 0x40000000) != 0) {
            uint64_t v57 = *(void *)(v15 - 8);
          }
          else {
            uint64_t v57 = v15 - 32 * (v56 & 0x7FFFFFF);
          }
          uint64_t v58 = *(void *)(v57 + 32 * *(unsigned int *)(v15 + 60) + v53);
          if ((*(unsigned int (**)(llvm::AbstractAttribute *, uint64_t, void))(*(void *)*v49 + 168))(*v49, v58, *(void *)(v15 + 40)))
          {
            *unint64_t v54 = 1;
            v203 |= (*(unsigned __int8 (**)(void))(*((void *)*v49 + 4) + 24))() ^ 1;
          }
          else
          {
            int v59 = *(_DWORD *)(v15 + 20);
            if ((v59 & 0x40000000) != 0) {
              uint64_t v60 = *(void *)(v15 - 8);
            }
            else {
              uint64_t v60 = v15 - 32 * (v59 & 0x7FFFFFF);
            }
            uint64_t v61 = *(void *)(v58 + 40);
            if (v61 == v58 + 40)
            {
              uint64_t v63 = 0;
            }
            else
            {
              if (v61) {
                uint64_t v62 = v61 - 24;
              }
              else {
                uint64_t v62 = 0;
              }
              if (*(unsigned __int8 *)(v62 + 16) - 29 >= 0xB) {
                uint64_t v63 = 0;
              }
              else {
                uint64_t v63 = v62;
              }
            }
            uint64_t v64 = *(void *)(v60 + v52);
            if (v243 >= (unint64_t)v244) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v65 = &v242[16 * v243];
            *(void *)uint64_t v65 = v64;
            *((void *)v65 + 1) = v63;
            ++v243;
          }
          v53 += 8;
          v52 += 32;
        }
        while (v55 != v53);
        uint64_t v2 = (llvm::Attributor *)a2;
        int v11 = v197;
      }
      else
      {
        uint64_t v2 = (llvm::Attributor *)a2;
      }
      goto LABEL_274;
    }
    if (v31 != 85)
    {
      if (v31 == 21) {
        uint64_t v40 = (llvm::Argument *)v15;
      }
      else {
        uint64_t v40 = 0;
      }
      unint64_t v225 = (unint64_t)v40;
      if (v40 && (llvm::Argument::hasPassPointeeByValueCopyAttr(v40) & 1) == 0)
      {
        uint64_t v236 = (uint64_t)&v237.i64[1];
        v237.i64[0] = 0x300000000;
        LOBYTE(v220) = 0;
        *(void *)v231 = &v225;
        *(void *)&v231[8] = &v236;
        int v41 = llvm::Attributor::checkForAllCallSites((uint64_t)v2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8DD19C, (uint64_t)v231, *(void *)(v225 + 24), 1, v3, &v220);
        char v42 = v41;
        int v43 = 0;
        if (v41)
        {
          sub_1CD3D61B4((unsigned int *)&v242, (unsigned char *)v236, (unsigned char *)(v236 + 16 * v237.u32[0]));
          int v43 = 3;
        }
        if ((unint64_t *)v236 != &v237.u64[1]) {
          free((void *)v236);
        }
        if (v42)
        {
LABEL_269:
          if (v43 != 3 && v43 != 0)
          {
LABEL_436:
            int v187 = 0;
            goto LABEL_437;
          }
          goto LABEL_274;
        }
      }
      unsigned int v44 = *(unsigned __int8 *)(v15 + 16);
      if (v44 != 60)
      {
LABEL_125:
        if (v44 < 0x1C)
        {
          v231[0] = 0;
          uint64_t v80 = *(void *)(v3 + 24);
          if (!v44) {
            v15 |= 2uLL;
          }
LABEL_133:
          uint64_t v236 = v15;
          v237.i64[0] = v80;
          unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)&v236, (const llvm::AbstractAttribute *)v3, v231);
          if (v83)
          {
            uint64_t v85 = AssumedSimplified;
            if (AssumedSimplified)
            {
              uint64_t v86 = *(void *)(v3 + 24);
              unsigned int v87 = *(unsigned __int8 *)(AssumedSimplified + 16);
              if (v87 != 21)
              {
                if (v87 < 0x1C)
                {
                  if (!*(unsigned char *)(AssumedSimplified + 16)) {
                    uint64_t v85 = AssumedSimplified | 2;
                  }
                }
                else
                {
                  unsigned int v88 = v87 - 33;
                  if (v88 <= 0x33 && ((1 << v88) & 0x8000000000041) != 0)
                  {
                    uint64_t v86 = 0;
                    uint64_t v85 = AssumedSimplified | 1;
                  }
                }
              }
              uint64_t v94 = sub_1CC8C972C((uint64_t)v2, v85, v86, v3, 0);
              (*(void (**)(uint64_t *__return_ptr))(*(void *)v94 + 112))(&v236);
              sub_1CD65AED8((uint64_t)&v204, (unsigned int *)&v236);
              if (v238.i32[0] >= 0x41u && v237.i64[1]) {
                MEMORY[0x1D25D9CB0](v237.i64[1], 0x1000C8000313F17);
              }
              if (v237.i32[0] >= 0x41u && v236) {
                MEMORY[0x1D25D9CB0](v236, 0x1000C8000313F17);
              }
              int v84 = v204[2]((void **)&v204);
            }
            else
            {
              int v84 = 0;
            }
          }
          else
          {
            int v84 = 1;
          }
LABEL_268:
          int v43 = v84 ^ 1;
          goto LABEL_269;
        }
        unsigned int v81 = v44 - 33;
        if (v44 - 33 <= 0x33 && ((1 << v81) & 0x8000000000041) != 0)
        {
          v231[0] = 0;
          uint64_t v80 = *(void *)(v3 + 24);
          if (v81 <= 0x33 && ((1 << v81) & 0x8000000000041) != 0)
          {
            uint64_t v80 = 0;
            v15 |= 1uLL;
          }
          goto LABEL_133;
        }
        uint64_t v236 = (uint64_t)&v237.i64[1];
        v237.i64[0] = 0x400000000;
        if (v44 - 59 >= 0xFFFFFFEE)
        {
          uint64_t v89 = *(void *)(v15 - 64);
          uint64_t v90 = *(void *)(v15 - 32);
          LOBYTE(v216) = 0;
          uint64_t v91 = *(void *)(v3 + 24);
          unsigned int v92 = *(unsigned __int8 *)(v89 + 16);
          if (v92 != 21)
          {
            if (v92 < 0x1C)
            {
              if (!*(unsigned char *)(v89 + 16)) {
                v89 |= 2uLL;
              }
            }
            else
            {
              unsigned int v93 = v92 - 33;
              if (v93 <= 0x33 && ((1 << v93) & 0x8000000000041) != 0)
              {
                uint64_t v91 = 0;
                v89 |= 1uLL;
              }
            }
          }
          *(void *)v231 = v89;
          *(void *)&v231[8] = v91;
          unint64_t v108 = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)v231, (const llvm::AbstractAttribute *)v3, (BOOL *)&v216);
          if (!v109) {
            goto LABEL_223;
          }
          unint64_t v110 = v108;
          if (v108)
          {
            uint64_t v111 = *(void *)(a1 + 24);
            unsigned int v112 = *(unsigned __int8 *)(v90 + 16);
            if (v112 != 21)
            {
              if (v112 < 0x1C)
              {
                if (!*(unsigned char *)(v90 + 16)) {
                  v90 |= 2uLL;
                }
              }
              else
              {
                unsigned int v113 = v112 - 33;
                if (v113 <= 0x33 && ((1 << v113) & 0x8000000000041) != 0)
                {
                  uint64_t v111 = 0;
                  v90 |= 1uLL;
                }
              }
            }
            *(void *)v231 = v90;
            *(void *)&v231[8] = v111;
            unint64_t v126 = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)v231, (const llvm::AbstractAttribute *)a1, (BOOL *)&v216);
            if (!v127) {
              goto LABEL_223;
            }
            uint64_t v128 = v126;
            if (v126)
            {
              if (*(unsigned char *)(*(void *)v110 + 8) == 13 && *(unsigned char *)(*(void *)v126 + 8) == 13)
              {
                uint64_t v129 = *(void *)(a1 + 24);
                unsigned int v130 = *(unsigned __int8 *)(v110 + 16);
                if (v130 != 21)
                {
                  if (v130 < 0x1C)
                  {
                    if (!*(unsigned char *)(v110 + 16)) {
                      v110 |= 2uLL;
                    }
                  }
                  else
                  {
                    unsigned int v131 = v130 - 33;
                    if (v131 <= 0x33 && ((1 << v131) & 0x8000000000041) != 0)
                    {
                      uint64_t v129 = 0;
                      v110 |= 1uLL;
                    }
                  }
                }
                uint64_t v151 = v110;
                uint64_t v3 = a1;
                unsigned int v152 = sub_1CC8C972C((uint64_t)v2, v151, v129, a1, 0);
                if (v237.u32[0] >= (unint64_t)v237.u32[1]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(v236 + 8 * v237.u32[0]) = v152;
                ++v237.i32[0];
                (*(void (**)(unsigned char *__return_ptr, llvm::AbstractAttribute *, llvm::Attributor *, unint64_t))(*(void *)v152 + 112))(v231, v152, v2, v14);
                uint64_t v153 = *(void *)(a1 + 24);
                unsigned int v154 = *(unsigned __int8 *)(v128 + 16);
                if (v154 != 21)
                {
                  if (v154 < 0x1C)
                  {
                    if (!*(unsigned char *)(v128 + 16)) {
                      v128 |= 2uLL;
                    }
                  }
                  else
                  {
                    unsigned int v155 = v154 - 33;
                    if (v155 <= 0x33 && ((1 << v155) & 0x8000000000041) != 0)
                    {
                      uint64_t v153 = 0;
                      v128 |= 1uLL;
                    }
                  }
                }
                v156 = sub_1CC8C972C((uint64_t)v2, v128, v153, a1, 0);
                if (v237.u32[0] >= (unint64_t)v237.u32[1]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(v236 + 8 * v237.u32[0]) = v156;
                ++v237.i32[0];
                (*(void (**)(unint64_t *__return_ptr, llvm::AbstractAttribute *, llvm::Attributor *, unint64_t))(*(void *)v156 + 112))(&v225, v156, v2, v14);
                llvm::ConstantRange::binaryOp((llvm::ConstantRange *)&v225, (unsigned int *)v231, *(unsigned __int8 *)(v15 + 16) - 28, &v220);
                sub_1CD65AED8((uint64_t)&v204, (unsigned int *)&v220);
                char v157 = v204[2]((void **)&v204);
                if (v223 >= 0x41 && v222) {
                  MEMORY[0x1D25D9CB0](v222, 0x1000C8000313F17);
                }
                if (v221 >= 0x41 && v220) {
                  MEMORY[0x1D25D9CB0](v220, 0x1000C8000313F17);
                }
                if (v228 >= 0x41 && v227) {
                  MEMORY[0x1D25D9CB0](v227, 0x1000C8000313F17);
                }
                if (v226 >= 0x41 && v225) {
                  MEMORY[0x1D25D9CB0](v225, 0x1000C8000313F17);
                }
                int v198 = v11;
LABEL_311:
                if (v232.i32[0] >= 0x41u && *(void *)&v231[16]) {
                  MEMORY[0x1D25D9CB0](*(void *)&v231[16], 0x1000C8000313F17);
                }
                if (*(_DWORD *)&v231[8] >= 0x41u && *(void *)v231) {
                  MEMORY[0x1D25D9CB0](*(void *)v231, 0x1000C8000313F17);
                }
                if (v157) {
                  goto LABEL_224;
                }
                goto LABEL_314;
              }
            }
          }
        }
        else
        {
          if (v44 - 83 < 0xFFFFFFFE)
          {
            if (v44 - 79 < 0xFFFFFFF3)
            {
              v204[5]((void **)&v204);
LABEL_146:
              int v84 = 0;
              goto LABEL_266;
            }
            uint64_t v104 = *(void *)(v15 - 32);
            LOBYTE(v220) = 0;
            uint64_t v105 = *(void *)(v3 + 24);
            unsigned int v106 = *(unsigned __int8 *)(v104 + 16);
            if (v106 != 21)
            {
              if (v106 < 0x1C)
              {
                if (!*(unsigned char *)(v104 + 16)) {
                  v104 |= 2uLL;
                }
              }
              else
              {
                unsigned int v107 = v106 - 33;
                if (v107 <= 0x33 && ((1 << v107) & 0x8000000000041) != 0)
                {
                  uint64_t v105 = 0;
                  v104 |= 1uLL;
                }
              }
            }
            *(void *)v231 = v104;
            *(void *)&v231[8] = v105;
            unint64_t v120 = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)v231, (const llvm::AbstractAttribute *)v3, (BOOL *)&v220);
            if (!v121)
            {
              int v198 = v11;
LABEL_224:
              if (!v237.i32[0])
              {
LABEL_225:
                int v84 = v204[2]((void **)&v204);
                uint64_t v2 = (llvm::Attributor *)a2;
LABEL_226:
                int v11 = v198;
                goto LABEL_266;
              }
              uint64_t v134 = (void *)v236;
              uint64_t v135 = 8 * v237.u32[0];
              while (*v134 != v3)
              {
LABEL_244:
                ++v134;
                v135 -= 8;
                if (!v135) {
                  goto LABEL_225;
                }
              }
              uint64_t v136 = v207;
              if (v207 > 0x40) {
                operator new[]();
              }
              v202 = __src;
              uint64_t v137 = v209;
              if (v209 > 0x40) {
                operator new[]();
              }
              __s1 = v208;
              uint64_t v138 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
              if (*(_DWORD *)(v138 + 24) > 0x40u) {
                operator new[]();
              }
              uint64_t v139 = *(const void **)(v138 + 16);
              if (*(_DWORD *)(v138 + 40) > 0x40u) {
                operator new[]();
              }
              int64x2_t v140 = *(const void **)(v138 + 32);
              if (v136 > 0x40)
              {
                if (!memcmp(v202, v139, ((unint64_t)(v136 + 63) >> 3) & 0x3FFFFFF8)) {
                  goto LABEL_235;
                }
              }
              else if (v202 == v139)
              {
LABEL_235:
                if (v137 > 0x40) {
                  BOOL v141 = memcmp(__s1, v140, ((unint64_t)(v137 + 63) >> 3) & 0x3FFFFFF8) == 0;
                }
                else {
                  BOOL v141 = __s1 == v140;
                }
                char v142 = v141;
                goto LABEL_240;
              }
              char v142 = 0;
LABEL_240:
              if (v137 >= 0x41 && __s1) {
                MEMORY[0x1D25D9CB0](__s1, 0x1000C8000313F17);
              }
              uint64_t v3 = a1;
              if (v136 >= 0x41 && v202) {
                MEMORY[0x1D25D9CB0](v202, 0x1000C8000313F17);
              }
              if ((v142 & 1) == 0) {
                v204[5]((void **)&v204);
              }
              goto LABEL_244;
            }
            uint64_t v122 = v120;
            if (!v120 || *(unsigned char *)(*(void *)v120 + 8) != 13) {
              goto LABEL_146;
            }
            uint64_t v123 = *(void *)(v3 + 24);
            unsigned int v124 = *(unsigned __int8 *)(v120 + 16);
            if (v124 != 21)
            {
              if (v124 < 0x1C)
              {
                if (!*(unsigned char *)(v120 + 16)) {
                  uint64_t v122 = v120 | 2;
                }
              }
              else
              {
                unsigned int v125 = v124 - 33;
                if (v125 <= 0x33 && ((1 << v125) & 0x8000000000041) != 0)
                {
                  uint64_t v123 = 0;
                  uint64_t v122 = v120 | 1;
                }
              }
            }
            uint64_t v148 = sub_1CC8C972C((uint64_t)v2, v122, v123, v3, 0);
            if (v237.u32[0] >= (unint64_t)v237.u32[1]) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(v236 + 8 * v237.u32[0]) = v148;
            ++v237.i32[0];
            unsigned int v226 = *((_DWORD *)v148 + 14);
            if (v226 > 0x40) {
              operator new[]();
            }
            unint64_t v225 = *((void *)v148 + 6);
            unsigned int v228 = *((_DWORD *)v148 + 18);
            if (v228 > 0x40) {
              operator new[]();
            }
            unint64_t v227 = *((void *)v148 + 8);
            int v149 = *(unsigned __int8 *)(v15 + 16) - 28;
            uint64_t v150 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
            llvm::ConstantRange::castOp(&v225, v149, *(_DWORD *)(v150 + 8), (uint64_t)v231);
            sub_1CD65AED8((uint64_t)&v204, (unsigned int *)v231);
            if (v232.i32[0] >= 0x41u && *(void *)&v231[16]) {
              MEMORY[0x1D25D9CB0](*(void *)&v231[16], 0x1000C8000313F17);
            }
            if (*(_DWORD *)&v231[8] >= 0x41u && *(void *)v231) {
              MEMORY[0x1D25D9CB0](*(void *)v231, 0x1000C8000313F17);
            }
            int v198 = v11;
            if (v228 >= 0x41 && v227) {
              MEMORY[0x1D25D9CB0](v227, 0x1000C8000313F17);
            }
            if (v226 >= 0x41 && v225) {
              MEMORY[0x1D25D9CB0](v225, 0x1000C8000313F17);
            }
            if (v204[2]((void **)&v204)) {
              goto LABEL_224;
            }
LABEL_314:
            int v84 = 0;
            goto LABEL_226;
          }
          uint64_t v99 = *(void *)(v15 - 64);
          uint64_t v100 = *(void *)(v15 - 32);
          BOOL v224 = 0;
          uint64_t v101 = *(void *)(v3 + 24);
          unsigned int v102 = *(unsigned __int8 *)(v99 + 16);
          if (v102 != 21)
          {
            if (v102 < 0x1C)
            {
              if (!*(unsigned char *)(v99 + 16)) {
                v99 |= 2uLL;
              }
            }
            else
            {
              unsigned int v103 = v102 - 33;
              if (v103 <= 0x33 && ((1 << v103) & 0x8000000000041) != 0)
              {
                uint64_t v101 = 0;
                v99 |= 1uLL;
              }
            }
          }
          *(void *)v231 = v99;
          *(void *)&v231[8] = v101;
          unint64_t v114 = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)v231, (const llvm::AbstractAttribute *)v3, &v224);
          if (!v115)
          {
LABEL_223:
            int v198 = v11;
            uint64_t v3 = a1;
            goto LABEL_224;
          }
          int64_t v116 = v114;
          if (v114)
          {
            uint64_t v117 = *(void *)(a1 + 24);
            unsigned int v118 = *(unsigned __int8 *)(v100 + 16);
            if (v118 != 21)
            {
              if (v118 < 0x1C)
              {
                if (!*(unsigned char *)(v100 + 16)) {
                  v100 |= 2uLL;
                }
              }
              else
              {
                unsigned int v119 = v118 - 33;
                if (v119 <= 0x33 && ((1 << v119) & 0x8000000000041) != 0)
                {
                  uint64_t v117 = 0;
                  v100 |= 1uLL;
                }
              }
            }
            *(void *)v231 = v100;
            *(void *)&v231[8] = v117;
            unint64_t v132 = llvm::Attributor::getAssumedSimplified(v2, (const llvm::IRPosition *)v231, (const llvm::AbstractAttribute *)a1, &v224);
            if (!v133) {
              goto LABEL_223;
            }
            uint64_t v143 = v132;
            if (v132)
            {
              if (*(unsigned char *)(*(void *)v116 + 8) == 13 && *(unsigned char *)(*(void *)v132 + 8) == 13)
              {
                uint64_t v144 = *(void *)(a1 + 24);
                unsigned int v145 = *(unsigned __int8 *)(v116 + 16);
                if (v145 != 21)
                {
                  if (v145 < 0x1C)
                  {
                    if (!*(unsigned char *)(v116 + 16)) {
                      v116 |= 2uLL;
                    }
                  }
                  else
                  {
                    unsigned int v146 = v145 - 33;
                    if (v146 <= 0x33 && ((1 << v146) & 0x8000000000041) != 0)
                    {
                      uint64_t v144 = 0;
                      v116 |= 1uLL;
                    }
                  }
                }
                uint64_t v158 = sub_1CC8C972C((uint64_t)v2, v116, v144, a1, 0);
                if (v237.u32[0] >= (unint64_t)v237.u32[1]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(v236 + 8 * v237.u32[0]) = v158;
                ++v237.i32[0];
                uint64_t v159 = *(void *)(a1 + 24);
                unsigned int v160 = *(unsigned __int8 *)(v143 + 16);
                if (v160 != 21)
                {
                  if (v160 < 0x1C)
                  {
                    if (!*(unsigned char *)(v143 + 16)) {
                      v143 |= 2uLL;
                    }
                  }
                  else
                  {
                    unsigned int v161 = v160 - 33;
                    if (v161 <= 0x33 && ((1 << v161) & 0x8000000000041) != 0)
                    {
                      uint64_t v159 = 0;
                      v143 |= 1uLL;
                    }
                  }
                }
                uint64_t v162 = sub_1CC8C972C((uint64_t)v2, v143, v159, a1, 0);
                if (v237.u32[0] >= (unint64_t)v237.u32[1]) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                int v198 = v11;
                *(void *)(v236 + 8 * v237.u32[0]) = v162;
                ++v237.i32[0];
                (*(void (**)(unsigned char *__return_ptr, llvm::AbstractAttribute *, llvm::Attributor *, unint64_t))(*(void *)v158 + 112))(v231, v158, v2, v14);
                (*(void (**)(unint64_t *__return_ptr, llvm::AbstractAttribute *, llvm::Attributor *, unint64_t))(*(void *)v162 + 112))(&v225, v162, v2, v14);
                uint64_t v163 = *(unsigned int *)&v231[8];
                if (*(_DWORD *)&v231[8] >= 0x41u)
                {
                  uint64_t v165 = *(void *)v231;
                  uint64_t v3 = a1;
                  if (!memcmp(*(const void **)v231, *(const void **)&v231[16], (((unint64_t)*(unsigned int *)&v231[8] + 63) >> 3) & 0x3FFFFFF8))
                  {
                    int v166 = 0;
                    int64_t v167 = (unint64_t)(v163 + 63) >> 6;
                    do
                    {
                      BOOL v21 = v167-- < 1;
                      if (v21) {
                        break;
                      }
                      unint64_t v168 = *(void *)(v165 + 8 * v167);
                      v166 += __clz(v168);
                    }
                    while (!v168);
                    int v169 = v163 | 0xFFFFFFC0;
                    if ((v163 & 0x3F) == 0) {
                      int v169 = 0;
                    }
                    uint64_t v3 = a1;
                    if (v166 + v169 == v163) {
                      goto LABEL_332;
                    }
                  }
                }
                else
                {
                  uint64_t v3 = a1;
                  if (!(*(void *)&v231[16] | *(void *)v231)) {
                    goto LABEL_332;
                  }
                }
                uint64_t v164 = v226;
                if (v226 >= 0x41)
                {
                  unint64_t v170 = v225;
                  if (!memcmp((const void *)v225, (const void *)v227, (((unint64_t)v226 + 63) >> 3) & 0x3FFFFFF8))
                  {
                    int v179 = 0;
                    int64_t v180 = (unint64_t)(v164 + 63) >> 6;
                    do
                    {
                      BOOL v21 = v180-- < 1;
                      if (v21) {
                        break;
                      }
                      unint64_t v181 = *(void *)(v170 + 8 * v180);
                      v179 += __clz(v181);
                    }
                    while (!v181);
                    int v182 = v164 | 0xFFFFFFC0;
                    if ((v164 & 0x3F) == 0) {
                      int v182 = 0;
                    }
                    uint64_t v3 = a1;
                    if (v179 + v182 == v164) {
                      goto LABEL_332;
                    }
                  }
                }
                else if (!(v227 | v225))
                {
LABEL_332:
                  if (v228 >= 0x41 && v227) {
                    MEMORY[0x1D25D9CB0](v227, 0x1000C8000313F17);
                  }
                  if (v226 >= 0x41 && v225) {
                    MEMORY[0x1D25D9CB0](v225, 0x1000C8000313F17);
                  }
                  if (v232.i32[0] >= 0x41u && *(void *)&v231[16]) {
                    MEMORY[0x1D25D9CB0](*(void *)&v231[16], 0x1000C8000313F17);
                  }
                  if (*(_DWORD *)&v231[8] >= 0x41u && *(void *)v231) {
                    MEMORY[0x1D25D9CB0](*(void *)v231, 0x1000C8000313F17);
                  }
                  goto LABEL_224;
                }
                llvm::ConstantRange::makeAllowedICmpRegion((llvm::ConstantRange *)&v225, *(_WORD *)(v15 + 18) & 0x3F, (uint64_t)&v220);
                llvm::ConstantRange::intersectWith((uint64_t)&v220, (llvm::ConstantRange *)v231, 0, (uint64_t)&v216);
                uint64_t v171 = v217;
                if (v217 > 0x40)
                {
                  BOOL v178 = v216;
                  unint64_t v172 = v218;
                  if (memcmp(v216, (const void *)v218, (((unint64_t)v217 + 63) >> 3) & 0x3FFFFFF8))
                  {
                    int v174 = 0;
LABEL_374:
                    if (v219 >= 0x41 && v172 != 0)
                    {
                      MEMORY[0x1D25D9CB0](v172, 0x1000C8000313F17);
                      LODWORD(v171) = v217;
                    }
                    if (v171 >= 0x41 && v216) {
                      MEMORY[0x1D25D9CB0](v216, 0x1000C8000313F17);
                    }
                    BOOL v176 = llvm::ConstantRange::icmp((const llvm::ConstantRange *)v231, *(_WORD *)(v15 + 18) & 0x3F, (llvm::ConstantRange *)&v225);
                    uint64_t v177 = 1;
                    if (v176)
                    {
                      unsigned int v217 = 1;
                      v216 = (void *)1;
                      int v230 = 1;
                      uint64_t v229 = 1;
                    }
                    else
                    {
                      if (!v174)
                      {
                        unsigned int v217 = 1;
                        v216 = (void *)1;
                        unsigned int v219 = 1;
LABEL_386:
                        unint64_t v218 = v177;
                        sub_1CD65AED8((uint64_t)&v204, (unsigned int *)&v216);
                        if (v219 >= 0x41 && v218) {
                          MEMORY[0x1D25D9CB0](v218, 0x1000C8000313F17);
                        }
                        if (v217 >= 0x41 && v216) {
                          MEMORY[0x1D25D9CB0](v216, 0x1000C8000313F17);
                        }
                        uint64_t v2 = (llvm::Attributor *)a2;
                        uint64_t v3 = a1;
                        char v157 = v204[2]((void **)&v204);
                        if (v223 >= 0x41 && v222) {
                          MEMORY[0x1D25D9CB0](v222, 0x1000C8000313F17);
                        }
                        if (v221 >= 0x41 && v220) {
                          MEMORY[0x1D25D9CB0](v220, 0x1000C8000313F17);
                        }
                        if (v228 >= 0x41 && v227) {
                          MEMORY[0x1D25D9CB0](v227, 0x1000C8000313F17);
                        }
                        if (v226 >= 0x41 && v225) {
                          MEMORY[0x1D25D9CB0](v225, 0x1000C8000313F17);
                        }
                        goto LABEL_311;
                      }
                      unsigned int v217 = 1;
                      v216 = 0;
                      int v230 = 1;
                      uint64_t v229 = 0;
                    }
                    llvm::APInt::operator+=((uint64_t)&v229, 1uLL);
                    unsigned int v219 = v230;
                    uint64_t v177 = v229;
                    goto LABEL_386;
                  }
                  int v183 = 0;
                  int64_t v184 = (unint64_t)(v171 + 63) >> 6;
                  do
                  {
                    BOOL v21 = v184-- < 1;
                    if (v21) {
                      break;
                    }
                    unint64_t v185 = v178[v184];
                    v183 += __clz(v185);
                  }
                  while (!v185);
                  int v186 = v171 | 0xFFFFFFC0;
                  if ((v171 & 0x3F) == 0) {
                    int v186 = 0;
                  }
                  BOOL v173 = v183 + v186 == v171;
                }
                else
                {
                  unint64_t v172 = v218;
                  BOOL v173 = (v218 | (unint64_t)v216) == 0;
                }
                int v174 = v173;
                goto LABEL_374;
              }
            }
          }
        }
        int v84 = 0;
        uint64_t v3 = a1;
LABEL_266:
        if ((unint64_t *)v236 != &v237.u64[1]) {
          free((void *)v236);
        }
        goto LABEL_268;
      }
      LOBYTE(v225) = 0;
      if (*(void *)(v15 - 32) == v196)
      {
        unsigned int v44 = 60;
        goto LABEL_125;
      }
      int v73 = v11;
      uint64_t v236 = 1;
      int64x2_t v237 = v194;
      int64x2_t v238 = v194;
      v239 = v241;
      uint64_t v240 = 0x400000000;
      *(void *)v231 = 1;
      *(int64x2_t *)&v231[8] = v194;
      int64x2_t v232 = v194;
      v233 = v235;
      uint64_t v234 = 0x400000000;
      LODWORD(v74) = 1;
      if (llvm::AA::getPotentiallyLoadedValues(v2, v15, &v236, v231, (const llvm::AbstractAttribute *)v3, (BOOL *)&v225, 1))
      {
        if (!v240)
        {
LABEL_104:
          LODWORD(v74) = 0;
LABEL_105:
          int v43 = 3;
LABEL_116:
          if (v233 != v235) {
            free(v233);
          }
          if ((v231[0] & 1) == 0) {
            MEMORY[0x1D25D9CD0](*(void *)&v231[8], 8);
          }
          if (v239 != v241) {
            free(v239);
          }
          if (v236)
          {
            if (v74)
            {
LABEL_124:
              unsigned int v44 = *(unsigned __int8 *)(v15 + 16);
              int v11 = v73;
              goto LABEL_125;
            }
          }
          else
          {
            MEMORY[0x1D25D9CD0](v237.i64[0], 8);
            if (v74) {
              goto LABEL_124;
            }
          }
          int v11 = v73;
          goto LABEL_269;
        }
        int v75 = (int64_t *)v239;
        uint64_t v76 = 8 * v240;
        while (1)
        {
          LODWORD(v74) = 1;
          if (!llvm::AA::isDynamicallyUnique(v2, (llvm::Attributor *)v3, *v75, (const llvm::Value *)1)) {
            break;
          }
          ++v75;
          v76 -= 8;
          if (!v76)
          {
            if (!v240) {
              goto LABEL_104;
            }
            uint64_t v77 = v239;
            unsigned int v78 = v243;
            uint64_t v74 = 8 * v240;
            do
            {
              if (v78 >= v244) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              unsigned int v79 = &v242[16 * v78];
              *(void *)unsigned int v79 = *v77;
              *((void *)v79 + 1) = v14;
              unsigned int v78 = ++v243;
              ++v77;
              v74 -= 8;
            }
            while (v74);
            goto LABEL_105;
          }
        }
      }
      int v43 = 0;
      goto LABEL_116;
    }
    unint64_t v32 = *(void *)(v15 - 96);
    unsigned int v33 = *(unsigned __int8 *)(v32 + 16);
    if (v33 != 21)
    {
      if (v33 < 0x1C)
      {
        if (!*(unsigned char *)(v32 + 16)) {
          v32 |= 2uLL;
        }
      }
      else
      {
        unsigned int v34 = v33 - 33;
        BOOL v21 = v34 > 0x33;
        uint64_t v35 = (1 << v34) & 0x8000000000041;
        if (!v21 && v35 != 0) {
          v32 |= 1uLL;
        }
      }
    }
    uint64_t v236 = v32;
    v237.i64[0] = 0;
    AssumedConstant = llvm::Attributor::getAssumedConstant(v2, (const llvm::IRPosition *)&v236, (const llvm::AbstractAttribute *)v3, &v203);
    if (v67)
    {
      if (!AssumedConstant) {
        goto LABEL_92;
      }
      int v71 = *((unsigned __int8 *)AssumedConstant + 16);
      if ((v71 - 11) >= 2)
      {
        if (v71 == 16)
        {
          uint64_t v72 = *((unsigned int *)AssumedConstant + 8);
          if (v72 > 0x40)
          {
            int v95 = 0;
            int64_t v96 = (unint64_t)(v72 + 63) >> 6;
            do
            {
              BOOL v21 = v96-- < 1;
              if (v21) {
                break;
              }
              unint64_t v97 = *(void *)(*((void *)AssumedConstant + 3) + 8 * v96);
              v95 += __clz(v97);
            }
            while (!v97);
            int v98 = v72 | 0xFFFFFFC0;
            if ((v72 & 0x3F) == 0) {
              int v98 = 0;
            }
            if (v95 + v98 == v72) {
              goto LABEL_163;
            }
LABEL_101:
            uint64_t v70 = *(void *)(v15 - 64);
          }
          else
          {
            if (*((void *)AssumedConstant + 3)) {
              goto LABEL_101;
            }
LABEL_163:
            uint64_t v70 = *(void *)(v15 - 32);
          }
          if (v243 >= (unint64_t)v244) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unint64_t v18 = &v242[16 * v243];
        }
        else
        {
LABEL_92:
          if (v243 >= (unint64_t)v244) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v68 = &v242[16 * v243];
          *(void *)uint64_t v68 = *(void *)(v15 - 64);
          *((void *)v68 + 1) = v14;
          unsigned int v69 = v243 + 1;
          unsigned int v243 = v69;
          uint64_t v70 = *(void *)(v15 - 32);
          if (v69 >= v244) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unint64_t v18 = &v242[16 * v69];
        }
        *(void *)unint64_t v18 = v70;
LABEL_96:
        *((void *)v18 + 1) = v14;
        ++v243;
      }
    }
LABEL_274:
    unsigned int v12 = v243;
  }
  while (v243);
  if (v251)
  {
    uint64_t v190 = 24 * v251;
    v191 = v250 + 16;
    do
    {
      if (*v191) {
        llvm::Attributor::recordDependence((uint64_t)v2, *((void *)v191 - 1), v3, 1);
      }
      v191 += 24;
      v190 -= 24;
    }
    while (v190);
  }
  int v187 = 1;
LABEL_437:
  if (v242 != (char *)v245) {
    free(v242);
  }
  sub_1CD40B1BC(v248[0]);
  if (v246[0] != v247) {
    free(v246[0]);
  }
  if (v250 != (char *)v252) {
    free(v250);
  }
  if ((v249[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v249[1], 8);
  }
  if (v187)
  {
    uint64_t v192 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3);
    if (sub_1CD65AF44(v192, (uint64_t)&v204))
    {
      uint64_t v188 = 1;
    }
    else
    {
      int v193 = *(_DWORD *)(v3 + 112);
      *(_DWORD *)(v3 + 112) = v193 + 1;
      if (v193 >= 5) {
        goto LABEL_446;
      }
      uint64_t v188 = 0;
    }
  }
  else
  {
LABEL_446:
    uint64_t v188 = (*(uint64_t (**)(uint64_t))(*(void *)v195 + 40))(v195);
  }
  v204 = (uint64_t (**)(void **))&unk_1F26245C0;
  if (v213 >= 0x41 && v212) {
    MEMORY[0x1D25D9CB0](v212, 0x1000C8000313F17);
  }
  if (v211 >= 0x41 && v210) {
    MEMORY[0x1D25D9CB0](v210, 0x1000C8000313F17);
  }
  if (v209 >= 0x41 && v208) {
    MEMORY[0x1D25D9CB0](v208, 0x1000C8000313F17);
  }
  if (v207 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  return v188;
}

uint64_t sub_1CC8DC1B8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = sub_1CC8DD2C0(a1, a2, a3);
  if (result)
  {
    sub_1CC8DD00C((unint64_t *)&v22, a1, a2);
    sub_1CC8DCCC0((unint64_t *)&v18, a1, a2);
    unsigned int v11 = *(_DWORD *)(a1 + 56);
    if (v11 > 0x40) {
      operator new[]();
    }
    uint64_t v10 = *(void *)(a1 + 48);
    unsigned int v13 = *(_DWORD *)(a1 + 72);
    if (v13 > 0x40) {
      operator new[]();
    }
    uint64_t v12 = *(void *)(a1 + 64);
    llvm::ConstantRange::intersectWith((uint64_t)&v10, (llvm::ConstantRange *)&v18, 0, (uint64_t)&v14);
    uint64_t result = llvm::ConstantRange::intersectWith((uint64_t)&v14, (llvm::ConstantRange *)&v22, 0, a4);
    if (v17 >= 0x41)
    {
      uint64_t result = v16;
      if (v16) {
        uint64_t result = MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
      }
    }
    if (v15 >= 0x41)
    {
      uint64_t result = v14;
      if (v14) {
        uint64_t result = MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
      }
    }
    if (v13 >= 0x41)
    {
      uint64_t result = v12;
      if (v12) {
        uint64_t result = MEMORY[0x1D25D9CB0](v12, 0x1000C8000313F17);
      }
    }
    if (v11 >= 0x41)
    {
      uint64_t result = v10;
      if (v10) {
        uint64_t result = MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
      }
    }
    if (v21 >= 0x41)
    {
      uint64_t result = v20;
      if (v20) {
        uint64_t result = MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
      }
    }
    if (v19 >= 0x41)
    {
      uint64_t result = v18;
      if (v18) {
        uint64_t result = MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
      }
    }
    if (v25 >= 0x41)
    {
      uint64_t result = v24;
      if (v24) {
        uint64_t result = MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
      }
    }
    if (v23 >= 0x41)
    {
      uint64_t result = v22;
      if (v22) {
        return MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
      }
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a4 + 8) = v8;
    if (v8 > 0x40) {
      operator new[]();
    }
    *(void *)a4 = *(void *)(a1 + 48);
    unsigned int v9 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a4 + 24) = v9;
    if (v9 > 0x40) {
      operator new[]();
    }
    *(void *)(a4 + 16) = *(void *)(a1 + 64);
  }
  return result;
}

uint64_t sub_1CC8DC508@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t result = sub_1CC8DD2C0(a1, a2, a3);
  if (result)
  {
    sub_1CC8DD00C((unint64_t *)&v22, a1, a2);
    sub_1CC8DCCC0((unint64_t *)&v18, a1, a2);
    unsigned int v11 = *(_DWORD *)(a1 + 88);
    if (v11 > 0x40) {
      operator new[]();
    }
    uint64_t v10 = *(void *)(a1 + 80);
    unsigned int v13 = *(_DWORD *)(a1 + 104);
    if (v13 > 0x40) {
      operator new[]();
    }
    uint64_t v12 = *(void *)(a1 + 96);
    llvm::ConstantRange::intersectWith((uint64_t)&v10, (llvm::ConstantRange *)&v18, 0, (uint64_t)&v14);
    uint64_t result = llvm::ConstantRange::intersectWith((uint64_t)&v14, (llvm::ConstantRange *)&v22, 0, a4);
    if (v17 >= 0x41)
    {
      uint64_t result = v16;
      if (v16) {
        uint64_t result = MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
      }
    }
    if (v15 >= 0x41)
    {
      uint64_t result = v14;
      if (v14) {
        uint64_t result = MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
      }
    }
    if (v13 >= 0x41)
    {
      uint64_t result = v12;
      if (v12) {
        uint64_t result = MEMORY[0x1D25D9CB0](v12, 0x1000C8000313F17);
      }
    }
    if (v11 >= 0x41)
    {
      uint64_t result = v10;
      if (v10) {
        uint64_t result = MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
      }
    }
    if (v21 >= 0x41)
    {
      uint64_t result = v20;
      if (v20) {
        uint64_t result = MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
      }
    }
    if (v19 >= 0x41)
    {
      uint64_t result = v18;
      if (v18) {
        uint64_t result = MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
      }
    }
    if (v25 >= 0x41)
    {
      uint64_t result = v24;
      if (v24) {
        uint64_t result = MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
      }
    }
    if (v23 >= 0x41)
    {
      uint64_t result = v22;
      if (v22) {
        return MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
      }
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(a1 + 88);
    *(_DWORD *)(a4 + 8) = v8;
    if (v8 > 0x40) {
      operator new[]();
    }
    *(void *)a4 = *(void *)(a1 + 80);
    unsigned int v9 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a4 + 24) = v9;
    if (v9 > 0x40) {
      operator new[]();
    }
    *(void *)(a4 + 16) = *(void *)(a1 + 96);
  }
  return result;
}

uint64_t *sub_1CC8DC858(uint64_t a1)
{
  *(void *)a1 = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8DC978(uint64_t a1)
{
}

unint64_t *sub_1CC8DC980(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (_DWORD *)(a1 + 16);
  uint64_t v7 = 0;
  uint64_t v5 = a1 + 32;
  if (sub_1CD650C48(a2, (uint64_t *)(a1 + 16), &v7)) {
    return (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 40))(a1 + 32);
  }
  sub_1CC8AB830(v4);
  sub_1CC8DCCC0((unint64_t *)&v7, a1, (uint64_t)a2);
  sub_1CD65AE50(a1 + 32, (llvm::ConstantRange *)&v7);
  if (v10 >= 0x41 && v9) {
    MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
  }
  if (v8 >= 0x41 && v7) {
    MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
  }
  sub_1CC8AB830(v4);
  sub_1CC8DD00C((unint64_t *)&v7, a1, (uint64_t)a2);
  uint64_t result = (unint64_t *)sub_1CD65AE50(a1 + 32, (llvm::ConstantRange *)&v7);
  if (v10 >= 0x41)
  {
    uint64_t result = v9;
    if (v9) {
      uint64_t result = (unint64_t *)MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
    }
  }
  if (v8 >= 0x41)
  {
    uint64_t result = v7;
    if (v7) {
      return (unint64_t *)MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
    }
  }
  return result;
}

uint64_t sub_1CC8DCAFC(uint64_t a1, _OWORD *a2, unsigned int a3)
{
  *(_OWORD *)(a1 + 16) = *a2;
  *(void *)a1 = &unk_1F2620A20;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = &unk_1F26245C0;
  *(_DWORD *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 56) = a3;
  if (a3 >= 0x41) {
    operator new[]();
  }
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 72) = a3;
  *(void *)(a1 + 64) = 0;
  llvm::ConstantRange::ConstantRange((unint64_t *)(a1 + 80), a3, 1);
  *(void *)a1 = &unk_1F2624500;
  *(void *)(a1 + 32) = &unk_1F2624580;
  return a1;
}

uint64_t sub_1CC8DCCA8(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CC8DCCB0(uint64_t a1)
{
  return a1 + 32;
}

unint64_t *sub_1CC8DCCC0(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (_DWORD *)(a2 + 16);
  if (sub_1CD6482A0((_DWORD *)(a2 + 16)))
  {
    uint64_t v9 = *(void *)(a3 + 88);
    uint64_t v10 = *(void *)(sub_1CD6482A0(v6) + 40);
    if (**(void **)(v9 + 440)) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    if (sub_1CD6482A0(v6))
    {
      uint64_t v12 = *(void *)(a3 + 88);
      uint64_t v13 = *(void *)(sub_1CD6482A0(v6) + 40);
      if (**(void **)(v12 + 440)) {
        BOOL v14 = v13 == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (!v14) {
        llvm::AnalysisManager<llvm::Function>::getResultImpl();
      }
      uint64_t v15 = *(void *)(a3 + 88);
      uint64_t v16 = *(void *)(sub_1CD6482A0(v6) + 40);
      if (**(void **)(v15 + 440)) {
        BOOL v17 = v16 == 0;
      }
      else {
        BOOL v17 = 1;
      }
      if (!v17) {
        llvm::AnalysisManager<llvm::Function>::getResultImpl();
      }
    }
  }
  unsigned int v7 = *(_DWORD *)(a2 + 40);

  return llvm::ConstantRange::ConstantRange(a1, v7, 1);
}

unint64_t *sub_1CC8DD00C(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (_DWORD *)(a2 + 16);
  if (sub_1CD6482A0((_DWORD *)(a2 + 16)))
  {
    uint64_t v9 = *(void *)(a3 + 88);
    uint64_t v10 = *(void *)(sub_1CD6482A0(v6) + 40);
    if (**(void **)(v9 + 440) && v10 != 0) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
  }
  unsigned int v7 = *(_DWORD *)(a2 + 40);

  return llvm::ConstantRange::ConstantRange(a1, v7, 1);
}

BOOL sub_1CC8DD0F0(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 > 0x40)
  {
    unsigned int v7 = a2;
    uint64_t v8 = a1;
    int v6 = memcmp(*(const void **)a1, *a2, ((unint64_t)(v2 + 63) >> 3) & 0x3FFFFFF8);
    a2 = v7;
    a1 = v8;
    if (!v6) {
      goto LABEL_3;
    }
    return 0;
  }
  if (*(const void **)a1 != *a2) {
    return 0;
  }
LABEL_3:
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  if (v3 > 0x40) {
    return memcmp(*(const void **)(a1 + 16), a2[2], ((unint64_t)(v3 + 63) >> 3) & 0x3FFFFFF8) == 0;
  }
  else {
    return *(void *)(a1 + 16) == (void)a2[2];
  }
}

uint64_t sub_1CC8DD19C(void *a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  BOOL v14 = &v16;
  uint64_t v15 = 0;
  if (!*((_DWORD *)a2 + 4))
  {
    unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
    goto LABEL_3;
  }
  sub_1CD41B598((uint64_t)&v14, (uint64_t)(a2 + 1));
  unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
  if (!v15)
  {
LABEL_3:
    uint64_t v4 = v13;
    unsigned int v5 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
    if (v5 < 0x15 || v5 == 24) {
      goto LABEL_9;
    }
  }
  unsigned int v3 = *((_DWORD *)v14 + v3 + 1);
  if ((v3 & 0x80000000) != 0)
  {
LABEL_12:
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = v13;
LABEL_9:
  uint64_t v7 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v3);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = a1[1];
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 >= *(_DWORD *)(v8 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v10 = (void *)(*(void *)v8 + 16 * v9);
  *uint64_t v10 = v7;
  v10[1] = v4;
  ++*(_DWORD *)(v8 + 8);
  uint64_t v11 = 1;
LABEL_13:
  if (v14 != &v16) {
    free(v14);
  }
  return v11;
}

uint64_t sub_1CC8DD2C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  unsigned int v5 = (llvm::IRPosition *)(a1 + 16);
  if (sub_1CC8AB830((_DWORD *)(a1 + 16)) == a3) {
    return 0;
  }
  unint64_t v7 = sub_1CD6482F0(v5);
  unsigned int v8 = *(unsigned __int8 *)(v7 + 16);
  if (v8 >= 0x15)
  {
    if (v8 >= 0x1C)
    {
      unsigned int v9 = (void *)(*(void *)(v7 + 40) + 56);
    }
    else
    {
      if (v8 != 21) {
        return 0;
      }
      unsigned int v9 = (void *)(v7 + 24);
    }
    if (*v9 == *(void *)(*(void *)(a3 + 40) + 56)) {
      goto LABEL_10;
    }
    return 0;
  }
LABEL_10:
  unint64_t v10 = sub_1CD6482F0(v5);
  if (*(unsigned __int8 *)(v10 + 16) >= 0x1Cu)
  {
    if (**(void **)(*(void *)(a2 + 88) + 440)) {
      BOOL v11 = *(void *)(*(void *)(*(void *)(v10 + 40) + 56) + 40) == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
    return 0;
  }
  return 1;
}

uint64_t sub_1CC8DD3CC(uint64_t result, const void **a2)
{
  if (*(_DWORD *)(result + 8) > 0x40u || *((_DWORD *)a2 + 2) > 0x40u)
  {
    if ((const void **)result != a2)
    {
      uint64_t v2 = a2;
      uint64_t v3 = result;
      llvm::APInt::reallocate(result, *((_DWORD *)a2 + 2));
      uint64_t result = v3;
      uint64_t v4 = *(unsigned int *)(v3 + 8);
      if (v4 <= 0x40)
      {
        a2 = v2;
        *(void *)uint64_t v3 = *v2;
      }
      else
      {
        memcpy(*(void **)v3, *v2, ((unint64_t)(v4 + 63) >> 3) & 0x3FFFFFF8);
        a2 = v2;
        uint64_t result = v3;
      }
    }
  }
  else
  {
    *(void *)uint64_t result = *a2;
    *(_DWORD *)(result + 8) = *((_DWORD *)a2 + 2);
  }
  if (*(_DWORD *)(result + 24) > 0x40u || *((_DWORD *)a2 + 6) > 0x40u)
  {
    if ((const void **)result != a2)
    {
      unsigned int v5 = a2;
      int v6 = (void **)(result + 16);
      uint64_t v7 = result;
      llvm::APInt::reallocate(result + 16, *((_DWORD *)a2 + 6));
      uint64_t v8 = *(unsigned int *)(v7 + 24);
      if (v8 <= 0x40) {
        *int v6 = (void *)v5[2];
      }
      else {
        memcpy(*v6, v5[2], ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
      }
      return v7;
    }
  }
  else
  {
    *(void *)(result + 16) = a2[2];
    *(_DWORD *)(result + 24) = *((_DWORD *)a2 + 6);
  }
  return result;
}

uint64_t sub_1CC8DD504(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 80);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8DD61C(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t *sub_1CC8DD754(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (_DWORD *)(a1 + 16);
  uint64_t result = (unint64_t *)sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (!result) {
    goto LABEL_2;
  }
  uint64_t result = (unint64_t *)sub_1CD6482A0(v4);
  if (result && *((unsigned char *)result + 16) == 3)
  {
    if ((*((_DWORD *)result + 5) & 0x7FFFFFF) == 0)
    {
LABEL_2:
      unsigned int v6 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 56) > 0x40u || v6 > 0x40)
      {
        uint64_t result = (unint64_t *)llvm::APInt::reallocate(a1 + 48, v6);
        uint64_t v8 = *(unsigned int *)(a1 + 56);
        if (v8 <= 0x40) {
          *(void *)(a1 + 48) = *(void *)(a1 + 80);
        }
        else {
          uint64_t result = (unint64_t *)memcpy(*(void **)(a1 + 48), *(const void **)(a1 + 80), ((unint64_t)(v8 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
      else
      {
        *(void *)(a1 + 48) = *(void *)(a1 + 80);
        *(_DWORD *)(a1 + 56) = v6;
      }
      unsigned int v7 = *(_DWORD *)(a1 + 104);
      if (*(_DWORD *)(a1 + 72) > 0x40u || v7 > 0x40)
      {
        uint64_t result = (unint64_t *)llvm::APInt::reallocate(a1 + 64, v7);
        uint64_t v9 = *(unsigned int *)(a1 + 72);
        if (v9 <= 0x40)
        {
          *(void *)(a1 + 64) = *(void *)(a1 + 96);
        }
        else
        {
          unint64_t v10 = *(void **)(a1 + 64);
          BOOL v11 = *(const void **)(a1 + 96);
          return (unint64_t *)memcpy(v10, v11, ((unint64_t)(v9 + 63) >> 3) & 0x3FFFFFF8);
        }
      }
      else
      {
        *(void *)(a1 + 64) = *(void *)(a1 + 96);
        *(_DWORD *)(a1 + 72) = v7;
      }
      return result;
    }
  }
  else if (!*((unsigned char *)result + 16) {
         && (unint64_t *)result[9] == result + 9
  }
         && (*((unsigned char *)result + 34) & 0x80) == 0)
  {
    goto LABEL_2;
  }

  return sub_1CC8DC980(a1, a2);
}

void sub_1CC8DD8D4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0F0))
  {
    __cxa_guard_release(&qword_1EA61C0F0);
  }
}

BOOL sub_1CC8DD928(void *a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)((*(uint64_t (**)(void *))(*a1 + 40))(a1) + 8);
  if (v4 >= 0x41) {
    operator new[]();
  }
  uint64_t v16 = (void (**)(void **))&unk_1F26245C0;
  unsigned int v17 = v4;
  unsigned int v19 = v4;
  unsigned int v21 = v4;
  uint64_t v18 = 0;
  uint64_t v20 = 0;
  uint64_t v5 = (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v4);
  if (!v4) {
    uint64_t v5 = 0;
  }
  __src = v5;
  unsigned int v23 = v4;
  unsigned int v25 = v4;
  uint64_t v24 = v5;
  unsigned int v6 = (llvm::IRPosition *)(a1 + 2);
  uint64_t v7 = a1[3];
  if (v7)
  {
    unsigned int v8 = sub_1CD64DE00(v6, 0);
    int v9 = *(_DWORD *)(v7 + 20);
    if ((v9 & 0x40000000) != 0) {
      uint64_t v10 = *(void *)(v7 - 8);
    }
    else {
      uint64_t v10 = v7 - 32 * (v9 & 0x7FFFFFF);
    }
    BOOL v11 = sub_1CC8C972C(a2, (v10 + 32 * v8) | 3, 0, (uint64_t)a1, 0);
    uint64_t v12 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v11 + 48))(v11);
    sub_1CD65AFF8((uint64_t)v38, (uint64_t)&v16, v12);
  }
  else
  {
    LOBYTE(v38[0]) = 0;
    char v47 = 0;
    int v37 = 0;
    int v37 = sub_1CD64DE00(v6, 0);
    v36[0] = &v37;
    v36[1] = a2;
    v36[2] = a1;
    v36[3] = v38;
    if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8DE138, (uint64_t)v36, (uint64_t)a1, 1, &v35))
    {
      if (!v47) {
        goto LABEL_24;
      }
      sub_1CD65AFF8((uint64_t)&v26, (uint64_t)&v16, (uint64_t)v38);
      uint64_t v26 = &unk_1F26245C0;
      if (v34 >= 0x41 && v33) {
        MEMORY[0x1D25D9CB0](v33, 0x1000C8000313F17);
      }
      if (v32 >= 0x41 && v31) {
        MEMORY[0x1D25D9CB0](v31, 0x1000C8000313F17);
      }
      if (v30 >= 0x41 && v29) {
        MEMORY[0x1D25D9CB0](v29, 0x1000C8000313F17);
      }
      if (v28 >= 0x41 && v27) {
        MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
      }
    }
    else
    {
      v16[5]((void **)&v16);
    }
    if (!v47) {
      goto LABEL_24;
    }
  }
  v38[0] = &unk_1F26245C0;
  if (v46 >= 0x41 && v45) {
    MEMORY[0x1D25D9CB0](v45, 0x1000C8000313F17);
  }
  if (v44 >= 0x41 && v43) {
    MEMORY[0x1D25D9CB0](v43, 0x1000C8000313F17);
  }
  if (v42 >= 0x41 && v41) {
    MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
  }
  if (v40 >= 0x41 && v39) {
    MEMORY[0x1D25D9CB0](v39, 0x1000C8000313F17);
  }
LABEL_24:
  uint64_t v13 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
  BOOL v14 = sub_1CD65AF44(v13, (uint64_t)&v16);
  uint64_t v16 = (void (**)(void **))&unk_1F26245C0;
  if (v25 >= 0x41 && v24) {
    MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
  }
  if (v23 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  if (v21 >= 0x41 && v20) {
    MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
  }
  if (v19 >= 0x41 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  return v14;
}

uint64_t *sub_1CC8DE010(uint64_t a1)
{
  *(void *)a1 = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8DE130(uint64_t a1)
{
}

uint64_t sub_1CC8DE138(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  BOOL v11 = v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v22 = v10;
    unsigned int v23 = &v25;
    uint64_t v24 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v23, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v22 = v3;
    unsigned int v23 = &v25;
    uint64_t v24 = 0;
  }
  uint64_t v25 = sub_1CD659800((uint64_t)&v22, **(_DWORD **)a1);
  uint64_t v26 = v4;
  if (v23 != &v25) {
    free(v23);
  }
  if (sub_1CD647DEC(&v25))
  {
    uint64_t v7 = sub_1CC8C972C(*(void *)(a1 + 8), v25, v26, *(void *)(a1 + 16), 0);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    uint64_t v9 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v9 + 80))
    {
      sub_1CD65B080((uint64_t)v13, v9, v8);
      v13[0] = &unk_1F26245C0;
      if (v21 >= 0x41 && v20) {
        MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
      }
      if (v19 >= 0x41 && v18) {
        MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
      }
      if (v17 >= 0x41 && v16) {
        MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
      }
      if (v15 >= 0x41 && v14) {
        MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
      }
    }
    else
    {
      sub_1CD65B1B0(*(void *)(a1 + 24), v8);
    }
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (v11 != v13) {
    free(v11);
  }
  return v5;
}

uint64_t sub_1CC8DE374(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 80);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8DE48C(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8DE5C8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C0F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C0F8))
  {
    __cxa_guard_release(&qword_1EA61C0F8);
  }
}

BOOL sub_1CC8DE61C(void *a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)((*(uint64_t (**)(void *))(*a1 + 40))(a1) + 8);
  if (v4 >= 0x41) {
    operator new[]();
  }
  uint64_t v9 = (void (**)(void **))&unk_1F26245C0;
  unsigned int v10 = v4;
  unsigned int v12 = v4;
  unsigned int v14 = v4;
  uint64_t v11 = 0;
  uint64_t v13 = 0;
  uint64_t v5 = (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v4);
  if (!v4) {
    uint64_t v5 = 0;
  }
  __src = v5;
  unsigned int v16 = v4;
  unsigned int v18 = v4;
  unsigned int v17 = v5;
  uint64_t v39 = a1[3];
  LOBYTE(v29[0]) = 0;
  char v38 = 0;
  v28[0] = &v39;
  v28[1] = a2;
  uint64_t v28[2] = a1;
  void v28[3] = v29;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8DED7C, (uint64_t)v28, (uint64_t)a1))
  {
    if (!v38) {
      goto LABEL_18;
    }
    sub_1CD65AFF8((uint64_t)&v19, (uint64_t)&v9, (uint64_t)v29);
    unsigned int v19 = &unk_1F26245C0;
    if (v27 >= 0x41 && v26) {
      MEMORY[0x1D25D9CB0](v26, 0x1000C8000313F17);
    }
    if (v25 >= 0x41 && v24) {
      MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
    }
    if (v23 >= 0x41 && v22) {
      MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
    }
    if (v21 >= 0x41 && v20) {
      MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
    }
  }
  else
  {
    v9[5]((void **)&v9);
  }
  if (v38)
  {
    v29[0] = &unk_1F26245C0;
    if (v37 >= 0x41 && v36) {
      MEMORY[0x1D25D9CB0](v36, 0x1000C8000313F17);
    }
    if (v35 >= 0x41 && v34) {
      MEMORY[0x1D25D9CB0](v34, 0x1000C8000313F17);
    }
    if (v33 >= 0x41 && v32) {
      MEMORY[0x1D25D9CB0](v32, 0x1000C8000313F17);
    }
    if (v31 >= 0x41 && v30) {
      MEMORY[0x1D25D9CB0](v30, 0x1000C8000313F17);
    }
  }
LABEL_18:
  uint64_t v6 = (*(uint64_t (**)(void *))(*a1 + 40))(a1);
  BOOL v7 = sub_1CD65AF44(v6, (uint64_t)&v9);
  uint64_t v9 = (void (**)(void **))&unk_1F26245C0;
  if (v18 >= 0x41 && v17) {
    MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
  }
  if (v16 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
  if (v14 >= 0x41 && v13) {
    MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
  }
  if (v12 >= 0x41 && v11) {
    MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
  }
  return v7;
}

uint64_t *sub_1CC8DEC54(uint64_t a1)
{
  *(void *)a1 = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8DED74(uint64_t a1)
{
}

uint64_t sub_1CC8DED7C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 != 21)
  {
    if (v4 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v5 = v4 - 33;
      BOOL v6 = v5 > 0x33;
      uint64_t v7 = (1 << v5) & 0x8000000000041;
      if (!v6 && v7 != 0)
      {
        uint64_t v3 = 0;
        a2 |= 1uLL;
      }
    }
  }
  uint64_t v9 = sub_1CC8C972C(*(void *)(a1 + 8), a2, v3, *(void *)(a1 + 16), 0);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v11 + 80))
  {
    sub_1CD65B080((uint64_t)&v13, v11, v10);
    uint64_t v13 = &unk_1F26245C0;
    if (v21 >= 0x41 && v20) {
      MEMORY[0x1D25D9CB0](v20, 0x1000C8000313F17);
    }
    if (v19 >= 0x41 && v18) {
      MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
    }
    if (v17 >= 0x41 && v16) {
      MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
    }
    if (v15 >= 0x41 && v14) {
      MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
    }
  }
  else
  {
    sub_1CD65B1B0(*(void *)(a1 + 24), v10);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
}

uint64_t sub_1CC8DEF48(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 80);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8DF060(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t *sub_1CC8DF198(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (*(unsigned char *)(v4 + 16) != 84 || (*(unsigned char *)(v4 + 23) & 0x20) == 0) {
    return sub_1CC8DC980(a1, a2);
  }
  uint64_t v5 = ***(void ***)v4;
  unint64_t v22 = v4;
  int v6 = *(_DWORD *)(v5 + 2496);
  if (v6)
  {
    uint64_t v7 = *(void *)(v5 + 2480);
    int v8 = v6 - 1;
    unsigned int v9 = (v6 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    uint64_t v10 = (void *)(v7 + 40 * v9);
    uint64_t v11 = *v10;
    if (*v10 == v4) {
      goto LABEL_13;
    }
    unsigned int v12 = 0;
    int v13 = 1;
    while (v11 != -4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == -8192;
      }
      if (v14) {
        unsigned int v12 = v10;
      }
      unsigned int v15 = v9 + v13++;
      unsigned int v9 = v15 & v8;
      uint64_t v10 = (void *)(v7 + 40 * (v15 & v8));
      uint64_t v11 = *v10;
      if (*v10 == v4) {
        goto LABEL_13;
      }
    }
    if (v12) {
      uint64_t v20 = v12;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v10 = sub_1CC609054(v5 + 2480, (uint64_t)&v22, (uint64_t *)&v22, v20);
  uint64_t v21 = v22;
  v10[3] = 0;
  void v10[4] = 0;
  *uint64_t v10 = v21;
  v10[1] = v10 + 3;
  void v10[2] = 0x100000000;
LABEL_13:
  uint64_t v16 = *((unsigned int *)v10 + 4);
  if (v16)
  {
    unsigned int v17 = (uint64_t *)(v10[1] + 8);
    uint64_t v18 = 16 * v16;
    while (*((_DWORD *)v17 - 2) != 4)
    {
      v17 += 2;
      v18 -= 16;
      if (!v18) {
        return sub_1CC8DC980(a1, a2);
      }
    }
    if (*v17)
    {
      llvm::getConstantRangeFromMetadata(*v17, (uint64_t)&v22);
      sub_1CD65AE50(a1 + 32, (llvm::ConstantRange *)&v22);
      if (v25 >= 0x41 && v24) {
        MEMORY[0x1D25D9CB0](v24, 0x1000C8000313F17);
      }
      if (v23 >= 0x41 && v22) {
        MEMORY[0x1D25D9CB0](v22, 0x1000C8000313F17);
      }
    }
  }
  return sub_1CC8DC980(a1, a2);
}

void sub_1CC8DF360()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C100, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C100))
  {
    __cxa_guard_release(&qword_1EA61C100);
  }
}

uint64_t sub_1CC8DF3B4(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD648A0C(v4);
  if (v6)
  {
    unint64_t v9 = *(void *)v4 & 0xFFFFFFFFFFFFFFFCLL;
    if ((~*(_DWORD *)v4 & 3) == 0) {
      unint64_t v9 = *(void *)(v9 + 24);
    }
    uint64_t v10 = sub_1CC8C972C(a2, v6 | 1, v9, a1, 0);
    uint64_t v11 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 48))(v10);
    return sub_1CD65AF44(v5, v11);
  }
  else
  {
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)v5 + 40);
    return v7(v5);
  }
}

uint64_t *sub_1CC8DF4C4(uint64_t a1)
{
  *(void *)a1 = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8DF5E4(uint64_t a1)
{
}

uint64_t sub_1CC8DF5EC(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 80);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8DF704(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 104) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 96);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 64);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8DF83C()
{
  return 1;
}

void sub_1CC8DF844()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C108, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C108))
  {
    __cxa_guard_release(&qword_1EA61C108);
  }
}

uint64_t *sub_1CC8DF898(uint64_t a1)
{
  *(void *)a1 = &unk_1F26245C0;
  if (*(_DWORD *)(a1 + 72) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1D25D9CB0](v6, 0x1000C8000313F17);
    }
  }
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8DF9B8(uint64_t a1)
{
}

uint64_t sub_1CC8DF9C0(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8DFA3C(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8DFAD8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v12 = 0;
  if (sub_1CD650C48(a2, (uint64_t *)(a1 + 16), &v12)) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 40))();
  }
  uint64_t v4 = (uint64_t *)(a1 + 32);
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 24))(a1 + 32);
  if ((result & 1) == 0)
  {
    unint64_t result = sub_1CD6482F0(v3);
    unsigned int v6 = *(unsigned __int8 *)(result + 16);
    if (v6 == 16)
    {
      sub_1CD65B468(a1 + 32, (llvm *)(result + 24));
      uint64_t v7 = *v4;
    }
    else
    {
      if (v6 - 11 > 1)
      {
        BOOL v9 = v6 > 0x1B && v6 - 41 < 0x12;
        if (v6 != 81 && !v9 && (v6 - 66 >= 0xD || v6 <= 0x1B))
        {
          unsigned int v11 = v6 - 60;
          if (v11 > 0x19 || ((1 << v11) & 0x2800001) == 0) {
            return (*(uint64_t (**)(uint64_t))(*v4 + 40))(a1 + 32);
          }
        }
        return result;
      }
      *(unsigned char *)(a1 + 336) = *(_DWORD *)(a1 + 200) == 0;
      uint64_t v7 = *(void *)(a1 + 32);
    }
    return (*(uint64_t (**)(uint64_t))(v7 + 32))(a1 + 32);
  }
  return result;
}

void sub_1CC8DFC68(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  int v6 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  int v13 = v14;
  int v12 = 0;
  uint64_t v5 = &unk_1F2646F30;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
  llvm::operator<<((llvm::raw_ostream *)&v5, v3);
  if (*((char *)v13 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v13, (unint64_t)v13[1]);
  }
  else
  {
    long long v4 = *(_OWORD *)v13;
    *(void *)(a2 + 16) = v13[2];
    *(_OWORD *)a2 = v4;
  }
  uint64_t v5 = &unk_1F2646B98;
  if (v12 == 1 && v7) {
    MEMORY[0x1D25D9CB0](v7, 0x1000C8077774924);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

void sub_1CC8DFD90()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C110, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C110))
  {
    __cxa_guard_release(&qword_1EA61C110);
  }
}

uint64_t sub_1CC8DFDE4(uint64_t a1, llvm::Attributor *a2)
{
  uint64_t v193 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  unsigned int v5 = *(unsigned __int8 *)(v4 + 16);
  if (v5 >= 0x1C) {
    unint64_t v6 = v4;
  }
  else {
    unint64_t v6 = 0;
  }
  int v7 = *(unsigned __int8 *)(v6 + 16);
  if (v5 >= 0x1C && v7 == 81)
  {
    int v187 = &unk_1F2624AC0;
    __int16 v189 = *(_WORD *)(a1 + 48);
    uint64_t v188 = &unk_1F2620BB0;
    sub_1CD65BC98(v190, (_DWORD *)(a1 + 56));
    char v192 = *(unsigned char *)(a1 + 336);
    uint64_t v15 = *(void *)(v6 - 64);
    uint64_t v16 = *(void *)(v6 - 32);
    BOOL v184 = 0;
    uint64_t v17 = *(void *)(a1 + 24);
    unsigned int v18 = *(unsigned __int8 *)(v15 + 16);
    if (v18 != 21)
    {
      if (v18 < 0x1C)
      {
        if (!*(unsigned char *)(v15 + 16)) {
          v15 |= 2uLL;
        }
      }
      else
      {
        unsigned int v19 = v18 - 33;
        BOOL v20 = v19 > 0x33;
        uint64_t v21 = (1 << v19) & 0x8000000000041;
        if (!v20 && v21 != 0)
        {
          uint64_t v17 = 0;
          v15 |= 1uLL;
        }
      }
    }
    unint64_t v185 = (unint64_t *)v15;
    uint64_t v186 = v17;
    unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, &v184);
    if (!v64) {
      goto LABEL_160;
    }
    int64_t v65 = AssumedSimplified;
    uint64_t v30 = a1 + 32;
    if (AssumedSimplified)
    {
      uint64_t v66 = *(void *)(a1 + 24);
      unsigned int v67 = *(unsigned __int8 *)(v16 + 16);
      if (v67 != 21)
      {
        if (v67 < 0x1C)
        {
          if (!*(unsigned char *)(v16 + 16)) {
            v16 |= 2uLL;
          }
        }
        else
        {
          unsigned int v68 = v67 - 33;
          BOOL v20 = v68 > 0x33;
          uint64_t v69 = (1 << v68) & 0x8000000000041;
          if (!v20 && v69 != 0)
          {
            uint64_t v66 = 0;
            v16 |= 1uLL;
          }
        }
      }
      unint64_t v185 = (unint64_t *)v16;
      uint64_t v186 = v66;
      unint64_t v93 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, &v184);
      if (!v94) {
        goto LABEL_160;
      }
      unint64_t v95 = v93;
      if (v93 && *(unsigned char *)(*(void *)v65 + 8) == 13 && *(unsigned char *)(*(void *)v93 + 8) == 13)
      {
        unsigned int v96 = *(unsigned __int8 *)(v65 + 16);
        if (v96 != 21)
        {
          if (v96 < 0x1C)
          {
            if (!*(unsigned char *)(v65 + 16)) {
              v65 |= 2uLL;
            }
          }
          else
          {
            unsigned int v97 = v96 - 33;
            if (v97 <= 0x33 && ((1 << v97) & 0x8000000000041) != 0) {
              v65 |= 1uLL;
            }
          }
        }
        unsigned int v124 = sub_1CC8E1740((uint64_t)a2, v65, 0, a1, 0);
        if ((*(uint64_t (**)(void))(*((void *)v124 + 4) + 16))())
        {
          unsigned int v125 = *(unsigned __int8 *)(v95 + 16);
          uint64_t v126 = v95;
          if (v125 != 21)
          {
            if (v125 < 0x1C)
            {
              if (*(unsigned char *)(v95 + 16)) {
                uint64_t v126 = v95;
              }
              else {
                uint64_t v126 = v95 | 2;
              }
            }
            else
            {
              unsigned int v127 = v125 - 33;
              uint64_t v126 = v95;
              if (v127 <= 0x33)
              {
                uint64_t v126 = v95;
                if (((1 << v127) & 0x8000000000041) != 0) {
                  uint64_t v126 = v95 | 1;
                }
              }
            }
          }
          uint64_t v136 = sub_1CC8E1740((uint64_t)a2, v126, 0, a1, 0);
          if ((*(uint64_t (**)(void))(*((void *)v136 + 4) + 16))())
          {
            unsigned int v137 = *(_DWORD *)(*(void *)v95 + 8);
            LODWORD(v186) = v137 >> 8;
            if (v137 >> 8 > 0x40) {
              operator new[]();
            }
            unint64_t v185 = 0;
            if (*((unsigned char *)v124 + 336) && *((unsigned char *)v136 + 336))
            {
              *(unsigned char *)(a1 + 336) = *(_DWORD *)(a1 + 200) == 0;
            }
            else if (*((unsigned char *)v124 + 336))
            {
              uint64_t v163 = *((unsigned int *)v136 + 50);
              if (v163)
              {
                char v164 = 0;
                char v165 = 0;
                uint64_t v166 = *((void *)v136 + 24);
                int v167 = *(_WORD *)(v6 + 18) & 0x3F;
                uint64_t v168 = 16 * v163;
                do
                {
                  char v169 = llvm::ICmpInst::compare((uint64_t)&v185, v166, v167);
                  v164 |= v169;
                  v165 |= v169 ^ 1;
                  if (v164) {
                    BOOL v170 = v165 == 0;
                  }
                  else {
                    BOOL v170 = 1;
                  }
                  if (!v170) {
                    goto LABEL_322;
                  }
                  v166 += 16;
                  v168 -= 16;
                }
                while (v168);
LABEL_313:
                char v142 = v165 & 1;
                if ((v164 & 1) == 0) {
                  goto LABEL_317;
                }
LABEL_314:
                unsigned int v183 = 1;
                *(void *)int v182 = 1;
                sub_1CD65B468(v30, (llvm *)v182);
                if (v183 >= 0x41 && *(void *)v182) {
                  MEMORY[0x1D25D9CB0](*(void *)v182, 0x1000C8000313F17);
                }
LABEL_317:
                if (v142)
                {
                  unsigned int v183 = 1;
                  *(void *)int v182 = 0;
                  sub_1CD65B468(v30, (llvm *)v182);
                  if (v183 >= 0x41)
                  {
                    if (*(void *)v182) {
                      MEMORY[0x1D25D9CB0](*(void *)v182, 0x1000C8000313F17);
                    }
                  }
                }
              }
            }
            else
            {
              uint64_t v139 = *((void *)v124 + 24);
              uint64_t v140 = *((unsigned int *)v124 + 50);
              if (*((unsigned char *)v136 + 336))
              {
                if (v140)
                {
                  char v164 = 0;
                  char v165 = 0;
                  int v171 = *(_WORD *)(v6 + 18) & 0x3F;
                  uint64_t v172 = 16 * v140;
                  while (1)
                  {
                    char v173 = llvm::ICmpInst::compare(v139, (uint64_t)&v185, v171);
                    v164 |= v173;
                    v165 |= v173 ^ 1;
                    if (v164 && v165 != 0) {
                      goto LABEL_322;
                    }
                    v139 += 16;
                    v172 -= 16;
                    if (!v172) {
                      goto LABEL_313;
                    }
                  }
                }
              }
              else if (v140)
              {
                char v141 = 0;
                char v142 = 0;
                uint64_t v179 = *((void *)v136 + 24);
                uint64_t v180 = v139 + 16 * v140;
                uint64_t v181 = *((unsigned int *)v136 + 50);
                while (!v181)
                {
LABEL_246:
                  v139 += 16;
                  if (v139 == v180)
                  {
                    if ((v141 & 1) == 0) {
                      goto LABEL_317;
                    }
                    goto LABEL_314;
                  }
                }
                int v143 = *(_WORD *)(v6 + 18) & 0x3F;
                uint64_t v145 = 16 * v181;
                uint64_t v144 = v179;
                while (1)
                {
                  char v146 = llvm::ICmpInst::compare(v139, v144, v143);
                  v141 |= v146;
                  v142 |= v146 ^ 1;
                  if (v141 & 1) != 0 && (v142) {
                    goto LABEL_322;
                  }
                  v144 += 16;
                  v145 -= 16;
                  if (!v145) {
                    goto LABEL_246;
                  }
                }
              }
            }
            goto LABEL_236;
          }
        }
      }
    }
    goto LABEL_286;
  }
  if (v7 == 85) {
    unint64_t v8 = v6;
  }
  else {
    unint64_t v8 = 0;
  }
  if (v5 >= 0x1C && v7 == 85)
  {
    int v187 = &unk_1F2624AC0;
    __int16 v189 = *(_WORD *)(a1 + 48);
    uint64_t v188 = &unk_1F2620BB0;
    sub_1CD65BC98(v190, (_DWORD *)(a1 + 56));
    char v192 = *(unsigned char *)(a1 + 336);
    uint64_t v23 = *(void *)(v8 - 64);
    uint64_t v24 = *(void *)(v8 - 32);
    v182[0] = 0;
    uint64_t v25 = *(void *)(a1 + 24);
    unsigned int v26 = *(unsigned __int8 *)(v23 + 16);
    if (v26 != 21)
    {
      if (v26 < 0x1C)
      {
        if (!*(unsigned char *)(v23 + 16)) {
          v23 |= 2uLL;
        }
      }
      else
      {
        unsigned int v27 = v26 - 33;
        BOOL v20 = v27 > 0x33;
        uint64_t v28 = (1 << v27) & 0x8000000000041;
        if (!v20 && v28 != 0)
        {
          uint64_t v25 = 0;
          v23 |= 1uLL;
        }
      }
    }
    unint64_t v185 = (unint64_t *)v23;
    uint64_t v186 = v25;
    unint64_t v71 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
    if (!v72) {
      goto LABEL_160;
    }
    int64_t v73 = v71;
    uint64_t v30 = a1 + 32;
    if (!v71) {
      goto LABEL_286;
    }
    uint64_t v74 = *(void *)(a1 + 24);
    unsigned int v75 = *(unsigned __int8 *)(v24 + 16);
    if (v75 != 21)
    {
      if (v75 < 0x1C)
      {
        if (!*(unsigned char *)(v24 + 16)) {
          v24 |= 2uLL;
        }
      }
      else
      {
        unsigned int v76 = v75 - 33;
        BOOL v20 = v76 > 0x33;
        uint64_t v77 = (1 << v76) & 0x8000000000041;
        if (!v20 && v77 != 0)
        {
          uint64_t v74 = 0;
          v24 |= 1uLL;
        }
      }
    }
    unint64_t v185 = (unint64_t *)v24;
    uint64_t v186 = v74;
    unint64_t v98 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
    if (!v99) {
      goto LABEL_160;
    }
    uint64_t v100 = v98;
    if (!v98 || *(unsigned char *)(*(void *)v73 + 8) != 13 || *(unsigned char *)(*(void *)v98 + 8) != 13) {
      goto LABEL_286;
    }
    uint64_t v101 = *(void *)(v8 - 96);
    unsigned int v102 = *(unsigned __int8 *)(v101 + 16);
    if (v102 != 21)
    {
      if (v102 < 0x1C)
      {
        if (!*(unsigned char *)(v101 + 16)) {
          v101 |= 2uLL;
        }
      }
      else
      {
        unsigned int v103 = v102 - 33;
        BOOL v20 = v103 > 0x33;
        uint64_t v104 = (1 << v103) & 0x8000000000041;
        if (!v20 && v104 != 0) {
          v101 |= 1uLL;
        }
      }
    }
    unint64_t v185 = (unint64_t *)v101;
    uint64_t v186 = 0;
    AssumedConstant = llvm::Attributor::getAssumedConstant(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
    char v129 = 0;
    if (v130)
    {
      unsigned int v131 = AssumedConstant;
      if (AssumedConstant)
      {
        if (llvm::Constant::isOneValue(AssumedConstant))
        {
          char v129 = 1;
        }
        else
        {
          if (llvm::Constant::isZeroValue(v131))
          {
            unint64_t v132 = 0;
LABEL_259:
            unsigned int v150 = *(unsigned __int8 *)(v100 + 16);
            if (v150 != 21)
            {
              if (v150 < 0x1C)
              {
                if (!*(unsigned char *)(v100 + 16)) {
                  v100 |= 2uLL;
                }
              }
              else
              {
                unsigned int v151 = v150 - 33;
                if (v151 <= 0x33 && ((1 << v151) & 0x8000000000041) != 0) {
                  v100 |= 1uLL;
                }
              }
            }
            int v149 = sub_1CC8E1740((uint64_t)a2, v100, 0, a1, 0);
            if (((*(uint64_t (**)(uint64_t))(*((void *)v149 + 4) + 16))((uint64_t)v149 + 32) & 1) == 0) {
              goto LABEL_286;
            }
            if (v132)
            {
              if (*((unsigned char *)v132 + 336) && *((unsigned char *)v149 + 336)) {
                goto LABEL_292;
              }
              sub_1CD65C220(a1 + 32, (uint64_t)v132 + 32);
              uint64_t v161 = a1 + 32;
              uint64_t v160 = (uint64_t)v149 + 32;
              goto LABEL_304;
            }
LABEL_284:
            if (*((unsigned char *)v149 + 336)) {
              goto LABEL_292;
            }
            uint64_t v160 = (uint64_t)v149 + 32;
            uint64_t v161 = a1 + 32;
LABEL_304:
            sub_1CD65C220(v161, v160);
            goto LABEL_293;
          }
          char v129 = 0;
        }
      }
    }
    unsigned int v147 = *(unsigned __int8 *)(v73 + 16);
    if (v147 != 21)
    {
      if (v147 < 0x1C)
      {
        if (!*(unsigned char *)(v73 + 16)) {
          v73 |= 2uLL;
        }
      }
      else
      {
        unsigned int v148 = v147 - 33;
        if (v148 <= 0x33 && ((1 << v148) & 0x8000000000041) != 0) {
          v73 |= 1uLL;
        }
      }
    }
    unint64_t v132 = sub_1CC8E1740((uint64_t)a2, v73, 0, a1, 0);
    if (((*(uint64_t (**)(void))(*((void *)v132 + 4) + 16))() & 1) == 0) {
      goto LABEL_286;
    }
    int v149 = v132;
    if (v129) {
      goto LABEL_284;
    }
    goto LABEL_259;
  }
  if ((v7 - 79) >= 0xFFFFFFF3) {
    uint64_t v9 = (unsigned __int8 *)v6;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v5 >= 0x1C && (v7 - 79) >= 0xFFFFFFF3)
  {
    uint64_t v30 = a1 + 32;
    int v187 = &unk_1F2624AC0;
    __int16 v189 = *(_WORD *)(a1 + 48);
    uint64_t v188 = &unk_1F2620BB0;
    sub_1CD65BC98(v190, (_DWORD *)(a1 + 56));
    char v192 = *(unsigned char *)(a1 + 336);
    if (llvm::CastInst::isIntegerCast((llvm::CastInst *)v9))
    {
      unint64_t v31 = *(unsigned int *)(*(void *)v9 + 8);
      uint64_t v32 = *((void *)v9 - 4);
      v182[0] = 0;
      uint64_t v33 = *(void *)(a1 + 24);
      unsigned int v34 = *(unsigned __int8 *)(v32 + 16);
      if (v34 != 21)
      {
        if (v34 < 0x1C)
        {
          if (!*(unsigned char *)(v32 + 16)) {
            v32 |= 2uLL;
          }
        }
        else
        {
          unsigned int v35 = v34 - 33;
          BOOL v20 = v35 > 0x33;
          uint64_t v36 = (1 << v35) & 0x8000000000041;
          if (!v20 && v36 != 0)
          {
            uint64_t v33 = 0;
            v32 |= 1uLL;
          }
        }
      }
      unint64_t v185 = (unint64_t *)v32;
      uint64_t v186 = v33;
      unint64_t v88 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
      if (!v89) {
        goto LABEL_160;
      }
      uint64_t v90 = v88;
      if (v88)
      {
        unsigned int v91 = *(unsigned __int8 *)(v88 + 16);
        if (v91 != 21)
        {
          if (v91 < 0x1C)
          {
            if (!*(unsigned char *)(v88 + 16)) {
              uint64_t v90 = v88 | 2;
            }
          }
          else
          {
            unsigned int v92 = v91 - 33;
            if (v92 <= 0x33 && ((1 << v92) & 0x8000000000041) != 0) {
              uint64_t v90 = v88 | 1;
            }
          }
        }
        unsigned int v112 = sub_1CC8E1740((uint64_t)a2, v90, 0, a1, 0);
        if ((*(uint64_t (**)(void))(*((void *)v112 + 4) + 16))())
        {
          if (!*((unsigned char *)v112 + 336))
          {
            uint64_t v113 = *((unsigned int *)v112 + 50);
            if (v113)
            {
              unint64_t v114 = v31 >> 8;
              uint64_t v115 = *((void *)v112 + 24);
              uint64_t v116 = v115 + 16 * v113;
              unsigned int v117 = v31 >> 8;
              while (1)
              {
                unsigned int v118 = v9[16];
                if (v118 > 0x43) {
                  break;
                }
                if (v118 == 66)
                {
                  unsigned int v119 = *(_DWORD *)(v115 + 8);
                  if (v117 <= 0x40)
                  {
                    unint64_t v120 = (unint64_t *)v115;
                    if (v119 >= 0x41) {
                      unint64_t v120 = *(unint64_t **)v115;
                    }
                    unint64_t v121 = *v120;
LABEL_185:
                    LODWORD(v186) = v31 >> 8;
                    if (v31 <= 0xFF) {
                      unint64_t v122 = 0;
                    }
                    else {
                      unint64_t v122 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v31) + 63);
                    }
                    uint64_t v123 = (unint64_t *)(v122 & v121);
LABEL_191:
                    unint64_t v185 = v123;
                    goto LABEL_192;
                  }
                  if (v119 != v114) {
                    operator new[]();
                  }
                }
                else
                {
                  if (v117 <= 0x40)
                  {
                    unint64_t v121 = *(void *)v115;
                    goto LABEL_185;
                  }
                  if (*(_DWORD *)(v115 + 8) != v114) {
                    operator new[]();
                  }
                }
                sub_1CD0463BC((uint64_t)&v185, v115);
LABEL_192:
                sub_1CD65B468(v30, (llvm *)&v185);
                if (v186 >= 0x41 && v185) {
                  MEMORY[0x1D25D9CB0](v185, 0x1000C8000313F17);
                }
                v115 += 16;
                if (v115 == v116) {
                  goto LABEL_293;
                }
              }
              if (v118 == 68)
              {
                llvm::APInt::sext(v115, v31 >> 8, (uint64_t)&v185);
                goto LABEL_192;
              }
              LODWORD(v186) = *(_DWORD *)(v115 + 8);
              if (v186 > 0x40) {
                operator new[]();
              }
              uint64_t v123 = *(unint64_t **)v115;
              goto LABEL_191;
            }
LABEL_293:
            uint64_t v162 = sub_1CD65BB64((uint64_t)&v187, v30);
            goto LABEL_287;
          }
LABEL_292:
          *(unsigned char *)(a1 + 336) = *(_DWORD *)(a1 + 200) == 0;
          goto LABEL_293;
        }
      }
    }
LABEL_286:
    uint64_t v162 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 40))(v30);
LABEL_287:
    uint64_t v79 = v162;
    goto LABEL_288;
  }
  if ((v7 - 59) >= 0xFFFFFFEE) {
    unint64_t v11 = v6;
  }
  else {
    unint64_t v11 = 0;
  }
  if (v5 >= 0x1C && (v7 - 59) >= 0xFFFFFFEE)
  {
    int v187 = &unk_1F2624AC0;
    __int16 v189 = *(_WORD *)(a1 + 48);
    uint64_t v188 = &unk_1F2620BB0;
    sub_1CD65BC98(v190, (_DWORD *)(a1 + 56));
    char v192 = *(unsigned char *)(a1 + 336);
    uint64_t v38 = *(void *)(v11 - 64);
    uint64_t v39 = *(void *)(v11 - 32);
    v182[0] = 0;
    uint64_t v40 = *(void *)(a1 + 24);
    unsigned int v41 = *(unsigned __int8 *)(v38 + 16);
    if (v41 != 21)
    {
      if (v41 < 0x1C)
      {
        if (!*(unsigned char *)(v38 + 16)) {
          v38 |= 2uLL;
        }
      }
      else
      {
        unsigned int v42 = v41 - 33;
        BOOL v20 = v42 > 0x33;
        uint64_t v43 = (1 << v42) & 0x8000000000041;
        if (!v20 && v43 != 0)
        {
          uint64_t v40 = 0;
          v38 |= 1uLL;
        }
      }
    }
    unint64_t v185 = (unint64_t *)v38;
    uint64_t v186 = v40;
    unint64_t v80 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
    if (!v81) {
      goto LABEL_160;
    }
    unint64_t v82 = v80;
    uint64_t v30 = a1 + 32;
    if (v80)
    {
      uint64_t v83 = *(void *)(a1 + 24);
      unsigned int v84 = *(unsigned __int8 *)(v39 + 16);
      if (v84 != 21)
      {
        if (v84 < 0x1C)
        {
          if (!*(unsigned char *)(v39 + 16)) {
            v39 |= 2uLL;
          }
        }
        else
        {
          unsigned int v85 = v84 - 33;
          BOOL v20 = v85 > 0x33;
          uint64_t v86 = (1 << v85) & 0x8000000000041;
          if (!v20 && v86 != 0)
          {
            uint64_t v83 = 0;
            v39 |= 1uLL;
          }
        }
      }
      unint64_t v185 = (unint64_t *)v39;
      uint64_t v186 = v83;
      unint64_t v106 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
      if (!v107)
      {
LABEL_160:
        uint64_t v79 = 1;
LABEL_288:
        int v187 = &unk_1F2624AC0;
        sub_1CD480C18(v191);
        goto LABEL_289;
      }
      uint64_t v108 = v106;
      if (v106 && *(unsigned char *)(*(void *)v82 + 8) == 13 && *(unsigned char *)(*(void *)v106 + 8) == 13)
      {
        unsigned int v109 = *(unsigned __int8 *)(v82 + 16);
        uint64_t v110 = v82;
        if (v109 != 21)
        {
          if (v109 < 0x1C)
          {
            if (*(unsigned char *)(v82 + 16)) {
              uint64_t v110 = v82;
            }
            else {
              uint64_t v110 = v82 | 2;
            }
          }
          else
          {
            unsigned int v111 = v109 - 33;
            uint64_t v110 = v82;
            if (v111 <= 0x33)
            {
              uint64_t v110 = v82;
              if (((1 << v111) & 0x8000000000041) != 0) {
                uint64_t v110 = v82 | 1;
              }
            }
          }
        }
        char v133 = sub_1CC8E1740((uint64_t)a2, v110, 0, a1, 0);
        if ((*(uint64_t (**)(void))(*((void *)v133 + 4) + 16))())
        {
          unsigned int v134 = *(unsigned __int8 *)(v108 + 16);
          if (v134 != 21)
          {
            if (v134 < 0x1C)
            {
              if (!*(unsigned char *)(v108 + 16)) {
                v108 |= 2uLL;
              }
            }
            else
            {
              unsigned int v135 = v134 - 33;
              if (v135 <= 0x33 && ((1 << v135) & 0x8000000000041) != 0) {
                v108 |= 1uLL;
              }
            }
          }
          unsigned int v152 = sub_1CC8E1740((uint64_t)a2, v108, 0, a1, 0);
          if ((*(uint64_t (**)(void))(*((void *)v152 + 4) + 16))())
          {
            unsigned int v153 = *(_DWORD *)(*(void *)v82 + 8);
            LODWORD(v186) = v153 >> 8;
            if (v153 >> 8 > 0x40) {
              operator new[]();
            }
            unint64_t v185 = 0;
            if (*((unsigned char *)v133 + 336) && *((unsigned char *)v152 + 336))
            {
              if ((sub_1CC8E1C48(a1, *(unsigned char *)(v11 + 16), (llvm::APInt *)&v185, (llvm::APInt *)&v185) & 1) == 0)
              {
LABEL_322:
                uint64_t v138 = (*(uint64_t (**)(uint64_t))(*(void *)v30 + 40))(v30);
                goto LABEL_323;
              }
            }
            else if (*((unsigned char *)v133 + 336))
            {
              uint64_t v175 = *((unsigned int *)v152 + 50);
              if (v175)
              {
                BOOL v176 = (llvm::APInt *)*((void *)v152 + 24);
                uint64_t v177 = 16 * v175;
                while ((sub_1CC8E1C48(a1, *(unsigned char *)(v11 + 16), (llvm::APInt *)&v185, v176) & 1) != 0)
                {
                  BOOL v176 = (llvm::APInt *)((char *)v176 + 16);
                  v177 -= 16;
                  if (!v177) {
                    goto LABEL_236;
                  }
                }
                goto LABEL_322;
              }
            }
            else
            {
              unsigned int v154 = (llvm::APInt *)*((void *)v133 + 24);
              uint64_t v155 = *((unsigned int *)v133 + 50);
              if (*((unsigned char *)v152 + 336))
              {
                if (v155)
                {
                  uint64_t v178 = 16 * v155;
                  while ((sub_1CC8E1C48(a1, *(unsigned char *)(v11 + 16), v154, (llvm::APInt *)&v185) & 1) != 0)
                  {
                    unsigned int v154 = (llvm::APInt *)((char *)v154 + 16);
                    v178 -= 16;
                    if (!v178) {
                      goto LABEL_236;
                    }
                  }
                  goto LABEL_322;
                }
              }
              else if (v155)
              {
                v156 = (llvm::APInt *)((char *)v154 + 16 * v155);
                while (1)
                {
                  uint64_t v157 = *((unsigned int *)v152 + 50);
                  if (v157) {
                    break;
                  }
LABEL_278:
                  unsigned int v154 = (llvm::APInt *)((char *)v154 + 16);
                  if (v154 == v156) {
                    goto LABEL_236;
                  }
                }
                uint64_t v158 = (llvm::APInt *)*((void *)v152 + 24);
                uint64_t v159 = 16 * v157;
                while ((sub_1CC8E1C48(a1, *(unsigned char *)(v11 + 16), v154, v158) & 1) != 0)
                {
                  uint64_t v158 = (llvm::APInt *)((char *)v158 + 16);
                  v159 -= 16;
                  if (!v159) {
                    goto LABEL_278;
                  }
                }
                goto LABEL_322;
              }
            }
LABEL_236:
            uint64_t v138 = sub_1CD65BB64((uint64_t)&v187, v30);
LABEL_323:
            uint64_t v79 = v138;
            if (v186 >= 0x41 && v185) {
              MEMORY[0x1D25D9CB0](v185, 0x1000C8000313F17);
            }
            goto LABEL_288;
          }
        }
      }
    }
    goto LABEL_286;
  }
  if (v5 < 0x1C || v7 != 83)
  {
    int v13 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);
    return v13(a1 + 32);
  }
  int v187 = &unk_1F2624AC0;
  __int16 v189 = *(_WORD *)(a1 + 48);
  uint64_t v188 = &unk_1F2620BB0;
  sub_1CD65BC98(v190, (_DWORD *)(a1 + 56));
  char v192 = *(unsigned char *)(a1 + 336);
  uint64_t v45 = *(_DWORD *)(v6 + 20) & 0x7FFFFFF;
  if (!v45)
  {
LABEL_60:
    uint64_t v46 = sub_1CD65BB64((uint64_t)&v187, a1 + 32);
    goto LABEL_112;
  }
  uint64_t v47 = 0;
  uint64_t v48 = 32 * v45;
  while (1)
  {
    int v49 = *(_DWORD *)(v6 + 20);
    if ((v49 & 0x40000000) != 0) {
      unint64_t v50 = *(void *)(v6 - 8);
    }
    else {
      unint64_t v50 = v6 - 32 * (v49 & 0x7FFFFFF);
    }
    uint64_t v51 = *(void *)(v50 + v47);
    v182[0] = 0;
    uint64_t v52 = *(void *)(a1 + 24);
    unsigned int v53 = *(unsigned __int8 *)(v51 + 16);
    if (v53 != 21)
    {
      if (v53 < 0x1C)
      {
        if (!*(unsigned char *)(v51 + 16)) {
          v51 |= 2uLL;
        }
      }
      else
      {
        unsigned int v54 = v53 - 33;
        BOOL v20 = v54 > 0x33;
        uint64_t v55 = (1 << v54) & 0x8000000000041;
        if (!v20 && v55 != 0)
        {
          uint64_t v52 = 0;
          v51 |= 1uLL;
        }
      }
    }
    unint64_t v185 = (unint64_t *)v51;
    uint64_t v186 = v52;
    unint64_t v57 = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)&v185, (const llvm::AbstractAttribute *)a1, v182);
    if (!v58) {
      goto LABEL_86;
    }
    uint64_t v59 = v57;
    if (!v57) {
      break;
    }
    unsigned int v60 = *(unsigned __int8 *)(v57 + 16);
    if (v60 != 21)
    {
      if (v60 < 0x1C)
      {
        if (!*(unsigned char *)(v57 + 16)) {
          uint64_t v59 = v57 | 2;
        }
      }
      else
      {
        unsigned int v61 = v60 - 33;
        if (v61 <= 0x33 && ((1 << v61) & 0x8000000000041) != 0) {
          uint64_t v59 = v57 | 1;
        }
      }
    }
    uint64_t v62 = sub_1CC8E1740((uint64_t)a2, v59, 0, a1, 0);
    if (!(*(unsigned int (**)(uint64_t))(*((void *)v62 + 4) + 16))((uint64_t)v62 + 32)) {
      break;
    }
    if (*((unsigned char *)v62 + 336)) {
      *(unsigned char *)(a1 + 336) = *(_DWORD *)(a1 + 200) == 0;
    }
    else {
      sub_1CD65C220(a1 + 32, (uint64_t)v62 + 32);
    }
LABEL_86:
    v47 += 32;
    if (v48 == v47) {
      goto LABEL_60;
    }
  }
  uint64_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
LABEL_112:
  uint64_t v79 = v46;
  int v187 = &unk_1F2624AC0;
  sub_1CD480C18(v191);
LABEL_289:
  sub_1CD65B3B4((uint64_t)v190);
  return v79;
}

uint64_t *sub_1CC8E135C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E13E8(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E148C(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = 0;
  uint64_t result = sub_1CD650C48(a2, (uint64_t *)(a1 + 16), &v4);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  return result;
}

double sub_1CC8E14F8(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = 0;
  *(_OWORD *)(a1 + 16) = *a2;
  *(void *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 48) = 256;
  *(void *)(a1 + 40) = &unk_1F2620BB0;
  *(void *)(a1 + 56) = 1;
  do
  {
    uint64_t v3 = a1 + v2;
    *(_DWORD *)(v3 + 72) = 0;
    *(void *)(v3 + 64) = 0;
    v2 += 16;
  }
  while (v2 != 128);
  *(void *)(a1 + 192) = a1 + 208;
  *(void *)&double result = 0x800000000;
  *(void *)(a1 + 200) = 0x800000000;
  *(unsigned char *)(a1 + 336) = 0;
  *(void *)a1 = &unk_1F2624A00;
  *(void *)(a1 + 32) = &unk_1F2624A80;
  return result;
}

uint64_t sub_1CC8E15B4(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CC8E15BC(uint64_t a1)
{
  return a1 + 32;
}

llvm::APInt *sub_1CC8E15CC(uint64_t a1, llvm::APInt *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v8 = v4 + 1;
    unint64_t v9 = v5 + 16 * v4;
    if (v5 <= (unint64_t)a2 && v9 > (unint64_t)a2)
    {
      unint64_t v11 = (char *)a2 - v5;
      sub_1CBFC6948(a1, v8);
      unint64_t v5 = *(void *)a1;
      a2 = (llvm::APInt *)&v11[*(void *)a1];
    }
    else
    {
      sub_1CBFC6948(a1, v8);
      unint64_t v5 = *(void *)a1;
    }
  }
  double result = (llvm::APInt *)(v5 + 16 * *(unsigned int *)(a1 + 8));
  unsigned int v7 = *((_DWORD *)a2 + 2);
  *((_DWORD *)result + 2) = v7;
  if (v7 > 0x40) {
    llvm::APInt::initSlowCase(result, a2);
  }
  *(void *)double result = *(void *)a2;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CC8E1674(uint64_t a1, uint64_t a2, void **this)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      if (*((_DWORD *)this + 2) > 0x40u || *(_DWORD *)(v4 + 8) > 0x40u)
      {
        if ((void **)v4 != this)
        {
          llvm::APInt::reallocate((uint64_t)this, *(_DWORD *)(v4 + 8));
          uint64_t v6 = *((unsigned int *)this + 2);
          if (v6 <= 0x40) {
            *this = *(void **)v4;
          }
          else {
            memcpy(*this, *(const void **)v4, ((unint64_t)(v6 + 63) >> 3) & 0x3FFFFFF8);
          }
        }
      }
      else
      {
        *this = *(void **)v4;
        *((_DWORD *)this + 2) = *(_DWORD *)(v4 + 8);
      }
      v4 += 16;
      this += 2;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

llvm::AbstractAttribute *sub_1CC8E1740(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (byte_1EBD07860) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = 0;
  }
  *(void *)&long long v52 = a2;
  *((void *)&v52 + 1) = v8;
  char v10 = (llvm::AbstractAttribute *)sub_1CD65C028(a1, &v52, a4, a5);
  if (v10) {
    return v10;
  }
  llvm::AAPotentialConstantValues::createForPosition((llvm::AAPotentialConstantValues *)&v52, (uint64_t **)a1, v9);
  char v10 = (llvm::AbstractAttribute *)v12;
  sub_1CD65C114(a1, v12);
  int v13 = *(uint64_t **)(a1 + 5480);
  if (v13)
  {
    __p[0] = &llvm::AAPotentialConstantValues::ID;
    v48[0] = 0;
    int v14 = sub_1CD420258(v13, __p, v48) ^ 1;
  }
  else
  {
    int v14 = 0;
  }
  uint64_t v15 = v52 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v52 & 3) == 0) {
    uint64_t v15 = *(void *)(v15 + 24);
  }
  unsigned int v16 = *(unsigned __int8 *)(v15 + 16);
  if (!*(unsigned char *)(v15 + 16)) {
    goto LABEL_16;
  }
  if (v16 == 21)
  {
    uint64_t v17 = (uint64_t *)(v15 + 24);
  }
  else
  {
    if (v16 < 0x1C)
    {
      uint64_t v15 = 0;
      goto LABEL_23;
    }
    uint64_t v17 = (uint64_t *)(*(void *)(v15 + 40) + 56);
  }
  uint64_t v15 = *v17;
  if (!*v17)
  {
LABEL_23:
    char v20 = 1;
    goto LABEL_48;
  }
LABEL_16:
  uint64_t v18 = *(void *)(v15 + 112);
  if (v18 && ((*(unsigned char *)(v18 + 14) & 2) != 0 || (*(unsigned char *)(v18 + 17) & 8) != 0))
  {
    BOOL v19 = 1;
  }
  else if (*(unsigned char *)(a1 + 5464))
  {
    BOOL v19 = 0;
  }
  else
  {
    uint64_t v21 = *(uint64_t **)(a1 + 88);
    uint64_t v23 = *v21;
    uint64_t v22 = v21[1];
    if (v22 == *v21)
    {
      uint64_t v24 = *((unsigned int *)v21 + 5);
      uint64_t v25 = (void *)(v22 + 8 * v24);
      if (v24)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 8 * v24;
        while (*(void *)(v22 + v26) != v15)
        {
          v26 += 8;
          if (v27 == v26) {
            goto LABEL_43;
          }
        }
        uint64_t v25 = (void *)(v22 + v26);
      }
LABEL_43:
      uint64_t v23 = v21[1];
    }
    else
    {
      uint64_t v28 = *((unsigned int *)v21 + 4);
      int v29 = v28 - 1;
      unsigned int v30 = (v28 - 1) & ((v15 >> 4) ^ (v15 >> 9));
      uint64_t v25 = (void *)(v22 + 8 * v30);
      uint64_t v31 = *v25;
      if (*v25 == -1)
      {
        uint64_t v32 = 0;
LABEL_84:
        if (v32) {
          uint64_t v25 = v32;
        }
        if (*v25 != v15) {
          uint64_t v25 = (void *)(v22 + 8 * v28);
        }
      }
      else
      {
        uint64_t v32 = 0;
        int v33 = 1;
        while (v31 != v15)
        {
          if (v32) {
            BOOL v34 = 0;
          }
          else {
            BOOL v34 = v31 == -2;
          }
          if (v34) {
            uint64_t v32 = v25;
          }
          unsigned int v35 = v30 + v33++;
          unsigned int v30 = v35 & v29;
          uint64_t v25 = (void *)(v22 + 8 * (v35 & v29));
          uint64_t v31 = *v25;
          if (*v25 == -1) {
            goto LABEL_84;
          }
        }
      }
    }
    BOOL v34 = v22 == v23;
    uint64_t v36 = 16;
    if (v34) {
      uint64_t v36 = 20;
    }
    BOOL v19 = v25 == (void *)(v22 + 8 * *(unsigned int *)((char *)v21 + v36));
  }
  char v20 = 0;
  LOBYTE(v14) = (v19 | v14) != 0;
LABEL_48:
  if ((v14 & 1) != 0 || *(_DWORD *)(a1 + 4372) > llvm::MaxInitializationChainLength) {
    goto LABEL_75;
  }
  (*(void (**)(void **__return_ptr, llvm::AbstractAttribute *))(*(void *)v10 + 72))(v48, v10);
  if (v49 >= 0) {
    size_t v37 = v49 & 0x7F;
  }
  else {
    size_t v37 = (size_t)v48[1];
  }
  uint64_t v38 = __p;
  sub_1CB907098((uint64_t)__p, v37 + 12);
  if (v51 < 0) {
    uint64_t v38 = (void **)__p[0];
  }
  if (v37)
  {
    if (v49 >= 0) {
      uint64_t v39 = v48;
    }
    else {
      uint64_t v39 = (void **)v48[0];
    }
    memmove(v38, v39, v37);
  }
  strcpy((char *)v38 + v37, "::initialize");
  uint64_t v40 = (uint64_t *)off_1EC7DFC00();
  if (*v40)
  {
    if (v51 >= 0) {
      unsigned int v41 = __p;
    }
    else {
      unsigned int v41 = (void **)__p[0];
    }
    if (v51 >= 0) {
      uint64_t v42 = v51 & 0x7F;
    }
    else {
      uint64_t v42 = (uint64_t)__p[1];
    }
    llvm::timeTraceProfilerBegin((uint64_t)v41, v42, (uint64_t)"", 0);
  }
  if (v51 < 0) {
    operator delete(__p[0]);
  }
  if (v49 < 0) {
    operator delete(v48[0]);
  }
  ++*(_DWORD *)(a1 + 4372);
  (*(void (**)(llvm::AbstractAttribute *, uint64_t))(*(void *)v10 + 24))(v10, a1);
  --*(_DWORD *)(a1 + 4372);
  if (*v40)
  {
    sub_1CD84B62C(*v40);
    if (v20) {
      goto LABEL_74;
    }
  }
  else if (v20)
  {
    goto LABEL_74;
  }
  uint64_t v46 = *(uint64_t **)(a1 + 80);
  __p[0] = (void *)v15;
  v48[0] = 0;
  if ((sub_1CD420258(v46, __p, v48) & 1) == 0)
  {
    uint64_t v47 = *(uint64_t **)(a1 + 80);
    __p[0] = (void *)sub_1CD648A0C((llvm::IRPosition *)&v52);
    v48[0] = 0;
    if ((sub_1CD420258(v47, __p, v48) & 1) == 0) {
      goto LABEL_75;
    }
  }
LABEL_74:
  int v43 = *(_DWORD *)(a1 + 4368);
  if (v43 == 2)
  {
LABEL_75:
    uint64_t v44 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 40))(v10);
    (*(void (**)(uint64_t))(*(void *)v44 + 40))(v44);
    return v10;
  }
  *(_DWORD *)(a1 + 4368) = 1;
  llvm::Attributor::updateAA((llvm::Attributor *)a1, v10);
  *(_DWORD *)(a1 + 4368) = v43;
  if (a4)
  {
    uint64_t v45 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v10 + 40))(v10);
    if ((*(unsigned int (**)(uint64_t))(*(void *)v45 + 16))(v45)) {
      llvm::Attributor::recordDependence(a1, (uint64_t)v10, a4, a5);
    }
  }
  return v10;
}

uint64_t sub_1CC8E1C48(uint64_t a1, char a2, llvm::APInt *this, llvm::APInt *a4)
{
  switch(a2)
  {
    case ')':
      unsigned int v27 = *((_DWORD *)this + 2);
      if (v27 >= 0x41) {
        operator new[]();
      }
      uint64_t v28 = *(void *)a4 + *(void *)this;
      goto LABEL_51;
    case '+':
      unsigned int v27 = *((_DWORD *)this + 2);
      if (v27 >= 0x41) {
        operator new[]();
      }
      uint64_t v28 = *(void *)this - *(void *)a4;
LABEL_51:
      unint64_t v29 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v27;
      if (!v27) {
        unint64_t v29 = 0;
      }
      goto LABEL_63;
    case '-':
      llvm::APInt::operator*((uint64_t)this, a4, (uint64_t)&v57);
      goto LABEL_94;
    case '/':
      uint64_t v5 = *((unsigned int *)a4 + 2);
      if (v5 <= 0x40)
      {
        if (!*(void *)a4) {
          goto LABEL_44;
        }
        goto LABEL_22;
      }
      int v10 = 0;
      int64_t v11 = (unint64_t)(v5 + 63) >> 6;
      do
      {
        BOOL v12 = v11-- < 1;
        if (v12) {
          break;
        }
        unint64_t v13 = *(void *)(*(void *)a4 + 8 * v11);
        v10 += __clz(v13);
      }
      while (!v13);
      int v14 = v5 | 0xFFFFFFC0;
      if ((v5 & 0x3F) == 0) {
        int v14 = 0;
      }
      if (v10 + v14 != v5)
      {
LABEL_22:
        llvm::APInt::udiv((uint64_t)this, a4, (uint64_t)&v57);
        goto LABEL_94;
      }
      goto LABEL_44;
    case '0':
      uint64_t v7 = *((unsigned int *)a4 + 2);
      if (v7 <= 0x40)
      {
        if (!*(void *)a4) {
          goto LABEL_44;
        }
        goto LABEL_30;
      }
      int v15 = 0;
      int64_t v16 = (unint64_t)(v7 + 63) >> 6;
      do
      {
        BOOL v12 = v16-- < 1;
        if (v12) {
          break;
        }
        unint64_t v17 = *(void *)(*(void *)a4 + 8 * v16);
        v15 += __clz(v17);
      }
      while (!v17);
      int v18 = v7 | 0xFFFFFFC0;
      if ((v7 & 0x3F) == 0) {
        int v18 = 0;
      }
      if (v15 + v18 != v7)
      {
LABEL_30:
        llvm::APInt::sdiv(this, a4, (uint64_t)&v57);
        goto LABEL_94;
      }
      goto LABEL_44;
    case '2':
      uint64_t v8 = *((unsigned int *)a4 + 2);
      if (v8 <= 0x40)
      {
        if (!*(void *)a4) {
          goto LABEL_44;
        }
        goto LABEL_37;
      }
      int v19 = 0;
      int64_t v20 = (unint64_t)(v8 + 63) >> 6;
      do
      {
        BOOL v12 = v20-- < 1;
        if (v12) {
          break;
        }
        unint64_t v21 = *(void *)(*(void *)a4 + 8 * v20);
        v19 += __clz(v21);
      }
      while (!v21);
      int v22 = v8 | 0xFFFFFFC0;
      if ((v8 & 0x3F) == 0) {
        int v22 = 0;
      }
      if (v19 + v22 != v8)
      {
LABEL_37:
        llvm::APInt::urem(this, a4, (uint64_t)&v57);
        goto LABEL_94;
      }
      goto LABEL_44;
    case '3':
      uint64_t v9 = *((unsigned int *)a4 + 2);
      if (v9 <= 0x40)
      {
        if (!*(void *)a4) {
          goto LABEL_44;
        }
        goto LABEL_68;
      }
      int v23 = 0;
      int64_t v24 = (unint64_t)(v9 + 63) >> 6;
      do
      {
        BOOL v12 = v24-- < 1;
        if (v12) {
          break;
        }
        unint64_t v25 = *(void *)(*(void *)a4 + 8 * v24);
        v23 += __clz(v25);
      }
      while (!v25);
      int v26 = v9 | 0xFFFFFFC0;
      if ((v9 & 0x3F) == 0) {
        int v26 = 0;
      }
      if (v23 + v26 != v9)
      {
LABEL_68:
        llvm::APInt::srem(this, a4, (uint64_t)&v57);
        goto LABEL_94;
      }
LABEL_44:
      unsigned int v58 = *((_DWORD *)this + 2);
      if (v58 > 0x40) {
        operator new[]();
      }
      unint64_t v57 = *(void *)this;
      goto LABEL_95;
    case '5':
      unint64_t v30 = *((unsigned int *)this + 2);
      unsigned int v58 = v30;
      if (v30 > 0x40) {
        operator new[]();
      }
      uint64_t v31 = *(void *)this;
      unint64_t v57 = *(void *)this;
      uint64_t v35 = *((unsigned int *)a4 + 2);
      if (v35 < 0x41)
      {
        unint64_t v36 = *(void *)a4;
        goto LABEL_74;
      }
      int v46 = 0;
      int64_t v47 = (unint64_t)(v35 + 63) >> 6;
      uint64_t v48 = *(unint64_t **)a4;
      do
      {
        BOOL v12 = v47-- < 1;
        if (v12) {
          break;
        }
        unint64_t v49 = v48[v47];
        v46 += __clz(v49);
      }
      while (!v49);
      int v50 = v35 | 0xFFFFFFC0;
      if ((v35 & 0x3F) == 0) {
        int v50 = 0;
      }
      int v37 = v30;
      if ((v35 - v46 - v50) <= 0x40)
      {
        unint64_t v36 = *v48;
LABEL_74:
        int v37 = v30;
        if (v36 <= v30) {
          int v37 = v36;
        }
      }
      uint64_t v38 = v31 << v37;
      if (v30 == v37) {
        uint64_t v38 = 0;
      }
      unint64_t v39 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v30;
      if (!v30) {
        unint64_t v39 = 0;
      }
      unint64_t v40 = v39 & v38;
      goto LABEL_88;
    case '6':
      unint64_t v32 = *((unsigned int *)this + 2);
      unsigned int v58 = v32;
      if (v32 > 0x40) {
        operator new[]();
      }
      unint64_t v33 = *(void *)this;
      unint64_t v57 = *(void *)this;
      uint64_t v41 = *((unsigned int *)a4 + 2);
      if (v41 < 0x41)
      {
        unint64_t v42 = *(void *)a4;
        goto LABEL_84;
      }
      int v51 = 0;
      int64_t v52 = (unint64_t)(v41 + 63) >> 6;
      unsigned int v53 = *(unint64_t **)a4;
      do
      {
        BOOL v12 = v52-- < 1;
        if (v12) {
          break;
        }
        unint64_t v54 = v53[v52];
        v51 += __clz(v54);
      }
      while (!v54);
      int v55 = v41 | 0xFFFFFFC0;
      if ((v41 & 0x3F) == 0) {
        int v55 = 0;
      }
      unsigned int v56 = v41 - v51 - v55;
      int v43 = v32;
      if (v56 <= 0x40)
      {
        unint64_t v42 = *v53;
LABEL_84:
        int v43 = v32;
        if (v42 <= v32) {
          int v43 = v42;
        }
      }
      if (v32 == v43)
      {
        unint64_t v57 = 0;
      }
      else
      {
        unint64_t v40 = v33 >> v43;
LABEL_88:
        unint64_t v57 = v40;
      }
LABEL_94:
      sub_1CD65B468(a1 + 32, (llvm *)&v57);
LABEL_95:
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32);
      if (v58 >= 0x41 && v57 != 0) {
        MEMORY[0x1D25D9CB0](v57, 0x1000C8000313F17);
      }
      return v6;
    case '7':
      unsigned int v58 = *((_DWORD *)this + 2);
      if (v58 > 0x40) {
        operator new[]();
      }
      unint64_t v57 = *(void *)this;
      llvm::APInt::ashrInPlace((unsigned int *)&v57, a4);
      goto LABEL_94;
    case '8':
      unsigned int v27 = *((_DWORD *)this + 2);
      if (v27 > 0x40) {
        operator new[]();
      }
      uint64_t v28 = *(void *)this;
      unint64_t v29 = *(void *)a4;
LABEL_63:
      unint64_t v34 = v29 & v28;
      goto LABEL_93;
    case '9':
      unsigned int v27 = *((_DWORD *)this + 2);
      if (v27 > 0x40) {
        operator new[]();
      }
      unint64_t v34 = *(void *)a4 | *(void *)this;
      goto LABEL_93;
    case ':':
      unsigned int v27 = *((_DWORD *)this + 2);
      if (v27 > 0x40) {
        operator new[]();
      }
      unint64_t v34 = *(void *)a4 ^ *(void *)this;
LABEL_93:
      unsigned int v58 = v27;
      unint64_t v57 = v34;
      goto LABEL_94;
    default:
      if (*((_DWORD *)this + 2) >= 0x41u) {
        operator new[]();
      }
      return 0;
  }
}

uint64_t sub_1CC8E25A8(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8E2624(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E26C0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 16);
  uint64_t result = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (!result) {
    goto LABEL_2;
  }
  uint64_t result = sub_1CD6482A0(v4);
  if (!result || *(unsigned char *)(result + 16) != 3)
  {
    if (*(unsigned char *)(result + 16) || *(void *)(result + 72) != result + 72 || (*(unsigned char *)(result + 34) & 0x80) != 0) {
      goto LABEL_11;
    }
LABEL_2:
    *(unsigned char *)(a1 + 49) = *(unsigned char *)(a1 + 48);
    return result;
  }
  if ((*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
    goto LABEL_2;
  }
LABEL_11:
  uint64_t v6 = 0;
  uint64_t result = sub_1CD650C48(a2, v4, &v6);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  return result;
}

void sub_1CC8E2794()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C118, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C118))
  {
    __cxa_guard_release(&qword_1EA61C118);
  }
}

uint64_t sub_1CC8E27E8(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v4 = 0;
  v12[0] = &unk_1F2624AC0;
  __int16 v13 = 256;
  v12[1] = &unk_1F2620BB0;
  v14[0] = 1;
  do
  {
    uint64_t v5 = &v12[v4];
    *((_DWORD *)v5 + 10) = 0;
    v5[4] = 0;
    v4 += 2;
  }
  while (v4 != 16);
  v15[0] = v16;
  v15[1] = (char *)0x800000000;
  unsigned char v16[128] = 0;
  LOBYTE(v20[0]) = 0;
  char v23 = 0;
  int v11 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  v10[0] = &v11;
  v10[1] = a2;
  void v10[2] = a1;
  v10[3] = v20;
  if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8E2D98, (uint64_t)v10, a1, 1, &v9))
  {
    if (!v23) {
      goto LABEL_9;
    }
    sub_1CC8E2CD8((uint64_t)&v17, (uint64_t)v12, (uint64_t)v20);
    unint64_t v17 = &unk_1F2624AC0;
    sub_1CD480C18(&v19);
    sub_1CD65B3B4((uint64_t)&v18);
  }
  else
  {
    (*(void (**)(void *))(v12[0] + 40))(v12);
  }
  if (v23)
  {
    v20[0] = &unk_1F2624AC0;
    sub_1CD480C18(&v22);
    sub_1CD65B3B4((uint64_t)&v21);
  }
LABEL_9:
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v7 = sub_1CC8E2B98(v6, (uint64_t)v12);
  v12[0] = &unk_1F2624AC0;
  sub_1CD480C18(v15);
  sub_1CD65B3B4((uint64_t)v14);
  return v7;
}

uint64_t *sub_1CC8E2A68(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E2AF4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E2B98(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  v9[0] = &unk_1F2624AC0;
  __int16 v10 = *(_WORD *)(a1 + 16);
  v9[1] = &unk_1F2620BB0;
  sub_1CD65BC98(v11, (_DWORD *)(a1 + 24));
  char v13 = *(unsigned char *)(a1 + 304);
  sub_1CC8E2CD8((uint64_t)&v6, a1, a2);
  uint64_t v6 = &unk_1F2624AC0;
  sub_1CD480C18(&v8);
  sub_1CD65B3B4((uint64_t)&v7);
  uint64_t v4 = sub_1CD65BB64((uint64_t)v9, a1);
  v9[0] = &unk_1F2624AC0;
  sub_1CD480C18(&v12);
  sub_1CD65B3B4((uint64_t)v11);
  return v4;
}

void *sub_1CC8E2CD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t, void))(*(void *)(a2 + 8) + 48))(a2 + 8, *(unsigned __int8 *)(a3 + 17));
  sub_1CD65C220(a2, a3);
  *(void *)a1 = &unk_1F2624AC0;
  *(_WORD *)(a1 + 16) = *(_WORD *)(a2 + 16);
  *(void *)(a1 + 8) = &unk_1F2620BB0;
  uint64_t result = sub_1CD65BC98((void *)(a1 + 24), (_DWORD *)(a2 + 24));
  *(unsigned char *)(a1 + 304) = *(unsigned char *)(a2 + 304);
  return result;
}

uint64_t sub_1CC8E2D98(uint64_t a1, uint64_t *a2)
{
  v20[19] = *(char **)MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  int v11 = &v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v13 = v10;
    uint64_t v14 = &v16;
    uint64_t v15 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v14, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v13 = v3;
    uint64_t v14 = &v16;
    uint64_t v15 = 0;
  }
  uint64_t v16 = sub_1CD659800((uint64_t)&v13, **(_DWORD **)a1);
  uint64_t v17 = v4;
  if (v14 != &v16) {
    free(v14);
  }
  if (sub_1CD647DEC(&v16))
  {
    uint64_t v7 = sub_1CC8E1740(*(void *)(a1 + 8), v16, v17, *(void *)(a1 + 16), 0);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    uint64_t v9 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v9 + 312))
    {
      sub_1CD65C354((uint64_t)&v18, v9, v8);
      uint64_t v18 = &unk_1F2624AC0;
      sub_1CD480C18(v20);
      sub_1CD65B3B4((uint64_t)&v19);
    }
    else
    {
      sub_1CD65C418(*(void *)(a1 + 24), v8);
    }
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (v11 != &v13) {
    free(v11);
  }
  return v5;
}

uint64_t sub_1CC8E2F6C(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8E2FE8(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E3084()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C120, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C120))
  {
    __cxa_guard_release(&qword_1EA61C120);
  }
}

uint64_t sub_1CC8E30D8(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v4 = 0;
  v11[0] = &unk_1F2624AC0;
  __int16 v12 = 256;
  v11[1] = &unk_1F2620BB0;
  v13[0] = 1;
  do
  {
    uint64_t v5 = &v11[v4];
    *((_DWORD *)v5 + 10) = 0;
    v5[4] = 0;
    v4 += 2;
  }
  while (v4 != 16);
  v14[0] = v15;
  v14[1] = (char *)0x800000000;
  v15[128] = 0;
  LOBYTE(v19[0]) = 0;
  char v22 = 0;
  v9[0] = &v10;
  v9[1] = a2;
  void v9[2] = a1;
  void v9[3] = v19;
  uint64_t v10 = 0;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8E3474, (uint64_t)v9, a1))
  {
    if (!v22) {
      goto LABEL_9;
    }
    sub_1CC8E2CD8((uint64_t)&v16, (uint64_t)v11, (uint64_t)v19);
    uint64_t v16 = &unk_1F2624AC0;
    sub_1CD480C18(&v18);
    sub_1CD65B3B4((uint64_t)&v17);
  }
  else
  {
    (*(void (**)(void *))(v11[0] + 40))(v11);
  }
  if (v22)
  {
    v19[0] = &unk_1F2624AC0;
    sub_1CD480C18(&v21);
    sub_1CD65B3B4((uint64_t)&v20);
  }
LABEL_9:
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v7 = sub_1CC8E2B98(v6, (uint64_t)v11);
  v11[0] = &unk_1F2624AC0;
  sub_1CD480C18(v14);
  sub_1CD65B3B4((uint64_t)v13);
  return v7;
}

uint64_t *sub_1CC8E3344(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E33D0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E3474(uint64_t a1, uint64_t a2)
{
  v15[19] = *(char **)MEMORY[0x1E4F143B8];
  uint64_t v3 = **(void **)a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 != 21)
  {
    if (v4 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v5 = v4 - 33;
      BOOL v6 = v5 > 0x33;
      uint64_t v7 = (1 << v5) & 0x8000000000041;
      if (!v6 && v7 != 0)
      {
        uint64_t v3 = 0;
        a2 |= 1uLL;
      }
    }
  }
  uint64_t v9 = sub_1CC8E1740(*(void *)(a1 + 8), a2, v3, *(void *)(a1 + 16), 0);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v11 + 312))
  {
    sub_1CD65C354((uint64_t)&v13, v11, v10);
    uint64_t v13 = &unk_1F2624AC0;
    sub_1CD480C18(v15);
    sub_1CD65B3B4((uint64_t)&v14);
  }
  else
  {
    sub_1CD65C418(*(void *)(a1 + 24), v10);
  }
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
}

uint64_t sub_1CC8E35D8(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8E3654(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E36F0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C128, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C128))
  {
    __cxa_guard_release(&qword_1EA61C128);
  }
}

uint64_t sub_1CC8E3744(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD648A0C(v4);
  if (v6)
  {
    uint64_t v7 = sub_1CC8E1740(a2, v6 | 1, 0, a1, 0);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    return sub_1CC8E2B98(v5, v8);
  }
  else
  {
    uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)v5 + 40);
    return v10(v5);
  }
}

uint64_t *sub_1CC8E3840(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E38CC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E3970(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1CC8E39EC(uint64_t a1)
{
  *(void *)(a1 + 32) = &unk_1F2624AC0;
  uint64_t v2 = a1 + 56;
  sub_1CD480C18((char **)(a1 + 192));
  sub_1CD65B3B4(v2);
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8E3A88(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v6 = 0;
  if (sub_1CD650C48(a2, (uint64_t *)(a1 + 16), &v6)) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 40))();
  }
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 24))(a1 + 32);
  if ((result & 1) == 0)
  {
    unint64_t result = sub_1CD6482F0(v3);
    int v5 = *(unsigned __int8 *)(result + 16);
    if (v5 == 16)
    {
      sub_1CD65B468(a1 + 32, (llvm *)(result + 24));
    }
    else
    {
      if ((v5 - 11) > 1) {
        return result;
      }
      *(unsigned char *)(a1 + 336) = *(_DWORD *)(a1 + 200) == 0;
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
  }
  return result;
}

void sub_1CC8E3B98()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C130, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C130))
  {
    __cxa_guard_release(&qword_1EA61C130);
  }
}

uint64_t sub_1CC8E3BEC(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  v13[0] = &unk_1F2624AC0;
  __int16 v14 = *(_WORD *)(a1 + 48);
  v13[1] = &unk_1F2620BB0;
  sub_1CD65BC98(v15, (_DWORD *)(a1 + 56));
  char v17 = *(unsigned char *)(a1 + 336);
  unsigned int v5 = *(unsigned __int8 *)(v4 + 16);
  if (v5 != 21)
  {
    if (v5 < 0x1C)
    {
      if (!*(unsigned char *)(v4 + 16)) {
        v4 |= 2uLL;
      }
    }
    else
    {
      unsigned int v6 = v5 - 33;
      BOOL v7 = v6 > 0x33;
      uint64_t v8 = (1 << v6) & 0x8000000000041;
      if (!v7 && v8 != 0) {
        v4 |= 1uLL;
      }
    }
  }
  uint64_t v10 = sub_1CC8E1740(a2, v4, 0, a1, 0);
  sub_1CD65C220(a1 + 32, (uint64_t)v10 + 32);
  uint64_t v11 = sub_1CD65BB64((uint64_t)v13, a1 + 32);
  v13[0] = &unk_1F2624AC0;
  sub_1CD480C18(&v16);
  sub_1CD65B3B4((uint64_t)v15);
  return v11;
}

uint64_t *sub_1CC8E3D68(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;

  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E3DF4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2624AC0;
  uint64_t v2 = a1 + 24;
  sub_1CD480C18((char **)(a1 + 160));
  sub_1CD65B3B4(v2);
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E3E98(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E3EDC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8E3F40(uint64_t a1, uint64_t a2)
{
  v39[4] = *MEMORY[0x1E4F143B8];
  sub_1CC8E45EC((void *)a1, a2);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
  if ((result & 1) == 0)
  {
    unint64_t result = sub_1CC8AB830((_DWORD *)(a1 + 16));
    if (result)
    {
      uint64_t v6 = result;
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      v32[0] = 0;
      v32[1] = 0;
      int v33 = 0;
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      uint64_t v34 = 0;
      for (uint64_t i = *(void **)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 8); i; uint64_t i = (void *)i[1])
      {
        int v37 = i;
        sub_1CC61C590(v32, &v37);
      }
      uint64_t v9 = *(void *)(a2 + 88) + 136;
      sub_1CC8E4700(a1, a2, v9, v6, v32, v7);
      if (((*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7) & 1) == 0)
      {
        int v37 = v39;
        uint64_t v38 = 0x400000000;
        uint64_t v31 = &v37;
        sub_1CD65952C(v9, v6, (unsigned int (*)(uint64_t))sub_1CC8E4928, (uint64_t)&v31);
        uint64_t v10 = (char *)v37;
        if (v38)
        {
          uint64_t v11 = (char *)v37 + 8 * v38;
          unint64_t v25 = v11;
          uint64_t v26 = v7;
          do
          {
            uint64_t v12 = *(void *)v10;
            unint64_t v29 = &unk_1F2620BB0;
            __int16 v30 = 257;
            int v13 = *(_DWORD *)(v12 + 20);
            if ((v13 & 0x40000000) != 0)
            {
              uint64_t v15 = *(void *)(v12 - 8);
              uint64_t v14 = v13 & 0x7FFFFFF;
            }
            else
            {
              uint64_t v14 = v13 & 0x7FFFFFF;
              uint64_t v15 = v12 - 32 * v14;
            }
            uint64_t v16 = v14 == 3;
            if (v14 == v16)
            {
              int v17 = 1;
            }
            else
            {
              uint64_t v18 = (uint64_t *)(v15 + 32 * v14);
              uint64_t v19 = (uint64_t *)(v15 + 32 * v16);
              do
              {
                uint64_t v20 = *v19;
                __int16 v28 = 256;
                unsigned int v27 = &unk_1F2620BB0;
                uint64_t v21 = &v35[-v34];
                uint64_t v22 = *(void *)(v20 + 48);
                if (v22) {
                  uint64_t v23 = v22 - 24;
                }
                else {
                  uint64_t v23 = 0;
                }
                sub_1CC8E4700(a1, a2, v9, v23, v32, (uint64_t)&v27);
                for (j = &v21[v34]; v35 != j; j = sub_1CD659618((uint64_t)v32, j))
                  ;
                (*((void (**)(void **, void, void))v29 + 9))(&v29, HIBYTE(v28), v28);
                v19 += 4;
              }
              while (v19 != v18);
              int v17 = v30;
              uint64_t v11 = v25;
              uint64_t v7 = v26;
            }
            (*(void (**)(uint64_t, BOOL))(*(void *)v7 + 56))(v7, v17 != 0);
            v10 += 8;
          }
          while (v10 != v11);
          uint64_t v10 = (char *)v37;
        }
        if (v10 != (char *)v39) {
          free(v10);
        }
      }
      return (unint64_t)sub_1CD456CB4(v32);
    }
  }
  return result;
}

void *sub_1CC8E42CC@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "noundef";
  }
  else {
    uint64_t v3 = "may-undef-or-poison";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 7;
  }
  else {
    size_t v4 = 19;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

uint64_t sub_1CC8E4328(const llvm::AbstractAttribute *a1, llvm::Attributor *a2)
{
  BOOL v8 = 0;
  size_t v4 = (const llvm::AbstractAttribute *)((char *)a1 + 16);
  uint64_t v5 = 1;
  if ((llvm::Attributor::isAssumedDead((uint64_t)a2, (uint64_t)a1 + 16, 0, 0, &v8, 0, 1) & 1) == 0)
  {
    llvm::Attributor::getAssumedSimplified(a2, v4, a1, &v8);
    if (v6) {
      return sub_1CD65C700((uint64_t)a1, (uint64_t)a2);
    }
  }
  return v5;
}

void sub_1CC8E43C0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C138, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C138))
  {
    __cxa_guard_release(&qword_1EA61C138);
  }
}

uint64_t sub_1CC8E4414(uint64_t *a1, llvm::Attributor *a2)
{
  v13[0] = a2;
  v13[1] = a1;
  __int16 v12 = 256;
  uint64_t v11 = &unk_1F2620BB0;
  BOOL v10 = 0;
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  unint64_t v6 = sub_1CC8AB830((_DWORD *)a1 + 4);
  if ((sub_1CC8C9CC4(a2, v4, v5, (const llvm::AbstractAttribute *)a1, (uint64_t)&v11, (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL))sub_1CC8E49B8, (uint64_t)v13, v6, &v10) & 1) == 0)return (*(uint64_t (**)(uint64_t *))(a1[4] + 40))(a1 + 4); {
  uint64_t v7 = (unsigned char *)(*(uint64_t (**)(uint64_t *))(*a1 + 40))(a1);
  }
  BOOL v8 = v7[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v7 + 48))(v7, HIBYTE(v12));
  return v8 ^ (v7[9] != 0);
}

uint64_t *sub_1CC8E455C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E4584(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8E45EC(void *a1, uint64_t a2)
{
  uint64_t v4 = (llvm::IRPosition *)(a1 + 2);
  unsigned int v9 = 36;
  if (llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 2), &v9, 1, 0, 0)) {
    return (*(uint64_t (**)(void *))(a1[4] + 32))(a1 + 4);
  }
  unint64_t v6 = sub_1CD6482F0(v4);
  int v7 = *(unsigned __int8 *)(v6 + 16);
  if ((v7 - 11) <= 1) {
    return (*(uint64_t (**)(void *))(a1[4] + 40))(a1 + 4);
  }
  if (v7 == 95) {
    return (*(uint64_t (**)(void *))(a1[4] + 32))(a1 + 4);
  }
  BOOL v8 = (uint64_t ***)v6;
  if (sub_1CD647DEC(v4) != 2 && sub_1CC16A22C(v8, 0, 0, 0, 0, 0)) {
    return (*(uint64_t (**)(void *))(a1[4] + 32))(a1 + 4);
  }
  else {
    return sub_1CD65C5A0(a1, a2);
  }
}

uint64_t sub_1CC8E4700(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v11 = sub_1CD4B25C4(a3, a4);
  v38[0] = 0;
  v38[1] = 0;
  int v39 = 0;
  sub_1CBFCB9AC((uint64_t)v38, v11);
  long long v12 = *(_OWORD *)(v11 + 40);
  long long v40 = *(_OWORD *)(v11 + 24);
  long long v41 = v12;
  v34[0] = 0;
  v34[1] = 0;
  int v35 = 0;
  sub_1CBFCB9AC((uint64_t)v34, a3 + 176);
  long long v36 = *(_OWORD *)(a3 + 200);
  long long v37 = *(_OWORD *)(a3 + 216);
  uint64_t v13 = a5[3];
  if (a5[4] != v13)
  {
    uint64_t v14 = 0;
    unsigned int v15 = 0;
    uint64_t v16 = (_DWORD *)(a1 + 16);
    do
    {
      uint64_t v17 = *(void *)(v13 + 8 * v14);
      uint64_t v18 = *(void *)(v17 + 24);
      if (v18) {
        BOOL v19 = *(unsigned __int8 *)(v18 + 16) >= 0x1Cu;
      }
      else {
        BOOL v19 = 0;
      }
      if (v19 && sub_1CD648B2C(a3, *(void *)(v17 + 24), v38, v34))
      {
        unint64_t v32 = *(uint64_t ****)v17;
        uint64_t v20 = *(void *)(a2 + 88);
        unint64_t v21 = sub_1CD6482A0(v16);
        if (v21)
        {
          unint64_t v22 = v21;
          uint64_t v23 = **(void **)(v20 + 440);
          uint64_t v24 = *(void *)(v22 + 40);
          if (v23) {
            BOOL v25 = v24 == 0;
          }
          else {
            BOOL v25 = 1;
          }
          if (!v25) {
            llvm::AnalysisManager<llvm::Function>::getResultImpl();
          }
          if (v23) {
            BOOL v26 = v24 == 0;
          }
          else {
            BOOL v26 = 1;
          }
          if (!v26) {
            llvm::AnalysisManager<llvm::Function>::getResultImpl();
          }
        }
        char v27 = sub_1CC16A22C(v32, 0, v18, 0, 0, 0);
        *(unsigned char *)(a6 + 8) |= v27;
        *(unsigned char *)(a6 + 9) |= v27;
        int v28 = *(unsigned __int8 *)(v18 + 16);
        if (v28 == 62 || (v28 - 66) <= 0xC)
        {
          for (uint64_t i = *(void *)(v18 + 8); i; uint64_t i = *(void *)(i + 8))
          {
            uint64_t v33 = i;
            sub_1CC61C590(a5, &v33);
          }
        }
      }
      uint64_t v13 = a5[3];
      uint64_t v14 = ++v15;
    }
    while (v15 < (unint64_t)((a5[4] - v13) >> 3));
  }
  MEMORY[0x1D25D9CD0](v34[0], 8);
  return MEMORY[0x1D25D9CD0](v38[0], 8);
}

uint64_t sub_1CC8E4928(uint64_t *a1, uint64_t a2)
{
  if (a2 && *(unsigned char *)(a2 + 16) == 30 && (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3)
  {
    uint64_t v2 = *a1;
    unsigned int v3 = *(_DWORD *)(*a1 + 8);
    if (v3 >= *(_DWORD *)(*a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v2 + 8 * v3) = a2;
    ++*(_DWORD *)(v2 + 8);
  }
  return 1;
}

uint64_t sub_1CC8E49B8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  unsigned int v10 = *(unsigned __int8 *)(a2 + 16);
  if (v10 != 21)
  {
    if (v10 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v11 = v10 - 33;
      BOOL v12 = v11 > 0x33;
      uint64_t v13 = (1 << v11) & 0x8000000000041;
      if (!v12 && v13 != 0) {
        a2 |= 1uLL;
      }
    }
  }
  unsigned int v15 = sub_1CC8B9CBC(v7, a2, 0, v8, 0, 0, 1);
  if ((a5 & 1) != 0 || (llvm::AbstractAttribute *)v8 != v15)
  {
    uint64_t v16 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v15 + 48))(v15);
    (*(void (**)(uint64_t, void))(*(void *)a4 + 48))(a4, *(unsigned __int8 *)(v16 + 9));
  }
  else
  {
    (*(void (**)(uint64_t))(*(void *)a4 + 40))(a4);
  }
  uint64_t v17 = *(uint64_t (**)(uint64_t))(*(void *)a4 + 16);

  return v17(a4);
}

void *sub_1CC8E4B0C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E4B50(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E4BB4()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C140, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C140))
  {
    __cxa_guard_release(&qword_1EA61C140);
  }
}

uint64_t sub_1CC8E4C08(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  __int16 v8 = 256;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2620BB0;
  v12[0] = 0;
  char v13 = 0;
  int v11 = sub_1CD64DE00((llvm::IRPosition *)(a1 + 16), 0);
  v10[0] = &v11;
  v10[1] = a2;
  void v10[2] = a1;
  v10[3] = v12;
  if (llvm::Attributor::checkForAllCallSites(a2, sub_1CC8E4E40, (uint64_t)v10, a1, 1, &v9))
  {
    if (v13) {
      v7[6]((void **)&v7, v12[9]);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  uint64_t v4 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  BOOL v5 = v4[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v4 + 48))(v4, HIBYTE(v8));
  return v5 ^ (v4[9] != 0);
}

uint64_t *sub_1CC8E4DB0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E4DD8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E4E40(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v10 = *a2;
  int v11 = &v13;
  uint64_t v12 = 0;
  if (*((_DWORD *)a2 + 4))
  {
    sub_1CD41B598((uint64_t)&v11, (uint64_t)(a2 + 1));
    uint64_t v13 = v10;
    uint64_t v14 = &v16;
    uint64_t v15 = 0;
    if (v12) {
      sub_1CD41B6B0((uint64_t)&v14, (uint64_t)&v11);
    }
  }
  else
  {
    uint64_t v13 = v3;
    uint64_t v14 = &v16;
    uint64_t v15 = 0;
  }
  uint64_t v16 = sub_1CD659800((uint64_t)&v13, **(_DWORD **)a1);
  uint64_t v17 = v4;
  if (v14 != &v16) {
    free(v14);
  }
  if (sub_1CD647DEC(&v16))
  {
    BOOL v5 = sub_1CC8B9CBC(*(void *)(a1 + 8), v16, v17, *(void *)(a1 + 16), 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v7 = *(void *)(a1 + 24);
    if (*(unsigned char *)(v7 + 16))
    {
      (*(void (**)(uint64_t, void, void))(*(void *)v7 + 72))(v7, *(unsigned __int8 *)(v6 + 9), *(unsigned __int8 *)(v6 + 8));
    }
    else
    {
      *(void *)uint64_t v7 = &unk_1F26275E0;
      *(_WORD *)(v7 + 8) = *(_WORD *)(v6 + 8);
      *(void *)uint64_t v7 = &unk_1F2620BB0;
      *(unsigned char *)(v7 + 16) = 1;
    }
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (v11 != &v13) {
    free(v11);
  }
  return v8;
}

void *sub_1CC8E5014(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E5058(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E50BC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C148, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C148))
  {
    __cxa_guard_release(&qword_1EA61C148);
  }
}

uint64_t sub_1CC8E5110(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  __int16 v8 = 256;
  uint64_t v7 = (void (**)(void **, void))&unk_1F2620BB0;
  uint64_t v12 = 0;
  v10[0] = 0;
  char v11 = 0;
  v9[0] = &v12;
  v9[1] = a2;
  void v9[2] = a1;
  void v9[3] = v10;
  if (llvm::Attributor::checkForAllReturnedValues(a2, (uint64_t)sub_1CC8E5334, (uint64_t)v9, a1))
  {
    if (v11) {
      v7[6]((void **)&v7, v10[9]);
    }
  }
  else
  {
    ((void (*)(void (***)(void **, void)))v7[5])(&v7);
  }
  uint64_t v4 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  BOOL v5 = v4[9] == 0;
  (*(void (**)(unsigned char *, void))(*(void *)v4 + 48))(v4, HIBYTE(v8));
  return v5 ^ (v4[9] != 0);
}

uint64_t *sub_1CC8E52A4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E52CC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E5334(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = **(void **)a1;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 != 21)
  {
    if (v4 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v5 = v4 - 33;
      BOOL v6 = v5 > 0x33;
      uint64_t v7 = (1 << v5) & 0x8000000000041;
      if (!v6 && v7 != 0)
      {
        uint64_t v3 = 0;
        a2 |= 1uLL;
      }
    }
  }
  char v9 = sub_1CC8B9CBC(*(void *)(a1 + 8), a2, v3, *(void *)(a1 + 16), 0, 0, 1);
  uint64_t v10 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v9 + 48))(v9);
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v11 + 16))
  {
    (*(void (**)(uint64_t, void, void))(*(void *)v11 + 72))(v11, *(unsigned __int8 *)(v10 + 9), *(unsigned __int8 *)(v10 + 8));
  }
  else
  {
    *(void *)uint64_t v11 = &unk_1F26275E0;
    *(_WORD *)(v11 + 8) = *(_WORD *)(v10 + 8);
    *(void *)uint64_t v11 = &unk_1F2620BB0;
    *(unsigned char *)(v11 + 16) = 1;
  }
  uint64_t v12 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);

  return v12();
}

void *sub_1CC8E549C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E54E0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E5544()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C150, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C150))
  {
    __cxa_guard_release(&qword_1EA61C150);
  }
}

uint64_t sub_1CC8E5598(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v5 = (unsigned char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  unint64_t v6 = sub_1CD648A0C(v4);
  if (v6)
  {
    uint64_t v7 = sub_1CC8B9CBC(a2, v6 | 1, 0, a1, 0, 0, 1);
    uint64_t v8 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v7 + 48))(v7);
    BOOL v9 = v5[9] == 0;
    (*(void (**)(unsigned char *, void))(*(void *)v5 + 48))(v5, *(unsigned __int8 *)(v8 + 9));
    return v9 ^ (v5[9] != 0);
  }
  else
  {
    uint64_t v11 = *(uint64_t (**)(unsigned char *))(*(void *)v5 + 40);
    return v11(v5);
  }
}

uint64_t *sub_1CC8E56CC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E56F4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E575C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E57A0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E5804()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C158, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C158))
  {
    __cxa_guard_release(&qword_1EA61C158);
  }
}

uint64_t *sub_1CC8E5858(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E5880(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E58E8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E5938(void *a1)
{
  sub_1CD65C8DC((uint64_t)(a1 + 4));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E59AC(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  *((unsigned char *)&v23.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&v23, "PointerInfo ");
  int v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v4)
  {
    *((unsigned char *)&v19.__r_.__value_.__s + 23) = 1;
    LOWORD(v19.__r_.__value_.__l.__data_) = 35;
    std::to_string(&v18, *(_DWORD *)(a1 + 48));
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v5 = &v18;
    }
    else {
      unsigned int v5 = (std::string *)v18.__r_.__value_.__r.__words[0];
    }
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v18.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v18.__r_.__value_.__l.__size_;
    }
    uint64_t v7 = std::string::append(&v19, (const std::string::value_type *)v5, size);
    std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v20.__r_.__value_.__r.__words[2] = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    BOOL v9 = std::string::append(&v20, " bins");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    std::string::size_type v22 = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    char v11 = HIBYTE(v22);
    uint64_t v12 = (uint64_t)__p[0];
  }
  else
  {
    char v11 = 9;
    HIBYTE(v22) = 9;
    strcpy((char *)__p, "<invalid>");
    uint64_t v12 = 0x64696C61766E693CLL;
  }
  BOOL v13 = v11 < 0;
  if (v11 >= 0) {
    uint64_t v14 = __p;
  }
  else {
    uint64_t v14 = (void **)v12;
  }
  uint64_t v15 = (void *)(v11 & 0x7F);
  if (v13) {
    uint64_t v16 = __p[1];
  }
  else {
    uint64_t v16 = v15;
  }
  uint64_t v17 = std::string::append(&v23, (const std::string::value_type *)v14, (std::string::size_type)v16);
  *a2 = *v17;
  v17->__r_.__value_.__r.__words[0] = 0;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v22) < 0)
  {
    operator delete(__p[0]);
    if (!v4) {
      goto LABEL_26;
    }
  }
  else if (!v4)
  {
    goto LABEL_26;
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
LABEL_26:
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8E5B8C()
{
  return 1;
}

uint64_t sub_1CC8E5B98(void *a1, llvm::Attributor *a2)
{
  unsigned int v18 = 1;
  int v4 = a1 + 2;
  unint64_t v5 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 2));
  uint64_t v6 = *(void *)(*((void *)a2 + 11) + 120);
  v16[0] = 0;
  v16[1] = 0;
  int v17 = 0;
  v13[0] = v5;
  *sub_1CC8E671C((uint64_t)v16, v13) = 0;
  uint64_t v15 = v16;
  if (sub_1CD6482A0(v4))
  {
    uint64_t v9 = *((void *)a2 + 11);
    uint64_t v10 = *(void *)(sub_1CD6482A0(v4) + 40);
    if (**(void **)(v9 + 440) && v10 != 0) {
      llvm::AnalysisManager<llvm::Function>::getResultImpl();
    }
  }
  uint64_t v14 = 0;
  v13[0] = (uint64_t)&v15;
  v13[1] = (uint64_t)v16;
  void v13[2] = v6;
  v13[3] = v5;
  v13[4] = (uint64_t)a1;
  v13[5] = (uint64_t)a2;
  v13[6] = (uint64_t)&v18;
  v13[7] = (uint64_t)&v14;
  uint64_t v12 = v16;
  if (llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8E6788, (uint64_t)v13, (const llvm::AbstractAttribute *)a1, v5, 1, 1, 1, (uint64_t (*)(void, void, void))sub_1CC8E7384, (uint64_t)&v12))uint64_t v7 = v18; {
  else
  }
    uint64_t v7 = (*(uint64_t (**)(void *))(a1[4] + 40))(a1 + 4);
  MEMORY[0x1D25D9CD0](v16[0], 8);
  return v7;
}

uint64_t sub_1CC8E5D24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, BOOL), uint64_t a5)
{
  return sub_1CD65D174(a1 + 32, a2, a3, a4, a5);
}

uint64_t sub_1CC8E5D2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int (*a5)(uint64_t, const llvm::Value **, void), uint64_t a6)
{
  v102[16] = *MEMORY[0x1E4F143B8];
  unint64_t v80 = v84;
  char v81 = v84;
  uint64_t v82 = 8;
  int v83 = 0;
  uint64_t v100 = (const llvm::Value ***)v102;
  uint64_t v101 = 0x800000000;
  uint64_t v12 = *(void *)(*(void *)(a4 + 40) + 56);
  BOOL v13 = sub_1CC8B4D90(a2, v12, 0, a3, 1, 0, 1);
  long long __p = (unint64_t)v12;
  uint64_t v79 = sub_1CD65D328(a2, &__p, a3, 1, 0);
  char v78 = *((unsigned char *)v13 + 41);
  unsigned int v76 = &v78;
  uint64_t v77 = &v79;
  unsigned int v75 = &v76;
  uint64_t v14 = sub_1CC8B3300(a2, v12, 0, a3, 1, 0, 1);
  LOBYTE(v15) = 0;
  int v16 = *(unsigned __int8 *)(a4 + 16);
  uint64_t v17 = (v16 - 33);
  if (v17 <= 0x37)
  {
    if (((1 << (v16 - 33)) & 0x8000000000041) == 0)
    {
      if (((1 << (v16 - 33)) & 0x808001C8000010) == 0)
      {
        if (v17 != 28) {
          goto LABEL_19;
        }
        LOBYTE(v15) = (*(_WORD *)(a4 + 18) & 0x301) != 0;
        goto LABEL_18;
      }
      goto LABEL_17;
    }
    uint64_t v18 = *(void *)(a4 + 64);
    if (v18 && ((*(unsigned char *)(v18 + 20) & 4) != 0 || (*(unsigned char *)(v18 + 17) & 0x10) != 0)) {
      goto LABEL_12;
    }
    LODWORD(__p) = 7;
    if (sub_1CC5CB59C(a4, (__int32 *)&__p, 1uLL))
    {
      uint64_t v19 = *(void *)(a4 - 32);
      if (!v19 || *(unsigned char *)(v19 + 16) || *(void *)(v19 + 24) != *(void *)(a4 + 72) || *(_DWORD *)(v19 + 36) != 7)
      {
LABEL_17:
        LOBYTE(v15) = 1;
        goto LABEL_18;
      }
    }
    if (llvm::CallBase::hasFnAttrOnCalledFunction(a4, 66)) {
LABEL_12:
    }
      LOBYTE(v15) = 0;
    else {
      int v15 = llvm::CallBase::hasFnAttrOnCalledFunction(a4, 44) ^ 1;
    }
LABEL_18:
    int v16 = *(unsigned __int8 *)(a4 + 16);
  }
LABEL_19:
  char v20 = 0;
  char v74 = v15;
  uint64_t v21 = (v16 - 33);
  if (v21 <= 0x37)
  {
    if (((1 << v21) & 0x8000000000041) != 0)
    {
      uint64_t v22 = *(void *)(a4 + 64);
      if (!v22 || (*(unsigned char *)(v22 + 17) & 0x30) == 0)
      {
        int v23 = *(_DWORD *)(a4 + 20);
        if (v23 < 0)
        {
          uint64_t v64 = a4 - 32 * (v23 & 0x7FFFFFF);
          uint64_t v67 = *(void *)(v64 - 8);
          uint64_t v65 = v64 - 8;
          uint64_t v66 = v67;
          if (v67)
          {
            uint64_t v68 = -v66;
            while (1)
            {
              unsigned int v69 = *(_DWORD *)(*(void *)(v65 + v68) + 8);
              if (v69 >= 2 && v69 != 7) {
                break;
              }
              v68 += 16;
              if (!v68) {
                goto LABEL_27;
              }
            }
LABEL_23:
            char v20 = 1;
            goto LABEL_30;
          }
        }
LABEL_27:
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(a4, 45) & 1) == 0)
        {
          char v20 = llvm::CallBase::hasFnAttrOnCalledFunction(a4, 44) ^ 1;
          goto LABEL_30;
        }
      }
      char v20 = 0;
      goto LABEL_30;
    }
    if (v21 == 27)
    {
      char v20 = (*(_WORD *)(a4 + 18) & 0x301) != 0;
      goto LABEL_30;
    }
    if (((1 << v21) & 0x808001D0000010) != 0) {
      goto LABEL_23;
    }
  }
LABEL_30:
  char v73 = v20;
  BOOL v24 = *v76 || *v77 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*v77 + 112))(*v77, a4) & 1) != 0;
  BOOL v72 = v24;
  char v25 = v15 ^ 1;
  if (!*((unsigned char *)v14 + 40)) {
    char v25 = 1;
  }
  if ((v25 & 1) == 0 && **(void **)(*(void *)(a2 + 88) + 440) && *(void *)(v12 + 40) != 0) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  unint64_t v71 = 0;
  char v99 = 0;
  unint64_t v27 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (*(unsigned char *)(v27 + 16) == 59)
  {
    uint64_t v28 = *(void *)(*(void *)(v27 + 40) + 56);
    if (!*((unsigned char *)sub_1CC8B3300(a2, v28, 0, a1, 1, 0, 1) + 41)) {
      goto LABEL_61;
    }
    *(void *)&long long __p = &unk_1F2625398;
    *((void *)&__p + 1) = v28;
    p_p = &__p;
    sub_1CC8E7524(&__p, v98);
    if (p_p == &__p) {
      goto LABEL_58;
    }
    if (p_p) {
LABEL_60:
    }
      (*(void (**)(void))(*(void *)p_p + 40))();
  }
  else
  {
    unint64_t v29 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    if (*(unsigned __int8 *)(v29 + 16) <= 3u)
    {
      unint64_t v30 = v29;
      uint64_t v31 = *(void *)(v29 + 40) + 216;
      __int16 v86 = 260;
      v85[0] = v31;
      llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)v85);
      if (p_p == 25 || p_p == 30 || (p_p & 0xFFFFFFFE) == 0x2C)
      {
        unsigned int v32 = *(_DWORD *)(*(void *)v30 + 8);
        if ((v32 & 0xFE) == 0x12) {
          unsigned int v32 = *(_DWORD *)(**(void **)(*(void *)v30 + 16) + 8);
        }
        BOOL v33 = (v32 >> 8) - 3 < 3;
      }
      else
      {
        BOOL v33 = 0;
      }
      if (SHIBYTE(v88) < 0) {
        operator delete((void *)__p);
      }
      if (v33)
      {
        *(void *)&long long __p = &unk_1F26253E0;
        p_p = &__p;
        sub_1CC8E7524(&__p, v98);
        if (p_p == &__p)
        {
LABEL_58:
          (*(void (**)(long long *))(__p + 32))(&__p);
          goto LABEL_61;
        }
        if (p_p) {
          goto LABEL_60;
        }
      }
    }
  }
LABEL_61:
  *(void *)&long long __p = &v74;
  *((void *)&__p + 1) = &v73;
  unint64_t v88 = &v72;
  p_p = (long long *)a2;
  uint64_t v90 = a4;
  uint64_t v91 = a3;
  unsigned int v92 = v98;
  unint64_t v93 = &v71;
  uint64_t v94 = v12;
  unint64_t v95 = &v75;
  unsigned int v96 = &v80;
  unsigned int v97 = (void **)&v100;
  if (!sub_1CD65D474(a1 + 32, a4, (uint64_t (*)(uint64_t, uint64_t, BOOL))sub_1CC8E79A4, (uint64_t)&__p))
  {
    uint64_t v62 = 0;
    goto LABEL_131;
  }
  if (v72)
  {
    unsigned int v34 = v101;
    if (v101)
    {
      int v35 = v100;
      long long v36 = (char *)&v100[2 * v101];
      while (1)
      {
        if (v71) {
          BOOL v37 = dword_1EBCDE1E8 >= v34;
        }
        else {
          BOOL v37 = 0;
        }
        if (v37)
        {
          uint64_t v38 = *v35;
          if (**v75
            || (uint64_t v44 = *(void *)v75[1]) != 0
            && (*(unsigned int (**)(uint64_t, const llvm::Value *))(*(void *)v44 + 112))(v44, *v38))
          {
            int v39 = v80;
            long long v40 = v81;
            if (v81 == v80)
            {
              unsigned int v41 = HIDWORD(v82);
              unint64_t v42 = &v81[8 * HIDWORD(v82)];
              if (HIDWORD(v82))
              {
                uint64_t v43 = 0;
                while (*(const llvm::Value ***)&v81[v43] != v38)
                {
                  v43 += 8;
                  if (8 * HIDWORD(v82) == v43) {
                    goto LABEL_93;
                  }
                }
                unint64_t v42 = &v81[v43];
              }
LABEL_93:
              int v39 = v81;
            }
            else
            {
              int v45 = v82 - 1;
              unsigned int v46 = (v82 - 1) & ((v38 >> 4) ^ (v38 >> 9));
              unint64_t v42 = &v81[8 * v46];
              int64_t v47 = *(const llvm::Value ***)v42;
              if (*(void *)v42 == -1)
              {
                uint64_t v48 = 0;
LABEL_115:
                if (v48) {
                  unint64_t v42 = v48;
                }
                unsigned int v41 = HIDWORD(v82);
                if (*(const llvm::Value ***)v42 != v38) {
                  unint64_t v42 = &v81[8 * v82];
                }
              }
              else
              {
                uint64_t v48 = 0;
                int v49 = 1;
                while (v47 != v38)
                {
                  if (v48) {
                    BOOL v50 = 0;
                  }
                  else {
                    BOOL v50 = v47 == (const llvm::Value **)-2;
                  }
                  if (v50) {
                    uint64_t v48 = v42;
                  }
                  unsigned int v51 = v46 + v49++;
                  unsigned int v46 = v51 & v45;
                  unint64_t v42 = &v81[8 * (v51 & v45)];
                  int64_t v47 = *(const llvm::Value ***)v42;
                  if (*(void *)v42 == -1) {
                    goto LABEL_115;
                  }
                }
                unsigned int v41 = HIDWORD(v82);
              }
            }
            uint64_t v52 = v81 == v39 ? v41 : v82;
            unsigned int v53 = &v81[8 * v52];
            if (v42 != v53)
            {
              if (v52)
              {
                uint64_t v54 = 8 * v52;
                while (*(void *)v40 >= 0xFFFFFFFFFFFFFFFELL)
                {
                  v40 += 8;
                  v54 -= 8;
                  if (!v54) {
                    goto LABEL_111;
                  }
                }
              }
              if (v40 != v53)
              {
                int v55 = *(const llvm::Instruction ***)v40;
LABEL_105:
                if (v55 != v38 && (llvm::DominatorTree::dominates(v71, *v38, *v55) & 1) != 0) {
                  goto LABEL_112;
                }
                unsigned int v56 = (unint64_t *)(v40 + 8);
                while (v56 != (unint64_t *)v53)
                {
                  unint64_t v57 = *v56++;
                  int v55 = (const llvm::Instruction **)v57;
                  if (v57 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    long long v40 = (char *)(v56 - 1);
                    goto LABEL_105;
                  }
                }
              }
            }
          }
        }
LABEL_111:
        if (!a5(a6, *v35, *((unsigned __int8 *)v35 + 8)))
        {
          uint64_t v62 = 0;
          goto LABEL_131;
        }
LABEL_112:
        v35 += 2;
        if (v35 == (const llvm::Value ***)v36)
        {
          uint64_t v62 = 1;
          goto LABEL_131;
        }
      }
    }
LABEL_129:
    uint64_t v62 = 1;
    goto LABEL_131;
  }
  if (!v101) {
    goto LABEL_129;
  }
  unsigned int v58 = (char *)v100;
  uint64_t v59 = (char *)&v100[2 * v101];
  do
  {
    uint64_t v60 = ((uint64_t (*)(uint64_t, void, void))a5)(a6, *(void *)v58, v58[8]);
    v58 += 16;
    if (v60) {
      BOOL v61 = v58 == v59;
    }
    else {
      BOOL v61 = 1;
    }
  }
  while (!v61);
  uint64_t v62 = v60;
LABEL_131:
  if (v99 == v98)
  {
    (*(void (**)(void *))(v98[0] + 32))(v98);
  }
  else if (v99)
  {
    (*(void (**)(void))(*v99 + 40))();
  }
  if (v100 != v102) {
    free(v100);
  }
  if (v81 != v80) {
    free(v81);
  }
  return v62;
}

uint64_t *sub_1CC8E6658(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  uint64_t v2 = (uint64_t *)(v1 - 24);

  return sub_1CD64E248(v2);
}

void sub_1CC8E66AC(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(v1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E671C(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CC4EB2E8(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0xFFFFFFFF80000000;
  }
  return v5 + 1;
}

uint64_t sub_1CC8E6788(uint64_t a1, unint64_t a2, unsigned char *a3)
{
  v97[8] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *(const llvm::AbstractAttribute **)(a1 + 32);
  uint64_t v6 = *(llvm::GlobalValue **)a2;
  unint64_t v93 = *(llvm::GlobalValue **)a2;
  uint64_t v7 = *(void **)(a2 + 24);
  unsigned int v8 = *((unsigned __int8 *)v7 + 16);
  if (v7) {
    BOOL v9 = v8 == 5;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    int v18 = *((unsigned __int16 *)v7 + 9);
    if ((v18 - 38) <= 0xC)
    {
LABEL_24:
      uint64_t v19 = *(uint64_t **)a1;
      uint64_t v20 = *sub_1CC8E671C(*(void *)(a1 + 8), (uint64_t *)&v93);
      unint64_t v95 = v7;
      *sub_1CC8E671C(*v19, (uint64_t *)&v95) = v20;
      goto LABEL_36;
    }
    if ((v18 - 53) < 2) {
      return 1;
    }
    if (v18 != 34) {
      return 0;
    }
    goto LABEL_28;
  }
  if (v8 == 62 || v8 == 5 && *((_WORD *)v7 + 9) == 34)
  {
LABEL_28:
    uint64_t v22 = *(void *)(a1 + 8);
    unint64_t v95 = *(void **)(a2 + 24);
    int v23 = sub_1CC8E671C(v22, (uint64_t *)&v95);
    BOOL v24 = sub_1CC8E671C(*(void *)(a1 + 8), (uint64_t *)&v93);
    void *v23 = *v24;
    uint64_t v25 = *v24;
    if (*v24 == 0xFFFFFFFF80000000)
    {
LABEL_35:
      void *v23 = 0xFFFFFFFF80000000;
      goto LABEL_36;
    }
    int v26 = *((_DWORD *)v7 + 5);
    if ((v26 & 0x40000000) != 0)
    {
      uint64_t v28 = (void *)*(v7 - 1);
      uint64_t v27 = v26 & 0x7FFFFFF;
    }
    else
    {
      uint64_t v27 = v26 & 0x7FFFFFF;
      uint64_t v28 = &v7[-4 * v27];
    }
    unint64_t v29 = v28 + 4;
    uint64_t v30 = 32 * v27 - 32;
    uint64_t v31 = v30;
    while (v31)
    {
      uint64_t v32 = *v29;
      v29 += 4;
      v31 -= 32;
      if (*(unsigned char *)(v32 + 16) != 16) {
        goto LABEL_35;
      }
    }
    unint64_t v95 = v97;
    uint64_t v96 = 0x800000000;
    if ((v26 & 0x40000000) != 0) {
      unsigned int v34 = (void *)*(v7 - 1);
    }
    else {
      unsigned int v34 = &v7[-4 * v27];
    }
    if (v27 == 1)
    {
      uint64_t v37 = 0;
      uint64_t v38 = (const llvm::Value **)v97;
    }
    else
    {
      LODWORD(v37) = 0;
      int v39 = v34 + 4;
      do
      {
        if (*v39) {
          BOOL v40 = *(unsigned char *)(*v39 + 16) == 16;
        }
        else {
          BOOL v40 = 0;
        }
        if (!v40)
        {
          uint64_t v21 = 0;
          goto LABEL_72;
        }
        if (v37 >= HIDWORD(v96)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v95 + v37) = *v39;
        uint64_t v37 = (v96 + 1);
        LODWORD(v96) = v96 + 1;
        v39 += 4;
        v30 -= 32;
      }
      while (v30);
      uint64_t v25 = *v24;
      uint64_t v38 = (const llvm::Value **)v95;
    }
    BOOL v48 = *((unsigned char *)v7 + 16) != 62 || v7 == 0;
    uint64_t v49 = 8;
    if (v48) {
      uint64_t v49 = 3;
    }
    void *v23 = llvm::DataLayout::getIndexedOffsetInType(*(llvm::DataLayout **)(a1 + 16), v7[v49], v38, v37) + v25;
    uint64_t v21 = 1;
    *a3 = 1;
LABEL_72:
    if (v95 != v97) {
      free(v95);
    }
    return v21;
  }
  BOOL v12 = v8 > 0x1B && v8 - 66 < 0xD;
  if (v8 == 85 || v12) {
    goto LABEL_24;
  }
  if (v8 == 83)
  {
    uint64_t v14 = *(void *)(a1 + 8);
    unint64_t v95 = *(void **)(a2 + 24);
    int v15 = sub_1CC8E671C(v14, (uint64_t *)&v95);
    int v16 = sub_1CC8E671C(*(void *)(a1 + 8), (uint64_t *)&v93);
    if (*v15 != *v16)
    {
      if (*v16 == 0xFFFFFFFF80000000)
      {
        void *v15 = 0xFFFFFFFF80000000;
LABEL_36:
        uint64_t v21 = 1;
        *a3 = 1;
        return v21;
      }
      uint64_t v67 = v16;
      uint64_t v68 = *(void *)(a1 + 16);
      unsigned int v69 = *(_DWORD *)(*(void *)v6 + 8);
      if ((v69 & 0xFE) == 0x12) {
        unsigned int v69 = *(_DWORD *)(**(void **)(*(void *)v6 + 16) + 8);
      }
      if (v69 < 0x100) {
        goto LABEL_106;
      }
      unsigned int v70 = v69 >> 8;
      uint64_t v71 = *(unsigned int *)(v68 + 240);
      uint64_t v72 = *(void *)(v68 + 232);
      if (v71)
      {
        uint64_t v72 = *(void *)(v68 + 232);
        unint64_t v73 = *(unsigned int *)(v68 + 240);
        do
        {
          unint64_t v74 = v73 >> 1;
          uint64_t v75 = v72 + 16 * (v73 >> 1);
          unsigned int v76 = *(_DWORD *)(v75 + 8);
          uint64_t v77 = v75 + 16;
          v73 += ~(v73 >> 1);
          if (v76 < v70) {
            uint64_t v72 = v77;
          }
          else {
            unint64_t v73 = v74;
          }
        }
        while (v73);
      }
      if (v72 == *(void *)(v68 + 232) + 16 * v71 || *(_DWORD *)(v72 + 8) != v70) {
LABEL_106:
      }
        uint64_t v72 = *(void *)(v68 + 232);
      LODWORD(v96) = *(_DWORD *)(v72 + 12);
      if (v96 > 0x40) {
        operator new[]();
      }
      unint64_t v95 = 0;
      char v78 = *(llvm::GlobalValue **)(a1 + 24);
      uint64_t v21 = 1;
      if (v78 == llvm::Value::stripAndAccumulateConstantOffsets(v6, (llvm::DataLayout *)v68, (llvm::APInt *)&v95, 1, 0, 0, v17))
      {
        uint64_t v79 = *v67;
        if (v96 >= 0x41)
        {
          int v81 = 0;
          unint64_t v80 = v95;
          int64_t v82 = ((unint64_t)v96 + 63) >> 6;
          do
          {
            BOOL v45 = v82-- < 1;
            if (v45) {
              break;
            }
            unint64_t v83 = *((void *)v95 + v82);
            v81 += __clz(v83);
          }
          while (!v83);
          uint64_t v21 = 0;
          int v84 = v96 | 0xFFFFFFC0;
          if ((v96 & 0x3F) == 0) {
            int v84 = 0;
          }
          if ((v96 - v81 - v84) > 0x40) {
            goto LABEL_111;
          }
        }
        else
        {
          unint64_t v80 = &v95;
        }
        if (*v80 != v79)
        {
          uint64_t v21 = 0;
          goto LABEL_111;
        }
        unsigned int v85 = *(uint64_t **)a1;
        *(void *)uint64_t v94 = v7;
        *sub_1CC8E671C(*v85, (uint64_t *)v94) = v79;
        uint64_t v21 = 1;
      }
      else
      {
        void *v15 = 0xFFFFFFFF80000000;
      }
      *a3 = 1;
LABEL_111:
      if (v96 >= 0x41 && v95) {
        MEMORY[0x1D25D9CB0](v95, 0x1000C8000313F17);
      }
      return v21;
    }
    return 1;
  }
  if (v7 && v8 == 60)
  {
    uint64_t v35 = *(void *)(a1 + 40);
    long long v36 = sub_1CC8E671C(*(void *)(a1 + 8), (uint64_t *)&v93);
    uint64_t v21 = 1;
    sub_1CC8E6F70((uint64_t)v5, v35, (uint64_t)v7, 0, 1, 1, *v36, *(int **)(a1 + 48), *v7);
    return v21;
  }
  if (v7 && v8 == 61)
  {
    unint64_t v41 = *(v7 - 8);
    if ((llvm::GlobalValue *)v41 != v6)
    {
      v94[0] = 0;
      unint64_t v42 = *(llvm::Attributor **)(a1 + 40);
      unsigned int v43 = *(unsigned __int8 *)(v41 + 16);
      if (v43 != 21)
      {
        if (v43 < 0x1C)
        {
          if (!*(unsigned char *)(v41 + 16)) {
            v41 |= 2uLL;
          }
        }
        else
        {
          unsigned int v44 = v43 - 33;
          BOOL v45 = v44 > 0x33;
          uint64_t v46 = (1 << v44) & 0x8000000000041;
          if (!v45 && v46 != 0) {
            v41 |= 1uLL;
          }
        }
      }
      unint64_t v95 = (void *)v41;
      uint64_t v96 = 0;
      unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(v42, (const llvm::IRPosition *)&v95, v5, v94);
      uint64_t v88 = v87;
      uint64_t v89 = *(void *)(a1 + 40);
      uint64_t v90 = sub_1CC8E671C(*(void *)(a1 + 8), (uint64_t *)&v93);
      sub_1CC8E6F70((uint64_t)v5, v89, (uint64_t)v7, AssumedSimplified, v88, 2, *v90, *(int **)(a1 + 48), *(void *)*(v7 - 8));
      return 1;
    }
    return 0;
  }
  if (v8 < 0x1C) {
    return 0;
  }
  unsigned int v50 = v8 - 33;
  BOOL v45 = v50 > 0x33;
  uint64_t v51 = (1 << v50) & 0x8000000000041;
  if (v45 || v51 == 0) {
    return 0;
  }
  if (llvm::Instruction::isLifetimeStartOrEnd(*(llvm::Instruction **)(a2 + 24))) {
    return 1;
  }
  unsigned int v53 = **(uint64_t ***)(a1 + 56);
  if (v53)
  {
    v94[0] = 0;
    uint64_t v54 = (uint64_t ***)sub_1CC0960E8((uint64_t)v7, v94);
    if (v54)
    {
      if (!v94[0])
      {
        uint64_t v91 = (llvm::Function *)v54;
        LODWORD(v95) = 0;
        if (llvm::TargetLibraryInfoImpl::getLibFunc(*v53, v54, &v95)
          && ((*(void *)(v53[1] + (((unint64_t)v95 >> 3) & 0x1FFFFFF8)) >> (char)v95) & 1) == 0
          && ((*(unsigned __int8 *)(*v53 + ((unint64_t)v95 >> 2)) >> (2 * (v95 & 3))) & 3) != 0
          && llvm::isLibFreeFunction(v91, (int)v95)
          && *((unsigned char *)v7 + 16) == 84)
        {
          return 1;
        }
      }
    }
  }
  int v55 = *((_DWORD *)v7 + 5);
  unsigned int v56 = &v7[-4 * (v55 & 0x7FFFFFF)];
  if ((unint64_t)v56 > a2) {
    return 0;
  }
  int v57 = *((unsigned __int8 *)v7 + 16);
  if (v57 == 84) {
    uint64_t v58 = 0;
  }
  else {
    uint64_t v58 = v57 == 39 ? (*((_DWORD *)v7 + 20) + 1) : 2;
  }
  if (v55 < 0 && (uint64_t v92 = *(v56 - 1), (v92 & 0xFFFFFFFF0) != 0)) {
    uint64_t v59 = (*((_DWORD *)v56 - 3) - *(_DWORD *)((char *)v56 - v92));
  }
  else {
    uint64_t v59 = 0;
  }
  if ((unint64_t)&v7[-4 * v58 - 4 + -4 * v59] <= a2) {
    return 0;
  }
  unint64_t v60 = a2 - (void)v56;
  if ((v55 & 0x40000000) != 0) {
    unsigned int v56 = (void *)*(v7 - 1);
  }
  uint64_t v21 = 1;
  BOOL v61 = sub_1CC8B5800(*(void *)(a1 + 40), ((unint64_t)v56 + (v60 & 0x1FFFFFFFE0)) | 3, 0, (uint64_t)v5, 0, 0, 1);
  uint64_t v62 = *(llvm::Attributor **)(a1 + 40);
  uint64_t v63 = sub_1CC8E671C(*(void *)(a1 + 8), (uint64_t *)&v93);
  int v64 = sub_1CC8E7048(v5, v62, (uint64_t)v61, *v63, (uint64_t)v7);
  uint64_t v65 = *(int **)(a1 + 48);
  int v66 = *v65;
  if (!v64) {
    int v66 = 0;
  }
  *uint64_t v65 = v66;
  return v21;
}

void sub_1CC8E6F70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int *a8, uint64_t a9)
{
  int v11 = a6;
  unint64_t v17 = 0xFFFFFFFF80000000;
  if (a7 != 0xFFFFFFFF80000000 && a9 != 0)
  {
    uint64_t v20 = sub_1CB83544C(*(void *)(*(void *)(a2 + 88) + 120), a9);
    int v11 = a6;
    if (v21 != 1) {
      unint64_t v17 = (unint64_t)(v20 + 7) >> 3;
    }
  }
  int v22 = *a8;
  sub_1CD65CA58(a1 + 32, a2, a7, v17, a3, a4, a5, v11, a9, 0, 0);
  if (v22) {
    int v24 = v23;
  }
  else {
    int v24 = 0;
  }
  *a8 = v24;
}

uint64_t sub_1CC8E7048(const llvm::AbstractAttribute *a1, llvm::Attributor *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48))(a3);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v10 + 16))(v10)
    || ((*(uint64_t (**)(void *))(*((void *)a1 + 4) + 16))((void *)a1 + 4) & 1) == 0)
  {
    int v11 = *(uint64_t (**)(char *))(*((void *)a1 + 4) + 40);
    return v11((char *)a1 + 32);
  }
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a3 + 16));
  if (*(unsigned char *)(*(void *)AssociatedArgument + 8) == 15
    && (uint64_t v14 = *(void *)(*(void *)(AssociatedArgument + 24) + 112)) != 0
    && (unsigned int v15 = *(_DWORD *)(AssociatedArgument + 32) + 2, v15 < *(_DWORD *)(v14 + 8))
    && (uint64_t v35 = *(void *)(v14 + 8 * v15 + 40)) != 0)
  {
    int v16 = (*(unsigned __int8 *)(v35 + 20) >> 5) & 1;
  }
  else
  {
    int v16 = 0;
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48))(a3);
  int v18 = sub_1CD65C9B4(v17 + 8);
  uint64_t v37 = *(void *)(v17 + 8) + 24 * *(unsigned int *)(v17 + 24);
  if ((void *)v37 != v18)
  {
    uint64_t v20 = v18;
    int v21 = v19;
    uint64_t v36 = a4;
    uint64_t v22 = 1;
    while (1)
    {
      int64x2_t v42 = vdupq_n_s64(0xFFFFFFFF80000000);
      *(void *)&long long v39 = 0xFFFFFFFF80000000;
      *((void *)&v39 + 1) = 0xFFFFFFFF80000000;
      if (a4 != 0xFFFFFFFF80000000)
      {
        *(void *)&long long v39 = *v20 + a4;
        *((void *)&v39 + 1) = v20[1];
        int64x2_t v42 = (int64x2_t)v39;
      }
      int v23 = sub_1CD65CC84((uint64_t)a1 + 40, v42.i64);
      int v24 = (unsigned int *)v20[2];
      uint64_t v25 = v24[2];
      if (v25) {
        break;
      }
LABEL_25:
      v20 += 3;
      if (v20 == v21)
      {
        uint64_t v20 = v21;
        a4 = v36;
      }
      else
      {
        a4 = v36;
        while (1)
        {
          uint64_t v32 = v20[1];
          if ((*v20 != 0x7FFFFFFFFFFFFFFFLL || v32 != 0x7FFFFFFFFFFFFFFFLL)
            && (*v20 != 0x8000000000000000 || v32 != 0x8000000000000000))
          {
            break;
          }
          v20 += 3;
          if (v20 == v21)
          {
            uint64_t v20 = v21;
            break;
          }
        }
      }
      if (v20 == (void *)v37) {
        return v22;
      }
    }
    uint64_t v38 = v23[2];
    uint64_t v26 = 48 * v25;
    uint64_t v27 = (uint64_t *)(*(void *)v24 + 40);
    while (v16)
    {
      if (*(unsigned char *)(v27 - 1))
      {
        int v40 = v22;
        int v28 = 1;
LABEL_22:
        BOOL v41 = 0;
        unint64_t v29 = llvm::Attributor::translateArgumentToCallSiteContent(a2, (llvm::Argument *)*(v27 - 3), *(v27 - 2), a5, a1, &v41);
        sub_1CD65CA58((uint64_t)a1 + 32, (uint64_t)a2, v39, *((uint64_t *)&v39 + 1), a5, v29, v30, *(_DWORD *)(v27 - 1) & v28, *v27, *(v27 - 4), v38);
        if (v40) {
          uint64_t v22 = v31;
        }
        else {
          uint64_t v22 = 0;
        }
      }
      v27 += 6;
      v26 -= 48;
      if (!v26) {
        goto LABEL_25;
      }
    }
    int v40 = v22;
    int v28 = 3;
    goto LABEL_22;
  }
  return 1;
}

BOOL sub_1CC8E7384(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = *a1;
  int v7 = *(_DWORD *)(v6 + 16);
  if (v7)
  {
    int v8 = v7 - 1;
    unsigned int v9 = ((*a3 >> 4) ^ (*a3 >> 9)) & v8;
    uint64_t v10 = *(void *)(*(void *)v6 + 16 * v9);
    if (v10 == *a3)
    {
LABEL_3:
      uint64_t v19 = *a3;
      int v11 = sub_1CC8E671C(v6, &v19);
      uint64_t v12 = *a1;
      uint64_t v18 = *a2;
      return *v11 == *sub_1CC8E671C(v12, &v18);
    }
    int v14 = 1;
    while (v10 != -4096)
    {
      unsigned int v15 = v9 + v14++;
      unsigned int v9 = v15 & v8;
      uint64_t v10 = *(void *)(*(void *)v6 + 16 * v9);
      if (v10 == *a3) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v19 = *a2;
  int v16 = sub_1CC8E671C(v6, &v19);
  uint64_t v17 = *a1;
  uint64_t v18 = *a3;
  *sub_1CC8E671C(v17, &v18) = *v16;
  return 1;
}

void sub_1CC8E748C()
{
}

void *sub_1CC8E74A0(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *unint64_t result = &unk_1F2625398;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC8E74E8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2625398;
  a2[1] = v2;
  return result;
}

BOOL sub_1CC8E7514(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 8) != a2;
}

void *sub_1CC8E7524(void *result, void *a2)
{
  void v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    char v4 = (void *)result[3];
    unint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        unint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        unint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      unint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1CC8E7790()
{
}

void *sub_1CC8E77A4()
{
  unint64_t result = operator new(0x10uLL);
  *unint64_t result = &unk_1F26253E0;
  return result;
}

void sub_1CC8E77DC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26253E0;
}

uint64_t sub_1CC8E7804(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  if (v2)
  {
    if (*(_DWORD *)(v2 + 8))
    {
      uint64_t v3 = *(void *)(v2 + 40);
      if (v3)
      {
        int v4 = *(_DWORD *)(v3 + 40);
        if (v4)
        {
          uint64_t v5 = *(void *)(v3 + 24);
          uint64_t v6 = &unk_1EBCBE000;
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
          {
            uint64_t v19 = v5;
            int v18 = v4;
            int v16 = __cxa_guard_acquire(&qword_1EBCBE588);
            uint64_t v6 = &unk_1EBCBE000;
            int v4 = v18;
            uint64_t v5 = v19;
            if (v16)
            {
              unint64_t v17 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v17 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v17;
              __cxa_guard_release(&qword_1EBCBE588);
              uint64_t v6 = (void *)&unk_1EBCBE000;
              int v4 = v18;
              uint64_t v5 = v19;
            }
          }
          unint64_t v7 = 0x9DDFEA08EB382D69
             * ((0x9DDFEA08EB382D69 * (v6[176] ^ 0x31FF6452CLL)) ^ ((0x9DDFEA08EB382D69 * (v6[176] ^ 0x31FF6452CLL)) >> 47) ^ v6[176] ^ 0x6C656E72);
          unsigned int v8 = -348639895 * ((v7 >> 47) ^ v7);
          int v9 = v4 - 1;
          for (int i = 1; ; ++i)
          {
            unsigned int v11 = v8 & v9;
            uint64_t v12 = (uint64_t *)(v5 + 24 * v11);
            uint64_t v13 = *v12;
            if (*v12 == -1)
            {
              if ("kernel" == (char *)-1) {
                return 0;
              }
            }
            else if (v13 == -2)
            {
              if ("kernel" == (char *)-2) {
                return 0;
              }
            }
            else if (v12[1] == 6 && *(_DWORD *)v13 == 1852990827 && *(_WORD *)(v13 + 4) == 27749)
            {
              return 0;
            }
            if (v13 == -1) {
              return 1;
            }
            unsigned int v8 = i + v11;
          }
        }
      }
    }
  }
  return 1;
}

uint64_t sub_1CC8E79A4(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!**(unsigned char **)a1 || (int v6 = a2[8], (v6 & 2) == 0))
  {
    if (!**(unsigned char **)(a1 + 8)) {
      return 1;
    }
    int v6 = a2[8];
    if ((v6 & 1) == 0) {
      return 1;
    }
  }
  if (!**(unsigned char **)(a1 + 16)) {
    goto LABEL_28;
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v7 = *(void *)a2;
    uint64_t v8 = *(void *)(a1 + 24);
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 40);
    sub_1CB93141C((uint64_t)v43, *(void *)(a1 + 48));
    if (llvm::AA::isPotentiallyReachable(v8, v7, v9, v10, (uint64_t)v43))
    {
      char v11 = 0;
      goto LABEL_19;
    }
    if ((a2[8] & 1) == 0)
    {
      char v11 = 1;
      goto LABEL_19;
    }
  }
  else if ((v6 & 1) == 0)
  {
    return 1;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v14 = *(void *)a2;
  uint64_t v15 = *(void *)(a1 + 40);
  sub_1CB93141C((uint64_t)v41, *(void *)(a1 + 48));
  char v11 = llvm::AA::isPotentiallyReachable(v12, v13, v14, v15, (uint64_t)v41) ^ 1;
  if (v42 == v41)
  {
    (*(void (**)(void *))(v41[0] + 32))(v41);
    if ((v6 & 2) == 0) {
      goto LABEL_22;
    }
  }
  else
  {
    if (v42) {
      (*(void (**)(void))(*v42 + 40))();
    }
    if ((v6 & 2) == 0)
    {
LABEL_22:
      if (v11) {
        return 1;
      }
      goto LABEL_25;
    }
  }
LABEL_19:
  if (v44 != v43)
  {
    if (v44) {
      (*(void (**)(void))(*v44 + 40))();
    }
    goto LABEL_22;
  }
  (*(void (**)(void *))(v43[0] + 32))(v43);
  if (v11) {
    return 1;
  }
LABEL_25:
  int v16 = **(llvm::DominatorTree ***)(a1 + 56);
  if (!v16) {
    goto LABEL_28;
  }
  if (!a3) {
    goto LABEL_28;
  }
  unint64_t v17 = *(const llvm::Value **)a2;
  if (*(void *)(*(void *)(*(void *)a2 + 40) + 56) != *(void *)(a1 + 64)) {
    goto LABEL_28;
  }
  uint64_t v22 = **(void **)(a1 + 72);
  if (!**(unsigned char **)v22)
  {
    uint64_t v30 = **(void **)(v22 + 8);
    if (!v30 || !(*(unsigned int (**)(uint64_t))(*(void *)v30 + 112))(v30)) {
      goto LABEL_28;
    }
    unint64_t v17 = *(const llvm::Value **)a2;
    int v16 = **(llvm::DominatorTree ***)(a1 + 56);
  }
  if (llvm::DominatorTree::dominates(v16, v17, *(const llvm::Instruction **)(a1 + 32)))
  {
    uint64_t v23 = *(void *)(a1 + 80);
    uint64_t v24 = *(void *)(v23 + 8);
    uint64_t v25 = *(unsigned int *)(v23 + 20);
    if (v24 == *(void *)v23)
    {
      if (v25)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 8 * v25;
        int v28 = *(void **)(v23 + 8);
        while ((_DWORD *)*v28 != a2)
        {
          if (*v28 == -2) {
            uint64_t v26 = v28;
          }
          ++v28;
          v27 -= 8;
          if (!v27)
          {
            if (!v26) {
              goto LABEL_41;
            }
            *uint64_t v26 = a2;
            --*(_DWORD *)(v23 + 24);
            goto LABEL_28;
          }
        }
        goto LABEL_28;
      }
LABEL_41:
      unsigned int v29 = *(_DWORD *)(v23 + 16);
      if (v25 < v29)
      {
        *(_DWORD *)(v23 + 20) = v25 + 1;
        *(void *)(v24 + 8 * v25) = a2;
        goto LABEL_28;
      }
    }
    else
    {
      unsigned int v29 = *(_DWORD *)(v23 + 16);
    }
    if (3 * v29 <= 4 * ((int)v25 - *(_DWORD *)(v23 + 24)))
    {
      if (v29 >= 0x40) {
        v29 *= 2;
      }
      else {
        unsigned int v29 = 128;
      }
    }
    else if (v29 - v25 >= v29 >> 3)
    {
      goto LABEL_49;
    }
    uint64_t v40 = *(void *)(a1 + 80);
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v23, v29);
    uint64_t v23 = v40;
    unsigned int v29 = *(_DWORD *)(v40 + 16);
    uint64_t v24 = *(void *)(v40 + 8);
LABEL_49:
    unsigned int v31 = v29 - 1;
    unsigned int v32 = (v29 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    BOOL v33 = (void *)(v24 + 8 * v32);
    unsigned int v34 = (_DWORD *)*v33;
    if (*v33 == -1)
    {
      uint64_t v35 = 0;
LABEL_61:
      if (v35) {
        long long v39 = v35;
      }
      else {
        long long v39 = v33;
      }
      if ((_DWORD *)*v39 != a2)
      {
        if (*v39 == -2) {
          --*(_DWORD *)(v23 + 24);
        }
        else {
          ++*(_DWORD *)(v23 + 20);
        }
        *long long v39 = a2;
      }
    }
    else
    {
      uint64_t v35 = 0;
      int v36 = 1;
      while (v34 != a2)
      {
        if (v35) {
          BOOL v37 = 0;
        }
        else {
          BOOL v37 = v34 == (_DWORD *)-2;
        }
        if (v37) {
          uint64_t v35 = v33;
        }
        unsigned int v38 = v32 + v36++;
        unsigned int v32 = v38 & v31;
        BOOL v33 = (void *)(v24 + 8 * (v38 & v31));
        unsigned int v34 = (_DWORD *)*v33;
        if (*v33 == -1) {
          goto LABEL_61;
        }
      }
    }
  }
LABEL_28:
  uint64_t v18 = *(void *)(a1 + 88);
  unsigned int v19 = *(_DWORD *)(v18 + 8);
  if (v19 >= *(_DWORD *)(v18 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v20 = (void *)(*(void *)v18 + 16 * v19);
  *uint64_t v20 = a2;
  v20[1] = a3;
  ++*(_DWORD *)(v18 + 8);
  return 1;
}

void *sub_1CC8E7DF4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E7E44(void *a1)
{
  sub_1CD65C8DC((uint64_t)(a1 + 4));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8E7EB4(uint64_t a1)
{
  unint64_t result = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (result && *(unsigned char *)(result + 16) == 3)
  {
    if ((*(_DWORD *)(result + 20) & 0x7FFFFFF) != 0) {
      return result;
    }
    goto LABEL_4;
  }
  if (!*(unsigned char *)(result + 16) && *(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0) {
LABEL_4:
  }
    *(unsigned char *)(a1 + 73) = *(unsigned char *)(a1 + 72);
  return result;
}

uint64_t *sub_1CC8E7F24(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  uint64_t v2 = (uint64_t *)(v1 - 24);

  return sub_1CD64E248(v2);
}

void sub_1CC8E7F78(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(v1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E7FE4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E8034(void *a1)
{
  sub_1CD65C8DC((uint64_t)(a1 + 4));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E80A8(uint64_t a1)
{
  *(unsigned char *)(a1 + 73) = *(unsigned char *)(a1 + 72);
  return 0;
}

uint64_t *sub_1CC8E80B8(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  uint64_t v2 = (uint64_t *)(v1 - 24);

  return sub_1CD64E248(v2);
}

void sub_1CC8E810C(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(v1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E8178(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E81C8(void *a1)
{
  sub_1CD65C8DC((uint64_t)(a1 + 4));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CC8E823C(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  uint64_t v2 = (uint64_t *)(v1 - 24);

  return sub_1CD64E248(v2);
}

void sub_1CC8E8290(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(v1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E82FC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E834C(void *a1)
{
  sub_1CD65C8DC((uint64_t)(a1 + 4));
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

double sub_1CC8E83C0(uint64_t a1, llvm::Attributor *a2)
{
  int v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v5 = sub_1CC8AB830((_DWORD *)(a1 + 16));
  if (v5)
  {
    uint64_t v6 = v5;
    if (sub_1CBFB3AB0(v5))
    {
      uint64_t v11 = *(void *)(v6 - 32 * (*(_DWORD *)(v6 + 20) & 0x7FFFFFF) + 64);
      if (v11) {
        BOOL v12 = *(unsigned char *)(v11 + 16) == 16;
      }
      else {
        BOOL v12 = 0;
      }
      if (v12)
      {
        unsigned int v14 = *(_DWORD *)(v11 + 32);
        if (v14 > 0x40) {
          unint64_t v13 = **(void **)(v11 + 24);
        }
        else {
          unint64_t v13 = (uint64_t)(*(void *)(v11 + 24) << -(char)v14) >> -(char)v14;
        }
      }
      else
      {
        unint64_t v13 = 0xFFFFFFFF80000000;
      }
      sub_1CD6482F0(v4);
      int v15 = sub_1CD64DE00(v4, 0);
      if (v15 == 1)
      {
        *(void *)&double result = sub_1CD65CA58(a1 + 32, (uint64_t)a2, 0, v13, v6, 0, 1, 1, 0, 0, 0).n128_u64[0];
        return result;
      }
      if (!v15)
      {
        *(void *)&double result = sub_1CD65CA58(a1 + 32, (uint64_t)a2, 0, v13, v6, 0, 1, 2, 0, 0, 0).n128_u64[0];
        return result;
      }
LABEL_17:
      *(unsigned char *)(a1 + 73) = *(unsigned char *)(a1 + 72);
      return result;
    }
  }
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument(v4);
  if (!AssociatedArgument) {
    goto LABEL_17;
  }
  uint64_t v9 = sub_1CC8B5800((uint64_t)a2, AssociatedArgument, 0, a1, 0, 0, 1);
  unint64_t v10 = sub_1CC8AB830(v4);

  sub_1CC8E7048((const llvm::AbstractAttribute *)a1, a2, (uint64_t)v9, 0, v10);
  return result;
}

uint64_t *sub_1CC8E8564(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  uint64_t v2 = (uint64_t *)(v1 - 24);

  return sub_1CD64E248(v2);
}

void sub_1CC8E85B8(uint64_t a1)
{
  uint64_t v1 = sub_1CD65C8DC(a1);
  *(void *)(v1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(v1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E8624(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E8668(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E86CC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 72)) {
    *(unsigned char *)(a1 + 72) = 1;
  }
  uint64_t v1 = *(void *)(a1 + 32);
  *(void *)(a1 + 64) = 0;
  return (*(uint64_t (**)(void))(v1 + 32))();
}

size_t sub_1CC8E8704@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = a1 + 32;
  if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32))
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 24))(v3)) {
      int v4 = "simplified";
    }
    else {
      int v4 = "maybe-simple";
    }
  }
  else
  {
    int v4 = "not-simple";
  }
  size_t result = strlen(v4);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v6 = result;
  if (result >= 0x17)
  {
    uint64_t v7 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v7 = result | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = result;
    if (!result) {
      goto LABEL_14;
    }
  }
  size_t result = (size_t)memcpy(a2, v4, v6);
LABEL_14:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

BOOL sub_1CC8E881C(uint64_t a1, const llvm::Instruction **a2)
{
  uint64_t v4 = *(void *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 8);
  if (v4)
  {
    int v5 = 1;
    while (1)
    {
      uint64_t v6 = *(void *)(v4 + 24);
      unsigned int v7 = *(unsigned __int8 *)(v6 + 16);
      if (v6) {
        BOOL v8 = v7 >= 0x1C;
      }
      else {
        BOOL v8 = 0;
      }
      if (!v8) {
        goto LABEL_7;
      }
      if (v7 != 83) {
        goto LABEL_19;
      }
      int v9 = *(_DWORD *)(v6 + 20);
      uint64_t v10 = (v9 & 0x40000000) != 0 ? *(void *)(v6 - 8) : v6 - 32 * (v9 & 0x7FFFFFF);
      uint64_t v11 = *(void *)(v10 + 32 * *(unsigned int *)(v6 + 60) + 8
                                                                * ((unint64_t)(v4 - v10) >> 5));
      uint64_t v12 = *(void *)(v11 + 40);
      if (v12 == v11 + 40)
      {
LABEL_7:
        uint64_t v6 = 0;
      }
      else
      {
        if (v12) {
          uint64_t v13 = v12 - 24;
        }
        else {
          uint64_t v13 = 0;
        }
        if (*(unsigned __int8 *)(v13 + 16) - 29 >= 0xB) {
          uint64_t v6 = 0;
        }
        else {
          uint64_t v6 = v13;
        }
      }
LABEL_19:
      unsigned int v14 = sub_1CC8E8C1C(a1, a2, (llvm::Type *)v6);
      if (v14)
      {
        if (sub_1CD65D61C((uint64_t)a2, v4, v14)) {
          int v5 = 0;
        }
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (!v4) {
        return v5 != 0;
      }
    }
  }
  return 1;
}

void sub_1CC8E891C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C160, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C160))
  {
    __cxa_guard_release(&qword_1EA61C160);
  }
}

uint64_t sub_1CC8E8974(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_1CC8E8980(uint64_t a1)
{
  unint64_t v2 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (!*(unsigned char *)(a1 + 72)) {
    *(unsigned char *)(a1 + 72) = 1;
  }
  *(void *)(a1 + 64) = v2;
  *(unsigned char *)(a1 + 57) = *(unsigned char *)(a1 + 56);
  return 0;
}

uint64_t *sub_1CC8E89C8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E89F0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E8A58(uint64_t a1)
{
  unint64_t v2 = sub_1CD6482F0((llvm::IRPosition *)(a1 - 16));
  if (!*(unsigned char *)(a1 + 40)) {
    *(unsigned char *)(a1 + 40) = 1;
  }
  *(void *)(a1 + 32) = v2;
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a1 + 24);
  return 0;
}

uint64_t sub_1CC8E8AA0(uint64_t a1, llvm::IRPosition *a2)
{
  uint64_t v4 = sub_1CD648FA4(a2);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(_WORD *)(a1 + 56) = 256;
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = &unk_1F2620BB0;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)a1 = &unk_1F2625838;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = &unk_1F26258C0;
  return a1;
}

uint64_t sub_1CC8E8B44(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 2;
  if (*(unsigned char *)(*(void *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 2)) + 8) == 7) {
    (*(void (**)(uint64_t *))(*a1 + 120))(a1);
  }
  uint64_t v6 = 0;
  uint64_t result = sub_1CD650C48(a2, v4, &v6);
  if (result) {
    return (*(uint64_t (**)(uint64_t *))(*a1 + 120))(a1);
  }
  return result;
}

uint64_t sub_1CC8E8C0C(uint64_t a1)
{
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a1 + 24);
  return 0;
}

llvm::UndefValue *sub_1CC8E8C1C(uint64_t a1, const llvm::Instruction **a2, llvm::Type *a3)
{
  if (*(unsigned char *)(a1 + 72))
  {
    unsigned int v7 = *(llvm::UndefValue **)(a1 + 64);
    if (!v7) {
      return 0;
    }
  }
  else
  {
    int v9 = (llvm::UndefValue *)sub_1CD648FA4((llvm::IRPosition *)(a1 + 16));
    unsigned int v7 = llvm::UndefValue::get(v9, v10);
    if (!v7) {
      return 0;
    }
  }
  if (v7 == (llvm::UndefValue *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16))) {
    return 0;
  }
  int v35 = 128;
  uint64_t v11 = (char *)operator new(0x2000uLL, (std::align_val_t)8uLL);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  v34[0] = v11;
  v34[1] = 0;
  uint64_t v39 = 2;
  uint64_t v40 = 0;
  uint64_t v41 = -4096;
  uint64_t v42 = 0;
  unsigned int v38 = &unk_1F2615EC8;
  do
  {
    unsigned int v14 = &v11[v12];
    uint64_t v15 = v39;
    uint64_t v16 = v41;
    *(void *)&v11[v12 + 8] = v39 & 6;
    *((void *)v14 + 2) = 0;
    *((void *)v14 + 3) = v16;
    if (v16 != -4096 && v16 != -8192 && v16 != 0)
    {
      *((void *)v14 + 2) = *(void *)(v15 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v15 & 0xFFFFFFFFFFFFFFF8) = &v11[v12 + 8];
      *((void *)v14 + 1) = v15 & 0xFFFFFFFFFFFFFFFELL;
      uint64_t v18 = (void *)*((void *)v14 + 2);
      if (v18) {
        *uint64_t v18 = &v11[v12 + 16 + (*v18 & 7)];
      }
      uint64_t v13 = v42;
    }
    *(void *)unsigned int v14 = &unk_1F2615EC8;
    *((void *)v14 + 4) = v13;
    v12 += 64;
  }
  while (v12 != 0x2000);
  if (v41 != -8192 && v41 != -4096 && v41 != 0)
  {
    unint64_t v23 = v39 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v39 & 0xFFFFFFFFFFFFFFF8) = v40;
    if (v40)
    {
      *uint64_t v40 = *v40 & 7 | v23;
    }
    else
    {
      uint64_t v24 = v41;
      uint64_t v25 = ***(int32x2_t ****)v41;
      unint64_t v26 = (unint64_t)v25[303];
      if (v26 <= v23)
      {
        uint64_t v27 = v25[305].u32[0];
        if (v26 + 16 * v27 > v23)
        {
          unsigned int v28 = v27 - 1;
          LODWORD(v29) = v28 & ((v41 >> 4) ^ (v41 >> 9));
          uint64_t v30 = (uint64_t *)(v26 + 16 * v29);
          uint64_t v31 = *v30;
          if (v41 == *v30)
          {
LABEL_38:
            *uint64_t v30 = -8192;
            v25[304] = vadd_s32(v25[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v24 = v41;
          }
          else
          {
            int v32 = 1;
            while (v31 != -4096)
            {
              int v33 = v29 + v32++;
              uint64_t v29 = v33 & v28;
              uint64_t v31 = *(void *)(v26 + 16 * v29);
              if (v41 == v31)
              {
                uint64_t v30 = (uint64_t *)(v26 + 16 * v29);
                goto LABEL_38;
              }
            }
          }
          *(unsigned char *)(v24 + 17) &= ~1u;
        }
      }
    }
  }
  LOBYTE(v36[0]) = 0;
  char v37 = 0;
  uint64_t v20 = (llvm::PoisonValue *)sub_1CD648FA4((llvm::IRPosition *)(a1 + 16));
  int v21 = sub_1CC8E8F28(a2, (const llvm::AbstractAttribute *)a1, (uint64_t)v7, v20, a3, 1, (uint64_t)v34);
  if (v21)
  {
    uint64_t v22 = (llvm::PoisonValue *)sub_1CD648FA4((llvm::IRPosition *)(a1 + 16));
    uint64_t v3 = sub_1CC8E8F28(a2, (const llvm::AbstractAttribute *)a1, (uint64_t)v7, v22, a3, 0, (uint64_t)v34);
  }
  if (v37)
  {
    sub_1CC009394((uint64_t)v36);
    MEMORY[0x1D25D9CD0](v36[0], 8);
    char v37 = 0;
  }
  sub_1CC4D021C(v34);
  MEMORY[0x1D25D9CD0](v34[0], 8);
  if (!v21) {
    return 0;
  }
  return v3;
}

llvm::UndefValue *sub_1CC8E8F28(const llvm::Instruction **a1, const llvm::AbstractAttribute *a2, uint64_t a3, llvm::PoisonValue *a4, llvm::Type *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a3;
  uint64_t v14 = *(void *)a7;
  uint64_t v15 = *(unsigned int *)(a7 + 16);
  if (v15)
  {
    uint64_t v16 = (v15 - 1) & ((a3 >> 4) ^ (a3 >> 9));
    unint64_t v17 = (void *)(v14 + (v16 << 6));
    uint64_t v18 = v17[3];
    if (v18 == a3) {
      goto LABEL_8;
    }
    int v19 = 1;
    while (v18 != -4096)
    {
      int v20 = v16 + v19++;
      uint64_t v16 = v20 & (v15 - 1);
      unint64_t v17 = (void *)(v14 + (v16 << 6));
      uint64_t v18 = v17[3];
      if (v18 == a3) {
        goto LABEL_8;
      }
    }
  }
  unint64_t v17 = (void *)(v14 + (v15 << 6));
LABEL_8:
  uint64_t v115 = 6;
  if (v17 == (void *)(v14 + (v15 << 6)))
  {
    unint64_t v21 = 0;
    uint64_t result = 0;
    unint64_t v116 = 0;
    uint64_t v117 = 0;
  }
  else
  {
    unint64_t v21 = 0;
    uint64_t result = (llvm::UndefValue *)v17[7];
    unint64_t v116 = 0;
    uint64_t v117 = (uint64_t)result;
    if (result != (llvm::UndefValue *)-8192 && result != (llvm::UndefValue *)-4096 && result != 0)
    {
      unint64_t v24 = v17[5] & 0xFFFFFFFFFFFFFFF8;
      unint64_t v116 = *(void *)v24;
      *(void *)unint64_t v24 = &v115;
      uint64_t v115 = v24 | 6;
      unint64_t v21 = v116;
      if (v116) {
        *(void *)unint64_t v116 = *(void *)v116 & 7 | (unint64_t)&v116;
      }
      uint64_t result = (llvm::UndefValue *)v117;
    }
  }
  if (result != (llvm::UndefValue *)-8192 && result != (llvm::UndefValue *)-4096 && result != 0)
  {
    unint64_t v32 = v115 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(v115 & 0xFFFFFFFFFFFFFFF8) = v21;
    if (v116)
    {
      *(void *)unint64_t v116 = *(void *)v116 & 7 | v32;
    }
    else
    {
      uint64_t v33 = v117;
      unsigned int v34 = ***(int32x2_t ****)v117;
      unint64_t v35 = (unint64_t)v34[303];
      if (v35 <= v32)
      {
        uint64_t v36 = v34[305].u32[0];
        if (v35 + 16 * v36 > v32)
        {
          unsigned int v37 = v36 - 1;
          LODWORD(v38) = v37 & ((v117 >> 4) ^ (v117 >> 9));
          uint64_t v39 = (uint64_t *)(v35 + 16 * v38);
          uint64_t v40 = *v39;
          if (v117 == *v39)
          {
LABEL_41:
            *uint64_t v39 = -8192;
            v34[304] = vadd_s32(v34[304], (int32x2_t)0x1FFFFFFFFLL);
            uint64_t v33 = v117;
          }
          else
          {
            int v41 = 1;
            while (v40 != -4096)
            {
              int v42 = v38 + v41++;
              uint64_t v38 = v42 & v37;
              uint64_t v40 = *(void *)(v35 + 16 * v38);
              if (v117 == v40)
              {
                uint64_t v39 = (uint64_t *)(v35 + 16 * v38);
                goto LABEL_41;
              }
            }
          }
          *(unsigned char *)(v33 + 17) &= ~1u;
        }
      }
    }
  }
  if (!result)
  {
    BOOL v114 = 0;
    unsigned int v26 = *(unsigned __int8 *)(a3 + 16);
    if (v26 != 21)
    {
      if (v26 < 0x1C)
      {
        if (!*(unsigned char *)(a3 + 16))
        {
          uint64_t v31 = a3 | 2;
LABEL_45:
          uint64_t v115 = v31;
          unint64_t v116 = 0;
          unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified((llvm::Attributor *)a1, (const llvm::IRPosition *)&v115, a2, &v114);
          if (!(_BYTE)v44) {
            return (llvm::UndefValue *)llvm::PoisonValue::get(a4, v44);
          }
          if (AssumedSimplified) {
            uint64_t v11 = AssumedSimplified;
          }
          if (v11 && *(unsigned __int8 *)(v11 + 16) <= 0x14u)
          {
            uint64_t v115 = (uint64_t)v119;
            unint64_t v116 = (unint64_t)v119;
            uint64_t v117 = 4;
            LODWORD(v118) = 0;
            BOOL v46 = sub_1CC565AD0(v11, (uint64_t)&v115);
            if (v116 == v115)
            {
              if (v46) {
                goto LABEL_52;
              }
            }
            else
            {
              free((void *)v116);
              if (v46) {
                goto LABEL_52;
              }
            }
            return (llvm::UndefValue *)v11;
          }
LABEL_52:
          if (a5 && llvm::AA::isValidAtPosition((llvm::AA *)v11, a5, a1[11], v45))
          {
            int64_t v47 = (llvm::AA *)v11;
            return sub_1CC8E9918(v47, a4, a5, a6);
          }
          unsigned int v48 = *(unsigned __int8 *)(v11 + 16);
          if (v48 >= 0x1C)
          {
            if (a6)
            {
              uint64_t v49 = v48 - 33;
              if (v49 <= 0x37)
              {
                if (((1 << v49) & 0x8000000000041) != 0)
                {
                  uint64_t v81 = *(void *)(v11 + 64);
                  if (!v81 || (*(unsigned char *)(v81 + 20) & 4) == 0 && (*(unsigned char *)(v81 + 17) & 0x10) == 0)
                  {
                    LODWORD(v115) = 7;
                    if (sub_1CC5CB59C(v11, (__int32 *)&v115, 1uLL))
                    {
                      uint64_t v112 = *(void *)(v11 - 32);
                      if (!v112
                        || *(unsigned char *)(v112 + 16)
                        || *(void *)(v112 + 24) != *(void *)(v11 + 72)
                        || *(_DWORD *)(v112 + 36) != 7)
                      {
                        return 0;
                      }
                    }
                    if ((llvm::CallBase::hasFnAttrOnCalledFunction(v11, 66) & 1) == 0
                      && !llvm::CallBase::hasFnAttrOnCalledFunction(v11, 44))
                    {
                      return 0;
                    }
                  }
                }
                else if (((1 << v49) & 0x808001C8000010) != 0 || v49 == 28 && (*(_WORD *)(v11 + 18) & 0x301) != 0)
                {
                  return 0;
                }
              }
              int isSafeToSpeculativelyExecute = llvm::isSafeToSpeculativelyExecute(v11, (uint64_t *)a5, 0, 0);
              uint64_t result = 0;
              if (!isSafeToSpeculativelyExecute) {
                return result;
              }
            }
            int v51 = *(_DWORD *)(v11 + 20);
            if ((v51 & 0x40000000) != 0)
            {
              unsigned int v53 = *(int32x2_t ******)(v11 - 8);
              uint64_t v52 = v51 & 0x7FFFFFF;
            }
            else
            {
              uint64_t v52 = v51 & 0x7FFFFFF;
              unsigned int v53 = (int32x2_t *****)(v11 - 32 * v52);
            }
            if (v52)
            {
              uint64_t v113 = &v53[4 * v52];
              do
              {
                uint64_t v54 = *v53;
                uint64_t result = (llvm::UndefValue *)sub_1CC8E8F28(a1, a2, *v53, a4, a5, a6, a7);
                if (!result) {
                  return result;
                }
                if ((a6 & 1) == 0)
                {
                  int v55 = result;
                  unint64_t v116 = 2;
                  uint64_t v117 = 0;
                  unsigned int v118 = v54;
                  if (v54 != (int32x2_t ****)-8192 && v54 != (int32x2_t ****)-4096 && v54) {
                    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v116);
                  }
                  uint64_t v115 = (uint64_t)&unk_1F2615EC8;
                  v119[0] = a7;
                  unsigned int v56 = sub_1CC4CFF80(a7, &v115);
                  if (v118 != (int32x2_t ****)-8192 && v118 != (int32x2_t ****)-4096 && v118)
                  {
                    unint64_t v57 = v116 & 0xFFFFFFFFFFFFFFF8;
                    *(void *)(v116 & 0xFFFFFFFFFFFFFFF8) = v117;
                    if (v117)
                    {
                      *(void *)uint64_t v117 = *(void *)v117 & 7 | v57;
                    }
                    else
                    {
                      uint64_t v58 = v118;
                      uint64_t v59 = ***v118;
                      unint64_t v60 = (unint64_t)v59[303];
                      if (v60 <= v57)
                      {
                        uint64_t v61 = v59[305].u32[0];
                        if (v60 + 16 * v61 > v57)
                        {
                          unsigned int v62 = v61 - 1;
                          LODWORD(v63) = v62 & ((v118 >> 4) ^ (v118 >> 9));
                          int v64 = (int32x2_t *****)(v60 + 16 * v63);
                          uint64_t v65 = *v64;
                          if (v118 == *v64)
                          {
LABEL_88:
                            *int v64 = (int32x2_t ****)-8192;
                            v59[304] = vadd_s32(v59[304], (int32x2_t)0x1FFFFFFFFLL);
                            uint64_t v58 = v118;
                          }
                          else
                          {
                            int v66 = 1;
                            while (v65 != (int32x2_t ****)-4096)
                            {
                              int v67 = v63 + v66++;
                              uint64_t v63 = v67 & v62;
                              uint64_t v65 = *(int32x2_t *****)(v60 + 16 * v63);
                              if (v118 == v65)
                              {
                                int v64 = (int32x2_t *****)(v60 + 16 * v63);
                                goto LABEL_88;
                              }
                            }
                          }
                          *((unsigned char *)v58 + 17) &= ~1u;
                        }
                      }
                    }
                  }
                  uint64_t v68 = (llvm::UndefValue *)v56[7];
                  if (v68 != v55)
                  {
                    if (v68 && v68 != (llvm::UndefValue *)-8192 && v68 != (llvm::UndefValue *)-4096)
                    {
                      unint64_t v69 = v56[5] & 0xFFFFFFFFFFFFFFF8;
                      *(void *)unint64_t v69 = v56[6];
                      unsigned int v70 = (unint64_t *)v56[6];
                      if (v70)
                      {
                        *unsigned int v70 = *v70 & 7 | v69;
                      }
                      else
                      {
                        uint64_t v71 = v56[7];
                        uint64_t v72 = ***(int32x2_t ****)v71;
                        unint64_t v73 = (unint64_t)v72[303];
                        if (v73 <= v69)
                        {
                          uint64_t v74 = v72[305].u32[0];
                          if (v73 + 16 * v74 > v69)
                          {
                            unsigned int v75 = v74 - 1;
                            LODWORD(v76) = v75 & ((v71 >> 4) ^ (v71 >> 9));
                            uint64_t v77 = (uint64_t *)(v73 + 16 * v76);
                            uint64_t v78 = *v77;
                            if (v71 == *v77)
                            {
LABEL_108:
                              *uint64_t v77 = -8192;
                              v72[304] = vadd_s32(v72[304], (int32x2_t)0x1FFFFFFFFLL);
                              uint64_t v71 = v56[7];
                            }
                            else
                            {
                              int v79 = 1;
                              while (v78 != -4096)
                              {
                                int v80 = v76 + v79++;
                                uint64_t v76 = v80 & v75;
                                uint64_t v78 = *(void *)(v73 + 16 * v76);
                                if (v71 == v78)
                                {
                                  uint64_t v77 = (uint64_t *)(v73 + 16 * v76);
                                  goto LABEL_108;
                                }
                              }
                            }
                            *(unsigned char *)(v71 + 17) &= ~1u;
                          }
                        }
                      }
                    }
                    v56[7] = v55;
                    if (v55 != (llvm::UndefValue *)-8192 && v55 != (llvm::UndefValue *)-4096) {
                      llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v56 + 5));
                    }
                  }
                }
                v53 += 4;
              }
              while (v53 != v113);
            }
            if ((a6 & 1) == 0)
            {
              int64_t v82 = (llvm::Value *)llvm::Instruction::clone((llvm::Instruction *)v11);
              unint64_t v116 = 2;
              uint64_t v117 = 0;
              unsigned int v118 = (int32x2_t ****)v11;
              if (v11 != -8192 && v11 != -4096 && v11) {
                llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)&v116);
              }
              uint64_t v115 = (uint64_t)&unk_1F2615EC8;
              v119[0] = a7;
              unint64_t v83 = sub_1CC4CFF80(a7, &v115);
              if (v118 != (int32x2_t ****)-8192 && v118 != (int32x2_t ****)-4096 && v118)
              {
                unint64_t v84 = v116 & 0xFFFFFFFFFFFFFFF8;
                *(void *)(v116 & 0xFFFFFFFFFFFFFFF8) = v117;
                if (v117)
                {
                  *(void *)uint64_t v117 = *(void *)v117 & 7 | v84;
                }
                else
                {
                  unsigned int v85 = v118;
                  __int16 v86 = ***v118;
                  unint64_t v87 = (unint64_t)v86[303];
                  if (v87 <= v84)
                  {
                    uint64_t v88 = v86[305].u32[0];
                    if (v87 + 16 * v88 > v84)
                    {
                      unsigned int v89 = v88 - 1;
                      LODWORD(v90) = v89 & ((v118 >> 4) ^ (v118 >> 9));
                      uint64_t v91 = (int32x2_t *****)(v87 + 16 * v90);
                      uint64_t v92 = *v91;
                      if (v118 != *v91)
                      {
                        int v93 = 1;
                        do
                        {
                          if (v92 == (int32x2_t ****)-4096) {
                            goto LABEL_138;
                          }
                          int v94 = v90 + v93++;
                          uint64_t v90 = v94 & v89;
                          uint64_t v92 = *(int32x2_t *****)(v87 + 16 * v90);
                        }
                        while (v118 != v92);
                        uint64_t v91 = (int32x2_t *****)(v87 + 16 * v90);
                      }
                      llvm::Function *v91 = (int32x2_t ****)-8192;
                      v86[304] = vadd_s32(v86[304], (int32x2_t)0x1FFFFFFFFLL);
                      unsigned int v85 = v118;
LABEL_138:
                      *((unsigned char *)v85 + 17) &= ~1u;
                    }
                  }
                }
              }
              unint64_t v95 = (llvm::Value *)v83[7];
              if (v95 != v82)
              {
                if (v95 && v95 != (llvm::Value *)-8192 && v95 != (llvm::Value *)-4096)
                {
                  unint64_t v100 = v83[5] & 0xFFFFFFFFFFFFFFF8;
                  *(void *)unint64_t v100 = v83[6];
                  uint64_t v101 = (unint64_t *)v83[6];
                  if (v101)
                  {
                    *uint64_t v101 = *v101 & 7 | v100;
                  }
                  else
                  {
                    uint64_t v102 = v83[7];
                    unsigned int v103 = ***(int32x2_t ****)v102;
                    unint64_t v104 = (unint64_t)v103[303];
                    if (v104 <= v100)
                    {
                      uint64_t v105 = v103[305].u32[0];
                      if (v104 + 16 * v105 > v100)
                      {
                        unsigned int v106 = v105 - 1;
                        LODWORD(v107) = v106 & ((v102 >> 4) ^ (v102 >> 9));
                        uint64_t v108 = (uint64_t *)(v104 + 16 * v107);
                        uint64_t v109 = *v108;
                        if (v102 != *v108)
                        {
                          int v110 = 1;
                          do
                          {
                            if (v109 == -4096) {
                              goto LABEL_164;
                            }
                            int v111 = v107 + v110++;
                            uint64_t v107 = v111 & v106;
                            uint64_t v109 = *(void *)(v104 + 16 * v107);
                          }
                          while (v102 != v109);
                          uint64_t v108 = (uint64_t *)(v104 + 16 * v107);
                        }
                        *uint64_t v108 = -8192;
                        v103[304] = vadd_s32(v103[304], (int32x2_t)0x1FFFFFFFFLL);
                        uint64_t v102 = v83[7];
LABEL_164:
                        *(unsigned char *)(v102 + 17) &= ~1u;
                      }
                    }
                  }
                }
                v83[7] = v82;
                if (v82 != (llvm::Value *)-8192 && v82 != (llvm::Value *)-4096 && v82) {
                  llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(v83 + 5));
                }
              }
              uint64_t v96 = *((void *)a5 + 5);
              *((void *)v82 + 5) = v96;
              *(_WORD *)(v96 + 18) &= ~0x8000u;
              if ((*((unsigned char *)v82 + 23) & 0x10) != 0)
              {
                uint64_t v98 = *(void *)(v96 + 56);
                if (v98)
                {
                  char v99 = *(llvm::ValueSymbolTable **)(v98 + 104);
                  if (v99) {
                    llvm::ValueSymbolTable::reinsertValue(v99, v82);
                  }
                }
              }
              uint64_t v97 = *((void *)a5 + 3);
              *((void *)v82 + 4) = (char *)a5 + 24;
              *((void *)v82 + 3) = v97;
              *(void *)(v97 + 8) = (char *)v82 + 24;
              *((void *)a5 + 3) = (char *)v82 + 24;
              sub_1CD65D6A8();
            }
            if (v11)
            {
              int64_t v47 = (llvm::AA *)v11;
              return sub_1CC8E9918(v47, a4, a5, a6);
            }
          }
          return 0;
        }
      }
      else
      {
        unsigned int v27 = v26 - 33;
        BOOL v28 = v27 > 0x33;
        uint64_t v29 = (1 << v27) & 0x8000000000041;
        if (!v28 && v29 != 0)
        {
          uint64_t v31 = a3 | 1;
          goto LABEL_45;
        }
      }
    }
    uint64_t v31 = a3;
    goto LABEL_45;
  }
  return result;
}

llvm::UndefValue *sub_1CC8E9918(llvm::AA *a1, llvm::Value *a2, llvm::Type *a3, char a4)
{
  unsigned int v7 = a1;
  uint64_t result = llvm::AA::getWithType(a1, a2, a3);
  if (!result)
  {
    if (a3 && llvm::Type::canLosslesslyBitCastTo(*(llvm::Type **)v7, a2))
    {
      if ((a4 & 1) == 0)
      {
        __int16 v11 = 257;
        return llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(v7, a2, &v10, a3, v9);
      }
      return v7;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *sub_1CC8E99A0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E99E4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8E9A48()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C168, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C168))
  {
    __cxa_guard_release(&qword_1EA61C168);
  }
}

uint64_t *sub_1CC8E9A9C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8E9AC4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8E9B2C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8E9B70(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8E9BD4(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = sub_1CC8E8B44(a1, a2);
  unint64_t v4 = a1[2] & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*((_DWORD *)a1 + 4) & 3) == 0) {
    unint64_t v4 = *(void *)(v4 + 24);
  }
  if (*(unsigned __int8 *)(v4 + 16) <= 0x14u)
  {
    int v5 = *(uint64_t (**)(uint64_t *))(*a1 + 120);
    return v5(a1);
  }
  return result;
}

void sub_1CC8E9C5C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C170, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C170))
  {
    __cxa_guard_release(&qword_1EA61C170);
  }
}

uint64_t sub_1CC8E9CB0(uint64_t a1, llvm::Attributor *a2)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 64);
  int v5 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v6 = (_DWORD *)(a1 + 16);
  unint64_t v7 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  int v8 = *(unsigned __int8 *)(v7 + 16);
  if (v8 == 60) {
    int v9 = (uint64_t *)v7;
  }
  else {
    int v9 = 0;
  }
  if (v8 == 60)
  {
    uint64_t v14 = *((void *)a2 + 11);
    uint64_t v30 = v7;
    uint64_t v24 = 0;
    if (sub_1CD420258((uint64_t *)(v14 + 392), &v30, &v24))
    {
      uint64_t v15 = v24;
      uint64_t v16 = *(void *)(v14 + 392);
      uint64_t v17 = *(unsigned int *)(v14 + 408);
    }
    else
    {
      uint64_t v16 = *(void *)(v14 + 392);
      uint64_t v17 = *(unsigned int *)(v14 + 408);
      uint64_t v15 = v16 + 8 * v17;
    }
    if (v15 != v16 + 8 * v17)
    {
      uint64_t v30 = 1;
      int64x2_t v31 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      int64x2_t v32 = v31;
      uint64_t v33 = v35;
      uint64_t v34 = 0x400000000;
      uint64_t v24 = 1;
      int64x2_t v25 = v31;
      int64x2_t v26 = v31;
      unsigned int v27 = v29;
      uint64_t v28 = 0x400000000;
      BOOL v23 = 0;
      int v18 = 1;
      if (llvm::AA::getPotentiallyLoadedValues(a2, (uint64_t)v9, &v30, &v24, (const llvm::AbstractAttribute *)a1, &v23, 1)&& v28)
      {
        int v9 = (uint64_t *)v27;
        uint64_t v19 = 8 * v28;
        while (1)
        {
          uint64_t v20 = *v9;
          if (*v9)
          {
            if (*(unsigned char *)(v20 + 16) == 61)
            {
              int v21 = *(_DWORD *)(v20 + 20);
              if ((v21 & 0x40000000) != 0) {
                uint64_t v22 = *(uint64_t **)(v20 - 8);
              }
              else {
                uint64_t v22 = (uint64_t *)(v20 - 32 * (v21 & 0x7FFFFFF));
              }
              if (!llvm::Attributor::isAssumedDead((uint64_t)a2, v22, a1, 0, &v23, 0, 1))
              {
LABEL_39:
                int v9 = (uint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
                int v18 = 0;
                break;
              }
            }
            else if ((llvm::Attributor::isAssumedDead((uint64_t)a2, v20, a1, 0, &v23, 0, 1) & 1) == 0)
            {
              goto LABEL_39;
            }
          }
          ++v9;
          v19 -= 8;
          if (!v19)
          {
            int v18 = 1;
            break;
          }
        }
      }
      if (v27 != v29) {
        free(v27);
      }
      if ((v24 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v25.i64[0], 8);
      }
      if (v33 != v35) {
        free(v33);
      }
      if (v30)
      {
        if (!v18) {
          return (uint64_t)v9;
        }
      }
      else
      {
        MEMORY[0x1D25D9CD0](v31.i64[0], 8);
        if (!v18) {
          return (uint64_t)v9;
        }
      }
    }
  }
  uint64_t v30 = (uint64_t)a2;
  v31.i64[0] = a1;
  LOBYTE(v24) = 0;
  BOOL v23 = 0;
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(a1 + 24);
  unint64_t v12 = sub_1CC8AB830(v6);
  if ((sub_1CC8C6DEC(a2, v10, v11, (const llvm::AbstractAttribute *)a1, (uint64_t)&v24, (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, BOOL))sub_1CC8EA184, (uint64_t)&v30, v12, &v23) & 1) == 0&& (sub_1CC8EA08C(a1, (uint64_t)a2) & 1) == 0)
  {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  }
  if (v5 && *(unsigned char *)(a1 + 72)) {
    return v4 == *(void *)(a1 + 64);
  }
  return (v5 == 0) ^ (*(unsigned char *)(a1 + 72) != 0);
}

uint64_t *sub_1CC8E9FFC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EA024(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EA08C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  if (*(unsigned char *)(*(void *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 8) == 13)
  {
    int v5 = sub_1CC8C972C(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 2);
    uint64_t v6 = sub_1CD65DC58((uint64_t)v5);
    if (!v7)
    {
LABEL_3:
      *(unsigned char *)(a1 + 64) = 0;
      *(unsigned char *)(a1 + 72) = 0;
LABEL_12:
      uint64_t v8 = 1;
      llvm::Attributor::recordDependence(a2, (uint64_t)v5, a1, 1);
      return v8;
    }
    if (v6) {
      goto LABEL_16;
    }
  }
  if (*(unsigned char *)(*(void *)sub_1CD6482F0(v4) + 8) == 13)
  {
    int v5 = sub_1CC8E1740(a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 2);
    uint64_t v6 = sub_1CD65DCFC((uint64_t)v5);
    if (!v9) {
      goto LABEL_3;
    }
    if (v6)
    {
LABEL_16:
      if (!*(unsigned char *)(a1 + 72)) {
        *(unsigned char *)(a1 + 72) = 1;
      }
      *(void *)(a1 + 64) = v6;
      goto LABEL_12;
    }
  }
  return 0;
}

BOOL sub_1CC8EA184(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t v6 = a2;
  v113[8] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *a1;
  uint64_t v9 = a1[1];
  uint64_t v11 = *(void *)(v9 + 24);
  unsigned int v12 = *(unsigned __int8 *)(a2 + 16);
  if (v12 != 21)
  {
    if (v12 < 0x1C)
    {
      if (!*(unsigned char *)(a2 + 16)) {
        a2 |= 2uLL;
      }
    }
    else
    {
      unsigned int v13 = v12 - 33;
      BOOL v14 = v13 > 0x33;
      uint64_t v15 = (1 << v13) & 0x8000000000041;
      if (!v14 && v15 != 0)
      {
        uint64_t v11 = 0;
        a2 |= 1uLL;
      }
    }
  }
  if (llvm::AbstractAttribute *)v9 != sub_1CC8AB8F0(v8, a2, v11, v9, 0, 0, 1) || (a5)
  {
    uint64_t v24 = (llvm::Attributor *)*a1;
    uint64_t v25 = *(void *)(v9 + 24);
    unsigned int v26 = *(unsigned __int8 *)(v6 + 16);
    if (v26 != 21)
    {
      if (v26 < 0x1C)
      {
        if (!*(unsigned char *)(v6 + 16)) {
          v6 |= 2uLL;
        }
      }
      else
      {
        unsigned int v27 = v26 - 33;
        if (v27 <= 0x33 && ((1 << v27) & 0x8000000000041) != 0)
        {
          uint64_t v25 = 0;
          v6 |= 1uLL;
        }
      }
    }
    int v111 = (void *)v6;
    uint64_t v112 = v25;
    return sub_1CC8EAA38(v9, v24, (const llvm::AbstractAttribute *)v9, (llvm::IRPosition *)&v111);
  }
  unsigned int v17 = *(unsigned __int8 *)(v6 + 16);
  if (v17 <= 0x1B) {
    int v18 = 0;
  }
  else {
    int v18 = (llvm *)v6;
  }
  if (v17 < 0x1C) {
    return 0;
  }
  if (v17 - 83 < 0xFFFFFFFE) {
    goto LABEL_17;
  }
  unint64_t v28 = *(void *)(v6 - 64);
  uint64_t v29 = (llvm::Attributor *)*a1;
  unint64_t v30 = *(void *)(v6 - 32);
  v104[0] = 0;
  uint64_t v31 = *(void *)(v9 + 24);
  unsigned int v32 = *(unsigned __int8 *)(v28 + 16);
  if (v32 != 21)
  {
    if (v32 < 0x1C)
    {
      if (!*(unsigned char *)(v28 + 16)) {
        v28 |= 2uLL;
      }
    }
    else
    {
      unsigned int v33 = v32 - 33;
      BOOL v14 = v33 > 0x33;
      uint64_t v34 = (1 << v33) & 0x8000000000041;
      if (!v14 && v34 != 0)
      {
        uint64_t v31 = 0;
        v28 |= 1uLL;
      }
    }
  }
  int v111 = (void *)v28;
  uint64_t v112 = v31;
  unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(v29, (const llvm::IRPosition *)&v111, (const llvm::AbstractAttribute *)v9, v104);
  if (!v59) {
    return 1;
  }
  unint64_t v60 = AssumedSimplified;
  if (!AssumedSimplified) {
    goto LABEL_17;
  }
  uint64_t v61 = *(void *)(v9 + 24);
  unsigned int v62 = *(unsigned __int8 *)(v30 + 16);
  if (v62 != 21)
  {
    if (v62 < 0x1C)
    {
      if (!*(unsigned char *)(v30 + 16)) {
        v30 |= 2uLL;
      }
    }
    else
    {
      unsigned int v63 = v62 - 33;
      if (v63 <= 0x33 && ((1 << v63) & 0x8000000000041) != 0)
      {
        uint64_t v61 = 0;
        v30 |= 1uLL;
      }
    }
  }
  int v111 = (void *)v30;
  uint64_t v112 = v61;
  unint64_t v70 = llvm::Attributor::getAssumedSimplified(v29, (const llvm::IRPosition *)&v111, (const llvm::AbstractAttribute *)v9, v104);
  if (!v72) {
    return 1;
  }
  if (!v70) {
    goto LABEL_17;
  }
  unint64_t v73 = **(uint64_t ***)v6;
  if (v60 == v70)
  {
    unsigned int v80 = *(_WORD *)(v6 + 18) & 0x3F;
    if (v80 - 32 < 0xA || v80 <= 0xF && ((1 << v80) & 0xAA55) != 0)
    {
      BOOL v81 = 0;
      uint64_t v82 = *v73;
      if (v80 <= 0x29) {
        BOOL v81 = ((1 << v80) & 0x2A90000AA00) != 0;
      }
      unint64_t v83 = *(llvm::ConstantInt **)(v82 + 1888);
      unint64_t v84 = *(unsigned int *)(v82 + 1896);
      LODWORD(v112) = v84 >> 8;
      if (v84 >> 8 > 0x40) {
        operator new[]();
      }
      if (v84 <= 0xFF) {
        unint64_t v85 = 0;
      }
      else {
        unint64_t v85 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v84) + 63);
      }
      int v111 = (void *)(v85 & v81);
      __int16 v86 = (llvm::Value **)llvm::ConstantInt::get(v83, (llvm::LLVMContext *)&v111, v71);
      if (v112 >= 0x41 && v111) {
        MEMORY[0x1D25D9CB0](v111, 0x1000C8000313F17);
      }
      int v111 = v86;
      LOBYTE(v112) = 1;
      unint64_t v87 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(v9 + 64), (uint64_t)&v111, *v86);
      *(void *)(v9 + 64) = v87;
      *(void *)(v9 + 72) = v88;
      if ((_BYTE)v88) {
        BOOL v89 = v87 == 0;
      }
      else {
        BOOL v89 = 0;
      }
      int v90 = !v89;
      if (v90 == 1 && !v104[0]) {
        goto LABEL_151;
      }
LABEL_130:
      if (v90) {
        return 1;
      }
      goto LABEL_17;
    }
  }
  if (*(unsigned char *)(v6 + 16) == 81 && (*(_WORD *)(v6 + 18) & 0x3E) == 0x20)
  {
    int v74 = *(unsigned __int8 *)(v60 + 16);
    if (v74 == 19 || *(unsigned char *)(v70 + 16) == 19)
    {
      uint64_t v75 = *(void *)(v6 - 64 + 32 * (v74 == 19));
      unsigned int v76 = *(unsigned __int8 *)(v75 + 16);
      if (v76 != 21)
      {
        if (v76 < 0x1C)
        {
          if (!*(unsigned char *)(v75 + 16)) {
            v75 |= 2uLL;
          }
        }
        else
        {
          unsigned int v77 = v76 - 33;
          BOOL v14 = v77 > 0x33;
          uint64_t v78 = (1 << v77) & 0x8000000000041;
          if (!v14 && v78 != 0) {
            v75 |= 1uLL;
          }
        }
      }
      uint64_t v92 = sub_1CC8BA72C((uint64_t)v29, v75, 0, v9, 0, 0, 1);
      if (*((unsigned char *)v92 + 41))
      {
        v104[0] |= *((unsigned char *)v92 + 40) ^ 1;
        BOOL v94 = (*(_WORD *)(v6 + 18) & 0x3F) == 33;
        unint64_t v95 = *(llvm::ConstantInt **)(*v73 + 1888);
        unsigned int v96 = *(_DWORD *)(*v73 + 1896);
        LODWORD(v112) = v96 >> 8;
        if (v96 >> 8 > 0x40) {
          operator new[]();
        }
        if (v96 <= 0xFF) {
          unint64_t v97 = 0;
        }
        else {
          unint64_t v97 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v96) + 63);
        }
        int v111 = (void *)(v97 & v94);
        uint64_t v98 = (llvm::Value **)llvm::ConstantInt::get(v95, (llvm::LLVMContext *)&v111, v93);
        if (v112 >= 0x41 && v111) {
          MEMORY[0x1D25D9CB0](v111, 0x1000C8000313F17);
        }
        int v111 = v98;
        LOBYTE(v112) = 1;
        char v99 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(v9 + 64), (uint64_t)&v111, *v98);
        *(void *)(v9 + 64) = v99;
        *(void *)(v9 + 72) = v100;
        if ((_BYTE)v100) {
          BOOL v101 = v99 == 0;
        }
        else {
          BOOL v101 = 0;
        }
        LOBYTE(v90) = !v101;
        if (!v101 && !v104[0])
        {
LABEL_151:
          (*(void (**)(uint64_t))(*(void *)(v9 + 32) + 32))(v9 + 32);
          return 1;
        }
        goto LABEL_130;
      }
    }
  }
LABEL_17:
  uint64_t v19 = (llvm::Attributor *)*a1;
  BOOL v110 = 0;
  int v20 = *(_DWORD *)(v6 + 20);
  uint64_t v21 = v20 & 0x7FFFFFF;
  int v111 = v113;
  HIDWORD(v112) = 8;
  if ((v20 & 0x7FFFFFFu) >= 9)
  {
    LODWORD(v112) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v21) {
    bzero(v113, 8 * v21);
  }
  LODWORD(v112) = v20 & 0x7FFFFFF;
  if ((v20 & 0x40000000) != 0)
  {
    BOOL v23 = *(uint64_t **)(v6 - 8);
    uint64_t v22 = v20 & 0x7FFFFFF;
    if ((v20 & 0x7FFFFFF) == 0)
    {
LABEL_90:
      char v53 = 0;
      goto LABEL_91;
    }
  }
  else
  {
    uint64_t v22 = v20 & 0x7FFFFFF;
    BOOL v23 = (uint64_t *)(v6 - 32 * v22);
    if ((v20 & 0x7FFFFFF) == 0) {
      goto LABEL_90;
    }
  }
  uint64_t v37 = 0;
  char v38 = 0;
  uint64_t v39 = 32 * v22;
  do
  {
    unint64_t v40 = *v23;
    uint64_t v41 = *(void *)(v9 + 24);
    unsigned int v42 = *(unsigned __int8 *)(*v23 + 16);
    if (v42 == 21) {
      goto LABEL_48;
    }
    if (v42 >= 0x1C)
    {
      unsigned int v43 = v42 - 33;
      BOOL v14 = v43 > 0x33;
      uint64_t v44 = (1 << v43) & 0x8000000000041;
      if (!v14 && v44 != 0)
      {
        uint64_t v41 = 0;
        uint64_t v46 = v40 | 1;
        goto LABEL_49;
      }
LABEL_48:
      uint64_t v46 = *v23;
      goto LABEL_49;
    }
    if (*(unsigned char *)(*v23 + 16)) {
      goto LABEL_48;
    }
    uint64_t v46 = v40 | 2;
LABEL_49:
    *(void *)unint64_t v104 = v46;
    uint64_t v105 = v41;
    unint64_t v47 = llvm::Attributor::getAssumedSimplified(v19, (const llvm::IRPosition *)v104, (const llvm::AbstractAttribute *)v9, &v110);
    if (!v51)
    {
      char v53 = 1;
      goto LABEL_91;
    }
    if (v47) {
      unint64_t v52 = v47;
    }
    else {
      unint64_t v52 = v40;
    }
    *(void *)((char *)v111 + v37) = v52;
    v38 |= *(void *)((char *)v111 + v37) != v40;
    v23 += 4;
    v37 += 8;
    v39 -= 32;
  }
  while (v39);
  if ((v38 & 1) == 0) {
    goto LABEL_90;
  }
  uint64_t v54 = *((void *)v19 + 11);
  uint64_t v55 = **(void **)(v54 + 440);
  uint64_t v56 = *(void *)(*(void *)(*((void *)v18 + 5) + 56) + 40);
  if (v55) {
    BOOL v57 = v56 == 0;
  }
  else {
    BOOL v57 = 1;
  }
  if (!v57) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  if (v55) {
    BOOL v64 = v56 == 0;
  }
  else {
    BOOL v64 = 1;
  }
  if (!v64) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  if (**(void **)(v54 + 440)) {
    BOOL v65 = v56 == 0;
  }
  else {
    BOOL v65 = 1;
  }
  if (!v65) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  *(void *)unint64_t v104 = *(void *)(*(void *)(*((void *)v18 + 5) + 56) + 40) + 272;
  uint64_t v105 = 0;
  uint64_t v106 = 0;
  uint64_t v107 = 0;
  uint64_t v108 = v18;
  __int16 v109 = 257;
  int v66 = llvm::SimplifyInstructionWithOperands(v18, (uint64_t)v111, v112, (uint64_t)v104, v48, v49, v50);
  if (!v66) {
    goto LABEL_90;
  }
  uint64_t v102 = v66;
  char v103 = 1;
  int v67 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(v9 + 64), (uint64_t)&v102, *(llvm::Value **)v18);
  *(void *)(v9 + 64) = v67;
  *(void *)(v9 + 72) = v68;
  if ((_BYTE)v68) {
    BOOL v69 = v67 == 0;
  }
  else {
    BOOL v69 = 0;
  }
  char v53 = !v69;
LABEL_91:
  if (v111 != v113) {
    free(v111);
  }
  return (v53 & 1) != 0;
}

BOOL sub_1CC8EAA38(uint64_t a1, llvm::Attributor *a2, const llvm::AbstractAttribute *a3, llvm::IRPosition *a4)
{
  BOOL v13 = 0;
  sub_1CD6482F0(a4);
  v14[0] = llvm::Attributor::getAssumedSimplified(a2, a4, a3, &v13);
  v14[1] = v8;
  uint64_t v9 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(a1 + 64), (uint64_t)v14, *(llvm::Value **)(a1 + 40));
  *(void *)(a1 + 64) = v9;
  *(void *)(a1 + 72) = v10;
  if ((_BYTE)v10) {
    BOOL v11 = v9 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  return !v11;
}

void *sub_1CC8EAAB8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EAAFC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8EAB60(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  sub_1CC8E8B44((uint64_t *)a1, a2);
  if (sub_1CD6482A0((_DWORD *)(a1 + 16)))
  {
    unint64_t v5 = sub_1CD6482A0((_DWORD *)(a1 + 16));
    if (v5 && *(unsigned char *)(v5 + 16) == 3)
    {
      if ((*(_DWORD *)(v5 + 20) & 0x7FFFFFF) != 0) {
        goto LABEL_5;
      }
    }
    else if (*(unsigned char *)(v5 + 16) || *(void *)(v5 + 72) != v5 + 72 || (*(unsigned char *)(v5 + 34) & 0x80) != 0)
    {
      goto LABEL_5;
    }
  }
  unint64_t v3 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (!*(unsigned char *)(a1 + 72)) {
    *(unsigned char *)(a1 + 72) = 1;
  }
  *(void *)(a1 + 64) = v3;
  *(unsigned char *)(a1 + 57) = *(unsigned char *)(a1 + 56);
LABEL_5:
  int v7 = 69;
  long long v6 = xmmword_1CFB273B8;
  unint64_t result = llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), (unsigned int *)&v6, 5, 1, 0);
  if (result)
  {
    unint64_t result = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
    if (!*(unsigned char *)(a1 + 72)) {
      *(unsigned char *)(a1 + 72) = 1;
    }
    *(void *)(a1 + 64) = result;
    *(unsigned char *)(a1 + 57) = *(unsigned char *)(a1 + 56);
  }
  return result;
}

void sub_1CC8EAC90()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C178, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C178))
  {
    __cxa_guard_release(&qword_1EA61C178);
  }
}

BOOL sub_1CC8EACE4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 16);
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  unint64_t v6 = AssociatedArgument;
  if (*(unsigned char *)(*(void *)AssociatedArgument + 8) == 15)
  {
    uint64_t v7 = *(void *)(*(void *)(AssociatedArgument + 24) + 112);
    if (v7)
    {
      unsigned int v8 = *(_DWORD *)(AssociatedArgument + 32) + 2;
      if (v8 < *(_DWORD *)(v7 + 8))
      {
        uint64_t v15 = *(void *)(v7 + 8 * v8 + 40);
        if (v15)
        {
          if ((*(unsigned char *)(v15 + 20) & 0x20) != 0 && (sub_1CC8AAAB0(a2, v4, a1, 0, v20) & 1) == 0) {
            goto LABEL_24;
          }
        }
      }
    }
  }
  uint64_t v9 = *(void *)(a1 + 64);
  int v10 = *(unsigned __int8 *)(a1 + 72);
  v20[0] = a1;
  v20[1] = a2;
  uint64_t v11 = *(void *)(a1 + 24);
  if (!v11) {
    goto LABEL_19;
  }
  uint64_t v12 = *(void *)(v11 - 32);
  if (!v12 || *(unsigned char *)(v12 + 16) || *(void *)(v12 + 24) != *(void *)(v11 + 72)) {
    uint64_t v12 = 0;
  }
  if (v12 == *(void *)(v6 + 24))
  {
    llvm::AbstractCallSite::AbstractCallSite((llvm::AbstractCallSite *)&v17, (const llvm::Use *)(v11 - 32));
    char v13 = sub_1CC8EAF44(v20, &v17);
    if (v18 != &v19) {
      free(v18);
    }
    if (v13) {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_19:
    if (llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8EB050, (uint64_t)v20, a1, 1, (unsigned char *)&v19 + 7))goto LABEL_14; {
  }
    }
  if (sub_1CC8EA08C(a1, a2))
  {
LABEL_14:
    if (v10 && *(unsigned char *)(a1 + 72)) {
      return v9 == *(void *)(a1 + 64);
    }
    else {
      return (v10 == 0) ^ (*(unsigned char *)(a1 + 72) != 0);
    }
  }
LABEL_24:
  unint64_t v16 = sub_1CD6482F0((llvm::IRPosition *)v4);
  if (!*(unsigned char *)(a1 + 72)) {
    *(unsigned char *)(a1 + 72) = 1;
  }
  BOOL result = 0;
  *(void *)(a1 + 64) = v16;
  *(unsigned char *)(a1 + 57) = *(unsigned char *)(a1 + 56);
  return result;
}

uint64_t *sub_1CC8EAEB4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EAEDC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EAF44(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v14 = *a2;
  v15[0] = v16;
  v15[1] = 0;
  if (*((_DWORD *)a2 + 4)) {
    sub_1CD41B6B0((uint64_t)v15, (uint64_t)(a2 + 1));
  }
  unsigned int v4 = sub_1CD64DE00((llvm::IRPosition *)(v3 + 16), 0);
  v16[0] = sub_1CD659800((uint64_t)&v14, v4);
  v16[1] = v5;
  if (v15[0] != v16) {
    free(v15[0]);
  }
  uint64_t result = sub_1CD647DEC(v16);
  if (result)
  {
    BOOL v13 = 0;
    AssumedConstant = llvm::Attributor::getAssumedConstant((llvm::Attributor *)a1[1], (const llvm::IRPosition *)v16, (const llvm::AbstractAttribute *)v3, &v13);
    if (v8)
    {
      uint64_t v9 = AssumedConstant;
      if (AssumedConstant)
      {
        uint64_t result = llvm::AA::isDynamicallyUnique((llvm::AA *)a1[1], (llvm::Attributor *)v3, (int64_t)AssumedConstant, (const llvm::Value *)1);
        if (result)
        {
          v17[0] = v9;
          v17[1] = 1;
          int v10 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(v3 + 64), (uint64_t)v17, *(llvm::Value **)(v3 + 40));
          *(void *)(v3 + 64) = v10;
          *(void *)(v3 + 72) = v11;
          if ((_BYTE)v11) {
            BOOL v12 = v10 == 0;
          }
          else {
            BOOL v12 = 0;
          }
          return !v12;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_1CC8EB050(uint64_t *a1, uint64_t a2)
{
  uint64_t v5 = *(void *)a2;
  v6[0] = &v7;
  v6[1] = 0;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD41B598((uint64_t)v6, a2 + 8);
  }
  uint64_t v3 = sub_1CC8EAF44(a1, &v5);
  if (v6[0] != &v7) {
    free(v6[0]);
  }
  return v3;
}

void *sub_1CC8EB0C8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EB10C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EB170()
{
  return 1;
}

void sub_1CC8EB178()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C180, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C180))
  {
    __cxa_guard_release(&qword_1EA61C180);
  }
}

uint64_t sub_1CC8EB1CC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  int v5 = *(unsigned __int8 *)(a1 + 72);
  v11[0] = a1;
  v11[1] = a2;
  int v8 = 1;
  v9[0] = &v8;
  v9[1] = 1;
  unint64_t v6 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if ((llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8EB3BC, (uint64_t)v11, v6, a1, (uint64_t)v9, &v10, 0, 0) & 1) == 0&& (sub_1CC8EA08C(a1, a2) & 1) == 0)
  {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  }
  if (v5 && *(unsigned char *)(a1 + 72)) {
    return v4 == *(void *)(a1 + 64);
  }
  return (v5 == 0) ^ (*(unsigned char *)(a1 + 72) != 0);
}

uint64_t sub_1CC8EB2D4(uint64_t a1)
{
  if ((*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16))()) {
    return *(void *)(a1 + 64);
  }
  else {
    return 0;
  }
}

uint64_t *sub_1CC8EB32C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EB354(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8EB3BC(const llvm::AbstractAttribute **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  int v5 = a1[1];
  uint64_t v6 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
  uint64_t v7 = *((void *)v4 + 3);
  unsigned int v8 = *(unsigned __int8 *)(v6 + 16);
  if (v8 != 21)
  {
    if (v8 < 0x1C)
    {
      if (!*(unsigned char *)(v6 + 16)) {
        v6 |= 2uLL;
      }
    }
    else
    {
      unsigned int v9 = v8 - 33;
      BOOL v10 = v9 > 0x33;
      uint64_t v11 = (1 << v9) & 0x8000000000041;
      if (!v10 && v11 != 0)
      {
        uint64_t v7 = 0;
        v6 |= 1uLL;
      }
    }
  }
  v14[0] = v6;
  v14[1] = v7;
  return sub_1CC8EAA38((uint64_t)v4, v5, v4, (llvm::IRPosition *)v14);
}

void *sub_1CC8EB458(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EB49C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8EB500(uint64_t *a1, uint64_t *a2)
{
  sub_1CC8E8B44(a1, a2);
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 2));
  if (!v4)
  {
    uint64_t v15 = *(void (**)(uint64_t *))(*a1 + 120);
    v15(a1);
    return;
  }
  unint64_t v5 = v4;
  if ((*(_WORD *)(v4 + 18) & 1) == 0)
  {
    uint64_t v6 = *(void *)(v4 + 88);
LABEL_4:
    uint64_t v7 = v6;
    goto LABEL_5;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)v4);
  uint64_t v6 = *(void *)(v5 + 88);
  if ((*(_WORD *)(v5 + 18) & 1) == 0) {
    goto LABEL_4;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)v5);
  uint64_t v7 = *(void *)(v5 + 88);
LABEL_5:
  uint64_t v8 = v7 + 40 * *(void *)(v5 + 96);
  while (v6 != v8)
  {
    uint64_t v9 = *(void *)(*(void *)(v6 + 24) + 112);
    if (v9)
    {
      unsigned int v10 = *(_DWORD *)(v6 + 32) + 2;
      if (v10 < *(_DWORD *)(v9 + 8))
      {
        uint64_t v11 = *(void *)(v9 + 8 * v10 + 40);
        if (v11)
        {
          if ((*(unsigned char *)(v11 + 17) & 0x40) != 0)
          {
            unint64_t v12 = sub_1CC8AB830((_DWORD *)a1 + 4);
            int v13 = *(_DWORD *)(v12 + 20);
            if ((v13 & 0x40000000) != 0) {
              unint64_t v14 = *(void *)(v12 - 8);
            }
            else {
              unint64_t v14 = v12 - 32 * (v13 & 0x7FFFFFF);
            }
            v16[0] = (v14 + 32 * *(unsigned int *)(v6 + 32)) | 3;
            v16[1] = 0;
            if (sub_1CD647DEC(v16) == 7
              && sub_1CC8EAA38((uint64_t)a1, (llvm::Attributor *)a2, (const llvm::AbstractAttribute *)a1, (llvm::IRPosition *)v16))
            {
              (*(void (**)(uint64_t *))(a1[4] + 32))(a1 + 4);
            }
            else
            {
              (*(void (**)(uint64_t *))(*a1 + 120))(a1);
            }
            return;
          }
        }
      }
    }
    v6 += 40;
  }
}

void sub_1CC8EB6D0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C188, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C188))
  {
    __cxa_guard_release(&qword_1EA61C188);
  }
}

uint64_t sub_1CC8EB724(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  int v5 = *(unsigned __int8 *)(a1 + 72);
  unint64_t v6 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  uint64_t v7 = sub_1CC8B670C(a2, v6, 0, a1, 0, 0, 1);
  v11[0] = a2;
  v11[1] = a1;
  if (((*(uint64_t (**)(llvm::AbstractAttribute *, BOOL (*)(uint64_t, llvm::Argument *), void *))(*(void *)v7 + 120))(v7, sub_1CC8EB8C8, v11) & 1) == 0&& (sub_1CC8EA08C(a1, a2) & 1) == 0)
  {
    return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120))(a1);
  }
  int v8 = *(unsigned __int8 *)(a1 + 72);
  if (v5) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    return (v5 == 0) ^ (v8 != 0);
  }
  else {
    return v4 == *(void *)(a1 + 64);
  }
}

uint64_t *sub_1CC8EB838(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EB860(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8EB8C8(uint64_t a1, llvm::Argument *a2)
{
  BOOL v13 = 0;
  uint64_t v4 = *(llvm::Attributor **)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v5 = sub_1CC8AB830((_DWORD *)(v3 + 16));
  v12[0] = llvm::Attributor::translateArgumentToCallSiteContent(v4, a2, 1, v5, (const llvm::AbstractAttribute *)v3, &v13);
  v12[1] = v6;
  uint64_t v7 = (llvm::Value *)sub_1CD648FA4((llvm::IRPosition *)(v3 + 16));
  int v8 = llvm::AA::combineOptionalValuesInAAValueLatice((unsigned __int8 *)(v3 + 64), (uint64_t)v12, v7);
  *(void *)(v3 + 64) = v8;
  *(void *)(v3 + 72) = v9;
  if ((_BYTE)v9) {
    BOOL v10 = v8 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  return !v10;
}

void *sub_1CC8EB958(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EB99C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EBA00(uint64_t a1, const llvm::Instruction **a2)
{
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v5 = (llvm::Type *)sub_1CC8AB830((_DWORD *)(a1 + 16));
  uint64_t v6 = sub_1CC8E8C1C(a1, a2, v5);
  if (!v6) {
    return 1;
  }
  int v8 = v6;
  unint64_t v9 = *(void *)v4 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*(_DWORD *)v4 & 3) == 0) {
    unint64_t v9 = *(void *)(v9 + 24);
  }
  unsigned int v10 = sub_1CD64DE00(v4, 0);
  int v11 = *(_DWORD *)(v9 + 20);
  if ((v11 & 0x40000000) != 0) {
    unint64_t v12 = *(void *)(v9 - 8);
  }
  else {
    unint64_t v12 = v9 - 32 * (v11 & 0x7FFFFFF);
  }
  return sub_1CD65D61C((uint64_t)a2, v12 + 32 * v10, v8) ^ 1;
}

void sub_1CC8EBAAC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C190, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C190))
  {
    __cxa_guard_release(&qword_1EA61C190);
  }
}

uint64_t *sub_1CC8EBB00(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EBB28(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

double sub_1CC8EBB90(uint64_t a1, _OWORD *a2)
{
  *(_OWORD *)(a1 + 16) = *a2;
  *(_WORD *)(a1 + 40) = 768;
  *(void *)a1 = &unk_1F2625DE0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = &unk_1F2625EA0;
  *(void *)&double result = 1;
  *(void *)(a1 + 48) = 1;
  int64x2_t v3 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 56) = v3;
  *(int64x2_t *)(a1 + 72) = v3;
  *(int64x2_t *)(a1 + 88) = v3;
  *(int64x2_t *)(a1 + 104) = v3;
  *(void *)(a1 + 120) = a1 + 136;
  *(void *)(a1 + 128) = 0x800000000;
  *(void *)(a1 + 200) = 1;
  *(int64x2_t *)(a1 + 208) = v3;
  *(int64x2_t *)(a1 + 224) = v3;
  *(int64x2_t *)(a1 + 240) = v3;
  *(int64x2_t *)(a1 + 256) = v3;
  *(void *)(a1 + 272) = a1 + 288;
  *(void *)(a1 + 280) = 0x800000000;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  *(_DWORD *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 392) = 0;
  return result;
}

void sub_1CC8EBC44(uint64_t a1)
{
  sub_1CC8ED120(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EBC7C(uint64_t a1, llvm::Attributor *a2)
{
  unint64_t v4 = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (!v4) {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  uint64_t v5 = v4;
  if (*(unsigned char *)(v4 + 16))
  {
    if (*(unsigned char *)(v4 + 16) == 3 && (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) == 0) {
      return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
    }
  }
  else if (*(void *)(v4 + 72) == v4 + 72 && (*(unsigned char *)(v4 + 34) & 0x80) == 0)
  {
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
  }
  uint64_t v7 = (uint64_t *)*((void *)a2 + 10);
  if (v7[3] != v7[4])
  {
    uint64_t v14 = 0;
    uint64_t v15 = v5;
    if ((sub_1CD420258(v7, &v15, &v14) & 1) == 0) {
      return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
    }
  }
  uint64_t v8 = *(void *)(v5 + 80);
  if (v8) {
    uint64_t v9 = v8 - 24;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *(void *)(v9 + 48);
  if (v10) {
    uint64_t v11 = v10 - 24;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v15 = v11;
  sub_1CD65DEA4(a1 + 48, &v15);
  uint64_t v12 = *(void *)(v5 + 80);
  if (v12) {
    uint64_t v13 = v12 - 24;
  }
  else {
    uint64_t v13 = 0;
  }
  return sub_1CC8ED20C(a1, a2, v13);
}

void sub_1CC8EBD98(_DWORD *a1@<X0>, std::string *a2@<X8>)
{
  std::to_string(&v31, a1[96]);
  unint64_t v4 = std::string::insert(&v31, 0, "Live[#BB ");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v32.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v32, "/");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  unint64_t v8 = sub_1CD6482A0(a1 + 4) + 72;
  unint64_t v9 = -1;
  unint64_t v10 = v8;
  do
  {
    unint64_t v10 = *(void *)(v10 + 8);
    ++v9;
  }
  while (v10 != v8);
  std::to_string(&v30, v9);
  if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v30;
  }
  else {
    uint64_t v11 = (std::string *)v30.__r_.__value_.__r.__words[0];
  }
  if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&v30.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = v30.__r_.__value_.__l.__size_;
  }
  uint64_t v13 = std::string::append(&v33, (const std::string::value_type *)v11, size);
  std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  uint64_t v15 = std::string::append(&v34, "][#TBEP ");
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v29, a1[32]);
  if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v17 = &v29;
  }
  else {
    uint64_t v17 = (std::string *)v29.__r_.__value_.__r.__words[0];
  }
  if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v18 = *((unsigned char *)&v29.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type v18 = v29.__r_.__value_.__l.__size_;
  }
  uint64_t v19 = std::string::append(&v35, (const std::string::value_type *)v17, v18);
  std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v36.__r_.__value_.__l.__data_ = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v36.__r_.__value_.__r.__words[2] = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  uint64_t v21 = std::string::append(&v36, "][#KDE ");
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v37.__r_.__value_.__r.__words[2] = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, a1[70]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v24 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type v24 = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v25 = std::string::append(&v37, (const std::string::value_type *)p_p, v24);
  std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__r.__words[2] = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  unsigned int v27 = std::string::append(&v38, "]");
  *a2 = *v27;
  v27->__r_.__value_.__r.__words[0] = 0;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v38.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v36.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v35.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8EC058(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v4 = (llvm *)sub_1CD6482A0((_DWORD *)(a1 + 16));
  uint64_t v6 = v4;
  if (*(_DWORD *)(a1 + 384))
  {
    BOOL v7 = (*((_WORD *)v4 + 9) & 8) != 0 && !llvm::canSimplifyInvokeNoUnwind(v4, v5);
    uint64_t v8 = *(unsigned int *)(a1 + 128);
    if (v8)
    {
      unint64_t v9 = *(uint64_t **)(a1 + 120);
      uint64_t v10 = 8 * v8;
      do
      {
        sub_1CD65DEA4(a1 + 200, v9++);
        v10 -= 8;
      }
      while (v10);
    }
    uint64_t v11 = *(unsigned int *)(a1 + 280);
    if (v11)
    {
      uint64_t v12 = *(uint64_t **)(a1 + 272);
      uint64_t v13 = 8 * v11;
      uint64_t v14 = 1;
      while (1)
      {
        uint64_t v15 = *v12;
        unsigned int v16 = *(unsigned __int8 *)(*v12 + 16) - 33;
        BOOL v17 = v16 > 0x33;
        uint64_t v18 = (1 << v16) & 0x8000000000041;
        if (v17 || v18 == 0) {
          goto LABEL_16;
        }
        if (*((unsigned char *)sub_1CC8B8D14((uint64_t)a2, *v12, 0, a1, 1, 1, 1) + 41))
        {
          if (*(unsigned char *)(v15 + 16) != 33)
          {
            uint64_t v20 = *(void *)(v15 + 32);
            if (v20) {
              BOOL v21 = v20 == *(void *)(v15 + 40) + 40;
            }
            else {
              BOOL v21 = 1;
            }
            if (v21) {
              uint64_t v22 = 0;
            }
            else {
              uint64_t v22 = v20 - 24;
            }
            sub_1CD65E44C((uint64_t)a2, v22);
            goto LABEL_27;
          }
        }
        else if (v7 || *(unsigned char *)(v15 + 16) != 33)
        {
          goto LABEL_16;
        }
        sub_1CD65E3D0((uint64_t)a2, v15);
LABEL_27:
        uint64_t v14 = 0;
LABEL_16:
        ++v12;
        v13 -= 8;
        if (!v13) {
          goto LABEL_29;
        }
      }
    }
    uint64_t v14 = 1;
LABEL_29:
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C198, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_1EA61C198))
    {
      __cxa_guard_release(&qword_1EA61C198);
    }
    BOOL v23 = (char *)v6 + 72;
    uint64_t v24 = *((void *)v6 + 10);
    if ((char *)v24 != v23)
    {
      uint64_t v25 = (uint64_t *)(a1 + 376);
      uint64_t v26 = (uint64_t)(a2 + 4624);
      do
      {
        if (v24) {
          uint64_t v27 = v24 - 24;
        }
        else {
          uint64_t v27 = 0;
        }
        uint64_t v29 = 0;
        uint64_t v30 = v27;
        if ((sub_1CD420258(v25, &v30, &v29) & 1) == 0)
        {
          uint64_t v30 = v27;
          sub_1CC261774(v26, &v30);
          uint64_t v14 = 0;
        }
        uint64_t v24 = *(void *)(v24 + 8);
      }
      while ((char *)v24 != v23);
    }
  }
  else
  {
    sub_1CD65E2F4(a2, v4);
    return 0;
  }
  return v14;
}

uint64_t sub_1CC8EC27C(uint64_t a1, llvm::Attributor *a2)
{
  v120[8] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(unsigned char **)(a1 + 120);
  uint64_t v5 = a1 + 48;
  uint64_t v99 = a1 + 120;
  uint64_t v6 = &v4[8 * *(unsigned int *)(a1 + 128)];
  unsigned int v118 = v120;
  uint64_t v119 = 0x800000000;
  sub_1CD47792C((unsigned int *)&v118, v4, v6);
  uint64_t v110 = 1;
  int64x2_t v111 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v112 = v111;
  int64x2_t v113 = v111;
  int64x2_t v114 = v111;
  uint64_t v115 = v117;
  uint64_t v116 = 0x800000000;
  uint64_t v107 = v109;
  uint64_t v108 = 0x800000000;
  unsigned int v7 = v119;
  if (!v119)
  {
    if (*(_DWORD *)(a1 + 128)) {
      goto LABEL_238;
    }
    uint64_t v8 = 1;
LABEL_221:
    unint64_t v89 = sub_1CD6482A0((_DWORD *)(a1 + 16)) + 72;
    uint64_t v90 = -1;
    unint64_t v91 = v89;
    do
    {
      unint64_t v91 = *(void *)(v91 + 8);
      ++v90;
    }
    while (v91 != v89);
    if (*(_DWORD *)(a1 + 384) == v90)
    {
      uint64_t v92 = *(unsigned int *)(a1 + 280);
      if (v92)
      {
        int v93 = *(uint64_t **)(a1 + 272);
        uint64_t v94 = 8 * v92;
        while (2)
        {
          uint64_t v95 = *v93;
          int v96 = *(unsigned __int8 *)(*v93 + 16);
          if ((v96 - 29) <= 0xA && v96 != 30)
          {
            switch(*(unsigned char *)(*v93 + 16))
            {
              case 0x1E:
                goto LABEL_240;
              case 0x1F:
                int v98 = (*(_DWORD *)(v95 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_232;
              case 0x20:
              case 0x26:
                int v98 = (*(_DWORD *)(v95 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_232;
              case 0x21:
              case 0x25:
                goto LABEL_210;
              case 0x24:
                int v98 = *(_WORD *)(v95 + 18) & 1;
                goto LABEL_232;
              case 0x27:
                int v98 = *(_DWORD *)(v95 + 80) + 1;
LABEL_232:
                if (!v98) {
                  goto LABEL_233;
                }
                goto LABEL_210;
              default:
LABEL_233:
                ++v93;
                v94 -= 8;
                if (!v94) {
                  goto LABEL_239;
                }
                continue;
            }
          }
          break;
        }
      }
      else
      {
LABEL_239:
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
      }
    }
    goto LABEL_210;
  }
  uint64_t v100 = v5;
  uint64_t v8 = 1;
  do
  {
    uint64_t v103 = 0;
    uint64_t v9 = v118[v7 - 1];
    LODWORD(v119) = v7 - 1;
    int v10 = *(unsigned __int8 *)(v9 + 16);
    if ((v10 - 29) >= 0xB)
    {
      do
      {
        if (v10 - 33 <= 0x33
          && ((1 << (v10 - 33)) & 0x8000000000041) != 0)
        {
          break;
        }
        uint64_t v14 = *(void *)(v9 + 32);
        uint64_t v15 = *(void *)(v9 + 40) + 40;
        uint64_t v9 = v14 - 24;
        BOOL v16 = !v14 || v14 == v15;
        uint64_t v17 = v16 ? 0 : v14 - 24;
        int v10 = *(unsigned __int8 *)(v17 + 16);
      }
      while ((v10 - 29) > 0xA);
    }
    uint64_t v103 = v9;
    LODWORD(v108) = 0;
    if (v10 > 0x20u)
    {
      if (v10 == 33)
      {
        BOOL v30 = sub_1CC8ED314((uint64_t)a2, v9, a1, (uint64_t)&v107);
        BOOL v32 = v30;
        std::string v33 = *(llvm **)(*(void *)(v9 + 40) + 56);
        if ((*((_WORD *)v33 + 9) & 8) == 0 || llvm::canSimplifyInvokeNoUnwind(v33, v31))
        {
          std::string v34 = sub_1CC8B82A4((uint64_t)a2, v9, 0, a1, 1, 1, 1);
          if (*((unsigned char *)v34 + 41))
          {
            if (*((unsigned char *)v34 + 40)) {
              char v35 = v32;
            }
            else {
              char v35 = 1;
            }
            if (v35) {
              goto LABEL_182;
            }
            goto LABEL_156;
          }
          uint64_t v44 = *(void *)(*(void *)(v9 - 64) + 48);
          if (v44) {
            uint64_t v45 = v44 - 24;
          }
          else {
            uint64_t v45 = 0;
          }
          if (v108 >= (unint64_t)HIDWORD(v108)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v107 + v108) = v45;
          unsigned int v46 = v108 + 1;
          LODWORD(v108) = v108 + 1;
          if (v32)
          {
LABEL_182:
            sub_1CD65DEA4((uint64_t)&v110, &v103);
            goto LABEL_163;
          }
        }
        else
        {
          uint64_t v74 = *(void *)(*(void *)(v9 - 64) + 48);
          if (v74) {
            uint64_t v75 = v74 - 24;
          }
          else {
            uint64_t v75 = 0;
          }
          if (v108 >= (unint64_t)HIDWORD(v108)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v107 + v108) = v75;
          unsigned int v46 = v108 + 1;
          LODWORD(v108) = v108 + 1;
          if (v32) {
            goto LABEL_182;
          }
        }
        if (!v46) {
          goto LABEL_179;
        }
        goto LABEL_157;
      }
      if (v10 != 84)
      {
LABEL_27:
        uint64_t v18 = *(void *)(v9 + 40);
        uint64_t v19 = *(void *)(v18 + 40);
        if (v19 != v18 + 40)
        {
          if (v19) {
            uint64_t v20 = v19 - 24;
          }
          else {
            uint64_t v20 = 0;
          }
          if (*(unsigned char *)(v20 + 16) != 30)
          {
            int v73 = 2;
            switch(*(unsigned char *)(v20 + 16))
            {
              case 0x1E:
LABEL_240:
                __break(1u);
                JUMPOUT(0x1CC8ECE14);
              case 0x1F:
                int v73 = (*(_DWORD *)(v20 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_131;
              case 0x20:
              case 0x26:
                int v73 = (*(_DWORD *)(v20 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_131;
              case 0x21:
                goto LABEL_36;
              case 0x24:
                int v73 = *(_WORD *)(v20 + 18) & 1;
                goto LABEL_131;
              case 0x25:
                int v73 = 1;
                goto LABEL_36;
              case 0x27:
                int v73 = *(_DWORD *)(v20 + 80) + 1;
LABEL_131:
                if (!v73) {
                  goto LABEL_156;
                }
                goto LABEL_36;
              default:
                goto LABEL_156;
            }
          }
          if ((*(_DWORD *)(v20 + 20) & 0x7FFFFFF) == 3) {
            int v73 = 2;
          }
          else {
            int v73 = 1;
          }
LABEL_36:
          for (unsigned int i = 0; i != v73; ++i)
          {
            uint64_t v22 = *(void *)(llvm::Instruction::getSuccessor((llvm::Instruction *)v20, i) + 48);
            if (v22) {
              uint64_t v23 = v22 - 24;
            }
            else {
              uint64_t v23 = 0;
            }
            if (v108 >= (unint64_t)HIDWORD(v108)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v107 + v108) = v23;
            LODWORD(v108) = v108 + 1;
          }
        }
        goto LABEL_156;
      }
      if (sub_1CC8ED314((uint64_t)a2, v9, a1, (uint64_t)&v107)) {
        goto LABEL_182;
      }
    }
    else
    {
      if (v10 == 30)
      {
        v101[0] = 0;
        if ((*(_DWORD *)(v9 + 20) & 0x7FFFFFF) != 3)
        {
          uint64_t v41 = *(void *)(*(void *)(v9 - 32) + 48);
          if (v41) {
            uint64_t v42 = v41 - 24;
          }
          else {
            uint64_t v42 = 0;
          }
          if (HIDWORD(v108))
          {
            uint64_t v43 = 0;
            goto LABEL_154;
          }
          goto LABEL_189;
        }
        uint64_t v24 = *(void *)(v9 - 96);
        unsigned int v25 = *(unsigned __int8 *)(v24 + 16);
        if (v25 != 21)
        {
          if (v25 < 0x1C)
          {
            if (!*(unsigned char *)(v24 + 16)) {
              v24 |= 2uLL;
            }
          }
          else
          {
            unsigned int v26 = v25 - 33;
            BOOL v27 = v26 > 0x33;
            uint64_t v28 = (1 << v26) & 0x8000000000041;
            if (!v27 && v28 != 0) {
              v24 |= 1uLL;
            }
          }
        }
        uint64_t v104 = v24;
        uint64_t v105 = 0;
        AssumedConstant = llvm::Attributor::getAssumedConstant(a2, (const llvm::IRPosition *)&v104, (const llvm::AbstractAttribute *)a1, v101);
        if (v64)
        {
          if (AssumedConstant)
          {
            int v65 = *((unsigned __int8 *)AssumedConstant + 16);
            if ((v65 - 11) < 2) {
              goto LABEL_155;
            }
            if (v65 == 16)
            {
              int v66 = (void *)((char *)AssumedConstant + 24);
              if (*((_DWORD *)AssumedConstant + 8) >= 0x41u) {
                int v66 = (void *)*v66;
              }
              uint64_t v67 = *(void *)(v9 - 32 * (1 - *(_DWORD *)v66) - 32);
              goto LABEL_150;
            }
          }
          uint64_t v68 = *(void *)(*(void *)(v9 - 32) + 48);
          if (v68) {
            uint64_t v69 = v68 - 24;
          }
          else {
            uint64_t v69 = 0;
          }
          if (v108 >= (unint64_t)HIDWORD(v108)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v107 + v108) = v69;
          unsigned int v70 = v108 + 1;
          LODWORD(v108) = v108 + 1;
          uint64_t v71 = *(void *)(*(void *)(v9 - 64) + 48);
          if (v71) {
            uint64_t v72 = v71 - 24;
          }
          else {
            uint64_t v72 = 0;
          }
          if (v70 >= HIDWORD(v108)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v107 + v70) = v72;
          LODWORD(v108) = v108 + 1;
          goto LABEL_156;
        }
      }
      else
      {
        if (v10 != 31) {
          goto LABEL_27;
        }
        v101[0] = 0;
        int v11 = *(_DWORD *)(v9 + 20);
        if ((v11 & 0x40000000) != 0) {
          uint64_t v12 = *(uint64_t **)(v9 - 8);
        }
        else {
          uint64_t v12 = (uint64_t *)(v9 - 32 * (v11 & 0x7FFFFFF));
        }
        uint64_t v36 = *v12;
        unsigned int v37 = *(unsigned __int8 *)(v36 + 16);
        if (v37 != 21)
        {
          if (v37 < 0x1C)
          {
            if (!*(unsigned char *)(v36 + 16)) {
              v36 |= 2uLL;
            }
          }
          else
          {
            unsigned int v38 = v37 - 33;
            BOOL v27 = v38 > 0x33;
            uint64_t v39 = (1 << v38) & 0x8000000000041;
            if (!v27 && v39 != 0) {
              v36 |= 1uLL;
            }
          }
        }
        uint64_t v104 = v36;
        uint64_t v105 = 0;
        unint64_t v47 = llvm::Attributor::getAssumedConstant(a2, (const llvm::IRPosition *)&v104, (const llvm::AbstractAttribute *)a1, v101);
        if (v48)
        {
          if (v47)
          {
            int v49 = *((unsigned __int8 *)v47 + 16);
            if ((v49 - 11) < 2) {
              goto LABEL_155;
            }
            if (v49 == 16)
            {
              unsigned int v50 = *(_DWORD *)(v9 + 20);
              int v51 = (v50 >> 1) & 0x3FFFFFF;
              uint64_t v52 = (v51 - 1);
              if (v51 == 1)
              {
LABEL_92:
                if ((v50 & 0x40000000) != 0) {
                  uint64_t v56 = *(void *)(v9 - 8);
                }
                else {
                  uint64_t v56 = v9 - 32 * (v50 & 0x7FFFFFF);
                }
                uint64_t v67 = *(void *)(v56 + 32);
                goto LABEL_150;
              }
              uint64_t v53 = 0;
              uint64_t v54 = v9 - 32 * (v50 & 0x7FFFFFF);
              uint64_t v55 = 2 * v52;
              while (1)
              {
                if ((v50 & 0x40000000) != 0)
                {
                  if (*(llvm::UndefValue **)(*(void *)(v9 - 8) + 32 * ((v53 + 2) & 0xFFFFFFFE)) == v47)
                  {
                    uint64_t v54 = *(void *)(v9 - 8);
LABEL_147:
                    uint64_t v77 = (v53 + 3);
                    if (v53 == 0x1FFFFFFFCLL) {
                      uint64_t v77 = 1;
                    }
                    uint64_t v67 = *(void *)(v54 + 32 * v77);
LABEL_150:
                    uint64_t v78 = *(void *)(v67 + 48);
                    if (v78) {
                      uint64_t v42 = v78 - 24;
                    }
                    else {
                      uint64_t v42 = 0;
                    }
                    uint64_t v43 = v108;
                    if (v108 < (unint64_t)HIDWORD(v108))
                    {
LABEL_154:
                      *((void *)v107 + v43) = v42;
                      LODWORD(v108) = v108 + 1;
                      goto LABEL_155;
                    }
LABEL_189:
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                }
                else if (*(llvm::UndefValue **)(v54 + 32 * ((v53 + 2) & 0xFFFFFFFE)) == v47)
                {
                  goto LABEL_147;
                }
                v53 += 2;
                if (v55 == v53) {
                  goto LABEL_92;
                }
              }
            }
          }
          uint64_t v57 = *(void *)(v9 + 40);
          uint64_t v58 = *(void *)(v57 + 40);
          if (v58 != v57 + 40)
          {
            if (v58) {
              uint64_t v59 = v58 - 24;
            }
            else {
              uint64_t v59 = 0;
            }
            if (*(unsigned char *)(v59 + 16) != 30)
            {
              int v76 = 2;
              switch(*(unsigned char *)(v59 + 16))
              {
                case 0x1E:
                  goto LABEL_240;
                case 0x1F:
                  int v76 = (*(_DWORD *)(v59 + 20) >> 1) & 0x3FFFFFF;
                  goto LABEL_144;
                case 0x20:
                case 0x26:
                  int v76 = (*(_DWORD *)(v59 + 20) & 0x7FFFFFF) - 1;
                  goto LABEL_144;
                case 0x21:
                  goto LABEL_103;
                case 0x24:
                  int v76 = *(_WORD *)(v59 + 18) & 1;
                  goto LABEL_144;
                case 0x25:
                  int v76 = 1;
                  goto LABEL_103;
                case 0x27:
                  int v76 = *(_DWORD *)(v59 + 80) + 1;
LABEL_144:
                  if (!v76) {
                    goto LABEL_155;
                  }
                  goto LABEL_103;
                default:
                  goto LABEL_155;
              }
            }
            if ((*(_DWORD *)(v59 + 20) & 0x7FFFFFF) == 3) {
              int v76 = 2;
            }
            else {
              int v76 = 1;
            }
LABEL_103:
            for (unsigned int j = 0; j != v76; ++j)
            {
              uint64_t v61 = *(void *)(llvm::Instruction::getSuccessor((llvm::Instruction *)v59, j) + 48);
              if (v61) {
                uint64_t v62 = v61 - 24;
              }
              else {
                uint64_t v62 = 0;
              }
              if (v108 >= (unint64_t)HIDWORD(v108)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v107 + v108) = v62;
              LODWORD(v108) = v108 + 1;
            }
          }
        }
      }
LABEL_155:
      if (v101[0]) {
        goto LABEL_182;
      }
    }
LABEL_156:
    unsigned int v46 = v108;
    if (!v108) {
      goto LABEL_179;
    }
LABEL_157:
    int v79 = *(unsigned __int8 *)(v103 + 16);
    int v80 = v79 - 29;
    if (v79 != 30)
    {
      unsigned int v85 = 0;
      switch(v80)
      {
        case 0:
        case 5:
        case 6:
          goto LABEL_162;
        case 1:
          goto LABEL_240;
        case 2:
          unsigned int v85 = (*(_DWORD *)(v103 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_162;
        case 3:
        case 9:
          unsigned int v85 = (*(_DWORD *)(v103 + 20) & 0x7FFFFFF) - 1;
          goto LABEL_162;
        case 4:
          unsigned int v85 = 2;
          goto LABEL_162;
        case 7:
          unsigned int v85 = *(_WORD *)(v103 + 18) & 1;
          goto LABEL_162;
        case 8:
          unsigned int v85 = 1;
          goto LABEL_162;
        case 10:
          unsigned int v85 = *(_DWORD *)(v103 + 80) + 1;
          goto LABEL_162;
        default:
          goto LABEL_163;
      }
    }
    if ((*(_DWORD *)(v103 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v85 = 2;
    }
    else {
      unsigned int v85 = 1;
    }
LABEL_162:
    if (v46 < v85)
    {
LABEL_179:
      if (sub_1CD65DEA4(a1 + 200, &v103)) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = v8;
      }
    }
LABEL_163:
    if (v108)
    {
      BOOL v81 = (uint64_t *)v107;
      uint64_t v82 = 8 * v108;
      do
      {
        uint64_t v83 = *v81;
        if (*(unsigned __int8 *)(v103 + 16) - 29 >= 0xB
          || (uint64_t v84 = *(void *)(v83 + 40),
              *(void *)BOOL v101 = *(void *)(v103 + 40),
              uint64_t v102 = v84,
              sub_1CD459424((uint64_t)&v104, a1 + 352, (uint64_t *)v101),
              v106 ? (uint64_t v8 = 0) : (uint64_t v8 = v8),
              sub_1CC8ED20C(a1, a2, *(void *)(v83 + 40))))
        {
          if (v119 >= (unint64_t)HIDWORD(v119)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v118[v119] = v83;
          LODWORD(v119) = v119 + 1;
        }
        ++v81;
        v82 -= 8;
      }
      while (v82);
    }
    unsigned int v7 = v119;
  }
  while (v119);
  uint64_t v5 = v100;
  if (v116 != *(_DWORD *)(a1 + 128)) {
    goto LABEL_238;
  }
  if (v116)
  {
    __int16 v86 = (uint64_t *)v115;
    uint64_t v87 = 8 * v116;
    while (1)
    {
      uint64_t v104 = *v86;
      *(void *)BOOL v101 = 0;
      if ((sub_1CD4AC5C0(v100, &v104, v101) & 1) == 0) {
        break;
      }
      ++v86;
      v87 -= 8;
      if (!v87) {
        goto LABEL_209;
      }
    }
LABEL_238:
    sub_1CD65E4C8(v5, (unsigned int *)&v110);
    sub_1CD41C56C(v99, (uint64_t)&v115);
    uint64_t v8 = 0;
  }
LABEL_209:
  if (!*(_DWORD *)(a1 + 128)) {
    goto LABEL_221;
  }
LABEL_210:
  if (v107 != v109) {
    free(v107);
  }
  if (v115 != v117) {
    free(v115);
  }
  if ((v110 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v111.i64[0], 8);
  }
  if (v118 != v120) {
    free(v118);
  }
  return v8;
}

uint64_t sub_1CC8ECEC4()
{
  return 0;
}

uint64_t sub_1CC8ECECC()
{
  return 0;
}

uint64_t sub_1CC8ECED4(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 41)) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = a2;
  return sub_1CD420258((uint64_t *)(a1 + 376), &v4, &v3) ^ 1;
}

uint64_t sub_1CC8ECF18(unsigned char *a1)
{
  if (a1[40]) {
    return (*(uint64_t (**)(void))(*(void *)a1 + 128))();
  }
  else {
    return 0;
  }
}

uint64_t sub_1CC8ECF4C(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 41)) {
    return 0;
  }
  uint64_t v5 = *(void **)(a2 + 40);
  uint64_t v10 = 0;
  int v11 = v5;
  if (sub_1CD420258((uint64_t *)(a1 + 376), &v11, &v10))
  {
    uint64_t v6 = (void *)(a2 + 24);
    if (*(void *)(*(void *)(a2 + 40) + 48) == a2 + 24) {
      return 0;
    }
    unsigned int v7 = (void *)*v6;
    if (!*v6) {
      return 0;
    }
    uint64_t v8 = a1 + 200;
    uint64_t v9 = a1 + 48;
    while (1)
    {
      uint64_t v10 = 0;
      int v11 = v7 - 3;
      if (sub_1CD4AC5C0(v8, &v11, &v10)) {
        break;
      }
      uint64_t v10 = 0;
      int v11 = v7 - 3;
      if (sub_1CD4AC5C0(v9, &v11, &v10)) {
        break;
      }
      if (*(void **)(v7[2] + 48) == v7) {
        return 0;
      }
      uint64_t result = 0;
      unsigned int v7 = (void *)*v7;
      if (!v7) {
        return result;
      }
    }
  }
  return 1;
}

uint64_t sub_1CC8ED028(unsigned char *a1)
{
  if (a1[40]) {
    return (*(uint64_t (**)(void))(*(void *)a1 + 144))();
  }
  else {
    return 0;
  }
}

uint64_t sub_1CC8ED05C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (result) {
    return sub_1CD4594B8(*(void *)(a1 + 352), *(_DWORD *)(a1 + 368), a2, a3, &v7) ^ 1;
  }
  return result;
}

uint64_t sub_1CC8ED0DC(uint64_t a1)
{
  return sub_1CC8ED120(a1 - 32);
}

void sub_1CC8ED0E4(uint64_t a1)
{
  sub_1CC8ED120(a1 - 32);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8ED120(uint64_t a1)
{
  *(void *)a1 = &unk_1F2625DE0;
  *(void *)(a1 + 32) = &unk_1F2625EA0;
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 376), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 352), 8);
  unint64_t v2 = *(void **)(a1 + 272);
  if (v2 != (void *)(a1 + 288)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 200) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 208), 8);
  }
  uint64_t v3 = *(void **)(a1 + 120);
  if (v3 != (void *)(a1 + 136)) {
    free(v3);
  }
  if ((*(unsigned char *)(a1 + 48) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 56), 8);
  }
  *(void *)a1 = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 + 8));
  return a1;
}

BOOL sub_1CC8ED20C(uint64_t a1, llvm::Attributor *a2, uint64_t a3)
{
  uint64_t v16 = a3;
  sub_1CD4201D0(a1 + 376, &v16, (uint64_t)v17);
  int v5 = v18;
  if (v18)
  {
    uint64_t v6 = a3 + 40;
    for (uint64_t i = *(void *)(a3 + 48); i != v6; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v8 = i - 24;
      if (!i) {
        uint64_t v8 = 0;
      }
      unsigned int v9 = *(unsigned __int8 *)(v8 + 16) - 33;
      BOOL v10 = v9 > 0x33;
      uint64_t v11 = (1 << v9) & 0x8000000000041;
      if (!v10 && v11 != 0)
      {
        uint64_t v13 = *(void *)(i - 56);
        if (v13)
        {
          if (!*(unsigned char *)(v13 + 16)
            && *(void *)(v13 + 24) == *(void *)(i + 48)
            && (*(_DWORD *)(v13 + 32) & 0xFu) - 9 >= 0xFFFFFFFE
            && *((unsigned char *)a2 + 5467) != 0)
          {
            llvm::Attributor::identifyDefaultAbstractAttributes(a2, v13);
          }
        }
      }
    }
  }
  return v5 != 0;
}

BOOL sub_1CC8ED314(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = sub_1CC8B8D14(a1, a2, 0, a3, 1, 1, 1);
  if (*((unsigned char *)v6 + 41)) {
    return *((unsigned char *)v6 + 40) == 0;
  }
  if (*(unsigned __int8 *)(a2 + 16) - 29 > 0xA)
  {
    uint64_t v11 = *(void *)(a2 + 32);
    uint64_t v12 = *(void *)(a2 + 40) + 40;
    uint64_t v13 = v11 - 24;
    BOOL v15 = v11 == v12 || v11 == 0;
    unsigned int v16 = *(_DWORD *)(a4 + 8);
    if (v16 >= *(_DWORD *)(a4 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    BOOL result = 0;
    if (v15) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = v13;
    }
    *(void *)(*(void *)a4 + 8 * v16) = v17;
  }
  else
  {
    uint64_t v8 = *(void *)(llvm::Instruction::getSuccessor((llvm::Instruction *)a2, 0) + 48);
    if (v8) {
      uint64_t v9 = v8 - 24;
    }
    else {
      uint64_t v9 = 0;
    }
    unsigned int v10 = *(_DWORD *)(a4 + 8);
    if (v10 >= *(_DWORD *)(a4 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    BOOL result = 0;
    *(void *)(*(void *)a4 + 8 * v10) = v9;
  }
  ++*(_DWORD *)(a4 + 8);
  return result;
}

void sub_1CC8ED440(uint64_t a1)
{
  sub_1CC8ED120(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8ED480(uint64_t a1)
{
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  return 0;
}

uint64_t sub_1CC8ED490(uint64_t a1)
{
  return sub_1CC8ED120(a1 - 32);
}

void sub_1CC8ED498(uint64_t a1)
{
  sub_1CC8ED120(a1 - 32);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8ED4D4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8ED518(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8ED57C(uint64_t a1, uint64_t a2)
{
  sub_1CC8EDCBC(a1, a2);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 16) - 11 <= 1)
  {
LABEL_2:
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);
    return v4(a1 + 32);
  }
  unint64_t v6 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  unint64_t v7 = v6;
  unsigned int v8 = *(unsigned __int8 *)(v6 + 16);
  if (v8 <= 0x1B) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = v6;
  }
  uint64_t result = sub_1CC8EDDC0(a1, a2, v9);
  if ((result & 1) == 0)
  {
    if (v8 >= 0x1C && *(unsigned char *)(v7 + 16) == 61)
    {
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 41) & 0xFE | *(unsigned char *)(a1 + 40);
      return result;
    }
    goto LABEL_2;
  }
  return result;
}

uint64_t sub_1CC8ED65C@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  if (*(unsigned char *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 2)) + 16) == 61
    && (uint64_t result = (*(uint64_t (**)(void))(a1[4] + 16))(), result))
  {
    *(unsigned char *)(a2 + 23) = 18;
    strcpy((char *)a2, "assumed-dead-store");
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 112))(a1);
    int v5 = "assumed-live";
    if (result) {
      int v5 = "assumed-dead";
    }
    *(unsigned char *)(a2 + 23) = 12;
    *(void *)a2 = *(void *)v5;
    *(_DWORD *)(a2 + 8) = *((_DWORD *)v5 + 2);
    *(unsigned char *)(a2 + 12) = 0;
  }
  return result;
}

uint64_t sub_1CC8ED744(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  unsigned int v5 = *(unsigned __int8 *)(v4 + 16);
  if (v5 < 0x1C) {
    return 1;
  }
  uint64_t v7 = v4;
  if (v5 == 61 || (int v8 = sub_1CC8EDDC0(a1, a2, v4), result = 1, v8) && *(unsigned char *)(v7 + 16) != 33)
  {
    sub_1CD65E620(a2, v7);
    return 0;
  }
  return result;
}

void sub_1CC8ED7D0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1A0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1A0))
  {
    __cxa_guard_release(&qword_1EA61C1A0);
  }
}

uint64_t sub_1CC8ED824(void *a1, llvm::Attributor *a2)
{
  void v30[4] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 2);
  unint64_t v5 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 2));
  unsigned int v6 = *(unsigned __int8 *)(v5 + 16);
  if (v6 <= 0x1B) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v5;
  }
  if (v6 == 61)
  {
    if ((*(_WORD *)(v5 + 18) & 1) == 0)
    {
      BOOL v23 = 0;
      uint64_t v25 = 1;
      int64x2_t v26 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      int64x2_t v27 = v26;
      uint64_t v28 = v30;
      uint64_t v29 = 0x400000000;
      int PotentialCopiesOfStoredValue = llvm::AA::getPotentialCopiesOfStoredValue(a2, v7, &v25, (const llvm::AbstractAttribute *)a1, &v23, 0);
      uint64_t v9 = (char *)v28;
      if (PotentialCopiesOfStoredValue)
      {
        if (v29)
        {
          uint64_t v10 = 8 * v29 - 8;
          do
          {
            uint64_t v11 = *(void *)v9;
            unsigned int v12 = *(unsigned __int8 *)(*(void *)v9 + 16);
            if (v12 != 21)
            {
              if (v12 < 0x1C)
              {
                if (!*(unsigned char *)(*(void *)v9 + 16)) {
                  v11 |= 2uLL;
                }
              }
              else
              {
                unsigned int v13 = v12 - 33;
                BOOL v14 = v13 > 0x33;
                uint64_t v15 = (1 << v13) & 0x8000000000041;
                if (!v14 && v15 != 0) {
                  v11 |= 1uLL;
                }
              }
            }
            v24[0] = v11;
            v24[1] = 0;
            int isAssumedDead = llvm::Attributor::isAssumedDead((uint64_t)a2, (uint64_t)v24, (uint64_t)a1, 0, &v23, 0, 1);
            char v18 = isAssumedDead;
            if (!isAssumedDead) {
              break;
            }
            v9 += 8;
            uint64_t v19 = v10;
            v10 -= 8;
          }
          while (v19);
          uint64_t v9 = (char *)v28;
        }
        else
        {
          char v18 = 1;
        }
      }
      else
      {
        char v18 = 0;
      }
      if (v9 != (char *)v30) {
        free(v9);
      }
      if (v25)
      {
        if (v18) {
          return 1;
        }
      }
      else
      {
        MEMORY[0x1D25D9CD0](v26.i64[0], 8);
        if (v18) {
          return 1;
        }
      }
    }
    return (*(uint64_t (**)(void *))(a1[4] + 40))(a1 + 4);
  }
  else
  {
    if (sub_1CC8EDDC0((uint64_t)a1, (uint64_t)a2, v7))
    {
      unint64_t v22 = sub_1CD6482F0(v4);
      if (sub_1CC8EDED0((const llvm::AbstractAttribute *)a1, a2, v22)) {
        return 1;
      }
    }
    uint64_t v20 = *(uint64_t (**)(void *))(a1[4] + 40);
    return v20(a1 + 4);
  }
}

BOOL sub_1CC8EDABC(uint64_t a1)
{
  return (~*(unsigned __int8 *)(a1 + 41) & 3) == 0;
}

BOOL sub_1CC8EDAD0(uint64_t a1)
{
  return (~*(unsigned __int8 *)(a1 + 40) & 3) == 0;
}

uint64_t sub_1CC8EDAE4()
{
  return 0;
}

uint64_t sub_1CC8EDAEC()
{
  return 0;
}

uint64_t sub_1CC8EDAF4(_DWORD *a1, uint64_t a2)
{
  if (sub_1CC8AB830(a1 + 4) != a2) {
    return 0;
  }
  unint64_t v4 = *(uint64_t (**)(_DWORD *))(*(void *)a1 + 112);

  return v4(a1);
}

uint64_t sub_1CC8EDB6C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 120);
    return v3(a1);
  }
  return result;
}

BOOL sub_1CC8EDBF4(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 41) & 2) != 0 && *(unsigned char *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 16) == 61;
}

uint64_t *sub_1CC8EDC2C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EDC54(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EDCBC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (result)
  {
    uint64_t v5 = result;
    uint64_t result = *(void *)(a2 + 80);
    if (*(void *)(result + 24) != *(void *)(result + 32))
    {
      uint64_t v6 = 0;
      uint64_t v7 = v5;
      uint64_t result = sub_1CD420258((uint64_t *)result, &v7, &v6);
      if ((result & 1) == 0) {
        return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
      }
    }
  }
  return result;
}

uint64_t sub_1CC8EDD48@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  unint64_t v4 = "assumed-live";
  if (result) {
    unint64_t v4 = "assumed-dead";
  }
  *(unsigned char *)(a2 + 23) = 12;
  *(void *)a2 = *(void *)v4;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)v4 + 2);
  *(unsigned char *)(a2 + 12) = 0;
  return result;
}

uint64_t sub_1CC8EDDC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 1;
  }
  if (llvm::wouldInstructionBeTriviallyDead(a3, 0)) {
    return 1;
  }
  int v7 = *(unsigned __int8 *)(a3 + 16);
  if (v7 != 33 && v7 != 39)
  {
    if (v7 != 84) {
      return 0;
    }
    uint64_t v8 = *(void *)(a3 - 32);
    if (v8)
    {
      if (!*(unsigned char *)(v8 + 16) && *(void *)(v8 + 24) == *(void *)(a3 + 72) && (*(unsigned char *)(v8 + 33) & 0x20) != 0) {
        return 0;
      }
    }
  }
  v11[0] = a3;
  v11[1] = 0;
  uint64_t v9 = sub_1CC8B82A4(a2, a3, 0, a1, 2, 1, 1);
  if (!*((unsigned char *)v9 + 41)) {
    return 0;
  }
  if (!*((unsigned char *)v9 + 40)) {
    llvm::Attributor::recordDependence(a2, (uint64_t)v9, a1, 1);
  }
  return sub_1CC8AAAB0(a2, v11, a1, 0, &v10);
}

uint64_t sub_1CC8EDED0(const llvm::AbstractAttribute *a1, llvm::Attributor *a2, uint64_t a3)
{
  if (*(unsigned char *)(*(void *)a3 + 8) == 7 || *(void *)(a3 + 8) == 0) {
    return 1;
  }
  unsigned int v8 = *(unsigned __int8 *)(a3 + 16);
  if (v8 < 0x15) {
    return llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8EE01C, (uint64_t)v17, a1, a3, 0, 0, 0, 0, v15);
  }
  if (v8 < 0x1C)
  {
LABEL_11:
    v16[0] = 0;
    if (v8 == 21) {
      goto LABEL_20;
    }
    if (v8 < 0x1C)
    {
      if (!v8)
      {
        uint64_t v9 = a3 | 2;
LABEL_21:
        v17[0] = v9;
        v17[1] = 0;
        AssumedConstant = llvm::Attributor::getAssumedConstant(a2, (const llvm::IRPosition *)v17, a1, v16);
        if (v13 && !AssumedConstant) {
          return llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8EE01C, (uint64_t)v17, a1, a3, 0, 0, 0, 0, v15);
        }
        return 1;
      }
      goto LABEL_20;
    }
LABEL_17:
    unsigned int v11 = v8 - 33;
    if (v11 <= 0x33 && ((1 << v11) & 0x8000000000041) != 0)
    {
      uint64_t v9 = a3 | 1;
      goto LABEL_21;
    }
LABEL_20:
    uint64_t v9 = a3;
    goto LABEL_21;
  }
  char v10 = (uint64_t *)*((void *)a2 + 10);
  if (v10[3] == v10[4])
  {
    v16[0] = 0;
    goto LABEL_17;
  }
  uint64_t v14 = *(void *)(*(void *)(a3 + 40) + 56);
  *(void *)unsigned int v16 = 0;
  v17[0] = v14;
  uint64_t result = sub_1CD420258(v10, v17, v16);
  if (result)
  {
    unsigned int v8 = *(unsigned __int8 *)(a3 + 16);
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_1CC8EE01C()
{
  return 0;
}

void *sub_1CC8EE024(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EE068(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EE0CC(uint64_t a1, uint64_t a2)
{
  sub_1CC8ED57C(a1, a2);
  unint64_t v4 = (llvm::GlobalValue *)sub_1CD6482A0((_DWORD *)(a1 + 16));
  uint64_t result = sub_1CD64EF44(a2, v4);
  if ((result & 1) == 0)
  {
    uint64_t v6 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);
    return v6(a1 + 32);
  }
  return result;
}

BOOL sub_1CC8EE14C(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (!llvm::Attributor::isValidFunctionSignatureRewrite(a2, AssociatedArgument)) {
    return 1;
  }
  unsigned int v8 = 0;
  void v6[3] = 0;
  char v5 = llvm::Attributor::registerFunctionSignatureRewrite(a2, AssociatedArgument, 0, 0);
  if (!v6) {
    (*(void (**)(void *))(v6[0] + 32))(v6);
  }
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  return (v5 & 1) == 0;
}

void sub_1CC8EE2CC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1A8))
  {
    __cxa_guard_release(&qword_1EA61C1A8);
  }
}

uint64_t *sub_1CC8EE320(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EE348(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EE3B0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EE3F4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8EE458(uint64_t a1, uint64_t a2)
{
  char v14 = 0;
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  int v7 = llvm::UndefValue::get(**(llvm::UndefValue ***)(*(void *)(v5 + 24) + 16), v6);
  v13[0] = &v14;
  v13[1] = a2;
  void v13[2] = v7;
  int v10 = 1;
  v11[0] = &v10;
  v11[1] = 1;
  unint64_t v8 = sub_1CD648A0C(v4);
  llvm::Attributor::checkForAllInstructions(a2, sub_1CC8EE6DC, (uint64_t)v13, v8, a1, (uint64_t)v11, &v12, 0, 0);
  return v14 == 0;
}

void sub_1CC8EE514()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1B0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1B0))
  {
    __cxa_guard_release(&qword_1EA61C1B0);
  }
}

uint64_t sub_1CC8EE568(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 1;
  int v7 = 1;
  unint64_t v8 = &v7;
  uint64_t v9 = 1;
  unint64_t v5 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8EE74C, (uint64_t)&v10, v5, a1, (uint64_t)&v8, &v11, 0, 0);
  unint64_t v8 = (int *)a1;
  uint64_t v9 = a2;
  if ((llvm::Attributor::checkForAllCallSites(a2, (uint64_t (*)(uint64_t, uint64_t *))sub_1CC8EE754, (uint64_t)&v8, a1, 1, &v11) & 1) == 0)return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32); {
  return v4;
  }
}

uint64_t *sub_1CC8EE64C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EE674(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EE6DC(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 20);
  uint64_t v4 = a2 - 32 * (v3 & 0x7FFFFFF);
  if (*(unsigned __int8 *)(*(void *)v4 + 16) - 11 >= 2)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    if ((v3 & 0x40000000) != 0) {
      uint64_t v4 = *(void *)(a2 - 8);
    }
    **(unsigned char **)a1 |= sub_1CD65D61C(v7, v4, *(llvm::Value **)(a1 + 16));
  }
  return 1;
}

uint64_t sub_1CC8EE74C()
{
  return 1;
}

uint64_t sub_1CC8EE754(const llvm::AbstractAttribute **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v6 = *(void *)a2;
  uint64_t v7 = &v9;
  uint64_t v8 = 0;
  if (*(_DWORD *)(a2 + 16))
  {
    sub_1CD41B598((uint64_t)&v7, a2 + 8);
    if (!v8)
    {
      uint64_t v3 = v6;
      if (v6) {
        goto LABEL_3;
      }
    }
  }
  else if (v3)
  {
LABEL_3:
    uint64_t v4 = sub_1CC8EDED0(*a1, a1[1], v3);
    goto LABEL_6;
  }
  uint64_t v4 = 0;
LABEL_6:
  if (v7 != &v9) {
    free(v7);
  }
  return v4;
}

void *sub_1CC8EE7E4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EE828(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EE88C(uint64_t a1, uint64_t a2)
{
  sub_1CC8ED57C(a1, a2);
  if (*(unsigned __int8 *)(sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 16) - 11 > 1)
  {
    unint64_t v6 = sub_1CC8AB830((_DWORD *)(a1 + 16));
    uint64_t result = sub_1CC8EDDC0(a1, a2, v6);
    *(unsigned char *)(a1 + 42) = result;
  }
  else
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);
    return v4(a1 + 32);
  }
  return result;
}

size_t sub_1CC8EE938@<X0>(unsigned char *a1@<X0>, void *a2@<X8>)
{
  if ((*(uint64_t (**)(unsigned char *))(*(void *)a1 + 112))(a1))
  {
    uint64_t v4 = "assumed-dead";
  }
  else if (a1[41])
  {
    uint64_t v4 = "assumed-dead-users";
  }
  else
  {
    uint64_t v4 = "assumed-live";
  }
  size_t result = strlen(v4);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v6 = result;
  if (result >= 0x17)
  {
    uint64_t v7 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v7 = result | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = result;
    if (!result) {
      goto LABEL_14;
    }
  }
  size_t result = (size_t)memcpy(a2, v4, v6);
LABEL_14:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

void sub_1CC8EEA28(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 42))
  {
    if (atomic_load_explicit(byte_1EBCDDEA0, memory_order_acquire)) {
      return;
    }
    uint64_t v1 = (__guard *)byte_1EBCDDEA0;
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDEA8, memory_order_acquire)) {
      return;
    }
    uint64_t v1 = (__guard *)byte_1EBCDDEA8;
  }
  if (__cxa_guard_acquire(v1))
  {
    __cxa_guard_release(v1);
  }
}

uint64_t sub_1CC8EEAAC(uint64_t a1, llvm::Attributor *a2)
{
  if (*(unsigned char *)(a1 + 42) && (unint64_t v4 = sub_1CC8AB830((_DWORD *)(a1 + 16)), (sub_1CC8EDDC0(a1, (uint64_t)a2, v4) & 1) == 0))
  {
    uint64_t v5 = 0;
    *(unsigned char *)(a1 + 42) = 0;
  }
  else
  {
    uint64_t v5 = 1;
  }
  unint64_t v6 = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (sub_1CC8EDED0((const llvm::AbstractAttribute *)a1, a2, v6)) {
    return v5;
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);

  return v8(a1 + 32);
}

BOOL sub_1CC8EEB70(uint64_t a1)
{
  return (~*(unsigned __int8 *)(a1 + 41) & 3) == 0 && *(unsigned char *)(a1 + 42) != 0;
}

uint64_t *sub_1CC8EEB98(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EEBC0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EEC28(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EEC6C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8EECD0(uint64_t a1, uint64_t a2)
{
  sub_1CC8EDCBC(a1, a2);
  unint64_t result = sub_1CD6482F0((llvm::IRPosition *)(a1 + 16));
  if (*(unsigned __int8 *)(result + 16) - 11 <= 1)
  {
    unint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40);
    return v4(a1 + 32);
  }
  return result;
}

uint64_t sub_1CC8EED4C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v3 = (llvm::IRPosition *)(a1 + 16);
  unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFCLL;
  if ((~(_BYTE)v4 & 3) == 0) {
    unint64_t v5 = *(void *)(v5 + 24);
  }
  unsigned int v6 = sub_1CD64DE00(v3, 0);
  int v8 = *(_DWORD *)(v5 + 20);
  if ((v8 & 0x40000000) != 0) {
    unint64_t v9 = *(void *)(v5 - 8);
  }
  else {
    unint64_t v9 = v5 - 32 * (v8 & 0x7FFFFFF);
  }
  char v10 = (llvm::UndefValue ***)(v9 + 32 * v6);
  char v11 = llvm::UndefValue::get(**v10, v7);
  return sub_1CD65D61C(a2, (uint64_t)v10, v11) ^ 1;
}

void sub_1CC8EEDCC()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1B8))
  {
    __cxa_guard_release(&qword_1EA61C1B8);
  }
}

uint64_t sub_1CC8EEE20(void *a1, uint64_t a2)
{
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 2));
  if (AssociatedArgument)
  {
    unint64_t v5 = sub_1CC8AC178(a2, AssociatedArgument, 0, (uint64_t)a1, 0, 0, 1);
    unsigned int v6 = (unsigned __int8 *)(*(uint64_t (**)(void *))(*a1 + 40))(a1);
    uint64_t v7 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    LODWORD(v5) = v6[9];
    (*(void (**)(unsigned __int8 *, void))(*(void *)v6 + 48))(v6, *(unsigned __int8 *)(v7 + 9));
    return v5 == v6[9];
  }
  else
  {
    unint64_t v9 = *(uint64_t (**)(void *))(a1[4] + 40);
    return v9(a1 + 4);
  }
}

uint64_t *sub_1CC8EEF44(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EEF6C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EEFD4(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EF018(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EF07C@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "nofree";
  }
  else {
    uint64_t v3 = "may-free";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 6;
  }
  else {
    size_t v4 = 8;
  }
  a2[23] = v4;
  unint64_t result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

void sub_1CC8EF0D8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1C0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1C0))
  {
    __cxa_guard_release(&qword_1EA61C1C0);
  }
}

uint64_t sub_1CC8EF12C(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  v7[0] = a2;
  v7[1] = a1;
  uint64_t v9 = 0xB00000005;
  int v10 = 56;
  v8[0] = &v9;
  v8[1] = 3;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8EF2B4, (uint64_t)v7, v4, a1, (uint64_t)v8, &v6, 0, 0))return 1; {
  else
  }
    return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 40))(a1 + 32);
}

uint64_t *sub_1CC8EF224(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EF24C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8EF2B4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *(void *)(a2 + 64);
  return v5 && (*(unsigned char *)(v5 + 15) & 2) != 0
      || (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 25) & 1) != 0
      || *((unsigned char *)sub_1CC8B87DC(*a1, a2, 0, v4, 0, 0, 1) + 41) != 0;
}

void *sub_1CC8EF338(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EF37C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8EF3E0(uint64_t a1, uint64_t a2)
{
  sub_1CD65EBA4((void *)a1, a2);
  unint64_t result = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8EF450()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1C8))
  {
    __cxa_guard_release(&qword_1EA61C1C8);
  }
}

uint64_t sub_1CC8EF4A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  uint64_t v5 = sub_1CC8B87DC(a2, v4, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned char *)(v3 + 9) == 0;
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 ^ (*(unsigned char *)(v3 + 9) != 0);
}

uint64_t *sub_1CC8EF55C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EF584(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EF5EC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EF630(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8EF694()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1D0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1D0))
  {
    __cxa_guard_release(&qword_1EA61C1D0);
  }
}

uint64_t sub_1CC8EF6E8(void *a1, llvm::Attributor *a2)
{
  unint64_t v4 = (llvm::IRPosition *)(a1 + 2);
  unint64_t v5 = sub_1CD659BC0((llvm::IRPosition *)(a1 + 2));
  uint64_t v6 = 1;
  if (!*((unsigned char *)sub_1CC8B87DC((uint64_t)a2, v5, v7, (uint64_t)a1, 1, 0, 1) + 41))
  {
    unint64_t v9 = sub_1CD6482F0(v4);
    v11[0] = a2;
    v11[1] = a1;
    if ((llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8EF864, (uint64_t)v11, (const llvm::AbstractAttribute *)a1, v9, 0, 1, 1, 0, v10) & 1) == 0)return (*(uint64_t (**)(void *))(a1[4] + 40))(a1 + 4); {
  }
    }
  return v6;
}

uint64_t *sub_1CC8EF7D4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EF7FC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC8EF864(uint64_t *a1, unint64_t a2, unsigned char *a3)
{
  uint64_t v3 = a1[1];
  uint64_t v4 = *(void *)(a2 + 24);
  unsigned int v5 = *(unsigned __int8 *)(v4 + 16);
  if (v5 > 0x3D)
  {
    switch(*(unsigned char *)(v4 + 16))
    {
      case 'M':
      case 'S':
      case 'U':
        break;
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
        return 0;
      case 'T':
        goto LABEL_10;
      default:
        if (v5 != 62) {
          return 0;
        }
        break;
    }
    BOOL result = 1;
    *a3 = 1;
  }
  else
  {
    if (*(unsigned __int8 *)(v4 + 16) > 0x3Bu || v5 == 29) {
      return 1;
    }
    if (v5 != 33 && v5 != 39) {
      return 0;
    }
LABEL_10:
    int v7 = *(_DWORD *)(v4 + 20);
    if (v7 < 0)
    {
      uint64_t v14 = v4 - 32 * (v7 & 0x7FFFFFF);
      uint64_t v15 = *(void *)(v14 - 8);
      if ((v15 & 0xFFFFFFFF0) != 0)
      {
        unint64_t v16 = (a2 - v14) >> 5;
        if (*(_DWORD *)(v14 - v15) <= v16 && *(_DWORD *)(v14 - 12) > v16) {
          return 0;
        }
      }
    }
    unint64_t v8 = v4 - 32 * (v7 & 0x7FFFFFF);
    if (v8 > a2) {
      return 1;
    }
    if (v5 == 84) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = v5 == 39 ? (*(_DWORD *)(v4 + 80) + 1) : 2;
    }
    if (v7 < 0 && (uint64_t v17 = *(void *)(v8 - 8), (v17 & 0xFFFFFFFF0) != 0)) {
      uint64_t v10 = (*(_DWORD *)(v8 - 12) - *(_DWORD *)(v8 - v17));
    }
    else {
      uint64_t v10 = 0;
    }
    if (v4 - 32 * v9 - 32 * v10 - 32 <= a2) {
      return 1;
    }
    unint64_t v11 = a2 - v8;
    uint64_t v12 = *a1;
    if ((v7 & 0x40000000) != 0) {
      unint64_t v8 = *(void *)(v4 - 8);
    }
    return *((unsigned char *)sub_1CC8B87DC(v12, (v8 + (v11 & 0x1FFFFFFFE0)) | 3, 0, v3, 0, 0, 1) + 41) != 0;
  }
  return result;
}

void *sub_1CC8EFA10(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EFA54(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8EFAB8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1D8))
  {
    __cxa_guard_release(&qword_1EA61C1D8);
  }
}

uint64_t *sub_1CC8EFB0C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EFB34(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EFB9C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EFBE0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8EFC44()
{
  return 1;
}

void sub_1CC8EFC4C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1E0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1E0))
  {
    __cxa_guard_release(&qword_1EA61C1E0);
  }
}

uint64_t *sub_1CC8EFCA0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EFCC8(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EFD30(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8EFD74(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8EFDD8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1E8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1E8))
  {
    __cxa_guard_release(&qword_1EA61C1E8);
  }
}

unint64_t sub_1CC8EFE2C(uint64_t a1, uint64_t a2)
{
  unint64_t result = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (result)
  {
    unsigned int v5 = sub_1CC8B87DC(a2, result, 0, a1, 0, 0, 1);
    uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = a1 + 32;
    BOOL v9 = *(unsigned char *)(v7 + 9) == 0;
    (*(void (**)(uint64_t, void))(v8 + 48))(v7, *(unsigned __int8 *)(v6 + 9));
    return v9 ^ (*(unsigned char *)(v7 + 9) != 0);
  }
  else
  {
    *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  }
  return result;
}

uint64_t *sub_1CC8EFEF4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8EFF1C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8EFF84(void *a1)
{
  uint64_t v2 = a1[9];
  uint64_t v3 = a1[10];
  while (v2 != v3)
  {
    uint64_t v4 = *(void *)(v2 + 8);
    unsigned int v5 = *(void **)(v4 + 48);
    if (v5 != (void *)(v4 + 64)) {
      free(v5);
    }
    if ((*(unsigned char *)(v4 + 24) & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)(v4 + 32), 8);
    }
    v2 += 16;
  }
  uint64_t v6 = (void *)a1[15];
  uint64_t v7 = (void *)a1[16];
  if (v6 != v7)
  {
    do
    {
      uint64_t v8 = v6[1];
      BOOL v9 = *(void **)(v8 + 40);
      if (v9 != (void *)(v8 + 56)) {
        free(v9);
      }
      if ((*(unsigned char *)(v8 + 16) & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)(v8 + 24), 8);
      }
      v6 += 2;
    }
    while (v6 != v7);
    uint64_t v6 = (void *)a1[15];
  }
  if (v6)
  {
    a1[16] = v6;
    operator delete(v6);
  }
  MEMORY[0x1D25D9CD0](a1[12], 8);
  uint64_t v10 = (void *)a1[9];
  if (v10)
  {
    a1[10] = v10;
    operator delete(v10);
  }
  MEMORY[0x1D25D9CD0](a1[6], 8);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F0094(void *a1)
{
  sub_1CC8EFF84(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F00CC(uint64_t a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = *(void *)(sub_1CD6482A0((_DWORD *)(a1 + 16)) + 40);
  if (**(void **)(a2[11] + 440)) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  v18[2] = a2;
  uint64_t v19 = 0;
  v18[0] = &v19;
  v18[1] = a1;
  uint64_t v20 = 0xB00000005;
  LODWORD(v21) = 56;
  v22[0] = &v20;
  v22[1] = 3;
  unint64_t v7 = sub_1CD648A0C(v4);
  llvm::Attributor::checkForAllInstructions((uint64_t)a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8F18E4, (uint64_t)v18, v7, a1, (uint64_t)v22, &v17, 0, 1);
  v22[0] = &unk_1F2626C20;
  BOOL v23 = v22;
  uint64_t v8 = *(uint64_t **)(a1 + 72);
  BOOL v9 = *(uint64_t **)(a1 + 80);
  while (v8 != v9)
  {
    uint64_t v10 = *v8;
    v8 += 2;
    uint64_t v20 = v10 | 1;
    uint64_t v21 = 0;
    unint64_t v11 = sub_1CD65EF00(a2, &v20);
    sub_1CC8F1F2C((unsigned int *)v11 + 4, (uint64_t)v22);
  }
  char v13 = *(uint64_t **)(a1 + 120);
  uint64_t v12 = *(uint64_t **)(a1 + 128);
  while (v13 != v12)
  {
    uint64_t v14 = *v13;
    v13 += 2;
    uint64_t v20 = v14 | 1;
    uint64_t v21 = 0;
    uint64_t v15 = sub_1CD65EF00(a2, &v20);
    sub_1CC8F1F2C((unsigned int *)v15 + 4, (uint64_t)v22);
  }
  uint64_t result = (uint64_t)v23;
  if (v23 == v22) {
    return (*(uint64_t (**)(void *))(v22[0] + 32))(v22);
  }
  if (v23) {
    return (*(uint64_t (**)(void))(*v23 + 40))();
  }
  return result;
}

void sub_1CC8F02D0(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 72);
  uint64_t v4 = *(void *)(a1 + 80);
  if (v3 == v4)
  {
    unsigned int v6 = 0;
    unsigned int v5 = 0;
  }
  else
  {
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    do
    {
      if (*(_DWORD *)(*(void *)(v3 + 8) + 12) == 2) {
        ++v6;
      }
      else {
        ++v5;
      }
      v3 += 16;
    }
    while (v3 != v4);
  }
  std::to_string(&v15, v5);
  unint64_t v7 = std::string::insert(&v15, 0, "[H2S] Mallocs Good/Bad: ");
  std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  BOOL v9 = std::string::append(&v16, "/");
  std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, v6);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  char v13 = std::string::append(&v17, (const std::string::value_type *)p_p, size);
  *a2 = *v13;
  v13->__r_.__value_.__r.__words[0] = 0;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8F0428(uint64_t a1, llvm::Attributor *a2)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (**(void **)(*((void *)a2 + 11) + 440)) {
    BOOL v5 = *(void *)(v4 + 40) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  unint64_t v84 = v4;
  if (!v5) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v6 = *(void *)(a1 + 80);
  if (v7 != v6)
  {
    uint64_t result = 1;
    while (1)
    {
      BOOL v9 = *(uint64_t **)(v7 + 8);
      if (*((_DWORD *)v9 + 3) != 2) {
        break;
      }
LABEL_9:
      v7 += 16;
      if (v7 == v6) {
        return result;
      }
    }
    uint64_t v10 = *((unsigned int *)v9 + 14);
    if (v10)
    {
      unint64_t v11 = (uint64_t *)v9[6];
      uint64_t v12 = 8 * v10;
      do
      {
        uint64_t v13 = *v11++;
        sub_1CD65E620((uint64_t)a2, v13);
        v12 -= 8;
      }
      while (v12);
    }
    if (*((_DWORD *)v9 + 2) == 91) {
      uint64_t v14 = 6;
    }
    else {
      uint64_t v14 = 11;
    }
    if (*((_DWORD *)v9 + 2) == 91) {
      std::string v15 = "OMP110";
    }
    else {
      std::string v15 = "HeapToStack";
    }
    std::string v16 = (uint64_t (*)(void, void))*((void *)a2 + 687);
    if (v16)
    {
      uint64_t v17 = *v9;
      char v18 = (uint64_t ***)v16(*((void *)a2 + 688), *(void *)(*(void *)(*v9 + 40) + 56));
      uint64_t v19 = v18;
      if (*(_WORD *)v15 == 19791 && v15[2] == 80)
      {
        uint64_t v21 = *(void *)***v18;
        if (!*(void *)(v21 + 128)
          && !(*(unsigned int (**)(void))(**(void **)(v21 + 72) + 48))(*(void *)(v21 + 72)))
        {
          goto LABEL_96;
        }
        llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v116, *((void *)a2 + 689), (uint64_t)v15, v14, v17);
        int v85 = 0;
        BOOL v22 = sub_1CC0A4DF4(0, *v9, &v85);
        uint64_t v23 = 52;
        if (v22 && v85 == 91) {
          uint64_t v23 = 40;
        }
        uint64_t v24 = "Moving memory allocation from the heap to the stack.";
        if (v22 && v85 == 91) {
          uint64_t v24 = "Moving globalized variable to the stack.";
        }
        __int16 v86 = v24;
        uint64_t v87 = v23;
        sub_1CC59ADEC((uint64_t *)&v124, (uint64_t)&v86);
        LODWORD(v89) = v117;
        BYTE4(v89) = v118;
        long long v90 = v119;
        uint64_t v91 = v120;
        long long v92 = v121;
        long long v93 = v122;
        uint64_t v94 = v123;
        uint64_t v88 = &unk_1F2616800;
        uint64_t v95 = &v97;
        uint64_t v96 = 0x400000000;
        if (v125) {
          sub_1CD494D68((uint64_t)&v95, (uint64_t)&v124);
        }
        uint64_t v104 = v127;
        uint64_t v105 = v128;
        __int16 v86 = " [";
        uint64_t v87 = 2;
        uint64_t v88 = &unk_1F2616570;
        sub_1CC59ADEC((uint64_t *)&v95, (uint64_t)&v86);
        __int16 v86 = v15;
        uint64_t v87 = v14;
        sub_1CC59ADEC((uint64_t *)&v95, (uint64_t)&v86);
        __int16 v86 = "]";
        uint64_t v87 = 1;
        sub_1CC59ADEC((uint64_t *)&v95, (uint64_t)&v86);
        LODWORD(v107) = v89;
        BYTE4(v107) = BYTE4(v89);
        long long v108 = v90;
        uint64_t v109 = v91;
        char v106 = (const char **)&unk_1F2616800;
        long long v110 = v92;
        long long v111 = v93;
        int64x2_t v112 = v94;
        int64x2_t v113 = (char *)v115;
        uint64_t v114 = 0x400000000;
        if (v96)
        {
          sub_1CD494D68((uint64_t)&v113, (uint64_t)&v95);
          uint64_t v25 = v96;
        }
        else
        {
          uint64_t v25 = 0;
        }
        void v115[32] = v104;
        v115[33] = v105;
        char v106 = (const char **)&unk_1F2616570;
        uint64_t v88 = &unk_1F2616800;
        unsigned int v38 = (char *)v95;
        if (v25)
        {
          uint64_t v39 = v25 << 6;
          do
          {
            unint64_t v40 = (void **)&v38[v39];
            if (v38[v39 - 17] < 0) {
              operator delete(*(v40 - 5));
            }
            if (*((char *)v40 - 41) < 0) {
              operator delete(*(v40 - 8));
            }
            v39 -= 64;
          }
          while (v39);
          unsigned int v38 = (char *)v95;
        }
        if (v38 != (char *)&v97) {
          free(v38);
        }
        uint64_t v116 = &unk_1F2616800;
        uint64_t v41 = v124;
        if (v125)
        {
          unint64_t v42 = (unint64_t)v125 << 6;
          do
          {
            uint64_t v43 = (void **)&v41[v42];
            if (v41[v42 - 17] < 0) {
              operator delete(*(v43 - 5));
            }
            if (*((char *)v43 - 41) < 0) {
              operator delete(*(v43 - 8));
            }
            v42 -= 64;
          }
          while (v42);
          uint64_t v41 = v124;
        }
        if (v41 != v126) {
          free(v41);
        }
        llvm::OptimizationRemarkEmitter::emit(v19, (llvm::DiagnosticInfoOptimizationBase *)&v106);
        char v106 = (const char **)&unk_1F2616800;
        std::string v34 = v113;
        if (v114)
        {
          unint64_t v44 = (unint64_t)v114 << 6;
          do
          {
            uint64_t v45 = (void **)&v34[v44];
            if (v34[v44 - 17] < 0) {
              operator delete(*(v45 - 5));
            }
            if (*((char *)v45 - 41) < 0) {
              operator delete(*(v45 - 8));
            }
            v44 -= 64;
          }
          while (v44);
          std::string v34 = v113;
        }
        unsigned int v37 = (char *)v115;
      }
      else
      {
        uint64_t v26 = *(void *)***v18;
        if (!*(void *)(v26 + 128)
          && !(*(unsigned int (**)(void))(**(void **)(v26 + 72) + 48))(*(void *)(v26 + 72)))
        {
          goto LABEL_96;
        }
        llvm::OptimizationRemark::OptimizationRemark((uint64_t)&v88, *((void *)a2 + 689), (uint64_t)v15, v14, v17);
        LODWORD(v86) = 0;
        BOOL v27 = sub_1CC0A4DF4(0, *v9, &v86);
        uint64_t v28 = 52;
        if (v27 && v86 == 91) {
          uint64_t v28 = 40;
        }
        uint64_t v29 = "Moving memory allocation from the heap to the stack.";
        if (v27 && v86 == 91) {
          uint64_t v29 = "Moving globalized variable to the stack.";
        }
        char v106 = (const char **)v29;
        uint64_t v107 = v28;
        sub_1CC59ADEC((uint64_t *)&v95, (uint64_t)&v106);
        unsigned int v117 = v89;
        char v118 = BYTE4(v89);
        long long v119 = v90;
        uint64_t v120 = v91;
        uint64_t v116 = &unk_1F2616800;
        long long v121 = v92;
        long long v122 = v93;
        uint64_t v123 = v94;
        unsigned int v124 = v126;
        uint64_t v125 = 0x400000000;
        if (v96)
        {
          sub_1CD494D68((uint64_t)&v124, (uint64_t)&v95);
          uint64_t v30 = v96;
        }
        else
        {
          uint64_t v30 = 0;
        }
        uint64_t v127 = v104;
        uint64_t v128 = v105;
        uint64_t v116 = &unk_1F2616570;
        uint64_t v88 = &unk_1F2616800;
        std::string v31 = (char *)v95;
        if (v30)
        {
          uint64_t v32 = v30 << 6;
          do
          {
            std::string v33 = (void **)&v31[v32];
            if (v31[v32 - 17] < 0) {
              operator delete(*(v33 - 5));
            }
            if (*((char *)v33 - 41) < 0) {
              operator delete(*(v33 - 8));
            }
            v32 -= 64;
          }
          while (v32);
          std::string v31 = (char *)v95;
        }
        if (v31 != (char *)&v97) {
          free(v31);
        }
        llvm::OptimizationRemarkEmitter::emit(v19, (llvm::DiagnosticInfoOptimizationBase *)&v116);
        uint64_t v116 = &unk_1F2616800;
        std::string v34 = v124;
        if (v125)
        {
          unint64_t v35 = (unint64_t)v125 << 6;
          do
          {
            uint64_t v36 = (void **)&v34[v35];
            if (v34[v35 - 17] < 0) {
              operator delete(*(v36 - 5));
            }
            if (*((char *)v36 - 41) < 0) {
              operator delete(*(v36 - 8));
            }
            v35 -= 64;
          }
          while (v35);
          std::string v34 = v124;
        }
        unsigned int v37 = v126;
      }
      if (v34 != v37) {
        free(v34);
      }
    }
LABEL_96:
    uint64_t v46 = *(void *)(*((void *)a2 + 11) + 120);
    sub_1CC8F2364((uint64_t)&v116, a1, (uint64_t)a2, a1, v9);
    char v48 = *(llvm::ConstantInt ***)*v9;
    if ((_BYTE)v119)
    {
      int v49 = llvm::ConstantInt::get(*v48, (llvm::LLVMContext *)&v116, v47);
    }
    else
    {
      v82 &= 0xFFFFFFFFFF000000;
      llvm::ObjectSizeOffsetEvaluator::ObjectSizeOffsetEvaluator((uint64_t)&v88, v46, 0, (uint64_t)*v48, v82, 0);
      int v49 = llvm::ObjectSizeOffsetEvaluator::compute((llvm::ObjectSizeOffsetEvaluator *)&v88, (llvm::Value *)*v9);
      sub_1CD4A7604((uint64_t)&v88);
    }
    unsigned __int16 v50 = sub_1CC63020C(*v9);
    if ((_BYTE)v50) {
      BOOL v51 = v50 >= 0x100u;
    }
    else {
      BOOL v51 = 0;
    }
    if (v51) {
      unsigned __int8 v52 = v50;
    }
    else {
      unsigned __int8 v52 = 0;
    }
    uint64_t AllocAlignment = llvm::getAllocAlignment(*v9, 0);
    if (AllocAlignment)
    {
      sub_1CC8F24A0((uint64_t)&v88, a2, (const llvm::AbstractAttribute *)a1, AllocAlignment);
      uint64_t v54 = (unint64_t *)&v88;
      if (v89 >= 0x41) {
        uint64_t v54 = (unint64_t *)v88;
      }
      unint64_t v55 = *v54;
      unint64_t v56 = __clz(v55) ^ 0x13F;
      if (v55) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = 0;
      }
      if ((v57 & 0x3F) <= v52) {
        unsigned __int8 v58 = v52;
      }
      else {
        unsigned __int8 v58 = v57;
      }
      if (v57 >= 0x100) {
        unsigned __int8 v52 = v58;
      }
      if (v89 >= 0x41 && (_BYTE)v90 && v88) {
        MEMORY[0x1D25D9CB0]();
      }
    }
    uint64_t v59 = (llvm::Type *)*(unsigned int *)(v46 + 4);
    unint64_t v60 = operator new(0x68uLL);
    PointerBitCastOrAddrSpaceCast = (llvm::Value *)(v60 + 8);
    v60[13] = v60[13] & 0x38000000 | 1;
    *(void *)unint64_t v60 = 0;
    *((void *)v60 + 1) = 0;
    *((void *)v60 + 2) = 0;
    *((void *)v60 + 3) = v60 + 8;
    uint64_t v62 = (llvm::PointerType *)(***(void ***)v84 + 1912);
    LOWORD(v91) = 257;
    llvm::AllocaInst::AllocaInst((unint64_t *)v60 + 4, v62, v59, v49, v52, (const char **)&v88, *v9);
    uint64_t v64 = *v9;
    int v65 = *(llvm::Value **)*v9;
    if (*((llvm::Value **)v60 + 4) != v65)
    {
      uint64_t v88 = "malloc_cast";
      LOWORD(v91) = 259;
      PointerBitCastOrAddrSpaceCast = llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(PointerBitCastOrAddrSpaceCast, v65, (const char **)&v88, (const llvm::Twine *)*v9, v63);
      uint64_t v64 = *v9;
    }
    InitialValueOfAllocation = llvm::getInitialValueOfAllocation(v64, 0, (llvm::UndefValue *)(***(void ***)v84 + 1912));
    sub_1CD65F304((uint64_t)a2, *v9, PointerBitCastOrAddrSpaceCast, 1);
    uint64_t v67 = *v9;
    if (*v9 && *(unsigned char *)(v67 + 16) == 33)
    {
      uint64_t v68 = *(llvm::BasicBlock **)(v67 - 96);
      uint64_t v69 = *(llvm::BasicBlock **)(v67 + 40);
      unsigned int v70 = operator new(0x60uLL);
      v70[13] = v70[13] & 0x38000000 | 1;
      *(void *)unsigned int v70 = 0;
      *((void *)v70 + 1) = 0;
      *((void *)v70 + 2) = 0;
      *((void *)v70 + 3) = v70 + 8;
      llvm::BranchInst::BranchInst((llvm::BranchInst *)(v70 + 8), v68, v69);
      uint64_t v67 = *v9;
    }
    sub_1CD65E620((uint64_t)a2, v67);
    if (*((unsigned __int8 *)InitialValueOfAllocation + 16) - 11 < 2) {
      goto LABEL_137;
    }
    uint64_t v71 = 0;
    uint64_t v72 = *((void *)PointerBitCastOrAddrSpaceCast + 4);
    if (v72) {
      BOOL v73 = v72 == *((void *)PointerBitCastOrAddrSpaceCast + 5) + 40;
    }
    else {
      BOOL v73 = 1;
    }
    if (v73) {
      uint64_t v74 = 0;
    }
    else {
      uint64_t v74 = (uint64_t **)(v72 - 24);
    }
    uint64_t v75 = **v74;
    uint64_t v88 = &v90;
    uint64_t v89 = 0x200000000;
    *((void *)&v93 + 1) = v75;
    uint64_t v94 = &v102;
    uint64_t v95 = &v103;
    uint64_t v96 = 0;
    int v97 = 0;
    __int16 v98 = 512;
    char v99 = 7;
    *((void *)&v92 + 1) = 0;
    *(void *)&long long v93 = 0;
    uint64_t v100 = 0;
    uint64_t v101 = 0;
    uint64_t v102 = &unk_1F2616E88;
    uint64_t v103 = &unk_1F2617008;
    *((void *)&v92 + 1) = v74[5];
    *(void *)&long long v93 = v74 + 3;
    int v76 = (unsigned __int8 *)v74[6];
    __int16 v86 = (const char *)v76;
    if (v76)
    {
      llvm::MetadataTracking::track((uint64_t)&v86, v76, 2);
      uint64_t v71 = (uint64_t)v86;
    }
    sub_1CB8461A4((uint64_t)&v88, 0, v71);
    unint64_t v77 = v83;
    if (!v86)
    {
LABEL_135:
      unint64_t v83 = v77 & 0xFFFFFFFFFFFF0000;
      llvm::IRBuilderBase::CreateMemSet((uint64_t)&v88, PointerBitCastOrAddrSpaceCast, (uint64_t)InitialValueOfAllocation, v49, 0, 0, 0, 0, 0);
      if (v88 != &v90) {
        free(v88);
      }
LABEL_137:
      if ((_BYTE)v119 && v117 >= 0x41)
      {
        if (v116) {
          MEMORY[0x1D25D9CB0](v116, 0x1000C8000313F17);
        }
      }
      uint64_t result = 0;
      goto LABEL_9;
    }
    int v78 = *(unsigned __int8 *)v86;
    if ((v78 - 4) > 0x1E)
    {
      if ((v78 - 3) >= 0xFFFFFFFE) {
        BOOL v81 = v86;
      }
      else {
        BOOL v81 = 0;
      }
      if ((v78 - 3) < 0xFFFFFFFE)
      {
        if (v78 == 3) {
          *((void *)v86 + 1) = 0;
        }
        goto LABEL_135;
      }
      unint64_t v80 = (unint64_t)(v81 + 8);
    }
    else
    {
      if ((v86[1] & 0x7F) != 2 && !*((_DWORD *)v86 + 3)) {
        goto LABEL_135;
      }
      uint64_t v79 = *((void *)v86 + 2);
      if ((v79 & 4) == 0) {
        goto LABEL_135;
      }
      unint64_t v80 = v79 & 0xFFFFFFFFFFFFFFF8;
      if (!v80) {
        goto LABEL_135;
      }
    }
    char v106 = &v86;
    sub_1CC5FA668(v80 + 16, &v106);
    unint64_t v77 = v83;
    goto LABEL_135;
  }
  return 1;
}

void sub_1CC8F1110()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1F0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1F0))
  {
    __cxa_guard_release(&qword_1EA61C1F0);
  }
}

uint64_t sub_1CC8F1164(uint64_t a1, llvm::Attributor *a2)
{
  v69[8] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = sub_1CD6482A0((_DWORD *)(a1 + 16));
  if (**(void **)(*((void *)a2 + 11) + 440)) {
    BOOL v5 = *(void *)(v4 + 40) == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  uint64_t v6 = sub_1CC8AC178((uint64_t)a2, v4, 0, a1, 2, 0, 1);
  uint64_t v7 = *((void *)a2 + 11);
  int v8 = *(_DWORD *)(v7 + 592);
  BOOL v10 = v8 != 25 && v8 != 30 && (v8 & 0xFFFFFFFE) != 44;
  BOOL v63 = v10;
  uint64_t v11 = *(void *)(a1 + 72);
  uint64_t v12 = *(void *)(a1 + 80);
  if (v11 != v12)
  {
    uint64_t v13 = v6;
    int v14 = 0;
    uint64_t v61 = v7 + 136;
    uint64_t v15 = 1;
    while (1)
    {
      uint64_t v16 = *(void *)(v11 + 8);
      if (*(_DWORD *)(v16 + 12) != 2) {
        break;
      }
LABEL_96:
      v11 += 16;
      if (v11 == v12) {
        return v15;
      }
    }
    uint64_t AllocAlignment = llvm::getAllocAlignment(*(void *)v16, 0);
    if (!AllocAlignment) {
      goto LABEL_34;
    }
    sub_1CC8F24A0((uint64_t)&v67, a2, (const llvm::AbstractAttribute *)a1, AllocAlignment);
    if (!LOBYTE(v69[0])) {
      goto LABEL_94;
    }
    if (v68 < 0x41)
    {
      if ((unint64_t)v67 > 0x100000000) {
        goto LABEL_94;
      }
      uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v67);
      v18.i16[0] = vaddlv_u8(v18);
      if (v18.u32[0] != 1) {
        goto LABEL_94;
      }
LABEL_34:
      unsigned int v64 = v15;
      if (dword_1EBCDE068 != -1)
      {
        sub_1CC8F2364((uint64_t)&v67, a1, (uint64_t)a2, a1, (uint64_t *)v16);
        if (!LOBYTE(v69[0]))
        {
LABEL_94:
          uint64_t v15 = 0;
          *(_DWORD *)(v16 + 12) = 2;
          goto LABEL_96;
        }
        unsigned int v28 = v68;
        uint64_t v29 = v67;
        if (v68 < 0x41)
        {
          uint64_t v30 = &v67;
          goto LABEL_44;
        }
        int v31 = 0;
        int64_t v32 = ((unint64_t)v68 + 63) >> 6;
        do
        {
          BOOL v22 = v32-- < 1;
          if (v22) {
            break;
          }
          unint64_t v33 = *((void *)v67 + v32);
          v31 += __clz(v33);
        }
        while (!v33);
        int v34 = v68 | 0xFFFFFFC0;
        if ((v68 & 0x3F) == 0) {
          int v34 = 0;
        }
        unsigned int v35 = v68 - v31 - v34;
        uint64_t v30 = v67;
        if (v35 > 0x40)
        {
LABEL_45:
          unsigned int v64 = 0;
          int v36 = 0;
          *(_DWORD *)(v16 + 12) = 2;
        }
        else
        {
LABEL_44:
          if (*v30 > (unint64_t)dword_1EBCDE068) {
            goto LABEL_45;
          }
          int v36 = 1;
        }
        if (v28 >= 0x41 && v29) {
          MEMORY[0x1D25D9CB0](v29, 0x1000C8000313F17);
        }
        if (!v36)
        {
LABEL_95:
          uint64_t v15 = v64;
          goto LABEL_96;
        }
      }
      int v37 = *(_DWORD *)(v16 + 12);
      if (v37 != 1)
      {
        if (v37) {
          goto LABEL_95;
        }
        LOBYTE(v65) = 1;
        uint64_t v67 = &v65;
        uint64_t v68 = a1;
        v69[0] = v16;
        v69[1] = a2;
        if (llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8F2700, (uint64_t)&v67, (const llvm::AbstractAttribute *)a1, *(void *)v16, 0, 1, 1, 0, v60)&& v65 != 0)
        {
          goto LABEL_95;
        }
        *(_DWORD *)(v16 + 12) = 1;
      }
      if (v63 || *((unsigned char *)sub_1CC8B4D90((uint64_t)a2, *(void *)(a1 + 16), *(void *)(a1 + 24), a1, 1, 0, 1) + 41))
      {
        if (!v14)
        {
          uint64_t v40 = *(void *)(a1 + 120);
          uint64_t v39 = *(void *)(a1 + 128);
          if (v40 != v39)
          {
            uint64_t v62 = v13;
            do
            {
              uint64_t v41 = *(unsigned char **)(v40 + 8);
              if (!v41[8])
              {
                BOOL v66 = 0;
                if ((llvm::Attributor::isAssumedDead((uint64_t)a2, *(void *)v41, a1, v13, &v66, 1, 1) & 1) == 0)
                {
                  uint64_t v67 = v69;
                  uint64_t v68 = 0x800000000;
                  if (llvm::AA::getAssumedUnderlyingObjects(a2, *(void *)(*(void *)v41 - 32 * (*(_DWORD *)(*(void *)v41 + 20) & 0x7FFFFFF)), (uint64_t)&v67, (const llvm::AbstractAttribute *)a1, *(void *)v41, &v66, 2))
                  {
                    if (v68)
                    {
                      unint64_t v42 = (uint64_t *)v67;
                      uint64_t v43 = 8 * v68;
                      do
                      {
                        uint64_t v44 = *v42;
                        unsigned int v45 = *(unsigned __int8 *)(*v42 + 16);
                        if (v45 > 0x13 || ((1 << v45) & 0x81800) == 0)
                        {
                          if (v45 < 0x1C
                            || ((v47 = v45 - 33, BOOL v22 = v47 > 0x33, v48 = (1 << v47) & 0x8000000000041, !v22)
                              ? (BOOL v49 = v48 == 0)
                              : (BOOL v49 = 1),
                                v49))
                          {
                            v41[8] = 1;
                          }
                          else
                          {
                            uint64_t v65 = *v42;
                            if (sub_1CC8F2D68(a1 + 48, v44)) {
                              sub_1CD65F520((uint64_t)(v41 + 16), &v65);
                            }
                            else {
                              v41[8] = 1;
                            }
                          }
                        }
                        ++v42;
                        v43 -= 8;
                      }
                      while (v43);
                    }
                  }
                  else
                  {
                    v41[8] = 1;
                  }
                  if (v67 != v69) {
                    free(v67);
                  }
                  uint64_t v13 = v62;
                }
              }
              v40 += 16;
            }
            while (v40 != v39);
          }
        }
        if (*(_DWORD *)(v16 + 56) == 1)
        {
          unint64_t v50 = **(void **)(v16 + 48);
          uint64_t v67 = 0;
          if (sub_1CD40EA84(*(void *)(a1 + 96), *(_DWORD *)(a1 + 112), v50, &v67))
          {
            BOOL v51 = (unsigned int *)v67;
            uint64_t v52 = *(void *)(a1 + 96);
            uint64_t v53 = *(unsigned int *)(a1 + 112);
          }
          else
          {
            uint64_t v52 = *(void *)(a1 + 96);
            uint64_t v53 = *(unsigned int *)(a1 + 112);
            BOOL v51 = (unsigned int *)(v52 + 16 * v53);
          }
          uint64_t v15 = v64;
          if (v51 != (unsigned int *)(v52 + 16 * v53)
            && (uint64_t v54 = *(void *)(*(void *)(a1 + 120) + 16 * v51[2] + 8)) != 0
            && !*(unsigned char *)(v54 + 8)
            && *(_DWORD *)(v54 + 48) <= 1u
            && (uint64_t v55 = **(void **)(v54 + 40), v55 == *(void *)v16))
          {
            if (*(unsigned char *)(v55 + 16) != 33)
            {
              uint64_t v56 = *(void *)(v55 + 32);
              if (v56) {
                BOOL v57 = v56 == *(void *)(v55 + 40) + 40;
              }
              else {
                BOOL v57 = 1;
              }
              if (v57) {
                uint64_t v55 = 0;
              }
              else {
                uint64_t v55 = v56 - 24;
              }
            }
            char v58 = sub_1CD65FA00(v61, v50, v55);
            int v14 = 1;
            if (v58) {
              goto LABEL_96;
            }
          }
          else
          {
            int v14 = 1;
          }
        }
        else
        {
          int v14 = 1;
        }
      }
      goto LABEL_94;
    }
    int v19 = 0;
    uint64_t v20 = v67;
    int64_t v21 = ((unint64_t)v68 + 63) >> 6;
    do
    {
      BOOL v22 = v21-- < 1;
      if (v22) {
        break;
      }
      unint64_t v23 = *((void *)v67 + v21);
      v19 += __clz(v23);
    }
    while (!v23);
    int v24 = v68 | 0xFFFFFFC0;
    if ((v68 & 0x3F) == 0) {
      int v24 = 0;
    }
    if ((v68 - v19 - v24) <= 0x40)
    {
      if (*(void *)v67 <= 0x100000000uLL)
      {
        uint64_t v25 = 0;
        int v26 = 0;
        do
        {
          uint8x8_t v27 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)v67 + 8 * v25));
          v27.i16[0] = vaddlv_u8(v27);
          v26 += v27.i32[0];
          ++v25;
        }
        while (((unint64_t)v68 + 63) >> 6 != v25);
        if (v26 == 1)
        {
          MEMORY[0x1D25D9CB0](v67, 0x1000C8000313F17);
          goto LABEL_34;
        }
      }
      *(_DWORD *)(v16 + 12) = 2;
    }
    else
    {
      *(_DWORD *)(v16 + 12) = 2;
      if (!v20) {
        goto LABEL_48;
      }
    }
    MEMORY[0x1D25D9CB0]();
LABEL_48:
    uint64_t v15 = 0;
    goto LABEL_96;
  }
  return 1;
}

uint64_t sub_1CC8F17E0(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 41)) {
    return 0;
  }
  uint64_t result = sub_1CC8F2D68(a1 + 48, a2);
  if (result) {
    return *(_DWORD *)(result + 12) != 2;
  }
  return result;
}

uint64_t sub_1CC8F181C(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 41)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t v3 = *(void *)(a1 + 80);
  if (v2 == v3) {
    return 0;
  }
  while (1)
  {
    uint64_t v5 = *(void *)(v2 + 8);
    if (*(_DWORD *)(v5 + 12) != 2 && (sub_1CD65F664(v5 + 24, a2, &v7) & 1) != 0) {
      break;
    }
    v2 += 16;
    if (v2 == v3) {
      return 0;
    }
  }
  return 1;
}

void *sub_1CC8F18A0(uint64_t a1)
{
  return sub_1CC8EFF84((void *)(a1 - 32));
}

void sub_1CC8F18A8(uint64_t a1)
{
  sub_1CC8EFF84((void *)(a1 - 32));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F18E4(uint64_t ***a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 16) - 33;
  BOOL v3 = v2 > 0x33;
  uint64_t v4 = (1 << v2) & 0x8000000000041;
  if (!v3 && v4 != 0)
  {
    int v8 = a1[1];
    BOOL v9 = **a1;
    LOBYTE(v52) = 0;
    BOOL v10 = (uint64_t ***)sub_1CC0960E8(a2, &v52);
    if (v10)
    {
      if (!(_BYTE)v52)
      {
        v54[0] = 0;
        if (v9)
        {
          uint64_t v20 = (llvm::Function *)v10;
          if (llvm::TargetLibraryInfoImpl::getLibFunc(*v9, v10, v54)
            && ((*(void *)(v9[1] + (((unint64_t)v54[0] >> 3) & 0x1FFFFFF8)) >> SLOBYTE(v54[0])) & 1) == 0
            && ((*(unsigned __int8 *)(*v9 + ((unint64_t)v54[0] >> 2)) >> (2 * (v54[0] & 3))) & 3) != 0
            && llvm::isLibFreeFunction(v20, v54[0])
            && *(unsigned char *)(a2 + 16) == 84)
          {
            int64_t v21 = a1[2][3];
            v21[10] += 64;
            if (((*v21 + 7) & 0xFFFFFFFFFFFFFFF8) - *v21 + 64 > v21[1] - *v21)
            {
              unsigned int v49 = *((_DWORD *)v21 + 6) >> 7;
              if (v49 >= 0x1E) {
                LOBYTE(v49) = 30;
              }
              uint64_t v50 = 4096 << v49;
              unint64_t v22 = (unint64_t)operator new(4096 << v49, (std::align_val_t)8uLL);
              unsigned int v51 = *((_DWORD *)v21 + 6);
              if (v51 >= *((_DWORD *)v21 + 7)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(v21[2] + 8 * v51) = v22;
              ++*((_DWORD *)v21 + 6);
              v21[1] = v22 + v50;
            }
            else
            {
              unint64_t v22 = (*v21 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            *int64_t v21 = v22 + 64;
            *(void *)unint64_t v22 = a2;
            *(unsigned char *)(v22 + 8) = 0;
            *(_OWORD *)(v22 + 32) = 0u;
            *(_OWORD *)(v22 + 48) = 0u;
            *(void *)(v22 + 16) = 1;
            *(void *)(v22 + 24) = -4096;
            *(void *)(v22 + 40) = v22 + 56;
            *(_DWORD *)(v22 + 52) = 1;
            uint64_t v52 = a2;
            int v53 = 0;
            sub_1CD40E370((uint64_t)v54, (uint64_t)(v8 + 12), &v52, &v53);
            uint64_t v23 = *(void *)v54;
            if (!v55)
            {
              unsigned int v40 = *(_DWORD *)(*(void *)v54 + 8);
              uint64_t v41 = v8[15];
LABEL_76:
              v41[2 * v40 + 1] = v22;
              return 1;
            }
            uint64_t v25 = v8[16];
            unint64_t v24 = (unint64_t)v8[17];
            if ((unint64_t)v25 < v24)
            {
              *uint64_t v25 = a2;
              v25[1] = 0;
              int v26 = v25 + 2;
LABEL_75:
              unsigned char v8[16] = v26;
              uint64_t v41 = v8[15];
              unsigned int v40 = ((unint64_t)((char *)v26 - (char *)v41) >> 4) - 1;
              *(_DWORD *)(v23 + 8) = v40;
              goto LABEL_76;
            }
            unint64_t v42 = v8[15];
            uint64_t v43 = ((char *)v25 - (char *)v42) >> 4;
            unint64_t v44 = v43 + 1;
            if (!((unint64_t)(v43 + 1) >> 60))
            {
              uint64_t v45 = v24 - (void)v42;
              if (v45 >> 3 > v44) {
                unint64_t v44 = v45 >> 3;
              }
              if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v46 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v46 = v44;
              }
              if (!v46)
              {
                unsigned int v47 = 0;
                goto LABEL_70;
              }
              if (!(v46 >> 60))
              {
                unsigned int v47 = (char *)operator new(16 * v46);
LABEL_70:
                uint64_t v48 = (uint64_t *)&v47[16 * v43];
                uint64_t *v48 = a2;
                v48[1] = 0;
                int v26 = v48 + 2;
                if (v25 != v42)
                {
                  do
                  {
                    *((_OWORD *)v48 - 1) = *((_OWORD *)v25 - 1);
                    v48 -= 2;
                    v25 -= 2;
                  }
                  while (v25 != v42);
                  uint64_t v25 = v8[15];
                }
                v8[15] = v48;
                unsigned char v8[16] = v26;
                v8[17] = (uint64_t *)&v47[16 * v46];
                if (v25) {
                  operator delete(v25);
                }
                goto LABEL_75;
              }
LABEL_68:
              sub_1CB833614();
            }
LABEL_67:
            abort();
          }
        }
      }
    }
    if (byte_1EBD04470) {
      int v11 = 59;
    }
    else {
      int v11 = 63;
    }
    sub_1CC095244(a2, v11, **a1, v54);
    if (v56)
    {
      int v12 = byte_1EBD04470 ? 43 : 47;
      sub_1CC095244(a2, v12, **a1, v54);
      if (v56)
      {
        if (llvm::getInitialValueOfAllocation(a2, **a1, (llvm::UndefValue *)(****(void ****)(a2 + 40) + 1912)))
        {
          int v14 = a1[2][3];
          v14[10] += 72;
          if (((*v14 + 7) & 0xFFFFFFFFFFFFFFF8) - *v14 + 72 > v14[1] - *v14)
          {
            unsigned int v37 = *((_DWORD *)v14 + 6) >> 7;
            if (v37 >= 0x1E) {
              LOBYTE(v37) = 30;
            }
            uint64_t v38 = 4096 << v37;
            unint64_t v15 = (unint64_t)operator new(4096 << v37, (std::align_val_t)8uLL);
            unsigned int v39 = *((_DWORD *)v14 + 6);
            if (v39 >= *((_DWORD *)v14 + 7)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(v14[2] + 8 * v39) = v15;
            ++*((_DWORD *)v14 + 6);
            v14[1] = v15 + v38;
          }
          else
          {
            unint64_t v15 = (*v14 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *int v14 = v15 + 72;
          *(void *)unint64_t v15 = a2;
          *(void *)(v15 + 8) = 469;
          *(unsigned char *)(v15 + 16) = 0;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_OWORD *)(v15 + 56) = 0u;
          *(void *)(v15 + 24) = 1;
          *(void *)(v15 + 32) = -4096;
          *(void *)(v15 + 48) = v15 + 64;
          *(_DWORD *)(v15 + 60) = 1;
          uint64_t v52 = a2;
          int v53 = 0;
          sub_1CD40E370((uint64_t)v54, (uint64_t)(v8 + 6), &v52, &v53);
          uint64_t v16 = *(void *)v54;
          if (v55)
          {
            uint8x8_t v18 = v8[10];
            unint64_t v17 = (unint64_t)v8[11];
            if ((unint64_t)v18 >= v17)
            {
              uint64_t v29 = v8[9];
              uint64_t v30 = ((char *)v18 - (char *)v29) >> 4;
              unint64_t v31 = v30 + 1;
              if ((unint64_t)(v30 + 1) >> 60) {
                goto LABEL_67;
              }
              uint64_t v32 = v17 - (void)v29;
              if (v32 >> 3 > v31) {
                unint64_t v31 = v32 >> 3;
              }
              if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v33 = v31;
              }
              if (v33)
              {
                if (v33 >> 60) {
                  goto LABEL_68;
                }
                int v34 = (char *)operator new(16 * v33);
              }
              else
              {
                int v34 = 0;
              }
              unsigned int v35 = (uint64_t *)&v34[16 * v30];
              uint64_t *v35 = a2;
              v35[1] = 0;
              int v19 = v35 + 2;
              if (v18 != v29)
              {
                do
                {
                  *((_OWORD *)v35 - 1) = *((_OWORD *)v18 - 1);
                  v35 -= 2;
                  v18 -= 2;
                }
                while (v18 != v29);
                uint8x8_t v18 = v8[9];
              }
              v8[9] = v35;
              v8[10] = v19;
              v8[11] = (uint64_t *)&v34[16 * v33];
              if (v18) {
                operator delete(v18);
              }
            }
            else
            {
              *uint8x8_t v18 = a2;
              v18[1] = 0;
              int v19 = v18 + 2;
            }
            v8[10] = v19;
            unsigned int v28 = v8[9];
            unsigned int v27 = ((unint64_t)((char *)v19 - (char *)v28) >> 4) - 1;
            *(_DWORD *)(v16 + 8) = v27;
          }
          else
          {
            unsigned int v27 = *(_DWORD *)(*(void *)v54 + 8);
            unsigned int v28 = v8[9];
          }
          v28[2 * v27 + 1] = v15;
          int v36 = **a1;
          if (v36) {
            sub_1CC0A4DF4(v36, a2, (_DWORD *)(v15 + 8));
          }
        }
      }
    }
  }
  return 1;
}

void sub_1CC8F1EAC()
{
}

void *sub_1CC8F1EC0()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2626C20;
  return result;
}

void sub_1CC8F1EF8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2626C20;
}

uint64_t sub_1CC8F1F20()
{
  return 0;
}

uint64_t sub_1CC8F1F2C(unsigned int *a1, uint64_t a2)
{
  uint64_t v3 = a1[2];
  if (v3 >= a1[3])
  {
    return sub_1CC8F22A0(a1, a2);
  }
  else
  {
    sub_1CC8B6674(*(void *)a1 + 32 * v3, a2);
    uint64_t v4 = a1[2] + 1;
    a1[2] = v4;
    return *(void *)a1 + 32 * v4 - 32;
  }
}

unsigned int *sub_1CC8F1F9C(unsigned int *a1, unsigned int *a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(void *)a2;
    if (*(unsigned int **)a2 == a2 + 4)
    {
      uint64_t v5 = a2[2];
      uint64_t v6 = a1[2];
      if (v6 >= v5)
      {
        BOOL v9 = *(void **)a1;
        if (v5)
        {
          uint64_t v10 = 0;
          do
          {
            sub_1CC8F21C0(&v9[v10], v4 + v10 * 8);
            v10 += 4;
          }
          while (4 * v5 != v10);
          uint64_t v6 = a1[2];
          int v11 = &v9[v10];
          BOOL v9 = *(void **)a1;
        }
        else
        {
          int v11 = *(void **)a1;
        }
        int v12 = &v9[4 * v6];
        if (v12 != v11)
        {
          uint64_t v13 = v12 - 4;
          int v14 = v12 - 4;
          do
          {
            unint64_t v15 = (void *)v14[3];
            if (v14 == v15)
            {
              (*(void (**)(void *))(*v14 + 32))(v14);
            }
            else if (v15)
            {
              (*(void (**)(void *))(*v15 + 40))(v15);
            }
            v13 -= 4;
            BOOL v16 = v14 == v11;
            v14 -= 4;
          }
          while (!v16);
        }
      }
      else
      {
        if (a1[3] < v5)
        {
          sub_1CC8B62E4(a1);
          sub_1CD650D18();
        }
        if (v6)
        {
          uint64_t v7 = *(void **)a1;
          uint64_t v8 = 32 * v6;
          do
          {
            sub_1CC8F21C0(v7, v4);
            v4 += 32;
            v7 += 4;
            v8 -= 32;
          }
          while (v8);
        }
        else
        {
          uint64_t v6 = 0;
        }
        uint64_t v17 = a2[2];
        if (v6 != v17)
        {
          uint64_t v18 = *(void *)a1 + 32 * v6;
          uint64_t v19 = *(void *)a2 + 32 * v6;
          uint64_t v20 = 32 * v17 - 32 * v6;
          do
          {
            uint64_t v21 = *(void *)(v19 + 24);
            if (v21)
            {
              if (v19 == v21)
              {
                *(void *)(v18 + 24) = v18;
                (*(void (**)(void, uint64_t))(**(void **)(v19 + 24) + 24))(*(void *)(v19 + 24), v18);
              }
              else
              {
                *(void *)(v18 + 24) = v21;
                *(void *)(v19 + 24) = 0;
              }
            }
            else
            {
              *(void *)(v18 + 24) = 0;
            }
            v19 += 32;
            v18 += 32;
            v20 -= 32;
          }
          while (v20);
        }
      }
      a1[2] = v5;
      sub_1CC8B62E4(a2);
    }
    else
    {
      sub_1CD65F22C((char **)a1, (char **)a2);
    }
  }
  return a1;
}

void *sub_1CC8F21C0(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v5;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

uint64_t sub_1CC8F22A0(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = a1[3];
  if (v2 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v5 = (2 * v2) | 1;
  if (v5 >= 0xFFFFFFFF) {
    uint64_t v6 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v6 = v5;
  }
  uint64_t v7 = malloc_type_malloc(32 * v6, 0x4065EBACuLL);
  if (!v7) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v8 = (uint64_t)v7;
  sub_1CC8B6674((uint64_t)v7 + 32 * a1[2], a2);
  sub_1CD650D88(a1, v8);
  if (*(unsigned int **)a1 != a1 + 4) {
    free(*(void **)a1);
  }
  *(void *)a1 = v8;
  uint64_t v9 = a1[2] + 1;
  a1[2] = v9;
  a1[3] = v6;
  return v8 + 32 * v9 - 32;
}

uint64_t sub_1CC8F2364(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(sub_1CD6482A0((_DWORD *)(a2 + 16)) + 40);
  if (**(void **)(*(void *)(a3 + 88) + 440)) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    llvm::AnalysisManager<llvm::Function>::getResultImpl();
  }
  uint64_t v11 = *a5;
  v13[0] = &unk_1F2626C68;
  v13[1] = a3;
  void v13[2] = a4;
  int v14 = v13;
  llvm::getAllocSize(v11, 0, v13, a1);
  uint64_t result = (uint64_t)v14;
  if (v14 == v13) {
    return (*(uint64_t (**)(void *))(v13[0] + 32))(v13);
  }
  if (v14) {
    return (*(uint64_t (**)(void))(*v14 + 40))();
  }
  return result;
}

llvm::UndefValue *sub_1CC8F24A0(uint64_t a1, llvm::Attributor *a2, const llvm::AbstractAttribute *a3, uint64_t a4)
{
  BOOL v14 = 0;
  unsigned int v5 = *(unsigned __int8 *)(a4 + 16);
  if (v5 != 21)
  {
    if (v5 < 0x1C)
    {
      if (!*(unsigned char *)(a4 + 16)) {
        a4 |= 2uLL;
      }
    }
    else
    {
      unsigned int v6 = v5 - 33;
      BOOL v7 = v6 > 0x33;
      uint64_t v8 = (1 << v6) & 0x8000000000041;
      if (!v7 && v8 != 0) {
        a4 |= 1uLL;
      }
    }
  }
  v15[0] = a4;
  v15[1] = 0;
  uint64_t result = llvm::Attributor::getAssumedConstant(a2, (const llvm::IRPosition *)v15, a3, &v14);
  if (!v11)
  {
    *(_DWORD *)(a1 + 8) = 64;
    *(void *)a1 = 0;
LABEL_18:
    char v13 = 1;
    goto LABEL_19;
  }
  if (result && *((unsigned char *)result + 16) == 16)
  {
    unsigned int v12 = *((_DWORD *)result + 8);
    *(_DWORD *)(a1 + 8) = v12;
    if (v12 > 0x40) {
      operator new[]();
    }
    *(void *)a1 = *((void *)result + 3);
    goto LABEL_18;
  }
  char v13 = 0;
  *(unsigned char *)a1 = 0;
LABEL_19:
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

void sub_1CC8F25C8()
{
}

__n128 sub_1CC8F25DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F2626C68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CC8F2628(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2626C68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

llvm::UndefValue *sub_1CC8F2658(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  BOOL v15 = 0;
  uint64_t v4 = *(llvm::Attributor **)(a1 + 8);
  unsigned int v5 = *(const llvm::AbstractAttribute **)(a1 + 16);
  unsigned int v6 = *(unsigned __int8 *)(v3 + 16);
  if (v6 == 21) {
    goto LABEL_9;
  }
  if (v6 >= 0x1C)
  {
    unsigned int v7 = v6 - 33;
    BOOL v8 = v7 > 0x33;
    uint64_t v9 = (1 << v7) & 0x8000000000041;
    if (!v8 && v9 != 0)
    {
      uint64_t v11 = v3 | 1;
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (*(unsigned char *)(v3 + 16))
  {
LABEL_9:
    uint64_t v11 = v3;
    goto LABEL_10;
  }
  uint64_t v11 = v3 | 2;
LABEL_10:
  v16[0] = v11;
  v16[1] = 0;
  __n128 result = llvm::Attributor::getAssumedConstant(v4, (const llvm::IRPosition *)v16, v5, &v15);
  if (result) {
    BOOL v14 = v13 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14) {
    return (llvm::UndefValue *)v3;
  }
  return result;
}

uint64_t sub_1CC8F2700(uint64_t a1, void *a2, unsigned char *a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2[3];
  int v4 = *(unsigned __int8 *)(v3 + 16);
  if (v4 != 60)
  {
    if (v4 == 61)
    {
      if (*(void *)(v3 - 64) == *a2) {
LABEL_4:
      }
        **(unsigned char **)a1 = 0;
    }
    else
    {
      if ((v4 - 33) > 0x33 || ((1 << (v4 - 33)) & 0x8000000000041) == 0)
      {
        unsigned int v16 = v4 - 62;
        if (v16 <= 0x17 && ((1 << v16) & 0xA08001) != 0)
        {
          *a3 = 1;
          return 1;
        }
        goto LABEL_4;
      }
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v43 = a2[3];
      int v9 = *(_DWORD *)(v3 + 20);
      unint64_t v10 = v3 - 32 * (v9 & 0x7FFFFFF);
      if (v10 <= (unint64_t)a2)
      {
        if (v4 == 84) {
          uint64_t v11 = 0;
        }
        else {
          uint64_t v11 = v4 == 39 ? (*(_DWORD *)(v3 + 80) + 1) : 2;
        }
        if (v9 < 0 && (uint64_t v42 = *(void *)(v10 - 8), (v42 & 0xFFFFFFFF0) != 0)) {
          uint64_t v12 = (*(_DWORD *)(v10 - 12) - *(_DWORD *)(v10 - v42));
        }
        else {
          uint64_t v12 = 0;
        }
        if (v3 - 32 * v11 - 32 * v12 - 32 > (unint64_t)a2
          && !llvm::Instruction::isLifetimeStartOrEnd((llvm::Instruction *)v3))
        {
          uint64_t v65 = 0;
          if (sub_1CD40EA84(*(void *)(v8 + 96), *(_DWORD *)(v8 + 112), v3, &v65))
          {
            char v13 = v65;
            uint64_t v14 = *(void *)(v8 + 96);
            uint64_t v15 = *(unsigned int *)(v8 + 112);
          }
          else
          {
            uint64_t v14 = *(void *)(v8 + 96);
            uint64_t v15 = *(unsigned int *)(v8 + 112);
            char v13 = (const char *)(v14 + 16 * v15);
          }
          if (v13 != (const char *)(v14 + 16 * v15))
          {
            sub_1CD65F520(*(void *)(a1 + 16) + 24, &v43);
            return 1;
          }
          int v19 = *(_DWORD *)(v3 + 20);
          uint64_t v20 = v3 - 32 * (v19 & 0x7FFFFFF);
          unint64_t v21 = (unint64_t)a2 - v20;
          if ((v19 & 0x40000000) != 0) {
            uint64_t v20 = *(void *)(v3 - 8);
          }
          uint64_t v22 = (v21 >> 5);
          uint64_t v23 = sub_1CC8BB6D4(*(void *)(a1 + 24), (v20 + 32 * v22) | 3, 0, v8, 1, 0, 1);
          int v24 = *(_DWORD *)(v3 + 20);
          uint64_t v25 = (v24 & 0x40000000) != 0 ? *(void *)(v3 - 8) : v3 - 32 * (v24 & 0x7FFFFFF);
          int v26 = sub_1CC8B87DC(*(void *)(a1 + 24), (v25 + 32 * v22) | 3, 0, v8, 1, 0, 1);
          uint64_t v27 = *(void *)(a1 + 16);
          if ((~*((unsigned __int16 *)v23 + 21) & 7) != 0 || !*((unsigned char *)v26 + 41) && *(_DWORD *)(v27 + 8) != 91)
          {
            *(unsigned char *)(v27 + 16) |= *((unsigned char *)v26 + 41) == 0;
            if (**(unsigned char **)a1)
            {
              if (*(_DWORD *)(v27 + 8) == 91)
              {
                unsigned int v28 = *(void **)(a1 + 24);
                uint64_t v29 = (uint64_t (*)(void, void))v28[687];
                if (v29)
                {
                  uint64_t v30 = (uint64_t ***)v29(v28[688], *(void *)(*(void *)(v3 + 40) + 56));
                  uint64_t v31 = *(void *)***v30;
                  if (*(void *)(v31 + 128)
                    || (*(unsigned int (**)(void))(**(void **)(v31 + 72) + 48))(*(void *)(v31 + 72)))
                  {
                    llvm::OptimizationRemarkMissed::OptimizationRemarkMissed((uint64_t)&v54, v28[689], (uint64_t)"OMP113", 6, v3);
                    uint64_t v65 = "Could not move globalized variable to the stack. Variable is potentially captured in call. Mar"
                    uint64_t v66 = 149;
                    sub_1CC59ADEC((uint64_t *)&v62, (uint64_t)&v65);
                    LODWORD(v66) = v55;
                    BYTE4(v66) = v56;
                    long long v67 = v57;
                    uint64_t v68 = v58;
                    long long v69 = v59;
                    long long v70 = v60;
                    uint64_t v65 = (const char *)&unk_1F2616800;
                    uint64_t v71 = v61;
                    uint64_t v72 = v74;
                    uint64_t v73 = 0x400000000;
                    if (v63) {
                      sub_1CD494D68((uint64_t)&v72, (uint64_t)&v62);
                    }
                    uint64_t v75 = v64[32];
                    uint64_t v76 = v64[33];
                    uint64_t v65 = (const char *)&unk_1F26165A8;
                    unint64_t v44 = " [";
                    uint64_t v45 = 2;
                    sub_1CC59ADEC((uint64_t *)&v72, (uint64_t)&v44);
                    unint64_t v44 = "OMP113";
                    uint64_t v45 = 6;
                    sub_1CC59ADEC((uint64_t *)&v72, (uint64_t)&v44);
                    unint64_t v44 = "]";
                    uint64_t v45 = 1;
                    sub_1CC59ADEC((uint64_t *)&v72, (uint64_t)&v44);
                    LODWORD(v45) = v66;
                    BYTE4(v45) = BYTE4(v66);
                    long long v46 = v67;
                    uint64_t v47 = v68;
                    long long v48 = v69;
                    unint64_t v44 = (const char *)&unk_1F2616800;
                    long long v49 = v70;
                    uint64_t v50 = v71;
                    unsigned int v51 = v53;
                    uint64_t v52 = 0x400000000;
                    unsigned int v32 = v73;
                    if (v73)
                    {
                      sub_1CD494D68((uint64_t)&v51, (uint64_t)&v72);
                      unsigned int v32 = v73;
                    }
                    v53[32] = v75;
                    v53[33] = v76;
                    unint64_t v44 = (const char *)&unk_1F26165A8;
                    uint64_t v65 = (const char *)&unk_1F2616800;
                    unint64_t v33 = (char *)v72;
                    if (v32)
                    {
                      unint64_t v34 = (unint64_t)v32 << 6;
                      do
                      {
                        unsigned int v35 = (void **)&v33[v34];
                        if (v33[v34 - 17] < 0) {
                          operator delete(*(v35 - 5));
                        }
                        if (*((char *)v35 - 41) < 0) {
                          operator delete(*(v35 - 8));
                        }
                        v34 -= 64;
                      }
                      while (v34);
                      unint64_t v33 = (char *)v72;
                    }
                    if (v33 != v74) {
                      free(v33);
                    }
                    uint64_t v54 = &unk_1F2616800;
                    int v36 = (char *)v62;
                    if (v63)
                    {
                      unint64_t v37 = (unint64_t)v63 << 6;
                      do
                      {
                        uint64_t v38 = (void **)&v36[v37];
                        if (v36[v37 - 17] < 0) {
                          operator delete(*(v38 - 5));
                        }
                        if (*((char *)v38 - 41) < 0) {
                          operator delete(*(v38 - 8));
                        }
                        v37 -= 64;
                      }
                      while (v37);
                      int v36 = (char *)v62;
                    }
                    if (v36 != (char *)v64) {
                      free(v36);
                    }
                    llvm::OptimizationRemarkEmitter::emit(v30, (llvm::DiagnosticInfoOptimizationBase *)&v44);
                    unint64_t v44 = (const char *)&unk_1F2616800;
                    unsigned int v39 = (char *)v51;
                    if (v52)
                    {
                      unint64_t v40 = (unint64_t)v52 << 6;
                      do
                      {
                        uint64_t v41 = (void **)&v39[v40];
                        if (v39[v40 - 17] < 0) {
                          operator delete(*(v41 - 5));
                        }
                        if (*((char *)v41 - 41) < 0) {
                          operator delete(*(v41 - 8));
                        }
                        v40 -= 64;
                      }
                      while (v40);
                      unsigned int v39 = (char *)v51;
                    }
                    if (v39 != (char *)v53) {
                      free(v39);
                    }
                  }
                }
              }
            }
            goto LABEL_4;
          }
        }
      }
    }
  }
  return 1;
}

uint64_t sub_1CC8F2D68(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    uint64_t v3 = *(void *)a1 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 24) + 16 * *(unsigned int *)(v3 + 8) + 8);
  }
}

void *sub_1CC8F2DEC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F2E30(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8F2E94(char *a1@<X8>)
{
  a1[23] = 9;
  strcpy(a1, "reachable");
}

void sub_1CC8F2EB8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C1F8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C1F8))
  {
    __cxa_guard_release(&qword_1EA61C1F8);
  }
}

uint64_t sub_1CC8F2F0C()
{
  return 1;
}

uint64_t *sub_1CC8F2F14(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F2F3C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8F2FA4(void *a1)
{
  *a1 = &unk_1F2626E80;
  a1[4] = &unk_1F2626F10;
  uint64_t v2 = (void *)a1[19];
  if (v2 != (void *)a1[18]) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3 != (void *)a1[6]) {
    free(v3);
  }
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F304C(void *a1)
{
  *a1 = &unk_1F2626E80;
  a1[4] = &unk_1F2626F10;
  uint64_t v2 = (void *)a1[19];
  if (v2 != (void *)a1[18]) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3 != (void *)a1[6]) {
    free(v3);
  }
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8F3114@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 41)) {
    uint64_t v3 = "undefined-behavior";
  }
  else {
    uint64_t v3 = "no-ub";
  }
  if (*(unsigned char *)(a1 + 41)) {
    size_t v4 = 18;
  }
  else {
    size_t v4 = 5;
  }
  a2[23] = v4;
  __n128 result = memcpy(a2, v3, v4);
  a2[v4] = 0;
  return result;
}

uint64_t sub_1CC8F3170(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 68) == *(_DWORD *)(a1 + 72)) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = 64;
  if (v4 == *(void *)(a1 + 48)) {
    uint64_t v5 = 68;
  }
  uint64_t v6 = *(unsigned int *)(a1 + v5);
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    for (uint64_t i = *(uint64_t **)(a1 + 56); (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v7 -= 8;
      if (!v7) {
        return 0;
      }
    }
  }
  else
  {
    uint64_t i = *(uint64_t **)(a1 + 56);
  }
  int v9 = (void *)(v4 + 8 * v6);
  if (i != v9)
  {
    uint64_t v10 = *i;
LABEL_13:
    sub_1CD65E44C(a2, v10);
    uint64_t v11 = (unint64_t *)(i + 1);
    while (v11 != v9)
    {
      unint64_t v12 = *v11++;
      uint64_t v10 = v12;
      if (v12 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t i = (uint64_t *)(v11 - 1);
        goto LABEL_13;
      }
    }
  }
  return 0;
}

void sub_1CC8F322C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA61C200, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EA61C200))
  {
    __cxa_guard_release(&qword_1EA61C200);
  }
}

BOOL sub_1CC8F3280(_DWORD *a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v4 = a1[17];
  int v5 = a1[18];
  int v6 = a1[41] - a1[42];
  v18[0] = a1;
  v18[1] = a2;
  v17[0] = a1;
  v17[1] = a2;
  v16[0] = a1;
  v16[1] = a2;
  v15[0] = a1;
  v15[1] = a2;
  long long v21 = xmmword_1CFB27370;
  int v19 = &v21;
  uint64_t v20 = 4;
  uint64_t v7 = (llvm::IRPosition *)(a1 + 4);
  unint64_t v8 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 4));
  llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8F3968, (uint64_t)v18, v8, (uint64_t)a1, (uint64_t)&v19, &v14, 1u, 0);
  LODWORD(v21) = 2;
  int v19 = &v21;
  uint64_t v20 = 1;
  unint64_t v9 = sub_1CD648A0C(v7);
  llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8F4410, (uint64_t)v17, v9, (uint64_t)a1, (uint64_t)&v19, &v14, 1u, 0);
  *(void *)&long long v21 = 0xB00000005;
  DWORD2(v21) = 56;
  int v19 = &v21;
  uint64_t v20 = 3;
  unint64_t v10 = sub_1CD648A0C(v7);
  llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8F47A8, (uint64_t)v16, v10, (uint64_t)a1, (uint64_t)&v19, &v14, 0, 0);
  if (*(unsigned char *)(**(void **)(*(void *)(sub_1CD6482A0(v7) + 24) + 16) + 8) != 7)
  {
    int v19 = (long long *)(sub_1CD6482A0(v7) | 1);
    uint64_t v20 = 0;
    if ((llvm::Attributor::isAssumedDead(a2, (uint64_t)&v19, (uint64_t)a1, 0, &v14, 0, 1) & 1) == 0)
    {
      if (*((unsigned char *)sub_1CC8B9CBC(a2, (uint64_t)v19, v20, (uint64_t)a1, 2, 0, 1) + 40))
      {
        int v13 = 1;
        *(void *)&long long v21 = &v13;
        *((void *)&v21 + 1) = 1;
        unint64_t v12 = sub_1CD648A0C(v7);
        llvm::Attributor::checkForAllInstructions(a2, sub_1CC8F4E20, (uint64_t)v15, v12, (uint64_t)a1, (uint64_t)&v21, &v14, 1u, 0);
      }
    }
  }
  return v6 == a1[41] - a1[42] && v4 - v5 == a1[17] - a1[18];
}

BOOL sub_1CC8F3514(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16) - 30;
  if (v3 > 0x23) {
    return v2;
  }
  if (((1 << v3) & 0xCC0000000) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 144);
    uint64_t v4 = *(void *)(a1 + 152);
    if (v4 == v5)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 164);
      uint64_t v7 = (void *)(v4 + 8 * v6);
      if (v6)
      {
        uint64_t v8 = 0;
        uint64_t v9 = 8 * v6;
        while (*(void *)(v4 + v8) != a2)
        {
          v8 += 8;
          if (v9 == v8) {
            goto LABEL_30;
          }
        }
LABEL_29:
        uint64_t v7 = (void *)(v4 + v8);
        goto LABEL_30;
      }
      goto LABEL_30;
    }
    uint64_t v10 = *(unsigned int *)(a1 + 160);
    int v11 = v10 - 1;
    unsigned int v12 = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v7 = (void *)(v4 + 8 * v12);
    uint64_t v13 = *v7;
    if (*v7 != -1)
    {
      char v14 = 0;
      int v15 = 1;
      while (v13 != a2)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == -2;
        }
        if (v16) {
          char v14 = v7;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v7 = (void *)(v4 + 8 * (v17 & v11));
        uint64_t v13 = *v7;
        if (*v7 == -1) {
          goto LABEL_47;
        }
      }
      goto LABEL_31;
    }
LABEL_46:
    char v14 = 0;
LABEL_47:
    if (v14) {
      uint64_t v7 = v14;
    }
    if (*v7 != a2) {
      uint64_t v7 = (void *)(v4 + 8 * v10);
    }
    goto LABEL_31;
  }
  if (*(unsigned char *)(a2 + 16) != 30) {
    return v2;
  }
  if ((*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 1) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v4 = *(void *)(a1 + 152);
  if (v4 != v5)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 160);
    int v22 = v10 - 1;
    unsigned int v23 = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v7 = (void *)(v4 + 8 * v23);
    uint64_t v24 = *v7;
    if (*v7 != -1)
    {
      char v14 = 0;
      int v25 = 1;
      while (v24 != a2)
      {
        if (v14) {
          BOOL v26 = 0;
        }
        else {
          BOOL v26 = v24 == -2;
        }
        if (v26) {
          char v14 = v7;
        }
        unsigned int v27 = v23 + v25++;
        unsigned int v23 = v27 & v22;
        uint64_t v7 = (void *)(v4 + 8 * (v27 & v22));
        uint64_t v24 = *v7;
        if (*v7 == -1) {
          goto LABEL_47;
        }
      }
      goto LABEL_31;
    }
    goto LABEL_46;
  }
  uint64_t v18 = *(unsigned int *)(a1 + 164);
  uint64_t v7 = (void *)(v4 + 8 * v18);
  if (v18)
  {
    uint64_t v8 = 0;
    uint64_t v19 = 8 * v18;
    while (*(void *)(v4 + v8) != a2)
    {
      v8 += 8;
      if (v19 == v8) {
        goto LABEL_30;
      }
    }
    goto LABEL_29;
  }
LABEL_30:
  uint64_t v5 = v4;
LABEL_31:
  BOOL v16 = v4 != v5;
  uint64_t v20 = 160;
  if (!v16) {
    uint64_t v20 = 164;
  }
  return v7 == (void *)(v4 + 8 * *(unsigned int *)(a1 + v20));
}

BOOL sub_1CC8F36F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2 == v3)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 68);
    uint64_t v5 = (void *)(v2 + 8 * v4);
    if (v4)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v4;
      while (*(void *)(v2 + v6) != a2)
      {
        v6 += 8;
        if (v7 == v6) {
          goto LABEL_19;
        }
      }
      uint64_t v5 = (void *)(v2 + v6);
    }
LABEL_19:
    uint64_t v3 = *(void *)(a1 + 56);
  }
  else
  {
    uint64_t v8 = *(unsigned int *)(a1 + 64);
    int v9 = v8 - 1;
    unsigned int v10 = (v8 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v5 = (void *)(v2 + 8 * v10);
    uint64_t v11 = *v5;
    if (*v5 == -1)
    {
      unsigned int v12 = 0;
LABEL_24:
      if (v12) {
        uint64_t v5 = v12;
      }
      if (*v5 != a2) {
        uint64_t v5 = (void *)(v2 + 8 * v8);
      }
    }
    else
    {
      unsigned int v12 = 0;
      int v13 = 1;
      while (v11 != a2)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          unsigned int v12 = v5;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        uint64_t v5 = (void *)(v2 + 8 * (v15 & v9));
        uint64_t v11 = *v5;
        if (*v5 == -1) {
          goto LABEL_24;
        }
      }
    }
  }
  BOOL v14 = v2 == v3;
  uint64_t v16 = 64;
  if (v14) {
    uint64_t v16 = 68;
  }
  return v5 != (void *)(v2 + 8 * *(unsigned int *)(a1 + v16));
}

uint64_t *sub_1CC8F37E0(void *a1)
{
  *(a1 - 4) = &unk_1F2626E80;
  *a1 = &unk_1F2626F10;
  uint64_t v2 = (void *)a1[15];
  if (v2 != (void *)a1[14]) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3 != (void *)a1[2]) {
    free(v3);
  }
  *(a1 - 4) = &unk_1F2620AA0;

  return sub_1CD64E248(a1 - 3);
}

void sub_1CC8F3890(void *a1)
{
  *(a1 - 4) = &unk_1F2626E80;
  *a1 = &unk_1F2626F10;
  uint64_t v2 = (void *)a1[15];
  if (v2 != (void *)a1[14]) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[3];
  if (v3 != (void *)a1[2]) {
    free(v3);
  }
  *(a1 - 4) = &unk_1F2620AA0;
  sub_1CD64E248(a1 - 3);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F3968(uint64_t a1, llvm::Instruction *this)
{
  uint64_t v4 = *(void *)a1;
  if (llvm::Instruction::isVolatile(this))
  {
    uint64_t v5 = *((unsigned __int8 *)this + 16) - 33;
    if (v5 <= 0x37)
    {
      if (((1 << (*((unsigned char *)this + 16) - 33)) & 0x8000000000041) != 0)
      {
        uint64_t v48 = *((void *)this + 8);
        if (!v48 || (*(unsigned char *)(v48 + 17) & 0x30) == 0)
        {
          int v49 = *((_DWORD *)this + 5);
          if (v49 < 0)
          {
            BOOL v81 = (char *)this - 32 * (v49 & 0x7FFFFFF);
            uint64_t v84 = *((void *)v81 - 1);
            uint64_t v82 = v81 - 8;
            uint64_t v83 = v84;
            if (v84)
            {
              uint64_t v85 = -v83;
              do
              {
                unsigned int v86 = *(_DWORD *)(*(void *)&v82[v85] + 8);
                BOOL v87 = v86 > 7;
                int v88 = (1 << v86) & 0x83;
                if (v87 || v88 == 0) {
                  return 1;
                }
                v85 += 16;
              }
              while (v85);
            }
          }
          if ((llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 45) & 1) == 0
            && !llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 44))
          {
            return 1;
          }
        }
      }
      else if (v5 == 27)
      {
        if ((*((_WORD *)this + 9) & 0x301) != 0) {
          return 1;
        }
      }
      else if (((1 << (*((unsigned char *)this + 16) - 33)) & 0x808001D0000010) != 0)
      {
        return 1;
      }
    }
  }
  uint64_t v7 = *(void *)(v4 + 144);
  uint64_t v6 = *(void *)(v4 + 152);
  if (v6 == v7)
  {
    uint64_t v8 = *(unsigned int *)(v4 + 164);
    int v9 = (llvm::Instruction **)(v6 + 8 * v8);
    if (v8)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 8 * v8;
      while (*(llvm::Instruction **)(v6 + v10) != this)
      {
        v10 += 8;
        if (v11 == v10) {
          goto LABEL_24;
        }
      }
      int v9 = (llvm::Instruction **)(v6 + v10);
    }
LABEL_24:
    uint64_t v7 = *(void *)(v4 + 152);
  }
  else
  {
    uint64_t v12 = *(unsigned int *)(v4 + 160);
    int v13 = v12 - 1;
    unsigned int v14 = (v12 - 1) & ((this >> 4) ^ (this >> 9));
    int v9 = (llvm::Instruction **)(v6 + 8 * v14);
    unsigned int v15 = *v9;
    if (*v9 == (llvm::Instruction *)-1)
    {
      uint64_t v16 = 0;
LABEL_46:
      if (v16) {
        int v9 = v16;
      }
      if (*v9 != this) {
        int v9 = (llvm::Instruction **)(v6 + 8 * v12);
      }
    }
    else
    {
      uint64_t v16 = 0;
      int v17 = 1;
      while (v15 != this)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == (llvm::Instruction *)-2;
        }
        if (v18) {
          uint64_t v16 = v9;
        }
        unsigned int v19 = v14 + v17++;
        unsigned int v14 = v19 & v13;
        int v9 = (llvm::Instruction **)(v6 + 8 * (v19 & v13));
        unsigned int v15 = *v9;
        if (*v9 == (llvm::Instruction *)-1) {
          goto LABEL_46;
        }
      }
    }
  }
  BOOL v18 = v6 == v7;
  uint64_t v20 = 160;
  if (v18) {
    uint64_t v20 = 164;
  }
  if (v9 != (llvm::Instruction **)(v6 + 8 * *(unsigned int *)(v4 + v20))) {
    return 1;
  }
  uint64_t v22 = *(void *)(v4 + 48);
  uint64_t v21 = *(void *)(v4 + 56);
  if (v21 == v22)
  {
    uint64_t v23 = *(unsigned int *)(v4 + 68);
    uint64_t v24 = (llvm::Instruction **)(v21 + 8 * v23);
    if (v23)
    {
      uint64_t v25 = 0;
      uint64_t v26 = 8 * v23;
      while (*(llvm::Instruction **)(v21 + v25) != this)
      {
        v25 += 8;
        if (v26 == v25) {
          goto LABEL_51;
        }
      }
      uint64_t v24 = (llvm::Instruction **)(v21 + v25);
    }
LABEL_51:
    uint64_t v22 = *(void *)(v4 + 56);
  }
  else
  {
    uint64_t v27 = *(unsigned int *)(v4 + 64);
    int v28 = v27 - 1;
    unsigned int v29 = (v27 - 1) & ((this >> 4) ^ (this >> 9));
    uint64_t v24 = (llvm::Instruction **)(v21 + 8 * v29);
    uint64_t v30 = *v24;
    if (*v24 == (llvm::Instruction *)-1)
    {
      uint64_t v31 = 0;
LABEL_95:
      if (v31) {
        uint64_t v24 = v31;
      }
      if (*v24 != this) {
        uint64_t v24 = (llvm::Instruction **)(v21 + 8 * v27);
      }
    }
    else
    {
      uint64_t v31 = 0;
      int v32 = 1;
      while (v30 != this)
      {
        if (v31) {
          BOOL v33 = 0;
        }
        else {
          BOOL v33 = v30 == (llvm::Instruction *)-2;
        }
        if (v33) {
          uint64_t v31 = v24;
        }
        unsigned int v34 = v29 + v32++;
        unsigned int v29 = v34 & v28;
        uint64_t v24 = (llvm::Instruction **)(v21 + 8 * (v34 & v28));
        uint64_t v30 = *v24;
        if (*v24 == (llvm::Instruction *)-1) {
          goto LABEL_95;
        }
      }
    }
  }
  BOOL v18 = v21 == v22;
  uint64_t v35 = 64;
  if (v18) {
    uint64_t v35 = 68;
  }
  if (v24 != (llvm::Instruction **)(v21 + 8 * *(unsigned int *)(v4 + v35))) {
    return 1;
  }
  int v36 = (unsigned char *)sub_1CC8F40B8(v4, *(llvm::Attributor **)(a1 + 8), *((void *)this + 4 * qword_1CFB273E8[*((char *)this + 16) - 60]), (uint64_t)this);
  if (!v37 || v36 == 0) {
    return 1;
  }
  if (v36[16] != 19)
  {
    uint64_t v42 = *(void *)(v4 + 152);
    uint64_t v43 = *(unsigned int *)(v4 + 164);
    if (v42 == *(void *)(v4 + 144))
    {
      if (v43)
      {
        uint64_t v50 = 0;
        uint64_t v51 = 8 * v43;
        uint64_t v52 = *(void **)(v4 + 152);
        while ((llvm::Instruction *)*v52 != this)
        {
          if (*v52 == -2) {
            uint64_t v50 = v52;
          }
          ++v52;
          v51 -= 8;
          if (!v51)
          {
            if (!v50) {
              goto LABEL_92;
            }
LABEL_169:
            void *v50 = this;
            --*(_DWORD *)(v4 + 168);
            return 1;
          }
        }
        return 1;
      }
LABEL_92:
      unsigned int v53 = *(_DWORD *)(v4 + 160);
      if (v43 < v53)
      {
LABEL_109:
        *(_DWORD *)(v4 + 164) = v43 + 1;
        goto LABEL_110;
      }
    }
    else
    {
      unsigned int v53 = *(_DWORD *)(v4 + 160);
    }
    if (3 * v53 <= 4 * ((int)v43 - *(_DWORD *)(v4 + 168)))
    {
      if (v53 >= 0x40) {
        v53 *= 2;
      }
      else {
        unsigned int v53 = 128;
      }
    }
    else if (v53 - v43 >= v53 >> 3)
    {
      goto LABEL_114;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 144), v53);
    unsigned int v53 = *(_DWORD *)(v4 + 160);
    uint64_t v42 = *(void *)(v4 + 152);
LABEL_114:
    unsigned int v57 = v53 - 1;
    unsigned int v58 = (v53 - 1) & ((this >> 4) ^ (this >> 9));
    long long v59 = (llvm::Instruction **)(v42 + 8 * v58);
    long long v60 = *v59;
    if (*v59 != (llvm::Instruction *)-1)
    {
      uint64_t v61 = 0;
      int v62 = 1;
      while (v60 != this)
      {
        if (v61) {
          BOOL v63 = 0;
        }
        else {
          BOOL v63 = v60 == (llvm::Instruction *)-2;
        }
        if (v63) {
          uint64_t v61 = v59;
        }
        unsigned int v64 = v58 + v62++;
        unsigned int v58 = v64 & v57;
        long long v59 = (llvm::Instruction **)(v42 + 8 * (v64 & v57));
        long long v60 = *v59;
        if (*v59 == (llvm::Instruction *)-1) {
          goto LABEL_140;
        }
      }
      return 1;
    }
    goto LABEL_139;
  }
  uint64_t v39 = *(void *)(*((void *)this + 5) + 56);
  unsigned int v40 = *(_DWORD *)(*(void *)v36 + 8);
  if ((v40 & 0xFE) == 0x12) {
    unsigned int v40 = *(_DWORD *)(**(void **)(*(void *)v36 + 16) + 8);
  }
  if (v39 && (uint64_t v41 = *(void *)(v39 + 112)) != 0)
  {
    if ((*(unsigned char *)(v41 + 17) & 1) == 0 && v40 <= 0xFF)
    {
LABEL_66:
      uint64_t v42 = *(void *)(v4 + 56);
      uint64_t v43 = *(unsigned int *)(v4 + 68);
      if (v42 == *(void *)(v4 + 48))
      {
        if (v43)
        {
          unint64_t v44 = 0;
          uint64_t v45 = 8 * v43;
          long long v46 = *(void **)(v4 + 56);
          while ((llvm::Instruction *)*v46 != this)
          {
            if (*v46 == -2) {
              unint64_t v44 = v46;
            }
            ++v46;
            v45 -= 8;
            if (!v45)
            {
              if (!v44) {
                goto LABEL_74;
              }
              *unint64_t v44 = this;
              --*(_DWORD *)(v4 + 72);
              return 1;
            }
          }
          return 1;
        }
LABEL_74:
        unsigned int v47 = *(_DWORD *)(v4 + 64);
        if (v43 < v47)
        {
          *(_DWORD *)(v4 + 68) = v43 + 1;
LABEL_110:
          *(void *)(v42 + 8 * v43) = this;
          return 1;
        }
      }
      else
      {
        unsigned int v47 = *(_DWORD *)(v4 + 64);
      }
      if (3 * v47 <= 4 * ((int)v43 - *(_DWORD *)(v4 + 72)))
      {
        if (v47 >= 0x40) {
          v47 *= 2;
        }
        else {
          unsigned int v47 = 128;
        }
      }
      else if (v47 - v43 >= v47 >> 3)
      {
        goto LABEL_149;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 48), v47);
      unsigned int v47 = *(_DWORD *)(v4 + 64);
      uint64_t v42 = *(void *)(v4 + 56);
LABEL_149:
      unsigned int v72 = v47 - 1;
      unsigned int v73 = (v47 - 1) & ((this >> 4) ^ (this >> 9));
      uint64_t v74 = (llvm::Instruction **)(v42 + 8 * v73);
      uint64_t v75 = *v74;
      if (*v74 != (llvm::Instruction *)-1)
      {
        uint64_t v76 = 0;
        int v77 = 1;
        while (v75 != this)
        {
          if (v76) {
            BOOL v78 = 0;
          }
          else {
            BOOL v78 = v75 == (llvm::Instruction *)-2;
          }
          if (v78) {
            uint64_t v76 = v74;
          }
          unsigned int v79 = v73 + v77++;
          unsigned int v73 = v79 & v72;
          uint64_t v74 = (llvm::Instruction **)(v42 + 8 * (v79 & v72));
          uint64_t v75 = *v74;
          if (*v74 == (llvm::Instruction *)-1) {
            goto LABEL_161;
          }
        }
        return 1;
      }
      uint64_t v76 = 0;
LABEL_161:
      if (v76) {
        uint64_t v71 = v76;
      }
      else {
        uint64_t v71 = v74;
      }
      if (*v71 != this)
      {
        if (*v71 == (llvm::Instruction *)-2) {
          --*(_DWORD *)(v4 + 72);
        }
        else {
          ++*(_DWORD *)(v4 + 68);
        }
LABEL_167:
        *uint64_t v71 = this;
        return 1;
      }
      return 1;
    }
  }
  else if (v40 < 0x100)
  {
    goto LABEL_66;
  }
  uint64_t v42 = *(void *)(v4 + 152);
  uint64_t v43 = *(unsigned int *)(v4 + 164);
  if (v42 == *(void *)(v4 + 144))
  {
    if (v43)
    {
      uint64_t v50 = 0;
      uint64_t v54 = 8 * v43;
      int v55 = *(void **)(v4 + 152);
      while ((llvm::Instruction *)*v55 != this)
      {
        if (*v55 == -2) {
          uint64_t v50 = v55;
        }
        ++v55;
        v54 -= 8;
        if (!v54)
        {
          if (v50) {
            goto LABEL_169;
          }
          goto LABEL_108;
        }
      }
      return 1;
    }
LABEL_108:
    unsigned int v56 = *(_DWORD *)(v4 + 160);
    if (v43 < v56) {
      goto LABEL_109;
    }
  }
  else
  {
    unsigned int v56 = *(_DWORD *)(v4 + 160);
  }
  if (3 * v56 <= 4 * ((int)v43 - *(_DWORD *)(v4 + 168)))
  {
    if (v56 >= 0x40) {
      v56 *= 2;
    }
    else {
      unsigned int v56 = 128;
    }
  }
  else if (v56 - v43 >= v56 >> 3)
  {
    goto LABEL_128;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 144), v56);
  unsigned int v56 = *(_DWORD *)(v4 + 160);
  uint64_t v42 = *(void *)(v4 + 152);
LABEL_128:
  unsigned int v65 = v56 - 1;
  unsigned int v66 = (v56 - 1) & ((this >> 4) ^ (this >> 9));
  long long v59 = (llvm::Instruction **)(v42 + 8 * v66);
  long long v67 = *v59;
  if (*v59 != (llvm::Instruction *)-1)
  {
    uint64_t v61 = 0;
    int v68 = 1;
    while (v67 != this)
    {
      if (v61) {
        BOOL v69 = 0;
      }
      else {
        BOOL v69 = v67 == (llvm::Instruction *)-2;
      }
      if (v69) {
        uint64_t v61 = v59;
      }
      unsigned int v70 = v66 + v68++;
      unsigned int v66 = v70 & v65;
      long long v59 = (llvm::Instruction **)(v42 + 8 * (v70 & v65));
      long long v67 = *v59;
      if (*v59 == (llvm::Instruction *)-1) {
        goto LABEL_140;
      }
    }
    return 1;
  }
LABEL_139:
  uint64_t v61 = 0;
LABEL_140:
  if (v61) {
    uint64_t v71 = v61;
  }
  else {
    uint64_t v71 = v59;
  }
  if (*v71 != this)
  {
    if (*v71 == (llvm::Instruction *)-2) {
      --*(_DWORD *)(v4 + 168);
    }
    else {
      ++*(_DWORD *)(v4 + 164);
    }
    goto LABEL_167;
  }
  return 1;
}

unint64_t sub_1CC8F40B8(uint64_t a1, llvm::Attributor *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = a3;
  BOOL v41 = 0;
  unsigned int v7 = *(unsigned __int8 *)(a3 + 16);
  if (v7 == 21) {
    goto LABEL_9;
  }
  if (v7 >= 0x1C)
  {
    unsigned int v8 = v7 - 33;
    BOOL v9 = v8 > 0x33;
    uint64_t v10 = (1 << v8) & 0x8000000000041;
    if (!v9 && v10 != 0)
    {
      uint64_t v12 = a3 | 1;
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (*(unsigned char *)(a3 + 16))
  {
LABEL_9:
    uint64_t v12 = a3;
    goto LABEL_10;
  }
  uint64_t v12 = a3 | 2;
LABEL_10:
  v40[0] = v12;
  v40[1] = 0;
  unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(a2, (const llvm::IRPosition *)v40, (const llvm::AbstractAttribute *)a1, &v41);
  if (v41)
  {
LABEL_11:
    if (*(unsigned __int8 *)(v5 + 16) - 11 > 1) {
      return v5;
    }
    uint64_t v15 = *(void *)(a1 + 56);
    uint64_t v16 = *(unsigned int *)(a1 + 68);
    if (v15 != *(void *)(a1 + 48))
    {
      unsigned int v20 = *(_DWORD *)(a1 + 64);
      goto LABEL_26;
    }
    if (v16)
    {
      int v17 = 0;
      uint64_t v18 = 8 * v16;
      unsigned int v19 = *(void **)(a1 + 56);
      while (*v19 != a4)
      {
        if (*v19 == -2) {
          int v17 = v19;
        }
        ++v19;
        v18 -= 8;
        if (!v18)
        {
          if (v17) {
            goto LABEL_74;
          }
          goto LABEL_20;
        }
      }
      return 0;
    }
LABEL_20:
    unsigned int v20 = *(_DWORD *)(a1 + 64);
    if (v16 >= v20)
    {
LABEL_26:
      if (3 * v20 <= 4 * ((int)v16 - *(_DWORD *)(a1 + 72)))
      {
        if (v20 >= 0x40) {
          v20 *= 2;
        }
        else {
          unsigned int v20 = 128;
        }
      }
      else if (v20 - v16 >= v20 >> 3)
      {
        goto LABEL_28;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 48), v20);
      unsigned int v20 = *(_DWORD *)(a1 + 64);
      uint64_t v15 = *(void *)(a1 + 56);
LABEL_28:
      unsigned int v21 = v20 - 1;
      unsigned int v22 = (v20 - 1) & ((a4 >> 4) ^ (a4 >> 9));
      uint64_t v23 = (void *)(v15 + 8 * v22);
      uint64_t v24 = *v23;
      if (*v23 != -1)
      {
        uint64_t v25 = 0;
        int v26 = 1;
        while (v24 != a4)
        {
          if (v25) {
            BOOL v27 = 0;
          }
          else {
            BOOL v27 = v24 == -2;
          }
          if (v27) {
            uint64_t v25 = v23;
          }
          unsigned int v28 = v22 + v26++;
          unsigned int v22 = v28 & v21;
          uint64_t v23 = (void *)(v15 + 8 * (v28 & v21));
          uint64_t v24 = *v23;
          if (*v23 == -1) {
            goto LABEL_65;
          }
        }
        return 0;
      }
      goto LABEL_64;
    }
LABEL_48:
    unint64_t v5 = 0;
    *(_DWORD *)(a1 + 68) = v16 + 1;
    *(void *)(v15 + 8 * v16) = a4;
    return v5;
  }
  if (v14)
  {
    unint64_t v5 = AssumedSimplified;
    if (!AssumedSimplified) {
      return v5;
    }
    goto LABEL_11;
  }
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(unsigned int *)(a1 + 68);
  if (v15 == *(void *)(a1 + 48))
  {
    if (v16)
    {
      int v17 = 0;
      uint64_t v29 = 8 * v16;
      uint64_t v30 = *(void **)(a1 + 56);
      while (*v30 != a4)
      {
        if (*v30 == -2) {
          int v17 = v30;
        }
        ++v30;
        v29 -= 8;
        if (!v29)
        {
          if (!v17) {
            goto LABEL_47;
          }
LABEL_74:
          unint64_t v5 = 0;
          *int v17 = a4;
          --*(_DWORD *)(a1 + 72);
          return v5;
        }
      }
      return 0;
    }
LABEL_47:
    unsigned int v31 = *(_DWORD *)(a1 + 64);
    if (v16 < v31) {
      goto LABEL_48;
    }
  }
  else
  {
    unsigned int v31 = *(_DWORD *)(a1 + 64);
  }
  if (3 * v31 <= 4 * ((int)v16 - *(_DWORD *)(a1 + 72)))
  {
    if (v31 >= 0x40) {
      v31 *= 2;
    }
    else {
      unsigned int v31 = 128;
    }
  }
  else if (v31 - v16 >= v31 >> 3)
  {
    goto LABEL_53;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 48), v31);
  unsigned int v31 = *(_DWORD *)(a1 + 64);
  uint64_t v15 = *(void *)(a1 + 56);
LABEL_53:
  unsigned int v32 = v31 - 1;
  unsigned int v33 = (v31 - 1) & ((a4 >> 4) ^ (a4 >> 9));
  uint64_t v23 = (void *)(v15 + 8 * v33);
  uint64_t v34 = *v23;
  if (*v23 != -1)
  {
    uint64_t v25 = 0;
    int v35 = 1;
    while (v34 != a4)
    {
      if (v25) {
        BOOL v36 = 0;
      }
      else {
        BOOL v36 = v34 == -2;
      }
      if (v36) {
        uint64_t v25 = v23;
      }
      unsigned int v37 = v33 + v35++;
      unsigned int v33 = v37 & v32;
      uint64_t v23 = (void *)(v15 + 8 * (v37 & v32));
      uint64_t v34 = *v23;
      if (*v23 == -1) {
        goto LABEL_65;
      }
    }
    return 0;
  }
LABEL_64:
  uint64_t v25 = 0;
LABEL_65:
  if (v25) {
    uint64_t v38 = v25;
  }
  else {
    uint64_t v38 = v23;
  }
  if (*v38 == a4) {
    return 0;
  }
  if (*v38 == -2) {
    --*(_DWORD *)(a1 + 72);
  }
  else {
    ++*(_DWORD *)(a1 + 68);
  }
  unint64_t v5 = 0;
  *uint64_t v38 = a4;
  return v5;
}

uint64_t sub_1CC8F4410(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v5 = (llvm::SmallPtrSetImplBase *)(*a1 + 144);
  uint64_t v4 = *(void *)v5;
  uint64_t v6 = *(void *)(*a1 + 152);
  if (v6 == *(void *)v5)
  {
    uint64_t v7 = *(unsigned int *)(v3 + 164);
    unsigned int v8 = (void *)(v6 + 8 * v7);
    if (v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v7;
      while (*(void *)(v6 + v9) != a2)
      {
        v9 += 8;
        if (v10 == v9) {
          goto LABEL_19;
        }
      }
      unsigned int v8 = (void *)(v6 + v9);
    }
LABEL_19:
    uint64_t v4 = *(void *)(*a1 + 152);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(v3 + 160);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unsigned int v8 = (void *)(v6 + 8 * v13);
    uint64_t v14 = *v8;
    if (*v8 == -1)
    {
      uint64_t v15 = 0;
LABEL_41:
      if (v15) {
        unsigned int v8 = v15;
      }
      if (*v8 != a2) {
        unsigned int v8 = (void *)(v6 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != a2)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v8;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        unsigned int v8 = (void *)(v6 + 8 * (v18 & v12));
        uint64_t v14 = *v8;
        if (*v8 == -1) {
          goto LABEL_41;
        }
      }
    }
  }
  BOOL v17 = v6 == v4;
  uint64_t v19 = 160;
  if (v17) {
    uint64_t v19 = 164;
  }
  if (v8 == (void *)(v6 + 8 * *(unsigned int *)(v3 + v19)))
  {
    uint64_t v21 = *(void *)(v3 + 48);
    uint64_t v20 = *(void *)(v3 + 56);
    if (v20 == v21)
    {
      uint64_t v22 = *(unsigned int *)(v3 + 68);
      uint64_t v23 = (void *)(v20 + 8 * v22);
      if (v22)
      {
        uint64_t v24 = 0;
        uint64_t v25 = 8 * v22;
        while (*(void *)(v20 + v24) != a2)
        {
          v24 += 8;
          if (v25 == v24) {
            goto LABEL_46;
          }
        }
        uint64_t v23 = (void *)(v20 + v24);
      }
LABEL_46:
      uint64_t v21 = *(void *)(v3 + 56);
    }
    else
    {
      uint64_t v26 = *(unsigned int *)(v3 + 64);
      int v27 = v26 - 1;
      unsigned int v28 = (v26 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v23 = (void *)(v20 + 8 * v28);
      uint64_t v29 = *v23;
      if (*v23 == -1)
      {
        uint64_t v30 = 0;
LABEL_66:
        if (v30) {
          uint64_t v23 = v30;
        }
        if (*v23 != a2) {
          uint64_t v23 = (void *)(v20 + 8 * v26);
        }
      }
      else
      {
        uint64_t v30 = 0;
        int v31 = 1;
        while (v29 != a2)
        {
          if (v30) {
            BOOL v32 = 0;
          }
          else {
            BOOL v32 = v29 == -2;
          }
          if (v32) {
            uint64_t v30 = v23;
          }
          unsigned int v33 = v28 + v31++;
          unsigned int v28 = v33 & v27;
          uint64_t v23 = (void *)(v20 + 8 * (v33 & v27));
          uint64_t v29 = *v23;
          if (*v23 == -1) {
            goto LABEL_66;
          }
        }
      }
    }
    BOOL v17 = v20 == v21;
    uint64_t v34 = 64;
    if (v17) {
      uint64_t v34 = 68;
    }
    if (v23 == (void *)(v20 + 8 * *(unsigned int *)(v3 + v34)) && (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) != 1)
    {
      unint64_t v35 = sub_1CC8F40B8(*a1, (llvm::Attributor *)a1[1], *(void *)(a2 - 96), a2);
      if (v36 && v35 != 0)
      {
        uint64_t v38 = *(void *)(v3 + 152);
        uint64_t v39 = *(unsigned int *)(v3 + 164);
        if (v38 == *(void *)(v3 + 144))
        {
          if (v39)
          {
            unsigned int v40 = 0;
            uint64_t v41 = 8 * v39;
            uint64_t v42 = *(uint64_t **)(v3 + 152);
            while (*v42 != a2)
            {
              if (*v42 == -2) {
                unsigned int v40 = v42;
              }
              ++v42;
              v41 -= 8;
              if (!v41)
              {
                if (!v40) {
                  goto LABEL_63;
                }
                *unsigned int v40 = a2;
                --*(_DWORD *)(v3 + 168);
                return 1;
              }
            }
            return 1;
          }
LABEL_63:
          unsigned int v43 = *(_DWORD *)(v3 + 160);
          if (v39 < v43)
          {
            *(_DWORD *)(v3 + 164) = v39 + 1;
            *(void *)(v38 + 8 * v39) = a2;
            return 1;
          }
        }
        else
        {
          unsigned int v43 = *(_DWORD *)(v3 + 160);
        }
        if (3 * v43 <= 4 * ((int)v39 - *(_DWORD *)(v3 + 168)))
        {
          if (v43 >= 0x40) {
            v43 *= 2;
          }
          else {
            unsigned int v43 = 128;
          }
        }
        else if (v43 - v39 >= v43 >> 3)
        {
          goto LABEL_73;
        }
        llvm::SmallPtrSetImplBase::Grow(v5, v43);
        unsigned int v43 = *(_DWORD *)(v3 + 160);
        uint64_t v38 = *(void *)(v3 + 152);
LABEL_73:
        unsigned int v44 = v43 - 1;
        unsigned int v45 = (v43 - 1) & ((a2 >> 4) ^ (a2 >> 9));
        long long v46 = (uint64_t *)(v38 + 8 * v45);
        uint64_t v47 = *v46;
        if (*v46 == -1)
        {
          uint64_t v48 = 0;
LABEL_85:
          if (v48) {
            uint64_t v52 = v48;
          }
          else {
            uint64_t v52 = v46;
          }
          if (*v52 != a2)
          {
            if (*v52 == -2) {
              --*(_DWORD *)(v3 + 168);
            }
            else {
              ++*(_DWORD *)(v3 + 164);
            }
            *uint64_t v52 = a2;
          }
        }
        else
        {
          uint64_t v48 = 0;
          int v49 = 1;
          while (v47 != a2)
          {
            if (v48) {
              BOOL v50 = 0;
            }
            else {
              BOOL v50 = v47 == -2;
            }
            if (v50) {
              uint64_t v48 = v46;
            }
            unsigned int v51 = v45 + v49++;
            unsigned int v45 = v51 & v44;
            long long v46 = (uint64_t *)(v38 + 8 * (v51 & v44));
            uint64_t v47 = *v46;
            if (*v46 == -1) {
              goto LABEL_85;
            }
          }
        }
      }
    }
  }
  return 1;
}

uint64_t sub_1CC8F47A8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  uint64_t v6 = *(void *)(*a1 + 144);
  uint64_t v5 = *(void *)(*a1 + 152);
  if (v5 == v6)
  {
    uint64_t v7 = *(unsigned int *)(v4 + 164);
    unsigned int v8 = (void *)(v5 + 8 * v7);
    if (v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v7;
      while (*(void *)(v5 + v9) != a2)
      {
        v9 += 8;
        if (v10 == v9) {
          goto LABEL_19;
        }
      }
      unsigned int v8 = (void *)(v5 + v9);
    }
LABEL_19:
    uint64_t v6 = *(void *)(*a1 + 152);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(v4 + 160);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unsigned int v8 = (void *)(v5 + 8 * v13);
    uint64_t v14 = *v8;
    if (*v8 == -1)
    {
      uint64_t v15 = 0;
LABEL_41:
      if (v15) {
        unsigned int v8 = v15;
      }
      if (*v8 != a2) {
        unsigned int v8 = (void *)(v5 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != a2)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -2;
        }
        if (v17) {
          uint64_t v15 = v8;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        unsigned int v8 = (void *)(v5 + 8 * (v18 & v12));
        uint64_t v14 = *v8;
        if (*v8 == -1) {
          goto LABEL_41;
        }
      }
    }
  }
  BOOL v17 = v5 == v6;
  uint64_t v19 = 160;
  if (v17) {
    uint64_t v19 = 164;
  }
  if (v8 == (void *)(v5 + 8 * *(unsigned int *)(v4 + v19)))
  {
    uint64_t v21 = *(void *)(v4 + 48);
    uint64_t v20 = *(void *)(v4 + 56);
    if (v20 == v21)
    {
      uint64_t v22 = *(unsigned int *)(v4 + 68);
      uint64_t v23 = (void *)(v20 + 8 * v22);
      if (v22)
      {
        uint64_t v24 = 0;
        uint64_t v25 = 8 * v22;
        while (*(void *)(v20 + v24) != a2)
        {
          v24 += 8;
          if (v25 == v24) {
            goto LABEL_46;
          }
        }
        uint64_t v23 = (void *)(v20 + v24);
      }
LABEL_46:
      uint64_t v21 = *(void *)(v4 + 56);
    }
    else
    {
      uint64_t v26 = *(unsigned int *)(v4 + 64);
      int v27 = v26 - 1;
      unsigned int v28 = (v26 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v23 = (void *)(v20 + 8 * v28);
      uint64_t v29 = *v23;
      if (*v23 == -1)
      {
        uint64_t v30 = 0;
LABEL_156:
        if (v30) {
          uint64_t v23 = v30;
        }
        if (*v23 != a2) {
          uint64_t v23 = (void *)(v20 + 8 * v26);
        }
      }
      else
      {
        uint64_t v30 = 0;
        int v31 = 1;
        while (v29 != a2)
        {
          if (v30) {
            BOOL v32 = 0;
          }
          else {
            BOOL v32 = v29 == -2;
          }
          if (v32) {
            uint64_t v30 = v23;
          }
          unsigned int v33 = v28 + v31++;
          unsigned int v28 = v33 & v27;
          uint64_t v23 = (void *)(v20 + 8 * (v33 & v27));
          uint64_t v29 = *v23;
          if (*v23 == -1) {
            goto LABEL_156;
          }
        }
      }
    }
    BOOL v17 = v20 == v21;
    uint64_t v34 = 64;
    if (v17) {
      uint64_t v34 = 68;
    }
    if (v23 == (void *)(v20 + 8 * *(unsigned int *)(v4 + v34)))
    {
      uint64_t v36 = *(void *)(a2 - 32);
      if (v36)
      {
        if (!*(unsigned char *)(v36 + 16) && *(void *)(v36 + 24) == *(void *)(a2 + 72))
        {
          unsigned int v37 = 0;
          uint64_t v38 = (uint64_t *)(a2 - 8);
          unsigned int v82 = (a2 >> 4) ^ (a2 >> 9);
          while (1)
          {
            int v39 = *(unsigned __int8 *)(a2 + 16);
            if (v39 == 84)
            {
              uint64_t v40 = 0;
            }
            else if (v39 == 39)
            {
              uint64_t v40 = (*(_DWORD *)(a2 + 80) + 1);
            }
            else
            {
              uint64_t v40 = 2;
            }
            int v41 = *(_DWORD *)(a2 + 20);
            if (v41 < 0 && (v38[-4 * (v41 & 0x7FFFFFF)] & 0xFFFFFFFF0) != 0)
            {
              uint64_t v43 = -(uint64_t)(v41 & 0x7FFFFFF);
              int v42 = *(_DWORD *)(a2 - 32 * (v41 & 0x7FFFFFF) - 12)
                  - *(_DWORD *)(a2 - 32 * (v41 & 0x7FFFFFF) - *(void *)(a2 - 32 * (v41 & 0x7FFFFFF) - 8));
            }
            else
            {
              int v42 = 0;
              uint64_t v43 = -(uint64_t)(v41 & 0x7FFFFFF);
            }
            uint64_t v44 = a2 - 32 - 32 * v40 + 32 * -v42;
            uint64_t v45 = a2 + 32 * v43;
            if (v37 >= ((unint64_t)(v44 - v45) >> 5)
              || *(void *)(v36 + 96) <= (unint64_t)v37)
            {
              return 1;
            }
            uint64_t v46 = *(void *)(v45 + 32 * v37);
            if (!v46) {
              goto LABEL_75;
            }
            if ((v41 & 0x40000000) != 0) {
              uint64_t v45 = *v38;
            }
            uint64_t v47 = (v45 + 32 * v37) | 3;
            if (!*((unsigned char *)sub_1CC8B9CBC(a1[1], v47, 0, v4, 2, 0, 1) + 40)) {
              goto LABEL_75;
            }
            BOOL v84 = 0;
            unsigned int v48 = *(unsigned __int8 *)(v46 + 16);
            if (v48 == 21) {
              goto LABEL_73;
            }
            if (v48 >= 0x1C) {
              break;
            }
            if (*(unsigned char *)(v46 + 16)) {
              goto LABEL_73;
            }
            uint64_t v53 = v46 | 2;
LABEL_74:
            uint64_t v54 = (llvm::Attributor *)a1[1];
            v83[0] = v53;
            v83[1] = 0;
            unint64_t AssumedSimplified = llvm::Attributor::getAssumedSimplified(v54, (const llvm::IRPosition *)v83, (const llvm::AbstractAttribute *)v4, &v84);
            if (v84) {
              goto LABEL_75;
            }
            if (v56 && !AssumedSimplified) {
              return 1;
            }
            if (!v56 || (int v57 = *(unsigned __int8 *)(AssumedSimplified + 16), (v57 - 11) <= 1))
            {
              uint64_t v58 = *(void *)(v4 + 56);
              uint64_t v59 = *(unsigned int *)(v4 + 68);
              if (v58 == *(void *)(v4 + 48))
              {
                if (v59)
                {
                  long long v60 = 0;
                  uint64_t v61 = 8 * v59;
                  int v62 = *(void **)(v4 + 56);
                  while (*v62 != a2)
                  {
                    if (*v62 == -2) {
                      long long v60 = v62;
                    }
                    ++v62;
                    v61 -= 8;
                    if (!v61)
                    {
                      if (v60) {
                        goto LABEL_140;
                      }
                      goto LABEL_88;
                    }
                  }
                  goto LABEL_75;
                }
LABEL_88:
                unsigned int v63 = *(_DWORD *)(v4 + 64);
                if (v59 < v63) {
                  goto LABEL_89;
                }
              }
              else
              {
                unsigned int v63 = *(_DWORD *)(v4 + 64);
              }
              if (3 * v63 <= 4 * ((int)v59 - *(_DWORD *)(v4 + 72)))
              {
                if (v63 >= 0x40) {
                  v63 *= 2;
                }
                else {
                  unsigned int v63 = 128;
                }
              }
              else if (v63 - v59 >= v63 >> 3)
              {
                goto LABEL_106;
              }
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 48), v63);
              unsigned int v63 = *(_DWORD *)(v4 + 64);
              uint64_t v58 = *(void *)(v4 + 56);
LABEL_106:
              unsigned int v67 = v63 - 1;
              unsigned int v68 = (v63 - 1) & v82;
              BOOL v69 = (void *)(v58 + 8 * v68);
              uint64_t v70 = *v69;
              if (*v69 != -1)
              {
                uint64_t v71 = 0;
                int v72 = 1;
                while (v70 != a2)
                {
                  if (v71) {
                    BOOL v73 = 0;
                  }
                  else {
                    BOOL v73 = v70 == -2;
                  }
                  if (v73) {
                    uint64_t v71 = v69;
                  }
                  unsigned int v74 = v68 + v72++;
                  unsigned int v68 = v74 & v67;
                  BOOL v69 = (void *)(v58 + 8 * (v74 & v67));
                  uint64_t v70 = *v69;
                  if (*v69 == -1) {
                    goto LABEL_133;
                  }
                }
                goto LABEL_75;
              }
LABEL_132:
              uint64_t v71 = 0;
LABEL_133:
              if (v71) {
                BOOL v81 = v71;
              }
              else {
                BOOL v81 = v69;
              }
              if (*v81 != a2)
              {
                if (*v81 == -2) {
                  --*(_DWORD *)(v4 + 72);
                }
                else {
                  ++*(_DWORD *)(v4 + 68);
                }
                *BOOL v81 = a2;
              }
              goto LABEL_75;
            }
            if (v57 != 19
              || *(unsigned char *)(*(void *)v46 + 8) != 15
              || !*((unsigned char *)sub_1CC8BA72C(a1[1], v47, 0, v4, 2, 0, 1) + 40))
            {
              goto LABEL_75;
            }
            uint64_t v58 = *(void *)(v4 + 56);
            uint64_t v59 = *(unsigned int *)(v4 + 68);
            if (v58 == *(void *)(v4 + 48))
            {
              if (v59)
              {
                long long v60 = 0;
                uint64_t v64 = 8 * v59;
                unsigned int v65 = *(void **)(v4 + 56);
                while (*v65 != a2)
                {
                  if (*v65 == -2) {
                    long long v60 = v65;
                  }
                  ++v65;
                  v64 -= 8;
                  if (!v64)
                  {
                    if (!v60) {
                      goto LABEL_101;
                    }
LABEL_140:
                    *long long v60 = a2;
                    --*(_DWORD *)(v4 + 72);
                    goto LABEL_75;
                  }
                }
                goto LABEL_75;
              }
LABEL_101:
              unsigned int v66 = *(_DWORD *)(v4 + 64);
              if (v59 < v66)
              {
LABEL_89:
                *(_DWORD *)(v4 + 68) = v59 + 1;
                *(void *)(v58 + 8 * v59) = a2;
                goto LABEL_75;
              }
            }
            else
            {
              unsigned int v66 = *(_DWORD *)(v4 + 64);
            }
            if (3 * v66 <= 4 * ((int)v59 - *(_DWORD *)(v4 + 72)))
            {
              if (v66 >= 0x40) {
                v66 *= 2;
              }
              else {
                unsigned int v66 = 128;
              }
LABEL_149:
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 48), v66);
              unsigned int v66 = *(_DWORD *)(v4 + 64);
              uint64_t v58 = *(void *)(v4 + 56);
              goto LABEL_121;
            }
            if (v66 - v59 < v66 >> 3) {
              goto LABEL_149;
            }
LABEL_121:
            unsigned int v75 = v66 - 1;
            unsigned int v76 = (v66 - 1) & v82;
            BOOL v69 = (void *)(v58 + 8 * v76);
            uint64_t v77 = *v69;
            if (*v69 == -1) {
              goto LABEL_132;
            }
            uint64_t v71 = 0;
            int v78 = 1;
            while (v77 != a2)
            {
              if (v71) {
                BOOL v79 = 0;
              }
              else {
                BOOL v79 = v77 == -2;
              }
              if (v79) {
                uint64_t v71 = v69;
              }
              unsigned int v80 = v76 + v78++;
              unsigned int v76 = v80 & v75;
              BOOL v69 = (void *)(v58 + 8 * (v80 & v75));
              uint64_t v77 = *v69;
              if (*v69 == -1) {
                goto LABEL_133;
              }
            }
LABEL_75:
            ++v37;
          }
          unsigned int v49 = v48 - 33;
          BOOL v50 = v49 > 0x33;
          uint64_t v51 = (1 << v49) & 0x8000000000041;
          if (!v50 && v51 != 0)
          {
            uint64_t v53 = v46 | 1;
            goto LABEL_74;
          }
LABEL_73:
          uint64_t v53 = v46;
          goto LABEL_74;
        }
      }
    }
  }
  return 1;
}

uint64_t sub_1CC8F4E20(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = sub_1CC8F40B8(*(void *)a1, *(llvm::Attributor **)(a1 + 8), *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)), a2);
  if (v6) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7) {
    return 1;
  }
  if (*(unsigned char *)(v5 + 16) != 19) {
    return 1;
  }
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = sub_1CD6482A0((_DWORD *)(v4 + 16));
  if (!*((unsigned char *)sub_1CC8BA72C(v9, v10 | 1, 0, v4, 2, 0, 1) + 40)) {
    return 1;
  }
  uint64_t v11 = *(void *)(v4 + 56);
  uint64_t v12 = *(unsigned int *)(v4 + 68);
  if (v11 != *(void *)(v4 + 48))
  {
    unsigned int v16 = *(_DWORD *)(v4 + 64);
    goto LABEL_19;
  }
  if (!v12)
  {
LABEL_16:
    unsigned int v16 = *(_DWORD *)(v4 + 64);
    if (v12 < v16)
    {
      *(_DWORD *)(v4 + 68) = v12 + 1;
      *(void *)(v11 + 8 * v12) = a2;
      return 1;
    }
LABEL_19:
    if (3 * v16 <= 4 * ((int)v12 - *(_DWORD *)(v4 + 72)))
    {
      if (v16 >= 0x40) {
        v16 *= 2;
      }
      else {
        unsigned int v16 = 128;
      }
    }
    else if (v16 - v12 >= v16 >> 3)
    {
      goto LABEL_21;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v4 + 48), v16);
    unsigned int v16 = *(_DWORD *)(v4 + 64);
    uint64_t v11 = *(void *)(v4 + 56);
LABEL_21:
    unsigned int v17 = v16 - 1;
    unsigned int v18 = (v16 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v19 = (uint64_t *)(v11 + 8 * v18);
    uint64_t v20 = *v19;
    if (*v19 == -1)
    {
      uint64_t v21 = 0;
LABEL_33:
      if (v21) {
        uint64_t v25 = v21;
      }
      else {
        uint64_t v25 = v19;
      }
      if (*v25 != a2)
      {
        if (*v25 == -2) {
          --*(_DWORD *)(v4 + 72);
        }
        else {
          ++*(_DWORD *)(v4 + 68);
        }
        *uint64_t v25 = a2;
      }
    }
    else
    {
      uint64_t v21 = 0;
      int v22 = 1;
      while (v20 != a2)
      {
        if (v21) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v20 == -2;
        }
        if (v23) {
          uint64_t v21 = v19;
        }
        unsigned int v24 = v18 + v22++;
        unsigned int v18 = v24 & v17;
        uint64_t v19 = (uint64_t *)(v11 + 8 * (v24 & v17));
        uint64_t v20 = *v19;
        if (*v19 == -1) {
          goto LABEL_33;
        }
      }
    }
    return 1;
  }
  unsigned int v13 = 0;
  uint64_t v14 = 8 * v12;
  uint64_t v15 = *(uint64_t **)(v4 + 56);
  while (*v15 != a2)
  {
    if (*v15 == -2) {
      unsigned int v13 = v15;
    }
    ++v15;
    v14 -= 8;
    if (!v14)
    {
      if (!v13) {
        goto LABEL_16;
      }
      uint64_t *v13 = a2;
      --*(_DWORD *)(v4 + 72);
      return 1;
    }
  }
  return 1;
}

void *sub_1CC8F5020(void *a1)
{
  *a1 = &unk_1F2626F70;
  a1[4] = &unk_1F2627010;
  uint64_t v2 = a1[22];
  if (v2)
  {
    uint64_t v3 = a1[23];
    uint64_t v4 = (void *)a1[22];
    if (v3 != v2)
    {
      do
      {
        MEMORY[0x1D25D9CD0](*(void *)(v3 - 32), 8);
        MEMORY[0x1D25D9CD0](*(void *)(v3 - 56), 8);
        v3 -= 64;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[22];
    }
    a1[23] = v2;
    operator delete(v4);
  }
  MEMORY[0x1D25D9CD0](a1[19], 8);
  uint64_t v5 = a1[16];
  if (v5)
  {
    uint64_t v6 = a1[17];
    BOOL v7 = (void *)a1[16];
    if (v6 != v5)
    {
      do
      {
        MEMORY[0x1D25D9CD0](*(void *)(v6 - 32), 8);
        MEMORY[0x1D25D9CD0](*(void *)(v6 - 56), 8);
        v6 -= 64;
      }
      while (v6 != v5);
      BOOL v7 = (void *)a1[16];
    }
    a1[17] = v5;
    operator delete(v7);
  }
  MEMORY[0x1D25D9CD0](a1[13], 8);
  MEMORY[0x1D25D9CD0](a1[9], 8);
  MEMORY[0x1D25D9CD0](a1[6], 8);
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F5174(void *a1)
{
  sub_1CC8F5020(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8F51AC(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  unint64_t v3 = (*(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 56));
  std::to_string(&v14, *(_DWORD *)(a1 + 56));
  uint64_t v4 = std::string::insert(&v14, 0, "FunctionReachability [");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v15, ",");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v16.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v16.__r_.__value_.__r.__words[2] = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, v3);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  unint64_t v10 = std::string::append(&v16, (const std::string::value_type *)p_p, size);
  std::string::size_type v11 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v17.__r_.__value_.__l.__data_ = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v17.__r_.__value_.__r.__words[2] = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  uint64_t v12 = std::string::append(&v17, "]");
  *a2 = *v12;
  v12->__r_.__value_.__r.__words[0] = 0;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v17.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

uint64_t sub_1CC8F5310(uint64_t *a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::IRPosition *)(a1 + 2);
  unsigned int v24 = sub_1CC8C5FA0(a2, a1[2], a1[3], (uint64_t)a1, 0);
  uint64_t v5 = sub_1CC8F5DBC((uint64_t)(a1 + 6), a2, (uint64_t)a1, (uint64_t)&v24, 1);
  std::string::size_type v7 = (uint64_t *)a1[16];
  uint64_t v6 = (uint64_t *)a1[17];
  if (v7 != v6)
  {
    unsigned int v8 = (uint64_t *)a1[16];
    do
    {
      uint64_t v9 = *v8;
      v8 += 8;
      unsigned int v24 = sub_1CC8C5FA0(a2, v9, 0, (uint64_t)a1, 0);
      unsigned int v10 = sub_1CC8F5DBC((uint64_t)(v7 + 1), a2, (uint64_t)a1, (uint64_t)&v24, 1);
      if (v5) {
        uint64_t v5 = v10;
      }
      else {
        uint64_t v5 = 0;
      }
      std::string::size_type v7 = v8;
    }
    while (v8 != v6);
  }
  if (a1[22] != a1[23])
  {
    unint64_t v12 = sub_1CD648A0C(v4);
    unsigned int v13 = sub_1CC8B3838(a2, v12, 0, (uint64_t)a1, 0, 0, 1);
    uint64_t v14 = a1[22];
    uint64_t v15 = a1[23];
    if (v14 != v15)
    {
      std::string v16 = v13;
      do
      {
        unsigned int v24 = v26;
        uint64_t v25 = 0x600000000;
        uint64_t v17 = *(void *)v14;
        v22[0] = v16;
        v22[1] = a2;
        v22[2] = v17;
        void v22[3] = a1;
        uint64_t v27 = 0xB00000005;
        int v28 = 56;
        v22[4] = &v24;
        v23[0] = &v27;
        v23[1] = 3;
        unint64_t v18 = sub_1CD648A0C(v4);
        if ((llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8F61F4, (uint64_t)v22, v18, (uint64_t)a1, (uint64_t)v23, &v21, 1u, 0) & 1) == 0)*(unsigned char *)(v14 + 56) = 1; {
        uint64_t v19 = v14 + 8;
        }
        unsigned int v20 = sub_1CC8F5DBC(v19, a2, (uint64_t)a1, (uint64_t)v24, v25);
        if (v5) {
          uint64_t v5 = v20;
        }
        else {
          uint64_t v5 = 0;
        }
        if (v24 != v26) {
          free(v24);
        }
        uint64_t v14 = v19 + 56;
      }
      while (v14 != v15);
    }
  }
  return v5;
}

uint64_t sub_1CC8F554C(uint64_t *a1, uint64_t a2, void *a3)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(void))(a1[4] + 16))()) {
    return 1;
  }
  v7[0] = sub_1CC8C5FA0(a2, a1[2], a1[3], (uint64_t)a1, 0);
  return sub_1CC8F6298((uint64_t)(a1 + 6), a2, (uint64_t)a1, (uint64_t)v7, 1, a3);
}

uint64_t sub_1CC8F5618(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(void))(a1[4] + 16))()) {
    return 1;
  }
  uint64_t v9 = sub_1CC8C5FA0(a2, a3, 0, (uint64_t)a1, 0);
  uint64_t v28 = a3;
  int v29 = 0;
  sub_1CD40E370((uint64_t)v30, (uint64_t)(a1 + 13), &v28, &v29);
  uint64_t v10 = v30[0];
  if (v31)
  {
    unint64_t v12 = (uint64_t *)a1[17];
    unint64_t v11 = a1[18];
    if ((unint64_t)v12 >= v11)
    {
      std::string v16 = (uint64_t *)a1[16];
      uint64_t v17 = ((char *)v12 - (char *)v16) >> 6;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 58) {
        abort();
      }
      uint64_t v19 = v11 - (void)v16;
      if (v19 >> 5 > v18) {
        unint64_t v18 = v19 >> 5;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFC0) {
        unint64_t v20 = 0x3FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20 >> 58) {
        sub_1CB833614();
      }
      char v21 = (char *)operator new(v20 << 6);
      int v22 = &v21[64 * v17];
      v22[56] = 0;
      *((void *)v22 + 1) = 0;
      *((void *)v22 + 2) = 0;
      *(void *)int v22 = a3;
      BOOL v23 = &v21[64 * v20];
      unsigned int v13 = v22 + 64;
      *((_DWORD *)v22 + 6) = 0;
      *((void *)v22 + 4) = 0;
      *((void *)v22 + 5) = 0;
      *((_DWORD *)v22 + 12) = 0;
      if (v12 == v16)
      {
        a1[16] = v22;
        a1[17] = v13;
        a1[18] = v23;
      }
      else
      {
        uint64_t v24 = 0;
        do
        {
          uint64_t v25 = &v12[v24];
          uint64_t v26 = &v22[v24 * 8];
          *((void *)v26 - 8) = v12[v24 - 8];
          *((void *)v26 - 7) = v12[v24 - 7];
          *(v25 - 7) = 0;
          *((_DWORD *)v26 - 12) = v12[v24 - 6];
          *((_DWORD *)v25 - 12) = 0;
          *((_DWORD *)v26 - 11) = *((_DWORD *)&v12[v24 - 5] - 1);
          *((_DWORD *)v25 - 11) = 0;
          *((_DWORD *)v26 - 10) = v12[v24 - 5];
          *((_DWORD *)v25 - 10) = 0;
          *((void *)v26 - 4) = v12[v24 - 4];
          *(v25 - 4) = 0;
          *((_DWORD *)v26 - 6) = v12[v24 - 3];
          *((_DWORD *)v25 - 6) = 0;
          *((_DWORD *)v26 - 5) = *((_DWORD *)&v12[v24 - 2] - 1);
          *((_DWORD *)v25 - 5) = 0;
          *((_DWORD *)v26 - 4) = v12[v24 - 2];
          *((_DWORD *)v25 - 4) = 0;
          *(v26 - 8) = v12[v24 - 1];
          v24 -= 8;
        }
        while (&v12[v24] != v16);
        unint64_t v12 = (uint64_t *)a1[16];
        uint64_t v27 = (uint64_t *)a1[17];
        a1[16] = &v22[v24 * 8];
        a1[17] = v13;
        for (a1[18] = v23; v27 != v12; v27 -= 8)
        {
          MEMORY[0x1D25D9CD0](*(v27 - 4), 8);
          MEMORY[0x1D25D9CD0](*(v27 - 7), 8);
        }
      }
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *((unsigned char *)v12 + 56) = 0;
      unsigned int v13 = v12 + 8;
      v12[1] = 0;
      void v12[2] = 0;
      *unint64_t v12 = a3;
      *((_DWORD *)v12 + 6) = 0;
      v12[4] = 0;
      v12[5] = 0;
      *((_DWORD *)v12 + 12) = 0;
    }
    a1[17] = v13;
    MEMORY[0x1D25D9CD0](0, 8);
    MEMORY[0x1D25D9CD0](0, 8);
    MEMORY[0x1D25D9CD0](0, 8);
    MEMORY[0x1D25D9CD0](0, 8);
    uint64_t v15 = a1[16];
    unsigned int v14 = ((unint64_t)(a1[17] - v15) >> 6) - 1;
    *(_DWORD *)(v10 + 8) = v14;
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(v30[0] + 8);
    uint64_t v15 = a1[16];
  }
  v30[0] = v9;
  return sub_1CC8F6298(v15 + ((unint64_t)v14 << 6) + 8, a2, (uint64_t)a1, (uint64_t)v30, 1, a4);
}

uint64_t sub_1CC8F5918(void *a1, uint64_t a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(void))(a1[4] + 16))()) {
    return 1;
  }
  if (a5)
  {
    uint64_t v45 = 0;
    uint64_t isPotentiallyReachable = llvm::AA::isPotentiallyReachable(a2, a3, (uint64_t)a4, (uint64_t)a1, (uint64_t)v44);
    if (v45 == v44)
    {
      (*(void (**)(void *))(v44[0] + 32))(v44);
    }
    else if (v45)
    {
      (*(void (**)(void))(*v45 + 40))();
    }
  }
  else
  {
    unint64_t v12 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 2));
    uint64_t v42 = 0x600000000;
    v35[0] = sub_1CC8B3838(a2, v12, 0, (uint64_t)a1, 0, 0, 1);
    v35[1] = a2;
    uint64_t v36 = a3;
    unsigned int v37 = a1;
    uint64_t v38 = &v41;
    uint64_t v46 = 0xB00000005;
    int v47 = 56;
    int v39 = &v46;
    uint64_t v40 = 3;
    int v41 = v43;
    unint64_t v13 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 2));
    char i = llvm::Attributor::checkForAllInstructions(a2, (uint64_t (*)(uint64_t, uint64_t))sub_1CC8F61F4, (uint64_t)v35, v13, (uint64_t)a1, (uint64_t)&v39, &v34, 1u, 0);
    int v39 = (uint64_t *)a3;
    LODWORD(v40) = 0;
    sub_1CD65FB5C((uint64_t)v35, (uint64_t)(a1 + 19), (uint64_t *)&v39, &v40);
    uint64_t v15 = v35[0];
    if ((_BYTE)v36)
    {
      uint64_t v17 = (uint64_t *)a1[23];
      unint64_t v16 = a1[24];
      if ((unint64_t)v17 >= v16)
      {
        char v33 = i;
        char v21 = (uint64_t *)a1[22];
        uint64_t v22 = ((char *)v17 - (char *)v21) >> 6;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 58) {
          abort();
        }
        uint64_t v24 = v16 - (void)v21;
        if (v24 >> 5 > v23) {
          unint64_t v23 = v24 >> 5;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFC0) {
          unint64_t v25 = 0x3FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25 >> 58) {
          sub_1CB833614();
        }
        uint64_t v26 = (char *)operator new(v25 << 6);
        uint64_t v27 = &v26[64 * v22];
        v27[56] = 0;
        *((void *)v27 + 1) = 0;
        *((void *)v27 + 2) = 0;
        *(void *)uint64_t v27 = a3;
        uint64_t v28 = &v26[64 * v25];
        unint64_t v18 = v27 + 64;
        *((_DWORD *)v27 + 6) = 0;
        *((void *)v27 + 4) = 0;
        *((void *)v27 + 5) = 0;
        *((_DWORD *)v27 + 12) = 0;
        if (v17 == v21)
        {
          a1[22] = v27;
          a1[23] = v18;
          a1[24] = v28;
          char i = v33;
        }
        else
        {
          uint64_t v29 = 0;
          do
          {
            uint64_t v30 = &v17[v29];
            char v31 = &v27[v29 * 8];
            *((void *)v31 - 8) = v17[v29 - 8];
            *((void *)v31 - 7) = v17[v29 - 7];
            *(v30 - 7) = 0;
            *((_DWORD *)v31 - 12) = v17[v29 - 6];
            *((_DWORD *)v30 - 12) = 0;
            *((_DWORD *)v31 - 11) = *((_DWORD *)&v17[v29 - 5] - 1);
            *((_DWORD *)v30 - 11) = 0;
            *((_DWORD *)v31 - 10) = v17[v29 - 5];
            *((_DWORD *)v30 - 10) = 0;
            *((void *)v31 - 4) = v17[v29 - 4];
            *(v30 - 4) = 0;
            *((_DWORD *)v31 - 6) = v17[v29 - 3];
            *((_DWORD *)v30 - 6) = 0;
            *((_DWORD *)v31 - 5) = *((_DWORD *)&v17[v29 - 2] - 1);
            *((_DWORD *)v30 - 5) = 0;
            *((_DWORD *)v31 - 4) = v17[v29 - 2];
            *((_DWORD *)v30 - 4) = 0;
            *(v31 - 8) = v17[v29 - 1];
            v29 -= 8;
          }
          while (&v17[v29] != v21);
          uint64_t v17 = (uint64_t *)a1[22];
          uint64_t v32 = (uint64_t *)a1[23];
          a1[22] = &v27[v29 * 8];
          a1[23] = v18;
          a1[24] = v28;
          for (char i = v33; v32 != v17; v32 -= 8)
          {
            MEMORY[0x1D25D9CD0](*(v32 - 4), 8);
            MEMORY[0x1D25D9CD0](*(v32 - 7), 8);
          }
        }
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *((unsigned char *)v17 + 56) = 0;
        unint64_t v18 = v17 + 8;
        v17[1] = 0;
        void v17[2] = 0;
        *uint64_t v17 = a3;
        *((_DWORD *)v17 + 6) = 0;
        v17[4] = 0;
        v17[5] = 0;
        *((_DWORD *)v17 + 12) = 0;
      }
      a1[23] = v18;
      MEMORY[0x1D25D9CD0](0, 8);
      MEMORY[0x1D25D9CD0](0, 8);
      MEMORY[0x1D25D9CD0](0, 8);
      MEMORY[0x1D25D9CD0](0, 8);
      uint64_t v20 = a1[22];
      unsigned int v19 = ((unint64_t)(a1[23] - v20) >> 6) - 1;
      *(_DWORD *)(v15 + 8) = v19;
    }
    else
    {
      unsigned int v19 = *(_DWORD *)(v35[0] + 8);
      uint64_t v20 = a1[22];
    }
    if ((i & 1) == 0) {
      *(unsigned char *)(v20 + ((unint64_t)v19 << 6) + 56) = 1;
    }
    uint64_t isPotentiallyReachable = sub_1CC8F6298(v20 + ((unint64_t)v19 << 6) + 8, a2, (uint64_t)a1, (uint64_t)v41, v42, a4);
    if (v41 != v43) {
      free(v41);
    }
  }
  return isPotentiallyReachable;
}

uint64_t sub_1CC8F5D70(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

void *sub_1CC8F5D78(uint64_t a1)
{
  return sub_1CC8F5020((void *)(a1 - 32));
}

void sub_1CC8F5D80(uint64_t a1)
{
  sub_1CC8F5020((void *)(a1 - 32));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F5DBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    uint64_t v10 = 8 * a5;
    uint64_t v11 = a4;
    while (!(*(unsigned int (**)(void))(**(void **)v11 + 120))())
    {
      v11 += 8;
      v10 -= 8;
      if (!v10) {
        goto LABEL_5;
      }
    }
    uint64_t v17 = *(unsigned __int8 *)(a1 + 48);
    *(unsigned char *)(a1 + 48) = 1;
  }
  else
  {
LABEL_5:
    uint64_t v12 = *(void *)(a1 + 24);
    uint64_t v13 = *(unsigned int *)(a1 + 40);
    unsigned int v14 = (void **)(v12 + 8 * v13);
    if (*(_DWORD *)(a1 + 32))
    {
      if (v13)
      {
        uint64_t v15 = 8 * v13;
        unint64_t v16 = *(void ***)(a1 + 24);
        while (((unint64_t)*v16 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          ++v16;
          v15 -= 8;
          if (!v15) {
            goto LABEL_10;
          }
        }
      }
      else
      {
        unint64_t v16 = *(void ***)(a1 + 24);
      }
    }
    else
    {
LABEL_10:
      unint64_t v16 = (void **)(v12 + 8 * v13);
    }
    unint64_t v18 = (void **)(v12 + 8 * v13);
    uint64_t v17 = 1;
    if (v16 != v18)
    {
      do
      {
        unsigned int v19 = v14;
        if (v16 + 1 != v14)
        {
          unsigned int v19 = v16 + 1;
          while ((*v19 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            if (++v19 == v14)
            {
              unsigned int v19 = v14;
              break;
            }
          }
        }
        uint64_t v20 = (uint64_t)*v16;
        if (sub_1CC8F5F2C(a2, a3, a4, a5, *v16))
        {
          sub_1CC8F617C(a1, v20);
          uint64_t v17 = 0;
        }
        unint64_t v16 = (void **)v19;
      }
      while (v19 != v18);
    }
  }
  return v17;
}

uint64_t sub_1CC8F5F2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  v26[8] = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v6 = a3;
    uint64_t v9 = 8 * a4;
    uint64_t v10 = a3;
    uint64_t v11 = a3 + 8 * a4;
    do
    {
      uint64_t v12 = (uint64_t *)(*(uint64_t (**)(void))(**(void **)v10 + 112))();
      uint64_t v23 = 0;
      uint64_t v24 = a5;
      if (sub_1CD420258(v12, &v24, &v23)) {
        return 1;
      }
      v10 += 8;
      v9 -= 8;
    }
    while (v9);
    uint64_t v24 = v26;
    uint64_t v25 = 0x800000000;
    while (2)
    {
      uint64_t v13 = (*(uint64_t (**)(void))(**(void **)v6 + 112))();
      unsigned int v14 = *(uint64_t **)(v13 + 24);
      uint64_t v15 = *(uint64_t **)(v13 + 32);
      while (v14 != v15)
      {
        uint64_t v16 = *(void *)(*v14 + 112);
        if (!v16 || (*(unsigned char *)(v16 + 14) & 0x20) == 0)
        {
          uint64_t v17 = sub_1CC8B3D70(a1, *v14, 0, a2, 2, 0, 1);
          if (v25 >= (unint64_t)HIDWORD(v25)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v24 + v25) = v17;
          LODWORD(v25) = v25 + 1;
          if ((*(uint64_t (**)(llvm::AbstractAttribute *, uint64_t, void *))(*(void *)v17 + 112))(v17, a1, a5))
          {
            uint64_t v21 = 1;
            goto LABEL_21;
          }
        }
        ++v14;
      }
      v6 += 8;
      if (v6 != v11) {
        continue;
      }
      break;
    }
    if (v25)
    {
      unint64_t v18 = (uint64_t *)v24;
      uint64_t v19 = 8 * v25;
      do
      {
        uint64_t v20 = *v18++;
        llvm::Attributor::recordDependence(a1, v20, a2, 0);
        v19 -= 8;
      }
      while (v19);
    }
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v24 = v26;
    uint64_t v25 = 0x800000000;
  }
LABEL_21:
  if (v24 != v26) {
    free(v24);
  }
  return v21;
}

int32x2_t sub_1CC8F617C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2;
  sub_1CD6521E0(a1, &v5, (uint64_t)v6);
  uint64_t v5 = a2;
  v6[0] = 0;
  if (sub_1CC020A5C((uint64_t *)(a1 + 24), &v5, v6))
  {
    *(void *)v6[0] = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 32), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 32) = result;
  }
  return result;
}

uint64_t sub_1CC8F61F4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[3];
  if (sub_1CC8B3254(*a1, a1[1], a1[2], a2))
  {
    uint64_t v5 = sub_1CC8C5FA0(a1[1], a2, 0, v4, 0);
    uint64_t v6 = a1[4];
    unsigned int v7 = *(_DWORD *)(v6 + 8);
    if (v7 >= *(_DWORD *)(v6 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v6 + 8 * v7) = v5;
    ++*(_DWORD *)(v6 + 8);
  }
  return 1;
}

uint64_t sub_1CC8F6298(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  if (*(unsigned char *)(a1 + 48)) {
    return 1;
  }
  uint64_t v13 = 0;
  v14[0] = (uint64_t)a6;
  if (sub_1CC020A5C((uint64_t *)a1, v14, &v13)) {
    return 1;
  }
  uint64_t v13 = 0;
  v14[0] = (uint64_t)a6;
  if (sub_1CC020A5C((uint64_t *)(a1 + 24), v14, &v13)) {
    return 0;
  }
  v14[0] = a3;
  sub_1CD64A1CC(a2 + 5184, v14);
  uint64_t v13 = a6;
  sub_1CD6521E0(a1 + 24, &v13, (uint64_t)v14);
  uint64_t result = sub_1CC8F5F2C(a2, a3, a4, a5, a6);
  if (result)
  {
    sub_1CC8F617C(a1, (uint64_t)a6);
    return 1;
  }
  return result;
}

void *sub_1CC8F6388(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F63CC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8F6430(unsigned char *a1, uint64_t a2)
{
  a1[41] = a1[41] & 3 | a1[40];
  uint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 40))(a1);
  sub_1CC8F6A00(v4, v5, 0);

  return sub_1CD65857C(a1, a2);
}

uint64_t sub_1CC8F64C0@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  int v2 = *(unsigned __int8 *)(result + 41);
  if ((~v2 & 3) == 0)
  {
    a2[23] = 8;
    uint64_t v3 = 0x656E6F6E64616572;
LABEL_7:
    *(void *)a2 = v3;
    a2[8] = 0;
    return result;
  }
  if ((v2 & 2) != 0)
  {
    a2[23] = 8;
    uint64_t v3 = 0x796C6E6F64616572;
    goto LABEL_7;
  }
  if (v2)
  {
    a2[23] = 9;
    strcpy(a2, "writeonly");
  }
  else
  {
    a2[23] = 14;
    strcpy(a2, "may-read/write");
  }
  return result;
}

uint64_t sub_1CC8F6564(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if ((~*(_DWORD *)(a1 + 16) & 3) == 0) {
    unint64_t v4 = *(void *)(v4 + 24);
  }
  if ((~*(unsigned __int8 *)(a1 + 41) & 3) == 0)
  {
    *(void *)(v4 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v4 + 112), **(uint64_t ***)v4, -1, 3);
    *(void *)(v4 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v4 + 112), **(uint64_t ***)v4, -1, 11);
    *(void *)(v4 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v4 + 112), **(uint64_t ***)v4, -1, 12);
  }

  return sub_1CC8F6880(a1, a2);
}

void sub_1CC8F6628(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 41);
  if ((~v1 & 3) != 0)
  {
    if ((v1 & 2) != 0)
    {
      if (atomic_load_explicit(byte_1EBCDDEB8, memory_order_acquire)) {
        return;
      }
      int v2 = (__guard *)byte_1EBCDDEB8;
    }
    else
    {
      if (v1 & 1) == 0 || (atomic_load_explicit(byte_1EBCDDEC0, memory_order_acquire)) {
        return;
      }
      int v2 = (__guard *)byte_1EBCDDEC0;
    }
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDEB0, memory_order_acquire)) {
      return;
    }
    int v2 = (__guard *)byte_1EBCDDEB0;
  }
  if (__cxa_guard_acquire(v2))
  {
    __cxa_guard_release(v2);
  }
}

BOOL sub_1CC8F66D8(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 41);
  v6[0] = a2;
  v6[1] = a1;
  if (llvm::Attributor::checkForAllReadWriteInstructions(a2, (unsigned int (*)(uint64_t, uint64_t))sub_1CC8F6D2C, (uint64_t)v6, a1, &v5))return v3 == *(unsigned __int8 *)(a1 + 41); {
  BOOL result = 0;
  }
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 40);
  return result;
}

unint64_t sub_1CC8F674C(unint64_t result, uint64_t *a2, uint64_t a3)
{
  int v4 = *(unsigned __int8 *)(result + 41);
  if ((~v4 & 3) != 0)
  {
    if ((v4 & 2) != 0)
    {
      char v5 = a2;
      unsigned int v6 = 45;
    }
    else
    {
      if ((v4 & 1) == 0) {
        return result;
      }
      char v5 = a2;
      unsigned int v6 = 66;
    }
  }
  else
  {
    char v5 = a2;
    unsigned int v6 = 44;
  }
  BOOL result = llvm::Attribute::get(v5, v6, 0);
  unsigned int v7 = *(_DWORD *)(a3 + 8);
  if (v7 >= *(_DWORD *)(a3 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a3 + 8 * v7) = result;
  ++*(_DWORD *)(a3 + 8);
  return result;
}

uint64_t *sub_1CC8F67F0(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F6818(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F6880(uint64_t a1, uint64_t a2)
{
  v14[4] = *MEMORY[0x1E4F143B8];
  int v4 = (llvm::IRPosition *)(a1 + 16);
  LODWORD(v12) = 44;
  uint64_t v5 = 1;
  if (!llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), (unsigned int *)&v12, 1, 1, 0))
  {
    uint64_t v12 = v14;
    uint64_t v13 = 0x400000000;
    unint64_t v6 = *(void *)v4 & 0xFFFFFFFFFFFFFFFCLL;
    if ((~*(_DWORD *)v4 & 3) == 0) {
      unint64_t v6 = *(void *)(v6 + 24);
    }
    (*(void (**)(uint64_t, void, void **))(*(void *)a1 + 112))(a1, **(void **)v6, &v12);
    if (v13)
    {
      unsigned int v7 = (uint64_t *)v12;
      uint64_t v8 = 8 * v13;
      while (1)
      {
        uint64_t v9 = *v7;
        if (*v7) {
          LODWORD(v9) = *(_DWORD *)(v9 + 12);
        }
        unsigned int v11 = v9;
        if (!llvm::IRPosition::hasAttr(v4, &v11, 1, 1, 0)) {
          break;
        }
        ++v7;
        v8 -= 8;
        if (!v8) {
          goto LABEL_10;
        }
      }
      sub_1CD658824(v4, dword_1CFB273AC, 3);
      uint64_t v5 = sub_1CD65FC24(a1, a2);
    }
    else
    {
LABEL_10:
      uint64_t v5 = 1;
    }
    if (v12 != v14) {
      free(v12);
    }
  }
  return v5;
}

void sub_1CC8F6A00(llvm::IRPosition *a1, uint64_t a2, char a3)
{
  v33[2] = *MEMORY[0x1E4F143B8];
  char v31 = v33;
  uint64_t v32 = 0x200000000;
  llvm::IRPosition::getAttrs(a1, (unsigned int *)dword_1CFB273AC, 3, (uint64_t)&v31, a3, 0);
  if (v32)
  {
    uint64_t v5 = (char *)v31;
    int v6 = *(unsigned __int8 *)(a2 + 9);
    uint64_t v7 = 8 * v32;
    int v8 = *(unsigned __int8 *)(a2 + 8);
    do
    {
      int v9 = *(_DWORD *)(*(void *)v5 + 12);
      if (v9 == 44)
      {
        int v10 = 3;
      }
      else if (v9 == 66)
      {
        int v10 = 1;
      }
      else
      {
        int v10 = 2;
      }
      v6 |= v10;
      *(unsigned char *)(a2 + 9) = v6;
      v8 |= v10;
      *(unsigned char *)(a2 + 8) = v8;
      v5 += 8;
      v7 -= 8;
    }
    while (v7);
  }
  int v11 = ~*(_DWORD *)a1;
  unint64_t v12 = *(void *)a1 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v11 & 3) == 0) {
    unint64_t v12 = *(void *)(v12 + 24);
  }
  unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
  if (v12) {
    BOOL v14 = v13 >= 0x1C;
  }
  else {
    BOOL v14 = 0;
  }
  if (!v14) {
    goto LABEL_27;
  }
  uint64_t v15 = v13 - 33;
  if (v15 > 0x37) {
    goto LABEL_20;
  }
  if (((1 << (v13 - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v17 = *(void *)(v12 + 64);
    if (!v17 || (*(unsigned char *)(v17 + 20) & 4) == 0 && (*(unsigned char *)(v17 + 17) & 0x10) == 0)
    {
      __int32 v30 = 7;
      if (sub_1CC5CB59C(v12, &v30, 1uLL))
      {
        uint64_t v20 = *(void *)(v12 - 32);
        if (!v20
          || *(unsigned char *)(v20 + 16)
          || *(void *)(v20 + 24) != *(void *)(v12 + 72)
          || *(_DWORD *)(v20 + 36) != 7)
        {
          goto LABEL_21;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v12, 66) & 1) == 0
        && !llvm::CallBase::hasFnAttrOnCalledFunction(v12, 44))
      {
        goto LABEL_21;
      }
    }
    goto LABEL_20;
  }
  if (((1 << (v13 - 33)) & 0x808001C8000010) != 0) {
    goto LABEL_22;
  }
  if (v15 != 28 || (*(_WORD *)(v12 + 18) & 0x301) == 0)
  {
LABEL_20:
    *(unsigned char *)(a2 + 9) |= 1u;
    *(unsigned char *)(a2 + 8) |= 1u;
  }
LABEL_21:
  unsigned int v13 = *(unsigned __int8 *)(v12 + 16);
LABEL_22:
  uint64_t v16 = v13 - 33;
  if (v16 > 0x37) {
    goto LABEL_26;
  }
  if (((1 << v16) & 0x8000000000041) == 0)
  {
    if (v16 == 27)
    {
      if ((*(_WORD *)(v12 + 18) & 0x301) != 0) {
        goto LABEL_27;
      }
    }
    else if (((1 << v16) & 0x808001D0000010) != 0)
    {
      goto LABEL_27;
    }
LABEL_26:
    *(unsigned char *)(a2 + 9) |= 2u;
    *(unsigned char *)(a2 + 8) |= 2u;
    goto LABEL_27;
  }
  uint64_t v18 = *(void *)(v12 + 64);
  if (v18 && (*(unsigned char *)(v18 + 17) & 0x30) != 0) {
    goto LABEL_26;
  }
  int v19 = *(_DWORD *)(v12 + 20);
  if ((v19 & 0x80000000) == 0
    || (unint64_t v21 = v12 - 32 * (v19 & 0x7FFFFFF), v24 = *(void *)(v21 - 8), v22 = v21 - 8, (v23 = v24) == 0))
  {
LABEL_40:
    if ((llvm::CallBase::hasFnAttrOnCalledFunction(v12, 45) & 1) == 0
      && !llvm::CallBase::hasFnAttrOnCalledFunction(v12, 44))
    {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  uint64_t v25 = -v23;
  while (1)
  {
    unsigned int v26 = *(_DWORD *)(*(void *)(v22 + v25) + 8);
    BOOL v27 = v26 > 7;
    int v28 = (1 << v26) & 0x83;
    if (v27 || v28 == 0) {
      break;
    }
    v25 += 16;
    if (!v25) {
      goto LABEL_40;
    }
  }
LABEL_27:
  if (v31 != v33) {
    free(v31);
  }
}

BOOL sub_1CC8F6D2C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = *(unsigned __int8 *)(a2 + 16) - 33;
  if (v3 > 0x37) {
    goto LABEL_7;
  }
  if (((1 << (*(unsigned char *)(a2 + 16) - 33)) & 0x8000000000041) == 0)
  {
    if (((1 << (*(unsigned char *)(a2 + 16) - 33)) & 0x808001C8000010) != 0) {
      goto LABEL_11;
    }
    if (v3 != 28)
    {
LABEL_7:
      unsigned int v7 = *(unsigned __int8 *)(v2 + 41);
LABEL_8:
      int v6 = *(unsigned __int8 *)(v2 + 40);
      return v7 != v6;
    }
    if ((*(_WORD *)(a2 + 18) & 0x301) != 0)
    {
LABEL_11:
      int v9 = *(unsigned __int8 *)(v2 + 40);
      unsigned int v7 = *(unsigned char *)(v2 + 41) & 0xFE | v9;
      *(unsigned char *)(v2 + 41) = *(unsigned char *)(v2 + 41) & 0xFE | v9;
      if (((1 << v3) & 0x8000000000041) != 0)
      {
        uint64_t v10 = *(void *)(a2 + 64);
        if (v10 && (*(unsigned char *)(v10 + 17) & 0x30) != 0) {
          goto LABEL_7;
        }
        int v11 = *(_DWORD *)(a2 + 20);
        if ((v11 & 0x80000000) == 0
          || (v13 = a2 - 32 * (v11 & 0x7FFFFFF), v16 = *(void *)(v13 - 8), uint64_t v14 = v13 - 8, (v15 = v16) == 0))
        {
LABEL_19:
          if (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 45)) {
            goto LABEL_7;
          }
          int hasFnAttrOnCalledFunction = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 44);
          unsigned int v7 = *(unsigned __int8 *)(v2 + 41);
          if (hasFnAttrOnCalledFunction) {
            goto LABEL_8;
          }
          goto LABEL_31;
        }
        uint64_t v17 = -v15;
        while (1)
        {
          unsigned int v18 = *(_DWORD *)(*(void *)(v14 + v17) + 8);
          BOOL v19 = v18 > 7;
          int v20 = (1 << v18) & 0x83;
          if (v19 || v20 == 0) {
            break;
          }
          v17 += 16;
          if (!v17) {
            goto LABEL_19;
          }
        }
      }
      else if (((1 << v3) & 0x808001D0000010) == 0)
      {
        if (v3 != 27) {
          goto LABEL_7;
        }
        if ((*(_WORD *)(a2 + 18) & 0x301) == 0) {
          goto LABEL_8;
        }
LABEL_31:
        int v6 = *(unsigned __int8 *)(v2 + 40);
        unsigned int v7 = v6 | v7 & 0xFFFFFFFD;
        goto LABEL_4;
      }
    }
    unsigned int v7 = *(unsigned __int8 *)(v2 + 41);
    goto LABEL_31;
  }
  uint64_t v5 = sub_1CC8B2D1C(*a1, a2, 0, v2, 0, 0, 1);
  int v6 = *(unsigned __int8 *)(v2 + 40);
  unsigned int v7 = (*(unsigned char *)(v2 + 41) & *((unsigned char *)v5 + 41)) | v6;
LABEL_4:
  *(unsigned char *)(v2 + 41) = v7;
  return v7 != v6;
}

void *sub_1CC8F6F08(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F6F4C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8F6FB0(unsigned char *a1, uint64_t a2)
{
  a1[41] = a1[41] & 3 | a1[40];
  int v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 40))(a1);
  sub_1CC8F6A00(v4, v5, 0);
  sub_1CD65857C(a1, a2);
  unint64_t result = sub_1CD648A0C(v4);
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      a1[41] = a1[40];
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

void sub_1CC8F7080(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 41);
  if ((~v1 & 3) != 0)
  {
    if ((v1 & 2) != 0)
    {
      if (atomic_load_explicit(byte_1EBCDDED0, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDED0;
    }
    else
    {
      if (v1 & 1) == 0 || (atomic_load_explicit(byte_1EBCDDED8, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDED8;
    }
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDEC8, memory_order_acquire)) {
      return;
    }
    uint64_t v2 = (__guard *)byte_1EBCDDEC8;
  }
  if (__cxa_guard_acquire(v2))
  {
    __cxa_guard_release(v2);
  }
}

BOOL sub_1CC8F7130(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t v4 = sub_1CD648A0C((llvm::IRPosition *)(a1 + 16));
  uint64_t v5 = sub_1CC8B2D1C(a2, v4, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned __int8 *)(v3 + 9);
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 == *(unsigned __int8 *)(v3 + 9);
}

uint64_t *sub_1CC8F71DC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F7204(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8F726C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F72B0(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8F7314(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 41);
  if ((~v1 & 3) != 0)
  {
    if ((v1 & 2) != 0)
    {
      if (atomic_load_explicit(byte_1EBCDDEE8, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDEE8;
    }
    else
    {
      if (v1 & 1) == 0 || (atomic_load_explicit(byte_1EBCDDEF0, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDEF0;
    }
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDEE0, memory_order_acquire)) {
      return;
    }
    uint64_t v2 = (__guard *)byte_1EBCDDEE0;
  }
  if (__cxa_guard_acquire(v2))
  {
    __cxa_guard_release(v2);
  }
}

uint64_t sub_1CC8F73C4(const llvm::AbstractAttribute *a1, llvm::Attributor *a2)
{
  unint64_t v4 = (const llvm::AbstractAttribute *)((char *)a1 + 16);
  unint64_t v5 = sub_1CD659BC0((const llvm::AbstractAttribute *)((char *)a1 + 16));
  uint64_t v7 = v6;
  uint64_t v8 = (*(uint64_t (**)(const llvm::AbstractAttribute *))(*(void *)a1 + 40))(a1);
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument(v4);
  if (AssociatedArgument
    && *(unsigned char *)(*(void *)AssociatedArgument + 8) == 15
    && (uint64_t v10 = *(void *)(*(void *)(AssociatedArgument + 24) + 112)) != 0
    && (unsigned int v11 = *(_DWORD *)(AssociatedArgument + 32) + 2, v11 < *(_DWORD *)(v10 + 8))
    && (uint64_t v19 = *(void *)(v10 + 8 * v11 + 40)) != 0
    && (*(unsigned char *)(v19 + 20) & 0x20) != 0)
  {
    char v14 = 0;
    int v16 = *(unsigned __int8 *)(v8 + 9);
  }
  else
  {
    uint64_t v12 = 1;
    uint64_t v13 = sub_1CC8B2D1C((uint64_t)a2, v5, v7, (uint64_t)a1, 1, 0, 1);
    char v14 = *((unsigned char *)v13 + 41);
    char v15 = *((unsigned char *)v13 + 40);
    int v16 = (*(unsigned char *)(v8 + 9) | v15);
    *(unsigned char *)(v8 + 9) |= v15;
    *(unsigned char *)(v8 + 8) |= v15;
    if ((v16 & ~*((unsigned __int8 *)v13 + 41)) == 0) {
      return v12;
    }
  }
  if ((~*((unsigned __int16 *)sub_1CC8BB6D4((uint64_t)a2, *((void *)a1 + 2), *((void *)a1 + 3), (uint64_t)a1, 1, 0, 1)+ 21) & 3) != 0)
  {
    *(unsigned char *)(v8 + 9) = *(unsigned char *)(v8 + 9) & v14 | *(unsigned char *)(v8 + 8);
  }
  else
  {
    v21[0] = a1;
    v21[1] = a2;
    unint64_t v18 = sub_1CD6482F0(v4);
    if ((llvm::Attributor::checkForAllUses(a2, (unsigned int (*)(uint64_t, uint64_t *, uint64_t *))sub_1CC8F764C, (uint64_t)v21, a1, v18, 0, 1, 1, 0, v20) & 1) == 0)return (*(uint64_t (**)(void *))(*((void *)a1 + 4) + 40))((void *)a1 + 4); {
  }
    }
  return v16 == *((unsigned __int8 *)a1 + 41);
}

uint64_t *sub_1CC8F75BC(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F75E4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F764C(uint64_t *a1, void *a2, BOOL *a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = a2[3];
  if (sub_1CBF698E4(v7) || sub_1CC27D470(v7)) {
    return 1;
  }
  unsigned int v9 = *(unsigned __int8 *)(v7 + 16);
  BOOL v10 = 1;
  if (v9 <= 0x3B)
  {
    if (v9 != 33 && v9 != 39) {
      goto LABEL_23;
    }
    goto LABEL_12;
  }
  if (v9 == 84)
  {
LABEL_12:
    int v12 = *(_DWORD *)(v7 + 20);
    unint64_t v13 = v7 - 32 * (v12 & 0x7FFFFFF);
    if (v13 <= (unint64_t)a2
      && (v9 != 84 ? (v9 != 39 ? (uint64_t v14 = 2) : (uint64_t v14 = (*(_DWORD *)(v7 + 80) + 1))) : (uint64_t v14 = 0),
          (v12 & 0x80000000) == 0 || (uint64_t v31 = *(void *)(v13 - 8), (v31 & 0xFFFFFFFF0) == 0)
        ? (uint64_t v15 = 0)
        : (uint64_t v15 = (*(_DWORD *)(v13 - 12) - *(_DWORD *)(v13 - v31))),
          v7 - 32 * v14 - 32 * v15 - 32 > (unint64_t)a2 && *(unsigned char *)(*(void *)*a2 + 8) == 15))
    {
      unint64_t v16 = (unint64_t)a2 - v13;
      if ((v12 & 0x40000000) != 0) {
        unint64_t v13 = *(void *)(v7 - 8);
      }
      BOOL v10 = (~*((unsigned __int16 *)sub_1CC8BB6D4(a1[1], (v13 + (v16 & 0x1FFFFFFFE0)) | 3, 0, v6, 1, 0, 1) + 21) & 7) != 0;
      unsigned int v9 = *(unsigned __int8 *)(v7 + 16);
    }
    else
    {
      BOOL v10 = 1;
    }
    goto LABEL_23;
  }
  if (v9 == 60)
  {
    *a3 = 0;
    goto LABEL_11;
  }
LABEL_23:
  *a3 = v10;
  uint64_t v17 = v9 - 33;
  if (v17 <= 0x37)
  {
    if (((1 << v17) & 0x8000000000041) != 0)
    {
      uint64_t v18 = *(void *)(v7 + 64);
      if (!v18 || (*(unsigned char *)(v18 + 20) & 4) == 0 && (*(unsigned char *)(v18 + 17) & 0x10) == 0)
      {
        __int32 v54 = 7;
        if (sub_1CC5CB59C(v7, &v54, 1uLL))
        {
          uint64_t v32 = *(void *)(v7 - 32);
          if (!v32
            || *(unsigned char *)(v32 + 16)
            || *(void *)(v32 + 24) != *(void *)(v7 + 72)
            || *(_DWORD *)(v32 + 36) != 7)
          {
            goto LABEL_48;
          }
        }
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v7, 66) & 1) == 0
          && !llvm::CallBase::hasFnAttrOnCalledFunction(v7, 44))
        {
          goto LABEL_48;
        }
      }
    }
    else if (v17 == 28)
    {
      if ((*(_WORD *)(v7 + 18) & 0x301) != 0)
      {
LABEL_48:
        int v19 = *(unsigned __int8 *)(v7 + 16);
        goto LABEL_49;
      }
    }
    else if (((1 << v17) & 0x808001C8000010) != 0)
    {
      goto LABEL_48;
    }
  }
  int v19 = *(unsigned __int8 *)(v7 + 16);
  uint64_t v20 = (v19 - 33);
  if (v20 > 0x37) {
    return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
  }
  if (((1 << (v19 - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v21 = *(void *)(v7 + 64);
    if (v21 && (*(unsigned char *)(v21 + 17) & 0x30) != 0) {
      return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
    }
    int v22 = *(_DWORD *)(v7 + 20);
    if (v22 < 0 && (uint64_t v36 = v7 - 32 * (v22 & 0x7FFFFFF), v39 = *(void *)(v36 - 8), v37 = v36 - 8, (v38 = v39) != 0))
    {
      uint64_t v40 = -v38;
      while (1)
      {
        unsigned int v41 = *(_DWORD *)(*(void *)(v37 + v40) + 8);
        BOOL v42 = v41 > 7;
        int v43 = (1 << v41) & 0x83;
        if (v42 || v43 == 0) {
          break;
        }
        v40 += 16;
        if (!v40) {
          goto LABEL_42;
        }
      }
    }
    else
    {
LABEL_42:
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v7, 45) & 1) != 0
        || (llvm::CallBase::hasFnAttrOnCalledFunction(v7, 44) & 1) != 0)
      {
        return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
      }
    }
    goto LABEL_48;
  }
  if (v20 == 27)
  {
    if ((*(_WORD *)(v7 + 18) & 0x301) == 0) {
      return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
    }
    goto LABEL_48;
  }
  if (((1 << (v19 - 33)) & 0x808001D0000010) == 0) {
    return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
  }
LABEL_49:
  if (v19 <= 59)
  {
    if (v19 != 33 && v19 != 39)
    {
      if (v19 != 37) {
        goto LABEL_82;
      }
      goto LABEL_81;
    }
    goto LABEL_57;
  }
  if ((v19 - 61) > 0x1B) {
    goto LABEL_73;
  }
  if (v19 == 61)
  {
    if (*(void *)(v7 - 32) == *a2) {
      goto LABEL_94;
    }
LABEL_71:
    (*(void (**)(void))(*(void *)(v6 + 32) + 40))();
    return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
  }
  if (v19 != 84)
  {
    if (((1 << (v19 - 61)) & 0x808001C) != 0) {
      goto LABEL_81;
    }
LABEL_73:
    if (v19 != 60) {
      goto LABEL_82;
    }
LABEL_11:
    char v11 = *(unsigned char *)(v6 + 41) & 0xFE;
LABEL_95:
    *(unsigned char *)(v6 + 41) = v11 | *(unsigned char *)(v6 + 40);
    return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
  }
LABEL_57:
  int v23 = *(_DWORD *)(v7 + 20);
  if (v23 < 0)
  {
    uint64_t v33 = v7 - 32 * (v23 & 0x7FFFFFF);
    uint64_t v34 = *(void *)(v33 - 8);
    if ((v34 & 0xFFFFFFFF0) != 0)
    {
      unint64_t v35 = ((unint64_t)a2 - v33) >> 5;
      if (*(_DWORD *)(v33 - v34) <= v35 && *(_DWORD *)(v33 - 12) > v35) {
        goto LABEL_71;
      }
    }
  }
  if ((void *)(v7 - 32) != a2)
  {
    if (*(unsigned char *)(*(void *)*a2 + 8) == 15)
    {
      uint64_t v24 = v7 - 32 * (v23 & 0x7FFFFFF);
      unint64_t v25 = (unint64_t)a2 - v24;
      if ((v23 & 0x40000000) != 0) {
        uint64_t v24 = *(void *)(v7 - 8);
      }
      uint64_t v7 = (v24 + (v25 & 0x1FFFFFFFE0)) | 3;
    }
    char v11 = *(unsigned char *)(v6 + 41) & *((unsigned char *)sub_1CC8B2D1C(a1[1], v7, 0, v6, 1, 0, 1) + 41);
    goto LABEL_95;
  }
  *(unsigned char *)(v6 + 41) = *(unsigned char *)(v6 + 41) & 0xFE | *(unsigned char *)(v6 + 40);
  uint64_t v26 = (v19 - 33);
  if (v26 <= 0x33)
  {
    if (((1 << v26) & 0x8000000000041) == 0)
    {
      if (((1 << v26) & 0x8001C8000010) == 0 && (v26 != 28 || (*(_WORD *)(v7 + 18) & 0x301) == 0)) {
        goto LABEL_82;
      }
LABEL_81:
      *(unsigned char *)(v6 + 41) = *(unsigned char *)(v6 + 41) & 0xFE | *(unsigned char *)(v6 + 40);
      goto LABEL_82;
    }
    uint64_t v27 = *(void *)(v7 + 64);
    if (!v27 || (*(unsigned char *)(v27 + 20) & 4) == 0 && (*(unsigned char *)(v27 + 17) & 0x10) == 0)
    {
      __int32 v55 = 7;
      if (sub_1CC5CB59C(v7, &v55, 1uLL))
      {
        uint64_t v53 = *a2;
        if (!*a2 || *(unsigned char *)(v53 + 16) || *(void *)(v53 + 24) != *(void *)(v7 + 72) || *(_DWORD *)(v53 + 36) != 7) {
          goto LABEL_81;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v7, 66) & 1) == 0
        && (llvm::CallBase::hasFnAttrOnCalledFunction(v7, 44) & 1) == 0)
      {
        goto LABEL_81;
      }
    }
  }
LABEL_82:
  uint64_t v28 = *(unsigned __int8 *)(v7 + 16) - 33;
  if (v28 > 0x37) {
    return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
  }
  if (((1 << (*(unsigned char *)(v7 + 16) - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v29 = *(void *)(v7 + 64);
    if (v29 && (*(unsigned char *)(v29 + 17) & 0x30) != 0) {
      return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
    }
    int v30 = *(_DWORD *)(v7 + 20);
    if (v30 < 0 && (uint64_t v45 = v7 - 32 * (v30 & 0x7FFFFFF), v48 = *(void *)(v45 - 8), v46 = v45 - 8, (v47 = v48) != 0))
    {
      uint64_t v49 = -v47;
      while (1)
      {
        unsigned int v50 = *(_DWORD *)(*(void *)(v46 + v49) + 8);
        BOOL v42 = v50 > 7;
        int v51 = (1 << v50) & 0x83;
        if (v42 || v51 == 0) {
          break;
        }
        v49 += 16;
        if (!v49) {
          goto LABEL_90;
        }
      }
    }
    else
    {
LABEL_90:
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(v7, 45) & 1) != 0
        || (llvm::CallBase::hasFnAttrOnCalledFunction(v7, 44) & 1) != 0)
      {
        return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
      }
    }
    goto LABEL_94;
  }
  if (v28 == 27)
  {
    if ((*(_WORD *)(v7 + 18) & 0x301) == 0) {
      return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
    }
LABEL_94:
    char v11 = *(unsigned char *)(v6 + 41) & 0xFD;
    goto LABEL_95;
  }
  if (((1 << (*(unsigned char *)(v7 + 16) - 33)) & 0x808001D0000010) != 0) {
    goto LABEL_94;
  }
  return (*(unsigned int (**)(uint64_t))(*(void *)(v6 + 32) + 24))(v6 + 32) ^ 1;
}

void *sub_1CC8F7D2C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F7D70(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F7DD4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 41) = *(unsigned char *)(a1 + 41) & 3 | *(unsigned char *)(a1 + 40);
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  unsigned int v9 = 69;
  char hasAttr = llvm::IRPosition::hasAttr((llvm::IRPosition *)(a1 + 16), &v9, 1, 1, 0);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  sub_1CC8F6A00(v4, v6, hasAttr);
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument(v4);
  if (!AssociatedArgument) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 40))();
  }
  uint64_t result = sub_1CD64EF44(a2, *(llvm::GlobalValue **)(AssociatedArgument + 24));
  if ((result & 1) == 0) {
    return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 40))();
  }
  return result;
}

uint64_t sub_1CC8F7EC4(unsigned char *a1, uint64_t a2)
{
  v7[1] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  if (*(unsigned char *)(*(void *)sub_1CD6482F0((llvm::IRPosition *)(a1 + 16)) + 8) != 15) {
    return 1;
  }
  v7[0] = 0x4800000047;
  if (llvm::IRPosition::hasAttr(v4, (unsigned int *)v7, 2, 0, 0))
  {
    char v6 = a1[40];
    a1[40] = v6 & 0xFD;
    a1[41] = (a1[41] | v6) & 0xFD;
  }
  return sub_1CC8F6880((uint64_t)a1, a2);
}

void sub_1CC8F7F98(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 41);
  if ((~v1 & 3) != 0)
  {
    if ((v1 & 2) != 0)
    {
      if (atomic_load_explicit(byte_1EBCDDF00, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDF00;
    }
    else
    {
      if (v1 & 1) == 0 || (atomic_load_explicit(byte_1EBCDDF08, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDF08;
    }
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDEF8, memory_order_acquire)) {
      return;
    }
    uint64_t v2 = (__guard *)byte_1EBCDDEF8;
  }
  if (__cxa_guard_acquire(v2))
  {
    __cxa_guard_release(v2);
  }
}

uint64_t *sub_1CC8F8048(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F8070(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8F80D8(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F811C(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8F8180(unsigned char *a1, uint64_t a2)
{
  a1[41] = a1[41] & 3 | a1[40];
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  uint64_t v5 = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 40))(a1);
  sub_1CC8F6A00(v4, v5, 0);
  sub_1CD65857C(a1, a2);
  unint64_t result = sub_1CD648A0C(v4);
  if (!result) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(result + 16))
  {
    if (*(unsigned char *)(result + 16) == 3 && (*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_8:
    }
      a1[41] = a1[40];
  }
  else if (*(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_8;
  }
  return result;
}

uint64_t sub_1CC8F8250()
{
  return 1;
}

uint64_t *sub_1CC8F825C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F8284(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC8F82EC(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);
  return a1;
}

void sub_1CC8F8330(void *a1)
{
  *a1 = &unk_1F2620AA0;
  sub_1CD64E248(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CC8F8394(unsigned char *a1, uint64_t a2)
{
  unint64_t v4 = (llvm::IRPosition *)(a1 + 16);
  unint64_t result = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  if (!result) {
    goto LABEL_2;
  }
  if (*(unsigned char *)(*(void *)result + 8) == 15)
  {
    uint64_t v6 = *(void *)(*(void *)(result + 24) + 112);
    if (v6)
    {
      unsigned int v7 = *(_DWORD *)(result + 32) + 2;
      if (v7 < *(_DWORD *)(v6 + 8))
      {
        uint64_t v8 = *(void *)(v6 + 8 * v7 + 40);
        if (v8)
        {
          if ((*(unsigned char *)(v8 + 20) & 0x20) != 0)
          {
            char v9 = a1[41];
            char v10 = a1[40];
            a1[40] = v10 & 0xFC | 2;
            a1[41] = (v10 | v9) & 0xFC | 2;
          }
        }
      }
    }
  }
  sub_1CC8F7DD4((uint64_t)a1, a2);
  unint64_t result = sub_1CD648A0C(v4);
  if (result && *(unsigned char *)(result + 16) == 3)
  {
    if ((*(_DWORD *)(result + 20) & 0x7FFFFFF) == 0) {
LABEL_2:
    }
      a1[41] = a1[40];
  }
  else if (!*(unsigned char *)(result + 16) && *(void *)(result + 72) == result + 72 && (*(unsigned char *)(result + 34) & 0x80) == 0)
  {
    goto LABEL_2;
  }
  return result;
}

void sub_1CC8F8498(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 41);
  if ((~v1 & 3) != 0)
  {
    if ((v1 & 2) != 0)
    {
      if (atomic_load_explicit(byte_1EBCDDF18, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDF18;
    }
    else
    {
      if (v1 & 1) == 0 || (atomic_load_explicit(byte_1EBCDDF20, memory_order_acquire)) {
        return;
      }
      uint64_t v2 = (__guard *)byte_1EBCDDF20;
    }
  }
  else
  {
    if (atomic_load_explicit(byte_1EBCDDF10, memory_order_acquire)) {
      return;
    }
    uint64_t v2 = (__guard *)byte_1EBCDDF10;
  }
  if (__cxa_guard_acquire(v2))
  {
    __cxa_guard_release(v2);
  }
}

BOOL sub_1CC8F8548(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  unint64_t AssociatedArgument = llvm::IRPosition::getAssociatedArgument((llvm::IRPosition *)(a1 + 16));
  uint64_t v5 = sub_1CC8B2D1C(a2, AssociatedArgument, 0, v3, 0, 0, 1);
  uint64_t v6 = (*(uint64_t (**)(llvm::AbstractAttribute *))(*(void *)v5 + 48))(v5);
  uint64_t v7 = *(void *)(v3 + 32);
  v3 += 32;
  LODWORD(a2) = *(unsigned __int8 *)(v3 + 9);
  (*(void (**)(uint64_t, void))(v7 + 48))(v3, *(unsigned __int8 *)(v6 + 9));
  return a2 == *(unsigned __int8 *)(v3 + 9);
}

uint64_t *sub_1CC8F85F4(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  return sub_1CD64E248((uint64_t *)(a1 - 24));
}

void sub_1CC8F861C(uint64_t a1)
{
  *(void *)(a1 - 32) = &unk_1F2620AA0;
  sub_1CD64E248((uint64_t *)(a1 - 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F8684(void *a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  uint64_t v14 = &v16;
  uint64_t v15 = 0;
  if (!*((_DWORD *)a2 + 4))
  {
    unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
    goto LABEL_3;
  }
  sub_1CD41B598((uint64_t)&v14, (uint64_t)(a2 + 1));
  unsigned int v3 = *(_DWORD *)(*(void *)*a1 + 32);
  if (!v15)
  {
LABEL_3:
    uint64_t v4 = v13;
    unsigned int v5 = *(unsigned __int8 *)(*(void *)(v13 - 32) + 16);
    if (v5 < 0x15 || v5 == 24) {
      goto LABEL_9;
    }
  }
  unsigned int v3 = *((_DWORD *)v14 + v3 + 1);
  if ((v3 & 0x80000000) != 0)
  {
LABEL_12:
    uint64_t v11 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = v13;
LABEL_9:
  uint64_t v7 = *(void *)(v4 - 32 * (*(_DWORD *)(v4 + 20) & 0x7FFFFFF) + 32 * v3);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = a1[1];
  unsigned int v9 = *(_DWORD *)(v8 + 8);
  if (v9 >= *(_DWORD *)(v8 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  char v10 = (void *)(*(void *)v8 + 16 * v9);
  *char v10 = v7;
  v10[1] = v4;
  ++*(_DWORD *)(v8 + 8);
  uint64_t v11 = 1;
LABEL_13:
  if (v14 != &v16) {
    free(v14);
  }
  return v11;
}

void sub_1CC8F87A8(uint64_t a1, unint64_t a2)
{
  char v66 = 0;
  LOBYTE(v65[0]) = 0;
  uint64_t v4 = *(llvm::raw_ostream **)a1;
  uint64_t v5 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v5) > 4)
  {
    *(unsigned char *)(v5 + 4) = 101;
    *(_DWORD *)uint64_t v5 = 1685016073;
    *((void *)v4 + 4) += 5;
  }
  else
  {
    llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "\tNode", 5uLL);
  }
  llvm::write_hex(v4, a2, 3, 0, 0);
  uint64_t v6 = (void *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 7uLL)
  {
    *uint64_t v6 = 0x3D65706168735B20;
    *((void *)v4 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v4, " [shape=", 8uLL);
  }
  uint64_t v7 = *(llvm::raw_ostream **)a1;
  uint64_t v8 = *(void *)(*(void *)a1 + 32);
  unint64_t v9 = *(void *)(*(void *)a1 + 24) - v8;
  if (*(unsigned char *)(a1 + 16))
  {
    if (v9 <= 4)
    {
      char v10 = "none,";
      size_t v11 = 5;
      goto LABEL_10;
    }
    *(unsigned char *)(v8 + 4) = 44;
    *(_DWORD *)uint64_t v8 = 1701736302;
    uint64_t v56 = *((void *)v7 + 4) + 5;
  }
  else
  {
    if (v9 <= 6)
    {
      char v10 = "record,";
      size_t v11 = 7;
LABEL_10:
      llvm::raw_ostream::write(v7, v10, v11);
      goto LABEL_11;
    }
    *(_DWORD *)(v8 + 3) = 744780399;
    *(_DWORD *)uint64_t v8 = 1868785010;
    uint64_t v56 = *((void *)v7 + 4) + 7;
  }
  *((void *)v7 + 4) = v56;
LABEL_11:
  if (v66 >= 0) {
    size_t v12 = v66 & 0x7F;
  }
  else {
    size_t v12 = (size_t)v65[1];
  }
  if (v12)
  {
    if (v66 >= 0) {
      uint64_t v13 = (const char *)v65;
    }
    else {
      uint64_t v13 = (const char *)v65[0];
    }
    uint64_t v14 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v13, v12);
    uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
    if (*((unsigned char **)v14 + 3) == v15)
    {
      llvm::raw_ostream::write(v14, ",", 1uLL);
    }
    else
    {
      unsigned char *v15 = 44;
      ++*((void *)v14 + 4);
    }
  }
  uint64_t v16 = *(llvm::raw_ostream **)a1;
  uint64_t v17 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v17) > 5)
  {
    *(_WORD *)(v17 + 4) = 15724;
    *(_DWORD *)uint64_t v17 = 1700946284;
    *((void *)v16 + 4) += 6;
  }
  else
  {
    llvm::raw_ostream::write(v16, "label=", 6uLL);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v21 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 16))(a2);
    uint64_t v22 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 24))(a2);
    if (v21 == v22)
    {
      unsigned int v23 = 0;
      BOOL v24 = 0;
    }
    else
    {
      int v25 = 0;
      uint64_t v26 = v21 + 8;
      do
      {
        unsigned int v23 = v25 + 1;
        BOOL v24 = v26 != v22;
        if (v26 == v22) {
          break;
        }
        v26 += 8;
        BOOL v27 = v25++ == 63;
      }
      while (!v27);
    }
    if (v23 <= 1) {
      int v28 = 1;
    }
    else {
      int v28 = v23;
    }
    uint64_t v29 = *(llvm::raw_ostream **)a1;
    int v30 = *(void **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v30 > 0x30uLL)
    {
      qmemcpy(v30, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 49);
      uint64_t v31 = (void *)(*((void *)v29 + 4) + 49);
      *((void *)v29 + 4) = v31;
    }
    else
    {
      llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, "<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"", 0x31uLL);
      uint64_t v31 = (void *)*((void *)v29 + 4);
    }
    unint64_t v32 = (v28 + v24);
    if (*((void *)v29 + 3) - (void)v31 > 0x2EuLL)
    {
      qmemcpy(v31, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 47);
      *((void *)v29 + 4) += 47;
    }
    else
    {
      llvm::raw_ostream::write(v29, " cellpadding=\"0\"><tr><td align=\"text\" colspan=\"", 0x2FuLL);
    }
    sub_1CD098D14(v29, v32, 0, 0, 0);
    uint64_t v33 = (_WORD *)*((void *)v29 + 4);
    if (*((void *)v29 + 3) - (void)v33 <= 1uLL)
    {
      uint64_t v20 = "\">";
      uint64_t v18 = v29;
      goto LABEL_40;
    }
    *uint64_t v33 = 15906;
    *((void *)v29 + 4) += 2;
  }
  else
  {
    uint64_t v18 = *(llvm::raw_ostream **)a1;
    int v19 = *(_WORD **)(*(void *)a1 + 32);
    if (*(void *)(*(void *)a1 + 24) - (void)v19 <= 1uLL)
    {
      uint64_t v20 = "\"{";
LABEL_40:
      llvm::raw_ostream::write(v18, v20, 2uLL);
      goto LABEL_41;
    }
    *int v19 = 31522;
    *((void *)v18 + 4) += 2;
  }
LABEL_41:
  uint64_t v34 = *(llvm::raw_ostream **)a1;
  if (*(unsigned char *)(a1 + 16))
  {
    sub_1CD660200(&__p, a2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(v34, (const char *)p_p, size);
    uint64_t v40 = *((void *)v34 + 4);
    if ((unint64_t)(*((void *)v34 + 3) - v40) > 4)
    {
      *(unsigned char *)(v40 + 4) = 62;
      *(_DWORD *)uint64_t v40 = 1685335868;
      *((void *)v34 + 4) += 5;
    }
    else
    {
      llvm::raw_ostream::write(v34, "</td>", 5uLL);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v37 = (void *)__p.__r_.__value_.__r.__words[0];
      goto LABEL_62;
    }
  }
  else
  {
    sub_1CD660200(&v64, a2);
    llvm::DOT::EscapeString((char *)&v64, (uint64_t)&__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v35 = &__p;
    }
    else {
      unint64_t v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v36 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v36 = __p.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(v34, (const char *)v35, v36);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v37 = (void *)v64.__r_.__value_.__r.__words[0];
LABEL_62:
      operator delete(v37);
    }
  }
  memset(&v64, 0, sizeof(v64));
  LODWORD(__p.__r_.__value_.__r.__words[1]) = 0;
  char v60 = 0;
  uint64_t v61 = 0;
  unsigned int v63 = &v64;
  int v62 = 0;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
  __p.__r_.__value_.__r.__words[2] = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  sub_1CD660270(a1, (llvm::raw_ostream *)&__p, a2);
  unsigned int v41 = *(llvm::raw_ostream **)a1;
  BOOL v42 = *(_WORD **)(*(void *)a1 + 32);
  unint64_t v43 = *(void *)(*(void *)a1 + 24) - (void)v42;
  if (*(unsigned char *)(a1 + 16))
  {
    if (v43 <= 0xD)
    {
      uint64_t v44 = "</tr></table>>";
      size_t v45 = 14;
LABEL_68:
      llvm::raw_ostream::write(v41, v44, v45);
      goto LABEL_69;
    }
    qmemcpy(v42, "</tr></table>>", 14);
    uint64_t v55 = *((void *)v41 + 4) + 14;
  }
  else
  {
    if (v43 <= 1)
    {
      uint64_t v44 = "}\"";
      size_t v45 = 2;
      goto LABEL_68;
    }
    *BOOL v42 = 8829;
    uint64_t v55 = *((void *)v41 + 4) + 2;
  }
  *((void *)v41 + 4) = v55;
LABEL_69:
  uint64_t v46 = *(llvm::raw_ostream **)a1;
  uint64_t v47 = *(void *)(*(void *)a1 + 32);
  if ((unint64_t)(*(void *)(*(void *)a1 + 24) - v47) > 2)
  {
    *(unsigned char *)(v47 + 2) = 10;
    *(_WORD *)uint64_t v47 = 15197;
    *((void *)v46 + 4) += 3;
  }
  else
  {
    llvm::raw_ostream::write(v46, "];\n", 3uLL);
  }
  uint64_t v48 = (uint64_t *)(*(uint64_t (**)(unint64_t))(*(void *)a2 + 16))(a2);
  uint64_t v50 = v49;
  uint64_t v51 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 24))(a2);
  if (v48 != (uint64_t *)v51)
  {
    uint64_t v52 = 0;
    do
    {
      if (**(llvm::AbstractAttribute ***)(a1 + 8) != (llvm::AbstractAttribute *)((char *)sub_1CC8C5FA0(v50, v48[v52], 0, 0, 2)+ 48))sub_1CD660324((llvm::raw_ostream **)a1, a2, &v48[v52], v50); {
      uint64_t v53 = v52 * 8 + 8;
      }
      if (&v48[v52 + 1] == (uint64_t *)v51) {
        break;
      }
      BOOL v27 = (v52 * 8) == 504;
      ++v52;
    }
    while (!v27);
    uint64_t v48 = (uint64_t *)((char *)v48 + v53);
  }
  if (v48 != (uint64_t *)v51)
  {
    __int32 v54 = v48;
    do
    {
      if (**(llvm::AbstractAttribute ***)(a1 + 8) != (llvm::AbstractAttribute *)((char *)sub_1CC8C5FA0(v50, *v48, 0, 0, 2)+ 48))sub_1CD660324((llvm::raw_ostream **)a1, a2, v54, v50); {
      ++v48;
      }
      ++v54;
    }
    while (v48 != (uint64_t *)v51);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646B98;
  if (v62 == 1 && __p.__r_.__value_.__r.__words[2]) {
    MEMORY[0x1D25D9CB0](__p.__r_.__value_.__r.__words[2], 0x1000C8077774924);
  }
  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v64.__r_.__value_.__l.__data_);
  }
  if (v66 < 0) {
    operator delete(v65[0]);
  }
}

uint64_t sub_1CC8F8F60()
{
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Manifest Attributor internal string attributes.";
  v5.n128_u64[1] = 47;
  LOBYTE(v3) = 0;
  uint64_t v4 = &v3;
  sub_1CD413E90((llvm::cl::Option *)&unk_1EBCDDF28, "attributor-manifest-internal", &v2, &v5, (unsigned char **)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDDF28, &dword_1CB82C000);
  LODWORD(v4) = 128;
  v5.n128_u64[0] = (unint64_t)&v4;
  LODWORD(v2) = 1;
  sub_1CD65FD44((int **)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBCDDFE8, &dword_1CB82C000);
  int v3 = 1;
  v5.n128_u64[0] = (unint64_t)"Maximum number of potential values to be tracked for each position.";
  v5.n128_u64[1] = 67;
  uint64_t v4 = &llvm::PotentialValuesState<llvm::APInt>::MaxPotentialValues;
  int v1 = 7;
  uint64_t v2 = &v1;
  sub_1CD65FE64(&v3, (long long *)&v5, &v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC0708F8, &qword_1EBCDE0A8, &dword_1CB82C000);
  LODWORD(v2) = 1;
  v5.n128_u64[0] = (unint64_t)"Maximum number of interfering accesses to check before assuming all might interfere.";
  v5.n128_u64[1] = 84;
  int v3 = 6;
  uint64_t v4 = &v3;
  sub_1CD660008(&v2, (long long *)&v5, &v4);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCDE168, &dword_1CB82C000);
}

uint64_t sub_1CC8F90E4(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE228;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2627640;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE230, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC8F9204;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCDE230, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::initializeBarrierNoopPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE230, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8F9204;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE230, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8F9204()
{
}

void sub_1CC8F92A4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8F92DC()
{
  return 0;
}

void sub_1CC8F92E4()
{
}

void llvm::initializeBlockExtractorLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE238, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8F9390;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE238, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8F9390()
{
}

void llvm::createBlockExtractorPass(llvm *this)
{
}

uint64_t sub_1CC8F9468(uint64_t a1)
{
  v3[0] = &v4;
  v3[1] = 0;
  sub_1CC8F9510(a1, (uint64_t)v3, 0);
  if (v3[0] != &v4) {
    free(v3[0]);
  }
  return a1;
}

void llvm::createBlockExtractorPass()
{
}

{
  operator new();
}

uint64_t sub_1CC8F9510(uint64_t a1, uint64_t a2, char a3)
{
  v16[72] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EA61EFE6;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F26276E0;
  *(void *)(a1 + 32) = a1 + 48;
  uint64_t v4 = a1 + 32;
  *(void *)(a1 + 40) = 0x400000000;
  *(unsigned char *)(a1 + 624) = a3;
  *(void *)(a1 + 632) = a1 + 648;
  *(void *)(a1 + 640) = 0x400000000;
  uint64_t v14 = (char *)v16;
  uint64_t v15 = 0x400000000;
  uint64_t v5 = *(unsigned int *)(a2 + 8);
  if (v5)
  {
    uint64_t v6 = *(uint64_t **)a2;
    uint64_t v7 = 8 * v5;
    do
    {
      uint64_t v8 = *v6;
      v12[0] = v13;
      v13[0] = v8;
      v12[1] = (void *)0x1000000001;
      unint64_t v9 = sub_1CD63C2B8((uint64_t)&v14, (unint64_t)v12, 1);
      char v10 = &v14[144 * v15];
      *(void *)char v10 = v10 + 16;
      *((void *)v10 + 1) = 0x1000000000;
      if (*(_DWORD *)(v9 + 8)) {
        sub_1CBB08064((uint64_t)v10, v9);
      }
      LODWORD(v15) = v15 + 1;
      if (v12[0] != v13) {
        free(v12[0]);
      }
      ++v6;
      v7 -= 8;
    }
    while (v7);
  }
  sub_1CC8F96A0(v4, (uint64_t *)&v14);
  sub_1CD63C448(&v14);
  return a1;
}

void sub_1CC8F96A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *((_DWORD *)a2 + 2);
  if (v3)
  {
    uint64_t v4 = *a2;
    uint64_t v5 = *a2 + 144 * v3;
    do
    {
      uint64_t v49 = v51;
      uint64_t v50 = 0x1000000000;
      uint64_t v6 = *(unsigned int *)(v4 + 8);
      if (v6 >= 0x11) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v6)
      {
        memcpy(v51, *(const void **)v4, 8 * v6);
        int v7 = v50;
      }
      else
      {
        int v7 = 0;
      }
      LODWORD(v50) = v7 + v6;
      sub_1CD6605A4(a1, (uint64_t)&v49);
      if (v49 != v51) {
        free(v49);
      }
      v4 += 144;
    }
    while (v4 != v5);
  }
  uint64_t v8 = qword_1EBCDE388;
  if (byte_1EBCDE397 >= 0) {
    uint64_t v8 = byte_1EBCDE397 & 0x7F;
  }
  if (!v8) {
    return;
  }
  v51[8] = 260;
  uint64_t v49 = &qword_1EBCDE380;
  sub_1CD096690((unsigned __int8 *)&v49, (llvm::WritableMemoryBuffer *)0xFFFFFFFFFFFFFFFFLL, 0, 0, 1, 0, (uint64_t)&v52);
  if (v53)
  {
    uint64_t v9 = v52;
    if (v52)
    {
      unint64_t v32 = "BlockExtractor couldn't load the file.";
LABEL_54:
      llvm::report_fatal_error((llvm *)v32, (const llvm::Twine *)1);
    }
  }
  else
  {
    std::system_category();
    uint64_t v9 = v52;
  }
  char v10 = (char *)v51;
  uint64_t v49 = v51;
  uint64_t v50 = 0x1000000000;
  size_t v11 = *(void **)(v9 + 8);
  size_t v12 = (void *)(*(void *)(v9 + 16) - (void)v11);
  __p[0] = v11;
  __p[1] = v12;
  llvm::StringRef::split((char *)__p, (uint64_t)&v49, 10, -1, 0);
  uint64_t v13 = (char *)v49;
  if (!v50) {
    goto LABEL_46;
  }
  uint64_t v14 = &v45;
  uint64_t v15 = a1 + 600;
  uint64_t v16 = &v38;
  uint64_t v17 = (void **)v41;
  uint64_t v18 = 16 * v50;
  do
  {
    uint64_t v46 = v48;
    uint64_t v47 = 0x400000000;
    llvm::StringRef::split(v13, (uint64_t)&v46, 32, -1, 0);
    if (!v47) {
      goto LABEL_21;
    }
    if (v47 != 2)
    {
      unint64_t v32 = "Invalid line format, expecting lines like: 'funcname bb1[;bb2..]'";
      goto LABEL_54;
    }
    unint64_t v43 = v14;
    uint64_t v44 = 0x400000000;
    llvm::StringRef::split((char *)v46 + 16, (uint64_t)&v43, 59, -1, 0);
    if (!v44)
    {
      unint64_t v32 = "Missing bbs name";
      goto LABEL_54;
    }
    size_t v19 = *((void *)v46 + 1);
    if (v19 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v20 = *(const void **)v46;
    if (v19 >= 0x17)
    {
      uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v19 | 7) != 0x17) {
        uint64_t v22 = v19 | 7;
      }
      uint64_t v33 = v17;
      unsigned int v23 = v14;
      BOOL v24 = v10;
      int v25 = v16;
      uint64_t v26 = v15;
      uint64_t v27 = v22 + 1;
      int v28 = *(const void **)v46;
      uint64_t v29 = (long long *)operator new(v22 + 1);
      uint64_t v20 = v28;
      p_dst = v29;
      unint64_t v30 = v27 | 0x8000000000000000;
      uint64_t v15 = v26;
      uint64_t v16 = v25;
      char v10 = v24;
      uint64_t v14 = v23;
      uint64_t v17 = v33;
      *((void *)&__dst + 1) = v19;
      unint64_t v35 = v30;
      *(void *)&long long __dst = v29;
    }
    else
    {
      HIBYTE(v35) = *((void *)v46 + 1);
      p_dst = &__dst;
      if (!v19) {
        goto LABEL_35;
      }
    }
    memmove(p_dst, v20, v19);
LABEL_35:
    *((unsigned char *)p_dst + v19) = 0;
    size_t v36 = v16;
    uint64_t v37 = 0x400000000;
    sub_1CD660B90((uint64_t)&v36, (uint64_t)v43, (uint64_t)v43 + 16 * v44);
    int v31 = SHIBYTE(v35);
    if (SHIBYTE(v35) < 0)
    {
      sub_1CB8BDF7C((uint64_t)__p, (const void *)__dst, *((unint64_t *)&__dst + 1));
    }
    else
    {
      *(_OWORD *)std::string __p = __dst;
      unint64_t v40 = v35;
    }
    v41[0] = &v42;
    v41[1] = 0x400000000;
    if (v37) {
      sub_1CD660C28((uint64_t)v17, (uint64_t)&v36);
    }
    sub_1CD6606E4(v15, (unint64_t)__p);
    sub_1CC076978(v17);
    if (SHIBYTE(v40) < 0) {
      operator delete(__p[0]);
    }
    sub_1CC076978((void **)&v36);
    if (v31 < 0) {
      operator delete((void *)__dst);
    }
    if (v43 != v14) {
      free(v43);
    }
LABEL_21:
    if (v46 != v48) {
      free(v46);
    }
    v13 += 16;
    v18 -= 16;
  }
  while (v18);
  uint64_t v13 = (char *)v49;
LABEL_46:
  if (v13 != v10) {
    free(v13);
  }
  if ((v53 & 1) == 0)
  {
    if (v52) {
      (*(void (**)(uint64_t))(*(void *)v52 + 8))(v52);
    }
  }
}

uint64_t sub_1CC8F9B04(uint64_t a1, uint64_t a2)
{
  v114[4] = *MEMORY[0x1E4F143B8];
  int64x2_t v112 = (llvm::GlobalValue **)v114;
  uint64_t v113 = 0x400000000;
  uint64_t v2 = a2 + 24;
  uint64_t v3 = *(void *)(a2 + 32);
  if (v3 != a2 + 24)
  {
    unsigned int v72 = 0;
    do
    {
      if (v3) {
        BOOL v73 = (llvm::GlobalValue *)(v3 - 56);
      }
      else {
        BOOL v73 = 0;
      }
      unsigned int v74 = (void *)*((void *)v73 + 10);
      if (v74 != (void *)((char *)v73 + 72))
      {
        do
        {
          unsigned int v75 = v74 - 3;
          if (!v74) {
            unsigned int v75 = 0;
          }
          unsigned int v76 = v75 + 5;
          for (char i = (void *)v75[6]; i != v76; char i = (void *)i[1])
          {
            if (i) {
              int v78 = i - 3;
            }
            else {
              int v78 = 0;
            }
            if (*((unsigned char *)v78 + 16) == 33)
            {
              uint64_t v79 = v78[5];
              v107[0] = v79;
              uint64_t v80 = *(v78 - 8);
              uint64_t v81 = *(void *)(v80 + 8);
              if (v81)
              {
                while (1)
                {
                  uint64_t v82 = *(void *)(v81 + 24);
                  unsigned int v83 = *(unsigned __int8 *)(v82 + 16);
                  BOOL v84 = v82 && v83 >= 0x1C;
                  if (v84 && v83 - 29 <= 0xA) {
                    break;
                  }
                  uint64_t v81 = *(void *)(v81 + 8);
                  if (!v81) {
                    goto LABEL_129;
                  }
                }
LABEL_138:
                uint64_t v89 = *(void *)(v82 + 40);
                long long v90 = (uint64_t *)(v89 + 48);
                do
                {
                  uint64_t v91 = *v90;
                  uint64_t v92 = v91 - 24;
                  if (!v91) {
                    uint64_t v92 = 0;
                  }
                  int v93 = *(unsigned __int8 *)(v92 + 16);
                  long long v90 = (uint64_t *)(v91 + 8);
                }
                while (v93 == 83);
                if (v93 == 94 && v89 != v79)
                {
                  uint64_t v95 = *(void *)(v79 + 40);
                  if (v95) {
                    uint64_t v96 = v95 - 24;
                  }
                  else {
                    uint64_t v96 = 0;
                  }
                  if (*(unsigned __int8 *)(v96 + 16) - 29 >= 0xB) {
                    uint64_t v96 = 0;
                  }
                  if (*(unsigned char *)(v96 + 16) == 33)
                  {
                    uint64_t v109 = v111;
                    uint64_t v110 = 0x200000000;
                    sub_1CD127BEC((uint64_t **)v80);
                  }
                }
                while (1)
                {
                  uint64_t v81 = *(void *)(v81 + 8);
                  if (!v81) {
                    break;
                  }
                  uint64_t v82 = *(void *)(v81 + 24);
                  unsigned int v86 = *(unsigned __int8 *)(v82 + 16);
                  if (v82) {
                    BOOL v87 = v86 >= 0x1C;
                  }
                  else {
                    BOOL v87 = 0;
                  }
                  if (v87 && v86 - 29 < 0xB) {
                    goto LABEL_138;
                  }
                }
              }
            }
LABEL_129:
            ;
          }
          unsigned int v74 = (void *)v74[1];
        }
        while (v74 != (void *)((char *)v73 + 72));
        unsigned int v72 = v113;
      }
      if (v72 >= HIDWORD(v113)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v112[v72] = v73;
      unsigned int v72 = v113 + 1;
      LODWORD(v113) = v113 + 1;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
  }
  uint64_t v4 = a1;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  sub_1CD660E2C(a1, *(unsigned int *)(a1 + 608) + v5);
  unsigned int v6 = *(_DWORD *)(a1 + 608);
  if (!v6) {
    goto LABEL_65;
  }
  int v7 = *(size_t **)(a1 + 600);
  __int16 v98 = &v7[17 * v6];
  do
  {
    unsigned int v99 = v5;
    uint64_t v100 = v7;
    char v8 = *((unsigned char *)v7 + 23);
    BOOL v9 = v8 < 0;
    char v10 = (unsigned __int8 *)*v7;
    if (v8 >= 0) {
      char v10 = (unsigned __int8 *)v7;
    }
    __s1 = v10;
    size_t v11 = v8 & 0x7F;
    if (v9) {
      size_t v12 = v7[1];
    }
    else {
      size_t v12 = v11;
    }
    uint64_t v13 = *(uint64_t **)(a2 + 112);
    size_t v14 = *((unsigned int *)v13 + 8);
    if ((v14 & 0x80000000) == 0)
    {
      if (v14 <= 1) {
        unint64_t v15 = 1;
      }
      else {
        unint64_t v15 = v14;
      }
      if (v12 < v15) {
        unint64_t v15 = v12;
      }
      if (v12 > v14) {
        size_t v12 = v15;
      }
    }
    uint64_t v16 = *((unsigned int *)v13 + 2);
    if (!v16) {
      goto LABEL_104;
    }
    int v17 = 0;
    if (v12)
    {
      size_t v18 = v12;
      size_t v19 = __s1;
      do
      {
        int v20 = *v19++;
        int v17 = 33 * v17 + v20;
        --v18;
      }
      while (v18);
    }
    uint64_t v21 = *v13;
    uint64_t v22 = *v13 + 8 * v16 + 8;
    int v23 = 1;
    int v24 = v17;
    while (1)
    {
      uint64_t v25 = v24 & (v16 - 1);
      uint64_t v26 = *(void **)(v21 + 8 * v25);
      if (v26 != (void *)-8)
      {
        if (!v26) {
          goto LABEL_104;
        }
        if (*(_DWORD *)(v22 + 4 * v25) == v17
          && v12 == *v26
          && (!v12 || !memcmp(__s1, (char *)v26 + *((unsigned int *)v13 + 5), v12)))
        {
          break;
        }
      }
      int v24 = v23 + v25;
      ++v23;
    }
    if (v25 == -1
      || (int)v25 == v16
      || (uint64_t v27 = *(void *)(*(void *)(v21 + 8 * (int)v25) + 8)) == 0
      || *(unsigned char *)(v27 + 16))
    {
LABEL_104:
      uint64_t v71 = "Invalid function name specified in the input file";
      goto LABEL_105;
    }
    unsigned int v28 = *((_DWORD *)v100 + 8);
    uint64_t v4 = a1;
    if (!v28) {
      goto LABEL_64;
    }
    uint64_t v29 = (const void **)v100[3];
    __s1a = &v29[3 * v28];
    uint64_t v30 = v27 + 72;
    do
    {
      uint64_t v31 = *(void *)(v27 + 80);
      if (v31 == v30)
      {
LABEL_164:
        uint64_t v71 = "Invalid block name specified in the input file";
LABEL_105:
        llvm::report_fatal_error((llvm *)v71, (const llvm::Twine *)1);
      }
      char v32 = *((unsigned char *)v29 + 23);
      BOOL v33 = v32 < 0;
      if (v32 >= 0) {
        uint64_t v34 = v29;
      }
      else {
        uint64_t v34 = *v29;
      }
      size_t v35 = v32 & 0x7F;
      if (v33) {
        size_t v36 = (size_t)v29[1];
      }
      else {
        size_t v36 = v35;
      }
      while (1)
      {
        if (v31) {
          uint64_t v37 = (uint64_t ***)(v31 - 24);
        }
        else {
          uint64_t v37 = 0;
        }
        if ((*((unsigned char *)v37 + 23) & 0x10) == 0)
        {
          uint64_t v48 = 0;
          uint64_t v47 = &byte_1CFBCE98E;
          goto LABEL_54;
        }
        uint64_t v38 = ***v37;
        uint64_t v39 = *(void *)(v38 + 152);
        uint64_t v40 = *(unsigned int *)(v38 + 168);
        if (!v40) {
          goto LABEL_52;
        }
        LODWORD(v41) = (v40 - 1) & ((v37 >> 4) ^ (v37 >> 9));
        uint64_t v42 = (uint64_t ****)(v39 + 16 * v41);
        unint64_t v43 = *v42;
        if (*v42 != v37)
        {
          int v44 = 1;
          while (v43 != (uint64_t ***)-4096)
          {
            int v45 = v41 + v44++;
            uint64_t v41 = v45 & (v40 - 1);
            unint64_t v43 = *(uint64_t ****)(v39 + 16 * v41);
            if (v43 == v37)
            {
              uint64_t v42 = (uint64_t ****)(v39 + 16 * v41);
              goto LABEL_53;
            }
          }
LABEL_52:
          uint64_t v42 = (uint64_t ****)(v39 + 16 * v40);
        }
LABEL_53:
        uint64_t v46 = v42[1];
        uint64_t v49 = *v46;
        uint64_t v47 = (char *)(v46 + 2);
        uint64_t v48 = v49;
LABEL_54:
        if (v48 == (uint64_t **)v36 && (!v36 || !memcmp(v47, v34, v36))) {
          break;
        }
        uint64_t v31 = *(void *)(v31 + 8);
        if (v31 == v30) {
          goto LABEL_164;
        }
      }
      uint64_t v50 = *(void *)a1 + 144 * v99;
      unint64_t v51 = *(unsigned int *)(v50 + 8);
      if (v51 >= *(unsigned int *)(v50 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v50 + 8 * v51) = v37;
      ++*(_DWORD *)(v50 + 8);
      v29 += 3;
    }
    while (v29 != __s1a);
LABEL_64:
    LODWORD(v5) = v99 + 1;
    int v7 = v100 + 17;
  }
  while (v100 + 17 != v98);
LABEL_65:
  unsigned int v52 = *(_DWORD *)(v4 + 8);
  char v53 = 0;
  if (!v52) {
    goto LABEL_91;
  }
  uint64_t v54 = *(uint64_t ***)v4;
  uint64_t v55 = *(void *)v4 + 144 * v52;
  while (2)
  {
    uint64_t v109 = v111;
    uint64_t v110 = 0x2000000000;
    uint64_t v56 = *v54;
    uint64_t v57 = *((unsigned int *)v54 + 2);
    if (!v57) {
      goto LABEL_88;
    }
    unsigned int v58 = 0;
    uint64_t v59 = 8 * v57;
    while (2)
    {
      uint64_t v60 = *v56;
      if (*(void *)(*(void *)(*v56 + 56) + 40) != a2)
      {
        uint64_t v71 = "Invalid basic block";
        goto LABEL_105;
      }
      if (v58 >= HIDWORD(v110)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v109 + v58) = v60;
      unsigned int v58 = v110 + 1;
      LODWORD(v110) = v110 + 1;
      uint64_t v61 = *(void *)(v60 + 40);
      if (v61 != v60 + 40)
      {
        uint64_t v62 = v61 - 24;
        if (!v61) {
          uint64_t v62 = 0;
        }
        unsigned int v63 = *(unsigned __int8 *)(v62 + 16) - 40;
        if (v63 < 0xFFFFFFF5) {
          uint64_t v62 = 0;
        }
        if (v61)
        {
          if (*(unsigned char *)(v62 + 16) == 33 && v63 >= 0xFFFFFFF5)
          {
            if (v58 >= HIDWORD(v110)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v109 + v58) = *(void *)(v62 - 64);
            unsigned int v58 = v110 + 1;
            LODWORD(v110) = v110 + 1;
          }
        }
      }
      ++v56;
      v59 -= 8;
      if (v59) {
        continue;
      }
      break;
    }
    uint64_t v56 = *v54;
    char v53 = 1;
LABEL_88:
    llvm::CodeExtractorAnalysisCache::CodeExtractorAnalysisCache((llvm::CodeExtractorAnalysisCache *)v108, *(llvm::Function **)(*v56 + 56));
    char v106 = 0;
    LOBYTE(v105) = 0;
    llvm::CodeExtractor::CodeExtractor((uint64_t)v107, (char **)v109, v110, 0, 0, 0, 0, 0, 0, 0, 0, &v105);
    llvm::CodeExtractor::extractCodeRegion((llvm::CodeExtractor *)v107, (const llvm::CodeExtractorAnalysisCache *)v108);
    sub_1CD6110E0((uint64_t)v107);
    sub_1CD611140((uint64_t)v108);
    if (v109 != v111) {
      free(v109);
    }
    v54 += 18;
    if (v54 != (uint64_t **)v55) {
      continue;
    }
    break;
  }
LABEL_91:
  if (*(unsigned __int8 *)(a1 + 592) | byte_1EBCDE2C0)
  {
    if (v113)
    {
      unsigned int v65 = v112;
      uint64_t v66 = 8 * v113;
      do
      {
        unsigned int v67 = *v65++;
        sub_1CD660DD8(v67);
        v66 -= 8;
      }
      while (v66);
    }
    for (uint64_t j = *(void *)(a2 + 32); j != v2; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        BOOL v69 = (llvm::GlobalValue *)(j - 56);
      }
      else {
        BOOL v69 = 0;
      }
      int v70 = *((_DWORD *)v69 + 8);
      *((_DWORD *)v69 + 8) = v70 & 0xFFFFFFF0;
      if ((v70 & 0x30) != 0 && (llvm::GlobalValue::hasExternalWeakLinkage(v69) & 1) == 0) {
        *((_DWORD *)v69 + 8) |= 0x4000u;
      }
    }
    char v53 = 1;
  }
  if (v112 != v114) {
    free(v112);
  }
  return v53 & 1;
}

void sub_1CC8FA2D4()
{
}

void sub_1CC8FA310(char **a1)
{
  *a1 = (char *)&unk_1F26276E0;
  uint64_t v2 = a1 + 4;
  sub_1CD660F0C(a1 + 79);
  sub_1CD63C448(v2);

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC8FA374(char **a1)
{
  *a1 = (char *)&unk_1F26276E0;
  uint64_t v2 = a1 + 4;
  sub_1CD660F0C(a1 + 79);
  sub_1CD63C448(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8FA3EC(uint64_t a1, uint64_t a2)
{
  return sub_1CC8F9B04(a1 + 32, a2);
}

uint64_t sub_1CC8FA3F4()
{
  *(void *)&long long v3 = "filename";
  *((void *)&v3 + 1) = 8;
  *(void *)&long long v2 = "A file containing list of basic blocks to extract";
  *((void *)&v2 + 1) = 49;
  int v1 = 1;
  sub_1CD660F88(&v3, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, &qword_1EBCDE300, &dword_1CB82C000);
  *(void *)&long long v3 = "Erase the existing functions";
  *((void *)&v3 + 1) = 28;
  LODWORD(v2) = 1;
  sub_1CD6610AC((uint64_t)&unk_1EBCDE240, "extract-blocks-erase-funcs", &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDE240, &dword_1CB82C000);
}

uint64_t sub_1CC8FA4CC(uint64_t *a1)
{
  uint64_t v89[2] = *(void **)MEMORY[0x1E4F143B8];
  int v57 = 0;
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  unsigned int v58 = 0;
  int v61 = 0;
  unsigned int v63 = 0;
  uint64_t v64 = 0;
  uint64_t v62 = 0;
  int v65 = 0;
  unsigned int v67 = 0;
  uint64_t v68 = 0;
  std::string __p = 0;
  sub_1CBFAFDE4(&v58, 0, 0, 0);
  int v61 = 2;
  sub_1CBFAFDE4(&v62, 0, 0, 0);
  int v65 = 3;
  sub_1CBFAFDE4(&__p, 0, 0, 0);
  unsigned int v3 = 0;
  unsigned int v4 = 0;
  uint64_t v56 = &unk_1F2627780;
  BOOL v69 = v73;
  int v70 = v73;
  uint64_t v71 = 32;
  int v72 = 0;
  v75[0] = 0;
  v75[1] = 0;
  unsigned int v74 = &v56;
  int v76 = 0;
  uint64_t v77 = v81;
  int v78 = v81;
  uint64_t v79 = 16;
  int v80 = 0;
  uint64_t v82 = v84;
  uint64_t v83 = 0x4000000000;
  uint64_t v85 = v87;
  uint64_t v86 = 0x4000000000;
  v89[1] = 0;
  v89[0] = 0;
  int v88 = v89;
  uint64_t v5 = (uint64_t *)a1[4];
  if (v5 != a1 + 3)
  {
    while (1)
    {
      if (v5) {
        unsigned int v6 = v5 - 7;
      }
      else {
        unsigned int v6 = 0;
      }
      if (v5 && *((unsigned char *)v6 + 16) == 3)
      {
        if ((*((_DWORD *)v6 + 5) & 0x7FFFFFF) != 0) {
          goto LABEL_12;
        }
      }
      else if (*((unsigned char *)v6 + 16) || (uint64_t *)v6[9] != v6 + 9 || (*((unsigned char *)v6 + 34) & 0x80) != 0)
      {
LABEL_12:
        if ((llvm::canTrackArgumentsInterprocedurally((llvm *)v6, v2) & 1) == 0)
        {
          uint64_t v7 = v6[10];
          if (v7) {
            uint64_t v8 = v7 - 24;
          }
          else {
            uint64_t v8 = 0;
          }
          sub_1CC8FAC98((uint64_t)&v74, v8);
        }
      }
      uint64_t v5 = (uint64_t *)v5[1];
      if (v5 == a1 + 3)
      {
        unsigned int v4 = v86;
        unsigned int v3 = v83;
        break;
      }
    }
  }
  if (v4 | v3)
  {
    do
    {
      if (v3)
      {
        do
        {
          uint64_t v9 = *((void *)v82 + --v3);
          LODWORD(v83) = v3;
          uint64_t v10 = *(void *)(v9 + 8);
          if (v10)
          {
            do
            {
              unint64_t v11 = *(void *)(v10 + 24);
              if (v11) {
                BOOL v12 = *(unsigned __int8 *)(v11 + 16) >= 0x1Cu;
              }
              else {
                BOOL v12 = 0;
              }
              if (v12)
              {
                uint64_t v13 = *(void *)(v11 + 40);
                size_t v14 = v77;
                if (v78 == v77)
                {
                  int v15 = HIDWORD(v79);
                  uint64_t v16 = &v78[8 * HIDWORD(v79)];
                  if (HIDWORD(v79))
                  {
                    uint64_t v17 = 0;
                    while (*(void *)&v78[v17] != v13)
                    {
                      v17 += 8;
                      if (8 * HIDWORD(v79) == v17) {
                        goto LABEL_46;
                      }
                    }
                    uint64_t v16 = &v78[v17];
                  }
LABEL_46:
                  size_t v14 = v78;
                }
                else
                {
                  int v18 = v79 - 1;
                  unsigned int v19 = (v79 - 1) & ((v13 >> 4) ^ (v13 >> 9));
                  uint64_t v16 = &v78[8 * v19];
                  uint64_t v20 = *(void *)v16;
                  if (*(void *)v16 == -1)
                  {
                    uint64_t v21 = 0;
LABEL_54:
                    if (v21) {
                      uint64_t v16 = v21;
                    }
                    int v15 = HIDWORD(v79);
                    if (*(void *)v16 != v13) {
                      uint64_t v16 = &v78[8 * v79];
                    }
                  }
                  else
                  {
                    uint64_t v21 = 0;
                    int v22 = 1;
                    while (v20 != v13)
                    {
                      if (v21) {
                        BOOL v23 = 0;
                      }
                      else {
                        BOOL v23 = v20 == -2;
                      }
                      if (v23) {
                        uint64_t v21 = v16;
                      }
                      unsigned int v24 = v19 + v22++;
                      unsigned int v19 = v24 & v18;
                      uint64_t v16 = &v78[8 * (v24 & v18)];
                      uint64_t v20 = *(void *)v16;
                      if (*(void *)v16 == -1) {
                        goto LABEL_54;
                      }
                    }
                    int v15 = HIDWORD(v79);
                  }
                }
                int v25 = v79;
                if (v78 == v14) {
                  int v25 = v15;
                }
                if (v16 != &v78[8 * v25]) {
                  sub_1CC8FCDBC((uint64_t)&v74, v11);
                }
              }
              uint64_t v10 = *(void *)(v10 + 8);
            }
            while (v10);
            unsigned int v3 = v83;
          }
        }
        while (v3);
        unsigned int v4 = v86;
      }
      if (!v4) {
        break;
      }
      do
      {
        uint64_t v26 = *((void *)v85 + --v4);
        LODWORD(v86) = v4;
        uint64_t v27 = v26 + 40;
        uint64_t v28 = *(void *)(v26 + 48);
        if (v28 != v26 + 40)
        {
          do
          {
            if (v28) {
              unint64_t v29 = v28 - 24;
            }
            else {
              unint64_t v29 = 0;
            }
            sub_1CC8FCDBC((uint64_t)&v74, v29);
            uint64_t v28 = *(void *)(v28 + 8);
          }
          while (v28 != v27);
          unsigned int v4 = v86;
        }
      }
      while (v4);
      unsigned int v3 = v83;
    }
    while (v83);
  }
  uint64_t v55 = *a1;
  if (v70 == v69) {
    uint64_t v30 = (uint64_t *)((char *)&v71 + 4);
  }
  else {
    uint64_t v30 = &v71;
  }
  uint64_t v31 = *(unsigned int *)v30;
  if (v31)
  {
    uint64_t v53 = 8 * v31;
    char v32 = v70;
    while (*(void *)v32 >= 0xFFFFFFFFFFFFFFFELL)
    {
      v32 += 8;
      v53 -= 8;
      if (!v53) {
        goto LABEL_103;
      }
    }
  }
  else
  {
    char v32 = v70;
  }
  BOOL v33 = &v70[8 * v31];
  if (v32 != v33)
  {
    char v34 = 0;
    size_t v35 = *(llvm::Instruction **)v32;
    while (1)
    {
      if (!v76) {
        goto LABEL_80;
      }
      unint64_t v36 = *((void *)v35 - 4);
      unint64_t v37 = v36 & 0xFFFFFFFFFFFFFFF9;
      unsigned int v38 = (v76 - 1) & ((v36 >> 9) ^ v36 & 0xFFFFFFF9);
      uint64_t v39 = v75[0] + 40 * v38;
      uint64_t v40 = *(void *)v39;
      if (v37 != *(void *)v39) {
        break;
      }
LABEL_79:
      if (v38 == v76) {
        goto LABEL_80;
      }
      uint64_t v42 = *(unsigned char **)(v39 + 16);
      int v45 = *(unsigned char **)(v39 + 24);
      int64_t v43 = v45 - v42;
      if (v45 != v42)
      {
        if (v43 < 0) {
LABEL_119:
        }
          abort();
        int v44 = *(_DWORD *)(v39 + 8);
        goto LABEL_86;
      }
LABEL_92:
      uint64_t v48 = (unint64_t *)(v32 + 8);
      do
      {
        if (v48 == (unint64_t *)v33) {
          goto LABEL_104;
        }
        unint64_t v49 = *v48++;
        size_t v35 = (llvm::Instruction *)v49;
      }
      while (v49 > 0xFFFFFFFFFFFFFFFDLL);
      char v32 = (char *)(v48 - 1);
    }
    int v51 = 1;
    while (v40 != -2)
    {
      unsigned int v52 = v38 + v51++;
      unsigned int v38 = v52 & (v76 - 1);
      uint64_t v39 = v75[0] + 40 * v38;
      uint64_t v40 = *(void *)v39;
      if (v37 == *(void *)v39) {
        goto LABEL_79;
      }
    }
LABEL_80:
    uint64_t v42 = v74[10];
    uint64_t v41 = v74[11];
    int64_t v43 = v41 - v42;
    if (v41 != v42)
    {
      if (v43 < 0) {
        goto LABEL_119;
      }
      int v44 = *((_DWORD *)v74 + 18);
LABEL_86:
      uint64_t v46 = (char *)operator new(v43);
      memmove(v46, v42, v43);
      if (v44 == 1 && v46 != &v46[8 * (v43 >> 3)])
      {
        uint64_t v50 = llvm::MDBuilder::createCallees(&v55, (llvm::Value *)v46, (8 * (v43 >> 3)) >> 3);
        llvm::Instruction::setMetadata(v35, 23, v50);
        char v34 = 1;
      }
      operator delete(v46);
      goto LABEL_92;
    }
    goto LABEL_92;
  }
LABEL_103:
  char v34 = 0;
LABEL_104:
  sub_1CD3C5048((uint64_t)&v88, v89[0]);
  if (v85 != v87) {
    free(v85);
  }
  if (v82 != v84) {
    free(v82);
  }
  if (v78 != v77) {
    free(v78);
  }
  sub_1CC8FDB9C(v75);
  uint64_t v56 = &unk_1F2627780;
  if (v70 != v69) {
    free(v70);
  }
  uint64_t v56 = &unk_1F26277E0;
  if (__p)
  {
    unsigned int v67 = __p;
    operator delete(__p);
  }
  if (v62)
  {
    unsigned int v63 = v62;
    operator delete(v62);
  }
  if (v58)
  {
    uint64_t v59 = v58;
    operator delete(v58);
  }
  return v34 & 1;
}

void llvm::initializeCalledValuePropagationLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  long long v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4B0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8FAB50;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCDE4B0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8FAB50()
{
}

uint64_t sub_1CC8FABE8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE4A8;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2627840;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4B0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC8FAB50;
    v5[1] = &PassRegistry;
    unsigned int v4 = v5;
    std::__call_once(&qword_1EBCDE4B0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC8FAC98(uint64_t a1, uint64_t a2)
{
  unsigned int v6 = *(void **)(a1 + 32);
  uint64_t v5 = *(void **)(a1 + 40);
  unsigned int v4 = (unsigned int *)(a1 + 32);
  uint64_t v7 = v4[5];
  if (v5 == v6)
  {
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v10 = v5;
      while (*v10 != a2)
      {
        if (*v10 == -2) {
          uint64_t v8 = v10;
        }
        ++v10;
        v9 -= 8;
        if (!v9)
        {
          if (!v8) {
            goto LABEL_9;
          }
          *uint64_t v8 = a2;
          --*(_DWORD *)(a1 + 56);
          goto LABEL_33;
        }
      }
      return;
    }
LABEL_9:
    unsigned int v11 = *(_DWORD *)(a1 + 48);
    if (v7 < v11)
    {
      *(_DWORD *)(a1 + 52) = v7 + 1;
      v5[v7] = a2;
LABEL_33:
      unsigned int v21 = *(_DWORD *)(a1 + 728);
      if (v21 >= *(_DWORD *)(a1 + 732)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 720) + 8 * v21) = a2;
      ++*(_DWORD *)(a1 + 728);
      return;
    }
  }
  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 48);
  }
  if (3 * v11 <= 4 * ((int)v7 - *(_DWORD *)(a1 + 56)))
  {
    if (v11 >= 0x40) {
      v11 *= 2;
    }
    else {
      unsigned int v11 = 128;
    }
  }
  else if (v11 - v7 >= v11 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v4, v11);
  unsigned int v11 = *(_DWORD *)(a1 + 48);
  uint64_t v5 = *(void **)(a1 + 40);
LABEL_14:
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  size_t v14 = &v5[v13];
  uint64_t v15 = *v14;
  if (*v14 != -1)
  {
    uint64_t v16 = 0;
    int v17 = 1;
    while (v15 != a2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -2;
      }
      if (v18) {
        uint64_t v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      size_t v14 = &v5[v19 & v12];
      uint64_t v15 = *v14;
      if (*v14 == -1) {
        goto LABEL_26;
      }
    }
    return;
  }
  uint64_t v16 = 0;
LABEL_26:
  if (v16) {
    uint64_t v20 = v16;
  }
  else {
    uint64_t v20 = v14;
  }
  if (*v20 != a2)
  {
    if (*v20 == -2) {
      --*(_DWORD *)(a1 + 56);
    }
    else {
      ++*(_DWORD *)(a1 + 52);
    }
    *uint64_t v20 = a2;
    goto LABEL_33;
  }
}

void *sub_1CC8FAE54(void *a1)
{
  *a1 = &unk_1F2627780;
  long long v2 = (void *)a1[14];
  if (v2 != (void *)a1[13]) {
    free(v2);
  }
  *a1 = &unk_1F26277E0;
  unsigned int v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  unsigned int v4 = (void *)a1[6];
  if (v4)
  {
    a1[7] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[2];
  if (v5)
  {
    a1[3] = v5;
    operator delete(v5);
  }
  return a1;
}

void sub_1CC8FAEF4(void *a1)
{
  *a1 = &unk_1F2627780;
  long long v2 = (void *)a1[14];
  if (v2 != (void *)a1[13]) {
    free(v2);
  }
  *a1 = &unk_1F26277E0;
  unsigned int v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }
  unsigned int v4 = (void *)a1[6];
  if (v4)
  {
    a1[7] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[2];
  if (v5)
  {
    a1[3] = v5;
    operator delete(v5);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8FAFB4()
{
  return 0;
}

void *sub_1CC8FAFBC@<X0>(uint64_t a1@<X0>, llvm::Function *a2@<X1>, void *a3@<X8>)
{
  unsigned int v5 = (a2 >> 1) & 3;
  if (v5 - 1 >= 2)
  {
    if (!v5)
    {
      uint64_t v7 = (llvm **)((unint64_t)a2 & 0xFFFFFFFFFFFFFFF8);
      unsigned int v9 = *(unsigned __int8 *)(((unint64_t)a2 & 0xFFFFFFFFFFFFFFF8) + 16);
      if (v9 >= 0x1C) {
        goto LABEL_17;
      }
      if (!v7 || v9 != 21)
      {
        if (v7 && v9 <= 0x14)
        {
LABEL_6:
          return sub_1CC8FC60C(a3, a1, (llvm::Value *)v7);
        }
        goto LABEL_20;
      }
      if (llvm::canTrackArgumentsInterprocedurally(v7[3], a2)) {
        goto LABEL_17;
      }
    }
LABEL_20:
    *(_DWORD *)a3 = *(_DWORD *)(a1 + 40);
    a3[2] = 0;
    a3[3] = 0;
    a3[1] = 0;
    uint64_t v10 = a3 + 1;
    unsigned int v11 = *(const void **)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    goto LABEL_21;
  }
  unint64_t v6 = (unint64_t)a2 & 0xFFFFFFFFFFFFFFF8;
  if (((unint64_t)a2 & 0xFFFFFFFFFFFFFFF8) != 0 && *(unsigned char *)(v6 + 16) == 3)
  {
    if (llvm::canTrackGlobalVariableInterprocedurally((llvm *)((unint64_t)a2 & 0xFFFFFFFFFFFFFFF8), a2))
    {
      uint64_t v7 = *(llvm ***)(v6 - 32);
      goto LABEL_6;
    }
    goto LABEL_20;
  }
  if (!v6 || !llvm::canTrackReturnsInterprocedurally((llvm *)((unint64_t)a2 & 0xFFFFFFFFFFFFFFF8), a2)) {
    goto LABEL_20;
  }
LABEL_17:
  *(_DWORD *)a3 = *(_DWORD *)(a1 + 8);
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  uint64_t v10 = a3 + 1;
  unsigned int v11 = *(const void **)(a1 + 16);
  uint64_t v12 = *(void *)(a1 + 24);
LABEL_21:

  return sub_1CBFCBA2C(v10, v11, v12, (v12 - (uint64_t)v11) >> 3);
}

uint64_t sub_1CC8FB0D8()
{
  return 0;
}

void sub_1CC8FB0E0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6 = a1;
  int v8 = *(_DWORD *)(a1 + 40);
  unsigned int v9 = *(unsigned char **)(a1 + 48);
  uint64_t v10 = *(unsigned char **)(a1 + 56);
  size_t v11 = v10 - v9;
  uint64_t v12 = (v10 - v9) >> 3;
  if (v10 == v9)
  {
    unsigned int v13 = 0;
    size_t v14 = 0;
  }
  else
  {
    if ((v11 & 0x8000000000000000) != 0) {
      goto LABEL_147;
    }
    unsigned int v13 = (char *)operator new(v10 - v9);
    memmove(v13, v9, v10 - v9);
    size_t v14 = &v13[8 * v12];
  }
  if (*(_DWORD *)a2 != v8
    || (uint64_t v15 = *(const void **)(a2 + 8), v16 = *(void *)(a2 + 16) - (void)v15, v16 != v14 - v13)
    || memcmp(v15, v13, v16))
  {
    if (v10 == v9)
    {
      int v17 = 0;
      BOOL v18 = 0;
    }
    else
    {
      if ((v11 & 0x8000000000000000) != 0) {
        goto LABEL_147;
      }
      int v17 = (char *)operator new(v10 - v9);
      memmove(v17, v9, v11);
      BOOL v18 = &v17[8 * v12];
    }
    if (*(_DWORD *)a3 == v8
      && (unsigned int v19 = *(const void **)(a3 + 8), v20 = *(void *)(a3 + 16) - (void)v19, v20 == v18 - v17))
    {
      BOOL v21 = memcmp(v19, v17, v20) == 0;
      if (!v17)
      {
LABEL_18:
        if (!v13) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
    }
    else
    {
      BOOL v21 = 0;
      if (!v17) {
        goto LABEL_18;
      }
    }
    operator delete(v17);
    goto LABEL_18;
  }
  BOOL v21 = 1;
  if (v13) {
LABEL_19:
  }
    operator delete(v13);
LABEL_20:
  if (v21)
  {
    *(_DWORD *)a4 = *(_DWORD *)(v6 + 40);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    int v22 = (void *)(a4 + 8);
    BOOL v23 = *(const void **)(v6 + 48);
    uint64_t v24 = *(void *)(v6 + 56);
LABEL_34:
    sub_1CBFCBA2C(v22, v23, v24, (v24 - (uint64_t)v23) >> 3);
    return;
  }
  int v25 = *(_DWORD *)(v6 + 8);
  uint64_t v26 = *(unsigned char **)(v6 + 16);
  uint64_t v27 = *(unsigned char **)(v6 + 24);
  size_t v28 = v27 - v26;
  uint64_t v29 = (v27 - v26) >> 3;
  if (v27 == v26)
  {
    uint64_t v31 = 0;
    uint64_t v30 = 0;
  }
  else
  {
    if ((v28 & 0x8000000000000000) != 0) {
      goto LABEL_147;
    }
    uint64_t v30 = (char *)operator new(v27 - v26);
    memmove(v30, v26, v27 - v26);
    uint64_t v31 = &v30[8 * v29];
  }
  if (*(_DWORD *)a2 != v25
    || (char v32 = *(const void **)(a2 + 8), v33 = *(void *)(a2 + 16) - (void)v32, v33 != v31 - v30)
    || memcmp(v32, v30, v33))
  {
    BOOL v34 = 0;
    goto LABEL_30;
  }
  if (v27 == v26)
  {
    uint64_t v85 = 0;
    BOOL v84 = 0;
    goto LABEL_141;
  }
  if ((v28 & 0x8000000000000000) != 0) {
LABEL_147:
  }
    abort();
  BOOL v84 = (char *)operator new(v27 - v26);
  memmove(v84, v26, v28);
  uint64_t v85 = &v84[8 * v29];
LABEL_141:
  BOOL v34 = *(_DWORD *)a3 == v25
     && (uint64_t v86 = *(const void **)(a3 + 8), v87 = *(void *)(a3 + 16) - (void)v86, v87 == v85 - v84)
     && memcmp(v86, v84, v87) == 0;
  if (v84) {
    operator delete(v84);
  }
LABEL_30:
  if (v30) {
    operator delete(v30);
  }
  if (v34)
  {
    *(_DWORD *)a4 = *(_DWORD *)(v6 + 8);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 8) = 0;
    int v22 = (void *)(a4 + 8);
    BOOL v23 = *(const void **)(v6 + 16);
    uint64_t v24 = *(void *)(v6 + 24);
    goto LABEL_34;
  }
  uint64_t v88 = a4;
  size_t v35 = *(uint64_t *****)(a2 + 8);
  unint64_t v36 = *(uint64_t *****)(a2 + 16);
  unsigned int v38 = *(uint64_t *****)(a3 + 8);
  unint64_t v37 = *(uint64_t *****)(a3 + 16);
  long long v90 = v37;
  if (v35 == v36)
  {
    uint64_t v41 = 0;
    int v45 = 0;
    uint64_t v39 = 0;
LABEL_84:
    if (v38 == v37)
    {
      int v65 = v45;
    }
    else
    {
      do
      {
        if (v45 >= v41)
        {
          uint64_t v66 = (v45 - v39) >> 3;
          unint64_t v67 = v66 + 1;
          if ((unint64_t)(v66 + 1) >> 61) {
            goto LABEL_147;
          }
          unint64_t v68 = v41 - v39;
          unint64_t v69 = (v41 - v39) >> 2;
          if (v69 > v67) {
            unint64_t v67 = v69;
          }
          if (v68 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v70 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v70 = v67;
          }
          if (v70)
          {
            if (v70 >> 61) {
              goto LABEL_148;
            }
            uint64_t v71 = (char *)operator new(8 * v70);
          }
          else
          {
            uint64_t v71 = 0;
          }
          int v72 = (uint64_t ****)&v71[8 * v66];
          *int v72 = *v38;
          int v65 = (char *)(v72 + 1);
          if (v45 == v39)
          {
            unint64_t v37 = v90;
          }
          else
          {
            unint64_t v37 = v90;
            do
            {
              BOOL v73 = (uint64_t ***)*((void *)v45 - 1);
              v45 -= 8;
              *--int v72 = v73;
            }
            while (v45 != v39);
          }
          uint64_t v41 = &v71[8 * v70];
          if (v39)
          {
            unsigned int v74 = &v71[8 * v70];
            operator delete(v39);
            uint64_t v41 = v74;
          }
          uint64_t v39 = (char *)v72;
        }
        else
        {
          *(void *)int v45 = *v38;
          int v65 = v45 + 8;
        }
        ++v38;
        int v45 = v65;
      }
      while (v38 != v37);
    }
  }
  else
  {
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    uint64_t v89 = v6;
    while (v38 != v37)
    {
      unint64_t v42 = (unint64_t)v41;
      int64_t v43 = *v38;
      int v44 = *v35;
      if (sub_1CC8FC6CC(*v38, *v35))
      {
        uint64_t v41 = (char *)v42;
        if ((unint64_t)v40 >= v42)
        {
          uint64_t v47 = ((char *)v40 - v39) >> 3;
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 61) {
            goto LABEL_147;
          }
          unint64_t v49 = v41 - v39;
          unint64_t v50 = (v41 - v39) >> 2;
          if (v50 > v48) {
            unint64_t v48 = v50;
          }
          if (v49 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v51 = v48;
          }
          if (v51)
          {
            if (v51 >> 61) {
              goto LABEL_148;
            }
            unsigned int v52 = (char *)operator new(8 * v51);
            int64_t v43 = *v38;
          }
          else
          {
            unsigned int v52 = 0;
          }
          uint64_t v59 = (uint64_t ****)&v52[8 * v47];
          *uint64_t v59 = v43;
          int v45 = (char *)(v59 + 1);
          while (v40 != (uint64_t ****)v39)
          {
            uint64_t v60 = *--v40;
            *--uint64_t v59 = v60;
          }
          uint64_t v41 = &v52[8 * v51];
          if (v39)
          {
            int v61 = &v52[8 * v51];
            operator delete(v39);
            uint64_t v41 = v61;
          }
          uint64_t v39 = (char *)v59;
          unint64_t v37 = v90;
        }
        else
        {
          *uint64_t v40 = v43;
          int v45 = (char *)(v40 + 1);
        }
        ++v38;
      }
      else
      {
        BOOL v46 = sub_1CC8FC6CC(v44, v43);
        uint64_t v41 = (char *)v42;
        if ((unint64_t)v40 >= v42)
        {
          uint64_t v53 = ((char *)v40 - v39) >> 3;
          unint64_t v54 = v53 + 1;
          if ((unint64_t)(v53 + 1) >> 61) {
            goto LABEL_147;
          }
          unint64_t v55 = v41 - v39;
          unint64_t v56 = (v41 - v39) >> 2;
          if (v56 > v54) {
            unint64_t v54 = v56;
          }
          if (v55 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v57 = v54;
          }
          if (v57)
          {
            if (v57 >> 61) {
LABEL_148:
            }
              sub_1CB833614();
            unsigned int v58 = (char *)operator new(8 * v57);
            int v44 = *v35;
          }
          else
          {
            unsigned int v58 = 0;
          }
          uint64_t v62 = (uint64_t ****)&v58[8 * v53];
          *uint64_t v62 = v44;
          int v45 = (char *)(v62 + 1);
          while (v40 != (uint64_t ****)v39)
          {
            unsigned int v63 = *--v40;
            *--uint64_t v62 = v63;
          }
          uint64_t v41 = &v58[8 * v57];
          if (v39)
          {
            uint64_t v64 = &v58[8 * v57];
            operator delete(v39);
            uint64_t v41 = v64;
          }
          uint64_t v39 = (char *)v62;
          uint64_t v6 = v89;
          unint64_t v37 = v90;
        }
        else
        {
          *uint64_t v40 = v44;
          int v45 = (char *)(v40 + 1);
        }
        v38 += !v46;
        ++v35;
      }
      uint64_t v40 = (uint64_t ****)v45;
      if (v35 == v36) {
        goto LABEL_84;
      }
    }
    if (v35 == v36)
    {
      int v65 = (char *)v40;
    }
    else
    {
      do
      {
        if (v40 >= (uint64_t ****)v41)
        {
          uint64_t v75 = ((char *)v40 - v39) >> 3;
          unint64_t v76 = v75 + 1;
          if ((unint64_t)(v75 + 1) >> 61) {
            goto LABEL_147;
          }
          unint64_t v77 = v41 - v39;
          unint64_t v78 = (v41 - v39) >> 2;
          if (v78 > v76) {
            unint64_t v76 = v78;
          }
          if (v77 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v79 = v76;
          }
          if (v79)
          {
            if (v79 >> 61) {
              goto LABEL_148;
            }
            int v80 = (char *)operator new(8 * v79);
          }
          else
          {
            int v80 = 0;
          }
          uint64_t v81 = (uint64_t ****)&v80[8 * v75];
          *uint64_t v81 = *v35;
          int v65 = (char *)(v81 + 1);
          while (v40 != (uint64_t ****)v39)
          {
            uint64_t v82 = *--v40;
            *--uint64_t v81 = v82;
          }
          uint64_t v41 = &v80[8 * v79];
          if (v39)
          {
            uint64_t v83 = &v80[8 * v79];
            operator delete(v39);
            uint64_t v41 = v83;
          }
          uint64_t v39 = (char *)v81;
        }
        else
        {
          *uint64_t v40 = *v35;
          int v65 = (char *)(v40 + 1);
        }
        ++v35;
        uint64_t v40 = (uint64_t ****)v65;
      }
      while (v35 != v36);
    }
  }
  if (dword_1EBCDE468 >= (unint64_t)((v65 - v39) >> 3))
  {
    *(_DWORD *)uint64_t v88 = 1;
    *(void *)(v88 + 8) = v39;
    *(void *)(v88 + 16) = v65;
    *(void *)(v88 + 24) = v41;
  }
  else
  {
    *(_DWORD *)uint64_t v88 = *(_DWORD *)(v6 + 40);
    *(void *)(v88 + 16) = 0;
    *(void *)(v88 + 24) = 0;
    *(void *)(v88 + 8) = 0;
    sub_1CBFCBA2C((void *)(v88 + 8), *(const void **)(v6 + 48), *(void *)(v6 + 56), (uint64_t)(*(void *)(v6 + 56) - *(void *)(v6 + 48)) >> 3);
    if (v39)
    {
      operator delete(v39);
    }
  }
}

void sub_1CC8FB7B0(uint64_t a1, _DWORD *a2, uint64_t a3, void *a4)
{
  unsigned int v8 = *((unsigned __int8 *)a2 + 16);
  if (v8 <= 0x3C)
  {
    if (v8 != 29)
    {
      if (v8 != 33)
      {
        if (v8 == 60)
        {
          unint64_t v69 = a2;
          uint64_t v9 = *((void *)a2 - 4);
          if (v9 && *(unsigned char *)(v9 + 16) == 3)
          {
            unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF9 | 4;
            sub_1CC8FC920((uint64_t)v76, a4, (unint64_t)a2);
            size_t v11 = a4;
            unint64_t v12 = v10;
            goto LABEL_75;
          }
          int v28 = *(_DWORD *)(a1 + 40);
          int64_t v43 = *(unsigned char **)(a1 + 48);
          unint64_t v42 = *(unsigned char **)(a1 + 56);
          int64_t v44 = v42 - v43;
          if (v42 == v43)
          {
            char v32 = 0;
            size_t v33 = 0;
            goto LABEL_83;
          }
          if ((v44 & 0x8000000000000000) == 0)
          {
            char v32 = (char *)operator new(v42 - v43);
            size_t v33 = &v32[8 * (v44 >> 3)];
            memmove(v32, v43, v44);
LABEL_83:
            unint64_t v49 = (unint64_t *)&v69;
            goto LABEL_84;
          }
LABEL_119:
          abort();
        }
        goto LABEL_33;
      }
      goto LABEL_11;
    }
    uint64_t v22 = *(void *)(*((void *)a2 + 5) + 56);
    if (*(unsigned char *)(**(void **)(*(void *)(v22 + 24) + 16) + 8) == 7) {
      return;
    }
    uint64_t v23 = a2[5] & 0x7FFFFFF;
    if (v23) {
      unint64_t v24 = *(void *)&a2[-8 * v23] & 0xFFFFFFFFFFFFFFF9;
    }
    else {
      unint64_t v24 = 0;
    }
    unint64_t v27 = v22 & 0xFFFFFFFFFFFFFFF9 | 2;
    goto LABEL_73;
  }
  if (v8 == 61)
  {
    uint64_t v25 = *((void *)a2 - 4);
    if (v25) {
      BOOL v26 = *(unsigned char *)(v25 + 16) == 3;
    }
    else {
      BOOL v26 = 0;
    }
    if (!v26) {
      return;
    }
    unint64_t v24 = *((void *)a2 - 8) & 0xFFFFFFFFFFFFFFF9;
    unint64_t v27 = v25 & 0xFFFFFFFFFFFFFFF9 | 4;
LABEL_73:
    unint64_t v69 = (_DWORD *)v27;
    goto LABEL_74;
  }
  if (v8 == 85)
  {
    unint64_t v69 = a2;
    unint64_t v24 = *((void *)a2 - 8) & 0xFFFFFFFFFFFFFFF9;
    unint64_t v27 = *((void *)a2 - 4) & 0xFFFFFFFFFFFFFFF9;
LABEL_74:
    sub_1CC8FC920((uint64_t)v76, a4, v24);
    size_t v11 = a4;
    unint64_t v12 = v27;
LABEL_75:
    sub_1CC8FC920((uint64_t)v73, v11, v12);
    (*(void (**)(_DWORD **__return_ptr, uint64_t, char *, char *))(*(void *)a1 + 40))(&v79, a1, v76, v73);
    uint64_t v50 = sub_1CC8FC838(a3, (unint64_t *)&v69);
    *(_DWORD *)uint64_t v50 = v79;
    unint64_t v51 = *(void **)(v50 + 8);
    if (v51)
    {
      *(void *)(v50 + 16) = v51;
      operator delete(v51);
      *(void *)(v50 + 8) = 0;
      *(void *)(v50 + 16) = 0;
      *(void *)(v50 + 24) = 0;
    }
    *(_OWORD *)(v50 + 8) = v80;
    *(void *)(v50 + 24) = v81;
    long long v80 = 0uLL;
    uint64_t v81 = 0;
    if (__p)
    {
      uint64_t v75 = __p;
      operator delete(__p);
    }
    unsigned int v52 = v77;
    if (v77)
    {
      unint64_t v78 = v77;
LABEL_81:
      operator delete(v52);
      return;
    }
    return;
  }
  if (v8 != 84)
  {
LABEL_33:
    if (!*((void *)a2 + 1)) {
      return;
    }
    unint64_t v79 = a2;
    int v28 = *(_DWORD *)(a1 + 40);
    uint64_t v30 = *(unsigned char **)(a1 + 48);
    uint64_t v29 = *(unsigned char **)(a1 + 56);
    int64_t v31 = v29 - v30;
    if (v29 == v30)
    {
      char v32 = 0;
      size_t v33 = 0;
    }
    else
    {
      if (v31 < 0) {
        goto LABEL_119;
      }
      char v32 = (char *)operator new(v29 - v30);
      size_t v33 = &v32[8 * (v31 >> 3)];
      memmove(v32, v30, v31);
    }
    unint64_t v49 = (unint64_t *)&v79;
    goto LABEL_84;
  }
LABEL_11:
  uint64_t v13 = *((void *)a2 - 4);
  if (!v13 || *(unsigned char *)(v13 + 16) || *(void *)(v13 + 24) != *((void *)a2 + 9))
  {
    int v72 = a2;
    uint64_t v16 = *(void *)(a1 + 104);
    uint64_t v15 = *(void *)(a1 + 112);
    size_t v14 = (llvm::SmallPtrSetImplBase *)(a1 + 104);
    uint64_t v17 = *(unsigned int *)(a1 + 124);
    if (v15 == v16)
    {
      if (v17)
      {
        BOOL v18 = 0;
        uint64_t v19 = 8 * v17;
        size_t v20 = *(void **)(a1 + 112);
        while ((_DWORD *)*v20 != a2)
        {
          if (*v20 == -2) {
            BOOL v18 = v20;
          }
          ++v20;
          v19 -= 8;
          if (!v19)
          {
            if (!v18) {
              goto LABEL_22;
            }
            *BOOL v18 = a2;
            --*(_DWORD *)(a1 + 128);
            goto LABEL_63;
          }
        }
        goto LABEL_63;
      }
LABEL_22:
      unsigned int v21 = *(_DWORD *)(a1 + 120);
      if (v17 < v21)
      {
        *(_DWORD *)(a1 + 124) = v17 + 1;
        *(void *)(v15 + 8 * v17) = a2;
LABEL_63:
        if (*(unsigned char *)(*(void *)a2 + 8) == 7) {
          return;
        }
        int v28 = *(_DWORD *)(a1 + 40);
        uint64_t v47 = *(unsigned char **)(a1 + 48);
        BOOL v46 = *(unsigned char **)(a1 + 56);
        int64_t v48 = v46 - v47;
        if (v46 == v47)
        {
          char v32 = 0;
          size_t v33 = 0;
        }
        else
        {
          if (v48 < 0) {
            goto LABEL_119;
          }
          char v32 = (char *)operator new(v46 - v47);
          size_t v33 = &v32[8 * (v48 >> 3)];
          memmove(v32, v47, v48);
        }
        unint64_t v49 = (unint64_t *)&v72;
LABEL_84:
        uint64_t v53 = sub_1CC8FC838(a3, v49);
        *(_DWORD *)uint64_t v53 = v28;
        unint64_t v54 = *(void **)(v53 + 8);
        if (v54)
        {
          *(void *)(v53 + 16) = v54;
          operator delete(v54);
        }
        *(void *)(v53 + 8) = v32;
        *(void *)(v53 + 16) = v33;
        *(void *)(v53 + 24) = v33;
        return;
      }
    }
    else
    {
      unsigned int v21 = *(_DWORD *)(a1 + 120);
    }
    if (3 * v21 <= 4 * ((int)v17 - *(_DWORD *)(a1 + 128)))
    {
      if (v21 >= 0x40) {
        v21 *= 2;
      }
      else {
        unsigned int v21 = 128;
      }
    }
    else if (v21 - v17 >= v21 >> 3)
    {
      goto LABEL_41;
    }
    llvm::SmallPtrSetImplBase::Grow(v14, v21);
    unsigned int v21 = *(_DWORD *)(a1 + 120);
    uint64_t v15 = *(void *)(a1 + 112);
LABEL_41:
    unsigned int v34 = v21 - 1;
    unsigned int v35 = (v21 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unint64_t v36 = (void *)(v15 + 8 * v35);
    unint64_t v37 = (_DWORD *)*v36;
    if (*v36 == -1)
    {
      unsigned int v38 = 0;
LABEL_56:
      if (v38) {
        int v45 = v38;
      }
      else {
        int v45 = v36;
      }
      if ((_DWORD *)*v45 != a2)
      {
        if (*v45 == -2) {
          --*(_DWORD *)(a1 + 128);
        }
        else {
          ++*(_DWORD *)(a1 + 124);
        }
        *int v45 = a2;
      }
    }
    else
    {
      unsigned int v38 = 0;
      int v39 = 1;
      while (v37 != a2)
      {
        if (v38) {
          BOOL v40 = 0;
        }
        else {
          BOOL v40 = v37 == (_DWORD *)-2;
        }
        if (v40) {
          unsigned int v38 = v36;
        }
        unsigned int v41 = v35 + v39++;
        unsigned int v35 = v41 & v34;
        unint64_t v36 = (void *)(v15 + 8 * (v41 & v34));
        unint64_t v37 = (_DWORD *)*v36;
        if (*v36 == -1) {
          goto LABEL_56;
        }
      }
    }
    goto LABEL_63;
  }
  int v72 = a2;
  if (!llvm::canTrackReturnsInterprocedurally((llvm *)v13, (llvm::Function *)a2)) {
    goto LABEL_63;
  }
  uint64_t v55 = *(void *)(v13 + 80);
  if (v55) {
    uint64_t v56 = v55 - 24;
  }
  else {
    uint64_t v56 = 0;
  }
  sub_1CC8FAC98((uint64_t)a4, v56);
  if ((*(_WORD *)(v13 + 18) & 1) == 0)
  {
    uint64_t v57 = *(void *)(v13 + 88);
LABEL_94:
    uint64_t v58 = v57;
    goto LABEL_95;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)v13);
  uint64_t v57 = *(void *)(v13 + 88);
  if ((*(_WORD *)(v13 + 18) & 1) == 0) {
    goto LABEL_94;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)v13);
  uint64_t v58 = *(void *)(v13 + 88);
LABEL_95:
  uint64_t v65 = v58 + 40 * *(void *)(v13 + 96);
  if (v57 != v65)
  {
    uint64_t v59 = v57;
    do
    {
      unint64_t v69 = (_DWORD *)(v59 & 0xFFFFFFFFFFFFFFF9);
      unint64_t v60 = *(void *)&a2[8 * *(unsigned int *)(v57 + 32) + -8 * (a2[5] & 0x7FFFFFF)] & 0xFFFFFFFFFFFFFFF9;
      sub_1CC8FC920((uint64_t)v76, a4, v59 & 0xFFFFFFFFFFFFFFF9);
      sub_1CC8FC920((uint64_t)v73, a4, v60);
      (*(void (**)(_DWORD **__return_ptr, uint64_t, char *, char *))(*(void *)a1 + 40))(&v79, a1, v76, v73);
      uint64_t v61 = sub_1CC8FC838(a3, (unint64_t *)&v69);
      *(_DWORD *)uint64_t v61 = v79;
      uint64_t v62 = *(void **)(v61 + 8);
      if (v62)
      {
        *(void *)(v61 + 16) = v62;
        operator delete(v62);
        *(void *)(v61 + 8) = 0;
        *(void *)(v61 + 16) = 0;
        *(void *)(v61 + 24) = 0;
      }
      *(_OWORD *)(v61 + 8) = v80;
      *(void *)(v61 + 24) = v81;
      long long v80 = 0uLL;
      uint64_t v81 = 0;
      if (__p)
      {
        uint64_t v75 = __p;
        operator delete(__p);
      }
      if (v77)
      {
        unint64_t v78 = v77;
        operator delete(v77);
      }
      v57 += 40;
      v59 += 40;
    }
    while (v57 != v65);
  }
  if (*(unsigned char *)(*(void *)a2 + 8) != 7)
  {
    sub_1CC8FC920((uint64_t)&v69, a4, (unint64_t)a2);
    sub_1CC8FC920((uint64_t)v66, a4, v13 & 0xFFFFFFFFFFFFFFF9 | 2);
    (*(void (**)(_DWORD **__return_ptr, uint64_t, _DWORD **, char *))(*(void *)a1 + 40))(&v79, a1, &v69, v66);
    uint64_t v63 = sub_1CC8FC838(a3, (unint64_t *)&v72);
    *(_DWORD *)uint64_t v63 = v79;
    uint64_t v64 = *(void **)(v63 + 8);
    if (v64)
    {
      *(void *)(v63 + 16) = v64;
      operator delete(v64);
      *(void *)(v63 + 8) = 0;
      *(void *)(v63 + 16) = 0;
      *(void *)(v63 + 24) = 0;
    }
    *(_OWORD *)(v63 + 8) = v80;
    *(void *)(v63 + 24) = v81;
    long long v80 = 0uLL;
    uint64_t v81 = 0;
    if (v67)
    {
      unint64_t v68 = v67;
      operator delete(v67);
    }
    unsigned int v52 = v70;
    if (v70)
    {
      uint64_t v71 = v70;
      goto LABEL_81;
    }
  }
}

void sub_1CC8FBED0(uint64_t a1, uint64_t a2, llvm::raw_ostream *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v8 = *(unsigned char **)(a1 + 16);
  uint64_t v7 = *(unsigned char **)(a1 + 24);
  int64_t v9 = v7 - v8;
  if (v7 == v8)
  {
    unint64_t v10 = 0;
    size_t v11 = 0;
  }
  else
  {
    if (v9 < 0) {
      goto LABEL_50;
    }
    unint64_t v10 = (char *)operator new(v7 - v8);
    memmove(v10, v8, v9);
    size_t v11 = &v10[8 * (v9 >> 3)];
  }
  if (*(_DWORD *)a2 != v6
    || (unint64_t v12 = *(const void **)(a2 + 8), v13 = *(void *)(a2 + 16) - (void)v12, v13 != v11 - v10))
  {
    BOOL v14 = 0;
    if (!v10) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  BOOL v14 = memcmp(v12, v10, v13) == 0;
  if (v10) {
LABEL_10:
  }
    operator delete(v10);
LABEL_11:
  if (!v14)
  {
    int v17 = *(_DWORD *)(a1 + 40);
    uint64_t v19 = *(unsigned char **)(a1 + 48);
    BOOL v18 = *(unsigned char **)(a1 + 56);
    int64_t v20 = v18 - v19;
    if (v18 == v19)
    {
      uint64_t v22 = 0;
      unsigned int v21 = 0;
    }
    else
    {
      if (v20 < 0) {
        goto LABEL_50;
      }
      unsigned int v21 = (char *)operator new(v18 - v19);
      memmove(v21, v19, v20);
      uint64_t v22 = &v21[8 * (v20 >> 3)];
    }
    if (*(_DWORD *)a2 == v17
      && (v23 = *(const void **)(a2 + 8), size_t v24 = *(void *)(a2 + 16) - (void)v23, v24 == v22 - v21))
    {
      BOOL v25 = memcmp(v23, v21, v24) == 0;
      if (!v21) {
        goto LABEL_24;
      }
    }
    else
    {
      BOOL v25 = 0;
      if (!v21)
      {
LABEL_24:
        if (v25)
        {
          uint64_t v15 = *((void *)a3 + 4);
          if ((unint64_t)(*((void *)a3 + 3) - v15) <= 0xA)
          {
            uint64_t v16 = "Overdefined";
            goto LABEL_42;
          }
          int v36 = 1684369001;
          unint64_t v37 = "Overdefined";
LABEL_49:
          *(_DWORD *)(v15 + 7) = v36;
          *(void *)uint64_t v15 = *(void *)v37;
          *((void *)a3 + 4) += 11;
          return;
        }
        int v26 = *(_DWORD *)(a1 + 72);
        int v28 = *(unsigned char **)(a1 + 80);
        unint64_t v27 = *(unsigned char **)(a1 + 88);
        int64_t v29 = v27 - v28;
        if (v27 == v28)
        {
          int64_t v31 = 0;
          uint64_t v30 = 0;
          goto LABEL_31;
        }
        if ((v29 & 0x8000000000000000) == 0)
        {
          uint64_t v30 = (char *)operator new(v27 - v28);
          memmove(v30, v28, v29);
          int64_t v31 = &v30[8 * (v29 >> 3)];
LABEL_31:
          if (*(_DWORD *)a2 == v26
            && (char v32 = *(const void **)(a2 + 8), v33 = *(void *)(a2 + 16) - (void)v32, v33 == v31 - v30))
          {
            BOOL v34 = memcmp(v32, v30, v33) == 0;
            if (!v30)
            {
LABEL_37:
              uint64_t v15 = *((void *)a3 + 4);
              unint64_t v35 = *((void *)a3 + 3) - v15;
              if (v34)
              {
                if (v35 <= 0xA)
                {
                  uint64_t v16 = "Untracked  ";
                  goto LABEL_42;
                }
                int v36 = 538993765;
                unint64_t v37 = "Untracked  ";
              }
              else
              {
                if (v35 <= 0xA)
                {
                  uint64_t v16 = "FunctionSet";
                  goto LABEL_42;
                }
                int v36 = 1952797550;
                unint64_t v37 = "FunctionSet";
              }
              goto LABEL_49;
            }
          }
          else
          {
            BOOL v34 = 0;
            if (!v30) {
              goto LABEL_37;
            }
          }
          operator delete(v30);
          goto LABEL_37;
        }
LABEL_50:
        abort();
      }
    }
    operator delete(v21);
    goto LABEL_24;
  }
  uint64_t v15 = *((void *)a3 + 4);
  if ((unint64_t)(*((void *)a3 + 3) - v15) > 0xA)
  {
    int v36 = 538993765;
    unint64_t v37 = "Undefined  ";
    goto LABEL_49;
  }
  uint64_t v16 = "Undefined  ";
LABEL_42:

  llvm::raw_ostream::write(a3, v16, 0xBuLL);
}

void sub_1CC8FC1AC(int a1, uint64_t a2, llvm::raw_ostream *this)
{
  unsigned int v5 = (a2 >> 1) & 3;
  if (v5 == 2)
  {
    uint64_t v6 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v6) <= 5)
    {
      uint64_t v7 = "<mem> ";
      goto LABEL_10;
    }
    *(_WORD *)(v6 + 4) = 8254;
    int v22 = 1835363644;
  }
  else if (v5 == 1)
  {
    uint64_t v6 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v6) <= 5)
    {
      uint64_t v7 = "<ret> ";
      goto LABEL_10;
    }
    *(_WORD *)(v6 + 4) = 8254;
    int v22 = 1952805436;
  }
  else
  {
    if (v5) {
      goto LABEL_11;
    }
    uint64_t v6 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v6) <= 5)
    {
      uint64_t v7 = "<reg> ";
LABEL_10:
      llvm::raw_ostream::write(this, v7, 6uLL);
      goto LABEL_11;
    }
    *(_WORD *)(v6 + 4) = 8254;
    int v22 = 1734701628;
  }
  *(_DWORD *)uint64_t v6 = v22;
  *((void *)this + 4) += 6;
LABEL_11:
  unsigned int v8 = (llvm::Value *)(a2 & 0xFFFFFFFFFFFFFFF8);
  if (!*(unsigned char *)((a2 & 0xFFFFFFFFFFFFFFF8) + 16))
  {
    if ((*((unsigned char *)v8 + 23) & 0x10) == 0) {
      return;
    }
    uint64_t v9 = ***(void ***)v8;
    uint64_t v10 = *(void *)(v9 + 152);
    uint64_t v11 = *(unsigned int *)(v9 + 168);
    if (v11)
    {
      LODWORD(v12) = (v11 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      size_t v13 = (llvm::Value **)(v10 + 16 * v12);
      BOOL v14 = *v13;
      if (*v13 == v8) {
        goto LABEL_20;
      }
      int v15 = 1;
      while (v14 != (llvm::Value *)-4096)
      {
        int v16 = v12 + v15++;
        uint64_t v12 = v16 & (v11 - 1);
        BOOL v14 = *(llvm::Value **)(v10 + 16 * v12);
        if (v14 == v8)
        {
          size_t v13 = (llvm::Value **)(v10 + 16 * v12);
          goto LABEL_20;
        }
      }
    }
    size_t v13 = (llvm::Value **)(v10 + 16 * v11);
LABEL_20:
    int v17 = (size_t *)v13[1];
    size_t v20 = *v17;
    BOOL v18 = v17 + 2;
    size_t v19 = v20;
    unsigned int v21 = (void *)*((void *)this + 4);
    if (v20 <= *((void *)this + 3) - (void)v21)
    {
      if (v19)
      {
        memcpy(v21, v18, v19);
        *((void *)this + 4) += v19;
      }
    }
    else
    {
      llvm::raw_ostream::write(this, (const char *)v18, v19);
    }
    return;
  }

  llvm::Value::print(v8, this, 0);
}

uint64_t sub_1CC8FC388()
{
  return 0;
}

void *sub_1CC8FC398@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 40);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  return sub_1CBFCBA2C((void *)(a2 + 8), *(const void **)(a1 + 48), *(void *)(a1 + 56), (uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 3);
}

void *sub_1CC8FC3BC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 40);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  return sub_1CBFCBA2C((void *)(a2 + 8), *(const void **)(a1 + 48), *(void *)(a1 + 56), (uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 3);
}

llvm::raw_ostream *sub_1CC8FC3E0(llvm::raw_ostream *result, int *a2, llvm::raw_ostream *this)
{
  unsigned int v5 = result;
  int v6 = *a2;
  if (*a2 == *((_DWORD *)result + 2))
  {
    unint64_t result = (llvm::raw_ostream *)*((void *)a2 + 1);
    size_t v7 = *((void *)a2 + 2) - (void)result;
    unsigned int v8 = (const void *)*((void *)v5 + 2);
    if (v7 == *((void *)v5 + 3) - (void)v8)
    {
      unint64_t result = (llvm::raw_ostream *)memcmp(result, v8, v7);
      if (!result)
      {
        uint64_t v17 = *((void *)this + 4);
        if ((unint64_t)(*((void *)this + 3) - v17) <= 8)
        {
          BOOL v14 = "undefined";
LABEL_21:
          int v15 = this;
          size_t v16 = 9;
          goto LABEL_12;
        }
        size_t v20 = "undefined";
LABEL_27:
        *(unsigned char *)(v17 + 8) = 100;
        *(void *)uint64_t v17 = *(void *)v20;
        uint64_t v19 = *((void *)this + 4) + 9;
        goto LABEL_23;
      }
    }
  }
  if (v6 == *((_DWORD *)v5 + 10))
  {
    unint64_t result = (llvm::raw_ostream *)*((void *)a2 + 1);
    size_t v9 = *((void *)a2 + 2) - (void)result;
    uint64_t v10 = (const void *)*((void *)v5 + 6);
    if (v9 == *((void *)v5 + 7) - (void)v10)
    {
      unint64_t result = (llvm::raw_ostream *)memcmp(result, v10, v9);
      if (!result)
      {
        uint64_t v18 = *((void *)this + 4);
        if ((unint64_t)(*((void *)this + 3) - v18) <= 0xA)
        {
          BOOL v14 = "overdefined";
          int v15 = this;
          size_t v16 = 11;
          goto LABEL_12;
        }
        *(_DWORD *)(v18 + 7) = 1684369001;
        *(void *)uint64_t v18 = *(void *)"overdefined";
        uint64_t v19 = *((void *)this + 4) + 11;
LABEL_23:
        *((void *)this + 4) = v19;
        return result;
      }
    }
  }
  if (v6 == *((_DWORD *)v5 + 18))
  {
    unint64_t result = (llvm::raw_ostream *)*((void *)a2 + 1);
    size_t v11 = *((void *)a2 + 2) - (void)result;
    uint64_t v12 = (const void *)*((void *)v5 + 10);
    if (v11 == *((void *)v5 + 11) - (void)v12)
    {
      unint64_t result = (llvm::raw_ostream *)memcmp(result, v12, v11);
      if (!result)
      {
        uint64_t v17 = *((void *)this + 4);
        if ((unint64_t)(*((void *)this + 3) - v17) <= 8)
        {
          BOOL v14 = "untracked";
          goto LABEL_21;
        }
        size_t v20 = "untracked";
        goto LABEL_27;
      }
    }
  }
  size_t v13 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v13 > 0x14uLL)
  {
    qmemcpy(v13, "unknown lattice value", 21);
    uint64_t v19 = *((void *)this + 4) + 21;
    goto LABEL_23;
  }
  BOOL v14 = "unknown lattice value";
  int v15 = this;
  size_t v16 = 21;
LABEL_12:

  return llvm::raw_ostream::write(v15, v14, v16);
}

double sub_1CC8FC5BC(int a1, int a2, llvm::raw_ostream *this)
{
  uint64_t v3 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v3) > 0x12)
  {
    *(_DWORD *)(v3 + 15) = 2036689696;
    double result = *(double *)"unknown lattice key";
    *(_OWORD *)uint64_t v3 = *(_OWORD *)"unknown lattice key";
    *((void *)this + 4) += 19;
  }
  else
  {
    llvm::raw_ostream::write(this, "unknown lattice key", 0x13uLL);
  }
  return result;
}

void *sub_1CC8FC60C(void *result, uint64_t a2, llvm::Value *this)
{
  uint64_t v3 = result;
  if (*((unsigned char *)this + 16) == 19)
  {
    *(_DWORD *)double result = 1;
    result[2] = 0;
    result[3] = 0;
    result[1] = 0;
  }
  else
  {
    unsigned int v5 = llvm::Value::stripPointerCasts(this);
    if (!v5 || (int v6 = v5, *((unsigned char *)v5 + 16)))
    {
      *(_DWORD *)uint64_t v3 = *(_DWORD *)(a2 + 40);
      v3[2] = 0;
      v3[3] = 0;
      v3[1] = 0;
      unsigned int v8 = *(const void **)(a2 + 48);
      uint64_t v9 = *(void *)(a2 + 56);
      return sub_1CBFCBA2C(v3 + 1, v8, v9, (v9 - (uint64_t)v8) >> 3);
    }
    else
    {
      size_t v7 = operator new(8uLL);
      v3[1] = v7;
      *size_t v7 = v6;
      double result = v7 + 1;
      *(_DWORD *)uint64_t v3 = 1;
      v3[2] = result;
      v3[3] = result;
    }
  }
  return result;
}

BOOL sub_1CC8FC6CC(uint64_t ***a1, uint64_t ***a2)
{
  if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
  {
    uint64_t v2 = ***a1;
    uint64_t v3 = *(void *)(v2 + 152);
    uint64_t v4 = *(unsigned int *)(v2 + 168);
    if (v4)
    {
      LODWORD(v5) = (v4 - 1) & ((a1 >> 4) ^ (a1 >> 9));
      int v6 = (uint64_t ****)(v3 + 16 * v5);
      size_t v7 = *v6;
      if (*v6 == a1)
      {
LABEL_9:
        uint64_t v10 = v6[1];
        size_t v13 = (size_t)*v10;
        size_t v11 = (char *)(v10 + 2);
        size_t v12 = v13;
        goto LABEL_10;
      }
      int v8 = 1;
      while (v7 != (uint64_t ***)-4096)
      {
        int v9 = v5 + v8++;
        uint64_t v5 = v9 & (v4 - 1);
        size_t v7 = *(uint64_t ****)(v3 + 16 * v5);
        if (v7 == a1)
        {
          int v6 = (uint64_t ****)(v3 + 16 * v5);
          goto LABEL_9;
        }
      }
    }
    int v6 = (uint64_t ****)(v3 + 16 * v4);
    goto LABEL_9;
  }
  size_t v12 = 0;
  size_t v11 = &byte_1CFBCE98E;
LABEL_10:
  if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
  {
    uint64_t v14 = ***a2;
    uint64_t v15 = *(void *)(v14 + 152);
    uint64_t v16 = *(unsigned int *)(v14 + 168);
    if (v16)
    {
      LODWORD(v17) = (v16 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      uint64_t v18 = (uint64_t ****)(v15 + 16 * v17);
      uint64_t v19 = *v18;
      if (*v18 == a2)
      {
LABEL_18:
        int v22 = v18[1];
        size_t v25 = (size_t)*v22;
        uint64_t v23 = (char *)(v22 + 2);
        size_t v24 = v25;
        goto LABEL_19;
      }
      int v20 = 1;
      while (v19 != (uint64_t ***)-4096)
      {
        int v21 = v17 + v20++;
        uint64_t v17 = v21 & (v16 - 1);
        uint64_t v19 = *(uint64_t ****)(v15 + 16 * v17);
        if (v19 == a2)
        {
          uint64_t v18 = (uint64_t ****)(v15 + 16 * v17);
          goto LABEL_18;
        }
      }
    }
    uint64_t v18 = (uint64_t ****)(v15 + 16 * v16);
    goto LABEL_18;
  }
  size_t v24 = 0;
  uint64_t v23 = &byte_1CFBCE98E;
LABEL_19:
  if (v24 >= v12) {
    size_t v26 = v12;
  }
  else {
    size_t v26 = v24;
  }
  if (v26 && (int v27 = memcmp(v11, v23, v26)) != 0)
  {
    int v28 = (v27 >> 31) | 1;
  }
  else
  {
    if (v12 < v24) {
      int v28 = -1;
    }
    else {
      int v28 = 1;
    }
    if (v12 == v24) {
      int v28 = 0;
    }
  }
  return v28 == -1;
}

uint64_t sub_1CC8FC838(uint64_t a1, unint64_t *a2)
{
  uint64_t v9 = 0;
  char v4 = sub_1CC8FCBA4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v9);
  uint64_t v5 = v9;
  if (v4) {
    return v5 + 8;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CC8FCC3C(a1, v7);
    uint64_t v9 = 0;
    sub_1CC8FCBA4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v9);
    uint64_t v5 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)v5 != -2) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)uint64_t v5 = *a2;
  *(_DWORD *)(v5 + 8) = 0;
  *(void *)(v5 + 24) = 0;
  *(void *)(v5 + 32) = 0;
  *(void *)(v5 + 16) = 0;
  return v5 + 8;
}

void sub_1CC8FC920(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v28 = a3;
  uint64_t v7 = (uint64_t)(a2 + 1);
  uint64_t v6 = a2[1];
  uint64_t v25 = 0;
  int v8 = sub_1CC8FCBA4(v6, *((_DWORD *)a2 + 6), a3, &v25);
  uint64_t v9 = v25;
  if (v8) {
    BOOL v10 = v25 == *(void *)v7 + 40 * *(unsigned int *)(v7 + 16);
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v25 + 8);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 8) = 0;
    size_t v12 = (void *)(a1 + 8);
    size_t v13 = *(const void **)(v9 + 16);
    uint64_t v14 = *(void *)(v9 + 24);
LABEL_8:
    sub_1CBFCBA2C(v12, v13, v14, (v14 - (uint64_t)v13) >> 3);
    return;
  }
  if ((*(unsigned int (**)(void, unint64_t))(*(void *)*a2 + 16))(*a2, a3))
  {
    uint64_t v11 = *a2;
    *(_DWORD *)a1 = *(_DWORD *)(*a2 + 72);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 8) = 0;
    size_t v12 = (void *)(a1 + 8);
    size_t v13 = *(const void **)(v11 + 80);
    uint64_t v14 = *(void *)(v11 + 88);
    goto LABEL_8;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 24))(&v25);
  int v15 = *(_DWORD *)(*a2 + 72);
  uint64_t v17 = *(unsigned char **)(*a2 + 80);
  uint64_t v16 = *(unsigned char **)(*a2 + 88);
  int64_t v18 = v16 - v17;
  if (v16 == v17)
  {
    uint64_t v19 = 0;
    int v20 = 0;
  }
  else
  {
    if (v18 < 0) {
      abort();
    }
    uint64_t v19 = (char *)operator new(v16 - v17);
    memmove(v19, v17, v18);
    int v20 = &v19[8 * (v18 >> 3)];
  }
  if (v25 != v15 || (char *)__p[1] - (char *)__p[0] != v20 - v19)
  {
    BOOL v21 = 0;
    if (!v19) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  BOOL v21 = memcmp(__p[0], v19, (char *)__p[1] - (char *)__p[0]) == 0;
  if (v19) {
LABEL_20:
  }
    operator delete(v19);
LABEL_21:
  if (v21)
  {
    *(_DWORD *)a1 = v25;
    *(_OWORD *)(a1 + 8) = *(_OWORD *)__p;
    *(void *)(a1 + 24) = v27;
  }
  else
  {
    uint64_t v22 = sub_1CC8FC838(v7, &v28);
    int v23 = v25;
    *(_DWORD *)uint64_t v22 = v25;
    size_t v24 = *(void **)(v22 + 8);
    if (v24)
    {
      *(void *)(v22 + 16) = v24;
      operator delete(v24);
      *(void *)(v22 + 8) = 0;
      *(void *)(v22 + 16) = 0;
      *(void *)(v22 + 24) = 0;
      int v23 = *(_DWORD *)v22;
    }
    *(_OWORD *)(v22 + 8) = *(_OWORD *)__p;
    *(void *)(v22 + 24) = v27;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v27 = 0;
    *(_DWORD *)a1 = v23;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 8) = 0;
    sub_1CBFCBA2C((void *)(a1 + 8), *(const void **)(v22 + 8), *(void *)(v22 + 16), (uint64_t)(*(void *)(v22 + 16) - *(void *)(v22 + 8)) >> 3);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

uint64_t sub_1CC8FCBA4(uint64_t a1, int a2, unint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (a2 - 1) & ((a3 >> 9) ^ a3);
    uint64_t v6 = (void *)(a1 + 40 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      BOOL v10 = 0;
      int v11 = 1;
      while (v7 != -2)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -16;
        }
        if (v12) {
          BOOL v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 40 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

void *sub_1CC8FCC3C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 40 * v10;
      do
      {
        *double result = -2;
        result += 5;
        v11 -= 40;
      }
      while (v11);
    }
    if (v3)
    {
      int v12 = 0;
      uint64_t v13 = 40 * v3;
      uint64_t v14 = v4 + 16;
      do
      {
        unint64_t v15 = *(void *)(v14 - 16);
        if (v15 != -16 && v15 != -2)
        {
          int v20 = 0;
          sub_1CC8FCBA4(*(void *)a1, *(_DWORD *)(a1 + 16), v15, &v20);
          uint64_t v17 = v20;
          *int v20 = v15;
          *((_DWORD *)v17 + 2) = *(_DWORD *)(v14 - 8);
          v17[3] = 0;
          v17[4] = 0;
          void v17[2] = 0;
          *((_OWORD *)v17 + 1) = *(_OWORD *)v14;
          v17[4] = *(void *)(v14 + 16);
          ++v12;
          *(void *)uint64_t v14 = 0;
          *(void *)(v14 + 8) = 0;
          *(void *)(v14 + 16) = 0;
          *(_DWORD *)(a1 + 8) = v12;
        }
        v14 += 40;
        v13 -= 40;
      }
      while (v13);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v18 = *(unsigned int *)(a1 + 16);
  if (v18)
  {
    uint64_t v19 = 40 * v18;
    do
    {
      *double result = -2;
      result += 5;
      v19 -= 40;
    }
    while (v19);
  }
  return result;
}

void sub_1CC8FCDBC(uint64_t a1, unint64_t a2)
{
  void v30[2] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a2 + 16) == 83)
  {
    sub_1CC8FD240((void *)a1, a2);
  }
  else
  {
    v25[0] = 0;
    v25[1] = 0;
    int v26 = 0;
    (*(void (**)(void))(**(void **)a1 + 48))();
    if (*(unsigned __int8 *)(a2 + 16) - 29 < 0xB)
    {
      unint64_t v28 = v30;
      long long v29 = xmmword_1CDB15990;
      sub_1CC8FDC18(a1, a2, &v28);
      uint64_t v4 = v29;
      if (v29)
      {
        uint64_t v5 = 0;
        uint64_t v6 = *(void *)(a2 + 40);
        do
        {
          if (*((unsigned char *)v28 + v5))
          {
            uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)a2, v5);
            *(void *)&long long v27 = v6;
            *((void *)&v27 + 1) = Successor;
            if (sub_1CD486140(a1 + 1248, (unint64_t *)&v27, &v27))
            {
              uint64_t v9 = *(void *)(a1 + 32);
              uint64_t v8 = *(void *)(a1 + 40);
              if (v8 == v9)
              {
                uint64_t v10 = *(unsigned int *)(a1 + 52);
                uint64_t v11 = (void *)(v8 + 8 * v10);
                if (v10)
                {
                  uint64_t v12 = 0;
                  uint64_t v13 = 8 * v10;
                  while (*(void *)(v8 + v12) != Successor)
                  {
                    v12 += 8;
                    if (v13 == v12) {
                      goto LABEL_30;
                    }
                  }
                  uint64_t v11 = (void *)(v8 + v12);
                }
LABEL_30:
                uint64_t v9 = *(void *)(a1 + 40);
              }
              else
              {
                uint64_t v14 = *(unsigned int *)(a1 + 48);
                int v15 = v14 - 1;
                unsigned int v16 = (v14 - 1) & ((Successor >> 4) ^ (Successor >> 9));
                uint64_t v11 = (void *)(v8 + 8 * v16);
                uint64_t v17 = *v11;
                if (*v11 == -1)
                {
                  uint64_t v18 = 0;
LABEL_43:
                  if (v18) {
                    uint64_t v11 = v18;
                  }
                  if (*v11 != Successor) {
                    uint64_t v11 = (void *)(v8 + 8 * v14);
                  }
                }
                else
                {
                  uint64_t v18 = 0;
                  int v19 = 1;
                  while (v17 != Successor)
                  {
                    if (v18) {
                      BOOL v20 = 0;
                    }
                    else {
                      BOOL v20 = v17 == -2;
                    }
                    if (v20) {
                      uint64_t v18 = v11;
                    }
                    unsigned int v21 = v16 + v19++;
                    unsigned int v16 = v21 & v15;
                    uint64_t v11 = (void *)(v8 + 8 * (v21 & v15));
                    uint64_t v17 = *v11;
                    if (*v11 == -1) {
                      goto LABEL_43;
                    }
                  }
                }
              }
              if (v8 == v9) {
                uint64_t v22 = (unsigned int *)(a1 + 52);
              }
              else {
                uint64_t v22 = (unsigned int *)(a1 + 48);
              }
              if (v11 == (void *)(v8 + 8 * *v22))
              {
                sub_1CC8FAC98(a1, Successor);
              }
              else
              {
                for (uint64_t i = *(void *)(Successor + 48); ; uint64_t i = *(void *)(i + 8))
                {
                  uint64_t v24 = i ? i - 24 : 0;
                  if (*(unsigned char *)(v24 + 16) != 83) {
                    break;
                  }
                  sub_1CC8FD240((void *)a1, i - 24);
                }
              }
            }
          }
          ++v5;
        }
        while (v5 != v4);
      }
      if (v28 != v30) {
        free(v28);
      }
    }
    sub_1CC8FDB9C(v25);
  }
}

void sub_1CC8FD240(void *a1, unint64_t a2)
{
  v100[2] = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(void))(*(void *)*a1 + 32))(*a1))
  {
    __int16 v98 = 0;
    *(void *)&long long v99 = 0;
    DWORD2(v99) = 0;
    (*(void (**)(void, unint64_t, char **, void *))(*(void *)*a1 + 48))(*a1, a2, &v98, a1);
    uint64_t v4 = &v98[40 * DWORD2(v99)];
    if (v99)
    {
      if (DWORD2(v99))
      {
        uint64_t v5 = 40 * DWORD2(v99);
        uint64_t v6 = v98;
        while (*(void *)v6 == -2 || *(void *)v6 == -16)
        {
          v6 += 40;
          v5 -= 40;
          if (!v5) {
            goto LABEL_11;
          }
        }
      }
      else
      {
        uint64_t v6 = v98;
      }
    }
    else
    {
LABEL_11:
      uint64_t v6 = &v98[40 * DWORD2(v99)];
    }
    unint64_t v28 = &v98[40 * DWORD2(v99)];
    if (v6 == v28)
    {
LABEL_65:
      sub_1CC8FDB9C((uint64_t *)&v98);
      return;
    }
    while (1)
    {
      int v29 = *(_DWORD *)(*a1 + 72);
      int64_t v31 = *(unsigned char **)(*a1 + 80);
      uint64_t v30 = *(unsigned char **)(*a1 + 88);
      int64_t v32 = v30 - v31;
      if (v30 == v31)
      {
        size_t v33 = 0;
        BOOL v34 = 0;
      }
      else
      {
        if (v32 < 0) {
          goto LABEL_140;
        }
        size_t v33 = (char *)operator new(v30 - v31);
        memmove(v33, v31, v32);
        BOOL v34 = &v33[8 * (v32 >> 3)];
      }
      if (*((_DWORD *)v6 + 2) != v29) {
        break;
      }
      unint64_t v35 = (const void *)*((void *)v6 + 2);
      size_t v36 = *((void *)v6 + 3) - (void)v35;
      if (v36 != v34 - v33) {
        break;
      }
      BOOL v37 = memcmp(v35, v33, v36) != 0;
      if (v33) {
        goto LABEL_51;
      }
LABEL_52:
      if (v37)
      {
        unint64_t v38 = *(void *)v6;
        int v95 = *((_DWORD *)v6 + 2);
        uint64_t v97 = 0;
        long long v96 = 0uLL;
        long long v96 = *((_OWORD *)v6 + 1);
        uint64_t v97 = *((void *)v6 + 4);
        *((void *)v6 + 3) = 0;
        *((void *)v6 + 4) = 0;
        *((void *)v6 + 2) = 0;
        sub_1CC8FDA94((uint64_t)a1, v38, (uint64_t)&v95);
        if ((void)v96)
        {
          *((void *)&v96 + 1) = v96;
          operator delete((void *)v96);
        }
      }
      int v39 = v6 + 40;
      uint64_t v6 = v4;
      if (v39 != v4)
      {
        uint64_t v6 = v39;
        while (*(void *)v6 == -2 || *(void *)v6 == -16)
        {
          v6 += 40;
          if (v6 == v4)
          {
            uint64_t v6 = v4;
            break;
          }
        }
      }
      if (v6 == v28) {
        goto LABEL_65;
      }
    }
    BOOL v37 = 1;
    if (!v33) {
      goto LABEL_52;
    }
LABEL_51:
    operator delete(v33);
    goto LABEL_52;
  }
  sub_1CC8FC920((uint64_t)&v92, a1, a2);
  uint64_t v8 = *a1;
  int v72 = *(_DWORD *)(*a1 + 40);
  uint64_t v10 = *(unsigned char **)(*a1 + 48);
  uint64_t v9 = *(unsigned char **)(*a1 + 56);
  int64_t v11 = v9 - v10;
  if (v9 == v10)
  {
    uint64_t v13 = 0;
    uint64_t v12 = 0;
  }
  else
  {
    if (v11 < 0) {
      goto LABEL_140;
    }
    uint64_t v12 = (char *)operator new(v9 - v10);
    memmove(v12, v10, v11);
    uint64_t v13 = &v12[8 * (v11 >> 3)];
  }
  int v14 = v92;
  if (v92 == v72
    && *((void *)&v93 + 1) - (void)v93 == v13 - v12
    && !memcmp((const void *)v93, v12, *((void *)&v93 + 1) - v93))
  {
    goto LABEL_36;
  }
  __s2 = v12;
  int v15 = *(_DWORD *)(v8 + 72);
  uint64_t v17 = *(unsigned char **)(v8 + 80);
  unsigned int v16 = *(unsigned char **)(v8 + 88);
  int64_t v18 = v16 - v17;
  if (v16 == v17)
  {
    BOOL v20 = 0;
    int v19 = 0;
  }
  else
  {
    if (v18 < 0) {
      goto LABEL_140;
    }
    int v19 = (char *)operator new(v16 - v17);
    memmove(v19, v17, v18);
    BOOL v20 = &v19[8 * (v18 >> 3)];
  }
  if (v14 == v15)
  {
    uint64_t v12 = __s2;
    if (*((void *)&v93 + 1) - (void)v93 == v20 - v19)
    {
      BOOL v21 = memcmp((const void *)v93, v19, *((void *)&v93 + 1) - v93) == 0;
      if (!v19) {
        goto LABEL_29;
      }
    }
    else
    {
      BOOL v21 = 0;
      if (!v19) {
        goto LABEL_29;
      }
    }
    goto LABEL_28;
  }
  BOOL v21 = 0;
  uint64_t v12 = __s2;
  if (v19) {
LABEL_28:
  }
    operator delete(v19);
LABEL_29:
  if (v21) {
    goto LABEL_36;
  }
  int v22 = *(_DWORD *)(a2 + 20);
  int v23 = v22 & 0x7FFFFFF;
  if ((v22 & 0x7FFFFFFu) > 0x40)
  {
    int v88 = v72;
    long long v90 = 0;
    uint64_t v91 = 0;
    std::string __p = 0;
    uint64_t v24 = v13 - v12;
    if (v13 != v12)
    {
      if (v24 < 0) {
        goto LABEL_140;
      }
      uint64_t v25 = (char *)operator new(v13 - v12);
      int v26 = &v25[8 * (v24 >> 3)];
      std::string __p = v25;
      uint64_t v91 = v26;
      memcpy(v25, v12, v13 - v12);
      long long v90 = v26;
    }
    sub_1CC8FDA94((uint64_t)a1, a2, (uint64_t)&v88);
    long long v27 = __p;
    if (!__p) {
      goto LABEL_36;
    }
LABEL_35:
    operator delete(v27);
    goto LABEL_36;
  }
  if (!v23) {
    goto LABEL_135;
  }
  unsigned int v41 = 0;
  size_t __n = v13 - __s2;
  int v70 = v22 & 0x7FFFFFF;
  if ((v22 & 0x40000000) != 0) {
    goto LABEL_72;
  }
LABEL_71:
  for (unint64_t i = a2 - 32 * (v22 & 0x7FFFFFF); ; unint64_t i = *(void *)(a2 - 8))
  {
    uint64_t v43 = *(void *)(i + 32 * *(unsigned int *)(a2 + 60) + 8 * v41);
    uint64_t v44 = *(void *)(a2 + 40);
    __int16 v98 = (char *)v100;
    long long v99 = xmmword_1CDB15990;
    uint64_t v45 = *(void *)(v43 + 40);
    if (v45) {
      uint64_t v46 = v45 - 24;
    }
    else {
      uint64_t v46 = 0;
    }
    if (*(unsigned __int8 *)(v46 + 16) - 29 >= 0xB) {
      uint64_t v47 = 0;
    }
    else {
      uint64_t v47 = v46;
    }
    sub_1CC8FDC18((uint64_t)a1, v47, (void **)&v98);
    if (*(unsigned char *)(v47 + 16) != 30)
    {
      unsigned int v48 = 2;
      char v51 = 1;
      switch(*(unsigned char *)(v47 + 16))
      {
        case 0x1E:
          __break(1u);
          JUMPOUT(0x1CC8FDA68);
        case 0x1F:
          unsigned int v48 = (*(_DWORD *)(v47 + 20) >> 1) & 0x3FFFFFF;
          goto LABEL_129;
        case 0x20:
        case 0x26:
          unsigned int v48 = (*(_DWORD *)(v47 + 20) & 0x7FFFFFF) - 1;
          goto LABEL_129;
        case 0x21:
          goto LABEL_83;
        case 0x24:
          unsigned int v48 = *(_WORD *)(v47 + 18) & 1;
          goto LABEL_129;
        case 0x25:
          unsigned int v48 = 1;
          goto LABEL_83;
        case 0x27:
          unsigned int v48 = *(_DWORD *)(v47 + 80) + 1;
LABEL_129:
          if (!v48) {
            goto LABEL_89;
          }
          goto LABEL_83;
        default:
          goto LABEL_89;
      }
    }
    unsigned int v48 = (*(_DWORD *)(v47 + 20) & 0x7FFFFFF) == 3 ? 2 : 1;
LABEL_83:
    uint64_t v49 = 0;
    uint64_t v50 = v48;
    while (llvm::Instruction::getSuccessor((llvm::Instruction *)v47, v49) != v44 || !v98[v49])
    {
      if (v50 == ++v49)
      {
        char v51 = 1;
        goto LABEL_89;
      }
    }
    char v51 = 0;
LABEL_89:
    if (v98 != (char *)v100) {
      free(v98);
    }
    if (v51) {
      break;
    }
    int v52 = *(_DWORD *)(a2 + 20);
    if ((v52 & 0x40000000) != 0) {
      unint64_t v53 = *(void *)(a2 - 8);
    }
    else {
      unint64_t v53 = a2 - 32 * (v52 & 0x7FFFFFF);
    }
    sub_1CC8FC920((uint64_t)&v98, a1, *(void *)(v53 + 32 * v41) & 0xFFFFFFFFFFFFFFF9);
    int v54 = (int)v98;
    int v55 = v92;
    long long v56 = v93;
    if (v98 == v92)
    {
      int64_t v57 = *((void *)&v93 + 1) - v93;
      if (*((void *)&v99 + 1) - (void)v99 == *((void *)&v93 + 1) - (void)v93
        && !memcmp((const void *)v99, (const void *)v93, *((void *)&v93 + 1) - v93))
      {
        int v23 = v70;
        goto LABEL_115;
      }
    }
    else
    {
      int64_t v57 = *((void *)&v93 + 1) - v93;
    }
    uint64_t v58 = *a1;
    int v81 = v55;
    uint64_t v83 = 0;
    BOOL v84 = 0;
    uint64_t v82 = 0;
    if (*((void *)&v56 + 1) != (void)v56)
    {
      if (v57 < 0) {
        goto LABEL_140;
      }
      uint64_t v82 = operator new(v57);
      uint64_t v83 = v82;
      uint64_t v59 = (char *)v82 + 8 * (v57 >> 3);
      BOOL v84 = v59;
      memmove(v82, (const void *)v56, v57);
      uint64_t v83 = v59;
    }
    int v77 = v54;
    unint64_t v79 = 0;
    long long v80 = 0;
    unint64_t v78 = 0;
    unint64_t v60 = (const void *)v99;
    int64_t v61 = *((void *)&v99 + 1) - v99;
    int v23 = v70;
    if (*((void *)&v99 + 1) != (void)v99)
    {
      if (v61 < 0) {
        goto LABEL_140;
      }
      unint64_t v78 = operator new(*((void *)&v99 + 1) - v99);
      unint64_t v79 = v78;
      uint64_t v62 = (char *)v78 + 8 * (v61 >> 3);
      long long v80 = v62;
      memmove(v78, v60, v61);
      unint64_t v79 = v62;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, int *, int *))(*(void *)v58 + 40))(&v85, v58, &v81, &v77);
    int v92 = v85;
    if ((void)v93)
    {
      *((void *)&v93 + 1) = v93;
      operator delete((void *)v93);
    }
    long long v93 = v86;
    uint64_t v94 = v87;
    uint64_t v87 = 0;
    long long v86 = 0uLL;
    if (v78)
    {
      unint64_t v79 = v78;
      operator delete(v78);
    }
    if (v82)
    {
      uint64_t v83 = v82;
      operator delete(v82);
    }
    int v54 = v92;
LABEL_115:
    BOOL v63 = v54 == v72 && *((void *)&v93 + 1) - (void)v93 == __n && memcmp((const void *)v93, __s2, __n) == 0;
    if ((void)v99)
    {
      *((void *)&v99 + 1) = v99;
      operator delete((void *)v99);
    }
    char v64 = ++v41 == v23 || v63;
    if (v64) {
      goto LABEL_135;
    }
LABEL_125:
    int v22 = *(_DWORD *)(a2 + 20);
    if ((v22 & 0x40000000) == 0) {
      goto LABEL_71;
    }
LABEL_72:
    ;
  }
  if (++v41 != v23) {
    goto LABEL_125;
  }
LABEL_135:
  int v73 = v92;
  uint64_t v75 = 0;
  unint64_t v76 = 0;
  unsigned int v74 = 0;
  uint64_t v65 = (const void *)v93;
  int64_t v66 = *((void *)&v93 + 1) - v93;
  uint64_t v12 = __s2;
  if (*((void *)&v93 + 1) != (void)v93)
  {
    if ((v66 & 0x8000000000000000) == 0)
    {
      unint64_t v67 = (char *)operator new(*((void *)&v93 + 1) - v93);
      unint64_t v68 = &v67[8 * (v66 >> 3)];
      unsigned int v74 = v67;
      unint64_t v76 = v68;
      memmove(v67, v65, v66);
      uint64_t v75 = v68;
      goto LABEL_138;
    }
LABEL_140:
    abort();
  }
LABEL_138:
  sub_1CC8FDA94((uint64_t)a1, a2, (uint64_t)&v73);
  long long v27 = v74;
  if (v74) {
    goto LABEL_35;
  }
LABEL_36:
  if (v12) {
    operator delete(v12);
  }
  if ((void)v93)
  {
    *((void *)&v93 + 1) = v93;
    operator delete((void *)v93);
  }
}

void sub_1CC8FDA94(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v14 = a2;
  uint64_t v15 = 0;
  uint64_t v6 = a1 + 8;
  if (sub_1CC8FCBA4(*(void *)(a1 + 8), *(_DWORD *)(a1 + 24), a2, &v15)) {
    BOOL v7 = v15 == *(void *)v6 + 40 * *(unsigned int *)(v6 + 16);
  }
  else {
    BOOL v7 = 1;
  }
  if (v7
    || *(_DWORD *)(v15 + 8) != *(_DWORD *)a3
    || (uint64_t v8 = *(const void **)(v15 + 16),
        size_t v9 = *(void *)(v15 + 24) - (void)v8,
        uint64_t v10 = *(const void **)(a3 + 8),
        v9 != *(void *)(a3 + 16) - (void)v10)
    || memcmp(v8, v10, v9))
  {
    int64_t v11 = (_DWORD *)sub_1CC8FC838(v6, &v14);
    *int64_t v11 = *(_DWORD *)a3;
    sub_1CD46D2D8((uint64_t)(v11 + 2), (__n128 *)(a3 + 8));
    unint64_t v12 = a2 & 0xFFFFFFFFFFFFFFF8;
    if (v12)
    {
      unsigned int v13 = *(_DWORD *)(a1 + 200);
      if (v13 >= *(_DWORD *)(a1 + 204)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 192) + 8 * v13) = v12;
      ++*(_DWORD *)(a1 + 200);
    }
  }
}

uint64_t *sub_1CC8FDB9C(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 40 * v2;
    uint64_t v5 = (void *)(v3 + 24);
    do
    {
      uint64_t v6 = *(v5 - 3);
      if (v6 != -16 && v6 != -2)
      {
        uint64_t v8 = (void *)*(v5 - 1);
        if (v8)
        {
          void *v5 = v8;
          operator delete(v8);
        }
      }
      v5 += 5;
      v4 -= 40;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void sub_1CC8FDC18(uint64_t a1, uint64_t a2, void **a3)
{
  unsigned int v6 = *(unsigned __int8 *)(a2 + 16);
  if (v6 == 30)
  {
    if ((*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3) {
      unsigned int v7 = 2;
    }
    else {
      unsigned int v7 = 1;
    }
  }
  else
  {
    unsigned int v7 = 0;
    switch(*(unsigned char *)(a2 + 16))
    {
      case 0x1E:
LABEL_169:
        __break(1u);
        goto LABEL_170;
      case 0x1F:
        unsigned int v7 = (*(_DWORD *)(a2 + 20) >> 1) & 0x3FFFFFF;
        break;
      case 0x20:
      case 0x26:
LABEL_170:
        unsigned int v7 = (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) - 1;
        break;
      case 0x21:
        unsigned int v7 = 2;
        break;
      case 0x24:
        unsigned int v7 = *(_WORD *)(a2 + 18) & 1;
        break;
      case 0x25:
        unsigned int v7 = 1;
        break;
      case 0x27:
        unsigned int v7 = *(_DWORD *)(a2 + 80) + 1;
        break;
      default:
        break;
    }
  }
  size_t v8 = v7;
  unint64_t v9 = (unint64_t)a3[1];
  if (v9 != v7)
  {
    if (v9 <= v7)
    {
      if ((unint64_t)a3[2] < v7) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      if (v7 != v9) {
        bzero((char *)*a3 + v9, v7 - v9);
      }
    }
    a3[1] = (void *)v8;
    unsigned int v6 = *(unsigned __int8 *)(a2 + 16);
  }
  if (v6 != 30)
  {
    switch(v6)
    {
      case 0x1Eu:
        goto LABEL_169;
      case 0x1Fu:
        int v36 = (*(_DWORD *)(a2 + 20) >> 1) & 0x3FFFFFF;
        goto LABEL_56;
      case 0x20u:
      case 0x26u:
        int v36 = (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) - 1;
        goto LABEL_56;
      case 0x21u:
      case 0x25u:
        goto LABEL_59;
      case 0x24u:
        int v36 = *(_WORD *)(a2 + 18) & 1;
        goto LABEL_56;
      case 0x27u:
        int v36 = *(_DWORD *)(a2 + 80) + 1;
LABEL_56:
        if (!v36) {
          return;
        }
        if (v6 <= 0x27 && ((1 << v6) & 0xF700000000) != 0)
        {
LABEL_59:
          if ((unint64_t)a3[2] < v8)
          {
            a3[1] = 0;
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          if (v8) {
            memset(*a3, 1, v8);
          }
          a3[1] = (void *)v8;
          return;
        }
        int v39 = *(_DWORD *)(a2 + 20);
        BOOL v84 = a3;
        if ((v39 & 0x40000000) != 0) {
          BOOL v40 = *(void **)(a2 - 8);
        }
        else {
          BOOL v40 = (void *)(a2 - 32 * (v39 & 0x7FFFFFF));
        }
        sub_1CC8FC920((uint64_t)&v93, (void *)a1, *v40 & 0xFFFFFFFFFFFFFFF9);
        int v41 = v93;
        int64_t v11 = v94;
        long long v86 = v95;
        uint64_t v42 = a1;
        uint64_t v43 = *(void *)a1;
        int v44 = *(_DWORD *)(*(void *)a1 + 40);
        uint64_t v46 = *(unsigned char **)(*(void *)a1 + 48);
        uint64_t v45 = *(unsigned char **)(*(void *)a1 + 56);
        int64_t v47 = v45 - v46;
        if (v45 == v46)
        {
          uint64_t v49 = 0;
          unsigned int v48 = 0;
        }
        else
        {
          if (v47 < 0) {
            goto LABEL_168;
          }
          a1 = v47 >> 3;
          unsigned int v48 = (char *)operator new(v45 - v46);
          memmove(v48, v46, v47);
          uint64_t v49 = &v48[8 * (v47 >> 3)];
        }
        if (v41 == v44 && (void)v86 - (void)v11 == v49 - v48 && !memcmp(v11, v48, v86 - (void)v11))
        {
          BOOL v57 = 1;
          uint64_t v56 = v42;
          if (v48) {
LABEL_99:
          }
            operator delete(v48);
        }
        else
        {
          int v50 = *(_DWORD *)(v43 + 72);
          int v52 = *(unsigned char **)(v43 + 80);
          char v51 = *(unsigned char **)(v43 + 88);
          int64_t v53 = v51 - v52;
          if (v51 == v52)
          {
            int v55 = 0;
            int v54 = 0;
          }
          else
          {
            if (v53 < 0) {
              goto LABEL_168;
            }
            a1 = v53 >> 3;
            int v54 = (char *)operator new(v51 - v52);
            memmove(v54, v52, v53);
            int v55 = &v54[8 * (v53 >> 3)];
          }
          if (v41 == v50)
          {
            uint64_t v56 = v42;
            BOOL v57 = (void)v86 - (void)v11 == v55 - v54 && memcmp(v11, v54, v86 - (void)v11) == 0;
          }
          else
          {
            BOOL v57 = 0;
            uint64_t v56 = v42;
          }
          if (v54) {
            operator delete(v54);
          }
          if (v48) {
            goto LABEL_99;
          }
        }
        if (v57)
        {
          if (*(unsigned char *)(a2 + 16) != 30)
          {
            unsigned int v6 = 0;
            a3 = v84;
            switch(*(unsigned char *)(a2 + 16))
            {
              case 0x1E:
                goto LABEL_169;
              case 0x1F:
                unsigned int v6 = (*(_DWORD *)(a2 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_106;
              case 0x20:
              case 0x26:
                unsigned int v6 = (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_106;
              case 0x21:
                unsigned int v6 = 2;
                goto LABEL_106;
              case 0x24:
                unsigned int v6 = *(_WORD *)(a2 + 18) & 1;
                goto LABEL_106;
              case 0x25:
                unsigned int v6 = 1;
                goto LABEL_106;
              case 0x27:
                unsigned int v6 = *(_DWORD *)(a2 + 80) + 1;
                goto LABEL_106;
              default:
                goto LABEL_106;
            }
          }
          if ((*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3) {
            unsigned int v6 = 2;
          }
          else {
            unsigned int v6 = 1;
          }
          a3 = v84;
LABEL_106:
          uint64_t v58 = (char *)v6;
          if ((unint64_t)a3[2] < v6)
          {
            a3[1] = 0;
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          uint64_t v59 = (char *)*a3;
          unint64_t v60 = (unint64_t)a3[1];
          if (v60 >= v6) {
            size_t v61 = v6;
          }
          else {
            size_t v61 = (size_t)a3[1];
          }
          if (v61) {
            memset(*a3, 1, v61);
          }
          if ((unint64_t)v58 > v60) {
            memset(&v59[v60], 1, (size_t)&v58[-v60]);
          }
          a3[1] = v58;
          goto LABEL_46;
        }
        int v62 = *(_DWORD *)(*(void *)v56 + 8);
        char v64 = *(unsigned char **)(*(void *)v56 + 16);
        BOOL v63 = *(unsigned char **)(*(void *)v56 + 24);
        int64_t v65 = v63 - v64;
        if (v63 == v64)
        {
          unint64_t v67 = 0;
          int64_t v66 = 0;
        }
        else
        {
          if (v65 < 0) {
            goto LABEL_168;
          }
          int64_t v66 = (char *)operator new(v63 - v64);
          memmove(v66, v64, v65);
          unint64_t v67 = &v66[8 * (v65 >> 3)];
        }
        BOOL v68 = v41 == v62 && (void)v86 - (void)v11 == v67 - v66 && memcmp(v11, v66, v86 - (void)v11) == 0;
        if (v66) {
          operator delete(v66);
        }
        if (v68) {
          goto LABEL_46;
        }
        uint64_t v69 = *(void *)v56;
        int v87 = v41;
        int v88 = v11;
        long long v89 = v86;
        int v70 = *(_DWORD *)(a2 + 20);
        if ((v70 & 0x40000000) != 0) {
          uint64_t v71 = *(void ***)(a2 - 8);
        }
        else {
          uint64_t v71 = (void **)(a2 - 32 * (v70 & 0x7FFFFFF));
        }
        a3 = v84;
        uint64_t v72 = (*(uint64_t (**)(uint64_t, int *, void))(*(void *)v69 + 72))(v69, &v87, **v71);
        if (v72)
        {
          if (*(unsigned __int8 *)(v72 + 16) >= 0x15u) {
            a1 = 0;
          }
          else {
            a1 = v72;
          }
        }
        else
        {
          a1 = 0;
        }
        if (v88)
        {
          *(void *)&long long v89 = v88;
          operator delete(v88);
        }
        if (a1 && *(unsigned char *)(a1 + 16) == 16)
        {
          sub_1CC025540(a2, a1);
          uint64_t v74 = (v73 + 1);
          if (v73 == -2) {
            uint64_t v74 = 0;
          }
          *((unsigned char *)*v84 + v74) = 1;
        }
        else
        {
          if (*(unsigned char *)(a2 + 16) != 30)
          {
            unsigned int v6 = 0;
            switch(*(unsigned char *)(a2 + 16))
            {
              case 0x1E:
                goto LABEL_169;
              case 0x1F:
                unsigned int v6 = (*(_DWORD *)(a2 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_148;
              case 0x20:
              case 0x26:
                unsigned int v6 = (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_148;
              case 0x21:
                unsigned int v6 = 2;
                goto LABEL_148;
              case 0x24:
                unsigned int v6 = *(_WORD *)(a2 + 18) & 1;
                goto LABEL_148;
              case 0x25:
                unsigned int v6 = 1;
                goto LABEL_148;
              case 0x27:
                unsigned int v6 = *(_DWORD *)(a2 + 80) + 1;
                goto LABEL_148;
              default:
                goto LABEL_148;
            }
          }
          if ((*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 3) {
            unsigned int v6 = 2;
          }
          else {
            unsigned int v6 = 1;
          }
LABEL_148:
          uint64_t v75 = (char *)v6;
          if ((unint64_t)v84[2] < v6)
          {
            v84[1] = 0;
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          unint64_t v76 = (char *)*v84;
          unint64_t v77 = (unint64_t)v84[1];
          if (v77 >= v6) {
            size_t v78 = v6;
          }
          else {
            size_t v78 = (size_t)v84[1];
          }
          if (v78) {
            memset(*v84, 1, v78);
          }
          if ((unint64_t)v75 > v77) {
            memset(&v76[v77], 1, (size_t)&v75[-v77]);
          }
          v84[1] = v75;
        }
        return;
      default:
        return;
    }
  }
  if ((*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 1)
  {
    *(unsigned char *)*a3 = 1;
    return;
  }
  sub_1CC8FC920((uint64_t)&v93, (void *)a1, *(void *)(a2 - 96) & 0xFFFFFFFFFFFFFFF9);
  int v10 = v93;
  int64_t v11 = v94;
  long long v85 = v95;
  uint64_t v12 = *(void *)a1;
  int v13 = *(_DWORD *)(*(void *)a1 + 40);
  uint64_t v15 = *(unsigned char **)(*(void *)a1 + 48);
  unint64_t v14 = *(unsigned char **)(*(void *)a1 + 56);
  int64_t v16 = v14 - v15;
  if (v14 == v15)
  {
    uint64_t v17 = 0;
    int64_t v18 = 0;
  }
  else
  {
    if (v16 < 0) {
      goto LABEL_168;
    }
    uint64_t v17 = (char *)operator new(v14 - v15);
    memmove(v17, v15, v16);
    int64_t v18 = &v17[8 * (v16 >> 3)];
  }
  if (v10 != v13 || (void)v85 - (void)v11 != v18 - v17 || memcmp(v11, v17, v85 - (void)v11))
  {
    int v19 = *(_DWORD *)(v12 + 72);
    BOOL v21 = *(unsigned char **)(v12 + 80);
    BOOL v20 = *(unsigned char **)(v12 + 88);
    int64_t v22 = v20 - v21;
    if (v20 == v21)
    {
      int v23 = 0;
      uint64_t v24 = 0;
    }
    else
    {
      if (v22 < 0) {
        goto LABEL_168;
      }
      int v23 = (char *)operator new(v20 - v21);
      memmove(v23, v21, v22);
      uint64_t v24 = &v23[8 * (v22 >> 3)];
    }
    if (v10 == v19 && (void)v85 - (void)v11 == v24 - v23)
    {
      BOOL v25 = memcmp(v11, v23, v85 - (void)v11) == 0;
      if (!v23)
      {
LABEL_31:
        if (!v17) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
    }
    else
    {
      BOOL v25 = 0;
      if (!v23) {
        goto LABEL_31;
      }
    }
    operator delete(v23);
    goto LABEL_31;
  }
  BOOL v25 = 1;
  if (v17) {
LABEL_32:
  }
    operator delete(v17);
LABEL_33:
  if (v25)
  {
    *(_WORD *)*a3 = 257;
    goto LABEL_46;
  }
  int v26 = *(_DWORD *)(*(void *)a1 + 8);
  unint64_t v28 = *(unsigned char **)(*(void *)a1 + 16);
  long long v27 = *(unsigned char **)(*(void *)a1 + 24);
  int64_t v29 = v27 - v28;
  if (v27 == v28)
  {
    uint64_t v30 = 0;
    int64_t v31 = 0;
    goto LABEL_39;
  }
  if (v29 < 0) {
LABEL_168:
  }
    abort();
  uint64_t v30 = (char *)operator new(v27 - v28);
  memmove(v30, v28, v29);
  int64_t v31 = &v30[8 * (v29 >> 3)];
LABEL_39:
  if (v10 == v26 && (void)v85 - (void)v11 == v31 - v30)
  {
    BOOL v32 = memcmp(v11, v30, v85 - (void)v11) == 0;
    if (!v30) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
  BOOL v32 = 0;
  if (v30) {
LABEL_44:
  }
    operator delete(v30);
LABEL_45:
  if (v32)
  {
LABEL_46:
    if (v11) {
      operator delete(v11);
    }
    return;
  }
  uint64_t v33 = *(void *)a1;
  int v90 = v10;
  std::string __p = v11;
  long long v92 = v85;
  uint64_t v34 = (*(uint64_t (**)(uint64_t, int *, void))(*(void *)v33 + 72))(v33, &v90, **(void **)(a2 - 96));
  if (v34)
  {
    if (*(unsigned __int8 *)(v34 + 16) >= 0x15u) {
      uint64_t v35 = 0;
    }
    else {
      uint64_t v35 = v34;
    }
  }
  else
  {
    uint64_t v35 = 0;
  }
  if (__p)
  {
    *(void *)&long long v92 = __p;
    operator delete(__p);
  }
  if (v35 && *(unsigned char *)(v35 + 16) == 16)
  {
    uint64_t v37 = *(unsigned int *)(v35 + 32);
    if (v37 > 0x40)
    {
      int v79 = 0;
      int64_t v80 = (unint64_t)(v37 + 63) >> 6;
      do
      {
        if (v80-- < 1) {
          break;
        }
        unint64_t v82 = *(void *)(*(void *)(v35 + 24) + 8 * v80);
        v79 += __clz(v82);
      }
      while (!v82);
      int v83 = v37 | 0xFFFFFFC0;
      if ((v37 & 0x3F) == 0) {
        int v83 = 0;
      }
      BOOL v38 = v79 + v83 == v37;
    }
    else
    {
      BOOL v38 = *(void *)(v35 + 24) == 0;
    }
    *((unsigned char *)*a3 + v38) = 1;
  }
  else
  {
    *(_WORD *)*a3 = 257;
  }
}

void sub_1CC8FE6A8()
{
}

void sub_1CC8FE6E8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC8FE720(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CC8FE72C(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }

  return sub_1CC8FA4CC((uint64_t *)a2);
}

uint64_t sub_1CC8FE778()
{
  int v4 = 1;
  int v2 = 4;
  uint64_t v3 = &v2;
  *(void *)&long long v1 = "The maximum number of functions to track per lattice value";
  *((void *)&v1 + 1) = 58;
  sub_1CD45A86C((uint64_t)&unk_1EBCDE3E8, "cvp-max-functions-per-value", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCDE3E8, &dword_1CB82C000);
}

uint64_t sub_1CC8FE808(uint64_t a1)
{
  v77[1] = *MEMORY[0x1E4F143B8];
  unint64_t v67 = v71;
  BOOL v68 = v71;
  uint64_t v69 = 8;
  int v70 = 0;
  long long v1 = *(uint64_t **)(a1 + 112);
  unsigned int v2 = *((_DWORD *)v1 + 8);
  if (v2 <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = v2;
  }
  if (v2 <= 8) {
    size_t v4 = v3;
  }
  else {
    size_t v4 = 9;
  }
  uint64_t v5 = *((unsigned int *)v1 + 2);
  if (!v5) {
    goto LABEL_20;
  }
  uint64_t v6 = 0;
  int v7 = 0;
  do
    int v7 = 33 * v7 + aLlvmUsed[v6++];
  while (v4 != v6);
  uint64_t v8 = *v1;
  uint64_t v9 = *v1 + 8 * v5 + 8;
  int v10 = 1;
  int v11 = v7;
  while (1)
  {
    uint64_t v12 = v11 & (v5 - 1);
    int v13 = *(void **)(v8 + 8 * v12);
    if (v13 != (void *)-8)
    {
      if (!v13) {
        goto LABEL_20;
      }
      if (*(_DWORD *)(v9 + 4 * v12) == v7
        && v4 == *v13
        && !memcmp("llvm.used", (char *)v13 + *((unsigned int *)v1 + 5), v4))
      {
        break;
      }
    }
    int v11 = v10 + v12;
    ++v10;
  }
  if (v12 == -1
    || (int)v12 == v5
    || (uint64_t v14 = *(void *)(*(void *)(v8 + 8 * (int)v12) + 8)) == 0
    || *(unsigned char *)(v14 + 16) != 3
    || (*(_DWORD *)(v14 + 32) & 0xFu) - 7 <= 1)
  {
LABEL_20:
    uint64_t v14 = 0;
  }
  sub_1CC8FF098(v14, (uint64_t)&v67);
  uint64_t v15 = *(uint64_t **)(a1 + 112);
  unsigned int v16 = *((_DWORD *)v15 + 8);
  if (v16 <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v16;
  }
  if (v16 <= 0x11) {
    size_t v18 = v17;
  }
  else {
    size_t v18 = 18;
  }
  uint64_t v19 = *((unsigned int *)v15 + 2);
  if (!v19) {
    goto LABEL_40;
  }
  uint64_t v20 = 0;
  int v21 = 0;
  do
    int v21 = 33 * v21 + aLlvmCompilerUs[v20++];
  while (v18 != v20);
  uint64_t v22 = *v15;
  uint64_t v23 = *v15 + 8 * v19 + 8;
  int v24 = 1;
  int v25 = v21;
  while (1)
  {
    uint64_t v26 = v25 & (v19 - 1);
    long long v27 = *(void **)(v22 + 8 * v26);
    if (v27 != (void *)-8)
    {
      if (!v27) {
        goto LABEL_40;
      }
      if (*(_DWORD *)(v23 + 4 * v26) == v21
        && v18 == *v27
        && !memcmp("llvm.compiler.used", (char *)v27 + *((unsigned int *)v15 + 5), v18))
      {
        break;
      }
    }
    int v25 = v24 + v26;
    ++v24;
  }
  if (v26 == -1
    || (int)v26 == v19
    || (uint64_t v28 = *(void *)(*(void *)(v22 + 8 * (int)v26) + 8)) == 0
    || *(unsigned char *)(v28 + 16) != 3
    || (*(_DWORD *)(v28 + 32) & 0xFu) - 7 <= 1)
  {
LABEL_40:
    uint64_t v28 = 0;
  }
  sub_1CC8FF098(v28, (uint64_t)&v67);
  v65[0] = 0;
  v65[1] = 0;
  int v66 = 0;
  uint64_t v72 = v74;
  uint64_t v73 = 0x2000000000;
  uint64_t v29 = a1 + 8;
  uint64_t v30 = *(void *)(a1 + 16);
  if (v30 == a1 + 8) {
    goto LABEL_85;
  }
  do
  {
    uint64_t v31 = v30 - 56;
    BOOL v36 = v30 == 0;
    uint64_t v30 = *(void *)(v30 + 8);
    if (v36) {
      uint64_t v32 = 0;
    }
    else {
      uint64_t v32 = v31;
    }
    llvm::Constant::removeDeadConstantUsers(v32);
    if (!*(void *)(v32 + 8) && (*(_DWORD *)(v32 + 32) & 0xFu) - 7 <= 1) {
      llvm::GlobalVariable::eraseFromParent((llvm::GlobalVariable *)v32);
    }
    if (!sub_1CC8FF274((llvm::GlobalValue *)v32, (uint64_t *)&v67))
    {
      unsigned int v33 = *(_DWORD *)(v32 + 32) & 0xF;
      BOOL v34 = v33 > 0xA;
      int v35 = (1 << v33) & 0x63C;
      BOOL v36 = v34 || v35 == 0;
      if (v36 && !sub_1CC8FF404((unsigned char *)v32))
      {
        uint64_t v75 = 0;
        uint64_t v75 = *(llvm::MDNode ***)(v32 - 32);
        uint64_t v37 = sub_1CD467E2C((uint64_t)v65, (uint64_t *)&v75);
        uint64_t v38 = v37[1];
        if (v38)
        {
          int v39 = *(_DWORD *)(v32 + 32);
          unsigned int v40 = (*(_DWORD *)(v38 + 32) & 0xF) - 7;
          if ((v39 & 0xFu) - 7 < 2)
          {
            if (v40 > 1) {
              continue;
            }
LABEL_61:
            if ((v39 & 0xC0) != 0x80) {
              continue;
            }
            goto LABEL_62;
          }
          if (v40 >= 2) {
            goto LABEL_61;
          }
        }
LABEL_62:
        v37[1] = v32;
      }
    }
  }
  while (v30 != v29);
  uint64_t v41 = *(void *)(a1 + 16);
  while (v41 != v29)
  {
    uint64_t v42 = v41 - 56;
    BOOL v36 = v41 == 0;
    uint64_t v41 = *(void *)(v41 + 8);
    if (v36) {
      uint64_t v43 = 0;
    }
    else {
      uint64_t v43 = v42;
    }
    if (!sub_1CC8FF274((llvm::GlobalValue *)v43, (uint64_t *)&v67))
    {
      int v44 = *(_DWORD *)(v43 + 32);
      if ((v44 & 0xFu) - 7 <= 1)
      {
        if (v66)
        {
          uint64_t v45 = *(void *)(v43 - 32);
          uint64_t v46 = ((v45 >> 4) ^ (v45 >> 9)) & (v66 - 1);
          uint64_t v47 = *(void *)(v65[0] + 16 * v46);
          if (v45 == v47)
          {
LABEL_71:
            if (v46 != v66)
            {
              uint64_t v48 = *(void *)(v65[0] + 16 * v46 + 8);
              if (v48 != v43
                && ((v44 & 0xC0) == 0x80 || (*(_DWORD *)(v48 + 32) & 0xC0) == 0x80)
                && !sub_1CC8FF404((unsigned char *)v43))
              {
                if ((*(_DWORD *)(v43 + 32) & 0xC0) != 0x80) {
                  *(_DWORD *)(v48 + 32) &= 0xFFFFFF3F;
                }
                if (v73 >= (unint64_t)HIDWORD(v73)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v49 = (char *)v72 + 16 * v73;
                *uint64_t v49 = v43;
                v49[1] = v48;
                LODWORD(v73) = v73 + 1;
              }
            }
          }
          else
          {
            int v50 = 1;
            while (v47 != -4096)
            {
              int v51 = v46 + v50++;
              uint64_t v46 = v51 & (v66 - 1);
              uint64_t v47 = *(void *)(v65[0] + 16 * v46);
              if (v45 == v47) {
                goto LABEL_71;
              }
            }
          }
        }
      }
    }
  }
LABEL_85:
  if (v73)
  {
    int v52 = *(const llvm::GlobalVariable **)v72;
    uint64_t v53 = *((void *)v72 + 1);
    unsigned int v54 = *(_DWORD *)(*(void *)v72 + 32);
    if ((v54 & 0x3F0000) != 0 || (*(unsigned char *)(v53 + 34) & 0x3F) != 0)
    {
      char PreferredAlign = llvm::DataLayout::getPreferredAlign((llvm::DataLayout *)(*((void *)v52 + 5) + 272), v52);
      __int16 v56 = *(_WORD *)(v53 + 34);
      char v57 = llvm::DataLayout::getPreferredAlign((llvm::DataLayout *)(*(void *)(v53 + 40) + 272), (const llvm::GlobalVariable *)v53);
      if ((v56 & 0x3F) != 0) {
        LOBYTE(v58) = (v56 & 0x3F) - 1;
      }
      else {
        LOBYTE(v58) = v57;
      }
      int v59 = (HIWORD(v54) & 0x3F) - 1;
      if ((v54 & 0x3F0000) == 0) {
        LOBYTE(v59) = PreferredAlign;
      }
      if (v59 <= v58) {
        int v58 = v58;
      }
      else {
        int v58 = v59;
      }
      *(_DWORD *)(v53 + 32) = ((v58 << 16) + 0x10000) | *(_DWORD *)(v53 + 32) & 0xFFC0FFFF;
    }
    uint64_t v75 = (llvm::MDNode **)v77;
    uint64_t v76 = 0x100000000;
    llvm::GlobalVariable::getDebugInfo((unsigned int *)v52, (uint64_t)&v75);
    unint64_t v60 = v75;
    if (v76)
    {
      uint64_t v61 = 8 * v76;
      do
      {
        int v62 = *v60++;
        llvm::Value::addMetadata((llvm::Value *)v53, 0, v62);
        v61 -= 8;
      }
      while (v61);
      unint64_t v60 = v75;
    }
    if (v60 != v77) {
      free(v60);
    }
    llvm::Value::doRAUW(v52, (llvm::Value *)v53, (llvm::Value *)1);
    llvm::GlobalVariable::eraseFromParent(v52);
  }
  if (v72 != v74) {
    free(v72);
  }
  MEMORY[0x1D25D9CD0](v65[0], 8);
  if (v68 != v67) {
    free(v68);
  }
  return 0;
}

void llvm::initializeConstantMergeLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4C0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8FEF4C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCDE4C0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8FEF4C()
{
}

uint64_t sub_1CC8FEFE8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE4B8;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F26278E0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4C0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC8FEF4C;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCDE4C0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC8FF098(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 - 32);
    int v3 = *(_DWORD *)(v2 + 20);
    uint64_t v4 = v3 & 0x7FFFFFF;
    if ((v3 & 0x7FFFFFF) != 0)
    {
      uint64_t v6 = 0;
      while (1)
      {
        int v7 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v2 - 32 * (*(_DWORD *)(v2 + 20) & 0x7FFFFFF) + 32 * v6));
        uint64_t v8 = v7;
        uint64_t v9 = *(void *)(a2 + 8);
        uint64_t v10 = *(unsigned int *)(a2 + 20);
        if (v9 != *(void *)a2) {
          break;
        }
        if (v10)
        {
          int v11 = 0;
          uint64_t v12 = 8 * v10;
          int v13 = *(llvm::Value ***)(a2 + 8);
          while (*v13 != v7)
          {
            if (*v13 == (llvm::Value *)-2) {
              int v11 = v13;
            }
            ++v13;
            v12 -= 8;
            if (!v12)
            {
              if (!v11) {
                goto LABEL_12;
              }
              *int v11 = v7;
              --*(_DWORD *)(a2 + 24);
              goto LABEL_36;
            }
          }
          goto LABEL_36;
        }
LABEL_12:
        unsigned int v14 = *(_DWORD *)(a2 + 16);
        if (v10 >= v14) {
          goto LABEL_15;
        }
        *(_DWORD *)(a2 + 20) = v10 + 1;
        *(void *)(v9 + 8 * v10) = v7;
LABEL_36:
        if (++v6 == v4) {
          return;
        }
      }
      unsigned int v14 = *(_DWORD *)(a2 + 16);
LABEL_15:
      if (3 * v14 <= 4 * ((int)v10 - *(_DWORD *)(a2 + 24)))
      {
        if (v14 >= 0x40) {
          v14 *= 2;
        }
        else {
          unsigned int v14 = 128;
        }
      }
      else if (v14 - v10 >= v14 >> 3)
      {
        goto LABEL_17;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v14);
      unsigned int v14 = *(_DWORD *)(a2 + 16);
      uint64_t v9 = *(void *)(a2 + 8);
LABEL_17:
      unsigned int v15 = v14 - 1;
      unsigned int v16 = (v14 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      uint64_t v17 = (llvm::Value **)(v9 + 8 * v16);
      size_t v18 = *v17;
      if (*v17 == (llvm::Value *)-1)
      {
        uint64_t v19 = 0;
LABEL_29:
        if (v19) {
          uint64_t v23 = v19;
        }
        else {
          uint64_t v23 = v17;
        }
        if (*v23 != v8)
        {
          if (*v23 == (llvm::Value *)-2) {
            --*(_DWORD *)(a2 + 24);
          }
          else {
            ++*(_DWORD *)(a2 + 20);
          }
          char *v23 = v8;
        }
      }
      else
      {
        uint64_t v19 = 0;
        int v20 = 1;
        while (v18 != v8)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v18 == (llvm::Value *)-2;
          }
          if (v21) {
            uint64_t v19 = v17;
          }
          unsigned int v22 = v16 + v20++;
          unsigned int v16 = v22 & v15;
          uint64_t v17 = (llvm::Value **)(v9 + 8 * (v22 & v15));
          size_t v18 = *v17;
          if (*v17 == (llvm::Value *)-1) {
            goto LABEL_29;
          }
        }
      }
      goto LABEL_36;
    }
  }
}

BOOL sub_1CC8FF274(llvm::GlobalValue *this, uint64_t *a2)
{
  if ((*((unsigned char *)this + 80) & 1) == 0) {
    return 1;
  }
  if (*((unsigned char *)this + 16))
  {
    if (*((unsigned char *)this + 16) == 3 && (*((_DWORD *)this + 5) & 0x7FFFFFF) == 0) {
      return 1;
    }
  }
  else if (*((llvm::GlobalValue **)this + 9) == (llvm::GlobalValue *)((char *)this + 72) {
         && (*((unsigned char *)this + 34) & 0x80) == 0)
  }
  {
    return 1;
  }
  if ((llvm::GlobalValue::isInterposable(this) & 1) != 0
    || (*((unsigned char *)this + 80) & 2) != 0
    || *(_DWORD *)(*(void *)this + 8) > 0xFFu
    || (*((_DWORD *)this + 8) & 0x401C00) != 0)
  {
    return 1;
  }
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5 == *a2)
  {
    uint64_t v7 = *((unsigned int *)a2 + 5);
    uint64_t v8 = (llvm::GlobalValue **)(v5 + 8 * v7);
    if (v7)
    {
      uint64_t v9 = 0;
      while (*(llvm::GlobalValue **)(v5 + v9) != this)
      {
        v9 += 8;
        if (8 * v7 == v9) {
          goto LABEL_31;
        }
      }
      uint64_t v8 = (llvm::GlobalValue **)(v5 + v9);
    }
LABEL_31:
    uint64_t v6 = a2[1];
    goto LABEL_38;
  }
  uint64_t v10 = *((unsigned int *)a2 + 4);
  int v11 = v10 - 1;
  unsigned int v12 = (v10 - 1) & ((this >> 4) ^ (this >> 9));
  uint64_t v8 = (llvm::GlobalValue **)(v5 + 8 * v12);
  int v13 = *v8;
  if (*v8 != (llvm::GlobalValue *)-1)
  {
    unsigned int v14 = 0;
    int v15 = 1;
    while (v13 != this)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v13 == (llvm::GlobalValue *)-2;
      }
      if (v16) {
        unsigned int v14 = v8;
      }
      unsigned int v17 = v12 + v15++;
      unsigned int v12 = v17 & v11;
      uint64_t v8 = (llvm::GlobalValue **)(v5 + 8 * (v17 & v11));
      int v13 = *v8;
      if (*v8 == (llvm::GlobalValue *)-1) {
        goto LABEL_33;
      }
    }
LABEL_37:
    LODWORD(v7) = *((_DWORD *)a2 + 5);
    goto LABEL_38;
  }
  unsigned int v14 = 0;
LABEL_33:
  if (v14) {
    uint64_t v8 = v14;
  }
  if (*v8 == this) {
    goto LABEL_37;
  }
  LODWORD(v7) = *((_DWORD *)a2 + 5);
  uint64_t v8 = (llvm::GlobalValue **)(v5 + 8 * v10);
LABEL_38:
  if (v5 == v6) {
    unsigned int v18 = v7;
  }
  else {
    unsigned int v18 = *((_DWORD *)a2 + 4);
  }
  return v8 != (llvm::GlobalValue **)(v5 + 8 * v18);
}

BOOL sub_1CC8FF404(unsigned char *a1)
{
  v9[8] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = v9;
  uint64_t v8 = 0x400000000;
  llvm::Value::getAllMetadata(a1, (uint64_t)&v7);
  if (v8)
  {
    uint64_t v1 = 16 * v8 - 16;
    uint64_t v2 = (int *)v7;
    do
    {
      int v3 = *v2;
      v2 += 4;
      BOOL v4 = v3 != 0;
      if (v3) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v1 == 0;
      }
      v1 -= 16;
    }
    while (!v5);
  }
  else
  {
    BOOL v4 = 0;
  }
  if (v7 != v9) {
    free(v7);
  }
  return v4;
}

void sub_1CC8FF4C0()
{
}

void sub_1CC8FF500(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC8FF538(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }

  return sub_1CC8FE808((uint64_t)a2);
}

void llvm::initializeCrossDSOCFIPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4D0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC8FF5F4;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE4D0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC8FF5F4()
{
}

void llvm::createCrossDSOCFIPass(llvm *this)
{
}

uint64_t sub_1CC8FF6C8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE4C8;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2627980;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4D0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC8FF5F4;
    v5[1] = &PassRegistry;
    BOOL v4 = v5;
    std::__call_once(&qword_1EBCDE4D0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

BOOL sub_1CC8FF778(uint64_t a1, void **a2)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v94 = *a2;
  __int16 v98 = (void *)0x1000FFFFFLL;
  *(void *)(a1 + 32) = llvm::MDBuilder::createBranchWeights((uint64_t **)&v94, (uint64_t)&v98, 2);
  __int16 v98 = &v100;
  uint64_t v99 = 0x800000000;
  long long v86 = (llvm::Module *)a2;
  llvm::Module::getModuleFlagsMetadata((llvm::Module *)a2, (uint64_t)&v98);
  if (v99)
  {
    int v3 = (uint64_t *)((char *)v98 + 16);
    uint64_t v4 = 24 * v99;
    while (1)
    {
      BOOL v5 = *(void **)(*(v3 - 1) + 8);
      if (*v5 == 13)
      {
        uint64_t v6 = v5[3];
        uint64_t v7 = *(void *)((char *)v5 + 29);
        BOOL v8 = v6 == 0x53442D73736F7243 && v7 == 0x494643204F53442DLL;
        if (v8) {
          break;
        }
      }
      v3 += 3;
      v4 -= 24;
      if (!v4) {
        goto LABEL_12;
      }
    }
    uint64_t v9 = *v3;
  }
  else
  {
LABEL_12:
    uint64_t v9 = 0;
  }
  if (v98 != &v100)
  {
    free(v98);
    if (!v9) {
      return v9 != 0;
    }
LABEL_17:
    v89[0] = 0;
    v89[1] = 0;
    int v90 = 0;
    uint64_t v92 = 0;
    uint64_t v93 = 0;
    uint64_t v91 = 0;
    long long v95 = &v97;
    uint64_t v96 = 0x200000000;
    int v11 = (char *)v86 + 24;
    unsigned int v12 = (char *)*((void *)v86 + 4);
    int v13 = (char *)v86 + 8;
    uint64_t v14 = *((void *)v86 + 2);
    __int16 v98 = v12;
    uint64_t v99 = v14;
    uint64_t v100 = (char *)v86 + 24;
    uint64_t v101 = (char *)v86 + 8;
    while (v12 != v11 || (char *)v14 != v13 || v100 != v11 || v101 != v13)
    {
      uint64_t v16 = 0;
      do
      {
        unsigned int v17 = (unsigned int *)(*(uint64_t (**)(void **))((char *)&off_1F2627A10 + v16))(&v98);
        v16 += 16;
      }
      while (!v17);
      LODWORD(v96) = 0;
      llvm::Value::getMetadata(v17, 19, (uint64_t)&v95);
      if (v96)
      {
        unsigned int v18 = (char *)v95;
        uint64_t v19 = 8 * v96;
        do
        {
          int v20 = *(unsigned __int8 **)(*(void *)v18 - 8 * *(unsigned int *)(*(void *)v18 + 8) + 8);
          if (*v20 - 3 >= 0xFFFFFFFE)
          {
            uint64_t v21 = *((void *)v20 + 16);
            if (v21)
            {
              if (*(unsigned char *)(v21 + 16) == 16 && *(_DWORD *)(v21 + 32) == 64)
              {
                uint64_t v94 = *(void **)(v21 + 24);
                sub_1CC0C3F88(v89, (uint64_t *)&v94);
              }
            }
          }
          v18 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      uint64_t v22 = 0;
      do
      {
        if ((*(uint64_t (**)(void **))((char *)&off_1F2627A30 + v22))(&v98)) {
          break;
        }
        BOOL v8 = v22 == 16;
        v22 += 16;
      }
      while (!v8);
      unsigned int v12 = (char *)v98;
      uint64_t v14 = v99;
    }
    __int16 v98 = "cfi.functions";
    __int16 v102 = 259;
    uint64_t NamedMetadata = llvm::Module::getNamedMetadata(v86, (const char **)&v98);
    if (NamedMetadata)
    {
      uint64_t v24 = NamedMetadata;
      uint64_t v25 = *(unsigned int *)(*(void *)(NamedMetadata + 48) + 8);
      if (v25)
      {
        for (uint64_t i = 0; i != v25; ++i)
        {
          uint64_t v27 = *(void *)(**(void **)(v24 + 48) + 8 * i);
          unint64_t v28 = *(unsigned int *)(v27 + 8);
          if (v28 >= 3)
          {
            for (unint64_t j = 2; j < v28; ++j)
            {
              uint64_t v30 = *(void *)(v27 - 8 * v28 + 8 * j);
              uint64_t v31 = *(unsigned __int8 **)(v30 - 8 * *(unsigned int *)(v30 + 8) + 8);
              if (*v31 - 3 >= 0xFFFFFFFE)
              {
                uint64_t v32 = *((void *)v31 + 16);
                if (v32)
                {
                  if (*(unsigned char *)(v32 + 16) == 16 && *(_DWORD *)(v32 + 32) == 64)
                  {
                    __int16 v98 = *(void **)(v32 + 24);
                    sub_1CC0C3F88(v89, (uint64_t *)&v98);
                    unint64_t v28 = *(unsigned int *)(v27 + 8);
                  }
                }
              }
            }
          }
        }
      }
    }
    unsigned int v33 = *(uint64_t **)v86;
    uint64_t v34 = **(void **)v86;
    int v35 = (uint64_t **)(v34 + 1576);
    uint64_t v36 = v34 + 1984;
    unint64_t v37 = llvm::PointerType::get((llvm::PointerType *)(v34 + 1912), 0);
    unint64_t v38 = llvm::PointerType::get((llvm::PointerType *)(*v33 + 1912), 0);
    uint64_t v39 = sub_1CD6613C8((uint64_t)v86, v35, v36, v37, v38);
    sub_1CD660DD8((llvm::GlobalValue *)v39);
    *(_DWORD *)(v39 + 32) = *(_DWORD *)(v39 + 32) & 0xFFC0FFFF | 0xD0000;
    __int16 v102 = 260;
    __int16 v98 = (char *)v86 + 216;
    llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)&v98);
    if (v88 <= 0x28 && ((1 << v88) & 0x18000000006) != 0) {
      *(void *)(v39 + 112) = llvm::AttributeList::addAttributeAtIndex((llvm::AttributeList *)(v39 + 112), **(uint64_t ***)v39, -1, "target-features", 0xFuLL, "+thumb-mode", 0xBuLL);
    }
    if (*(_WORD *)(v39 + 18)) {
      llvm::Function::BuildLazyArguments((llvm::Function *)v39);
    }
    unsigned int v40 = *(uint64_t ****)(v39 + 88);
    uint64_t v41 = v40 + 5;
    __int16 v98 = "CallSiteTypeId";
    __int16 v102 = 259;
    llvm::Value::setNameImpl((llvm::Value *)v40, (const char **)&v98);
    if (v40) {
      BOOL v42 = *((unsigned char *)v40 + 16) == 0;
    }
    else {
      BOOL v42 = 0;
    }
    if (v42)
    {
      if ((*((unsigned char *)v40 + 23) & 0x10) == 0) {
        goto LABEL_92;
      }
      uint64_t v44 = ***v40;
      uint64_t v45 = *(void *)(v44 + 152);
      uint64_t v46 = *(unsigned int *)(v44 + 168);
      if (v46)
      {
        LODWORD(v47) = (v46 - 1) & ((v40 >> 4) ^ (v40 >> 9));
        uint64_t v48 = (uint64_t ****)(v45 + 16 * v47);
        uint64_t v49 = *v48;
        if (*v48 != v40)
        {
          int v50 = 1;
          do
          {
            if (v49 == (uint64_t ***)-4096) {
              goto LABEL_84;
            }
            int v51 = v47 + v50++;
            uint64_t v47 = v51 & (v46 - 1);
            uint64_t v49 = *(uint64_t ****)(v45 + 16 * v47);
          }
          while (v49 != v40);
          uint64_t v48 = (uint64_t ****)(v45 + 16 * v47);
        }
      }
      else
      {
LABEL_84:
        uint64_t v48 = (uint64_t ****)(v45 + 16 * v46);
      }
      BOOL v68 = v48[1];
      unint64_t v71 = (unint64_t)*v68;
      uint64_t v69 = v68 + 2;
      unint64_t v70 = v71;
      if (v71 >= 5 && (*(_DWORD *)v69 == *(_DWORD *)"llvm." ? (BOOL v72 = v69[4] == aLlvm_1[4]) : (BOOL v72 = 0), v72))
      {
        *((_DWORD *)v40 + 8) |= 0x2000u;
        int v73 = llvm::Function::lookupIntrinsicID(v69, v70);
      }
      else
      {
LABEL_92:
        int v73 = 0;
        *((_DWORD *)v40 + 8) &= ~0x2000u;
      }
      *((_DWORD *)v40 + 9) = v73;
    }
    uint64_t v43 = v40 + 10;
    __int16 v98 = "Addr";
    __int16 v102 = 259;
    llvm::Value::setNameImpl((llvm::Value *)(v40 + 5), (const char **)&v98);
    if (!*((unsigned char *)v40 + 56))
    {
      if ((*((unsigned char *)v40 + 63) & 0x10) == 0) {
        goto LABEL_102;
      }
      uint64_t v52 = ***v41;
      uint64_t v53 = *(void *)(v52 + 152);
      uint64_t v54 = *(unsigned int *)(v52 + 168);
      if (v54)
      {
        LODWORD(v55) = (v54 - 1) & ((v41 >> 4) ^ (v41 >> 9));
        __int16 v56 = (uint64_t ****)(v53 + 16 * v55);
        char v57 = *v56;
        if (*v56 != v41)
        {
          int v58 = 1;
          do
          {
            if (v57 == (uint64_t ***)-4096) {
              goto LABEL_94;
            }
            int v59 = v55 + v58++;
            uint64_t v55 = v59 & (v54 - 1);
            char v57 = *(uint64_t ****)(v53 + 16 * v55);
          }
          while (v57 != v41);
          __int16 v56 = (uint64_t ****)(v53 + 16 * v55);
        }
      }
      else
      {
LABEL_94:
        __int16 v56 = (uint64_t ****)(v53 + 16 * v54);
      }
      uint64_t v74 = v56[1];
      unint64_t v77 = (unint64_t)*v74;
      uint64_t v75 = v74 + 2;
      unint64_t v76 = v77;
      if (v77 >= 5 && (*(_DWORD *)v75 == *(_DWORD *)"llvm." ? (BOOL v78 = v75[4] == aLlvm_1[4]) : (BOOL v78 = 0), v78))
      {
        *((_DWORD *)v40 + 18) |= 0x2000u;
        int v79 = llvm::Function::lookupIntrinsicID(v75, v76);
      }
      else
      {
LABEL_102:
        int v79 = 0;
        *((_DWORD *)v40 + 18) &= ~0x2000u;
      }
      *((_DWORD *)v40 + 19) = v79;
    }
    __int16 v98 = "CFICheckFailData";
    __int16 v102 = 259;
    llvm::Value::setNameImpl((llvm::Value *)(v40 + 10), (const char **)&v98);
    if (!*((unsigned char *)v40 + 96))
    {
      if ((*((unsigned char *)v40 + 103) & 0x10) == 0) {
        goto LABEL_112;
      }
      uint64_t v60 = ***v43;
      uint64_t v61 = *(void *)(v60 + 152);
      uint64_t v62 = *(unsigned int *)(v60 + 168);
      if (v62)
      {
        LODWORD(v63) = (v62 - 1) & ((v43 >> 4) ^ (v43 >> 9));
        char v64 = (uint64_t ****)(v61 + 16 * v63);
        int64_t v65 = *v64;
        if (*v64 != v43)
        {
          int v66 = 1;
          do
          {
            if (v65 == (uint64_t ***)-4096) {
              goto LABEL_104;
            }
            int v67 = v63 + v66++;
            uint64_t v63 = v67 & (v62 - 1);
            int64_t v65 = *(uint64_t ****)(v61 + 16 * v63);
          }
          while (v65 != v43);
          char v64 = (uint64_t ****)(v61 + 16 * v63);
        }
      }
      else
      {
LABEL_104:
        char v64 = (uint64_t ****)(v61 + 16 * v62);
      }
      int64_t v80 = v64[1];
      unint64_t v83 = (unint64_t)*v80;
      int v81 = v80 + 2;
      unint64_t v82 = v83;
      if (v83 >= 5 && (*(_DWORD *)v81 == *(_DWORD *)"llvm." ? (BOOL v84 = v81[4] == aLlvm_1[4]) : (BOOL v84 = 0), v84))
      {
        *((_DWORD *)v40 + 28) |= 0x2000u;
        int v85 = llvm::Function::lookupIntrinsicID(v81, v82);
      }
      else
      {
LABEL_112:
        int v85 = 0;
        *((_DWORD *)v40 + 28) &= ~0x2000u;
      }
      *((_DWORD *)v40 + 29) = v85;
    }
    __int16 v98 = "entry";
    __int16 v102 = 259;
    operator new();
  }
  if (v9) {
    goto LABEL_17;
  }
  return v9 != 0;
}

void sub_1CC90069C()
{
}

void sub_1CC9006D8(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC900710(void *a1)
{
  if (*a1 == a1[2] || *a1 == 0) {
    return 0;
  }
  else {
    return *a1 - 56;
  }
}

uint64_t sub_1CC90072C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1 == *(void *)(a1 + 24) || v1 == 0) {
    return 0;
  }
  else {
    return v1 - 56;
  }
}

BOOL sub_1CC900748(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[2];
  if (*a1 != v2) {
    *a1 = *(void *)(v1 + 8);
  }
  return v1 != v2;
}

BOOL sub_1CC90076C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 24);
  if (v1 != v2) {
    *(void *)(a1 + 8) = *(void *)(v1 + 8);
  }
  return v1 != v2;
}

void llvm::initializeDAEPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4E8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC900800;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE4E8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC900800()
{
}

void llvm::initializeDAHPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4D8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC90090C;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE4D8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC90090C()
{
}

uint64_t sub_1CC9009A8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE4E0;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2627A60;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4E8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC900800;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCDE4E8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::createDeadArgHackingPass(llvm *this)
{
}

uint64_t llvm::DeadArgumentEliminationPass::DeleteDeadVarargs(llvm::DeadArgumentEliminationPass *this, llvm::Function *a2)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a2 + 16))
  {
    if (*((unsigned char *)a2 + 16) == 3 && (*((_DWORD *)a2 + 5) & 0x7FFFFFF) == 0) {
      return 0;
    }
  }
  else if (*((llvm::Function **)a2 + 9) == (llvm::Function *)((char *)a2 + 72) && (*((unsigned char *)a2 + 34) & 0x80) == 0)
  {
    return 0;
  }
  if ((*((_DWORD *)a2 + 8) & 0xFu) - 7 > 1) {
    return 0;
  }
  char hasAddressTaken = llvm::Function::hasAddressTaken(a2, 0, 0, 1, 0, 0);
  uint64_t result = 0;
  if (hasAddressTaken) {
    return result;
  }
  uint64_t v5 = *((void *)a2 + 14);
  if (v5)
  {
    if ((*(unsigned char *)(v5 + 14) & 2) != 0) {
      return 0;
    }
  }
  for (uint64_t i = (void *)*((void *)a2 + 10); i != (void *)((char *)a2 + 72); uint64_t i = (void *)i[1])
  {
    if (i) {
      uint64_t v7 = i - 3;
    }
    else {
      uint64_t v7 = 0;
    }
    BOOL v8 = v7 + 5;
    for (unint64_t j = (void *)v7[6]; j != v8; unint64_t j = (void *)j[1])
    {
      uint64_t v10 = j - 3;
      if (!j) {
        uint64_t v10 = 0;
      }
      int v11 = *((unsigned __int8 *)v10 + 16);
      BOOL v12 = v11 == 84;
      if (v11 == 84) {
        int v13 = v10;
      }
      else {
        int v13 = 0;
      }
      if (j)
      {
        if (v12)
        {
          if ((*((_WORD *)v13 + 9) & 3) == 2) {
            return 0;
          }
          uint64_t v14 = *(v13 - 4);
          if (v14)
          {
            if (!*(unsigned char *)(v14 + 16)
              && *(void *)(v14 + 24) == v13[9]
              && (*(unsigned char *)(v14 + 33) & 0x20) != 0
              && *(_DWORD *)(*(v10 - 4) + 36) == 315)
            {
              return 0;
            }
          }
        }
      }
    }
  }
  uint64_t v15 = *((void *)a2 + 3);
  uint64_t v16 = *(uint64_t ****)(v15 + 16);
  uint64_t v17 = *(unsigned int *)(v15 + 12);
  uint64_t v99 = (uint64_t *)((char *)a2 + 72);
  if (8 * v17 == 8)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
  }
  else
  {
    if (!v17) {
      goto LABEL_130;
    }
    unsigned int v18 = operator new(8 * v17 - 8);
    uint64_t v19 = (uint64_t)v18;
    if (v17 != 1) {
      memmove(v18, v16 + 1, 8 * v17 - 8);
    }
    uint64_t v20 = v19 + 8 * ((8 * v17 - 8) >> 3);
    uint64_t v16 = *(uint64_t ****)(v15 + 16);
  }
  unint64_t v21 = v20 - v19;
  uint64_t v22 = (llvm::PointerType *)llvm::FunctionType::get(*v16, v19, (v20 - v19) >> 3, 0);
  char v23 = *((_DWORD *)a2 + 8) & 0xF;
  uint64_t v24 = (llvm::Type *)(*(_DWORD *)(*(void *)a2 + 8) >> 8);
  v110[8] = 257;
  uint64_t v25 = (unint64_t *)operator new(0x80uLL);
  uint64_t v26 = (llvm::Value *)(v25 + 1);
  *((_DWORD *)v25 + 7) = *((_DWORD *)v25 + 7) & 0x38000000 | 0x40000000;
  *uint64_t v25 = 0;
  uint64_t v27 = llvm::Function::Function(v25 + 1, v22, v23, v24, (const char **)&__src, 0);
  llvm::Function::copyAttributesFrom((llvm::Function *)v27, a2);
  llvm::GlobalObject::setComdat((llvm::GlobalObject *)(v25 + 1), *((llvm::Comdat **)a2 + 6));
  unint64_t v28 = *((void *)a2 + 5);
  v25[6] = v28;
  uint64_t v103 = v25;
  if ((*((unsigned char *)v25 + 31) & 0x10) != 0)
  {
    uint64_t v29 = *(llvm::ValueSymbolTable **)(v28 + 112);
    if (v29) {
      llvm::ValueSymbolTable::reinsertValue(v29, v26);
    }
  }
  __int16 v98 = (void *)v19;
  unint64_t v30 = *((void *)a2 + 7);
  v25[8] = v30;
  v25[9] = (unint64_t)a2 + 56;
  *(void *)(v30 + 8) = v25 + 8;
  *((void *)a2 + 7) = v25 + 8;
  __int16 v102 = (uint64_t **)(v25 + 1);
  llvm::Value::takeName((int32x2_t ****)v26, a2);
  uint64_t v101 = a2;
  uint64_t v31 = *((void *)a2 + 1);
  uint64_t v32 = 0;
  if (v31)
  {
    unint64_t v33 = (v21 >> 3);
    size_t __n = v21 & 0x7FFFFFFF8;
    while (1)
    {
      uint64_t v34 = *(void *)(v31 + 24);
      uint64_t v31 = *(void *)(v31 + 8);
      unsigned int v35 = *(unsigned __int8 *)(v34 + 16);
      if (v35 >= 0x1C)
      {
        unsigned int v36 = v35 - 33;
        BOOL v37 = v36 > 0x33;
        uint64_t v38 = (1 << v36) & 0x8000000000041;
        if (!v37 && v38 != 0) {
          break;
        }
      }
      if (!v31) {
        goto LABEL_110;
      }
    }
    unsigned int v40 = (uint64_t *)(v34 - 32 * (*(_DWORD *)(v34 + 20) & 0x7FFFFFF));
    if (!v33)
    {
      uint64_t v42 = 0;
      goto LABEL_58;
    }
    if (!(v33 >> 61))
    {
      uint64_t v41 = (uint64_t *)operator new(8 * v33);
      uint64_t v32 = v41;
      uint64_t v42 = 0;
      uint64_t v43 = 32 * v33;
      do
      {
        uint64_t v44 = *v40;
        v40 += 4;
        v41[v42++] = v44;
        v43 -= 32;
      }
      while (v43);
LABEL_58:
      uint64_t v45 = *(void *)(v34 + 64);
      if (v45)
      {
        __src = v110;
        uint64_t v109 = 0x800000000;
        unsigned int v46 = __n;
        if (__n)
        {
          unsigned int v46 = 0;
          uint64_t v47 = 0;
          do
          {
            if ((v47 + 2) < *(_DWORD *)(v45 + 8)) {
              uint64_t v48 = *(void *)(v45 + 40 + 8 * (v47 + 2));
            }
            else {
              uint64_t v48 = 0;
            }
            if (v46 >= HIDWORD(v109)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)__src + v46) = v48;
            unsigned int v46 = v109 + 1;
            LODWORD(v109) = v109 + 1;
            ++v47;
          }
          while (v33 != v47);
        }
        int v49 = *(_DWORD *)(v45 + 8);
        if (v49)
        {
          uint64_t v50 = *(void *)(v45 + 40);
          if (v49 == 1) {
            uint64_t v51 = 0;
          }
          else {
            uint64_t v51 = *(void *)(v45 + 48);
          }
        }
        else
        {
          uint64_t v50 = 0;
          uint64_t v51 = 0;
        }
        uint64_t v52 = llvm::AttributeList::get(**(uint64_t ***)v101, v50, v51, __src, v46);
        if (__src != v110) {
          free(__src);
        }
      }
      else
      {
        uint64_t v52 = 0;
      }
      __src = v110;
      uint64_t v109 = 0x100000000;
      int v53 = *(_DWORD *)(v34 + 20);
      if (v53 < 0)
      {
        unint64_t v76 = *(void *)(v34 - 32 * (v53 & 0x7FFFFFF) - 8);
        if ((v76 & 0xFFFFFFFF0) != 0)
        {
          uint64_t v77 = (v76 >> 4);
          uint64_t v78 = v34;
          do
          {
            uint64_t v79 = *(_DWORD *)(v34 + 20) & 0x7FFFFFF;
            uint64_t v80 = v34 - 32 * v79;
            int v81 = (unsigned int *)(v78 - (*(void *)(v80 - 8) + 32 * v79));
            uint64_t v82 = *v81;
            uint64_t v83 = v81[1];
            BOOL v84 = (const char *)*((void *)v81 - 1);
            v106[0] = (const char *)(v80 + 32 * v82);
            v106[1] = (const char *)(v83 - v82);
            void v106[2] = v84;
            sub_1CD5C74F0((uint64_t)&__src, (uint64_t)v106);
            v78 += 16;
            --v77;
          }
          while (v77);
        }
      }
      uint64_t v54 = &v32[v42];
      uint64_t v55 = v103[4];
      if (*(unsigned char *)(v34 + 16) == 33)
      {
        uint64_t v70 = *(void *)(v34 - 96);
        uint64_t v71 = *(void *)(v34 - 64);
        __int16 v107 = 257;
        int64_t v65 = sub_1CD4EF89C(v55, (uint64_t)v102, v70, v71, v32, (v42 * 8) >> 3, (uint64_t)__src, v109, v106, (llvm::Instruction *)v34);
        __int16 v69 = *((_WORD *)v65 + 9);
      }
      else
      {
        uint64_t v104 = (char *)__src;
        long long v105 = (uint64_t **)v103[4];
        uint64_t v56 = v109;
        __int16 v107 = 257;
        int v57 = 0;
        if (v109)
        {
          uint64_t v85 = 48 * v109;
          long long v86 = (char *)__src + 32;
          do
          {
            v57 += (*v86 - *(v86 - 1)) >> 3;
            v86 += 6;
            v85 -= 48;
          }
          while (v85);
        }
        uint64_t v58 = (char *)v54 - (char *)v32;
        int v59 = ((unint64_t)((char *)v54 - (char *)v32) >> 3) + 1;
        uint64_t v60 = (v57 + v59);
        uint64_t v61 = (16 * v109);
        if (v61) {
          uint64_t v62 = (16 * v109) | 8u;
        }
        else {
          uint64_t v62 = 0;
        }
        uint64_t v63 = (char *)operator new(v62 + 32 * v60 + 80);
        char v64 = &v63[v62];
        int64_t v65 = &v63[32 * v60 + v62];
        *((_DWORD *)v65 + 5) = v60 & 0x7FFFFFF | ((v61 != 0) << 31) | *((_DWORD *)v65 + 5) & 0x38000000;
        if (v60)
        {
          do
          {
            *(void *)char v64 = 0;
            *((void *)v64 + 1) = 0;
            *((void *)v64 + 2) = 0;
            *((void *)v64 + 3) = v65;
            v64 += 32;
          }
          while (v64 != v65);
        }
        if (v61) {
          *(void *)&v63[v61] = v61;
        }
        int v66 = 0;
        if (v56)
        {
          uint64_t v87 = 48 * v56;
          unsigned int v88 = v104 + 32;
          do
          {
            v66 += (*v88 - *(v88 - 1)) >> 3;
            v88 += 6;
            v87 -= 48;
          }
          while (v87);
        }
        *(void *)int64_t v65 = *v105[2];
        *((void *)v65 + 1) = 0;
        unsigned int v67 = *((_DWORD *)v65 + 5) & 0xC0000000 | (v66 + v59) & 0x7FFFFFF;
        *((_DWORD *)v65 + 4) = 84;
        *((_DWORD *)v65 + 5) = v67;
        *(_OWORD *)(v65 + 24) = 0u;
        BOOL v68 = v65 + 24;
        *(_OWORD *)(v65 + 40) = 0u;
        *((_DWORD *)v65 + 14) = 0;
        if (v34)
        {
          uint64_t v72 = *(void *)(v34 + 40);
          *((void *)v65 + 5) = v72;
          *(_WORD *)(v72 + 18) &= ~0x8000u;
          if ((v65[23] & 0x10) != 0)
          {
            uint64_t v74 = *(void *)(v72 + 56);
            if (v74)
            {
              uint64_t v75 = *(llvm::ValueSymbolTable **)(v74 + 104);
              if (v75) {
                llvm::ValueSymbolTable::reinsertValue(v75, (llvm::Value *)v65);
              }
            }
          }
          uint64_t v73 = *(void *)(v34 + 24);
          *((void *)v65 + 3) = v73;
          *((void *)v65 + 4) = v34 + 24;
          *(void *)(v73 + 8) = v68;
          *(void *)(v34 + 24) = v68;
        }
        *((void *)v65 + 8) = 0;
        llvm::CallInst::init((uint64_t ***)v65, v105, v102, v32, v58 >> 3, (uint64_t)v104, v56, v106);
        __int16 v69 = *((_WORD *)v65 + 9) & 0xFFFC | *(_WORD *)(v34 + 18) & 3;
        *((_WORD *)v65 + 9) = v69;
      }
      *((_WORD *)v65 + 9) = *(_WORD *)(v34 + 18) & 0xFFC | v69 & 0xF003;
      *((void *)v65 + 8) = v52;
      v106[0] = (const char *)2;
      llvm::Instruction::copyMetadata((uint64_t)v65, v34, (int *)v106, 2);
      if (*(void *)(v34 + 8)) {
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)v34, (llvm::Value *)v65, (llvm::Value *)1);
      }
      llvm::Value::takeName((int32x2_t ****)v65, (llvm::Value *)v34);
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
LABEL_130:
    abort();
  }
LABEL_110:
  sub_1CC89D864((uint64_t)(v103 + 10), (uint64_t *)v103[11], v99);
  if (*((_WORD *)v101 + 9))
  {
    llvm::Function::BuildLazyArguments(v101);
    long long v89 = (llvm::ValueAsMetadata *)*((void *)v101 + 11);
    uint64_t v91 = v98;
    uint64_t v92 = v26;
    if (*((_WORD *)v101 + 9)) {
      llvm::Function::BuildLazyArguments(v101);
    }
    int v90 = (llvm::ValueAsMetadata *)*((void *)v101 + 11);
  }
  else
  {
    long long v89 = (llvm::ValueAsMetadata *)*((void *)v101 + 11);
    int v90 = v89;
    uint64_t v91 = v98;
    uint64_t v92 = v26;
  }
  uint64_t v93 = (llvm::ValueAsMetadata *)((char *)v90 + 40 * *((void *)v101 + 12));
  if (*((_WORD *)v103 + 13)) {
    llvm::Function::BuildLazyArguments(v92);
  }
  if (v89 != v93)
  {
    uint64_t v94 = (llvm::Value *)v103[12];
    do
    {
      llvm::Value::doRAUW(v89, v94, (llvm::Value *)1);
      llvm::Value::takeName((int32x2_t ****)v94, v89);
      long long v89 = (llvm::ValueAsMetadata *)((char *)v89 + 40);
      uint64_t v94 = (llvm::Value *)((char *)v94 + 40);
    }
    while (v89 != v93);
  }
  __src = v110;
  uint64_t v109 = 0x100000000;
  llvm::Value::getAllMetadata(v101, (uint64_t)&__src);
  if (v109)
  {
    long long v95 = (llvm::MDNode **)__src;
    uint64_t v96 = (llvm::MDNode **)((char *)__src + 16 * v109);
    do
    {
      llvm::Value::addMetadata(v92, *(_DWORD *)v95, v95[1]);
      v95 += 2;
    }
    while (v95 != v96);
  }
  uint64_t v97 = v92;
  if (*(void *)v92 != *(void *)v101) {
    uint64_t v97 = sub_1CC56C0C0((llvm *)0x31, v92, *(llvm::Constant **)v101, 0);
  }
  llvm::Value::doRAUW(v101, v97, (llvm::Value *)1);
  llvm::Constant::removeDeadConstantUsers((uint64_t)v92);
  llvm::Function::eraseFromParent(v101);
  if (__src != v110) {
    free(__src);
  }
  if (v91) {
    operator delete(v91);
  }
  return 1;
}

uint64_t llvm::DeadArgumentEliminationPass::RemoveDeadArgumentsFromCallers(llvm::DeadArgumentEliminationPass *this, llvm::Function *a2)
{
  v48[4] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a2 + 16) == 3)
  {
    if ((*((_DWORD *)a2 + 5) & 0x7FFFFFF) == 0) {
      goto LABEL_3;
    }
  }
  else if (!*((unsigned char *)a2 + 16) {
         && *((llvm::Function **)a2 + 9) == (llvm::Function *)((char *)a2 + 72)
  }
         && (*((unsigned char *)a2 + 34) & 0x80) == 0)
  {
    goto LABEL_3;
  }
  char v4 = 0;
  if (((1 << (*((_DWORD *)a2 + 8) & 0xF)) & 0x7D5) == 0) {
    return v4 & 1;
  }
  if (llvm::GlobalValue::isInterposable(a2)) {
    goto LABEL_3;
  }
  if ((*((_DWORD *)a2 + 8) & 0xFu) - 7 <= 1)
  {
    for (uint64_t i = (void *)*((void *)this + 7); i; uint64_t i = (void *)*i)
    {
      unint64_t v15 = i[4];
      if (v15 <= (unint64_t)a2)
      {
        if (v15 >= (unint64_t)a2) {
          goto LABEL_11;
        }
        ++i;
      }
    }
    if (*(_DWORD *)(*((void *)a2 + 3) + 8) < 0x100u) {
      goto LABEL_3;
    }
  }
LABEL_11:
  uint64_t v7 = *((void *)a2 + 14);
  if (v7 && (*(unsigned char *)(v7 + 14) & 2) != 0 || !*((void *)a2 + 1))
  {
LABEL_3:
    char v4 = 0;
    return v4 & 1;
  }
  unsigned int v46 = v48;
  uint64_t v47 = 0x800000000;
  v44[0] = 0;
  v44[1] = 0;
  uint64_t v43 = v44;
  long long v42 = xmmword_1CFAC7B50;
  if (*((unsigned char *)a2 + 18))
  {
    llvm::Function::BuildLazyArguments(a2);
    uint64_t v8 = *((void *)a2 + 11);
    if (*((_WORD *)a2 + 9))
    {
      llvm::Function::BuildLazyArguments(a2);
      uint64_t v9 = *((void *)a2 + 11);
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v8 = *((void *)a2 + 11);
  }
  uint64_t v9 = v8;
LABEL_17:
  uint64_t v10 = v9 + 40 * *((void *)a2 + 12);
  if (v8 == v10)
  {
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    do
    {
      uint64_t v11 = *(void *)(*(void *)(v8 + 24) + 112);
      if (!v11
        || (unsigned int v12 = *(_DWORD *)(v8 + 32) + 2, v12 >= *(_DWORD *)(v11 + 8))
        || (uint64_t v13 = *(void *)(v11 + 8 * v12 + 40)) == 0
        || (*(char *)(v13 + 19) & 0x80000000) == 0)
      {
        if (!*(void *)(v8 + 8) && (llvm::Argument::hasPassPointeeByValueCopyAttr((llvm::Argument *)v8) & 1) == 0)
        {
          if ((*(unsigned char *)(v8 + 23) & 8) != 0)
          {
            unsigned int v40 = llvm::UndefValue::get(*(llvm::UndefValue **)v8, v6);
            char v4 = 1;
            llvm::Value::doRAUW((llvm::ValueAsMetadata *)v8, v40, (llvm::Value *)1);
          }
          if (v47 >= (unint64_t)HIDWORD(v47)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v46 + v47) = *(_DWORD *)(v8 + 32);
          LODWORD(v47) = v47 + 1;
          llvm::Function::removeParamAttrs((uint64_t)a2, *(_DWORD *)(v8 + 32), (uint64_t)&v42);
        }
      }
      v8 += 40;
    }
    while (v8 != v10);
  }
  if (v47)
  {
    for (uint64_t j = *((void *)a2 + 1); j; uint64_t j = *(void *)(j + 8))
    {
      uint64_t v17 = *(void *)(j + 24);
      unsigned int v18 = *(unsigned __int8 *)(v17 + 16);
      if (v18 >= 0x1C)
      {
        unsigned int v19 = v18 - 33;
        BOOL v20 = v19 > 0x33;
        uint64_t v21 = (1 << v19) & 0x8000000000041;
        BOOL v22 = v20 || v21 == 0;
        if (!v22 && v17 - 32 == j && *(void *)(v17 + 72) == *((void *)a2 + 3) && v47)
        {
          uint64_t v23 = 0;
          uint64_t v24 = (uint64_t *)(v17 + 64);
          uint64_t v41 = 4 * v47;
          do
          {
            uint64_t v25 = *(unsigned int *)((char *)v46 + v23);
            uint64_t v26 = llvm::UndefValue::get(**(llvm::UndefValue ***)(v17 - 32 * (*(_DWORD *)(v17 + 20) & 0x7FFFFFF) + 32 * v25), v6);
            uint64_t v27 = v17 - 32 * (*(_DWORD *)(v17 + 20) & 0x7FFFFFF);
            uint64_t v28 = v27 + 32 * v25;
            if (*(void *)v28)
            {
              **(void **)(v28 + 16) = *(void *)(v28 + 8);
              uint64_t v29 = *(void *)(v28 + 8);
              if (v29) {
                *(void *)(v29 + 16) = *(void *)(v28 + 16);
              }
            }
            *(void *)uint64_t v28 = v26;
            if (v26)
            {
              uint64_t v32 = *((void *)v26 + 1);
              unint64_t v30 = (void *)((char *)v26 + 8);
              uint64_t v31 = v32;
              uint64_t v33 = v27 + 32 * v25;
              *(void *)(v33 + 8) = v32;
              if (v32) {
                *(void *)(v31 + 16) = v33 + 8;
              }
              *(void *)(v33 + 16) = v30;
              *unint64_t v30 = v28;
            }
            uint64_t v34 = **(uint64_t ***)v17;
            uint64_t v35 = *(void *)(v17 + 64);
            if (v35 && (v25 + 2) < *(_DWORD *)(v35 + 8)) {
              uint64_t v36 = *(void *)(v35 + 8 * (v25 + 2) + 40);
            }
            else {
              uint64_t v36 = 0;
            }
            uint64_t v45 = v36;
            BOOL v37 = v34;
            uint64_t v38 = llvm::AttributeSet::removeAttributes(&v45, v34, (uint64_t)&v42);
            if (v36 == v38) {
              uint64_t v39 = *v24;
            }
            else {
              uint64_t v39 = llvm::AttributeList::setAttributesAtIndex((void *)(v17 + 64), v37, (int)v25 + 1, v38);
            }
            *uint64_t v24 = v39;
            v23 += 4;
            char v4 = 1;
          }
          while (v41 != v23);
        }
      }
    }
  }
  else
  {
    char v4 = 0;
  }
  sub_1CC1E4850((uint64_t)&v43, v44[0]);
  if (v46 != v48) {
    free(v46);
  }
  return v4 & 1;
}

uint64_t llvm::DeadArgumentEliminationPass::MarkIfNotLive(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[0] = a2;
  v12[1] = a3;
  for (uint64_t i = *(void **)(a1 + 56); i; uint64_t i = (void *)*i)
  {
    unint64_t v8 = i[4];
    if (v8 <= a2)
    {
      if (v8 >= a2) {
        return 0;
      }
      ++i;
    }
  }
  if (sub_1CC904D78(*(void *)(a1 + 32), v12)) {
    return 0;
  }
  unsigned int v9 = *(_DWORD *)(a4 + 8);
  if (v9 >= *(_DWORD *)(a4 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v10 = (unint64_t *)(*(void *)a4 + 16 * v9);
  *uint64_t v10 = a2;
  v10[1] = a3;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

uint64_t llvm::DeadArgumentEliminationPass::IsLive(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (!v2) {
    return sub_1CC904D78(*(void *)(a1 + 32), a2) != 0;
  }
  unint64_t v3 = *a2;
  while (1)
  {
    unint64_t v4 = v2[4];
    if (v3 >= v4) {
      break;
    }
LABEL_6:
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      return sub_1CC904D78(*(void *)(a1 + 32), a2) != 0;
    }
  }
  if (v4 < v3)
  {
    ++v2;
    goto LABEL_6;
  }
  return 1;
}

uint64_t llvm::DeadArgumentEliminationPass::SurveyUse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v7 = *(void *)(a2 + 24);
  unsigned int v8 = *(unsigned __int8 *)(v7 + 16);
  if (v7) {
    BOOL v9 = v8 == 29;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    unint64_t v14 = *(void *)(*(void *)(v7 + 40) + 56);
    if (a4 == -1)
    {
      unint64_t v25 = 0;
      uint64_t v13 = 1;
      while (1)
      {
        uint64_t v26 = **(void **)(*(void *)(v14 + 24) + 16);
        int v27 = *(unsigned __int8 *)(v26 + 8);
        if (v27 == 7)
        {
          unint64_t v28 = 0;
        }
        else if (v27 == 17)
        {
          unint64_t v28 = *(unsigned int *)(v26 + 32);
        }
        else
        {
          unint64_t v28 = v27 == 16 ? *(unsigned int *)(v26 + 12) : 1;
        }
        if (v25 >= v28) {
          break;
        }
        unsigned int v29 = llvm::DeadArgumentEliminationPass::MarkIfNotLive(a1, v14, v25, a3);
        if (v13) {
          uint64_t v13 = v29;
        }
        else {
          uint64_t v13 = 0;
        }
        ++v25;
      }
      return v13;
    }
    uint64_t v15 = a4;
  }
  else
  {
    if (v7 && v8 == 93)
    {
      int v10 = *(_DWORD *)(v7 + 20);
      if ((v10 & 0x40000000) != 0) {
        uint64_t v11 = *(void *)(v7 - 8);
      }
      else {
        uint64_t v11 = v7 - 32 * (v10 & 0x7FFFFFF);
      }
      if (((a2 - v11) & 0x1FFFFFFFE0) != 0) {
        uint64_t v4 = **(unsigned int **)(v7 + 64);
      }
      uint64_t v12 = *(void *)(v7 + 8);
      if (!v12) {
        return 1;
      }
      while (llvm::DeadArgumentEliminationPass::SurveyUse(a1, v12, a3, v4))
      {
        uint64_t v12 = *(void *)(v12 + 8);
        if (!v12) {
          return 1;
        }
      }
      return 0;
    }
    if (v8 < 0x1C) {
      return 0;
    }
    unsigned int v17 = v8 - 33;
    BOOL v18 = v17 > 0x33;
    uint64_t v19 = (1 << v17) & 0x8000000000041;
    if (v18 || v19 == 0) {
      return 0;
    }
    unint64_t v14 = *(void *)(v7 - 32);
    if (!v14) {
      return 0;
    }
    if (*(unsigned char *)(v14 + 16)) {
      return 0;
    }
    uint64_t v21 = *(void *)(v14 + 24);
    if (v21 != *(void *)(v7 + 72)) {
      return 0;
    }
    int v22 = *(_DWORD *)(v7 + 20);
    uint64_t v23 = -(uint64_t)(v22 & 0x7FFFFFF);
    if (v22 < 0)
    {
      uint64_t v30 = v7 - 32 * (v22 & 0x7FFFFFF);
      uint64_t v31 = *(void *)(v30 - 8);
      if ((v31 & 0xFFFFFFFF0) != 0)
      {
        unint64_t v32 = (unint64_t)(a2 - v30) >> 5;
        if (*(_DWORD *)(v30 - v31) <= v32 && *(_DWORD *)(v30 - 12) > v32) {
          return 0;
        }
      }
    }
    unint64_t v24 = a2 - (v7 + 32 * v23);
    if (*(_DWORD *)(v21 + 12) - 1 <= (v24 >> 5)) {
      return 0;
    }
    uint64_t v15 = (v24 >> 5) | 0x100000000;
  }

  return llvm::DeadArgumentEliminationPass::MarkIfNotLive(a1, v14, v15, a3);
}

uint64_t llvm::DeadArgumentEliminationPass::SurveyUses(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (!v3) {
    return 1;
  }
  while (1)
  {
    uint64_t result = llvm::DeadArgumentEliminationPass::SurveyUse(a1, v3, a3, 0xFFFFFFFFLL);
    if (!result) {
      break;
    }
    uint64_t v3 = *(void *)(v3 + 8);
    if (!v3) {
      return 1;
    }
  }
  return result;
}

void llvm::DeadArgumentEliminationPass::SurveyFunction(llvm::DeadArgumentEliminationPass *this, const llvm::Function *a2)
{
  uint64_t v2 = a2;
  v85[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (unsigned char *)*((void *)a2 + 14);
  if (!v4 || ((char)v4[32] & 0x80000000) == 0 && (v4[33] & 1) == 0 && (v4[14] & 2) == 0)
  {
    uint64_t v5 = **(void **)(*((void *)a2 + 3) + 16);
    int v6 = *(unsigned __int8 *)(v5 + 8);
    switch(v6)
    {
      case 7:
        unsigned int v7 = 0;
        break;
      case 17:
        unsigned int v7 = *(_DWORD *)(v5 + 32);
LABEL_13:
        unint64_t v8 = v7;
        BOOL v9 = v85;
        uint64_t v83 = v85;
        uint64_t v84 = 0x500000000;
        if (v7 >= 6) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (!v7)
        {
LABEL_15:
          LODWORD(v84) = v7;
          *(void *)&long long __src = v79;
          *((void *)&__src + 1) = 0x500000000;
          int v10 = v82;
          uint64_t v80 = v82;
          uint64_t v81 = 0x500000000;
          __int16 v69 = v82;
          uint64_t v70 = v2;
          unsigned int v74 = v7;
          if (v7)
          {
            unint64_t v11 = v8;
            do
            {
              *int v10 = v10 + 2;
              v10[1] = 0x500000000;
              if (DWORD2(__src)) {
                int v10 = (void *)sub_1CD49DFB4((uint64_t)v10, (uint64_t)&__src);
              }
              v10 += 12;
              --v11;
            }
            while (v11);
            unsigned int v12 = v7;
          }
          else
          {
            unsigned int v12 = 0;
          }
          LODWORD(v81) = v12;
          if ((unsigned char *)__src != v79) {
            free((void *)__src);
          }
          uint64_t v13 = (void *)*((void *)v2 + 10);
          if (v13 != (void *)((char *)v2 + 72))
          {
            char v14 = 0;
            uint64_t v15 = *((void *)v2 + 3);
            while (1)
            {
              uint64_t v16 = v13 ? (llvm::BasicBlock *)(v13 - 3) : 0;
              unsigned int v17 = (void *)*((void *)v16 + 5);
              if (v17 != (void *)((char *)v16 + 40))
              {
                BOOL v18 = v17 - 3;
                if (!v17) {
                  BOOL v18 = 0;
                }
                unsigned int v19 = *((unsigned __int8 *)v18 + 16) - 40;
                if (v19 < 0xFFFFFFF5) {
                  BOOL v18 = 0;
                }
                if (v17)
                {
                  if (*((unsigned char *)v18 + 16) == 29 && v19 >= 0xFFFFFFF5)
                  {
                    uint64_t v21 = *((_DWORD *)v18 + 5) & 0x7FFFFFF;
                    if (v21)
                    {
                      if (*(void *)v18[-4 * v21] != **(void **)(v15 + 16)) {
                        break;
                      }
                    }
                  }
                }
              }
              v14 |= llvm::BasicBlock::getTerminatingMustTailCall(v16) != 0;
              uint64_t v13 = (void *)v13[1];
              if (v13 == (void *)((char *)v2 + 72)) {
                goto LABEL_45;
              }
            }
LABEL_121:
            llvm::DeadArgumentEliminationPass::MarkLive(this, v2);
LABEL_147:
            char v64 = (char *)v80;
            int64_t v65 = v69;
            if (v81)
            {
              uint64_t v66 = 96 * v81;
              do
              {
                unsigned int v67 = *(char **)&v64[v66 - 96];
                if (&v64[v66 - 80] != v67)
                {
                  free(v67);
                  int64_t v65 = v69;
                }
                v66 -= 96;
              }
              while (v66);
              char v64 = (char *)v80;
            }
            if (v64 != v65) {
              free(v64);
            }
            if (v83 != v9) {
              free(v83);
            }
            return;
          }
          char v14 = 0;
LABEL_45:
          int v22 = *((_DWORD *)v2 + 8);
          unsigned int v23 = v74;
          if ((v22 & 0xFu) - 7 >= 2 && ((v22 & 0x2000) != 0 || !*((unsigned char *)this + 72))) {
            goto LABEL_121;
          }
          BOOL v68 = v85;
          uint64_t v24 = *((void *)v2 + 1);
          if (v24)
          {
            int v25 = 0;
            unsigned int v26 = 0;
            uint64_t v75 = v79;
            while (1)
            {
              uint64_t v73 = v24;
              uint64_t v27 = *(void *)(v24 + 24);
              unsigned int v28 = *(unsigned __int8 *)(v27 + 16);
              if (v28 < 0x1C) {
                break;
              }
              BOOL v29 = v28 - 33 > 0x33 || ((1 << (v28 - 33)) & 0x8000000000041) == 0;
              if (v29 || v27 - 32 != v73 || *(void *)(v27 + 72) != *((void *)v2 + 3)) {
                break;
              }
              int v72 = v25;
              BOOL v71 = v28 == 84 && (*(_WORD *)(v27 + 18) & 3) == 2;
              unsigned int i = v23;
              if (v26 != v23)
              {
                int v30 = *(_DWORD *)(v27 + 20);
                if (v30 < 0)
                {
                  unint64_t v48 = *(void *)(v27 - 32 * (v30 & 0x7FFFFFF) - 8);
                  if ((v48 & 0xFFFFFFFF0) != 0)
                  {
                    uint64_t v49 = (v48 >> 4);
                    uint64_t v50 = v27 - 8;
                    do
                    {
                      if (*(_DWORD *)(*(void *)(v50
                                                 - (*(void *)(v27 - 8 - 32 * (*(_DWORD *)(v27 + 20) & 0x7FFFFFF))
                                                  + 32 * (*(_DWORD *)(v27 + 20) & 0x7FFFFFF)))
                                     + 8) == 6)
                      {
                        if (HIDWORD(v84) < v74)
                        {
                          LODWORD(v84) = 0;
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        uint64_t v51 = (char *)v83;
                        uint64_t v52 = v84;
                        if (v84 >= v8) {
                          unint64_t v53 = v8;
                        }
                        else {
                          unint64_t v53 = v84;
                        }
                        if (v53) {
                          bzero(v83, 4 * v53);
                        }
                        if (v52 < v74) {
                          bzero(&v51[4 * v52], 4 * (v8 - v52));
                        }
                        unsigned int v26 = v74;
                        LODWORD(v84) = v74;
                      }
                      v50 += 16;
                      --v49;
                      uint64_t v2 = v70;
                    }
                    while (v49);
                  }
                  else
                  {
                    uint64_t v2 = v70;
                  }
                }
                uint64_t v31 = *(void *)(v27 + 8);
                for (i = v26; v31; uint64_t v31 = *(void *)(v31 + 8))
                {
                  uint64_t v32 = *(void *)(v31 + 24);
                  if (v32 && *(unsigned char *)(v32 + 16) == 92)
                  {
                    uint64_t v33 = **(unsigned int **)(v32 + 64);
                    uint64_t v34 = v83;
                    if (*((_DWORD *)v83 + v33))
                    {
                      uint64_t v35 = *(void *)(v32 + 8);
                      if (v35)
                      {
                        uint64_t v36 = (char *)v80 + 96 * v33;
                        while (llvm::DeadArgumentEliminationPass::SurveyUse((uint64_t)this, v35, (uint64_t)v36, 0xFFFFFFFFLL))
                        {
                          uint64_t v35 = *(void *)(v35 + 8);
                          if (!v35)
                          {
                            int v37 = 1;
                            goto LABEL_97;
                          }
                        }
                        int v37 = 0;
LABEL_97:
                        uint64_t v34 = v83;
                      }
                      else
                      {
                        int v37 = 1;
                      }
                      unsigned int v47 = i;
                      v34[v33] = v37;
                      unsigned int i = (v37 ^ 1) + v47;
                    }
                  }
                  else
                  {
                    *(void *)&long long __src = v75;
                    *((void *)&__src + 1) = 0x500000000;
                    int v38 = llvm::DeadArgumentEliminationPass::SurveyUse((uint64_t)this, v31, (uint64_t)&__src, 0xFFFFFFFFLL);
                    if (v38)
                    {
                      if (v74)
                      {
                        uint64_t v39 = 0;
                        uint64_t v40 = 0;
                        do
                        {
                          if (*((_DWORD *)v83 + v40))
                          {
                            uint64_t v41 = (char *)v80 + v39;
                            int v42 = DWORD2(__src);
                            uint64_t v43 = *(unsigned int *)((char *)v80 + v39 + 8);
                            if (v43 + (unint64_t)DWORD2(__src) > *(unsigned int *)((char *)v80 + v39 + 12)) {
                              llvm::SmallVectorBase<unsigned int>::grow_pod();
                            }
                            if (DWORD2(__src))
                            {
                              memcpy((void *)(*(void *)v41 + 16 * v43), (const void *)__src, 16 * DWORD2(__src));
                              LODWORD(v43) = *((_DWORD *)v41 + 2);
                            }
                            *((_DWORD *)v41 + 2) = v43 + v42;
                          }
                          ++v40;
                          v39 += 96;
                        }
                        while (v8 != v40);
                        uint64_t v2 = v70;
                      }
                    }
                    else
                    {
                      if (HIDWORD(v84) < v74)
                      {
                        LODWORD(v84) = 0;
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      uint64_t v44 = (char *)v83;
                      uint64_t v45 = v84;
                      if (v84 >= v8) {
                        unint64_t v46 = v8;
                      }
                      else {
                        unint64_t v46 = v84;
                      }
                      if (v46) {
                        bzero(v83, 4 * v46);
                      }
                      if (v45 < v74) {
                        bzero(&v44[4 * v45], 4 * (v8 - v45));
                      }
                      LODWORD(v84) = v74;
                      unsigned int i = v74;
                    }
                    if ((unsigned char *)__src != v75) {
                      free((void *)__src);
                    }
                    if (!v38) {
                      break;
                    }
                  }
                }
              }
              int v25 = v71 | v72;
              uint64_t v24 = *(void *)(v73 + 8);
              unsigned int v26 = i;
              unsigned int v23 = v74;
              if (!v24) {
                goto LABEL_123;
              }
            }
            llvm::DeadArgumentEliminationPass::MarkLive(this, v2);
            goto LABEL_146;
          }
          LOBYTE(v25) = 0;
LABEL_123:
          if (v23)
          {
            uint64_t v54 = 0;
            uint64_t v55 = 0;
            do
            {
              *(void *)&long long __src = v2;
              *((void *)&__src + 1) = v55;
              llvm::DeadArgumentEliminationPass::MarkValue((uint64_t)this, &__src, *((_DWORD *)v83 + v55++), (uint64_t)v80 + v54);
              v54 += 96;
            }
            while (v8 != v55);
          }
          *(void *)&long long __src = v79;
          *((void *)&__src + 1) = 0x500000000;
          if (*((unsigned char *)v2 + 18))
          {
            llvm::Function::BuildLazyArguments(v2);
            uint64_t v57 = *((void *)v2 + 11);
            char v56 = v25;
            if (*((_WORD *)v2 + 9))
            {
              llvm::Function::BuildLazyArguments(v2);
              uint64_t v58 = *((void *)v2 + 11);
              goto LABEL_135;
            }
          }
          else
          {
            char v56 = v25;
            uint64_t v57 = *((void *)v2 + 11);
          }
          uint64_t v58 = v57;
LABEL_135:
          uint64_t v59 = v58 + 40 * *((void *)v2 + 12);
          if (v57 == v59)
          {
LABEL_144:
            if ((unsigned char *)__src != v79) {
              free((void *)__src);
            }
LABEL_146:
            BOOL v9 = v68;
            goto LABEL_147;
          }
          unsigned int v60 = 0;
          char v61 = v56 | v14;
          while (1)
          {
            if (!((*(_DWORD *)(*((void *)v2 + 3) + 8) > 0xFFu) | v61 & 1))
            {
              uint64_t v63 = *(void *)(v57 + 8);
              if (!v63)
              {
LABEL_142:
                int v62 = 1;
                goto LABEL_143;
              }
              while (llvm::DeadArgumentEliminationPass::SurveyUse((uint64_t)this, v63, (uint64_t)&__src, 0xFFFFFFFFLL))
              {
                uint64_t v63 = *(void *)(v63 + 8);
                if (!v63) {
                  goto LABEL_142;
                }
              }
            }
            int v62 = 0;
LABEL_143:
            *(void *)&long long v77 = v2;
            *((void *)&v77 + 1) = v60 | 0x100000000;
            llvm::DeadArgumentEliminationPass::MarkValue((uint64_t)this, &v77, v62, (uint64_t)&__src);
            DWORD2(__src) = 0;
            v57 += 40;
            ++v60;
            if (v57 == v59) {
              goto LABEL_144;
            }
          }
        }
LABEL_131:
        memset_pattern16(v85, &unk_1CFAC30F0, 4 * v8);
        goto LABEL_15;
      case 16:
        unsigned int v7 = *(_DWORD *)(v5 + 12);
        goto LABEL_13;
      default:
        unsigned int v7 = 1;
        break;
    }
    unint64_t v8 = v7;
    BOOL v9 = v85;
    uint64_t v83 = v85;
    uint64_t v84 = 0x500000000;
    if (!v7) {
      goto LABEL_15;
    }
    goto LABEL_131;
  }

  llvm::DeadArgumentEliminationPass::MarkLive(this, a2);
}

void llvm::DeadArgumentEliminationPass::MarkLive(llvm::DeadArgumentEliminationPass *this, const llvm::Function *a2)
{
  uint64_t v5 = (uint64_t **)((char *)this + 56);
  uint64_t v4 = (uint64_t *)*((void *)this + 7);
  if (v4)
  {
    do
    {
      while (1)
      {
        int v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if (v7 <= (unint64_t)a2) {
          break;
        }
        uint64_t v4 = *v6;
        uint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_7;
        }
      }
      if (v7 >= (unint64_t)a2) {
        goto LABEL_10;
      }
      uint64_t v4 = v6[1];
    }
    while (v4);
    uint64_t v5 = v6 + 1;
  }
  else
  {
    int v6 = (uint64_t **)((char *)this + 56);
  }
LABEL_7:
  unint64_t v8 = (uint64_t *)operator new(0x28uLL);
  void v8[4] = (uint64_t)a2;
  *unint64_t v8 = 0;
  v8[1] = 0;
  void v8[2] = (uint64_t)v6;
  void *v5 = v8;
  uint64_t v9 = **((void **)this + 6);
  if (v9)
  {
    *((void *)this + 6) = v9;
    unint64_t v8 = *v5;
  }
  sub_1CB8358B8(*((uint64_t **)this + 7), v8);
  ++*((void *)this + 8);
LABEL_10:
  int v10 = *((_DWORD *)a2 + 24);
  if (v10)
  {
    unsigned int v11 = 0;
    unsigned int v12 = (uint64_t *)((char *)this + 8);
    do
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        char v14 = (uint64_t *)((char *)this + 8);
        do
        {
          unint64_t v15 = *(void *)(v13 + 32);
          if (v15 >= (unint64_t)a2
            && (v15 > (unint64_t)a2
             || (unsigned int v16 = *(_DWORD *)(v13 + 40), v16 >= v11) && (v11 < v16 || *(unsigned char *)(v13 + 44))))
          {
            char v14 = (uint64_t *)v13;
          }
          else
          {
            v13 += 8;
          }
          uint64_t v13 = *(void *)v13;
        }
        while (v13);
        unsigned int v17 = (uint64_t *)((char *)this + 8);
        if (v14 != v12)
        {
          unsigned int v17 = v14;
          while ((const llvm::Function *)v17[4] == a2 && *((_DWORD *)v17 + 10) == v11 && *((unsigned char *)v17 + 44))
          {
            llvm::DeadArgumentEliminationPass::MarkLive((uint64_t)this, (uint64_t)(v17 + 6));
            unsigned int v19 = (uint64_t *)v17[1];
            if (v19)
            {
              do
              {
                BOOL v20 = v19;
                unsigned int v19 = (uint64_t *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                BOOL v20 = (uint64_t *)v17[2];
                BOOL v21 = *v20 == (void)v17;
                unsigned int v17 = v20;
              }
              while (!v21);
            }
            unsigned int v17 = v20;
            if (v20 == v12)
            {
              unsigned int v17 = (uint64_t *)((char *)this + 8);
              break;
            }
          }
        }
        if (v17 != v14)
        {
          do
          {
            BOOL v18 = sub_1CC904DE8((uint64_t **)this, v14);
            operator delete(v14);
            char v14 = v18;
          }
          while (v17 != v18);
        }
      }
      ++v11;
    }
    while (v11 != v10);
  }
  uint64_t v22 = **(void **)(*((void *)a2 + 3) + 16);
  int v23 = *(unsigned __int8 *)(v22 + 8);
  if (v23 != 7)
  {
    if (v23 == 17)
    {
      int v24 = *(_DWORD *)(v22 + 32);
      if (!v24) {
        return;
      }
    }
    else if (v23 == 16)
    {
      int v24 = *(_DWORD *)(v22 + 12);
      if (!v24) {
        return;
      }
    }
    else
    {
      int v24 = 1;
    }
    unsigned int v25 = 0;
    unsigned int v26 = (uint64_t *)((char *)this + 8);
    do
    {
      uint64_t v27 = *v26;
      if (*v26)
      {
        unsigned int v28 = (uint64_t *)((char *)this + 8);
        do
        {
          unint64_t v29 = *(void *)(v27 + 32);
          if (v29 < (unint64_t)a2 || v29 <= (unint64_t)a2 && *(_DWORD *)(v27 + 40) < v25) {
            v27 += 8;
          }
          else {
            unsigned int v28 = (uint64_t *)v27;
          }
          uint64_t v27 = *(void *)v27;
        }
        while (v27);
        int v30 = (uint64_t *)((char *)this + 8);
        if (v28 != v26)
        {
          int v30 = v28;
          while ((const llvm::Function *)v30[4] == a2 && *((_DWORD *)v30 + 10) == v25 && !*((unsigned char *)v30 + 44))
          {
            llvm::DeadArgumentEliminationPass::MarkLive((uint64_t)this, (uint64_t)(v30 + 6));
            uint64_t v32 = (uint64_t *)v30[1];
            if (v32)
            {
              do
              {
                uint64_t v33 = v32;
                uint64_t v32 = (uint64_t *)*v32;
              }
              while (v32);
            }
            else
            {
              do
              {
                uint64_t v33 = (uint64_t *)v30[2];
                BOOL v21 = *v33 == (void)v30;
                int v30 = v33;
              }
              while (!v21);
            }
            int v30 = v33;
            if (v33 == v26)
            {
              int v30 = (uint64_t *)((char *)this + 8);
              break;
            }
          }
        }
        if (v30 != v28)
        {
          do
          {
            uint64_t v31 = sub_1CC904DE8((uint64_t **)this, v28);
            operator delete(v28);
            unsigned int v28 = v31;
          }
          while (v30 != v31);
        }
      }
      ++v25;
    }
    while (v25 != v24);
  }
}

void llvm::DeadArgumentEliminationPass::MarkValue(uint64_t a1, long long *a2, int a3, uint64_t a4)
{
  if (a3)
  {
    if (a3 != 1) {
      return;
    }
    uint64_t v6 = *(unsigned int *)(a4 + 8);
    if (!v6) {
      return;
    }
    unint64_t v7 = *(uint64_t **)a4;
    uint64_t v8 = *(void *)a4 + 16 * v6;
    uint64_t v9 = (uint64_t **)(a1 + 8);
    while (1)
    {
      int v10 = *(void **)(a1 + 56);
      if (v10)
      {
        unint64_t v11 = *v7;
        do
        {
          unint64_t v12 = v10[4];
          if (v11 >= v12)
          {
            if (v12 >= v11) {
              goto LABEL_2;
            }
            ++v10;
          }
          int v10 = (void *)*v10;
        }
        while (v10);
      }
      if (sub_1CC904D78(*(void *)(a1 + 32), v7)) {
        break;
      }
      long long v24 = *(_OWORD *)v7;
      uint64_t v13 = (uint64_t *)operator new(0x40uLL);
      char v14 = v13;
      long long v15 = *a2;
      *((_OWORD *)v13 + 2) = v24;
      *((_OWORD *)v13 + 3) = v15;
      unsigned int v16 = *v9;
      unsigned int v17 = (uint64_t **)(a1 + 8);
      BOOL v18 = (uint64_t **)(a1 + 8);
      if (*v9)
      {
        unint64_t v19 = v13[4];
        unsigned int v20 = *((_DWORD *)v13 + 10);
        do
        {
          while (1)
          {
            unsigned int v17 = (uint64_t **)v16;
            unint64_t v21 = v16[4];
            if (v19 >= v21)
            {
              if (v21 < v19) {
                break;
              }
              unsigned int v22 = *((_DWORD *)v16 + 10);
              if (v20 >= v22
                && (v22 < v20 || *((unsigned __int8 *)v13 + 44) >= *((unsigned __int8 *)v16 + 44)))
              {
                break;
              }
            }
            unsigned int v16 = (uint64_t *)*v16;
            BOOL v18 = v17;
            if (!*v17) {
              goto LABEL_26;
            }
          }
          unsigned int v16 = (uint64_t *)v16[1];
        }
        while (v16);
        BOOL v18 = v17 + 1;
      }
LABEL_26:
      uint64_t *v13 = 0;
      v13[1] = 0;
      void v13[2] = (uint64_t)v17;
      *BOOL v18 = v13;
      uint64_t v23 = **(void **)a1;
      if (v23)
      {
        *(void *)a1 = v23;
        char v14 = *v18;
      }
      sub_1CB8358B8(*(uint64_t **)(a1 + 8), v14);
      ++*(void *)(a1 + 16);
      v7 += 2;
      if (v7 == (uint64_t *)v8) {
        return;
      }
    }
  }
LABEL_2:

  llvm::DeadArgumentEliminationPass::MarkLive(a1, (uint64_t)a2);
}

void llvm::DeadArgumentEliminationPass::MarkLive(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4)
  {
    unint64_t v5 = *(void *)a2;
    do
    {
      unint64_t v6 = v4[4];
      if (v5 >= v6)
      {
        if (v6 >= v5) {
          return;
        }
        ++v4;
      }
      uint64_t v4 = (void *)*v4;
    }
    while (v4);
  }
  uint64_t v8 = (void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 32);
  if (!sub_1CC904D78(v7, (uint64_t *)a2))
  {
    if (!v7)
    {
      unint64_t v11 = (void *)(a1 + 32);
      goto LABEL_20;
    }
    unint64_t v9 = *(void *)a2;
    unsigned int v10 = *(_DWORD *)(a2 + 8);
    while (1)
    {
      unint64_t v11 = (void *)v7;
      unint64_t v12 = *(void *)(v7 + 32);
      if (v9 < v12) {
        goto LABEL_19;
      }
      if (v12 < v9)
      {
LABEL_14:
        uint64_t v7 = *(void *)(v7 + 8);
        if (!v7)
        {
          uint64_t v8 = v11 + 1;
LABEL_20:
          unsigned int v16 = operator new(0x30uLL);
          void v16[2] = *(_OWORD *)a2;
          *(void *)unsigned int v16 = 0;
          *((void *)v16 + 1) = 0;
          *((void *)v16 + 2) = v11;
          *uint64_t v8 = v16;
          uint64_t v17 = **(void **)(a1 + 24);
          if (v17)
          {
            *(void *)(a1 + 24) = v17;
            unsigned int v16 = (_OWORD *)*v8;
          }
          sub_1CB8358B8(*(uint64_t **)(a1 + 32), (uint64_t *)v16);
          ++*(void *)(a1 + 40);
LABEL_23:
          unint64_t v19 = (uint64_t *)(a1 + 8);
          uint64_t v18 = *(void *)(a1 + 8);
          if (v18)
          {
            unint64_t v20 = *(void *)a2;
            unint64_t v21 = (uint64_t *)(a1 + 8);
            do
            {
              unint64_t v22 = *(void *)(v18 + 32);
              if (v22 >= v20
                && (v20 < v22
                 || (v23 = *(_DWORD *)(a2 + 8), unsigned int v24 = *(_DWORD *)(v18 + 40), v24 >= v23)
                 && (v23 < v24 || *(unsigned __int8 *)(v18 + 44) >= *(unsigned __int8 *)(a2 + 12))))
              {
                unint64_t v21 = (uint64_t *)v18;
              }
              else
              {
                v18 += 8;
              }
              uint64_t v18 = *(void *)v18;
            }
            while (v18);
            if (v21 != v19)
            {
              unsigned int v26 = v21;
              while (v26[4] == *(void *)a2
                   && *((_DWORD *)v26 + 10) == *(_DWORD *)(a2 + 8)
                   && *((unsigned __int8 *)v26 + 44) == *(unsigned __int8 *)(a2 + 12))
              {
                llvm::DeadArgumentEliminationPass::MarkLive(a1, v26 + 6);
                uint64_t v27 = (uint64_t *)v26[1];
                if (v27)
                {
                  do
                  {
                    unsigned int v28 = v27;
                    uint64_t v27 = (uint64_t *)*v27;
                  }
                  while (v27);
                }
                else
                {
                  do
                  {
                    unsigned int v28 = (uint64_t *)v26[2];
                    BOOL v29 = *v28 == (void)v26;
                    unsigned int v26 = v28;
                  }
                  while (!v29);
                }
                unsigned int v26 = v28;
                if (v28 == v19) {
                  goto LABEL_36;
                }
              }
              unint64_t v19 = v26;
            }
LABEL_36:
            if (v19 != v21)
            {
              do
              {
                unsigned int v25 = sub_1CC904DE8((uint64_t **)a1, v21);
                operator delete(v21);
                unint64_t v21 = v25;
              }
              while (v19 != v25);
            }
          }
          return;
        }
      }
      else
      {
        unsigned int v13 = *(_DWORD *)(v7 + 40);
        if (v10 >= v13)
        {
          if (v13 < v10) {
            goto LABEL_14;
          }
          unsigned int v14 = *(unsigned __int8 *)(a2 + 12);
          unsigned int v15 = *(unsigned __int8 *)(v7 + 44);
          if (v14 >= v15)
          {
            if (v15 >= v14) {
              goto LABEL_23;
            }
            goto LABEL_14;
          }
        }
LABEL_19:
        uint64_t v7 = *(void *)v7;
        uint64_t v8 = v11;
        if (!*v11) {
          goto LABEL_20;
        }
      }
    }
  }
}

void llvm::DeadArgumentEliminationPass::PropagateLiveness(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = (uint64_t *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    unint64_t v6 = *a2;
    uint64_t v7 = (uint64_t *)(a1 + 8);
    do
    {
      unint64_t v8 = *(void *)(v2 + 32);
      if (v8 >= v6
        && (v6 < v8
         || (unsigned int v9 = *((_DWORD *)a2 + 2), v10 = *(_DWORD *)(v2 + 40), v10 >= v9)
         && (v9 < v10 || *(unsigned __int8 *)(v2 + 44) >= *((unsigned __int8 *)a2 + 12))))
      {
        uint64_t v7 = (uint64_t *)v2;
      }
      else
      {
        v2 += 8;
      }
      uint64_t v2 = *(void *)v2;
    }
    while (v2);
    if (v7 != v3)
    {
      unint64_t v12 = v7;
      while (v12[4] == *a2
           && *((_DWORD *)v12 + 10) == *((_DWORD *)a2 + 2)
           && *((unsigned __int8 *)v12 + 44) == *((unsigned __int8 *)a2 + 12))
      {
        llvm::DeadArgumentEliminationPass::MarkLive(a1, (uint64_t)(v12 + 6));
        unsigned int v13 = (uint64_t *)v12[1];
        if (v13)
        {
          do
          {
            unsigned int v14 = v13;
            unsigned int v13 = (uint64_t *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            unsigned int v14 = (uint64_t *)v12[2];
            BOOL v15 = *v14 == (void)v12;
            unint64_t v12 = v14;
          }
          while (!v15);
        }
        unint64_t v12 = v14;
        if (v14 == v3) {
          goto LABEL_14;
        }
      }
      uint64_t v3 = v12;
    }
LABEL_14:
    if (v3 != v7)
    {
      do
      {
        unint64_t v11 = sub_1CC904DE8((uint64_t **)a1, v7);
        operator delete(v7);
        uint64_t v7 = v11;
      }
      while (v3 != v11);
    }
  }
}

uint64_t llvm::DeadArgumentEliminationPass::RemoveDeadStuffFromFunction(llvm::DeadArgumentEliminationPass *this, llvm::Function *a2)
{
  v265[8] = *MEMORY[0x1E4F143B8];
  for (unsigned int i = (void *)*((void *)this + 7); i; unsigned int i = (void *)*i)
  {
    unint64_t v4 = i[4];
    if (v4 <= (unint64_t)a2)
    {
      if (v4 >= (unint64_t)a2) {
        return 0;
      }
      ++i;
    }
  }
  uint64_t v5 = *((void *)a2 + 3);
  v263 = v265;
  uint64_t v264 = 0x800000000;
  uint64_t v6 = *((void *)a2 + 14);
  uint64_t v222 = v5;
  size_t v7 = (*(_DWORD *)(v5 + 12) - 1);
  v259 = v262;
  uint64_t v261 = 10;
  if (v7 >= 0xB)
  {
    size_t v260 = 0;
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v7) {
    bzero(v262, v7);
  }
  size_t v260 = v7;
  if ((*((_WORD *)a2 + 9) & 1) == 0)
  {
    unint64_t v8 = (void *)*((void *)a2 + 11);
    unsigned int v217 = (llvm::ValueAsMetadata **)((char *)a2 + 88);
LABEL_13:
    unsigned int v9 = v8;
    goto LABEL_16;
  }
  llvm::Function::BuildLazyArguments(a2);
  unint64_t v8 = (void *)*((void *)a2 + 11);
  unsigned int v217 = (llvm::ValueAsMetadata **)((char *)a2 + 88);
  if ((*((_WORD *)a2 + 9) & 1) == 0) {
    goto LABEL_13;
  }
  llvm::Function::BuildLazyArguments(a2);
  unsigned int v9 = (void *)*((void *)a2 + 11);
LABEL_16:
  uint64_t v234 = (void ***)a2;
  unint64_t v11 = &v9[5 * *((void *)a2 + 12)];
  if (v8 == v11)
  {
    BOOL v224 = 0;
    uint64_t v18 = 0;
    char v12 = 0;
  }
  else
  {
    char v12 = 0;
    unsigned int v13 = 0;
    unsigned int v14 = 0;
    BOOL v15 = 0;
    BOOL v224 = 0;
    int64x2_t v232 = (llvm::ValueAsMetadata *)(v6 + 40);
    do
    {
      uint64_t v16 = v13;
      v240[0] = v234;
      v240[1] = (void *)(v13 | 0x100000000);
      if (sub_1CC904E5C((uint64_t **)this + 3, (unint64_t *)v240))
      {
        uint64_t v17 = *v8;
        if (v15 >= v14)
        {
          uint64_t v19 = (v15 - v224) >> 3;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 61) {
LABEL_380:
          }
            abort();
          if ((v14 - v224) >> 2 > v20) {
            unint64_t v20 = (v14 - v224) >> 2;
          }
          if ((unint64_t)(v14 - v224) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v20;
          }
          if (v21)
          {
            if (v21 >> 61) {
LABEL_381:
            }
              sub_1CB833614();
            unint64_t v22 = (char *)operator new(8 * v21);
          }
          else
          {
            unint64_t v22 = 0;
          }
          unsigned int v23 = &v22[8 * v19];
          *(void *)unsigned int v23 = v17;
          uint64_t v18 = v23 + 8;
          if (v15 != v224)
          {
            do
            {
              uint64_t v24 = *((void *)v15 - 1);
              v15 -= 8;
              *((void *)v23 - 1) = v24;
              v23 -= 8;
            }
            while (v15 != v224);
            BOOL v15 = v224;
          }
          BOOL v224 = v23;
          unsigned int v14 = &v22[8 * v21];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)BOOL v15 = v17;
          uint64_t v18 = v15 + 8;
        }
        v259[v16] = 1;
        unsigned int v25 = v16 + 2;
        if (v6 && v25 < *(_DWORD *)(v6 + 8)) {
          uint64_t v26 = *((void *)v232 + v25);
        }
        else {
          uint64_t v26 = 0;
        }
        if (v264 >= (unint64_t)HIDWORD(v264)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v263[v264] = v26;
        LODWORD(v264) = v264 + 1;
        if (v6 && v25 < *(_DWORD *)(v6 + 8))
        {
          uint64_t v27 = *((void *)v232 + v25);
          if (v27) {
            LODWORD(v27) = (*(unsigned __int8 *)(v27 + 17) >> 6) & 1;
          }
        }
        else
        {
          LOBYTE(v27) = 0;
        }
        v12 |= v27;
        BOOL v15 = v18;
      }
      else
      {
        uint64_t v18 = v15;
      }
      unsigned int v13 = v16 + 1;
      v8 += 5;
    }
    while (v8 != v11);
  }
  unsigned int v28 = **(llvm::UndefValue ***)(v222 + 16);
  BOOL v29 = (const char ***)v234;
  uint64_t v30 = *(void *)v234[3][2];
  int v31 = *(unsigned __int8 *)(v30 + 8);
  unsigned int v228 = v28;
  switch(v31)
  {
    case 7:
      unsigned int v34 = 0;
      break;
    case 17:
      unsigned int v32 = *(_DWORD *)(v30 + 32);
      goto LABEL_57;
    case 16:
      unsigned int v32 = *(_DWORD *)(v30 + 12);
LABEL_57:
      unint64_t v33 = v32;
      v256 = v258;
      uint64_t v257 = 0x500000000;
      if (v32 >= 6) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unsigned int v34 = v32;
      goto LABEL_62;
    default:
      unsigned int v34 = 1;
      break;
  }
  unint64_t v33 = v34;
  v256 = v258;
  uint64_t v257 = 0x500000000;
LABEL_62:
  unsigned int v226 = v34;
  if (!v34)
  {
    unsigned int v36 = 0;
    unsigned int v223 = 0;
    uint64_t v35 = 0;
    LODWORD(v257) = 0;
    uint64_t v229 = v28;
    if (!((*((unsigned char *)v28 + 8) == 7) | v12 & 1)) {
      goto LABEL_101;
    }
    goto LABEL_114;
  }
  memset(v258, 255, 4 * v33);
  LODWORD(v257) = v226;
  if ((*((unsigned char *)v28 + 8) == 7) | v12 & 1)
  {
    unsigned int v223 = 0;
    uint64_t v35 = 0;
    uint64_t v229 = v28;
    unsigned int v36 = v226;
    goto LABEL_114;
  }
  int v37 = 0;
  uint64_t v35 = 0;
  unsigned int v223 = 0;
  int v38 = 0;
  do
  {
    v240[0] = v234;
    v240[1] = v37;
    if (!sub_1CC904E5C((uint64_t **)this + 3, (unint64_t *)v240)) {
      goto LABEL_98;
    }
    uint64_t v39 = *(void *)v234[3][2];
    int v40 = *(unsigned __int8 *)(v39 + 8);
    if (v39) {
      BOOL v41 = v40 == 16;
    }
    else {
      BOOL v41 = 0;
    }
    if (v41)
    {
      uint64_t v43 = (uint64_t *)(*(void *)(v39 + 16) + 8 * (void)v37);
    }
    else
    {
      if (v39) {
        BOOL v42 = v40 == 17;
      }
      else {
        BOOL v42 = 0;
      }
      if (!v42) {
        goto LABEL_79;
      }
      uint64_t v43 = (uint64_t *)(v39 + 24);
    }
    uint64_t v39 = *v43;
LABEL_79:
    if (v223 >= v38)
    {
      uint64_t v45 = v223 - v35;
      unint64_t v46 = v45 + 1;
      if ((unint64_t)(v45 + 1) >> 61) {
        goto LABEL_380;
      }
      if (((char *)v38 - (char *)v35) >> 2 > v46) {
        unint64_t v46 = ((char *)v38 - (char *)v35) >> 2;
      }
      if ((unint64_t)((char *)v38 - (char *)v35) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v47 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v47 = v46;
      }
      if (v47)
      {
        if (v47 >> 61) {
          goto LABEL_381;
        }
        unint64_t v48 = (char *)operator new(8 * v47);
      }
      else
      {
        unint64_t v48 = 0;
      }
      uint64_t v49 = &v48[8 * v45];
      *(void *)uint64_t v49 = v39;
      uint64_t v44 = v49 + 8;
      for (uint64_t j = v223; j != v35; --j)
      {
        uint64_t v51 = (uint64_t)*(j - 1);
        *((void *)v49 - 1) = v51;
        v49 -= 8;
      }
      int v38 = (llvm::ArrayType **)&v48[8 * v47];
      if (v35) {
        operator delete(v35);
      }
      uint64_t v35 = (llvm::ArrayType **)v49;
    }
    else
    {
      *unsigned int v223 = (llvm::ArrayType *)v39;
      uint64_t v44 = (char *)(v223 + 1);
    }
    *((_DWORD *)v256 + (void)v37) = ((unint64_t)(v44 - (char *)v35) >> 3) - 1;
    unsigned int v223 = (llvm::ArrayType **)v44;
LABEL_98:
    int v37 = (char *)v37 + 1;
  }
  while (v37 != (void *)v33);
  BOOL v29 = (const char ***)v234;
  unsigned int v36 = v226;
LABEL_101:
  if ((unint64_t)((char *)v223 - (char *)v35) <= 8)
  {
    if ((char *)v223 - (char *)v35 == 8)
    {
      uint64_t v229 = *v35;
    }
    else if (v35 == v223)
    {
      uint64_t v229 = (llvm::UndefValue *)(*(void *)**v29 + 1576);
      uint64_t v35 = v223;
    }
    else
    {
      uint64_t v229 = 0;
    }
  }
  else
  {
    if (*((_DWORD *)v28 + 2) != 16 || v28 == 0) {
      uint64_t v53 = (uint64_t)llvm::ArrayType::get(*v35, (llvm::Type *)(v223 - v35));
    }
    else {
      uint64_t v53 = llvm::StructType::get(*(uint64_t **)v28, (uint64_t)v35, v223 - v35, (*((_DWORD *)v28 + 2) >> 9) & 1);
    }
    uint64_t v229 = (llvm::UndefValue *)v53;
  }
LABEL_114:
  if (v6 && *(_DWORD *)(v6 + 8) > 1u)
  {
    uint64_t v182 = *(void *)(v6 + 48);
    v252 = **v29;
    v253 = v255;
    uint64_t v254 = 0x800000000;
    if (v182)
    {
      uint64_t v54 = (char *)(v182 + 48);
      uint64_t v55 = (char *)(v182 + 48 + 8 * *(unsigned int *)(v182 + 8));
    }
    else
    {
      uint64_t v54 = 0;
      uint64_t v55 = 0;
    }
  }
  else
  {
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    v252 = **v29;
    v253 = v255;
    uint64_t v254 = 0x800000000;
  }
  sub_1CC512940((uint64_t)&v253, (uint64_t)v255, v54, v55);
  if (*((unsigned char *)v229 + 8) == 7)
  {
    v242 = 0;
    uint64_t v243 = 0;
    uint64_t v241 = (uint64_t)&v242;
    v240[1] = (void *)14328;
    v240[0] = (void *)0x80013090004C0002;
    llvm::AttrBuilder::remove((uint64_t)&v252, (uint64_t)v240);
    sub_1CC1E4850((uint64_t)&v241, v242);
  }
  uint64_t Sorted = llvm::AttributeSetNode::getSorted((uint64_t *)**v29, (uint64_t *)v253, v254);
  std::string __p = v35;
  if (v6 && *(_DWORD *)(v6 + 8)) {
    uint64_t v57 = *(void **)(v6 + 40);
  }
  else {
    uint64_t v57 = 0;
  }
  v240[0] = v57;
  uint64_t v58 = llvm::AttributeSet::removeAttribute((uint64_t *)v240, (uint64_t *)**v29, 75);
  uint64_t v59 = llvm::AttributeList::get((uint64_t *)**v29, v58, Sorted, v263, v264);
  uint64_t v60 = llvm::FunctionType::get((uint64_t **)v229, (uint64_t)v224, (v18 - v224) >> 3, *(_DWORD *)(v222 + 8) > 0xFFu);
  uint64_t v10 = v60 != v222;
  if (v60 != v222)
  {
    char v61 = (llvm::PointerType *)v60;
    unsigned int v227 = v36;
    char v62 = v29[4] & 0xF;
    uint64_t v63 = (llvm::Type *)(*((_DWORD *)*v29 + 2) >> 8);
    LOWORD(v243) = 257;
    char v64 = (char *)operator new(0x80uLL);
    int64_t v65 = (llvm::Value *)(v64 + 8);
    *((_DWORD *)v64 + 7) = *((_DWORD *)v64 + 7) & 0x38000000 | 0x40000000;
    *(void *)char v64 = 0;
    unsigned int v221 = (uint64_t **)v61;
    uint64_t v66 = llvm::Function::Function((unint64_t *)v64 + 1, v61, v62, v63, (const char **)v240, 0);
    llvm::Function::copyAttributesFrom((llvm::Function *)v66, (const llvm::Function *)v29);
    llvm::GlobalObject::setComdat((llvm::GlobalObject *)(v64 + 8), (llvm::Comdat *)v29[6]);
    *((void *)v64 + 15) = v59;
    unsigned int v67 = v29[5];
    *((void *)v64 + 6) = v67;
    unsigned int v219 = v64;
    if ((v64[31] & 0x10) != 0)
    {
      BOOL v68 = (llvm::ValueSymbolTable *)v67[14];
      if (v68) {
        llvm::ValueSymbolTable::reinsertValue(v68, v65);
      }
    }
    unsigned int v216 = v10;
    __int16 v69 = v29[7];
    *((void *)v64 + 8) = v69;
    *((void *)v64 + 9) = v29 + 7;
    v69[1] = v64 + 64;
    v29[7] = (const char **)(v64 + 64);
    unint64_t v220 = (llvm::Function *)(v64 + 8);
    llvm::Value::takeName((int32x2_t ****)v65, (llvm::Value *)v29);
    uint64_t v70 = v29[1];
    BOOL v71 = 0;
    if (v70)
    {
      int v72 = 0;
      uint64_t v73 = (char *)v70[3];
      LODWORD(v264) = 0;
      uint64_t v74 = *((void *)v73 + 8);
      if (v74 && *(_DWORD *)(v74 + 8) > 1u)
      {
        uint64_t v147 = *(void *)(v74 + 48);
        v247 = **v29;
        v248 = &v250;
        uint64_t v249 = 0x800000000;
        if (v147)
        {
          uint64_t v75 = (char *)(v147 + 48);
          unint64_t v76 = (char *)(v147 + 48 + 8 * *(unsigned int *)(v147 + 8));
        }
        else
        {
          uint64_t v75 = 0;
          unint64_t v76 = 0;
        }
      }
      else
      {
        uint64_t v75 = 0;
        unint64_t v76 = 0;
        v247 = **v29;
        v248 = &v250;
        uint64_t v249 = 0x800000000;
      }
      sub_1CC512940((uint64_t)&v248, (uint64_t)&v250, v75, v76);
      v240[0] = 0;
      v240[1] = 0;
      v242 = 0;
      uint64_t v243 = 0;
      uint64_t v241 = (uint64_t)&v242;
      int v77 = *((unsigned __int8 *)v229 + 8);
      if (v77 == 13)
      {
        unint64_t v78 = 0x80003080004C0000;
        uint64_t v79 = 13296;
LABEL_135:
        v240[0] = (void *)v78;
        v240[1] = (void *)v79;
      }
      else
      {
        *(_OWORD *)uint64_t v240 = xmmword_1CFAC6340;
        if (v77 != 15)
        {
          unint64_t v78 = 0x80013080004C0002;
          uint64_t v79 = 13304;
          goto LABEL_135;
        }
        unint64_t v78 = 0x1000000000002;
        uint64_t v79 = 8;
      }
      int v80 = v77;
      if ((v77 & 0xFE) == 0x12) {
        int v80 = *(unsigned __int8 *)(**((void **)v229 + 2) + 8);
      }
      if (v80 != 15) {
        v240[1] = (void *)(v79 | 0x400);
      }
      if (v77 == 7) {
        v240[0] = (void *)(v78 | 0x1000000000);
      }
      llvm::AttrBuilder::remove((uint64_t)&v247, (uint64_t)v240);
      sub_1CC1E4850((uint64_t)&v241, v242);
      uint64_t v225 = llvm::AttributeSetNode::getSorted((uint64_t *)**v29, (uint64_t *)v248, v249);
      v233 = (llvm::ValueAsMetadata *)v73;
      uint64_t v81 = &v73[-32 * (*((_DWORD *)v73 + 5) & 0x7FFFFFF)];
      int v82 = *(_DWORD *)(v222 + 12);
      uint64_t v83 = (v82 - 1);
      if (v82 != 1)
      {
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        while (!v259[v84])
        {
          uint64_t v87 = v85;
LABEL_169:
          v81 += 32;
          ++v84;
          uint64_t v85 = v87;
          if (v84 == v83) {
            goto LABEL_180;
          }
        }
        uint64_t v86 = *(void *)v81;
        if (v85 >= v72)
        {
          uint64_t v88 = (v85 - v71) >> 3;
          unint64_t v89 = v88 + 1;
          if ((unint64_t)(v88 + 1) >> 61) {
            goto LABEL_380;
          }
          if ((v72 - v71) >> 2 > v89) {
            unint64_t v89 = (v72 - v71) >> 2;
          }
          if ((unint64_t)(v72 - v71) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v90 = v89;
          }
          if (v90)
          {
            if (v90 >> 61) {
              goto LABEL_381;
            }
            uint64_t v91 = (char *)operator new(8 * v90);
          }
          else
          {
            uint64_t v91 = 0;
          }
          uint64_t v92 = &v91[8 * v88];
          *(void *)uint64_t v92 = v86;
          uint64_t v87 = v92 + 8;
          while (v85 != v71)
          {
            uint64_t v93 = *((void *)v85 - 1);
            v85 -= 8;
            *((void *)v92 - 1) = v93;
            v92 -= 8;
          }
          int v72 = &v91[8 * v90];
          if (v71) {
            operator delete(v71);
          }
          BOOL v71 = v92;
          if (!v74) {
            goto LABEL_166;
          }
LABEL_165:
          if ((v84 + 2) >= *(_DWORD *)(v74 + 8)) {
            goto LABEL_166;
          }
          uint64_t v94 = *(void *)(v74 + 40 + 8 * (v84 + 2));
          if (v229 != v228 && v94 && (*(unsigned char *)(v94 + 17) & 0x40) != 0)
          {
            v240[0] = **v234;
            long long v95 = (uint64_t *)v240[0];
            v240[1] = &v242;
            uint64_t v241 = 0x800000000;
            sub_1CC512940((uint64_t)&v240[1], (uint64_t)&v242, (char *)(v94 + 48), (char *)(v94 + 48 + 8 * *(unsigned int *)(v94 + 8)));
            llvm::AttrBuilder::removeAttribute((uint64_t)v240, 46);
            uint64_t v96 = llvm::AttributeSetNode::getSorted(v95, (uint64_t *)v240[1], v241);
            if (v264 >= (unint64_t)HIDWORD(v264)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v263[v264] = v96;
            LODWORD(v264) = v264 + 1;
            if (v240[1] != &v242) {
              free(v240[1]);
            }
            goto LABEL_169;
          }
        }
        else
        {
          *(void *)uint64_t v85 = v86;
          uint64_t v87 = v85 + 8;
          if (v74) {
            goto LABEL_165;
          }
LABEL_166:
          uint64_t v94 = 0;
        }
        if (v264 >= (unint64_t)HIDWORD(v264)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v263[v264] = v94;
        LODWORD(v264) = v264 + 1;
        goto LABEL_169;
      }
      uint64_t v87 = 0;
LABEL_180:
      uint64_t v97 = v233;
      int v98 = *((unsigned __int8 *)v233 + 16);
      if (v98 == 84)
      {
        uint64_t v99 = 0;
      }
      else if (v98 == 39)
      {
        uint64_t v97 = v233;
        uint64_t v99 = (*((_DWORD *)v233 + 20) + 1);
      }
      else
      {
        uint64_t v99 = 2;
        uint64_t v97 = v233;
      }
      int v100 = *((_DWORD *)v97 + 5);
      if (v100 < 0)
      {
        uint64_t v163 = (char *)v97 - 32 * (v100 & 0x7FFFFFF);
        uint64_t v164 = *((void *)v163 - 1);
        if ((v164 & 0xFFFFFFFF0) != 0) {
          uint64_t v101 = (*((_DWORD *)v163 - 3) - *(_DWORD *)&v163[-v164]);
        }
        else {
          uint64_t v101 = 0;
        }
        uint64_t v97 = v233;
      }
      else
      {
        uint64_t v101 = 0;
      }
      uint64_t v102 = (uint64_t)v97 + -32 * v101 + -32 * v99 - 32;
      if (v81 != (char *)v102)
      {
        while (2)
        {
          uint64_t v103 = *(void *)v81;
          if (v87 >= v72)
          {
            uint64_t v104 = (v87 - v71) >> 3;
            unint64_t v105 = v104 + 1;
            if ((unint64_t)(v104 + 1) >> 61) {
              goto LABEL_380;
            }
            if ((v72 - v71) >> 2 > v105) {
              unint64_t v105 = (v72 - v71) >> 2;
            }
            if ((unint64_t)(v72 - v71) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v106 = v105;
            }
            if (v106)
            {
              if (v106 >> 61) {
                goto LABEL_381;
              }
              __int16 v107 = (char *)operator new(8 * v106);
            }
            else
            {
              __int16 v107 = 0;
            }
            long long v108 = &v107[8 * v104];
            *(void *)long long v108 = v103;
            uint64_t v109 = v108 + 8;
            while (v87 != v71)
            {
              uint64_t v110 = *((void *)v87 - 1);
              v87 -= 8;
              *((void *)v108 - 1) = v110;
              v108 -= 8;
            }
            int v72 = &v107[8 * v106];
            if (v71) {
              operator delete(v71);
            }
            BOOL v71 = v108;
            uint64_t v87 = v109;
            if (!v74) {
              goto LABEL_205;
            }
LABEL_204:
            if ((v83 + 2) >= *(_DWORD *)(v74 + 8)) {
              goto LABEL_205;
            }
            uint64_t v111 = *(void *)(v74 + 40 + 8 * (v83 + 2));
          }
          else
          {
            *(void *)uint64_t v87 = v103;
            v87 += 8;
            if (v74) {
              goto LABEL_204;
            }
LABEL_205:
            uint64_t v111 = 0;
          }
          if (v264 >= (unint64_t)HIDWORD(v264)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v263[v264] = v111;
          LODWORD(v264) = v264 + 1;
          v81 += 32;
          LODWORD(v83) = v83 + 1;
          if (v81 == (char *)v102) {
            break;
          }
          continue;
        }
      }
      if (v74)
      {
        uint64_t v112 = (uint64_t)v233;
        uint64_t v113 = (uint64_t ***)v234;
        if (*(_DWORD *)(v74 + 8)) {
          uint64_t v114 = *(void **)(v74 + 40);
        }
        else {
          uint64_t v114 = 0;
        }
      }
      else
      {
        uint64_t v114 = 0;
        uint64_t v112 = (uint64_t)v233;
        uint64_t v113 = (uint64_t ***)v234;
      }
      v240[0] = v114;
      uint64_t v115 = llvm::AttributeSet::removeAttribute((uint64_t *)v240, **v113, 75);
      uint64_t v116 = llvm::AttributeList::get(**v113, v115, v225, v263, v264);
      unsigned int v244 = &v246;
      uint64_t v245 = 0x100000000;
      int v117 = *(_DWORD *)(v112 + 20);
      if (v117 < 0)
      {
        unint64_t v165 = *(void *)(v112 - 32 * (v117 & 0x7FFFFFF) - 8);
        if ((v165 & 0xFFFFFFFF0) != 0)
        {
          uint64_t v166 = (v165 >> 4);
          uint64_t v167 = v112;
          do
          {
            uint64_t v168 = *(_DWORD *)(v112 + 20) & 0x7FFFFFF;
            uint64_t v169 = v112 - 32 * v168;
            BOOL v170 = (unsigned int *)(v167 - (*(void *)(v169 - 8) + 32 * v168));
            uint64_t v171 = *v170;
            uint64_t v172 = v170[1];
            uint64_t v173 = *((void *)v170 - 1);
            v240[0] = (void *)(v169 + 32 * v171);
            v240[1] = (void *)(v172 - v171);
            uint64_t v241 = v173;
            sub_1CD5C74F0((uint64_t)&v244, (uint64_t)v240);
            v167 += 16;
            --v166;
          }
          while (v166);
        }
      }
      if (*(unsigned char *)(v112 + 16) == 33)
      {
        uint64_t v148 = *((void *)v219 + 4);
        uint64_t v149 = *(void *)(v112 - 96);
        uint64_t v150 = *(void *)(v112 - 64);
        LOWORD(v243) = 257;
        uint64_t v128 = sub_1CD661590(v148, (uint64_t)v220, v149, v150, (uint64_t *)v71, (v87 - v71) >> 3, (uint64_t)v244, v245, (const char **)v240, *(llvm::BasicBlock **)(v112 + 40));
        __int16 v136 = *((_WORD *)v128 + 9);
        unint64_t v137 = (char *)v223 - (char *)__p;
      }
      else
      {
        uint64_t v231 = v116;
        char v118 = (char *)v244;
        uint64_t v119 = v245;
        LOWORD(v243) = 257;
        int v120 = 0;
        if (v245)
        {
          uint64_t v174 = 48 * v245;
          uint64_t v175 = (char *)v244 + 32;
          do
          {
            v120 += (*v175 - *(v175 - 1)) >> 3;
            v175 += 6;
            v174 -= 48;
          }
          while (v174);
        }
        uint64_t v121 = v87 - v71;
        int v122 = ((unint64_t)v121 >> 3) + 1;
        uint64_t v123 = (v120 + v122);
        uint64_t v124 = (16 * v245);
        if (v124) {
          uint64_t v125 = (16 * v245) | 8u;
        }
        else {
          uint64_t v125 = 0;
        }
        uint64_t v126 = (char *)operator new(v125 + 32 * v123 + 80);
        uint64_t v127 = &v126[v125];
        uint64_t v128 = &v126[32 * v123 + v125];
        *((_DWORD *)v128 + 5) = v123 & 0x7FFFFFF | ((v124 != 0) << 31) | *((_DWORD *)v128 + 5) & 0x38000000;
        if (v123)
        {
          do
          {
            *(void *)uint64_t v127 = 0;
            *((void *)v127 + 1) = 0;
            *((void *)v127 + 2) = 0;
            *((void *)v127 + 3) = v128;
            v127 += 32;
          }
          while (v127 != v128);
        }
        uint64_t v129 = v221;
        if (v124) {
          *(void *)&v126[v124] = v124;
        }
        int v130 = 0;
        if (v119)
        {
          uint64_t v176 = 48 * v119;
          uint64_t v177 = v118 + 32;
          unsigned int v131 = (uint64_t **)v220;
          do
          {
            v130 += (*v177 - *(v177 - 1)) >> 3;
            v177 += 6;
            v176 -= 48;
          }
          while (v176);
        }
        else
        {
          unsigned int v131 = (uint64_t **)v220;
        }
        *(void *)uint64_t v128 = *v221[2];
        *((void *)v128 + 1) = 0;
        unsigned int v132 = *((_DWORD *)v128 + 5) & 0xC0000000 | (v130 + v122) & 0x7FFFFFF;
        *((_DWORD *)v128 + 4) = 84;
        *((_DWORD *)v128 + 5) = v132;
        *(_OWORD *)(v128 + 24) = 0u;
        char v133 = v128 + 24;
        *(_OWORD *)(v128 + 40) = 0u;
        *((_DWORD *)v128 + 14) = 0;
        uint64_t v112 = (uint64_t)v233;
        uint64_t v134 = *((void *)v233 + 5);
        *((void *)v128 + 5) = v134;
        *(_WORD *)(v134 + 18) &= ~0x8000u;
        if ((v128[23] & 0x10) != 0)
        {
          uint64_t v151 = *(void *)(v134 + 56);
          if (v151)
          {
            unsigned int v152 = *(llvm::ValueSymbolTable **)(v151 + 104);
            if (v152)
            {
              llvm::ValueSymbolTable::reinsertValue(v152, (llvm::Value *)v128);
              uint64_t v129 = v221;
            }
          }
        }
        uint64_t v135 = *((void *)v233 + 3);
        *((void *)v128 + 3) = v135;
        *((void *)v128 + 4) = (char *)v233 + 24;
        *(void *)(v135 + 8) = v133;
        *((void *)v233 + 3) = v133;
        *((void *)v128 + 8) = 0;
        llvm::CallInst::init((uint64_t ***)v128, v129, v131, (uint64_t *)v71, v121 >> 3, (uint64_t)v118, v119, (const char **)v240);
        __int16 v136 = *((_WORD *)v128 + 9) & 0xFFFC | *((_WORD *)v233 + 9) & 3;
        *((_WORD *)v128 + 9) = v136;
        unint64_t v137 = (char *)v223 - (char *)__p;
        uint64_t v116 = v231;
      }
      *((_WORD *)v128 + 9) = *(_WORD *)(v112 + 18) & 0xFFC | v136 & 0xF003;
      *((void *)v128 + 8) = v116;
      v240[0] = (void *)2;
      llvm::Instruction::copyMetadata((uint64_t)v128, v112, (int *)v240, 2);
      LODWORD(v264) = 0;
      if (*(void *)(v112 + 8) || (*(unsigned char *)(v112 + 23) & 8) != 0)
      {
        uint64_t v140 = *(llvm::UndefValue **)v112;
        if (*(void *)v128 == *(void *)v112)
        {
          char v142 = (llvm::ValueAsMetadata *)v112;
          int v143 = (llvm::Value *)v128;
        }
        else
        {
          if (*(unsigned char *)(*(void *)v128 + 8) == 7)
          {
            if (*((unsigned char *)v140 + 8) != 10)
            {
              char v141 = llvm::UndefValue::get(v140, v138);
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v112, v141, (llvm::Value *)1);
            }
            goto LABEL_248;
          }
          if (*(unsigned char *)(v112 + 16) == 33)
          {
            unsigned int v153 = (llvm *)*((void *)v128 + 5);
            unsigned int v154 = (llvm::BasicBlock *)*((void *)v233 - 12);
            LOWORD(v243) = 257;
            uint64_t v155 = llvm::SplitEdge(v153, v154, 0, 0, 0, (llvm::MemorySSAUpdater *)v240, v139);
            uint64_t v156 = v155 + 40;
            for (uint64_t k = *(void *)(v155 + 48); ; uint64_t k = *(void *)(k + 8))
            {
              if (k == v156) {
                goto LABEL_269;
              }
              uint64_t v158 = k - 24;
              if (!k) {
                uint64_t v158 = 0;
              }
              if (*(unsigned char *)(v158 + 16) != 83) {
                break;
              }
            }
            unsigned int v159 = *(unsigned __int8 *)(k - 8) - 38;
            BOOL v160 = v159 > 0x38;
            uint64_t v161 = (1 << v159) & 0x100060000000001;
            if (v160 || v161 == 0) {
              uint64_t v156 = k;
            }
            else {
              uint64_t v156 = *(void *)(k + 8);
            }
LABEL_269:
            if (v156) {
              uint64_t v112 = v156 - 24;
            }
            else {
              uint64_t v112 = 0;
            }
          }
          uint64_t v144 = llvm::UndefValue::get(v228, v138);
          unsigned int v239 = 0;
          if (v227)
          {
            for (unsigned int m = 0; m != v227; v239 = m)
            {
              if (*((_DWORD *)v256 + m) != -1)
              {
                sub_1CC8A8E38((uint64_t)v240, (uint64_t **)v112, 0, 0, 0);
                char v146 = (llvm::Instruction *)v128;
                if (v137 >= 9)
                {
                  unsigned int v238 = *((_DWORD *)v256 + v239);
                  v236[0] = "newret";
                  __int16 v237 = 259;
                  char v146 = sub_1CC2415A4((uint64_t)v240, (uint64_t *)v128, &v238, 1, (uint64_t)v236);
                }
                v236[0] = "oldret";
                __int16 v237 = 259;
                uint64_t v144 = sub_1CC2411F8((uint64_t)v240, (uint64_t)v144, (uint64_t)v146, &v239, 1, (uint64_t)v236);
                if (v240[0] != &v241) {
                  free(v240[0]);
                }
                unsigned int m = v239;
              }
              ++m;
            }
          }
          uint64_t v112 = (uint64_t)v233;
          char v142 = v233;
          int v143 = v144;
        }
        llvm::Value::doRAUW(v142, v143, (llvm::Value *)1);
        llvm::Value::takeName((int32x2_t ****)v128, (llvm::Value *)v112);
      }
LABEL_248:
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    uint64_t v178 = v64 + 80;
    sub_1CC89D864((uint64_t)(v64 + 80), *((uint64_t **)v64 + 11), (uint64_t *)v29 + 9);
    if ((*((_WORD *)v29 + 9) & 1) == 0)
    {
      uint64_t v180 = *v217;
      goto LABEL_293;
    }
    llvm::Function::BuildLazyArguments((llvm::Function *)v29);
    uint64_t v180 = (llvm::ValueAsMetadata *)v29[11];
    if (*((_WORD *)v29 + 9))
    {
      llvm::Function::BuildLazyArguments((llvm::Function *)v29);
      uint64_t v181 = (llvm::ValueAsMetadata *)v29[11];
    }
    else
    {
LABEL_293:
      uint64_t v181 = v180;
    }
    unsigned int v183 = (llvm::ValueAsMetadata *)((char *)v181 + 40 * (void)v29[12]);
    if (*((_WORD *)v64 + 13)) {
      llvm::Function::BuildLazyArguments(v65);
    }
    if (v180 != v183)
    {
      int v184 = 0;
      unint64_t v185 = (llvm::Value *)*((void *)v64 + 12);
      do
      {
        if (v259[v184])
        {
          llvm::Value::doRAUW(v180, v185, (llvm::Value *)1);
          llvm::Value::takeName((int32x2_t ****)v185, v180);
          unint64_t v185 = (llvm::Value *)((char *)v185 + 40);
        }
        else if (*(unsigned char *)(*(void *)v180 + 8) != 10)
        {
          uint64_t v186 = llvm::UndefValue::get(*(llvm::UndefValue **)v180, v179);
          llvm::Value::doRAUW(v180, v186, (llvm::Value *)1);
        }
        uint64_t v180 = (llvm::ValueAsMetadata *)((char *)v180 + 40);
        ++v184;
      }
      while (v180 != v183);
    }
    if (*(void *)v29[3][2] != **(void **)(*((void *)v64 + 4) + 16))
    {
      uint64_t v187 = *((void *)v64 + 11);
      if ((char *)v187 != v178)
      {
        while (1)
        {
          uint64_t v188 = v187 ? v187 - 24 : 0;
          uint64_t v189 = *(void *)(v188 + 40);
          if (v189 != v188 + 40)
          {
            uint64_t v190 = v189 ? v189 - 24 : 0;
            unsigned int v191 = *(unsigned __int8 *)(v190 + 16) - 40;
            uint64_t v192 = v191 >= 0xFFFFFFF5 ? v190 : 0;
            if (v189)
            {
              if (*(unsigned char *)(v192 + 16) == 29 && v191 >= 0xFFFFFFF5) {
                break;
              }
            }
          }
          uint64_t v187 = *(void *)(v187 + 8);
          if ((char *)v187 == v178) {
            goto LABEL_359;
          }
        }
        sub_1CC8A8E38((uint64_t)v240, (uint64_t **)v192, 0, 0, 0);
        uint64_t v195 = 0;
        if (*(unsigned char *)(*v221[2] + 8) != 7)
        {
          unint64_t v196 = *(uint64_t **)(v192 - 32 * (*(_DWORD *)(v192 + 20) & 0x7FFFFFF));
          uint64_t v195 = llvm::UndefValue::get(v229, v194);
          LODWORD(v244) = 0;
          if (v227)
          {
            for (unsigned int n = 0; n != v227; LODWORD(v244) = n)
            {
              if (*((_DWORD *)v256 + n) != -1)
              {
                v247 = "oldret";
                __int16 v251 = 259;
                int v198 = sub_1CC2415A4((uint64_t)v240, v196, (unsigned int *)&v244, 1, (uint64_t)&v247);
                unsigned int n = v244;
                if ((unint64_t)((char *)v223 - (char *)__p) < 9)
                {
                  uint64_t v195 = v198;
                }
                else
                {
                  LODWORD(v236[0]) = *((_DWORD *)v256 + v244);
                  v247 = "newret";
                  __int16 v251 = 259;
                  uint64_t v195 = sub_1CC2411F8((uint64_t)v240, (uint64_t)v195, (uint64_t)v198, v236, 1, (uint64_t)&v247);
                  unsigned int n = v244;
                }
              }
              ++n;
            }
          }
        }
        v199 = (llvm::LLVMContext *)**v234;
        BOOL v200 = v195 != 0;
        if (v195) {
          size_t v201 = 96;
        }
        else {
          size_t v201 = 64;
        }
        v202 = operator new(v201);
        BOOL v203 = &v202[4 * v200];
        *((_DWORD *)v203 + 5) = *((_DWORD *)v203 + 5) & 0x38000000 | v200;
        if (v195)
        {
          do
          {
            void *v202 = 0;
            v202[1] = 0;
            v202[2] = 0;
            v202[3] = v203;
            v202 += 4;
          }
          while (v202 != v203);
        }
        llvm::ReturnInst::ReturnInst((llvm::ReturnInst *)v203, v199, v195, (llvm::Instruction *)v192);
        v204 = *(unsigned __int8 **)(v192 + 48);
        v235 = v204;
        if (v204) {
          llvm::MetadataTracking::track((uint64_t)&v235, v204, 2);
        }
        unsigned int v207 = (unsigned __int8 *)v203[6];
        v206 = (char *)(v203 + 6);
        unsigned int v205 = v207;
        if (!v207)
        {
LABEL_340:
          v208 = v235;
          *(void *)v206 = v235;
          if (v208)
          {
            llvm::MetadataTracking::retrack((uint64_t)&v235, v208, (uint64_t)v206);
            v235 = 0;
          }
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        int v209 = *v205;
        if ((v209 - 4) > 0x1E)
        {
          if ((v209 - 3) >= 0xFFFFFFFE) {
            v212 = v205;
          }
          else {
            v212 = 0;
          }
          if ((v209 - 3) < 0xFFFFFFFE)
          {
            if (v209 == 3) {
              *((void *)v205 + 1) = 0;
            }
            goto LABEL_340;
          }
          unint64_t v211 = (unint64_t)(v212 + 8);
        }
        else
        {
          if ((v205[1] & 0x7F) != 2 && !*((_DWORD *)v205 + 3)) {
            goto LABEL_340;
          }
          uint64_t v210 = *((void *)v205 + 2);
          if ((v210 & 4) == 0) {
            goto LABEL_340;
          }
          unint64_t v211 = v210 & 0xFFFFFFFFFFFFFFF8;
          if (!v211) {
            goto LABEL_340;
          }
        }
        v247 = v206;
        sub_1CC5FA668(v211 + 16, &v247);
        goto LABEL_340;
      }
    }
LABEL_359:
    v240[0] = &v241;
    v240[1] = (void *)0x100000000;
    llvm::Value::getAllMetadata(v234, (uint64_t)v240);
    if (LODWORD(v240[1]))
    {
      unsigned int v213 = (llvm::MDNode **)v240[0];
      v214 = (llvm::MDNode **)((char *)v240[0] + 16 * LODWORD(v240[1]));
      do
      {
        llvm::Value::addMetadata(v220, *(_DWORD *)v213, v213[1]);
        v213 += 2;
      }
      while (v213 != v214);
    }
    llvm::Function::eraseFromParent((llvm::Function *)v234);
    if (v240[0] != &v241) {
      free(v240[0]);
    }
    uint64_t v10 = v216;
  }
  if (v253 != v255) {
    free(v253);
  }
  if (__p) {
    operator delete(__p);
  }
  if (v256 != v258) {
    free(v256);
  }
  if (v259 != v262) {
    free(v259);
  }
  if (v263 != v265) {
    free(v263);
  }
  if (v224) {
    operator delete(v224);
  }
  return v10;
}

double llvm::DeadArgumentEliminationPass::run@<D0>(llvm::DeadArgumentEliminationPass *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = this;
  uint64_t v6 = a2 + 24;
  uint64_t v7 = *(void *)(a2 + 32);
  if (v7 == a2 + 24)
  {
    int v8 = 0;
  }
  else
  {
    int v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(v7 + 8);
      if (v7) {
        uint64_t v10 = (llvm::Function *)(v7 - 56);
      }
      else {
        uint64_t v10 = 0;
      }
      if (*(_DWORD *)(*((void *)v10 + 3) + 8) >= 0x100u)
      {
        uint64_t v20 = *(void *)(v7 + 8);
        this = (llvm::DeadArgumentEliminationPass *)llvm::DeadArgumentEliminationPass::DeleteDeadVarargs(this, v10);
        uint64_t v9 = v20;
        v8 |= this;
      }
      uint64_t v7 = v9;
    }
    while (v9 != v6);
    uint64_t v7 = *(void *)(a2 + 32);
  }
  if (v7 != v6)
  {
    do
    {
      if (v7) {
        unint64_t v11 = (const llvm::Function *)(v7 - 56);
      }
      else {
        unint64_t v11 = 0;
      }
      llvm::DeadArgumentEliminationPass::SurveyFunction(v4, v11);
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != v6);
    uint64_t v12 = *(void *)(a2 + 32);
    if (v12 != v6)
    {
      do
      {
        uint64_t v13 = *(void *)(v12 + 8);
        if (v12) {
          unsigned int v14 = (llvm::Function *)(v12 - 56);
        }
        else {
          unsigned int v14 = 0;
        }
        v8 |= llvm::DeadArgumentEliminationPass::RemoveDeadStuffFromFunction(v4, v14);
        uint64_t v12 = v13;
      }
      while (v13 != v6);
      for (uint64_t i = *(void *)(a2 + 32); i != v6; uint64_t i = *(void *)(i + 8))
      {
        if (i) {
          uint64_t v16 = (llvm::Function *)(i - 56);
        }
        else {
          uint64_t v16 = 0;
        }
        v8 |= llvm::DeadArgumentEliminationPass::RemoveDeadArgumentsFromCallers(v4, v16);
      }
    }
  }
  if (v8)
  {
    int v18 = 0;
    *(void *)(a3 + 88) = 0;
    *(_OWORD *)(a3 + 72) = 0u;
    *(_OWORD *)(a3 + 56) = 0u;
    *(_OWORD *)(a3 + 40) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    uint64_t v17 = a3 + 32;
  }
  else
  {
    *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
    uint64_t v17 = a3 + 32;
    int v18 = 1;
  }
  *(void *)a3 = v17;
  *(void *)(a3 + 8) = v17;
  *(_DWORD *)(a3 + 16) = 2;
  *(_DWORD *)(a3 + 20) = v18;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)&double result = 2;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  return result;
}

void sub_1CC904A04()
{
}

void sub_1CC904A40()
{
}

void sub_1CC904AA0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CC904AD8(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }
  char v5 = (*(uint64_t (**)(llvm::ModulePass *))(*(void *)a1 + 144))(a1);
  unsigned int v34 = v35;
  v35[0] = 0;
  v37[0] = 0;
  v37[1] = 0;
  v35[1] = 0;
  unsigned int v36 = v37;
  v39[0] = 0;
  v39[1] = 0;
  int v38 = v39;
  char v40 = v5;
  v27[0] = 0;
  v27[1] = 0;
  int v28 = 0;
  v29[0] = 0;
  v29[1] = 0;
  int v30 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  int v33 = 0;
  llvm::DeadArgumentEliminationPass::run((llvm::DeadArgumentEliminationPass *)&v34, (uint64_t)a2, (uint64_t)&v19);
  if (v25 == v26)
  {
    uint64_t v6 = v19;
    if (v20 == v19)
    {
      unsigned int v7 = v22;
      int v8 = (void **)&v20[8 * v22];
      if (v22)
      {
        uint64_t v9 = 0;
        while (*(_UNKNOWN **)&v20[v9] != &llvm::PreservedAnalyses::AllAnalysesKey)
        {
          v9 += 8;
          if (8 * v22 == v9) {
            goto LABEL_23;
          }
        }
        int v8 = (void **)&v20[v9];
      }
LABEL_23:
      uint64_t v6 = v20;
      goto LABEL_30;
    }
    unsigned int v10 = v21 - 1;
    unsigned int v11 = (v21 - 1) & ((&llvm::PreservedAnalyses::AllAnalysesKey >> 4) ^ (&llvm::PreservedAnalyses::AllAnalysesKey >> 9));
    int v8 = (void **)&v20[8 * v11];
    uint64_t v12 = *v8;
    if (*v8 == (void *)-1)
    {
      uint64_t v13 = 0;
LABEL_25:
      if (v13) {
        int v8 = v13;
      }
      if (*v8 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        unsigned int v7 = v22;
        int v8 = (void **)&v20[8 * v21];
LABEL_30:
        if (v20 == v6) {
          unsigned int v17 = v7;
        }
        else {
          unsigned int v17 = v21;
        }
        BOOL v4 = v8 == (void **)&v20[8 * v17];
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      while (v12 != &llvm::PreservedAnalyses::AllAnalysesKey)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == (void *)-2;
        }
        if (v15) {
          uint64_t v13 = v8;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        int v8 = (void **)&v20[8 * (v16 & v10)];
        uint64_t v12 = *v8;
        if (*v8 == (void *)-1) {
          goto LABEL_25;
        }
      }
    }
    unsigned int v7 = v22;
    goto LABEL_30;
  }
  BOOL v4 = 1;
LABEL_34:
  if (v24 != v23) {
    free(v24);
  }
  if (v20 != v19) {
    free(v20);
  }
  MEMORY[0x1D25D9CD0](0, 8);
  sub_1CC5C4BBC(v29);
  sub_1CC5C4C3C((unsigned int *)v27);
  MEMORY[0x1D25D9CD0](v27[0], 8);
  sub_1CB833A08((uint64_t)&v38, v39[0]);
  sub_1CB833A08((uint64_t)&v36, v37[0]);
  sub_1CB833A08((uint64_t)&v34, v35[0]);
  return v4;
}

uint64_t sub_1CC904D2C()
{
  return 0;
}

void sub_1CC904D38(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC904D70()
{
  return 1;
}

uint64_t sub_1CC904D78(uint64_t result, uint64_t *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    unint64_t v3 = *a2;
    unsigned int v4 = *((_DWORD *)a2 + 2);
    double result = 1;
    while (1)
    {
      unint64_t v5 = *(void *)(v2 + 32);
      if (v3 >= v5)
      {
        if (v5 < v3) {
          goto LABEL_7;
        }
        unsigned int v6 = *(_DWORD *)(v2 + 40);
        if (v4 >= v6) {
          break;
        }
      }
LABEL_8:
      uint64_t v2 = *(void *)v2;
      if (!v2) {
        return 0;
      }
    }
    if (v6 >= v4)
    {
      unsigned int v7 = *((unsigned __int8 *)a2 + 12);
      unsigned int v8 = *(unsigned __int8 *)(v2 + 44);
      if (v7 < v8) {
        goto LABEL_8;
      }
      if (v8 >= v7) {
        return result;
      }
    }
LABEL_7:
    v2 += 8;
    goto LABEL_8;
  }
  return result;
}

uint64_t *sub_1CC904DE8(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      unsigned int v4 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    unint64_t v3 = a2;
    do
    {
      unsigned int v4 = (uint64_t *)v3[2];
      BOOL v5 = *v4 == (void)v3;
      unint64_t v3 = v4;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  unsigned int v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1CB91F7C8(v6, a2);
  return v4;
}

uint64_t *sub_1CC904E5C(uint64_t **a1, unint64_t *a2)
{
  unsigned int v4 = (uint64_t *)(a1 + 1);
  double result = a1[1];
  if (result)
  {
    unint64_t v5 = *a2;
    unsigned int v6 = *((_DWORD *)a2 + 2);
    unsigned int v7 = result;
    unsigned int v8 = v4;
    unsigned int v9 = *((unsigned __int8 *)a2 + 12);
    do
    {
      unint64_t v10 = v7[4];
      if (v10 >= v5
        && (v5 < v10 || (unsigned int v11 = *((_DWORD *)v7 + 10), v11 >= v6) && (v6 < v11 || *((unsigned __int8 *)v7 + 44) >= v9)))
      {
        unsigned int v8 = v7;
      }
      else
      {
        ++v7;
      }
      unsigned int v7 = (uint64_t *)*v7;
    }
    while (v7);
    if (v8 == v4) {
      return 0;
    }
    unint64_t v12 = v8[4];
    if (v5 < v12) {
      return 0;
    }
    if (v12 >= v5 && ((unsigned int v13 = *((_DWORD *)v8 + 10), v6 < v13) || v13 >= v6 && v9 < *((unsigned __int8 *)v8 + 44)))
    {
      return 0;
    }
    else
    {
      int v14 = (uint64_t *)v8[1];
      if (v14)
      {
        do
        {
          unsigned int v16 = v14;
          int v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
      else
      {
        BOOL v15 = v8;
        do
        {
          unsigned int v16 = (uint64_t *)v15[2];
          BOOL v17 = *v16 == (void)v15;
          BOOL v15 = v16;
        }
        while (!v17);
      }
      if (*a1 == v8) {
        *a1 = v16;
      }
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      sub_1CB91F7C8(result, v8);
      operator delete(v8);
      return (uint64_t *)1;
    }
  }
  return result;
}

uint64_t sub_1CC904F88(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 != a1 + 8)
  {
    char v4 = 0;
    while (1)
    {
      uint64_t v5 = v3 ? v3 - 56 : 0;
      int v6 = *(_DWORD *)(v5 + 32);
      if ((v6 & 0xF) == 1) {
        break;
      }
LABEL_20:
      uint64_t v3 = *(void *)(v3 + 8);
      if (v3 == v2) {
        goto LABEL_23;
      }
    }
    if (v3 && *(unsigned char *)(v5 + 16) == 3)
    {
      if ((*(_DWORD *)(v5 + 20) & 0x7FFFFFF) == 0)
      {
LABEL_16:
        llvm::Constant::removeDeadConstantUsers(v5);
        int v10 = *(_DWORD *)(v5 + 32);
        *(_DWORD *)(v5 + 32) = v10 & 0xFFFFFFF0;
        if ((v10 & 0x30) != 0 && (llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)v5) & 1) == 0) {
          *(_DWORD *)(v5 + 32) |= 0x4000u;
        }
        char v4 = 1;
        goto LABEL_20;
      }
    }
    else if (!*(unsigned char *)(v5 + 16) && (v6 & 0x800000) == 0 && *(void *)(v5 + 72) == v5 + 72)
    {
      goto LABEL_16;
    }
    unsigned int v7 = *(int32x2_t *****)(v5 - 32);
    llvm::GlobalVariable::setInitializer(v5, 0);
    if (llvm::isSafeToDestroyConstant((llvm *)v7, v8)) {
      llvm::Constant::destroyConstant(v7, v9);
    }
    goto LABEL_16;
  }
  char v4 = 0;
LABEL_23:
  uint64_t v11 = a1 + 24;
  for (uint64_t i = *(void *)(a1 + 32); i != v11; uint64_t i = *(void *)(i + 8))
  {
    if (i) {
      uint64_t v13 = i - 56;
    }
    else {
      uint64_t v13 = 0;
    }
    int v14 = *(_DWORD *)(v13 + 32);
    if ((v14 & 0xF) == 1)
    {
      if (i && *(unsigned char *)(v13 + 16) == 3)
      {
        if ((*(_DWORD *)(v13 + 20) & 0x7FFFFFF) != 0) {
          goto LABEL_38;
        }
      }
      else if (*(unsigned char *)(v13 + 16) || (v14 & 0x800000) != 0 || *(void *)(v13 + 72) != v13 + 72)
      {
LABEL_38:
        sub_1CD660DD8((llvm::GlobalValue *)v13);
      }
      llvm::Constant::removeDeadConstantUsers(v13);
      char v4 = 1;
      continue;
    }
  }
  return v4 & 1;
}

void llvm::initializeEliminateAvailableExternallyLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4F8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC90518C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCDE4F8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC90518C()
{
}

uint64_t sub_1CC905228(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE4F0;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2627BB0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE4F8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC90518C;
    v5[1] = &PassRegistry;
    char v4 = v5;
    std::__call_once(&qword_1EBCDE4F8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC9052D8()
{
}

void sub_1CC905318(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC905350(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }

  return sub_1CC904F88((uint64_t)a2);
}

void llvm::createGVExtractionPass()
{
}

void sub_1CC905558(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2627C50;
  uint64_t v2 = (void *)*((void *)a1 + 7);
  if (v2)
  {
    *((void *)a1 + 8) = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](*((void *)a1 + 4), 8);

  llvm::Pass::~Pass(a1);
}

void sub_1CC9055C4(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2627C50;
  uint64_t v2 = (void *)*((void *)a1 + 7);
  if (v2)
  {
    *((void *)a1 + 8) = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](*((void *)a1 + 4), 8);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC905644(uint64_t a1, uint64_t a2)
{
  int v4 = llvm::ModulePass::skipModule((llvm::ModulePass *)a1, (llvm::LLVMContextImpl ***)a2);
  int v5 = v4;
  if ((v4 & 1) == 0)
  {
    int v52 = v4;
    if (!*(unsigned char *)(a1 + 80)) {
      LLVMSetModuleInlineAsm2_0(a2, "", 0);
    }
    for (uint64_t i = *(void *)(a2 + 16); i != a2 + 8; uint64_t i = *(void *)(i + 8))
    {
      int v7 = *(unsigned __int8 *)(a1 + 80);
      if (i) {
        uint64_t v8 = i - 56;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v53 = v8;
      uint64_t v54 = 0;
      if (v7 == sub_1CC906108((uint64_t *)(a1 + 32), &v53, &v54))
      {
        if (i && *(unsigned char *)(v8 + 16) == 3)
        {
          if ((*(_DWORD *)(v8 + 20) & 0x7FFFFFF) == 0) {
            goto LABEL_18;
          }
        }
        else if (!*(unsigned char *)(v8 + 16) && *(void *)(v8 + 72) == v8 + 72 && (*(unsigned char *)(v8 + 34) & 0x80) == 0)
        {
          goto LABEL_18;
        }
        if ((*(unsigned char *)(v8 + 80) & 1) == 0 || !*(unsigned char *)(a1 + 81))
        {
          int v17 = 1;
          goto LABEL_37;
        }
      }
LABEL_18:
      if ((*(_DWORD *)(v8 + 32) & 0xF) == 1) {
        continue;
      }
      if ((*(unsigned char *)(v8 + 23) & 0x10) == 0) {
        goto LABEL_36;
      }
      uint64_t v9 = ***(void ***)v8;
      uint64_t v10 = *(void *)(v9 + 152);
      uint64_t v11 = *(unsigned int *)(v9 + 168);
      if (!v11) {
        goto LABEL_27;
      }
      LODWORD(v12) = (v11 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      uint64_t v13 = (uint64_t *)(v10 + 16 * v12);
      uint64_t v14 = *v13;
      if (*v13 != v8)
      {
        int v15 = 1;
        while (v14 != -4096)
        {
          int v16 = v12 + v15++;
          uint64_t v12 = v16 & (v11 - 1);
          uint64_t v14 = *(void *)(v10 + 16 * v12);
          if (v14 == v8)
          {
            uint64_t v13 = (uint64_t *)(v10 + 16 * v12);
            goto LABEL_28;
          }
        }
LABEL_27:
        uint64_t v13 = (uint64_t *)(v10 + 16 * v11);
      }
LABEL_28:
      uint64_t v18 = v13[1];
      if (*(void *)v18 == 17)
      {
        uint64_t v19 = *(void *)(v18 + 16);
        uint64_t v20 = *(void *)(v18 + 24);
        int v21 = *(unsigned __int8 *)(v18 + 32);
        BOOL v22 = v19 == 0x6F6C672E6D766C6CLL && v20 == 0x726F74635F6C6162;
        if (v22 && v21 == 115) {
          continue;
        }
      }
LABEL_36:
      int v17 = 0;
LABEL_37:
      if ((*(unsigned char *)(v8 + 34) & 0x40) == 0) {
        goto LABEL_45;
      }
      uint64_t v24 = ***(void ***)v8;
      uint64_t v53 = v8;
      int v25 = *(_DWORD *)(v24 + 2520);
      if (!v25)
      {
        char v40 = 0;
LABEL_63:
        BOOL v29 = sub_1CC5BF31C(v24 + 2504, (uint64_t)&v53, &v53, v40);
        uint64_t v41 = v53;
        v29[1] = 0;
        uint64_t v29[2] = 0;
        *BOOL v29 = v41;
        goto LABEL_40;
      }
      uint64_t v26 = *(void *)(v24 + 2504);
      int v27 = v25 - 1;
      unsigned int v28 = v27 & ((v8 >> 4) ^ (v8 >> 9));
      BOOL v29 = (void *)(v26 + 24 * v28);
      uint64_t v30 = *v29;
      if (*v29 != v8)
      {
        unsigned int v36 = 0;
        int v37 = 1;
        while (v30 != -4096)
        {
          if (v36) {
            BOOL v38 = 0;
          }
          else {
            BOOL v38 = v30 == -8192;
          }
          if (v38) {
            unsigned int v36 = v29;
          }
          unsigned int v39 = v28 + v37++;
          unsigned int v28 = v39 & v27;
          BOOL v29 = (void *)(v26 + 24 * v28);
          uint64_t v30 = *v29;
          if (*v29 == v8) {
            goto LABEL_40;
          }
        }
        if (v36) {
          char v40 = v36;
        }
        else {
          char v40 = v29;
        }
        goto LABEL_63;
      }
LABEL_40:
      if (v29[2] == 12)
      {
        uint64_t v31 = (uint64_t *)v29[1];
        uint64_t v32 = *v31;
        int v33 = *((_DWORD *)v31 + 2);
        if (v32 == 0x7274702E6D766C6CLL && v33 == 1752462689) {
          continue;
        }
      }
LABEL_45:
      sub_1CC906030(v8, v17);
      if (v17)
      {
        llvm::GlobalVariable::setInitializer(v8, 0);
        uint64_t v35 = *(void *)(v8 + 48);
        if (v35) {
          llvm::Comdat::removeUser(v35, v8);
        }
        *(void *)(v8 + 48) = 0;
      }
    }
    uint64_t v42 = *(void *)(a2 + 32);
    int v5 = v52;
    if (v42 != a2 + 24)
    {
      while (1)
      {
        int v43 = *(unsigned __int8 *)(a1 + 80);
        uint64_t v44 = v42 ? v42 - 56 : 0;
        uint64_t v53 = v44;
        uint64_t v54 = 0;
        if (v43 != sub_1CC906108((uint64_t *)(a1 + 32), &v53, &v54)) {
          break;
        }
        if (v42 && *(unsigned char *)(v44 + 16) == 3)
        {
          if ((*(_DWORD *)(v44 + 20) & 0x7FFFFFF) == 0) {
            break;
          }
        }
        else if (!*(unsigned char *)(v44 + 16) && *(void *)(v44 + 72) == v44 + 72 && (*(unsigned char *)(v44 + 34) & 0x80) == 0)
        {
          break;
        }
        sub_1CC906030(v44, 1);
        sub_1CD660DD8((llvm::GlobalValue *)v44);
        uint64_t v45 = *(void *)(v44 + 48);
        if (v45) {
          llvm::Comdat::removeUser(v45, v44);
        }
        *(void *)(v44 + 48) = 0;
LABEL_79:
        uint64_t v42 = *(void *)(v42 + 8);
        if (v42 == a2 + 24) {
          goto LABEL_84;
        }
      }
      if ((*(_DWORD *)(v44 + 32) & 0xF) != 1) {
        sub_1CC906030(v44, 0);
      }
      goto LABEL_79;
    }
LABEL_84:
    uint64_t v46 = *(void *)(a2 + 48);
    if (v46 != a2 + 40)
    {
      do
      {
        uint64_t v47 = *(void *)(v46 + 8);
        if (v46) {
          uint64_t v48 = v46 - 48;
        }
        else {
          uint64_t v48 = 0;
        }
        int v49 = *(unsigned __int8 *)(a1 + 80);
        uint64_t v53 = v48;
        uint64_t v54 = 0;
        int v50 = sub_1CC906108((uint64_t *)(a1 + 32), &v53, &v54);
        sub_1CC906030(v48, v49 == v50);
        if (v49 == v50) {
          llvm::SymbolTableListTraits<llvm::GlobalAlias>::removeNodeFromList();
        }
        uint64_t v46 = v47;
      }
      while (v47 != a2 + 40);
    }
  }
  return v5 ^ 1u;
}

uint64_t sub_1CC905D80@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD50F704((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC905E08(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

void *sub_1CC905E08(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC905EBC(a1, v7);
  uint64_t v9 = 0;
  sub_1CD50F704((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CC905EBC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC905F88(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CC905F88(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD50F704((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CC906030(uint64_t this, int a2)
{
  uint64_t v2 = (llvm::GlobalValue *)this;
  int v3 = *(_DWORD *)(this + 32);
  unsigned int v4 = (v3 & 0xF) - 7;
  if (v4 >= 2 && a2 == 0)
  {
    if ((v3 & 0xE) == 2)
    {
      unsigned int v8 = v3 & 0xFFFFFFF0;
      int v9 = *(_DWORD *)(this + 32) & 0x30;
      int v10 = (*(_DWORD *)(this + 32) & 0xF) == 2 ? v8 | 4 : v8 | 5;
      *(_DWORD *)(this + 32) = v10;
      if (v9) {
        goto LABEL_16;
      }
    }
  }
  else
  {
    *(_DWORD *)(this + 32) = v3 & 0xFFFFFFF0;
    if ((v3 & 0x30) != 0)
    {
      this = llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)this);
      if ((this & 1) == 0) {
        *((_DWORD *)v2 + 8) |= 0x4000u;
      }
    }
    if (v4 <= 1)
    {
      int v6 = *((_DWORD *)v2 + 8);
      unsigned int v7 = v6 & 0xFFFFFFCF | 0x10;
      *((_DWORD *)v2 + 8) = v7;
      if ((v6 & 0xFu) - 7 < 2)
      {
LABEL_18:
        *((_DWORD *)v2 + 8) = v7 | 0x4000;
        return this;
      }
LABEL_16:
      this = llvm::GlobalValue::hasExternalWeakLinkage(v2);
      if (this) {
        return this;
      }
      unsigned int v7 = *((_DWORD *)v2 + 8);
      goto LABEL_18;
    }
  }
  return this;
}

uint64_t sub_1CC906108(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    unsigned int v7 = (void *)(*a1 + 8 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      int v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          int v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        unsigned int v7 = (void *)(v4 + 8 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        unsigned int v7 = v10;
      }
    }
  }
  else
  {
    unsigned int v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

unint64_t sub_1CC9061A4(unint64_t result)
{
  uint64_t v1 = (uint64_t ***)result;
  uint64_t v2 = qword_1EBCDE590;
  uint64_t v3 = unk_1EBCDE598;
  unsigned int v57 = result >> 4;
  if (qword_1EBCDE590 != unk_1EBCDE598)
  {
    unsigned int v4 = v57 ^ (result >> 9);
    int v5 = (void *)(result + 112);
    while (1)
    {
      char v6 = *(unsigned char *)(v2 + 23);
      BOOL v7 = v6 < 0;
      if (v6 >= 0) {
        uint64_t v8 = (char *)v2;
      }
      else {
        uint64_t v8 = *(char **)v2;
      }
      unint64_t v9 = v6 & 0x7F;
      if (v7) {
        unint64_t v10 = *(void *)(v2 + 8);
      }
      else {
        unint64_t v10 = v9;
      }
      uint64_t v58 = v8;
      unint64_t v59 = v10;
      char v60 = 58;
      uint64_t result = llvm::StringRef::find((uint64_t *)&v58, &v60, 1uLL, 0);
      if (v10 >= result) {
        size_t v11 = result;
      }
      else {
        size_t v11 = v10;
      }
      if (v10 >= result + 1) {
        unint64_t v12 = result + 1;
      }
      else {
        unint64_t v12 = v10;
      }
      unsigned int v13 = &v8[v12];
      uint64_t v14 = v10 - v12;
      if (result == -1) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = v14;
      }
      if (result == -1) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = (uint64_t)v13;
      }
      if (result == -1) {
        size_t v17 = v10;
      }
      else {
        size_t v17 = v11;
      }
      if ((*((unsigned char *)v1 + 23) & 0x10) == 0)
      {
        unsigned int v28 = 0;
        int v27 = &byte_1CFBCE98E;
        goto LABEL_33;
      }
      uint64_t v18 = ***v1;
      uint64_t v19 = *(void *)(v18 + 152);
      uint64_t v20 = *(unsigned int *)(v18 + 168);
      if (!v20) {
        goto LABEL_31;
      }
      LODWORD(v21) = (v20 - 1) & v4;
      BOOL v22 = (uint64_t ****)(v19 + 16 * v21);
      unsigned int v23 = *v22;
      if (*v22 != v1) {
        break;
      }
LABEL_32:
      uint64_t v26 = v22[1];
      BOOL v29 = *v26;
      int v27 = (char *)(v26 + 2);
      unsigned int v28 = v29;
LABEL_33:
      if ((uint64_t **)v17 == v28)
      {
        if (!v17 || (uint64_t result = memcmp(v8, v27, v17), !result))
        {
          uint64_t result = llvm::Attribute::getAttrKindFromName(v16, v15);
          if (result)
          {
            if (!*v5 || ((*(unsigned __int8 *)(*v5 + (int)result / 8 + 12) >> (result & 7)) & 1) == 0)
            {
              uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v1 + 14, **v1, -1, result);
              v1[14] = (uint64_t **)result;
            }
          }
        }
      }
      v2 += 24;
      if (v2 == v3) {
        goto LABEL_43;
      }
    }
    int v24 = 1;
    while (v23 != (uint64_t ***)-4096)
    {
      int v25 = v21 + v24++;
      uint64_t v21 = v25 & (v20 - 1);
      unsigned int v23 = *(uint64_t ****)(v19 + 16 * v21);
      if (v23 == v1)
      {
        BOOL v22 = (uint64_t ****)(v19 + 16 * v21);
        goto LABEL_32;
      }
    }
LABEL_31:
    BOOL v22 = (uint64_t ****)(v19 + 16 * v20);
    goto LABEL_32;
  }
LABEL_43:
  uint64_t v30 = qword_1EBCDE668;
  uint64_t v31 = unk_1EBCDE670;
  if (qword_1EBCDE668 != unk_1EBCDE670)
  {
    uint64_t v32 = v1 + 14;
    while (1)
    {
      char v33 = *(unsigned char *)(v30 + 23);
      BOOL v34 = v33 < 0;
      uint64_t v35 = v33 >= 0 ? (char *)v30 : *(char **)v30;
      uint64_t v36 = v33 & 0x7F;
      unint64_t v37 = v34 ? *(void *)(v30 + 8) : v36;
      uint64_t v58 = v35;
      unint64_t v59 = v37;
      char v60 = 58;
      uint64_t result = llvm::StringRef::find((uint64_t *)&v58, &v60, 1uLL, 0);
      unint64_t v38 = v37 >= result ? result : v37;
      uint64_t v39 = v37 >= result + 1 ? result + 1 : v37;
      char v40 = &v35[v39];
      unint64_t v41 = v37 - v39;
      uint64_t v42 = result == -1 ? 0 : v41;
      uint64_t v43 = result == -1 ? 0 : (uint64_t)v40;
      size_t v44 = result == -1 ? v37 : v38;
      if ((*((unsigned char *)v1 + 23) & 0x10) != 0) {
        break;
      }
      uint64_t v55 = 0;
      uint64_t v54 = &byte_1CFBCE98E;
LABEL_75:
      if ((uint64_t **)v44 == v55)
      {
        if (!v44 || (uint64_t result = memcmp(v35, v54, v44), !result))
        {
          uint64_t result = llvm::Attribute::getAttrKindFromName(v43, v42);
          if (result
            && *v32
            && ((*(unsigned __int8 *)(*v32 + (int)result / 8 + 12) >> (result & 7)) & 1) != 0)
          {
            uint64_t result = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)v1 + 14, **v1, -1, result);
            v1[14] = (uint64_t **)result;
          }
        }
      }
      v30 += 24;
      if (v30 == v31) {
        return result;
      }
    }
    uint64_t v45 = ***v1;
    uint64_t v46 = *(void *)(v45 + 152);
    uint64_t v47 = *(unsigned int *)(v45 + 168);
    if (v47)
    {
      LODWORD(v48) = (v47 - 1) & (v57 ^ (v1 >> 9));
      int v49 = (uint64_t ****)(v46 + 16 * v48);
      int v50 = *v49;
      if (*v49 == v1)
      {
LABEL_74:
        uint64_t v53 = v49[1];
        char v56 = *v53;
        uint64_t v54 = (char *)(v53 + 2);
        uint64_t v55 = v56;
        goto LABEL_75;
      }
      int v51 = 1;
      while (v50 != (uint64_t ***)-4096)
      {
        int v52 = v48 + v51++;
        uint64_t v48 = v52 & (v47 - 1);
        int v50 = *(uint64_t ****)(v46 + 16 * v48);
        if (v50 == v1)
        {
          int v49 = (uint64_t ****)(v46 + 16 * v48);
          goto LABEL_74;
        }
      }
    }
    int v49 = (uint64_t ****)(v46 + 16 * v47);
    goto LABEL_74;
  }
  return result;
}

void llvm::initializeForceFunctionAttrsLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE508, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC90657C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCDE508, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC90657C()
{
}

uint64_t sub_1CC906618(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE500;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2627CF0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE508, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC90657C;
    v5[1] = &PassRegistry;
    unsigned int v4 = v5;
    std::__call_once(&qword_1EBCDE508, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC9066C8()
{
}

void sub_1CC906708(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC906740(uint64_t a1, uint64_t a2)
{
  BOOL v2 = qword_1EBCDE590 == unk_1EBCDE598 && qword_1EBCDE668 == unk_1EBCDE670;
  uint64_t v3 = !v2;
  if (!v2)
  {
    uint64_t v4 = a2 + 24;
    for (uint64_t i = *(void *)(a2 + 32); i != v4; uint64_t i = *(void *)(i + 8))
    {
      if (i) {
        unint64_t v6 = i - 56;
      }
      else {
        unint64_t v6 = 0;
      }
      sub_1CC9061A4(v6);
    }
  }
  return v3;
}

uint64_t sub_1CC9067B0()
{
  int v2 = 1;
  *(void *)&long long v1 = "Add an attribute to a function. This should be a pair of 'function-name:attribute-name', for example "
                   "-force-attribute=foo:noinline. This option can be specified multiple times.";
  *((void *)&v1 + 1) = 176;
  sub_1CD661878(&v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CD510A20, &qword_1EBCDE510, &dword_1CB82C000);
  int v2 = 1;
  *(void *)&long long v1 = "Remove an attribute from a function. This should be a pair of 'function-name:attribute-name', for exa"
                   "mple -force-remove-attribute=foo:noinline. This option can be specified multiple times.";
  *((void *)&v1 + 1) = 188;
  sub_1CD66196C(&v2, &v1);

  return __cxa_atexit((void (*)(void *))sub_1CD510A20, &qword_1EBCDE5E8, &dword_1CB82C000);
}

uint64_t sub_1CC90686C(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void **)(a3 + 8);
  unint64_t v9 = *(void **)(a3 + 16);
  uint64_t v10 = 63;
  while (v8 != v9)
  {
    uint64_t v10 = (*(unsigned int (**)(void, uint64_t))(*(void *)*v8 + 56))(*v8, a1) & v10;
    if (v10 == 4) {
      return v10;
    }
    ++v8;
  }
  if (!a2) {
    return v10;
  }
  uint64_t v11 = a1 + 72;
  for (uint64_t i = *(void *)(a1 + 80); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v11)
    {
      uint64_t v87 = 0;
      LOBYTE(v15) = 0;
      goto LABEL_167;
    }
    uint64_t v13 = i - 24;
    if (!i) {
      uint64_t v13 = 0;
    }
    uint64_t v14 = *(void *)(v13 + 48);
    if (v14 != v13 + 40) {
      break;
    }
  }
  uint64_t v87 = 0;
  int v15 = 0;
  uint64_t v86 = a4;
  while (1)
  {
    uint64_t v16 = v14 - 24;
    if (v14) {
      uint64_t v17 = v14 - 24;
    }
    else {
      uint64_t v17 = 0;
    }
    int v18 = *(unsigned __int8 *)(v17 + 16);
    uint64_t v19 = (v18 - 33);
    if (v19 > 0x33 || ((1 << (v18 - 33)) & 0x8000000000041) == 0)
    {
      if (v14 && v18 == 60)
      {
        uint64_t v26 = *(void *)(*(void *)(*(void *)(v17 + 40) + 56) + 40) + 272;
        int v27 = *(llvm **)(v17 - 32);
        unsigned int v28 = *(uint64_t ***)v17;
LABEL_35:
        uint64_t v29 = sub_1CB83544C(v26, (uint64_t)v28);
        if (v30 == 1) {
          unint64_t v31 = -2;
        }
        else {
          unint64_t v31 = (unint64_t)(v29 + 7) >> 3;
        }
        llvm::Instruction::getAAMetadata((uint64_t ***)v17, v91);
        unint64_t v89 = v27;
        uint64_t v90 = v31;
        if ((*(unsigned char *)(v17 + 18) & 1) == 0)
        {
          if (llvm::AAResults::pointsToConstantMemory(a3, (uint64_t)&v89, 1)) {
            goto LABEL_134;
          }
          int v27 = v89;
        }
        uint64_t v32 = v27;
LABEL_42:
        int v33 = *((unsigned __int8 *)llvm::getUnderlyingObject(v32, (const llvm::Value *)6) + 16);
        BOOL v34 = v33 == 21 || v33 == 59;
        goto LABEL_45;
      }
      if (v14 && v18 == 61)
      {
        uint64_t v26 = *(void *)(*(void *)(*(void *)(v17 + 40) + 56) + 40) + 272;
        int v27 = *(llvm **)(v17 - 32);
        unsigned int v28 = **(uint64_t ****)(v17 - 64);
        goto LABEL_35;
      }
      if (v14 && v18 == 88)
      {
        int v52 = *(llvm **)(v17 - 32);
        llvm::Instruction::getAAMetadata((uint64_t ***)v17, v91);
        unint64_t v89 = v52;
        uint64_t v90 = -2;
        if (llvm::AAResults::pointsToConstantMemory(a3, (uint64_t)&v89, 1)) {
          goto LABEL_134;
        }
        uint64_t v32 = v89;
        goto LABEL_42;
      }
      if (v19 <= 0x37)
      {
        if (((1 << (v18 - 33)) & 0x8000000000001) == 0)
        {
          if (((1 << (v18 - 33)) & 0x808001C8000010) == 0
            && (v19 != 28 || (*(_WORD *)(v17 + 18) & 0x301) == 0))
          {
            goto LABEL_81;
          }
LABEL_109:
          int v35 = 1;
LABEL_48:
          int v36 = *(unsigned __int8 *)(v17 + 16);
          goto LABEL_49;
        }
        uint64_t v59 = *(void *)(v17 + 64);
        if (!v59 || (*(unsigned char *)(v59 + 20) & 4) == 0 && (*(unsigned char *)(v59 + 17) & 0x10) == 0)
        {
          LODWORD(v89) = 7;
          if (sub_1CC5CB59C(v17, (__int32 *)&v89, 1uLL))
          {
            uint64_t v75 = *(void *)(v17 - 32);
            if (!v75 || *(unsigned char *)(v75 + 16) || *(void *)(v75 + 24) != *(void *)(v17 + 72))
            {
LABEL_165:
              int v35 = 1;
              goto LABEL_48;
            }
            if (*(_DWORD *)(v75 + 36) != 7) {
              goto LABEL_109;
            }
          }
          if ((llvm::CallBase::hasFnAttrOnCalledFunction(v17, 66) & 1) == 0
            && !llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44))
          {
            goto LABEL_109;
          }
        }
      }
LABEL_81:
      int v35 = 0;
      int v36 = *(unsigned __int8 *)(v17 + 16);
      uint64_t v53 = (v36 - 33);
      if (v53 > 0x37) {
        goto LABEL_49;
      }
      if (((1 << (v36 - 33)) & 0x8000000000041) == 0)
      {
        if (v53 == 27)
        {
          BOOL v34 = (*(_WORD *)(v17 + 18) & 0x301) == 0;
LABEL_45:
          int v35 = !v34;
          goto LABEL_48;
        }
        if (((1 << (v36 - 33)) & 0x808001D0000010) != 0) {
          goto LABEL_109;
        }
LABEL_49:
        int v37 = 0;
        uint64_t v38 = (v36 - 33);
        if (v38 > 0x37) {
          goto LABEL_92;
        }
        if (((1 << v38) & 0x8000000000041) == 0)
        {
          if (v38 == 27) {
            int v37 = (*(_WORD *)(v17 + 18) & 0x301) != 0;
          }
          else {
            int v37 = ((1 << v38) & 0x808001D0000010) != 0;
          }
          goto LABEL_92;
        }
        uint64_t v54 = *(void *)(v17 + 64);
        if (!v54 || (*(unsigned char *)(v54 + 17) & 0x30) == 0)
        {
          int v55 = *(_DWORD *)(v17 + 20);
          if (v55 < 0)
          {
            uint64_t v66 = v17 - 32 * (v55 & 0x7FFFFFF);
            uint64_t v69 = *(void *)(v66 - 8);
            uint64_t v67 = v66 - 8;
            uint64_t v68 = v69;
            if (v69)
            {
              uint64_t v70 = -v68;
              while (1)
              {
                unsigned int v71 = *(_DWORD *)(*(void *)(v67 + v70) + 8);
                BOOL v72 = v71 > 7;
                int v73 = (1 << v71) & 0x83;
                if (v72 || v73 == 0) {
                  break;
                }
                v70 += 16;
                if (!v70) {
                  goto LABEL_89;
                }
              }
              int v37 = 1;
LABEL_92:
              int v56 = 0;
              uint64_t v57 = *(unsigned __int8 *)(v17 + 16) - 33;
              if (v57 <= 0x37)
              {
                if (((1 << (*(unsigned char *)(v17 + 16) - 33)) & 0x8000000000041) == 0)
                {
                  if (((1 << (*(unsigned char *)(v17 + 16) - 33)) & 0x808001C8000010) == 0)
                  {
                    if (v57 == 28) {
                      int v56 = (*(_WORD *)(v17 + 18) & 0x301) != 0;
                    }
                    goto LABEL_133;
                  }
                  goto LABEL_132;
                }
                uint64_t v58 = *(void *)(v17 + 64);
                if (v58 && ((*(unsigned char *)(v58 + 20) & 4) != 0 || (*(unsigned char *)(v58 + 17) & 0x10) != 0)) {
                  goto LABEL_116;
                }
                LODWORD(v89) = 7;
                if (sub_1CC5CB59C(v17, (__int32 *)&v89, 1uLL))
                {
                  uint64_t v63 = *(void *)(v17 - 32);
                  if (!v63
                    || *(unsigned char *)(v63 + 16)
                    || *(void *)(v63 + 24) != *(void *)(v17 + 72)
                    || *(_DWORD *)(v63 + 36) != 7)
                  {
LABEL_132:
                    int v56 = 1;
                    goto LABEL_133;
                  }
                }
                if (llvm::CallBase::hasFnAttrOnCalledFunction(v17, 66)) {
LABEL_116:
                }
                  int v56 = 0;
                else {
                  int v56 = llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44) ^ 1;
                }
              }
LABEL_133:
              LODWORD(v87) = v87 | v35;
              v15 |= v37;
              HIDWORD(v87) |= v56;
              goto LABEL_134;
            }
          }
LABEL_89:
          if ((llvm::CallBase::hasFnAttrOnCalledFunction(v17, 45) & 1) == 0)
          {
            int v37 = llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44) ^ 1;
            goto LABEL_92;
          }
        }
        int v37 = 0;
        goto LABEL_92;
      }
      uint64_t v60 = *(void *)(v17 + 64);
      if (!v60 || (*(unsigned char *)(v60 + 17) & 0x30) == 0)
      {
        int v61 = *(_DWORD *)(v17 + 20);
        if (v61 < 0)
        {
          uint64_t v76 = v17 - 32 * (v61 & 0x7FFFFFF);
          uint64_t v79 = *(void *)(v76 - 8);
          uint64_t v77 = v76 - 8;
          uint64_t v78 = v79;
          if (v79)
          {
            uint64_t v80 = -v78;
            do
            {
              unsigned int v81 = *(_DWORD *)(*(void *)(v77 + v80) + 8);
              BOOL v72 = v81 > 7;
              int v82 = (1 << v81) & 0x83;
              if (v72 || v82 == 0) {
                goto LABEL_165;
              }
              v80 += 16;
            }
            while (v80);
          }
        }
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v17, 45) & 1) == 0)
        {
          int v35 = llvm::CallBase::hasFnAttrOnCalledFunction(v17, 44) ^ 1;
          goto LABEL_48;
        }
      }
      int v35 = 0;
      goto LABEL_48;
    }
    int v21 = *(_DWORD *)(v14 - 4);
    if (v21 < 0 && (*(void *)(v16 - 32 * (v21 & 0x7FFFFFF) - 8) & 0xFFFFFFFF0) != 0
      || (uint64_t v22 = *(void *)(v14 - 56)) == 0
      || *(unsigned char *)(v22 + 16)
      || *(void *)(v22 + 24) != *(void *)(v14 + 48)
      || (unint64_t v89 = *(llvm **)(v14 - 56), *(void *)&v88[0] = 0, (sub_1CC8B6C50(v86, &v89, v88) & 1) == 0))
    {
      unsigned __int8 ModRefBehavior = llvm::AAResults::getModRefBehavior(a3, v14 - 24);
      if ((ModRefBehavior & 3) != 0)
      {
        unsigned __int8 v24 = ModRefBehavior;
        if (!sub_1CC27D470(v17))
        {
          int v25 = v24;
          if ((v24 & 0x30) != 0)
          {
            v15 |= (v24 & 2) >> 1;
            HIDWORD(v87) |= v24;
            LODWORD(v87) = 1;
          }
          else
          {
            int v39 = *(unsigned __int8 *)(v14 - 8);
            if (v39 == 84)
            {
              uint64_t v40 = 0;
            }
            else if (v39 == 39)
            {
              uint64_t v40 = (*(_DWORD *)(v14 + 56) + 1);
            }
            else
            {
              uint64_t v40 = 2;
            }
            int v41 = *(_DWORD *)(v14 - 4);
            uint64_t v42 = v41 & 0x7FFFFFF;
            uint64_t v43 = (uint64_t **)(v16 - 32 * v42);
            if (v41 < 0 && (uint64_t v62 = (uint64_t)*(v43 - 1), (v62 & 0xFFFFFFFF0) != 0)) {
              uint64_t v44 = (*((_DWORD *)v43 - 3) - *(_DWORD *)((char *)v43 - v62));
            }
            else {
              uint64_t v44 = 0;
            }
            if (v43 != (uint64_t **)(v16 - 32 * v40 - 32 * v44 - 32))
            {
              uint64_t v45 = 32 * v42 - 32 * v40 - 32 * v44 - 32;
              do
              {
                uint64_t v46 = (llvm *)*v43;
                uint64_t v47 = **v43;
                if ((*(_DWORD *)(v47 + 8) & 0xFE) == 0x12) {
                  int v48 = *(unsigned __int8 *)(**(void **)(v47 + 16) + 8);
                }
                else {
                  int v48 = *(_DWORD *)(v47 + 8);
                }
                if (v48 == 15)
                {
                  llvm::Instruction::getAAMetadata((uint64_t ***)v17, v88);
                  unint64_t v89 = v46;
                  uint64_t v90 = -1;
                  v91[0] = v88[0];
                  v91[1] = v88[1];
                  if ((llvm::AAResults::pointsToConstantMemory(a3, (uint64_t)&v89, 1) & 1) == 0)
                  {
                    int v49 = *((unsigned __int8 *)llvm::getUnderlyingObject(v89, (const llvm::Value *)6) + 16);
                    BOOL v51 = v49 != 21 && v49 != 59;
                    v15 |= (v25 & 2) >> 1;
                    LODWORD(v87) = v87 | v51;
                    HIDWORD(v87) |= v25;
                  }
                }
                v43 += 4;
                v45 -= 32;
              }
              while (v45);
            }
          }
        }
      }
    }
LABEL_134:
    uint64_t v14 = *(void *)(v14 + 8);
    uint64_t v64 = i - 24;
    if (!i) {
      uint64_t v64 = 0;
    }
    if (v14 == v64 + 40) {
      break;
    }
LABEL_141:
    if (i == v11) {
      goto LABEL_167;
    }
  }
  while (1)
  {
    uint64_t i = *(void *)(i + 8);
    if (i == v11) {
      break;
    }
    uint64_t v65 = i - 24;
    if (!i) {
      uint64_t v65 = 0;
    }
    uint64_t v14 = *(void *)(v65 + 48);
    if (v14 != v65 + 40) {
      goto LABEL_141;
    }
  }
LABEL_167:
  if ((v15 & 1) == 0 && (v87 & 0x100000000) == 0) {
    return 4;
  }
  if (v87) {
    unsigned int v84 = 56;
  }
  else {
    unsigned int v84 = 8;
  }
  if (v15) {
    v84 |= 6u;
  }
  if ((v87 & 0x100000000) != 0) {
    return v84 | 5;
  }
  else {
    return v84;
  }
}

uint64_t llvm::thinLTOPropagateFunctionAttrs(uint64_t a1)
{
  if (!byte_1EBCDE998)
  {
    v2[14] = 0;
    v2[15] = 0;
    int v3 = 0;
    v2[0] = a1;
    sub_1CD4CB74C(v2);
  }
  return 0;
}

void llvm::PostOrderFunctionAttrsPass::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::LazyCallGraph::SCC,llvm::LazyCallGraph&>::getResultImpl();
}

void llvm::initializePostOrderFunctionAttrsLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE6C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC907E44;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE6C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC907E44(llvm *a1)
{
  llvm::initializeAssumptionCacheTrackerPass((uint64_t)a1);
  llvm::initializeCallGraphWrapperPassPass(a1, v2);
  operator new();
}

uint64_t sub_1CC907EEC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE6C0;
  *(_DWORD *)(a1 + 24) = 3;
  *(void *)a1 = &unk_1F2627D90;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE6C8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC907E44;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCDE6C8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::initializeReversePostOrderFunctionAttrsLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE6D0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC90800C;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCDE6D0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC90800C(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CC9080AC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCDE6C1;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F26281E0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE6D0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC90800C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCDE6D0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CC90815C(uint64_t a1)
{
  v31[16] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = 0;
  uint64_t v29 = v31;
  uint64_t v30 = 0x1000000000;
  LODWORD(v20) = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  int v23 = 0;
  *(_OWORD *)unsigned __int8 v24 = 0u;
  *(_OWORD *)int v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)std::string __p = 0u;
  sub_1CBFAF330((int *)&v20, a1);
  while (1)
  {
    sub_1CBFAF5D8(&v20);
    long long v1 = v25[1];
    if (v25[1] == (void *)v26) {
      break;
    }
    if ((void)v26 - (unint64_t)v25[1] == 8)
    {
      uint64_t v2 = *(void *)(*(void *)v25[1] + 8);
      if (v2)
      {
        if (*(unsigned char *)(v2 + 16))
        {
          if (*(unsigned char *)(v2 + 16) != 3 || (*(_DWORD *)(v2 + 20) & 0x7FFFFFF) != 0) {
            goto LABEL_11;
          }
        }
        else if (*(void *)(v2 + 72) != v2 + 72 || (*(unsigned char *)(v2 + 34) & 0x80) != 0)
        {
LABEL_11:
          uint64_t v3 = *(void *)(v2 + 112);
          if ((!v3 || (*(unsigned char *)(v3 + 15) & 0x40) == 0) && (*(_DWORD *)(v2 + 32) & 0xF) == 7)
          {
            if (v30 >= (unint64_t)HIDWORD(v30)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v29 + v30) = v2;
            LODWORD(v30) = v30 + 1;
          }
        }
      }
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
    long long v1 = v25[1];
  }
  if (v1)
  {
    *(void *)&long long v26 = v1;
    operator delete(v1);
  }
  if (v24[0])
  {
    v24[1] = v24[0];
    operator delete(v24[0]);
  }
  MEMORY[0x1D25D9CD0](v21, 8);
  uint64_t v4 = (char *)v29;
  if (v30)
  {
    char v5 = 0;
    unint64_t v6 = (char *)v29 + 8 * v30;
    do
    {
      uint64_t v8 = *((void *)v6 - 1);
      v6 -= 8;
      uint64_t v7 = v8;
      uint64_t v9 = *(void *)(v8 + 8);
      if (v9)
      {
        while (1)
        {
          uint64_t v10 = *(void *)(v9 + 24);
          unsigned int v11 = *(unsigned __int8 *)(v10 + 16);
          if (!v10 || v11 < 0x1C) {
            break;
          }
          unsigned int v13 = v11 - 33;
          BOOL v14 = v13 > 0x33;
          uint64_t v15 = (1 << v13) & 0x8000000000041;
          if (v14 || v15 == 0) {
            break;
          }
          uint64_t v17 = *(void *)(*(void *)(*(void *)(v10 + 40) + 56) + 112);
          if (!v17 || (*(unsigned char *)(v17 + 15) & 0x40) == 0) {
            break;
          }
          uint64_t v9 = *(void *)(v9 + 8);
          if (!v9) {
            goto LABEL_38;
          }
        }
        char v18 = 0;
      }
      else
      {
LABEL_38:
        *(void *)(v7 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v7 + 112), **(uint64_t ***)v7, -1, 30);
        char v18 = 1;
      }
      v5 |= v18;
    }
    while (v6 != v4);
    uint64_t v4 = (char *)v29;
  }
  else
  {
    char v5 = 0;
  }
  if (v4 != (char *)v31) {
    free(v4);
  }
  return v5 & 1;
}

uint64_t sub_1CC9083D0(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void), uint64_t a4)
{
  uint64_t v21 = a1;
  int v8 = sub_1CC908520(*(void *)a2, *(_DWORD *)(a2 + 16), a1, &v22);
  uint64_t v9 = sub_1CC9085BC(a2, &v21);
  if (v8) {
    return v9[1];
  }
  v9[1] = 0;
  uint64_t v10 = (void *)(a1 & 0xFFFFFFFFFFFFFFF8);
  unsigned int v11 = (uint64_t *)v10[3];
  uint64_t v12 = v10[4] - (void)v11;
  if (!v12) {
    goto LABEL_24;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 8 * (v12 >> 3);
  do
  {
    uint64_t v15 = v13;
    uint64_t v16 = *v11;
    __int16 v17 = *(_WORD *)(*v11 + 12);
    if ((v17 & 0x80) == 0) {
      goto LABEL_16;
    }
    int v18 = *(_DWORD *)(v16 + 8);
    uint64_t v13 = *v11;
    if (!v18)
    {
      uint64_t v13 = *(void *)(v16 + 72);
      int v18 = *(_DWORD *)(v13 + 8);
    }
    if (v18 != 1 || (*(unsigned char *)(v13 + 69) & 1) != 0) {
      return 0;
    }
    int v19 = v17 & 0xF;
    if ((v19 - 7) > 1)
    {
      if ((v19 - 2) >= 4)
      {
        if (!v19)
        {
LABEL_21:
          if (v15) {
            uint64_t v13 = v15;
          }
          goto LABEL_23;
        }
      }
      else if (a3(a4, *v10))
      {
        goto LABEL_21;
      }
LABEL_16:
      uint64_t v13 = v15;
      goto LABEL_17;
    }
    if (v15) {
      return 0;
    }
LABEL_17:
    ++v11;
    v14 -= 8;
  }
  while (v14);
  if (!v13) {
    goto LABEL_24;
  }
LABEL_23:
  sub_1CC9085BC(a2, &v21)[1] = v13;
LABEL_24:
  uint64_t v9 = sub_1CC9085BC(a2, &v21);
  return v9[1];
}

uint64_t sub_1CC908520(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (a2 - 1) & a3 & 0xFFFFFFF8;
    unint64_t v6 = (void *)(a1 + 16 * v5);
    unint64_t v7 = *v6 & 0xFFFFFFFFFFFFFFF8;
    if ((a3 & 0xFFFFFFFFFFFFFFF8) == v7)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -8)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -16;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unint64_t v6 = (void *)(a1 + 16 * (v13 & v4));
        unint64_t v7 = *v6 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v8 = 1;
        if ((a3 & 0xFFFFFFFFFFFFFFF8) == v7) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unint64_t v6 = v10;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

uint64_t *sub_1CC9085BC(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CC908520(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t result = v8;
  if (v4) {
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_9;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    sub_1CC90869C(a1, v7);
    uint64_t v8 = 0;
    sub_1CC908520(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    uint64_t result = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if ((~*result & 0xFFFFFFFFFFFFFFF8) != 0) {
    --*(_DWORD *)(a1 + 12);
  }
  *uint64_t result = *a2;
  result[1] = 0;
  return result;
}

void *sub_1CC90869C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      do
      {
        *uint64_t result = -8;
        result += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 16 * v3;
      unsigned int v13 = (uint64_t *)v4;
      do
      {
        uint64_t v14 = *v13;
        if ((~*v13 & 0xFFFFFFFFFFFFFFF0) != 0)
        {
          int v19 = 0;
          sub_1CC908520(*(void *)a1, *(_DWORD *)(a1 + 16), v14, &v19);
          uint64_t v15 = v19;
          uint64_t v16 = v13[1];
          *int v19 = *v13;
          v15[1] = v16;
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    uint64_t v18 = 16 * v17;
    do
    {
      *uint64_t result = -8;
      result += 2;
      v18 -= 16;
    }
    while (v18);
  }
  return result;
}

void sub_1CC9087E4()
{
}

void sub_1CC908824(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC90885C(llvm::PassRegistry *a1, llvm *a2)
{
  v6[0] = &unk_1F2617E40;
  v6[1] = (char *)a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetTransformInfoWrapperPass::ID);
  llvm::getAAResultsAnalysisUsage(a2, v5);

  llvm::CallGraphSCCPass::getAnalysisUsage(a1, a2);
}

BOOL sub_1CC908900(llvm *a1, uint64_t a2)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (llvm::CallGraphSCCPass::skipSCC((uint64_t)a1, a2)) {
    return 0;
  }
  unint64_t v31 = a1;
  char v32 = 0;
  char v37 = 0;
  v38[0] = 0;
  char v39 = 0;
  uint64_t v45 = v47;
  uint64_t v46 = 0x800000000;
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = *(void *)(a2 + 24);
  if (v5 == v6)
  {
    uint64_t v7 = 0;
    unsigned int v8 = (uint64_t *)v47;
  }
  else
  {
    LODWORD(v7) = 0;
    do
    {
      if (v7 >= HIDWORD(v46)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v45 + v7) = *(void *)(*(void *)v5 + 8);
      uint64_t v7 = (v46 + 1);
      LODWORD(v46) = v46 + 1;
      v5 += 8;
    }
    while (v5 != v6);
    unsigned int v8 = (uint64_t *)v45;
  }
  sub_1CC909204((uint64_t)&v48, v8, v7);
  uint64_t v40 = v44;
  int v41 = v44;
  uint64_t v42 = 8;
  int v43 = 0;
  if (v51)
  {
    sub_1CC909564(v50, v51, (uint64_t)&v40);
    if (v51) {
      sub_1CC8A987C(&v31, *v50, v9);
    }
    sub_1CC909918((uint64_t)&v48, (uint64_t)&v40);
    sub_1CC90B06C(&v48, (uint64_t)&v40);
    sub_1CC90B728(v50, v51, (uint64_t)&v40);
    sub_1CC90BD94(v50, v51, (uint64_t)&v40);
    if (!v52[64])
    {
      sub_1CC90C178((uint64_t)&v48, (uint64_t)&v40);
      sub_1CC90C7FC((uint64_t)&v48, (uint64_t)&v40);
      sub_1CC90CFC4((uint64_t)&v48, (uint64_t)&v40);
      sub_1CC90D890(v50, v51, (uint64_t)&v40);
    }
    sub_1CC90E03C((uint64_t)&v48, (uint64_t)&v40);
    if (v51)
    {
      uint64_t v11 = v50;
      uint64_t v12 = &v50[v51];
      do
      {
        unsigned int v13 = *v11;
        if (*v11 && llvm::inferAttributesFromOthers(*v11, v10))
        {
          uint64_t v14 = v41;
          uint64_t v15 = HIDWORD(v42);
          if (v41 != v40)
          {
            uint64_t v10 = (llvm::Function *)v42;
LABEL_30:
            if (3 * (int)v10 <= (4 * (HIDWORD(v42) - v43)))
            {
              if (v10 >= 0x40) {
                LODWORD(v10) = 2 * v10;
              }
              else {
                LODWORD(v10) = 128;
              }
            }
            else if ((int)v10 - HIDWORD(v42) >= v10 >> 3)
            {
              goto LABEL_32;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v40, v10);
            uint64_t v10 = (llvm::Function *)v42;
            uint64_t v14 = v41;
LABEL_32:
            int v19 = v10 - 1;
            unsigned int v20 = (v10 - 1) & ((v13 >> 4) ^ (v13 >> 9));
            uint64_t v21 = &v14[8 * v20];
            uint64_t v22 = *(llvm **)v21;
            if (*(void *)v21 == -1)
            {
              int v23 = 0;
LABEL_44:
              if (v23) {
                int v27 = v23;
              }
              else {
                int v27 = (llvm **)v21;
              }
              if (*v27 != v13)
              {
                if (*v27 == (llvm *)-2) {
                  --v43;
                }
                else {
                  ++HIDWORD(v42);
                }
                *int v27 = v13;
              }
            }
            else
            {
              int v23 = 0;
              int v24 = 1;
              while (v22 != v13)
              {
                if (v23) {
                  BOOL v25 = 0;
                }
                else {
                  BOOL v25 = v22 == (llvm *)-2;
                }
                if (v25) {
                  int v23 = (llvm **)v21;
                }
                unsigned int v26 = v20 + v24++;
                unsigned int v20 = v26 & v19;
                uint64_t v21 = &v14[8 * (v26 & v19)];
                uint64_t v22 = *(llvm **)v21;
                if (*(void *)v21 == -1) {
                  goto LABEL_44;
                }
              }
            }
            goto LABEL_51;
          }
          if (HIDWORD(v42))
          {
            uint64_t v16 = 0;
            uint64_t v17 = 8 * HIDWORD(v42);
            uint64_t v18 = (llvm **)v41;
            while (*v18 != v13)
            {
              if (*v18 == (llvm *)-2) {
                uint64_t v16 = v18;
              }
              ++v18;
              v17 -= 8;
              if (!v17)
              {
                if (!v16) {
                  goto LABEL_27;
                }
                uint64_t *v16 = v13;
                --v43;
                goto LABEL_51;
              }
            }
            goto LABEL_51;
          }
LABEL_27:
          uint64_t v10 = (llvm::Function *)v42;
          if (HIDWORD(v42) >= v42) {
            goto LABEL_30;
          }
          ++HIDWORD(v42);
          *(void *)&v41[8 * v15] = v13;
        }
LABEL_51:
        ++v11;
      }
      while (v11 != v12);
    }
  }
  if (v50 != (llvm::GlobalValue **)v52) {
    free(v50);
  }
  if ((v48 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v49, 8);
  }
  int v28 = HIDWORD(v42);
  int v29 = v43;
  if (v41 != v40) {
    free(v41);
  }
  if (v45 != v47) {
    free(v45);
  }
  BOOL v4 = v28 != v29;
  if (v39)
  {
    llvm::AAResults::~AAResults((llvm::AAResults *)v38);
    char v39 = 0;
  }
  if (v37)
  {
    if (v36 != v35) {
      free(v36);
    }
    if (v34 != v33) {
      free(v34);
    }
  }
  return v4;
}

void sub_1CC909204(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)a1 = 1;
  int64x2_t v3 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 8) = v3;
  *(int64x2_t *)(a1 + 24) = v3;
  *(int64x2_t *)(a1 + 40) = v3;
  *(int64x2_t *)(a1 + 56) = v3;
  *(void *)(a1 + 72) = a1 + 88;
  *(void *)(a1 + 80) = 0x800000000;
  *(unsigned char *)(a1 + 152) = 0;
  if (a3)
  {
    BOOL v4 = a2;
    uint64_t v6 = &a2[a3];
    while (1)
    {
      uint64_t v7 = *v4;
      uint64_t v36 = v7;
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 112);
        if (!v8) {
          goto LABEL_29;
        }
        if ((*(unsigned char *)(v8 + 17) & 8) == 0 && (*(unsigned char *)(v8 + 14) & 2) == 0) {
          break;
        }
      }
LABEL_28:
      *(unsigned char *)(a1 + 152) = 1;
LABEL_31:
      if (++v4 == v6) {
        return;
      }
    }
    if (*(_DWORD *)(v8 + 8))
    {
      uint64_t v9 = *(void *)(v8 + 40);
      if (v9)
      {
        int v10 = *(_DWORD *)(v9 + 40);
        if (v10)
        {
          uint64_t v11 = *(void *)(v9 + 24);
          if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
            && __cxa_guard_acquire(&qword_1EBCBE588))
          {
            unint64_t v35 = llvm::hashing::detail::fixed_seed_override;
            if (!llvm::hashing::detail::fixed_seed_override) {
              unint64_t v35 = 0xFF51AFD7ED558CCDLL;
            }
            qword_1EBCBE580 = v35;
            __cxa_guard_release(&qword_1EBCBE588);
          }
          uint64_t v12 = __ROR8__(qword_1EBCBE580 ^ 0x7A48DC6FE7EA5090, 30);
          unint64_t v13 = 0x9DDFEA08EB382D69
              * ((qword_1EBCBE580 - 0x2D69957673248ED7) ^ ((0x9DDFEA08EB382D69
                                                            * ((v12 - 0x574D426307C1BC2DLL) ^ (qword_1EBCBE580
                                                                                             - 0x2D69957673248ED7))) >> 47) ^ (0x9DDFEA08EB382D69 * ((v12 - 0x574D426307C1BC2DLL) ^ (qword_1EBCBE580 - 0x2D69957673248ED7))));
          unsigned int v14 = -348639895 * ((v13 >> 47) ^ v13);
          for (int i = 1; ; ++i)
          {
            unsigned int v16 = v14 & (v10 - 1);
            uint64_t v17 = (uint64_t *)(v11 + 24 * v16);
            uint64_t v18 = *v17;
            if (*v17 == -1)
            {
              if ("coroutine.presplit" == (char *)-1) {
                goto LABEL_28;
              }
            }
            else if (v18 == -2)
            {
              if ("coroutine.presplit" == (char *)-2) {
                goto LABEL_28;
              }
            }
            else if (v17[1] == 18)
            {
              BOOL v19 = *(void *)v18 == 0x6E6974756F726F63 && *(void *)(v18 + 8) == 0x6C70736572702E65;
              if (v19 && *(_WORD *)(v18 + 16) == 29801) {
                goto LABEL_28;
              }
            }
            if (v18 == -1) {
              break;
            }
            unsigned int v14 = i + v16;
          }
        }
      }
    }
LABEL_29:
    if (!*(unsigned char *)(a1 + 152))
    {
      uint64_t v21 = v36 + 72;
      for (uint64_t j = *(void *)(v36 + 80); j != v21; uint64_t j = *(void *)(j + 8))
      {
        uint64_t v23 = j - 24;
        if (!j) {
          uint64_t v23 = 0;
        }
        uint64_t v24 = v23 + 40;
        uint64_t v25 = *(void *)(v23 + 48);
        if (v25 != v24)
        {
          while (1)
          {
            uint64_t v26 = v25 - 24;
            if (!v25) {
              uint64_t v26 = 0;
            }
            unsigned int v27 = *(unsigned __int8 *)(v26 + 16) - 33;
            BOOL v28 = v27 > 0x33;
            uint64_t v29 = (1 << v27) & 0x8000000000041;
            if (!v28 && v29 != 0)
            {
              uint64_t v31 = *(void *)(v25 - 56);
              if (!v31 || *(unsigned char *)(v31 + 16) || *(void *)(v31 + 24) != *(void *)(v25 + 48)) {
                break;
              }
            }
            uint64_t v25 = *(void *)(v25 + 8);
            uint64_t v32 = j - 24;
            if (!j) {
              uint64_t v32 = 0;
            }
            uint64_t v33 = v32 + 40;
            while (v25 == v33)
            {
              uint64_t j = *(void *)(j + 8);
              if (j == v21) {
                goto LABEL_30;
              }
              uint64_t v34 = j - 24;
              if (!j) {
                uint64_t v34 = 0;
              }
              uint64_t v33 = v34 + 40;
              uint64_t v25 = *(void *)(v34 + 48);
            }
            if (j == v21) {
              goto LABEL_30;
            }
          }
          *(unsigned char *)(a1 + 152) = 1;
          break;
        }
      }
    }
LABEL_30:
    sub_1CC8AEA28(a1, &v36);
    goto LABEL_31;
  }
}

void sub_1CC909564(llvm::GlobalValue **a1, int a2, uint64_t a3)
{
  if (a2)
  {
    BOOL v4 = a1;
    uint64_t v5 = &a1[a2];
    do
    {
      uint64_t v6 = *v4;
      if (*v4) {
        BOOL v7 = *((unsigned char *)*v4 + 16) == 3;
      }
      else {
        BOOL v7 = 0;
      }
      if (v7)
      {
        if ((*((_DWORD *)v6 + 5) & 0x7FFFFFF) == 0) {
          goto LABEL_86;
        }
      }
      else if (!*((unsigned char *)*v4 + 16) {
             && *((llvm::GlobalValue **)v6 + 9) == (llvm::GlobalValue *)((char *)v6 + 72)
      }
             && (*((unsigned char *)v6 + 34) & 0x80) == 0)
      {
        goto LABEL_86;
      }
      if (((1 << (*((_DWORD *)v6 + 8) & 0xF)) & 0x7D5) == 0
        || (llvm::GlobalValue::isInterposable(*v4) & 1) != 0
        || *(unsigned char *)(**(void **)(*((void *)v6 + 3) + 16) + 8) == 7)
      {
        goto LABEL_86;
      }
      if (*((_WORD *)v6 + 9))
      {
        llvm::Function::BuildLazyArguments(v6);
        uint64_t v8 = *((void *)v6 + 11);
        if (*((_WORD *)v6 + 9))
        {
          llvm::Function::BuildLazyArguments(v6);
          uint64_t v9 = *((void *)v6 + 11);
          goto LABEL_18;
        }
      }
      else
      {
        uint64_t v8 = *((void *)v6 + 11);
      }
      uint64_t v9 = v8;
LABEL_18:
      uint64_t v10 = v9 + 40 * *((void *)v6 + 12);
      while (v8 != v10)
      {
        uint64_t v11 = *(void *)(*(void *)(v8 + 24) + 112);
        if (v11)
        {
          unsigned int v12 = *(_DWORD *)(v8 + 32) + 2;
          if (v12 < *(_DWORD *)(v11 + 8))
          {
            uint64_t v13 = *(void *)(v11 + 8 * v12 + 40);
            if (v13)
            {
              if ((*(unsigned char *)(v13 + 17) & 0x40) != 0) {
                goto LABEL_86;
              }
            }
          }
        }
        v8 += 40;
      }
      unsigned int v14 = (void *)*((void *)v6 + 10);
      if (v14 != (void *)((char *)v6 + 72))
      {
        uint64_t v15 = 0;
        do
        {
          unsigned int v16 = v15;
          uint64_t v17 = v14 - 3;
          if (!v14) {
            uint64_t v17 = 0;
          }
          uint64_t v18 = (void *)v17[5];
          if (v18 != v17 + 5)
          {
            BOOL v19 = v18 - 3;
            if (!v18) {
              BOOL v19 = 0;
            }
            unsigned int v20 = *((unsigned __int8 *)v19 + 16) - 40;
            if (v20 < 0xFFFFFFF5) {
              BOOL v19 = 0;
            }
            if (v18)
            {
              if (*((unsigned char *)v19 + 16) == 29 && v20 >= 0xFFFFFFF5)
              {
                uint64_t v22 = *((_DWORD *)v19 + 5) & 0x7FFFFFF;
                uint64_t v23 = v22 ? (llvm::Value *)v19[-4 * v22] : 0;
                uint64_t v15 = llvm::Value::stripPointerCasts(v23);
                if (*((unsigned char *)v15 + 16) != 21) {
                  goto LABEL_86;
                }
                if (*(void *)v15 != **(void **)(*((void *)v6 + 3) + 16)) {
                  goto LABEL_86;
                }
                if (v16)
                {
                  BOOL v7 = v16 == v15;
                  uint64_t v15 = v16;
                  if (!v7) {
                    goto LABEL_86;
                  }
                }
              }
            }
          }
          unsigned int v14 = (void *)v14[1];
        }
        while (v14 != (void *)((char *)v6 + 72));
        if (!v15) {
          goto LABEL_86;
        }
        uint64_t v24 = *((void *)v15 + 3);
        *(void *)(v24 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v24 + 112), **(uint64_t ***)v24, *((_DWORD *)v15 + 8) + 1, 46);
        uint64_t v25 = *(void *)(a3 + 8);
        uint64_t v26 = *(unsigned int *)(a3 + 20);
        if (v25 != *(void *)a3)
        {
          unsigned int v30 = *(_DWORD *)(a3 + 16);
          goto LABEL_65;
        }
        if (!v26)
        {
LABEL_60:
          unsigned int v30 = *(_DWORD *)(a3 + 16);
          if (v26 < v30)
          {
            *(_DWORD *)(a3 + 20) = v26 + 1;
            *(void *)(v25 + 8 * v26) = v6;
            goto LABEL_86;
          }
LABEL_65:
          if (3 * v30 <= 4 * ((int)v26 - *(_DWORD *)(a3 + 24)))
          {
            if (v30 >= 0x40) {
              v30 *= 2;
            }
            else {
              unsigned int v30 = 128;
            }
          }
          else if (v30 - v26 >= v30 >> 3)
          {
            goto LABEL_67;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v30);
          unsigned int v30 = *(_DWORD *)(a3 + 16);
          uint64_t v25 = *(void *)(a3 + 8);
LABEL_67:
          unsigned int v31 = v30 - 1;
          unsigned int v32 = (v30 - 1) & ((v6 >> 4) ^ (v6 >> 9));
          uint64_t v33 = (llvm::GlobalValue **)(v25 + 8 * v32);
          uint64_t v34 = *v33;
          if (*v33 == (llvm::GlobalValue *)-1)
          {
            unint64_t v35 = 0;
LABEL_79:
            if (v35) {
              char v39 = v35;
            }
            else {
              char v39 = v33;
            }
            if (*v39 != v6)
            {
              if (*v39 == (llvm::GlobalValue *)-2) {
                --*(_DWORD *)(a3 + 24);
              }
              else {
                ++*(_DWORD *)(a3 + 20);
              }
              *char v39 = v6;
            }
          }
          else
          {
            unint64_t v35 = 0;
            int v36 = 1;
            while (v34 != v6)
            {
              if (v35) {
                BOOL v37 = 0;
              }
              else {
                BOOL v37 = v34 == (llvm::GlobalValue *)-2;
              }
              if (v37) {
                unint64_t v35 = v33;
              }
              unsigned int v38 = v32 + v36++;
              unsigned int v32 = v38 & v31;
              uint64_t v33 = (llvm::GlobalValue **)(v25 + 8 * (v38 & v31));
              uint64_t v34 = *v33;
              if (*v33 == (llvm::GlobalValue *)-1) {
                goto LABEL_79;
              }
            }
          }
          goto LABEL_86;
        }
        unsigned int v27 = 0;
        uint64_t v28 = 8 * v26;
        uint64_t v29 = *(llvm::GlobalValue ***)(a3 + 8);
        while (*v29 != v6)
        {
          if (*v29 == (llvm::GlobalValue *)-2) {
            unsigned int v27 = v29;
          }
          ++v29;
          v28 -= 8;
          if (!v28)
          {
            if (!v27) {
              goto LABEL_60;
            }
            *unsigned int v27 = v6;
            --*(_DWORD *)(a3 + 24);
            break;
          }
        }
      }
LABEL_86:
      ++v4;
    }
    while (v4 != v5);
  }
}

void sub_1CC909918(uint64_t a1, uint64_t a2)
{
  v258[4] = *MEMORY[0x1E4F143B8];
  v253 = (uint64_t *)v254;
  v254[0] = 0;
  uint64_t v255 = 0;
  v256 = v258;
  uint64_t v257 = 0x400000000;
  v254[1] = 0;
  uint64_t v3 = *(unsigned int *)(a1 + 80);
  if (!v3) {
    goto LABEL_307;
  }
  uint64_t v4 = a1;
  uint64_t v5 = *(llvm::GlobalValue ***)(a1 + 72);
  __int16 v237 = &v5[v3];
  do
  {
    uint64_t v6 = *v5;
    if (*v5) {
      BOOL v7 = *((unsigned char *)*v5 + 16) == 3;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7)
    {
      if ((*((_DWORD *)v6 + 5) & 0x7FFFFFF) == 0) {
        goto LABEL_299;
      }
    }
    else if (!*((unsigned char *)*v5 + 16) {
           && *((llvm::GlobalValue **)v6 + 9) == (llvm::GlobalValue *)((char *)v6 + 72)
    }
           && (*((unsigned char *)v6 + 34) & 0x80) == 0)
    {
      goto LABEL_299;
    }
    if ((1 << (*((_DWORD *)v6 + 8) & 0xF)) & 0x7D5) == 0 || (llvm::GlobalValue::isInterposable(*v5)) {
      goto LABEL_299;
    }
    uint64_t v236 = v5;
    unsigned int v238 = v6;
    if (!byte_1EBCDE758) {
      goto LABEL_139;
    }
    uint64_t v8 = *((void *)v6 + 10);
    uint64_t v9 = v8 ? v8 - 24 : 0;
    uint64_t v10 = v9 + 40;
    uint64_t v11 = *(void *)(v9 + 48);
    if (v11 == v9 + 40) {
      goto LABEL_139;
    }
    char v12 = 0;
    do
    {
      if (v11) {
        uint64_t v13 = v11 - 24;
      }
      else {
        uint64_t v13 = 0;
      }
      int v14 = *(unsigned __int8 *)(v13 + 16);
      if ((v14 - 33) <= 0x33 && ((1 << (v14 - 33)) & 0x8000000000041) != 0)
      {
        uint64_t v16 = *(void *)(v11 - 56);
        if (!v16 || *(unsigned char *)(v16 + 16) || *(void *)(v16 + 24) != *(void *)(v11 + 48))
        {
LABEL_30:
          int v14 = *(unsigned __int8 *)(v13 + 16);
          uint64_t v6 = v238;
          goto LABEL_31;
        }
        if (*(_WORD *)(v16 + 18))
        {
          llvm::Function::BuildLazyArguments(*(llvm::Function **)(v11 - 56));
          uint64_t v18 = *(void *)(v16 + 88);
          if (*(_WORD *)(v16 + 18))
          {
            llvm::Function::BuildLazyArguments((llvm::Function *)v16);
            uint64_t v19 = *(void *)(v16 + 88);
            goto LABEL_46;
          }
        }
        else
        {
          uint64_t v18 = *(void *)(v16 + 88);
        }
        uint64_t v19 = v18;
LABEL_46:
        uint64_t v20 = v19 + 40 * *(void *)(v16 + 96);
        while (1)
        {
          if (v18 == v20) {
            goto LABEL_30;
          }
          unsigned int v21 = *(_DWORD *)(*(void *)v18 + 8);
          if (v21 != 15) {
            goto LABEL_51;
          }
          uint64_t v22 = *(void *)(v18 + 24);
          uint64_t v23 = *(void *)(v22 + 112);
          if (!v23) {
            goto LABEL_51;
          }
          uint64_t v24 = *(unsigned int *)(v18 + 32);
          if ((v24 + 2) >= *(_DWORD *)(v23 + 8)) {
            goto LABEL_51;
          }
          uint64_t v25 = *(void *)(v23 + 8 * (v24 + 2) + 40);
          if (!v25) {
            goto LABEL_51;
          }
          int v26 = *(char *)(v25 + 16);
          if ((v26 & 0x80000000) == 0 || (v26 & 0x10) == 0) {
            break;
          }
LABEL_70:
          uint64_t v34 = *(uint64_t **)(v11 - 24 - 32 * (*(_DWORD *)(v11 - 4) & 0x7FFFFFF) + 32 * v24);
          if (v34) {
            BOOL v35 = *((unsigned char *)v34 + 16) == 21;
          }
          else {
            BOOL v35 = 0;
          }
          if (!v35) {
            goto LABEL_51;
          }
          uint64_t v36 = *v34;
          unsigned int v37 = *(_DWORD *)(*v34 + 8);
          uint64_t v38 = v34[3];
          int v39 = *((_DWORD *)v34 + 8);
          if (v37 != 15) {
            goto LABEL_78;
          }
          uint64_t v40 = *(void *)(v38 + 112);
          if (!v40 || (v39 + 2) >= *(_DWORD *)(v40 + 8)) {
            goto LABEL_78;
          }
          uint64_t v41 = v38;
          uint64_t v42 = *(void *)(v40 + 8 * (v39 + 2) + 40);
          if (!v42) {
            goto LABEL_82;
          }
          if (*(char *)(v42 + 16) < 0)
          {
            uint64_t v4 = a1;
            goto LABEL_51;
          }
          if ((*(unsigned char *)(v42 + 21) & 0x10) == 0) {
            goto LABEL_82;
          }
          int v43 = (void *)(v42 + 48);
          uint64_t v44 = 8 * *(unsigned int *)(v42 + 8) - 8 * *(unsigned int *)(v42 + 32);
          if (v44)
          {
            unint64_t v45 = v44 >> 3;
            do
            {
              unint64_t v46 = v45 >> 1;
              uint64_t v47 = &v43[v45 >> 1];
              uint64_t v48 = *v47;
              if (*v47) {
                LODWORD(v48) = *(_DWORD *)(v48 + 12);
              }
              uint64_t v49 = v47 + 1;
              v45 += ~v46;
              if ((int)v48 < 76) {
                int v43 = v49;
              }
              else {
                unint64_t v45 = v46;
              }
            }
            while (v45);
          }
          if (!*(void *)(*v43 + 16))
          {
LABEL_82:
            uint64_t v4 = a1;
            uint64_t v38 = v41;
LABEL_78:
            *(void *)(v38 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v38 + 112), **(uint64_t ***)v38, v39 + 1, 39);
            char v12 = 1;
            goto LABEL_51;
          }
          if ((v37 & 0xFE) == 0x12)
          {
            unsigned int v37 = *(_DWORD *)(**(void **)(v36 + 16) + 8);
            if (v41)
            {
LABEL_94:
              if (*(unsigned char *)(v40 + 17)) {
                goto LABEL_82;
              }
              uint64_t v4 = a1;
              uint64_t v38 = v41;
              if (v37 > 0xFF) {
                goto LABEL_78;
              }
              goto LABEL_51;
            }
          }
          else if (v41)
          {
            goto LABEL_94;
          }
          uint64_t v4 = a1;
          if (v37 >= 0x100)
          {
            uint64_t v38 = 0;
            goto LABEL_78;
          }
LABEL_51:
          v18 += 40;
        }
        if ((*(unsigned char *)(v25 + 21) & 0x10) == 0) {
          goto LABEL_51;
        }
        unsigned int v27 = (void *)(v25 + 48);
        uint64_t v28 = 8 * *(unsigned int *)(v25 + 8) - 8 * *(unsigned int *)(v25 + 32);
        if (v28)
        {
          unint64_t v29 = v28 >> 3;
          do
          {
            unint64_t v30 = v29 >> 1;
            unsigned int v31 = &v27[v29 >> 1];
            uint64_t v32 = *v31;
            if (*v31) {
              LODWORD(v32) = *(_DWORD *)(v32 + 12);
            }
            uint64_t v33 = v31 + 1;
            v29 += ~v30;
            if ((int)v32 < 76) {
              unsigned int v27 = v33;
            }
            else {
              unint64_t v29 = v30;
            }
          }
          while (v29);
        }
        if (!*(void *)(*v27 + 16)) {
          goto LABEL_51;
        }
        if ((v21 & 0xFE) == 0x12)
        {
          unsigned int v21 = *(_DWORD *)(**(void **)(*(void *)v18 + 16) + 8);
          if (!v22) {
            goto LABEL_67;
          }
        }
        else if (!v22)
        {
          goto LABEL_67;
        }
        if (*(unsigned char *)(v23 + 17)) {
          goto LABEL_51;
        }
LABEL_67:
        if (v21 > 0xFF) {
          goto LABEL_51;
        }
        goto LABEL_70;
      }
LABEL_31:
      if (v14 != 84)
      {
        switch(v14)
        {
          case 29:
          case 34:
          case 35:
            goto LABEL_106;
          case 30:
          case 31:
          case 32:
          case 33:
          case 37:
            goto LABEL_36;
          case 36:
          case 38:
            if (*(_WORD *)(v13 + 18)) {
              goto LABEL_36;
            }
            goto LABEL_106;
          default:
            if (v14 != 80) {
              goto LABEL_36;
            }
            PersonalityFunsigned int n = (llvm::Value *)llvm::Function::getPersonalityFn(*(llvm::Function **)(*(void *)(v13 + 40)
                                                                                               + 56));
            if (llvm::classifyEHPersonality(PersonalityFn, v51) != 10) {
              goto LABEL_106;
            }
            goto LABEL_37;
        }
      }
      uint64_t v17 = *(void *)(v13 + 64);
      if ((!v17 || (*(unsigned char *)(v17 + 16) & 0x20) == 0)
        && !llvm::CallBase::hasFnAttrOnCalledFunction(v13, 37))
      {
        break;
      }
LABEL_36:
      if ((llvm::Instruction::willReturn((llvm::Instruction *)v13) & 1) == 0) {
        break;
      }
LABEL_37:
      uint64_t v11 = *(void *)(v11 + 8);
    }
    while (v11 != v10);
LABEL_106:
    if ((v12 & 1) == 0) {
      goto LABEL_139;
    }
    uint64_t v52 = *(void *)(a2 + 8);
    uint64_t v53 = *(unsigned int *)(a2 + 20);
    if (v52 != *(void *)a2)
    {
      unsigned int v57 = *(_DWORD *)(a2 + 16);
      goto LABEL_118;
    }
    if (!v53)
    {
LABEL_115:
      unsigned int v57 = *(_DWORD *)(a2 + 16);
      if (v53 < v57)
      {
        *(_DWORD *)(a2 + 20) = v53 + 1;
        *(void *)(v52 + 8 * v53) = v6;
        goto LABEL_139;
      }
LABEL_118:
      if (3 * v57 <= 4 * ((int)v53 - *(_DWORD *)(a2 + 24)))
      {
        if (v57 >= 0x40) {
          v57 *= 2;
        }
        else {
          unsigned int v57 = 128;
        }
      }
      else if (v57 - v53 >= v57 >> 3)
      {
        goto LABEL_120;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v57);
      unsigned int v57 = *(_DWORD *)(a2 + 16);
      uint64_t v52 = *(void *)(a2 + 8);
LABEL_120:
      unsigned int v58 = v57 - 1;
      unsigned int v59 = (v57 - 1) & ((v6 >> 4) ^ (v6 >> 9));
      uint64_t v60 = (llvm::GlobalValue **)(v52 + 8 * v59);
      int v61 = *v60;
      if (*v60 == (llvm::GlobalValue *)-1)
      {
        uint64_t v62 = 0;
LABEL_132:
        if (v62) {
          uint64_t v66 = v62;
        }
        else {
          uint64_t v66 = v60;
        }
        if (*v66 != v6)
        {
          if (*v66 == (llvm::GlobalValue *)-2) {
            --*(_DWORD *)(a2 + 24);
          }
          else {
            ++*(_DWORD *)(a2 + 20);
          }
          *uint64_t v66 = v6;
        }
      }
      else
      {
        uint64_t v62 = 0;
        int v63 = 1;
        while (v61 != v6)
        {
          if (v62) {
            BOOL v64 = 0;
          }
          else {
            BOOL v64 = v61 == (llvm::GlobalValue *)-2;
          }
          if (v64) {
            uint64_t v62 = v60;
          }
          unsigned int v65 = v59 + v63++;
          unsigned int v59 = v65 & v58;
          uint64_t v60 = (llvm::GlobalValue **)(v52 + 8 * (v65 & v58));
          int v61 = *v60;
          if (*v60 == (llvm::GlobalValue *)-1) {
            goto LABEL_132;
          }
        }
      }
      goto LABEL_139;
    }
    uint64_t v54 = 0;
    uint64_t v55 = 8 * v53;
    int v56 = *(llvm::GlobalValue ***)(a2 + 8);
    while (*v56 != v6)
    {
      if (*v56 == (llvm::GlobalValue *)-2) {
        uint64_t v54 = v56;
      }
      ++v56;
      v55 -= 8;
      if (!v55)
      {
        if (!v54) {
          goto LABEL_115;
        }
        *uint64_t v54 = v6;
        --*(_DWORD *)(a2 + 24);
        break;
      }
    }
LABEL_139:
    uint64_t v67 = *((void *)v6 + 14);
    if (!v67
      || (*(unsigned char *)(v67 + 17) & 0x30) == 0
      || (*(unsigned char *)(v67 + 16) & 0x20) == 0
      || *(unsigned char *)(**(void **)(*((void *)v6 + 3) + 16) + 8) != 7)
    {
      if (*((_WORD *)v6 + 9))
      {
        llvm::Function::BuildLazyArguments(v6);
        unint64_t v69 = *((void *)v6 + 11);
        if (*((_WORD *)v6 + 9)) {
          llvm::Function::BuildLazyArguments(v6);
        }
        unint64_t v70 = *((void *)v6 + 11);
      }
      else
      {
        unint64_t v69 = *((void *)v6 + 11);
        unint64_t v70 = v69;
      }
      unint64_t v71 = v70 + 40 * *((void *)v6 + 12);
      if (v69 == v71) {
        goto LABEL_299;
      }
      unsigned int v235 = (v6 >> 4) ^ (v6 >> 9);
      while (1)
      {
        if (*(unsigned char *)(*(void *)v69 + 8) != 15) {
          goto LABEL_231;
        }
        if ((llvm::Argument::hasNoCaptureAttr((llvm::Argument *)v69) & 1) == 0)
        {
          unsigned int v244 = (void **)&unk_1F2627E40;
          LOBYTE(v245) = 0;
          uint64_t v246 = v248;
          uint64_t v247 = 0x400000000;
          *(void *)&long long v250 = v4;
          llvm::PointerMayBeCaptured((llvm *)v69, (const llvm::Value *)&v244, 0);
          if ((_BYTE)v245) {
            goto LABEL_155;
          }
          if (!v247)
          {
            uint64_t v87 = *(void *)(v69 + 24);
            *(void *)(v87 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v87 + 112), **(uint64_t ***)v87, *(_DWORD *)(v69 + 32) + 1, 22);
            uint64_t v88 = *(void *)(a2 + 8);
            uint64_t v89 = *(unsigned int *)(a2 + 20);
            if (v88 == *(void *)a2)
            {
              if (v89)
              {
                uint64_t v90 = 0;
                uint64_t v91 = 8 * v89;
                uint64_t v92 = *(llvm::GlobalValue ***)(a2 + 8);
                while (*v92 != v238)
                {
                  if (*v92 == (llvm::GlobalValue *)-2) {
                    uint64_t v90 = v92;
                  }
                  ++v92;
                  v91 -= 8;
                  if (!v91)
                  {
                    if (!v90) {
                      goto LABEL_186;
                    }
                    *uint64_t v90 = v238;
                    --*(_DWORD *)(a2 + 24);
                    goto LABEL_155;
                  }
                }
                goto LABEL_155;
              }
LABEL_186:
              unsigned int v93 = *(_DWORD *)(a2 + 16);
              if (v89 < v93)
              {
                *(_DWORD *)(a2 + 20) = v89 + 1;
                *(void *)(v88 + 8 * v89) = v238;
LABEL_155:
                unsigned int v244 = (void **)&unk_1F2627E40;
                if (v246 != v248) {
                  free(v246);
                }
                uint64_t v6 = v238;
                goto LABEL_158;
              }
            }
            else
            {
              unsigned int v93 = *(_DWORD *)(a2 + 16);
            }
            if (3 * v93 <= 4 * ((int)v89 - *(_DWORD *)(a2 + 24)))
            {
              if (v93 >= 0x40) {
                v93 *= 2;
              }
              else {
                unsigned int v93 = 128;
              }
            }
            else if (v93 - v89 >= v93 >> 3)
            {
              goto LABEL_210;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v93);
            unsigned int v93 = *(_DWORD *)(a2 + 16);
            uint64_t v88 = *(void *)(a2 + 8);
LABEL_210:
            unsigned int v102 = v93 - 1;
            unsigned int v103 = (v93 - 1) & v235;
            uint64_t v104 = (llvm::GlobalValue **)(v88 + 8 * v103);
            unint64_t v105 = *v104;
            if (*v104 == (llvm::GlobalValue *)-1)
            {
              unint64_t v106 = 0;
LABEL_234:
              if (v106) {
                uint64_t v111 = v106;
              }
              else {
                uint64_t v111 = v104;
              }
              if (*v111 != v238)
              {
                if (*v111 == (llvm::GlobalValue *)-2) {
                  --*(_DWORD *)(a2 + 24);
                }
                else {
                  ++*(_DWORD *)(a2 + 20);
                }
                *uint64_t v111 = v238;
              }
            }
            else
            {
              unint64_t v106 = 0;
              int v107 = 1;
              while (v105 != v238)
              {
                if (v106) {
                  BOOL v108 = 0;
                }
                else {
                  BOOL v108 = v105 == (llvm::GlobalValue *)-2;
                }
                if (v108) {
                  unint64_t v106 = v104;
                }
                unsigned int v109 = v103 + v107++;
                unsigned int v103 = v109 & v102;
                uint64_t v104 = (llvm::GlobalValue **)(v88 + 8 * (v109 & v102));
                unint64_t v105 = *v104;
                if (*v104 == (llvm::GlobalValue *)-1) {
                  goto LABEL_234;
                }
              }
            }
            goto LABEL_155;
          }
          uint64_t v79 = sub_1CC90E5A8(&v253, v69);
          uint64_t v80 = (unint64_t *)v246;
          if (v247)
          {
            unsigned int v81 = v79;
            char v82 = 0;
            uint64_t v83 = 8 * v247;
            do
            {
              unint64_t v84 = *v80;
              uint64_t v85 = sub_1CC90E5A8(&v253, *v80);
              unint64_t v86 = *((unsigned int *)v81 + 4);
              if (v86 >= *((unsigned int *)v81 + 5)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*((void *)v81 + 1) + 8 * v86) = v85;
              ++*((_DWORD *)v81 + 4);
              v82 |= v84 != v69;
              ++v80;
              v83 -= 8;
            }
            while (v83);
            uint64_t v80 = (unint64_t *)v246;
            uint64_t v4 = a1;
          }
          else
          {
            char v82 = 0;
          }
          unsigned int v244 = (void **)&unk_1F2627E40;
          uint64_t v5 = v236;
          if (v80 != (unint64_t *)v248) {
            free(v80);
          }
          uint64_t v6 = v238;
          if (v82) {
            goto LABEL_231;
          }
        }
LABEL_158:
        if ((llvm::Argument::onlyReadsMemory((llvm::Argument *)v69) & 1) == 0)
        {
          unsigned int v244 = v248;
          uint64_t v245 = v248;
          LODWORD(v247) = 0;
          uint64_t v246 = (void *)0x100000008;
          v248[0] = (void *)v69;
          int v72 = sub_1CC90E728((llvm::Argument *)v69, (uint64_t *)&v244);
          if (!v72 || !sub_1CC90F280(v69, v72))
          {
LABEL_229:
            if (v245 != v244) {
              free(v245);
            }
            goto LABEL_231;
          }
          uint64_t v73 = *(void *)(a2 + 8);
          uint64_t v74 = *(unsigned int *)(a2 + 20);
          if (v73 == *(void *)a2)
          {
            if (v74)
            {
              uint64_t v75 = 0;
              uint64_t v76 = 8 * v74;
              uint64_t v77 = *(llvm::GlobalValue ***)(a2 + 8);
              while (*v77 != v6)
              {
                if (*v77 == (llvm::GlobalValue *)-2) {
                  uint64_t v75 = v77;
                }
                ++v77;
                v76 -= 8;
                if (!v76)
                {
                  if (!v75) {
                    goto LABEL_169;
                  }
                  *uint64_t v75 = v6;
                  --*(_DWORD *)(a2 + 24);
                  goto LABEL_229;
                }
              }
              goto LABEL_229;
            }
LABEL_169:
            unsigned int v78 = *(_DWORD *)(a2 + 16);
            if (v74 < v78)
            {
              *(_DWORD *)(a2 + 20) = v74 + 1;
              *(void *)(v73 + 8 * v74) = v6;
              goto LABEL_229;
            }
          }
          else
          {
            unsigned int v78 = *(_DWORD *)(a2 + 16);
          }
          if (3 * v78 <= 4 * ((int)v74 - *(_DWORD *)(a2 + 24)))
          {
            if (v78 >= 0x40) {
              v78 *= 2;
            }
            else {
              unsigned int v78 = 128;
            }
          }
          else if (v78 - v74 >= v78 >> 3)
          {
            goto LABEL_191;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v78);
          unsigned int v78 = *(_DWORD *)(a2 + 16);
          uint64_t v73 = *(void *)(a2 + 8);
LABEL_191:
          unsigned int v94 = v78 - 1;
          unsigned int v95 = (v78 - 1) & v235;
          uint64_t v96 = (llvm::GlobalValue **)(v73 + 8 * v95);
          uint64_t v97 = *v96;
          if (*v96 == (llvm::GlobalValue *)-1)
          {
            int v98 = 0;
LABEL_222:
            if (v98) {
              uint64_t v110 = v98;
            }
            else {
              uint64_t v110 = v96;
            }
            if (*v110 != v6)
            {
              if (*v110 == (llvm::GlobalValue *)-2) {
                --*(_DWORD *)(a2 + 24);
              }
              else {
                ++*(_DWORD *)(a2 + 20);
              }
              *uint64_t v110 = v6;
            }
          }
          else
          {
            int v98 = 0;
            int v99 = 1;
            while (v97 != v6)
            {
              if (v98) {
                BOOL v100 = 0;
              }
              else {
                BOOL v100 = v97 == (llvm::GlobalValue *)-2;
              }
              if (v100) {
                int v98 = v96;
              }
              unsigned int v101 = v95 + v99++;
              unsigned int v95 = v101 & v94;
              uint64_t v96 = (llvm::GlobalValue **)(v73 + 8 * (v101 & v94));
              uint64_t v97 = *v96;
              if (*v96 == (llvm::GlobalValue *)-1) {
                goto LABEL_222;
              }
            }
          }
          goto LABEL_229;
        }
LABEL_231:
        v69 += 40;
        if (v69 == v71) {
          goto LABEL_299;
        }
      }
    }
    if ((*((_WORD *)v6 + 9) & 1) == 0)
    {
      uint64_t v68 = *((void *)v6 + 11);
      goto LABEL_254;
    }
    llvm::Function::BuildLazyArguments(v6);
    uint64_t v68 = *((void *)v6 + 11);
    if (*((_WORD *)v6 + 9))
    {
      llvm::Function::BuildLazyArguments(v6);
      uint64_t v112 = *((void *)v6 + 11);
    }
    else
    {
LABEL_254:
      uint64_t v112 = v68;
    }
    uint64_t v113 = v112 + 40 * *((void *)v6 + 12);
    if (v68 != v113)
    {
      while (2)
      {
        if (*(unsigned char *)(*(void *)v68 + 8) != 15
          || (llvm::Argument::hasNoCaptureAttr((llvm::Argument *)v68) & 1) != 0)
        {
          goto LABEL_291;
        }
        uint64_t v114 = *(void *)(v68 + 24);
        *(void *)(v114 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v114 + 112), **(uint64_t ***)v114, *(_DWORD *)(v68 + 32) + 1, 22);
        uint64_t v115 = *(void *)(a2 + 8);
        uint64_t v116 = *(unsigned int *)(a2 + 20);
        if (v115 == *(void *)a2)
        {
          uint64_t v4 = a1;
          if (v116)
          {
            int v117 = 0;
            uint64_t v118 = 8 * v116;
            uint64_t v119 = *(llvm::GlobalValue ***)(a2 + 8);
            while (*v119 != v6)
            {
              if (*v119 == (llvm::GlobalValue *)-2) {
                int v117 = v119;
              }
              ++v119;
              v118 -= 8;
              if (!v118)
              {
                if (!v117) {
                  goto LABEL_267;
                }
                *int v117 = v6;
                --*(_DWORD *)(a2 + 24);
                break;
              }
            }
LABEL_291:
            v68 += 40;
            if (v68 == v113) {
              goto LABEL_299;
            }
            continue;
          }
LABEL_267:
          unsigned int v120 = *(_DWORD *)(a2 + 16);
          if (v116 < v120)
          {
            *(_DWORD *)(a2 + 20) = v116 + 1;
            *(void *)(v115 + 8 * v116) = v6;
            goto LABEL_291;
          }
        }
        else
        {
          unsigned int v120 = *(_DWORD *)(a2 + 16);
          uint64_t v4 = a1;
        }
        break;
      }
      if (3 * v120 <= 4 * ((int)v116 - *(_DWORD *)(a2 + 24)))
      {
        if (v120 >= 0x40) {
          v120 *= 2;
        }
        else {
          unsigned int v120 = 128;
        }
      }
      else if (v120 - v116 >= v120 >> 3)
      {
        goto LABEL_272;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v120);
      unsigned int v120 = *(_DWORD *)(a2 + 16);
      uint64_t v115 = *(void *)(a2 + 8);
LABEL_272:
      unsigned int v121 = v120 - 1;
      unsigned int v122 = (v120 - 1) & ((v6 >> 4) ^ (v6 >> 9));
      uint64_t v123 = (llvm::GlobalValue **)(v115 + 8 * v122);
      uint64_t v124 = *v123;
      if (*v123 == (llvm::GlobalValue *)-1)
      {
        uint64_t v125 = 0;
LABEL_284:
        if (v125) {
          uint64_t v129 = v125;
        }
        else {
          uint64_t v129 = v123;
        }
        if (*v129 != v6)
        {
          if (*v129 == (llvm::GlobalValue *)-2) {
            --*(_DWORD *)(a2 + 24);
          }
          else {
            ++*(_DWORD *)(a2 + 20);
          }
          *uint64_t v129 = v6;
        }
      }
      else
      {
        uint64_t v125 = 0;
        int v126 = 1;
        while (v124 != v6)
        {
          if (v125) {
            BOOL v127 = 0;
          }
          else {
            BOOL v127 = v124 == (llvm::GlobalValue *)-2;
          }
          if (v127) {
            uint64_t v125 = v123;
          }
          unsigned int v128 = v122 + v126++;
          unsigned int v122 = v128 & v121;
          uint64_t v123 = (llvm::GlobalValue **)(v115 + 8 * (v128 & v121));
          uint64_t v124 = *v123;
          if (*v123 == (llvm::GlobalValue *)-1) {
            goto LABEL_284;
          }
        }
      }
      goto LABEL_291;
    }
LABEL_299:
    ++v5;
  }
  while (v5 != v237);
LABEL_307:
  LODWORD(v244) = 0;
  uint64_t v245 = 0;
  uint64_t v246 = 0;
  LODWORD(v247) = 0;
  *(_OWORD *)v248 = 0u;
  long long v249 = 0u;
  long long v250 = 0u;
  long long __p = 0u;
  uint64_t v252 = 0;
  sub_1CC90F5AC((int *)&v244, (uint64_t)&v255);
  sub_1CC90F7C0((uint64_t)&v244);
  int v130 = (uint64_t **)*((void *)&v249 + 1);
  unsigned int v131 = (llvm::Argument ***)v250;
  if (*((void *)&v249 + 1) != (void)v250)
  {
    while (1)
    {
      unint64_t v132 = (char *)v131 - (char *)v130;
      if ((char *)v131 - (char *)v130 != 8) {
        break;
      }
      char v133 = *v130;
      uint64_t v134 = **v130;
      if (v134 && *((_DWORD *)v133 + 4) == 1 && *(uint64_t **)v133[1] == v133)
      {
        uint64_t v135 = *(void *)(v134 + 24);
        *(void *)(v135 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v135 + 112), **(uint64_t ***)v135, *(_DWORD *)(v134 + 32) + 1, 22);
        uint64_t v136 = *(void *)(v134 + 24);
        uint64_t v137 = *(void *)(a2 + 8);
        uint64_t v138 = *(unsigned int *)(a2 + 20);
        if (v137 == *(void *)a2)
        {
          if (v138)
          {
            uint64_t v139 = 0;
            uint64_t v140 = 8 * v138;
            char v141 = *(void **)(a2 + 8);
            while (*v141 != v136)
            {
              if (*v141 == -2) {
                uint64_t v139 = v141;
              }
              ++v141;
              v140 -= 8;
              if (!v140)
              {
                if (!v139) {
                  goto LABEL_320;
                }
                *uint64_t v139 = v136;
                --*(_DWORD *)(a2 + 24);
                goto LABEL_523;
              }
            }
            goto LABEL_523;
          }
LABEL_320:
          unsigned int v142 = *(_DWORD *)(a2 + 16);
          if (v138 < v142)
          {
            *(_DWORD *)(a2 + 20) = v138 + 1;
            *(void *)(v137 + 8 * v138) = v136;
LABEL_523:
            unsigned int v239 = (char *)v243;
            uint64_t v240 = (char *)v243;
            int v242 = 0;
            uint64_t v241 = 0x100000008;
            v243[0] = v134;
            int v233 = sub_1CC90E728((llvm::Argument *)v134, (uint64_t *)&v239);
            if (v233) {
              sub_1CC90F280(v134, v233);
            }
            goto LABEL_525;
          }
        }
        else
        {
          unsigned int v142 = *(_DWORD *)(a2 + 16);
        }
        if (3 * v142 <= 4 * ((int)v138 - *(_DWORD *)(a2 + 24)))
        {
          if (v142 >= 0x40) {
            v142 *= 2;
          }
          else {
            unsigned int v142 = 128;
          }
        }
        else if (v142 - v138 >= v142 >> 3)
        {
          goto LABEL_504;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v142);
        unsigned int v142 = *(_DWORD *)(a2 + 16);
        uint64_t v137 = *(void *)(a2 + 8);
LABEL_504:
        unsigned int v224 = v142 - 1;
        unsigned int v225 = (v142 - 1) & ((v136 >> 4) ^ (v136 >> 9));
        unsigned int v226 = (void *)(v137 + 8 * v225);
        uint64_t v227 = *v226;
        if (*v226 == -1)
        {
          unsigned int v228 = 0;
LABEL_516:
          if (v228) {
            int64x2_t v232 = v228;
          }
          else {
            int64x2_t v232 = v226;
          }
          if (*v232 != v136)
          {
            if (*v232 == -2) {
              --*(_DWORD *)(a2 + 24);
            }
            else {
              ++*(_DWORD *)(a2 + 20);
            }
            *int64x2_t v232 = v136;
          }
        }
        else
        {
          unsigned int v228 = 0;
          int v229 = 1;
          while (v227 != v136)
          {
            if (v228) {
              BOOL v230 = 0;
            }
            else {
              BOOL v230 = v227 == -2;
            }
            if (v230) {
              unsigned int v228 = v226;
            }
            unsigned int v231 = v225 + v229++;
            unsigned int v225 = v231 & v224;
            unsigned int v226 = (void *)(v137 + 8 * (v231 & v224));
            uint64_t v227 = *v226;
            if (*v226 == -1) {
              goto LABEL_516;
            }
          }
        }
        goto LABEL_523;
      }
LABEL_527:
      sub_1CC90F7C0((uint64_t)&v244);
      int v130 = (uint64_t **)*((void *)&v249 + 1);
      unsigned int v131 = (llvm::Argument ***)v250;
      if (*((void *)&v249 + 1) == (void)v250) {
        goto LABEL_535;
      }
    }
    int v143 = (llvm::Argument ***)v130;
    if (v130 != (uint64_t **)v131)
    {
      do
      {
        while (*((_DWORD *)*v143 + 4))
        {
          if (++v143 == v131) {
            goto LABEL_329;
          }
        }
        char hasNoCaptureAttr = llvm::Argument::hasNoCaptureAttr(**v143++);
      }
      while (v143 != v131 && (hasNoCaptureAttr & 1) != 0);
      if ((hasNoCaptureAttr & 1) == 0) {
        goto LABEL_527;
      }
LABEL_329:
      unsigned int v145 = 0;
      unsigned int v239 = (char *)v243;
      uint64_t v240 = (char *)v243;
      unsigned int v146 = 8;
      uint64_t v241 = 8;
      uint64_t v147 = (char *)v243;
      uint64_t v148 = (char *)v243;
      uint64_t v149 = v130;
      int v242 = 0;
      while (2)
      {
        uint64_t v150 = **v149;
        if (v148 == v147)
        {
          if (v145)
          {
            uint64_t v151 = 0;
            uint64_t v152 = 8 * v145;
            unsigned int v153 = (uint64_t *)v147;
            while (*v153 != v150)
            {
              if (*v153 == -2) {
                uint64_t v151 = v153;
              }
              ++v153;
              v152 -= 8;
              if (!v152)
              {
                if (!v151) {
                  goto LABEL_338;
                }
                uint64_t *v151 = v150;
                --v242;
                break;
              }
            }
LABEL_361:
            uint64_t v147 = v239;
            uint64_t v148 = v240;
            unsigned int v146 = v241;
            unsigned int v145 = HIDWORD(v241);
            if (++v149 == (uint64_t **)v131)
            {
              uint64_t v163 = v130;
              while (1)
              {
                uint64_t v164 = *((unsigned int *)*v163 + 4);
                if (v164) {
                  break;
                }
LABEL_404:
                if (++v163 == (uint64_t **)v131) {
                  goto LABEL_407;
                }
              }
              unint64_t v165 = (llvm::Argument ***)(*v163)[1];
              uint64_t v166 = &v165[v164];
              while (1)
              {
                uint64_t v167 = **v165;
                if ((llvm::Argument::hasNoCaptureAttr(v167) & 1) == 0)
                {
                  uint64_t v168 = v239;
                  if (v240 == v239)
                  {
                    int v169 = HIDWORD(v241);
                    BOOL v170 = &v240[8 * HIDWORD(v241)];
                    if (HIDWORD(v241))
                    {
                      uint64_t v171 = 0;
                      while (*(llvm::Argument **)&v240[v171] != v167)
                      {
                        v171 += 8;
                        if (8 * HIDWORD(v241) == v171) {
                          goto LABEL_391;
                        }
                      }
                      BOOL v170 = &v240[v171];
                    }
LABEL_391:
                    uint64_t v168 = v240;
                  }
                  else
                  {
                    int v172 = v241 - 1;
                    unsigned int v173 = (v241 - 1) & ((v167 >> 4) ^ (v167 >> 9));
                    BOOL v170 = &v240[8 * v173];
                    uint64_t v174 = *(llvm::Argument **)v170;
                    if (*(void *)v170 == -1)
                    {
                      uint64_t v175 = 0;
LABEL_399:
                      if (v175) {
                        BOOL v170 = v175;
                      }
                      int v169 = HIDWORD(v241);
                      if (*(llvm::Argument **)v170 != v167) {
                        BOOL v170 = &v240[8 * v241];
                      }
                    }
                    else
                    {
                      uint64_t v175 = 0;
                      int v176 = 1;
                      while (v174 != v167)
                      {
                        if (v175) {
                          BOOL v177 = 0;
                        }
                        else {
                          BOOL v177 = v174 == (llvm::Argument *)-2;
                        }
                        if (v177) {
                          uint64_t v175 = v170;
                        }
                        unsigned int v178 = v173 + v176++;
                        unsigned int v173 = v178 & v172;
                        BOOL v170 = &v240[8 * (v178 & v172)];
                        uint64_t v174 = *(llvm::Argument **)v170;
                        if (*(void *)v170 == -1) {
                          goto LABEL_399;
                        }
                      }
                      int v169 = HIDWORD(v241);
                    }
                  }
                  int v179 = v240 == v168 ? v169 : v241;
                  if (v170 == &v240[8 * v179]) {
                    goto LABEL_525;
                  }
                }
                if (++v165 == v166) {
                  goto LABEL_404;
                }
              }
            }
            continue;
          }
LABEL_338:
          if (v146 > v145)
          {
            HIDWORD(v241) = v145 + 1;
            *(void *)&v147[8 * v145] = v150;
            goto LABEL_361;
          }
        }
        break;
      }
      if (3 * v146 <= 4 * (v145 - v242))
      {
        if (v146 >= 0x40) {
          v146 *= 2;
        }
        else {
          unsigned int v146 = 128;
        }
      }
      else if (v146 - v145 >= v146 >> 3)
      {
        goto LABEL_342;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v239, v146);
      unsigned int v146 = v241;
      uint64_t v148 = v240;
LABEL_342:
      unsigned int v154 = v146 - 1;
      unsigned int v155 = (v146 - 1) & ((v150 >> 4) ^ (v150 >> 9));
      uint64_t v156 = (uint64_t *)&v148[8 * v155];
      uint64_t v157 = *v156;
      if (*v156 == -1)
      {
        uint64_t v158 = 0;
LABEL_354:
        if (v158) {
          uint64_t v162 = v158;
        }
        else {
          uint64_t v162 = v156;
        }
        if (*v162 != v150)
        {
          if (*v162 == -2) {
            --v242;
          }
          else {
            ++HIDWORD(v241);
          }
          *uint64_t v162 = v150;
        }
      }
      else
      {
        uint64_t v158 = 0;
        int v159 = 1;
        while (v157 != v150)
        {
          if (v158) {
            BOOL v160 = 0;
          }
          else {
            BOOL v160 = v157 == -2;
          }
          if (v160) {
            uint64_t v158 = v156;
          }
          unsigned int v161 = v155 + v159++;
          unsigned int v155 = v161 & v154;
          uint64_t v156 = (uint64_t *)&v148[8 * (v161 & v154)];
          uint64_t v157 = *v156;
          if (*v156 == -1) {
            goto LABEL_354;
          }
        }
      }
      goto LABEL_361;
    }
    unsigned int v239 = (char *)v243;
    uint64_t v240 = (char *)v243;
    uint64_t v241 = 8;
    int v242 = 0;
LABEL_407:
    if ((v132 & 0x7FFFFFFF8) == 0)
    {
LABEL_525:
      if (v240 != v239) {
        free(v240);
      }
      goto LABEL_527;
    }
    uint64_t v180 = 0;
    uint64_t v181 = (v132 >> 3);
    while (2)
    {
      uint64_t v182 = *v130[v180];
      uint64_t v183 = *(void *)(v182 + 24);
      *(void *)(v183 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v183 + 112), **(uint64_t ***)v183, *(_DWORD *)(v182 + 32) + 1, 22);
      uint64_t v184 = *(void *)(v182 + 24);
      uint64_t v185 = *(void *)(a2 + 8);
      uint64_t v186 = *(unsigned int *)(a2 + 20);
      if (v185 == *(void *)a2)
      {
        if (v186)
        {
          uint64_t v187 = 0;
          uint64_t v188 = 8 * v186;
          uint64_t v189 = *(void **)(a2 + 8);
          while (*v189 != v184)
          {
            if (*v189 == -2) {
              uint64_t v187 = v189;
            }
            ++v189;
            v188 -= 8;
            if (!v188)
            {
              if (!v187) {
                goto LABEL_417;
              }
              *uint64_t v187 = v184;
              --*(_DWORD *)(a2 + 24);
              break;
            }
          }
LABEL_441:
          if (++v180 == v181)
          {
            uint64_t v200 = v181 - 1;
            uint64_t v201 = 44;
            v202 = (llvm::Argument ***)v130;
            do
            {
              uint64_t v203 = sub_1CC90E728(**v202, (uint64_t *)&v239);
              if (v201 == v203)
              {
                uint64_t v204 = v201;
              }
              else
              {
                uint64_t v204 = v203;
                if (v201 != 44)
                {
                  if (v203 == 44) {
                    uint64_t v204 = v201;
                  }
                  else {
                    uint64_t v204 = 0;
                  }
                }
              }
              if (v200-- == 0) {
                break;
              }
              ++v202;
              uint64_t v201 = v204;
            }
            while (v204);
            if (!v204) {
              goto LABEL_525;
            }
            uint64_t v206 = 0;
            while (2)
            {
              uint64_t v207 = *v130[v206];
              if (!sub_1CC90F280(v207, v204))
              {
LABEL_493:
                if (++v206 == v181) {
                  goto LABEL_525;
                }
                continue;
              }
              break;
            }
            uint64_t v208 = *(void *)(v207 + 24);
            uint64_t v209 = *(void *)(a2 + 8);
            uint64_t v210 = *(unsigned int *)(a2 + 20);
            if (v209 == *(void *)a2)
            {
              if (v210)
              {
                unint64_t v211 = 0;
                uint64_t v212 = 8 * v210;
                unsigned int v213 = *(void **)(a2 + 8);
                while (*v213 != v208)
                {
                  if (*v213 == -2) {
                    unint64_t v211 = v213;
                  }
                  ++v213;
                  v212 -= 8;
                  if (!v212)
                  {
                    if (!v211) {
                      goto LABEL_469;
                    }
                    *unint64_t v211 = v208;
                    --*(_DWORD *)(a2 + 24);
                    goto LABEL_493;
                  }
                }
                goto LABEL_493;
              }
LABEL_469:
              unsigned int v214 = *(_DWORD *)(a2 + 16);
              if (v210 < v214)
              {
                *(_DWORD *)(a2 + 20) = v210 + 1;
                *(void *)(v209 + 8 * v210) = v208;
                goto LABEL_493;
              }
            }
            else
            {
              unsigned int v214 = *(_DWORD *)(a2 + 16);
            }
            if (3 * v214 <= 4 * ((int)v210 - *(_DWORD *)(a2 + 24)))
            {
              if (v214 >= 0x40) {
                v214 *= 2;
              }
              else {
                unsigned int v214 = 128;
              }
            }
            else if (v214 - v210 >= v214 >> 3)
            {
              goto LABEL_474;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v214);
            unsigned int v214 = *(_DWORD *)(a2 + 16);
            uint64_t v209 = *(void *)(a2 + 8);
LABEL_474:
            unsigned int v215 = v214 - 1;
            unsigned int v216 = (v214 - 1) & ((v208 >> 4) ^ (v208 >> 9));
            unsigned int v217 = (void *)(v209 + 8 * v216);
            uint64_t v218 = *v217;
            if (*v217 == -1)
            {
              unsigned int v219 = 0;
LABEL_486:
              if (v219) {
                unsigned int v223 = v219;
              }
              else {
                unsigned int v223 = v217;
              }
              if (*v223 != v208)
              {
                if (*v223 == -2) {
                  --*(_DWORD *)(a2 + 24);
                }
                else {
                  ++*(_DWORD *)(a2 + 20);
                }
                *unsigned int v223 = v208;
              }
            }
            else
            {
              unsigned int v219 = 0;
              int v220 = 1;
              while (v218 != v208)
              {
                if (v219) {
                  BOOL v221 = 0;
                }
                else {
                  BOOL v221 = v218 == -2;
                }
                if (v221) {
                  unsigned int v219 = v217;
                }
                unsigned int v222 = v216 + v220++;
                unsigned int v216 = v222 & v215;
                unsigned int v217 = (void *)(v209 + 8 * (v222 & v215));
                uint64_t v218 = *v217;
                if (*v217 == -1) {
                  goto LABEL_486;
                }
              }
            }
            goto LABEL_493;
          }
          continue;
        }
LABEL_417:
        unsigned int v190 = *(_DWORD *)(a2 + 16);
        if (v186 < v190)
        {
          *(_DWORD *)(a2 + 20) = v186 + 1;
          *(void *)(v185 + 8 * v186) = v184;
          goto LABEL_441;
        }
      }
      else
      {
        unsigned int v190 = *(_DWORD *)(a2 + 16);
      }
      break;
    }
    if (3 * v190 <= 4 * ((int)v186 - *(_DWORD *)(a2 + 24)))
    {
      if (v190 >= 0x40) {
        v190 *= 2;
      }
      else {
        unsigned int v190 = 128;
      }
    }
    else if (v190 - v186 >= v190 >> 3)
    {
      goto LABEL_422;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v190);
    unsigned int v190 = *(_DWORD *)(a2 + 16);
    uint64_t v185 = *(void *)(a2 + 8);
LABEL_422:
    unsigned int v191 = v190 - 1;
    unsigned int v192 = (v190 - 1) & ((v184 >> 4) ^ (v184 >> 9));
    uint64_t v193 = (void *)(v185 + 8 * v192);
    uint64_t v194 = *v193;
    if (*v193 == -1)
    {
      uint64_t v195 = 0;
LABEL_434:
      if (v195) {
        v199 = v195;
      }
      else {
        v199 = v193;
      }
      if (*v199 != v184)
      {
        if (*v199 == -2) {
          --*(_DWORD *)(a2 + 24);
        }
        else {
          ++*(_DWORD *)(a2 + 20);
        }
        void *v199 = v184;
      }
    }
    else
    {
      uint64_t v195 = 0;
      int v196 = 1;
      while (v194 != v184)
      {
        if (v195) {
          BOOL v197 = 0;
        }
        else {
          BOOL v197 = v194 == -2;
        }
        if (v197) {
          uint64_t v195 = v193;
        }
        unsigned int v198 = v192 + v196++;
        unsigned int v192 = v198 & v191;
        uint64_t v193 = (void *)(v185 + 8 * (v198 & v191));
        uint64_t v194 = *v193;
        if (*v193 == -1) {
          goto LABEL_434;
        }
      }
    }
    goto LABEL_441;
  }
LABEL_535:
  if ((void)__p) {
    operator delete((void *)__p);
  }
  if (v130) {
    operator delete(v130);
  }
  if (v248[0]) {
    operator delete(v248[0]);
  }
  MEMORY[0x1D25D9CD0](v245, 8);
  if (v256 != v258) {
    free(v256);
  }
  sub_1CC90FC24(v254[0]);
}

void sub_1CC90B06C(_DWORD *a1, uint64_t a2)
{
  v38[52] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = v38;
  uint64_t v37 = 0x400000000;
  v26[0] = &unk_1F2627E80;
  unsigned int v27 = v26;
  uint64_t v18 = 1;
  int64x2_t v19 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v20 = v19;
  int64x2_t v21 = v19;
  int64x2_t v22 = v19;
  int64x2_t v15 = v19;
  sub_1CC910CAC(&v18, a1);
  uint64_t v23 = v25;
  uint64_t v24 = 0x800000000;
  if (a1[20]) {
    sub_1CD4C0D94((uint64_t)&v23, (uint64_t)(a1 + 18));
  }
  uint64_t v4 = (int64x2_t *)operator new(0xA0uLL);
  v4->i64[0] = (uint64_t)&unk_1F2627EC8;
  v4->i64[1] = 1;
  v4[1] = v15;
  void v4[2] = v15;
  v4[3] = v15;
  v4[4] = v15;
  sub_1CC910CAC(&v4->i32[2], &v18);
  v4[5].i64[0] = (uint64_t)v4[6].i64;
  v4[5].i64[1] = 0x800000000;
  if (v24) {
    sub_1CD4C0D94((uint64_t)v4[5].i64, (uint64_t)&v23);
  }
  v16[0] = &unk_1F2627F10;
  uint64_t v17 = v16;
  if (v27)
  {
    if (v27 == v26)
    {
      unint64_t v29 = v28;
      (*(void (**)(void *, void *))(v26[0] + 24))(v26, v28);
    }
    else
    {
      unint64_t v29 = (void *)(*(uint64_t (**)(void))(*v27 + 16))();
    }
  }
  else
  {
    unint64_t v29 = 0;
  }
  unsigned int v31 = (void *)(*(uint64_t (**)(int64x2_t *))(v4->i64[0] + 16))(v4);
  if (v17)
  {
    if (v17 == v16)
    {
      uint64_t v33 = v32;
      (*(void (**)(void *, void *))(v16[0] + 24))(v16, v32);
    }
    else
    {
      uint64_t v33 = (void *)(*(uint64_t (**)(void))(*v17 + 16))();
    }
  }
  else
  {
    uint64_t v33 = 0;
  }
  int v34 = 6;
  char v35 = 0;
  sub_1CC9107B4((uint64_t)&v36, (unint64_t)v28);
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  if (v31 == v30)
  {
    (*(void (**)(void *))(v30[0] + 32))(v30);
  }
  else if (v31)
  {
    (*(void (**)(void))(*v31 + 40))();
  }
  if (v29 == v28)
  {
    (*(void (**)(void *))(v28[0] + 32))(v28);
  }
  else if (v29)
  {
    (*(void (**)(void))(*v29 + 40))();
  }
  if (v17 == v16)
  {
    (*(void (**)(void *))(v16[0] + 32))(v16);
  }
  else if (v17)
  {
    (*(void (**)(void))(*v17 + 40))();
  }
  (*(void (**)(int64x2_t *))(v4->i64[0] + 40))(v4);
  if (v23 != v25) {
    free(v23);
  }
  if ((v18 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v19.i64[0], 8);
  }
  if (v27 == v26)
  {
    (*(void (**)(void *))(v26[0] + 32))(v26);
  }
  else if (v27)
  {
    (*(void (**)(void))(*v27 + 40))();
  }
  sub_1CC90FC84((uint64_t)&v36, (uint64_t)a1, a2);
  uint64_t v5 = (char *)v36;
  if (v37)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 104 * v37;
    uint64_t v8 = (char *)v36;
    do
    {
      uint64_t v9 = &v5[v7];
      uint64_t v10 = (uint64_t)&v5[v7 - 40];
      uint64_t v11 = *(void *)&v5[v7 - 16];
      if (v10 == v11)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
      }
      else if (v11)
      {
        (*(void (**)(void))(*(void *)v11 + 40))(*(void *)&v5[v7 - 16]);
      }
      uint64_t v12 = (uint64_t)&v5[v7 - 72];
      uint64_t v13 = *(void *)&v5[v7 - 48];
      if (v12 == v13)
      {
        (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
      }
      else if (v13)
      {
        (*(void (**)(void))(*(void *)v13 + 40))(*(void *)&v5[v7 - 48]);
      }
      int v14 = *(char **)&v5[v7 - 80];
      if (v9 - 104 == v14)
      {
        (*(void (**)(char *))(*((void *)v9 - 13) + 32))(v9 - 104);
      }
      else if (v14)
      {
        (*(void (**)(void))(*(void *)v14 + 40))(*(void *)&v5[v7 - 80]);
      }
      v6 += 104;
      v5 -= 104;
      v8 -= 104;
    }
    while (v7 != v6);
    uint64_t v5 = (char *)v36;
  }
  if (v5 != (char *)v38) {
    free(v5);
  }
}

void sub_1CC90B728(llvm::GlobalValue **a1, int a2, uint64_t a3)
{
  v66[16] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v3 = a1;
    uint64_t v4 = &a1[a2];
    while (1)
    {
      uint64_t v5 = *v3;
      if (*v3)
      {
        if (*((unsigned char *)v5 + 16))
        {
          if (*((unsigned char *)v5 + 16) == 3 && (*((_DWORD *)v5 + 5) & 0x7FFFFFF) == 0) {
            goto LABEL_139;
          }
        }
        else if (*((llvm::GlobalValue **)v5 + 9) == (llvm::GlobalValue *)((char *)v5 + 72) {
               && (*((unsigned char *)v5 + 34) & 0x80) == 0)
        }
        {
          goto LABEL_139;
        }
        if (((1 << (*((_DWORD *)v5 + 8) & 0xF)) & 0x7D5) != 0 && (llvm::GlobalValue::isInterposable(*v3) & 1) == 0)
        {
          uint64_t v6 = *((void *)v5 + 14);
          if (!v6 || (*(unsigned char *)(v6 + 14) & 2) == 0 && (*(unsigned char *)(v6 + 16) & 1) == 0) {
            break;
          }
        }
      }
LABEL_139:
      if (++v3 == v4) {
        return;
      }
    }
    int v63 = v66;
    unsigned int v65 = 16;
    unsigned int v58 = v62;
    unsigned int v59 = v62;
    int v61 = 0;
    uint64_t v7 = *((void *)v5 + 10);
    if (v7) {
      uint64_t v8 = v7 - 24;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v60 = 0x100000010;
    v62[0] = v8;
    v66[0] = v8;
    unsigned int v9 = 1;
    while (1)
    {
      uint64_t v10 = *((void *)v63 + v9 - 1);
      unsigned int v64 = v9 - 1;
      uint64_t v12 = (void *)(v10 + 40);
      uint64_t v11 = *(void **)(v10 + 40);
      uint64_t v13 = v11 - 3;
      if (!v11) {
        uint64_t v13 = 0;
      }
      if (*((unsigned __int8 *)v13 + 16) - 29 >= 0xB) {
        uint64_t v13 = 0;
      }
      if (*((unsigned char *)v13 + 16) == 29)
      {
        for (int i = *(void **)(v10 + 48); i != v12; int i = (void *)i[1])
        {
          if (i) {
            int64x2_t v15 = i - 3;
          }
          else {
            int64x2_t v15 = 0;
          }
          unsigned int v16 = *((unsigned __int8 *)v15 + 16) - 33;
          BOOL v17 = v16 > 0x33;
          uint64_t v18 = (1 << v16) & 0x8000000000041;
          if (!v17
            && v18 != 0
            && ((uint64_t v20 = i[5]) != 0 && (*(unsigned char *)(v20 + 16) & 1) != 0
             || (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)(i - 3), 32) & 1) != 0))
          {
            uint64_t v11 = (void *)*v12;
            goto LABEL_38;
          }
        }
        char v55 = 1;
LABEL_102:
        if (v59 != v58) {
          free(v59);
        }
        if (v63 != v66) {
          free(v63);
        }
        if (v55) {
          goto LABEL_139;
        }
        *((void *)v5 + 14) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v5 + 14, **(uint64_t ***)v5, -1, 32);
        uint64_t v41 = *(void *)(a3 + 8);
        uint64_t v42 = *(unsigned int *)(a3 + 20);
        if (v41 != *(void *)a3)
        {
          unsigned int v46 = *(_DWORD *)(a3 + 16);
LABEL_118:
          if (3 * v46 <= 4 * ((int)v42 - *(_DWORD *)(a3 + 24)))
          {
            if (v46 >= 0x40) {
              v46 *= 2;
            }
            else {
              unsigned int v46 = 128;
            }
          }
          else if (v46 - v42 >= v46 >> 3)
          {
            goto LABEL_120;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v46);
          unsigned int v46 = *(_DWORD *)(a3 + 16);
          uint64_t v41 = *(void *)(a3 + 8);
LABEL_120:
          unsigned int v47 = v46 - 1;
          unsigned int v48 = (v46 - 1) & ((v5 >> 4) ^ (v5 >> 9));
          uint64_t v49 = (llvm::GlobalValue **)(v41 + 8 * v48);
          int v50 = *v49;
          if (*v49 == (llvm::GlobalValue *)-1)
          {
            unsigned int v51 = 0;
LABEL_132:
            if (v51) {
              int v56 = v51;
            }
            else {
              int v56 = v49;
            }
            if (*v56 != v5)
            {
              if (*v56 == (llvm::GlobalValue *)-2) {
                --*(_DWORD *)(a3 + 24);
              }
              else {
                ++*(_DWORD *)(a3 + 20);
              }
              *int v56 = v5;
            }
          }
          else
          {
            unsigned int v51 = 0;
            int v52 = 1;
            while (v50 != v5)
            {
              if (v51) {
                BOOL v53 = 0;
              }
              else {
                BOOL v53 = v50 == (llvm::GlobalValue *)-2;
              }
              if (v53) {
                unsigned int v51 = v49;
              }
              unsigned int v54 = v48 + v52++;
              unsigned int v48 = v54 & v47;
              uint64_t v49 = (llvm::GlobalValue **)(v41 + 8 * (v54 & v47));
              int v50 = *v49;
              if (*v49 == (llvm::GlobalValue *)-1) {
                goto LABEL_132;
              }
            }
          }
          goto LABEL_139;
        }
        if (v42)
        {
          int v43 = 0;
          uint64_t v44 = 8 * v42;
          unint64_t v45 = *(llvm::GlobalValue ***)(a3 + 8);
          while (*v45 != v5)
          {
            if (*v45 == (llvm::GlobalValue *)-2) {
              int v43 = v45;
            }
            ++v45;
            v44 -= 8;
            if (!v44)
            {
              if (!v43) {
                goto LABEL_115;
              }
              *int v43 = v5;
              --*(_DWORD *)(a3 + 24);
              goto LABEL_139;
            }
          }
          goto LABEL_139;
        }
LABEL_115:
        unsigned int v46 = *(_DWORD *)(a3 + 16);
        if (v42 >= v46) {
          goto LABEL_118;
        }
        *(_DWORD *)(a3 + 20) = v42 + 1;
        *(void *)(v41 + 8 * v42) = v5;
        goto LABEL_139;
      }
LABEL_38:
      if (v11 != v12) {
        break;
      }
LABEL_92:
      unsigned int v9 = v64;
      if (!v64)
      {
        char v55 = 0;
        goto LABEL_102;
      }
    }
    if (v11) {
      int64x2_t v21 = v11 - 3;
    }
    else {
      int64x2_t v21 = 0;
    }
    if (*((unsigned char *)v21 + 16) != 30)
    {
      int v40 = 2;
      switch(*((unsigned char *)v21 + 16))
      {
        case 0x1E:
          __break(1u);
          JUMPOUT(0x1CC90BD68);
        case 0x1F:
          int v40 = (*((_DWORD *)v21 + 5) >> 1) & 0x3FFFFFF;
          goto LABEL_95;
        case 0x20:
        case 0x26:
          int v40 = (*((_DWORD *)v21 + 5) & 0x7FFFFFF) - 1;
          goto LABEL_95;
        case 0x21:
          goto LABEL_47;
        case 0x24:
          int v40 = *((_WORD *)v21 + 9) & 1;
          goto LABEL_95;
        case 0x25:
          int v40 = 1;
          goto LABEL_47;
        case 0x27:
          int v40 = *((_DWORD *)v21 + 20) + 1;
LABEL_95:
          if (!v40) {
            goto LABEL_92;
          }
          goto LABEL_47;
        default:
          goto LABEL_92;
      }
    }
    if ((*((_DWORD *)v21 + 5) & 0x7FFFFFF) == 3) {
      int v40 = 2;
    }
    else {
      int v40 = 1;
    }
LABEL_47:
    unsigned int v22 = 0;
    while (1)
    {
      uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v21, v22);
      uint64_t v24 = Successor;
      uint64_t v25 = (char *)v59;
      uint64_t v26 = HIDWORD(v60);
      if (v59 == v58)
      {
        if (HIDWORD(v60))
        {
          unsigned int v27 = 0;
          uint64_t v28 = 8 * HIDWORD(v60);
          unint64_t v29 = v59;
          while (*v29 != Successor)
          {
            if (*v29 == -2) {
              unsigned int v27 = v29;
            }
            ++v29;
            v28 -= 8;
            if (!v28)
            {
              if (!v27) {
                goto LABEL_56;
              }
              *unsigned int v27 = Successor;
              --v61;
              goto LABEL_80;
            }
          }
          goto LABEL_82;
        }
LABEL_56:
        unsigned int v30 = v60;
        if (HIDWORD(v60) < v60)
        {
          ++HIDWORD(v60);
          v59[v26] = Successor;
          goto LABEL_80;
        }
      }
      else
      {
        unsigned int v30 = v60;
      }
      if (3 * v30 <= 4 * (HIDWORD(v60) - v61)) {
        break;
      }
      if (v30 - HIDWORD(v60) < v30 >> 3) {
        goto LABEL_89;
      }
LABEL_61:
      unsigned int v31 = v30 - 1;
      unsigned int v32 = (v30 - 1) & ((v24 >> 4) ^ (v24 >> 9));
      uint64_t v33 = &v25[8 * v32];
      uint64_t v34 = *(void *)v33;
      if (*(void *)v33 != -1)
      {
        char v35 = 0;
        int v36 = 1;
        while (v34 != v24)
        {
          if (v35) {
            BOOL v37 = 0;
          }
          else {
            BOOL v37 = v34 == -2;
          }
          if (v37) {
            char v35 = (uint64_t *)v33;
          }
          unsigned int v38 = v32 + v36++;
          unsigned int v32 = v38 & v31;
          uint64_t v33 = &v25[8 * (v38 & v31)];
          uint64_t v34 = *(void *)v33;
          if (*(void *)v33 == -1) {
            goto LABEL_73;
          }
        }
        goto LABEL_82;
      }
      char v35 = 0;
LABEL_73:
      if (v35) {
        int v39 = v35;
      }
      else {
        int v39 = (uint64_t *)v33;
      }
      if (*v39 == v24) {
        goto LABEL_82;
      }
      if (*v39 == -2) {
        --v61;
      }
      else {
        ++HIDWORD(v60);
      }
      *int v39 = v24;
LABEL_80:
      if (v64 >= (unint64_t)v65) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v63 + v64++) = v24;
LABEL_82:
      if (v40 == ++v22) {
        goto LABEL_92;
      }
    }
    if (v30 >= 0x40) {
      v30 *= 2;
    }
    else {
      unsigned int v30 = 128;
    }
LABEL_89:
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v58, v30);
    unsigned int v30 = v60;
    uint64_t v25 = (char *)v59;
    goto LABEL_61;
  }
}

void sub_1CC90BD94(llvm::GlobalValue **a1, int a2, uint64_t a3)
{
  v37[6] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v4 = a1;
    uint64_t v5 = v37;
    uint64_t v6 = &a1[a2];
    do
    {
      uint64_t v7 = *v4;
      if (!*v4) {
        goto LABEL_81;
      }
      unsigned int v9 = (void *)((char *)v7 + 112);
      uint64_t v8 = *((void *)v7 + 14);
      if (v8)
      {
        if ((*(unsigned char *)(v8 + 20) & 2) != 0) {
          goto LABEL_81;
        }
      }
      if (*((unsigned char *)v7 + 16))
      {
        if (*((unsigned char *)v7 + 16) == 3 && (*((_DWORD *)v7 + 5) & 0x7FFFFFF) == 0) {
          goto LABEL_81;
        }
      }
      else if (*((llvm::GlobalValue **)v7 + 9) == (llvm::GlobalValue *)((char *)v7 + 72) {
             && (*((unsigned char *)v7 + 34) & 0x80) == 0)
      }
      {
        goto LABEL_81;
      }
      if (((1 << (*((_DWORD *)v7 + 8) & 0xF)) & 0x7D5) != 0 && (llvm::GlobalValue::isInterposable(*v4) & 1) == 0)
      {
        uint64_t v10 = (unsigned char *)*v9;
        if (!*v9 || (v10[14] & 1) == 0 && (v10[20] & 2) == 0 || (v10[17] & 0x30) == 0)
        {
          if (*((unsigned char *)v7 + 16))
          {
            if (*((unsigned char *)v7 + 16) == 3 && (*((_DWORD *)v7 + 5) & 0x7FFFFFF) == 0) {
              goto LABEL_81;
            }
          }
          else if (*((llvm::GlobalValue **)v7 + 9) == (llvm::GlobalValue *)((char *)v7 + 72) {
                 && (*((unsigned char *)v7 + 34) & 0x80) == 0)
          }
          {
            goto LABEL_81;
          }
          char v35 = v5;
          uint64_t v36 = 0x300000000;
          llvm::FindFunctionBackedges((uint64_t)v7, (uint64_t)&v35);
          if (v36)
          {
            uint64_t v11 = v5;
            int v12 = 0;
          }
          else
          {
            uint64_t v11 = v5;
            uint64_t v13 = (char *)v7 + 72;
            for (uint64_t i = *((void *)v7 + 10); ; uint64_t i = *(void *)(i + 8))
            {
              if ((char *)i == v13)
              {
LABEL_45:
                int v12 = 1;
                goto LABEL_46;
              }
              uint64_t v15 = i - 24;
              if (!i) {
                uint64_t v15 = 0;
              }
              uint64_t v16 = *(void *)(v15 + 48);
              if (v16 != v15 + 40) {
                break;
              }
            }
            do
            {
              BOOL v17 = v16 ? (llvm::Instruction *)(v16 - 24) : 0;
              int v12 = llvm::Instruction::willReturn(v17);
              if (!v12) {
                break;
              }
              uint64_t v16 = *(void *)(v16 + 8);
              uint64_t v18 = i - 24;
              if (!i) {
                uint64_t v18 = 0;
              }
              if (v16 == v18 + 40)
              {
                do
                {
                  uint64_t i = *(void *)(i + 8);
                  if ((char *)i == v13) {
                    goto LABEL_45;
                  }
                  uint64_t v19 = i - 24;
                  if (!i) {
                    uint64_t v19 = 0;
                  }
                  uint64_t v16 = *(void *)(v19 + 48);
                }
                while (v16 == v19 + 40);
              }
            }
            while ((char *)i != v13);
          }
LABEL_46:
          uint64_t v5 = v11;
          if (v35 != v11) {
            free(v35);
          }
          if (!v12) {
            goto LABEL_81;
          }
        }
        *((void *)v7 + 14) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v7 + 14, **(uint64_t ***)v7, -1, 65);
        uint64_t v20 = *(void *)(a3 + 8);
        uint64_t v21 = *(unsigned int *)(a3 + 20);
        if (v20 != *(void *)a3)
        {
          unsigned int v25 = *(_DWORD *)(a3 + 16);
LABEL_60:
          if (3 * v25 <= 4 * ((int)v21 - *(_DWORD *)(a3 + 24)))
          {
            if (v25 >= 0x40) {
              v25 *= 2;
            }
            else {
              unsigned int v25 = 128;
            }
          }
          else if (v25 - v21 >= v25 >> 3)
          {
            goto LABEL_62;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v25);
          unsigned int v25 = *(_DWORD *)(a3 + 16);
          uint64_t v20 = *(void *)(a3 + 8);
LABEL_62:
          unsigned int v26 = v25 - 1;
          unsigned int v27 = (v25 - 1) & ((v7 >> 4) ^ (v7 >> 9));
          uint64_t v28 = (llvm::GlobalValue **)(v20 + 8 * v27);
          unint64_t v29 = *v28;
          if (*v28 == (llvm::GlobalValue *)-1)
          {
            unsigned int v30 = 0;
LABEL_74:
            if (v30) {
              uint64_t v34 = v30;
            }
            else {
              uint64_t v34 = v28;
            }
            if (*v34 != v7)
            {
              if (*v34 == (llvm::GlobalValue *)-2) {
                --*(_DWORD *)(a3 + 24);
              }
              else {
                ++*(_DWORD *)(a3 + 20);
              }
              *uint64_t v34 = v7;
            }
          }
          else
          {
            unsigned int v30 = 0;
            int v31 = 1;
            while (v29 != v7)
            {
              if (v30) {
                BOOL v32 = 0;
              }
              else {
                BOOL v32 = v29 == (llvm::GlobalValue *)-2;
              }
              if (v32) {
                unsigned int v30 = v28;
              }
              unsigned int v33 = v27 + v31++;
              unsigned int v27 = v33 & v26;
              uint64_t v28 = (llvm::GlobalValue **)(v20 + 8 * (v33 & v26));
              unint64_t v29 = *v28;
              if (*v28 == (llvm::GlobalValue *)-1) {
                goto LABEL_74;
              }
            }
          }
          goto LABEL_81;
        }
        if (v21)
        {
          unsigned int v22 = 0;
          uint64_t v23 = 8 * v21;
          uint64_t v24 = *(llvm::GlobalValue ***)(a3 + 8);
          while (*v24 != v7)
          {
            if (*v24 == (llvm::GlobalValue *)-2) {
              unsigned int v22 = v24;
            }
            ++v24;
            v23 -= 8;
            if (!v23)
            {
              if (!v22) {
                goto LABEL_57;
              }
              *unsigned int v22 = v7;
              --*(_DWORD *)(a3 + 24);
              goto LABEL_81;
            }
          }
          goto LABEL_81;
        }
LABEL_57:
        unsigned int v25 = *(_DWORD *)(a3 + 16);
        if (v21 >= v25) {
          goto LABEL_60;
        }
        *(_DWORD *)(a3 + 20) = v21 + 1;
        *(void *)(v20 + 8 * v21) = v7;
      }
LABEL_81:
      ++v4;
    }
    while (v4 != v6);
  }
}

void sub_1CC90C178(uint64_t a1, uint64_t a2)
{
  v71[8] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(a1 + 80);
  if (v2)
  {
    uint64_t v5 = *(llvm::GlobalValue ***)(a1 + 72);
    uint64_t v6 = &v5[v2];
    int64x2_t v61 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      uint64_t v7 = *v5;
      uint64_t v8 = *((void *)*v5 + 14);
      if (!v8 || *(_DWORD *)(v8 + 8) < 2u || (uint64_t v39 = *(void *)(v8 + 48)) == 0 || (*(unsigned char *)(v39 + 14) & 8) == 0)
      {
        if (*((unsigned char *)v7 + 16))
        {
          if (*((unsigned char *)v7 + 16) == 3 && (*((_DWORD *)v7 + 5) & 0x7FFFFFF) == 0) {
            return;
          }
        }
        else if (*((llvm::GlobalValue **)v7 + 9) == (llvm::GlobalValue *)((char *)v7 + 72) {
               && (*((unsigned char *)v7 + 34) & 0x80) == 0)
        }
        {
          return;
        }
        if ((1 << (*((_DWORD *)v7 + 8) & 0xF)) & 0x7D5) == 0 || (llvm::GlobalValue::isInterposable(*v5)) {
          return;
        }
        if (*(unsigned char *)(**(void **)(*((void *)v7 + 3) + 16) + 8) == 15)
        {
          uint64_t v64 = 1;
          int64x2_t v65 = v61;
          int64x2_t v66 = v61;
          int64x2_t v67 = v61;
          int64x2_t v68 = v61;
          unint64_t v69 = v71;
          uint64_t v70 = 0x800000000;
          unsigned int v9 = (char *)v7 + 72;
          uint64_t v10 = *((void *)v7 + 10);
          if ((char *)v10 != v9)
          {
            do
            {
              uint64_t v11 = v10 - 24;
              if (!v10) {
                uint64_t v11 = 0;
              }
              uint64_t v12 = *(void *)(v11 + 40);
              if (v12 != v11 + 40)
              {
                uint64_t v13 = v12 - 24;
                if (!v12) {
                  uint64_t v13 = 0;
                }
                unsigned int v14 = *(unsigned __int8 *)(v13 + 16) - 40;
                if (v14 < 0xFFFFFFF5) {
                  uint64_t v13 = 0;
                }
                if (v12)
                {
                  if (*(unsigned char *)(v13 + 16) == 29 && v14 >= 0xFFFFFFF5)
                  {
                    uint64_t v16 = *(_DWORD *)(v13 + 20) & 0x7FFFFFF;
                    if (v16) {
                      uint64_t v17 = *(void *)(v13 - 32 * v16);
                    }
                    else {
                      uint64_t v17 = 0;
                    }
                    uint64_t v63 = v17;
                    sub_1CC911830((uint64_t)&v64, &v63);
                  }
                }
              }
              uint64_t v10 = *(void *)(v10 + 8);
            }
            while ((char *)v10 != v9);
            if (v70)
            {
              for (unsigned int i = 0; v70 != i; ++i)
              {
                uint64_t v19 = *((void *)v69 + i);
                unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
                if (v19) {
                  BOOL v21 = v20 > 0x14;
                }
                else {
                  BOOL v21 = 1;
                }
                if (v21)
                {
                  if (v20 == 21) {
                    goto LABEL_92;
                  }
                  if (v19) {
                    BOOL v22 = v20 >= 0x1C;
                  }
                  else {
                    BOOL v22 = 0;
                  }
                  if (v22)
                  {
                    int v24 = 0;
                    if (*(unsigned __int8 *)(v19 + 16) > 0x4Cu)
                    {
                      switch(*(unsigned char *)(v19 + 16))
                      {
                        case 'M':
                        case 'N':
                          goto LABEL_59;
                        case 'S':
                          int v25 = *(_DWORD *)(v19 + 20);
                          if ((v25 & 0x40000000) != 0)
                          {
                            unsigned int v27 = *(uint64_t **)(v19 - 8);
                            uint64_t v26 = v25 & 0x7FFFFFF;
                            if (!v26) {
                              continue;
                            }
                          }
                          else
                          {
                            uint64_t v26 = v25 & 0x7FFFFFF;
                            unsigned int v27 = (uint64_t *)(v19 - 32 * v26);
                            if (!v26) {
                              continue;
                            }
                          }
                          uint64_t v33 = 32 * v26;
                          do
                          {
                            uint64_t v63 = 0;
                            uint64_t v34 = *v27;
                            v27 += 4;
                            uint64_t v63 = v34;
                            sub_1CC911830((uint64_t)&v64, &v63);
                            v33 -= 32;
                          }
                          while (v33);
                          break;
                        case 'T':
                          goto LABEL_68;
                        case 'U':
                          uint64_t v63 = *(void *)(v19 - 64);
                          sub_1CC911830((uint64_t)&v64, &v63);
                          uint64_t v32 = *(void *)(v19 - 32);
                          goto LABEL_77;
                        default:
                          goto LABEL_94;
                      }
                      continue;
                    }
                    switch(v20)
                    {
                      case '!':
LABEL_68:
                        if ((sub_1CBF5BCC4(*((void *)v69 + i), 19) & 1) == 0)
                        {
                          uint64_t v31 = *(void *)(v19 - 32);
                          if (!v31) {
                            goto LABEL_92;
                          }
                          if (*(unsigned char *)(v31 + 16)) {
                            goto LABEL_92;
                          }
                          if (*(void *)(v31 + 24) != *(void *)(v19 + 72)) {
                            goto LABEL_92;
                          }
                          uint64_t v62 = 0;
                          uint64_t v63 = v31;
                          if (!sub_1CC8B6C50(a1, &v63, &v62)) {
                            goto LABEL_92;
                          }
                        }
                        break;
                      case ';':
                        break;
                      case '>':
LABEL_59:
                        int v28 = *(_DWORD *)(v19 + 20);
                        if ((v28 & 0x40000000) != 0) {
                          unint64_t v29 = *(uint64_t **)(v19 - 8);
                        }
                        else {
                          unint64_t v29 = (uint64_t *)(v19 - 32 * (v28 & 0x7FFFFFF));
                        }
                        uint64_t v32 = *v29;
LABEL_77:
                        uint64_t v63 = v32;
                        sub_1CC911830((uint64_t)&v64, &v63);
                        continue;
                      default:
                        goto LABEL_94;
                    }
                  }
                  if (llvm::PointerMayBeCaptured((llvm *)v19, 0, 0, 0)) {
                    goto LABEL_92;
                  }
                }
                else if (v20 == 16)
                {
                  uint64_t v23 = *(unsigned int *)(v19 + 32);
                  if (v23 >= 0x41)
                  {
                    int v35 = 0;
                    int64_t v36 = (unint64_t)(v23 + 63) >> 6;
                    do
                    {
                      BOOL v21 = v36-- < 1;
                      if (v21) {
                        break;
                      }
                      unint64_t v37 = *(void *)(*(void *)(v19 + 24) + 8 * v36);
                      v35 += __clz(v37);
                    }
                    while (!v37);
                    int v38 = v23 | 0xFFFFFFC0;
                    if ((v23 & 0x3F) == 0) {
                      int v38 = 0;
                    }
                    if (v35 + v38 != v23)
                    {
LABEL_92:
                      int v24 = 0;
                      goto LABEL_94;
                    }
                  }
                  else if (*(void *)(v19 + 24))
                  {
                    goto LABEL_92;
                  }
                }
                else
                {
                  if (v20 == 17)
                  {
                    if (sub_1CB844168(*((void *)v69 + i), 0.0)) {
                      continue;
                    }
                    unsigned int v20 = *(unsigned __int8 *)(v19 + 16);
                  }
                  else if (v20 - 18 < 3 || v20 == 13)
                  {
                    continue;
                  }
                  if (v20 - 11 >= 2) {
                    goto LABEL_92;
                  }
                }
              }
            }
          }
          int v24 = 1;
LABEL_94:
          if (v69 != v71) {
            free(v69);
          }
          if (v64)
          {
            if (!v24) {
              return;
            }
          }
          else
          {
            MEMORY[0x1D25D9CD0](v65.i64[0], 8);
            if (!v24) {
              return;
            }
          }
        }
      }
      ++v5;
    }
    while (v5 != v6);
    uint64_t v40 = *(unsigned int *)(a1 + 80);
    if (v40)
    {
      uint64_t v41 = *(uint64_t **)(a1 + 72);
      uint64_t v42 = &v41[v40];
      do
      {
        uint64_t v43 = *v41;
        uint64_t v44 = *(void *)(*v41 + 112);
        if ((!v44 || *(_DWORD *)(v44 + 8) < 2u || (uint64_t v60 = *(void *)(v44 + 48)) == 0 || (*(unsigned char *)(v60 + 14) & 8) == 0)
          && *(unsigned char *)(**(void **)(*(void *)(v43 + 24) + 16) + 8) == 15)
        {
          *(void *)(v43 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(*v41 + 112), **(uint64_t ***)v43, 0, 19);
          uint64_t v45 = *(void *)(a2 + 8);
          uint64_t v46 = *(unsigned int *)(a2 + 20);
          if (v45 != *(void *)a2)
          {
            unsigned int v50 = *(_DWORD *)(a2 + 16);
LABEL_121:
            if (3 * v50 <= 4 * ((int)v46 - *(_DWORD *)(a2 + 24)))
            {
              if (v50 >= 0x40) {
                v50 *= 2;
              }
              else {
                unsigned int v50 = 128;
              }
            }
            else if (v50 - v46 >= v50 >> 3)
            {
              goto LABEL_123;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v50);
            unsigned int v50 = *(_DWORD *)(a2 + 16);
            uint64_t v45 = *(void *)(a2 + 8);
LABEL_123:
            unsigned int v51 = v50 - 1;
            unsigned int v52 = (v50 - 1) & ((v43 >> 4) ^ (v43 >> 9));
            BOOL v53 = (void *)(v45 + 8 * v52);
            uint64_t v54 = *v53;
            if (*v53 == -1)
            {
              char v55 = 0;
LABEL_135:
              if (v55) {
                unsigned int v59 = v55;
              }
              else {
                unsigned int v59 = v53;
              }
              if (*v59 != v43)
              {
                if (*v59 == -2) {
                  --*(_DWORD *)(a2 + 24);
                }
                else {
                  ++*(_DWORD *)(a2 + 20);
                }
                *unsigned int v59 = v43;
              }
            }
            else
            {
              char v55 = 0;
              int v56 = 1;
              while (v54 != v43)
              {
                if (v55) {
                  BOOL v57 = 0;
                }
                else {
                  BOOL v57 = v54 == -2;
                }
                if (v57) {
                  char v55 = v53;
                }
                unsigned int v58 = v52 + v56++;
                unsigned int v52 = v58 & v51;
                BOOL v53 = (void *)(v45 + 8 * (v58 & v51));
                uint64_t v54 = *v53;
                if (*v53 == -1) {
                  goto LABEL_135;
                }
              }
            }
            goto LABEL_142;
          }
          if (v46)
          {
            unsigned int v47 = 0;
            uint64_t v48 = 8 * v46;
            uint64_t v49 = *(void **)(a2 + 8);
            while (*v49 != v43)
            {
              if (*v49 == -2) {
                unsigned int v47 = v49;
              }
              ++v49;
              v48 -= 8;
              if (!v48)
              {
                if (!v47) {
                  goto LABEL_118;
                }
                *unsigned int v47 = v43;
                --*(_DWORD *)(a2 + 24);
                goto LABEL_142;
              }
            }
            goto LABEL_142;
          }
LABEL_118:
          unsigned int v50 = *(_DWORD *)(a2 + 16);
          if (v46 >= v50) {
            goto LABEL_121;
          }
          *(_DWORD *)(a2 + 20) = v46 + 1;
          *(void *)(v45 + 8 * v46) = v43;
        }
LABEL_142:
        ++v41;
      }
      while (v41 != v42);
    }
  }
}

void sub_1CC90C7FC(uint64_t a1, uint64_t a2)
{
  v87[8] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(a1 + 80);
  if (!v2) {
    return;
  }
  uint64_t v3 = a2;
  uint64_t v4 = *(llvm::GlobalValue ***)(a1 + 72);
  uint64_t v5 = &v4[v2];
  int64x2_t v75 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  char v72 = 1;
  uint64_t v74 = v5;
  do
  {
    while (1)
    {
      uint64_t v6 = *v4;
      uint64_t v8 = (uint64_t *)((char *)*v4 + 112);
      uint64_t v7 = *v8;
      if (*v8)
      {
        if (*(_DWORD *)(v7 + 8) >= 2u)
        {
          uint64_t v49 = *(void *)(v7 + 48);
          if (v49)
          {
            if (*(char *)(v49 + 16) < 0) {
              goto LABEL_117;
            }
          }
        }
      }
      if (*((unsigned char *)v6 + 16))
      {
        if (*((unsigned char *)v6 + 16) == 3 && (*((_DWORD *)v6 + 5) & 0x7FFFFFF) == 0) {
          return;
        }
      }
      else if (*((llvm::GlobalValue **)v6 + 9) == (llvm::GlobalValue *)((char *)v6 + 72) {
             && (*((unsigned char *)v6 + 34) & 0x80) == 0)
      }
      {
        return;
      }
      if ((1 << (*((_DWORD *)v6 + 8) & 0xF)) & 0x7D5) == 0 || (llvm::GlobalValue::isInterposable(*v4)) {
        return;
      }
      if (*(unsigned char *)(**(void **)(*((void *)v6 + 3) + 16) + 8) != 15) {
        goto LABEL_117;
      }
      uint64_t v80 = 1;
      int64x2_t v81 = v75;
      int64x2_t v82 = v75;
      int64x2_t v83 = v75;
      int64x2_t v84 = v75;
      uint64_t v85 = v87;
      uint64_t v86 = 0x800000000;
      unsigned int v9 = (void *)*((void *)v6 + 10);
      if (v9 != (void *)((char *)v6 + 72))
      {
        do
        {
          uint64_t v10 = v9 - 3;
          if (!v9) {
            uint64_t v10 = 0;
          }
          uint64_t v11 = (void *)v10[5];
          if (v11 != v10 + 5)
          {
            uint64_t v12 = v11 - 3;
            if (!v11) {
              uint64_t v12 = 0;
            }
            unsigned int v13 = *((unsigned __int8 *)v12 + 16) - 40;
            if (v13 < 0xFFFFFFF5) {
              uint64_t v12 = 0;
            }
            if (v11)
            {
              if (*((unsigned char *)v12 + 16) == 29 && v13 >= 0xFFFFFFF5)
              {
                uint64_t v15 = *((_DWORD *)v12 + 5) & 0x7FFFFFF;
                if (v15) {
                  uint64_t v16 = v12[-4 * v15];
                }
                else {
                  uint64_t v16 = 0;
                }
                v78[0] = v16;
                sub_1CC911830((uint64_t)&v80, v78);
              }
            }
          }
          unsigned int v9 = (void *)v9[1];
        }
        while (v9 != (void *)((char *)v6 + 72));
        if (v86)
        {
          unsigned int v17 = 0;
          int v18 = 0;
          uint64_t v19 = *((void *)v6 + 5) + 272;
          while (1)
          {
            uint64_t v20 = *((void *)v85 + v17);
            if (v20) {
              BOOL v21 = *(unsigned __int8 *)(v20 + 16) >= 0x1Cu;
            }
            else {
              BOOL v21 = 0;
            }
            if (!v21 || (uint64_t v22 = *((void *)v85 + v17), !*(void *)(v20 + 40))) {
              uint64_t v22 = 0;
            }
            v78[0] = v19;
            v78[1] = 0;
            v78[2] = v22;
            v78[3] = 0;
            v78[4] = 0;
            char v79 = 1;
            if ((sub_1CC1620B8(v20, 0, (uint64_t)v78) & 1) == 0)
            {
              unsigned int v23 = *(unsigned __int8 *)(v20 + 16);
              if (v20) {
                BOOL v24 = v23 >= 0x1C;
              }
              else {
                BOOL v24 = 0;
              }
              if (!v24)
              {
LABEL_88:
                int v25 = 0;
                goto LABEL_73;
              }
              int v25 = 0;
              switch(*(unsigned char *)(v20 + 16))
              {
                case 'M':
                case 'N':
                  goto LABEL_57;
                case 'O':
                case 'P':
                case 'Q':
                case 'R':
                  goto LABEL_73;
                case 'S':
                  uint64_t v26 = *(_DWORD *)(v20 + 20) & 0x7FFFFFF;
                  if (v26)
                  {
                    uint64_t v27 = 0;
                    uint64_t v28 = 32 * v26;
                    do
                    {
                      int v29 = *(_DWORD *)(v20 + 20);
                      if ((v29 & 0x40000000) != 0) {
                        uint64_t v30 = *(void *)(v20 - 8);
                      }
                      else {
                        uint64_t v30 = v20 - 32 * (v29 & 0x7FFFFFF);
                      }
                      v78[0] = *(void *)(v30 + v27);
                      sub_1CC911830((uint64_t)&v80, v78);
                      v27 += 32;
                    }
                    while (v28 != v27);
                    uint64_t v3 = a2;
                  }
                  break;
                case 'T':
                  goto LABEL_59;
                case 'U':
                  v78[0] = *(void *)(v20 - 64);
                  sub_1CC911830((uint64_t)&v80, v78);
                  uint64_t v34 = *(void *)(v20 - 32);
                  goto LABEL_67;
                default:
                  if (v23 == 33)
                  {
LABEL_59:
                    uint64_t v33 = *(void *)(v20 - 32);
                    if (!v33) {
                      goto LABEL_88;
                    }
                    if (*(unsigned char *)(v33 + 16)) {
                      goto LABEL_88;
                    }
                    if (*(void *)(v33 + 24) != *(void *)(v20 + 72)) {
                      goto LABEL_88;
                    }
                    uint64_t v77 = 0;
                    v78[0] = v33;
                    if (!sub_1CC8B6C50(a1, v78, &v77)) {
                      goto LABEL_88;
                    }
                    int v18 = 1;
                  }
                  else
                  {
                    if (v23 != 62) {
                      goto LABEL_73;
                    }
LABEL_57:
                    int v31 = *(_DWORD *)(v20 + 20);
                    if ((v31 & 0x40000000) != 0) {
                      uint64_t v32 = *(uint64_t **)(v20 - 8);
                    }
                    else {
                      uint64_t v32 = (uint64_t *)(v20 - 32 * (v31 & 0x7FFFFFF));
                    }
                    uint64_t v34 = *v32;
LABEL_67:
                    v78[0] = v34;
                    sub_1CC911830((uint64_t)&v80, v78);
                  }
                  break;
              }
            }
            if (v86 == ++v17) {
              goto LABEL_72;
            }
          }
        }
      }
      int v18 = 0;
LABEL_72:
      int v25 = 1;
LABEL_73:
      if (v85 != v87) {
        free(v85);
      }
      if (v80) {
        break;
      }
      MEMORY[0x1D25D9CD0](v81.i64[0], 8);
      if (v25) {
        goto LABEL_77;
      }
LABEL_104:
      char v72 = 0;
      ++v4;
      uint64_t v5 = v74;
      if (v4 == v74) {
        return;
      }
    }
    if (!v25) {
      goto LABEL_104;
    }
LABEL_77:
    uint64_t v5 = v74;
    if (v18) {
      goto LABEL_117;
    }
    *((void *)v6 + 14) = llvm::AttributeList::addAttributeAtIndex(v8, **(uint64_t ***)v6, 0, 39);
    uint64_t v35 = *(void *)(v3 + 8);
    uint64_t v36 = *(unsigned int *)(v3 + 20);
    if (v35 != *(void *)v3)
    {
      unsigned int v40 = *(_DWORD *)(v3 + 16);
      goto LABEL_90;
    }
    if (!v36)
    {
LABEL_86:
      unsigned int v40 = *(_DWORD *)(v3 + 16);
      if (v36 < v40)
      {
        *(_DWORD *)(v3 + 20) = v36 + 1;
        *(void *)(v35 + 8 * v36) = v6;
        goto LABEL_117;
      }
LABEL_90:
      if (3 * v40 <= 4 * ((int)v36 - *(_DWORD *)(v3 + 24)))
      {
        if (v40 >= 0x40) {
          v40 *= 2;
        }
        else {
          unsigned int v40 = 128;
        }
      }
      else if (v40 - v36 >= v40 >> 3)
      {
        goto LABEL_92;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v3, v40);
      unsigned int v40 = *(_DWORD *)(v3 + 16);
      uint64_t v35 = *(void *)(v3 + 8);
LABEL_92:
      unsigned int v41 = v40 - 1;
      unsigned int v42 = (v40 - 1) & ((v6 >> 4) ^ (v6 >> 9));
      uint64_t v43 = (llvm::GlobalValue **)(v35 + 8 * v42);
      uint64_t v44 = *v43;
      if (*v43 == (llvm::GlobalValue *)-1)
      {
        uint64_t v45 = 0;
LABEL_110:
        if (v45) {
          unsigned int v50 = v45;
        }
        else {
          unsigned int v50 = v43;
        }
        if (*v50 != v6)
        {
          if (*v50 == (llvm::GlobalValue *)-2) {
            --*(_DWORD *)(v3 + 24);
          }
          else {
            ++*(_DWORD *)(v3 + 20);
          }
          llvm::GlobalValue *v50 = v6;
        }
      }
      else
      {
        uint64_t v45 = 0;
        int v46 = 1;
        while (v44 != v6)
        {
          if (v45) {
            BOOL v47 = 0;
          }
          else {
            BOOL v47 = v44 == (llvm::GlobalValue *)-2;
          }
          if (v47) {
            uint64_t v45 = v43;
          }
          unsigned int v48 = v42 + v46++;
          unsigned int v42 = v48 & v41;
          uint64_t v43 = (llvm::GlobalValue **)(v35 + 8 * (v48 & v41));
          uint64_t v44 = *v43;
          if (*v43 == (llvm::GlobalValue *)-1) {
            goto LABEL_110;
          }
        }
      }
      goto LABEL_117;
    }
    unint64_t v37 = 0;
    uint64_t v38 = 8 * v36;
    uint64_t v39 = *(llvm::GlobalValue ***)(v3 + 8);
    while (*v39 != v6)
    {
      if (*v39 == (llvm::GlobalValue *)-2) {
        unint64_t v37 = v39;
      }
      ++v39;
      v38 -= 8;
      if (!v38)
      {
        if (!v37) {
          goto LABEL_86;
        }
        *unint64_t v37 = v6;
        --*(_DWORD *)(v3 + 24);
        break;
      }
    }
LABEL_117:
    ++v4;
  }
  while (v4 != v5);
  if (v72)
  {
    uint64_t v51 = *(unsigned int *)(a1 + 80);
    if (v51)
    {
      unsigned int v52 = *(uint64_t **)(a1 + 72);
      BOOL v53 = &v52[v51];
      do
      {
        uint64_t v54 = *v52;
        uint64_t v55 = *(void *)(*v52 + 112);
        if ((!v55
           || *(_DWORD *)(v55 + 8) < 2u
           || (uint64_t v71 = *(void *)(v55 + 48)) == 0
           || (*(char *)(v71 + 16) & 0x80000000) == 0)
          && *(unsigned char *)(**(void **)(*(void *)(v54 + 24) + 16) + 8) == 15)
        {
          *(void *)(v54 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(*v52 + 112), **(uint64_t ***)v54, 0, 39);
          uint64_t v56 = *(void *)(v3 + 8);
          uint64_t v57 = *(unsigned int *)(v3 + 20);
          if (v56 != *(void *)v3)
          {
            unsigned int v61 = *(_DWORD *)(v3 + 16);
LABEL_142:
            if (3 * v61 <= 4 * ((int)v57 - *(_DWORD *)(v3 + 24)))
            {
              if (v61 >= 0x40) {
                v61 *= 2;
              }
              else {
                unsigned int v61 = 128;
              }
            }
            else if (v61 - v57 >= v61 >> 3)
            {
              goto LABEL_144;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v3, v61);
            unsigned int v61 = *(_DWORD *)(v3 + 16);
            uint64_t v56 = *(void *)(v3 + 8);
LABEL_144:
            unsigned int v62 = v61 - 1;
            unsigned int v63 = (v61 - 1) & ((v54 >> 4) ^ (v54 >> 9));
            uint64_t v64 = (void *)(v56 + 8 * v63);
            uint64_t v65 = *v64;
            if (*v64 == -1)
            {
              int64x2_t v66 = 0;
LABEL_156:
              if (v66) {
                uint64_t v70 = v66;
              }
              else {
                uint64_t v70 = v64;
              }
              if (*v70 != v54)
              {
                if (*v70 == -2) {
                  --*(_DWORD *)(v3 + 24);
                }
                else {
                  ++*(_DWORD *)(v3 + 20);
                }
                *uint64_t v70 = v54;
              }
            }
            else
            {
              int64x2_t v66 = 0;
              int v67 = 1;
              while (v65 != v54)
              {
                if (v66) {
                  BOOL v68 = 0;
                }
                else {
                  BOOL v68 = v65 == -2;
                }
                if (v68) {
                  int64x2_t v66 = v64;
                }
                unsigned int v69 = v63 + v67++;
                unsigned int v63 = v69 & v62;
                uint64_t v64 = (void *)(v56 + 8 * (v69 & v62));
                uint64_t v65 = *v64;
                if (*v64 == -1) {
                  goto LABEL_156;
                }
              }
            }
            goto LABEL_163;
          }
          if (v57)
          {
            unsigned int v58 = 0;
            uint64_t v59 = 8 * v57;
            uint64_t v60 = *(void **)(v3 + 8);
            while (*v60 != v54)
            {
              if (*v60 == -2) {
                unsigned int v58 = v60;
              }
              ++v60;
              v59 -= 8;
              if (!v59)
              {
                if (!v58) {
                  goto LABEL_139;
                }
                *unsigned int v58 = v54;
                --*(_DWORD *)(v3 + 24);
                goto LABEL_163;
              }
            }
            goto LABEL_163;
          }
LABEL_139:
          unsigned int v61 = *(_DWORD *)(v3 + 16);
          if (v57 >= v61) {
            goto LABEL_142;
          }
          *(_DWORD *)(v3 + 20) = v57 + 1;
          *(void *)(v56 + 8 * v57) = v54;
        }
LABEL_163:
        ++v52;
      }
      while (v52 != v53);
    }
  }
}

void sub_1CC90CFC4(uint64_t a1, uint64_t a2)
{
  v44[52] = *MEMORY[0x1E4F143B8];
  unsigned int v42 = v44;
  uint64_t v43 = 0x400000000;
  if (!byte_1EBCDE818)
  {
    v32[0] = &unk_1F2627F58;
    uint64_t v33 = v32;
    v30[0] = &unk_1F2627FA0;
    v30[1] = a1;
    int v31 = v30;
    v28[0] = &unk_1F2627FE8;
    int v29 = v28;
    v34[0] = &unk_1F2627F58;
    uint64_t v35 = v34;
    v36[0] = &unk_1F2627FA0;
    v36[1] = a1;
    uint64_t v39 = v38;
    unint64_t v37 = v36;
    v38[0] = &unk_1F2627FE8;
    int v40 = 37;
    char v41 = 1;
    sub_1CC9107B4((uint64_t)&v42, (unint64_t)v34);
    if (v39 == v38)
    {
      (*(void (**)(void *))(v38[0] + 32))(v38);
    }
    else if (v39)
    {
      (*(void (**)(void))(*v39 + 40))();
    }
    if (v37 == v36)
    {
      (*(void (**)(void *))(v36[0] + 32))(v36);
    }
    else if (v37)
    {
      (*(void (**)(void))(*v37 + 40))();
    }
    if (v35 == v34)
    {
      (*(void (**)(void *))(v34[0] + 32))(v34);
    }
    else if (v35)
    {
      (*(void (**)(void))(*v35 + 40))();
    }
    if (v29 == v28)
    {
      (*(void (**)(void *))(v28[0] + 32))(v28);
    }
    else if (v29)
    {
      (*(void (**)(void))(*v29 + 40))();
    }
    if (v31 == v30)
    {
      (*(void (**)(void *))(v30[0] + 32))(v30);
    }
    else if (v31)
    {
      (*(void (**)(void))(*v31 + 40))();
    }
    if (v33 == v32)
    {
      (*(void (**)(void *))(v32[0] + 32))(v32);
    }
    else if (v33)
    {
      (*(void (**)(void))(*v33 + 40))();
    }
  }
  if (!byte_1EBCDE8D8)
  {
    v18[0] = &unk_1F2628030;
    uint64_t v19 = v18;
    v16[0] = &unk_1F2628078;
    v16[1] = a1;
    unsigned int v17 = v16;
    v14[0] = &unk_1F26280C0;
    uint64_t v15 = v14;
    v20[0] = &unk_1F2628030;
    BOOL v21 = v20;
    v22[0] = &unk_1F2628078;
    v22[1] = a1;
    int v25 = v24;
    unsigned int v23 = v22;
    v24[0] = &unk_1F26280C0;
    int v26 = 25;
    char v27 = 1;
    sub_1CC9107B4((uint64_t)&v42, (unint64_t)v20);
    if (v25 == v24)
    {
      (*(void (**)(void *))(v24[0] + 32))(v24);
    }
    else if (v25)
    {
      (*(void (**)(void))(*v25 + 40))();
    }
    if (v23 == v22)
    {
      (*(void (**)(void *))(v22[0] + 32))(v22);
    }
    else if (v23)
    {
      (*(void (**)(void))(*v23 + 40))();
    }
    if (v21 == v20)
    {
      (*(void (**)(void *))(v20[0] + 32))(v20);
    }
    else if (v21)
    {
      (*(void (**)(void))(*v21 + 40))();
    }
    if (v15 == v14)
    {
      (*(void (**)(void *))(v14[0] + 32))(v14);
    }
    else if (v15)
    {
      (*(void (**)(void))(*v15 + 40))();
    }
    if (v17 == v16)
    {
      (*(void (**)(void *))(v16[0] + 32))(v16);
    }
    else if (v17)
    {
      (*(void (**)(void))(*v17 + 40))();
    }
    if (v19 == v18)
    {
      (*(void (**)(void *))(v18[0] + 32))(v18);
    }
    else if (v19)
    {
      (*(void (**)(void))(*v19 + 40))();
    }
  }
  sub_1CC90FC84((uint64_t)&v42, a1, a2);
  uint64_t v4 = (char *)v42;
  if (v43)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 104 * v43;
    uint64_t v7 = (char *)v42;
    do
    {
      uint64_t v8 = &v4[v6];
      uint64_t v9 = (uint64_t)&v4[v6 - 40];
      uint64_t v10 = *(void *)&v4[v6 - 16];
      if (v9 == v10)
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
      }
      else if (v10)
      {
        (*(void (**)(void))(*(void *)v10 + 40))(*(void *)&v4[v6 - 16]);
      }
      uint64_t v11 = (uint64_t)&v4[v6 - 72];
      uint64_t v12 = *(void *)&v4[v6 - 48];
      if (v11 == v12)
      {
        (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
      }
      else if (v12)
      {
        (*(void (**)(void))(*(void *)v12 + 40))(*(void *)&v4[v6 - 48]);
      }
      unsigned int v13 = *(char **)&v4[v6 - 80];
      if (v8 - 104 == v13)
      {
        (*(void (**)(char *))(*((void *)v8 - 13) + 32))(v8 - 104);
      }
      else if (v13)
      {
        (*(void (**)(void))(*(void *)v13 + 40))(*(void *)&v4[v6 - 80]);
      }
      v5 += 104;
      v4 -= 104;
      v7 -= 104;
    }
    while (v6 != v5);
    uint64_t v4 = (char *)v42;
  }
  if (v4 != (char *)v44) {
    free(v4);
  }
}

void sub_1CC90D890(llvm::GlobalValue **a1, int a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a2 != 1) {
    return;
  }
  uint64_t v3 = *a1;
  if (!*a1) {
    return;
  }
  if (*((unsigned char *)v3 + 16))
  {
    if (*((unsigned char *)v3 + 16) == 3 && (*((_DWORD *)v3 + 5) & 0x7FFFFFF) == 0) {
      return;
    }
  }
  else if (*((llvm::GlobalValue **)v3 + 9) == (llvm::GlobalValue *)((char *)v3 + 72) {
         && (*((unsigned char *)v3 + 34) & 0x80) == 0)
  }
  {
    return;
  }
  if (((1 << (*((_DWORD *)v3 + 8) & 0xF)) & 0x7D5) == 0) {
    return;
  }
  if (llvm::GlobalValue::isInterposable(*a1)) {
    return;
  }
  uint64_t v5 = *((void *)v3 + 14);
  if (v5)
  {
    if ((*(unsigned char *)(v5 + 15) & 0x40) != 0) {
      return;
    }
  }
  for (unsigned int i = (void *)*((void *)v3 + 10); i != (void *)((char *)v3 + 72); unsigned int i = (void *)i[1])
  {
    if (i) {
      uint64_t v7 = (llvm::BasicBlock *)(i - 3);
    }
    else {
      uint64_t v7 = 0;
    }
    llvm::BasicBlock::instructionsWithoutDebug(v7, 1, (uint64_t)&v39);
    long long v36 = v39;
    if (v41)
    {
      if (v41 == v40)
      {
        uint64_t v38 = v37;
        (*(void (**)(void *, void *))(v40[0] + 24))(v40, v37);
      }
      else
      {
        uint64_t v38 = (void *)(*(uint64_t (**)(void))(*v41 + 16))();
      }
    }
    else
    {
      uint64_t v38 = 0;
    }
    uint64_t v33 = v42;
    if (v44)
    {
      if (v44 == v43)
      {
        uint64_t v35 = v34;
        (*(void (**)(void *, void *))(v43[0] + 24))(v43, v34);
      }
      else
      {
        uint64_t v35 = (void *)(*(uint64_t (**)(void))(*v44 + 16))();
      }
    }
    else
    {
      uint64_t v35 = 0;
    }
    uint64_t v8 = v36;
LABEL_28:
    while (v8 != v33)
    {
      uint64_t v9 = v8 - 24;
      if (!v8) {
        uint64_t v9 = 0;
      }
      unsigned int v10 = *(unsigned __int8 *)(v9 + 16) - 33;
      BOOL v11 = v10 > 0x33;
      uint64_t v12 = (1 << v10) & 0x8000000000041;
      if (!v11 && v12 != 0)
      {
        uint64_t v14 = *(void *)(v8 - 56);
        if (!v14
          || *(unsigned char *)(v14 + 16)
          || (llvm::GlobalValue *)v14 == v3
          || *(void *)(v14 + 24) != *(void *)(v8 + 48)
          || (uint64_t v15 = *(void *)(v14 + 112)) == 0
          || (*(unsigned char *)(v15 + 15) & 0x40) == 0)
        {
          if (v35 == v34)
          {
            (*(void (**)(void *))(v34[0] + 32))(v34);
          }
          else if (v35)
          {
            (*(void (**)(void))(*v35 + 40))();
          }
          if (v38 == v37)
          {
            (*(void (**)(void *))(v37[0] + 32))(v37);
          }
          else if (v38)
          {
            (*(void (**)(void))(*v38 + 40))();
          }
          unsigned int v23 = v44;
          if (v44 == v43)
          {
            (*(void (**)(void *))(v43[0] + 32))(v43);
LABEL_84:
            if (v41 == v40)
            {
              (*(void (**)(void *))(v40[0] + 32))(v40);
            }
            else if (v41)
            {
              (*(void (**)(void))(*v41 + 40))();
            }
            return;
          }
LABEL_116:
          if (v23) {
            (*(void (**)(void *))(*v23 + 40))(v23);
          }
          goto LABEL_84;
        }
      }
      uint64_t v8 = *(void *)(v8 + 8);
      *(void *)&long long v36 = v8;
      if (v8 != *((void *)&v36 + 1))
      {
        while (v38)
        {
          char v16 = (*(uint64_t (**)(void))(*v38 + 48))();
          uint64_t v8 = v36;
          if ((v16 & 1) == 0)
          {
            uint64_t v8 = *(void *)(v36 + 8);
            *(void *)&long long v36 = v8;
            if (v8 != *((void *)&v36 + 1)) {
              continue;
            }
          }
          goto LABEL_28;
        }
        sub_1CB920400();
        goto LABEL_116;
      }
    }
    if (v35 == v34)
    {
      (*(void (**)(void *))(v34[0] + 32))(v34);
    }
    else if (v35)
    {
      (*(void (**)(void))(*v35 + 40))();
    }
    if (v38 == v37)
    {
      (*(void (**)(void *))(v37[0] + 32))(v37);
    }
    else if (v38)
    {
      (*(void (**)(void))(*v38 + 40))();
    }
    if (v44 == v43)
    {
      (*(void (**)(void *))(v43[0] + 32))(v43);
    }
    else if (v44)
    {
      (*(void (**)(void))(*v44 + 40))();
    }
    if (v41 == v40)
    {
      (*(void (**)(void *))(v40[0] + 32))(v40);
    }
    else if (v41)
    {
      (*(void (**)(void))(*v41 + 40))();
    }
  }
  *((void *)v3 + 14) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v3 + 14, **(uint64_t ***)v3, -1, 30);
  uint64_t v17 = *(void *)(a3 + 8);
  uint64_t v18 = *(unsigned int *)(a3 + 20);
  if (v17 != *(void *)a3)
  {
    unsigned int v22 = *(_DWORD *)(a3 + 16);
    goto LABEL_88;
  }
  if (!v18)
  {
LABEL_75:
    unsigned int v22 = *(_DWORD *)(a3 + 16);
    if (v18 < v22)
    {
      *(_DWORD *)(a3 + 20) = v18 + 1;
      *(void *)(v17 + 8 * v18) = v3;
      return;
    }
LABEL_88:
    if (3 * v22 <= 4 * ((int)v18 - *(_DWORD *)(a3 + 24)))
    {
      if (v22 >= 0x40) {
        v22 *= 2;
      }
      else {
        unsigned int v22 = 128;
      }
    }
    else if (v22 - v18 >= v22 >> 3)
    {
      goto LABEL_90;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v22);
    unsigned int v22 = *(_DWORD *)(a3 + 16);
    uint64_t v17 = *(void *)(a3 + 8);
LABEL_90:
    unsigned int v24 = v22 - 1;
    unsigned int v25 = (v22 - 1) & ((v3 >> 4) ^ (v3 >> 9));
    int v26 = (llvm::GlobalValue **)(v17 + 8 * v25);
    char v27 = *v26;
    if (*v26 == (llvm::GlobalValue *)-1)
    {
      uint64_t v28 = 0;
LABEL_102:
      if (v28) {
        uint64_t v32 = v28;
      }
      else {
        uint64_t v32 = v26;
      }
      if (*v32 != v3)
      {
        if (*v32 == (llvm::GlobalValue *)-2) {
          --*(_DWORD *)(a3 + 24);
        }
        else {
          ++*(_DWORD *)(a3 + 20);
        }
        *uint64_t v32 = v3;
      }
    }
    else
    {
      uint64_t v28 = 0;
      int v29 = 1;
      while (v27 != v3)
      {
        if (v28) {
          BOOL v30 = 0;
        }
        else {
          BOOL v30 = v27 == (llvm::GlobalValue *)-2;
        }
        if (v30) {
          uint64_t v28 = v26;
        }
        unsigned int v31 = v25 + v29++;
        unsigned int v25 = v31 & v24;
        int v26 = (llvm::GlobalValue **)(v17 + 8 * (v31 & v24));
        char v27 = *v26;
        if (*v26 == (llvm::GlobalValue *)-1) {
          goto LABEL_102;
        }
      }
    }
    return;
  }
  uint64_t v19 = 0;
  uint64_t v20 = 8 * v18;
  BOOL v21 = *(llvm::GlobalValue ***)(a3 + 8);
  while (*v21 != v3)
  {
    if (*v21 == (llvm::GlobalValue *)-2) {
      uint64_t v19 = v21;
    }
    ++v21;
    v20 -= 8;
    if (!v20)
    {
      if (!v19) {
        goto LABEL_75;
      }
      *uint64_t v19 = v3;
      --*(_DWORD *)(a3 + 24);
      return;
    }
  }
}

void sub_1CC90E03C(uint64_t a1, uint64_t a2)
{
  v30[52] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = v30;
  uint64_t v29 = 0x400000000;
  v18[0] = &unk_1F2628108;
  uint64_t v19 = v18;
  v16[0] = &unk_1F2628150;
  v16[1] = a1;
  uint64_t v17 = v16;
  v14[0] = &unk_1F2628198;
  uint64_t v15 = v14;
  v20[0] = &unk_1F2628108;
  BOOL v21 = v20;
  v22[0] = &unk_1F2628150;
  v22[1] = a1;
  unsigned int v25 = v24;
  unsigned int v23 = v22;
  v24[0] = &unk_1F2628198;
  int v26 = 35;
  char v27 = 1;
  sub_1CC9107B4((uint64_t)&v28, (unint64_t)v20);
  if (v25 == v24)
  {
    (*(void (**)(void *))(v24[0] + 32))(v24);
  }
  else if (v25)
  {
    (*(void (**)(void))(*v25 + 40))();
  }
  if (v23 == v22)
  {
    (*(void (**)(void *))(v22[0] + 32))(v22);
  }
  else if (v23)
  {
    (*(void (**)(void))(*v23 + 40))();
  }
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
  }
  else if (v21)
  {
    (*(void (**)(void))(*v21 + 40))();
  }
  if (v15 == v14)
  {
    (*(void (**)(void *))(v14[0] + 32))(v14);
  }
  else if (v15)
  {
    (*(void (**)(void))(*v15 + 40))();
  }
  if (v17 == v16)
  {
    (*(void (**)(void *))(v16[0] + 32))(v16);
  }
  else if (v17)
  {
    (*(void (**)(void))(*v17 + 40))();
  }
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void))(*v19 + 40))();
  }
  sub_1CC90FC84((uint64_t)&v28, a1, a2);
  uint64_t v4 = (char *)v28;
  if (v29)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 104 * v29;
    uint64_t v7 = (char *)v28;
    do
    {
      uint64_t v8 = &v4[v6];
      uint64_t v9 = (uint64_t)&v4[v6 - 40];
      uint64_t v10 = *(void *)&v4[v6 - 16];
      if (v9 == v10)
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
      }
      else if (v10)
      {
        (*(void (**)(void))(*(void *)v10 + 40))(*(void *)&v4[v6 - 16]);
      }
      uint64_t v11 = (uint64_t)&v4[v6 - 72];
      uint64_t v12 = *(void *)&v4[v6 - 48];
      if (v11 == v12)
      {
        (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
      }
      else if (v12)
      {
        (*(void (**)(void))(*(void *)v12 + 40))(*(void *)&v4[v6 - 48]);
      }
      unsigned int v13 = *(char **)&v4[v6 - 80];
      if (v8 - 104 == v13)
      {
        (*(void (**)(char *))(*((void *)v8 - 13) + 32))(v8 - 104);
      }
      else if (v13)
      {
        (*(void (**)(void))(*(void *)v13 + 40))(*(void *)&v4[v6 - 80]);
      }
      v5 += 104;
      v4 -= 104;
      v7 -= 104;
    }
    while (v6 != v5);
    uint64_t v4 = (char *)v28;
  }
  if (v4 != (char *)v30) {
    free(v4);
  }
}

char *sub_1CC90E5A8(uint64_t **a1, unint64_t a2)
{
  uint64_t v5 = a1 + 1;
  uint64_t v4 = (char *)a1[1];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = v4;
        unint64_t v7 = *((void *)v4 + 4);
        if (v7 <= a2) {
          break;
        }
        uint64_t v4 = *(char **)v6;
        uint64_t v5 = (uint64_t **)v6;
        if (!*(void *)v6) {
          goto LABEL_9;
        }
      }
      if (v7 >= a2) {
        break;
      }
      uint64_t v4 = (char *)*((void *)v6 + 1);
      if (!v4)
      {
        uint64_t v5 = (uint64_t **)(v6 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v6 = (char *)(a1 + 1);
LABEL_9:
    uint64_t v8 = v6;
    uint64_t v6 = (char *)operator new(0x60uLL);
    *((void *)v6 + 4) = a2;
    *(_OWORD *)(v6 + 40) = 0u;
    *(_OWORD *)(v6 + 56) = 0u;
    *((void *)v6 + 11) = 0;
    *(_OWORD *)(v6 + 72) = 0u;
    *((void *)v6 + 6) = v6 + 64;
    *((_DWORD *)v6 + 15) = 4;
    *(void *)uint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v8;
    void *v5 = (uint64_t *)v6;
    uint64_t v9 = (uint64_t *)**a1;
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *a1 = v9;
      uint64_t v10 = *v5;
    }
    sub_1CB8358B8(a1[1], v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  *((void *)v6 + 5) = a2;
  uint64_t v11 = v6 + 40;
  unsigned int v12 = *((_DWORD *)a1 + 10);
  if (v12 >= *((_DWORD *)a1 + 11)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  a1[4][v12] = (uint64_t)v11;
  ++*((_DWORD *)a1 + 10);
  return v11;
}

void *sub_1CC90E6D4(void *a1)
{
  *a1 = &unk_1F2627E40;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CC90E728(llvm::Argument *a1, uint64_t *a2)
{
  unsigned char v118[32] = *MEMORY[0x1E4F143B8];
  uint64_t v116 = v118;
  uint64_t v117 = 0x2000000000;
  uint64_t v110 = v114;
  uint64_t v111 = v114;
  uint64_t v112 = 32;
  int v113 = 0;
  uint64_t v4 = 0;
  if (llvm::Argument::hasInAllocaAttr(a1)) {
    goto LABEL_268;
  }
  if (llvm::Argument::hasPreallocatedAttr(a1)) {
    goto LABEL_3;
  }
  uint64_t v5 = *((void *)a1 + 1);
  if (v5)
  {
    while (1)
    {
      uint64_t v6 = v111;
      uint64_t v7 = HIDWORD(v112);
      if (v111 != v110) {
        break;
      }
      if (HIDWORD(v112))
      {
        uint64_t v8 = 0;
        uint64_t v9 = 8 * HIDWORD(v112);
        uint64_t v10 = v111;
        while (*(void *)v10 != v5)
        {
          if (*(void *)v10 == -2) {
            uint64_t v8 = v10;
          }
          v10 += 8;
          v9 -= 8;
          if (!v9)
          {
            if (!v8) {
              goto LABEL_13;
            }
            *(void *)uint64_t v8 = v5;
            --v113;
            goto LABEL_37;
          }
        }
        goto LABEL_37;
      }
LABEL_13:
      unsigned int v11 = v112;
      if (HIDWORD(v112) >= v112) {
        goto LABEL_16;
      }
      ++HIDWORD(v112);
      *(void *)&v111[8 * v7] = v5;
LABEL_37:
      if (v117 >= (unint64_t)HIDWORD(v117)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v116 + v117) = v5;
      unsigned int v21 = v117 + 1;
      LODWORD(v117) = v117 + 1;
      uint64_t v5 = *(void *)(v5 + 8);
      if (!v5) {
        goto LABEL_48;
      }
    }
    unsigned int v11 = v112;
LABEL_16:
    if (3 * v11 <= 4 * (HIDWORD(v112) - v113))
    {
      if (v11 >= 0x40) {
        v11 *= 2;
      }
      else {
        unsigned int v11 = 128;
      }
    }
    else if (v11 - HIDWORD(v112) >= v11 >> 3)
    {
      goto LABEL_18;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v110, v11);
    unsigned int v11 = v112;
    uint64_t v6 = v111;
LABEL_18:
    unsigned int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((v5 >> 4) ^ (v5 >> 9));
    uint64_t v14 = &v6[8 * v13];
    uint64_t v15 = *(void *)v14;
    if (*(void *)v14 == -1)
    {
      char v16 = 0;
LABEL_30:
      if (v16) {
        uint64_t v20 = v16;
      }
      else {
        uint64_t v20 = v14;
      }
      if (*(void *)v20 != v5)
      {
        if (*(void *)v20 == -2) {
          --v113;
        }
        else {
          ++HIDWORD(v112);
        }
        *(void *)uint64_t v20 = v5;
      }
    }
    else
    {
      char v16 = 0;
      int v17 = 1;
      while (v15 != v5)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v15 == -2;
        }
        if (v18) {
          char v16 = v14;
        }
        unsigned int v19 = v13 + v17++;
        unsigned int v13 = v19 & v12;
        uint64_t v14 = &v6[8 * (v19 & v12)];
        uint64_t v15 = *(void *)v14;
        if (*(void *)v14 == -1) {
          goto LABEL_30;
        }
      }
    }
    goto LABEL_37;
  }
  unsigned int v21 = v117;
LABEL_48:
  if (!v21)
  {
    uint64_t v4 = 44;
    goto LABEL_268;
  }
  char v22 = 0;
  char v23 = 0;
  unsigned int v109 = a2;
  do
  {
    if (v23 & 1) != 0 && (v22) {
      goto LABEL_3;
    }
    uint64_t v4 = 0;
    unsigned int v24 = (void *)*((void *)v116 + --v21);
    LODWORD(v117) = v21;
    uint64_t v25 = v24[3];
    unsigned int v26 = *(unsigned __int8 *)(v25 + 16);
    if (v26 <= 0x3C)
    {
      if (v26 == 29) {
        continue;
      }
      if (v26 != 33)
      {
        if (v26 != 60) {
          goto LABEL_268;
        }
        if (*(_WORD *)(v25 + 18)) {
          goto LABEL_3;
        }
LABEL_159:
        char v22 = 1;
        goto LABEL_213;
      }
    }
    else
    {
      if (v26 - 62 > 0x17) {
        goto LABEL_183;
      }
      if (((1 << (v26 - 62)) & 0xA18001) != 0)
      {
        uint64_t v27 = *(void *)(v25 + 8);
        if (!v27) {
          goto LABEL_213;
        }
        while (1)
        {
          uint64_t v29 = v111;
          uint64_t v30 = HIDWORD(v112);
          if (v111 == v110)
          {
            if (HIDWORD(v112))
            {
              unsigned int v31 = 0;
              uint64_t v32 = 8 * HIDWORD(v112);
              uint64_t v33 = v111;
              while (*(void *)v33 != v27)
              {
                if (*(void *)v33 == -2) {
                  unsigned int v31 = v33;
                }
                v33 += 8;
                v32 -= 8;
                if (!v32)
                {
                  if (v31)
                  {
                    *(void *)unsigned int v31 = v27;
                    --v113;
                    goto LABEL_101;
                  }
                  goto LABEL_77;
                }
              }
              goto LABEL_103;
            }
LABEL_77:
            unsigned int v28 = v112;
            if (HIDWORD(v112) < v112)
            {
              ++HIDWORD(v112);
              *(void *)&v111[8 * v30] = v27;
              goto LABEL_101;
            }
          }
          else
          {
            unsigned int v28 = v112;
          }
          if (3 * v28 <= 4 * (HIDWORD(v112) - v113))
          {
            if (v28 >= 0x40) {
              v28 *= 2;
            }
            else {
              unsigned int v28 = 128;
            }
          }
          else if (v28 - HIDWORD(v112) >= v28 >> 3)
          {
            goto LABEL_82;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v110, v28);
          unsigned int v28 = v112;
          uint64_t v29 = v111;
LABEL_82:
          unsigned int v34 = v28 - 1;
          unsigned int v35 = (v28 - 1) & ((v27 >> 4) ^ (v27 >> 9));
          long long v36 = &v29[8 * v35];
          uint64_t v37 = *(void *)v36;
          if (*(void *)v36 != -1)
          {
            uint64_t v38 = 0;
            int v39 = 1;
            while (v37 != v27)
            {
              if (v38) {
                BOOL v40 = 0;
              }
              else {
                BOOL v40 = v37 == -2;
              }
              if (v40) {
                uint64_t v38 = v36;
              }
              unsigned int v41 = v35 + v39++;
              unsigned int v35 = v41 & v34;
              long long v36 = &v29[8 * (v41 & v34)];
              uint64_t v37 = *(void *)v36;
              if (*(void *)v36 == -1) {
                goto LABEL_94;
              }
            }
            goto LABEL_103;
          }
          uint64_t v38 = 0;
LABEL_94:
          if (v38) {
            long long v42 = v38;
          }
          else {
            long long v42 = v36;
          }
          if (*(void *)v42 == v27) {
            goto LABEL_103;
          }
          if (*(void *)v42 == -2) {
            --v113;
          }
          else {
            ++HIDWORD(v112);
          }
          *(void *)long long v42 = v27;
LABEL_101:
          if (v117 >= (unint64_t)HIDWORD(v117)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v116 + v117) = v27;
          LODWORD(v117) = v117 + 1;
LABEL_103:
          uint64_t v27 = *(void *)(v27 + 8);
          if (!v27) {
            goto LABEL_213;
          }
        }
      }
      if (v26 == 81) {
        continue;
      }
      if (v26 != 84)
      {
LABEL_183:
        if (v26 != 61) {
          goto LABEL_268;
        }
        if (*(void *)(v25 - 64) == *v24 || (*(_WORD *)(v25 + 18) & 1) != 0) {
          goto LABEL_3;
        }
        char v23 = 1;
        goto LABEL_213;
      }
    }
    uint64_t v43 = (uint64_t *)(v25 - 32);
    if ((void *)(v25 - 32) == v24) {
      goto LABEL_159;
    }
    unint64_t v44 = (unint64_t)&v24[4 * (*(_DWORD *)(v25 + 20) & 0x7FFFFFF)] - v25;
    if ((sub_1CBF5BC2C(v24[3], v44 >> 5, 22) & 1) == 0)
    {
      uint64_t v45 = *(void *)(v25 + 64);
      if (!v45 || (*(unsigned char *)(v45 + 17) & 0x30) == 0)
      {
        int v46 = *(_DWORD *)(v25 + 20);
        if (v46 < 0)
        {
          uint64_t v88 = v25 - 32 * (v46 & 0x7FFFFFF);
          uint64_t v91 = *(void *)(v88 - 8);
          uint64_t v89 = v88 - 8;
          uint64_t v90 = v91;
          if (v91)
          {
            uint64_t v92 = -v90;
            do
            {
              unsigned int v93 = *(_DWORD *)(*(void *)(v89 + v92) + 8);
              BOOL v94 = v93 > 7;
              int v95 = (1 << v93) & 0x83;
              if (v94 || v95 == 0) {
                goto LABEL_3;
              }
              v92 += 16;
            }
            while (v92);
          }
        }
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v25, 45) & 1) == 0
          && !llvm::CallBase::hasFnAttrOnCalledFunction(v25, 44))
        {
LABEL_3:
          uint64_t v4 = 0;
          goto LABEL_268;
        }
      }
      if (*(unsigned char *)(*(void *)v25 + 8) != 7)
      {
        uint64_t v47 = *(void *)(v25 + 8);
        if (v47)
        {
          while (1)
          {
            unsigned int v48 = v111;
            uint64_t v49 = HIDWORD(v112);
            if (v111 == v110)
            {
              if (HIDWORD(v112))
              {
                unsigned int v50 = 0;
                uint64_t v51 = 8 * HIDWORD(v112);
                unsigned int v52 = v111;
                while (*(void *)v52 != v47)
                {
                  if (*(void *)v52 == -2) {
                    unsigned int v50 = v52;
                  }
                  v52 += 8;
                  v51 -= 8;
                  if (!v51)
                  {
                    if (!v50) {
                      goto LABEL_124;
                    }
                    *(void *)unsigned int v50 = v47;
                    --v113;
                    goto LABEL_148;
                  }
                }
                goto LABEL_150;
              }
LABEL_124:
              unsigned int v53 = v112;
              if (HIDWORD(v112) < v112)
              {
                ++HIDWORD(v112);
                *(void *)&v111[8 * v49] = v47;
                goto LABEL_148;
              }
            }
            else
            {
              unsigned int v53 = v112;
            }
            if (3 * v53 <= 4 * (HIDWORD(v112) - v113)) {
              break;
            }
            if (v53 - HIDWORD(v112) < v53 >> 3) {
              goto LABEL_157;
            }
LABEL_129:
            unsigned int v54 = v53 - 1;
            unsigned int v55 = (v53 - 1) & ((v47 >> 4) ^ (v47 >> 9));
            uint64_t v56 = &v48[8 * v55];
            uint64_t v57 = *(void *)v56;
            if (*(void *)v56 != -1)
            {
              unsigned int v58 = 0;
              int v59 = 1;
              while (v57 != v47)
              {
                if (v58) {
                  BOOL v60 = 0;
                }
                else {
                  BOOL v60 = v57 == -2;
                }
                if (v60) {
                  unsigned int v58 = v56;
                }
                unsigned int v61 = v55 + v59++;
                unsigned int v55 = v61 & v54;
                uint64_t v56 = &v48[8 * (v61 & v54)];
                uint64_t v57 = *(void *)v56;
                if (*(void *)v56 == -1) {
                  goto LABEL_141;
                }
              }
              goto LABEL_150;
            }
            unsigned int v58 = 0;
LABEL_141:
            if (v58) {
              unsigned int v62 = v58;
            }
            else {
              unsigned int v62 = v56;
            }
            if (*(void *)v62 == v47) {
              goto LABEL_150;
            }
            if (*(void *)v62 == -2) {
              --v113;
            }
            else {
              ++HIDWORD(v112);
            }
            *(void *)unsigned int v62 = v47;
LABEL_148:
            if (v117 >= (unint64_t)HIDWORD(v117)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v116 + v117) = v47;
            LODWORD(v117) = v117 + 1;
LABEL_150:
            uint64_t v47 = *(void *)(v47 + 8);
            if (!v47) {
              goto LABEL_160;
            }
          }
          if (v53 >= 0x40) {
            v53 *= 2;
          }
          else {
            unsigned int v53 = 128;
          }
LABEL_157:
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v110, v53);
          unsigned int v53 = v112;
          unsigned int v48 = v111;
          goto LABEL_129;
        }
      }
    }
LABEL_160:
    uint64_t v63 = *(void *)(v25 + 64);
    if (v63 && (*(unsigned char *)(v63 + 17) & 0x10) != 0) {
      goto LABEL_213;
    }
    __int32 v115 = 7;
    if (!sub_1CC5CB59C(v25, &v115, 1uLL))
    {
LABEL_163:
      if (llvm::CallBase::hasFnAttrOnCalledFunction(v25, 44)) {
        goto LABEL_213;
      }
      uint64_t v64 = *v43;
LABEL_165:
      if (!v64) {
        goto LABEL_204;
      }
      goto LABEL_166;
    }
    uint64_t v64 = *v43;
    if (!*v43 || *(unsigned char *)(v64 + 16) || *(void *)(v64 + 24) != *(void *)(v25 + 72)) {
      goto LABEL_165;
    }
    if (*(_DWORD *)(v64 + 36) == 7) {
      goto LABEL_163;
    }
LABEL_166:
    if (!*(unsigned char *)(v64 + 16) && *(void *)(v64 + 24) == *(void *)(v25 + 72))
    {
      int v65 = *(_DWORD *)(v25 + 20);
      unint64_t v66 = v25 - 32 * (v65 & 0x7FFFFFF);
      if (v66 <= (unint64_t)v24)
      {
        int v67 = *(unsigned __int8 *)(v25 + 16);
        if (v67 == 84) {
          uint64_t v68 = 0;
        }
        else {
          uint64_t v68 = v67 == 39 ? (*(_DWORD *)(v25 + 80) + 1) : 2;
        }
        if (v65 < 0 && (uint64_t v106 = *(void *)(v66 - 8), (v106 & 0xFFFFFFFF0) != 0)) {
          uint64_t v69 = (*(_DWORD *)(v66 - 12) - *(_DWORD *)(v66 - v106));
        }
        else {
          uint64_t v69 = 0;
        }
        if (v25 - 32 * v68 - 32 * v69 - 32 > (unint64_t)v24
          && *(void *)(v64 + 96) > (unint64_t)(v44 >> 5))
        {
          if (*(_WORD *)(v64 + 18)) {
            llvm::Function::BuildLazyArguments((llvm::Function *)v64);
          }
          uint64_t v70 = *(void *)(v64 + 88) + 40 * (v44 >> 5);
          uint64_t v72 = *v109;
          uint64_t v71 = v109[1];
          if (v71 == *v109)
          {
            uint64_t v73 = *((unsigned int *)v109 + 5);
            uint64_t v74 = (void *)(v71 + 8 * v73);
            if (v73)
            {
              uint64_t v75 = 0;
              while (*(void *)(v71 + v75) != v70)
              {
                v75 += 8;
                if (8 * v73 == v75) {
                  goto LABEL_200;
                }
              }
              uint64_t v74 = (void *)(v71 + v75);
            }
LABEL_200:
            uint64_t v72 = v109[1];
          }
          else
          {
            uint64_t v76 = *((unsigned int *)v109 + 4);
            int v77 = v76 - 1;
            unsigned int v78 = (v76 - 1) & ((v70 >> 4) ^ (v70 >> 9));
            uint64_t v74 = (void *)(v71 + 8 * v78);
            uint64_t v79 = *v74;
            if (*v74 == -1)
            {
              uint64_t v80 = 0;
LABEL_223:
              if (v80) {
                uint64_t v74 = v80;
              }
              LODWORD(v73) = *((_DWORD *)v109 + 5);
              if (*v74 != v70) {
                uint64_t v74 = (void *)(v71 + 8 * v76);
              }
            }
            else
            {
              uint64_t v80 = 0;
              int v81 = 1;
              while (v79 != v70)
              {
                if (v80) {
                  BOOL v82 = 0;
                }
                else {
                  BOOL v82 = v79 == -2;
                }
                if (v82) {
                  uint64_t v80 = v74;
                }
                unsigned int v83 = v78 + v81++;
                unsigned int v78 = v83 & v77;
                uint64_t v74 = (void *)(v71 + 8 * (v83 & v77));
                uint64_t v79 = *v74;
                if (*v74 == -1) {
                  goto LABEL_223;
                }
              }
              LODWORD(v73) = *((_DWORD *)v109 + 5);
            }
          }
          unsigned int v84 = *((_DWORD *)v109 + 4);
          if (v71 == v72) {
            unsigned int v84 = v73;
          }
          if (v74 != (void *)(v71 + 8 * v84)) {
            goto LABEL_213;
          }
        }
      }
    }
LABEL_204:
    if ((sub_1CBF5BC2C(v25, v44 >> 5, 44) & 1) == 0)
    {
      uint64_t v85 = *(void *)(v25 + 64);
      if (!v85 || (*(unsigned char *)(v85 + 17) & 0x30) == 0)
      {
        int v86 = *(_DWORD *)(v25 + 20);
        if (v86 < 0)
        {
          uint64_t v97 = v25 - 32 * (v86 & 0x7FFFFFF);
          uint64_t v100 = *(void *)(v97 - 8);
          uint64_t v98 = v97 - 8;
          uint64_t v99 = v100;
          if (v100)
          {
            uint64_t v101 = -v99;
            while (1)
            {
              unsigned int v102 = *(_DWORD *)(*(void *)(v98 + v101) + 8);
              BOOL v94 = v102 > 7;
              int v103 = (1 << v102) & 0x83;
              if (v94 || v103 == 0) {
                break;
              }
              v101 += 16;
              if (!v101) {
                goto LABEL_208;
              }
            }
LABEL_210:
            if ((sub_1CBF5BC2C(v25, v44 >> 5, 45) & 1) == 0 && (sub_1CBF5BC2C(v25, v44 >> 5, 44) & 1) == 0)
            {
              uint64_t v87 = *(void *)(v25 + 64);
              if (!v87 || (*(unsigned char *)(v87 + 20) & 4) == 0)
              {
                if ((__int32 v115 = 7, sub_1CC5CB59C(v25, &v115, 1uLL))
                  && ((uint64_t v105 = *v43) == 0
                   || *(unsigned char *)(v105 + 16)
                   || *(void *)(v105 + 24) != *(void *)(v25 + 72)
                   || *(_DWORD *)(v105 + 36) != 7)
                  || (llvm::CallBase::hasFnAttrOnCalledFunction(v25, 66) & 1) == 0)
                {
                  if ((sub_1CBF5BC2C(v25, v44 >> 5, 66) & 1) == 0) {
                    goto LABEL_3;
                  }
                }
              }
              char v23 = 1;
              goto LABEL_213;
            }
            goto LABEL_212;
          }
        }
LABEL_208:
        if ((llvm::CallBase::hasFnAttrOnCalledFunction(v25, 45) & 1) == 0
          && (llvm::CallBase::hasFnAttrOnCalledFunction(v25, 44) & 1) == 0)
        {
          goto LABEL_210;
        }
      }
LABEL_212:
      char v22 = 1;
    }
LABEL_213:
    unsigned int v21 = v117;
  }
  while (v21);
  if (v23) {
    unsigned int v107 = 66;
  }
  else {
    unsigned int v107 = 44;
  }
  if (v22) {
    unsigned int v107 = 45;
  }
  if (v23 & v22) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v107;
  }
LABEL_268:
  if (v111 != v110) {
    free(v111);
  }
  if (v116 != v118) {
    free(v116);
  }
  return v4;
}

uint64_t sub_1CC90F280(uint64_t a1, int a2)
{
  int hasAttribute = llvm::Argument::hasAttribute(a1, a2);
  if ((hasAttribute & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 24);
    *(void *)(v5 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v5 + 112), **(uint64_t ***)v5, *(_DWORD *)(a1 + 32) + 1, 66);
    uint64_t v6 = *(void *)(a1 + 24);
    *(void *)(v6 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v6 + 112), **(uint64_t ***)v6, *(_DWORD *)(a1 + 32) + 1, 45);
    uint64_t v7 = *(void *)(a1 + 24);
    *(void *)(v7 + 112) = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(v7 + 112), **(uint64_t ***)v7, *(_DWORD *)(a1 + 32) + 1, 44);
    uint64_t v8 = *(void *)(a1 + 24);
    *(void *)(v8 + 112) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v8 + 112), **(uint64_t ***)v8, *(_DWORD *)(a1 + 32) + 1, a2);
  }
  return hasAttribute ^ 1u;
}

void sub_1CC90F34C(void *a1)
{
  *a1 = &unk_1F2627E40;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC90F3C0(uint64_t result)
{
  *(unsigned char *)(result + 8) = 1;
  return result;
}

uint64_t sub_1CC90F3CC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  unsigned int v4 = *(unsigned __int8 *)(v3 + 16);
  if (v4 < 0x1C) {
    goto LABEL_26;
  }
  unsigned int v5 = v4 - 33;
  BOOL v6 = v5 > 0x33;
  uint64_t v7 = (1 << v5) & 0x8000000000041;
  if (v6 || v7 == 0) {
    goto LABEL_26;
  }
  uint64_t v9 = *(void *)(v3 - 32);
  if (!v9 || *(unsigned char *)(v9 + 16) || *(void *)(v9 + 24) != *(void *)(v3 + 72)) {
    goto LABEL_26;
  }
  int v10 = *(_DWORD *)(v9 + 32);
  if (*(void *)(v9 + 72) == v9 + 72 && (v10 & 0x800000) == 0) {
    goto LABEL_26;
  }
  if (((1 << (v10 & 0xF)) & 0x7D5) == 0) {
    goto LABEL_26;
  }
  if (llvm::GlobalValue::isInterposable(*(llvm::GlobalValue **)(v3 - 32))) {
    goto LABEL_26;
  }
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t v25 = 0;
  uint64_t v26 = v9;
  if ((sub_1CC8B6C50(v13, &v26, &v25) & 1) == 0) {
    goto LABEL_26;
  }
  int v14 = *(_DWORD *)(v3 + 20);
  uint64_t v15 = v3 - 32 * (v14 & 0x7FFFFFF);
  unint64_t v16 = (unint64_t)(a2 - v15) >> 5;
  int v17 = *(unsigned __int8 *)(v3 + 16);
  if (v17 == 84) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = v17 == 39 ? (*(_DWORD *)(v3 + 80) + 1) : 2;
  }
  if (v14 < 0 && (uint64_t v24 = *(void *)(v15 - 8), (v24 & 0xFFFFFFFF0) != 0)) {
    int v19 = *(_DWORD *)(v15 - 12) - *(_DWORD *)(v15 - v24);
  }
  else {
    int v19 = 0;
  }
  if (v16 >= ((v3 - 32 * v18 + 32 * (unint64_t)-v19 - v15 - 32) >> 5)
    || *(void *)(v9 + 96) <= (unint64_t)v16)
  {
LABEL_26:
    uint64_t result = 1;
    *(unsigned char *)(a1 + 8) = 1;
  }
  else
  {
    unsigned int v20 = (unint64_t)(a2 - v15) >> 5;
    if (*(_WORD *)(v9 + 18)) {
      llvm::Function::BuildLazyArguments((llvm::Function *)v9);
    }
    uint64_t v21 = *(void *)(v9 + 88) + 40 * v20;
    unsigned int v22 = *(_DWORD *)(a1 + 24);
    if (v22 >= *(_DWORD *)(a1 + 28)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t result = 0;
    *(void *)(*(void *)(a1 + 16) + 8 * v22) = v21;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void sub_1CC90F5AC(int *a1, uint64_t a2)
{
  uint64_t v29 = a2;
  int v4 = *a1 + 1;
  *a1 = v4;
  *(_DWORD *)sub_1CC90FA3C((uint64_t)(a1 + 2), &v29) = v4;
  BOOL v6 = (uint64_t *)*((void *)a1 + 5);
  unint64_t v5 = *((void *)a1 + 6);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = (void *)*((void *)a1 + 4);
    uint64_t v9 = v6 - v8;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_36;
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        goto LABEL_37;
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    int v14 = (uint64_t *)&v13[8 * v9];
    *int v14 = a2;
    uint64_t v7 = v14 + 1;
    if (v6 != v8)
    {
      do
      {
        uint64_t v15 = *--v6;
        *--int v14 = v15;
      }
      while (v6 != v8);
      BOOL v6 = (uint64_t *)*((void *)a1 + 4);
    }
    *((void *)a1 + 4) = v14;
    *((void *)a1 + 5) = v7;
    *((void *)a1 + 6) = &v13[8 * v12];
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    *BOOL v6 = a2;
    uint64_t v7 = v6 + 1;
  }
  *((void *)a1 + 5) = v7;
  uint64_t v16 = v29;
  uint64_t v17 = *(void *)(v29 + 8);
  int v18 = *a1;
  unsigned int v20 = (char *)*((void *)a1 + 11);
  unint64_t v19 = *((void *)a1 + 12);
  if ((unint64_t)v20 < v19)
  {
    *(void *)unsigned int v20 = v29;
    *((void *)v20 + 1) = v17;
    uint64_t v21 = v20 + 24;
    *((_DWORD *)v20 + 4) = v18;
    goto LABEL_35;
  }
  unsigned int v22 = (unsigned char *)*((void *)a1 + 10);
  unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v20 - v22) >> 3) + 1;
  if (v23 > 0xAAAAAAAAAAAAAAALL) {
LABEL_36:
  }
    abort();
  unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - (void)v22) >> 3);
  if (2 * v24 > v23) {
    unint64_t v23 = 2 * v24;
  }
  if (v24 >= 0x555555555555555) {
    unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v25 = v23;
  }
  if (!v25)
  {
    uint64_t v26 = 0;
    goto LABEL_30;
  }
  if (v25 > 0xAAAAAAAAAAAAAAALL) {
LABEL_37:
  }
    sub_1CB833614();
  uint64_t v26 = (char *)operator new(24 * v25);
LABEL_30:
  uint64_t v27 = &v26[8 * ((v20 - v22) >> 3)];
  *(void *)uint64_t v27 = v16;
  *((void *)v27 + 1) = v17;
  *((_DWORD *)v27 + 4) = v18;
  uint64_t v21 = v27 + 24;
  if (v20 != v22)
  {
    do
    {
      long long v28 = *(_OWORD *)(v20 - 24);
      *((_DWORD *)v27 - 2) = *((_DWORD *)v20 - 2);
      *(_OWORD *)(v27 - 24) = v28;
      v27 -= 24;
      v20 -= 24;
    }
    while (v20 != v22);
    unsigned int v20 = (char *)*((void *)a1 + 10);
  }
  *((void *)a1 + 10) = v27;
  *((void *)a1 + 11) = v21;
  *((void *)a1 + 12) = &v26[24 * v25];
  if (v20) {
    operator delete(v20);
  }
LABEL_35:
  *((void *)a1 + 11) = v21;
}

uint64_t sub_1CC90F7C0(uint64_t result)
{
  *(void *)(result + 64) = *(void *)(result + 56);
  uint64_t v2 = *(void *)(result + 80);
  uint64_t v1 = *(void *)(result + 88);
  if (v2 != v1)
  {
    uint64_t v3 = result;
    uint64_t v4 = result + 8;
    while (1)
    {
      uint64_t v5 = *(void *)(v1 - 24);
      BOOL v6 = *(uint64_t **)(v1 - 16);
      if (v6 != (uint64_t *)(*(void *)(v5 + 8) + 8 * *(unsigned int *)(v5 + 16)))
      {
        while (1)
        {
          *(void *)(v1 - 16) = v6 + 1;
          uint64_t v7 = *v6;
          uint64_t v8 = *(void *)(v3 + 8);
          uint64_t v9 = *(unsigned int *)(v3 + 24);
          if (!v9) {
            goto LABEL_10;
          }
          LODWORD(v10) = ((v7 >> 4) ^ (v7 >> 9)) & (v9 - 1);
          uint64_t v11 = (uint64_t *)(v8 + 16 * v10);
          uint64_t v12 = *v11;
          if (*v11 != v7) {
            break;
          }
LABEL_11:
          if (v11 == (uint64_t *)(v8 + 16 * v9))
          {
            sub_1CC90F5AC((int *)v3, v7);
            uint64_t v1 = *(void *)(v3 + 88);
          }
          else
          {
            unsigned int v15 = *((_DWORD *)v11 + 2);
            if (*(_DWORD *)(v1 - 8) > v15) {
              *(_DWORD *)(v1 - 8) = v15;
            }
          }
          uint64_t v5 = *(void *)(v1 - 24);
          BOOL v6 = *(uint64_t **)(v1 - 16);
          if (v6 == (uint64_t *)(*(void *)(v5 + 8) + 8 * *(unsigned int *)(v5 + 16)))
          {
            uint64_t v2 = *(void *)(v3 + 80);
            goto LABEL_17;
          }
        }
        int v13 = 1;
        while (v12 != -4096)
        {
          int v14 = v10 + v13++;
          uint64_t v10 = v14 & (v9 - 1);
          uint64_t v12 = *(void *)(v8 + 16 * v10);
          if (v12 == v7)
          {
            uint64_t v11 = (uint64_t *)(v8 + 16 * v10);
            goto LABEL_11;
          }
        }
LABEL_10:
        uint64_t v11 = (uint64_t *)(v8 + 16 * v9);
        goto LABEL_11;
      }
LABEL_17:
      uint64_t v29 = v5;
      unsigned int v16 = *(_DWORD *)(v1 - 8);
      *(void *)(v3 + 88) = v1 - 24;
      if (v2 != v1 - 24 && *(_DWORD *)(v1 - 32) > v16) {
        *(_DWORD *)(v1 - 32) = v16;
      }
      uint64_t result = sub_1CC90FA3C(v4, &v29);
      if (v16 == *(_DWORD *)result) {
        break;
      }
      uint64_t v2 = *(void *)(v3 + 80);
      uint64_t v1 = *(void *)(v3 + 88);
      if (v2 == v1) {
        return result;
      }
    }
    uint64_t v17 = *(void **)(v3 + 64);
    do
    {
      uint64_t v18 = *(void *)(v3 + 40);
      unint64_t v19 = *(void *)(v3 + 72);
      if ((unint64_t)v17 >= v19)
      {
        uint64_t v21 = *(void **)(v3 + 56);
        uint64_t v22 = v17 - v21;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 61) {
          abort();
        }
        uint64_t v24 = v19 - (void)v21;
        if (v24 >> 2 > v23) {
          unint64_t v23 = v24 >> 2;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25)
        {
          if (v25 >> 61) {
            sub_1CB833614();
          }
          uint64_t v26 = (char *)operator new(8 * v25);
        }
        else
        {
          uint64_t v26 = 0;
        }
        uint64_t v27 = &v26[8 * v22];
        *(void *)uint64_t v27 = *(void *)(v18 - 8);
        unsigned int v20 = v27 + 8;
        if (v17 != v21)
        {
          do
          {
            uint64_t v28 = *--v17;
            *((void *)v27 - 1) = v28;
            v27 -= 8;
          }
          while (v17 != v21);
          uint64_t v17 = *(void **)(v3 + 56);
        }
        *(void *)(v3 + 56) = v27;
        *(void *)(v3 + 64) = v20;
        *(void *)(v3 + 72) = &v26[8 * v25];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *uint64_t v17 = *(void *)(v18 - 8);
        unsigned int v20 = v17 + 1;
      }
      *(void *)(v3 + 64) = v20;
      *(void *)(v3 + 40) -= 8;
      uint64_t result = sub_1CC90FA3C(v4, v20 - 1);
      *(_DWORD *)uint64_t result = -1;
      uint64_t v17 = *(void **)(v3 + 64);
    }
    while (*(v17 - 1) != v29);
  }
  return result;
}

uint64_t sub_1CC90FA3C(uint64_t a1, uint64_t *a2)
{
  uint64_t v24 = 0;
  char v4 = sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v24);
  uint64_t v5 = v24;
  if (v4) {
    return v5 + 8;
  }
  uint64_t v25 = v24;
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(unsigned int *)(a1 + 16);
  if (4 * v6 + 4 >= (3 * v7))
  {
    int v8 = 2 * v7;
    goto LABEL_9;
  }
  int v8 = *(_DWORD *)(a1 + 16);
  if ((int)v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_9:
    uint64_t v10 = *(void *)a1;
    unint64_t v11 = (v8 - 1) | ((unint64_t)(v8 - 1) >> 1);
    unint64_t v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
    int v13 = ((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8);
    if ((v13 + 1) > 0x40) {
      unsigned int v14 = v13 + 1;
    }
    else {
      unsigned int v14 = 64;
    }
    *(_DWORD *)(a1 + 16) = v14;
    unsigned int v15 = operator new(16 * v14, (std::align_val_t)8uLL);
    *(void *)a1 = v15;
    if (v10)
    {
      *(void *)(a1 + 8) = 0;
      uint64_t v16 = *(unsigned int *)(a1 + 16);
      if (v16)
      {
        uint64_t v17 = 16 * v16;
        do
        {
          void *v15 = -4096;
          v15 += 2;
          v17 -= 16;
        }
        while (v17);
      }
      if (v7)
      {
        uint64_t v18 = (_DWORD *)(v10 + 8);
        uint64_t v19 = 16 * v7;
        do
        {
          uint64_t v20 = *((void *)v18 - 1);
          if ((v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            uint64_t v26 = 0;
            sub_1CBB0BF40(*(void *)a1, *(_DWORD *)(a1 + 16), v20, &v26);
            uint64_t v21 = v26;
            *uint64_t v26 = v20;
            *((_DWORD *)v21 + 2) = *v18;
            ++*(_DWORD *)(a1 + 8);
          }
          v18 += 4;
          v19 -= 16;
        }
        while (v19);
      }
      MEMORY[0x1D25D9CD0](v10, 8);
      unsigned int v15 = *(void **)a1;
      LODWORD(v22) = *(_DWORD *)(a1 + 16);
    }
    else
    {
      *(void *)(a1 + 8) = 0;
      uint64_t v22 = *(unsigned int *)(a1 + 16);
      if (v22)
      {
        uint64_t v23 = 0;
        do
        {
          v15[v23] = -4096;
          v23 += 2;
        }
        while (2 * v22 != v23);
      }
    }
    sub_1CBB0BF40((uint64_t)v15, v22, *a2, &v25);
    int v6 = *(_DWORD *)(a1 + 8);
    uint64_t v5 = v25;
  }
  *(_DWORD *)(a1 + 8) = v6 + 1;
  if (*(void *)v5 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)uint64_t v5 = *a2;
  *(_DWORD *)(v5 + 8) = 0;
  return v5 + 8;
}

void sub_1CC90FC24(void *a1)
{
  if (a1)
  {
    sub_1CC90FC24(*a1);
    sub_1CC90FC24(a1[1]);
    uint64_t v2 = (void *)a1[6];
    if (v2 != a1 + 8) {
      free(v2);
    }
    operator delete(a1);
  }
}

void sub_1CC90FC84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v90 = a2;
  int v4 = 0;
  v100[52] = *MEMORY[0x1E4F143B8];
  uint64_t v89 = (char *)v100;
  uint64_t v98 = v100;
  uint64_t v99 = 0x400000000;
  if (&v98 != (void **)a1)
  {
    unint64_t v6 = *(unsigned int *)(a1 + 8);
    if (v6)
    {
      if (v6 <= 4)
      {
        uint64_t v9 = *(unsigned char **)a1;
        uint64_t v10 = *(void *)a1 + 104 * v6;
        int v8 = v89;
      }
      else
      {
        sub_1CC91087C((uint64_t)&v98, v6);
        unsigned int v7 = *(_DWORD *)(a1 + 8);
        if (!v7)
        {
LABEL_9:
          LODWORD(v99) = v6;
          int v4 = v6;
          goto LABEL_10;
        }
        int v8 = (char *)v98;
        uint64_t v9 = *(unsigned char **)a1;
        uint64_t v10 = *(void *)a1 + 104 * v7;
      }
      uint64_t v11 = 0;
      do
      {
        unint64_t v12 = &v8[v11];
        sub_1CB93141C((uint64_t)&v8[v11], (uint64_t)&v9[v11]);
        sub_1CC53A1FC((uint64_t)&v8[v11 + 32], (uint64_t)&v9[v11 + 32]);
        sub_1CC6D8CE4((uint64_t)&v8[v11 + 64], (uint64_t)&v9[v11 + 64]);
        int v13 = *(_DWORD *)&v9[v11 + 96];
        v12[100] = v9[v11 + 100];
        *((_DWORD *)v12 + 24) = v13;
        v11 += 104;
      }
      while (&v9[v11] != (unsigned char *)v10);
      goto LABEL_9;
    }
  }
LABEL_10:
  uint64_t v14 = *(unsigned int *)(v90 + 80);
  if (v14)
  {
    unsigned int v15 = *(void **)(v90 + 72);
    unsigned int v93 = &v15[v14];
    uint64_t v16 = v97;
    uint64_t v91 = v97;
    while (1)
    {
      unsigned int v17 = v99;
      uint64_t v18 = (char *)v98;
      if (!v99) {
        goto LABEL_178;
      }
      uint64_t v19 = 0;
      uint64_t v20 = *v15;
      uint64_t v21 = (char *)v98 + 104 * v99;
      uint64_t v22 = 104 * v99;
      uint64_t v23 = (void *)(*v15 + 72);
      while (1)
      {
        uint64_t v24 = *(void *)&v18[v19 + 24];
        if (!v24) {
LABEL_181:
        }
          sub_1CB920400();
        if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v24 + 48))(v24, v20)) {
          goto LABEL_24;
        }
        if (v20 && *(unsigned char *)(v20 + 16) == 3)
        {
          if ((*(_DWORD *)(v20 + 20) & 0x7FFFFFF) == 0) {
            break;
          }
LABEL_21:
          if (!v18[v19 + 100]) {
            goto LABEL_24;
          }
          goto LABEL_22;
        }
        if (*(unsigned char *)(v20 + 16)) {
          goto LABEL_21;
        }
        if ((void *)*v23 == v23 && (*(unsigned char *)(v20 + 34) & 0x80) == 0) {
          break;
        }
        if (!v18[v19 + 100]) {
          goto LABEL_24;
        }
        if ((void *)*v23 == v23 && (*(unsigned char *)(v20 + 34) & 0x80) == 0) {
          break;
        }
LABEL_22:
        if (((1 << (*(_DWORD *)(v20 + 32) & 0xF)) & 0x7D5) == 0
          || (llvm::GlobalValue::isInterposable((llvm::GlobalValue *)v20) & 1) != 0)
        {
          break;
        }
LABEL_24:
        v19 += 104;
        if (v22 == v19) {
          goto LABEL_53;
        }
      }
      uint64_t v21 = &v18[v19];
      if (104 * v17 - 104 != v19) {
        break;
      }
LABEL_53:
      sub_1CC9112BC((uint64_t *)&v98, (uint64_t)v21, (uint64_t)v98 + 104 * v99);
      int v95 = v16;
      uint64_t v96 = 0x400000000;
      if (v99)
      {
        uint64_t v28 = v98;
        uint64_t v29 = 104 * v99;
        do
        {
          uint64_t v30 = v28[3];
          if (!v30) {
            goto LABEL_181;
          }
          if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v30 + 48))(v30, v20) & 1) == 0) {
            sub_1CC9107B4((uint64_t)&v95, (unint64_t)v28);
          }
          v28 += 13;
          v29 -= 104;
        }
        while (v29);
        uint64_t v31 = v96;
        if (v96)
        {
          uint64_t v32 = *(void **)(v20 + 80);
          if (v32 != v23)
          {
            uint64_t v33 = v32 - 3;
            if (!v32) {
              uint64_t v33 = 0;
            }
            unsigned int v34 = (void *)v33[6];
            if (v34 == v33 + 5)
            {
              while (1)
              {
                uint64_t v32 = (void *)v32[1];
                if (v32 == v23) {
                  break;
                }
                unsigned int v35 = v32 - 3;
                if (!v32) {
                  unsigned int v35 = 0;
                }
                unsigned int v34 = (void *)v35[6];
                if (v34 != v35 + 5) {
                  goto LABEL_68;
                }
              }
            }
            else
            {
LABEL_68:
              uint64_t v92 = v15;
              while (1)
              {
                long long v36 = v34 - 3;
                if (!v34) {
                  long long v36 = 0;
                }
                uint64_t v37 = (char *)v95;
                uint64_t v38 = 104 * v31;
                int v39 = (char *)v95 + 104 * v31;
                v94[0] = v36;
                v94[1] = &v98;
                while (!sub_1CC9116D8(v94, (uint64_t)v37))
                {
                  v37 += 104;
                  v38 -= 104;
                  if (!v38) {
                    goto LABEL_82;
                  }
                }
                uint64_t v40 = v38 - 104;
                if (v40)
                {
                  uint64_t v41 = 0;
                  int v39 = v37;
                  do
                  {
                    long long v42 = &v37[v41];
                    if ((sub_1CC9116D8(v94, (uint64_t)&v37[v41 + 104]) & 1) == 0)
                    {
                      sub_1CC911518(v39, (uint64_t)&v37[v41 + 104]);
                      sub_1CC9115F8((void *)v39 + 4, (uint64_t)(v42 + 136));
                      sub_1CC6DA560((void *)v39 + 8, (uint64_t)(v42 + 168));
                      char v43 = v42[204];
                      *((_DWORD *)v39 + 24) = *((_DWORD *)v42 + 50);
                      v39[100] = v43;
                      v39 += 104;
                    }
                    v41 += 104;
                  }
                  while (v40 != v41);
                }
                else
                {
                  int v39 = v37;
                }
LABEL_82:
                sub_1CC9112BC((uint64_t *)&v95, (uint64_t)v39, (uint64_t)v95 + 104 * v96);
                uint64_t v31 = v96;
                if (!v96)
                {
                  uint64_t v16 = v91;
                  unsigned int v15 = v92;
                  goto LABEL_107;
                }
                unsigned int v34 = (void *)v34[1];
                unint64_t v44 = v32 - 3;
                if (!v32) {
                  unint64_t v44 = 0;
                }
                uint64_t v16 = v91;
                unsigned int v15 = v92;
                if (v34 == v44 + 5) {
                  break;
                }
LABEL_90:
                if (v32 == v23) {
                  goto LABEL_93;
                }
              }
              while (1)
              {
                uint64_t v32 = (void *)v32[1];
                if (v32 == v23) {
                  break;
                }
                uint64_t v45 = v32 - 3;
                if (!v32) {
                  uint64_t v45 = 0;
                }
                unsigned int v34 = (void *)v45[6];
                if (v34 != v45 + 5) {
                  goto LABEL_90;
                }
              }
            }
          }
LABEL_93:
          uint64_t v46 = 0;
          uint64_t v47 = (char *)v95;
          uint64_t v48 = 104 * v31;
          uint64_t v49 = (char *)v95;
          do
          {
            unsigned int v50 = &v49[v48];
            uint64_t v51 = (uint64_t)&v49[v48 - 40];
            uint64_t v52 = *(void *)&v49[v48 - 16];
            if (v51 == v52)
            {
              (*(void (**)(uint64_t))(*(void *)v51 + 32))(v51);
            }
            else if (v52)
            {
              (*(void (**)(void))(*(void *)v52 + 40))(*(void *)&v49[v48 - 16]);
            }
            uint64_t v53 = (uint64_t)&v49[v48 - 72];
            uint64_t v54 = *(void *)&v49[v48 - 48];
            if (v53 == v54)
            {
              (*(void (**)(uint64_t))(*(void *)v53 + 32))(v53);
            }
            else if (v54)
            {
              (*(void (**)(void))(*(void *)v54 + 40))(*(void *)&v49[v48 - 48]);
            }
            unsigned int v55 = *(char **)&v49[v48 - 80];
            if (v50 - 104 == v55)
            {
              (*(void (**)(char *))(*((void *)v50 - 13) + 32))(v50 - 104);
            }
            else if (v55)
            {
              (*(void (**)(void))(*(void *)v55 + 40))(*(void *)&v49[v48 - 80]);
            }
            v46 += 104;
            v49 -= 104;
            v47 -= 104;
          }
          while (v48 != v46);
        }
      }
LABEL_107:
      if (v95 != v16) {
        free(v95);
      }
      if (++v15 == v93)
      {
        int v4 = v99;
        goto LABEL_112;
      }
    }
    uint64_t v25 = 104 * v17 - 104;
    while (1)
    {
      uint64_t v26 = *(void *)&v18[v19 + 128];
      if (!v26) {
        goto LABEL_181;
      }
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v26 + 48))(v26, v20)) {
        goto LABEL_35;
      }
      if (v20 && *(unsigned char *)(v20 + 16) == 3) {
        break;
      }
      if (*(unsigned char *)(v20 + 16)) {
        goto LABEL_43;
      }
      if ((void *)*v23 == v23 && (*(unsigned char *)(v20 + 34) & 0x80) == 0) {
        goto LABEL_36;
      }
      if (v18[v19 + 204])
      {
        if ((void *)*v23 == v23 && (*(unsigned char *)(v20 + 34) & 0x80) == 0) {
          goto LABEL_36;
        }
LABEL_44:
        if (((1 << (*(_DWORD *)(v20 + 32) & 0xF)) & 0x7D5) == 0
          || (llvm::GlobalValue::isInterposable((llvm::GlobalValue *)v20) & 1) != 0)
        {
          goto LABEL_36;
        }
      }
LABEL_35:
      sub_1CC911518(v21, (uint64_t)&v18[v19 + 104]);
      sub_1CC9115F8((void *)v21 + 4, (uint64_t)&v18[v19 + 136]);
      sub_1CC6DA560((void *)v21 + 8, (uint64_t)&v18[v19 + 168]);
      char v27 = v18[v19 + 204];
      *((_DWORD *)v21 + 24) = *(_DWORD *)&v18[v19 + 200];
      v21[100] = v27;
      v21 += 104;
LABEL_36:
      v19 += 104;
      if (v25 == v19) {
        goto LABEL_53;
      }
    }
    if ((*(_DWORD *)(v20 + 20) & 0x7FFFFFF) == 0) {
      goto LABEL_36;
    }
LABEL_43:
    if (v18[v19 + 204]) {
      goto LABEL_44;
    }
    goto LABEL_35;
  }
LABEL_112:
  if (v4)
  {
    uint64_t v56 = *(unsigned int *)(v90 + 80);
    if (v56)
    {
      uint64_t v57 = *(uint64_t **)(v90 + 72);
      unsigned int v58 = &v57[v56];
      while (!v99)
      {
LABEL_161:
        if (++v57 == v58) {
          goto LABEL_162;
        }
      }
      uint64_t v59 = *v57;
      BOOL v60 = (char *)v98;
      unsigned int v61 = (char *)v98 + 104 * v99;
      unsigned int v62 = (*v57 >> 4) ^ (*v57 >> 9);
      while (1)
      {
        uint64_t v63 = *((void *)v60 + 3);
        if (!v63) {
          goto LABEL_181;
        }
        if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v63 + 48))(v63, v59) & 1) == 0) {
          break;
        }
LABEL_153:
        v60 += 104;
        if (v60 == v61) {
          goto LABEL_161;
        }
      }
      uint64_t v64 = *(void *)(a3 + 8);
      uint64_t v65 = *(unsigned int *)(a3 + 20);
      if (v64 == *(void *)a3)
      {
        if (v65)
        {
          unint64_t v66 = 0;
          uint64_t v67 = 8 * v65;
          uint64_t v68 = *(void **)(a3 + 8);
          while (*v68 != v59)
          {
            if (*v68 == -2) {
              unint64_t v66 = v68;
            }
            ++v68;
            v67 -= 8;
            if (!v67)
            {
              if (!v66) {
                goto LABEL_127;
              }
              *unint64_t v66 = v59;
              --*(_DWORD *)(a3 + 24);
              goto LABEL_151;
            }
          }
          goto LABEL_151;
        }
LABEL_127:
        unsigned int v69 = *(_DWORD *)(a3 + 16);
        if (v65 < v69)
        {
          *(_DWORD *)(a3 + 20) = v65 + 1;
          *(void *)(v64 + 8 * v65) = v59;
LABEL_151:
          uint64_t v79 = *((void *)v60 + 11);
          if (!v79) {
            goto LABEL_181;
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v79 + 48))(v79, v59);
          goto LABEL_153;
        }
      }
      else
      {
        unsigned int v69 = *(_DWORD *)(a3 + 16);
      }
      if (3 * v69 <= 4 * ((int)v65 - *(_DWORD *)(a3 + 24)))
      {
        if (v69 >= 0x40) {
          v69 *= 2;
        }
        else {
          unsigned int v69 = 128;
        }
      }
      else if (v69 - v65 >= v69 >> 3)
      {
        goto LABEL_132;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a3, v69);
      unsigned int v69 = *(_DWORD *)(a3 + 16);
      uint64_t v64 = *(void *)(a3 + 8);
LABEL_132:
      unsigned int v70 = v69 - 1;
      unsigned int v71 = (v69 - 1) & v62;
      uint64_t v72 = (void *)(v64 + 8 * v71);
      uint64_t v73 = *v72;
      if (*v72 == -1)
      {
        uint64_t v74 = 0;
LABEL_144:
        if (v74) {
          unsigned int v78 = v74;
        }
        else {
          unsigned int v78 = v72;
        }
        if (*v78 != v59)
        {
          if (*v78 == -2) {
            --*(_DWORD *)(a3 + 24);
          }
          else {
            ++*(_DWORD *)(a3 + 20);
          }
          *unsigned int v78 = v59;
        }
      }
      else
      {
        uint64_t v74 = 0;
        int v75 = 1;
        while (v73 != v59)
        {
          if (v74) {
            BOOL v76 = 0;
          }
          else {
            BOOL v76 = v73 == -2;
          }
          if (v76) {
            uint64_t v74 = v72;
          }
          unsigned int v77 = v71 + v75++;
          unsigned int v71 = v77 & v70;
          uint64_t v72 = (void *)(v64 + 8 * (v77 & v70));
          uint64_t v73 = *v72;
          if (*v72 == -1) {
            goto LABEL_144;
          }
        }
      }
      goto LABEL_151;
    }
  }
LABEL_162:
  uint64_t v18 = (char *)v98;
  if (v99)
  {
    uint64_t v80 = 0;
    uint64_t v81 = 104 * v99;
    BOOL v82 = (char *)v98;
    do
    {
      unsigned int v83 = &v18[v81];
      uint64_t v84 = (uint64_t)&v18[v81 - 40];
      uint64_t v85 = *(void *)&v18[v81 - 16];
      if (v84 == v85)
      {
        (*(void (**)(uint64_t))(*(void *)v84 + 32))(v84);
      }
      else if (v85)
      {
        (*(void (**)(void))(*(void *)v85 + 40))(*(void *)&v18[v81 - 16]);
      }
      uint64_t v86 = (uint64_t)&v18[v81 - 72];
      uint64_t v87 = *(void *)&v18[v81 - 48];
      if (v86 == v87)
      {
        (*(void (**)(uint64_t))(*(void *)v86 + 32))(v86);
      }
      else if (v87)
      {
        (*(void (**)(void))(*(void *)v87 + 40))(*(void *)&v18[v81 - 48]);
      }
      uint64_t v88 = *(char **)&v18[v81 - 80];
      if (v83 - 104 == v88)
      {
        (*(void (**)(char *))(*((void *)v83 - 13) + 32))(v83 - 104);
      }
      else if (v88)
      {
        (*(void (**)(void))(*(void *)v88 + 40))(*(void *)&v18[v81 - 80]);
      }
      v80 += 104;
      v18 -= 104;
      v82 -= 104;
    }
    while (v81 != v80);
    uint64_t v18 = (char *)v98;
  }
LABEL_178:
  if (v18 != v89) {
    free(v18);
  }
}

uint64_t sub_1CC9107B4(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v9 = v4 + 1;
    unint64_t v10 = v5 + 104 * v4;
    if (v5 <= a2 && v10 > a2)
    {
      unint64_t v12 = a2 - v5;
      sub_1CC91087C(a1, v9);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v12;
    }
    else
    {
      sub_1CC91087C(a1, v9);
      unint64_t v5 = *(void *)a1;
    }
  }
  uint64_t v6 = v5 + 104 * *(unsigned int *)(a1 + 8);
  sub_1CB93141C(v6, a2);
  sub_1CC53A1FC(v6 + 32, a2 + 32);
  uint64_t result = sub_1CC6D8CE4(v6 + 64, a2 + 64);
  int v8 = *(_DWORD *)(a2 + 96);
  *(unsigned char *)(v6 + 100) = *(unsigned char *)(a2 + 100);
  *(_DWORD *)(v6 + 96) = v8;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CC91087C(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = (char *)malloc_type_malloc(104 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unsigned int v7 = v6;
  int v8 = *(unsigned char **)a1;
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  if (v9)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 104 * v9;
    do
    {
      unint64_t v12 = &v8[v10];
      int v13 = &v7[v10];
      uint64_t v14 = *(char **)&v8[v10 + 24];
      if (v14)
      {
        if (v12 == v14)
        {
          *((void *)v13 + 3) = v13;
          (*(void (**)(void))(**((void **)v12 + 3) + 24))(*((void *)v12 + 3));
        }
        else
        {
          *((void *)v13 + 3) = v14;
          *((void *)v12 + 3) = 0;
        }
      }
      else
      {
        *((void *)v13 + 3) = 0;
      }
      unsigned int v15 = &v7[v10];
      uint64_t v16 = &v8[v10];
      unsigned int v17 = *(char **)&v8[v10 + 56];
      if (v17)
      {
        if (v16 + 32 == v17)
        {
          *((void *)v15 + 7) = v15 + 32;
          (*(void (**)(void))(**((void **)v16 + 7) + 24))(*((void *)v16 + 7));
        }
        else
        {
          *((void *)v15 + 7) = v17;
          *((void *)v16 + 7) = 0;
        }
      }
      else
      {
        *((void *)v15 + 7) = 0;
      }
      uint64_t v18 = &v7[v10];
      uint64_t v19 = &v8[v10];
      uint64_t v20 = *(char **)&v8[v10 + 88];
      if (v20)
      {
        if (v19 + 64 == v20)
        {
          *((void *)v18 + 11) = v18 + 64;
          (*(void (**)(void))(**((void **)v19 + 11) + 24))(*((void *)v19 + 11));
        }
        else
        {
          *((void *)v18 + 11) = v20;
          *((void *)v19 + 11) = 0;
        }
      }
      else
      {
        *((void *)v18 + 11) = 0;
      }
      uint64_t v21 = &v7[v10];
      int v22 = *(_DWORD *)&v8[v10 + 96];
      v21[100] = v8[v10 + 100];
      *((_DWORD *)v21 + 24) = v22;
      v10 += 104;
    }
    while (v11 != v10);
    int v8 = *(unsigned char **)a1;
    unsigned int v23 = *(_DWORD *)(a1 + 8);
    if (v23)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 104 * v23;
      uint64_t v26 = *(unsigned char **)a1;
      do
      {
        char v27 = &v8[v25];
        uint64_t v28 = (uint64_t)&v8[v25 - 40];
        uint64_t v29 = *(void *)&v8[v25 - 16];
        if (v28 == v29)
        {
          (*(void (**)(uint64_t))(*(void *)v28 + 32))(v28);
        }
        else if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 40))(*(void *)&v8[v25 - 16]);
        }
        uint64_t v30 = (uint64_t)&v8[v25 - 72];
        uint64_t v31 = *(void *)&v8[v25 - 48];
        if (v30 == v31)
        {
          (*(void (**)(uint64_t))(*(void *)v30 + 32))(v30);
        }
        else if (v31)
        {
          (*(void (**)(void))(*(void *)v31 + 40))(*(void *)&v8[v25 - 48]);
        }
        uint64_t v32 = *(char **)&v8[v25 - 80];
        if (v27 - 104 == v32)
        {
          (*(void (**)(char *))(*((void *)v27 - 13) + 32))(v27 - 104);
        }
        else if (v32)
        {
          (*(void (**)(void))(*(void *)v32 + 40))(*(void *)&v8[v25 - 80]);
        }
        v24 += 104;
        v8 -= 104;
        v26 -= 104;
      }
      while (v25 != v24);
      int v8 = *(unsigned char **)a1;
    }
  }
  if (v8 != (unsigned char *)(a1 + 16)) {
    free(v8);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CC910C18()
{
}

void *sub_1CC910C2C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2627E80;
  return result;
}

void sub_1CC910C64(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2627E80;
}

BOOL sub_1CC910C8C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  return !v2 || (*(unsigned char *)(v2 + 12) & 0x40) == 0;
}

void *sub_1CC910CAC(_DWORD *a1, _DWORD *a2)
{
  int v2 = *a1;
  if ((*a1 & 1) == 0)
  {
    int v13 = a2;
    uint64_t v14 = a1;
    MEMORY[0x1D25D9CD0](*((void *)a1 + 1), 8);
    a2 = v13;
    a1 = v14;
    int v2 = *v14;
  }
  *a1 = v2 | 1;
  if ((*a2 & 1) != 0 || a2[4] <= 8u)
  {
    int v3 = 0;
    *a1 = *a2 | 1;
    a1[1] = a2[1];
    unint64_t v4 = a1 + 2;
  }
  else
  {
    *a1 = v2 & 0xFFFFFFFE;
    if (*a2) {
      uint64_t v9 = 8;
    }
    else {
      uint64_t v9 = a2[4];
    }
    uint64_t v10 = a1;
    uint64_t v11 = a2;
    *((void *)a1 + 1) = operator new(8 * v9, (std::align_val_t)8uLL);
    unint64_t v4 = v10 + 2;
    *((void *)v10 + 2) = v9;
    unsigned int v12 = *v10;
    *uint64_t v10 = *v11 & 0xFFFFFFFE | *v10 & 1;
    a2 = v11;
    a1 = v10;
    v10[1] = v11[1];
    if (v12)
    {
      int v3 = 0;
    }
    else
    {
      unint64_t v4 = (void *)*v4;
      int v3 = 1;
    }
  }
  char v6 = *(unsigned char *)a2;
  uint64_t v5 = a2 + 2;
  if ((v6 & 1) == 0) {
    uint64_t v5 = (void *)*v5;
  }
  if (v3) {
    size_t v7 = 8 * a1[4];
  }
  else {
    size_t v7 = 64;
  }

  return memcpy(v4, v5, v7);
}

uint64_t sub_1CC910DE4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2627EC8;
  int v2 = *(void **)(a1 + 80);
  if (v2 != (void *)(a1 + 96)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 8) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 16), 8);
  }
  return a1;
}

void sub_1CC910E50(uint64_t a1)
{
  *(void *)a1 = &unk_1F2627EC8;
  int v2 = *(void **)(a1 + 80);
  if (v2 != (void *)(a1 + 96)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 8) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 16), 8);
  }

  JUMPOUT(0x1D25D9CE0);
}

int64x2_t *sub_1CC910EDC(uint64_t a1)
{
  int v2 = (int64x2_t *)operator new(0xA0uLL);
  v2->i64[1] = 1;
  int64x2_t v3 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  v2->i64[0] = (uint64_t)&unk_1F2627EC8;
  v2[1] = v3;
  v2[2] = v3;
  v2[3] = v3;
  v2[4] = v3;
  sub_1CC910CAC(&v2->i32[2], (_DWORD *)(a1 + 8));
  v2[5].i64[0] = (uint64_t)v2[6].i64;
  v2[5].i64[1] = 0x800000000;
  if (*(_DWORD *)(a1 + 88)) {
    sub_1CD4C0D94((uint64_t)v2[5].i64, a1 + 80);
  }
  return v2;
}

void *sub_1CC910F74(uint64_t a1, int64x2_t *a2)
{
  a2->i64[1] = 1;
  int64x2_t v4 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  a2->i64[0] = (uint64_t)&unk_1F2627EC8;
  a2[1] = v4;
  a2[2] = v4;
  a2[3] = v4;
  a2[4] = v4;
  uint64_t result = sub_1CC910CAC(&a2->i32[2], (_DWORD *)(a1 + 8));
  a2[5].i64[0] = (uint64_t)a2[6].i64;
  uint64_t i64 = (uint64_t)a2[5].i64;
  *(void *)(i64 + 8) = 0x800000000;
  if (*(_DWORD *)(a1 + 88))
  {
    return (void *)sub_1CD4C0D94(i64, a1 + 80);
  }
  return result;
}

void sub_1CC91101C(uint64_t a1)
{
  int v2 = *(void **)(a1 + 80);
  if (v2 != (void *)(a1 + 96)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 8) & 1) == 0)
  {
    JUMPOUT(0x1D25D9CD0);
  }
}

void sub_1CC91107C(void *__p)
{
  int v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  if ((__p[1] & 1) == 0) {
    MEMORY[0x1D25D9CD0](__p[2], 8);
  }

  operator delete(__p);
}

uint64_t sub_1CC9110DC(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 16) - 33;
  BOOL v3 = v2 > 0x33;
  uint64_t v4 = (1 << v2) & 0x8000000000041;
  if (v3 || v4 == 0) {
    return 0;
  }
  uint64_t v8 = *(void *)(a2 + 64);
  if (v8 && (*(unsigned char *)(v8 + 12) & 0x40) != 0
    || (uint64_t result = llvm::CallBase::hasFnAttrOnCalledFunction(a2, 6), result))
  {
    uint64_t v10 = *(void *)(a2 - 32);
    if (!v10 || *(unsigned char *)(v10 + 16) || *(void *)(v10 + 24) != *(void *)(a2 + 72)) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = sub_1CC9111A4(a1 + 8, v10);
    if (*(unsigned char *)(a1 + 8))
    {
      uint64_t v12 = a1 + 16;
      uint64_t v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 16);
      uint64_t v13 = *(unsigned int *)(a1 + 24);
    }
    return v12 + 8 * v13 == v11;
  }
  return result;
}

uint64_t sub_1CC9111A4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  if (sub_1CC8B6C50(a1, &v7, &v6)) {
    return v6;
  }
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    uint64_t v4 = 8;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = *(unsigned int *)(a1 + 16);
  }
  return v3 + 8 * v4;
}

void sub_1CC91120C()
{
}

void *sub_1CC911220()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2627F10;
  return result;
}

void sub_1CC911258(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2627F10;
}

uint64_t sub_1CC911280(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(a2 + 112), **(uint64_t ***)a2, -1, 6);
  *(void *)(a2 + 112) = result;
  return result;
}

uint64_t sub_1CC9112BC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  unsigned int v6 = *((_DWORD *)a1 + 2);
  uint64_t v7 = *a1 + 104 * v6;
  if (v7 == a3)
  {
    uint64_t v12 = a2;
  }
  else
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = a2 + v9;
      sub_1CC911518((void *)(a2 + v9), a3 + v9);
      sub_1CC9115F8((void *)(a2 + v9 + 32), a3 + v9 + 32);
      sub_1CC6DA560((void *)(a2 + v9 + 64), a3 + v9 + 64);
      char v11 = *(unsigned char *)(a3 + v9 + 100);
      *(_DWORD *)(v10 + 96) = *(_DWORD *)(a3 + v9 + 96);
      *(unsigned char *)(v10 + 100) = v11;
      v9 += 104;
    }
    while (a3 + v9 != v7);
    uint64_t v5 = *a1;
    unsigned int v6 = *((_DWORD *)a1 + 2);
    uint64_t v12 = a2 + v9;
  }
  if (v5 + 104 * v6 != v12)
  {
    uint64_t v13 = 104 * v6;
    uint64_t v14 = v5;
    do
    {
      uint64_t v15 = v5 + v13;
      uint64_t v16 = v5 + v13 - 40;
      uint64_t v17 = *(void *)(v5 + v13 - 16);
      if (v16 == v17)
      {
        (*(void (**)(uint64_t))(*(void *)v16 + 32))(v16);
      }
      else if (v17)
      {
        (*(void (**)(void))(*(void *)v17 + 40))(*(void *)(v5 + v13 - 16));
      }
      uint64_t v18 = v5 + v13 - 72;
      uint64_t v19 = *(void *)(v5 + v13 - 48);
      if (v18 == v19)
      {
        (*(void (**)(uint64_t))(*(void *)v18 + 32))(v18);
      }
      else if (v19)
      {
        (*(void (**)(void))(*(void *)v19 + 40))(*(void *)(v5 + v13 - 48));
      }
      uint64_t v20 = *(void *)(v5 + v13 - 80);
      if (v15 - 104 == v20)
      {
        (*(void (**)(uint64_t))(*(void *)(v15 - 104) + 32))(v15 - 104);
      }
      else if (v20)
      {
        (*(void (**)(void))(*(void *)v20 + 40))(*(void *)(v5 + v13 - 80));
      }
      v5 -= 104;
      v14 -= 104;
    }
    while (v5 + v13 != v12);
    uint64_t v5 = *a1;
  }
  *((_DWORD *)a1 + 2) = -991146299 * ((unint64_t)(v12 - v5) >> 3);
  return a2;
}

void *sub_1CC911518(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v5;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *sub_1CC9115F8(void *a1, uint64_t a2)
{
  uint64_t v4 = (void *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5)
  {
    if (v5 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v5;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

uint64_t sub_1CC9116D8(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 56);
  if (v3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 48))(v3, *a1);
    if (v5)
    {
      uint64_t v6 = a1[1];
      uint64_t v7 = *(void *)v6;
      unsigned int v8 = *(_DWORD *)(v6 + 8);
      if (v8)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 104 * v8;
        while (1)
        {
          uint64_t v11 = v7 + v9;
          if (*(_DWORD *)(v7 + v9 + 96) == *(_DWORD *)(a2 + 96)) {
            break;
          }
          v9 += 104;
          if (v10 == v9)
          {
            uint64_t v11 = v7 + 104 * v8;
            goto LABEL_15;
          }
        }
        if (v10 - 104 != v9)
        {
          uint64_t v12 = v10 - v9 - 104;
          uint64_t v13 = v11 + 104;
          do
          {
            if (*(_DWORD *)(v13 + 96) != *(_DWORD *)(a2 + 96))
            {
              sub_1CC911518((void *)v11, v13);
              sub_1CC9115F8((void *)(v11 + 32), v13 + 32);
              sub_1CC6DA560((void *)(v11 + 64), v13 + 64);
              char v14 = *(unsigned char *)(v13 + 100);
              *(_DWORD *)(v11 + 96) = *(_DWORD *)(v13 + 96);
              *(unsigned char *)(v11 + 100) = v14;
              v11 += 104;
            }
            v13 += 104;
            v12 -= 104;
          }
          while (v12);
          uint64_t v7 = *(void *)v6;
          unsigned int v8 = *(_DWORD *)(v6 + 8);
        }
      }
      else
      {
        uint64_t v11 = *(void *)v6;
      }
LABEL_15:
      sub_1CC9112BC((uint64_t *)v6, v11, v7 + 104 * v8);
    }
    return v5;
  }
  else
  {
    sub_1CB920400();
    return sub_1CC911830();
  }
}

BOOL sub_1CC911830(uint64_t a1, uint64_t *a2)
{
  sub_1CC9118C0(a1, a2, (uint64_t)&v8);
  int v4 = v9;
  if (v9)
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 80);
    if (v6 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 72) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 80);
  }
  return v4 != 0;
}

void *sub_1CC9118C0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  char v14 = 0;
  uint64_t result = (void *)sub_1CC27F554(a1, a2, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    char v11 = 0;
    uint64_t v10 = v12 + 8 * v13;
  }
  else
  {
    uint64_t result = sub_1CC91197C((_DWORD *)a1, (uint64_t)a2, a2, v14);
    uint64_t v7 = result;
    *uint64_t result = *a2;
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v10 = v8 + 8 * v9;
    char v11 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v10;
  *(unsigned char *)(a3 + 16) = v11;
  return result;
}

void *sub_1CC91197C(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 8;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CC911A40((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CC27F554((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_5:
  *a1 += 2;
  if (*a4 != -4096) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CC911A40(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    char v11 = *(void **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC911BBC(a1, v11, &v11[v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  int v6 = v14;
  for (uint64_t i = 8; i != 72; i += 8)
  {
    uint64_t v8 = *(void *)(a1 + i);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v6++ = v8;
    }
  }
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CC911BBC(a1, v14, v6);
}

uint64_t sub_1CC911BBC(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_9;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_9:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CC27F554((uint64_t)v5, a2, &v10);
      *uint64_t v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

void sub_1CC911C80()
{
}

void *sub_1CC911C94()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2627F58;
  return result;
}

void sub_1CC911CCC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2627F58;
}

uint64_t sub_1CC911CF4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  if (v2) {
    return (*(unsigned __int8 *)(v2 + 16) >> 5) & 1;
  }
  else {
    return 0;
  }
}

void sub_1CC911D14()
{
}

void *sub_1CC911D28(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2627FA0;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC911D70(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2627FA0;
  a2[1] = v2;
  return result;
}

BOOL sub_1CC911D9C(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 > 0x23)
  {
    if (v4 == 84)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      uint64_t v7 = *(void *)(a2 + 64);
      if ((!v7 || (*(unsigned char *)(v7 + 16) & 0x20) == 0) && (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 37) & 1) == 0)
      {
        if (*(unsigned char *)(a2 + 16) != 84) {
          return 1;
        }
        uint64_t v8 = *(void *)(a2 - 32);
        if (!v8 || *(unsigned char *)(v8 + 16) || *(void *)(v8 + 24) != *(void *)(a2 + 72)) {
          return 1;
        }
        uint64_t v9 = sub_1CC9111A4(v6, v8);
        uint64_t v10 = v6 + 8;
        if (*(unsigned char *)v6)
        {
          uint64_t v11 = 8;
        }
        else
        {
          uint64_t v10 = *(void *)(v6 + 8);
          uint64_t v11 = *(unsigned int *)(v6 + 16);
        }
        return v10 + 8 * v11 == v9;
      }
    }
    else
    {
      if (v4 != 36 && v4 != 38) {
        return result;
      }
      if ((*(_WORD *)(a2 + 18) & 1) == 0) {
        return 1;
      }
    }
    return 0;
  }
  if (v4 == 34) {
    return 1;
  }
  return result;
}

void sub_1CC911E94()
{
}

void *sub_1CC911EA8()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F2627FE8;
  return result;
}

void sub_1CC911EE0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2627FE8;
}

uint64_t sub_1CC911F08(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(a2 + 112), **(uint64_t ***)a2, -1, 37);
  *(void *)(a2 + 112) = result;
  return result;
}

void sub_1CC911F48()
{
}

void *sub_1CC911F5C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2628030;
  return result;
}

void sub_1CC911F94(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2628030;
}

uint64_t sub_1CC911FBC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  if (!v2) {
    return 0;
  }
  if ((*(unsigned char *)(v2 + 17) & 0x30) != 0) {
    return 1;
  }
  return (*(unsigned __int8 *)(v2 + 15) >> 1) & 1;
}

void sub_1CC911FF0()
{
}

void *sub_1CC912004(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2628078;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC91204C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2628078;
  a2[1] = v2;
  return result;
}

BOOL sub_1CC912078(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 16) - 33;
  BOOL v3 = v2 > 0x33;
  uint64_t v4 = (1 << v2) & 0x8000000000041;
  BOOL v5 = v3 || v4 == 0;
  BOOL result = 0;
  if (!v5)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a2 + 64);
    if ((!v8 || (*(unsigned char *)(v8 + 15) & 2) == 0) && (llvm::CallBase::hasFnAttrOnCalledFunction(a2, 25) & 1) == 0)
    {
      uint64_t v10 = *(void *)(a2 - 32);
      if (!v10 || *(unsigned char *)(v10 + 16) || *(void *)(v10 + 24) != *(void *)(a2 + 72)) {
        return 1;
      }
      uint64_t v11 = sub_1CC9111A4(v7, v10);
      uint64_t v12 = v7 + 8;
      if (*(unsigned char *)v7)
      {
        uint64_t v13 = 8;
      }
      else
      {
        uint64_t v12 = *(void *)(v7 + 8);
        uint64_t v13 = *(unsigned int *)(v7 + 16);
      }
      if (v12 + 8 * v13 == v11) {
        return 1;
      }
    }
  }
  return result;
}

void sub_1CC912148()
{
}

void *sub_1CC91215C()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F26280C0;
  return result;
}

void sub_1CC912194(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26280C0;
}

uint64_t sub_1CC9121BC(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(a2 + 112), **(uint64_t ***)a2, -1, 25);
  *(void *)(a2 + 112) = result;
  return result;
}

void sub_1CC9121FC()
{
}

void *sub_1CC912210()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2628108;
  return result;
}

void sub_1CC912248(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2628108;
}

uint64_t sub_1CC912270(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 112);
  if (v2) {
    return (*(unsigned __int8 *)(v2 + 16) >> 3) & 1;
  }
  else {
    return 0;
  }
}

void sub_1CC912290()
{
}

void *sub_1CC9122A4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2628150;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC9122EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2628150;
  a2[1] = v2;
  return result;
}

BOOL sub_1CC912318(uint64_t a1, llvm::Instruction *this)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (llvm::Instruction::isVolatile(this)) {
    return 1;
  }
  int v5 = *((unsigned __int8 *)this + 16);
  if (v5 == 60)
  {
LABEL_4:
    if ((*((_WORD *)this + 9) & 0x380) != 0)
    {
      BOOL v6 = (*((_WORD *)this + 9) & 0x301) == 0;
      return !v6;
    }
    return 0;
  }
  if (*((unsigned __int8 *)this + 16) <= 0x3Eu)
  {
    if (v5 == 61) {
      goto LABEL_4;
    }
    if (v5 != 33 && v5 != 39) {
      return 0;
    }
  }
  else if (v5 != 84)
  {
    if (v5 != 63) {
      return (v5 - 64) < 2;
    }
    BOOL v6 = *((unsigned char *)this + 60) == 0;
    return !v6;
  }
  uint64_t v7 = *((void *)this + 8);
  if (v7 && (*(unsigned char *)(v7 + 16) & 8) != 0 || (llvm::CallBase::hasFnAttrOnCalledFunction((uint64_t)this, 35) & 1) != 0) {
    return 0;
  }
  if (!sub_1CBFB3AB0((uint64_t)this))
  {
LABEL_28:
    uint64_t v15 = *((void *)this - 4);
    if (!v15 || *(unsigned char *)(v15 + 16) || *(void *)(v15 + 24) != *((void *)this + 9)) {
      return 1;
    }
    uint64_t v16 = sub_1CC9111A4(v3, v15);
    uint64_t v17 = v3 + 8;
    if (*(unsigned char *)v3)
    {
      uint64_t v18 = 8;
    }
    else
    {
      uint64_t v17 = *(void *)(v3 + 8);
      uint64_t v18 = *(unsigned int *)(v3 + 16);
    }
    return v17 + 8 * v18 == v16;
  }
  uint64_t v8 = ((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[12];
  uint64_t v9 = *(unsigned int *)(v8 + 32);
  if (v9 <= 0x40)
  {
    if (!*(void *)(v8 + 24)) {
      return 0;
    }
    goto LABEL_28;
  }
  int v10 = 0;
  int64_t v11 = (unint64_t)(v9 + 63) >> 6;
  do
  {
    if (v11-- < 1) {
      break;
    }
    unint64_t v13 = *(void *)(*(void *)(v8 + 24) + 8 * v11);
    v10 += __clz(v13);
  }
  while (!v13);
  BOOL result = 0;
  int v14 = v9 | 0xFFFFFFC0;
  if ((v9 & 0x3F) == 0) {
    int v14 = 0;
  }
  if (v10 + v14 != v9) {
    goto LABEL_28;
  }
  return result;
}

void sub_1CC9124C4()
{
}

void *sub_1CC9124D8()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F2628198;
  return result;
}

void sub_1CC912510(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2628198;
}

uint64_t sub_1CC912538(uint64_t a1, uint64_t a2)
{
  uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(a2 + 112), **(uint64_t ***)a2, -1, 35);
  *(void *)(a2 + 112) = result;
  return result;
}

void sub_1CC912574()
{
}

void sub_1CC9125B4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC9125EC(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v3 = a2 + 112;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::CallGraphWrapperPass::ID);

  sub_1CB843600(a2, v3, (uint64_t)&llvm::CallGraphWrapperPass::ID);
}

uint64_t sub_1CC912680(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }
  uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_6:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::CallGraphWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_6;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = *(void *)(*(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::CallGraphWrapperPass::ID)+ 32)+ 80);

  return sub_1CC90815C(v8);
}

uint64_t sub_1CC912738()
{
  char v3 = 1;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Try to propagate nonnull argument attributes from callsites to caller functions.";
  v1.n128_u64[1] = 80;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDE6D8, "enable-nonnull-arg-prop", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDE6D8, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Stop inferring nounwind attribute during function-attrs pass";
  v1.n128_u64[1] = 60;
  sub_1CD4C1500((uint64_t)&unk_1EBCDE798, "disable-nounwind-inference", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDE798, &dword_1CB82C000);
  LODWORD(v4) = 1;
  v1.n128_u64[0] = (unint64_t)"Stop inferring nofree attribute during function-attrs pass";
  v1.n128_u64[1] = 58;
  sub_1CD4C1500((uint64_t)&unk_1EBCDE858, "disable-nofree-inference", &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDE858, &dword_1CB82C000);
  char v3 = 1;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Don't propagate function-attrs in thinLTO";
  v1.n128_u64[1] = 41;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDE918, "disable-thinlto-funcattrs", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDE918, &dword_1CB82C000);
}

void llvm::ComputeCrossModuleImport(uint64_t a1, uint64_t a2, llvm::StringMapImpl *a3, uint64_t a4)
{
  uint64_t v7 = *(unsigned int *)(a2 + 8);
  if (v7)
  {
    for (uint64_t i = *(uint64_t **)a2; !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = *(uint64_t **)a2;
  }
  uint64_t v10 = *(void *)a2 + 8 * v7;
  if (i != (uint64_t *)v10)
  {
    uint64_t v11 = *i;
    do
    {
      uint64_t v12 = sub_1CC915D88(a3, (unsigned __int8 *)(v11 + 32), *(void *)v11);
      sub_1CC912D30(v11 + 8, a1, (const void *)(v11 + 32), *(void *)v11, *v12 + 8, a4);
      do
      {
        uint64_t v13 = i[1];
        ++i;
        uint64_t v11 = v13;
        if (v13) {
          BOOL v14 = v11 == -8;
        }
        else {
          BOOL v14 = 1;
        }
      }
      while (v14);
    }
    while (i != (uint64_t *)v10);
  }
  uint64_t v62 = a1;
  uint64_t v15 = *(unsigned int *)(a4 + 8);
  if (v15)
  {
    for (uint64_t j = *(uint64_t **)a4; !*j || *j == -8; ++j)
      ;
  }
  else
  {
    uint64_t j = *(uint64_t **)a4;
  }
  uint64_t v63 = *(void *)a4 + 8 * v15;
  if (j != (uint64_t *)v63)
  {
    uint64_t v18 = *j;
    do
    {
      uint64_t v68 = 0;
      unint64_t v69 = 0;
      unsigned int v70 = 0;
      sub_1CC9133EC((uint64_t)&v66, (uint64_t *)a2, (unsigned __int8 *)(v18 + 32), *(void *)v18);
      uint64_t v21 = *(void **)(v18 + 8);
      uint64_t v20 = v18 + 8;
      uint64_t v19 = v21;
      uint64_t v22 = *(unsigned int *)(v20 + 16);
      unsigned int v23 = &v21[v22];
      if (*(_DWORD *)(v20 + 8))
      {
        if (*(_DWORD *)(v20 + 16))
        {
          uint64_t v24 = 8 * v22;
          uint64_t v25 = v19;
          while ((~*v25 & 0xFFFFFFFFFFFFFFF0) == 0)
          {
            ++v25;
            v24 -= 8;
            if (!v24) {
              goto LABEL_34;
            }
          }
        }
        else
        {
          uint64_t v25 = v19;
        }
      }
      else
      {
LABEL_34:
        uint64_t v25 = v23;
      }
      uint64_t v26 = &v19[v22];
      if (v25 != v26)
      {
        uint64_t v65 = v66;
        unsigned int v27 = v67;
        do
        {
          uint64_t v28 = sub_1CD661C80(v65, v27, *(void *)(*v25 & 0xFFFFFFFFFFFFFFF8))[1];
          int v29 = *(_DWORD *)(v28 + 8);
          if (v28) {
            BOOL v30 = v29 == 0;
          }
          else {
            BOOL v30 = 0;
          }
          if (v30)
          {
            uint64_t v28 = *(void *)(v28 + 72);
            int v29 = *(_DWORD *)(v28 + 8);
          }
          if (v29 == 2)
          {
            if (!*(unsigned char *)(v62 + 129) || (*(unsigned char *)(v28 + 72) & 2) == 0)
            {
              uint64_t v31 = *(void **)(v28 + 40);
              uint64_t v32 = *(void *)(v28 + 48) - (void)v31;
              if (v32)
              {
                uint64_t v33 = 8 * (v32 >> 3);
                do
                {
                  sub_1CD4AD7E0((uint64_t)&v68, v31++, (uint64_t)v71);
                  v33 -= 8;
                }
                while (v33);
              }
            }
          }
          else
          {
            unsigned int v34 = *(void **)(v28 + 80);
            uint64_t v35 = *(void *)(v28 + 88) - (void)v34;
            if (v35)
            {
              uint64_t v36 = 16 * (v35 >> 4);
              do
              {
                sub_1CD4AD7E0((uint64_t)&v68, v34, (uint64_t)v71);
                v34 += 2;
                v36 -= 16;
              }
              while (v36);
            }
            uint64_t v37 = *(void **)(v28 + 40);
            uint64_t v38 = *(void *)(v28 + 48) - (void)v37;
            if (v38)
            {
              uint64_t v39 = 8 * (v38 >> 3);
              do
              {
                sub_1CD4AD7E0((uint64_t)&v68, v37++, (uint64_t)v71);
                v39 -= 8;
              }
              while (v39);
            }
          }
          uint64_t v40 = v25 + 1;
          uint64_t v25 = v23;
          if (v40 != v23)
          {
            uint64_t v25 = v40;
            while ((~*v25 & 0xFFFFFFFFFFFFFFF0) == 0)
            {
              if (++v25 == v23)
              {
                uint64_t v25 = v23;
                break;
              }
            }
          }
        }
        while (v25 != v26);
      }
      uint64_t v41 = v68;
      int v42 = v69;
      uint64_t v43 = v70;
      unint64_t v44 = &v68[v70];
      if (v69)
      {
        uint64_t v45 = 37;
        if (v70)
        {
          uint64_t v46 = 8 * v70;
          uint64_t v47 = v68;
          while ((~*v47 & 0xFFFFFFFFFFFFFFF0) == 0)
          {
            ++v47;
            v46 -= 8;
            if (!v46)
            {
              uint64_t v47 = &v68[v70];
              break;
            }
          }
        }
        else
        {
          uint64_t v47 = v68;
        }
      }
      else
      {
        uint64_t v47 = &v68[v70];
        uint64_t v45 = 37;
      }
      uint64_t v48 = &v68[v70];
      if (v47 != v48)
      {
        int v49 = HIDWORD(v69);
        uint64_t v50 = v66;
        unsigned int v51 = v67;
        unsigned int v52 = v67 - 1;
        do
        {
          if (v51)
          {
            uint64_t v53 = *(void *)(*v47 & 0xFFFFFFFFFFFFFFF8);
            unsigned int v54 = (37 * v53) & v52;
            uint64_t v55 = *(void *)(v50 + 16 * v54);
            if (v53 == v55) {
              goto LABEL_75;
            }
            int v56 = 1;
            while (v55 != -1)
            {
              unsigned int v57 = v54 + v56++;
              unsigned int v54 = v57 & v52;
              uint64_t v55 = *(void *)(v50 + 16 * v54);
              if (v53 == v55)
              {
LABEL_75:
                while (++v47 != v44)
                {
                  if ((~*v47 & 0xFFFFFFFFFFFFFFF0) != 0) {
                    goto LABEL_89;
                  }
                }
                uint64_t v47 = v44;
                goto LABEL_89;
              }
            }
          }
          unsigned int v58 = v44;
          if (v47 + 1 != v44)
          {
            unsigned int v58 = v47 + 1;
            while ((~*v58 & 0xFFFFFFFFFFFFFFF0) == 0)
            {
              if (++v58 == v44)
              {
                unsigned int v58 = v44;
                break;
              }
            }
          }
          *uint64_t v47 = -16;
          unint64_t v69 = __PAIR64__(++v49, --v42);
          uint64_t v47 = v58;
LABEL_89:
          ;
        }
        while (v47 != v48);
      }
      if (v42)
      {
        if (v43)
        {
          uint64_t v59 = 8 * v43;
          while ((~*v41 & 0xFFFFFFFFFFFFFFF0) == 0)
          {
            ++v41;
            v59 -= 8;
            if (!v59) {
              goto LABEL_100;
            }
          }
        }
LABEL_99:
        if (v41 != v48)
        {
          sub_1CD4AD7E0(v20, v41, (uint64_t)v71);
          while (++v41 != v48)
          {
            if ((~*v41 & 0xFFFFFFFFFFFFFFF0) != 0) {
              goto LABEL_99;
            }
          }
        }
      }
LABEL_100:
      MEMORY[0x1D25D9CD0](v66, 8, v45);
      MEMORY[0x1D25D9CD0](v68, 8);
      do
      {
        uint64_t v60 = j[1];
        ++j;
        uint64_t v18 = v60;
        if (v60) {
          BOOL v61 = v18 == -8;
        }
        else {
          BOOL v61 = 1;
        }
      }
      while (v61);
    }
    while (j != (uint64_t *)v63);
  }
}

void sub_1CC912D30(uint64_t a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = a1;
  v62[256] = *MEMORY[0x1E4F143B8];
  uint64_t v60 = v62;
  uint64_t v61 = 0x8000000000;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  unsigned int v59 = 0;
  uint64_t v12 = *(unsigned int *)(a1 + 16);
  uint64_t v13 = *(void *)a1 + 16 * v12;
  if (*(_DWORD *)(a1 + 8))
  {
    if (v12)
    {
      uint64_t v28 = 16 * v12;
      BOOL v14 = *(unint64_t **)a1;
      while (*v14 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v14 += 2;
        v28 -= 16;
        if (!v28) {
          goto LABEL_2;
        }
      }
    }
    else
    {
      BOOL v14 = *(unint64_t **)a1;
    }
  }
  else
  {
LABEL_2:
    BOOL v14 = (unint64_t *)(*(void *)a1 + 16 * v12);
  }
  uint64_t v15 = *(void *)a1 + 16 * v12;
  if (v14 != (unint64_t *)v15)
  {
    do
    {
      a1 = v14[1];
      if (!*(unsigned char *)(a2 + 128) || (*(_WORD *)(a1 + 12) & 0x80) != 0)
      {
        int v16 = *(_DWORD *)(a1 + 8);
        if (a1) {
          BOOL v17 = v16 == 0;
        }
        else {
          BOOL v17 = 0;
        }
        if (v17)
        {
          a1 = *(void *)(a1 + 72);
          int v16 = *(_DWORD *)(a1 + 8);
        }
        if (v16 == 1) {
          a1 = sub_1CC914D44(a1, a2, dword_1EBCDEA68, v11, (uint64_t)&v60, a5, a6, (uint64_t)&v57);
        }
      }
      uint64_t v18 = v14 + 2;
      while (v18 != (unint64_t *)v13)
      {
        unint64_t v19 = *v18;
        v18 += 2;
        if (v19 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          BOOL v14 = v18 - 2;
          goto LABEL_21;
        }
      }
      BOOL v14 = (unint64_t *)v13;
LABEL_21:
      ;
    }
    while (v14 != (unint64_t *)v15);
    while (v61)
    {
      uint64_t v20 = (char *)v60 + 16 * v61;
      uint64_t v21 = *((void *)v20 - 2);
      uint64_t v22 = *((void *)v20 - 1);
      LODWORD(v61) = v61 - 1;
      if (v21) {
        BOOL v23 = *(_DWORD *)(v21 + 8) == 1;
      }
      else {
        BOOL v23 = 0;
      }
      if (v23) {
        a1 = sub_1CC914D44(v21, a2, v22, v11, (uint64_t)&v60, a5, a6, (uint64_t)&v57);
      }
      else {
        a1 = sub_1CC91558C(v21, a2, v11, (uint64_t)&v60, a5, a6);
      }
    }
  }
  if (byte_1EBCDF128)
  {
    uint64_t v24 = llvm::dbgs((llvm *)a1);
    uint64_t v25 = v24;
    uint64_t v26 = (void *)*((void *)v24 + 4);
    if (*((void *)v24 + 3) - (void)v26 > 0x1AuLL)
    {
      qmemcpy(v26, "Missed imports into module ", 27);
      unsigned int v27 = (llvm::raw_ostream *)(*((void *)v24 + 4) + 27);
      *((void *)v25 + 4) = v27;
    }
    else
    {
      llvm::raw_ostream::write(v24, "Missed imports into module ", 0x1BuLL);
      unsigned int v27 = (llvm::raw_ostream *)*((void *)v25 + 4);
    }
    if (a4 <= *((void *)v25 + 3) - (void)v27)
    {
      if (a4)
      {
        memcpy(v27, a3, a4);
        unsigned int v27 = (llvm::raw_ostream *)(*((void *)v25 + 4) + a4);
        *((void *)v25 + 4) = v27;
      }
    }
    else
    {
      llvm::raw_ostream::write(v25, (const char *)a3, a4);
      unsigned int v27 = (llvm::raw_ostream *)*((void *)v25 + 4);
    }
    if (*((llvm::raw_ostream **)v25 + 3) == v27)
    {
      unsigned int v27 = llvm::raw_ostream::write(v25, "\n", 1uLL);
    }
    else
    {
      *(unsigned char *)unsigned int v27 = 10;
      ++*((void *)v25 + 4);
    }
    int v29 = (unint64_t *)(v57 + 32 * v59);
    if (v58)
    {
      if (v59)
      {
        uint64_t v56 = 32 * v59;
        uint64_t v30 = v57;
        while (*(void *)v30 >= 0xFFFFFFFFFFFFFFFELL)
        {
          v30 += 32;
          v56 -= 32;
          if (!v56) {
            goto LABEL_44;
          }
        }
      }
      else
      {
        uint64_t v30 = v57;
      }
    }
    else
    {
LABEL_44:
      uint64_t v30 = v57 + 32 * v59;
    }
    uint64_t v31 = v57 + 32 * v59;
    while (v30 != v31)
    {
      if (*(void *)(v30 + 16)) {
        goto LABEL_52;
      }
      unint64_t v34 = **(void **)(v30 + 24) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v35 = *(uint64_t **)(v34 + 24);
      if (*(uint64_t **)(v34 + 32) == v35)
      {
        uint64_t v36 = 0;
      }
      else
      {
        uint64_t v37 = *v35;
        int v38 = *(_DWORD *)(v37 + 8);
        if (v37) {
          BOOL v39 = v38 == 0;
        }
        else {
          BOOL v39 = 0;
        }
        if (v39)
        {
          uint64_t v37 = *(void *)(v37 + 72);
          int v38 = *(_DWORD *)(v37 + 8);
        }
        if (v38 == 1) {
          uint64_t v36 = v37;
        }
        else {
          uint64_t v36 = 0;
        }
      }
      uint64_t v40 = llvm::dbgs(v27);
      uint64_t v41 = sub_1CD662C0C(v40, *(void **)(v30 + 24));
      int v42 = v41;
      uint64_t v43 = *((void *)v41 + 4);
      if ((unint64_t)(*((void *)v41 + 3) - v43) > 0xA)
      {
        *(_DWORD *)(v43 + 7) = 540876910;
        *(void *)uint64_t v43 = *(void *)": Reason = ";
        *((void *)v41 + 4) += 11;
      }
      else
      {
        llvm::raw_ostream::write(v41, ": Reasounsigned int n = ", 0xBuLL);
      }
      unint64_t v44 = off_1E684AAF0[*(int *)(*(void *)(v30 + 24) + 12)];
      size_t v45 = strlen(v44);
      uint64_t v46 = (void *)*((void *)v42 + 4);
      if (v45 <= *((void *)v42 + 3) - (void)v46)
      {
        if (v45)
        {
          memcpy(v46, v44, v45);
          uint64_t v46 = (void *)(*((void *)v42 + 4) + v45);
          *((void *)v42 + 4) = v46;
        }
      }
      else
      {
        llvm::raw_ostream::write(v42, v44, v45);
        uint64_t v46 = (void *)*((void *)v42 + 4);
      }
      if (*((void *)v42 + 3) - (void)v46 > 0xDuLL)
      {
        qmemcpy(v46, ", Threshold = ", 14);
        *((void *)v42 + 4) += 14;
      }
      else
      {
        llvm::raw_ostream::write(v42, ", Threshold = ", 0xEuLL);
      }
      sub_1CD098D14(v42, *(unsigned int *)(v30 + 8), 0, 0, 0);
      uint64_t v47 = *((void *)v42 + 4);
      if ((unint64_t)(*((void *)v42 + 3) - v47) > 8)
      {
        *(unsigned char *)(v47 + 8) = 32;
        *(void *)uint64_t v47 = *(void *)", Size = ";
        *((void *)v42 + 4) += 9;
        if (!v36)
        {
LABEL_85:
          unint64_t v48 = -1;
LABEL_86:
          unint64_t v48 = -(uint64_t)v48;
          int v49 = v42;
          int v50 = 1;
          goto LABEL_87;
        }
      }
      else
      {
        llvm::raw_ostream::write(v42, ", Size = ", 9uLL);
        if (!v36) {
          goto LABEL_85;
        }
      }
      unint64_t v48 = *(int *)(v36 + 64);
      if ((v48 & 0x80000000) != 0) {
        goto LABEL_86;
      }
      int v49 = v42;
      int v50 = 0;
LABEL_87:
      sub_1CD098D14(v49, v48, 0, 0, v50);
      unsigned int v51 = (void *)*((void *)v42 + 4);
      if (*((void *)v42 + 3) - (void)v51 > 0xEuLL)
      {
        qmemcpy(v51, ", MaxHotness = ", 15);
        *((void *)v42 + 4) += 15;
      }
      else
      {
        llvm::raw_ostream::write(v42, ", MaxHotness = ", 0xFuLL);
      }
      unsigned int v52 = off_1E684AAC8[*(char *)(*(void *)(v30 + 24) + 8)];
      size_t v53 = strlen(v52);
      unsigned int v54 = (void *)*((void *)v42 + 4);
      if (v53 <= *((void *)v42 + 3) - (void)v54)
      {
        if (v53)
        {
          memcpy(v54, v52, v53);
          unsigned int v54 = (void *)(*((void *)v42 + 4) + v53);
          *((void *)v42 + 4) = v54;
        }
      }
      else
      {
        llvm::raw_ostream::write(v42, v52, v53);
        unsigned int v54 = (void *)*((void *)v42 + 4);
      }
      if (*((void *)v42 + 3) - (void)v54 > 0xCuLL)
      {
        qmemcpy(v54, ", Attempts = ", 13);
        *((void *)v42 + 4) += 13;
      }
      else
      {
        llvm::raw_ostream::write(v42, ", Attempts = ", 0xDuLL);
      }
      unsigned int v27 = sub_1CD098D14(v42, *(unsigned int *)(*(void *)(v30 + 24) + 16), 0, 0, 0);
      uint64_t v55 = (unsigned char *)*((void *)v42 + 4);
      if (*((unsigned char **)v42 + 3) == v55)
      {
        unsigned int v27 = llvm::raw_ostream::write(v42, "\n", 1uLL);
      }
      else
      {
        *uint64_t v55 = 10;
        ++*((void *)v42 + 4);
      }
LABEL_52:
      uint64_t v32 = (unint64_t *)(v30 + 32);
      while (v32 != v29)
      {
        unint64_t v33 = *v32;
        v32 += 4;
        if (v33 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v30 = (uint64_t)(v32 - 4);
          goto LABEL_57;
        }
      }
      uint64_t v30 = (uint64_t)v29;
LABEL_57:
      ;
    }
  }
  sub_1CD6632F8(&v57);
  if (v60 != v62) {
    free(v60);
  }
}

uint64_t sub_1CC9133EC(uint64_t result, uint64_t *a2, unsigned __int8 *__s1, size_t __n)
{
  uint64_t v23 = result;
  uint64_t v4 = *((unsigned int *)a2 + 2);
  if (!v4) {
    goto LABEL_15;
  }
  int v8 = 0;
  if (__n)
  {
    size_t v9 = __n;
    uint64_t v10 = __s1;
    do
    {
      int v11 = *v10++;
      int v8 = 33 * v8 + v11;
      --v9;
    }
    while (v9);
  }
  uint64_t v12 = *a2;
  uint64_t v13 = *a2 + 8 * v4 + 8;
  int v14 = 1;
  int v15 = v8;
  while (1)
  {
    uint64_t v16 = v15 & (v4 - 1);
    BOOL v17 = *(void **)(v12 + 8 * v16);
    if (v17 != (void *)-8)
    {
      if (!v17) {
        goto LABEL_15;
      }
      if (*(_DWORD *)(v13 + 4 * v16) == v8 && __n == *v17)
      {
        if (!__n) {
          break;
        }
        uint64_t result = memcmp(__s1, (char *)v17 + *((unsigned int *)a2 + 5), __n);
        if (!result) {
          break;
        }
      }
    }
    int v15 = v14 + v16;
    ++v14;
  }
  if (v16 == -1 || (int)v16 == v4)
  {
LABEL_15:
    *(void *)uint64_t v23 = 0;
    *(void *)(v23 + 8) = 0;
    *(_DWORD *)(v23 + 16) = 0;
  }
  else
  {
    uint64_t v18 = *(void *)(v12 + 8 * (int)v16);
    *(void *)uint64_t v23 = 0;
    *(void *)(v23 + 8) = 0;
    uint64_t result = MEMORY[0x1D25D9CD0](0, 8);
    uint64_t v19 = *(unsigned int *)(v18 + 24);
    *(_DWORD *)(v23 + 16) = v19;
    if (v19)
    {
      size_t v20 = 16 * v19;
      uint64_t v21 = operator new(16 * v19, (std::align_val_t)8uLL);
      *(void *)uint64_t v23 = v21;
      *(void *)(v23 + 8) = *(void *)(v18 + 16);
      uint64_t v22 = *(const void **)(v18 + 8);
      return (uint64_t)memcpy(v21, v22, v20);
    }
    else
    {
      *(void *)uint64_t v23 = 0;
      *(void *)(v23 + 8) = 0;
    }
  }
  return result;
}

uint64_t updateValueInfoForIndirectCalls(uint64_t result, uint64_t a2)
{
  int v2 = *(unint64_t **)(a2 + 80);
  char v3 = *(unint64_t **)(a2 + 88);
  if (v2 != v3)
  {
    uint64_t v5 = *(void **)(result + 8);
    result += 8;
    uint64_t v4 = v5;
    uint64_t v6 = *(void **)(result + 104);
    uint64_t v7 = *(unsigned __int8 *)(result + 125);
    do
    {
      int v8 = (unint64_t *)(*v2 & 0xFFFFFFFFFFFFFFF8);
      if (v8[4] == v8[3] && v6)
      {
        unint64_t v9 = *v8;
        uint64_t v10 = v6;
        int v11 = (void *)(result + 104);
        do
        {
          unint64_t v12 = v10[4];
          BOOL v13 = v12 >= v9;
          if (v12 >= v9) {
            int v14 = v10;
          }
          else {
            int v14 = v10 + 1;
          }
          if (v13) {
            int v11 = v10;
          }
          uint64_t v10 = (void *)*v14;
        }
        while (*v14);
        if (v11 != (void *)(result + 104) && v11[4] <= v9)
        {
          unint64_t v15 = v11[5];
          if (v15)
          {
            if (!v4) {
              goto LABEL_29;
            }
            uint64_t v16 = v4;
            BOOL v17 = (void *)result;
            do
            {
              unint64_t v18 = v16[4];
              BOOL v19 = v18 >= v15;
              if (v18 >= v15) {
                size_t v20 = v16;
              }
              else {
                size_t v20 = v16 + 1;
              }
              if (v19) {
                BOOL v17 = v16;
              }
              uint64_t v16 = (void *)*v20;
            }
            while (*v20);
            if (v17 == (void *)result || v17[4] > v15) {
LABEL_29:
            }
              BOOL v17 = (void *)result;
            uint64_t v21 = (uint64_t)(v17 + 4);
            if (v17 == (void *)result) {
              uint64_t v21 = 0;
            }
            unint64_t v22 = v21 & 0xFFFFFFFFFFFFFFF8;
            uint64_t v23 = *(void *)(v22 + 24);
            uint64_t v24 = *(void *)(v22 + 32) - v23;
            if (v24)
            {
              uint64_t v25 = 8 * (v24 >> 3);
              while (*(_DWORD *)(*(void *)v23 + 8) != 2)
              {
                v23 += 8;
                v25 -= 8;
                if (!v25) {
                  goto LABEL_36;
                }
              }
            }
            else
            {
LABEL_36:
              unint64_t *v2 = v22 | v7;
            }
          }
        }
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
  return result;
}

void *llvm::updateIndirectCalls(void *this, llvm::ModuleSummaryIndex *a2)
{
  int v2 = this + 1;
  char v3 = (void *)*this;
  if ((void *)*this != this + 1)
  {
    uint64_t v4 = (uint64_t)this;
    do
    {
      uint64_t v5 = (uint64_t *)v3[7];
      uint64_t v6 = (uint64_t *)v3[8];
      while (v5 != v6)
      {
        if (*v5) {
          BOOL v7 = *(_DWORD *)(*v5 + 8) == 1;
        }
        else {
          BOOL v7 = 0;
        }
        if (v7) {
          this = (void *)updateValueInfoForIndirectCalls(v4, *v5);
        }
        ++v5;
      }
      int v8 = (void *)v3[1];
      if (v8)
      {
        do
        {
          unint64_t v9 = v8;
          int v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          unint64_t v9 = (void *)v3[2];
          BOOL v7 = *v9 == (void)v3;
          char v3 = v9;
        }
        while (!v7);
      }
      char v3 = v9;
    }
    while (v9 != v2);
  }
  return this;
}

void llvm::computeDeadSymbolsAndUpdateIndirectCalls(llvm **this, llvm::ModuleSummaryIndex *a2, void (*a3)(uint64_t, void), uint64_t a4)
{
  v66[128] = *MEMORY[0x1E4F143B8];
  uint64_t v62 = a3;
  uint64_t v63 = a4;
  if (byte_1EBCDF1E8 && (int v5 = *((_DWORD *)a2 + 2)) != 0)
  {
    int v61 = 0;
    uint64_t v64 = v66;
    uint64_t v65 = 0x8000000000;
    if ((2 * v5) >= 0x81) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v6 = *(unint64_t **)a2;
    uint64_t v7 = *((unsigned int *)a2 + 4);
    uint64_t v8 = *(void *)a2 + 8 * v7;
    if (v7)
    {
      uint64_t v9 = 0;
      while (v6[v9] >= 0xFFFFFFFFFFFFFFFELL)
      {
        if (v7 == ++v9)
        {
          uint64_t v10 = (unint64_t *)(*(void *)a2 + 8 * v7);
          goto LABEL_15;
        }
      }
      uint64_t v10 = &v6[v9];
    }
    else
    {
      uint64_t v10 = *(unint64_t **)a2;
    }
LABEL_15:
    int v11 = &v6[v7];
    if (v10 != v11)
    {
      unint64_t v12 = (char *)(this + 1);
      do
      {
        BOOL v13 = *(void **)v12;
        if (!*(void *)v12) {
          goto LABEL_28;
        }
        unint64_t v14 = *v10;
        unint64_t v15 = (char *)(this + 1);
        do
        {
          unint64_t v16 = v13[4];
          BOOL v17 = v16 >= v14;
          if (v16 >= v14) {
            unint64_t v18 = v13;
          }
          else {
            unint64_t v18 = v13 + 1;
          }
          if (v17) {
            unint64_t v15 = (char *)v13;
          }
          BOOL v13 = (void *)*v18;
        }
        while (*v18);
        if (v15 == v12 || *((void *)v15 + 4) > v14) {
LABEL_28:
        }
          unint64_t v15 = (char *)(this + 1);
        if (v15 == v12) {
          unint64_t v19 = 0;
        }
        else {
          unint64_t v19 = (unint64_t)(v15 + 32);
        }
        unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFF8;
        if ((v19 & 0xFFFFFFFFFFFFFFF8) != 0)
        {
          uint64_t v21 = *(uint64_t **)(v20 + 24);
          uint64_t v22 = *(void *)(v20 + 32) - (void)v21;
          if (v22)
          {
            uint64_t v23 = 8 * (v22 >> 3);
            do
            {
              uint64_t v24 = *v21++;
              *(_WORD *)(v24 + 12) |= 0x80u;
              v23 -= 8;
            }
            while (v23);
          }
        }
        uint64_t v25 = v10 + 1;
        while (v25 != (unint64_t *)v8)
        {
          unint64_t v26 = *v25++;
          if (v26 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v10 = v25 - 1;
            goto LABEL_41;
          }
        }
        uint64_t v10 = (unint64_t *)v8;
LABEL_41:
        ;
      }
      while (v10 != v11);
    }
    unsigned int v27 = this + 1;
    uint64_t v28 = *this;
    if (*this != (llvm *)(this + 1))
    {
      do
      {
        int v29 = (uint64_t *)*((void *)v28 + 7);
        uint64_t v30 = (uint64_t *)*((void *)v28 + 8);
        if (v29 != v30)
        {
          unint64_t v31 = *((unsigned __int8 *)this + 133) | ((unint64_t)v28 + 32);
          while (1)
          {
            uint64_t v32 = *v29;
            if (*v29) {
              BOOL v33 = *(_DWORD *)(*v29 + 8) == 1;
            }
            else {
              BOOL v33 = 0;
            }
            if (v33)
            {
              updateValueInfoForIndirectCalls((uint64_t)this, v32);
              uint64_t v32 = *v29;
            }
            if ((*(_WORD *)(v32 + 12) & 0x80) != 0) {
              break;
            }
            if (++v29 == v30) {
              goto LABEL_56;
            }
          }
          if (v65 >= (unint64_t)HIDWORD(v65)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v64 + v65) = v31;
          LODWORD(v65) = v65 + 1;
          ++v61;
        }
LABEL_56:
        unint64_t v34 = (llvm *)*((void *)v28 + 1);
        if (v34)
        {
          do
          {
            uint64_t v35 = (llvm **)v34;
            unint64_t v34 = *(llvm **)v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            uint64_t v35 = (llvm **)*((void *)v28 + 2);
            BOOL v33 = *v35 == v28;
            uint64_t v28 = (llvm *)v35;
          }
          while (!v33);
        }
        uint64_t v28 = (llvm *)v35;
      }
      while (v35 != v27);
    }
    v60[0] = &v62;
    v60[1] = &v61;
    v60[2] = &v64;
    unsigned int v36 = v65;
    while (v36)
    {
      uint64_t v37 = *((void *)v64 + --v36);
      LODWORD(v65) = v36;
      v37 &= 0xFFFFFFFFFFFFFFF8;
      uint64_t v38 = *(void *)(v37 + 24);
      uint64_t v39 = *(void *)(v37 + 32);
      if (v39 != v38)
      {
        do
        {
          uint64_t v40 = *(void **)v38;
          int v41 = *(_DWORD *)(*(void *)v38 + 8);
          if (*(void *)v38) {
            BOOL v42 = v41 == 0;
          }
          else {
            BOOL v42 = 0;
          }
          if (v42)
          {
            uint64_t v51 = v40[8];
            unsigned int v52 = (void *)(v51 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v53 = *(void *)((v51 & 0xFFFFFFFFFFFFFFF8) + 24);
            uint64_t v54 = *(void *)((v51 & 0xFFFFFFFFFFFFFFF8) + 32) - v53;
            if (v54)
            {
              uint64_t v55 = 8 * (v54 >> 3);
              while ((*(_WORD *)(*(void *)v53 + 12) & 0x80) == 0)
              {
                v53 += 8;
                v55 -= 8;
                if (!v55) {
                  goto LABEL_83;
                }
              }
            }
            else
            {
LABEL_83:
              v62(v63, *v52);
              uint64_t v56 = (uint64_t *)v52[3];
              uint64_t v57 = v52[4] - (void)v56;
              if (v57)
              {
                uint64_t v58 = 8 * (v57 >> 3);
                do
                {
                  uint64_t v59 = *v56++;
                  *(_WORD *)(v59 + 12) |= 0x80u;
                  v58 -= 8;
                }
                while (v58);
              }
              ++v61;
              if (v65 >= (unint64_t)HIDWORD(v65)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v64 + v65) = v51;
              LODWORD(v65) = v65 + 1;
            }
          }
          else
          {
            uint64_t v43 = (uint64_t *)v40[5];
            uint64_t v44 = v40[6] - (void)v43;
            if (v44)
            {
              uint64_t v45 = 8 * (v44 >> 3);
              do
              {
                uint64_t v46 = *v43++;
                sub_1CC913BE0((uint64_t)v60, v46);
                v45 -= 8;
              }
              while (v45);
              uint64_t v40 = *(void **)v38;
              int v41 = *(_DWORD *)(*(void *)v38 + 8);
            }
            if (v41 == 1)
            {
              uint64_t v47 = (uint64_t *)v40[10];
              uint64_t v48 = v40[11] - (void)v47;
              if (v48)
              {
                uint64_t v49 = 16 * (v48 >> 4);
                do
                {
                  uint64_t v50 = *v47;
                  v47 += 2;
                  sub_1CC913BE0((uint64_t)v60, v50);
                  v49 -= 16;
                }
                while (v49);
              }
            }
          }
          v38 += 8;
        }
        while (v38 != v39);
        unsigned int v36 = v65;
      }
    }
    *((unsigned char *)this + 128) = 1;
    if (v64 != v66) {
      free(v64);
    }
  }
  else
  {
    llvm::updateIndirectCalls(this, a2);
  }
}

uint64_t sub_1CC913BE0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (void *)(a2 & 0xFFFFFFFFFFFFFFF8);
  uint64_t v5 = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24);
  uint64_t v6 = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 32) - v5;
  if (v6)
  {
    uint64_t v7 = 8 * (v6 >> 3);
    do
    {
      if ((*(_WORD *)(*(void *)v5 + 12) & 0x80) != 0) {
        return result;
      }
      v5 += 8;
      v7 -= 8;
    }
    while (v7);
  }
  uint64_t result = (**(uint64_t (***)(void, void))result)(*(void *)(*(void *)result + 8), *v4);
  uint64_t v8 = (uint64_t *)v4[3];
  uint64_t v9 = (void *)v4[4];
  uint64_t v10 = v9 - v8;
  if (result != 1) {
    goto LABEL_16;
  }
  if (v9 != v8)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 8 * v10;
    uint64_t v14 = v4[3];
    while (1)
    {
      uint64_t result = v11;
      uint64_t v11 = 1;
      int v15 = 1 << (*(_WORD *)(*(void *)v14 + 12) & 0xF);
      if ((v15 & 0x1C1) != 0)
      {
        uint64_t v11 = v12;
      }
      else if ((v15 & 0x614) == 0)
      {
        goto LABEL_13;
      }
      uint64_t v12 = v11;
      uint64_t v11 = result;
LABEL_13:
      v14 += 8;
      v13 -= 8;
      if (!v13)
      {
        if (v11 & v12) {
          llvm::report_fatal_error((llvm *)"Interposable and available_externally/linkonce_odr/weak_odr symbol", (const llvm::Twine *)1);
        }
        if (v11)
        {
LABEL_16:
          if (v9 != v8)
          {
            uint64_t v16 = 8 * v10;
            do
            {
              uint64_t v17 = *v8++;
              *(_WORD *)(v17 + 12) |= 0x80u;
              v16 -= 8;
            }
            while (v16);
          }
          unint64_t v18 = *(_DWORD **)(v3 + 8);
          uint64_t v19 = *(void *)(v3 + 16);
          ++*v18;
          unsigned int v20 = *(_DWORD *)(v19 + 8);
          if (v20 >= *(_DWORD *)(v19 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)v19 + 8 * v20) = a2;
          ++*(_DWORD *)(v19 + 8);
        }
        return result;
      }
    }
  }
  return result;
}

void llvm::computeDeadSymbolsWithConstProp(llvm **a1, llvm::ModuleSummaryIndex *a2, void (*a3)(uint64_t, void), uint64_t a4, int a5)
{
  llvm::computeDeadSymbolsAndUpdateIndirectCalls(a1, a2, a3, a4);
  if (a5)
  {
    llvm::ModuleSummaryIndex::propagateAttributes(a1, (uint64_t)a2);
  }
}

uint64_t llvm::gatherImportedSummariesForModule(unsigned __int8 *__s1, size_t __n, uint64_t *a3, uint64_t a4, uint64_t **a5)
{
  sub_1CC9133EC((uint64_t)&__dst, a3, __s1, __n);
  if (__n > 0x7FFFFFFFFFFFFFF7) {
LABEL_42:
  }
    abort();
  if (__n >= 0x17)
  {
    size_t v11 = (__n & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__n | 7) != 0x17) {
      size_t v11 = __n | 7;
    }
    size_t v12 = v11 + 1;
    uint64_t v10 = operator new(v11 + 1);
    __p[1] = (void *)__n;
    unint64_t v33 = v12 | 0x8000000000000000;
    __p[0] = v10;
    goto LABEL_8;
  }
  HIBYTE(v33) = __n;
  uint64_t v10 = __p;
  if (__n) {
LABEL_8:
  }
    memmove(v10, __s1, __n);
  *((unsigned char *)v10 + __n) = 0;
  uint64_t v13 = sub_1CC915F90(a5, (const void **)__p, (uint64_t)__p);
  MEMORY[0x1D25D9CD0](v13[7], 8);
  v13[7] = __dst;
  long long __dst = 0;
  uint64_t v13[8] = v35;
  *((_DWORD *)v13 + 18) = v36;
  if (SHIBYTE(v33) < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = MEMORY[0x1D25D9CD0](0, 8);
  uint64_t v15 = *(unsigned int *)(a4 + 8);
  if (v15)
  {
    for (uint64_t i = *(size_t ***)a4; !*i || *i + 1 == 0; ++i)
      ;
  }
  else
  {
    uint64_t i = *(size_t ***)a4;
  }
  uint64_t v18 = *(void *)a4 + 8 * v15;
  if (i != (size_t **)v18)
  {
    uint64_t v19 = *i;
    do
    {
      size_t v20 = *v19;
      if (*v19 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_42;
      }
      if (v20 >= 0x17)
      {
        uint64_t v22 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v20 | 7) != 0x17) {
          uint64_t v22 = v20 | 7;
        }
        uint64_t v23 = v22 + 1;
        p_dst = (void **)operator new(v22 + 1);
        uint64_t v35 = (uint64_t *)v20;
        unint64_t v36 = v23 | 0x8000000000000000;
        long long __dst = (uint64_t *)p_dst;
      }
      else
      {
        HIBYTE(v36) = *v19;
        p_dst = (void **)&__dst;
        if (!v20) {
          goto LABEL_30;
        }
      }
      memmove(p_dst, v19 + 6, v20);
LABEL_30:
      *((unsigned char *)p_dst + v20) = 0;
      uint64_t v24 = sub_1CC915F90(a5, (const void **)&__dst, (uint64_t)&__dst);
      if (SHIBYTE(v36) < 0) {
        operator delete(__dst);
      }
      sub_1CC9133EC((uint64_t)&__dst, a3, (unsigned __int8 *)v19 + 48, *v19);
      uint64_t v25 = (void *)v19[3];
      uint64_t v26 = (uint64_t)__dst;
      if (v25)
      {
        uint64_t v27 = (uint64_t)(v24 + 7);
        unsigned int v28 = v36;
        do
        {
          uint64_t v29 = sub_1CD661C80(v26, v28, v25[2])[1];
          sub_1CD5D47AC(v27, v25 + 2)[1] = v29;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      uint64_t result = MEMORY[0x1D25D9CD0](v26, 8);
      do
      {
        uint64_t v30 = i[1];
        ++i;
        uint64_t v19 = v30;
        if (v30) {
          BOOL v31 = v19 + 1 == 0;
        }
        else {
          BOOL v31 = 1;
        }
      }
      while (v31);
    }
    while (i != (size_t **)v18);
  }
  return result;
}

unint64_t llvm::EmitImportsFiles(const void *a1, size_t a2, unsigned char *a3, uint64_t a4, void *a5)
{
  LODWORD(v24[0]) = 0;
  v24[1] = std::system_category();
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v22, a3, a4, (uint64_t)v24, 0);
  if (LODWORD(v24[0]))
  {
    unint64_t v14 = v24[0] & 0xFFFFFFFF00000000;
    uint64_t v13 = LODWORD(v24[0]);
  }
  else
  {
    size_t v12 = (void *)*a5;
    uint64_t v10 = a5 + 1;
    size_t v11 = v12;
    if (v12 != v10)
    {
      do
      {
        char v16 = *((unsigned char *)v11 + 55);
        if (v16 >= 0) {
          uint64_t v17 = (const char *)(v11 + 4);
        }
        else {
          uint64_t v17 = (const char *)v11[4];
        }
        if (v16 >= 0) {
          size_t v18 = v16 & 0x7F;
        }
        else {
          size_t v18 = v11[5];
        }
        if (v18 != a2 || a2 && memcmp(v17, a1, a2))
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)v22, v17, v18);
          if ((unsigned char *)v22[3] == v23) {
            llvm::raw_ostream::write((llvm::raw_ostream *)v22, "\n", 1uLL);
          }
          else {
            *v23++ = 10;
          }
        }
        uint64_t v19 = (void *)v11[1];
        if (v19)
        {
          do
          {
            size_t v20 = v19;
            uint64_t v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            size_t v20 = (void *)v11[2];
            BOOL v21 = *v20 == (void)v11;
            size_t v11 = v20;
          }
          while (!v21);
        }
        size_t v11 = v20;
      }
      while (v20 != v10);
    }
    std::system_category();
    uint64_t v13 = 0;
    unint64_t v14 = 0;
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v22);
  return v14 | v13;
}

uint64_t sub_1CC9141BC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void **)a1;
  uint64_t v7 = sub_1CD4AC784((llvm::GlobalValue *)a2);
  uint64_t result = (uint64_t)sub_1CD661C80(*v6, *((_DWORD *)v6 + 4), v7);
  if (**(void **)a1 + 16 * *(unsigned int *)(*(void *)a1 + 16) != result)
  {
    uint64_t v10 = result;
    if (a3)
    {
      uint64_t v11 = *(void *)(result + 8);
      BOOL v12 = v11 && *(_DWORD *)(v11 + 8) == 1;
      if (v12 && *(unsigned char *)(a2 + 16) == 0)
      {
        int v14 = *(_DWORD *)(v11 + 68);
        if (v14)
        {
          uint64_t result = a2 + 112;
          uint64_t v15 = *(void *)(a2 + 112);
          if (!v15 || (*(unsigned char *)(v15 + 17) & 0x10) == 0)
          {
            uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)result, **(uint64_t ***)a2, -1, 44);
            *(void *)(a2 + 112) = result;
            int v14 = *(_DWORD *)(v11 + 68);
          }
        }
        if ((v14 & 2) != 0)
        {
          uint64_t result = a2 + 112;
          uint64_t v16 = *(void *)(a2 + 112);
          if (!v16 || (*(unsigned char *)(v16 + 17) & 0x30) == 0)
          {
            uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)result, **(uint64_t ***)a2, -1, 45);
            *(void *)(a2 + 112) = result;
            int v14 = *(_DWORD *)(v11 + 68);
          }
        }
        if ((v14 & 4) != 0)
        {
          uint64_t result = a2 + 112;
          uint64_t v17 = *(void *)(a2 + 112);
          if (!v17 || (*(unsigned char *)(v17 + 15) & 0x40) == 0)
          {
            uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)result, **(uint64_t ***)a2, -1, 30);
            *(void *)(a2 + 112) = result;
            int v14 = *(_DWORD *)(v11 + 68);
          }
        }
        if ((v14 & 0x40) != 0)
        {
          uint64_t result = a2 + 112;
          uint64_t v18 = *(void *)(a2 + 112);
          if (!v18 || (*(unsigned char *)(v18 + 16) & 0x20) == 0)
          {
            uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)result, **(uint64_t ***)a2, -1, 37);
            *(void *)(a2 + 112) = result;
          }
        }
      }
    }
    unsigned int v19 = *(_DWORD *)(a2 + 32);
    if ((v19 & 0xF) - 7 >= 2)
    {
      unsigned int v20 = *(unsigned __int16 *)(*(void *)(v10 + 8) + 12);
      int v21 = v20 & 0xF;
      if ((v21 - 7) >= 2)
      {
        if (*(unsigned char *)(a2 + 16))
        {
          if (*(unsigned char *)(a2 + 16) == 3 && (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) == 0) {
            return result;
          }
        }
        else if ((v19 & 0x800000) == 0 && *(void *)(a2 + 72) == a2 + 72)
        {
          return result;
        }
        int v22 = (v20 >> 4) & 3;
        if (v22)
        {
          *(_DWORD *)(a2 + 32) = v19 & 0xFFFFFFCF | (16 * (v22 & 3));
          uint64_t result = llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)a2);
          unsigned int v19 = *(_DWORD *)(a2 + 32);
          if ((result & 1) == 0)
          {
            v19 |= 0x4000u;
            *(_DWORD *)(a2 + 32) = v19;
          }
        }
        int v23 = v19 & 0xF;
        if (v23 != v21)
        {
          if (v21 == 5)
          {
            if ((*(_WORD *)(*(void *)(v10 + 8) + 12) & 0x200) != 0)
            {
              unsigned int v19 = v19 & 0xFFFFFFCF | 0x10;
              *(_DWORD *)(a2 + 32) = v19;
              if ((v23 - 7) < 2
                || (uint64_t result = llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)a2),
                    unsigned int v19 = *(_DWORD *)(a2 + 32),
                    (result & 1) == 0))
              {
                v19 |= 0x4000u;
              }
            }
          }
          else if (v21 == 1 && ((1 << v23) & 0x1EB) == 0)
          {
            uint64_t result = llvm::convertToDeclaration((llvm *)a2, v9);
            goto LABEL_48;
          }
          *(_DWORD *)(a2 + 32) = v19 & 0xFFFFFFF0 | v21;
          if ((v19 & 0x30) != 0)
          {
            uint64_t result = llvm::GlobalValue::hasExternalWeakLinkage((llvm::GlobalValue *)a2);
            if ((result & 1) == 0) {
              *(_DWORD *)(a2 + 32) |= 0x4000u;
            }
          }
LABEL_48:
          unsigned int v24 = *(unsigned __int8 *)(a2 + 16);
          if (v24 <= 3 && v24 != 1)
          {
            int v25 = *(_DWORD *)(a2 + 32);
            if ((v25 & 0xF) != 1)
            {
              if (*(unsigned char *)(a2 + 16))
              {
                if (v24 != 3 || (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) != 0) {
                  return result;
                }
              }
              else if ((v25 & 0x800000) != 0 || *(void *)(a2 + 72) != a2 + 72)
              {
                return result;
              }
            }
            uint64_t result = *(void *)(a2 + 48);
            if (result)
            {
              uint64_t result = (uint64_t)llvm::Comdat::removeUser(result, a2);
              *(void *)(a2 + 48) = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CC9144B8(llvm::Module *a1, void *a2, llvm::CallGraph *a3)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)a2[3];
  if (!v5)
  {
    uint64_t v9 = 0;
    v10[0] = 0;
    goto LABEL_5;
  }
  if (v5 != a2)
  {
    uint64_t v9 = (void *)a2[3];
    a2[3] = 0;
    v10[0] = 0;
    goto LABEL_7;
  }
  uint64_t v9 = v8;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v8);
  uint64_t v5 = v9;
  v10[0] = 0;
  if (!v9)
  {
LABEL_5:
    BOOL v12 = 0;
    goto LABEL_10;
  }
LABEL_7:
  if (v5 == v8)
  {
    BOOL v12 = v11;
    (*(void (**)(void *, void *))(v8[0] + 24))(v8, v11);
  }
  else
  {
    BOOL v12 = v5;
    uint64_t v9 = 0;
  }
LABEL_10:
  v13[0] = 0;
  v13[1] = 0;
  void v13[2] = 0x800000000;
  uint64_t v6 = llvm::InternalizePass::internalizeModule((llvm::InternalizePass *)v10, a1, a3);
  sub_1CC0D7CD8((uint64_t)v13);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  return v6;
}

BOOL sub_1CC9146E4(void *a1, void *a2)
{
  sub_1CC905D80((uint64_t)a1, a2, (uint64_t)&v17);
  int v4 = v18;
  if (v18)
  {
    uint64_t v6 = (void *)a1[4];
    unint64_t v5 = a1[5];
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = (void *)a1[3];
      uint64_t v9 = v6 - v8;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61) {
        abort();
      }
      uint64_t v11 = v5 - (void)v8;
      if (v11 >> 2 > v10) {
        unint64_t v10 = v11 >> 2;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 61) {
          sub_1CB833614();
        }
        uint64_t v13 = (char *)operator new(8 * v12);
      }
      else
      {
        uint64_t v13 = 0;
      }
      int v14 = &v13[8 * v9];
      *(void *)int v14 = *a2;
      uint64_t v7 = v14 + 8;
      if (v6 != v8)
      {
        do
        {
          uint64_t v15 = *--v6;
          *((void *)v14 - 1) = v15;
          v14 -= 8;
        }
        while (v6 != v8);
        uint64_t v6 = (void *)a1[3];
      }
      a1[3] = v14;
      a1[4] = v7;
      a1[5] = &v13[8 * v12];
      if (v6) {
        operator delete(v6);
      }
    }
    else
    {
      *uint64_t v6 = *a2;
      uint64_t v7 = v6 + 1;
    }
    a1[4] = v7;
  }
  return v4 != 0;
}

uint64_t sub_1CC914804(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (byte_1EBCDF43F >= 0) {
    uint64_t v1 = byte_1EBCDF43F & 0x7F;
  }
  else {
    uint64_t v1 = qword_1EBCDF430;
  }
  if (!v1) {
    llvm::report_fatal_error((llvm *)"error: -function-import requires -summary-file\n", (const llvm::Twine *)1);
  }
  if (byte_1EBCDF43F >= 0) {
    uint64_t v3 = &qword_1EBCDF428;
  }
  else {
    uint64_t v3 = (uint64_t *)qword_1EBCDF428;
  }
  llvm::getModuleSummaryIndexForFile((uint64_t)v3, v1, 0, (uint64_t)&v27);
  if ((v28 & 1) == 0)
  {
    unint64_t v5 = v27;
    uint64_t v27 = 0;
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = 0uLL;
    v21.__r_.__value_.__r.__words[2] = 0x3000000000;
    char v6 = *(unsigned char *)(a1 + 191);
    if (v6 >= 0) {
      uint64_t v7 = (void *)(a1 + 168);
    }
    else {
      uint64_t v7 = *(void **)(a1 + 168);
    }
    if (v6 >= 0) {
      size_t v8 = v6 & 0x7F;
    }
    else {
      size_t v8 = *(void *)(a1 + 176);
    }
    if (byte_1EBCDF368) {
      llvm::ComputeCrossModuleImportForModuleFromIndex((uint64_t)v7, v8, v5, (uint64_t)&v21);
    }
    else {
      llvm::ComputeCrossModuleImportForModule(v7, v8, (uint64_t)v5, (uint64_t)&v21);
    }
    uint64_t v13 = (void *)*v5;
    if ((void *)*v5 != v5 + 1)
    {
      do
      {
        uint64_t v14 = v13[7];
        uint64_t v15 = v13[8];
        while (v14 != v15)
        {
          __int16 v16 = *(_WORD *)(*(void *)v14 + 12);
          if ((v16 & 0xFu) - 7 <= 1) {
            *(_WORD *)(*(void *)v14 + 12) = v16 & 0xFFF0;
          }
          v14 += 8;
        }
        uint64_t v17 = (void *)v13[1];
        if (v17)
        {
          do
          {
            unsigned __int8 v18 = v17;
            uint64_t v17 = (void *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            unsigned __int8 v18 = (void *)v13[2];
            BOOL v19 = *v18 == (void)v13;
            uint64_t v13 = v18;
          }
          while (!v19);
        }
        uint64_t v13 = v18;
      }
      while (v18 != v5 + 1);
    }
    llvm::renameModuleForThinLTO(a1, (uint64_t)v5, 0, 0);
  }
  uint64_t v9 = v27;
  uint64_t v27 = 0;
  unsigned int v24 = v9;
  unint64_t v10 = (llvm::raw_ostream *)llvm::errs(v4);
  std::operator+<char>();
  uint64_t v11 = std::string::append(&v21, "': ");
  std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
  long long v25 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  std::string::size_type v26 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  __int16 v23 = 260;
  int v22 = &v25;
  llvm::logAllUnhandledErrors((llvm::raw_ostream *)&v24, v10, (uint64_t)&v22);
  if (SHIBYTE(v26) < 0) {
    operator delete((void *)v25);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (v24) {
    (*(void (**)(void *))(*v24 + 8))(v24);
  }
  sub_1CD663484((uint64_t)&v27);
  return 0;
}

void llvm::initializeFunctionImportLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCDE9D8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC914CA8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCDE9D8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC914CA8()
{
}

uint64_t sub_1CC914D44(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a7;
  uint64_t v10 = a6;
  uint64_t v11 = a5;
  uint64_t v14 = a2;
  uint64_t result = sub_1CC91558C(a1, a2, a4, a5, a6, a7);
  uint64_t v101 = a1;
  unsigned __int8 v18 = *(uint64_t **)(a1 + 80);
  uint64_t v17 = *(uint64_t **)(a1 + 88);
  if (v17 == v18) {
    return result;
  }
  float v19 = (float)a3;
  do
  {
    uint64_t v20 = *v18;
    uint64_t v113 = *v18;
    if ((dword_1EBCDEB28 & 0x80000000) == 0 && dword_1EBCDE9E0 >= dword_1EBCDEB28) {
      goto LABEL_7;
    }
    std::string::size_type v21 = *(void *)(v20 & 0xFFFFFFFFFFFFFFF8);
    int v22 = *(_DWORD *)(a4 + 16);
    if (v22)
    {
      int v23 = v22 - 1;
      unsigned int v24 = v23 & (37 * v21);
      uint64_t v25 = *(void *)(*(void *)a4 + 16 * v24);
      if (v21 == v25) {
        goto LABEL_7;
      }
      int v26 = 1;
      while (v25 != -1)
      {
        unsigned int v27 = v24 + v26++;
        unsigned int v24 = v27 & v23;
        uint64_t v25 = *(void *)(*(void *)a4 + 16 * v24);
        if (v21 == v25) {
          goto LABEL_7;
        }
      }
    }
    int v28 = v18[1] & 7;
    if (v28 == 1)
    {
      int v29 = dword_1EBCDEFA8;
    }
    else if (v28 == 4)
    {
      int v29 = dword_1EBCDEEE8;
    }
    else
    {
      *(float *)&int v29 = 1.0;
      if (v28 == 3) {
        int v29 = dword_1EBCDEE28;
      }
    }
    float v30 = *(float *)&v29 * v19;
    v114.__r_.__value_.__r.__words[0] = v21;
    unsigned int v102 = (float)(*(float *)&v29 * v19);
    LODWORD(v114.__r_.__value_.__r.__words[1]) = v102;
    v114.__r_.__value_.__r.__words[2] = 0;
    uint64_t v115 = 0;
    sub_1CD662CF4((uint64_t)&v111, a8, (uint64_t *)&v114, (uint64_t)&v114.__r_.__value_.__l.__size_);
    uint64_t result = v115;
    if (v115) {
      uint64_t result = MEMORY[0x1D25D9CE0](v115, 0x1000C40669B30A5);
    }
    uint64_t v31 = v111;
    int v32 = *((_DWORD *)v18 + 2);
    uint64_t v33 = *(void *)(v111 + 16);
    if (v33)
    {
      if (v30 > (float)*(unsigned int *)(v111 + 8))
      {
        *(_DWORD *)(v111 + 8) = v102;
        goto LABEL_24;
      }
      goto LABEL_7;
    }
    int v38 = v112;
    unsigned int v39 = v102;
    if (!v112 && v30 <= (float)*(unsigned int *)(v111 + 8))
    {
      if (byte_1EBCDF128) {
        ++*(_DWORD *)(*(void *)(v111 + 24) + 16);
      }
      goto LABEL_7;
    }
    uint64_t v98 = v14;
    uint64_t v99 = v11;
    uint64_t v95 = v10;
    uint64_t v96 = v9;
    uint64_t v97 = a8;
    int v41 = *(uint64_t **)((v113 & 0xFFFFFFFFFFFFFFF8) + 24);
    uint64_t v40 = *(uint64_t **)((v113 & 0xFFFFFFFFFFFFFFF8) + 32);
    uint64_t v42 = (char *)v40 - (char *)v41;
    if (v40 == v41)
    {
      int v48 = 0;
LABEL_58:
      *(void *)(v31 + 16) = 0;
      if (v38)
      {
        uint64_t v14 = v98;
        uint64_t v11 = v99;
        if (byte_1EBCDF128) {
          operator new();
        }
      }
      else
      {
        *(_DWORD *)(v31 + 8) = v39;
        uint64_t v14 = v98;
        uint64_t v11 = v99;
        if (byte_1EBCDF128)
        {
          uint64_t v52 = *(void *)(v31 + 24);
          int v53 = *(_DWORD *)(v52 + 16) + 1;
          *(_DWORD *)(v52 + 12) = v48;
          *(_DWORD *)(v52 + 16) = v53;
          unsigned int v54 = v18[1] & 7;
          if (*(unsigned __int8 *)(v52 + 8) > v54) {
            LOBYTE(v54) = *(unsigned char *)(v52 + 8);
          }
          *(unsigned char *)(v52 + 8) = v54;
        }
      }
      if (!byte_1EBCDEBE8)
      {
        uint64_t v9 = v96;
        a8 = v97;
        uint64_t v10 = v95;
        goto LABEL_7;
      }
      v107.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
      *(_OWORD *)&v107.__r_.__value_.__r.__words[1] = xmmword_1CD96DBE0;
      strcpy(v107.__r_.__value_.__l.__data_, "Failed to import function ");
      unint64_t v58 = v113 & 0xFFFFFFFFFFFFFFF8;
      if (v113)
      {
        int v61 = *(uint64_t ****)(v58 + 8);
        if ((*((unsigned char *)v61 + 23) & 0x10) != 0)
        {
          uint64_t v62 = ***v61;
          uint64_t v63 = *(void *)(v62 + 152);
          uint64_t v64 = *(unsigned int *)(v62 + 168);
          if (v64)
          {
            LODWORD(v65) = (v64 - 1) & ((v61 >> 4) ^ (v61 >> 9));
            uint64_t v66 = (uint64_t ****)(v63 + 16 * v65);
            unsigned int v67 = *v66;
            if (*v66 != v61)
            {
              int v68 = 1;
              do
              {
                if (v67 == (uint64_t ***)-4096) {
                  goto LABEL_86;
                }
                int v69 = v65 + v68++;
                uint64_t v65 = v69 & (v64 - 1);
                unsigned int v67 = *(uint64_t ****)(v63 + 16 * v65);
              }
              while (v67 != v61);
              uint64_t v66 = (uint64_t ****)(v63 + 16 * v65);
            }
          }
          else
          {
LABEL_86:
            uint64_t v66 = (uint64_t ****)(v63 + 16 * v64);
          }
          uint64_t v73 = v66[1];
          size_t v74 = (size_t)*v73;
          uint64_t v59 = (char *)(v73 + 2);
          size_t v60 = v74;
        }
        else
        {
          size_t v60 = 0;
          uint64_t v59 = &byte_1CFBCE98E;
        }
      }
      else
      {
        uint64_t v59 = *(char **)(v58 + 8);
        if (!v59)
        {
          std::string::size_type v70 = 0;
          unsigned int v71 = 0;
          char v72 = 0;
          long long __dst = 0;
          size_t v105 = 0;
          unint64_t v106 = 0;
          goto LABEL_97;
        }
        size_t v60 = *(void *)(v58 + 16);
      }
      if (v60 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v60 >= 0x17)
      {
        uint64_t v76 = (v60 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v60 | 7) != 0x17) {
          uint64_t v76 = v60 | 7;
        }
        uint64_t v77 = v76 + 1;
        p_dst = (void **)operator new(v76 + 1);
        size_t v105 = v60;
        unint64_t v106 = v77 | 0x8000000000000000;
        long long __dst = p_dst;
      }
      else
      {
        HIBYTE(v106) = v60;
        p_dst = (void **)&__dst;
        if (!v60) {
          goto LABEL_96;
        }
      }
      memmove(p_dst, v59, v60);
LABEL_96:
      *((unsigned char *)p_dst + v60) = 0;
      char v72 = HIBYTE(v106);
      unsigned int v71 = (const std::string::value_type *)__dst;
      std::string::size_type v70 = v105;
LABEL_97:
      BOOL v78 = v72 < 0;
      if (v72 >= 0) {
        uint64_t v79 = (const std::string::value_type *)&__dst;
      }
      else {
        uint64_t v79 = v71;
      }
      std::string::size_type v80 = v72 & 0x7F;
      if (v78) {
        std::string::size_type v81 = v70;
      }
      else {
        std::string::size_type v81 = v80;
      }
      BOOL v82 = std::string::append(&v107, v79, v81);
      std::string::size_type v83 = v82->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v108.__r_.__value_.__l.__data_ = *(_OWORD *)&v82->__r_.__value_.__l.__data_;
      v108.__r_.__value_.__r.__words[2] = v83;
      v82->__r_.__value_.__l.__size_ = 0;
      v82->__r_.__value_.__r.__words[2] = 0;
      v82->__r_.__value_.__r.__words[0] = 0;
      uint64_t v84 = std::string::append(&v108, " due to ");
      std::string::size_type v85 = v84->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v114.__r_.__value_.__l.__data_ = *(_OWORD *)&v84->__r_.__value_.__l.__data_;
      v114.__r_.__value_.__r.__words[2] = v85;
      v84->__r_.__value_.__l.__size_ = 0;
      v84->__r_.__value_.__r.__words[2] = 0;
      v84->__r_.__value_.__r.__words[0] = 0;
      uint64_t v86 = std::string::append(&v114, off_1E684AAF0[v48]);
      std::string::size_type v87 = v86->__r_.__value_.__r.__words[2];
      long long v109 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
      std::string::size_type v110 = v87;
      v86->__r_.__value_.__l.__size_ = 0;
      v86->__r_.__value_.__r.__words[2] = 0;
      v86->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v114.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v108.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v106) < 0) {
        operator delete(__dst);
      }
      if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v107.__r_.__value_.__l.__data_);
      }
      std::generic_category();
      operator new();
    }
    int v88 = *((_DWORD *)v18 + 2);
    size_t v43 = *(void *)(v101 + 32);
    __s2 = *(void **)(v101 + 24);
    uint64_t v92 = (char *)v40 - (char *)v41;
    int v44 = *(unsigned __int8 *)(v14 + 128);
    int v45 = byte_1EBCDEBE8;
    uint64_t v46 = 8 * (v42 >> 3);
    uint64_t v94 = v111;
    int v93 = v112;
    size_t __n = v43;
    int v89 = byte_1EBCDEBE8;
    int v90 = v44;
    while (1)
    {
      uint64_t v33 = *v41;
      __int16 v47 = *(_WORD *)(*v41 + 12);
      if (!v44 || (v47 & 0x80) != 0) {
        break;
      }
      int v48 = 2;
LABEL_55:
      ++v41;
      v46 -= 8;
      if (!v46) {
        goto LABEL_58;
      }
    }
    int v49 = v47 & 0xF;
    int v48 = 4;
    if (((1 << (v47 & 0xF)) & 0x1EB) == 0) {
      goto LABEL_55;
    }
    int v50 = *(_DWORD *)(v33 + 8);
    uint64_t v51 = *v41;
    if (!v50)
    {
      uint64_t v51 = *(void *)(v33 + 72);
      __int16 v47 = *(_WORD *)(v51 + 12);
      int v49 = v47 & 0xF;
    }
    if ((unint64_t)v42 >= 9 && (v49 - 7) <= 1)
    {
      if (*(void *)(v51 + 32) != v43) {
        goto LABEL_45;
      }
      if (v43)
      {
        uint64_t result = memcmp(*(const void **)(v51 + 24), __s2, __n);
        int v45 = v89;
        int v44 = v90;
        size_t v43 = __n;
        uint64_t v42 = v92;
        int v38 = v93;
        unsigned int v39 = v102;
        uint64_t v31 = v94;
        if (result)
        {
LABEL_45:
          int v48 = 5;
          goto LABEL_55;
        }
      }
    }
    if (*(_DWORD *)(v51 + 64) > v39 && (*(unsigned char *)(v51 + 68) & 0x20) == 0 && !v45)
    {
      int v48 = 3;
      goto LABEL_55;
    }
    if ((v47 & 0x40) != 0)
    {
      int v48 = 6;
      goto LABEL_55;
    }
    if ((*(unsigned char *)(v51 + 68) & 0x10) != 0 && !v45)
    {
      int v48 = 7;
      goto LABEL_55;
    }
    *(void *)(v31 + 16) = v33;
    if (!v50) {
      uint64_t v33 = *(void *)(v33 + 72);
    }
    uint64_t v11 = v99;
    *(void *)(v31 + 16) = v33;
    uint64_t v55 = *(unsigned __int8 **)(v33 + 24);
    uint64_t v10 = v95;
    size_t v103 = *(void *)(v33 + 32);
    uint64_t v56 = sub_1CD66421C(v95, v55, v103);
    uint64_t result = sub_1CC9157BC(*v56 + 8, *(void *)(v113 & 0xFFFFFFFFFFFFFFF8), *(void *)(v113 & 0xFFFFFFFFFFFFFFF8));
    uint64_t v9 = v96;
    a8 = v97;
    if (v96)
    {
      uint64_t v57 = sub_1CD663184(v96, v55, v103);
      uint64_t result = sub_1CD4AD7E0((uint64_t)(*v57 + 1), &v113, (uint64_t)&v114);
    }
    uint64_t v14 = v98;
    LOBYTE(v32) = v88;
LABEL_24:
    if ((v32 & 7) == 3) {
      unint64_t v34 = &dword_1EBCDED68;
    }
    else {
      unint64_t v34 = &dword_1EBCDECA8;
    }
    float v35 = *(float *)v34 * v19;
    ++dword_1EBCDE9E0;
    uint64_t v36 = *(unsigned int *)(v11 + 8);
    if (v36 >= *(_DWORD *)(v11 + 12))
    {
      uint64_t result = sub_1CD663284(v11, v33, v35);
    }
    else
    {
      uint64_t v37 = *(void *)v11 + 16 * v36;
      *(void *)uint64_t v37 = v33;
      *(_DWORD *)(v37 + 8) = v35;
      *(_DWORD *)(v11 + 8) = v36 + 1;
    }
LABEL_7:
    v18 += 2;
  }
  while (v18 != v17);
  return result;
}

uint64_t sub_1CC91558C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char v6 = *(void **)(result + 40);
  int v29 = *(void **)(result + 48);
  if (v29 == v6) {
    return result;
  }
  uint64_t v9 = result;
  do
  {
    uint64_t v10 = (uint64_t *)(*v6 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v11 = *(void *)a3;
    uint64_t v12 = *(unsigned int *)(a3 + 16);
    uint64_t result = (uint64_t)sub_1CD661C80(*(void *)a3, *(_DWORD *)(a3 + 16), *v10);
    uint64_t v14 = (uint64_t *)v10[3];
    uint64_t v13 = (uint64_t *)v10[4];
    uint64_t v15 = (char *)v13 - (char *)v14;
    if (v11 + 16 * v12 != result
      && ((unint64_t)v15 < 9 || ((1 << (*(_WORD *)(*(void *)(result + 8) + 12) & 0xF)) & 0x1EB) != 0)
      || v13 == v14)
    {
      goto LABEL_15;
    }
    uint64_t v17 = *(const void **)(v9 + 24);
    size_t v16 = *(void *)(v9 + 32);
    uint64_t v18 = 8 * (v15 >> 3);
    while (1)
    {
      uint64_t v19 = *v14;
      if (*(_DWORD *)(*v14 + 8) != 2) {
        goto LABEL_14;
      }
      uint64_t result = llvm::ModuleSummaryIndex::canImportGlobalVar(a2, *v14, 1);
      if (!result) {
        goto LABEL_14;
      }
      uint64_t v20 = *(unsigned __int8 **)(v19 + 24);
      if ((*(_WORD *)(v19 + 12) & 0xFu) - 7 > 1) {
        break;
      }
      if (*(void *)(v19 + 32) == v16)
      {
        if (!v16) {
          goto LABEL_18;
        }
        uint64_t result = memcmp(*(const void **)(v19 + 24), v17, v16);
        if (!result) {
          goto LABEL_18;
        }
      }
LABEL_14:
      ++v14;
      v18 -= 8;
      if (!v18) {
        goto LABEL_15;
      }
    }
    size_t v16 = *(void *)(v19 + 32);
LABEL_18:
    std::string::size_type v21 = sub_1CD66421C(a5, v20, v16);
    uint64_t result = sub_1CC9157BC(*v21 + 8, *(void *)(*v6 & 0xFFFFFFFFFFFFFFF8), *(void *)(*v6 & 0xFFFFFFFFFFFFFFF8));
    if (result)
    {
      if (a6)
      {
        uint64_t v25 = sub_1CD663184(a6, *(unsigned __int8 **)(*v14 + 24), *(void *)(*v14 + 32));
        uint64_t result = sub_1CD4AD7E0((uint64_t)(*v25 + 1), v6, (uint64_t)v30);
      }
      uint64_t v22 = *v14;
      if (!*(unsigned char *)(a2 + 129) || (*(unsigned char *)(v22 + 72) & 2) == 0)
      {
        uint64_t v23 = *(unsigned int *)(a4 + 8);
        if (v23 >= *(_DWORD *)(a4 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v24 = *(void *)a4 + 16 * v23;
        *(void *)uint64_t v24 = v22;
        *(_DWORD *)(v24 + 8) = 0;
        *(_DWORD *)(a4 + 8) = v23 + 1;
      }
    }
LABEL_15:
    ++v6;
  }
  while (v6 != v29);
  return result;
}

uint64_t sub_1CC9157BC(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = (void *)*v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return 0;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = operator new(0x18uLL);
  *uint64_t v12 = 0;
  v12[1] = a2;
  uint64_t v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_1CC7C0688(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *uint64_t v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }
  *uint64_t v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }
    else
    {
      v21 &= v7 - 1;
    }
    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return 1;
}

void *sub_1CC9159BC(void *a1)
{
  return a1;
}

void sub_1CC915A04()
{
}

void *sub_1CC915A18(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F2628280;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC915A60(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2628280;
  a2[1] = v2;
  return result;
}

void sub_1CC915A8C(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v26[21] = *MEMORY[0x1E4F143B8];
  size_t v3 = *(void *)(a1 + 8);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  int v4 = *(const void **)a1;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    p_dst = (void **)operator new(v6 + 1);
    std::string::size_type v14 = v3;
    int64_t v15 = v7 | 0x8000000000000000;
    long long __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v15) = *(void *)(a1 + 8);
  p_dst = (void **)&__dst;
  if (v3) {
LABEL_8:
  }
    memmove(p_dst, v4, v3);
  *((unsigned char *)p_dst + v3) = 0;
  *(_OWORD *)unint64_t v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  *(_OWORD *)uint64_t v20 = 0u;
  *(_OWORD *)unint64_t v21 = 0u;
  long long v22 = 0u;
  *(_OWORD *)long long __p = 0u;
  uint64_t v24 = 0;
  v25[0] = v26;
  if (v15 >= 0) {
    uint8x8_t v8 = (const std::string::value_type *)&__dst;
  }
  else {
    uint8x8_t v8 = (const std::string::value_type *)__dst;
  }
  int v19 = 0;
  if (v15 >= 0) {
    std::string::size_type v9 = HIBYTE(v15) & 0x7F;
  }
  else {
    std::string::size_type v9 = v14;
  }
  v25[1] = (void *)0x400000000;
  llvm::getLazyIRFileModule(v8, v9, (uint64_t)&v16, &v12);
  if (!v12)
  {
    unint64_t v11 = (llvm::raw_ostream *)llvm::errs(v10);
    llvm::SMDiagnostic::print((llvm::SMDiagnostic *)&v16, "function-import", v11, 1, 1);
    llvm::report_fatal_error((llvm *)"Abort", (const llvm::Twine *)1);
  }
  sub_1CC1925A4(v25);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[1]);
  }
  if (SHIBYTE(v21[0]) < 0) {
    operator delete(v20[0]);
  }
  if (SBYTE7(v18) < 0) {
    operator delete(v17[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__dst);
  }
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = v12;
}

void sub_1CC915C94()
{
}

void sub_1CC915CF4(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC915D2C()
{
  return "Function Importing";
}

uint64_t sub_1CC915D3C(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }

  return sub_1CC914804((uint64_t)a2);
}

void *sub_1CC915D88(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n)
{
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (!v5)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    uint64_t v25 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v25) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v25[16] = 2;
    *(void *)a1 = v25;
    unsigned int v5 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  int v6 = 0;
  if (__n)
  {
    size_t v7 = __n;
    uint8x8_t v8 = a2;
    do
    {
      int v9 = *v8++;
      int v6 = 33 * v6 + v9;
      --v7;
    }
    while (v7);
  }
  uint64_t v10 = *(void *)a1;
  unsigned int v11 = v5 - 1;
  uint64_t v12 = *(void *)a1 + 8 * v5 + 8;
  int v13 = -1;
  int v14 = 1;
  int v15 = v6;
  while (1)
  {
    uint64_t v16 = v15 & v11;
    unint64_t v17 = *(void **)(v10 + 8 * v16);
    if (!v17) {
      break;
    }
    if (v17 == (void *)-8)
    {
      if (v13 == -1) {
        int v13 = v15 & v11;
      }
    }
    else if (*(_DWORD *)(v12 + 4 * v16) == v6 {
           && __n == *v17
    }
           && (!__n || !memcmp(a2, (char *)v17 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_20;
    }
    int v15 = v14 + v16;
    ++v14;
  }
  uint64_t v18 = v13;
  if (v13 == -1)
  {
    uint64_t v18 = v16;
    uint64_t v16 = v16;
  }
  else
  {
    uint64_t v16 = v13;
  }
  *(_DWORD *)(v12 + 4 * v18) = v6;
  unint64_t v17 = *(void **)(v10 + 8 * v16);
LABEL_20:
  uint64_t i = (void *)(v10 + 8 * v16);
  if (v17 == (void *)-8)
  {
    --*((_DWORD *)a1 + 4);
  }
  else if (v17)
  {
    return i;
  }
  uint64_t v20 = operator new(__n + 41, (std::align_val_t)8uLL);
  unint64_t v21 = v20;
  long long v22 = (char *)(v20 + 5);
  if (__n) {
    memcpy(v20 + 5, a2, __n);
  }
  v22[__n] = 0;
  *unint64_t v21 = __n;
  v21[1] = 0;
  void v21[2] = 0;
  void v21[3] = 0x3000000000;
  *uint64_t i = v21;
  ++*((_DWORD *)a1 + 3);
  for (uint64_t i = (void *)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v16));
        !*i || *i == -8;
  return i;
}

uint64_t **sub_1CC915F90(uint64_t **a1, const void **a2, uint64_t a3)
{
  int v6 = a1 + 1;
  unsigned int v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      size_t v8 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v8 = (size_t)a2[1];
    }
    if (v7 >= 0) {
      int v9 = a2;
    }
    else {
      int v9 = *a2;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v10 = (uint64_t **)v5;
        int v13 = (const void *)v5[4];
        unsigned int v11 = v5 + 4;
        uint64_t v12 = v13;
        size_t v14 = *((unsigned __int8 *)v11 + 23);
        if ((v14 & 0x80u) == 0) {
          int v15 = v11;
        }
        else {
          int v15 = v12;
        }
        size_t v16 = v11[1];
        if ((v14 & 0x80u) == 0) {
          size_t v17 = v14 & 0x7F;
        }
        else {
          size_t v17 = v11[1];
        }
        if (v17 >= v8) {
          size_t v18 = v8;
        }
        else {
          size_t v18 = v17;
        }
        int v19 = memcmp(v9, v15, v18);
        BOOL v20 = v8 < v17;
        if (v19) {
          BOOL v20 = v19 < 0;
        }
        if (!v20) {
          break;
        }
        unsigned int v5 = *v10;
        int v6 = v10;
        if (!*v10) {
          goto LABEL_33;
        }
      }
      if ((v14 & 0x80u) != 0) {
        size_t v14 = v16;
      }
      if (v8 >= v14) {
        size_t v21 = v14;
      }
      else {
        size_t v21 = v8;
      }
      int v22 = memcmp(v15, v9, v21);
      BOOL v23 = v14 < v8;
      if (v22) {
        BOOL v23 = v22 < 0;
      }
      if (!v23) {
        break;
      }
      unsigned int v5 = v10[1];
      if (!v5)
      {
        int v6 = v10 + 1;
        goto LABEL_33;
      }
    }
  }
  else
  {
    uint64_t v10 = a1 + 1;
LABEL_33:
    uint64_t v24 = (uint64_t *)v10;
    uint64_t v10 = (uint64_t **)operator new(0x50uLL);
    *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
    uint64_t v25 = *(uint64_t **)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    v10[7] = 0;
    unsigned char v10[8] = 0;
    v10[6] = v25;
    *((_DWORD *)v10 + 18) = 0;
    *uint64_t v10 = 0;
    v10[1] = 0;
    void v10[2] = v24;
    *int v6 = (uint64_t *)v10;
    int v26 = (uint64_t *)**a1;
    unsigned int v27 = (uint64_t *)v10;
    if (v26)
    {
      *a1 = v26;
      unsigned int v27 = *v6;
    }
    sub_1CB8358B8(a1[1], v27);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

void sub_1CC91611C()
{
}

__n128 sub_1CC916130(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F2628368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CC91617C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2628368;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_1CC9161AC(uint64_t a1, llvm::GlobalValue *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = sub_1CD4AC784(a2);
  int v6 = sub_1CD661C80(*(void *)v4, *(_DWORD *)(v4 + 16), v5);
  if ((uint64_t *)(**(void **)(a1 + 8) + 16 * *(unsigned int *)(*(void *)(a1 + 8) + 16)) != v6) {
    return (*(_WORD *)(v6[1] + 12) & 0xFu) - 9 < 0xFFFFFFFE;
  }
  if ((*((unsigned char *)a2 + 23) & 0x10) == 0)
  {
    size_t v18 = 0;
    size_t v17 = &byte_1CFBCE98E;
    goto LABEL_12;
  }
  uint64_t v8 = ***(void ***)a2;
  uint64_t v9 = *(void *)(v8 + 152);
  uint64_t v10 = *(unsigned int *)(v8 + 168);
  if (!v10) {
    goto LABEL_10;
  }
  LODWORD(v11) = (v10 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v12 = (llvm::GlobalValue **)(v9 + 16 * v11);
  int v13 = *v12;
  if (*v12 != a2)
  {
    int v14 = 1;
    while (v13 != (llvm::GlobalValue *)-4096)
    {
      int v15 = v11 + v14++;
      uint64_t v11 = v15 & (v10 - 1);
      int v13 = *(llvm::GlobalValue **)(v9 + 16 * v11);
      if (v13 == a2)
      {
        uint64_t v12 = (llvm::GlobalValue **)(v9 + 16 * v11);
        goto LABEL_11;
      }
    }
LABEL_10:
    uint64_t v12 = (llvm::GlobalValue **)(v9 + 16 * v10);
  }
LABEL_11:
  size_t v16 = v12[1];
  size_t v19 = *(void *)v16;
  size_t v17 = (char *)v16 + 16;
  size_t v18 = v19;
LABEL_12:
  *(void *)&long long v36 = v17;
  *((void *)&v36 + 1) = v18;
  unint64_t v20 = llvm::StringRef::rfind((uint64_t *)&v36, ".llvm.", 6uLL);
  if (v18 >= v20) {
    size_t v21 = v20;
  }
  else {
    size_t v21 = v18;
  }
  if (v20 != -1) {
    size_t v18 = v21;
  }
  uint64_t v22 = *(void *)(a1 + 16);
  uint64_t v25 = *(const std::string::value_type **)(v22 + 192);
  uint64_t v23 = v22 + 192;
  uint64_t v24 = v25;
  char v26 = *(unsigned char *)(v23 + 23);
  if (v26 >= 0) {
    unsigned int v27 = (const std::string::value_type *)v23;
  }
  else {
    unsigned int v27 = v24;
  }
  std::string::size_type v28 = *(void *)(v23 + 8);
  if (v26 >= 0) {
    std::string::size_type v29 = v26 & 0x7F;
  }
  else {
    std::string::size_type v29 = v28;
  }
  llvm::GlobalValue::getGlobalIdentifier(v17, v18, 7, v27, v29, &__p);
  uint64_t v30 = *(void *)(a1 + 8);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = (int *)&__p;
  }
  else {
    p_p = (int *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t size = __p.__r_.__value_.__l.__size_;
  }
  long long v36 = xmmword_1CFAC4320;
  uint64_t v37 = 0;
  llvm::MD5::update((int *)&v36, p_p, size);
  llvm::MD5::final((int *)&v36, (int *)v35);
  int v6 = sub_1CD661C80(*(void *)v30, *(_DWORD *)(v30 + 16), v35[0]);
  uint64_t v33 = *(void *)(a1 + 8);
  if ((uint64_t *)(*(void *)v33 + 16 * *(unsigned int *)(v33 + 16)) == v6)
  {
    long long v36 = xmmword_1CFAC4320;
    uint64_t v37 = 0;
    llvm::MD5::update((int *)&v36, (int *)v17, v18);
    llvm::MD5::final((int *)&v36, (int *)v35);
    int v6 = sub_1CD661C80(*(void *)v33, *(_DWORD *)(v33 + 16), v35[0]);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return (*(_WORD *)(v6[1] + 12) & 0xFu) - 9 < 0xFFFFFFFE;
}

void *sub_1CC91641C(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  __n128 result = sub_1CC9164B8(a1, &v10, a2);
  if (!*result)
  {
    int v6 = result;
    int v7 = operator new(0x30uLL);
    void v7[2] = *a3;
    uint64_t v8 = v10;
    *(void *)int v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v8;
    *int v6 = v7;
    uint64_t v9 = **(void **)a1;
    if (v9)
    {
      *(void *)a1 = v9;
      int v7 = (_OWORD *)*v6;
    }
    __n128 result = sub_1CB8358B8(*(uint64_t **)(a1 + 8), (uint64_t *)v7);
    ++*(void *)(a1 + 16);
  }
  return result;
}

void *sub_1CC9164B8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = v4;
        uint64_t v9 = (uint64_t)(v4 + 4);
        if (!sub_1CC016A40(v7, a3, (uint64_t)(v4 + 4))) {
          break;
        }
        uint64_t v4 = (void *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (!sub_1CC016A40(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_8:
  *a2 = v8;
  return v5;
}

uint64_t sub_1CC916558()
{
  LODWORD(v1) = 100;
  int v3 = 1;
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"N";
  v5.n128_u64[1] = 1;
  v2.n128_u64[0] = (unint64_t)"Only import functions with less than N instructions";
  v2.n128_u64[1] = 51;
  sub_1CD663500((int **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCDE9E8, &dword_1CB82C000);
  LODWORD(v1) = -1;
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"N";
  int v3 = 1;
  v5.n128_u64[1] = 1;
  v2.n128_u64[0] = (unint64_t)"Only import first N functions if N>=0 (default -1)";
  v2.n128_u64[1] = 50;
  sub_1CD663698((int **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &qword_1EBCDEAA8, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  v2.n128_u64[0] = (unint64_t)&v1;
  LODWORD(v4) = 1;
  v5.n128_u64[0] = (unint64_t)"Import functions with noinline attribute";
  v5.n128_u64[1] = 40;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDEB68, "force-import-all", &v2, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDEB68, &dword_1CB82C000);
  uint64_t v1 = 0x3FE6666666666666;
  int v3 = 1;
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"x";
  v5.n128_u64[1] = 1;
                                     "before processing newly imported functions";
  v2.n128_u64[1] = 125;
  sub_1CD663834((double **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCDEC28, &dword_1CB82C000);
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"x";
  int v3 = 1;
  v5.n128_u64[1] = 1;
  uint64_t v1 = 0x3FF0000000000000;
                                     "threshold by this factor before processing newly imported functions";
  v2.n128_u64[1] = 150;
  sub_1CD6639D0((double **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCDECE8, &dword_1CB82C000);
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"x";
  int v3 = 1;
  v5.n128_u64[1] = 1;
  uint64_t v1 = 0x4024000000000000;
  v2.n128_u64[1] = 61;
  sub_1CD663B6C((double **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCDEDA8, &dword_1CB82C000);
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"x";
  int v3 = 1;
  v5.n128_u64[1] = 1;
  uint64_t v1 = 0x4059000000000000;
  v2.n128_u64[1] = 66;
  sub_1CD663D08((double **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCDEE68, &dword_1CB82C000);
  LODWORD(v1) = 0;
  uint64_t v4 = &v1;
  v5.n128_u64[0] = (unint64_t)"N";
  int v3 = 1;
  v5.n128_u64[1] = 1;
  v2.n128_u64[1] = 62;
  sub_1CD663EA4((int **)&v4, &v3, (long long *)&v5, &v2);
  __cxa_atexit((void (*)(void *))sub_1CC08F43C, &qword_1EBCDEF28, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  v2.n128_u64[0] = (unint64_t)&v1;
  LODWORD(v4) = 1;
  v5.n128_u64[0] = (unint64_t)"Print imported functions";
  v5.n128_u64[1] = 24;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDEFE8, "print-imports", &v2, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDEFE8, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  v2.n128_u64[0] = (unint64_t)&v1;
  LODWORD(v4) = 1;
  v5.n128_u64[0] = (unint64_t)"Print information for functions rejected for importing";
  v5.n128_u64[1] = 54;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDF0A8, "print-import-failures", &v2, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDF0A8, &dword_1CB82C000);
  LOBYTE(v1) = 1;
  v2.n128_u64[0] = (unint64_t)&v1;
  LODWORD(v4) = 1;
  v5.n128_u64[0] = (unint64_t)"Compute dead symbols";
  v5.n128_u64[1] = 20;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDF168, "compute-dead", &v2, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDF168, &dword_1CB82C000);
  LOBYTE(v1) = 0;
  v2.n128_u64[0] = (unint64_t)&v1;
  LODWORD(v4) = 1;
  v5.n128_u64[0] = (unint64_t)"Enable import metadata like 'thinlto_src_module'";
  v5.n128_u64[1] = 48;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCDF228, "enable-import-metadata", &v2, &v4, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCDF228, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"The summary file to use for function importing.";
  v5.n128_u64[1] = 47;
  sub_1CD664040((long long *)&v5);
  __cxa_atexit((void (*)(void *))sub_1CD41C8DC, qword_1EBCDF3A8, &dword_1CB82C000);
  v5.n128_u64[0] = (unint64_t)"Import all external functions in index.";
  v5.n128_u64[1] = 39;
  sub_1CD664134((long long *)&v5);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCDF2E8, &dword_1CB82C000);
}

void llvm::runFunctionSpecialization(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  sub_1CC91B7F8((uint64_t)v8, v4);
  uint64_t v10 = 0;
  __n128 v5 = v9;
  if (v9)
  {
    int v6 = operator new(0x28uLL);
    uint64_t v7 = v6;
    *int v6 = &unk_1F26283B0;
    if (v5 == v8)
    {
      void v6[4] = v6 + 1;
      (*(void (**)(void *))(v8[0] + 24))(v8);
    }
    else
    {
      void v6[4] = v5;
      uint64_t v9 = 0;
    }
    uint64_t v10 = v7;
  }
  llvm::SCCPSolver::SCCPSolver();
}

uint64_t sub_1CC919708(uint64_t result)
{
  for (uint64_t i = *(void *)(result + 80); i != result + 72; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v2 = i - 24;
    if (!i) {
      uint64_t v2 = 0;
    }
    uint64_t v3 = v2 + 40;
    uint64_t v4 = *(void *)(v2 + 48);
    if (v4 != v3)
    {
      do
      {
        uint64_t v5 = *(void *)(v4 + 8);
        if (v4) {
          uint64_t v6 = v4 - 24;
        }
        else {
          uint64_t v6 = 0;
        }
        if (*(unsigned char *)(v6 + 16) == 84)
        {
          uint64_t v7 = *(void *)(v6 - 32);
          if (v7)
          {
            if (!*(unsigned char *)(v7 + 16)
              && *(void *)(v7 + 24) == *(void *)(v6 + 72)
              && (*(unsigned char *)(v7 + 33) & 0x20) != 0
              && *(_DWORD *)(*(void *)(v4 - 56) + 36) == 281)
            {
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v6, *(llvm::Value **)(v4 - 24 - 32 * (*(_DWORD *)(v4 - 4) & 0x7FFFFFF)), (llvm::Value *)1);
              llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
            }
          }
        }
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v5 != v3);
    }
  }
  return result;
}

uint64_t sub_1CC91980C(uint64_t **a1, uint64_t a2)
{
  v67[6] = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(*(void *)a2 + 8) & 0xFE) != 0x12)
  {
    unsigned int v4 = *(_DWORD *)(*(void *)a2 + 8);
    BOOL v5 = v4 > 0x15;
    int v6 = (1 << v4) & 0x20AC7F;
    if (v5 || v6 == 0) {
      return 0;
    }
  }
  unsigned int v8 = *(unsigned __int8 *)(a2 + 16);
  if (v8 >= 0x1C)
  {
    unsigned int v9 = v8 - 33;
    BOOL v5 = v9 > 0x33;
    uint64_t v10 = (1 << v9) & 0x8000000000041;
    if (!v5 && v10 != 0) {
      return 0;
    }
  }
  if (!*(void *)(a2 + 8)) {
    return 0;
  }
  uint64_t v12 = sub_1CD205858((uint64_t *)(**a1 + 136), a2);
  int v14 = v12;
  size_t v16 = (__int16 *)(v12 + 1);
  __int16 v15 = *((_WORD *)v12 + 4);
  int v17 = v15;
  if ((v15 & 0xFE) != 0 && v15 != 2)
  {
    if ((v15 & 0xFE) == 4)
    {
      LODWORD(v66) = *((_DWORD *)v12 + 6);
      if (v66 > 0x40) {
        operator new[]();
      }
      __s2 = (void *)v12[2];
      llvm::APInt::operator+=((uint64_t)&__s2, 1uLL);
      unsigned int v20 = v66;
      size_t v21 = __s2;
      LODWORD(v66) = 0;
      uint64_t v22 = *((unsigned int *)v14 + 10);
      if (v22 > 0x40)
      {
        uint64_t v63 = __s2;
        int v59 = memcmp((const void *)v14[4], __s2, ((unint64_t)(v22 + 63) >> 3) & 0x3FFFFFF8);
        size_t v21 = v63;
        BOOL v23 = v59 == 0;
      }
      else
      {
        BOOL v23 = v14[4] == (void)__s2;
      }
      int v24 = v23;
      if (v20 >= 0x41)
      {
        if (v21)
        {
          MEMORY[0x1D25D9CB0](v21, 0x1000C8000313F17);
          if (v66 >= 0x41)
          {
            if (__s2) {
              MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
            }
          }
        }
      }
      if (v24)
      {
        __int16 v15 = *v16;
        int v17 = *v16;
        goto LABEL_18;
      }
    }
    return 0;
  }
LABEL_18:
  if (v17 == 2) {
    goto LABEL_19;
  }
  if ((v15 & 0xFE) != 4) {
    goto LABEL_40;
  }
  LODWORD(v66) = *((_DWORD *)v14 + 6);
  if (v66 > 0x40) {
    operator new[]();
  }
  __s2 = (void *)v14[2];
  llvm::APInt::operator+=((uint64_t)&__s2, 1uLL);
  unsigned int v26 = v66;
  unsigned int v27 = __s2;
  LODWORD(v66) = 0;
  uint64_t v28 = *((unsigned int *)v14 + 10);
  if (v28 > 0x40)
  {
    size_t v60 = (const void *)v14[4];
    int v61 = __s2;
    int v62 = memcmp(v60, __s2, ((unint64_t)(v28 + 63) >> 3) & 0x3FFFFFF8);
    unsigned int v27 = v61;
    BOOL v29 = v62 == 0;
  }
  else
  {
    BOOL v29 = v14[4] == (void)__s2;
  }
  int v30 = v29;
  if (v26 >= 0x41)
  {
    if (v27)
    {
      MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
      if (v66 >= 0x41)
      {
        if (__s2) {
          MEMORY[0x1D25D9CB0](__s2, 0x1000C8000313F17);
        }
      }
    }
  }
  if (v30) {
LABEL_19:
  }
    Constant = (llvm::Value *)llvm::SCCPInstVisitor::getConstant(**a1, (uint64_t)v16);
  else {
LABEL_40:
  }
    Constant = llvm::UndefValue::get(*(llvm::UndefValue **)a2, v13);
  uint64_t v31 = Constant;
  __s2 = v67;
  uint64_t v66 = 0x600000000;
  uint64_t v32 = *(void *)(a2 + 8);
  if (v32)
  {
    unsigned int v33 = 0;
    do
    {
      uint64_t v34 = *(void *)(v32 + 24);
      if (v34) {
        BOOL v35 = *(unsigned __int8 *)(v34 + 16) >= 0x1Cu;
      }
      else {
        BOOL v35 = 0;
      }
      if (v35)
      {
        uint64_t v36 = *(void *)(v34 + 40);
        uint64_t v37 = **a1;
        uint64_t v39 = *(void *)(v37 + 40);
        uint64_t v38 = *(void *)(v37 + 48);
        if (v38 == v39)
        {
          uint64_t v40 = *(unsigned int *)(v37 + 60);
          int v41 = (void *)(v38 + 8 * v40);
          if (v40)
          {
            uint64_t v42 = 0;
            uint64_t v43 = 8 * v40;
            while (*(void *)(v38 + v42) != v36)
            {
              v42 += 8;
              if (v43 == v42) {
                goto LABEL_66;
              }
            }
            int v41 = (void *)(v38 + v42);
          }
LABEL_66:
          uint64_t v39 = *(void *)(v37 + 48);
        }
        else
        {
          uint64_t v44 = *(unsigned int *)(v37 + 56);
          int v45 = v44 - 1;
          unsigned int v46 = (v44 - 1) & ((v36 >> 4) ^ (v36 >> 9));
          int v41 = (void *)(v38 + 8 * v46);
          uint64_t v47 = *v41;
          if (*v41 == -1)
          {
            int v48 = 0;
LABEL_76:
            if (v48) {
              int v41 = v48;
            }
            if (*v41 != v36) {
              int v41 = (void *)(v38 + 8 * v44);
            }
          }
          else
          {
            int v48 = 0;
            int v49 = 1;
            while (v47 != v36)
            {
              if (v48) {
                BOOL v50 = 0;
              }
              else {
                BOOL v50 = v47 == -2;
              }
              if (v50) {
                int v48 = v41;
              }
              unsigned int v51 = v46 + v49++;
              unsigned int v46 = v51 & v45;
              int v41 = (void *)(v38 + 8 * (v51 & v45));
              uint64_t v47 = *v41;
              if (*v41 == -1) {
                goto LABEL_76;
              }
            }
          }
        }
        if (v38 == v39) {
          uint64_t v52 = 60;
        }
        else {
          uint64_t v52 = 56;
        }
        if (v41 != (void *)(v38 + 8 * *(unsigned int *)(v37 + v52)))
        {
          if (v33 >= HIDWORD(v66)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)__s2 + v33) = v34;
          unsigned int v33 = v66 + 1;
          LODWORD(v66) = v66 + 1;
        }
      }
      uint64_t v32 = *(void *)(v32 + 8);
    }
    while (v32);
  }
  llvm::Value::doRAUW((llvm::ValueAsMetadata *)a2, v31, (llvm::Value *)1);
  if (v66)
  {
    unsigned int v54 = (llvm::CallBase **)__s2;
    uint64_t v55 = 8 * v66;
    do
    {
      uint64_t v56 = *v54++;
      sub_1CD203DDC((llvm::SCCPInstVisitor *)**a1, v56, v53);
      v55 -= 8;
    }
    while (v55);
  }
  if (*(unsigned __int8 *)(a2 + 16) >= 0x1Cu
    && llvm::Instruction::isSafeToRemove((llvm::Instruction *)a2))
  {
    unsigned int v57 = *((_DWORD *)a1 + 60);
    if (v57 >= *((_DWORD *)a1 + 61)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    a1[29][v57] = a2;
    ++*((_DWORD *)a1 + 60);
    unint64_t v58 = (int32x2_t *)**a1;
    uint64_t v64 = a2;
    sub_1CD205788(v58 + 17, &v64);
  }
  if (__s2 != v67) {
    free(__s2);
  }
  return 1;
}

char **sub_1CC919DA8(char **a1)
{
  uint64_t v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 168 * v3;
    do
    {
      BOOL v5 = *(char **)&v2[v4 - 160];
      if (&v2[v4 - 144] != v5) {
        free(v5);
      }
      v4 -= 168;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CC919E20(char **a1, char **a2)
{
  if (a1 != a2)
  {
    BOOL v5 = (uint64_t *)(a2 + 2);
    uint64_t v4 = *a2;
    if (*a2 == (char *)(a2 + 2))
    {
      uint64_t v10 = a2 + 1;
      unint64_t v12 = *((unsigned int *)a2 + 2);
      uint64_t v13 = *((unsigned int *)a1 + 2);
      if (v13 >= v12)
      {
        uint64_t v18 = (uint64_t)*a1;
        if (v12)
        {
          size_t v19 = &v4[168 * v12];
          uint64_t v20 = (uint64_t)(v4 + 8);
          do
          {
            *(void *)uint64_t v18 = *(void *)(v20 - 8);
            sub_1CD4684F0(v18 + 8, v20);
            uint64_t v21 = *(void *)(v20 + 144);
            *(_DWORD *)(v18 + 160) = *(_DWORD *)(v20 + 152);
            *(void *)(v18 + 152) = v21;
            v18 += 168;
            uint64_t v22 = v20 + 160;
            v20 += 168;
          }
          while ((char *)v22 != v19);
          uint64_t v23 = v18;
          LODWORD(v13) = *((_DWORD *)a1 + 2);
          uint64_t v18 = (uint64_t)*a1;
        }
        else
        {
          uint64_t v23 = (uint64_t)*a1;
        }
        for (uint64_t i = v18 + 168 * v13; i != v23; i -= 168)
        {
          uint64_t v32 = *(void **)(i - 160);
          if ((void *)(i - 144) != v32) {
            free(v32);
          }
        }
        *((_DWORD *)a1 + 2) = v12;
        unsigned int v33 = *((_DWORD *)a2 + 2);
        if (v33)
        {
          uint64_t v34 = *a2;
          uint64_t v35 = 168 * v33;
          do
          {
            uint64_t v36 = *(char **)&v34[v35 - 160];
            if (&v34[v35 - 144] != v36) {
              free(v36);
            }
            v35 -= 168;
          }
          while (v35);
        }
      }
      else
      {
        unsigned int v14 = *((_DWORD *)a1 + 3);
        if (v14 >= v12)
        {
          int v24 = *a1;
          if (v13)
          {
            uint64_t v25 = &v4[168 * v13];
            uint64_t v26 = (uint64_t)(v24 + 8);
            uint64_t v27 = (uint64_t)(v4 + 8);
            do
            {
              *(void *)(v26 - 8) = *(void *)(v27 - 8);
              uint64_t v28 = sub_1CD4684F0(v26, v27);
              uint64_t v29 = *(void *)(v27 + 144);
              *(_DWORD *)(v28 + 152) = *(_DWORD *)(v27 + 152);
              *(void *)(v28 + 144) = v29;
              uint64_t v26 = v28 + 168;
              uint64_t v30 = v27 + 160;
              v27 += 168;
            }
            while ((char *)v30 != v25);
            int v24 = *a1;
          }
          else
          {
            uint64_t v13 = 0;
          }
        }
        else
        {
          if (v13)
          {
            uint64_t v15 = (uint64_t)*a1;
            uint64_t v16 = 168 * v13;
            do
            {
              int v17 = *(void **)(v15 + v16 - 160);
              if ((void *)(v15 + v16 - 144) != v17) {
                free(v17);
              }
              v16 -= 168;
            }
            while (v16);
            unsigned int v14 = *((_DWORD *)a1 + 3);
            *((_DWORD *)a1 + 2) = 0;
            if (v14 == -1) {
              sub_1CD0A89A8(0xFFFFFFFFuLL);
            }
          }
          else
          {
            *((_DWORD *)a1 + 2) = 0;
          }
          unint64_t v37 = (2 * v14) | 1;
          if (v37 <= v12) {
            unint64_t v37 = v12;
          }
          if (v37 >= 0xFFFFFFFF) {
            uint64_t v38 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v38 = v37;
          }
          uint64_t v39 = (char *)malloc_type_malloc(168 * v38, 0x4065EBACuLL);
          if (!v39) {
            llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
          }
          int v24 = v39;
          sub_1CC91A298((uint64_t *)a1, (uint64_t)v39);
          if (*a1 != (char *)(a1 + 2)) {
            free(*a1);
          }
          uint64_t v13 = 0;
          *a1 = v24;
          *((_DWORD *)a1 + 3) = v38;
        }
        uint64_t v40 = *a2;
        uint64_t v41 = *((unsigned int *)a2 + 2);
        if (v13 != v41)
        {
          uint64_t v42 = &v40[168 * v41];
          uint64_t v43 = 168 * v13 + 8;
          uint64_t v44 = &v24[v43];
          uint64_t v45 = (uint64_t)&v40[v43];
          do
          {
            uint64_t v46 = v45 - 8;
            uint64_t v47 = v44 + 16;
            *((void *)v44 - 1) = *(void *)(v45 - 8);
            *(void *)uint64_t v44 = v44 + 16;
            *((void *)v44 + 1) = 0x800000000;
            if (*(_DWORD *)(v45 + 8)) {
              uint64_t v44 = (char *)sub_1CD4684F0((uint64_t)v44, v45);
            }
            *((_OWORD *)v47 + 8) = *(_OWORD *)(v45 + 144);
            v44 += 168;
            v45 += 168;
          }
          while ((char *)(v46 + 168) != v42);
          uint64_t v40 = *a2;
        }
        *((_DWORD *)a1 + 2) = v12;
        if (*v10)
        {
          uint64_t v48 = 168 * *v10;
          do
          {
            int v49 = *(char **)&v40[v48 - 160];
            if (&v40[v48 - 144] != v49) {
              free(v49);
            }
            v48 -= 168;
          }
          while (v48);
        }
      }
    }
    else
    {
      int v6 = *a1;
      unsigned int v7 = *((_DWORD *)a1 + 2);
      if (v7)
      {
        uint64_t v8 = 168 * v7;
        do
        {
          unsigned int v9 = *(char **)&v6[v8 - 160];
          if (&v6[v8 - 144] != v9) {
            free(v9);
          }
          v8 -= 168;
        }
        while (v8);
        int v6 = *a1;
      }
      if (v6 != (char *)(a1 + 2)) {
        free(v6);
      }
      *a1 = *a2;
      uint64_t v10 = a2 + 1;
      a1[1] = a2[1];
      *a2 = (char *)v5;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v10 = 0;
  }
  return a1;
}

uint64_t sub_1CC91A1AC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  unsigned int v6 = *((_DWORD *)a1 + 2);
  uint64_t v7 = *a1 + 168 * v6;
  if (v7 == a3)
  {
    uint64_t v9 = a2;
  }
  else
  {
    uint64_t v8 = a3 + 8;
    uint64_t v9 = a2;
    do
    {
      *(void *)uint64_t v9 = *(void *)(v8 - 8);
      sub_1CD4684F0(v9 + 8, v8);
      uint64_t v10 = *(void *)(v8 + 144);
      *(_DWORD *)(v9 + 160) = *(_DWORD *)(v8 + 152);
      *(void *)(v9 + 152) = v10;
      v9 += 168;
      uint64_t v11 = v8 + 160;
      v8 += 168;
    }
    while (v11 != v7);
    uint64_t v5 = *a1;
    unsigned int v6 = *((_DWORD *)a1 + 2);
  }
  uint64_t v12 = v5 + 168 * v6;
  if (v12 != v9)
  {
    do
    {
      uint64_t v13 = *(void **)(v12 - 160);
      if ((void *)(v12 - 144) != v13) {
        free(v13);
      }
      v12 -= 168;
    }
    while (v12 != v9);
    uint64_t v5 = *a1;
  }
  *((_DWORD *)a1 + 2) = 1022611261 * ((unint64_t)(v9 - v5) >> 3);
  return a2;
}

void sub_1CC91A298(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a1 + 168 * v2;
    unsigned int v6 = (void *)(a2 + 8);
    uint64_t v7 = v4 + 8;
    do
    {
      uint64_t v8 = v7 - 8;
      uint64_t v9 = v6 + 2;
      *(v6 - 1) = *(void *)(v7 - 8);
      *unsigned int v6 = v6 + 2;
      v6[1] = 0x800000000;
      if (*(_DWORD *)(v7 + 8)) {
        unsigned int v6 = (void *)sub_1CD4684F0((uint64_t)v6, v7);
      }
      *((_OWORD *)v9 + 8) = *(_OWORD *)(v7 + 144);
      v6 += 21;
      v7 += 168;
    }
    while (v8 + 168 != v5);
    unsigned int v10 = *((_DWORD *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = 168 * v10;
      do
      {
        uint64_t v13 = *(void **)(v11 + v12 - 160);
        if ((void *)(v11 + v12 - 144) != v13) {
          free(v13);
        }
        v12 -= 168;
      }
      while (v12);
    }
  }
}

unint64_t sub_1CC91A370(uint64_t a1, void *a2, uint64_t *a3)
{
  v38[4] = *MEMORY[0x1E4F143B8];
  if (!a1 || *(unsigned __int8 *)(a1 + 16) <= 0x1Bu)
  {
    unint64_t result = 0;
    LODWORD(v35) = 0;
    return result;
  }
  int v6 = *(_DWORD *)(a1 + 20);
  if ((v6 & 0x40000000) != 0)
  {
    uint64_t v8 = *(uint64_t **)(a1 - 8);
    unint64_t v7 = v6 & 0x7FFFFFF;
  }
  else
  {
    unint64_t v7 = v6 & 0x7FFFFFF;
    uint64_t v8 = (uint64_t *)(a1 - 32 * v7);
  }
  uint64_t v36 = v38;
  uint64_t v37 = 0x400000000;
  if (v7 >= 5) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v7)
  {
    uint64_t v9 = 32 * v7;
    unsigned int v10 = v38;
    do
    {
      uint64_t v11 = *v8;
      v8 += 4;
      *v10++ = v11;
      v9 -= 32;
    }
    while (v9);
    uint64_t v12 = v36;
  }
  else
  {
    uint64_t v12 = v38;
  }
  LODWORD(v37) = v7;
  unint64_t v14 = (*(uint64_t (**)(void, uint64_t, void *))(*(void *)*a2 + 72))(*a2, a1, v12);
  uint64_t v17 = v16;
  if (v36 != v38) {
    free(v36);
  }
  unint64_t v34 = v14;
  uint64_t v35 = v17;
  uint64_t v18 = *(unsigned __int8 *)(a1 + 16) - 33;
  if (v18 > 0x37) {
    goto LABEL_18;
  }
  if (((1 << (*(unsigned char *)(a1 + 16) - 33)) & 0x8000000000041) != 0)
  {
    uint64_t v32 = *(void *)(a1 + 64);
    if (!v32 || (*(unsigned char *)(v32 + 20) & 4) == 0 && (*(unsigned char *)(v32 + 17) & 0x10) == 0)
    {
      LODWORD(v36) = 7;
      if (sub_1CC5CB59C(a1, (__int32 *)&v36, 1uLL))
      {
        uint64_t v33 = *(void *)(a1 - 32);
        if (!v33 || *(unsigned char *)(v33 + 16) || *(void *)(v33 + 24) != *(void *)(a1 + 72) || *(_DWORD *)(v33 + 36) != 7) {
          goto LABEL_19;
        }
      }
      if ((llvm::CallBase::hasFnAttrOnCalledFunction(a1, 66) & 1) == 0
        && !llvm::CallBase::hasFnAttrOnCalledFunction(a1, 44))
      {
        goto LABEL_19;
      }
    }
LABEL_18:
    if (*(unsigned __int8 *)(a1 + 16) - 66 > 0xC) {
      goto LABEL_26;
    }
    goto LABEL_19;
  }
  if (((1 << (*(unsigned char *)(a1 + 16) - 33)) & 0x808001C8000010) == 0
    && (v18 != 28 || (*(_WORD *)(a1 + 18) & 0x301) == 0))
  {
    goto LABEL_18;
  }
LABEL_19:
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v20 = sub_1CC91A370(*(void *)(i + 24), a2, a3);
    if (v21 == 1) {
      LODWORD(v35) = 1;
    }
    if (__OFADD__(v14, v20)) {
      unint64_t v14 = ((uint64_t)(v14 + v20) >> 63) ^ 0x8000000000000000;
    }
    else {
      v14 += v20;
    }
    unint64_t v34 = v14;
  }
LABEL_26:
  int v22 = *((_DWORD *)a3 + 4);
  if (v22)
  {
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *a3;
    unsigned int v25 = v22 - 1;
    uint64_t v26 = ((v23 >> 4) ^ (v23 >> 9)) & (v22 - 1);
    uint64_t v27 = *(void *)(*a3 + 16 * v26);
    if (v23 == v27)
    {
LABEL_31:
      uint64_t v30 = *(void **)(v24 + 16 * v26 + 8);
      if (v30)
      {
        unsigned int v31 = 0;
        do
        {
          uint64_t v30 = (void *)*v30;
          ++v31;
        }
        while (v30);
        goto LABEL_36;
      }
    }
    else
    {
      int v28 = 1;
      while (v27 != -4096)
      {
        int v29 = v26 + v28++;
        uint64_t v26 = v29 & v25;
        uint64_t v27 = *(void *)(v24 + 16 * v26);
        if (v23 == v27) {
          goto LABEL_31;
        }
      }
    }
  }
  unsigned int v31 = 0;
LABEL_36:
  LODWORD(v15) = dword_1EBCDF810;
  uint64_t v36 = (void *)(uint64_t)pow((double)v15, (double)v31);
  LODWORD(v37) = 0;
  sub_1CB90C9D4((uint64_t)&v34, (uint64_t)&v36);
  return v34;
}

void sub_1CC91A6D4(uint64_t a1, void *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      int v7 = *(_DWORD *)(a1 + 160);
      int v8 = *((_DWORD *)a2 - 2);
      BOOL v9 = v7 == v8;
      BOOL v10 = v7 < v8;
      if (v9) {
        BOOL v10 = *(void *)(a1 + 152) < *(a2 - 2);
      }
      if (v10)
      {
        uint64_t v11 = a2 - 21;
        sub_1CC91AB64((uint64_t *)a1, v11);
      }
    }
    else if ((uint64_t)a3 <= 0)
    {
      if ((void *)a1 != a2)
      {
        uint64_t v18 = (void *)(a1 + 168);
        if ((void *)(a1 + 168) != a2)
        {
          uint64_t v19 = 0;
          uint64_t v20 = (void *)a1;
          do
          {
            int v21 = v18;
            int v22 = *((_DWORD *)v20 + 40);
            int v23 = *((_DWORD *)v20 + 82);
            BOOL v9 = v22 == v23;
            BOOL v24 = v22 < v23;
            if (v9) {
              BOOL v24 = v20[19] < v20[40];
            }
            if (v24)
            {
              uint64_t v59 = *v21;
              v60[0] = v61;
              v60[1] = (void *)0x800000000;
              if (*((_DWORD *)v20 + 46)) {
                sub_1CD4684F0((uint64_t)v60, (uint64_t)(v20 + 22));
              }
              long long v62 = *((_OWORD *)v20 + 20);
              uint64_t v25 = v19;
              while (1)
              {
                uint64_t v26 = a1 + v25;
                *(void *)(a1 + v25 + 168) = *(void *)(a1 + v25);
                uint64_t v27 = a1 + v25 + 8;
                sub_1CD4684F0(a1 + v25 + 176, v27);
                *(void *)(v26 + 320) = *(void *)(v26 + 152);
                *(_DWORD *)(v26 + 328) = *(_DWORD *)(v26 + 160);
                if (!v25) {
                  break;
                }
                int v28 = *(_DWORD *)(v26 - 8);
                BOOL v9 = v28 == DWORD2(v62);
                BOOL v29 = v28 < SDWORD2(v62);
                if (v9) {
                  BOOL v29 = *(void *)(v26 - 16) < (uint64_t)v62;
                }
                v25 -= 168;
                if (!v29)
                {
                  uint64_t v30 = (void *)(a1 + v25 + 168);
                  goto LABEL_31;
                }
              }
              uint64_t v30 = (void *)a1;
LABEL_31:
              *uint64_t v30 = v59;
              sub_1CD4684F0(v27, (uint64_t)v60);
              *(void *)(v26 + 152) = v62;
              *(_DWORD *)(v26 + 160) = DWORD2(v62);
              if (v60[0] != v61) {
                free(v60[0]);
              }
            }
            uint64_t v18 = v21 + 21;
            v19 += 168;
            uint64_t v20 = v21;
          }
          while (v21 + 21 != a2);
        }
      }
    }
    else
    {
      unint64_t v15 = a3 >> 1;
      uint64_t v16 = (void *)(a1 + 168 * (a3 >> 1));
      unint64_t v17 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CC91AC60(a1, v16, v17, (uint64_t)a4);
        uint64_t v31 = (uint64_t)&a4[21 * v15];
        sub_1CC91AC60(a1 + 168 * (a3 >> 1), a2, a3 - (a3 >> 1), v31);
        uint64_t v32 = &a4[21 * a3];
        uint64_t v33 = a1 + 152;
        uint64_t v34 = v31;
        uint64_t v35 = a4;
        while ((uint64_t *)v34 != v32)
        {
          uint64_t v36 = v34 + 152;
          uint64_t v37 = v35 + 19;
          int v38 = *((_DWORD *)v35 + 40);
          int v39 = *(_DWORD *)(v34 + 160);
          BOOL v40 = v35[19] < *(void *)(v34 + 152);
          if (v38 != v39) {
            BOOL v40 = v38 < v39;
          }
          uint64_t v41 = v33 - 144;
          if (v40)
          {
            uint64_t v42 = v34 + 8;
            uint64_t v43 = *(void *)v34;
            v34 += 168;
            *(void *)(v33 - 152) = v43;
            sub_1CD4684F0(v41, v42);
            uint64_t v44 = *(void *)v36;
            int v45 = *(_DWORD *)(v36 + 8);
          }
          else
          {
            uint64_t v46 = (uint64_t)(v35 + 1);
            uint64_t v47 = *v35;
            v35 += 21;
            *(void *)(v33 - 152) = v47;
            sub_1CD4684F0(v41, v46);
            uint64_t v44 = *v37;
            int v45 = *((_DWORD *)v37 + 2);
          }
          *(_DWORD *)(v33 + 8) = v45;
          *(void *)uint64_t v33 = v44;
          v33 += 168;
          if (v35 == (uint64_t *)v31)
          {
            if ((uint64_t *)v34 != v32)
            {
              uint64_t v48 = 0;
              do
              {
                uint64_t v49 = v34 + v48;
                uint64_t v50 = v33 + v48;
                *(void *)(v33 + v48 - 152) = *(void *)(v34 + v48);
                sub_1CD4684F0(v33 + v48 - 144, v34 + v48 + 8);
                uint64_t v51 = *(void *)(v34 + v48 + 152);
                *(_DWORD *)(v50 + 8) = *(_DWORD *)(v34 + v48 + 160);
                *(void *)uint64_t v50 = v51;
                v48 += 168;
              }
              while ((uint64_t *)(v49 + 168) != v32);
            }
            goto LABEL_48;
          }
        }
        if (v35 != (uint64_t *)v31)
        {
          uint64_t v52 = 0;
          do
          {
            uint64_t v53 = v33 + v52 * 8;
            unsigned int v54 = &v35[v52];
            *(void *)(v33 + v52 * 8 - 152) = v35[v52];
            sub_1CD4684F0(v33 + v52 * 8 - 144, (uint64_t)&v35[v52 + 1]);
            uint64_t v55 = v35[v52 + 19];
            *(_DWORD *)(v53 + 8) = v35[v52 + 20];
            *(void *)uint64_t v53 = v55;
            v52 += 21;
          }
          while (v54 + 21 != (uint64_t *)v31);
        }
LABEL_48:
        if (a4)
        {
          unint64_t v56 = a3;
          unsigned int v57 = a4 + 3;
          do
          {
            unint64_t v58 = (uint64_t *)*(v57 - 2);
            if (v57 != v58) {
              free(v58);
            }
            v57 += 21;
            --v56;
          }
          while (v56);
        }
      }
      else
      {
        sub_1CC91A6D4(a1, v16, v17, a4, a5);
        sub_1CC91A6D4(a1 + 168 * (a3 >> 1), a2, a3 - (a3 >> 1), a4, a5);
        sub_1CC91B15C((uint64_t *)a1, (uint64_t *)(a1 + 168 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), a4, a5);
      }
    }
  }
}

void sub_1CC91AB64(uint64_t *a1, uint64_t *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  *a1 = *a2;
  *a2 = v4;
  uint64_t v5 = (uint64_t)(a2 + 1);
  uint64_t v6 = (uint64_t)(a1 + 1);
  v9[0] = v10;
  v9[1] = (void *)0x800000000;
  if (*((_DWORD *)a1 + 4)) {
    sub_1CD4684F0((uint64_t)v9, v6);
  }
  long long v11 = *(_OWORD *)(a1 + 19);
  sub_1CD4684F0(v6, v5);
  uint64_t v7 = a2[19];
  *((_DWORD *)a1 + 40) = *((_DWORD *)a2 + 40);
  a1[19] = v7;
  sub_1CD4684F0(v5, (uint64_t)v9);
  int v8 = v9[0];
  a2[19] = v11;
  *((_DWORD *)a2 + 40) = DWORD2(v11);
  if (v8 != v10) {
    free(v8);
  }
}

uint64_t sub_1CC91AC60(uint64_t result, void *a2, unint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v7 = (void *)result;
    if (a3 == 2)
    {
      int v8 = (long long *)(a2 - 2);
      BOOL v9 = (long long *)(result + 152);
      int v10 = *(_DWORD *)(result + 160);
      int v11 = *((_DWORD *)a2 - 2);
      BOOL v12 = v10 < v11;
      if (v10 == v11) {
        BOOL v12 = *(void *)(result + 152) < *(a2 - 2);
      }
      uint64_t v13 = a4 + 8;
      uint64_t v14 = a4 + 24;
      if (v12)
      {
        *(void *)a4 = *(a2 - 21);
        *(void *)(a4 + 8) = v14;
        *(void *)(a4 + 16) = 0x800000000;
        if (*((_DWORD *)a2 - 38)) {
          sub_1CD4684F0(v13, (uint64_t)(a2 - 20));
        }
        long long v15 = *v8;
        *(void *)(a4 + 176) = a4 + 192;
        unint64_t result = a4 + 176;
        *(_OWORD *)(a4 + 152) = v15;
        *(void *)(a4 + 168) = *v7;
        *(void *)(a4 + 184) = 0x800000000;
        if (*((_DWORD *)v7 + 4)) {
          unint64_t result = sub_1CD4684F0(result, (uint64_t)(v7 + 1));
        }
        long long v16 = *v9;
      }
      else
      {
        *(void *)a4 = *v7;
        *(void *)(a4 + 8) = v14;
        *(void *)(a4 + 16) = 0x800000000;
        if (*((_DWORD *)v7 + 4)) {
          sub_1CD4684F0(v13, (uint64_t)(v7 + 1));
        }
        long long v35 = *v9;
        *(void *)(a4 + 176) = a4 + 192;
        unint64_t result = a4 + 176;
        *(_OWORD *)(a4 + 152) = v35;
        *(void *)(a4 + 168) = *(a2 - 21);
        *(void *)(a4 + 184) = 0x800000000;
        if (*((_DWORD *)a2 - 38)) {
          unint64_t result = sub_1CD4684F0(result, (uint64_t)(a2 - 20));
        }
        long long v16 = *v8;
      }
      *(_OWORD *)(a4 + 320) = v16;
    }
    else if (a3 == 1)
    {
      *(void *)a4 = *(void *)result;
      *(void *)(a4 + 8) = a4 + 24;
      unint64_t result = a4 + 8;
      *(void *)(a4 + 16) = 0x800000000;
      if (*((_DWORD *)v7 + 4)) {
        unint64_t result = sub_1CD4684F0(result, (uint64_t)(v7 + 1));
      }
      *(_OWORD *)(a4 + 152) = *(_OWORD *)(v7 + 19);
    }
    else if ((uint64_t)a3 > 8)
    {
      uint64_t v36 = 168 * (a3 >> 1);
      uint64_t v37 = result + v36;
      sub_1CC91A6D4(result, result + v36, a3 >> 1, a4, a3 >> 1);
      unint64_t result = sub_1CC91A6D4(&v7[(unint64_t)v36 / 8], a2, a3 - (a3 >> 1), a4 + v36, a3 - (a3 >> 1));
      int v38 = (_OWORD *)(a4 + 152);
      int v39 = &v7[(unint64_t)v36 / 8];
      while (v39 != a2)
      {
        int v40 = *((_DWORD *)v7 + 40);
        int v41 = *((_DWORD *)v39 + 40);
        BOOL v42 = v40 < v41;
        if (v40 == v41) {
          BOOL v42 = v7[19] < v39[19];
        }
        unint64_t result = (uint64_t)(v38 - 9);
        uint64_t v43 = v38 - 8;
        if (v42)
        {
          *((void *)v38 - 19) = *v39;
          *((void *)v38 - 18) = v43;
          *((void *)v38 - 17) = 0x800000000;
          if (*((_DWORD *)v39 + 4)) {
            unint64_t result = sub_1CD4684F0(result, (uint64_t)(v39 + 1));
          }
          *int v38 = *(_OWORD *)(v39 + 19);
          v39 += 21;
        }
        else
        {
          *((void *)v38 - 19) = *v7;
          *((void *)v38 - 18) = v43;
          *((void *)v38 - 17) = 0x800000000;
          if (*((_DWORD *)v7 + 4)) {
            unint64_t result = sub_1CD4684F0(result, (uint64_t)(v7 + 1));
          }
          *int v38 = *(_OWORD *)(v7 + 19);
          v7 += 21;
        }
        int v38 = (_OWORD *)((char *)v38 + 168);
        if (v7 == (void *)v37)
        {
          if (v39 != a2)
          {
            uint64_t v47 = 0;
            do
            {
              uint64_t v48 = &v39[v47];
              uint64_t v49 = v39[v47];
              *(void *)((char *)v38 + v47 * 8 - 144) = (char *)v38 + v47 * 8 - 128;
              unint64_t result = (uint64_t)v38 + v47 * 8 - 144;
              *(void *)(result - 8) = v49;
              *(void *)(result + 8) = 0x800000000;
              if (LODWORD(v39[v47 + 2])) {
                unint64_t result = sub_1CD4684F0(result, (uint64_t)(v48 + 1));
              }
              *(_OWORD *)((char *)v38 + v47 * 8) = *(_OWORD *)(v48 + 19);
              v47 += 21;
            }
            while (v48 + 21 != a2);
          }
          return result;
        }
      }
      if (v7 != (void *)v37)
      {
        uint64_t v44 = 0;
        do
        {
          int v45 = &v7[v44];
          uint64_t v46 = v7[v44];
          *(void *)((char *)v38 + v44 * 8 - 144) = (char *)v38 + v44 * 8 - 128;
          unint64_t result = (uint64_t)v38 + v44 * 8 - 144;
          *(void *)(result - 8) = v46;
          *(void *)(result + 8) = 0x800000000;
          if (LODWORD(v7[v44 + 2])) {
            unint64_t result = sub_1CD4684F0(result, (uint64_t)(v45 + 1));
          }
          *(_OWORD *)((char *)v38 + v44 * 8) = *(_OWORD *)(v45 + 19);
          v44 += 21;
        }
        while (v45 + 21 != (void *)v37);
      }
    }
    else if ((void *)result != a2)
    {
      *(void *)a4 = *(void *)result;
      *(void *)(a4 + 8) = a4 + 24;
      unint64_t result = a4 + 8;
      *(void *)(a4 + 16) = 0x800000000;
      if (*((_DWORD *)v7 + 4)) {
        unint64_t result = sub_1CD4684F0(result, (uint64_t)(v7 + 1));
      }
      *(_OWORD *)(a4 + 152) = *(_OWORD *)(v7 + 19);
      unint64_t v17 = v7 + 21;
      if (v7 + 21 != a2)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (_OWORD *)a4;
        do
        {
          uint64_t v20 = v17;
          int v21 = (_OWORD *)((char *)v19 + 152);
          int v22 = v7 + 40;
          int v23 = *((_DWORD *)v19 + 40);
          int v24 = *((_DWORD *)v7 + 82);
          BOOL v25 = v23 == v24;
          BOOL v26 = v23 < v24;
          if (v25) {
            BOOL v26 = *((void *)v19 + 19) < v7[40];
          }
          unint64_t result = (uint64_t)(v19 + 11);
          uint64_t v27 = v19 + 12;
          if (v26)
          {
            *((void *)v19 + 21) = *(void *)v19;
            *((void *)v19 + 22) = v27;
            *((void *)v19 + 23) = 0x800000000;
            if (*((_DWORD *)v19 + 4)) {
              sub_1CD4684F0(result, (uint64_t)v19 + 8);
            }
            v19[20] = *v21;
            uint64_t v28 = a4;
            if (v19 != (_OWORD *)a4)
            {
              uint64_t v29 = v18;
              while (1)
              {
                uint64_t v28 = a4 + v29;
                int v30 = *(_DWORD *)(a4 + v29 - 8);
                int v31 = *((_DWORD *)v7 + 82);
                BOOL v32 = *(void *)(a4 + v29 - 16) < v7[40];
                BOOL v25 = v30 == v31;
                BOOL v33 = v30 < v31;
                if (!v25) {
                  BOOL v32 = v33;
                }
                if (!v32) {
                  break;
                }
                *(void *)uint64_t v28 = *(void *)(v28 - 168);
                sub_1CD4684F0(v28 + 8, v28 - 160);
                *(void *)(v28 + 152) = *(void *)(a4 + v29 - 16);
                *(_DWORD *)(v28 + 160) = *(_DWORD *)(a4 + v29 - 8);
                v29 -= 168;
                if (!v29)
                {
                  uint64_t v28 = a4;
                  break;
                }
              }
            }
            *(void *)uint64_t v28 = *v20;
            unint64_t result = sub_1CD4684F0(v28 + 8, (uint64_t)(v7 + 22));
            uint64_t v34 = *v22;
            *(_DWORD *)(v28 + 160) = *((_DWORD *)v7 + 82);
            *(void *)(v28 + 152) = v34;
          }
          else
          {
            *((void *)v19 + 21) = *v20;
            *((void *)v19 + 22) = v27;
            *((void *)v19 + 23) = 0x800000000;
            if (*((_DWORD *)v7 + 46)) {
              unint64_t result = sub_1CD4684F0(result, (uint64_t)(v7 + 22));
            }
            v19[20] = *(_OWORD *)v22;
          }
          uint64_t v19 = v21 + 1;
          unint64_t v17 = v20 + 21;
          v18 += 168;
          uint64_t v7 = v20;
        }
        while (v20 + 21 != a2);
      }
    }
  }
  return result;
}

void sub_1CC91B15C(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v7 = a5;
    size_t v103 = a6;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4) {
        return;
      }
      uint64_t v11 = 0;
      int v12 = *((_DWORD *)a2 + 40);
      uint64_t v13 = -a4;
      while (1)
      {
        uint64_t v14 = &a1[v11];
        int v15 = a1[v11 + 20];
        BOOL v16 = v15 == v12;
        BOOL v17 = v15 < v12;
        if (v16) {
          BOOL v17 = a1[v11 + 19] < a2[19];
        }
        if (v17) {
          break;
        }
        v11 += 21;
        if (__CFADD__(v13++, 1)) {
          return;
        }
      }
      uint64_t v19 = -v13;
      if (-v13 >= v7)
      {
        if (v13 == -1)
        {
          sub_1CC91AB64(&a1[v11], a2);
          return;
        }
        if (v13 > 0) {
          uint64_t v19 = 1 - v13;
        }
        uint64_t v33 = v19 >> 1;
        if (a3 == a2)
        {
          BOOL v32 = a2;
        }
        else
        {
          unint64_t v34 = 0xCF3CF3CF3CF3CF3DLL * (a3 - a2);
          long long v35 = &a1[21 * v33 + v11];
          int v36 = *((_DWORD *)v35 + 40);
          uint64_t v37 = v35[19];
          BOOL v32 = a2;
          do
          {
            unint64_t v38 = v34 >> 1;
            int v39 = &v32[21 * (v34 >> 1)];
            int v40 = *((_DWORD *)v39 + 40);
            BOOL v16 = v36 == v40;
            BOOL v41 = v36 < v40;
            if (v16) {
              BOOL v41 = v37 < v39[19];
            }
            BOOL v42 = v39 + 21;
            v34 += ~(v34 >> 1);
            if (v41) {
              BOOL v32 = v42;
            }
            else {
              unint64_t v34 = v38;
            }
          }
          while (v34);
        }
        int v22 = &a1[21 * v33 + v11];
        uint64_t v21 = 0xCF3CF3CF3CF3CF3DLL * (v32 - a2);
      }
      else
      {
        if (v7 >= 0) {
          uint64_t v20 = v7;
        }
        else {
          uint64_t v20 = v7 + 1;
        }
        uint64_t v21 = v20 >> 1;
        int v22 = a2;
        if (v14 != a2)
        {
          unint64_t v23 = 0xCF3CF3CF3CF3CF3DLL * (((char *)a2 - (char *)a1 - v11 * 8) >> 3);
          int v24 = &a2[21 * v21];
          int v25 = *((_DWORD *)v24 + 40);
          uint64_t v26 = v24[19];
          int v22 = &a1[v11];
          do
          {
            unint64_t v27 = v23 >> 1;
            uint64_t v28 = &v22[21 * (v23 >> 1)];
            int v29 = *((_DWORD *)v28 + 40);
            BOOL v16 = v29 == v25;
            BOOL v30 = v29 < v25;
            if (v16) {
              BOOL v30 = v28[19] < v26;
            }
            int v31 = v28 + 21;
            v23 += ~(v23 >> 1);
            if (v30) {
              unint64_t v23 = v27;
            }
            else {
              int v22 = v31;
            }
          }
          while (v23);
        }
        BOOL v32 = &a2[21 * v21];
        uint64_t v33 = 0xCF3CF3CF3CF3CF3DLL * (((char *)v22 - (char *)a1 - v11 * 8) >> 3);
      }
      uint64_t v43 = v32;
      if (v22 != a2)
      {
        uint64_t v43 = v22;
        if (a2 != v32)
        {
          uint64_t v99 = v21;
          uint64_t v100 = v33;
          uint64_t v101 = a7;
          unsigned int v102 = a3;
          sub_1CC91AB64(v22, a2);
          uint64_t v43 = v22 + 21;
          for (uint64_t i = a2 + 21; i != v32; i += 21)
          {
            if (v43 == a2) {
              a2 = i;
            }
            sub_1CC91AB64(v43, i);
            v43 += 21;
          }
          if (v43 == a2)
          {
            uint64_t v43 = a2;
          }
          else
          {
            int v45 = v43;
            uint64_t v46 = a2;
            do
            {
              while (1)
              {
                sub_1CC91AB64(v45, a2);
                v45 += 21;
                a2 += 21;
                if (a2 == v32) {
                  break;
                }
                if (v45 == v46) {
                  uint64_t v46 = a2;
                }
              }
              a2 = v46;
            }
            while (v45 != v46);
          }
          a3 = v102;
          a6 = v103;
          uint64_t v33 = v100;
          a7 = v101;
          uint64_t v21 = v99;
        }
      }
      a4 = -v33 - v13;
      uint64_t v47 = v7 - v21;
      if (v33 + v21 >= v7 - (v33 + v21) - v13)
      {
        uint64_t v50 = v33;
        uint64_t v51 = -v33 - v13;
        uint64_t v52 = v21;
        uint64_t v49 = a7;
        sub_1CC91B15C(v43, v32, a3, v51, v47, a6);
        BOOL v32 = v22;
        uint64_t v47 = v52;
        a4 = v50;
        a3 = v43;
      }
      else
      {
        uint64_t v48 = a3;
        uint64_t v49 = a7;
        sub_1CC91B15C(v14, v22, v43, v33, v21, a6);
        a3 = v48;
        uint64_t v14 = v43;
      }
      a2 = v32;
      uint64_t v7 = v47;
      a1 = v14;
      a6 = v103;
      a7 = v49;
      if (!v47) {
        return;
      }
    }
    if (a4 <= v7)
    {
      if (a1 == a2) {
        return;
      }
      unint64_t v59 = 0;
      uint64_t v54 = 0;
      do
      {
        size_t v60 = &a6[v59];
        int v61 = &a1[v59];
        *size_t v60 = a1[v59];
        a6[v59 + 1] = (uint64_t)&a6[v59 + 3];
        v60[2] = 0x800000000;
        if (LODWORD(a1[v59 + 2]))
        {
          long long v62 = a3;
          sub_1CD4684F0((uint64_t)&a6[v59 + 1], (uint64_t)(v61 + 1));
          a3 = v62;
          a6 = v103;
        }
        *(_OWORD *)(v60 + 19) = *(_OWORD *)(v61 + 19);
        ++v54;
        v59 += 21;
      }
      while (v61 + 21 != a2);
      if (v59 * 8)
      {
        uint64_t v73 = &a6[v59];
        uint64_t v74 = (uint64_t)&a6[v59 - 21];
        int v75 = a6;
        while (a2 != a3)
        {
          uint64_t v76 = a3;
          uint64_t v77 = a2 + 19;
          BOOL v78 = v75 + 19;
          int v79 = *((_DWORD *)v75 + 40);
          int v80 = *((_DWORD *)a2 + 40);
          BOOL v81 = v75[19] < a2[19];
          if (v79 != v80) {
            BOOL v81 = v79 < v80;
          }
          uint64_t v82 = (uint64_t)(a1 + 1);
          if (v81)
          {
            uint64_t v83 = (uint64_t)(a2 + 1);
            uint64_t v84 = *a2;
            a2 += 21;
            *a1 = v84;
            sub_1CD4684F0(v82, v83);
            uint64_t v85 = *v77;
            int v86 = *((_DWORD *)v77 + 2);
          }
          else
          {
            uint64_t v87 = (uint64_t)(v75 + 1);
            uint64_t v88 = *v75;
            v75 += 21;
            *a1 = v88;
            sub_1CD4684F0(v82, v87);
            uint64_t v85 = *v78;
            int v86 = *((_DWORD *)v78 + 2);
          }
          *((_DWORD *)a1 + 40) = v86;
          a1[19] = v85;
          a1 += 21;
          a6 = v103;
          a3 = v76;
          if (v73 == v75) {
            goto LABEL_106;
          }
        }
        if (v73 != v75)
        {
          unint64_t v93 = 0;
          do
          {
            uint64_t v94 = &a1[v93];
            uint64_t v95 = &v75[v93];
            a1[v93] = v75[v93];
            sub_1CD4684F0((uint64_t)&a1[v93 + 1], (uint64_t)&v75[v93 + 1]);
            uint64_t v96 = v75[v93 + 19];
            *((_DWORD *)v94 + 40) = v75[v93 + 20];
            v94[19] = v96;
            v93 += 21;
          }
          while ((uint64_t *)v74 != v95);
          a6 = v103;
        }
      }
    }
    else
    {
      if (a2 == a3) {
        return;
      }
      unint64_t v53 = 0;
      uint64_t v54 = 0;
      do
      {
        uint64_t v55 = &a6[v53];
        unint64_t v56 = &a2[v53];
        *uint64_t v55 = a2[v53];
        uint64_t v57 = (uint64_t)&a6[v53 + 3];
        void v55[2] = 0x800000000;
        v55[1] = v57;
        if (LODWORD(a2[v53 + 2]))
        {
          unint64_t v58 = a3;
          sub_1CD4684F0((uint64_t)&a6[v53 + 1], (uint64_t)(v56 + 1));
          a3 = v58;
          a6 = v103;
        }
        *(_OWORD *)(v57 + 128) = *(_OWORD *)(v56 + 19);
        ++v54;
        v53 += 21;
      }
      while (v56 + 21 != a3);
      if (v53 * 8)
      {
        uint64_t v63 = &a6[v53];
        while (a2 != a1)
        {
          uint64_t v64 = v63 - 2;
          uint64_t v65 = a2 - 2;
          int v66 = *((_DWORD *)a2 - 2);
          int v67 = *((_DWORD *)v63 - 2);
          BOOL v68 = *(a2 - 2) < *(v63 - 2);
          if (v66 != v67) {
            BOOL v68 = v66 < v67;
          }
          if (v68)
          {
            int v69 = a2;
            a2 -= 21;
          }
          else
          {
            int v69 = v63;
            v63 -= 21;
            uint64_t v65 = v64;
          }
          std::string::size_type v70 = a3 - 21;
          unsigned int v71 = a3 - 2;
          *(a3 - 21) = *(v69 - 21);
          sub_1CD4684F0((uint64_t)(a3 - 20), (uint64_t)(v69 - 20));
          uint64_t v72 = *v65;
          *((_DWORD *)v71 + 2) = *((_DWORD *)v65 + 2);
          *unsigned int v71 = v72;
          a3 = v70;
          a6 = v103;
          if (v63 == v103) {
            goto LABEL_106;
          }
        }
        if (v63 != a6)
        {
          unint64_t v89 = 0;
          do
          {
            int v90 = &a3[v89];
            a3[v89 - 21] = v63[v89 - 21];
            uint64_t v91 = a3;
            sub_1CD4684F0((uint64_t)&a3[v89 - 20], (uint64_t)&v63[v89 - 20]);
            a3 = v91;
            a6 = v103;
            uint64_t v92 = v63[v89 - 2];
            *((_DWORD *)v90 - 2) = v63[v89 - 1];
            *(v90 - 2) = v92;
            v89 -= 21;
          }
          while (&v63[v89] != v103);
        }
      }
    }
LABEL_106:
    if (a6 && v54)
    {
      uint64_t v97 = a6 + 3;
      do
      {
        uint64_t v98 = (void *)*(v97 - 2);
        if (v97 != v98) {
          free(v98);
        }
        v97 += 21;
        --v54;
      }
      while (v54);
    }
  }
}