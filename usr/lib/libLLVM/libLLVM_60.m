uint64_t sub_1CD56A014(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD56A01C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD56A030(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD56A044(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD56A058(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void sub_1CD56A084(_WORD *a1, _WORD *a2, int **a3, long long *a4, uint64_t a5)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD21A8, 0, 0);
  dword_1EBCD2228 = 0;
  qword_1EBCD2230 = (uint64_t)&unk_1F2611858;
  *(void *)&dword_1EBCD2238 = 0;
  qword_1EBCD21A8 = (uint64_t)&unk_1F26117A0;
  qword_1EBCD2240 = (uint64_t)&unk_1F2611808;
  qword_1EBCD2248 = (uint64_t)&qword_1EBCD21A8;
  qword_1EBCD2250 = (uint64_t)&unk_1EBCD2260;
  qword_1EBCD2258 = 0x800000000;
  qword_1EBCD23E0 = (uint64_t)&unk_1F2611948;
  qword_1EBCD23F8 = (uint64_t)&qword_1EBCD23E0;
  sub_1CD56A1A0(a1, a2, a3, a4, a5);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD21A8);
}

void sub_1CD56A1A0(_WORD *a1, _WORD *a2, int **a3, long long *a4, uint64_t a5)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD21A8, "regalloc-enable-advisor", 0x17uLL);
  word_1EBCD21B2 = word_1EBCD21B2 & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCD21B2 = word_1EBCD21B2 & 0xFFF8 | *a2 & 7;
  v10 = *a3;
  dword_1EBCD2228 = **a3;
  byte_1EBCD223C = 1;
  dword_1EBCD2238 = *v10;
  xmmword_1EBCD21C8 = *a4;
  uint64_t v11 = *(void *)a5;
  unsigned int v12 = *(_DWORD *)(a5 + 8);

  sub_1CD56A2D0(v11, v12);
}

void sub_1CD56A258()
{
}

void *sub_1CD56A26C()
{
  result = operator new(0x10uLL);
  void *result = &unk_1F2611948;
  return result;
}

void sub_1CD56A2A4(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2611948;
}

void sub_1CD56A2D0(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD56A31C(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD56A31C(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  v11[3] = a5;
  v11[4] = &unk_1F2611858;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD56A410((unint64_t)v11);
  uint64_t v8 = qword_1EBCD2250 + 48 * qword_1EBCD2258;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2611878;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2611858;
  LODWORD(qword_1EBCD2258) = qword_1EBCD2258 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCD2248, a1, a2);
}

unint64_t sub_1CD56A410(unint64_t result)
{
  if (qword_1EBCD2258 >= HIDWORD(qword_1EBCD2258))
  {
    if (qword_1EBCD2250 > result || qword_1EBCD2250 + 48 * (unint64_t)qword_1EBCD2258 <= result) {
      sub_1CD56A48C();
    }
    sub_1CD56A48C();
  }
  return result;
}

void sub_1CD56A48C()
{
}

void sub_1CD56A584(_WORD *a1, long long *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&EvictInterferenceCutoff, 0, 0);
  dword_1EBD05AA0 = 0;
  qword_1EBD05AA8 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD05AB0 = 0;
  EvictInterferenceCutoff = (uint64_t)&unk_1F2643F00;
  qword_1EBD05AB8 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD05AC0 = (uint64_t)&unk_1F25EA168;
  qword_1EBD05AD8 = (uint64_t)&qword_1EBD05AC0;
  llvm::cl::Option::setArgStr(v6, "regalloc-eviction-max-interference-cutoff", 0x29uLL);
  word_1EBD05A2A = (32 * (*a1 & 3)) | word_1EBD05A2A & 0xFF9F;
  xmmword_1EBD05A40 = *a2;
  dword_1EBD05AA0 = **a3;
  byte_1EBD05AB4 = 1;
  dword_1EBD05AB0 = dword_1EBD05AA0;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&EvictInterferenceCutoff);
}

void llvm::createFastRegisterAllocator(llvm *this)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  operator new();
}

void llvm::initializeRegAllocFastPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD2408, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC413328;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD2408, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t *sub_1CD56A830(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    v5 = (void *)(v3 + 24);
    do
    {
      if (*((_DWORD *)v5 - 6) <= 0xFFFFFFFD)
      {
        uint64_t v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t *sub_1CD56A8A4(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 40 * v2;
    v5 = (void *)(v3 + 24);
    do
    {
      if (*((_DWORD *)v5 - 6) <= 0xFFFFFFFD)
      {
        uint64_t v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
      }
      v5 += 5;
      v4 -= 40;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void sub_1CD56A91C(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 40 * v3;
    uint64_t v5 = *(void *)a1 + 24;
    while (1)
    {
      int v6 = *(_DWORD *)(v5 - 24);
      if (v6 == -2) {
        goto LABEL_10;
      }
      if (v6 != -1) {
        break;
      }
LABEL_11:
      v5 += 40;
      v4 -= 40;
      if (!v4) {
        goto LABEL_12;
      }
    }
    unint64_t v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(_DWORD *)(v5 - 24) = -1;
    goto LABEL_11;
  }

  sub_1CD56BF0C(a1);
}

void sub_1CD56A9E0(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 32 * v3;
    uint64_t v5 = *(void *)a1 + 24;
    while (1)
    {
      int v6 = *(_DWORD *)(v5 - 24);
      if (v6 == -2) {
        goto LABEL_10;
      }
      if (v6 != -1) {
        break;
      }
LABEL_11:
      v5 += 32;
      v4 -= 32;
      if (!v4) {
        goto LABEL_12;
      }
    }
    unint64_t v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(_DWORD *)(v5 - 24) = -1;
    goto LABEL_11;
  }

  sub_1CD56BE0C(a1);
}

void *sub_1CD56AAA0(void *result, uint64_t a2)
{
  uint64_t v2 = (uint64_t)result;
  void *result = result + 2;
  result[1] = 0x400000000;
  result[5] = 0;
  result[6] = 0;
  result[4] = result + 5;
  uint64_t v3 = *(void *)(a2 + 32);
  if (**(_WORD **)(a2 + 16) == 14)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 40);
    if (v4 == 2) {
      return result;
    }
    uint64_t v5 = v3 + 32 * v4;
    v3 += 64;
  }
  else
  {
    uint64_t v5 = v3 + 32;
  }
  do
  {
    if (!*(unsigned char *)v3)
    {
      if (*(_DWORD *)(v3 + 4))
      {
        unsigned int v6 = *(_DWORD *)(v3 + 4);
        result = (void *)sub_1CBB141C8(v2, &v6);
      }
    }
    v3 += 32;
  }
  while (v3 != v5);
  return result;
}

_DWORD *sub_1CD56AB58(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    long long v9 = 0;
LABEL_5:
    unsigned int v6 = sub_1CD56AC28(a1, a2, v9);
    *unsigned int v6 = *a2;
    *((void *)v6 + 1) = v6 + 6;
    *((void *)v6 + 2) = 0x100000000;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  unsigned int v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    char v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        char v10 = v6;
      }
      int v13 = v5 + v11++;
      uint64_t v5 = v13 & v4;
      unsigned int v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      long long v9 = v10;
    }
    else {
      long long v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD56AC28(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD56ADB0(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      unsigned int v17 = v16 - 1;
      uint64_t v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        int v22 = v18 + v20++;
        uint64_t v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD56ADB0(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  unsigned int v9 = v8 - 1;
  uint64_t v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    int v15 = v10 + v13++;
    uint64_t v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD56ADB0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC4160F0(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      _DWORD *result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

_DWORD *sub_1CD56AE7C(uint64_t a1, int *a2)
{
  int v7 = 0;
  char v4 = sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD56AF98(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = v5 + 6;
    *((void *)v5 + 2) = 0x200000000;
  }
  return v5;
}

uint64_t sub_1CD56AEFC(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    unint64_t v6 = (_DWORD *)(a1 + 40 * v5);
    int v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unint64_t v6 = (_DWORD *)(a1 + 40 * (v13 & v4));
        int v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unint64_t v6 = v10;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1CD56AF98(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD56B04C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD56B04C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD56B124(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      _DWORD *result = -1;
      result += 10;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

void sub_1CD56B124(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 40 * v6;
    do
    {
      *int v7 = -1;
      v7 += 10;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        unsigned int v13 = 0;
        sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *unsigned int v13 = *(_DWORD *)v4;
        *((void *)v10 + 2) = 0x200000000;
        *((void *)v10 + 1) = v10 + 6;
        uint64_t v11 = (uint64_t)(v10 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CC4162B8(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

_DWORD *sub_1CD56B218(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD414440(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(_DWORD **)result;
        uint64_t v3 = 8 * v1;
        do
        {
          *uint64_t v2 = -1;
          v2 += 2;
          v3 -= 8;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

uint64_t sub_1CD56B268(uint64_t a1, uint64_t *a2)
{
  v17[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *a2;
  int v10 = 0;
  sub_1CD56B3E8((uint64_t)&v7, a1, &v9, &v10);
  uint64_t v4 = v7;
  if (v8)
  {
    uint64_t v11 = v13;
    uint64_t v12 = 0x600000000;
    uint64_t v14 = *a2;
    int v15 = v17;
    uint64_t v16 = 0x600000000;
    sub_1CD56B374(a1 + 40, (unint64_t)&v14);
    if (v15 != v17) {
      free(v15);
    }
    if (v11 != v13) {
      free(v11);
    }
    unsigned int v5 = *(_DWORD *)(a1 + 48) - 1;
    *(_DWORD *)(v4 + 8) = v5;
  }
  else
  {
    unsigned int v5 = *(_DWORD *)(v7 + 8);
  }
  return *(void *)(a1 + 40) + 72 * v5 + 8;
}

unint64_t sub_1CD56B374(uint64_t a1, unint64_t a2)
{
  unint64_t result = sub_1CD56B888(a1, a2);
  uint64_t v4 = (void *)(*(void *)a1 + 72 * *(unsigned int *)(a1 + 8));
  *uint64_t v4 = *(void *)result;
  void v4[2] = 0x600000000;
  v4[1] = v4 + 3;
  uint64_t v5 = (uint64_t)(v4 + 1);
  if (*(_DWORD *)(result + 16)) {
    unint64_t result = sub_1CD41C56C(v5, result + 8);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD56B3E8(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v16 = 0;
  uint64_t result = sub_1CD56B4B4(a2, *a3, &v16);
  uint64_t v9 = v16;
  if (result)
  {
    uint64_t v10 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v11 = 2;
    }
    else
    {
      uint64_t v10 = *(void *)(a2 + 8);
      uint64_t v11 = *(unsigned int *)(a2 + 16);
    }
    char v12 = 0;
    uint64_t v13 = v10 + 16 * v11;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD56B560((_DWORD *)a2, a3, v16);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    uint64_t v14 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v15 = 2;
    }
    else
    {
      uint64_t v14 = *(void *)(a2 + 8);
      uint64_t v15 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v13 = v14 + 16 * v15;
    char v12 = 1;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v13;
  *(unsigned char *)(a1 + 16) = v12;
  return result;
}

uint64_t sub_1CD56B4B4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 2;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD56B560(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 2;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD56B620((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD56B4B4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD56B620(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2 >= 3)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 2)
    {
      uint64_t v15 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v15;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD56B7BC(a1, v6, v6 + 16 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  char v8 = 0;
  uint64_t v9 = v16;
  uint64_t v10 = 1;
  uint64_t v11 = a1 + 8;
  do
  {
    char v12 = v8;
    if ((*(void *)v11 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)uint64_t v9 = *(void *)v11;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(v11 + 8);
      v9 += 16;
    }
    uint64_t v11 = a1 + 8 + 16 * v10;
    char v8 = 1;
    uint64_t v10 = 2;
  }
  while ((v12 & 1) == 0);
  if (a2 > 2)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v13 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v13;
  }
  return sub_1CD56B7BC(a1, (uint64_t)v16, (uint64_t)v9);
}

uint64_t sub_1CD56B7BC(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    char v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 40);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    char v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *char v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v12 = 0;
      uint64_t result = sub_1CD56B4B4((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *char v12 = *(void *)a2;
      *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

unint64_t sub_1CD56B888(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 72 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD56B8F4();
    }
    sub_1CD56B8F4();
  }
  return a2;
}

void sub_1CD56B8F4()
{
}

void sub_1CD56B964(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1 + 72 * v2;
    uint64_t v5 = a2 + 24;
    uint64_t v6 = *a1 + 8;
    do
    {
      uint64_t v7 = v6 - 8;
      *(void *)(v5 - 24) = *(void *)(v6 - 8);
      *(void *)(v5 - 16) = v5;
      *(void *)(v5 - 8) = 0x600000000;
      if (*(_DWORD *)(v6 + 8)) {
        sub_1CD41C56C(v5 - 16, v6);
      }
      v5 += 72;
      v6 += 72;
    }
    while (v7 + 72 != v4);
    uint64_t v8 = *((unsigned int *)a1 + 2);
    if (v8)
    {
      uint64_t v9 = *a1;
      uint64_t v10 = 72 * v8;
      do
      {
        uint64_t v11 = *(void **)(v9 + v10 - 64);
        if ((void *)(v9 + v10 - 48) != v11) {
          free(v11);
        }
        v10 -= 72;
      }
      while (v10);
    }
  }
}

_DWORD *sub_1CD56BA34(uint64_t a1, int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD56BAF4(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((_WORD *)v6 + 2) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD56BAF4(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD56BC6C(a1, 2 * v6);
    int v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v10 = (37 * *a2) & v9;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
    int v11 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          BOOL v12 = a3;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
        int v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      int v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD56BC6C(a1, v6);
    int v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v17 = (37 * *a2) & v16;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v17);
    int v18 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          BOOL v12 = a3;
        }
        unsigned int v21 = v17 + v19++;
        unsigned int v17 = v21 & v16;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v17);
        int v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD56BC6C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD56BD38(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      _DWORD *result = -1;
      result += 2;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD56BD38(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(_DWORD **)result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    unint64_t v6 = *(_DWORD **)result;
    do
    {
      *unint64_t v6 = -1;
      v6 += 2;
      v5 -= 8;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    int v7 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v8 = *(_DWORD *)(result + 16) - 1;
      unsigned int v9 = v8 & (37 * v7);
      uint64_t v10 = &v3[2 * v9];
      int v11 = *v10;
      if (v7 != *v10)
      {
        BOOL v12 = 0;
        int v13 = 1;
        while (v11 != -1)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == -2;
          }
          if (v14) {
            BOOL v12 = v10;
          }
          unsigned int v15 = v9 + v13++;
          unsigned int v9 = v15 & v8;
          uint64_t v10 = &v3[2 * (v15 & v8)];
          int v11 = *v10;
          if (v7 == *v10) {
            goto LABEL_7;
          }
        }
        if (v12) {
          uint64_t v10 = v12;
        }
      }
LABEL_7:
      _DWORD *v10 = v7;
      *((_WORD *)v10 + 2) = *((_WORD *)a2 + 2);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

void sub_1CD56BE0C(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = *(void *)a1 + 24;
    do
    {
      if (*(_DWORD *)(v5 - 24) <= 0xFFFFFFFD)
      {
        unint64_t v6 = *(void **)(v5 - 16);
        if ((void *)v5 != v6) {
          free(v6);
        }
      }
      v5 += 32;
      v4 -= 32;
    }
    while (v4);
  }
  if (v3)
  {
    int v7 = 1 << (33 - __clz(v3 - 1));
    if (v7 <= 64) {
      unsigned int v8 = 64;
    }
    else {
      unsigned int v8 = v7;
    }
    unsigned int v9 = *(_DWORD **)a1;
    if (v8 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v10 = 32 * v8;
      do
      {
        *unsigned int v9 = -1;
        v9 += 8;
        v10 -= 32;
      }
      while (v10);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v8 = 0;
    unsigned int v9 = *(_DWORD **)a1;
  }
  MEMORY[0x1D25D9CD0](v9, 8);

  sub_1CBFFB9D0(a1, v8);
}

void sub_1CD56BF0C(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 40 * v2;
    uint64_t v5 = *(void *)a1 + 24;
    do
    {
      if (*(_DWORD *)(v5 - 24) <= 0xFFFFFFFD)
      {
        unint64_t v6 = *(void **)(v5 - 16);
        if ((void *)v5 != v6) {
          free(v6);
        }
      }
      v5 += 40;
      v4 -= 40;
    }
    while (v4);
  }
  int v7 = 1 << (33 - __clz(v3 - 1));
  if (v7 <= 64) {
    int v7 = 64;
  }
  if (v3) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  if (v8 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v8)
    {
      unsigned int v9 = *(_DWORD **)a1;
      uint64_t v10 = 40 * v8;
      do
      {
        *unsigned int v9 = -1;
        v9 += 10;
        v10 -= 40;
      }
      while (v10);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC415EB8(a1, v8);
  }
}

void sub_1CD56C008(_WORD *a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)&qword_1EBCD2440, 0, 0);
  byte_1EBCD24C0 = 0;
  qword_1EBCD24C8 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD24D0 = 0;
  qword_1EBCD2440 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD24D8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD24E0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD24F8 = (uint64_t)&qword_1EBCD24E0;
  llvm::cl::Option::setArgStr(v2, "rafast-ignore-missing-defs", 0x1AuLL);
  word_1EBCD244A = (32 * (*a1 & 3)) | word_1EBCD244A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2440);
}

void llvm::createGreedyRegisterAllocator(llvm *this)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  operator new();
}

void llvm::initializeRAGreedyPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD2500, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC418B34;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCD2500, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD56C284(uint64_t a1, llvm::AnalysisUsage *this)
{
  llvm::AnalysisUsage::setPreservesCFG(this);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::MachineBlockFrequencyInfo::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  llvm::AnalysisUsage::addRequiredID(this, llvm::AAResultsWrapperPass::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::LiveIntervals::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::LiveIntervals::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::SlotIndexes::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::SlotIndexes::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&unk_1EA61EEDF);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&unk_1EA61EEDF);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::LiveStacks::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::LiveStacks::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::MachineDominatorTree::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(this, llvm::MachineLoopInfo::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::VirtRegMap::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::VirtRegMap::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::LiveRegMatrix::ID);
  sub_1CB843600((uint64_t)this, (uint64_t)this + 112, (uint64_t)&llvm::LiveRegMatrix::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::EdgeBundles::ID);
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::SpillPlacement::ID);
  llvm::AnalysisUsage::addRequiredID(this, llvm::MachineOptimizationRemarkEmitterPass::ID);
  llvm::AnalysisUsage::addRequiredID(this, llvm::RegAllocEvictionAdvisorAnalysis::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, (uint64_t)this);
}

uint64_t sub_1CD56C47C(uint64_t a1, int a2, int a3)
{
  return sub_1CD56C48C(a1 + 1248, a2, a3);
}

uint64_t sub_1CD56C48C(uint64_t result, int a2, int a3)
{
  unint64_t v3 = a3 & 0x7FFFFFFF;
  unint64_t v4 = *(unsigned int *)(result + 8);
  if (v3 < v4)
  {
    uint64_t v5 = (uint64_t *)result;
    uint64_t v6 = *(void *)result;
    *(_DWORD *)(*(void *)result + 8 * v3) = 1;
    unint64_t v7 = a2 & 0x7FFFFFFF;
    BOOL v8 = v7 >= v4;
    unint64_t v9 = v7 - v4;
    if (v8)
    {
      uint64_t result = sub_1CC38F7B8(result, v9 + 1, *(void *)(result + 16));
      uint64_t v6 = *v5;
    }
    *(void *)(v6 + 8 * v7) = *(void *)(v6 + 8 * v3);
  }
  return result;
}

uint64_t sub_1CD56C4FC(uint64_t a1, int a2, int a3)
{
  return sub_1CD56C48C(a1 + 392, a2, a3);
}

uint64_t sub_1CD56C50C(uint64_t a1, uint64_t a2)
{
  return sub_1CC419398(a1, a1 + 1208, a2);
}

uint64_t sub_1CD56C518(uint64_t a1)
{
  return sub_1CC419710(a1, a1 + 1208);
}

uint64_t llvm::RegAllocEvictionAdvisor::canReassign(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  sub_1CC2356A0(*(_DWORD *)(a2 + 112), a1[5], a1[8], a1[3], (uint64_t)&v33);
  uint64_t v6 = -v34;
  int v22 = &v33;
  uint64_t v23 = -(int)v34;
  int v7 = v36;
  if (v36 == -(int)v34)
  {
    uint64_t v8 = 0;
  }
  else
  {
    do
    {
      if ((v6 & 0x80000000) != 0) {
        unsigned int v10 = *((unsigned __int16 *)*v22 + (void)v22[1] + (int)v6);
      }
      else {
        unsigned int v10 = *((unsigned __int16 *)v22[7] + v6);
      }
      if (v10 != a3)
      {
        uint64_t v12 = a1[7];
        if (v12) {
          int v13 = (void *)(v12 + 8);
        }
        else {
          int v13 = 0;
        }
        unint64_t v14 = *(unsigned int *)(*v13 + 24 * v10 + 16);
        unsigned int v15 = (_WORD *)(v13[6] + ((v14 >> 3) & 0x1FFFFFFE));
        __int16 v17 = *v15;
        int v16 = v15 + 1;
        unsigned __int16 v18 = v17 + (v14 & 0xF) * v10;
        while (1)
        {
          v24[0] = *(void *)(a1[3] + 392) + 216 * v18;
          v24[1] = a2;
          v24[3] = 0;
          v25 = v27;
          uint64_t v26 = 0x400000000;
          v28 = v30;
          uint64_t v29 = 0x400000000;
          v30[16] = 0;
          int v31 = 0;
          int v32 = 0;
          int v19 = llvm::LiveIntervalUnion::Query::collectInterferingVRegs((llvm::LiveIntervalUnion::Query *)v24, 1u);
          if (v28 != v30) {
            free(v28);
          }
          if (v25 != v27) {
            free(v25);
          }
          if (v19) {
            break;
          }
          int v20 = *v16++;
          v18 += v20;
          if (!v20)
          {
            if ((v23 & 0x80000000) != 0) {
              unsigned int v21 = (unsigned __int16 *)((char *)*v22 + 2 * (void)v22[1] + 2 * (int)v23);
            }
            else {
              unsigned int v21 = (unsigned __int16 *)((char *)v22[7] + 2 * v23);
            }
            uint64_t v8 = *v21;
            goto LABEL_10;
          }
        }
      }
      uint64_t v8 = 0;
LABEL_10:
      sub_1CC419C00(&v22);
      LODWORD(v6) = v23;
    }
    while (v23 != v7 && v8 == 0);
  }
  if (v33 != &v35) {
    free(v33);
  }
  return v8;
}

uint64_t sub_1CD56C730(uint64_t a1, llvm::LiveInterval *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  v71[2] = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(void, void, llvm::LiveInterval *))(**(void **)(a1 + 880) + 536))(*(void *)(a1 + 880), *(void *)(a1 + 864), a2))return 0xFFFFFFFFLL; {
  if (dword_1EBCD25B8 <= a7 && byte_1EBCD2738 == 0)
  }
  {
    *(unsigned char *)(a1 + 1304) |= 1u;
    return 0xFFFFFFFFLL;
  }
  int64_t v16 = *(unsigned int *)(a6 + 8);
  v60 = v64;
  v61 = v64;
  uint64_t v62 = 4;
  int v63 = 0;
  LODWORD(v65[0]) = *((_DWORD *)a2 + 28);
  sub_1CD533D58(a5, (unsigned int *)v65);
  __int16 v17 = v71;
  v69 = v71;
  uint64_t v70 = 0x400000000;
  uint64_t v18 = -*(void *)(a3 + 8);
  uint64_t v19 = -*(_DWORD *)(a3 + 8);
  v58 = (void *)a3;
  uint64_t v59 = v19;
  int v54 = *(_DWORD *)(a3 + 72);
  if (v54 == v18)
  {
    a3 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v48 = 16 * v16;
    while (1)
    {
      int v20 = (unsigned __int16 *)((v18 & 0x80000000) != 0
                               ? *v58 + 2 * v58[1] + 2 * (int)v18
                               : v58[7] + 2 * v18);
      uint64_t v21 = *v20;
      sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v60);
      LODWORD(v70) = 0;
      if ((int)llvm::LiveRegMatrix::checkInterference(*(void *)(a1 + 288), a2, v21) <= 1)
      {
        if (sub_1CC41E500(a1, v21, (uint64_t)a2, (uint64_t)&v60, a5))
        {
          v50 = v17;
          int64_t v51 = v16;
          uint64_t v52 = a5;
          int v53 = a7;
          __p = 0;
          v56 = 0;
          uint64_t v57 = 0;
          v33 = v61 == v60 ? (uint64_t *)((char *)&v62 + 4) : &v62;
          uint64_t v34 = *(unsigned int *)v33;
          if (v34)
          {
            uint64_t v35 = 8 * v34;
            int v36 = v61;
            while (*(void *)v36 >= 0xFFFFFFFFFFFFFFFELL)
            {
              v36 += 8;
              v35 -= 8;
              if (!v35) {
                goto LABEL_52;
              }
            }
          }
          else
          {
            int v36 = v61;
          }
          uint64_t v37 = &v61[8 * v34];
          if (v36 != v37)
          {
            v38 = *(const llvm::LiveInterval **)v36;
LABEL_47:
            int v39 = *((_DWORD *)v38 + 28);
            sub_1CC419398(a1, (uint64_t)&__p, (uint64_t)v38);
            v40 = (const llvm::LiveInterval *)*(unsigned int *)(*(void *)(*(void *)(a1 + 272) + 280)
                                                              + 4 * (v39 & 0x7FFFFFFF));
            unint64_t v41 = *(unsigned int *)(a6 + 8);
            if (v41 >= *(unsigned int *)(a6 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42 = (const llvm::LiveInterval **)(*(void *)a6 + 16 * v41);
            *v42 = v38;
            v42[1] = v40;
            ++*(_DWORD *)(a6 + 8);
            llvm::LiveRegMatrix::unassign(*(llvm::LiveRegMatrix **)(a1 + 288), v38);
            v43 = (unint64_t *)(v36 + 8);
            while (v43 != (unint64_t *)v37)
            {
              unint64_t v44 = *v43++;
              v38 = (const llvm::LiveInterval *)v44;
              if (v44 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                int v36 = (char *)(v43 - 1);
                goto LABEL_47;
              }
            }
          }
LABEL_52:
          llvm::LiveRegMatrix::assign(*(void **)(a1 + 288), a2, v21);
          v65[0] = v66;
          v65[1] = (void *)0x1000000000;
          if (*(_DWORD *)(v52 + 8)) {
            sub_1CB927A18((uint64_t)v65, v52);
          }
          sub_1CC421D48((uint64_t)&v67, (void *)(v52 + 80));
          char v49 = sub_1CD56CD0C(a1, &__p, (uint64_t)&v69, v52, a6, v53);
          if (v49)
          {
            int64_t v16 = v51;
            if (v70)
            {
              v45 = v69;
              unsigned int v46 = *(_DWORD *)(a4 + 8);
              uint64_t v47 = 4 * v70;
              do
              {
                if (v46 >= *(_DWORD *)(a4 + 12)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(_DWORD *)(*(void *)a4 + 4 * v46) = *v45;
                unsigned int v46 = *(_DWORD *)(a4 + 8) + 1;
                *(_DWORD *)(a4 + 8) = v46;
                ++v45;
                v47 -= 4;
              }
              while (v47);
            }
            llvm::LiveRegMatrix::unassign(*(llvm::LiveRegMatrix **)(a1 + 288), a2);
            a3 = v21;
          }
          else
          {
            sub_1CB927A18(v52, (uint64_t)v65);
            if (v65 != (void **)v52) {
              sub_1CD56DD24(v52 + 80, v67, &v68);
            }
            llvm::LiveRegMatrix::unassign(*(llvm::LiveRegMatrix **)(a1 + 288), a2);
            int64_t v16 = v51;
            if (v70)
            {
              v25 = (int *)v69;
              uint64_t v26 = 4 * v70;
              do
              {
                uint64_t v22 = sub_1CC2F12AC(*(void *)(a1 + 280), *v25);
                uint64_t v23 = (char *)sub_1CB896AE8((uint64_t)&v60, v22);
                if (v61 == v60) {
                  v24 = (uint64_t *)((char *)&v62 + 4);
                }
                else {
                  v24 = &v62;
                }
                if (v23 == &v61[8 * *(unsigned int *)v24])
                {
                  unint64_t v27 = *(unsigned int *)(a4 + 8);
                  if (v27 >= *(unsigned int *)(a4 + 12)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(_DWORD *)(*(void *)a4 + 4 * v27) = *v25;
                  ++*(_DWORD *)(a4 + 8);
                }
                ++v25;
                v26 -= 4;
              }
              while (v26);
            }
            int64_t v29 = *(unsigned int *)(a6 + 8);
            if (v29 > v51)
            {
              uint64_t v30 = 16 * v29 - 16;
              do
              {
                v28 = *(const llvm::LiveInterval **)(*(void *)a6 + v30);
                if (*(_DWORD *)(*(void *)(*(void *)(a1 + 272) + 280) + 4 * (*((_DWORD *)v28 + 28) & 0x7FFFFFFF))) {
                  llvm::LiveRegMatrix::unassign(*(llvm::LiveRegMatrix **)(a1 + 288), v28);
                }
                --v29;
                v30 -= 16;
              }
              while (v29 > v51);
              LODWORD(v29) = *(_DWORD *)(a6 + 8);
            }
            uint64_t v32 = v48;
            int64_t v31 = v51;
            if (v51 != v29)
            {
              do
              {
                llvm::LiveRegMatrix::assign(*(void **)(a1 + 288), *(llvm::LiveInterval **)(*(void *)a6 + v32), *(_DWORD *)(*(void *)a6 + v32 + 8));
                ++v31;
                v32 += 16;
              }
              while (v31 != *(_DWORD *)(a6 + 8));
            }
            sub_1CD56EAF8(a6, v51);
          }
          sub_1CB833A08((uint64_t)&v67, v68);
          __int16 v17 = v50;
          if (v65[0] != v66) {
            free(v65[0]);
          }
          a5 = v52;
          if (__p)
          {
            v56 = __p;
            operator delete(__p);
          }
          a7 = v53;
          if (v49) {
            break;
          }
        }
      }
      sub_1CC419C00(&v58);
      LODWORD(v18) = v59;
      if (v59 == v54)
      {
        a3 = 0xFFFFFFFFLL;
        break;
      }
    }
    if (v69 != v17) {
      free(v69);
    }
  }
  if (v61 != v60) {
    free(v61);
  }
  return a3;
}

uint64_t sub_1CD56CD0C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (*a2 != a2[1])
  {
    uint64_t v11 = (a6 + 1);
    do
    {
      uint64_t v12 = (llvm::LiveInterval *)sub_1CC419710(a1, (uint64_t)a2);
      unsigned int v13 = sub_1CC41E990(a1, v12, a3, a4, a5, v11);
      if (v13)
      {
        if (v13 == -1) {
          return 0;
        }
        llvm::LiveRegMatrix::assign(*(void **)(a1 + 288), v12, v13);
        unsigned int v15 = *((_DWORD *)v12 + 28);
        sub_1CD533D58(a4, &v15);
      }
      else if (*((_DWORD *)v12 + 2))
      {
        return 0;
      }
    }
    while (*a2 != a2[1]);
  }
  return 1;
}

uint64_t sub_1CD56CDF4(void *a1, uint64_t a2, unsigned __int16 **a3, uint64_t a4, unsigned char *a5, uint64_t a6)
{
  int v9 = *(_DWORD *)(a1[156] + 8 * (*(_DWORD *)(a2 + 112) & 0x7FFFFFFF));
  if (v9 == 4)
  {
    if (*(float *)(a2 + 116) != INFINITY)
    {
      uint64_t v11 = a1[167];
      *(_DWORD *)(v11 + 208) = 0;
      *(_DWORD *)(v11 + 288) = 0;
      *(_DWORD *)(v11 + 688) = 0;
      *(_DWORD *)(v11 + 632) = 0;
      *(void *)(v11 + 40) = a2;
      sub_1CC475A9C(v11);
      if ((unint64_t)sub_1CC41AF54((uint64_t)a1) < a1[3661])
      {
        a4 = 0;
        *a5 = 1;
      }
    }
  }
  else if (v9 <= 1)
  {
    uint64_t v14 = a1[167];
    *(_DWORD *)(v14 + 208) = 0;
    *(_DWORD *)(v14 + 288) = 0;
    *(_DWORD *)(v14 + 688) = 0;
    *(_DWORD *)(v14 + 632) = 0;
    *(void *)(v14 + 40) = a2;
    sub_1CC475A9C(v14);
    unsigned int v19 = 0;
    unint64_t v18 = a1[3661];
    unsigned int v16 = sub_1CC41B0D0((uint64_t)a1, v15, a3, &v18, &v19, 1);
    if (v16 != -1)
    {
      sub_1CC41B9EC((uint64_t)a1, a2, v16, 0, a6);
      return 0;
    }
  }
  return a4;
}

void sub_1CD56CF20(float *a1, uint64_t a2)
{
  uint64_t v4 = *((unsigned int *)a1 + 3);
  if (v4)
  {
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v56, "NumSpills", 9, v4);
    uint64_t v10 = sub_1CD3D6290(a2, &v56);
    v60 = " spills ";
    uint64_t v61 = 8;
    sub_1CC59ADEC((uint64_t *)(v10 + 80), (uint64_t)&v60);
    if (v59 < 0) {
      operator delete(v58);
    }
    if (v57 < 0) {
      operator delete((void *)v56);
    }
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v53, "TotalSpillsCost", 0xFuLL, a1[8]);
    uint64_t v11 = sub_1CD3D6290(a2, (long long *)&v53);
    v60 = " total spills cost ";
    uint64_t v61 = 19;
    sub_1CC59ADEC((uint64_t *)(v11 + 80), (uint64_t)&v60);
    if (v55 < 0) {
      operator delete(v54);
    }
    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v53.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v5 = *((unsigned int *)a1 + 4);
  if (v5)
  {
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v49, "NumFoldedSpills", 15, v5);
    uint64_t v12 = sub_1CD3D6290(a2, &v49);
    v60 = " folded spills ";
    uint64_t v61 = 15;
    sub_1CC59ADEC((uint64_t *)(v12 + 80), (uint64_t)&v60);
    if (v52 < 0) {
      operator delete(v51);
    }
    if (v50 < 0) {
      operator delete((void *)v49);
    }
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v46, "TotalFoldedSpillsCost", 0x15uLL, a1[9]);
    uint64_t v13 = sub_1CD3D6290(a2, (long long *)&v46);
    v60 = " total folded spills cost ";
    uint64_t v61 = 26;
    sub_1CC59ADEC((uint64_t *)(v13 + 80), (uint64_t)&v60);
    if (v48 < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v6 = *(unsigned int *)a1;
  if (v6)
  {
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v42, "NumReloads", 10, v6);
    uint64_t v14 = sub_1CD3D6290(a2, (long long *)v42);
    v60 = " reloads ";
    uint64_t v61 = 9;
    sub_1CC59ADEC((uint64_t *)(v14 + 80), (uint64_t)&v60);
    if (v45 < 0) {
      operator delete(v44);
    }
    if (v43 < 0) {
      operator delete(v42[0]);
    }
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v39, "TotalReloadsCost", 0x10uLL, a1[6]);
    uint64_t v15 = sub_1CD3D6290(a2, (long long *)&v39);
    v60 = " total reloads cost ";
    uint64_t v61 = 20;
    sub_1CC59ADEC((uint64_t *)(v15 + 80), (uint64_t)&v60);
    if (v41 < 0) {
      operator delete(v40);
    }
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v39.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v7 = *((unsigned int *)a1 + 1);
  if (v7)
  {
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v35, "NumFoldedReloads", 16, v7);
    uint64_t v16 = sub_1CD3D6290(a2, (long long *)v35);
    v60 = " folded reloads ";
    uint64_t v61 = 16;
    sub_1CC59ADEC((uint64_t *)(v16 + 80), (uint64_t)&v60);
    if (v38 < 0) {
      operator delete(v37);
    }
    if (v36 < 0) {
      operator delete(v35[0]);
    }
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v32, "TotalFoldedReloadsCost", 0x16uLL, a1[7]);
    uint64_t v17 = sub_1CD3D6290(a2, (long long *)&v32);
    v60 = " total folded reloads cost ";
    uint64_t v61 = 27;
    sub_1CC59ADEC((uint64_t *)(v17 + 80), (uint64_t)&v60);
    if (v34 < 0) {
      operator delete(v33);
    }
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v32.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v8 = *((unsigned int *)a1 + 2);
  if (v8)
  {
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v28, "NumZeroCostFoldedReloads", 24, v8);
    uint64_t v18 = sub_1CD3D6290(a2, (long long *)v28);
    v60 = " zero cost folded reloads ";
    uint64_t v61 = 26;
    sub_1CC59ADEC((uint64_t *)(v18 + 80), (uint64_t)&v60);
    if (v31 < 0) {
      operator delete(v30);
    }
    if (v29 < 0) {
      operator delete(v28[0]);
    }
  }
  uint64_t v9 = *((unsigned int *)a1 + 5);
  if (v9)
  {
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v24, "NumVRCopies", 11, v9);
    uint64_t v19 = sub_1CD3D6290(a2, (long long *)v24);
    v60 = " virtual registers copies ";
    uint64_t v61 = 26;
    sub_1CC59ADEC((uint64_t *)(v19 + 80), (uint64_t)&v60);
    if (v27 < 0) {
      operator delete(v26);
    }
    if (v25 < 0) {
      operator delete(v24[0]);
    }
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v21, "TotalCopiesCost", 0xFuLL, a1[10]);
    uint64_t v20 = sub_1CD3D6290(a2, (long long *)&v21);
    v60 = " total copies cost ";
    uint64_t v61 = 19;
    sub_1CC59ADEC((uint64_t *)(v20 + 80), (uint64_t)&v60);
    if (v23 < 0) {
      operator delete(v22);
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
  }
}

float sub_1CD56D3A4(uint64_t a1, uint64_t a2)
{
  *(int32x4_t *)a1 = vaddq_s32(*(int32x4_t *)a1, *(int32x4_t *)a2);
  *(int32x2_t *)(a1 + 16) = vadd_s32(*(int32x2_t *)(a1 + 16), *(int32x2_t *)(a2 + 16));
  *(float32x4_t *)(a1 + 24) = vaddq_f32(*(float32x4_t *)(a2 + 24), *(float32x4_t *)(a1 + 24));
  float result = *(float *)(a2 + 40) + *(float *)(a1 + 40);
  *(float *)(a1 + 40) = result;
  return result;
}

void sub_1CD56D3EC(uint64_t a1)
{
  sub_1CC421EC8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD56D424(uint64_t a1)
{
}

void sub_1CD56D42C(uint64_t a1)
{
  sub_1CC421EC8(a1 - 248);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD56D468(uint64_t a1)
{
}

void sub_1CD56D470(uint64_t a1)
{
  sub_1CC421EC8(a1 - 856);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD56D4AC(void *a1)
{
  *a1 = &unk_1F2611BF0;
  uint64_t v2 = a1 + 71;
  unint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2611C58;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD56D594(void *a1)
{
  *a1 = &unk_1F2611C58;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD56D5E8(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD56D67C(v11);
}

uint64_t sub_1CD56D67C(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD56D694(void *a1)
{
  sub_1CD56D4AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD56D6CC(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD56D6D8(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD56D6E8(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F2611CA8;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD56D76C(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD56D780(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD56D788(void *a1)
{
  *a1 = &unk_1F2611C58;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD56D7FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD56D804(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD56D818(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD56D82C(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD56D840(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

uint64_t sub_1CD56D86C(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v11 = 0;
  uint64_t v8 = llvm::cl::parser<unsigned long>::parse(a1 + 160, (void *)a1, a3, a4, a5, a6, &v11);
  if (v8) {
    return v8;
  }
  *(void *)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 192);
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD56D900();
}

uint64_t sub_1CD56D900()
{
  return 2;
}

uint64_t sub_1CD56D908(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 160, a1);
}

llvm::raw_ostream *sub_1CD56D914(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 160), a1, a2);
}

void sub_1CD56D924(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    unint64_t v3 = *(void *)(a1 + 128);
LABEL_3:
    uint64_t v4 = *(void *)(a1 + 144);
    char v6 = *(unsigned char *)(a1 + 152);
    v5[0] = &unk_1F2611D50;
    v5[1] = v4;
    llvm::cl::parser<unsigned long>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 160), (const llvm::cl::Option *)a1, v3, (uint64_t)v5, a2);
    return;
  }
  if (*(unsigned char *)(a1 + 152))
  {
    unint64_t v3 = *(void *)(a1 + 128);
    if (*(void *)(a1 + 144) != v3) {
      goto LABEL_3;
    }
  }
}

uint64_t sub_1CD56D9A4(uint64_t result)
{
  if (*(unsigned char *)(result + 152)) {
    uint64_t v1 = *(void *)(result + 144);
  }
  else {
    uint64_t v1 = 0;
  }
  *(void *)(result + 128) = v1;
  return result;
}

BOOL sub_1CD56D9C4(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 16) && *(unsigned char *)(a1 + 16) && *(void *)(a1 + 8) != *(void *)(a2 + 8);
}

void sub_1CD56D9F0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t *sub_1CD56DAFC(void **a1, uint64_t *a2, unsigned int a3, _DWORD *a4)
{
  float result = sub_1CD56DBA0(a1, a2, &v13, &v12, a3);
  if (!*result)
  {
    uint64_t v7 = result;
    uint64_t v8 = operator new(0x20uLL);
    v8[7] = *a4;
    uint64_t v9 = v13;
    *(void *)uint64_t v8 = 0;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = v9;
    *uint64_t v7 = (uint64_t)v8;
    uint64_t v10 = (void *)**a1;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = (uint64_t *)*v7;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v8;
    }
    float result = sub_1CB8358B8(a1[1], v11);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return result;
}

uint64_t *sub_1CD56DBA0(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int a5)
{
  int v5 = a1 + 1;
  if (a1 + 1 == a2 || (unsigned int v6 = *((_DWORD *)a2 + 7), v6 > a5))
  {
    uint64_t v7 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v9 = a2;
    }
    else
    {
      if (v7)
      {
        uint64_t v8 = (uint64_t *)*a2;
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (uint64_t *)v8[1];
        }
        while (v8);
      }
      else
      {
        uint64_t v13 = a2;
        do
        {
          uint64_t v9 = (uint64_t *)v13[2];
          BOOL v14 = *v9 == (void)v13;
          uint64_t v13 = v9;
        }
        while (v14);
      }
      if (*((_DWORD *)v9 + 7) >= a5)
      {
        uint64_t v15 = *v5;
        if (*v5)
        {
          do
          {
            while (1)
            {
              a4 = (uint64_t *)v15;
              unsigned int v16 = *(_DWORD *)(v15 + 28);
              if (v16 <= a5) {
                break;
              }
              uint64_t v15 = *a4;
              int v5 = a4;
              if (!*a4) {
                goto LABEL_36;
              }
            }
            if (v16 >= a5) {
              break;
            }
            int v5 = a4 + 1;
            uint64_t v15 = a4[1];
          }
          while (v15);
LABEL_27:
          *a3 = a4;
          return v5;
        }
        goto LABEL_44;
      }
    }
    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  else
  {
    if (v6 >= a5)
    {
      *a3 = a2;
      *a4 = (uint64_t)a2;
      return a4;
    }
    uint64_t v10 = a2[1];
    if (v10)
    {
      uint64_t v11 = (uint64_t *)a2[1];
      do
      {
        a4 = v11;
        uint64_t v11 = (uint64_t *)*v11;
      }
      while (v11);
    }
    else
    {
      uint64_t v17 = a2;
      do
      {
        a4 = (uint64_t *)v17[2];
        BOOL v14 = *a4 == (void)v17;
        uint64_t v17 = a4;
      }
      while (!v14);
    }
    if (a4 != v5 && *((_DWORD *)a4 + 7) <= a5)
    {
      uint64_t v18 = *v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            a4 = (uint64_t *)v18;
            unsigned int v19 = *(_DWORD *)(v18 + 28);
            if (v19 <= a5) {
              break;
            }
            uint64_t v18 = *a4;
            int v5 = a4;
            if (!*a4) {
              goto LABEL_36;
            }
          }
          if (v19 >= a5) {
            break;
          }
          int v5 = a4 + 1;
          uint64_t v18 = a4[1];
        }
        while (v18);
        goto LABEL_27;
      }
LABEL_44:
      *a3 = v5;
      return v5;
    }
    if (v10)
    {
LABEL_36:
      *a3 = a4;
    }
    else
    {
      *a3 = a2;
      return a2 + 1;
    }
  }
  return a4;
}

void sub_1CD56DD24(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    unsigned int v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    uint64_t v8 = v6[1] ? (uint64_t *)v6[1] : v6;
    if (v8)
    {
      uint64_t v12 = sub_1CD4F3428((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v13 = a2;
        do
        {
          uint64_t v14 = (uint64_t)v8;
          uint64_t v8 = v12;
          *(_DWORD *)(v14 + 28) = *((_DWORD *)v13 + 7);
          sub_1CD56DE88((uint64_t **)a1, v14);
          if (v12) {
            uint64_t v12 = sub_1CD4F3428((uint64_t)v12);
          }
          uint64_t v15 = (void *)v13[1];
          if (v15)
          {
            do
            {
              a2 = v15;
              uint64_t v15 = (void *)*v15;
            }
            while (v15);
          }
          else
          {
            do
            {
              a2 = (void *)v13[2];
              BOOL v11 = *a2 == (void)v13;
              uint64_t v13 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v13 = a2;
        }
        while (a2 != a3);
      }
      sub_1CB833A08(a1, v8);
      if (v12)
      {
        do
        {
          unsigned int v16 = v12;
          uint64_t v12 = (uint64_t *)v12[2];
        }
        while (v12);
        sub_1CB833A08(a1, v16);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD56DF20((uint64_t **)a1, *((_DWORD *)a2 + 7));
      uint64_t v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

uint64_t *sub_1CD56DE88(uint64_t **a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)(a1 + 1);
  uint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v3 = v4;
        if (*(_DWORD *)(a2 + 28) >= *((_DWORD *)v4 + 7)) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        int v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    int v5 = v3 + 1;
  }
  else
  {
    int v5 = (uint64_t *)(a1 + 1);
  }
LABEL_8:
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = v3;
  uint64_t *v5 = a2;
  unsigned int v6 = (uint64_t *)**a1;
  if (v6)
  {
    *a1 = v6;
    a2 = *v5;
  }
  float result = sub_1CB8358B8(a1[1], (uint64_t *)a2);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1CD56DF20(uint64_t **a1, unsigned int a2)
{
  uint64_t v4 = (uint64_t *)operator new(0x20uLL);
  int v5 = v4;
  *((_DWORD *)v4 + 7) = a2;
  unsigned int v6 = a1 + 1;
  uint64_t v7 = (uint64_t **)a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        unsigned int v6 = v7;
        if (*((_DWORD *)v7 + 7) <= a2) {
          break;
        }
        uint64_t v7 = (uint64_t **)*v7;
        uint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      uint64_t v7 = (uint64_t **)v7[1];
    }
    while (v7);
    uint64_t v8 = v6 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_8:
  *uint64_t v4 = 0;
  v4[1] = 0;
  void v4[2] = (uint64_t)v6;
  *uint64_t v8 = v4;
  uint64_t v9 = (uint64_t *)**a1;
  if (v9)
  {
    *a1 = v9;
    int v5 = *v8;
  }
  float result = sub_1CB8358B8(a1[1], v5);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void **sub_1CD56DFC8(void **a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void **)*a1;
  uint64_t v3 = *((unsigned int *)v1 + 2);
  if (v3)
  {
    uint64_t v8 = v1;
    uint64_t v5 = 144 * v3;
    unsigned int v6 = (char *)(v2 - 18);
    do
    {
      sub_1CC422100(&v6[v5]);
      v5 -= 144;
    }
    while (v5);
    uint64_t v1 = v8;
    uint64_t v2 = (void **)*v8;
  }
  if (v2 != v1 + 2)
  {
    uint64_t v7 = v1;
    free(v2);
    return v7;
  }
  return v1;
}

void sub_1CD56E048(_WORD *a1, long long *a2, uint64_t a3, int **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD2900, 0, 0);
  dword_1EBCD2980 = 0;
  qword_1EBCD2988 = (uint64_t)&unk_1F2611CA8;
  *(void *)&dword_1EBCD2990 = 0;
  qword_1EBCD2900 = (uint64_t)&unk_1F2611BF0;
  qword_1EBCD2998 = (uint64_t)&unk_1F2611C58;
  qword_1EBCD29A0 = (uint64_t)&qword_1EBCD2900;
  qword_1EBCD29A8 = (uint64_t)&unk_1EBCD29B8;
  qword_1EBCD29B0 = 0x800000000;
  qword_1EBCD2B38 = (uint64_t)&unk_1F2611D70;
  qword_1EBCD2B50 = (uint64_t)&qword_1EBCD2B38;
  sub_1CD56E15C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2900);
}

void sub_1CD56E15C(_WORD *a1, long long *a2, uint64_t a3, int **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD2900, "split-spill-mode", 0x10uLL);
  word_1EBCD290A = (32 * (*a1 & 3)) | word_1EBCD290A & 0xFF9F;
  xmmword_1EBCD2920 = *a2;
  sub_1CD56E278(*(void *)a3, *(_DWORD *)(a3 + 8));
  uint64_t v8 = *a4;
  dword_1EBCD2980 = **a4;
  byte_1EBCD2994 = 1;
  dword_1EBCD2990 = *v8;
}

void sub_1CD56E200()
{
}

void *sub_1CD56E214()
{
  float result = operator new(0x10uLL);
  void *result = &unk_1F2611D70;
  return result;
}

void sub_1CD56E24C(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2611D70;
}

void sub_1CD56E278(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD56E2C4(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD56E2C4(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  v11[2] = a4;
  v11[3] = a5;
  v11[4] = &unk_1F2611CA8;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD56E3B8((unint64_t)v11);
  uint64_t v8 = qword_1EBCD29A8 + 48 * qword_1EBCD29B0;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2611CC8;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2611CA8;
  LODWORD(qword_1EBCD29B0) = qword_1EBCD29B0 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCD29A0, a1, a2);
}

unint64_t sub_1CD56E3B8(unint64_t result)
{
  if (qword_1EBCD29B0 >= HIDWORD(qword_1EBCD29B0))
  {
    if (qword_1EBCD29A8 > result || qword_1EBCD29A8 + 48 * (unint64_t)qword_1EBCD29B0 <= result) {
      sub_1CD56E434();
    }
    sub_1CD56E434();
  }
  return result;
}

void sub_1CD56E434()
{
}

void sub_1CD56E52C(_WORD *a1, long long *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD25F8, 0, 0);
  dword_1EBCD2678 = 0;
  qword_1EBCD2680 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD2688 = 0;
  qword_1EBCD25F8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD2690 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD2698 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD26B0 = (uint64_t)&qword_1EBCD2698;
  llvm::cl::Option::setArgStr(v6, "lcr-max-interf", 0xEuLL);
  word_1EBCD2602 = (32 * (*a1 & 3)) | word_1EBCD2602 & 0xFF9F;
  xmmword_1EBCD2618 = *a2;
  dword_1EBCD2678 = **a3;
  byte_1EBCD268C = 1;
  dword_1EBCD2688 = dword_1EBCD2678;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD25F8);
}

void sub_1CD56E654(_WORD *a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD26B8, 0, 0);
  byte_1EBCD2738 = 0;
  qword_1EBCD2740 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD2748 = 0;
  qword_1EBCD26B8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD2750 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD2758 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD2770 = (uint64_t)&qword_1EBCD2758;
  sub_1CD56E744(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD26B8);
}

__n128 sub_1CD56E744(_WORD *a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD26B8, "exhaustive-register-search", 0x1AuLL);
  __int16 v6 = word_1EBCD26C2;
  word_1EBCD26C2 = word_1EBCD26C2 & 0xFF9F | (32 * (*a1 & 3));
  __n128 result = *a2;
  xmmword_1EBCD26D8 = (__int128)*a2;
  word_1EBCD26C2 = v6 & 0xFF9F | (32 * (*a3 & 3));
  return result;
}

void sub_1CD56E7B8(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD2838, 0, 0);
  xmmword_1EBCD28B8 = 0u;
  *(_OWORD *)&qword_1EBCD28C8 = 0u;
  *((void *)&xmmword_1EBCD28B8 + 1) = &unk_1F2611D50;
  qword_1EBCD2838 = (uint64_t)&unk_1F2611CE8;
  qword_1EBCD28D8 = (uint64_t)&unk_1F2643DE0;
  qword_1EBCD28E0 = (uint64_t)&unk_1F2611DB8;
  qword_1EBCD28F8 = (uint64_t)&qword_1EBCD28E0;
  llvm::cl::Option::setArgStr(v6, "grow-region-complexity-budget", 0x1DuLL);
  xmmword_1EBCD2858 = *a1;
  *(void *)&xmmword_1EBCD28B8 = **a2;
  byte_1EBCD28D0 = 1;
  qword_1EBCD28C8 = xmmword_1EBCD28B8;
  word_1EBCD2842 = (32 * (*a3 & 3)) | word_1EBCD2842 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2838);
}

void sub_1CD56E8E8()
{
}

void *sub_1CD56E8FC()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2611DB8;
  return result;
}

void sub_1CD56E934(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2611DB8;
}

void sub_1CD56E960()
{
}

uint64_t sub_1CD56E9D0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(uint64_t **)result;
    uint64_t v6 = 144 * v2;
    do
    {
      __n128 result = sub_1CD56EA54(a2, v5);
      v5 += 18;
      a2 += 144;
      v6 -= 144;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(v4 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)v4;
      uint64_t v9 = 144 * v7;
      uint64_t v10 = v8 - 144;
      do
      {
        __n128 result = (uint64_t)sub_1CC422100((void *)(v10 + v9));
        v9 -= 144;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t sub_1CD56EA54(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = v4;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 8) = v5;
  if (v5) {
    ++*(_DWORD *)(v5 + 8);
  }
  *(void *)(a1 + 24) = a1 + 40;
  uint64_t v6 = a1 + 24;
  *(void *)(a1 + 32) = 0x600000000;
  if (*((_DWORD *)a2 + 8)) {
    sub_1CB837F14(v6, (uint64_t)(a2 + 3));
  }
  *(void *)(a1 + 96) = a1 + 112;
  *(_DWORD *)(a1 + 88) = *((_DWORD *)a2 + 22);
  *(void *)(a1 + 104) = 0x800000000;
  if (*((_DWORD *)a2 + 26)) {
    sub_1CC0778D4(a1 + 96, (uint64_t)(a2 + 12));
  }
  return a1;
}

uint64_t sub_1CD56EAF8(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(result + 12) < a2) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v2 != a2)
      {
        uint64_t v3 = *(void *)result + 16 * a2;
        uint64_t v4 = *(void *)result + 16 * v2;
        do
        {
          *(void *)uint64_t v4 = 0;
          *(_DWORD *)(v4 + 8) = 0;
          v4 += 16;
        }
        while (v4 != v3);
      }
    }
    *(_DWORD *)(result + 8) = a2;
  }
  return result;
}

uint64_t sub_1CD56EB80(uint64_t a1, int a2, int a3, int a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)(37 * a4) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (_DWORD *)(a1 + 8 * v9);
    int v11 = *v10;
    int v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v16 = 1;
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v14) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v12 == -2;
        }
        if (v18 && v11 == -2) {
          uint64_t v14 = v10;
        }
        unsigned int v20 = v9 + v15++;
        unsigned int v9 = v20 & v8;
        uint64_t v10 = (_DWORD *)(a1 + 8 * (v20 & v8));
        int v11 = *v10;
        int v12 = v10[1];
        uint64_t v16 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_11;
        }
      }
      uint64_t v16 = 0;
      if (v14) {
        uint64_t v10 = v14;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v16 = 0;
  }
LABEL_11:
  *a5 = v10;
  return v16;
}

uint64_t sub_1CD56EC64(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD56EB80(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v10);
  unint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD56ECF8(a2, a3, v10);
    unint64_t v7 = (_DWORD *)result;
    *(void *)uint64_t result = *(void *)a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

_DWORD *sub_1CD56ECF8(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
LABEL_3:
    sub_1CC42B9E8(a1, v6);
    uint64_t v9 = 0;
    sub_1CD56EB80(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
    a3 = v9;
    goto LABEL_4;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

uint64_t sub_1CD56EDB4(uint64_t result, int *a2, int *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6) {
    uint64_t result = (uint64_t)memset(*(void **)result, 255, 8 * v6);
  }
  while (a2 != a3)
  {
    int v7 = *a2;
    int v8 = a2[1];
    if ((*a2 != -1 || v8 != -1) && (v7 != -2 || v8 != -2))
    {
      int v12 = 0;
      uint64_t result = sub_1CD56EB80(*(void *)v5, *(_DWORD *)(v5 + 16), v7, v8, &v12);
      int v11 = v12;
      *int v12 = *a2;
      v11[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

uint64_t **sub_1CD56EE6C(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = (uint64_t *)v9;
    uint64_t v9 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v9 + 7) = **a4;
    *((_DWORD *)v9 + 8) = 0;
    *uint64_t v9 = 0;
    v9[1] = 0;
    v9[2] = v11;
    *int v7 = (uint64_t *)v9;
    int v12 = (uint64_t *)**a1;
    char v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1 = v12;
      char v13 = *v7;
    }
    sub_1CB8358B8(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

void sub_1CD56EFA4(_WORD *a1, int **a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBD05F88, 0, 0);
  dword_1EBD06008 = 0;
  qword_1EBD06010 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD06018 = 0;
  qword_1EBD05F88 = (uint64_t)&unk_1F2643F00;
  qword_1EBD06020 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD06028 = (uint64_t)&unk_1F25EA168;
  qword_1EBD06040 = (uint64_t)&qword_1EBD06028;
  sub_1CD56F0A4(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD05F88);
}

__n128 sub_1CD56F0A4(_WORD *a1, int **a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBD05F88, "stress-regalloc", 0xFuLL);
  word_1EBD05F92 = (32 * (*a1 & 3)) | word_1EBD05F92 & 0xFF9F;
  dword_1EBD06008 = **a2;
  byte_1EBD0601C = 1;
  dword_1EBD06018 = dword_1EBD06008;
  xmmword_1EBD05FB8 = *a3;
  __n128 result = *a4;
  xmmword_1EBD05FA8 = (__int128)*a4;
  return result;
}

void llvm::initializeRegisterCoalescerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD2C48, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC42F788;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD2C48, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t *sub_1CD56F1B0(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v5 = 40 * v2;
    uint64_t v6 = (void *)(v3 + 24);
    do
    {
      if (*((_DWORD *)v6 - 6) <= 0xFFFFFFFD)
      {
        int v7 = (void *)*(v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
      }
      v6 += 5;
      v5 -= 40;
    }
    while (v5);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t *sub_1CD56F22C(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v5 = 32 * v2;
    uint64_t v6 = (void *)(v3 + 24);
    do
    {
      if (*((_DWORD *)v6 - 6) <= 0xFFFFFFFD)
      {
        int v7 = (void *)*(v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
      }
      v6 += 4;
      v5 -= 32;
    }
    while (v5);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

_DWORD *sub_1CD56F2A4(uint64_t a1, int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD56F374(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((void *)v6 + 1) = v6 + 6;
    *((void *)v6 + 2) = 0x200000000;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    unsigned int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        unsigned int v10 = v6;
      }
      int v13 = v5 + v11++;
      uint64_t v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD56F374(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD56F4EC(a1, 2 * v6);
    int v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v10 = (37 * *a2) & v9;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
    int v11 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          BOOL v12 = a3;
        }
        int v15 = v10 + v13++;
        uint64_t v10 = v15 & v9;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
        int v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      int v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD56F4EC(a1, v6);
    int v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v17 = (37 * *a2) & v16;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v17);
    int v18 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          BOOL v12 = a3;
        }
        int v21 = v17 + v19++;
        uint64_t v17 = v21 & v16;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v17);
        int v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD56F4EC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC432734(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      _DWORD *result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CD56F5B8(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CC432578(a1);
  if (v2)
  {
    int v3 = 1 << (33 - __clz(v2 - 1));
    if (v3 <= 64) {
      unsigned int v4 = 64;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v4 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v5 = 32 * v4;
      unint64_t v6 = *(_DWORD **)a1;
      do
      {
        *unint64_t v6 = -1;
        v6 += 8;
        v5 -= 32;
      }
      while (v5);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v4 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CBFFB9D0(a1, v4);
}

_DWORD *sub_1CD56F678(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC432B00(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      _DWORD *result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

_DWORD *sub_1CD56F744(uint64_t a1, int *a2)
{
  int v7 = 0;
  char v4 = sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD56F7C4(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = v5 + 6;
    *((void *)v5 + 2) = 0x400000000;
  }
  return v5;
}

_DWORD *sub_1CD56F7C4(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD56F878(a1, v6);
  unsigned int v8 = 0;
  sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD56F878(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD56F950(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      _DWORD *result = -1;
      result += 10;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

void sub_1CD56F950(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 40 * v6;
    do
    {
      *int v7 = -1;
      v7 += 10;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        int v13 = 0;
        sub_1CD56AEFC(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *int v13 = *(_DWORD *)v4;
        *((void *)v10 + 2) = 0x400000000;
        *((void *)v10 + 1) = v10 + 6;
        uint64_t v11 = (uint64_t)(v10 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CB927804(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

_DWORD *sub_1CD56FA44(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  if (!v6)
  {
    BOOL v12 = 0;
LABEL_6:
    __n128 result = sub_1CD56FB14(a2, v12, a3, a4);
    uint64_t v7 = *(void *)a2;
    unsigned int v6 = *(_DWORD *)(a2 + 16);
    char v11 = 1;
    goto LABEL_4;
  }
  uint64_t v7 = *(void *)a2;
  uint64_t v8 = (37 * *a3) & (v6 - 1);
  __n128 result = (_DWORD *)(*(void *)a2 + 32 * v8);
  int v10 = *result;
  if (*a3 != *result)
  {
    int v13 = 0;
    int v14 = 1;
    while (v10 != -1)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v10 == -2;
      }
      if (v15) {
        int v13 = result;
      }
      int v16 = v8 + v14++;
      uint64_t v8 = v16 & (v6 - 1);
      __n128 result = (_DWORD *)(v7 + 32 * v8);
      int v10 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v13) {
      BOOL v12 = v13;
    }
    else {
      BOOL v12 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v11 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v7 + 32 * v6;
  *(unsigned char *)(a1 + 16) = v11;
  return result;
}

_DWORD *sub_1CD56FB14(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4)
{
  unsigned int v6 = sub_1CD56F374(a1, a3, a2);
  *unsigned int v6 = *a3;
  *((void *)v6 + 1) = v6 + 6;
  *((void *)v6 + 2) = 0x200000000;
  if (*(_DWORD *)(a4 + 8)) {
    sub_1CC0778D4((uint64_t)(v6 + 2), a4);
  }
  return v6;
}

void *sub_1CD56FB80(void *result, unsigned int a2, uint64_t a3)
{
  if (a2)
  {
    unint64_t v3 = a2;
    do
    {
      unint64_t v4 = v3 >> 1;
      unint64_t v5 = &result[3 * (v3 >> 1)];
      uint64_t v7 = *v5;
      unsigned int v6 = v5 + 3;
      v3 += ~(v3 >> 1);
      if ((*(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (a3 >> 1) & 3) < ((v7 >> 1) & 3 | *(_DWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 24))) {
        unint64_t v3 = v4;
      }
      else {
        __n128 result = v6;
      }
    }
    while (v3);
  }
  return result;
}

void sub_1CD56FBD8(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD2D10, 0, 0);
  byte_1EBCD2D90 = 0;
  qword_1EBCD2D98 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD2DA0 = 0;
  qword_1EBCD2D10 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD2DA8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD2DB0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD2DC8 = (uint64_t)&qword_1EBCD2DB0;
  sub_1CD56FCC8(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2D10);
}

__n128 sub_1CD56FCC8(__n128 *a1, char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD2D10, "terminal-rule", 0xDuLL);
  __n128 result = *a1;
  xmmword_1EBCD2D30 = (__int128)*a1;
  uint64_t v7 = *a2;
  byte_1EBCD2D90 = **a2;
  byte_1EBCD2DA1 = 1;
  byte_1EBCD2DA0 = *v7;
  word_1EBCD2D1A = (32 * (*a3 & 3)) | word_1EBCD2D1A & 0xFF9F;
  return result;
}

void sub_1CD56FD50(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD2DD0, 0, 0);
  byte_1EBCD2E50 = 0;
  qword_1EBCD2E58 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD2E60 = 0;
  qword_1EBCD2DD0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD2E68 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD2E70 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD2E88 = (uint64_t)&qword_1EBCD2E70;
  llvm::cl::Option::setArgStr(v4, "join-splitedges", 0xFuLL);
  xmmword_1EBCD2DF0 = *a1;
  word_1EBCD2DDA = (32 * (*a2 & 3)) | word_1EBCD2DDA & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2DD0);
}

void sub_1CD56FE5C(__n128 *a1, int **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD2E90, 0, 0);
  dword_1EBCD2F10 = 0;
  qword_1EBCD2F18 = (uint64_t)&unk_1F2643C00;
  *(void *)&dword_1EBCD2F20 = 0;
  qword_1EBCD2E90 = (uint64_t)&unk_1F2609740;
  qword_1EBCD2F28 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD2F30 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD2F48 = (uint64_t)&qword_1EBCD2F30;
  sub_1CD56FF4C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2E90);
}

__n128 sub_1CD56FF4C(__n128 *a1, int **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD2E90, "join-globalcopies", 0x11uLL);
  __n128 result = *a1;
  xmmword_1EBCD2EB0 = (__int128)*a1;
  uint64_t v7 = *a2;
  dword_1EBCD2F10 = **a2;
  byte_1EBCD2F24 = 1;
  dword_1EBCD2F20 = *v7;
  word_1EBCD2E9A = (32 * (*a3 & 3)) | word_1EBCD2E9A & 0xFF9F;
  return result;
}

void sub_1CD56FFD4(long long *a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD2F50, 0, 0);
  byte_1EBCD2FD0 = 0;
  qword_1EBCD2FD8 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD2FE0 = 0;
  qword_1EBCD2F50 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD2FE8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD2FF0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD3008 = (uint64_t)&qword_1EBCD2FF0;
  llvm::cl::Option::setArgStr(v4, "verify-coalescing", 0x11uLL);
  xmmword_1EBCD2F70 = *a1;
  word_1EBCD2F5A = (32 * (*a2 & 3)) | word_1EBCD2F5A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD2F50);
}

llvm::raw_ostream *llvm::dumpRegSetPressure(llvm::raw_ostream *result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (!a2) {
    goto LABEL_10;
  }
  unint64_t v5 = result;
  uint64_t v6 = 0;
  char v7 = 1;
  do
  {
    if (*((_DWORD *)v5 + v6))
    {
      uint64_t v8 = llvm::dbgs(result);
      int v9 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 304))(a3, v6);
      int v10 = sub_1CB8E509C(v8, v9);
      char v11 = sub_1CB8E509C(v10, "=");
      __n128 result = llvm::raw_ostream::operator<<(v11, *((unsigned int *)v5 + v6));
      BOOL v12 = (unsigned char *)*((void *)result + 4);
      if ((unint64_t)v12 >= *((void *)result + 3))
      {
        __n128 result = llvm::raw_ostream::write(result, 10);
        char v7 = 0;
      }
      else
      {
        char v7 = 0;
        *((void *)result + 4) = v12 + 1;
        *BOOL v12 = 10;
      }
    }
    ++v6;
  }
  while (v3 != v6);
  if (v7)
  {
LABEL_10:
    int v13 = llvm::dbgs(result);
    return sub_1CB8E509C(v13, "\n");
  }
  return result;
}

llvm *llvm::RegisterPressure::dump(llvm::RegisterPressure *this, const llvm::TargetRegisterInfo *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = llvm::dbgs(this);
  sub_1CB8E509C(v4, "Max Pressure: ");
  unint64_t v5 = llvm::dumpRegSetPressure(*(llvm::raw_ostream **)this, (uint64_t)(*((void *)this + 1) - *(void *)this) >> 2, (uint64_t)a2);
  uint64_t v6 = llvm::dbgs(v5);
  char v7 = sub_1CB8E509C(v6, "Live In: ");
  uint64_t v8 = *((unsigned int *)this + 8);
  if (v8)
  {
    uint64_t v11 = 16 * v8;
    BOOL v12 = (uint64_t *)(*((void *)this + 3) + 8);
    while (1)
    {
      int v13 = llvm::dbgs(v7);
      llvm::printVRegOrUnit(*((unsigned int *)v12 - 2), (uint64_t)a2, &v35);
      if (!v37) {
        break;
      }
      (*((void (**)(void **, llvm *))*v37 + 6))(v37, v13);
      int v14 = (llvm *)v37;
      if (v37 == (void **)&v35)
      {
        int v14 = (llvm *)v35[4]((void **)&v35);
      }
      else if (v37)
      {
        int v14 = (llvm *)(*((uint64_t (**)(void))*v37 + 5))();
      }
      if (*v12 != -1)
      {
        int v16 = llvm::dbgs(v14);
        uint64_t v17 = (unsigned char *)*((void *)v16 + 4);
        if ((unint64_t)v17 >= *((void *)v16 + 3))
        {
          int v16 = llvm::raw_ostream::write(v16, 58);
        }
        else
        {
          *((void *)v16 + 4) = v17 + 1;
          *uint64_t v17 = 58;
        }
        uint64_t v18 = *v12;
        uint64_t v37 = (void **)&v35;
        uint64_t v35 = (uint64_t (**)(void **))&unk_1F260C990;
        uint64_t v36 = v18;
        std::string v32 = &unk_1F25FF808;
        v33 = "%016llX";
        uint64_t v34 = v18;
        llvm::raw_ostream::operator<<(v16, (uint64_t)&v32);
        int v14 = (llvm *)v37;
        if (v37 == (void **)&v35)
        {
          int v14 = (llvm *)v35[4]((void **)&v35);
        }
        else if (v37)
        {
          int v14 = (llvm *)(*((uint64_t (**)(void))*v37 + 5))();
        }
      }
      char v7 = llvm::dbgs(v14);
      BOOL v15 = (unsigned char *)*((void *)v7 + 4);
      if ((unint64_t)v15 >= *((void *)v7 + 3))
      {
        char v7 = llvm::raw_ostream::write(v7, 32);
      }
      else
      {
        *((void *)v7 + 4) = v15 + 1;
        *BOOL v15 = 32;
      }
      v12 += 2;
      v11 -= 16;
      if (!v11) {
        goto LABEL_2;
      }
    }
LABEL_47:
    sub_1CB920400();
  }
LABEL_2:
  int v9 = llvm::dbgs(v7);
  int v10 = (unsigned char *)*((void *)v9 + 4);
  if ((unint64_t)v10 >= *((void *)v9 + 3))
  {
    int v9 = llvm::raw_ostream::write(v9, 10);
  }
  else
  {
    *((void *)v9 + 4) = v10 + 1;
    unsigned char *v10 = 10;
  }
  int v19 = llvm::dbgs(v9);
  BOOL v20 = sub_1CB8E509C(v19, "Live Out: ");
  uint64_t v21 = *((unsigned int *)this + 44);
  if (v21)
  {
    uint64_t v24 = 16 * v21;
    char v25 = (uint64_t *)(*((void *)this + 21) + 8);
    do
    {
      uint64_t v26 = llvm::dbgs(v20);
      llvm::printVRegOrUnit(*((unsigned int *)v25 - 2), (uint64_t)a2, &v35);
      if (!v37) {
        goto LABEL_47;
      }
      (*((void (**)(void **, llvm *))*v37 + 6))(v37, v26);
      char v27 = (llvm *)v37;
      if (v37 == (void **)&v35)
      {
        char v27 = (llvm *)v35[4]((void **)&v35);
      }
      else if (v37)
      {
        char v27 = (llvm *)(*((uint64_t (**)(void))*v37 + 5))();
      }
      if (*v25 != -1)
      {
        char v29 = llvm::dbgs(v27);
        uint64_t v30 = (unsigned char *)*((void *)v29 + 4);
        if ((unint64_t)v30 >= *((void *)v29 + 3))
        {
          char v29 = llvm::raw_ostream::write(v29, 58);
        }
        else
        {
          *((void *)v29 + 4) = v30 + 1;
          *uint64_t v30 = 58;
        }
        uint64_t v31 = *v25;
        uint64_t v37 = (void **)&v35;
        uint64_t v35 = (uint64_t (**)(void **))&unk_1F260C990;
        uint64_t v36 = v31;
        std::string v32 = &unk_1F25FF808;
        v33 = "%016llX";
        uint64_t v34 = v31;
        llvm::raw_ostream::operator<<(v29, (uint64_t)&v32);
        char v27 = (llvm *)v37;
        if (v37 == (void **)&v35)
        {
          char v27 = (llvm *)v35[4]((void **)&v35);
        }
        else if (v37)
        {
          char v27 = (llvm *)(*((uint64_t (**)(void))*v37 + 5))();
        }
      }
      BOOL v20 = llvm::dbgs(v27);
      v28 = (unsigned char *)*((void *)v20 + 4);
      if ((unint64_t)v28 >= *((void *)v20 + 3))
      {
        BOOL v20 = llvm::raw_ostream::write(v20, 32);
      }
      else
      {
        *((void *)v20 + 4) = v28 + 1;
        unsigned char *v28 = 32;
      }
      v25 += 2;
      v24 -= 16;
    }
    while (v24);
  }
  __n128 result = llvm::dbgs(v20);
  char v23 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v23 >= *((void *)result + 3)) {
    return llvm::raw_ostream::write(result, 10);
  }
  *((void *)result + 4) = v23 + 1;
  *char v23 = 10;
  return result;
}

llvm *llvm::RegPressureTracker::dump(llvm::RegPressureTracker *this)
{
  int v2 = *((unsigned __int8 *)this + 56);
  uint64_t v3 = (llvm *)*((void *)this + 6);
  if (!v2)
  {
    if (!*((void *)v3 + 39) && !*((void *)v3 + 40)) {
      goto LABEL_8;
    }
LABEL_7:
    uint64_t v4 = llvm::dbgs(v3);
    sub_1CB8E509C(v4, "Curr Pressure: ");
    llvm::dumpRegSetPressure(*((llvm::raw_ostream **)this + 9), (uint64_t)(*((void *)this + 10) - *((void *)this + 9)) >> 2, *((void *)this + 1));
    uint64_t v3 = (llvm *)*((void *)this + 6);
    goto LABEL_8;
  }
  if (*((void *)v3 + 39) <= 7uLL || *((void *)v3 + 40) <= 7uLL) {
    goto LABEL_7;
  }
LABEL_8:
  unint64_t v5 = (const llvm::TargetRegisterInfo *)*((void *)this + 1);

  return llvm::RegisterPressure::dump(v3, v5);
}

llvm *llvm::PressureDiff::dump(llvm::PressureDiff *this, const llvm::TargetRegisterInfo *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = (llvm::PressureDiff *)((char *)this + 64);
  unint64_t v5 = "";
  do
  {
    if (!*(_WORD *)v3) {
      break;
    }
    uint64_t v6 = llvm::dbgs(this);
    char v7 = sub_1CB8E509C(v6, v5);
    uint64_t v8 = (char *)(*(uint64_t (**)(const llvm::TargetRegisterInfo *, void))(*(void *)a2 + 304))(a2, *(unsigned __int16 *)v3 - 1);
    int v9 = sub_1CB8E509C(v7, v8);
    int v10 = sub_1CB8E509C(v9, " ");
    this = llvm::raw_ostream::operator<<(v10, *((__int16 *)v3 + 1));
    uint64_t v3 = (llvm::PressureDiff *)((char *)v3 + 4);
    unint64_t v5 = "    ";
  }
  while (v3 != v4);
  __n128 result = llvm::dbgs(this);
  BOOL v12 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v12 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v12 + 1;
    *BOOL v12 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::PressureChange::dump(llvm::PressureChange *this)
{
  int v2 = llvm::dbgs(this);
  uint64_t v3 = sub_1CB8E509C(v2, "[");
  uint64_t v4 = llvm::raw_ostream::operator<<(v3, (unsigned __int16)(*(_WORD *)this - 1));
  unint64_t v5 = sub_1CB8E509C(v4, ", ");
  uint64_t v6 = llvm::raw_ostream::operator<<(v5, *((__int16 *)this + 1));

  return sub_1CB8E509C(v6, "]\n");
}

uint64_t llvm::RegisterOperands::detectDeadDefs(llvm::RegisterOperands *this, const llvm::MachineInstr *a2, const llvm::LiveIntervals *a3)
{
  uint64_t result = sub_1CBB24CA0(*((void *)a3 + 36), (unint64_t)a2, 0);
  unsigned int v6 = *((_DWORD *)this + 38);
  if (v6)
  {
    uint64_t v7 = result;
    uint64_t v8 = (unsigned int *)*((void *)this + 18);
    do
    {
      uint64_t v9 = *v8;
      if ((v9 & 0x80000000) != 0)
      {
        uint64_t result = sub_1CC2F12AC((uint64_t)a3, v9);
      }
      else
      {
        uint64_t result = *(void *)(*((void *)a3 + 85) + 8 * v9);
        if (!result) {
          goto LABEL_11;
        }
      }
      uint64_t result = sub_1CC2FC02C(result, v7, (uint64_t)v13);
      if ((~v13[16] & 6) == 0)
      {
        unint64_t v10 = *((unsigned int *)this + 74);
        if (v10 >= *((unsigned int *)this + 75)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_OWORD *)(*((void *)this + 36) + 16 * v10) = *(_OWORD *)v8;
        ++*((_DWORD *)this + 74);
        uint64_t v11 = *((unsigned int *)this + 38);
        uint64_t v12 = *((void *)this + 18) + 16 * v11;
        if ((unsigned int *)v12 != v8 + 4)
        {
          uint64_t result = (uint64_t)memmove(v8, v8 + 4, v12 - (void)(v8 + 4));
          LODWORD(v11) = *((_DWORD *)this + 38);
        }
        unsigned int v6 = v11 - 1;
        *((_DWORD *)this + 38) = v6;
        continue;
      }
      unsigned int v6 = *((_DWORD *)this + 38);
LABEL_11:
      v8 += 4;
    }
    while (v8 != (unsigned int *)(*((void *)this + 18) + 16 * v6));
  }
  return result;
}

uint64_t llvm::RegPressureTracker::advance(llvm::RegPressureTracker *this, unsigned int **a2)
{
  uint64_t v4 = *((void *)this + 6);
  if (*((unsigned char *)this + 56))
  {
    if (*(void *)(v4 + 312) > 7uLL) {
      goto LABEL_10;
    }
    goto LABEL_5;
  }
  if (*(void *)(v4 + 312))
  {
LABEL_5:
    llvm::RegPressureTracker::closeTop((unint64_t)this);
    if (!*((unsigned char *)this + 56))
    {
      uint64_t v4 = *((void *)this + 6);
      goto LABEL_7;
    }
LABEL_10:
    unint64_t CurrSlot = llvm::RegPressureTracker::getCurrSlot(this);
    uint64_t v4 = *((void *)this + 6);
    unint64_t v6 = *(void *)(v4 + 320);
    if (v6 <= 7
      || (*(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24) | (v6 >> 1) & 3) > (*(_DWORD *)((CurrSlot & 0xFFFFFFFFFFFFFFF8) + 24) | (CurrSlot >> 1) & 3))
    {
      goto LABEL_14;
    }
LABEL_12:
    *(void *)(v4 + 320) = 0;
    *(_DWORD *)(v4 + 32) = 0;
    goto LABEL_14;
  }
LABEL_7:
  if (*(void *)(v4 + 320))
  {
    unint64_t CurrSlot = 0;
    goto LABEL_14;
  }
  unint64_t CurrSlot = 0;
  if (!*((void *)this + 8)) {
    goto LABEL_12;
  }
LABEL_14:
  uint64_t v7 = *((unsigned int *)a2 + 2);
  if (v7)
  {
    int v19 = *a2;
    uint64_t v20 = (uint64_t)&(*a2)[4 * v7];
    unint64_t v21 = CurrSlot & 0xFFFFFFFFFFFFFFF8;
    do
    {
      uint64_t v22 = *v19;
      uint64_t v23 = v22;
      unsigned int v24 = *v19;
      if ((v22 & 0x80000000) != 0)
      {
        uint64_t v23 = *((_DWORD *)this + 64) + (v22 & 0x7FFFFFFF);
        unsigned int v24 = *((_DWORD *)this + 64) + (v22 & 0x7FFFFFFF);
      }
      unsigned int v25 = *(unsigned __int8 *)(*((void *)this + 30) + v23);
      unsigned int v26 = *((_DWORD *)this + 26);
      if (v26 <= v25) {
        goto LABEL_31;
      }
      uint64_t v27 = *((void *)this + 12);
      while (1)
      {
        unsigned int v28 = v25;
        if (*(_DWORD *)(v27 + 16 * v25) == v24) {
          break;
        }
        v25 += 256;
        if (v28 + 256 >= v26) {
          goto LABEL_31;
        }
      }
      if (v26 == v25) {
LABEL_31:
      }
        uint64_t v29 = 0;
      else {
        uint64_t v29 = *(void *)(v27 + 16 * v25 + 8);
      }
      uint64_t v30 = *((void *)v19 + 1);
      if ((v30 & ~v29) != 0)
      {
        llvm::RegPressureTracker::discoverLiveInOrOut((uint64_t)this, *v19, v30 & ~v29, (uint64_t *)(*((void *)this + 6) + 24));
        llvm::RegPressureTracker::increaseRegPressure((uint64_t)this, v22, v29, v30 | v29);
        unsigned int v31 = v22;
        if ((v22 & 0x80000000) != 0) {
          unsigned int v31 = *((_DWORD *)this + 64) + (v22 & 0x7FFFFFFF);
        }
        unsigned int v36 = v31;
        uint64_t v37 = v30 & ~v29;
        uint64_t v32 = sub_1CC446CA4((uint64_t *)this + 12, &v36);
        if ((v33 & 1) == 0) {
          *(void *)(v32 + 8) |= v30 & ~v29;
        }
      }
      if (*((unsigned char *)this + 56))
      {
        uint64_t v34 = sub_1CC4464AC(*((void *)this + 4), *((void *)this + 3), *((unsigned char *)this + 58), v22, v21, 0, (unsigned int (*)(void))sub_1CC446E54);
        if (v34)
        {
          uint64_t v35 = v34;
          sub_1CC445438((uint64_t *)this + 12, v22, v34);
          llvm::RegPressureTracker::decreaseRegPressure((uint64_t)this, v22, v29, v29 & ~v35);
        }
      }
      v19 += 4;
    }
    while (v19 != (unsigned int *)v20);
  }
  uint64_t v8 = *((unsigned int *)a2 + 38);
  if (v8)
  {
    uint64_t v9 = a2[18];
    unint64_t v10 = &v9[4 * v8];
    do
    {
      int v11 = *v9;
      if ((*v9 & 0x80000000) != 0) {
        int v11 = *((_DWORD *)this + 64) + (v11 & 0x7FFFFFFF);
      }
      uint64_t v12 = *((void *)v9 + 1);
      unsigned int v36 = v11;
      uint64_t v37 = v12;
      uint64_t v13 = sub_1CC446CA4((uint64_t *)this + 12, &v36);
      if (v14)
      {
        uint64_t v15 = 0;
      }
      else
      {
        uint64_t v15 = *(void *)(v13 + 8);
        *(void *)(v13 + 8) = v15 | v12;
      }
      uint64_t v16 = *((void *)v9 + 1) | v15;
      unsigned int v17 = *v9;
      v9 += 4;
      llvm::RegPressureTracker::increaseRegPressure((uint64_t)this, v17, v15, v16);
    }
    while (v9 != v10);
  }
  llvm::RegPressureTracker::bumpDeadDefs((uint64_t)this, a2[36], *((unsigned int *)a2 + 74));
  uint64_t result = sub_1CD570D34(*((void *)this + 8), *((void *)this + 5) + 48);
  *((void *)this + 8) = result;
  return result;
}

uint64_t sub_1CD570D34(uint64_t a1, uint64_t a2)
{
  if (!a1 || (*(unsigned char *)a1 & 4) == 0)
  {
    while ((*(_WORD *)(a1 + 44) & 8) != 0)
      a1 = *(void *)(a1 + 8);
  }
  return sub_1CC442FE8(*(void *)(a1 + 8), a2);
}

uint64_t llvm::RegPressureTracker::bumpUpwardPressure(llvm::RegPressureTracker *this, const llvm::MachineInstr *a2)
{
  v37[16] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 56)) {
    unint64_t v4 = sub_1CBB24CA0(*(void *)(*((void *)this + 4) + 288), (unint64_t)a2, 0) & 0xFFFFFFFFFFFFFFF8 | 4;
  }
  else {
    unint64_t v4 = 0;
  }
  uint64_t v29 = &v31;
  uint64_t v30 = 0x800000000;
  uint64_t v32 = (unsigned int *)&v34;
  uint64_t v33 = 0x800000000;
  uint64_t v35 = (unsigned int *)v37;
  uint64_t v36 = 0x800000000;
  llvm::RegisterOperands::collect(&v29, a2, *((const llvm::TargetRegisterInfo **)this + 1), *((const llvm::MachineRegisterInfo **)this + 3), *((unsigned __int8 *)this + 58), 1);
  if (*((unsigned char *)this + 58))
  {
    llvm::RegisterOperands::adjustLaneLiveness((uint64_t)&v29, *((void *)this + 4), *((void *)this + 3), v4, 0);
  }
  else if (*((unsigned char *)this + 56))
  {
    llvm::RegisterOperands::detectDeadDefs((llvm::RegisterOperands *)&v29, a2, *((const llvm::LiveIntervals **)this + 4));
  }
  llvm::RegPressureTracker::bumpDeadDefs((uint64_t)this, v35, v36);
  if (v33)
  {
    unint64_t v5 = v32;
    unint64_t v6 = &v32[4 * v33];
    do
    {
      uint64_t v7 = *v5;
      uint64_t v8 = v7;
      unsigned int v9 = *v5;
      if ((v7 & 0x80000000) != 0)
      {
        uint64_t v8 = *((_DWORD *)this + 64) + (v7 & 0x7FFFFFFF);
        unsigned int v9 = *((_DWORD *)this + 64) + (v7 & 0x7FFFFFFF);
      }
      unsigned int v10 = *(unsigned __int8 *)(*((void *)this + 30) + v8);
      unsigned int v11 = *((_DWORD *)this + 26);
      if (v11 <= v10) {
        goto LABEL_13;
      }
      uint64_t v12 = *((void *)this + 12);
      while (1)
      {
        unsigned int v13 = v10;
        if (*(_DWORD *)(v12 + 16 * v10) == v9) {
          break;
        }
        v10 += 256;
        if (v13 + 256 >= v11) {
          goto LABEL_13;
        }
      }
      if (v11 == v10) {
LABEL_13:
      }
        uint64_t v14 = 0;
      else {
        uint64_t v14 = *(void *)(v12 + 16 * v10 + 8);
      }
      if (v30)
      {
        uint64_t v15 = v29 + 1;
        uint64_t v16 = 16 * v30;
        while (v7 != *((_DWORD *)v15 - 2))
        {
          v15 += 2;
          v16 -= 16;
          if (!v16) {
            goto LABEL_18;
          }
        }
        uint64_t v17 = *v15;
      }
      else
      {
LABEL_18:
        uint64_t v17 = 0;
      }
      llvm::RegPressureTracker::decreaseRegPressure((uint64_t)this, v7, v14, v14 & ~*((void *)v5 + 1) | v17);
      v5 += 4;
    }
    while (v5 != v6);
  }
  if (v30)
  {
    uint64_t v18 = (unsigned int *)v29;
    int v19 = (unsigned int *)&v29[2 * v30];
    do
    {
      uint64_t v20 = *v18;
      uint64_t v21 = v20;
      unsigned int v22 = *v18;
      if ((v20 & 0x80000000) != 0)
      {
        uint64_t v21 = *((_DWORD *)this + 64) + (v20 & 0x7FFFFFFF);
        unsigned int v22 = *((_DWORD *)this + 64) + (v20 & 0x7FFFFFFF);
      }
      unsigned int v23 = *(unsigned __int8 *)(*((void *)this + 30) + v21);
      unsigned int v24 = *((_DWORD *)this + 26);
      if (v24 <= v23) {
        goto LABEL_32;
      }
      uint64_t v25 = *((void *)this + 12);
      while (1)
      {
        unsigned int v26 = v23;
        if (*(_DWORD *)(v25 + 16 * v23) == v22) {
          break;
        }
        v23 += 256;
        if (v26 + 256 >= v24) {
          goto LABEL_32;
        }
      }
      if (v24 == v23) {
LABEL_32:
      }
        uint64_t v27 = 0;
      else {
        uint64_t v27 = *(void *)(v25 + 16 * v23 + 8);
      }
      llvm::RegPressureTracker::increaseRegPressure((uint64_t)this, v20, v27, *((void *)v18 + 1) | v27);
      v18 += 4;
    }
    while (v18 != v19);
  }
  return sub_1CC397418((uint64_t)&v29);
}

uint64_t llvm::RegPressureTracker::bumpDownwardPressure(llvm::RegPressureTracker *this, const llvm::MachineInstr *a2)
{
  v49[16] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 56)) {
    unint64_t v4 = sub_1CBB24CA0(*(void *)(*((void *)this + 4) + 288), (unint64_t)a2, 0) & 0xFFFFFFFFFFFFFFF8 | 4;
  }
  else {
    unint64_t v4 = 0;
  }
  char v41 = (unsigned int *)&v43;
  uint64_t v42 = 0x800000000;
  unint64_t v44 = (unsigned int *)&v46;
  uint64_t v45 = 0x800000000;
  uint64_t v47 = (unsigned int *)v49;
  uint64_t v48 = 0x800000000;
  llvm::RegisterOperands::collect(&v41, a2, *((const llvm::TargetRegisterInfo **)this + 1), *((const llvm::MachineRegisterInfo **)this + 3), *((unsigned __int8 *)this + 58), 0);
  if (*((unsigned char *)this + 58)) {
    llvm::RegisterOperands::adjustLaneLiveness((uint64_t)&v41, *((void *)this + 4), *((void *)this + 3), v4, 0);
  }
  if (*((unsigned char *)this + 56) && v42)
  {
    unint64_t v5 = v41;
    uint64_t v38 = &v41[4 * v42];
    unint64_t v40 = v4 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v39 = (v4 >> 1) & 3;
    do
    {
      uint64_t v6 = *v5;
      uint64_t v7 = sub_1CC4464AC(*((void *)this + 4), *((void *)this + 3), *((unsigned char *)this + 58), *v5, v40, 0, (unsigned int (*)(void))sub_1CC446E54);
      if (v7)
      {
        uint64_t v8 = v7;
        unint64_t CurrSlot = llvm::RegPressureTracker::getCurrSlot(this);
        uint64_t v10 = *((void *)this + 3);
        uint64_t v11 = *((void *)this + 4);
        uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(*(void *)v10 + 16) + 176))(*(void *)(*(void *)v10 + 16));
        uint64_t v13 = sub_1CBB36200(v10, v6);
        if ((unsigned int *)v13 == v14)
        {
LABEL_18:
          uint64_t v20 = v6;
          int v21 = v6;
          if ((v6 & 0x80000000) != 0)
          {
            uint64_t v20 = *((_DWORD *)this + 64) + (v6 & 0x7FFFFFFF);
            int v21 = *((_DWORD *)this + 64) + (v6 & 0x7FFFFFFF);
          }
          unsigned int v22 = *(unsigned __int8 *)(*((void *)this + 30) + v20);
          unsigned int v23 = *((_DWORD *)this + 26);
          if (v23 <= v22) {
            goto LABEL_24;
          }
          uint64_t v24 = *((void *)this + 12);
          while (1)
          {
            unsigned int v25 = v22;
            if (*(_DWORD *)(v24 + 16 * v22) == v21) {
              break;
            }
            v22 += 256;
            if (v25 + 256 >= v23) {
              goto LABEL_24;
            }
          }
          if (v23 == v22) {
LABEL_24:
          }
            uint64_t v26 = 0;
          else {
            uint64_t v26 = *(void *)(v24 + 16 * v22 + 8);
          }
          llvm::RegPressureTracker::decreaseRegPressure((uint64_t)this, v6, v26, v26 & ~v8);
        }
        else
        {
          uint64_t v15 = (unsigned int *)v13;
          uint64_t v16 = v14;
          unint64_t v17 = CurrSlot & 0xFFFFFFFFFFFFFFF8;
          unsigned int v18 = (CurrSlot >> 1) & 3;
          while (1)
          {
            if ((*((unsigned char *)v15 + 3) & 0x10) == 0)
            {
              unsigned int v19 = *(_DWORD *)((sub_1CBB24CA0(*(void *)(v11 + 288), *((void *)v15 + 1), 0) & 0xFFFFFFFFFFFFFFF8)
                              + 24) | 2;
              if (v19 >= (*(_DWORD *)(v17 + 24) | v18) && v19 < (*(_DWORD *)(v40 + 24) | v39))
              {
                v8 &= ~*(void *)(*(void *)(v12 + 232) + 8 * (((unint64_t)*v15 >> 8) & 0xFFF));
                if (!v8) {
                  break;
                }
              }
            }
            do
              uint64_t v15 = (unsigned int *)*((void *)v15 + 3);
            while (v15 && (*((unsigned char *)v15 + 3) & 0x81) != 0);
            if (v15 == v16) {
              goto LABEL_18;
            }
          }
        }
      }
      v5 += 4;
    }
    while (v5 != v38);
  }
  if (v45)
  {
    uint64_t v27 = v44;
    unsigned int v28 = &v44[4 * v45];
    do
    {
      uint64_t v29 = *v27;
      uint64_t v30 = v29;
      unsigned int v31 = *v27;
      if ((v29 & 0x80000000) != 0)
      {
        uint64_t v30 = *((_DWORD *)this + 64) + (v29 & 0x7FFFFFFF);
        unsigned int v31 = *((_DWORD *)this + 64) + (v29 & 0x7FFFFFFF);
      }
      unsigned int v32 = *(unsigned __int8 *)(*((void *)this + 30) + v30);
      unsigned int v33 = *((_DWORD *)this + 26);
      if (v33 <= v32) {
        goto LABEL_38;
      }
      uint64_t v34 = *((void *)this + 12);
      while (1)
      {
        unsigned int v35 = v32;
        if (*(_DWORD *)(v34 + 16 * v32) == v31) {
          break;
        }
        v32 += 256;
        if (v35 + 256 >= v33) {
          goto LABEL_38;
        }
      }
      if (v33 == v32) {
LABEL_38:
      }
        uint64_t v36 = 0;
      else {
        uint64_t v36 = *(void *)(v34 + 16 * v32 + 8);
      }
      llvm::RegPressureTracker::increaseRegPressure((uint64_t)this, v29, v36, *((void *)v27 + 1) | v36);
      v27 += 4;
    }
    while (v27 != v28);
  }
  llvm::RegPressureTracker::bumpDeadDefs((uint64_t)this, v47, v48);
  return sub_1CC397418((uint64_t)&v41);
}

void *llvm::RegScavenger::setRegUsed(uint64_t a1, unsigned __int16 a2, uint64_t a3)
{
  return sub_1CC447034((void *)(a1 + 96), a2, a3);
}

void llvm::RegScavenger::enterBasicBlock(llvm::RegScavenger *this, llvm::MachineBasicBlock *a2)
{
  llvm::RegScavenger::init(this, a2);

  llvm::LiveRegUnits::addLiveIns((llvm::RegScavenger *)((char *)this + 96), (const llvm::MachineFunction **)a2);
}

void *llvm::RegScavenger::addRegUnits(void *result, uint64_t *a2, unsigned int a3)
{
  if (*result) {
    uint64_t v3 = (void *)(*result + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = *(unsigned int *)(*v3 + 24 * a3 + 16);
  unint64_t v5 = (unsigned __int16 *)(v3[6] + ((v4 >> 3) & 0x1FFFFFFE));
  int v7 = *v5;
  uint64_t v6 = v5 + 1;
  int v8 = v7 + (v4 & 0xF) * a3;
  uint64_t v9 = *a2;
  do
  {
    *(void *)(v9 + 8 * ((unsigned __int16)v8 >> 6)) |= 1 << v8;
    int v10 = *v6++;
    v8 += v10;
  }
  while (v10);
  return result;
}

void llvm::RegScavenger::determineKillsAndDefs(llvm::RegScavenger *this)
{
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = (void **)((char *)this + 176);
  uint64_t v4 = *((unsigned int *)this + 46);
  if (v4) {
    bzero(*v3, 8 * v4);
  }
  uint64_t v5 = *((unsigned int *)this + 64);
  if (v5) {
    bzero(*((void **)this + 31), 8 * v5);
  }
  uint64_t v6 = *(unsigned int *)(v2 + 40);
  if (v6)
  {
    int v7 = *(unsigned int **)(v2 + 32);
    int v8 = (int *)&v7[8 * v6];
    do
    {
      unsigned int v9 = *v7;
      if (*v7 == 12)
      {
        uint64_t v10 = *((void *)this + 40);
        uint64_t v11 = *((unsigned int *)this + 82);
        if (v11) {
          bzero(*((void **)this + 40), 8 * v11);
        }
        uint64_t v12 = *(unsigned int *)(*(void *)this + 44);
        if (v12)
        {
          uint64_t v13 = 0;
          uint64_t v14 = *(void *)(*(void *)this + 48);
          do
          {
            uint64_t v15 = (unsigned __int16 *)(v14 + 4 * v13);
            unsigned int v16 = *v15;
            unsigned int v17 = v15[1];
            while (v16)
            {
              int v18 = *(_DWORD *)(*((void *)v7 + 2) + 4 * (v16 >> 5)) >> v16;
              unsigned int v16 = v17;
              unsigned int v17 = 0;
              if ((v18 & 1) == 0)
              {
                *(void *)(v10 + 8 * (v13 >> 6)) |= 1 << v13;
                break;
              }
            }
            ++v13;
          }
          while (v13 != v12);
        }
        sub_1CC447398((uint64_t)v3, (uint64_t)this + 320);
        unsigned int v9 = *v7;
      }
      if ((_BYTE)v9) {
        goto LABEL_19;
      }
      unint64_t v19 = v7[1];
      if ((v19 - 1) > 0x3FFFFFFE
        || ((*(void *)(*(void *)(*((void *)this + 2) + 352) + ((v19 >> 3) & 0x1FFFFFF8)) >> v19) & 1) != 0)
      {
        goto LABEL_19;
      }
      if ((v9 & 0x1000000) != 0)
      {
        if ((~v9 & 0x5000000) != 0) {
          uint64_t v20 = (uint64_t *)((char *)this + 248);
        }
        else {
          uint64_t v20 = (uint64_t *)v3;
        }
      }
      else
      {
        if ((v9 & 0x10000000) != 0) {
          goto LABEL_19;
        }
        uint64_t v20 = (uint64_t *)v3;
        if (((v9 >> 26) & ~HIBYTE(v9) & 1) == 0) {
          goto LABEL_19;
        }
      }
      llvm::RegScavenger::addRegUnits(this, v20, v19);
LABEL_19:
      v7 += 8;
    }
    while (v7 != (unsigned int *)v8);
  }
}

uint64_t llvm::RegScavenger::forward(uint64_t this)
{
  uint64_t v1 = this;
  if (*(unsigned char *)(this + 44))
  {
    uint64_t v2 = *(void *)(this + 32);
    if (!v2 || (*(unsigned char *)v2 & 4) == 0)
    {
      while ((*(_WORD *)(v2 + 44) & 8) != 0)
        uint64_t v2 = *(void *)(v2 + 8);
    }
    uint64_t v3 = *(void *)(v2 + 8);
    *(void *)(this + 32) = v3;
  }
  else
  {
    uint64_t v3 = *(void *)(*(void *)(this + 24) + 56);
    *(void *)(this + 32) = v3;
    *(unsigned char *)(this + 44) = 1;
  }
  uint64_t v4 = *(unsigned int *)(this + 56);
  if (v4)
  {
    uint64_t v5 = 16 * v4;
    uint64_t v6 = (void *)(*(void *)(this + 48) + 8);
    do
    {
      if (*v6 == v3)
      {
        *((_DWORD *)v6 - 1) = 0;
        *uint64_t v6 = 0;
      }
      v6 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  int v7 = **(unsigned __int16 **)(v3 + 16);
  if ((v7 - 13) >= 5 && v7 != 23)
  {
    llvm::RegScavenger::determineKillsAndDefs((llvm::RegScavenger *)this);
    LODWORD(v9) = *(_DWORD *)(v1 + 112);
    unsigned int v10 = *(_DWORD *)(v1 + 184);
    if (v10 >= v9) {
      uint64_t v9 = v9;
    }
    else {
      uint64_t v9 = v10;
    }
    if (v9)
    {
      uint64_t v11 = *(uint64_t **)(v1 + 176);
      uint64_t v12 = *(void **)(v1 + 104);
      do
      {
        uint64_t v13 = *v11++;
        *v12++ &= ~v13;
        --v9;
      }
      while (v9);
    }
    return sub_1CC447398(v1 + 104, v1 + 248);
  }
  return this;
}

unint64_t llvm::RegScavenger::FindUnusedReg(uint64_t a1, unsigned __int16 ***a2)
{
  if (!*((_WORD *)*a2 + 10)) {
    return 0;
  }
  uint64_t v3 = **a2;
  uint64_t v4 = (void *)(a1 + 96);
  uint64_t v5 = 2 * *((unsigned __int16 *)*a2 + 10);
  while (1)
  {
    unint64_t v6 = *v3;
    if (((*(void *)(*(void *)(*(void *)(a1 + 16) + 352) + ((v6 >> 3) & 0x1FF8)) >> v6) & 1) == 0
      && sub_1CBAF9370(v4, *v3))
    {
      break;
    }
    ++v3;
    v5 -= 2;
    if (!v5) {
      return 0;
    }
  }
  return v6;
}

uint64_t llvm::RegScavenger::spill(void *a1, unsigned int a2, uint64_t a3, uint64_t a4, void *a5, void **a6)
{
  uint64_t v11 = *(void *)(*(void *)(a5[3] + 32) + 56);
  uint64_t v12 = a1 + 6;
  uint64_t v13 = *((unsigned int *)a1 + 14);
  int v14 = *(_DWORD *)(v11 + 32);
  int v15 = -v14;
  uint64_t v16 = *(void *)(v11 + 8);
  uint64_t v17 = -858993459 * ((unint64_t)(*(void *)(v11 + 16) - v16) >> 3) - v14;
  if (!v13)
  {
    uint64_t v38 = 0;
    uint64_t v23 = 0;
LABEL_20:
    if (v13 >= *((_DWORD *)a1 + 15)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unsigned int v39 = (void *)(a1[6] + 16 * v23);
    *unsigned int v39 = v17;
    v39[1] = 0;
    ++*((_DWORD *)a1 + 14);
    uint64_t v19 = *a1;
    uint64_t v26 = a1[6];
    goto LABEL_22;
  }
  uint64_t v18 = 0;
  uint64_t v19 = *a1;
  uint64_t v20 = *(void *)(*a1 + 264);
  unsigned int v21 = *(unsigned __int16 *)(*(void *)a3 + 24)
      + *(_DWORD *)(*a1 + 272) * ((*(void *)(*a1 + 248) - *(void *)(*a1 + 240)) >> 3);
  unsigned int v22 = *(_DWORD *)(v20 + 24 * v21 + 4) >> 3;
  uint64_t v23 = v13;
  LOBYTE(v20) = 63 - __clz((unint64_t)*(unsigned int *)(v20 + 24 * v21 + 8) >> 3);
  unsigned int v24 = v20;
  uint64_t v25 = -1 << v20;
  uint64_t v26 = *v12;
  uint64_t v27 = (_DWORD *)(*v12 + 4);
  unsigned int v28 = -1;
  unsigned int v29 = v13;
  do
  {
    if (!*v27)
    {
      int v30 = *(v27 - 1);
      if (v30 >= v15 && v30 < (int)v17)
      {
        unsigned int v32 = v30 + v14;
        unsigned int v33 = *(_DWORD *)(v16 + 40 * (v30 + v14) + 8);
        BOOL v34 = v33 >= v22;
        unsigned int v35 = v33 - v22;
        if (v34)
        {
          unsigned int v36 = *(unsigned __int8 *)(v16 + 40 * v32 + 16);
          if (v24 <= v36)
          {
            unsigned int v37 = v35 + v25 + (1 << v36);
            if (v37 < v28)
            {
              unsigned int v28 = v37;
              unsigned int v29 = v18;
            }
          }
        }
      }
    }
    ++v18;
    v27 += 4;
  }
  while (v13 != v18);
  uint64_t v38 = v29;
  if (v13 == v29) {
    goto LABEL_20;
  }
LABEL_22:
  *(_DWORD *)(v26 + 16 * v38 + 4) = a2;
  if (((*(uint64_t (**)(uint64_t, void, void *, void **, uint64_t, void))(*(void *)v19 + 496))(v19, a1[3], a5, a6, a3, a2) & 1) == 0)
  {
    int v40 = *(_DWORD *)(*v12 + 16 * v38);
    if (v40 < v15 || v40 >= (int)v17)
    {
      uint64_t v61 = "Error while trying to spill ";
      __int16 v62 = 259;
      uint64_t v47 = (unsigned char *)(*(void *)(*a1 + 72) + *(unsigned int *)(*(void *)(*a1 + 8) + 24 * a2));
      char v48 = 1;
      char v60 = 1;
      char v49 = 1;
      if (*v47)
      {
        v58[0] = (uint64_t)v47;
        char v49 = 3;
      }
      char v59 = v49;
      sub_1CB8F1E58((uint64_t *)&v61, v58, (uint64_t)v63);
      long long v56 = " from class ";
      __int16 v57 = 259;
      sub_1CB8F1E58(v63, (uint64_t *)&v56, (uint64_t)v64);
      char v50 = (unsigned char *)(*(void *)(*a1 + 80) + *(unsigned int *)(*(void *)a3 + 16));
      char v55 = 1;
      if (*v50)
      {
        v53[0] = (uint64_t)v50;
        char v48 = 3;
      }
      char v54 = v48;
      sub_1CD3E3950(v64, v53, (uint64_t)v65);
      int64_t v51 = ": Cannot scavenge register without an emergency spill slot!";
      __int16 v52 = 259;
      sub_1CD3E3950(v65, (uint64_t *)&v51, (uint64_t)v66);
      llvm::report_fatal_error((llvm *)v66, (const llvm::Twine *)1);
    }
    (*(void (**)(void, void, void *, void, uint64_t, void, uint64_t, void))(*(void *)a1[1] + 448))(a1[1], a1[3], a5, a2, 1, *(unsigned int *)(*v12 + 16 * v38), a3, *a1);
    unint64_t v42 = *a5 & 0xFFFFFFFFFFFFFFF8;
    if (!v42 || (*(unsigned char *)v42 & 4) == 0)
    {
      while ((*(_WORD *)(v42 + 44) & 4) != 0)
        unint64_t v42 = *(void *)v42 & 0xFFFFFFFFFFFFFFF8;
    }
    unsigned int v43 = -1;
    do
      ++v43;
    while (*(unsigned char *)(*(void *)(v42 + 32) + 32 * v43) != 5);
    (*(void (**)(void))(*(void *)*a1 + 504))();
    (*(void (**)(void))(*(void *)a1[1] + 464))();
    unint64_t v44 = **a6 & 0xFFFFFFFFFFFFFFF8;
    if (!v44 || (*(unsigned char *)v44 & 4) == 0)
    {
      while ((*(_WORD *)(v44 + 44) & 4) != 0)
        unint64_t v44 = *(void *)v44 & 0xFFFFFFFFFFFFFFF8;
    }
    unsigned int v45 = -1;
    do
      ++v45;
    while (*(unsigned char *)(*(void *)(v44 + 32) + 32 * v45) != 5);
    (*(void (**)(void))(*(void *)*a1 + 504))();
  }
  return *v12 + 16 * v38;
}

void llvm::initializeRemoveRedundantDebugValuesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3250, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC448FBC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD3250, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

int *sub_1CD571CDC(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)a1;
  *(_DWORD *)a1 |= 1u;
  if (a2 >= 5)
  {
    *(_DWORD *)a1 = v3 & 0xFFFFFFFE;
    uint64_t v4 = a2;
    *(void *)(a1 + 8) = operator new(40 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v4;
  }

  return sub_1CC449D24((int *)a1);
}

uint64_t sub_1CD571D48(_DWORD *a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t result = sub_1CC449E40((uint64_t)a1, a2, &v6);
  if (result)
  {
    uint64_t v4 = v6;
    *(void *)(v6 + 8) = 0;
    *(void *)(v4 + 16) = 0;
    *(void *)uint64_t v4 = 0;
    *(unsigned char *)(v4 + 24) = 1;
    *(void *)(v4 + 32) = 0;
    int v5 = a1[1] + 1;
    *a1 -= 2;
    a1[1] = v5;
  }
  return result;
}

int *sub_1CD571DA8(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)a1;
  unsigned int v3 = __clz((*(_DWORD *)a1 >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) == 0 || v5 >= 5)
  {
    if (v2)
    {
LABEL_12:
      return sub_1CD571CDC(a1, v5);
    }
    if (v5 != *(_DWORD *)(a1 + 16))
    {
      MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
      goto LABEL_12;
    }
  }

  return sub_1CC449D24((int *)a1);
}

void llvm::initializeRenameIndependentSubregsPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3258, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC44A5DC;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD3258, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::stableHashValue(llvm *this, const llvm::MachineOperand *a2)
{
  v103[6] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *(unsigned int *)this;
  unint64_t v4 = 0;
  switch(*(_DWORD *)this)
  {
    case 1u:
      unint64_t v4 = 0xCBF29CE484222325;
      unsigned int v14 = (v2 >> 8) & 0xFFF;
      unint64_t v15 = *((void *)this + 2);
      int v16 = 8;
      uint64_t v17 = *(_DWORD *)this;
      do
      {
        unint64_t v18 = v4 ^ v17;
        uint64_t v17 = 0;
        unint64_t v4 = 0x100000001B3 * v18;
        --v16;
      }
      while (v16);
      if (*(_DWORD *)this) {
        unint64_t v19 = v14;
      }
      else {
        unint64_t v19 = 0;
      }
      int v20 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v19 ^ v4);
        v19 >>= 8;
        --v20;
      }
      while (v20);
      int v21 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v15 ^ v4);
        v15 >>= 8;
        --v21;
      }
      while (v21);
      return v4;
    case 2u:
    case 3u:
      uint64_t v47 = *((void *)this + 2);
      if (*(_DWORD *)this == 2)
      {
        char v48 = (const llvm::APInt *)(v47 + 24);
        LODWORD(v102) = *(_DWORD *)(v47 + 32);
        if (v102 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&__p, v48);
        }
        __p = *(void **)v48;
      }
      else
      {
        sub_1CB867534(v47 + 24, (uint64_t)&__p);
      }
      uint64_t v68 = 0xCBF29CE484222325;
      p_p = __p;
      if (v102 < 0x41) {
        p_p = &__p;
      }
      if (v102)
      {
        uint64_t v70 = 0;
        do
        {
          unint64_t v71 = p_p[v70];
          int v72 = 8;
          do
          {
            uint64_t v68 = 0x100000001B3 * (v71 ^ (unint64_t)v68);
            v71 >>= 8;
            --v72;
          }
          while (v72);
          ++v70;
        }
        while (v70 != ((unint64_t)v102 + 63) >> 6);
      }
      uint64_t v100 = v68;
      unsigned int v73 = *(_DWORD *)this;
      char v99 = *(_DWORD *)this;
      if ((_BYTE)v73) {
        int v74 = (v73 >> 8) & 0xFFF;
      }
      else {
        int v74 = 0;
      }
      unsigned int v98 = v74;
      unint64_t v4 = sub_1CD572788(&v99, (int *)&v98, &v100);
      if (v102 >= 0x41 && __p) {
        MEMORY[0x1D25D9CB0](__p, 0x1000C8000313F17);
      }
      return v4;
    case 4u:
    case 6u:
    case 0xAu:
    case 0xBu:
    case 0xEu:
      return v4;
    case 5u:
    case 8u:
      unint64_t v4 = 0xCBF29CE484222325;
      unsigned int v6 = (v2 >> 8) & 0xFFF;
      unint64_t v7 = *((int *)this + 4);
      int v8 = 8;
      uint64_t v9 = *(_DWORD *)this;
      do
      {
        unint64_t v10 = v4 ^ v9;
        uint64_t v9 = 0;
        unint64_t v4 = 0x100000001B3 * v10;
        --v8;
      }
      while (v8);
      if (*(_DWORD *)this) {
        unint64_t v11 = v6;
      }
      else {
        unint64_t v11 = 0;
      }
      int v12 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v11 ^ v4);
        v11 >>= 8;
        --v12;
      }
      while (v12);
      int v13 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v7 ^ v4);
        v7 >>= 8;
        --v13;
      }
      while (v13);
      return v4;
    case 7u:
      uint64_t TargetIndexName = llvm::MachineOperand::getTargetIndexName(this);
      if (!TargetIndexName) {
        return 0;
      }
      v75 = (unsigned char *)TargetIndexName;
      unint64_t v76 = 0xCBF29CE484222325;
      unsigned __int8 v77 = *(_DWORD *)this;
      if (v77) {
        unint64_t v51 = (*(_DWORD *)this >> 8) & 0xFFF;
      }
      else {
        unint64_t v51 = 0;
      }
      unsigned int v78 = *v75;
      if (*v75)
      {
        v79 = v75 + 1;
        do
        {
          unint64_t v76 = 0x100000001B3 * (v76 ^ v78);
          unsigned int v80 = *v79++;
          unsigned int v78 = v80;
        }
        while (v80);
      }
      unint64_t v81 = *((unsigned int *)this + 1) | ((unint64_t)*((unsigned int *)this + 6) << 32);
      goto LABEL_99;
    case 9u:
      uint64_t v56 = 0xCBF29CE484222325;
      char v99 = 9;
      if ((_BYTE)v2) {
        unsigned int v57 = (v2 >> 8) & 0xFFF;
      }
      else {
        unsigned int v57 = 0;
      }
      unsigned int v98 = v57;
      __p = (void *)(*((unsigned int *)this + 1) | ((unint64_t)*((unsigned int *)this + 6) << 32));
      v58 = (unsigned char *)*((void *)this + 2);
      unsigned int v59 = *v58;
      if (*v58)
      {
        char v60 = v58 + 1;
        do
        {
          uint64_t v56 = 0x100000001B3 * (v56 ^ v59);
          unsigned int v61 = *v60++;
          unsigned int v59 = v61;
        }
        while (v61);
      }
      uint64_t v100 = v56;
      return sub_1CD539DE8(&v99, (int *)&v98, (uint64_t *)&__p, &v100);
    case 0xCu:
    case 0xDu:
      LOBYTE(v98) = *(_DWORD *)this;
      if ((_BYTE)v2) {
        unsigned int v49 = (v2 >> 8) & 0xFFF;
      }
      else {
        unsigned int v49 = 0;
      }
      LODWORD(v100) = v49;
      __p = (void *)*((void *)this + 2);
      return sub_1CD539EA0(&v98, (int *)&v100, (uint64_t *)&__p);
    case 0xFu:
      __int16 v62 = (unsigned char *)*((void *)this + 2);
      if ((*v62 & 4) != 0)
      {
        v82 = (void *)*((void *)v62 - 1);
        uint64_t v83 = *v82;
        int v63 = (unsigned __int8 *)(v82 + 2);
        uint64_t v64 = v83;
      }
      else
      {
        int v63 = 0;
        uint64_t v64 = 0;
      }
      uint64_t v84 = 0xCBF29CE484222325;
      LOBYTE(v98) = 15;
      if ((_BYTE)v2) {
        unsigned int v85 = (v2 >> 8) & 0xFFF;
      }
      else {
        unsigned int v85 = 0;
      }
      for (LODWORD(v100) = v85; v64; --v64)
      {
        unsigned int v86 = *v63++;
        uint64_t v84 = 0x100000001B3 * (v84 ^ v86);
      }
      __p = (void *)v84;
      return sub_1CD572788(&v98, (int *)&v100, (uint64_t *)&__p);
    case 0x10u:
      unint64_t v4 = 0xCBF29CE484222325;
      unsigned int v23 = (v2 >> 8) & 0xFFF;
      unint64_t v24 = *((unsigned int *)this + 4);
      int v25 = 8;
      uint64_t v26 = *(_DWORD *)this;
      do
      {
        unint64_t v27 = v4 ^ v26;
        uint64_t v26 = 0;
        unint64_t v4 = 0x100000001B3 * v27;
        --v25;
      }
      while (v25);
      if (*(_DWORD *)this) {
        unint64_t v28 = v23;
      }
      else {
        unint64_t v28 = 0;
      }
      int v29 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v28 ^ v4);
        v28 >>= 8;
        --v29;
      }
      while (v29);
      int v30 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v24 ^ v4);
        v24 >>= 8;
        --v30;
      }
      while (v30);
      return v4;
    case 0x11u:
      unint64_t v4 = 0xCBF29CE484222325;
      unsigned int v31 = (v2 >> 8) & 0xFFF;
      unint64_t v32 = *((unsigned int *)this + 4);
      int v33 = 8;
      uint64_t v34 = *(_DWORD *)this;
      do
      {
        unint64_t v35 = v4 ^ v34;
        uint64_t v34 = 0;
        unint64_t v4 = 0x100000001B3 * v35;
        --v33;
      }
      while (v33);
      if (*(_DWORD *)this) {
        unint64_t v36 = v31;
      }
      else {
        unint64_t v36 = 0;
      }
      int v37 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v36 ^ v4);
        v36 >>= 8;
        --v37;
      }
      while (v37);
      int v38 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v32 ^ v4);
        v32 >>= 8;
        --v38;
      }
      while (v38);
      return v4;
    case 0x12u:
      unint64_t v4 = 0xCBF29CE484222325;
      unsigned int v39 = (v2 >> 8) & 0xFFF;
      unint64_t v40 = *((unsigned int *)this + 4);
      int v41 = 8;
      uint64_t v42 = *(_DWORD *)this;
      do
      {
        unint64_t v43 = v4 ^ v42;
        uint64_t v42 = 0;
        unint64_t v4 = 0x100000001B3 * v43;
        --v41;
      }
      while (v41);
      if (*(_DWORD *)this) {
        unint64_t v44 = v39;
      }
      else {
        unint64_t v44 = 0;
      }
      int v45 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v44 ^ v4);
        v44 >>= 8;
        --v45;
      }
      while (v45);
      int v46 = 8;
      do
      {
        unint64_t v4 = 0x100000001B3 * (v40 ^ v4);
        v40 >>= 8;
        --v46;
      }
      while (v46);
      return v4;
    case 0x13u:
      __p = 0;
      uint64_t v102 = 0;
      v103[0] = 0;
      v65 = (char *)*((void *)this + 3);
      if (v65)
      {
        v66 = 0;
        v87 = (int *)*((void *)this + 2);
        uint64_t v88 = 4 * (void)v65;
        do
        {
          uint64_t v89 = *v87;
          uint64_t v100 = v89;
          if ((unint64_t)v66 >= v103[0])
          {
            v66 = sub_1CC1533E4((char **)&__p, &v100);
          }
          else
          {
            *(void *)v66 = v89;
            v66 += 8;
          }
          uint64_t v102 = (uint64_t)v66;
          ++v87;
          v88 -= 4;
        }
        while (v88);
        int v67 = *(_DWORD *)this;
        v65 = (char *)__p;
        LODWORD(v2) = *(_DWORD *)this;
      }
      else
      {
        v66 = 0;
        LOBYTE(v67) = 19;
      }
      uint64_t v90 = 0xCBF29CE484222325;
      char v99 = v67;
      if ((_BYTE)v2) {
        unsigned int v91 = (v2 >> 8) & 0xFFF;
      }
      else {
        unsigned int v91 = 0;
      }
      unsigned int v98 = v91;
      if (v66 != v65)
      {
        uint64_t v92 = 0;
        unint64_t v93 = (v66 - v65) >> 3;
        if (v93 <= 1) {
          unint64_t v93 = 1;
        }
        do
        {
          unint64_t v94 = *(void *)&v65[8 * v92];
          int v95 = 8;
          do
          {
            uint64_t v90 = 0x100000001B3 * (v94 ^ (unint64_t)v90);
            v94 >>= 8;
            --v95;
          }
          while (v95);
          ++v92;
        }
        while (v92 != v93);
      }
      uint64_t v100 = v90;
      unint64_t v4 = sub_1CD572788(&v99, (int *)&v98, &v100);
      if (__p)
      {
        uint64_t v102 = (uint64_t)__p;
        operator delete(__p);
      }
      return v4;
    default:
      unint64_t v51 = *((unsigned int *)this + 1);
      if ((v51 & 0x80000000) != 0)
      {
        uint64_t v52 = *(void *)(llvm::MachineInstr::getMF(*((llvm::MachineInstr **)this + 1)) + 40);
        __p = v103;
        uint64_t v102 = 0xC00000000;
        uint64_t v53 = sub_1CBB2C050(v52, *((_DWORD *)this + 1));
        unsigned int v55 = 0;
        if (v53 != v54)
        {
          uint64_t v96 = v53;
          do
          {
            if (v55 >= HIDWORD(v102)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((_DWORD *)__p + v55) = **(unsigned __int16 **)(*(void *)(v96 + 8) + 16);
            unsigned int v55 = v102 + 1;
            LODWORD(v102) = v102 + 1;
            uint64_t v97 = *(void *)(v96 + 8);
            while (1)
            {
              uint64_t v96 = *(void *)(v96 + 24);
              if (!v96) {
                goto LABEL_136;
              }
              if ((*(unsigned char *)(v96 + 3) & 1) == 0) {
                break;
              }
              if (*(void *)(v96 + 8) != v97) {
                goto LABEL_136;
              }
            }
            uint64_t v96 = 0;
LABEL_136:
            ;
          }
          while (v96 != v54);
        }
        unint64_t v4 = sub_1CD48BB60(__p, (uint64_t)__p + 4 * v55);
        if (__p != v103) {
          free(__p);
        }
        return v4;
      }
      unsigned __int8 v77 = *(_DWORD *)this;
      unint64_t v76 = (v2 >> 8) & 0xFFF;
      unint64_t v81 = (v2 >> 24) & 1;
LABEL_99:
      return sub_1CD5726FC(v77, v51, v76, v81);
  }
}

uint64_t sub_1CD5726FC(unsigned __int8 a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = a1;
  uint64_t result = 0xCBF29CE484222325;
  int v6 = 8;
  do
  {
    uint64_t v7 = result ^ v4;
    uint64_t v4 = 0;
    uint64_t result = 0x100000001B3 * v7;
    --v6;
  }
  while (v6);
  int v8 = 8;
  do
  {
    uint64_t result = 0x100000001B3 * (a2 ^ (unint64_t)result);
    a2 >>= 8;
    --v8;
  }
  while (v8);
  int v9 = 8;
  do
  {
    uint64_t result = 0x100000001B3 * (a3 ^ (unint64_t)result);
    a3 >>= 8;
    --v9;
  }
  while (v9);
  int v10 = 8;
  do
  {
    uint64_t result = 0x100000001B3 * (a4 ^ (unint64_t)result);
    a4 >>= 8;
    --v10;
  }
  while (v10);
  return result;
}

unint64_t sub_1CD572788(unsigned char *a1, int *a2, uint64_t *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LOBYTE(v7[0]) = *a1;
  return sub_1CC2E95DC((char *)v7, 0, (_OWORD *)((char *)v7 + 1), (char *)v8, a2, a3);
}

uint64_t llvm::stableHashValue(llvm *this, const llvm::MachineInstr *a2, BOOL a3, int a4)
{
  char v5 = (char)a2;
  v42[16] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (uint64_t *)((char *)this + 48);
  unint64_t v6 = *((void *)this + 6);
  int v8 = *((_DWORD *)this + 10);
  if (v6 < 8)
  {
LABEL_8:
    int v38 = 0;
    goto LABEL_9;
  }
  if ((v6 & 7) != 0)
  {
    uint64_t v9 = (int *)(v6 & 0xFFFFFFFFFFFFFFF8);
    if ((*((void *)this + 6) & 7) == 3 && v9 != 0)
    {
      int v38 = *v9;
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  *uint64_t v7 = v6 & 0xFFFFFFFFFFFFFFF8;
  int v38 = 1;
LABEL_9:
  if ((v8 + v38 + 2) > 0x10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v42[0] = **((unsigned __int16 **)this + 2);
  v42[1] = *((unsigned __int16 *)this + 22);
  unsigned int v11 = 2;
  unsigned int v39 = 2;
  uint64_t v12 = *((unsigned int *)this + 10);
  if (v12)
  {
    int v13 = (llvm *)*((void *)this + 4);
    unsigned int v14 = (unsigned int *)((char *)v13 + 32 * v12);
    do
    {
      unint64_t v15 = *(unsigned int *)v13;
      if ((v5 & 1) != 0 || (v15 & 0x10000FF) != 0x1000000 || (*((_DWORD *)v13 + 1) & 0x80000000) == 0)
      {
        if (*(_DWORD *)v13 == 6)
        {
          unint64_t v16 = (v15 >> 8) & 0xFFF;
          unint64_t v17 = *((int *)v13 + 4);
          uint64_t v18 = 0x6AD26A20123BA583;
          int v19 = 8;
          do
          {
            uint64_t v18 = 0x100000001B3 * (v16 ^ (unint64_t)v18);
            v16 >>= 8;
            --v19;
          }
          while (v19);
          int v20 = 8;
          do
          {
            uint64_t v18 = 0x100000001B3 * (v17 ^ (unint64_t)v18);
            v17 >>= 8;
            --v20;
          }
          while (v20);
        }
        else
        {
          uint64_t v21 = llvm::stableHashValue(v13, a2);
          if (!v21) {
            return 0;
          }
          uint64_t v18 = v21;
          unsigned int v11 = v39;
        }
        if (v11 >= 0x10) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v42[v11] = v18;
        unsigned int v11 = ++v39;
      }
      int v13 = (llvm *)((char *)v13 + 32);
    }
    while (v13 != (llvm *)v14);
  }
  uint64_t v22 = *v7;
  if ((unint64_t)*v7 >= 8)
  {
    if ((v22 & 7) == 0)
    {
      *uint64_t v7 = v22 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v24 = 1;
      goto LABEL_32;
    }
    if ((*v7 & 7) == 3)
    {
      unsigned int v23 = (int *)(v22 & 0xFFFFFFFFFFFFFFF8);
      if ((v22 & 0xFFFFFFFFFFFFFFF8) != 0)
      {
        uint64_t v25 = *v23;
        uint64_t v7 = (uint64_t *)(v23 + 2);
        uint64_t v24 = v25;
LABEL_32:
        if (v24 && a4)
        {
          uint64_t v26 = 8 * v24;
          do
          {
            uint64_t v27 = *v7;
            unsigned int v28 = sub_1CB8F20C0(*v7);
            if (v39 >= 0x10uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v39] = v28;
            if (v39 + 1 >= 0x10) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v39 + 1] = *(unsigned __int16 *)(v27 + 32);
            if (v39 + 2 >= 0x10) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v39 + 2] = *(unsigned int *)(v27 + 8);
            if (v39 + 3 >= 0x10) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v39 + 3] = *(unsigned char *)(v27 + 37) & 0xF;
            unsigned int v40 = v39 + 4;
            unsigned int AddrSpace = llvm::MachinePointerInfo::getAddrSpace((llvm::MachinePointerInfo *)v27);
            if (v40 >= 0x10uLL) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v40] = AddrSpace;
            if (v40 + 1 >= 0x10) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v40 + 1] = *(unsigned __int8 *)(v27 + 36);
            if (v40 + 2 >= 0x10) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v40 + 2] = (1 << *(unsigned char *)(v27 + 34));
            unsigned int v30 = v40 + 3;
            unsigned int v41 = v30;
            unint64_t v31 = *(unsigned __int16 *)(v27 + 36);
            if (v30 >= 0x10) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v42[v30] = v31 >> 12;
            unsigned int v11 = v30 + 1;
            unsigned int v39 = v41 + 1;
            ++v7;
            v26 -= 8;
          }
          while (v26);
        }
      }
    }
  }
  uint64_t v32 = 0xCBF29CE484222325;
  if (v11)
  {
    int v33 = &v42[v11];
    uint64_t v34 = v42;
    do
    {
      unint64_t v35 = *v34;
      int v36 = 8;
      do
      {
        uint64_t v32 = 0x100000001B3 * (v35 ^ (unint64_t)v32);
        v35 >>= 8;
        --v36;
      }
      while (v36);
      ++v34;
    }
    while (v34 != v33);
  }
  return v32;
}

BOOL llvm::VRegRenamer::doVRegRenaming(void **a1, void *a2)
{
  unint64_t v2 = a2 + 1;
  unsigned int v3 = (void *)*a2;
  if ((void *)*a2 == a2 + 1) {
    return 0;
  }
  LOBYTE(v5) = 0;
  do
  {
    unint64_t v6 = *a1;
    uint64_t v7 = *((unsigned int *)v3 + 7);
    if (v5)
    {
      BOOL v5 = 1;
    }
    else
    {
      if ((v7 & 0x80000000) != 0) {
        int v8 = (void *)(v6[3] + 16 * (v7 & 0x7FFFFFFF) + 8);
      }
      else {
        int v8 = (void *)(v6[34] + 8 * v7);
      }
      BOOL v5 = *v8 != 0;
    }
    llvm::MachineRegisterInfo::replaceRegWith(v6, v7, *((_DWORD *)v3 + 8));
    uint64_t v9 = (void *)v3[1];
    if (v9)
    {
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = (void *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        uint64_t v10 = (void *)v3[2];
        BOOL v11 = *v10 == (void)v3;
        unsigned int v3 = v10;
      }
      while (!v11);
    }
    unsigned int v3 = v10;
  }
  while (v10 != v2);
  return v5;
}

uint64_t llvm::VRegRenamer::getVRegRenameMap@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0x1000000000;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)a3 = a3 + 8;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    do
    {
      int v7 = *(_DWORD *)v4;
      int v37 = *(_DWORD *)v4;
      char v8 = *(unsigned char *)(v4 + 31);
      int v9 = v8;
      if (v8 >= 0) {
        uint64_t v10 = (unsigned __int8 *)(v4 + 8);
      }
      else {
        uint64_t v10 = *(unsigned __int8 **)(v4 + 8);
      }
      size_t v11 = v8 & 0x7F;
      if (v9 >= 0) {
        size_t v12 = v11;
      }
      else {
        size_t v12 = *(void *)(v4 + 16);
      }
      int Key = llvm::StringMapImpl::FindKey(&v38, v10, v12);
      if (Key == -1 || Key == (unint64_t)v39)
      {
        char v15 = *(unsigned char *)(v4 + 31);
        BOOL v16 = v15 < 0;
        if (v15 >= 0) {
          unint64_t v17 = (unsigned __int8 *)(v4 + 8);
        }
        else {
          unint64_t v17 = *(unsigned __int8 **)(v4 + 8);
        }
        size_t v18 = v15 & 0x7F;
        if (v16) {
          size_t v19 = *(void *)(v4 + 16);
        }
        else {
          size_t v19 = v18;
        }
        *(_DWORD *)(*sub_1CC44CD14((llvm::StringMapImpl *)&v38, v17, v19) + 8) = 0;
      }
      char v20 = *(unsigned char *)(v4 + 31);
      BOOL v21 = v20 < 0;
      if (v20 >= 0) {
        uint64_t v22 = (unsigned __int8 *)(v4 + 8);
      }
      else {
        uint64_t v22 = *(unsigned __int8 **)(v4 + 8);
      }
      size_t v23 = v20 & 0x7F;
      if (v21) {
        size_t v24 = *(void *)(v4 + 16);
      }
      else {
        size_t v24 = v23;
      }
      uint64_t v25 = sub_1CC44CD14((llvm::StringMapImpl *)&v38, v22, v24);
      unsigned int v26 = *(_DWORD *)(*v25 + 8) + 1;
      *(_DWORD *)(*v25 + 8) = v26;
      sub_1CBAD7600("__", (const void **)(v4 + 8), (void **)&v42.__r_.__value_.__l.__data_);
      std::to_string(&v41, v26);
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v27 = &v41;
      }
      else {
        uint64_t v27 = (std::string *)v41.__r_.__value_.__r.__words[0];
      }
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = *((unsigned char *)&v41.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        std::string::size_type size = v41.__r_.__value_.__l.__size_;
      }
      int v29 = std::string::append(&v42, (const std::string::value_type *)v27, size);
      std::string::size_type v30 = v29->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      uint64_t v36 = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v42.__r_.__value_.__l.__data_);
      }
      if (v36 >= 0) {
        unint64_t v31 = __p;
      }
      else {
        unint64_t v31 = (void **)__p[0];
      }
      if (v36 >= 0) {
        uint64_t v32 = HIBYTE(v36) & 0x7F;
      }
      else {
        uint64_t v32 = (uint64_t)__p[1];
      }
      int VirtualRegisterWithLowerName = llvm::VRegRenamer::createVirtualRegisterWithLowerName(a1, v7, (uint64_t)v31, v32);
      v42.__r_.__value_.__r.__words[0] = (std::string::size_type)&v37;
      *((_DWORD *)sub_1CD56EE6C((uint64_t **)a3, (unsigned int *)&v37, (uint64_t)&std::piecewise_construct, &v42) + 8) = VirtualRegisterWithLowerName;
      if (SHIBYTE(v36) < 0) {
        operator delete(__p[0]);
      }
      v4 += 32;
    }
    while (v4 != v5);
  }
  return sub_1CC3724DC((uint64_t)&v38);
}

uint64_t llvm::VRegRenamer::createVirtualRegisterWithLowerName(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  v20[0] = a3;
  v20[1] = a4;
  llvm::StringRef::lower((llvm::StringRef *)v20, &__p);
  uint64_t v6 = *a1;
  uint64_t v7 = a2 & 0x7FFFFFFF;
  uint64_t v8 = *(void *)(*(void *)(*a1 + 24) + 16 * v7);
  if ((v8 & 4) != 0 || (v8 & 0xFFFFFFFFFFFFFFF8) == 0)
  {
    if (a2 < 0 && v7 < *(_DWORD *)(v6 + 432)) {
      uint64_t v12 = *(void *)(*(void *)(v6 + 424) + 8 * v7);
    }
    else {
      uint64_t v12 = 0;
    }
    if (v19 >= 0) {
      p_p = (unsigned __int8 *)&__p;
    }
    else {
      p_p = (unsigned __int8 *)__p;
    }
    if (v19 >= 0) {
      size_t v14 = v19 & 0x7F;
    }
    else {
      size_t v14 = v18;
    }
    uint64_t GenericVirtualRegister = llvm::MachineRegisterInfo::createGenericVirtualRegister(v6, v12, p_p, v14);
  }
  else
  {
    if (v19 >= 0) {
      int v9 = (unsigned __int8 *)&__p;
    }
    else {
      int v9 = (unsigned __int8 *)__p;
    }
    if (v19 >= 0) {
      size_t v10 = v19 & 0x7F;
    }
    else {
      size_t v10 = v18;
    }
    uint64_t GenericVirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(v6, v8 & 0xFFFFFFFFFFFFFFF8, v9, v10);
  }
  uint64_t v15 = GenericVirtualRegister;
  if (v19 < 0) {
    operator delete(__p);
  }
  return v15;
}

void llvm::VRegRenamer::getInstructionOpcodeHash(llvm::VRegRenamer *this@<X0>, llvm::MachineInstr *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v52 = 0;
  int v43 = 0;
  char v47 = 0;
  uint64_t v48 = 0;
  char v50 = __p;
  int v49 = 0;
  std::string v42 = &unk_1F2646F30;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  if (byte_1EBCD32E0)
  {
    unint64_t v5 = llvm::stableHashValue(a2, (const llvm::MachineInstr *)1, 1, 1);
    std::to_string(&__str, v5);
    std::string::basic_string(a3, &__str, 0, 5uLL, (std::allocator<char> *)&v41);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    goto LABEL_4;
  }
  uint64_t v7 = **((unsigned __int16 **)a2 + 2);
  uint64_t v8 = *((unsigned __int16 *)a2 + 22);
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str.__r_.__value_.__r.__words[2];
  __str.__r_.__value_.__r.__words[2] = v7 | (v8 << 32);
  __str.__r_.__value_.__l.__size_ = 0x1000000002;
  uint64_t v9 = *((void *)a2 + 4);
  size_t v11 = (unsigned int *)(v9 + 32 * llvm::MachineInstr::getNumExplicitDefs(a2));
  for (uint64_t i = *((void *)a2 + 4) + 32 * *((unsigned int *)a2 + 10); v11 != (unsigned int *)i; v11 += 8)
  {
    unsigned int v27 = *v11;
    unsigned int v28 = 0;
    switch(*v11)
    {
      case 1u:
        unsigned int v28 = v11[4];
        break;
      case 2u:
        LOBYTE(v54) = 2;
        if ((_BYTE)v27) {
          int v31 = (v27 >> 8) & 0xFFF;
        }
        else {
          int v31 = 0;
        }
        LODWORD(v53) = v31;
        uint64_t v32 = *((void *)v11 + 2);
        int v33 = (void *)(v32 + 24);
        if (*(_DWORD *)(v32 + 32) >= 0x41u) {
          int v33 = (void *)*v33;
        }
        v41.__r_.__value_.__r.__words[0] = *v33;
        unsigned int v29 = sub_1CD572788(&v54, (int *)&v53, (uint64_t *)&v41);
        goto LABEL_34;
      case 3u:
        char v55 = 3;
        if ((_BYTE)v27) {
          int v34 = (v27 >> 8) & 0xFFF;
        }
        else {
          int v34 = 0;
        }
        int v54 = v34;
        sub_1CB867534(*((void *)v11 + 2) + 24, (uint64_t)&v41);
        if (LODWORD(v41.__r_.__value_.__r.__words[1]) >= 0x41) {
          unint64_t v35 = (std::string *)v41.__r_.__value_.__r.__words[0];
        }
        else {
          unint64_t v35 = &v41;
        }
        std::string::size_type v53 = v35->__r_.__value_.__r.__words[0];
        unsigned int v28 = sub_1CD572788(&v55, &v54, (uint64_t *)&v53);
        if (LODWORD(v41.__r_.__value_.__r.__words[1]) >= 0x41 && v41.__r_.__value_.__r.__words[0]) {
          MEMORY[0x1D25D9CB0](v41.__r_.__value_.__r.__words[0], 0x1000C8000313F17);
        }
        break;
      case 4u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        break;
      case 5u:
      case 6u:
      case 8u:
        unsigned int v29 = llvm::hash_value((llvm *)v11, v10);
LABEL_34:
        unsigned int v28 = v29;
        break;
      case 7u:
        if (*v11) {
          int v30 = (v27 << 8) & 0xFFF0000;
        }
        else {
          int v30 = 0;
        }
        unsigned int v28 = v11[1] | v30;
        break;
      default:
        size_t v10 = (const llvm::MachineOperand *)v11[1];
        unsigned int v28 = v10;
        if ((v10 & 0x80000000) != 0) {
          unsigned int v28 = **(unsigned __int16 **)(llvm::MachineRegisterInfo::getVRegDef(*(void *)this, v10) + 16);
        }
        break;
    }
    if (LODWORD(__str.__r_.__value_.__r.__words[1]) >= (unint64_t)HIDWORD(__str.__r_.__value_.__r.__words[1])) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * LODWORD(__str.__r_.__value_.__r.__words[1])) = v28;
    ++LODWORD(__str.__r_.__value_.__r.__words[1]);
  }
  size_t v14 = (uint64_t *)((char *)a2 + 48);
  unint64_t v13 = *((void *)a2 + 6);
  if (v13 >= 8)
  {
    if ((v13 & 7) == 0)
    {
      *((void *)a2 + 6) = v13 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v15 = (uint64_t *)((char *)a2 + 56);
      goto LABEL_11;
    }
    uint64_t v36 = (int *)(v13 & 0xFFFFFFFFFFFFFFF8);
    if ((*((void *)a2 + 6) & 7) == 3 && v36 != 0)
    {
      uint64_t v39 = *v36;
      size_t v14 = (uint64_t *)(v36 + 2);
      uint64_t v38 = v39;
      if (v39)
      {
        uint64_t v15 = &v14[v38];
        do
        {
LABEL_11:
          uint64_t v16 = *v14;
          int v17 = sub_1CB8F20C0(*v14);
          if (LODWORD(__str.__r_.__value_.__r.__words[1]) >= (unint64_t)HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * LODWORD(__str.__r_.__value_.__r.__words[1])) = v17;
          unsigned int v18 = LODWORD(__str.__r_.__value_.__r.__words[1]) + 1;
          LODWORD(__str.__r_.__value_.__r.__words[1]) = v18;
          if (v18 >= HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * v18) = *(unsigned __int16 *)(v16 + 32);
          unsigned int v19 = LODWORD(__str.__r_.__value_.__r.__words[1]) + 1;
          LODWORD(__str.__r_.__value_.__r.__words[1]) = v19;
          if (v19 >= HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * v19) = *(_DWORD *)(v16 + 8);
          unsigned int v20 = LODWORD(__str.__r_.__value_.__r.__words[1]) + 1;
          LODWORD(__str.__r_.__value_.__r.__words[1]) = v20;
          if (v20 >= HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * v20) = *(unsigned char *)(v16 + 37) & 0xF;
          ++LODWORD(__str.__r_.__value_.__r.__words[1]);
          int AddrSpace = llvm::MachinePointerInfo::getAddrSpace((llvm::MachinePointerInfo *)v16);
          if (LODWORD(__str.__r_.__value_.__r.__words[1]) >= (unint64_t)HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * LODWORD(__str.__r_.__value_.__r.__words[1])) = AddrSpace;
          unsigned int v22 = LODWORD(__str.__r_.__value_.__r.__words[1]) + 1;
          LODWORD(__str.__r_.__value_.__r.__words[1]) = v22;
          if (v22 >= HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * v22) = *(unsigned __int8 *)(v16 + 36);
          unsigned int v23 = LODWORD(__str.__r_.__value_.__r.__words[1]) + 1;
          LODWORD(__str.__r_.__value_.__r.__words[1]) = v23;
          if (v23 >= HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * v23) = 1 << *(unsigned char *)(v16 + 34);
          unsigned int v24 = LODWORD(__str.__r_.__value_.__r.__words[1]) + 1;
          LODWORD(__str.__r_.__value_.__r.__words[1]) = v24;
          unsigned int v25 = *(unsigned __int16 *)(v16 + 36);
          if (v24 >= HIDWORD(__str.__r_.__value_.__r.__words[1])) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + 4 * v24) = v25 >> 12;
          unsigned int v26 = ++LODWORD(__str.__r_.__value_.__r.__words[1]);
          ++v14;
        }
        while (v14 != v15);
        goto LABEL_64;
      }
    }
  }
  unsigned int v26 = __str.__r_.__value_.__r.__words[1];
LABEL_64:
  unint64_t v40 = sub_1CD48BB60(__str.__r_.__value_.__l.__data_, __str.__r_.__value_.__r.__words[0] + 4 * v26);
  std::to_string(&v41, v40);
  std::string::basic_string(a3, &v41, 0, 5uLL, (std::allocator<char> *)&v53);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v41.__r_.__value_.__l.__data_);
  }
  if ((std::string::size_type *)__str.__r_.__value_.__l.__data_ != &__str.__r_.__value_.__r.__words[2]) {
    free(__str.__r_.__value_.__l.__data_);
  }
LABEL_4:
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v42);
  if (SHIBYTE(v52) < 0) {
    operator delete(__p[0]);
  }
}

BOOL llvm::VRegRenamer::renameInstsInMBB(llvm::VRegRenamer *this, llvm::MachineBasicBlock *a2)
{
  int64x2_t v29 = 0uLL;
  unint64_t v30 = 0;
  std::to_string(&v26, *((_DWORD *)this + 2));
  uint64_t v4 = std::string::insert(&v26, 0, "bb");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v24, "_");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  uint64_t v28 = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  uint64_t v8 = (char *)a2 + 48;
  for (uint64_t i = *((void *)a2 + 7); (char *)i != v8; uint64_t i = *(void *)(i + 8))
  {
    if (sub_1CB8F9CA0(i, 1))
    {
      if (!i) {
        goto LABEL_11;
      }
    }
    else
    {
      if ((*(_WORD *)(i + 44) & 0xC) != 0 && (*(_WORD *)(i + 44) & 4) == 0)
      {
        if (llvm::MachineInstr::hasPropertyInBundle(i, 1024, 1)) {
          goto LABEL_8;
        }
      }
      else if ((*(unsigned char *)(*(void *)(i + 16) + 9) & 4) != 0)
      {
        goto LABEL_8;
      }
      if (*(_DWORD *)(i + 40))
      {
        uint64_t v11 = *(void *)(i + 32);
        if (!*(unsigned char *)v11)
        {
          int v12 = *(_DWORD *)(v11 + 4);
          if (v12 < 0)
          {
            llvm::VRegRenamer::getInstructionOpcodeHash(this, (llvm::MachineInstr *)i, &v26);
            if (v28 >= 0) {
              unint64_t v13 = __p;
            }
            else {
              unint64_t v13 = (void **)__p[0];
            }
            if (v28 >= 0) {
              std::string::size_type v14 = HIBYTE(v28) & 0x7F;
            }
            else {
              std::string::size_type v14 = (std::string::size_type)__p[1];
            }
            uint64_t v15 = std::string::insert(&v26, 0, (const std::string::value_type *)v13, v14);
            int v17 = (void *)v15->__r_.__value_.__r.__words[0];
            unint64_t size = v15->__r_.__value_.__l.__size_;
            *(_DWORD *)unsigned int v23 = v15->__r_.__value_.__r.__words[2];
            *(_DWORD *)&v23[3] = *(_DWORD *)((char *)&v15->__r_.__value_.__r.__words[2] + 3);
            int v18 = SHIBYTE(v15->__r_.__value_.__r.__words[2]);
            v15->__r_.__value_.__r.__words[0] = 0;
            v15->__r_.__value_.__l.__size_ = 0;
            v15->__r_.__value_.__r.__words[2] = 0;
            LODWORD(v24.__r_.__value_.__l.__data_) = v12;
            if (v18 < 0)
            {
              sub_1CB8BDF7C((uint64_t)&v24.__r_.__value_.__l.__size_, v17, size);
            }
            else
            {
              v24.__r_.__value_.__l.__size_ = (std::string::size_type)v17;
              v24.__r_.__value_.__r.__words[2] = size;
              LODWORD(v25) = *(_DWORD *)v23;
              *(_DWORD *)((char *)&v25 + 3) = *(_DWORD *)&v23[3];
              HIBYTE(v25) = v18;
            }
            uint64_t v19 = v29.i64[1];
            if (v29.i64[1] >= v30)
            {
              v29.i64[1] = (uint64_t)sub_1CC44CF1C(&v29, (uint64_t)&v24);
              if (SHIBYTE(v25) < 0) {
                operator delete((void *)v24.__r_.__value_.__l.__size_);
              }
            }
            else
            {
              *(_DWORD *)v29.i64[1] = v24.__r_.__value_.__l.__data_;
              long long v20 = *(_OWORD *)&v24.__r_.__value_.__r.__words[1];
              *(void *)(v19 + 24) = v25;
              *(_OWORD *)(v19 + 8) = v20;
              uint64_t v25 = 0;
              *(_OWORD *)&v24.__r_.__value_.__r.__words[1] = 0uLL;
              v29.i64[1] = v19 + 32;
            }
            if (v18 < 0) {
              operator delete(v17);
            }
            if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v26.__r_.__value_.__l.__data_);
            }
          }
        }
      }
    }
LABEL_8:
    if ((*(unsigned char *)i & 4) == 0)
    {
LABEL_11:
      while ((*(_WORD *)(i + 44) & 8) != 0)
        uint64_t i = *(void *)(i + 8);
    }
  }
  if (v29.i64[1] == v29.i64[0])
  {
    BOOL v21 = 0;
  }
  else
  {
    llvm::VRegRenamer::getVRegRenameMap((uint64_t *)this, v29.i64, (uint64_t)&v24);
    BOOL v21 = llvm::VRegRenamer::doVRegRenaming((void **)this, &v24);
    sub_1CB833A08((uint64_t)&v24, (void *)v24.__r_.__value_.__l.__size_);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  v24.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
  sub_1CC1CB288((void ***)&v24);
  return v21;
}

void llvm::initializeMIRNamerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3320, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC44D0DC;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD3320, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeMIRCanonicalizerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3328, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC44D4C4;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD3328, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD573B00(uint64_t a1)
{
  unsigned int v3 = *(void ***)(a1 + 8);
  unint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      unint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1CD573B64(_WORD *a1, int **a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD3338, 0, 0);
  dword_1EBCD33B8 = 0;
  qword_1EBCD33C0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD33C8 = 0;
  qword_1EBCD3338 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD33D0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD33D8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD33F0 = (uint64_t)&qword_1EBCD33D8;
  sub_1CD573C64(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD3338);
}

__n128 sub_1CD573C64(_WORD *a1, int **a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD3338, "canon-nth-function", 0x12uLL);
  word_1EBCD3342 = (32 * (*a1 & 3)) | word_1EBCD3342 & 0xFF9F;
  uint64_t v8 = *a2;
  dword_1EBCD33B8 = **a2;
  byte_1EBCD33CC = 1;
  dword_1EBCD33C8 = *v8;
  xmmword_1EBCD3368 = *a3;
  __n128 result = *a4;
  xmmword_1EBCD3358 = (__int128)*a4;
  return result;
}

void llvm::initializePhysicalRegisterUsageInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34B8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC450B40;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD34B8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::PhysicalRegisterUsageInfo::print(llvm::PhysicalRegisterUsageInfo *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  v33[64] = *MEMORY[0x1E4F143B8];
  int v31 = v33;
  uint64_t v32 = 0x4000000000;
  uint64_t v5 = *((void *)this + 4);
  uint64_t v6 = *((unsigned int *)this + 12);
  std::string::size_type v7 = (void *)(v5 + 32 * v6);
  if (*((_DWORD *)this + 10))
  {
    if (v6)
    {
      uint64_t v8 = 32 * v6;
      uint64_t v9 = (void *)*((void *)this + 4);
      while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v9 += 4;
        v8 -= 32;
        if (!v8) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v9 = (void *)*((void *)this + 4);
    }
  }
  else
  {
LABEL_6:
    uint64_t v9 = (void *)(v5 + 32 * v6);
  }
  size_t v10 = (void *)(v5 + 32 * v6);
  if (v9 == v10)
  {
    std::string::size_type v14 = (uint64_t *****)v33;
    unint64_t v13 = (char *)v33;
  }
  else
  {
    LODWORD(v11) = 0;
    do
    {
      if (v11 >= HIDWORD(v32)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v31 + v11) = v9;
      unint64_t v11 = (v32 + 1);
      LODWORD(v32) = v32 + 1;
      int v12 = v9 + 4;
      uint64_t v9 = v7;
      if (v12 != v7)
      {
        uint64_t v9 = v12;
        while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v9 += 4;
          if (v9 == v7)
          {
            uint64_t v9 = v7;
            break;
          }
        }
      }
    }
    while (v9 != v10);
    unint64_t v13 = (char *)v31;
    std::string::size_type v14 = (uint64_t *****)((char *)v31 + 8 * v11);
    if (v11)
    {
      uint64_t v15 = 126 - 2 * __clz(v11);
      goto LABEL_20;
    }
  }
  uint64_t v15 = 0;
LABEL_20:
  sub_1CC4511F8(v13, v14, v15, 1);
  uint64_t v16 = (llvm::Value ***)v31;
  if (v32)
  {
    int v17 = (llvm::Value ***)((char *)v31 + 8 * v32);
    do
    {
      int v18 = *v16;
      Name = llvm::Value::getName(**v16);
      size_t v21 = v19;
      unsigned int v22 = (void *)*((void *)a2 + 4);
      if (v19 <= *((void *)a2 + 3) - (void)v22)
      {
        if (v19)
        {
          memcpy(v22, Name, v19);
          *((void *)a2 + 4) += v21;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, Name, v19);
      }
      unsigned int v23 = sub_1CB8E509C(a2, " ");
      sub_1CB8E509C(v23, "Clobbered Registers: ");
      uint64_t v24 = (*(uint64_t (**)(void, llvm::Value *))(**((void **)this + 7) + 16))(*((void *)this + 7), *v18);
      uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 176))(v24);
      uint64_t v26 = *(unsigned int *)(v25 + 16);
      if (v26 >= 2)
      {
        uint64_t v27 = v25;
        for (unint64_t i = 1; i != v26; ++i)
        {
          if (((*(_DWORD *)((char *)v18[1] + ((i >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> i) & 1) == 0)
          {
            llvm::printReg(i, v27, 0, 0, (uint64_t)v29);
            if (!v30) {
              sub_1CB920400();
            }
            (*(void (**)(void *, llvm::raw_ostream *))(*v30 + 48))(v30, a2);
            sub_1CB8E509C(a2, " ");
            if (v30 == v29)
            {
              (*(void (**)(void *))(v29[0] + 32))(v29);
            }
            else if (v30)
            {
              (*(void (**)(void))(*v30 + 40))();
            }
          }
        }
      }
      sub_1CB8E509C(a2, "\n");
      ++v16;
    }
    while (v16 != v17);
    uint64_t v16 = (llvm::Value ***)v31;
  }
  if (v16 != v33) {
    free(v16);
  }
}

void sub_1CD574114(unsigned int *a1)
{
  *(void *)a1 = &unk_1F2612748;
  sub_1CC450FE0(a1 + 8);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 4), 8);

  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

void sub_1CD574174(unsigned int *a1)
{
  *(void *)a1 = &unk_1F2612748;
  sub_1CC450FE0(a1 + 8);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 4), 8);
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::PhysicalRegisterUsageInfo>()
{
}

uint64_t sub_1CD574224(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &llvm::PhysicalRegisterUsageInfo::ID;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2612748;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34B8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC450B40;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCD34B8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::initializeRegUsageInfoCollectorPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC455300;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD34C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createRegUsageInfoCollector(llvm *this)
{
}

void llvm::initializeRegUsageInfoPropagationPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34D8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC455D68;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD34D8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createRegUsageInfoPropPass(llvm *this)
{
}

void llvm::ReplaceWithVeclibLegacy::runOnFunction(llvm::ReplaceWithVeclibLegacy *this, llvm::Function *a2)
{
  unsigned int v3 = (uint64_t *)*((void *)this + 1);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(char **)v4 != llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v6 + 96))(v6, llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CBF5AC74(v7, (uint64_t)a2);
}

void llvm::ReplaceWithVeclibLegacy::getAnalysisUsage(llvm::ReplaceWithVeclibLegacy *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::setPreservesCFG(a2);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::ScalarEvolutionWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::LoopAccessLegacyAnalysis::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::DemandedBitsWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::OptimizationRemarkEmitterWrapperPass::ID);

  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::GlobalsAAWrapperPass::ID);
}

void llvm::createReplaceWithVeclibLegacyPass(llvm *this)
{
}

void sub_1CD574604(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::ReplaceWithVeclibLegacy>()
{
}

uint64_t sub_1CD574678(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &llvm::ReplaceWithVeclibLegacy::ID;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2612970;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EA61BED8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC4574F0;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EA61BED8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::createResetMachineFunctionPass(llvm *this)
{
}

llvm::raw_ostream *llvm::RegisterBank::dump(llvm::RegisterBank *this, const llvm::TargetRegisterInfo *a2)
{
  uint64_t v4 = llvm::dbgs(this);

  return llvm::RegisterBank::print((char **)this, v4, 1, a2);
}

llvm::raw_ostream *llvm::RegisterBank::print(char **this, llvm::raw_ostream *a2, int a3, const llvm::TargetRegisterInfo *a4)
{
  __n128 result = sub_1CB8E509C(a2, this[1]);
  if (a3)
  {
    uint64_t v9 = sub_1CB8E509C(a2, "(ID:");
    size_t v10 = llvm::raw_ostream::operator<<(v9, *(unsigned int *)this);
    unint64_t v11 = sub_1CB8E509C(v10, ", Size:");
    int v12 = llvm::raw_ostream::operator<<(v11, *((unsigned int *)this + 4));
    unint64_t v13 = sub_1CB8E509C(v12, ")\n");
    std::string::size_type v14 = sub_1CB8E509C(v13, "isValid:");
    unint64_t v15 = *(_DWORD *)this != -1 && this[1] && *((_DWORD *)this + 4) && *((_DWORD *)this + 22) != 0;
    uint64_t v16 = llvm::raw_ostream::operator<<(v14, v15);
    int v17 = (unsigned char *)*((void *)v16 + 4);
    if ((unint64_t)v17 >= *((void *)v16 + 3))
    {
      uint64_t v16 = llvm::raw_ostream::write(v16, 10);
    }
    else
    {
      *((void *)v16 + 4) = v17 + 1;
      *int v17 = 10;
    }
    int v18 = sub_1CB8E509C(v16, "Number of Covered register classes: ");
    uint64_t v19 = *((unsigned int *)this + 8);
    if (v19)
    {
      LODWORD(v20) = 0;
      size_t v21 = (int8x8_t *)this[3];
      uint64_t v22 = 8 * v19;
      do
      {
        int8x8_t v23 = *v21++;
        uint8x8_t v24 = (uint8x8_t)vcnt_s8(v23);
        v24.i16[0] = vaddlv_u8(v24);
        unint64_t v20 = (v20 + v24.i32[0]);
        v22 -= 8;
      }
      while (v22);
    }
    else
    {
      unint64_t v20 = 0;
    }
    __n128 result = llvm::raw_ostream::operator<<(v18, v20);
    uint64_t v25 = (unsigned char *)*((void *)result + 4);
    if ((unint64_t)v25 >= *((void *)result + 3))
    {
      __n128 result = llvm::raw_ostream::write(result, 10);
    }
    else
    {
      *((void *)result + 4) = v25 + 1;
      unsigned char *v25 = 10;
    }
    if (a4)
    {
      if (*((_DWORD *)this + 22))
      {
        __n128 result = sub_1CB8E509C(a2, "Covered register classes:\n");
        unint64_t v26 = *((void *)a4 + 31) - *((void *)a4 + 30);
        if ((v26 & 0x7FFFFFFF8) != 0)
        {
          uint64_t v27 = 0;
          uint64_t v28 = (v26 >> 3);
          int v29 = 1;
          do
          {
            uint64_t v30 = *(void *)(*((void *)a4 + 30) + 8 * v27);
            if ((*(void *)&this[3][((unint64_t)*(unsigned __int16 *)(*(void *)v30 + 24) >> 3) & 0x1FF8] >> *(_WORD *)(*(void *)v30 + 24)))
            {
              size_t v31 = 2 * (v29 == 0);
              uint64_t v32 = (_WORD *)*((void *)a2 + 4);
              if (v31 <= *((void *)a2 + 3) - (void)v32)
              {
                if (!v29)
                {
                  *uint64_t v32 = 8236;
                  *((void *)a2 + 4) += 2;
                }
              }
              else
              {
                if (v29) {
                  int v33 = 0;
                }
                else {
                  int v33 = ", ";
                }
                llvm::raw_ostream::write(a2, v33, v31);
              }
              __n128 result = sub_1CB8E509C(a2, (char *)(*((void *)a4 + 10) + *(unsigned int *)(*(void *)v30 + 16)));
              int v29 = 0;
            }
            ++v27;
          }
          while (v28 != v27);
        }
      }
    }
  }
  return result;
}

uint64_t *llvm::RegisterBankInfo::getMinimalPhysRegClass(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = a1 + 120;
  unsigned int v11 = a2;
  uint64_t v7 = sub_1CD48A634((uint64_t *)(a1 + 120), &v11);
  if ((int *)(*(void *)(a1 + 120) + 16 * *(unsigned int *)(a1 + 136)) != v7) {
    return (uint64_t *)*((void *)v7 + 1);
  }
  MinimalPhysRegClass = llvm::TargetRegisterInfo::getMinimalPhysRegClass(a3, a2, 1u);
  unsigned int v10 = a2;
  *((void *)sub_1CD576724(v6, &v10) + 1) = MinimalPhysRegClass;
  return MinimalPhysRegClass;
}

uint64_t llvm::RegisterBankInfo::getRegBankFromConstraints(llvm::RegisterBankInfo *this, const llvm::MachineInstr *a2, uint64_t a3, const llvm::TargetInstrInfo *a4, const llvm::MachineRegisterInfo *a5)
{
  unsigned int v10 = (const llvm::TargetRegisterInfo *)(*(uint64_t (**)(void))(**(void **)(*(void *)a5 + 16) + 176))(*(void *)(*(void *)a5 + 16));
  uint64_t result = llvm::MachineInstr::getRegClassConstraint(a2, a3, a4, v10);
  if (result)
  {
    int v12 = *(_DWORD *)(*((void *)a2 + 4) + 32 * a3 + 4);
    if (v12 < 0 && (uint64_t v15 = v12 & 0x7FFFFFFF, v15 < *((_DWORD *)a5 + 108))) {
      uint64_t v13 = *(void *)(*((void *)a5 + 53) + 8 * v15);
    }
    else {
      uint64_t v13 = 0;
    }
    std::string::size_type v14 = *(uint64_t (**)(llvm::RegisterBankInfo *, uint64_t, uint64_t))(*(void *)this + 24);
    return v14(this, result, v13);
  }
  return result;
}

uint64_t llvm::RegisterBankInfo::getInstrMappingImpl(llvm::RegisterBankInfo *this, const llvm::MachineInstr *a2)
{
  v47[8] = *MEMORY[0x1E4F143B8];
  int v4 = **((unsigned __int16 **)a2 + 2);
  if ((v4 - 18) <= 0x33 && ((1 << (v4 - 18)) & 0x8000000000003) != 0 || v4 == 0)
  {
    int v30 = 1;
    unsigned int v31 = 1;
  }
  else
  {
    int v30 = 0;
    unsigned int v31 = *((_DWORD *)a2 + 10);
  }
  uint64_t v7 = *(void *)(*((void *)a2 + 3) + 32);
  uint64_t v8 = *(void *)(v7 + 16);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 176))(v8);
  unsigned int v10 = *(const llvm::MachineRegisterInfo **)(v7 + 40);
  unsigned int v42 = v31;
  uint64_t v44 = (llvm::TargetInstrInfo *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 104))(v8);
  uint64_t v45 = v47;
  uint64_t v46 = 0x800000000;
  sub_1CD4138E0((uint64_t)&v45, v31, 0);
  uint64_t v11 = *((unsigned int *)a2 + 10);
  if (!v11) {
    goto LABEL_11;
  }
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  char v43 = 1;
  while (1)
  {
    uint64_t v21 = *((void *)a2 + 4);
    if (*(unsigned char *)(v21 + v19)) {
      goto LABEL_18;
    }
    uint64_t v22 = v21 + v19;
    unsigned int v23 = *(_DWORD *)(v22 + 4);
    if (!v23) {
      goto LABEL_18;
    }
    RegBank = (const llvm::RegisterBank *)llvm::RegisterBankInfo::getRegBank((uint64_t)this, *(_DWORD *)(v22 + 4), (uint64_t)v10, v9);
    if (RegBank) {
      char v25 = v30;
    }
    else {
      char v25 = 0;
    }
    if ((v25 & 1) == 0)
    {
      uint64_t RegBankFromConstraints = llvm::RegisterBankInfo::getRegBankFromConstraints(this, a2, v20, v44, v10);
      if (!RegBankFromConstraints)
      {
        if ((v30 & 1) == 0) {
          goto LABEL_31;
        }
        char v43 = 0;
        goto LABEL_18;
      }
      RegBank = (const llvm::RegisterBank *)RegBankFromConstraints;
    }
    int SizeInBits = llvm::RegisterBankInfo::getSizeInBits((uint64_t)this, v23, (uint64_t)v10, v9);
    PartialMapping = (const llvm::RegisterBankInfo::PartialMapping *)llvm::RegisterBankInfo::getPartialMapping(this, 0, SizeInBits, RegBank);
    uint64_t ValueMapping = llvm::RegisterBankInfo::getValueMapping(this, PartialMapping, 1u);
    if (v30) {
      break;
    }
    *((void *)v45 + v20) = ValueMapping;
LABEL_18:
    ++v20;
    v19 += 32;
    if (v11 == v20)
    {
      if (v43 & 1 | ((v30 & 1) == 0)) {
        goto LABEL_11;
      }
      goto LABEL_31;
    }
  }
  uint64_t v32 = v45;
  if (!*(void *)v45)
  {
    if (**((_WORD **)a2 + 2) == 18)
    {
      int v33 = llvm::RegisterBankInfo::getSizeInBits((uint64_t)this, *(_DWORD *)(*((void *)a2 + 4) + 4), (uint64_t)v10, v9);
      int v34 = (const llvm::RegisterBankInfo::PartialMapping *)llvm::RegisterBankInfo::getPartialMapping(this, 0, v33, RegBank);
      uint64_t ValueMapping = llvm::RegisterBankInfo::getValueMapping(this, v34, 1u);
      uint64_t v32 = v45;
    }
    *uint64_t v32 = ValueMapping;
  }
  if (v11 != v20)
  {
    while (1)
    {
      uint64_t v35 = *((void *)a2 + 4);
      int v36 = v20;
      if (!*(unsigned char *)(v35 + 32 * v20))
      {
        uint64_t v37 = v35 + 32 * v20;
        unsigned int v38 = *(_DWORD *)(v37 + 4);
        if (v38)
        {
          unint64_t v39 = llvm::RegisterBankInfo::getRegBank((uint64_t)this, *(_DWORD *)(v37 + 4), (uint64_t)v10, v9);
          if (v39)
          {
            unint64_t v40 = v39;
            uint64_t v41 = llvm::RegisterBankInfo::getSizeInBits((uint64_t)this, v38, (uint64_t)v10, v9);
            if ((*(unsigned int (**)(llvm::RegisterBankInfo *, const llvm::RegisterBank *, unint64_t, uint64_t))(*(void *)this + 32))(this, RegBank, v40, v41) == -1)break; {
          }
            }
        }
      }
      LODWORD(v20) = v36 + 1;
      if (v11 == v36 + 1) {
        goto LABEL_11;
      }
    }
LABEL_31:
    uint64_t v13 = this;
    int v14 = -2;
    int v15 = 0;
    int v12 = 0;
    int v16 = 0;
    goto LABEL_12;
  }
LABEL_11:
  int v12 = (const llvm::RegisterBankInfo::ValueMapping *)sub_1CD5753D0((uint64_t)this, v45, (uint64_t)v45 + 8 * v46);
  uint64_t v13 = this;
  int v14 = -1;
  int v15 = 1;
  int v16 = v42;
LABEL_12:
  uint64_t InstructionMappingImpl = llvm::RegisterBankInfo::getInstructionMappingImpl(v13, 0, v14, v15, v12, v16);
  if (v45 != v47) {
    free(v45);
  }
  return InstructionMappingImpl;
}

uint64_t llvm::RegisterBankInfo::getValueMapping(llvm::RegisterBankInfo *this, int a2, int a3, const llvm::RegisterBank *a4)
{
  PartialMapping = (const llvm::RegisterBankInfo::PartialMapping *)llvm::RegisterBankInfo::getPartialMapping(this, a2, a3, a4);

  return llvm::RegisterBankInfo::getValueMapping(this, PartialMapping, 1u);
}

uint64_t llvm::RegisterBankInfo::getOperandsMapping(uint64_t a1, uint64_t a2)
{
  return sub_1CD5753D0(a1, *(void **)a2, *(void *)a2 + 8 * *(unsigned int *)(a2 + 8));
}

uint64_t llvm::RegisterBankInfo::getPartialMapping(llvm::RegisterBankInfo *this, int a2, int a3, const llvm::RegisterBank *a4)
{
  int v12 = a3;
  int v13 = a2;
  int v11 = *(_DWORD *)a4;
  int v5 = sub_1CD5764A0(&v13, &v12, &v11);
  uint64_t v7 = *((void *)this + 3);
  uint64_t v6 = (char *)this + 24;
  uint64_t v8 = *((unsigned int *)v6 + 4);
  uint64_t v9 = sub_1CD57516C(v7, *((_DWORD *)v6 + 4), v5);
  if ((int *)(v7 + 16 * v8) == v9)
  {
    int v13 = v5;
    sub_1CD576A40((uint64_t)v6, &v13);
    operator new();
  }
  return *((void *)v9 + 1);
}

int *sub_1CD57516C(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2) {
    return (int *)(a1 + 16 * a2);
  }
  LODWORD(v3) = (37 * a3) & (a2 - 1);
  int v4 = (int *)(a1 + 16 * v3);
  int v5 = *v4;
  if (*v4 != a3)
  {
    int v7 = 1;
    while (v5 != -1)
    {
      int v8 = v3 + v7++;
      uint64_t v3 = v8 & (a2 - 1);
      int v5 = *(_DWORD *)(a1 + 16 * v3);
      if (v5 == a3) {
        return (int *)(a1 + 16 * v3);
      }
    }
    return (int *)(a1 + 16 * a2);
  }
  return v4;
}

uint64_t llvm::RegisterBankInfo::getValueMapping(llvm::RegisterBankInfo *this, const llvm::RegisterBankInfo::PartialMapping *a2, unsigned int a3)
{
  v25[8] = *MEMORY[0x1E4F143B8];
  if (a3 == 1)
  {
    int v6 = *(_DWORD *)a2;
    int v7 = (_DWORD *)*((void *)a2 + 1);
    int v22 = *((_DWORD *)a2 + 1);
    LODWORD(v23) = v6;
    if (v7) {
      LODWORD(v7) = *v7;
    }
    int v21 = (int)v7;
    int v8 = sub_1CD5764A0(&v23, &v22, &v21);
  }
  else
  {
    uint64_t v14 = a3;
    unsigned int v23 = v25;
    uint64_t v24 = 0x800000000;
    sub_1CB90D610((uint64_t)&v23, a3, 0);
    if (a3)
    {
      int v16 = (_DWORD **)((char *)a2 + 8);
      do
      {
        int v17 = *((_DWORD *)v16 - 2);
        int v18 = *v16;
        int v21 = *((_DWORD *)v16 - 1);
        int v22 = v17;
        if (v18) {
          LODWORD(v18) = *v18;
        }
        int v20 = (int)v18;
        unint64_t v19 = sub_1CD5764A0(&v22, &v21, &v20);
        if (v24 >= (unint64_t)HIDWORD(v24)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v23 + v24) = v19;
        unsigned int v15 = v24 + 1;
        LODWORD(v24) = v24 + 1;
        v16 += 2;
        --v14;
      }
      while (v14);
    }
    else
    {
      unsigned int v15 = v24;
    }
    int v8 = sub_1CC13A6B8(v23, (uint64_t)v23 + 8 * v15);
    if (v23 != v25) {
      free(v23);
    }
  }
  uint64_t v10 = *((void *)this + 6);
  uint64_t v9 = (char *)this + 48;
  uint64_t v11 = *((unsigned int *)v9 + 4);
  int v12 = sub_1CD57516C(v10, *((_DWORD *)v9 + 4), v8);
  if ((int *)(v10 + 16 * v11) == v12)
  {
    LODWORD(v23) = v8;
    sub_1CD576E90((uint64_t)v9, &v23);
    operator new();
  }
  return *((void *)v12 + 1);
}

uint64_t sub_1CD5753D0(uint64_t a1, void *a2, uint64_t a3)
{
  int v5 = sub_1CD48BB60(a2, a3);
  uint64_t result = *((void *)sub_1CD5772E0(a1 + 72, &v5) + 1);
  if (!result) {
    operator new[]();
  }
  return result;
}

uint64_t llvm::RegisterBankInfo::getInstructionMappingImpl(llvm::RegisterBankInfo *this, BOOL a2, int a3, int a4, const llvm::RegisterBankInfo::ValueMapping *a5, int a6)
{
  int v15 = a4;
  int v16 = a3;
  uint64_t v14 = a5;
  int v13 = a6;
  int v7 = sub_1CD576558(&v16, &v15, (uint64_t *)&v14, &v13);
  uint64_t v9 = *((void *)this + 12);
  int v8 = (char *)this + 96;
  uint64_t v10 = *((unsigned int *)v8 + 4);
  uint64_t v11 = sub_1CD57516C(v9, *((_DWORD *)v8 + 4), v7);
  if ((int *)(v9 + 16 * v10) == v11)
  {
    LODWORD(v14) = v7;
    sub_1CD577730((uint64_t)v8, &v14);
    operator new();
  }
  return *((void *)v11 + 1);
}

void llvm::RegisterBankInfo::getInstrPossibleMappings(llvm::RegisterBankInfo *this@<X0>, const llvm::MachineInstr *a2@<X1>, unsigned int *a3@<X8>)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  *(void *)a3 = a3 + 4;
  *((void *)a3 + 1) = 0x400000000;
  uint64_t v6 = (*(uint64_t (**)(llvm::RegisterBankInfo *))(*(void *)this + 48))(this);
  if (*(_DWORD *)v6 != -2 && *(void *)(v6 + 8) != 0)
  {
    unsigned int v8 = a3[2];
    if (v8 >= a3[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v8) = v6;
    ++a3[2];
  }
  (*(void (**)(void **__return_ptr, llvm::RegisterBankInfo *, const llvm::MachineInstr *))(*(void *)this + 56))(&__src, this, a2);
  sub_1CD4832F4(a3, *(void *)a3 + 8 * a3[2], (uint64_t *)__src, (uint64_t *)__src + v10);
  if (__src != v11) {
    free(__src);
  }
}

double llvm::RegisterBankInfo::getInstrAlternativeMappings@<D0>(void *a1@<X8>)
{
  *a1 = a1 + 2;
  *(void *)&double result = 0x400000000;
  a1[1] = 0x400000000;
  return result;
}

uint64_t llvm::RegisterBankInfo::applyDefaultMapping(uint64_t this, const llvm::RegisterBankInfo::OperandsMapper *a2)
{
  uint64_t v2 = *(unsigned int *)(*(void *)(this + 112) + 16);
  if (v2)
  {
    uint64_t v3 = this;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(this + 96);
    uint64_t v7 = *(void *)(this + 104);
    uint64_t v8 = 32 * v2;
    do
    {
      this = *(void *)(v7 + 32) + v5;
      if (!*(unsigned char *)this)
      {
        int v9 = *(_DWORD *)(this + 4);
        if (v9)
        {
          uint64_t v10 = *(int *)(*(void *)v3 + v4);
          if (v10 != -1)
          {
            unsigned int v11 = *(_DWORD *)(v3 + 56);
            LODWORD(v12) = *(_DWORD *)(*(void *)(*(void *)(v3 + 112) + 8) + 4 * v4 + 8) + v10;
            uint64_t v12 = v11 >= v12 ? v12 : v11;
            if (v10 != v12)
            {
              unsigned int v13 = *(_DWORD *)(*(void *)(v3 + 48) + 4 * v10);
              this = llvm::MachineOperand::setReg(this, v13);
              if (v9 < 0 && (v9 & 0x7FFFFFFFu) < *(_DWORD *)(v6 + 432)) {
                uint64_t v14 = *(void *)(*(void *)(v6 + 424) + 8 * (v9 & 0x7FFFFFFF));
              }
              else {
                uint64_t v14 = 0;
              }
              if ((v13 & 0x80000000) != 0 && (v13 & 0x7FFFFFFF) < (unint64_t)*(unsigned int *)(v6 + 432)) {
                uint64_t v15 = *(void *)(*(void *)(v6 + 424) + 8 * (v13 & 0x7FFFFFFF));
              }
              else {
                uint64_t v15 = 0;
              }
              if (v14 != v15) {
                this = llvm::MachineRegisterInfo::setType(v6, v13, v14);
              }
            }
          }
        }
      }
      v5 += 32;
      v4 += 4;
    }
    while (v8 != v5);
  }
  return this;
}

uint64_t llvm::RegisterBankInfo::OperandsMapper::getVRegs(llvm::RegisterBankInfo::OperandsMapper *this, unsigned int a2)
{
  uint64_t v2 = *(int *)(*(void *)this + 4 * a2);
  if (v2 == -1) {
    return *((void *)this + 6) + 4 * *((unsigned int *)this + 14);
  }
  else {
    return *((void *)this + 6) + 4 * v2;
  }
}

llvm *llvm::RegisterBankInfo::PartialMapping::dump(llvm::RegisterBankInfo::PartialMapping *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = llvm::RegisterBankInfo::PartialMapping::print(this, v2);
  double result = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::RegisterBankInfo::PartialMapping::print(llvm::RegisterBankInfo::PartialMapping *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = sub_1CB8E509C(a2, "[");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)this);
  uint64_t v6 = sub_1CB8E509C(v5, ", ");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, (*(_DWORD *)this + *((_DWORD *)this + 1) - 1));
  sub_1CB8E509C(v7, "], RegBank = ");
  uint64_t v8 = (char **)*((void *)this + 1);
  if (v8)
  {
    return llvm::RegisterBank::print(v8, a2, 0, 0);
  }
  else
  {
    return sub_1CB8E509C(a2, "nullptr");
  }
}

llvm *llvm::RegisterBankInfo::ValueMapping::dump(llvm::RegisterBankInfo::ValueMapping *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = llvm::RegisterBankInfo::ValueMapping::print((llvm::RegisterBankInfo::PartialMapping **)this, v2);
  double result = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::RegisterBankInfo::ValueMapping::print(llvm::RegisterBankInfo::PartialMapping **this, llvm::raw_ostream *a2)
{
  uint64_t v4 = sub_1CB8E509C(a2, "#BreakDown: ");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, *((unsigned int *)this + 2));
  double result = sub_1CB8E509C(v5, " ");
  uint64_t v7 = *((unsigned int *)this + 2);
  if (v7)
  {
    uint64_t v8 = *this;
    uint64_t v9 = 16 * v7;
    char v10 = 1;
    do
    {
      if ((v10 & 1) == 0) {
        sub_1CB8E509C(a2, ", ");
      }
      unsigned int v11 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v11 >= *((void *)a2 + 3))
      {
        uint64_t v12 = llvm::raw_ostream::write(a2, 91);
      }
      else
      {
        *((void *)a2 + 4) = v11 + 1;
        *unsigned int v11 = 91;
        uint64_t v12 = a2;
      }
      double result = llvm::RegisterBankInfo::PartialMapping::print(v8, v12);
      unsigned int v13 = (unsigned char *)*((void *)v12 + 4);
      if ((unint64_t)v13 >= *((void *)v12 + 3))
      {
        double result = llvm::raw_ostream::write(v12, 93);
      }
      else
      {
        *((void *)v12 + 4) = v13 + 1;
        *unsigned int v13 = 93;
      }
      char v10 = 0;
      uint64_t v8 = (llvm::RegisterBankInfo::PartialMapping *)((char *)v8 + 16);
      v9 -= 16;
    }
    while (v9);
  }
  return result;
}

llvm *llvm::RegisterBankInfo::InstructionMapping::dump(llvm::RegisterBankInfo::InstructionMapping *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = llvm::RegisterBankInfo::InstructionMapping::print(this, v2);
  double result = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::RegisterBankInfo::InstructionMapping::print(llvm::RegisterBankInfo::InstructionMapping *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = sub_1CB8E509C(a2, "ID: ");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)this);
  uint64_t v6 = sub_1CB8E509C(v5, " Cost: ");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, *((unsigned int *)this + 1));
  double result = sub_1CB8E509C(v7, " Mapping: ");
  if (*((_DWORD *)this + 4))
  {
    unsigned int v9 = 0;
    do
    {
      uint64_t v10 = *((void *)this + 1);
      if (v9) {
        sub_1CB8E509C(a2, ", ");
      }
      unsigned int v11 = v9;
      uint64_t v12 = (llvm::RegisterBankInfo::PartialMapping **)(v10 + 16 * v9);
      unsigned int v13 = sub_1CB8E509C(a2, "{ Idx: ");
      uint64_t v14 = llvm::raw_ostream::operator<<(v13, v9);
      uint64_t v15 = sub_1CB8E509C(v14, " Map: ");
      double result = llvm::RegisterBankInfo::ValueMapping::print(v12, v15);
      int v16 = (unsigned char *)*((void *)v15 + 4);
      if ((unint64_t)v16 >= *((void *)v15 + 3))
      {
        double result = llvm::raw_ostream::write(v15, 125);
      }
      else
      {
        *((void *)v15 + 4) = v16 + 1;
        *int v16 = 125;
      }
      unsigned int v9 = v11 + 1;
    }
    while (v11 + 1 != *((_DWORD *)this + 4));
  }
  return result;
}

llvm::RegisterBankInfo::OperandsMapper *llvm::RegisterBankInfo::OperandsMapper::OperandsMapper(llvm::RegisterBankInfo::OperandsMapper *this, llvm::MachineInstr *a2, const llvm::RegisterBankInfo::InstructionMapping *a3, llvm::MachineRegisterInfo *a4)
{
  *(void *)this = (char *)this + 16;
  *((void *)this + 1) = 0x800000000;
  *((void *)this + 6) = (char *)this + 64;
  *((void *)this + 7) = 0x800000000;
  *((void *)this + 12) = a4;
  *((void *)this + 13) = a2;
  *((void *)this + 14) = a3;
  uint64_t v5 = *((unsigned int *)a3 + 4);
  if (v5) {
    sub_1CC458150((uint64_t)this, v5, -1);
  }
  return this;
}

uint64_t llvm::RegisterBankInfo::OperandsMapper::getVRegsMem(llvm::RegisterBankInfo::OperandsMapper *this, unsigned int a2)
{
  int v2 = *(_DWORD *)(*(void *)(*((void *)this + 14) + 8) + 16 * a2 + 8);
  int v3 = *(_DWORD *)(*(void *)this + 4 * a2);
  if (v3 == -1)
  {
    int v3 = *((_DWORD *)this + 14);
    *(_DWORD *)(*(void *)this + 4 * a2) = v3;
    if (v2)
    {
      unsigned int v5 = *((_DWORD *)this + 14);
      int v6 = v2;
      do
      {
        if (v5 >= *((_DWORD *)this + 15)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*((void *)this + 6) + 4 * v5) = 0;
        unsigned int v5 = *((_DWORD *)this + 14) + 1;
        *((_DWORD *)this + 14) = v5;
        --v6;
      }
      while (v6);
    }
  }
  return *((void *)this + 6) + 4 * v3;
}

int *llvm::RegisterBankInfo::OperandsMapper::createVRegs(llvm::RegisterBankInfo::OperandsMapper *this, unsigned int a2)
{
  double result = (int *)llvm::RegisterBankInfo::OperandsMapper::getVRegsMem(this, a2);
  if (result != v5)
  {
    int v6 = result;
    uint64_t v7 = v5;
    uint64_t v8 = (uint64_t *)(*(void *)(*(void *)(*((void *)this + 14) + 8) + 16 * a2) + 8);
    do
    {
      int GenericVirtualRegister = llvm::MachineRegisterInfo::createGenericVirtualRegister(*((void *)this + 12), (8 * *((unsigned int *)v8 - 1)) | 1, "", 0);
      *v6++ = GenericVirtualRegister;
      uint64_t v10 = *v8;
      v8 += 2;
      double result = (int *)llvm::MachineRegisterInfo::setRegBank(*((void *)this + 12), GenericVirtualRegister, v10);
    }
    while (v6 != v7);
  }
  return result;
}

llvm *llvm::RegisterBankInfo::OperandsMapper::dump(llvm::RegisterBankInfo::OperandsMapper *this)
{
  int v2 = (char **)llvm::dbgs(this);
  int v3 = llvm::RegisterBankInfo::OperandsMapper::print(this, v2, 1);
  double result = llvm::dbgs(v3);
  unsigned int v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::RegisterBankInfo::OperandsMapper::print(llvm::RegisterBankInfo::OperandsMapper *this, char **a2, int a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned int *)(*((void *)this + 14) + 16);
  if (a3)
  {
    unint64_t v26 = sub_1CB8E509C((llvm::raw_ostream *)a2, "Mapping for ");
    llvm::MachineInstr::print(*((llvm::MachineInstr **)this + 13), v26, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
    uint64_t v27 = sub_1CB8E509C(v26, "\nwith ");
    llvm::RegisterBankInfo::InstructionMapping::print(*((llvm::RegisterBankInfo::InstructionMapping **)this + 14), v27);
    uint64_t v28 = (unsigned char *)*((void *)v27 + 4);
    if ((unint64_t)v28 >= *((void *)v27 + 3))
    {
      llvm::raw_ostream::write(v27, 10);
    }
    else
    {
      *((void *)v27 + 4) = v28 + 1;
      unsigned char *v28 = 10;
    }
    sub_1CB8E509C((llvm::raw_ostream *)a2, "Populated indices (CellNumber, IndexInNewVRegs): ");
    if (v5)
    {
      unint64_t v29 = 0;
      char v30 = 1;
      do
      {
        if (*(_DWORD *)(*(void *)this + 4 * v29) != -1)
        {
          if ((v30 & 1) == 0) {
            sub_1CB8E509C((llvm::raw_ostream *)a2, ", ");
          }
          unsigned int v31 = a2[4];
          if (v31 >= a2[3])
          {
            uint64_t v32 = llvm::raw_ostream::write((llvm::raw_ostream *)a2, 40);
          }
          else
          {
            a2[4] = v31 + 1;
            *unsigned int v31 = 40;
            uint64_t v32 = (llvm::raw_ostream *)a2;
          }
          int v33 = llvm::raw_ostream::operator<<(v32, v29);
          int v34 = sub_1CB8E509C(v33, ", ");
          uint64_t v35 = llvm::raw_ostream::operator<<(v34, *(int *)(*(void *)this + 4 * v29));
          int v36 = (unsigned char *)*((void *)v35 + 4);
          if ((unint64_t)v36 >= *((void *)v35 + 3))
          {
            llvm::raw_ostream::write(v35, 41);
            char v30 = 0;
          }
          else
          {
            char v30 = 0;
            *((void *)v35 + 4) = v36 + 1;
            *int v36 = 41;
          }
        }
        ++v29;
      }
      while (v5 != v29);
    }
    uint64_t v8 = a2[4];
    if (v8 < a2[3])
    {
      a2[4] = v8 + 1;
      char v9 = 10;
      goto LABEL_4;
    }
    uint64_t v7 = (llvm::raw_ostream *)a2;
    char v10 = 10;
LABEL_6:
    llvm::raw_ostream::write(v7, v10);
    goto LABEL_7;
  }
  int v6 = sub_1CB8E509C((llvm::raw_ostream *)a2, "Mapping ID: ");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, **((unsigned int **)this + 14));
  uint64_t v8 = (char *)*((void *)v7 + 4);
  if ((unint64_t)v8 >= *((void *)v7 + 3))
  {
    char v10 = 32;
    goto LABEL_6;
  }
  *((void *)v7 + 4) = v8 + 1;
  char v9 = 32;
LABEL_4:
  *uint64_t v8 = v9;
LABEL_7:
  double result = sub_1CB8E509C((llvm::raw_ostream *)a2, "Operand Mapping: ");
  uint64_t v12 = *(void *)(*((void *)this + 13) + 24);
  if (v12 && (uint64_t v13 = *(void *)(v12 + 32)) != 0)
  {
    double result = (llvm::raw_ostream *)(*(uint64_t (**)(void))(**(void **)(v13 + 16) + 176))(*(void *)(v13 + 16));
    uint64_t v14 = (uint64_t)result;
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (v5)
  {
    uint64_t v15 = 0;
    char v16 = 1;
    do
    {
      if (*(_DWORD *)(*(void *)this + 4 * v15) != -1)
      {
        if ((v16 & 1) == 0) {
          sub_1CB8E509C((llvm::raw_ostream *)a2, ", ");
        }
        int v17 = a2[4];
        if (v17 >= a2[3])
        {
          int v18 = llvm::raw_ostream::write((llvm::raw_ostream *)a2, 40);
        }
        else
        {
          a2[4] = v17 + 1;
          *int v17 = 40;
          int v18 = (llvm::raw_ostream *)a2;
        }
        llvm::printReg(*(_DWORD *)(*(void *)(*((void *)this + 13) + 32) + 32 * v15 + 4), v14, 0, 0, (uint64_t)v37);
        if (!v38) {
          goto LABEL_61;
        }
        (*(void (**)(void *, llvm::raw_ostream *))(*v38 + 48))(v38, v18);
        sub_1CB8E509C(v18, ", [");
        if (v38 == v37)
        {
          (*(void (**)(void *))(v37[0] + 32))(v37);
        }
        else if (v38)
        {
          (*(void (**)(void))(*v38 + 40))();
        }
        uint64_t v19 = *(int *)(*(void *)this + 4 * v15);
        if (v19 != -1)
        {
          unsigned int v20 = *((_DWORD *)this + 14);
          LODWORD(v21) = *(_DWORD *)(*(void *)(*((void *)this + 14) + 8) + 16 * v15 + 8) + v19;
          uint64_t v21 = v20 >= v21 ? v21 : v20;
          if (v19 != v21)
          {
            int v22 = (int *)(*((void *)this + 6) + 4 * v19);
            uint64_t v23 = 4 * v21 - 4 * v19;
            char v24 = 1;
            while (1)
            {
              int v25 = *v22;
              if ((v24 & 1) == 0) {
                sub_1CB8E509C((llvm::raw_ostream *)a2, ", ");
              }
              llvm::printReg(v25, v14, 0, 0, (uint64_t)v37);
              if (!v38) {
                break;
              }
              (*(void (**)(void *, char **))(*v38 + 48))(v38, a2);
              if (v38 == v37)
              {
                (*(void (**)(void *))(v37[0] + 32))(v37);
              }
              else if (v38)
              {
                (*(void (**)(void))(*v38 + 40))();
              }
              char v24 = 0;
              ++v22;
              v23 -= 4;
              if (!v23) {
                goto LABEL_27;
              }
            }
LABEL_61:
            sub_1CB920400();
          }
        }
LABEL_27:
        double result = sub_1CB8E509C((llvm::raw_ostream *)a2, "])");
        char v16 = 0;
      }
      ++v15;
    }
    while (v15 != v5);
  }
  return result;
}

void sub_1CD576468(uint64_t a1)
{
}

void sub_1CD576478()
{
  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD5764A0(_DWORD *a1, int *a2, int *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LODWORD(v7[0]) = *a1;
  return sub_1CC36B194((char *)v7, 0, (_DWORD *)v7 + 1, (char *)v8, a2, a3);
}

unint64_t sub_1CD576558(int *a1, int *a2, uint64_t *a3, int *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v12 = sub_1CBF65470();
  return sub_1CD576610(v9, v9, (char *)v10, *a1, a2, a3, a4);
}

unint64_t sub_1CD576610(void *a1, _DWORD *__dst, char *a3, int a4, int *a5, uint64_t *a6, int *a7)
{
  uint64_t v15 = 0;
  uint64_t v12 = sub_1CC0AC9D0(a1, &v15, __dst, (unint64_t)a3, a4);
  uint64_t v16 = v15;
  uint64_t v13 = sub_1CC0AC9D0(a1, &v16, v12, (unint64_t)a3, *a5);
  return sub_1CD5766AC(a1, v16, v13, a3, *a6, a7);
}

unint64_t sub_1CD5766AC(void *a1, uint64_t a2, void *a3, char *a4, uint64_t a5, int *a6)
{
  uint64_t v12 = a2;
  uint64_t v9 = sub_1CC2E96A4(a1, &v12, a3, (unint64_t)a4, a5);
  uint64_t v13 = v12;
  uint64_t v10 = (char *)sub_1CC0AC9D0(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

_DWORD *sub_1CD576724(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    int v7 = v3 - 1;
    unsigned int v8 = (37 * *a2) & (v3 - 1);
    uint64_t v5 = (_DWORD *)(*(void *)a1 + 16 * v8);
    int v9 = *v5;
    if (*a2 == *v5) {
      return v5;
    }
    uint64_t v10 = 0;
    int v11 = 1;
    while (v9 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v9 == -2;
      }
      if (v12) {
        uint64_t v10 = v5;
      }
      unsigned int v13 = v8 + v11++;
      unsigned int v8 = v13 & v7;
      uint64_t v5 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v7));
      int v9 = *v5;
      if (*a2 == *v5) {
        return v5;
      }
    }
    if (v10) {
      uint64_t v4 = v10;
    }
    else {
      uint64_t v4 = v5;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v5 = sub_1CD5767E0(a1, a2, v4);
  _DWORD *v5 = *a2;
  *((void *)v5 + 1) = 0;
  return v5;
}

_DWORD *sub_1CD5767E0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_8;
    }
    sub_1CD576968(a1, v6);
    int v14 = *(_DWORD *)(a1 + 16);
    if (v14)
    {
      int v15 = v14 - 1;
      unsigned int v16 = (37 * *a2) & v15;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v16);
      int v17 = *a3;
      if (*a2 == *a3) {
        goto LABEL_8;
      }
      int v11 = 0;
      int v18 = 1;
      while (v17 != -1)
      {
        if (v11) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v17 == -2;
        }
        if (v19) {
          int v11 = a3;
        }
        unsigned int v20 = v16 + v18++;
        unsigned int v16 = v20 & v15;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v16);
        int v17 = *a3;
        if (*a2 == *a3) {
          goto LABEL_8;
        }
      }
      goto LABEL_6;
    }
LABEL_23:
    a3 = 0;
    goto LABEL_8;
  }
  sub_1CD576968(a1, 2 * v6);
  int v7 = *(_DWORD *)(a1 + 16);
  if (!v7) {
    goto LABEL_23;
  }
  int v8 = v7 - 1;
  unsigned int v9 = (37 * *a2) & v8;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v9);
  int v10 = *a3;
  if (*a2 == *a3) {
    goto LABEL_8;
  }
  int v11 = 0;
  int v12 = 1;
  while (v10 != -1)
  {
    if (v11) {
      BOOL v21 = 0;
    }
    else {
      BOOL v21 = v10 == -2;
    }
    if (v21) {
      int v11 = a3;
    }
    unsigned int v22 = v9 + v12++;
    unsigned int v9 = v22 & v8;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v9);
    int v10 = *a3;
    if (*a2 == *a3) {
      goto LABEL_8;
    }
  }
LABEL_6:
  if (v11) {
    a3 = v11;
  }
LABEL_8:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD576968(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD48C0B0(a1, v4, &v4[4 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

_DWORD *sub_1CD576A40(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    unsigned int v9 = 0;
LABEL_5:
    unint64_t v6 = sub_1CD576B00(a1, a2, v9);
    *unint64_t v6 = *a2;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  unint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      unint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      unsigned int v9 = v10;
    }
    else {
      unsigned int v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD576B00(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD576C88(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD576C88(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD576C88(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD576D5C(a1, v4, &v4[4 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD576D5C(uint64_t result, int *a2, int *a3)
{
  int v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -1;
      v7 += 4;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(v5 + 16) - 1;
        unsigned int v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)v5 + 16 * v11;
        int v13 = *(_DWORD *)v12;
        if (v9 != *(_DWORD *)v12)
        {
          uint64_t v15 = 0;
          int v16 = 1;
          while (v13 != -1)
          {
            if (v15) {
              BOOL v17 = 0;
            }
            else {
              BOOL v17 = v13 == -2;
            }
            if (v17) {
              uint64_t v15 = v12;
            }
            unsigned int v18 = v11 + v16++;
            unsigned int v11 = v18 & v10;
            uint64_t v12 = *(void *)v5 + 16 * (v18 & v10);
            int v13 = *(_DWORD *)v12;
            if (v9 == *(_DWORD *)v12) {
              goto LABEL_9;
            }
          }
          if (v15) {
            uint64_t v12 = v15;
          }
        }
LABEL_9:
        *(_DWORD *)uint64_t v12 = v9;
        uint64_t v14 = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        *(void *)(v12 + 8) = v14;
        ++*(_DWORD *)(v5 + 8);
        double result = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        if (result) {
          double result = MEMORY[0x1D25D9CE0](result, 0x1060C40832E3BDALL);
        }
      }
      v4 += 4;
    }
    while (v4 != a3);
  }
  return result;
}

_DWORD *sub_1CD576E90(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD576F50(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        int v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      int v9 = v10;
    }
    else {
      int v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD576F50(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD5770D8(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD5770D8(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD5770D8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5771AC(a1, v4, &v4[4 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5771AC(uint64_t result, int *a2, int *a3)
{
  int v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -1;
      v7 += 4;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(v5 + 16) - 1;
        unsigned int v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)v5 + 16 * v11;
        int v13 = *(_DWORD *)v12;
        if (v9 != *(_DWORD *)v12)
        {
          uint64_t v15 = 0;
          int v16 = 1;
          while (v13 != -1)
          {
            if (v15) {
              BOOL v17 = 0;
            }
            else {
              BOOL v17 = v13 == -2;
            }
            if (v17) {
              uint64_t v15 = v12;
            }
            unsigned int v18 = v11 + v16++;
            unsigned int v11 = v18 & v10;
            uint64_t v12 = *(void *)v5 + 16 * (v18 & v10);
            int v13 = *(_DWORD *)v12;
            if (v9 == *(_DWORD *)v12) {
              goto LABEL_9;
            }
          }
          if (v15) {
            uint64_t v12 = v15;
          }
        }
LABEL_9:
        *(_DWORD *)uint64_t v12 = v9;
        uint64_t v14 = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        *(void *)(v12 + 8) = v14;
        ++*(_DWORD *)(v5 + 8);
        double result = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        if (result) {
          double result = MEMORY[0x1D25D9CE0](result, 0x1060C40ADAFC7CALL);
        }
      }
      v4 += 4;
    }
    while (v4 != a3);
  }
  return result;
}

_DWORD *sub_1CD5772E0(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD5773A0(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        int v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      int v9 = v10;
    }
    else {
      int v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD5773A0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD577528(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD577528(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD577528(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5775FC(a1, v4, &v4[4 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5775FC(uint64_t result, int *a2, int *a3)
{
  int v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -1;
      v7 += 4;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(v5 + 16) - 1;
        unsigned int v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)v5 + 16 * v11;
        int v13 = *(_DWORD *)v12;
        if (v9 != *(_DWORD *)v12)
        {
          uint64_t v15 = 0;
          int v16 = 1;
          while (v13 != -1)
          {
            if (v15) {
              BOOL v17 = 0;
            }
            else {
              BOOL v17 = v13 == -2;
            }
            if (v17) {
              uint64_t v15 = v12;
            }
            unsigned int v18 = v11 + v16++;
            unsigned int v11 = v18 & v10;
            uint64_t v12 = *(void *)v5 + 16 * (v18 & v10);
            int v13 = *(_DWORD *)v12;
            if (v9 == *(_DWORD *)v12) {
              goto LABEL_9;
            }
          }
          if (v15) {
            uint64_t v12 = v15;
          }
        }
LABEL_9:
        *(_DWORD *)uint64_t v12 = v9;
        uint64_t v14 = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        *(void *)(v12 + 8) = v14;
        ++*(_DWORD *)(v5 + 8);
        double result = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        if (result) {
          double result = MEMORY[0x1D25D9CB0](result, 0x1060C80ADAFC7CALL);
        }
      }
      v4 += 4;
    }
    while (v4 != a3);
  }
  return result;
}

_DWORD *sub_1CD577730(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD5777F0(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        int v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      int v9 = v10;
    }
    else {
      int v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD5777F0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD577978(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD577978(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD577978(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD577A4C(a1, v4, &v4[4 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      _DWORD *result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD577A4C(uint64_t result, int *a2, int *a3)
{
  int v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -1;
      v7 += 4;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(v5 + 16) - 1;
        unsigned int v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)v5 + 16 * v11;
        int v13 = *(_DWORD *)v12;
        if (v9 != *(_DWORD *)v12)
        {
          uint64_t v15 = 0;
          int v16 = 1;
          while (v13 != -1)
          {
            if (v15) {
              BOOL v17 = 0;
            }
            else {
              BOOL v17 = v13 == -2;
            }
            if (v17) {
              uint64_t v15 = v12;
            }
            unsigned int v18 = v11 + v16++;
            unsigned int v11 = v18 & v10;
            uint64_t v12 = *(void *)v5 + 16 * (v18 & v10);
            int v13 = *(_DWORD *)v12;
            if (v9 == *(_DWORD *)v12) {
              goto LABEL_9;
            }
          }
          if (v15) {
            uint64_t v12 = v15;
          }
        }
LABEL_9:
        *(_DWORD *)uint64_t v12 = v9;
        uint64_t v14 = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        *(void *)(v12 + 8) = v14;
        ++*(_DWORD *)(v5 + 8);
        double result = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        if (result) {
          double result = MEMORY[0x1D25D9CE0](result, 0x1060C40F2FE4B89);
        }
      }
      v4 += 4;
    }
    while (v4 != a3);
  }
  return result;
}

void llvm::initializeSafeStackLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34E8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC458200;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD34E8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createSafeStackPass(llvm *this)
{
}

llvm::PointerType *sub_1CD577C30(uint64_t a1, unsigned __int8 *a2, const char *a3, uint64_t a4, uint64_t **a5)
{
  int v9 = (llvm::PointerType *)llvm::FunctionType::get(a5, (uint64_t)&v11, 0, 0);
  return llvm::Module::getOrInsertFunction(a1, a2, a3, v9, a4);
}

void **sub_1CD577CCC(void **a1)
{
  uint64_t v3 = a1 + 2;
  int v2 = (void **)*a1;
  if (v2 != v3) {
    free(v2);
  }
  return a1;
}

void sub_1CD577D08()
{
}

void *sub_1CD577D1C()
{
  double result = operator new(0x10uLL);
  void *result = &unk_1F2612BC0;
  return result;
}

void sub_1CD577D54(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2612BC0;
}

BOOL sub_1CD577D7C(uint64_t a1, void *a2)
{
  return *a2 != 0;
}

uint64_t sub_1CD577D8C(void *a1, void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2[1];
  v13[0] = *a2;
  v13[1] = v5;
  uint64_t v6 = (void *)a2[5];
  if (v6)
  {
    if (v6 == a2 + 2)
    {
      uint64_t v15 = v14;
      (*(void (**)(void *, void *))(*v6 + 24))(v6, v14);
    }
    else
    {
      uint64_t v15 = (void *)a2[5];
      a2[5] = 0;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v7 = a3[1];
  v10[0] = *a3;
  v10[1] = v7;
  uint64_t v8 = (void *)a3[5];
  if (v8)
  {
    if (v8 == a3 + 2)
    {
      uint64_t v12 = v11;
      (*(void (**)(void *, void *))(*v8 + 24))(v8, v11);
    }
    else
    {
      uint64_t v12 = (void *)a3[5];
      a3[5] = 0;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  sub_1CD577F84(a1, v13, v10);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
  if (v15) {
    return (*(uint64_t (**)(void))(*v15 + 40))();
  }
  return result;
}

void *sub_1CD577F84(void *a1, void *a2, void *a3)
{
  *a1 = *a2;
  a1[1] = a2[1];
  uint64_t v5 = (void *)a2[5];
  if (v5)
  {
    if (v5 == a2 + 2)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void, void *))(*(void *)a2[5] + 24))(a2[5], a1 + 2);
    }
    else
    {
      a1[5] = v5;
      a2[5] = 0;
    }
  }
  else
  {
    a1[5] = 0;
  }
  a1[6] = *a3;
  a1[7] = a3[1];
  uint64_t v6 = (void *)a3[5];
  if (v6)
  {
    if (v6 == a3 + 2)
    {
      a1[11] = a1 + 8;
      (*(void (**)(void))(*(void *)a3[5] + 24))(a3[5]);
    }
    else
    {
      a1[11] = v6;
      a3[5] = 0;
    }
  }
  else
  {
    a1[11] = 0;
  }
  return a1;
}

void *sub_1CD578080(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  sub_1CC45E850((uint64_t)v8, a4);
  *a1 = a2;
  a1[1] = a3;
  if (v9)
  {
    if (v9 == v8)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void *))(v8[0] + 24))(v8);
    }
    else
    {
      a1[5] = (*(uint64_t (**)(void))(*v9 + 16))();
    }
  }
  else
  {
    a1[5] = 0;
  }
  sub_1CD5781E0((uint64_t)a1);
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  return a1;
}

uint64_t sub_1CD5781E0(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)result;
  if (*(void *)result != *(void *)(result + 8))
  {
    int v2 = (void *)result;
    while (1)
    {
      uint64_t v6 = *v1;
      uint64_t v3 = v2[5];
      if (!v3) {
        break;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v6);
      if ((result & 1) == 0)
      {
        int v4 = (uint64_t *)v2[1];
        uint64_t v1 = (uint64_t *)(*v2 + 8);
        *int v2 = v1;
        if (v1 != v4) {
          continue;
        }
      }
      return result;
    }
    sub_1CB920400();
    return (uint64_t)sub_1CD578268(v5);
  }
  return result;
}

void *sub_1CD578268(void *a1)
{
  int v2 = a1 + 8;
  uint64_t v3 = (void *)a1[11];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  int v4 = (void *)a1[5];
  if (v4 == a1 + 2)
  {
    (*(void (**)(void *))(a1[2] + 32))(a1 + 2);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  return a1;
}

void *sub_1CD578354(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5783BC((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    *((unsigned char *)v5 + 8) = 0;
  }
  return v5;
}

void *sub_1CD5783BC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD57846C(a1, v7);
  int v9 = 0;
  sub_1CD3C8538((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD57846C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD466668(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD578538(uint64_t a1)
{
  return a1;
}

char **sub_1CD578584(char **a1)
{
  int v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 88 * v3;
    do
    {
      unint64_t v5 = *(char **)&v2[v4 - 72];
      if (&v2[v4 - 56] != v5) {
        free(v5);
      }
      v4 -= 88;
    }
    while (v4);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD5785FC(char **a1)
{
  int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 80 * v3;
    do
    {
      unint64_t v5 = *(char **)&v2[v4 - 72];
      if (&v2[v4 - 56] != v5) {
        free(v5);
      }
      v4 -= 80;
    }
    while (v4);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD578674(char **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD3540, 0, 0);
  byte_1EBCD35C0 = 0;
  qword_1EBCD35C8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD35D0 = 0;
  qword_1EBCD3540 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD35D8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD35E0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD35F8 = (uint64_t)&qword_1EBCD35E0;
  llvm::cl::Option::setArgStr(v4, "safestack-use-pointer-address", 0x1DuLL);
  unint64_t v5 = *a1;
  byte_1EBCD35C0 = **a1;
  byte_1EBCD35D1 = 1;
  byte_1EBCD35D0 = *v5;
  word_1EBCD354A = (32 * (*a2 & 3)) | word_1EBCD354A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD3540);
}

llvm::raw_ostream *llvm::safestack::StackLayout::print(llvm::safestack::StackLayout *this, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "Stack regions:\n");
  if (*((_DWORD *)this + 4))
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      unint64_t v6 = sub_1CB8E509C(a2, "  ");
      int v7 = llvm::raw_ostream::operator<<(v6, v5);
      unsigned int v8 = sub_1CB8E509C(v7, ": [");
      int v9 = llvm::raw_ostream::operator<<(v8, *(unsigned int *)(*((void *)this + 1) + v4));
      uint64_t v10 = sub_1CB8E509C(v9, ", ");
      uint64_t v11 = llvm::raw_ostream::operator<<(v10, *(unsigned int *)(*((void *)this + 1) + v4 + 4));
      uint64_t v12 = sub_1CB8E509C(v11, "), range ");
      int v13 = sub_1CD578988(v12, *((void *)this + 1) + v4 + 8);
      sub_1CB8E509C(v13, "\n");
      ++v5;
      v4 += 80;
    }
    while (v5 < *((unsigned int *)this + 4));
  }
  uint64_t result = sub_1CB8E509C(a2, "Stack objects:\n");
  uint64_t v15 = *((void *)this + 253);
  uint64_t v16 = *((unsigned int *)this + 510);
  uint64_t v17 = v15 + 16 * v16;
  if (*((_DWORD *)this + 508))
  {
    if (v16)
    {
      uint64_t v18 = 16 * v16;
      uint64_t v19 = *((void *)this + 253);
      while ((*(void *)v19 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v19 += 16;
        v18 -= 16;
        if (!v18) {
          goto LABEL_9;
        }
      }
    }
    else
    {
      uint64_t v19 = *((void *)this + 253);
    }
  }
  else
  {
LABEL_9:
    uint64_t v19 = v15 + 16 * v16;
  }
  uint64_t v20 = v15 + 16 * v16;
  while (v19 != v20)
  {
    BOOL v21 = sub_1CB8E509C(a2, "  at ");
    unsigned int v22 = llvm::raw_ostream::operator<<(v21, *(unsigned int *)(v19 + 8));
    uint64_t v23 = sub_1CB8E509C(v22, ": ");
    llvm::Value::print(*(llvm::Value **)v19, v23, 0);
    uint64_t result = sub_1CB8E509C(v23, "\n");
    uint64_t v24 = v19 + 16;
    uint64_t v19 = v17;
    if (v24 != v17)
    {
      uint64_t v19 = v24;
      while ((*(void *)v19 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v19 += 16;
        if (v19 == v17)
        {
          uint64_t v19 = v17;
          break;
        }
      }
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD578988(llvm::raw_ostream *a1, uint64_t a2)
{
  sub_1CB8E509C(a1, "{");
  unsigned int v4 = sub_1CB9FA0BC(a2);
  if ((v4 & 0x80000000) == 0)
  {
    unsigned int v5 = v4;
    char v6 = 0;
    do
    {
      if (v6) {
        size_t v7 = 2;
      }
      else {
        size_t v7 = 0;
      }
      unsigned int v8 = (_WORD *)*((void *)a1 + 4);
      if (v7 <= *((void *)a1 + 3) - (void)v8)
      {
        if (v6)
        {
          *unsigned int v8 = 8236;
          *((void *)a1 + 4) += 2;
        }
      }
      else
      {
        if (v6) {
          int v9 = ", ";
        }
        else {
          int v9 = 0;
        }
        llvm::raw_ostream::write(a1, v9, v7);
      }
      llvm::raw_ostream::operator<<(a1, v5);
      char v6 = 1;
      unsigned int v5 = sub_1CC45F194((void *)a2, v5 + 1, *(_DWORD *)(a2 + 64), 1u);
    }
    while ((v5 & 0x80000000) == 0);
  }
  sub_1CB8E509C(a1, "}");
  return a1;
}

void *llvm::safestack::StackLayout::addObject(uint64_t *a1, uint64_t a2, int a3, unsigned __int8 a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a2;
  uint64_t v12 = a2;
  uint64_t v8 = (uint64_t)(a1 + 163);
  int v13 = a3;
  unsigned __int8 v14 = a4;
  v15[0] = v16;
  v15[1] = (void *)0x600000000;
  if (*(_DWORD *)(a5 + 8)) {
    sub_1CBAF13E8((uint64_t)v15, a5);
  }
  v16[12] = *(_DWORD *)(a5 + 64);
  sub_1CD578B68(v8, (unint64_t)&v12);
  if (v15[0] != v16) {
    free(v15[0]);
  }
  uint64_t result = sub_1CD578354(a1 + 256, &v11);
  *((unsigned char *)result + 8) = a4;
  unsigned __int8 v10 = a4;
  if (*(unsigned __int8 *)a1 > a4) {
    unsigned __int8 v10 = *(unsigned char *)a1;
  }
  *(unsigned char *)a1 = v10;
  return result;
}

uint64_t sub_1CD578B68(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD578DA4(a1, a2);
  uint64_t v4 = *(void *)a1;
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  char v6 = (void *)(*(void *)a1 + 88 * v5);
  uint64_t v7 = *(void *)v3;
  *(void *)((char *)v6 + 5) = *(void *)(v3 + 5);
  *char v6 = v7;
  v6[3] = 0x600000000;
  v6[2] = v6 + 4;
  uint64_t result = (uint64_t)(v6 + 2);
  if (*(_DWORD *)(v3 + 24)) {
    uint64_t result = sub_1CB837F14(result, v3 + 16);
  }
  *(_DWORD *)(v4 + 88 * v5 + 80) = *(_DWORD *)(v3 + 80);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD578BF8(uint64_t *a1, _DWORD *a2, int *a3, uint64_t a4)
{
  unsigned int v6 = *((_DWORD *)a1 + 2);
  if (v6 >= *((_DWORD *)a1 + 3))
  {
    sub_1CD578F60();
  }
  uint64_t v7 = *a1;
  uint64_t v8 = *a1 + 80 * v6;
  int v9 = *a3;
  *(_DWORD *)uint64_t v8 = *a2;
  *(_DWORD *)(v8 + 4) = v9;
  *(void *)(v8 + 16) = 0x600000000;
  *(void *)(v8 + 8) = v8 + 24;
  uint64_t result = v8 + 8;
  if (*(_DWORD *)(a4 + 8)) {
    uint64_t result = sub_1CBAF13E8(result, a4);
  }
  *(_DWORD *)(v7 + 80 * v6 + 72) = *(_DWORD *)(a4 + 64);
  ++*((_DWORD *)a1 + 2);
  return result;
}

void llvm::safestack::StackLayout::computeLayout(llvm::safestack::StackLayout *this)
{
  uint64_t v2 = *((unsigned int *)this + 328);
  if (v2 >= 3)
  {
    uint64_t v3 = *((void *)this + 163);
    uint64_t v4 = v3 + 88;
    unsigned int v5 = (uint64_t *)(v3 + 88 * v2);
    unint64_t v6 = v2 - 1;
    uint64_t v7 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v8 = v2 - 1;
    while (1)
    {
      int v9 = operator new(88 * v8, v7);
      if (v9) {
        break;
      }
      BOOL v10 = v8 >= 2;
      v8 >>= 1;
      if (!v10)
      {
        sub_1CC45F238(v4, v5, v6, 0, 0);
        goto LABEL_7;
      }
    }
    uint64_t v11 = v9;
    sub_1CC45F238(v4, v5, v6, v9, v8);
    operator delete(v11);
LABEL_7:
    LODWORD(v2) = *((_DWORD *)this + 328);
  }
  if (v2)
  {
    uint64_t v12 = *((void *)this + 163);
    uint64_t v13 = 88 * v2;
    do
    {
      llvm::safestack::StackLayout::layoutObject((uint64_t)this, v12);
      v12 += 88;
      v13 -= 88;
    }
    while (v13);
  }
}

unint64_t sub_1CD578DA4(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 88 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD578E10();
    }
    sub_1CD578E10();
  }
  return a2;
}

void sub_1CD578E10()
{
}

void sub_1CD578E80(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = *a1 + 88 * v2;
    uint64_t v6 = *a1 + 16;
    do
    {
      uint64_t v8 = v6 - 16;
      uint64_t v7 = *(void *)(v6 - 16);
      *(void *)(a2 + 5) = *(void *)(v6 - 11);
      *(void *)a2 = v7;
      *(void *)(a2 + 16) = a2 + 32;
      *(void *)(a2 + 24) = 0x600000000;
      if (*(_DWORD *)(v6 + 8)) {
        sub_1CB837F14(a2 + 16, v6);
      }
      *(_DWORD *)(a2 + 80) = *(_DWORD *)(v6 + 64);
      a2 += 88;
      v6 += 88;
    }
    while (v8 + 88 != v5);
    unsigned int v9 = *((_DWORD *)a1 + 2);
    if (v9)
    {
      uint64_t v10 = *a1;
      uint64_t v11 = 88 * v9;
      do
      {
        uint64_t v12 = *(void **)(v10 + v11 - 72);
        if ((void *)(v10 + v11 - 56) != v12) {
          free(v12);
        }
        v11 -= 88;
      }
      while (v11);
    }
  }
}

void sub_1CD578F60()
{
}

void sub_1CD57904C(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a1;
    uint64_t v7 = *a1 + 80 * v2;
    do
    {
      uint64_t v8 = a2 + v5;
      uint64_t v9 = v6 + v5;
      *(void *)uint64_t v8 = *(void *)(v6 + v5);
      *(void *)(a2 + v5 + 8) = a2 + v5 + 24;
      *(void *)(v8 + 16) = 0x600000000;
      if (*(_DWORD *)(v6 + v5 + 16)) {
        sub_1CB837F14(a2 + v5 + 8, v9 + 8);
      }
      *(_DWORD *)(v8 + 72) = *(_DWORD *)(v9 + 72);
      v5 += 80;
    }
    while (v9 + 80 != v7);
    uint64_t v10 = *((unsigned int *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = 80 * v10;
      do
      {
        uint64_t v13 = *(void **)(v11 + v12 - 72);
        if ((void *)(v11 + v12 - 56) != v13) {
          free(v13);
        }
        v12 -= 80;
      }
      while (v12);
    }
  }
}

uint64_t sub_1CD57912C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(void *)a1;
  if (*(void *)a1 + 80 * *(unsigned int *)(a1 + 8) == a2)
  {
    return sub_1CD5792AC(a1, a3);
  }
  else
  {
    uint64_t v6 = a2 - v4;
    uint64_t v7 = (a2 - v4) >> 4;
    unint64_t v8 = sub_1CD579334(a1, a3);
    uint64_t v9 = *(void *)a1;
    uint64_t v10 = (void *)(*(void *)a1 + v6);
    unsigned int v11 = *(_DWORD *)(a1 + 8);
    uint64_t v12 = (void *)(*(void *)a1 + 80 * v11);
    *uint64_t v12 = *(v12 - 10);
    v12[1] = v12 + 3;
    v12[2] = 0x600000000;
    if (*((_DWORD *)v12 - 16)) {
      sub_1CB837F14((uint64_t)(v12 + 1), (uint64_t)(v12 - 9));
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * v7;
    *(_DWORD *)(v9 + 80 * v11 + 72) = *((_DWORD *)v12 - 2);
    uint64_t v14 = *(void *)a1;
    unsigned int v15 = *(_DWORD *)(a1 + 8);
    uint64_t v16 = *(void *)a1 + 80 * v15 - 80;
    if ((void *)v16 != v10)
    {
      uint64_t v17 = *(void *)a1 + 80 * v15 - 80;
      do
      {
        uint64_t v18 = *(void *)(v17 - 80);
        v17 -= 80;
        *(void *)uint64_t v16 = v18;
        sub_1CB837F14(v16 + 8, v16 - 72);
        *(_DWORD *)(v16 + 72) = *(_DWORD *)(v16 - 8);
        uint64_t v16 = v17;
      }
      while ((void *)v17 != v10);
      unsigned int v15 = *(_DWORD *)(a1 + 8);
      uint64_t v14 = *(void *)a1;
    }
    unsigned int v19 = v15 + 1;
    *(_DWORD *)(a1 + 8) = v19;
    unint64_t v20 = v14 + 80 * v19;
    BOOL v22 = v8 >= (unint64_t)v10 && v8 < v20;
    unint64_t v23 = v8 + 80 * v22;
    void *v10 = *(void *)v23;
    uint64_t v24 = v9 + 80 * v13;
    uint64_t result = sub_1CBAF13E8(v24 + 8, v23 + 8);
    *(_DWORD *)(v24 + 72) = *(_DWORD *)(v23 + 72);
  }
  return result;
}

uint64_t sub_1CD5792AC(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD579334(a1, a2);
  uint64_t v4 = *(void *)a1;
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = (void *)(*(void *)a1 + 80 * v5);
  *uint64_t v6 = *(void *)v3;
  v6[2] = 0x600000000;
  v6[1] = v6 + 3;
  uint64_t result = (uint64_t)(v6 + 1);
  if (*(_DWORD *)(v3 + 16)) {
    uint64_t result = sub_1CBAF13E8(result, v3 + 8);
  }
  *(_DWORD *)(v4 + 80 * v5 + 72) = *(_DWORD *)(v3 + 72);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

unint64_t sub_1CD579334(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 80 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD5793A0();
    }
    sub_1CD5793A0();
  }
  return a2;
}

void sub_1CD5793A0()
{
}

uint64_t llvm::ScheduleDAG::getNodeDesc(uint64_t a1, uint64_t a2)
{
  if (a2 && (int v2 = *(__int16 *)(a2 + 24), v2 < 0)) {
    return *(void *)(*(void *)(a1 + 16) + 8) + 48 * (unsigned __int16)~(_WORD)v2;
  }
  else {
    return 0;
  }
}

void llvm::SDep::dump(llvm::SDep *this, const llvm::TargetRegisterInfo *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = off_1E6830558[(*(void *)this >> 1) & 3];
  unsigned int v5 = llvm::dbgs(this);
  uint64_t v6 = sub_1CB8E509C(v5, v4);
  int v7 = (*(_DWORD *)this >> 1) & 3;
  if ((v7 - 1) >= 2)
  {
    if (v7 == 3)
    {
      unsigned int v11 = llvm::dbgs(v6);
      uint64_t v12 = sub_1CB8E509C(v11, " Latency=");
      unint64_t v13 = llvm::raw_ostream::operator<<(v12, *((unsigned int *)this + 3));
      switch(*((_DWORD *)this + 2))
      {
        case 0:
          uint64_t v14 = llvm::dbgs(v13);
          unsigned int v15 = " Barrier";
          goto LABEL_8;
        case 1:
        case 2:
          uint64_t v14 = llvm::dbgs(v13);
          unsigned int v15 = " Memory";
          goto LABEL_8;
        case 3:
          uint64_t v14 = llvm::dbgs(v13);
          unsigned int v15 = " Artificial";
          goto LABEL_8;
        case 4:
          uint64_t v14 = llvm::dbgs(v13);
          unsigned int v15 = " Weak";
          goto LABEL_8;
        case 5:
          uint64_t v14 = llvm::dbgs(v13);
          unsigned int v15 = " Cluster";
LABEL_8:
          sub_1CB8E509C(v14, v15);
          break;
        default:
          return;
      }
    }
    else
    {
      uint64_t v16 = llvm::dbgs(v6);
      uint64_t v17 = sub_1CB8E509C(v16, " Latency=");
      uint64_t v18 = llvm::raw_ostream::operator<<(v17, *((unsigned int *)this + 3));
      if (a2 && (*(unsigned char *)this & 6) == 0 && *((_DWORD *)this + 2))
      {
        unsigned int v19 = llvm::dbgs(v18);
        unint64_t v20 = sub_1CB8E509C(v19, " Reg=");
        llvm::printReg(*((_DWORD *)this + 2), (uint64_t)a2, 0, 0, (uint64_t)v23);
        if (v24)
        {
          (*(void (**)(void *, llvm::raw_ostream *))(*v24 + 48))(v24, v20);
          if (v24 == v23)
          {
            (*(void (**)(void *))(v23[0] + 32))(v23);
          }
          else if (v24)
          {
            (*(void (**)(void))(*v24 + 40))();
          }
        }
        else
        {
          sub_1CB920400();
          llvm::SUnit::setDepthToAtLeast(v21, v22);
        }
      }
    }
  }
  else
  {
    unint64_t v8 = llvm::dbgs(v6);
    uint64_t v9 = sub_1CB8E509C(v8, " Latency=");
    unint64_t v10 = *((unsigned int *)this + 3);
    llvm::raw_ostream::operator<<(v9, v10);
  }
}

void llvm::SUnit::setDepthToAtLeast(llvm::SUnit *this, unsigned int a2)
{
  if ((*((unsigned char *)this + 236) & 1) == 0) {
    llvm::SUnit::ComputeDepth(this);
  }
  if (*((_DWORD *)this + 60) < a2)
  {
    llvm::SUnit::setDepthDirty(this);
    *((_DWORD *)this + 60) = a2;
    *((unsigned char *)this + 236) |= 1u;
  }
}

void llvm::SUnit::setHeightToAtLeast(llvm::SUnit *this, unsigned int a2)
{
  if ((*((unsigned char *)this + 236) & 2) == 0) {
    llvm::SUnit::ComputeHeight(this);
  }
  if (*((_DWORD *)this + 61) < a2)
  {
    llvm::SUnit::setHeightDirty(this);
    *((_DWORD *)this + 61) = a2;
    *((unsigned char *)this + 236) |= 2u;
  }
}

llvm::raw_ostream *llvm::SUnit::dumpAttributes(llvm::SUnit *this)
{
  int v2 = llvm::dbgs(this);
  unint64_t v3 = sub_1CB8E509C(v2, "  # preds left       : ");
  unint64_t v4 = llvm::raw_ostream::operator<<(v3, *((unsigned int *)this + 52));
  unsigned int v5 = sub_1CB8E509C(v4, "\n");
  uint64_t v6 = llvm::dbgs(v5);
  int v7 = sub_1CB8E509C(v6, "  # succs left       : ");
  unint64_t v8 = llvm::raw_ostream::operator<<(v7, *((unsigned int *)this + 53));
  uint64_t v9 = sub_1CB8E509C(v8, "\n");
  if (*((_DWORD *)this + 54))
  {
    unint64_t v10 = llvm::dbgs(v9);
    unsigned int v11 = sub_1CB8E509C(v10, "  # weak preds left  : ");
    uint64_t v12 = llvm::raw_ostream::operator<<(v11, *((unsigned int *)this + 54));
    uint64_t v9 = sub_1CB8E509C(v12, "\n");
  }
  if (*((_DWORD *)this + 55))
  {
    unint64_t v13 = llvm::dbgs(v9);
    uint64_t v14 = sub_1CB8E509C(v13, "  # weak succs left  : ");
    unsigned int v15 = llvm::raw_ostream::operator<<(v14, *((unsigned int *)this + 55));
    uint64_t v9 = sub_1CB8E509C(v15, "\n");
  }
  uint64_t v16 = llvm::dbgs(v9);
  uint64_t v17 = sub_1CB8E509C(v16, "  # rdefs left       : ");
  uint64_t v18 = llvm::raw_ostream::operator<<(v17, *((unsigned __int16 *)this + 112));
  unsigned int v19 = sub_1CB8E509C(v18, "\n");
  unint64_t v20 = llvm::dbgs(v19);
  BOOL v21 = sub_1CB8E509C(v20, "  Latency            : ");
  unsigned int v22 = llvm::raw_ostream::operator<<(v21, *((unsigned __int16 *)this + 113));
  unint64_t v23 = sub_1CB8E509C(v22, "\n");
  uint64_t v24 = llvm::dbgs(v23);
  uint64_t v25 = sub_1CB8E509C(v24, "  Depth              : ");
  if ((*((unsigned char *)this + 236) & 1) == 0) {
    llvm::SUnit::ComputeDepth(this);
  }
  unint64_t v26 = llvm::raw_ostream::operator<<(v25, *((unsigned int *)this + 60));
  uint64_t v27 = sub_1CB8E509C(v26, "\n");
  uint64_t v28 = llvm::dbgs(v27);
  unint64_t v29 = sub_1CB8E509C(v28, "  Height             : ");
  if ((*((unsigned char *)this + 236) & 2) == 0) {
    llvm::SUnit::ComputeHeight(this);
  }
  char v30 = llvm::raw_ostream::operator<<(v29, *((unsigned int *)this + 61));

  return sub_1CB8E509C(v30, "\n");
}

llvm::raw_ostream *llvm::ScheduleDAG::dumpNodeName(llvm::ScheduleDAG *this, const llvm::SUnit *a2)
{
  if ((llvm::ScheduleDAG *)((char *)this + 72) == a2)
  {
    unint64_t v4 = llvm::dbgs(this);
    int v7 = "EntrySU";
  }
  else
  {
    unint64_t v3 = (llvm::ScheduleDAG *)((char *)this + 344);
    unint64_t v4 = llvm::dbgs(this);
    if (v3 == a2)
    {
      int v7 = "ExitSU";
    }
    else
    {
      unsigned int v5 = sub_1CB8E509C(v4, "SU(");
      uint64_t v6 = llvm::raw_ostream::operator<<(v5, *((unsigned int *)a2 + 48));
      unint64_t v4 = llvm::dbgs(v6);
      int v7 = ")";
    }
  }

  return sub_1CB8E509C(v4, v7);
}

llvm::raw_ostream *llvm::ScheduleDAG::dumpNodeAll(const llvm::TargetRegisterInfo **this, llvm::SDep **a2)
{
  (*((void (**)(const llvm::TargetRegisterInfo **))*this + 4))(this);
  uint64_t result = llvm::SUnit::dumpAttributes((llvm::SUnit *)a2);
  if (*((_DWORD *)a2 + 10))
  {
    unsigned int v5 = llvm::dbgs(result);
    uint64_t result = sub_1CB8E509C(v5, "  Predecessors:\n");
    uint64_t v6 = *((unsigned int *)a2 + 10);
    if (v6)
    {
      int v7 = a2[4];
      uint64_t v8 = 16 * v6;
      do
      {
        uint64_t v9 = llvm::dbgs(result);
        sub_1CB8E509C(v9, "    ");
        unint64_t v10 = llvm::ScheduleDAG::dumpNodeName((llvm::ScheduleDAG *)this, (const llvm::SUnit *)(*(void *)v7 & 0xFFFFFFFFFFFFFFF8));
        unsigned int v11 = llvm::dbgs(v10);
        sub_1CB8E509C(v11, ": ");
        llvm::SDep::dump(v7, this[3]);
        uint64_t result = llvm::dbgs(v12);
        unint64_t v13 = (unsigned char *)*((void *)result + 4);
        if ((unint64_t)v13 >= *((void *)result + 3))
        {
          uint64_t result = llvm::raw_ostream::write(result, 10);
        }
        else
        {
          *((void *)result + 4) = v13 + 1;
          *unint64_t v13 = 10;
        }
        int v7 = (llvm::SDep *)((char *)v7 + 16);
        v8 -= 16;
      }
      while (v8);
    }
  }
  if (*((_DWORD *)a2 + 30))
  {
    uint64_t v14 = llvm::dbgs(result);
    uint64_t result = sub_1CB8E509C(v14, "  Successors:\n");
    uint64_t v15 = *((unsigned int *)a2 + 30);
    if (v15)
    {
      uint64_t v16 = a2[14];
      uint64_t v17 = 16 * v15;
      do
      {
        uint64_t v18 = llvm::dbgs(result);
        sub_1CB8E509C(v18, "    ");
        unsigned int v19 = llvm::ScheduleDAG::dumpNodeName((llvm::ScheduleDAG *)this, (const llvm::SUnit *)(*(void *)v16 & 0xFFFFFFFFFFFFFFF8));
        unint64_t v20 = llvm::dbgs(v19);
        sub_1CB8E509C(v20, ": ");
        llvm::SDep::dump(v16, this[3]);
        uint64_t result = llvm::dbgs(v21);
        unsigned int v22 = (unsigned char *)*((void *)result + 4);
        if ((unint64_t)v22 >= *((void *)result + 3))
        {
          uint64_t result = llvm::raw_ostream::write(result, 10);
        }
        else
        {
          *((void *)result + 4) = v22 + 1;
          *unsigned int v22 = 10;
        }
        uint64_t v16 = (llvm::SDep *)((char *)v16 + 16);
        v17 -= 16;
      }
      while (v17);
    }
  }
  return result;
}

void llvm::ScheduleDAGTopologicalSort::AddPred(llvm::ScheduleDAGTopologicalSort *this, llvm::SUnit *a2, llvm::SUnit *a3)
{
  uint64_t v3 = *((void *)this + 40);
  int v4 = *(_DWORD *)(v3 + 4 * *((unsigned int *)a2 + 48));
  int v5 = *(_DWORD *)(v3 + 4 * *((unsigned int *)a3 + 48));
  if (v4 < v5)
  {
    uint64_t v8 = (void **)((char *)this + 344);
    uint64_t v9 = *((unsigned int *)this + 88);
    if (v9) {
      bzero(*v8, 8 * v9);
    }
    llvm::ScheduleDAGTopologicalSort::DFS(this, (unint64_t)a2, v5, &v10);
    llvm::ScheduleDAGTopologicalSort::Shift((uint64_t)this, v8, v4, v5);
  }
}

void llvm::ScheduleDAGTopologicalSort::Shift(uint64_t a1, void *a2, int a3, int a4)
{
  __p = 0;
  unsigned int v22 = 0;
  unint64_t v23 = 0;
  if (a3 <= a4)
  {
    int v5 = a3;
    uint64_t v8 = 0;
    int v9 = 0;
    int v10 = a4 + 1;
    uint64_t v11 = 4 * a3;
    do
    {
      uint64_t v12 = *(void *)(a1 + 296);
      unint64_t v13 = *(unsigned int *)(v12 + v11);
      uint64_t v14 = *(void *)(*a2 + 8 * (v13 >> 6));
      if (((1 << v13) & v14) != 0)
      {
        *(void *)(*a2 + 8 * (v13 >> 6)) = v14 & ~(1 << v13);
        if ((unint64_t)v8 >= v23)
        {
          uint64_t v8 = sub_1CC463D78((char **)&__p, v13);
        }
        else
        {
          *(_DWORD *)uint64_t v8 = v13;
          v8 += 4;
        }
        unsigned int v22 = v8;
        ++v9;
      }
      else
      {
        *(_DWORD *)(*(void *)(a1 + 320) + 4 * (int)v13) = v5 - v9;
        *(_DWORD *)(v12 + 4 * (v5 - v9)) = v13;
      }
      ++v5;
      v11 += 4;
    }
    while (v10 != v5);
    uint64_t v15 = __p;
    if (__p != v8)
    {
      uint64_t v16 = *(void *)(a1 + 320);
      uint64_t v17 = (_DWORD *)(*(void *)(a1 + 296) + 4 * v10 - 4 * v9);
      int v18 = a4 - v9 + 1;
      unsigned int v19 = (char *)__p;
      do
      {
        uint64_t v20 = *(int *)v19;
        v19 += 4;
        *(_DWORD *)(v16 + 4 * v20) = v18;
        *v17++ = v20;
        ++v18;
      }
      while (v19 != v8);
    }
    if (v15)
    {
      operator delete(v15);
    }
  }
}

uint64_t llvm::ScheduleDAGTopologicalSort::AddSUnitWithoutPredecessors(llvm::ScheduleDAGTopologicalSort *this, const llvm::SUnit *a2)
{
  int v4 = (_DWORD *)*((void *)this + 38);
  unint64_t v5 = ((unint64_t)v4 - *((void *)this + 37)) >> 2;
  int v12 = v5;
  uint64_t v6 = (_DWORD *)*((void *)this + 41);
  if ((unint64_t)v6 >= *((void *)this + 42))
  {
    int v7 = sub_1CBFFBD60((char **)this + 40, &v12);
    int v4 = (_DWORD *)*((void *)this + 38);
  }
  else
  {
    *uint64_t v6 = v5;
    int v7 = (char *)(v6 + 1);
  }
  *((void *)this + 41) = v7;
  int v8 = *((_DWORD *)a2 + 48);
  int v11 = v8;
  if ((unint64_t)v4 >= *((void *)this + 39))
  {
    int v9 = sub_1CBFFBD60((char **)this + 37, &v11);
    int v7 = (char *)*((void *)this + 41);
  }
  else
  {
    *int v4 = v8;
    int v9 = (char *)(v4 + 1);
  }
  *((void *)this + 38) = v9;
  return sub_1CB8F8DF4((uint64_t)this + 344, (unint64_t)&v7[-*((void *)this + 40)] >> 2, 0);
}

void llvm::ScheduleHazardRecognizer::~ScheduleHazardRecognizer(llvm::ScheduleHazardRecognizer *this)
{
}

uint64_t sub_1CD579EB4()
{
  return 0;
}

uint64_t sub_1CD579EBC()
{
  return 0;
}

uint64_t sub_1CD579ED0()
{
  return 0;
}

uint64_t sub_1CD579ED8()
{
  return 0;
}

uint64_t sub_1CD579EE0()
{
  return 0;
}

uint64_t sub_1CD579EF0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 80))();
}

void *llvm::ScheduleDAGInstrs::insertBarrierChain(uint64_t a1, int32x2_t *a2)
{
  int32x2_t v4 = a2[3];
  int32x2_t v5 = a2[4];
  uint64_t v3 = a2 + 3;
  if (*(void *)&v4 == *(void *)&v5)
  {
    uint64_t v6 = (uint64_t *)a2[3];
  }
  else
  {
    do
    {
      int v12 = (uint64_t *)(*(void *)&v4 + 8);
      for (unint64_t i = *(uint64_t **)(*(void *)&v4 + 16); i != v12; unint64_t i = (uint64_t *)i[1])
      {
        uint64_t v14 = i[2];
        uint64_t v15 = *(void *)(a1 + 2104);
        if (*(_DWORD *)(v14 + 192) <= *(_DWORD *)(v15 + 192))
        {
          if (v14 == v15) {
            int v12 = (uint64_t *)i[1];
          }
          else {
            int v12 = i;
          }
          break;
        }
        sub_1CC466058(v14, v15);
      }
      uint64_t v16 = *(uint64_t **)(*(void *)&v4 + 16);
      if (v12 != v16)
      {
        uint64_t v17 = *v12;
        uint64_t v18 = *v16;
        *(void *)(v18 + 8) = *(void *)(*v12 + 8);
        **(void **)(v17 + 8) = v18;
        do
        {
          unsigned int v19 = (uint64_t *)v16[1];
          --*(void *)(*(void *)&v4 + 24);
          operator delete(v16);
          uint64_t v16 = v19;
        }
        while (v19 != v12);
      }
      *(void *)&v4 += 32;
    }
    while (*(void *)&v4 != *(void *)&v5);
    uint64_t v6 = (uint64_t *)a2[3];
    uint64_t v20 = (uint64_t *)a2[4];
    if (v6 == v20)
    {
      int32x2_t v4 = a2[3];
    }
    else
    {
      BOOL v21 = (uint64_t *)a2[3];
      do
      {
        if (v21[3])
        {
          if (v21 != v6)
          {
            *uint64_t v6 = *v21;
            sub_1CD57AEC0(v6 + 1, v21 + 1);
            unint64_t v22 = ((unint64_t)v6 - *(void *)&a2[3]) >> 5;
            *((_DWORD *)sub_1CD57AF70((uint64_t)a2, v6) + 2) = v22;
          }
          v6 += 4;
        }
        else
        {
          sub_1CD57ADB4(a2, *v21);
        }
        v21 += 4;
      }
      while (v21 != v20);
      int32x2_t v4 = a2[4];
    }
  }
  uint64_t result = sub_1CD57AE30(v3, (char *)v6, *(char **)&v4);
  a2[6].i32[0] = 0;
  int32x2_t v8 = a2[3];
  int32x2_t v9 = a2[4];
  if (*(void *)&v8 != *(void *)&v9)
  {
    __int32 v10 = 0;
    do
    {
      v10 += *(_DWORD *)(*(void *)&v8 + 24);
      *(void *)&v8 += 32;
    }
    while (*(void *)&v8 != *(void *)&v9);
    a2[6].i32[0] = v10;
  }
  return result;
}

void llvm::ScheduleDAGInstrs::reduceHugeMemNodeMaps(uint64_t a1, int32x2_t *a2, int32x2_t *a3, int a4)
{
  __p = 0;
  unint64_t v23 = 0;
  unint64_t v24 = 0;
  sub_1CC34AE58((uint64_t)&__p, (a3[6].i32[0] + a2[6].i32[0]));
  int32x2_t v8 = a2[3];
  int32x2_t v9 = a2[4];
  while (*(void *)&v8 != *(void *)&v9)
  {
    uint64_t v10 = *(void *)(*(void *)&v8 + 16);
    if (v10 != *(void *)&v8 + 8)
    {
      int v11 = v23;
      do
      {
        int v12 = (_DWORD *)(*(void *)(v10 + 16) + 192);
        if ((unint64_t)v11 >= v24)
        {
          int v11 = sub_1CBFFBD60((char **)&__p, v12);
        }
        else
        {
          *(_DWORD *)int v11 = *v12;
          v11 += 4;
        }
        unint64_t v23 = v11;
        uint64_t v10 = *(void *)(v10 + 8);
      }
      while (v10 != *(void *)&v8 + 8);
    }
    *(void *)&v8 += 32;
  }
  int32x2_t v13 = a3[3];
  int32x2_t v14 = a3[4];
  while (*(void *)&v13 != *(void *)&v14)
  {
    uint64_t v15 = *(void *)(*(void *)&v13 + 16);
    if (v15 != *(void *)&v13 + 8)
    {
      uint64_t v16 = v23;
      do
      {
        uint64_t v17 = (_DWORD *)(*(void *)(v15 + 16) + 192);
        if ((unint64_t)v16 >= v24)
        {
          uint64_t v16 = sub_1CBFFBD60((char **)&__p, v17);
        }
        else
        {
          *(_DWORD *)uint64_t v16 = *v17;
          v16 += 4;
        }
        unint64_t v23 = v16;
        uint64_t v15 = *(void *)(v15 + 8);
      }
      while (v15 != *(void *)&v13 + 8);
    }
    *(void *)&v13 += 32;
  }
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>();
  unsigned int v18 = *(_DWORD *)&v23[-4 * a4];
  uint64_t v19 = *(void *)(a1 + 48);
  uint64_t v20 = v19 + 272 * v18;
  uint64_t v21 = *(void *)(a1 + 2104);
  if (!v21) {
    goto LABEL_20;
  }
  if (*(_DWORD *)(v19 + 272 * v18 + 192) < *(_DWORD *)(v21 + 192))
  {
    sub_1CC466058(v21, v20);
LABEL_20:
    *(void *)(a1 + 2104) = v20;
  }
  llvm::ScheduleDAGInstrs::insertBarrierChain(a1, a2);
  llvm::ScheduleDAGInstrs::insertBarrierChain(a1, a3);
  if (__p)
  {
    unint64_t v23 = (char *)__p;
    operator delete(__p);
  }
}

uint64_t llvm::ScheduleDAGInstrs::fixupKills(llvm::ScheduleDAGInstrs *this, const llvm::MachineFunction **a2)
{
  int32x2_t v4 = (llvm::ScheduleDAGInstrs *)((char *)this + 2568);
  uint64_t v5 = *((void *)this + 3);
  *((void *)this + 321) = v5;
  *((void *)this + 323) = 0;
  sub_1CD50BAB8((char *)this + 2576, *(_DWORD *)(v5 + 16));
  uint64_t result = (uint64_t)llvm::LivePhysRegs::addLiveOuts(v4, a2);
  unint64_t v8 = (unint64_t)a2[6];
  int v7 = (char *)(a2 + 6);
  unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFF8;
  if ((v8 & 0xFFFFFFFFFFFFFFF8) == 0 || (*(unsigned char *)v9 & 4) == 0)
  {
    while ((*(_WORD *)(v9 + 44) & 4) != 0)
      unint64_t v9 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
  }
  while ((char *)v9 != v7)
  {
    int v10 = **(unsigned __int16 **)(v9 + 16);
    if ((v10 - 13) >= 5 && v10 != 23)
    {
      uint64_t result = (uint64_t)sub_1CC301138(&v20, v9);
      int v12 = v22;
      if (v22 != v23)
      {
        do
        {
          if (*v12 == 12)
          {
            uint64_t result = (uint64_t)llvm::LivePhysRegs::removeRegsInMask(v4, (unint64_t)v12, 0);
          }
          else if (!*v12 && (*v12 & 0x1000000) != 0 && v12[1])
          {
            uint64_t result = sub_1CD51C088((uint64_t *)v4, (unsigned __int16)v12[1]);
          }
          int32x2_t v13 = v23;
          int32x2_t v14 = v22 + 8;
          unint64_t v22 = v14;
          if (v14 == v23)
          {
            uint64_t v15 = *(void *)(v20 + 8);
            if (v15 == v21)
            {
              int v12 = v14;
            }
            else
            {
              int v12 = v14;
              if ((*(_WORD *)(v15 + 44) & 4) != 0)
              {
                while (1)
                {
                  int v12 = *(_DWORD **)(v15 + 32);
                  uint64_t v16 = *(unsigned int *)(v15 + 40);
                  int32x2_t v13 = &v12[8 * v16];
                  if (v16) {
                    break;
                  }
                  uint64_t v15 = *(void *)(v15 + 8);
                  if (v15 == v21 || (*(_WORD *)(v15 + 44) & 4) == 0)
                  {
                    unint64_t v22 = v12;
                    unint64_t v23 = &v12[8 * v16];
                    int32x2_t v14 = v23;
                    goto LABEL_36;
                  }
                }
                unint64_t v22 = *(_DWORD **)(v15 + 32);
                unint64_t v23 = &v12[8 * v16];
                uint64_t v20 = v15;
                continue;
              }
            }
LABEL_36:
            uint64_t v20 = v21;
            int32x2_t v13 = v14;
          }
          else
          {
            int v12 = v14;
          }
        }
        while (v12 != v13);
      }
      if ((*(_WORD *)(v9 + 44) & 0xC) != 0)
      {
        if (**(_WORD **)(v9 + 16) == 20) {
          uint64_t result = (uint64_t)sub_1CC468870(*((const llvm::MachineRegisterInfo **)this + 5), v4, *(unsigned int **)(v9 + 32), *(_DWORD *)(v9 + 40), 0);
        }
        for (unint64_t i = *(void *)(v9 + 8); (*(_WORD *)(i + 44) & 8) != 0; unint64_t i = *(void *)(i + 8))
          ;
        do
        {
          int v18 = **(unsigned __int16 **)(i + 16);
          if ((v18 - 13) >= 5 && v18 != 23) {
            uint64_t result = (uint64_t)sub_1CC468870(*((const llvm::MachineRegisterInfo **)this + 5), v4, *(unsigned int **)(i + 32), *(_DWORD *)(i + 40), 1);
          }
          unint64_t i = *(void *)i & 0xFFFFFFFFFFFFFFF8;
        }
        while (v9 != i);
      }
      else
      {
        uint64_t result = (uint64_t)sub_1CC468870(*((const llvm::MachineRegisterInfo **)this + 5), v4, *(unsigned int **)(v9 + 32), *(_DWORD *)(v9 + 40), 1);
      }
    }
    unint64_t v9 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
    if (!v9 || (*(unsigned char *)v9 & 4) == 0)
    {
      while ((*(_WORD *)(v9 + 44) & 4) != 0)
        unint64_t v9 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
    }
  }
  return result;
}

void llvm::ScheduleDAGInstrs::dumpNode(llvm::ScheduleDAGInstrs *this, llvm::MachineInstr **a2)
{
  uint64_t v3 = llvm::ScheduleDAG::dumpNodeName(this, (const llvm::SUnit *)a2);
  int32x2_t v4 = llvm::dbgs(v3);
  sub_1CB8E509C(v4, ": ");
  uint64_t v5 = a2[1];

  llvm::MachineInstr::dump(v5);
}

llvm::raw_ostream *llvm::ScheduleDAGInstrs::dump(llvm::raw_ostream *this)
{
  uint64_t v1 = (uint64_t)this;
  if (*((void *)this + 10)) {
    this = llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)this, (llvm::SDep **)this + 9);
  }
  int v2 = *(llvm::SDep ***)(v1 + 48);
  uint64_t v3 = *(llvm::SDep ***)(v1 + 56);
  while (v2 != v3)
  {
    this = llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)v1, v2);
    v2 += 34;
  }
  if (*(void *)(v1 + 352))
  {
    return llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)v1, (llvm::SDep **)(v1 + 344));
  }
  return this;
}

void llvm::ScheduleDAGInstrs::getGraphNodeLabel(llvm::ScheduleDAGInstrs *this@<X0>, llvm::MachineInstr **a2@<X1>, uint64_t a3@<X8>)
{
  v15[0] = 0;
  v15[1] = 0;
  uint64_t v16 = 0;
  int v7 = 0;
  char v11 = 0;
  uint64_t v12 = 0;
  int32x2_t v14 = v15;
  int v13 = 0;
  uint64_t v6 = &unk_1F2646F30;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if ((llvm::MachineInstr **)((char *)this + 72) == a2)
  {
    int32x2_t v4 = "<entry>";
  }
  else
  {
    if ((llvm::MachineInstr **)((char *)this + 344) != a2)
    {
      llvm::MachineInstr::print(a2[1], (llvm::raw_ostream *)&v6, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
      goto LABEL_6;
    }
    int32x2_t v4 = "<exit>";
  }
  sub_1CB8E509C((llvm::raw_ostream *)&v6, v4);
LABEL_6:
  if (*((char *)v14 + 23) < 0)
  {
    sub_1CB8BDF7C(a3, *v14, (unint64_t)v14[1]);
  }
  else
  {
    long long v5 = *(_OWORD *)v14;
    *(void *)(a3 + 16) = v14[2];
    *(_OWORD *)a3 = v5;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v6);
  if (SHIBYTE(v16) < 0) {
    operator delete(v15[0]);
  }
}

void llvm::ScheduleDAGInstrs::getDAGName(llvm::MachineBasicBlock **this@<X0>, std::string *a2@<X8>)
{
  llvm::MachineBasicBlock::getFullName(this[115], &v4);
  uint64_t v3 = std::string::insert(&v4, 0, "dag.");
  *a2 = *v3;
  v3->__r_.__value_.__r.__words[0] = 0;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

BOOL llvm::ScheduleDAGInstrs::canAddEdge(llvm::ScheduleDAGInstrs *this, llvm::SUnit *a2, llvm::SUnit *a3)
{
  return (llvm::ScheduleDAGInstrs *)((char *)this + 344) == a2
      || !llvm::ScheduleDAGTopologicalSort::IsReachable((llvm::ScheduleDAGInstrs *)((char *)this + 2120), a3, a2);
}

uint64_t llvm::ScheduleDAGInstrs::addEdge(uint64_t a1, llvm::SUnit *a2, uint64_t a3)
{
  if ((llvm::SUnit *)(a1 + 344) != a2)
  {
    uint64_t v5 = a1 + 2120;
    if (llvm::ScheduleDAGTopologicalSort::IsReachable((llvm::ScheduleDAGTopologicalSort *)(a1 + 2120), (const llvm::SUnit *)(*(void *)a3 & 0xFFFFFFFFFFFFFFF8), a2))
    {
      return 0;
    }
    llvm::ScheduleDAGTopologicalSort::AddPredQueued(v5, a2, (llvm::SUnit *)(*(void *)a3 & 0xFFFFFFFFFFFFFFF8));
  }
  char v8 = (~*(_DWORD *)a3 & 6) != 0 || *(_DWORD *)(a3 + 8) != 3;
  llvm::SUnit::addPred((uint64_t)a2, (uint64_t *)a3, v8);
  return 1;
}

llvm::raw_ostream *llvm::ILPValue::print(llvm::ILPValue *this, llvm::raw_ostream *a2)
{
  sub_1CD098D14(a2, *(unsigned int *)this, 0, 0, 0);
  std::string v4 = sub_1CB8E509C(a2, " / ");
  sub_1CD098D14(v4, *((unsigned int *)this + 1), 0, 0, 0);
  sub_1CB8E509C(v4, " = ");
  unsigned int v6 = *((_DWORD *)this + 1);
  if (v6)
  {
    LODWORD(v5) = *(_DWORD *)this;
    v8[0] = &unk_1F25F6490;
    v8[1] = "%g";
    *(double *)&v8[2] = (double)v5 / (double)v6;
    return llvm::raw_ostream::operator<<(a2, (uint64_t)v8);
  }
  else
  {
    return sub_1CB8E509C(a2, "BADILP");
  }
}

llvm::raw_ostream *llvm::ILPValue::dump(llvm::ILPValue *this)
{
  int v2 = llvm::dbgs(this);
  uint64_t result = llvm::operator<<(v2, this);
  std::string v4 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v4 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v4 + 1;
    *std::string v4 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, llvm::ILPValue *this)
{
  return a1;
}

uint64_t sub_1CD57A99C(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = a1 + 48;
  unint64_t v5 = (void *)(a1 + 32);
  *(void *)(a1 + 40) = 0x400000000;
  if (*(_DWORD *)(a2 + 40)) {
    sub_1CC469A68(v5, a2 + 32);
  }
  *(void *)(a1 + 112) = a1 + 128;
  *(void *)(a1 + 120) = 0x400000000;
  if (*(_DWORD *)(a2 + 120)) {
    sub_1CC469A68((void *)(a1 + 112), a2 + 112);
  }
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 192);
  long long v6 = *(_OWORD *)(a2 + 208);
  long long v7 = *(_OWORD *)(a2 + 224);
  long long v8 = *(_OWORD *)(a2 + 256);
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 256) = v8;
  *(_OWORD *)(a1 + 208) = v6;
  *(_OWORD *)(a1 + 224) = v7;
  return a1;
}

uint64_t sub_1CD57AA30(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    long long v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *long long v4 = -4096;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v6 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & (37 * v6);
      uint64_t v9 = *(void *)result + 16 * v8;
      uint64_t v10 = *(void *)v9;
      if (v6 != *(void *)v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -4096)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -8192;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          uint64_t v9 = *(void *)result + 16 * (v14 & v7);
          uint64_t v10 = *(void *)v9;
          if (v6 == *(void *)v9) {
            goto LABEL_9;
          }
        }
        if (v11) {
          uint64_t v9 = v11;
        }
      }
LABEL_9:
      *(void *)uint64_t v9 = v6;
      *(_DWORD *)(v9 + 8) = *((_DWORD *)a2 + 2);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

void sub_1CD57AB10(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD3780, 0, 0);
  byte_1EBCD3800 = 0;
  qword_1EBCD3808 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD3810 = 0;
  qword_1EBCD3780 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD3818 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD3820 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD3838 = (uint64_t)&qword_1EBCD3820;
  sub_1CD57AC10(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD3780);
}

__n128 sub_1CD57AC10(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD3780, "enable-aa-sched-mi", 0x12uLL);
  word_1EBCD378A = word_1EBCD378A & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCD378A = word_1EBCD378A & 0xFFF8 | *a2 & 7;
  unsigned int v8 = *a3;
  byte_1EBCD3800 = **a3;
  byte_1EBCD3811 = 1;
  byte_1EBCD3810 = *v8;
  __n128 result = *a4;
  xmmword_1EBCD37A0 = (__int128)*a4;
  return result;
}

void sub_1CD57ACA8(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD39C0, 0, 0);
  dword_1EBCD3A40 = 0;
  qword_1EBCD3A48 = (uint64_t)&unk_1F25EA1B0;
  unk_1EBCD3A50 = 0;
  qword_1EBCD39C0 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD3A58 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD3A60 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD3A78 = (uint64_t)&qword_1EBCD3A60;
  llvm::cl::Option::setArgStr(v4, "dag-maps-reduction-size", 0x17uLL);
  word_1EBCD39CA = (32 * (*a1 & 3)) | word_1EBCD39CA & 0xFF9F;
  xmmword_1EBCD39E0 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD39C0);
}

int32x2_t *sub_1CD57ADB4(int32x2_t *result, uint64_t a2)
{
  __int32 v2 = result[2].i32[0];
  if (v2)
  {
    int32x2_t v3 = *result;
    __int32 v4 = v2 - 1;
    LODWORD(v5) = (v2 - 1) & (37 * a2);
    uint64_t v6 = (uint64_t *)(*(void *)result + 16 * v5);
    uint64_t v7 = *v6;
    if (a2 == *v6)
    {
LABEL_3:
      *uint64_t v6 = -8192;
      result[1] = vadd_s32(result[1], (int32x2_t)0x1FFFFFFFFLL);
    }
    else
    {
      int v8 = 1;
      while (v7 != -4096)
      {
        int v9 = v5 + v8++;
        uint64_t v5 = v9 & v4;
        uint64_t v7 = *(void *)(*(void *)&v3 + 16 * v5);
        if (a2 == v7)
        {
          uint64_t v6 = (uint64_t *)(*(void *)&v3 + 16 * v5);
          goto LABEL_3;
        }
      }
    }
  }
  return result;
}

void *sub_1CD57AE30(void *result, char *a2, char *a3)
{
  if (a2 != a3)
  {
    __int32 v4 = a2;
    uint64_t v5 = result;
    uint64_t v6 = (char *)result[1];
    if (a3 != v6)
    {
      uint64_t v7 = 32 * ((a3 - a2) >> 5);
      do
      {
        *(void *)__int32 v4 = *(void *)&v4[v7];
        sub_1CD57AEC0((void *)v4 + 1, &v4[v7 + 8]);
        v4 += 32;
      }
      while (&v4[v7] != v6);
    }
    return sub_1CC469BDC(v5, (uint64_t)v4);
  }
  return result;
}

void *sub_1CD57AEC0(void *result, void *a2)
{
  uint64_t v3 = result;
  if (result[2])
  {
    uint64_t v4 = *result;
    __n128 result = (void *)result[1];
    uint64_t v5 = *result;
    *(void *)(v5 + 8) = *(void *)(*v3 + 8);
    **(void **)(v4 + 8) = v5;
    v3[2] = 0;
    if (result != v3)
    {
      do
      {
        uint64_t v6 = (void *)result[1];
        operator delete(result);
        __n128 result = v6;
      }
      while (v6 != v3);
    }
  }
  uint64_t v7 = a2[2];
  if (v7)
  {
    uint64_t v9 = *a2;
    int v8 = (uint64_t *)a2[1];
    uint64_t v10 = *v8;
    *(void *)(v10 + 8) = *(void *)(*a2 + 8);
    **(void **)(v9 + 8) = v10;
    uint64_t v11 = *v3;
    *(void *)(v11 + 8) = v8;
    *int v8 = v11;
    *uint64_t v3 = v9;
    *(void *)(v9 + 8) = v3;
    v3[2] += v7;
    a2[2] = 0;
  }
  return result;
}

void *sub_1CD57AF70(uint64_t a1, void *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CC469FEC(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((_DWORD *)v6 + 2) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -8192;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (void *)(*(void *)a1 + 16 * (v13 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

llvm::raw_ostream *llvm::ScheduleDAG::viewGraph(llvm *a1)
{
  uint64_t v1 = (llvm::raw_ostream *)llvm::errs(a1);
  __int32 v2 = sub_1CB8E509C(v1, "ScheduleDAG::viewGraph is only available in debug builds on ");

  return sub_1CB8E509C(v2, "systems with Graphviz or gv!\n");
}

void llvm::ScheduleDAG::viewGraph(llvm::ScheduleDAG *this)
{
  (*(void (**)(void **__return_ptr))(*(void *)this + 56))(v9);
  __int16 v12 = 260;
  int v11 = v9;
  (*(void (**)(std::string *__return_ptr, llvm::ScheduleDAG *))(*(void *)this + 56))(&v4, this);
  __int32 v2 = std::string::insert(&v4, 0, "Scheduling-Units Graph for ");
  std::string::size_type v3 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  std::string::size_type v6 = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  __int16 v8 = 260;
  uint64_t v7 = __p;
  (*(void (**)(llvm::ScheduleDAG *, void ***, void ***))(*(void *)this + 16))(this, &v11, &v7);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
  if (v10 < 0) {
    operator delete(v9[0]);
  }
}

void llvm::ScoreboardHazardRecognizer::Reset(llvm::ScoreboardHazardRecognizer *this)
{
  *((_DWORD *)this + 11) = 0;
  __int32 v2 = (void *)*((void *)this + 9);
  if (!v2)
  {
    *((void *)this + 10) = 1;
    operator new[]();
  }
  bzero(v2, 8 * *((void *)this + 10));
  *((void *)this + 11) = 0;
  std::string::size_type v3 = (void *)*((void *)this + 6);
  if (!v3)
  {
    *((void *)this + 7) = 1;
    operator new[]();
  }
  bzero(v3, 8 * *((void *)this + 7));
  *((void *)this + 8) = 0;
}

llvm::raw_ostream *llvm::ScoreboardHazardRecognizer::Scoreboard::dump(llvm::ScoreboardHazardRecognizer::Scoreboard *this)
{
  __int32 v2 = llvm::dbgs(this);
  __n128 result = sub_1CB8E509C(v2, "Scoreboard:\n");
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = v4 - 1;
  unsigned int v6 = v4 - 1;
  do
  {
    unsigned int v7 = v6;
    if (!v6) {
      break;
    }
  }
  while (!*(void *)(*(void *)this + 8 * ((*((void *)this + 2) + v6--) & v5)));
  unsigned int v9 = 0;
  do
  {
    unint64_t v10 = *(void *)(*(void *)this + 8 * ((*((void *)this + 1) - 1) & (*((void *)this + 2) + v9)));
    int v11 = llvm::dbgs(result);
    __int16 v12 = sub_1CB8E509C(v11, "\t");
    for (uint64_t i = 63; i != -1; --i)
    {
      __int16 v12 = llvm::dbgs(v12);
      if ((v10 >> i)) {
        char v14 = 49;
      }
      else {
        char v14 = 48;
      }
      uint64_t v15 = (char *)*((void *)v12 + 4);
      if ((unint64_t)v15 >= *((void *)v12 + 3))
      {
        __int16 v12 = llvm::raw_ostream::write(v12, v14);
      }
      else
      {
        *((void *)v12 + 4) = v15 + 1;
        *uint64_t v15 = v14;
      }
    }
    __n128 result = llvm::dbgs(v12);
    uint64_t v16 = (unsigned char *)*((void *)result + 4);
    if ((unint64_t)v16 >= *((void *)result + 3))
    {
      __n128 result = llvm::raw_ostream::write(result, 10);
    }
    else
    {
      *((void *)result + 4) = v16 + 1;
      *uint64_t v16 = 10;
    }
    ++v9;
  }
  while (v9 <= v7);
  return result;
}

BOOL llvm::ScoreboardHazardRecognizer::atIssueLimit(llvm::ScoreboardHazardRecognizer *this)
{
  int v1 = *((_DWORD *)this + 10);
  return v1 && *((_DWORD *)this + 11) == v1;
}

uint64_t llvm::ScoreboardHazardRecognizer::EmitInstruction(uint64_t result, unsigned __int16 **a2)
{
  uint64_t v2 = *(void *)(result + 24);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 96);
    if (v3)
    {
      uint64_t v4 = a2[1];
      if (v4)
      {
        uint64_t v5 = (unsigned __int16 *)*((void *)v4 + 2);
      }
      else
      {
        uint64_t v5 = *a2;
        if (*a2)
        {
          int v31 = (__int16)v5[12];
          if (v31 < 0) {
            uint64_t v5 = (unsigned __int16 *)(*(void *)(*(void *)(*(void *)(result + 32) + 16) + 8)
          }
                                    + 48 * (unsigned __int16)~(_WORD)v31);
          else {
            uint64_t v5 = 0;
          }
        }
      }
      if (*v5 >= 0x14u)
      {
        ++*(_DWORD *)(result + 44);
        uint64_t v6 = v3 + 10 * v5[3];
        unsigned int v7 = *(unsigned __int16 *)(v6 + 2);
        unsigned int v8 = *(unsigned __int16 *)(v6 + 4);
        if (v7 != v8)
        {
          int v9 = 0;
          uint64_t v10 = *(void *)(v2 + 72);
          int v11 = (unsigned int *)(v10 + 24 * v8);
          __int16 v12 = (unsigned int *)(v10 + 24 * v7);
          unsigned int v13 = (uint64_t *)(result + 48);
          char v14 = (uint64_t *)(result + 64);
          uint64_t v15 = (void *)(result + 56);
          uint64_t v16 = (uint64_t *)(result + 72);
          uint64_t v17 = (uint64_t *)(result + 88);
          int v18 = (void *)(result + 80);
          while (1)
          {
            uint64_t v19 = *v12;
            if (v19) {
              break;
            }
LABEL_26:
            __n128 result = v12[4];
            if ((int)result >= 0) {
              LODWORD(v19) = v12[4];
            }
            v9 += v19;
            v12 += 6;
            if (v12 == v11) {
              return result;
            }
          }
          uint64_t v20 = 0;
          unsigned int v21 = v12[5];
          if (v21) {
            unint64_t v22 = v13;
          }
          else {
            unint64_t v22 = v16;
          }
          if (v21) {
            unint64_t v23 = v14;
          }
          else {
            unint64_t v23 = v17;
          }
          if (v21) {
            unint64_t v24 = v15;
          }
          else {
            unint64_t v24 = v18;
          }
          uint64_t v25 = *v22;
          uint64_t v26 = *v23;
          uint64_t v27 = *v24 - 1;
          while (1)
          {
            uint64_t v28 = *((void *)v12 + 1);
            if (!v21) {
              break;
            }
            if (v21 == 1)
            {
              uint64_t v29 = (v9 + v20);
LABEL_23:
              v28 &= ~*(void *)(*v16 + 8 * ((*v18 - 1) & (*v17 + v29)));
              goto LABEL_24;
            }
            do
            {
LABEL_24:
              uint64_t v30 = v28;
              v28 &= v28 - 1;
            }
            while (v28);
            *(void *)(v25 + 8 * (v27 & (v26 + (v9 + v20++)))) |= v30;
            if (v20 == v19) {
              goto LABEL_26;
            }
          }
          uint64_t v29 = (v9 + v20);
          v28 &= ~*(void *)(*v13 + 8 * ((*v15 - 1) & (*v14 + v29)));
          goto LABEL_23;
        }
      }
    }
  }
  return result;
}

uint64_t llvm::ScoreboardHazardRecognizer::AdvanceCycle(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 56) - 1;
  uint64_t v2 = *(void *)(this + 64);
  uint64_t v3 = *(void *)(this + 72);
  *(void *)(*(void *)(this + 48) + 8 * (v1 & v2)) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(void *)(this + 64) = v1 & (v2 + 1);
  uint64_t v4 = *(void *)(this + 88);
  uint64_t v5 = *(void *)(this + 80) - 1;
  *(void *)(v3 + 8 * (v5 & v4)) = 0;
  *(void *)(this + 88) = v5 & (v4 + 1);
  return this;
}

uint64_t llvm::ScoreboardHazardRecognizer::RecedeCycle(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 56) - 1;
  uint64_t v2 = *(void *)(this + 64);
  uint64_t v3 = *(void *)(this + 72);
  *(void *)(*(void *)(this + 48) + 8 * ((v2 + v1) & v1)) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(void *)(this + 64) = (v2 - 1) & v1;
  uint64_t v4 = *(void *)(this + 88);
  uint64_t v5 = *(void *)(this + 80) - 1;
  *(void *)(v3 + 8 * ((v4 + v5) & v5)) = 0;
  *(void *)(this + 88) = (v4 - 1) & v5;
  return this;
}

void llvm::initializeShadowStackGCLoweringPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3A80, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC46AE1C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD3A80, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeShrinkWrapPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3B48, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC46D2C0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD3B48, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD57B698(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = v20;
  uint64_t v17 = v20;
  uint64_t v18 = 32;
  int v19 = 0;
  if (a2 != a1)
  {
    uint64_t v3 = a2;
    uint64_t v5 = (uint64_t *)(a3 + 248);
    while (2)
    {
      uint64_t v7 = *(void *)(v3 - 8);
      v3 -= 8;
      uint64_t v6 = v7;
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v16, v7);
      unsigned int v8 = *(uint64_t **)(v7 + 88);
      int v9 = *(uint64_t **)(v7 + 96);
      while (v8 != v9)
      {
        uint64_t v10 = *v8;
        int v11 = (char *)sub_1CB896AE8((uint64_t)&v16, *v8);
        if (v17 == v16) {
          __int16 v12 = (uint64_t *)((char *)&v18 + 4);
        }
        else {
          __int16 v12 = &v18;
        }
        if (v11 != &v17[8 * *(unsigned int *)v12])
        {
          uint64_t v21 = 0;
          uint64_t v22 = v6;
          if ((sub_1CB834D78(v5, &v22, &v21) & 1) == 0 || (unsigned int v13 = *(uint64_t ***)(v21 + 8)) == 0)
          {
LABEL_17:
            uint64_t v14 = 1;
            goto LABEL_18;
          }
          while (*v13[4] != v10)
          {
            unsigned int v13 = (uint64_t **)*v13;
            if (!v13) {
              goto LABEL_17;
            }
          }
        }
        ++v8;
      }
      if (v3 != a1) {
        continue;
      }
      break;
    }
  }
  uint64_t v14 = 0;
LABEL_18:
  if (v17 != v16) {
    free(v17);
  }
  return v14;
}

void sub_1CD57B7CC(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD3A88, 0, 0);
  dword_1EBCD3B08 = 0;
  qword_1EBCD3B10 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD3B18 = 0;
  qword_1EBCD3A88 = (uint64_t)&unk_1F2609740;
  qword_1EBCD3B20 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD3B28 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD3B40 = (uint64_t)&qword_1EBCD3B28;
  llvm::cl::Option::setArgStr(v4, "enable-shrink-wrap", 0x12uLL);
  word_1EBCD3A92 = (32 * (*a1 & 3)) | word_1EBCD3A92 & 0xFF9F;
  xmmword_1EBCD3AA8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD3A88);
}

void llvm::initializeSjLjEHPreparePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3B50, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC46F120;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD3B50, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createSjLjEHPreparePass(llvm *this, const llvm::TargetMachine *a2)
{
}

llvm::PointerType *sub_1CD57B9C0(uint64_t a1, unsigned __int8 *a2, const char *a3, uint64_t a4, uint64_t **a5, uint64_t a6)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  v12[0] = a6;
  uint64_t v10 = (llvm::PointerType *)llvm::FunctionType::get(a5, (uint64_t)v12, 1, 0);
  return llvm::Module::getOrInsertFunction(a1, a2, a3, v10, a4);
}

llvm::Instruction *sub_1CD57BA94(uint64_t a1, uint64_t a2, uint64_t *a3, llvm::IntegerType *a4, unsigned int a5, uint64_t a6)
{
  v18[2] = *MEMORY[0x1E4F143B8];
  v18[0] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), a4, 0);
  v18[1] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), a5, 0);
  __n128 result = (llvm::Instruction *)(*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t *, uint64_t, void))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72), a2, a3, v18, 2, 0);
  if (!result)
  {
    __int16 v17 = 257;
    __int16 v12 = operator new(0xB0uLL);
    uint64_t v13 = 0;
    uint64_t v14 = (llvm::Instruction *)(v12 + 24);
    v12[29] = v12[29] & 0x38000000 | 3;
    do
    {
      uint64_t v15 = &v12[v13];
      *uint64_t v15 = 0;
      v15[1] = 0;
      v15[2] = 0;
      v15[3] = v14;
      v13 += 8;
    }
    while (v13 != 24);
    sub_1CB845960((uint64_t)(v12 + 24), a2, a3, v18, 2, 3, &v16, 0);
    return sub_1CB844E0C((uint64_t *)a1, v14, a6);
  }
  return result;
}

llvm::SlotIndexes *llvm::SlotIndexes::SlotIndexes(llvm::SlotIndexes *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::SlotIndexes::ID);
  *(void *)uint64_t v2 = &unk_1F2613088;
  *(void *)(v2 + 248) = 0;
  *(void *)(v2 + 256) = 0;
  *(void *)(v2 + 264) = v2 + 280;
  *(void *)(v2 + 272) = 0x400000000;
  *(void *)(v2 + 312) = v2 + 328;
  *(void *)(v2 + 320) = 0;
  *(void *)(v2 + 328) = 0;
  *(void *)(v2 + 336) = 1;
  *(void *)(v2 + 344) = v2 + 344;
  *(void *)(v2 + 352) = v2 + 344;
  *(void *)(v2 + 368) = 0;
  *(void *)(v2 + 376) = 0;
  *(void *)(v2 + 360) = 0;
  *(_DWORD *)(v2 + 384) = 0;
  *(void *)(v2 + 392) = v2 + 408;
  *(void *)(v2 + 400) = 0x800000000;
  *(void *)(v2 + 536) = v2 + 552;
  *(void *)(v2 + 544) = 0x800000000;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3B58, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC473008;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCD3B58, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::SlotIndexes::getAnalysisUsage(uint64_t this, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void llvm::SlotIndexes::dump(llvm::SlotIndexes *this)
{
  uint64_t v1 = this;
  uint64_t v2 = (char *)this + 344;
  uint64_t v3 = *((void *)this + 44);
  if ((llvm::SlotIndexes *)v3 != (llvm::SlotIndexes *)((char *)this + 344))
  {
    do
    {
      uint64_t v4 = llvm::dbgs(this);
      uint64_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(v3 + 24));
      uint64_t v6 = sub_1CB8E509C(v5, " ");
      uint64_t v7 = *(void *)(v3 + 16);
      unsigned int v8 = llvm::dbgs(v6);
      if (v7) {
        llvm::MachineInstr::print(*(llvm::MachineInstr **)(v3 + 16), v8, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
      }
      else {
        this = sub_1CB8E509C(v8, "\n");
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while ((char *)v3 != v2);
  }
  uint64_t v9 = *((unsigned int *)v1 + 100);
  if (v9)
  {
    uint64_t v10 = 0;
    for (unint64_t i = 0; i != v9; ++i)
    {
      __int16 v12 = llvm::dbgs(this);
      uint64_t v13 = sub_1CB8E509C(v12, "%bb.");
      uint64_t v14 = llvm::raw_ostream::operator<<(v13, i);
      uint64_t v15 = sub_1CB8E509C(v14, "\t[");
      uint64_t v17 = *(void *)(*((void *)v1 + 49) + v10);
      llvm::SlotIndex::print((llvm::SlotIndex *)&v17, v15);
      uint64_t v16 = (unsigned char *)*((void *)v15 + 4);
      if ((unint64_t)v16 >= *((void *)v15 + 3))
      {
        uint64_t v15 = llvm::raw_ostream::write(v15, 59);
      }
      else
      {
        *((void *)v15 + 4) = v16 + 1;
        *uint64_t v16 = 59;
      }
      uint64_t v17 = *(void *)(*((void *)v1 + 49) + v10 + 8);
      llvm::SlotIndex::print((llvm::SlotIndex *)&v17, v15);
      this = sub_1CB8E509C(v15, ")\n");
      v10 += 16;
    }
  }
}

llvm::raw_ostream *llvm::SlotIndex::print(llvm::SlotIndex *this, llvm::raw_ostream *a2)
{
  if (*(void *)this < 8uLL)
  {
    return sub_1CB8E509C(a2, "invalid");
  }
  else
  {
    __n128 result = llvm::raw_ostream::operator<<(a2, *(unsigned int *)((*(void *)this & 0xFFFFFFFFFFFFFFF8) + 24));
    char v4 = aBerd[(*(void *)this >> 1) & 3];
    uint64_t v5 = (char *)*((void *)result + 4);
    if ((unint64_t)v5 >= *((void *)result + 3))
    {
      return llvm::raw_ostream::write(result, v4);
    }
    else
    {
      *((void *)result + 4) = v5 + 1;
      char *v5 = v4;
    }
  }
  return result;
}

llvm::raw_ostream *llvm::SlotIndex::dump(llvm::SlotIndex *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = llvm::SlotIndex::print(this, v2);
  char v4 = llvm::dbgs(v3);

  return sub_1CB8E509C(v4, "\n");
}

void llvm::callDefaultCtor<llvm::SlotIndexes>()
{
}

void llvm::initializeSpillPlacementPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3B60, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4740BC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD3B60, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::SpillPlacement::getAnalysisUsage(llvm::SpillPlacement *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBlockFrequencyInfo::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::EdgeBundles::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::MachineLoopInfo::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void sub_1CD57C100(uint64_t a1)
{
  sub_1CD57C1D0(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::SpillPlacement>()
{
}

void sub_1CD57C1D0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2613148;
  llvm::SpillPlacement::releaseMemory(a1);
  free(*(void **)(a1 + 528));
  uint64_t v2 = *(void **)(a1 + 480);
  if (v2 != (void *)(a1 + 496)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 392);
  if (v3 != (void *)(a1 + 408)) {
    free(v3);
  }
  char v4 = *(void **)(a1 + 344);
  if (v4 != (void *)(a1 + 360)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 296);
  if (v5 != (void *)(a1 + 312)) {
    free(v5);
  }

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

BOOL sub_1CD57C280(void *a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1[5] + 112);
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (*(_DWORD *)(*(void *)(v5 + 328) + 4 * (v3 & 0x7FFFFFFF))) {
    int v6 = *(_DWORD *)(*(void *)(v5 + 328) + 4 * (v3 & 0x7FFFFFFF));
  }
  else {
    int v6 = v3;
  }
  uint64_t v7 = sub_1CC2F12AC(v4, v6);
  unsigned int v8 = (void *)llvm::LiveRange::find((uint64_t *)v7, a2);
  if (v8 == (void *)(*(void *)v7 + 24 * *(unsigned int *)(v7 + 8))
    || ((*v8 >> 1) & 3 | *(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3))
  {
    if (v8 == *(void **)v7) {
      return 0;
    }
    return *(v8 - 2) == a2;
  }
  else
  {
    return *v8 == a2;
  }
}

llvm *sub_1CD57C338(llvm *a1)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a1 + 97))
  {
    int v11 = (_DWORD *)((char *)a1 + 200);
    __int16 v12 = v14;
    uint64_t v13 = 0x400000000;
    for (unint64_t i = (llvm *)sub_1CC47ECE8((uint64_t *)&v11); v13; unint64_t i = (llvm *)sub_1CC476878((uint64_t)&v11))
    {
      if (*((_DWORD *)v12 + 3) >= *((_DWORD *)v12 + 2)) {
        break;
      }
      uint64_t v2 = llvm::dbgs(i);
      int v3 = sub_1CB8E509C(v2, " [");
      uint64_t v10 = *(void *)(*((void *)v12 + 2 * v13 - 2)
                      + 16 * *((unsigned int *)v12 + 4 * v13 - 1));
      llvm::SlotIndex::print((llvm::SlotIndex *)&v10, v3);
      uint64_t v4 = (unsigned char *)*((void *)v3 + 4);
      if ((unint64_t)v4 >= *((void *)v3 + 3))
      {
        int v3 = llvm::raw_ostream::write(v3, 59);
      }
      else
      {
        *((void *)v3 + 4) = v4 + 1;
        *uint64_t v4 = 59;
      }
      uint64_t v10 = *(void *)(*((void *)v12 + 2 * v13 - 2)
                      + 16 * *((unsigned int *)v12 + 4 * v13 - 1)
                      + 8);
      llvm::SlotIndex::print((llvm::SlotIndex *)&v10, v3);
      uint64_t v5 = sub_1CB8E509C(v3, "):");
      llvm::raw_ostream::operator<<(v5, *(unsigned int *)(*((void *)v12 + 2 * v13 - 2)+ 4 * *((unsigned int *)v12 + 4 * v13 - 1)+ 144));
    }
    int v6 = (llvm *)v12;
    if (v12 != v14) {
      free(v12);
    }
    __n128 result = llvm::dbgs(v6);
    unsigned int v8 = (unsigned char *)*((void *)result + 4);
    if ((unint64_t)v8 >= *((void *)result + 3))
    {
      return llvm::raw_ostream::write(result, 10);
    }
    else
    {
      *((void *)result + 4) = v8 + 1;
      *unsigned int v8 = 10;
    }
  }
  else
  {
    uint64_t v9 = llvm::dbgs(a1);
    return sub_1CB8E509C(v9, " empty\n");
  }
  return result;
}

uint64_t sub_1CD57C548(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8) + 16 * *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(void *)(v2 - 16);
  uint64_t v4 = *(unsigned int *)(v2 - 4);
  if ((*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3) >= ((*(void *)(v3 + 16 * v4 + 8) >> 1) & 3 | *(_DWORD *)((*(void *)(v3 + 16 * v4 + 8) & 0xFFFFFFFFFFFFFFF8) + 24))
    && (uint64_t v11 = a2,
        uint64_t v12 = a1,
        uint64_t v10 = v4,
        char v6 = sub_1CD57C76C((uint64_t *)a1, a2, *(_DWORD *)(v3 + 4 * v4 + 144)),
        a2 = v11,
        char v7 = v6,
        a1 = v12,
        (v7 & 1) != 0))
  {
    uint64_t v8 = *(void *)(v3 + 16 * v10);
    uint64_t result = sub_1CD57C858(v12);
    uint64_t v9 = *(void *)(v12 + 8) + 16 * *(unsigned int *)(v12 + 16);
    *(void *)(*(void *)(v9 - 16) + 16 * *(unsigned int *)(v9 - 4)) = v8;
  }
  else
  {
    return sub_1CD57C818(a1, a2);
  }
  return result;
}

uint64_t sub_1CD57C620(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v8 = result;
    uint64_t v9 = a3 - 4;
    uint64_t v10 = result - 8;
    uint64_t v11 = a2 - 1;
    do
    {
      unsigned int v12 = *(_DWORD *)(a3 + 4 * v11);
      unsigned int v13 = *(_DWORD *)(a4 + 4 * v11);
      if (v12 != v13)
      {
        uint64_t v14 = v11;
        do
        {
          if (!v14) {
            break;
          }
          uint64_t result = sub_1CC2ECBB8(*(void **)(v8 + 8 * v11), v12, *(void *)(v10 + 8 * v14), *(_DWORD *)(v9 + 4 * v14), v13 - v12);
          *(_DWORD *)(v9 + 4 * v14) -= result;
          unsigned int v12 = *(_DWORD *)(a3 + 4 * v11) + result;
          *(_DWORD *)(a3 + 4 * v11) = v12;
          unsigned int v13 = *(_DWORD *)(a4 + 4 * v11);
          --v14;
        }
        while (v12 < v13);
      }
      --v11;
    }
    while (v11);
    if (a2 >= 2)
    {
      uint64_t v15 = 0;
      uint64_t v16 = 1;
      do
      {
        unsigned int v17 = *(_DWORD *)(a3 + 4 * v15);
        unsigned int v18 = *(_DWORD *)(a4 + 4 * v15);
        if (v17 != v18)
        {
          unsigned int v19 = v16;
          do
          {
            if (a2 == v19) {
              break;
            }
            uint64_t v20 = v15;
            uint64_t v21 = v16;
            uint64_t result = sub_1CC2ECBB8(*(void **)(v8 + 8 * v19), *(_DWORD *)(a3 + 4 * v19), *(void *)(v8 + 8 * v15), v17, v17 - v18);
            uint64_t v16 = v21;
            uint64_t v15 = v20;
            *(_DWORD *)(a3 + 4 * v19) += result;
            unsigned int v17 = *(_DWORD *)(a3 + 4 * v20) - result;
            *(_DWORD *)(a3 + 4 * v20) = v17;
            unsigned int v18 = *(_DWORD *)(a4 + 4 * v20);
            ++v19;
          }
          while (v17 < v18);
        }
        ++v15;
        uint64_t v16 = (v16 + 1);
      }
      while (v15 != v4);
    }
  }
  return result;
}

uint64_t sub_1CD57C76C(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = *((unsigned int *)a1 + 4);
  uint64_t v8 = a1[1];
  char v7 = (llvm::IntervalMapImpl::Path *)(a1 + 1);
  uint64_t v9 = *a1;
  uint64_t v10 = v8 + 16 * v6;
  unsigned int v11 = *(_DWORD *)(v10 - 8);
  uint64_t v12 = (*(_DWORD *)(v10 - 4) + 1);
  if (*(_DWORD *)(v9 + 184))
  {
    if (v12 < v11) {
      goto LABEL_3;
    }
    uint64_t result = llvm::IntervalMapImpl::Path::getRightSibling(v7, (int)v6 - 1);
    if (!result) {
      return result;
    }
    if (*(_DWORD *)((result & 0xFFFFFFFFFFFFFFC0) + 0x90) == a3)
    {
      uint64_t v14 = *(void *)(result & 0xFFFFFFFFFFFFFFC0);
      return v14 == a2;
    }
  }
  else if (v12 < v11)
  {
LABEL_3:
    uint64_t v13 = *(void *)(v10 - 16);
    if (*(_DWORD *)(v13 + 4 * v12 + 144) == a3)
    {
      uint64_t v14 = *(void *)(v13 + 16 * v12);
      return v14 == a2;
    }
  }
  return 0;
}

uint64_t sub_1CD57C818(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(unsigned int *)(result + 16);
  *(void *)(*(void *)(v2 + 16 * v3 - 16) + 16 * *(unsigned int *)(v2 + 16 * v3 - 4) + 8) = a2;
  if (*(_DWORD *)(v2 + 16 * (v3 - 1) + 12) == *(_DWORD *)(v2 + 16 * (v3 - 1) + 8) - 1) {
    return sub_1CC47FB18(result, (int)v3 - 1, a2);
  }
  return result;
}

uint64_t sub_1CD57C858(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  if (*(_DWORD *)(*(void *)result + 184)) {
    return sub_1CC47FB68(result, 1);
  }
  uint64_t v2 = *(void *)(result + 8);
  unsigned int v3 = *(_DWORD *)(v2 + 16 * *(unsigned int *)(result + 16) - 4);
  int v4 = *(_DWORD *)(v1 + 188);
  if (v3 + 1 != v4)
  {
    int v5 = v4 - 1;
    do
    {
      *(_OWORD *)(v1 + 16 * v3) = *(_OWORD *)(v1 + 16 * (v3 + 1));
      *(_DWORD *)(v1 + 144 + 4 * v3) = *(_DWORD *)(v1 + 144 + 4 * (v3 + 1));
      ++v3;
    }
    while (v5 != v3);
    int v4 = *(_DWORD *)(v1 + 188);
  }
  *(_DWORD *)(v1 + 188) = v4 - 1;
  *(_DWORD *)(v2 + 8) = v4 - 1;
  return result;
}

void llvm::initializeStackColoringPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3B68, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC481328;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD3B68, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

char **sub_1CD57C93C(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    int v5 = v2 - 8;
    do
    {
      sub_1CC2CAB7C((uint64_t *)&v5[v4], 0);
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD57C9A4(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  unint64_t v3 = *(void *)result;
  if (v2 >= *(_DWORD *)(result + 12))
  {
    unint64_t v6 = v3 + 8 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD57CA2C();
    }
    sub_1CD57CA2C();
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(v3 + 8 * v4) = v5;
  *(_DWORD *)(result + 8) = v4 + 1;
  return result;
}

void sub_1CD57CA2C()
{
}

void sub_1CD57CAD8(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        sub_1CD57CBB8();
      }
      if (v2 != a2)
      {
        uint64_t v8 = 3 * v2;
        uint64_t v9 = 48 * a2 - 48 * v2;
        uint64_t v10 = *(void *)a1 + 16 * v8 + 16;
        do
        {
          *(void *)(v10 - 16) = v10;
          *(void *)(v10 - 8) = 0x400000000;
          v10 += 48;
          v9 -= 48;
        }
        while (v9);
      }
    }
    else
    {
      uint64_t v5 = 3 * v2;
      unint64_t v6 = (void **)(*(void *)a1 + 16 * v5 - 48);
      uint64_t v7 = 48 * a2 - 16 * v5;
      do
      {
        if (v6 + 2 != *v6) {
          free(*v6);
        }
        v6 -= 6;
        v7 += 48;
      }
      while (v7);
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
}

void sub_1CD57CBB8()
{
}

void sub_1CD57CC28(uint64_t *a1, void *a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = *a1;
    uint64_t v6 = 48 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x400000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CBA6E388((uint64_t)a2, (const void **)v5);
      }
      v5 += 48;
      a2 += 6;
      v6 -= 48;
    }
    while (v6);
    uint64_t v7 = *((unsigned int *)a1 + 2);
    if (v7)
    {
      uint64_t v8 = *a1;
      uint64_t v9 = 48 * v7;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 48);
        if ((void *)(v8 + v9 - 32) != v10) {
          free(v10);
        }
        v9 -= 48;
      }
      while (v9);
    }
  }
}

_DWORD *sub_1CD57CCDC(uint64_t a1, unsigned int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    int v7 = v3 - 1;
    unsigned int v8 = (37 * *a2) & (v3 - 1);
    uint64_t v5 = (_DWORD *)(*(void *)a1 + 8 * v8);
    int v9 = *v5;
    if (*a2 == *v5) {
      return v5;
    }
    uint64_t v10 = 0;
    int v11 = 1;
    while (v9 != 0x7FFFFFFF)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v9 == 0x80000000;
      }
      if (v12) {
        uint64_t v10 = v5;
      }
      unsigned int v13 = v8 + v11++;
      unsigned int v8 = v13 & v7;
      uint64_t v5 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v7));
      int v9 = *v5;
      if (*a2 == *v5) {
        return v5;
      }
    }
    if (v10) {
      uint64_t v4 = v10;
    }
    else {
      uint64_t v4 = v5;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v5 = sub_1CD542F68(a1, (uint64_t)a2, a2, v4);
  *(void *)uint64_t v5 = *a2;
  return v5;
}

void sub_1CD57CD9C(char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD3CF0, 0, 0);
  byte_1EBCD3D70 = 0;
  qword_1EBCD3D78 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD3D80 = 0;
  qword_1EBCD3CF0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD3D88 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD3D90 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD3DA8 = (uint64_t)&qword_1EBCD3D90;
  sub_1CD57CE8C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD3CF0);
}

__n128 sub_1CD57CE8C(char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD3CF0, "stackcoloring-lifetime-start-on-first-use", 0x29uLL);
  uint64_t v6 = *a1;
  byte_1EBCD3D70 = **a1;
  byte_1EBCD3D81 = 1;
  byte_1EBCD3D80 = *v6;
  word_1EBCD3CFA = (32 * (*a2 & 3)) | word_1EBCD3CFA & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCD3D10 = (__int128)*a3;
  return result;
}

void llvm::initializeStackMapLivenessPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3E70, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC487838;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCD3E70, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::StatepointOpers::getNumGcMapEntriesIdx(llvm::StatepointOpers *this)
{
  unsigned int NumAllocaIdx = llvm::StatepointOpers::getNumAllocaIdx(this);
  uint64_t v3 = *(void *)(*(void *)this + 32);
  int v4 = *(_DWORD *)(v3 + 32 * NumAllocaIdx + 16);
  if (v4)
  {
    do
    {
      uint64_t v5 = NumAllocaIdx + 1;
      if (*(unsigned char *)(v3 + 32 * v5) == 1)
      {
        uint64_t v6 = *(void *)(v3 + 32 * v5 + 16);
        if (v6)
        {
          if (v6 == 1) {
            LODWORD(v5) = NumAllocaIdx + 4;
          }
          else {
            LODWORD(v5) = NumAllocaIdx + 2;
          }
        }
        else
        {
          LODWORD(v5) = NumAllocaIdx + 3;
        }
      }
      unsigned int NumAllocaIdx = v5;
      --v4;
    }
    while (v4);
  }
  else
  {
    LODWORD(v5) = NumAllocaIdx;
  }
  return (v5 + 2);
}

uint64_t llvm::StatepointOpers::getNumAllocaIdx(llvm::StatepointOpers *this)
{
  unsigned int NumGCPtrIdx = llvm::StatepointOpers::getNumGCPtrIdx(this);
  uint64_t v3 = *(void *)(*(void *)this + 32);
  int v4 = *(_DWORD *)(v3 + 32 * NumGCPtrIdx + 16);
  if (v4)
  {
    do
    {
      uint64_t v5 = NumGCPtrIdx + 1;
      if (*(unsigned char *)(v3 + 32 * v5) == 1)
      {
        uint64_t v6 = *(void *)(v3 + 32 * v5 + 16);
        if (v6)
        {
          if (v6 == 1) {
            LODWORD(v5) = NumGCPtrIdx + 4;
          }
          else {
            LODWORD(v5) = NumGCPtrIdx + 2;
          }
        }
        else
        {
          LODWORD(v5) = NumGCPtrIdx + 3;
        }
      }
      unsigned int NumGCPtrIdx = v5;
      --v4;
    }
    while (v4);
  }
  else
  {
    LODWORD(v5) = NumGCPtrIdx;
  }
  return (v5 + 2);
}

uint64_t llvm::StackMaps::getNextMetaArgIdx(llvm::StackMaps *this, const llvm::MachineInstr *a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (*(unsigned char *)(v2 + 32 * a2) == 1)
  {
    uint64_t v3 = *(void *)(v2 + 32 * a2 + 16);
    if (v3)
    {
      if (v3 == 1) {
        LODWORD(a2) = a2 + 3;
      }
      else {
        LODWORD(a2) = a2 + 1;
      }
    }
    else
    {
      LODWORD(a2) = a2 + 2;
    }
  }
  return (a2 + 1);
}

uint64_t llvm::StatepointOpers::getNumGCPtrIdx(llvm::StatepointOpers *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 32);
  int v2 = *((_DWORD *)this + 2) + *(_DWORD *)(v1 + 32 * (*((_DWORD *)this + 2) + 2) + 16);
  int v3 = *(_DWORD *)(v1 + 32 * (v2 + 9) + 16);
  for (unsigned int i = v2 + 10; v3; --v3)
  {
    if (*(unsigned char *)(v1 + 32 * i) == 1)
    {
      uint64_t v5 = *(void *)(v1 + 32 * i + 16);
      if (v5)
      {
        if (v5 == 1) {
          i += 3;
        }
        else {
          ++i;
        }
      }
      else
      {
        i += 2;
      }
    }
    ++i;
  }
  return i + 1;
}

uint64_t llvm::StatepointOpers::getFirstGCPtrIdx(llvm::StatepointOpers *this)
{
  unsigned int NumGCPtrIdx = llvm::StatepointOpers::getNumGCPtrIdx(this);
  if (*(_DWORD *)(*(void *)(*(void *)this + 32) + 32 * NumGCPtrIdx + 16)) {
    return NumGCPtrIdx + 1;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

llvm::cl::Option *sub_1CD57D1E4(llvm::cl::Option *a1, char *a2, _DWORD **a3, _WORD *a4, __n128 *a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25F74C8;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F68;
  *(void *)(v10 + 152) = &unk_1F2643D20;
  *(void *)(v10 + 160) = &unk_1F25F7480;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD57D2D4(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD57D2D4(uint64_t a1, char *__s, _DWORD **a3, _WORD *a4, __n128 *a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  int v11 = *a3;
  *(_DWORD *)(a1 + 128) = **a3;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v11;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  __n128 result = *a5;
  *(__n128 *)(a1 + 32) = *a5;
  return result;
}

void *sub_1CD57D368(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD57D418(a1, v7);
  int v9 = 0;
  sub_1CC48C528((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD57D418(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD57D4E4(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD57D4E4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      __n128 result = sub_1CC48C528((uint64_t *)v5, (void *)a2, &v10);
      int v9 = v10;
      void *v10 = *(void *)a2;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

llvm::StackProtector *llvm::StackProtector::StackProtector(llvm::StackProtector *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::StackProtector::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F26133D0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *((_DWORD *)this + 36) = 8;
  *((void *)this + 19) = (char *)this + 184;
  *((void *)this + 20) = (char *)this + 184;
  *((void *)this + 21) = 16;
  *((_DWORD *)this + 44) = 0;
  *((_WORD *)this + 156) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3FF8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC48C654;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCD3FF8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeStackProtectorPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3FF8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC48C654;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD3FF8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createStackProtectorPass(llvm *this)
{
}

void llvm::StackProtector::getAnalysisUsage(llvm::StackProtector *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::TargetPassConfig::ID);

  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t llvm::StackProtector::ContainsProtectableArray(llvm::StackProtector *this, llvm::Type **a2, BOOL *a3, BOOL a4, char a5)
{
  if (!a2) {
    goto LABEL_20;
  }
  int v9 = *((unsigned __int8 *)a2 + 8);
  if (v9 == 17)
  {
    if (!llvm::Type::isIntegerTy(a2[3], 8) && !a4)
    {
      if (a5)
      {
LABEL_20:
        char v11 = 0;
        return v11 & 1;
      }
      char v11 = 0;
      unsigned int v12 = *((_DWORD *)this + 21);
      if (v12 > 0x21 || ((1 << v12) & 0x3F0000888) == 0) {
        return v11 & 1;
      }
    }
    unint64_t v13 = *((unsigned int *)this + 36);
    uint64_t v14 = (llvm::DataLayout *)(*((void *)this + 13) + 272);
    unint64_t v15 = (unint64_t)(sub_1CB83544C((uint64_t)v14, (uint64_t)a2) + 7) >> 3;
    BOOL v17 = v16 == 1;
    char v11 = 1;
    char Alignment = llvm::DataLayout::getAlignment(v14, (llvm::Type *)a2, 1);
    v24[0] = ((1 << Alignment) + v15 - 1) & -(1 << Alignment);
    v24[1] = v17;
    if (llvm::TypeSize::operator unsigned long long(v24, v19) >= v13)
    {
      *a3 = 1;
      return v11 & 1;
    }
    if (a4)
    {
      char v11 = 1;
      return v11 & 1;
    }
    int v9 = *((unsigned __int8 *)a2 + 8);
  }
  if (v9 != 16) {
    goto LABEL_20;
  }
  uint64_t v20 = *((unsigned int *)a2 + 3);
  if (!v20) {
    goto LABEL_20;
  }
  char v11 = 0;
  uint64_t v21 = (llvm::Type **)a2[2];
  uint64_t v22 = 8 * v20;
  do
  {
    if (llvm::StackProtector::ContainsProtectableArray(this, *v21, a3, a4, 1))
    {
      char v11 = 1;
      if (*a3) {
        break;
      }
    }
    ++v21;
    v22 -= 8;
  }
  while (v22);
  return v11 & 1;
}

uint64_t llvm::StackProtector::HasAddressTaken(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    return 0;
  }
  int v9 = (const llvm::DataLayout *)(*(void *)(a1 + 104) + 272);
  uint64_t v10 = (llvm::SmallPtrSetImplBase *)(a1 + 152);
  while (2)
  {
    uint64_t v11 = *(void *)(v4 + 24);
    llvm::MemoryLocation::getOrNone((uint64_t ***)v11, (uint64_t)v25);
    if (!v27 || (v26 <= 0xFFFFFFFFFFFFFFFDLL ? (BOOL v12 = a3 >= (v26 & 0x7FFFFFFFFFFFFFFFLL)) : (BOOL v12 = 1), v12))
    {
      switch(*(unsigned char *)(v11 + 16))
      {
        case '<':
        case 'A':
          goto LABEL_12;
        case '=':
          uint64_t v13 = *(void *)(v11 - 64);
          goto LABEL_11;
        case '>':
          IndexTypeint SizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)v9, *(void *)v11);
          sub_1CB8F1EEC((uint64_t)&v23, IndexTypeSizeInBits, 0);
          if (llvm::GetElementPtrInst::accumulateConstantOffset((llvm::GetElementPtrInst *)v11, v9, (llvm::APInt *)&v23, v15, v16, v17, v18)&& (unsigned int v19 = sub_1CBF82054((uint64_t)&v23, 0xFFFFFFFFFFFFFFFFLL), a3 > (unint64_t)v19))
          {
            if (llvm::StackProtector::HasAddressTaken(a1, v11, a3 - (void)v19, 0)) {
              int v20 = 1;
            }
            else {
              int v20 = 4;
            }
          }
          else
          {
            int v20 = 1;
          }
          if (v24 >= 0x41)
          {
            if (v23) {
              MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
            }
          }
          if (v20 != 4) {
            return 1;
          }
          goto LABEL_12;
        case '?':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'L':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
          return 1;
        case '@':
        case 'K':
          uint64_t v13 = *(void *)(v11 - 32);
LABEL_11:
          if (v13 != a2) {
            goto LABEL_12;
          }
          return 1;
        case 'M':
        case 'N':
        case 'U':
          goto LABEL_26;
        case 'S':
          sub_1CB89694C(v10, v11);
          if (!v21) {
            goto LABEL_12;
          }
LABEL_26:
          if (llvm::StackProtector::HasAddressTaken(a1, v11, a3, a4)) {
            return 1;
          }
LABEL_12:
          uint64_t v4 = *(void *)(v4 + 8);
          if (!v4) {
            return 0;
          }
          continue;
        case 'T':
          if (!llvm::Instruction::isDebugOrPseudoInst((llvm::Instruction *)v11)
            && !llvm::Instruction::isLifetimeStartOrEnd((llvm::Instruction *)v11))
          {
            return 1;
          }
          goto LABEL_12;
        default:
          if (*(unsigned char *)(v11 + 16) != 29) {
            return 1;
          }
          goto LABEL_12;
      }
    }
    return 1;
  }
}

void llvm::StackProtector::CreateFailBB(llvm::StackProtector *this)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = "CallStackCheckFailBlk";
  __int16 v2 = 259;
  operator new();
}

uint64_t sub_1CD57DDA8(uint64_t a1, char *a2, llvm::Type *a3, const char **a4, unsigned int a5, uint64_t a6)
{
  v9[2] = *MEMORY[0x1E4F143B8];
  GlobalString = (uint64_t *)llvm::IRBuilderBase::CreateGlobalString(a1, a2, a3, a4, a5, a6);
  v9[0] = llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), 0, 0);
  v9[1] = v9[0];
  return llvm::ConstantExpr::getGetElementPtr(GlobalString[3], GlobalString, (uint64_t)v9, 2, 1, 0, 0);
}

void sub_1CD57DE44(uint64_t a1)
{
  sub_1CD57DEB8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::StackProtector>()
{
}

void sub_1CD57DEB8(uint64_t a1)
{
  *(void *)a1 = &unk_1F26133D0;
  __int16 v2 = *(void **)(a1 + 160);
  if (v2 != *(void **)(a1 + 152)) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 120), 8);
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

uint64_t sub_1CD57DF40(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  BOOL v12 = 0;
  uint64_t result = sub_1CD3C8538((uint64_t *)a2, a3, &v12);
  int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4B4EC8(a2, a3, v12);
    int v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void llvm::initializeStackSlotColoringPass(llvm *this, llvm::PassRegistry *a2)
{
  __int16 v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD4000, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC48ECC8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD4000, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

char **sub_1CD57E04C(char **a1)
{
  __int16 v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    int v7 = v2;
    uint64_t v5 = 48 * v3;
    do
    {
      uint64_t v6 = *(char **)&v7[v5 - 48];
      if (&v7[v5 - 32] != v6) {
        free(v6);
      }
      v5 -= 48;
    }
    while (v5);
    __int16 v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void **sub_1CD57E0CC(void **result)
{
  uint64_t v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    uint64_t v6 = (char *)*result;
    int v7 = result;
    uint64_t v3 = 72 * v2;
    do
    {
      uint64_t v4 = *(char **)&v6[v3 - 72];
      if (&v6[v3 - 56] != v4) {
        free(v4);
      }
      v3 -= 72;
    }
    while (v3);
    uint64_t result = v7;
    uint64_t v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    uint64_t v5 = result;
    free(v1);
    return v5;
  }
  return result;
}

char **sub_1CD57E158(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    int v7 = v2;
    uint64_t v5 = 80 * v3;
    do
    {
      uint64_t v6 = *(char **)&v7[v5 - 80];
      if (&v7[v5 - 64] != v6) {
        free(v6);
      }
      v5 -= 80;
    }
    while (v5);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD57E1D8()
{
}

void sub_1CD57E248(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)a1;
    uint64_t v4 = 80 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x800000000;
      if (*(_DWORD *)(v3 + 8)) {
        sub_1CBC5C65C((uint64_t)a2, v3);
      }
      v3 += 80;
      a2 += 10;
      v4 -= 80;
    }
    while (v4);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5)
    {
      uint64_t v6 = *(void *)a1;
      uint64_t v7 = 80 * v5;
      do
      {
        uint64_t v8 = *(void **)(v6 + v7 - 80);
        if ((void *)(v6 + v7 - 64) != v8) {
          free(v8);
        }
        v7 -= 80;
      }
      while (v7);
    }
  }
}

void sub_1CD57E30C()
{
}

void sub_1CD57E37C(uint64_t *a1, void *a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v11 = a1;
    uint64_t v5 = *a1;
    uint64_t v6 = 48 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x400000000;
      if (*(_DWORD *)(v5 + 8)) {
        a2 = (void *)sub_1CD41C56C((uint64_t)a2, v5);
      }
      v5 += 48;
      a2 += 6;
      v6 -= 48;
    }
    while (v6);
    uint64_t v7 = *((unsigned int *)v11 + 2);
    if (v7)
    {
      uint64_t v8 = *v11;
      uint64_t v9 = 48 * v7;
      do
      {
        char v10 = *(void **)(v8 + v9 - 48);
        if ((void *)(v8 + v9 - 32) != v10) {
          free(v10);
        }
        v9 -= 48;
      }
      while (v9);
    }
  }
}

uint64_t llvm::SwiftErrorValueTracking::getOrCreateVReg(llvm::SwiftErrorValueTracking *this, const llvm::MachineBasicBlock *a2, const llvm::Value *a3)
{
  v13[0] = (uint64_t)a2;
  v13[1] = (uint64_t)a3;
  uint64_t v5 = (char *)this + 32;
  uint64_t v4 = *((void *)this + 4);
  uint64_t v14 = 0;
  if (sub_1CD553C1C(v4, *((_DWORD *)v5 + 4), (uint64_t)a2, (uint64_t)a3, &v14)) {
    BOOL v6 = v14 == *(void *)v5 + 24 * *((unsigned int *)v5 + 4);
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    return *(unsigned int *)(v14 + 16);
  }
  uint64_t DataLayout = llvm::MachineFunction::getDataLayout(*(llvm::MachineFunction **)this);
  uint64_t v10 = *((void *)this + 2);
  uint64_t v11 = (*(unsigned __int8 (**)(uint64_t, uint64_t, void))(*(void *)v10 + 32))(v10, DataLayout, 0);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v10 + 424))(v10, v11, 0);
  uint64_t VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*(void *)(*(void *)this + 40), v12, "", 0);
  *((_DWORD *)sub_1CD57E864((uint64_t)v5, v13) + 4) = VirtualRegister;
  *((_DWORD *)sub_1CD57E864((uint64_t)this + 56, v13) + 4) = VirtualRegister;
  return VirtualRegister;
}

void *llvm::SwiftErrorValueTracking::setCurrentVReg(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v6[0] = a2;
  v6[1] = a3;
  uint64_t result = sub_1CD57EB4C(a1 + 32, v6);
  *((_DWORD *)result + 4) = a4;
  return result;
}

uint64_t llvm::SwiftErrorValueTracking::getOrCreateVRegDefAt(llvm::SwiftErrorValueTracking *this, unint64_t a2, const llvm::MachineBasicBlock *a3, const llvm::Value *a4)
{
  unint64_t v7 = a2 | 4;
  unint64_t v22 = a2 | 4;
  uint64_t v9 = (char *)this + 80;
  uint64_t v8 = *((void *)this + 10);
  uint64_t v10 = *((unsigned int *)this + 24);
  if (v10)
  {
    LODWORD(v11) = (v10 - 1) & ((a2 >> 9) ^ v7);
    uint64_t v12 = (uint64_t *)(v8 + 16 * v11);
    uint64_t v13 = *v12;
    if (v7 == *v12) {
      goto LABEL_3;
    }
    int v20 = 1;
    while (v13 != -4)
    {
      int v21 = v11 + v20++;
      uint64_t v11 = v21 & (v10 - 1);
      uint64_t v13 = *(void *)(v8 + 16 * v11);
      if (v7 == v13)
      {
        uint64_t v12 = (uint64_t *)(v8 + 16 * v11);
        goto LABEL_3;
      }
    }
  }
  uint64_t v12 = (uint64_t *)(v8 + 16 * v10);
LABEL_3:
  if (v12 != (uint64_t *)(v8 + 16 * v10)) {
    return *((unsigned int *)v12 + 2);
  }
  uint64_t DataLayout = llvm::MachineFunction::getDataLayout(*(llvm::MachineFunction **)this);
  uint64_t v17 = *((void *)this + 2);
  uint64_t v18 = (*(unsigned __int8 (**)(uint64_t, uint64_t, void))(*(void *)v17 + 32))(v17, DataLayout, 0);
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v17 + 424))(v17, v18, 0);
  uint64_t VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*(void *)(*(void *)this + 40), v19, "", 0);
  *((_DWORD *)sub_1CD57EC58((uint64_t)v9, &v22) + 2) = VirtualRegister;
  v23[0] = (uint64_t)a3;
  v23[1] = (uint64_t)a4;
  *((_DWORD *)sub_1CD57EB4C((uint64_t)this + 32, v23) + 4) = VirtualRegister;
  return VirtualRegister;
}

uint64_t llvm::SwiftErrorValueTracking::getOrCreateVRegUseAt(llvm::SwiftErrorValueTracking *this, unint64_t a2, const llvm::MachineBasicBlock *a3, const llvm::Value *a4)
{
  unint64_t v4 = a2 & 0xFFFFFFFFFFFFFFFBLL;
  unint64_t v15 = a2 & 0xFFFFFFFFFFFFFFFBLL;
  BOOL v6 = (char *)this + 80;
  uint64_t v5 = *((void *)this + 10);
  uint64_t v7 = *((unsigned int *)this + 24);
  if (v7)
  {
    LODWORD(v8) = (v7 - 1) & ((a2 >> 9) ^ v4);
    uint64_t v9 = (uint64_t *)(v5 + 16 * v8);
    uint64_t v10 = *v9;
    if (v4 == *v9) {
      goto LABEL_3;
    }
    int v13 = 1;
    while (v10 != -4)
    {
      int v14 = v8 + v13++;
      uint64_t v8 = v14 & (v7 - 1);
      uint64_t v10 = *(void *)(v5 + 16 * v8);
      if (v4 == v10)
      {
        uint64_t v9 = (uint64_t *)(v5 + 16 * v8);
        goto LABEL_3;
      }
    }
  }
  uint64_t v9 = (uint64_t *)(v5 + 16 * v7);
LABEL_3:
  if (v9 != (uint64_t *)(v5 + 16 * v7)) {
    return *((unsigned int *)v9 + 2);
  }
  uint64_t VReg = llvm::SwiftErrorValueTracking::getOrCreateVReg(this, a3, a4);
  *((_DWORD *)sub_1CD57EC58((uint64_t)v6, &v15) + 2) = VReg;
  return VReg;
}

_DWORD *sub_1CD57E814(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD57EF00(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          *uint64_t v2 = -4;
          v2 += 2;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

void *sub_1CD57E864(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD57E8D4(a1, a2, v7);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    *((_DWORD *)v5 + 4) = 0;
  }
  return v5;
}

void *sub_1CD57E8D4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1CD57E994(a1, v6);
    uint64_t v8 = 0;
    sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD57E994(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD57EA70(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD57EA70(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *int v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    uint64_t v11 = *(void *)(a2 + 8);
    if ((*(void *)a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      int v13 = 0;
      uint64_t result = sub_1CD553C1C(*(void *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v13);
      int64x2_t v12 = v13;
      *int v13 = *(void *)a2;
      v12[1] = *(void *)(a2 + 8);
      *((_DWORD *)v12 + 4) = *(_DWORD *)(a2 + 16);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

void *sub_1CD57EB4C(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD57E8D4(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = a2[1];
    *((_DWORD *)v5 + 4) = 0;
  }
  return v5;
}

uint64_t sub_1CD57EBC4(uint64_t a1, int a2, unint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (a2 - 1) & ((a3 >> 9) ^ a3);
    uint64_t v6 = (void *)(a1 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -16;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 16 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD57EC58(uint64_t a1, unint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD57EBC4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD57ECC8(a1, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void *sub_1CD57ECC8(uint64_t a1, unint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD57ED7C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD57EBC4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD57ED7C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD57EE48(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD57EE48(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    unint64_t v9 = *(void *)a2;
    if (*(void *)a2 != -16 && v9 != -4)
    {
      BOOL v12 = 0;
      uint64_t result = sub_1CD57EBC4(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v11 = v12;
      *BOOL v12 = *(void *)a2;
      *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

_DWORD *sub_1CD57EF00(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(void **)result;
      uint64_t v7 = 16 * v2;
      do
      {
        *uint64_t v6 = -4;
        v6 += 2;
        v7 -= 16;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC49318C(v1, v5);
  }
  return result;
}

char *llvm::SwitchCG::getJumpTableRange(void *a1, unsigned int a2, unsigned int a3)
{
  int v3 = (unint64_t **)(*(void *)(*a1 + 40 * a2 + 8) + 24);
  uint64_t v4 = *(void *)(*a1 + 40 * a3 + 16);
  int v5 = (const llvm::APInt *)(v4 + 24);
  unsigned int v9 = *(_DWORD *)(v4 + 32);
  if (v9 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v8, v5);
  }
  uint64_t v8 = *(void *)v5;
  llvm::APInt::operator-=((uint64_t)&v8, v3);
  unsigned int v11 = v9;
  uint64_t v10 = v8;
  unsigned int v9 = 0;
  uint64_t v6 = sub_1CBF82054((uint64_t)&v10, 0x28F5C28F5C28F5CuLL);
  if (v11 >= 0x41 && v10) {
    MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
  }
  if (v9 >= 0x41 && v8) {
    MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
  }
  return (char *)v6 + 1;
}

void llvm::SwitchCG::SwitchLowering::buildJumpTable(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a5;
  unsigned int v8 = a4;
  unsigned int v9 = a3;
  int v12 = 0;
  unsigned int v13 = 0;
  unsigned int v14 = 0;
  unint64_t v103 = 0;
  uint64_t v104 = a6;
  v101 = 0;
  uint64_t v102 = 0;
  unsigned int v98 = 0;
  uint64_t v99 = 0;
  unsigned int v100 = 0;
  if (a3 <= a4)
  {
    do
      *((_DWORD *)sub_1CD57F9D0((uint64_t)&v98, (uint64_t *)(*a2 + 40 * v9++ + 24)) + 2) = 0;
    while (v9 <= v8);
    unsigned int v14 = 0;
    unsigned int v13 = 0;
    unsigned int v15 = a3;
    uint64_t v71 = a1;
    unsigned int v70 = v8;
    do
    {
      uint64_t v16 = *a2;
      uint64_t v17 = *a2 + 40 * v15;
      uint64_t v18 = *(unsigned int *)(v17 + 32);
      unint64_t v19 = v18 + v13;
      unsigned int v20 = v18 + v13;
      if (v19 > 0x80000000) {
        unsigned int v20 = 0x80000000;
      }
      unsigned int v73 = v20;
      uint64_t v21 = *(void *)(v17 + 8);
      uint64_t v22 = *(void *)(v17 + 16);
      uint64_t v23 = (const llvm::APInt *)(v21 + 24);
      unsigned int v24 = (char **)(v22 + 24);
      unsigned int v25 = *(_DWORD *)(v21 + 32);
      if (v25 > 0x40) {
        BOOL v26 = llvm::APInt::equalSlowCase((const void **)(v21 + 24), (const void **)(v22 + 24));
      }
      else {
        BOOL v26 = *(void *)v23 == (void)*v24;
      }
      unsigned int v27 = v15;
      if (v26) {
        int v28 = 1;
      }
      else {
        int v28 = 2;
      }
      if (v27 != a3)
      {
        uint64_t v29 = *(void *)(v16 + 40 * (v27 - 1) + 16);
        unsigned int v97 = v25;
        if (v25 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v96, v23);
        }
        int v30 = v28;
        uint64_t v96 = *(char **)v23;
        llvm::APInt::operator-=((uint64_t)&v96, (unint64_t **)(v29 + 24));
        LODWORD(v90) = v97;
        uint64_t v89 = v96;
        unsigned int v97 = 0;
        uint64_t v41 = sub_1CBF82054((uint64_t)&v89, 0xFFFFFFFFFFFFFFFFLL);
        if (v90 >= 0x41 && v89) {
          MEMORY[0x1D25D9CB0](v89, 0x1000C8000313F17);
        }
        if (v97 >= 0x41 && v96) {
          MEMORY[0x1D25D9CB0](v96, 0x1000C8000313F17);
        }
        unsigned int v42 = (char *)v41 - 1;
        int v28 = v30;
        if (v42)
        {
          char v43 = v102;
          do
          {
            if ((unint64_t)v43 >= v103) {
              char v43 = sub_1CBC13470((void **)&v101, &v104);
            }
            else {
              *v43++ = v104;
            }
            uint64_t v102 = v43;
            --v42;
          }
          while (v42);
        }
      }
      unsigned int v95 = *(_DWORD *)(v22 + 32);
      if (v95 > 0x40) {
        llvm::APInt::initSlowCase((llvm::APInt *)&v94, (const llvm::APInt *)(v22 + 24));
      }
      unint64_t v94 = *v24;
      unsigned int v13 = v73;
      unsigned int v8 = v70;
      llvm::APInt::operator-=((uint64_t)&v94, (unint64_t **)v23);
      LODWORD(v90) = v95;
      uint64_t v89 = v94;
      unsigned int v95 = 0;
      int v31 = sub_1CBF82054((uint64_t)&v89, 0xFFFFFFFFFFFFFFFFLL);
      if (v90 >= 0x41 && v89) {
        MEMORY[0x1D25D9CB0](v89, 0x1000C8000313F17);
      }
      if (v95 >= 0x41 && v94) {
        MEMORY[0x1D25D9CB0](v94, 0x1000C8000313F17);
      }
      if (v31 != (void *)-1)
      {
        uint64_t v32 = v102;
        int v33 = (char *)v31 + 1;
        do
        {
          int v34 = (void *)(*a2 + 40 * v27 + 24);
          if ((unint64_t)v32 >= v103) {
            uint64_t v32 = sub_1CBC13470((void **)&v101, v34);
          }
          else {
            *v32++ = *v34;
          }
          uint64_t v102 = v32;
          --v33;
        }
        while (v33);
      }
      v14 += v28;
      uint64_t v35 = *a2 + 40 * v27;
      uint64_t v36 = *(unsigned int *)(v35 + 32);
      uint64_t v37 = sub_1CD57F9D0((uint64_t)&v98, (uint64_t *)(v35 + 24));
      uint64_t v38 = *((unsigned int *)v37 + 2);
      unint64_t v39 = v38 + v36;
      unsigned int v40 = v38 + v36;
      if (v39 > 0x80000000) {
        unsigned int v40 = 0x80000000;
      }
      *((_DWORD *)v37 + 2) = v40;
      unsigned int v15 = v27 + 1;
      a1 = v71;
    }
    while (v15 <= v70);
    int v12 = v99;
    uint64_t v7 = a5;
    unsigned int v9 = a3;
  }
  if (!sub_1CB908330(*(void *)(a1 + 80), (void *)(*(void *)(*a2 + 40 * v9 + 8) + 24), *(void *)(*a2 + 40 * v8 + 16) + 24, *(void *)(a1 + 96))|| (v14 < 3 || v12 != 1) && (v14 < 5 || v12 != 2) && (v14 < 6 || v12 != 3))
  {
    unsigned int v74 = v13;
    unsigned int v44 = v8;
    uint64_t v45 = *(llvm::MachineFunction **)(*(void *)(a1 + 104) + 8);
    uint64_t v69 = v7;
    unint64_t MachineBasicBlock = llvm::MachineFunction::CreateMachineBasicBlock(v45, *(const llvm::BasicBlock **)(v7 + 40));
    uint64_t v89 = v93;
    uint64_t v90 = v93;
    uint64_t v91 = 8;
    int v92 = 0;
    char v47 = v101;
    uint64_t v48 = v102;
    while (v47 != v48)
    {
      uint64_t v49 = *v47;
      uint64_t v79 = v49;
      char v50 = (char *)sub_1CB896AE8((uint64_t)&v89, v49);
      if (v90 == v89) {
        unint64_t v51 = (uint64_t *)((char *)&v91 + 4);
      }
      else {
        unint64_t v51 = &v91;
      }
      if (v50 == &v90[8 * *(unsigned int *)v51])
      {
        uint64_t v52 = sub_1CD57F9D0((uint64_t)&v98, &v79);
        (**(void (***)(uint64_t, unint64_t, uint64_t, void))a1)(a1, MachineBasicBlock, v49, *((unsigned int *)v52 + 2));
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v89, v49);
      }
      ++v47;
    }
    sub_1CC2BE0A8(*(unsigned int **)(MachineBasicBlock + 112), *(unsigned int **)(MachineBasicBlock + 120));
    int v53 = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 1552))();
    uint64_t JumpTableInfo = llvm::MachineFunction::getOrCreateJumpTableInfo(v45, v53);
    int JumpTableIndex = llvm::MachineJumpTableInfo::createJumpTableIndex(JumpTableInfo, (uint64_t)&v101);
    v86[0] = -1;
    v86[1] = JumpTableIndex;
    unint64_t v87 = MachineBasicBlock;
    uint64_t v88 = 0;
    uint64_t v56 = *a2;
    uint64_t v57 = *(void *)(*a2 + 40 * v9 + 8);
    v58 = (const llvm::APInt *)(v57 + 24);
    unsigned int v78 = *(_DWORD *)(v57 + 32);
    if (v78 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&v77, v58);
    }
    uint64_t v77 = *(void *)v58;
    uint64_t v59 = *(void *)(v56 + 40 * v44 + 16);
    char v60 = (const llvm::APInt *)(v59 + 24);
    unsigned int v76 = *(_DWORD *)(v59 + 32);
    if (v76 > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&v75, v60);
    }
    uint64_t v75 = *(void *)v60;
    int v61 = *(_DWORD *)(v69 + 20);
    if ((v61 & 0x40000000) != 0) {
      __int16 v62 = *(uint64_t **)(v69 - 8);
    }
    else {
      __int16 v62 = (uint64_t *)(v69 - 32 * (v61 & 0x7FFFFFF));
    }
    uint64_t v63 = *v62;
    unsigned int v80 = v78;
    uint64_t v79 = v77;
    unsigned int v78 = 0;
    unsigned int v82 = v76;
    uint64_t v81 = v75;
    unsigned int v76 = 0;
    uint64_t v83 = v63;
    uint64_t v84 = 0;
    __int16 v85 = 0;
    sub_1CD57F740(a1 + 32, (uint64_t)&v79, (uint64_t)v86);
    uint64_t v64 = *(void *)(*a2 + 40 * v9 + 8);
    uint64_t v65 = *(void *)(*a2 + 40 * v44 + 16);
    uint64_t v66 = (*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4;
    *(_DWORD *)a7 = 1;
    *(void *)(a7 + 8) = v64;
    *(void *)(a7 + 16) = v65;
    *(_DWORD *)(a7 + 24) = -858993459 * v66 - 1;
    *(_DWORD *)(a7 + 32) = v74;
    sub_1CD494A40((uint64_t)&v79);
    if (v90 != v89) {
      free(v90);
    }
  }
  llvm::deallocate_buffer(v98, (void *)(16 * v100));
}

char *sub_1CD57F740(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4 >= *(void *)(a1 + 16))
  {
    uint64_t result = sub_1CC494D70((void **)a1, a2, a3);
  }
  else
  {
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
    *(void *)unint64_t v4 = *(void *)a2;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(v4 + 24) = *(_DWORD *)(a2 + 24);
    *(void *)(v4 + 16) = *(void *)(a2 + 16);
    *(_DWORD *)(a2 + 24) = 0;
    long long v5 = *(_OWORD *)(a2 + 32);
    *(_WORD *)(v4 + 48) = *(_WORD *)(a2 + 48);
    *(_OWORD *)(v4 + 32) = v5;
    long long v6 = *(_OWORD *)a3;
    *(void *)(v4 + 72) = *(void *)(a3 + 16);
    *(_OWORD *)(v4 + 56) = v6;
    uint64_t result = (char *)(v4 + 80);
  }
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t sub_1CD57F7C8(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, int *a5, char a6, char a7, char a8, uint64_t a9, int *a10)
{
  unint64_t v11 = a1[1];
  if (v11 >= a1[2])
  {
    uint64_t result = sub_1CC496284(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else
  {
    sub_1CC496404(v11, a2, a3, a4, a5, a6, a7, a8, a9, a10);
    uint64_t result = v11 + 192;
  }
  a1[1] = result;
  return result;
}

void sub_1CD57F824(void **a1, unint64_t a2)
{
  long long v5 = (char *)a1[1];
  unint64_t v4 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v17 = &v5[40 * a2];
      do
      {
        *((void *)v5 + 4) = 0;
        *(_OWORD *)long long v5 = 0uLL;
        *((_OWORD *)v5 + 1) = 0uLL;
        *((_DWORD *)v5 + 8) = -1;
        v5 += 40;
      }
      while (v5 != v17);
      long long v5 = v17;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*a1) >> 3);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x666666666666666) {
      abort();
    }
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - (unsigned char *)*a1) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x333333333333333) {
      unint64_t v9 = 0x666666666666666;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x666666666666666) {
        sub_1CB833614();
      }
      uint64_t v10 = (char *)operator new(40 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    unint64_t v11 = &v10[40 * v6];
    int v12 = &v11[40 * a2];
    unsigned int v13 = v11;
    do
    {
      *((void *)v13 + 4) = 0;
      *(_OWORD *)unsigned int v13 = 0uLL;
      *((_OWORD *)v13 + 1) = 0uLL;
      *((_DWORD *)v13 + 8) = -1;
      v13 += 40;
    }
    while (v13 != v12);
    unsigned int v14 = (char *)*a1;
    if (v5 != *a1)
    {
      do
      {
        long long v15 = *(_OWORD *)(v5 - 40);
        long long v16 = *(_OWORD *)(v5 - 24);
        *((_DWORD *)v11 - 2) = *((_DWORD *)v5 - 2);
        *(_OWORD *)(v11 - 24) = v16;
        *(_OWORD *)(v11 - 40) = v15;
        v11 -= 40;
        v5 -= 40;
      }
      while (v5 != v14);
      long long v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = v12;
    a1[2] = &v10[40 * v9];
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void *sub_1CD57F9D0(uint64_t a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  long long v5 = v7;
  if ((v4 & 1) == 0)
  {
    long long v5 = sub_1CD57FA44(a1, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = -1;
  }
  return v5;
}

void *sub_1CD57FA44(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD57FAF8(a1, v6);
  unint64_t v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD57FAF8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD40ED08(a1, (uint64_t)v4, (uint64_t)v4 + 16 * v3);
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

unint64_t sub_1CD57FBCC(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 32 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t sub_1CD57FC44(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v5 = (const void *)(a2 + 16);
    unint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)a1, v4, 32 * v9 - 4);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove(*(void **)a1, v4, 32 * v10 - 4);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 32 * v10), (const void *)(*(void *)a2 + 32 * v10), *(void *)a2 + 32 * v11 - (*(void *)a2 + 32 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v9;
    }
    else
    {
      unint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        unint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *int v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD57FD64(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = 0;
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v6 = a1 + 64;
  *(_OWORD *)(v6 - 32) = v4;
  *(_OWORD *)(v6 - 16) = v5;
  *(void *)(v6 + 8) = 0x300000000;
  if (*(_DWORD *)(a2 + 72)) {
    sub_1CD57FC44(v6, a2 + 64);
  }
  uint64_t v7 = *(void *)(a2 + 176);
  *(unsigned char *)(a1 + 184) = *(unsigned char *)(a2 + 184);
  *(void *)(a1 + 176) = v7;
  return a1;
}

uint64_t sub_1CD57FDF4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2 != (void *)(a1 + 80)) {
    free(v2);
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 8) >= 0x41u && *(void *)a1) {
    MEMORY[0x1D25D9CB0](*(void *)a1, 0x1000C8000313F17);
  }
  return a1;
}

void llvm::initializeTailDuplicatePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD4188, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC499164;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD4188, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeEarlyTailDuplicatePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD4190, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC499200;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD4190, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

__n128 llvm::TailDuplicator::initMF(llvm::TailDuplicator *this, llvm::MachineFunction *a2, char a3, const llvm::MachineBranchProbabilityInfo *a4, llvm::MBFIWrapper *a5, llvm::ProfileSummaryInfo *a6, char a7, int a8)
{
  *((void *)this + 5) = a2;
  *(void *)this = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 104))(*((void *)a2 + 2));
  *((void *)this + 1) = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 5) + 16) + 176))(*(void *)(*((void *)this + 5) + 16));
  __n128 result = *(__n128 *)(*((void *)this + 5) + 32);
  *(__n128 *)((char *)this + 24) = result;
  *((void *)this + 2) = a4;
  *((void *)this + 6) = a5;
  *((void *)this + 7) = a6;
  *((_DWORD *)this + 17) = a8;
  *((unsigned char *)this + 65) = a7;
  *((unsigned char *)this + 64) = a3;
  return result;
}

uint64_t llvm::TailDuplicator::tailDuplicateAndUpdate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v65[8] = *MEMORY[0x1E4F143B8];
  unsigned int v13 = *(uint64_t **)(a3 + 88);
  unsigned int v14 = *(uint64_t **)(a3 + 96);
  uint64_t v58 = 1;
  int64x2_t v59 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v60 = v59;
  int64x2_t v61 = v59;
  int64x2_t v62 = v59;
  uint64_t v63 = v65;
  uint64_t v64 = 0x800000000;
  sub_1CD53F660(&v58, v13, v14);
  v56[0] = v57;
  v56[1] = (void *)0x800000000;
  int v53 = v55;
  uint64_t v54 = 0x1000000000;
  uint64_t v15 = llvm::TailDuplicator::tailDuplicate((uint64_t *)a1, a2, (llvm::MachineBasicBlock *)a3, a4, (uint64_t)v56, (uint64_t)&v53, a7);
  if (v15)
  {
    v51[0] = v52;
    v51[1] = (void *)0x800000000;
    int v16 = llvm::MachineSSAUpdater::MachineSSAUpdater(v47, *(void *)(a1 + 40), (uint64_t)v51);
    int v17 = *(void *)(a3 + 64) == *(void *)(a3 + 72) && *(unsigned char *)(a3 + 185) == 0;
    if (*(unsigned char *)(a1 + 64)) {
      llvm::TailDuplicator::updateSuccessorsPHIs(a1, a3, v17, (uint64_t)v56, (uint64_t)&v58);
    }
    unsigned int v45 = v15;
    if (v17) {
      llvm::TailDuplicator::removeDeadBlock(v16, (llvm::MachineBasicBlock *)a3, a6);
    }
    uint64_t v18 = *(unsigned int *)(a1 + 80);
    if (v18)
    {
      for (uint64_t i = 0; i != v18; ++i)
      {
        unsigned int v27 = *(_DWORD *)(*(void *)(a1 + 72) + 4 * i);
        llvm::MachineSSAUpdater::Initialize((uint64_t)v47, v27);
        uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(*(void *)(a1 + 32), v27);
        if (VRegDef)
        {
          uint64_t v29 = *(void *)(VRegDef + 24);
          llvm::MachineSSAUpdater::AddAvailableValue(v47, v29, v27);
        }
        else
        {
          uint64_t v29 = 0;
        }
        int v30 = sub_1CD489BC0(*(void *)(a1 + 152), *(_DWORD *)(a1 + 168), v27);
        uint64_t v31 = *((void *)v30 + 1);
        uint64_t v32 = *((void *)v30 + 2);
        while (v31 != v32)
        {
          llvm::MachineSSAUpdater::AddAvailableValue(v47, *(void *)v31, *(_DWORD *)(v31 + 8));
          v31 += 16;
        }
        uint64_t v48 = v50;
        uint64_t v49 = 0x600000000;
        uint64_t v33 = sub_1CBA02BCC(*(void *)(a1 + 32), v27);
        if (v33 != v34)
        {
          uint64_t v39 = v33;
          uint64_t v40 = v34;
          do
          {
            uint64_t v41 = (llvm::MachineOperand *)v39;
            do
              uint64_t v39 = *(void *)(v39 + 24);
            while (v39 && (*(unsigned char *)(v39 + 3) & 1) != 0);
            uint64_t v42 = *((void *)v41 + 1);
            int v43 = **(unsigned __int16 **)(v42 + 16);
            if ((v43 - 13) > 1)
            {
              if (*(void *)(v42 + 24) != v29 || (v43 != 69 ? (BOOL v44 = v43 == 0) : (BOOL v44 = 1), v44)) {
                llvm::MachineSSAUpdater::RewriteUse((llvm::MachineSSAUpdater *)v47, v41);
              }
            }
            else
            {
              if (v49 >= (unint64_t)HIDWORD(v49)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v48 + v49) = v41;
              LODWORD(v49) = v49 + 1;
            }
          }
          while (v39 != v40);
        }
        uint64_t v35 = (uint64_t *)v48;
        if (v49)
        {
          uint64_t v36 = 8 * v49;
          do
          {
            uint64_t v37 = *v35++;
            unsigned int ValueInMiddleOfBlock = llvm::MachineSSAUpdater::GetValueInMiddleOfBlock((llvm::MachineSSAUpdater *)v47, *(llvm::MachineBasicBlock **)(*(void *)(v37 + 8) + 24), 1);
            llvm::MachineOperand::setReg(v37, ValueInMiddleOfBlock);
            v36 -= 8;
          }
          while (v36);
          uint64_t v35 = (uint64_t *)v48;
        }
        if (v35 != (uint64_t *)v50) {
          free(v35);
        }
      }
      *(_DWORD *)(a1 + 80) = 0;
      sub_1CD53711C((unsigned int *)(a1 + 152));
    }
    if (v54)
    {
      uint64_t v19 = 0;
      uint64_t v20 = 8 * v54;
      do
      {
        uint64_t v21 = *(void *)((char *)v53 + v19);
        if (**(_WORD **)(v21 + 16) == 19)
        {
          uint64_t v22 = *(void *)(v21 + 32);
          unsigned int v23 = *(_DWORD *)(v22 + 4);
          unsigned int v24 = *(_DWORD *)(v22 + 36);
          if (llvm::MachineRegisterInfo::hasOneNonDBGUse(*(void *)(a1 + 32), v24))
          {
            if (llvm::MachineRegisterInfo::constrainRegClass(*(void **)(a1 + 32), v24, *(void *)(*(void *)(*(void *)(a1 + 32) + 24) + 16 * (v23 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, 0))
            {
              llvm::MachineRegisterInfo::replaceRegWith(*(void **)(a1 + 32), v23, v24);
              llvm::MachineInstr::eraseFromParent((llvm::MachineInstr *)v21);
            }
          }
        }
        v19 += 8;
      }
      while (v20 != v19);
    }
    if (a5) {
      sub_1CBA6E388(a5, (const void **)v56);
    }
    llvm::MachineSSAUpdater::~MachineSSAUpdater((llvm::MachineSSAUpdater *)v47);
    uint64_t v15 = v45;
    if (v51[0] != v52) {
      free(v51[0]);
    }
  }
  if (v53 != v55) {
    free(v53);
  }
  if (v56[0] != v57) {
    free(v56[0]);
  }
  if (v63 != v65) {
    free(v63);
  }
  if ((v58 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v59.i64[0], 8);
  }
  return v15;
}

void llvm::TailDuplicator::updateSuccessorsPHIs(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(unsigned int *)(a5 + 80);
  if (v5)
  {
    uint64_t v7 = *(uint64_t **)(a5 + 72);
    uint64_t v34 = &v7[v5];
    do
    {
      uint64_t v35 = v7;
      uint64_t v8 = *v7;
      uint64_t v9 = *v7 + 48;
      uint64_t v10 = *(void *)(*v7 + 56);
      for (i = v9; v10 != v9; uint64_t v9 = i)
      {
        int v11 = **(unsigned __int16 **)(v10 + 16);
        if (v11 != 69 && v11 != 0) {
          break;
        }
        int v13 = *(_DWORD *)(v10 + 40);
        uint64_t v14 = *(void *)(v10 + 32);
        if (v13 == 1)
        {
LABEL_11:
          unsigned int v15 = 0;
        }
        else
        {
          unsigned int v15 = 1;
          while (*(void *)(v14 + 32 * (v15 + 1) + 16) != a2)
          {
            v15 += 2;
            if (v13 == v15) {
              goto LABEL_11;
            }
          }
        }
        int v16 = *(llvm::MachineFunction **)(a2 + 32);
        unsigned int v17 = *(_DWORD *)(v14 + 32 * v15 + 4);
        if (a3)
        {
          unsigned int v18 = v13 - 2;
          if (v13 - 2 != v15)
          {
            do
            {
              uint64_t v19 = v18 + 1;
              if (*(void *)(*(void *)(v10 + 32) + 32 * v19 + 16) == a2)
              {
                llvm::MachineInstr::removeOperand((char *)v10, v19);
                llvm::MachineInstr::removeOperand((char *)v10, v18);
              }
              v18 -= 2;
            }
            while (v15 != v18);
          }
        }
        else
        {
          unsigned int v15 = 0;
        }
        uint64_t v20 = *(void *)(a1 + 152);
        uint64_t v21 = *(unsigned int *)(a1 + 168);
        uint64_t v22 = sub_1CD489BC0(v20, *(_DWORD *)(a1 + 168), v17);
        if ((int *)(v20 + 32 * v21) == v22)
        {
          uint64_t v29 = *(unsigned int *)(a4 + 8);
          if (v29)
          {
            int v30 = *(uint64_t **)a4;
            uint64_t v31 = 8 * v29;
            do
            {
              uint64_t v32 = *v30;
              if (v15)
              {
                llvm::MachineOperand::setReg(*(void *)(v10 + 32) + 32 * v15, v17);
                *(void *)(*(void *)(v10 + 32) + 32 * (v15 + 1) + 16) = v32;
              }
              else
              {
                uint64_t v41 = 0;
                int v39 = 0;
                unsigned int v40 = v17;
                uint64_t v42 = 0;
                uint64_t v43 = 0;
                llvm::MachineInstr::addOperand((llvm::MachineInstr *)v10, v16, (const llvm::MachineOperand *)&v39);
                uint64_t v41 = 0;
                uint64_t v42 = v32;
                int v39 = 4;
                llvm::MachineInstr::addOperand((llvm::MachineInstr *)v10, v16, (const llvm::MachineOperand *)&v39);
              }
              unsigned int v15 = 0;
              ++v30;
              v31 -= 8;
            }
            while (v31);
            goto LABEL_44;
          }
        }
        else
        {
          unsigned int v23 = (_DWORD *)*((void *)v22 + 1);
          unsigned int v24 = (_DWORD *)*((void *)v22 + 2);
          while (v23 != v24)
          {
            uint64_t v25 = *(void *)v23;
            BOOL v26 = *(void **)(*(void *)v23 + 88);
            unsigned int v27 = *(void **)(*(void *)v23 + 96);
            if (v26 != v27)
            {
              while (*v26 != v8)
              {
                if (++v26 == v27)
                {
                  BOOL v26 = *(void **)(*(void *)v23 + 96);
                  break;
                }
              }
            }
            if (v26 != v27)
            {
              unsigned int v28 = v23[2];
              if (v15)
              {
                llvm::MachineOperand::setReg(*(void *)(v10 + 32) + 32 * v15, v28);
                *(void *)(*(void *)(v10 + 32) + 32 * (v15 + 1) + 16) = v25;
                unsigned int v15 = 0;
              }
              else
              {
                uint64_t v41 = 0;
                int v39 = 0;
                unsigned int v40 = v28;
                uint64_t v42 = 0;
                uint64_t v43 = 0;
                llvm::MachineInstr::addOperand((llvm::MachineInstr *)v10, v16, (const llvm::MachineOperand *)&v39);
                uint64_t v41 = 0;
                uint64_t v42 = v25;
                int v39 = 4;
                llvm::MachineInstr::addOperand((llvm::MachineInstr *)v10, v16, (const llvm::MachineOperand *)&v39);
              }
            }
            v23 += 4;
          }
        }
        if (v15)
        {
          llvm::MachineInstr::removeOperand((char *)v10, v15 + 1);
          llvm::MachineInstr::removeOperand((char *)v10, v15);
        }
LABEL_44:
        if (!v10 || (*(unsigned char *)v10 & 4) == 0)
        {
          while ((*(_WORD *)(v10 + 44) & 8) != 0)
            uint64_t v10 = *(void *)(v10 + 8);
        }
        uint64_t v10 = *(void *)(v10 + 8);
      }
      uint64_t v7 = v35 + 1;
    }
    while (v35 + 1 != v34);
  }
}

void llvm::TailDuplicator::removeDeadBlock(int a1, llvm::MachineBasicBlock *this, uint64_t a3)
{
  uint64_t v5 = (char *)this + 48;
  uint64_t v6 = *((void *)this + 7);
  if ((llvm::MachineBasicBlock *)v6 != (llvm::MachineBasicBlock *)((char *)this + 48))
  {
    uint64_t v7 = (int32x2_t *)*((void *)this + 4);
    do
    {
      if (llvm::MachineInstr::shouldUpdateCallSiteInfo((llvm::MachineInstr *)v6)) {
        llvm::MachineFunction::eraseCallSiteInfo(v7, (const llvm::MachineInstr *)v6);
      }
      if (!v6 || (*(unsigned char *)v6 & 4) == 0)
      {
        while ((*(_WORD *)(v6 + 44) & 8) != 0)
          uint64_t v6 = *(void *)(v6 + 8);
      }
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while ((char *)v6 != v5);
  }
  if (a3) {
    (*(void (**)(void, llvm::MachineBasicBlock *))a3)(*(void *)(a3 + 8), this);
  }
  while (1)
  {
    uint64_t v8 = *((void *)this + 12);
    if (*((void *)this + 11) == v8) {
      break;
    }
    llvm::MachineBasicBlock::removeSuccessor((uint64_t)this, (char *)(v8 - 8), 0);
  }

  llvm::MachineBasicBlock::eraseFromParent(this);
}

uint64_t llvm::TailDuplicator::tailDuplicateBlocks(llvm::TailDuplicator *this, llvm::MachineBasicBlock *a2)
{
  if (*((unsigned char *)this + 64)) {
    BOOL v3 = byte_1EBD060C8 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    sub_1CC49A7B0(*((void *)this + 5), 1);
  }
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = (llvm::TailDuplicator *)(v4 + 320);
  uint64_t v6 = *(llvm::TailDuplicator **)(*(void *)(v4 + 328) + 8);
  if (v6 == (llvm::TailDuplicator *)(v4 + 320))
  {
    LOBYTE(v7) = 0;
  }
  else
  {
    int v7 = 0;
    do
    {
      if (!dword_1EBD06188) {
        break;
      }
      uint64_t v8 = (llvm::TailDuplicator *)*((void *)v6 + 1);
      int isSimpleBB = llvm::TailDuplicator::isSimpleBB(v6, a2);
      if (llvm::TailDuplicator::shouldTailDuplicate(this, isSimpleBB, v6)) {
        v7 |= llvm::TailDuplicator::tailDuplicateAndUpdate((uint64_t)this, isSimpleBB, (uint64_t)v6, 0, 0, 0, 0);
      }
      uint64_t v6 = v8;
    }
    while (v8 != v5);
  }
  if (*((unsigned char *)this + 64)) {
    BOOL v10 = byte_1EBD060C8 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    sub_1CC49A7B0(*((void *)this + 5), 0);
  }
  return v7 & 1;
}

uint64_t llvm::TailDuplicator::isSimpleBB(llvm::TailDuplicator *this, llvm::MachineBasicBlock *a2)
{
  if (((*((void *)this + 12) - *((void *)this + 11)) & 0x7FFFFFFF8) != 8
    || *((void *)this + 8) == *((void *)this + 9))
  {
    return 0;
  }
  uint64_t v3 = 1;
  FirstNonDebugInstr = llvm::MachineBasicBlock::getFirstNonDebugInstr(this, 1);
  if ((char *)this + 48 == FirstNonDebugInstr) {
    return v3;
  }

  return sub_1CD50C018((uint64_t)FirstNonDebugInstr, 1);
}

uint64_t llvm::TailDuplicator::shouldTailDuplicate(llvm::TailDuplicator *this, int a2, llvm::MachineBasicBlock *a3)
{
  v38[16] = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 65) && llvm::MachineBasicBlock::getFallThrough(a3)) {
    return 0;
  }
  uint64_t v6 = (llvm::MachineBasicBlock **)*((void *)a3 + 11);
  int v7 = (llvm::MachineBasicBlock **)*((void *)a3 + 12);
  if (v6 != v7)
  {
    while (*v6 != a3)
    {
      if (++v6 == v7)
      {
        uint64_t v6 = (llvm::MachineBasicBlock **)*((void *)a3 + 12);
        break;
      }
    }
  }
  if (v6 != v7) {
    return 0;
  }
  uint64_t v10 = **((void **)this + 5);
  if ((llvm::Function::hasFnAttribute(v10, 42) & 1) != 0
    || (llvm::Function::hasFnAttribute(v10, 15) & 1) != 0
    || ((shouldOptimizeForSize = llvm::shouldOptimizeForSize(a3, *((void *)this + 7), *((llvm::MBFIWrapper **)this + 6)), *((_DWORD *)this + 17))? (unsigned int v12 = *((_DWORD *)this + 17)): (unsigned int v12 = dword_1EBCD4218), shouldOptimizeForSize))
  {
    unsigned int v12 = 1;
  }
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  v37[0] = v38;
  v37[1] = (void *)0x400000000;
  if (!(*(unsigned int (**)(void, llvm::MachineBasicBlock *, uint64_t *, uint64_t *, void **, void))(**(void **)this + 248))(*(void *)this, a3, &v36, &v35, v37, 0)|| !llvm::MachineBasicBlock::getFallThrough(a3))
  {
    int v13 = (char *)a3 + 48;
    unint64_t v14 = *((void *)a3 + 6) & 0xFFFFFFFFFFFFFFF8;
    if ((llvm::MachineBasicBlock *)((char *)a3 + 48) != (llvm::MachineBasicBlock *)v14)
    {
      if (v14 && (*(unsigned char *)v14 & 4) != 0)
      {
        __int16 v15 = *(_WORD *)(v14 + 44);
      }
      else
      {
        while (1)
        {
          __int16 v15 = *(_WORD *)(v14 + 44);
          if ((v15 & 4) == 0) {
            break;
          }
          unint64_t v14 = *(void *)v14 & 0xFFFFFFFFFFFFFFF8;
        }
      }
      int v16 = v15 & 0xC;
      int v17 = v15 & 4;
      if (v16) {
        BOOL v18 = v17 == 0;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18)
      {
        if (!llvm::MachineInstr::hasPropertyInBundle(v14, 2048, 1)) {
          goto LABEL_34;
        }
      }
      else if ((*(unsigned char *)(*(void *)(v14 + 16) + 9) & 8) == 0)
      {
        goto LABEL_34;
      }
      if (*((unsigned char *)this + 64)) {
        unsigned int v12 = dword_1EBCD42D8;
      }
      int v19 = 1;
      goto LABEL_35;
    }
LABEL_34:
    int v19 = 0;
LABEL_35:
    uint64_t v20 = *((void *)a3 + 7);
    if ((char *)v20 == v13)
    {
LABEL_73:
      for (uint64_t i = *((void *)a3 + 11); i != *((void *)a3 + 12); i += 8)
      {
        for (uint64_t j = *(void *)(*(void *)i + 56); j != *(void *)i + 48; uint64_t j = *(void *)(j + 8))
        {
          int v30 = **(unsigned __int16 **)(j + 16);
          if (v30 != 69 && v30 != 0) {
            break;
          }
          int v32 = *(_DWORD *)(j + 40);
          uint64_t v33 = *(void *)(j + 32);
          if (v32 == 1)
          {
LABEL_83:
            unsigned int v34 = 0;
          }
          else
          {
            unsigned int v34 = 1;
            while (*(llvm::MachineBasicBlock **)(v33 + 32 * (v34 + 1) + 16) != a3)
            {
              v34 += 2;
              if (v32 == v34) {
                goto LABEL_83;
              }
            }
          }
          if ((*(_DWORD *)(v33 + 32 * v34) & 0xFFF00) != 0) {
            goto LABEL_20;
          }
          if ((*(unsigned char *)j & 4) == 0)
          {
            while ((*(_WORD *)(j + 44) & 8) != 0)
              uint64_t j = *(void *)(j + 8);
          }
        }
      }
      if (((v19 | a2) & 1) == 0 && *((unsigned char *)this + 64)) {
        uint64_t canCompletelyDuplicateBB = llvm::TailDuplicator::canCompletelyDuplicateBB(this, a3);
      }
      else {
        uint64_t canCompletelyDuplicateBB = 1;
      }
      goto LABEL_21;
    }
    unsigned int v21 = 0;
    while (1)
    {
      if ((*(_WORD *)(v20 + 44) & 0xC) != 0 && (*(_WORD *)(v20 + 44) & 4) == 0)
      {
        if (!llvm::MachineInstr::hasPropertyInBundle(v20, 0x800000, 1)) {
          goto LABEL_47;
        }
      }
      else if ((*(unsigned char *)(*(void *)(v20 + 16) + 10) & 0x80) == 0)
      {
        goto LABEL_47;
      }
      unsigned int v23 = *(_DWORD *)(*(void *)(*((void *)a3 + 4) + 8) + 484) - 3;
      if (v23 < 0x1F && ((0x7E000111u >> v23) & 1) != 0 || **(_WORD **)(v20 + 16) != 3) {
        break;
      }
LABEL_47:
      if (sub_1CBA0BBC0(v20, 1)) {
        break;
      }
      if (!*((unsigned char *)this + 64)) {
        goto LABEL_60;
      }
      __int16 v24 = *(_WORD *)(v20 + 44);
      int v25 = v24 & 0xC;
      if ((v24 & 0xC) == 0 || (v24 & 4) != 0)
      {
        if ((*(unsigned char *)(*(void *)(v20 + 16) + 8) & 0x20) != 0) {
          break;
        }
      }
      else
      {
        if (llvm::MachineInstr::hasPropertyInBundle(v20, 32, 1)) {
          break;
        }
        if (!*((unsigned char *)this + 64)) {
          goto LABEL_60;
        }
        __int16 v24 = *(_WORD *)(v20 + 44);
        int v25 = v24 & 0xC;
      }
      if (!v25 || (v24 & 4) != 0)
      {
        if ((*(unsigned char *)(*(void *)(v20 + 16) + 8) & 0x80) != 0) {
          break;
        }
      }
      else if (llvm::MachineInstr::hasPropertyInBundle(v20, 128, 1))
      {
        break;
      }
LABEL_60:
      BOOL v26 = *(unsigned __int16 **)(v20 + 16);
      unsigned int v27 = *v26;
      if (v27 <= 0x13)
      {
        if (*v26)
        {
          if (v27 == 2) {
            break;
          }
LABEL_66:
          if ((v26[4] & 0x10) == 0) {
            ++v21;
          }
        }
      }
      else if (v27 != 69)
      {
        if (v27 != 20) {
          goto LABEL_66;
        }
        v21 += llvm::MachineInstr::getBundleSize((llvm::MachineInstr *)v20);
      }
      if (v21 > v12) {
        break;
      }
      if ((*(unsigned char *)v20 & 4) == 0)
      {
        while ((*(_WORD *)(v20 + 44) & 8) != 0)
          uint64_t v20 = *(void *)(v20 + 8);
      }
      uint64_t v20 = *(void *)(v20 + 8);
      if ((char *)v20 == v13) {
        goto LABEL_73;
      }
    }
  }
LABEL_20:
  uint64_t canCompletelyDuplicateBB = 0;
LABEL_21:
  if (v37[0] != v38) {
    free(v37[0]);
  }
  return canCompletelyDuplicateBB;
}

void llvm::TailDuplicator::processPHI(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v13 = *(void *)(a2 + 32);
  unsigned int v14 = *(_DWORD *)(v13 + 4);
  int v15 = *(_DWORD *)(a2 + 40);
  if (v15 == 1)
  {
    unsigned int v16 = 0;
    unsigned int v17 = *(_DWORD *)(v13 + 4);
  }
  else
  {
    unsigned int v16 = 1;
    while (*(void *)(v13 + 32 * (v16 + 1) + 16) != a4)
    {
      v16 += 2;
      if (v15 == v16)
      {
        unsigned int v16 = 0;
        break;
      }
    }
    unsigned int v17 = *(_DWORD *)(v13 + 32 * v16 + 4);
  }
  unint64_t v18 = (unint64_t)*(unsigned int *)(v13 + 32 * v16) >> 8;
  int v19 = (*(_DWORD *)(v13 + 32 * v16) >> 8) & 0xFFF;
  unint64_t v20 = *(void *)(*(void *)(a1[4] + 24) + 16 * (v14 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
  LODWORD(v31[0]) = *(_DWORD *)(v13 + 4);
  uint64_t v21 = v17 | ((v18 & 0xFFF) << 32);
  *(uint64_t *)((char *)v31 + 4) = v21;
  uint64_t v32 = v31[0];
  int v33 = v18 & 0xFFF;
  sub_1CD46AFB4((uint64_t)v31, a5, (int *)&v32, (uint64_t *)((char *)&v32 + 4));
  unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(a1[4], v20, "", 0);
  LODWORD(v31[0]) = VirtualRegister;
  *(uint64_t *)((char *)v31 + 4) = v21;
  sub_1CB839378(a6, v31[0], v19);
  if (sub_1CC49AD24(v14, a3, a1[4])) {
    goto LABEL_9;
  }
  int v23 = *(_DWORD *)(a7 + 16);
  if (!v23) {
    goto LABEL_10;
  }
  int v24 = v23 - 1;
  unsigned int v25 = v24 & (37 * v14);
  int v26 = *(_DWORD *)(*(void *)a7 + 4 * v25);
  if (v14 == v26)
  {
LABEL_9:
    llvm::TailDuplicator::addSSAUpdateEntry((uint64_t)a1, v14, VirtualRegister, a4);
  }
  else
  {
    int v27 = 1;
    while (v26 != -1)
    {
      unsigned int v28 = v25 + v27++;
      unsigned int v25 = v28 & v24;
      int v26 = *(_DWORD *)(*(void *)a7 + 4 * v25);
      if (v14 == v26) {
        goto LABEL_9;
      }
    }
  }
LABEL_10:
  if (a8)
  {
    llvm::MachineInstr::removeOperand((char *)a2, v16 + 1);
    llvm::MachineInstr::removeOperand((char *)a2, v16);
    if (*(_DWORD *)(a2 + 40) == 1)
    {
      if (*(unsigned char *)(a3 + 185))
      {
        *(void *)(a2 + 16) = *(void *)(*a1 + 8) + 480;
      }
      else
      {
        llvm::MachineInstr::eraseFromParent((llvm::MachineInstr *)a2);
      }
    }
  }
}

void llvm::TailDuplicator::duplicateInstruction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int32x2_t *a5, uint64_t a6)
{
  if (**(_WORD **)(a2 + 16) == 3)
  {
    llvm::MachineBasicBlock::findDebugLoc(a4, *(void *)(a4 + 56), &v56);
    uint64_t v9 = sub_1CB84B588(a4, (unint64_t *)(a4 + 48), &v56, *(void *)(*(void *)a1 + 8) + 144);
    int v11 = v10;
    int v12 = *(_DWORD *)(*(void *)(a2 + 32) + 16);
    LODWORD(v58) = 16;
    *((void *)&v58 + 1) = 0;
    LODWORD(v59) = v12;
    llvm::MachineInstr::addOperand(v10, v9, (const llvm::MachineOperand *)&v58);
    *((_WORD *)v11 + 22) = *((_WORD *)v11 + 22) & 0xC | *(_WORD *)(a2 + 44) & 0xFFF3;
    if (v56) {
      llvm::MetadataTracking::untrack((uint64_t)&v56, v56);
    }
    return;
  }
  uint64_t v14 = (*(uint64_t (**)(void))(**(void **)a1 + 184))();
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v15 = v14;
    uint64_t v16 = *(unsigned int *)(v14 + 40);
    if (v16)
    {
      uint64_t v17 = 0;
      char v55 = a5;
      do
      {
        unint64_t v18 = (unsigned int *)(*(void *)(v15 + 32) + 32 * v17);
        if (*v18) {
          goto LABEL_9;
        }
        unsigned int v19 = v18[1];
        if ((v19 & 0x80000000) == 0) {
          goto LABEL_9;
        }
        if ((*v18 & 0x1000000) != 0)
        {
          unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*(void *)(a1 + 32), *(void *)(*(void *)(*(void *)(a1 + 32) + 24) + 16 * (v19 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
          uint64_t v35 = VirtualRegister;
          llvm::MachineOperand::setReg((uint64_t)v18, VirtualRegister);
          LODWORD(v58) = v19;
          *(void *)((char *)&v58 + 4) = v35;
          uint64_t v56 = (unsigned __int8 *)v58;
          int v57 = 0;
          a5 = v55;
          sub_1CD46AFB4((uint64_t)&v58, (uint64_t)v55, (int *)&v56, (unsigned __int8 **)((char *)&v56 + 4));
          if ((sub_1CC49AD24(v19, a3, *(void *)(a1 + 32)) & 1) == 0)
          {
            int v45 = *(_DWORD *)(a6 + 16);
            if (!v45) {
              goto LABEL_9;
            }
            int v46 = v45 - 1;
            unsigned int v47 = v46 & (37 * v19);
            int v48 = *(_DWORD *)(*(void *)a6 + 4 * v47);
            if (v19 != v48)
            {
              int v49 = 1;
              while (v48 != -1)
              {
                unsigned int v50 = v47 + v49++;
                unsigned int v47 = v50 & v46;
                int v48 = *(_DWORD *)(*(void *)a6 + 4 * v47);
                if (v19 == v48) {
                  goto LABEL_30;
                }
              }
              goto LABEL_9;
            }
          }
LABEL_30:
          llvm::TailDuplicator::addSSAUpdateEntry(a1, v19, v35, a4);
          goto LABEL_9;
        }
        int32x2_t v20 = *a5;
        unsigned __int32 v21 = a5[2].u32[0];
        if (v21)
        {
          unsigned int v22 = (v21 - 1) & (37 * v19);
          int v23 = (int *)(*(void *)&v20 + 12 * v22);
          int v24 = *v23;
          if (v19 == *v23) {
            goto LABEL_15;
          }
          int v51 = 1;
          while (v24 != -1)
          {
            unsigned int v52 = v22 + v51++;
            unsigned int v22 = v52 & (v21 - 1);
            int v23 = (int *)(*(void *)&v20 + 12 * v22);
            int v24 = *v23;
            if (v19 == *v23) {
              goto LABEL_15;
            }
          }
        }
        int v23 = (int *)(*(void *)&v20 + 12 * v21);
LABEL_15:
        if (v23 != (int *)(*(void *)&v20 + 12 * v21))
        {
          unsigned int v25 = *(void **)(a1 + 32);
          uint64_t v26 = v25[3];
          uint64_t v27 = *(void *)(v26 + 16 * (v19 & 0x7FFFFFFF));
          unint64_t v28 = v27 & 0xFFFFFFFFFFFFFFF8;
          int v29 = v23[1];
          if (v23[2])
          {
            uint64_t v30 = (*(uint64_t (**)(void, unint64_t, unint64_t))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *(void *)(v26 + 16 * (v29 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, v28);
            if (v30)
            {
              llvm::MachineRegisterInfo::setRegClass(*(void *)(a1 + 32), v23[1], v30);
              goto LABEL_19;
            }
LABEL_31:
            uint64_t RegClassConstraint = llvm::MachineInstr::getRegClassConstraint((llvm::MachineInstr *)a2, v17, *(const llvm::TargetInstrInfo **)a1, *(const llvm::TargetRegisterInfo **)(a1 + 8));
            if (RegClassConstraint) {
              uint64_t v37 = RegClassConstraint;
            }
            else {
              uint64_t v37 = v28;
            }
            unsigned int v38 = llvm::MachineRegisterInfo::createVirtualRegister(*(void *)(a1 + 32), v37, "", 0);
            uint64_t v39 = v38;
            unsigned int v40 = sub_1CB84B030(a4, v15, (unsigned __int8 **)(v15 + 56), *(void *)(*(void *)a1 + 8) + 912, v38);
            int v41 = v23[1];
            int v42 = v23[2];
            *((void *)&v58 + 1) = 0;
            uint64_t v59 = 0;
            uint64_t v60 = 0;
            LODWORD(v58) = (v42 & 0xFFF) << 8;
            DWORD1(v58) = v41;
            llvm::MachineInstr::addOperand(v43, v40, (const llvm::MachineOperand *)&v58);
            *int v23 = -2;
            v55[1] = vadd_s32(v55[1], (int32x2_t)0x1FFFFFFFFLL);
            LODWORD(v58) = v19;
            *(void *)((char *)&v58 + 4) = v39;
            uint64_t v56 = (unsigned __int8 *)v58;
            int v57 = 0;
            sub_1CD46AFB4((uint64_t)&v58, (uint64_t)v55, (int *)&v56, (unsigned __int8 **)((char *)&v56 + 4));
            unsigned int v44 = v39;
            a5 = v55;
            llvm::MachineOperand::setReg((uint64_t)v18, v44);
            unsigned int v33 = *v18;
          }
          else
          {
            if (!llvm::MachineRegisterInfo::constrainRegClass(v25, v29, v27 & 0xFFFFFFFFFFFFFFF8, 0)) {
              goto LABEL_31;
            }
LABEL_19:
            llvm::MachineOperand::setReg((uint64_t)v18, v23[1]);
            unsigned int v31 = *v18;
            int v32 = v23[2];
            if (((*v18 >> 8) & 0xFFF) != 0)
            {
              a5 = v55;
              if (v32)
              {
                LOWORD(v32) = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 208))(*(void *)(a1 + 8));
                unsigned int v31 = *v18;
              }
              else
              {
                int v32 = (v31 >> 8) & 0xFFF;
              }
            }
            else
            {
              a5 = v55;
            }
            unsigned int v33 = v31 & 0xFFF000FF | ((v32 & 0xFFF) << 8);
          }
          *unint64_t v18 = v33 & 0xFBFFFFFF;
        }
LABEL_9:
        ++v17;
      }
      while (v17 != v16);
    }
  }
}

uint64_t llvm::TailDuplicator::canCompletelyDuplicateBB(llvm::TailDuplicator *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a2 + 8);
  uint64_t v3 = *((void *)a2 + 9);
  if (v2 == v3) {
    return 1;
  }
  while (((*(void *)(*(void *)v2 + 96) - *(void *)(*(void *)v2 + 88)) & 0x7FFFFFFF0) == 0
       && !(*(unsigned int (**)(void))(**(void **)this + 248))())
  {
    v2 += 8;
    if (v2 == v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t llvm::TailDuplicator::canTailDuplicate(llvm::TailDuplicator *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  v10[16] = *MEMORY[0x1E4F143B8];
  if (((*((void *)a3 + 12) - *((void *)a3 + 11)) & 0x7FFFFFFF0) != 0) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = v10;
  uint64_t v9 = 0x400000000;
  int v5 = (*(uint64_t (**)(void, llvm::MachineBasicBlock *, uint64_t *, uint64_t *, void **, void))(**(void **)this + 248))(*(void *)this, a3, &v7, &v6, &v8, 0);
  uint64_t v3 = (v9 == 0) & ~v5;
  if (v8 != v10) {
    free(v8);
  }
  return v3;
}

void llvm::TailDuplicator::appendCopies(uint64_t a1, llvm::MachineBasicBlock *this, uint64_t a3, uint64_t a4)
{
  unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator(this);
  unsigned int v9 = *(_DWORD *)(a3 + 8);
  if (v9)
  {
    uint64_t v10 = (unint64_t *)FirstTerminator;
    uint64_t v11 = *(void *)(*(void *)a1 + 8) + 912;
    int v12 = *(int **)a3;
    uint64_t v13 = *(void *)a3 + 12 * v9;
    do
    {
      int32x2_t v20 = 0;
      uint64_t v14 = sub_1CB85AA4C((uint64_t)this, v10, &v20, v11, *v12);
      uint64_t v16 = v15;
      int v17 = v12[1];
      int v18 = v12[2];
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      v21[0] = (v18 & 0xFFF) << 8;
      v21[1] = v17;
      llvm::MachineInstr::addOperand(v15, v14, (const llvm::MachineOperand *)v21);
      if (v20) {
        llvm::MetadataTracking::untrack((uint64_t)&v20, v20);
      }
      unint64_t v19 = *(unsigned int *)(a4 + 8);
      if (v19 >= *(unsigned int *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a4 + 8 * v19) = v16;
      ++*(_DWORD *)(a4 + 8);
      v12 += 3;
    }
    while (v12 != (int *)v13);
  }
}

llvm::raw_ostream *sub_1CD5818A8(llvm::raw_ostream *a1, llvm::MachineInstr *this)
{
  return a1;
}

void *sub_1CD5818EC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, a1);
    return (void *)a1;
  }
  else
  {
    sub_1CB920400();
    return sub_1CD581944(v4);
  }
}

void *sub_1CD581944(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void sub_1CD5819C8(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD4258, 0, 0);
  dword_1EBCD42D8 = 0;
  qword_1EBCD42E0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD42E8 = 0;
  qword_1EBCD4258 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD42F0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD42F8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD4310 = (uint64_t)&qword_1EBCD42F8;
  llvm::cl::Option::setArgStr(v6, "tail-dup-indirect-size", 0x16uLL);
  xmmword_1EBCD4278 = *a1;
  dword_1EBCD42D8 = **a2;
  byte_1EBCD42EC = 1;
  dword_1EBCD42E8 = dword_1EBCD42D8;
  word_1EBCD4262 = (32 * (*a3 & 3)) | word_1EBCD4262 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD4258);
}

uint64_t sub_1CD581AF0(uint64_t a1, char *a2, _DWORD **a3, _WORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(_DWORD *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = &unk_1F25EA1B0;
  *(void *)(v8 + 144) = 0;
  *(void *)uint64_t v8 = &unk_1F2643F00;
  *(void *)(v8 + 152) = &unk_1F2643DB0;
  *(void *)(v8 + 160) = &unk_1F25EA168;
  *(void *)(v8 + 184) = v8 + 160;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  uint64_t v10 = *a3;
  *(_DWORD *)(a1 + 128) = **a3;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v10;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

_DWORD *sub_1CD581C0C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    uint64_t v14 = 0;
LABEL_6:
    __n128 result = sub_1CD51959C(a2, a3, v14);
    _DWORD *result = *a3;
    *((void *)result + 2) = 0;
    *((void *)result + 3) = 0;
    *((void *)result + 1) = 0;
    *(_OWORD *)(result + 2) = *(_OWORD *)a4;
    *((void *)result + 3) = *(void *)(a4 + 16);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  uint64_t v10 = (37 * *a3) & (v8 - 1);
  __n128 result = (_DWORD *)(*(void *)a2 + 32 * v10);
  int v12 = *result;
  if (*a3 != *result)
  {
    uint64_t v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        uint64_t v15 = result;
      }
      int v18 = v10 + v16++;
      uint64_t v10 = v18 & (v8 - 1);
      __n128 result = (_DWORD *)(v9 + 32 * v10);
      int v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      uint64_t v14 = v15;
    }
    else {
      uint64_t v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 32 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

uint64_t llvm::TargetFrameLowering::enableCalleeSaveSkip(llvm::TargetFrameLowering *this, const llvm::MachineFunction *a2)
{
  return 0;
}

uint64_t llvm::TargetFrameLowering::enableCFIFixup(llvm::TargetFrameLowering *this, llvm::MachineFunction *a2)
{
  uint64_t result = llvm::MachineFunction::needsFrameMoves(a2);
  if (result)
  {
    uint64_t v4 = *(void *)(*((void *)a2 + 1) + 560);
    if (*(_DWORD *)(v4 + 412) == 4)
    {
      int v5 = *(_DWORD *)(v4 + 420);
      return !v5 || v5 == 6;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t llvm::TargetFrameLowering::getFrameIndexReference(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v7 = *(void *)(a2 + 56);
  uint64_t v8 = *(void *)(*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  *a4 = (*(uint64_t (**)(void))(v8 + 552))();
  return *(void *)(v7 + 48)
       + *(void *)(*(void *)(v7 + 8) + 40 * (*(_DWORD *)(v7 + 32) + a3))
       - *(int *)(a1 + 16)
       + *(int *)(v7 + 56);
}

void llvm::TargetInstrInfo::~TargetInstrInfo(llvm::TargetInstrInfo *this)
{
  *(void *)this = &unk_1F26138F8;
  uint64_t v1 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v2;

  *(void *)this = &unk_1F26138F8;
  uint64_t v2 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1F26138F8;
  uint64_t v2 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::TargetInstrInfo::insertNoops(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    int v4 = a4;
    uint64_t v7 = result;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 736))(v7, a2, a3);
      --v4;
    }
    while (v4);
  }
  return result;
}

void llvm::TargetInstrInfo::ReplaceTailWithBranchTo(uint64_t a1, llvm::MachineInstr *this, void *a3)
{
  int v4 = this;
  for (uint64_t i = *((void *)this + 3); ; llvm::MachineBasicBlock::removeSuccessor(i, v7, 0))
  {
    uint64_t v7 = *(char **)(i + 88);
    if (v7 == *(char **)(i + 96)) {
      break;
    }
  }
  uint64_t v8 = (unsigned __int8 *)*((void *)v4 + 7);
  uint64_t v11 = v8;
  if (v8) {
    llvm::MetadataTracking::track((uint64_t)&v11, v8, 2);
  }
  if ((llvm::MachineInstr *)(i + 48) != v4)
  {
    do
    {
      if (!v4 || (uint64_t v9 = v4, (*(unsigned char *)v4 & 4) == 0))
      {
        uint64_t v9 = v4;
        if ((*((_WORD *)v4 + 22) & 8) != 0)
        {
          uint64_t v9 = v4;
          do
            uint64_t v9 = (llvm::MachineInstr *)*((void *)v9 + 1);
          while ((*((_WORD *)v9 + 22) & 8) != 0);
        }
      }
      uint64_t v10 = (llvm::MachineInstr *)*((void *)v9 + 1);
      if (llvm::MachineInstr::shouldUpdateCallSiteInfo(v4)) {
        llvm::MachineFunction::eraseCallSiteInfo(*(int32x2_t **)(i + 32), v4);
      }
      sub_1CC49C000(i, v4);
      int v4 = v10;
    }
    while (v10 != (llvm::MachineInstr *)(i + 48));
  }
  if (*(void **)(i + 8) != a3) {
    (*(void (**)(uint64_t, uint64_t, void *, void, unsigned __int8 **, void, unsigned __int8 **, void))(*(void *)a1 + 272))(a1, i, a3, 0, &v11, 0, &v11, 0);
  }
  llvm::MachineBasicBlock::addSuccessor((void *)i, a3, -1);
  if (v11) {
    llvm::MetadataTracking::untrack((uint64_t)&v11, v11);
  }
}

llvm::MachineInstr *llvm::TargetInstrInfo::commuteInstructionImpl(llvm::TargetInstrInfo *this, llvm::MachineInstr *a2, int a3, unsigned int a4, unsigned int a5)
{
  int v5 = a2;
  uint64_t v6 = (_DWORD *)*((void *)a2 + 4);
  if (*(unsigned char *)(*((void *)a2 + 2) + 4))
  {
    if (*v6) {
      return 0;
    }
    int v40 = *(unsigned __int8 *)(*((void *)a2 + 2) + 4);
    unsigned int v45 = v6[1];
    int v8 = (*v6 >> 8) & 0xFFF;
  }
  else
  {
    int v40 = *(unsigned __int8 *)(*((void *)a2 + 2) + 4);
    unsigned int v45 = 0;
    LOWORD(v8) = 0;
  }
  uint64_t v44 = a4;
  uint64_t v9 = (llvm::MachineOperand *)&v6[8 * a4];
  uint64_t v10 = a5;
  uint64_t v11 = &v6[8 * a5];
  unsigned int v12 = *(_DWORD *)v9;
  unsigned int v13 = *v11;
  unsigned int v46 = v11[1];
  unsigned int v14 = *((_DWORD *)v9 + 1);
  unsigned int v42 = v14 - 1;
  __int16 v37 = v8;
  int v36 = v14 - 1 <= 0x3FFFFFFE && llvm::MachineOperand::isRenamable(v9);
  int v16 = (v13 >> 26) & ~HIBYTE(v13) & 1;
  int v43 = (v12 >> 26) & ~HIBYTE(v12) & 1;
  if (v46 - 1 > 0x3FFFFFFE)
  {
    BOOL isRenamable = 0;
    uint64_t v17 = v10;
  }
  else
  {
    uint64_t v17 = v10;
    BOOL isRenamable = llvm::MachineOperand::isRenamable((llvm::MachineOperand *)(*((void *)v5 + 4) + 32 * v10));
  }
  int v18 = v40;
  unsigned int v19 = v14;
  int v20 = a3;
  int v21 = (v12 >> 8) & 0xFFF;
  if (v40)
  {
    if (v45 == v14
      && (uint64_t v22 = *((void *)v5 + 2), *(unsigned __int16 *)(v22 + 2) > a4)
      && (*(_WORD *)(*(void *)(v22 + 40) + 6 * v44 + 4) & 0xF1) == 1)
    {
      int v16 = 0;
      unsigned int v45 = v46;
      __int16 v37 = (v13 >> 8) & 0xFFF;
    }
    else if (v45 == v46)
    {
      uint64_t v23 = *((void *)v5 + 2);
      if (*(unsigned __int16 *)(v23 + 2) > a5)
      {
        uint64_t v24 = v17;
        if ((*(_WORD *)(*(void *)(v23 + 40) + 6 * v17 + 4) & 0xF1) == 1)
        {
          int v43 = 0;
          unsigned int v45 = v14;
          __int16 v37 = (v12 >> 8) & 0xFFF;
        }
        goto LABEL_22;
      }
    }
  }
  uint64_t v24 = v17;
LABEL_22:
  int v41 = v16;
  int v25 = (v13 >> 8) & 0xFFF;
  if (v20) {
    int v5 = (llvm::MachineInstr *)llvm::MachineFunction::CloneMachineInstr(*(llvm::MachineFunction **)(*((void *)v5 + 3) + 32), v5);
  }
  int v26 = v12 & 0x10000000;
  int v27 = v13 & 0x10000000;
  int v28 = v12 & 0x20000000;
  int v39 = v13 & 0x20000000;
  if (v18)
  {
    llvm::MachineOperand::setReg(*((void *)v5 + 4), v45);
    **((_DWORD **)v5 + 4) = **((_DWORD **)v5 + 4) & 0xFFF000FF | ((v37 & 0xFFF) << 8);
  }
  uint64_t v29 = *((void *)v5 + 4) + 32 * v24;
  uint64_t v30 = v24;
  uint64_t v31 = 32 * v24;
  llvm::MachineOperand::setReg(v29, v19);
  llvm::MachineOperand::setReg(*((void *)v5 + 4) + 32 * v44, v46);
  *(_DWORD *)(*((void *)v5 + 4) + v31) = *(_DWORD *)(*((void *)v5 + 4) + v31) & 0xFFF000FF | ((v21 & 0xFFF) << 8);
  *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) = *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) & 0xFFF000FF | ((v25 & 0xFFF) << 8);
  if (v43) {
    int v32 = 0x4000000;
  }
  else {
    int v32 = 0;
  }
  *(_DWORD *)(*((void *)v5 + 4) + v31) = *(_DWORD *)(*((void *)v5 + 4) + v31) & 0xFBFFFFFF | v32;
  if (v41) {
    int v33 = 0x4000000;
  }
  else {
    int v33 = 0;
  }
  *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) = *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) & 0xFBFFFFFF | v33;
  *(_DWORD *)(*((void *)v5 + 4) + v31) = *(_DWORD *)(*((void *)v5 + 4) + v31) & 0xEFFFFFFF | v26;
  *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) = *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) & 0xEFFFFFFF | v27;
  *(_DWORD *)(*((void *)v5 + 4) + v31) = *(_DWORD *)(*((void *)v5 + 4) + v31) & 0xDFFFFFFF | v28;
  *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) = *(_DWORD *)(*((void *)v5 + 4) + 32 * v44) & 0xDFFFFFFF | v39;
  if (v42 <= 0x3FFFFFFE) {
    llvm::MachineOperand::setIsRenamable((unsigned int *)(*((void *)v5 + 4) + 32 * v30), v36);
  }
  if (v46 - 1 <= 0x3FFFFFFE) {
    llvm::MachineOperand::setIsRenamable((unsigned int *)(*((void *)v5 + 4) + 32 * v44), isRenamable);
  }
  return v5;
}

uint64_t llvm::TargetInstrInfo::commuteInstruction(llvm::TargetInstrInfo *this, llvm::MachineInstr *a2, uint64_t a3, int a4, int a5)
{
  int v9 = a5;
  int v10 = a4;
  if ((a4 == -1 || a5 == -1)
    && !(*(unsigned int (**)(llvm::TargetInstrInfo *, llvm::MachineInstr *, int *, int *))(*(void *)this + 200))(this, a2, &v10, &v9))
  {
    return 0;
  }
  else
  {
    return (*(uint64_t (**)(llvm::TargetInstrInfo *, llvm::MachineInstr *, uint64_t))(*(void *)this + 40))(this, a2, a3);
  }
}

BOOL llvm::TargetInstrInfo::findCommutedOpIndices(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, llvm::TargetInstrInfo *a3, unsigned int *a4)
{
  uint64_t v4 = *((void *)a2 + 2);
  if ((*(unsigned char *)(v4 + 11) & 2) == 0) {
    return 0;
  }
  BOOL result = llvm::TargetInstrInfo::fixCommutedOpIndices(a3, a4, (unsigned int *)*(unsigned __int8 *)(v4 + 4), *(unsigned __int8 *)(v4 + 4) + 1);
  if (result)
  {
    uint64_t v9 = *((void *)a2 + 4);
    if (!*(unsigned char *)(v9 + 32 * *(unsigned int *)a3)) {
      return *(unsigned __int8 *)(v9 + 32 * *a4) == 0;
    }
    return 0;
  }
  return result;
}

uint64_t llvm::TargetInstrInfo::PredicateInstruction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a2 + 16);
  if ((*(_WORD *)(a2 + 44) & 0xC) != 0 && (*(_WORD *)(a2 + 44) & 4) == 0)
  {
    uint64_t v16 = *(void *)(a2 + 16);
    uint64_t v17 = a2;
    while ((*(unsigned char *)(v16 + 10) & 0x40) != 0 || *(_WORD *)v16 == 20)
    {
      if ((*(_WORD *)(v17 + 44) & 8) == 0) {
        goto LABEL_6;
      }
      uint64_t v17 = *(void *)(v17 + 8);
      uint64_t v16 = *(void *)(v17 + 16);
    }
  }
  else if ((*(unsigned char *)(v5 + 10) & 0x40) != 0)
  {
LABEL_6:
    uint64_t v7 = *(unsigned int *)(a2 + 40);
    if (v7)
    {
      uint64_t v8 = 0;
      char v9 = 0;
      unsigned int v10 = 0;
      uint64_t v11 = 32 * v7;
      for (uint64_t i = 2; (*(unsigned char *)(*(void *)(v5 + 40) + i) & 2) == 0; i += 6)
      {
LABEL_17:
        v8 += 32;
        if (v11 == v8) {
          return v9 & 1;
        }
      }
      uint64_t v13 = *(void *)(a2 + 32);
      uint64_t v14 = v13 + v8;
      int v15 = *(unsigned __int8 *)(v13 + v8);
      if (v15 == 4)
      {
        *(void *)(v14 + 16) = *(void *)(a3 + 32 * v10 + 16);
      }
      else if (v15 == 1)
      {
        *(void *)(v13 + v8 + 16) = *(void *)(a3 + 32 * v10 + 16);
      }
      else
      {
        if (*(unsigned char *)(v13 + v8))
        {
LABEL_16:
          ++v10;
          goto LABEL_17;
        }
        llvm::MachineOperand::setReg(v14, *(_DWORD *)(a3 + 32 * v10 + 4));
      }
      char v9 = 1;
      goto LABEL_16;
    }
  }
  char v9 = 0;
  return v9 & 1;
}

BOOL llvm::TargetInstrInfo::hasLoadFromStackSlot(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 8);
  unint64_t v6 = *(void *)(a2 + 48);
  uint64_t v4 = (void *)(a2 + 48);
  uint64_t v5 = v6;
  if (v6 < 8)
  {
    unint64_t v8 = 0;
LABEL_16:
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    goto LABEL_17;
  }
  if ((v5 & 7) != 0)
  {
    if ((v5 & 0xFFFFFFFFFFFFFFF8) != 0 && (v5 & 7) == 3) {
      unint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    }
    else {
      unint64_t v8 = 0;
    }
  }
  else
  {
    unint64_t v8 = (unint64_t)v4;
    v5 &= 0xFFFFFFFFFFFFFFF8;
    *uint64_t v4 = v5;
    if (!v5)
    {
      unint64_t v8 = (unint64_t)v4;
      uint64_t v4 = 0;
      goto LABEL_17;
    }
  }
  if ((v5 & 7) == 0)
  {
    *uint64_t v4 = v5 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v5 = 1;
    goto LABEL_17;
  }
  char v9 = (int *)(v5 & 0xFFFFFFFFFFFFFFF8);
  if ((v5 & 7) != 3 || v9 == 0) {
    goto LABEL_16;
  }
  uint64_t v11 = *v9;
  uint64_t v4 = v9 + 2;
  uint64_t v5 = v11;
LABEL_17:
  unsigned int v12 = &v4[v5];
  while ((void *)v8 != v12)
  {
    uint64_t v13 = *(void **)v8;
    if ((*(_WORD *)(*(void *)v8 + 32) & 1) != 0 && (*v13 & 4) != 0)
    {
      unint64_t v14 = *v13 & 0xFFFFFFFFFFFFFFF8;
      if (v14)
      {
        if (*(_DWORD *)(v14 + 8) == 4)
        {
          unint64_t v15 = *(unsigned int *)(a3 + 8);
          if (v15 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a3 + 8 * v15) = v13;
          ++*(_DWORD *)(a3 + 8);
        }
      }
    }
    v8 += 8;
  }
  return *(_DWORD *)(a3 + 8) != v3;
}

uint64_t llvm::TargetInstrInfo::getStackSlotRange(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, int *a5, llvm::MachineFunction *a6)
{
  uint64_t v11 = (*(uint64_t (**)(void *))(**((void **)a6 + 2) + 176))(*((void **)a6 + 2));
  uint64_t v12 = v11;
  if (!a3)
  {
    int v15 = 0;
    *a4 = *(_DWORD *)(*(void *)(v11 + 264)
                    + 24
                    * (*(unsigned __int16 *)(*(void *)a2 + 24)
                     + *(_DWORD *)(v11 + 272) * ((*(void *)(v11 + 248) - *(void *)(v11 + 240)) >> 3))
                    + 4) >> 3;
LABEL_5:
    *a5 = v15;
    return 1;
  }
  unsigned int v13 = *(unsigned __int16 *)(*(void *)(v11 + 96) + 4 * a3 + 2);
  if ((v13 & 7) != 0) {
    return 0;
  }
  unsigned int SubRegIdxOffset = llvm::MCRegisterInfo::getSubRegIdxOffset((llvm::MCRegisterInfo *)(v11 + 8), a3);
  if ((SubRegIdxOffset & 0x80000007) != 0) {
    return 0;
  }
  *a4 = v13 >> 3;
  *a5 = SubRegIdxOffset >> 3;
  if (*(unsigned char *)llvm::MachineFunction::getDataLayout(a6))
  {
    int v15 = (*(_DWORD *)(*(void *)(v12 + 264)
                     + 24
                     * (*(unsigned __int16 *)(*(void *)a2 + 24)
                      + *(_DWORD *)(v12 + 272) * ((*(void *)(v12 + 248) - *(void *)(v12 + 240)) >> 3))
                     + 4) >> 3)
        - (*a5
         + *a4);
    goto LABEL_5;
  }
  return 1;
}

BOOL llvm::TargetInstrInfo::produceSameValue(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, const llvm::MachineInstr *a3, const llvm::MachineRegisterInfo *a4)
{
  return llvm::MachineInstr::isIdenticalTo((uint64_t)a2, (uint64_t)a3, 3);
}

uint64_t llvm::TargetInstrInfo::getPatchpointUnfoldableRange(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2)
{
  int v3 = **((unsigned __int16 **)a2 + 2);
  if (v3 == 31)
  {
    int NumExplicitDefs = llvm::MachineInstr::getNumExplicitDefs(a2);
    uint64_t v7 = *(void *)(*((void *)a2 + 2) + 32);
    if (v7)
    {
      unsigned int v8 = -1;
      do
        ++v8;
      while (*(_WORD *)(v7 + 2 * v8));
    }
    else
    {
      unsigned int v8 = 0;
    }
    uint64_t v4 = v8 + NumExplicitDefs;
    int v9 = llvm::MachineInstr::getNumExplicitDefs(a2);
    uint64_t v10 = *(void *)(*((void *)a2 + 2) + 32);
    if (v10)
    {
      unsigned int v11 = -1;
      do
        ++v11;
      while (*(_WORD *)(v10 + 2 * v11));
    }
    else
    {
      unsigned int v11 = 0;
    }
    uint64_t v5 = v11 + v9 + *(_DWORD *)(*((void *)a2 + 4) + 32 * (v11 + v9 + 2) + 16) + 4;
  }
  else if (v3 == 27)
  {
    llvm::PatchPointOpers::PatchPointOpers((uint64_t)&v13, a2);
    uint64_t v4 = 0;
    uint64_t v5 = v14 + *(_DWORD *)(*(void *)(v13 + 32) + 32 * v14 + 112) + 5;
  }
  else
  {
    llvm::StackMapOpers::StackMapOpers(&v13, a2);
    uint64_t v4 = 0;
    uint64_t v5 = 2;
  }
  return v4 | (v5 << 32);
}

uint64_t llvm::TargetInstrInfo::foldMemoryOperand(void *a1, uint64_t *a2, __int32 *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (unsigned __int16 *)a2[2];
  uint64_t v13 = a2[3];
  unsigned __int8 v14 = *(llvm::MachineFunction **)(v13 + 32);
  int v39 = 0;
  LODWORD(v12) = *v12;
  BOOL v15 = v12 > 0x1F;
  unsigned int v16 = (1 << (char)v12) & 0x8A000000;
  BOOL v17 = v15 || v16 == 0;
  if (v17 || !(*(unsigned int (**)(void *, uint64_t, int *))(*a1 + 64))(a1, a5, &v39))
  {
    uint64_t v18 = (*(uint64_t (**)(void *, llvm::MachineFunction *, uint64_t *, __int32 *, size_t, uint64_t *, uint64_t, uint64_t))(*a1 + 600))(a1, v14, a2, a3, a4, a2, a5, a6);
    if (!v18) {
      return v18;
    }
  }
  else
  {
    uint64_t v18 = (uint64_t)sub_1CC49CD34(v14, (uint64_t)a2, a3, a4, v39, a1);
    if (!v18) {
      return v18;
    }
    llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)(v13 + 40), v18);
    unint64_t v19 = *a2 & 0xFFFFFFFFFFFFFFF8;
    *(void *)uint64_t v18 = v19 | *(void *)v18 & 7;
    *(void *)(v18 + 8) = a2;
    *(void *)(v19 + 8) = v18;
    *a2 = *a2 & 7 | v18;
  }
  unint64_t v22 = a2[6];
  int v21 = (unint64_t *)(a2 + 6);
  unint64_t v20 = v22;
  if (v22 < 8) {
    goto LABEL_14;
  }
  if ((v20 & 7) == 0)
  {
    v20 &= 0xFFFFFFFFFFFFFFF8;
    *int v21 = v20;
    if (!v20)
    {
      int v21 = 0;
      uint64_t v29 = 0;
      goto LABEL_29;
    }
LABEL_23:
    if ((v20 & 7) != 0)
    {
      int v21 = 0;
      uint64_t v29 = 0;
      if ((v20 & 7) == 3)
      {
        uint64_t v30 = (int *)(v20 & 0xFFFFFFFFFFFFFFF8);
        if (v30)
        {
          uint64_t v29 = *v30;
          int v21 = (unint64_t *)(v30 + 2);
        }
      }
    }
    else
    {
      *int v21 = v20 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v29 = 1;
    }
LABEL_29:
    llvm::MachineInstr::setMemRefs(v18, (uint64_t *)v14, v21, v29);
    unint64_t v33 = *(void *)(a5 + 48);
    int v32 = (llvm::MachineMemOperand **)(a5 + 48);
    uint64_t v31 = v33;
    if (v33 < 8)
    {
      uint64_t v35 = 0;
      int v32 = 0;
      uint64_t v31 = 0;
    }
    else
    {
      if ((v31 & 7) != 0)
      {
        if ((v31 & 0xFFFFFFFFFFFFFFF8) != 0 && (v31 & 7) == 3) {
          uint64_t v35 = (llvm::MachineMemOperand **)((v31 & 0xFFFFFFFFFFFFFFF8) + 8);
        }
        else {
          uint64_t v35 = 0;
        }
        goto LABEL_37;
      }
      uint64_t v35 = v32;
      v31 &= 0xFFFFFFFFFFFFFFF8;
      *int v32 = (llvm::MachineMemOperand *)v31;
      if (v31)
      {
LABEL_37:
        if ((v31 & 7) != 0)
        {
          int v32 = 0;
          if ((v31 & 7) == 3 && (int v36 = (int *)(v31 & 0xFFFFFFFFFFFFFFF8), (v31 & 0xFFFFFFFFFFFFFFF8) != 0))
          {
            uint64_t v31 = *v36;
            int v32 = (llvm::MachineMemOperand **)(v36 + 2);
          }
          else
          {
            uint64_t v31 = 0;
          }
        }
        else
        {
          *int v32 = (llvm::MachineMemOperand *)(v31 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v31 = 1;
        }
        goto LABEL_42;
      }
      uint64_t v35 = v32;
      int v32 = 0;
    }
LABEL_42:
    __int16 v37 = &v32[v31];
    while (v35 != v37)
    {
      unsigned int v38 = *v35++;
      llvm::MachineInstr::addMemOperand((llvm::MachineInstr *)v18, v14, v38);
    }
    return v18;
  }
  if ((v20 & 7) == 3 && (v20 & 0xFFFFFFFFFFFFFFF8) != 0 && *(_DWORD *)(v20 & 0xFFFFFFFFFFFFFFF8)) {
    goto LABEL_23;
  }
LABEL_14:
  unint64_t v25 = *(void *)(a5 + 48);
  uint64_t v24 = (unint64_t *)(a5 + 48);
  unint64_t v23 = v25;
  if (v25 < 8)
  {
    uint64_t v24 = 0;
    uint64_t v26 = 0;
  }
  else if ((v23 & 7) != 0)
  {
    uint64_t v24 = 0;
    uint64_t v26 = 0;
    if ((v23 & 7) == 3)
    {
      int v27 = (int *)(v23 & 0xFFFFFFFFFFFFFFF8);
      if (v27)
      {
        uint64_t v26 = *v27;
        uint64_t v24 = (unint64_t *)(v27 + 2);
      }
    }
  }
  else
  {
    unint64_t *v24 = v23 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v26 = 1;
  }
  llvm::MachineInstr::setMemRefs(v18, (uint64_t *)v14, v24, v26);
  return v18;
}

BOOL llvm::TargetInstrInfo::hasReassociableOperands(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v4 = *((void *)a2 + 4);
  uint64_t v5 = *(void *)(*((void *)a3 + 4) + 40);
  if (*(unsigned char *)(v4 + 32) || (unsigned int v8 = *(_DWORD *)(v4 + 36), (v8 & 0x80000000) == 0)) {
    Uniqueuint64_t VRegDef = 0;
  }
  else {
    Uniqueuint64_t VRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(*(void *)(*((void *)a3 + 4) + 40), v8);
  }
  if (*(unsigned char *)(v4 + 64)) {
    return 0;
  }
  unsigned int v9 = *(_DWORD *)(v4 + 68);
  if ((v9 & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v10 = llvm::MachineRegisterInfo::getUniqueVRegDef(v5, v9);
  BOOL result = 0;
  if (UniqueVRegDef && v10)
  {
    if (*(const llvm::MachineBasicBlock **)(UniqueVRegDef + 24) == a3) {
      return *(void *)(v10 + 24) == (void)a3;
    }
    return 0;
  }
  return result;
}

BOOL llvm::TargetInstrInfo::hasReassociableSibling(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, BOOL *a3)
{
  uint64_t v6 = *((void *)a2 + 3);
  uint64_t v7 = *(void *)(*(void *)(v6 + 32) + 40);
  Uniqueuint64_t VRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(v7, *(_DWORD *)(*((void *)a2 + 4) + 36));
  uint64_t v9 = llvm::MachineRegisterInfo::getUniqueVRegDef(v7, *(_DWORD *)(*((void *)a2 + 4) + 68));
  int v10 = **((unsigned __int16 **)a2 + 2);
  if (**(unsigned __int16 **)(UniqueVRegDef + 16) == v10)
  {
    BOOL v11 = 0;
  }
  else
  {
    BOOL v11 = **(unsigned __int16 **)(v9 + 16) == v10;
    if (**(unsigned __int16 **)(v9 + 16) == v10) {
      Uniqueuint64_t VRegDef = v9;
    }
  }
  *a3 = v11;
  if (**(unsigned __int16 **)(UniqueVRegDef + 16) != v10
    || !(*(unsigned int (**)(llvm::TargetInstrInfo *, uint64_t))(*(void *)this + 536))(this, UniqueVRegDef)|| !(*(unsigned int (**)(llvm::TargetInstrInfo *, uint64_t, uint64_t))(*(void *)this + 544))(this, UniqueVRegDef, v6))
  {
    return 0;
  }
  unsigned int v12 = *(_DWORD *)(*(void *)(UniqueVRegDef + 32) + 4);

  return llvm::MachineRegisterInfo::hasOneNonDBGUse(v7, v12);
}

uint64_t llvm::TargetInstrInfo::isThroughputPattern()
{
  return 0;
}

uint64_t llvm::TargetInstrInfo::reassociateOps(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = *(void *)(*(void *)(a2 + 24) + 32);
  BOOL v11 = *(void **)(v10 + 40);
  unsigned int v12 = (const llvm::TargetInstrInfo *)(*(uint64_t (**)(void))(**(void **)(v10 + 16) + 104))(*(void *)(v10 + 16));
  unsigned int v46 = (llvm::MachineFunction *)v10;
  uint64_t v13 = (const llvm::TargetRegisterInfo *)(*(uint64_t (**)(void))(**(void **)(v10 + 16) + 176))(*(void *)(v10 + 16));
  unsigned int v50 = v12;
  uint64_t RegClassConstraint = llvm::MachineInstr::getRegClassConstraint((llvm::MachineInstr *)a2, 0, v12, v13);
  BOOL v15 = (unsigned int *)((char *)&unk_1CFAC7440 + 16 * a4);
  uint64_t v53 = a3;
  uint64_t v16 = *(void *)(a3 + 32);
  BOOL v17 = (_DWORD *)(v16 + 32 * *v15);
  uint64_t v18 = *(void *)(a2 + 32);
  unint64_t v19 = (_DWORD *)(v16 + 32 * v15[2]);
  int v20 = v17[1];
  int v21 = *(_DWORD *)(v18 + 32 * v15[1] + 4);
  int v22 = v19[1];
  unint64_t v23 = (_DWORD *)(v18 + 32 * v15[3]);
  int v54 = v23[1];
  int v24 = *(_DWORD *)(v18 + 4);
  if (v20 < 0) {
    llvm::MachineRegisterInfo::constrainRegClass(v11, v20, RegClassConstraint, 0);
  }
  if (v21 < 0) {
    llvm::MachineRegisterInfo::constrainRegClass(v11, v21, RegClassConstraint, 0);
  }
  if (v22 < 0) {
    llvm::MachineRegisterInfo::constrainRegClass(v11, v22, RegClassConstraint, 0);
  }
  if (v54 < 0) {
    llvm::MachineRegisterInfo::constrainRegClass(v11, v54, RegClassConstraint, 0);
  }
  if (v24 < 0) {
    llvm::MachineRegisterInfo::constrainRegClass(v11, v24, RegClassConstraint, 0);
  }
  unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister((uint64_t)v11, RegClassConstraint, "", 0);
  v55[0] = (llvm::MachineFunction *)VirtualRegister;
  sub_1CBFFD778(a7, v55, (_DWORD *)v55 + 1, (uint64_t)&v56);
  uint64_t v26 = **(unsigned __int16 **)(a2 + 16);
  int v48 = (*v17 >> 26) & ~HIBYTE(*v17) & 1;
  int v27 = (*v19 >> 26) & ~HIBYTE(*v19) & 1;
  int v28 = (*v23 >> 26) & ~HIBYTE(*v23) & 1;
  uint64_t v29 = a2;
  uint64_t v30 = 3 * v26;
  uint64_t v56 = sub_1CD5834C0(v46, (unsigned __int8 **)(v53 + 56), *((void *)v50 + 1) + 48 * v26, VirtualRegister);
  uint64_t v57 = v31;
  int v32 = sub_1CB89517C(&v56, v22, 8 * v27, 0);
  unint64_t v33 = sub_1CB89517C(v32, v54, 8 * v28, 0)[1];
  *((_WORD *)v33 + 22) = *((_WORD *)v33 + 22) & 0xC | *(_WORD *)(v53 + 44) & 0xFFF3;
  v55[0] = sub_1CD5834C0(v46, (unsigned __int8 **)(v29 + 56), *((void *)v50 + 1) + 16 * v30, v24);
  v55[1] = v34;
  uint64_t v35 = sub_1CB89517C(v55, v20, 8 * v48, 0);
  int v36 = v35[1];
  __int16 v37 = *v35;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  LODWORD(v56) = 0x4000000;
  HIDWORD(v56) = VirtualRegister;
  llvm::MachineInstr::addOperand(v36, v37, (const llvm::MachineOperand *)&v56);
  unsigned int v38 = v35[1];
  *((_WORD *)v38 + 22) = *((_WORD *)v38 + 22) & 0xC | *(_WORD *)(v29 + 44) & 0xFFF3;
  uint64_t result = (*(uint64_t (**)(void))(*(void *)a1 + 568))();
  unsigned int v40 = *(_DWORD *)(a5 + 8);
  if (v40 >= *(_DWORD *)(a5 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a5 + 8 * v40) = v33;
  unsigned int v41 = *(_DWORD *)(a5 + 12);
  unsigned int v42 = *(_DWORD *)(a5 + 8) + 1;
  *(_DWORD *)(a5 + 8) = v42;
  if (v42 >= v41) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a5 + 8 * v42) = v38;
  ++*(_DWORD *)(a5 + 8);
  unsigned int v43 = *(_DWORD *)(a6 + 8);
  if (v43 >= *(_DWORD *)(a6 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a6 + 8 * v43) = v53;
  unsigned int v44 = *(_DWORD *)(a6 + 12);
  unsigned int v45 = *(_DWORD *)(a6 + 8) + 1;
  *(_DWORD *)(a6 + 8) = v45;
  if (v45 >= v44) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a6 + 8 * v45) = v29;
  ++*(_DWORD *)(a6 + 8);
  return result;
}

llvm::MachineFunction *sub_1CD5834C0(llvm::MachineFunction *a1, unsigned __int8 **a2, uint64_t a3, int a4)
{
  uint64_t v7 = *a2;
  uint64_t v10 = v7;
  if (v7) {
    llvm::MetadataTracking::track((uint64_t)&v10, v7, 2);
  }
  unsigned int v8 = llvm::MachineFunction::CreateMachineInstr(a1, a3, &v10, 0);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  v11[0] = 0x1000000;
  v11[1] = a4;
  llvm::MachineInstr::addOperand(v8, a1, (const llvm::MachineOperand *)v11);
  if (v10) {
    llvm::MetadataTracking::untrack((uint64_t)&v10, v10);
  }
  return a1;
}

uint64_t llvm::TargetInstrInfo::genAlternativeCodeSequence(uint64_t a1, uint64_t a2, signed int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  Uniqueuint64_t VRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(*(void *)(*(void *)(*(void *)(a2 + 24) + 32) + 40), *(_DWORD *)(*(void *)(a2 + 32) + 32 * qword_1CFAC7480[a3] + 4));

  return llvm::TargetInstrInfo::reassociateOps(a1, a2, UniqueVRegDef, a3, a4, a5, a6);
}

void llvm::TargetInstrInfo::CreateTargetHazardRecognizer(llvm::TargetInstrInfo *this, const llvm::TargetSubtargetInfo *a2, const llvm::ScheduleDAG *a3)
{
}

void llvm::TargetInstrInfo::CreateTargetPostRAHazardRecognizer()
{
}

uint64_t llvm::TargetInstrInfo::getMemOperandWithOffset(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, const llvm::MachineOperand **a3, uint64_t *a4, BOOL *a5, const llvm::TargetRegisterInfo *a6)
{
  return 0;
}

uint64_t llvm::TargetInstrInfo::getOperandLatency(uint64_t a1, void *a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = a2[12];
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = *(__int16 *)(a3 + 24);
  if ((v7 & 0x80000000) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *(void *)(a1 + 8);
  unsigned int v10 = *(unsigned __int16 *)(v9 + 48 * (unsigned __int16)~(_WORD)v7 + 6);
  int v11 = *(__int16 *)(a5 + 24);
  if (v11 < 0) {
    return sub_1CD583810(a2, v10, a4, *(unsigned __int16 *)(v9 + 48 * (unsigned __int16)~(_WORD)v11 + 6), a6);
  }
  uint64_t v12 = v6 + 10 * v10;
  unsigned int v13 = *(unsigned __int16 *)(v12 + 8);
  unsigned int v14 = *(unsigned __int16 *)(v12 + 6) + a4;
  if (v14 >= v13) {
    return 0xFFFFFFFFLL;
  }
  return *(unsigned int *)(a2[10] + 4 * v14);
}

{
  return sub_1CD583810(a2, *(unsigned __int16 *)(*(void *)(a3 + 16) + 6), a4, *(unsigned __int16 *)(*(void *)(a5 + 16) + 6), a6);
}

uint64_t sub_1CD583810(void *a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  uint64_t v5 = a1[12];
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v5 + 10 * a2;
  unsigned int v7 = *(unsigned __int16 *)(v6 + 8);
  uint64_t v8 = *(unsigned __int16 *)(v6 + 6) + a3;
  if (v8 >= v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = a1[10];
  int v11 = *(_DWORD *)(v10 + 4 * v8);
  if (v11 == -1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = v5 + 10 * a4;
  unsigned int v13 = *(unsigned __int16 *)(v12 + 8);
  uint64_t v14 = *(unsigned __int16 *)(v12 + 6) + a5;
  if (v14 >= v13) {
    return 0xFFFFFFFFLL;
  }
  int v15 = *(_DWORD *)(v10 + 4 * v14);
  if (v15 == -1) {
    return 0xFFFFFFFFLL;
  }
  int v16 = v11 - v15;
  uint64_t result = (v16 + 1);
  if (v16 >= 0)
  {
    uint64_t v18 = a1[11];
    int v19 = *(_DWORD *)(v18 + 4 * v8);
    if (v19)
    {
      if (v19 == *(_DWORD *)(v18 + 4 * v14)) {
        return v16;
      }
      else {
        return result;
      }
    }
  }
  return result;
}

uint64_t llvm::TargetInstrInfo::getInstrLatency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    return 1;
  }
  uint64_t v3 = *(void *)(a2 + 96);
  if (!v3) {
    return 1;
  }
  int v4 = *(__int16 *)(a3 + 24);
  if ((v4 & 0x80000000) == 0) {
    return 1;
  }
  uint64_t v6 = v3 + 10 * *(unsigned __int16 *)(*(void *)(a1 + 8) + 48 * (unsigned __int16)~(_WORD)v4 + 6);
  unsigned int v7 = *(unsigned __int16 *)(v6 + 2);
  unsigned int v8 = *(unsigned __int16 *)(v6 + 4);
  if (v7 == v8) {
    return 0;
  }
  int v9 = 0;
  LODWORD(result) = 0;
  uint64_t v10 = *(void *)(a2 + 72);
  int v11 = (int *)(v10 + 24 * v8);
  uint64_t v12 = (int *)(v10 + 24 * v7);
  do
  {
    int v13 = *v12;
    unsigned int v14 = *v12 + v9;
    if (result <= v14) {
      uint64_t result = v14;
    }
    else {
      uint64_t result = result;
    }
    if (v12[4] >= 0) {
      int v13 = v12[4];
    }
    v9 += v13;
    v12 += 6;
  }
  while (v12 != v11);
  return result;
}

{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int v12;
  unsigned int v13;

  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 96);
    if (v3)
    {
      int v4 = v3 + 10 * *(unsigned __int16 *)(*(void *)(a3 + 16) + 6);
      uint64_t v5 = *(unsigned __int16 *)(v4 + 2);
      uint64_t v6 = *(unsigned __int16 *)(v4 + 4);
      if (v5 == v6)
      {
        return 0;
      }
      else
      {
        unsigned int v8 = 0;
        LODWORD(result) = 0;
        int v9 = *(void *)(a2 + 72);
        uint64_t v10 = (int *)(v9 + 24 * v6);
        int v11 = (int *)(v9 + 24 * v5);
        do
        {
          uint64_t v12 = *v11;
          int v13 = *v11 + v8;
          if (result <= v13) {
            uint64_t result = v13;
          }
          else {
            uint64_t result = result;
          }
          if (v11[4] >= 0) {
            uint64_t v12 = v11[4];
          }
          v8 += v12;
          v11 += 6;
        }
        while (v11 != v10);
      }
    }
    else
    {
      return 1;
    }
  }
  else if (sub_1CBA0BB64(a3, 1))
  {
    return 2;
  }
  else
  {
    return 1;
  }
  return result;
}

uint64_t llvm::TargetInstrInfo::getNumMicroOps(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2) {
    return 1;
  }
  uint64_t v3 = *(void *)(a2 + 96);
  if (!v3) {
    return 1;
  }
  int v4 = *(__int16 *)(v3 + 10 * *(unsigned __int16 *)(*(void *)(a3 + 16) + 6));
  if (v4 < 0) {
    return 1;
  }
  else {
    return v4;
  }
}

uint64_t llvm::TargetInstrInfo::getPredicationCost(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2)
{
  return 0;
}

BOOL llvm::TargetInstrInfo::hasLowDefLatency(llvm::TargetInstrInfo *this, const llvm::TargetSchedModel *a2, const llvm::MachineInstr *a3, int a4)
{
  BOOL result = llvm::TargetSchedModel::hasInstrItineraries(a2);
  if (result)
  {
    uint64_t v8 = *((void *)a2 + 21);
    if (v8)
    {
      uint64_t v9 = v8 + 10 * *(unsigned __int16 *)(*((void *)a3 + 2) + 6);
      unsigned int v10 = *(unsigned __int16 *)(v9 + 8);
      unsigned int v11 = *(unsigned __int16 *)(v9 + 6) + a4;
      if (v11 >= v10) {
        int v12 = -1;
      }
      else {
        int v12 = *(_DWORD *)(*((void *)a2 + 19) + 4 * v11);
      }
      return v12 != -1 && v12 < 2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void llvm::TargetInstrInfo::describeLoadedValue(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  v38[8] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*(void *)(a2 + 24) + 32);
  uint64_t v9 = (const llvm::TargetRegisterInfo *)(*(uint64_t (**)(void))(**(void **)(v8 + 16) + 176))(*(void *)(v8 + 16));
  Context = (void *)llvm::Function::getContext(*(llvm::Function **)v8);
  Impl = llvm::DIExpression::getImpl(Context, 0, 0, 0, 1);
  uint64_t v35 = 0;
  if (**(_WORD **)(a2 + 16) == 19)
  {
    uint64_t v31 = *(void *)(a2 + 32);
    uint64_t v12 = v31;
    int v32 = (_OWORD *)(v31 + 32);
    char v33 = 1;
LABEL_3:
    if (*(_DWORD *)(v12 + 4) != a3)
    {
      char v14 = 0;
      *(unsigned char *)a4 = 0;
      goto LABEL_6;
    }
    long long v13 = v32[1];
    *(_OWORD *)a4 = *v32;
    *(_OWORD *)(a4 + 16) = v13;
    *(void *)(a4 + 32) = Impl;
LABEL_5:
    char v14 = 1;
LABEL_6:
    *(unsigned char *)(a4 + 40) = v14;
    return;
  }
  BOOL v34 = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 416))(&v31, a1, a2);
  if (v33)
  {
    uint64_t v12 = v31;
    goto LABEL_3;
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void))(*(void *)a1 + 432))(&v28, a1, a2, a3);
  if (v30)
  {
    int v15 = v28;
    int v16 = llvm::DIExpression::prepend(Impl, 0, *(uint64_t *)v29);
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = v15;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 32) = v16;
    goto LABEL_5;
  }
  unint64_t v17 = *(void *)(a2 + 48);
  if (v17 < 8)
  {
LABEL_25:
    *(unsigned char *)a4 = 0;
    *(unsigned char *)(a4 + 40) = 0;
    return;
  }
  if ((v17 & 7) != 0)
  {
    if ((*(void *)(a2 + 48) & 7) != 3) {
      goto LABEL_25;
    }
    uint64_t v18 = (_DWORD *)(v17 & 0xFFFFFFFFFFFFFFF8);
    if (!v18 || *v18 != 1) {
      goto LABEL_25;
    }
  }
  else
  {
    *(void *)(a2 + 48) = v17 & 0xFFFFFFFFFFFFFFF8;
  }
  int v19 = (llvm::TargetInstrInfo *)(*(uint64_t (**)(void))(**(void **)(v8 + 16) + 104))(*(void *)(v8 + 16));
  uint64_t v20 = *(void *)(v8 + 56);
  uint64_t v21 = *(void *)(a2 + 48);
  if ((v21 & 7) != 0)
  {
    int v22 = *(uint64_t **)((v21 & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  else
  {
    int v22 = (uint64_t *)(v21 & 0xFFFFFFFFFFFFFFF8);
    *(void *)(a2 + 48) = v21 & 0xFFFFFFFFFFFFFFF8;
  }
  uint64_t v23 = *v22;
  if ((*v22 & 4) == 0) {
    goto LABEL_25;
  }
  if ((v23 & 0xFFFFFFFFFFFFFFF8) == 0) {
    goto LABEL_25;
  }
  if ((*(unsigned int (**)(unint64_t, uint64_t))(*(void *)(v23 & 0xFFFFFFFFFFFFFFF8) + 40))(v23 & 0xFFFFFFFFFFFFFFF8, v20))
  {
    goto LABEL_25;
  }
  int v27 = 0;
  if ((llvm::TargetInstrInfo::getMemOperandWithOffset(v19, (const llvm::MachineInstr *)a2, &v27, &v35, &v34, v9) & 1) == 0
    || v34
    || llvm::MachineInstr::getNumExplicitDefs((llvm::MachineInstr *)a2) != 1)
  {
    goto LABEL_25;
  }
  int v36 = v38;
  uint64_t v37 = 0x800000000;
  llvm::DIExpression::appendOffset((uint64_t)&v36, v35);
  if (v37 >= HIDWORD(v37)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v36 + v37) = 148;
  LODWORD(v37) = v37 + 1;
  unint64_t v24 = sub_1CB8F20C0((uint64_t)v22);
  if (v37 >= HIDWORD(v37)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v36 + v37) = v24;
  LODWORD(v37) = v37 + 1;
  unint64_t v25 = llvm::DIExpression::prependOpcodes(Impl, (unsigned int *)&v36, 0, 0);
  long long v26 = *((_OWORD *)v27 + 1);
  *(_OWORD *)a4 = *(_OWORD *)v27;
  *(_OWORD *)(a4 + 16) = v26;
  *(void *)(a4 + 32) = v25;
  *(unsigned char *)(a4 + 40) = 1;
  if (v36 != v38) {
    free(v36);
  }
}

uint64_t llvm::TargetInstrInfo::getExtractSubregInputs(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (**(_WORD **)(a2 + 16) != 8) {
    return (*(uint64_t (**)(void))(*(void *)a1 + 616))();
  }
  uint64_t v4 = *(void *)(a2 + 32);
  if ((*(unsigned char *)(v4 + 35) & 0x10) != 0) {
    return 0;
  }
  *a4 = *(_DWORD *)(v4 + 36);
  a4[1] = (*(_DWORD *)(v4 + 32) >> 8) & 0xFFF;
  a4[2] = *(void *)(v4 + 80);
  return 1;
}

uint64_t llvm::TargetInstrInfo::getInsertSubregInputs(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  if (**(_WORD **)(a2 + 16) != 9) {
    return (*(uint64_t (**)(void))(*(void *)a1 + 624))();
  }
  uint64_t v5 = *(void *)(a2 + 32);
  if ((*(unsigned char *)(v5 + 67) & 0x10) != 0) {
    return 0;
  }
  *a4 = *(_DWORD *)(v5 + 36);
  a4[1] = (*(_DWORD *)(v5 + 32) >> 8) & 0xFFF;
  *a5 = *(_DWORD *)(v5 + 68);
  a5[1] = (*(_DWORD *)(v5 + 64) >> 8) & 0xFFF;
  a5[2] = *(void *)(v5 + 112);
  return 1;
}

_OWORD *sub_1CD583FB4(uint64_t a1, char a2)
{
  BOOL result = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a2)
  {
    *(void *)&long long v5 = "sideeffect";
    *((void *)&v5 + 1) = 10;
    BOOL result = sub_1CC016940((void **)a1, &v5);
    *(void *)(a1 + 8) = result;
  }
  if ((a2 & 8) != 0)
  {
    *(void *)&long long v5 = "mayload";
    *((void *)&v5 + 1) = 7;
    if ((unint64_t)result >= *(void *)(a1 + 16)) {
      BOOL result = sub_1CC016940((void **)a1, &v5);
    }
    else {
      *result++ = v5;
    }
    *(void *)(a1 + 8) = result;
  }
  if ((a2 & 0x10) != 0)
  {
    *(void *)&long long v5 = "maystore";
    *((void *)&v5 + 1) = 8;
    if ((unint64_t)result >= *(void *)(a1 + 16)) {
      BOOL result = sub_1CC016940((void **)a1, &v5);
    }
    else {
      *result++ = v5;
    }
    *(void *)(a1 + 8) = result;
  }
  if ((a2 & 0x20) != 0)
  {
    *(void *)&long long v5 = "isconvergent";
    *((void *)&v5 + 1) = 12;
    if ((unint64_t)result >= *(void *)(a1 + 16)) {
      BOOL result = sub_1CC016940((void **)a1, &v5);
    }
    else {
      *result++ = v5;
    }
    *(void *)(a1 + 8) = result;
  }
  if ((a2 & 2) != 0)
  {
    *(void *)&long long v5 = "alignstack";
    *((void *)&v5 + 1) = 10;
    if ((unint64_t)result >= *(void *)(a1 + 16)) {
      BOOL result = sub_1CC016940((void **)a1, &v5);
    }
    else {
      *result++ = v5;
    }
    *(void *)(a1 + 8) = result;
  }
  if ((a2 & 4) == 0)
  {
    *(void *)&long long v5 = "attdialect";
    *((void *)&v5 + 1) = 10;
    if ((unint64_t)result >= *(void *)(a1 + 16)) {
      BOOL result = sub_1CC016940((void **)a1, &v5);
    }
    else {
      *result++ = v5;
    }
    *(void *)(a1 + 8) = result;
  }
  return result;
}

uint64_t llvm::TargetInstrInfo::mergeOutliningCandidateAttributes(uint64_t a1, llvm::LLVMContext ***a2, void *a3)
{
  uint64_t v5 = **(void **)(*(void *)(*a3 + 24) + 32);
  if (llvm::Function::hasFnAttribute(v5, "target-features", 0xFuLL))
  {
    uint64_t FnAttribute = llvm::Function::getFnAttribute(v5, "target-features", 0xFuLL);
    llvm::Function::addFnAttr(a2, FnAttribute);
  }
  if (llvm::Function::hasFnAttribute(v5, "target-cpu", 0xAuLL))
  {
    uint64_t v7 = llvm::Function::getFnAttribute(v5, "target-cpu", 0xAuLL);
    llvm::Function::addFnAttr(a2, v7);
  }
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  while (v9 != v8)
  {
    uint64_t result = llvm::Function::hasFnAttribute(**(void **)(*(void *)(v9 + 24) + 32), 37);
    if ((result & 1) == 0) {
      return result;
    }
    v9 += 224;
  }

  return llvm::Function::addFnAttr((uint64_t)a2, 37);
}

BOOL llvm::TargetInstrInfo::isMBBSafeToOutlineFrom(llvm::TargetInstrInfo *this, llvm::MachineBasicBlock *a2, unsigned int *a3)
{
  uint64_t v4 = 1;
  FirstNonDebugInstr = (unsigned __int16 **)llvm::MachineBasicBlock::getFirstNonDebugInstr(a2, 1);
  if ((unsigned __int16 **)((char *)a2 + 48) != FirstNonDebugInstr)
  {
    int v6 = *FirstNonDebugInstr[2];
    return v6 != 26 && v6 != 35;
  }
  return v4;
}

uint64_t llvm::RTLIB::getFPLibCall(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  switch(a1)
  {
    case 10:
      return a3;
    case 11:
      a3 = a4;
      break;
    case 12:
      a3 = a5;
      break;
    case 13:
      a3 = a6;
      break;
    default:
      if (a1 == 14) {
        a3 = a7;
      }
      else {
        a3 = 637;
      }
      break;
  }
  return a3;
}

uint64_t llvm::RTLIB::getFPEXT(char a1, uint64_t a2, char a3)
{
  if (a1 == 11)
  {
    if (a3 == 14) {
      unsigned int v5 = 255;
    }
    else {
      unsigned int v5 = 637;
    }
    if (a3 == 13) {
      return 257;
    }
    else {
      return v5;
    }
  }
  else
  {
    if (a1 == 10)
    {
      LOBYTE(v3) = a3 - 11;
      if ((a3 - 11) < 4u)
      {
        uint64_t v3 = (char)v3;
        uint64_t v4 = (unsigned int *)&unk_1CFAC7510;
        return v4[v3];
      }
    }
    else if (a1 == 9)
    {
      LOBYTE(v3) = a3 - 10;
      if ((a3 - 10) < 4u)
      {
        uint64_t v3 = (char)v3;
        uint64_t v4 = (unsigned int *)&unk_1CFAC7500;
        return v4[v3];
      }
    }
    else if (a1 == 12 && a3 == 13)
    {
      return 256;
    }
    return 637;
  }
}

uint64_t llvm::RTLIB::getFPROUND(char a1, uint64_t a2, char a3)
{
  switch(a3)
  {
    case 11:
      unsigned int v5 = (a1 - 12);
      if (v5 < 3) {
        return v5 + 273;
      }
      break;
    case 10:
      unsigned int v6 = (a1 - 11);
      if (v6 < 4) {
        return v6 + 269;
      }
      break;
    case 9:
      unsigned int v3 = (a1 - 10);
      if (v3 < 5) {
        return v3 + 264;
      }
      break;
    default:
      if (a3 == 12 && a1 == 13) {
        return 276;
      }
      break;
  }
  return 637;
}

uint64_t llvm::RTLIB::getFPTOSINT(char a1, uint64_t a2, char a3)
{
  switch(a1)
  {
    case 9:
      unsigned int v3 = (a3 - 5);
      BOOL v4 = v3 >= 3;
      unsigned int v5 = v3 + 277;
      goto LABEL_9;
    case 10:
      unsigned int v7 = (a3 - 5);
      BOOL v4 = v7 >= 3;
      unsigned int v5 = v7 + 280;
      goto LABEL_9;
    case 11:
      unsigned int v8 = (a3 - 5);
      BOOL v4 = v8 >= 3;
      unsigned int v5 = v8 + 283;
      goto LABEL_9;
    case 12:
      unsigned int v9 = (a3 - 5);
      BOOL v4 = v9 >= 3;
      unsigned int v5 = v9 + 286;
      goto LABEL_9;
    case 13:
      unsigned int v10 = (a3 - 5);
      BOOL v4 = v10 >= 3;
      unsigned int v5 = v10 + 289;
      goto LABEL_9;
    case 14:
      unsigned int v11 = (a3 - 5);
      BOOL v4 = v11 >= 3;
      unsigned int v5 = v11 + 292;
LABEL_9:
      if (v4) {
        uint64_t result = 637;
      }
      else {
        uint64_t result = v5;
      }
      break;
    default:
      uint64_t result = 637;
      break;
  }
  return result;
}

uint64_t llvm::RTLIB::getFPTOUINT(char a1, uint64_t a2, char a3)
{
  switch(a1)
  {
    case 9:
      unsigned int v3 = (a3 - 5);
      BOOL v4 = v3 >= 3;
      unsigned int v5 = v3 + 295;
      goto LABEL_9;
    case 10:
      unsigned int v7 = (a3 - 5);
      BOOL v4 = v7 >= 3;
      unsigned int v5 = v7 + 298;
      goto LABEL_9;
    case 11:
      unsigned int v8 = (a3 - 5);
      BOOL v4 = v8 >= 3;
      unsigned int v5 = v8 + 301;
      goto LABEL_9;
    case 12:
      unsigned int v9 = (a3 - 5);
      BOOL v4 = v9 >= 3;
      unsigned int v5 = v9 + 304;
      goto LABEL_9;
    case 13:
      unsigned int v10 = (a3 - 5);
      BOOL v4 = v10 >= 3;
      unsigned int v5 = v10 + 307;
      goto LABEL_9;
    case 14:
      unsigned int v11 = (a3 - 5);
      BOOL v4 = v11 >= 3;
      unsigned int v5 = v11 + 310;
LABEL_9:
      if (v4) {
        uint64_t result = 637;
      }
      else {
        uint64_t result = v5;
      }
      break;
    default:
      uint64_t result = 637;
      break;
  }
  return result;
}

uint64_t llvm::RTLIB::getSINTTOFP(char a1, uint64_t a2, char a3)
{
  unsigned int v3 = (a3 - 9);
  if (v3 >= 6) {
    unsigned int v4 = 637;
  }
  else {
    unsigned int v4 = v3 + 325;
  }
  if (v3 >= 6) {
    int v5 = 637;
  }
  else {
    int v5 = v3 + 319;
  }
  BOOL v6 = v3 >= 6;
  int v7 = v3 + 313;
  if (v6) {
    int v7 = 637;
  }
  if (a1 == 5) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 637;
  }
  if (a1 == 6) {
    unsigned int v8 = v5;
  }
  if (a1 == 7) {
    return v4;
  }
  else {
    return v8;
  }
}

uint64_t llvm::RTLIB::getUINTTOFP(char a1, uint64_t a2, char a3)
{
  unsigned int v3 = (a3 - 9);
  if (v3 >= 6) {
    unsigned int v4 = 637;
  }
  else {
    unsigned int v4 = v3 + 343;
  }
  if (v3 >= 6) {
    int v5 = 637;
  }
  else {
    int v5 = v3 + 337;
  }
  BOOL v6 = v3 >= 6;
  int v7 = v3 + 331;
  if (v6) {
    int v7 = 637;
  }
  if (a1 == 5) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 637;
  }
  if (a1 == 6) {
    unsigned int v8 = v5;
  }
  if (a1 == 7) {
    return v4;
  }
  else {
    return v8;
  }
}

uint64_t llvm::RTLIB::getPOWI(char a1)
{
  if (a1 == 14) {
    unsigned int v1 = 96;
  }
  else {
    unsigned int v1 = 637;
  }
  if (((a1 - 10) & 0xFC) != 0) {
    return v1;
  }
  else {
    return (a1 - 10) + 92;
  }
}

uint64_t llvm::RTLIB::getOUTLINE_ATOMIC(int a1, int a2, char a3)
{
  if ((a3 - 3) <= 4u
    && (int v3 = a2 - 2, (a2 - 2) <= 5)
    && ((0x3Du >> v3) & 1) != 0
    && (int v4 = a1 - 292, (a1 - 292) <= 8)
    && ((0x1CDu >> v4) & 1) != 0)
  {
    return *((unsigned int *)*(&off_1E68305E0 + v4) + 4 * (a3 - 3) + qword_1CFAC7850[v3]);
  }
  else
  {
    return 637;
  }
}

uint64_t llvm::RTLIB::getSYNC(int a1, char a2)
{
  uint64_t result = 637;
  switch(a1)
  {
    case 292:
      unsigned int v4 = (a2 - 3);
      BOOL v5 = v4 >= 5;
      unsigned int v6 = v4 + 400;
      goto LABEL_14;
    case 294:
      unsigned int v7 = (a2 - 3);
      BOOL v5 = v7 >= 5;
      unsigned int v6 = v7 + 405;
      goto LABEL_14;
    case 295:
      unsigned int v8 = (a2 - 3);
      BOOL v5 = v8 >= 5;
      unsigned int v6 = v8 + 410;
      goto LABEL_14;
    case 296:
      unsigned int v9 = (a2 - 3);
      BOOL v5 = v9 >= 5;
      unsigned int v6 = v9 + 415;
      goto LABEL_14;
    case 297:
      unsigned int v10 = (a2 - 3);
      BOOL v5 = v10 >= 5;
      unsigned int v6 = v10 + 420;
      goto LABEL_14;
    case 299:
      unsigned int v11 = (a2 - 3);
      BOOL v5 = v11 >= 5;
      unsigned int v6 = v11 + 425;
      goto LABEL_14;
    case 300:
      unsigned int v12 = (a2 - 3);
      BOOL v5 = v12 >= 5;
      unsigned int v6 = v12 + 430;
      goto LABEL_14;
    case 301:
      unsigned int v13 = (a2 - 3);
      BOOL v5 = v13 >= 5;
      unsigned int v6 = v13 + 435;
      goto LABEL_14;
    case 302:
      unsigned int v14 = (a2 - 3);
      BOOL v5 = v14 >= 5;
      unsigned int v6 = v14 + 450;
      goto LABEL_14;
    case 303:
      unsigned int v15 = (a2 - 3);
      BOOL v5 = v15 >= 5;
      unsigned int v6 = v15 + 440;
      goto LABEL_14;
    case 304:
      unsigned int v16 = (a2 - 3);
      BOOL v5 = v16 >= 5;
      unsigned int v6 = v16 + 455;
      goto LABEL_14;
    case 305:
      unsigned int v17 = (a2 - 3);
      BOOL v5 = v17 >= 5;
      unsigned int v6 = v17 + 445;
LABEL_14:
      if (v5) {
        uint64_t result = 637;
      }
      else {
        uint64_t result = v6;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t llvm::RTLIB::getMEMCPY_ELEMENT_UNORDERED_ATOMIC(llvm::RTLIB *this)
{
  unsigned int v1 = (char *)this - 1;
  uint64_t result = 383;
  switch((unint64_t)v1)
  {
    case 0uLL:
      return result;
    case 1uLL:
      uint64_t result = 384;
      break;
    case 3uLL:
      uint64_t result = 385;
      break;
    case 7uLL:
      uint64_t result = 386;
      break;
    default:
      uint64_t result = 637;
      break;
  }
  return result;
}

uint64_t llvm::RTLIB::getMEMMOVE_ELEMENT_UNORDERED_ATOMIC(llvm::RTLIB *this)
{
  unsigned int v1 = (char *)this - 1;
  uint64_t result = 388;
  switch((unint64_t)v1)
  {
    case 0uLL:
      return result;
    case 1uLL:
      uint64_t result = 389;
      break;
    case 3uLL:
      uint64_t result = 390;
      break;
    case 7uLL:
      uint64_t result = 391;
      break;
    default:
      uint64_t result = 637;
      break;
  }
  return result;
}

uint64_t llvm::RTLIB::getMEMSET_ELEMENT_UNORDERED_ATOMIC(llvm::RTLIB *this)
{
  unsigned int v1 = (char *)this - 1;
  uint64_t result = 393;
  switch((unint64_t)v1)
  {
    case 0uLL:
      return result;
    case 1uLL:
      uint64_t result = 394;
      break;
    case 3uLL:
      uint64_t result = 395;
      break;
    case 7uLL:
      uint64_t result = 396;
      break;
    default:
      uint64_t result = 637;
      break;
  }
  return result;
}

uint64_t llvm::TargetLoweringBase::getScalarShiftAmountTy(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  int v3 = *(_DWORD *)(*(void *)(a2 + 232) + 4);
  if (v3 > 31)
  {
    switch(v3)
    {
      case 32:
        return 5;
      case 64:
        return 6;
      case 128:
        return 7;
    }
  }
  else
  {
    switch(v3)
    {
      case 1:
        return 2;
      case 8:
        return 3;
      case 16:
        return 4;
    }
  }
  return result;
}

unint64_t llvm::TargetLoweringBase::getShiftAmountTy(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned __int8 v5 = a2;
  v16[0] = a2;
  v16[1] = a3;
  if ((_BYTE)a2)
  {
    if ((a2 - 15) < 0x9Cu)
    {
LABEL_3:
      unint64_t v6 = a2 & 0xFFFFFFFFFFFFFF00;
      return v6 | v5;
    }
  }
  else if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12)
  {
    goto LABEL_3;
  }
  uint64_t v7 = *a1;
  if (a5) {
    unsigned __int8 v8 = (*(uint64_t (**)(void))(v7 + 56))();
  }
  else {
    unsigned __int8 v8 = (*(uint64_t (**)(void))(v7 + 32))();
  }
  unsigned __int8 v15 = v8;
  unint64_t v10 = sub_1CB87E200(&v15);
  if (v9 == 1) {
  if (v5)
  }
    Extendedint SizeInBits = sub_1CB87E200((unsigned __int8 *)v16);
  else {
    Extendedint SizeInBits = llvm::EVT::getExtendedSizeInBits((llvm::EVT *)v16);
  }
  unsigned int v13 = ExtendedSizeInBits;
  if (v12 == 1) {
  unint64_t v6 = 0;
  }
  if (v10 >= 32 - __clz(v13 - 1)) {
    unsigned __int8 v5 = v15;
  }
  else {
    unsigned __int8 v5 = 5;
  }
  return v6 | v5;
}

BOOL llvm::TargetLoweringBase::canOpTrap(uint64_t a1, int a2)
{
  return (a2 - 59) < 4;
}

uint64_t llvm::TargetLoweringBase::setJumpIsExpensive(uint64_t this, char a2)
{
  if (!word_1EBCD43E0) {
    *(unsigned char *)(this + 48) = a2;
  }
  return this;
}

unint64_t sub_1CD584B84(llvm::EVT *a1, llvm::LLVMContext *a2)
{
  int v4 = sub_1CC4A0738(a1);
  if ((v4 & (v4 - 1)) == 0) {
    return *(void *)a1;
  }
  unint64_t v6 = sub_1CC4A0738(a1);
  uint64_t v8 = (1 << -(char)__clz(v6 - 1));
  unint64_t v9 = v6 & 0xFFFFFFFF00000000;
  if (*(unsigned char *)a1)
  {
    LOBYTE(EVT) = sub_1CB8C2FBC((unsigned __int8 *)a1);
    unint64_t v11 = 0;
    uint64_t v12 = 0;
  }
  else
  {
    unint64_t EVT = llvm::EVT::getEVT(*(llvm::EVT **)(*((void *)a1 + 1) + 24), 0, v7);
    uint64_t v12 = v13;
    unint64_t v11 = EVT & 0xFFFFFFFFFFFFFF00;
  }
  return sub_1CB882C1C(a2, v11 | EVT, v12, (llvm::Type *)(v8 | ((unint64_t)(v9 == 0x100000000) << 32)));
}

uint64_t llvm::TargetLoweringBase::getSetCCResultType(uint64_t a1, uint64_t a2)
{
  return (*(unsigned __int8 (**)(uint64_t, uint64_t, void))(*(void *)a1 + 32))(a1, a2, 0);
}

uint64_t llvm::TargetLoweringBase::getCmpLibcallReturnType(llvm::TargetLoweringBase *this)
{
  return 5;
}

uint64_t llvm::TargetLoweringBase::getVectorTypeBreakdown(unint64_t a1, llvm::LLVMContext *a2, uint64_t a3, uint64_t a4, void *a5, unsigned int *a6, unsigned __int8 *a7)
{
  *(void *)&long long v47 = a3;
  *((void *)&v47 + 1) = a4;
  unint64_t v12 = sub_1CC4A0738((llvm::EVT *)&v47);
  llvm::TargetLoweringBase::getTypeConversion(a1, a2, v47, *((uint64_t *)&v47 + 1), (uint64_t)v48);
  if ((HIDWORD(v12) == 1 || v12 != 1) && (v48[0] == 7 || v48[0] == 1))
  {
    llvm::TargetLoweringBase::getTypeConversion(a1, a2, v47, *((uint64_t *)&v47 + 1), (uint64_t)v48);
    unsigned __int8 v16 = v48[8];
    if (v48[8])
    {
      if (*(void *)(a1 + 8 * v48[8] + 96))
      {
        *(_OWORD *)a5 = *(_OWORD *)&v48[8];
        *a7 = v16;
        uint64_t v17 = 1;
        *a6 = 1;
        return v17;
      }
    }
  }
  if ((_BYTE)v47)
  {
    LOBYTE(EVT) = sub_1CB8C2FBC((unsigned __int8 *)&v47);
    unint64_t v20 = 0;
    uint64_t v21 = 0;
  }
  else
  {
    unint64_t EVT = llvm::EVT::getEVT(*(llvm::EVT **)(*((void *)&v47 + 1) + 24), 0, v13);
    uint64_t v21 = v33;
    unint64_t v20 = EVT & 0xFFFFFFFFFFFFFF00;
  }
  if (HIDWORD(v12) == 1)
  {
    long long v46 = v47;
    uint64_t v29 = *((void *)&v47 + 1);
    do
    {
      llvm::TargetLoweringBase::getTypeConversion(a1, a2, v46, v29, (uint64_t)v48);
      *(_DWORD *)((char *)&v46 + 1) = *(_DWORD *)&v48[9];
      DWORD1(v46) = *(_DWORD *)&v48[12];
      uint64_t v29 = *(void *)&v48[16];
      LOBYTE(v46) = v48[8];
      *((void *)&v46 + 1) = *(void *)&v48[16];
    }
    while (v48[0]);
    if (v48[8])
    {
      if (v48[8] - 15 < 0x9C)
      {
LABEL_34:
        uint64_t v30 = sub_1CC4A0738((llvm::EVT *)&v47);
        unsigned int v31 = sub_1CC4A0738((llvm::EVT *)&v46);
        *a6 = (v30 + (unint64_t)v31 - 1) / v31;
        *(_OWORD *)a5 = v46;
        *a7 = sub_1CB87E160(a1, a2, *a5, a5[1]);
        return *a6;
      }
    }
    else if ((*(_DWORD *)(*(void *)&v48[16] + 8) & 0xFE) == 0x12)
    {
      goto LABEL_34;
    }
    llvm::report_fatal_error((llvm *)"Don't know how to legalize this scalable vector type", (const llvm::Twine *)1);
  }
  uint64_t v22 = v20 | EVT;
  v19.i32[0] = v12;
  uint8x8_t v23 = (uint8x8_t)vcnt_s8(v19);
  v23.i16[0] = vaddlv_u8(v23);
  if (v23.i32[0] == 1) {
    unsigned int v24 = v12;
  }
  else {
    unsigned int v24 = 1;
  }
  if (v23.i32[0] == 1) {
    uint64_t v25 = HIDWORD(v12);
  }
  else {
    uint64_t v25 = 0;
  }
  if (v23.i32[0] == 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v12;
  }
  if (v24 >= 2)
  {
    while (1)
    {
      unsigned __int8 v26 = sub_1CB882C1C(a2, v22, v21, (llvm::Type *)(v12 | (unint64_t)(v25 << 32)));
      if (v26)
      {
        if (*(void *)(a1 + 8 * v26 + 96)) {
          break;
        }
      }
      uint64_t v25 = 0;
      uint64_t v27 = 0;
      unsigned int v24 = v12 >> 1;
      uint64_t v17 = (2 * v17);
      BOOL v28 = v12 > 3;
      LODWORD(v12) = v12 >> 1;
      if (!v28) {
        goto LABEL_41;
      }
    }
    unsigned int v24 = v12;
  }
  uint64_t v27 = v25;
LABEL_41:
  *a6 = v17;
  unint64_t v34 = sub_1CB882C1C(a2, v22, v21, (llvm::Type *)(v24 | (unint64_t)(v27 << 32)));
  *(void *)int v48 = v34;
  *(void *)&v48[8] = v35;
  if ((_BYTE)v34 && *(void *)(a1 + 8 * v34 + 96))
  {
    uint64_t v22 = v34;
    uint64_t v21 = v35;
  }
  else
  {
    *(void *)int v48 = v22;
    *(void *)&v48[8] = v21;
  }
  *(_OWORD *)a5 = *(_OWORD *)v48;
  unsigned __int8 v36 = sub_1CB87E160(a1, a2, v22, v21);
  unsigned __int8 v45 = v36;
  *a7 = v36;
  LOBYTE(v46) = v36;
  *((void *)&v46 + 1) = 0;
  if (v36 == v22)
  {
    if ((_BYTE)v22 || !v21 || !sub_1CB8F2034((unsigned __int8 *)&v46, v22, v21)) {
      return v17;
    }
  }
  else
  {
    if (!sub_1CB8F2034((unsigned __int8 *)&v46, v22, v21)) {
      return v17;
    }
    if ((_BYTE)v22)
    {
      Extendedint SizeInBits = sub_1CB87E200(v48);
      goto LABEL_50;
    }
  }
  Extendedint SizeInBits = (unint64_t)llvm::EVT::getExtendedSizeInBits((llvm::EVT *)v48);
LABEL_50:
  unint64_t v39 = ExtendedSizeInBits;
  uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)ExtendedSizeInBits);
  v40.i16[0] = vaddlv_u8(v40);
  if (v40.i32[0] != 1)
  {
    unint64_t v41 = ExtendedSizeInBits | (ExtendedSizeInBits >> 1) | ((ExtendedSizeInBits | (ExtendedSizeInBits >> 1)) >> 2);
    unint64_t v42 = v41 | (v41 >> 4) | ((v41 | (v41 >> 4)) >> 8);
    unint64_t v39 = (v42 | (v42 >> 16) | ((v42 | (v42 >> 16)) >> 32)) + 1;
    BOOL v38 = v38;
  }
  if (v38) {
  unint64_t v44 = sub_1CB87E200(&v45);
  }
  if (v43 == 1) {
  return v17 * (v39 / v44);
  }
}

void llvm::GetReturnInfo(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, llvm::DataLayout *a6)
{
  v35[8] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a3;
  uint64_t v33 = v35;
  uint64_t v34 = 0x400000000;
  llvm::ComputeValueVTs((uint64_t)a5, a6, (uint64_t)a2, (uint64_t)&v33, 0, 0);
  uint64_t v10 = v34;
  if (v34)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      long long v31 = *((_OWORD *)v33 + i);
      if ((llvm::AttributeList::hasAttributeAtIndex(&v32, 0, 48) & 1) != 0
        || llvm::AttributeList::hasAttributeAtIndex(&v32, 0, 67))
      {
        if ((_BYTE)v31)
        {
          BOOL v12 = v31 - 120 >= 0x20 && v31 - 2 >= 6;
          if (!v12 || v31 - 15 < 0x3C) {
            goto LABEL_26;
          }
        }
        else
        {
          if ((*(_DWORD *)(*((void *)&v31 + 1) + 8) & 0xFE) == 0x12) {
            int v22 = *(unsigned __int8 *)(**(void **)(*((void *)&v31 + 1) + 16) + 8);
          }
          else {
            int v22 = *(_DWORD *)(*((void *)&v31 + 1) + 8);
          }
          if (v22 == 13)
          {
LABEL_26:
            int v23 = a5[1891];
            if ((v31 != v23 || !(_BYTE)v31 && *((void *)&v31 + 1))
              && sub_1CB8F2034((unsigned __int8 *)&v31, a5[1891], 0))
            {
              LOBYTE(v31) = v23;
              *((void *)&v31 + 1) = 0;
            }
          }
        }
      }
      int v13 = (*(uint64_t (**)(unsigned __int8 *, void, uint64_t, void, void))(*(void *)a5 + 600))(a5, *a2, a1, v31, *((void *)&v31 + 1));
      char v14 = (*(uint64_t (**)(unsigned __int8 *, void, uint64_t, void, void))(*(void *)a5 + 592))(a5, *a2, a1, v31, *((void *)&v31 + 1));
      if (llvm::AttributeList::hasAttributeAtIndex(&v32, 0, 10)) {
        uint64_t v15 = 4;
      }
      else {
        uint64_t v15 = 0;
      }
      if (llvm::AttributeList::hasAttributeAtIndex(&v32, 0, 48)) {
        uint64_t hasAttributeAtIndex = 2;
      }
      else {
        uint64_t hasAttributeAtIndex = llvm::AttributeList::hasAttributeAtIndex(&v32, 0, 67);
      }
      if (v13)
      {
        uint64_t v17 = hasAttributeAtIndex | v15;
        do
        {
          uint64_t v24 = v17;
          int v25 = 0;
          char v28 = 1;
          int v29 = 0;
          int v30 = 0;
          char v26 = v14;
          long long v27 = v31;
          uint64_t v18 = (_OWORD *)sub_1CD58643C(a4, (unint64_t)&v24, 1);
          int8x8_t v19 = (_OWORD *)(*(void *)a4 + 48 * *(unsigned int *)(a4 + 8));
          long long v21 = v18[1];
          long long v20 = v18[2];
          *int8x8_t v19 = *v18;
          v19[1] = v21;
          v19[2] = v20;
          ++*(_DWORD *)(a4 + 8);
          --v13;
        }
        while (v13);
      }
    }
  }
  if (v33 != v35) {
    free(v33);
  }
}

uint64_t llvm::TargetLoweringBase::getByValTypeAlignment(llvm::TargetLoweringBase *this, llvm::Type *a2, const llvm::DataLayout *a3)
{
  return 1 << llvm::DataLayout::getABITypeAlign(a3, a2);
}

uint64_t llvm::TargetLoweringBase::allowsMemoryAccessForAlignment(uint64_t a1, llvm::LLVMContext *a2, llvm::DataLayout *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, unsigned char *a9)
{
  uint64_t v17 = a4;
  uint64_t v18 = a5;
  llvm::EVT::getTypeForEVT((llvm::EVT *)&v17, a2);
  uint64_t v15 = v14;
  if (!sub_1CD585444((llvm::EVT *)&v17)
    && a7 < llvm::DataLayout::getABITypeAlign(a3, v15))
  {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, unsigned char *))(*(void *)a1 + 648))(a1, v17, v18, a6, a7, a8, a9);
  }
  uint64_t result = 1;
  if (a9) {
    *a9 = 1;
  }
  return result;
}

BOOL sub_1CD585444(llvm::EVT *this)
{
  if (*(unsigned char *)this)
  {
    if (*(unsigned __int8 *)this - 120 < 0x33) {
      return 0;
    }
    Extendedint SizeInBits = sub_1CB87E200((unsigned __int8 *)this);
  }
  else
  {
    if (llvm::EVT::isExtendedScalableVector(this)) {
      return 0;
    }
    Extendedint SizeInBits = (uint64_t)llvm::EVT::getExtendedSizeInBits(this);
  }
  if (v4 == 1)
  {
    uint64_t v5 = ExtendedSizeInBits;
    Extendedint SizeInBits = v5;
  }
  return ExtendedSizeInBits == 0;
}

uint64_t llvm::TargetLoweringBase::allowsMemoryAccessForAlignment(uint64_t a1, llvm::LLVMContext *a2, llvm::DataLayout *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned char *a7)
{
  uint64_t v7 = (1 << *(unsigned char *)(a6 + 34)) | *(void *)(a6 + 8);
  return llvm::TargetLoweringBase::allowsMemoryAccessForAlignment(a1, a2, a3, a4, a5, *(unsigned int *)(a6 + 16), 63 - __clz(v7 & -v7), *(unsigned __int16 *)(a6 + 32), a7);
}

uint64_t llvm::TargetLoweringBase::allowsMemoryAccess(uint64_t a1, llvm::LLVMContext *a2, llvm::DataLayout *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7, uint64_t a8, unsigned char *a9)
{
  return llvm::TargetLoweringBase::allowsMemoryAccessForAlignment(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t llvm::TargetLoweringBase::allowsMemoryAccess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = (1 << *(unsigned char *)(a6 + 34)) | *(void *)(a6 + 8);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)a1 + 664))(a1, a2, a3, a4, a5, *(unsigned int *)(a6 + 16), (63 - __clz(v7 & -v7)), *(unsigned __int16 *)(a6 + 32), a7);
}

uint64_t llvm::TargetLoweringBase::allowsMemoryAccess(uint64_t a1, llvm::LLVMContext *a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t ApproximateEVTForLLT = llvm::getApproximateEVTForLLT(a4, a3, a2);
  uint64_t v12 = (1 << *(unsigned char *)(a5 + 34)) | *(void *)(a5 + 8);
  return (*(uint64_t (**)(uint64_t, llvm::LLVMContext *, uint64_t, unint64_t, uint64_t, void, void, void, uint64_t))(*(void *)a1 + 664))(a1, a2, a3, ApproximateEVTForLLT, v13, *(unsigned int *)(a5 + 16), (63 - __clz(v12 & -v12)), *(unsigned __int16 *)(a5 + 32), a6);
}

void *llvm::TargetLoweringBase::getDefaultSafeStackPointerLocation(llvm::TargetLoweringBase *this, llvm::IRBuilderBase *a2, int a3)
{
  int v4 = *(llvm::Type ***)(*(void *)(*((void *)a2 + 6) + 56) + 40);
  uint64_t NamedValue = llvm::Module::getNamedValue((uint64_t)v4, "__safestack_unsafe_stack_ptr", 0x1CuLL);
  if (NamedValue && (unint64_t v6 = (void *)NamedValue, *(unsigned char *)(NamedValue + 16) == 3))
  {
    if (*(void *)(NamedValue + 24) != llvm::Type::getInt8PtrTy(*v4, 0))
    {
      v24[0] = (uint64_t)"__safestack_unsafe_stack_ptr";
      __int16 v25 = 259;
      v22[0] = (uint64_t)" must have void* type";
      __int16 v23 = 259;
      unint64_t v9 = v22;
      goto LABEL_16;
    }
    if (((*((unsigned char *)v6 + 33) & 0x1C) != 0) != a3)
    {
      long long v20 = "__safestack_unsafe_stack_ptr";
      __int16 v21 = 259;
      uint64_t v18 = " must ";
      __int16 v19 = 259;
      sub_1CB8F1E58((uint64_t *)&v20, (uint64_t *)&v18, (uint64_t)v22);
      uint64_t v7 = "";
      if (!a3) {
        uint64_t v7 = "not ";
      }
      char v8 = 1;
      char v17 = 1;
      if (*v7)
      {
        uint64_t v15 = v7;
        char v8 = 3;
      }
      char v16 = v8;
      sub_1CD3E3950(v22, (uint64_t *)&v15, (uint64_t)v24);
      uint64_t v13 = "be thread-local";
      __int16 v14 = 259;
      unint64_t v9 = (uint64_t *)&v13;
LABEL_16:
      sub_1CD3E3950(v24, v9, (uint64_t)v26);
      llvm::report_fatal_error((llvm *)v26, (const llvm::Twine *)1);
    }
  }
  else
  {
    Int8PtrTy = (llvm::PointerType *)llvm::Type::getInt8PtrTy(*v4, 0);
    if (a3) {
      char v11 = 3;
    }
    else {
      char v11 = 0;
    }
    unint64_t v6 = llvm::User::operator new((llvm::User *)0x58, 1u);
    v26[0] = "__safestack_unsafe_stack_ptr";
    __int16 v27 = 259;
    llvm::GlobalVariable::GlobalVariable(v6, (uint64_t)v4, Int8PtrTy, 0, 0, 0, v26, 0, v11, 0, 0);
  }
  return v6;
}

void *llvm::TargetLoweringBase::getSafeStackPointerLocation(llvm::TargetLoweringBase *this, llvm::IRBuilderBase *a2)
{
  if (*(_DWORD *)(*((void *)this + 1) + 488) == 11)
  {
    int v3 = *(llvm::Type ***)(*(void *)(*((void *)a2 + 6) + 56) + 40);
    Int8PtrTy = (llvm::Type *)llvm::Type::getInt8PtrTy(*v3, 0);
    PointerTo = (uint64_t **)llvm::Type::getPointerTo(Int8PtrTy, 0);
    unint64_t v6 = (uint64_t **)sub_1CD577C30((uint64_t)v3, "__safestack_pointer_address", (const char *)0x1B, 0, PointerTo);
    __int16 v10 = 257;
    return (void *)sub_1CB845BAC((uint64_t *)a2, v6, v7, 0, 0, (uint64_t)v9, 0);
  }
  else
  {
    return llvm::TargetLoweringBase::getDefaultSafeStackPointerLocation(this, a2, 1);
  }
}

llvm::detail::IEEEFloat *llvm::TargetLoweringBase::getIRStackGuard(llvm::TargetLoweringBase *this, llvm::IRBuilderBase *a2)
{
  if (*(_DWORD *)(*((void *)this + 1) + 484) != 13) {
    return 0;
  }
  uint64_t v2 = *(llvm::Type ***)(*(void *)(*((void *)a2 + 6) + 56) + 40);
  Int8PtrTy = (llvm::PointerType *)llvm::Type::getInt8PtrTy(*v2, 0);
  inserted = llvm::Module::getOrInsertGlobal((uint64_t)v2, "__guard_local", 0xDuLL, Int8PtrTy);
  uint64_t v5 = inserted;
  if (inserted && *((unsigned char *)inserted + 16) == 3)
  {
    int v6 = *((_DWORD *)inserted + 8);
    unsigned int v7 = v6 & 0xFFFFFFCF | 0x10;
    *((_DWORD *)inserted + 8) = v7;
    if ((v6 & 0xFu) - 7 >= 2)
    {
      if (llvm::GlobalValue::hasExternalWeakLinkage(inserted)) {
        return v5;
      }
      unsigned int v7 = *((_DWORD *)v5 + 8);
    }
    *((_DWORD *)v5 + 8) = v7 | 0x4000;
  }
  return v5;
}

uint64_t llvm::TargetLoweringBase::insertSSPDeclarations(llvm::TargetMachine **this, llvm::Type **a2)
{
  uint64_t result = llvm::Module::getNamedValue((uint64_t)a2, "__stack_chk_guard", 0x11uLL);
  if (!result)
  {
    uint64_t v5 = llvm::User::operator new((llvm::User *)0x58, 1u);
    Int8PtrTy = (llvm::PointerType *)llvm::Type::getInt8PtrTy(*a2, 0);
    unint64_t v9 = "__stack_chk_guard";
    __int16 v10 = 259;
    llvm::GlobalVariable::GlobalVariable(v5, (uint64_t)a2, Int8PtrTy, 0, 0, 0, &v9, 0, 0, 0, 0);
    uint64_t result = llvm::TargetMachine::getRelocationModel(this[1]);
    if (!result)
    {
      unsigned int v7 = this[1];
      int v8 = *((_DWORD *)v7 + 121);
      if (v8 != 5 && (v8 != 15 || *((_DWORD *)v7 + 122) != 1)) {
        *((_DWORD *)v5 + 8) |= 0x4000u;
      }
    }
  }
  return result;
}

uint64_t llvm::TargetLoweringBase::getSDagStackGuard(llvm::TargetLoweringBase *this, const llvm::Module *a2)
{
  return llvm::Module::getNamedValue((uint64_t)a2, "__stack_chk_guard", 0x11uLL);
}

uint64_t llvm::TargetLoweringBase::getSSPStackGuardCheck(llvm::TargetLoweringBase *this, const llvm::Module *a2)
{
  return 0;
}

uint64_t llvm::TargetLoweringBase::getMinimumJumpTableEntries(llvm::TargetLoweringBase *this)
{
  return dword_1EBCD4518;
}

BOOL llvm::TargetLoweringBase::isJumpTableRelative(llvm::TargetMachine **this)
{
  return llvm::TargetMachine::isPositionIndependent(this[1]);
}

uint64_t llvm::TargetLoweringBase::getPrefLoopAlignment(llvm::TargetLoweringBase *this, llvm::MachineLoop *a2)
{
  unint64_t v2 = *(unsigned int *)(*((void *)this + 1) + 1096);
  if (v2) {
    return __clz(v2) ^ 0x3F;
  }
  else {
    return *((unsigned __int8 *)this + 71);
  }
}

uint64_t llvm::TargetLoweringBase::getMaxPermittedBytesForAlignment(llvm::TargetLoweringBase *this, llvm::MachineBasicBlock *a2)
{
  return *((unsigned int *)this + 18);
}

uint64_t llvm::TargetLoweringBase::getRecipEstimateSqrtEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute(*a4, "reciprocal-estimates", 0x14uLL);
  uint64_t ValueAsString = llvm::Attribute::getValueAsString((llvm::Attribute *)&FnAttribute);
  return sub_1CC4A1AF0(1, a2, a3, ValueAsString, v7);
}

uint64_t llvm::TargetLoweringBase::getRecipEstimateDivEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute(*a4, "reciprocal-estimates", 0x14uLL);
  uint64_t ValueAsString = llvm::Attribute::getValueAsString((llvm::Attribute *)&FnAttribute);
  return sub_1CC4A1AF0(0, a2, a3, ValueAsString, v7);
}

uint64_t llvm::TargetLoweringBase::getSqrtRefinementSteps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute(*a4, "reciprocal-estimates", 0x14uLL);
  uint64_t ValueAsString = (unsigned __int16 *)llvm::Attribute::getValueAsString((llvm::Attribute *)&FnAttribute);
  return sub_1CC4A1E20(1, a2, a3, ValueAsString, v7);
}

uint64_t llvm::TargetLoweringBase::getDivRefinementSteps(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute(*a4, "reciprocal-estimates", 0x14uLL);
  uint64_t ValueAsString = (unsigned __int16 *)llvm::Attribute::getValueAsString((llvm::Attribute *)&FnAttribute);
  return sub_1CC4A1E20(0, a2, a3, ValueAsString, v7);
}

llvm::Instruction *llvm::TargetLoweringBase::emitLeadingFence(int a1, uint64_t *a2, llvm::Instruction *this, unsigned int a4)
{
  if ((unint64_t)a4 - 5 > 2) {
    return 0;
  }
  uint64_t v12 = v4;
  uint64_t v13 = v5;
  __int16 v6 = a4;
  if (!llvm::Instruction::hasAtomicStore(this)) {
    return 0;
  }
  __int16 v11 = 257;
  unint64_t v9 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, 0);
  llvm::FenceInst::FenceInst(v9, a2[8], v6, 1, 0);
  return sub_1CD509770(a2, v9, (uint64_t)v10);
}

llvm::Instruction *llvm::TargetLoweringBase::emitTrailingFence(uint64_t a1, uint64_t *a2, uint64_t a3, __int16 a4)
{
  if (((0xD0uLL >> a4) & 1) == 0) {
    return 0;
  }
  __int16 v9 = 257;
  size_t v7 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, 0);
  llvm::FenceInst::FenceInst(v7, a2[8], a4, 1, 0);
  return sub_1CD509770(a2, v7, (uint64_t)v8);
}

uint64_t llvm::TargetLoweringBase::shouldLocalize(llvm::TargetLoweringBase *this, const llvm::MachineInstr *a2, const llvm::TargetTransformInfo *a3)
{
  uint64_t result = 0;
  uint64_t v4 = **((unsigned __int16 **)a2 + 2) - 70;
  if (v4 <= 0x33)
  {
    if (((1 << (**((_WORD **)a2 + 2) - 70)) & 0xC000000000801) != 0)
    {
      return 1;
    }
    else if (v4 == 1)
    {
      uint64_t v6 = *(void *)(*(void *)(*((void *)a2 + 3) + 32) + 40);
      uint64_t result = llvm::TargetTransformInfo::getGISelRematGlobalCost(a3);
      if (result != 1)
      {
        unsigned int v7 = *(_DWORD *)(*((void *)a2 + 4) + 4);
        if (result == 2) {
          int v8 = 2;
        }
        else {
          int v8 = 1;
        }
        return llvm::MachineRegisterInfo::hasAtMostUserInstrs(v6, v7, v8);
      }
    }
  }
  return result;
}

void sub_1CD585E88(uint64_t a1)
{
}

void sub_1CD585E98()
{
  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD585EC0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 32))(a1, a2, 0);
}

uint64_t sub_1CD585EE8()
{
  return 0;
}

uint64_t sub_1CD585EF0()
{
  return 0;
}

uint64_t sub_1CD585EF8()
{
  return 0;
}

uint64_t sub_1CD585F00()
{
  return 1;
}

uint64_t sub_1CD585F08()
{
  return 0;
}

uint64_t sub_1CD585F10()
{
  return 0;
}

char *sub_1CD585F18(uint64_t a1, unsigned int a2, unsigned __int8 a3, void **a4)
{
  uint64_t v6 = sub_1CD585FC8(a1, &v13, a2, a3);
  unsigned int v7 = (char *)*v6;
  if (!*v6)
  {
    int v8 = v6;
    unsigned int v7 = (char *)operator new(0x28uLL);
    *(void *)(v7 + 28) = **a4;
    v7[36] = 0;
    uint64_t v9 = v13;
    *(void *)unsigned int v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    *int v8 = (uint64_t)v7;
    uint64_t v10 = **(void **)a1;
    __int16 v11 = (uint64_t *)v7;
    if (v10)
    {
      *(void *)a1 = v10;
      __int16 v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

uint64_t *sub_1CD585FC8(uint64_t a1, void *a2, unsigned int a3, unsigned __int8 a4)
{
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  uint64_t result = (uint64_t *)(a1 + 8);
  uint64_t v5 = v6;
  if (v6)
  {
    while (1)
    {
      unsigned int v7 = v5;
      unsigned int v8 = *((_DWORD *)v5 + 7);
      if (v8 > a3) {
        goto LABEL_9;
      }
      if (v8 < a3)
      {
LABEL_6:
        uint64_t result = v7 + 1;
        uint64_t v5 = (uint64_t *)v7[1];
        if (!v5) {
          goto LABEL_7;
        }
      }
      else
      {
        unsigned int v9 = *((unsigned __int8 *)v7 + 32);
        if (v9 <= a4)
        {
          if (v9 >= a4) {
            goto LABEL_7;
          }
          goto LABEL_6;
        }
LABEL_9:
        uint64_t v5 = (uint64_t *)*v7;
        uint64_t result = v7;
        if (!*v7) {
          goto LABEL_7;
        }
      }
    }
  }
  unsigned int v7 = result;
LABEL_7:
  *a2 = v7;
  return result;
}

void sub_1CD586024(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)qword_1EBCD43D8, 0, 0);
  byte_1EBCD4458 = 0;
  qword_1EBCD4460 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD4468 = 0;
  qword_1EBCD43D8[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBCD4470 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD4478 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD4490 = (uint64_t)&qword_1EBCD4478;
  sub_1CD586114(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCD43D8);
}

__n128 sub_1CD586114(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)qword_1EBCD43D8, "jump-is-expensive", 0x11uLL);
  uint64_t v6 = *a1;
  byte_1EBCD4458 = **a1;
  byte_1EBCD4469 = 1;
  byte_1EBCD4468 = *v6;
  __n128 result = *a2;
  xmmword_1EBCD43F8 = (__int128)*a2;
  word_1EBCD43E2 = (32 * (*a3 & 3)) | word_1EBCD43E2 & 0xFF9F;
  return result;
}

void sub_1CD58619C(int **a1, _WORD *a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD4498, 0, 0);
  dword_1EBCD4518 = 0;
  qword_1EBCD4520 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD4528 = 0;
  qword_1EBCD4498 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD4530 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD4538 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD4550 = (uint64_t)&qword_1EBCD4538;
  llvm::cl::Option::setArgStr(v6, "min-jump-table-entries", 0x16uLL);
  dword_1EBCD4518 = **a1;
  byte_1EBCD452C = 1;
  dword_1EBCD4528 = dword_1EBCD4518;
  word_1EBCD44A2 = (32 * (*a2 & 3)) | word_1EBCD44A2 & 0xFF9F;
  xmmword_1EBCD44B8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD4498);
}

void sub_1CD5862C4(int **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD4558, 0, 0);
  dword_1EBCD45D8 = 0;
  qword_1EBCD45E0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD45E8 = 0;
  qword_1EBCD4558 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD45F0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD45F8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD4610 = (uint64_t)&qword_1EBCD45F8;
  sub_1CD5863B4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD4558);
}

__n128 sub_1CD5863B4(int **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD4558, "max-jump-table-size", 0x13uLL);
  uint64_t v6 = *a1;
  dword_1EBCD45D8 = **a1;
  byte_1EBCD45EC = 1;
  dword_1EBCD45E8 = *v6;
  word_1EBCD4562 = (32 * (*a2 & 3)) | word_1EBCD4562 & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCD4578 = (__int128)*a3;
  return result;
}

unint64_t sub_1CD58643C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 48 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t llvm::TargetLoweringObjectFileMachO::getStaticDtorSection(llvm::TargetLoweringObjectFileMachO *this, unsigned int a2, const llvm::MCSymbol *a3)
{
  if ((*(unsigned char *)(*((void *)this + 123) + 1032) & 2) != 0) {
    llvm::report_fatal_error((llvm *)"@llvm.global_dtors should have been lowered already", (const llvm::Twine *)1);
  }
  return *((void *)this + 122);
}

size_t llvm::TargetLoweringObjectFileMachO::getExplicitSectionGlobal(uint64_t a1, llvm::GlobalObject *this, int a3)
{
  if ((*((unsigned char *)this + 34) & 0x40) != 0)
  {
    SectionImpl = llvm::GlobalObject::getSectionImpl(this);
    uint64_t v7 = v8;
  }
  else
  {
    SectionImpl = 0;
    uint64_t v7 = 0;
  }
  if (!*((unsigned char *)this + 16)
    && llvm::Function::hasFnAttribute((uint64_t)this, "implicit-section-name", 0x15uLL))
  {
    uint64_t FnAttribute = llvm::Function::getFnAttribute((uint64_t)this, "implicit-section-name", 0x15uLL);
    if (FnAttribute)
    {
      uint64_t v7 = *(unsigned int *)(FnAttribute + 16);
      SectionImpl = (llvm::GlobalObject *)(FnAttribute + *(unsigned int *)(FnAttribute + 12) + 25);
    }
    else
    {
      SectionImpl = 0;
      uint64_t v7 = 0;
    }
  }
  uint64_t v41 = 0;
  unint64_t v42 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v38 = 0;
  char v37 = 0;
  sub_1CC4A7F0C((uint64_t)this);
  llvm::MCSectionMachO::ParseSectionSpecifier((uint64_t)SectionImpl, v7, &v41, &v39, (int *)&v38 + 1, &v37, &v38, &v36);
  if (v36)
  {
    __int16 v28 = 1283;
    v27[0] = (uint64_t)"Global variable '";
    v27[2] = (uint64_t)llvm::Value::getName(this);
    v27[3] = v13;
    __int16 v25 = "' has an invalid section specifier '";
    __int16 v26 = 259;
    sub_1CD3E3950(v27, (uint64_t *)&v25, (uint64_t)v29);
    __int16 v24 = 261;
    v23[0] = sub_1CC4A7E24((uint64_t)this);
    v23[1] = v14;
    sub_1CD3E3950(v29, v23, (uint64_t)v30);
    __int16 v21 = "': ";
    __int16 v22 = 259;
    sub_1CD3E3950(v30, (uint64_t *)&v21, (uint64_t)v31);
    uint64_t v17 = v36;
    uint64_t v36 = 0;
    sub_1CD4FB504(&v17, &v18);
    __int16 v20 = 260;
    __int16 v19 = &v18;
    sub_1CD3E3950(v31, (uint64_t *)&v19, (uint64_t)v33);
    uint64_t v15 = ".";
    __int16 v16 = 259;
    uint64_t v12 = (uint64_t *)&v15;
LABEL_17:
    sub_1CD3E3950(v33, v12, (uint64_t)v35);
    llvm::report_fatal_error((llvm *)v35, (const llvm::Twine *)1);
  }
  size_t result = llvm::MCContext::getMachOSection(*(void *)(a1 + 840), v41, v42, v39, v40, SHIDWORD(v38), v38, a3, 0);
  if (v37)
  {
    if (*(_DWORD *)(result + 240) != HIDWORD(v38)) {
      goto LABEL_16;
    }
  }
  else
  {
    HIDWORD(v38) = *(_DWORD *)(result + 240);
  }
  if (*(_DWORD *)(result + 244) != v38)
  {
LABEL_16:
    __int16 v34 = 1283;
    v33[0] = (uint64_t)"Global variable '";
    v33[2] = (uint64_t)llvm::Value::getName(this);
    v33[3] = v11;
    v31[0] = (uint64_t)"' section type or attributes does not match previous section specifier";
    __int16 v32 = 259;
    uint64_t v12 = v31;
    goto LABEL_17;
  }
  return result;
}

uint64_t llvm::TargetLoweringObjectFileMachO::getSectionForConstant(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  if (a3 > 0x12u)
  {
    if (a3 - 19 <= 1)
    {
      uint64_t v3 = a1 + 576;
      return *(void *)v3;
    }
LABEL_11:
    uint64_t v3 = a1 + 48;
    return *(void *)v3;
  }
  if (a3 == 8)
  {
    uint64_t v3 = a1 + 616;
    return *(void *)v3;
  }
  if (a3 == 9)
  {
    uint64_t v3 = a1 + 624;
    return *(void *)v3;
  }
  if (a3 != 10) {
    goto LABEL_11;
  }
  uint64_t v3 = a1 + 632;
  return *(void *)v3;
}

unint64_t llvm::TargetLoweringObjectFileMachO::getTTypeGlobalReference(llvm::TargetLoweringObjectFileMachO *this, const llvm::GlobalValue *a2, char a3, const llvm::TargetMachine *a4, llvm::MachineModuleInfo *a5, llvm::MCStreamer *a6)
{
  if (a3 < 0)
  {
    uint64_t v12 = sub_1CD586994((uint64_t)a5);
    uint64_t SymbolWithGlobalValueBase = llvm::TargetLoweringObjectFile::getSymbolWithGlobalValueBase((uint64_t)this, a2, "$non_lazy_ptr", 13, (uint64_t)a4);
    uint64_t v16 = SymbolWithGlobalValueBase;
    uint64_t v14 = sub_1CD45F378(v12 + 8, &v16);
    if (v14[1] <= 7uLL) {
      v14[1] = llvm::TargetMachine::getSymbol(a4, a2) & 0xFFFFFFFFFFFFFFFBLL | (4
    }
                                                                              * ((*((_DWORD *)a2 + 8) & 0xFu) - 9 < 0xFFFFFFFE));
    unint64_t v15 = llvm::MCSymbolRefExpr::create(SymbolWithGlobalValueBase, 0, *((void *)this + 105), 0);
    return llvm::TargetLoweringObjectFile::getTTypeReference((uint64_t)this, v15, a3 & 0x7F, (uint64_t)a6);
  }
  else
  {
    return llvm::TargetLoweringObjectFile::getTTypeGlobalReference(this, a2, a3, a4, a5, a6);
  }
}

uint64_t sub_1CD586994(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 2072);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t llvm::TargetLoweringObjectFileMachO::getCFIPersonalitySymbol(llvm::TargetLoweringObjectFileMachO *this, const llvm::GlobalValue *a2, const llvm::TargetMachine *a3, llvm::MachineModuleInfo *a4)
{
  uint64_t v7 = sub_1CD586994((uint64_t)a4);
  uint64_t SymbolWithGlobalValueBase = llvm::TargetLoweringObjectFile::getSymbolWithGlobalValueBase((uint64_t)this, a2, "$non_lazy_ptr", 13, (uint64_t)a3);
  uint64_t v11 = SymbolWithGlobalValueBase;
  unsigned int v9 = sub_1CD45F378(v7 + 8, &v11);
  if (v9[1] <= 7uLL) {
    v9[1] = llvm::TargetMachine::getSymbol(a3, a2) & 0xFFFFFFFFFFFFFFFBLL | (4
  }
                                                                           * ((*((_DWORD *)a2 + 8) & 0xFu) - 9 < 0xFFFFFFFE));
  return SymbolWithGlobalValueBase;
}

unint64_t llvm::TargetLoweringObjectFileMachO::getIndirectSymViaGOTPCRel(llvm::TargetLoweringObjectFileMachO *this, const llvm::GlobalValue *a2, unint64_t a3, const llvm::MCValue *a4, uint64_t a5, llvm::MachineModuleInfo *a6, llvm::MCStreamer *a7)
{
  v33[16] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = sub_1CD586994((uint64_t)a6);
  uint64_t v13 = (llvm::MCContext *)*((void *)this + 105);
  uint64_t v14 = *((void *)a4 + 2);
  uint64_t v15 = *(void *)(*((void *)a4 + 1) + 16);
  long long v31 = v33;
  uint64_t v16 = *(int *)(*((void *)a6 + 258) + 300);
  uint64_t v17 = qword_1CFAC7A58[v16];
  long long v32 = xmmword_1CFAC3020;
  sub_1CC22C75C(&v31, *((unsigned char **)&off_1E6830628 + v16), (unsigned char *)(*((void *)&off_1E6830628 + v16) + v17));
  if ((*(unsigned char *)a3 & 4) != 0)
  {
    __int16 v20 = *(void **)(a3 - 8);
    uint64_t v21 = *v20;
    std::string v18 = v20 + 2;
    uint64_t v19 = v21;
  }
  else
  {
    std::string v18 = 0;
    uint64_t v19 = 0;
  }
  sub_1CC22C75C(&v31, v18, &v18[v19]);
  sub_1CC22C75C(&v31, "$non_lazy_ptr", "");
  __int16 v30 = 261;
  v29[0] = (unsigned __int8 **)v31;
  v29[1] = (unsigned __int8 **)v32;
  Symbol = (unsigned __int8 **)llvm::MCContext::getOrCreateSymbol(v13, v29);
  v29[0] = Symbol;
  __int16 v23 = sub_1CD45F378(v12 + 8, (uint64_t *)v29);
  if (v23[1] <= 7uLL) {
    v23[1] = a3 & 0xFFFFFFFFFFFFFFFBLL | (4 * ((*((_DWORD *)a2 + 8) & 0xFu) - 9 < 0xFFFFFFFE));
  }
  unint64_t v24 = llvm::MCSymbolRefExpr::create(v15, 0, (uint64_t)v13, 0);
  unint64_t v25 = llvm::MCSymbolRefExpr::create((uint64_t)Symbol, 0, (uint64_t)v13, 0);
  if (v14)
  {
    unint64_t v26 = llvm::MCConstantExpr::create((llvm::MCConstantExpr *)-v14, (uint64_t)v13, 0, 0);
    unint64_t v24 = llvm::MCBinaryExpr::create(0, v24, v26, (uint64_t)v13, 0);
  }
  unint64_t v27 = llvm::MCBinaryExpr::create(18, v25, v24, (uint64_t)v13, 0);
  if (v31 != v33) {
    free(v31);
  }
  return v27;
}

BOOL llvm::TargetLoweringObjectFileXCOFF::ShouldEmitEHBlock(llvm::TargetLoweringObjectFileXCOFF *this, const llvm::MachineFunction *a2)
{
  if (*((void *)this + 64) != *((void *)this + 65)) {
    return 1;
  }
  uint64_t v3 = *(_WORD **)this;
  if ((*(_WORD *)(*(void *)this + 18) & 8) == 0
    || !llvm::AttributeList::getUWTableKind((llvm::AttributeList *)(v3 + 56))
    && llvm::Function::hasFnAttribute((uint64_t)v3, 37)
    && (v3[9] & 8) == 0)
  {
    return 0;
  }
  PersonalityFn = (llvm::Value *)llvm::Function::getPersonalityFn((llvm::Function *)v3);
  unint64_t v5 = (unsigned __int8 *)llvm::Value::stripPointerCasts(PersonalityFn);
  if (v5[16] >= 4u) {
    unint64_t v5 = 0;
  }
  return llvm::classifyEHPersonality((llvm::Value *)v5, v6) == 0;
}

uint64_t llvm::TargetLoweringObjectFileXCOFF::getEHInfoTableSymbol(llvm::TargetLoweringObjectFileXCOFF *this, const llvm::MachineFunction *a2)
{
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *(llvm::MCContext **)(v2 + 2056);
  uint64_t v4 = (llvm::MCContext *)(v2 + 8);
  if (v3) {
    unint64_t v5 = v3;
  }
  else {
    unint64_t v5 = v4;
  }
  uint64_t v10 = "__ehinfo.";
  __int16 v11 = 259;
  int v6 = *((_DWORD *)this + 84);
  __int16 v9 = 264;
  LODWORD(v8[0]) = v6;
  sub_1CB8F1E58((uint64_t *)&v10, v8, (uint64_t)v12);
  return llvm::MCContext::getOrCreateSymbol(v5, v12);
}

uint64_t sub_1CD586DD0()
{
  return 4;
}

uint64_t sub_1CD586DD8()
{
  return 0;
}

uint64_t sub_1CD586DE0()
{
  return 0;
}

uint64_t sub_1CD586DE8()
{
  return 0;
}

uint64_t sub_1CD586DF0()
{
  return 0;
}

uint64_t sub_1CD586DF8()
{
  return 0;
}

uint64_t sub_1CD586E00()
{
  return 0;
}

uint64_t sub_1CD586E08()
{
  return 0;
}

void sub_1CD586E14(llvm::TargetLoweringObjectFile *a1)
{
  llvm::TargetLoweringObjectFile::~TargetLoweringObjectFile(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD586E4C(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_1CD586E54(uint64_t a1)
{
  return *(void *)(a1 + 968);
}

uint64_t sub_1CD586E5C()
{
  return 0;
}

uint64_t sub_1CD586E64()
{
  return 0;
}

uint64_t sub_1CD586E70(uint64_t a1)
{
  return *(void *)(a1 + 976);
}

uint64_t sub_1CD586E78(uint64_t result, uint64_t a2)
{
  v2[0] = result;
  v2[1] = a2;
  if (*(unsigned char *)(a2 + result - 1) == 93)
  {
    char v3 = 91;
    llvm::StringRef::rfind(v2, &v3, 1uLL);
    return v2[0];
  }
  return result;
}

uint64_t sub_1CD586EE0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 == *(void *)(a1 + 48) || v1 == 0) {
    return 0;
  }
  else {
    return v1 - 48;
  }
}

uint64_t sub_1CD586EFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1 == *(void *)(a1 + 56) || v1 == 0) {
    return 0;
  }
  else {
    return v1 - 56;
  }
}

void llvm::TargetPassConfig::~TargetPassConfig(llvm::TargetPassConfig *this)
{
  *(void *)this = &unk_1F2614AD8;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    sub_1CC4AFEA4(v2);
  }

  llvm::ImmutablePass::~ImmutablePass(this);
}

{
  uint64_t vars8;

  llvm::TargetPassConfig::~TargetPassConfig(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *llvm::TargetPassConfig::setStartStopPasses(llvm::TargetPassConfig *this)
{
  if (byte_1EBCD69E7 >= 0) {
    uint64_t v2 = byte_1EBCD69E7 & 0x7F;
  }
  else {
    uint64_t v2 = qword_1EBCD69D8;
  }
  if (byte_1EBCD69E7 >= 0) {
    char v3 = &qword_1EBCD69D0;
  }
  else {
    char v3 = (uint64_t *)qword_1EBCD69D0;
  }
  sub_1CC4ADA8C((uint64_t)&v30, (uint64_t)v3, v2);
  uint64_t v4 = v30;
  size_t v5 = v31;
  *((_DWORD *)this + 18) = v32;
  if (byte_1EBCD68FF >= 0) {
    uint64_t v6 = byte_1EBCD68FF & 0x7F;
  }
  else {
    uint64_t v6 = qword_1EBCD68F0;
  }
  if (byte_1EBCD68FF >= 0) {
    uint64_t v7 = &qword_1EBCD68E8;
  }
  else {
    uint64_t v7 = (uint64_t *)qword_1EBCD68E8;
  }
  sub_1CC4ADA8C((uint64_t)&v30, (uint64_t)v7, v6);
  uint64_t v8 = v30;
  size_t v9 = v31;
  *((_DWORD *)this + 20) = v32;
  if (byte_1EBCD6BB7 >= 0) {
    uint64_t v10 = byte_1EBCD6BB7 & 0x7F;
  }
  else {
    uint64_t v10 = qword_1EBCD6BA8;
  }
  if (byte_1EBCD6BB7 >= 0) {
    __int16 v11 = &qword_1EBCD6BA0;
  }
  else {
    __int16 v11 = (uint64_t *)qword_1EBCD6BA0;
  }
  sub_1CC4ADA8C((uint64_t)&v30, (uint64_t)v11, v10);
  uint64_t v12 = v30;
  size_t v13 = v31;
  *((_DWORD *)this + 22) = v32;
  if (byte_1EBCD6ACF >= 0) {
    uint64_t v14 = byte_1EBCD6ACF & 0x7F;
  }
  else {
    uint64_t v14 = qword_1EBCD6AC0;
  }
  if (byte_1EBCD6ACF >= 0) {
    uint64_t v15 = &qword_1EBCD6AB8;
  }
  else {
    uint64_t v15 = (uint64_t *)qword_1EBCD6AB8;
  }
  sub_1CC4ADA8C((uint64_t)&v30, (uint64_t)v15, v14);
  uint64_t v16 = v30;
  size_t v17 = v31;
  *((_DWORD *)this + 24) = v32;
  *((void *)this + 5) = sub_1CC4ADBE4(v4, v5);
  *((void *)this + 6) = sub_1CC4ADBE4(v8, v9);
  *((void *)this + 7) = sub_1CC4ADBE4(v12, v13);
  uint64_t result = sub_1CC4ADBE4(v16, v17);
  *((void *)this + 8) = result;
  if (*((void *)this + 5) && *((void *)this + 6))
  {
    v26[0] = (uint64_t)"start-before";
    __int16 v27 = 259;
    v24[0] = (uint64_t)" and ";
    __int16 v25 = 259;
    sub_1CD3E3950(v26, v24, (uint64_t)v28);
    uint64_t v19 = "start-after";
    goto LABEL_32;
  }
  if (*((void *)this + 7) && result)
  {
    v26[0] = (uint64_t)"stop-before";
    __int16 v27 = 259;
    v24[0] = (uint64_t)" and ";
    __int16 v25 = 259;
    sub_1CD3E3950(v26, v24, (uint64_t)v28);
    uint64_t v19 = "stop-after";
LABEL_32:
    __int16 v22 = v19;
    __int16 v23 = 259;
    sub_1CD3E3950(v28, (uint64_t *)&v22, (uint64_t)v29);
    __int16 v20 = " specified!";
    __int16 v21 = 259;
    sub_1CD3E3950(v29, (uint64_t *)&v20, (uint64_t)&v30);
    llvm::report_fatal_error((llvm *)&v30, (const llvm::Twine *)1);
  }
  *((unsigned char *)this + 104) = *(_OWORD *)((char *)this + 40) == 0;
  return result;
}

void llvm::TargetPassConfig::TargetPassConfig(llvm::TargetPassConfig *this, llvm::LLVMTargetMachine *a2, llvm::legacy::PassManagerBase *a3)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::TargetPassConfig::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2614AD8;
  *((void *)this + 4) = a3;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 16777217;
  *((void *)this + 14) = a2;
  *((void *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0x10000;
  operator new();
}

void llvm::LLVMTargetMachine::createPassConfig(llvm::LLVMTargetMachine *this, llvm::legacy::PassManagerBase *a2)
{
}

BOOL llvm::TargetPassConfig::willCompleteCodeGenPipeline(llvm::TargetPassConfig *this)
{
  uint64_t v1 = qword_1EBCD6BA8;
  if (byte_1EBCD6BB7 >= 0) {
    uint64_t v1 = byte_1EBCD6BB7 & 0x7F;
  }
  if (v1) {
    return 0;
  }
  uint64_t v2 = qword_1EBCD6AC0;
  if (byte_1EBCD6ACF >= 0) {
    uint64_t v2 = byte_1EBCD6ACF & 0x7F;
  }
  return v2 == 0;
}

void llvm::TargetPassConfig::setOpt(llvm::TargetPassConfig *this, BOOL *a2, BOOL a3)
{
  *a2 = a3;
}

void *llvm::TargetPassConfig::substitutePass(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7 = a2;
  uint64_t result = sub_1CD58B5EC(*(void *)(a1 + 120), &v7);
  result[1] = a3;
  *((unsigned char *)result + 16) = a4;
  return result;
}

llvm *llvm::TargetPassConfig::printAndVerify(llvm *a1)
{
  uint64_t result = llvm::TargetPassConfig::addPrintPass(a1);
  if (dword_1EBCD5C98 == 1) {
    llvm::createMachineVerifierPass();
  }
  return result;
}

llvm *llvm::TargetPassConfig::addPrintPass(llvm *result)
{
  if (byte_1EBCD6118)
  {
    llvm::dbgs(result);
    llvm::createMachineFunctionPrinterPass();
  }
  return result;
}

void llvm::TargetPassConfig::addIRPasses(llvm::TargetPassConfig *this)
{
  if (!*((unsigned char *)this + 129)) {
    llvm::createVerifierPass((llvm *)1);
  }
  if (*(_DWORD *)(*((void *)this + 14) + 552))
  {
    if (dword_1EBCD7138 != 3)
    {
      if (dword_1EBCD7138 != 2)
      {
        if (dword_1EBCD7138 != 1) {
          llvm::createTypeBasedAAWrapperPass(this);
        }
        llvm::createCFLSteensAAWrapperPass(this);
      }
      llvm::createCFLAndersAAWrapperPass(this);
    }
    llvm::createCFLAndersAAWrapperPass(this);
  }
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EEDB);
  uint64_t v2 = (llvm *)llvm::TargetPassConfig::addPass(this, &unk_1EA61EF4B);
  llvm::createLowerConstantIntrinsicsPass(v2);
}

llvm *llvm::TargetPassConfig::addPassesToHandleExceptions(llvm::TargetPassConfig *this, const llvm::TargetMachine *a2)
{
  uint64_t result = (llvm *)*((void *)this + 14);
  int v3 = *(_DWORD *)(*((void *)result + 70) + 412);
  if (v3 != 1)
  {
    switch(v3)
    {
      case 0:
        llvm::createLowerInvokePass(result);
      case 2:
        llvm::createSjLjEHPreparePass(result, a2);
      case 3:
      case 6:
        break;
      case 4:
        llvm::createWinEHPass(0);
      case 5:
        llvm::createWinEHPass(0);
      default:
        return result;
    }
  }
  llvm::createDwarfEHPass();
}

uint64_t llvm::TargetPassConfig::addCodeGenPrepare(uint64_t this)
{
  if (*(_DWORD *)(*(void *)(this + 112) + 552)) {
    BOOL v1 = byte_1EBCD5698 == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1) {
    llvm::createCodeGenPreparePass(0);
  }
  return this;
}

void llvm::TargetPassConfig::addISelPrepare(llvm::TargetPassConfig *this)
{
  uint64_t v2 = (llvm *)(*(uint64_t (**)(llvm::TargetPassConfig *))(*(void *)this + 296))(this);
  if (*((unsigned char *)this + 131)) {
    operator new();
  }
  llvm::createSafeStackPass(v2);
}

BOOL llvm::TargetPassConfig::isGlobalISelAbortEnabled(llvm::TargetPassConfig *this)
{
  return *(_DWORD *)(*((void *)this + 14) + 1024) == 1;
}

void llvm::TargetPassConfig::addISelPasses(llvm::TargetMachine **this)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  BOOL v1 = llvm::TargetMachine::useEmulatedTLS(this[14]);
  if (!v1) {
    llvm::createPreISelIntrinsicLoweringPass((llvm *)v1);
  }
  llvm::createLowerEmuTLSPass((llvm *)v1);
}

uint64_t llvm::TargetPassConfig::addMachineSSAOptimization(llvm::TargetPassConfig *this)
{
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF54);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF30);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF4F);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EEE4);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EED0);
  (*(void (**)(llvm::TargetPassConfig *))(*(void *)this + 312))(this);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EEFB);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EEF2);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF28);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF31);

  return llvm::TargetPassConfig::addPass(this, &unk_1EA61EED0);
}

void llvm::TargetPassConfig::createTargetRegisterAllocator(llvm *this, int a2)
{
  if (a2) {
    llvm::createGreedyRegisterAllocator(this);
  }
  llvm::createFastRegisterAllocator(this);
}

uint64_t llvm::TargetPassConfig::createRegAllocPass(llvm::TargetPassConfig *this, uint64_t a2)
{
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD4860, memory_order_acquire) != -1)
  {
    size_t v5 = &v6;
    uint64_t v6 = sub_1CC4AFE6C;
    std::__call_once(&qword_1EBCD4860, &v5, (void (__cdecl *)(void *))sub_1CBF42120);
  }
  if (off_1EBCBE7A8 == sub_1CC4AF680) {
    return (*(uint64_t (**)(llvm::TargetPassConfig *, uint64_t))(*(void *)this + 352))(this, a2);
  }
  else {
    return off_1EBCBE7A8();
  }
}

uint64_t llvm::TargetPassConfig::addRegAssignAndRewriteFast(llvm::TargetPassConfig *this)
{
  if ((uint64_t (*)())xmmword_1EBCD7390 != sub_1CC4AF680
    && (void (*)(llvm *))xmmword_1EBCD7390 != llvm::createFastRegisterAllocator)
  {
    llvm::report_fatal_error((llvm *)"Must use fast (default) register allocator for unoptimized regalloc.", (const llvm::Twine *)1);
  }
  uint64_t v2 = (llvm::Pass *)(*(uint64_t (**)(llvm::TargetPassConfig *, void))(*(void *)this + 456))(this, 0);
  llvm::TargetPassConfig::addPass(this, v2);
  (*(void (**)(llvm::TargetPassConfig *))(*(void *)this + 384))(this);
  return 1;
}

void llvm::TargetPassConfig::addRegAssignAndRewriteOptimized(llvm::TargetPassConfig *this)
{
  uint64_t v2 = (llvm::Pass *)(*(uint64_t (**)(llvm::TargetPassConfig *, uint64_t))(*(void *)this + 456))(this, 1);
  llvm::TargetPassConfig::addPass(this, v2);
  (*(void (**)(llvm::TargetPassConfig *))(*(void *)this + 376))(this);
  int v3 = (llvm *)llvm::TargetPassConfig::addPass(this, &unk_1EA61EF58);
  llvm::createRegAllocScoringPass(v3);
}

uint64_t llvm::TargetPassConfig::addFastRegAlloc(llvm::TargetPassConfig *this)
{
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF32);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF56);
  uint64_t v2 = *(uint64_t (**)(llvm::TargetPassConfig *))(*(void *)this + 464);

  return v2(this);
}

uint64_t llvm::TargetPassConfig::addOptimizedRegAlloc(llvm::TargetPassConfig *this)
{
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EED1);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF34);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF57);
  llvm::TargetPassConfig::addPass(this, &llvm::LiveVariables::ID);
  llvm::TargetPassConfig::addPass(this, llvm::MachineLoopInfo::ID);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF32);
  if (byte_1EBCD64D8) {
    llvm::TargetPassConfig::addPass(this, &llvm::LiveIntervals::ID);
  }
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF56);
  if ((*(unsigned int (**)(llvm::TargetPassConfig *))(*(void *)this + 320))(this))
  {
    __p = (char *)operator new(0x28uLL);
    strcpy(__p, "After pre Register Coalescer passes");
    llvm::TargetPassConfig::printAndVerify(this);
    operator delete(__p);
  }
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF44);
  if ((*(unsigned int (**)(llvm::TargetPassConfig *))(*(void *)this + 328))(this))
  {
    __pa = (char *)operator new(0x28uLL);
    strcpy(__pa, "After pre Machine Scheduler passes");
    llvm::TargetPassConfig::printAndVerify(this);
    operator delete(__pa);
  }
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF46);
  llvm::TargetPassConfig::addPass(this, &unk_1EA61EF20);
  if ((*(unsigned int (**)(llvm::TargetPassConfig *))(*(void *)this + 336))(this))
  {
    __pb = (char *)operator new(0x28uLL);
    strcpy(__pb, "After post Machine Scheduling passes");
    llvm::TargetPassConfig::printAndVerify(this);
    operator delete(__pb);
  }
  uint64_t result = (*(uint64_t (**)(llvm::TargetPassConfig *))(*(void *)this + 472))(this);
  if (result)
  {
    llvm::TargetPassConfig::addPass(this, &unk_1EA61EF52);
    (*(void (**)(llvm::TargetPassConfig *))(*(void *)this + 392))(this);
    llvm::TargetPassConfig::addPass(this, &unk_1EA61EEF1);
    return llvm::TargetPassConfig::addPass(this, &unk_1EA61EEFA);
  }
  return result;
}

uint64_t llvm::TargetPassConfig::addMachineLateOptimization(llvm::TargetPassConfig *this)
{
  llvm::TargetPassConfig::addPass(this, &unk_1EA61ECD3);
  if ((*(unsigned char *)(*((void *)this + 14) + 592) & 1) == 0) {
    llvm::TargetPassConfig::addPass(this, &unk_1EA61EF53);
  }

  return llvm::TargetPassConfig::addPass(this, &unk_1EA61EEF1);
}

uint64_t llvm::TargetPassConfig::addGCPasses(llvm::TargetPassConfig *this)
{
  return 1;
}

uint64_t llvm::TargetPassConfig::addBlockPlacement(llvm::TargetPassConfig *this)
{
  if (byte_1EBD064B8) {
    llvm::createMIRAddFSDiscriminatorsPass();
  }
  uint64_t result = llvm::TargetPassConfig::addPass(this, &unk_1EA61EEE9);
  if (result)
  {
    if (byte_1EBCD4D98) {
      return llvm::TargetPassConfig::addPass(this, &unk_1EA61EEEA);
    }
  }
  return result;
}

BOOL llvm::TargetPassConfig::reportDiagnosticWhenGlobalISelFallback(llvm::TargetPassConfig *this)
{
  return *(_DWORD *)(*((void *)this + 14) + 1024) == 2;
}

uint64_t llvm::TargetPassConfig::isGISelCSEEnabled(llvm::TargetPassConfig *this)
{
  return 1;
}

void llvm::TargetPassConfig::getCSEConfig(llvm::TargetPassConfig *this)
{
}

uint64_t sub_1CD5886EC()
{
  return 0;
}

uint64_t sub_1CD5886F4()
{
  return 0;
}

uint64_t sub_1CD5886FC()
{
  return 0;
}

uint64_t sub_1CD588704()
{
  return 0;
}

void *sub_1CD588710(void *a1)
{
  *a1 = &unk_1F2614CC8;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2614D30;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD5887F8(void *a1)
{
  *a1 = &unk_1F2614D30;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD58884C(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD5888E0(v11);
}

uint64_t sub_1CD5888E0(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD5888F8(void *a1)
{
  sub_1CD588710(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD588930(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD58893C(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD58894C(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F2614D80;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD5889D0(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD5889E4(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD5889EC(void *a1)
{
  *a1 = &unk_1F2614D30;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD588A60(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD588A68(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD588A7C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD588A90(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD588AA4(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void *sub_1CD588AD0(void *a1)
{
  *a1 = &unk_1F2614DC0;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2614E28;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD588BB8(void *a1)
{
  *a1 = &unk_1F2614E28;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD588C0C(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD588CA0(v11);
}

uint64_t sub_1CD588CA0(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD588CB8(void *a1)
{
  sub_1CD588AD0(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD588CF0(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD588CFC(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD588D0C(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F2614E78;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD588D90(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD588DA8(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD588DB0(void *a1)
{
  *a1 = &unk_1F2614E28;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD588E24(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD588E2C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD588E40(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD588E54(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD588E68(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void *sub_1CD588E94(void *a1)
{
  *a1 = &unk_1F2614EB8;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2614F20;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD588F7C(void *a1)
{
  *a1 = &unk_1F2614F20;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD588FD0(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD589064(v11);
}

uint64_t sub_1CD589064(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD58907C(void *a1)
{
  sub_1CD588E94(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD5890B4(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD5890C0(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD5890D0(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F2614F70;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD589154(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD589168(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD589170(void *a1)
{
  *a1 = &unk_1F2614F20;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5891E4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD5891EC(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD589200(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD589214(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD589228(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void llvm::callDefaultCtor<llvm::TargetPassConfig>()
{
}

llvm *sub_1CD58927C(llvm *result)
{
  unint64_t v1 = *((void *)result + 3);
  if (v1 >= 8)
  {
    if ((v1 & 4) != 0)
    {
      uint64_t v2 = *((void *)result + 3);
      int v3 = result;
      if ((v1 & 2) == 0) {
        uint64_t result = *(llvm **)result;
      }
      (*(void (**)(llvm *))((v1 & 0xFFFFFFFFFFFFFFF8) + 16))(result);
      LOBYTE(v1) = v2;
      uint64_t result = v3;
    }
    if ((v1 & 2) == 0) {
      llvm::deallocate_buffer(*(llvm **)result, *((void **)result + 1));
    }
  }
  return result;
}

void sub_1CD5892E4()
{
}

uint64_t sub_1CD5892EC(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v12 = 0;
  uint64_t v8 = sub_1CD54B1C4(a1 + 168, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(void *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 672);
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD589380(v11);
}

uint64_t sub_1CD589380(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 176) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD589398(void *a1)
{
  sub_1CC4B00CC(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD5893D0(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 168), a1);
}

uint64_t sub_1CD5893DC(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 168), a1, a2);
}

llvm::raw_ostream *sub_1CD5893EC(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = *((void *)result + 16);
LABEL_3:
    char v5 = 1;
    v4[0] = &unk_1F26150F0;
    v4[1] = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 168), result, (const llvm::cl::GenericOptionValue *)v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 152))
  {
    uint64_t v3 = *((void *)result + 16);
    if (*((void *)result + 18) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD58946C(uint64_t result)
{
  if (*(unsigned char *)(result + 152)) {
    uint64_t v1 = *(void *)(result + 144);
  }
  else {
    uint64_t v1 = 0;
  }
  *(void *)(result + 128) = v1;
  return result;
}

void *sub_1CD589488(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 168), a2);
}

void sub_1CD589494(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

uint64_t sub_1CD58949C(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result = llvm::cl::generic_parser_base::findOption(a1 + 8, a2, a3);
  uint64_t v5 = *(void *)(a1 + 24);
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  uint64_t v7 = v5 + 56 * v6;
  uint64_t v8 = v5 + 56 * result + 56;
  if (v8 != v7)
  {
    uint64_t v9 = 56 * v6 - 56 * result - 56;
    do
    {
      long long v10 = *(_OWORD *)(v8 + 16);
      *(_OWORD *)(v8 - 56) = *(_OWORD *)v8;
      *(_OWORD *)(v8 - 40) = v10;
      *(void *)(v8 - 16) = *(void *)(v8 + 40);
      *(unsigned char *)(v8 - 8) = *(unsigned char *)(v8 + 48);
      v8 += 56;
      v9 -= 56;
    }
    while (v9);
    unsigned int v6 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v6 - 1;
  return result;
}

void sub_1CD58952C(uint64_t a1)
{
  sub_1CC4B018C((void *)(a1 - 8));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD589568(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD589570(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 56 * a2);
}

uint64_t sub_1CD589584(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 56 * a2 + 16);
}

uint64_t sub_1CD589598(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 56 * a2 + 32;
}

void *sub_1CD5895AC(void *a1)
{
  *a1 = &unk_1F26150A0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

void sub_1CD589600(void *a1)
{
  *a1 = &unk_1F26150A0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD589674(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v13[0] = a2;
  v13[1] = a3;
  uint64_t v13[2] = a5;
  v13[3] = a6;
  char v14 = 1;
  v13[4] = &unk_1F26150F0;
  v13[5] = a4;
  unint64_t v9 = sub_1CD589794(a1 + 16, (unint64_t)v13);
  uint64_t v10 = *(void *)(a1 + 16) + 56 * *(unsigned int *)(a1 + 24);
  long long v11 = *(_OWORD *)(v9 + 16);
  *(_OWORD *)uint64_t v10 = *(_OWORD *)v9;
  *(_OWORD *)(v10 + 16) = v11;
  *(void *)(v10 + 32) = &unk_1F2615110;
  uint64_t v12 = *(void *)(v9 + 40);
  *(unsigned char *)(v10 + 48) = *(unsigned char *)(v9 + 48);
  *(void *)(v10 + 32) = &unk_1F26150F0;
  *(void *)(v10 + 40) = v12;
  ++*(_DWORD *)(a1 + 24);
  llvm::cl::AddLiteralOption(*(void *)(a1 + 8), a2, a3);
}

BOOL sub_1CD589768(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 16) && *(unsigned char *)(a1 + 16) && *(void *)(a1 + 8) != *(void *)(a2 + 8);
}

unint64_t sub_1CD589794(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 56 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD58980C();
    }
    sub_1CD58980C();
  }
  return a2;
}

void sub_1CD58980C()
{
}

void sub_1CD5898EC(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD4B98, 0, 0);
  byte_1EBCD4C18 = 0;
  qword_1EBCD4C20 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD4C28 = 0;
  qword_1EBCD4B98 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD4C30 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD4C38 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD4C50 = (uint64_t)&qword_1EBCD4C38;
  llvm::cl::Option::setArgStr(v4, "disable-early-taildup", 0x15uLL);
  word_1EBCD4BA2 = (32 * (*a1 & 3)) | word_1EBCD4BA2 & 0xFF9F;
  xmmword_1EBCD4BB8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD4B98);
}

void sub_1CD5899F8(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD4C58, 0, 0);
  byte_1EBCD4CD8 = 0;
  qword_1EBCD4CE0 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD4CE8 = 0;
  qword_1EBCD4C58 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD4CF0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD4CF8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD4D10 = (uint64_t)&qword_1EBCD4CF8;
  llvm::cl::Option::setArgStr(v4, "disable-block-placement", 0x17uLL);
  word_1EBCD4C62 = (32 * (*a1 & 3)) | word_1EBCD4C62 & 0xFF9F;
  xmmword_1EBCD4C78 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD4C58);
}

void sub_1CD589B04(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD5198, 0, 0);
  dword_1EBCD5218 = 0;
  qword_1EBCD5220 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD5228 = 0;
  qword_1EBCD5198 = (uint64_t)&unk_1F2609740;
  qword_1EBCD5230 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD5238 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD5250 = (uint64_t)&qword_1EBCD5238;
  llvm::cl::Option::setArgStr(v4, "optimize-regalloc", 0x11uLL);
  word_1EBCD51A2 = (32 * (*a1 & 3)) | word_1EBCD51A2 & 0xFF9F;
  xmmword_1EBCD51B8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5198);
}

void sub_1CD589C10(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD5558, 0, 0);
  byte_1EBCD55D8 = 0;
  qword_1EBCD55E0 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD55E8 = 0;
  qword_1EBCD5558 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD55F0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD55F8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD5610 = (uint64_t)&qword_1EBCD55F8;
  llvm::cl::Option::setArgStr(v4, "disable-constant-hoisting", 0x19uLL);
  word_1EBCD5562 = (32 * (*a1 & 3)) | word_1EBCD5562 & 0xFF9F;
  xmmword_1EBCD5578 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5558);
}

void sub_1CD589D1C(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD5B58, 0, 0);
  byte_1EBCD5BD8 = 0;
  qword_1EBCD5BE0 = (uint64_t)&unk_1F25EDE58;
  unk_1EBCD5BE8 = 0;
  qword_1EBCD5B58 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD5BF0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD5BF8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD5C10 = (uint64_t)&qword_1EBCD5BF8;
  llvm::cl::Option::setArgStr(v4, "print-gc", 8uLL);
  word_1EBCD5B62 = (32 * (*a1 & 3)) | word_1EBCD5B62 & 0xFF9F;
  xmmword_1EBCD5B78 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5B58);
}

void sub_1CD589E28(_WORD *a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD5C18, 0, 0);
  dword_1EBCD5C98 = 0;
  qword_1EBCD5CA0 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD5CA8 = 0;
  qword_1EBCD5C18 = (uint64_t)&unk_1F2609740;
  qword_1EBCD5CB0 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD5CB8 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD5CD0 = (uint64_t)&qword_1EBCD5CB8;
  sub_1CD589F18(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5C18);
}

__n128 sub_1CD589F18(_WORD *a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD5C18, "verify-machineinstrs", 0x14uLL);
  word_1EBCD5C22 = word_1EBCD5C22 & 0xFF9F | (32 * (*a1 & 3));
  __n128 result = *a2;
  xmmword_1EBCD5C38 = (__int128)*a2;
  word_1EBCD5C22 = word_1EBCD5C22 & 0xFFF8 | *a3 & 7;
  return result;
}

void sub_1CD589F88(_WORD *a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD5CD8, 0, 0);
  dword_1EBCD5D58 = 0;
  qword_1EBCD5D60 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD5D68 = 0;
  qword_1EBCD5CD8 = (uint64_t)&unk_1F2609740;
  qword_1EBCD5D70 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD5D78 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD5D90 = (uint64_t)&qword_1EBCD5D78;
  sub_1CD58A078(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5CD8);
}

__n128 sub_1CD58A078(_WORD *a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD5CD8, "debugify-and-strip-all-safe", 0x1BuLL);
  word_1EBCD5CE2 = word_1EBCD5CE2 & 0xFF9F | (32 * (*a1 & 3));
  __n128 result = *a2;
  xmmword_1EBCD5CF8 = (__int128)*a2;
  word_1EBCD5CE2 = word_1EBCD5CE2 & 0xFFF8 | *a3 & 7;
  return result;
}

void sub_1CD58A0E8(_WORD *a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD5D98, 0, 0);
  dword_1EBCD5E18 = 0;
  qword_1EBCD5E20 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD5E28 = 0;
  qword_1EBCD5D98 = (uint64_t)&unk_1F2609740;
  qword_1EBCD5E30 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD5E38 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD5E50 = (uint64_t)&qword_1EBCD5E38;
  sub_1CD58A1D8(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5D98);
}

__n128 sub_1CD58A1D8(_WORD *a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD5D98, "debugify-check-and-strip-all-safe", 0x21uLL);
  word_1EBCD5DA2 = word_1EBCD5DA2 & 0xFF9F | (32 * (*a1 & 3));
  __n128 result = *a2;
  xmmword_1EBCD5DB8 = (__int128)*a2;
  word_1EBCD5DA2 = word_1EBCD5DA2 & 0xFFF8 | *a3 & 7;
  return result;
}

void sub_1CD58A248(long long *a1, _WORD *a2, _WORD *a3, int **a4, uint64_t a5)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD6C08, 0, 0);
  dword_1EBCD6C88 = 0;
  qword_1EBCD6C90 = (uint64_t)&unk_1F2614D80;
  *(void *)&dword_1EBCD6C98 = 0;
  qword_1EBCD6C08 = (uint64_t)&unk_1F2614CC8;
  qword_1EBCD6CA0 = (uint64_t)&unk_1F2614D30;
  qword_1EBCD6CA8 = (uint64_t)&qword_1EBCD6C08;
  qword_1EBCD6CB0 = (uint64_t)&unk_1EBCD6CC0;
  qword_1EBCD6CB8 = 0x800000000;
  qword_1EBCD6E40 = (uint64_t)&unk_1F2615130;
  qword_1EBCD6E58 = (uint64_t)&qword_1EBCD6E40;
  sub_1CD58A364(a1, a2, a3, a4, a5);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD6C08);
}

void sub_1CD58A364(long long *a1, _WORD *a2, _WORD *a3, int **a4, uint64_t a5)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD6C08, "enable-machine-outliner", 0x17uLL);
  xmmword_1EBCD6C28 = *a1;
  word_1EBCD6C12 = word_1EBCD6C12 & 0xFF9F | (32 * (*a2 & 3));
  word_1EBCD6C12 = (8 * (*a3 & 3)) | word_1EBCD6C12 & 0xFFE7;
  uint64_t v10 = *a4;
  dword_1EBCD6C88 = **a4;
  byte_1EBCD6C9C = 1;
  dword_1EBCD6C98 = *v10;
  uint64_t v11 = *(void *)a5;
  unsigned int v12 = *(_DWORD *)(a5 + 8);

  sub_1CD58A49C(v11, v12);
}

void sub_1CD58A424()
{
}

void *sub_1CD58A438()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2615130;
  return result;
}

void sub_1CD58A470(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2615130;
}

void sub_1CD58A49C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD58A4E8(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD58A4E8(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  _DWORD v11[2] = a4;
  void v11[3] = a5;
  v11[4] = &unk_1F2614D80;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD58A5DC((unint64_t)v11);
  uint64_t v8 = qword_1EBCD6CB0 + 48 * qword_1EBCD6CB8;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2614DA0;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2614D80;
  LODWORD(qword_1EBCD6CB8) = qword_1EBCD6CB8 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCD6CA8, a1, a2);
}

unint64_t sub_1CD58A5DC(unint64_t result)
{
  if (qword_1EBCD6CB8 >= HIDWORD(qword_1EBCD6CB8))
  {
    if (qword_1EBCD6CB0 > result || qword_1EBCD6CB0 + 48 * (unint64_t)qword_1EBCD6CB8 <= result) {
      sub_1CD58A658();
    }
    sub_1CD58A658();
  }
  return result;
}

void sub_1CD58A658()
{
}

void sub_1CD58A750(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD5F18, 0, 0);
  dword_1EBCD5F98 = 0;
  qword_1EBCD5FA0 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD5FA8 = 0;
  qword_1EBCD5F18 = (uint64_t)&unk_1F2609740;
  qword_1EBCD5FB0 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD5FB8 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD5FD0 = (uint64_t)&qword_1EBCD5FB8;
  llvm::cl::Option::setArgStr(v4, "fast-isel", 9uLL);
  word_1EBCD5F22 = (32 * (*a1 & 3)) | word_1EBCD5F22 & 0xFF9F;
  xmmword_1EBCD5F38 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5F18);
}

void sub_1CD58A85C(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCD5FD8, 0, 0);
  dword_1EBCD6058 = 0;
  qword_1EBCD6060 = (uint64_t)&unk_1F2643C00;
  unk_1EBCD6068 = 0;
  qword_1EBCD5FD8 = (uint64_t)&unk_1F2609740;
  qword_1EBCD6070 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCD6078 = (uint64_t)&unk_1F26097A8;
  qword_1EBCD6090 = (uint64_t)&qword_1EBCD6078;
  llvm::cl::Option::setArgStr(v4, "global-isel", 0xBuLL);
  word_1EBCD5FE2 = (32 * (*a1 & 3)) | word_1EBCD5FE2 & 0xFF9F;
  xmmword_1EBCD5FF8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD5FD8);
}

void sub_1CD58A968(_WORD *a1, long long *a2, uint64_t a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD6E60, 0, 0);
  dword_1EBCD6EE0 = 0;
  qword_1EBCD6EE8 = (uint64_t)&unk_1F2614E78;
  unk_1EBCD6EF0 = 0;
  qword_1EBCD6E60 = (uint64_t)&unk_1F2614DC0;
  qword_1EBCD6EF8 = (uint64_t)&unk_1F2614E28;
  qword_1EBCD6F00 = (uint64_t)&qword_1EBCD6E60;
  qword_1EBCD6F08 = (uint64_t)&unk_1EBCD6F18;
  qword_1EBCD6F10 = 0x800000000;
  qword_1EBCD7098 = (uint64_t)&unk_1F2615178;
  qword_1EBCD70B0 = (uint64_t)&qword_1EBCD7098;
  sub_1CD58AA6C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD6E60);
}

void sub_1CD58AA6C(_WORD *a1, long long *a2, uint64_t a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD6E60, "global-isel-abort", 0x11uLL);
  word_1EBCD6E6A = (32 * (*a1 & 3)) | word_1EBCD6E6A & 0xFF9F;
  xmmword_1EBCD6E80 = *a2;
  uint64_t v6 = *(void *)a3;
  unsigned int v7 = *(_DWORD *)(a3 + 8);

  sub_1CD58AB6C(v6, v7);
}

void sub_1CD58AAF4()
{
}

void *sub_1CD58AB08()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2615178;
  return result;
}

void sub_1CD58AB40(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2615178;
}

void sub_1CD58AB6C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD58ABB8(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD58ABB8(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  _DWORD v11[2] = a4;
  void v11[3] = a5;
  v11[4] = &unk_1F2614E78;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD58ACAC((unint64_t)v11);
  uint64_t v8 = qword_1EBCD6F08 + 48 * qword_1EBCD6F10;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2614E98;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2614E78;
  LODWORD(qword_1EBCD6F10) = qword_1EBCD6F10 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCD6F00, a1, a2);
}

unint64_t sub_1CD58ACAC(unint64_t result)
{
  if (qword_1EBCD6F10 >= HIDWORD(qword_1EBCD6F10))
  {
    if (qword_1EBCD6F08 > result || qword_1EBCD6F08 + 48 * (unint64_t)qword_1EBCD6F10 <= result) {
      sub_1CD58AD28();
    }
    sub_1CD58AD28();
  }
  return result;
}

void sub_1CD58AD28()
{
}

void sub_1CD58AE20(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD6698, 0, 0);
  qword_1EBCD6718 = 0;
  qword_1EBCD6720 = 0;
  qword_1EBCD6740 = 0;
  unk_1EBCD6748 = 0;
  byte_1EBCD6750 = 0;
  qword_1EBCD6738 = 0;
  unk_1EBCD6728 = 0;
  unk_1EBCD6730 = &unk_1F2643C20;
  qword_1EBCD6698 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCD6758 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCD6760 = (uint64_t)&unk_1F25F6428;
  qword_1EBCD6778 = (uint64_t)&qword_1EBCD6760;
  sub_1CD58AF2C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD6698);
}

__n128 sub_1CD58AF2C(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD6698, "fs-profile-file", 0xFuLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCD6698);
  xmmword_1EBCD66C8 = *a2;
  __n128 result = *a3;
  xmmword_1EBCD66B8 = (__int128)*a3;
  word_1EBCD66A2 = (32 * (*a4 & 3)) | word_1EBCD66A2 & 0xFF9F;
  return result;
}

void sub_1CD58AFB8(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD6780, 0, 0);
  qword_1EBCD6800 = 0;
  qword_1EBCD6808 = 0;
  qword_1EBCD6828 = 0;
  unk_1EBCD6830 = 0;
  byte_1EBCD6838 = 0;
  qword_1EBCD6820 = 0;
  unk_1EBCD6810 = 0;
  unk_1EBCD6818 = &unk_1F2643C20;
  qword_1EBCD6780 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCD6840 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCD6848 = (uint64_t)&unk_1F25F6428;
  qword_1EBCD6860 = (uint64_t)&qword_1EBCD6848;
  sub_1CD58B0C4(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD6780);
}

__n128 sub_1CD58B0C4(const char **a1, long long *a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD6780, "fs-remapping-file", 0x11uLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCD6780);
  xmmword_1EBCD67B0 = *a2;
  __n128 result = *a3;
  xmmword_1EBCD67A0 = (__int128)*a3;
  word_1EBCD678A = (32 * (*a4 & 3)) | word_1EBCD678A & 0xFF9F;
  return result;
}

void sub_1CD58B150(int **a1, _WORD *a2, long long *a3, uint64_t *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD70B8, 0, 0);
  dword_1EBCD7138 = 0;
  qword_1EBCD7140 = (uint64_t)&unk_1F2614F70;
  *(void *)&dword_1EBCD7148 = 0;
  qword_1EBCD70B8 = (uint64_t)&unk_1F2614EB8;
  qword_1EBCD7150 = (uint64_t)&unk_1F2614F20;
  unk_1EBCD7158 = &qword_1EBCD70B8;
  qword_1EBCD7160 = (uint64_t)&unk_1EBCD7170;
  qword_1EBCD7168 = 0x800000000;
  qword_1EBCD72F0 = (uint64_t)&unk_1F26151C0;
  qword_1EBCD7308 = (uint64_t)&qword_1EBCD72F0;
  sub_1CD58B264(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD70B8);
}

void sub_1CD58B264(int **a1, _WORD *a2, long long *a3, uint64_t *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD70B8, "use-cfl-aa-in-codegen", 0x15uLL);
  uint64_t v8 = *a1;
  dword_1EBCD7138 = **a1;
  byte_1EBCD714C = 1;
  dword_1EBCD7148 = *v8;
  word_1EBCD70C2 = (32 * (*a2 & 3)) | word_1EBCD70C2 & 0xFF9F;
  xmmword_1EBCD70D8 = *a3;

  sub_1CC4B024C(a4, (uint64_t)&qword_1EBCD70B8);
}

void sub_1CD58B314()
{
}

void *sub_1CD58B328()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F26151C0;
  return result;
}

void sub_1CD58B360(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26151C0;
}

void sub_1CD58B38C()
{
}

llvm::cl::Option *sub_1CD58B470(llvm::cl::Option *a1, uint64_t a2, _OWORD *a3, _OWORD *a4, const char **a5, _WORD *a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(void *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = 0;
  *(unsigned char *)(v12 + 184) = 0;
  *(void *)(v12 + 168) = 0;
  *(void *)(v12 + 176) = 0;
  *(void *)(v12 + 160) = 0;
  *(void *)(v12 + 144) = 0;
  *(void *)(v12 + 152) = &unk_1F2643C20;
  *(void *)uint64_t v12 = &unk_1F2643FD0;
  *(void *)(v12 + 192) = &unk_1F2643EA0;
  *(void *)(v12 + 200) = &unk_1F25F6428;
  *(void *)(v12 + 224) = v12 + 200;
  sub_1CD58B574(v12, *(unsigned __int8 **)a2, *(void *)(a2 + 8), a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

void sub_1CD58B574(uint64_t a1, unsigned __int8 *a2, size_t a3, _OWORD *a4, _OWORD *a5, const char **a6, _WORD *a7)
{
  *(_OWORD *)(a1 + 32) = *a4;
  *(_OWORD *)(a1 + 48) = *a5;
  sub_1CBAD7D28(a6, a1);
  *(_WORD *)(a1 + 10) = (32 * (*a7 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
}

void *sub_1CD58B5EC(uint64_t a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CC4B06FC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD58B658(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
    *((unsigned char *)v5 + 16) = 0;
  }
  return v5;
}

void *sub_1CD58B658(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC4B0794(a1, v6);
  uint64_t v8 = 0;
  sub_1CC4B06FC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

uint64_t sub_1CD58B710(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unint64_t v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *unint64_t v7 = -4096;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      __n128 result = sub_1CC4B06FC(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      char v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

void sub_1CD58B7C4(_WORD *a1, uint64_t **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD7310, 0, 0);
  xmmword_1EBCD7390 = 0u;
  *(_OWORD *)&qword_1EBCD73A0 = 0u;
  *((void *)&xmmword_1EBCD7390 + 1) = &unk_1F26150F0;
  qword_1EBCD7310 = (uint64_t)&unk_1F2614FB0;
  qword_1EBCD73C0 = (uint64_t)&qword_1EBCD7310;
  unk_1EBCD73C8 = &unk_1EBCD73D8;
  qword_1EBCD73D0 = 0x800000000;
  qword_1EBCD73B0 = (uint64_t)&unk_1F2615018;
  qword_1EBCD73B8 = (uint64_t)&unk_1F2615050;
  qword_1EBCD7598 = (uint64_t)&unk_1F2615208;
  qword_1EBCD75B0 = (uint64_t)&qword_1EBCD7598;
  sub_1CD58B8F0(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD7310);

  sub_1CD58B9F4();
}

__n128 sub_1CD58B8F0(_WORD *a1, uint64_t **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD7310, "regalloc", 8uLL);
  word_1EBCD731A = (32 * (*a1 & 3)) | word_1EBCD731A & 0xFF9F;
  uint64_t v6 = *a2;
  *(void *)&xmmword_1EBCD7390 = **a2;
  byte_1EBCD73A8 = 1;
  qword_1EBCD73A0 = *v6;
  __n128 result = *a3;
  xmmword_1EBCD7330 = (__int128)*a3;
  return result;
}

void sub_1CD58B97C()
{
}

void *sub_1CD58B990()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2615208;
  return result;
}

void sub_1CD58B9C8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2615208;
}

void sub_1CD58B9F4()
{
  uint64_t v0 = (unsigned __int8 *)llvm::RegisterRegAllocBase<llvm::RegisterRegAlloc>::Registry;
  if (llvm::RegisterRegAllocBase<llvm::RegisterRegAlloc>::Registry)
  {
    do
    {
      sub_1CD589674((uint64_t)&qword_1EBCD73B8, *((unsigned __int8 **)v0 + 1), *((void *)v0 + 2), *((void *)v0 + 5), *((void *)v0 + 3), *((void *)v0 + 4));
      uint64_t v0 = *(unsigned __int8 **)v0;
    }
    while (v0);
  }
  qword_1EBCBE7B0 = (uint64_t)&qword_1EBCD73B0;
}

void sub_1CD58BA5C()
{
}

uint64_t sub_1CD58BA70()
{
  return 0;
}

uint64_t llvm::TargetRegisterInfo::TargetRegisterInfo(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(void *)(result + 168) = 0;
  *(void *)(result + 176) = 0;
  *(_DWORD *)(result + 184) = 0;
  *(void *)(result + 192) = 0;
  *(void *)(result + 200) = 0;
  *(_DWORD *)(result + 208) = 0;
  *(void *)__n128 result = &unk_1F2615278;
  *(void *)(result + 216) = a2;
  *(void *)(result + 224) = a5;
  *(void *)(result + 232) = a6;
  *(void *)(result + 240) = a3;
  *(void *)(result + 248) = a4;
  *(void *)(result + 256) = a7;
  *(void *)(result + 264) = a8;
  *(_DWORD *)(result + 272) = a9;
  return result;
}

void llvm::TargetRegisterInfo::~TargetRegisterInfo(llvm::TargetRegisterInfo *this)
{
}

uint64_t sub_1CD58BAE0()
{
  return v0;
}

BOOL llvm::TargetRegisterInfo::shouldRegionSplitForVirtReg(llvm::TargetRegisterInfo *this, const llvm::MachineFunction *a2, const llvm::LiveInterval *a3)
{
  uint64_t v5 = (llvm::TargetInstrInfo *)(*(uint64_t (**)(void))(**((void **)a2 + 2) + 104))(*((void *)a2 + 2));
  Uniqueuint64_t VRegDef = (const llvm::MachineInstr *)llvm::MachineRegisterInfo::getUniqueVRegDef(*((void *)a2 + 5), *((_DWORD *)a3 + 28));
  return !UniqueVRegDef
      || !sub_1CC4B18C4(v5, UniqueVRegDef)
      || *((_DWORD *)a3 + 2) <= dword_1EBCD7638;
}

_DWORD *llvm::printReg@<X0>(int a1@<W0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  __n128 result = operator new(0x28uLL);
  *(void *)__n128 result = &unk_1F26154E0;
  result[2] = a1;
  *((void *)result + 2) = a2;
  result[6] = a3;
  *((void *)result + 4) = a4;
  *(void *)(a5 + 24) = result;
  return result;
}

uint64_t llvm::printRegUnit@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[2] = a2;
  a3[3] = a3;
  *a3 = &unk_1F2615528;
  a3[1] = this;
  return this;
}

uint64_t llvm::printVRegOrUnit@<X0>(uint64_t this@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[2] = a2;
  a3[3] = a3;
  *a3 = &unk_1F2615570;
  a3[1] = this;
  return this;
}

_DWORD *llvm::printRegClassOrBank@<X0>(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __n128 result = operator new(0x20uLL);
  *(void *)__n128 result = &unk_1F26155B8;
  result[2] = a1;
  *((void *)result + 2) = a2;
  *((void *)result + 3) = a3;
  *(void *)(a4 + 24) = result;
  return result;
}

uint64_t llvm::TargetRegisterInfo::getMinimalPhysRegClassLLT(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 240);
  char v4 = *(uint64_t **)(a1 + 248);
  if (v3 != v4)
  {
    uint64_t result = 0;
    unint64_t v7 = a3 & 0xFFFFFFFFFFFFFFF9;
    unsigned int v8 = a2 - 1;
    uint64_t v9 = a2 >> 3;
    int v10 = 1 << (a2 & 7);
    unint64_t v11 = (unint64_t)a2 >> 3;
    while (1)
    {
      uint64_t v12 = *v3;
      if (v7) {
        break;
      }
      if (v8 <= 0x3FFFFFFE) {
        goto LABEL_5;
      }
LABEL_11:
      if (++v3 == v4) {
        return result;
      }
    }
    uint64_t v17 = result;
    BOOL v14 = sub_1CD58BDD8(a1, v12, a3) == 0;
    uint64_t result = v17;
    if (v14 || v8 >= 0x3FFFFFFF) {
      goto LABEL_11;
    }
LABEL_5:
    uint64_t v13 = *(void *)v12;
    if (v11 < *(unsigned __int16 *)(*(void *)v12 + 22)
      && (v10 & *(unsigned char *)(*(void *)(v13 + 8) + v9)) != 0
      && (!result
       || v12 != result
       && ((*(_DWORD *)(*(void *)(result + 8) + ((*(unsigned __int16 *)(v13 + 24) >> 3) & 0x1FFCLL)) >> *(_WORD *)(v13 + 24)) & 1) != 0))
    {
      uint64_t result = v12;
    }
    goto LABEL_11;
  }
  return 0;
}

uint64_t sub_1CD58BDD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v4 = *(unsigned __int8 **)(*(void *)(a1 + 264)
                           + 24
                           * (*(unsigned __int16 *)(*(void *)a2 + 24)
                            + *(_DWORD *)(a1 + 272)
                            * ((*(void *)(a1 + 248) - *(void *)(a1 + 240)) >> 3))
                           + 16);
  while (1)
  {
    int v5 = *v4;
    if (v5 == 1) {
      break;
    }
    if (v5 != 174)
    {
      llvm::LLT::LLT(&v7, v5);
      ++v4;
      if (v7 != a3) {
        continue;
      }
    }
    return 1;
  }
  return 0;
}

unsigned __int16 *llvm::TargetRegisterInfo::getAllocatableSet@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  int v8 = *(_DWORD *)(a1 + 16);
  *(void *)a4 = a4 + 16;
  *(void *)(a4 + sub_1CD521E44((uint64_t)this + 8) = 0x600000000;
  uint64_t result = (unsigned __int16 *)sub_1CB90D610(a4, (v8 + 63) >> 6, 0);
  *(_DWORD *)(a4 + 64) = v8;
  if (a3)
  {
    uint64_t result = (unsigned __int16 *)llvm::TargetRegisterInfo::getAllocatableClass(a1, a3);
    if (result)
    {
      int v10 = (uint64_t (*)(uint64_t))*((void *)result + 6);
      if (v10)
      {
        uint64_t result = (unsigned __int16 *)v10(a2);
      }
      else
      {
        int v29 = *(unsigned __int16 ***)result;
        uint64_t result = **(unsigned __int16 ***)result;
        uint64_t v11 = *((unsigned __int16 *)v29 + 10);
      }
      if (v11)
      {
        uint64_t v12 = *(void **)a4;
        uint64_t v13 = 2 * v11;
        do
        {
          unsigned int v14 = *result++;
          *(void *)((char *)v12 + (((unint64_t)v14 >> 3) & 0x1FF8)) |= 1 << v14;
          v13 -= 2;
        }
        while (v13);
      }
    }
  }
  else
  {
    uint64_t v15 = *(unsigned __int16 *****)(a1 + 240);
    for (uint64_t i = *(unsigned __int16 *****)(a1 + 248); v15 != i; ++v15)
    {
      uint64_t v17 = **v15;
      if (*((unsigned char *)v17 + 31))
      {
        std::string v18 = (*v15)[6];
        if (v18)
        {
          uint64_t result = (unsigned __int16 *)((uint64_t (*)(uint64_t))v18)(a2);
        }
        else
        {
          uint64_t result = *v17;
          uint64_t v19 = *((unsigned __int16 *)v17 + 10);
        }
        if (v19)
        {
          __int16 v20 = *(void **)a4;
          uint64_t v21 = 2 * v19;
          do
          {
            unsigned int v22 = *result++;
            *(void *)((char *)v20 + (((unint64_t)v22 >> 3) & 0x1FF8)) |= 1 << v22;
            v21 -= 2;
          }
          while (v21);
        }
      }
    }
  }
  uint64_t v23 = *(void *)(a2 + 40);
  LODWORD(v24) = *(_DWORD *)(a4 + 8);
  unsigned int v25 = *(_DWORD *)(v23 + 360);
  if (v25 >= v24) {
    uint64_t v24 = v24;
  }
  else {
    uint64_t v24 = v25;
  }
  if (v24)
  {
    unint64_t v26 = *(uint64_t **)(v23 + 352);
    __int16 v27 = *(void **)a4;
    do
    {
      uint64_t v28 = *v26++;
      *v27++ &= ~v28;
      --v24;
    }
    while (v24);
  }
  return result;
}

BOOL llvm::TargetRegisterInfo::shouldRewriteCopySrc(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  if (a2 == a4) {
    return 1;
  }
  uint64_t v15 = v5;
  uint64_t v16 = v6;
  uint64_t v8 = a2;
  if (a3 && a5)
  {
    uint64_t CommonSuperRegClass = (uint64_t)llvm::TargetRegisterInfo::getCommonSuperRegClass(a1, a4, a5, a2, a3, &v14, &v13);
  }
  else
  {
    if (a5) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = a4;
    }
    if (a5)
    {
      uint64_t v8 = a4;
      unsigned int v12 = a5;
    }
    else
    {
      unsigned int v12 = a3;
    }
    if (v12) {
      uint64_t CommonSuperRegClass = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 184))(a1, v8, v11);
    }
    else {
      uint64_t CommonSuperRegClass = llvm::TargetRegisterInfo::getCommonSubClass(a1, v11, v8);
    }
  }
  return CommonSuperRegClass != 0;
}

uint64_t llvm::TargetRegisterInfo::isCalleeSavedPhysReg(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 40))(a1, a3, (*(unsigned __int16 *)(*(void *)a3 + 18) >> 4) & 0x3FF);
  if (result) {
    return (*(_DWORD *)(result + 4 * (a2 >> 5)) >> a2) & 1;
  }
  return result;
}

uint64_t llvm::TargetRegisterInfo::lookThruSingleUseCopyChain(uint64_t a1, unsigned int a2, uint64_t a3)
{
  while (1)
  {
    uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(a3, a2);
    int v6 = **(unsigned __int16 **)(VRegDef + 16);
    if (v6 != 11) {
      break;
    }
    uint64_t v7 = 2;
LABEL_5:
    uint64_t v8 = *(void *)(VRegDef + 32) + 32 * v7;
    a2 = *(_DWORD *)(v8 + 4);
    if ((a2 & 0x80000000) == 0 || !llvm::MachineRegisterInfo::hasOneNonDBGUse(a3, *(_DWORD *)(v8 + 4))) {
      return 0;
    }
  }
  if (v6 == 19)
  {
    uint64_t v7 = 1;
    goto LABEL_5;
  }
  if (llvm::MachineRegisterInfo::hasOneNonDBGUse(a3, a2)) {
    return a2;
  }
  else {
    return 0;
  }
}

uint64_t llvm::TargetRegisterInfo::getOffsetOpcodes(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return llvm::DIExpression::appendOffset(a3, *a2);
}

llvm::MDNode *llvm::TargetRegisterInfo::prependOffsetExpression(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  v10[16] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = v10;
  uint64_t v9 = 0x1000000000;
  if (a3)
  {
    v10[0] = 6;
    LODWORD(v9) = 1;
  }
  (*(void (**)(uint64_t, uint64_t, void **))(*(void *)a1 + 488))(a1, a4, &v8);
  if ((a3 & 2) != 0)
  {
    if (v9 >= HIDWORD(v9)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v8 + v9) = 6;
    LODWORD(v9) = v9 + 1;
  }
  int v6 = llvm::DIExpression::prependOpcodes(a2, (unsigned int *)&v8, (a3 & 4) != 0, (a3 >> 3) & 1);
  if (v8 != v10) {
    free(v8);
  }
  return v6;
}

uint64_t llvm::TargetRegisterInfo::dumpReg(llvm *a1, int a2, uint64_t a3)
{
  int v5 = (int)a1;
  int v6 = llvm::dbgs(a1);
  uint64_t v7 = operator new(0x28uLL);
  *(void *)uint64_t v7 = &unk_1F26154E0;
  v7[2] = v5;
  *((void *)v7 + 2) = a3;
  v7[6] = a2;
  *((void *)v7 + 4) = 0;
  sub_1CC4B2FB0((llvm::raw_ostream *)v7, v6);
  sub_1CB8E509C(v6, "\n");
  uint64_t v8 = *(uint64_t (**)(_DWORD *))(*(void *)v7 + 40);

  return v8(v7);
}

uint64_t sub_1CD58C3B0()
{
  return 0;
}

uint64_t sub_1CD58C3B8()
{
  return 0;
}

uint64_t sub_1CD58C3C0(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t llvm::TargetSchedModel::mustEndGroup(llvm::TargetSchedModel *a1, const llvm::MachineInstr *a2, uint64_t a3)
{
  if (!byte_1EBD06248 || !*((void *)a1 + 5)) {
    return 0;
  }
  if (!a3) {
    a3 = llvm::TargetSchedModel::resolveSchedClass(a1, a2);
  }
  unsigned int v3 = *(unsigned __int16 *)(a3 + 8);
  BOOL v4 = (~v3 & 0x1FFF) == 0;
  unsigned int v5 = (v3 >> 14) & 1;
  if (v4) {
    return 0;
  }
  else {
    return v5;
  }
}

uint64_t llvm::TargetSchedModel::findUseIdx(uint64_t this, const llvm::MachineInstr *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = this;
  LODWORD(this) = 0;
  unsigned int v3 = *(int **)(v2 + 32);
  uint64_t v4 = a2;
  do
  {
    int v6 = *v3;
    v3 += 8;
    char v5 = v6;
    int v7 = v6 & 0x10FFF00;
    if ((v6 & 0x310000FF) == 0 && v7 != 0x1000000 || v5 == 7) {
      this = (this + 1);
    }
    else {
      this = this;
    }
    --v4;
  }
  while (v4);
  return this;
}

uint64_t llvm::TargetSubtargetInfo::enableAtomicExpand(llvm::TargetSubtargetInfo *this)
{
  return 1;
}

uint64_t llvm::TargetSubtargetInfo::enableIndirectBrExpand(llvm::TargetSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::TargetSubtargetInfo::enableMachineScheduler(llvm::TargetSubtargetInfo *this)
{
  return 0;
}

uint64_t llvm::TargetSubtargetInfo::enableRALocalReassignment()
{
  return 1;
}

uint64_t llvm::TargetSubtargetInfo::enablePostRAMachineScheduler(llvm::TargetSubtargetInfo *this)
{
  uint64_t result = (*(uint64_t (**)(llvm::TargetSubtargetInfo *))(*(void *)this + 232))(this);
  if (result)
  {
    unsigned int v3 = *(uint64_t (**)(llvm::TargetSubtargetInfo *))(*(void *)this + 264);
    return v3(this);
  }
  return result;
}

uint64_t sub_1CD58C5CC()
{
  return 0;
}

uint64_t sub_1CD58C5D4()
{
  return 0;
}

void llvm::initializeTypePromotionPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7738, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4B4C08;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD7738, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD58C650(uint64_t a1)
{
  uint64_t v2 = (void *)(*(void *)(a1 + 32) - 8);
  uint64_t v4 = 0;
  uint64_t result = sub_1CBF5FB7C((uint64_t *)a1, v2, &v4);
  if (result)
  {
    *uint64_t v4 = -8192;
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  *(void *)(a1 + 32) -= 8;
  return result;
}

void *sub_1CD58C6BC(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  char v5 = v7;
  if ((v4 & 1) == 0)
  {
    char v5 = sub_1CD58C738(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
  }
  return v5;
}

void *sub_1CD58C738(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD58C7EC(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD58C7EC(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD58C8C4(a1, v4, v4 + 56 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      void *result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

void sub_1CD58C8C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *unsigned int v13 = *(void *)v4;
        void v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CC00811C(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        unsigned int v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

void llvm::initializeTwoAddressInstructionPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7740, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4B9514;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD7740, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

_DWORD *sub_1CD58CA30(void *a1, unsigned int a2)
{
  if (a2 <= 4)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v3 = a2;
    uint64_t result = operator new(56 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    int v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      uint64_t v6 = &result[14 * v3];
      goto LABEL_6;
    }
  }
  uint64_t result = a1 + 1;
  uint64_t v6 = a1 + 29;
  do
  {
LABEL_6:
    _DWORD *result = -1;
    result += 14;
  }
  while (result != v6);
  return result;
}

void sub_1CD58CABC(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v2 > 4)
    {
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(56 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD58CCB8(a1, v7, v7 + 56 * v8);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  uint64_t v10 = v14;
  do
  {
    uint64_t v11 = a1 + v9;
    unsigned int v12 = *(_DWORD *)(a1 + v9 + 8);
    if (v12 <= 0xFFFFFFFD)
    {
      *(_DWORD *)uint64_t v10 = v12;
      *((void *)v10 + 1) = v10 + 24;
      unsigned int v13 = (void **)(v11 + 16);
      *((void *)v10 + 2) = 0x400000000;
      if (*(_DWORD *)(v11 + 24)) {
        sub_1CD58CDC4((uint64_t)(v10 + 8), (uint64_t)v13);
      }
      v10 += 56;
      if ((void *)(a1 + v9 + 32) != *v13) {
        free(*v13);
      }
    }
    v9 += 56;
  }
  while (v9 != 224);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(56 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  sub_1CD58CCB8(a1, (uint64_t)v14, (uint64_t)v10);
}

void sub_1CD58CCB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    unsigned int v8 = (_DWORD *)(a1 + 8);
    uint64_t v9 = (_DWORD *)(a1 + 232);
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    unsigned int v8 = *(_DWORD **)(a1 + 8);
    uint64_t v9 = &v8[14 * v7];
  }
  do
  {
    *unsigned int v8 = -1;
    v8 += 14;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      int v10 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        unsigned int v14 = 0;
        sub_1CC4C0558(a1, v10, &v14);
        uint64_t v11 = v14;
        *unsigned int v14 = *(_DWORD *)v4;
        *((void *)v11 + 2) = 0x400000000;
        *((void *)v11 + 1) = v11 + 6;
        uint64_t v12 = (uint64_t)(v11 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD58CDC4(v12, v4 + 8);
        }
        *(_DWORD *)a1 += 2;
        unsigned int v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13) {
          free(v13);
        }
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD58CDC4(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = a2 + 16;
    uint64_t v4 = *(_DWORD **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9)
        {
          uint64_t v11 = &v4[2 * v9];
          uint64_t v12 = *(_DWORD **)a1;
          do
          {
            *uint64_t v12 = *v4;
            v12[1] = v4[1];
            v4 += 2;
            v12 += 2;
          }
          while (v4 != v11);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          unsigned int v13 = &v4[2 * v10];
          unsigned int v14 = *(_DWORD **)a1;
          do
          {
            *unsigned int v14 = *v4;
            v14[1] = v4[1];
            v4 += 2;
            v14 += 2;
          }
          while (v4 != v13);
        }
        else
        {
          uint64_t v10 = 0;
        }
        if (v10 != v9) {
          memcpy((void *)(*(void *)a1 + 8 * v10), (const void *)(*(void *)a2 + 8 * v10), *(void *)a2 + 8 * v9 - (*(void *)a2 + 8 * v10));
        }
      }
      *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v9;
    }
    else
    {
      int v6 = *(_DWORD **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(_DWORD **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *int v7 = 0;
  }
  return a1;
}

void sub_1CD58CF18(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)a1;
  sub_1CC4C0A08(a1);
  unsigned int v3 = __clz((v2 >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((*(_DWORD *)a1 & 1) != 0 && v5 < 5)
  {
    int v6 = (_DWORD *)(a1 + 8);
    *(void *)a1 = 1;
    int v7 = (_DWORD *)(a1 + 232);
    do
    {
LABEL_10:
      *int v6 = -1;
      v6 += 14;
    }
    while (v6 != v7);
    return;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    if (v5 == *(_DWORD *)(a1 + 16))
    {
      *(void *)a1 = 0;
      if (!v5) {
        return;
      }
      int v6 = *(_DWORD **)(a1 + 8);
      int v7 = &v6[14 * v5];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }

  sub_1CD58CA30((void *)a1, v5);
}

void sub_1CD58CFFC(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD7808, 0, 0);
  dword_1EBCD7888 = 0;
  qword_1EBCD7890 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD7898 = 0;
  qword_1EBCD7808 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD78A0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD78A8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD78C0 = (uint64_t)&qword_1EBCD78A8;
  llvm::cl::Option::setArgStr(v6, "dataflow-edge-limit", 0x13uLL);
  word_1EBCD7812 = (32 * (*a1 & 3)) | word_1EBCD7812 & 0xFF9F;
  dword_1EBCD7888 = **a2;
  byte_1EBCD789C = 1;
  dword_1EBCD7898 = dword_1EBCD7888;
  xmmword_1EBCD7828 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD7808);
}

void llvm::initializeUnreachableBlockElimLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD78D8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4C0B68;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD78D8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createUnreachableBlockEliminationPass(llvm *this)
{
}

void llvm::initializeUnreachableMachineBlockElimPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD78C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4C0D6C;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD78C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::EVT::changeExtendedTypeToInteger(llvm::EVT *this)
{
  uint64_t v1 = (llvm::IntegerType *)**((void **)this + 1);
  if (*(unsigned char *)this) {
    Extendedint SizeInBits = sub_1CB87E200((unsigned __int8 *)this);
  }
  else {
    Extendedint SizeInBits = (uint64_t)llvm::EVT::getExtendedSizeInBits(this);
  }
  int v4 = (llvm::LLVMContext *)ExtendedSizeInBits;
  if (v3 == 1)
  {
    uint64_t v6 = (llvm::LLVMContext *)ExtendedSizeInBits;
    int v4 = v6;
  }

  return sub_1CB8E40FC(v1, v4);
}

unint64_t llvm::EVT::changeExtendedVectorElementTypeToInteger(llvm::EVT *this, uint64_t a2, BOOL a3)
{
  int v4 = (llvm::IntegerType *)**((void **)this + 1);
  unsigned int v5 = sub_1CD3E12F4((unsigned __int8 *)this, a2, a3);
  uint64_t v6 = sub_1CB8E40FC(v4, v5);
  uint64_t v8 = v7;
  uint64_t v9 = (llvm::Type *)sub_1CC4A0738(this);

  return sub_1CB882C1C(v4, v6, v8, v9);
}

unint64_t llvm::EVT::changeExtendedVectorElementType(llvm::EVT *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = (llvm::LLVMContext *)**((void **)a1 + 1);
  uint64_t v6 = (llvm::Type *)sub_1CC4A0738(a1);

  return sub_1CB882C1C(v5, a2, a3, v6);
}

uint64_t llvm::EVT::getExtendedVectorVT(llvm::LLVMContext *a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  v10[0] = a2;
  v10[1] = a3;
  llvm::EVT::getTypeForEVT((llvm::EVT *)v10, a1);
  uint64_t v8 = 0x100000000;
  if (!a5) {
    uint64_t v8 = 0;
  }
  llvm::VectorType::get(v7, (llvm::Type *)(v8 | a4));
  return 0;
}

uint64_t llvm::EVT::getExtendedVectorVT(llvm::LLVMContext *a1, uint64_t a2, uint64_t a3, llvm::Type *a4)
{
  v7[0] = a2;
  v7[1] = a3;
  llvm::EVT::getTypeForEVT((llvm::EVT *)v7, a1);
  llvm::VectorType::get(v5, a4);
  return 0;
}

BOOL llvm::EVT::isExtendedFloatingPoint(llvm::EVT *this)
{
  uint64_t v1 = *((void *)this + 1);
  if ((*(_DWORD *)(v1 + 8) & 0xFE) == 0x12) {
    unsigned int v2 = *(unsigned __int8 *)(**(void **)(v1 + 16) + 8);
  }
  else {
    unsigned int v2 = *(_DWORD *)(v1 + 8);
  }
  return v2 < 7;
}

BOOL llvm::EVT::isExtendedScalarInteger(llvm::EVT *this)
{
  return *(unsigned char *)(*((void *)this + 1) + 8) == 13;
}

BOOL llvm::EVT::isExtendedFixedLengthVector(llvm::EVT *this)
{
  return *(unsigned char *)(*((void *)this + 1) + 8) == 18;
}

unint64_t llvm::EVT::getExtendedVectorElementType(llvm::EVT *this, uint64_t a2, BOOL a3)
{
  return llvm::EVT::getEVT(*(llvm::EVT **)(*((void *)this + 1) + 24), 0, a3);
}

uint64_t llvm::EVT::getExtendedVectorNumElements(llvm::EVT *this)
{
  uint64_t v1 = *((void *)this + 1);
  uint64_t v2 = *(unsigned int *)(v1 + 32);
  if (*(unsigned char *)(v1 + 8) == 19)
  {
    unsigned int v3 = llvm::WithColor::warning(this);
    sub_1CB8E509C(v3, "The code that requested the fixed number of elements has made the assumption that this vector is not scalable. This assumption was not correct, and this may lead to broken code\n");
  }
  return v2;
}

unint64_t llvm::EVT::getExtendedVectorElementCount(llvm::EVT *this)
{
  return *(unsigned int *)(*((void *)this + 1) + 32) | ((unint64_t)(*(unsigned char *)(*((void *)this + 1) + 8) == 19) << 32);
}

void llvm::EVT::getEVTString(llvm::EVT *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(unsigned __int8 *)this;
  if (v4 <= 0xD)
  {
    if (*(unsigned char *)this)
    {
      if (v4 == 1)
      {
        *(unsigned char *)(a2 + 23) = 2;
        strcpy((char *)a2, "ch");
        return;
      }
      if (v4 == 8)
      {
        *(unsigned char *)(a2 + 23) = 4;
        int v6 = 909207138;
LABEL_8:
        *(_DWORD *)a2 = v6;
        *(unsigned char *)(a2 + 4) = 0;
        return;
      }
LABEL_23:
      if (v4 - 15 >= 0x9C)
      {
        if (*(unsigned char *)this)
        {
          if (v4 - 2 <= 5)
          {
            uint64_t v14 = sub_1CB87E200((unsigned __int8 *)this);
LABEL_41:
            unint64_t v18 = v14;
            if (v15 == 1) {
            if (v18)
            }
            {
              uint64_t v19 = &v41.__r_.__value_.__s.__data_[21];
              do
              {
                *--uint64_t v19 = (v18 % 0xA) | 0x30;
                BOOL v13 = v18 > 9;
                v18 /= 0xAuLL;
              }
              while (v13);
            }
            else
            {
              uint64_t v19 = &v41.__r_.__value_.__s.__data_[20];
              v41.__r_.__value_.__s.__data_[20] = 48;
            }
            sub_1CC028D80(&v36, v19, &v41.__r_.__value_.__s.__data_[21], (char *)&v41.__r_.__value_.__r.__words[2] + 5 - v19);
            __int16 v20 = "i";
LABEL_51:
            uint64_t v21 = std::string::insert(&v36, 0, v20);
            *(std::string *)a2 = *v21;
            v21->__r_.__value_.__r.__words[0] = 0;
            v21->__r_.__value_.__l.__size_ = 0;
            v21->__r_.__value_.__r.__words[2] = 0;
            if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              return;
            }
            unsigned int v22 = (void *)v36.__r_.__value_.__r.__words[0];
            goto LABEL_53;
          }
          Extendedint SizeInBits = sub_1CB87E200((unsigned __int8 *)this);
LABEL_16:
          unint64_t v11 = ExtendedSizeInBits;
          if (v10 == 1) {
          if (v11)
          }
          {
            uint64_t v12 = &v41.__r_.__value_.__s.__data_[21];
            do
            {
              *--uint64_t v12 = (v11 % 0xA) | 0x30;
              BOOL v13 = v11 > 9;
              v11 /= 0xAuLL;
            }
            while (v13);
          }
          else
          {
            uint64_t v12 = &v41.__r_.__value_.__s.__data_[20];
            v41.__r_.__value_.__s.__data_[20] = 48;
          }
          sub_1CC028D80(&v36, v12, &v41.__r_.__value_.__s.__data_[21], (char *)&v41.__r_.__value_.__r.__words[2] + 5 - v12);
          __int16 v20 = "f";
          goto LABEL_51;
        }
        uint64_t v7 = *((void *)this + 1);
        int v8 = *(unsigned __int8 *)(v7 + 8);
LABEL_13:
        if ((v8 & 0xFE) == 0x12)
        {
          if (*(unsigned char *)(**(void **)(v7 + 16) + 8) != 13)
          {
LABEL_15:
            Extendedint SizeInBits = (uint64_t)llvm::EVT::getExtendedSizeInBits(this);
            goto LABEL_16;
          }
        }
        else if (v8 != 13)
        {
          goto LABEL_15;
        }
        uint64_t v14 = (uint64_t)llvm::EVT::getExtendedSizeInBits(this);
        goto LABEL_41;
      }
      BOOL v23 = v4 - 120 < 0x33;
    }
    else
    {
      uint64_t v7 = *((void *)this + 1);
      int v8 = *(_DWORD *)(v7 + 8);
      if ((*(_DWORD *)(v7 + 8) & 0xFE) != 0x12) {
        goto LABEL_13;
      }
      BOOL v23 = v8 == 19;
    }
    if (v23) {
      uint64_t v24 = "nxv";
    }
    else {
      uint64_t v24 = "v";
    }
    unint64_t v25 = sub_1CC4A0738(this);
    if (v25)
    {
      unint64_t v26 = v39;
      do
      {
        *--unint64_t v26 = (v25 % 0xA) | 0x30;
        BOOL v13 = v25 > 9;
        v25 /= 0xAuLL;
      }
      while (v13);
    }
    else
    {
      unint64_t v26 = &v38;
      char v38 = 48;
    }
    sub_1CC028D80(&v41, v26, v39, v39 - v26);
    __int16 v27 = std::string::insert(&v41, 0, v24);
    std::string::size_type v28 = v27->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v36.__r_.__value_.__l.__data_ = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
    v36.__r_.__value_.__r.__words[2] = v28;
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    v35[0] = sub_1CD58DA2C((uint64_t)this, v29, v30);
    v35[1] = v31;
    llvm::EVT::getEVTString((uint64_t *)__p, (llvm::EVT *)v35);
    if (v40 >= 0) {
      int v32 = __p;
    }
    else {
      int v32 = (void **)__p[0];
    }
    if (v40 >= 0) {
      std::string::size_type v33 = v40 & 0x7F;
    }
    else {
      std::string::size_type v33 = (std::string::size_type)__p[1];
    }
    __int16 v34 = std::string::append(&v36, (const std::string::value_type *)v32, v33);
    *(std::string *)a2 = *v34;
    v34->__r_.__value_.__r.__words[0] = 0;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    if (v40 < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    if ((SHIBYTE(v41.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    unsigned int v22 = (void *)v41.__r_.__value_.__r.__words[0];
LABEL_53:
    operator delete(v22);
    return;
  }
  switch(*(unsigned char *)this)
  {
    case 0xAB:
      *(unsigned char *)(a2 + 23) = 6;
      int v5 = 1832269944;
      goto LABEL_36;
    case 0xAC:
      *(unsigned char *)(a2 + 23) = 4;
      int v6 = 1702194279;
      goto LABEL_8;
    case 0xAD:
      *(unsigned char *)(a2 + 23) = 6;
      *(_DWORD *)a2 = 1867936617;
      __int16 v17 = 25705;
      goto LABEL_37;
    case 0xAE:
      *(unsigned char *)(a2 + 23) = 7;
      *(_DWORD *)a2 = 2037673557;
      int v16 = 1684369529;
      goto LABEL_33;
    case 0xAF:
      *(unsigned char *)(a2 + 23) = 7;
      *(_DWORD *)a2 = 1668183398;
      int v16 = 1717924451;
      goto LABEL_33;
    case 0xB0:
      *(unsigned char *)(a2 + 23) = 9;
      strcpy((char *)a2, "externref");
      return;
    case 0xB1:
      *(unsigned char *)(a2 + 23) = 6;
      int v5 = 1630943352;
LABEL_36:
      *(_DWORD *)a2 = v5;
      __int16 v17 = 30829;
LABEL_37:
      *(_WORD *)(a2 + 4) = v17;
      *(unsigned char *)(a2 + 6) = 0;
      return;
    case 0xB2:
      *(unsigned char *)(a2 + 23) = 5;
      strcpy((char *)a2, "i64x8");
      return;
    default:
      if (v4 == 14)
      {
        *(unsigned char *)(a2 + 23) = 7;
        *(_DWORD *)a2 = 1717792880;
        int v16 = 942813542;
LABEL_33:
        *(_DWORD *)(a2 + 3) = v16;
        *(unsigned char *)(a2 + 7) = 0;
      }
      else
      {
        if (v4 != 249) {
          goto LABEL_23;
        }
        *(unsigned char *)(a2 + 23) = 8;
        strcpy((char *)a2, "Metadata");
      }
      break;
  }
}

unint64_t sub_1CD58DA2C(uint64_t a1, uint64_t a2, BOOL a3)
{
  if (*(unsigned char *)a1)
  {
    LOBYTE(EVT) = sub_1CB8C2FBC((unsigned __int8 *)a1);
    unint64_t v4 = 0;
  }
  else
  {
    unint64_t EVT = llvm::EVT::getEVT(*(llvm::EVT **)(*(void *)(a1 + 8) + 24), 0, a3);
    unint64_t v4 = EVT & 0xFFFFFFFFFFFFFF00;
  }
  return v4 | EVT;
}

void llvm::initializeVirtRegMapPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7CA0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4C5AB4;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD7CA0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::raw_ostream *llvm::VirtRegMap::print(llvm::VirtRegMap *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = sub_1CB8E509C(a2, "********** REGISTER MAP **********\n");
  int v6 = *(_DWORD *)(*((void *)this + 31) + 32);
  if (v6)
  {
    for (int i = 0; i != v6; ++i)
    {
      uint64_t v8 = i & 0x7FFFFFFF;
      if (*(_DWORD *)(*((void *)this + 35) + 4 * v8))
      {
        uint64_t v9 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v9 >= *((void *)a2 + 3))
        {
          uint64_t v10 = llvm::raw_ostream::write(a2, 91);
        }
        else
        {
          *((void *)a2 + 4) = v9 + 1;
          *uint64_t v9 = 91;
          uint64_t v10 = a2;
        }
        llvm::printReg(i | 0x80000000, *((void *)this + 33), 0, 0, (uint64_t)v26);
        if (!v27
          || ((*(void (**)(llvm::raw_ostream *, llvm::raw_ostream *))(*(void *)v27 + 48))(v27, v10),
              unint64_t v11 = sub_1CB8E509C(v10, " -> "),
              llvm::printReg(*(_DWORD *)(*((void *)this + 35) + 4 * v8), *((void *)this + 33), 0, 0, (uint64_t)v24),
              !v25))
        {
LABEL_36:
          sub_1CB920400();
        }
        (*(void (**)(void *, llvm::raw_ostream *))(*v25 + 48))(v25, v11);
        uint64_t v12 = sub_1CB8E509C(v11, "] ");
        BOOL v13 = sub_1CB8E509C(v12, (char *)(*(void *)(*((void *)this + 33) + 80)+ *(unsigned int *)(*(void *)(*(void *)(*(void *)(*((void *)this + 31) + 24) + 16 * v8) & 0xFFFFFFFFFFFFFFF8)+ 16)));
        sub_1CB8E509C(v13, "\n");
        if (v25 == v24)
        {
          (*(void (**)(void *))(v24[0] + 32))(v24);
        }
        else if (v25)
        {
          (*(void (**)(void))(*v25 + 40))();
        }
        uint64_t result = v27;
        if (v27 == (llvm::raw_ostream *)v26)
        {
          uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(void *))(v26[0] + 32))(v26);
        }
        else if (v27)
        {
          uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(void))(*(void *)v27 + 40))();
        }
      }
    }
    int v14 = *(_DWORD *)(*((void *)this + 31) + 32);
    if (v14)
    {
      for (int j = 0; v14 != j; ++j)
      {
        uint64_t v16 = j & 0x7FFFFFFF;
        if (*(_DWORD *)(*((void *)this + 38) + 4 * v16) != 0x3FFFFFFF)
        {
          __int16 v17 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v17 >= *((void *)a2 + 3))
          {
            unint64_t v18 = llvm::raw_ostream::write(a2, 91);
          }
          else
          {
            *((void *)a2 + 4) = v17 + 1;
            *__int16 v17 = 91;
            unint64_t v18 = a2;
          }
          llvm::printReg(j | 0x80000000, *((void *)this + 33), 0, 0, (uint64_t)v26);
          if (!v27) {
            goto LABEL_36;
          }
          (*(void (**)(llvm::raw_ostream *, llvm::raw_ostream *))(*(void *)v27 + 48))(v27, v18);
          uint64_t v19 = sub_1CB8E509C(v18, " -> fi#");
          __int16 v20 = llvm::raw_ostream::operator<<(v19, *(int *)(*((void *)this + 38) + 4 * v16));
          uint64_t v21 = sub_1CB8E509C(v20, "] ");
          unsigned int v22 = sub_1CB8E509C(v21, (char *)(*(void *)(*((void *)this + 33) + 80)+ *(unsigned int *)(*(void *)(*(void *)(*(void *)(*((void *)this + 31) + 24)+ 16 * v16) & 0xFFFFFFFFFFFFFFF8)+ 16)));
          sub_1CB8E509C(v22, "\n");
          uint64_t result = v27;
          if (v27 == (llvm::raw_ostream *)v26)
          {
            uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(void *))(v26[0] + 32))(v26);
          }
          else if (v27)
          {
            uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(void))(*(void *)v27 + 40))();
          }
        }
      }
    }
  }
  BOOL v23 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v23 >= *((void *)a2 + 3)) {
    return llvm::raw_ostream::write(a2, 10);
  }
  *((void *)a2 + 4) = v23 + 1;
  *BOOL v23 = 10;
  return result;
}

uint64_t llvm::VirtRegMap::dump(llvm::VirtRegMap *this)
{
  uint64_t v2 = llvm::dbgs(this);
  unsigned int v3 = *(uint64_t (**)(llvm::VirtRegMap *, llvm *, void))(*(void *)this + 40);

  return v3(this, v2, 0);
}

void llvm::initializeVirtRegRewriterPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7CA8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4C60A8;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD7CA8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createVirtRegRewriter(llvm *this)
{
}

void sub_1CD58E08C(llvm::Pass *a1)
{
  sub_1CD58E10C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD58E0C4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

void llvm::callDefaultCtor<llvm::VirtRegMap>()
{
}

void sub_1CD58E10C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2615C08;
  MEMORY[0x1D25D9CD0](*((void *)a1 + 44), 8);
  uint64_t v2 = (void *)*((void *)a1 + 41);
  if (v2 != (void *)((char *)a1 + 344)) {
    free(v2);
  }
  unsigned int v3 = (void *)*((void *)a1 + 38);
  if (v3 != (void *)((char *)a1 + 320)) {
    free(v3);
  }
  unint64_t v4 = (void *)*((void *)a1 + 35);
  if (v4 != (void *)((char *)a1 + 296)) {
    free(v4);
  }

  sub_1CBA0E6AC(a1);
}

_DWORD *sub_1CD58E1A4(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      int v6 = *(_DWORD **)result;
      uint64_t v7 = 40 * v2;
      do
      {
        *int v6 = -1;
        v6 += 10;
        v7 -= 40;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC415EB8(v1, v5);
  }
  return result;
}

void llvm::initializeWasmEHPreparePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7CB0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4C8260;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCD7CB0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createWasmEHPass(llvm *this)
{
}

void *sub_1CD58E338(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = a2 & 0xFFFFFFFFFFFFFFFBLL;
  uint64_t v19 = (unsigned char *)(a2 & 0xFFFFFFFFFFFFFFFBLL);
  unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFBLL;
  sub_1CD58E458(a1, &v19)[1] = a3 & 0xFFFFFFFFFFFFFFFBLL;
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v7 = a1 + 24;
  uint64_t v6 = v8;
  int v9 = *(_DWORD *)(v7 + 16);
  if (v9)
  {
    int v11 = v9 - 1;
    unsigned int v12 = v11 & (37 * v5);
    uint64_t v13 = *(void *)(v6 + 72 * v12);
    if (v5 == v13) {
      goto LABEL_7;
    }
    int v16 = 1;
    while (v13 != -4096)
    {
      unsigned int v17 = v12 + v16++;
      unsigned int v12 = v17 & v11;
      uint64_t v13 = *(void *)(v6 + 72 * v12);
      if (v5 == v13) {
        goto LABEL_7;
      }
    }
  }
  uint64_t v19 = v23;
  __int16 v20 = v23;
  uint64_t v21 = 4;
  int v22 = 0;
  unint64_t v18 = v5;
  uint64_t v10 = sub_1CD58E8F0((uint64_t *)v7, &v18) + 1;
  if (&v19 != v10) {
    llvm::SmallPtrSetImplBase::MoveFrom((uint64_t)v10, 4, (double *)&v19);
  }
  if (v20 != v19) {
    free(v20);
  }
LABEL_7:
  uint64_t v19 = (unsigned char *)v5;
  int v14 = sub_1CD58E8F0((uint64_t *)v7, &v19);
  return sub_1CB89694C((llvm::SmallPtrSetImplBase *)(v14 + 1), v4);
}

void *sub_1CD58E458(uint64_t a1, void *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD58E518(a1, (uint64_t)a2, a2, v9);
    *uint64_t v6 = *a2;
    v6[1] = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -8192;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (void *)(*(void *)a1 + 16 * (v13 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      int v9 = v10;
    }
    else {
      int v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

void *sub_1CD58E518(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3) {
      goto LABEL_3;
    }
    sub_1CD58E6A0(a1, v7);
    int v17 = *(_DWORD *)(a1 + 16);
    if (v17)
    {
      int v18 = v17 - 1;
      unsigned int v19 = (37 * *a3) & v18;
      a4 = (void *)(*(void *)a1 + 16 * v19);
      uint64_t v20 = *a4;
      if (*a3 == *a4) {
        goto LABEL_3;
      }
      unsigned int v13 = 0;
      int v21 = 1;
      while (v20 != -4096)
      {
        if (v13) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v20 == -8192;
        }
        if (v22) {
          unsigned int v13 = a4;
        }
        unsigned int v23 = v19 + v21++;
        unsigned int v19 = v23 & v18;
        a4 = (void *)(*(void *)a1 + 16 * v19);
        uint64_t v20 = *a4;
        if (*a3 == *a4) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a4 = 0;
    goto LABEL_3;
  }
  sub_1CD58E6A0(a1, 2 * v7);
  int v9 = *(_DWORD *)(a1 + 16);
  if (!v9) {
    goto LABEL_24;
  }
  int v10 = v9 - 1;
  unsigned int v11 = (37 * *a3) & v10;
  a4 = (void *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a4;
  if (*a3 == *a4) {
    goto LABEL_3;
  }
  unsigned int v13 = 0;
  int v14 = 1;
  while (v12 != -4096)
  {
    if (v13) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v12 == -8192;
    }
    if (v15) {
      unsigned int v13 = a4;
    }
    unsigned int v16 = v11 + v14++;
    unsigned int v11 = v16 & v10;
    a4 = (void *)(*(void *)a1 + 16 * v11);
    uint64_t v12 = *a4;
    if (*a3 == *a4) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v13) {
    a4 = v13;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD58E6A0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD58E76C(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD58E76C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    int v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *int v4 = -4096;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v6 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & (37 * v6);
      int v9 = (void *)(*(void *)result + 16 * v8);
      uint64_t v10 = *v9;
      if (v6 != *v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -4096)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -8192;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          int v9 = (void *)(*(void *)result + 16 * (v14 & v7));
          uint64_t v10 = *v9;
          if (v6 == *v9) {
            goto LABEL_9;
          }
        }
        if (v11) {
          int v9 = v11;
        }
      }
LABEL_9:
      *int v9 = v6;
      v9[1] = a2[1];
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t sub_1CD58E84C(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = (37 * *a2) & (v3 - 1);
    int v7 = (void *)(*a1 + 72 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        int v7 = (void *)(v4 + 72 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        int v7 = v10;
      }
    }
  }
  else
  {
    int v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

void *sub_1CD58E8F0(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CD58E84C(a1, a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD58E96C((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 5;
    void v5[2] = v5 + 5;
    v5[3] = 4;
    *((_DWORD *)v5 + sub_1CD521E44((uint64_t)this + 8) = 0;
  }
  return v5;
}

void *sub_1CD58E96C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD58EA1C(a1, v7);
  int v9 = 0;
  sub_1CD58E84C((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD58EA1C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(72 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD58EAF4(a1, v4, &v4[9 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 72 * v10;
    do
    {
      void *result = -4096;
      result += 9;
      v11 -= 72;
    }
    while (v11);
  }
  return result;
}

void sub_1CD58EAF4(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 72 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 9;
      v8 -= 72;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v12 = 0;
      sub_1CD58E84C((uint64_t *)a1, a2, &v12);
      int v9 = v12;
      uint64_t v10 = v12 + 5;
      *BOOL v12 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v9 + 1), v10, 4, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      uint64_t v11 = (void *)a2[2];
      if (v11 != (void *)a2[1]) {
        free(v11);
      }
    }
    a2 += 9;
  }
}

void llvm::initializeWinEHPreparePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7CB8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4C9EE0;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCD7CB8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createWinEHPass(llvm *this)
{
}

uint64_t *llvm::calculateSEHStateNumbers(uint64_t *this, const llvm::Function *a2, llvm::WinEHFuncInfo *a3)
{
  if (!*((_DWORD *)a2 + 114))
  {
    char v4 = (llvm *)this;
    unint64_t v5 = this + 9;
    uint64_t v6 = (uint64_t *)this[10];
    if (v6 != this + 9)
    {
      do
      {
        if (v6) {
          int v7 = v6 - 3;
        }
        else {
          int v7 = 0;
        }
        uint64_t v8 = v7[6];
        uint64_t v9 = v8 - 24;
        if (!v8) {
          uint64_t v9 = 0;
        }
        int v10 = *(unsigned __int8 *)(v9 + 16);
        uint64_t v11 = v7[6];
        if (v10 == 83)
        {
          uint64_t v11 = v7[6];
          do
          {
            uint64_t v11 = *(void *)(v11 + 8);
            uint64_t v12 = v11 - 24;
            if (!v11) {
              uint64_t v12 = 0;
            }
          }
          while (*(unsigned char *)(v12 + 16) == 83);
        }
        unsigned int v13 = v7 + 5;
        unsigned int v14 = *(unsigned __int8 *)(v11 - 8) - 38;
        BOOL v15 = v14 > 0x38;
        uint64_t v16 = (1 << v14) & 0x100060000000001;
        if (!v15 && v16 != 0)
        {
          while (1)
          {
            uint64_t v18 = v8 - 24;
            uint64_t v19 = v8 ? v8 - 24 : 0;
            if (*(unsigned char *)(v19 + 16) != 83) {
              break;
            }
            uint64_t v8 = *(void *)(v8 + 8);
            if ((uint64_t *)v8 == v13)
            {
              uint64_t v18 = 0;
              break;
            }
          }
          if (sub_1CC4C9F7C(v18)) {
            sub_1CC4CA034((uint64_t)a2, v18, 0xFFFFFFFFLL);
          }
        }
        uint64_t v6 = (uint64_t *)v6[1];
      }
      while (v6 != v5);
    }
    return sub_1CC4CA498(v4, (uint64_t)a2);
  }
  return this;
}

uint64_t *llvm::calculateWinCXXEHStateNumbers(uint64_t *this, const llvm::Function *a2, llvm::WinEHFuncInfo *a3)
{
  if (!*((_DWORD *)a2 + 2))
  {
    char v4 = (llvm *)this;
    unint64_t v5 = this + 9;
    uint64_t v6 = (uint64_t *)this[10];
    if (v6 != this + 9)
    {
      do
      {
        if (v6) {
          int v7 = v6 - 3;
        }
        else {
          int v7 = 0;
        }
        uint64_t v8 = v7[6];
        uint64_t v9 = v8 - 24;
        if (!v8) {
          uint64_t v9 = 0;
        }
        int v10 = *(unsigned __int8 *)(v9 + 16);
        uint64_t v11 = v7[6];
        if (v10 == 83)
        {
          uint64_t v11 = v7[6];
          do
          {
            uint64_t v11 = *(void *)(v11 + 8);
            uint64_t v12 = v11 - 24;
            if (!v11) {
              uint64_t v12 = 0;
            }
          }
          while (*(unsigned char *)(v12 + 16) == 83);
        }
        unsigned int v13 = v7 + 5;
        unsigned int v14 = *(unsigned __int8 *)(v11 - 8) - 38;
        BOOL v15 = v14 > 0x38;
        uint64_t v16 = (1 << v14) & 0x100060000000001;
        if (!v15 && v16 != 0)
        {
          while (1)
          {
            uint64_t v18 = v8 - 24;
            uint64_t v19 = v8 ? v8 - 24 : 0;
            if (*(unsigned char *)(v19 + 16) != 83) {
              break;
            }
            uint64_t v8 = *(void *)(v8 + 8);
            if ((uint64_t *)v8 == v13)
            {
              uint64_t v18 = 0;
              break;
            }
          }
          if (sub_1CC4C9F7C(v18)) {
            sub_1CC4CA6F0((uint64_t)a2, v18, 0xFFFFFFFF);
          }
        }
        uint64_t v6 = (uint64_t *)v6[1];
      }
      while (v6 != v5);
    }
    return sub_1CC4CA498(v4, (uint64_t)a2);
  }
  return this;
}

void *llvm::WinEHFuncInfo::addIPToStateRange(llvm::WinEHFuncInfo *this, const llvm::InvokeInst *a2, llvm::MCSymbol *a3, llvm::MCSymbol *a4)
{
  uint64_t v8 = a3;
  uint64_t v9 = a2;
  int v6 = *((_DWORD *)sub_1CD40EB18((uint64_t)this + 48, (uint64_t *)&v9) + 2);
  uint64_t result = sub_1CD542CF8((uint64_t)this + 72, (uint64_t *)&v8);
  *((_DWORD *)result + 2) = v6;
  result[2] = a4;
  return result;
}

__n128 llvm::WinEHFuncInfo::WinEHFuncInfo(__n128 *this)
{
  this->n128_u64[0] = 0;
  this->n128_u64[1] = 0;
  this[1].n128_u32[0] = 0;
  this[1].n128_u64[1] = 0;
  this[2].n128_u64[0] = 0;
  this[2].n128_u32[2] = 0;
  this[3].n128_u64[0] = 0;
  this[3].n128_u64[1] = 0;
  this[4].n128_u32[0] = 0;
  this[4].n128_u64[1] = 0;
  this[5].n128_u64[0] = 0;
  this[5].n128_u32[2] = 0;
  this[6].n128_u64[0] = (unint64_t)this[7].n128_u64;
  this[6].n128_u64[1] = 0x400000000;
  this[11].n128_u64[0] = (unint64_t)this[12].n128_u64;
  this[11].n128_u64[1] = 0x400000000;
  this[28].n128_u64[0] = (unint64_t)this[29].n128_u64;
  this[28].n128_u64[1] = 0x400000000;
  this[35].n128_u64[0] = (unint64_t)this[36].n128_u64;
  this[35].n128_u64[1] = 0x400000000;
  result.n128_u64[0] = 0x8000000080000000;
  result.n128_u64[1] = 0x8000000080000000;
  this[42] = result;
  this[43].n128_u64[0] = 0x8000000080000000;
  return result;
}

uint64_t sub_1CD58F044(uint64_t a1)
{
  unsigned int v3 = (void **)(a1 + 24);
  sub_1CC4CDFC0(&v3);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

uint64_t *sub_1CD58F08C(uint64_t *result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (!v2 && !*((_DWORD *)result + 3)) {
    return result;
  }
  uint64_t v3 = *((unsigned int *)result + 4);
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      v1[1] = 0;
      return result;
    }
    uint64_t v4 = 16 * v3;
    __n128 result = (uint64_t *)(*result + 8);
    while (1)
    {
      uint64_t v5 = *(result - 1);
      if (v5 == -8192) {
        goto LABEL_9;
      }
      if (v5 != -4096) {
        break;
      }
LABEL_10:
      result += 2;
      v4 -= 16;
      if (!v4) {
        goto LABEL_11;
      }
    }
    __n128 result = sub_1CD487110(result);
LABEL_9:
    *(result - 1) = -4096;
    goto LABEL_10;
  }

  return sub_1CD58F3C8(result);
}

void sub_1CD58F140(uint64_t a1)
{
  sub_1CC0A1FD4((_DWORD *)a1);
  uint64_t v2 = *(void *)(a1 + 24);
  for (uint64_t i = *(void *)(a1 + 32); i != v2; i -= 32)
  {
    uint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  *(void *)(a1 + 32) = v2;
}

uint64_t sub_1CD58F194(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CBFFB304(a1, &v13, &v14, (uint64_t)&v11);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v8 = (unint64_t)*a2;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    sub_1CC4CE04C((uint64_t *)(a1 + 24), &v8);
    if (*((void *)&v8 + 1)) {
      operator delete(*((void **)&v8 + 1));
    }
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = ((unint64_t)(*(void *)(a1 + 32) - v5) >> 5) - 1;
    *(_DWORD *)(v4 + sub_1CD521E44((uint64_t)this + 8) = v6;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v11 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  return v5 + 32 * v6 + 8;
}

uint64_t *sub_1CD58F244(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = (void *)a2[1];
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 32);
    v2 -= 32;
    *(v4 - 4) = v5;
    v4 -= 4;
    void v4[2] = 0;
    v4[3] = 0;
    v4[1] = 0;
    *(_OWORD *)(v4 + 1) = *(_OWORD *)(v2 + 8);
    v4[3] = *(void *)(v2 + 24);
    *(void *)(v2 + sub_1CD521E44((uint64_t)this + 8) = 0;
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 24) = 0;
  }
  a2[1] = v4;
  uint64_t v6 = *result;
  void *result = (uint64_t)v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1CD58F2BC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 32;
    uint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_1CD58F320(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  if ((*a1 & 4) != 0)
  {
    uint64_t v5 = *(uint64_t **)(v3 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v4 = &v5[*(unsigned int *)((v3 & 0xFFFFFFFFFFFFFFF8) + 8)];
  }
  else
  {
    uint64_t v4 = &a1[v3 > 7];
    uint64_t v5 = a1;
  }
  if (v5 != v4)
  {
    while (*v5 != a2)
    {
      if (++v5 == v4)
      {
        uint64_t v5 = v4;
        break;
      }
    }
  }
  if (v5 != v4)
  {
    for (uint64_t i = v5 + 1; i != v4; ++i)
    {
      if (*i != a2) {
        *v5++ = *i;
      }
    }
  }
  if ((v3 & 4) != 0) {
    uint64_t v7 = (uint64_t *)(*(void *)(v3 & 0xFFFFFFFFFFFFFFF8) + 8 * *(unsigned int *)((v3 & 0xFFFFFFFFFFFFFFF8) + 8));
  }
  else {
    uint64_t v7 = &a1[v3 > 7];
  }
  return sub_1CC4D0194(a1, v5, v7);
}

uint64_t *sub_1CD58F3C8(uint64_t *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  if (v2)
  {
    uint64_t v4 = 16 * v2;
    __n128 result = (uint64_t *)(*result + 8);
    do
    {
      if ((*(result - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        __n128 result = sub_1CD487110(result);
      }
      result += 2;
      v4 -= 16;
    }
    while (v4);
  }
  if (v3)
  {
    int v5 = 1 << (33 - __clz(v3 - 1));
    if (v5 <= 64) {
      unsigned int v6 = 64;
    }
    else {
      unsigned int v6 = v5;
    }
    __n128 result = (uint64_t *)*v1;
    if (v6 == *((_DWORD *)v1 + 4))
    {
      v1[1] = 0;
      uint64_t v7 = 16 * v6;
      do
      {
        void *result = -4096;
        result += 2;
        v7 -= 16;
      }
      while (v7);
      return result;
    }
  }
  else
  {
    if (!*((_DWORD *)v1 + 4))
    {
      v1[1] = 0;
      return result;
    }
    unsigned int v6 = 0;
    __n128 result = (uint64_t *)*v1;
  }
  MEMORY[0x1D25D9CD0](result, 8);

  return (uint64_t *)sub_1CB837D60(v1, v6);
}

uint64_t sub_1CD58F4CC(unint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 2);
  unint64_t v4 = *a1;
  if (v3 >= *((_DWORD *)a1 + 3))
  {
    unint64_t v8 = v4 + (v3 << 6);
    if (v4 > (unint64_t)a2 || v8 <= (unint64_t)a2) {
      sub_1CD58F588();
    }
    sub_1CD58F588();
  }
  unint64_t v5 = v4 + ((unint64_t)*((unsigned int *)a1 + 2) << 6);
  uint64_t v6 = *a2;
  *(_DWORD *)(v5 + sub_1CD521E44((uint64_t)this + 8) = *((_DWORD *)a2 + 2);
  *(void *)unint64_t v5 = v6;
  *(void *)(v5 + 24) = 0x100000000;
  *(void *)(v5 + 16) = v5 + 32;
  uint64_t result = v5 + 16;
  if (*((_DWORD *)a2 + 6)) {
    uint64_t result = sub_1CD58F7DC(result, (uint64_t)(a2 + 2));
  }
  ++*((_DWORD *)a1 + 2);
  return result;
}

void sub_1CD58F588()
{
}

void sub_1CD58F5F8(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a1 + (v2 << 6);
    uint64_t v6 = (void *)(a2 + 16);
    uint64_t v7 = v4 + 16;
    do
    {
      uint64_t v9 = v7 - 16;
      uint64_t v8 = *(void *)(v7 - 16);
      *((_DWORD *)v6 - 2) = *(_DWORD *)(v7 - 8);
      *(v6 - 2) = v8;
      *uint64_t v6 = v6 + 2;
      v6[1] = 0x100000000;
      if (*(_DWORD *)(v7 + 8)) {
        uint64_t v6 = (void *)sub_1CD58F6C4((uint64_t)v6, v7);
      }
      v6 += 8;
      v7 += 64;
    }
    while (v9 + 64 != v5);
    uint64_t v10 = *((unsigned int *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = v10 << 6;
      do
      {
        uint64_t v13 = *(void **)(v11 + v12 - 48);
        if ((void *)(v11 + v12 - 32) != v13) {
          free(v13);
        }
        v12 -= 64;
      }
      while (v12);
    }
  }
}

uint64_t sub_1CD58F6C4(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      uint64_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)a1, v4, 32 * v9);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove(*(void **)a1, v4, 32 * v10);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 32 * v10), (const void *)(*(void *)a2 + 32 * v10), *(void *)a2 + 32 * v11 - (*(void *)a2 + 32 * v10));
        }
      }
      *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v9;
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD58F7DC(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 32 * v4);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 32 * v5);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 32 * v5), (const void *)(*(void *)a2 + 32 * v5), *(void *)a2 + 32 * v6 - (*(void *)a2 + 32 * v5));
      }
    }
    *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4;
  }
  return a1;
}

uint64_t sub_1CD58F8A8(uint64_t result, char *a2, uint64_t (*a3)(uint64_t), char *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = result;
  unint64_t v8 = a4 - a2;
  uint64_t v9 = *(unsigned int *)(result + 8);
  if (v9 + ((a4 - a2) >> 5) > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a4)
  {
    uint64_t v10 = (uint64_t *)(*(void *)result + 8 * v9);
    do
    {
      uint64_t v11 = *(void *)v6;
      v6 += 32;
      uint64_t result = a3(v11);
      *v10++ = result;
    }
    while (v6 != a4);
    LODWORD(v9) = *(_DWORD *)(v7 + 8);
  }
  *(_DWORD *)(v7 + sub_1CD521E44((uint64_t)this + 8) = v9 + (v8 >> 5);
  return result;
}

void llvm::initializeXRayInstrumentationPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7F00, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4D0A84;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD7F00, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeLiveDebugValuesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD7F08, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4D28CC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD7F08, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD58FA28(long long *a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)qword_1EBD06348, 0, 0);
  dword_1EBD063C8 = 0;
  qword_1EBD063D0 = (uint64_t)&unk_1F2643C00;
  unk_1EBD063D8 = 0;
  qword_1EBD06348[0] = (uint64_t)&unk_1F2609740;
  qword_1EBD063E0 = (uint64_t)&unk_1F2643CF0;
  qword_1EBD063E8 = (uint64_t)&unk_1F26097A8;
  qword_1EBD06400 = (uint64_t)&qword_1EBD063E8;
  llvm::cl::Option::setArgStr(v2, "experimental-debug-variable-locations", 0x25uLL);
  xmmword_1EBD06368 = *a1;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBD06348);
}

void sub_1CD58FB10(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD7FD0, 0, 0);
  dword_1EBCD8050 = 0;
  qword_1EBCD8058 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD8060 = 0;
  qword_1EBCD7FD0 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD8068 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD8070 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD8088 = (uint64_t)&qword_1EBCD8070;
  llvm::cl::Option::setArgStr(v6, "livedebugvalues-input-bb-limit", 0x1EuLL);
  xmmword_1EBCD7FF0 = *a1;
  dword_1EBCD8050 = **a2;
  byte_1EBCD8064 = 1;
  dword_1EBCD8060 = dword_1EBCD8050;
  word_1EBCD7FDA = (32 * (*a3 & 3)) | word_1EBCD7FDA & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD7FD0);
}

void sub_1CD58FC38(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD8090, 0, 0);
  dword_1EBCD8110 = 0;
  qword_1EBCD8118 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD8120 = 0;
  qword_1EBCD8090 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD8128 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD8130 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD8148 = (uint64_t)&qword_1EBCD8130;
  llvm::cl::Option::setArgStr(v6, "livedebugvalues-input-dbg-value-limit", 0x25uLL);
  xmmword_1EBCD80B0 = *a1;
  dword_1EBCD8110 = **a2;
  byte_1EBCD8124 = 1;
  dword_1EBCD8120 = dword_1EBCD8110;
  word_1EBCD809A = (32 * (*a3 & 3)) | word_1EBCD809A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8090);
}

void llvm::makeVarLocBasedLiveDebugValues(llvm *this)
{
}

_DWORD *sub_1CD58FE28(_DWORD *result, unsigned int a2)
{
  uint64_t v2 = *(void *)result;
  uint64_t v4 = (uint64_t *)(result + 2);
  uint64_t v3 = *((void *)result + 1);
  unsigned int v5 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v28 = result;
    uint64_t v29 = (uint64_t *)(result + 2);
    unsigned int v10 = a2;
    uint64_t v11 = v3 + 16 * v5;
    uint64_t v30 = a2 - 1;
    uint64_t v12 = *(void **)(v3 + 16 * v30);
    int v15 = *(_DWORD *)(v11 + 8);
    int v14 = (_DWORD *)(v11 + 8);
    int v13 = v15;
    int v16 = v15 - 1;
    if (v15 == 1)
    {
      __int16 v27 = *(void **)(v2 + 200);
      *uint64_t v12 = *v27;
      *__int16 v27 = v12;
      unsigned int v5 = a2 - 1;
      sub_1CD58FE28(result, v30);
      uint64_t result = v28;
      a2 = v10;
      uint64_t v4 = v29;
    }
    else
    {
      int v17 = *(_DWORD *)(v3 + 16 * v30 + 12);
      if (v17 + 1 != v13)
      {
        unsigned int v18 = *(_DWORD *)(v3 + 16 * v30 + 12);
        do
        {
          v12[v18] = v12[v18 + 1];
          v12[v18 + 12] = v12[v18 + 13];
          ++v18;
        }
        while (v16 != v18);
      }
      *int v14 = v16;
      uint64_t v19 = (uint64_t *)(v3 + 16 * (a2 - 2));
      uint64_t v20 = *((unsigned int *)v19 + 3);
      uint64_t v21 = *v19;
      uint64_t v22 = *(void *)(*v19 + 8 * v20);
      uint64_t v23 = (v13 - 2);
      *(void *)(v21 + 8 * v20) = v22 & 0xFFFFFFFFFFFFFFC0 | v23;
      BOOL v24 = v17 == v16;
      uint64_t v4 = (uint64_t *)(result + 2);
      unsigned int v5 = v30;
      if (v24)
      {
        sub_1CC4DB5F8((uint64_t)result, v30, v12[v23 + 12]);
        llvm::IntervalMapImpl::Path::moveRight(v29, v30);
        uint64_t v4 = v29;
        unsigned int v5 = v30;
        uint64_t result = v28;
        a2 = v10;
      }
    }
    goto LABEL_4;
  }
  unsigned int v6 = *(_DWORD *)(v3 + 12);
  int v7 = *(_DWORD *)(v2 + 196);
  if (v6 + 1 != v7)
  {
    do
    {
      *(void *)(v2 + 8 + 8 * v6) = *(void *)(v2 + 8 + 8 * (v6 + 1));
      *(void *)(v2 + 96 + 8 * v6) = *(void *)(v2 + 96 + 8 * (v6 + 1));
      ++v6;
    }
    while (v7 - 1 != v6);
  }
  int v8 = v7 - 1;
  *(_DWORD *)(v2 + 196) = v8;
  *(_DWORD *)(v3 + sub_1CD521E44((uint64_t)this + 8) = v8;
  if (v8)
  {
LABEL_4:
    if (result[4])
    {
      uint64_t v9 = *v4;
      if (*(_DWORD *)(*v4 + 12) < *(_DWORD *)(*v4 + 8))
      {
        uint64_t v25 = *(void *)(*(void *)(v9 + 16 * v5) + 8 * *(unsigned int *)(v9 + 16 * v5 + 12));
        uint64_t v26 = v9 + 16 * a2;
        *(void *)uint64_t v26 = v25 & 0xFFFFFFFFFFFFFFC0;
        *(_DWORD *)(v26 + sub_1CD521E44((uint64_t)this + 8) = (v25 & 0x3F) + 1;
        *(_DWORD *)(*v4 + 16 * a2 + 12) = 0;
      }
    }
    return result;
  }
  *(_DWORD *)(v2 + 192) = 0;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 12sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 4sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;

  return sub_1CC4DA944(result, 0);
}

uint64_t sub_1CD590054(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v8 = result;
    uint64_t v9 = (int)v4;
    uint64_t v10 = a3 - 4;
    uint64_t v11 = result - 8;
    do
    {
      unsigned int v12 = *(_DWORD *)(a3 + 4 * v9);
      unsigned int v13 = *(_DWORD *)(a4 + 4 * v9);
      if (v12 != v13)
      {
        uint64_t v14 = v9;
        do
        {
          if (!v14) {
            break;
          }
          uint64_t result = sub_1CD5903FC(*(void *)(v8 + 8 * v9), v12, *(void *)(v11 + 8 * v14), *(_DWORD *)(v10 + 4 * v14), v13 - v12);
          *(_DWORD *)(v10 + 4 * v14) -= result;
          unsigned int v12 = *(_DWORD *)(a3 + 4 * v9) + result;
          *(_DWORD *)(a3 + 4 * v9) = v12;
          unsigned int v13 = *(_DWORD *)(a4 + 4 * v9);
          --v14;
        }
        while (v12 < v13);
      }
      --v9;
    }
    while (v9);
    if (a2 >= 2)
    {
      uint64_t v15 = 0;
      uint64_t v16 = 1;
      do
      {
        unsigned int v17 = *(_DWORD *)(a3 + 4 * v15);
        unsigned int v18 = *(_DWORD *)(a4 + 4 * v15);
        if (v17 != v18)
        {
          unsigned int v19 = v16;
          do
          {
            if (a2 == v19) {
              break;
            }
            uint64_t v20 = v15;
            uint64_t v21 = v16;
            uint64_t result = sub_1CD5903FC(*(void *)(v8 + 8 * v19), *(_DWORD *)(a3 + 4 * v19), *(void *)(v8 + 8 * v15), v17, v17 - v18);
            uint64_t v16 = v21;
            uint64_t v15 = v20;
            *(_DWORD *)(a3 + 4 * v19) += result;
            unsigned int v17 = *(_DWORD *)(a3 + 4 * v20) - result;
            *(_DWORD *)(a3 + 4 * v20) = v17;
            unsigned int v18 = *(_DWORD *)(a4 + 4 * v20);
            ++v19;
          }
          while (v17 < v18);
        }
        ++v15;
        uint64_t v16 = (v16 + 1);
      }
      while (v15 != v4);
    }
  }
  return result;
}

uint64_t sub_1CD5901A0(llvm::IntervalMapImpl::Path *this, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (unsigned int *)((char *)this + 8);
  uint64_t v5 = *(void *)this;
  BOOL v6 = a2 == 1;
  if (a2 == 1)
  {
    unsigned int v7 = *(_DWORD *)(v5 + 196);
    if (v7 <= 0xA)
    {
      uint64_t v8 = v5 + 8;
      uint64_t v9 = *(void *)v4;
      uint64_t v10 = *(unsigned int *)(v9 + 12);
      if (v7 != v10)
      {
        unsigned int v15 = *(_DWORD *)(v5 + 196);
        do
        {
          *(void *)(v8 + 8 * v15) = *(void *)(v8 + 8 * (v15 - 1));
          *(void *)(v5 + 96 + 8 * v15) = *(void *)(v5 + 96 + 8 * (v15 - 1));
          --v15;
        }
        while (v10 != v15);
      }
      uint64_t result = 0;
      unsigned int v12 = (void *)(v8 + 8 * v10);
      *unsigned int v12 = a3;
      v12[11] = a4;
      unsigned int v13 = v7 + 1;
      *(_DWORD *)(v5 + 196) = v13;
      uint64_t v14 = *(void *)(*(void *)v9 + 8 * v10);
      *(_DWORD *)(v9 + sub_1CD521E44((uint64_t)this + 8) = v13;
      *(void *)(v9 + 16) = v14 & 0xFFFFFFFFFFFFFFC0;
      *(_DWORD *)(v9 + 24) = (v14 & 0x3F) + 1;
      return result;
    }
    BOOL v37 = a2 == 1;
    std::string::size_type v33 = this;
    uint64_t v35 = a3;
    uint64_t v31 = (unsigned int *)((char *)this + 8);
    uint64_t v16 = a4;
    uint64_t v17 = sub_1CD590578(v5, *(unsigned int *)(*(void *)v4 + 12));
    llvm::IntervalMapImpl::Path::replaceRoot(v31, v5 + 8, *(_DWORD *)(v5 + 196), v17);
    uint64_t v4 = v31;
    this = v33;
    a3 = v35;
    a4 = v16;
    BOOL v6 = v37;
    a2 = 2;
  }
  uint64_t v36 = a3;
  unsigned int v38 = v6;
  unsigned int v18 = (llvm::IntervalMapImpl::Path *)v4;
  uint64_t v32 = a4;
  __int16 v34 = this;
  uint64_t v19 = (a2 - 1);
  if (!*((_DWORD *)this + 4)
    || (uint64_t v20 = *(void *)v4, *(_DWORD *)(*(void *)v18 + 12) >= *(_DWORD *)(*(void *)v18 + 8)))
  {
    llvm::IntervalMapImpl::Path::moveLeft(v18, a2 - 1);
    uint64_t v20 = *(void *)v18;
    ++*(_DWORD *)(*(void *)v18 + 16 * v19 + 12);
  }
  unsigned int v21 = *(_DWORD *)(v20 + 16 * v19 + 8);
  if (v21 == 12)
  {
    unsigned int v38 = sub_1CC4DB878(v34, v19);
    uint64_t v19 = v19 + v38;
    uint64_t v20 = *((void *)v34 + 1);
    unsigned int v21 = *(_DWORD *)(v20 + 16 * v19 + 8);
  }
  uint64_t v22 = (uint64_t *)(v20 + 16 * v19);
  uint64_t v23 = *v22;
  uint64_t v24 = *((unsigned int *)v22 + 3);
  uint64_t v25 = v22 + 1;
  if (v21 != v24)
  {
    unsigned int v26 = v21;
    do
    {
      *(void *)(v23 + 8 * v26) = *(void *)(v23 + 8 * (v26 - 1));
      *(void *)(v23 + 96 + 8 * v26) = *(void *)(v23 + 96 + 8 * (v26 - 1));
      --v26;
    }
    while (v24 != v26);
  }
  __int16 v27 = (void *)(v23 + 8 * v24);
  *__int16 v27 = v36;
  v27[12] = v32;
  _DWORD *v25 = v21 + 1;
  if (v19)
  {
    uint64_t v28 = v20 + 16 * (v19 - 1);
    *(void *)(*(void *)v28 + 8 * *(unsigned int *)(v28 + 12)) = *(void *)(*(void *)v28
                                                                                + 8 * *(unsigned int *)(v28 + 12)) & 0xFFFFFFFFFFFFFFC0 | v21;
  }
  if (v21 == v24)
  {
    sub_1CC4DB5F8((uint64_t)v34, v19, v32);
    uint64_t v20 = *((void *)v34 + 1);
    uint64_t v23 = *(void *)(v20 + 16 * v19);
  }
  uint64_t v29 = *(void *)(v23 + 8 * *(unsigned int *)(v20 + 16 * v19 + 12));
  uint64_t v30 = v20 + 16 * (v19 + 1);
  *(void *)uint64_t v30 = v29 & 0xFFFFFFFFFFFFFFC0;
  *(_DWORD *)(v30 + sub_1CD521E44((uint64_t)this + 8) = (v29 & 0x3F) + 1;
  return v38;
}

uint64_t sub_1CD5903FC(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    unsigned int v9 = 11 - a2;
    if (a4 >= a5) {
      unsigned int v10 = a5;
    }
    else {
      unsigned int v10 = a4;
    }
    if (v9 >= v10) {
      uint64_t v7 = v10;
    }
    else {
      uint64_t v7 = v9;
    }
    sub_1CD590490(a3, a4, a1, a2, v7);
  }
  else
  {
    if (-a5 < a2) {
      unsigned int v5 = -a5;
    }
    else {
      unsigned int v5 = a2;
    }
    if (11 - a4 >= v5) {
      int v6 = v5;
    }
    else {
      int v6 = 11 - a4;
    }
    sub_1CD590504(a1, a2, a3, a4, v6);
    return -v6;
  }
  return v7;
}

__n128 sub_1CD590490(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  if (a4)
  {
    uint64_t v5 = (a4 - 1);
    int v6 = -a4;
    do
    {
      uint64_t v7 = (a5 + v5);
      __n128 result = *(__n128 *)(a3 + 16 * v5);
      *(__n128 *)(a3 + 16 * v7) = result;
      *(unsigned char *)(a3 + v7 + 176) = *(unsigned char *)(a3 + v5-- + 176);
    }
    while (!__CFADD__(v6++, 1));
  }
  if (a5)
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = (a2 - a5 + v10);
      __n128 result = *(__n128 *)(a1 + 16 * v11);
      *(__n128 *)(a3 + 16 * v10) = result;
      *(unsigned char *)(a3 + v10++ + 176) = *(unsigned char *)(a1 + v11 + 176);
    }
    while (a5 != v10);
  }
  return result;
}

__n128 sub_1CD590504(uint64_t a1, int a2, uint64_t a3, int a4, int a5)
{
  if (a5)
  {
    for (uint64_t i = 0; i != a5; *(unsigned char *)(a3 + v6 + 176) = *(unsigned char *)(a1 + i++ + 176))
    {
      uint64_t v6 = (a4 + i);
      __n128 result = *(__n128 *)(a1 + 16 * i);
      *(__n128 *)(a3 + 16 * v6) = result;
    }
  }
  if (a2 != a5)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = (a5 + v8);
      __n128 result = *(__n128 *)(a1 + 16 * v9);
      *(__n128 *)(a1 + 16 * vsub_1CD521E44((uint64_t)this + 8) = result;
      *(unsigned char *)(a1 + v8++ + 176) = *(unsigned char *)(a1 + v9 + 176);
    }
    while (a2 - a5 != v8);
  }
  return result;
}

uint64_t sub_1CD590578(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 196);
  uint64_t v5 = *(uint64_t **)(a1 + 200);
  uint64_t v6 = *v5;
  if (*v5) {
    uint64_t *v5 = *(void *)v6;
  }
  else {
    uint64_t v6 = sub_1CB906F34(v5 + 1, 192, 6);
  }
  *(_OWORD *)(v6 + 160) = 0u;
  *(_OWORD *)(v6 + 176) = 0u;
  *(_OWORD *)(v6 + 12sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 4sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  if (v4)
  {
    uint64_t v7 = (uint64_t *)(a1 + 96);
    uint64_t v8 = (void *)v6;
    uint64_t v9 = v4;
    do
    {
      *uint64_t v8 = *(v7 - 11);
      uint64_t v10 = *v7++;
      v8[12] = v10;
      ++v8;
      --v9;
    }
    while (v9);
  }
  uint64_t v11 = (v4 - 1);
  *(void *)(a1 + 96) = *(void *)((v6 & 0xFFFFFFFFFFFFFFC0 | v11 & 0xFFFFFFFFFFFFFFC0)
                                   + 8 * v11
                                   + 0x60);
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v6 & 0xFFFFFFFFFFFFFFC0 | v11;
  ++*(_DWORD *)(a1 + 192);
  *(_DWORD *)(a1 + 196) = 1;
  return a2 << 32;
}

uint64_t sub_1CD59064C(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v8 = result;
    uint64_t v9 = a3 - 4;
    uint64_t v10 = result - 8;
    uint64_t v11 = a2 - 1;
    do
    {
      unsigned int v12 = *(_DWORD *)(a3 + 4 * v11);
      unsigned int v13 = *(_DWORD *)(a4 + 4 * v11);
      if (v12 != v13)
      {
        uint64_t v14 = v11;
        do
        {
          if (!v14) {
            break;
          }
          __n128 result = sub_1CD590794(*(void **)(v8 + 8 * v11), v12, *(void *)(v10 + 8 * v14), *(_DWORD *)(v9 + 4 * v14), v13 - v12);
          *(_DWORD *)(v9 + 4 * v14) -= result;
          unsigned int v12 = *(_DWORD *)(a3 + 4 * v11) + result;
          *(_DWORD *)(a3 + 4 * v11) = v12;
          unsigned int v13 = *(_DWORD *)(a4 + 4 * v11);
          --v14;
        }
        while (v12 < v13);
      }
      --v11;
    }
    while (v11);
    if (a2 >= 2)
    {
      uint64_t v15 = 0;
      int v16 = 1;
      do
      {
        unsigned int v17 = *(_DWORD *)(a3 + 4 * v15);
        unsigned int v18 = *(_DWORD *)(a4 + 4 * v15);
        if (v17 != v18)
        {
          unsigned int v19 = v16;
          do
          {
            if (a2 == v19) {
              break;
            }
            __n128 result = sub_1CD590794(*(void **)(v8 + 8 * v19), *(_DWORD *)(a3 + 4 * v19), *(void *)(v8 + 8 * v15), v17, v17 - v18);
            *(_DWORD *)(a3 + 4 * v19) += result;
            unsigned int v17 = *(_DWORD *)(a3 + 4 * v15) - result;
            *(_DWORD *)(a3 + 4 * v15) = v17;
            unsigned int v18 = *(_DWORD *)(a4 + 4 * v15);
            ++v19;
          }
          while (v17 < v18);
        }
        ++v15;
        ++v16;
      }
      while (v15 != v4);
    }
  }
  return result;
}

uint64_t sub_1CD590794(void *a1, unsigned int a2, uint64_t a3, unsigned int a4, int a5)
{
  if (a5 < 1)
  {
    unsigned int v12 = 12 - a4;
    if (-a5 < a2) {
      LODWORD(v13) = -a5;
    }
    else {
      LODWORD(v13) = a2;
    }
    if (v12 >= v13) {
      uint64_t v13 = v13;
    }
    else {
      uint64_t v13 = v12;
    }
    if (v13)
    {
      uint64_t v14 = a1;
      uint64_t v15 = v13;
      do
      {
        int v16 = (void *)(a3 + 8 * a4);
        *int v16 = *v14;
        v16[12] = v14[12];
        ++a4;
        ++v14;
        --v15;
      }
      while (v15);
    }
    if (v13 != a2)
    {
      unsigned int v17 = a1;
      int v18 = v13;
      do
      {
        unsigned int v19 = &a1[v18];
        *unsigned int v17 = *v19;
        v17[12] = v19[12];
        ++v18;
        ++v17;
      }
      while (a2 != v18);
    }
    return -(int)v13;
  }
  else
  {
    LODWORD(v5) = 12 - a2;
    if (a4 >= a5) {
      unsigned int v6 = a5;
    }
    else {
      unsigned int v6 = a4;
    }
    if (v5 >= v6) {
      uint64_t v5 = v6;
    }
    else {
      uint64_t v5 = v5;
    }
    if (a2)
    {
      uint64_t v7 = &a1[a2 - 1];
      do
      {
        uint64_t v8 = &a1[v5 - 1 + a2];
        *uint64_t v8 = *v7;
        v8[12] = v7[12];
        --v7;
        --a2;
      }
      while (a2);
    }
    if (v5)
    {
      int v9 = -(int)v5;
      do
      {
        uint64_t v10 = (void *)(a3 + 8 * (a4 + v9));
        *a1 = *v10;
        a1[12] = v10[12];
        ++a1;
      }
      while (!__CFADD__(v9++, 1));
    }
  }
  return v5;
}

_OWORD *sub_1CD5908A4(uint64_t a1, unint64_t *a2, _OWORD *a3)
{
  uint64_t v5 = (void **)sub_1CD4861E8(a1, &v12, a2);
  unsigned int v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    unsigned int v6 = operator new(0x30uLL);
    uint64_t v6[2] = *a3;
    uint64_t v9 = v12;
    *(void *)unsigned int v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    *uint64_t v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

_OWORD *sub_1CD590950(void **a1, void *a2, unint64_t *a3, _OWORD *a4)
{
  unsigned int v6 = (void **)sub_1CD590A00(a1, a2, &v14, &v13, a3);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v9 = v6;
    uint64_t v7 = operator new(0x30uLL);
    void v7[2] = *a4;
    uint64_t v10 = v14;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v10;
    *uint64_t v9 = v7;
    uint64_t v11 = (void *)**a1;
    uint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1CD590A00(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  if (a1 + 1 != a2)
  {
    unint64_t v5 = *a5;
    unint64_t v6 = a2[4];
    if (*a5 >= v6)
    {
      if (v6 < v5) {
        goto LABEL_9;
      }
      unint64_t v16 = a5[1];
      unint64_t v17 = a2[5];
      if (v16 < v17) {
        goto LABEL_3;
      }
      if (v17 < v16)
      {
LABEL_9:
        uint64_t v10 = a2[1];
        if (v10)
        {
          uint64_t v11 = (void *)a2[1];
          do
          {
            a4 = v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          int v18 = a2;
          do
          {
            a4 = (void *)v18[2];
            BOOL v14 = *a4 == (void)v18;
            int v18 = a4;
          }
          while (!v14);
        }
        if (a4 != a1 + 1)
        {
          unint64_t v19 = a4[4];
          if (v5 >= v19 && (v19 < v5 || a5[1] >= a4[5])) {
            return sub_1CD4861E8((uint64_t)a1, a3, a5);
          }
        }
        if (v10)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
      }
      else
      {
        *a3 = a2;
        *a4 = a2;
      }
      return a4;
    }
  }
LABEL_3:
  uint64_t v7 = *a2;
  if ((void *)*a1 == a2)
  {
    uint64_t v9 = a2;
LABEL_14:
    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  if (v7)
  {
    uint64_t v8 = (void *)*a2;
    do
    {
      uint64_t v9 = v8;
      uint64_t v8 = (void *)v8[1];
    }
    while (v8);
  }
  else
  {
    uint64_t v13 = a2;
    do
    {
      uint64_t v9 = (void *)v13[2];
      BOOL v14 = *v9 == (void)v13;
      uint64_t v13 = v9;
    }
    while (v14);
  }
  unint64_t v15 = v9[4];
  if (v15 < *a5 || *a5 >= v15 && v9[5] < a5[1]) {
    goto LABEL_14;
  }
  return sub_1CD4861E8((uint64_t)a1, a3, a5);
}

void sub_1CD590B5C(uint64_t a1)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  int v1 = *(_DWORD *)(a1 + 192);
  if (v1)
  {
    uint64_t v23 = v25;
    uint64_t v24 = 0x400000000;
    uint64_t v20 = v22;
    uint64_t v21 = 0x400000000;
    LODWORD(v2) = *(_DWORD *)(a1 + 196);
    if (v2)
    {
      LODWORD(v2) = 0;
      unsigned int v3 = 0;
      do
      {
        if (v2 >= HIDWORD(v24)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v23 + v2) = *(void *)(a1 + 8 + 8 * v3);
        LODWORD(v2) = v24 + 1;
        LODWORD(v24) = v24 + 1;
        ++v3;
      }
      while (v3 != *(_DWORD *)(a1 + 196));
      int v1 = *(_DWORD *)(a1 + 192);
    }
    int v4 = v1 - 1;
    if (v4)
    {
      int v18 = v4;
      uint64_t v19 = a1;
      do
      {
        uint64_t v10 = v24;
        if (v24)
        {
          uint64_t v11 = 0;
          uint64_t v12 = v23;
          unsigned int v13 = v21;
          do
          {
            uint64_t v14 = 0;
            uint64_t v15 = 8 * (v12[v11] & 0x3FLL) + 8;
            do
            {
              if (v13 >= HIDWORD(v21)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v20 + v13) = *(void *)((*((void *)v23 + v11) & 0xFFFFFFFFFFFFFFC0) + v14);
              unsigned int v13 = v21 + 1;
              LODWORD(v21) = v21 + 1;
              v14 += 8;
            }
            while (v15 != v14);
            uint64_t v12 = v23;
            unint64_t v16 = (void *)(*((void *)v23 + v11) & 0xFFFFFFFFFFFFFFC0);
            unint64_t v17 = *(void **)(v19 + 200);
            *unint64_t v16 = *v17;
            *unint64_t v17 = v16;
            ++v11;
          }
          while (v11 != v10);
        }
        LODWORD(v24) = 0;
        sub_1CC2E99B4(&v23, &v20);
        --v18;
      }
      while (v18);
      LODWORD(v2) = v24;
      a1 = v19;
    }
    if (v2)
    {
      uint64_t v2 = v2;
      unint64_t v5 = (uint64_t *)v23;
      unint64_t v6 = *(unint64_t **)(a1 + 200);
      unint64_t v7 = *v6;
      do
      {
        uint64_t v8 = *v5++;
        unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFC0;
        *(void *)(v8 & 0xFFFFFFFFFFFFFFC0) = v7;
        unint64_t v7 = v8 & 0xFFFFFFFFFFFFFFC0;
        --v2;
      }
      while (v2);
      *unint64_t v6 = v9;
    }
    if (v20 != v22) {
      free(v20);
    }
    if (v23 != v25) {
      free(v23);
    }
  }
}

uint64_t llvm::IntervalMap<unsigned long long,char,11u,llvm::IntervalMapInfo<unsigned long long>>::deleteNode(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unint64_t **)(result + 200);
  *(void *)(a2 & 0xFFFFFFFFFFFFFFC0) = *v2;
  *uint64_t v2 = a2 & 0xFFFFFFFFFFFFFFC0;
  return result;
}

LiveDebugValues::MLocTracker *LiveDebugValues::MLocTracker::MLocTracker(LiveDebugValues::MLocTracker *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = a2;
  *((void *)this + 6) = LiveDebugValues::ValueIDNum::EmptyValue;
  uint64_t v8 = (char *)this + 48;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = a5;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0;
  *((void *)this + sub_1CD521E44((uint64_t)this + 8) = 0;
  unint64_t v9 = (uint64_t *)((char *)this + 64);
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 11) = (char *)this + 104;
  *((void *)this + 12) = 0;
  *((void *)this + 14) = (char *)this + 128;
  uint64_t v10 = (char *)this + 112;
  *((void *)this + 15) = 0x800000000;
  *(_OWORD *)((char *)this + 16sub_1CD521E44((uint64_t)this + 8) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((void *)this + 20) = (char *)this + 168;
  *((void *)this + 23) = (char *)this + 192;
  *((_OWORD *)this + 13) = 0u;
  *((void *)this + 2sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 31) = (char *)this + 264;
  uint64_t v11 = (char *)this + 776;
  *(_OWORD *)((char *)this + 776) = 0u;
  *((_DWORD *)this + 19sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 204) = 0;
  *((_OWORD *)this + 50) = 0u;
  unint64_t v12 = *(unsigned int *)(a4 + 16);
  *((_DWORD *)this + 59) = v12;
  *((void *)this + 32) = 0x2000000000;
  v46[0] = -1;
  if (v12) {
    sub_1CD59DD30((uint64_t)this + 64, v12, v46);
  }
  uint64_t v13 = *(unsigned int *)(a5 + 88);
  if (v13)
  {
    uint64_t v43 = *v9;
    if (*(_DWORD *)(v43 + 4 * v13) == -1) {
      *(_DWORD *)(v43 + 4 * v13) = LiveDebugValues::MLocTracker::trackRegister(this, v13);
    }
    sub_1CB8FB608((uint64_t)v46, v13, (void *)(a4 + 8), 1);
    while (v48)
    {
LABEL_50:
      LODWORD(v45) = v49;
      sub_1CD513F60((uint64_t)v10, (unsigned int *)&v45);
      while (1)
      {
        sub_1CB8FB704((uint64_t)v46);
        if (v47 || v48 == 0) {
          break;
        }
        if (v46[0] != v49) {
          goto LABEL_50;
        }
      }
    }
  }
  uint64_t v45 = 8;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  uint64_t v45 = 0x100000010;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  uint64_t v45 = 0x200000020;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  uint64_t v45 = 0x300000040;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  uint64_t v45 = 0x400000080;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  uint64_t v45 = 0x500000100;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  uint64_t v45 = 0x600000200;
  sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
  unint64_t v14 = *(unsigned int *)(a4 + 104);
  if (v14 >= 2)
  {
    uint64_t v15 = 0;
    for (unint64_t i = 1; i < v14; ++i)
    {
      uint64_t v17 = *(void *)(a4 + 96) + v15;
      unsigned int v18 = *(unsigned __int16 *)(v17 + 6);
      unsigned int v19 = *(unsigned __int16 *)(v17 + 4);
      if (v18 <= 0xEA60 && v19 <= 0xEA60)
      {
        int v21 = *((_DWORD *)this + 196);
        LODWORD(v45) = v18 | (v19 << 16);
        HIDWORD(v45) = v21;
        sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
        unint64_t v14 = *(unsigned int *)(a4 + 104);
      }
      v15 += 4;
    }
  }
  uint64_t v22 = *(void *)(a4 + 240);
  for (uint64_t j = *(void *)(a4 + 248); v22 != j; v22 += 8)
  {
    if (*(_DWORD *)(*(void *)(a4 + 264)
                   + 24
                   * (*(unsigned __int16 *)(**(void **)v22 + 24)
                    + *(_DWORD *)(a4 + 272) * ((*(void *)(a4 + 248) - *(void *)(a4 + 240)) >> 3))) <= 0x200u)
    {
      int v24 = *((_DWORD *)this + 196);
      LODWORD(v45) = *(_DWORD *)(*(void *)(a4 + 264)
                               + 24
                               * (*(unsigned __int16 *)(**(void **)v22 + 24)
                                + *(_DWORD *)(a4 + 272)
                                * ((*(void *)(a4 + 248) - *(void *)(a4 + 240)) >> 3)));
      HIDWORD(v45) = v24;
      sub_1CD59E0D0((uint64_t)v46, (uint64_t)v11, (unsigned __int16 *)&v45, (_DWORD *)&v45 + 1);
    }
  }
  int v25 = *((_DWORD *)this + 196);
  uint64_t v26 = *((void *)this + 97);
  uint64_t v27 = *((unsigned int *)this + 198);
  uint64_t v28 = (unsigned __int16 *)(v26 + 8 * v27);
  if (v25)
  {
    if (v27)
    {
      uint64_t v29 = 8 * v27;
      uint64_t v30 = (unsigned __int16 *)*((void *)this + 97);
      while (1)
      {
        int v31 = *v30;
        int v32 = v30[1];
        if ((v31 != 0xFFFF || v32 != 0xFFFF) && (v31 != 65534 || v32 != 65534)) {
          break;
        }
        v30 += 4;
        v29 -= 8;
        if (!v29) {
          goto LABEL_29;
        }
      }
    }
    else
    {
      uint64_t v30 = (unsigned __int16 *)*((void *)this + 97);
    }
  }
  else
  {
LABEL_29:
    uint64_t v30 = (unsigned __int16 *)(v26 + 8 * v27);
  }
  uint64_t v35 = (unsigned __int16 *)(v26 + 8 * v27);
  if (v30 != v35)
  {
    do
    {
      uint64_t v36 = sub_1CD59E178((uint64_t)(v8 + 752), (_DWORD *)v30 + 1);
      BOOL v37 = v30 + 4;
      v36[1] = *(_DWORD *)v30;
      uint64_t v30 = v28;
      if (v37 != v28)
      {
        uint64_t v30 = v37;
        while (1)
        {
          int v38 = *v30;
          int v39 = v30[1];
          if ((v38 != 0xFFFF || v39 != 0xFFFF) && (v38 != 65534 || v39 != 65534)) {
            break;
          }
          v30 += 4;
          if (v30 == v28)
          {
            uint64_t v30 = v28;
            break;
          }
        }
      }
    }
    while (v30 != v35);
    int v25 = *((_DWORD *)this + 196);
  }
  *((_DWORD *)this + 60) = v25;
  return this;
}

unint64_t LiveDebugValues::MLocTracker::trackRegister(LiveDebugValues::MLocTracker *this, unsigned int a2)
{
  int v4 = (void *)((char *)this + 32);
  unint64_t v5 = *((unsigned int *)this + 10);
  unint64_t v6 = (v5 + 1);
  if (v6 > v5) {
    sub_1CC38F7B8((uint64_t)this + 32, v6 - v5, *((void *)this + 6));
  }
  unint64_t v7 = *((unsigned int *)this + 24);
  if (v6 > v7) {
    sub_1CC4E9F38((uint64_t)this + 88, v6 - v7, *((_DWORD *)this + 26));
  }
  unint64_t v8 = *((_DWORD *)this + 58) & 0xFFFFFLL | ((unint64_t)v5 << 40);
  uint64_t v9 = *((void *)this + 31);
  uint64_t v10 = 16 * *((unsigned int *)this + 64);
  while (v10)
  {
    int v11 = *(_DWORD *)(*(void *)(*(void *)(v9 + v10 - 16) + 16) + 4 * (a2 >> 5));
    v10 -= 16;
    if ((v11 & (1 << a2)) == 0)
    {
      unint64_t v8 = *((_DWORD *)this + 58) & 0xFFFFFLL | ((unint64_t)(*(_DWORD *)(v9 + v10 + 8) & 0xFFFFF) << 20) | (v5 << 40);
      break;
    }
  }
  *(void *)(*v4 + 8 * v5) = v8;
  *(_DWORD *)(*((void *)this + 11) + 4 * v5) = a2;
  return v5;
}

unint64_t LiveDebugValues::MLocTracker::writeRegMask(unint64_t this, const llvm::MachineOperand *a2, int a3, unsigned int a4)
{
  uint64_t v6 = this;
  int v7 = *(_DWORD *)(this + 40);
  if (v7)
  {
    uint64_t v8 = 0;
    unint64_t v9 = a3 & 0xFFFFFLL | ((unint64_t)(a4 & 0xFFFFF) << 20);
    do
    {
      unint64_t v10 = *(unsigned int *)(*(void *)(v6 + 88) + 4 * v8);
      if (v10 < *(_DWORD *)(v6 + 236))
      {
        if (*(void *)(v6 + 176))
        {
          for (unint64_t i = *(uint64_t **)(v6 + 168); i; unint64_t i = (uint64_t *)*i)
          {
            unsigned int v12 = *((_DWORD *)i + 7);
            if (v10 >= v12)
            {
              if (v12 >= v10) {
                goto LABEL_11;
              }
              ++i;
            }
          }
        }
        else
        {
          uint64_t v14 = *(unsigned int *)(v6 + 120);
          if (v14)
          {
            uint64_t v15 = *(_DWORD **)(v6 + 112);
            uint64_t v16 = 4 * v14;
            while (*v15 != v10)
            {
              ++v15;
              v16 -= 4;
              if (!v16) {
                goto LABEL_10;
              }
            }
            if (v16) {
              goto LABEL_11;
            }
          }
        }
LABEL_10:
        if (((*(_DWORD *)(*((void *)a2 + 2) + ((v10 >> 3) & 0x1FFFFFFC)) >> v10) & 1) == 0)
        {
          uint64_t v17 = *(void *)(v6 + 64);
          this = *(unsigned int *)(v17 + 4 * v10);
          if (this == -1)
          {
            this = LiveDebugValues::MLocTracker::trackRegister((LiveDebugValues::MLocTracker *)v6, *(_DWORD *)(*(void *)(v6 + 88) + 4 * v8));
            *(_DWORD *)(v17 + 4 * v10) = this;
          }
          *(void *)(*(void *)(v6 + 32) + 8 * this) = v9 | ((unint64_t)this << 40);
        }
      }
LABEL_11:
      int v13 = v8 + 1;
      uint64_t v8 = (v8 + 1);
    }
    while (v7 != v13);
  }
  unsigned int v18 = *(_DWORD *)(v6 + 256);
  if (v18 >= *(_DWORD *)(v6 + 260)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v19 = (void *)(*(void *)(v6 + 248) + 16 * v18);
  *unsigned int v19 = a2;
  v19[1] = a4;
  ++*(_DWORD *)(v6 + 256);
  return this;
}

uint64_t LiveDebugValues::MLocTracker::getOrTrackSpillLoc(uint64_t a1, int *a2)
{
  uint64_t v4 = a1 + 184;
  unint64_t v5 = sub_1CD59E55C(a1 + 184, a2);
  if ((uint64_t *)(a1 + 192) != v5)
  {
    unsigned int v6 = *((_DWORD *)v5 + 14);
    if (v6) {
      goto LABEL_3;
    }
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 216) - *(void *)(a1 + 208)) >> 3) >= dword_1EBCD8290)
  {
    uint64_t v7 = 0;
    unsigned int v6 = 0;
    return v7 | v6;
  }
  unsigned int v9 = sub_1CD59161C(v4, (uint64_t)a2);
  unsigned int v6 = v9;
  unsigned int v10 = *(_DWORD *)(a1 + 240);
  if (v10)
  {
    unsigned int v11 = 0;
    unsigned int v12 = v9 - 1;
    do
    {
      int v13 = *(_DWORD *)(a1 + 236);
      uint64_t v14 = *(unsigned int *)(a1 + 40);
      if (v14 == -1)
      {
        unsigned int v15 = 0;
      }
      else
      {
        unsigned int v15 = v14 + 1;
        sub_1CC38F7B8(a1 + 32, 1, *(void *)(a1 + 48));
      }
      uint64_t v16 = *(unsigned int *)(a1 + 96);
      if (v15 > v16) {
        sub_1CC4E9F38(a1 + 88, v15 - v16, *(_DWORD *)(a1 + 104));
      }
      uint64_t v17 = *(_DWORD **)(a1 + 72);
      if ((unint64_t)v17 >= *(void *)(a1 + 80))
      {
        unsigned int v18 = sub_1CC463D78((char **)(a1 + 64), v14);
      }
      else
      {
        *uint64_t v17 = v14;
        unsigned int v18 = (char *)(v17 + 1);
      }
      *(void *)(a1 + 72) = v18;
      *(_DWORD *)(*(void *)(a1 + 88) + 4 * v14) = v11 + v13 + v10 * v12;
      *(void *)(*(void *)(a1 + 32) + 8 * v14) = *(_DWORD *)(a1 + 232) & 0xFFFFF | (unint64_t)(v14 << 40);
      ++v11;
      unsigned int v10 = *(_DWORD *)(a1 + 240);
      uint64_t v7 = 0x100000000;
    }
    while (v11 < v10);
  }
  else
  {
LABEL_3:
    uint64_t v7 = 0x100000000;
  }
  return v7 | v6;
}

uint64_t sub_1CD59161C(uint64_t a1, uint64_t a2)
{
  unsigned int v10 = (_OWORD *)a2;
  uint64_t v4 = sub_1CD59E618(a1, (int *)a2, &v10);
  uint64_t result = *((unsigned int *)v4 + 14);
  if (!result)
  {
    unint64_t v6 = *(void *)(a1 + 32);
    unint64_t v7 = *(void *)(a1 + 40);
    *((_DWORD *)v4 + 14) = -1431655765 * ((v6 - *(void *)(a1 + 24)) >> 3) + 1;
    if (v6 >= v7)
    {
      unsigned int v9 = sub_1CBF99908((void **)(a1 + 24), a2);
    }
    else
    {
      long long v8 = *(_OWORD *)a2;
      *(void *)(v6 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)unint64_t v6 = v8;
      unsigned int v9 = (char *)(v6 + 24);
    }
    *(void *)(a1 + 32) = v9;
    return *((unsigned int *)v4 + 14);
  }
  return result;
}

void LiveDebugValues::MLocTracker::LocIdxToName(uint64_t a1@<X0>, unsigned int a2@<W1>, std::string *a3@<X8>)
{
  unsigned int v4 = *(_DWORD *)(*(void *)(a1 + 88) + 4 * a2);
  unsigned int v5 = *(_DWORD *)(a1 + 236);
  if (v4 >= v5)
  {
    unsigned int v8 = v4 - v5;
    unsigned int v9 = *(_DWORD *)(a1 + 240);
    int v10 = v8 / v9;
    unsigned int v11 = sub_1CBA86078(*(void *)(a1 + 800), *(_DWORD *)(a1 + 816), v8 % v9)[1];
    uint64_t v26 = "slot ";
    __int16 v27 = 259;
    __int16 v24 = 264;
    LODWORD(v23[0]) = v10;
    uint64_t v20 = " sz ";
    __int16 v21 = 259;
    __int16 v18 = 265;
    LODWORD(v17[0]) = (unsigned __int16)v11;
    uint64_t v14 = " offs ";
    __int16 v15 = 259;
    __int16 v13 = 265;
    LODWORD(v12[0]) = HIWORD(v11);
    sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)v16);
    sub_1CB8F1E58(v17, v16, (uint64_t)v19);
    sub_1CB8F1E58((uint64_t *)&v20, v19, (uint64_t)v22);
    sub_1CB8F1E58(v23, v22, (uint64_t)v25);
    sub_1CB8F1E58((uint64_t *)&v26, v25, (uint64_t)v28);
    llvm::Twine::str((llvm::Twine *)v28, a3);
  }
  else
  {
    unint64_t v6 = (const std::string::value_type *)(*(uint64_t (**)(void))(**(void **)(a1 + 16) + 512))(*(void *)(a1 + 16));
    if (v6)
    {
      std::string::__init(a3, v6, v7);
    }
    else
    {
      a3->__r_.__value_.__r.__words[0] = 0;
      a3->__r_.__value_.__l.__size_ = 0;
      a3->__r_.__value_.__r.__words[2] = 0;
    }
  }
}

void LiveDebugValues::MLocTracker::IDAsString(uint64_t a1@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  LiveDebugValues::MLocTracker::LocIdxToName(a1, *a2 >> 40, &__p);
  sub_1CD5918B4(a3, *a2, (uint64_t)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1CD5918B4(void *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v26 = "Value{bb: ";
  __int16 v27 = 259;
  __int16 v24 = 268;
  uint64_t v22 = a2 & 0xFFFFF;
  uint64_t v23 = &v22;
  unsigned int v19 = ", inst: ";
  __int16 v20 = 259;
  if ((a2 & 0xFFFFF00000) != 0)
  {
    uint64_t v13 = (a2 >> 20) & 0xFFFFF;
    char v4 = 12;
    unsigned int v5 = &v13;
  }
  else
  {
    char v4 = 3;
    unsigned int v5 = (uint64_t *)"live-in";
  }
  char v16 = 1;
  uint64_t v14 = v5;
  char v15 = v4;
  int v10 = ", loc: ";
  __int16 v11 = 259;
  __int16 v9 = 260;
  v8[0] = a3;
  sub_1CB8F1E58((uint64_t *)&v10, v8, (uint64_t)v12);
  sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)v17);
  unint64_t v6 = "}";
  __int16 v7 = 259;
  sub_1CB8F1E58(v17, (uint64_t *)&v6, (uint64_t)v18);
  sub_1CB8F1E58((uint64_t *)&v19, v18, (uint64_t)v21);
  sub_1CB8F1E58((uint64_t *)&v23, v21, (uint64_t)v25);
  sub_1CB8F1E58((uint64_t *)&v26, v25, (uint64_t)v28);
  llvm::Twine::str((llvm::Twine *)v28, a1);
}

llvm::MachineFunction *LiveDebugValues::MLocTracker::emitLoc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v40[2] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*(void *)a3 + 16);
  __int16 v9 = (void *)(v8 & 0xFFFFFFFFFFFFFFF8);
  if ((v8 & 4) != 0) {
    __int16 v9 = (void *)*v9;
  }
  Impl = (const llvm::DILocation *)llvm::DILocation::getImpl(v9, 0, 0, *(void *)(*(void *)a3 - 8 * *(unsigned int *)(*(void *)a3 + 8)), *(void *)(a3 + 32), 0, 0, 1);
  llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v36, Impl);
  unsigned int v12 = sub_1CC34E910(*(llvm::MachineFunction **)a1, &v36, *(void *)(*(void *)(a1 + 8) + 8) + 624);
  uint64_t v13 = v11;
  uint64_t v14 = *(llvm::DIExpression **)a4;
  if ((a2 & 0xFF00000000) == 0) {
    goto LABEL_8;
  }
  unsigned int v15 = *(_DWORD *)(*(void *)(a1 + 88) + 4 * a2);
  unsigned int v16 = *(_DWORD *)(a1 + 236);
  BOOL v17 = v15 >= v16;
  unsigned int v18 = v15 - v16;
  if (!v17)
  {
    *((void *)&v37 + 1) = 0;
    long long v38 = 0uLL;
    LODWORD(v37) = 0;
    DWORD1(v37) = v15;
    llvm::MachineInstr::addOperand(v11, v12, (const llvm::MachineOperand *)&v37);
    if (*(unsigned char *)(a4 + 8))
    {
LABEL_6:
      LODWORD(v37) = 1;
      *((void *)&v37 + 1) = 0;
      *(void *)&long long v38 = 0;
LABEL_10:
      llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v37);
      goto LABEL_11;
    }
LABEL_9:
    long long v37 = 0u;
    long long v38 = 0u;
    goto LABEL_10;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 240);
  unsigned int v20 = v18 / v19;
  if (*((_WORD *)sub_1CBA86078(*(void *)(a1 + 800), *(_DWORD *)(a1 + 816), v18 % v19) + 3))
  {
LABEL_8:
    long long v37 = 0u;
    long long v38 = 0u;
    llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v37);
    goto LABEL_9;
  }
  uint64_t v23 = *(void *)(a1 + 208);
  int v24 = *(_DWORD *)(v23 + 24 * v20);
  *((void *)&v37 + 1) = 0;
  long long v38 = 0uLL;
  LODWORD(v37) = 0;
  DWORD1(v37) = v24;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v37);
  unsigned int v25 = sub_1CD591D38(a1, a2);
  unsigned int v26 = v25;
  if (*(unsigned char *)(a3 + 24))
  {
    if (v25 != *(_DWORD *)(a3 + 8) || llvm::DIExpression::isComplex(v14))
    {
      if (!*(unsigned char *)(a4 + 8)) {
        goto LABEL_18;
      }
      goto LABEL_24;
    }
  }
  else
  {
    unint64_t SizeInBits = llvm::DIVariable::getSizeInBits(*(llvm::DIVariable **)a3);
    if (v29)
    {
      BOOL v30 = SizeInBits != v26;
      goto LABEL_23;
    }
  }
  BOOL v30 = 0;
LABEL_23:
  if (*(unsigned char *)(a4 + 8))
  {
LABEL_24:
    uint64_t v31 = *(void *)(a1 + 16);
    uint64_t v32 = v23 + 24 * v20 + 8;
    std::string::size_type v33 = v14;
    unsigned int v34 = 2;
    goto LABEL_25;
  }
  if (!v30)
  {
    BOOL isComplex = llvm::DIExpression::isComplex(v14);
    uint64_t v31 = *(void *)(a1 + 16);
    uint64_t v32 = v23 + 24 * v20 + 8;
    std::string::size_type v33 = v14;
    if (isComplex)
    {
      uint64_t v14 = llvm::TargetRegisterInfo::prependOffsetExpression(v31, v14, 2u, v32);
      goto LABEL_9;
    }
    unsigned int v34 = 0;
LABEL_25:
    uint64_t v14 = llvm::TargetRegisterInfo::prependOffsetExpression(v31, v33, v34, v32);
    goto LABEL_6;
  }
LABEL_18:
  v39[0] = v40;
  v40[0] = 148;
  v40[1] = v26 >> 3;
  v39[1] = (void *)0x200000002;
  __int16 v27 = llvm::DIExpression::prependOpcodes(v14, (unsigned int *)v39, 1, 0);
  uint64_t v14 = llvm::TargetRegisterInfo::prependOffsetExpression(*(void *)(a1 + 16), v27, 4u, v23 + 24 * v20 + 8);
  long long v37 = 0u;
  long long v38 = 0u;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v37);
  if (v39[0] != v40) {
    free(v39[0]);
  }
LABEL_11:
  __int16 v21 = *(llvm::DIVariable **)a3;
  LODWORD(v37) = 14;
  *((void *)&v37 + 1) = 0;
  *(void *)&long long v38 = v21;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v37);
  LODWORD(v37) = 14;
  *((void *)&v37 + 1) = 0;
  *(void *)&long long v38 = v14;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v37);
  if (v36) {
    llvm::MetadataTracking::untrack((uint64_t)&v36, v36);
  }
  return v12;
}

uint64_t sub_1CD591D38(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)(a1 + 88) + 4 * a2);
  unsigned int v3 = *(_DWORD *)(a1 + 236);
  if (v2 >= v3) {
    return *((unsigned __int16 *)sub_1CBA86078(*(void *)(a1 + 800), *(_DWORD *)(a1 + 816), (v2 - v3) % *(_DWORD *)(a1 + 240))+ 2);
  }
  uint64_t v4 = *(void *)(*(void *)a1 + 40);
  uint64_t v5 = *(void *)(a1 + 16);

  return llvm::TargetRegisterInfo::getRegSizeInBits(v5, v2, v4);
}

double LiveDebugValues::InstrRefBasedLDV::InstrRefBasedLDV(LiveDebugValues::InstrRefBasedLDV *this)
{
  *(void *)this = &unk_1F2616098;
  *((void *)this + 7) = (char *)this + 72;
  *((void *)this + sub_1CD521E44((uint64_t)this + 8) = 0x600000000;
  *((_DWORD *)this + 30) = 0;
  double result = 0.0;
  *((_OWORD *)this + sub_1CD521E44((uint64_t)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 1065353216;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_DWORD *)this + 52) = 1065353216;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((_DWORD *)this + 62) = 1065353216;
  *((void *)this + 32) = (char *)this + 272;
  *((void *)this + 33) = 0x400000000;
  *((void *)this + 44) = 0;
  *((_OWORD *)this + 19) = 0u;
  *((_DWORD *)this + 82) = 0;
  *((void *)this + 40) = 0;
  *((unsigned char *)this + 384) = 0;
  *((_OWORD *)this + 23) = 0u;
  *((void *)this + 49) = (char *)this + 424;
  *((void *)this + 50) = (char *)this + 424;
  *((void *)this + 51) = 16;
  *((_DWORD *)this + 104) = 0;
  *((_DWORD *)this + 142) = 0;
  *(_OWORD *)((char *)this + 552) = 0u;
  *((_DWORD *)this + 14sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_OWORD *)this + 36) = 0u;
  *((_DWORD *)this + 154) = 0;
  *(_OWORD *)((char *)this + 600) = 0u;
  *(_OWORD *)((char *)this + 632) = 0u;
  *((void *)this + 7sub_1CD521E44((uint64_t)this + 8) = (char *)this + 632;
  *((void *)this + 81) = (char *)this + 664;
  *((void *)this + 82) = 0x2000000000;
  *((unsigned char *)this + 2016) = 0;
  *(_OWORD *)((char *)this + 1944) = 0u;
  *((_DWORD *)this + 490) = 0;
  *((_DWORD *)this + 496) = 0;
  *((_OWORD *)this + 123) = 0u;
  *((_DWORD *)this + 502) = 0;
  *(_OWORD *)((char *)this + 1992) = 0u;
  *(_OWORD *)((char *)this + 2024) = 0u;
  return result;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::isCalleeSaved(void *a1, unsigned int a2)
{
  unsigned int v3 = *(_DWORD *)(*(void *)(a1[44] + 88) + 4 * a2);
  uint64_t v4 = a1[2];
  if (v4) {
    uint64_t v5 = (void *)(v4 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_1CB8FB608((uint64_t)v8, v3, v5, 1);
  if (!v10) {
    return 0;
  }
LABEL_5:
  while (((*(void *)(a1[7] + (((unint64_t)v11 >> 3) & 0x1FF8)) >> v11) & 1) == 0)
  {
    while (1)
    {
      sub_1CB8FB704((uint64_t)v8);
      if (v9 || v10 == 0) {
        break;
      }
      if (v8[0] != v11) {
        goto LABEL_5;
      }
    }
    if (!v10) {
      return 0;
    }
  }
  return 1;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::extractSpillBaseRegAndOffset(LiveDebugValues::InstrRefBasedLDV *this, const llvm::MachineInstr *a2)
{
  uint64_t v3 = *((void *)a2 + 6);
  if ((v3 & 7) != 0)
  {
    uint64_t v4 = *(void **)((v3 & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  else
  {
    uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
    *((void *)a2 + 6) = v4;
  }
  uint64_t v5 = *(unsigned int *)((*v4 & ((uint64_t)(*v4 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8) + 0x10);
  uint64_t v6 = *((void *)a2 + 3);
  int v14 = 0;
  uint64_t v7 = (*(uint64_t (**)(void, void, uint64_t, int *))(**((void **)this + 5) + 232))(*((void *)this + 5), *(void *)(v6 + 32), v5, &v14);
  uint64_t v8 = *((void *)this + 44);
  int v11 = v14;
  uint64_t v12 = v7;
  uint64_t v13 = v9;
  return LiveDebugValues::MLocTracker::getOrTrackSpillLoc(v8, &v11);
}

uint64_t LiveDebugValues::InstrRefBasedLDV::findLocationForMemOperand(LiveDebugValues::InstrRefBasedLDV *this, const llvm::MachineInstr *a2)
{
  unint64_t SpillBaseRegAndOffset = LiveDebugValues::InstrRefBasedLDV::extractSpillBaseRegAndOffset(this, a2);
  uint64_t v5 = HIDWORD(SpillBaseRegAndOffset);
  if (HIDWORD(SpillBaseRegAndOffset))
  {
    int v9 = SpillBaseRegAndOffset;
    uint64_t v10 = *((void *)a2 + 6);
    if ((v10 & 7) != 0)
    {
      unint64_t v11 = *(void *)((v10 & 0xFFFFFFFFFFFFFFF8) + 8);
    }
    else
    {
      unint64_t v11 = v10 & 0xFFFFFFFFFFFFFFF8;
      *((void *)a2 + 6) = v10 & 0xFFFFFFFFFFFFFFF8;
    }
    uint64_t v13 = *(void *)(v11 + 24);
    uint64_t v12 = (unint64_t *)(v11 + 24);
    if ((v13 & 0xFFFFFFFFFFFFFFF9) != 0)
    {
      v20[0] = sub_1CB8F1DC4(v12);
      v20[1] = v15;
      unsigned __int16 v14 = llvm::TypeSize::operator unsigned long long(v20, v15);
    }
    else
    {
      unsigned __int16 v14 = -1;
    }
    uint64_t v16 = *((void *)this + 44);
    v20[0] = 0;
    if (sub_1CD59B9B0(*(void *)(v16 + 776), *(_DWORD *)(v16 + 792), v14, 0, v20)) {
      uint64_t v17 = v20[0];
    }
    else {
      uint64_t v17 = *(void *)(v16 + 776) + 8 * *(unsigned int *)(v16 + 792);
    }
    uint64_t v18 = *((void *)this + 44);
    if (v17 != *(void *)(v18 + 776) + 8 * *(unsigned int *)(v18 + 792))
    {
      int v19 = *(_DWORD *)(*(void *)(v18 + 64)
                      + 4
                      * (*(_DWORD *)(v17 + 4) + *(_DWORD *)(v18 + 240) * (v9 - 1) + *(_DWORD *)(v18 + 236)));
      unsigned int v7 = v19 & 0xFFFFFF00;
      int v6 = v19;
      uint64_t v5 = 0x100000000;
      return v5 | v7 | v6;
    }
    uint64_t v5 = 0;
  }
  int v6 = 0;
  unsigned int v7 = 0;
  return v5 | v7 | v6;
}

uint64_t sub_1CD59213C(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, char a5)
{
  int v10 = **(unsigned __int16 **)(a2 + 16);
  BOOL v11 = v10 == 14;
  uint64_t v12 = *(void *)(a2 + 32);
  uint64_t v13 = *(void *)(v12 + ((unint64_t)(v10 != 14) << 6) + 16);
  uint64_t v14 = 96;
  if (v11) {
    uint64_t v14 = 32;
  }
  uint64_t v15 = *(void *)(v12 + v14 + 16);
  uint64_t v16 = *(void *)(a2 + 56);
  if (*(_DWORD *)(v16 + 8) == 2) {
    uint64_t v17 = *(void *)(v16 - 8);
  }
  else {
    uint64_t v17 = 0;
  }
  *(void *)&long long v34 = v13;
  if (v15)
  {
    llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v15 + 24), *(uint64_t **)(v15 + 32), (int8x16_t *)((char *)&v34 + 8));
  }
  else
  {
    BYTE8(v34) = 0;
    BYTE8(v35) = 0;
  }
  uint64_t v36 = v17;
  BOOL v11 = a5 == 0;
  BOOL v18 = a5 != 0;
  if (v11) {
    a4 = LiveDebugValues::ValueIDNum::EmptyValue;
  }
  *(_OWORD *)&uint64_t v33[4] = *a3;
  v25[0] = v34;
  v25[1] = v35;
  uint64_t v26 = v17;
  *(void *)&long long v27 = a4;
  BYTE8(v27) = 0;
  char v28 = 0;
  int v29 = 0;
  long long v30 = *(_OWORD *)v33;
  int v31 = *(_DWORD *)&v33[16];
  BOOL v32 = v18;
  uint64_t v19 = sub_1CD59A644((void *)a1, (uint64_t)v25, &v27);
  if (!v20)
  {
    *(void *)(v19 + 40) = a4;
    *(unsigned char *)(v19 + 4sub_1CD521E44((uint64_t)this + 8) = 0;
    *(unsigned char *)(v19 + 80) = 0;
    *(_DWORD *)(v19 + 8sub_1CD521E44((uint64_t)this + 8) = 0;
    *(_OWORD *)(v19 + 92) = *(_OWORD *)v33;
    *(_DWORD *)(v19 + 10sub_1CD521E44((uint64_t)this + 8) = *(_DWORD *)&v33[16];
    *(_DWORD *)(v19 + 112) = v18;
  }
  uint64_t v21 = *(void *)(a2 + 56);
  *(void *)(sub_1CD59DE68((_DWORD *)(a1 + 48), (uint64_t)&v34) + 40) = v21;
  return sub_1CD59A45C(a1, (uint64_t)&v34, *(void *)(a2 + 56), v22, v23);
}

uint64_t sub_1CD5922AC(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  int v7 = **(unsigned __int16 **)(a2 + 16);
  BOOL v8 = v7 == 14;
  uint64_t v9 = *(void *)(a2 + 32);
  uint64_t v10 = *(void *)(v9 + ((unint64_t)(v7 != 14) << 6) + 16);
  uint64_t v11 = 96;
  if (v8) {
    uint64_t v11 = 32;
  }
  uint64_t v12 = *(void *)(v9 + v11 + 16);
  uint64_t v13 = *(void *)(a2 + 56);
  if (*(_DWORD *)(v13 + 8) == 2) {
    uint64_t v14 = *(void *)(v13 - 8);
  }
  else {
    uint64_t v14 = 0;
  }
  *(void *)&long long v37 = v10;
  if (v12)
  {
    llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v12 + 24), *(uint64_t **)(v12 + 32), (int8x16_t *)((char *)&v37 + 8));
  }
  else
  {
    BYTE8(v37) = 0;
    BYTE8(v3sub_1CD521E44((uint64_t)this + 8) = 0;
  }
  uint64_t v39 = v14;
  sub_1CD59A7B8(a1 + 2496, (uint64_t *)&v37);
  *(void *)&v32[0] = 0;
  uint64_t result = sub_1CC4E4420(*(void *)(a1 + 2400), *(_DWORD *)(a1 + 2416), (uint64_t *)&v37, (uint64_t *)v32);
  uint64_t v16 = *(unsigned int *)(a1 + 2416);
  if (result) {
    uint64_t v17 = *(void *)&v32[0];
  }
  else {
    uint64_t v17 = *(void *)(a1 + 2400) + (v16 << 6);
  }
  if (v17 != *(void *)(a1 + 2400) + (v16 << 6))
  {
    BOOL v18 = sub_1CD59A81C(a1 + 2376, (int *)(v17 + 40));
    uint64_t result = sub_1CC4E4348((uint64_t)(v18 + 2), (unint64_t *)&v37);
  }
  if ((a4 & 0xFF00000000) != 0)
  {
    unsigned int v36 = a4;
    if (*(void *)(*(void *)(*(void *)(a1 + 16) + 32) + 8 * a4) != *(void *)(*(void *)(a1 + 2104) + 8 * a4))
    {
      uint64_t v19 = sub_1CD59A81C(a1 + 2376, (int *)&v36);
      uint64_t v20 = *((void *)v19 + 25);
      if (v20) {
        uint64_t v21 = (uint64_t *)*((void *)v19 + 23);
      }
      else {
        uint64_t v21 = (uint64_t *)*((void *)v19 + 1);
      }
      uint64_t v22 = *((void *)v19 + 1) + 40 * v19[4];
      int8x16_t v23 = (uint64_t *)(v19 + 48);
      while (1)
      {
        while (!v20)
        {
          if (v21 == (uint64_t *)v22) {
            goto LABEL_30;
          }
          sub_1CD59A748(a1 + 2400, v21);
          v21 += 5;
        }
        if (v21 == v23) {
          break;
        }
        sub_1CD59A748(a1 + 2400, v21 + 4);
        int v24 = (uint64_t *)v21[1];
        unsigned int v25 = v21;
        if (v24)
        {
          do
          {
            uint64_t v21 = v24;
            int v24 = (uint64_t *)*v24;
          }
          while (v24);
        }
        else
        {
          do
          {
            uint64_t v21 = (uint64_t *)v25[2];
            BOOL v8 = *v21 == (void)v25;
            unsigned int v25 = v21;
          }
          while (!v8);
        }
      }
LABEL_30:
      uint64_t v26 = v36;
      LODWORD(v32[0]) = v36;
      long long v27 = sub_1CD59A81C(a1 + 2376, (int *)v32);
      a4 = (unint64_t)(v27 + 48);
      char v28 = (void *)*((void *)v27 + 24);
      uint64_t v27[4] = 0;
      sub_1CD3C5048((uint64_t)(v27 + 46), v28);
      *(void *)(a4 - sub_1CD521E44((uint64_t)this + 8) = a4;
      *(void *)a4 = 0;
      *(void *)(a4 + sub_1CD521E44((uint64_t)this + 8) = 0;
      *(void *)(*(void *)(a1 + 2104) + 8 * v26) = *(void *)(*(void *)(*(void *)(a1 + 16) + 32) + 8 * v26);
      LODWORD(a4) = v26;
    }
    int v29 = sub_1CD59A81C(a1 + 2376, (int *)&v36);
    uint64_t result = sub_1CD598850((uint64_t)(v29 + 2), (unint64_t *)&v37);
    if (v17 == *(void *)(a1 + 2400) + ((unint64_t)*(unsigned int *)(a1 + 2416) << 6))
    {
      *(void *)&v40[4] = *a3;
      v40[12] = *((unsigned char *)a3 + 8);
      v32[0] = v37;
      v32[1] = v38;
      uint64_t v33 = v39;
      int v34 = a4;
      v35[0] = *(void *)v40;
      *(void *)((char *)v35 + 5) = *(void *)&v40[5];
      return sub_1CD59ADF0((uint64_t)v31, a1 + 2400, (uint64_t)v32, (long long *)&v34);
    }
    else
    {
      *(_DWORD *)(v17 + 40) = a4;
      uint64_t v30 = *a3;
      *(unsigned char *)(v17 + 56) = *((unsigned char *)a3 + 8);
      *(void *)(v17 + 4sub_1CD521E44((uint64_t)this + 8) = v30;
    }
  }
  return result;
}

llvm::MachineInstr *sub_1CD5925AC(llvm::MachineInstr *result, uint64_t *a2, uint64_t a3, void *a4)
{
  if (*((unsigned char *)result + 32))
  {
    if (*(_WORD *)(*a2 + 32)
      && a2[4] == 0
      && ((*(void *)(*(void *)a3 + 32) - *(void *)(*(void *)a3 + 24)) & 0x7FFFFFFF8) == 0)
    {
      BOOL v8 = result;
      uint64_t result = (llvm::MachineInstr *)sub_1CD59B034((uint64_t)result, a4);
      if (result)
      {
        uint64_t v9 = llvm::DIExpression::prepend(*(llvm::DIExpression **)a3, (const llvm::DIExpression *)8, 0);
        int v10 = *(_DWORD *)(*(void *)(*((void *)v8 + 2) + 88) + ((*a4 >> 38) & 0x3FFFFFCLL));
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        v14[0] = 0;
        v14[1] = v10;
        uint64_t v17 = 0;
        LOBYTE(v10) = *(unsigned char *)(a3 + 8);
        uint64_t v12 = v9;
        char v13 = v10;
        uint64_t result = sub_1CD59B0F4((llvm::MachineFunction **)v8, (const llvm::MachineOperand *)v14, a2, (uint64_t *)&v12);
        unsigned int v11 = *((_DWORD *)v8 + 608);
        if (v11 >= *((_DWORD *)v8 + 609)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*((void *)v8 + 303) + 8 * v11) = result;
        ++*((_DWORD *)v8 + 608);
      }
    }
  }
  return result;
}

uint64_t sub_1CD5926C4(uint64_t a1, uint64_t a2, long long *a3)
{
  int v6 = **(unsigned __int16 **)(a2 + 16);
  BOOL v7 = v6 == 14;
  uint64_t v8 = *(void *)(a2 + 32);
  uint64_t v9 = *(void *)(v8 + ((unint64_t)(v6 != 14) << 6) + 16);
  uint64_t v10 = 96;
  if (v7) {
    uint64_t v10 = 32;
  }
  uint64_t v11 = *(void *)(v8 + v10 + 16);
  uint64_t v12 = *(void *)(a2 + 56);
  if (*(_DWORD *)(v12 + 8) == 2) {
    uint64_t v13 = *(void *)(v12 - 8);
  }
  else {
    uint64_t v13 = 0;
  }
  *(void *)&long long v37 = v9;
  if (v11)
  {
    llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v11 + 24), *(uint64_t **)(v11 + 32), (int8x16_t *)((char *)&v37 + 8));
  }
  else
  {
    BYTE8(v37) = 0;
    BYTE8(v3sub_1CD521E44((uint64_t)this + 8) = 0;
  }
  uint64_t v39 = v13;
  BOOL v14 = *(unsigned char *)(v8 + 32) == 1;
  uint64_t v15 = LiveDebugValues::ValueIDNum::EmptyValue;
  long long v16 = a3[1];
  long long v35 = *a3;
  long long v36 = v16;
  v25[0] = v37;
  v25[1] = v38;
  uint64_t v26 = v13;
  uint64_t v27 = LiveDebugValues::ValueIDNum::EmptyValue;
  long long v17 = a3[1];
  long long v28 = *a3;
  long long v29 = v17;
  char v30 = 1;
  int v31 = 0;
  uint64_t v32 = v11;
  BOOL v33 = v14;
  int v34 = 2;
  uint64_t v18 = sub_1CD59A644((void *)a1, (uint64_t)v25, (long long *)&v27);
  if (!v19)
  {
    *(void *)(v18 + 40) = v15;
    long long v20 = v36;
    *(_OWORD *)(v18 + 4sub_1CD521E44((uint64_t)this + 8) = v35;
    *(_OWORD *)(v18 + 64) = v20;
    *(unsigned char *)(v18 + 80) = 1;
    *(_DWORD *)(v18 + 8sub_1CD521E44((uint64_t)this + 8) = 0;
    *(void *)(v18 + 96) = v11;
    *(unsigned char *)(v18 + 104) = v14;
    *(_DWORD *)(v18 + 112) = 2;
  }
  uint64_t v21 = *(void *)(a2 + 56);
  *(void *)(sub_1CD59DE68((_DWORD *)(a1 + 48), (uint64_t)&v37) + 40) = v21;
  return sub_1CD59A45C(a1, (uint64_t)&v37, *(void *)(a2 + 56), v22, v23);
}

void sub_1CD592834(uint64_t a1, uint64_t a2)
{
  int v4 = **(unsigned __int16 **)(a2 + 16);
  BOOL v5 = v4 == 14;
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v7 = *(void *)(v6 + ((unint64_t)(v4 != 14) << 6) + 16);
  uint64_t v8 = 96;
  if (v5) {
    uint64_t v8 = 32;
  }
  uint64_t v9 = *(void *)(v6 + v8 + 16);
  uint64_t v10 = *(void *)(a2 + 56);
  if (*(_DWORD *)(v10 + 8) == 2) {
    uint64_t v11 = *(void *)(v10 - 8);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v17 = v7;
  if (v9)
  {
    llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v9 + 24), *(uint64_t **)(v9 + 32), &v18);
  }
  else
  {
    v18.i8[0] = 0;
    char v19 = 0;
  }
  uint64_t v20 = v11;
  uint64_t v15 = v9;
  BOOL v16 = *(unsigned char *)(v6 + 32) == 1;
  if (!*(unsigned char *)v6 && (uint64_t v12 = *(unsigned int *)(v6 + 4), v12))
  {
    sub_1CD5922AC(a1, a2, &v15, *(unsigned int *)(*(void *)(*(void *)(a1 + 16) + 64) + 4 * v12) | 0x100000000);
  }
  else
  {
    uint64_t v21 = 0;
    if (sub_1CC4E4420(*(void *)(a1 + 2400), *(_DWORD *)(a1 + 2416), &v17, &v21))
    {
      uint64_t v13 = v21;
      if (v21 != *(void *)(a1 + 2400) + ((unint64_t)*(unsigned int *)(a1 + 2416) << 6))
      {
        BOOL v14 = sub_1CD59A81C(a1 + 2376, (int *)(v21 + 40));
        sub_1CC4E4348((uint64_t)(v14 + 2), (unint64_t *)&v17);
        *(void *)(v13 + sub_1CD521E44((uint64_t)this + 8) = 0;
        *(void *)(v13 + 16) = 0;
        *(void *)uint64_t v13 = 0;
        *(unsigned char *)(v13 + 24) = 1;
        *(void *)(v13 + 32) = 0;
        *(int32x2_t *)(a1 + 240sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(a1 + 2408), (int32x2_t)0x1FFFFFFFFLL);
      }
    }
    sub_1CD59A7B8(a1 + 2496, &v17);
  }
}

uint64_t sub_1CD5929AC(uint64_t a1, uint64_t a2, uint64_t *a3, unint64_t a4)
{
  long long v6 = *(_OWORD *)(a2 + 16);
  long long v16 = *(_OWORD *)a2;
  unint64_t v15 = a4;
  long long v17 = v6;
  uint64_t v7 = *a3;
  uint64_t v18 = *(void *)(a2 + 32);
  uint64_t v19 = v7;
  char v20 = *((unsigned char *)a3 + 8);
  v21[0] = (a4 >> 20) & 0xFFFFF;
  uint64_t v8 = sub_1CD59B230(a1 + 2472, v21);
  uint64_t v9 = (long long *)sub_1CD59B6E8((uint64_t)(v8 + 2), (unint64_t)&v15);
  uint64_t v10 = (_OWORD *)(*((void *)v8 + 1) + ((unint64_t)v8[4] << 6));
  long long v11 = *v9;
  long long v12 = v9[1];
  long long v13 = v9[3];
  void v10[2] = v9[2];
  _OWORD v10[3] = v13;
  _OWORD *v10 = v11;
  v10[1] = v12;
  ++v8[4];
  return sub_1CC3A0178(a1 + 2496, a2, (uint64_t)v21);
}

void sub_1CD592A64(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _DWORD v8[4] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 2432))
  {
    unint64_t v3 = a2;
    if (!a3 || (unint64_t v5 = *(void *)(a3 + 56), v5 != a2))
    {
      while ((*(_WORD *)(v3 + 44) & 4) != 0)
        unint64_t v3 = *(void *)v3 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v5 = v3;
    }
    v6[0] = v5;
    v6[1] = a3;
    v7[0] = v8;
    v7[1] = (void *)0x400000000;
    sub_1CBB08064((uint64_t)v7, a1 + 2424);
    sub_1CD59B760((unint64_t *)(a1 + 40), (unint64_t)v6);
    if (v7[0] != v8) {
      free(v7[0]);
    }
    *(_DWORD *)(a1 + 2432) = 0;
  }
}

BOOL LiveDebugValues::InstrRefBasedLDV::transferDebugPHI(LiveDebugValues::InstrRefBasedLDV *this, llvm::MachineInstr *a2)
{
  int v2 = **((unsigned __int16 **)a2 + 2);
  if (v2 == 16 && !*((void *)this + 46) && !*((void *)this + 47))
  {
    uint64_t v6 = *((void *)a2 + 4);
    uint64_t v7 = *(void *)(v6 + 48);
    uint64_t v8 = v7;
    v59[0] = (uint64_t)this;
    v59[1] = (uint64_t)a2;
    int v60 = v7;
    if (*(unsigned char *)v6 == 5)
    {
      if (*(void *)(*(void *)(*((void *)this + 6) + 8)
                     + 40 * (*(_DWORD *)(*((void *)this + 6) + 32) + *(_DWORD *)(v6 + 16))
                     + 8) != -1)
      {
        LODWORD(v55[0]) = 0;
        uint64_t v16 = (*(uint64_t (**)(void, void))(**((void **)this + 5) + 232))(*((void *)this + 5), *(void *)(*((void *)a2 + 3) + 32));
        uint64_t v17 = *((void *)this + 44);
        int v46 = v55[0];
        uint64_t v47 = v16;
        uint64_t v48 = v18;
        unint64_t v19 = LiveDebugValues::MLocTracker::getOrTrackSpillLoc(v17, &v46);
        if (HIDWORD(v19))
        {
          uint64_t v20 = *((void *)this + 44);
          LODWORD(v49) = *(unsigned __int16 *)(*((void *)a2 + 4) + 80);
          int v21 = v19 - 1;
          int v22 = *(_DWORD *)(v20 + 240);
          int8x16_t v23 = sub_1CD59B940(v20 + 776, (unsigned __int16 *)&v49);
          uint64_t v24 = *((void *)this + 44);
          uint64_t v25 = *(unsigned int *)(*(void *)(v24 + 64)
                                + 4 * (*((_DWORD *)v23 + 1) + v22 * v21 + *(_DWORD *)(v20 + 236)));
          uint64_t v26 = *(void *)(*(void *)(v24 + 32) + 8 * v25);
          uint64_t v27 = *((void *)a2 + 3);
          uint64_t v49 = v8;
          uint64_t v50 = v27;
          uint64_t v51 = v26;
          char v52 = 1;
          LODWORD(v53) = v25;
          BYTE4(v53) = 1;
          uint64_t v10 = (char *)this + 648;
          goto LABEL_11;
        }
      }
      sub_1CC4E0EBC(v59);
    }
    else
    {
      if (*(unsigned char *)v6 || (uint64_t v9 = *(unsigned int *)(v6 + 4), !v9))
      {
        uint64_t v10 = (char *)this + 648;
        uint64_t v11 = *((void *)a2 + 3);
        uint64_t v49 = v8;
        uint64_t v50 = v11;
        LOBYTE(v51) = 0;
        char v52 = 0;
        LOBYTE(v53) = 0;
        BYTE4(v53) = 0;
LABEL_11:
        unint64_t v12 = sub_1CC47EC6C((uint64_t)v10, (unint64_t)&v49);
        uint64_t v13 = *((void *)this + 81) + 40 * *((unsigned int *)this + 164);
        uint64_t v14 = *(void *)(v12 + 32);
        long long v15 = *(_OWORD *)(v12 + 16);
        *(_OWORD *)uint64_t v13 = *(_OWORD *)v12;
        *(_OWORD *)(v13 + 16) = v15;
        *(void *)(v13 + 32) = v14;
        ++*((_DWORD *)this + 164);
        return v2 == 16;
      }
      uint64_t v28 = *((void *)this + 44);
      uint64_t v29 = *(void *)(v28 + 64);
      int v30 = *(_DWORD *)(v29 + 4 * v9);
      if (v30 == -1)
      {
        unsigned int v31 = LiveDebugValues::MLocTracker::trackRegister(*((LiveDebugValues::MLocTracker **)this + 44), *(_DWORD *)(v6 + 4));
        *(_DWORD *)(v29 + 4 * v9) = v31;
        uint64_t v32 = (LiveDebugValues::MLocTracker *)*((void *)this + 44);
        uint64_t v29 = *((void *)v32 + 8);
        int v30 = *(_DWORD *)(v29 + 4 * v9);
      }
      else
      {
        uint64_t v32 = (LiveDebugValues::MLocTracker *)*((void *)this + 44);
        unsigned int v31 = *(_DWORD *)(v29 + 4 * v9);
      }
      uint64_t v33 = *(void *)(*(void *)(v28 + 32) + 8 * v31);
      uint64_t v34 = *((void *)a2 + 3);
      v55[0] = v8;
      v55[1] = v34;
      v55[2] = v33;
      char v56 = 1;
      if (v30 == -1)
      {
        int v30 = LiveDebugValues::MLocTracker::trackRegister(v32, v9);
        *(_DWORD *)(v29 + 4 * v9) = v30;
      }
      int v57 = v30;
      char v58 = 1;
      unint64_t v35 = sub_1CC47EC6C((uint64_t)this + 648, (unint64_t)v55);
      uint64_t v36 = *((void *)this + 81) + 40 * *((unsigned int *)this + 164);
      uint64_t v37 = *(void *)(v35 + 32);
      long long v38 = *(_OWORD *)(v35 + 16);
      *(_OWORD *)uint64_t v36 = *(_OWORD *)v35;
      *(_OWORD *)(v36 + 16) = v38;
      *(void *)(v36 + 32) = v37;
      ++*((_DWORD *)this + 164);
      uint64_t v39 = *((void *)this + 2);
      if (v39) {
        char v40 = (void *)(v39 + 8);
      }
      else {
        char v40 = 0;
      }
      sub_1CB8FB608((uint64_t)&v49, *(_DWORD *)(v6 + 4), v40, 1);
      uint64_t v41 = v53;
      while (v41)
      {
LABEL_24:
        uint64_t v42 = (LiveDebugValues::MLocTracker *)*((void *)this + 44);
        uint64_t v43 = (unsigned __int16)v54;
        uint64_t v44 = *((void *)v42 + 8);
        if (*(_DWORD *)(v44 + 4 * (unsigned __int16)v54) == -1) {
          *(_DWORD *)(v44 + 4 * v43) = LiveDebugValues::MLocTracker::trackRegister(v42, (unsigned __int16)v54);
        }
        while (1)
        {
          sub_1CB8FB704((uint64_t)&v49);
          uint64_t v41 = v53;
          if ((_BYTE)v51 || v53 == 0) {
            break;
          }
          if (v49 != (unsigned __int16)v54) {
            goto LABEL_24;
          }
        }
      }
    }
  }
  return v2 == 16;
}

void LiveDebugValues::InstrRefBasedLDV::transferRegisterDef(LiveDebugValues::InstrRefBasedLDV *this, llvm::MachineInstr *a2)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a2 + 2);
  if (*(_WORD *)v4 == 10)
  {
    uint64_t v5 = *((void *)this + 44);
    uint64_t v6 = *((void *)a2 + 4);
    uint64_t v7 = *(unsigned int *)(v6 + 4);
    uint64_t v8 = *(void *)(v5 + 64);
    unsigned int v9 = *(_DWORD *)(v8 + 4 * v7);
    if (v9 == -1)
    {
      unsigned int v9 = LiveDebugValues::MLocTracker::trackRegister(*((LiveDebugValues::MLocTracker **)this + 44), *(_DWORD *)(v6 + 4));
      *(_DWORD *)(v8 + 4 * v7) = v9;
    }
    if (*(void *)(*(void *)(v5 + 32) + 8 * v9) >> 40) {
      return;
    }
  }
  else if ((*(unsigned char *)(v4 + 8) & 0x10) != 0)
  {
    return;
  }
  char v10 = *((unsigned char *)this + 2016);
  if (!v10) {
    goto LABEL_9;
  }
  uint64_t v16 = *(void *)(*((void *)a2 + 2) + 8);
  BOOL v17 = (*((_WORD *)a2 + 22) & 0xC) != 0 && (*((_WORD *)a2 + 22) & 4) == 0;
  if (v17)
  {
    if ((v16 & 0x80) == 0)
    {
      uint64_t v41 = a2;
      while ((*((_WORD *)v41 + 22) & 8) != 0)
      {
        uint64_t v41 = (llvm::MachineInstr *)*((void *)v41 + 1);
        if ((*(unsigned char *)(*((void *)v41 + 2) + 8) & 0x80) != 0) {
          goto LABEL_16;
        }
      }
      goto LABEL_76;
    }
  }
  else if ((v16 & 0x80) == 0)
  {
LABEL_76:
    char v10 = 0;
    goto LABEL_9;
  }
LABEL_16:
  uint64_t v18 = *((void *)a2 + 4);
  if (*(unsigned char *)v18 != 9) {
    goto LABEL_76;
  }
  char v10 = strcmp(*(const char **)(v18 + 16), *((const char **)this + 253)) == 0;
LABEL_9:
  v77[0] = this;
  v77[1] = a2;
  char v78 = v10;
  __int16 v85 = v87;
  uint64_t v86 = 0x2000000000;
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  uint64_t v88 = &v89;
  unsigned int v82 = v84;
  uint64_t v83 = 0x400000000;
  uint64_t v71 = a2;
  uint64_t v79 = v81;
  uint64_t v80 = 0x400000000;
  uint64_t v11 = *((unsigned int *)a2 + 10);
  if (v11)
  {
    unint64_t v19 = (int *)*((void *)a2 + 4);
    uint64_t v20 = &v19[8 * v11];
    do
    {
      int v21 = *v19;
      if ((*v19 & 0x10000FF) == 0x1000000
        && (unsigned int v22 = v19[1], v22 - 1 <= 0x3FFFFFFE)
        && !sub_1CC4E0F3C((uint64_t)v77, v19[1]))
      {
        uint64_t v23 = *((void *)this + 2);
        if (v23) {
          uint64_t v24 = (void *)(v23 + 8);
        }
        else {
          uint64_t v24 = 0;
        }
        sub_1CB8FB608((uint64_t)v73, v22, v24, 1);
        uint64_t v25 = v75;
        while (v25)
        {
LABEL_33:
          unsigned int v72 = v76;
          sub_1CB946958((uint64_t)&v85, &v72);
          while (1)
          {
            sub_1CB8FB704((uint64_t)v73);
            uint64_t v25 = v75;
            if (v74 || v75 == 0) {
              break;
            }
            if (v73[0] != v76) {
              goto LABEL_33;
            }
          }
        }
      }
      else if (v21 == 12)
      {
        if (v83 >= (unint64_t)HIDWORD(v83)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v82[v83] = *((void *)v19 + 2);
        LODWORD(v83) = v83 + 1;
        if (v80 >= (unint64_t)HIDWORD(v80)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v79 + v80) = v19;
        LODWORD(v80) = v80 + 1;
      }
      v19 += 8;
    }
    while (v19 != v20);
    long long v15 = v85;
    uint64_t v14 = v88;
    uint64_t v12 = v86;
    BOOL v13 = v90 == 0;
  }
  else
  {
    uint64_t v12 = 0;
    BOOL v13 = 1;
    uint64_t v14 = &v89;
    long long v15 = v87;
  }
  if (v13) {
    uint64_t v27 = v15;
  }
  else {
    uint64_t v27 = v14;
  }
  uint64_t v28 = &v15[4 * v12];
  while (v13)
  {
    if (v27 == (void *)v28) {
      goto LABEL_60;
    }
LABEL_48:
    uint64_t v29 = (unsigned int *)v27 + 7;
    if (v13) {
      uint64_t v29 = (unsigned int *)v27;
    }
    uint64_t v30 = *v29;
    uint64_t v31 = *((void *)this + 44);
    int v32 = *((_DWORD *)this + 90);
    int v33 = *((_DWORD *)this + 91);
    uint64_t v34 = *(void *)(v31 + 64);
    unsigned int v35 = *(_DWORD *)(v34 + 4 * v30);
    if (v35 == -1)
    {
      unsigned int v35 = LiveDebugValues::MLocTracker::trackRegister(*((LiveDebugValues::MLocTracker **)this + 44), *v29);
      *(_DWORD *)(v34 + 4 * v30) = v35;
    }
    *(void *)(*(void *)(v31 + 32) + 8 * v35) = *(void *)&v32 & 0xFFFFFLL | ((*(void *)&v33 & 0xFFFFFLL) << 20) | ((unint64_t)v35 << 40);
    if (v13)
    {
      uint64_t v27 = (void *)((char *)v27 + 4);
    }
    else
    {
      uint64_t v36 = (void *)v27[1];
      uint64_t v37 = v27;
      if (v36)
      {
        do
        {
          uint64_t v27 = v36;
          uint64_t v36 = (void *)*v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v37[2];
          BOOL v17 = *v27 == (void)v37;
          uint64_t v37 = v27;
        }
        while (!v17);
      }
    }
  }
  if (v27 != &v89) {
    goto LABEL_48;
  }
LABEL_60:
  if (v80)
  {
    long long v38 = (const llvm::MachineOperand **)v79;
    uint64_t v39 = 8 * v80;
    do
    {
      char v40 = *v38++;
      LiveDebugValues::MLocTracker::writeRegMask(*((void *)this + 44), v40, *((_DWORD *)this + 90), *((_DWORD *)this + 91));
      v39 -= 8;
    }
    while (v39);
  }
  if (sub_1CD593558((uint64_t)this, (uint64_t)v71))
  {
    unint64_t SpillBaseRegAndOffset = LiveDebugValues::InstrRefBasedLDV::extractSpillBaseRegAndOffset(this, v71);
    if (HIDWORD(SpillBaseRegAndOffset))
    {
      uint64_t v43 = *((void *)this + 44);
      unsigned int v44 = *(_DWORD *)(v43 + 240);
      if (v44)
      {
        for (unsigned int i = 0; i < v44; ++i)
        {
          uint64_t v46 = *(unsigned int *)(*(void *)(v43 + 64)
                                + 4 * (i + *(_DWORD *)(v43 + 236) + v44 * (SpillBaseRegAndOffset - 1)));
          *(void *)(*(void *)(v43 + 32) + 8 * v46) = *((_DWORD *)this + 90) & 0xFFFFFLL | ((*((_DWORD *)this + 91) & 0xFFFFFLL) << 20) | (v46 << 40);
          uint64_t v43 = *((void *)this + 44);
          unsigned int v44 = *(_DWORD *)(v43 + 240);
        }
      }
    }
  }
  if (*((void *)this + 47))
  {
    uint64_t v47 = v90;
    if (v90) {
      uint64_t v48 = (char *)v88;
    }
    else {
      uint64_t v48 = v85;
    }
    uint64_t v49 = &v85[4 * v86];
    while (1)
    {
      if (v47)
      {
        if (v48 == (char *)&v89)
        {
LABEL_102:
          if (v80)
          {
            int v57 = *(_DWORD *)(*((void *)this + 44) + 40);
            if (v57)
            {
              uint64_t v63 = 0;
              do
              {
                uint64_t v64 = *((void *)this + 44);
                unint64_t v65 = *(unsigned int *)(*(void *)(v64 + 88) + 4 * v63);
                if (v65 < *(_DWORD *)(v64 + 236) && !sub_1CC4E0F3C((uint64_t)v77, v65) && v80)
                {
                  int v67 = (char *)v79;
                  unint64_t v68 = v65 >> 5;
                  int v69 = 1 << v65;
                  uint64_t v70 = 8 * v80;
                  do
                  {
                    if ((*(_DWORD *)(*(void *)(*(void *)v67 + 16) + 4 * v68) & v69) == 0) {
                      sub_1CD593628(*((void *)this + 47), v63, (unint64_t)v71, 0);
                    }
                    v67 += 8;
                    v70 -= 8;
                  }
                  while (v70);
                }
                int v66 = v63 + 1;
                uint64_t v63 = (v63 + 1);
              }
              while (v57 != v66);
            }
          }
          if (sub_1CD593558((uint64_t)this, (uint64_t)v71))
          {
            unint64_t v58 = LiveDebugValues::InstrRefBasedLDV::extractSpillBaseRegAndOffset(this, v71);
            if (HIDWORD(v58))
            {
              uint64_t v59 = *((void *)this + 44);
              unsigned int v60 = *(_DWORD *)(v59 + 240);
              if (v60)
              {
                unsigned int v61 = 0;
                int v62 = v58 - 1;
                do
                {
                  sub_1CD593628(*((void *)this + 47), *(_DWORD *)(*(void *)(v59 + 64) + 4 * (v61 + *(_DWORD *)(v59 + 236) + v60 * v62)), (unint64_t)v71, 1);
                  ++v61;
                  uint64_t v59 = *((void *)this + 44);
                  unsigned int v60 = *(_DWORD *)(v59 + 240);
                }
                while (v61 < v60);
              }
            }
          }
          break;
        }
      }
      else if (v48 == v49)
      {
        goto LABEL_102;
      }
      uint64_t v50 = v48 + 28;
      if (!v47) {
        uint64_t v50 = v48;
      }
      uint64_t v51 = *(unsigned int *)v50;
      char v52 = (LiveDebugValues::MLocTracker *)*((void *)this + 44);
      uint64_t v53 = *((void *)v52 + 8);
      unsigned int v54 = *(_DWORD *)(v53 + 4 * v51);
      if (v54 == -1)
      {
        unsigned int v54 = LiveDebugValues::MLocTracker::trackRegister(v52, v51);
        *(_DWORD *)(v53 + 4 * v51) = v54;
      }
      sub_1CD593628(*((void *)this + 47), v54, (unint64_t)v71, 0);
      if (v47)
      {
        char v55 = (char *)*((void *)v48 + 1);
        char v56 = v48;
        if (v55)
        {
          do
          {
            uint64_t v48 = v55;
            char v55 = *(char **)v55;
          }
          while (v55);
        }
        else
        {
          do
          {
            uint64_t v48 = (char *)*((void *)v56 + 2);
            BOOL v17 = *(void *)v48 == (void)v56;
            char v56 = v48;
          }
          while (!v17);
        }
      }
      else
      {
        v48 += 4;
      }
    }
  }
  if (v79 != v81) {
    free(v79);
  }
  if (v82 != (void *)v84) {
    free(v82);
  }
  sub_1CB833A08((uint64_t)&v88, v89);
  if (v85 != v87) {
    free(v85);
  }
}

uint64_t sub_1CD593558(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a2 + 48);
  if (v2 < 8) {
    return 0;
  }
  if ((v2 & 7) != 0)
  {
    unint64_t v3 = (_DWORD *)(v2 & 0xFFFFFFFFFFFFFFF8);
    BOOL v4 = (*(void *)(a2 + 48) & 7) != 3 || v3 == 0;
    if (v4 || *v3 != 1) {
      return 0;
    }
  }
  else
  {
    v2 &= 0xFFFFFFFFFFFFFFF8;
    *(void *)(a2 + 4sub_1CD521E44((uint64_t)this + 8) = v2;
  }
  if ((v2 & 7) != 0)
  {
    unint64_t v5 = *(void *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  else
  {
    unint64_t v5 = v2 & 0xFFFFFFFFFFFFFFF8;
    *(void *)(a2 + 4sub_1CD521E44((uint64_t)this + 8) = v2 & 0xFFFFFFFFFFFFFFF8;
  }
  if ((*(_WORD *)(v5 + 32) & 2) == 0) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v8 = *(void *)v5;
  if ((v8 & 4) != 0)
  {
    unsigned int v9 = (_DWORD *)(v8 & 0xFFFFFFFFFFFFFFF8);
    if (v9)
    {
      if (v9[2] == 4) {
        return (*(unsigned int (**)(_DWORD *, void))(*(void *)v9 + 32))(v9, *(void *)(a1 + 48)) ^ 1;
      }
      return 0;
    }
  }
  return v6;
}

void sub_1CD593628(uint64_t a1, unsigned int a2, unint64_t a3, char a4)
{
  uint64_t v8 = *(void *)(a1 + 2376);
  unsigned int v9 = *(_DWORD *)(a1 + 2392);
  char v10 = sub_1CD59BD20(v8, v9, a2);
  if ((int *)(v8 + 208 * v9) != v10)
  {
    BOOL v11 = 0;
    uint64_t v12 = *(void *)(a1 + 2104);
    uint64_t v13 = *(void *)(v12 + 8 * a2);
    uint64_t v58 = v13;
    *(void *)(v12 + 8 * a2) = LiveDebugValues::ValueIDNum::EmptyValue;
    LOBYTE(v57) = 0;
    BYTE4(v57) = 0;
    uint64_t v14 = *(void *)(a1 + 16);
    int v15 = *(_DWORD *)(v14 + 40);
    if (v15)
    {
      char v16 = 0;
      int v17 = 0;
      uint64_t v18 = 0;
      char v19 = 0;
      uint64_t v20 = *(void *)(v14 + 32);
      int v21 = v57;
      do
      {
        uint64_t v22 = *(void *)(v20 + 8 * v18);
        if (v19) {
          BOOL v23 = 0;
        }
        else {
          BOOL v23 = v22 == v13;
        }
        if (v23) {
          char v16 = 1;
        }
        if (v22 == v13)
        {
          int v21 = v17;
          char v19 = 1;
        }
        int v17 = v18 + 1;
        uint64_t v18 = (v18 + 1);
      }
      while (v15 != v17);
      LODWORD(v57) = v21;
      BYTE4(v57) = v16;
      BOOL v11 = v19 != 0;
    }
    if (v11 || (a4 & 1) != 0)
    {
      uint64_t v54 = 0;
      uint64_t v55 = 0;
      unsigned int v56 = 0;
      uint64_t v27 = *((void *)v10 + 25);
      if (v27)
      {
        uint64_t v29 = v10 + 48;
        uint64_t v28 = (uint64_t *)*((void *)v10 + 23);
      }
      else
      {
        uint64_t v28 = (uint64_t *)*((void *)v10 + 1);
        uint64_t v29 = (int *)&v28[5 * v10[4]];
      }
      if (v28 != (uint64_t *)v29)
      {
        do
        {
          if (v27) {
            uint64_t v37 = v28 + 4;
          }
          else {
            uint64_t v37 = v28;
          }
          v59[0] = 0;
          if (sub_1CC4E4420(*(void *)(a1 + 2400), *(_DWORD *)(a1 + 2416), v37, v59)) {
            unint64_t v38 = v59[0];
          }
          else {
            unint64_t v38 = *(void *)(a1 + 2400) + ((unint64_t)*(unsigned int *)(a1 + 2416) << 6);
          }
          uint64_t v39 = (uint64_t *)(v38 + 48);
          if (*(unsigned char *)(a1 + 33)
            && (uint64_t v40 = *v39) != 0
            && (v42 = v40 + 24, uint64_t v41 = *(void **)(v40 + 24),
                                ((*(void *)(v42 + 8) - (void)v41) & 0x7FFFFFFF8) != 0)
            && *v41 == 4099)
          {
            LiveDebugValues::MLocTracker::emitLoc(*(void *)(a1 + 16), a2 | 0x100000000, (uint64_t)v37, (uint64_t)v39);
            unint64_t v44 = *(unsigned int *)(a1 + 2432);
            if (v44 >= *(unsigned int *)(a1 + 2436)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 2424) + 8 * v44) = v43;
            ++*(_DWORD *)(a1 + 2432);
            int v45 = BYTE4(v57);
          }
          else
          {
            unsigned __int8 v47 = BYTE4(v57);
            LiveDebugValues::MLocTracker::emitLoc(*(void *)(a1 + 16), v57, (uint64_t)v37, (uint64_t)v39);
            unint64_t v49 = *(unsigned int *)(a1 + 2432);
            if (v49 >= *(unsigned int *)(a1 + 2436)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v45 = v47;
            *(void *)(*(void *)(a1 + 2424) + 8 * v49) = v48;
            ++*(_DWORD *)(a1 + 2432);
          }
          if (v45)
          {
            *(_DWORD *)(v38 + 40) = v57;
            sub_1CC3A0178((uint64_t)&v54, (uint64_t)v37, (uint64_t)v59);
          }
          else
          {
            *(void *)unint64_t v38 = 0;
            *(void *)(v38 + sub_1CD521E44((uint64_t)this + 8) = 0;
            *(void *)(v38 + 16) = 0;
            *(unsigned char *)(v38 + 24) = 1;
            *(void *)(v38 + 32) = 0;
            *(int32x2_t *)(a1 + 240sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(a1 + 2408), (int32x2_t)0x1FFFFFFFFLL);
          }
          if (v27)
          {
            uint64_t v50 = (uint64_t *)v28[1];
            if (v50)
            {
              do
              {
                uint64_t v46 = v50;
                uint64_t v50 = (uint64_t *)*v50;
              }
              while (v50);
            }
            else
            {
              do
              {
                uint64_t v46 = (uint64_t *)v28[2];
                BOOL v23 = *v46 == (void)v28;
                uint64_t v28 = v46;
              }
              while (!v23);
            }
          }
          else
          {
            uint64_t v46 = v28 + 5;
          }
          uint64_t v28 = v46;
        }
        while (v46 != (uint64_t *)v29);
        if (v55)
        {
          uint64_t v51 = v54 + 40 * v56;
          v59[0] = v54;
          v59[1] = v51;
          sub_1CC4E4750(v59);
          for (unsigned int i = (unint64_t *)v59[0]; v59[0] != v51; unsigned int i = (unint64_t *)v59[0])
          {
            uint64_t v53 = sub_1CD59A81C(a1 + 2376, (int *)&v57);
            sub_1CD598850((uint64_t)(v53 + 2), i);
            v59[0] = (uint64_t)(i + 5);
            sub_1CC4E4750(v59);
          }
        }
      }
      if (BYTE4(v57)) {
        *(void *)(*(void *)(a1 + 2104) + 8 * v57) = v58;
      }
      sub_1CD592A64(a1, a3, 0);
      uint64_t v34 = sub_1CD59BD20(*(void *)(a1 + 2376), *(_DWORD *)(a1 + 2392), a2);
      uint64_t v36 = v34 + 48;
      unsigned int v35 = (void *)*((void *)v34 + 24);
      v34[4] = 0;
      sub_1CD3C5048((uint64_t)(v34 + 46), v35);
      *(v36 - 1) = v36;
      *uint64_t v36 = 0;
      v36[1] = 0;
      MEMORY[0x1D25D9CD0](v54, 8);
    }
    else
    {
      uint64_t v24 = *((void *)v10 + 25);
      if (v24)
      {
        uint64_t v26 = v10 + 48;
        uint64_t v25 = (uint64_t *)*((void *)v10 + 23);
      }
      else
      {
        uint64_t v25 = (uint64_t *)*((void *)v10 + 1);
        uint64_t v26 = (int *)&v25[5 * v10[4]];
      }
      if (v25 != (uint64_t *)v26)
      {
        do
        {
          if (v24) {
            uint64_t v30 = v25 + 4;
          }
          else {
            uint64_t v30 = v25;
          }
          v59[0] = 0;
          if (sub_1CC4E4420(*(void *)(a1 + 2400), *(_DWORD *)(a1 + 2416), v30, v59)) {
            unint64_t v31 = v59[0];
          }
          else {
            unint64_t v31 = *(void *)(a1 + 2400) + ((unint64_t)*(unsigned int *)(a1 + 2416) << 6);
          }
          sub_1CD5925AC((llvm::MachineInstr *)a1, v30, v31 + 48, &v58);
          if (v24)
          {
            int v33 = (uint64_t *)v25[1];
            if (v33)
            {
              do
              {
                int v32 = v33;
                int v33 = (uint64_t *)*v33;
              }
              while (v33);
            }
            else
            {
              do
              {
                int v32 = (uint64_t *)v25[2];
                BOOL v23 = *v32 == (void)v25;
                uint64_t v25 = v32;
              }
              while (!v23);
            }
          }
          else
          {
            int v32 = v25 + 5;
          }
          uint64_t v25 = v32;
        }
        while (v32 != (uint64_t *)v26);
      }
      sub_1CD592A64(a1, a3, 0);
    }
  }
}

unint64_t LiveDebugValues::InstrRefBasedLDV::performCopy(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  if (v6) {
    uint64_t v7 = (void *)(v6 + 8);
  }
  else {
    uint64_t v7 = 0;
  }
  unsigned int v8 = a3;
  sub_1CB8FB608((uint64_t)v37, a3, v7, 1);
  while (v39)
  {
LABEL_5:
    uint64_t v9 = *(void *)(a1 + 352);
    uint64_t v10 = (unsigned __int16)v40;
    int v11 = *(_DWORD *)(a1 + 360);
    int v12 = *(_DWORD *)(a1 + 364);
    uint64_t v13 = *(void *)(v9 + 64);
    unsigned int v14 = *(_DWORD *)(v13 + 4 * (unsigned __int16)v40);
    if (v14 == -1)
    {
      unsigned int v14 = LiveDebugValues::MLocTracker::trackRegister(*(LiveDebugValues::MLocTracker **)(a1 + 352), (unsigned __int16)v40);
      *(_DWORD *)(v13 + 4 * v10) = v14;
    }
    *(void *)(*(void *)(v9 + 32) + 8 * v14) = *(void *)&v11 & 0xFFFFFLL | ((*(void *)&v12 & 0xFFFFFLL) << 20) | ((unint64_t)v14 << 40);
    while (1)
    {
      sub_1CB8FB704((uint64_t)v37);
      if (v38 || v39 == 0) {
        break;
      }
      if (v37[0] != (unsigned __int16)v40) {
        goto LABEL_5;
      }
    }
  }
  uint64_t v16 = *(void *)(a1 + 352);
  uint64_t v17 = *(void *)(v16 + 64);
  unsigned int v18 = *(_DWORD *)(v17 + 4 * a2);
  if (v18 == -1)
  {
    unsigned int v18 = LiveDebugValues::MLocTracker::trackRegister(*(LiveDebugValues::MLocTracker **)(a1 + 352), a2);
    *(_DWORD *)(v17 + 4 * a2) = v18;
    char v19 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
    uint64_t v17 = *((void *)v19 + 8);
  }
  else
  {
    char v19 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
  }
  uint64_t v20 = *(void *)(*(void *)(v16 + 32) + 8 * v18);
  unint64_t result = *(unsigned int *)(v17 + 4 * a3);
  if (result == -1)
  {
    unint64_t result = LiveDebugValues::MLocTracker::trackRegister(v19, a3);
    *(_DWORD *)(v17 + 4 * a3) = result;
  }
  *(void *)(*((void *)v19 + 4) + 8 * result) = v20;
  uint64_t v22 = *(void *)(a1 + 16);
  if (v22) {
    BOOL v23 = (void *)(v22 + 8);
  }
  else {
    BOOL v23 = 0;
  }
  uint64_t v24 = v23[6];
  uint64_t v25 = *(unsigned int *)(*v23 + 24 * a2 + 4);
  if (*(_WORD *)(v24 + 2 * v25))
  {
    uint64_t v26 = (unsigned __int16 *)(v23[10] + 2 * *(unsigned int *)(*v23 + 24 * a2 + 12));
    unsigned __int16 v27 = *(_WORD *)(v24 + 2 * v25) + a2;
    uint64_t v28 = (unsigned __int16 *)(v24 + 2 * v25 + 2);
    do
    {
      uint64_t v29 = v27;
      unint64_t result = llvm::MCRegisterInfo::getSubReg((void *)(*(void *)(a1 + 16) + 8), v8, *v26);
      if (result)
      {
        unsigned int v30 = result;
        unint64_t v31 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
        uint64_t v32 = *((void *)v31 + 8);
        if (*(_DWORD *)(v32 + 4 * v29) == -1)
        {
          *(_DWORD *)(v32 + 4 * v29) = LiveDebugValues::MLocTracker::trackRegister(*(LiveDebugValues::MLocTracker **)(a1 + 352), v29);
          unint64_t v31 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
          uint64_t v32 = *((void *)v31 + 8);
        }
        if (*(_DWORD *)(v32 + 4 * v30) == -1)
        {
          *(_DWORD *)(v32 + 4 * v30) = LiveDebugValues::MLocTracker::trackRegister(v31, v30);
          unint64_t v31 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
          uint64_t v32 = *((void *)v31 + 8);
        }
        unsigned int v33 = *(_DWORD *)(v32 + 4 * v29);
        if (v33 == -1)
        {
          unsigned int v33 = LiveDebugValues::MLocTracker::trackRegister(v31, v29);
          *(_DWORD *)(v32 + 4 * v29) = v33;
          uint64_t v34 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
          uint64_t v32 = *((void *)v34 + 8);
        }
        else
        {
          uint64_t v34 = v31;
        }
        uint64_t v35 = *(void *)(*((void *)v31 + 4) + 8 * v33);
        unint64_t result = *(unsigned int *)(v32 + 4 * v30);
        if (result == -1)
        {
          unint64_t result = LiveDebugValues::MLocTracker::trackRegister(v34, v30);
          *(_DWORD *)(v32 + 4 * v30) = result;
        }
        *(void *)(*((void *)v34 + 4) + 8 * result) = v35;
      }
      int v36 = *v28++;
      unsigned __int16 v27 = v36 + v29;
      ++v26;
    }
    while (v36);
  }
  return result;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::isSpillInstruction(const llvm::TargetInstrInfo **this, const llvm::MachineInstr *a2, llvm::MachineFunction *a3)
{
  unint64_t v3 = *((void *)a2 + 6);
  if (v3 >= 8)
  {
    if ((v3 & 7) != 0)
    {
      uint64_t v6 = (_DWORD *)(v3 & 0xFFFFFFFFFFFFFFF8);
      BOOL v7 = (*((void *)a2 + 6) & 7) != 3 || v6 == 0;
      if (v7 || *v6 != 1) {
        goto LABEL_13;
      }
    }
    else
    {
      v3 &= 0xFFFFFFFFFFFFFFF8;
      *((void *)a2 + 6) = v3;
    }
    if ((v3 & 7) != 0)
    {
      unsigned int v8 = *(void **)((v3 & 0xFFFFFFFFFFFFFFF8) + 8);
    }
    else
    {
      unsigned int v8 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
      *((void *)a2 + 6) = v8;
    }
    unint64_t v9 = *v8 & ((uint64_t)(*v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8;
    if (((*(uint64_t (**)(unint64_t, const llvm::TargetInstrInfo *, llvm::MachineFunction *))(*(void *)v9 + 32))(v9, this[6], a3) & 1) == 0&& ((llvm::MachineInstr::getSpillSize(a2, this[4]) & 0xFF00000000) != 0|| (llvm::MachineInstr::getFoldedSpillSize(a2, this[4]) & 0xFF00000000) != 0))
    {
      uint64_t SpillBaseRegAndOffset = LiveDebugValues::InstrRefBasedLDV::extractSpillBaseRegAndOffset((LiveDebugValues::InstrRefBasedLDV *)this, a2);
      uint64_t v11 = SpillBaseRegAndOffset & 0x100000000;
      uint64_t v12 = SpillBaseRegAndOffset & 0xFFFFFF00;
      uint64_t v10 = SpillBaseRegAndOffset;
      return v11 | v10 | v12;
    }
  }
LABEL_13:
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  return v11 | v10 | v12;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::isRestoreInstruction(const llvm::TargetInstrInfo **this, const llvm::MachineInstr *a2, llvm::MachineFunction *a3, unsigned int *a4)
{
  unint64_t v4 = *((void *)a2 + 6);
  if (v4 >= 8)
  {
    if ((v4 & 7) != 0)
    {
      unsigned int v8 = (_DWORD *)(v4 & 0xFFFFFFFFFFFFFFF8);
      BOOL v9 = (*((void *)a2 + 6) & 7) != 3 || v8 == 0;
      if (v9 || *v8 != 1) {
        goto LABEL_11;
      }
    }
    else
    {
      *((void *)a2 + 6) = v4 & 0xFFFFFFFFFFFFFFF8;
    }
    if ((llvm::MachineInstr::getRestoreSize(a2, this[4]) & 0xFF00000000) != 0)
    {
      *a4 = *(_DWORD *)(*((void *)a2 + 4) + 4);
      uint64_t SpillBaseRegAndOffset = LiveDebugValues::InstrRefBasedLDV::extractSpillBaseRegAndOffset((LiveDebugValues::InstrRefBasedLDV *)this, a2);
      uint64_t v11 = SpillBaseRegAndOffset & 0x100000000;
      uint64_t v12 = SpillBaseRegAndOffset & 0xFFFFFF00;
      uint64_t v10 = SpillBaseRegAndOffset;
      return v11 | v10 | v12;
    }
  }
LABEL_11:
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  return v11 | v10 | v12;
}

uint64_t sub_1CD593F58(uint64_t a1, int a2, unsigned int a3)
{
  unint64_t v3 = (unsigned __int16 *)(*(void *)(*(void *)(a1 + 16) + 96) + 4 * a3);
  int v6 = v3[1] | (*v3 << 16);
  int v4 = *(_DWORD *)(a1 + 240);
  return (*((_DWORD *)sub_1CD59B940(a1 + 776, (unsigned __int16 *)&v6) + 1)
                      + v4 * (a2 - 1)
                      + *(_DWORD *)(a1 + 236));
}

void sub_1CD593FC8(uint64_t a1, unsigned int a2, unsigned int a3, unint64_t a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  unsigned int v32 = a3;
  unsigned int v33 = a2;
  if (*(void *)(*(void *)(a1 + 2104) + 8 * a2) != *(void *)(*(void *)(*(void *)(a1 + 16) + 32) + 8 * a2)) {
    return;
  }
  uint64_t v7 = a2;
  uint64_t v8 = a1 + 2376;
  BOOL v9 = sub_1CD59A81C(a1 + 2376, (int *)&v33);
  uint64_t v10 = v9;
  uint64_t v35 = v37;
  uint64_t v36 = 0x400000000;
  if (v9[4]) {
    sub_1CD59BD84((uint64_t)&v35, (uint64_t)(v9 + 2));
  }
  sub_1CC4E47A0((uint64_t)&v38, (void *)v10 + 23);
  uint64_t v11 = sub_1CD59A81C(v8, (int *)&v32);
  if ((void **)sub_1CD59BD84((uint64_t)(v11 + 2), (uint64_t)&v35) != &v35) {
    sub_1CD59C138((uint64_t)(v11 + 46), v38, &v39);
  }
  *(void *)(*(void *)(a1 + 2104) + 8 * a3) = *(void *)(*(void *)(a1 + 2104) + 8 * v7);
  uint64_t v12 = v40;
  if (v40) {
    uint64_t v13 = v38;
  }
  else {
    uint64_t v13 = (uint64_t *)v35;
  }
  unsigned int v14 = (uint64_t *)((char *)v35 + 40 * v36);
  while (!v12)
  {
    if (v13 == v14) {
      goto LABEL_36;
    }
LABEL_15:
    if (v12) {
      int v15 = v13 + 4;
    }
    else {
      int v15 = v13;
    }
    unint64_t v34 = 0;
    if (sub_1CC4E4420(*(void *)(a1 + 2400), *(_DWORD *)(a1 + 2416), v15, (uint64_t *)&v34)) {
      unint64_t v16 = v34;
    }
    else {
      unint64_t v16 = *(void *)(a1 + 2400) + ((unint64_t)*(unsigned int *)(a1 + 2416) << 6);
    }
    uint64_t v17 = v32;
    *(_DWORD *)(v16 + 40) = v32;
    if (*(unsigned char *)(a1 + 33)
      && (uint64_t v18 = v16 + 48, (v19 = *(void *)(v16 + 48)) != 0)
      && (v21 = v19 + 24, uint64_t v20 = *(void **)(v19 + 24), ((*(void *)(v21 + 8) - (void)v20) & 0x7FFFFFFF8) != 0)
      && *v20 == 4099)
    {
      uint64_t v22 = *(void *)(a1 + 16);
      uint64_t v23 = v33 | 0x100000000;
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 16);
      uint64_t v18 = v16 + 48;
      uint64_t v23 = v17 | 0x100000000;
    }
    LiveDebugValues::MLocTracker::emitLoc(v22, v23, (uint64_t)v15, v18);
    unint64_t v25 = *(unsigned int *)(a1 + 2432);
    if (v25 >= *(unsigned int *)(a1 + 2436)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 2424) + 8 * v25) = v24;
    ++*(_DWORD *)(a1 + 2432);
    if (v12)
    {
      uint64_t v26 = (uint64_t *)v13[1];
      unsigned __int16 v27 = v13;
      if (v26)
      {
        do
        {
          uint64_t v13 = v26;
          uint64_t v26 = (uint64_t *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v13 = (uint64_t *)v27[2];
          BOOL v28 = *v13 == (void)v27;
          unsigned __int16 v27 = v13;
        }
        while (!v28);
      }
    }
    else
    {
      v13 += 5;
    }
  }
  if (v13 != (uint64_t *)&v39) {
    goto LABEL_15;
  }
LABEL_36:
  uint64_t v29 = sub_1CD59A81C(v8, (int *)&v33);
  unint64_t v31 = v29 + 48;
  unsigned int v30 = (void *)*((void *)v29 + 24);
  v29[4] = 0;
  sub_1CD3C5048((uint64_t)(v29 + 46), v30);
  *(v31 - 1) = v31;
  *unint64_t v31 = 0;
  v31[1] = 0;
  sub_1CD592A64(a1, a4, 0);
  if (byte_1EBCD81D0) {
    *(void *)(*(void *)(a1 + 2104) + 8 * v33) = LiveDebugValues::ValueIDNum::EmptyValue;
  }
  sub_1CD3C5048((uint64_t)&v38, v39);
  if (v35 != v37) {
    free(v35);
  }
}

void LiveDebugValues::InstrRefBasedLDV::process(LiveDebugValues::InstrRefBasedLDV *a1, llvm::MachineInstr *a2, uint64_t a3, uint64_t a4)
{
  if (!LiveDebugValues::InstrRefBasedLDV::transferDebugValue(a1, a2)
    && (LiveDebugValues::InstrRefBasedLDV::transferDebugInstrRef((uint64_t)a1, (unint64_t)a2, a3, a4) & 1) == 0
    && !LiveDebugValues::InstrRefBasedLDV::transferDebugPHI(a1, a2)
    && (LiveDebugValues::InstrRefBasedLDV::transferRegisterCopy(a1, a2) & 1) == 0
    && (LiveDebugValues::InstrRefBasedLDV::transferSpillOrRestoreInst(a1, a2) & 1) == 0)
  {
    LiveDebugValues::InstrRefBasedLDV::transferRegisterDef(a1, a2);
  }
}

uint64_t LiveDebugValues::InstrRefBasedLDV::mlocJoin(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  v30[8] = *MEMORY[0x1E4F143B8];
  BOOL v28 = v30;
  uint64_t v29 = 0x800000000;
  BOOL v9 = *(void **)(a2 + 64);
  uint64_t v10 = *(void **)(a2 + 72);
  if (v9 == v10)
  {
    uint64_t v27 = a1;
    uint64_t v13 = (int8x16_t *)v30;
    uint64_t v12 = (int8x16_t *)v30;
LABEL_8:
    uint64_t v14 = 0;
    goto LABEL_9;
  }
  LODWORD(v11) = 0;
  do
  {
    if (v11 >= HIDWORD(v29)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v28 + v11) = *v9;
    unint64_t v11 = (v29 + 1);
    LODWORD(v29) = v29 + 1;
    ++v9;
  }
  while (v9 != v10);
  uint64_t v12 = (int8x16_t *)v28;
  uint64_t v13 = (int8x16_t *)((char *)v28 + 8 * v11);
  uint64_t v27 = a1;
  if (!v11) {
    goto LABEL_8;
  }
  uint64_t v14 = 126 - 2 * __clz(v11);
LABEL_9:
  sub_1CC4E4F70(v12, v13, &v27, v14, 1);
  if (v29)
  {
    int v15 = *(_DWORD *)(*(void *)(a1 + 352) + 40);
    if (v15)
    {
      char v16 = 0;
      uint64_t v17 = 0;
      while (1)
      {
        uint64_t v18 = *(void *)(*(void *)(*a4 + 8 * *(int *)(*(void *)v28 + 24)) + 8 * v17);
        unint64_t v19 = *(_DWORD *)(a2 + 24) & 0xFFFFF | (unint64_t)(v17 << 40);
        uint64_t v20 = *(void *)(*a5 + 8 * v17);
        if (v20 == v19) {
          break;
        }
        if (v20 != v18) {
          goto LABEL_21;
        }
LABEL_22:
        int v25 = v17 + 1;
        uint64_t v17 = (v17 + 1);
        if (v15 == v25) {
          goto LABEL_25;
        }
      }
      if (v29 >= 2)
      {
        char v21 = 0;
        uint64_t v22 = v29 - 1;
        uint64_t v23 = (char *)v28 + 8;
        do
        {
          uint64_t v24 = *(void *)(*(void *)(*a4 + 8 * *(int *)(*(void *)v23 + 24)) + 8 * v17);
          if (v18 != v24) {
            v21 |= v24 != v19;
          }
          v23 += 8;
          --v22;
        }
        while (v22);
        if (v21) {
          goto LABEL_22;
        }
      }
LABEL_21:
      *(void *)(*a5 + 8 * v17) = v18;
      char v16 = 1;
      goto LABEL_22;
    }
  }
  char v16 = 0;
LABEL_25:
  if (v28 != v30) {
    free(v28);
  }
  return v16 & 1;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::findStackIndexInterference(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 352);
  uint64_t v27 = 0;
  uint64_t result = sub_1CD59B9B0(*(void *)(v4 + 776), *(_DWORD *)(v4 + 792), 8u, 0, &v27);
  if (result) {
    uint64_t v6 = v27;
  }
  else {
    uint64_t v6 = *(void *)(v4 + 776) + 8 * *(unsigned int *)(v4 + 792);
  }
  int v7 = *(_DWORD *)(v6 + 4);
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  if (v8 >= *(_DWORD *)(a2 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_DWORD *)(*(void *)a2 + 4 * vsub_1CD521E44((uint64_t)this + 8) = v7;
  unsigned int v9 = *(_DWORD *)(a2 + 8) + 1;
  *(_DWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v9;
  uint64_t v10 = *(void *)(a1 + 352);
  int v11 = *(_DWORD *)(v10 + 784);
  uint64_t v12 = *(unsigned __int16 **)(v10 + 776);
  uint64_t v13 = *(unsigned int *)(v10 + 792);
  uint64_t v14 = &v12[4 * v13];
  if (v11)
  {
    if (v13)
    {
      uint64_t v15 = 8 * v13;
      char v16 = v12;
      while (1)
      {
        int v17 = *v16;
        int v18 = v16[1];
        if ((v17 != 0xFFFF || v18 != 0xFFFF) && (v17 != 65534 || v18 != 65534)) {
          break;
        }
        v16 += 4;
        v15 -= 8;
        if (!v15) {
          goto LABEL_18;
        }
      }
    }
    else
    {
      char v16 = v12;
    }
  }
  else
  {
LABEL_18:
    char v16 = &v12[4 * v13];
  }
  char v21 = &v12[4 * v13];
  while (v16 != v21)
  {
    if (v16[1])
    {
      if (v9 >= *(_DWORD *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v9) = *((_DWORD *)v16 + 1);
      unsigned int v9 = *(_DWORD *)(a2 + 8) + 1;
      *(_DWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v9;
    }
    uint64_t v22 = v16 + 4;
    char v16 = v14;
    if (v22 != v14)
    {
      char v16 = v22;
      while (1)
      {
        int v23 = *v16;
        int v24 = v16[1];
        if ((v23 != 0xFFFF || v24 != 0xFFFF) && (v23 != 65534 || v24 != 65534)) {
          break;
        }
        v16 += 4;
        if (v16 == v14)
        {
          char v16 = v14;
          break;
        }
      }
    }
  }
  return result;
}

void LiveDebugValues::InstrRefBasedLDV::placeMLocPHIs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v89[2] = *MEMORY[0x1E4F143B8];
  unint64_t v87 = (unsigned int *)v89;
  uint64_t v88 = 0x400000000;
  LiveDebugValues::InstrRefBasedLDV::findStackIndexInterference(a1, (uint64_t)&v87);
  uint64_t v81 = v83;
  uint64_t v82 = 0x2000000000;
  uint64_t v86 = 0;
  __int16 v85 = 0;
  uint64_t v84 = (unsigned int *)&v85;
  unsigned int v9 = (int *)v77;
  uint64_t v75 = v77;
  uint64_t v76 = 0x2000000000;
  uint64_t v80 = 0;
  uint64_t v79 = 0;
  char v78 = (int *)&v79;
  int v69 = v71;
  uint64_t v70 = 0x2000000000;
  uint64_t v74 = 0;
  unsigned int v73 = 0;
  unsigned int v72 = &v73;
  int v10 = *(_DWORD *)(*(void *)(a1 + 352) + 40);
  if (v10)
  {
    uint64_t v53 = a2;
    uint64_t v54 = a5;
    uint64_t v55 = a3;
    unsigned int v14 = 0;
    uint64_t v15 = 0;
    char v16 = v65;
    int v56 = *(_DWORD *)(*(void *)(a1 + 352) + 40);
    do
    {
      v57[0] = v14;
      uint64_t v17 = *(void *)(a1 + 352);
      unsigned int v18 = *(_DWORD *)(*(void *)(v17 + 88) + 4 * v15);
      unsigned int v19 = *(_DWORD *)(v17 + 236);
      if (v18 >= v19)
      {
        LODWORD(v63) = (v18 - v19) / *(_DWORD *)(v17 + 240) + 1;
        sub_1CD595004((uint64_t)&v69, (unsigned int *)&v63);
      }
      else
      {
        char v20 = 0;
        char v21 = v16;
        uint64_t v63 = v16;
        uint64_t v64 = 0x800000000;
        int v67 = 0;
        uint64_t v68 = 0;
        int v66 = &v67;
        uint64_t v22 = *(void *)(a1 + 16);
        if (v22) {
          int v23 = (void *)(v22 + 8);
        }
        else {
          int v23 = 0;
        }
        unint64_t v24 = *(unsigned int *)(*v23 + 24 * v18 + 16);
        int v25 = (_WORD *)(v23[6] + ((v24 >> 3) & 0x1FFFFFFE));
        unsigned __int16 v26 = *v25 + (v24 & 0xF) * v18;
        do
        {
          uint64_t v27 = *(void *)(a1 + 16);
          if (v27) {
            uint64_t v28 = v27 + 8;
          }
          else {
            uint64_t v28 = 0;
          }
          uint64_t v29 = *(void *)(v28 + 40);
          uint64_t v30 = v26;
          unsigned int v31 = *(unsigned __int16 *)(v29 + 4 * v26);
          if (v31)
          {
            unsigned int v32 = *(unsigned __int16 *)(v29 + 4 * v30 + 2);
            do
            {
              unsigned int v33 = v32;
              if (*(_DWORD *)(*(void *)(*(void *)(a1 + 352) + 64) + 4 * v31) == -1)
              {
                char v20 = 1;
              }
              else
              {
                LODWORD(v58[0]) = v31;
                sub_1CD513F60((uint64_t)&v63, (unsigned int *)v58);
              }
              unsigned int v32 = 0;
              unsigned int v31 = v33;
            }
            while (v33);
          }
          int v34 = (unsigned __int16)v25[1];
          ++v25;
          unsigned __int16 v26 = v34 + v30;
        }
        while (v34);
        if (v20)
        {
          sub_1CD595004((uint64_t)&v75, v57);
          char v16 = v21;
          int v10 = v56;
        }
        else
        {
          char v16 = v21;
          if (v68)
          {
            char v37 = 0;
            uint64_t v35 = v66;
            uint64_t v36 = (char *)&v67;
          }
          else
          {
            uint64_t v35 = v63;
            uint64_t v36 = (char *)v63 + 4 * v64;
            char v37 = 1;
          }
          int v10 = v56;
          unsigned int v61 = v35;
          char v62 = v37;
          uint64_t v59 = v36;
          char v60 = v37;
          sub_1CD595118((uint64_t)&v81, (uint64_t)&v61, (uint64_t)&v59);
        }
        sub_1CB833A08((uint64_t)&v66, v67);
        if (v63 != v16) {
          free(v63);
        }
      }
      unsigned int v14 = v15 + 1;
      uint64_t v15 = (v15 + 1);
    }
    while (v10 != v14);
    unsigned int v9 = (int *)v75;
    uint64_t v13 = v78;
    uint64_t v11 = v76;
    BOOL v12 = v80 == 0;
    a5 = v54;
    a3 = v55;
    a2 = v53;
  }
  else
  {
    uint64_t v11 = 0;
    BOOL v12 = 1;
    uint64_t v13 = (int *)&v79;
  }
  uint64_t v63 = v65;
  uint64_t v64 = 0x2000000000;
  v58[0] = a1;
  v58[1] = a5;
  v58[2] = a2;
  v58[3] = (uint64_t)&v63;
  if (v12) {
    char v38 = v9;
  }
  else {
    char v38 = v13;
  }
  uint64_t v58[4] = a3;
  if (!v12)
  {
    if (v38 == (int *)&v79) {
      goto LABEL_41;
    }
LABEL_38:
    uint64_t v39 = v38 + 7;
    if (v12) {
      uint64_t v39 = v38;
    }
    sub_1CC4E26D0(v58, *v39);
  }
  if (v38 != &v9[v11]) {
    goto LABEL_38;
  }
LABEL_41:
  if (v74) {
    uint64_t v40 = v72;
  }
  else {
    uint64_t v40 = v69;
  }
  while (1)
  {
    uint64_t v41 = v74 ? &v73 : (void **)((char *)v69 + 4 * v70);
    if (v40 == v41) {
      break;
    }
    if (v88)
    {
      uint64_t v42 = (_DWORD *)v40 + 7;
      if (!v74) {
        uint64_t v42 = v40;
      }
      int v43 = *v42 - 1;
      v57[0] = *v87;
      sub_1CC4E26D0(v58, *(_DWORD *)(*(void *)(*(void *)(a1 + 352) + 64)+ 4* (v57[0]+ *(_DWORD *)(*(void *)(a1 + 352) + 240) * v43+ *(_DWORD *)(*(void *)(a1 + 352) + 236))));
    }
    if (v74)
    {
      unint64_t v44 = (void *)v40[1];
      int v45 = v40;
      if (v44)
      {
        do
        {
          uint64_t v40 = v44;
          unint64_t v44 = (void *)*v44;
        }
        while (v44);
      }
      else
      {
        do
        {
          uint64_t v40 = (void *)v45[2];
          BOOL v46 = *v40 == (void)v45;
          int v45 = v40;
        }
        while (!v46);
      }
    }
    else
    {
      uint64_t v40 = (void *)((char *)v40 + 4);
    }
  }
  if (v86) {
    unsigned __int8 v47 = v84;
  }
  else {
    unsigned __int8 v47 = (unsigned int *)v81;
  }
  if (v86)
  {
    if (v47 != (unsigned int *)&v85) {
      goto LABEL_65;
    }
  }
  else if (v47 != (unsigned int *)((char *)v81 + 4 * v82))
  {
LABEL_65:
    uint64_t v48 = v47 + 7;
    if (!v86) {
      uint64_t v48 = v47;
    }
    uint64_t v49 = *v48;
    uint64_t v50 = *(LiveDebugValues::MLocTracker **)(a1 + 352);
    uint64_t v51 = *((void *)v50 + 8);
    int v52 = *(_DWORD *)(v51 + 4 * v49);
    if (v52 == -1)
    {
      int v52 = LiveDebugValues::MLocTracker::trackRegister(v50, v49);
      *(_DWORD *)(v51 + 4 * v49) = v52;
    }
    sub_1CC4E26D0(v58, v52);
  }
  if (v63 != v65) {
    free(v63);
  }
  sub_1CD40B1BC(v73);
  if (v69 != v71) {
    free(v69);
  }
  sub_1CD40B1BC(v79);
  if (v75 != v77) {
    free(v75);
  }
  sub_1CB833A08((uint64_t)&v84, v85);
  if (v81 != v83) {
    free(v81);
  }
  if (v87 != (unsigned int *)v89) {
    free(v87);
  }
}

uint64_t sub_1CD595004(uint64_t result, unsigned int *a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 160))
  {
    unsigned int v8 = (uint64_t **)(result + 144);
    unsigned int v9 = *a2;
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(result + 8);
    unsigned int v5 = *a2;
    if (!v4)
    {
LABEL_7:
      if (v4 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)result + 4 * v4) = v5;
      ++*(_DWORD *)(result + 8);
      return result;
    }
    uint64_t v6 = 4 * v4;
    int v7 = *(_DWORD **)result;
    while (*v7 != v5)
    {
      ++v7;
      v6 -= 4;
      if (!v6) {
        goto LABEL_6;
      }
    }
    if (v6) {
      return result;
    }
LABEL_6:
    if (v4 <= 0x1F) {
      goto LABEL_7;
    }
    do
    {
      unsigned int v10 = *(_DWORD *)(*(void *)v3 + 4 * v4 - 4);
      sub_1CD59EBF0((uint64_t **)(v3 + 144), v10, v10);
      LODWORD(v4) = *(_DWORD *)(v3 + 8) - 1;
      *(_DWORD *)(v3 + sub_1CD521E44((uint64_t)this + 8) = v4;
    }
    while (v4);
    unsigned int v9 = *a2;
    unsigned int v8 = (uint64_t **)(v3 + 144);
  }

  return sub_1CD59EBF0(v8, v9, v9);
}

uint64_t sub_1CD595118(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  int v6 = *(unsigned __int8 *)(a2 + 8);
  for (unsigned int i = *(unsigned int **)a2; ; *(void *)a2 = i)
  {
    if (v6 != *(unsigned __int8 *)(a3 + 8))
    {
      if (v6) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
    if (!v6) {
      break;
    }
    if (i == *(unsigned int **)a3) {
      return result;
    }
LABEL_10:
    uint64_t result = sub_1CC34E98C(v5, i);
    int v6 = *(unsigned __int8 *)(a2 + 8);
    unsigned int v8 = *(unsigned int **)a2;
    if (*(unsigned char *)(a2 + 8))
    {
      unsigned int i = v8 + 1;
    }
    else
    {
      unsigned int v9 = (unsigned int *)*((void *)v8 + 1);
      if (v9)
      {
        do
        {
          unsigned int i = v9;
          unsigned int v9 = *(unsigned int **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unsigned int i = (unsigned int *)*((void *)v8 + 2);
          BOOL v10 = *(void *)i == (void)v8;
          unsigned int v8 = i;
        }
        while (!v10);
      }
    }
  }
  if (i != *(unsigned int **)a3)
  {
LABEL_9:
    i += 7;
    goto LABEL_10;
  }
  return result;
}

void LiveDebugValues::InstrRefBasedLDV::buildMLocValueMap(uint64_t a1, uint64_t a2, void **a3, void *a4, uint64_t *a5)
{
  v90[64] = *MEMORY[0x1E4F143B8];
  uint64_t v86 = 0;
  __int16 v85 = 0;
  uint64_t v87 = 0;
  uint64_t v83 = 0;
  std::string __p = 0;
  uint64_t v84 = 0;
  uint64_t v77 = v81;
  char v78 = v81;
  uint64_t v79 = 16;
  int v80 = 0;
  unsigned int v72 = (uint64_t *)v76;
  unsigned int v73 = (uint64_t *)v76;
  uint64_t v74 = 16;
  int v75 = 0;
  int v67 = v71;
  uint64_t v68 = v71;
  uint64_t v69 = 32;
  int v70 = 0;
  LODWORD(v8sub_1CD521E44((uint64_t)this + 8) = 0;
  if (*(_DWORD *)(a1 + 584))
  {
    do
    {
      sub_1CC4D7DA8((uint64_t)&v85, &v88);
      unsigned int v9 = sub_1CC4DCD10(a1 + 552, &v88);
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v72, *((void *)v9 + 1));
      BOOL v10 = sub_1CC4DCD10(a1 + 552, &v88);
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v67, *((void *)v10 + 1));
      LODWORD(v8sub_1CD521E44((uint64_t)this + 8) = v88 + 1;
    }
    while (v88 < *(_DWORD *)(a1 + 584));
  }
  uint64_t v58 = (uint64_t *)(a1 + 576);
  uint64_t v11 = *(void *)(a1 + 352);
  int v12 = *(_DWORD *)(v11 + 40);
  if (v12)
  {
    uint64_t v13 = 0;
    do
    {
      *(void *)(**a3 + 8 * v13) = v13 << 40;
      int v14 = v13 + 1;
      uint64_t v13 = (v13 + 1);
    }
    while (v12 != v14);
    uint64_t v11 = *(void *)(a1 + 352);
  }
  *(_DWORD *)(v11 + 256) = 0;
  LiveDebugValues::InstrRefBasedLDV::placeMLocPHIs(a1, a2, (uint64_t)&v67, (uint64_t)a3, (uint64_t)a5);
  char v62 = v66;
  uint64_t v63 = v66;
  uint64_t v64 = 16;
  int v65 = 0;
  while (1)
  {
    uint64_t v15 = v85;
    if (v85 == v86) {
      break;
    }
    uint64_t v88 = v90;
    uint64_t v89 = 0x2000000000;
    do
    {
      uint64_t v61 = 0;
      uint64_t v61 = *((void *)sub_1CC4DCD10(a1 + 552, v15) + 1);
      *(_DWORD *)(a1 + 360) = *(_DWORD *)(v61 + 24);
      sub_1CC4E6CA4((unsigned int *)v85, (uint64_t)v86, (v86 - (unsigned char *)v85) >> 2);
      v86 -= 4;
      unsigned __int8 v17 = LiveDebugValues::InstrRefBasedLDV::mlocJoin(a1, v61, v16, a4, &(*a3)[*(unsigned int *)(a1 + 360)]);
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v62, v61);
      if (!(v18 | v17)) {
        goto LABEL_11;
      }
      uint64_t v36 = *(void *)(a1 + 352);
      uint64_t v55 = *(unsigned int *)(a1 + 360);
      char v37 = *a3;
      *(_DWORD *)(v36 + 232) = v55;
      int v38 = *(_DWORD *)(v36 + 40);
      if (v38)
      {
        uint64_t v20 = 0;
        do
        {
          *(void *)(*(void *)(v36 + 32) + 8 * v20) = *(void *)(v37[v55] + 8 * v20);
          int v19 = v20 + 1;
          uint64_t v20 = (v20 + 1);
        }
        while (v38 != v19);
        LODWORD(v55) = *(_DWORD *)(a1 + 360);
      }
      LODWORD(v89) = 0;
      uint64_t v39 = *a5;
      uint64_t v40 = (_DWORD *)(*a5 + 72 * v55);
      uint64_t v41 = sub_1CD5957AC(v40);
      uint64_t v27 = v41;
      char v44 = *(unsigned char *)v40;
      int v43 = v40 + 2;
      if (v44)
      {
        uint64_t v45 = 4;
      }
      else
      {
        int v43 = (void *)*v43;
        uint64_t v45 = *(unsigned int *)(v39 + 72 * v55 + 16);
      }
      unsigned int v33 = (unsigned int *)&v43[2 * v45];
      if (v33 != v41)
      {
        unsigned int v24 = 0;
        do
        {
          unint64_t v21 = *((void *)v27 + 1);
          if ((v21 & 0xFFFFF00000) == 0 && (v21 & 0xFFFFF) == *(_DWORD *)(a1 + 360)) {
            unint64_t v21 = *(void *)(*(void *)(*(void *)(a1 + 352) + 32) + ((v21 >> 37) & 0x7FFFFF8));
          }
          if (v24 >= HIDWORD(v89)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v23 = (char *)v88 + 16 * v24;
          *int v23 = *v27;
          v23[1] = v21;
          unsigned int v24 = v89 + 1;
          LODWORD(v89) = v89 + 1;
          int v25 = v27 + 4;
          while (v25 != v42)
          {
            unsigned int v26 = *v25;
            v25 += 4;
            if (v26 <= 0xFFFFFFFD)
            {
              uint64_t v27 = v25 - 4;
              goto LABEL_27;
            }
          }
          uint64_t v27 = v42;
LABEL_27:
          ;
        }
        while (v27 != v33);
        if (v24)
        {
          unsigned int v32 = (char *)v88;
          uint64_t v49 = (char *)v88 + 16 * v24;
          do
          {
            *(void *)(*(void *)(*(void *)(a1 + 352) + 32) + 8 * *(unsigned int *)v32) = *((void *)v32 + 1);
            v32 += 16;
          }
          while (v32 != v49);
        }
      }
      uint64_t v34 = *(void *)(a1 + 352);
      int v35 = *(_DWORD *)(v34 + 40);
      if (!v35)
      {
        *(_DWORD *)(v34 + 256) = 0;
        goto LABEL_11;
      }
      char v30 = 0;
      uint64_t v31 = 0;
      do
      {
        uint64_t v28 = *(void *)(*a4 + 8 * *(unsigned int *)(a1 + 360));
        uint64_t v29 = *(void *)(*(void *)(v34 + 32) + 8 * v31);
        v30 |= *(void *)(v28 + 8 * v31) != v29;
        *(void *)(v28 + 8 * v31) = v29;
        LODWORD(v29) = v31 + 1;
        uint64_t v31 = (v31 + 1);
      }
      while (v35 != v29);
      *(_DWORD *)(*(void *)(a1 + 352) + 256) = 0;
      if (v30)
      {
        uint64_t v50 = *(uint64_t **)(v61 + 88);
        uint64_t v51 = *(uint64_t **)(v61 + 96);
        while (v50 != v51)
        {
          uint64_t v60 = 0;
          uint64_t v60 = *v50;
          unsigned int v52 = *((_DWORD *)sub_1CD41D7A0(v58, &v60) + 2);
          if (v52 <= *((_DWORD *)sub_1CD41D7A0(v58, &v61) + 2))
          {
            sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v77, v60);
            if (!v54) {
              goto LABEL_52;
            }
            p_p = &__p;
          }
          else
          {
            sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v72, v60);
            if (!v53) {
              goto LABEL_52;
            }
            p_p = &v85;
          }
          int v56 = sub_1CD41D7A0(v58, &v60);
          sub_1CC4D7DA8((uint64_t)p_p, (_DWORD *)v56 + 2);
LABEL_52:
          ++v50;
        }
      }
LABEL_11:
      uint64_t v15 = v85;
    }
    while (v85 != v86);
    BOOL v46 = __p;
    unsigned __int8 v47 = v83;
LABEL_39:
    __int16 v85 = v46;
    uint64_t v86 = v47;
    std::string __p = v15;
    uint64_t v83 = v15;
    uint64_t v48 = v87;
    uint64_t v87 = v84;
    uint64_t v84 = v48;
    llvm::SmallPtrSetImplBase::swap((uint64_t *)&v77, &v72);
    sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v77);
    if (v88 != v90) {
      free(v88);
    }
  }
  BOOL v46 = __p;
  unsigned __int8 v47 = v83;
  if (__p != v83)
  {
    uint64_t v88 = v90;
    uint64_t v89 = 0x2000000000;
    goto LABEL_39;
  }
  if (v63 != v62) {
    free(v63);
  }
  if (v68 != v67) {
    free(v68);
  }
  if (v73 != v72) {
    free(v73);
  }
  if (v78 != v77) {
    free(v78);
  }
  if (__p)
  {
    uint64_t v83 = __p;
    operator delete(__p);
  }
  if (v85)
  {
    uint64_t v86 = v85;
    operator delete(v85);
  }
}

_DWORD *sub_1CD5957AC(_DWORD *a1)
{
  int v2 = *a1;
  if (*a1 > 1u)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      int v7 = a1 + 18;
LABEL_10:
      while (*result >= 0xFFFFFFFE)
      {
        result += 4;
        if (result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (_DWORD *)*((void *)a1 + 1);
      uint64_t v6 = a1[4];
      if (v6)
      {
        int v7 = &result[4 * v6];
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v2)
    {
      uint64_t v3 = a1 + 2;
      uint64_t v4 = 4;
    }
    else
    {
      uint64_t v3 = (_DWORD *)*((void *)a1 + 1);
      uint64_t v4 = a1[4];
    }
    return &v3[4 * v4];
  }
  return result;
}

void sub_1CD595820()
{
}

unint64_t LiveDebugValues::InstrRefBasedLDV::pickVPHILoc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  v61[32] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (char *)v61;
  uint64_t v59 = v61;
  uint64_t v60 = 0x800000000;
  int v56 = v58;
  uint64_t v57 = 0x400000000;
  uint64_t v7 = *(unsigned int *)(a6 + 8);
  if (!v7) {
    goto LABEL_71;
  }
  uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 352) + 40);
  int v12 = *(uint64_t **)a6;
  uint64_t v49 = *(uint64_t **)a6;
  do
  {
    uint64_t v13 = *v12;
    uint64_t v14 = *(unsigned int *)(*v12 + 24);
    char v53 = 0;
    if (sub_1CD40EA84(*(void *)a4, *(_DWORD *)(a4 + 16), v13, &v53)) {
      BOOL v15 = v53 == (void *)(*(void *)a4 + 16 * *(unsigned int *)(a4 + 16));
    }
    else {
      BOOL v15 = 1;
    }
    if (v15
      || ((uint64_t v16 = v7, v17 = (uint64_t *)*((void *)v53 + 1), v18 = *((_DWORD *)v17 + 18), v18 != 2)
        ? (BOOL v19 = v18 == 4)
        : (BOOL v19 = 1),
          v19))
    {
      LOBYTE(v42) = 0;
      unint64_t v43 = 0;
      goto LABEL_60;
    }
    if (v57 >= (unint64_t)HIDWORD(v57)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v56 + v57) = v17 + 7;
    LODWORD(v57) = v57 + 1;
    sub_1CD59EECC((uint64_t)&v59, v60 + 1);
    int v20 = *((_DWORD *)v17 + 18);
    uint64_t v48 = v6;
    if (v20 == 1)
    {
      uint64_t v23 = *v17;
    }
    else
    {
      if (v20 != 3)
      {
        int v21 = *((_DWORD *)v17 + 12);
        int v22 = *(_DWORD *)(a2 + 24);
LABEL_25:
        if (v21 != v22)
        {
          LOBYTE(v42) = 0;
          unint64_t v43 = 0;
          goto LABEL_60;
        }
LABEL_26:
        if (v11)
        {
          uint64_t v27 = 0;
          for (uint64_t i = 0; i != v11; ++i)
          {
            if (v27 + (*(_DWORD *)(a2 + 24) & 0xFFFFF) == *(void *)(*(void *)(*a5 + 8 * v14) + 8 * i))
            {
              uint64_t v29 = (char *)v59 + 32 * v60;
              unint64_t v30 = *((unsigned int *)v29 - 6);
              if (v30 >= *((unsigned int *)v29 - 5)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(_DWORD *)(*((void *)v29 - 4) + 4 * v30) = i;
              ++*((_DWORD *)v29 - 6);
            }
            v27 += 0x10000000000;
          }
        }
        goto LABEL_32;
      }
      int v21 = *((_DWORD *)v17 + 12);
      int v22 = *(_DWORD *)(a2 + 24);
      if (v21 == v22) {
        goto LABEL_26;
      }
      uint64_t v23 = *v17;
      if (v23 == LiveDebugValues::ValueIDNum::EmptyValue) {
        goto LABEL_25;
      }
    }
    if (v11)
    {
      for (uint64_t j = 0; j != v11; ++j)
      {
        if (*(void *)(*(void *)(*a5 + 8 * v14) + 8 * j) == v23)
        {
          int v25 = (char *)v59 + 32 * v60;
          unint64_t v26 = *((unsigned int *)v25 - 6);
          if (v26 >= *((unsigned int *)v25 - 5)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*((void *)v25 - 4) + 4 * v26) = j;
          ++*((_DWORD *)v25 - 6);
        }
      }
    }
LABEL_32:
    uint64_t v7 = v16;
    uint64_t v6 = v48;
    ++v12;
  }
  while (v12 != &v49[v16]);
  if (v57)
  {
    uint64_t v31 = (char *)v56;
    uint64_t v32 = 8 * v57;
    while (**(void **)v31 == **(void **)v56
         && *(unsigned __int8 *)(*(void *)v31 + 8) == *(unsigned __int8 *)(*(void *)v56 + 8))
    {
      v31 += 8;
      v32 -= 8;
      if (!v32) {
        goto LABEL_38;
      }
    }
LABEL_71:
    LOBYTE(v42) = 0;
    unint64_t v43 = 0;
  }
  else
  {
LABEL_38:
    char v53 = v55;
    uint64_t v54 = 0x400000000;
    if (*((_DWORD *)v59 + 2)) {
      sub_1CD59F0BC((uint64_t)&v53, (uint64_t)v59);
    }
    if (v60 >= 2)
    {
      unint64_t v33 = 1;
      do
      {
        uint64_t v34 = (char *)v59 + 32 * v33;
        v51[0] = v52;
        v51[1] = (void *)0x400000000;
        uint64_t v35 = *((unsigned int *)v34 + 2);
        if (v54) {
          BOOL v36 = v35 == 0;
        }
        else {
          BOOL v36 = 1;
        }
        if (!v36)
        {
          char v37 = (char *)v53;
          int v38 = (char *)v53 + 4 * v54;
          uint64_t v39 = *(_DWORD **)v34;
          uint64_t v40 = *(void *)v34 + 4 * v35;
          uint64_t v41 = v52;
          do
          {
            if (*(_DWORD *)v37 >= *v39)
            {
              if (*v39 >= *(_DWORD *)v37)
              {
                int v50 = *(_DWORD *)v37;
                uint64_t v41 = (unsigned char *)(sub_1CD4231B4((uint64_t *)v51, (uint64_t)v41, &v50) + 4);
                v37 += 4;
              }
              ++v39;
            }
            else
            {
              v37 += 4;
            }
          }
          while (v37 != v38 && v39 != (_DWORD *)v40);
        }
        sub_1CD59F0BC((uint64_t)&v53, (uint64_t)v51);
        if (v51[0] != v52) {
          free(v51[0]);
        }
        ++v33;
      }
      while (v33 < v60);
    }
    if (v54)
    {
      int v42 = *(_DWORD *)(a2 + 24);
      unint64_t v43 = *(void *)&v42 & 0xFFF00 | ((unint64_t)*(unsigned int *)v53 << 40);
    }
    else
    {
      LOBYTE(v42) = 0;
      unint64_t v43 = 0;
    }
    if (v53 != v55) {
      free(v53);
    }
  }
LABEL_60:
  if (v56 != v58) {
    free(v56);
  }
  char v44 = (char *)v59;
  if (v60)
  {
    uint64_t v45 = 32 * v60;
    do
    {
      BOOL v46 = *(char **)&v44[v45 - 32];
      if (&v44[v45 - 16] != v46) {
        free(v46);
      }
      v45 -= 32;
    }
    while (v45);
    char v44 = (char *)v59;
  }
  if (v44 != v6) {
    free(v44);
  }
  return v43 | v42;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::vlocJoin(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  v56[8] = *MEMORY[0x1E4F143B8];
  BOOL v10 = *(char **)(a2 + 64);
  uint64_t v11 = *(char **)(a2 + 72);
  uint64_t v54 = v56;
  uint64_t v55 = 0x800000000;
  sub_1CB91FB58((uint64_t)&v54, v10, v11);
  uint64_t v51 = a1;
  unint64_t v12 = 126 - 2 * __clz(v55);
  if (v55) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  sub_1CC4E6F50((uint64_t)v54, &v54[v55], &v51, v13, 1);
  uint64_t v51 = (void *)a2;
  unsigned int v14 = *((_DWORD *)sub_1CD41D7A0(a1 + 72, &v51) + 2);
  uint64_t v51 = v53;
  uint64_t v52 = 0x800000000;
  if (v55)
  {
    uint64_t v46 = a5;
    LODWORD(v15) = 0;
    uint64_t v16 = v54;
    uint64_t v17 = 8 * v55;
    do
    {
      uint64_t v50 = *v16;
      int v18 = sub_1CB896AE8((uint64_t)a4, v50);
      uint64_t v19 = a4[1];
      if (v19 == *a4) {
        int v20 = (unsigned int *)a4 + 5;
      }
      else {
        int v20 = (unsigned int *)(a4 + 2);
      }
      if (v18 == (void *)(v19 + 8 * *v20)) {
        goto LABEL_46;
      }
      *(void *)&v47[0] = 0;
      int v21 = sub_1CD40EA84(*(void *)a3, *(_DWORD *)(a3 + 16), v50, v47);
      uint64_t v22 = *(void *)&v47[0];
      if (!v21) {
        uint64_t v22 = *(void *)a3 + 16 * *(unsigned int *)(a3 + 16);
      }
      uint64_t v23 = *(void *)(v22 + 8);
      if (*((_DWORD *)sub_1CD41D7A0(a1 + 72, &v50) + 2) >= v14) {
        uint64_t v15 = v15;
      }
      else {
        uint64_t v15 = (v15 + 1);
      }
      if (v52 >= (unint64_t)HIDWORD(v52)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unsigned int v24 = (char *)v51 + 16 * v52;
      void *v24 = v50;
      v24[1] = v23;
      uint64_t v25 = (v52 + 1);
      LODWORD(v52) = v52 + 1;
      ++v16;
      v17 -= 8;
    }
    while (v17);
    if (!v25)
    {
LABEL_46:
      uint64_t v37 = 0;
      goto LABEL_47;
    }
    unint64_t v26 = (char *)v51;
    uint64_t v27 = *((void *)v51 + 1);
    if (*(_DWORD *)(v46 + 72) == 3 && *(_DWORD *)(v46 + 48) == *(_DWORD *)(a2 + 24))
    {
      uint64_t v28 = 0;
      uint64_t v29 = (char *)v51 + 16 * v25;
      uint64_t v30 = 16 * v25;
      while (1)
      {
        uint64_t v31 = *(void *)((char *)v51 + v28 + 8);
        if (*(void *)(v31 + 56) != *(void *)(v27 + 56)
          || *(unsigned __int8 *)(v31 + 64) != *(unsigned __int8 *)(v27 + 64))
        {
          goto LABEL_46;
        }
        int v32 = *(_DWORD *)(v31 + 72);
        if (v32 == 2)
        {
          if (*(_DWORD *)(v27 + 72) != 2) {
            goto LABEL_46;
          }
        }
        else if (v32 == 4)
        {
          goto LABEL_46;
        }
        v28 += 16;
        if (v30 == v28)
        {
          char v33 = 0;
LABEL_29:
          uint64_t v34 = v26;
          v26 += 16;
          do
          {
            if (!sub_1CD5964D4(*((void *)v26 - 1), v27))
            {
              uint64_t v35 = *((void *)v26 - 1);
              if (*(_DWORD *)(v35 + 72) != 3
                || *(_DWORD *)(v35 + 48) != *(_DWORD *)(a2 + 24)
                || v15 > (v34 - (unsigned char *)v51) >> 4)
              {
                char v33 = 1;
                if (v26 != v29) {
                  goto LABEL_29;
                }
                goto LABEL_41;
              }
            }
            v34 += 16;
            BOOL v36 = v26 == v29;
            v26 += 16;
          }
          while (!v36);
          if (v33)
          {
LABEL_41:
            int v38 = *(_DWORD *)(a2 + 24);
            *(void *)&v47[0] = LiveDebugValues::ValueIDNum::EmptyValue;
            BYTE8(v47[0]) = 0;
            BYTE8(v4sub_1CD521E44((uint64_t)this + 8) = 0;
            *(_DWORD *)uint64_t v49 = v38;
            *(_OWORD *)&v49[8] = *(_OWORD *)(v27 + 56);
            *(_DWORD *)&v49[24] = 3;
            BOOL v39 = sub_1CD5964D4(v46, (uint64_t)v47);
            uint64_t v37 = !v39;
            if (!v39)
            {
              long long v40 = *(_OWORD *)v49;
              *(_OWORD *)(v46 + 32) = v48;
              *(_OWORD *)(v46 + 4sub_1CD521E44((uint64_t)this + 8) = v40;
              *(_OWORD *)(v46 + 60) = *(_OWORD *)&v49[12];
              long long v41 = v47[1];
              *(_OWORD *)uint64_t v46 = v47[0];
              *(_OWORD *)(v46 + 16) = v41;
            }
            goto LABEL_47;
          }
          if (!sub_1CD5964D4(v46, v27)) {
            goto LABEL_52;
          }
          goto LABEL_46;
        }
      }
    }
    if (sub_1CD5964D4(v46, *((void *)v51 + 1)))
    {
      uint64_t v37 = 0;
    }
    else
    {
LABEL_52:
      *(_OWORD *)uint64_t v46 = *(_OWORD *)v27;
      long long v43 = *(_OWORD *)(v27 + 16);
      long long v44 = *(_OWORD *)(v27 + 32);
      long long v45 = *(_OWORD *)(v27 + 48);
      *(_OWORD *)(v46 + 60) = *(_OWORD *)(v27 + 60);
      *(_OWORD *)(v46 + 32) = v44;
      *(_OWORD *)(v46 + 4sub_1CD521E44((uint64_t)this + 8) = v45;
      *(_OWORD *)(v46 + 16) = v43;
      uint64_t v37 = 1;
    }
  }
  else
  {
    uint64_t v37 = 0;
  }
LABEL_47:
  if (v51 != v53) {
    free(v51);
  }
  if (v54 != v56) {
    free(v54);
  }
  return v37;
}

BOOL sub_1CD5964D4(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 != *(_DWORD *)(a2 + 72)
    || *(void *)(a1 + 56) != *(void *)(a2 + 56)
    || *(unsigned __int8 *)(a1 + 64) != *(unsigned __int8 *)(a2 + 64))
  {
    return 0;
  }
  switch(v2)
  {
    case 1:
      goto LABEL_6;
    case 2:
      return llvm::MachineOperand::isIdenticalTo((llvm::MachineOperand *)(a1 + 8), (const llvm::MachineOperand *)(a2 + 8));
    case 3:
      if (*(_DWORD *)(a1 + 48) != *(_DWORD *)(a2 + 48)) {
        return 0;
      }
LABEL_6:
      if (*(void *)a1 == *(void *)a2) {
        goto LABEL_12;
      }
      return 0;
    case 4:
      if (*(_DWORD *)(a1 + 48) != *(_DWORD *)(a2 + 48)) {
        return 0;
      }
      goto LABEL_12;
    default:
LABEL_12:
      BOOL result = 1;
      break;
  }
  return result;
}

uint64_t LiveDebugValues::InstrRefBasedLDV::getBlocksForScope(int8x8_t *a1, uint64_t a2, unsigned int *a3, void *a4)
{
  v57[16] = *MEMORY[0x1E4F143B8];
  llvm::LexicalScopes::getMachineBasicBlocks(a1 + 16, a2, (llvm::SmallPtrSetImplBase *)a3);
  uint64_t v7 = (uint64_t *)a4[1];
  if (v7 == (uint64_t *)*a4) {
    unsigned int v8 = (unsigned int *)a4 + 5;
  }
  else {
    unsigned int v8 = (unsigned int *)(a4 + 2);
  }
  uint64_t v9 = *v8;
  BOOL v10 = &v7[v9];
  if (v9)
  {
    uint64_t v20 = 8 * v9;
    while ((unint64_t)*v7 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v7;
      v20 -= 8;
      if (!v20)
      {
        uint64_t v7 = v10;
        break;
      }
    }
  }
  sub_1CD596984((llvm::SmallPtrSetImplBase *)a3, v7, v10, v10);
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  unsigned int v53 = 0;
  uint64_t v11 = *((void *)a3 + 1);
  if (v11 == *(void *)a3) {
    unint64_t v12 = a3 + 5;
  }
  else {
    unint64_t v12 = a3 + 4;
  }
  uint64_t v13 = *v12;
  if (v13)
  {
    uint64_t v21 = 8 * v13;
    unsigned int v14 = (unint64_t *)*((void *)a3 + 1);
    while (*v14 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v14;
      v21 -= 8;
      if (!v21) {
        goto LABEL_11;
      }
    }
  }
  else
  {
    unsigned int v14 = (unint64_t *)*((void *)a3 + 1);
  }
  uint64_t v15 = (unint64_t *)(v11 + 8 * v13);
  if (v14 == v15)
  {
LABEL_11:
    unsigned int v16 = 0;
    uint64_t v17 = 0;
LABEL_12:
    v17 += v16;
    int v18 = v17;
    goto LABEL_13;
  }
  unint64_t v22 = *v14;
LABEL_23:
  uint64_t v55 = v57;
  uint64_t v56 = 0x800000000;
  uint64_t v23 = *(uint64_t **)(v22 + 88);
  unsigned int v24 = *(uint64_t **)(v22 + 96);
  if (v23 != v24)
  {
    do
    {
      uint64_t v50 = 0;
      uint64_t v50 = *v23;
      uint64_t v25 = sub_1CB896AE8((uint64_t)a3, v50);
      uint64_t v26 = *((void *)a3 + 1);
      if (v26 == *(void *)a3) {
        uint64_t v27 = a3 + 5;
      }
      else {
        uint64_t v27 = a3 + 4;
      }
      if (v25 == (void *)(v26 + 8 * *v27))
      {
        uint64_t v28 = sub_1CB896AE8((uint64_t)&a1[49], v50);
        int8x8_t v29 = a1[50];
        uint64_t v30 = *(void *)&v29 == *(void *)&a1[49] ? 412 : 408;
        if (v28 != (void *)(*(void *)&v29 + 8 * *(unsigned int *)((char *)a1->u32 + v30)))
        {
          sub_1CD484194((uint64_t)v54, (uint64_t)&v51, &v50);
          uint64_t v31 = *(void *)(v50 + 88);
          if (v56 >= (unint64_t)HIDWORD(v56)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          int v32 = (char *)v55 + 16 * v56;
          *int v32 = v50;
          v32[1] = v31;
          LODWORD(v56) = v56 + 1;
        }
      }
      ++v23;
    }
    while (v23 != v24);
    unsigned int v33 = v56;
    while (1)
    {
      while (1)
      {
        if (!v33) {
          goto LABEL_49;
        }
        uint64_t v34 = (char *)v55 + 16 * v33;
        uint64_t v35 = (uint64_t *)*((void *)v34 - 1);
        if (v35 != *(uint64_t **)(*((void *)v34 - 2) + 96)) {
          break;
        }
        LODWORD(v56) = --v33;
      }
      uint64_t v36 = *v35;
      if (v53)
      {
        unsigned int v37 = ((v36 >> 4) ^ (v36 >> 9)) & (v53 - 1);
        uint64_t v38 = v51[v37];
        if (v36 == v38) {
          goto LABEL_40;
        }
        int v48 = 1;
        while (v38 != -4096)
        {
          unsigned int v49 = v37 + v48++;
          unsigned int v37 = v49 & (v53 - 1);
          uint64_t v38 = v51[v37];
          if (v36 == v38) {
            goto LABEL_40;
          }
        }
      }
      BOOL v39 = sub_1CB896AE8((uint64_t)&a1[49], v36);
      int8x8_t v40 = a1[50];
      if (*(void *)&v40 == *(void *)&a1[49]) {
        uint64_t v41 = 103;
      }
      else {
        uint64_t v41 = 102;
      }
      uint64_t v35 = (uint64_t *)*((void *)v34 - 1);
      if (v39 == (void *)(*(void *)&v40 + 8 * a1->u32[v41]))
      {
        unsigned int v33 = v56;
LABEL_40:
        *((void *)v34 - 1) = v35 + 1;
      }
      else
      {
        sub_1CD484194((uint64_t)v54, (uint64_t)&v51, v35);
        uint64_t v42 = **((void **)v34 - 1);
        uint64_t v43 = *(void *)(v42 + 88);
        if (v56 >= (unint64_t)HIDWORD(v56)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        long long v44 = (char *)v55 + 16 * v56;
        *long long v44 = v42;
        v44[1] = v43;
        unsigned int v33 = v56 + 1;
        LODWORD(v56) = v56 + 1;
      }
    }
  }
LABEL_49:
  if (v55 != v57) {
    free(v55);
  }
  long long v45 = v14 + 1;
  while (v45 != v15)
  {
    unint64_t v46 = *v45++;
    unint64_t v22 = v46;
    if (v46 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      unsigned int v14 = v45 - 1;
      goto LABEL_23;
    }
  }
  uint64_t v17 = v51;
  unsigned int v16 = v53;
  if (!v52) {
    goto LABEL_12;
  }
  int v18 = &v51[v53];
  if (v53)
  {
    uint64_t v47 = 8 * v53;
    while ((*v17 | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      ++v17;
      v47 -= 8;
      if (!v47)
      {
        uint64_t v17 = &v51[v53];
        break;
      }
    }
  }
LABEL_13:
  sub_1CD5969F8((llvm::SmallPtrSetImplBase *)a3, v17, v18, v18);
  return MEMORY[0x1D25D9CD0](v51, 8);
}

llvm::SmallPtrSetImplBase *sub_1CD596984(llvm::SmallPtrSetImplBase *this, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (a2 != a4)
  {
    uint64_t v6 = a2;
    uint64_t v7 = this;
    do
    {
      uint64_t v9 = *v6;
      unsigned int v8 = (unint64_t *)(v6 + 1);
      this = (llvm::SmallPtrSetImplBase *)sub_1CB89694C(v7, v9);
      while (v8 != (unint64_t *)a3)
      {
        unint64_t v10 = *v8++;
        if (v10 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v6 = (uint64_t *)(v8 - 1);
          goto LABEL_8;
        }
      }
      uint64_t v6 = a3;
LABEL_8:
      ;
    }
    while (v6 != a4);
  }
  return this;
}

llvm::SmallPtrSetImplBase *sub_1CD5969F8(llvm::SmallPtrSetImplBase *this, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (a2 != a4)
  {
    uint64_t v6 = a2;
    uint64_t v7 = this;
    do
    {
      uint64_t v8 = *v6++;
      this = (llvm::SmallPtrSetImplBase *)sub_1CB89694C(v7, v8);
      while (v6 != a3)
      {
        if ((*v6 | 0x1000) != 0xFFFFFFFFFFFFF000) {
          goto LABEL_8;
        }
        ++v6;
      }
      uint64_t v6 = a3;
LABEL_8:
      ;
    }
    while (v6 != a4);
  }
  return this;
}

void LiveDebugValues::InstrRefBasedLDV::buildVLocValueMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (int8x8_t *)MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = (uint64_t)v4;
  v140[8] = *MEMORY[0x1E4F143B8];
  v124 = 0;
  v123 = 0;
  uint64_t v125 = 0;
  v121 = 0;
  std::string __p = 0;
  uint64_t v122 = 0;
  v115 = v119;
  v116 = v119;
  uint64_t v117 = 16;
  int v118 = 0;
  v110 = v114;
  v111 = v114;
  uint64_t v112 = 16;
  int v113 = 0;
  v105 = (unint64_t *)v109;
  v106 = v109;
  uint64_t v107 = 8;
  int v108 = 0;
  v138 = v140;
  uint64_t v139 = 0x800000000;
  LiveDebugValues::InstrRefBasedLDV::getBlocksForScope(v4, v10, (unsigned int *)&v105, v11);
  LODWORD(v12) = HIDWORD(v107);
  if (HIDWORD(v107) - v108 != 1)
  {
    unsigned int v100 = v104;
    v101 = v104;
    uint64_t v102 = 8;
    int v103 = 0;
    uint64_t v13 = (unint64_t *)v106;
    unsigned int v14 = v105;
    unsigned int v15 = v107;
    if (v106 == v105) {
      uint64_t v16 = HIDWORD(v107);
    }
    else {
      uint64_t v16 = v107;
    }
    uint64_t v17 = (uint64_t *)v106;
    if (v16)
    {
      uint64_t v22 = 0;
      while (*(void *)((char *)v106 + v22) >= 0xFFFFFFFFFFFFFFFELL)
      {
        v22 += 8;
        if (8 * v16 == v22) {
          goto LABEL_30;
        }
      }
      uint64_t v17 = (uint64_t *)((char *)v106 + v22);
    }
    int v18 = (uint64_t *)((char *)v106 + 8 * v16);
    if (v17 != v18)
    {
      uint64_t v19 = *v17;
LABEL_21:
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v100, v19);
      uint64_t v20 = (unint64_t *)(v17 + 1);
      while (v20 != (unint64_t *)v18)
      {
        unint64_t v21 = *v20++;
        uint64_t v19 = v21;
        if (v21 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v17 = (uint64_t *)(v20 - 1);
          goto LABEL_21;
        }
      }
      uint64_t v13 = (unint64_t *)v106;
      unsigned int v14 = v105;
      LODWORD(v12) = HIDWORD(v107);
      unsigned int v15 = v107;
    }
LABEL_30:
    if (v13 == v14) {
      uint64_t v12 = v12;
    }
    else {
      uint64_t v12 = v15;
    }
    uint64_t v23 = v13;
    if (v12)
    {
      uint64_t v24 = 8 * v12;
      uint64_t v23 = v13;
      while (*v23 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v23;
        v24 -= 8;
        if (!v24)
        {
          unsigned int v25 = v139;
          goto LABEL_45;
        }
      }
    }
    uint64_t v26 = &v13[v12];
    unsigned int v25 = v139;
    if (v23 != v26)
    {
      unint64_t v27 = *v23;
LABEL_40:
      if (v25 >= HIDWORD(v139)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v138[v25] = v27;
      unsigned int v25 = v139 + 1;
      LODWORD(v139) = v139 + 1;
      uint64_t v28 = v23 + 1;
      while (v28 != v26)
      {
        unint64_t v29 = *v28++;
        unint64_t v27 = v29;
        if (v29 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v23 = v28 - 1;
          goto LABEL_40;
        }
      }
    }
LABEL_45:
    v135 = (void *)v9;
    unint64_t v30 = 126 - 2 * __clz(v25);
    if (v25) {
      uint64_t v31 = v30;
    }
    else {
      uint64_t v31 = 0;
    }
    sub_1CC4E8110((uint64_t)v138, &v138[v25], &v135, v31, 1);
    int v32 = v139;
    v135 = v137;
    uint64_t v136 = 0x2000000000;
    v132 = v134;
    uint64_t v133 = 0x2000000000;
    if (v139 >= 0x21) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v84 = v139;
    uint64_t v78 = *(void *)(v9 + 344);
    if (v139)
    {
      int v33 = 0;
      do
      {
        uint64_t v86 = (uint64_t *)LiveDebugValues::ValueIDNum::EmptyValue;
        LOBYTE(v87) = 0;
        v90[8] = 0;
        int v91 = v33;
        uint64_t v92 = v78;
        char v93 = 0;
        v94[0] = *(_DWORD *)v99;
        *(_DWORD *)((char *)v94 + 3) = *(_DWORD *)&v99[3];
        *(_DWORD *)((char *)&v94[1] + 3) = 4;
        uint64_t v34 = (_OWORD *)sub_1CD59F188((uint64_t)&v135, (unint64_t)&v86);
        uint64_t v35 = (char *)v135 + 80 * v136;
        *uint64_t v35 = *v34;
        long long v36 = v34[4];
        long long v37 = v34[1];
        long long v38 = v34[2];
        v35[3] = v34[3];
        void v35[4] = v36;
        v35[1] = v37;
        void v35[2] = v38;
        LODWORD(v136) = v136 + 1;
        BOOL v39 = (_OWORD *)sub_1CD59F188((uint64_t)&v132, (unint64_t)&v86);
        int8x8_t v40 = (char *)v132 + 80 * v133;
        _OWORD *v40 = *v39;
        long long v41 = v39[4];
        long long v42 = v39[1];
        long long v43 = v39[2];
        void v40[3] = v39[3];
        v40[4] = v41;
        v40[1] = v42;
        v40[2] = v43;
        LODWORD(v133) = v133 + 1;
        ++v33;
      }
      while (v84 != v33);
      char v44 = 0;
      int v32 = v84;
    }
    else
    {
      char v44 = 1;
    }
    v97[1] = 0;
    v97[0] = 0;
    int v98 = 0;
    v95[1] = 0;
    v95[0] = 0;
    int v96 = 0;
    sub_1CD597934(v97, v32);
    sub_1CD597934(v95, v32);
    char v82 = v44;
    if ((v44 & 1) == 0)
    {
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v47 = v84;
      do
      {
        int v48 = (char *)v132 + v45;
        sub_1CD467E2C((uint64_t)v97, &v138[v46])[1] = v48;
        unsigned int v49 = (char *)v135 + v45;
        sub_1CD467E2C((uint64_t)v95, &v138[v46++])[1] = v49;
        v45 += 80;
        --v47;
      }
      while (v47);
    }
    uint64_t v50 = *(void *)(v8 + 192);
    if (v50) {
      uint64_t v51 = *(uint64_t **)(v8 + 176);
    }
    else {
      uint64_t v51 = *(uint64_t **)v8;
    }
    uint64_t v79 = *(void *)v8 + 40 * *(unsigned int *)(v8 + 8);
    uint64_t v80 = v8 + 184;
    uint64_t v52 = v84;
    unsigned int v53 = &unk_1EBD06000;
    uint64_t v81 = v50;
    while (1)
    {
      uint64_t v54 = (uint64_t *)(v50 ? v80 : v79);
      if (v51 == v54) {
        break;
      }
      uint64_t v55 = v51 + 4;
      if (!v50) {
        uint64_t v55 = v51;
      }
      __int16 v85 = v55;
      if ((v82 & 1) == 0)
      {
        uint64_t v56 = 0;
        uint64_t v57 = 72;
        do
        {
          uint64_t v58 = v53[129];
          uint64_t v59 = (char *)v135 + v57;
          *((void *)v59 - 9) = v58;
          *((unsigned char *)v59 - 64) = 0;
          *((unsigned char *)v59 - 32) = 0;
          *(v59 - 6) = v56;
          *((void *)v59 - 2) = v78;
          *((unsigned char *)v59 - sub_1CD521E44((uint64_t)this + 8) = 0;
          *(v59 - 1) = *(_DWORD *)&v99[3];
          *uint64_t v59 = 4;
          *(_DWORD *)((char *)v59 - 7) = *(_DWORD *)v99;
          uint64_t v60 = (char *)v132 + v57;
          *((void *)v60 - 9) = v58;
          *((unsigned char *)v60 - 64) = 0;
          *((unsigned char *)v60 - 32) = 0;
          *(v60 - 6) = v56;
          *((void *)v60 - 2) = v78;
          *((unsigned char *)v60 - sub_1CD521E44((uint64_t)this + 8) = 0;
          *(v60 - 1) = *(_DWORD *)&v99[3];
          _DWORD *v60 = 4;
          *(_DWORD *)((char *)v60 - 7) = *(_DWORD *)v99;
          ++v56;
          v57 += 80;
        }
        while (v52 != v56);
      }
      uint64_t v86 = (uint64_t *)v90;
      uint64_t v87 = (uint64_t *)v90;
      uint64_t v88 = 32;
      int v89 = 0;
      if (v106 == v105) {
        uint64_t v61 = (uint64_t *)((char *)&v107 + 4);
      }
      else {
        uint64_t v61 = &v107;
      }
      uint64_t v62 = *(unsigned int *)v61;
      uint64_t v83 = v51;
      if (v62)
      {
        uint64_t v71 = 8 * v62;
        uint64_t v63 = (uint64_t *)v106;
        while ((unint64_t)*v63 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v63;
          v71 -= 8;
          if (!v71) {
            goto LABEL_75;
          }
        }
      }
      else
      {
        uint64_t v63 = (uint64_t *)v106;
      }
      uint64_t v64 = (unint64_t *)((char *)v106 + 8 * v62);
      if (v63 == (uint64_t *)v64)
      {
LABEL_75:
        int v65 = 0;
        LODWORD(v66) = 0;
      }
      else
      {
        uint64_t v72 = *v63;
LABEL_99:
        uint64_t v73 = *v6 + 472 * *(int *)(v72 + 24);
        if (*(void *)(v73 + 32) != sub_1CD597980(v73, v85)) {
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v86, v72);
        }
        uint64_t v74 = (unint64_t *)(v63 + 1);
        while (v74 != v64)
        {
          unint64_t v75 = *v74++;
          uint64_t v72 = v75;
          if (v75 <= 0xFFFFFFFFFFFFFFFDLL)
          {
            uint64_t v63 = (uint64_t *)(v74 - 1);
            goto LABEL_99;
          }
        }
        LODWORD(v66) = HIDWORD(v88);
        int v65 = v89;
      }
      v129 = v131;
      uint64_t v130 = 0x2000000000;
      if (v66 - v65 != 1)
      {
        v126[0] = (void *)sub_1CC2DC358(*(llvm::MachineDominatorTree **)(v9 + 8));
        BYTE1(v126[1]) = 1;
        v127 = &v100;
        v128 = &v86;
        sub_1CD595820();
      }
      int v67 = v87;
      if (v87 == v86) {
        uint64_t v66 = v66;
      }
      else {
        uint64_t v66 = v88;
      }
      if (v66)
      {
        uint64_t v76 = 8 * v66;
        uint64_t v77 = &v87[v66];
        while ((unint64_t)*v67 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v67;
          v76 -= 8;
          if (!v76)
          {
            int v67 = v77;
            break;
          }
        }
      }
      LiveDebugValues::InstrRefBasedLDV::placePHIsForSingleVarDefinition(v9, &v100, *v67, v6, v85);
      if (v129 != v131) {
        free(v129);
      }
      uint64_t v52 = v84;
      unsigned int v53 = (void *)&unk_1EBD06000;
      uint64_t v50 = v81;
      if (v87 != v86) {
        free(v87);
      }
      if (v81)
      {
        uint64_t v68 = v83;
        uint64_t v69 = (uint64_t *)v83[1];
        if (v69)
        {
          do
          {
            uint64_t v51 = v69;
            uint64_t v69 = (uint64_t *)*v69;
          }
          while (v69);
        }
        else
        {
          do
          {
            uint64_t v51 = (uint64_t *)v68[2];
            BOOL v70 = *v51 == (void)v68;
            uint64_t v68 = v51;
          }
          while (!v70);
        }
      }
      else
      {
        uint64_t v51 = v83 + 5;
      }
    }
    LODWORD(v139) = 0;
    sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v105);
    MEMORY[0x1D25D9CD0](v95[0], 8);
    MEMORY[0x1D25D9CD0](v97[0], 8);
    if (v132 != v134) {
      free(v132);
    }
    if (v135 != v137) {
      free(v135);
    }
    if (v101 != v100) {
      free(v101);
    }
  }
  if (v138 != v140) {
    free(v138);
  }
  if (v106 != v105) {
    free(v106);
  }
  if (v111 != v110) {
    free(v111);
  }
  if (v116 != v115) {
    free(v116);
  }
  if (__p)
  {
    v121 = __p;
    operator delete(__p);
  }
  if (v123)
  {
    v124 = v123;
    operator delete(v123);
  }
}

void *sub_1CD597934(void *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (*((_DWORD *)result + 4) <= v4) {
      return sub_1CD467F4C((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

uint64_t sub_1CD597980(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = 0;
  if (sub_1CC2E9354(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5)) {
    BOOL v3 = v5 == *(void *)a1 + 48 * *(unsigned int *)(a1 + 16);
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + 120 * *(unsigned int *)(v5 + 40);
  }
}

uint64_t LiveDebugValues::InstrRefBasedLDV::placePHIsForSingleVarDefinition(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t *a5)
{
  uint64_t result = sub_1CD597980(*a4 + 472 * *(int *)(a3 + 24), a5);
  if (*(_DWORD *)(result + 112))
  {
    uint64_t v8 = a2[1];
    if (v8 == *a2) {
      uint64_t v9 = (unsigned int *)a2 + 5;
    }
    else {
      uint64_t v9 = (unsigned int *)(a2 + 2);
    }
    uint64_t v10 = *v9;
    if (v10)
    {
      uint64_t v11 = 8 * v10;
      for (uint64_t i = (void *)a2[1]; *i >= 0xFFFFFFFFFFFFFFFELL; ++i)
      {
        v11 -= 8;
        if (!v11) {
          return result;
        }
      }
    }
    else
    {
      uint64_t i = (void *)a2[1];
    }
    if (i != (void *)(v8 + 8 * v10))
    {
      llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 8));
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::properlyDominates();
    }
  }
  return result;
}

void LiveDebugValues::InstrRefBasedLDV::dump_mloc_transfer(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = sub_1CD5957AC((_DWORD *)a2);
  if (*(_DWORD *)a2) {
    uint64_t v6 = a2 + 8;
  }
  else {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  unsigned int v7 = *(_DWORD *)(a2 + 16);
  if (*(_DWORD *)a2) {
    unsigned int v7 = 4;
  }
  uint64_t v8 = (unsigned int *)(v6 + 16 * v7);
  if (v8 != v4)
  {
    uint64_t v9 = v4;
    uint64_t v10 = v5;
    do
    {
      LiveDebugValues::MLocTracker::LocIdxToName(*(void *)(a1 + 352), *v9, &v25);
      LiveDebugValues::MLocTracker::IDAsString(*(void *)(a1 + 352), (unint64_t *)v9 + 1, __p);
      uint64_t v12 = llvm::dbgs(v11);
      uint64_t v13 = sub_1CB8E509C(v12, "Loc ");
      if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned int v14 = &v25;
      }
      else {
        unsigned int v14 = (std::string *)v25.__r_.__value_.__r.__words[0];
      }
      if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = *((unsigned char *)&v25.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t size = v25.__r_.__value_.__l.__size_;
      }
      uint64_t v16 = llvm::raw_ostream::write(v13, (const char *)v14, size);
      uint64_t v17 = sub_1CB8E509C(v16, " --> ");
      if (v24 >= 0) {
        int v18 = __p;
      }
      else {
        int v18 = (void **)__p[0];
      }
      if (v24 >= 0) {
        size_t v19 = v24 & 0x7F;
      }
      else {
        size_t v19 = (size_t)__p[1];
      }
      uint64_t v20 = llvm::raw_ostream::write(v17, (const char *)v18, v19);
      sub_1CB8E509C(v20, "\n");
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v25.__r_.__value_.__l.__data_);
      }
      unint64_t v21 = v9 + 4;
      while (v21 != v10)
      {
        unsigned int v22 = *v21;
        v21 += 4;
        if (v22 <= 0xFFFFFFFD)
        {
          uint64_t v9 = v21 - 4;
          goto LABEL_29;
        }
      }
      uint64_t v9 = v10;
LABEL_29:
      ;
    }
    while (v9 != v8);
  }
}

uint64_t LiveDebugValues::InstrRefBasedLDV::ExtendRanges(LiveDebugValues::InstrRefBasedLDV *this, llvm::MachineFunction *a2, llvm::MachineDominatorTree *a3, llvm::TargetPassConfig *a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](this, a2, a3, a4);
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v4;
  if (llvm::Function::getSubprogram(*v9))
  {
    *(void *)(v11 + 336) = v6;
    *(void *)(v11 + sub_1CD521E44((uint64_t)this + 8) = v8;
    *(void *)(v11 + 16) = (*(uint64_t (**)(llvm::Function *))(*(void *)v10[2] + 176))(v10[2]);
    *(void *)(v11 + 24) = v10[5];
    *(void *)(v11 + 32) = (*(uint64_t (**)(llvm::Function *))(*(void *)v10[2] + 104))(v10[2]);
    uint64_t v13 = (*(uint64_t (**)(llvm::Function *))(*(void *)v10[2] + 112))(v10[2]);
    *(void *)(v11 + 40) = v13;
    (*(void (**)(void))(*(void *)v13 + 256))();
    *(void *)(v11 + 4sub_1CD521E44((uint64_t)this + 8) = v10[7];
    llvm::LexicalScopes::initialize((llvm::LexicalScopes *)(v11 + 128), (uint64_t ****)v10);
    if (*(unsigned char *)(*(void *)(v11 + 48) + 61))
    {
      unsigned int v14 = v10[2];
      uint64_t v15 = (*(uint64_t (**)(llvm::Function *))(*(void *)v14 + 112))(v14);
      int v16 = (*(uint64_t (**)(uint64_t))(*(void *)v15 + 152))(v15);
      *(unsigned char *)(v11 + 2016) = v16;
      if (v16)
      {
        uint64_t v17 = (*(uint64_t (**)(llvm::Function *))(*(void *)v14 + 120))(v14);
        *(void *)(v11 + 2024) = (*(uint64_t (**)(uint64_t, llvm::Function **))(*(void *)v17 + 832))(v17, v10);
        *(void *)(v11 + 2032) = v18;
      }
    }
    else
    {
      *(unsigned char *)(v11 + 2016) = 0;
    }
    operator new();
  }
  return 0;
}

void *sub_1CD5987A8(void *result, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = *((unsigned int *)result + 2);
  BOOL v5 = a2 >= v4;
  uint64_t v6 = a2 - v4;
  if (v6)
  {
    uint64_t v7 = result;
    if (v5)
    {
      return (void *)sub_1CD59FAB0((uint64_t)result, v6, a3);
    }
    else
    {
      uint64_t v8 = *result + 472 * v4 - 472;
      uint64_t v9 = 472 * a2 - 472 * v4;
      do
      {
        if ((*(unsigned char *)(v8 + 48) & 1) == 0) {
          MEMORY[0x1D25D9CD0](*(void *)(v8 + 56), 8);
        }
        uint64_t result = sub_1CD456CB4((void *)v8);
        v8 -= 472;
        v9 += 472;
      }
      while (v9);
      *((_DWORD *)v7 + 2) = a2;
    }
  }
  return result;
}

unint64_t sub_1CD598850(uint64_t a1, unint64_t *a2)
{
  if (*(void *)(a1 + 192))
  {
    sub_1CD59DFA0(a1 + 176, a2, (uint64_t)a2);
    return ((unint64_t)v10 << 32) | 1;
  }
  else
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5)
    {
      uint64_t v6 = 40 * v5;
      while (!sub_1CC2E9944(v4, (uint64_t)a2))
      {
        v4 += 40;
        v6 -= 40;
        if (!v6)
        {
          uint64_t v4 = *(void *)a1;
          LODWORD(v5) = *(_DWORD *)(a1 + 8);
          goto LABEL_7;
        }
      }
      unsigned int v7 = *(_DWORD *)(a1 + 8);
      uint64_t v8 = *(void *)a1;
      LODWORD(v5) = v7;
    }
    else
    {
LABEL_7:
      unsigned int v7 = v5;
      uint64_t v8 = v4;
      v4 += 40 * v5;
    }
    if (v4 == v8 + 40 * v7)
    {
      if (v5 > 3)
      {
        do
        {
          uint64_t v15 = (unint64_t *)(*(void *)a1 + 40 * v5 - 40);
          sub_1CD59DFA0(a1 + 176, v15, (uint64_t)v15);
          LODWORD(v5) = *(_DWORD *)(a1 + 8) - 1;
          *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v5;
        }
        while (v5);
        sub_1CD59DFA0(a1 + 176, a2, (uint64_t)a2);
      }
      else
      {
        unint64_t v11 = sub_1CD59E054(a1, (unint64_t)a2, 1);
        uint64_t v12 = *(void *)a1 + 40 * *(unsigned int *)(a1 + 8);
        uint64_t v13 = *(void *)(v11 + 32);
        long long v14 = *(_OWORD *)(v11 + 16);
        *(_OWORD *)uint64_t v12 = *(_OWORD *)v11;
        *(_OWORD *)(v12 + 16) = v14;
        *(void *)(v12 + 32) = v13;
        ++*(_DWORD *)(a1 + 8);
      }
      return 0x100000001;
    }
    else
    {
      return 1;
    }
  }
}

void sub_1CD59899C(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (!v2 && !*(_DWORD *)(a1 + 12)) {
    return;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_22:
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
      return;
    }
    uint64_t v4 = 56 * v3;
    uint64_t v5 = *(void *)a1 + 40;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 40);
      if (v6 == -8192)
      {
        if (*(void *)(v5 - 32) == -2 && *(void *)(v5 - 24) == -2) {
          goto LABEL_20;
        }
      }
      else if (v6 == -4096 && *(void *)(v5 - 32) == -1 && *(void *)(v5 - 24) == -1)
      {
        goto LABEL_21;
      }
      uint64_t v9 = *(void **)(v5 - 16);
      if ((void *)v5 != v9) {
        free(v9);
      }
LABEL_20:
      *(void *)(v5 - 40) = -4096;
      *(void *)(v5 - 32) = -1;
      *(void *)(v5 - 24) = -1;
LABEL_21:
      v5 += 56;
      v4 -= 56;
      if (!v4) {
        goto LABEL_22;
      }
    }
  }

  sub_1CD5A0838(a1);
}

void sub_1CD598A98(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 112 * v3;
    uint64_t v5 = *(void *)a1 + 88;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 88);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 112;
      v4 -= 112;
      if (!v4) {
        goto LABEL_12;
      }
    }
    sub_1CD3C5048(v5, *(void **)(v5 + 8));
    unsigned int v7 = *(void **)(v5 - 80);
    if ((void *)(v5 - 64) != v7) {
      free(v7);
    }
LABEL_10:
    *(void *)(v5 - 8sub_1CD521E44((uint64_t)this + 8) = -4096;
    goto LABEL_11;
  }

  sub_1CD5A08F8(a1);
}

_DWORD *sub_1CD598B6C(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD5A09AC(result);
    }
    else
    {
      if (v1)
      {
        int v2 = *(void **)result;
        uint64_t v3 = 24 * v1;
        do
        {
          *int v2 = -4096;
          v2 += 3;
          v3 -= 24;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

void llvm::makeInstrRefBasedLiveDebugValues(llvm *this)
{
}

unint64_t LiveDebugValues::InstrRefBasedLDV::resolveDbgPHIsImpl(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  v270[10] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v10 = sub_1CC4EB200(*(unsigned int **)(a1 + 648), (unsigned int *)(*(void *)(a1 + 648) + 40 * *(unsigned int *)(a1 + 656)), a6);
  if (v10 == v11)
  {
LABEL_7:
    LOBYTE(v14) = 0;
    unint64_t v15 = 0;
    return v15 | v14;
  }
  uint64_t v12 = v11;
  uint64_t v13 = v10;
  do
  {
    if (!*((unsigned char *)v13 + 24)) {
      goto LABEL_7;
    }
    v13 += 10;
  }
  while (v13 != v11);
  if ((char *)v11 - (char *)v10 == 40)
  {
    unint64_t v14 = *((void *)v10 + 2);
    unint64_t v15 = v14 & 0xFFFFFFFFFFFFFF00;
    return v15 | v14;
  }
  uint64_t v17 = v10[8];
  v235 = 0;
  uint64_t v236 = 0;
  unsigned int v237 = 0;
  v238[0] = 0;
  v238[1] = 0;
  int v239 = 0;
  v240 = 0;
  uint64_t v241 = 0;
  unsigned int v242 = 0;
  int v243 = v17;
  uint64_t v244 = a4;
  v233[0] = 0;
  v233[1] = 0;
  int v234 = 0;
  v256 = v258;
  v230 = v10;
  uint64_t v18 = v10;
  uint64_t v257 = 0x800000000;
  do
  {
    size_t v19 = (void *)sub_1CC4E3D64((uint64_t)&v235, *((void *)v18 + 1));
    uint64_t v20 = v19;
    uint64_t v21 = *((void *)v18 + 2);
    v259 = v19;
    uint64_t v260 = v21;
    if (v234)
    {
      unsigned int v22 = (v234 - 1) & ((v19 >> 4) ^ (v19 >> 9));
      uint64_t v23 = (void *)(v233[0] + 16 * v22);
      char v24 = (void *)*v23;
      if (v19 == (void *)*v23) {
        goto LABEL_12;
      }
      v148 = 0;
      int v149 = 1;
      while (v24 != (void *)-4096)
      {
        if (v148) {
          BOOL v192 = 0;
        }
        else {
          BOOL v192 = v24 == (void *)-8192;
        }
        if (v192) {
          v148 = v23;
        }
        unsigned int v193 = v22 + v149++;
        unsigned int v22 = v193 & (v234 - 1);
        uint64_t v23 = (void *)(v233[0] + 16 * v22);
        char v24 = (void *)*v23;
        if (v19 == (void *)*v23) {
          goto LABEL_12;
        }
      }
      if (v148) {
        std::string v25 = v148;
      }
      else {
        std::string v25 = v23;
      }
    }
    else
    {
      std::string v25 = 0;
    }
    uint64_t v26 = sub_1CC4EB2E8((uint64_t)v233, (uint64_t *)&v259, v25);
    *uint64_t v26 = v20;
    v26[1] = v21;
LABEL_12:
    v18 += 10;
  }
  while (v18 != v12);
  uint64_t v27 = sub_1CC4E3D64((uint64_t)&v235, *(void *)(a5 + 24));
  if (v234)
  {
    uint64_t v63 = ((v27 >> 4) ^ (v27 >> 9)) & (v234 - 1);
    uint64_t v64 = *(void *)(v233[0] + 16 * v63);
    if (v27 == v64)
    {
LABEL_94:
      if (v63 != v234)
      {
        unint64_t v14 = *(void *)(v233[0] + 16 * v63 + 8);
        unint64_t v15 = v14 & 0xFFFFFFFFFFFFFF00;
        goto LABEL_69;
      }
    }
    else
    {
      int v190 = 1;
      while (v64 != -4096)
      {
        int v191 = v63 + v190++;
        uint64_t v63 = v191 & (v234 - 1);
        uint64_t v64 = *(void *)(v233[0] + 16 * v63);
        if (v27 == v64) {
          goto LABEL_94;
        }
      }
    }
  }
  v226 = v12;
  uint64_t v227 = v17;
  uint64_t v228 = a3;
  uint64_t v229 = a4;
  v248 = &v235;
  v249 = v233;
  v251[0] = 0;
  v251[1] = 0;
  v250 = &v256;
  int v252 = 0;
  v253[0] = 0;
  v253[1] = 0;
  v253[2] = (uint64_t)v254;
  v253[3] = 0x400000000;
  v254[4] = v255;
  v254[5] = 0;
  v255[0] = 0;
  v255[1] = 1;
  uint64_t v28 = sub_1CC4E3D64((uint64_t)&v235, *(void *)(a5 + 24));
  uint64_t v245 = v28;
  v259 = v261;
  uint64_t v260 = 0x6400000000;
  uint64_t v247 = v28;
  v268 = v270;
  uint64_t v269 = 0xA00000000;
  v265 = v267;
  uint64_t v266 = 0x4000000000;
  uint64_t v29 = sub_1CB906F34(v253, 64, 3);
  *(void *)(v29 + 32) = 0;
  *(_DWORD *)(v29 + 40) = 0;
  *(void *)(v29 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(v29 + 16) = 0;
  v225 = (void **)v28;
  *(void *)uint64_t v29 = v28;
  *(_DWORD *)(v29 + 24) = 0;
  *(void *)(v29 + 4sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(v29 + 56) = 0;
  sub_1CC4EB514((uint64_t)v251, &v247)[1] = v29;
  if (v266 >= HIDWORD(v266)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v265 + v266) = v29;
  v262 = v264;
  uint64_t v263 = 0xA00000000;
  BOOL v30 = __CFADD__(v266, 1);
  unsigned int v31 = v266 + 1;
  LODWORD(v266) = v266 + 1;
  if (!v30)
  {
    while (2)
    {
      v200 = (uint64_t **)*((void *)v265 + v31 - 1);
      LODWORD(v266) = v31 - 1;
      LODWORD(v263) = 0;
      v201 = *v200;
      uint64_t v202 = **v200;
      v203 = *(uint64_t **)(v202 + 64);
      v204 = *(uint64_t **)(v202 + 72);
      if (v203 == v204)
      {
        *((_DWORD *)v200 + 10) = 0;
      }
      else
      {
        do
        {
          uint64_t v205 = sub_1CC4E3D64(v201[1], *v203);
          if (v263 >= (unint64_t)HIDWORD(v263)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v262 + v263) = v205;
          unsigned int v206 = v263 + 1;
          LODWORD(v263) = v263 + 1;
          ++v203;
        }
        while (v203 != v204);
        *((_DWORD *)v200 + 10) = v206;
        if (v206)
        {
          uint64_t v207 = sub_1CB906F34(v253, 8 * v206, 3);
          int v208 = *((_DWORD *)v200 + 10);
          v200[6] = (uint64_t *)v207;
          if (v208)
          {
            unsigned int v209 = 0;
            while (1)
            {
              uint64_t v210 = v209;
              uint64_t v211 = *((void *)v262 + v209);
              uint64_t v246 = v211;
              v212 = sub_1CC4EB514((uint64_t)v251, &v246);
              uint64_t v213 = v212[1];
              if (!v213) {
                break;
              }
              v200[6][v210] = v213;
LABEL_341:
              unsigned int v209 = v210 + 1;
              if (v210 + 1 == *((_DWORD *)v200 + 10)) {
                goto LABEL_357;
              }
            }
            v214 = v212;
            int v215 = *((_DWORD *)v249 + 4);
            if (v215)
            {
              uint64_t v216 = *v249;
              unsigned int v217 = v215 - 1;
              uint64_t v218 = (v215 - 1) & ((v211 >> 4) ^ (v211 >> 9));
              uint64_t v219 = *(void *)(*v249 + 16 * v218);
              if (v211 == v219)
              {
LABEL_345:
                uint64_t v220 = *(void *)(v216 + 16 * v218 + 8);
                goto LABEL_346;
              }
              int v223 = 1;
              while (v219 != -4096)
              {
                int v224 = v218 + v223++;
                uint64_t v218 = v224 & v217;
                uint64_t v219 = *(void *)(v216 + 16 * v218);
                if (v211 == v219) {
                  goto LABEL_345;
                }
              }
            }
            uint64_t v220 = 0;
LABEL_346:
            uint64_t v221 = sub_1CB906F34(v253, 64, 3);
            *(void *)uint64_t v221 = v211;
            *(void *)(v221 + sub_1CD521E44((uint64_t)this + 8) = v220;
            if (v220) {
              uint64_t v222 = v221;
            }
            else {
              uint64_t v222 = 0;
            }
            *(void *)(v221 + 16) = v222;
            *(_DWORD *)(v221 + 24) = 0;
            *(void *)(v221 + 32) = 0;
            *(_DWORD *)(v221 + 40) = 0;
            *(void *)(v221 + 4sub_1CD521E44((uint64_t)this + 8) = 0;
            *(void *)(v221 + 56) = 0;
            v214[1] = v221;
            v200[6][v210] = v221;
            if (v220)
            {
              if (v269 >= (unint64_t)HIDWORD(v269)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v268[v269] = v221;
              LODWORD(v269) = v269 + 1;
            }
            else
            {
              if (v266 >= (unint64_t)HIDWORD(v266)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v265 + v266) = v221;
              LODWORD(v266) = v266 + 1;
            }
            goto LABEL_341;
          }
LABEL_357:
          unsigned int v31 = v266;
          if (!v266) {
            goto LABEL_20;
          }
          continue;
        }
      }
      break;
    }
    v200[6] = 0;
    goto LABEL_357;
  }
LABEL_20:
  uint64_t v32 = sub_1CB906F34(v253, 64, 3);
  *(void *)(v32 + 32) = 0;
  *(_DWORD *)(v32 + 40) = 0;
  *(void *)(v32 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(v32 + 16) = 0;
  *(void *)uint64_t v32 = 0;
  *(_DWORD *)(v32 + 24) = 0;
  *(void *)(v32 + 4sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(v32 + 56) = 0;
  unsigned int v33 = v269;
  for (i = v266; v269; unsigned int v33 = v269)
  {
    uint64_t v70 = v268[v33 - 1];
    LODWORD(v269) = v33 - 1;
    *(void *)(v70 + 32) = v32;
    *(_DWORD *)(v70 + 24) = -1;
    if (i >= HIDWORD(v266)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v265 + i) = v70;
    unsigned int i = v266 + 1;
    LODWORD(v266) = v266 + 1;
  }
  for (int j = 1; i; LODWORD(v266) = i)
  {
    while (1)
    {
      uint64_t v71 = (uint64_t **)*((void *)v265 + i - 1);
      if (*((_DWORD *)v71 + 6) == -2) {
        break;
      }
      *((_DWORD *)v71 + 6) = -2;
      uint64_t v72 = **v71;
      uint64_t v73 = *(uint64_t **)(v72 + 88);
      uint64_t v74 = *(uint64_t **)(v72 + 96);
      if (v74 != v73)
      {
        uint64_t v75 = (*v71)[1];
        do
        {
          uint64_t v246 = sub_1CC4E3D64(v75, *v73);
          uint64_t v76 = *sub_1CC4EB4AC((uint64_t)v251, &v246);
          if (v76 && !*(_DWORD *)(v76 + 24))
          {
            *(_DWORD *)(v76 + 24) = -1;
            if (v266 >= (unint64_t)HIDWORD(v266)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v265 + v266) = v76;
            LODWORD(v266) = v266 + 1;
          }
          ++v73;
        }
        while (v73 != v74);
        unsigned int i = v266;
      }
      if (!i) {
        goto LABEL_22;
      }
    }
    *((_DWORD *)v71 + 6) = j;
    if (!v71[1])
    {
      if (v260 >= (unint64_t)HIDWORD(v260)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v259 + v260) = v71;
      LODWORD(v260) = v260 + 1;
      unsigned int i = v266;
    }
    ++j;
    --i;
  }
LABEL_22:
  *(_DWORD *)(v32 + 24) = j;
  if (v262 != v264) {
    free(v262);
  }
  long long v36 = v230;
  if (v265 != v267) {
    free(v265);
  }
  if (v268 != v270) {
    free(v268);
  }
  uint64_t v37 = v260;
  if (!v260)
  {
    unint64_t v14 = *((_DWORD *)*v225 + 6) & 0xFFFFF | ((unint64_t)*((unsigned int *)v248 + 18) << 40);
    v265 = *v225;
    sub_1CD45F378((uint64_t)(v248 + 3), (uint64_t *)&v265)[1] = v14;
    *sub_1CC4EB4AC((uint64_t)v249, &v245) = v14;
    goto LABEL_57;
  }
LABEL_30:
  char v38 = 0;
  BOOL v39 = (char *)v259;
  int8x8_t v40 = (char *)v259 + 8 * v37;
  do
  {
    while (1)
    {
      uint64_t v42 = *((void *)v40 - 1);
      v40 -= 8;
      uint64_t v41 = v42;
      if (!*(_DWORD *)(v42 + 40)) {
        break;
      }
      unsigned int v43 = 0;
      uint64_t v44 = 0;
      do
      {
        uint64_t v45 = *(void *)(*(void *)(v41 + 48) + 8 * v43);
        if (!*(_DWORD *)(v45 + 24))
        {
          unint64_t v48 = *(_DWORD *)(**(void **)v45 + 24) & 0xFFFFF | ((unint64_t)*((unsigned int *)v248 + 18) << 40);
          v265 = **(void ***)v45;
          sub_1CD45F378((uint64_t)(v248 + 3), (uint64_t *)&v265)[1] = v48;
          *(void *)(v45 + sub_1CD521E44((uint64_t)this + 8) = v48;
          *sub_1CC4EB4AC((uint64_t)v249, (uint64_t *)v45) = v48;
          *(void *)(v45 + 16) = v45;
          *(_DWORD *)(v45 + 24) = (*(_DWORD *)(v32 + 24))++;
        }
        if (v44)
        {
          if (v44 != v45)
          {
            int v46 = *(_DWORD *)(v45 + 24);
            do
            {
              while (1)
              {
                int v47 = *(_DWORD *)(v44 + 24);
                if (v47 >= v46) {
                  break;
                }
                uint64_t v44 = *(void *)(v44 + 32);
                if (!v44) {
                  goto LABEL_46;
                }
              }
              while (1)
              {
                int v46 = *(_DWORD *)(v45 + 24);
                if (v46 >= v47) {
                  break;
                }
                uint64_t v45 = *(void *)(v45 + 32);
                if (!v45) {
                  goto LABEL_47;
                }
              }
            }
            while (v44 != v45);
          }
        }
        else
        {
LABEL_46:
          uint64_t v44 = v45;
        }
LABEL_47:
        ++v43;
      }
      while (v43 != *(_DWORD *)(v41 + 40));
      if (!v44 || v44 == *(void *)(v41 + 32)) {
        break;
      }
      *(void *)(v41 + 32) = v44;
      char v38 = 1;
      if (v40 == v39)
      {
        uint64_t v37 = v260;
LABEL_55:
        if (!v37) {
          goto LABEL_56;
        }
        goto LABEL_30;
      }
    }
  }
  while (v40 != v39);
  uint64_t v37 = v260;
  if (v38) {
    goto LABEL_55;
  }
  if (!v260) {
    goto LABEL_56;
  }
  int v99 = 0;
  unsigned int v100 = (uint64_t **)v259;
  v101 = (uint64_t **)((char *)v259 + 8 * v260);
  uint64_t v102 = v101;
  do
  {
    while (1)
    {
      uint64_t v104 = (uint64_t)*--v102;
      uint64_t v103 = v104;
      uint64_t v105 = *(void *)(v104 + 16);
      if (v105 == v104) {
        break;
      }
      uint64_t v106 = *(void *)(v103 + 32);
      uint64_t v107 = *(void *)(v106 + 16);
      uint64_t v108 = *(unsigned int *)(v103 + 40);
      if (v108)
      {
        uint64_t v109 = 0;
        while (2)
        {
          for (uint64_t k = *(void *)(*(void *)(v103 + 48) + 8 * v109); k != v106; uint64_t k = *(void *)(k + 32))
          {
            if (*(void *)(k + 16) == k)
            {
              uint64_t v107 = v103;
              goto LABEL_179;
            }
          }
          if (++v109 != v108) {
            continue;
          }
          break;
        }
      }
LABEL_179:
      if (v107 == v105) {
        break;
      }
      *(void *)(v103 + 16) = v107;
      int v99 = v102 != v100;
      if (v102 == v100) {
        uint64_t v102 = v101;
      }
    }
    BOOL v111 = v102 != v100;
    char v112 = v111 | v99;
    v99 &= v111;
    if (v102 == v100) {
      uint64_t v102 = v101;
    }
  }
  while ((v112 & 1) != 0);
  v231 = v101;
  while (2)
  {
    if ((uint64_t *)(*v100)[2] != *v100) {
      goto LABEL_187;
    }
    v232 = *v100;
    uint64_t v113 = **v100;
    unsigned int v114 = *(_DWORD *)(v113 + 24);
    if (!v114) {
      goto LABEL_223;
    }
    uint64_t v115 = *(void *)(v113 + 16);
    uint64_t v116 = v115 + 96 * v114;
    while (2)
    {
      v265 = v267;
      v267[0] = v115;
      uint64_t v266 = 0x1400000001;
      v268 = *(void **)(v115 + 80);
      *(void *)(*sub_1CC4EB4AC((uint64_t)v251, (uint64_t *)&v268) + 56) = v115;
      unsigned int v117 = v266;
      if (!v266)
      {
LABEL_204:
        LODWORD(v121) = 1;
        goto LABEL_206;
      }
      while (1)
      {
        uint64_t v118 = *((void *)v265 + --v117);
        LODWORD(v266) = v117;
        int v119 = *(_DWORD *)(v118 + 8);
        if (v119) {
          break;
        }
LABEL_203:
        if (!v117) {
          goto LABEL_204;
        }
      }
      uint64_t v120 = 0;
      while (2)
      {
        uint64_t v121 = *(void *)(*(void *)v118 + 16 * v120 + 8);
        v268 = *(void **)(*(void *)v118 + 16 * v120);
        uint64_t v122 = *(void **)(*sub_1CC4EB4AC((uint64_t)v251, (uint64_t *)&v268) + 16);
        uint64_t v123 = v122[1];
        if (v123)
        {
LABEL_195:
          if (v121 != v123) {
            break;
          }
          goto LABEL_196;
        }
        uint64_t v125 = sub_1CC4EB57C(v121, *v248, *((_DWORD *)v248 + 4));
        uint64_t v121 = v125;
        if (!v125) {
          goto LABEL_206;
        }
        if (*(void *)(v125 + 80) == *v122)
        {
          uint64_t v123 = v122[7];
          if (v123) {
            goto LABEL_195;
          }
          v122[7] = v125;
          if (v266 >= (unint64_t)HIDWORD(v266)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v265 + v266) = v125;
          LODWORD(v266) = v266 + 1;
LABEL_196:
          int v124 = v120 + 1;
          uint64_t v120 = (v120 + 1);
          if (v119 == v124)
          {
            unsigned int v117 = v266;
            goto LABEL_203;
          }
          continue;
        }
        break;
      }
      LODWORD(v121) = 0;
LABEL_206:
      if (v265 != v267) {
        free(v265);
      }
      v126 = (char *)v259;
      if (v121)
      {
        if (v260)
        {
          uint64_t v127 = 8 * v260;
          do
          {
            uint64_t v128 = *(void *)(*(void *)v126 + 56);
            if (v128)
            {
              uint64_t v129 = *(void *)(v128 + 88);
              v265 = *(void **)(v128 + 80);
              *sub_1CC4EB4AC((uint64_t)v249, (uint64_t *)&v265) = v129;
              *(void *)(sub_1CC4EB514((uint64_t)v251, (uint64_t *)&v265)[1] + sub_1CD521E44((uint64_t)this + 8) = v129;
            }
            v126 += 8;
            v127 -= 8;
          }
          while (v127);
          goto LABEL_214;
        }
        break;
      }
      if (v260)
      {
        uint64_t v131 = 8 * v260;
        do
        {
          uint64_t v132 = *(void *)v126;
          v126 += 8;
          *(void *)(v132 + 56) = 0;
          v131 -= 8;
        }
        while (v131);
      }
LABEL_214:
      v115 += 96;
      if (v115 == v116) {
        int v130 = 1;
      }
      else {
        int v130 = v121;
      }
      if (v130 != 1) {
        continue;
      }
      break;
    }
LABEL_223:
    v101 = v231;
    uint64_t v133 = v232;
    if (!v232[1])
    {
      uint64_t v134 = *v232;
      uint64_t v135 = (uint64_t)v248;
      uint64_t v136 = *(void *)(*(void *)(v248[10] + 8 * *(int *)(*(void *)*v232 + 24))
                       + 8 * *((unsigned int *)v248 + 18));
      unsigned int v137 = *(_DWORD *)(*v232 + 24);
      if (v137 >= *(_DWORD *)(*v232 + 28))
      {
        v265 = 0;
        llvm::SmallVectorBase<unsigned int>::mallocForGrow();
      }
      v138 = (void *)(*(void *)(v134 + 16) + 96 * v137);
      void *v138 = v138 + 2;
      v138[1] = 0x400000000;
      v138[10] = v134;
      v138[11] = v136;
      unsigned int v139 = *(_DWORD *)(v134 + 24) + 1;
      *(_DWORD *)(v134 + 24) = v139;
      uint64_t v140 = *(void *)(v134 + 16);
      unsigned int v141 = *(_DWORD *)(v135 + 16);
      if (v141)
      {
        unsigned int v142 = v141 - 1;
        unsigned int v143 = (v141 - 1) & (37 * v136);
        v144 = (uint64_t *)(*(void *)v135 + 16 * v143);
        uint64_t v145 = *v144;
        if (v136 == *v144) {
          goto LABEL_227;
        }
        v178 = 0;
        int v179 = 1;
        while (v145 != -1)
        {
          if (v178) {
            BOOL v195 = 0;
          }
          else {
            BOOL v195 = v145 == -2;
          }
          if (v195) {
            v178 = v144;
          }
          unsigned int v196 = v143 + v179++;
          unsigned int v143 = v196 & v142;
          v144 = (uint64_t *)(*(void *)v135 + 16 * (v196 & v142));
          uint64_t v145 = *v144;
          v101 = v231;
          uint64_t v133 = v232;
          if (v136 == *v144) {
            goto LABEL_227;
          }
        }
        if (v178) {
          v144 = v178;
        }
        v101 = v231;
        uint64_t v133 = v232;
      }
      else
      {
        v144 = 0;
      }
      int v146 = *(_DWORD *)(v135 + 8);
      if (4 * v146 + 4 >= 3 * v141)
      {
        sub_1CC4EB5F0(v135, 2 * v141);
        int v180 = *(_DWORD *)(v135 + 16) - 1;
        unsigned int v181 = v180 & (37 * v136);
        v144 = (uint64_t *)(*(void *)v135 + 16 * v181);
        uint64_t v182 = *v144;
        if (v136 == *v144) {
          goto LABEL_297;
        }
        v183 = 0;
        int v184 = 1;
        while (v182 != -1)
        {
          if (v183) {
            BOOL v185 = 0;
          }
          else {
            BOOL v185 = v182 == -2;
          }
          if (v185) {
            v183 = v144;
          }
          unsigned int v186 = v181 + v184++;
          unsigned int v181 = v186 & v180;
          v144 = (uint64_t *)(*(void *)v135 + 16 * (v186 & v180));
          uint64_t v182 = *v144;
          if (v136 == *v144) {
            goto LABEL_297;
          }
        }
      }
      else
      {
        if (v141 + ~v146 - *(_DWORD *)(v135 + 12) > v141 >> 3) {
          goto LABEL_231;
        }
        sub_1CC4EB5F0(v135, v141);
        int v187 = *(_DWORD *)(v135 + 16) - 1;
        unsigned int v188 = v187 & (37 * v136);
        v144 = (uint64_t *)(*(void *)v135 + 16 * v188);
        uint64_t v189 = *v144;
        if (v136 == *v144)
        {
LABEL_297:
          uint64_t v147 = v136;
          v101 = v231;
          uint64_t v133 = v232;
          goto LABEL_232;
        }
        v183 = 0;
        int v197 = 1;
        while (v189 != -1)
        {
          if (v183) {
            BOOL v198 = 0;
          }
          else {
            BOOL v198 = v189 == -2;
          }
          if (v198) {
            v183 = v144;
          }
          unsigned int v199 = v188 + v197++;
          unsigned int v188 = v199 & v187;
          v144 = (uint64_t *)(*(void *)v135 + 16 * (v199 & v187));
          uint64_t v189 = *v144;
          if (v136 == *v144) {
            goto LABEL_297;
          }
        }
      }
      if (v183) {
        v144 = v183;
      }
      v101 = v231;
      uint64_t v133 = v232;
LABEL_231:
      uint64_t v147 = *v144;
LABEL_232:
      ++*(_DWORD *)(v135 + 8);
      if (v147 != -1) {
        --*(_DWORD *)(v135 + 12);
      }
      uint64_t *v144 = v136;
      v144[1] = 0;
LABEL_227:
      v144[1] = v140 + 96 * v139 - 96;
      v133[1] = v136;
      *sub_1CC4EB4AC((uint64_t)v249, v133) = v136;
    }
LABEL_187:
    if (++v100 != v101) {
      continue;
    }
    break;
  }
  if (v260)
  {
    v153 = (char *)v259;
    v154 = (char *)v259 + 8 * v260;
    do
    {
      uint64_t v156 = *((void *)v154 - 1);
      v154 -= 8;
      uint64_t v155 = v156;
      uint64_t v157 = *(void *)(v156 + 16);
      if (v157 == v156)
      {
        uint64_t v159 = sub_1CC4EB57C(*(void *)(v155 + 8), *v248, *((_DWORD *)v248 + 4));
        if (v159 && !*(_DWORD *)(v159 + 8))
        {
          if (*(_DWORD *)(v155 + 40))
          {
            unsigned int v160 = 0;
            unsigned int v161 = 0;
            do
            {
              v162 = *(void **)(*(void *)(v155 + 48) + 8 * v161);
              uint64_t v163 = *(void *)(v162[2] + 8);
              if (v160 >= *(_DWORD *)(v159 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v164 = (void *)(*(void *)v159 + 16 * v160);
              void *v164 = *v162;
              v164[1] = v163;
              unsigned int v160 = *(_DWORD *)(v159 + 8) + 1;
              *(_DWORD *)(v159 + sub_1CD521E44((uint64_t)this + 8) = v160;
              ++v161;
            }
            while (v161 != *(_DWORD *)(v155 + 40));
          }
          v165 = v250;
          if (v250)
          {
            unint64_t v166 = *((unsigned int *)v250 + 2);
            if (v166 >= *((unsigned int *)v250 + 3)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)*v250 + v166) = v159;
            ++*((_DWORD *)v165 + 2);
          }
        }
      }
      else
      {
        uint64_t v158 = *(void *)(v157 + 8);
        *sub_1CC4EB4AC((uint64_t)v249, (uint64_t *)v155) = v158;
      }
    }
    while (v154 != v153);
  }
LABEL_56:
  unint64_t v14 = *(void *)(*(void *)(sub_1CC4EB514((uint64_t)v251, &v245)[1] + 16) + 8);
  long long v36 = v230;
LABEL_57:
  if (v259 != v261) {
    free(v259);
  }
  uint64_t v266 = 0;
  v265 = 0;
  LODWORD(v267[0]) = 0;
  do
  {
    unsigned int v49 = (void *)sub_1CC4E3D64((uint64_t)&v235, *((void *)v36 + 1));
    uint64_t v50 = *((void *)v36 + 2);
    v268 = v49;
    uint64_t v269 = v50;
    sub_1CC4E3FBC((uint64_t)&v259, (uint64_t)&v265, (uint64_t *)&v268);
    v36 += 10;
  }
  while (v36 != v226);
  v259 = v261;
  uint64_t v260 = 0x800000000;
  if (!v257)
  {
    v268 = (void *)a1;
    uint64_t v51 = (uint64_t *)v261;
    uint64_t v52 = v261;
    goto LABEL_63;
  }
  LODWORD(v77) = 0;
  uint64_t v78 = v256;
  uint64_t v79 = 8 * v257;
  do
  {
    if (v77 >= HIDWORD(v260)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v259 + v77) = *v78;
    unint64_t v77 = (v260 + 1);
    LODWORD(v260) = v260 + 1;
    ++v78;
    v79 -= 8;
  }
  while (v79);
  uint64_t v52 = v259;
  uint64_t v51 = (uint64_t *)((char *)v259 + 8 * v77);
  v268 = (void *)a1;
  if (v77) {
    uint64_t v53 = 126 - 2 * __clz(v77);
  }
  else {
LABEL_63:
  }
    uint64_t v53 = 0;
  sub_1CC4EB778((uint64_t)v52, v51, &v268, v53, 1);
  if (v260)
  {
    uint64_t v80 = (uint64_t ****)v259;
    uint64_t v81 = (uint64_t ****)((char *)v259 + 8 * v260);
    while (1)
    {
      char v82 = (*v80)[10];
      uint64_t v83 = *(void *)(*(void *)(v229 + 8 * *((int *)*v82 + 6)) + 8 * v227);
      uint64_t v84 = *((unsigned int *)*v80 + 2);
      if (v84) {
        break;
      }
LABEL_150:
      v262 = (*v80)[10];
      uint64_t v263 = v83;
      sub_1CC4E3FBC((uint64_t)&v268, (uint64_t)&v265, (uint64_t *)&v262);
      if (++v80 == v81) {
        goto LABEL_65;
      }
    }
    __int16 v85 = **v80;
    uint64_t v86 = &v85[2 * v84];
    int v87 = v239 - 1;
    int v88 = LODWORD(v267[0]) - 1;
    while (1)
    {
      int v89 = *v85;
      uint64_t v90 = **v85;
      if (v239)
      {
        unsigned int v91 = ((v90 >> 4) ^ (v90 >> 9)) & v87;
        uint64_t v92 = *(void *)(v238[0] + 16 * v91);
        if (v90 == v92)
        {
LABEL_143:
          if (v91 != v239) {
            break;
          }
        }
        else
        {
          int v175 = 1;
          while (v92 != -4096)
          {
            unsigned int v176 = v91 + v175++;
            unsigned int v91 = v176 & v87;
            uint64_t v92 = *(void *)(v238[0] + 16 * v91);
            if (v90 == v92) {
              goto LABEL_143;
            }
          }
        }
      }
      uint64_t v93 = *(void *)(*(void *)(v229 + 8 * *((int *)*v82 + 6)) + 8 * v227);
      if (LODWORD(v267[0]))
      {
        uint64_t v94 = ((v89 >> 4) ^ (v89 >> 9)) & v88;
        unsigned int v95 = (uint64_t *)*((void *)v265 + 2 * v94);
        if (v95 == v89)
        {
LABEL_146:
          uint64_t v93 = *(void *)(*(void *)(v229 + 8 * *((int *)*v82 + 6)) + 8 * v227);
          if (v94 != LODWORD(v267[0])) {
            uint64_t v93 = *((void *)v265 + 2 * v94 + 1);
          }
        }
        else
        {
          int v177 = 1;
          while (v95 != (uint64_t *)-4096)
          {
            int v194 = v94 + v177++;
            uint64_t v94 = v194 & v88;
            unsigned int v95 = (uint64_t *)*((void *)v265 + 2 * v94);
            if (v95 == v89) {
              goto LABEL_146;
            }
          }
          uint64_t v93 = *(void *)(*(void *)(v229 + 8 * *((int *)*v82 + 6)) + 8 * v227);
        }
      }
      if (*(void *)(*(void *)(v228 + 8 * *(int *)(v90 + 24)) + 8 * v227) != v93) {
        break;
      }
      v85 += 2;
      if (v85 == v86) {
        goto LABEL_150;
      }
    }
    LOBYTE(v14) = 0;
    unint64_t v15 = 0;
  }
  else
  {
LABEL_65:
    unint64_t v15 = v14 & 0xFFFFFFFFFFFFFF00;
  }
  if (v259 != v261) {
    free(v259);
  }
  MEMORY[0x1D25D9CD0](v265, 8);
  sub_1CBFFBA64((uint64_t)v253);
  MEMORY[0x1D25D9CD0](v251[0], 8);
LABEL_69:
  if (v256 != v258) {
    free(v256);
  }
  MEMORY[0x1D25D9CD0](v233[0], 8);
  uint64_t v54 = &v240[2 * v242];
  if (v241)
  {
    if (v242)
    {
      uint64_t v98 = 16 * v242;
      uint64_t v55 = v240;
      while ((*v55 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v55 += 2;
        v98 -= 16;
        if (!v98) {
          goto LABEL_72;
        }
      }
    }
    else
    {
      uint64_t v55 = v240;
    }
  }
  else
  {
LABEL_72:
    uint64_t v55 = &v240[2 * v242];
  }
  uint64_t v56 = &v240[2 * v242];
LABEL_74:
  while (v55 != v56)
  {
    uint64_t v57 = v55[1];
    if (v57)
    {
      uint64_t v58 = *(char **)(v57 + 16);
      uint64_t v59 = *(unsigned int *)(v57 + 24);
      if (v59)
      {
        uint64_t v60 = 96 * v59;
        do
        {
          uint64_t v61 = *(char **)&v58[v60 - 96];
          if (&v58[v60 - 80] != v61) {
            free(v61);
          }
          v60 -= 96;
        }
        while (v60);
        uint64_t v58 = *(char **)(v57 + 16);
      }
      if (v58 != (char *)(v57 + 32)) {
        free(v58);
      }
      MEMORY[0x1D25D9CE0](v57, 0x10A0C4042BD28D8);
    }
    uint64_t v62 = v55 + 2;
    uint64_t v55 = v54;
    if (v62 != v54)
    {
      uint64_t v55 = v62;
      while ((*v55 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v55 += 2;
        if (v55 == v54)
        {
          uint64_t v55 = v54;
          goto LABEL_74;
        }
      }
    }
  }
  if (v236)
  {
    int v65 = v235;
    if (v237 <= 4 * (int)v236 || v237 < 0x41)
    {
      if (v237)
      {
        uint64_t v96 = 16 * v237;
        do
        {
          void *v65 = -1;
          v65 += 2;
          v96 -= 16;
        }
        while (v96);
      }
      uint64_t v236 = 0;
    }
    else if (v236)
    {
      int v150 = 1 << (33 - __clz(v236 - 1));
      if (v150 <= 64) {
        int v151 = 64;
      }
      else {
        int v151 = v150;
      }
      if (v151 == v237)
      {
        uint64_t v236 = 0;
        uint64_t v152 = 16 * v237;
        do
        {
          void *v65 = -1;
          v65 += 2;
          v152 -= 16;
        }
        while (v152);
      }
      else
      {
        MEMORY[0x1D25D9CD0](v235, 8);
        unint64_t v171 = (4 * v151 / 3u + 1) | ((unint64_t)(4 * v151 / 3u + 1) >> 1);
        unint64_t v172 = v171 | (v171 >> 2) | ((v171 | (v171 >> 2)) >> 4);
        unsigned int v237 = (((v172 | (v172 >> 8)) >> 16) | v172 | (v172 >> 8)) + 1;
        v173 = operator new(16 * v237, (std::align_val_t)8uLL);
        v235 = v173;
        uint64_t v236 = 0;
        if (v237)
        {
          uint64_t v174 = 16 * v237;
          do
          {
            void *v173 = -1;
            v173 += 2;
            v174 -= 16;
          }
          while (v174);
        }
      }
    }
    else
    {
      MEMORY[0x1D25D9CD0](v235, 8);
      v235 = 0;
      uint64_t v236 = 0;
      unsigned int v237 = 0;
    }
  }
  sub_1CD3C7F68(v238);
  if (v241)
  {
    uint64_t v66 = v240;
    if (v242 <= 4 * (int)v241 || v242 < 0x41)
    {
      if (v242)
      {
        uint64_t v97 = 16 * v242;
        do
        {
          void *v66 = -4096;
          v66 += 2;
          v97 -= 16;
        }
        while (v97);
      }
      uint64_t v241 = 0;
    }
    else if (v241)
    {
      int v67 = 1 << (33 - __clz(v241 - 1));
      if (v67 <= 64) {
        int v68 = 64;
      }
      else {
        int v68 = v67;
      }
      if (v68 == v242)
      {
        uint64_t v241 = 0;
        uint64_t v69 = 16 * v242;
        do
        {
          void *v66 = -4096;
          v66 += 2;
          v69 -= 16;
        }
        while (v69);
      }
      else
      {
        MEMORY[0x1D25D9CD0](v240, 8);
        unint64_t v167 = (4 * v68 / 3u + 1) | ((unint64_t)(4 * v68 / 3u + 1) >> 1);
        unint64_t v168 = v167 | (v167 >> 2) | ((v167 | (v167 >> 2)) >> 4);
        unsigned int v242 = (((v168 | (v168 >> 8)) >> 16) | v168 | (v168 >> 8)) + 1;
        v169 = operator new(16 * v242, (std::align_val_t)8uLL);
        v240 = v169;
        uint64_t v241 = 0;
        if (v242)
        {
          uint64_t v170 = 16 * v242;
          do
          {
            void *v169 = -4096;
            v169 += 2;
            v170 -= 16;
          }
          while (v170);
        }
      }
    }
    else
    {
      MEMORY[0x1D25D9CD0](v240, 8);
      v240 = 0;
      uint64_t v241 = 0;
      unsigned int v242 = 0;
    }
  }
  MEMORY[0x1D25D9CD0](v240, 8);
  MEMORY[0x1D25D9CD0](v238[0], 8);
  MEMORY[0x1D25D9CD0](v235, 8);
  return v15 | v14;
}

void sub_1CD59A424(uint64_t a1)
{
  sub_1CD59DC44(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD59A45C(uint64_t a1, uint64_t a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  a4.i32[0] = 0;
  uint64_t v7 = *(void *)(a1 + 448);
  a5.i8[0] = *(unsigned char *)(a2 + 24);
  int8x16_t v8 = vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(a5, a4), 0), (int8x16_t)llvm::DebugVariable::DefaultFragment, *(int8x16_t *)(a2 + 8));
  *(void *)std::string v25 = *(void *)a2;
  *(int8x16_t *)&unsigned char v25[8] = v8;
  *(void *)&long long v34 = 0;
  uint64_t result = sub_1CC4DC8E0((uint64_t *)v7, v25, (uint64_t **)&v34);
  if (result) {
    uint64_t v10 = v34;
  }
  else {
    uint64_t v10 = *(void *)v7 + 56 * *(unsigned int *)(v7 + 16);
  }
  if (v10 != **(void **)(a1 + 448) + 56 * *(unsigned int *)(*(void *)(a1 + 448) + 16))
  {
    uint64_t v11 = *(unsigned int *)(v10 + 32);
    if (v11)
    {
      uint64_t v12 = *(uint64_t **)(v10 + 24);
      uint64_t v23 = &v12[2 * v11];
      do
      {
        uint64_t v13 = *v12;
        uint64_t v14 = v12[1];
        unint64_t v15 = (unint64_t)*v12 >> 8;
        BOOL v16 = *v12 == -1 && v14 == 0;
        char v17 = !v16;
        if (v16) {
          char v18 = 0;
        }
        else {
          char v18 = *v12;
        }
        uint64_t v19 = *(void *)(a2 + 32);
        *(void *)&long long v34 = *(void *)a2;
        BYTE8(v34) = v18;
        HIBYTE(v34) = HIBYTE(v13);
        *(_WORD *)((char *)&v34 + 13) = HIDWORD(v13) >> 8;
        *(_DWORD *)((char *)&v34 + 9) = v15;
        *(void *)&long long v35 = v14;
        BYTE8(v35) = v17;
        uint64_t v36 = v19;
        uint64_t v20 = LiveDebugValues::ValueIDNum::EmptyValue;
        *(_OWORD *)&uint64_t v33[4] = *(_OWORD *)(a1 + 456);
        *(_OWORD *)std::string v25 = v34;
        *(_OWORD *)&v25[16] = v35;
        uint64_t v26 = v19;
        *(void *)&long long v27 = LiveDebugValues::ValueIDNum::EmptyValue;
        BYTE8(v27) = 0;
        char v28 = 0;
        long long v30 = *(_OWORD *)v33;
        int v31 = *(_DWORD *)&v33[16];
        int v29 = 0;
        int v32 = 0;
        uint64_t v21 = sub_1CD59A644((void *)a1, (uint64_t)v25, &v27);
        if (!v22)
        {
          *(void *)(v21 + 40) = v20;
          *(unsigned char *)(v21 + 4sub_1CD521E44((uint64_t)this + 8) = 0;
          *(unsigned char *)(v21 + 80) = 0;
          *(_DWORD *)(v21 + 8sub_1CD521E44((uint64_t)this + 8) = 0;
          *(_OWORD *)(v21 + 92) = *(_OWORD *)v33;
          *(void *)(v21 + 10sub_1CD521E44((uint64_t)this + 8) = *(unsigned int *)&v33[16];
        }
        uint64_t result = sub_1CD59DE68((_DWORD *)(a1 + 48), (uint64_t)&v34);
        *(void *)(result + 40) = a3;
        v12 += 2;
      }
      while (v12 != v23);
    }
  }
  return result;
}

uint64_t sub_1CD59A644(void *a1, uint64_t a2, long long *a3)
{
  long long v6 = *(_OWORD *)(a2 + 16);
  v16[0] = *(_OWORD *)a2;
  v16[1] = v6;
  uint64_t v17 = *(void *)(a2 + 32);
  v18[0] = 0;
  sub_1CD5A02CC((uint64_t)&v19, (uint64_t)a1, (uint64_t *)v16, v18);
  uint64_t v7 = (void **)(a1 + 3);
  if (!v20) {
    return (uint64_t)*v7 + 120 * *(unsigned int *)(v19 + 40);
  }
  unint64_t v8 = a1[4];
  *(_DWORD *)(v19 + 40) = -286331153 * ((v8 - a1[3]) >> 3);
  if (v8 >= a1[5])
  {
    uint64_t v14 = sub_1CC4E41D0(v7, a2, a3);
  }
  else
  {
    long long v9 = *(_OWORD *)a2;
    long long v10 = *(_OWORD *)(a2 + 16);
    *(void *)(v8 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)unint64_t v8 = v9;
    *(_OWORD *)(v8 + 16) = v10;
    long long v11 = a3[3];
    long long v12 = a3[4];
    long long v13 = a3[2];
    *(_OWORD *)(v8 + 56) = a3[1];
    *(_OWORD *)(v8 + 104) = v12;
    *(_OWORD *)(v8 + 8sub_1CD521E44((uint64_t)this + 8) = v11;
    *(_OWORD *)(v8 + 72) = v13;
    *(_OWORD *)(v8 + 40) = *a3;
    uint64_t v14 = (char *)(v8 + 120);
  }
  a1[4] = v14;
  return (uint64_t)(v14 - 120);
}

int32x2_t sub_1CD59A748(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = 0;
  if (sub_1CC4E4420(*(void *)a1, *(_DWORD *)(a1 + 16), a2, (uint64_t *)&v5))
  {
    uint64_t v4 = v5;
    void *v5 = 0;
    v4[1] = 0;
    void v4[2] = 0;
    *((unsigned char *)v4 + 24) = 1;
    v4[4] = 0;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD59A7B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = 0;
  if (sub_1CC39FD20((uint64_t *)a1, a2, (uint64_t *)&v5))
  {
    uint64_t v4 = v5;
    void *v5 = 0;
    v4[1] = 0;
    void v4[2] = 0;
    *((unsigned char *)v4 + 24) = 1;
    v4[4] = 0;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

_DWORD *sub_1CD59A81C(uint64_t a1, int *a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (!v4)
  {
    long long v9 = 0;
LABEL_5:
    int32x2_t result = sub_1CD59A928(a1, a2, v9);
    _DWORD *result = *a2;
    *(_OWORD *)(result + 42) = 0u;
    *(_OWORD *)(result + 3sub_1CD521E44((uint64_t)this + 8) = 0u;
    *(_OWORD *)(result + 34) = 0u;
    *(_OWORD *)(result + 30) = 0u;
    *(_OWORD *)(result + 26) = 0u;
    *(_OWORD *)(result + 22) = 0u;
    *(_OWORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = 0u;
    *(_OWORD *)(result + 14) = 0u;
    *(_OWORD *)(result + 10) = 0u;
    *(_OWORD *)(result + 6) = 0u;
    *((void *)result + 1) = result + 6;
    *((void *)result + 2) = 0x400000000;
    *((void *)result + 25) = 0;
    *((void *)result + 24) = 0;
    *((void *)result + 23) = result + 48;
    return result;
  }
  int v5 = v4 - 1;
  unsigned int v6 = *a2 & v5;
  int32x2_t result = (_DWORD *)(*(void *)a1 + 208 * v6);
  int v8 = *result;
  if (*a2 != *result)
  {
    long long v10 = 0;
    int v11 = 1;
    while (v8 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -2;
      }
      if (v12) {
        long long v10 = result;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      int32x2_t result = (_DWORD *)(*(void *)a1 + 208 * v6);
      int v8 = *result;
      if (*a2 == *result) {
        return result;
      }
    }
    if (v10) {
      long long v9 = v10;
    }
    else {
      long long v9 = result;
    }
    goto LABEL_5;
  }
  return result;
}

_DWORD *sub_1CD59A928(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD59AAA0(a1, 2 * v6);
    int v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v10 = *a2 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 208 * v10);
    int v11 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          BOOL v12 = a3;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        a3 = (_DWORD *)(*(void *)a1 + 208 * v10);
        int v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      int v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD59AAA0(a1, v6);
    int v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v17 = *a2 & v16;
    a3 = (_DWORD *)(*(void *)a1 + 208 * v17);
    int v18 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          BOOL v12 = a3;
        }
        unsigned int v21 = v17 + v19++;
        unsigned int v17 = v21 & v16;
        a3 = (_DWORD *)(*(void *)a1 + 208 * v17);
        int v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD59AAA0(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  int32x2_t result = operator new(208 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC4E4530(a1, v4, &v4[52 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 208 * v10;
    do
    {
      _DWORD *result = -1;
      result += 52;
      v11 -= 208;
    }
    while (v11);
  }
  return result;
}

void *sub_1CD59AB78(void *result, uint64_t a2)
{
  _DWORD *result = result + 2;
  result[1] = 0x400000000;
  if (*(_DWORD *)(a2 + 8)) {
    int32x2_t result = (void *)sub_1CD59ABF8((uint64_t)result, a2);
  }
  result[22] = *(void *)(a2 + 176);
  int v3 = (void *)(a2 + 184);
  uint64_t v4 = *(void *)(a2 + 184);
  result[23] = v4;
  unint64_t v5 = result + 23;
  uint64_t v6 = *(void *)(a2 + 192);
  result[24] = v6;
  if (v6)
  {
    *(void *)(v4 + 16) = v5;
    *(void *)(a2 + 176) = v3;
    *int v3 = 0;
    *(void *)(a2 + 192) = 0;
  }
  else
  {
    result[22] = v5;
  }
  return result;
}

uint64_t sub_1CD59ABF8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)a1, v4, 40 * v9);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove(*(void **)a1, v4, 40 * v10);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 40 * v10), (const void *)(*(void *)a2 + 40 * v10), *(void *)a2 + 40 * v11 - (*(void *)a2 + 40 * v10));
        }
      }
      *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v9;
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *int v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD59AD20(uint64_t **a1, unint64_t *a2)
{
  int v3 = sub_1CD59AD74((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  unint64_t v5 = v3;
  sub_1CD491B50(a1, v3);
  operator delete(v5);
  return 1;
}

void *sub_1CD59AD74(uint64_t a1, unint64_t *a2)
{
  int v2 = (void *)(a1 + 8);
  int v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unint64_t v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = sub_1CC4D9D2C(v3 + 4, a2);
    int v7 = v3 + 1;
    if (!v6)
    {
      int v7 = v3;
      unint64_t v5 = v3;
    }
    int v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || sub_1CC4D9D2C(a2, v5 + 4)) {
    return v2;
  }
  return v5;
}

uint64_t sub_1CD59ADF0(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  uint64_t v15 = 0;
  uint64_t result = sub_1CC4E4420(*(void *)a2, *(_DWORD *)(a2 + 16), (uint64_t *)a3, &v15);
  uint64_t v9 = v15;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = sub_1CD59AE98(a2, (uint64_t *)a3, v15);
    uint64_t v9 = result;
    uint64_t v12 = *(void *)(a3 + 32);
    long long v13 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    *(_OWORD *)(result + 16) = v13;
    *(void *)(result + 32) = v12;
    long long v14 = *a4;
    *(void *)(result + 56) = *((void *)a4 + 2);
    *(_OWORD *)(result + 40) = v14;
    char v10 = 1;
  }
  unint64_t v11 = *(void *)a2 + ((unint64_t)*(unsigned int *)(a2 + 16) << 6);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD59AE98(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_10;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_10:
    sub_1CD59AF5C(a1, v6);
    uint64_t v8 = 0;
    sub_1CC4E4420(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)a3 || *(unsigned char *)(a3 + 24) || *(void *)(a3 + 32)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

char *sub_1CD59AF5C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(long long **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)operator new((unint64_t)v8 << 6, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC4E466C(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    unint64_t v11 = &result[64 * v10];
    do
    {
      *(void *)uint64_t result = 0;
      result[8] = 0;
      result[24] = 0;
      *((void *)result + 4) = 0;
      result += 64;
    }
    while (result != v11);
  }
  return result;
}

BOOL sub_1CD59B034(uint64_t a1, void *a2)
{
  if ((*a2 & 0xFFFFFFFFFFLL) != 0
    || *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 88) + ((*a2 >> 38) & 0x3FFFFFCLL)) >= *(_DWORD *)(*(void *)(a1 + 16) + 236))
  {
    return 0;
  }
  int v5 = *(_DWORD *)(*(void *)(a1 + 8) + 88);
  int v6 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 2520) + 552))(*(void *)(a1 + 2520), *(void *)(a1 + 24));
  int v7 = *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 88) + ((*a2 >> 38) & 0x3FFFFFCLL));
  return v7 != v5 && v7 != v6;
}

llvm::MachineInstr *sub_1CD59B0F4(llvm::MachineFunction **a1, const llvm::MachineOperand *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v8 = *(void *)(*a3 + 16);
  uint64_t v9 = (void *)(v8 & 0xFFFFFFFFFFFFFFF8);
  if ((v8 & 4) != 0) {
    uint64_t v9 = (void *)*v9;
  }
  Impl = (const llvm::DILocation *)llvm::DILocation::getImpl(v9, 0, 0, *(void *)(*a3 - 8 * *(unsigned int *)(*a3 + 8)), a3[4], 0, 0, 1);
  llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v17, Impl);
  unint64_t v11 = sub_1CC34E910(a1[3], &v17, *((void *)*a1 + 1) + 624);
  long long v13 = v12;
  llvm::MachineInstr::addOperand(v12, v11, a2);
  if (*((unsigned char *)a4 + 8))
  {
    LODWORD(v1sub_1CD521E44((uint64_t)this + 8) = 1;
    *((void *)&v18 + 1) = 0;
    *(void *)&long long v19 = 0;
  }
  else
  {
    long long v18 = 0u;
    long long v19 = 0u;
  }
  llvm::MachineInstr::addOperand(v13, v11, (const llvm::MachineOperand *)&v18);
  uint64_t v14 = *a3;
  LODWORD(v1sub_1CD521E44((uint64_t)this + 8) = 14;
  *((void *)&v18 + 1) = 0;
  *(void *)&long long v19 = v14;
  llvm::MachineInstr::addOperand(v13, v11, (const llvm::MachineOperand *)&v18);
  uint64_t v15 = *a4;
  LODWORD(v1sub_1CD521E44((uint64_t)this + 8) = 14;
  *((void *)&v18 + 1) = 0;
  *(void *)&long long v19 = v15;
  llvm::MachineInstr::addOperand(v13, v11, (const llvm::MachineOperand *)&v18);
  if (v17) {
    llvm::MetadataTracking::untrack((uint64_t)&v17, v17);
  }
  return v13;
}

_DWORD *sub_1CD59B230(uint64_t a1, int *a2)
{
  int v7 = 0;
  char v4 = sub_1CD59B2B0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD59B34C(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = v5 + 6;
    *((void *)v5 + 2) = 0x100000000;
  }
  return v5;
}

uint64_t sub_1CD59B2B0(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    int v6 = (_DWORD *)(a1 + 88 * v5);
    int v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (_DWORD *)(a1 + 88 * (v13 & v4));
        int v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1CD59B34C(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD59B400(a1, v6);
  uint64_t v8 = 0;
  sub_1CD59B2B0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD59B400(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(88 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD59B4D8(a1, v4, v4 + 88 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 88 * v10;
    do
    {
      _DWORD *result = -1;
      result += 22;
      v11 -= 88;
    }
    while (v11);
  }
  return result;
}

void sub_1CD59B4D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 88 * v6;
    do
    {
      *int v7 = -1;
      v7 += 22;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        unsigned int v13 = 0;
        sub_1CD59B2B0(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        unsigned int v10 = v13;
        *unsigned int v13 = *(_DWORD *)v4;
        *((void *)v10 + 2) = 0x100000000;
        *((void *)v10 + 1) = v10 + 6;
        uint64_t v11 = (uint64_t)(v10 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD59B5D0(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD59B5D0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)a1, v4, v9 << 6);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove(*(void **)a1, v4, v10 << 6);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + (v10 << 6)), (const void *)(*(void *)a2 + (v10 << 6)), *(void *)a2 + (v11 << 6) - (*(void *)a2 + (v10 << 6)));
        }
      }
      *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v9;
    }
    else
    {
      unsigned int v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *int v7 = 0;
  }
  return a1;
}

unint64_t sub_1CD59B6E8(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + (v2 << 6);
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t sub_1CD59B760(unint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 2);
  unint64_t v4 = *a1;
  if (v3 >= *((_DWORD *)a1 + 3))
  {
    unint64_t v7 = v4 + (v3 << 6);
    if (v4 > a2 || v7 <= a2) {
      sub_1CD59B810();
    }
    sub_1CD59B810();
  }
  unint64_t v5 = v4 + ((unint64_t)*((unsigned int *)a1 + 2) << 6);
  *(_OWORD *)unint64_t v5 = *(_OWORD *)a2;
  *(void *)(v5 + 24) = 0x400000000;
  *(void *)(v5 + 16) = v5 + 32;
  uint64_t result = v5 + 16;
  if (*(_DWORD *)(a2 + 24)) {
    uint64_t result = sub_1CBB08144(result, (const void **)(a2 + 16));
  }
  ++*((_DWORD *)a1 + 2);
  return result;
}

void sub_1CD59B810()
{
}

void sub_1CD59B880(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1 + (v2 << 6);
    unint64_t v5 = (void *)(a2 + 16);
    uint64_t v6 = *a1 + 16;
    do
    {
      *((_OWORD *)v5 - 1) = *(_OWORD *)(v6 - 16);
      void *v5 = v5 + 2;
      v5[1] = 0x400000000;
      if (*(_DWORD *)(v6 + 8)) {
        sub_1CBB08144((uint64_t)v5, (const void **)v6);
      }
      uint64_t v7 = v6 - 16;
      v5 += 8;
      v6 += 64;
    }
    while (v7 + 64 != v4);
    uint64_t v8 = *((unsigned int *)a1 + 2);
    if (v8)
    {
      uint64_t v9 = *a1;
      uint64_t v10 = v8 << 6;
      do
      {
        uint64_t v11 = *(void **)(v9 + v10 - 48);
        if ((void *)(v9 + v10 - 32) != v11) {
          free(v11);
        }
        v10 -= 64;
      }
      while (v10);
    }
  }
}

__int16 *sub_1CD59B940(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD59B9B0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD59BAAC(a1, a2, v7);
    *(void *)unint64_t v5 = *(unsigned int *)a2;
  }
  return v5;
}

uint64_t sub_1CD59B9B0(uint64_t a1, int a2, unsigned __int16 a3, unsigned __int16 a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | (0x2500000000 * a3)) + ~(0x2500000000 * a4);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (unsigned __int16 *)(a1 + 8 * v9);
    int v11 = *v10;
    int v12 = v10[1];
    if (v11 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      int v16 = 0;
      int v17 = 1;
      while (v11 != 0xFFFF || v12 != 0xFFFF)
      {
        if (v16) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v12 == 65534;
        }
        if (v19 && v11 == 65534) {
          int v16 = v10;
        }
        unsigned int v21 = v9 + v17++;
        unsigned int v9 = v21 & v8;
        uint64_t v10 = (unsigned __int16 *)(a1 + 8 * (v21 & v8));
        int v11 = *v10;
        int v12 = v10[1];
        uint64_t v14 = 1;
        if (v11 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        uint64_t v10 = v16;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

__int16 *sub_1CD59BAAC(uint64_t a1, unsigned __int16 *a2, __int16 *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD59BB70(a1, v6);
  unsigned int v9 = 0;
  sub_1CD59B9B0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || (unsigned __int16)a3[1] != 0xFFFF) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD59BB70(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(unsigned __int16 **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD59BC3C(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      _DWORD *result = -1;
      result += 2;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD59BC3C(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3)
{
  char v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *int v7 = -1;
      v7 += 2;
      v8 -= 8;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      int v10 = v4[1];
      if ((v9 != 0xFFFF || v10 != 0xFFFF) && (v9 != 65534 || v10 != 65534))
      {
        uint64_t v14 = 0;
        uint64_t result = sub_1CD59B9B0(*(void *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
        unsigned int v13 = v14;
        *uint64_t v14 = *v4;
        v13[1] = v4[1];
        *((_DWORD *)v13 + 1) = *((_DWORD *)v4 + 1);
        ++*(_DWORD *)(v5 + 8);
      }
      v4 += 4;
    }
    while (v4 != a3);
  }
  return result;
}

int *sub_1CD59BD20(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2) {
    return (int *)(a1 + 208 * a2);
  }
  unsigned int v3 = a2 - 1;
  unsigned int v4 = (a2 - 1) & a3;
  uint64_t v5 = (int *)(a1 + 208 * v4);
  int v6 = *v5;
  if (*v5 != a3)
  {
    int v8 = 1;
    while (v6 != -1)
    {
      unsigned int v9 = v4 + v8++;
      unsigned int v4 = v9 & v3;
      uint64_t v5 = (int *)(a1 + 208 * (v9 & v3));
      int v6 = *v5;
      if (*v5 == a3) {
        return v5;
      }
    }
    return (int *)(a1 + 208 * a2);
  }
  return v5;
}

uint64_t sub_1CD59BD84(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 40 * v4);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 40 * v5);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 40 * v5), (const void *)(*(void *)a2 + 40 * v5), *(void *)a2 + 40 * v6 - (*(void *)a2 + 40 * v5));
      }
    }
    *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4;
  }
  return a1;
}

uint64_t *sub_1CD59BE60(void **a1, void *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t result = sub_1CD59BF0C(a1, a2, &v14, &v13, a3);
  if (!*result)
  {
    int v7 = result;
    int v8 = operator new(0x48uLL);
    long long v9 = *(_OWORD *)(a4 + 16);
    v8[2] = *(_OWORD *)a4;
    void v8[3] = v9;
    *((void *)v8 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a4 + 32);
    uint64_t v10 = v14;
    *(void *)int v8 = 0;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = v10;
    *int v7 = (uint64_t)v8;
    uint64_t v11 = (void *)**a1;
    if (v11)
    {
      *a1 = v11;
      int v12 = (uint64_t *)*v7;
    }
    else
    {
      int v12 = (uint64_t *)v8;
    }
    uint64_t result = sub_1CB8358B8(a1[1], v12);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return result;
}

uint64_t *sub_1CD59BF0C(void *a1, void *a2, void *a3, uint64_t *a4, unint64_t *a5)
{
  long long v9 = a1 + 1;
  if (a1 + 1 != a2 && !sub_1CC4D9D2C(a5, a2 + 4))
  {
    if (!sub_1CC4D9D2C(a2 + 4, a5))
    {
      *a3 = a2;
      *a4 = (uint64_t)a2;
      return a4;
    }
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      uint64_t v14 = (void *)a2[1];
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)*v14;
      }
      while (v14);
    }
    else
    {
      BOOL v19 = a2;
      do
      {
        uint64_t v15 = (void *)v19[2];
        BOOL v17 = *v15 == (void)v19;
        BOOL v19 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!sub_1CC4D9D2C(a5, v15 + 4)) {
        goto LABEL_30;
      }
      uint64_t v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = a2;
    }
    return a4;
  }
  if ((void *)*a1 == a2)
  {
    int v12 = a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  uint64_t v11 = (void *)*a2;
  if (*a2)
  {
    do
    {
      int v12 = v11;
      uint64_t v11 = (void *)v11[1];
    }
    while (v11);
  }
  else
  {
    int v16 = a2;
    do
    {
      int v12 = (void *)v16[2];
      BOOL v17 = *v12 == (void)v16;
      int v16 = v12;
    }
    while (v17);
  }
  if (sub_1CC4D9D2C(v12 + 4, a5)) {
    goto LABEL_16;
  }
LABEL_30:

  return sub_1CD59C0A4((uint64_t)a1, a3, a5);
}

void *sub_1CD59C0A4(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        int v7 = v4;
        int v8 = v4 + 4;
        if (!sub_1CC4D9D2C(a3, v4 + 4)) {
          break;
        }
        uint64_t v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CC4D9D2C(v8, a3)) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    int v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void sub_1CD59C138(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
    int v8 = v6[1] ? (uint64_t *)v6[1] : v6;
    if (v8)
    {
      int v12 = sub_1CD4F3428((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v13 = a2;
        do
        {
          uint64_t v14 = v8;
          int v8 = v12;
          long long v15 = *((_OWORD *)v13 + 2);
          long long v16 = *((_OWORD *)v13 + 3);
          v14[8] = v13[8];
          *((_OWORD *)v14 + 2) = v15;
          *((_OWORD *)v14 + 3) = v16;
          sub_1CD59C2A4((uint64_t **)a1, v14);
          if (v12) {
            int v12 = sub_1CD4F3428((uint64_t)v12);
          }
          BOOL v17 = (void *)v13[1];
          if (v17)
          {
            do
            {
              a2 = v17;
              BOOL v17 = (void *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              a2 = (void *)v13[2];
              BOOL v11 = *a2 == (void)v13;
              uint64_t v13 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v13 = a2;
        }
        while (a2 != a3);
      }
      sub_1CD3C5048(a1, v8);
      if (v12)
      {
        do
        {
          long long v18 = v12;
          int v12 = (uint64_t *)v12[2];
        }
        while (v12);
        sub_1CD3C5048(a1, v18);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD59C350((uint64_t **)a1, (uint64_t)(a2 + 4));
      long long v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          long long v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

uint64_t *sub_1CD59C2A4(uint64_t **a1, void *a2)
{
  uint64_t v5 = (uint64_t *)(a1 + 1);
  uint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v4;
        if (!sub_1CC4D9D2C(a2 + 4, (unint64_t *)v4 + 4)) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v5;
        uint64_t v6 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v5[1];
    }
    while (v4);
    uint64_t v6 = v5 + 1;
  }
  else
  {
    uint64_t v6 = (uint64_t *)(a1 + 1);
  }
LABEL_8:
  *a2 = 0;
  a2[1] = 0;
  a2[2] = v5;
  *uint64_t v6 = (uint64_t)a2;
  uint64_t v7 = (uint64_t *)**a1;
  if (v7)
  {
    *a1 = v7;
    a2 = (void *)*v6;
  }
  uint64_t result = sub_1CB8358B8(a1[1], a2);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1CD59C350(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x48uLL);
  long long v5 = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v4 + 2) = *(_OWORD *)a2;
  *((_OWORD *)v4 + 3) = v5;
  *((void *)v4 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a2 + 32);
  uint64_t v7 = (void **)(a1 + 1);
  uint64_t v6 = a1[1];
  if (v6)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = (void **)v6;
        if (!sub_1CC4D9D2C((unint64_t *)v4 + 4, (unint64_t *)v6 + 4)) {
          break;
        }
        uint64_t v6 = (uint64_t *)*v7;
        int v8 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      uint64_t v6 = (uint64_t *)v7[1];
    }
    while (v6);
    int v8 = v7 + 1;
  }
  else
  {
    int v8 = (void **)(a1 + 1);
  }
LABEL_8:
  *(void *)uint64_t v4 = 0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = v7;
  *int v8 = v4;
  long long v9 = (uint64_t *)**a1;
  if (v9)
  {
    *a1 = v9;
    uint64_t v4 = *v8;
  }
  uint64_t result = sub_1CB8358B8(a1[1], (uint64_t *)v4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t sub_1CD59C418(uint64_t a1, int a2)
{
  uint64_t v6 = 0;
  if (sub_1CD59C478(a1, a2, &v6)) {
    return v6;
  }
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    uint64_t v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 16 * v5;
}

uint64_t sub_1CD59C478(uint64_t a1, int a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & a2;
  uint64_t v7 = (_DWORD *)(v3 + 16 * v6);
  int v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -2;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (_DWORD *)(v3 + 16 * (v13 & v5));
      int v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t sub_1CD59C51C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 33) = 0;
  *(void *)(a1 + 40) = a1 + 56;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = 0x2000000000;
  *(void *)(a1 + 2104) = a1 + 2120;
  *(void *)(a1 + 2112) = 0x2000000000;
  *(_DWORD *)(a1 + 2392) = 0;
  *(_OWORD *)(a1 + 2376) = 0u;
  *(_OWORD *)(a1 + 2400) = 0u;
  *(_DWORD *)(a1 + 2416) = 0;
  *(void *)(a1 + 2424) = a1 + 2440;
  *(void *)(a1 + 2432) = 0x400000000;
  *(_DWORD *)(a1 + 248sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_OWORD *)(a1 + 2472) = 0u;
  *(_OWORD *)(a1 + 2496) = 0u;
  *(_DWORD *)(a1 + 2512) = 0;
  *(void *)(a1 + 2520) = a5;
  *(void *)(a1 + 252sub_1CD521E44((uint64_t)this + 8) = a6;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = (*(uint64_t (**)(void))(**(void **)(a4 + 16) + 120))(*(void *)(a4 + 16));
  *(unsigned char *)(a1 + 32) = llvm::TargetOptions::ShouldEmitDebugEntryValues((llvm::TargetOptions *)(*(void *)(a7 + 112)
                                                                                              + 1008));
  return a1;
}

uint64_t sub_1CD59C5F4(uint64_t a1, uint64_t a2, void *a3, int *a4, unsigned int a5)
{
  v63[2] = *MEMORY[0x1E4F143B8];
  uint64_t v50 = (_DWORD *)(a1 + 2376);
  sub_1CD59CFD4((_DWORD *)(a1 + 2376));
  unsigned int v49 = (char *)(a1 + 2400);
  sub_1CD59D0A8((char *)(a1 + 2400));
  *(_DWORD *)(a1 + 2112) = 0;
  if (*(_DWORD *)(a1 + 2116) < a5) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  sub_1CD59D104((_DWORD *)(a1 + 2472));
  sub_1CC4E4A18((char *)(a1 + 2496));
  int v9 = 0;
  v61[0] = 0;
  v61[1] = 0;
  unsigned int v62 = 0;
  uint64_t v10 = a4[2];
  if (v10)
  {
    uint64_t v11 = 120 * v10;
    BOOL v12 = (_DWORD *)(*(void *)a4 + 112);
    do
    {
      if (*v12 == 1)
      {
        unint64_t v57 = *((void *)v12 - 9);
        int v58 = -1;
        sub_1CD59D638((uint64_t)v53, (uint64_t)v61, &v57, &v58);
      }
      v12 += 30;
      v11 -= 120;
    }
    while (v11);
    int v9 = a4[2];
  }
  sub_1CD59D1C8(v50, v9);
  sub_1CD59D214(v49, a4[2]);
  int v13 = *(_DWORD *)(*(void *)(a1 + 16) + 40);
  if (v13)
  {
    int v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = v61[0];
    int v19 = v62;
    uint64_t v52 = v61[0] + 16 * v62;
    do
    {
      BOOL v20 = (unint64_t *)(*a3 + 8 * v17);
      if (*v20 != LiveDebugValues::ValueIDNum::EmptyValue)
      {
        unint64_t v21 = *(unsigned int *)(a1 + 2112);
        if (v21 >= *(unsigned int *)(a1 + 2116)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 2104) + 8 * v21) = *v20;
        ++*(_DWORD *)(a1 + 2112);
        *(void *)&v53[0] = 0;
        int v22 = sub_1CD59D6D0(v18, v19, v20, v53);
        uint64_t v23 = *(void *)&v53[0];
        if (v22) {
          BOOL v24 = *(void *)&v53[0] == v52;
        }
        else {
          BOOL v24 = 1;
        }
        if (!v24)
        {
          uint64_t v25 = *(unsigned int *)(*(void *)&v53[0] + 8);
          if (v25 == -1
            || *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 88) + 4 * v25) >= *(_DWORD *)(*(void *)(a1 + 16)
                                                                                            + 236)
            || !sub_1CD59D260(a1, v25) && sub_1CD59D260(a1, v17))
          {
            *(_DWORD *)(v23 + sub_1CD521E44((uint64_t)this + 8) = v16;
          }
        }
      }
      int v16 = v17 + 1;
      uint64_t v17 = (v17 + 1);
    }
    while (v13 != v16);
  }
  uint64_t v14 = a4[2];
  if (v14)
  {
    uint64_t v26 = 0;
    uint64_t v27 = *(void *)a4;
    uint64_t v28 = 120 * v14;
    do
    {
      int v29 = (long long *)(v27 + v26);
      if (!*(unsigned char *)(a1 + 33)
        || (uint64_t v30 = *((void *)v29 + 12)) == 0
        || (v32 = v30 + 24, int v31 = *(void **)(v30 + 24), ((*(void *)(v32 + 8) - (void)v31) & 0x7FFFFFFF8) == 0)
        || *v31 != 4099)
      {
        if (*((_DWORD *)v29 + 28) == 2)
        {
          unsigned int v33 = sub_1CD59B0F4((llvm::MachineFunction **)a1, (const llvm::MachineOperand *)(v27 + v26 + 48), (uint64_t *)(v27 + v26), (uint64_t *)(v27 + v26 + 96));
LABEL_36:
          unint64_t v34 = *(unsigned int *)(a1 + 2432);
          if (v34 >= *(unsigned int *)(a1 + 2436)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 2424) + 8 * v34) = v33;
          ++*(_DWORD *)(a1 + 2432);
          goto LABEL_32;
        }
        long long v35 = (unint64_t *)v29 + 5;
        *(void *)&v53[0] = 0;
        uint64_t v36 = v61[0];
        uint64_t v37 = v62;
        int v38 = sub_1CD59D6D0(v61[0], v62, (unint64_t *)v29 + 5, v53);
        uint64_t v39 = *(void *)&v53[0];
        if (!v38) {
          uint64_t v39 = v36 + 16 * v37;
        }
        uint64_t v40 = *(unsigned int *)(v39 + 8);
        if (v40 != -1)
        {
          int v60 = *(_DWORD *)(v39 + 8);
          *(void *)((char *)v63 + 4) = *(void *)(v27 + v26 + 96);
          BYTE4(v63[1]) = *(unsigned char *)(v27 + v26 + 104);
          long long v44 = *v29;
          long long v45 = v29[1];
          uint64_t v54 = *((void *)v29 + 4);
          v53[0] = v44;
          v53[1] = v45;
          int v55 = v40;
          v56[0] = v63[0];
          *(void *)((char *)v56 + 5) = *(void *)((char *)v63 + 5);
          sub_1CD59ADF0((uint64_t)&v57, (uint64_t)v49, (uint64_t)v53, (long long *)&v55);
          if (!v59)
          {
            unint64_t v46 = v57;
            *(_DWORD *)(v57 + 40) = v40;
            *(void *)(v46 + 44) = v63[0];
            *(void *)(v46 + 49) = *(void *)((char *)v63 + 5);
          }
          int v47 = sub_1CD59A81C((uint64_t)v50, &v60);
          sub_1CD598850((uint64_t)(v47 + 2), (unint64_t *)(v27 + v26));
          LiveDebugValues::MLocTracker::emitLoc(*(void *)(a1 + 16), v40 | 0x100000000, v27 + v26, v27 + v26 + 96);
          unsigned int v33 = v48;
          goto LABEL_36;
        }
        uint64_t v41 = (uint64_t *)(v27 + v26 + 96);
        uint64_t v42 = (uint64_t *)(v27 + v26);
        if ((*v35 & 0xFFFFF00000) != 0 && (*v35 & 0xFFFFF) == *(_DWORD *)(a2 + 24)) {
          sub_1CD5929AC(a1, (uint64_t)v42, v41, *v35);
        }
        else {
          sub_1CD5925AC((llvm::MachineInstr *)a1, v42, (uint64_t)v41, (void *)v29 + 5);
        }
      }
LABEL_32:
      v26 += 120;
    }
    while (v28 != v26);
  }
  sub_1CD592A64(a1, *(void *)(a2 + 56), a2);
  return MEMORY[0x1D25D9CD0](v61[0], 8);
}

void sub_1CD59CA90(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 2472);
  unsigned int v6 = *(_DWORD *)(a1 + 2488);
  if (v6)
  {
    unsigned int v7 = (v6 - 1) & (37 * a2);
    int v8 = (int *)(v5 + 88 * v7);
    int v9 = *v8;
    if (*v8 == a2) {
      goto LABEL_3;
    }
    int v17 = 1;
    while (v9 != -1)
    {
      unsigned int v18 = v7 + v17++;
      unsigned int v7 = v18 & (v6 - 1);
      int v8 = (int *)(v5 + 88 * v7);
      int v9 = *v8;
      if (*v8 == a2) {
        goto LABEL_3;
      }
    }
  }
  int v8 = (int *)(v5 + 88 * v6);
LABEL_3:
  if (v8 != (int *)(v5 + 88 * v6))
  {
    uint64_t v10 = v8[4];
    if (v10)
    {
      uint64_t v11 = v10 << 6;
      uint64_t v12 = *((void *)v8 + 1) + 48;
      do
      {
        unint64_t v13 = *(void *)(v12 - 48);
        unint64_t v14 = v13 >> 40;
        if (*(void *)(*(void *)(*(void *)(a1 + 16) + 32) + 8 * (v13 >> 40)) == v13)
        {
          uint64_t v19 = 0;
          if (sub_1CC39FD20((uint64_t *)(a1 + 2496), (uint64_t *)(v12 - 40), &v19))
          {
            LiveDebugValues::MLocTracker::emitLoc(*(void *)(a1 + 16), v14 | 0x100000000, v12 - 40, v12);
            unint64_t v16 = *(unsigned int *)(a1 + 2432);
            if (v16 >= *(unsigned int *)(a1 + 2436)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 2424) + 8 * v16) = v15;
            ++*(_DWORD *)(a1 + 2432);
          }
        }
        v12 += 64;
        v11 -= 64;
      }
      while (v11);
    }
    sub_1CD592A64(a1, a3, 0);
  }
}

uint64_t sub_1CD59CC24(uint64_t a1)
{
  int v1 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 > 1u || *(_DWORD *)(a1 + 4))
  {
    if (v1)
    {
      uint64_t v3 = a1 + 8;
      uint64_t v4 = a1 + 392;
      goto LABEL_8;
    }
    unsigned int v2 = *(_DWORD *)(a1 + 16);
    if (((2 * v1) & 0xFFFFFFFC) >= v2)
    {
      if (!v2)
      {
        int v5 = 0;
LABEL_10:
        *(_DWORD *)a1 = v5;
        *(_DWORD *)(a1 + 4) = 0;
        return a1;
      }
      goto LABEL_6;
    }
    if (v2 <= 0x40)
    {
LABEL_6:
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = v3 + 48 * v2;
      do
      {
LABEL_8:
        *(void *)uint64_t v3 = 0;
        *(unsigned char *)(v3 + sub_1CD521E44((uint64_t)this + 8) = 0;
        *(void *)(v3 + 9) = *(void *)v7;
        *(void *)(v3 + 16) = *(void *)&v7[7];
        *(unsigned char *)(v3 + 24) = 0;
        *(_DWORD *)(v3 + 25) = *(_DWORD *)v6;
        *(_DWORD *)(v3 + 2sub_1CD521E44((uint64_t)this + 8) = *(_DWORD *)&v6[3];
        *(void *)(v3 + 32) = 0;
        v3 += 48;
      }
      while (v3 != v4);
      int v5 = *(_DWORD *)a1 & 1;
      goto LABEL_10;
    }
    return (uint64_t)sub_1CD59CE5C(a1);
  }
  return a1;
}

char *sub_1CD59CD40(char *result)
{
  if (*((void *)result + 1))
  {
    unsigned int v1 = *((_DWORD *)result + 4);
    if (v1 > 4 * *((_DWORD *)result + 2) && v1 >= 0x41)
    {
      return sub_1CD59CDA0(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void *)result;
        uint64_t v3 = *(void *)result + 48 * v1;
        do
        {
          *(void *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + sub_1CD521E44((uint64_t)this + 8) = 0;
          *(unsigned char *)(v2 + 24) = 0;
          *(void *)(v2 + 32) = 0;
          v2 += 48;
        }
        while (v2 != v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

char *sub_1CD59CDA0(char *result)
{
  unsigned int v1 = result;
  unsigned int v2 = *((_DWORD *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(void *)result;
      uint64_t v7 = *(void *)result + 48 * v2;
      do
      {
        *(void *)uint64_t v6 = 0;
        *(unsigned char *)(v6 + sub_1CD521E44((uint64_t)this + 8) = 0;
        *(unsigned char *)(v6 + 24) = 0;
        *(void *)(v6 + 32) = 0;
        v6 += 48;
      }
      while (v6 != v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC4E4974(v1, v5);
  }
  return result;
}

int *sub_1CD59CE5C(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)a1;
  char v3 = __clz((*(_DWORD *)a1 >> 1) - 1);
  if ((v3 & 0x3E) == 0x1C) {
    int v4 = 64;
  }
  else {
    int v4 = 1 << (33 - v3);
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 9)
  {
LABEL_9:
    return sub_1CD59CF18((int *)a1);
  }
  if ((v2 & 1) == 0)
  {
    if (v5 == *(_DWORD *)(a1 + 16)) {
      goto LABEL_9;
    }
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }

  return sub_1CD59CF68(a1, v5);
}

int *sub_1CD59CF18(int *result)
{
  int v1 = *result;
  *(void *)uint64_t result = *result & 1;
  if (v1)
  {
    char v3 = result + 2;
    int v4 = result + 98;
  }
  else
  {
    unsigned int v2 = result[4];
    if (!v2) {
      return result;
    }
    char v3 = (int *)*((void *)result + 1);
    int v4 = &v3[12 * v2];
  }
  do
  {
    *(void *)char v3 = 0;
    *((unsigned char *)v3 + sub_1CD521E44((uint64_t)this + 8) = 0;
    *((unsigned char *)v3 + 24) = 0;
    *((void *)v3 + 4) = 0;
    v3 += 12;
  }
  while (v3 != v4);
  return result;
}

int *sub_1CD59CF68(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)a1;
  *(_DWORD *)a1 |= 1u;
  if (a2 >= 9)
  {
    *(_DWORD *)a1 = v3 & 0xFFFFFFFE;
    uint64_t v4 = a2;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(48 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v4;
  }

  return sub_1CD59CF18((int *)a1);
}

void sub_1CD59CFD4(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  unsigned int v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 208 * v3;
    uint64_t v5 = *(void *)a1 + 184;
    while (1)
    {
      int v6 = *(_DWORD *)(v5 - 184);
      if (v6 == -2) {
        goto LABEL_10;
      }
      if (v6 != -1) {
        break;
      }
LABEL_11:
      v5 += 208;
      v4 -= 208;
      if (!v4) {
        goto LABEL_12;
      }
    }
    sub_1CD3C5048(v5, *(void **)(v5 + 8));
    uint64_t v7 = *(void **)(v5 - 176);
    if ((void *)(v5 - 160) != v7) {
      free(v7);
    }
LABEL_10:
    *(_DWORD *)(v5 - 184) = -1;
    goto LABEL_11;
  }

  sub_1CD59D364(a1);
}

char *sub_1CD59D0A8(char *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = *((unsigned int *)result + 4);
    if (v1 > 4 * *((_DWORD *)result + 2) && v1 >= 0x41)
    {
      return sub_1CD59D484(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void *)result;
        uint64_t v3 = *(void *)result + (v1 << 6);
        do
        {
          *(void *)uint64_t v2 = 0;
          *(unsigned char *)(v2 + sub_1CD521E44((uint64_t)this + 8) = 0;
          *(unsigned char *)(v2 + 24) = 0;
          *(void *)(v2 + 32) = 0;
          v2 += 64;
        }
        while (v2 != v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

void sub_1CD59D104(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  unsigned int v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 88 * v3;
    uint64_t v5 = *(void *)a1 + 24;
    while (1)
    {
      int v6 = *(_DWORD *)(v5 - 24);
      if (v6 == -2) {
        goto LABEL_10;
      }
      if (v6 != -1) {
        break;
      }
LABEL_11:
      v5 += 88;
      v4 -= 88;
      if (!v4) {
        goto LABEL_12;
      }
    }
    uint64_t v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(_DWORD *)(v5 - 24) = -1;
    goto LABEL_11;
  }

  sub_1CD59D53C(a1);
}

_DWORD *sub_1CD59D1C8(_DWORD *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (result[4] <= v4) {
      return sub_1CD59AAA0((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

char *sub_1CD59D214(char *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (*((_DWORD *)result + 4) <= v4) {
      return sub_1CD59AF5C((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

BOOL sub_1CD59D260(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(*(void *)(v2 + 88) + 4 * a2);
  if (v3 >= *(_DWORD *)(v2 + 236)) {
    return 0;
  }
  int v6 = (v5 = *(void *)(a1 + 2520)) != 0 ? (void *)(v5 + 8) : 0;
  sub_1CB8FB608((uint64_t)v12, v3, v6, 1);
  if (!v14) {
    return 0;
  }
  BOOL v7 = 1;
  if (!((1 << v15) & *(void *)(**(void **)(a1 + 2528) + (((unint64_t)v15 >> 3) & 0x1FF8))))
  {
    BOOL v7 = 0;
    while (1)
    {
      sub_1CB8FB704((uint64_t)v12);
      if (v13 || v14 == 0) {
        break;
      }
      if (v12[0] != v15)
      {
LABEL_15:
        uint64_t v10 = (1 << v15) & *(void *)(**(void **)(a1 + 2528) + (((unint64_t)v15 >> 3) & 0x1FF8));
        BOOL v7 = v10 != 0;
        if (v10) {
          return 1;
        }
      }
    }
    if (!v14) {
      return v7;
    }
    goto LABEL_15;
  }
  return v7;
}

void sub_1CD59D364(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CD59D418((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(_DWORD **)a1;
      uint64_t v6 = 208 * v4;
      do
      {
        _DWORD *v5 = -1;
        v5 += 52;
        v6 -= 208;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC4E4838(a1, v4);
  }
}

void sub_1CD59D418(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 208 * v1;
    uint64_t v3 = *(void *)a1 + 184;
    do
    {
      if (*(_DWORD *)(v3 - 184) <= 0xFFFFFFFD)
      {
        sub_1CD3C5048(v3, *(void **)(v3 + 8));
        unsigned int v4 = *(void **)(v3 - 176);
        if ((void *)(v3 - 160) != v4) {
          free(v4);
        }
      }
      v3 += 208;
      v2 -= 208;
    }
    while (v2);
  }
}

char *sub_1CD59D484(char *result)
{
  unsigned int v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(void *)result;
      uint64_t v7 = *(void *)result + (v2 << 6);
      do
      {
        *(void *)uint64_t v6 = 0;
        *(unsigned char *)(v6 + sub_1CD521E44((uint64_t)this + 8) = 0;
        *(unsigned char *)(v6 + 24) = 0;
        *(void *)(v6 + 32) = 0;
        v6 += 64;
      }
      while (v6 != v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC4E48D4(v1, v5);
  }
  return result;
}

void sub_1CD59D53C(_DWORD *a1)
{
  unsigned int v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 88 * v2;
    uint64_t v5 = *(void *)a1 + 24;
    do
    {
      if (*(_DWORD *)(v5 - 24) <= 0xFFFFFFFD)
      {
        uint64_t v6 = *(void **)(v5 - 16);
        if ((void *)v5 != v6) {
          free(v6);
        }
      }
      v5 += 88;
      v4 -= 88;
    }
    while (v4);
  }
  int v7 = 1 << (33 - __clz(v3 - 1));
  if (v7 <= 64) {
    int v7 = 64;
  }
  if (v3) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 0;
  }
  if (v8 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v8)
    {
      int v9 = *(_DWORD **)a1;
      uint64_t v10 = 88 * v8;
      do
      {
        *int v9 = -1;
        v9 += 22;
        v10 -= 88;
      }
      while (v10);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC3A6BC8(a1, v8);
  }
}

uint64_t sub_1CD59D638(uint64_t a1, uint64_t a2, unint64_t *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD59D6D0(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v12);
  int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD59D7F4(a2, a3, v12);
    int v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD59D6D0(uint64_t a1, int a2, unint64_t *a3, void *a4)
{
  if (a2)
  {
    uint64_t v8 = LiveDebugValues::ValueIDNum::EmptyValue;
    uint64_t v9 = LiveDebugValues::ValueIDNum::TombstoneValue;
    unint64_t v10 = *a3;
    unint64_t v11 = HIDWORD(*a3);
    unint64_t v12 = 0x9DDFEA08EB382D69 * ((8 * v10 + sub_1CBF65470()) ^ HIDWORD(v10));
    int v13 = a2 - 1;
    unsigned int v14 = (-348639895
         * ((((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 32) >> 15) ^ (-348639895
                                                                                              * (v11 ^ (v12 >> 47) ^ v12)))) & (a2 - 1);
    unsigned __int16 v15 = (void *)(a1 + 16 * v14);
    uint64_t v16 = *v15;
    if (*a3 == *v15)
    {
      uint64_t result = 1;
    }
    else
    {
      unsigned int v18 = 0;
      int v19 = 1;
      uint64_t result = 1;
      while (v16 != v8)
      {
        if (v18) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v16 == v9;
        }
        if (v20) {
          unsigned int v18 = v15;
        }
        unsigned int v21 = v14 + v19++;
        unsigned int v14 = v21 & v13;
        unsigned __int16 v15 = (void *)(a1 + 16 * (v21 & v13));
        uint64_t v16 = *v15;
        if (*a3 == *v15) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v18) {
        unsigned __int16 v15 = v18;
      }
    }
  }
  else
  {
    unsigned __int16 v15 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a4 = v15;
  return result;
}

void *sub_1CD59D7F4(uint64_t a1, unint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD59D8B0(a1, v6);
  uint64_t v8 = 0;
  sub_1CD59D6D0(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != LiveDebugValues::ValueIDNum::EmptyValue) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD59D8B0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD59D980(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = LiveDebugValues::ValueIDNum::EmptyValue;
    uint64_t v12 = 16 * v10;
    do
    {
      void *result = v11;
      result += 2;
      v12 -= 16;
    }
    while (v12);
  }
  return result;
}

uint64_t sub_1CD59D980(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = LiveDebugValues::ValueIDNum::EmptyValue;
  uint64_t v7 = *(unsigned int *)(result + 16);
  if (v7)
  {
    unsigned int v8 = *(uint64_t **)result;
    uint64_t v9 = 16 * v7;
    do
    {
      *unsigned int v8 = v6;
      v8 += 2;
      v9 -= 16;
    }
    while (v9);
    uint64_t v6 = LiveDebugValues::ValueIDNum::EmptyValue;
  }
  if (a2 != a3)
  {
    uint64_t v10 = LiveDebugValues::ValueIDNum::TombstoneValue;
    do
    {
      if (*(void *)v4 != v6 && *(void *)v4 != v10)
      {
        int v13 = 0;
        uint64_t result = sub_1CD59D6D0(*(void *)v5, *(_DWORD *)(v5 + 16), (unint64_t *)v4, &v13);
        uint64_t v12 = v13;
        *int v13 = *(void *)v4;
        *((_DWORD *)v12 + 2) = *(_DWORD *)(v4 + 8);
        ++*(_DWORD *)(v5 + 8);
      }
      v4 += 16;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t sub_1CD59DA58(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 800), 4);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 776), 4);
  unsigned int v2 = *(void **)(a1 + 248);
  if (v2 != (void *)(a1 + 264)) {
    free(v2);
  }
  sub_1CD59DB08(a1 + 184);
  sub_1CB833A08(a1 + 160, *(void **)(a1 + 168));
  uint64_t v3 = *(void **)(a1 + 112);
  if (v3 != (void *)(a1 + 128)) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 88);
  if (v4 != (void *)(a1 + 104)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 64);
  if (v5)
  {
    *(void *)(a1 + 72) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 32);
  if (v6 != (void *)(a1 + 48)) {
    free(v6);
  }
  return a1;
}

uint64_t sub_1CD59DB08(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  sub_1CD40B1BC(*(void **)(a1 + 8));
  return a1;
}

uint64_t sub_1CD59DB44(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 2496), 8);
  sub_1CD59DBCC((uint64_t *)(a1 + 2472));
  unsigned int v2 = *(void **)(a1 + 2424);
  if (v2 != (void *)(a1 + 2440)) {
    free(v2);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 2400), 8);
  sub_1CD59D418(a1 + 2376);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 2376), 8);
  uint64_t v3 = *(void **)(a1 + 2104);
  if (v3 != (void *)(a1 + 2120)) {
    free(v3);
  }
  sub_1CD531B58((char **)(a1 + 40));
  return a1;
}

uint64_t *sub_1CD59DBCC(uint64_t *a1)
{
  unsigned int v2 = *((_DWORD *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 88 * v2;
    uint64_t v5 = (void *)(v3 + 24);
    do
    {
      if (*((_DWORD *)v5 - 6) <= 0xFFFFFFFD)
      {
        uint64_t v6 = (void *)*(v5 - 2);
        if (v5 != v6) {
          free(v6);
        }
      }
      v5 += 11;
      v4 -= 88;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CD59DC44(uint64_t a1)
{
  *(void *)a1 = &unk_1F2616098;
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 1992), 8);
  sub_1CC4DFF94(a1 + 1968);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 1968), 8);
  sub_1CC4E00E0(a1 + 1944);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 1944), 8);
  unsigned int v2 = *(void **)(a1 + 648);
  if (v2 != (void *)(a1 + 664)) {
    free(v2);
  }
  sub_1CBC0FD34(*(void **)(a1 + 632));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 600), 4);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 576), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 552), 8);
  uint64_t v3 = *(void **)(a1 + 400);
  if (v3 != *(void **)(a1 + 392)) {
    free(v3);
  }
  sub_1CC2EDB5C(a1 + 128);
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4 != (void *)(a1 + 72)) {
    free(v4);
  }
  return a1;
}

void sub_1CD59DD30(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v7 = *(_DWORD **)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  if (a2 <= (v6 - (uint64_t)v7) >> 2)
  {
    uint64_t v19 = 4 * a2;
    BOOL v20 = &v7[a2];
    do
    {
      *v7++ = *a3;
      v19 -= 4;
    }
    while (v19);
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v20;
  }
  else
  {
    unsigned int v8 = *(_DWORD **)a1;
    uint64_t v9 = (uint64_t)v7 - *(void *)a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        sub_1CB833614();
      }
      int v13 = (char *)operator new(4 * v12);
    }
    else
    {
      int v13 = 0;
    }
    unsigned int v14 = &v13[4 * (v9 >> 2)];
    unsigned __int16 v15 = &v14[4 * a2];
    uint64_t v16 = 4 * a2;
    int v17 = v14;
    do
    {
      *(_DWORD *)int v17 = *a3;
      v17 += 4;
      v16 -= 4;
    }
    while (v16);
    while (v7 != v8)
    {
      int v18 = *--v7;
      *((_DWORD *)v14 - 1) = v18;
      v14 -= 4;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v15;
    *(void *)(a1 + 16) = &v13[4 * v12];
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t sub_1CD59DE68(_DWORD *a1, uint64_t a2)
{
  uint64_t v9 = 0;
  char v4 = sub_1CC4E4A78((uint64_t)a1, (uint64_t *)a2, &v9);
  uint64_t v5 = v9;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD59DED0(a1, (uint64_t *)a2, v9);
    uint64_t v7 = *(void *)(a2 + 32);
    long long v8 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    *(_OWORD *)(v5 + 16) = v8;
    *(void *)(v5 + 32) = v7;
    *(void *)(v5 + 40) = 0;
  }
  return v5;
}

uint64_t sub_1CD59DED0(_DWORD *a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_13;
  }
  if (v6 + ~v5 - a1[1] <= v6 >> 3)
  {
LABEL_13:
    sub_1CC4E4BA8((uint64_t)a1, v6);
    uint64_t v8 = 0;
    sub_1CC4E4A78((uint64_t)a1, a2, &v8);
    a3 = v8;
  }
  *a1 += 2;
  if (*(void *)a3 || *(unsigned char *)(a3 + 24) || *(void *)(a3 + 32)) {
    --a1[1];
  }
  return a3;
}

_OWORD *sub_1CD59DFA0(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  int v5 = (void **)sub_1CD59C0A4(a1, &v13, a2);
  unsigned int v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    unsigned int v6 = operator new(0x48uLL);
    long long v9 = *(_OWORD *)(a3 + 16);
    void v6[2] = *(_OWORD *)a3;
    v6[3] = v9;
    *((void *)v6 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a3 + 32);
    uint64_t v10 = v13;
    *(void *)unsigned int v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v10;
    *uint64_t v8 = v6;
    uint64_t v11 = **(void **)a1;
    unint64_t v12 = (uint64_t *)v6;
    if (v11)
    {
      *(void *)a1 = v11;
      unint64_t v12 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

unint64_t sub_1CD59E054(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 40 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t sub_1CD59E0D0(uint64_t a1, uint64_t a2, unsigned __int16 *a3, _DWORD *a4)
{
  unint64_t v12 = 0;
  uint64_t result = sub_1CD59B9B0(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v12);
  long long v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD59BAAC(a2, a3, v12);
    long long v9 = (__int16 *)result;
    *(_WORD *)uint64_t result = *a3;
    *(_WORD *)(result + 2) = a3[1];
    *(_DWORD *)(result + 4) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

_DWORD *sub_1CD59E178(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    long long v9 = 0;
LABEL_5:
    unsigned int v6 = sub_1CD59E234(a1, a2, v9);
    *(void *)unsigned int v6 = *a2;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  unsigned int v6 = (_DWORD *)(*(void *)a1 + 8 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    char v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        char v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      unsigned int v6 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      long long v9 = v10;
    }
    else {
      long long v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD59E234(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD59E3BC(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 8 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD59E3BC(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD59E3BC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD59E488(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      _DWORD *result = -1;
      result += 2;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD59E488(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    int v4 = *(_DWORD **)result;
    uint64_t v5 = 8 * v3;
    do
    {
      *int v4 = -1;
      v4 += 2;
      v5 -= 8;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    int v6 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & (37 * v6);
      int v9 = (_DWORD *)(*(void *)result + 8 * v8);
      int v10 = *v9;
      if (v6 != *v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -1)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -2;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          int v9 = (_DWORD *)(*(void *)result + 8 * (v14 & v7));
          int v10 = *v9;
          if (v6 == *v9) {
            goto LABEL_7;
          }
        }
        if (v11) {
          int v9 = v11;
        }
      }
LABEL_7:
      *int v9 = v6;
      v9[1] = a2[1];
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t *sub_1CD59E55C(uint64_t a1, int *a2)
{
  int v4 = *(uint64_t **)(a1 + 8);
  unsigned int v2 = (uint64_t *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  uint64_t v6 = *((void *)a2 + 1);
  uint64_t v5 = *((void *)a2 + 2);
  int v7 = v2;
  unsigned int v8 = *a2;
  do
  {
    unsigned int v9 = *((_DWORD *)v3 + 8);
    if (v9 < v8)
    {
LABEL_4:
      ++v3;
      goto LABEL_5;
    }
    if (v8 >= v9)
    {
      uint64_t v10 = v3[5];
      if (v10 < v6) {
        goto LABEL_4;
      }
      if (v6 >= v10 && v3[6] < v5) {
        ++v3;
      }
      else {
        int v7 = v3;
      }
    }
    else
    {
      int v7 = v3;
    }
LABEL_5:
    uint64_t v3 = (uint64_t *)*v3;
  }
  while (v3);
  if (v7 == v2) {
    return v2;
  }
  unsigned int v13 = *((_DWORD *)v7 + 8);
  if (v8 < v13) {
    return v2;
  }
  if (v13 >= v8)
  {
    uint64_t v15 = v7[5];
    if (v6 < v15 || v15 >= v6 && v5 < v7[6]) {
      return v2;
    }
  }
  return v7;
}

_OWORD *sub_1CD59E618(uint64_t a1, int *a2, _OWORD **a3)
{
  uint64_t v5 = (void **)sub_1CD59E6CC(a1, &v13, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    unsigned int v8 = v5;
    uint64_t v6 = operator new(0x40uLL);
    uint64_t v9 = *((void *)*a3 + 2);
    void v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    *((_DWORD *)v6 + 14) = 0;
    uint64_t v10 = v13;
    *(void *)uint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v10;
    *unsigned int v8 = v6;
    uint64_t v11 = **(void **)a1;
    int v12 = (uint64_t *)v6;
    if (v11)
    {
      *(void *)a1 = v11;
      int v12 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD59E6CC(uint64_t a1, void *a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v6 = *((void *)a3 + 1);
    uint64_t v7 = *((void *)a3 + 2);
    unsigned int v8 = *a3;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (void *)v4;
        unsigned int v10 = *(_DWORD *)(v4 + 32);
        if (v8 >= v10) {
          break;
        }
LABEL_4:
        uint64_t v4 = *v9;
        uint64_t result = v9;
        if (!*v9) {
          goto LABEL_18;
        }
      }
      if (v10 >= v8)
      {
        uint64_t v11 = v9[5];
        if (v6 < v11) {
          goto LABEL_4;
        }
        uint64_t v12 = v9[6];
        if (v11 >= v6 && v7 < v12) {
          goto LABEL_4;
        }
        if (v11 >= v6 && v12 >= v7) {
          goto LABEL_18;
        }
      }
      uint64_t result = v9 + 1;
      uint64_t v4 = v9[1];
      if (!v4) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v9 = result;
LABEL_18:
  *a2 = v9;
  return result;
}

uint64_t *sub_1CD59E750(uint64_t *result, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = operator new(0x38uLL);
    uint64_t v10 = *(void *)(a3 + 8);
    _OWORD v9[4] = *(void *)a3;
    v9[5] = v10;
    *((_DWORD *)v9 + 12) = *(_DWORD *)(a3 + 16);
    *uint64_t v9 = 0;
    v9[1] = 0;
    v9[2] = v7;
    *uint64_t v6 = v9;
    uint64_t v11 = *(void *)*v4;
    if (v11)
    {
      *uint64_t v4 = v11;
      uint64_t v12 = *v6;
    }
    else
    {
      uint64_t v12 = v9;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v4[1], v12);
    ++v4[2];
  }
  return result;
}

uint64_t sub_1CD59E814(uint64_t a1, uint64_t a2, int *a3, void *a4)
{
  int v16 = 0;
  uint64_t result = sub_1CD59C478(a2, *a3, &v16);
  uint64_t v9 = v16;
  if (result)
  {
    uint64_t v10 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v11 = 4;
    }
    else
    {
      uint64_t v10 = *(void *)(a2 + 8);
      uint64_t v11 = *(unsigned int *)(a2 + 16);
    }
    char v12 = 0;
    uint64_t v13 = v10 + 16 * v11;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD59E8E0((_DWORD *)a2, a3, v16);
    uint64_t v9 = (_DWORD *)result;
    *(_DWORD *)uint64_t result = *a3;
    *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = *a4;
    uint64_t v14 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v15 = 4;
    }
    else
    {
      uint64_t v14 = *(void *)(a2 + 8);
      uint64_t v15 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v13 = v14 + 16 * v15;
    char v12 = 1;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v13;
  *(unsigned char *)(a1 + 16) = v12;
  return result;
}

_DWORD *sub_1CD59E8E0(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD59E9A0((uint64_t)a1, v6);
  unint64_t v8 = 0;
  sub_1CD59C478((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -1) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD59E9A0(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD59EB28(a1, v6, v6 + 16 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    unsigned int v10 = *(_DWORD *)(a1 + v8 + 8);
    if (v10 <= 0xFFFFFFFD)
    {
      *(_DWORD *)uint64_t v9 = v10;
      *((void *)v9 + 1) = *(void *)(a1 + v8 + 16);
      v9 += 16;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD59EB28(a1, (uint64_t)v14, (uint64_t)v9);
}

uint64_t sub_1CD59EB28(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (_DWORD *)(result + 8);
    uint64_t v9 = (_DWORD *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(_DWORD **)(result + 8);
    uint64_t v9 = &v8[4 * v7];
  }
  do
  {
    *uint64_t v8 = -1;
    v8 += 4;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    int v10 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      char v12 = 0;
      uint64_t result = sub_1CD59C478((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *char v12 = *(_DWORD *)a2;
      *((void *)v11 + 1) = *(void *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD59EBF0(uint64_t **a1, unsigned int a2, int a3)
{
  int v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        return 0;
      }
      int v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = operator new(0x20uLL);
    v9[7] = a3;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    *int v6 = (uint64_t *)v9;
    int v10 = (uint64_t *)**a1;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v9;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return 1;
  }
}

uint64_t sub_1CD59ECB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  int v5 = (void *)(*(void *)a1 + 16 * v4);
  void *v5 = a2;
  v5[1] = a3;
  uint64_t v6 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v6;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *(void *)a1 + 16 * v6;

  return sub_1CC4E6D90(v7, v8, v6);
}

uint64_t sub_1CD59ED3C(uint64_t **a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  uint64_t v4 = **a1;
  uint64_t v21 = 0;
  uint64_t v22 = a2;
  uint64_t result = sub_1CBFA3AF4((uint64_t *)(v4 + 24), &v22, &v21);
  if (result)
  {
    uint64_t v6 = v21;
    uint64_t v7 = *(void *)(v4 + 24);
    uint64_t v8 = *(unsigned int *)(v4 + 40);
  }
  else
  {
    uint64_t v7 = *(void *)(v4 + 24);
    uint64_t v8 = *(unsigned int *)(v4 + 40);
    uint64_t v6 = v7 + 16 * v8;
  }
  if (v6 == v7 + 16 * v8) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *(void *)(v6 + 8);
  }
  uint64_t v10 = *(unsigned int *)(v9 + 16);
  if (v10 <= *(_DWORD *)a1[1])
  {
    uint64_t result = (uint64_t)sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1[2], v9);
    if (v11)
    {
      uint64_t v12 = *(void *)v9;
      if (!*((unsigned char *)v3 + 9)) {
        goto LABEL_13;
      }
      uint64_t v13 = (void *)v3[2];
      uint64_t result = (uint64_t)sub_1CB896AE8((uint64_t)v13, *(void *)v9);
      uint64_t v14 = v13[1];
      uint64_t v15 = 16;
      if (v14 == *v13) {
        uint64_t v15 = 20;
      }
      if (result != v14 + 8 * *(unsigned int *)((char *)v13 + v15))
      {
LABEL_13:
        int v16 = a1[3];
        uint64_t v17 = *((unsigned int *)v16 + 2);
        if (v17 >= *((_DWORD *)v16 + 3)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*v16 + 8 * v17) = v12;
        *((_DWORD *)v16 + 2) = v17 + 1;
        unsigned int v18 = (void *)v3[3];
        uint64_t result = (uint64_t)sub_1CB896AE8((uint64_t)v18, v12);
        uint64_t v19 = v18[1];
        uint64_t v20 = 16;
        if (v19 == *v18) {
          uint64_t v20 = 20;
        }
        if (result == v19 + 8 * *(unsigned int *)((char *)v18 + v20)) {
          return sub_1CD59ECB4((uint64_t)a1[4], v9, v10 | ((unint64_t)*(unsigned int *)(v9 + 72) << 32));
        }
      }
    }
  }
  return result;
}

void sub_1CD59EECC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        sub_1CD59EF98();
      }
      if (v2 != a2)
      {
        uint64_t v8 = 32 * a2 - 32 * v2;
        uint64_t v9 = *(void *)a1 + 32 * v2 + 16;
        do
        {
          *(void *)(v9 - 16) = v9;
          *(void *)(v9 - sub_1CD521E44((uint64_t)this + 8) = 0x400000000;
          v9 += 32;
          v8 -= 32;
        }
        while (v8);
      }
    }
    else
    {
      uint64_t v5 = *(void *)a1 + 32 * v2 - 16;
      uint64_t v6 = 32 * a2 - 32 * v2;
      do
      {
        uint64_t v7 = *(void **)(v5 - 16);
        if ((void *)v5 != v7) {
          free(v7);
        }
        v5 -= 32;
        v6 += 32;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v3;
  }
}

void sub_1CD59EF98()
{
}

void sub_1CD59F008(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = 32 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x400000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CD41B598((uint64_t)a2, v5);
      }
      v5 += 32;
      a2 += 4;
      v6 -= 32;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = 32 * v7;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 32);
        if ((void *)(v8 + v9 - 16) != v10) {
          free(v10);
        }
        v9 -= 32;
      }
      while (v9);
    }
  }
}

uint64_t sub_1CD59F0BC(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 4 * v4);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 4 * v5);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 4 * v5), (const void *)(*(void *)a2 + 4 * v5), *(void *)a2 + 4 * v6 - (*(void *)a2 + 4 * v5));
      }
    }
    *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4;
  }
  return a1;
}

unint64_t sub_1CD59F188(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 80 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

unint64_t sub_1CD59F204(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 120 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

void sub_1CD59F280(unint64_t a1, unsigned int *a2, uint64_t a3, char a4)
{
uint64_t sub_1CD59F678(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 208 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 208 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

uint64_t sub_1CD59F714(uint64_t result, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  int v4 = (void *)(*(void *)result + 16 * v3);
  *int v4 = a2;
  v4[1] = a3;
  ++*(_DWORD *)(result + 8);
  return result;
}

char **sub_1CD59F788(char **a1)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 472 * v3;
    do
    {
      unsigned int v5 = &v2[v4];
      if ((v2[v4 - 424] & 1) == 0) {
        MEMORY[0x1D25D9CD0](*((void *)v5 - 52), 8);
      }
      sub_1CD456CB4((void *)v5 - 59);
      v4 -= 472;
    }
    while (v4);
    unsigned int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD59F810(char **a1)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 976 * v3;
    do
    {
      unsigned int v5 = *(char **)&v2[v4 - 976];
      if (&v2[v4 - 960] != v5) {
        free(v5);
      }
      v4 -= 976;
    }
    while (v4);
    unsigned int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD59F88C(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    uint64_t v4 = result;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(result + 12) < a2) {
        sub_1CD59F97C();
      }
      if (v2 != a2)
      {
        uint64_t v8 = *(void *)result + 72 * a2;
        uint64_t v9 = *(void *)result + 72 * v2;
        uint64_t v10 = (void *)v9;
        do
        {
          void *v10 = 1;
          v10 += 9;
          for (uint64_t i = 8; i != 72; i += 16)
            *(_DWORD *)(v9 + i) = -1;
          uint64_t v9 = (uint64_t)v10;
        }
        while (v10 != (void *)v8);
      }
    }
    else
    {
      uint64_t v5 = 9 * v2;
      uint64_t v6 = *(void *)result + 8 * v5 - 72;
      uint64_t v7 = 72 * a2 - 8 * v5;
      do
      {
        if ((*(unsigned char *)v6 & 1) == 0) {
          uint64_t result = MEMORY[0x1D25D9CD0](*(void *)(v6 + 8), 8);
        }
        v6 -= 72;
        v7 += 72;
      }
      while (v7);
    }
    *(_DWORD *)(v4 + sub_1CD521E44((uint64_t)this + 8) = v3;
  }
  return result;
}

void sub_1CD59F97C()
{
}

unsigned int *sub_1CD59F9EC(unsigned int *result, unsigned int *a2)
{
  unsigned int v2 = result[2];
  if (v2)
  {
    int v3 = result;
    uint64_t v4 = *(unsigned int **)result;
    uint64_t v5 = *(void *)result + 72 * v2;
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v6 = 1;
      v6 += 18;
      for (uint64_t i = 2; i != 18; i += 4)
        a2[i] = -1;
      uint64_t result = sub_1CC4EAB10(a2, v4);
      v4 += 18;
      a2 = v6;
    }
    while (v4 != (unsigned int *)v5);
    uint64_t v8 = v3[2];
    if (v8)
    {
      uint64_t v9 = *(void *)v3;
      uint64_t v10 = 72 * v8;
      do
      {
        if ((*(unsigned char *)(v9 + v10 - 72) & 1) == 0) {
          uint64_t result = (unsigned int *)MEMORY[0x1D25D9CD0](*(void *)(v9 + v10 - 64), 8);
        }
        v10 -= 72;
      }
      while (v10);
    }
  }
  return result;
}

unint64_t sub_1CD59FAB0(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t result = sub_1CD59FB24(a1, a3, a2);
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (a2)
  {
    uint64_t v7 = result;
    unint64_t result = *(void *)a1 + 472 * v6;
    uint64_t v8 = a2;
    do
    {
      unint64_t result = sub_1CD59FC84(result, v7) + 472;
      --v8;
    }
    while (v8);
    unsigned int v6 = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v6 + a2;
  return result;
}

unint64_t sub_1CD59FB24(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 472 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD59FB90();
    }
    sub_1CD59FB90();
  }
  return a2;
}

void sub_1CD59FB90()
{
}

void sub_1CD59FC00(uint64_t a1, uint64_t a2)
{
  __n128 v3 = sub_1CC4EAC68(*(void *)a1, *(void *)a1 + 472 * (unint64_t)*(unsigned int *)(a1 + 8), a2);
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = 472 * v4;
    do
    {
      uint64_t v7 = v5 + v6;
      if ((*(unsigned char *)(v5 + v6 - 424) & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)(v7 - 416), 8, v3);
      }
      sub_1CD456CB4((void *)(v7 - 472));
      v6 -= 472;
    }
    while (v6);
  }
}

uint64_t sub_1CD59FC84(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  sub_1CC4EAF5C(a1, a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1CC4EAFE4((void *)(a1 + 24), *(unsigned char **)(a2 + 24), *(unsigned char **)(a2 + 32), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3));
  *(_DWORD *)(a1 + 48) |= 1u;
  sub_1CD59CF18((int *)(a1 + 48));
  sub_1CD59FD28(a1 + 48, (_DWORD *)(a2 + 48));
  long long v4 = *(_OWORD *)(a2 + 440);
  *(_OWORD *)(a1 + 449) = *(_OWORD *)(a2 + 449);
  *(_OWORD *)(a1 + 440) = v4;
  return a1;
}

void *sub_1CD59FD28(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
    unsigned int v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 | 1;
  if ((*(unsigned char *)a2 & 1) == 0 && a2[4] >= 9u)
  {
    *(_DWORD *)a1 = v4 & 0xFFFFFFFE;
    if (*a2) {
      uint64_t v5 = 8;
    }
    else {
      uint64_t v5 = a2[4];
    }
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(16 * (v5 + 2 * v5), (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v5;
  }

  return sub_1CD59FDD0((unsigned int *)a1, a2);
}

void *sub_1CD59FDD0(unsigned int *a1, _DWORD *a2)
{
  int v3 = *a1 & 1;
  *a1 = *a2 & 0xFFFFFFFE | v3;
  a1[1] = a2[1];
  unsigned int v4 = a1 + 2;
  if (!v3) {
    unsigned int v4 = (void *)*v4;
  }
  char v6 = *(unsigned char *)a2;
  uint64_t v5 = a2 + 2;
  if ((v6 & 1) == 0) {
    uint64_t v5 = (void *)*v5;
  }
  if (v3) {
    size_t v7 = 384;
  }
  else {
    size_t v7 = 48 * a1[4];
  }
  return memcpy(v4, v5, v7);
}

void sub_1CD59FE24(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        sub_1CD59FEFC();
      }
      if (v2 != a2)
      {
        uint64_t v7 = 976 * a2 - 976 * v2;
        uint64_t v8 = *(void *)a1 + 976 * v2 + 16;
        do
        {
          *(void *)(v8 - 16) = v8;
          *(void *)(v8 - sub_1CD521E44((uint64_t)this + 8) = 0x800000000;
          v8 += 976;
          v7 -= 976;
        }
        while (v7);
      }
    }
    else
    {
      uint64_t v5 = (void **)(*(void *)a1 + 976 * v2 - 976);
      uint64_t v6 = 976 * a2 - 976 * v2;
      do
      {
        if (v5 + 2 != *v5) {
          free(*v5);
        }
        v5 -= 122;
        v6 += 976;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v3;
  }
}

void sub_1CD59FEFC()
{
}

void sub_1CD59FF6C(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = *a1;
    uint64_t v6 = 976 * v2;
    do
    {
      *(void *)a2 = a2 + 16;
      *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0x800000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CD5A002C((char **)a2, (uint64_t **)v5);
      }
      v5 += 976;
      a2 += 976;
      v6 -= 976;
    }
    while (v6);
    unsigned int v7 = *((_DWORD *)a1 + 2);
    if (v7)
    {
      uint64_t v8 = *a1;
      uint64_t v9 = 976 * v7;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 976);
        if ((void *)(v8 + v9 - 960) != v10) {
          free(v10);
        }
        v9 -= 976;
      }
      while (v9);
    }
  }
}

char **sub_1CD5A002C(char **a1, uint64_t **a2)
{
  if (a1 != (char **)a2)
  {
    uint64_t v5 = (uint64_t *)(a2 + 2);
    unsigned int v4 = (long long *)*a2;
    if (*a2 == (uint64_t *)(a2 + 2))
    {
      unsigned int v7 = a2 + 1;
      unsigned int v9 = *((_DWORD *)a2 + 2);
      uint64_t v10 = *((unsigned int *)a1 + 2);
      if (v10 >= v9)
      {
        if (v9)
        {
          BOOL v12 = (long long *)((char *)v4 + 120 * v9);
          unsigned int v13 = *a1;
          do
          {
            long long v14 = *v4;
            long long v15 = v4[1];
            *((void *)v13 + 4) = *((void *)v4 + 4);
            *(_OWORD *)unsigned int v13 = v14;
            *((_OWORD *)v13 + 1) = v15;
            long long v16 = *(long long *)((char *)v4 + 72);
            long long v17 = *(long long *)((char *)v4 + 88);
            long long v18 = *(long long *)((char *)v4 + 100);
            *(_OWORD *)(v13 + 56) = *(long long *)((char *)v4 + 56);
            *(_OWORD *)(v13 + 100) = v18;
            *(_OWORD *)(v13 + 8sub_1CD521E44((uint64_t)this + 8) = v17;
            *(_OWORD *)(v13 + 72) = v16;
            *(_OWORD *)(v13 + 40) = *(long long *)((char *)v4 + 40);
            unsigned int v4 = (long long *)((char *)v4 + 120);
            v13 += 120;
          }
          while (v4 != v12);
        }
      }
      else
      {
        if (*((_DWORD *)a1 + 3) < v9)
        {
          *((_DWORD *)a1 + 2) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          unsigned int v19 = (long long *)((char *)v4 + 120 * v10);
          unint64_t v20 = *a1;
          do
          {
            long long v21 = *v4;
            long long v22 = v4[1];
            *((void *)v20 + 4) = *((void *)v4 + 4);
            *(_OWORD *)unint64_t v20 = v21;
            *((_OWORD *)v20 + 1) = v22;
            long long v23 = *(long long *)((char *)v4 + 72);
            long long v24 = *(long long *)((char *)v4 + 88);
            long long v25 = *(long long *)((char *)v4 + 100);
            *(_OWORD *)(v20 + 56) = *(long long *)((char *)v4 + 56);
            *(_OWORD *)(v20 + 100) = v25;
            *(_OWORD *)(v20 + 8sub_1CD521E44((uint64_t)this + 8) = v24;
            *(_OWORD *)(v20 + 72) = v23;
            *(_OWORD *)(v20 + 40) = *(long long *)((char *)v4 + 40);
            unsigned int v4 = (long long *)((char *)v4 + 120);
            v20 += 120;
          }
          while (v4 != v19);
        }
        else
        {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy(&(*a1)[120 * v10], &(*a2)[15 * v10], (char *)&(*a2)[15 * v11] - (char *)&(*a2)[15 * v10]);
        }
      }
      *((_DWORD *)a1 + 2) = v9;
    }
    else
    {
      uint64_t v6 = *a1;
      if (*a1 != (char *)(a1 + 2))
      {
        free(v6);
        unsigned int v4 = (long long *)*a2;
      }
      *a1 = (char *)v4;
      unsigned int v7 = a2 + 1;
      a1[1] = (char *)a2[1];
      *a2 = v5;
      *((_DWORD *)a2 + 3) = 0;
    }
    *unsigned int v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD5A01D8(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

void sub_1CD5A01F4(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = 208 * a2;
    uint64_t v3 = a1 + 184;
    do
    {
      if ((*(void *)(v3 - 184) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        sub_1CD3C5048(v3, *(void **)(v3 + 8));
        unsigned int v4 = *(void **)(v3 - 176);
        if ((void *)(v3 - 160) != v4) {
          free(v4);
        }
      }
      v3 += 208;
      v2 -= 208;
    }
    while (v2);
  }
}

void sub_1CD5A0268(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = 72 * a2;
    uint64_t v3 = (void **)(a1 + 16);
    do
    {
      if (((unint64_t)*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v3 != *(v3 - 1)) {
        free(*v3);
      }
      v3 += 9;
      v2 -= 72;
    }
    while (v2);
  }
}

uint64_t sub_1CD5A02CC(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v14 = 0;
  uint64_t result = sub_1CC2E9354(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v14);
  uint64_t v9 = v14;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = sub_1CD5A0370(a2, a3, v14);
    uint64_t v9 = result;
    long long v13 = *(_OWORD *)a3;
    long long v12 = *((_OWORD *)a3 + 1);
    *(void *)(result + 32) = a3[4];
    *(_OWORD *)uint64_t result = v13;
    *(_OWORD *)(result + 16) = v12;
    *(_DWORD *)(result + 40) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 48 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD5A0370(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_10;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_10:
    sub_1CD5A0434(a1, v6);
    uint64_t v8 = 0;
    sub_1CC2E9354(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)a3 || *(unsigned char *)(a3 + 24) || *(void *)(a3 + 32)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

char *sub_1CD5A0434(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unsigned int v4 = *(long long **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)operator new(48 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC4EB120(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = &result[48 * v10];
    do
    {
      *(void *)uint64_t result = 0;
      result[8] = 0;
      result[24] = 0;
      *((void *)result + 4) = 0;
      result += 48;
    }
    while (result != v11);
  }
  return result;
}

void *sub_1CD5A0518(uint64_t a1, uint64_t *a2)
{
  unsigned int v8 = 0;
  char v4 = sub_1CD59F678(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD5A05D0(a1, a2, v8);
    uint64_t v7 = *a2;
    *(_OWORD *)(v5 + 21) = 0u;
    *(_OWORD *)(v5 + 19) = 0u;
    *(_OWORD *)(v5 + 17) = 0u;
    *(_OWORD *)(v5 + 15) = 0u;
    *(_OWORD *)(v5 + 13) = 0u;
    *(_OWORD *)(v5 + 11) = 0u;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 7) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    void *v5 = v7;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
    v5[25] = 0;
    v5[24] = 0;
    v5[23] = v5 + 24;
  }
  return v5;
}

void *sub_1CD5A05D0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5A0684(a1, v6);
  unsigned int v8 = 0;
  sub_1CD59F678(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5A0684(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(208 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5A075C(a1, v4, v4 + 208 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 208 * v10;
    do
    {
      void *result = -4096;
      result += 26;
      v11 -= 208;
    }
    while (v11);
  }
  return result;
}

void sub_1CD5A075C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 208 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 26;
      v8 -= 208;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      long long v12 = 0;
      sub_1CD59F678(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      unsigned int v10 = v12;
      *long long v12 = *(void *)a2;
      sub_1CD59AB78(v10 + 1, a2 + 8);
      ++*(_DWORD *)(a1 + 8);
      sub_1CD3C5048(a2 + 184, *(void **)(a2 + 192));
      uint64_t v11 = *(void **)(a2 + 8);
      if ((void *)(a2 + 24) != v11) {
        free(v11);
      }
    }
    a2 += 208;
  }
}

void sub_1CD5A0838(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  sub_1CC4E00E0(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == *(_DWORD *)(a1 + 16))
  {
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
    if (v4)
    {
      unint64_t v5 = *(void **)a1;
      uint64_t v6 = *(void *)a1 + 56 * v4;
      do
      {
        void *v5 = -4096;
        v5[1] = -1;
        void v5[2] = -1;
        v5 += 7;
      }
      while (v5 != (void *)v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC4E4E30((char *)a1, v4);
  }
}

void sub_1CD5A08F8(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC4DFF94((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      unint64_t v5 = *(void **)a1;
      uint64_t v6 = 112 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 14;
        v6 -= 112;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC4E4ED4(a1, v4);
  }
}

_DWORD *sub_1CD5A09AC(_DWORD *result)
{
  unsigned int v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(void **)result;
      uint64_t v7 = 24 * v2;
      do
      {
        *uint64_t v6 = -4096;
        v6 += 3;
        v7 -= 24;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CBC04E60(v1, v5);
  }
  return result;
}

uint64_t sub_1CD5A0A5C(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4)
{
  long long v12 = 0;
  uint64_t result = sub_1CD45B528(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4CB5C0(a2, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_OWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t llvm::ModuleSlotTracker::ModuleSlotTracker(uint64_t this, const llvm::Module *a2, char a3)
{
  *(void *)this = &unk_1F26160C0;
  *(void *)(this + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(this + 16) = a2 != 0;
  *(unsigned char *)(this + 17) = a3;
  *(void *)(this + 72) = 0;
  *(void *)(this + 104) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 24) = a2;
  return this;
}

_DWORD *llvm::ModuleSlotTracker::incorporateFunction(const llvm::Function **this, const llvm::Function *a2)
{
  uint64_t result = (_DWORD *)llvm::ModuleSlotTracker::getMachine((llvm::ModuleSlotTracker *)this);
  if (result)
  {
    int v5 = this[4];
    if (v5 != a2)
    {
      if (v5)
      {
        uint64_t v6 = this[5];
        uint64_t result = sub_1CC0A1FD4((_DWORD *)v6 + 34);
        *((void *)v6 + 2) = 0;
        *((unsigned char *)v6 + 24) = 0;
      }
      uint64_t v7 = this[5];
      *((void *)v7 + 2) = a2;
      *((unsigned char *)v7 + 24) = 0;
      this[4] = a2;
    }
  }
  return result;
}

uint64_t llvm::ModuleSlotTracker::getLocalSlot(llvm::SlotTracker **this, const llvm::Value *a2)
{
  return llvm::SlotTracker::getLocalSlot(this[5], a2);
}

void *llvm::ModuleSlotTracker::setProcessHook(uint64_t a1, uint64_t a2)
{
  return sub_1CC4EDBC8((void *)(a1 + 48), a2);
}

{
  return sub_1CC4EDEAC((void *)(a1 + 80), a2);
}

double llvm::SlotTracker::SlotTracker(llvm::SlotTracker *this, const llvm::Module *a2, char a3)
{
  *(void *)this = &unk_1F26160E0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 24) = 0;
  *((unsigned char *)this + 25) = a3;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 4sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 56) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 3sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0x1000000000;
  *((_DWORD *)this + 66) = 0;
  *((_DWORD *)this + 74) = 0;
  *((_DWORD *)this + 72) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 3sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 40) = 0x1000000000;
  *((_DWORD *)this + 84) = 0;
  return result;
}

double llvm::SlotTracker::SlotTracker(llvm::SlotTracker *this, const llvm::Function *a2, char a3)
{
  *(void *)this = &unk_1F26160E0;
  if (a2) {
    uint64_t v3 = *((void *)a2 + 5);
  }
  else {
    uint64_t v3 = 0;
  }
  *((void *)this + 1) = v3;
  *((void *)this + 2) = a2;
  *((unsigned char *)this + 24) = 0;
  *((unsigned char *)this + 25) = a3;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 4sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 56) = 0;
  double result = 0.0;
  *(_OWORD *)((char *)this + 8sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 3sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((_DWORD *)this + 54) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0x1000000000;
  *((_DWORD *)this + 66) = 0;
  *((_DWORD *)this + 74) = 0;
  *((_DWORD *)this + 72) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 3sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 40) = 0x1000000000;
  *((_DWORD *)this + 84) = 0;
  return result;
}

uint64_t llvm::SlotTracker::processIndex(llvm::SlotTracker *this)
{
  v52[19] = *MEMORY[0x1E4F143B8];
  v50[0] = 0;
  v50[1] = 0;
  unsigned int v49 = (uint64_t *)v50;
  uint64_t v2 = *((void *)this + 12);
  uint64_t v3 = *(uint64_t ****)(v2 + 24);
  uint64_t v4 = *(unsigned int *)(v2 + 32);
  if (v4)
  {
    for (uint64_t i = v3; ; ++i)
    {
      BOOL v36 = !*i || *i + 1 == 0;
      if (!v36) {
        break;
      }
    }
  }
  else
  {
    uint64_t i = v3;
  }
  uint64_t v6 = &v3[v4];
  if (i != v6)
  {
    uint64_t v37 = *i;
    do
    {
      int v38 = (uint64_t *)(v37 + 5);
      uint64_t v39 = *v37;
      uint64_t v40 = sub_1CD5A4928(&v49, (unint64_t)v37[1], v37 + 1);
      v40[5] = v38;
      v40[6] = v39;
      do
      {
        uint64_t v41 = i[1];
        ++i;
        uint64_t v37 = v41;
        if (v41) {
          BOOL v42 = v37 + 1 == 0;
        }
        else {
          BOOL v42 = 1;
        }
      }
      while (v42);
    }
    while (i != v6);
    unsigned int v43 = v49;
    if (v49 != (uint64_t *)v50)
    {
      do
      {
        long long v44 = (unsigned __int8 *)v43[5];
        size_t v45 = v43[6];
        int v46 = *((_DWORD *)this + 66);
        *((_DWORD *)this + 66) = v46 + 1;
        *(_DWORD *)(*sub_1CC44CD14((llvm::SlotTracker *)((char *)this + 232), v44, v45) + sub_1CD521E44((uint64_t)this + 8) = v46;
        int v47 = (uint64_t *)v43[1];
        if (v47)
        {
          do
          {
            unint64_t v48 = v47;
            int v47 = (uint64_t *)*v47;
          }
          while (v47);
        }
        else
        {
          do
          {
            unint64_t v48 = (uint64_t *)v43[2];
            BOOL v36 = *v48 == (void)v43;
            unsigned int v43 = v48;
          }
          while (!v36);
        }
        unsigned int v43 = v48;
      }
      while (v48 != (uint64_t *)v50);
    }
  }
  *((_DWORD *)this + 74) = *((_DWORD *)this + 66);
  uint64_t v7 = (void *)*((void *)this + 12);
  uint64_t v8 = v7 + 1;
  uint64_t v9 = (void *)*v7;
  if ((void *)*v7 != v7 + 1)
  {
    do
    {
      v52[0] = v9[4];
      int v10 = *((_DWORD *)this + 74);
      *((_DWORD *)this + 74) = v10 + 1;
      *((_DWORD *)sub_1CD54145C((uint64_t)this + 272, v52) + 2) = v10;
      uint64_t v11 = (void *)v9[1];
      if (v11)
      {
        do
        {
          long long v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          long long v12 = (void *)v9[2];
          BOOL v36 = *v12 == (void)v9;
          uint64_t v9 = v12;
        }
        while (!v36);
      }
      uint64_t v9 = v12;
    }
    while (v12 != v8);
    uint64_t v7 = (void *)*((void *)this + 12);
  }
  long long v13 = (void *)v7[10];
  uint64_t v14 = v7 + 11;
  if (v13 != v7 + 11)
  {
    do
    {
      char v15 = *((unsigned char *)v13 + 55);
      int v16 = v15;
      if (v15 >= 0) {
        long long v17 = v13 + 4;
      }
      else {
        long long v17 = (void *)v13[4];
      }
      uint64_t v18 = v15 & 0x7F;
      if (v16 >= 0) {
        uint64_t v19 = v18;
      }
      else {
        uint64_t v19 = v13[5];
      }
      double v20 = llvm::MD5::MD5((llvm::MD5 *)v52);
      llvm::MD5::update(v52, v17, v19, v20);
      llvm::MD5::final((int *)v52, (int *)&v51);
      v52[0] = v51;
      int v21 = *((_DWORD *)this + 74);
      *((_DWORD *)this + 74) = v21 + 1;
      *((_DWORD *)sub_1CD54145C((uint64_t)this + 272, v52) + 2) = v21;
      long long v22 = (void *)v13[1];
      if (v22)
      {
        do
        {
          long long v23 = v22;
          long long v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          long long v23 = (void *)v13[2];
          BOOL v36 = *v23 == (void)v13;
          long long v13 = v23;
        }
        while (!v36);
      }
      long long v13 = v23;
    }
    while (v23 != v14);
    uint64_t v7 = (void *)*((void *)this + 12);
  }
  uint64_t v24 = *((unsigned int *)this + 74);
  *((_DWORD *)this + 84) = v24;
  long long v25 = (void *)v7[7];
  unsigned int v26 = v7 + 8;
  if (v25 != v7 + 8)
  {
    do
    {
      char v27 = *((unsigned char *)v25 + 63);
      int v28 = v27;
      if (v27 >= 0) {
        int v29 = (unsigned __int8 *)(v25 + 5);
      }
      else {
        int v29 = (unsigned __int8 *)v25[5];
      }
      size_t v30 = v27 & 0x7F;
      if (v28 >= 0) {
        size_t v31 = v30;
      }
      else {
        size_t v31 = v25[6];
      }
      int v32 = *((_DWORD *)this + 84);
      *((_DWORD *)this + 84) = v32 + 1;
      *(_DWORD *)(*sub_1CC44CD14((llvm::SlotTracker *)((char *)this + 304), v29, v31) + sub_1CD521E44((uint64_t)this + 8) = v32;
      unsigned int v33 = (void *)v25[1];
      if (v33)
      {
        do
        {
          unint64_t v34 = v33;
          unsigned int v33 = (void *)*v33;
        }
        while (v33);
      }
      else
      {
        do
        {
          unint64_t v34 = (void *)v25[2];
          BOOL v36 = *v34 == (void)v25;
          long long v25 = v34;
        }
        while (!v36);
      }
      long long v25 = v34;
    }
    while (v34 != v26);
    uint64_t v24 = *((unsigned int *)this + 84);
  }
  sub_1CD40B1BC(v50[0]);
  return v24;
}

uint64_t llvm::SlotTracker::getGlobalSlot(llvm::SlotTracker *this, const llvm::GlobalValue *a2)
{
  sub_1CC4EF170(this);
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  int v4 = sub_1CB883B0C((uint64_t)this + 104, &v6, &v7);
  uint64_t result = 0xFFFFFFFFLL;
  if (v4)
  {
    if (v7 != *((void *)this + 13) + 16 * *((unsigned int *)this + 30)) {
      return *(unsigned int *)(v7 + 8);
    }
  }
  return result;
}

uint64_t llvm::SlotTracker::getModulePathSlot(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  if (*(void *)(a1 + 96))
  {
    llvm::SlotTracker::processIndex((llvm::SlotTracker *)a1);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t result = llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 232), a2, a3);
  if (result != -1)
  {
    if ((int)result == (unint64_t)*(unsigned int *)(a1 + 240)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *(unsigned int *)(*(void *)(*(void *)(a1 + 232) + 8 * (int)result) + 8);
    }
  }
  return result;
}

uint64_t llvm::SlotTracker::getGUIDSlot(llvm::SlotTracker *this, uint64_t a2)
{
  uint64_t v5 = a2;
  if (*((void *)this + 12))
  {
    llvm::SlotTracker::processIndex(this);
    *((void *)this + 12) = 0;
  }
  uint64_t v3 = sub_1CD5A11BC((uint64_t *)this + 34, &v5);
  if ((uint64_t *)(*((void *)this + 34) + 16 * *((unsigned int *)this + 72)) == v3) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *((unsigned int *)v3 + 2);
  }
}

uint64_t *sub_1CD5A11BC(uint64_t *a1, void *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (37 * *a2) & (v3 - 1);
    uint64_t result = (uint64_t *)(v2 + 16 * v4);
    uint64_t v6 = *result;
    if (*a2 == *result) {
      return result;
    }
    int v7 = 1;
    while (v6 != -1)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (*a2 == v6) {
        return (uint64_t *)(v2 + 16 * v4);
      }
    }
  }
  return (uint64_t *)(v2 + 16 * v3);
}

uint64_t llvm::SlotTracker::getTypeIdSlot(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  if (*(void *)(a1 + 96))
  {
    llvm::SlotTracker::processIndex((llvm::SlotTracker *)a1);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t result = llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 304), a2, a3);
  if (result != -1)
  {
    if ((int)result == (unint64_t)*(unsigned int *)(a1 + 312)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *(unsigned int *)(*(void *)(*(void *)(a1 + 304) + 8 * (int)result) + 8);
    }
  }
  return result;
}

void *llvm::Function::print(const llvm::Module **this, llvm::raw_ostream *a2, llvm::AssemblyAnnotationWriter *a3, char a4, char a5)
{
  v25[43] = *MEMORY[0x1E4F143B8];
  llvm::SlotTracker::SlotTracker((llvm::SlotTracker *)v25, this[5], 0);
  int v12 = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  int v18 = 1;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = &unk_1F2644C68;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int v21 = &v23;
  long long v22 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v11, (uint64_t)a2);
  sub_1CC4EF34C((uint64_t)v24, (uint64_t)&v11, (uint64_t)v25, (uint64_t)this[5], (uint64_t)a3, a5, a4);
  sub_1CC4EF5C8(v24, (llvm::LLVMContext ***)this);
  sub_1CC4F09EC(v24);
  sub_1CBF2EF74((llvm::raw_ostream *)&v11);
  return sub_1CC4FDAD8(v25);
}

void *llvm::NamedMDNode::print(const llvm::Module **this, llvm::raw_ostream *a2, char a3)
{
  v21[43] = *MEMORY[0x1E4F143B8];
  llvm::SlotTracker::SlotTracker((llvm::SlotTracker *)v21, this[5], 0);
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  int v14 = 1;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  int v7 = &unk_1F2644C68;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v19;
  long long v18 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v7, (uint64_t)a2);
  sub_1CC4EF34C((uint64_t)v20, (uint64_t)&v7, (uint64_t)v21, (uint64_t)this[5], 0, a3, 0);
  sub_1CC4F28E8((uint64_t)v20, (uint64_t)this);
  sub_1CC4F09EC(v20);
  sub_1CBF2EF74((llvm::raw_ostream *)&v7);
  return sub_1CC4FDAD8(v21);
}

llvm::raw_ostream *llvm::NamedMDNode::print(const llvm::Module **this, llvm::raw_ostream *a2, llvm::ModuleSlotTracker *a3, char a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  LOBYTE(v23[0]) = 0;
  char v24 = 0;
  Machine = (void *)llvm::ModuleSlotTracker::getMachine(a3);
  if (!Machine)
  {
    Machine = v23;
    llvm::SlotTracker::SlotTracker((llvm::SlotTracker *)v23, this[5], 0);
    char v24 = 1;
  }
  int v10 = 0;
  char v14 = 0;
  uint64_t v15 = 0;
  int v16 = 1;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  uint64_t v9 = &unk_1F2644C68;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = &v21;
  long long v20 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v9, (uint64_t)a2);
  sub_1CC4EF34C((uint64_t)v22, (uint64_t)&v9, (uint64_t)Machine, (uint64_t)this[5], 0, a4, 0);
  sub_1CC4F28E8((uint64_t)v22, (uint64_t)this);
  sub_1CC4F09EC(v22);
  uint64_t result = sub_1CBF2EF74((llvm::raw_ostream *)&v9);
  if (v24) {
    return (llvm::raw_ostream *)sub_1CC4FDAD8(v23);
  }
  return result;
}

llvm::raw_ostream *llvm::Comdat::print(size_t **this, llvm::raw_ostream *a2)
{
  uint64_t v4 = (llvm::raw_ostream *)(*this + 9);
  size_t v5 = **this;
  uint64_t v6 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v6 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 36);
  }
  else
  {
    *((void *)a2 + 4) = v6 + 1;
    *uint64_t v6 = 36;
  }
  llvm::printLLVMNameWithoutPrefix(a2, v4, v5);
  uint64_t result = sub_1CB8E509C(a2, " = comdat ");
  uint64_t v8 = *((int *)this + 2);
  if (v8 <= 4) {
    uint64_t result = sub_1CB8E509C(a2, off_1E68306D0[v8]);
  }
  uint64_t v9 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v9 >= *((void *)a2 + 3))
  {
    return llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((void *)a2 + 4) = v9 + 1;
    *uint64_t v9 = 10;
  }
  return result;
}

void llvm::Value::print(llvm::Value *this, llvm::raw_ostream *a2, char a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *((unsigned __int8 *)this + 16);
  if (this && v6 >= 0x1C)
  {
    if (v6 == 84
      && (uint64_t v7 = *((void *)this - 4)) != 0
      && !*(unsigned char *)(v7 + 16)
      && *(void *)(v7 + 24) == *((void *)this + 9)
      && (*(unsigned char *)(v7 + 33) & 0x20) != 0
      && ((int v11 = *((_DWORD *)this + 5), (v11 & 0x40000000) != 0)
        ? (uint64_t *)(v13 = (uint64_t *)*((void *)this - 1), uint64_t v12 = v11 & 0x7FFFFFF)
        : (uint64_t v12 = v11 & 0x7FFFFFF, v13 = (uint64_t *)((char *)this - 32 * v12)),
          v12))
    {
      uint64_t v14 = 32 * v12;
      while (1)
      {
        uint64_t v15 = *v13;
        if (*v13)
        {
          if (*(unsigned char *)(v15 + 16) == 23 && (sub_1CB8F0DA8(*(unsigned char **)(v15 + 24)) & 1) != 0) {
            break;
          }
        }
        v13 += 4;
        v14 -= 32;
        if (!v14) {
          goto LABEL_8;
        }
      }
      char v8 = 1;
    }
    else
    {
LABEL_8:
      char v8 = 0;
    }
  }
  else
  {
    if (*((unsigned char *)this + 16)) {
      BOOL v9 = v6 == 23;
    }
    else {
      BOOL v9 = 1;
    }
    char v8 = v9;
  }
  uint64_t v10 = sub_1CC4F3E90((uint64_t)this);
  v16[0] = &unk_1F26160C0;
  v16[1] = 0;
  BOOL v17 = v10 != 0;
  char v18 = v8;
  uint64_t v23 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = v10;
  llvm::Value::print(this, a2, (llvm::ModuleSlotTracker *)v16, a3);
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v16);
}

llvm::raw_ostream *llvm::Value::print(llvm::Value *this, llvm::raw_ostream *a2, llvm::ModuleSlotTracker *a3, char a4)
{
  v55[43] = *MEMORY[0x1E4F143B8];
  int v22 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  int v28 = 1;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  uint64_t v21 = (int *)&unk_1F2644C68;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  size_t v31 = &v33;
  long long v32 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v21, (uint64_t)a2);
  Machine = v55;
  llvm::SlotTracker::SlotTracker((llvm::SlotTracker *)v55, 0, 0);
  if (llvm::ModuleSlotTracker::getMachine(a3)) {
    Machine = (void *)llvm::ModuleSlotTracker::getMachine(a3);
  }
  unsigned int v9 = *((unsigned __int8 *)this + 16);
  if (this && v9 >= 0x1C)
  {
    uint64_t v10 = *((void *)this + 5);
    if (v10)
    {
      int v11 = *(const llvm::Function **)(v10 + 56);
      if (v11) {
        llvm::ModuleSlotTracker::incorporateFunction((const llvm::Function **)a3, v11);
      }
    }
    uint64_t v12 = sub_1CC4F3E90((uint64_t)this);
    sub_1CC4EF34C((uint64_t)v34, (uint64_t)&v21, (uint64_t)Machine, v12, 0, a4, 0);
    sub_1CC4F3F64(v34, (uint64_t)this);
    goto LABEL_9;
  }
  if (this && v9 == 22)
  {
    uint64_t v14 = (const llvm::Function *)*((void *)this + 7);
    if (v14) {
      llvm::ModuleSlotTracker::incorporateFunction((const llvm::Function **)a3, v14);
    }
    uint64_t v15 = sub_1CC4F3E90((uint64_t)this);
    sub_1CC4EF34C((uint64_t)v34, (uint64_t)&v21, (uint64_t)Machine, v15, 0, a4, 0);
    sub_1CC4F0C24(v34, (uint64_t ***)this);
    goto LABEL_9;
  }
  if (this && v9 <= 3)
  {
    sub_1CC4EF34C((uint64_t)v34, (uint64_t)&v21, (uint64_t)Machine, *((void *)this + 5), 0, a4, 0);
    int v16 = *((unsigned __int8 *)this + 16);
    if (*((unsigned char *)this + 16))
    {
      if (v16 == 1)
      {
        sub_1CC4F771C(v34, (uint64_t)this);
      }
      else if (v16 == 3)
      {
        sub_1CC4F6DD4(v34, (uint64_t ***)this);
      }
      else
      {
        sub_1CC4F7C4C(v34, (uint64_t)this);
      }
    }
    else
    {
      sub_1CC4EF5C8(v34, (llvm::LLVMContext ***)this);
    }
LABEL_9:
    sub_1CC4F09EC(v34);
    goto LABEL_10;
  }
  if (this && v9 == 23)
  {
    uint64_t v17 = *((void *)this + 3);
    uint64_t v18 = sub_1CC4F3E90((uint64_t)this);
    sub_1CC4F9EAC((uint64_t)a2, v17, a3, v18, 0, 0);
  }
  if (this && v9 <= 0x14)
  {
    memset(v34, 0, sizeof(v34));
    int v35 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    int v38 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    int v41 = 0;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    int v44 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v45 = 0;
    char v48 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    int v51 = 0;
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    uint64_t v52 = 0;
    sub_1CC4F2DB8((llvm::raw_ostream *)v34, *(void *)this, (llvm::raw_ostream *)&v21);
    uint64_t v19 = v25;
    if ((unint64_t)v25 >= v24)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v21, 32);
    }
    else
    {
      ++v25;
      *uint64_t v19 = 32;
    }
    v20[0] = &unk_1F26161D8;
    v20[1] = v34;
    void v20[2] = llvm::ModuleSlotTracker::getMachine(a3);
    v20[3] = 0;
    sub_1CC4F8044(&v21, this, (uint64_t)v20);
    sub_1CC4F3E10(v34);
  }
  else
  {
    sub_1CC4F9C88((unint64_t *)this, (llvm::raw_ostream *)&v21, 1, a3);
  }
LABEL_10:
  sub_1CC4FDAD8(v55);
  return sub_1CBF2EF74((llvm::raw_ostream *)&v21);
}

void llvm::Metadata::print(llvm::Metadata *this, llvm::raw_ostream *a2, llvm::ModuleSlotTracker *a3, const llvm::Module *a4)
{
}

uint64_t llvm::Value::printAsOperand(llvm::Value *this, llvm::raw_ostream *a2, int a3, llvm::ModuleSlotTracker *a4)
{
  if ((a3 & 1) != 0
    || (uint64_t Machine = llvm::ModuleSlotTracker::getMachine(a4),
        uint64_t result = sub_1CC4F9C08((unsigned __int8 *)this, a2, Machine, *((void *)a4 + 3)),
        (result & 1) == 0))
  {
    return sub_1CC4F9C88((unint64_t *)this, a2, a3, a4);
  }
  return result;
}

uint64_t llvm::Value::printAsOperand(llvm::Value *this, llvm::raw_ostream *a2, int a3, const llvm::Module *a4)
{
  uint64_t v4 = a4;
  v16[43] = *MEMORY[0x1E4F143B8];
  if (!a4) {
    uint64_t v4 = (const llvm::Module *)sub_1CC4F3E90((uint64_t)this);
  }
  if ((a3 & 1) != 0 || (uint64_t result = sub_1CC4F9C08((unsigned __int8 *)this, a2, 0, (uint64_t)v4), (result & 1) == 0))
  {
    llvm::SlotTracker::SlotTracker((llvm::SlotTracker *)v16, v4, *((unsigned char *)this + 16) == 23);
    v9[0] = &unk_1F26160C0;
    v9[1] = 0;
    __int16 v10 = 0;
    int v11 = v4;
    uint64_t v12 = 0;
    uint64_t v13 = v16;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    sub_1CC4F9C88((unint64_t *)this, a2, a3, (llvm::ModuleSlotTracker *)v9);
    llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v9);
    return (uint64_t)sub_1CC4FDAD8(v16);
  }
  return result;
}

void llvm::Metadata::printAsOperand(llvm::Metadata *this, llvm::raw_ostream *a2, llvm::ModuleSlotTracker *a3, const llvm::Module *a4)
{
}

void llvm::Metadata::print(llvm::Metadata *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  v6[0] = &unk_1F26160C0;
  v6[1] = 0;
  BOOL v7 = a3 != 0;
  char v8 = sub_1CB8F0DA8(this);
  uint64_t v13 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v9 = a3;
  sub_1CC4F9EAC((uint64_t)a2, (uint64_t)this, (llvm::ModuleSlotTracker *)v6, (uint64_t)a3, 0, 0);
}

void *llvm::ModuleSummaryIndex::print(llvm::ModuleSummaryIndex *this, llvm::raw_ostream *a2, char a3)
{
  uint64_t v303 = *MEMORY[0x1E4F143B8];
  llvm::SlotTracker::SlotTracker((uint64_t)v297, (uint64_t)this);
  int v249 = 0;
  char v252 = 0;
  uint64_t v253 = 0;
  int v254 = 1;
  unsigned int v6 = (llvm::raw_ostream *)&v248;
  long long v251 = 0u;
  uint64_t v250 = 0;
  v248 = &unk_1F2644C68;
  long long v255 = 0u;
  v256 = &v258;
  long long v257 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v248, (uint64_t)a2);
  v263[0] = (llvm::raw_ostream *)&v248;
  v263[1] = 0;
  v264 = this;
  uint64_t v265 = 0;
  uint64_t v266 = (llvm::SlotTracker *)v297;
  uint64_t v267 = 0;
  long long v268 = 0u;
  long long v270 = 0u;
  int v269 = 0;
  int v271 = 0;
  long long v272 = 0u;
  long long v274 = 0u;
  int v273 = 0;
  int v275 = 0;
  uint64_t v277 = 0;
  char v278 = 0;
  long long v276 = 0u;
  long long v279 = 0u;
  int v280 = 0;
  int v284 = 0;
  long long v283 = 0u;
  long long v282 = 0u;
  long long v281 = 0u;
  uint64_t v286 = 0;
  long long v285 = 0u;
  char v287 = a3;
  char v288 = 0;
  long long v289 = 0u;
  int v290 = 0;
  v291 = v293;
  uint64_t v292 = 0x800000000;
  v293[16] = &v294;
  v293[17] = 0x800000000;
  long long v295 = 0u;
  int v296 = 0;
  if (v298)
  {
    int v7 = llvm::SlotTracker::processIndex((llvm::SlotTracker *)v297);
    uint64_t v298 = 0;
    unsigned int v6 = v263[0];
  }
  else
  {
    int v7 = 0;
  }
  int v243 = v7;
  sub_1CB8E509C(v6, "\n");
  uint64_t v260 = 0;
  uint64_t v261 = 0;
  uint64_t v262 = 0;
  sub_1CD5A4460(&v260, *((unsigned int *)v264 + 9));
  uint64_t v8 = *((unsigned int *)v264 + 8);
  if (v8)
  {
    for (uint64_t i = (uint64_t *)*((void *)v264 + 3); ; ++i)
    {
      BOOL v10 = !*i || *i == -8;
      if (!v10) {
        break;
      }
    }
  }
  else
  {
    uint64_t i = (uint64_t *)*((void *)v264 + 3);
  }
  uint64_t v11 = *((void *)v264 + 3) + 8 * v8;
  if (i != (uint64_t *)v11)
  {
    uint64_t v12 = *i;
    do
    {
      if (*(void *)(v12 + 8) == 0xFFFFFFFFLL)
      {
        strcpy((char *)&v302, "[Regular LTO]");
        HIWORD(v302.__r_.__value_.__r.__words[1]) = 0;
        LODWORD(v302.__r_.__value_.__r.__words[2]) = v259[0];
        *(_DWORD *)((char *)&v302.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v259 + 3);
        char v13 = 13;
        std::string::size_type v14 = 0x72616C756765525BLL;
      }
      else
      {
        std::string::__init(&v302, (const std::string::value_type *)(v12 + 40), *(void *)v12);
        std::string::size_type v14 = v302.__r_.__value_.__r.__words[0];
        char v13 = HIBYTE(v302.__r_.__value_.__r.__words[2]);
      }
      v301[0] = v302.__r_.__value_.__l.__size_;
      *(void *)((char *)v301 + 7) = *(std::string::size_type *)((char *)&v302.__r_.__value_.__r.__words[1] + 7);
      memset(&v302, 0, sizeof(v302));
      int v300 = *(_DWORD *)(v12 + 32);
      long long v299 = *(_OWORD *)(v12 + 16);
      int ModulePathSlot = llvm::SlotTracker::getModulePathSlot((uint64_t)v266, (unsigned __int8 *)(v12 + 40), *(void *)v12);
      uint64_t v16 = v260;
      uint64_t v17 = v260 + 48 * ModulePathSlot;
      if (*(char *)(v17 + 23) < 0) {
        operator delete(*(void **)v17);
      }
      uint64_t v18 = v301[0];
      *(void *)uint64_t v17 = v14;
      *(void *)(v17 + sub_1CD521E44((uint64_t)this + 8) = v18;
      *(void *)(v17 + 15) = *(void *)((char *)v301 + 7);
      *(unsigned char *)(v17 + 23) = v13;
      uint64_t v19 = v16 + 48 * ModulePathSlot;
      *(_OWORD *)(v19 + 24) = v299;
      *(_DWORD *)(v19 + 40) = v300;
      if (SHIBYTE(v302.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v302.__r_.__value_.__l.__data_);
      }
      do
      {
        uint64_t v20 = i[1];
        ++i;
        uint64_t v12 = v20;
        if (v20) {
          BOOL v21 = v12 == -8;
        }
        else {
          BOOL v21 = 1;
        }
      }
      while (v21);
    }
    while (i != (uint64_t *)v11);
  }
  uint64_t v22 = v260;
  uint64_t v23 = v261;
  if (v260 != v261)
  {
    unsigned int v24 = 0;
    do
    {
      uint64_t v25 = sub_1CB8E509C(v263[0], "^");
      sub_1CD098D14(v25, v24, 0, 0, 0);
      sub_1CB8E509C(v25, " = module: (");
      sub_1CB8E509C(v263[0], "path: \"");
      char v26 = *(unsigned char *)(v22 + 23);
      BOOL v27 = v26 < 0;
      if (v26 >= 0) {
        int v28 = (llvm::raw_ostream *)v22;
      }
      else {
        int v28 = *(llvm::raw_ostream **)v22;
      }
      uint64_t v29 = v26 & 0x7F;
      if (v27) {
        uint64_t v30 = *(void *)(v22 + 8);
      }
      else {
        uint64_t v30 = v29;
      }
      llvm::printEscapedString(v28, v30, v263[0]);
      sub_1CB8E509C(v263[0], "\", hash: (");
      char v31 = 0;
      for (uint64_t j = 24; j != 44; j += 4)
      {
        unint64_t v33 = *(unsigned int *)(v22 + j);
        unint64_t v34 = v263[0];
        if (v31) {
          unint64_t v34 = sub_1CB8E509C(v263[0], ", ");
        }
        sub_1CD098D14(v34, v33, 0, 0, 0);
        char v31 = 1;
      }
      ++v24;
      sub_1CB8E509C(v263[0], "))\n");
      v22 += 48;
    }
    while (v22 != v23);
  }
  int v35 = v264;
  uint64_t v36 = (char *)v264 + 8;
  uint64_t v37 = *(char **)v264;
  if (*(llvm::ModuleSummaryIndex **)v264 != (llvm::ModuleSummaryIndex *)((char *)v264 + 8))
  {
    do
    {
      int v38 = (std::string::size_type *)*((void *)v37 + 7);
      uint64_t v39 = (std::string::size_type *)*((void *)v37 + 8);
      if (v38 != v39)
      {
        uint64_t v40 = *((void *)v37 + 4);
        do
        {
          std::string::size_type v41 = *v38++;
          v302.__r_.__value_.__r.__words[0] = v41;
          sub_1CD45F378((uint64_t)&v295, (uint64_t *)&v302)[1] = v40;
        }
        while (v38 != v39);
      }
      uint64_t v42 = (char *)*((void *)v37 + 1);
      if (v42)
      {
        do
        {
          uint64_t v43 = v42;
          uint64_t v42 = *(char **)v42;
        }
        while (v42);
      }
      else
      {
        do
        {
          uint64_t v43 = (char *)*((void *)v37 + 2);
          BOOL v10 = *(void *)v43 == (void)v37;
          uint64_t v37 = v43;
        }
        while (!v10);
      }
      uint64_t v37 = v43;
    }
    while (v43 != v36);
    int v35 = v264;
    uint64_t v37 = *(char **)v264;
  }
  uint64_t v245 = (char *)v35 + 8;
  if (v37 != (char *)v35 + 8)
  {
    while (1)
    {
      uint64_t v44 = *((unsigned __int8 *)v264 + 133);
      unsigned int GUIDSlot = llvm::SlotTracker::getGUIDSlot(v266, *((void *)v37 + 4));
      uint64_t v46 = sub_1CB8E509C(v263[0], "^");
      sub_1CD098D14(v46, GUIDSlot, 0, 0, 0);
      sub_1CB8E509C(v46, " = gv: (");
      unint64_t v47 = (unint64_t)(v37 + 32) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v48 = (unint64_t)(v37 + 32) & 1 | v44;
      if (v48)
      {
        llvm::Value::getName(*(llvm::Value **)(v47 + 8));
        if (v49)
        {
          uint64_t v50 = sub_1CB8E509C(v263[0], "name: \"");
          Name = llvm::Value::getName(*(llvm::Value **)(v47 + 8));
          size_t v53 = v52;
LABEL_55:
          uint64_t v54 = (void *)*((void *)v50 + 4);
          if (v53 <= *((void *)v50 + 3) - (void)v54)
          {
            if (v53)
            {
              memcpy(v54, Name, v53);
              *((void *)v50 + 4) += v53;
            }
          }
          else
          {
            llvm::raw_ostream::write(v50, Name, v53);
          }
          sub_1CB8E509C(v50, "\"");
          goto LABEL_58;
        }
      }
      else if (*(void *)(v47 + 16))
      {
        uint64_t v50 = sub_1CB8E509C(v263[0], "name: \"");
        Name = *(char **)(v47 + 8);
        size_t v53 = *(void *)(v47 + 16);
        goto LABEL_55;
      }
      int v151 = sub_1CB8E509C(v263[0], "guid: ");
      sub_1CD098D14(v151, *(void *)v47, 0, 0, 0);
LABEL_58:
      if (*(void *)(v47 + 32) == *(void *)(v47 + 24)) {
        goto LABEL_169;
      }
      uint64_t v244 = (unint64_t)(v37 + 32) & 1 | v44;
      sub_1CB8E509C(v263[0], ", summaries: (");
      int v55 = *(uint64_t **)(v47 + 24);
      uint64_t v247 = *(uint64_t **)(v47 + 32);
      if (v247 == v55) {
        goto LABEL_168;
      }
      char v56 = 0;
      do
      {
        if (v56) {
          sub_1CB8E509C(v263[0], ", ");
        }
        uint64_t v57 = *v55;
        unint64_t v58 = *(unsigned int *)(*v55 + 12);
        char v59 = sub_1CB8E509C(v263[0], off_1E68306F8[*(int *)(*v55 + 8)]);
        sub_1CB8E509C(v59, ": ");
        int v60 = sub_1CB8E509C(v263[0], "(module: ^");
        int v61 = llvm::SlotTracker::getModulePathSlot((uint64_t)v266, *(unsigned __int8 **)(v57 + 24), *(void *)(v57 + 32));
        unsigned int v62 = llvm::raw_ostream::operator<<(v60, v61);
        sub_1CB8E509C(v62, ", flags: (");
        uint64_t v63 = sub_1CB8E509C(v263[0], "linkage: ");
        sub_1CC4FD6B4((char *)&v302, v58 & 0xF);
        if ((v302.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v64 = &v302;
        }
        else {
          uint64_t v64 = (std::string *)v302.__r_.__value_.__r.__words[0];
        }
        if ((v302.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t size = *((unsigned char *)&v302.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t size = v302.__r_.__value_.__l.__size_;
        }
        llvm::raw_ostream::write(v63, (const char *)v64, size);
        if (SHIBYTE(v302.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v302.__r_.__value_.__l.__data_);
        }
        uint64_t v66 = sub_1CB8E509C(v263[0], ", visibility: ");
        sub_1CB8E509C(v66, off_1E6830710[(v58 >> 4) & 3]);
        int v67 = sub_1CB8E509C(v263[0], ", notEligibleToImport: ");
        sub_1CD098D14(v67, (v58 >> 6) & 1, 0, 0, 0);
        int v68 = sub_1CB8E509C(v263[0], ", live: ");
        sub_1CD098D14(v68, (v58 >> 7) & 1, 0, 0, 0);
        uint64_t v69 = sub_1CB8E509C(v263[0], ", dsoLocal: ");
        sub_1CD098D14(v69, (v58 >> 8) & 1, 0, 0, 0);
        uint64_t v70 = sub_1CB8E509C(v263[0], ", canAutoHide: ");
        sub_1CD098D14(v70, (v58 >> 9) & 1, 0, 0, 0);
        sub_1CB8E509C(v263[0], ")");
        int v71 = *(_DWORD *)(v57 + 8);
        if (v71 == 1)
        {
          uint64_t v93 = sub_1CB8E509C(v263[0], ", insts: ");
          sub_1CD098D14(v93, *(unsigned int *)(v57 + 64), 0, 0, 0);
          if ((*(_WORD *)(v57 + 68) & 0x3FF) != 0)
          {
            int v239 = sub_1CB8E509C(v263[0], ", ");
            LODWORD(v299) = *(_DWORD *)(v57 + 68);
            sub_1CD5A46C0((uint64_t)&v302, &v299);
            v240 = (v302.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? &v302
                 : (std::string *)v302.__r_.__value_.__r.__words[0];
            size_t v241 = (v302.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? *((unsigned char *)&v302.__r_.__value_.__s + 23) & 0x7F
                 : v302.__r_.__value_.__l.__size_;
            llvm::raw_ostream::write(v239, (const char *)v240, v241);
            if (SHIBYTE(v302.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v302.__r_.__value_.__l.__data_);
            }
          }
          if (*(void *)(v57 + 88) != *(void *)(v57 + 80))
          {
            sub_1CB8E509C(v263[0], ", calls: (");
            uint64_t v95 = *(void *)(v57 + 80);
            uint64_t v94 = *(void *)(v57 + 88);
            uint64_t v96 = v94 - v95;
            if (v94 != v95)
            {
              char v97 = 0;
              uint64_t v98 = 16 * (v96 >> 4);
              int v99 = (_DWORD *)(v95 + 8);
              do
              {
                if (v97) {
                  sub_1CB8E509C(v263[0], ", ");
                }
                unsigned int v100 = sub_1CB8E509C(v263[0], "(callee: ^");
                int v101 = llvm::SlotTracker::getGUIDSlot(v266, *(void *)(*((void *)v99 - 1) & 0xFFFFFFFFFFFFFFF8));
                llvm::raw_ostream::operator<<(v100, v101);
                if ((*v99 & 7) != 0)
                {
                  uint64_t v102 = sub_1CB8E509C(v263[0], ", hotness: ");
                  sub_1CB8E509C(v102, off_1E6830728[*v99 & 7]);
                }
                else if (*v99 >= 8u)
                {
                  uint64_t v103 = sub_1CB8E509C(v263[0], ", relbf: ");
                  sub_1CD098D14(v103, (unint64_t)*v99 >> 3, 0, 0, 0);
                }
                sub_1CB8E509C(v263[0], ")");
                v99 += 4;
                char v97 = 1;
                v98 -= 16;
              }
              while (v98);
            }
            sub_1CB8E509C(v263[0], ")");
          }
          uint64_t v121 = *(void *)(v57 + 104);
          if (v121)
          {
            sub_1CB8E509C(v263[0], ", typeIdInfo: (");
            if (*(void *)v121 == *(void *)(v121 + 8))
            {
              v138 = (unint64_t **)(v121 + 24);
              if (*(void *)(v121 + 24) != *(void *)(v121 + 32))
              {
LABEL_149:
                sub_1CC504B30((uint64_t *)v263, v138, "typeTestAssumeVCalls");
                goto LABEL_150;
              }
              unsigned int v139 = (unint64_t **)(v121 + 48);
              if (*(void *)(v121 + 48) != *(void *)(v121 + 56))
              {
LABEL_152:
                sub_1CC504B30((uint64_t *)v263, v139, "typeCheckedLoadVCalls");
                goto LABEL_153;
              }
              uint64_t v140 = (void *)(v121 + 72);
              if (*(void *)(v121 + 72) != *(void *)(v121 + 80))
              {
LABEL_155:
                sub_1CC504CC4((uint64_t *)v263, v140, "typeTestAssumeConstVCalls");
                goto LABEL_156;
              }
              uint64_t v233 = *(void *)(v121 + 96);
              uint64_t v234 = *(void *)(v121 + 104);
              unsigned int v143 = (void *)(v121 + 96);
              if (v233 != v234) {
LABEL_158:
              }
                sub_1CC504CC4((uint64_t *)v263, v143, "typeCheckedLoadConstVCalls");
            }
            else
            {
              sub_1CB8E509C(v263[0], "typeTests: (");
              uint64_t v122 = *(unint64_t **)v121;
              unsigned int v242 = *(unint64_t **)(v121 + 8);
              if (*(unint64_t **)v121 != v242)
              {
                char v123 = 0;
                int v124 = 1;
                do
                {
                  uint64_t v125 = sub_1CD4F29A8((uint64_t)v264 + 56, v122);
                  if (v125 == v126)
                  {
                    if (v123) {
                      sub_1CB8E509C(v263[0], ", ");
                    }
                    sub_1CD098D14(v263[0], *v122, 0, 0, 0);
                  }
                  else
                  {
                    uint64_t v127 = v125;
                    uint64_t v128 = v126;
                    do
                    {
                      if (!v124) {
                        sub_1CB8E509C(v263[0], ", ");
                      }
                      char v129 = *((unsigned char *)v127 + 63);
                      int v130 = v129;
                      if (v129 >= 0) {
                        uint64_t v131 = (unsigned __int8 *)(v127 + 5);
                      }
                      else {
                        uint64_t v131 = (unsigned __int8 *)v127[5];
                      }
                      size_t v132 = v129 & 0x7F;
                      if (v130 >= 0) {
                        size_t v133 = v132;
                      }
                      else {
                        size_t v133 = v127[6];
                      }
                      int TypeIdSlot = llvm::SlotTracker::getTypeIdSlot((uint64_t)v266, v131, v133);
                      uint64_t v135 = sub_1CB8E509C(v263[0], "^");
                      llvm::raw_ostream::operator<<(v135, TypeIdSlot);
                      uint64_t v136 = (void *)v127[1];
                      if (v136)
                      {
                        do
                        {
                          unsigned int v137 = v136;
                          uint64_t v136 = (void *)*v136;
                        }
                        while (v136);
                      }
                      else
                      {
                        do
                        {
                          unsigned int v137 = (void *)v127[2];
                          BOOL v10 = *v137 == (void)v127;
                          uint64_t v127 = v137;
                        }
                        while (!v10);
                      }
                      int v124 = 0;
                      uint64_t v127 = v137;
                    }
                    while (v137 != v128);
                  }
                  int v124 = 0;
                  ++v122;
                  char v123 = 1;
                }
                while (v122 != v242);
              }
              sub_1CB8E509C(v263[0], ")");
              v138 = (unint64_t **)(v121 + 24);
              if (*(void *)(v121 + 24) != *(void *)(v121 + 32))
              {
                sub_1CB8E509C(v263[0], ", ");
                goto LABEL_149;
              }
LABEL_150:
              unsigned int v139 = (unint64_t **)(v121 + 48);
              if (*(void *)(v121 + 48) != *(void *)(v121 + 56))
              {
                sub_1CB8E509C(v263[0], ", ");
                goto LABEL_152;
              }
LABEL_153:
              uint64_t v140 = (void *)(v121 + 72);
              if (*(void *)(v121 + 72) != *(void *)(v121 + 80))
              {
                sub_1CB8E509C(v263[0], ", ");
                goto LABEL_155;
              }
LABEL_156:
              uint64_t v141 = *(void *)(v121 + 96);
              uint64_t v142 = *(void *)(v121 + 104);
              unsigned int v143 = (void *)(v121 + 96);
              if (v141 != v142)
              {
                sub_1CB8E509C(v263[0], ", ");
                goto LABEL_158;
              }
            }
            sub_1CB8E509C(v263[0], ")");
          }
          v144 = *(void **)(v57 + 112);
          if (!v144 || v144[1] == *v144) {
            goto LABEL_76;
          }
          sub_1CB8E509C(v263[0], ", params: (");
          uint64_t v145 = *(uint64_t **)(v57 + 112);
          if (v145)
          {
            uint64_t v91 = *v145;
            uint64_t v146 = v145[1];
            if (v146 != *v145)
            {
              char v92 = 0;
              do
              {
                if (v92) {
                  sub_1CB8E509C(v263[0], ", ");
                }
                uint64_t v84 = sub_1CB8E509C(v263[0], "(param: ");
                sub_1CD098D14(v84, *(void *)v91, 0, 0, 0);
                sub_1CB8E509C(v263[0], ", offset: ");
                sub_1CC50491C(v263[0], (_DWORD *)(v91 + 8));
                if (*(void *)(v91 + 40) != *(void *)(v91 + 48))
                {
                  sub_1CB8E509C(v263[0], ", calls: (");
                  uint64_t v85 = *(void *)(v91 + 40);
                  uint64_t v86 = *(void *)(v91 + 48);
                  if (v85 != v86)
                  {
                    char v87 = 0;
                    do
                    {
                      if (v87) {
                        sub_1CB8E509C(v263[0], ", ");
                      }
                      int v88 = sub_1CB8E509C(v263[0], "(callee: ^");
                      int v89 = llvm::SlotTracker::getGUIDSlot(v266, *(void *)(*(void *)(v85 + 8) & 0xFFFFFFFFFFFFFFF8));
                      llvm::raw_ostream::operator<<(v88, v89);
                      uint64_t v90 = sub_1CB8E509C(v263[0], ", param: ");
                      sub_1CD098D14(v90, *(void *)v85, 0, 0, 0);
                      sub_1CB8E509C(v263[0], ", offset: ");
                      sub_1CC50491C(v263[0], (_DWORD *)(v85 + 16));
                      sub_1CB8E509C(v263[0], ")");
                      v85 += 48;
                      char v87 = 1;
                    }
                    while (v85 != v86);
                  }
                  sub_1CB8E509C(v263[0], ")");
                }
                sub_1CB8E509C(v263[0], ")");
                v91 += 64;
                char v92 = 1;
              }
              while (v91 != v146);
            }
          }
          uint64_t v72 = v263[0];
          uint64_t v73 = ")";
          goto LABEL_75;
        }
        if (v71)
        {
          uint64_t v104 = *(void *)(v57 + 64);
          if (v104)
          {
            uint64_t v105 = *(void **)v104;
            uint64_t v106 = (uint64_t)(*(void *)(v104 + 8) - *(void *)v104) >> 4;
          }
          else
          {
            uint64_t v105 = 0;
            uint64_t v106 = 0;
          }
          uint64_t v107 = sub_1CB8E509C(v263[0], ", varFlags: (readonly: ");
          sub_1CD098D14(v107, *(unsigned char *)(v57 + 72) & 1, 0, 0, 0);
          uint64_t v108 = sub_1CB8E509C(v107, ", ");
          uint64_t v109 = sub_1CB8E509C(v108, "writeonly: ");
          sub_1CD098D14(v109, ((unint64_t)*(unsigned __int8 *)(v57 + 72) >> 1) & 1, 0, 0, 0);
          v110 = sub_1CB8E509C(v109, ", ");
          BOOL v111 = sub_1CB8E509C(v110, "constant: ");
          sub_1CD098D14(v111, ((unint64_t)*(unsigned __int8 *)(v57 + 72) >> 2) & 1, 0, 0, 0);
          char v112 = v263[0];
          if (v106)
          {
            uint64_t v113 = sub_1CB8E509C(v263[0], ", ");
            unsigned int v114 = sub_1CB8E509C(v113, "vcall_visibility: ");
            sub_1CD098D14(v114, ((unint64_t)*(unsigned __int8 *)(v57 + 72) >> 3) & 3, 0, 0, 0);
            sub_1CB8E509C(v263[0], ")");
            sub_1CB8E509C(v263[0], ", vTableFuncs: (");
            char v115 = 0;
            uint64_t v116 = &v105[2 * v106];
            do
            {
              if (v115) {
                sub_1CB8E509C(v263[0], ", ");
              }
              unsigned int v117 = sub_1CB8E509C(v263[0], "(virtFunc: ^");
              int v118 = llvm::SlotTracker::getGUIDSlot(v266, *(void *)(*v105 & 0xFFFFFFFFFFFFFFF8));
              int v119 = llvm::raw_ostream::operator<<(v117, v118);
              uint64_t v120 = sub_1CB8E509C(v119, ", offset: ");
              sub_1CD098D14(v120, v105[1], 0, 0, 0);
              sub_1CB8E509C(v263[0], ")");
              v105 += 2;
              char v115 = 1;
            }
            while (v105 != v116);
            char v112 = v263[0];
          }
          sub_1CB8E509C(v112, ")");
          goto LABEL_76;
        }
        sub_1CB8E509C(v263[0], ", aliasee: ");
        uint64_t v72 = v263[0];
        if (*(void *)(v57 + 72))
        {
          v235 = sub_1CB8E509C(v263[0], "^");
          uint64_t v236 = v266;
          v302.__r_.__value_.__r.__words[0] = *(void *)(v57 + 72);
          unsigned int v237 = sub_1CD45F378((uint64_t)&v295, (uint64_t *)&v302);
          int v238 = llvm::SlotTracker::getGUIDSlot(v236, v237[1]);
          llvm::raw_ostream::operator<<(v235, v238);
          goto LABEL_76;
        }
        uint64_t v73 = "null";
LABEL_75:
        sub_1CB8E509C(v72, v73);
LABEL_76:
        uint64_t v75 = *(char **)(v57 + 40);
        uint64_t v74 = *(char **)(v57 + 48);
        int64_t v76 = v74 - v75;
        if (v74 == v75) {
          goto LABEL_87;
        }
        sub_1CB8E509C(v263[0], ", refs: (");
        char v77 = 0;
        unint64_t v78 = v76 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          if (v77) {
            sub_1CB8E509C(v263[0], ", ");
          }
          if ((*(void *)v75 & 2) != 0)
          {
            uint64_t v79 = v263[0];
            uint64_t v80 = "readonly ";
          }
          else
          {
            if ((*(void *)v75 & 4) == 0) {
              goto LABEL_85;
            }
            uint64_t v79 = v263[0];
            uint64_t v80 = "writeonly ";
          }
          sub_1CB8E509C(v79, v80);
LABEL_85:
          uint64_t v81 = sub_1CB8E509C(v263[0], "^");
          uint64_t v82 = *(void *)v75;
          v75 += 8;
          int v83 = llvm::SlotTracker::getGUIDSlot(v266, *(void *)(v82 & 0xFFFFFFFFFFFFFFF8));
          llvm::raw_ostream::operator<<(v81, v83);
          char v77 = 1;
          v78 -= 8;
        }
        while (v78);
        sub_1CB8E509C(v263[0], ")");
LABEL_87:
        sub_1CB8E509C(v263[0], ")");
        ++v55;
        char v56 = 1;
      }
      while (v55 != v247);
LABEL_168:
      sub_1CB8E509C(v263[0], ")");
      uint64_t v48 = v244;
LABEL_169:
      sub_1CB8E509C(v263[0], ")");
      if (v48) {
        llvm::Value::getName(*(llvm::Value **)(v47 + 8));
      }
      else {
        uint64_t v147 = *(void *)(v47 + 16);
      }
      if (v147)
      {
        v148 = sub_1CB8E509C(v263[0], " ; guid = ");
        sub_1CD098D14(v148, *(void *)v47, 0, 0, 0);
      }
      sub_1CB8E509C(v263[0], "\n");
      int v149 = (char *)*((void *)v37 + 1);
      if (v149)
      {
        do
        {
          int v150 = v149;
          int v149 = *(char **)v149;
        }
        while (v149);
      }
      else
      {
        do
        {
          int v150 = (char *)*((void *)v37 + 2);
          BOOL v10 = *(void *)v150 == (void)v37;
          uint64_t v37 = v150;
        }
        while (!v10);
      }
      uint64_t v37 = v150;
      if (v150 == v245)
      {
        int v35 = v264;
        break;
      }
    }
  }
  uint64_t v152 = (void *)*((void *)v35 + 7);
  uint64_t v246 = (void *)((char *)v35 + 64);
  if (v152 != (void *)((char *)v35 + 64))
  {
    do
    {
      v153 = sub_1CB8E509C(v263[0], "^");
      char v154 = *((unsigned char *)v152 + 63);
      int v155 = v154;
      if (v154 >= 0) {
        uint64_t v156 = (unsigned __int8 *)(v152 + 5);
      }
      else {
        uint64_t v156 = (unsigned __int8 *)v152[5];
      }
      size_t v157 = v154 & 0x7F;
      if (v155 >= 0) {
        size_t v158 = v157;
      }
      else {
        size_t v158 = v152[6];
      }
      int v159 = llvm::SlotTracker::getTypeIdSlot((uint64_t)v266, v156, v158);
      unsigned int v160 = llvm::raw_ostream::operator<<(v153, v159);
      unsigned int v161 = sub_1CB8E509C(v160, " = typeid: (name: \"");
      char v162 = *((unsigned char *)v152 + 63);
      BOOL v163 = v162 < 0;
      if (v162 >= 0) {
        v164 = (const char *)(v152 + 5);
      }
      else {
        v164 = (const char *)v152[5];
      }
      size_t v165 = v162 & 0x7F;
      if (v163) {
        size_t v166 = v152[6];
      }
      else {
        size_t v166 = v165;
      }
      unint64_t v167 = llvm::raw_ostream::write(v161, v164, v166);
      sub_1CB8E509C(v167, "\"");
      sub_1CB8E509C(v263[0], ", summary: (");
      unint64_t v168 = sub_1CB8E509C(v263[0], "typeTestRes: (kind: ");
      v169 = sub_1CB8E509C(v168, off_1E6830750[*((int *)v152 + 16)]);
      uint64_t v170 = sub_1CB8E509C(v169, ", sizeM1BitWidth: ");
      sub_1CD098D14(v170, *((unsigned int *)v152 + 17), 0, 0, 0);
      if (v152[9])
      {
        unint64_t v171 = sub_1CB8E509C(v263[0], ", alignLog2: ");
        sub_1CD098D14(v171, v152[9], 0, 0, 0);
      }
      if (v152[10])
      {
        unint64_t v172 = sub_1CB8E509C(v263[0], ", sizeM1: ");
        sub_1CD098D14(v172, v152[10], 0, 0, 0);
      }
      if (*((unsigned char *)v152 + 88))
      {
        v173 = sub_1CB8E509C(v263[0], ", bitMask: ");
        sub_1CD098D14(v173, *((unsigned __int8 *)v152 + 88), 0, 0, 0);
      }
      if (v152[12])
      {
        uint64_t v174 = sub_1CB8E509C(v263[0], ", inlineBits: ");
        sub_1CD098D14(v174, v152[12], 0, 0, 0);
      }
      sub_1CB8E509C(v263[0], ")");
      if (v152[15])
      {
        sub_1CB8E509C(v263[0], ", wpdResolutions: (");
        int v175 = (void *)v152[13];
        if (v175 != v152 + 14)
        {
          char v176 = 0;
          do
          {
            if (v176) {
              sub_1CB8E509C(v263[0], ", ");
            }
            int v177 = sub_1CB8E509C(v263[0], "(offset: ");
            sub_1CD098D14(v177, v175[4], 0, 0, 0);
            sub_1CB8E509C(v177, ", ");
            sub_1CB8E509C(v263[0], "wpdRes: (kind: ");
            sub_1CB8E509C(v263[0], off_1E6830780[*((int *)v175 + 10)]);
            if (*((_DWORD *)v175 + 10) == 1)
            {
              v178 = sub_1CB8E509C(v263[0], ", singleImplName: \"");
              char v179 = *((unsigned char *)v175 + 71);
              if (v179 >= 0) {
                int v180 = (const char *)(v175 + 6);
              }
              else {
                int v180 = (const char *)v175[6];
              }
              if (v179 >= 0) {
                size_t v181 = v179 & 0x7F;
              }
              else {
                size_t v181 = v175[7];
              }
              uint64_t v182 = llvm::raw_ostream::write(v178, v180, v181);
              sub_1CB8E509C(v182, "\"");
            }
            if (v175[11])
            {
              sub_1CB8E509C(v263[0], ", resByArg: (");
              v183 = (unint64_t **)v175[9];
              if (v183 != v175 + 10)
              {
                char v184 = 0;
                do
                {
                  if (v184) {
                    sub_1CB8E509C(v263[0], ", ");
                  }
                  sub_1CC5052EC(v263, v183 + 4);
                  sub_1CB8E509C(v263[0], ", byArg: (kind: ");
                  sub_1CB8E509C(v263[0], off_1E6830798[*((int *)v183 + 14)]);
                  if ((*((_DWORD *)v183 + 14) - 1) <= 1)
                  {
                    BOOL v185 = sub_1CB8E509C(v263[0], ", info: ");
                    sub_1CD098D14(v185, (unint64_t)v183[8], 0, 0, 0);
                  }
                  if (v183[9])
                  {
                    unsigned int v186 = sub_1CB8E509C(v263[0], ", byte: ");
                    sub_1CD098D14(v186, *((unsigned int *)v183 + 18), 0, 0, 0);
                    int v187 = sub_1CB8E509C(v186, ", bit: ");
                    sub_1CD098D14(v187, *((unsigned int *)v183 + 19), 0, 0, 0);
                  }
                  sub_1CB8E509C(v263[0], ")");
                  unsigned int v188 = v183[1];
                  if (v188)
                  {
                    do
                    {
                      uint64_t v189 = (unint64_t **)v188;
                      unsigned int v188 = (unint64_t *)*v188;
                    }
                    while (v188);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v189 = (unint64_t **)v183[2];
                      BOOL v10 = *v189 == (unint64_t *)v183;
                      v183 = v189;
                    }
                    while (!v10);
                  }
                  char v184 = 1;
                  v183 = v189;
                }
                while (v189 != v175 + 10);
              }
              sub_1CB8E509C(v263[0], ")");
            }
            sub_1CB8E509C(v263[0], ")");
            sub_1CB8E509C(v263[0], ")");
            int v190 = (void *)v175[1];
            if (v190)
            {
              do
              {
                int v191 = v190;
                int v190 = (void *)*v190;
              }
              while (v190);
            }
            else
            {
              do
              {
                int v191 = (void *)v175[2];
                BOOL v10 = *v191 == (void)v175;
                int v175 = v191;
              }
              while (!v10);
            }
            char v176 = 1;
            int v175 = v191;
          }
          while (v191 != v152 + 14);
        }
        sub_1CB8E509C(v263[0], ")");
      }
      sub_1CB8E509C(v263[0], ")");
      BOOL v192 = sub_1CB8E509C(v263[0], ") ; guid = ");
      sub_1CD098D14(v192, v152[4], 0, 0, 0);
      sub_1CB8E509C(v192, "\n");
      unsigned int v193 = (void *)v152[1];
      if (v193)
      {
        do
        {
          int v194 = v193;
          unsigned int v193 = (void *)*v193;
        }
        while (v193);
      }
      else
      {
        do
        {
          int v194 = (void *)v152[2];
          BOOL v10 = *v194 == (void)v152;
          uint64_t v152 = v194;
        }
        while (!v10);
      }
      uint64_t v152 = v194;
    }
    while (v194 != v246);
    int v35 = v264;
  }
  BOOL v195 = (void *)*((void *)v35 + 10);
  unsigned int v196 = (void *)((char *)v35 + 88);
  if (v195 != (void *)((char *)v35 + 88))
  {
    do
    {
      char v197 = *((unsigned char *)v195 + 55);
      int v198 = v197;
      if (v197 >= 0) {
        unsigned int v199 = v195 + 4;
      }
      else {
        unsigned int v199 = (void *)v195[4];
      }
      uint64_t v200 = v197 & 0x7F;
      if (v198 >= 0) {
        uint64_t v201 = v200;
      }
      else {
        uint64_t v201 = v195[5];
      }
      double v202 = llvm::MD5::MD5((llvm::MD5 *)&v302);
      llvm::MD5::update(v203, v199, v201, v202);
      llvm::MD5::final((int *)&v302, (int *)&v299);
      unint64_t v204 = v299;
      uint64_t v205 = sub_1CB8E509C(v263[0], "^");
      int v206 = llvm::SlotTracker::getGUIDSlot(v266, v204);
      uint64_t v207 = llvm::raw_ostream::operator<<(v205, v206);
      int v208 = sub_1CB8E509C(v207, " = typeidCompatibleVTable: (name: \"");
      char v209 = *((unsigned char *)v195 + 55);
      BOOL v210 = v209 < 0;
      if (v209 >= 0) {
        uint64_t v211 = (const char *)(v195 + 4);
      }
      else {
        uint64_t v211 = (const char *)v195[4];
      }
      size_t v212 = v209 & 0x7F;
      if (v210) {
        size_t v213 = v195[5];
      }
      else {
        size_t v213 = v212;
      }
      v214 = llvm::raw_ostream::write(v208, v211, v213);
      sub_1CB8E509C(v214, "\"");
      sub_1CB8E509C(v263[0], ", summary: (");
      int v215 = (unint64_t *)v195[7];
      uint64_t v216 = (unint64_t *)v195[8];
      if (v215 != v216)
      {
        char v217 = 0;
        do
        {
          if (v217) {
            sub_1CB8E509C(v263[0], ", ");
          }
          uint64_t v218 = sub_1CB8E509C(v263[0], "(offset: ");
          sub_1CD098D14(v218, *v215, 0, 0, 0);
          sub_1CB8E509C(v218, ", ");
          uint64_t v219 = sub_1CB8E509C(v263[0], "^");
          int v220 = llvm::SlotTracker::getGUIDSlot(v266, *(void *)(v215[1] & 0xFFFFFFFFFFFFFFF8));
          llvm::raw_ostream::operator<<(v219, v220);
          sub_1CB8E509C(v263[0], ")");
          v215 += 2;
          char v217 = 1;
        }
        while (v215 != v216);
      }
      sub_1CB8E509C(v263[0], ")");
      uint64_t v221 = sub_1CB8E509C(v263[0], ") ; guid = ");
      sub_1CD098D14(v221, v204, 0, 0, 0);
      sub_1CB8E509C(v221, "\n");
      uint64_t v222 = (void *)v195[1];
      if (v222)
      {
        do
        {
          int v223 = v222;
          uint64_t v222 = (void *)*v222;
        }
        while (v222);
      }
      else
      {
        do
        {
          int v223 = (void *)v195[2];
          BOOL v10 = *v223 == (void)v195;
          BOOL v195 = v223;
        }
        while (!v10);
      }
      BOOL v195 = v223;
    }
    while (v223 != v196);
    int v35 = v264;
  }
  if (llvm::ModuleSummaryIndex::getFlags(v35))
  {
    int v224 = sub_1CB8E509C(v263[0], "^");
    v225 = llvm::raw_ostream::operator<<(v224, v243);
    v226 = sub_1CB8E509C(v225, " = flags: ");
    unint64_t Flags = llvm::ModuleSummaryIndex::getFlags(v264);
    sub_1CD098D14(v226, Flags, 0, 0, 0);
    sub_1CB8E509C(v226, "\n");
    int v228 = v243 + 1;
  }
  else
  {
    int v228 = v243;
  }
  uint64_t v229 = sub_1CB8E509C(v263[0], "^");
  v230 = llvm::raw_ostream::operator<<(v229, v228);
  v231 = sub_1CB8E509C(v230, " = blockcount: ");
  sub_1CD098D14(v231, *((void *)v264 + 37), 0, 0, 0);
  sub_1CB8E509C(v231, "\n");
  v302.__r_.__value_.__r.__words[0] = (std::string::size_type)&v260;
  sub_1CC3CE3C8((void ***)&v302);
  sub_1CC4F09EC(v263);
  sub_1CBF2EF74((llvm::raw_ostream *)&v248);
  return sub_1CC4FDAD8(v297);
}

_OWORD *llvm::ModuleSlotTracker::collectMDNodes(_OWORD *result, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4 = *((void *)result + 1);
  if (v4)
  {
    int v8 = *(_DWORD *)(v4 + 176);
    unsigned int v9 = *(uint64_t **)(v4 + 168);
    uint64_t v10 = *(unsigned int *)(v4 + 184);
    uint64_t v11 = &v9[2 * v10];
    if (v8)
    {
      if (v10)
      {
        uint64_t v12 = 16 * v10;
        char v13 = v9;
        while ((*v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v13 += 2;
          v12 -= 16;
          if (!v12) {
            goto LABEL_7;
          }
        }
      }
      else
      {
        char v13 = v9;
      }
    }
    else
    {
LABEL_7:
      char v13 = &v9[2 * v10];
    }
    std::string::size_type v14 = &v9[2 * v10];
LABEL_9:
    while (v13 != v14)
    {
      unsigned int v15 = *((_DWORD *)v13 + 2);
      if (v15 >= a3 && v15 < a4)
      {
        uint64_t v17 = *v13;
        *(void *)&long long v20 = *((unsigned int *)v13 + 2);
        *((void *)&v20 + 1) = v17;
        uint64_t v18 = *(_OWORD **)(a2 + 8);
        if ((unint64_t)v18 >= *(void *)(a2 + 16))
        {
          uint64_t result = sub_1CC00319C((void **)a2, &v20);
        }
        else
        {
          *uint64_t v18 = v20;
          uint64_t result = v18 + 1;
        }
        *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = result;
      }
      uint64_t v19 = v13 + 2;
      char v13 = v11;
      if (v19 != v11)
      {
        char v13 = v19;
        while ((*v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v13 += 2;
          if (v13 == v11)
          {
            char v13 = v11;
            goto LABEL_9;
          }
        }
      }
    }
  }
  return result;
}

llvm *llvm::Value::dump(llvm::Value *this)
{
  uint64_t v2 = llvm::dbgs(this);
  llvm::Value::print(this, v2, 1);
  uint64_t result = llvm::dbgs(v3);
  size_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  return result;
}

llvm *llvm::Type::dump(llvm::Type *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = (llvm *)llvm::Type::print(this, v2, 0, 0);
  uint64_t result = llvm::dbgs(v3);
  size_t v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  return result;
}

void *llvm::Module::dump(llvm::Module *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::Module::print((const std::string *)this, v2, 0, 0, 1);
}

llvm::raw_ostream *llvm::Comdat::dump(llvm::Comdat *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::Comdat::print((size_t **)this, v2);
}

void *llvm::NamedMDNode::dump(llvm::NamedMDNode *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::NamedMDNode::print((const llvm::Module **)this, v2, 1);
}

void llvm::Metadata::dump(llvm::Metadata *this)
{
}

void llvm::Metadata::dump(llvm::Metadata *this, const llvm::Module *a2)
{
  uint64_t v4 = llvm::dbgs(this);
  llvm::Metadata::print(this, v4, a2);
}

void llvm::MDNode::dumpTree(llvm::MDNode *this)
{
}

void llvm::MDNode::dumpTree(llvm::MDNode *this, const llvm::Module *a2)
{
  uint64_t v4 = llvm::dbgs(this);
  llvm::MDNode::printTree(this, v4, a2);
}

void *llvm::ModuleSummaryIndex::dump(llvm::ModuleSummaryIndex *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::ModuleSummaryIndex::print(this, v2, 1);
}

void sub_1CD5A3C0C(void *a1)
{
  sub_1CC4FDAD8(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5A3C44(uint64_t a1)
{
  return *(unsigned int *)(a1 + 192);
}

uint64_t *sub_1CD5A3C4C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)a1 + 4);
  uint64_t v5 = *a1;
  if (v4)
  {
    uint64_t v6 = 56 * v4;
    uint64_t v7 = v5 + 8;
    do
    {
      if ((*(void *)(v7 - 8) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v7 = sub_1CD58F044(v7);
      }
      v7 += 56;
      v6 -= 56;
    }
    while (v6);
    uint64_t v5 = *a1;
  }
  MEMORY[0x1D25D9CD0](v5, 8);
  *a1 = 0;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  *a1 = *a2;
  *a2 = 0;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = 0;
  int v8 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v8;
  int v9 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = v9;
  return a1;
}

uint64_t sub_1CD5A3D08(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CC37F5D8(a1, &v13, &v14, (uint64_t)&v11);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v8 = (unint64_t)*a2;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    sub_1CC4CE04C((uint64_t *)(a1 + 24), &v8);
    if (*((void *)&v8 + 1)) {
      operator delete(*((void **)&v8 + 1));
    }
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = ((unint64_t)(*(void *)(a1 + 32) - v5) >> 5) - 1;
    *(_DWORD *)(v4 + sub_1CD521E44((uint64_t)this + 8) = v6;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v11 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  return v5 + 32 * v6 + 8;
}

uint64_t sub_1CD5A3DB8(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CB883B0C(a1, &v8, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = *(unsigned int *)(a1 + 16);
    uint64_t v3 = *(void *)a1 + 16 * v5;
  }
  if (v3 == v4 + 16 * v5) {
    return 0;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 24) + 16 * *(unsigned int *)(v3 + 8) + 8);
  }
}

uint64_t sub_1CD5A3E34(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CC37F5D8(a1, &v13, &v14, (uint64_t)&v11);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v10 = (unint64_t)*a2;
    uint64_t v5 = *(_OWORD **)(a1 + 32);
    if ((unint64_t)v5 >= *(void *)(a1 + 40))
    {
      unsigned int v6 = sub_1CC00319C((void **)(a1 + 24), &v10);
    }
    else
    {
      _OWORD *v5 = v10;
      unsigned int v6 = v5 + 1;
    }
    *(void *)(a1 + 32) = v6;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v7 = (((unint64_t)v6 - v8) >> 4) - 1;
    *(_DWORD *)(v4 + sub_1CD521E44((uint64_t)this + 8) = v7;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(v11 + 8);
    uint64_t v8 = *(void *)(a1 + 24);
  }
  return v8 + 16 * v7 + 8;
}

void *sub_1CD5A3EF0(uint64_t a1, uint64_t *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CC4FD9C8(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5A3F6C(a1, a2, v7);
    void *v5 = *a2;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    *(_OWORD *)(v5 + 1) = 0u;
  }
  return v5;
}

void *sub_1CD5A3F6C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5A4020(a1, v6);
  uint64_t v8 = 0;
  sub_1CC4FD9C8(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5A4020(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5A40F8(a1, v4, &v4[7 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      void *result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5A40F8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      sub_1CC4FD9C8(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      sub_1CD46AEB4((uint64_t)(v10 + 1), (uint64_t)(a2 + 1));
      ++*(_DWORD *)(v5 + 8);
      uint64_t result = sub_1CD58F044((uint64_t)(a2 + 1));
    }
    a2 += 7;
  }
  return result;
}

llvm::SmallPtrSetImplBase *sub_1CD5A41C0(llvm::SmallPtrSetImplBase *this, uint64_t *a2, uint64_t a3)
{
  *(void *)this = (char *)this + 32;
  *((void *)this + 1) = (char *)this + 32;
  *((void *)this + 2) = 4;
  *((_DWORD *)this + 6) = 0;
  if (a3)
  {
    uint64_t v5 = 8 * a3;
    do
    {
      uint64_t v6 = *a2++;
      sub_1CB89694C(this, v6);
      v5 -= 8;
    }
    while (v5);
  }
  return this;
}

void sub_1CD5A4224(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD5A42B4();
  }
  uint64_t v4 = *(void *)a1 + 32 * v3;
  *(_DWORD *)uint64_t v4 = *(_DWORD *)a2;
  uint64_t v5 = *(const char **)(a2 + 8);
  std::string::size_type v6 = strlen(v5);
  std::string::__init((std::string *)(v4 + 8), v5, v6);
  ++*(_DWORD *)(a1 + 8);
}

void sub_1CD5A42B4()
{
}

void sub_1CD5A4368(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *a1 + 32 * v2;
    do
    {
      *(_DWORD *)a2 = *(_DWORD *)v3;
      long long v5 = *(_OWORD *)(v3 + 8);
      *(void *)(a2 + 24) = *(void *)(v3 + 24);
      *(_OWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v5;
      *(void *)(v3 + 16) = 0;
      *(void *)(v3 + 24) = 0;
      *(void *)(v3 + sub_1CD521E44((uint64_t)this + 8) = 0;
      v3 += 32;
      a2 += 32;
    }
    while (v3 != v4);
    uint64_t v6 = *((unsigned int *)a1 + 2);
    if (v6)
    {
      uint64_t v7 = *a1;
      uint64_t v8 = 32 * v6;
      do
      {
        if (*(char *)(v7 + v8 - 1) < 0) {
          operator delete(*(void **)(v7 + v8 - 24));
        }
        v8 -= 32;
      }
      while (v8);
    }
  }
}

char **sub_1CD5A43F0(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 32 * v3;
    do
    {
      if (v2[v4 - 1] < 0) {
        operator delete(*(void **)&v2[v4 - 24]);
      }
      v4 -= 32;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD5A4460(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD5A4500(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 48 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 25) < 0) {
        operator delete(*(void **)(v3 - 48));
      }
      v3 -= 48;
    }
    a1[1] = v7;
  }
}

void *sub_1CD5A4500(void *result, unint64_t a2)
{
  uint64_t v3 = (char **)result;
  unint64_t v4 = (char *)result[2];
  BOOL v5 = (_OWORD *)result[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (char *)v5) >> 4) < a2)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *result) >> 4);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555) {
      abort();
    }
    if (0x5555555555555556 * ((uint64_t)&v4[-*result] >> 4) > v9) {
      unint64_t v9 = 0x5555555555555556 * ((uint64_t)&v4[-*result] >> 4);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v4[-*result] >> 4) >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x555555555555555;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t v23 = result + 2;
    if (v10)
    {
      if (v10 > 0x555555555555555) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(48 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    char v12 = &v11[48 * v8];
    uint64_t v13 = &v12[48 * a2];
    uint64_t v14 = 48 * a2;
    unsigned int v15 = v12;
    do
    {
      *(_OWORD *)((char *)v15 + 2sub_1CD521E44((uint64_t)this + 8) = 0uLL;
      *unsigned int v15 = 0uLL;
      v15[1] = 0uLL;
      v15 += 3;
      v14 -= 48;
    }
    while (v14);
    uint64_t v16 = *v3;
    if (v5 == (_OWORD *)*v3)
    {
      int64x2_t v17 = vdupq_n_s64((unint64_t)v5);
    }
    else
    {
      do
      {
        long long v18 = *(v5 - 3);
        *((void *)v12 - 4) = *((void *)v5 - 4);
        *((_OWORD *)v12 - 3) = v18;
        *((void *)v5 - 5) = 0;
        *((void *)v5 - 4) = 0;
        *((void *)v5 - 6) = 0;
        long long v19 = *(_OWORD *)((char *)v5 - 24);
        *((_DWORD *)v12 - 2) = *((_DWORD *)v5 - 2);
        *(_OWORD *)(v12 - 24) = v19;
        v12 -= 48;
        v5 -= 3;
      }
      while (v5 != (_OWORD *)v16);
      int64x2_t v17 = *(int64x2_t *)v3;
      unint64_t v4 = v3[2];
    }
    *uint64_t v3 = v12;
    v3[1] = v13;
    int64x2_t v21 = v17;
    v3[2] = &v11[48 * v10];
    uint64_t v22 = v4;
    uint64_t v20 = v17.i64[0];
    return (void *)sub_1CD5649E0((uint64_t)&v20);
  }
  else
  {
    if (a2)
    {
      unint64_t v6 = &v5[3 * a2];
      uint64_t v7 = 48 * a2;
      do
      {
        *(_OWORD *)((char *)v5 + 2sub_1CD521E44((uint64_t)this + 8) = 0uLL;
        _OWORD *v5 = 0uLL;
        v5[1] = 0uLL;
        v5 += 3;
        v7 -= 48;
      }
      while (v7);
      BOOL v5 = v6;
    }
    result[1] = v5;
  }
  return result;
}

void sub_1CD5A46C0(uint64_t a1, _WORD *a2)
{
  v24[0] = 0;
  v24[1] = 0;
  uint64_t v25 = 0;
  int v16 = 0;
  char v20 = 0;
  uint64_t v21 = 0;
  uint64_t v23 = v24;
  int v22 = 0;
  unsigned int v15 = &unk_1F2646F30;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  sub_1CB8E509C((llvm::raw_ostream *)&v15, "funcFlags: (");
  unint64_t v4 = sub_1CB8E509C((llvm::raw_ostream *)&v15, "readNone: ");
  sub_1CD098D14(v4, *a2 & 1, 0, 0, 0);
  BOOL v5 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", readOnly: ");
  sub_1CD098D14(v5, ((unint64_t)(unsigned __int16)*a2 >> 1) & 1, 0, 0, 0);
  unint64_t v6 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", noRecurse: ");
  sub_1CD098D14(v6, ((unint64_t)(unsigned __int16)*a2 >> 2) & 1, 0, 0, 0);
  uint64_t v7 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", returnDoesNotAlias: ");
  sub_1CD098D14(v7, ((unint64_t)(unsigned __int16)*a2 >> 3) & 1, 0, 0, 0);
  unint64_t v8 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", noInline: ");
  sub_1CD098D14(v8, ((unint64_t)(unsigned __int16)*a2 >> 4) & 1, 0, 0, 0);
  unint64_t v9 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", alwaysInline: ");
  sub_1CD098D14(v9, ((unint64_t)(unsigned __int16)*a2 >> 5) & 1, 0, 0, 0);
  unint64_t v10 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", noUnwind: ");
  sub_1CD098D14(v10, ((unint64_t)(unsigned __int16)*a2 >> 6) & 1, 0, 0, 0);
  uint64_t v11 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", mayThrow: ");
  sub_1CD098D14(v11, ((unint64_t)(unsigned __int16)*a2 >> 7) & 1, 0, 0, 0);
  char v12 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", hasUnknownCall: ");
  sub_1CD098D14(v12, ((unint64_t)(unsigned __int16)*a2 >> 8) & 1, 0, 0, 0);
  uint64_t v13 = sub_1CB8E509C((llvm::raw_ostream *)&v15, ", mustBeUnreachable: ");
  sub_1CD098D14(v13, ((unint64_t)(unsigned __int16)*a2 >> 9) & 1, 0, 0, 0);
  sub_1CB8E509C((llvm::raw_ostream *)&v15, ")");
  if (*((char *)v23 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *v23, (unint64_t)v23[1]);
  }
  else
  {
    long long v14 = *(_OWORD *)v23;
    *(void *)(a1 + 16) = v23[2];
    *(_OWORD *)a1 = v14;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
}

uint64_t **sub_1CD5A4928(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  unint64_t v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x38uLL);
    unint64_t v10 = *a3;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[5] = 0;
    v7[6] = 0;
    _OWORD v7[4] = v10;
    void v7[2] = v9;
    *unint64_t v6 = (uint64_t *)v7;
    uint64_t v11 = (uint64_t *)**a1;
    char v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      char v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t sub_1CD5A49F8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 4) != 0xFFFFFFFFFFFFFFFCLL)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CC505574(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      unint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

BOOL llvm::hasAssumption(uint64_t a1, uint64_t a2)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute(a1, "llvm.assume", 0xBuLL);
  return sub_1CC5056D4(&FnAttribute, a2);
}

{
  uint64_t v4;
  uint64_t AttributeAtIndex;
  uint64_t FnAttribute;

  unint64_t v4 = *(void *)(a1 - 32);
  if (v4)
  {
    if (!*(unsigned char *)(v4 + 16) && *(void *)(v4 + 24) == *(void *)(a1 + 72))
    {
      uint64_t FnAttribute = llvm::Function::getFnAttribute(v4, "llvm.assume", 0xBuLL);
      if (sub_1CC5056D4(&FnAttribute, a2)) {
        return 1;
      }
    }
  }
  uint64_t FnAttribute = *(void *)(a1 + 64);
  AttributeAtIndex = llvm::AttributeList::getAttributeAtIndex(&FnAttribute, -1, "llvm.assume", 0xBuLL);
  if (!AttributeAtIndex) {
    llvm::CallBase::getFnAttrOnCalledFunction<llvm::StringRef>();
  }
  uint64_t FnAttribute = AttributeAtIndex;
  return sub_1CC5056D4(&FnAttribute, a2);
}

void llvm::getAssumptions(llvm *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute((uint64_t)this, "llvm.assume", 0xBuLL);
  sub_1CC5057B4(&FnAttribute, a2);
}

{
  uint64_t AttributeAtIndex;
  uint64_t v5;

  uint64_t v5 = *((void *)this + 8);
  AttributeAtIndex = llvm::AttributeList::getAttributeAtIndex(&v5, -1, "llvm.assume", 0xBuLL);
  if (!AttributeAtIndex) {
    llvm::CallBase::getFnAttrOnCalledFunction<llvm::StringRef>();
  }
  uint64_t v5 = AttributeAtIndex;
  sub_1CC5057B4(&v5, a2);
}

uint64_t llvm::addAssumptions(llvm::Function *a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8)) {
    return 0;
  }
  __p.__r_.__value_.__r.__words[0] = llvm::Function::getFnAttribute((uint64_t)a1, "llvm.assume", 0xBuLL);
  sub_1CC5057B4((uint64_t *)&__p, (uint64_t)&v13);
  uint64_t v2 = sub_1CD5A4F8C((uint64_t)&v13, a2);
  if (v2)
  {
    Context = (uint64_t *)llvm::Function::getContext(a1);
    uint64_t v7 = v13;
    if (v14)
    {
      if (v15)
      {
        uint64_t v11 = 16 * v15;
        while (v7->__r_.__value_.__r.__words[0] >= 0xFFFFFFFFFFFFFFFELL)
        {
          uint64_t v7 = (std::string *)((char *)v7 + 16);
          v11 -= 16;
          if (!v11) {
            goto LABEL_7;
          }
        }
      }
    }
    else
    {
LABEL_7:
      uint64_t v7 = (std::string *)((char *)v13 + 16 * v15);
    }
    sub_1CD5A5074(v7, (std::string *)((char *)v13 + 16 * v15), (std::string *)((char *)v13 + 16 * v15), ",", 1uLL, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    unint64_t v10 = llvm::Attribute::get(Context, "llvm.assume", 0xBuLL, (unsigned __int8 *)p_p, size);
    llvm::Function::addFnAttr((llvm::LLVMContext ***)a1, (uint64_t)v10);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  MEMORY[0x1D25D9CD0](v13, 8);
  return v2;
}

uint64_t llvm::addAssumptions(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8)) {
    return 0;
  }
  llvm::getAssumptions((llvm *)a1, (uint64_t)&v14);
  uint64_t v2 = sub_1CD5A4F8C((uint64_t)&v14, a2);
  if (v2)
  {
    Context = (uint64_t *)llvm::Value::getContext((llvm::Value *)a1);
    uint64_t v7 = v14;
    if (v15)
    {
      if (v16)
      {
        uint64_t v12 = 16 * v16;
        while (v7->__r_.__value_.__r.__words[0] >= 0xFFFFFFFFFFFFFFFELL)
        {
          uint64_t v7 = (std::string *)((char *)v7 + 16);
          v12 -= 16;
          if (!v12) {
            goto LABEL_7;
          }
        }
      }
    }
    else
    {
LABEL_7:
      uint64_t v7 = (std::string *)((char *)v14 + 16 * v16);
    }
    sub_1CD5A5074(v7, (std::string *)((char *)v14 + 16 * v16), (std::string *)((char *)v14 + 16 * v16), ",", 1uLL, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    unint64_t v10 = llvm::Attribute::get(Context, "llvm.assume", 0xBuLL, (unsigned __int8 *)p_p, size);
    uint64_t v11 = (llvm::LLVMContext *)llvm::Value::getContext((llvm::Value *)a1);
    *(void *)(a1 + 64) = llvm::AttributeList::addAttributeAtIndex((llvm::AttributeList *)(a1 + 64), v11, -1, (uint64_t)v10);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  MEMORY[0x1D25D9CD0](v14, 8);
  return v2;
}

BOOL sub_1CD5A4EF4(uint64_t a1, unsigned int a2, void *__s2, size_t __n)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  if (a2)
  {
    uint64_t v9 = 16 * a2;
    uint64_t v6 = a1;
    uint64_t v10 = a1 + v9;
    while (*(void *)(v6 + 8) != __n || __n && memcmp(*(const void **)v6, __s2, __n))
    {
      v6 += 16;
      v9 -= 16;
      if (!v9)
      {
        uint64_t v6 = v10;
        return v5 != (v6 - a1) >> 4;
      }
    }
  }
  return v5 != (v6 - a1) >> 4;
}

uint64_t sub_1CD5A4F8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  uint64_t v4 = *(void *)a2 + 16 * v3;
  if (*(_DWORD *)(a2 + 8))
  {
    if (v3)
    {
      uint64_t v5 = 16 * v3;
      uint64_t v6 = *(unint64_t **)a2;
      while (*v6 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v6 += 2;
        v5 -= 16;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v6 = *(unint64_t **)a2;
    }
  }
  else
  {
LABEL_6:
    uint64_t v6 = (unint64_t *)(*(void *)a2 + 16 * v3);
  }
  uint64_t v7 = *(void *)a2 + 16 * v3;
  if (v6 == (unint64_t *)v7)
  {
    char v8 = 0;
  }
  else
  {
    char v8 = 0;
    do
    {
      sub_1CC5059B0(a1, (uint64_t)v6, (uint64_t)v12);
      v8 |= v12[16] != 0;
      uint64_t v9 = v6 + 2;
      while (v9 != (unint64_t *)v4)
      {
        unint64_t v10 = *v9;
        v9 += 2;
        if (v10 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v6 = v9 - 2;
          goto LABEL_14;
        }
      }
      uint64_t v6 = (unint64_t *)v4;
LABEL_14:
      ;
    }
    while (v6 != (unint64_t *)v7);
  }
  return v8 & 1;
}

std::string *sub_1CD5A5074@<X0>(std::string *result@<X0>, std::string *a2@<X1>, std::string *a3@<X2>, const std::string::value_type *a4@<X4>, std::string::size_type a5@<X5>, std::string *a6@<X8>)
{
  a6->__r_.__value_.__r.__words[0] = 0;
  a6->__r_.__value_.__l.__size_ = 0;
  a6->__r_.__value_.__r.__words[2] = 0;
  if (result != a3)
  {
    unint64_t v10 = result;
    uint64_t v12 = 0;
    uint64_t v13 = result;
    do
    {
      uint64_t v14 = v12++;
      int v15 = &v13->__r_.__value_.__r.__words[2];
      while (v15 != (unint64_t *)a2)
      {
        unint64_t v16 = *v15;
        v15 += 2;
        if (v16 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v13 = (std::string *)(v15 - 2);
          goto LABEL_8;
        }
      }
      uint64_t v13 = a2;
LABEL_8:
      ;
    }
    while (v13 != a3);
    std::string::size_type v17 = v14 * a5;
    uint64_t v18 = result;
    do
    {
      v17 += v18->__r_.__value_.__l.__size_;
      uint64_t v19 = &v18->__r_.__value_.__r.__words[2];
      while (v19 != (unint64_t *)a2)
      {
        unint64_t v20 = *v19;
        v19 += 2;
        if (v20 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v18 = (std::string *)(v19 - 2);
          goto LABEL_15;
        }
      }
      uint64_t v18 = a2;
LABEL_15:
      ;
    }
    while (v18 != a3);
    std::string::reserve(a6, v17);
    uint64_t v21 = (const std::string::value_type *)v10->__r_.__value_.__r.__words[0];
    for (std::string::size_type i = v10->__r_.__value_.__l.__size_; ; std::string::size_type i = v23[1].__r_.__value_.__r.__words[0])
    {
      uint64_t result = std::string::append(a6, v21, i);
      while (1)
      {
        uint64_t v23 = v10;
        unint64_t v10 = (std::string *)((char *)v10 + 16);
        if (v10 == a2) {
          break;
        }
        if (v10->__r_.__value_.__r.__words[0] <= 0xFFFFFFFFFFFFFFFDLL) {
          goto LABEL_22;
        }
      }
      unint64_t v10 = a2;
LABEL_22:
      if (v10 == a3) {
        break;
      }
      std::string::append(a6, a4, a5);
      uint64_t v21 = (const std::string::value_type *)v10->__r_.__value_.__r.__words[0];
    }
  }
  return result;
}

unint64_t llvm::Attribute::getWithDereferenceableOrNullBytes(llvm::Attribute *this, llvm::LLVMContext *a2)
{
  return llvm::Attribute::get((uint64_t *)this, 0x4Du, (uint64_t)a2);
}

unint64_t llvm::Attribute::getWithByValType(llvm::Attribute *this, llvm::LLVMContext *a2, llvm::Type *a3)
{
  return llvm::Attribute::get((uint64_t *)this, 69, (uint64_t)a2);
}

unint64_t llvm::Attribute::getWithStructRetType(llvm::Attribute *this, llvm::LLVMContext *a2, llvm::Type *a3)
{
  return llvm::Attribute::get((uint64_t *)this, 73, (uint64_t)a2);
}

unint64_t llvm::Attribute::getWithInAllocaType(llvm::Attribute *this, llvm::LLVMContext *a2, llvm::Type *a3)
{
  return llvm::Attribute::get((uint64_t *)this, 71, (uint64_t)a2);
}

unint64_t llvm::Attribute::getWithUWTableKind(uint64_t *a1, int a2)
{
  return llvm::Attribute::get(a1, 0x4Fu, a2);
}

unint64_t llvm::Attribute::getWithAllocSizeArgs(uint64_t *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (*((unsigned char *)a3 + 4)) {
    uint64_t v3 = *a3;
  }
  return llvm::Attribute::get(a1, 0x4Bu, v3 | (a2 << 32));
}

unint64_t llvm::Attribute::getWithVScaleRangeArgs(llvm::Attribute *this, llvm::LLVMContext *a2, unsigned int a3)
{
  return llvm::Attribute::get((uint64_t *)this, 0x50u, a3 | ((void)a2 << 32));
}

uint64_t llvm::Attribute::getDereferenceableBytes(llvm::Attribute *this)
{
  return *(void *)(*(void *)this + 16);
}

uint64_t llvm::Attribute::getAllocSizeArgs(llvm::Attribute *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 16);
  BOOL v2 = v1 == 0xFFFFFFFFLL;
  BOOL v3 = v1 != 0xFFFFFFFFLL;
  uint64_t v4 = *(void *)(*(void *)this + 16);
  if (v2) {
    uint64_t v4 = 0;
  }
  *(void *)&v6[4] = v4 & 0xFFFFFFFEFFFFFFFFLL | *(void *)(*(void *)this + 16) & 0xFFFFFF00 | ((unint64_t)v3 << 32);
  return *(void *)v6;
}

uint64_t llvm::Attribute::getVScaleRangeMin(llvm::Attribute *this)
{
  return *(unsigned int *)(*(void *)this + 20);
}

uint64_t llvm::Attribute::getVScaleRangeMax(llvm::Attribute *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 16);
  if (!*(void *)(*(void *)this + 16)) {
    uint64_t v1 = 0;
  }
  *(void *)&v4[4] = v1 | *(void *)(*(void *)this + 16) & 0xFFFFFF00 | ((unint64_t)(*(void *)(*(void *)this + 16) != 0) << 32);
  *((void *)&v3 + 1) = *(void *)(*(void *)this + 16) != 0;
  *(void *)&long long v3 = *(void *)v4;
  return v3 >> 32;
}

uint64_t llvm::AttributeSet::addAttribute(uint64_t *a1, uint64_t *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, size_t a6)
{
  v16[8] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = v16;
  uint64_t v15 = 0x800000000;
  unint64_t v10 = llvm::Attribute::get(a2, a3, a4, a5, a6);
  sub_1CC50F2F8((uint64_t)&v14, a3, a4, (uint64_t)v10);
  uint64_t Sorted = llvm::AttributeSetNode::getSorted(a2, (uint64_t *)v14, v15);
  uint64_t v12 = llvm::AttributeSet::addAttributes(a1, a2, Sorted);
  if (v14 != v16) {
    free(v14);
  }
  return v12;
}

uint64_t llvm::AttrBuilder::merge(uint64_t this, const llvm::AttrBuilder *a2)
{
  uint64_t v2 = *((unsigned int *)a2 + 4);
  if (v2)
  {
    long long v3 = (uint64_t *)*((void *)a2 + 1);
    uint64_t v4 = 8 * v2;
    do
    {
      uint64_t v5 = *v3++;
      this = llvm::AttrBuilder::addAttribute(this, v5);
      v4 -= 8;
    }
    while (v4);
  }
  return this;
}

uint64_t llvm::AttributeSet::getAttribute(uint64_t *a1, int a2)
{
  uint64_t result = *a1;
  if (result)
  {
    uint64_t result = llvm::AttributeSetNode::findEnumAttribute(result, a2);
    if (!v3) {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::AttributeSet::getAttribute(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  if (*a1 && (v5[0] = a2, v5[1] = a3, uint64_t v6 = 0, sub_1CC5122C8((uint64_t *)(v3 + 24), (uint64_t)v5, &v6))) {
    return *(void *)(v6 + 16);
  }
  else {
    return 0;
  }
}

uint64_t llvm::AttributeSet::getAlignment(llvm::AttributeSetNode **this)
{
  uint64_t v1 = *this;
  if (v1)
  {
    LOWORD(v1) = llvm::AttributeSetNode::getAlignment(v1);
    int v2 = BYTE1(v1);
  }
  else
  {
    int v2 = 0;
  }
  return v1 | (v2 << 8);
}

uint64_t llvm::AttributeSet::getElementType(llvm::AttributeSet *this)
{
  uint64_t result = *(void *)this;
  if (result)
  {
    uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute(result, 70);
    if (v3) {
      BOOL v4 = EnumAttribute == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (v4) {
      return 0;
    }
    else {
      return *(void *)(EnumAttribute + 16);
    }
  }
  return result;
}

llvm::AttributeSetNode *llvm::AttributeSet::getAllocSizeArgs(llvm::AttributeSetNode **this)
{
  uint64_t result = *this;
  if (result) {
    return (llvm::AttributeSetNode *)llvm::AttributeSetNode::getAllocSizeArgs(result);
  }
  return result;
}

uint64_t llvm::AttributeSetNode::getAllocSizeArgs(llvm::AttributeSetNode *this)
{
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute((uint64_t)this, 75);
  if (!v2) {
    return 0;
  }
  unint64_t v5 = *(void *)(EnumAttribute + 16);
  unint64_t v3 = HIDWORD(v5);
  int v4 = v5 & 0xFFFFFF00;
  LODWORD(v5) = v5;
  LODWORD(v7) = v3;
  if (*(void *)(EnumAttribute + 16) == 0xFFFFFFFFLL) {
    LODWORD(v5) = 0;
  }
  HIDWORD(v7) = v5 | v4;
  return v7;
}

uint64_t llvm::AttributeSet::getVScaleRangeMin(llvm::AttributeSetNode **this)
{
  uint64_t v1 = *this;
  if (v1) {
    return llvm::AttributeSetNode::getVScaleRangeMin(v1);
  }
  else {
    return 1;
  }
}

uint64_t llvm::AttributeSetNode::getVScaleRangeMin(llvm::AttributeSetNode *this)
{
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute((uint64_t)this, 80);
  if (v2) {
    return *(unsigned int *)(EnumAttribute + 20);
  }
  else {
    return 1;
  }
}

llvm::AttributeSetNode *llvm::AttributeSet::getVScaleRangeMax(llvm::AttributeSetNode **this)
{
  uint64_t result = *this;
  if (result) {
    return (llvm::AttributeSetNode *)llvm::AttributeSetNode::getVScaleRangeMax(result);
  }
  return result;
}

uint64_t llvm::AttributeSetNode::getVScaleRangeMax(llvm::AttributeSetNode *this)
{
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute((uint64_t)this, 80);
  if (!v2) {
    return 0;
  }
  unint64_t v5 = *(void *)(EnumAttribute + 16);
  unint64_t v3 = HIDWORD(v5);
  int v4 = v5 & 0xFFFFFF00;
  LODWORD(v5) = v5;
  LODWORD(vsub_1CD521E44((uint64_t)this + 8) = v3;
  if (!*(void *)(EnumAttribute + 16)) {
    LODWORD(v5) = 0;
  }
  HIDWORD(vsub_1CD521E44((uint64_t)this + 8) = v5 | v4;
  *((void *)&v7 + 1) = *(void *)(EnumAttribute + 16) != 0;
  *(void *)&long long v7 = v8;
  return v7 >> 32;
}

void llvm::AttributeSet::dump(llvm::AttributeSet *this)
{
  char v2 = llvm::dbgs(this);
  unint64_t v3 = sub_1CB8E509C(v2, "AS =\n");
  int v4 = llvm::dbgs(v3);
  unint64_t v5 = sub_1CB8E509C(v4, "  { ");
  long long v7 = llvm::dbgs(v5);
  if (*(void *)this)
  {
    llvm::AttributeSetNode::getAsString(*(llvm::AttributeSetNode **)this, 1, &__p);
    char v8 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  else
  {
    char v8 = 0;
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    __p.__r_.__value_.__s.__data_[0] = 0;
  }
  BOOL v9 = v8 < 0;
  if (v8 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  size_t v11 = v8 & 0x7F;
  if (v9) {
    size_t v12 = size;
  }
  else {
    size_t v12 = v11;
  }
  uint64_t v13 = llvm::raw_ostream::write(v7, (const char *)p_p, v12);
  sub_1CB8E509C(v13, " }\n");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

llvm::raw_ostream *llvm::AttributeListImpl::dump(llvm::AttributeListImpl *this)
{
  char v2 = this;
  return llvm::AttributeList::dump((llvm::AttributeList *)&v2);
}

llvm::raw_ostream *llvm::AttributeList::dump(llvm::AttributeList *this)
{
  char v2 = llvm::dbgs(this);

  return llvm::AttributeList::print(this, v2);
}

uint64_t llvm::AttributeList::removeAttributesAtIndex(llvm::AttributeList *this, llvm::LLVMContext *a2, int a3)
{
  v10[4] = *MEMORY[0x1E4F143B8];
  uint64_t Impl = *(void *)this;
  if (*(void *)this)
  {
    unsigned int v4 = a3 + 1;
    uint64_t v5 = *(unsigned int *)(Impl + 8);
    if (a3 + 1 < v5)
    {
      char v8 = v10;
      uint64_t v9 = 0x400000000;
      sub_1CB935BDC((unsigned int *)&v8, (unsigned char *)(Impl + 40), (unsigned char *)(Impl + 40 + 8 * v5));
      *((void *)v8 + v4) = 0;
      uint64_t Impl = llvm::AttributeList::getImpl((uint64_t *)a2, v8, v9);
      if (v8 != v10) {
        free(v8);
      }
    }
  }
  return Impl;
}

uint64_t llvm::AttributeList::addDereferenceableOrNullParamAttr(llvm::AttributeList *this, llvm::LLVMContext *a2, int a3, uint64_t a4)
{
  v13[8] = *MEMORY[0x1E4F143B8];
  unint64_t v10 = a2;
  size_t v11 = v13;
  uint64_t v12 = 0x800000000;
  if (a4)
  {
    unint64_t v7 = llvm::Attribute::get((uint64_t *)a2, 0x4Du, a4);
    llvm::AttrBuilder::addAttribute((uint64_t)&v10, v7);
  }
  uint64_t v8 = llvm::AttributeList::addAttributesAtIndex(this, a2, a3 + 1, (const llvm::AttrBuilder *)&v10);
  if (v11 != v13) {
    free(v11);
  }
  return v8;
}

uint64_t **llvm::AttrBuilder::addDereferenceableOrNullAttr(uint64_t **this, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = llvm::Attribute::get(*this, 0x4Du, a2);
    llvm::AttrBuilder::addAttribute((uint64_t)this, v3);
  }
  return this;
}

uint64_t llvm::AttrBuilder::addAllocSizeAttr(uint64_t **a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (*((unsigned char *)a3 + 4)) {
    uint64_t v4 = *a3;
  }
  unint64_t v5 = llvm::Attribute::get(*a1, 0x4Bu, v4 | (a2 << 32));

  return llvm::AttrBuilder::addAttribute((uint64_t)a1, v5);
}

uint64_t llvm::AttributeList::getParamByRefType(llvm::AttributeList *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this || (a2 + 2) >= *(_DWORD *)(v2 + 8)) {
    return 0;
  }
  uint64_t result = *(void *)(v2 + 8 * (a2 + 2) + 40);
  if (!result) {
    return result;
  }
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute(result, 68);
  if (!v5 || EnumAttribute == 0) {
    return 0;
  }
  else {
    return *(void *)(EnumAttribute + 16);
  }
}

uint64_t llvm::AttributeList::getParamPreallocatedType(llvm::AttributeList *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this || (a2 + 2) >= *(_DWORD *)(v2 + 8)) {
    return 0;
  }
  uint64_t result = *(void *)(v2 + 8 * (a2 + 2) + 40);
  if (!result) {
    return result;
  }
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute(result, 72);
  if (!v5 || EnumAttribute == 0) {
    return 0;
  }
  else {
    return *(void *)(EnumAttribute + 16);
  }
}

uint64_t llvm::AttributeList::getParamInAllocaType(llvm::AttributeList *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this || (a2 + 2) >= *(_DWORD *)(v2 + 8)) {
    return 0;
  }
  uint64_t result = *(void *)(v2 + 8 * (a2 + 2) + 40);
  if (!result) {
    return result;
  }
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute(result, 71);
  if (!v5 || EnumAttribute == 0) {
    return 0;
  }
  else {
    return *(void *)(EnumAttribute + 16);
  }
}

uint64_t llvm::AttributeList::getParamElementType(llvm::AttributeList *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this || (a2 + 2) >= *(_DWORD *)(v2 + 8)) {
    return 0;
  }
  uint64_t result = *(void *)(v2 + 8 * (a2 + 2) + 40);
  if (!result) {
    return result;
  }
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute(result, 70);
  if (!v5 || EnumAttribute == 0) {
    return 0;
  }
  else {
    return *(void *)(EnumAttribute + 16);
  }
}

uint64_t llvm::AttributeList::getUWTableKind(llvm::AttributeList *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this || !*(_DWORD *)(v1 + 8)) {
    return 0;
  }
  uint64_t result = *(void *)(v1 + 40);
  if (!result) {
    return result;
  }
  uint64_t EnumAttribute = llvm::AttributeSetNode::findEnumAttribute(result, 79);
  if (v4) {
    return *(unsigned int *)(EnumAttribute + 16);
  }
  else {
    return 0;
  }
}

llvm::raw_ostream *llvm::AttributeList::print(llvm::AttributeList *this, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "AttributeList[\n");
  if (*(void *)this)
  {
    int v4 = *(_DWORD *)(*(void *)this + 8);
    if (v4)
    {
      unsigned int v5 = 0;
      uint64_t v6 = 40;
      do
      {
        uint64_t v7 = *(void *)this;
        if (*(void *)this && v5 < *(_DWORD *)(v7 + 8) && *(void *)(v7 + v6))
        {
          sub_1CB8E509C(a2, "  { ");
          uint64_t v8 = a2;
          if (v5)
          {
            if (v5 == 1)
            {
              uint64_t v9 = "return";
            }
            else
            {
              unint64_t v10 = sub_1CB8E509C(a2, "arg(");
              uint64_t v8 = llvm::raw_ostream::operator<<(v10, v5 - 2);
              uint64_t v9 = ")";
            }
          }
          else
          {
            uint64_t v9 = "function";
          }
          sub_1CB8E509C(v8, v9);
          size_t v11 = sub_1CB8E509C(a2, " => ");
          uint64_t v12 = *(void *)this;
          if (*(void *)this && v5 < *(_DWORD *)(v12 + 8) && (uint64_t v13 = *(llvm::AttributeSetNode **)(v12 + v6)) != 0)
          {
            llvm::AttributeSetNode::getAsString(v13, 0, &__p);
            char v14 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          else
          {
            char v14 = 0;
            *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
            __p.__r_.__value_.__s.__data_[0] = 0;
          }
          BOOL v15 = v14 < 0;
          if (v14 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          std::string::size_type v17 = v14 & 0x7F;
          if (v15) {
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
          }
          else {
            std::string::size_type size = v17;
          }
          uint64_t v19 = llvm::raw_ostream::write(v11, (const char *)p_p, size);
          sub_1CB8E509C(v19, " }\n");
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
        ++v5;
        v6 += 8;
      }
      while (v4 != v5);
    }
  }
  return sub_1CB8E509C(a2, "]\n");
}

uint64_t llvm::AttrBuilder::clear(uint64_t this)
{
  *(_DWORD *)(this + 16) = 0;
  return this;
}

uint64_t llvm::AttrBuilder::addAllocSizeAttrFromRawRepr(uint64_t **this, uint64_t a2)
{
  unint64_t v3 = llvm::Attribute::get(*this, 0x4Bu, a2);

  return llvm::AttrBuilder::addAttribute((uint64_t)this, v3);
}

uint64_t **llvm::AttrBuilder::addVScaleRangeAttr(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  if ((a3 & 0xFF00000000) == 0) {
    uint64_t v4 = 0;
  }
  uint64_t v5 = v4 | (a2 << 32);
  if (v5)
  {
    unint64_t v6 = llvm::Attribute::get(*a1, 0x50u, v5);
    llvm::AttrBuilder::addAttribute((uint64_t)a1, v6);
  }
  return a1;
}

uint64_t **llvm::AttrBuilder::addVScaleRangeAttrFromRawRepr(uint64_t **this, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = llvm::Attribute::get(*this, 0x50u, a2);
    llvm::AttrBuilder::addAttribute((uint64_t)this, v3);
  }
  return this;
}

uint64_t **llvm::AttrBuilder::addUWTableAttr(uint64_t **a1, int a2)
{
  if (a2)
  {
    unint64_t v3 = llvm::Attribute::get(*a1, 0x4Fu, a2);
    llvm::AttrBuilder::addAttribute((uint64_t)a1, v3);
  }
  return a1;
}

uint64_t llvm::AttrBuilder::getTypeAttr(uint64_t a1, int a2)
{
  uint64_t result = llvm::AttrBuilder::getAttribute(a1, a2);
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t llvm::AttrBuilder::addTypeAttr(uint64_t **a1, int a2, uint64_t a3)
{
  unint64_t v4 = llvm::Attribute::get(*a1, a2, a3);

  return llvm::AttrBuilder::addAttribute((uint64_t)a1, v4);
}

uint64_t llvm::AttrBuilder::addByValAttr(uint64_t **this, llvm::Type *a2)
{
  unint64_t v3 = llvm::Attribute::get(*this, 69, (uint64_t)a2);

  return llvm::AttrBuilder::addAttribute((uint64_t)this, v3);
}

uint64_t llvm::AttrBuilder::addByRefAttr(uint64_t **this, llvm::Type *a2)
{
  unint64_t v3 = llvm::Attribute::get(*this, 68, (uint64_t)a2);

  return llvm::AttrBuilder::addAttribute((uint64_t)this, v3);
}

uint64_t llvm::AttrBuilder::addInAllocaAttr(uint64_t **this, llvm::Type *a2)
{
  unint64_t v3 = llvm::Attribute::get(*this, 71, (uint64_t)a2);

  return llvm::AttrBuilder::addAttribute((uint64_t)this, v3);
}

uint64_t llvm::AttrBuilder::hasAlignmentAttr(llvm::AttrBuilder *this)
{
  uint64_t result = llvm::AttrBuilder::getAttribute((uint64_t)this, 74);
  if (result) {
    return *(void *)(result + 16) != 0;
  }
  return result;
}

BOOL llvm::AttrBuilder::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  if (v2 != *(_DWORD *)(a2 + 16)) {
    return 0;
  }
  if (!v2) {
    return 1;
  }
  unint64_t v3 = *(uint64_t **)(a1 + 8);
  unint64_t v4 = *(uint64_t **)(a2 + 8);
  uint64_t v5 = 8 * v2 - 8;
  do
  {
    uint64_t v7 = *v4++;
    uint64_t v6 = v7;
    uint64_t v8 = *v3++;
    BOOL result = v8 == v6;
    BOOL v10 = v8 != v6 || v5 == 0;
    v5 -= 8;
  }
  while (!v10);
  return result;
}

unsigned int *sub_1CD5A5FCC(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return sub_1CC5097B4(a2, a3);
}

unint64_t sub_1CD5A5FD8(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  return sub_1CC13A6B8(*(void **)a3, *(void *)a3 + 4 * a3[2]);
}

uint64_t sub_1CD5A6014(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 8);
  if (v3)
  {
    uint64_t v5 = (uint64_t *)(a2 + 48);
    uint64_t v6 = 8 * v3;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t result = sub_1CC1312F4(a3, v7);
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_1CD5A6060(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(_OWORD **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *uint64_t v7 = xmmword_1CFAC4A20;
      uint64_t v7 = (_OWORD *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(void *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      BOOL v10 = 0;
      uint64_t result = sub_1CC5122C8((uint64_t *)v5, a2, &v10);
      uint64_t v9 = v10;
      _OWORD *v10 = *(_OWORD *)a2;
      *((void *)v9 + 2) = *(void *)(a2 + 16);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1CD5A6114(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 8);
  if (v3)
  {
    uint64_t v5 = (uint64_t *)(a2 + 40);
    uint64_t v6 = 8 * v3;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t result = sub_1CC1312F4(a3, v7);
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

std::string *llvm::UpgradeInlineAsmString(std::string *a1)
{
  uint64_t result = (std::string *)sub_1CBC1CE7C((uint64_t *)a1, "mov\tfp", 0);
  if (!result)
  {
    uint64_t result = (std::string *)sub_1CBC1CE7C((uint64_t *)a1, "objc_retainAutoreleaseReturnValue", 0);
    if (result != (std::string *)-1)
    {
      uint64_t result = (std::string *)sub_1CBC1CE7C((uint64_t *)a1, "# marker", 0);
      if (result != (std::string *)-1)
      {
        return std::string::replace(a1, (std::string::size_type)result, 1uLL, ";");
      }
    }
  }
  return result;
}

llvm::Instruction *sub_1CD5A61FC(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6 = (unsigned __int8 *)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1984), 0, 0);

  return sub_1CB8445F4(a1, a2, v6, a3);
}

llvm::Instruction *sub_1CD5A6264(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v8 = (unsigned __int8 *)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1984), 0, 0);

  return sub_1CB84478C(a1, a2, a3, v8, a4);
}

double sub_1CD5A62D4(uint64_t a1)
{
  Primitiveunint64_t SizeInBits = (llvm::LLVMContext *)llvm::Type::getPrimitiveSizeInBits(*(llvm::Type **)(a1 + 24));
  if (v2 == 1)
  {
    uint64_t v7 = PrimitiveSizeInBits;
    Primitiveunint64_t SizeInBits = v7;
  }
  unint64_t v4 = (llvm::FixedVectorType *)llvm::IntegerType::get(*(llvm::IntegerType **)a1, PrimitiveSizeInBits);
  uint64_t v5 = (llvm::Type *)(*(unsigned int *)(a1 + 32) | ((unint64_t)(*(unsigned char *)(a1 + 8) == 19) << 32));

  return llvm::VectorType::get(v4, v5);
}

llvm::Instruction *sub_1CD5A6358(uint64_t a1, llvm::BinaryOperator *this, uint64_t a3, llvm::Instruction *a4, uint64_t a5)
{
  int v5 = a5;
  int v6 = (int)a4;
  if (!this || *((unsigned __int8 *)this + 16) > 0x14u)
  {
    __int16 v15 = 257;
    Neg = llvm::BinaryOperator::CreateNeg(this, (llvm::Value *)v14, 0, a4);
    BOOL v10 = sub_1CB844E0C((uint64_t *)a1, Neg, a3);
    size_t v11 = (unsigned __int8 *)v10;
    if (v6) {
      *((unsigned char *)v10 + 17) |= 2u;
    }
    if (v5) {
      *((unsigned char *)v10 + 17) |= 4u;
    }
    return (llvm::Instruction *)v11;
  }
  size_t v11 = (unsigned __int8 *)(*(uint64_t (**)(void, llvm::BinaryOperator *, llvm::Instruction *, uint64_t))(**(void **)(a1 + 72) + 192))(*(void *)(a1 + 72), this, a4, a5);
  if (v11) {
    BOOL v13 = v11[16] >= 0x1Cu;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13) {
    return (llvm::Instruction *)v11;
  }

  return sub_1CB844E0C((uint64_t *)a1, (llvm::Instruction *)v11, a3);
}

void llvm::UpgradeCallsToIntrinsic(llvm *this, llvm::Function *a2, llvm::Function **a3)
{
  BOOL v13 = 0;
  if (llvm::UpgradeIntrinsicFunction(this, (llvm::Function *)&v13, a3))
  {
    uint64_t v5 = *((void *)this + 1);
    if (v5)
    {
      int v6 = v13;
      do
      {
        uint64_t v7 = *(unsigned __int8 **)(v5 + 24);
        uint64_t v5 = *(void *)(v5 + 8);
        unsigned int v8 = v7[16];
        if (v8 >= 0x1C)
        {
          unsigned int v9 = v8 - 33;
          BOOL v10 = v9 > 0x33;
          uint64_t v11 = (1 << v9) & 0x8000000000041;
          if (!v10 && v11 != 0) {
            llvm::UpgradeIntrinsicCall((llvm *)v7, v6, v4);
          }
        }
      }
      while (v5);
    }
    llvm::Function::eraseFromParent(this);
  }
}

void llvm::UpgradeSectionAttributes(llvm *this, llvm::Module *a2)
{
  v36[10] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 8;
  uint64_t v3 = (char *)*((void *)this + 2);
  if (v3 != (char *)this + 8)
  {
    do
    {
      if (v3) {
        unint64_t v4 = (llvm::GlobalObject *)(v3 - 56);
      }
      else {
        unint64_t v4 = 0;
      }
      if ((*((unsigned char *)v4 + 34) & 0x40) != 0)
      {
        Sectionuint64_t Impl = llvm::GlobalObject::getSectionImpl(v4);
        if (v6 >= 0x16)
        {
          BOOL v7 = *(void *)SectionImpl == 0x202C415441445F5FLL && *((void *)SectionImpl + 1) == 0x635F636A626F5F5FLL;
          if (v7 && *(void *)((char *)SectionImpl + 14) == 0x7473696C7461635FLL)
          {
            v30[0] = SectionImpl;
            v30[1] = v6;
            unint64_t v34 = v36;
            uint64_t v35 = 0x500000000;
            llvm::StringRef::split((char *)v30, (uint64_t)&v34, 44, -1, 1);
            char v31 = v33;
            long long v32 = xmmword_1CDC7F9D0;
            int v22 = 0;
            char v26 = 0;
            uint64_t v27 = 0;
            uint64_t v21 = &unk_1F2646FA8;
            uint64_t v29 = &v31;
            int v28 = 0;
            unint64_t v24 = 0;
            uint64_t v25 = 0;
            uint64_t v23 = 0;
            if (v35)
            {
              unsigned int v9 = v34;
              uint64_t v10 = 16 * v35;
              do
              {
                *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *v9;
                uint64_t v11 = v25;
                if ((unint64_t)v25 >= v24)
                {
                  llvm::raw_ostream::write((llvm::raw_ostream *)&v21, 44);
                }
                else
                {
                  ++v25;
                  *uint64_t v11 = 44;
                }
                BOOL v13 = (const void *)sub_1CD5A69D0(&v20, " \t\n\v\f\r", 6);
                size_t v14 = v12;
                if (v12 <= v24 - (unint64_t)v25)
                {
                  if (v12)
                  {
                    memcpy(v25, v13, v12);
                    v25 += v14;
                  }
                }
                else
                {
                  llvm::raw_ostream::write((llvm::raw_ostream *)&v21, (const char *)v13, v12);
                }
                ++v9;
                v10 -= 16;
              }
              while (v10);
              unint64_t v16 = (const std::string::value_type *)*v29;
              __int16 v15 = v29[1];
            }
            else
            {
              __int16 v15 = 0;
              unint64_t v16 = v33;
            }
            if (v15) {
              std::string::size_type v17 = v16 + 1;
            }
            else {
              std::string::size_type v17 = v16;
            }
            std::string::__init(&v20, v17, (std::string::size_type)v15 - (v15 != 0));
            llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v21);
            if (v31 != v33) {
              free(v31);
            }
            if (v34 != v36) {
              free(v34);
            }
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v18 = &v20;
            }
            else {
              uint64_t v18 = (std::string *)v20.__r_.__value_.__r.__words[0];
            }
            if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              size_t size = *((unsigned char *)&v20.__r_.__value_.__s + 23) & 0x7F;
            }
            else {
              size_t size = v20.__r_.__value_.__l.__size_;
            }
            llvm::GlobalObject::setSection(v4, v18, size);
            if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v20.__r_.__value_.__l.__data_);
            }
          }
        }
      }
      uint64_t v3 = (char *)*((void *)v3 + 1);
    }
    while (v3 != v2);
  }
}

uint64_t llvm::UpgradeOperandBundles(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = (long long *)a1[1];
  if ((long long *)*a1 == v2)
  {
    uint64_t v2 = (long long *)*a1;
  }
  else
  {
    while (1)
    {
      uint64_t v5 = v3 + 48;
      if (sub_1CC535B50(v3)) {
        break;
      }
      v3 += 48;
      if ((long long *)v5 == v2)
      {
        uint64_t v3 = (uint64_t)v2;
        goto LABEL_3;
      }
    }
    if ((long long *)v5 != v2)
    {
      do
      {
        if (!sub_1CC535B50(v5))
        {
          if (*(char *)(v3 + 23) < 0) {
            operator delete(*(void **)v3);
          }
          long long v6 = *(_OWORD *)v5;
          *(void *)(v3 + 16) = *(void *)(v5 + 16);
          *(_OWORD *)uint64_t v3 = v6;
          *(unsigned char *)(v5 + 23) = 0;
          *(unsigned char *)uint64_t v5 = 0;
          sub_1CD46D2D8(v3 + 24, (__n128 *)(v5 + 24));
          v3 += 48;
        }
        v5 += 48;
      }
      while ((long long *)v5 != v2);
      uint64_t v2 = (long long *)a1[1];
    }
  }
LABEL_3:

  return sub_1CD5A6A60((uint64_t)a1, v3, v2);
}

uint64_t sub_1CD5A6908(uint64_t a1, const void *a2, uint64_t a3, const void *a4, uint64_t a5, const void *a6, uint64_t a7, char a8)
{
  uint64_t v13 = sub_1CC5310AC(a1, a2, a3, a8);
  uint64_t v14 = sub_1CC5310AC(v13, a4, a5, a8);

  return sub_1CC5310AC(v14, a6, a7, a8);
}

uint64_t sub_1CD5A697C(uint64_t a1, const void *a2, size_t a3)
{
  if (!*(unsigned char *)(a1 + 17) && *(void *)(a1 + 8) >= a3 && (!a3 || !memcmp(*(const void **)a1, a2, a3))) {
    *(_WORD *)(a1 + 16) = 257;
  }
  return a1;
}

uint64_t sub_1CD5A69D0(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t first_not_of = llvm::StringRef::find_first_not_of(a1, a2, a3, 0);
  unint64_t v7 = a1[1];
  if (first_not_of >= v7) {
    unint64_t v8 = a1[1];
  }
  else {
    unint64_t v8 = first_not_of;
  }
  v10[0] = *a1 + v8;
  v10[1] = v7 - v8;
  llvm::StringRef::find_last_not_of(v10, a2, a3, 0xFFFFFFFFFFFFFFFFLL);
  return v10[0];
}

uint64_t sub_1CD5A6A60(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    sub_1CC535AC8((uint64_t)&v9, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
        uint64_t v7 = sub_1CD4AF9B4(v7 - 48);
      while (v7 != v6);
    }
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v6;
  }
  return a2;
}

uint64_t llvm::BasicBlock::sizeWithoutDebug(llvm::BasicBlock *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  llvm::BasicBlock::instructionsWithoutDebug(this, 1, &v11);
  long long v14 = v11;
  if (v13)
  {
    if (v13 == &v12)
    {
      unint64_t v16 = v15;
      (*(void (**)(void))(*v13 + 24))();
    }
    else
    {
      unint64_t v16 = (void *)(*(uint64_t (**)(void))(*v13 + 16))();
    }
  }
  else
  {
    unint64_t v16 = 0;
  }
  llvm::BasicBlock::instructionsWithoutDebug(this, 1, v4);
  long long v8 = v5;
  if (v7)
  {
    if (v7 == &v6)
    {
      uint64_t v10 = v9;
      (*(void (**)(void))(*v7 + 24))();
    }
    else
    {
      uint64_t v10 = (void *)(*(uint64_t (**)(void))(*v7 + 16))();
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  uint64_t v2 = sub_1CC5373E4(&v14, &v8);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  sub_1CD484020(v4);
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void *))(*v16 + 40))(v16);
  }
  sub_1CD484020(&v11);
  return v2;
}

uint64_t sub_1CD5A6D50(void *a1, long long *a2, long long *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v12 = *a2;
  long long v5 = (long long *)*((void *)a2 + 5);
  if (v5)
  {
    if (v5 == a2 + 1)
    {
      long long v14 = v13;
      (*(void (**)(long long *, void *))(*(void *)v5 + 24))(v5, v13);
    }
    else
    {
      long long v14 = (void *)*((void *)a2 + 5);
      *((void *)a2 + 5) = 0;
    }
  }
  else
  {
    long long v14 = 0;
  }
  long long v9 = *a3;
  uint64_t v6 = (long long *)*((void *)a3 + 5);
  if (v6)
  {
    if (v6 == a3 + 1)
    {
      long long v11 = v10;
      (*(void (**)(long long *, void *))(*(void *)v6 + 24))(v6, v10);
    }
    else
    {
      long long v11 = (void *)*((void *)a3 + 5);
      *((void *)a3 + 5) = 0;
    }
  }
  else
  {
    long long v11 = 0;
  }
  sub_1CD5A6F48(a1, &v12, &v9);
  if (v11 == v10)
  {
    (*(void (**)(void *))(v10[0] + 32))(v10);
  }
  else if (v11)
  {
    (*(void (**)(void *, uint64_t))(*v11 + 40))(v11, v7);
  }
  uint64_t result = (uint64_t)v14;
  if (v14 == v13) {
    return (*(uint64_t (**)(void *))(v13[0] + 32))(v13);
  }
  if (v14) {
    return (*(uint64_t (**)(void *, uint64_t))(*v14 + 40))(v14, v7);
  }
  return result;
}

void *sub_1CD5A6F48(void *a1, void *a2, void *a3)
{
  *a1 = *a2;
  a1[1] = a2[1];
  long long v5 = (void *)a2[5];
  if (v5)
  {
    if (v5 == a2 + 2)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void, void *))(*(void *)a2[5] + 24))(a2[5], a1 + 2);
    }
    else
    {
      a1[5] = v5;
      a2[5] = 0;
    }
  }
  else
  {
    a1[5] = 0;
  }
  a1[6] = *a3;
  a1[7] = a3[1];
  uint64_t v6 = (void *)a3[5];
  if (v6)
  {
    if (v6 == a3 + 2)
    {
      a1[11] = a1 + 8;
      (*(void (**)(void))(*(void *)a3[5] + 24))(a3[5]);
    }
    else
    {
      a1[11] = v6;
      a3[5] = 0;
    }
  }
  else
  {
    a1[11] = 0;
  }
  return a1;
}

void *sub_1CD5A7044(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  sub_1CC539EC8((uint64_t)v8, a4);
  *a1 = a2;
  a1[1] = a3;
  if (v9)
  {
    if (v9 == v8)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void *))(v8[0] + 24))(v8);
    }
    else
    {
      a1[5] = (*(uint64_t (**)(void))(*v9 + 16))();
    }
  }
  else
  {
    a1[5] = 0;
  }
  sub_1CD48427C((uint64_t)a1);
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  return a1;
}

uint64_t llvm::Comdat::getName(llvm::Comdat *this)
{
  return *(void *)this + 72;
}

void *llvm::Comdat::addUser(uint64_t a1, uint64_t a2)
{
  return sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 16), a2);
}

void *llvm::Comdat::removeUser(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1CB896AE8(a1 + 16, a2);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = 32;
  if (v4 == *(void *)(a1 + 16)) {
    uint64_t v5 = 36;
  }
  if (result != (void *)(v4 + 8 * *(unsigned int *)(a1 + v5)))
  {
    void *result = -2;
    ++*(_DWORD *)(a1 + 40);
  }
  return result;
}

uint64_t llvm::ConstantRange::makeExactNoWrapRegion@<X0>(int a1@<W0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  unsigned int v9 = *(_DWORD *)(a2 + 8);
  if (v9 > 0x40) {
    operator new[]();
  }
  uint64_t v8 = *(void *)a2;
  llvm::ConstantRange::ConstantRange(v10, &v8);
  llvm::ConstantRange::makeGuaranteedNoWrapRegion((llvm::APInt *)v10, a1, a3, a4);
  uint64_t result = sub_1CC05EB8C((uint64_t)v10);
  if (v9 >= 0x41)
  {
    uint64_t result = v8;
    if (v8) {
      return MEMORY[0x1D25D9CB0](v8, 0x1000C8000313F17);
    }
  }
  return result;
}

BOOL llvm::ConstantRange::isUpperWrapped(llvm::ConstantRange *this)
{
  return (int)llvm::APInt::compare(this, (llvm::ConstantRange *)((char *)this + 16)) > 0;
}

BOOL llvm::ConstantRange::isSignWrappedSet(llvm::ConstantRange *this)
{
  uint64_t v1 = (char *)this + 16;
  return (int)llvm::APInt::compareSigned(this, (llvm::ConstantRange *)((char *)this + 16)) >= 1
      && !sub_1CB8C0D18((uint64_t)v1);
}

BOOL llvm::ConstantRange::isUpperSignWrapped(llvm::ConstantRange *this)
{
  return (int)llvm::APInt::compareSigned(this, (llvm::ConstantRange *)((char *)this + 16)) > 0;
}

llvm::raw_ostream *llvm::ConstantRange::print(llvm::ConstantRange *this, llvm::raw_ostream *a2)
{
  if (llvm::ConstantRange::isFullSet((const void **)this))
  {
    uint64_t v4 = "full-set";
  }
  else if (llvm::ConstantRange::isEmptySet((const void **)this))
  {
    uint64_t v4 = "empty-set";
  }
  else
  {
    uint64_t v6 = sub_1CB8E509C(a2, "[");
    llvm::APInt::print(this, v6, 1);
    a2 = sub_1CB8E509C(v6, ",");
    llvm::APInt::print((llvm::ConstantRange *)((char *)this + 16), a2, 1);
    uint64_t v4 = ")";
  }

  return sub_1CB8E509C(a2, v4);
}

llvm::raw_ostream *llvm::ConstantRange::dump(llvm::ConstantRange *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::ConstantRange::print(this, v2);
}

void *llvm::ConstantTokenNone::get(llvm::ConstantTokenNone *this, llvm::LLVMContext *a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void **)(*(void *)this + 2032);
  if (!v3)
  {
    uint64_t v3 = operator new(0x18uLL);
    *uint64_t v3 = llvm::Type::getTokenTy(this, v6);
    v3[1] = 0;
    v3[2] = 20;
    uint64_t v7 = *(llvm::Value **)(v2 + 2032);
    *(void *)(v2 + 2032) = v3;
    if (v7)
    {
      llvm::Value::~Value(v7);
      llvm::User::operator delete(v8);
      return *(void **)(v2 + 2032);
    }
  }
  return v3;
}

void *llvm::ConstantTargetNone::get(llvm::ConstantTargetNone *this, llvm::TargetExtType *a2)
{
  uint64_t v7 = this;
  uint64_t v3 = sub_1CD5A9FE4(**(void **)this + 1336, (uint64_t *)&v7);
  uint64_t result = (void *)v3[1];
  if (!result)
  {
    uint64_t result = operator new(0x18uLL);
    void *result = this;
    result[1] = 0;
    result[2] = 18;
    uint64_t v5 = (llvm::Value *)v3[1];
    v3[1] = result;
    if (v5)
    {
      llvm::Value::~Value(v5);
      llvm::User::operator delete(v6);
      return (void *)v3[1];
    }
  }
  return result;
}

uint64_t llvm::BlockAddress::destroyConstantImpl(llvm::BlockAddress *this)
{
  uint64_t v2 = ****((void ****)this - 8);
  uint64_t v3 = *((void *)this - 4);
  v6[0] = *((void *)this - 8);
  v6[1] = v3;
  uint64_t v7 = 0;
  uint64_t result = sub_1CD5AA3D8((uint64_t *)(v2 + 1440), v6, &v7);
  if (result)
  {
    uint64_t v5 = v7;
    *uint64_t v7 = -8192;
    v5[1] = -8192;
    *(int32x2_t *)(v2 + 144sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(v2 + 1448), (int32x2_t)0x1FFFFFFFFLL);
  }
  *(_WORD *)(*((void *)this - 4) + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(*((void *)this - 4) + 18) & 0x8000 | (*(_WORD *)(*((void *)this - 4) + 18)
                                                                                                - 1) & 0x7FFF;
  return result;
}

int32x2_t llvm::DSOLocalEquivalent::destroyConstantImpl(llvm::DSOLocalEquivalent *this)
{
  uint64_t v1 = (uint64_t ***)*((void *)this - 4);
  uint64_t v2 = ***v1;
  uint64_t v4 = 0;
  if (sub_1CD40EA84(*(void *)(v2 + 1464), *(_DWORD *)(v2 + 1480), (uint64_t)v1, &v4))
  {
    *uint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(v2 + 1472), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(v2 + 1472) = result;
  }
  return result;
}

int32x2_t llvm::NoCFIValue::destroyConstantImpl(llvm::NoCFIValue *this)
{
  uint64_t v1 = (uint64_t ***)*((void *)this - 4);
  uint64_t v2 = ***v1;
  uint64_t v4 = 0;
  if (sub_1CD40EA84(*(void *)(v2 + 1488), *(_DWORD *)(v2 + 1504), (uint64_t)v1, &v4))
  {
    *uint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(v2 + 1496), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(v2 + 1496) = result;
  }
  return result;
}

void llvm::UndefValue::destroyConstantImpl(llvm::UndefValue *this)
{
  if (*((unsigned char *)this + 16) == 11)
  {
    uint64_t v1 = *(void ***)this;
    uint64_t v2 = ***(void ***)this + 1360;
    uint64_t v3 = v1;
    sub_1CD5A8238(v2, &v3);
    __break(1u);
  }
  sub_1CD5A82A4(***(void ***)this + 1384, *(void *)this);
  __break(1u);
}

void llvm::ConstantDataSequential::destroyConstantImpl(llvm::Value **this)
{
  uint64_t v2 = **(void **)*this;
  RawDataValues = (unsigned __int8 *)llvm::ConstantDataSequential::getRawDataValues((llvm::ConstantDataSequential *)this);
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(v2 + 1408), RawDataValues, v4);
  if (Key == -1) {
    uint64_t v6 = *(unsigned int *)(v2 + 1416);
  }
  else {
    uint64_t v6 = Key;
  }
  uint64_t v7 = *(size_t **)(*(void *)(v2 + 1408) + 8 * v6);
  uint64_t v8 = (llvm::ConstantDataSequential **)(v7 + 1);
  if (*(void *)(v7[1] + 32))
  {
    do
    {
      unsigned int v9 = v8;
      uint64_t v10 = *v8;
      uint64_t v8 = (llvm::ConstantDataSequential **)((char *)*v8 + 32);
    }
    while (v10 != (llvm::ConstantDataSequential *)this);
    long long v11 = this[4];
    this[4] = 0;
    long long v12 = *v9;
    *unsigned int v9 = v11;
    if (v12)
    {
      sub_1CC5747CC(v12);
      llvm::User::operator delete(v13);
    }
  }
  else
  {
    llvm::StringMapImpl::RemoveKey((uint64_t *)(**(void **)*this + 1408), v7);
    sub_1CC5748CC((uint64_t)v7);
  }
}

BOOL llvm::Constant::needsDynamicRelocation(llvm::Constant *this)
{
  return llvm::Constant::getRelocationInfo(this) == 2;
}

llvm::Constant *llvm::Constant::replaceUndefsWith(llvm::Constant *this, llvm::Constant *a2, llvm::Constant *a3)
{
  unsigned char v16[32] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)this;
  if ((sub_1CC04BFB8((uint64_t)this) & 1) == 0)
  {
    if (*(unsigned char *)(v5 + 8) != 18 || v5 == 0)
    {
      return this;
    }
    else
    {
      unint64_t v8 = *(unsigned int *)(v5 + 32);
      long long v14 = v16;
      uint64_t v15 = 0x2000000000;
      sub_1CBFC6B20((uint64_t)&v14, v8, 0);
      if (v8)
      {
        for (std::string::size_type i = 0; i != (llvm::Type *)v8; std::string::size_type i = (llvm::Type *)((char *)i + 1))
        {
          AggregateElement = (llvm::Constant *)llvm::Constant::getAggregateElement(this, i);
          long long v11 = AggregateElement;
          if (!AggregateElement || (char v12 = sub_1CC04BFB8((uint64_t)AggregateElement), v13 = a2, (v12 & 1) == 0)) {
            uint64_t v13 = v11;
          }
          *((void *)v14 + i) = v13;
        }
      }
      a2 = llvm::ConstantVector::get((llvm::FixedVectorType ***)v14, (llvm::Type *)v15);
      if (v14 != v16) {
        free(v14);
      }
    }
  }
  return a2;
}

uint64_t llvm::Constant::isManifestConstant(llvm::Constant *this)
{
  unsigned int v2 = *((unsigned __int8 *)this + 16);
  uint64_t result = 1;
  if (v2 - 11 >= 0xA)
  {
    BOOL v4 = v2 > 0xA;
    int v5 = (1 << v2) & 0x720;
    if (v4 || v5 == 0)
    {
      return 0;
    }
    else
    {
      int v7 = *((_DWORD *)this + 5);
      if ((v7 & 0x40000000) != 0)
      {
        unsigned int v9 = (llvm::Constant **)*((void *)this - 1);
        uint64_t v8 = v7 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v8 = v7 & 0x7FFFFFF;
        unsigned int v9 = (llvm::Constant **)((char *)this - 32 * v8);
      }
      if (v8)
      {
        uint64_t v10 = 32 * v8 - 32;
        do
        {
          long long v11 = *v9;
          v9 += 4;
          uint64_t result = llvm::Constant::isManifestConstant(v11);
          if (result) {
            BOOL v12 = v10 == 0;
          }
          else {
            BOOL v12 = 1;
          }
          v10 -= 32;
        }
        while (!v12);
      }
    }
  }
  return result;
}

llvm::Value *llvm::ConstantInt::getBool(uint64_t **this, llvm::Type *a2, const llvm::APInt *a3)
{
  if (a2) {
    return llvm::ConstantInt::getTrue(this, a2, a3);
  }
  else {
    return llvm::ConstantInt::getFalse(this, a2, a3);
  }
}

const llvm::detail::DoubleAPFloat *llvm::ConstantFP::getQNaN(llvm::ConstantFP *this, llvm::Type *a2, const llvm::APInt *a3, llvm::APInt *a4)
{
  char v5 = (char)a2;
  uint64_t v6 = this;
  v12[3] = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)this + 2) & 0xFE) == 0x12) {
    this = (llvm::ConstantFP *)**((void **)this + 2);
  }
  FltSemantics = llvm::Type::getFltSemantics(this);
  sub_1CB87E68C((uint64_t)v12, (uint64_t)FltSemantics);
  sub_1CBFC6FE8((uint64_t)v11, 0, v5, a3);
  Splat = llvm::ConstantFP::get(*(llvm::ConstantFP **)v6, (llvm::LLVMContext *)v11, v8);
  if ((*((_DWORD *)v6 + 2) & 0xFE) == 0x12) {
    Splat = llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v6 + 8) | ((unint64_t)(*((_DWORD *)v6 + 2) == 19) << 32)), (uint64_t)Splat);
  }
  sub_1CB87DEE4(v12);
  return Splat;
}

llvm::Value *llvm::ConstantFP::getInfinity(llvm::ConstantFP *this, llvm::Type *a2)
{
  int v2 = (int)a2;
  uint64_t v3 = this;
  void v10[3] = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)this + 2) & 0xFE) == 0x12) {
    this = (llvm::ConstantFP *)**((void **)this + 2);
  }
  FltSemantics = llvm::Type::getFltSemantics(this);
  char v5 = *(llvm::ConstantFP **)v3;
  sub_1CB87E68C((uint64_t)v10, (uint64_t)FltSemantics);
  sub_1CB87E790((uint64_t)v9, v2);
  int v7 = llvm::ConstantFP::get(v5, (llvm::LLVMContext *)v9, v6);
  sub_1CB87DEE4(v10);
  if ((*((_DWORD *)v3 + 2) & 0xFE) == 0x12) {
    return llvm::ConstantVector::getSplat((llvm::Type *)(*((unsigned int *)v3 + 8) | ((unint64_t)(*((_DWORD *)v3 + 2) == 19) << 32)), (uint64_t)v7);
  }
  return v7;
}

uint64_t llvm::ConstantStruct::getTypeForElements(uint64_t *a1, uint64_t a2, unsigned int a3, int a4)
{
  v13[16] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a3;
  long long v11 = v13;
  uint64_t v12 = 0x1000000000;
  sub_1CB90CB08((uint64_t)&v11, a3, 0);
  if (v7)
  {
    uint64_t v8 = 0;
    do
    {
      *(void *)((char *)v11 + vsub_1CD521E44((uint64_t)this + 8) = **(void **)(a2 + v8);
      v8 += 8;
    }
    while (8 * v7 != v8);
  }
  uint64_t v9 = llvm::StructType::get(a1, (uint64_t)v11, v12, a4);
  if (v11 != v13) {
    free(v11);
  }
  return v9;
}

uint64_t llvm::ConstantStruct::getTypeForElements(uint64_t ****a1, unsigned int a2, int a3)
{
  return llvm::ConstantStruct::getTypeForElements(***a1, (uint64_t)a1, a2, a3);
}

uint64_t llvm::ConstantExpr::getIndices(llvm::ConstantExpr *this)
{
  return *((void *)this + 3);
}

uint64_t llvm::ConstantExpr::getShuffleMask(llvm::ConstantExpr *this)
{
  return *((void *)this + 3);
}

uint64_t llvm::ConstantExpr::getShuffleMaskForBitcode(llvm::ConstantExpr *this)
{
  return *((void *)this + 7);
}

uint64_t llvm::ConstantInt::isValueValidForType(llvm::ConstantInt *this, llvm::Type *a2)
{
  unint64_t v2 = *((unsigned int *)this + 2);
  unint64_t v3 = v2 >> 8;
  BOOL v7 = (v2 & 0xFFFFC000) == 0;
  unint64_t v4 = 0xFFFFFFFFFFFFFFFFLL >> -(uint64_t)(v2 >> 8);
  unsigned int v6 = !v7 || v4 >= (unint64_t)a2;
  BOOL v7 = *((_DWORD *)this + 2) == 13 && v3 == 1;
  if (v7) {
    return (unint64_t)a2 < 2;
  }
  else {
    return v6;
  }
}

BOOL llvm::ConstantInt::isValueValidForType(llvm::ConstantInt *this, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)this + 2);
  if (v2 == 13 && *((_DWORD *)this + 2) >> 8 == 1) {
    return (unint64_t)(a2 + 1) < 3;
  }
  if (v2 >> 14) {
    return 1;
  }
  uint64_t v5 = -1 << (BYTE1(v2) - 1);
  return v5 <= a2 && ~v5 >= a2;
}

uint64_t llvm::ConstantFP::isValueValidForType(llvm::ConstantFP *this, llvm::Type *a2, const llvm::APFloat *a3)
{
  v25[3] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (llvm::APFloatBase *)sub_1CB87DDC4((uint64_t)v25, (uint64_t *)a2 + 1);
  char v23 = 0;
  switch(*((unsigned char *)this + 8))
  {
    case 0:
      if ((_UNKNOWN *)v25[0] == &unk_1CFB2E2E0) {
        goto LABEL_48;
      }
      uint64_t v5 = &unk_1CFB2E2E0;
      goto LABEL_31;
    case 1:
      if ((_UNKNOWN *)v25[0] == &unk_1CFB2E2F4) {
        goto LABEL_48;
      }
      uint64_t v5 = &unk_1CFB2E2F4;
      goto LABEL_31;
    case 2:
      if ((_UNKNOWN *)v25[0] == &unk_1CFB2E308) {
        goto LABEL_48;
      }
      uint64_t v5 = &unk_1CFB2E308;
      goto LABEL_31;
    case 3:
      if ((_UNKNOWN *)v25[0] == &unk_1CFB2E31C
        || v25[0] == (void)&unk_1CFB2E308
        || v25[0] == (void)&unk_1CFB2E2E0
        || v25[0] == (void)&unk_1CFB2E2F4)
      {
        goto LABEL_48;
      }
      uint64_t v5 = &unk_1CFB2E31C;
LABEL_31:
      llvm::APFloat::convert((uint64_t)v24, v5, 1, &v23);
      BOOL v15 = v23 == 0;
      goto LABEL_32;
    case 4:
      uint64_t v10 = v25[0];
      if ((_UNKNOWN *)v25[0] == &unk_1CFB2E31C
        || v25[0] == (void)&unk_1CFB2E308
        || v25[0] == (void)&unk_1CFB2E2E0
        || v25[0] == (void)&unk_1CFB2E2F4)
      {
        goto LABEL_48;
      }
      long long v14 = llvm::APFloatBase::x87DoubleExtended(v4);
      goto LABEL_47;
    case 5:
      uint64_t v10 = v25[0];
      if ((_UNKNOWN *)v25[0] == &unk_1CFB2E31C
        || v25[0] == (void)&unk_1CFB2E308
        || v25[0] == (void)&unk_1CFB2E2E0
        || v25[0] == (void)&unk_1CFB2E2F4)
      {
LABEL_48:
        uint64_t v6 = 1;
      }
      else
      {
        long long v14 = llvm::APFloatBase::IEEEquad(v4);
LABEL_47:
        BOOL v15 = v10 == (void)v14;
LABEL_32:
        uint64_t v6 = v15;
      }
LABEL_35:
      sub_1CB87DEE4(v25);
      return v6;
    case 6:
      BOOL v15 = (_UNKNOWN *)v25[0] == &unk_1CFB2E2E0
         || v25[0] == (void)&unk_1CFB2E2F4
         || v25[0] == (void)&unk_1CFB2E308
         || v25[0] == (void)&unk_1CFB2E31C
         || v25[0] == (void)&unk_1CFB2E344;
      goto LABEL_32;
    default:
      uint64_t v6 = 0;
      goto LABEL_35;
  }
}

int32x2_t sub_1CD5A8068(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CC1DE178(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    unint64_t v4 = (void *)v7;
    uint64_t v5 = *(llvm::Value **)(v7 + 8);
    *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0;
    if (v5)
    {
      llvm::Value::~Value(v5);
      llvm::User::operator delete(v6);
    }
    *unint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD5A80E0(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = a2;
  uint64_t v6 = 0;
  if (sub_1CD5A9E50(*(void *)a1, *(_DWORD *)(a1 + 16), &v5, &v6)) {
    unint64_t v3 = v6;
  }
  else {
    unint64_t v3 = (uint64_t **)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 16));
  }
  *unint64_t v3 = (uint64_t *)-8192;
  int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  return result;
}

int32x2_t sub_1CD5A8154(uint64_t a1, void *a2)
{
  uint64_t v7 = 0;
  if (sub_1CC5734E0((uint64_t *)a1, a2, &v7))
  {
    unint64_t v4 = (void *)v7;
    uint64_t v5 = *(llvm::Value **)(v7 + 8);
    *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0;
    if (v5)
    {
      llvm::Value::~Value(v5);
      llvm::User::operator delete(v6);
    }
    *unint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD5A81C0(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    unint64_t v4 = (void *)v7;
    uint64_t v5 = *(llvm::Value **)(v7 + 8);
    *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0;
    if (v5)
    {
      llvm::Value::~Value(v5);
      llvm::User::operator delete(v6);
    }
    *unint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD5A8238(uint64_t a1, void *a2)
{
  uint64_t v7 = 0;
  if (sub_1CB915048((uint64_t *)a1, a2, &v7))
  {
    unint64_t v4 = (void *)v7;
    uint64_t v5 = *(llvm::Value **)(v7 + 8);
    *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0;
    if (v5)
    {
      llvm::Value::~Value(v5);
      llvm::User::operator delete(v6);
    }
    *unint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD5A82A4(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CC152E2C(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    unint64_t v4 = (void *)v7;
    uint64_t v5 = *(llvm::Value **)(v7 + 8);
    *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0;
    if (v5)
    {
      llvm::Value::~Value(v5);
      llvm::User::operator delete(v6);
    }
    *unint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

llvm::BlockAddress *llvm::BlockAddress::get(llvm::BlockAddress **this, llvm::BasicBlock *a2, llvm::BasicBlock *a3)
{
  return llvm::BlockAddress::get(this[7], (llvm::Function *)this, a3);
}

llvm::BlockAddress *llvm::BlockAddress::get(llvm::BlockAddress *this, llvm::Function *a2, llvm::BasicBlock *a3)
{
  uint64_t v5 = (uint64_t *)(*(void *)llvm::Function::getContext(this) + 1440);
  v9[0] = this;
  v9[1] = a2;
  uint64_t v6 = sub_1CD5AA370(v5, v9);
  int32x2_t result = (llvm::BlockAddress *)v6[2];
  if (!result)
  {
    uint64_t v8 = operator new(0x58uLL);
    v8[21] = v8[21] & 0x38000000 | 2;
    *(void *)uint64_t v8 = 0;
    *((void *)v8 + 1) = 0;
    *((void *)v8 + 2) = 0;
    *((void *)v8 + 3) = v8 + 16;
    *((void *)v8 + 4) = 0;
    *((void *)v8 + 5) = 0;
    *((void *)v8 + 6) = 0;
    *((void *)v8 + 7) = v8 + 16;
    int32x2_t result = llvm::BlockAddress::BlockAddress((llvm::BlockAddress *)(v8 + 16), this, a2);
    void v6[2] = result;
  }
  return result;
}

llvm::BlockAddress *llvm::BlockAddress::BlockAddress(llvm::BlockAddress *this, llvm::Function *a2, llvm::BasicBlock *a3)
{
  Context = (llvm::Type *)llvm::Function::getContext(a2);
  AddressSpace = (llvm::LLVMContext *)llvm::GlobalValue::getAddressSpace(a2);
  *(void *)this = llvm::Type::getInt8PtrTy(Context, AddressSpace);
  *((void *)this + 1) = 0;
  unsigned int v8 = *((_DWORD *)this + 5) & 0xC0000000 | 2;
  *((_DWORD *)this + 4) = 4;
  *((_DWORD *)this + 5) = v8;
  uint64_t v9 = (void *)((char *)this - 64);
  if (*((void *)this - 8))
  {
    **((void **)this - 6) = *((void *)this - 7);
    uint64_t v10 = *((void *)this - 7);
    if (v10) {
      *(void *)(v10 + 16) = *((void *)this - 6);
    }
  }
  *uint64_t v9 = a2;
  if (a2)
  {
    uint64_t v13 = *((void *)a2 + 1);
    uint64_t v12 = (void *)((char *)a2 + 8);
    uint64_t v11 = v13;
    *((void *)this - 7) = v13;
    if (v13) {
      *(void *)(v11 + 16) = (char *)this - 56;
    }
    *((void *)this - 6) = v12;
    *uint64_t v12 = v9;
  }
  long long v14 = (void *)((char *)this - 32);
  if (*((void *)this - 4))
  {
    **((void **)this - 2) = *((void *)this - 3);
    uint64_t v15 = *((void *)this - 3);
    if (v15) {
      *(void *)(v15 + 16) = *((void *)this - 2);
    }
  }
  *long long v14 = a3;
  if (a3)
  {
    unint64_t v16 = (void *)((char *)a3 + 8);
    uint64_t v17 = *((void *)a3 + 1);
    *((void *)this - 3) = v17;
    if (v17) {
      *(void *)(v17 + 16) = (char *)this - 24;
    }
    *((void *)this - 2) = v16;
    *unint64_t v16 = v14;
  }
  *((_WORD *)a3 + 9) = *((_WORD *)a3 + 9) & 0x8000 | (*((_WORD *)a3 + 9) + 1) & 0x7FFF;
  return this;
}

uint64_t llvm::BlockAddress::handleOperandChangeImpl(uint64_t ***this, llvm::Value *a2, llvm::Value *a3)
{
  unint64_t v3 = a3;
  uint64_t v6 = (llvm::Value **)(this - 8);
  uint64_t v5 = (llvm::Value *)*(this - 8);
  uint64_t v7 = (llvm::Value **)(this - 4);
  if (v5 == a2)
  {
    unsigned int v8 = *v7;
    uint64_t v5 = llvm::Value::stripPointerCasts(a3);
    unint64_t v3 = v8;
  }
  uint64_t v9 = (uint64_t *)(***this + 1440);
  uint64_t v25 = v5;
  char v26 = v3;
  uint64_t v10 = sub_1CD5AA370(v9, &v25);
  uint64_t v11 = v10[2];
  if (!v11)
  {
    uint64_t v13 = v10;
    long long v14 = (llvm::Value *)*(this - 4);
    *((_WORD *)v14 + 9) = *((_WORD *)v14 + 9) & 0x8000 | (*((_WORD *)v14 + 9) - 1) & 0x7FFF;
    uint64_t v15 = ***this;
    uint64_t v25 = (llvm::Value *)*(this - 8);
    char v26 = v14;
    uint64_t v27 = 0;
    if (sub_1CD5AA3D8((uint64_t *)(v15 + 1440), &v25, &v27))
    {
      unint64_t v16 = v27;
      *uint64_t v27 = -8192;
      v16[1] = -8192;
      *(int32x2_t *)(v15 + 144sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(v15 + 1448), (int32x2_t)0x1FFFFFFFFLL);
    }
    uint64_t v13[2] = this;
    if (*(this - 8))
    {
      **(this - 6) = (uint64_t *)*(this - 7);
      uint64_t v17 = (uint64_t)*(this - 7);
      if (v17) {
        *(void *)(v17 + 16) = *(this - 6);
      }
    }
    *uint64_t v6 = v5;
    if (v5)
    {
      std::string v20 = (uint64_t **)*((void *)v5 + 1);
      uint64_t v19 = (llvm::Value ***)((char *)v5 + 8);
      uint64_t v18 = v20;
      *(this - 7) = v20;
      if (v20) {
        v18[2] = (uint64_t *)(this - 7);
      }
      *(this - 6) = (uint64_t **)v19;
      *uint64_t v19 = v6;
    }
    if (*v7)
    {
      **(this - 2) = (uint64_t *)*(this - 3);
      uint64_t v21 = (uint64_t)*(this - 3);
      if (v21) {
        *(void *)(v21 + 16) = *(this - 2);
      }
    }
    *(this - 4) = (uint64_t **)v3;
    unint64_t v24 = (uint64_t **)*((void *)v3 + 1);
    char v23 = (llvm::Value ***)((char *)v3 + 8);
    int v22 = v24;
    *(this - 3) = v24;
    if (v24) {
      v22[2] = (uint64_t *)(this - 3);
    }
    *(this - 2) = (uint64_t **)v23;
    *char v23 = v7;
    *((_WORD *)*(this - 4) + 9) = *((_WORD *)*(this - 4) + 9) & 0x8000 | (*((_WORD *)*(this - 4) + 9) + 1) & 0x7FFF;
  }
  return v11;
}

uint64_t llvm::DSOLocalEquivalent::get(llvm::DSOLocalEquivalent *this, llvm::GlobalValue *a2)
{
  uint64_t v5 = this;
  unsigned int v2 = sub_1CD467E2C(***(void ***)this + 1464, (uint64_t *)&v5);
  uint64_t result = v2[1];
  if (!result)
  {
    unint64_t v4 = operator new(0x38uLL);
    v4[13] = v4[13] & 0x38000000 | 1;
    *(void *)unint64_t v4 = 0;
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 3) = v4 + 8;
    uint64_t result = llvm::DSOLocalEquivalent::DSOLocalEquivalent((uint64_t)(v4 + 8), v5);
    v2[1] = result;
  }
  return result;
}

uint64_t llvm::DSOLocalEquivalent::DSOLocalEquivalent(uint64_t this, llvm::GlobalValue *a2)
{
  *(void *)this = *(void *)a2;
  *(void *)(this + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v2 = *(_DWORD *)(this + 20) & 0xC0000000 | 1;
  *(_DWORD *)(this + 16) = 6;
  *(_DWORD *)(this + 2llvm::MDNode::dumpTree(this, 0) = v2;
  if (*(void *)(this - 32))
  {
    **(void **)(this - 16) = *(void *)(this - 24);
    uint64_t v3 = *(void *)(this - 24);
    if (v3) {
      *(void *)(v3 + 16) = *(void *)(this - 16);
    }
  }
  *(void *)(this - 32) = a2;
  uint64_t v6 = *((void *)a2 + 1);
  unint64_t v4 = (void *)((char *)a2 + 8);
  uint64_t v5 = v6;
  *(void *)(this - 24) = v6;
  if (v6) {
    *(void *)(v5 + 16) = this - 24;
  }
  *(void *)(this - 16) = v4;
  *unint64_t v4 = this - 32;
  return this;
}

llvm::detail::IEEEFloat *llvm::DSOLocalEquivalent::handleOperandChangeImpl(llvm::Constant **this, llvm::Value *a2, llvm::Value *a3)
{
  uint64_t v3 = a3;
  if (*((unsigned __int8 *)a3 + 16) >= 4u) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = a3;
  }
  uint64_t v19 = v5;
  if (v5 && (uint64_t v7 = (llvm::detail::IEEEFloat *)sub_1CD467E2C(**(void **)*this + 1464, (uint64_t *)&v19)[1]) != 0)
  {
    if (*(llvm::Constant **)v7 != *this) {
      return sub_1CC56C0C0((llvm *)0x31, v7, *this, 0);
    }
    return v7;
  }
  else if ((llvm::Constant::isNullValue(v3) & 1) == 0)
  {
    unsigned int v8 = llvm::Value::stripPointerCastsAndAliases(v3);
    uint64_t v9 = **(void **)*this + 1464;
    uint64_t v19 = v8;
    uint64_t v10 = sub_1CD467E2C(v9, (uint64_t *)&v19);
    uint64_t v3 = (llvm::Value *)v10[1];
    uint64_t v11 = *this;
    if (v3)
    {
      if (*(llvm::Constant **)v3 != v11) {
        return sub_1CC56C0C0((llvm *)0x31, v3, v11, 0);
      }
    }
    else
    {
      uint64_t v12 = v10;
      uint64_t v13 = **(void **)v11;
      uint64_t v15 = this - 4;
      uint64_t v14 = (uint64_t)*(this - 4);
      uint64_t v19 = 0;
      if (sub_1CD40EA84(*(void *)(v13 + 1464), *(_DWORD *)(v13 + 1480), v14, &v19))
      {
        *(void *)uint64_t v19 = -8192;
        *(int32x2_t *)(v13 + 1472) = vadd_s32(*(int32x2_t *)(v13 + 1472), (int32x2_t)0x1FFFFFFFFLL);
      }
      v12[1] = this;
      if (*(this - 4))
      {
        *(void *)*(this - 2) = *(this - 3);
        uint64_t v16 = (uint64_t)*(this - 3);
        if (v16) {
          *(void *)(v16 + 16) = *(this - 2);
        }
      }
      *uint64_t v15 = v8;
      if (v8)
      {
        uint64_t v17 = (llvm::Value *)((char *)v8 + 8);
        uint64_t v18 = (llvm::Constant *)*((void *)v8 + 1);
        *(this - 3) = v18;
        if (v18) {
          *((void *)v18 + 2) = this - 3;
        }
        *(this - 2) = v17;
        *(void *)uint64_t v17 = v15;
      }
      uint64_t v3 = 0;
      if (*(llvm::Constant **)v8 != *this) {
        *this = *(llvm::Constant **)v8;
      }
    }
  }
  return v3;
}

uint64_t llvm::NoCFIValue::get(llvm::NoCFIValue *this, llvm::GlobalValue *a2)
{
  uint64_t v5 = this;
  unsigned int v2 = sub_1CD467E2C(***(void ***)this + 1488, (uint64_t *)&v5);
  uint64_t result = v2[1];
  if (!result)
  {
    unint64_t v4 = operator new(0x38uLL);
    v4[13] = v4[13] & 0x38000000 | 1;
    *(void *)unint64_t v4 = 0;
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 3) = v4 + 8;
    uint64_t result = llvm::NoCFIValue::NoCFIValue((uint64_t)(v4 + 8), v5);
    v2[1] = result;
  }
  return result;
}

uint64_t llvm::NoCFIValue::NoCFIValue(uint64_t this, llvm::GlobalValue *a2)
{
  *(void *)this = *(void *)a2;
  *(void *)(this + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v2 = *(_DWORD *)(this + 20) & 0xC0000000 | 1;
  *(_DWORD *)(this + 16) = 7;
  *(_DWORD *)(this + 2llvm::MDNode::dumpTree(this, 0) = v2;
  if (*(void *)(this - 32))
  {
    **(void **)(this - 16) = *(void *)(this - 24);
    uint64_t v3 = *(void *)(this - 24);
    if (v3) {
      *(void *)(v3 + 16) = *(void *)(this - 16);
    }
  }
  *(void *)(this - 32) = a2;
  uint64_t v6 = *((void *)a2 + 1);
  unint64_t v4 = (void *)((char *)a2 + 8);
  uint64_t v5 = v6;
  *(void *)(this - 24) = v6;
  if (v6) {
    *(void *)(v5 + 16) = this - 24;
  }
  *(void *)(this - 16) = v4;
  *unint64_t v4 = this - 32;
  return this;
}

llvm::detail::IEEEFloat *llvm::NoCFIValue::handleOperandChangeImpl(llvm::Constant **this, llvm::Value *a2, llvm::Value *a3)
{
  unint64_t v4 = llvm::Value::stripPointerCasts(a3);
  if (*((unsigned __int8 *)v4 + 16) >= 4u) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v19 = v5;
  uint64_t v6 = sub_1CD467E2C(**(void **)*this + 1488, (uint64_t *)&v19);
  uint64_t v7 = (llvm::detail::IEEEFloat *)v6[1];
  unsigned int v8 = *this;
  if (v7)
  {
    if (*(llvm::Constant **)v7 != v8) {
      return sub_1CC56C0C0((llvm *)0x31, v7, v8, 0);
    }
  }
  else
  {
    uint64_t v10 = v6;
    uint64_t v11 = **(void **)v8;
    uint64_t v13 = this - 4;
    uint64_t v12 = (uint64_t)*(this - 4);
    std::string v20 = 0;
    if (sub_1CD40EA84(*(void *)(v11 + 1488), *(_DWORD *)(v11 + 1504), v12, &v20))
    {
      *std::string v20 = -8192;
      *(int32x2_t *)(v11 + 1496) = vadd_s32(*(int32x2_t *)(v11 + 1496), (int32x2_t)0x1FFFFFFFFLL);
    }
    v10[1] = this;
    uint64_t v14 = v19;
    if (*(this - 4))
    {
      *(void *)*(this - 2) = *(this - 3);
      uint64_t v15 = (uint64_t)*(this - 3);
      if (v15) {
        *(void *)(v15 + 16) = *(this - 2);
      }
    }
    *uint64_t v13 = v14;
    if (v14)
    {
      uint64_t v18 = (llvm::Constant *)*((void *)v14 + 1);
      uint64_t v16 = (llvm::Value *)((char *)v14 + 8);
      uint64_t v17 = v18;
      *(this - 3) = v18;
      if (v18) {
        *((void *)v17 + 2) = this - 3;
      }
      *(this - 2) = v16;
      *(void *)uint64_t v16 = v13;
    }
    uint64_t v7 = 0;
    if (*(llvm::Constant **)v19 != *this) {
      *this = *(llvm::Constant **)v19;
    }
  }
  return v7;
}

llvm::detail::IEEEFloat *llvm::ConstantExpr::getTruncOrBitCast(llvm::Type **this, llvm::Type ***a2, llvm::Type *a3)
{
  uint64_t v5 = *this;
  if ((*((_DWORD *)*this + 2) & 0xFE) == 0x12) {
    uint64_t v6 = (llvm::Type *)**((void **)v5 + 2);
  }
  else {
    uint64_t v6 = *this;
  }
  Primitiveunint64_t SizeInBits = llvm::Type::getPrimitiveSizeInBits(v6);
  unsigned int v8 = (llvm::Type *)a2;
  if ((a2[1] & 0xFE) == 0x12) {
    unsigned int v8 = *a2[2];
  }
  if (PrimitiveSizeInBits == llvm::Type::getPrimitiveSizeInBits(v8))
  {
    if (v5 == (llvm::Type *)a2) {
      return (llvm::detail::IEEEFloat *)this;
    }
    uint64_t v9 = 49;
  }
  else
  {
    uint64_t v9 = 38;
  }

  return sub_1CC56C0C0((llvm *)v9, (llvm::detail::IEEEFloat *)this, (llvm::Constant *)a2, 0);
}

llvm::ConstantExpr *llvm::ConstantExpr::getFPCast(llvm::ConstantExpr *this, llvm::Type ***a2, llvm::Type *a3)
{
  uint64_t v5 = *(void *)this;
  if ((*(_DWORD *)(v5 + 8) & 0xFE) == 0x12) {
    uint64_t v5 = **(void **)(v5 + 16);
  }
  Primitiveunint64_t SizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v5);
  uint64_t v7 = (llvm::Type *)a2;
  if ((a2[1] & 0xFE) == 0x12) {
    uint64_t v7 = *a2[2];
  }
  unsigned int v8 = llvm::Type::getPrimitiveSizeInBits(v7);
  if (PrimitiveSizeInBits == v8) {
    return this;
  }
  if (PrimitiveSizeInBits > v8) {
    uint64_t v10 = 45;
  }
  else {
    uint64_t v10 = 46;
  }

  return llvm::ConstantExpr::getCast((llvm::ConstantExpr *)v10, this, a2, 0);
}

llvm::detail::IEEEFloat *llvm::ConstantExpr::getSizeOf(llvm::ConstantExpr *this, llvm::Type *a2)
{
  uint64_t v3 = llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)this + 1960), 1uLL, 0);
  unint64_t v4 = (llvm::Constant *)llvm::PointerType::get(this, 0);
  NullValue = (uint64_t *)llvm::Constant::getNullValue(v4, v5, v6);
  uint64_t v10 = v3;
  ElementPtr = (llvm::detail::IEEEFloat *)llvm::ConstantExpr::getGetElementPtr((uint64_t)this, NullValue, (uint64_t)&v10, 1, 0, 0, 0);
  return sub_1CC56C0C0((llvm *)0x2F, ElementPtr, (llvm::Constant *)(**(void **)this + 1984), 0);
}

const llvm::detail::DoubleAPFloat *llvm::ConstantExpr::getFRem(llvm::ConstantExpr *this, llvm::Constant *a2, llvm::Constant *a3, uint64_t a4, uint64_t a5, llvm::Type *a6)
{
  return llvm::ConstantExpr::get((llvm::ConstantExpr *)0x18, this, a2, 0, 0, a6);
}

llvm::Constant *llvm::ConstantExpr::getUMin(llvm::ConstantExpr *this, llvm::Constant *a2, llvm::Constant *a3, uint64_t a4, BOOL a5)
{
  ICmp = (llvm::ConstantExpr *)llvm::ConstantExpr::getICmp((llvm::ConstantExpr *)0x24, this, a2, 0, a5);

  return llvm::ConstantExpr::getSelect(ICmp, (llvm::PoisonValue **)this, a2, 0, v8);
}

const llvm::detail::DoubleAPFloat *llvm::ConstantExpr::getAShr(llvm::ConstantExpr *this, llvm::Constant *a2, llvm::Constant *a3, BOOL a4, uint64_t a5, llvm::Type *a6)
{
  return llvm::ConstantExpr::get((llvm::ConstantExpr *)0x1B, this, a2, a3, 0, a6);
}

float llvm::ConstantDataSequential::getElementAsFloat(llvm::ConstantDataSequential *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 3);
  return *(float *)(v2 + llvm::ConstantDataSequential::getElementByteSize(this) * a2);
}

double llvm::ConstantDataSequential::getElementAsDouble(llvm::ConstantDataSequential *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 3);
  return *(double *)(v2 + llvm::ConstantDataSequential::getElementByteSize(this) * a2);
}

BOOL llvm::ConstantDataSequential::isCString(llvm::ConstantDataSequential *this)
{
  if (*(unsigned char *)(*(void *)this + 8) != 17) {
    return 0;
  }
  if (*(_DWORD *)(*(void *)(*(void *)this + 24) + 8) != 2061) {
    return 0;
  }
  RawDataValues = (unsigned char *)llvm::ConstantDataSequential::getRawDataValues(this);
  if (RawDataValues[v2 - 1]) {
    return 0;
  }
  if (v2 >= v2 - 1) {
    size_t v4 = v2 - 1;
  }
  else {
    size_t v4 = v2;
  }
  if (v4 && (v5 = RawDataValues, (uint64_t v6 = memchr(RawDataValues, 0, v4)) != 0)) {
    uint64_t v7 = v6 - v5;
  }
  else {
    uint64_t v7 = -1;
  }
  return v7 == -1;
}

void llvm::Constant::handleOperandChange(uint64_t ***this, llvm::Value *a2, llvm::Value *a3)
{
  if (*((unsigned char *)this + 16) != 8)
  {
    switch(*((unsigned char *)this + 16))
    {
      case 4:
        size_t v4 = (llvm::Value *)llvm::BlockAddress::handleOperandChangeImpl(this, a2, a3);
        goto LABEL_3;
      case 5:
        size_t v4 = llvm::ConstantExpr::handleOperandChangeImpl((llvm::ConstantExpr *)this, a2, a3);
        goto LABEL_3;
      case 6:
        size_t v4 = llvm::DSOLocalEquivalent::handleOperandChangeImpl((llvm::Constant **)this, a2, a3);
        goto LABEL_3;
      case 7:
        size_t v4 = llvm::NoCFIValue::handleOperandChangeImpl((llvm::Constant **)this, a2, a3);
        goto LABEL_3;
      case 8:
        __break(1u);
        return;
      case 9:
        size_t v4 = (llvm::Value *)llvm::ConstantStruct::handleOperandChangeImpl((llvm::ConstantStruct *)this, a2, a3);
        goto LABEL_3;
      case 0xA:
        size_t v4 = llvm::ConstantVector::handleOperandChangeImpl((llvm::ConstantVector *)this, a2, (llvm::FixedVectorType **)a3);
        goto LABEL_3;
      default:
        llvm::GlobalValue::handleOperandChangeImpl((llvm::GlobalValue *)this, a2, a3);
    }
  }
  size_t v4 = llvm::ConstantArray::handleOperandChangeImpl((llvm::ConstantArray *)this, a2, a3);
LABEL_3:
  if (v4)
  {
    llvm::Value::replaceAllUsesWith((llvm::Value *)this, v4);
    llvm::Constant::destroyConstant((int32x2_t ****)this, v5);
  }
}

llvm::ConstantExpr *llvm::ConstantExpr::handleOperandChangeImpl(llvm::ConstantExpr *this, llvm::Value *a2, llvm::Value *a3)
{
  v16[8] = *(llvm::ConstantExpr **)MEMORY[0x1E4F143B8];
  unsigned int v15 = 0;
  int v6 = *((_DWORD *)this + 5);
  if ((v6 & 0x7FFFFFF) != 0)
  {
    LODWORD(v7) = 0;
    uint64_t v8 = 0;
    unsigned int v9 = 0;
    int v10 = 0;
    uint64_t v11 = this;
    do
    {
      if (*((llvm::Value **)v11 - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF)) == a2)
      {
        ++v10;
        unsigned int v9 = v8;
        uint64_t v12 = a3;
      }
      else
      {
        uint64_t v12 = (llvm::ConstantExpr *)*((void *)v11 - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
      }
      if (v7 >= 8) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v16[v7] = v12;
      uint64_t v7 = ++v15;
      ++v8;
      uint64_t v11 = (llvm::ConstantExpr *)((char *)v11 + 32);
    }
    while ((v6 & 0x7FFFFFF) != v8);
  }
  else
  {
    uint64_t v7 = 0;
    int v10 = 0;
    unsigned int v9 = 0;
  }
  uint64_t v13 = llvm::ConstantExpr::getWithOperands(this, v16, v7, *(llvm::Constant ****)this, (llvm::Type *)1, 0);
  if (!v13) {
    return (llvm::ConstantExpr *)sub_1CD5A9BC8(***(void ***)this + 1512, (uint64_t)v16, v15, (uint64_t)this, (uint64_t)a2, (uint64_t)a3, v10, v9);
  }
  return v13;
}

llvm::Value *llvm::ConstantArray::handleOperandChangeImpl(llvm::ConstantArray *this, llvm::Value *a2, llvm::Value *a3)
{
  v19[8] = *MEMORY[0x1E4F143B8];
  unsigned int v18 = 0;
  int v6 = *((_DWORD *)this + 5);
  if ((v6 & 0x7FFFFFFu) >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if ((v6 & 0x40000000) != 0)
  {
    uint64_t v8 = (llvm::Value **)*((void *)this - 1);
    uint64_t v7 = v6 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v7 = v6 & 0x7FFFFFF;
    uint64_t v8 = (llvm::Value **)((char *)this - 32 * v7);
  }
  if (v7)
  {
    unsigned int v9 = 0;
    unsigned int v10 = 0;
    int v11 = 0;
    unsigned int v12 = 0;
    uint64_t v13 = 32 * v7;
    char v14 = 1;
    do
    {
      unsigned int v15 = *v8;
      if (*v8 == a2)
      {
        ++v11;
        unsigned int v10 = v9;
        unsigned int v15 = a3;
      }
      if (v12 >= 8) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v19[v12] = v15;
      unsigned int v12 = ++v18;
      v14 &= v15 == a3;
      v8 += 4;
      ++v9;
      v13 -= 32;
    }
    while (v13);
    if ((v14 & 1) == 0) {
      goto LABEL_12;
    }
  }
  else
  {
    unsigned int v10 = 0;
    int v11 = 0;
  }
  if (llvm::Constant::isNullValue(a3)) {
    return (llvm::Value *)llvm::ConstantAggregateZero::get(*(llvm::ConstantAggregateZero **)this, v17);
  }
  if (*((unsigned __int8 *)a3 + 16) - 11 < 2) {
    return (llvm::Value *)llvm::UndefValue::get(*(llvm::UndefValue **)this, v17);
  }
  unsigned int v12 = v18;
LABEL_12:
  uint64_t result = llvm::ConstantArray::getImpl(*(llvm::PoisonValue **)this, (llvm::Type *)v19, v12);
  if (!result) {
    return (llvm::Value *)sub_1CD5A97A0(***(void ***)this + 1240, v19, v18, (uint64_t)this, (uint64_t)a2, (uint64_t)a3, v11, v10);
  }
  return result;
}

void *llvm::ConstantStruct::handleOperandChangeImpl(llvm::ConstantStruct *this, llvm::Value *a2, llvm::Value *a3)
{
  v20[8] = *MEMORY[0x1E4F143B8];
  int v6 = *((_DWORD *)this + 5);
  if ((v6 & 0x40000000) != 0)
  {
    uint64_t v8 = (llvm::Value **)*((void *)this - 1);
    LODWORD(v7) = v6 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v7 = v6 & 0x7FFFFFF;
    uint64_t v8 = (llvm::Value **)((char *)this - 32 * v7);
  }
  unsigned int v19 = 0;
  if (v7 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v7)
  {
    unsigned int v9 = 0;
    unsigned int v10 = 0;
    int v11 = 0;
    uint64_t v12 = v7;
    unsigned int v13 = 0;
    uint64_t v14 = 32 * v12;
    char v15 = 1;
    do
    {
      if (*v8 == a2)
      {
        ++v11;
        unsigned int v10 = v9;
        uint64_t v16 = a3;
      }
      else
      {
        uint64_t v16 = *v8;
      }
      if (v13 >= 8) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v20[v13] = v16;
      unsigned int v13 = ++v19;
      v15 &= v16 == a3;
      v8 += 4;
      ++v9;
      v14 -= 32;
    }
    while (v14);
    if ((v15 & 1) == 0) {
      return (void *)sub_1CD5A9900(***(void ***)this + 1264, v20, v13, (uint64_t)this, (uint64_t)a2, (uint64_t)a3, v11, v10);
    }
  }
  else
  {
    unsigned int v10 = 0;
    int v11 = 0;
  }
  if (llvm::Constant::isNullValue(a3)) {
    return llvm::ConstantAggregateZero::get(*(llvm::ConstantAggregateZero **)this, v17);
  }
  if (*((unsigned __int8 *)a3 + 16) - 11 < 2) {
    return (void *)llvm::UndefValue::get(*(llvm::UndefValue **)this, v17);
  }
  unsigned int v13 = v19;
  return (void *)sub_1CD5A9900(***(void ***)this + 1264, v20, v13, (uint64_t)this, (uint64_t)a2, (uint64_t)a3, v11, v10);
}

llvm::Value *llvm::ConstantVector::handleOperandChangeImpl(llvm::ConstantVector *this, llvm::Value *a2, llvm::FixedVectorType **a3)
{
  v16[8] = *(llvm::FixedVectorType ***)MEMORY[0x1E4F143B8];
  unsigned int v15 = 0;
  unsigned int v6 = *((_DWORD *)this + 5) & 0x7FFFFFF;
  if (v6 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v12 = 0;
  if (v6)
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    int v9 = 0;
    unsigned int v10 = this;
    do
    {
      if (*((llvm::Value **)v10 - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF)) == a2)
      {
        ++v9;
        unsigned int v8 = v7;
        int v11 = a3;
      }
      else
      {
        int v11 = (llvm::FixedVectorType **)*((void *)v10 - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
      }
      if (v12 >= 8) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v16[v12] = v11;
      unsigned int v12 = ++v15;
      ++v7;
      unsigned int v10 = (llvm::ConstantVector *)((char *)v10 + 32);
    }
    while (v6 != v7);
  }
  else
  {
    int v9 = 0;
    unsigned int v8 = 0;
  }
  uint64_t Impl = llvm::ConstantVector::getImpl(v16, (llvm::Type *)v12);
  if (!Impl) {
    return (llvm::Value *)sub_1CD5A9A64(***(void ***)this + 1288, v16, v15, (uint64_t)this, (uint64_t)a2, (uint64_t)a3, v9, v8);
  }
  return Impl;
}

uint64_t sub_1CD5A97A0(unint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int a8)
{
  *(void *)&long long v22 = *(void *)a4;
  *((void *)&v22 + 1) = a2;
  uint64_t v23 = a3;
  int v19 = sub_1CC571B50(a2, (uint64_t)&a2[a3]);
  int v19 = sub_1CC571744((uint64_t *)&v22, &v19);
  long long v20 = v22;
  uint64_t v21 = v23;
  v25[0] = 0;
  if (sub_1CC571F20((uint64_t *)a1, (uint64_t)&v19, v25)
    && v25[0] != (uint64_t *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 16)))
  {
    return *v25[0];
  }
  sub_1CC56B838((int32x2_t *)a1, a4);
  if (a7 == 1)
  {
    sub_1CD5AAE7C(a4, a8, a6);
  }
  else
  {
    int v15 = *(_DWORD *)(a4 + 20);
    uint64_t v16 = v15 & 0x7FFFFFF;
    if ((v15 & 0x7FFFFFF) != 0)
    {
      uint64_t v17 = 0;
      uint64_t v18 = a4;
      do
      {
        if (*(void *)(v18 - 32 * (*(_DWORD *)(a4 + 20) & 0x7FFFFFF)) == a5) {
          sub_1CD5AAE7C(a4, v17, a6);
        }
        ++v17;
        v18 += 32;
      }
      while (v16 != v17);
    }
  }
  uint64_t v24 = a4;
  sub_1CC572074(a1, &v24, (uint64_t)&v19, (uint64_t)v25);
  return 0;
}

uint64_t sub_1CD5A9900(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int a8)
{
  *(void *)&long long v22 = *(void *)a4;
  *((void *)&v22 + 1) = a2;
  uint64_t v23 = a3;
  int v19 = sub_1CC571B50(a2, (uint64_t)&a2[a3]);
  int v19 = sub_1CC5724CC(&v22, &v19);
  long long v20 = v22;
  uint64_t v21 = v23;
  v25[0] = 0;
  if (sub_1CC5725C8(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)&v19, v25)
    && v25[0] != (uint64_t *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 16)))
  {
    return *v25[0];
  }
  sub_1CC56B8EC((int32x2_t *)a1, (uint64_t *)a4);
  if (a7 == 1)
  {
    sub_1CD5AAE7C(a4, a8, a6);
  }
  else
  {
    int v15 = *(_DWORD *)(a4 + 20);
    uint64_t v16 = v15 & 0x7FFFFFF;
    if ((v15 & 0x7FFFFFF) != 0)
    {
      uint64_t v17 = 0;
      uint64_t v18 = a4;
      do
      {
        if (*(void *)(v18 - 32 * (*(_DWORD *)(a4 + 20) & 0x7FFFFFF)) == a5) {
          sub_1CD5AAE7C(a4, v17, a6);
        }
        ++v17;
        v18 += 32;
      }
      while (v16 != v17);
    }
  }
  uint64_t v24 = a4;
  sub_1CC5726A4((uint64_t)v25, a1, &v24, (uint64_t)&v19);
  return 0;
}

uint64_t sub_1CD5A9A64(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int a8)
{
  *(void *)&long long v22 = *(void *)a4;
  *((void *)&v22 + 1) = a2;
  uint64_t v23 = a3;
  int v19 = sub_1CC571B50(a2, (uint64_t)&a2[a3]);
  int v19 = sub_1CC5724CC(&v22, &v19);
  long long v20 = v22;
  uint64_t v21 = v23;
  v25[0] = 0;
  if (sub_1CC572A90(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)&v19, v25)
    && v25[0] != (uint64_t *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 16)))
  {
    return *v25[0];
  }
  sub_1CD5A80E0(a1, (uint64_t *)a4);
  if (a7 == 1)
  {
    sub_1CD5AAE7C(a4, a8, a6);
  }
  else
  {
    int v15 = *(_DWORD *)(a4 + 20);
    uint64_t v16 = v15 & 0x7FFFFFF;
    if ((v15 & 0x7FFFFFF) != 0)
    {
      uint64_t v17 = 0;
      uint64_t v18 = a4;
      do
      {
        if (*(void *)(v18 - 32 * (*(_DWORD *)(a4 + 20) & 0x7FFFFFF)) == a5) {
          sub_1CD5AAE7C(a4, v17, a6);
        }
        ++v17;
        v18 += 32;
      }
      while (v16 != v17);
    }
  }
  uint64_t v24 = a4;
  sub_1CC572B64(a1, &v24, (uint64_t)&v19, (uint64_t)v25);
  return 0;
}

uint64_t sub_1CD5A9BC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, unsigned int a8)
{
  uint64_t v14 = *(void *)a4;
  uint64_t v15 = sub_1CD5AAEEC((uint64_t)v28 + 8, a2, a3, a4);
  *(void *)&v28[0] = v14;
  int v22 = sub_1CC573C30(v15);
  int v16 = sub_1CC5724CC(v28, &v22);
  long long v24 = v28[1];
  long long v25 = v28[2];
  long long v26 = v28[3];
  int v22 = v16;
  uint64_t v27 = v29;
  long long v23 = v28[0];
  v31[0] = 0;
  if (sub_1CC573E20(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)&v22, v31)
    && v31[0] != (uint64_t *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 16)))
  {
    return *v31[0];
  }
  sub_1CC56E990((int32x2_t *)a1, (uint64_t *)a4);
  if (a7 == 1)
  {
    LLVMSetArgOperand_0(a4, a8, a6);
  }
  else
  {
    int v18 = *(_DWORD *)(a4 + 20);
    uint64_t v19 = v18 & 0x7FFFFFF;
    if ((v18 & 0x7FFFFFF) != 0)
    {
      uint64_t v20 = 0;
      uint64_t v21 = a4;
      do
      {
        if (*(void *)(v21 - 32 * (*(_DWORD *)(a4 + 20) & 0x7FFFFFF)) == a5) {
          LLVMSetArgOperand_0(a4, v20, a6);
        }
        ++v20;
        v21 += 32;
      }
      while (v19 != v20);
    }
  }
  uint64_t v30 = a4;
  sub_1CC574050((uint64_t)v31, a1, &v30, (uint64_t)&v22);
  return 0;
}

void sub_1CD5A9D38(llvm::Value *this)
{
  unint64_t v2 = (llvm::Value *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2)
  {
    sub_1CC5747CC(v2);
    llvm::User::operator delete(v3);
  }

  llvm::Value::~Value(this);
}

void sub_1CD5A9D80(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)a1;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v14 = 0;
      sub_1CC1DE178(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v14);
      unsigned int v10 = v14;
      *uint64_t v14 = *a2;
      uint64_t v11 = a2[1];
      a2[1] = 0;
      v10[1] = v11;
      ++*(_DWORD *)(a1 + 8);
      unsigned int v12 = (llvm::Value *)a2[1];
      a2[1] = 0;
      if (v12)
      {
        llvm::Value::~Value(v12);
        llvm::User::operator delete(v13);
      }
    }
    a2 += 2;
  }
}

uint64_t sub_1CD5A9E50(uint64_t a1, int a2, uint64_t **a3, uint64_t ***a4)
{
  if (a2)
  {
    int v8 = sub_1CC572FB0(*a3);
    int v9 = a2 - 1;
    unsigned int v10 = v8 & (a2 - 1);
    uint64_t v11 = (uint64_t **)(a1 + 8 * v10);
    unsigned int v12 = *v11;
    if (*a3 == *v11)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      uint64_t result = 1;
      while (v12 != (uint64_t *)-4096)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v12 == (uint64_t *)-8192;
        }
        if (v16) {
          uint64_t v14 = v11;
        }
        unsigned int v17 = v10 + v15++;
        unsigned int v10 = v17 & v9;
        uint64_t v11 = (uint64_t **)(a1 + 8 * (v17 & v9));
        unsigned int v12 = *v11;
        if (*a3 == *v11) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v14) {
        uint64_t v11 = v14;
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a4 = v11;
  return result;
}

void sub_1CD5A9F14(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)a1;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v13 = 0;
      sub_1CC5734E0((uint64_t *)a1, a2, &v13);
      int v9 = v13;
      *unsigned int v13 = *a2;
      uint64_t v10 = a2[1];
      a2[1] = 0;
      v9[1] = v10;
      ++*(_DWORD *)(a1 + 8);
      uint64_t v11 = (llvm::Value *)a2[1];
      a2[1] = 0;
      if (v11)
      {
        llvm::Value::~Value(v11);
        llvm::User::operator delete(v12);
      }
    }
    a2 += 2;
  }
}

void *sub_1CD5A9FE4(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5AA050(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD5AA050(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5AA104(a1, v6);
  uint64_t v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5AA104(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5AA1D0(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void sub_1CD5AA1D0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v14 = 0;
      sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v14);
      uint64_t v10 = v14;
      *uint64_t v14 = *a2;
      uint64_t v11 = a2[1];
      a2[1] = 0;
      v10[1] = v11;
      ++*(_DWORD *)(a1 + 8);
      unsigned int v12 = (llvm::Value *)a2[1];
      a2[1] = 0;
      if (v12)
      {
        llvm::Value::~Value(v12);
        llvm::User::operator delete(v13);
      }
    }
    a2 += 2;
  }
}

void sub_1CD5AA2A0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v14 = 0;
      sub_1CC152E2C(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v14);
      uint64_t v10 = v14;
      *uint64_t v14 = *a2;
      uint64_t v11 = a2[1];
      a2[1] = 0;
      v10[1] = v11;
      ++*(_DWORD *)(a1 + 8);
      unsigned int v12 = (llvm::Value *)a2[1];
      a2[1] = 0;
      if (v12)
      {
        llvm::Value::~Value(v12);
        llvm::User::operator delete(v13);
      }
    }
    a2 += 2;
  }
}

void *sub_1CD5AA370(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CD5AA3D8(a1, a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD5AA4D0((uint64_t)a1, a2, v7);
    void *v5 = *a2;
    v5[1] = a2[1];
    void v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1CD5AA3D8(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = a2[1];
    unint64_t v6 = ((v5 >> 4) ^ (v5 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
       + ~((unint64_t)((v5 >> 4) ^ (v5 >> 9)) << 32);
    unint64_t v7 = (v6 ^ (v6 >> 22)) + ~((v6 ^ (v6 >> 22)) << 13);
    unint64_t v8 = (9 * (v7 ^ (v7 >> 8))) ^ ((9 * (v7 ^ (v7 >> 8))) >> 15);
    int v9 = ((v8 + ~(v8 << 27)) >> 31) ^ (v8 + ~(v8 << 27));
    int v10 = v3 - 1;
    unsigned int v11 = (v3 - 1) & v9;
    unsigned int v12 = (void *)(*a1 + 24 * v11);
    uint64_t v13 = *v12;
    uint64_t v14 = v12[1];
    if (*a2 == *v12 && v5 == v14)
    {
      uint64_t result = 1;
    }
    else
    {
      unsigned int v17 = 0;
      int v18 = 1;
      while (v13 != -4096 || v14 != -4096)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v14 == -8192;
        }
        if (v19 && v13 == -8192) {
          unsigned int v17 = v12;
        }
        unsigned int v21 = v11 + v18++;
        unsigned int v11 = v21 & v10;
        unsigned int v12 = (void *)(v4 + 24 * (v21 & v10));
        uint64_t v13 = *v12;
        uint64_t v14 = v12[1];
        uint64_t result = 1;
        if (*a2 == *v12 && v5 == v14) {
          goto LABEL_8;
        }
      }
      uint64_t result = 0;
      if (v17) {
        unsigned int v12 = v17;
      }
    }
  }
  else
  {
    unsigned int v12 = 0;
    uint64_t result = 0;
  }
LABEL_8:
  *a3 = v12;
  return result;
}

void *sub_1CD5AA4D0(uint64_t a1, void *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1CD5AA58C(a1, v6);
    unint64_t v8 = 0;
    sub_1CD5AA3D8((uint64_t *)a1, a2, &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD5AA58C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5AA668(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5AA668(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *int v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v10 = a2[1];
    if ((*a2 != -4096 || v10 != -4096) && (*a2 != -8192 || v10 != -8192))
    {
      int64x2_t v12 = 0;
      uint64_t result = sub_1CD5AA3D8((uint64_t *)v5, a2, &v12);
      uint64_t v11 = v12;
      *int64x2_t v12 = *a2;
      v11[1] = a2[1];
      _DWORD v11[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

uint64_t sub_1CD5AA744(uint64_t result, __int16 a2, void *a3, uint64_t a4, char a5)
{
  *(void *)uint64_t result = *a3;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_WORD *)(result + 16) = 5;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(result + 20) & 0xC0000000 | 2;
  *(_WORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = a2;
  if (*(void *)(result - 64))
  {
    **(void **)(result - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(result - 56);
    uint64_t v12 = *(void *)(result - 56);
    if (v12) {
      *(void *)(v12 + 16) = *(void *)(result - 48);
    }
  }
  *(void *)(result - 64) = a3;
  uint64_t v7 = a3[1];
  uint64_t v5 = a3 + 1;
  uint64_t v6 = v7;
  *(void *)(result - 56) = v7;
  if (v7) {
    *(void *)(v6 + 16) = result - 56;
  }
  *(void *)(result - 4sub_1CD521E44((uint64_t)this + 8) = v5;
  void *v5 = result - 64;
  uint64_t v8 = (void *)(result - 32);
  if (*(void *)(result - 32))
  {
    **(void **)(result - 16) = *(void *)(result - 24);
    uint64_t v13 = *(void *)(result - 24);
    if (v13) {
      *(void *)(v13 + 16) = *(void *)(result - 16);
    }
  }
  *uint64_t v8 = a4;
  if (a4)
  {
    uint64_t v11 = *(void *)(a4 + 8);
    int64x2_t v9 = (void *)(a4 + 8);
    uint64_t v10 = v11;
    *(void *)(result - 24) = v11;
    if (v11) {
      *(void *)(v10 + 16) = result - 24;
    }
    *(void *)(result - 16) = v9;
    *int64x2_t v9 = v8;
  }
  *(unsigned char *)(result + 17) = *(unsigned char *)(result + 17) & 1 | (2 * a5);
  return result;
}

uint64_t sub_1CD5AA80C(uint64_t result, uint64_t a2, void *a3, uint64_t a4)
{
  *(void *)uint64_t result = *a3;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v4 = *(_DWORD *)(result + 20) & 0xC0000000 | 3;
  *(_DWORD *)(result + 16) = 3735557;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = v4;
  uint64_t v5 = (void *)(result - 96);
  if (*(void *)(result - 96))
  {
    **(void **)(result - 8llvm::MDNode::dumpTree(this, 0) = *(void *)(result - 88);
    uint64_t v6 = *(void *)(result - 88);
    if (v6) {
      *(void *)(v6 + 16) = *(void *)(result - 80);
    }
  }
  void *v5 = a2;
  if (a2)
  {
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v7 = (void *)(a2 + 8);
    uint64_t v8 = v9;
    *(void *)(result - 8sub_1CD521E44((uint64_t)this + 8) = v9;
    if (v9) {
      *(void *)(v8 + 16) = result - 88;
    }
    *(void *)(result - 8llvm::MDNode::dumpTree(this, 0) = v7;
    *uint64_t v7 = v5;
  }
  if (*(void *)(result - 64))
  {
    **(void **)(result - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(result - 56);
    uint64_t v10 = *(void *)(result - 56);
    if (v10) {
      *(void *)(v10 + 16) = *(void *)(result - 48);
    }
  }
  *(void *)(result - 64) = a3;
  uint64_t v13 = a3[1];
  uint64_t v11 = a3 + 1;
  uint64_t v12 = v13;
  *(void *)(result - 56) = v13;
  if (v13) {
    *(void *)(v12 + 16) = result - 56;
  }
  *(void *)(result - 4sub_1CD521E44((uint64_t)this + 8) = v11;
  *uint64_t v11 = result - 64;
  uint64_t v14 = (void *)(result - 32);
  if (*(void *)(result - 32))
  {
    **(void **)(result - 16) = *(void *)(result - 24);
    uint64_t v15 = *(void *)(result - 24);
    if (v15) {
      *(void *)(v15 + 16) = *(void *)(result - 16);
    }
  }
  *uint64_t v14 = a4;
  if (a4)
  {
    uint64_t v18 = *(void *)(a4 + 8);
    BOOL v16 = (void *)(a4 + 8);
    uint64_t v17 = v18;
    *(void *)(result - 24) = v18;
    if (v18) {
      *(void *)(v17 + 16) = result - 24;
    }
    *(void *)(result - 16) = v16;
    *BOOL v16 = v14;
  }
  return result;
}

uint64_t sub_1CD5AA904(uint64_t result, void *a2, uint64_t a3)
{
  *(void *)uint64_t result = *(void *)(*a2 + 24);
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(result + 16) = 5;
  *(unsigned char *)(result + 17) = 0;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(result + 20) & 0xC0000000 | 2;
  *(_WORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = 61;
  if (*(void *)(result - 64))
  {
    **(void **)(result - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(result - 56);
    uint64_t v10 = *(void *)(result - 56);
    if (v10) {
      *(void *)(v10 + 16) = *(void *)(result - 48);
    }
  }
  *(void *)(result - 64) = a2;
  uint64_t v5 = a2[1];
  unsigned int v3 = a2 + 1;
  uint64_t v4 = v5;
  *(void *)(result - 56) = v5;
  if (v5) {
    *(void *)(v4 + 16) = result - 56;
  }
  *(void *)(result - 4sub_1CD521E44((uint64_t)this + 8) = v3;
  *unsigned int v3 = result - 64;
  uint64_t v6 = (void *)(result - 32);
  if (*(void *)(result - 32))
  {
    **(void **)(result - 16) = *(void *)(result - 24);
    uint64_t v11 = *(void *)(result - 24);
    if (v11) {
      *(void *)(v11 + 16) = *(void *)(result - 16);
    }
  }
  *uint64_t v6 = a3;
  if (a3)
  {
    uint64_t v9 = *(void *)(a3 + 8);
    uint64_t v7 = (void *)(a3 + 8);
    uint64_t v8 = v9;
    *(void *)(result - 24) = v9;
    if (v9) {
      *(void *)(v8 + 16) = result - 24;
    }
    *(void *)(result - 16) = v7;
    *uint64_t v7 = v6;
  }
  return result;
}

uint64_t sub_1CD5AA9CC(uint64_t result, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)uint64_t result = *a2;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v4 = *(_DWORD *)(result + 20) & 0xC0000000 | 3;
  *(_DWORD *)(result + 16) = 4063237;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = v4;
  if (*(void *)(result - 96))
  {
    **(void **)(result - 8llvm::MDNode::dumpTree(this, 0) = *(void *)(result - 88);
    uint64_t v5 = *(void *)(result - 88);
    if (v5) {
      *(void *)(v5 + 16) = *(void *)(result - 80);
    }
  }
  *(void *)(result - 96) = a2;
  uint64_t v8 = a2[1];
  uint64_t v6 = a2 + 1;
  uint64_t v7 = v8;
  *(void *)(result - 8sub_1CD521E44((uint64_t)this + 8) = v8;
  if (v8) {
    *(void *)(v7 + 16) = result - 88;
  }
  *(void *)(result - 8llvm::MDNode::dumpTree(this, 0) = v6;
  *uint64_t v6 = result - 96;
  uint64_t v9 = (void *)(result - 64);
  if (*(void *)(result - 64))
  {
    **(void **)(result - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(result - 56);
    uint64_t v10 = *(void *)(result - 56);
    if (v10) {
      *(void *)(v10 + 16) = *(void *)(result - 48);
    }
  }
  *uint64_t v9 = a3;
  if (a3)
  {
    uint64_t v13 = *(void *)(a3 + 8);
    uint64_t v11 = (void *)(a3 + 8);
    uint64_t v12 = v13;
    *(void *)(result - 56) = v13;
    if (v13) {
      *(void *)(v12 + 16) = result - 56;
    }
    *(void *)(result - 4sub_1CD521E44((uint64_t)this + 8) = v11;
    *uint64_t v11 = v9;
  }
  uint64_t v14 = (void *)(result - 32);
  if (*(void *)(result - 32))
  {
    **(void **)(result - 16) = *(void *)(result - 24);
    uint64_t v15 = *(void *)(result - 24);
    if (v15) {
      *(void *)(v15 + 16) = *(void *)(result - 16);
    }
  }
  *uint64_t v14 = a4;
  if (a4)
  {
    uint64_t v18 = *(void *)(a4 + 8);
    BOOL v16 = (void *)(a4 + 8);
    uint64_t v17 = v18;
    *(void *)(result - 24) = v18;
    if (v18) {
      *(void *)(v17 + 16) = result - 24;
    }
    *(void *)(result - 16) = v16;
    *BOOL v16 = v14;
  }
  return result;
}

uint64_t sub_1CD5AAAC4(uint64_t a1, void *a2, uint64_t a3, int *a4, uint64_t a5)
{
  llvm::VectorType::get(*(llvm::FixedVectorType **)(*a2 + 24), (llvm::Type *)(a5 | ((unint64_t)(*(unsigned char *)(*a2 + 8) == 19) << 32)));
  *(void *)a1 = v10;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 20) & 0xC0000000 | 2;
  *(_DWORD *)(a1 + 16) = 4128773;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = v11;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  if (*(void *)(a1 - 64))
  {
    **(void **)(a1 - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(a1 - 56);
    uint64_t v12 = *(void *)(a1 - 56);
    if (v12) {
      *(void *)(v12 + 16) = *(void *)(a1 - 48);
    }
  }
  *(void *)(a1 - 64) = a2;
  uint64_t v15 = a2[1];
  uint64_t v14 = a2 + 1;
  uint64_t v13 = v15;
  *(void *)(a1 - 56) = v15;
  if (v15) {
    *(void *)(v13 + 16) = a1 - 56;
  }
  *(void *)(a1 - 4sub_1CD521E44((uint64_t)this + 8) = v14;
  *uint64_t v14 = a1 - 64;
  BOOL v16 = (void *)(a1 - 32);
  if (*(void *)(a1 - 32))
  {
    **(void **)(a1 - 16) = *(void *)(a1 - 24);
    uint64_t v17 = *(void *)(a1 - 24);
    if (v17) {
      *(void *)(v17 + 16) = *(void *)(a1 - 16);
    }
  }
  *BOOL v16 = a3;
  if (a3)
  {
    uint64_t v20 = *(void *)(a3 + 8);
    BOOL v19 = (void *)(a3 + 8);
    uint64_t v18 = v20;
    *(void *)(a1 - 24) = v20;
    if (v20) {
      *(void *)(v18 + 16) = a1 - 24;
    }
    *(void *)(a1 - 16) = v19;
    *BOOL v19 = v16;
  }
  *(_DWORD *)(a1 + 32) = 0;
  sub_1CC1899BC((unsigned int *)(a1 + 24), a4, &a4[a5]);
  *(void *)(a1 + 56) = llvm::ShuffleVectorInst::convertShuffleMaskForBitcode(a4, a5, *(unsigned char **)a1);
  return a1;
}

uint64_t sub_1CD5AAC0C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *__src, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = a6;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v9 = *(_DWORD *)(a1 + 20) & 0xC0000000 | 2;
  *(_DWORD *)(a1 + 16) = 4259845;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = v9;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  sub_1CB925718((unsigned int *)(a1 + 24), __src, &__src[4 * a5]);
  uint64_t v10 = (void *)(a1 - 64);
  if (*(void *)(a1 - 64))
  {
    **(void **)(a1 - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(a1 - 56);
    uint64_t v11 = *(void *)(a1 - 56);
    if (v11) {
      *(void *)(v11 + 16) = *(void *)(a1 - 48);
    }
  }
  void *v10 = a2;
  if (a2)
  {
    uint64_t v14 = *(void *)(a2 + 8);
    uint64_t v13 = (void *)(a2 + 8);
    uint64_t v12 = v14;
    *(void *)(a1 - 56) = v14;
    if (v14) {
      *(void *)(v12 + 16) = a1 - 56;
    }
    *(void *)(a1 - 4sub_1CD521E44((uint64_t)this + 8) = v13;
    *uint64_t v13 = v10;
  }
  uint64_t v15 = (void *)(a1 - 32);
  if (*(void *)(a1 - 32))
  {
    **(void **)(a1 - 16) = *(void *)(a1 - 24);
    uint64_t v16 = *(void *)(a1 - 24);
    if (v16) {
      *(void *)(v16 + 16) = *(void *)(a1 - 16);
    }
  }
  *uint64_t v15 = a3;
  if (a3)
  {
    uint64_t v19 = *(void *)(a3 + 8);
    uint64_t v18 = (void *)(a3 + 8);
    uint64_t v17 = v19;
    *(void *)(a1 - 24) = v19;
    if (v19) {
      *(void *)(v17 + 16) = a1 - 24;
    }
    *(void *)(a1 - 16) = v18;
    *uint64_t v18 = v15;
  }
  return a1;
}

uint64_t sub_1CD5AAD0C(uint64_t a1, uint64_t a2, unsigned char *__src, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = a5;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  unsigned int v7 = *(_DWORD *)(a1 + 20) & 0xC0000000 | 1;
  *(_DWORD *)(a1 + 16) = 4194309;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = v7;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  sub_1CB925718((unsigned int *)(a1 + 24), __src, &__src[4 * a4]);
  uint64_t v8 = (void *)(a1 - 32);
  if (*(void *)(a1 - 32))
  {
    **(void **)(a1 - 16) = *(void *)(a1 - 24);
    uint64_t v9 = *(void *)(a1 - 24);
    if (v9) {
      *(void *)(v9 + 16) = *(void *)(a1 - 16);
    }
  }
  *uint64_t v8 = a2;
  if (a2)
  {
    uint64_t v12 = *(void *)(a2 + 8);
    uint64_t v11 = (void *)(a2 + 8);
    uint64_t v10 = v12;
    *(void *)(a1 - 24) = v12;
    if (v12) {
      *(void *)(v10 + 16) = a1 - 24;
    }
    *(void *)(a1 - 16) = v11;
    *uint64_t v11 = v8;
  }
  return a1;
}

uint64_t sub_1CD5AADBC(uint64_t result, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_WORD *)(result + 16) = 5;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(result + 20) & 0xC0000000 | 2;
  *(_WORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = a3;
  *(_WORD *)(result + 24) = a4;
  uint64_t v6 = (void *)(result - 64);
  if (*(void *)(result - 64))
  {
    **(void **)(result - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(result - 56);
    uint64_t v14 = *(void *)(result - 56);
    if (v14) {
      *(void *)(v14 + 16) = *(void *)(result - 48);
    }
  }
  *uint64_t v6 = a5;
  if (a5)
  {
    uint64_t v9 = *(void *)(a5 + 8);
    unsigned int v7 = (void *)(a5 + 8);
    uint64_t v8 = v9;
    *(void *)(result - 56) = v9;
    if (v9) {
      *(void *)(v8 + 16) = result - 56;
    }
    *(void *)(result - 4sub_1CD521E44((uint64_t)this + 8) = v7;
    *unsigned int v7 = v6;
  }
  uint64_t v10 = (void *)(result - 32);
  if (*(void *)(result - 32))
  {
    **(void **)(result - 16) = *(void *)(result - 24);
    uint64_t v15 = *(void *)(result - 24);
    if (v15) {
      *(void *)(v15 + 16) = *(void *)(result - 16);
    }
  }
  void *v10 = a6;
  if (a6)
  {
    uint64_t v13 = *(void *)(a6 + 8);
    uint64_t v11 = (void *)(a6 + 8);
    uint64_t v12 = v13;
    *(void *)(result - 24) = v13;
    if (v13) {
      *(void *)(v12 + 16) = result - 24;
    }
    *(void *)(result - 16) = v11;
    *uint64_t v11 = v10;
  }
  return result;
}

uint64_t sub_1CD5AAE7C(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = result - 32 * (*(_DWORD *)(result + 20) & 0x7FFFFFF);
  unsigned int v4 = (void *)(v3 + 32 * a2);
  uint64_t v5 = v4;
  if (*v4)
  {
    unsigned int v7 = (void *)v4[2];
    uint64_t v6 = v4 + 2;
    *unsigned int v7 = *(v6 - 1);
    uint64_t v8 = *(v6 - 1);
    if (v8) {
      *(void *)(v8 + 16) = *v6;
    }
  }
  void *v5 = a3;
  if (a3)
  {
    uint64_t v11 = *(void *)(a3 + 8);
    uint64_t v9 = (void *)(a3 + 8);
    uint64_t v10 = v11;
    uint64_t v12 = v3 + 32 * a2;
    *(void *)(v12 + sub_1CD521E44((uint64_t)this + 8) = v11;
    if (v11) {
      *(void *)(v10 + 16) = v12 + 8;
    }
    *(void *)(v12 + 16) = v9;
    *uint64_t v9 = v5;
  }
  return result;
}

uint64_t sub_1CD5AAEEC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = *(unsigned __int16 *)(a4 + 18);
  *(unsigned char *)uint64_t result = v4;
  *(unsigned char *)(result + 1) = *(unsigned char *)(a4 + 17) >> 1;
  if ((v4 - 53) > 1) {
    __int16 v5 = 0;
  }
  else {
    __int16 v5 = *(_WORD *)(a4 + 24);
  }
  *(_WORD *)(result + 2) = v5;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = a2;
  *(void *)(result + 16) = a3;
  if ((v4 & 0xFFFE) == 0x40)
  {
    uint64_t v6 = *(void *)(a4 + 24);
    uint64_t v7 = *(unsigned int *)(a4 + 32);
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  *(void *)(result + 24) = v6;
  *(void *)(result + 32) = v7;
  if (*(_WORD *)(a4 + 18) == 63)
  {
    uint64_t v8 = *(void *)(a4 + 24);
    uint64_t v9 = *(unsigned int *)(a4 + 32);
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v8 = 0;
  }
  *(void *)(result + 4llvm::MDNode::dumpTree(this, 0) = v8;
  *(void *)(result + 4sub_1CD521E44((uint64_t)this + 8) = v9;
  if (*(_WORD *)(a4 + 18) == 34) {
    uint64_t v10 = *(void *)(a4 + 24);
  }
  else {
    uint64_t v10 = 0;
  }
  *(void *)(result + 56) = v10;
  return result;
}

void llvm::initializeCore(llvm *this, llvm::PassRegistry *a2)
{
  llvm::initializeDominatorTreeWrapperPassPass((uint64_t)this);
  llvm::initializePrintModulePassWrapperPass(this, v3);
  llvm::initializePrintFunctionPassWrapperPass(this, v4);
  llvm::initializeSafepointIRVerifierPass(this, v5);

  llvm::initializeVerifierLegacyPassPass(this, v6);
}

uint64_t sub_1CD5AAFD8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result - 32 * (*(_DWORD *)(result + 20) & 0x7FFFFFF);
  uint64_t v3 = (void *)(v2 + 32);
  if (*(void *)(v2 + 32))
  {
    **(void **)(v2 + 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(v2 + 40);
    uint64_t v4 = *(void *)(v2 + 40);
    if (v4) {
      *(void *)(v4 + 16) = *(void *)(v2 + 48);
    }
  }
  *uint64_t v3 = a2;
  if (a2)
  {
    uint64_t v7 = *(void *)(a2 + 8);
    __int16 v5 = (void *)(a2 + 8);
    uint64_t v6 = v7;
    *(void *)(v2 + 4llvm::MDNode::dumpTree(this, 0) = v7;
    if (v7) {
      *(void *)(v6 + 16) = v2 + 40;
    }
    *(void *)(v2 + 4sub_1CD521E44((uint64_t)this + 8) = v5;
    void *v5 = v3;
  }
  return result;
}

llvm::Instruction *sub_1CD5AB030(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  __int16 v14 = 257;
  uint64_t v10 = sub_1CD4EF89C(a2, a3, a4, a5, a6, a7, 0, 0, &v13, 0);
  uint64_t v11 = (llvm::Instruction *)v10;
  if (*(unsigned char *)(a1 + 100)) {
    *((void *)v10 + sub_1CD521E44((uint64_t)this + 8) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v10 + 8, **(uint64_t ***)v10, -1, 61);
  }
  return sub_1CD509770((uint64_t *)a1, v11, a8);
}

llvm::Instruction *sub_1CD5AB0D0(uint64_t *a1, llvm::Type **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10 = a4 + 1;
  __int16 v14 = 257;
  uint64_t v11 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, (int)a4 + 1);
  llvm::FuncletPadInst::FuncletPadInst(v11, 52, a2, a3, a4, v10, &v13, 0);
  sub_1CD509770(a1, v11, a5);
  return v11;
}

llvm::Instruction *sub_1CD5AB170(uint64_t *a1, llvm::Type **a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10 = a4 + 1;
  __int16 v14 = 257;
  uint64_t v11 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, (int)a4 + 1);
  llvm::FuncletPadInst::FuncletPadInst(v11, 51, a2, a3, a4, v10, &v13, 0);
  sub_1CD509770(a1, v11, a5);
  return v11;
}

llvm::Instruction *LLVMBuildCleanupRet_0(uint64_t *a1, llvm::Value *a2, llvm::BasicBlock *a3)
{
  if (a3) {
    unsigned int v6 = 2;
  }
  else {
    unsigned int v6 = 1;
  }
  uint64_t v7 = (llvm::CleanupReturnInst *)llvm::User::operator new((llvm::User *)0x40, v6);
  llvm::CleanupReturnInst::CleanupReturnInst(v7, a2, a3, v6, 0);
  __int16 v10 = 257;
  return sub_1CD509770(a1, v7, (uint64_t)v9);
}

llvm::Instruction *sub_1CD5AB298(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1CC581220((uint64_t)a1, 23, (uint64_t)a2, a3, a4);
  if (!result)
  {
    __int16 v11 = 257;
    uint64_t v9 = llvm::BinaryOperator::Create(23, a2, a3, &v10, 0);
    return sub_1CB844E0C(a1, v9, a4);
  }
  return result;
}

llvm::Instruction *sub_1CD5AB31C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 100)) {
    return (llvm::Instruction *)llvm::IRBuilderBase::CreateConstrainedFPBinOp(a1, 95, a2, a3, 0, a4, 0, 0, 0);
  }
  uint64_t result = sub_1CC581220(a1, 24, (uint64_t)a2, a3, a4);
  if (!result)
  {
    __int16 v14 = 257;
    uint64_t v9 = (uint64_t ***)llvm::BinaryOperator::Create(24, a2, a3, &v13, 0);
    __int16 v10 = v9;
    int v11 = *(_DWORD *)(a1 + 96);
    uint64_t v12 = *(llvm::MDNode **)(a1 + 88);
    if (v12) {
      llvm::Value::setMetadata(v9, 3, v12);
    }
    *((unsigned char *)v10 + 17) |= 2 * (_BYTE)v11;
    return sub_1CB844E0C((uint64_t *)a1, (llvm::Instruction *)v10, a4);
  }
  return result;
}

llvm::CastInst *sub_1CD5AB400(uint64_t a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  if (*(llvm::Type ****)this == a3) {
    return this;
  }
  if (*((unsigned __int8 *)this + 16) > 0x14u)
  {
    __int16 v11 = 257;
    uint64_t v7 = llvm::CastInst::CreateSExtOrBitCast(this, a3, &v10, 0, a5);
    return sub_1CB844E0C((uint64_t *)a1, (llvm::Instruction *)v7, a4);
  }
  this = (llvm::CastInst *)(*(uint64_t (**)(void))(**(void **)(a1 + 72) + 296))(*(void *)(a1 + 72));
  if (this) {
    BOOL v9 = *((unsigned __int8 *)this + 16) >= 0x1Cu;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9) {
    return this;
  }

  return sub_1CB844E0C((uint64_t *)a1, this, a4);
}

llvm::CastInst *sub_1CD5AB4EC(uint64_t a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  if (*(llvm::Type ****)this == a3) {
    return this;
  }
  if (*((unsigned __int8 *)this + 16) > 0x14u)
  {
    __int16 v11 = 257;
    uint64_t v8 = llvm::CastInst::CreateTruncOrBitCast(this, a3, &v10, 0, a5);
    return sub_1CB844E0C((uint64_t *)a1, v8, a4);
  }
  this = (llvm::CastInst *)(*(uint64_t (**)(void))(**(void **)(a1 + 72) + 304))(*(void *)(a1 + 72));
  if (this) {
    BOOL v9 = *((unsigned __int8 *)this + 16) >= 0x1Cu;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9) {
    return this;
  }

  return sub_1CB844E0C((uint64_t *)a1, this, a4);
}

llvm::CastInst *sub_1CD5AB5DC(uint64_t a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  if (*(llvm::Type ****)this == a3) {
    return this;
  }
  if (*((unsigned __int8 *)this + 16) > 0x14u)
  {
    __int16 v11 = 257;
    uint64_t v7 = llvm::CastInst::CreateFPCast(this, a3, &v10, 0, a5);
    return sub_1CB844E0C((uint64_t *)a1, v7, a4);
  }
  this = (llvm::CastInst *)(*(uint64_t (**)(void))(**(void **)(a1 + 72) + 256))(*(void *)(a1 + 72));
  if (this) {
    BOOL v9 = *((unsigned __int8 *)this + 16) >= 0x1Cu;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9) {
    return this;
  }

  return sub_1CB844E0C((uint64_t *)a1, this, a4);
}

llvm::Instruction *sub_1CD5AB6C8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = operator new(0x60uLL);
  v8[13] = v8[13] & 0x38000000 | 1;
  BOOL v9 = (llvm::Instruction *)(v8 + 8);
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *((void *)v8 + 3) = v8 + 8;
  __int16 v13 = 257;
  __int16 v10 = sub_1CC19DDB4((llvm::Value *)(v8 + 8), a3, 60, a2, 0);
  llvm::Value::setName(v10, &v12);
  sub_1CD509770(a1, v9, a4);
  return v9;
}

uint64_t sub_1CD5AB76C(uint64_t result, unsigned int a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(result + 20);
  if ((v3 & 0x40000000) != 0) {
    uint64_t v4 = *(void *)(result - 8);
  }
  else {
    uint64_t v4 = result - 32 * (v3 & 0x7FFFFFF);
  }
  uint64_t v5 = v4 + 32 * a2;
  if (*(void *)v5)
  {
    **(void **)(v5 + 16) = *(void *)(v5 + 8);
    uint64_t v6 = *(void *)(v5 + 8);
    if (v6) {
      *(void *)(v6 + 16) = *(void *)(v5 + 16);
    }
  }
  *(void *)uint64_t v5 = a3;
  if (a3)
  {
    uint64_t v9 = *(void *)(a3 + 8);
    uint64_t v7 = (void *)(a3 + 8);
    uint64_t v8 = v9;
    uint64_t v10 = v4 + 32 * a2;
    *(void *)(v10 + sub_1CD521E44((uint64_t)this + 8) = v9;
    if (v9) {
      *(void *)(v8 + 16) = v10 + 8;
    }
    *(void *)(v10 + 16) = v7;
    *uint64_t v7 = v5;
  }
  return result;
}

uint64_t sub_1CD5AB7E0(uint64_t *a1, unsigned __int8 **a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3 >= *((_DWORD *)a1 + 3))
  {
    sub_1CD5AE91C();
  }
  uint64_t v4 = *a1;
  uint64_t v5 = (unsigned __int8 **)(*a1 + 8 * v3);
  uint64_t v6 = *a2;
  void *v5 = v6;
  if (v6)
  {
    llvm::MetadataTracking::track((uint64_t)v5, v6, 2);
    LODWORD(v3) = *((_DWORD *)a1 + 2);
    uint64_t v4 = *a1;
  }
  unsigned int v7 = v3 + 1;
  *((_DWORD *)a1 + 2) = v7;
  return v4 + 8 * v7 - 8;
}

void llvm::DIBuilder::finalizeSubprogram(llvm::DIBuilder *this, llvm::DISubprogram *a2)
{
  v11[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = ((void *)a2 - *((unsigned int *)a2 + 2))[7];
  if (v2 && (*(unsigned char *)(v2 + 1) & 0x7F) == 2)
  {
    uint64_t v8 = 0;
    uint64_t v9 = v11;
    uint64_t v10 = 0x1000000000;
    if (sub_1CD41F538(*((void *)this + 50), *((_DWORD *)this + 104), (uint64_t)a2, &v8)
      && v8 != *((void *)this + 50) + 32 * *((unsigned int *)this + 104))
    {
      sub_1CD4570C8((uint64_t)&v9, *(char **)(v8 + 8), (char *)(*(void *)(v8 + 8) + 8 * *(unsigned int *)(v8 + 16)));
    }
    uint64_t v8 = 0;
    if (sub_1CD41F538(*((void *)this + 53), *((_DWORD *)this + 110), (uint64_t)a2, &v8)
      && v8 != *((void *)this + 53) + 32 * *((unsigned int *)this + 110))
    {
      sub_1CD4570C8((uint64_t)&v9, *(char **)(v8 + 8), (char *)(*(void *)(v8 + 8) + 8 * *(unsigned int *)(v8 + 16)));
    }
    uint64_t Impl = llvm::MDTuple::getImpl(*((void *)this + 1), v9, v10, 0, 1);
    uint64_t v7 = *(void *)(v2 + 16);
    if ((v7 & 4) != 0) {
      llvm::ReplaceableMetadataImpl::replaceAllUsesWith((llvm::ReplaceableMetadataImpl *)(v7 & 0xFFFFFFFFFFFFFFF8), Impl);
    }
    llvm::MDNode::deleteTemporary((llvm::MDNode *)v2, v6);
    if (v9 != v11) {
      free(v9);
    }
  }
}

llvm::MDNode *llvm::DIBuilder::getOrCreateArray(uint64_t a1, void *a2, uint64_t a3)
{
  return llvm::MDTuple::getImpl(*(void *)(a1 + 8), a2, a3, 0, 1);
}

void llvm::DIBuilder::finalize(llvm::DIBuilder *this)
{
  unsigned char v55[16] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (llvm::MDNode *)*((void *)this + 2);
  if (v1)
  {
    uint64_t v3 = *((unsigned int *)this + 16);
    if (v3)
    {
      uint64_t Impl = llvm::MDTuple::getImpl(*((void *)this + 1), *((void **)this + 7), v3, 0, 1);
      llvm::MDNode::replaceOperandWith(v1, 4, Impl);
    }
    size_t v53 = (llvm::DISubprogram **)v55;
    uint64_t v54 = 0x1000000000;
    uint64_t v45 = v49;
    uint64_t v46 = v49;
    uint64_t v47 = 16;
    int v48 = 0;
    uint64_t v5 = *((unsigned int *)this + 28);
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v5;
      do
      {
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v45, *(void *)(*((void *)this + 13) + v6));
        if (v8)
        {
          if (v54 >= (unint64_t)HIDWORD(v54)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v53[v54] = *(llvm::DISubprogram **)(*((void *)this + 13) + v6);
          LODWORD(v54) = v54 + 1;
        }
        v6 += 8;
      }
      while (v7 != v6);
      if (v54)
      {
        uint64_t v9 = (llvm::MDNode *)*((void *)this + 2);
        uint64_t v10 = llvm::MDTuple::getImpl(*((void *)this + 1), v53, v54, 0, 1);
        llvm::MDNode::replaceOperandWith(v9, 5, v10);
      }
    }
    __int16 v11 = llvm::MDTuple::getImpl(*((void *)this + 1), *((void **)this + 19), *((unsigned int *)this + 40), 0, 1);
    uint64_t v12 = (llvm::DISubprogram **)v11;
    if (v11) {
      __int16 v13 = (llvm::DISubprogram **)((char *)v11 - 8 * *((unsigned int *)v11 + 2));
    }
    else {
      __int16 v13 = 0;
    }
    while (v13 != v12)
    {
      __int16 v14 = *v13++;
      llvm::DIBuilder::finalizeSubprogram(this, v14);
    }
    if (v54)
    {
      uint64_t v15 = v53;
      uint64_t v16 = 8 * v54;
      do
      {
        if (*(unsigned char *)*v15 == 17) {
          llvm::DIBuilder::finalizeSubprogram(this, *v15);
        }
        ++v15;
        v16 -= 8;
      }
      while (v16);
    }
    uint64_t v17 = *((unsigned int *)this + 52);
    if (v17)
    {
      uint64_t v18 = (llvm::MDNode *)*((void *)this + 2);
      uint64_t v19 = llvm::MDTuple::getImpl(*((void *)this + 1), *((void **)this + 25), v17, 0, 1);
      llvm::MDNode::replaceOperandWith(v18, 6, v19);
    }
    uint64_t v20 = *((unsigned int *)this + 64);
    if (v20)
    {
      uint64_t v42 = *((void *)this + 1);
      std::string::size_type v41 = (llvm::MDNode *)*((void *)this + 2);
      uint64_t v43 = (char *)*((void *)this + 31);
      uint64_t v50 = v52;
      uint64_t v51 = 0x1000000000;
      sub_1CD4570C8((uint64_t)&v50, v43, &v43[8 * v20]);
      uint64_t v44 = llvm::MDTuple::getImpl(v42, v50, v51, 0, 1);
      llvm::MDNode::replaceOperandWith(v41, 7, v44);
      if (v50 != v52) {
        free(v50);
      }
    }
    unsigned int v21 = (uint64_t *)*((void *)this + 40);
    int v22 = (uint64_t *)*((void *)this + 41);
    while (v21 != v22)
    {
      uint64_t v23 = *v21;
      if (*v21)
      {
        long long v24 = (void *)*((void *)this + 1);
        unsigned int v25 = *(_DWORD *)(v23 + 24);
        unint64_t v26 = *(void *)(v23 - 8 * *(unsigned int *)(v23 + 8));
        uint64_t v27 = llvm::MDTuple::getImpl((uint64_t)v24, (void *)v21[4], (v21[5] - v21[4]) >> 3, 0, 1);
        int v28 = llvm::DIMacroFile::getImpl(v24, 3u, v25, v26, (unint64_t)v27, 0, 1);
        if ((llvm::MDNode *)v23 == v28)
        {
          llvm::MDNode::replaceWithUniquedImpl((llvm::MDNode *)v23);
        }
        else
        {
          uint64_t v30 = *(void *)(v23 + 16);
          if ((v30 & 4) != 0) {
            llvm::ReplaceableMetadataImpl::replaceAllUsesWith((llvm::ReplaceableMetadataImpl *)(v30 & 0xFFFFFFFFFFFFFFF8), v28);
          }
          llvm::MDNode::deleteTemporary((llvm::MDNode *)v23, v29);
        }
      }
      else
      {
        char v31 = (llvm::MDNode *)*((void *)this + 2);
        long long v32 = llvm::MDTuple::getImpl(*((void *)this + 1), (void *)v21[4], (v21[5] - v21[4]) >> 3, 0, 1);
        llvm::MDNode::replaceOperandWith(v31, 8, v32);
      }
      v21 += 7;
    }
    uint64_t v33 = *((unsigned int *)this + 88);
    if (v33)
    {
      unint64_t v34 = (uint64_t *)*((void *)this + 43);
      uint64_t v35 = 8 * v33;
      do
      {
        uint64_t v36 = *v34;
        if (*v34 && ((*(unsigned char *)(v36 + 1) & 0x7F) == 2 || *(_DWORD *)(v36 + 12))) {
          llvm::MDNode::resolveCycles(v36);
        }
        ++v34;
        v35 -= 8;
      }
      while (v35);
      uint64_t v37 = *((unsigned int *)this + 88);
      if (v37)
      {
        uint64_t v38 = 8 * v37;
        uint64_t v39 = *((void *)this + 43) - 8;
        do
        {
          uint64_t v40 = *(unsigned __int8 **)(v39 + v38);
          if (v40) {
            llvm::MetadataTracking::untrack(v39 + v38, v40);
          }
          v38 -= 8;
        }
        while (v38);
      }
    }
    *((_DWORD *)this + 8sub_1CD521E44((uint64_t)this + 8) = 0;
    *((unsigned char *)this + 392) = 0;
    if (v46 != v45) {
      free(v46);
    }
    if (v53 != v55) {
      free(v53);
    }
  }
}

uint64_t llvm::DIBuilder::createCompileUnit(uint64_t a1, int a2, uint64_t a3, unsigned __int8 *a4, size_t a5, char a6, unsigned __int8 *a7, void *a8, int a9, unsigned __int8 *a10, size_t a11, int a12, uint64_t a13, char a14, char a15, int a16, char a17, unsigned __int8 *a18, size_t a19, unsigned __int8 *a20,size_t a21)
{
  *(void *)(a1 + 16) = sub_1CD5AE724(*(uint64_t **)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, 0, 0, 0, 0, a13, a14, a15,
                           a16,
                           a17,
                           a18,
                           a19,
                           a20,
                           a21,
                           1);
  inserted = (llvm::NamedMDNode *)llvm::Module::getOrInsertNamedMetadata(*(_DWORD **)a1, "llvm.dbg.cu", 0xBuLL);
  llvm::NamedMDNode::addOperand(inserted, *(llvm::MDNode **)(a1 + 16));
  uint64_t result = *(void *)(a1 + 16);
  long long v24 = (unsigned __int8 *)result;
  if (result && ((*(unsigned char *)(result + 1) & 0x7F) == 2 || *(_DWORD *)(result + 12)))
  {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v24);
    return *(void *)(a1 + 16);
  }
  return result;
}

unsigned __int8 *llvm::DIBuilder::createImportedDeclaration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned __int8 *a6, size_t a7, uint64_t a8)
{
  return sub_1CC581F48(*(uint64_t **)(a1 + 8), 8, a2, a3, a4, a5, a6, a7, a8, (uint64_t *)(a1 + 248));
}

llvm::MDNode *llvm::DIBuilder::createFile(uint64_t a1, unsigned __int8 *a2, void *a3, unsigned __int8 *a4, void *a5, _OWORD *a6, long long *a7)
{
  uint64_t v7 = *(uint64_t **)(a1 + 8);
  long long v8 = a6[1];
  v12[0] = *a6;
  v12[1] = v8;
  long long v10 = *a7;
  uint64_t v11 = *((void *)a7 + 2);
  return sub_1CD5AEA68(v7, a2, a3, a4, a5, (uint64_t)v12, (uint64_t)&v10, 0, 1u);
}

llvm::MDNode *llvm::DIBuilder::createMacro(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned __int8 *a5, size_t a6, unsigned __int8 *a7, size_t a8)
{
  long long v10 = sub_1CD5AEBAC(*(uint64_t **)(a1 + 8), a4, a3, a5, a6, a7, a8, 0, 1u);
  uint64_t v14 = a2;
  uint64_t v11 = (void *)sub_1CD5AC044(a1 + 296, &v14);
  __int16 v13 = v10;
  sub_1CC5820BC(v11, (uint64_t *)&v13);
  return v10;
}

uint64_t sub_1CD5AC044(uint64_t a1, uint64_t *a2)
{
  uint64_t v17 = *a2;
  int v18 = 0;
  sub_1CD40E370((uint64_t)&v15, a1, &v17, &v18);
  uint64_t v4 = v15;
  if (v16)
  {
    uint64_t v9 = *a2;
    v10[0] = 0;
    memset(v8, 0, sizeof(v8));
    v10[1] = 0;
    int v11 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v12 = 0;
    sub_1CC5836D8((void **)(a1 + 24), &v9);
    sub_1CD456CB4(v10);
    sub_1CD456CB4(v8);
    uint64_t v6 = *(void *)(a1 + 24);
    unsigned int v5 = -1227133513 * ((unint64_t)(*(void *)(a1 + 32) - v6) >> 3) - 1;
    *(_DWORD *)(v4 + sub_1CD521E44((uint64_t)this + 8) = v5;
  }
  else
  {
    unsigned int v5 = *(_DWORD *)(v15 + 8);
    uint64_t v6 = *(void *)(a1 + 24);
  }
  return v6 + 56 * v5 + 8;
}

llvm::MDNode *llvm::DIBuilder::createTempMacroFile(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t Impl = llvm::DIMacroFile::getImpl(*(void **)(a1 + 8), 3u, a3, a4, 0, 2, 1);
  uint64_t v7 = a1 + 296;
  uint64_t v16 = a2;
  long long v8 = (void *)sub_1CD5AC044(v7, &v16);
  *(void *)&long long v13 = Impl;
  sub_1CC5820BC(v8, (uint64_t *)&v13);
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  v17[0] = 0;
  v17[1] = 0;
  uint64_t v16 = (uint64_t)Impl;
  int v18 = 0;
  sub_1CBFCB9AC((uint64_t)v17, (uint64_t)&v13);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  unsigned int v21 = 0;
  uint64_t v9 = (const void *)*((void *)&v14 + 1);
  int64_t v10 = v15 - *((void *)&v14 + 1);
  if ((void)v15 != *((void *)&v14 + 1))
  {
    if (v10 < 0) {
      abort();
    }
    uint64_t v19 = (char *)operator new(v15 - *((void *)&v14 + 1));
    uint64_t v20 = v19;
    int v11 = &v19[8 * (v10 >> 3)];
    unsigned int v21 = v11;
    memmove(v19, v9, v10);
    uint64_t v20 = v11;
  }
  sub_1CD5AF2E0(v7, &v16, (uint64_t)v17);
  sub_1CD456CB4(v17);
  sub_1CD456CB4(&v13);
  return Impl;
}

llvm::MDNode *llvm::DIBuilder::createEnumerator(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t *a4)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  unsigned int v10 = *((_DWORD *)a4 + 2);
  if (v10 > 0x40) {
    operator new[]();
  }
  uint64_t v9 = *a4;
  int v5 = *((unsigned __int8 *)a4 + 12);
  if (a3) {
    uint64_t v6 = llvm::MDString::get(v4, a2, a3);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t Impl = llvm::DIEnumerator::getImpl(v4, (const llvm::APInt *)&v9, v5 != 0, (uint64_t)v6, 0, 1);
  if (v10 >= 0x41 && v9) {
    MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
  }
  return Impl;
}

llvm::MDNode *llvm::DIBuilder::createUnspecifiedType(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  return sub_1CD5AC354(*(uint64_t **)(a1 + 8), 59, a2, a3);
}

llvm::MDNode *sub_1CD5AC354(uint64_t *a1, int a2, unsigned __int8 *a3, size_t a4)
{
  if (a4) {
    uint64_t v6 = llvm::MDString::get(a1, a3, a4);
  }
  else {
    uint64_t v6 = 0;
  }
  return llvm::DIBasicType::getImpl(a1, a2, (uint64_t)v6, 0, 0, 0, 0, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createNullPtrType(uint64_t **this)
{
  return sub_1CD5AC354(this[1], 59, "decltype(nullptr)", 0x11uLL);
}

llvm::MDNode *llvm::DIBuilder::createBasicType(uint64_t a1, unsigned __int8 *a2, void *a3, uint64_t a4, int a5, int a6)
{
  uint64_t v9 = *(void **)(a1 + 8);
  if (a3) {
    a3 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a2, (size_t)a3);
  }
  return llvm::DIBasicType::getImpl(v9, 36, (uint64_t)a3, a4, 0, a5, a6, 0, 1);
}

uint64_t llvm::DIBuilder::createQualifiedType(uint64_t a1, int a2, uint64_t a3)
{
  return llvm::DIDerivedType::getImpl(*(void **)(a1 + 8), a2, 0, 0, 0, 0, a3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
}

uint64_t llvm::DIBuilder::createPtrAuthQualifiedType(uint64_t a1, uint64_t a2, char a3, int a4, unsigned __int16 a5, int a6, int a7)
{
  uint64_t v7 = *(void **)(a1 + 8);
  if (a4) {
    int v8 = 16;
  }
  else {
    int v8 = 0;
  }
  unsigned int v9 = v8 & 0xFFE00010 | a3 & 0xF | (32 * a5);
  if (a6) {
    int v10 = 0x200000;
  }
  else {
    int v10 = 0;
  }
  if (a7) {
    int v11 = 0x400000;
  }
  else {
    int v11 = 0;
  }
  return llvm::DIDerivedType::getImpl(v7, 17152, 0, 0, 0, 0, a2, 0, 0, 0, 0, v9 | v10 | v11 | 0x100000000, 0, 0, 0, 0, 1);
}

uint64_t llvm::DIBuilder::createPointerType(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unsigned __int8 *a6, size_t a7, uint64_t a8)
{
  long long v13 = *(void **)(a1 + 8);
  if (a7) {
    long long v14 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a6, a7);
  }
  else {
    long long v14 = 0;
  }
  return llvm::DIDerivedType::getImpl(v13, 15, (uint64_t)v14, 0, 0, 0, a2, a3, a4, 0, a5, 0, 0, 0, a8, 0, 1);
}

uint64_t llvm::DIBuilder::createMemberPointerType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  return llvm::DIDerivedType::getImpl(*(void **)(a1 + 8), 31, 0, 0, 0, 0, a2, a4, a5, 0, 0, 0, a6, a3, 0, 0, 1);
}

uint64_t llvm::DIBuilder::createReferenceType(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  return llvm::DIDerivedType::getImpl(*(void **)(a1 + 8), a2, 0, 0, 0, 0, a3, a4, a5, 0, a6, 0, 0, 0, 0, 0, 1);
}

uint64_t llvm::DIBuilder::createTypedef(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, unsigned char *a7, int a8, uint64_t a9)
{
  long long v13 = *(void **)(a1 + 8);
  if (a7)
  {
    if (*a7 == 16) {
      uint64_t v14 = 0;
    }
    else {
      uint64_t v14 = (uint64_t)a7;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  if (a4) {
    long long v15 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a3, a4);
  }
  else {
    long long v15 = 0;
  }
  return llvm::DIDerivedType::getImpl(v13, 22, (uint64_t)v15, a5, a6, v14, a2, 0, a8, 0, 0, 0, 0, 0, a9, 0, 1);
}

uint64_t llvm::DIBuilder::createInheritance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::IntegerType *a5, int a6)
{
  int v11 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 8) + 1960), a5, 0);
  uint64_t v13 = llvm::ValueAsMetadata::get(v11, v12);
  return llvm::DIDerivedType::getImpl(*(void **)(a1 + 8), 28, 0, 0, 0, a2, a3, 0, 0, a4, 0, 0, a6, v13, 0, 0, 1);
}

uint64_t llvm::DIBuilder::createMemberType(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12)
{
  uint64_t v16 = *(void **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  if (a4) {
    int v18 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a3, a4);
  }
  else {
    int v18 = 0;
  }
  return llvm::DIDerivedType::getImpl(v16, 13, (uint64_t)v18, a5, a6, v17, a11, a7, a8, a9, 0, 0, a10, 0, a12, 0, 1);
}

uint64_t llvm::DIBuilder::createBitFieldMemberType(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, llvm::IntegerType *a9, int a10, uint64_t a11, uint64_t a12)
{
  uint64_t v16 = *(uint64_t **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  int v18 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get((llvm::ConstantInt *)(*v16 + 1984), (unint64_t)a9, 0);
  uint64_t v20 = llvm::ValueAsMetadata::get(v18, v19);
  if (a4) {
    unsigned int v21 = llvm::MDString::get(v16, a3, a4);
  }
  else {
    unsigned int v21 = 0;
  }
  return llvm::DIDerivedType::getImpl(v16, 13, (uint64_t)v21, a5, a6, v17, a11, a7, 0, a8, 0, 0, a10 | 0x80000u, v20, a12, 0, 1);
}

uint64_t llvm::DIBuilder::createStaticMemberType(uint64_t a1, llvm::Value *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, int a8, llvm::ValueAsMetadata *a9, int a10)
{
  if (a2)
  {
    if (*(unsigned char *)a2 == 16) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  uint64_t v17 = *(uint64_t **)(a1 + 8);
  if (a9) {
    uint64_t v18 = llvm::ValueAsMetadata::get(a9, a2);
  }
  else {
    uint64_t v18 = 0;
  }
  if (a4) {
    uint64_t v19 = llvm::MDString::get(v17, a3, a4);
  }
  else {
    uint64_t v19 = 0;
  }
  return llvm::DIDerivedType::getImpl(v17, 13, (uint64_t)v19, a5, a6, v16, a7, 0, a10, 0, 0, 0, a8 | 0x1000u, v18, 0, 0, 1);
}

uint64_t llvm::DIBuilder::createObjCIVar(uint64_t a1, unsigned __int8 *a2, void *a3, unsigned char *a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9, uint64_t a10, uint64_t a11)
{
  uint64_t v16 = *(void **)(a1 + 8);
  if (a4)
  {
    if (*a4 == 16) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (uint64_t)a4;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  if (a3) {
    a3 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a2, (size_t)a3);
  }
  return llvm::DIDerivedType::getImpl(v16, 13, (uint64_t)a3, (uint64_t)a4, a5, v17, a10, a6, a7, a8, 0, 0, a9, a11, 0, 0, 1);
}

unsigned int *llvm::DIBuilder::createObjCProperty(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, int a5, unsigned __int8 *a6, void *a7, uint64_t a8, unsigned __int8 *a9, size_t a10, int a11, uint64_t a12)
{
  return sub_1CD5AEC64(*(uint64_t **)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createTemplateTypeParameter(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4, uint64_t a5, char a6)
{
  int v8 = *(void **)(a1 + 8);
  if (a4) {
    unsigned int v9 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a3, a4);
  }
  else {
    unsigned int v9 = 0;
  }

  return llvm::DITemplateTypeParameter::getImpl(v8, (uint64_t)v9, a5, a6, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createTemplateValueParameter(uint64_t a1, llvm::Value *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, char a6, llvm::ValueAsMetadata *this)
{
  int v11 = *(uint64_t **)(a1 + 8);
  if (this) {
    uint64_t v12 = llvm::ValueAsMetadata::get(this, a2);
  }
  else {
    uint64_t v12 = 0;
  }
  if (a4) {
    uint64_t v13 = llvm::MDString::get(v11, a3, a4);
  }
  else {
    uint64_t v13 = 0;
  }

  return llvm::DITemplateValueParameter::getImpl(v11, 48, (uint64_t)v13, a5, a6, v12, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createTemplateTemplateParameter(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4, uint64_t a5, unsigned __int8 *a6, size_t a7)
{
  int v10 = *(uint64_t **)(a1 + 8);
  int v11 = llvm::MDString::get(v10, a6, a7);
  if (a4) {
    uint64_t v12 = llvm::MDString::get(v10, a3, a4);
  }
  else {
    uint64_t v12 = 0;
  }

  return llvm::DITemplateValueParameter::getImpl(v10, 16646, (uint64_t)v12, a5, 0, (uint64_t)v11, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createTemplateParameterPack(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  int v8 = *(void **)(a1 + 8);
  if (a4) {
    unsigned int v9 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a3, a4);
  }
  else {
    unsigned int v9 = 0;
  }

  return llvm::DITemplateValueParameter::getImpl(v8, 16647, (uint64_t)v9, a5, 0, a6, 0, 1);
}

uint64_t llvm::DIBuilder::createStructType(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, unsigned int a8, unsigned int a9, uint64_t a10, uint64_t a11, int a12, uint64_t a13, unsigned __int8 *a14, size_t a15)
{
  uint64_t v16 = *(uint64_t **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v18 = sub_1CD5AED54(v16, 19, a3, a4, a5, a6, v17, a10, a7, a8, 0, a9, a11, a12, a13, 0, a14, a15, 0,
          0,
          0,
          0,
          0,
          0,
          0,
          1);
  uint64_t v19 = v18;
  unsigned int v21 = (unsigned __int8 *)v18;
  if (v18 && ((*(unsigned char *)(v18 + 1) & 0x7F) == 2 || *(_DWORD *)(v18 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v21);
  }
  return v19;
}

void llvm::DIBuilder::createSubroutineType(uint64_t a1, uint64_t a2, int a3, char a4)
{
}

uint64_t llvm::DIBuilder::createEnumerationType(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, unsigned int a8, uint64_t a9, uint64_t a10, unsigned __int8 *a11, size_t a12, char a13)
{
  uint64_t v14 = *(uint64_t **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  if (a13) {
    unsigned int v16 = 0x1000000;
  }
  else {
    unsigned int v16 = 0;
  }
  uint64_t v17 = sub_1CD5AED54(v14, 4, a3, a4, a5, a6, v15, a10, a7, a8, 0, v16, a9, 0, 0, 0, a11, a12, 0,
          0,
          0,
          0,
          0,
          0,
          0,
          1);
  unsigned int v18 = *(_DWORD *)(a1 + 64);
  if (v18 >= *(_DWORD *)(a1 + 68)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 56) + 8 * v1sub_1CD521E44((uint64_t)this + 8) = v17;
  ++*(_DWORD *)(a1 + 64);
  uint64_t v20 = (unsigned __int8 *)v17;
  if (v17 && ((*(unsigned char *)(v17 + 1) & 0x7F) == 2 || *(_DWORD *)(v17 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v20);
  }
  return v17;
}

uint64_t llvm::DIBuilder::createArrayType(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t Impl = llvm::DICompositeType::getImpl(*(void **)(a1 + 8), 1, 0, 0, 0, 0, a4, a2, a3, 0, 0, a5, 0, 0, 0, 0, 0, a6 & 0xFFFFFFFFFFFFFFF8, a7 & 0xFFFFFFFFFFFFFFF8,
           a8 & 0xFFFFFFFFFFFFFFF8,
           a9 & 0xFFFFFFFFFFFFFFF8,
           0,
           0,
           1);
  uint64_t v11 = Impl;
  uint64_t v13 = (unsigned __int8 *)Impl;
  if (Impl && ((*(unsigned char *)(Impl + 1) & 0x7F) == 2 || *(_DWORD *)(Impl + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v13);
  }
  return v11;
}

uint64_t llvm::DIBuilder::createVectorType(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t Impl = llvm::DICompositeType::getImpl(*(void **)(a1 + 8), 1, 0, 0, 0, 0, a4, a2, a3, 0, 0x800u, a5, 0, 0, 0, 0, 0, 0, 0,
           0,
           0,
           0,
           0,
           1);
  uint64_t v7 = Impl;
  unsigned int v9 = (unsigned __int8 *)Impl;
  if (Impl && ((*(unsigned char *)(Impl + 1) & 0x7F) == 2 || *(_DWORD *)(Impl + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v9);
  }
  return v7;
}

llvm::MDNode *llvm::DIBuilder::createObjectPointerType(llvm::MDNode *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *((_DWORD *)result + 7);
  if ((v8 & 0x400) == 0)
  {
    int v9 = v8 | 0x440;
    llvm::MDNode::clone(result, a3, a4, a5, a6, a7, a8, (uint64_t *)&v11);
    int v10 = v11;
    *((_DWORD *)v11 + 7) = v9;
    return llvm::MDNode::replaceWithUniquedImpl(v10);
  }
  return result;
}

void *llvm::DIBuilder::retainType(llvm::DIBuilder *this, llvm::DIScope *a2)
{
  uint64_t v3 = (unsigned __int8 *)a2;
  return sub_1CD5AD280((uint64_t)this + 104, &v3);
}

void *sub_1CD5AD280(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD5AE91C();
  }
  uint64_t result = (void *)(*(void *)a1 + 8 * v3);
  int v5 = *a2;
  void *result = v5;
  if (v5)
  {
    uint64_t result = (void *)llvm::MetadataTracking::track((uint64_t)result, v5, 2);
    LODWORD(v3) = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v3 + 1;
  return result;
}

uint64_t llvm::DIBuilder::createUnspecifiedParameter(llvm::DIBuilder *this)
{
  return 0;
}

uint64_t llvm::DIBuilder::createForwardDecl(uint64_t a1, int a2, unsigned __int8 *a3, size_t a4, unsigned char *a5, uint64_t a6, int a7, int a8, uint64_t a9, unsigned int a10, unsigned __int8 *a11, size_t a12)
{
  uint64_t v14 = *(uint64_t **)(a1 + 8);
  if (a5)
  {
    if (*a5 == 16) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = (uint64_t)a5;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v16 = sub_1CD5AED54(v14, a2, a3, a4, a6, a7, v15, 0, a9, a10, 0, 4u, 0, a8, 0, 0, a11, a12, 0,
          0,
          0,
          0,
          0,
          0,
          0,
          1);
  uint64_t v17 = v16;
  uint64_t v19 = (unsigned __int8 *)v16;
  if (v16 && ((*(unsigned char *)(v16 + 1) & 0x7F) == 2 || *(_DWORD *)(v16 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v19);
  }
  return v17;
}

uint64_t llvm::DIBuilder::createReplaceableCompositeType(uint64_t a1, int a2, unsigned __int8 *a3, size_t a4, unsigned char *a5, uint64_t a6, int a7, int a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned __int8 *a12, size_t a13, uint64_t a14)
{
  uint64_t v16 = *(uint64_t **)(a1 + 8);
  if (a5)
  {
    if (*a5 == 16) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (uint64_t)a5;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v18 = sub_1CD5AED54(v16, a2, a3, a4, a6, a7, v17, 0, a9, a10, 0, a11, 0, a8, 0, 0, a12, a13, 0,
          0,
          0,
          0,
          0,
          a14,
          2,
          1);
  uint64_t v19 = v18;
  unsigned int v21 = (unsigned __int8 *)v18;
  if (v18 && ((*(unsigned char *)(v18 + 1) & 0x7F) == 2 || *(_DWORD *)(v18 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v21);
  }
  return v19;
}

llvm::MDNode *llvm::DIBuilder::getOrCreateTypeArray(uint64_t a1, unsigned char **a2, uint64_t a3)
{
  v10[16] = *MEMORY[0x1E4F143B8];
  int v9 = 0;
  if (a3)
  {
    uint64_t v4 = a3;
    LODWORD(a3) = 0;
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = (uint64_t)*a2;
      if (*a2)
      {
        sub_1CB8F0DA8(*a2);
        LODWORD(a3) = v9;
      }
      if (a3 >= 0x10) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v10[a3] = v7;
      a3 = ++v9;
      ++a2;
      v6 -= 8;
    }
    while (v6);
  }
  return llvm::MDTuple::getImpl(*(void *)(a1 + 8), v10, a3, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::getOrCreateSubrange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return llvm::DISubrange::getImpl(*(void **)(a1 + 8), a2, a3, a4, a5, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createGlobalVariableExpression(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, size_t a6, uint64_t a7, int a8, uint64_t a9, char a10, char a11, llvm::MDNode *a12, uint64_t a13, uint64_t a14, int a15, uint64_t a16)
{
  uint64_t Impl = a12;
  uint64_t v18 = sub_1CD5AEED0(*(uint64_t **)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a13, a14, a15, a16, 1, 1);
  if (!a12) {
    uint64_t Impl = llvm::DIExpression::getImpl(*(void **)(a1 + 8), 0, 0, 0, 1);
  }
  uint64_t v19 = llvm::DIGlobalVariableExpression::getImpl(*(void **)(a1 + 8), (uint64_t)v18, (uint64_t)Impl, 0, 1);
  unsigned int v20 = *(_DWORD *)(a1 + 208);
  if (v20 >= *(_DWORD *)(a1 + 212)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 200) + 8 * v2llvm::MDNode::dumpTree(this, 0) = v19;
  ++*(_DWORD *)(a1 + 208);
  return v19;
}

llvm::MDNode *llvm::DIBuilder::createExpression(uint64_t a1, const void *a2, uint64_t a3)
{
  return llvm::DIExpression::getImpl(*(void **)(a1 + 8), a2, a3, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createTempGlobalVariableFwdDecl(uint64_t a1, uint64_t a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, size_t a6, uint64_t a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, int a13)
{
  return sub_1CD5AEED0(*(uint64_t **)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, 0, a11, a12, a13, 0, 2, 1);
}

unsigned __int8 *llvm::DIBuilder::createAutoVariable(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, char a8, int a9, int a10)
{
  return sub_1CC582A74(*(uint64_t **)(a1 + 8), a1 + 400, a2, a3, a4, 0, a5, a6, a7, a8, a9, a10, 0);
}

unsigned __int8 *llvm::DIBuilder::createParameterVariable(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, int a5, uint64_t a6, int a7, uint64_t a8, char a9, int a10, uint64_t a11)
{
  return sub_1CC582A74(*(uint64_t **)(a1 + 8), a1 + 400, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0, a11);
}

unsigned __int8 *llvm::DIBuilder::createLabel(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, int a7)
{
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(void **)(a1 + 8);
  if (a4) {
    uint64_t v14 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a3, a4);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t Impl = (unsigned __int8 *)llvm::DILabel::getImpl(v13, v12, (uint64_t)v14, a5, a6, 0, 1);
  uint64_t v19 = Impl;
  if (a7)
  {
    DISubprogram = llvm::getDISubprogram(a2);
    uint64_t v17 = sub_1CD5AF520(a1 + 424, (uint64_t *)&DISubprogram);
    sub_1CD5AD280((uint64_t)(v17 + 1), &v19);
  }
  return Impl;
}

uint64_t llvm::DIBuilder::createFunction(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, void *a6, void *a7, int a8, void *a9, int a10, unsigned int a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unsigned __int8 *a17, size_t a18)
{
  uint64_t v19 = *(uint64_t **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      unsigned int v20 = 0;
    }
    else {
      unsigned int v20 = a2;
    }
    uint64_t v27 = v20;
  }
  else
  {
    uint64_t v27 = 0;
  }
  if ((a12 & 8) != 0)
  {
    uint64_t v26 = *(void *)(a1 + 16);
    uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)v19, 0, 0, 2, 1);
    uint64_t v22 = sub_1CC583098(v19, v27, a3, a4, a5, a6, a7, a8, a9, a10, 0, 0, __SPAIR64__(a12, a11), v26, a13, a14, (uint64_t)Impl, a15, a16,
            a17,
            a18,
            1,
            1);
    unsigned int v24 = *(_DWORD *)(a1 + 160);
    if (v24 >= *(_DWORD *)(a1 + 164)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 152) + 8 * v24) = v22;
    ++*(_DWORD *)(a1 + 160);
  }
  else
  {
    unsigned int v21 = llvm::MDTuple::getImpl((uint64_t)v19, 0, 0, 2, 1);
    uint64_t v22 = sub_1CC583098(v19, v27, a3, a4, a5, a6, a7, a8, a9, a10, 0, 0, __SPAIR64__(a12, a11), 0, a13, a14, (uint64_t)v21, a15, a16,
            a17,
            a18,
            0,
            1);
  }
  unint64_t v34 = (unsigned __int8 *)v22;
  if (v22 && ((*(unsigned char *)(v22 + 1) & 0x7F) == 2 || *(_DWORD *)(v22 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v34);
  }
  return v22;
}

uint64_t llvm::DIBuilder::createTempFunctionFwdDecl(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, void *a6, void *a7, int a8, void *a9, int a10, unsigned int a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v16 = *(uint64_t **)(a1 + 8);
  if (a2 && *a2 == 16) {
    a2 = 0;
  }
  if ((a12 & 8) != 0) {
    uint64_t v17 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v17 = 0;
  }
  return sub_1CC583098(v16, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0, 0, __SPAIR64__(a12, a11), v17, a13, a14, 0, a15, 0,
           "",
           0,
           2,
           1);
}

uint64_t llvm::DIBuilder::createMethod(uint64_t a1, void *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, void *a6, void *a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v15 = *(uint64_t **)(a1 + 8);
  if ((a12 & 0x800000000) != 0)
  {
    uint64_t v16 = sub_1CC583098(v15, a2, a3, a4, a5, a6, a7, a8, a9, a8, a11, a10, a12, *(void *)(a1 + 16), a13, 0, 0, a14, 0,
            "",
            0,
            1,
            1);
    unsigned int v17 = *(_DWORD *)(a1 + 160);
    if (v17 >= *(_DWORD *)(a1 + 164)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 152) + 8 * v17) = v16;
    ++*(_DWORD *)(a1 + 160);
  }
  else
  {
    uint64_t v16 = sub_1CC583098(v15, a2, a3, a4, a5, a6, a7, a8, a9, a8, a11, a10, a12, 0, a13, 0, 0, a14, 0,
            "",
            0,
            0,
            1);
  }
  uint64_t v19 = (unsigned __int8 *)v16;
  if (v16 && ((*(unsigned char *)(v16 + 1) & 0x7F) == 2 || *(_DWORD *)(v16 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v19);
  }
  return v16;
}

llvm::MDNode *llvm::DIBuilder::createNameSpace(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, char a5)
{
  uint64_t v6 = *(void **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (a4) {
    int v8 = llvm::MDString::get(*(uint64_t **)(a1 + 8), a3, a4);
  }
  else {
    int v8 = 0;
  }

  return llvm::DINamespace::getImpl(v6, v7, (uint64_t)v8, a5, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createModule(uint64_t a1, unsigned char *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, void *a6, unsigned __int8 *a7, size_t a8, unsigned __int8 *a9, size_t a10, uint64_t a11, int a12, char a13)
{
  unsigned int v17 = *(uint64_t **)(a1 + 8);
  if (a2)
  {
    if (*a2 == 16) {
      uint64_t v18 = 0;
    }
    else {
      uint64_t v18 = (uint64_t)a2;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  return sub_1CD5AEFD4(v17, a11, v18, a3, a4, a5, a6, a8, a7, a8, a9, a10, a12, a13, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createLexicalBlockFile(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return llvm::DILexicalBlockFile::getImpl(*(void **)(a1 + 8), a2, a3, a4, 0, 1);
}

llvm::MDNode *llvm::DIBuilder::createLexicalBlock(uint64_t a1, unsigned char *a2, uint64_t a3, int a4, unsigned int a5)
{
  int v5 = *(void **)(a1 + 8);
  if (a2 && *a2 == 16) {
    a2 = 0;
  }
  return llvm::DILexicalBlock::getImpl(v5, (uint64_t)a2, a3, a4, a5, 1, 1);
}

uint64_t llvm::DIBuilder::insertDeclare(uint64_t a1, llvm::ValueAsMetadata *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return llvm::DIBuilder::insertDeclare(a1, a2, a3, a4, a5, *(void *)(a6 + 40), a6);
}

{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  uint64_t v6 = *(void *)(a6 + 40);
  if (v6 == a6 + 40)
  {
    uint64_t v7 = 0;
  }
  else
  {
    if (v6) {
      int v8 = v6 - 24;
    }
    else {
      int v8 = 0;
    }
    if (*(unsigned __int8 *)(v8 + 16) - 29 >= 0xB) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v8;
    }
  }
  return llvm::DIBuilder::insertDeclare(a1, a2, a3, a4, a5, a6, v7);
}

uint64_t llvm::DIBuilder::insertDeclare(uint64_t a1, llvm::ValueAsMetadata *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v34[3] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 24))
  {
    uint64_t v14 = *(uint64_t ***)a1;
    if (byte_1EBCD84D8) {
      int v15 = 55;
    }
    else {
      int v15 = 56;
    }
    *(void *)(a1 + 24) = llvm::Intrinsic::getDeclaration(v14, v15, 0, 0);
  }
  v25[0] = (void *)a3;
  if (a3 && ((*(unsigned char *)(a3 + 1) & 0x7F) == 2 || *(_DWORD *)(a3 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), (unsigned __int8 **)v25);
  }
  v25[0] = (void *)a4;
  if (a4 && ((*(unsigned char *)(a4 + 1) & 0x7F) == 2 || *(_DWORD *)(a4 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), (unsigned __int8 **)v25);
  }
  uint64_t v16 = *(void *)(a1 + 8);
  unsigned int v17 = (unsigned __int8 *)llvm::ValueAsMetadata::get(this, this);
  v34[0] = llvm::MetadataAsValue::get(v16, v17);
  v34[1] = llvm::MetadataAsValue::get(*(void *)(a1 + 8), (unsigned __int8 *)a3);
  v34[2] = llvm::MetadataAsValue::get(*(void *)(a1 + 8), (unsigned __int8 *)a4);
  uint64_t v18 = *(void *)(a5 + 16);
  uint64_t v19 = (void *)(v18 & 0xFFFFFFFFFFFFFFF8);
  if ((v18 & 4) != 0) {
    uint64_t v19 = (void *)*v19;
  }
  v25[0] = v26;
  v25[1] = (void *)0x200000000;
  v26[6] = v19;
  v26[7] = &v32;
  v26[8] = &v33;
  v26[9] = 0;
  int v27 = 0;
  __int16 v28 = 512;
  char v29 = 7;
  uint64_t v26[4] = 0;
  v26[5] = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  long long v32 = &unk_1F2616E88;
  uint64_t v33 = &unk_1F2617008;
  sub_1CC582D48((uint64_t)v25, (unsigned __int8 *)a5, a6, a7);
  uint64_t v20 = *(void *)(a1 + 24);
  if (v20) {
    unsigned int v21 = *(uint64_t ***)(v20 + 24);
  }
  else {
    unsigned int v21 = 0;
  }
  v24[16] = 257;
  uint64_t v22 = sub_1CB845BAC((uint64_t *)v25, v21, (uint64_t **)v20, v34, 3, (uint64_t)v24, 0);
  if (v25[0] != v26) {
    free(v25[0]);
  }
  return v22;
}

uint64_t llvm::DIBuilder::insertLabel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v26[1] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 40)) {
    *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = llvm::Intrinsic::getDeclaration(*(uint64_t ***)a1, 57, 0, 0);
  }
  v17[0] = (void *)a2;
  if (a2 && ((*(unsigned char *)(a2 + 1) & 0x7F) == 2 || *(_DWORD *)(a2 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), (unsigned __int8 **)v17);
  }
  v26[0] = llvm::MetadataAsValue::get(*(void *)(a1 + 8), (unsigned __int8 *)a2);
  uint64_t v10 = *(void *)(a3 + 16);
  uint64_t v11 = (void *)(v10 & 0xFFFFFFFFFFFFFFF8);
  if ((v10 & 4) != 0) {
    uint64_t v11 = (void *)*v11;
  }
  v17[0] = v18;
  v17[1] = (void *)0x200000000;
  v18[6] = v11;
  v18[7] = &v24;
  v18[8] = &v25;
  v18[9] = 0;
  int v19 = 0;
  __int16 v20 = 512;
  char v21 = 7;
  _DWORD v18[4] = 0;
  uint64_t v18[5] = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  unsigned int v24 = &unk_1F2616E88;
  unsigned int v25 = &unk_1F2617008;
  sub_1CC582D48((uint64_t)v17, (unsigned __int8 *)a3, a4, a5);
  uint64_t v12 = *(void *)(a1 + 40);
  if (v12) {
    uint64_t v13 = *(uint64_t ***)(v12 + 24);
  }
  else {
    uint64_t v13 = 0;
  }
  v16[16] = 257;
  uint64_t v14 = sub_1CB845BAC((uint64_t *)v17, v13, (uint64_t **)v12, v26, 1, (uint64_t)v16, 0);
  if (v17[0] != v18) {
    free(v17[0]);
  }
  return v14;
}

uint64_t llvm::DIBuilder::insertDbgValueIntrinsic(uint64_t a1, llvm::ValueAsMetadata *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  Declaration = *(llvm::Value **)(a1 + 32);
  if (!Declaration)
  {
    Declaration = (llvm::Value *)llvm::Intrinsic::getDeclaration(*(uint64_t ***)a1, 58, 0, 0);
    *(void *)(a1 + 32) = Declaration;
  }

  return llvm::DIBuilder::insertDbgIntrinsic(a1, Declaration, this, a3, a4, a5, a6, a7);
}

uint64_t llvm::DIBuilder::insertDbgIntrinsic(uint64_t a1, llvm::Value *a2, llvm::ValueAsMetadata *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v33[3] = *MEMORY[0x1E4F143B8];
  v24[0] = (void *)a4;
  if (a4 && ((*(unsigned char *)(a4 + 1) & 0x7F) == 2 || *(_DWORD *)(a4 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), (unsigned __int8 **)v24);
  }
  v24[0] = (void *)a5;
  if (a5 && ((*(unsigned char *)(a5 + 1) & 0x7F) == 2 || *(_DWORD *)(a5 + 12))) {
    sub_1CD5AB7E0((uint64_t *)(a1 + 344), (unsigned __int8 **)v24);
  }
  uint64_t v16 = *(void *)(a1 + 8);
  unsigned int v17 = (unsigned __int8 *)llvm::ValueAsMetadata::get(this, a2);
  v33[0] = llvm::MetadataAsValue::get(v16, v17);
  v33[1] = llvm::MetadataAsValue::get(*(void *)(a1 + 8), (unsigned __int8 *)a4);
  v33[2] = llvm::MetadataAsValue::get(*(void *)(a1 + 8), (unsigned __int8 *)a5);
  uint64_t v18 = *(void *)(a6 + 16);
  int v19 = (void *)(v18 & 0xFFFFFFFFFFFFFFF8);
  if ((v18 & 4) != 0) {
    int v19 = (void *)*v19;
  }
  v24[0] = v25;
  v24[1] = (void *)0x200000000;
  v25[6] = v19;
  v25[7] = &v31;
  unsigned char v25[8] = &v32;
  void v25[9] = 0;
  int v26 = 0;
  __int16 v27 = 512;
  char v28 = 7;
  uint64_t v25[4] = 0;
  uint64_t v25[5] = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = &unk_1F2616E88;
  long long v32 = &unk_1F2617008;
  sub_1CC582D48((uint64_t)v24, (unsigned __int8 *)a6, a7, a8);
  if (a2) {
    __int16 v20 = (uint64_t **)*((void *)a2 + 3);
  }
  else {
    __int16 v20 = 0;
  }
  v23[16] = 257;
  uint64_t v21 = sub_1CB845BAC((uint64_t *)v24, v20, (uint64_t **)a2, v33, 3, (uint64_t)v23, 0);
  if (v24[0] != v25) {
    free(v24[0]);
  }
  return v21;
}

void llvm::DIBuilder::replaceVTableHolder(uint64_t a1, llvm::MDNode **a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  unsigned int v17 = v6;
  if (v6)
  {
    llvm::MetadataTracking::track((uint64_t)&v17, (unsigned __int8 *)v6, 2);
    uint64_t v7 = v17;
  }
  else
  {
    uint64_t v7 = 0;
  }
  llvm::MDNode::replaceOperandWith(v7, 5, (llvm::Metadata *)a3);
  int v8 = (unsigned __int8 *)v17;
  *a2 = v17;
  if (v8)
  {
    llvm::MetadataTracking::untrack((uint64_t)&v17, v8);
    int v9 = *a2;
  }
  else
  {
    int v9 = 0;
  }
  if (v9 == (llvm::MDNode *)a3 && (*(unsigned char *)(a3 + 1) & 0x7F) != 2 && !*(_DWORD *)(a3 + 12))
  {
    uint64_t v10 = *(unsigned int *)(a3 + 8);
    if (v10)
    {
      uint64_t v11 = (uint64_t *)(a1 + 344);
      uint64_t v12 = -8 * v10;
      do
      {
        uint64_t v13 = *(unsigned char **)(a3 + v12);
        if (v13)
        {
          int v14 = sub_1CB8F0DA8(v13);
          uint64_t v15 = *(void *)(a3 + v12);
          if (v14) {
            BOOL v16 = v15 == 0;
          }
          else {
            BOOL v16 = 1;
          }
          if (!v16)
          {
            unsigned int v17 = *(llvm::MDNode **)(a3 + v12);
            if ((*(unsigned char *)(v15 + 1) & 0x7F) == 2 || *(_DWORD *)(v15 + 12)) {
              sub_1CD5AB7E0(v11, (unsigned __int8 **)&v17);
            }
          }
        }
        v12 += 8;
      }
      while (v12);
    }
  }
}

uint64_t llvm::DIBuilder::replaceArrays(uint64_t a1, unsigned __int8 **a2, llvm::Metadata *a3, llvm::Metadata *a4)
{
  int v8 = *a2;
  uint64_t v10 = v8;
  if (v8)
  {
    llvm::MetadataTracking::track((uint64_t)&v10, v8, 2);
    int v8 = v10;
  }
  if (a3)
  {
    llvm::MDNode::replaceOperandWith((llvm::MDNode *)v8, 4, a3);
    int v8 = v10;
  }
  if (a4)
  {
    llvm::MDNode::replaceOperandWith((llvm::MDNode *)v8, 6, a4);
    int v8 = v10;
  }
  *a2 = v8;
  uint64_t result = llvm::MetadataTracking::untrack((uint64_t)&v10, v8);
  if (((*a2)[1] & 0x7F) != 2 && !*((_DWORD *)*a2 + 3))
  {
    if (a3)
    {
      uint64_t v10 = (unsigned __int8 *)a3;
      if ((*((unsigned char *)a3 + 1) & 0x7F) == 2 || *((_DWORD *)a3 + 3)) {
        uint64_t result = sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v10);
      }
    }
    if (a4)
    {
      uint64_t v10 = (unsigned __int8 *)a4;
      if ((*((unsigned char *)a4 + 1) & 0x7F) == 2 || *((_DWORD *)a4 + 3)) {
        return sub_1CD5AB7E0((uint64_t *)(a1 + 344), &v10);
      }
    }
  }
  return result;
}

char *sub_1CD5AE724(uint64_t *a1, int a2, uint64_t a3, unsigned __int8 *a4, size_t a5, char a6, unsigned __int8 *a7, void *a8, int a9, unsigned __int8 *a10, size_t a11, int a12, unint64_t a13, unint64_t a14, long long a15, uint64_t a16, uint64_t a17, char a18, char a19, int a20,char a21,unsigned __int8 *a22,size_t a23,unsigned __int8 *a24,size_t a25,int a26)
{
  uint64_t v29 = (void *)a11;
  if (a5) {
    uint64_t v30 = llvm::MDString::get(a1, a4, a5);
  }
  else {
    uint64_t v30 = 0;
  }
  if (a8) {
    a8 = llvm::MDString::get(a1, a7, (size_t)a8);
  }
  if (a11) {
    uint64_t v29 = llvm::MDString::get(a1, a10, a11);
  }
  if (a23) {
    uint64_t v31 = llvm::MDString::get(a1, a22, a23);
  }
  else {
    uint64_t v31 = 0;
  }
  if (a25) {
    long long v32 = llvm::MDString::get(a1, a24, a25);
  }
  else {
    long long v32 = 0;
  }

  return llvm::DICompileUnit::getImpl((uint64_t)a1, a2, a3, (uint64_t)v30, a6, (uint64_t)a8, a9, (uint64_t)v29, a12, __PAIR128__(a14, a13), a15, a16, a17, a18, a19, a20, a21, (uint64_t)v31, (uint64_t)v32,
           a26);
}

void sub_1CD5AE91C()
{
}

uint64_t sub_1CD5AE9C0(uint64_t result, unsigned __int8 **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v9 = result;
    uint64_t v3 = *(unsigned __int8 ***)result;
    uint64_t v4 = 8 * v2;
    do
    {
      *a2 = *v3;
      if (*v3)
      {
        uint64_t result = llvm::MetadataTracking::retrack((uint64_t)v3, *v3, (uint64_t)a2);
        *uint64_t v3 = 0;
      }
      ++v3;
      ++a2;
      v4 -= 8;
    }
    while (v4);
    uint64_t v5 = *(unsigned int *)(v9 + 8);
    if (v5)
    {
      uint64_t v6 = 8 * v5;
      uint64_t v7 = *(void *)v9 - 8;
      do
      {
        uint64_t result = v7 + v6;
        int v8 = *(unsigned __int8 **)(v7 + v6);
        if (v8) {
          uint64_t result = llvm::MetadataTracking::untrack(result, v8);
        }
        v6 -= 8;
      }
      while (v6);
    }
  }
  return result;
}

llvm::MDNode *sub_1CD5AEA68(uint64_t *a1, unsigned __int8 *a2, void *a3, unsigned __int8 *a4, void *a5, uint64_t a6, uint64_t a7, int a8, unsigned __int8 a9)
{
  if (*(unsigned char *)(a6 + 24))
  {
    size_t v17 = *(void *)(a6 + 16);
    if (v17) {
      uint64_t v9 = llvm::MDString::get(a1, *(unsigned __int8 **)(a6 + 8), v17);
    }
    else {
      uint64_t v9 = 0;
    }
    unsigned int v18 = *(_DWORD *)a6 & 0xFFFFFF00;
    int v19 = *(_DWORD *)a6;
    char v20 = 1;
  }
  else
  {
    char v20 = 0;
    int v19 = 0;
    unsigned int v18 = 0;
  }
  if (a3) {
    a3 = llvm::MDString::get(a1, a2, (size_t)a3);
  }
  if (a5) {
    a5 = llvm::MDString::get(a1, a4, (size_t)a5);
  }
  LODWORD(v26) = v18 | v19;
  *((void *)&v26 + 1) = v9;
  char v27 = v20;
  if (*(unsigned char *)(a7 + 16))
  {
    size_t v21 = *(void *)(a7 + 8);
    if (v21) {
      uint64_t v22 = llvm::MDString::get(a1, *(unsigned __int8 **)a7, v21);
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v23 = 1;
  }
  else
  {
    uint64_t v23 = 0;
    uint64_t v22 = 0;
  }
  return llvm::DIFile::getImpl(a1, (uint64_t)a3, (uint64_t)a5, &v26, (uint64_t)v22, v23, a8, a9);
}

llvm::MDNode *sub_1CD5AEBAC(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4, size_t a5, unsigned __int8 *a6, size_t a7, int a8, unsigned __int8 a9)
{
  if (a5) {
    uint64_t v15 = llvm::MDString::get(a1, a4, a5);
  }
  else {
    uint64_t v15 = 0;
  }
  if (a7) {
    BOOL v16 = llvm::MDString::get(a1, a6, a7);
  }
  else {
    BOOL v16 = 0;
  }

  return llvm::DIMacro::getImpl(a1, a2, a3, (unint64_t)v15, (unint64_t)v16, a8, a9);
}

unsigned int *sub_1CD5AEC64(uint64_t *a1, unsigned __int8 *a2, size_t a3, uint64_t a4, int a5, unsigned __int8 *a6, void *a7, uint64_t a8, unsigned __int8 *a9, size_t a10, int a11, uint64_t a12, int a13, char a14)
{
  if (a3) {
    size_t v17 = llvm::MDString::get(a1, a2, a3);
  }
  else {
    size_t v17 = 0;
  }
  if (a7) {
    a7 = llvm::MDString::get(a1, a6, (size_t)a7);
  }
  if (a10) {
    unsigned int v18 = llvm::MDString::get(a1, a9, a10);
  }
  else {
    unsigned int v18 = 0;
  }

  return llvm::DIObjCProperty::getImpl(a1, (uint64_t)v17, a4, a5, (uint64_t)a7, (uint64_t)v18, a11, a12, a13, a14);
}

uint64_t sub_1CD5AED54(uint64_t *a1, int a2, unsigned __int8 *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, uint64_t a11, unsigned int a12, uint64_t a13, int a14, uint64_t a15, uint64_t a16, unsigned __int8 *a17, size_t a18, unint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,char a26)
{
  char v27 = a17;
  if (a4)
  {
    char v28 = llvm::MDString::get(a1, a3, a4);
    char v27 = a17;
    uint64_t v29 = (uint64_t)v28;
  }
  else
  {
    uint64_t v29 = 0;
  }
  if (a18) {
    uint64_t v30 = llvm::MDString::get(a1, v27, a18);
  }
  else {
    uint64_t v30 = 0;
  }

  return llvm::DICompositeType::getImpl(a1, a2, v29, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, (uint64_t)v30, a19, a20, a21,
           a22,
           a23,
           a24,
           a25,
           a26);
}

llvm::MDNode *sub_1CD5AEED0(uint64_t *a1, uint64_t a2, unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, size_t a6, uint64_t a7, int a8, uint64_t a9, char a10, char a11, uint64_t a12, uint64_t a13, int a14, uint64_t a15, int a16, char a17)
{
  if (a4)
  {
    int v19 = a5;
    char v20 = llvm::MDString::get(a1, a3, a4);
    a5 = v19;
    uint64_t v21 = (uint64_t)v20;
  }
  else
  {
    uint64_t v21 = 0;
  }
  if (a6) {
    uint64_t v22 = llvm::MDString::get(a1, a5, a6);
  }
  else {
    uint64_t v22 = 0;
  }

  return llvm::DIGlobalVariable::getImpl(a1, a2, v21, (uint64_t)v22, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
}

llvm::MDNode *sub_1CD5AEFD4(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, size_t a5, unsigned __int8 *a6, void *a7, uint64_t a8, unsigned __int8 *a9, size_t a10, unsigned __int8 *a11, size_t a12, int a13, char a14, int a15, char a16)
{
  if (a5) {
    int v19 = llvm::MDString::get(a1, a4, a5);
  }
  else {
    int v19 = 0;
  }
  if (a7) {
    a7 = llvm::MDString::get(a1, a6, (size_t)a7);
  }
  if (a10) {
    char v20 = llvm::MDString::get(a1, a9, a10);
  }
  else {
    char v20 = 0;
  }
  if (a12) {
    uint64_t v21 = llvm::MDString::get(a1, a11, a12);
  }
  else {
    uint64_t v21 = 0;
  }

  return llvm::DIModule::getImpl(a1, a2, a3, (uint64_t)v19, (uint64_t)a7, (uint64_t)v20, (uint64_t)v21, a13, a14, a15, a16);
}

void sub_1CD5AF0F4(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD8458, 0, 0);
  byte_1EBCD84D8 = 0;
  qword_1EBCD84E0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD84E8 = 0;
  qword_1EBCD8458 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD84F0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD84F8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD8510 = (uint64_t)&qword_1EBCD84F8;
  sub_1CD5AF1E4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8458);
}

__n128 sub_1CD5AF1E4(__n128 *a1, char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD8458, "use-dbg-addr", 0xCuLL);
  __n128 result = *a1;
  xmmword_1EBCD8478 = (__int128)*a1;
  uint64_t v7 = *a2;
  byte_1EBCD84D8 = **a2;
  byte_1EBCD84E9 = 1;
  byte_1EBCD84E8 = *v7;
  word_1EBCD8462 = (32 * (*a3 & 3)) | word_1EBCD8462 & 0xFF9F;
  return result;
}

void sub_1CD5AF26C()
{
}

uint64_t sub_1CD5AF2E0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v8 = *a2;
  int v9 = 0;
  sub_1CD40E370((uint64_t)&v10, a1, &v8, &v9);
  uint64_t v6 = (void *)(a1 + 24);
  if (!v11) {
    return *v6 + 56 * *(unsigned int *)(v10 + 8);
  }
  *(_DWORD *)(v10 + sub_1CD521E44((uint64_t)this + 8) = -1227133513 * ((*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
  sub_1CD5AF398((uint64_t)v6, a2, a3);
  return *(void *)(a1 + 32) - 56;
}

void sub_1CD5AF398(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void **)(a1 + 8);
  if ((unint64_t)v4 < *(void *)(a1 + 16))
  {
    *uint64_t v4 = *a2;
    uint64_t v5 = v4 + 7;
    sub_1CD46AEB4((uint64_t)(v4 + 1), a3);
  }
  else
  {
    uint64_t v5 = sub_1CC583220((void **)a1, a2, a3);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v5;
}

uint64_t sub_1CD5AF3F0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v14 = v3;
    uint64_t v15 = v4;
    uint64_t v6 = a2;
    uint64_t v7 = result;
    uint64_t v8 = (void **)(result + 24);
    do
    {
      uint64_t v11 = *v6;
      __n128 result = sub_1CC583388((uint64_t)v12, v7, &v11);
      if (v13)
      {
        uint64_t v9 = *v6;
        v12[0] = *v6;
        uint64_t v10 = *(uint64_t **)(v7 + 32);
        if ((unint64_t)v10 >= *(void *)(v7 + 40))
        {
          __n128 result = (uint64_t)sub_1CBC13470(v8, v12);
        }
        else
        {
          uint64_t *v10 = v9;
          __n128 result = (uint64_t)(v10 + 1);
        }
        *(void *)(v7 + 32) = result;
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

uint64_t sub_1CD5AF490(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CC583418(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC5834AC(a2, a3, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

void *sub_1CD5AF520(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5AF59C(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x100000000;
  }
  return v5;
}

void *sub_1CD5AF59C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5AF650(a1, v6);
  char v8 = 0;
  sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5AF650(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(char **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5AF71C((char **)a1, (uint64_t)v4, (uint64_t)&v4[32 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

char **sub_1CD5AF71C(char **result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  unint64_t v5 = result;
  result[1] = 0;
  uint64_t v6 = *((unsigned int *)result + 4);
  if (v6)
  {
    int v7 = *result;
    uint64_t v8 = 32 * v6;
    do
    {
      *(void *)int v7 = -4096;
      v7 += 32;
      v8 -= 32;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v12 = 0;
        sub_1CD41F538((uint64_t)*v5, *((_DWORD *)v5 + 4), v9, &v12);
        uint64_t v10 = v12;
        *uint64_t v12 = *(void *)v4;
        void v10[2] = 0x100000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD5AF808(v11, v4 + 8);
        }
        ++*((_DWORD *)v5 + 2);
        uint64_t result = sub_1CD5170A4((char **)(v4 + 8));
      }
      v4 += 32;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t sub_1CD5AF808(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v9 = *(char **)a1;
        if (v5)
        {
          uint64_t v10 = 0;
          do
          {
            sub_1CB8F69CC((unsigned __int8 **)&v9[v10], (unsigned __int8 **)&v4[v10]);
            v10 += 8;
          }
          while (8 * v5 != v10);
          uint64_t v6 = *(unsigned int *)(a1 + 8);
          uint64_t v11 = &v9[v10];
          uint64_t v9 = *(char **)a1;
        }
        else
        {
          uint64_t v11 = *(char **)a1;
        }
        uint64_t v12 = &v9[8 * v6];
        if (v12 != v11)
        {
          char v13 = (unsigned __int8 **)(v12 - 8);
          do
          {
            if (*v13) {
              llvm::MetadataTracking::untrack((uint64_t)v13, *v13);
            }
          }
          while (v13-- != (unsigned __int8 **)v11);
        }
        *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v5;
        uint64_t v15 = *(unsigned int *)(a2 + 8);
        if (v15)
        {
          uint64_t v16 = 8 * v15;
          uint64_t v17 = *(void *)a2 - 8;
          do
          {
            unsigned int v18 = *(unsigned __int8 **)(v17 + v16);
            if (v18) {
              llvm::MetadataTracking::untrack(v17 + v16, v18);
            }
            v16 -= 8;
          }
          while (v16);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            uint64_t v19 = 8 * v6;
            uint64_t v20 = *(void *)a1 - 8;
            do
            {
              uint64_t v21 = *(unsigned __int8 **)(v20 + v19);
              if (v21) {
                llvm::MetadataTracking::untrack(v20 + v19, v21);
              }
              v19 -= 8;
            }
            while (v19);
          }
          *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
          sub_1CD5AF26C();
        }
        if (v6)
        {
          int v7 = *(unsigned __int8 ***)a1;
          uint64_t v8 = 8 * v6;
          do
          {
            sub_1CB8F69CC(v7, (unsigned __int8 **)v4);
            v4 += 8;
            ++v7;
            v8 -= 8;
          }
          while (v8);
        }
        else
        {
          uint64_t v6 = 0;
        }
        uint64_t v22 = *(char **)a2;
        uint64_t v23 = *(unsigned int *)(a2 + 8);
        if (v6 != v23)
        {
          unsigned int v24 = (unsigned __int8 **)(*(void *)a1 + 8 * v6);
          unsigned int v25 = (unsigned __int8 **)&v22[8 * v6];
          uint64_t v26 = 8 * v23 - 8 * v6;
          do
          {
            void *v24 = *v25;
            if (*v25)
            {
              llvm::MetadataTracking::retrack((uint64_t)v25, *v25, (uint64_t)v24);
              void *v25 = 0;
            }
            ++v25;
            ++v24;
            v26 -= 8;
          }
          while (v26);
          uint64_t v22 = *(char **)a2;
        }
        *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v5;
        uint64_t v27 = *(unsigned int *)(a2 + 8);
        if (v27)
        {
          uint64_t v28 = 8 * v27;
          uint64_t v29 = v22 - 8;
          do
          {
            uint64_t v30 = *(unsigned __int8 **)&v29[v28];
            if (v30) {
              llvm::MetadataTracking::untrack((uint64_t)&v29[v28], v30);
            }
            v28 -= 8;
          }
          while (v28);
        }
      }
      *(_DWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0;
    }
    else
    {
      sub_1CD5AFA1C((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CD5AFA1C(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    int v7 = v4 - 8;
    do
    {
      uint64_t v8 = *(unsigned __int8 **)&v7[v6];
      if (v8) {
        llvm::MetadataTracking::untrack((uint64_t)&v7[v6], v8);
      }
      v6 -= 8;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

llvm::DataLayout *llvm::DataLayout::DataLayout(llvm::DataLayout *this, const llvm::Module *a2)
{
  *((_WORD *)this + 4) = 0;
  *((_WORD *)this + 1llvm::MDNode::dumpTree(this, 0) = 0;
  *((void *)this + 4) = (char *)this + 56;
  *(_OWORD *)((char *)this + 4llvm::MDNode::dumpTree(this, 0) = xmmword_1CD96EEC0;
  *((void *)this + sub_1CD521E44((uint64_t)this + 8) = (char *)this + 80;
  *((void *)this + 9) = 0x1000000000;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 2sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 29) = (char *)this + 248;
  *((void *)this + 3llvm::MDNode::dumpTree(this, 0) = 0x800000000;
  *((void *)this + 47) = 0;
  *((void *)this + 4sub_1CD521E44((uint64_t)this + 8) = (char *)this + 400;
  *((void *)this + 49) = 0x800000000;
  sub_1CB94E404((uint64_t)this, (uint64_t)a2 + 272);
  return this;
}

uint64_t llvm::DataLayout::getPointerABIAlignment(llvm::DataLayout *this, unsigned int a2)
{
  if (!a2) {
    goto LABEL_10;
  }
  uint64_t v2 = *((unsigned int *)this + 60);
  uint64_t v3 = (_DWORD *)*((void *)this + 29);
  if (v2)
  {
    uint64_t v3 = (_DWORD *)*((void *)this + 29);
    unint64_t v4 = *((unsigned int *)this + 60);
    do
    {
      unint64_t v5 = v4 >> 1;
      uint64_t v6 = &v3[4 * (v4 >> 1)];
      unsigned int v7 = v6[2];
      uint64_t v8 = v6 + 4;
      v4 += ~(v4 >> 1);
      if (v7 < a2) {
        uint64_t v3 = v8;
      }
      else {
        unint64_t v4 = v5;
      }
    }
    while (v4);
  }
  if (v3 == (_DWORD *)(*((void *)this + 29) + 16 * v2) || v3[2] != a2) {
LABEL_10:
  }
    uint64_t v3 = (_DWORD *)*((void *)this + 29);
  return *(unsigned __int8 *)v3;
}

uint64_t llvm::DataLayout::getPointerPrefAlignment(llvm::DataLayout *this, unsigned int a2)
{
  if (!a2) {
    goto LABEL_10;
  }
  uint64_t v2 = *((unsigned int *)this + 60);
  uint64_t v3 = *((void *)this + 29);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 29);
    unint64_t v4 = *((unsigned int *)this + 60);
    do
    {
      unint64_t v5 = v4 >> 1;
      uint64_t v6 = v3 + 16 * (v4 >> 1);
      unsigned int v7 = *(_DWORD *)(v6 + 8);
      uint64_t v8 = v6 + 16;
      v4 += ~(v4 >> 1);
      if (v7 < a2) {
        uint64_t v3 = v8;
      }
      else {
        unint64_t v4 = v5;
      }
    }
    while (v4);
  }
  if (v3 == *((void *)this + 29) + 16 * v2 || *(_DWORD *)(v3 + 8) != a2) {
LABEL_10:
  }
    uint64_t v3 = *((void *)this + 29);
  return *(unsigned __int8 *)(v3 + 1);
}

uint64_t llvm::DataLayout::getSmallestLegalIntType(llvm::DataLayout *this, llvm::LLVMContext *a2, unsigned int a3)
{
  uint64_t v3 = *((void *)this + 5);
  if (!v3) {
    return 0;
  }
  for (std::string::size_type i = (unsigned __int8 *)*((void *)this + 4); *i < a3; ++i)
  {
    if (!--v3) {
      return 0;
    }
  }
  return llvm::Type::getIntNTy(a2, (llvm::LLVMContext *)*i, a3);
}

uint64_t llvm::DebugInfoFinder::processCompileUnit(llvm::DebugInfoFinder *a1, uint64_t a2)
{
  uint64_t result = llvm::DebugInfoFinder::addCompileUnit((uint64_t)a1, a2);
  if (result)
  {
    uint64_t v5 = *(unsigned int *)(a2 + 8);
    uint64_t v6 = *(void *)(a2 - 8 * v5 + 48);
    if (v6) {
      unsigned int v7 = (uint64_t *)(v6 - 8 * *(unsigned int *)(v6 + 8));
    }
    else {
      unsigned int v7 = 0;
    }
    if (v7 != (uint64_t *)v6)
    {
      do
      {
        uint64_t v8 = *v7;
        uint64_t result = llvm::DebugInfoFinder::addGlobalVariable((uint64_t)a1, *v7);
        if (result)
        {
          uint64_t v9 = *(void *)(v8 - 8 * *(unsigned int *)(v8 + 8));
          llvm::DebugInfoFinder::processScope(a1, *(llvm::DIScope **)(v9 - 8 * *(unsigned int *)(v9 + 8)));
          uint64_t result = llvm::DebugInfoFinder::processType(a1, *(void *)(v9 - 8 * *(unsigned int *)(v9 + 8) + 24));
        }
        ++v7;
      }
      while (v7 != (uint64_t *)v6);
      uint64_t v5 = *(unsigned int *)(a2 + 8);
    }
    uint64_t v10 = -v5;
    uint64_t v11 = *(void *)(a2 + 8 * v10 + 32);
    if (v11) {
      uint64_t v12 = (uint64_t *)(v11 - 8 * *(unsigned int *)(v11 + 8));
    }
    else {
      uint64_t v12 = 0;
    }
    if (v12 != (uint64_t *)v11)
    {
      do
      {
        uint64_t v13 = *v12++;
        uint64_t result = llvm::DebugInfoFinder::processType(a1, v13);
      }
      while (v12 != (uint64_t *)v11);
      uint64_t v10 = -(uint64_t)*(unsigned int *)(a2 + 8);
    }
    uint64_t v14 = *(void *)(a2 + 8 * v10 + 40);
    if (v14) {
      uint64_t v15 = (llvm::DISubprogram **)(v14 - 8 * *(unsigned int *)(v14 + 8));
    }
    else {
      uint64_t v15 = 0;
    }
    if (v15 != (llvm::DISubprogram **)v14)
    {
      do
      {
        uint64_t v16 = *v15;
        int v17 = *(unsigned __int8 *)*v15;
        if ((v17 - 11) < 4 || v17 == 33) {
          uint64_t result = llvm::DebugInfoFinder::processType(a1, v16);
        }
        else {
          uint64_t result = llvm::DebugInfoFinder::processSubprogram(a1, v16);
        }
        ++v15;
      }
      while (v15 != (llvm::DISubprogram **)v14);
      uint64_t v10 = -(uint64_t)*(unsigned int *)(a2 + 8);
    }
    uint64_t v18 = *(void *)(a2 + 8 * v10 + 56);
    if (v18) {
      uint64_t v19 = v18 - 8 * *(unsigned int *)(v18 + 8);
    }
    else {
      uint64_t v19 = 0;
    }
    while (v19 != v18)
    {
      uint64_t v20 = *(unsigned int **)(*(void *)v19 - 8 * *(unsigned int *)(*(void *)v19 + 8) + 8);
      switch(*(unsigned char *)v20)
      {
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
          goto LABEL_27;
        case 0xF:
        case 0x10:
        case 0x12:
        case 0x13:
          break;
        case 0x11:
          uint64_t result = llvm::DebugInfoFinder::processSubprogram(a1, (llvm::DISubprogram *)v20);
          break;
        case 0x14:
        case 0x15:
          uint64_t result = llvm::DebugInfoFinder::processScope(a1, *(llvm::DIScope **)&v20[-2 * v20[2] + 2]);
          break;
        default:
          if (*(unsigned char *)v20 == 33) {
LABEL_27:
          }
            uint64_t result = llvm::DebugInfoFinder::processType(a1, v20);
          break;
      }
      v19 += 8;
    }
  }
  return result;
}

uint64_t llvm::DebugInfoFinder::processSubprogram(llvm::DebugInfoFinder *this, llvm::DISubprogram *a2)
{
  uint64_t result = llvm::DebugInfoFinder::addSubprogram(this, a2);
  if (result)
  {
    llvm::DebugInfoFinder::processScope(this, ((llvm::DIScope **)a2 - *((unsigned int *)a2 + 2))[1]);
    llvm::DebugInfoFinder::processCompileUnit(this, ((void *)a2 - *((unsigned int *)a2 + 2))[5]);
    uint64_t result = llvm::DebugInfoFinder::processType(this, ((void *)a2 - *((unsigned int *)a2 + 2))[4]);
    uint64_t v5 = *((unsigned int *)a2 + 2);
    if (v5 >= 0xA)
    {
      uint64_t v6 = ((void *)a2 - v5)[9];
      if (v6)
      {
        uint64_t v7 = *(unsigned int *)(v6 + 8);
        if (v7)
        {
          uint64_t v8 = -8 * v7;
          do
          {
            uint64_t v9 = *(void *)(v6 + v8);
            if ((*(unsigned char *)v9 & 0xFE) == 0x16) {
              uint64_t result = llvm::DebugInfoFinder::processType(this, *(void *)(v9 - 8 * *(unsigned int *)(v9 + 8) + 8));
            }
            v8 += 8;
          }
          while (v8);
        }
      }
    }
  }
  return result;
}

uint64_t llvm::DebugInfoFinder::addCompileUnit(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 400), a2);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  if (v5 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v5) = a2;
  ++*(_DWORD *)(a1 + 8);
  return 1;
}

void *llvm::DebugInfoFinder::processVariable(void *this, const llvm::Module *a2, const llvm::DbgVariableIntrinsic *a3)
{
  uint64_t v3 = *(void *)(((void *)a3 - 4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF))[4] + 24);
  if (v3)
  {
    if (*(unsigned char *)v3 == 25)
    {
      char v4 = (llvm::DebugInfoFinder *)this;
      this = sub_1CB89694C((llvm::SmallPtrSetImplBase *)(this + 50), *(void *)(((void *)a3 - 4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF))[4] + 24));
      if (v5)
      {
        llvm::DebugInfoFinder::processScope(v4, *(llvm::DIScope **)(v3 - 8 * *(unsigned int *)(v3 + 8)));
        uint64_t v6 = *(void *)(v3 - 8 * *(unsigned int *)(v3 + 8) + 24);
        return (void *)llvm::DebugInfoFinder::processType(v4, v6);
      }
    }
  }
  return this;
}

llvm::DebugInfoFinder *llvm::DebugInfoFinder::processLocation(llvm::DebugInfoFinder *this, const llvm::Module *a2, const llvm::DILocation *a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    char v4 = this;
    do
    {
      this = llvm::DebugInfoFinder::processScope(v4, *((llvm::DIScope **)v3 - *((unsigned int *)v3 + 2)));
      if (*((_DWORD *)v3 + 2) != 2) {
        break;
      }
      uint64_t v3 = (const llvm::DILocation *)*((void *)v3 - 1);
    }
    while (v3);
  }
  return this;
}

uint64_t llvm::DebugInfoFinder::addType(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 400), a2);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 248);
  if (v5 >= *(_DWORD *)(a1 + 252)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 240) + 8 * v5) = a2;
  ++*(_DWORD *)(a1 + 248);
  return 1;
}

uint64_t llvm::DebugInfoFinder::addScope(llvm::DebugInfoFinder *this, llvm::DIScope *a2)
{
  if (!a2) {
    return 0;
  }
  if (!*((_DWORD *)a2 + 2)) {
    return 0;
  }
  sub_1CB89694C((llvm::DebugInfoFinder *)((char *)this + 400), (uint64_t)a2);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = *((_DWORD *)this + 82);
  if (v5 >= *((_DWORD *)this + 83)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)this + 40) + 8 * v5) = a2;
  ++*((_DWORD *)this + 82);
  return 1;
}

uint64_t llvm::DebugInfoFinder::addSubprogram(llvm::DebugInfoFinder *this, llvm::DISubprogram *a2)
{
  if (!a2) {
    return 0;
  }
  sub_1CB89694C((llvm::DebugInfoFinder *)((char *)this + 400), (uint64_t)a2);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = *((_DWORD *)this + 22);
  if (v5 >= *((_DWORD *)this + 23)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)this + 10) + 8 * v5) = a2;
  ++*((_DWORD *)this + 22);
  return 1;
}

uint64_t llvm::stripNonLineTableDebugInfo(llvm *this, llvm::Module *a2)
{
  v47[8] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v44 = 0;
  v43[0] = this;
  v43[1] = &v44;
  sub_1CC588AFC(v43, "llvm.dbg.addr", 0xDuLL);
  sub_1CC588AFC(v43, "llvm.dbg.declare", 0x10uLL);
  sub_1CC588AFC(v43, "llvm.dbg.label", 0xEuLL);
  sub_1CC588AFC(v43, "llvm.dbg.value", 0xEuLL);
  for (std::string::size_type i = (void *)*((void *)this + 10); i != (void *)((char *)this + 72); std::string::size_type i = (void *)i[1])
    ;
  uint64_t v31 = (llvm *)((char *)this + 72);
  for (uint64_t j = (void *)*((void *)this + 2); j != (void *)((char *)this + 8); uint64_t j = (void *)j[1])
  {
    if (j) {
      unsigned int v5 = (llvm::Value *)(j - 7);
    }
    else {
      unsigned int v5 = 0;
    }
    llvm::Value::eraseMetadata(v5, 0);
  }
  uint64_t v6 = *(void **)this;
  v37[0] = 0;
  v37[1] = 0;
  int v38 = 0;
  uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)v6, 0, 0, 0, 1);
  llvm::DISubroutineType::getImpl(v6, 0, 0, (uint64_t)Impl, 0, 1);
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = v8;
  int v42 = 0;
  v36[0] = v37;
  v36[1] = &v44;
  for (uint64_t k = (llvm *)*((void *)this + 4); k != (llvm *)((char *)this + 24); uint64_t k = (llvm *)*((void *)v32 + 1))
  {
    long long v32 = k;
    if (k) {
      uint64_t v10 = (llvm *)((char *)k - 56);
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t Subprogram = llvm::Function::getSubprogram(v10);
    if (Subprogram)
    {
      uint64_t v12 = Subprogram;
      sub_1CC588C88((uint64_t)v37, Subprogram);
      uint64_t v13 = (llvm::MDNode *)sub_1CC58B858((uint64_t)v37, v12);
      if (v13)
      {
        uint64_t v14 = v13;
        if (sub_1CB8F0DA8(v13)) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = 0;
        }
      }
      else
      {
        uint64_t v15 = 0;
      }
      v44 |= v12 != (void)v15;
      llvm::Value::setMetadata((uint64_t ***)v10, 0, v15);
    }
    uint64_t v16 = (void *)((char *)v10 + 72);
    int v17 = (void *)*((void *)v10 + 10);
    uint64_t v33 = (void *)((char *)v10 + 72);
    while (v17 != v16)
    {
      uint64_t v18 = v17 - 3;
      if (!v17) {
        uint64_t v18 = 0;
      }
      uint64_t v19 = v18 + 5;
      for (m = (void *)v18[6]; m != v19; m = (void *)m[1])
      {
        if (m) {
          uint64_t v21 = (uint64_t)(m - 3);
        }
        else {
          uint64_t v21 = 0;
        }
        uint64_t v45 = v36;
        uint64_t v46 = (uint64_t)this;
        if (*(void *)(v21 + 48))
        {
          sub_1CC588F58(&v35, (uint64_t *)&v45, v21 + 48);
          sub_1CB8F69CC((unsigned __int8 **)(v21 + 48), &v35);
          if (v35) {
            llvm::MetadataTracking::untrack((uint64_t)&v35, v35);
          }
        }
        unint64_t v34 = &v45;
        llvm::updateLoopMetadataDebugLocations((llvm::Instruction *)v21, (uint64_t (*)(uint64_t))sub_1CC58B8C8, (uint64_t)&v34);
        if ((*(unsigned char *)(v21 + 23) & 0x20) != 0) {
          llvm::Instruction::setMetadata(v21, "heapallocsite", 0xDuLL, 0);
        }
      }
      int v17 = (void *)v17[1];
      uint64_t v16 = v33;
    }
  }
  for (n = (llvm::NamedMDNode *)*((void *)this + 10); n != v31; n = (llvm::NamedMDNode *)*((void *)n + 1))
  {
    uint64_t v45 = v47;
    uint64_t v46 = 0x800000000;
    uint64_t v23 = *(unsigned int *)(*((void *)n + 6) + 8);
    if (v23)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 8 * v23;
      do
      {
        uint64_t v26 = sub_1CC589210((uint64_t)v36, *(void *)(**((void **)n + 6) + v24));
        if (v46 >= (unint64_t)HIDWORD(v46)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v45 + v46) = v26;
        LODWORD(v46) = v46 + 1;
        v24 += 8;
      }
      while (v25 != v24);
    }
    if (v44)
    {
      llvm::NamedMDNode::clearOperands((uint64_t)n);
      if (v46)
      {
        uint64_t v27 = (llvm::MDNode **)v45;
        uint64_t v28 = 8 * v46;
        do
        {
          if (*v27) {
            llvm::NamedMDNode::addOperand(n, *v27);
          }
          ++v27;
          v28 -= 8;
        }
        while (v28);
      }
    }
    if (v45 != v47) {
      free(v45);
    }
  }
  uint64_t v29 = v44;
  MEMORY[0x1D25D9CD0](v40, 8);
  MEMORY[0x1D25D9CD0](v37[0], 8);
  return v29;
}

uint64_t sub_1CD5B0640(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CC58B6F8(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v10);
      uint64_t *v10 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t llvm::DILocation::encodeDiscriminator(llvm::DILocation *this, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int *a5)
{
  int v7 = (int)this;
  v23[0] = this;
  v23[1] = a2;
  uint64_t v23[2] = a3;
  unint64_t v8 = a2 + (unint64_t)this + a3;
  if (v8)
  {
    char v10 = 0;
    LODWORD(v9) = 0;
    uint64_t v11 = v23;
    do
    {
      unsigned int v13 = *v11++;
      uint64_t v12 = v13;
      unsigned int v14 = v13 & 0xFFF;
      int v15 = (2 * v13) & 0x1FC0 | v13 & 0x1F | 0x20;
      if (v14 >= 0x20) {
        unsigned int v14 = v15;
      }
      int v16 = 2 * v14;
      if (!v12) {
        int v16 = 1;
      }
      uint64_t v9 = (v16 << v10) | v9;
      if (v12 <= 0x1F) {
        char v17 = 7;
      }
      else {
        char v17 = 14;
      }
      if (!v12) {
        char v17 = 1;
      }
      v10 += v17;
      v8 -= v12;
    }
    while (v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unsigned int v22 = 0;
  *(void *)uint64_t v21 = 0;
  llvm::DILocation::decodeDiscriminator(v9, &v22, &v21[1], v21, a5);
  if (v21[0] == a3 && v21[1] == a2 && v22 == v7) {
    return v9 | 0x100000000;
  }
  else {
    return 0;
  }
}

uint64_t llvm::DILocation::decodeDiscriminator(uint64_t this, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  unsigned int v5 = (this >> 1) & 0x1F;
  if ((this & 0x40) != 0) {
    char v6 = 14;
  }
  else {
    char v6 = 7;
  }
  if ((this & 0x40) != 0) {
    unsigned int v5 = (this >> 2) & 0xFE0 | (this >> 1) & 0x1F;
  }
  if (this) {
    char v7 = 1;
  }
  else {
    char v7 = v6;
  }
  if (this) {
    unsigned int v5 = 0;
  }
  *a2 = v5;
  unsigned int v8 = this >> v7;
  int v9 = (v8 >> 1) & 0x1F;
  if ((v8 & 0x40) != 0) {
    char v10 = 14;
  }
  else {
    char v10 = 7;
  }
  if ((v8 & 0x40) != 0) {
    int v9 = (v8 >> 2) & 0xFE0 | (v8 >> 1) & 0x1F;
  }
  if (v8) {
    char v11 = 1;
  }
  else {
    char v11 = v10;
  }
  if (v8) {
    int v9 = 0;
  }
  *a3 = v9;
  unsigned int v12 = v8 >> v11;
  int v13 = (v12 >> 1) & 0x1F;
  if ((v12 & 0x40) != 0) {
    int v13 = (v12 >> 2) & 0xFE0 | (v12 >> 1) & 0x1F;
  }
  if (v12) {
    unsigned int v14 = 0;
  }
  else {
    unsigned int v14 = v13;
  }
  *a4 = v14;
  return this;
}

llvm::MDString *llvm::DIScope::getName(llvm::DIScope *this)
{
  int v2 = *(unsigned __int8 *)this;
  uint64_t result = (llvm::MDString *)&unk_1CFB7A80B;
  switch(v2)
  {
    case 11:
    case 12:
    case 13:
    case 14:
    case 17:
    case 20:
    case 21:
      goto LABEL_2;
    case 15:
    case 16:
    case 18:
    case 19:
      return result;
    default:
      if (v2 == 31 || v2 == 33)
      {
LABEL_2:
        uint64_t result = (llvm::MDString *)((void *)this - *((unsigned int *)this + 2))[2];
        if (result) {
          uint64_t result = (llvm::MDString *)llvm::MDString::getString(result);
        }
      }
      break;
  }
  return result;
}

uint64_t llvm::GenericDINode::getTag(llvm::GenericDINode *this)
{
  return *((unsigned __int16 *)this + 1);
}

llvm::MDNode *sub_1CD5B0910(llvm::MDNode *this, int a2, uint64_t a3)
{
  uint64_t v3 = this;
  unsigned int v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B2FAC(a3, (uint64_t *)&v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

unint64_t llvm::GenericDINode::recalculateHash(llvm::GenericDINode *this)
{
  unint64_t result = llvm::MDNodeOpsKey::calculateHash(this, (llvm::MDNode *)1);
  *((_DWORD *)this + 1) = result;
  return result;
}

llvm::MDNode *llvm::DISubrange::getImpl(llvm::Type *a1, llvm::LLVMContext *a2, unint64_t a3, int a4, int a5)
{
  Int64Ty = (llvm::ConstantInt *)llvm::Type::getInt64Ty(a1, a2);
  Signed = (llvm::ValueAsMetadata *)llvm::ConstantInt::getSigned(Int64Ty, (unint64_t)a2, v11);
  uint64_t v14 = llvm::ValueAsMetadata::get(Signed, v13);
  int v16 = (llvm::ConstantInt *)llvm::Type::getInt64Ty(a1, v15);
  uint64_t v18 = (llvm::ValueAsMetadata *)llvm::ConstantInt::getSigned(v16, a3, v17);
  uint64_t v20 = llvm::ValueAsMetadata::get(v18, v19);

  return llvm::DISubrange::getImpl(a1, v14, v20, 0, 0, a4, a5);
}

{
  llvm::ConstantInt *Int64Ty;
  const llvm::APInt *v11;
  llvm::ValueAsMetadata *Signed;
  llvm::Value *v13;
  uint64_t v14;
  uint64_t vars8;

  Int64Ty = (llvm::ConstantInt *)llvm::Type::getInt64Ty(a1, a2);
  Signed = (llvm::ValueAsMetadata *)llvm::ConstantInt::getSigned(Int64Ty, a3, v11);
  uint64_t v14 = llvm::ValueAsMetadata::get(Signed, v13);

  return llvm::DISubrange::getImpl(a1, (uint64_t)a2, v14, 0, 0, a4, a5);
}

llvm::MDNode *sub_1CD5B0AB0(llvm::MDNode *result, int a2, uint64_t a3)
{
  char v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      uint64_t v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B36B8(a3, &v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

unint64_t llvm::DISubrange::getLowerBound(llvm::DISubrange *this)
{
  unint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[1];
  if (!v1) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)v1;
  if (v2 == 1) {
    return *(void *)(v1 + 128) & 0xFFFFFFFFFFFFFFF9;
  }
  if ((v2 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFF9 | 2;
  }
  if (v2 == 6) {
    return v1 & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else {
    return 0;
  }
}

unint64_t llvm::DISubrange::getUpperBound(llvm::DISubrange *this)
{
  unint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[2];
  if (!v1) {
    return 0;
  }
  int v3 = *(unsigned __int8 *)v1;
  if (v3 == 1) {
    return *(void *)(v1 + 128) & 0xFFFFFFFFFFFFFFF9;
  }
  if ((v3 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFF9 | 2;
  }
  if (v3 != 6) {
    return 0;
  }
  return v1 & 0xFFFFFFFFFFFFFFF9 | 4;
}

unint64_t llvm::DISubrange::getStride(llvm::DISubrange *this)
{
  unint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[3];
  if (!v1) {
    return 0;
  }
  int v3 = *(unsigned __int8 *)v1;
  if (v3 == 1) {
    return *(void *)(v1 + 128) & 0xFFFFFFFFFFFFFFF9;
  }
  if ((v3 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFF9 | 2;
  }
  if (v3 != 6) {
    return 0;
  }
  return v1 & 0xFFFFFFFFFFFFFFF9 | 4;
}

llvm::MDNode *sub_1CD5B0C24(llvm::MDNode *this, int a2, uint64_t a3)
{
  int v3 = this;
  unsigned int v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B3B0C(a3, &v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

unint64_t llvm::DIGenericSubrange::getCount(llvm::DIGenericSubrange *this)
{
  unint64_t v1 = *((void *)this - *((unsigned int *)this + 2));
  if (!v1) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)v1;
  if ((v2 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFFBLL;
  }
  if (v2 == 6) {
    return v1 | 4;
  }
  else {
    return 0;
  }
}

unint64_t llvm::DIGenericSubrange::getLowerBound(llvm::DIGenericSubrange *this)
{
  unint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[1];
  if (!v1) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)v1;
  if ((v2 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFFBLL;
  }
  if (v2 == 6) {
    return v1 | 4;
  }
  else {
    return 0;
  }
}

unint64_t llvm::DIGenericSubrange::getUpperBound(llvm::DIGenericSubrange *this)
{
  unint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[2];
  if (!v1) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)v1;
  if ((v2 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFFBLL;
  }
  if (v2 == 6) {
    return v1 | 4;
  }
  else {
    return 0;
  }
}

unint64_t llvm::DIGenericSubrange::getStride(llvm::DIGenericSubrange *this)
{
  unint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[3];
  if (!v1) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)v1;
  if ((v2 & 0xFE) == 0x18) {
    return v1 & 0xFFFFFFFFFFFFFFFBLL;
  }
  if (v2 == 6) {
    return v1 | 4;
  }
  else {
    return 0;
  }
}

uint64_t llvm::DIEnumerator::DIEnumerator(uint64_t a1, uint64_t a2, char a3, const llvm::APInt *a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = llvm::MDNode::MDNode(a1, a2, 10, a3, a6, a7, 0, 0);
  *(_WORD *)(v10 + 2) = 40;
  char v11 = (llvm::APInt *)(v10 + 24);
  unsigned int v12 = *((_DWORD *)a4 + 2);
  *(_DWORD *)(a1 + 32) = v12;
  if (v12 > 0x40) {
    llvm::APInt::initSlowCase(v11, a4);
  }
  *(void *)char v11 = *(void *)a4;
  *(_DWORD *)(a1 + 4) = a5;
  return a1;
}

llvm::MDNode *sub_1CD5B0E0C(llvm::MDNode *result, int a2, uint64_t a3)
{
  char v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B4028(a3, (uint64_t *)&v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

llvm::MDNode *sub_1CD5B0E6C(llvm::MDNode *result, int a2, uint64_t a3)
{
  char v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B44E8(a3, (uint64_t *)&v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

uint64_t llvm::DIBasicType::getSignedness(llvm::DIBasicType *this)
{
  int v1 = *((_DWORD *)this + 13) - 5;
  if (v1 > 3) {
    return 0;
  }
  else {
    return qword_1CFAC8750[v1] | 0x100000000;
  }
}

llvm::MDNode *sub_1CD5B0EF8(llvm::MDNode *this, int a2, uint64_t a3)
{
  int v3 = this;
  unsigned int v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B4A74(a3, (uint64_t *)&v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

uint64_t llvm::DIDerivedType::getClassType(llvm::DIDerivedType *this)
{
  return ((void *)this - *((unsigned int *)this + 2))[4];
}

uint64_t llvm::DIDerivedType::getVBPtrOffset(llvm::DIDerivedType *this)
{
  uint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[4];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 128);
  if (!v2 || *(unsigned char *)(v2 + 16) != 16) {
    return 0;
  }
  int v3 = (unsigned int *)(v2 + 24);
  if (*(_DWORD *)(v2 + 32) >= 0x41u) {
    int v3 = *(unsigned int **)v3;
  }
  return *v3;
}

uint64_t llvm::DIDerivedType::getStorageOffsetInBits(llvm::DIDerivedType *this)
{
  uint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[4];
  if (v1) {
    return *(void *)(v1 + 128);
  }
  else {
    return 0;
  }
}

uint64_t llvm::DIDerivedType::getDiscriminantValue(llvm::DIDerivedType *this)
{
  uint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[4];
  if (v1) {
    return *(void *)(v1 + 128);
  }
  else {
    return 0;
  }
}

uint64_t llvm::DICompositeType::buildODRType(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, uint64_t a11, unsigned int a12, uint64_t a13, int a14, uint64_t a15, uint64_t a16, unint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  v37[14] = *MEMORY[0x1E4F143B8];
  uint64_t v22 = *a1;
  if (!*(unsigned char *)(*a1 + 1184)) {
    return 0;
  }
  v37[0] = a2;
  uint64_t v26 = sub_1CD467E2C(v22 + 1160, v37);
  uint64_t result = v26[1];
  if (!result)
  {
    uint64_t result = llvm::DICompositeType::getImpl(a1, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a2, a17, a18, a19,
               a20,
               a21,
               a22,
               1,
               1);
    v26[1] = result;
    return result;
  }
  if (*(unsigned __int16 *)(result + 2) != a3) {
    return 0;
  }
  if ((a12 & 4) == 0 && (*(_DWORD *)(result + 28) & 4) != 0)
  {
    *(_WORD *)(result + 2) = a3;
    *(_DWORD *)(result + 24) = a6;
    *(_DWORD *)(result + 2sub_1CD521E44((uint64_t)this + 8) = a12;
    *(_DWORD *)(result + 4sub_1CD521E44((uint64_t)this + 8) = a10;
    *(_DWORD *)(result + 52) = a14;
    *(void *)(result + 32) = a9;
    *(void *)(result + 4llvm::MDNode::dumpTree(this, 0) = a11;
    v37[0] = a5;
    v37[1] = a7;
    void v37[2] = a4;
    void v37[3] = a8;
    _DWORD v37[4] = a13;
    v37[5] = a15;
    v37[6] = a16;
    v37[7] = a2;
    v37[8] = a17;
    v37[9] = a18;
    v37[10] = a19;
    v37[11] = a20;
    v37[12] = a21;
    v37[13] = a22;
    uint64_t v27 = *(unsigned int *)(result + 8);
    if (v27)
    {
      for (uint64_t i = 0; i != v27; ++i)
      {
        uint64_t v29 = (unsigned __int8 *)v37[i];
        uint64_t v30 = v26[1];
        if (v29 != *(unsigned __int8 **)(v30 - 8 * *(unsigned int *)(v30 + 8) + 8 * i)) {
          llvm::MDNode::setOperand(v30, i, v29);
        }
      }
      return v26[1];
    }
  }
  return result;
}

const char *llvm::DIFile::getChecksumKindAsString(int a1)
{
  uint64_t v1 = off_1E6830AC8[a1 - 1];
  strlen(v1);
  return v1;
}

uint64_t llvm::DIFile::getChecksumKind(uint64_t a1, uint64_t a2)
{
  if (a2 == 10)
  {
    if (*(void *)a1 == 0x324148535F4B5343 && *(_WORD *)(a1 + 8) == 13877) {
      return 0x100000003;
    }
    return 0;
  }
  if (a2 != 8)
  {
    if (a2 == 7 && *(_DWORD *)a1 == 1598772035 && *(_DWORD *)(a1 + 3) == 893668703) {
      return 0x100000001;
    }
    return 0;
  }
  if (*(void *)a1 != 0x314148535F4B5343) {
    return 0;
  }
  return 0x100000002;
}

uint64_t llvm::DICompileUnit::getEmissionKind(int *a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a2 <= 13)
  {
    if (a2 == 7)
    {
      int v12 = *a1;
      int v13 = *(int *)((char *)a1 + 3);
      if (v12 == 1698983758 && v13 == 1735746149) {
        return 0x100000000;
      }
    }
    else
    {
      if (a2 != 9) {
        return result;
      }
      uint64_t v4 = *(void *)a1;
      int v5 = *((unsigned __int8 *)a1 + 8);
      if (v4 == 0x756265446C6C7546 && v5 == 103) {
        return 0x100000001;
      }
    }
    return 0;
  }
  if (a2 != 14)
  {
    if (a2 != 19) {
      return result;
    }
    uint64_t v7 = *(void *)a1;
    uint64_t v8 = *((void *)a1 + 1);
    uint64_t v9 = *(void *)((char *)a1 + 11);
    if (v7 == 0x7269446775626544 && v8 == 0x4F73657669746365 && v9 == 0x796C6E4F73657669) {
      return 0x100000003;
    }
    return 0;
  }
  uint64_t v15 = *(void *)a1;
  uint64_t v16 = *(void *)((char *)a1 + 6);
  if (v15 != 0x6C626154656E694CLL || v16 != 0x796C6E4F73656C62) {
    return 0;
  }
  return 0x100000002;
}

uint64_t llvm::DICompileUnit::getNameTableKind(uint64_t a1, uint64_t a2)
{
  if (a2 == 3)
  {
    if (*(_WORD *)a1 == 20039 && *(unsigned char *)(a1 + 2) == 85) {
      return 0x100000001;
    }
    return 0;
  }
  if (a2 != 4)
  {
    if (a2 == 7 && *(_DWORD *)a1 == 1634100548 && *(_DWORD *)(a1 + 3) == 1953264993) {
      return 0x100000000;
    }
    return 0;
  }
  if (*(_DWORD *)a1 != 1701736270) {
    return 0;
  }
  return 0x100000002;
}

const char *llvm::DICompileUnit::nameTableKindString(int a1)
{
  uint64_t v1 = "GNU";
  if (a1 != 1) {
    uint64_t v1 = 0;
  }
  if (a1 == 2) {
    return "None";
  }
  else {
    return v1;
  }
}

uint64_t llvm::DISubprogram::toSPFlags(llvm::DISubprogram *this, int a2, int a3, char a4, int a5)
{
  if (this) {
    int v5 = 4;
  }
  else {
    int v5 = 0;
  }
  if (a2) {
    int v6 = 8;
  }
  else {
    int v6 = 0;
  }
  if (a3) {
    int v7 = 16;
  }
  else {
    int v7 = 0;
  }
  if (a5) {
    int v8 = 256;
  }
  else {
    int v8 = 0;
  }
  return (v6 | v5 | v7) & 0xFFFFFFFC | a4 & 3 | v8;
}

unsigned __int8 *llvm::DILocalScope::cloneScopeForSubprogram(llvm::DIScope *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  v27[6] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = v27;
  uint64_t v26 = 0x600000000;
  if (*(unsigned char *)a1 != 17)
  {
    Scope = a1;
    while (1)
    {
      uint64_t v23 = Scope;
      uint64_t v24 = 0;
      if (sub_1CB883B0C(a4, &v23, &v24))
      {
        if (v24 != (llvm::MDNode *)(*(void *)a4 + 16 * *(unsigned int *)(a4 + 16))) {
          break;
        }
      }
      if (v26 >= (unint64_t)HIDWORD(v26)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v25 + v26) = Scope;
      unsigned int v14 = v26 + 1;
      LODWORD(v26) = v26 + 1;
      Scope = (llvm::DIScope *)llvm::DIScope::getScope(Scope);
      if (*(unsigned char *)Scope == 17)
      {
        uint64_t v15 = 0;
        goto LABEL_10;
      }
    }
    uint64_t v15 = (unsigned __int8 *)*((void *)v24 + 1);
    unsigned int v14 = v26;
LABEL_10:
    if (v15) {
      a2 = v15;
    }
    uint64_t v16 = v25;
    if (v14)
    {
      uint64_t v17 = 8 * v14;
      uint64_t v18 = (char *)v25 - 8;
      do
      {
        uint64_t v19 = *(llvm::MDNode **)&v18[v17];
        llvm::MDNode::clone(v19, v8, v9, v10, v11, v12, v13, (uint64_t *)&v24);
        llvm::MDNode::setOperand((uint64_t)v24, 1u, a2);
        uint64_t v20 = v24;
        uint64_t v24 = 0;
        a2 = (unsigned __int8 *)llvm::MDNode::replaceWithUniquedImpl(v20);
        uint64_t v23 = v19;
        sub_1CC5958A8(a4, (uint64_t *)&v23)[1] = a2;
        uint64_t v22 = v24;
        uint64_t v24 = 0;
        if (v22) {
          llvm::MDNode::deleteTemporary(v22, v21);
        }
        v17 -= 8;
      }
      while (v17);
      uint64_t v16 = v25;
    }
    if (v16 != v27) {
      free(v16);
    }
  }
  return a2;
}

llvm::MDNode *sub_1CD5B16DC(llvm::MDNode *result, int a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B5B9C(a3, (uint64_t *)&v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

llvm::MDNode *sub_1CD5B173C(llvm::MDNode *this, int a2, uint64_t a3)
{
  int v3 = this;
  int v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B60B0(a3, (uint64_t *)&v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

llvm::MDNode *sub_1CD5B17A0(llvm::MDNode *result, int a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B66CC(a3, (uint64_t *)&v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

llvm::MDNode *sub_1CD5B1800(llvm::MDNode *result, int a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B6C4C(a3, (uint64_t *)&v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

llvm::MDNode *sub_1CD5B1860(llvm::MDNode *this, int a2, uint64_t a3)
{
  int v3 = this;
  int v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B74C4(a3, (uint64_t *)&v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

unint64_t llvm::DIVariable::getSizeInBits(llvm::DIVariable *this)
{
  for (uint64_t i = (char *)this - 8 * *((unsigned int *)this + 2); ; uint64_t i = (char *)(v2 - 8 * *(unsigned int *)(v2 + 8)))
  {
    unint64_t v2 = *((void *)i + 3);
    if (!v2) {
      goto LABEL_9;
    }
    int v3 = *(unsigned __int8 *)v2;
    if ((v3 - 11) >= 4 && v3 != 33)
    {
LABEL_8:
      unint64_t v2 = 0;
LABEL_9:
      uint64_t v5 = 0;
      return v5 | v2;
    }
    uint64_t v4 = *(void *)(v2 + 32);
    if (v4) {
      break;
    }
    if (v3 != 12) {
      goto LABEL_8;
    }
  }
  unint64_t v2 = v4 & 0xFFFFFFFFFFFFFF00;
  uint64_t v5 = v4;
  return v5 | v2;
}

llvm::MDNode *sub_1CD5B192C(llvm::MDNode *this, int a2, uint64_t a3)
{
  int v3 = this;
  uint64_t v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B7A9C(a3, (uint64_t *)&v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

llvm::MDNode *sub_1CD5B1990(llvm::MDNode *result, int a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B7FA0(a3, &v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

BOOL llvm::DIExpression::startsWithDeref(llvm::DIExpression *this)
{
  uint64_t v1 = (void *)*((void *)this + 3);
  return ((*((void *)this + 4) - (void)v1) & 0x7FFFFFFF8) != 0 && *v1 == 6;
}

uint64_t llvm::DIExpression::appendOffset(uint64_t result, uint64_t a2)
{
  if (a2 < 1)
  {
    if ((a2 & 0x8000000000000000) == 0) {
      return result;
    }
    unsigned int v5 = *(_DWORD *)(result + 8);
    if (v5 >= *(_DWORD *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)result + 8 * v5) = 16;
    unsigned int v6 = *(_DWORD *)(result + 12);
    unsigned int v7 = *(_DWORD *)(result + 8) + 1;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = v7;
    if (v7 >= v6) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)result + 8 * v7) = -a2;
    unsigned int v3 = *(_DWORD *)(result + 12);
    unsigned int v4 = *(_DWORD *)(result + 8) + 1;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = v4;
    a2 = 28;
  }
  else
  {
    unsigned int v2 = *(_DWORD *)(result + 8);
    if (v2 >= *(_DWORD *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)result + 8 * v2) = 35;
    unsigned int v3 = *(_DWORD *)(result + 12);
    unsigned int v4 = *(_DWORD *)(result + 8) + 1;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = v4;
  }
  if (v4 >= v3) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)result + 8 * v4) = a2;
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t llvm::DIExpression::extractIfOffset(llvm::DIExpression *this, uint64_t *a2)
{
  unsigned int v2 = (void *)*((void *)this + 3);
  unint64_t v3 = *((void *)this + 4) - (void)v2;
  if ((v3 >> 3))
  {
    if ((v3 >> 3) != 2 || *v2 != 35)
    {
      if ((v3 & 0x7FFFFFFF8) != 0x18 || *v2 != 16) {
        return 0;
      }
      uint64_t v5 = v2[2];
      if (v5 == 28)
      {
        uint64_t v4 = -v2[1];
        goto LABEL_11;
      }
      if (v5 != 34) {
        return 0;
      }
    }
    uint64_t v4 = v2[1];
  }
  else
  {
    uint64_t v4 = (v3 >> 3);
  }
LABEL_11:
  *a2 = v4;
  return 1;
}

llvm::MDNode *llvm::DIExpression::extractAddressClass(llvm::MDNode *this, const llvm::DIExpression *a2, unsigned int *a3)
{
  uint64_t v4 = (void *)*((void *)this + 3);
  uint64_t v5 = *((void *)this + 4) - (void)v4;
  if ((unint64_t)v5 >= 0x19 && *v4 == 16 && v4[2] == 22 && v4[3] == 24)
  {
    *(_DWORD *)a2 = v4[1];
    if (v5 == 32)
    {
      return 0;
    }
    else
    {
      uint64_t v6 = *((void *)this + 2);
      unsigned int v7 = (void *)(v6 & 0xFFFFFFFFFFFFFFF8);
      if ((v6 & 4) != 0) {
        unsigned int v7 = (void *)*v7;
      }
      return llvm::DIExpression::getImpl(v7, v4, (v5 >> 3) - 4, 0, 1);
    }
  }
  return this;
}

llvm::MDNode *llvm::DIExpression::prepend(llvm::DIExpression *this, const llvm::DIExpression *a2, uint64_t a3)
{
  unsigned int v3 = a2;
  unsigned char v9[8] = *MEMORY[0x1E4F143B8];
  unsigned int v7 = v9;
  uint64_t v8 = 0x800000000;
  if (a2)
  {
    v9[0] = 6;
    LODWORD(vsub_1CD521E44((uint64_t)this + 8) = 1;
  }
  llvm::DIExpression::appendOffset((uint64_t)&v7, a3);
  if ((v3 & 2) != 0)
  {
    if (v8 >= HIDWORD(v8)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v7 + vsub_1CD521E44((uint64_t)this + 8) = 6;
    LODWORD(vsub_1CD521E44((uint64_t)this + 8) = v8 + 1;
  }
  uint64_t v5 = llvm::DIExpression::prependOpcodes(this, (unsigned int *)&v7, (v3 & 4) != 0, (v3 >> 3) & 1);
  if (v7 != v9) {
    free(v7);
  }
  return v5;
}

llvm::MDNode *llvm::DIExpression::prependOpcodes(void *a1, unsigned int *a2, char a3, int a4)
{
  unsigned int v6 = a2[2];
  if (a4)
  {
    if (v6 >= a2[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v6) = 4099;
    unsigned int v18 = a2[3];
    unsigned int v19 = a2[2] + 1;
    a2[2] = v19;
    if (v19 >= v18) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v19) = 1;
    unsigned int v6 = a2[2] + 1;
    a2[2] = v6;
  }
  if (v6) {
    char v7 = a3;
  }
  else {
    char v7 = 0;
  }
  uint64_t v8 = (uint64_t *)a1[3];
  uint64_t v9 = (uint64_t *)a1[4];
  for (uint64_t i = v8; v8 != v9; uint64_t i = v8)
  {
    uint64_t v20 = v8;
    if ((v7 & 1) == 0 || *v8 == 159)
    {
      char v7 = 0;
    }
    else if (*v8 == 4096)
    {
      unint64_t v17 = a2[2];
      if (v17 >= a2[3]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      char v7 = 0;
      *(void *)(*(void *)a2 + 8 * v17) = 159;
      ++a2[2];
    }
    else
    {
      char v7 = 1;
    }
    int Size = llvm::DIExpression::ExprOperand::getSize(&v20);
    sub_1CBFCBB74(a2, v8, &v8[Size]);
    v8 += llvm::DIExpression::ExprOperand::getSize(&i);
  }
  if (v7)
  {
    unsigned int v11 = a2[2];
    if (v11 >= a2[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v11) = 159;
    ++a2[2];
  }
  uint64_t v12 = a1[2];
  uint64_t v13 = (void *)(v12 & 0xFFFFFFFFFFFFFFF8);
  if ((v12 & 4) != 0) {
    uint64_t v13 = (void *)*v13;
  }
  unsigned int v14 = *(const void **)a2;
  uint64_t v15 = a2[2];

  return llvm::DIExpression::getImpl(v13, v14, v15, 0, 1);
}

llvm::MDNode *llvm::DIExpression::appendOpsToArg(void *a1, uint64_t *a2, uint64_t a3, int a4, char a5)
{
  v23[8] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = (void *)a1[3];
  uint64_t v10 = (void *)a1[4];
  uint64_t v21 = v9;
  if (v10 == v9)
  {
LABEL_5:
    uint64_t v21 = v23;
    uint64_t v22 = 0x800000000;
    sub_1CBFCBB74((unsigned int *)&v21, a2, &a2[a3]);
    uint64_t Impl = llvm::DIExpression::prependOpcodes(a1, (unsigned int *)&v21, a5, 0);
    unsigned int v14 = v21;
    if (v21 != v23) {
LABEL_15:
    }
      free(v14);
  }
  else
  {
    uint64_t v12 = v9;
    while (*v12 != 4101)
    {
      v12 += llvm::DIExpression::ExprOperand::getSize((uint64_t **)&v21);
      uint64_t v21 = v12;
      if (v12 == v10) {
        goto LABEL_5;
      }
    }
    uint64_t v20 = v9;
    uint64_t v21 = v23;
    uint64_t v22 = 0x800000000;
    do
    {
      unsigned int v19 = v9;
      int Size = llvm::DIExpression::ExprOperand::getSize(&v19);
      sub_1CBFCBB74((unsigned int *)&v21, v9, &v9[Size]);
      if (*v9 == 4101 && v9[1] == a4) {
        sub_1CD5B2154((unsigned int *)&v21, (uint64_t)v21 + 8 * v22, a2, &a2[a3]);
      }
      v9 += llvm::DIExpression::ExprOperand::getSize(&v20);
      uint64_t v20 = v9;
    }
    while (v9 != v10);
    uint64_t v17 = a1[2];
    unsigned int v18 = (void *)(v17 & 0xFFFFFFFFFFFFFFF8);
    if ((v17 & 4) != 0) {
      unsigned int v18 = (void *)*v18;
    }
    uint64_t Impl = llvm::DIExpression::getImpl(v18, v21, v22, 0, 1);
    unsigned int v14 = v21;
    if (v21 != v23) {
      goto LABEL_15;
    }
  }
  return Impl;
}

unsigned char *sub_1CD5B2154(unsigned int *a1, uint64_t a2, uint64_t *__src, uint64_t *a4)
{
  uint64_t v5 = __src;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v9 = a1[2];
  if (*(void *)a1 + 8 * v9 == a2)
  {
    sub_1CBFCBB74(a1, __src, a4);
    return (unsigned char *)(*(void *)a1 + 8 * v8);
  }
  else
  {
    unint64_t v10 = a4 - __src;
    if (v9 + v10 > a1[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unsigned int v11 = (unsigned char *)(v7 + 8 * v8);
    uint64_t v12 = (unsigned char *)(v7 + 8 * v9);
    unint64_t v13 = (v12 - v11) >> 3;
    if (v13 >= v10)
    {
      sub_1CD4570C8((uint64_t)a1, &v12[-8 * v10], (char *)(v7 + 8 * v9));
      if (&v12[-8 * v10] != v11) {
        memmove(&v11[8 * v10], v11, &v12[-8 * v10] - v11);
      }
      if (v5 != a4) {
        memmove(v11, v5, (char *)a4 - (char *)v5);
      }
    }
    else
    {
      unsigned int v14 = v9 + ((unint64_t)((char *)a4 - (char *)__src) >> 3);
      a1[2] = v14;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 8 * v14 - 8 * v13), v11, v12 - v11);
        uint64_t v15 = v11;
        do
        {
          uint64_t v16 = *v5++;
          *v15++ = v16;
          --v13;
        }
        while (v13);
      }
      if (v5 != a4) {
        memcpy(v12, v5, (char *)a4 - (char *)v5);
      }
    }
  }
  return v11;
}

llvm::MDNode *llvm::DIExpression::replaceArg(llvm::DIExpression *this, const llvm::DIExpression *a2, uint64_t a3)
{
  v19[8] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0x800000000;
  uint64_t v4 = (uint64_t *)*((void *)this + 3);
  uint64_t v5 = (uint64_t *)*((void *)this + 4);
  uint64_t v16 = v4;
  for (i = v19; v4 != v5; uint64_t v16 = v4)
  {
    uint64_t v15 = v4;
    if (*v4 == 4101 && v4[1] >= (unint64_t)a2)
    {
      if (v18 >= (unint64_t)HIDWORD(v18)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)i + v1sub_1CD521E44((uint64_t)this + 8) = 4101;
      unsigned int v8 = v18 + 1;
      LODWORD(v1sub_1CD521E44((uint64_t)this + 8) = v18 + 1;
      if ((const llvm::DIExpression *)v4[1] == a2) {
        uint64_t v9 = a3;
      }
      else {
        uint64_t v9 = v4[1];
      }
      if (v8 >= HIDWORD(v18)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)i + vsub_1CD521E44((uint64_t)this + 8) = (__PAIR128__(v9, (unint64_t)a2) - (unint64_t)v9) >> 64;
      LODWORD(v1sub_1CD521E44((uint64_t)this + 8) = v18 + 1;
    }
    else
    {
      int Size = llvm::DIExpression::ExprOperand::getSize(&v15);
      sub_1CBFCBB74((unsigned int *)&i, v4, &v4[Size]);
    }
    v4 += llvm::DIExpression::ExprOperand::getSize(&v16);
  }
  uint64_t v11 = *((void *)this + 2);
  uint64_t v12 = (void *)(v11 & 0xFFFFFFFFFFFFFFF8);
  if ((v11 & 4) != 0) {
    uint64_t v12 = (void *)*v12;
  }
  uint64_t Impl = llvm::DIExpression::getImpl(v12, i, v18, 0, 1);
  if (i != v19) {
    free(i);
  }
  return Impl;
}

llvm::MDNode *llvm::DIExpression::append(void *a1, unsigned char *a2, uint64_t a3)
{
  v18[16] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0x1000000000;
  unsigned int v6 = (uint64_t *)a1[3];
  uint64_t v7 = (uint64_t *)a1[4];
  uint64_t v15 = v6;
  for (i = v18; v6 != v7; uint64_t v15 = v6)
  {
    unsigned int v14 = v6;
    if (*v6 == 4096 || *v6 == 159)
    {
      sub_1CBFCBB74((unsigned int *)&i, a2, &a2[8 * a3]);
      a2 = 0;
      a3 = 0;
      unsigned int v6 = v14;
    }
    int Size = llvm::DIExpression::ExprOperand::getSize(&v14);
    sub_1CBFCBB74((unsigned int *)&i, v6, &v6[Size]);
    uint64_t v9 = v15;
    unsigned int v6 = &v9[llvm::DIExpression::ExprOperand::getSize(&v15)];
  }
  sub_1CBFCBB74((unsigned int *)&i, a2, &a2[8 * a3]);
  uint64_t v10 = a1[2];
  uint64_t v11 = (void *)(v10 & 0xFFFFFFFFFFFFFFF8);
  if ((v10 & 4) != 0) {
    uint64_t v11 = (void *)*v11;
  }
  uint64_t Impl = llvm::DIExpression::getImpl(v11, i, v17, 0, 1);
  if (i != v18) {
    free(i);
  }
  return Impl;
}

llvm::MDNode *llvm::DIExpression::createFragmentExpression(llvm::DIExpression *this, const llvm::DIExpression *a2, unsigned int a3)
{
  unsigned int v4 = a2;
  unsigned char v25[8] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = v25;
  uint64_t v24 = 0x800000000;
  if (!this || (v6 = *((void *)this + 3), uint64_t v7 = *((void *)this + 4), v22 = (uint64_t *)v6, v7 == v6))
  {
    unsigned int v13 = 0;
  }
  else
  {
    do
    {
      uint64_t v21 = (uint64_t *)v6;
      unint64_t v8 = *(void *)v6;
      if (*(void *)v6 == 4096)
      {
        v4 += *(_DWORD *)(v6 + 8);
      }
      else
      {
        BOOL v9 = v8 > 0x26;
        uint64_t v10 = (1 << v8) & 0x7C10000000;
        if (!v9 && v10 != 0)
        {
          uint64_t Impl = 0;
          goto LABEL_19;
        }
        unsigned int Size = llvm::DIExpression::ExprOperand::getSize(&v21);
        sub_1CBFCBB74((unsigned int *)&v23, (unsigned char *)v6, (unsigned char *)(v6 + 8 * Size));
      }
      v6 += 8 * llvm::DIExpression::ExprOperand::getSize(&v22);
      uint64_t v22 = (uint64_t *)v6;
    }
    while (v6 != v7);
    unsigned int v13 = v24;
    if (v24 >= HIDWORD(v24)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
  }
  *((void *)v23 + v13) = 4096;
  unsigned int v14 = v24 + 1;
  LODWORD(v24) = v14;
  if (v14 >= HIDWORD(v24)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v23 + v14) = v4;
  unsigned int v15 = v24 + 1;
  LODWORD(v24) = v15;
  if (v15 >= HIDWORD(v24)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v23 + v15) = a3;
  uint64_t v16 = (v24 + 1);
  LODWORD(v24) = v24 + 1;
  uint64_t v17 = *((void *)this + 2);
  uint64_t v18 = (void *)(v17 & 0xFFFFFFFFFFFFFFF8);
  if ((v17 & 4) != 0) {
    uint64_t v18 = (void *)*v18;
  }
  uint64_t Impl = llvm::DIExpression::getImpl(v18, v23, v16, 0, 1);
LABEL_19:
  if (v23 != v25) {
    free(v23);
  }
  return Impl;
}

uint64_t llvm::DIExpression::isConstant(llvm::DIExpression *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  unint64_t v2 = *((void *)this + 4) - (void)v1;
  if ((v2 >> 3) <= 6 && ((1 << (v2 >> 3)) & 0x4C) != 0)
  {
    uint64_t v7 = *v1;
    if ((*v1 & 0xFFFFFFFFFFFFFFFELL) == 0x10)
    {
      uint64_t v8 = v2 & 0x7FFFFFFF8;
      if (v8 == 48)
      {
        if (v1[2] == 159 && v1[3] == 4096) {
          goto LABEL_15;
        }
      }
      else
      {
        if (v8 != 24)
        {
          if (v8 == 16 && v7 == 17)
          {
            BOOL v5 = 0;
            goto LABEL_16;
          }
LABEL_15:
          BOOL v5 = v7 == 16;
LABEL_16:
          uint64_t v4 = 0x100000000;
          return v5 | v4;
        }
        if (v1[2] == 159) {
          goto LABEL_15;
        }
      }
    }
  }
  uint64_t v4 = 0;
  BOOL v5 = 0;
  return v5 | v4;
}

uint64_t llvm::DIExpression::getExtOps@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, int a3@<W2>, void *a4@<X8>)
{
  *a4 = 4097;
  a4[1] = this;
  uint64_t v4 = 7;
  if (a3) {
    uint64_t v4 = 5;
  }
  a4[2] = v4;
  a4[3] = 4097;
  a4[4] = a2;
  a4[5] = v4;
  return this;
}

llvm::MDNode *llvm::DIExpression::appendExt(llvm::DIExpression *this, const llvm::DIExpression *a2, unsigned int a3, int a4)
{
  v6[0] = 4097;
  v6[1] = a2;
  uint64_t v4 = 7;
  if (a4) {
    uint64_t v4 = 5;
  }
  void v6[2] = v4;
  v6[3] = 4097;
  v6[4] = a3;
  v6[5] = v4;
  return llvm::DIExpression::appendToStack(this, v6, 6);
}

llvm::MDNode *sub_1CD5B28F8(llvm::MDNode *result, int a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    if (a2 == 1)
    {
      unsigned int v3 = result;
      llvm::MDNode::storeDistinctInContext(result);
      return v3;
    }
  }
  else
  {
    sub_1CD5B8340(a3, &v4, (uint64_t)v5);
    return v4;
  }
  return result;
}

unsigned int *sub_1CD5B2958(llvm::MDNode *this, int a2, uint64_t a3)
{
  unsigned int v3 = this;
  BOOL v5 = (unsigned int *)this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B8A70(a3, &v5, (uint64_t)v6);
    return v5;
  }
  return (unsigned int *)v3;
}

llvm::MDNode *sub_1CD5B29BC(llvm::MDNode *this, int a2, uint64_t a3)
{
  unsigned int v3 = this;
  BOOL v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B91F0(a3, (uint64_t *)&v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

llvm::MDNode *sub_1CD5B2A20(llvm::MDNode *this, int a2, uint64_t a3)
{
  unsigned int v3 = this;
  BOOL v5 = this;
  if (a2 == 1)
  {
    llvm::MDNode::storeDistinctInContext(this);
  }
  else if (!a2)
  {
    sub_1CD5B9694(a3, &v5, (uint64_t)v6);
    return v5;
  }
  return v3;
}

void llvm::DIArgList::handleChangedOperand(llvm::DIArgList *this, unsigned __int8 *a2, llvm::Metadata *a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = *((unsigned int *)this + 8);
  if (v6)
  {
    uint64_t v7 = (void **)*((void *)this + 3);
    uint64_t v8 = 8 * v6;
    do
    {
      a2 = (unsigned __int8 *)*v7;
      if (*v7) {
        llvm::MetadataTracking::untrack((uint64_t)v7, a2);
      }
      ++v7;
      v8 -= 8;
    }
    while (v8);
  }
  int v9 = *((unsigned char *)this + 1) & 0x7F;
  if ((*((unsigned char *)this + 1) & 0x7F) == 0) {
    llvm::MDNode::eraseFromStore(this);
  }
  uint64_t v10 = *((unsigned int *)this + 8);
  if (v10)
  {
    uint64_t v11 = (unsigned __int8 *)*((void *)this + 3);
    uint64_t v12 = 8 * v10;
    do
    {
      if (v11 == v4)
      {
        unsigned int v13 = a3;
        if (!a3)
        {
          unsigned int v14 = (llvm::ValueAsMetadata *)llvm::UndefValue::get(**(llvm::UndefValue ***)(*(void *)v4 + 128), (llvm::Type *)a2);
          unsigned int v13 = (llvm::Metadata *)llvm::ValueAsMetadata::get(v14, v15);
        }
        *(void *)uint64_t v4 = v13;
      }
      v11 += 8;
      v12 -= 8;
    }
    while (v12);
  }
  if (!v9 && llvm::MDNode::uniquify(this) != (unsigned int *)this) {
    llvm::MDNode::storeDistinctInContext(this);
  }
  uint64_t v16 = *((unsigned int *)this + 8);
  if (v16)
  {
    uint64_t v17 = (unsigned __int8 **)*((void *)this + 3);
    unint64_t v18 = (unint64_t)this | 2;
    uint64_t v19 = 8 * v16;
    do
    {
      if (*v17) {
        llvm::MetadataTracking::track((uint64_t)v17, *v17, v18);
      }
      ++v17;
      v19 -= 8;
    }
    while (v19);
  }
}

uint64_t llvm::DIArgList::untrack(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 32);
  if (v1)
  {
    unint64_t v2 = *(unsigned __int8 ***)(this + 24);
    uint64_t v3 = 8 * v1;
    do
    {
      if (*v2) {
        this = llvm::MetadataTracking::untrack((uint64_t)v2, *v2);
      }
      ++v2;
      v3 -= 8;
    }
    while (v3);
  }
  return this;
}

uint64_t llvm::DIArgList::dropAllReferences(llvm::DIArgList *this)
{
  uint64_t v2 = *((unsigned int *)this + 8);
  if (v2)
  {
    uint64_t v3 = (unsigned __int8 **)*((void *)this + 3);
    uint64_t v4 = 8 * v2;
    do
    {
      if (*v3) {
        llvm::MetadataTracking::untrack((uint64_t)v3, *v3);
      }
      ++v3;
      v4 -= 8;
    }
    while (v4);
  }
  *((_DWORD *)this + sub_1CD521E44((uint64_t)this + 8) = 0;

  return llvm::MDNode::dropAllReferences((uint64_t)this);
}

uint64_t sub_1CD5B2C50(uint64_t a1, uint64_t a2, char a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v8 = llvm::MDNode::MDNode(a1, a2, 32, a3, 0, 0, 0, 0);
  int v9 = &a4[8 * a5];
  *(void *)(v8 + 24) = v8 + 40;
  uint64_t v10 = v8 + 24;
  *(void *)(v8 + 32) = 0x400000000;
  sub_1CD47792C((unsigned int *)(v8 + 24), a4, v9);
  uint64_t v11 = *(unsigned int *)(v10 + 8);
  if (v11)
  {
    uint64_t v12 = *(unsigned __int8 ***)v10;
    uint64_t v13 = 8 * v11;
    do
    {
      if (*v12) {
        llvm::MetadataTracking::track((uint64_t)v12, *v12, a1 | 2);
      }
      ++v12;
      v13 -= 8;
    }
    while (v13);
  }
  return a1;
}

uint64_t sub_1CD5B2CFC(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v16 = *(_DWORD *)(a2 + 32);
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & sub_1CD5B2E3C(&v16, (int *)(a2 + 36), (uint64_t *)(a2 + 40));
    BOOL v5 = (uint64_t *)(v8 + 8 * v10);
    if (sub_1CD5B2DF8(a2, *v5))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      while (*v5 != -4096)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = *v5 == -8192;
        }
        if (v13) {
          uint64_t v11 = v5;
        }
        int v14 = v12 + 1;
        unsigned int v10 = (v10 + v12) & v9;
        BOOL v5 = (uint64_t *)(v8 + 8 * v10);
        BOOL v15 = sub_1CD5B2DF8(a2, *v5);
        uint64_t result = 1;
        int v12 = v14;
        if (v15) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v11) {
        BOOL v5 = v11;
      }
    }
  }
  else
  {
    BOOL v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

BOOL sub_1CD5B2DF8(uint64_t a1, uint64_t a2)
{
  return (a2 | 0x1000) != 0xFFFFFFFFFFFFF000
      && *(_DWORD *)(a1 + 36) == *(unsigned __int16 *)(a2 + 2)
      && *(void *)(a1 + 40) == *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8))
      && sub_1CD5B2EF4(a1, a2, 1u);
}

unint64_t sub_1CD5B2E3C(_DWORD *a1, int *a2, uint64_t *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LODWORD(v7[0]) = *a1;
  return sub_1CD53AD84(v7, 0, (_DWORD *)v7 + 1, (char *)v8, a2, a3);
}

BOOL sub_1CD5B2EF4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 32) != *(_DWORD *)(a2 + 4)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    if (v3 == v4 - a3)
    {
      BOOL v5 = *(uint64_t **)a1;
      uint64_t v6 = (uint64_t *)(a2 - 8 * v4 + 8 * a3);
      uint64_t v7 = 8 * v3 - 8;
      do
      {
        uint64_t v9 = *v5++;
        uint64_t v8 = v9;
        uint64_t v10 = *v6++;
        BOOL result = v8 == v10;
        BOOL v12 = v8 != v10 || v7 == 0;
        v7 -= 8;
      }
      while (!v12);
      return result;
    }
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 24);
  uint64_t v14 = *(unsigned int *)(a2 + 8);
  if (v13 != v14 - a3) {
    return 0;
  }
  if (!v13) {
    return 1;
  }
  BOOL v15 = *(uint64_t **)(a1 + 16);
  int v16 = (uint64_t *)(a2 - 8 * v14 + 8 * a3);
  uint64_t v17 = 8 * v13 - 8;
  do
  {
    uint64_t v19 = *v15++;
    uint64_t v18 = v19;
    uint64_t v20 = *v16++;
    BOOL result = v18 == v20;
    BOOL v21 = v18 != v20 || v17 == 0;
    v17 -= 8;
  }
  while (!v21);
  return result;
}

uint64_t sub_1CD5B2FAC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B3034((uint64_t *)a1, a2, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B3154(a1, (uint64_t)a2, a2, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B3034(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD5B30F8(*a2);
    int v10 = v4 - 1;
    unsigned int v11 = v9 & (v4 - 1);
    BOOL v5 = (void *)(v8 + 8 * v11);
    uint64_t v12 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -8192;
        }
        if (v15) {
          uint64_t v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        BOOL v5 = (void *)(v8 + 8 * (v16 & v10));
        uint64_t v12 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        BOOL v5 = v13;
      }
    }
  }
  else
  {
    BOOL v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B30F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 - 8 * *(unsigned int *)(a1 + 8));
  int v3 = *(_DWORD *)(a1 + 4);
  int v4 = *(unsigned __int16 *)(a1 + 2);
  uint64_t v5 = v1;
  int v6 = v3;
  return sub_1CD5B2E3C(&v6, &v4, &v5);
}

void *sub_1CD5B3154(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B3204(a1, v7);
  int v9 = 0;
  sub_1CD5B3034((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B3204(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B32D0(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B32D0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B3034((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B3380(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    unsigned int v7 = sub_1CD5B345C(a2);
    uint64_t v8 = 0;
    int v9 = v4 - 1;
    for (int i = 1; ; ++i)
    {
      unsigned int v11 = v7 & v9;
      uint64_t v12 = (uint64_t *)(v6 + 8 * (v7 & v9));
      uint64_t v13 = *v12;
      if (*v12 != -4096 && v13 != -8192)
      {
        if (sub_1CD5B3578((unsigned char **)a2, v13))
        {
          uint64_t result = 1;
          goto LABEL_7;
        }
        uint64_t v13 = *v12;
      }
      if (v13 == -4096) {
        break;
      }
      if (v8) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v13 == -8192;
      }
      if (v15) {
        uint64_t v8 = (uint64_t *)(v6 + 8 * v11);
      }
      unsigned int v7 = v11 + i;
    }
    uint64_t result = 0;
    if (v8) {
      uint64_t v12 = v8;
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v12;
  return result;
}

unint64_t sub_1CD5B345C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(unsigned char *)v1 != 1) {
    return sub_1CC593480(a1, a1 + 1, a1 + 2, a1 + 3);
  }
  uint64_t v2 = *(void *)(v1 + 128);
  unsigned int v3 = *(_DWORD *)(v2 + 32);
  if (v3 > 0x40) {
    uint64_t v4 = **(void **)(v2 + 24);
  }
  else {
    uint64_t v4 = (uint64_t)(*(void *)(v2 + 24) << -(char)v3) >> -(char)v3;
  }
  uint64_t v6 = v4;
  return sub_1CC593480(&v6, a1 + 1, a1 + 2, a1 + 3);
}

unint64_t sub_1CD5B34E4(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v16 = a2;
  uint64_t v13 = sub_1CC2E96A4(a1, &v16, a3, (unint64_t)a4, *a5);
  uint64_t v17 = v16;
  int v14 = sub_1CC2E96A4(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CC36B408(a1, v17, v14, a4, a7, a8);
}

BOOL sub_1CD5B3578(unsigned char **a1, uint64_t a2)
{
  BOOL result = sub_1CD5B3614((uint64_t)&v5, *a1, *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8)));
  if (result)
  {
    BOOL result = sub_1CD5B3614((uint64_t)&v5, a1[1], *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8) + 8));
    if (result)
    {
      BOOL result = sub_1CD5B3614((uint64_t)&v5, a1[2], *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8) + 16));
      if (result) {
        return sub_1CD5B3614((uint64_t)&v5, a1[3], *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8) + 24));
      }
    }
  }
  return result;
}

BOOL sub_1CD5B3614(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  BOOL result = 1;
  if (a2 != (unsigned char *)a3)
  {
    if (a2) {
      unsigned int v3 = *a2 == 1 ? a2 : 0;
    }
    else {
      unsigned int v3 = 0;
    }
    if (!a3 || !v3 || *(unsigned char *)a3 != 1) {
      return 0;
    }
    uint64_t v4 = *((void *)v3 + 16);
    uint64_t v5 = *(void *)(a3 + 128);
    unsigned int v6 = *(_DWORD *)(v4 + 32);
    uint64_t v7 = v6 > 0x40 ? **(void **)(v4 + 24) : (uint64_t)(*(void *)(v4 + 24) << -(char)v6) >> -(char)v6;
    unsigned int v8 = *(_DWORD *)(v5 + 32);
    uint64_t v9 = v8 > 0x40 ? **(void **)(v5 + 24) : (uint64_t)(*(void *)(v5 + 24) << -(char)v8) >> -(char)v8;
    if (v7 != v9) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1CD5B36B8@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B3740((uint64_t *)a1, (uint64_t)a2, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B3828(a1, (uint64_t)a2, (uint64_t)a2, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B3740(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = (_OWORD *)(*(void *)a2 - 8 * *(unsigned int *)(*(void *)a2 + 8));
    v18[0] = *v7;
    v18[1] = v7[1];
    int v8 = sub_1CD5B345C((uint64_t *)v18);
    int v9 = v4 - 1;
    unsigned int v10 = v8 & (v4 - 1);
    unsigned int v11 = (void *)(v6 + 8 * v10);
    uint64_t v12 = *v11;
    if (*(void *)a2 == *v11)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v12 == -8192;
        }
        if (v16) {
          uint64_t v13 = v11;
        }
        unsigned int v17 = v10 + v14++;
        unsigned int v10 = v17 & v9;
        unsigned int v11 = (void *)(v6 + 8 * (v17 & v9));
        uint64_t v12 = *v11;
        if (*(void *)a2 == *v11) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v13) {
        unsigned int v11 = v13;
      }
    }
  }
  else
  {
    unsigned int v11 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v11;
  return result;
}

void *sub_1CD5B3828(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CC59353C(a1, v7);
  int v9 = 0;
  sub_1CD5B3740((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B38DC(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B3740((uint64_t *)v5, (uint64_t)a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B398C(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
    goto LABEL_3;
  }
  uint64_t v8 = *a1;
  unsigned int v9 = sub_1CD5B3A84(a2);
  unsigned int v10 = 0;
  int v11 = v4 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v13 = v9 & v11;
    uint64_t v5 = (uint64_t *)(v8 + 8 * (v9 & v11));
    uint64_t v14 = *v5;
    if (*v5 == -8192) {
      goto LABEL_8;
    }
    if (v14 == -4096) {
      break;
    }
    BOOL v15 = (void *)(v14 - 8 * *(unsigned int *)(v14 + 8));
    if (*a2 == *v15 && a2[1] == v15[1] && a2[2] == v15[2] && a2[3] == v15[3])
    {
      uint64_t result = 1;
      goto LABEL_3;
    }
LABEL_8:
    if (v10) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = v14 == -8192;
    }
    if (v16) {
      unsigned int v10 = (uint64_t *)(v8 + 8 * v13);
    }
    unsigned int v9 = v13 + i;
  }
  uint64_t result = 0;
  if (v10) {
    uint64_t v5 = v10;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B3A84(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1 || *(unsigned char *)v1 != 1) {
    return sub_1CC593480(a1, a1 + 1, a1 + 2, a1 + 3);
  }
  uint64_t v2 = *(void *)(v1 + 128);
  unsigned int v3 = *(_DWORD *)(v2 + 32);
  if (v3 > 0x40) {
    uint64_t v4 = **(void **)(v2 + 24);
  }
  else {
    uint64_t v4 = (uint64_t)(*(void *)(v2 + 24) << -(char)v3) >> -(char)v3;
  }
  uint64_t v6 = v4;
  return sub_1CC593480(&v6, a1 + 1, a1 + 2, a1 + 3);
}

uint64_t sub_1CD5B3B0C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v10 = 0;
  uint64_t result = sub_1CD5B3B94((uint64_t *)a1, (uint64_t)a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B3C7C(a1, (uint64_t)a2, (uint64_t)a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B3B94(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = (_OWORD *)(*(void *)a2 - 8 * *(unsigned int *)(*(void *)a2 + 8));
    v18[0] = *v9;
    v18[1] = v9[1];
    int v10 = sub_1CD5B3A84((uint64_t *)v18);
    int v11 = v4 - 1;
    unsigned int v12 = v10 & (v4 - 1);
    uint64_t v5 = (void *)(v8 + 8 * v12);
    uint64_t v13 = *v5;
    if (*(void *)a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v14 = 0;
      int v15 = 1;
      uint64_t result = 1;
      while (v13 != -4096)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v13 == -8192;
        }
        if (v16) {
          uint64_t v14 = v5;
        }
        unsigned int v17 = v12 + v15++;
        unsigned int v12 = v17 & v11;
        uint64_t v5 = (void *)(v8 + 8 * (v17 & v11));
        uint64_t v13 = *v5;
        if (*(void *)a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v14) {
        uint64_t v5 = v14;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

void *sub_1CD5B3C7C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B3D2C(a1, v7);
  uint64_t v9 = 0;
  sub_1CD5B3B94((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B3D2C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B3DF8(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B3DF8(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5B3B94((uint64_t *)v5, (uint64_t)a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B3EA8(uint64_t *a1, llvm *this, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = 0;
    int v8 = v4 - 1;
    unsigned int v9 = v8 & sub_1CC593608(this, (uint64_t *)this + 2);
    for (int i = 1; ; ++i)
    {
      uint64_t v11 = (uint64_t *)(v6 + 8 * v9);
      uint64_t v12 = *v11;
      if (*v11 != -4096 && v12 != -8192)
      {
        if (sub_1CD5B3F8C((uint64_t)this, v12))
        {
          uint64_t result = 1;
          goto LABEL_7;
        }
        uint64_t v12 = *v11;
      }
      if (v12 == -4096) {
        break;
      }
      if (v7) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v12 == -8192;
      }
      if (v14) {
        int v7 = (uint64_t *)(v6 + 8 * v9);
      }
      unsigned int v15 = v9 + i;
      unsigned int v9 = v15 & v8;
    }
    uint64_t result = 0;
    if (v7) {
      uint64_t v11 = v7;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v11;
  return result;
}

BOOL sub_1CD5B3F8C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != *(_DWORD *)(a2 + 32)) {
    return 0;
  }
  if (v2 > 0x40)
  {
    uint64_t v5 = a2;
    uint64_t v6 = a1;
    BOOL v4 = llvm::APInt::equalSlowCase((const void **)a1, (const void **)(a2 + 24));
    a2 = v5;
    a1 = v6;
    if (!v4) {
      return 0;
    }
  }
  else if (*(void *)a1 != *(void *)(a2 + 24))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 24) != (*(_DWORD *)(a2 + 4) != 0)) {
    return 0;
  }
  return *(void *)(a1 + 16) == *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
}

uint64_t sub_1CD5B4028@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CC5937E0((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B4194(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

unint64_t sub_1CD5B40B0(uint64_t a1)
{
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  if (v6 > 0x40) {
    operator new[]();
  }
  int v1 = *(_DWORD *)(a1 + 4);
  uint64_t v2 = *(void *)(a1 - 8 * *(unsigned int *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v7 = v2;
  BOOL v8 = v1 != 0;
  unint64_t result = sub_1CC593608((llvm *)&v5, &v7);
  if (v6 >= 0x41)
  {
    if (v5)
    {
      unint64_t v4 = result;
      MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
      return v4;
    }
  }
  return result;
}

void *sub_1CD5B4194(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC59389C(a1, v7);
  uint64_t v9 = 0;
  sub_1CC5937E0((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B4248(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      unint64_t result = sub_1CC5937E0((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B42F0(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    unsigned int v7 = 0;
    int v8 = v4 - 1;
    unsigned int v9 = v8 & sub_1CC593968((_DWORD *)a2, (uint64_t *)(a2 + 8), (uint64_t *)(a2 + 16), (int *)(a2 + 24), (int *)(a2 + 28));
    for (int i = 1; ; ++i)
    {
      uint64_t v11 = (uint64_t *)(v6 + 8 * v9);
      uint64_t v12 = *v11;
      if (*v11 != -4096 && v12 != -8192)
      {
        if (sub_1CD5B4474(a2, v12))
        {
          uint64_t result = 1;
          goto LABEL_7;
        }
        uint64_t v12 = *v11;
      }
      if (v12 == -4096) {
        break;
      }
      if (v7) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v12 == -8192;
      }
      if (v14) {
        unsigned int v7 = (uint64_t *)(v6 + 8 * v9);
      }
      unsigned int v15 = v9 + i;
      unsigned int v9 = v15 & v8;
    }
    uint64_t result = 0;
    if (v7) {
      uint64_t v11 = v7;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v11;
  return result;
}

unint64_t sub_1CD5B43E0(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, int *a7, int *a8)
{
  uint64_t v16 = a2;
  uint64_t v13 = sub_1CC2E96A4(a1, &v16, a3, (unint64_t)a4, *a5);
  uint64_t v17 = v16;
  BOOL v14 = sub_1CC2E96A4(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CC36B194(a1, v17, v14, a4, a7, a8);
}

BOOL sub_1CD5B4474(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)a1 == *(unsigned __int16 *)(a2 + 2)
      && *(void *)(a1 + 8) == *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8) + 16)
      && *(void *)(a1 + 16) == *(void *)(a2 + 32)
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 48)
      && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 52)
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 28);
}

uint64_t sub_1CD5B44E8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B4570((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B4680(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B4570(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = *a2;
    int v19 = *(unsigned __int16 *)(*a2 + 2);
    uint64_t v8 = *(void *)(v7 + 32);
    uint64_t v20 = *(void *)(v7 - 8 * *(unsigned int *)(v7 + 8) + 16);
    uint64_t v21 = v8;
    uint64_t v22 = *(void *)(v7 + 48);
    int v23 = *(_DWORD *)(v7 + 28);
    int v9 = sub_1CC593968(&v19, &v20, &v21, (int *)&v22, (int *)&v22 + 1);
    int v10 = v4 - 1;
    unsigned int v11 = (v4 - 1) & v9;
    uint64_t v12 = (void *)(v6 + 8 * v11);
    uint64_t v13 = *v12;
    if (*a2 == *v12)
    {
      uint64_t result = 1;
    }
    else
    {
      BOOL v14 = 0;
      int v15 = 1;
      uint64_t result = 1;
      while (v13 != -4096)
      {
        if (v14) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v13 == -8192;
        }
        if (v17) {
          BOOL v14 = v12;
        }
        unsigned int v18 = v11 + v15++;
        unsigned int v11 = v18 & v10;
        uint64_t v12 = (void *)(v6 + 8 * (v18 & v10));
        uint64_t v13 = *v12;
        if (*a2 == *v12) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v14) {
        uint64_t v12 = v14;
      }
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v12;
  return result;
}

void *sub_1CD5B4680(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC593A38(a1, v7);
  int v9 = 0;
  sub_1CD5B4570((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B4734(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B4570((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B47E4(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & sub_1CD5B4940((_DWORD *)a2, (uint64_t *)(a2 + 8), (int *)(a2 + 52));
    uint64_t v5 = (uint64_t *)(v8 + 8 * v10);
    if (sub_1CD5B48D0(a2, *v5))
    {
      uint64_t result = 1;
    }
    else
    {
      unsigned int v11 = 0;
      int v12 = 1;
      while (*v5 != -4096)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = *v5 == -8192;
        }
        if (v13) {
          unsigned int v11 = v5;
        }
        int v14 = v12 + 1;
        unsigned int v10 = (v10 + v12) & v9;
        uint64_t v5 = (uint64_t *)(v8 + 8 * v10);
        BOOL v15 = sub_1CD5B48D0(a2, *v5);
        uint64_t result = 1;
        int v12 = v14;
        if (v15) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v5 = v11;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

BOOL sub_1CD5B48D0(uint64_t a1, uint64_t a2)
{
  return (a2 | 0x1000) != 0xFFFFFFFFFFFFF000
      && *(_DWORD *)a1 == *(unsigned __int16 *)(a2 + 2)
      && *(void *)(a1 + 8) == *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8) + 16)
      && *(void *)(a1 + 40) == *(void *)(a2 + 32)
      && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a2 + 48)
      && *(_DWORD *)(a1 + 52) == *(_DWORD *)(a2 + 52);
}

unint64_t sub_1CD5B4940(_DWORD *a1, uint64_t *a2, int *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LODWORD(v7[0]) = *a1;
  return sub_1CD5B49F8(v7, 0, (_OWORD *)((char *)v7 + 4), (char *)v8, a2, a3);
}

unint64_t sub_1CD5B49F8(void *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, int *a6)
{
  uint64_t v12 = a2;
  uint64_t v9 = sub_1CC2E96A4(a1, &v12, a3, (unint64_t)a4, *a5);
  uint64_t v13 = v12;
  uint64_t v10 = (char *)sub_1CC0AC9D0(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

uint64_t sub_1CD5B4A74@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B4AFC((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B4C18(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B4AFC(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD5B4BC0(*a2);
    int v10 = v4 - 1;
    unsigned int v11 = v9 & (v4 - 1);
    uint64_t v5 = (void *)(v8 + 8 * v11);
    uint64_t v12 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -8192;
        }
        if (v15) {
          uint64_t v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v5 = (void *)(v8 + 8 * (v16 & v10));
        uint64_t v12 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v5 = v13;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B4BC0(uint64_t a1)
{
  uint64_t v1 = a1 - 8 * *(unsigned int *)(a1 + 8);
  long long v2 = *(_OWORD *)(v1 + 32);
  v5[0] = *(_OWORD *)(v1 + 16);
  v5[1] = v2;
  int v4 = *(unsigned __int16 *)(a1 + 2);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  return sub_1CD5B4940(&v4, (uint64_t *)v5, (int *)&v7 + 1);
}

void *sub_1CD5B4C18(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B4CC8(a1, v7);
  int v9 = 0;
  sub_1CD5B4AFC((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B4CC8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B4D94(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B4D94(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B4AFC((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B4E44(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = 0;
    int v8 = v4 - 1;
    unsigned int v9 = v8 & sub_1CC594738((uint64_t *)(a2 + 8), (uint64_t *)(a2 + 16), (int *)(a2 + 24), (uint64_t *)(a2 + 40), (uint64_t *)(a2 + 32), (uint64_t *)(a2 + 72), (uint64_t *)(a2 + 96), (uint64_t *)(a2 + 152));
    for (int i = 1; ; ++i)
    {
      uint64_t v11 = (uint64_t *)(v6 + 8 * v9);
      uint64_t v12 = *v11;
      if (*v11 != -4096 && v12 != -8192)
      {
        if (sub_1CD5B4F40(a2, v12))
        {
          uint64_t result = 1;
          goto LABEL_7;
        }
        uint64_t v12 = *v11;
      }
      if (v12 == -4096) {
        break;
      }
      if (v7) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v12 == -8192;
      }
      if (v14) {
        int v7 = (uint64_t *)(v6 + 8 * v9);
      }
      unsigned int v15 = v9 + i;
      unsigned int v9 = v15 & v8;
    }
    uint64_t result = 0;
    if (v7) {
      uint64_t v11 = v7;
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v11;
  return result;
}

BOOL sub_1CD5B4F40(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(unsigned __int16 *)(a2 + 2)) {
    return 0;
  }
  long long v2 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (*(void *)(a1 + 8) != v2[2]) {
    return 0;
  }
  uint64_t v3 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v3 = *v2;
  }
  return *(void *)(a1 + 16) == v3
      && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
      && *(void *)(a1 + 32) == v2[1]
      && *(void *)(a1 + 40) == v2[3]
      && *(void *)(a1 + 48) == *(void *)(a2 + 32)
      && *(_DWORD *)(a1 + 64) == *(_DWORD *)(a2 + 48)
      && *(void *)(a1 + 56) == *(void *)(a2 + 40)
      && *(_DWORD *)(a1 + 68) == *(_DWORD *)(a2 + 28)
      && *(void *)(a1 + 72) == v2[4]
      && *(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 52)
      && *(void *)(a1 + 88) == v2[5]
      && *(void *)(a1 + 96) == v2[6]
      && *(void *)(a1 + 104) == v2[7]
      && *(void *)(a1 + 112) == v2[8]
      && *(void *)(a1 + 120) == v2[9]
      && *(void *)(a1 + 128) == v2[10]
      && *(void *)(a1 + 136) == v2[11]
      && *(void *)(a1 + 144) == v2[12]
      && *(void *)(a1 + 152) == v2[13];
}

uint64_t sub_1CD5B50B4@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B513C((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B52BC(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B513C(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    sub_1CD5B5234((uint64_t)&v17, *a2);
    int v7 = sub_1CC594738(&v18, &v19, &v20, v22, &v21, v23, v24, &v25);
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & v7;
    uint64_t v10 = (void *)(v6 + 8 * v9);
    uint64_t v11 = *v10;
    if (*a2 == *v10)
    {
LABEL_14:
      uint64_t result = 1;
    }
    else
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != -4096)
      {
        if (v12) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v11 == -8192;
        }
        if (v15) {
          uint64_t v12 = v10;
        }
        unsigned int v16 = v9 + v13++;
        unsigned int v9 = v16 & v8;
        uint64_t v10 = (void *)(v6 + 8 * (v16 & v8));
        uint64_t v11 = *v10;
        if (*a2 == *v10) {
          goto LABEL_14;
        }
      }
      uint64_t result = 0;
      if (v12) {
        uint64_t v10 = v12;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t result = 0;
  }
  *a3 = v10;
  return result;
}

__n128 sub_1CD5B5234(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(unsigned __int16 *)(a2 + 2);
  long long v2 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v2[2];
  uint64_t v3 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v3 = *v2;
  }
  *(void *)(a1 + 16) = v3;
  int v4 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  uint64_t v5 = v2[3];
  uint64_t v6 = v2[4];
  *(void *)(a1 + 32) = v2[1];
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = v5;
  long long v7 = *(_OWORD *)(a2 + 32);
  LODWORD(v5) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 6sub_1CD521E44((uint64_t)this + 8) = v4;
  *(_OWORD *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = v7;
  *(void *)(a1 + 72) = v6;
  *(_DWORD *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = v5;
  *(_OWORD *)(a1 + 8sub_1CD521E44((uint64_t)this + 8) = *(_OWORD *)(v2 + 5);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(v2 + 7);
  *(_OWORD *)(a1 + 12llvm::MDNode::dumpTree(this, 0) = *(_OWORD *)(v2 + 9);
  __n128 result = *(__n128 *)(v2 + 11);
  *(__n128 *)(a1 + 136) = result;
  *(void *)(a1 + 152) = v2[13];
  return result;
}

void *sub_1CD5B52BC(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC5949E8(a1, v7);
  unsigned int v9 = 0;
  sub_1CD5B513C((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B5370(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v9 = 0;
      __n128 result = sub_1CD5B513C((uint64_t *)v5, a2, &v9);
      *unsigned int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B5420(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & sub_1CD5B5580((uint64_t *)a2, (uint64_t *)(a2 + 8), (int *)(a2 + 16), (int *)(a2 + 20));
    uint64_t v5 = (uint64_t *)(v8 + 8 * v10);
    if (sub_1CD5B5510(a2, *v5))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      while (*v5 != -4096)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = *v5 == -8192;
        }
        if (v13) {
          uint64_t v11 = v5;
        }
        int v14 = v12 + 1;
        unsigned int v10 = (v10 + v12) & v9;
        uint64_t v5 = (uint64_t *)(v8 + 8 * v10);
        BOOL v15 = sub_1CD5B5510(a2, *v5);
        uint64_t result = 1;
        int v12 = v14;
        if (v15) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v5 = v11;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

BOOL sub_1CD5B5510(uint64_t a1, uint64_t a2)
{
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (*(void *)a1 != v3[1]) {
    return 0;
  }
  uint64_t v4 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v4 = *v3;
  }
  return *(void *)(a1 + 8) == v4
      && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 24)
      && *(_DWORD *)(a1 + 20) == *(unsigned __int16 *)(a2 + 28);
}

unint64_t sub_1CD5B5580(uint64_t *a1, uint64_t *a2, int *a3, int *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v12 = sub_1CBF65470();
  return sub_1CD5B43E0((char *)v9, 0, v9, (char *)v10, a1, a2, a3, a4);
}

uint64_t sub_1CD5B563C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v10 = 0;
  uint64_t result = sub_1CD5B56C4((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B57F0(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B56C4(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD5B5788(*a2);
    int v10 = v4 - 1;
    unsigned int v11 = v9 & (v4 - 1);
    uint64_t v5 = (void *)(v8 + 8 * v11);
    uint64_t v12 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -8192;
        }
        if (v15) {
          uint64_t v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v5 = (void *)(v8 + 8 * (v16 & v10));
        uint64_t v12 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v5 = v13;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B5788(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 - 8 * *(unsigned int *)(a1 + 8));
  uint64_t v5 = v1[1];
  uint64_t v2 = a1;
  if (*(unsigned char *)a1 != 15) {
    uint64_t v2 = *v1;
  }
  uint64_t v6 = v2;
  int v3 = *(unsigned __int16 *)(a1 + 28);
  int v7 = *(_DWORD *)(a1 + 24);
  int v8 = v3;
  return sub_1CD5B5580(&v5, &v6, &v7, &v8);
}

void *sub_1CD5B57F0(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B58A0(a1, v7);
  int v9 = 0;
  sub_1CD5B56C4((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B58A0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B596C(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B596C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B56C4((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B5A1C(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = (void *)(a2 + 8);
    int v10 = sub_1CC596BEC((uint64_t *)a2, (uint64_t *)(a2 + 8));
    uint64_t v11 = 0;
    unsigned int v12 = (v4 - 1) & v10;
    for (int i = 1; ; ++i)
    {
      uint64_t v5 = (uint64_t *)(v8 + 8 * v12);
      uint64_t v14 = *v5;
      if (*v5 == -4096) {
        break;
      }
      if (v14 != -8192)
      {
        uint64_t v17 = v14 - 8 * *(unsigned int *)(v14 + 8);
        if (*(void *)a2 == *(void *)(v17 + 8)
          && *v9 == *(void *)(v17 + 16)
          && *(unsigned char *)(a2 + 16) == (*(unsigned char *)(v14 + 24) & 1))
        {
          uint64_t result = 1;
          goto LABEL_3;
        }
        if (v14 == -4096) {
          break;
        }
      }
      if (v11) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v14 == -8192;
      }
      if (v15) {
        uint64_t v11 = (uint64_t *)(v8 + 8 * v12);
      }
      unsigned int v16 = v12 + i;
      unsigned int v12 = v16 & (v4 - 1);
    }
    uint64_t result = 0;
    if (v11) {
      uint64_t v5 = v11;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B5B20(void *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t v12 = a2;
  int v9 = sub_1CC2E96A4(a1, &v12, a3, (unint64_t)a4, *a5);
  uint64_t v13 = v12;
  int v10 = (char *)sub_1CC2E96A4(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

uint64_t sub_1CD5B5B9C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v10 = 0;
  uint64_t result = sub_1CD5B5C24((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B5D18(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B5C24(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = *a2;
    long long v18 = *(_OWORD *)(*a2 - 8 * *(unsigned int *)(*a2 + 8) + 8);
    char v19 = *(unsigned char *)(v7 + 24) & 1;
    int v8 = sub_1CC596BEC((uint64_t *)&v18, (uint64_t *)&v18 + 1);
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & v8;
    uint64_t v11 = (void *)(v6 + 8 * v10);
    uint64_t v12 = *v11;
    if (*a2 == *v11)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v12 == -8192;
        }
        if (v16) {
          uint64_t v13 = v11;
        }
        unsigned int v17 = v10 + v14++;
        unsigned int v10 = v17 & v9;
        uint64_t v11 = (void *)(v6 + 8 * (v17 & v9));
        uint64_t v12 = *v11;
        if (*a2 == *v11) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v11 = v13;
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v11;
  return result;
}

void *sub_1CD5B5D18(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_3:
    sub_1CC596C90(a1, v7);
    int v9 = 0;
    sub_1CD5B5C24((uint64_t *)a1, a3, &v9);
    a4 = v9;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B5DCC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B5C24((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B5E7C(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & sub_1CD5B5FE0((uint64_t *)a2, (uint64_t *)(a2 + 8), (uint64_t *)(a2 + 16), (uint64_t *)(a2 + 24), (int *)(a2 + 32));
    uint64_t v5 = (uint64_t *)(v8 + 8 * v10);
    if (sub_1CD5B5F70(a2, *v5))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      while (*v5 != -4096)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = *v5 == -8192;
        }
        if (v13) {
          uint64_t v11 = v5;
        }
        int v14 = v12 + 1;
        unsigned int v10 = (v10 + v12) & v9;
        uint64_t v5 = (uint64_t *)(v8 + 8 * v10);
        BOOL v15 = sub_1CD5B5F70(a2, *v5);
        uint64_t result = 1;
        int v12 = v14;
        if (v15) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v5 = v11;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

BOOL sub_1CD5B5F70(uint64_t a1, uint64_t a2)
{
  if ((a2 | 0x1000) != 0xFFFFFFFFFFFFF000
    && (uint64_t v3 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8)), *(void *)a1 == *v3)
    && *(void *)(a1 + 8) == v3[1]
    && *(void *)(a1 + 16) == v3[2]
    && *(void *)(a1 + 24) == v3[3])
  {
    return *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24);
  }
  else
  {
    return 0;
  }
}

unint64_t sub_1CD5B5FE0(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, int *a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  uint64_t v10 = sub_1CBF65470();
  uint64_t v11 = *a1;
  uint64_t v15 = v10;
  uint64_t v13 = v11;
  return sub_1CC595EB0((char *)&v13, 0, v14, (char *)&v14[3] + 8, a2, a3, a4, a5);
}

uint64_t sub_1CD5B60B0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B6138((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B624C(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B6138(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD5B61FC(*a2);
    int v10 = v4 - 1;
    unsigned int v11 = v9 & (v4 - 1);
    uint64_t v5 = (void *)(v8 + 8 * v11);
    uint64_t v12 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -8192;
        }
        if (v15) {
          uint64_t v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v5 = (void *)(v8 + 8 * (v16 & v10));
        uint64_t v12 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v5 = v13;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B61FC(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 - 8 * *(unsigned int *)(a1 + 8));
  long long v2 = v1[1];
  long long v4 = *v1;
  long long v5 = v2;
  v6[0] = *(_DWORD *)(a1 + 24);
  return sub_1CD5B5FE0((uint64_t *)&v4, (uint64_t *)&v4 + 1, (uint64_t *)&v5, (uint64_t *)&v5 + 1, v6);
}

void *sub_1CD5B624C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B62FC(a1, v7);
  int v9 = 0;
  sub_1CD5B6138((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B62FC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  long long v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B63C8(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B63C8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B6138((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

BOOL sub_1CD5B6478(uint64_t a1, uint64_t a2)
{
  long long v2 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (*(void *)(a1 + 8) != v2[1]
    || *(void *)(a1 + 16) != v2[2]
    || *(void *)(a1 + 24) != v2[3]
    || *(void *)(a1 + 32) != v2[4]
    || *(void *)(a1 + 40) != v2[5])
  {
    return 0;
  }
  uint64_t v4 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v4 = *v2;
  }
  return *(void *)a1 == v4
      && *(_DWORD *)(a1 + 48) == *(_DWORD *)(a2 + 24)
      && *(unsigned __int8 *)(a1 + 52) == *(unsigned __int8 *)(a2 + 28);
}

uint64_t sub_1CD5B651C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CC596FDC((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B65C4(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = (void *)(a2 + 8);
    uint64_t v10 = (unsigned __int8 *)(a2 + 16);
    int v11 = sub_1CC5972A0((uint64_t *)a2, (uint64_t *)(a2 + 8), (char *)(a2 + 16));
    uint64_t v12 = 0;
    unsigned int v13 = (v4 - 1) & v11;
    for (int i = 1; ; ++i)
    {
      uint64_t v5 = (uint64_t *)(v8 + 8 * v13);
      uint64_t v15 = *v5;
      if (*v5 == -4096) {
        break;
      }
      if (v15 != -8192)
      {
        long long v18 = (void *)(v15 - 8 * *(unsigned int *)(v15 + 8));
        if (*(void *)a2 == *v18 && *v9 == v18[1] && *v10 == *(unsigned __int8 *)(v15 + 24))
        {
          uint64_t result = 1;
          goto LABEL_7;
        }
        if (v15 == -4096) {
          break;
        }
      }
      if (v12) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v15 == -8192;
      }
      if (v16) {
        uint64_t v12 = (uint64_t *)(v8 + 8 * v13);
      }
      unsigned int v17 = v13 + i;
      unsigned int v13 = v17 & (v4 - 1);
    }
    uint64_t result = 0;
    if (v12) {
      uint64_t v5 = v12;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v5;
  return result;
}

uint64_t sub_1CD5B66CC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B6754((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B6848(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B6754(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = *a2;
    long long v18 = *(_OWORD *)(*a2 - 8 * *(unsigned int *)(*a2 + 8));
    v19[0] = *(unsigned char *)(v7 + 24);
    int v8 = sub_1CC5972A0((uint64_t *)&v18, (uint64_t *)&v18 + 1, v19);
    int v9 = v4 - 1;
    unsigned int v10 = (v4 - 1) & v8;
    int v11 = (void *)(v6 + 8 * v10);
    uint64_t v12 = *v11;
    if (*a2 == *v11)
    {
      uint64_t result = 1;
    }
    else
    {
      unsigned int v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v12 == -8192;
        }
        if (v16) {
          unsigned int v13 = v11;
        }
        unsigned int v17 = v10 + v14++;
        unsigned int v10 = v17 & v9;
        int v11 = (void *)(v6 + 8 * (v17 & v9));
        uint64_t v12 = *v11;
        if (*a2 == *v11) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v13) {
        int v11 = v13;
      }
    }
  }
  else
  {
    int v11 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v11;
  return result;
}

void *sub_1CD5B6848(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CC597358(a1, v7);
  int v9 = 0;
  sub_1CD5B6754((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B68FC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B6754((uint64_t *)v5, a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B69AC(uint64_t *a1, uint64_t a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    char v19 = a3;
    uint64_t v6 = *a1;
    int v8 = v3 - 1;
    unsigned int v9 = (v3 - 1) & sub_1CC597424((_DWORD *)a2, (uint64_t *)(a2 + 8), (uint64_t *)(a2 + 16), (char *)(a2 + 24), (uint64_t *)(a2 + 32));
    uint64_t v18 = a2;
    if (sub_1CD5B6ACC(a2, *(void *)(v6 + 8 * v9)))
    {
      uint64_t result = 1;
      a3 = v19;
      int v4 = (void *)(v6 + 8 * v9);
    }
    else
    {
      unsigned int v10 = 0;
      int v11 = 1;
      int v4 = (void *)(v6 + 8 * v9);
      while (1)
      {
        uint64_t v12 = v4;
        uint64_t v13 = *v4;
        if (v13 == -4096) {
          break;
        }
        if (v10) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v13 == -8192;
        }
        if (v14) {
          unsigned int v10 = v12;
        }
        int v15 = v11 + 1;
        unsigned int v9 = (v9 + v11) & v8;
        BOOL v16 = sub_1CD5B6ACC(v18, *(void *)(v6 + 8 * v9));
        int v4 = (void *)(v6 + 8 * v9);
        BOOL v17 = v16;
        uint64_t result = 1;
        int v11 = v15;
        a3 = v19;
        if (v17) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v10) {
        int v4 = v10;
      }
      else {
        int v4 = v12;
      }
      a3 = v19;
    }
  }
  else
  {
    int v4 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v4;
  return result;
}

BOOL sub_1CD5B6ACC(uint64_t a1, uint64_t a2)
{
  if ((a2 | 0x1000) != 0xFFFFFFFFFFFFF000
    && *(_DWORD *)a1 == *(unsigned __int16 *)(a2 + 2)
    && (int v3 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8)), *(void *)(a1 + 8) == *v3)
    && *(void *)(a1 + 16) == v3[1]
    && *(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    return *(void *)(a1 + 32) == v3[2];
  }
  else
  {
    return 0;
  }
}

unint64_t sub_1CD5B6B3C(void *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, char *a7, uint64_t *a8)
{
  uint64_t v16 = a2;
  uint64_t v13 = sub_1CC2E96A4(a1, &v16, a3, (unint64_t)a4, *a5);
  uint64_t v17 = v16;
  BOOL v14 = sub_1CC2E96A4(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CD5B6BD0(a1, v17, v14, a4, a7, a8);
}

unint64_t sub_1CD5B6BD0(void *a1, uint64_t a2, unsigned char *a3, char *a4, char *a5, uint64_t *a6)
{
  uint64_t v12 = a2;
  unsigned int v9 = sub_1CC0AC730(a1, &v12, a3, (unint64_t)a4, *a5);
  uint64_t v13 = v12;
  unsigned int v10 = (char *)sub_1CC2E96A4(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

uint64_t sub_1CD5B6C4C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v10 = 0;
  uint64_t result = sub_1CD5B6CD4((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B6DE0(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B6CD4(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = *a2;
    int v19 = *(unsigned __int16 *)(*a2 + 2);
    unsigned int v10 = (long long *)(v9 - 8 * *(unsigned int *)(v9 + 8));
    long long v20 = *v10;
    v21[0] = *(unsigned char *)(v9 + 24);
    uint64_t v22 = *((void *)v10 + 2);
    int v11 = sub_1CC597424(&v19, (uint64_t *)&v20, (uint64_t *)&v20 + 1, v21, &v22);
    int v12 = v4 - 1;
    unsigned int v13 = (v4 - 1) & v11;
    uint64_t v5 = (void *)(v8 + 8 * v13);
    uint64_t v14 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      int v15 = 0;
      int v16 = 1;
      uint64_t result = 1;
      while (v14 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -8192;
        }
        if (v17) {
          int v15 = v5;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v5 = (void *)(v8 + 8 * (v18 & v12));
        uint64_t v14 = *v5;
        if (*a2 == *v5) {
          goto LABEL_8;
        }
      }
      uint64_t result = 0;
      if (v15) {
        uint64_t v5 = v15;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_8:
  *a3 = v5;
  return result;
}

void *sub_1CD5B6DE0(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_3:
    sub_1CC5974F4(a1, v7);
    uint64_t v9 = 0;
    sub_1CD5B6CD4((uint64_t *)a1, a3, &v9);
    a4 = v9;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B6E94(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5B6CD4((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B6F44(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = 0;
    int v10 = v4 - 1;
    unsigned int v11 = v10 & sub_1CD5B7048((uint64_t *)a2, (uint64_t *)(a2 + 8), (uint64_t *)(a2 + 16), (uint64_t *)(a2 + 24), (int *)(a2 + 32), (uint64_t *)(a2 + 40), (char *)(a2 + 48), (char *)(a2 + 49), (uint64_t *)(a2 + 56), (uint64_t *)(a2 + 80));
    for (int i = 1; ; ++i)
    {
      uint64_t v5 = (uint64_t *)(v8 + 8 * v11);
      uint64_t v13 = *v5;
      if ((*v5 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        if (sub_1CD5B73F0(a2, v13))
        {
          uint64_t result = 1;
          goto LABEL_3;
        }
        uint64_t v13 = *v5;
      }
      if (v13 == -4096) {
        break;
      }
      if (v9) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v13 == -8192;
      }
      if (v14) {
        uint64_t v9 = (uint64_t *)(v8 + 8 * v11);
      }
      unsigned int v15 = v11 + i;
      unsigned int v11 = v15 & v10;
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v5 = v9;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B7048(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, int *a5, uint64_t *a6, char *a7, char *a8, uint64_t *a9, uint64_t *a10)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  uint64_t v22 = sub_1CBF65470();
  return sub_1CD5B7134((char *)v19, 0, v19, (char *)v20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

unint64_t sub_1CD5B7134(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, int *a9, uint64_t *a10, char *a11, char *a12, uint64_t *a13, uint64_t *a14)
{
  uint64_t v22 = a2;
  int v19 = sub_1CC2E96A4(a1, &v22, a3, (unint64_t)a4, *a5);
  uint64_t v23 = v22;
  long long v20 = sub_1CC2E96A4(a1, &v23, v19, (unint64_t)a4, *a6);
  return sub_1CD5B71FC(a1, v23, v20, a4, a7, a8, a9, a10, a11, a12, a13, a14);
}

unint64_t sub_1CD5B71FC(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, int *a7, uint64_t *a8, char *a9, char *a10, uint64_t *a11, uint64_t *a12)
{
  uint64_t v20 = a2;
  BOOL v17 = sub_1CC2E96A4(a1, &v20, a3, (unint64_t)a4, *a5);
  uint64_t v21 = v20;
  unsigned int v18 = sub_1CC2E96A4(a1, &v21, v17, (unint64_t)a4, *a6);
  return sub_1CD5B72B4(a1, v21, v18, a4, a7, a8, a9, a10, a11, a12);
}

unint64_t sub_1CD5B72B4(char *a1, uint64_t a2, _DWORD *a3, char *a4, int *a5, uint64_t *a6, char *a7, char *a8, uint64_t *a9, uint64_t *a10)
{
  uint64_t v18 = a2;
  unsigned int v15 = sub_1CC0AC9D0(a1, &v18, a3, (unint64_t)a4, *a5);
  uint64_t v19 = v18;
  int v16 = sub_1CC2E96A4(a1, &v19, v15, (unint64_t)a4, *a6);
  return sub_1CD5B735C(a1, v19, v16, a4, a7, a8, a9, a10);
}

unint64_t sub_1CD5B735C(char *a1, uint64_t a2, unsigned char *a3, char *a4, char *a5, char *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v16 = a2;
  uint64_t v13 = sub_1CC0AC730(a1, &v16, a3, (unint64_t)a4, *a5);
  uint64_t v17 = v16;
  BOOL v14 = sub_1CC0AC730(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CC36B408(a1, v17, v14, a4, a7, a8);
}

BOOL sub_1CD5B73F0(uint64_t a1, uint64_t a2)
{
  long long v2 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  return *(void *)a1 == *v2
      && *(void *)(a1 + 8) == v2[1]
      && *(void *)(a1 + 16) == v2[5]
      && *(void *)(a1 + 24) == v2[2]
      && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24)
      && *(void *)(a1 + 40) == v2[3]
      && *(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 32)
      && *(unsigned __int8 *)(a1 + 49) == *(unsigned __int8 *)(a2 + 33)
      && *(void *)(a1 + 56) == v2[6]
      && *(void *)(a1 + 64) == v2[7]
      && *(_DWORD *)(a1 + 72) == *(_DWORD *)(a2 + 28)
      && *(void *)(a1 + 80) == v2[8];
}

uint64_t sub_1CD5B74C4@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v10 = 0;
  uint64_t result = sub_1CD5B754C((uint64_t *)a1, a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B76A4(a1, (uint64_t)a2, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B754C(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD5B7610(*a2);
    int v10 = v4 - 1;
    unsigned int v11 = v9 & (v4 - 1);
    uint64_t v5 = (void *)(v8 + 8 * v11);
    uint64_t v12 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -8192;
        }
        if (v15) {
          uint64_t v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v5 = (void *)(v8 + 8 * (v16 & v10));
        uint64_t v12 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v5 = v13;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B7610(uint64_t a1)
{
  uint64_t v1 = (long long *)(a1 - 8 * *(unsigned int *)(a1 + 8));
  long long v5 = *v1;
  uint64_t v2 = *((void *)v1 + 2);
  uint64_t v3 = *((void *)v1 + 3);
  uint64_t v6 = *((void *)v1 + 5);
  uint64_t v7 = v2;
  LODWORD(v2) = *(_DWORD *)(a1 + 28);
  int v8 = *(_DWORD *)(a1 + 24);
  uint64_t v9 = v3;
  *(_WORD *)int v10 = *(_WORD *)(a1 + 32);
  long long v11 = v1[3];
  int v12 = v2;
  uint64_t v13 = *((void *)v1 + 8);
  return sub_1CD5B7048((uint64_t *)&v5, (uint64_t *)&v5 + 1, &v6, &v7, &v8, &v9, v10, &v10[1], (uint64_t *)&v11, &v13);
}

void *sub_1CD5B76A4(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B7754(a1, v7);
  uint64_t v9 = 0;
  sub_1CD5B754C((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B7754(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B7820(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B7820(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5B754C((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B78D0(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
    goto LABEL_3;
  }
  uint64_t v8 = *a1;
  uint64_t v9 = (void *)(a2 + 8);
  uint64_t v10 = (_DWORD *)(a2 + 24);
  int v11 = sub_1CD5B79E4((uint64_t *)a2, (uint64_t *)(a2 + 8), (int *)(a2 + 24));
  int v12 = 0;
  unsigned int v13 = (v4 - 1) & v11;
  for (int i = 1; ; ++i)
  {
    uint64_t v5 = (uint64_t *)(v8 + 8 * v13);
    uint64_t v15 = *v5;
    if (*v5 == -8192) {
      goto LABEL_8;
    }
    if (v15 == -4096) {
      break;
    }
    unsigned int v16 = (void *)(v15 - 8 * *(unsigned int *)(v15 + 8));
    if (*(void *)a2 == *v16 && *v9 == v16[1] && *(void *)(a2 + 16) == v16[2] && *v10 == *(_DWORD *)(v15 + 24))
    {
      uint64_t result = 1;
      goto LABEL_3;
    }
LABEL_8:
    if (v12) {
      BOOL v17 = 0;
    }
    else {
      BOOL v17 = v15 == -8192;
    }
    if (v17) {
      int v12 = (uint64_t *)(v8 + 8 * v13);
    }
    unsigned int v18 = v13 + i;
    unsigned int v13 = v18 & (v4 - 1);
  }
  uint64_t result = 0;
  if (v12) {
    uint64_t v5 = v12;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B79E4(uint64_t *a1, uint64_t *a2, int *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  memset(v10, 0, sizeof(v10));
  uint64_t v6 = sub_1CBF65470();
  uint64_t v7 = *a1;
  uint64_t v11 = v6;
  uint64_t v9 = v7;
  return sub_1CD5B49F8(&v9, 0, v10, (char *)&v10[3] + 8, a2, a3);
}

uint64_t sub_1CD5B7A9C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B7B24((uint64_t *)a1, a2, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B7C20(a1, (uint64_t)a2, a2, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B7B24(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = *a2;
    uint64_t v10 = *a2 - 8 * *(unsigned int *)(*a2 + 8);
    long long v19 = *(_OWORD *)v10;
    uint64_t v20 = *(void *)(v10 + 16);
    int v21 = *(_DWORD *)(v9 + 24);
    int v11 = sub_1CD5B79E4((uint64_t *)&v19, (uint64_t *)&v19 + 1, &v21);
    int v12 = v4 - 1;
    unsigned int v13 = (v4 - 1) & v11;
    uint64_t v5 = (void *)(v8 + 8 * v13);
    uint64_t v14 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      uint64_t result = 1;
      while (v14 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -8192;
        }
        if (v17) {
          uint64_t v15 = v5;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v5 = (void *)(v8 + 8 * (v18 & v12));
        uint64_t v14 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v15) {
        uint64_t v5 = v15;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

void *sub_1CD5B7C20(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B7CD0(a1, v7);
  uint64_t v9 = 0;
  sub_1CD5B7B24((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B7CD0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B7D9C(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B7D9C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5B7B24((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B7E4C(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = v4 - 1;
    unsigned int v8 = (v4 - 1) & sub_1CC36B4D0(*(void **)a2, *(void *)a2 + 8 * *(void *)(a2 + 8));
    uint64_t v9 = (uint64_t *)(v6 + 8 * v8);
    if (sub_1CD5B7F3C(a2, *v9))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (*v9 != -4096)
      {
        if (v10) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = *v9 == -8192;
        }
        if (v13) {
          uint64_t v10 = v9;
        }
        int v14 = v11 + 1;
        unsigned int v8 = (v8 + v11) & v7;
        uint64_t v9 = (uint64_t *)(v6 + 8 * v8);
        BOOL v15 = sub_1CD5B7F3C(a2, *v9);
        uint64_t result = 1;
        int v11 = v14;
        if (v15) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v9 = v10;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v9;
  return result;
}

BOOL sub_1CD5B7F3C(uint64_t a1, uint64_t a2)
{
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(const void **)(a2 + 24);
  return v4 == (uint64_t)(*(void *)(a2 + 32) - (void)v5) >> 3 && memcmp(*(const void **)a1, v5, 8 * v4) == 0;
}

uint64_t sub_1CD5B7FA0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B8028((uint64_t *)a1, (uint64_t)a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B80F0(a1, (uint64_t)a2, (uint64_t)a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B8028(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int v7 = sub_1CC36B4D0(*(void **)(*(void *)a2 + 24), *(void *)(*(void *)a2 + 32));
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & v7;
    uint64_t v10 = (void *)(v6 + 8 * v9);
    uint64_t v11 = *v10;
    if (*(void *)a2 == *v10)
    {
      uint64_t result = 1;
    }
    else
    {
      int v12 = 0;
      int v13 = 1;
      uint64_t result = 1;
      while (v11 != -4096)
      {
        if (v12) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v11 == -8192;
        }
        if (v15) {
          int v12 = v10;
        }
        unsigned int v16 = v9 + v13++;
        unsigned int v9 = v16 & v8;
        uint64_t v10 = (void *)(v6 + 8 * (v16 & v8));
        uint64_t v11 = *v10;
        if (*(void *)a2 == *v10) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v12) {
        uint64_t v10 = v12;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v10;
  return result;
}

void *sub_1CD5B80F0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CC597E88(a1, v7);
  unsigned int v9 = 0;
  sub_1CD5B8028((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD5B81A4(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v9 = 0;
      uint64_t result = sub_1CD5B8028((uint64_t *)v5, (uint64_t)a2, &v9);
      *unsigned int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B8254(uint64_t *a1, uint64_t *a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    unsigned int v7 = a2 + 1;
    int v8 = sub_1CC598228(a2, a2 + 1);
    unsigned int v9 = 0;
    unsigned int v10 = (v4 - 1) & v8;
    for (int i = 1; ; ++i)
    {
      int v12 = (uint64_t *)(v6 + 8 * v10);
      uint64_t v13 = *v12;
      if (*v12 == -4096) {
        break;
      }
      if (v13 != -8192)
      {
        BOOL v15 = (void *)(v13 - 8 * *(unsigned int *)(v13 + 8));
        if (*a2 == *v15 && *v7 == v15[1])
        {
          uint64_t result = 1;
          goto LABEL_6;
        }
        if (v13 == -4096) {
          break;
        }
      }
      if (v9) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v13 == -8192;
      }
      if (v16) {
        unsigned int v9 = (uint64_t *)(v6 + 8 * v10);
      }
      unsigned int v17 = v10 + i;
      unsigned int v10 = v17 & (v4 - 1);
    }
    uint64_t result = 0;
    if (v9) {
      int v12 = v9;
    }
  }
  else
  {
    int v12 = 0;
    uint64_t result = 0;
  }
LABEL_6:
  *a3 = v12;
  return result;
}

uint64_t sub_1CD5B8340@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v10 = 0;
  uint64_t result = sub_1CD5B83C8((uint64_t *)a1, (uint64_t)a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B84B0(a1, (uint64_t)a2, (uint64_t)a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B83C8(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    long long v17 = *(_OWORD *)(*(void *)a2 - 8 * *(unsigned int *)(*(void *)a2 + 8));
    int v7 = sub_1CC598228((uint64_t *)&v17, (uint64_t *)&v17 + 1);
    int v8 = v4 - 1;
    unsigned int v9 = (v4 - 1) & v7;
    unsigned int v10 = (void *)(v6 + 8 * v9);
    uint64_t v11 = *v10;
    if (*(void *)a2 == *v10)
    {
      uint64_t result = 1;
    }
    else
    {
      int v12 = 0;
      int v13 = 1;
      uint64_t result = 1;
      while (v11 != -4096)
      {
        if (v12) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v11 == -8192;
        }
        if (v15) {
          int v12 = v10;
        }
        unsigned int v16 = v9 + v13++;
        unsigned int v9 = v16 & v8;
        unsigned int v10 = (void *)(v6 + 8 * (v16 & v8));
        uint64_t v11 = *v10;
        if (*(void *)a2 == *v10) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v12) {
        unsigned int v10 = v12;
      }
    }
  }
  else
  {
    unsigned int v10 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v10;
  return result;
}

void *sub_1CD5B84B0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B8564(a1, v7);
  unsigned int v9 = 0;
  sub_1CD5B83C8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B8564(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B8630(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B8630(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v9 = 0;
      uint64_t result = sub_1CD5B83C8((uint64_t *)v5, (uint64_t)a2, &v9);
      *unsigned int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B86E0(uint64_t *a1, uint64_t a2, unsigned int ***a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    unsigned int v9 = 0;
    int v10 = v4 - 1;
    unsigned int v11 = v10 & sub_1CD5B87CC((uint64_t *)a2, (uint64_t *)(a2 + 8), (int *)(a2 + 16), (uint64_t *)(a2 + 24), (uint64_t *)(a2 + 32), (int *)(a2 + 40), (uint64_t *)(a2 + 48));
    for (int i = 1; ; ++i)
    {
      uint64_t v5 = (unsigned int **)(v8 + 8 * v11);
      int v13 = *v5;
      if (((unint64_t)*v5 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        if (sub_1CD5B89EC(a2, v13))
        {
          uint64_t result = 1;
          goto LABEL_3;
        }
        int v13 = *v5;
      }
      if (v13 == (unsigned int *)-4096) {
        break;
      }
      if (v9) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v13 == (unsigned int *)-8192;
      }
      if (v14) {
        unsigned int v9 = (unsigned int **)(v8 + 8 * v11);
      }
      unsigned int v15 = v11 + i;
      unsigned int v11 = v15 & v10;
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v5 = v9;
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B87CC(uint64_t *a1, uint64_t *a2, int *a3, uint64_t *a4, uint64_t *a5, int *a6, uint64_t *a7)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  memset(v18, 0, sizeof(v18));
  uint64_t v14 = sub_1CBF65470();
  uint64_t v15 = *a1;
  uint64_t v19 = v14;
  uint64_t v17 = v15;
  return sub_1CD5B88B0((char *)&v17, 0, v18, (char *)&v18[3] + 8, a2, a3, a4, a5, a6, a7);
}

unint64_t sub_1CD5B88B0(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, int *a6, uint64_t *a7, uint64_t *a8, int *a9, uint64_t *a10)
{
  uint64_t v18 = a2;
  uint64_t v15 = sub_1CC2E96A4(a1, &v18, a3, (unint64_t)a4, *a5);
  uint64_t v19 = v18;
  unsigned int v16 = sub_1CC0AC9D0(a1, &v19, v15, (unint64_t)a4, *a6);
  return sub_1CD5B8958(a1, v19, v16, a4, a7, a8, a9, a10);
}

unint64_t sub_1CD5B8958(char *a1, uint64_t a2, void *a3, char *a4, uint64_t *a5, uint64_t *a6, int *a7, uint64_t *a8)
{
  uint64_t v16 = a2;
  int v13 = sub_1CC2E96A4(a1, &v16, a3, (unint64_t)a4, *a5);
  uint64_t v17 = v16;
  uint64_t v14 = sub_1CC2E96A4(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CC2E95DC(a1, v17, v14, a4, a7, a8);
}

BOOL sub_1CD5B89EC(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = &a2[-2 * a2[2]];
  return *(void *)a1 == *(void *)v2
      && *(void *)(a1 + 8) == *((void *)v2 + 1)
      && *(_DWORD *)(a1 + 16) == a2[6]
      && *(void *)(a1 + 24) == *((void *)v2 + 2)
      && *(void *)(a1 + 32) == *((void *)v2 + 3)
      && *(_DWORD *)(a1 + 40) == a2[7]
      && *(void *)(a1 + 48) == *((void *)v2 + 4);
}

uint64_t sub_1CD5B8A70@<X0>(uint64_t a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X8>)
{
  int v10 = 0;
  uint64_t result = sub_1CD5B8AF8((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B8C24(a1, (uint64_t)a2, a2, v10);
    int v7 = (unsigned int **)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B8AF8(uint64_t *a1, unsigned int **a2, unsigned int ***a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD5B8BBC(*a2);
    int v10 = v4 - 1;
    unsigned int v11 = v9 & (v4 - 1);
    uint64_t v5 = (unsigned int **)(v8 + 8 * v11);
    int v12 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      int v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != (unsigned int *)-4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == (unsigned int *)-8192;
        }
        if (v15) {
          int v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v5 = (unsigned int **)(v8 + 8 * (v16 & v10));
        int v12 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v5 = v13;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B8BBC(unsigned int *a1)
{
  uint64_t v1 = &a1[-2 * a1[2]];
  long long v2 = *((_OWORD *)v1 + 1);
  long long v5 = *(_OWORD *)v1;
  int v3 = a1[7];
  unsigned int v6 = a1[6];
  long long v7 = v2;
  int v8 = v3;
  uint64_t v9 = *((void *)v1 + 4);
  return sub_1CD5B87CC((uint64_t *)&v5, (uint64_t *)&v5 + 1, (int *)&v6, (uint64_t *)&v7, (uint64_t *)&v7 + 1, &v8, &v9);
}

unsigned int **sub_1CD5B8C24(uint64_t a1, uint64_t a2, unsigned int **a3, unsigned int **a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B8CD4(a1, v7);
  uint64_t v9 = 0;
  sub_1CD5B8AF8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != (unsigned int *)-4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B8CD4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(unsigned int ***)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B8DA0(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B8DA0(uint64_t result, unsigned int **a2, unsigned int **a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (((unint64_t)*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5B8AF8((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

BOOL sub_1CD5B8E50(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == *(unsigned __int16 *)(a2 + 2)
    && (long long v2 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8)), *(void *)(a1 + 8) == *v2)
    && *(void *)(a1 + 16) == v2[1]
    && *(void *)(a1 + 24) == v2[3]
    && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 24)
    && *(void *)(a1 + 40) == v2[2])
  {
    return *(void *)(a1 + 48) == v2[4];
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1CD5B8ED4(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CC598638((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B8F7C(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
    goto LABEL_3;
  }
  uint64_t v8 = *a1;
  uint64_t v9 = (_DWORD *)(a2 + 4);
  uint64_t v10 = (void *)(a2 + 8);
  uint64_t v11 = (void *)(a2 + 16);
  int v12 = sub_1CD5B90A0((int *)a2, (int *)(a2 + 4), (uint64_t *)(a2 + 8), (uint64_t *)(a2 + 16));
  int v13 = 0;
  unsigned int v14 = (v4 - 1) & v12;
  for (int i = 1; ; ++i)
  {
    uint64_t v5 = (uint64_t *)(v8 + 8 * v14);
    uint64_t v16 = *v5;
    if (*v5 == -8192) {
      goto LABEL_9;
    }
    if (v16 == -4096) {
      break;
    }
    if (*(_DWORD *)a2 == *(unsigned __int16 *)(v16 + 2) && *v9 == *(_DWORD *)(v16 + 24))
    {
      uint64_t v19 = (void *)(v16 - 8 * *(unsigned int *)(v16 + 8));
      if (*v10 == *v19 && *v11 == v19[1])
      {
        uint64_t result = 1;
        goto LABEL_3;
      }
    }
LABEL_9:
    if (v13) {
      BOOL v17 = 0;
    }
    else {
      BOOL v17 = v16 == -8192;
    }
    if (v17) {
      int v13 = (uint64_t *)(v8 + 8 * v14);
    }
    unsigned int v18 = v14 + i;
    unsigned int v14 = v18 & (v4 - 1);
  }
  uint64_t result = 0;
  if (v13) {
    uint64_t v5 = v13;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

unint64_t sub_1CD5B90A0(int *a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v12 = sub_1CBF65470();
  return sub_1CD5B915C((char *)v9, 0, v9, (char *)v10, a1, a2, a3, a4);
}

unint64_t sub_1CD5B915C(char *a1, uint64_t a2, _DWORD *a3, char *a4, int *a5, int *a6, uint64_t *a7, uint64_t *a8)
{
  uint64_t v16 = a2;
  uint64_t v13 = sub_1CC0AC9D0(a1, &v16, a3, (unint64_t)a4, *a5);
  uint64_t v17 = v16;
  unsigned int v14 = sub_1CC0AC9D0(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CC36B408(a1, v17, v14, a4, a7, a8);
}

uint64_t sub_1CD5B91F0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5B9278((uint64_t *)a1, a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B9374(a1, (uint64_t)a2, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B9278(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = *a2;
    int v10 = *(_DWORD *)(*a2 + 24);
    int v19 = *(unsigned __int16 *)(*a2 + 2);
    int v20 = v10;
    long long v21 = *(_OWORD *)(v9 - 8 * *(unsigned int *)(v9 + 8));
    int v11 = sub_1CD5B90A0(&v19, &v20, (uint64_t *)&v21, (uint64_t *)&v21 + 1);
    int v12 = v4 - 1;
    unsigned int v13 = (v4 - 1) & v11;
    uint64_t v5 = (void *)(v8 + 8 * v13);
    uint64_t v14 = *v5;
    if (*a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      BOOL v15 = 0;
      int v16 = 1;
      uint64_t result = 1;
      while (v14 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -8192;
        }
        if (v17) {
          BOOL v15 = v5;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v5 = (void *)(v8 + 8 * (v18 & v12));
        uint64_t v14 = *v5;
        if (*a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v15) {
        uint64_t v5 = v15;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

void *sub_1CD5B9374(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B9424(a1, v7);
  uint64_t v9 = 0;
  sub_1CD5B9278((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B9424(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B94F0(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B94F0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5B9278((uint64_t *)v5, a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD5B95A0(uint64_t *a1, const void **a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
    goto LABEL_3;
  }
  uint64_t v8 = *a1;
  uint64_t v9 = 0;
  int v10 = v4 - 1;
  unsigned int v11 = v10 & sub_1CD48BB60(*a2, (uint64_t)*a2 + 8 * (void)a2[1]);
  for (int i = 1; ; ++i)
  {
    uint64_t v5 = (uint64_t *)(v8 + 8 * v11);
    uint64_t v13 = *v5;
    if (*v5 == -8192) {
      goto LABEL_9;
    }
    if (v13 == -4096) {
      break;
    }
    uint64_t v14 = a2[1];
    if (v14 == (const void *)*(unsigned int *)(v13 + 32) && !memcmp(*a2, *(const void **)(v13 + 24), 8 * (void)v14))
    {
      uint64_t result = 1;
      goto LABEL_3;
    }
LABEL_9:
    if (v9) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v13 == -8192;
    }
    if (v15) {
      uint64_t v9 = (uint64_t *)(v8 + 8 * v11);
    }
    unsigned int v16 = v11 + i;
    unsigned int v11 = v16 & v10;
  }
  uint64_t result = 0;
  if (v9) {
    uint64_t v5 = v9;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

uint64_t sub_1CD5B9694@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int v10 = 0;
  uint64_t result = sub_1CD5B971C((uint64_t *)a1, (uint64_t)a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5B97EC(a1, (uint64_t)a2, (uint64_t)a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5B971C(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v8 = *a1;
    int v9 = sub_1CD48BB60(*(void **)(*(void *)a2 + 24), *(void *)(*(void *)a2 + 24) + 8 * *(unsigned int *)(*(void *)a2 + 32));
    int v10 = v4 - 1;
    unsigned int v11 = (v4 - 1) & v9;
    uint64_t v5 = (void *)(v8 + 8 * v11);
    uint64_t v12 = *v5;
    if (*(void *)a2 == *v5)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v12 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -8192;
        }
        if (v15) {
          uint64_t v13 = v5;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        uint64_t v5 = (void *)(v8 + 8 * (v16 & v10));
        uint64_t v12 = *v5;
        if (*(void *)a2 == *v5) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v5 = v13;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v5;
  return result;
}

void *sub_1CD5B97EC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5B989C(a1, v7);
  int v9 = 0;
  sub_1CD5B971C((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5B989C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5B9968(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5B9968(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v9 = 0;
      uint64_t result = sub_1CD5B971C((uint64_t *)v5, (uint64_t)a2, &v9);
      *int v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t llvm::DebugLoc::getFnDebugLoc@<X0>(llvm::DebugLoc *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *(void *)this;
  do
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(unsigned int *)(v3 + 8);
    if (v5 != 2) {
      break;
    }
    uint64_t v3 = *(void *)(v3 - 8);
  }
  while (v3);
  uint64_t result = (uint64_t)llvm::getDISubprogram(*(unsigned __int8 **)(v4 - 8 * v5));
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(result + 16);
    int v9 = (void *)(v8 & 0xFFFFFFFFFFFFFFF8);
    if ((v8 & 4) != 0) {
      int v9 = (void *)*v9;
    }
    uint64_t result = llvm::DILocation::getImpl(v9, *(_DWORD *)(v7 + 28), 0, v7, 0, 0, 0, 1);
    *a2 = result;
    if (result)
    {
      return llvm::MetadataTracking::track((uint64_t)a2, (unsigned __int8 *)result, 2);
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

BOOL llvm::DebugLoc::isImplicitCode(llvm::DebugLoc *this)
{
  return !*(void *)this || *(char *)(*(void *)this + 1) < 0;
}

void llvm::DebugLoc::replaceInlinedAtSubprogram(uint64_t *a1@<X0>, unsigned __int8 *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, unsigned __int8 **a5@<X8>)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  int v19 = v21;
  uint64_t v20 = 0x600000000;
  uint64_t v9 = *a1;
  if (!*a1)
  {
    unsigned int v10 = 0;
LABEL_9:
    uint64_t v11 = *((void *)v19 + v10 - 1);
    LODWORD(v2llvm::MDNode::dumpTree(this, 0) = v10 - 1;
    uint64_t v12 = llvm::DILocalScope::cloneScopeForSubprogram(*(llvm::DIScope **)(v11 - 8 * *(unsigned int *)(v11 + 8)), a2, (uint64_t)a3, a4);
    uint64_t Impl = (unsigned __int8 *)llvm::DILocation::getImpl(a3, *(_DWORD *)(v11 + 4), *(unsigned __int16 *)(v11 + 2), (uint64_t)v12, 0, 0, 0, 1);
    uint64_t v18 = v11;
    sub_1CC5958A8(a4, &v18)[1] = Impl;
    goto LABEL_10;
  }
  while (1)
  {
    uint64_t v17 = v9;
    uint64_t v18 = 0;
    if (sub_1CB883B0C(a4, &v17, &v18))
    {
      if (v18 != *(void *)a4 + 16 * *(unsigned int *)(a4 + 16)) {
        break;
      }
    }
    if (v20 >= (unint64_t)HIDWORD(v20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v19 + v2llvm::MDNode::dumpTree(this, 0) = v9;
    unsigned int v10 = v20 + 1;
    LODWORD(v2llvm::MDNode::dumpTree(this, 0) = v20 + 1;
    if (*(_DWORD *)(v9 + 8) == 2)
    {
      uint64_t v9 = *(void *)(v9 - 8);
      if (v9) {
        continue;
      }
    }
    goto LABEL_9;
  }
  uint64_t Impl = *(unsigned __int8 **)(v18 + 8);
  if (!Impl)
  {
    unsigned int v10 = v20;
    goto LABEL_9;
  }
LABEL_10:
  if (v20)
  {
    uint64_t v14 = 8 * v20;
    BOOL v15 = (char *)v19 - 8;
    do
    {
      uint64_t v16 = *(void *)&v15[v14];
      uint64_t Impl = (unsigned __int8 *)llvm::DILocation::getImpl(a3, *(_DWORD *)(v16 + 4), *(unsigned __int16 *)(v16 + 2), *(void *)(v16 - 8 * *(unsigned int *)(v16 + 8)), (uint64_t)Impl, 0, 0, 1);
      uint64_t v18 = v16;
      sub_1CC5958A8(a4, &v18)[1] = Impl;
      v14 -= 8;
    }
    while (v14);
  }
  *a5 = Impl;
  if (Impl) {
    llvm::MetadataTracking::track((uint64_t)a5, Impl, 2);
  }
  if (v19 != v21) {
    free(v19);
  }
}

uint64_t llvm::DebugLoc::dump(llvm::DebugLoc *this)
{
  long long v2 = llvm::dbgs(this);

  return llvm::DebugLoc::print((uint64_t)this, v2);
}

uint64_t llvm::DebugLoc::print(uint64_t this, llvm::raw_ostream *a2)
{
  if (*(void *)this)
  {
    uint64_t v3 = this;
    uint64_t v5 = sub_1CC3BE9E0(*(void *)(*(void *)this - 8 * *(unsigned int *)(*(void *)this + 8)));
    size_t v6 = v4;
    uint64_t v7 = (unsigned char *)*((void *)a2 + 4);
    if (v4 <= *((void *)a2 + 3) - (void)v7)
    {
      if (v4)
      {
        memcpy(v7, v5, v4);
        uint64_t v7 = (unsigned char *)(*((void *)a2 + 4) + v6);
        *((void *)a2 + 4) = v7;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, v5, v4);
      uint64_t v7 = (unsigned char *)*((void *)a2 + 4);
    }
    if ((unint64_t)v7 >= *((void *)a2 + 3))
    {
      uint64_t v8 = llvm::raw_ostream::write(a2, 58);
    }
    else
    {
      *((void *)a2 + 4) = v7 + 1;
      *uint64_t v7 = 58;
      uint64_t v8 = a2;
    }
    this = (uint64_t)llvm::raw_ostream::operator<<(v8, *(unsigned int *)(*(void *)v3 + 4));
    uint64_t v9 = *(void *)v3;
    if (*(_WORD *)(*(void *)v3 + 2))
    {
      unsigned int v10 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v10 >= *((void *)a2 + 3))
      {
        uint64_t v11 = llvm::raw_ostream::write(a2, 58);
      }
      else
      {
        *((void *)a2 + 4) = v10 + 1;
        unsigned char *v10 = 58;
        uint64_t v11 = a2;
      }
      this = (uint64_t)llvm::raw_ostream::operator<<(v11, *(unsigned __int16 *)(*(void *)v3 + 2));
      uint64_t v9 = *(void *)v3;
    }
    if (*(_DWORD *)(v9 + 8) == 2)
    {
      uint64_t v12 = *(unsigned __int8 **)(v9 - 8);
      uint64_t v13 = v12;
      if (v12)
      {
        this = llvm::MetadataTracking::track((uint64_t)&v13, v12, 2);
        if (v13)
        {
          sub_1CB8E509C(a2, " @[ ");
          llvm::DebugLoc::print((llvm::DebugLoc *)&v13, a2);
          this = (uint64_t)sub_1CB8E509C(a2, " ]");
          if (v13) {
            return llvm::MetadataTracking::untrack((uint64_t)&v13, v13);
          }
        }
      }
    }
  }
  return this;
}

void sub_1CD5B9ED8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26164A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD5B9EF8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26164A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5B9F4C(uint64_t a1)
{
}

uint64_t llvm::DiagnosticInfoInlineAsm::DiagnosticInfoInlineAsm(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(a1 + 12) = a4;
  *(void *)a1 = &unk_1F2616540;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a2;
  if (*(void *)(a2 + 48) || (*(unsigned char *)(a2 + 23) & 0x20) != 0)
  {
    Metadatauint64_t Impl = llvm::Instruction::getMetadataImpl((uint64_t ***)a2, "srcloc", 6uLL);
    if (MetadataImpl)
    {
      uint64_t v6 = *(unsigned int *)(MetadataImpl + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(MetadataImpl - 8 * v6);
        if (*(unsigned char *)v7 == 1)
        {
          uint64_t v8 = *(void *)(v7 + 128);
          if (*(unsigned char *)(v8 + 16) == 16)
          {
            uint64_t v9 = (void *)(v8 + 24);
            if (*(_DWORD *)(v8 + 32) >= 0x41u) {
              uint64_t v9 = (void *)*v9;
            }
            *(void *)(a1 + 16) = *v9;
          }
        }
      }
    }
  }
  return a1;
}

uint64_t llvm::DiagnosticInfoInlineAsm::print(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 128))(a2, *(void *)(a1 + 24));
  if (*(void *)(a1 + 16))
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, " at line ")+ 80);
    return v5();
  }
  return result;
}

uint64_t llvm::DiagnosticInfoResourceLimit::print(void *a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, a1[3]);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)v3 + 48))(v3, " (");
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 80))(v4, a1[4]);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)v5 + 48))(v5, ") exceeds limit (");
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 80))(v6, a1[5]);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)v7 + 48))(v7, ") in function '");
  uint64_t v9 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 136))(v8, a1[2])
                           + 16);

  return v9();
}

uint64_t llvm::DiagnosticInfoDebugMetadataVersion::print(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, "ignoring debug info with an invalid version (");
  uint64_t v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 104))(v3, *(unsigned int *)(a1 + 24));
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t, const char *))(*(void *)v4 + 48))(v4, ") in ")+ 144);

  return v5();
}

uint64_t llvm::DiagnosticInfoIgnoringInvalidDebugMetadata::print(uint64_t a1, uint64_t a2)
{
  long long v2 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, "ignoring invalid debug info in ")+ 56);

  return v2();
}

uint64_t llvm::DiagnosticInfoSampleProfile::print(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 24))
  {
    (*(void (**)(uint64_t, void))(*(void *)a2 + 40))(a2, *(void *)(a1 + 16));
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t v4 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, ":");
      (*(void (**)(uint64_t, void))(*(void *)v4 + 104))(v4, *(unsigned int *)(a1 + 32));
    }
    (*(void (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, ": ");
  }
  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128);

  return v6(a2, v5);
}

uint64_t llvm::DiagnosticInfoPGOProfile::print(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16))
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    (*(void (**)(uint64_t, const char *))(*(void *)v4 + 48))(v4, ": ");
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128);

  return v6(a2, v5);
}

uint64_t llvm::DiagnosticLocation::getRelativePath(llvm::DiagnosticLocation *this)
{
  uint64_t v1 = *(void *)(*(void *)this - 8 * *(unsigned int *)(*(void *)this + 8));
  if (v1) {
    return *(void *)(v1 + 8) + 24;
  }
  else {
    return 0;
  }
}

void llvm::DiagnosticLocation::getAbsolutePath(llvm::DiagnosticLocation *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)this - 8 * *(unsigned int *)(*(void *)this + 8));
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 8);
    uint64_t v8 = (void *)*v5;
    uint64_t v7 = v5 + 3;
    uint64_t v6 = v8;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  uint64_t v24[4] = 261;
  uint64_t v22 = v7;
  *(void *)&long long v23 = v6;
  if (llvm::sys::path::is_absolute((const char **)&v22, 0))
  {
    std::string::__init(a2, (const std::string::value_type *)v7, (std::string::size_type)v6);
  }
  else
  {
    uint64_t v22 = v24;
    long long v23 = xmmword_1CFAC3020;
    uint64_t v9 = *(void *)(*(void *)this - 8 * *(unsigned int *)(*(void *)this + 8) + 8);
    if (v9)
    {
      unsigned int v10 = *(void **)(v9 + 8);
      uint64_t v12 = *v10;
      uint64_t v11 = (const char *)(v10 + 3);
      uint64_t v9 = v12;
    }
    else
    {
      uint64_t v11 = 0;
    }
    __int16 v21 = 261;
    v20[0] = v11;
    v20[1] = (const char *)v9;
    __int16 v19 = 261;
    v18[0] = v7;
    v18[1] = v6;
    __int16 v17 = 257;
    v15[16] = 257;
    llvm::sys::path::append(&v22, v20, v18, (uint64_t)v16, (uint64_t)v15);
    uint64_t v13 = llvm::sys::path::remove_leading_dotslash((unsigned __int8 *)v22, v23, 0);
    if (v13)
    {
      std::string::__init(a2, (const std::string::value_type *)v13, v14);
    }
    else
    {
      a2->__r_.__value_.__r.__words[0] = 0;
      a2->__r_.__value_.__l.__size_ = 0;
      a2->__r_.__value_.__r.__words[2] = 0;
    }
    if (v22 != v24) {
      free(v22);
    }
  }
}

void llvm::DiagnosticInfoWithLocationBase::getAbsolutePath(llvm::DiagnosticInfoWithLocationBase *this@<X0>, std::string *a2@<X8>)
{
}

uint64_t llvm::DiagnosticInfoWithLocationBase::getLocation(uint64_t this, llvm::StringRef *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v4 = *(void *)(*(void *)(this + 24) - 8 * *(unsigned int *)(*(void *)(this + 24) + 8));
  if (v4)
  {
    uint64_t v5 = *(uint64_t **)(v4 + 8);
    uint64_t v7 = *v5;
    uint64_t v6 = v5 + 3;
    uint64_t v4 = v7;
  }
  else
  {
    uint64_t v6 = 0;
  }
  *(void *)a2 = v6;
  *((void *)a2 + 1) = v4;
  *a3 = *(_DWORD *)(this + 32);
  *a4 = *(_DWORD *)(this + 36);
  return this;
}

void llvm::DiagnosticInfoWithLocationBase::getLocationStr(llvm::DiagnosticInfoWithLocationBase *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *((void *)this + 3);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 - 8 * *(unsigned int *)(v3 + 8));
    if (v4)
    {
      uint64_t v5 = *(void **)(v4 + 8);
      uint64_t v7 = *v5;
      uint64_t v6 = (const char *)(v5 + 3);
      uint64_t v4 = v7;
    }
    else
    {
      uint64_t v6 = 0;
    }
    int v8 = *((_DWORD *)this + 8);
    int v9 = *((_DWORD *)this + 9);
  }
  else
  {
    int v8 = 0;
    int v9 = 0;
    uint64_t v4 = 9;
    uint64_t v6 = "<unknown>";
  }
  __int16 v17 = 773;
  v16[0] = (uint64_t)v6;
  v16[1] = v4;
  void v16[2] = (uint64_t)":";
  __int16 v15 = 264;
  LODWORD(v14[0]) = v8;
  sub_1CB8F1E58(v16, v14, (uint64_t)v18);
  uint64_t v12 = ":";
  __int16 v13 = 259;
  sub_1CB8F1E58(v18, (uint64_t *)&v12, (uint64_t)v19);
  __int16 v11 = 264;
  LODWORD(v10[0]) = v9;
  sub_1CB8F1E58(v19, v10, (uint64_t)v20);
  llvm::Twine::str((llvm::Twine *)v20, a2);
}

uint64_t llvm::DiagnosticInfoOptimizationBase::Argument::Argument(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, unsigned __int8 *a4)
{
  std::string::__init((std::string *)a1, a2, a3);
  *(_OWORD *)(a1 + 24) = 0u;
  uint64_t v6 = (void **)(a1 + 24);
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  if (!a4 || a4[16])
  {
    if (a4 && a4[16] >= 0x1Cu)
    {
      llvm::DiagnosticLocation::DiagnosticLocation(&v18, (const llvm::DebugLoc *)(a4 + 48));
      *(_OWORD *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = *(_OWORD *)&v18.__r_.__value_.__l.__data_;
    }
  }
  else
  {
    uint64_t Subprogram = llvm::Function::getSubprogram((llvm::Function *)a4);
    if (Subprogram)
    {
      uint64_t v8 = Subprogram;
      if (*(unsigned char *)Subprogram != 15) {
        uint64_t v8 = *(void *)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8));
      }
      unsigned int v9 = *(_DWORD *)(Subprogram + 28);
      *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = v8;
      *(void *)(a1 + 56) = v9;
    }
  }
  unsigned int v10 = a4[16];
  if (v10 < 4 || v10 == 21)
  {
    Name = llvm::Value::getName((llvm::Value *)a4);
    std::string::size_type v14 = Name;
    if (v13)
    {
      if (*Name == 1)
      {
        std::string::size_type v14 = Name + 1;
        std::string::size_type v15 = v13 - 1;
      }
      else
      {
        std::string::size_type v15 = v13;
      }
    }
    else
    {
      std::string::size_type v15 = 0;
    }
    std::string::__init(&v18, v14, v15);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)uint64_t v6 = *(_OWORD *)&v18.__r_.__value_.__l.__data_;
    *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = *((void *)&v18.__r_.__value_.__l + 2);
  }
  else if (v10 > 0x14)
  {
    if (a4 && v10 >= 0x1C)
    {
      OpcodeName = llvm::Instruction::getOpcodeName((llvm::Instruction *)(v10 - 28));
      MEMORY[0x1D25D9630](a1 + 24, OpcodeName);
    }
  }
  else
  {
    LODWORD(v18.__r_.__value_.__r.__words[1]) = 0;
    char v21 = 0;
    uint64_t v22 = 0;
    uint64_t v24 = a1 + 24;
    int v23 = 0;
    v18.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
    v18.__r_.__value_.__r.__words[2] = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    llvm::Value::printAsOperand((llvm::Value *)a4, (llvm::raw_ostream *)&v18, 0, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v18);
  }
  return a1;
}

uint64_t llvm::DiagnosticInfoOptimizationBase::Argument::Argument(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, llvm::Type *a4)
{
  std::string::__init((std::string *)a1, a2, a3);
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v15 = a1 + 24;
  int v14 = 0;
  uint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  llvm::Type::print(a4, (llvm::raw_ostream *)&v7, 0, 0);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  return a1;
}

void sub_1CD5BAB04(float *a1@<X0>, uint64_t a2@<X8>)
{
  v14[0] = 0;
  v14[1] = 0;
  uint64_t v15 = 0;
  int v6 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  uint64_t v13 = v14;
  int v12 = 0;
  uint64_t v5 = &unk_1F2646F30;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  double v3 = *a1;
  uint64_t v9 = 0;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v5, v3);
  if (*((char *)v13 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v13, (unint64_t)v13[1]);
  }
  else
  {
    long long v4 = *(_OWORD *)v13;
    *(void *)(a2 + 16) = v13[2];
    *(_OWORD *)a2 = v4;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v5);
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[0]);
  }
}

std::string *llvm::DiagnosticInfoOptimizationBase::Argument::Argument(std::string *a1, const std::string::value_type *a2, std::string::size_type a3, float a4)
{
  float v6 = a4;
  std::string::__init(a1, a2, a3);
  sub_1CD5BAB04(&v6, (uint64_t)&a1[1]);
  a1[2].__r_.__value_.__r.__words[0] = 0;
  a1[2].__r_.__value_.__l.__size_ = 0;
  return a1;
}

std::string *llvm::DiagnosticInfoOptimizationBase::Argument::Argument(std::string *a1, const std::string::value_type *a2, std::string::size_type a3, unint64_t a4)
{
  a1[2].__r_.__value_.__r.__words[0] = 0;
  a1[2].__r_.__value_.__l.__size_ = 0;
  return a1;
}

{
  char *v6;
  BOOL v7;
  char v9;
  uint64_t v10;

  char v10 = *MEMORY[0x1E4F143B8];
  std::string::__init(a1, a2, a3);
  if (a4)
  {
    float v6 = (char *)&v10;
    do
    {
      *--float v6 = (a4 % 0xA) | 0x30;
      uint64_t v7 = a4 > 9;
      a4 /= 0xAuLL;
    }
    while (v7);
  }
  else
  {
    float v6 = &v9;
    uint64_t v9 = 48;
  }
  sub_1CC028D80(a1[1].__r_.__value_.__r.__words, v6, (char *)&v10, (char *)&v10 - v6);
  a1[2].__r_.__value_.__r.__words[0] = 0;
  a1[2].__r_.__value_.__l.__size_ = 0;
  return a1;
}

{
  char *v6;
  BOOL v7;
  char v9;
  uint64_t v10;

  char v10 = *MEMORY[0x1E4F143B8];
  std::string::__init(a1, a2, a3);
  if (a4)
  {
    float v6 = (char *)&v10;
    do
    {
      *--float v6 = (a4 % 0xA) | 0x30;
      uint64_t v7 = a4 > 9;
      a4 /= 0xAuLL;
    }
    while (v7);
  }
  else
  {
    float v6 = &v9;
    uint64_t v9 = 48;
  }
  sub_1CC028D80(a1[1].__r_.__value_.__r.__words, v6, (char *)&v10, (char *)&v10 - v6);
  a1[2].__r_.__value_.__r.__words[0] = 0;
  a1[2].__r_.__value_.__l.__size_ = 0;
  return a1;
}

std::string *llvm::DiagnosticInfoOptimizationBase::Argument::Argument(std::string *a1, const std::string::value_type *a2, std::string::size_type a3, unsigned int a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  std::string::__init(a1, a2, a3);
  if (a4)
  {
    float v6 = (char *)&v11;
    unint64_t v7 = a4;
    do
    {
      *--float v6 = (v7 % 0xA) | 0x30;
      BOOL v8 = v7 > 9;
      v7 /= 0xAuLL;
    }
    while (v8);
  }
  else
  {
    float v6 = &v10;
    char v10 = 48;
  }
  sub_1CC028D80(a1[1].__r_.__value_.__r.__words, v6, (char *)&v11, (char *)&v11 - v6);
  a1[2].__r_.__value_.__r.__words[0] = 0;
  a1[2].__r_.__value_.__l.__size_ = 0;
  return a1;
}

uint64_t llvm::DiagnosticInfoOptimizationBase::Argument::Argument(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, unint64_t a4)
{
  std::string::__init((std::string *)a1, a2, a3);
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v15 = a1 + 24;
  int v14 = 0;
  unint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  if (HIDWORD(a4) == 1) {
    sub_1CB8E509C((llvm::raw_ostream *)&v7, "vscale x ");
  }
  sub_1CD098D14((llvm::raw_ostream *)&v7, a4, 0, 0, 0);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  return a1;
}

uint64_t llvm::DiagnosticInfoOptimizationBase::Argument::Argument(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, uint64_t a4, uint64_t a5)
{
  v16[0] = a4;
  v16[1] = a5;
  std::string::__init((std::string *)a1, a2, a3);
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  uint64_t v15 = a1 + 24;
  int v14 = 0;
  unint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  llvm::InstructionCost::print((llvm::InstructionCost *)v16, (llvm::raw_ostream *)&v7);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v7);
  return a1;
}

uint64_t llvm::DiagnosticInfoOptimizationBase::Argument::Argument(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, const llvm::DebugLoc *a4)
{
  std::string::__init((std::string *)a1, a2, a3);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  float v6 = (void **)(a1 + 24);
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0;
  llvm::DiagnosticLocation::DiagnosticLocation((void *)(a1 + 48), a4);
  if (*(void *)a4)
  {
    uint64_t v7 = llvm::DebugLoc::get(a4);
    int v8 = sub_1CC3BE9E0(*(void *)(v7 - 8 * *(unsigned int *)(v7 + 8)));
    __int16 v18 = 773;
    v17[0] = (uint64_t)v8;
    v17[1] = v9;
    void v17[2] = (uint64_t)":";
    __int16 v16 = 264;
    LODWORD(v15[0]) = llvm::DebugLoc::getLine(a4);
    sub_1CB8F1E58(v17, v15, (uint64_t)v19);
    uint64_t v13 = ":";
    __int16 v14 = 259;
    sub_1CB8F1E58(v19, (uint64_t *)&v13, (uint64_t)v20);
    __int16 v12 = 264;
    LODWORD(v11[0]) = llvm::DebugLoc::getCol(a4);
    sub_1CB8F1E58(v20, v11, (uint64_t)v21);
    llvm::Twine::str((llvm::Twine *)v21, &v22);
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*v6);
    }
    *(_OWORD *)float v6 = v22;
    *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = v23;
  }
  else
  {
    MEMORY[0x1D25D9630](a1 + 24, "<UNKNOWN LOCATION>");
  }
  return a1;
}

void llvm::DiagnosticInfoOptimizationBase::print(uint64_t a1, uint64_t a2)
{
  llvm::DiagnosticInfoWithLocationBase::getLocationStr((llvm::DiagnosticInfoWithLocationBase *)a1, v10);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, void **))(*(void *)a2 + 56))(a2, v10);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)v4 + 48))(v4, ": ");
  llvm::DiagnosticInfoOptimizationBase::getMsg((llvm::DiagnosticInfoOptimizationBase *)a1, (uint64_t)__p);
  (*(void (**)(uint64_t, void **))(*(void *)v5 + 56))(v5, __p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, " (hotness: ");
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 80))(v6, *(void *)(a1 + 64));
    (*(void (**)(uint64_t, const char *))(*(void *)v7 + 48))(v7, ")");
  }
}

void llvm::DiagnosticInfoOptimizationBase::getMsg(llvm::DiagnosticInfoOptimizationBase *this@<X0>, uint64_t a2@<X8>)
{
  v22[0] = 0;
  v22[1] = 0;
  uint64_t v23 = 0;
  int v14 = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  char v21 = v22;
  int v20 = 0;
  uint64_t v13 = &unk_1F2646F30;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v3 = *((int *)this + 89);
  if (v3 == -1) {
    uint64_t v3 = *((unsigned int *)this + 22);
  }
  if (v3)
  {
    uint64_t v4 = v3 << 6;
    uint64_t v5 = *((void *)this + 10) + 24;
    do
    {
      char v6 = *(unsigned char *)(v5 + 23);
      BOOL v7 = v6 < 0;
      if (v6 >= 0) {
        int v8 = (const char *)v5;
      }
      else {
        int v8 = *(const char **)v5;
      }
      size_t v9 = v6 & 0x7F;
      if (v7) {
        size_t v10 = *(void *)(v5 + 8);
      }
      else {
        size_t v10 = v9;
      }
      llvm::raw_ostream::write((llvm::raw_ostream *)&v13, v8, v10);
      v5 += 64;
      v4 -= 64;
    }
    while (v4);
    char v11 = v21;
  }
  else
  {
    char v11 = v22;
  }
  if (*((char *)v11 + 23) < 0)
  {
    sub_1CB8BDF7C(a2, *v11, (unint64_t)v11[1]);
  }
  else
  {
    long long v12 = *(_OWORD *)v11;
    *(void *)(a2 + 16) = v11[2];
    *(_OWORD *)a2 = v12;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v13);
  if (SHIBYTE(v23) < 0) {
    operator delete(v22[0]);
  }
}

uint64_t llvm::OptimizationRemark::OptimizationRemark(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::Function *a5)
{
  uint64_t Subprogram = llvm::Function::getSubprogram(a5);
  if (Subprogram)
  {
    uint64_t v11 = Subprogram;
    if (*(unsigned char *)Subprogram != 15) {
      uint64_t v11 = *(void *)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8));
    }
    int v12 = *(_DWORD *)(Subprogram + 28);
  }
  else
  {
    int v12 = 0;
    uint64_t v11 = 0;
  }
  if (*((llvm::Function **)a5 + 9) == (llvm::Function *)((char *)a5 + 72))
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v13 = *((void *)a5 + 10);
    if (v13) {
      uint64_t v14 = v13 - 24;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 9;
  *(unsigned char *)(a1 + 12) = 2;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = v11;
  *(_DWORD *)(a1 + 32) = v12;
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = a2;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = a3;
  *(void *)(a1 + 56) = a4;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = a1 + 96;
  *(void *)(a1 + 8sub_1CD521E44((uint64_t)this + 8) = 0x400000000;
  *(unsigned char *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 356) = -1;
  *(void *)(a1 + 36llvm::MDNode::dumpTree(this, 0) = v14;
  *(void *)a1 = &unk_1F2616570;
  return a1;
}

uint64_t llvm::OptimizationRemark::isEnabled(llvm::Function **this)
{
  Context = (llvm::LLVMContext *)llvm::Function::getContext(this[2]);
  uint64_t DiagHandlerPtr = llvm::LLVMContext::getDiagHandlerPtr(Context);
  uint64_t v4 = (const char *)this[5];
  if (v4) {
    size_t v5 = strlen(v4);
  }
  else {
    size_t v5 = 0;
  }
  char v6 = *(uint64_t (**)(uint64_t, const char *, size_t))(*(void *)DiagHandlerPtr + 40);

  return v6(DiagHandlerPtr, v4, v5);
}

uint64_t llvm::OptimizationRemarkMissed::OptimizationRemarkMissed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::Function *a5)
{
  uint64_t Subprogram = llvm::Function::getSubprogram(a5);
  if (Subprogram)
  {
    uint64_t v11 = Subprogram;
    if (*(unsigned char *)Subprogram != 15) {
      uint64_t v11 = *(void *)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8));
    }
    int v12 = *(_DWORD *)(Subprogram + 28);
  }
  else
  {
    int v12 = 0;
    uint64_t v11 = 0;
  }
  if (*((llvm::Function **)a5 + 9) == (llvm::Function *)((char *)a5 + 72))
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v13 = *((void *)a5 + 10);
    if (v13) {
      uint64_t v14 = v13 - 24;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 10;
  *(unsigned char *)(a1 + 12) = 2;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = v11;
  *(_DWORD *)(a1 + 32) = v12;
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = a2;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = a3;
  *(void *)(a1 + 56) = a4;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = a1 + 96;
  *(void *)(a1 + 8sub_1CD521E44((uint64_t)this + 8) = 0x400000000;
  *(unsigned char *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 356) = -1;
  *(void *)(a1 + 36llvm::MDNode::dumpTree(this, 0) = v14;
  *(void *)a1 = &unk_1F26165A8;
  return a1;
}

uint64_t llvm::OptimizationRemarkMissed::isEnabled(llvm::Function **this)
{
  Context = (llvm::LLVMContext *)llvm::Function::getContext(this[2]);
  uint64_t DiagHandlerPtr = llvm::LLVMContext::getDiagHandlerPtr(Context);
  uint64_t v4 = (const char *)this[5];
  if (v4) {
    size_t v5 = strlen(v4);
  }
  else {
    size_t v5 = 0;
  }
  char v6 = *(uint64_t (**)(uint64_t, const char *, size_t))(*(void *)DiagHandlerPtr + 32);

  return v6(DiagHandlerPtr, v4, v5);
}

uint64_t llvm::OptimizationRemarkAnalysis::OptimizationRemarkAnalysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::Function *a5)
{
  uint64_t Subprogram = llvm::Function::getSubprogram(a5);
  if (Subprogram)
  {
    uint64_t v11 = Subprogram;
    if (*(unsigned char *)Subprogram != 15) {
      uint64_t v11 = *(void *)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8));
    }
    int v12 = *(_DWORD *)(Subprogram + 28);
  }
  else
  {
    int v12 = 0;
    uint64_t v11 = 0;
  }
  if (*((llvm::Function **)a5 + 9) == (llvm::Function *)((char *)a5 + 72))
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v13 = *((void *)a5 + 10);
    if (v13) {
      uint64_t v14 = v13 - 24;
    }
    else {
      uint64_t v14 = 0;
    }
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 11;
  *(unsigned char *)(a1 + 12) = 2;
  *(void *)(a1 + 16) = a5;
  *(void *)(a1 + 24) = v11;
  *(_DWORD *)(a1 + 32) = v12;
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = a2;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = a3;
  *(void *)(a1 + 56) = a4;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = a1 + 96;
  *(void *)(a1 + 8sub_1CD521E44((uint64_t)this + 8) = 0x400000000;
  *(unsigned char *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 356) = -1;
  *(void *)(a1 + 36llvm::MDNode::dumpTree(this, 0) = v14;
  *(void *)a1 = &unk_1F26165E0;
  return a1;
}

BOOL llvm::OptimizationRemarkAnalysis::isEnabled(llvm::OptimizationRemarkAnalysis *this)
{
  Context = (llvm::LLVMContext *)llvm::Function::getContext(*((llvm::Function **)this + 2));
  uint64_t DiagHandlerPtr = llvm::LLVMContext::getDiagHandlerPtr(Context);
  uint64_t v4 = *((void *)this + 5);
  if (v4) {
    size_t v5 = strlen(*((const char **)this + 5));
  }
  else {
    size_t v5 = 0;
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t, size_t))(*(void *)DiagHandlerPtr + 24))(DiagHandlerPtr, v4, v5)) {
    return 1;
  }
  BOOL v7 = (const char *)*((void *)this + 5);

  return sub_1CD5BBA54(v7);
}

BOOL sub_1CD5BBA54(const char *a1)
{
  if (a1)
  {
    size_t v2 = strlen(a1);
    size_t v3 = v2;
    if (llvm::OptimizationRemarkAnalysis::AlwaysPrint)
    {
      if (v2 == strlen(llvm::OptimizationRemarkAnalysis::AlwaysPrint))
      {
        if (v3) {
          return memcmp(a1, llvm::OptimizationRemarkAnalysis::AlwaysPrint, v3) == 0;
        }
        return 1;
      }
    }
    else if (!v2)
    {
      return 1;
    }
    return 0;
  }
  if (!llvm::OptimizationRemarkAnalysis::AlwaysPrint) {
    return 1;
  }
  return *llvm::OptimizationRemarkAnalysis::AlwaysPrint == 0;
}

uint64_t llvm::DiagnosticInfoSrcMgr::print(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 152))(a2, *(void *)(a1 + 16));
}

BOOL llvm::DiagnosticInfoOptimizationFailure::isEnabled(llvm::DiagnosticInfoOptimizationFailure *this)
{
  return *((unsigned char *)this + 12) == 1;
}

uint64_t llvm::DiagnosticInfoISelFallback::print(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, "Instruction selection used fallback path for ")+ 136);

  return v2();
}

uint64_t llvm::DiagnosticInfoOptimizationBase::insert(uint64_t result)
{
  *(unsigned char *)(result + 352) = 1;
  return result;
}

{
  *(_DWORD *)(result + 356) = *(_DWORD *)(result + 88);
  return result;
}

void llvm::DiagnosticInfoMisExpect::print(llvm::DiagnosticInfoWithLocationBase *a1, uint64_t a2)
{
  llvm::DiagnosticInfoWithLocationBase::getLocationStr(a1, __p);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, void **))(*(void *)a2 + 56))(a2, __p);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)v4 + 48))(v4, ": ");
  (*(void (**)(uint64_t, void))(*(void *)v5 + 128))(v5, *((void *)a1 + 5));
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

uint64_t llvm::DiagnosticInfoDontCall::print(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, "call to ");
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v4 + 40))(v4, *(void *)(a1 + 16), *(void *)(a1 + 24));
  (*(void (**)(uint64_t, const char *))(*(void *)v5 + 48))(v5, " marked \"dontcall-");
  if (*(unsigned char *)(a1 + 12)) {
    char v6 = "warn\"";
  }
  else {
    char v6 = "error\"";
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, v6);
  if (*(void *)(a1 + 40))
  {
    int v8 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t, const char *))(*(void *)a2 + 48))(a2, ": ")+ 40);
    return v8();
  }
  return result;
}

void sub_1CD5BBF24()
{
}

void sub_1CD5BBF3C()
{
}

void sub_1CD5BBF54()
{
}

void sub_1CD5BBF6C()
{
}

void sub_1CD5BBF84()
{
}

void sub_1CD5BBF9C()
{
}

void sub_1CD5BBFCC(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5BC008(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5BC048(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5BC084(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5BC0C0()
{
}

void sub_1CD5BC0D8(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5BC114()
{
}

void sub_1CD5BC128()
{
}

void sub_1CD5BC140()
{
}

void sub_1CD5BC154()
{
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, char a2)
{
  size_t v3 = *(llvm::raw_ostream **)(a1 + 8);
  uint64_t v4 = (char *)*((void *)v3 + 4);
  if ((unint64_t)v4 >= *((void *)v3 + 3))
  {
    llvm::raw_ostream::write(v3, a2);
  }
  else
  {
    *((void *)v3 + 4) = v4 + 1;
    *uint64_t v4 = a2;
  }
  return a1;
}

{
  llvm::raw_ostream *v3;
  char *v4;

  size_t v3 = *(llvm::raw_ostream **)(a1 + 8);
  uint64_t v4 = (char *)*((void *)v3 + 4);
  if ((unint64_t)v4 >= *((void *)v3 + 3))
  {
    llvm::raw_ostream::write(v3, a2);
  }
  else
  {
    *((void *)v3 + 4) = v4 + 1;
    *uint64_t v4 = a2;
  }
  return a1;
}

{
  llvm::raw_ostream *v3;
  char *v4;

  size_t v3 = *(llvm::raw_ostream **)(a1 + 8);
  uint64_t v4 = (char *)*((void *)v3 + 4);
  if ((unint64_t)v4 >= *((void *)v3 + 3))
  {
    llvm::raw_ostream::write(v3, a2);
  }
  else
  {
    *((void *)v3 + 4) = v4 + 1;
    *uint64_t v4 = a2;
  }
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v5 = *(llvm::raw_ostream **)(a1 + 8);
  char v6 = (void *)*((void *)v5 + 4);
  if (a3 <= *((void *)v5 + 3) - (void)v6)
  {
    if (a3)
    {
      memcpy(v6, a2, a3);
      *((void *)v5 + 4) += a3;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, (const char *)a2, a3);
  }
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, char *a2)
{
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, uint64_t *a2)
{
  size_t v3 = *(llvm::raw_ostream **)(a1 + 8);
  char v4 = *((unsigned char *)a2 + 23);
  BOOL v5 = v4 < 0;
  size_t v6 = a2[1];
  if (v4 < 0) {
    a2 = (uint64_t *)*a2;
  }
  size_t v7 = v4 & 0x7F;
  if (v5) {
    size_t v8 = v6;
  }
  else {
    size_t v8 = v7;
  }
  llvm::raw_ostream::write(v3, (const char *)a2, v8);
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, unint64_t a2)
{
  return a1;
}

{
  llvm::raw_ostream::operator<<(*(llvm::raw_ostream **)(a1 + 8), a2);
  return a1;
}

{
  llvm::raw_ostream::operator<<(*(llvm::raw_ostream **)(a1 + 8), a2);
  return a1;
}

{
  llvm::raw_ostream::operator<<(*(llvm::raw_ostream **)(a1 + 8), a2);
  return a1;
}

{
  llvm::raw_ostream::operator<<(*(llvm::raw_ostream **)(a1 + 8), a2);
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, unsigned int a2)
{
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, int a2)
{
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, double a2)
{
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, llvm::Twine *this)
{
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, llvm::Value *this)
{
  size_t v3 = *(llvm::raw_ostream **)(a1 + 8);
  Name = llvm::Value::getName(this);
  size_t v6 = v4;
  size_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, uint64_t a2)
{
  size_t v3 = *(llvm::raw_ostream **)(a1 + 8);
  size_t v6 = *(const char **)(a2 + 168);
  uint64_t v4 = a2 + 168;
  BOOL v5 = v6;
  char v7 = *(unsigned char *)(v4 + 23);
  int v8 = v7;
  if (v7 >= 0) {
    BOOL v5 = (const char *)v4;
  }
  size_t v9 = v7 & 0x7F;
  if (v8 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *(void *)(v4 + 8);
  }
  llvm::raw_ostream::write(v3, v5, v10);
  return a1;
}

uint64_t llvm::DiagnosticPrinterRawOStream::operator<<(uint64_t a1, llvm::SMDiagnostic *this)
{
  return a1;
}

void sub_1CD5BC688()
{
}

void llvm::DominatorTreeBase<llvm::BasicBlock,false>::getDescendants(uint64_t a1, void *a2, uint64_t a3)
{
  v16[8] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a3 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v12 = 0;
  uint64_t v13 = a2;
  if (sub_1CB915048((uint64_t *)(a1 + 24), &v13, &v12))
  {
    uint64_t v5 = v12;
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(unsigned int *)(a1 + 40);
    uint64_t v5 = v6 + 16 * v7;
  }
  if (v5 != v6 + 16 * v7)
  {
    uint64_t v8 = *(void *)(v5 + 8);
    if (v8)
    {
      uint64_t v13 = v16;
      int v15 = 8;
      v16[0] = v8;
      unsigned int v9 = 1;
      do
      {
        uint64_t v10 = *((void *)v13 + v9 - 1);
        unsigned int v14 = v9 - 1;
        unint64_t v11 = *(unsigned int *)(a3 + 8);
        if (v11 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v11) = *(void *)v10;
        ++*(_DWORD *)(a3 + 8);
        sub_1CD5BC7E8((uint64_t)&v13, *(char **)(v10 + 24), (char *)(*(void *)(v10 + 24) + 8 * *(unsigned int *)(v10 + 32)));
        unsigned int v9 = v14;
      }
      while (v14);
      if (v13 != v16) {
        free(v13);
      }
    }
  }
}

uint64_t sub_1CD5BC7E8(uint64_t result, char *a2, char *a3)
{
  unint64_t v3 = a3 - a2;
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (v4 + ((a3 - a2) >> 3) > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    uint64_t v5 = (void *)(*(void *)result + 8 * v4);
    do
    {
      uint64_t v6 = *(void *)a2;
      a2 += 8;
      *v5++ = v6;
    }
    while (a2 != a3);
  }
  *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = v4 + (v3 >> 3);
  return result;
}

void llvm::DominatorTreeBase<llvm::BasicBlock,false>::setNewRoot(uint64_t a1)
{
  *(unsigned char *)(a1 + 64) = 0;
  llvm::DominatorTreeBase<llvm::BasicBlock,false>::createNode();
}

uint64_t llvm::DominatorTreeBase<llvm::BasicBlock,false>::eraseNode(int32x2_t *a1, uint64_t a2)
{
  uint64_t v14 = a2;
  uint64_t v15 = 0;
  unint64_t v3 = a1 + 3;
  uint64_t v16 = a2;
  if (sub_1CB915048((uint64_t *)&a1[3], &v16, &v15))
  {
    uint64_t v4 = v15;
    int32x2_t v5 = a1[3];
    uint64_t v6 = a1[5].u32[0];
  }
  else
  {
    int32x2_t v5 = a1[3];
    uint64_t v6 = a1[5].u32[0];
    uint64_t v4 = *(void *)&v5 + 16 * v6;
  }
  if (v4 == *(void *)&v5 + 16 * v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8);
  }
  a1[8].i8[0] = 0;
  uint64_t v8 = *(void *)(v7 + 8);
  if (v8)
  {
    unsigned int v9 = *(void **)(v8 + 24);
    uint64_t v10 = *(unsigned int *)(v8 + 32);
    unint64_t v11 = &v9[v10];
    if (v10)
    {
      uint64_t v12 = 8 * v10;
      while (*v9 != v7)
      {
        ++v9;
        v12 -= 8;
        if (!v12)
        {
          unsigned int v9 = v11;
          break;
        }
      }
    }
    if (v11 != v9 + 1)
    {
      memmove(v9, v9 + 1, (char *)v11 - (char *)(v9 + 1));
      LODWORD(v1llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(v8 + 32);
    }
    *(_DWORD *)(v8 + 32) = v10 - 1;
  }
  return sub_1CB931314(v3, &v14);
}

llvm::raw_ostream *llvm::DominatorTreeBase<llvm::BasicBlock,false>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "=============================--------------------------------\n");
  sub_1CB8E509C(a2, "Inorder Dominator Tree: ");
  if (!*(unsigned char *)(a1 + 64))
  {
    uint64_t v4 = sub_1CB8E509C(a2, "DFSNumbers invalid: ");
    sub_1CD098D14(v4, *(unsigned int *)(a1 + 68), 0, 0, 0);
    sub_1CB8E509C(v4, " slow queries.");
  }
  sub_1CB8E509C(a2, "\n");
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5) {
    sub_1CD4B6410(v5, a2, 1u);
  }
  sub_1CB8E509C(a2, "Roots: ");
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    uint64_t v7 = *(llvm::Value ***)a1;
    uint64_t v8 = 8 * v6;
    do
    {
      unsigned int v9 = *v7++;
      llvm::Value::printAsOperand(v9, a2, 0, 0);
      sub_1CB8E509C(a2, " ");
      v8 -= 8;
    }
    while (v8);
  }

  return sub_1CB8E509C(a2, "\n");
}

uint64_t llvm::DominatorTreeBase<llvm::BasicBlock,true>::eraseNode(int32x2_t *a1, uint64_t a2)
{
  uint64_t v21 = a2;
  uint64_t v22 = 0;
  unint64_t v3 = a1 + 6;
  uint64_t v23 = a2;
  if (sub_1CB915048((uint64_t *)&a1[6], &v23, &v22))
  {
    uint64_t v4 = v22;
    int32x2_t v5 = a1[6];
    uint64_t v6 = a1[8].u32[0];
  }
  else
  {
    int32x2_t v5 = a1[6];
    uint64_t v6 = a1[8].u32[0];
    uint64_t v4 = *(void *)&v5 + 16 * v6;
  }
  if (v4 == *(void *)&v5 + 16 * v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8);
  }
  a1[11].i8[0] = 0;
  uint64_t v8 = *(void *)(v7 + 8);
  if (v8)
  {
    unsigned int v9 = *(void **)(v8 + 24);
    uint64_t v10 = *(unsigned int *)(v8 + 32);
    unint64_t v11 = &v9[v10];
    if (v10)
    {
      uint64_t v12 = 8 * v10;
      while (*v9 != v7)
      {
        ++v9;
        v12 -= 8;
        if (!v12)
        {
          unsigned int v9 = v11;
          break;
        }
      }
    }
    if (v11 != v9 + 1)
    {
      memmove(v9, v9 + 1, (char *)v11 - (char *)(v9 + 1));
      LODWORD(v1llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(v8 + 32);
    }
    *(_DWORD *)(v8 + 32) = v10 - 1;
  }
  uint64_t result = sub_1CB931314(v3, &v21);
  uint64_t v14 = (void *)*a1;
  uint64_t v15 = a1[1].u32[0];
  uint64_t v16 = *(void *)a1 + 8 * v15;
  uint64_t v17 = (void *)*a1;
  if (v15)
  {
    uint64_t v18 = 8 * v15;
    uint64_t v17 = (void *)*a1;
    while (*v17 != v21)
    {
      ++v17;
      v18 -= 8;
      if (!v18)
      {
        uint64_t v17 = (void *)(*(void *)a1 + 8 * v15);
        break;
      }
    }
  }
  uint64_t v19 = v17 - v14;
  if (v19 != v15)
  {
    uint64_t v20 = v14[v19];
    v14[v19] = *(void *)(v16 - 8);
    *(void *)(v16 - sub_1CD521E44((uint64_t)this + 8) = v20;
    a1[1].i32[0] = v15 - 1;
  }
  return result;
}

llvm::raw_ostream *llvm::DominatorTreeBase<llvm::BasicBlock,true>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "=============================--------------------------------\n");
  sub_1CB8E509C(a2, "Inorder PostDominator Tree: ");
  if (!*(unsigned char *)(a1 + 88))
  {
    uint64_t v4 = sub_1CB8E509C(a2, "DFSNumbers invalid: ");
    sub_1CD098D14(v4, *(unsigned int *)(a1 + 92), 0, 0, 0);
    sub_1CB8E509C(v4, " slow queries.");
  }
  sub_1CB8E509C(a2, "\n");
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5) {
    sub_1CD4B6410(v5, a2, 1u);
  }
  sub_1CB8E509C(a2, "Roots: ");
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6)
  {
    uint64_t v7 = *(llvm::Value ***)a1;
    uint64_t v8 = 8 * v6;
    do
    {
      unsigned int v9 = *v7++;
      llvm::Value::printAsOperand(v9, a2, 0, 0);
      sub_1CB8E509C(a2, " ");
      v8 -= 8;
    }
    while (v8);
  }

  return sub_1CB8E509C(a2, "\n");
}

uint64_t llvm::cfg::Update<llvm::BasicBlock *>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  if ((*(void *)(a1 + 8) & 4) != 0) {
    uint64_t v4 = "Delete ";
  }
  else {
    uint64_t v4 = "Insert ";
  }
  sub_1CB8E509C(a2, v4);
  llvm::Value::printAsOperand(*(llvm::Value **)a1, a2, 0, 0);
  sub_1CB8E509C(a2, " -> ");
  uint64_t v5 = (llvm::Value *)(*(void *)(a1 + 8) & 0xFFFFFFFFFFFFFFF8);

  return llvm::Value::printAsOperand(v5, a2, 0, 0);
}

void llvm::cfg::Update<llvm::BasicBlock *>::dump(llvm *a1)
{
  llvm::dbgs(a1);

  llvm::cfg::Update<llvm::BasicBlock *>::print();
}

void sub_1CD5BCF10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = (uint64_t *)(a1 + 48);
  uint64_t v10 = 0;
  uint64_t v11 = a3;
  if (!sub_1CB915048((uint64_t *)(a1 + 48), &v11, &v10)
    || v10 == *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64)
    || (uint64_t v8 = *(uint64_t **)(v10 + 8)) == 0)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    sub_1CB915048(v7, &v11, &v10);
    llvm::DominatorTreeBase<llvm::BasicBlock,true>::createChild();
  }
  *(unsigned char *)(a1 + 8sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = 0;
  uint64_t v11 = a4;
  if (sub_1CB915048(v7, &v11, &v10)
    && v10 != *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64)
    && (uint64_t v9 = *(void *)(v10 + 8)) != 0)
  {
    sub_1CD5BDD34(a1, a2, v8, v9);
  }
  else
  {
    sub_1CD5BDC20(a1, a2, v8, a4);
  }
}

void *llvm::DominatorTreePrinterPass::DominatorTreePrinterPass(void *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

void llvm::DominatorTreePrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  unint64_t v3 = sub_1CB8E509C(*a1, "DominatorTree for function: ");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  uint64_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void llvm::DominatorTreeVerifierPass::run()
{
}

llvm::DominatorTreeWrapperPass *llvm::DominatorTreeWrapperPass::DominatorTreeWrapperPass(llvm::DominatorTreeWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::DominatorTreeWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2616A80;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0x100000000;
  *((_DWORD *)this + 25) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 1llvm::MDNode::dumpTree(this, 0) = 0;
  *((void *)this + 11) = 0;
  *((unsigned char *)this + 96) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD8800, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC5A8478;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCD8800, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::DominatorTreeWrapperPass::print(llvm::DominatorTreeWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

void sub_1CD5BD2EC(uint64_t *a1)
{
  sub_1CC5A857C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5BD324(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 16llvm::MDNode::dumpTree(this, 0) = 1;
}

void llvm::callDefaultCtor<llvm::DominatorTreeWrapperPass>()
{
}

uint64_t sub_1CD5BD36C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CD5BD3C8(a1, (_DWORD *)a2);
    sub_1CD5BD3C8(a1 + 296, (_DWORD *)(a2 + 296));
  }
  *(unsigned char *)(a1 + 592) = *(unsigned char *)(a2 + 592);
  sub_1CD41F46C(a1 + 600, a2 + 600);
  return a1;
}

uint64_t sub_1CD5BD3C8(uint64_t a1, _DWORD *a2)
{
  sub_1CBFEED08(a1);
  int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
    int v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 | 1;
  if ((*(unsigned char *)a2 & 1) == 0 && a2[4] >= 5u)
  {
    *(_DWORD *)a1 = v4 & 0xFFFFFFFE;
    if (*a2) {
      uint64_t v5 = 4;
    }
    else {
      uint64_t v5 = a2[4];
    }
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(8 * (v5 + 8 * v5), (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v5;
  }

  return sub_1CD5BD474(a1, a2);
}

uint64_t sub_1CD5BD474(uint64_t result, _DWORD *a2)
{
  unint64_t v3 = (unsigned int *)result;
  unint64_t v4 = 0;
  unsigned int v5 = *a2 & 0xFFFFFFFE | *(_DWORD *)result & 1;
  *(_DWORD *)uint64_t result = v5;
  *(_DWORD *)(result + 4) = a2[1];
  size_t v6 = (void *)(result + 8);
  uint64_t v7 = a2 + 2;
  while ((v5 & 1) == 0)
  {
    if (v4 >= v3[4]) {
      return result;
    }
    uint64_t v8 = (void *)*v6;
LABEL_6:
    uint64_t v9 = v7;
    if ((*(unsigned char *)a2 & 1) == 0) {
      uint64_t v9 = (void *)*v7;
    }
    v8[9 * v4] = v9[9 * v4];
    unsigned int v5 = *v3;
    if (*v3)
    {
      uint64_t v11 = v6[9 * v4] | 0x1000;
      uint64_t v10 = v6;
    }
    else
    {
      uint64_t v10 = (void *)*v6;
      uint64_t v11 = *(void *)(*v6 + 72 * v4) | 0x1000;
    }
    if (v11 != -4096)
    {
      uint64_t v12 = v7;
      if ((*(unsigned char *)a2 & 1) == 0) {
        uint64_t v12 = (void *)*v7;
      }
      char v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = (uint64_t)&v10[9 * v4 + 1];
      uint64_t v16 = (uint64_t)&v12[9 * v4 + 1];
      do
      {
        char v17 = v13;
        uint64_t result = v15 + 32 * v14;
        uint64_t v18 = v16 + 32 * v14;
        *(void *)uint64_t result = result + 16;
        *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0x200000000;
        if (*(_DWORD *)(v18 + 8)) {
          uint64_t result = sub_1CBB08064(result, v18);
        }
        char v13 = 1;
        uint64_t v14 = 1;
      }
      while ((v17 & 1) == 0);
      unsigned int v5 = *v3;
    }
    ++v4;
  }
  uint64_t v8 = v6;
  if (v4 < 4) {
    goto LABEL_6;
  }
  return result;
}

uint64_t sub_1CD5BD5D0(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CD5BD62C(a1, (_DWORD *)a2);
    sub_1CD5BD62C(a1 + 296, (_DWORD *)(a2 + 296));
  }
  *(unsigned char *)(a1 + 592) = *(unsigned char *)(a2 + 592);
  sub_1CD41F46C(a1 + 600, a2 + 600);
  return a1;
}

uint64_t sub_1CD5BD62C(uint64_t a1, _DWORD *a2)
{
  sub_1CBFEF690(a1);
  int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
    int v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 | 1;
  if ((*(unsigned char *)a2 & 1) == 0 && a2[4] >= 5u)
  {
    *(_DWORD *)a1 = v4 & 0xFFFFFFFE;
    if (*a2) {
      uint64_t v5 = 4;
    }
    else {
      uint64_t v5 = a2[4];
    }
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(8 * (v5 + 8 * v5), (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v5;
  }

  return sub_1CD5BD474(a1, a2);
}

uint64_t sub_1CD5BD6D8(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  size_t v6 = (uint64_t *)result;
  while (2)
  {
    uint64_t v7 = a2 - 1;
LABEL_3:
    uint64_t v8 = 1 - a4;
    while (1)
    {
      uint64_t v9 = (char *)a2 - (char *)v6;
      unint64_t v10 = a2 - v6;
      if (v10 == 2)
      {
        uint64_t result = sub_1CD5BDAA4(a3, *v7, *v6);
        if (result)
        {
          uint64_t v11 = *v6;
          *size_t v6 = *v7;
          *uint64_t v7 = v11;
        }
        return result;
      }
      if (v10 <= 2)
      {
        switch(v10)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            break;
          case 3uLL:
            return sub_1CC5AD2B0(v6, v6 + 1, v7, a3);
          case 4uLL:
            return sub_1CC5AD790(v6, v6 + 1, v6 + 2, v7, a3);
          case 5uLL:
            return sub_1CC5AD848(v6, v6 + 1, v6 + 2, v6 + 3, v7, a3);
          default:
            JUMPOUT(0);
        }
      }
      uint64_t v12 = a5;
      uint64_t v20 = a2;
      uint64_t v21 = a3;
      if (v9 <= 191)
      {
        if (a5)
        {
          return (uint64_t)sub_1CC5AD14C(v6, a2, a3);
        }
        else
        {
          return (uint64_t)sub_1CC5AD214(v6, a2, a3);
        }
      }
      if (v8 == 1)
      {
        if (v6 != a2)
        {
          return (uint64_t)sub_1CC5AD928(v6, a2, a2, a3);
        }
        return result;
      }
      unint64_t v13 = v10 >> 1;
      uint64_t v14 = &v6[v10 >> 1];
      if ((unint64_t)v9 < 0x401)
      {
        sub_1CC5AD2B0(&v6[v10 >> 1], v6, v7, a3);
      }
      else
      {
        sub_1CC5AD2B0(v6, v14, v7, a3);
        sub_1CC5AD2B0(v6 + 1, v14 - 1, v20 - 2, v21);
        sub_1CC5AD2B0(v6 + 2, &v6[v13 + 1], v20 - 3, v21);
        sub_1CC5AD2B0(v14 - 1, v14, &v6[v13 + 1], v21);
        uint64_t v15 = *v6;
        *size_t v6 = *v14;
        *uint64_t v14 = v15;
      }
      if ((v12 & 1) == 0 && !sub_1CD5BDAA4(v21, *(v6 - 1), *v6))
      {
        uint64_t result = (uint64_t)sub_1CC5AD398(v6, v20, v21);
        uint64_t v19 = (uint64_t *)result;
        goto LABEL_39;
      }
      uint64_t v16 = sub_1CC5AD4A8(v6, v20, v21);
      if ((v17 & 1) == 0) {
        goto LABEL_42;
      }
      BOOL v18 = sub_1CC5AD5C4(v6, v16, v21);
      uint64_t v19 = v16 + 1;
      uint64_t result = sub_1CC5AD5C4(v16 + 1, v20, v21);
      if (result) {
        break;
      }
      if (!v18)
      {
LABEL_42:
        uint64_t result = sub_1CD5BD6D8(v6, v16, v21, -v8, v12 & 1);
        a4 = -v8;
        a3 = v21;
        a5 = 0;
        size_t v6 = v16 + 1;
        a2 = v20;
        goto LABEL_3;
      }
LABEL_39:
      ++v8;
      size_t v6 = v19;
      a2 = v20;
      a3 = v21;
      a5 = v12;
    }
    a4 = -v8;
    a2 = v16;
    a3 = v21;
    a5 = v12;
    if (!v18) {
      continue;
    }
    return result;
  }
}

BOOL sub_1CD5BDAA4(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  uint64_t v11 = 0;
  uint64_t v12 = a2;
  if (sub_1CBFA3AF4((uint64_t *)v5, &v12, &v11)) {
    uint64_t v6 = v11;
  }
  else {
    uint64_t v6 = *(void *)v5 + 16 * *(unsigned int *)(v5 + 16);
  }
  unsigned int v7 = *(_DWORD *)(v6 + 8);
  uint64_t v8 = *a1;
  uint64_t v11 = 0;
  uint64_t v12 = a3;
  if (sub_1CBFA3AF4((uint64_t *)v8, &v12, &v11)) {
    uint64_t v9 = v11;
  }
  else {
    uint64_t v9 = *(void *)v8 + 16 * *(unsigned int *)(v8 + 16);
  }
  return v7 < *(_DWORD *)(v9 + 8);
}

uint64_t sub_1CD5BDB48(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  uint64_t v6 = (uint64_t *)(*a1 + 24);
  uint64_t v15 = 0;
  uint64_t v16 = a3;
  if (sub_1CB915048(v6, &v16, &v15))
  {
    uint64_t v7 = v15;
    uint64_t v8 = *(void *)(v5 + 24);
    uint64_t v9 = *(unsigned int *)(v5 + 40);
  }
  else
  {
    uint64_t v8 = *(void *)(v5 + 24);
    uint64_t v9 = *(unsigned int *)(v5 + 40);
    uint64_t v7 = v8 + 16 * v9;
  }
  if (v7 == v8 + 16 * v9) {
    return 1;
  }
  uint64_t v10 = *(void *)(v7 + 8);
  if (!v10) {
    return 1;
  }
  uint64_t v11 = a1[1];
  unsigned int v12 = *(_DWORD *)(v11 + 8);
  if (v12 >= *(_DWORD *)(v11 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t result = 0;
  uint64_t v14 = (void *)(*(void *)v11 + 16 * v12);
  *uint64_t v14 = a2;
  v14[1] = v10;
  ++*(_DWORD *)(v11 + 8);
  return result;
}

void sub_1CD5BDC20(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v15[16] = *MEMORY[0x1E4F143B8];
  unint64_t v13 = v15;
  uint64_t v14 = 0x800000000;
  sub_1CD5BE0D0(a1, a2, a4, a3, (uint64_t)&v13);
  uint64_t v6 = (uint64_t *)v13;
  if (v14)
  {
    uint64_t v7 = (char *)v13 + 16 * v14;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v11 = 0;
      uint64_t v12 = v8;
      int v9 = sub_1CB915048((uint64_t *)(a1 + 48), &v12, &v11);
      uint64_t v10 = 0;
      if (v9 && v11 != *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64)) {
        uint64_t v10 = *(void **)(v11 + 8);
      }
      sub_1CD5BDD34(a1, a2, v10, v6[1]);
      v6 += 2;
    }
    while (v6 != (uint64_t *)v7);
    uint64_t v6 = (uint64_t *)v13;
  }
  if (v6 != v15) {
    free(v6);
  }
}

uint64_t sub_1CD5BDD34(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v6 = a2;
  v44[8] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a4;
  uint64_t result = sub_1CD5BE244(a1, a2, a4);
  if ((result & 1) == 0)
  {
    if (*a3 && *(void *)a4) {
      llvm::DominatorTreeBase<llvm::BasicBlock,true>::findNearestCommonDominator();
    }
    uint64_t v33 = 0;
    uint64_t v30 = 0;
    uint64_t result = sub_1CB915048((uint64_t *)(a1 + 48), &v33, &v30);
    uint64_t v9 = 0;
    if (result && v30 != (void *)(*(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64))) {
      uint64_t v9 = *((void *)v30 + 1);
    }
    unsigned int v10 = *(_DWORD *)(v9 + 16) + 1;
    if (v10 < *(_DWORD *)(a4 + 16))
    {
      uint64_t v33 = &v35;
      uint64_t v34 = 0x800000000;
      uint64_t v36 = 1;
      int64x2_t v37 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      int64x2_t v38 = v37;
      int64x2_t v39 = v37;
      int64x2_t v40 = v37;
      uint64_t v41 = v43;
      uint64_t v42 = 0x800000000;
      v43[8] = v44;
      v43[9] = 0x800000000;
      uint64_t v30 = v32;
      uint64_t v31 = 0x800000000;
      sub_1CD5BE2C0((uint64_t)&v33, a4);
      sub_1CC5AE840((uint64_t)&v27, (uint64_t)&v36, &v23);
      for (uint64_t i = v34; v34; uint64_t i = v34)
      {
        uint64_t v12 = *v33;
        sub_1CC5AF144(v33, (uint64_t)&v33[i], i);
        LODWORD(v34) = v34 - 1;
        if (v42 >= (unint64_t)HIDWORD(v42)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v41[v42] = v12;
        LODWORD(v42) = v42 + 1;
        unsigned int v13 = *(_DWORD *)(v12 + 16);
        while (1)
        {
          uint64_t v14 = *(void *)v12;
          if (v6) {
            sub_1CC5ACE40(*(void *)(v6 + 8), v14, (char **)&v27);
          }
          else {
            sub_1CC5AD04C((char **)&v27, *(void *)(v14 + 8));
          }
          uint64_t v15 = (uint64_t *)v27;
          if (v28)
          {
            uint64_t v16 = v6;
            uint64_t v17 = 8 * v28;
            do
            {
              uint64_t v18 = *v15;
              uint64_t v24 = 0;
              v25[0] = v18;
              int v19 = sub_1CB915048((uint64_t *)(a1 + 48), v25, &v24);
              uint64_t v20 = v24;
              if (!v19) {
                uint64_t v20 = *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64);
              }
              uint64_t v21 = *(void *)(v20 + 8);
              uint64_t v24 = v21;
              unsigned int v22 = *(_DWORD *)(v21 + 16);
              if (v22 > v10)
              {
                sub_1CC5AE840((uint64_t)v25, (uint64_t)&v36, &v24);
                if (v26)
                {
                  if (v22 <= v13)
                  {
                    sub_1CD5BE2C0((uint64_t)&v33, v21);
                  }
                  else
                  {
                    if (v31 >= (unint64_t)HIDWORD(v31)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v30 + v31) = v21;
                    LODWORD(v31) = v31 + 1;
                  }
                }
              }
              ++v15;
              v17 -= 8;
            }
            while (v17);
            uint64_t v15 = (uint64_t *)v27;
            uint64_t v6 = v16;
          }
          if (v15 != &v29) {
            free(v15);
          }
          if (!v31) {
            break;
          }
          uint64_t v12 = *((void *)v30 + v31 - 1);
          LODWORD(v31) = v31 - 1;
        }
      }
      if (v42) {
        llvm::DomTreeNodeBase<llvm::BasicBlock>::setIDom();
      }
      sub_1CC5AF23C(a1, v6);
      if (v30 != v32) {
        free(v30);
      }
      return sub_1CD5BE338((uint64_t)&v33);
    }
  }
  return result;
}

uint64_t sub_1CD5BE0D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  unsigned int v10 = operator new(8uLL);
  v12[0] = (uint64_t)v10;
  void *v10 = 0;
  v12[1] = (uint64_t)(v10 + 1);
  void v12[2] = (uint64_t)(v10 + 1);
  v12[3] = 0;
  uint64_t v12[4] = 0;
  int v13 = 0;
  uint64_t v14 = a2;
  sub_1CC5AEB70((uint64_t)v12, a3, a1, a5);
  sub_1CC5AA8DC(v12, a1, 0);
  sub_1CC5AB454((uint64_t)v12, a1, *a4);
  return sub_1CC3457E4((uint64_t)v12);
}

uint64_t sub_1CD5BE174(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  uint64_t v6 = (uint64_t *)(*a1 + 48);
  uint64_t v15 = 0;
  uint64_t v16 = a3;
  if (sub_1CB915048(v6, &v16, &v15))
  {
    uint64_t v7 = v15;
    uint64_t v8 = *(void *)(v5 + 48);
    uint64_t v9 = *(unsigned int *)(v5 + 64);
  }
  else
  {
    uint64_t v8 = *(void *)(v5 + 48);
    uint64_t v9 = *(unsigned int *)(v5 + 64);
    uint64_t v7 = v8 + 16 * v9;
  }
  if (v7 == v8 + 16 * v9) {
    return 1;
  }
  uint64_t v10 = *(void *)(v7 + 8);
  if (!v10) {
    return 1;
  }
  uint64_t v11 = a1[1];
  unsigned int v12 = *(_DWORD *)(v11 + 8);
  if (v12 >= *(_DWORD *)(v11 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t result = 0;
  uint64_t v14 = (void *)(*(void *)v11 + 16 * v12);
  *uint64_t v14 = a2;
  v14[1] = v10;
  ++*(_DWORD *)(v11 + 8);
  return result;
}

uint64_t sub_1CD5BE244(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (**(void **)(a3 + 8)) {
    return 0;
  }
  int v4 = *(void **)a1;
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    uint64_t v7 = *(void **)a1;
    while (*v7 != *(void *)a3)
    {
      ++v7;
      v6 -= 8;
      if (!v6)
      {
        uint64_t v7 = &v4[v5];
        break;
      }
    }
  }
  else
  {
    uint64_t v7 = *(void **)a1;
  }
  if (v5 == v7 - v4) {
    return 0;
  }
  sub_1CC5A46F8(a1, a2);
  return 1;
}

uint64_t sub_1CD5BE2C0(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v3) = a2;
  unsigned int v4 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4;
  uint64_t v5 = *(void *)a1;
  uint64_t v6 = *(void *)a1 + 8 * v4;

  return sub_1CC5AF0DC(v5, v6);
}

uint64_t sub_1CD5BE338(uint64_t a1)
{
  size_t v2 = *(void **)(a1 + 240);
  if (v2 != (void *)(a1 + 256)) {
    free(v2);
  }
  unsigned int v3 = *(void **)(a1 + 160);
  if (v3 != (void *)(a1 + 176)) {
    free(v3);
  }
  if ((*(unsigned char *)(a1 + 88) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 96), 8);
  }
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CD5BE3AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[8] = *MEMORY[0x1E4F143B8];
  if (a2) {
    sub_1CC5AC514((uint64_t)&v10, *(void *)(a2 + 8), a3);
  }
  else {
    sub_1CC5AC9A8((uint64_t)&v10, a3);
  }
  unsigned int v4 = (uint64_t *)v10;
  if (v11)
  {
    uint64_t v5 = 8 * v11;
    do
    {
      uint64_t v6 = *v4;
      uint64_t v8 = 0;
      uint64_t v9 = v6;
      if (sub_1CB915048((uint64_t *)(a1 + 48), &v9, &v8)
        && v8 != *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64)
        && *(void *)(v8 + 8))
      {
        llvm::DominatorTreeBase<llvm::BasicBlock,true>::findNearestCommonDominator();
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
    unsigned int v4 = (uint64_t *)v10;
  }
  if (v4 != v12) {
    free(v4);
  }
  return 0;
}

uint64_t sub_1CD5BE4EC(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (v6 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v6) = *a3;
  ++*(_DWORD *)(a1 + 8);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v7 = sub_1CB915048((uint64_t *)(a1 + 48), &v11, &v10);
  uint64_t v8 = 0;
  if (v7 && v10 != *(void *)(a1 + 48) + 16 * *(unsigned int *)(a1 + 64)) {
    uint64_t v8 = *(void **)(v10 + 8);
  }
  return sub_1CD5BDD34(a1, a2, v8, (uint64_t)a3);
}

uint64_t llvm::convertStrToRoundingMode(uint64_t *a1, uint64_t a2)
{
  uint64_t result = 0;
  switch(a2)
  {
    case 12:
      uint64_t v4 = *a1;
      int v5 = *((_DWORD *)a1 + 2);
      if (v4 != 0x70752E646E756F72 || v5 != 1685217655) {
        return 0;
      }
      int v7 = 2;
      return v7 | 0x100u;
    case 13:
      uint64_t v8 = *a1;
      uint64_t v9 = *(uint64_t *)((char *)a1 + 5);
      if (v8 != 0x79642E646E756F72 || v9 != 0x63696D616E79642ELL) {
        return 0;
      }
      int v7 = 7;
      return v7 | 0x100u;
    case 14:
      uint64_t v11 = *a1;
      uint64_t v12 = *(uint64_t *)((char *)a1 + 6);
      if (v11 != 0x6F642E646E756F72 || v12 != 0x647261776E776F64) {
        return 0;
      }
      int v7 = 3;
      return v7 | 0x100u;
    case 15:
      uint64_t v14 = *a1;
      uint64_t v15 = *(uint64_t *)((char *)a1 + 7);
      if (v14 != 0x6F742E646E756F72 || v15 != 0x7473657261656E6FLL) {
        return 0;
      }
      int v7 = 1;
      return v7 | 0x100u;
    case 16:
      uint64_t result = 0;
      uint64_t v18 = *a1;
      uint64_t v17 = a1[1];
      if (v18 != 0x6F742E646E756F72 || v17 != 0x6F72657A64726177) {
        return result;
      }
      int v7 = 0;
      return v7 | 0x100u;
    case 19:
      uint64_t v20 = *a1;
      uint64_t v21 = a1[1];
      uint64_t v22 = *(uint64_t *)((char *)a1 + 11);
      if (v20 != 0x6F742E646E756F72 || v21 != 0x617473657261656ELL || v22 != 0x7961776174736572) {
        return 0;
      }
      int v7 = 4;
      return v7 | 0x100u;
    default:
      return result;
  }
}

uint64_t llvm::convertRoundingModeToStr@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  *(unsigned char *)(a2 + 16) = 0;
  if result <= 7 && ((0x9Fu >> result))
  {
    uint64_t v2 = qword_1CFAC8778[(int)result];
    *(void *)a2 = off_1E6830B00[(int)result];
    *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v2;
    *(unsigned char *)(a2 + 16) = 1;
  }
  return result;
}

uint64_t llvm::convertStrToExceptionBehavior(void *a1, uint64_t a2)
{
  if (a2 == 16)
  {
    if (*a1 != 0x7470656378657066 || a1[1] != 0x7061727479616D2ELL) {
      return 0;
    }
    int v4 = 1;
  }
  else
  {
    if (a2 != 15) {
      return 0;
    }
    if (*a1 == 0x7470656378657066 && *(void *)((char *)a1 + 7) == 0x65726F6E67692E74)
    {
      int v4 = 0;
    }
    else
    {
      if (*a1 != 0x7470656378657066 || *(void *)((char *)a1 + 7) != 0x7463697274732E74) {
        return 0;
      }
      int v4 = 2;
    }
  }
  return v4 | 0x100u;
}

uint64_t llvm::convertExceptionBehaviorToStr@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  *(unsigned char *)(a2 + 16) = 0;
  if (result <= 2)
  {
    uint64_t v2 = qword_1CFAC87B8[(char)result];
    *(void *)a2 = off_1E6830B40[(char)result];
    *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v2;
    *(unsigned char *)(a2 + 16) = 1;
  }
  return result;
}

uint64_t llvm::Argument::hasPointeeInMemoryValueAttr(llvm::Argument *this)
{
  if (*(unsigned char *)(*(void *)this + 8) != 15) {
    return 0;
  }
  uint64_t v1 = *(void *)(*((void *)this + 3) + 112);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (*((_DWORD *)this + 8) + 2);
  if (v2 >= *(_DWORD *)(v1 + 8)) {
    return 0;
  }
  uint64_t v4 = v1 + 40;
  uint64_t v5 = *(void *)(v4 + 8 * v2);
  if (v5 && (*(unsigned char *)(v5 + 20) & 0x20) != 0) {
    return 1;
  }
  uint64_t v6 = *(void *)(v4 + 8 * v2);
  if (v6)
  {
    if ((*(unsigned char *)(v6 + 21) & 2) != 0) {
      return 1;
    }
  }
  uint64_t v7 = *(void *)(v4 + 8 * v2);
  if (v7)
  {
    if (*(char *)(v7 + 20) < 0) {
      return 1;
    }
  }
  uint64_t v8 = *(void *)(v4 + 8 * v2);
  if (v8)
  {
    if (*(unsigned char *)(v8 + 21)) {
      return 1;
    }
  }
  uint64_t v9 = *(void *)(v4 + 8 * v2);
  if (!v9) {
    return 0;
  }
  return (*(unsigned __int8 *)(v9 + 20) >> 4) & 1;
}

llvm::Type *llvm::Argument::getPassPointeeByValueCopySize(llvm::Argument *this, const llvm::DataLayout *a2)
{
  uint64_t v3 = *(void *)(*((void *)this + 3) + 112);
  if (v3 && (unsigned int v4 = *((_DWORD *)this + 8) + 2, v4 < *(_DWORD *)(v3 + 8))) {
    uint64_t v5 = *(void *)(v3 + 8 * v4 + 40);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (llvm::Type *)sub_1CC5B1F28(v5);
  if (result)
  {
    uint64_t v7 = result;
    unint64_t v8 = (unint64_t)(sub_1CB83544C((uint64_t)a2, (uint64_t)result) + 7) >> 3;
    BOOL v10 = v9 == 1;
    char Alignment = llvm::DataLayout::getAlignment(a2, v7, 1);
    v13[0] = ((1 << Alignment) + v8 - 1) & -(1 << Alignment);
    v13[1] = v10;
    return (llvm::Type *)llvm::TypeSize::operator unsigned long long(v13, v12);
  }
  return result;
}

uint64_t llvm::Argument::getParamAlignment(llvm::Argument *this)
{
  Paramchar Alignment = llvm::AttributeList::getParamAlignment((llvm::AttributeList *)(*((void *)this + 3) + 112), *((_DWORD *)this + 8));
  if ((ParamAlignment & 0xFF00) != 0) {
    return 1 << ParamAlignment;
  }
  else {
    return 0;
  }
}

uint64_t llvm::Argument::getParamStackAlign(llvm::Argument *this)
{
  return llvm::AttributeList::getParamStackAlignment((llvm::AttributeList *)(*((void *)this + 3) + 112), *((_DWORD *)this + 8));
}

uint64_t llvm::Argument::getParamByRefType(llvm::Argument *this)
{
  return llvm::AttributeList::getParamByRefType((llvm::AttributeList *)(*((void *)this + 3) + 112), *((_DWORD *)this + 8));
}

uint64_t llvm::Argument::hasNestAttr(llvm::Argument *this)
{
  if (*(unsigned char *)(*(void *)this + 8) == 15
    && (uint64_t v1 = *(void *)(*((void *)this + 3) + 112)) != 0
    && (unsigned int v2 = *((_DWORD *)this + 8) + 2, v2 < *(_DWORD *)(v1 + 8))
    && (uint64_t v4 = *(void *)(v1 + 8 * v2 + 40)) != 0)
  {
    return (*(unsigned __int8 *)(v4 + 14) >> 2) & 1;
  }
  else
  {
    return 0;
  }
}

uint64_t llvm::Argument::hasZExtAttr(llvm::Argument *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 3) + 112);
  if (v1 && (unsigned int v2 = *((_DWORD *)this + 8) + 2, v2 < *(_DWORD *)(v1 + 8)) && (v4 = *(void *)(v1 + 8 * v2 + 40)) != 0) {
    return (*(unsigned __int8 *)(v4 + 20) >> 3) & 1;
  }
  else {
    return 0;
  }
}

uint64_t llvm::Argument::hasSExtAttr(llvm::Argument *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 3) + 112);
  if (v1 && (unsigned int v2 = *((_DWORD *)this + 8) + 2, v2 < *(_DWORD *)(v1 + 8)) && (v4 = *(void *)(v1 + 8 * v2 + 40)) != 0) {
    return *(unsigned char *)(v4 + 18) & 1;
  }
  else {
    return 0;
  }
}

uint64_t llvm::Argument::addAttrs(llvm::Argument *this, llvm::AttrBuilder *a2)
{
  uint64_t v3 = *((void *)this + 3);
  uint64_t v5 = *(void *)(v3 + 112);
  uint64_t result = llvm::AttributeList::addAttributesAtIndex((llvm::AttributeList *)&v5, **(llvm::LLVMContext ***)v3, *((_DWORD *)this + 8) + 1, a2);
  *(void *)(*((void *)this + 3) + 112) = result;
  return result;
}

uint64_t llvm::Function::addParamAttr(uint64_t a1, int a2, signed int a3)
{
  uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(a1 + 112), **(uint64_t ***)a1, a2 + 1, a3);
  *(void *)(a1 + 112) = result;
  return result;
}

uint64_t llvm::Function::addParamAttr(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = a2;
  uint64_t result = llvm::AttributeList::addParamAttribute((void *)(a1 + 112), **(uint64_t ***)a1, &v5, 1, a3);
  *(void *)(a1 + 112) = result;
  return result;
}

uint64_t llvm::Argument::getAttribute(uint64_t a1, int a2)
{
  return llvm::AttributeList::getAttributeAtIndex((uint64_t *)(*(void *)(a1 + 24) + 112), *(_DWORD *)(a1 + 32) + 1, a2);
}

uint64_t llvm::Function::getInstructionCount(llvm::Function *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (char *)this + 72;
  unsigned int v2 = (char *)*((void *)this + 10);
  if (v2 == (char *)this + 72) {
    return 0;
  }
  LODWORD(v3) = 0;
  do
  {
    if (v2) {
      uint64_t v4 = (llvm::BasicBlock *)(v2 - 24);
    }
    else {
      uint64_t v4 = 0;
    }
    llvm::BasicBlock::instructionsWithoutDebug(v4, 1, &v14);
    long long v17 = v14;
    if (v16)
    {
      if (v16 == v15)
      {
        int v19 = v18;
        (*(void (**)(void *, void *))(v15[0] + 24))(v15, v18);
      }
      else
      {
        int v19 = (void *)(*(uint64_t (**)(void))(*v16 + 16))();
      }
    }
    else
    {
      int v19 = 0;
    }
    llvm::BasicBlock::instructionsWithoutDebug(v4, 1, v7);
    long long v11 = v8;
    if (v10)
    {
      if (v10 == v9)
      {
        int v13 = v12;
        (*(void (**)(void *, void *))(v9[0] + 24))(v9, v12);
      }
      else
      {
        int v13 = (void *)(*(uint64_t (**)(void))(*v10 + 16))();
      }
    }
    else
    {
      int v13 = 0;
    }
    int v5 = sub_1CC5373E4(&v17, &v11);
    if (v13 == v12)
    {
      (*(void (**)(void *))(v12[0] + 32))(v12);
    }
    else if (v13)
    {
      (*(void (**)(void))(*v13 + 40))();
    }
    sub_1CD484020(v7);
    if (v19 == v18)
    {
      (*(void (**)(void *))(v18[0] + 32))(v18);
    }
    else if (v19)
    {
      (*(void (**)(void))(*v19 + 40))();
    }
    uint64_t v3 = (v3 + v5);
    sub_1CD484020(&v14);
    unsigned int v2 = (char *)*((void *)v2 + 1);
  }
  while (v2 != v1);
  return v3;
}

unint64_t *llvm::Function::Create(llvm::PointerType *a1, char a2, const char **a3, unint64_t a4)
{
  long long v8 = (llvm::Type *)*(unsigned int *)(a4 + 284);
  int v9 = (char *)operator new(0x80uLL);
  *((_DWORD *)v9 + 7) = *((_DWORD *)v9 + 7) & 0x38000000 | 0x40000000;
  *(void *)int v9 = 0;
  BOOL v10 = (unint64_t *)(v9 + 8);

  return llvm::Function::Function(v10, a1, a2, v8, a3, a4);
}

char *llvm::Function::createWithDefaultAttr(llvm::PointerType *a1, char a2, llvm::Type *a3, const char **a4, llvm::Module *a5)
{
  v19[8] = *MEMORY[0x1E4F143B8];
  BOOL v10 = (char *)operator new(0x80uLL);
  *((_DWORD *)v10 + 7) = *((_DWORD *)v10 + 7) & 0x38000000 | 0x40000000;
  *(void *)BOOL v10 = 0;
  llvm::Function::Function((unint64_t *)v10 + 1, a1, a2, a3, a4, (unint64_t)a5);
  uint64_t v16 = (uint64_t *)**((void **)v10 + 1);
  long long v17 = v19;
  uint64_t v18 = 0x800000000;
  int Uwtable = llvm::Module::getUwtable(a5);
  if (Uwtable) {
    llvm::AttrBuilder::addUWTableAttr(&v16, Uwtable);
  }
  int FramePointer = llvm::Module::getFramePointer(a5);
  if (FramePointer == 1)
  {
    int v13 = "non-leaf";
    size_t v14 = 8;
  }
  else
  {
    if (FramePointer != 2) {
      goto LABEL_8;
    }
    int v13 = "all";
    size_t v14 = 3;
  }
  llvm::AttrBuilder::addAttribute(&v16, "frame-pointer", 0xDuLL, (unsigned __int8 *)v13, v14);
LABEL_8:
  *((void *)v10 + 15) = llvm::AttributeList::addAttributesAtIndex((llvm::AttributeList *)(v10 + 120), **((llvm::LLVMContext ***)v10 + 1), -1, (const llvm::AttrBuilder *)&v16);
  if (v17 != v19) {
    free(v17);
  }
  return v10 + 8;
}

void llvm::Function::removeFromParent(llvm::Function *this)
{
  llvm::SymbolTableListTraits<llvm::Function>::removeNodeFromList(*((void *)this + 5) + 24, (uint64_t ***)this);
  uint64_t v2 = *((void *)this + 7);
  uint64_t v3 = (void *)*((void *)this + 8);
  *uint64_t v3 = v2;
  *(void *)(v2 + sub_1CD521E44((uint64_t)this + 8) = v3;
  *((void *)this + 7) = 0;
  *((void *)this + sub_1CD521E44((uint64_t)this + 8) = 0;
}

BOOL llvm::Function::isConstrainedFPIntrinsic(llvm::Function *this)
{
  return (*((_DWORD *)this + 9) - 79) < 0x28;
}

void llvm::Function::stealArgumentListFrom(llvm::Function *this, llvm::Function *a2)
{
  v15[16] = *MEMORY[0x1E4F143B8];
  __int16 v4 = *((_WORD *)this + 9);
  if ((v4 & 1) == 0)
  {
    llvm::Function::clearArguments(this);
    __int16 v4 = *((_WORD *)this + 9) | 1;
    *((_WORD *)this + 9) = v4;
  }
  if ((*((_WORD *)a2 + 9) & 1) == 0)
  {
    *((void *)this + 11) = *((void *)a2 + 11);
    *((void *)a2 + 11) = 0;
    uint64_t v5 = *((void *)this + 12);
    if (v5)
    {
      uint64_t v6 = *((void *)this + 11);
      uint64_t v7 = 40 * v5;
      do
      {
        int v13 = v15;
        long long v14 = xmmword_1CFAC3020;
        if ((*(unsigned char *)(v6 + 23) & 0x10) != 0
          && (Name = llvm::Value::getName((llvm::Value *)v6), sub_1CC22C75C(&v13, Name, &Name[v9]), (void)v14))
        {
          __int16 v12 = 257;
          llvm::Value::setName((llvm::Value *)v6, v11);
          BOOL v10 = (const char *)v14;
          *(void *)(v6 + 24) = this;
          if (v10)
          {
            __int16 v12 = 261;
            v11[0] = (const char *)v13;
            v11[1] = v10;
            llvm::Value::setName((llvm::Value *)v6, v11);
          }
        }
        else
        {
          *(void *)(v6 + 24) = this;
        }
        if (v13 != v15) {
          free(v13);
        }
        v6 += 40;
        v7 -= 40;
      }
      while (v7);
      __int16 v4 = *((_WORD *)this + 9);
    }
    *((_WORD *)this + 9) = v4 & 0xFFFE;
    *((_WORD *)a2 + 9) |= 1u;
  }
}

uint64_t llvm::Function::addFnAttr(llvm::LLVMContext ***a1, uint64_t a2)
{
  uint64_t result = llvm::AttributeList::addAttributeAtIndex((llvm::AttributeList *)(a1 + 14), **a1, -1, a2);
  a1[14] = (llvm::LLVMContext **)result;
  return result;
}

uint64_t llvm::Function::addRetAttr(uint64_t a1, signed int a2)
{
  uint64_t result = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(a1 + 112), **(uint64_t ***)a1, 0, a2);
  *(void *)(a1 + 112) = result;
  return result;
}

llvm::LLVMContext **llvm::Function::addParamAttrs(llvm::LLVMContext ***this, int a2, const llvm::AttrBuilder *a3)
{
  uint64_t result = (llvm::LLVMContext **)llvm::AttributeList::addAttributesAtIndex((llvm::AttributeList *)(this + 14), **this, a2 + 1, a3);
  this[14] = result;
  return result;
}

uint64_t llvm::Function::removeParamAttr(uint64_t a1, int a2, void *a3, size_t a4)
{
  uint64_t result = llvm::AttributeList::removeAttributeAtIndex((uint64_t *)(a1 + 112), **(uint64_t ***)a1, a2 + 1, a3, a4);
  *(void *)(a1 + 112) = result;
  return result;
}

uint64_t llvm::Function::getDenormalMode(uint64_t *a1, void *a2)
{
  if (llvm::APFloatBase::IEEEsingle((llvm::APFloatBase *)a1) != a2
    || (uint64_t AttributeAtIndex = llvm::AttributeList::getAttributeAtIndex(a1 + 14, -1, "denormal-fp-math-f32", 0x14uLL),
        uint64_t ValueAsString = llvm::Attribute::getValueAsString((llvm::Attribute *)&AttributeAtIndex),
        !v4))
  {
    uint64_t AttributeAtIndex = llvm::AttributeList::getAttributeAtIndex(a1 + 14, -1, "denormal-fp-math", 0x10uLL);
    uint64_t ValueAsString = llvm::Attribute::getValueAsString((llvm::Attribute *)&AttributeAtIndex);
  }
  return sub_1CD5BF42C(ValueAsString, v4);
}

uint64_t sub_1CD5BF42C(uint64_t a1, unint64_t a2)
{
  v10[0] = a1;
  v10[1] = a2;
  char v11 = 44;
  unint64_t v4 = llvm::StringRef::find(v10, &v11, 1uLL, 0);
  if (v4 == -1)
  {
    int v5 = sub_1CD5C0698(a1, a2);
    unsigned __int8 v6 = v5;
  }
  else
  {
    if (a2 >= v4) {
      uint64_t v8 = v4;
    }
    else {
      uint64_t v8 = a2;
    }
    unint64_t v9 = v4 + 1;
    int v5 = sub_1CD5C0698(a1, v8);
    unsigned __int8 v6 = v5;
    if (a2 > v9) {
      int v5 = sub_1CD5C0698(a1 + v9, a2 - v9);
    }
  }
  return v6 | (v5 << 8);
}

void *llvm::Function::getGC(llvm::LLVMContext ***this)
{
  return llvm::LLVMContext::getGC(**this, (const llvm::Function *)this);
}

void llvm::Function::setGC(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  else {
    uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  }
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(a1 + 18) & 0xBFFF | ((v3 != 0) << 14);
  unint64_t v4 = **(uint64_t ***)a1;
  uint64_t v6 = *(void *)(a2 + 16);
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  llvm::LLVMContext::setGC(v4, a1, (long long *)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void *llvm::Function::setPersonalityFn(llvm::Function *this, llvm::Constant *a2)
{
  __int16 v3 = a2 != 0;
  uint64_t result = sub_1CD5C0280(this, (uint64_t)a2);
  *((_WORD *)this + 9) = *((_WORD *)this + 9) & 0xFFF7 | (8 * v3);
  return result;
}

uint64_t llvm::Function::getPersonalityFn(llvm::Function *this)
{
  int v1 = *((_DWORD *)this + 5);
  if ((v1 & 0x40000000) != 0) {
    uint64_t v2 = (char *)*((void *)this - 1);
  }
  else {
    uint64_t v2 = (char *)this - 32 * (v1 & 0x7FFFFFF);
  }
  return *(void *)v2;
}

void *llvm::Function::setPrologueData(llvm::Function *this, llvm::Constant *a2)
{
  __int16 v3 = a2 != 0;
  uint64_t result = sub_1CD5C0388(this, (uint64_t)a2);
  *((_WORD *)this + 9) = *((_WORD *)this + 9) & 0xFFFB | (4 * v3);
  return result;
}

uint64_t llvm::Function::getPrologueData(llvm::Function *this)
{
  int v1 = *((_DWORD *)this + 5);
  if ((v1 & 0x40000000) != 0) {
    uint64_t v2 = (char *)*((void *)this - 1);
  }
  else {
    uint64_t v2 = (char *)this - 32 * (v1 & 0x7FFFFFF);
  }
  return *((void *)v2 + 8);
}

uint64_t llvm::Intrinsic::isOverloaded(llvm::Intrinsic *this)
{
  return (byte_1CFADA6F7[(unint64_t)this >> 3] >> (this & 7)) & 1;
}

char *llvm::Intrinsic::getBaseName(llvm::Intrinsic *this)
{
  int v1 = off_1E6830B58[this];
  if (v1) {
    strlen(off_1E6830B58[this]);
  }
  return v1;
}

uint64_t llvm::Intrinsic::getIntrinsicForGCCBuiltin(uint64_t a1, const char *a2, size_t a3)
{
  if (a1) {
    size_t v6 = strlen((const char *)a1);
  }
  else {
    size_t v6 = 0;
  }
  uint64_t v7 = (const char *)&unk_1CFB0DFBC;
  unint64_t v8 = 9;
  do
  {
    unint64_t v9 = (unsigned int *)&v7[8 * (v8 >> 1)];
    int v10 = strncmp(&aBuiltinAdjustT[v9[1]], a2, a3);
    if (v10 >= 0) {
      v8 >>= 1;
    }
    else {
      v8 += ~(v8 >> 1);
    }
    if (v10 < 0) {
      uint64_t v7 = (const char *)(v9 + 2);
    }
  }
  while (v8);
  if (v7 != (const char *)&unk_1CFB0E004
    && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
    && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
  {
    return *(unsigned int *)v7;
  }
  if (v6 != 7) {
    goto LABEL_71;
  }
  if (*(_DWORD *)a1 == 1668440417 && *(_DWORD *)(a1 + 3) == 875980899)
  {
    uint64_t v7 = (const char *)&unk_1CFB0E004;
    unint64_t v22 = 18;
    do
    {
      uint64_t v23 = (unsigned int *)&v7[8 * (v22 >> 1)];
      int v24 = strncmp(&aBuiltinAdjustT[v23[1]], a2, a3);
      if (v24 >= 0) {
        v22 >>= 1;
      }
      else {
        v22 += ~(v22 >> 1);
      }
      if (v24 < 0) {
        uint64_t v7 = (const char *)(v23 + 2);
      }
    }
    while (v22);
    if (v7 != (const char *)&unk_1CFB0E094
      && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
      && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
    {
      return *(unsigned int *)v7;
    }
LABEL_71:
    if (v6 == 6)
    {
      if (*(_DWORD *)a1 != 1734634849 || *(_WORD *)(a1 + 4) != 28259) {
        return 0;
      }
      uint64_t v7 = (const char *)&unk_1CFB0E094;
      unint64_t v33 = 125;
      do
      {
        uint64_t v34 = (unsigned int *)&v7[8 * (v33 >> 1)];
        int v35 = strncmp(&aBuiltinAdjustT[v34[1]], a2, a3);
        if (v35 >= 0) {
          v33 >>= 1;
        }
        else {
          v33 += ~(v33 >> 1);
        }
        if (v35 < 0) {
          uint64_t v7 = (const char *)(v34 + 2);
        }
      }
      while (v33);
      if (v7 != (const char *)&unk_1CFB0E47C
        && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
        && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
      {
        return *(unsigned int *)v7;
      }
    }
    BOOL v12 = v6 == 3;
    if (v6 == 3)
    {
      if (*(_WORD *)a1 == 29281 && *(unsigned char *)(a1 + 2) == 109)
      {
        uint64_t v7 = (const char *)&unk_1CFB0E47C;
        unint64_t v50 = 96;
        do
        {
          uint64_t v51 = (unsigned int *)&v7[8 * (v50 >> 1)];
          int v52 = strncmp(&aBuiltinAdjustT[v51[1]], a2, a3);
          if (v52 >= 0) {
            v50 >>= 1;
          }
          else {
            v50 += ~(v50 >> 1);
          }
          if (v52 < 0) {
            uint64_t v7 = (const char *)(v51 + 2);
          }
        }
        while (v50);
        BOOL v12 = v6 == 3;
        if (v7 != (const char *)&unk_1CFB0E77C
          && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
          && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
        {
          return *(unsigned int *)v7;
        }
      }
      if (*(_WORD *)a1 != 28770 || *(unsigned char *)(a1 + 2) != 102)
      {
        int v14 = 0;
        goto LABEL_26;
      }
      uint64_t v7 = (const char *)&unk_1CFB0E77C;
      unint64_t v53 = 10;
      do
      {
        uint64_t v54 = (unsigned int *)&v7[8 * (v53 >> 1)];
        int v55 = strncmp(&aBuiltinAdjustT[v54[1]], a2, a3);
        if (v55 >= 0) {
          v53 >>= 1;
        }
        else {
          v53 += ~(v53 >> 1);
        }
        if (v55 < 0) {
          uint64_t v7 = (const char *)(v54 + 2);
        }
      }
      while (v53);
      if (v7 != (const char *)&unk_1CFB0E7CC
        && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
        && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
      {
        return *(unsigned int *)v7;
      }
    }
    if (v6 != 7) {
      goto LABEL_197;
    }
    goto LABEL_20;
  }
  BOOL v12 = 0;
LABEL_20:
  if (*(_DWORD *)a1 != 1635280232 || *(_DWORD *)(a1 + 3) != 1852794721)
  {
    int v14 = 0;
    goto LABEL_25;
  }
  uint64_t v7 = (const char *)&unk_1CFB0E7CC;
  unint64_t v27 = 1866;
  do
  {
    unsigned int v28 = (unsigned int *)&v7[8 * (v27 >> 1)];
    int v29 = strncmp(&aBuiltinAdjustT[v28[1]], a2, a3);
    if (v29 >= 0) {
      v27 >>= 1;
    }
    else {
      v27 += ~(v27 >> 1);
    }
    if (v29 < 0) {
      uint64_t v7 = (const char *)(v28 + 2);
    }
  }
  while (v27);
  if (v7 != (const char *)&unk_1CFB1221C
    && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
    && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
  {
    return *(unsigned int *)v7;
  }
LABEL_197:
  if (v6 != 4)
  {
    int v14 = 0;
    int v16 = 0;
    if (!v12) {
      goto LABEL_34;
    }
    goto LABEL_26;
  }
  if (*(_DWORD *)a1 == 1936746861)
  {
    uint64_t v7 = (const char *)&unk_1CFB1221C;
    unint64_t v56 = 671;
    do
    {
      uint64_t v57 = (unsigned int *)&v7[8 * (v56 >> 1)];
      int v58 = strncmp(&aBuiltinAdjustT[v57[1]], a2, a3);
      if (v58 >= 0) {
        v56 >>= 1;
      }
      else {
        v56 += ~(v56 >> 1);
      }
      if (v58 < 0) {
        uint64_t v7 = (const char *)(v57 + 2);
      }
    }
    while (v56);
    if (v7 != (const char *)&unk_1CFB13714
      && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
      && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
    {
      return *(unsigned int *)v7;
    }
  }
  if (*(_DWORD *)a1 != 1836480110)
  {
    int v14 = 1;
LABEL_25:
    if (!v12)
    {
      int v16 = 0;
LABEL_31:
      if (!v14) {
        goto LABEL_34;
      }
      goto LABEL_32;
    }
LABEL_26:
    if (*(_WORD *)a1 == 28784 && *(unsigned char *)(a1 + 2) == 99)
    {
      size_t v62 = v6;
      uint64_t v7 = (const char *)&unk_1CFB14CAC;
      unint64_t v30 = 482;
      do
      {
        uint64_t v31 = (unsigned int *)&v7[8 * (v30 >> 1)];
        int v32 = strncmp(&aBuiltinAdjustT[v31[1]], a2, a3);
        if (v32 >= 0) {
          v30 >>= 1;
        }
        else {
          v30 += ~(v30 >> 1);
        }
        if (v32 < 0) {
          uint64_t v7 = (const char *)(v31 + 2);
        }
      }
      while (v30);
      size_t v6 = v62;
      if (v7 != (const char *)&unk_1CFB15BBC
        && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
        && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
      {
        return *(unsigned int *)v7;
      }
      int v16 = 1;
      if ((v14 & 1) == 0) {
        goto LABEL_34;
      }
      goto LABEL_32;
    }
    int v16 = 1;
    goto LABEL_31;
  }
  uint64_t v7 = (const char *)&unk_1CFB13714;
  unint64_t v59 = 691;
  do
  {
    int v60 = (unsigned int *)&v7[8 * (v59 >> 1)];
    int v61 = strncmp(&aBuiltinAdjustT[v60[1]], a2, a3);
    if (v61 >= 0) {
      v59 >>= 1;
    }
    else {
      v59 += ~(v59 >> 1);
    }
    if (v61 < 0) {
      uint64_t v7 = (const char *)(v60 + 2);
    }
  }
  while (v59);
  if (v7 != (const char *)&unk_1CFB14CAC
    && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
    && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
  {
    return *(unsigned int *)v7;
  }
  if (v12)
  {
    int v14 = 1;
    goto LABEL_26;
  }
  int v16 = 0;
LABEL_32:
  if (*(_DWORD *)a1 == 808466034)
  {
    uint64_t v7 = (const char *)&unk_1CFB15BBC;
    unint64_t v41 = 12;
    do
    {
      uint64_t v42 = (unsigned int *)&v7[8 * (v41 >> 1)];
      int v43 = strncmp(&aBuiltinAdjustT[v42[1]], a2, a3);
      if (v43 >= 0) {
        v41 >>= 1;
      }
      else {
        v41 += ~(v41 >> 1);
      }
      if (v43 < 0) {
        uint64_t v7 = (const char *)(v42 + 2);
      }
    }
    while (v41);
    if (v7 != (const char *)&unk_1CFB15C1C
      && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
      && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
    {
      return *(unsigned int *)v7;
    }
  }
  if (*(_DWORD *)a1 == 809055091)
  {
    uint64_t v7 = (const char *)&unk_1CFB15C1C;
    unint64_t v47 = 162;
    do
    {
      int v48 = (unsigned int *)&v7[8 * (v47 >> 1)];
      int v49 = strncmp(&aBuiltinAdjustT[v48[1]], a2, a3);
      if (v49 >= 0) {
        v47 >>= 1;
      }
      else {
        v47 += ~(v47 >> 1);
      }
      if (v49 < 0) {
        uint64_t v7 = (const char *)(v48 + 2);
      }
    }
    while (v47);
    if (v7 != (const char *)&unk_1CFB1612C
      && strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) == a3
      && (!a3 || !memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3)))
    {
      return *(unsigned int *)v7;
    }
  }
LABEL_34:
  if (v6 != 2 || *(_WORD *)a1 != 25974) {
    goto LABEL_233;
  }
  uint64_t v7 = (const char *)&unk_1CFB1612C;
  unint64_t v38 = 1263;
  do
  {
    int64x2_t v39 = (unsigned int *)&v7[8 * (v38 >> 1)];
    int v40 = strncmp(&aBuiltinAdjustT[v39[1]], a2, a3);
    if (v40 >= 0) {
      v38 >>= 1;
    }
    else {
      v38 += ~(v38 >> 1);
    }
    if (v40 < 0) {
      uint64_t v7 = (const char *)(v39 + 2);
    }
  }
  while (v38);
  if (v7 == (const char *)&unk_1CFB188A4
    || strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) != a3
    || a3 && memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3))
  {
LABEL_233:
    if (!v16) {
      goto LABEL_234;
    }
    if (*(_WORD *)a1 != 14456 || *(unsigned char *)(a1 + 2) != 54) {
      goto LABEL_234;
    }
    uint64_t v7 = (const char *)&unk_1CFB188A4;
    unint64_t v44 = 1161;
    do
    {
      uint64_t v45 = (unsigned int *)&v7[8 * (v44 >> 1)];
      int v46 = strncmp(&aBuiltinAdjustT[v45[1]], a2, a3);
      if (v46 >= 0) {
        v44 >>= 1;
      }
      else {
        v44 += ~(v44 >> 1);
      }
      if (v46 < 0) {
        uint64_t v7 = (const char *)(v45 + 2);
      }
    }
    while (v44);
    if (v7 == (const char *)&unk_1CFB1ACEC
      || strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) != a3
      || a3 && memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3))
    {
LABEL_234:
      if (v6 != 5) {
        return 0;
      }
      if (*(_DWORD *)a1 != 1919902584 || *(unsigned char *)(a1 + 4) != 101) {
        return 0;
      }
      uint64_t v7 = (const char *)&unk_1CFB1ACEC;
      unint64_t v19 = 4;
      do
      {
        uint64_t v20 = (unsigned int *)&v7[8 * (v19 >> 1)];
        int v21 = strncmp(&aBuiltinAdjustT[v20[1]], a2, a3);
        if (v21 >= 0) {
          v19 >>= 1;
        }
        else {
          v19 += ~(v19 >> 1);
        }
        if (v21 < 0) {
          uint64_t v7 = (const char *)(v20 + 2);
        }
      }
      while (v19);
      if (v7 == "__dmb"
        || strlen(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)]) != a3
        || a3 && memcmp(&aBuiltinAdjustT[*((unsigned int *)v7 + 1)], a2, a3))
      {
        return 0;
      }
    }
  }
  return *(unsigned int *)v7;
}

const char *llvm::Intrinsic::getIntrinsicForMSBuiltin(const char *result, const char *a2, size_t a3)
{
  if (result)
  {
    int v5 = result;
    size_t v6 = strlen(result);
    if (v6 == 3)
    {
      if (*(_WORD *)v5 != 29281 || v5[2] != 109) {
        return 0;
      }
      unint64_t v8 = (unsigned int *)&unk_1CFB1AD64;
      unint64_t v14 = 5;
      do
      {
        uint64_t v15 = &v8[2 * (v14 >> 1)];
        int v16 = strncmp(&aDmb[v15[1]], a2, a3);
        if (v16 >= 0) {
          v14 >>= 1;
        }
        else {
          v14 += ~(v14 >> 1);
        }
        if (v16 < 0) {
          unint64_t v8 = v15 + 2;
        }
      }
      while (v14);
      BOOL v12 = (unsigned int *)byte_1CFB1AD8C;
    }
    else
    {
      if (v6 != 7) {
        return 0;
      }
      if (*(_DWORD *)v5 != 1668440417 || *(_DWORD *)(v5 + 3) != 875980899) {
        return 0;
      }
      unint64_t v8 = (unsigned int *)&unk_1CFB1AD4C;
      unint64_t v9 = 3;
      do
      {
        int v10 = &v8[2 * (v9 >> 1)];
        int v11 = strncmp(&aDmb[v10[1]], a2, a3);
        if (v11 >= 0) {
          v9 >>= 1;
        }
        else {
          v9 += ~(v9 >> 1);
        }
        if (v11 < 0) {
          unint64_t v8 = v10 + 2;
        }
      }
      while (v9);
      BOOL v12 = (unsigned int *)&unk_1CFB1AD64;
    }
    if (v8 != v12 && strlen(&aDmb[v8[1]]) == a3 && (!a3 || !memcmp(&aDmb[v8[1]], a2, a3))) {
      return (const char *)*v8;
    }
    return 0;
  }
  return result;
}

void *sub_1CD5C0280(void *this, uint64_t a2)
{
  uint64_t v2 = this;
  if (a2)
  {
    this = llvm::Function::allocHungoffUselist(this);
    int v4 = *((_DWORD *)v2 + 5);
    if ((v4 & 0x40000000) != 0) {
      int v5 = (void *)*(v2 - 1);
    }
    else {
      int v5 = &v2[-4 * (v4 & 0x7FFFFFF)];
    }
    if (*v5)
    {
      *(void *)void v5[2] = v5[1];
      uint64_t v8 = v5[1];
      if (v8) {
        *(void *)(v8 + 16) = v5[2];
      }
    }
    void *v5 = a2;
    uint64_t v11 = *(void *)(a2 + 8);
    int v10 = (void *)(a2 + 8);
    uint64_t v9 = v11;
    v5[1] = v11;
    if (v11) {
      *(void *)(v9 + 16) = v5 + 1;
    }
    void v5[2] = v10;
    void *v10 = v5;
  }
  else
  {
    int v6 = *((_DWORD *)this + 5);
    if ((v6 & 0x7FFFFFF) != 0)
    {
      if ((v6 & 0x40000000) != 0) {
        uint64_t v7 = (void *)*(this - 1);
      }
      else {
        uint64_t v7 = &this[-4 * (v6 & 0x7FFFFFF)];
      }
      BOOL v12 = (llvm::ConstantPointerNull *)llvm::PointerType::get((llvm::PointerType *)(**(void **)*this + 1888), 0);
      this = llvm::ConstantPointerNull::get(v12, v13);
      if (*v7)
      {
        *(void *)void v7[2] = v7[1];
        uint64_t v14 = v7[1];
        if (v14) {
          *(void *)(v14 + 16) = v7[2];
        }
      }
      *uint64_t v7 = this;
      if (this)
      {
        uint64_t v16 = this[1];
        ++this;
        uint64_t v15 = v16;
        v7[1] = v16;
        if (v16) {
          *(void *)(v15 + 16) = v7 + 1;
        }
        void v7[2] = this;
        *this = v7;
      }
    }
  }
  return this;
}

void *sub_1CD5C0388(void *this, uint64_t a2)
{
  uint64_t v2 = this;
  if (a2)
  {
    this = llvm::Function::allocHungoffUselist(this);
    int v4 = *((_DWORD *)v2 + 5);
    if ((v4 & 0x40000000) != 0) {
      int v5 = (void *)*(v2 - 1);
    }
    else {
      int v5 = &v2[-4 * (v4 & 0x7FFFFFF)];
    }
    if (v5[8])
    {
      *(void *)v5[10] = v5[9];
      uint64_t v8 = v5[9];
      if (v8) {
        *(void *)(v8 + 16) = v5[10];
      }
    }
    v5[8] = a2;
    uint64_t v11 = *(void *)(a2 + 8);
    int v10 = (void *)(a2 + 8);
    uint64_t v9 = v11;
    v5[9] = v11;
    if (v11) {
      *(void *)(v9 + 16) = v5 + 9;
    }
    v5[10] = v10;
    void *v10 = v5 + 8;
  }
  else
  {
    int v6 = *((_DWORD *)this + 5);
    if ((v6 & 0x7FFFFFF) != 0)
    {
      if ((v6 & 0x40000000) != 0) {
        uint64_t v7 = (void *)*(this - 1);
      }
      else {
        uint64_t v7 = &this[-4 * (v6 & 0x7FFFFFF)];
      }
      BOOL v12 = (llvm::ConstantPointerNull *)llvm::PointerType::get((llvm::PointerType *)(**(void **)*this + 1888), 0);
      this = llvm::ConstantPointerNull::get(v12, v13);
      uint64_t v14 = v7 + 8;
      if (v7[8])
      {
        *(void *)v7[10] = v7[9];
        uint64_t v15 = v7[9];
        if (v15) {
          *(void *)(v15 + 16) = v7[10];
        }
      }
      *uint64_t v14 = this;
      if (this)
      {
        uint64_t v17 = this[1];
        ++this;
        uint64_t v16 = v17;
        v7[9] = v17;
        if (v17) {
          *(void *)(v16 + 16) = v7 + 9;
        }
        v7[10] = this;
        *this = v14;
      }
    }
  }
  return this;
}

uint64_t llvm::Function::setEntryCount(llvm::Function *a1, unint64_t a2, int a3, uint64_t a4)
{
  llvm::Function::getImportGUIDs(a1, (uint64_t)&v13);
  if (v14) {
    uint64_t v8 = &v13;
  }
  else {
    uint64_t v8 = 0;
  }
  if (a4) {
    uint64_t v9 = a4;
  }
  else {
    uint64_t v9 = (uint64_t)v8;
  }
  uint64_t v12 = **(void **)a1;
  int v10 = llvm::MDBuilder::createFunctionEntryCount(&v12, a2, a3 == 1, v9);
  llvm::Value::setMetadata((uint64_t ***)a1, 2, v10);
  return MEMORY[0x1D25D9CD0](v13, 8);
}

{
  return llvm::Function::setEntryCount(a1, a2, a3, a4);
}

uint64_t llvm::Function::getImportGUIDs@<X0>(llvm::Function *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  uint64_t result = llvm::Value::getMetadata(this, 2);
  if (result)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(unsigned int *)(result + 8);
    uint64_t v6 = *(void *)(result - 8 * v5);
    if (!*(unsigned char *)v6)
    {
      uint64_t v7 = *(void *)(v6 + 8);
      if (*(void *)v7 == 20)
      {
        uint64_t v8 = *(void *)(v7 + 24);
        uint64_t v9 = *(void *)(v7 + 32);
        int v10 = *(_DWORD *)(v7 + 40);
        BOOL v11 = v8 == 0x6E6F6974636E7566 && v9 == 0x635F7972746E655FLL;
        BOOL v12 = v11 && v10 == 1953396079;
        BOOL v13 = !v12;
        if (v5 >= 3 && !v13)
        {
          for (unint64_t i = 2; i < v5; ++i)
          {
            uint64_t v15 = *(void *)(*(void *)(v4 - 8 * v5 + 8 * i) + 128);
            uint64_t v16 = (void *)(v15 + 24);
            if (*(_DWORD *)(v15 + 32) >= 0x41u) {
              uint64_t v16 = (void *)*v16;
            }
            uint64_t v17 = (void *)*v16;
            uint64_t result = (uint64_t)sub_1CD4ADCD0(a2, (uint64_t *)&v17, (uint64_t)v18);
            unint64_t v5 = *(unsigned int *)(v4 + 8);
          }
        }
      }
    }
  }
  return result;
}

void llvm::Function::setSectionPrefix(uint64_t ***a1, unsigned __int8 *a2, size_t a3)
{
  unint64_t v5 = **a1;
  uint64_t v4 = llvm::MDBuilder::createFunctionSectionPrefix(&v5, a2, a3);
  llvm::Value::setMetadata(a1, 20, v4);
}

uint64_t sub_1CD5C0698(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 != 13)
  {
    if (a2 != 4 || *(_DWORD *)a1 != 1701143913) {
      return -1;
    }
    return 0;
  }
  if (*(void *)a1 == 0x6576726573657270 && *(void *)(a1 + 5) == 0x6E6769732D657672)
  {
    return 1;
  }
  else if (*(void *)a1 ^ 0x6576697469736F70 | *(void *)(a1 + 5) ^ 0x6F72657A2D657669)
  {
    return -1;
  }
  else
  {
    return 2;
  }
}

double sub_1CD5C0754(uint64_t **a1)
{
  uint64_t v2 = (unsigned __int8 *)a1[3];
  unsigned int v3 = v2[8];
  if (v3 > 6)
  {
    v12[0] = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v2);
    v12[1] = v9;
    unsigned int v10 = llvm::TypeSize::operator unsigned long long(v12, v9);
    uint64_t v8 = (llvm::FixedVectorType *)llvm::IntegerType::get((llvm::IntegerType *)*a1, (llvm::LLVMContext *)(v10 >> 1));
  }
  else
  {
    uint64_t v4 = **a1;
    BOOL v5 = v3 == 3;
    uint64_t v6 = (llvm::FixedVectorType *)(v4 + 1624);
    uint64_t v7 = (llvm::FixedVectorType *)(v4 + 1672);
    if (v5) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v6;
    }
  }
  return llvm::VectorType::get(v8, (llvm::Type *)(*((unsigned int *)a1 + 8) | ((unint64_t)(*((unsigned char *)a1 + 8) == 19) << 32)));
}

void sub_1CD5C07E0(uint64_t a1, int a2)
{
  if (a2 >= 1)
  {
    int v2 = a2;
    do
    {
      llvm::VectorType::get(*(llvm::FixedVectorType **)(a1 + 24), (llvm::Type *)((2 * *(_DWORD *)(a1 + 32)) | ((unint64_t)(*(unsigned char *)(a1 + 8) == 19) << 32)));
      sub_1CD5C0754(v3);
      --v2;
    }
    while (v2);
  }
}

unint64_t sub_1CD5C0838(unint64_t result, uint64_t a2, long long *a3)
{
  unint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(result + 8);
  if (v4 >= *(_DWORD *)(result + 12))
  {
    uint64_t v8 = a2;
    long long v9 = *a3;
    uint64_t result = sub_1CD483108(result, (unint64_t)&v8);
    uint64_t v6 = *(void *)v3 + 24 * *(unsigned int *)(v3 + 8);
    long long v7 = *(_OWORD *)result;
    *(void *)(v6 + 16) = *(void *)(result + 16);
    *(_OWORD *)uint64_t v6 = v7;
  }
  else
  {
    uint64_t v5 = *(void *)result + 24 * v4;
    *(void *)uint64_t v5 = a2;
    *(_OWORD *)(v5 + sub_1CD521E44((uint64_t)this + 8) = *a3;
  }
  ++*(_DWORD *)(v3 + 8);
  return result;
}

unint64_t sub_1CD5C08CC(llvm::User *a1, unsigned int a2)
{
  unint64_t result = sub_1CC5BC540(a1);
  if (result)
  {
    if (*((_DWORD *)llvm::User::getDescriptor(a1) + 2) <= a2)
    {
      Descriptor = llvm::User::getDescriptor(a1);
      return *(_DWORD *)&Descriptor[v6 - 4] > a2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::getGCStrategy(const std::string::value_type *a1, std::string::size_type a2)
{
  unsigned int v4 = llvm::Registry<llvm::GCStrategy>::Head;
  if (!llvm::Registry<llvm::GCStrategy>::Head)
  {
    sub_1CC5BC8A0(&v13, "unsupported GC: ");
    sub_1CD5C0A7C(&v12, a1, a2);
    sub_1CC5BC848(&v13, (uint64_t *)&v12, &v14);
    sub_1CC224444(&v14, " (did you remember to link and initialize the library?)", &v15);
    std::string::~string(&v14);
    std::string::~string(&v12);
    std::string::~string(&v13);
    sub_1CD5C0A90(v11, (uint64_t *)&v15);
    uint64_t v6 = v11[0];
    uint64_t v7 = v11[1];
LABEL_7:
    llvm::report_fatal_error(v6, v7, (const llvm::Twine *)1);
  }
  while (1)
  {
    uint64_t v5 = v4[1];
    if (*(void *)(v5 + 8) == a2 && (!a2 || !memcmp(*(const void **)v5, a1, a2))) {
      break;
    }
    unsigned int v4 = (void *)*v4;
    if (!v4)
    {
      sub_1CC5BC8A0(&v14, "unsupported GC: ");
      sub_1CD5C0A7C(&v13, a1, a2);
      sub_1CC5BC848(&v14, (uint64_t *)&v13, &v15);
      sub_1CD5C0A90(v10, (uint64_t *)&v15);
      uint64_t v6 = v10[0];
      uint64_t v7 = v10[1];
      goto LABEL_7;
    }
  }
  uint64_t v8 = *(uint64_t (**)(void))(v5 + 32);

  return v8();
}

void sub_1CD5C0A7C(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  if (__s)
  {
    std::string::__init(this, __s, __sz);
  }
  else
  {
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
    this->__r_.__value_.__r.__words[2] = 0;
  }
}

void *sub_1CD5C0A90(void *result, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    int v2 = a2;
  }
  else {
    int v2 = (uint64_t *)*a2;
  }
  void *result = v2;
  char v3 = *((unsigned char *)a2 + 23);
  int v4 = v3;
  uint64_t v5 = v3 & 0x7F;
  if (v4 < 0) {
    uint64_t v5 = a2[1];
  }
  result[1] = v5;
  return result;
}

llvm::detail::IEEEFloat *llvm::GlobalPtrAuthInfo::createWithSameSchema(llvm::GlobalPtrAuthInfo *this, llvm::Module *a2, llvm::Constant *a3, uint64_t a4, uint64_t a5, llvm::ConstantInt *a6)
{
  uint64_t v6 = (uint64_t ****)(*(void *)(*(void *)this - 32)
                    - 32 * (*(_DWORD *)(*(void *)(*(void *)this - 32) + 20) & 0x7FFFFFF));
  return llvm::GlobalPtrAuthInfo::create(a2, a3, v6[4], v6[8], v6[12], a6);
}

llvm::detail::IEEEFloat *llvm::GlobalPtrAuthInfo::create(llvm::GlobalPtrAuthInfo *this, llvm::Module *a2, uint64_t ***a3, uint64_t ***a4, uint64_t ***a5, llvm::ConstantInt *a6)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  BOOL v11 = (llvm::Constant *)llvm::PointerType::get((llvm::PointerType *)(**(void **)this + 1912), 0);
  v17[0] = (uint64_t ***)llvm::ConstantExpr::getBitCast(a2, v11, 0);
  v17[1] = a3;
  void v17[2] = a4;
  v17[3] = a5;
  TypeForElements = (llvm::PoisonValue *)llvm::ConstantStruct::getTypeForElements(v17, 4u, 0);
  std::string v13 = (llvm::PointerType **)llvm::ConstantStruct::get(TypeForElements, (llvm::Type *)v17, 4);
  std::string v14 = llvm::User::operator new((llvm::User *)0x58, 1u);
  std::string v15 = *v13;
  __int16 v18 = 257;
  llvm::GlobalVariable::GlobalVariable(v14, (uint64_t)this, v15, 1, 8, (unint64_t)v13, (const char **)v17, 0, 0, 0, 0);
  llvm::GlobalObject::setSection(v14, "llvm.ptrauth", 0xCuLL);
  return llvm::ConstantExpr::getBitCast((llvm::detail::IEEEFloat *)v14, *(llvm::Constant **)a2, 0);
}

uint64_t llvm::GlobalValue::materialize@<X0>(llvm::Module **this@<X0>, void *a2@<X8>)
{
  return llvm::Module::materialize(this[5], (llvm::GlobalValue *)this, a2);
}

void llvm::GlobalAlias::eraseFromParent(llvm::GlobalAlias *this)
{
}

void llvm::GlobalValue::getGlobalIdentifier(const std::string::value_type *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, const std::string::value_type *a4@<X3>, std::string::size_type a5@<X4>, std::string *a6@<X8>)
{
  if (a2) {
    BOOL v10 = *a1 == 1;
  }
  else {
    BOOL v10 = 0;
  }
  uint64_t v11 = v10;
  if (v10) {
    std::string v12 = a1 + 1;
  }
  else {
    std::string v12 = a1;
  }
  std::string::__init(a6, v12, a2 - v11);
  if ((a3 - 7) <= 1)
  {
    if (a5)
    {
      if (a4) {
        std::string::__init(&v19, a4, a5);
      }
      else {
        memset(&v19, 0, sizeof(v19));
      }
      std::string v13 = std::string::append(&v19, ":");
      std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      uint64_t v21 = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (v21 >= 0) {
        std::string v15 = __p;
      }
      else {
        std::string v15 = (void **)__p[0];
      }
      if (v21 >= 0) {
        std::string::size_type v16 = HIBYTE(v21) & 0x7F;
      }
      else {
        std::string::size_type v16 = (std::string::size_type)__p[1];
      }
      uint64_t v17 = std::string::insert(a6, 0, (const std::string::value_type *)v15, v16);
      std::string::operator=(a6, v17);
      if (SHIBYTE(v21) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v19.__r_.__value_.__l.__data_);
      }
    }
    else
    {
      __int16 v18 = std::string::insert(a6, 0, "<unknown>:");
      std::string::operator=(a6, v18);
    }
  }
}

void llvm::GlobalValue::getGlobalIdentifier(llvm::GlobalValue *this@<X0>, std::string *a2@<X8>)
{
  Name = llvm::Value::getName(this);
  int v6 = *((_DWORD *)this + 8) & 0xF;
  uint64_t v7 = *((void *)this + 5);
  BOOL v10 = *(const std::string::value_type **)(v7 + 192);
  uint64_t v8 = v7 + 192;
  long long v9 = v10;
  char v11 = *(unsigned char *)(v8 + 23);
  if (v11 >= 0) {
    std::string v12 = (const std::string::value_type *)v8;
  }
  else {
    std::string v12 = v9;
  }
  std::string::size_type v13 = *(void *)(v8 + 8);
  if (v11 >= 0) {
    std::string::size_type v14 = v11 & 0x7F;
  }
  else {
    std::string::size_type v14 = v13;
  }

  llvm::GlobalValue::getGlobalIdentifier(Name, v5, v6, v12, v14, a2);
}

uint64_t llvm::GlobalAlias::getAliaseeObject(llvm::GlobalAlias *this)
{
  v3[0] = 0;
  v3[1] = 0;
  int v4 = 0;
  uint64_t v1 = sub_1CC5BE54C(*((void *)this - 4), (uint64_t)v3);
  MEMORY[0x1D25D9CD0](v3[0], 8);
  return v1;
}

unint64_t *llvm::GlobalAlias::GlobalAlias(unint64_t *a1, llvm::PointerType *a2, llvm::Type *a3, char a4, const char **a5, unint64_t a6, uint64_t a7)
{
  BOOL v10 = sub_1CC5BF0A8(a1, a2, 1, a4, a5, a3);
  char v11 = v10 - 4;
  uint64_t v12 = *(v10 - 4);
  v10[6] = 0;
  _OWORD v10[7] = 0;
  if (v12)
  {
    *(void *)*(a1 - 2) = *(a1 - 3);
    uint64_t v13 = *(a1 - 3);
    if (v13) {
      *(void *)(v13 + 16) = *(a1 - 2);
    }
  }
  *char v11 = a6;
  if (a6)
  {
    unint64_t v16 = *(void *)(a6 + 8);
    std::string v15 = (unint64_t **)(a6 + 8);
    unint64_t v14 = v16;
    *(a1 - 3) = v16;
    if (v16) {
      *(void *)(v14 + 16) = a1 - 3;
    }
    *(a1 - 2) = (unint64_t)v15;
    *std::string v15 = v11;
  }
  if (a7) {
    llvm::SymbolTableListTraits<llvm::GlobalAlias>::addNodeToList();
  }
  return a1;
}

uint64_t llvm::GlobalAlias::setAliasee(uint64_t this, llvm::Constant *a2)
{
  int v2 = (void *)(this - 32);
  if (*(void *)(this - 32))
  {
    **(void **)(this - 16) = *(void *)(this - 24);
    uint64_t v3 = *(void *)(this - 24);
    if (v3) {
      *(void *)(v3 + 16) = *(void *)(this - 16);
    }
  }
  *int v2 = a2;
  if (a2)
  {
    uint64_t v6 = *((void *)a2 + 1);
    int v4 = (void *)((char *)a2 + 8);
    uint64_t v5 = v6;
    *(void *)(this - 24) = v6;
    if (v6) {
      *(void *)(v5 + 16) = this - 24;
    }
    *(void *)(this - 16) = v4;
    *int v4 = v2;
  }
  return this;
}

unint64_t *llvm::GlobalAlias::create(llvm::PointerType *a1, llvm::Type *a2, char a3, const char **a4, unint64_t a5, uint64_t a6)
{
  uint64_t v12 = (char *)operator new(0x60uLL);
  *((_DWORD *)v12 + 13) = *((_DWORD *)v12 + 13) & 0x38000000 | 1;
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  *((void *)v12 + 3) = v12 + 32;
  uint64_t v13 = (unint64_t *)(v12 + 32);

  return llvm::GlobalAlias::GlobalAlias(v13, a1, a2, a3, a4, a5, a6);
}

unint64_t *llvm::GlobalAlias::create(llvm::PointerType *a1, llvm::Type *a2, char a3, const char **a4, uint64_t a5)
{
  BOOL v10 = (char *)operator new(0x60uLL);
  *((_DWORD *)v10 + 13) = *((_DWORD *)v10 + 13) & 0x38000000 | 1;
  *(void *)BOOL v10 = 0;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  *((void *)v10 + 3) = v10 + 32;
  char v11 = (unint64_t *)(v10 + 32);

  return llvm::GlobalAlias::GlobalAlias(v11, a1, a2, a3, a4, 0, a5);
}

unint64_t *llvm::GlobalAlias::create(char a1, const char **a2, void *a3)
{
  uint64_t v6 = (llvm::PointerType *)a3[3];
  unsigned int v7 = *(_DWORD *)(*a3 + 8);
  uint64_t v8 = a3[5];
  long long v9 = (char *)operator new(0x60uLL);
  *((_DWORD *)v9 + 13) = *((_DWORD *)v9 + 13) & 0x38000000 | 1;
  *(void *)long long v9 = 0;
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 3) = v9 + 32;
  BOOL v10 = (unint64_t *)(v9 + 32);

  return llvm::GlobalAlias::GlobalAlias(v10, v6, (llvm::Type *)(v7 >> 8), a1, a2, (unint64_t)a3, v8);
}

unint64_t *llvm::GlobalAlias::create(const char **this, const llvm::Twine *a2, llvm::GlobalValue *a3)
{
  int v5 = *((_DWORD *)a2 + 8);
  uint64_t v6 = (llvm::PointerType *)*((void *)a2 + 3);
  unsigned int v7 = *(_DWORD *)(*(void *)a2 + 8);
  uint64_t v8 = *((void *)a2 + 5);
  long long v9 = (char *)operator new(0x60uLL);
  *((_DWORD *)v9 + 13) = *((_DWORD *)v9 + 13) & 0x38000000 | 1;
  *(void *)long long v9 = 0;
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 3) = v9 + 32;
  BOOL v10 = (unint64_t *)(v9 + 32);

  return llvm::GlobalAlias::GlobalAlias(v10, v6, (llvm::Type *)(v7 >> 8), v5 & 0xF, this, (unint64_t)a2, v8);
}

unint64_t *llvm::GlobalIFunc::GlobalIFunc(unint64_t *a1, llvm::PointerType *a2, llvm::Type *a3, char a4, const char **a5, unint64_t a6, uint64_t a7)
{
  BOOL v10 = sub_1CC5BF0A8(a1, a2, 2, a4, a5, a3);
  char v11 = v10 - 4;
  uint64_t v12 = *(v10 - 4);
  v10[6] = 0;
  _OWORD v10[7] = 0;
  *((_DWORD *)v10 + sub_1CD521E44((uint64_t)this + 8) = *((unsigned __int16 *)v10 + 16);
  char v10[8] = 0;
  if (v12)
  {
    *(void *)*(a1 - 2) = *(a1 - 3);
    uint64_t v13 = *(a1 - 3);
    if (v13) {
      *(void *)(v13 + 16) = *(a1 - 2);
    }
  }
  *char v11 = a6;
  if (a6)
  {
    unint64_t v16 = *(void *)(a6 + 8);
    std::string v15 = (unint64_t **)(a6 + 8);
    unint64_t v14 = v16;
    *(a1 - 3) = v16;
    if (v16) {
      *(void *)(v14 + 16) = a1 - 3;
    }
    *(a1 - 2) = (unint64_t)v15;
    *std::string v15 = v11;
  }
  if (a7) {
    llvm::SymbolTableListTraits<llvm::GlobalIFunc>::addNodeToList();
  }
  return a1;
}

unint64_t *llvm::GlobalIFunc::create(llvm::PointerType *a1, llvm::Type *a2, char a3, const char **a4, unint64_t a5, uint64_t a6)
{
  uint64_t v12 = (char *)operator new(0x68uLL);
  *((_DWORD *)v12 + 13) = *((_DWORD *)v12 + 13) & 0x38000000 | 1;
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  *((void *)v12 + 3) = v12 + 32;
  uint64_t v13 = (unint64_t *)(v12 + 32);

  return llvm::GlobalIFunc::GlobalIFunc(v13, a1, a2, a3, a4, a5, a6);
}

void sub_1CD5C1338()
{
}

uint64_t llvm::GlobalIFunc::getResolverFunction(llvm::GlobalIFunc *this)
{
  v4[0] = 0;
  v4[1] = 0;
  int v5 = 0;
  uint64_t v1 = sub_1CC5BE54C(*((void *)this - 4), (uint64_t)v4);
  if (*(unsigned char *)(v1 + 16)) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = v1;
  }
  MEMORY[0x1D25D9CD0](v4[0], 8);
  return v2;
}

void sub_1CD5C13F0(llvm::Value *a1)
{
  if (a1)
  {
    llvm::Constant::removeDeadConstantUsers((uint64_t)a1);
    llvm::Value::~Value(a1, v2);
    llvm::User::operator delete(v3);
  }
}

char *llvm::IRBuilderBase::CreateGlobalString(uint64_t a1, char *a2, llvm::Type *a3, const char **a4, unsigned int a5, uint64_t a6)
{
  String = (llvm::PointerType **)llvm::ConstantDataArray::getString(*(void *)(a1 + 64), a2, a3, 1);
  if (!a6) {
    a6 = *(void *)(*(void *)(*(void *)(a1 + 48) + 56) + 40);
  }
  char v11 = (char *)operator new(0x78uLL);
  *((_DWORD *)v11 + 13) = *((_DWORD *)v11 + 13) & 0x38000000 | 1;
  *(void *)char v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *((void *)v11 + 3) = v11 + 32;
  uint64_t v12 = llvm::GlobalVariable::GlobalVariable((unint64_t *)v11 + 4, a6, *String, 1, 8, (unint64_t)String, a4, 0, 0, (llvm::Type *)(a5 | 0x100000000), 0);
  *((_DWORD *)v11 + 16) = *((_DWORD *)v11 + 16) & 0xFFFFFF3F | 0x80;
  llvm::GlobalObject::setAlignment((uint64_t)v12, 256);
  return v11 + 32;
}

llvm::Instruction *llvm::IRBuilderBase::CreateVScale(llvm::IRBuilderBase *this, llvm::Constant *a2, const llvm::Twine *a3)
{
  int v4 = a2;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (void **)((char *)a2 + 24);
  unsigned int v7 = *((_DWORD *)a2 + 8);
  if (v7 > 0x40)
  {
    if (llvm::APInt::countLeadingZerosSlowCase((llvm::Constant *)((char *)a2 + 24)) == v7) {
      return v4;
    }
  }
  else if (!*v6)
  {
    return v4;
  }
  uint64_t v8 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v15[0] = *(void *)v4;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v8, 382, (uint64_t)v15, 1);
  if (Declaration) {
    BOOL v10 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    BOOL v10 = 0;
  }
  uint64_t v11 = sub_1CC233B6C((uint64_t *)this, v10, (uint64_t **)Declaration, 0, 0, 0, 0, (uint64_t)a3, 0);
  unsigned int v12 = *((_DWORD *)v4 + 8);
  if (v12 > 0x40) {
    uint64_t v13 = **v6;
  }
  else {
    uint64_t v13 = (uint64_t)((void)*v6 << -(char)v12) >> -(char)v12;
  }
  if (v13 != 1)
  {
    __int16 v16 = 257;
    return sub_1CC09A1EC((uint64_t)this, v11, (uint64_t)v4, (uint64_t)v15, 0, 0);
  }
  return (llvm::Instruction *)v11;
}

llvm::Instruction *llvm::IRBuilderBase::CreateStepVector(llvm::IRBuilderBase *this, llvm::Type ***a2, const llvm::Twine *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (llvm::Type *)a2;
  if ((a2[1] & 0xFE) == 0x12) {
    uint64_t v6 = *a2[2];
  }
  if (*((_DWORD *)a2 + 2) == 19)
  {
    if ((*((_DWORD *)v6 + 2) & 0xFE) == 0x12) {
      uint64_t v6 = (llvm::Type *)**((void **)v6 + 2);
    }
    unsigned int v7 = (llvm::Type *)a2;
    if ((llvm::Type::getPrimitiveSizeInBits(v6) & 0xFFFFFFF8) == 0)
    {
      llvm::VectorType::get((llvm::FixedVectorType *)(**((void **)this + 8) + 1912), (llvm::Type *)(*((unsigned int *)a2 + 8) | 0x100000000));
      unsigned int v7 = v8;
    }
    __int16 v16 = v7;
    uint64_t Intrinsic = llvm::IRBuilderBase::CreateIntrinsic((uint64_t *)this, 130, (uint64_t)&v16, 1, 0, 0, 0, (uint64_t)a3);
    if (v7 != (llvm::Type *)a2)
    {
      v18[8] = 257;
      return sub_1CB84580C((uint64_t)this, 38, Intrinsic, (uint64_t)a2, (uint64_t)&v16);
    }
  }
  else
  {
    uint64_t v10 = *((unsigned int *)a2 + 8);
    __int16 v16 = v18;
    uint64_t v17 = 0x800000000;
    if (v10)
    {
      for (unint64_t i = 0; i != v10; ++i)
      {
        unsigned int v12 = llvm::ConstantInt::get(v6, i, 0);
        if (v17 >= (unint64_t)HIDWORD(v17)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v16 + v17) = v12;
        uint64_t v13 = (llvm::Type *)(v17 + 1);
        LODWORD(v17) = v17 + 1;
      }
      unint64_t v14 = (llvm::FixedVectorType ***)v16;
    }
    else
    {
      uint64_t v13 = 0;
      unint64_t v14 = (llvm::FixedVectorType ***)v18;
    }
    uint64_t Intrinsic = (uint64_t)llvm::ConstantVector::get(v14, v13);
    if (v16 != v18) {
      free(v16);
    }
  }
  return (llvm::Instruction *)Intrinsic;
}

uint64_t ***llvm::IRBuilderBase::CreateMemCpyInline(uint64_t a1, llvm::Value *a2, __int16 a3, llvm::Value *a4, __int16 a5, void *a6, unsigned int a7, llvm::MDNode *a8, llvm::MDNode *a9, llvm::MDNode *a10, llvm::MDNode *a11)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  CastedInt8PtrValue = llvm::IRBuilderBase::getCastedInt8PtrValue((llvm::IRBuilderBase *)a1, a2);
  unsigned int v28 = llvm::IRBuilderBase::getCastedInt8PtrValue((llvm::IRBuilderBase *)a1, a4);
  int v29 = a6;
  unint64_t v30 = llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1888), a7, 0);
  v26[0] = *(void *)CastedInt8PtrValue;
  uint64_t v18 = *a6;
  v26[1] = *(void *)v28;
  uint64_t v26[2] = v18;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(*(uint64_t ***)(*(void *)(*(void *)(a1 + 48) + 56) + 40), 196, (uint64_t)v26, 3);
  __int16 v25 = 257;
  if (Declaration) {
    uint64_t v20 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = sub_1CC233B6C((uint64_t *)a1, v20, (uint64_t **)Declaration, (uint64_t *)&CastedInt8PtrValue, 4, 0, 0, (uint64_t)v24, 0);
  unint64_t v22 = (uint64_t ***)v21;
  if ((a3 & 0xFF00) != 0) {
    sub_1CC27C328(v21, a3);
  }
  if ((a5 & 0xFF00) != 0) {
    sub_1CC27C3B8((uint64_t)v22, a5);
  }
  if (a8) {
    llvm::Value::setMetadata(v22, 1, a8);
  }
  if (a9) {
    llvm::Value::setMetadata(v22, 5, a9);
  }
  if (a10) {
    llvm::Value::setMetadata(v22, 7, a10);
  }
  if (a11) {
    llvm::Value::setMetadata(v22, 8, a11);
  }
  return v22;
}

uint64_t ***llvm::IRBuilderBase::CreateElementUnorderedAtomicMemCpy(uint64_t a1, llvm::Value *a2, char a3, llvm::Value *a4, char a5, void *a6, unsigned int a7, llvm::MDNode *a8, llvm::MDNode *a9, llvm::MDNode *a10, llvm::MDNode *a11)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CastedInt8PtrValue = llvm::IRBuilderBase::getCastedInt8PtrValue((llvm::IRBuilderBase *)a1, a2);
  unint64_t v27 = llvm::IRBuilderBase::getCastedInt8PtrValue((llvm::IRBuilderBase *)a1, a4);
  unsigned int v28 = a6;
  int v29 = llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), a7, 0);
  v25[0] = *(void *)CastedInt8PtrValue;
  uint64_t v18 = *a6;
  v25[1] = *(void *)v27;
  void v25[2] = v18;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(*(uint64_t ***)(*(void *)(*(void *)(a1 + 48) + 56) + 40), 195, (uint64_t)v25, 3);
  __int16 v24 = 257;
  if (Declaration) {
    uint64_t v20 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t v21 = (uint64_t ***)sub_1CC233B6C((uint64_t *)a1, v20, (uint64_t **)Declaration, (uint64_t *)&CastedInt8PtrValue, 4, 0, 0, (uint64_t)v23, 0);
  sub_1CC27C328((uint64_t)v21, a3);
  sub_1CC27C3B8((uint64_t)v21, a5);
  if (a8) {
    llvm::Value::setMetadata(v21, 1, a8);
  }
  if (a9) {
    llvm::Value::setMetadata(v21, 5, a9);
  }
  if (a10) {
    llvm::Value::setMetadata(v21, 7, a10);
  }
  if (a11) {
    llvm::Value::setMetadata(v21, 8, a11);
  }
  return v21;
}

uint64_t ***llvm::IRBuilderBase::CreateMemMove(uint64_t a1, llvm::Value *a2, __int16 a3, llvm::Value *a4, __int16 a5, void *a6, unsigned int a7, llvm::MDNode *a8, llvm::MDNode *a9, llvm::MDNode *a10)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  CastedInt8PtrValue = llvm::IRBuilderBase::getCastedInt8PtrValue((llvm::IRBuilderBase *)a1, a2);
  unint64_t v27 = llvm::IRBuilderBase::getCastedInt8PtrValue((llvm::IRBuilderBase *)a1, a4);
  unsigned int v28 = a6;
  int v29 = llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1888), a7, 0);
  v25[0] = *(void *)CastedInt8PtrValue;
  uint64_t v17 = *a6;
  v25[1] = *(void *)v27;
  void v25[2] = v17;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(*(uint64_t ***)(*(void *)(*(void *)(a1 + 48) + 56) + 40), 197, (uint64_t)v25, 3);
  __int16 v24 = 257;
  if (Declaration) {
    uint64_t v19 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = sub_1CC233B6C((uint64_t *)a1, v19, (uint64_t **)Declaration, (uint64_t *)&CastedInt8PtrValue, 4, 0, 0, (uint64_t)v23, 0);
  uint64_t v21 = (uint64_t ***)v20;
  if ((a3 & 0xFF00) != 0) {
    sub_1CC27C328(v20, a3);
  }
  if ((a5 & 0xFF00) != 0) {
    sub_1CC27C3B8((uint64_t)v21, a5);
  }
  if (a8) {
    llvm::Value::setMetadata(v21, 1, a8);
  }
  if (a9) {
    llvm::Value::setMetadata(v21, 7, a9);
  }
  if (a10) {
    llvm::Value::setMetadata(v21, 8, a10);
  }
  return v21;
}

uint64_t llvm::IRBuilderBase::CreateFAddReduce(llvm::IRBuilderBase *this, llvm::Value *a2, llvm::Value *a3)
{
  void v10[2] = *MEMORY[0x1E4F143B8];
  int v4 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v10[0] = (uint64_t)a2;
  v10[1] = (uint64_t)a3;
  v8[0] = *(void *)a3;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v4, 319, (uint64_t)v8, 1);
  __int16 v9 = 257;
  if (Declaration) {
    uint64_t v6 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v6 = 0;
  }
  return sub_1CC233B6C((uint64_t *)this, v6, (uint64_t **)Declaration, v10, 2, 0, 0, (uint64_t)v8, 0);
}

uint64_t llvm::IRBuilderBase::CreateFMulReduce(llvm::IRBuilderBase *this, llvm::Value *a2, llvm::Value *a3)
{
  void v10[2] = *MEMORY[0x1E4F143B8];
  int v4 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v10[0] = (uint64_t)a2;
  v10[1] = (uint64_t)a3;
  v8[0] = *(void *)a3;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v4, 322, (uint64_t)v8, 1);
  __int16 v9 = 257;
  if (Declaration) {
    uint64_t v6 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v6 = 0;
  }
  return sub_1CC233B6C((uint64_t *)this, v6, (uint64_t **)Declaration, v10, 2, 0, 0, (uint64_t)v8, 0);
}

uint64_t llvm::IRBuilderBase::CreateAddReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 317, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateMulReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 323, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateAndReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 318, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateOrReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 324, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateXorReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 329, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateIntMaxReduce(llvm::IRBuilderBase *this, llvm::Value *a2, int a3)
{
  if (a3) {
    int v4 = 325;
  }
  else {
    int v4 = 327;
  }
  return sub_1CC5C0444((uint64_t *)this, v4, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateIntMinReduce(llvm::IRBuilderBase *this, llvm::Value *a2, int a3)
{
  if (a3) {
    int v4 = 326;
  }
  else {
    int v4 = 328;
  }
  return sub_1CC5C0444((uint64_t *)this, v4, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateFPMaxReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 320, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateFPMinReduce(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  return sub_1CC5C0444((uint64_t *)this, 321, (uint64_t *)a2);
}

uint64_t llvm::IRBuilderBase::CreateAssumption(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  v12[0] = a2;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(*(uint64_t ***)(*(void *)(a1[6] + 56) + 40), 7, 0, 0);
  __int16 v11 = 257;
  if (Declaration) {
    uint64_t v8 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v8 = 0;
  }
  return sub_1CC233B6C(a1, v8, (uint64_t **)Declaration, v12, 1, a3, a4, (uint64_t)v10, 0);
}

uint64_t llvm::IRBuilderBase::CreateMaskedLoad(uint64_t a1, llvm::UndefValue *this, uint64_t *a3, char a4, uint64_t a5, llvm::UndefValue *a6, uint64_t a7)
{
  uint64_t v8 = a6;
  void v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *a3;
  if (!a6) {
    uint64_t v8 = llvm::UndefValue::get(this, this);
  }
  v17[0] = this;
  v17[1] = v14;
  v16[0] = (uint64_t)a3;
  v16[1] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), (1 << a4), 0);
  void v16[2] = a5;
  v16[3] = (uint64_t)v8;
  return llvm::IRBuilderBase::CreateMaskedIntrinsic((uint64_t *)a1, 185, v16, 4, (uint64_t)v17, 2, a7);
}

uint64_t llvm::IRBuilderBase::CreateMaskedIntrinsic(uint64_t *a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(*(uint64_t ***)(*(void *)(a1[6] + 56) + 40), a2, a5, a6);
  if (Declaration) {
    unsigned int v12 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    unsigned int v12 = 0;
  }
  return sub_1CC233B6C(a1, v12, (uint64_t **)Declaration, a3, a4, 0, 0, a7, 0);
}

uint64_t llvm::IRBuilderBase::CreateMaskedStore(uint64_t a1, void *a2, uint64_t *a3, char a4, uint64_t a5)
{
  void v11[2] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a3;
  v11[0] = *a2;
  v11[1] = v7;
  v10[0] = (uint64_t)a2;
  v10[1] = (uint64_t)a3;
  void v10[2] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), (1 << a4), 0);
  uint64_t v10[3] = a5;
  v9[16] = 257;
  return llvm::IRBuilderBase::CreateMaskedIntrinsic((uint64_t *)a1, 187, v10, 4, (uint64_t)v11, 2, (uint64_t)v9);
}

uint64_t llvm::IRBuilderBase::CreateMaskedGather(uint64_t a1, llvm::UndefValue *this, uint64_t *a3, char a4, void *a5, llvm::UndefValue *a6, uint64_t a7)
{
  AllOnesValue = a5;
  void v20[2] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *a3;
  if (!a5)
  {
    llvm::VectorType::get((llvm::FixedVectorType *)(**(void **)(a1 + 64) + 1888), (llvm::Type *)(*((unsigned int *)this + 8) | ((unint64_t)(*((unsigned char *)this + 8) == 19) << 32)));
    AllOnesValue = llvm::Constant::getAllOnesValue(v15, v16, v17);
  }
  if (!a6) {
    a6 = llvm::UndefValue::get(this, this);
  }
  v20[0] = this;
  v20[1] = v14;
  v19[0] = (uint64_t)a3;
  v19[1] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), (1 << a4), 0);
  v19[2] = (uint64_t)AllOnesValue;
  v19[3] = (uint64_t)a6;
  return llvm::IRBuilderBase::CreateMaskedIntrinsic((uint64_t *)a1, 184, v19, 4, (uint64_t)v20, 2, a7);
}

uint64_t llvm::IRBuilderBase::CreateMaskedScatter(uint64_t a1, uint64_t *a2, uint64_t *a3, char a4, void *a5)
{
  AllOnesValue = a5;
  _OWORD v18[2] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a3;
  uint64_t v11 = *a2;
  if (!a5)
  {
    llvm::VectorType::get((llvm::FixedVectorType *)(**(void **)(a1 + 64) + 1888), (llvm::Type *)(*(unsigned int *)(v10 + 32) | ((unint64_t)(*(unsigned char *)(v10 + 8) == 19) << 32)));
    AllOnesValue = llvm::Constant::getAllOnesValue(v12, v13, v14);
  }
  v18[0] = v11;
  v18[1] = v10;
  v17[0] = (uint64_t)a2;
  v17[1] = (uint64_t)a3;
  void v17[2] = (uint64_t)llvm::ConstantInt::get((llvm::ConstantInt *)(**(void **)(a1 + 64) + 1960), (1 << a4), 0);
  void v17[3] = (uint64_t)AllOnesValue;
  v16[16] = 257;
  return llvm::IRBuilderBase::CreateMaskedIntrinsic((uint64_t *)a1, 186, v17, 4, (uint64_t)v18, 2, (uint64_t)v16);
}

uint64_t llvm::IRBuilderBase::CreateGCStatepointCall(uint64_t a1, uint64_t a2, const llvm::APInt *a3, uint64_t a4, char **a5, unsigned int a6, char *a7, uint64_t a8, long long *a9, long long *a10, uint64_t *a11, uint64_t a12, uint64_t a13)
{
  v39[3] = *(char **)MEMORY[0x1E4F143B8];
  long long v31 = *a9;
  uint64_t v32 = *((void *)a9 + 2);
  long long v29 = *a10;
  uint64_t v30 = *((void *)a10 + 2);
  uint64_t v20 = *(uint64_t ***)(*(void *)(*(void *)(a1 + 48) + 56) + 40);
  v39[0] = *a5;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v20, 124, (uint64_t)v39, 1);
  sub_1CC5C2D38(a1, a2, a3, (uint64_t)a5, a6, a7, a8, v39);
  if (Declaration) {
    unint64_t v22 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    unint64_t v22 = 0;
  }
  uint64_t v23 = (uint64_t *)v39[0];
  int64_t v24 = (v39[1] - v39[0]) >> 3;
  long long v35 = v31;
  uint64_t v36 = v32;
  long long v33 = v29;
  uint64_t v34 = v30;
  sub_1CC5C3C30(a11, (uint64_t)&v35, (uint64_t)&v33, a12, v37);
  uint64_t v25 = sub_1CC233B6C((uint64_t *)a1, v22, (uint64_t **)Declaration, v23, v24, v37[0], 0xAAAAAAAAAAAAAAABLL * ((v37[1] - v37[0]) >> 4), a13, 0);
  unint64_t v38 = (void **)v37;
  sub_1CC1E47CC(&v38);
  unint64_t v26 = llvm::Attribute::get(*(uint64_t **)(a1 + 64), 70, a4);
  LODWORD(v37[0]) = 2;
  *(void *)(v25 + 64) = llvm::AttributeList::addParamAttribute((void *)(v25 + 64), **(uint64_t ***)v25, v37, 1, v26);
  if (v23) {
    operator delete(v23);
  }
  return v25;
}

llvm::Instruction *llvm::IRBuilderBase::CreateGCStatepointInvoke(uint64_t a1, uint64_t a2, const llvm::APInt *a3, uint64_t a4, char **a5, uint64_t a6, uint64_t a7, unsigned int a8, char *a9, uint64_t a10, long long *a11, long long *a12, uint64_t *a13, uint64_t a14, uint64_t a15)
{
  v42[3] = *(char **)MEMORY[0x1E4F143B8];
  long long v34 = *a11;
  uint64_t v35 = *((void *)a11 + 2);
  long long v32 = *a12;
  uint64_t v33 = *((void *)a12 + 2);
  uint64_t v20 = *(uint64_t ***)(*(void *)(*(void *)(a1 + 48) + 56) + 40);
  v42[0] = *a5;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v20, 124, (uint64_t)v42, 1);
  sub_1CC5C2D38(a1, a2, a3, (uint64_t)a5, a8, a9, a10, v42);
  if (Declaration) {
    uint64_t v22 = *(void *)(Declaration + 24);
  }
  else {
    uint64_t v22 = 0;
  }
  uint64_t v23 = (uint64_t *)v42[0];
  int64_t v24 = (v42[1] - v42[0]) >> 3;
  long long v38 = v34;
  uint64_t v39 = v35;
  long long v36 = v32;
  uint64_t v37 = v33;
  sub_1CC5C3C30(a13, (uint64_t)&v38, (uint64_t)&v36, a14, v40);
  unint64_t v26 = sub_1CD5C4DB8(a1, v22, Declaration, a6, a7, v23, v24, v25, v40[0], 0xAAAAAAAAAAAAAAABLL * ((v40[1] - v40[0]) >> 4), a15);
  unint64_t v41 = (void **)v40;
  sub_1CC1E47CC(&v41);
  unint64_t v27 = llvm::Attribute::get(*(uint64_t **)(a1 + 64), 70, a4);
  LODWORD(v40[0]) = 2;
  *((void *)v26 + sub_1CD521E44((uint64_t)this + 8) = llvm::AttributeList::addParamAttribute((void *)v26 + 8, **(uint64_t ***)v26, v40, 1, v27);
  if (v23) {
    operator delete(v23);
  }
  return v26;
}

uint64_t llvm::IRBuilderBase::CreateGCResult(llvm::IRBuilderBase *this, llvm::Instruction *a2, llvm::Type *a3, const llvm::Twine *a4)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v12[0] = a3;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v7, 123, (uint64_t)v12, 1);
  uint64_t v11 = a2;
  if (Declaration) {
    __int16 v9 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    __int16 v9 = 0;
  }
  return sub_1CC233B6C((uint64_t *)this, v9, (uint64_t **)Declaration, (uint64_t *)&v11, 1, 0, 0, (uint64_t)a4, 0);
}

uint64_t llvm::IRBuilderBase::CreateConstrainedFPBinOp(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, llvm::Instruction *a5, uint64_t a6, llvm::MDNode *a7, __int16 a8, __int16 a9)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = sub_1CD5C2A3C(a1, a8);
  uint64_t v17 = sub_1CD5C2A94(a1, a9);
  if (a5) {
    LOBYTE(a5) = llvm::Instruction::getFastMathFlags(a5);
  }
  else {
    LODWORD(a5) = *(_DWORD *)(a1 + 96);
  }
  uint64_t v18 = *a3;
  v21[3] = v17;
  v22[0] = v18;
  v21[0] = (uint64_t)a3;
  v21[1] = a4;
  unsigned int v21[2] = v16;
  uint64_t Intrinsic = llvm::IRBuilderBase::CreateIntrinsic((uint64_t *)a1, a2, (uint64_t)v22, 1, v21, 4, 0, a6);
  *(void *)(Intrinsic + 64) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(Intrinsic + 64), **(uint64_t ***)Intrinsic, -1, 61);
  if (a7 || (a7 = *(llvm::MDNode **)(a1 + 88)) != 0) {
    llvm::Value::setMetadata((uint64_t ***)Intrinsic, 3, a7);
  }
  *(unsigned char *)(Intrinsic + 17) |= 2 * (_BYTE)a5;
  return Intrinsic;
}

uint64_t sub_1CD5C2A3C(uint64_t a1, __int16 a2)
{
  char v3 = *(unsigned char *)(a1 + 102);
  if ((a2 & 0xFF00) != 0) {
    char v3 = a2;
  }
  llvm::convertRoundingModeToStr(v3, (uint64_t)v6);
  int v4 = (unsigned __int8 *)llvm::MDString::get(*(uint64_t **)(a1 + 64), v6[0], (size_t)v6[1]);
  return llvm::MetadataAsValue::get(*(void *)(a1 + 64), v4);
}

uint64_t sub_1CD5C2A94(uint64_t a1, __int16 a2)
{
  unsigned __int8 v3 = *(unsigned char *)(a1 + 101);
  if ((a2 & 0xFF00) != 0) {
    unsigned __int8 v3 = a2;
  }
  llvm::convertExceptionBehaviorToStr(v3, (uint64_t)v6);
  int v4 = (unsigned __int8 *)llvm::MDString::get(*(uint64_t **)(a1 + 64), v6[0], (size_t)v6[1]);
  return llvm::MetadataAsValue::get(*(void *)(a1 + 64), v4);
}

llvm::Instruction *llvm::IRBuilderBase::CreateNAryOp(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, llvm::MDNode *a6)
{
  if ((a2 - 13) > 0x11) {
    return sub_1CD5C2B18(a1, 12, *a3, a5, a6);
  }
  else {
    return sub_1CB844E98(a1, a2, *a3, a3[1], a5, a6);
  }
}

llvm::Instruction *sub_1CD5C2B18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, llvm::MDNode *a5)
{
  if (!a3 || *(unsigned __int8 *)(a3 + 16) > 0x14u)
  {
    __int16 v14 = 257;
    uint64_t v11 = llvm::UnaryOperator::Create(a2, (uint64_t *)a3, &v13, 0);
    if (sub_1CB845E74((uint64_t)v11))
    {
      int v12 = *(_DWORD *)(a1 + 96);
      if (a5 || (a5 = *(llvm::MDNode **)(a1 + 88)) != 0) {
        llvm::Value::setMetadata((uint64_t ***)v11, 3, a5);
      }
      *((unsigned char *)v11 + 17) |= 2 * (_BYTE)v12;
    }
    return sub_1CB844E0C((uint64_t *)a1, v11, a4);
  }
  uint64_t v8 = (unsigned __int8 *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 72) + 216))(*(void *)(a1 + 72), a2, a3);
  if (v8) {
    BOOL v9 = v8[16] >= 0x1Cu;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9) {
    return (llvm::Instruction *)v8;
  }

  return sub_1CB844E0C((uint64_t *)a1, (llvm::Instruction *)v8, a4);
}

uint64_t llvm::IRBuilderBase::CreateConstrainedFPCast(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4, llvm::Instruction *a5, uint64_t a6, llvm::MDNode *a7, __int16 a8, __int16 a9)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = sub_1CD5C2A94(a1, a9);
  if (a5) {
    LOBYTE(a5) = llvm::Instruction::getFastMathFlags(a5);
  }
  else {
    LODWORD(a5) = *(_DWORD *)(a1 + 96);
  }
  if ((a2 - 80) <= 0x26 && ((1 << (a2 - 80)) & 0x5CF07BC74FLL) != 0)
  {
    uint64_t v18 = sub_1CD5C2A3C(a1, a8);
    uint64_t v19 = *a3;
    long long v31 = a4;
    uint64_t v32 = v19;
    unsigned int v28 = a3;
    uint64_t v29 = v18;
    uint64_t v30 = v17;
    uint64_t v20 = &v31;
    uint64_t v21 = (uint64_t *)&v28;
    uint64_t v22 = (uint64_t *)a1;
    int v23 = a2;
    uint64_t v24 = 3;
  }
  else
  {
    uint64_t v27 = *a3;
    unsigned int v28 = a4;
    uint64_t v29 = v27;
    long long v31 = a3;
    uint64_t v32 = v17;
    uint64_t v20 = &v28;
    uint64_t v21 = (uint64_t *)&v31;
    uint64_t v22 = (uint64_t *)a1;
    int v23 = a2;
    uint64_t v24 = 2;
  }
  uint64_t Intrinsic = llvm::IRBuilderBase::CreateIntrinsic(v22, v23, (uint64_t)v20, 2, v21, v24, 0, a6);
  *(void *)(Intrinsic + 64) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(Intrinsic + 64), **(uint64_t ***)Intrinsic, -1, 61);
  if (sub_1CB845E74(Intrinsic))
  {
    if (a7 || (a7 = *(llvm::MDNode **)(a1 + 88)) != 0) {
      llvm::Value::setMetadata((uint64_t ***)Intrinsic, 3, a7);
    }
    *(unsigned char *)(Intrinsic + 17) |= 2 * (_BYTE)a5;
  }
  return Intrinsic;
}

uint64_t llvm::IRBuilderBase::CreateConstrainedFPCmp(uint64_t a1, int a2, unsigned int a3, uint64_t *a4, uint64_t a5, uint64_t a6, __int16 a7)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  PredicateName = (unsigned __int8 *)llvm::CmpInst::getPredicateName(a3);
  std::string v15 = (unsigned __int8 *)llvm::MDString::get(*(uint64_t **)(a1 + 64), PredicateName, v14);
  uint64_t v16 = llvm::MetadataAsValue::get(*(void *)(a1 + 64), v15);
  uint64_t v17 = sub_1CD5C2A94(a1, a7);
  uint64_t v18 = *a4;
  v21[3] = v17;
  v22[0] = v18;
  v21[0] = (uint64_t)a4;
  v21[1] = a5;
  unsigned int v21[2] = v16;
  uint64_t Intrinsic = llvm::IRBuilderBase::CreateIntrinsic((uint64_t *)a1, a2, (uint64_t)v22, 1, v21, 4, 0, a6);
  *(void *)(Intrinsic + 64) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(Intrinsic + 64), **(uint64_t ***)Intrinsic, -1, 61);
  return Intrinsic;
}

uint64_t llvm::IRBuilderBase::CreateConstrainedFPCall(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, __int16 a6, __int16 a7)
{
  v22[6] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x600000000;
  sub_1CD5C4AF8((unsigned int *)&v20, (uint64_t)v22, a3, &a3[a4]);
  unsigned int v12 = *(_DWORD *)(a2 + 36) - 80;
  BOOL v13 = v12 > 0x26;
  uint64_t v14 = (1 << v12) & 0x5CF07BC74FLL;
  if (!v13 && v14 != 0)
  {
    uint64_t v16 = sub_1CD5C2A3C((uint64_t)a1, a6);
    if (v21 >= HIDWORD(v21)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v20 + v21) = v16;
    LODWORD(v21) = v21 + 1;
  }
  uint64_t v17 = sub_1CD5C2A94((uint64_t)a1, a7);
  if (v21 >= HIDWORD(v21)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v20 + v21) = v17;
  LODWORD(v21) = v21 + 1;
  uint64_t v18 = sub_1CB845BAC(a1, *(uint64_t ***)(a2 + 24), (uint64_t **)a2, (uint64_t *)v20, v21, a5, 0);
  *(void *)(v18 + 64) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v18 + 64), **(uint64_t ***)v18, -1, 61);
  if (v20 != v22) {
    free(v20);
  }
  return v18;
}

llvm::Instruction *llvm::IRBuilderBase::CreatePtrDiff(llvm::IRBuilderBase *this, llvm::Type *a2, llvm::Value *a3, llvm::Value *a4, const llvm::Twine *a5)
{
  uint64_t v9 = **((void **)this + 8) + 1984;
  __int16 v18 = 257;
  uint64_t v10 = sub_1CB84580C((uint64_t)this, 47, (uint64_t)a3, v9, (uint64_t)v17);
  uint64_t v11 = **((void **)this + 8) + 1984;
  __int16 v18 = 257;
  unsigned int v12 = sub_1CB84580C((uint64_t)this, 47, (uint64_t)a4, v11, (uint64_t)v17);
  __int16 v18 = 257;
  BOOL v13 = sub_1CB84494C((uint64_t)this, (uint64_t)v10, (uint64_t)v12, (uint64_t)v17, 0, 0);
  SizeOf = llvm::ConstantExpr::getSizeOf(a2, v14);
  return sub_1CC57DBF8((uint64_t)this, (uint64_t)v13, (uint64_t)SizeOf, (uint64_t)a5, 1);
}

llvm::Instruction *llvm::IRBuilderBase::CreateLaunderInvariantGroup(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  uint64_t v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a2;
  unsigned int v5 = *(_DWORD *)(*(void *)a2 + 8);
  if ((v5 & 0xFE) == 0x12) {
    unsigned int v5 = *(_DWORD *)(**(void **)(v4 + 16) + 8);
  }
  unint64_t v6 = llvm::PointerType::get((llvm::PointerType *)(**((void **)this + 8) + 1912), (llvm::Type *)(v5 >> 8));
  if (v4 != v6)
  {
    __int16 v14 = 257;
    uint64_t v2 = sub_1CB84580C((uint64_t)this, 49, (uint64_t)v2, v6, (uint64_t)v13);
  }
  uint64_t v7 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v13[0] = v6;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v7, 166, (uint64_t)v13, 1);
  if (Declaration) {
    uint64_t v9 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v9 = 0;
  }
  unsigned int v12 = v2;
  __int16 v14 = 257;
  uint64_t v10 = sub_1CB845BAC((uint64_t *)this, v9, (uint64_t **)Declaration, (uint64_t *)&v12, 1, (uint64_t)v13, 0);
  if (v4 != v6)
  {
    __int16 v14 = 257;
    return sub_1CB84580C((uint64_t)this, 49, v10, v4, (uint64_t)v13);
  }
  return (llvm::Instruction *)v10;
}

llvm::Instruction *llvm::IRBuilderBase::CreateStripInvariantGroup(llvm::IRBuilderBase *this, llvm::Value *a2)
{
  uint64_t v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)a2;
  unsigned int v5 = *(_DWORD *)(*(void *)a2 + 8);
  if ((v5 & 0xFE) == 0x12) {
    unsigned int v5 = *(_DWORD *)(**(void **)(v4 + 16) + 8);
  }
  unint64_t v6 = llvm::PointerType::get((llvm::PointerType *)(**((void **)this + 8) + 1912), (llvm::Type *)(v5 >> 8));
  if (v4 != v6)
  {
    __int16 v14 = 257;
    uint64_t v2 = sub_1CB84580C((uint64_t)this, 49, (uint64_t)v2, v6, (uint64_t)v13);
  }
  uint64_t v7 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v13[0] = v6;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v7, 290, (uint64_t)v13, 1);
  if (Declaration) {
    uint64_t v9 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v9 = 0;
  }
  unsigned int v12 = v2;
  __int16 v14 = 257;
  uint64_t v10 = sub_1CB845BAC((uint64_t *)this, v9, (uint64_t **)Declaration, (uint64_t *)&v12, 1, (uint64_t)v13, 0);
  if (v4 != v6)
  {
    __int16 v14 = 257;
    return sub_1CB84580C((uint64_t)this, 49, v10, v4, (uint64_t)v13);
  }
  return (llvm::Instruction *)v10;
}

llvm::Instruction *llvm::IRBuilderBase::CreateVectorReverse(llvm::IRBuilderBase *this, void **a2, const llvm::Twine *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  __int16 v18 = a2;
  unsigned int v5 = (llvm::PoisonValue *)*a2;
  if (*((unsigned char *)*a2 + 8) == 19)
  {
    unint64_t v6 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
    uint64_t v19 = *a2;
    uint64_t Declaration = llvm::Intrinsic::getDeclaration(v6, 133, (uint64_t)&v19, 1);
    uint64_t v8 = (uint64_t **)Declaration;
    if (Declaration) {
      uint64_t Declaration = *(void *)(Declaration + 24);
    }
    char v21[8] = 257;
    uint64_t v9 = (llvm::Instruction *)sub_1CC19A3E0((uint64_t **)Declaration, v8, (uint64_t *)&v18, 1, 0, 0, (const char **)&v19, 0);
    return sub_1CB844E0C((uint64_t *)this, v9, (uint64_t)a3);
  }
  else
  {
    uint64_t v19 = v21;
    uint64_t v20 = 0x800000000;
    int v13 = *((_DWORD *)v5 + 8);
    int v14 = v13 - 1;
    if (v13 < 1)
    {
      uint64_t v15 = 0;
      uint64_t v16 = v21;
    }
    else
    {
      LODWORD(v15) = 0;
      do
      {
        if (v15 >= HIDWORD(v20)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v19 + v15) = v14;
        uint64_t v15 = (llvm::Type *)(v20 + 1);
        LODWORD(v2llvm::MDNode::dumpTree(this, 0) = v20 + 1;
        --v14;
      }
      while (v14 != -1);
      uint64_t v16 = v19;
      unsigned int v5 = (llvm::PoisonValue *)*a2;
    }
    uint64_t v17 = llvm::PoisonValue::get(v5, (llvm::Type *)a2);
    uint64_t v10 = sub_1CB935A74((uint64_t)this, (uint64_t)a2, (uint64_t)v17, v16, v15, (uint64_t)a3);
    if (v19 != v21) {
      free(v19);
    }
  }
  return v10;
}

uint64_t llvm::IRBuilderBase::CreatePreserveArrayAccessIndex(llvm::IRBuilderBase *this, llvm::Type *a2, llvm::Value *a3, unsigned int a4, llvm::IntegerType *a5, llvm::MDNode *a6)
{
  uint64_t v27[4] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)a3;
  unsigned int v12 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), a5, 0);
  int v13 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), 0, 0);
  uint64_t v25 = v27;
  uint64_t v26 = 0x400000000;
  sub_1CB91FBE0((uint64_t)&v25, a4, (uint64_t)v13);
  if (v26 >= HIDWORD(v26)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v25 + v26) = v12;
  LODWORD(v26) = v26 + 1;
  sub_1CB845A7C((uint64_t)a2, (uint64_t *)a3, (uint64_t)v25, v26);
  int v14 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v22[0] = v15;
  v22[1] = v11;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v14, 241, (uint64_t)v22, 2);
  uint64_t v17 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), a4, 0);
  if (Declaration) {
    __int16 v18 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    __int16 v18 = 0;
  }
  v24[0] = (uint64_t)a3;
  v24[1] = (uint64_t)v17;
  void v24[2] = (uint64_t)v12;
  __int16 v23 = 257;
  uint64_t v19 = sub_1CB845BAC((uint64_t *)this, v18, (uint64_t **)Declaration, v24, 3, (uint64_t)v22, 0);
  unint64_t v20 = llvm::Attribute::get(**(uint64_t ***)v19, 70, (uint64_t)a2);
  LODWORD(v22[0]) = 0;
  *(void *)(v19 + 64) = llvm::AttributeList::addParamAttribute((void *)(v19 + 64), **(uint64_t ***)v19, v22, 1, v20);
  if (a6) {
    llvm::Value::setMetadata((uint64_t ***)v19, 27, a6);
  }
  if (v25 != v27) {
    free(v25);
  }
  return v19;
}

uint64_t ***llvm::IRBuilderBase::CreatePreserveUnionAccessIndex(llvm::IRBuilderBase *this, llvm::Value *a2, unsigned int a3, llvm::MDNode *a4)
{
  void v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  v15[0] = *(void *)a2;
  v15[1] = v15[0];
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v8, 243, (uint64_t)v15, 2);
  uint64_t v10 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), a3, 0);
  if (Declaration) {
    uint64_t v11 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v11 = 0;
  }
  v17[0] = (uint64_t)a2;
  v17[1] = (uint64_t)v10;
  __int16 v16 = 257;
  unsigned int v12 = (uint64_t ***)sub_1CB845BAC((uint64_t *)this, v11, (uint64_t **)Declaration, v17, 2, (uint64_t)v15, 0);
  int v13 = v12;
  if (a4) {
    llvm::Value::setMetadata(v12, 27, a4);
  }
  return v13;
}

uint64_t llvm::IRBuilderBase::CreatePreserveStructAccessIndex(llvm::IRBuilderBase *this, llvm::Type *a2, llvm::Value *a3, llvm::IntegerType *a4, unsigned int a5, llvm::MDNode *a6)
{
  uint64_t v24[3] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *(void *)a3;
  unsigned int v12 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), a4, 0);
  uint64_t v21 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), 0, 0);
  uint64_t v22 = v12;
  sub_1CB845A7C((uint64_t)a2, (uint64_t *)a3, (uint64_t)&v21, 2);
  int v13 = *(uint64_t ***)(*(void *)(*((void *)this + 6) + 56) + 40);
  uint64_t v21 = v14;
  uint64_t v22 = (void *)v11;
  uint64_t Declaration = llvm::Intrinsic::getDeclaration(v13, 242, (uint64_t)&v21, 2);
  __int16 v16 = llvm::ConstantInt::get((llvm::ConstantInt *)(**((void **)this + 8) + 1960), a5, 0);
  if (Declaration) {
    uint64_t v17 = *(uint64_t ***)(Declaration + 24);
  }
  else {
    uint64_t v17 = 0;
  }
  v24[0] = (uint64_t)a3;
  v24[1] = (uint64_t)v12;
  void v24[2] = (uint64_t)v16;
  __int16 v23 = 257;
  uint64_t v18 = sub_1CB845BAC((uint64_t *)this, v17, (uint64_t **)Declaration, v24, 3, (uint64_t)&v21, 0);
  unint64_t v19 = llvm::Attribute::get(**(uint64_t ***)v18, 70, (uint64_t)a2);
  LODWORD(v21) = 0;
  *(void *)(v18 + 64) = llvm::AttributeList::addParamAttribute((void *)(v18 + 64), **(uint64_t ***)v18, &v21, 1, v19);
  if (a6) {
    llvm::Value::setMetadata((uint64_t ***)v18, 27, a6);
  }
  return v18;
}

uint64_t llvm::IRBuilderBase::CreateAlignmentAssumptionHelper(llvm::ConstantInt **this, const llvm::DataLayout *a2, llvm::Value *a3, llvm::Value *a4, llvm::Value *a5)
{
  void v20[4] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = v20;
  v20[0] = a3;
  v20[1] = a4;
  uint64_t v19 = 0x400000002;
  if (a5)
  {
    void v20[2] = a5;
    uint64_t v6 = 3;
    LODWORD(v19) = 3;
  }
  else
  {
    uint64_t v6 = 2;
  }
  *(void *)&long long v12 = 0x6E67696C61;
  char v13 = 5;
  std::string __p = operator new(8 * v6);
  __int16 v16 = (char *)__p + 8 * v6;
  memcpy(__p, v20, 8 * v6);
  uint64_t v15 = (char *)__p + 8 * v6;
  True = llvm::ConstantInt::getTrue(this[8], v7, v8);
  sub_1CD5C4920((uint64_t)v17, &v12);
  uint64_t Assumption = llvm::IRBuilderBase::CreateAssumption((uint64_t *)this, (uint64_t)True, (uint64_t)v17, 1);
  sub_1CD4AF9B4((uint64_t)v17);
  if (__p)
  {
    uint64_t v15 = (char *)__p;
    operator delete(__p);
  }
  if (v13 < 0) {
    operator delete((void *)v12);
  }
  if (v18 != v20) {
    free(v18);
  }
  return Assumption;
}

uint64_t llvm::IRBuilderBase::CreateAlignmentAssumption(llvm::LLVMContext **this, const llvm::DataLayout *a2, llvm::Value *a3, unsigned int a4, llvm::Value *a5)
{
  IntPtrType = (llvm::ConstantInt *)llvm::DataLayout::getIntPtrType(a2, this[8], *(_DWORD *)(*(void *)a3 + 8) >> 8);
  uint64_t v11 = (llvm::Value *)llvm::ConstantInt::get(IntPtrType, a4, 0);

  return llvm::IRBuilderBase::CreateAlignmentAssumptionHelper(this, v10, a3, v11, a5);
}

void llvm::IRBuilderDefaultInserter::~IRBuilderDefaultInserter(llvm::IRBuilderDefaultInserter *this)
{
}

void sub_1CD5C3C44()
{
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3C58(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getFAdd(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3C64(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getFSub(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3C70(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getFMul(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3C7C(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getSDiv(this, a3, a4, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3C8C(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getFDiv(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3C98(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getURem(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3CA4(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getSRem(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3CB0(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, uint64_t a4, uint64_t a5, llvm::Type *a6)
{
  return llvm::ConstantExpr::getFRem(this, a3, a3, a4, a5, a6);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3CBC(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  return llvm::ConstantExpr::getShl(this, a3, a4, a5);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3CD0(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, uint64_t a5, llvm::Type *a6)
{
  return llvm::ConstantExpr::getAShr(this, a3, a4, (BOOL)a4, a5, a6);
}

uint64_t sub_1CD5C3CE0(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  return llvm::ConstantExpr::getXor(this, a3, a3, a4);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3CEC(int a1, llvm::ConstantExpr *this, llvm::Constant *a3, const llvm::APFloat *a4)
{
  return llvm::ConstantExpr::getNeg(this, a3, a4);
}

uint64_t sub_1CD5C3CFC(int a1, llvm::ConstantExpr *this, uint64_t a3, uint64_t a4, llvm::Type *a5)
{
  return llvm::ConstantExpr::getFNeg(this, this, a3, a4, a5);
}

const llvm::detail::DoubleAPFloat *sub_1CD5C3D04(int a1, llvm::Constant **this, const llvm::APInt *a3)
{
  return llvm::ConstantExpr::getNot(this, (llvm::Constant *)this, a3);
}

uint64_t sub_1CD5C3D0C(int a1, llvm::ConstantExpr *this, unsigned __int8 *a3, uint64_t a4, llvm::Type *a5)
{
  return llvm::ConstantExpr::get(this, a3, 0, 0, a5);
}

llvm::ConstantExpr *sub_1CD5C3D20(int a1, llvm::ConstantExpr *this, llvm::Constant *a3)
{
  return llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast(this, a3, a3);
}

llvm::ConstantExpr *sub_1CD5C3D2C(int a1, llvm::ConstantExpr *this, llvm::Type ***a3)
{
  return llvm::ConstantExpr::getFPCast(this, a3, (llvm::Type *)a3);
}

llvm::detail::IEEEFloat *sub_1CD5C3D38(uint64_t a1, llvm::detail::IEEEFloat *a2, llvm::Constant *a3)
{
  if (*(llvm::Constant **)a2 == a3) {
    return a2;
  }
  else {
    return sub_1CC56C0C0((llvm *)0x31, a2, a3, 0);
  }
}

llvm::detail::IEEEFloat *sub_1CD5C3D58(uint64_t a1, llvm::detail::IEEEFloat *a2, llvm::Constant *a3)
{
  return sub_1CC56C0C0((llvm *)0x30, a2, a3, 0);
}

llvm::detail::IEEEFloat *sub_1CD5C3D64(uint64_t a1, llvm::detail::IEEEFloat *a2, llvm::Constant *a3)
{
  return sub_1CC56C0C0((llvm *)0x2F, a2, a3, 0);
}

llvm::detail::IEEEFloat *sub_1CD5C3D70(int a1, llvm::Type **this, llvm::Type ***a3)
{
  return llvm::ConstantExpr::getZExtOrBitCast(this, a3, (llvm::Type *)a3);
}

llvm::ConstantExpr *sub_1CD5C3D7C(int a1, llvm::Type **this, llvm::Type ***a3)
{
  return llvm::ConstantExpr::getSExtOrBitCast(this, a3, (llvm::Type *)a3);
}

llvm::detail::IEEEFloat *sub_1CD5C3D88(int a1, llvm::Type **this, llvm::Type ***a3)
{
  return llvm::ConstantExpr::getTruncOrBitCast(this, a3, (llvm::Type *)a3);
}

void *sub_1CD5C3D94(int a1, unsigned __int16 a2, llvm::Type *a3, llvm::Constant *a4, BOOL a5)
{
  return llvm::ConstantExpr::getCompare((llvm::ConstantExpr *)a2, a3, a4, 0, a5);
}

llvm::Constant *sub_1CD5C3DA8(int a1, llvm::Constant *this, unsigned int *a3, uint64_t a4)
{
  return llvm::ConstantExpr::getExtractValue(this, a3, a4, 0);
}

llvm::Value *sub_1CD5C3DBC(uint64_t a1, llvm::Constant *a2, uint64_t *a3, _DWORD *a4, uint64_t a5)
{
  return llvm::ConstantExpr::getInsertValue(a2, a3, a4, a5, 0);
}

void sub_1CD5C3DD8()
{
}

uint64_t sub_1CD5C3DEC()
{
  return 0;
}

uint64_t sub_1CD5C3DF4()
{
  return 0;
}

uint64_t sub_1CD5C3DFC()
{
  return 0;
}

uint64_t sub_1CD5C3E04()
{
  return 0;
}

llvm::Value *sub_1CD5C3E0C(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(14, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C3E40(uint64_t a1, void *a2, uint64_t a3, int a4, int a5)
{
  __int16 v9 = 257;
  unint64_t result = llvm::BinaryOperator::Create(15, a2, a3, &v8, 0);
  if (a4) {
    *((unsigned char *)result + 17) |= 2u;
  }
  if (a5) {
    *((unsigned char *)result + 17) |= 4u;
  }
  return result;
}

llvm::Value *sub_1CD5C3EA4(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(16, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C3ED8(uint64_t a1, void *a2, uint64_t a3, int a4, int a5)
{
  __int16 v9 = 257;
  unint64_t result = llvm::BinaryOperator::Create(17, a2, a3, &v8, 0);
  if (a4) {
    *((unsigned char *)result + 17) |= 2u;
  }
  if (a5) {
    *((unsigned char *)result + 17) |= 4u;
  }
  return result;
}

llvm::Value *sub_1CD5C3F3C(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(18, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C3F70(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  __int16 v7 = 257;
  if ((a4 & 1) == 0) {
    return llvm::BinaryOperator::Create(19, a2, a3, v6, 0);
  }
  uint64_t v4 = llvm::BinaryOperator::Create(19, a2, a3, v6, 0);
  llvm::Instruction::setIsExact((uint64_t)v4, 1);
  return v4;
}

llvm::Value *sub_1CD5C3FDC(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  __int16 v7 = 257;
  if ((a4 & 1) == 0) {
    return llvm::BinaryOperator::Create(20, a2, a3, v6, 0);
  }
  uint64_t v4 = llvm::BinaryOperator::Create(20, a2, a3, v6, 0);
  llvm::Instruction::setIsExact((uint64_t)v4, 1);
  return v4;
}

llvm::Value *sub_1CD5C4048(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(21, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C407C(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(22, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C40B0(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(23, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C40E4(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(24, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C4118(uint64_t a1, void *a2, uint64_t a3, int a4, int a5)
{
  __int16 v9 = 257;
  unint64_t result = llvm::BinaryOperator::Create(25, a2, a3, &v8, 0);
  if (a4) {
    *((unsigned char *)result + 17) |= 2u;
  }
  if (a5) {
    *((unsigned char *)result + 17) |= 4u;
  }
  return result;
}

llvm::Value *sub_1CD5C417C(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  __int16 v7 = 257;
  if ((a4 & 1) == 0) {
    return llvm::BinaryOperator::Create(26, a2, a3, v6, 0);
  }
  uint64_t v4 = llvm::BinaryOperator::Create(26, a2, a3, v6, 0);
  llvm::Instruction::setIsExact((uint64_t)v4, 1);
  return v4;
}

llvm::Value *sub_1CD5C41E8(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  __int16 v7 = 257;
  if ((a4 & 1) == 0) {
    return llvm::BinaryOperator::Create(27, a2, a3, v6, 0);
  }
  uint64_t v4 = llvm::BinaryOperator::Create(27, a2, a3, v6, 0);
  llvm::Instruction::setIsExact((uint64_t)v4, 1);
  return v4;
}

llvm::Value *sub_1CD5C4254(uint64_t a1, void *a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::BinaryOperator::Create(30, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C4288(uint64_t a1, char a2, void *a3, uint64_t a4)
{
  __int16 v6 = 257;
  return llvm::BinaryOperator::Create(a2, a3, a4, &v5, 0);
}

llvm::Value *sub_1CD5C42C8(int a1, llvm::BinaryOperator *this, int a3, llvm::Instruction *a4)
{
  int v4 = (int)a4;
  __int16 v8 = 257;
  unint64_t result = llvm::BinaryOperator::CreateNeg(this, (llvm::Value *)v7, 0, a4);
  if (a3) {
    *((unsigned char *)result + 17) |= 2u;
  }
  if (v4) {
    *((unsigned char *)result + 17) |= 4u;
  }
  return result;
}

llvm::Value *sub_1CD5C432C(uint64_t a1, uint64_t *a2)
{
  __int16 v4 = 257;
  return llvm::UnaryOperator::Create(12, a2, &v3, 0);
}

llvm::Value *sub_1CD5C4360(int a1, llvm::Constant **this, uint64_t a3, llvm::Instruction *a4)
{
  __int16 v6 = 257;
  return llvm::BinaryOperator::CreateNot(this, (llvm::Value *)v5, 0, a4);
}

llvm::Value *sub_1CD5C4394(uint64_t a1, char a2, uint64_t *a3)
{
  __int16 v5 = 257;
  return llvm::UnaryOperator::Create(a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C43D0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  __int16 v6 = 257;
  return llvm::CastInst::Create(a2, a3, a4, &v5, 0);
}

llvm::Value *sub_1CD5C4410(int a1, llvm::CastInst *this, llvm::Value *a3, uint64_t a4, llvm::Instruction *a5)
{
  __int16 v7 = 257;
  return llvm::CastInst::CreatePointerCast(this, a3, &v6, 0, a5);
}

llvm::Value *sub_1CD5C444C(int a1, llvm::CastInst *this, llvm::Value *a3, uint64_t a4, llvm::Instruction *a5)
{
  __int16 v7 = 257;
  return llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(this, a3, &v6, 0, a5);
}

llvm::Value *sub_1CD5C4488(int a1, llvm::CastInst *this, llvm::Type ***a3, llvm::Type *a4, uint64_t a5, llvm::Instruction *a6)
{
  __int16 v8 = 257;
  return llvm::CastInst::CreateIntegerCast(this, a3, a4, &v7, 0, a6);
}

llvm::Value *sub_1CD5C44C8(int a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  __int16 v7 = 257;
  return llvm::CastInst::CreateFPCast(this, a3, &v6, 0, a5);
}

llvm::Value *sub_1CD5C4504(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::CastInst::Create(49, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C4538(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::CastInst::Create(48, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C456C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v5 = 257;
  return llvm::CastInst::Create(47, a2, a3, &v4, 0);
}

llvm::Value *sub_1CD5C45A0(int a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  __int16 v7 = 257;
  return llvm::CastInst::CreateZExtOrBitCast(this, a3, &v6, 0, a5);
}

char *sub_1CD5C45DC(int a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  __int16 v7 = 257;
  return llvm::CastInst::CreateSExtOrBitCast(this, a3, &v6, 0, a5);
}

llvm::Value *sub_1CD5C4618(int a1, llvm::CastInst *this, llvm::Type ***a3, uint64_t a4, llvm::Instruction *a5)
{
  __int16 v7 = 257;
  return llvm::CastInst::CreateTruncOrBitCast(this, a3, &v6, 0, a5);
}

llvm::Value *sub_1CD5C4654(uint64_t a1, __int16 a2, _DWORD **a3, uint64_t a4)
{
  __int16 v7 = operator new(0x80uLL);
  v7[21] = v7[21] & 0x38000000 | 2;
  __int16 v8 = (llvm::Value *)(v7 + 16);
  *(void *)__int16 v7 = 0;
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *((void *)v7 + 3) = v7 + 16;
  *((void *)v7 + 4) = 0;
  *((void *)v7 + 5) = 0;
  *((void *)v7 + 6) = 0;
  *((void *)v7 + 7) = v7 + 16;
  __int16 v12 = 257;
  sub_1CB90C994(*a3);
  return llvm::CmpInst::CmpInst(v8, v9, 54, a2, (uint64_t)a3, a4, &v11, 0, 0);
}

llvm::ExtractElementInst *sub_1CD5C46F0(uint64_t a1, llvm::Value *a2, llvm::Value *a3)
{
  __int16 v8 = 257;
  __int16 v5 = operator new(0x80uLL);
  v5[21] = v5[21] & 0x38000000 | 2;
  *(void *)__int16 v5 = 0;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 3) = v5 + 16;
  *((void *)v5 + 4) = 0;
  *((void *)v5 + 5) = 0;
  *((void *)v5 + 6) = 0;
  *((void *)v5 + 7) = v5 + 16;
  return llvm::ExtractElementInst::ExtractElementInst((llvm::ExtractElementInst *)(v5 + 16), a2, a3, &v7, 0);
}

llvm::InsertElementInst *sub_1CD5C4770(uint64_t a1, llvm::Value *a2, llvm::Value *a3, llvm::Value *a4)
{
  __int16 v13 = 257;
  __int16 v7 = operator new(0xA0uLL);
  uint64_t v8 = 0;
  uint64_t v9 = (llvm::InsertElementInst *)(v7 + 24);
  v7[29] = v7[29] & 0x38000000 | 3;
  do
  {
    uint64_t v10 = &v7[v8];
    void *v10 = 0;
    v10[1] = 0;
    void v10[2] = 0;
    uint64_t v10[3] = v9;
    v8 += 8;
  }
  while (v8 != 24);
  return llvm::InsertElementInst::InsertElementInst(v9, a2, a3, a4, &v12, 0);
}

uint64_t ***sub_1CD5C4804(uint64_t a1, uint64_t **a2, uint64_t **a3, void *a4, llvm::Type *a5)
{
  uint64_t v9 = (char *)operator new(0xA8uLL);
  *((_DWORD *)v9 + 21) = *((_DWORD *)v9 + 21) & 0x38000000 | 2;
  *(void *)uint64_t v9 = 0;
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 3) = v9 + 64;
  *((void *)v9 + 4) = 0;
  *((void *)v9 + 5) = 0;
  *((void *)v9 + 6) = 0;
  *((void *)v9 + 7) = v9 + 64;
  __int16 v12 = 257;
  return llvm::ShuffleVectorInst::ShuffleVectorInst((uint64_t ***)v9 + 8, a2, a3, a4, a5, &v11, 0);
}

llvm::Value *sub_1CD5C489C(uint64_t a1, uint64_t *a2, unsigned int *a3, uint64_t a4)
{
  __int16 v6 = 257;
  return sub_1CC19A650(a2, a3, a4, &v5, 0);
}

llvm::Value *sub_1CD5C48DC(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  __int16 v7 = 257;
  return sub_1CC19A834(a2, a3, a4, a5, &v6, 0);
}

uint64_t sub_1CD5C4920(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1CBFCBA2C((void *)(a1 + 24), *((const void **)a2 + 3), *((void *)a2 + 4), (uint64_t)(*((void *)a2 + 4) - *((void *)a2 + 3)) >> 3);
  return a1;
}

uint64_t sub_1CD5C498C(uint64_t *a1, const void *a2, unsigned int a3)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CC5C380C(a1, a2, a3);
  }
  else
  {
    *(void *)unint64_t v4 = 0x74706F6564;
    *(unsigned char *)(v4 + 23) = 5;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 4llvm::MDNode::dumpTree(this, 0) = 0;
    *(void *)(v4 + 24) = 0;
    sub_1CBFCBA2C((void *)(v4 + 24), a2, (uint64_t)a2 + 8 * a3, a3);
    uint64_t result = v4 + 48;
  }
  a1[1] = result;
  return result;
}

uint64_t sub_1CD5C49FC(uint64_t *a1, const void *a2, unsigned int a3)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CC5C3964(a1, a2, a3);
  }
  else
  {
    strcpy((char *)v4, "gc-transition");
    *(unsigned char *)(v4 + 23) = 13;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 4llvm::MDNode::dumpTree(this, 0) = 0;
    *(void *)(v4 + 24) = 0;
    sub_1CBFCBA2C((void *)(v4 + 24), a2, (uint64_t)a2 + 8 * a3, a3);
    uint64_t result = v4 + 48;
  }
  a1[1] = result;
  return result;
}

uint64_t sub_1CD5C4A84(uint64_t *a1, const void *a2, unsigned int a3)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CC5C3AD4(a1, a2, a3);
  }
  else
  {
    *(void *)unint64_t v4 = 0x6576696C2D6367;
    *(unsigned char *)(v4 + 23) = 7;
    *(void *)(v4 + 32) = 0;
    *(void *)(v4 + 4llvm::MDNode::dumpTree(this, 0) = 0;
    *(void *)(v4 + 24) = 0;
    sub_1CBFCBA2C((void *)(v4 + 24), a2, (uint64_t)a2 + 8 * a3, a3);
    uint64_t result = v4 + 48;
  }
  a1[1] = result;
  return result;
}

unsigned char *sub_1CD5C4AF8(unsigned int *a1, uint64_t a2, uint64_t *__src, uint64_t *a4)
{
  __int16 v5 = __src;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v9 = a1[2];
  if (*(void *)a1 + 8 * v9 == a2)
  {
    sub_1CC188254(a1, __src, a4);
    return (unsigned char *)(*(void *)a1 + 8 * v8);
  }
  else
  {
    unint64_t v10 = a4 - __src;
    if (v9 + v10 > a1[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v11 = (unsigned char *)(v7 + 8 * v8);
    __int16 v12 = (unsigned char *)(v7 + 8 * v9);
    unint64_t v13 = (v12 - v11) >> 3;
    if (v13 >= v10)
    {
      sub_1CD4570C8((uint64_t)a1, &v12[-8 * v10], (char *)(v7 + 8 * v9));
      if (&v12[-8 * v10] != v11) {
        memmove(&v11[8 * v10], v11, &v12[-8 * v10] - v11);
      }
      if (v5 != a4) {
        memmove(v11, v5, (char *)a4 - (char *)v5);
      }
    }
    else
    {
      unsigned int v14 = v9 + ((unint64_t)((char *)a4 - (char *)__src) >> 3);
      a1[2] = v14;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 8 * v14 - 8 * v13), v11, v12 - v11);
        uint64_t v15 = v11;
        do
        {
          uint64_t v16 = *v5++;
          *v15++ = v16;
          --v13;
        }
        while (v13);
      }
      if (v5 != a4) {
        memcpy(v12, v5, (char *)a4 - (char *)v5);
      }
    }
  }
  return v11;
}

uint64_t sub_1CD5C4C58(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  __int16 v5 = a3;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (*(void *)a1 + 8 * v9 == a2)
  {
    sub_1CC27D070(a1, a3, a4);
    return *(void *)a1 + 8 * v8;
  }
  else
  {
    unint64_t v10 = (a4 - a3) >> 5;
    if (v9 + v10 > *(unsigned int *)(a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v11 = (unsigned char *)(v7 + 8 * v8);
    __int16 v12 = (char *)(v7 + 8 * v9);
    unint64_t v13 = (v12 - v11) >> 3;
    if (v13 >= v10)
    {
      sub_1CD4570C8(a1, &v12[-8 * v10], (char *)(v7 + 8 * v9));
      if (&v12[-8 * v10] != v11) {
        memmove(&v11[8 * v10], v11, &v12[-8 * v10] - v11);
      }
      if (v5 != a4)
      {
        uint64_t v19 = v11;
        do
        {
          uint64_t v20 = *(void *)v5;
          v5 += 32;
          *v19++ = v20;
        }
        while (v5 != a4);
      }
    }
    else
    {
      unsigned int v14 = v9 + ((unint64_t)(a4 - a3) >> 5);
      *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v14;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 8 * v14 - 8 * v13), v11, v12 - v11);
        uint64_t v15 = v11;
        do
        {
          uint64_t v16 = *(void *)v5;
          v5 += 32;
          *v15++ = v16;
          --v13;
        }
        while (v13);
      }
      while (v5 != a4)
      {
        uint64_t v17 = *(void *)v5;
        v5 += 32;
        *(void *)__int16 v12 = v17;
        v12 += 8;
      }
    }
  }
  return (uint64_t)v11;
}

llvm::Instruction *sub_1CD5C4DB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  __int16 v16 = 257;
  __int16 v12 = sub_1CD4EF89C(a2, a3, a4, a5, a6, a7, a9, a10, &v15, 0);
  unint64_t v13 = (llvm::Instruction *)v12;
  if (*(unsigned char *)(a1 + 100)) {
    *((void *)v12 + sub_1CD521E44((uint64_t)this + 8) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v12 + 8, **(uint64_t ***)v12, -1, 61);
  }
  return sub_1CD509770((uint64_t *)a1, v13, a11);
}

double llvm::PrintModulePass::run@<D0>(uint64_t a1@<X0>, const std::string *a2@<X1>, uint64_t a3@<X8>)
{
  if (!llvm::isFunctionInPrintList("*", 1uLL))
  {
    size_t size = (const std::string *)a2[1].__r_.__value_.__l.__size_;
    if (size == &a2[1]) {
      goto LABEL_13;
    }
    char v13 = 0;
    while (1)
    {
      if (size) {
        unsigned int v14 = (llvm::Value *)&size[-3].__r_.__value_.__r.__words[2];
      }
      else {
        unsigned int v14 = 0;
      }
      Name = llvm::Value::getName(v14);
      if (!llvm::isFunctionInPrintList(Name, v16)) {
        goto LABEL_23;
      }
      if ((v13 & 1) == 0)
      {
        char v17 = *(unsigned char *)(a1 + 31);
        if (v17 < 0) {
          uint64_t v18 = *(void *)(a1 + 16);
        }
        else {
          uint64_t v18 = *(unsigned __int8 *)(a1 + 31);
        }
        if (!v18)
        {
          char v13 = 0;
          goto LABEL_22;
        }
        if (v17 >= 0) {
          uint64_t v19 = (const char *)(a1 + 8);
        }
        else {
          uint64_t v19 = *(const char **)(a1 + 8);
        }
        if (v17 >= 0) {
          size_t v20 = *(unsigned __int8 *)(a1 + 31);
        }
        else {
          size_t v20 = *(void *)(a1 + 16);
        }
        uint64_t v21 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v19, v20);
        sub_1CB8E509C(v21, "\n");
      }
      char v13 = 1;
LABEL_22:
      llvm::Function::print((const llvm::Module **)v14, *(llvm::raw_ostream **)a1, 0, 0, 0);
LABEL_23:
      size_t size = (const std::string *)size->__r_.__value_.__l.__size_;
      if (size == &a2[1]) {
        goto LABEL_13;
      }
    }
  }
  char v6 = *(unsigned char *)(a1 + 31);
  if (v6 < 0) {
    uint64_t v7 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 31);
  }
  if (v7)
  {
    if (v6 >= 0) {
      uint64_t v8 = (const char *)(a1 + 8);
    }
    else {
      uint64_t v8 = *(const char **)(a1 + 8);
    }
    if (v6 >= 0) {
      size_t v9 = *(unsigned __int8 *)(a1 + 31);
    }
    else {
      size_t v9 = *(void *)(a1 + 16);
    }
    unint64_t v10 = llvm::raw_ostream::write(*(llvm::raw_ostream **)a1, v8, v9);
    sub_1CB8E509C(v10, "\n");
  }
  llvm::Module::print(a2, *(llvm::raw_ostream **)a1, 0, *(unsigned char *)(a1 + 32), 0);
LABEL_13:
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 4sub_1CD521E44((uint64_t)this + 8) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

double llvm::PrintFunctionPass::run@<D0>(const std::string **this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  Name = llvm::Value::getName((llvm::Value *)this);
  isFunctionInPrintList = (llvm *)llvm::isFunctionInPrintList(Name, v7);
  if (isFunctionInPrintList)
  {
    int v9 = llvm::forcePrintModuleIR(isFunctionInPrintList);
    unint64_t v10 = *(llvm::raw_ostream **)a2;
    char v11 = *(unsigned char *)(a2 + 31);
    int v12 = v11;
    if (v11 >= 0) {
      char v13 = (const char *)(a2 + 8);
    }
    else {
      char v13 = *(const char **)(a2 + 8);
    }
    size_t v14 = v11 & 0x7F;
    if (v12 >= 0) {
      size_t v15 = v14;
    }
    else {
      size_t v15 = *(void *)(a2 + 16);
    }
    llvm::raw_ostream::write(*(llvm::raw_ostream **)a2, v13, v15);
    if (v9)
    {
      std::string::size_type v16 = sub_1CB8E509C(v10, " (function: ");
      uint64_t v18 = llvm::Value::getName((llvm::Value *)this);
      size_t v19 = v17;
      size_t v20 = (void *)*((void *)v16 + 4);
      if (v17 <= *((void *)v16 + 3) - (void)v20)
      {
        if (v17)
        {
          memcpy(v20, v18, v17);
          *((void *)v16 + 4) += v19;
        }
      }
      else
      {
        llvm::raw_ostream::write(v16, v18, v17);
      }
      uint64_t v21 = sub_1CB8E509C(v16, ")\n");
      llvm::Module::print(this[5], v21, 0, 0, 0);
    }
    else
    {
      uint64_t v22 = (unsigned char *)*((void *)v10 + 4);
      if ((unint64_t)v22 >= *((void *)v10 + 3))
      {
        unint64_t v10 = llvm::raw_ostream::write(v10, 10);
      }
      else
      {
        *((void *)v10 + 4) = v22 + 1;
        *uint64_t v22 = 10;
      }
      llvm::Value::print((llvm::Value *)this, v10, 0);
    }
  }
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + sub_1CD521E44((uint64_t)this + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 4sub_1CD521E44((uint64_t)this + 8) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

void llvm::initializePrintModulePassWrapperPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD8808, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC5C4878;
    v4[1] = &v2;
    unsigned __int8 v3 = v4;
    std::__call_once(&qword_1EBCD8808, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializePrintFunctionPassWrapperPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD8810, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC5C4918;
    v4[1] = &v2;
    unsigned __int8 v3 = v4;
    std::__call_once(&qword_1EBCD8810, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createPrintModulePass()
{
}

void llvm::createPrintFunctionPass()
{
}

BOOL llvm::isIRPrintingPass(llvm *this, llvm::Pass *a2)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  return v2 == &unk_1EA61EFA9 || v2 == &unk_1EA61BF20;
}

uint64_t llvm::GenericSSAContext<llvm::Function>::getEntryBlock(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (v1) {
    return v1 - 24;
  }
  else {
    return 0;
  }
}

void *llvm::GenericSSAContext<llvm::Function>::setFunction(void *result, uint64_t a2)
{
  llvm::Value *result = a2;
  return result;
}

uint64_t llvm::InlineAsm::InlineAsm(uint64_t a1, llvm::PointerType *this, long long *a3, long long *a4, char a5, char a6, int a7, char a8)
{
  std::string::size_type v16 = (llvm::Type *)llvm::PointerType::get(this, 0);
  llvm::Value::Value(a1, v16, 24);
  size_t v17 = (_OWORD *)(a1 + 24);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v17, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v18 = *a3;
    *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = *((void *)a3 + 2);
    *size_t v17 = v18;
  }
  size_t v19 = (_OWORD *)(a1 + 48);
  if (*((char *)a4 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v19, *(const void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v20 = *a4;
    *(void *)(a1 + 64) = *((void *)a4 + 2);
    *size_t v19 = v20;
  }
  *(void *)(a1 + 72) = this;
  *(unsigned char *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = a5;
  *(unsigned char *)(a1 + 81) = a6;
  *(_DWORD *)(a1 + 84) = a7;
  *(unsigned char *)(a1 + 8sub_1CD521E44((uint64_t)this + 8) = a8;
  return a1;
}

uint64_t llvm::InlineAsm::get(llvm::PointerType *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, char a7, int a8, char a9)
{
  uint64_t v17 = **(void **)a1 + 1536;
  unint64_t v18 = llvm::PointerType::get(a1, 0);
  v20[0] = a2;
  v20[1] = a3;
  void v20[2] = a4;
  void v20[3] = a5;
  void v20[4] = a1;
  char v21 = a6;
  char v22 = a7;
  int v23 = a8;
  char v24 = a9;
  return sub_1CD5C5628(v17, v18, (uint64_t)v20);
}

uint64_t sub_1CD5C5628(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)&v12[8] = *(_OWORD *)a3;
  *(_OWORD *)&v12[24] = v4;
  *(_OWORD *)&v12[40] = *(_OWORD *)(a3 + 32);
  uint64_t v5 = *(void *)(a3 + 48);
  *(void *)int v12 = a2;
  *(void *)&v12[56] = v5;
  int v7 = sub_1CD5C5B14((uint64_t)&v12[8], (uint64_t)&v12[24], &v12[48], &v12[49], (int *)&v12[52], (uint64_t *)&v12[40], &v12[56]);
  int v7 = sub_1CD5C59F0((uint64_t *)v12, &v7);
  long long v8 = *(_OWORD *)v12;
  long long v9 = *(_OWORD *)&v12[16];
  long long v10 = *(_OWORD *)&v12[32];
  long long v11 = *(_OWORD *)&v12[48];
  char v13 = 0;
  if (!sub_1CD5C5E78(*(void *)a1, *(_DWORD *)(a1 + 16), (uint64_t)&v7, &v13)
    || v13 == (uint64_t *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 16)))
  {
    sub_1CD5C6054();
  }
  return *v13;
}

uint64_t llvm::InlineAsm::getFunctionType(llvm::InlineAsm *this)
{
  return *((void *)this + 9);
}

void sub_1CD5C5754(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 5;
  if (a2 > v4)
  {
    unint64_t v7 = a2 - v4;
    sub_1CD5C65B0(a1, v7);
  }
  else if (a2 < v4)
  {
    uint64_t v5 = *a1 + 32 * a2;
    if (v3 != v5)
    {
      do
      {
        uint64_t v6 = v3 - 32;
        long long v8 = (void **)(v3 - 24);
        sub_1CB8338B8(&v8);
        uint64_t v3 = v6;
      }
      while (v6 != v5);
    }
    a1[1] = v5;
  }
}

void llvm::InlineAsm::ConstraintInfo::selectAlternative(llvm::InlineAsm::ConstraintInfo *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 6);
  if (a2 < (unint64_t)((*((void *)this + 7) - v2) >> 5))
  {
    *((_DWORD *)this + 1sub_1CD521E44((uint64_t)this + 8) = a2;
    uint64_t v3 = v2 + 32 * a2;
    *((_DWORD *)this + 2) = *(_DWORD *)v3;
    unint64_t v4 = (char *)this + 16;
    if (v4 != (char *)(v3 + 8)) {
      sub_1CBF4C3C4((uint64_t)v4, *(std::string **)(v3 + 8), *(std::string **)(v3 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v3 + 16) - *(void *)(v3 + 8)) >> 3));
    }
  }
}

void llvm::InlineAsm::ParseConstraints(char *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3 = a1;
  uint64_t v5 = &a1[a2];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  while (v3 != v5)
  {
    LODWORD(v12) = 0;
    BYTE4(v12) = 0;
    int v13 = -1;
    __int16 v14 = 0;
    memset(v15, 0, 25);
    memset(v16, 0, sizeof(v16));
    int v17 = 0;
    uint64_t v6 = (char *)memchr(v3, 44, v5 - v3);
    if (v6) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = v5;
    }
    if (v7 == v3
      || (llvm::InlineAsm::ConstraintInfo::Parse((uint64_t)&v12, (unsigned __int8 *)v3, v7 - v3, a3) & 1) != 0)
    {
      goto LABEL_8;
    }
    unint64_t v9 = a3[1];
    if (v9 < a3[2]) {
      uint64_t v10 = sub_1CD5C66FC(v9, &v12) + 80;
    }
    else {
      uint64_t v10 = sub_1CC5C6408(a3, &v12);
    }
    a3[1] = v10;
    if (v7 == v5)
    {
      char v8 = 1;
      uint64_t v3 = v5;
      goto LABEL_9;
    }
    long long v11 = v7 + 1;
    uint64_t v3 = v5;
    if (v7 + 1 == v5)
    {
LABEL_8:
      sub_1CC5C6398(a3);
      char v8 = 0;
    }
    else
    {
      char v8 = 1;
      uint64_t v3 = v11;
    }
LABEL_9:
    unint64_t v18 = (void **)v16;
    sub_1CC1E4230(&v18);
    unint64_t v18 = (void **)v15;
    sub_1CB8338B8(&v18);
    if ((v8 & 1) == 0) {
      return;
    }
  }
}

void sub_1CD5C599C(void **this, llvm::Value *a2)
{
  if (*((char *)this + 71) < 0) {
    operator delete(this[6]);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(this[3]);
  }

  llvm::Value::~Value((llvm::Value *)this, a2);
}

unint64_t sub_1CD5C59F0(uint64_t *a1, int *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  memset(v5, 0, sizeof(v5));
  uint64_t v8 = sub_1CBF65470();
  return sub_1CD5C5A90(v5, v5, (char *)v6, *a1, a2);
}

unint64_t sub_1CD5C5A90(void *a1, void *__dst, char *a3, uint64_t a4, int *a5)
{
  uint64_t v11 = 0;
  uint64_t v8 = sub_1CC2E96A4(a1, &v11, __dst, (unint64_t)a3, a4);
  uint64_t v12 = v11;
  uint64_t v9 = (char *)sub_1CC0AC9D0(a1, &v12, v8, (unint64_t)a3, *a5);
  return sub_1CC36B0E4((uint64_t)a1, v12, v9, a3);
}

unint64_t sub_1CD5C5B14(uint64_t a1, uint64_t a2, char *a3, char *a4, int *a5, uint64_t *a6, char *a7)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  memset(v15, 0, sizeof(v15));
  uint64_t v18 = sub_1CBF65470();
  return sub_1CD5C5BF0(v15, v15, (char *)v16, *(void **)a1, *(void *)(a1 + 8), a2, a3, a4, a5, a6, a7);
}

unint64_t sub_1CD5C5BF0(void *a1, void *a2, char *a3, void *a4, uint64_t a5, uint64_t a6, char *a7, char *a8, int *a9, uint64_t *a10, char *a11)
{
  uint64_t v20 = 0;
  unint64_t v17 = llvm::hash_value(a4, a5);
  uint64_t v18 = sub_1CBFFCBA0(a1, &v20, a2, (unint64_t)a3, v17);
  return sub_1CD5C5CA4(a1, v20, v18, a3, *(void **)a6, *(void *)(a6 + 8), a7, a8, a9, a10, a11);
}

unint64_t sub_1CD5C5CA4(void *a1, uint64_t a2, void *a3, char *a4, void *a5, uint64_t a6, char *a7, char *a8, int *a9, uint64_t *a10, char *a11)
{
  uint64_t v20 = a2;
  unint64_t v16 = llvm::hash_value(a5, a6);
  unint64_t v17 = sub_1CBFFCBA0(a1, &v20, a3, (unint64_t)a4, v16);
  uint64_t v21 = v20;
  uint64_t v18 = sub_1CC0AC730(a1, &v21, v17, (unint64_t)a4, *a7);
  return sub_1CD5C5D68(a1, v21, v18, a4, *a8, a9, a10, a11);
}

unint64_t sub_1CD5C5D68(void *a1, uint64_t a2, unsigned char *a3, char *a4, char a5, int *a6, uint64_t *a7, char *a8)
{
  uint64_t v16 = a2;
  int v13 = sub_1CC0AC730(a1, &v16, a3, (unint64_t)a4, a5 != 0);
  uint64_t v17 = v16;
  __int16 v14 = sub_1CC0AC9D0(a1, &v17, v13, (unint64_t)a4, *a6);
  return sub_1CD5C5E00(a1, v17, v14, a4, *a7, a8);
}

unint64_t sub_1CD5C5E00(void *a1, uint64_t a2, void *a3, char *a4, uint64_t a5, char *a6)
{
  uint64_t v12 = a2;
  uint64_t v9 = sub_1CC2E96A4(a1, &v12, a3, (unint64_t)a4, a5);
  uint64_t v13 = v12;
  uint64_t v10 = sub_1CC0AC730(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

uint64_t sub_1CD5C5E78(uint64_t a1, int a2, uint64_t a3, uint64_t **a4)
{
  if (!a2)
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
    goto LABEL_14;
  }
  uint64_t v7 = 0;
  unsigned int v8 = *(_DWORD *)a3;
  int v9 = a2 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v11 = v8 & v9;
    uint64_t v12 = (uint64_t *)(a1 + 8 * (v8 & v9));
    uint64_t v13 = (void *)*v12;
    if (*v12 == -8192) {
      goto LABEL_6;
    }
    if (v13 == (void *)-4096) {
      break;
    }
    if (*(void *)(a3 + 8) == *v13 && sub_1CD5C5F58(a3 + 16, *v12))
    {
      uint64_t result = 1;
      goto LABEL_14;
    }
LABEL_6:
    if (v7) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v13 == (void *)-8192;
    }
    if (v14) {
      uint64_t v7 = (uint64_t *)(a1 + 8 * v11);
    }
    unsigned int v8 = v11 + i;
  }
  uint64_t result = 0;
  if (v7) {
    uint64_t v12 = v7;
  }
LABEL_14:
  *a4 = v12;
  return result;
}

BOOL sub_1CD5C5F58(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 40) != *(unsigned __int8 *)(a2 + 80)
    || *(unsigned __int8 *)(a1 + 41) != *(unsigned __int8 *)(a2 + 81)
    || *(_DWORD *)(a1 + 44) != *(_DWORD *)(a2 + 84))
  {
    return 0;
  }
  size_t v4 = *(void *)(a1 + 8);
  char v5 = *(unsigned char *)(a2 + 47);
  if (v5 >= 0) {
    uint64_t v6 = (const void *)(a2 + 24);
  }
  else {
    uint64_t v6 = *(const void **)(a2 + 24);
  }
  uint64_t v7 = *(void *)(a2 + 32);
  if (v5 >= 0) {
    uint64_t v7 = v5 & 0x7F;
  }
  if (v4 != v7 || v4 && memcmp(*(const void **)a1, v6, v4)) {
    return 0;
  }
  size_t v8 = *(void *)(a1 + 24);
  char v9 = *(unsigned char *)(a2 + 71);
  if (v9 >= 0) {
    uint64_t v10 = (const void *)(a2 + 48);
  }
  else {
    uint64_t v10 = *(const void **)(a2 + 48);
  }
  uint64_t v11 = *(void *)(a2 + 56);
  if (v9 >= 0) {
    uint64_t v11 = v9 & 0x7F;
  }
  return v8 == v11
      && (!v8 || !memcmp(*(const void **)(a1 + 16), v10, v8))
      && *(void *)(a1 + 32) == *(void *)(a2 + 72)
      && *(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(a2 + 88);
}

void sub_1CD5C6054()
{
}

uint64_t sub_1CD5C6104(uint64_t a1, unint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD5C5E78(*(void *)a2, *(_DWORD *)(a2 + 16), a4, &v12);
  char v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5C6198(a2, a4, v12);
    char v9 = (uint64_t *)result;
    *(void *)uint64_t result = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t *sub_1CD5C6198(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5C624C(a1, v6);
  size_t v8 = 0;
  sub_1CD5C5E78(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5C624C(unint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  size_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5C6320(a1, v4, &v4[v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(8 * v3));
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

unint64_t sub_1CD5C6320(unint64_t result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      char v9 = 0;
      uint64_t result = sub_1CD5C63D4(*(void *)v5, *(_DWORD *)(v5 + 16), a2, &v9);
      *char v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

unint64_t sub_1CD5C63D4(unint64_t result, int a2, uint64_t *a3, void *a4)
{
  if (a2)
  {
    unint64_t v8 = result;
    uint64_t result = sub_1CD5C6484(*a3);
    int v9 = a2 - 1;
    unsigned int v10 = result & (a2 - 1);
    unint64_t v5 = (void *)(v8 + 8 * v10);
    uint64_t v11 = *v5;
    if (*a3 != *v5)
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != -4096)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -8192;
        }
        if (v14) {
          uint64_t v12 = v5;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        unint64_t v5 = (void *)(v8 + 8 * (v15 & v9));
        uint64_t v11 = *v5;
        if (*a3 == *v5) {
          goto LABEL_3;
        }
      }
      if (v12) {
        unint64_t v5 = v12;
      }
    }
  }
  else
  {
    unint64_t v5 = 0;
  }
LABEL_3:
  *a4 = v5;
  return result;
}

unint64_t sub_1CD5C6484(uint64_t a1)
{
  unsigned char v33[32] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)a1;
  char v2 = *(unsigned char *)(a1 + 47);
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = *(unsigned char *)(a1 + 71);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(a1 + 72);
  __int16 v8 = *(_WORD *)(a1 + 80);
  int v9 = *(_DWORD *)(a1 + 84);
  char v10 = *(unsigned char *)(a1 + 88);
  BOOL v11 = v2 < 0;
  uint64_t v14 = *(void *)(a1 + 24);
  uint64_t v12 = a1 + 24;
  uint64_t v13 = v14;
  if (v2 >= 0) {
    uint64_t v13 = v12;
  }
  long long v31 = v33;
  uint64_t v32 = 0x2000000000;
  uint64_t v15 = v2 & 0x7F;
  if (v11) {
    uint64_t v15 = v3;
  }
  BOOL v16 = v4 < 0;
  uint64_t v19 = *(void *)(a1 + 48);
  uint64_t v18 = a1 + 48;
  uint64_t v17 = v19;
  if (v4 >= 0) {
    uint64_t v17 = v18;
  }
  uint64_t v20 = v4 & 0x7F;
  if (v16) {
    uint64_t v20 = v6;
  }
  uint64_t v23 = v1;
  v24[0] = v13;
  v24[1] = v15;
  v25[0] = v17;
  v25[1] = v20;
  uint64_t v26 = v7;
  *(_WORD *)uint64_t v27 = v8;
  int v28 = v9;
  v29[0] = v10;
  int v30 = sub_1CD5C5B14((uint64_t)v24, (uint64_t)v25, v27, &v27[1], &v28, &v26, v29);
  unint64_t v21 = sub_1CD5C59F0(&v23, &v30);
  if (v31 != v33) {
    free(v31);
  }
  return v21;
}

void sub_1CD5C65B0(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  unint64_t v5 = (void *)a1[1];
  if (a2 > (v4 - (uint64_t)v5) >> 5)
  {
    uint64_t v7 = (uint64_t)v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 5);
    if (v8 >> 59) {
      abort();
    }
    uint64_t v9 = v4 - *a1;
    if (v9 >> 4 > v8) {
      unint64_t v8 = v9 >> 4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    unint64_t v21 = a1 + 2;
    if (v10)
    {
      if (v10 >> 59) {
        sub_1CB833614();
      }
      BOOL v11 = (char *)operator new(32 * v10);
    }
    else
    {
      BOOL v11 = 0;
    }
    uint64_t v12 = &v11[32 * (v7 >> 5)];
    std::string __p = v11;
    uint64_t v18 = v12;
    uint64_t v20 = &v11[32 * v10];
    uint64_t v13 = &v12[32 * a2];
    do
    {
      *(void *)uint64_t v12 = 0xFFFFFFFFLL;
      *((void *)v12 + 1) = 0;
      *((void *)v12 + 2) = 0;
      *((void *)v12 + 3) = 0;
      v12 += 32;
    }
    while (v12 != v13);
    uint64_t v19 = v13;
    sub_1CC207CA8(a1, &__p);
    uint64_t v15 = v18;
    uint64_t v14 = v19;
    if (v19 != v18)
    {
      do
      {
        BOOL v16 = v14 - 32;
        char v22 = (void **)(v14 - 24);
        sub_1CB8338B8(&v22);
        uint64_t v14 = v16;
      }
      while (v16 != v15);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    if (a2)
    {
      uint64_t v6 = &v5[4 * a2];
      do
      {
        void *v5 = 0xFFFFFFFFLL;
        v5[1] = 0;
        void v5[2] = 0;
        v5[3] = 0;
        v5 += 4;
      }
      while (v5 != v6);
      unint64_t v5 = v6;
    }
    a1[1] = (uint64_t)v5;
  }
}

uint64_t sub_1CD5C66FC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)(a1 + 6) = *(uint64_t *)((char *)a2 + 6);
  *(void *)a1 = v4;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  sub_1CB906CCC((void *)(a1 + 16), a2[2], a2[3], 0xAAAAAAAAAAAAAAABLL * ((a2[3] - a2[2]) >> 3));
  *(unsigned char *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = *((unsigned char *)a2 + 40);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = 0;
  sub_1CC5C65D0((void *)(a1 + 48), a2[6], a2[7], (a2[7] - a2[6]) >> 5);
  *(_DWORD *)(a1 + 72) = *((_DWORD *)a2 + 18);
  return a1;
}

void *sub_1CD5C6788(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v6;
      *(void *)(v4 + sub_1CD521E44((uint64_t)this + 8) = 0;
      *(void *)(v4 + 16) = 0;
      *(void *)(v4 + 24) = 0;
      uint64_t result = sub_1CB906CCC((void *)(v4 + 8), *(void *)(v6 + 8), *(void *)(v6 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v6 + 16) - *(void *)(v6 + 8)) >> 3));
      v4 += 32;
      v6 += 32;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

uint64_t llvm::Instruction::copyFastMathFlags(uint64_t result, char a2)
{
  *(unsigned char *)(result + 17) = *(unsigned char *)(result + 17) & 1 | (2 * a2);
  return result;
}

uint64_t llvm::Instruction::hasAtomicStore(llvm::Instruction *this)
{
  return (*((unsigned __int8 *)this + 16) - 61 < 5) & (0x19u >> (*((unsigned char *)this + 16) - 61));
}

uint64_t sub_1CD5C6840(uint64_t result, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = (void *)(result - 64);
    if (*(void *)(result - 64))
    {
      **(void **)(result - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(result - 56);
      uint64_t v4 = *(void *)(result - 56);
      if (v4) {
        *(void *)(v4 + 16) = *(void *)(result - 48);
      }
    }
    *uint64_t v3 = a3;
    if (a3)
    {
      uint64_t v7 = *(void *)(a3 + 8);
      unint64_t v5 = (void *)(a3 + 8);
      uint64_t v6 = v7;
      *(void *)(result - 56) = v7;
      if (v7) {
        *(void *)(v6 + 16) = result - 56;
      }
      *(void *)(result - 4sub_1CD521E44((uint64_t)this + 8) = v5;
LABEL_9:
      void *v5 = v3;
    }
  }
  else
  {
    uint64_t v3 = (void *)(result - 96);
    if (*(void *)(result - 96))
    {
      **(void **)(result - 8llvm::MDNode::dumpTree(this, 0) = *(void *)(result - 88);
      uint64_t v8 = *(void *)(result - 88);
      if (v8) {
        *(void *)(v8 + 16) = *(void *)(result - 80);
      }
    }
    *uint64_t v3 = a3;
    if (a3)
    {
      uint64_t v10 = *(void *)(a3 + 8);
      unint64_t v5 = (void *)(a3 + 8);
      uint64_t v9 = v10;
      *(void *)(result - 8sub_1CD521E44((uint64_t)this + 8) = v10;
      if (v10) {
        *(void *)(v9 + 16) = result - 88;
      }
      *(void *)(result - 8llvm::MDNode::dumpTree(this, 0) = v5;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t sub_1CD5C68D4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result - 32 * *(unsigned int *)(result + 80);
  uint64_t v4 = *(void *)(v2 - 64);
  uint64_t v3 = v2 - 64;
  if (v4)
  {
    **(void **)(v3 + 16) = *(void *)(v3 + 8);
    uint64_t v5 = *(void *)(v3 + 8);
    if (v5) {
      *(void *)(v5 + 16) = *(void *)(v3 + 16);
    }
  }
  *(void *)uint64_t v3 = a2;
  if (a2)
  {
    uint64_t v8 = *(void *)(a2 + 8);
    uint64_t v6 = (void *)(a2 + 8);
    uint64_t v7 = v8;
    *(void *)(v3 + sub_1CD521E44((uint64_t)this + 8) = v8;
    if (v8) {
      *(void *)(v7 + 16) = v3 + 8;
    }
    *(void *)(v3 + 16) = v6;
    *uint64_t v6 = v3;
  }
  return result;
}

llvm::BlockAddress **sub_1CD5C6928(unsigned int *a1, llvm::BasicBlock *a2, void *a3)
{
  unsigned int v4 = a2;
  uint64_t result = llvm::CallBrInst::updateArgBlockAddresses((llvm::CallBrInst *)a1, a2, (llvm::BasicBlock *)a3);
  uint64_t v7 = (uint64_t)&a1[-8 * a1[20] - 8];
  uint64_t v8 = (void *)(v7 + 32 * v4);
  uint64_t v9 = v8;
  if (*v8)
  {
    BOOL v11 = (void *)v8[2];
    uint64_t v10 = v8 + 2;
    *BOOL v11 = *(v10 - 1);
    uint64_t v12 = *(v10 - 1);
    if (v12) {
      *(void *)(v12 + 16) = *v10;
    }
  }
  *uint64_t v9 = a3;
  if (a3)
  {
    uint64_t v15 = a3[1];
    uint64_t v14 = a3 + 1;
    uint64_t v13 = v15;
    uint64_t v16 = v7 + 32 * v4;
    *(void *)(v16 + sub_1CD521E44((uint64_t)this + 8) = v15;
    if (v15) {
      *(void *)(v13 + 16) = v16 + 8;
    }
    *(void *)(v16 + 16) = v14;
    *uint64_t v14 = v9;
  }
  return result;
}

llvm::LandingPadInst *llvm::LandingPadInst::LandingPadInst(llvm::LandingPadInst *this, llvm::Type *a2, unsigned int a3, const char **a4, llvm::Instruction *a5)
{
  uint64_t v8 = llvm::Instruction::Instruction(this, a2, 66, 0, 0, a5);
  *((_DWORD *)v8 + 15) = a3;
  *((_DWORD *)v8 + 5) &= 0xF8000000;
  uint64_t v9 = operator new(32 * a3);
  *((void *)this - 1) = v9;
  if (a3)
  {
    uint64_t v10 = &v9[4 * a3];
    do
    {
      *uint64_t v9 = 0;
      v9[1] = 0;
      void v9[2] = 0;
      void v9[3] = this;
      v9 += 4;
    }
    while (v9 != v10);
  }
  llvm::Value::setName(this, a4);
  *((_WORD *)this + 9) &= ~1u;
  return this;
}

llvm::LandingPadInst *llvm::LandingPadInst::LandingPadInst(llvm::LandingPadInst *this, llvm::Type *a2, unsigned int a3, const char **a4, llvm::BasicBlock *a5)
{
  uint64_t v8 = llvm::Instruction::Instruction(this, a2, 66, 0, 0, a5);
  *((_DWORD *)v8 + 15) = a3;
  *((_DWORD *)v8 + 5) &= 0xF8000000;
  uint64_t v9 = operator new(32 * a3);
  *((void *)this - 1) = v9;
  if (a3)
  {
    uint64_t v10 = &v9[4 * a3];
    do
    {
      *uint64_t v9 = 0;
      v9[1] = 0;
      void v9[2] = 0;
      void v9[3] = this;
      v9 += 4;
    }
    while (v9 != v10);
  }
  llvm::Value::setName(this, a4);
  *((_WORD *)this + 9) &= ~1u;
  return this;
}

uint64_t llvm::LandingPadInst::LandingPadInst(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 20);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(a1 + 16) = 94;
  *(unsigned char *)(a1 + 17) = 0;
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a1 + 20) & 0xC0000000 | v4 & 0x7FFFFFF;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 6llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  uint64_t v5 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  uint64_t v6 = operator new(32 * v5);
  *(void *)(a1 - sub_1CD521E44((uint64_t)this + 8) = v6;
  if (v5)
  {
    uint64_t v7 = v6;
    do
    {
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
      v7[3] = a1;
      v7 += 4;
    }
    while (v7 != &v6[4 * v5]);
  }
  int v8 = *(_DWORD *)(a1 + 20);
  if ((v8 & 0x40000000) != 0) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = (void *)(a1 - 32 * (v8 & 0x7FFFFFF));
  }
  int v10 = *(_DWORD *)(a2 + 20);
  if ((v10 & 0x40000000) != 0) {
    BOOL v11 = *(uint64_t **)(a2 - 8);
  }
  else {
    BOOL v11 = (uint64_t *)(a2 - 32 * (v10 & 0x7FFFFFF));
  }
  uint64_t v12 = *(unsigned int *)(a1 + 60);
  if (v12)
  {
    uint64_t v13 = (void **)(v9 + 1);
    do
    {
      uint64_t v14 = v13 - 1;
      uint64_t v15 = *v11;
      if (*(v13 - 1))
      {
        *v13[1] = *v13;
        if (*v13) {
          (*v13)[2] = v13[1];
        }
      }
      *uint64_t v14 = v15;
      if (v15)
      {
        uint64_t v18 = *(void **)(v15 + 8);
        uint64_t v16 = (void *)(v15 + 8);
        uint64_t v17 = v18;
        *uint64_t v13 = v18;
        if (v18) {
          void v17[2] = v13;
        }
        v13[1] = v16;
        *uint64_t v16 = v14;
      }
      v13 += 4;
      v11 += 4;
      --v12;
    }
    while (v12);
  }
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(a1 + 18) & 0xFFFE | *(_WORD *)(a2 + 18) & 1;
  return a1;
}

llvm::LandingPadInst *llvm::LandingPadInst::Create(llvm::LandingPadInst *this, llvm::Type *a2, const char **a3, const llvm::Twine *a4, llvm::Instruction *a5)
{
  unsigned int v7 = a2;
  uint64_t v9 = operator new(0x48uLL);
  v9[7] = v9[7] & 0x38000000 | 0x40000000;
  *(void *)uint64_t v9 = 0;
  int v10 = (llvm::LandingPadInst *)(v9 + 2);

  return llvm::LandingPadInst::LandingPadInst(v10, this, v7, a3, a4);
}

llvm::LandingPadInst *llvm::LandingPadInst::Create(llvm::LandingPadInst *this, llvm::Type *a2, const char **a3, const llvm::Twine *a4, llvm::BasicBlock *a5)
{
  unsigned int v7 = a2;
  uint64_t v9 = operator new(0x48uLL);
  v9[7] = v9[7] & 0x38000000 | 0x40000000;
  *(void *)uint64_t v9 = 0;
  int v10 = (llvm::LandingPadInst *)(v9 + 2);

  return llvm::LandingPadInst::LandingPadInst(v10, this, v7, a3, a4);
}

char *llvm::CallBase::Create(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Instruction *a4)
{
  int v4 = *(unsigned __int8 *)(a1 + 16);
  if (v4 == 33) {
    return llvm::InvokeInst::Create((llvm::Value *)a1, a2, a3, a4);
  }
  if (v4 == 39) {
    return llvm::CallBrInst::Create(a1, a2, a3, a4);
  }
  return (char *)llvm::CallInst::Create(a1, a2, a3, (uint64_t)a4);
}

uint64_t llvm::CallInst::Create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 + 20);
  uint64_t v9 = v8 & 0x7FFFFFF;
  int v10 = (void *)(a1 - 32 * v9);
  int v11 = *(unsigned __int8 *)(a1 + 16);
  if (v11 == 84)
  {
    uint64_t v12 = 0;
  }
  else if (v11 == 39)
  {
    uint64_t v12 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v12 = 2;
  }
  if (v8 < 0 && (uint64_t v28 = *(v10 - 1), (v28 & 0xFFFFFFFF0) != 0)) {
    uint64_t v13 = (*((_DWORD *)v10 - 3) - *(_DWORD *)((char *)v10 - v28));
  }
  else {
    uint64_t v13 = 0;
  }
  unint64_t v14 = -32 * v12 - 32 - 32 * v13 - -32 * v9;
  if (v14)
  {
    if ((v14 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v15 = (uint64_t *)operator new(v14 >> 2);
    uint64_t v16 = v15;
    uint64_t v17 = 0;
    uint64_t v18 = 32 * v9 - 32 * v12 - 32 * v13 - 32;
    do
    {
      uint64_t v19 = *v10;
      v10 += 4;
      v15[v17++] = v19;
      v18 -= 32;
    }
    while (v18);
    unint64_t v14 = (unint64_t)&v15[v17];
  }
  else
  {
    uint64_t v16 = 0;
  }
  uint64_t v20 = *(uint64_t ***)(a1 + 72);
  unint64_t v21 = *(uint64_t ***)(a1 - 32);
  uint64_t v22 = (uint64_t)(v14 - (void)v16) >> 3;
  __int16 v31 = 261;
  v30[0] = llvm::Value::getName((llvm::Value *)a1);
  v30[1] = v23;
  uint64_t v24 = sub_1CC19A3E0(v20, v21, v16, v22, a2, a3, v30, a4);
  __int16 v25 = *(_WORD *)(v24 + 18) & 0xFFFC | *(_WORD *)(a1 + 18) & 3;
  *(_WORD *)(v24 + 1sub_1CD521E44((uint64_t)this + 8) = v25;
  *(_WORD *)(v24 + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(a1 + 18) & 0xFFC | v25 & 0xF003;
  *(unsigned char *)(v24 + 17) = *(unsigned char *)(a1 + 17) & 0xFE | *(unsigned char *)(v24 + 17) & 1;
  *(void *)(v24 + 64) = *(void *)(a1 + 64);
  uint64_t v26 = *(unsigned __int8 **)(a1 + 48);
  uint64_t v29 = v26;
  if (v26) {
    llvm::MetadataTracking::track((uint64_t)&v29, v26, 2);
  }
  sub_1CB8F69CC((unsigned __int8 **)(v24 + 48), &v29);
  if (v29) {
    llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
  }
  if (v16) {
    operator delete(v16);
  }
  return v24;
}

char *llvm::InvokeInst::Create(llvm::Value *this, uint64_t a2, uint64_t a3, llvm::Instruction *a4)
{
  int v8 = *((_DWORD *)this + 5);
  uint64_t v9 = v8 & 0x7FFFFFF;
  int v10 = (void *)((char *)this - 32 * v9);
  int v11 = *((unsigned __int8 *)this + 16);
  if (v11 == 84)
  {
    uint64_t v12 = 0;
  }
  else if (v11 == 39)
  {
    uint64_t v12 = (*((_DWORD *)this + 20) + 1);
  }
  else
  {
    uint64_t v12 = 2;
  }
  if (v8 < 0 && (uint64_t v29 = *(v10 - 1), (v29 & 0xFFFFFFFF0) != 0)) {
    uint64_t v13 = (*((_DWORD *)v10 - 3) - *(_DWORD *)((char *)v10 - v29));
  }
  else {
    uint64_t v13 = 0;
  }
  unint64_t v14 = -32 * v12 - 32 - 32 * v13 - -32 * v9;
  if (v14)
  {
    if ((v14 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v16 = (uint64_t *)operator new(v14 >> 2);
    uint64_t v15 = v16;
    uint64_t v17 = 0;
    uint64_t v18 = 32 * v9 - 32 * v12 - 32 * v13 - 32;
    do
    {
      uint64_t v19 = *v10;
      v10 += 4;
      v16[v17++] = v19;
      v18 -= 32;
    }
    while (v18);
    unint64_t v14 = (unint64_t)&v16[v17];
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v20 = *((void *)this + 9);
  uint64_t v21 = *((void *)this - 4);
  uint64_t v22 = *((void *)this - 12);
  uint64_t v23 = *((void *)this - 8);
  uint64_t v24 = (uint64_t)(v14 - (void)v15) >> 3;
  __int16 v32 = 261;
  v31[0] = llvm::Value::getName(this);
  v31[1] = v25;
  uint64_t v26 = sub_1CD4EF89C(v20, v21, v22, v23, v15, v24, a2, a3, v31, a4);
  *((_WORD *)v26 + 9) = *((_WORD *)v26 + 9) & 0xF003 | *((_WORD *)this + 9) & 0xFFC;
  v26[17] = *((unsigned char *)this + 17) & 0xFE | v26[17] & 1;
  *((void *)v26 + sub_1CD521E44((uint64_t)this + 8) = *((void *)this + 8);
  uint64_t v27 = (unsigned __int8 *)*((void *)this + 6);
  int v30 = v27;
  if (v27) {
    llvm::MetadataTracking::track((uint64_t)&v30, v27, 2);
  }
  sub_1CB8F69CC((unsigned __int8 **)v26 + 6, &v30);
  if (v30) {
    llvm::MetadataTracking::untrack((uint64_t)&v30, v30);
  }
  if (v15) {
    operator delete(v15);
  }
  return v26;
}

char *llvm::CallBrInst::Create(uint64_t a1, uint64_t a2, uint64_t a3, llvm::Instruction *a4)
{
  uint64_t v37[16] = *MEMORY[0x1E4F143B8];
  int v7 = *(_DWORD *)(a1 + 20);
  uint64_t v8 = v7 & 0x7FFFFFF;
  uint64_t v9 = (void *)(a1 - 32 * v8);
  int v10 = *(unsigned __int8 *)(a1 + 16);
  if (v10 == 84)
  {
    uint64_t v11 = 0;
  }
  else if (v10 == 39)
  {
    uint64_t v11 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v11 = 2;
  }
  if (v7 < 0 && (uint64_t v30 = *(v9 - 1), (v30 & 0xFFFFFFFF0) != 0)) {
    uint64_t v12 = (*((_DWORD *)v9 - 3) - *(_DWORD *)((char *)v9 - v30));
  }
  else {
    uint64_t v12 = 0;
  }
  unint64_t v13 = -32 * v11 - 32 - 32 * v12 - -32 * v8;
  if (v13)
  {
    if ((v13 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v16 = (uint64_t *)operator new(v13 >> 2);
    unint64_t v14 = v16;
    uint64_t v17 = 0;
    uint64_t v18 = 32 * v8 - 32 * v11 - 32 * v12 - 32;
    do
    {
      uint64_t v19 = *v9;
      v9 += 4;
      v16[v17++] = v19;
      v18 -= 32;
    }
    while (v18);
    uint64_t v15 = &v16[v17];
  }
  else
  {
    unint64_t v14 = 0;
    uint64_t v15 = 0;
  }
  uint64_t v20 = *(void *)(a1 + 72);
  uint64_t v21 = *(void *)(a1 - 32);
  uint64_t v22 = *(void *)(a1 - 32 - 32 * *(unsigned int *)(a1 + 80) - 32);
  sub_1CD5C85DC(a1, (uint64_t)&v35);
  uint64_t v23 = v35;
  int v24 = v36;
  __int16 v34 = 261;
  v33[0] = llvm::Value::getName((llvm::Value *)a1);
  v33[1] = v25;
  uint64_t v27 = sub_1CD4EFB0C(v20, v21, v22, (uint64_t)v23, v24, v14, v15 - v14, v26, a2, a3, v33, a4);
  if (v35 != v37) {
    free(v35);
  }
  *((_WORD *)v27 + 9) = *((_WORD *)v27 + 9) & 0xF003 | *(_WORD *)(a1 + 18) & 0xFFC;
  v27[17] = *(unsigned char *)(a1 + 17) & 0xFE | v27[17] & 1;
  *((void *)v27 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a1 + 64);
  uint64_t v28 = *(unsigned __int8 **)(a1 + 48);
  __int16 v32 = v28;
  if (v28) {
    llvm::MetadataTracking::track((uint64_t)&v32, v28, 2);
  }
  sub_1CB8F69CC((unsigned __int8 **)v27 + 6, &v32);
  if (v32) {
    llvm::MetadataTracking::untrack((uint64_t)&v32, v32);
  }
  *((_DWORD *)v27 + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a1 + 80);
  if (v14) {
    operator delete(v14);
  }
  return v27;
}

char *llvm::CallBase::Create(uint64_t a1, unsigned char *a2, llvm::Instruction *a3)
{
  v31[12] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = v31;
  uint64_t v30 = 0x200000000;
  int v5 = *(_DWORD *)(a1 + 20);
  if (v5 < 0)
  {
    unint64_t v11 = *(void *)(a1 - 32 * (v5 & 0x7FFFFFF) - 8);
    if ((v11 & 0xFFFFFFFF0) != 0)
    {
      uint64_t v12 = (v11 >> 4);
      uint64_t v13 = a1;
      uint64_t v27 = a2;
      do
      {
        uint64_t v14 = *(_DWORD *)(a1 + 20) & 0x7FFFFFF;
        uint64_t v15 = a1 - 32 * v14;
        uint64_t v16 = (unsigned int *)(v13 - (*(void *)(v15 - 8) + 32 * v14));
        uint64_t v17 = *v16;
        uint64_t v18 = v16[1];
        uint64_t v19 = (size_t *)*((void *)v16 - 1);
        v28[0] = v15 + 32 * v17;
        v28[1] = v18 - v17;
        v28[2] = v19;
        size_t v22 = *v19;
        uint64_t v20 = v19 + 2;
        size_t v21 = v22;
        char v23 = a2[23];
        BOOL v24 = v23 < 0;
        uint64_t v25 = *((void *)a2 + 1);
        if (v23 < 0) {
          a2 = *(unsigned char **)a2;
        }
        uint64_t v26 = v23 & 0x7F;
        if (v24) {
          uint64_t v26 = v25;
        }
        if (v21 != v26 || v21 && memcmp(v20, a2, v21)) {
          sub_1CD5C74F0((uint64_t)&v29, (uint64_t)v28);
        }
        v13 += 16;
        --v12;
        a2 = v27;
      }
      while (v12);
    }
  }
  sub_1CD5C7564((uint64_t)&v29, (long long *)a2);
  uint64_t v6 = llvm::CallBase::Create(a1, (uint64_t)v29, v30, a3);
  int v7 = v29;
  if (v30)
  {
    uint64_t v8 = 48 * v30;
    uint64_t v9 = (char *)v29 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v9[v8]);
      v8 -= 48;
    }
    while (v8);
    int v7 = v29;
  }
  if (v7 != v31) {
    free(v7);
  }
  return v6;
}

uint64_t sub_1CD5C74F0(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD5CAB44();
  }
  sub_1CD506FC4(*(void *)a1 + 48 * v3, a2);
  unsigned int v4 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4;
  return *(void *)a1 + 48 * v4 - 48;
}

uint64_t sub_1CD5C7564(uint64_t a1, long long *a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD5CABE0();
  }
  sub_1CD5C4920(*(void *)a1 + 48 * v3, a2);
  unsigned int v4 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4;
  return *(void *)a1 + 48 * v4 - 48;
}

uint64_t llvm::CallBase::getNumSubclassExtraOperandsDynamic(llvm::CallBase *this)
{
  return (*((_DWORD *)this + 20) + 1);
}

char *llvm::CallBase::getBundleOpInfoForOperand(char *this, unsigned int a2)
{
  int v2 = *((_DWORD *)this + 5);
  if (v2 < 0)
  {
    unsigned int v3 = &this[-32 * (v2 & 0x7FFFFFF)];
    uint64_t v6 = *((void *)v3 - 1);
    unsigned int v4 = v3 - 8;
    uint64_t v5 = v6;
    int v7 = &v4[-v6];
    if (v6 > 127)
    {
      if (v5)
      {
        do
        {
          if (&v7[16
                 * (((a2 - *((_DWORD *)v7 + 2)) << 10)
                  / (((*((_DWORD *)v4 - 1) - *((_DWORD *)v7 + 2)) << 10) / ((v4 - v7) >> 4)))] >= v4)
            this = v4 - 16;
          else {
            this = &v7[16
          }
                     * (((a2 - *((_DWORD *)v7 + 2)) << 10)
                      / (((*((_DWORD *)v4 - 1) - *((_DWORD *)v7 + 2)) << 10)
                                     / ((v4 - v7) >> 4)))];
          unsigned int v9 = *((_DWORD *)this + 3);
          if (*((_DWORD *)this + 2) <= a2 && v9 > a2) {
            break;
          }
          if (v9 > a2) {
            unsigned int v4 = this;
          }
          else {
            int v7 = this + 16;
          }
        }
        while (v7 != v4);
      }
      else
      {
        return v7;
      }
    }
    else if (v5)
    {
      do
      {
        while (1)
        {
          this = v7;
          if (*((_DWORD *)v7 + 2) <= a2) {
            break;
          }
          v7 += 16;
          if (this + 16 == v4) {
            return this;
          }
        }
        v7 += 16;
      }
      while (*((_DWORD *)this + 3) <= a2 && v7 != v4);
    }
  }
  return this;
}

char *llvm::CallBase::addOperandBundle(char *a1, uint64_t a2, unint64_t a3, llvm::Instruction *a4)
{
  uint64_t v6 = a1;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  sub_1CC233A58(a1, a2, (uint64_t *)&v12);
  if (!v14[8])
  {
    uint64_t v12 = v14;
    uint64_t v13 = 0x100000000;
    llvm::CallBase::getOperandBundlesAsDefs((uint64_t)v6, (uint64_t)&v12);
    uint64_t v8 = (long long *)sub_1CD506EE8((uint64_t)&v12, a3, 1);
    sub_1CD5C4920((uint64_t)v12 + 48 * v13, v8);
    LODWORD(v13) = v13 + 1;
    uint64_t v6 = llvm::CallBase::Create((uint64_t)v6, (uint64_t)v12, v13, a4);
    unsigned int v9 = v12;
    if (v13)
    {
      uint64_t v10 = 48 * v13;
      unint64_t v11 = (char *)v12 - 48;
      do
      {
        sub_1CD4AF9B4((uint64_t)&v11[v10]);
        v10 -= 48;
      }
      while (v10);
      unsigned int v9 = v12;
    }
    if (v9 != v14) {
      free(v9);
    }
  }
  return v6;
}

char *llvm::CallBase::removeOperandBundle(llvm::CallBase *this, llvm::CallBase *a2, llvm::Instruction *a3, llvm::Instruction *a4)
{
  unsigned int v4 = (char *)this;
  v27[6] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = v27;
  uint64_t v26 = 0x100000000;
  int v5 = *((_DWORD *)this + 5);
  if (v5 < 0)
  {
    int v23 = (int)a2;
    unint64_t v10 = *((void *)this - 4 * (v5 & 0x7FFFFFF) - 1);
    if ((v10 & 0xFFFFFFFF0) != 0)
    {
      uint64_t v11 = 0;
      char v12 = 0;
      uint64_t v13 = -(uint64_t)(v10 >> 4);
LABEL_11:
      uint64_t v14 = &v4[16 * v11++];
      do
      {
        uint64_t v15 = *((_DWORD *)v4 + 5) & 0x7FFFFFF;
        uint64_t v16 = &v4[-32 * v15];
        uint64_t v17 = &v14[-*((void *)v16 - 1) + -32 * v15];
        uint64_t v18 = *(unsigned int *)v17;
        uint64_t v19 = &v16[32 * v18];
        uint64_t v20 = *((unsigned int *)v17 + 1) - v18;
        uint64_t v21 = *((void *)v17 - 1);
        v24[0] = v19;
        v24[1] = v20;
        void v24[2] = v21;
        if (*(_DWORD *)(v21 + 8) == v23)
        {
          char v12 = 1;
          if (v13 + v11) {
            goto LABEL_11;
          }
          goto LABEL_18;
        }
        v14 += 16;
        sub_1CD5C74F0((uint64_t)&v25, (uint64_t)v24);
        ++v11;
      }
      while (v13 + v11 != 1);
      if ((v12 & 1) == 0) {
        goto LABEL_2;
      }
LABEL_18:
      unsigned int v4 = llvm::CallBase::Create((uint64_t)v4, (uint64_t)v25, v26, a3);
    }
  }
LABEL_2:
  uint64_t v6 = v25;
  if (v26)
  {
    uint64_t v7 = 48 * v26;
    uint64_t v8 = (char *)v25 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v8[v7]);
      v7 -= 48;
    }
    while (v7);
    uint64_t v6 = v25;
  }
  if (v6 != v27) {
    free(v6);
  }
  return v4;
}

void llvm::CallInst::init(llvm::CallInst *this, llvm::FunctionType *a2, llvm::Value *a3, const char **a4)
{
  unsigned int v4 = (void *)((char *)this - 32);
  uint64_t v5 = *((void *)this - 4);
  *((void *)this + 9) = a2;
  if (v5)
  {
    **((void **)this - 2) = *((void *)this - 3);
    uint64_t v6 = *((void *)this - 3);
    if (v6) {
      *(void *)(v6 + 16) = *((void *)this - 2);
    }
  }
  *unsigned int v4 = a3;
  if (a3)
  {
    uint64_t v9 = *((void *)a3 + 1);
    uint64_t v7 = (void *)((char *)a3 + 8);
    uint64_t v8 = v9;
    *((void *)this - 3) = v9;
    if (v9) {
      *(void *)(v8 + 16) = (char *)this - 24;
    }
    *((void *)this - 2) = v7;
    *uint64_t v7 = v4;
  }
  llvm::Value::setName(this, a4);
}

llvm::CallInst *llvm::CallInst::CallInst(llvm::CallInst *this, llvm::Type ***a2, llvm::Value *a3, const char **a4, llvm::Instruction *a5)
{
  uint64_t v9 = llvm::Instruction::Instruction(this, *a2[2], 56, (llvm::CallInst *)((char *)this - 32), 1, a5);
  *((void *)v9 + sub_1CD521E44((uint64_t)this + 8) = 0;
  llvm::CallInst::init(v9, (llvm::FunctionType *)a2, a3, a4);
  return this;
}

llvm::CallInst *llvm::CallInst::CallInst(llvm::CallInst *this, llvm::Type ***a2, llvm::Value *a3, const char **a4, llvm::BasicBlock *a5)
{
  uint64_t v9 = llvm::Instruction::Instruction(this, *a2[2], 56, (llvm::CallInst *)((char *)this - 32), 1, a5);
  *((void *)v9 + sub_1CD521E44((uint64_t)this + 8) = 0;
  llvm::CallInst::init(v9, (llvm::FunctionType *)a2, a3, a4);
  return this;
}

uint64_t llvm::CallInst::updateProfWeight(uint64_t this, unint64_t a2, uint64_t a3)
{
  unsigned int v4 = (uint64_t **)this;
  void v15[3] = *MEMORY[0x1E4F143B8];
  if (*(void *)(this + 48) || (*(unsigned char *)(this + 23) & 0x20) != 0)
  {
    this = llvm::Instruction::getMetadataImpl((llvm::Instruction *)this, 2);
    if (this)
    {
      uint64_t v5 = this;
      uint64_t v6 = *(llvm::MDString **)(this - 8 * *(unsigned int *)(this + 8));
      if (!*(unsigned char *)v6)
      {
        this = llvm::MDString::getString(*(llvm::MDString **)(this - 8 * *(unsigned int *)(this + 8)));
        if (v7 == 14
          && (*(void *)this == 0x775F68636E617262 ? (BOOL v8 = *(void *)(this + 6) == 0x737468676965775FLL) : (BOOL v8 = 0),
              v8))
        {
          if (!a3) {
            return this;
          }
        }
        else
        {
          this = llvm::MDString::getString(v6);
          if (v9 != 2 || !a3 || *(_WORD *)this != 20566) {
            return this;
          }
        }
        uint64_t v12 = **v4;
        uint64_t v13 = v15;
        v15[0] = *(void *)(v5 - 8 * *(unsigned int *)(v5 + 8));
        uint64_t v14 = 0x300000001;
        int v11 = 128;
        llvm::APInt::initSlowCase((llvm::APInt *)&v10);
      }
    }
  }
  return this;
}

void llvm::InvokeInst::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const char **a11)
{
  unsigned int v11 = a7;
  *(void *)(a1 + 72) = a2;
  sub_1CC5716C8((uint64_t)&v31, a6, &a6[a7], a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
  uint64_t v16 = (void *)(a1 - 96);
  if (*(void *)(a1 - 96))
  {
    **(void **)(a1 - 8llvm::MDNode::dumpTree(this, 0) = *(void *)(a1 - 88);
    uint64_t v17 = *(void *)(a1 - 88);
    if (v17) {
      *(void *)(v17 + 16) = *(void *)(a1 - 80);
    }
  }
  *uint64_t v16 = a4;
  if (a4)
  {
    uint64_t v20 = *(void *)(a4 + 8);
    uint64_t v19 = (void *)(a4 + 8);
    uint64_t v18 = v20;
    *(void *)(a1 - 8sub_1CD521E44((uint64_t)this + 8) = v20;
    if (v20) {
      *(void *)(v18 + 16) = a1 - 88;
    }
    *(void *)(a1 - 8llvm::MDNode::dumpTree(this, 0) = v19;
    *uint64_t v19 = v16;
  }
  uint64_t v21 = (void *)(a1 - 64);
  if (*(void *)(a1 - 64))
  {
    **(void **)(a1 - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(a1 - 56);
    uint64_t v22 = *(void *)(a1 - 56);
    if (v22) {
      *(void *)(v22 + 16) = *(void *)(a1 - 48);
    }
  }
  *uint64_t v21 = a5;
  if (a5)
  {
    uint64_t v25 = *(void *)(a5 + 8);
    BOOL v24 = (void *)(a5 + 8);
    uint64_t v23 = v25;
    *(void *)(a1 - 56) = v25;
    if (v25) {
      *(void *)(v23 + 16) = a1 - 56;
    }
    *(void *)(a1 - 4sub_1CD521E44((uint64_t)this + 8) = v24;
    void *v24 = v21;
  }
  uint64_t v26 = (void *)(a1 - 32);
  if (*(void *)(a1 - 32))
  {
    **(void **)(a1 - 16) = *(void *)(a1 - 24);
    uint64_t v27 = *(void *)(a1 - 24);
    if (v27) {
      *(void *)(v27 + 16) = *(void *)(a1 - 16);
    }
  }
  *uint64_t v26 = a3;
  if (a3)
  {
    uint64_t v30 = *(void *)(a3 + 8);
    uint64_t v29 = (void *)(a3 + 8);
    uint64_t v28 = v30;
    *(void *)(a1 - 24) = v30;
    if (v30) {
      *(void *)(v28 + 16) = a1 - 24;
    }
    *(void *)(a1 - 16) = v29;
    *uint64_t v29 = v26;
  }
  llvm::CallBase::populateBundleOperandInfos(a1, a9, a10, v11);
  llvm::Value::setName((llvm::Value *)a1, a11);
}

uint64_t llvm::InvokeInst::InvokeInst(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 72);
  uint64_t v5 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(a1 + 16) = 33;
  *(unsigned char *)(a1 + 17) = 0;
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a1 + 20) & 0xC0000000 | v5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v4;
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(a2 + 18) & 0xFFC;
  sub_1CC5E4108((uint64_t)&v14, (uint64_t *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)), (uint64_t *)a2, a1 - 32 * v5);
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = *(_DWORD *)(a2 + 20);
  if (v8 < 0)
  {
    uint64_t v9 = a2 - 32 * (v8 & 0x7FFFFFF);
    uint64_t v10 = *(void *)(v9 - 8);
    uint64_t v7 = (unsigned char *)(v9 - 8);
    uint64_t v6 = &v7[-v10];
  }
  int v11 = *(_DWORD *)(a1 + 20);
  if (v11 < 0) {
    uint64_t v12 = (void *)(a1 - 32 * (v11 & 0x7FFFFFF) - 8 - *(void *)(a1 - 32 * (v11 & 0x7FFFFFF) - 8));
  }
  else {
    uint64_t v12 = 0;
  }
  if (v7 != v6) {
    memmove(v12, v6, v7 - v6);
  }
  *(unsigned char *)(a1 + 17) = *(unsigned char *)(a2 + 17) & 0xFE | *(unsigned char *)(a1 + 17) & 1;
  return a1;
}

uint64_t llvm::InvokeInst::getLandingPadInst(llvm::BasicBlock **this)
{
  return llvm::BasicBlock::getFirstNonPHI(*(this - 8));
}

void llvm::CallBrInst::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, const char **a11)
{
  unsigned int v11 = a8;
  *(void *)(a1 + 72) = a2;
  sub_1CC5716C8((uint64_t)&v23, a7, &a7[a8], a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
  *(_DWORD *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = a6;
  sub_1CD5C68D4(a1, a4);
  if (*(_DWORD *)(a1 + 80))
  {
    uint64_t v17 = 0;
    do
    {
      sub_1CD5C6928((unsigned int *)a1, v17, *(void **)(a5 + 8 * v17));
      uint64_t v17 = (llvm::BasicBlock *)(v17 + 1);
    }
    while (v17 != *(_DWORD *)(a1 + 80));
  }
  uint64_t v18 = (void *)(a1 - 32);
  if (*(void *)(a1 - 32))
  {
    **(void **)(a1 - 16) = *(void *)(a1 - 24);
    uint64_t v19 = *(void *)(a1 - 24);
    if (v19) {
      *(void *)(v19 + 16) = *(void *)(a1 - 16);
    }
  }
  *uint64_t v18 = a3;
  if (a3)
  {
    uint64_t v22 = *(void *)(a3 + 8);
    uint64_t v21 = (void *)(a3 + 8);
    uint64_t v20 = v22;
    *(void *)(a1 - 24) = v22;
    if (v22) {
      *(void *)(v20 + 16) = a1 - 24;
    }
    *(void *)(a1 - 16) = v21;
    *uint64_t v21 = v18;
  }
  llvm::CallBase::populateBundleOperandInfos(a1, a9, a10, v11);
  llvm::Value::setName((llvm::Value *)a1, a11);
}

llvm::BlockAddress **llvm::CallBrInst::updateArgBlockAddresses(llvm::CallBrInst *this, llvm::BasicBlock *a2, llvm::BasicBlock *a3)
{
  uint64_t result = (llvm::BlockAddress **)*((void *)this + 4 * a2 + -4 * *((unsigned int *)this + 20) - 4);
  if (result)
  {
    uint64_t v6 = llvm::BlockAddress::get(result, a2, a3);
    uint64_t v9 = llvm::BlockAddress::get((llvm::BlockAddress **)a3, v7, v8);
    uint64_t result = (llvm::BlockAddress **)sub_1CD5C8448((uint64_t)this);
    if (result)
    {
      uint64_t v10 = 0;
      uint64_t v11 = result;
      uint64_t v12 = this;
      do
      {
        uint64_t v13 = (llvm::BlockAddress *)*((void *)v12 - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
        if (*((unsigned char *)v13 + 16) != 4) {
          uint64_t v13 = 0;
        }
        if (v13 == v6) {
          uint64_t result = (llvm::BlockAddress **)LLVMSetArgOperand_0((uint64_t)this, v10, (uint64_t)v9);
        }
        ++v10;
        uint64_t v12 = (llvm::CallBrInst *)((char *)v12 + 32);
      }
      while (v11 != v10);
    }
  }
  return result;
}

unint64_t sub_1CD5C8448(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 16);
  if (v1 == 84)
  {
    uint64_t v2 = 0;
  }
  else if (v1 == 39)
  {
    uint64_t v2 = (*(_DWORD *)(a1 + 80) + 1);
  }
  else
  {
    uint64_t v2 = 2;
  }
  int v3 = 0;
  int v4 = *(_DWORD *)(a1 + 20);
  uint64_t v5 = -(uint64_t)(v4 & 0x7FFFFFF);
  if (v4 < 0)
  {
    uint64_t v7 = a1 - 32 * (v4 & 0x7FFFFFF);
    uint64_t v8 = *(void *)(v7 - 8);
    if ((v8 & 0xFFFFFFFF0) != 0) {
      int v3 = *(_DWORD *)(v7 - 12) - *(_DWORD *)(v7 - v8);
    }
    else {
      int v3 = 0;
    }
  }
  return (-32 * v2 + 32 * (unint64_t)-v3 - 32 * v5 - 32) >> 5;
}

uint64_t llvm::CallBrInst::CallBrInst(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 72);
  uint64_t v5 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(a1 + 16) = 39;
  *(unsigned char *)(a1 + 17) = 0;
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a1 + 20) & 0xC0000000 | v5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a1 + 72) = v4;
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(a2 + 18) & 0xFFC;
  sub_1CC5E4108((uint64_t)&v14, (uint64_t *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)), (uint64_t *)a2, a1 - 32 * v5);
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = *(_DWORD *)(a2 + 20);
  if (v8 < 0)
  {
    uint64_t v9 = a2 - 32 * (v8 & 0x7FFFFFF);
    uint64_t v10 = *(void *)(v9 - 8);
    uint64_t v7 = (unsigned char *)(v9 - 8);
    uint64_t v6 = &v7[-v10];
  }
  int v11 = *(_DWORD *)(a1 + 20);
  if (v11 < 0) {
    uint64_t v12 = (void *)(a1 - 32 * (v11 & 0x7FFFFFF) - 8 - *(void *)(a1 - 32 * (v11 & 0x7FFFFFF) - 8));
  }
  else {
    uint64_t v12 = 0;
  }
  if (v7 != v6) {
    memmove(v12, v6, v7 - v6);
  }
  *(unsigned char *)(a1 + 17) = *(unsigned char *)(a2 + 17) & 0xFE | *(unsigned char *)(a1 + 17) & 1;
  *(_DWORD *)(a1 + 8llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a2 + 80);
  return a1;
}

uint64_t sub_1CD5C85DC@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0x1000000000;
  uint64_t v3 = *(unsigned int *)(result + 80);
  if (v3)
  {
    unsigned int v4 = 0;
    uint64_t v5 = result - 32;
    do
    {
      if (v4 >= *(_DWORD *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a2 + 8 * v4) = *(void *)(v5 - 32 * *(unsigned int *)(result + 80));
      unsigned int v4 = *(_DWORD *)(a2 + 8) + 1;
      *(_DWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v4;
      v5 += 32;
      --v3;
    }
    while (v3);
  }
  return result;
}

llvm::Instruction *llvm::ReturnInst::ReturnInst(llvm::ReturnInst *this, llvm::LLVMContext *a2, llvm::Value *a3, llvm::BasicBlock *a4)
{
  uint64_t v5 = (llvm::Type *)(*(void *)a2 + 1576);
  if (a3) {
    uint64_t v6 = -1;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t result = llvm::Instruction::Instruction(this, v5, 1, (llvm::ReturnInst *)((char *)this + 32 * v6), a3 != 0, a4);
  if (a3)
  {
    uint64_t v8 = *((_DWORD *)result + 5) & 0x7FFFFFF;
    uint64_t v9 = -v8;
    uint64_t v10 = (void *)((char *)result - 32 * v8);
    if (*v10)
    {
      int v11 = (char *)result + 32 * v9;
      uint64_t v13 = (void *)*((void *)v11 + 2);
      uint64_t v12 = v11 + 16;
      *uint64_t v13 = *(v12 - 1);
      uint64_t v14 = *(v12 - 1);
      if (v14) {
        *(void *)(v14 + 16) = *v12;
      }
    }
    void *v10 = a3;
    uint64_t v17 = *((void *)a3 + 1);
    uint64_t v16 = (void *)((char *)a3 + 8);
    uint64_t v15 = v17;
    uint64_t v18 = (char *)result + 32 * v9;
    *((void *)v18 + 1) = v17;
    if (v17) {
      *(void *)(v15 + 16) = v18 + 8;
    }
    *((void *)v18 + 2) = v16;
    *uint64_t v16 = v10;
  }
  return result;
}

llvm::Instruction *llvm::ReturnInst::ReturnInst(llvm::ReturnInst *this, llvm::LLVMContext *a2, llvm::BasicBlock *a3)
{
  return llvm::Instruction::Instruction(this, (llvm::Type *)(*(void *)a2 + 1576), 1, this, 0, a3);
}

uint64_t llvm::ResumeInst::ResumeInst(uint64_t result, void ***a2)
{
  uint64_t v2 = (void *)(result - 32);
  uint64_t v3 = *(void *)(result - 32);
  *(void *)uint64_t result = ***a2 + 1576;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(result + 16) = 34;
  *(unsigned char *)(result + 17) = 0;
  *(_WORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(result + 20) & 0xC0000000 | 1;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(result + 56) = 0;
  uint64_t v4 = (uint64_t)*(a2 - 4);
  if (v3)
  {
    **(void **)(result - 16) = *(void *)(result - 24);
    uint64_t v5 = *(void *)(result - 24);
    if (v5) {
      *(void *)(v5 + 16) = *(void *)(result - 16);
    }
  }
  *uint64_t v2 = v4;
  if (v4)
  {
    uint64_t v8 = *(void *)(v4 + 8);
    uint64_t v6 = (void *)(v4 + 8);
    uint64_t v7 = v8;
    *(void *)(result - 24) = v8;
    if (v8) {
      *(void *)(v7 + 16) = result - 24;
    }
    *(void *)(result - 16) = v6;
    *uint64_t v6 = v2;
  }
  return result;
}

llvm::Instruction *llvm::ResumeInst::ResumeInst(llvm::ResumeInst *this, llvm::Value *a2, llvm::Instruction *a3)
{
  uint64_t v4 = (char *)this - 32;
  uint64_t result = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a2 + 1576), 6, (llvm::ResumeInst *)((char *)this - 32), 1, a3);
  if (*((void *)result - 4))
  {
    **((void **)result - 2) = *((void *)result - 3);
    uint64_t v6 = *((void *)result - 3);
    if (v6) {
      *(void *)(v6 + 16) = *((void *)result - 2);
    }
  }
  *((void *)result - 4) = a2;
  uint64_t v9 = *((void *)a2 + 1);
  uint64_t v8 = (void *)((char *)a2 + 8);
  uint64_t v7 = v9;
  *((void *)result - 3) = v9;
  if (v9) {
    *(void *)(v7 + 16) = (char *)result - 24;
  }
  *((void *)result - 2) = v8;
  *uint64_t v8 = v4;
  return result;
}

llvm::Instruction *llvm::ResumeInst::ResumeInst(llvm::ResumeInst *this, llvm::Value *a2, llvm::BasicBlock *a3)
{
  uint64_t v4 = (char *)this - 32;
  uint64_t result = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a2 + 1576), 6, (llvm::ResumeInst *)((char *)this - 32), 1, a3);
  if (*((void *)result - 4))
  {
    **((void **)result - 2) = *((void *)result - 3);
    uint64_t v6 = *((void *)result - 3);
    if (v6) {
      *(void *)(v6 + 16) = *((void *)result - 2);
    }
  }
  *((void *)result - 4) = a2;
  uint64_t v9 = *((void *)a2 + 1);
  uint64_t v8 = (void *)((char *)a2 + 8);
  uint64_t v7 = v9;
  *((void *)result - 3) = v9;
  if (v9) {
    *(void *)(v7 + 16) = (char *)result - 24;
  }
  *((void *)result - 2) = v8;
  *uint64_t v8 = v4;
  return result;
}

uint64_t llvm::CleanupReturnInst::CleanupReturnInst(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  uint64_t v3 = -v2;
  *(void *)uint64_t result = *(void *)a2;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(result + 16) = 36;
  *(unsigned char *)(result + 17) = 0;
  *(_WORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(result + 20) & 0xC0000000 | v2;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(result + 56) = 0;
  *(_WORD *)(result + 1sub_1CD521E44((uint64_t)this + 8) = *(_WORD *)(a2 + 18) & 0x7FFF;
  uint64_t v4 = (void *)(result - 32 * v2);
  uint64_t v5 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF));
  if (*v4)
  {
    uint64_t v6 = result + 32 * v3;
    uint64_t v8 = *(void **)(v6 + 16);
    uint64_t v7 = (void *)(v6 + 16);
    *uint64_t v8 = *(v7 - 1);
    uint64_t v9 = *(v7 - 1);
    if (v9) {
      *(void *)(v9 + 16) = *v7;
    }
  }
  *uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v12 = *(void *)(v5 + 8);
    uint64_t v10 = (void *)(v5 + 8);
    uint64_t v11 = v12;
    uint64_t v13 = result + 32 * v3;
    *(void *)(v13 + sub_1CD521E44((uint64_t)this + 8) = v12;
    if (v12) {
      *(void *)(v11 + 16) = v13 + 8;
    }
    *(void *)(v13 + 16) = v10;
    void *v10 = v4;
  }
  if (*(_WORD *)(a2 + 18))
  {
    uint64_t v14 = result - 32 * (*(_DWORD *)(result + 20) & 0x7FFFFFF);
    uint64_t v15 = (void *)(v14 + 32);
    uint64_t v16 = *(void *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF) + 32);
    if (*(void *)(v14 + 32))
    {
      **(void **)(v14 + 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(v14 + 40);
      uint64_t v17 = *(void *)(v14 + 40);
      if (v17) {
        *(void *)(v17 + 16) = *(void *)(v14 + 48);
      }
    }
    *uint64_t v15 = v16;
    if (v16)
    {
      uint64_t v20 = *(void *)(v16 + 8);
      uint64_t v18 = (void *)(v16 + 8);
      uint64_t v19 = v20;
      *(void *)(v14 + 4llvm::MDNode::dumpTree(this, 0) = v20;
      if (v20) {
        *(void *)(v19 + 16) = v14 + 40;
      }
      *(void *)(v14 + 4sub_1CD521E44((uint64_t)this + 8) = v18;
      *uint64_t v18 = v15;
    }
  }
  return result;
}

uint64_t llvm::CleanupReturnInst::init(uint64_t this, llvm::Value *a2, llvm::BasicBlock *a3)
{
  if (a3)
  {
    *(_WORD *)(this + 18) |= 1u;
    uint64_t v3 = *(_DWORD *)(this + 20) & 0x7FFFFFF;
    uint64_t v4 = -v3;
    uint64_t v5 = (void *)(this - 32 * v3);
    if (*v5)
    {
      uint64_t v6 = this + 32 * v4;
      uint64_t v8 = *(void **)(v6 + 16);
      uint64_t v7 = (void *)(v6 + 16);
      *uint64_t v8 = *(v7 - 1);
      uint64_t v9 = *(v7 - 1);
      if (v9) {
        *(void *)(v9 + 16) = *v7;
      }
    }
    void *v5 = a2;
    if (a2)
    {
      uint64_t v12 = *((void *)a2 + 1);
      uint64_t v10 = (void *)((char *)a2 + 8);
      uint64_t v11 = v12;
      uint64_t v13 = this + 32 * v4;
      *(void *)(v13 + sub_1CD521E44((uint64_t)this + 8) = v12;
      if (v12) {
        *(void *)(v11 + 16) = v13 + 8;
      }
      *(void *)(v13 + 16) = v10;
      void *v10 = v5;
    }
    uint64_t v14 = this - 32 * (*(_DWORD *)(this + 20) & 0x7FFFFFF);
    if (*(void *)(v14 + 32))
    {
      **(void **)(v14 + 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(v14 + 40);
      uint64_t v15 = *(void *)(v14 + 40);
      if (v15) {
        *(void *)(v15 + 16) = *(void *)(v14 + 48);
      }
    }
    *(void *)(v14 + 32) = a3;
    uint64_t v18 = *((void *)a3 + 1);
    uint64_t v16 = (void *)((char *)a3 + 8);
    uint64_t v17 = v18;
    *(void *)(v14 + 4llvm::MDNode::dumpTree(this, 0) = v18;
    if (v18) {
      *(void *)(v17 + 16) = v14 + 40;
    }
    *(void *)(v14 + 4sub_1CD521E44((uint64_t)this + 8) = v16;
    *uint64_t v16 = v14 + 32;
  }
  else
  {
    uint64_t v19 = *(_DWORD *)(this + 20) & 0x7FFFFFF;
    uint64_t v20 = -v19;
    uint64_t v21 = (void *)(this - 32 * v19);
    if (*v21)
    {
      uint64_t v22 = this + 32 * v20;
      BOOL v24 = *(void **)(v22 + 16);
      char v23 = (void *)(v22 + 16);
      void *v24 = *(v23 - 1);
      uint64_t v25 = *(v23 - 1);
      if (v25) {
        *(void *)(v25 + 16) = *v23;
      }
    }
    *uint64_t v21 = a2;
    if (a2)
    {
      uint64_t v28 = *((void *)a2 + 1);
      uint64_t v26 = (void *)((char *)a2 + 8);
      uint64_t v27 = v28;
      uint64_t v29 = this + 32 * v20;
      *(void *)(v29 + sub_1CD521E44((uint64_t)this + 8) = v28;
      if (v28) {
        *(void *)(v27 + 16) = v29 + 8;
      }
      *(void *)(v29 + 16) = v26;
      *uint64_t v26 = v21;
    }
  }
  return this;
}

llvm::CleanupReturnInst *llvm::CleanupReturnInst::CleanupReturnInst(llvm::CleanupReturnInst *this, llvm::Value *a2, llvm::BasicBlock *a3, unsigned int a4, llvm::Instruction *a5)
{
  uint64_t v8 = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a2 + 1576), 8, (llvm::CleanupReturnInst *)((char *)this - 32 * a4), a4, a5);
  llvm::CleanupReturnInst::init((uint64_t)v8, a2, a3);
  return this;
}

llvm::CleanupReturnInst *llvm::CleanupReturnInst::CleanupReturnInst(llvm::CleanupReturnInst *this, llvm::Value *a2, llvm::BasicBlock *a3, unsigned int a4, llvm::BasicBlock *a5)
{
  uint64_t v8 = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a2 + 1576), 8, (llvm::CleanupReturnInst *)((char *)this - 32 * a4), a4, a5);
  llvm::CleanupReturnInst::init((uint64_t)v8, a2, a3);
  return this;
}

uint64_t llvm::CatchReturnInst::init(uint64_t this, llvm::Value *a2, llvm::BasicBlock *a3)
{
  uint64_t v3 = (void *)(this - 64);
  if (*(void *)(this - 64))
  {
    **(void **)(this - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(this - 56);
    uint64_t v4 = *(void *)(this - 56);
    if (v4) {
      *(void *)(v4 + 16) = *(void *)(this - 48);
    }
  }
  *uint64_t v3 = a2;
  if (a2)
  {
    uint64_t v7 = *((void *)a2 + 1);
    uint64_t v5 = (void *)((char *)a2 + 8);
    uint64_t v6 = v7;
    *(void *)(this - 56) = v7;
    if (v7) {
      *(void *)(v6 + 16) = this - 56;
    }
    *(void *)(this - 4sub_1CD521E44((uint64_t)this + 8) = v5;
    void *v5 = v3;
  }
  uint64_t v8 = (void *)(this - 32);
  if (*(void *)(this - 32))
  {
    **(void **)(this - 16) = *(void *)(this - 24);
    uint64_t v9 = *(void *)(this - 24);
    if (v9) {
      *(void *)(v9 + 16) = *(void *)(this - 16);
    }
  }
  *uint64_t v8 = a3;
  if (a3)
  {
    uint64_t v12 = *((void *)a3 + 1);
    uint64_t v10 = (void *)((char *)a3 + 8);
    uint64_t v11 = v12;
    *(void *)(this - 24) = v12;
    if (v12) {
      *(void *)(v11 + 16) = this - 24;
    }
    *(void *)(this - 16) = v10;
    void *v10 = v8;
  }
  return this;
}

uint64_t llvm::CatchReturnInst::CatchReturnInst(uint64_t this, const llvm::CatchReturnInst *a2)
{
  uint64_t v2 = (void *)(this - 64);
  uint64_t v3 = *(void *)(this - 64);
  *(void *)this = ***(void ***)a2 + 1576;
  *(void *)(this + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(this + 16) = 37;
  *(unsigned char *)(this + 17) = 0;
  *(_WORD *)(this + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(this + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(this + 20) & 0xC0000000 | 2;
  *(_OWORD *)(this + 24) = 0u;
  *(_OWORD *)(this + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(this + 56) = 0;
  uint64_t v4 = *((void *)a2 - 8);
  if (v3)
  {
    **(void **)(this - 4sub_1CD521E44((uint64_t)this + 8) = *(void *)(this - 56);
    uint64_t v5 = *(void *)(this - 56);
    if (v5) {
      *(void *)(v5 + 16) = *(void *)(this - 48);
    }
  }
  *uint64_t v2 = v4;
  if (v4)
  {
    uint64_t v8 = *(void *)(v4 + 8);
    uint64_t v6 = (void *)(v4 + 8);
    uint64_t v7 = v8;
    *(void *)(this - 56) = v8;
    if (v8) {
      *(void *)(v7 + 16) = this - 56;
    }
    *(void *)(this - 4sub_1CD521E44((uint64_t)this + 8) = v6;
    *uint64_t v6 = v2;
  }
  uint64_t v9 = (void *)(this - 32);
  uint64_t v10 = *((void *)a2 - 4);
  if (*(void *)(this - 32))
  {
    **(void **)(this - 16) = *(void *)(this - 24);
    uint64_t v11 = *(void *)(this - 24);
    if (v11) {
      *(void *)(v11 + 16) = *(void *)(this - 16);
    }
  }
  *uint64_t v9 = v10;
  if (v10)
  {
    uint64_t v14 = *(void *)(v10 + 8);
    uint64_t v12 = (void *)(v10 + 8);
    uint64_t v13 = v14;
    *(void *)(this - 24) = v14;
    if (v14) {
      *(void *)(v13 + 16) = this - 24;
    }
    *(void *)(this - 16) = v12;
    *uint64_t v12 = v9;
  }
  return this;
}

llvm::CatchReturnInst *llvm::CatchReturnInst::CatchReturnInst(llvm::CatchReturnInst *this, llvm::Value *a2, llvm::BasicBlock *a3, llvm::Instruction *a4)
{
  uint64_t v7 = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a3 + 1576), 9, (llvm::CatchReturnInst *)((char *)this - 64), 2, a4);
  llvm::CatchReturnInst::init((uint64_t)v7, a2, a3);
  return this;
}

llvm::CatchSwitchInst *llvm::CatchSwitchInst::CatchSwitchInst(llvm::CatchSwitchInst *this, llvm::Type **a2, llvm::BasicBlock *a3, int a4, const char **a5, llvm::Instruction *a6)
{
  uint64_t v11 = llvm::Instruction::Instruction(this, *a2, 10, 0, 0, a6);
  if (a3) {
    int v12 = a4 + 1;
  }
  else {
    int v12 = a4;
  }
  llvm::CatchSwitchInst::init(v11, (llvm::Value *)a2, a3, v12 + 1);
  llvm::Value::setName(this, a5);
  return this;
}

void *llvm::CatchSwitchInst::init(llvm::CatchSwitchInst *this, llvm::Value *a2, llvm::BasicBlock *a3, unsigned int a4)
{
  *((_DWORD *)this + 15) = a4;
  if (a3) {
    int v8 = 2;
  }
  else {
    int v8 = 1;
  }
  *((_DWORD *)this + 5) = *((_DWORD *)this + 5) & 0xF8000000 | v8;
  uint64_t result = operator new(32 * a4);
  *((void *)this - 1) = result;
  if (a4)
  {
    uint64_t v10 = result;
    do
    {
      void *v10 = 0;
      v10[1] = 0;
      void v10[2] = 0;
      uint64_t v10[3] = this;
      v10 += 4;
    }
    while (v10 != &result[4 * a4]);
  }
  int v11 = *((_DWORD *)this + 5);
  if ((v11 & 0x40000000) != 0) {
    int v12 = (char *)result;
  }
  else {
    int v12 = (char *)this - 32 * (v11 & 0x7FFFFFF);
  }
  if (*(void *)v12)
  {
    **((void **)v12 + 2) = *((void *)v12 + 1);
    uint64_t v13 = *((void *)v12 + 1);
    if (v13) {
      *(void *)(v13 + 16) = *((void *)v12 + 2);
    }
  }
  *(void *)int v12 = a2;
  if (a2)
  {
    uint64_t v16 = *((void *)a2 + 1);
    uint64_t v15 = (void *)((char *)a2 + 8);
    uint64_t v14 = v16;
    *((void *)v12 + 1) = v16;
    if (v16) {
      *(void *)(v14 + 16) = v12 + 8;
    }
    *((void *)v12 + 2) = v15;
    *uint64_t v15 = v12;
  }
  if (a3)
  {
    *((_WORD *)this + 9) |= 1u;
    return (void *)sub_1CD5AB76C((uint64_t)this, 1u, (uint64_t)a3);
  }
  return result;
}

llvm::CatchSwitchInst *llvm::CatchSwitchInst::CatchSwitchInst(llvm::CatchSwitchInst *this, const llvm::CatchSwitchInst *a2)
{
  int v4 = *((_DWORD *)a2 + 5);
  *(void *)this = *(void *)a2;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 38;
  *((unsigned char *)this + 17) = 0;
  *((_WORD *)this + 9) = 0;
  *((_DWORD *)this + 5) = *((_DWORD *)this + 5) & 0xC0000000 | v4 & 0x7FFFFFF;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *((_DWORD *)this + 14) = 0;
  int v5 = *((_DWORD *)a2 + 5);
  if ((v5 & 0x40000000) != 0) {
    uint64_t v6 = (char *)*((void *)a2 - 1);
  }
  else {
    uint64_t v6 = (char *)a2 - 32 * (v5 & 0x7FFFFFF);
  }
  if (*((_WORD *)a2 + 9)) {
    uint64_t v7 = (llvm::BasicBlock *)*((void *)v6 + 4);
  }
  else {
    uint64_t v7 = 0;
  }
  llvm::CatchSwitchInst::init(this, *(llvm::Value **)v6, v7, v5 & 0x7FFFFFF);
  int v8 = *((_DWORD *)this + 15);
  int v9 = *((_DWORD *)this + 5);
  *((_DWORD *)this + 5) = v9 & 0xF8000000 | v8 & 0x7FFFFFF;
  if ((v9 & 0x40000000) != 0) {
    uint64_t v10 = (char *)*((void *)this - 1);
  }
  else {
    uint64_t v10 = (char *)this - 32 * (v8 & 0x7FFFFFF);
  }
  int v11 = *((_DWORD *)a2 + 5);
  if ((v11 & 0x40000000) != 0) {
    int v12 = (char *)*((void *)a2 - 1);
  }
  else {
    int v12 = (char *)a2 - 32 * (v11 & 0x7FFFFFF);
  }
  int v13 = v8 - 1;
  if (v13)
  {
    uint64_t v14 = v10 + 32;
    uint64_t v15 = (uint64_t *)(v12 + 32);
    do
    {
      uint64_t v16 = *v15;
      if (*(void *)v14)
      {
        **((void **)v14 + 2) = *((void *)v14 + 1);
        uint64_t v17 = *((void *)v14 + 1);
        if (v17) {
          *(void *)(v17 + 16) = *((void *)v14 + 2);
        }
      }
      *(void *)uint64_t v14 = v16;
      if (v16)
      {
        uint64_t v20 = *(void *)(v16 + 8);
        uint64_t v18 = (char **)(v16 + 8);
        uint64_t v19 = v20;
        *((void *)v14 + 1) = v20;
        if (v20) {
          *(void *)(v19 + 16) = v14 + 8;
        }
        *((void *)v14 + 2) = v18;
        *uint64_t v18 = v14;
      }
      v14 += 32;
      v15 += 4;
      --v13;
    }
    while (v13);
  }
  return this;
}

void llvm::CatchSwitchInst::addHandler(llvm::CatchSwitchInst *this, llvm::BasicBlock *a2)
{
  int v4 = *((_DWORD *)this + 5);
  uint64_t v5 = v4 & 0x7FFFFFF;
  if (*((_DWORD *)this + 15) <= (v4 & 0x7FFFFFFu))
  {
    *((_DWORD *)this + 15) = 2 * v5;
    llvm::User::growHungoffUses(this, 2 * v5, 0);
    int v4 = *((_DWORD *)this + 5);
  }
  *((_DWORD *)this + 5) = v4 & 0xF8000000 | (v4 + 1) & 0x7FFFFFF;
  if ((v4 & 0x40000000) != 0) {
    uint64_t v6 = (char *)*((void *)this - 1);
  }
  else {
    uint64_t v6 = (char *)this - 32 * ((v4 + 1) & 0x7FFFFFF);
  }
  uint64_t v7 = &v6[32 * v5];
  if (*(void *)v7)
  {
    **((void **)v7 + 2) = *((void *)v7 + 1);
    uint64_t v8 = *((void *)v7 + 1);
    if (v8) {
      *(void *)(v8 + 16) = *((void *)v7 + 2);
    }
  }
  *(void *)uint64_t v7 = a2;
  if (a2)
  {
    uint64_t v11 = *((void *)a2 + 1);
    uint64_t v10 = (char **)((char *)a2 + 8);
    uint64_t v9 = v11;
    int v12 = &v6[32 * v5];
    *((void *)v12 + 1) = v11;
    if (v11) {
      *(void *)(v9 + 16) = v12 + 8;
    }
    *((void *)v12 + 2) = v10;
    char *v10 = v7;
  }
}

uint64_t llvm::CatchSwitchInst::removeHandler(uint64_t result, void *a2)
{
  int v2 = *(_DWORD *)(result + 20);
  if ((v2 & 0x40000000) != 0)
  {
    uint64_t v4 = *(void *)(result - 8);
    uint64_t v3 = v2 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v3 = v2 & 0x7FFFFFF;
    uint64_t v4 = result - 32 * v3;
  }
  uint64_t v5 = v4 + 32 * v3;
  uint64_t v6 = (void *)(v5 - 32);
  if ((void *)(v5 - 32) != a2)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v9 = v7[4];
      v7 += 4;
      uint64_t v8 = v9;
      if (*a2)
      {
        *(void *)a2[2] = a2[1];
        uint64_t v10 = a2[1];
        if (v10) {
          *(void *)(v10 + 16) = a2[2];
        }
      }
      *a2 = v8;
      if (v8)
      {
        uint64_t v13 = *(void *)(v8 + 8);
        uint64_t v11 = (void *)(v8 + 8);
        uint64_t v12 = v13;
        a2[1] = v13;
        if (v13) {
          *(void *)(v12 + 16) = a2 + 1;
        }
        a2[2] = v11;
        *uint64_t v11 = a2;
      }
      a2 = v7;
    }
    while (v7 != v6);
  }
  if (*v6)
  {
    **(void **)(v5 - 16) = *(void *)(v5 - 24);
    uint64_t v14 = *(void *)(v5 - 24);
    if (v14) {
      *(void *)(v14 + 16) = *(void *)(v5 - 16);
    }
  }
  *uint64_t v6 = 0;
  *(_DWORD *)(result + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(result + 20) & 0xF8000000 | (*(_DWORD *)(result + 20) - 1) & 0x7FFFFFF;
  return result;
}

void llvm::FuncletPadInst::init(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4, const char **a5)
{
  sub_1CC5716C8((uint64_t)&v13, a3, &a3[a4], (uint64_t)&a1[-8 * (a1[5] & 0x7FFFFFF)]);
  uint64_t v8 = a1 - 8;
  if (*((void *)a1 - 4))
  {
    **((void **)a1 - 2) = *((void *)a1 - 3);
    uint64_t v9 = *((void *)a1 - 3);
    if (v9) {
      *(void *)(v9 + 16) = *((void *)a1 - 2);
    }
  }
  *uint64_t v8 = a2;
  if (a2)
  {
    uint64_t v12 = *(void *)(a2 + 8);
    uint64_t v11 = (void *)(a2 + 8);
    uint64_t v10 = v12;
    *((void *)a1 - 3) = v12;
    if (v12) {
      *(void *)(v10 + 16) = a1 - 6;
    }
    *((void *)a1 - 2) = v11;
    *uint64_t v11 = v8;
  }
  llvm::Value::setName((llvm::Value *)a1, a5);
}

uint64_t llvm::FuncletPadInst::FuncletPadInst(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4 = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(_DWORD *)(a2 + 20) & 0x7FFFFFF;
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_WORD *)(a1 + 16) = v4;
  *(_WORD *)(a1 + 1sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(a1 + 20) & 0xC0000000 | v5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  sub_1CC5E4108((uint64_t)&v13, (uint64_t *)(a2 - 32 * (*(_DWORD *)(a2 + 20) & 0x7FFFFFF)), (uint64_t *)a2, a1 - 32 * v5);
  uint64_t v6 = *(void *)(a2 - 32);
  uint64_t v7 = (void *)(a1 - 32);
  if (*(void *)(a1 - 32))
  {
    **(void **)(a1 - 16) = *(void *)(a1 - 24);
    uint64_t v8 = *(void *)(a1 - 24);
    if (v8) {
      *(void *)(v8 + 16) = *(void *)(a1 - 16);
    }
  }
  *uint64_t v7 = v6;
  if (v6)
  {
    uint64_t v11 = *(void *)(v6 + 8);
    uint64_t v9 = (void *)(v6 + 8);
    uint64_t v10 = v11;
    *(void *)(a1 - 24) = v11;
    if (v11) {
      *(void *)(v10 + 16) = a1 - 24;
    }
    *(void *)(a1 - 16) = v9;
    *uint64_t v9 = v7;
  }
  return a1;
}

llvm::Instruction *llvm::FuncletPadInst::FuncletPadInst(llvm::Instruction *a1, char a2, llvm::Type **a3, uint64_t *a4, uint64_t a5, unsigned int a6, const char **a7, llvm::Instruction *a8)
{
  char v13 = llvm::Instruction::Instruction(a1, *a3, a2, (llvm::Instruction *)((char *)a1 - 32 * a6), a6, a8);
  llvm::FuncletPadInst::init(v13, (uint64_t)a3, a4, a5, a7);
  return a1;
}

llvm::Instruction *llvm::FuncletPadInst::FuncletPadInst(llvm::Instruction *a1, char a2, llvm::Type **a3, uint64_t *a4, uint64_t a5, unsigned int a6, const char **a7, llvm::BasicBlock *a8)
{
  char v13 = llvm::Instruction::Instruction(a1, *a3, a2, (llvm::Instruction *)((char *)a1 - 32 * a6), a6, a8);
  llvm::FuncletPadInst::init(v13, (uint64_t)a3, a4, a5, a7);
  return a1;
}

llvm::Instruction *llvm::FenceInst::FenceInst(llvm::Instruction *a1, uint64_t a2, __int16 a3, char a4, llvm::Instruction *a5)
{
  uint64_t result = llvm::Instruction::Instruction(a1, (llvm::Type *)(*(void *)a2 + 1576), 35, 0, 0, a5);
  *((_WORD *)result + 9) = *((_WORD *)result + 9) & 0xFFF8 | a3;
  *((unsigned char *)result + 6llvm::MDNode::dumpTree(this, 0) = a4;
  return result;
}

uint64_t llvm::ShuffleVectorInst::isConcat(llvm::ShuffleVectorInst *this)
{
  int v1 = (unsigned __int8 *)*((void *)this - 8);
  if (v1[16] - 11 >= 2
    && *(unsigned __int8 *)(*((void *)this - 4) + 16) - 11 >= 2
    && (uint64_t v2 = *(void *)this, *(unsigned __int8 *)(*(void *)this + 16) - 11 >= 2)
    && *(unsigned char *)(v2 + 8) != 19
    && (int v3 = *(_DWORD *)(v2 + 32), v3 == 2 * *(_DWORD *)(*(void *)v1 + 32)))
  {
    return sub_1CC5D47FC(*((int **)this + 8), *((unsigned int *)this + 18), v3);
  }
  else
  {
    return 0;
  }
}

void llvm::BinaryOperator::Create(char a1, uint64_t *a2, uint64_t a3, const char **a4)
{
  uint64_t v8 = operator new(0x80uLL);
  v8[21] = v8[21] & 0x38000000 | 2;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *((void *)v8 + 3) = v8 + 16;
  *((void *)v8 + 4) = 0;
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = 0;
  *((void *)v8 + 7) = v8 + 16;
  llvm::BinaryOperator::BinaryOperator((llvm::Value *)(v8 + 16), a1, (uint64_t)a2, a3, *a2, a4, 0);
  llvm::SymbolTableListTraits<llvm::Instruction>::addNodeToList();
}

llvm::Value *llvm::BinaryOperator::CreateNSWNeg(llvm::ConstantFP **this, llvm::Value *a2, const llvm::Twine *a3, llvm::Instruction *a4)
{
  ZeroValueForNegation = (uint64_t *)llvm::ConstantFP::getZeroValueForNegation(*this, a2, a3);
  uint64_t v8 = operator new(0x80uLL);
  v8[21] = v8[21] & 0x38000000 | 2;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *((void *)v8 + 3) = v8 + 16;
  *((void *)v8 + 4) = 0;
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = 0;
  *((void *)v8 + 7) = v8 + 16;
  uint64_t result = llvm::BinaryOperator::BinaryOperator((llvm::Value *)(v8 + 16), 15, (uint64_t)ZeroValueForNegation, (uint64_t)this, *ZeroValueForNegation, (const char **)a2, (uint64_t)a3);
  *((unsigned char *)v8 + 81) |= 4u;
  return result;
}

BOOL llvm::CastInst::isIntegerCast(llvm::CastInst *this)
{
  int v1 = *((unsigned __int8 *)this + 16);
  if ((v1 - 66) < 3) {
    return 1;
  }
  if (v1 == 77 && *(unsigned char *)(**((void **)this - 4) + 8) == 13) {
    return *(unsigned char *)(*(void *)this + 8) == 13;
  }
  return 0;
}

BOOL llvm::CastInst::isLosslessCast(llvm::CastInst *this)
{
  if (*((unsigned char *)this + 16) != 77) {
    return 0;
  }
  uint64_t v1 = **((void **)this - 4);
  if (v1 != *(void *)this)
  {
    if (*(unsigned char *)(v1 + 8) == 15) {
      return *(unsigned char *)(*(void *)this + 8) == 15;
    }
    return 0;
  }
  return 1;
}

char *llvm::CastInst::CreateSExtOrBitCast(llvm::CastInst *this, llvm::Type ***a2, const char **a3, const llvm::Twine *a4, llvm::Instruction *a5)
{
  uint64_t v9 = *(void *)this;
  if ((*(_DWORD *)(v9 + 8) & 0xFE) == 0x12) {
    uint64_t v9 = **(void **)(v9 + 16);
  }
  Primitiveunint64_t SizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v9);
  uint64_t v11 = (llvm::Type *)a2;
  if ((a2[1] & 0xFE) == 0x12) {
    uint64_t v11 = *a2[2];
  }
  int v12 = llvm::Type::getPrimitiveSizeInBits(v11);
  char v13 = operator new(0x60uLL);
  v13[13] = v13[13] & 0x38000000 | 1;
  uint64_t v14 = (char *)(v13 + 8);
  *(void *)char v13 = 0;
  *((void *)v13 + 1) = 0;
  *((void *)v13 + 2) = 0;
  *((void *)v13 + 3) = v13 + 8;
  if (PrimitiveSizeInBits == v12) {
    char v15 = 49;
  }
  else {
    char v15 = 40;
  }
  uint64_t v16 = sub_1CC19DDB4((llvm::Value *)(v13 + 8), (uint64_t)a2, v15, (uint64_t)this, (uint64_t)a4);
  llvm::Value::setName(v16, a3);
  return v14;
}

char *llvm::CastInst::CreatePointerBitCastOrAddrSpaceCast(llvm::CastInst *this, llvm::Value *a2, const char **a3, const llvm::Twine *a4, llvm::BasicBlock *a5)
{
  unsigned int v9 = *(_DWORD *)(*(void *)this + 8);
  if ((v9 & 0xFE) == 0x12) {
    unsigned int v9 = *(_DWORD *)(**(void **)(*(void *)this + 16) + 8);
  }
  int v10 = *((_DWORD *)a2 + 2);
  if ((v10 & 0xFE) == 0x12) {
    int v10 = *(_DWORD *)(**((void **)a2 + 2) + 8);
  }
  uint64_t v11 = operator new(0x60uLL);
  int v12 = (char *)(v11 + 8);
  v11[13] = v11[13] & 0x38000000 | 1;
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *((void *)v11 + 3) = v11 + 8;
  if ((v10 ^ v9) < 0x100) {
    char v13 = 49;
  }
  else {
    char v13 = 50;
  }
  uint64_t v14 = sub_1CC5CEE04((llvm::Value *)(v11 + 8), (uint64_t)a2, v13, (uint64_t)this, (uint64_t)a4);
  llvm::Value::setName(v14, a3);
  return v12;
}

llvm::Value *llvm::CastInst::CreateBitOrPointerCast(llvm::CastInst *this, llvm::Value *a2, const char **a3, const llvm::Twine *a4, llvm::Instruction *a5)
{
  int v9 = *(unsigned __int8 *)(*(void *)this + 8);
  if (v9 == 15)
  {
    if (*((unsigned char *)a2 + 8) == 13)
    {
      uint64_t v17 = operator new(0x60uLL);
      v17[13] = v17[13] & 0x38000000 | 1;
      uint64_t v11 = (llvm::Value *)(v17 + 8);
      *(void *)uint64_t v17 = 0;
      *((void *)v17 + 1) = 0;
      *((void *)v17 + 2) = 0;
      *((void *)v17 + 3) = v17 + 8;
      int v12 = (llvm::Value *)(v17 + 8);
      char v13 = a2;
      char v14 = 47;
      goto LABEL_4;
    }
  }
  else if (v9 == 13 && *((unsigned char *)a2 + 8) == 15)
  {
    uint64_t v16 = operator new(0x60uLL);
    v16[13] = v16[13] & 0x38000000 | 1;
    uint64_t v11 = (llvm::Value *)(v16 + 8);
    *(void *)uint64_t v16 = 0;
    *((void *)v16 + 1) = 0;
    *((void *)v16 + 2) = 0;
    *((void *)v16 + 3) = v16 + 8;
    int v12 = (llvm::Value *)(v16 + 8);
    char v13 = a2;
    char v14 = 48;
    goto LABEL_4;
  }
  int v10 = operator new(0x60uLL);
  v10[13] = v10[13] & 0x38000000 | 1;
  uint64_t v11 = (llvm::Value *)(v10 + 8);
  *(void *)int v10 = 0;
  *((void *)v10 + 1) = 0;
  *((void *)v10 + 2) = 0;
  *((void *)v10 + 3) = v10 + 8;
  int v12 = (llvm::Value *)(v10 + 8);
  char v13 = a2;
  char v14 = 49;
LABEL_4:
  sub_1CC19DDB4(v12, (uint64_t)v13, v14, (uint64_t)this, (uint64_t)a4);
  llvm::Value::setName(v11, a3);
  return v11;
}

llvm::Value *llvm::CastInst::CreateFPCast(llvm::CastInst *this, llvm::Type ***a2, const char **a3, const llvm::Twine *a4, llvm::Instruction *a5)
{
  uint64_t v9 = *(void *)this;
  if ((*(_DWORD *)(v9 + 8) & 0xFE) == 0x12) {
    uint64_t v9 = **(void **)(v9 + 16);
  }
  Primitiveunint64_t SizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)v9);
  uint64_t v11 = (llvm::Type *)a2;
  if ((a2[1] & 0xFE) == 0x12) {
    uint64_t v11 = *a2[2];
  }
  unsigned int v12 = llvm::Type::getPrimitiveSizeInBits(v11);
  if (PrimitiveSizeInBits > v12) {
    int v13 = 45;
  }
  else {
    int v13 = 46;
  }
  if (PrimitiveSizeInBits == v12) {
    int v14 = 49;
  }
  else {
    int v14 = v13;
  }

  return llvm::CastInst::Create(v14, (uint64_t)this, (uint64_t)a2, a3, (uint64_t)a4);
}

llvm::Value *llvm::CmpInst::Create(int a1, __int16 a2, _DWORD **a3, uint64_t a4, const char **a5, uint64_t a6)
{
  unsigned int v12 = operator new(0x80uLL);
  v12[21] = v12[21] & 0x38000000 | 2;
  int v13 = (llvm::Value *)(v12 + 16);
  *(void *)unsigned int v12 = 0;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  *((void *)v12 + 3) = v12 + 16;
  *((void *)v12 + 4) = 0;
  *((void *)v12 + 5) = 0;
  *((void *)v12 + 6) = 0;
  *((void *)v12 + 7) = v12 + 16;
  sub_1CB90C994(*a3);
  if (a1 == 53) {
    char v15 = 53;
  }
  else {
    char v15 = 54;
  }

  return llvm::CmpInst::CmpInst(v13, v14, v15, a2, (uint64_t)a3, a4, a5, a6);
}

uint64_t llvm::CmpInst::isCommutative(llvm::CmpInst *this)
{
  __int16 v1 = *((_WORD *)this + 9);
  if (this && *((unsigned char *)this + 16) == 81) {
    return (v1 & 0x3E) == 32;
  }
  unsigned int v3 = v1 & 0x3F;
  BOOL v4 = v3 > 0xF;
  unsigned int v5 = (0xC3C3u >> v3) & 1;
  if (v4) {
    return 0;
  }
  else {
    return v5;
  }
}

uint64_t llvm::CmpInst::getUnsignedPredicate(int a1)
{
  return (a1 - 4);
}

llvm::SwitchInst *llvm::SwitchInst::SwitchInst(llvm::SwitchInst *this, llvm::Value *a2, llvm::BasicBlock *a3, int a4, llvm::BasicBlock *a5)
{
  uint64_t v9 = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a2 + 1576), 3, 0, 0, a5);
  llvm::SwitchInst::init((uint64_t)v9, (uint64_t)a2, (uint64_t)a3, 2 * a4 + 2);
  return this;
}

llvm::MDNode *llvm::SwitchInstProfUpdateWrapper::buildProfBranchWeightsMD(llvm::SwitchInstProfUpdateWrapper *this)
{
  if (!*((unsigned char *)this + 56)) {
    return 0;
  }
  uint64_t v1 = *((unsigned int *)this + 4);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = 4 * v1;
  for (int i = (_DWORD *)v2; !*i; ++i)
  {
    v3 -= 4;
    if (!v3) {
      return 0;
    }
  }
  if (v1 < 2) {
    return 0;
  }
  uint64_t v6 = ***(uint64_t ****)(*(void *)this + 40);
  return llvm::MDBuilder::createBranchWeights(&v6, v2, v1);
}

void llvm::SwitchInstProfUpdateWrapper::addCase(void *a1, llvm::ConstantInt *a2, llvm::BasicBlock *a3, uint64_t a4)
{
  uint64_t v12[4] = *MEMORY[0x1E4F143B8];
  llvm::SwitchInst::addCase((_DWORD *)*a1, a2, a3);
  uint64_t v6 = a4 & 0xFF00000000;
  if (*((unsigned char *)a1 + 56)) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = v6 == 0;
  }
  if (v7 || a4 == 0)
  {
    if (*((unsigned char *)a1 + 56))
    {
      *((unsigned char *)a1 + 64) = 1;
      if (!v6) {
        LODWORD(a4) = 0;
      }
      unsigned int v10 = *((_DWORD *)a1 + 4);
      if (v10 >= *((_DWORD *)a1 + 5)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(a1[1] + 4 * v1llvm::MDNode::dumpTree(this, 0) = a4;
      ++*((_DWORD *)a1 + 4);
    }
  }
  else
  {
    *((unsigned char *)a1 + 64) = 1;
    unint64_t v9 = ((unint64_t)*(unsigned int *)(*a1 + 20) >> 1) & 0x3FFFFFF;
    v11[0] = v12;
    v11[1] = (void *)0x800000000;
    sub_1CB9CDA9C((uint64_t)v11, v9, 0);
    sub_1CD5CAC7C((uint64_t)(a1 + 1), (uint64_t)v11);
    if (v11[0] != v12) {
      free(v11[0]);
    }
    *(_DWORD *)(a1[1] + 4 * (((*(_DWORD *)(*a1 + 20) >> 1) & 0x3FFFFFFu) - 1)) = a4;
  }
}

void llvm::SwitchInstProfUpdateWrapper::eraseFromParent(llvm::SwitchInstProfUpdateWrapper *this)
{
  *((unsigned char *)this + 64) = 0;
  if (*((unsigned char *)this + 56)) {
    sub_1CBB1173C((uint64_t)this + 8, 0);
  }
  uint64_t v2 = *(llvm::Instruction **)this;

  llvm::Instruction::eraseFromParent(v2);
}

uint64_t llvm::SwitchInstProfUpdateWrapper::getSuccessorWeight(llvm::SwitchInstProfUpdateWrapper *this, unsigned int a2)
{
  if (*((unsigned char *)this + 56)) {
    return *(unsigned int *)(*((void *)this + 1) + 4 * a2) | 0x100000000;
  }
  else {
    return 0;
  }
}

uint64_t llvm::SwitchInstProfUpdateWrapper::getSuccessorWeight(llvm::SwitchInstProfUpdateWrapper *this, const llvm::SwitchInst *a2)
{
  int v2 = (int)a2;
  uint64_t ProfBranchWeightsMD = llvm::SwitchInstProfUpdateWrapper::getProfBranchWeightsMD(this, a2);
  if (ProfBranchWeightsMD
    && (uint64_t v8 = *(unsigned int *)(ProfBranchWeightsMD + 8), v8 == ((*((_DWORD *)this + 5) >> 1) & 0x3FFFFFF) + 1))
  {
    uint64_t v9 = *(void *)(*(void *)(ProfBranchWeightsMD - 8 * v8 + 8 * (v2 + 1)) + 128);
    unsigned int v10 = (unsigned int *)(v9 + 24);
    if (*(_DWORD *)(v9 + 32) >= 0x41u) {
      unsigned int v10 = *(unsigned int **)v10;
    }
    uint64_t v5 = *v10;
    uint64_t v6 = 0x100000000;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  return v6 | v5;
}

void *llvm::IndirectBrInst::init(llvm::IndirectBrInst *this, llvm::Value *a2, int a3)
{
  uint64_t v5 = (a3 + 1);
  BOOL v6 = a3 == -1;
  *((_DWORD *)this + 15) = v5;
  *((_DWORD *)this + 5) = *((_DWORD *)this + 5) & 0xF8000000 | 1;
  uint64_t result = operator new(32 * v5);
  *((void *)this - 1) = result;
  if (!v6)
  {
    uint64_t v8 = result;
    do
    {
      *uint64_t v8 = 0;
      v8[1] = 0;
      v8[2] = 0;
      _OWORD v8[3] = this;
      v8 += 4;
    }
    while (v8 != &result[4 * v5]);
  }
  int v9 = *((_DWORD *)this + 5);
  if ((v9 & 0x40000000) != 0) {
    unsigned int v10 = (char *)result;
  }
  else {
    unsigned int v10 = (char *)this - 32 * (v9 & 0x7FFFFFF);
  }
  if (*(void *)v10)
  {
    **((void **)v10 + 2) = *((void *)v10 + 1);
    uint64_t v11 = *((void *)v10 + 1);
    if (v11) {
      *(void *)(v11 + 16) = *((void *)v10 + 2);
    }
  }
  *(void *)unsigned int v10 = a2;
  if (a2)
  {
    uint64_t v14 = *((void *)a2 + 1);
    int v13 = (void *)((char *)a2 + 8);
    uint64_t v12 = v14;
    *((void *)v10 + 1) = v14;
    if (v14) {
      *(void *)(v12 + 16) = v10 + 8;
    }
    *((void *)v10 + 2) = v13;
    *int v13 = v10;
  }
  return result;
}

llvm::IndirectBrInst *llvm::IndirectBrInst::IndirectBrInst(llvm::IndirectBrInst *this, llvm::Value *a2, int a3, llvm::Instruction *a4)
{
  BOOL v7 = llvm::Instruction::Instruction(this, (llvm::Type *)(***(void ***)a2 + 1576), 4, 0, 0, a4);
  llvm::IndirectBrInst::init(v7, a2, a3);
  return this;
}

llvm::IndirectBrInst *llvm::IndirectBrInst::IndirectBrInst(llvm::IndirectBrInst *this, const llvm::IndirectBrInst *a2)
{
  int v4 = *((_DWORD *)a2 + 5);
  *(void *)this = ***(void ***)a2 + 1576;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 32;
  *((unsigned char *)this + 17) = 0;
  *((_WORD *)this + 9) = 0;
  *((_DWORD *)this + 5) = *((_DWORD *)this + 5) & 0xC0000000 | v4 & 0x7FFFFFF;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *((_DWORD *)this + 14) = 0;
  uint64_t v5 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  BOOL v6 = operator new(32 * v5);
  *((void *)this - 1) = v6;
  if (v5)
  {
    BOOL v7 = v6;
    do
    {
      *BOOL v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
      v7[3] = this;
      v7 += 4;
    }
    while (v7 != &v6[4 * v5]);
  }
  int v8 = *((_DWORD *)this + 5);
  if ((v8 & 0x40000000) != 0) {
    int v9 = (char *)v6;
  }
  else {
    int v9 = (char *)this - 32 * (v8 & 0x7FFFFFF);
  }
  int v10 = *((_DWORD *)a2 + 5);
  if ((v10 & 0x40000000) != 0)
  {
    uint64_t v12 = (uint64_t *)*((void *)a2 - 1);
    LODWORD(v11) = v10 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v11 = v10 & 0x7FFFFFF;
    uint64_t v12 = (uint64_t *)((char *)a2 - 32 * v11);
  }
  if (v11)
  {
    uint64_t v11 = v11;
    int v13 = (void **)(v9 + 8);
    do
    {
      uint64_t v14 = v13 - 1;
      uint64_t v15 = *v12;
      if (*(v13 - 1))
      {
        *v13[1] = *v13;
        if (*v13) {
          (*v13)[2] = v13[1];
        }
      }
      *uint64_t v14 = v15;
      if (v15)
      {
        uint64_t v18 = *(void **)(v15 + 8);
        uint64_t v16 = (void *)(v15 + 8);
        uint64_t v17 = v18;
        *int v13 = v18;
        if (v18) {
          void v17[2] = v13;
        }
        v13[1] = v16;
        *uint64_t v16 = v14;
      }
      v13 += 4;
      v12 += 4;
      --v11;
    }
    while (v11);
  }
  *((unsigned char *)this + 17) = *((unsigned char *)a2 + 17) & 0xFE | *((unsigned char *)this + 17) & 1;
  return this;
}

void llvm::IndirectBrInst::addDestination(llvm::IndirectBrInst *this, llvm::BasicBlock *a2)
{
  int v4 = *((_DWORD *)this + 5);
  uint64_t v5 = v4 & 0x7FFFFFF;
  int v6 = v4 + 1;
  if ((v4 & 0x7FFFFFFu) >= *((_DWORD *)this + 15))
  {
    unsigned int v7 = 2 * (v4 & 0x7FFFFFF);
    *((_DWORD *)this + 15) = v7;
    llvm::User::growHungoffUses(this, v7, 0);
    int v4 = *((_DWORD *)this + 5);
  }
  *((_DWORD *)this + 5) = v4 & 0xF8000000 | v6 & 0x7FFFFFF;
  if ((v4 & 0x40000000) != 0) {
    int v8 = (char *)*((void *)this - 1);
  }
  else {
    int v8 = (char *)this - 32 * (v6 & 0x7FFFFFF);
  }
  int v9 = &v8[32 * v5];
  if (*(void *)v9)
  {
    **((void **)v9 + 2) = *((void *)v9 + 1);
    uint64_t v10 = *((void *)v9 + 1);
    if (v10) {
      *(void *)(v10 + 16) = *((void *)v9 + 2);
    }
  }
  *(void *)int v9 = a2;
  if (a2)
  {
    uint64_t v13 = *((void *)a2 + 1);
    uint64_t v12 = (char **)((char *)a2 + 8);
    uint64_t v11 = v13;
    uint64_t v14 = &v8[32 * v5];
    *((void *)v14 + 1) = v13;
    if (v13) {
      *(void *)(v11 + 16) = v14 + 8;
    }
    *((void *)v14 + 2) = v12;
    *uint64_t v12 = v9;
  }
}

uint64_t llvm::IndirectBrInst::removeDestination(uint64_t this, int a2)
{
  int v2 = *(_DWORD *)(this + 20);
  uint64_t v3 = v2 & 0x7FFFFFF;
  if ((v2 & 0x40000000) != 0) {
    uint64_t v4 = *(void *)(this - 8);
  }
  else {
    uint64_t v4 = this - 32 * v3;
  }
  uint64_t v5 = (v3 - 1);
  int v6 = (uint64_t *)(v4 + 32 * v5);
  uint64_t v7 = (a2 + 1);
  uint64_t v8 = v4 + 32 * v7;
  uint64_t v9 = *v6;
  if (*(void *)v8)
  {
    **(void **)(v8 + 16) = *(void *)(v8 + 8);
    uint64_t v10 = *(void *)(v8 + 8);
    if (v10) {
      *(void *)(v10 + 16) = *(void *)(v8 + 16);
    }
  }
  *(void *)uint64_t v8 = v9;
  if (v9)
  {
    uint64_t v13 = *(void *)(v9 + 8);
    uint64_t v11 = (void *)(v9 + 8);
    uint64_t v12 = v13;
    uint64_t v14 = v4 + 32 * v7;
    *(void *)(v14 + sub_1CD521E44((uint64_t)this + 8) = v13;
    if (v13) {
      *(void *)(v12 + 16) = v14 + 8;
    }
    *(void *)(v14 + 16) = v11;
    *uint64_t v11 = v8;
  }
  if (*v6)
  {
    uint64_t v15 = v4 + 32 * v5;
    uint64_t v17 = *(void **)(v15 + 16);
    uint64_t v16 = (void *)(v15 + 16);
    *uint64_t v17 = *(v16 - 1);
    uint64_t v18 = *(v16 - 1);
    if (v18) {
      *(void *)(v18 + 16) = *v16;
    }
  }
  *int v6 = 0;
  *(_DWORD *)(this + 2llvm::MDNode::dumpTree(this, 0) = *(_DWORD *)(this + 20) & 0xF8000000 | v5 & 0x7FFFFFF;
  return this;
}

double llvm::FenceInst::cloneImpl(llvm::FenceInst *this)
{
  int v2 = (char *)operator new(0x40uLL);
  __int16 v3 = *((_WORD *)this + 9) & 7;
  char v4 = *((unsigned char *)this + 60);
  *(void *)int v2 = ***(void ***)this + 1576;
  *((void *)v2 + 1) = 0;
  v2[16] = 63;
  double result = 0.0;
  *(_OWORD *)(v2 + 17) = 0u;
  *(_OWORD *)(v2 + 33) = 0u;
  *(_OWORD *)(v2 + 44) = 0u;
  *((_WORD *)v2 + 9) = v3;
  v2[60] = v4;
  return result;
}

char *llvm::VAArgInst::cloneImpl(llvm::VAArgInst *this)
{
  int v2 = operator new(0x60uLL);
  __int16 v3 = (char *)(v2 + 8);
  v2[13] = v2[13] & 0x38000000 | 1;
  *(void *)int v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *((void *)v2 + 3) = v2 + 8;
  uint64_t v4 = *((void *)this - 4);
  uint64_t v5 = *(void *)this;
  __int16 v9 = 257;
  int v6 = sub_1CC19DDB4((llvm::Value *)(v2 + 8), v5, 60, v4, 0);
  llvm::Value::setName(v6, &v8);
  return v3;
}

uint64_t llvm::LandingPadInst::cloneImpl(llvm::LandingPadInst *this)
{
  int v2 = operator new(0x48uLL);
  v2[7] = v2[7] & 0x38000000 | 0x40000000;
  *(void *)int v2 = 0;
  uint64_t v3 = (uint64_t)(v2 + 2);

  return llvm::LandingPadInst::LandingPadInst(v3, (uint64_t)this);
}

llvm::IndirectBrInst *llvm::IndirectBrInst::cloneImpl(llvm::IndirectBrInst *this)
{
  int v2 = operator new(0x48uLL);
  v2[7] = v2[7] & 0x38000000 | 0x40000000;
  *(void *)int v2 = 0;
  uint64_t v3 = (llvm::IndirectBrInst *)(v2 + 2);

  return llvm::IndirectBrInst::IndirectBrInst(v3, this);
}

uint64_t llvm::InvokeInst::cloneImpl(llvm::InvokeInst *this)
{
  int v2 = *((_DWORD *)this + 5);
  uint64_t v3 = v2 & 0x7FFFFFF;
  if (v2 < 0 && (*((void *)this - 4 * v3 - 1) & 0xFFFFFFFF0) != 0) {
    uint64_t v4 = llvm::User::operator new((llvm::User *)0x50, v3, *((_DWORD *)this - 8 * v3 - 2) & 0xFFFFFFF0);
  }
  else {
    uint64_t v4 = llvm::User::operator new((llvm::User *)0x50, v3);
  }

  return llvm::InvokeInst::InvokeInst((uint64_t)v4, (uint64_t)this);
}

uint64_t llvm::CallBrInst::cloneImpl(llvm::CallBrInst *this)
{
  int v2 = *((_DWORD *)this + 5);
  uint64_t v3 = v2 & 0x7FFFFFF;
  if (v2 < 0 && (*((void *)this - 4 * v3 - 1) & 0xFFFFFFFF0) != 0) {
    uint64_t v4 = llvm::User::operator new((llvm::User *)0x58, v3, *((_DWORD *)this - 8 * v3 - 2) & 0xFFFFFFF0);
  }
  else {
    uint64_t v4 = llvm::User::operator new((llvm::User *)0x58, v3);
  }

  return llvm::CallBrInst::CallBrInst((uint64_t)v4, (uint64_t)this);
}

uint64_t llvm::ResumeInst::cloneImpl(llvm::ResumeInst *this)
{
  int v2 = operator new(0x60uLL);
  v2[13] = v2[13] & 0x38000000 | 1;
  *(void *)int v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *((void *)v2 + 3) = v2 + 8;
  uint64_t v3 = (uint64_t)(v2 + 8);

  return llvm::ResumeInst::ResumeInst(v3, (void ***)this);
}

uint64_t llvm::CleanupReturnInst::cloneImpl(llvm::CleanupReturnInst *this)
{
  int v2 = llvm::User::operator new((llvm::User *)0x40, *((_DWORD *)this + 5) & 0x7FFFFFF);

  return llvm::CleanupReturnInst::CleanupReturnInst((uint64_t)v2, (uint64_t)this);
}

uint64_t llvm::CatchReturnInst::cloneImpl(llvm::CatchReturnInst *this)
{
  int v2 = operator new(0x80uLL);
  v2[21] = v2[21] & 0x38000000 | 2;
  *(void *)int v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *((void *)v2 + 3) = v2 + 16;
  *((void *)v2 + 4) = 0;
  *((void *)v2 + 5) = 0;
  *((void *)v2 + 6) = 0;
  *((void *)v2 + 7) = v2 + 16;
  uint64_t v3 = (uint64_t)(v2 + 16);

  return llvm::CatchReturnInst::CatchReturnInst(v3, this);
}

llvm::CatchSwitchInst *llvm::CatchSwitchInst::cloneImpl(llvm::CatchSwitchInst *this)
{
  int v2 = operator new(0x48uLL);
  v2[7] = v2[7] & 0x38000000 | 0x40000000;
  *(void *)int v2 = 0;
  uint64_t v3 = (llvm::CatchSwitchInst *)(v2 + 2);

  return llvm::CatchSwitchInst::CatchSwitchInst(v3, this);
}

uint64_t llvm::FuncletPadInst::cloneImpl(llvm::FuncletPadInst *this)
{
  int v2 = llvm::User::operator new((llvm::User *)0x40, *((_DWORD *)this + 5) & 0x7FFFFFF);

  return llvm::FuncletPadInst::FuncletPadInst((uint64_t)v2, (uint64_t)this);
}

char *llvm::FreezeInst::cloneImpl(llvm::FreezeInst *this)
{
  int v2 = operator new(0x60uLL);
  uint64_t v3 = (char *)(v2 + 8);
  v2[13] = v2[13] & 0x38000000 | 1;
  *(void *)int v2 = 0;
  *((void *)v2 + 1) = 0;
  *((void *)v2 + 2) = 0;
  *((void *)v2 + 3) = v2 + 8;
  uint64_t v4 = (uint64_t *)*((void *)this - 4);
  __int16 v8 = 257;
  uint64_t v5 = sub_1CC19DDB4((llvm::Value *)(v2 + 8), *v4, 67, (uint64_t)v4, 0);
  llvm::Value::setName(v5, &v7);
  return v3;
}

void sub_1CD5CAB44()
{
}

void sub_1CD5CABE0()
{
}

uint64_t sub_1CD5CAC7C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    sub_1CC0778D4(a1, a2);
  }
  else
  {
    *(void *)a1 = a1 + 16;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0x800000000;
    if (*(_DWORD *)(a2 + 8)) {
      sub_1CC0778D4(a1, a2);
    }
    *(unsigned char *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = 1;
  }
  return a1;
}

void llvm::DbgVariableIntrinsic::addVariableLocationOps(uint64_t **a1, llvm::ValueAsMetadata **a2, uint64_t a3, unsigned __int8 *a4)
{
  uint64_t v26[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = llvm::MetadataAsValue::get(**a1, a4);
  LLVMSetArgOperand_0((uint64_t)a1, 2u, v7);
  unsigned int v25 = 0;
  unint64_t v9 = a1[-4 * (*((_DWORD *)a1 + 5) & 0x7FFFFFF)][3];
  int v10 = *(unsigned __int8 *)v9;
  if ((v10 - 3) >= 0xFFFFFFFE)
  {
    unint64_t v12 = v9 & 0xFFFFFFFFFFFFFFFBLL;
    unint64_t v13 = (v9 + 136) & 0xFFFFFFFFFFFFFFFBLL;
  }
  else if (v10 == 32)
  {
    uint64_t v11 = *(void *)(v9 + 24);
    unint64_t v12 = v11 | 4;
    unint64_t v13 = (v11 + 8 * *(unsigned int *)(v9 + 32)) | 4;
  }
  else
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
  }
  if (v12 == v13)
  {
    unsigned int v14 = 0;
  }
  else
  {
    unsigned int v14 = 0;
    do
    {
      uint64_t v15 = (unint64_t *)(v12 & 0xFFFFFFFFFFFFFFF8);
      unint64_t v16 = v12 & 0xFFFFFFFFFFFFFFF8;
      if ((v12 & 4) != 0) {
        unint64_t v16 = *v15;
      }
      uint64_t v17 = *(void *)(v16 + 128);
      if (*(unsigned char *)(v17 + 16) == 23)
      {
        if (**(unsigned __int8 **)(v17 + 24) - 1 >= 2) {
          uint64_t v18 = 0;
        }
        else {
          uint64_t v18 = *(void *)(v17 + 24);
        }
      }
      else
      {
        uint64_t v18 = llvm::ValueAsMetadata::get((llvm::ValueAsMetadata *)v17, v8);
        unsigned int v14 = v25;
      }
      if (v14 >= 4) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v26[v14] = v18;
      unsigned int v14 = ++v25;
      if ((v12 & 4) != 0) {
        unint64_t v12 = (unint64_t)(v15 + 1) | 4;
      }
      else {
        unint64_t v12 = (unint64_t)(v15 + 17);
      }
    }
    while (v12 != v13);
  }
  if (a3)
  {
    uint64_t v19 = 8 * a3;
    do
    {
      uint64_t v20 = *a2;
      if (*((unsigned char *)*a2 + 16) == 23)
      {
        if (**((unsigned __int8 **)v20 + 3) - 1 >= 2) {
          uint64_t v21 = 0;
        }
        else {
          uint64_t v21 = *((void *)v20 + 3);
        }
      }
      else
      {
        uint64_t v21 = llvm::ValueAsMetadata::get(v20, v8);
        unsigned int v14 = v25;
      }
      if (v14 >= 4) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v26[v14] = v21;
      unsigned int v14 = ++v25;
      ++a2;
      v19 -= 8;
    }
    while (v19);
  }
  uint64_t v22 = (void *)**a1;
  uint64_t Impl = (unsigned __int8 *)llvm::DIArgList::getImpl(v22, v26, (const void *)v14, 0, 1);
  uint64_t v24 = llvm::MetadataAsValue::get((uint64_t)v22, Impl);
  LLVMSetArgOperand_0((uint64_t)a1, 0, v24);
}

unint64_t llvm::DbgVariableIntrinsic::getFragmentSizeInBits(llvm::DbgVariableIntrinsic *this)
{
  uint64_t v2 = *(void *)(((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[8] + 24);
  llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v2 + 24), *(uint64_t **)(v2 + 32), &v4);
  if (v5) {
    return v4.i64[0];
  }
  else {
    return llvm::DIVariable::getSizeInBits(*(llvm::DIVariable **)(((void *)this
  }
                                                                 - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[4]
                                                                + 24));
}

uint64_t llvm::InstrProfInstBase::getNumCounters(llvm::InstrProfInstBase *this)
{
  return ((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[8];
}

uint64_t llvm::InstrProfInstBase::getIndex(llvm::InstrProfInstBase *this)
{
  return ((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[12];
}

void *llvm::InstrProfIncrementInst::getStep(llvm::InstrProfIncrementInst *this)
{
  if (*(_DWORD *)(*((void *)this - 4) + 36) == 161) {
    return (void *)((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[16];
  }
  Module = (llvm::Type **)llvm::Instruction::getModule(this);
  Int64Ty = (llvm::ConstantInt *)llvm::Type::getInt64Ty(*Module, v3);

  return llvm::ConstantInt::get(Int64Ty, 1uLL, 0);
}

BOOL llvm::ConstrainedFPIntrinsic::isDefaultFPEnvironment(llvm::ConstrainedFPIntrinsic *this)
{
  unsigned __int16 ExceptionBehavior = llvm::ConstrainedFPIntrinsic::getExceptionBehavior(this);
  if (ExceptionBehavior >= 0x100u && ExceptionBehavior != 0) {
    return 0;
  }
  unsigned __int16 RoundingMode = llvm::ConstrainedFPIntrinsic::getRoundingMode(this);
  return RoundingMode < 0x100u || RoundingMode == 1;
}

uint64_t llvm::ConstrainedFPCmpIntrinsic::getPredicate(llvm::ConstrainedFPCmpIntrinsic *this)
{
  return sub_1CC5E4A64(((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[8]);
}

uint64_t llvm::ConstrainedFPIntrinsic::isUnaryOp(llvm::ConstrainedFPIntrinsic *this)
{
  unsigned int v1 = *(_DWORD *)(*((void *)this - 4) + 36) - 79;
  return (v1 < 0x28) & (0xFF21FCF10FuLL >> v1);
}

BOOL llvm::ConstrainedFPIntrinsic::isTernaryOp(llvm::ConstrainedFPIntrinsic *this)
{
  return (*(_DWORD *)(*((void *)this - 4) + 36) & 0xFFFFFFFD) == 88;
}

unint64_t llvm::VPIntrinsic::getStaticVectorLength(llvm::VPIntrinsic *this)
{
  unsigned int v1 = this;
  unint64_t MaskParamPos = llvm::VPIntrinsic::getMaskParamPos((llvm::VPIntrinsic *)*(unsigned int *)(*((void *)this - 4) + 36));
  if (HIDWORD(MaskParamPos)
    && *((void *)v1 + 4 * MaskParamPos + -4 * (*((_DWORD *)v1 + 5) & 0x7FFFFFF)))
  {
    unsigned int v1 = (llvm::VPIntrinsic *)*((void *)v1 + 4 * MaskParamPos + -4 * (*((_DWORD *)v1 + 5) & 0x7FFFFFF));
  }
  return *(unsigned int *)(*(void *)v1 + 32) | ((unint64_t)(*(unsigned char *)(*(void *)v1 + 8) == 19) << 32);
}

uint64_t llvm::VPIntrinsic::getMaskParam(llvm::VPIntrinsic *this)
{
  unint64_t MaskParamPos = llvm::VPIntrinsic::getMaskParamPos((llvm::VPIntrinsic *)*(unsigned int *)(*((void *)this - 4) + 36));
  if (HIDWORD(MaskParamPos)) {
    return *((void *)this + 4 * MaskParamPos + -4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
  }
  else {
    return 0;
  }
}

uint64_t llvm::VPIntrinsic::getMaskParamPos(llvm::VPIntrinsic *this)
{
  uint64_t v1 = 0;
  if ((int)this <= 329)
  {
    uint64_t v4 = 0x100000000;
    uint64_t v5 = 2;
    uint64_t v6 = 0x100000000;
    if (this == 137) {
      uint64_t v1 = 3;
    }
    else {
      uint64_t v6 = 0;
    }
    if (this != 136)
    {
      uint64_t v4 = v6;
      uint64_t v5 = v1;
    }
    if (this == 135) {
      uint64_t v1 = 0x100000000;
    }
    else {
      uint64_t v1 = v4;
    }
    if (this == 135) {
      uint64_t v2 = 3;
    }
    else {
      uint64_t v2 = v5;
    }
  }
  else
  {
    uint64_t v2 = 0;
    switch((int)this)
    {
      case 330:
      case 331:
      case 332:
      case 333:
      case 335:
      case 337:
      case 343:
      case 344:
      case 349:
      case 351:
      case 352:
      case 354:
      case 355:
      case 356:
      case 357:
      case 358:
      case 359:
      case 360:
      case 361:
      case 362:
      case 363:
      case 364:
      case 365:
      case 366:
      case 367:
      case 368:
      case 371:
      case 373:
      case 374:
      case 375:
      case 377:
      case 379:
      case 380:
        uint64_t v1 = 0x100000000;
        uint64_t v2 = 2;
        break;
      case 334:
      case 336:
      case 346:
        uint64_t v1 = 0x100000000;
        uint64_t v2 = 3;
        break;
      case 338:
      case 339:
      case 340:
      case 341:
      case 342:
      case 345:
      case 347:
      case 348:
      case 353:
      case 370:
      case 372:
      case 376:
      case 378:
      case 381:
        uint64_t v1 = 0x100000000;
        uint64_t v2 = 1;
        break;
      default:
        return v2 | v1;
    }
  }
  return v2 | v1;
}

uint64_t llvm::VPIntrinsic::setMaskParam(llvm::VPIntrinsic *this, llvm::Value *a2)
{
  unsigned int MaskParamPos = llvm::VPIntrinsic::getMaskParamPos((llvm::VPIntrinsic *)*(unsigned int *)(*((void *)this - 4) + 36));

  return LLVMSetArgOperand_0((uint64_t)this, MaskParamPos, (uint64_t)a2);
}

uint64_t llvm::VPIntrinsic::getVectorLengthParam(llvm::VPIntrinsic *this)
{
  unint64_t VectorLengthParamPos = llvm::VPIntrinsic::getVectorLengthParamPos((llvm::VPIntrinsic *)*(unsigned int *)(*((void *)this - 4) + 36));
  if (HIDWORD(VectorLengthParamPos)) {
    return *((void *)this + 4 * VectorLengthParamPos + -4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
  }
  else {
    return 0;
  }
}

uint64_t llvm::VPIntrinsic::getVectorLengthParamPos(llvm::VPIntrinsic *this)
{
  if ((int)this <= 329)
  {
    uint64_t v1 = 0x100000000;
    uint64_t v2 = 5;
    uint64_t v4 = 0x100000000;
    uint64_t v5 = 3;
    uint64_t v6 = 0x100000000;
    uint64_t v7 = 4;
    if (this != 137)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 0;
    }
    if (this != 136)
    {
      uint64_t v4 = v6;
      uint64_t v5 = v7;
    }
    if (this != 135)
    {
      uint64_t v1 = v4;
      uint64_t v2 = v5;
    }
  }
  else
  {
    switch((int)this)
    {
      case 330:
      case 331:
      case 332:
      case 333:
      case 335:
      case 337:
      case 343:
      case 344:
      case 349:
      case 350:
      case 351:
      case 352:
      case 354:
      case 355:
      case 356:
      case 357:
      case 358:
      case 359:
      case 360:
      case 361:
      case 362:
      case 363:
      case 364:
      case 365:
      case 366:
      case 367:
      case 368:
      case 369:
      case 371:
      case 373:
      case 374:
      case 375:
      case 377:
      case 379:
      case 380:
        uint64_t v1 = 0x100000000;
        uint64_t v2 = 3;
        break;
      case 334:
      case 336:
      case 346:
        uint64_t v1 = 0x100000000;
        uint64_t v2 = 4;
        break;
      case 338:
      case 339:
      case 340:
      case 341:
      case 342:
      case 345:
      case 347:
      case 348:
      case 353:
      case 370:
      case 372:
      case 376:
      case 378:
      case 381:
        uint64_t v1 = 0x100000000;
        uint64_t v2 = 2;
        break;
      default:
        uint64_t v1 = 0;
        uint64_t v2 = 0;
        break;
    }
  }
  return v2 | v1;
}

uint64_t llvm::VPIntrinsic::setVectorLengthParam(llvm::VPIntrinsic *this, llvm::Value *a2)
{
  unsigned int VectorLengthParamPos = llvm::VPIntrinsic::getVectorLengthParamPos((llvm::VPIntrinsic *)*(unsigned int *)(*((void *)this - 4) + 36));

  return LLVMSetArgOperand_0((uint64_t)this, VectorLengthParamPos, (uint64_t)a2);
}

uint64_t llvm::VPIntrinsic::getPointerAlignment(llvm::VPIntrinsic *this)
{
  int v1 = *(_DWORD *)(*((void *)this - 4) + 36);
  int v2 = 1;
  if (v1 > 347)
  {
    if (v1 != 374 && v1 != 367) {
      goto LABEL_6;
    }
  }
  else if (v1 != 137)
  {
LABEL_6:
    int v2 = 0;
  }
  return llvm::AttributeList::getParamAlignment((llvm::VPIntrinsic *)((char *)this + 64), v2);
}

BOOL llvm::VPIntrinsic::isVPIntrinsic(llvm::VPIntrinsic *this)
{
  return (this - 330) < 0x34 || (this - 135) < 3;
}

uint64_t llvm::VPIntrinsic::getFunctionalOpcodeForVP(llvm::VPIntrinsic *this)
{
  if ((this - 330) > 0x33) {
    return 0;
  }
  else {
    return qword_1CFB1B3F8[(int)this - 330] | qword_1CFB1B258[(int)this - 330];
  }
}

uint64_t llvm::VPIntrinsic::canIgnoreVectorLengthParam(llvm::VPIntrinsic *this)
{
  unint64_t StaticVectorLength = llvm::VPIntrinsic::getStaticVectorLength(this);
  unint64_t VectorLengthParamPos = llvm::VPIntrinsic::getVectorLengthParamPos((llvm::VPIntrinsic *)*(unsigned int *)(*((void *)this - 4) + 36));
  if (!HIDWORD(VectorLengthParamPos)) {
    return 1;
  }
  uint64_t v5 = *((void *)this + 4 * VectorLengthParamPos + -4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
  if (!v5) {
    return 1;
  }
  if (!HIDWORD(StaticVectorLength))
  {
    if (*(unsigned char *)(v5 + 16) == 16)
    {
      uint64_t v6 = (unint64_t *)(v5 + 24);
      if (*(_DWORD *)(v5 + 32) >= 0x41u) {
        uint64_t v6 = (unint64_t *)*v6;
      }
      return *v6 >= StaticVectorLength;
    }
    return 0;
  }
  uint64_t result = llvm::Instruction::getModule(this);
  if (!result) {
    return result;
  }
  __int16 v8 = (llvm::DataLayout *)(result + 272);
  v9[1] = (llvm::DataLayout *)(result + 272);
  unint64_t v10 = 0;
  v9[0] = (llvm::DataLayout *)&v10;
  if (!sub_1CC5E541C((uint64_t)v9, 17, v5))
  {
    if (StaticVectorLength == 1)
    {
      v9[0] = v8;
      return sub_1CC5E5624(v9, v5);
    }
    return 0;
  }
  return v10 >= StaticVectorLength;
}

BOOL llvm::VPReductionIntrinsic::isVPReduction(llvm::VPReductionIntrinsic *this)
{
  return (this - 354) < 0xD;
}

uint64_t llvm::VPCastIntrinsic::isVPCast(llvm::VPCastIntrinsic *this)
{
  return ((this - 339) < 0x2B) & (0x4A28000410FuLL >> (this - 83));
}

BOOL llvm::VPCmpIntrinsic::isVPCmp(llvm::VPCmpIntrinsic *this)
{
  return this == 346 || this == 334;
}

BOOL llvm::VPReductionIntrinsic::getVectorParamPos(llvm::VPReductionIntrinsic *this)
{
  return (*(_DWORD *)(*((void *)this - 4) + 36) - 354) < 0xD;
}

uint64_t llvm::VPReductionIntrinsic::getStartParamPos(llvm::VPReductionIntrinsic *this)
{
  return 0;
}

uint64_t llvm::BinaryOpIntrinsic::getNoWrapKind(llvm::BinaryOpIntrinsic *this)
{
  unsigned int v1 = *(_DWORD *)(*((void *)this - 4) + 36) - 262;
  BOOL v2 = v1 > 0x16;
  int v3 = (1 << v1) & 0x610003;
  if (v2 || v3 == 0) {
    return 1;
  }
  else {
    return 2;
  }
}

uint64_t llvm::GCProjectionInst::getStatepoint(llvm::GCProjectionInst *this)
{
  uint64_t result = *((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF));
  if (*(unsigned char *)(result + 16) == 94)
  {
    uint64_t UniquePredecessor = llvm::BasicBlock::getUniquePredecessor(*(llvm::BasicBlock **)(result + 40));
    uint64_t v3 = *(void *)(UniquePredecessor + 40);
    if (v3 == UniquePredecessor + 40)
    {
      return 0;
    }
    else
    {
      if (v3) {
        uint64_t v4 = v3 - 24;
      }
      else {
        uint64_t v4 = 0;
      }
      if (*(unsigned __int8 *)(v4 + 16) - 29 >= 0xB) {
        return 0;
      }
      else {
        return v4;
      }
    }
  }
  return result;
}

uint64_t llvm::GCRelocateInst::getBasePtr(llvm::GCRelocateInst *this)
{
  Statepoint = (char *)llvm::GCProjectionInst::getStatepoint(this);
  sub_1CC233A58(Statepoint, 5, v8);
  if (v9)
  {
    uint64_t v3 = v8[0];
  }
  else
  {
    uint64_t v7 = llvm::GCProjectionInst::getStatepoint(this);
    uint64_t v3 = v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF);
  }
  uint64_t v4 = ((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[4];
  uint64_t v5 = (unsigned int *)(v4 + 24);
  if (*(_DWORD *)(v4 + 32) >= 0x41u) {
    uint64_t v5 = *(unsigned int **)v5;
  }
  return *(void *)(v3 + 32 * *v5);
}

uint64_t llvm::GCRelocateInst::getDerivedPtr(llvm::GCRelocateInst *this)
{
  Statepoint = (char *)llvm::GCProjectionInst::getStatepoint(this);
  sub_1CC233A58(Statepoint, 5, v8);
  if (v9)
  {
    uint64_t v3 = v8[0];
  }
  else
  {
    uint64_t v7 = llvm::GCProjectionInst::getStatepoint(this);
    uint64_t v3 = v7 - 32 * (*(_DWORD *)(v7 + 20) & 0x7FFFFFF);
  }
  uint64_t v4 = ((void *)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF))[8];
  uint64_t v5 = (unsigned int *)(v4 + 24);
  if (*(_DWORD *)(v4 + 32) >= 0x41u) {
    uint64_t v5 = *(unsigned int **)v5;
  }
  return *(void *)(v3 + 32 * *v5);
}

uint64_t sub_1CD5CBA60(llvm::DataLayout **a1, uint64_t a2)
{
  if (a2)
  {
    if (*(unsigned char *)(a2 + 16) == 84)
    {
      uint64_t v3 = *(void *)(a2 - 32);
      if (v3)
      {
        if (!*(unsigned char *)(v3 + 16) && *(void *)(v3 + 24) == *(void *)(a2 + 72) && *(_DWORD *)(v3 + 36) == 382) {
          return 1;
        }
      }
    }
  }
  uint64_t v20 = 0;
  uint64_t v18 = (uint64_t)&v20;
  uint64_t result = sub_1CC03F934((void **)&v18, a2);
  if (result)
  {
    uint64_t v5 = v20;
    int v6 = *(unsigned __int8 *)(v20 + 16);
    if (v6 == 62 || v6 == 5 && *(_WORD *)(v20 + 18) == 34)
    {
      uint64_t v7 = 64;
      if (v6 != 62) {
        uint64_t v7 = 24;
      }
      int v8 = *(_DWORD *)(v20 + 20);
      if ((v8 & 0x7FFFFFF) == 2)
      {
        char v9 = *(llvm::Type **)(v20 + v7);
        if (*((unsigned char *)v9 + 8) == 19)
        {
          unint64_t v10 = (v8 & 0x40000000) != 0 ? *(llvm::Constant ***)(v20 - 8) : (llvm::Constant **)(v20 - 64);
          uint64_t v11 = *v10;
          unsigned int v12 = *((unsigned __int8 *)*v10 + 16);
          if (v11 && v12 <= 0x14)
          {
            char isNullValue = llvm::Constant::isNullValue(v11);
            if (isNullValue & 1) != 0 || (sub_1CC03F414((uint64_t)&v18, v11))
            {
              unsigned int v19 = 64;
              uint64_t v18 = 1;
              int v15 = *(_DWORD *)(v5 + 20);
              uint64_t v16 = (v15 & 0x40000000) != 0 ? *(void *)(v5 - 8) : v5 - 32 * (v15 & 0x7FFFFFF);
              BOOL v17 = sub_1CBF53154((llvm::APInt *)&v18, *(unsigned __int8 **)(v16 + 32)) && sub_1CC5CA218(*a1, v9) == 8;
              if (v19 >= 0x41)
              {
                if (v18) {
                  MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
                }
              }
              if (v17) {
                return 1;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t llvm::LLVMContext::setDiagnosticsHotnessRequested(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)this + 81) = a2;
  return this;
}

uint64_t *llvm::LLVMContext::setDiagnosticsHotnessThreshold(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  *(void *)(v3 + 8sub_1CD521E44((uint64_t)this + 8) = a2;
  *(void *)(v3 + 96) = a3;
  return result;
}

uint64_t llvm::LLVMContext::setMisExpectWarningRequested(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)this + 12llvm::MDNode::dumpTree(this, 0) = a2;
  return this;
}

uint64_t llvm::LLVMContext::getMisExpectWarningRequested(llvm::LLVMContext *this)
{
  return *(unsigned __int8 *)(*(void *)this + 120);
}

uint64_t *llvm::LLVMContext::setDiagnosticsMisExpectTolerance(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  *(void *)(v3 + 104) = a2;
  *(void *)(v3 + 112) = a3;
  return result;
}

uint64_t llvm::LLVMContext::getDiagnosticsMisExpectTolerance(llvm::LLVMContext *this)
{
  if (*(unsigned char *)(*(void *)this + 112)) {
    return *(void *)(*(void *)this + 104);
  }
  else {
    return 0;
  }
}

BOOL llvm::LLVMContext::isDiagnosticsHotnessThresholdSetFromPSI(llvm::LLVMContext *this)
{
  return *(unsigned char *)(*(void *)this + 96) == 0;
}

void **llvm::LLVMContext::setMainRemarkStreamer(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void ***)(v2 + 64);
  *(void *)(v2 + 64) = v3;
  if (result)
  {
    sub_1CD5CC020(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t llvm::LLVMContext::setLLVMRemarkStreamer(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(v2 + 128);
  *(void *)(v2 + 12sub_1CD521E44((uint64_t)this + 8) = v3;
  if (result) {
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t llvm::LLVMContext::emitError(uint64_t a1, uint64_t a2)
{
  int v4 = 0;
  char v5 = 0;
  uint64_t v3 = &unk_1F2616540;
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  uint64_t v8 = 0;
  return llvm::LLVMContext::diagnose(a1, (const llvm::DiagnosticInfo *)&v3);
}

uint64_t llvm::LLVMContext::emitError(llvm::LLVMContext *this, const llvm::Instruction *a2, const llvm::Twine *a3)
{
  llvm::DiagnosticInfoInlineAsm::DiagnosticInfoInlineAsm(v5, a2, a3, 0);
  return llvm::LLVMContext::diagnose((uint64_t)this, (const llvm::DiagnosticInfo *)v5);
}

uint64_t llvm::LLVMContext::emitError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  char v6 = 0;
  int v4 = &unk_1F2616540;
  uint64_t v7 = a2;
  uint64_t v8 = a3;
  uint64_t v9 = 0;
  return llvm::LLVMContext::diagnose(a1, (const llvm::DiagnosticInfo *)&v4);
}

void *llvm::LLVMContext::getOrInsertBundleTag(_DWORD **a1, unsigned __int8 *a2, size_t a3)
{
  return llvm::LLVMContextImpl::getOrInsertBundleTag(*a1, a2, a3);
}

uint64_t llvm::LLVMContext::getOperandBundleTagID(uint64_t *a1, unsigned __int8 *a2, size_t a3)
{
  return llvm::LLVMContextImpl::getOperandBundleTagID(*a1, a2, a3);
}

void llvm::LLVMContext::setGC(uint64_t *a1, uint64_t a2, long long *a3)
{
  uint64_t v6 = *a1;
  uint64_t v12 = 0;
  if (sub_1CD41F538(*(void *)(v6 + 2640), *(_DWORD *)(v6 + 2656), a2, &v12)) {
    uint64_t v7 = v12;
  }
  else {
    uint64_t v7 = *(void *)(v6 + 2640) + 32 * *(unsigned int *)(v6 + 2656);
  }
  if (v7 == *(void *)(*a1 + 2640) + 32 * *(unsigned int *)(*a1 + 2656))
  {
    uint64_t v10 = *a1 + 2640;
    uint64_t v12 = a2;
    *(_OWORD *)std::string __p = *a3;
    uint64_t v14 = *((void *)a3 + 2);
    *(void *)a3 = 0;
    *((void *)a3 + 1) = 0;
    *((void *)a3 + 2) = 0;
    sub_1CD5CC0A4((uint64_t)v11, v10, &v12, (long long *)__p);
    if (SHIBYTE(v14) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v8 = v7 + 8;
    if (*(char *)(v7 + 31) < 0) {
      operator delete(*(void **)v8);
    }
    long long v9 = *a3;
    *(void *)(v8 + 16) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    *((unsigned char *)a3 + 23) = 0;
    *(unsigned char *)a3 = 0;
  }
}

void *llvm::LLVMContext::getGC(llvm::LLVMContext *this, const llvm::Function *a2)
{
  uint64_t v2 = *(void *)this + 2640;
  int v4 = a2;
  return sub_1CD5CC3AC(v2, (uint64_t *)&v4) + 1;
}

uint64_t llvm::LLVMContext::deleteGC(llvm::LLVMContext *this, const llvm::Function *a2)
{
  uint64_t v2 = *(void *)this + 2640;
  int v4 = a2;
  return sub_1CD5CBF50(v2, (uint64_t *)&v4);
}

uint64_t sub_1CD5CBF50(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = 0;
  uint64_t v3 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v6);
  if (v3)
  {
    int v4 = (void *)v6;
    if (*(char *)(v6 + 31) < 0) {
      operator delete(*(void **)(v6 + 8));
    }
    *int v4 = -8192;
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  return v3;
}

double llvm::LLVMContext::enableDebugTypeODRUniquing(llvm::LLVMContext *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(unsigned char *)(*(void *)this + 1184))
  {
    *(_DWORD *)(v1 + 1176) = 0;
    double result = 0.0;
    *(_OWORD *)(v1 + 116llvm::MDNode::dumpTree(this, 0) = 0u;
    *(unsigned char *)(v1 + 1184) = 1;
  }
  return result;
}

uint64_t llvm::LLVMContext::setDiscardValueNames(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)this + 2664) = a2;
  return this;
}

uint64_t llvm::LLVMContext::hasSetOpaquePointersValue(llvm::LLVMContextImpl **this)
{
  return llvm::LLVMContextImpl::hasOpaquePointersValue(*this);
}

uint64_t llvm::LLVMContext::setOpaquePointers(llvm::LLVMContext *this, char a2)
{
  return llvm::LLVMContextImpl::setOpaquePointers(*(void *)this, a2);
}

void **sub_1CD5CC020(void **this)
{
  if (*((unsigned char *)this + 56))
  {
    if (*((char *)this + 55) < 0) {
      operator delete(this[4]);
    }
    *((unsigned char *)this + 56) = 0;
  }
  uint64_t v2 = this[3];
  this[3] = 0;
  if (v2) {
    (*(void (**)(void *))(*(void *)v2 + 8))(v2);
  }
  if (*((unsigned char *)this + 16))
  {
    llvm::Regex::~Regex((llvm::Regex *)this);
    *((unsigned char *)this + 16) = 0;
  }
  return this;
}

uint64_t sub_1CD5CC0A4(uint64_t a1, uint64_t a2, uint64_t *a3, long long *a4)
{
  unint64_t v13 = 0;
  uint64_t result = sub_1CD41F538(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v13);
  long long v9 = v13;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5CC150(a2, a3, v13);
    long long v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    long long v12 = *a4;
    *(void *)(result + 24) = *((void *)a4 + 2);
    *(_OWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = v12;
    *((void *)a4 + 1) = 0;
    *((void *)a4 + 2) = 0;
    *(void *)a4 = 0;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 32 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD5CC150(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5CC204(a1, v6);
  uint64_t v8 = 0;
  sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5CC204(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5CC2D0(a1, v4, v4 + 32 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CD5CC2D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      long long v12 = 0;
      sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      uint64_t v10 = v12;
      *long long v12 = *(void *)a2;
      long long v11 = *(_OWORD *)(a2 + 8);
      uint64_t v10[3] = *(void *)(a2 + 24);
      *(_OWORD *)(v10 + 1) = v11;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0;
      ++*(_DWORD *)(a1 + 8);
      if (*(char *)(a2 + 31) < 0) {
        operator delete(*(void **)(a2 + 8));
      }
    }
    a2 += 32;
  }
}

void *sub_1CD5CC3AC(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD5CC150(a1, a2, v8);
    uint64_t v7 = *a2;
    void v5[2] = 0;
    v5[3] = 0;
    void *v5 = v7;
    v5[1] = 0;
  }
  return v5;
}

void llvm::LLVMContextImpl::dropTriviallyDeadConstantArrays(llvm::LLVMContextImpl *this)
{
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 1;
  int64x2_t v18 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v19 = v18;
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  uint64_t v1 = *((void *)this + 155);
  uint64_t v2 = *((unsigned int *)this + 314);
  uint64_t v3 = (uint64_t *)(v1 + 8 * v2);
  if (*((_DWORD *)this + 312))
  {
    if (v2)
    {
      uint64_t v4 = 8 * v2;
      unint64_t v5 = (uint64_t *)*((void *)this + 155);
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v5;
        v4 -= 8;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      unint64_t v5 = (uint64_t *)*((void *)this + 155);
    }
  }
  else
  {
LABEL_6:
    unint64_t v5 = (uint64_t *)(v1 + 8 * v2);
  }
  uint64_t v6 = (uint64_t *)(v1 + 8 * v2);
  if (v5 != v6)
  {
    do
    {
      uint64_t v16 = 0;
      uint64_t v16 = *v5;
      if (!*(void *)(v16 + 8)) {
        sub_1CD4B43C4((uint64_t)&v17, &v16);
      }
      uint64_t v7 = v5 + 1;
      unint64_t v5 = v3;
      if (v7 != v3)
      {
        unint64_t v5 = v7;
        while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          if (++v5 == v3)
          {
            unint64_t v5 = v3;
            break;
          }
        }
      }
    }
    while (v5 != v6);
    unsigned int v8 = v21;
    while (v8)
    {
      uint64_t v9 = *((void *)v20 + v8 - 1);
      sub_1CC18A12C(&v17, v9);
      unsigned int v8 = v21 - 1;
      LODWORD(v21) = v21 - 1;
      if (!*(void *)(v9 + 8))
      {
        int v11 = *(_DWORD *)(v9 + 20);
        if ((v11 & 0x40000000) != 0)
        {
          unint64_t v13 = *(uint64_t **)(v9 - 8);
          uint64_t v12 = v11 & 0x7FFFFFF;
        }
        else
        {
          uint64_t v12 = v11 & 0x7FFFFFF;
          unint64_t v13 = (uint64_t *)(v9 - 32 * v12);
        }
        if (v12)
        {
          uint64_t v14 = 32 * v12;
          do
          {
            uint64_t v15 = *v13;
            if (*(unsigned char *)(*v13 + 16) != 8) {
              uint64_t v15 = 0;
            }
            uint64_t v16 = v15;
            if (v15) {
              sub_1CD4B43C4((uint64_t)&v17, &v16);
            }
            v13 += 4;
            v14 -= 32;
          }
          while (v14);
        }
        llvm::Constant::destroyConstant((int32x2_t ****)v9, v10);
        unsigned int v8 = v21;
      }
    }
  }
  if (v20 != v22) {
    free(v20);
  }
  if ((v17 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v18.i64[0], 8);
  }
}

void llvm::Module::dropTriviallyDeadConstantArrays(llvm::LLVMContextImpl ***this)
{
}

uint64_t llvm::LLVMContextImpl::getOperandBundleTagID(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 2576), a2, a3);
  if (Key == -1) {
    uint64_t v5 = *(unsigned int *)(a1 + 2584);
  }
  else {
    uint64_t v5 = Key;
  }
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 2576) + 8 * v5) + 8);
}

uint64_t llvm::LLVMContextImpl::hasOpaquePointersValue(llvm::LLVMContextImpl *this)
{
  return *((unsigned __int8 *)this + 2681);
}

uint64_t llvm::LLVMContextImpl::setOpaquePointers(uint64_t this, char a2)
{
  if (!*(unsigned char *)(this + 2681)) {
    *(unsigned char *)(this + 2681) = 1;
  }
  *(unsigned char *)(this + 268llvm::MDNode::dumpTree(this, 0) = a2;
  return this;
}

void sub_1CD5CC6A0(unsigned int *a1, llvm::Value *a2)
{
  unsigned int v3 = a1[2];
  sub_1CC5ED4CC(a1, a2);
  if (v3)
  {
    int v4 = 1 << (33 - __clz(v3 - 1));
    if (v4 <= 64) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = v4;
    }
    if (v5 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v6 = 16 * v5;
      uint64_t v7 = *(void **)a1;
      do
      {
        *uint64_t v7 = -4096;
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v5 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CB837D60(a1, v5);
}

void sub_1CD5CC75C(unsigned int *a1, llvm::Value *a2)
{
  unsigned int v3 = a1[2];
  sub_1CC5ED53C(a1, a2);
  if (v3)
  {
    int v4 = 1 << (33 - __clz(v3 - 1));
    if (v4 <= 64) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = v4;
    }
    if (v5 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v6 = 16 * v5;
      uint64_t v7 = *(void **)a1;
      do
      {
        *uint64_t v7 = -4096;
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v5 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CB837D60(a1, v5);
}

uint64_t sub_1CD5CC818(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  sub_1CC5ECE64(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 == *(_DWORD *)(a1 + 16))
  {
    return sub_1CC5705D0(a1);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    return sub_1CC5ECD34(a1, v4);
  }
}

uint64_t *sub_1CD5CC8BC(void *a1)
{
  int v2 = *((_DWORD *)a1 + 2);
  sub_1CC5ED00C(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 == *((_DWORD *)a1 + 4))
  {
    return sub_1CC5710E0(a1);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*a1, 8);
    return sub_1CC5ECDCC(a1, v4);
  }
}

void sub_1CD5CC960()
{
}

uint64_t sub_1CD5CC9B4(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

unint64_t llvm::LLVMRemarkStreamer::toRemark@<X0>(const char **a1@<X1>, uint64_t a2@<X8>)
{
  int v4 = (const llvm::DiagnosticInfoOptimizationBase *)a1;
  int v6 = 0;
  *(void *)(a2 + 104) = a2 + 120;
  *(unsigned char *)(a2 + 8llvm::MDNode::dumpTree(this, 0) = 0;
  *(unsigned char *)(a2 + 8sub_1CD521E44((uint64_t)this + 8) = 0;
  *(unsigned char *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 4llvm::MDNode::dumpTree(this, 0) = 0u;
  *(unsigned char *)(a2 + 56) = 0;
  *(void *)(a2 + 112) = 0x500000000;
  int v7 = *((_DWORD *)a1 + 2) - 9;
  if (v7 <= 8) {
    int v6 = dword_1CFB1B6A8[v7];
  }
  *(_DWORD *)a2 = v6;
  unsigned int v8 = a1[5];
  if (v8) {
    size_t v9 = strlen(a1[5]);
  }
  else {
    size_t v9 = 0;
  }
  *(void *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v8;
  *(void *)(a2 + 16) = v9;
  *(_OWORD *)(a2 + 24) = *((_OWORD *)v4 + 3);
  Name = llvm::Value::getName(*((llvm::Value **)v4 + 2));
  if (v11 && *Name == 1)
  {
    ++Name;
    --v11;
  }
  *(void *)(a2 + 4llvm::MDNode::dumpTree(this, 0) = Name;
  *(void *)(a2 + 4sub_1CD521E44((uint64_t)this + 8) = v11;
  long long v12 = *(_OWORD *)((char *)v4 + 24);
  long long v37 = v12;
  char v13 = v12;
  if ((void)v12)
  {
    unint64_t result = llvm::DiagnosticLocation::getRelativePath((llvm::DiagnosticLocation *)&v37);
    char v13 = 1;
    *(void *)&long long v12 = *((void *)&v37 + 1);
  }
  else
  {
    unint64_t result = 0;
  }
  *(void *)(a2 + 56) = result;
  *(void *)(a2 + 64) = v11;
  *(void *)(a2 + 72) = v12;
  *(unsigned char *)(a2 + 8llvm::MDNode::dumpTree(this, 0) = v13;
  *(_OWORD *)(a2 + 8sub_1CD521E44((uint64_t)this + 8) = *((_OWORD *)v4 + 4);
  uint64_t v15 = *((unsigned int *)v4 + 22);
  if (v15)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    uint64_t v18 = *((void *)v4 + 10);
    uint64_t v19 = v15 << 6;
    do
    {
      uint64_t v20 = v18 + v16;
      sub_1CD5CCBEC(a2 + 104);
      char v21 = *(unsigned char *)(v18 + v16 + 23);
      BOOL v22 = v21 < 0;
      uint64_t v23 = *(void *)(v18 + v16);
      uint64_t v24 = *(void *)(v18 + v16 + 8);
      if (v21 >= 0) {
        uint64_t v23 = v18 + v16;
      }
      uint64_t v25 = v21 & 0x7F;
      if (!v22) {
        uint64_t v24 = v25;
      }
      uint64_t v26 = *(unsigned int *)(a2 + 112);
      uint64_t v27 = *(void *)(a2 + 104) + (v26 << 6);
      *(void *)(v27 - 64) = v23;
      *(void *)(v27 - 56) = v24;
      char v28 = *(unsigned char *)(v20 + 47);
      BOOL v29 = v28 < 0;
      if (v28 >= 0) {
        uint64_t v30 = v20 + 24;
      }
      else {
        uint64_t v30 = *(void *)(v20 + 24);
      }
      uint64_t v31 = v28 & 0x7F;
      if (v29) {
        uint64_t v31 = *(void *)(v20 + 32);
      }
      uint64_t v32 = *(void *)(a2 + 104) + (v26 << 6);
      *(void *)(v32 - 4sub_1CD521E44((uint64_t)this + 8) = v30;
      *(void *)(v32 - 4llvm::MDNode::dumpTree(this, 0) = v31;
      uint64_t v33 = *(void *)(v20 + 48);
      if (v33)
      {
        unint64_t RelativePath = llvm::DiagnosticLocation::getRelativePath((llvm::DiagnosticLocation *)(v20 + 48));
        int v4 = v35;
        uint64_t v3 = *(void *)(v20 + 56);
        unint64_t v17 = RelativePath >> 8;
        uint64_t v26 = *(unsigned int *)(a2 + 112);
        LOBYTE(v33) = 1;
      }
      else
      {
        LOBYTE(RelativePath) = 0;
      }
      uint64_t v36 = *(void *)(a2 + 104) + (v26 << 6);
      unint64_t result = RelativePath | (v17 << 8);
      *(void *)(v36 - 32) = result;
      *(void *)(v36 - 24) = v4;
      *(void *)(v36 - 16) = v3;
      *(unsigned char *)(v36 - sub_1CD521E44((uint64_t)this + 8) = v33;
      *(_DWORD *)(v36 - 7) = v37;
      *(_DWORD *)(v36 - 4) = *(_DWORD *)((char *)&v37 + 3);
      v16 += 64;
    }
    while (v19 != v16);
  }
  return result;
}

uint64_t sub_1CD5CCBEC(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 8);
  if (v1 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD5CD0F8(a1);
  }
  int v2 = (_OWORD *)(*(void *)a1 + (v1 << 6));
  uint64_t v2[2] = 0u;
  v2[3] = 0u;
  *int v2 = 0u;
  v2[1] = 0u;
  uint64_t v3 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v3;
  return *(void *)a1 + (v3 << 6) - 64;
}

void llvm::LLVMRemarkStreamer::emit(llvm::LLVMRemarkStreamer *this, const llvm::DiagnosticInfoOptimizationBase *a2)
{
  v9[40] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)this;
  unsigned int v5 = (char *)*((void *)a2 + 5);
  if (v5) {
    size_t v6 = strlen(*((const char **)a2 + 5));
  }
  else {
    size_t v6 = 0;
  }
  if (llvm::remarks::RemarkStreamer::matchesFilter(v4, v5, v6))
  {
    llvm::LLVMRemarkStreamer::toRemark((const char **)a2, (uint64_t)v7);
    (*(void (**)(void, unsigned char *))(**(void **)(*(void *)this + 24) + 16))(*(void *)(*(void *)this + 24), v7);
    if (v8 != v9) {
      free(v8);
    }
  }
}

uint64_t *llvm::setupLLVMOptimizationRemarks@<X0>(uint64_t *result@<X0>, uint64_t a2@<X2>, uint64_t a3@<X5>, uint64_t a4@<X6>, int a5@<W7>, uint64_t a6@<X8>, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *result;
  if (a5) {
    *(unsigned char *)(v8 + 81) = 1;
  }
  *(void *)(v8 + 8sub_1CD521E44((uint64_t)this + 8) = a7;
  *(void *)(v8 + 96) = a8;
  if (a2)
  {
    llvm::remarks::parseFormat(a3, a4, (uint64_t)&v10);
    if (v11)
    {
      uint64_t v9 = v10;
      uint64_t v10 = 0;
      if (v9) {
        sub_1CC5EE0B0();
      }
    }
    std::system_category();
    operator new();
  }
  *(unsigned char *)(a6 + 8) &= ~1u;
  *(void *)a6 = 0;
  return result;
}

uint64_t sub_1CD5CD0F8(uint64_t a1)
{
  memset(v9, 0, sizeof(v9));
  int v2 = (long long *)sub_1CD5CD16C(a1, (unint64_t)v9, 1);
  uint64_t v3 = (_OWORD *)(*(void *)a1 + ((unint64_t)*(unsigned int *)(a1 + 8) << 6));
  long long v4 = *v2;
  long long v5 = v2[1];
  long long v6 = v2[3];
  void v3[2] = v2[2];
  v3[3] = v6;
  *uint64_t v3 = v4;
  v3[1] = v5;
  uint64_t v7 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v7;
  return *(void *)a1 + (v7 << 6) - 64;
}

unint64_t sub_1CD5CD16C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + (v3 << 6);
    if (*(void *)a1 > a2 || v5 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t sub_1CD5CD1E4(uint64_t a1, char **a2)
{
  *(void *)a1 = &unk_1F2617298;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = std::system_category();
  long long v4 = *a2;
  uint64_t v6 = a1;
  uint64_t v7 = v4;
  *a2 = 0;
  sub_1CC5EE170(&v7, &v6);
  if (v7) {
    (*(void (**)(char *))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

uint64_t sub_1CD5CD284(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617298;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD5CD2D4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617298;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CD5CD344(uint64_t a1, llvm::raw_ostream *this)
{
  unint64_t v5 = *(const char **)(a1 + 8);
  uint64_t v3 = a1 + 8;
  long long v4 = v5;
  char v6 = *(unsigned char *)(v3 + 23);
  int v7 = v6;
  if (v6 >= 0) {
    uint64_t v8 = (const char *)v3;
  }
  else {
    uint64_t v8 = v4;
  }
  size_t v9 = v6 & 0x7F;
  if (v7 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *(void *)(v3 + 8);
  }
  return llvm::raw_ostream::write(this, v8, v10);
}

uint64_t sub_1CD5CD370(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void *sub_1CD5CD37C()
{
  return &llvm::LLVMRemarkSetupFormatError::ID;
}

BOOL sub_1CD5CD388(uint64_t a1, void *a2)
{
  return a2 == &llvm::LLVMRemarkSetupFormatError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

uint64_t sub_1CD5CD3A8(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617298;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD5CD3F8(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617298;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5CD468(uint64_t a1, uint64_t a2)
{
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a2 + 24))(&v7, a2);
  long long v4 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v4);
  }
  *(_OWORD *)long long v4 = v7;
  *(void *)(a1 + 24) = v8;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  *(void *)(a1 + 32) = result;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = v6;
  return result;
}

uint64_t sub_1CD5CD518(uint64_t a1, char **a2)
{
  *(void *)a1 = &unk_1F2617338;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = std::system_category();
  long long v4 = *a2;
  uint64_t v6 = a1;
  long long v7 = v4;
  *a2 = 0;
  sub_1CC5EE170(&v7, &v6);
  if (v7) {
    (*(void (**)(char *))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

uint64_t sub_1CD5CD5B8(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617338;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD5CD608(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617338;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CD5CD678(uint64_t a1, llvm::raw_ostream *this)
{
  unint64_t v5 = *(const char **)(a1 + 8);
  uint64_t v3 = a1 + 8;
  long long v4 = v5;
  char v6 = *(unsigned char *)(v3 + 23);
  int v7 = v6;
  if (v6 >= 0) {
    uint64_t v8 = (const char *)v3;
  }
  else {
    uint64_t v8 = v4;
  }
  size_t v9 = v6 & 0x7F;
  if (v7 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *(void *)(v3 + 8);
  }
  return llvm::raw_ostream::write(this, v8, v10);
}

uint64_t sub_1CD5CD6A4(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void *sub_1CD5CD6B0()
{
  return &llvm::LLVMRemarkSetupFileError::ID;
}

BOOL sub_1CD5CD6BC(uint64_t a1, void *a2)
{
  return a2 == &llvm::LLVMRemarkSetupFileError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

uint64_t sub_1CD5CD6DC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617338;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD5CD72C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617338;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5CD79C(uint64_t a1, char **a2)
{
  *(void *)a1 = &unk_1F26173D8;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = std::system_category();
  long long v4 = *a2;
  uint64_t v6 = a1;
  int v7 = v4;
  *a2 = 0;
  sub_1CC5EE170(&v7, &v6);
  if (v7) {
    (*(void (**)(char *))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

uint64_t sub_1CD5CD83C(uint64_t a1)
{
  *(void *)a1 = &unk_1F26173D8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD5CD88C(uint64_t a1)
{
  *(void *)a1 = &unk_1F26173D8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CD5CD8FC(uint64_t a1, llvm::raw_ostream *this)
{
  unint64_t v5 = *(const char **)(a1 + 8);
  uint64_t v3 = a1 + 8;
  long long v4 = v5;
  char v6 = *(unsigned char *)(v3 + 23);
  int v7 = v6;
  if (v6 >= 0) {
    uint64_t v8 = (const char *)v3;
  }
  else {
    uint64_t v8 = v4;
  }
  size_t v9 = v6 & 0x7F;
  if (v7 >= 0) {
    size_t v10 = v9;
  }
  else {
    size_t v10 = *(void *)(v3 + 8);
  }
  return llvm::raw_ostream::write(this, v8, v10);
}

uint64_t sub_1CD5CD928(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void *sub_1CD5CD934()
{
  return &llvm::LLVMRemarkSetupPatternError::ID;
}

BOOL sub_1CD5CD940(uint64_t a1, void *a2)
{
  return a2 == &llvm::LLVMRemarkSetupPatternError::ID || a2 == &llvm::ErrorInfoBase::ID;
}

uint64_t sub_1CD5CD960(uint64_t a1)
{
  *(void *)a1 = &unk_1F26173D8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1CD5CD9B0(uint64_t a1)
{
  *(void *)a1 = &unk_1F26173D8;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::PMDataManager::initSizeRemarkInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 + 24;
  uint64_t v4 = *(void *)(a2 + 32);
  if (v4 == a2 + 24) {
    return 0;
  }
  LODWORD(v6) = 0;
  do
  {
    if (v4) {
      int v7 = (llvm::Function *)(v4 - 56);
    }
    else {
      int v7 = 0;
    }
    int InstructionCount = llvm::Function::getInstructionCount(v7);
    Name = llvm::Value::getName(v7);
    if (Name)
    {
      std::string::__init(&v19, Name, v9);
      LOBYTE(Name) = *((unsigned char *)&v19.__r_.__value_.__s + 23);
      std::string::size_type size = v19.__r_.__value_.__l.__size_;
      std::string::size_type v12 = v19.__r_.__value_.__r.__words[0];
    }
    else
    {
      std::string::size_type size = 0;
      std::string::size_type v12 = 0;
      memset(&v19, 0, sizeof(v19));
    }
    int v13 = (char)Name;
    if ((char)Name >= 0) {
      uint64_t v14 = &v19;
    }
    else {
      uint64_t v14 = (std::string *)v12;
    }
    size_t v15 = Name & 0x7F;
    if (v13 >= 0) {
      size_t v16 = v15;
    }
    else {
      size_t v16 = size;
    }
    unint64_t v17 = *sub_1CD5CF708(a3, (unsigned __int8 *)v14, v16);
    *((_DWORD *)v17 + 2) = InstructionCount;
    *((_DWORD *)v17 + 3) = 0;
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
    uint64_t v6 = (InstructionCount + v6);
    uint64_t v4 = *(void *)(v4 + 8);
  }
  while (v4 != v3);
  return v6;
}

llvm::raw_ostream *llvm::PassManagerPrettyStackEntry::print(llvm::PassManagerPrettyStackEntry *this, llvm::raw_ostream *a2)
{
  if (*((_OWORD *)this + 2) == 0) {
    uint64_t v4 = "Releasing pass '";
  }
  else {
    uint64_t v4 = "Running pass '";
  }
  sub_1CB8E509C(a2, v4);
  uint64_t v6 = (const void *)(*(uint64_t (**)(void))(**((void **)this + 3) + 16))(*((void *)this + 3));
  size_t v7 = v5;
  uint64_t v8 = (void *)*((void *)a2 + 4);
  if (v5 <= *((void *)a2 + 3) - (void)v8)
  {
    if (v5)
    {
      memcpy(v8, v6, v5);
      *((void *)a2 + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(a2, (const char *)v6, v5);
  }
  uint64_t result = sub_1CB8E509C(a2, "'");
  if (*((void *)this + 5))
  {
    size_t v10 = sub_1CB8E509C(a2, " on module '");
    uint64_t v11 = *((void *)this + 5);
    uint64_t v14 = *(const char **)(v11 + 168);
    uint64_t v12 = v11 + 168;
    int v13 = v14;
    char v15 = *(unsigned char *)(v12 + 23);
    if (v15 >= 0) {
      size_t v16 = (const char *)v12;
    }
    else {
      size_t v16 = v13;
    }
    size_t v17 = *(void *)(v12 + 8);
    if (v15 >= 0) {
      size_t v18 = v15 & 0x7F;
    }
    else {
      size_t v18 = v17;
    }
    std::string v19 = llvm::raw_ostream::write(v10, v16, v18);
    uint64_t v20 = "'.\n";
LABEL_13:
    return sub_1CB8E509C(v19, v20);
  }
  if (*((void *)this + 4))
  {
    sub_1CB8E509C(a2, " on ");
    char v21 = "value";
    if (*(unsigned char *)(*((void *)this + 4) + 16) == 22) {
      char v21 = "basic block";
    }
    if (*(unsigned char *)(*((void *)this + 4) + 16)) {
      BOOL v22 = (char *)v21;
    }
    else {
      BOOL v22 = "function";
    }
    sub_1CB8E509C(a2, v22);
    sub_1CB8E509C(a2, " '");
    llvm::Value::printAsOperand(*((llvm::Value **)this + 4), a2, 0, *((const llvm::Module **)this + 5));
    uint64_t v20 = "'\n";
    std::string v19 = a2;
    goto LABEL_13;
  }
  uint64_t v23 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v23 >= *((void *)a2 + 3))
  {
    return llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((void *)a2 + 4) = v23 + 1;
    *uint64_t v23 = 10;
  }
  return result;
}

llvm::PMTopLevelManager *llvm::PMTopLevelManager::PMTopLevelManager(llvm::PMTopLevelManager *this, llvm::PMDataManager *a2)
{
  *((void *)this + 1) = 0;
  uint64_t v4 = (llvm::PMTopLevelManager *)((char *)this + 8);
  *(void *)this = &unk_1F2617428;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0x800000000;
  *((void *)this + 14) = (char *)this + 128;
  *((void *)this + 15) = 0x800000000;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 52) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 2sub_1CD521E44((uint64_t)this + 8) = 0;
  *((_DWORD *)this + 5sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)this + 3llvm::MDNode::dumpTree(this, 0) = (char *)this + 256;
  *((void *)this + 31) = 0x1000000000;
  size_t v5 = (llvm::PMTopLevelManager *)((char *)this + 520);
  uint64_t v6 = 392;
  *((void *)this + 4sub_1CD521E44((uint64_t)this + 8) = 1;
  do
  {
    *(void *)((char *)this + v6) = -4096;
    v6 += 16;
  }
  while (v6 != 520);
  llvm::FoldingSetBase::FoldingSetBase(v5, 6);
  *(_OWORD *)((char *)this + 536) = 0u;
  *((void *)this + 69) = (char *)this + 568;
  *((void *)this + 7llvm::MDNode::dumpTree(this, 0) = 0x400000000;
  *((void *)this + 75) = (char *)this + 616;
  *((_OWORD *)this + 3sub_1CD521E44((uint64_t)this + 8) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *(_OWORD *)((char *)this + 636) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_DWORD *)this + 16sub_1CD521E44((uint64_t)this + 8) = 0;
  *((void *)a2 + 1) = this;
  unsigned int v7 = *((_DWORD *)this + 10);
  if (v7 >= *((_DWORD *)this + 11)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)this + 4) + 8 * v7) = a2;
  ++*((_DWORD *)this + 10);
  llvm::PMStack::push(v4, a2);
  return this;
}

void *llvm::PMStack::push(llvm::PMStack *this, llvm::PMDataManager *a2)
{
  uint64_t v3 = *(void **)this;
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v3 == v4)
  {
    int v7 = 1;
  }
  else
  {
    uint64_t v5 = *(void *)(*(v4 - 1) + 8);
    unsigned int v6 = *(_DWORD *)(v5 + 120);
    if (v6 >= *(_DWORD *)(v5 + 124)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v5 + 112) + 8 * v6) = a2;
    ++*(_DWORD *)(v5 + 120);
    *((void *)a2 + 1) = v5;
    uint64_t v3 = (void *)*((void *)this + 1);
    int v7 = *(_DWORD *)(*(v3 - 1) + 376) + 1;
  }
  *((_DWORD *)a2 + 94) = v7;
  if ((unint64_t)v3 >= *((void *)this + 2))
  {
    uint64_t result = sub_1CBF63C18((void **)this, (uint64_t)a2);
  }
  else
  {
    *uint64_t v3 = a2;
    uint64_t result = v3 + 1;
  }
  *((void *)this + 1) = result;
  return result;
}

void *llvm::PMTopLevelManager::addImmutablePass(llvm::PMTopLevelManager *this, llvm::ImmutablePass *a2)
{
  (*(void (**)(llvm::ImmutablePass *))(*(void *)a2 + 144))(a2);
  unsigned int v4 = *((_DWORD *)this + 62);
  if (v4 >= *((_DWORD *)this + 63)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*((void *)this + 30) + 8 * v4) = a2;
  ++*((_DWORD *)this + 62);
  uint64_t v12 = (const void *)*((void *)a2 + 2);
  uint64_t v5 = v12;
  unsigned int v6 = (_DWORD *)((char *)this + 384);
  sub_1CD5CF84C((_DWORD *)this + 96, (uint64_t *)&v12)[1] = a2;
  uint64_t result = (void *)llvm::PMTopLevelManager::findAnalysisPassInfo(this, v5);
  uint64_t v8 = (uint64_t *)result[6];
  std::string::size_type v9 = (uint64_t *)result[7];
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    uint64_t v11 = *(void *)(v10 + 32);
    uint64_t result = sub_1CD5CFAFC(v6, &v11);
    result[1] = a2;
  }
  return result;
}

llvm::PMTopLevelManager **llvm::PMDataManager::dumpPassArguments(llvm::PMTopLevelManager **this)
{
  uint64_t v1 = *((unsigned int *)this + 6);
  if (v1)
  {
    int v2 = this;
    uint64_t v3 = this[2];
    uint64_t v4 = 8 * v1;
    do
    {
      uint64_t v5 = *(void *)v3;
      unsigned int v6 = (llvm::PMDataManager *)(*(uint64_t (**)(void))(**(void **)v3 + 112))(*(void *)v3);
      if (v6)
      {
        this = (llvm::PMTopLevelManager **)llvm::PMDataManager::dumpPassArguments(v6);
      }
      else
      {
        this = (llvm::PMTopLevelManager **)llvm::PMTopLevelManager::findAnalysisPassInfo(v2[1], *(const void **)(v5 + 16));
        if (this)
        {
          int v7 = this;
          if (!*((unsigned char *)this + 42))
          {
            uint64_t v8 = llvm::dbgs((llvm *)this);
            std::string::size_type v9 = sub_1CB8E509C(v8, " -");
            uint64_t v10 = v7[2];
            size_t v11 = (size_t)v7[3];
            this = (llvm::PMTopLevelManager **)*((void *)v9 + 4);
            if (v11 <= *((void *)v9 + 3) - (void)this)
            {
              if (v11)
              {
                this = (llvm::PMTopLevelManager **)memcpy(this, v10, v11);
                *((void *)v9 + 4) += v11;
              }
            }
            else
            {
              this = (llvm::PMTopLevelManager **)llvm::raw_ostream::write(v9, (const char *)v10, v11);
            }
          }
        }
      }
      uint64_t v3 = (llvm::PMTopLevelManager *)((char *)v3 + 8);
      v4 -= 8;
    }
    while (v4);
  }
  return this;
}

void llvm::PMDataManager::dumpLastUses(llvm::PMDataManager *this, llvm::Pass *a2, int a3)
{
  v17[12] = *MEMORY[0x1E4F143B8];
  if (dword_1EBD066F8 >= 4)
  {
    char v15 = v17;
    uint64_t v16 = 0xC00000000;
    uint64_t v3 = *((void *)this + 1);
    if (v3)
    {
      Uses = llvm::PMTopLevelManager::collectLastUses(v3, (uint64_t)&v15, (uint64_t)a2);
      unsigned int v6 = (uint64_t *)v15;
      if (v16)
      {
        std::string::size_type v7 = (2 * a3);
        uint64_t v8 = 8 * v16;
        do
        {
          uint64_t v9 = *v6;
          uint64_t v10 = llvm::dbgs((llvm *)Uses);
          size_t v11 = sub_1CB8E509C(v10, "--");
          std::string::__init(&__p, v7, 32);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            size_t size = __p.__r_.__value_.__l.__size_;
          }
          llvm::raw_ostream::write(v11, (const char *)p_p, size);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          Uses = (uint64_t *)(*(uint64_t (**)(uint64_t, void))(*(void *)v9 + 128))(v9, 0);
          ++v6;
          v8 -= 8;
        }
        while (v8);
        unsigned int v6 = (uint64_t *)v15;
      }
      if (v6 != v17) {
        free(v6);
      }
    }
  }
}

llvm *llvm::PMDataManager::dumpAnalysisUsage(llvm *result, const void *a2, size_t a3, unint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a5 + 8))
  {
    uint64_t v9 = result;
    uint64_t v10 = llvm::dbgs(result);
    size_t v11 = llvm::raw_ostream::operator<<(v10, a4);
    std::string::__init(&v27, (2 * *((_DWORD *)v9 + 94) + 3), 32);
    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v12 = &v27;
    }
    else {
      uint64_t v12 = (std::string *)v27.__r_.__value_.__r.__words[0];
    }
    if ((v27.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&v27.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = v27.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(v11, (const char *)v12, size);
    uint64_t v14 = (void *)*((void *)v11 + 4);
    if (a3 <= *((void *)v11 + 3) - (void)v14)
    {
      if (a3)
      {
        memcpy(v14, a2, a3);
        *((void *)v11 + 4) += a3;
      }
    }
    else
    {
      llvm::raw_ostream::write(v11, (const char *)a2, a3);
    }
    char v15 = sub_1CB8E509C(v11, " Analyses:");
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v27.__r_.__value_.__l.__data_);
    }
    if (*(_DWORD *)(a5 + 8))
    {
      uint64_t v17 = 0;
      int v18 = 0;
      do
      {
        if (v18)
        {
          BOOL v22 = llvm::dbgs(v15);
          uint64_t v23 = (unsigned char *)*((void *)v22 + 4);
          if ((unint64_t)v23 >= *((void *)v22 + 3))
          {
            llvm::raw_ostream::write(v22, 44);
          }
          else
          {
            *((void *)v22 + 4) = v23 + 1;
            *uint64_t v23 = 44;
          }
        }
        AnalysisPassInfo = (llvm *)llvm::PMTopLevelManager::findAnalysisPassInfo(*((llvm::PMTopLevelManager **)v9 + 1), *(const void **)(*(void *)a5 + 8 * v17));
        uint64_t v20 = llvm::dbgs(AnalysisPassInfo);
        char v21 = v20;
        if (AnalysisPassInfo)
        {
          uint64_t v24 = (unsigned char *)*((void *)v20 + 4);
          if ((unint64_t)v24 >= *((void *)v20 + 3))
          {
            char v21 = llvm::raw_ostream::write(v20, 32);
          }
          else
          {
            *((void *)v20 + 4) = v24 + 1;
            unsigned char *v24 = 32;
          }
          uint64_t v25 = *(const void **)AnalysisPassInfo;
          size_t v26 = *((void *)AnalysisPassInfo + 1);
          char v15 = (llvm *)*((void *)v21 + 4);
          if (v26 <= *((void *)v21 + 3) - (void)v15)
          {
            if (v26)
            {
              char v15 = (llvm *)memcpy(v15, v25, v26);
              *((void *)v21 + 4) += v26;
            }
          }
          else
          {
            char v15 = llvm::raw_ostream::write(v21, (const char *)v25, v26);
          }
        }
        else
        {
          char v15 = sub_1CB8E509C(v20, " Uninitialized Pass");
        }
        uint64_t v17 = (v18 + 1);
        int v18 = v17;
      }
      while (v17 != *(_DWORD *)(a5 + 8));
    }
    uint64_t result = llvm::dbgs(v15);
    uint64_t v16 = (unsigned char *)*((void *)result + 4);
    if ((unint64_t)v16 >= *((void *)result + 3))
    {
      return llvm::raw_ostream::write(result, 10);
    }
    else
    {
      *((void *)result + 4) = v16 + 1;
      *uint64_t v16 = 10;
    }
  }
  return result;
}

void llvm::PMDataManager::addLowerLevelRequiredPass(llvm **this, llvm::Pass *a2, llvm::Pass *a3)
{
}

void llvm::legacy::FunctionPassManager::FunctionPassManager(llvm::legacy::FunctionPassManager *this, llvm::Module *a2)
{
  *(void *)this = &unk_1F2617498;
  *((void *)this + 2) = a2;
  operator new();
}

llvm *llvm::legacy::FunctionPassManager::add(llvm::legacy::FunctionPassManager *this, llvm::Pass *a2)
{
  return llvm::PMTopLevelManager::schedulePass((int32x2_t *)(*((void *)this + 1) + 416), a2);
}

uint64_t llvm::legacy::FunctionPassManager::doInitialization(llvm::legacy::FunctionPassManager *this)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 1) + 24))(*((void *)this + 1), *((void *)this + 2));
}

uint64_t llvm::legacy::FunctionPassManager::doFinalization(llvm::legacy::FunctionPassManager *this)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 1) + 32))(*((void *)this + 1), *((void *)this + 2));
}

void llvm::FPPassManager::dumpPassStructure(llvm::FPPassManager *this, int a2)
{
  uint64_t v4 = llvm::dbgs(this);
  uint64_t v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  sub_1CB8E509C(v5, "FunctionPass Manager\n");
  if (*((_DWORD *)this + 14))
  {
    unint64_t v6 = 0;
    uint64_t v7 = (a2 + 1);
    do
    {
      uint64_t v8 = *(llvm::Pass **)(*((void *)this + 6) + 8 * v6);
      (*(void (**)(llvm::Pass *, uint64_t))(*(void *)v8 + 128))(v8, v7);
      llvm::PMDataManager::dumpLastUses((llvm::FPPassManager *)((char *)this + 32), v8, v7);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 14));
  }
}

void llvm::legacy::PassManager::PassManager(llvm::legacy::PassManager *this)
{
  *(void *)this = &unk_1F26174C0;
  operator new();
}

{
  *(void *)this = &unk_1F26174C0;
  operator new();
}

void llvm::legacy::PassManager::~PassManager(llvm::legacy::PassManager *this)
{
  *(void *)this = &unk_1F26174C0;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_1F26174C0;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1F26174C0;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x1D25D9CE0);
}

double llvm::PMStack::pop(llvm::PMStack *this)
{
  uint64_t v2 = *(void *)(*((void *)this + 1) - 8);
  sub_1CBB8977C((_DWORD *)(v2 + 208));
  double result = 0.0;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 192) = 0u;
  *(_OWORD *)(v2 + 16llvm::MDNode::dumpTree(this, 0) = 0u;
  *((void *)this + 1) -= 8;
  return result;
}

llvm::raw_ostream *llvm::PMStack::dump(llvm::raw_ostream *this)
{
  uint64_t v1 = *(uint64_t **)this;
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  if (*(uint64_t **)this != v2)
  {
    uint64_t v3 = this;
    do
    {
      uint64_t v4 = *v1;
      uint64_t v5 = llvm::dbgs(this);
      uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
      uint64_t v8 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
      size_t v9 = v7;
      this = (llvm::raw_ostream *)*((void *)v5 + 4);
      if (v7 <= *((void *)v5 + 3) - (void)this)
      {
        if (v7)
        {
          memcpy(this, v8, v7);
          this = (llvm::raw_ostream *)(*((void *)v5 + 4) + v9);
          *((void *)v5 + 4) = this;
        }
      }
      else
      {
        llvm::raw_ostream::write(v5, (const char *)v8, v7);
        this = (llvm::raw_ostream *)*((void *)v5 + 4);
      }
      if ((unint64_t)this >= *((void *)v5 + 3))
      {
        this = llvm::raw_ostream::write(v5, 32);
      }
      else
      {
        *((void *)v5 + 4) = (char *)this + 1;
        *(unsigned char *)this = 32;
      }
      ++v1;
    }
    while (v1 != v2);
    if (*(void *)v3 != *((void *)v3 + 1))
    {
      this = llvm::dbgs(this);
      uint64_t v10 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v10 >= *((void *)this + 3))
      {
        return llvm::raw_ostream::write(this, 10);
      }
      else
      {
        *((void *)this + 4) = v10 + 1;
        unsigned char *v10 = 10;
      }
    }
  }
  return this;
}

void sub_1CD5CEBB0()
{
}

uint64_t sub_1CD5CEBC4()
{
  return 0;
}

void sub_1CD5CEBCC(uint64_t a1)
{
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));

  llvm::ModulePass::~ModulePass((llvm::ModulePass *)a1);
}

void sub_1CD5CEC08(uint64_t a1)
{
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));
  llvm::ModulePass::~ModulePass((llvm::ModulePass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CD5CEC58()
{
  return "Function Pass Manager";
}

void sub_1CD5CEC68(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 16llvm::MDNode::dumpTree(this, 0) = 1;
}

uint64_t sub_1CD5CEC78()
{
  return 3;
}

void sub_1CD5CEC80(llvm::PMDataManager *a1)
{
  uint64_t v1 = (llvm::PMDataManager *)((char *)a1 - 32);
  llvm::PMDataManager::~PMDataManager(a1);

  llvm::ModulePass::~ModulePass(v1);
}

void sub_1CD5CECB8(llvm::PMDataManager *a1)
{
  uint64_t v1 = (llvm::PMDataManager *)((char *)a1 - 32);
  llvm::PMDataManager::~PMDataManager(a1);
  llvm::ModulePass::~ModulePass(v1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5CED04(uint64_t a1)
{
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 416));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD5CED48(uint64_t a1)
{
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 416));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5CEDA0()
{
}

void sub_1CD5CEDB0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 16llvm::MDNode::dumpTree(this, 0) = 1;
}

uint64_t sub_1CD5CEDBC(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD5CEDC4(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 456))
  {
    uint64_t v3 = result;
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*(void *)(v3 + 448) + 8 * v4);
      if (v5) {
        uint64_t v6 = v5 - 32;
      }
      else {
        uint64_t v6 = 0;
      }
      double result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 128))(v6, a2);
      ++v4;
    }
    while (v4 < *(unsigned int *)(v3 + 456));
  }
  return result;
}

uint64_t sub_1CD5CEE4C()
{
  return 3;
}

void sub_1CD5CEE54(uint64_t a1)
{
  uint64_t v2 = (llvm::Pass *)(a1 - 32);
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 384));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)a1);

  llvm::Pass::~Pass(v2);
}

void sub_1CD5CEE9C(uint64_t a1)
{
  uint64_t v2 = (llvm::Pass *)(a1 - 32);
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 384));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)a1);
  llvm::Pass::~Pass(v2);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5CEEF8(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1CD5CEF00(uint64_t a1)
{
  return a1 - 384;
}

uint64_t sub_1CD5CEF08()
{
  return 3;
}

void sub_1CD5CEF10(llvm::PMTopLevelManager *a1)
{
  uint64_t v1 = (llvm::PMTopLevelManager *)((char *)a1 - 416);
  llvm::PMTopLevelManager::~PMTopLevelManager(a1);
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(v2 - 384));

  llvm::Pass::~Pass(v1);
}

void sub_1CD5CEF50(llvm::PMTopLevelManager *a1)
{
  uint64_t v1 = (llvm::PMTopLevelManager *)((char *)a1 - 416);
  llvm::PMTopLevelManager::~PMTopLevelManager(a1);
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(v2 - 384));
  llvm::Pass::~Pass(v1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5CEFA4(uint64_t a1)
{
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 416));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD5CEFE8(uint64_t a1)
{
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 416));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(a1 + 32));
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5CF040()
{
}

void sub_1CD5CF050(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 16llvm::MDNode::dumpTree(this, 0) = 1;
}

uint64_t sub_1CD5CF05C(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD5CF068()
{
  return 1;
}

void sub_1CD5CF070(uint64_t a1)
{
  uint64_t v2 = (llvm::Pass *)(a1 - 32);
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 384));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)a1);

  llvm::Pass::~Pass(v2);
}

void sub_1CD5CF0B8(uint64_t a1)
{
  uint64_t v2 = (llvm::Pass *)(a1 - 32);
  llvm::PMTopLevelManager::~PMTopLevelManager((llvm::PMTopLevelManager *)(a1 + 384));
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)a1);
  llvm::Pass::~Pass(v2);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5CF114(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1CD5CF11C(uint64_t a1)
{
  return a1 - 384;
}

void sub_1CD5CF124(llvm::PMTopLevelManager *a1)
{
  uint64_t v1 = (llvm::PMTopLevelManager *)((char *)a1 - 416);
  llvm::PMTopLevelManager::~PMTopLevelManager(a1);
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(v2 - 384));

  llvm::Pass::~Pass(v1);
}

void sub_1CD5CF164(llvm::PMTopLevelManager *a1)
{
  uint64_t v1 = (llvm::PMTopLevelManager *)((char *)a1 - 416);
  llvm::PMTopLevelManager::~PMTopLevelManager(a1);
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)(v2 - 384));
  llvm::Pass::~Pass(v1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5CF1B8(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617EB0;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(a1 + 16) = &llvm::legacy::FunctionPassManagerImpl::ID;
  *(_DWORD *)(a1 + 24) = 5;
  *(void *)(a1 + 32) = &unk_1F2617458;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = a1 + 64;
  *(void *)(a1 + 56) = 0x1000000000;
  *(void *)(a1 + 24llvm::MDNode::dumpTree(this, 0) = 0;
  *(void *)(a1 + 24sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = a1 + 280;
  *(void *)(a1 + 272) = 0x1000000000;
  *(_DWORD *)(a1 + 40sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  operator new();
}

void sub_1CD5CF370(uint64_t a1)
{
  *(void *)a1 = &unk_1F2617EB0;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  *(void *)(a1 + 16) = &llvm::legacy::PassManagerImpl::ID;
  *(_DWORD *)(a1 + 24) = 5;
  *(void *)(a1 + 32) = &unk_1F2617458;
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = 0;
  *(void *)(a1 + 4sub_1CD521E44((uint64_t)this + 8) = a1 + 64;
  *(void *)(a1 + 56) = 0x1000000000;
  *(void *)(a1 + 24llvm::MDNode::dumpTree(this, 0) = 0;
  *(void *)(a1 + 24sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_DWORD *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = a1 + 280;
  *(void *)(a1 + 272) = 0x1000000000;
  *(_DWORD *)(a1 + 40sub_1CD521E44((uint64_t)this + 8) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20sub_1CD521E44((uint64_t)this + 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  operator new();
}

uint64_t sub_1CD5CF530(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  if (sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5)) {
    BOOL v3 = v5 == *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + 16 * *(unsigned int *)(v5 + 8);
  }
}

void *sub_1CD5CF5A0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
LABEL_3:
    sub_1CC5F69CC(a1, v6);
    uint64_t v8 = 0;
    sub_1CC076DC4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    a3 = v8;
    goto LABEL_4;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

uint64_t sub_1CD5CF658(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    size_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *size_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      size_t v11 = 0;
      double result = sub_1CC076DC4(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *size_t v11 = *(void *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

size_t **sub_1CD5CF708(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  int i = (size_t **)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  uint64_t v10 = operator new(a3 + 17, (std::align_val_t)8uLL);
  size_t v11 = v10;
  uint64_t v12 = (char *)(v10 + 2);
  if (a3) {
    memcpy(v10 + 2, a2, a3);
  }
  v12[a3] = 0;
  *size_t v11 = a3;
  v11[1] = 0;
  *int i = v11;
  ++*(_DWORD *)(a1 + 12);
  for (int i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

uint64_t sub_1CD5CF804(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1CC5F20DC(a3, a2 + 8);
}

unint64_t sub_1CD5CF810(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1CC13A6B8(*(void **)a3, *(void *)a3 + 4 * *(unsigned int *)(a3 + 8));
}

void *sub_1CD5CF84C(_DWORD *a1, uint64_t *a2)
{
  size_t v7 = 0;
  char v4 = sub_1CC5F75A4((uint64_t)a1, *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5CF8AC(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD5CF8AC(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_5;
  }
  sub_1CD5CF970((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CC5F75A4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_5:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD5CF970(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    size_t v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC5F7704(a1, v11, &v11[2 * v12]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  size_t v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *size_t v7 = v8;
      v7[1] = *(void *)(a1 + v6 + 16);
      v7 += 2;
    }
    v6 += 16;
  }
  while (v6 != 128);
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CC5F7704(a1, v14, v7);
}

void *sub_1CD5CFAFC(_DWORD *a1, uint64_t *a2)
{
  size_t v7 = 0;
  char v4 = sub_1CC5F75A4((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD5CF8AC(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD5CFB60(uint64_t a1, uint64_t *a2)
{
  size_t v7 = 0;
  char v4 = sub_1CBF8BDAC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CC5F77C8((_DWORD *)a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *llvm::MDBuilder::createString(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
  return llvm::MDString::get(*a1, a2, a3);
}

uint64_t llvm::MDBuilder::createConstant(llvm::MDBuilder *this, llvm::Constant *a2)
{
  return llvm::ValueAsMetadata::get(a2, a2);
}

llvm::MDNode *llvm::MDBuilder::createFPMath(llvm::Type **this, float a2, llvm::LLVMContext *a3)
{
  if (a2 == 0.0) {
    return 0;
  }
  v16[1] = v6;
  void v16[2] = v5;
  uint64_t v16[5] = v3;
  v16[6] = v4;
  double v9 = a2;
  FloatTy = (llvm::ConstantFP **)llvm::Type::getFloatTy(*this, a3);
  uint64_t v12 = llvm::ConstantFP::get(FloatTy, v11, v9);
  uint64_t v14 = llvm::ValueAsMetadata::get(v12, v13);
  char v15 = *this;
  v16[0] = v14;
  return llvm::MDTuple::getImpl((uint64_t)v15, v16, 1, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createBranchWeights(uint64_t **this, int a2, int a3)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v4[0] = a2;
  v4[1] = a3;
  return llvm::MDBuilder::createBranchWeights(this, (uint64_t)v4, 2);
}

llvm::MDNode *llvm::MDBuilder::createBranchWeights(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  _DWORD v18[4] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = v18;
  uint64_t v17 = 0x400000000;
  sub_1CB90CB08((uint64_t)&v16, a3 + 1, 0);
  uint64_t v6 = llvm::MDString::get(*a1, "branch_weights", 0xEuLL);
  *(void *)uint64_t v16 = v6;
  uint64_t Int32Ty = llvm::Type::getInt32Ty((llvm::Type *)*a1, v7);
  if (v3)
  {
    double v9 = (llvm::ConstantInt *)Int32Ty;
    for (uint64_t i = 0; i != v3; *((void *)v16 + ++i) = v13)
    {
      size_t v11 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v9, *(unsigned int *)(a2 + 4 * i), 0);
      uint64_t v13 = llvm::ValueAsMetadata::get(v11, v12);
    }
  }
  uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)*a1, v16, v17, 0, 1);
  if (v16 != v18) {
    free(v16);
  }
  return Impl;
}

llvm::MDNode *llvm::MDBuilder::createUnpredictable(llvm::MDBuilder *this)
{
  return llvm::MDTuple::getImpl(*(void *)this, 0, 0, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createFunctionEntryCount(uint64_t *a1, unint64_t a2, int a3, uint64_t a4)
{
  v32[8] = *MEMORY[0x1E4F143B8];
  size_t v7 = (uint64_t *)*a1;
  uint64_t v8 = (llvm::ConstantInt *)(*v7 + 1984);
  uint64_t v30 = v32;
  uint64_t v31 = 0x800000000;
  if (a3)
  {
    double v9 = "synthetic_function_entry_count";
    size_t v10 = 30;
  }
  else
  {
    double v9 = "function_entry_count";
    size_t v10 = 20;
  }
  *((void *)v30 + v31) = llvm::MDString::get(v7, (unsigned __int8 *)v9, v10);
  LODWORD(v31) = v31 + 1;
  size_t v11 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v8, a2, 0);
  uint64_t v13 = llvm::ValueAsMetadata::get(v11, v12);
  if (v31 >= HIDWORD(v31)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v30 + v31) = v13;
  unsigned int v14 = v31 + 1;
  LODWORD(v31) = v31 + 1;
  if (a4)
  {
    uint64_t v17 = *(unint64_t **)a4;
    uint64_t v18 = *(unsigned int *)(a4 + 16);
    std::string v19 = (unint64_t *)(*(void *)a4 + 8 * v18);
    if (*(_DWORD *)(a4 + 8))
    {
      if (v18)
      {
        uint64_t v26 = 8 * v18;
        while (*v17 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v17;
          v26 -= 8;
          if (!v26) {
            goto LABEL_10;
          }
        }
      }
    }
    else
    {
LABEL_10:
      uint64_t v17 = v19;
    }
    __base = v29;
    size_t __nel = 0x200000000;
    sub_1CD482BCC((uint64_t)&__base, v17, v19, v19);
    unsigned int v20 = __nel;
    if (__nel >= 2)
    {
      qsort(__base, __nel, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4FDB50);
      unsigned int v20 = __nel;
    }
    char v21 = (unint64_t *)__base;
    if (v20)
    {
      uint64_t v22 = 8 * v20;
      do
      {
        uint64_t v23 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v8, *v21, 0);
        uint64_t v25 = llvm::ValueAsMetadata::get(v23, v24);
        if (v31 >= (unint64_t)HIDWORD(v31)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v30 + v31) = v25;
        LODWORD(v31) = v31 + 1;
        ++v21;
        v22 -= 8;
      }
      while (v22);
      char v21 = (unint64_t *)__base;
    }
    if (v21 != (unint64_t *)v29) {
      free(v21);
    }
    unsigned int v14 = v31;
  }
  uint64_t Impl = llvm::MDTuple::getImpl(*a1, v30, v14, 0, 1);
  if (v30 != v32) {
    free(v30);
  }
  return Impl;
}

llvm::MDNode *llvm::MDBuilder::createFunctionSectionPrefix(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
  v8[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  v8[0] = llvm::MDString::get(*a1, "function_section_prefix", 0x17uLL);
  v8[1] = llvm::MDString::get(*a1, a2, a3);
  return llvm::MDTuple::getImpl((uint64_t)v6, v8, 2, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createCallees(uint64_t *a1, llvm::Value *a2, uint64_t a3)
{
  _OWORD v9[4] = *MEMORY[0x1E4F143B8];
  unsigned int v8 = 0;
  if (a3)
  {
    uint64_t v4 = (llvm::ValueAsMetadata **)a2;
    uint64_t v5 = 8 * a3;
    do
    {
      uint64_t v6 = llvm::ValueAsMetadata::get(*v4, a2);
      if (v8 >= 4uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v9[v8] = v6;
      a3 = ++v8;
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  return llvm::MDTuple::getImpl(*a1, v9, a3, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createCallbackEncoding(llvm::Type **a1, llvm::Type *a2, int *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v23[4] = *MEMORY[0x1E4F143B8];
  double v9 = (llvm::ConstantInt *)(*(void *)*a1 + 1984);
  size_t v10 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v9, a2, 0);
  v23[0] = llvm::ValueAsMetadata::get(v10, v11);
  unsigned int v22 = 1;
  if (a4)
  {
    uint64_t v13 = 4 * a4;
    do
    {
      unsigned int v14 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v9, *a3, (const llvm::APInt *)1);
      uint64_t v16 = llvm::ValueAsMetadata::get(v14, v15);
      if (v22 >= 4uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v23[v22++] = v16;
      ++a3;
      v13 -= 4;
    }
    while (v13);
  }
  Int1Ty = (llvm::ConstantInt *)llvm::Type::getInt1Ty(*a1, v12);
  uint64_t v18 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(Int1Ty, a5, 0);
  uint64_t v20 = llvm::ValueAsMetadata::get(v18, v19);
  if (v22 >= 4) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v23[v22] = v20;
  return llvm::MDTuple::getImpl((uint64_t)*a1, v23, v22 + 1, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createTBAARoot(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
  int v3 = *a1;
  uint64_t v5 = llvm::MDString::get(*a1, a2, a3);
  return llvm::MDTuple::getImpl((uint64_t)v3, &v5, 1, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createTBAATypeNode(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v6 = a6;
  uint64_t v31[4] = *MEMORY[0x1E4F143B8];
  BOOL v29 = v31;
  uint64_t v30 = 0x400000000;
  sub_1CB90CB08((uint64_t)&v29, 3 * a6 + 3, 0);
  uint64_t v12 = (llvm::ConstantInt *)(*(void *)*a1 + 1984);
  *(void *)BOOL v29 = a2;
  uint64_t v13 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v12, a3, 0);
  uint64_t v15 = llvm::ValueAsMetadata::get(v13, v14);
  uint64_t v16 = v29;
  *((void *)v29 + 1) = v15;
  void v16[2] = a4;
  if (v6)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 3 * v6;
    std::string v19 = (unint64_t *)(a5 + 8);
    do
    {
      *((void *)v29 + (v17 + 3)) = v19[1];
      uint64_t v20 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v12, *(v19 - 1), 0);
      uint64_t v22 = llvm::ValueAsMetadata::get(v20, v21);
      *((void *)v29 + (v17 + 4)) = v22;
      unint64_t v23 = *v19;
      v19 += 3;
      uint64_t v24 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v12, v23, 0);
      uint64_t v26 = llvm::ValueAsMetadata::get(v24, v25);
      *((void *)v29 + (v17 + 5)) = v26;
      v17 += 3;
    }
    while (v18 != v17);
    uint64_t v16 = v29;
  }
  uint64_t Impl = llvm::MDTuple::getImpl(*a1, v16, v30, 0, 1);
  if (v29 != v31) {
    free(v29);
  }
  return Impl;
}

llvm::MDNode *llvm::MDBuilder::createTBAAAccessTag(llvm::MDBuilder *this, llvm::MDNode *a2, llvm::MDNode *a3, llvm::IntegerType *a4, unint64_t a5, int a6)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  size_t v11 = (llvm::ConstantInt *)(**(void **)this + 1984);
  uint64_t v12 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v11, (unint64_t)a4, 0);
  uint64_t v14 = llvm::ValueAsMetadata::get(v12, v13);
  uint64_t v15 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v11, a5, 0);
  uint64_t v17 = llvm::ValueAsMetadata::get(v15, v16);
  if (a6)
  {
    uint64_t v18 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v11, 1uLL, 0);
    uint64_t v20 = llvm::ValueAsMetadata::get(v18, v19);
    char v21 = *(void **)this;
    uint64_t v25 = a2;
    uint64_t v26 = a3;
    uint64_t v27 = v14;
    uint64_t v28 = v17;
    uint64_t v29 = v20;
    uint64_t v22 = v21;
    uint64_t v23 = 5;
  }
  else
  {
    uint64_t v22 = *(void **)this;
    uint64_t v25 = a2;
    uint64_t v26 = a3;
    uint64_t v27 = v14;
    uint64_t v28 = v17;
    uint64_t v23 = 4;
  }
  return llvm::MDTuple::getImpl((uint64_t)v22, &v25, v23, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createMutableTBAAAccessTag(llvm::MDBuilder *this, llvm::MDNode *a2)
{
  uint64_t v4 = (char *)a2 - 8 * *((unsigned int *)a2 + 2);
  uint64_t v5 = (unsigned int *)*((void *)v4 + 1);
  uint64_t v6 = *(void *)(*((void *)v4 + 2) + 128);
  size_t v7 = (llvm::IntegerType **)(v6 + 24);
  if (*(_DWORD *)(v6 + 32) >= 0x41u) {
    size_t v7 = (llvm::IntegerType **)*v7;
  }
  unsigned int v8 = *(llvm::MDNode **)v4;
  double v9 = *v7;
  int v10 = sub_1CB8F0DA8(*(unsigned char **)&v5[-2 * v5[2]]);
  if (v10) {
    unsigned int v11 = 4;
  }
  else {
    unsigned int v11 = 3;
  }
  uint64_t v12 = *((unsigned int *)a2 + 2);
  if (v12 <= v11) {
    return a2;
  }
  char v13 = v10;
  uint64_t v14 = (char *)a2 - 8 * v12;
  uint64_t v15 = *(void *)(*(void *)&v14[8 * v11] + 128);
  uint64_t v16 = (llvm::APInt *)(v15 + 24);
  unsigned int v17 = *(_DWORD *)(v15 + 32);
  if (v17 <= 0x40)
  {
    if (*(void *)v16) {
      goto LABEL_9;
    }
    return a2;
  }
  if (llvm::APInt::countLeadingZerosSlowCase(v16) == v17) {
    return a2;
  }
LABEL_9:
  if (v13)
  {
    uint64_t v19 = *(void *)(*((void *)v14 + 3) + 128);
    uint64_t v20 = (unint64_t *)(v19 + 24);
    if (*(_DWORD *)(v19 + 32) >= 0x41u) {
      uint64_t v20 = (unint64_t *)*v20;
    }
    unint64_t v21 = *v20;
    return llvm::MDBuilder::createTBAAAccessTag(this, v8, (llvm::MDNode *)v5, v9, v21, 0);
  }
  else
  {
    return llvm::MDBuilder::createTBAAStructTagNode((uint64_t **)this, v8, (llvm::MDNode *)v5, (uint64_t)v9, 0);
  }
}

llvm::MDNode *llvm::MDBuilder::createIrrLoopHeaderWeight(uint64_t **this, unint64_t a2)
{
  void v7[2] = *MEMORY[0x1E4F143B8];
  v7[0] = llvm::MDString::get(*this, "loop_header_weight", 0x12uLL);
  uint64_t v4 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get((llvm::ConstantInt *)(**this + 1984), a2, 0);
  v7[1] = llvm::ValueAsMetadata::get(v4, v5);
  return llvm::MDTuple::getImpl((uint64_t)*this, v7, 2, 0, 1);
}

llvm::MDNode *llvm::MDBuilder::createPseudoProbeDesc(uint64_t **this, unint64_t a2, unint64_t a3, llvm::Function *a4)
{
  uint64_t v23[3] = *MEMORY[0x1E4F143B8];
  unsigned int v8 = (llvm::ConstantInt *)(**this + 1984);
  unint64_t v21 = v23;
  uint64_t v22 = 0x300000000;
  sub_1CB90CB08((uint64_t)&v21, 3uLL, 0);
  double v9 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v8, a2, 0);
  uint64_t v11 = llvm::ValueAsMetadata::get(v9, v10);
  *(void *)unint64_t v21 = v11;
  uint64_t v12 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v8, a3, 0);
  uint64_t v14 = llvm::ValueAsMetadata::get(v12, v13);
  *((void *)v21 + 1) = v14;
  Name = (unsigned __int8 *)llvm::Value::getName(a4);
  unsigned int v17 = llvm::MDString::get(*this, Name, v16);
  uint64_t v18 = v21;
  *((void *)v21 + 2) = v17;
  uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)*this, v18, v22, 0, 1);
  if (v21 != v23) {
    free(v21);
  }
  return Impl;
}

void llvm::Mangler::getNameWithPrefix(char **this, llvm::raw_ostream *a2, const llvm::Twine *a3, const llvm::DataLayout *a4)
{
}

void llvm::emitLinkerFlagsForGlobalCOFF(llvm *this, llvm::raw_ostream *a2, const llvm::GlobalValue *a3, const llvm::Triple *a4, llvm::Mangler *a5)
{
  if ((*((_DWORD *)a2 + 8) & 0x300) == 0x200 && !llvm::GlobalValue::isDeclaration(a2))
  {
    if ((*((_DWORD *)a3 + 10) & 0xFFFFFFEF) == 0 && *((_DWORD *)a3 + 9) == 15) {
      int v10 = " /EXPORT:";
    }
    else {
      int v10 = " -export:";
    }
    sub_1CB8E509C(this, v10);
    if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
    {
      Name = llvm::Value::getName(a2);
      if (v19)
      {
        while (1)
        {
          int v20 = *Name;
          if (v20 != 64)
          {
            BOOL v21 = v20 != 95 && (v20 - 48) >= 0xA;
            if (v21 && (v20 & 0xFFFFFFDF) - 65 >= 0x1A) {
              break;
            }
          }
          ++Name;
          if (!--v19) {
            goto LABEL_11;
          }
        }
      }
      sub_1CB8E509C(this, "\"");
      int v11 = 1;
    }
    else
    {
LABEL_11:
      int v11 = 0;
    }
    int v12 = *((_DWORD *)a3 + 10);
    BOOL v14 = v12 == 1 || v12 == 18;
    if (*((_DWORD *)a3 + 9) != 15 || !v14)
    {
      llvm::Mangler::getNameWithPrefix(a4, (char **)this, a2, 0);
    }
    else
    {
      memset(&__str, 0, sizeof(__str));
      int v29 = 0;
      char v33 = 0;
      uint64_t v34 = 0;
      p_str = &__str;
      int v35 = 0;
      uint64_t v28 = (char *)&unk_1F2646F30;
      uint64_t v30 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      llvm::Mangler::getNameWithPrefix(a4, &v28, a2, 0);
      if (v32 != v30) {
        llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v28);
      }
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v23 = &__str;
      }
      else {
        uint64_t v23 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      if (v23->__r_.__value_.__s.__data_[0] == (0x5F005F0000uLL >> (8 * *(_DWORD *)(*((void *)a2 + 5) + 300))))
      {
        std::string::basic_string(&__p, &__str, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v38);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t size = __p.__r_.__value_.__l.__size_;
        }
        llvm::raw_ostream::write(this, (const char *)p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      else
      {
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v26 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t v26 = __str.__r_.__value_.__l.__size_;
        }
        llvm::raw_ostream::write(this, (const char *)v23, v26);
      }
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v28);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
    }
    if (v11) {
      sub_1CB8E509C(this, "\"");
    }
    if (*(unsigned char *)(*((void *)a2 + 3) + 8) != 14)
    {
      if ((*((_DWORD *)a3 + 10) & 0xFFFFFFEF) == 0 && *((_DWORD *)a3 + 9) == 15) {
        unsigned int v17 = ",DATA";
      }
      else {
        unsigned int v17 = ",data";
      }
      sub_1CB8E509C(this, v17);
    }
  }
}

void *sub_1CD5D0D10(uint64_t *a1, uint64_t *a2)
{
  size_t v7 = 0;
  char v4 = sub_1CBFF6924(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CBFF69C0((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t sub_1CD5D0D74(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  uint64_t v5 = *(unsigned int *)(a2 + 8);
  uint64_t v6 = (uint64_t *)(a2 - 8 * v5);
  if (v5 == 2) {
    uint64_t v7 = v6[1];
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = llvm::DILocation::getImpl(v4, *(_DWORD *)(a2 + 4), *(unsigned __int16 *)(a2 + 2), *v6, v7, *(unsigned __int8 *)(a2 + 1) >> 7, 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D0DE4(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  uint64_t result = llvm::DIExpression::getImpl(v4, *(const void **)(a2 + 24), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3, 2, 1);
  *a1 = result;
  return result;
}

void sub_1CD5D0E34(llvm::MDNode **a1, uint64_t a2)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  int v5 = *(unsigned __int16 *)(a2 + 2);
  uint64_t v6 = (char *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (*(void *)v6)
  {
    double v9 = *(void **)(*(void *)v6 + 8);
    size_t v10 = *v9;
    unsigned int v8 = (unsigned __int8 *)(v9 + 3);
    size_t v7 = v10;
  }
  else
  {
    size_t v7 = 0;
    unsigned int v8 = 0;
  }
  int v11 = v13;
  uint64_t v12 = 0x400000000;
  sub_1CB91FB58((uint64_t)&v11, v6 + 8, (char *)a2);
  *a1 = sub_1CD5D249C(v4, v5, v8, v7, (unsigned __int8 **)v11, v12);
  if (v11 != v13) {
    free(v11);
  }
}

llvm::MDNode *sub_1CD5D0F28(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  int v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t result = llvm::DISubrange::getImpl(v4, *v5, v5[1], v5[2], v5[3], 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D0F78(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  unsigned int v12 = *(_DWORD *)(a2 + 32);
  if (v12 > 0x40) {
    operator new[]();
  }
  int v11 = *(llvm::MDNode **)(a2 + 24);
  uint64_t v5 = *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (v5)
  {
    unsigned int v8 = *(void **)(v5 + 8);
    size_t v9 = *v8;
    size_t v7 = (unsigned __int8 *)(v8 + 3);
    size_t v6 = v9;
  }
  else
  {
    size_t v6 = 0;
    size_t v7 = 0;
  }
  uint64_t result = sub_1CD5D252C(v4, (const llvm::APInt *)&v11, *(_DWORD *)(a2 + 4) != 0, v7, v6);
  *a1 = result;
  if (v12 >= 0x41)
  {
    uint64_t result = v11;
    if (v11) {
      return (llvm::MDNode *)MEMORY[0x1D25D9CB0](v11, 0x1000C8000313F17);
    }
  }
  return result;
}

llvm::MDNode *sub_1CD5D1078(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  uint64_t v5 = *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8) + 16);
  if (v5)
  {
    unsigned int v8 = *(void **)(v5 + 8);
    size_t v9 = *v8;
    size_t v7 = (unsigned __int8 *)(v8 + 3);
    size_t v6 = v9;
  }
  else
  {
    size_t v6 = 0;
    size_t v7 = 0;
  }
  uint64_t result = sub_1CD5D25B4(v4, *(unsigned __int16 *)(a2 + 2), v7, v6, *(void *)(a2 + 32), *(_DWORD *)(a2 + 48), *(_DWORD *)(a2 + 52), *(_DWORD *)(a2 + 28));
  *a1 = result;
  return result;
}

uint64_t sub_1CD5D10E8(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  char v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    char v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = v5[2];
  if (v6)
  {
    size_t v9 = *(void **)(v6 + 8);
    size_t v10 = *v9;
    unsigned int v8 = (unsigned __int8 *)(v9 + 3);
    size_t v7 = v10;
  }
  else
  {
    size_t v7 = 0;
    unsigned int v8 = 0;
  }
  int v11 = *(unsigned __int16 *)(a2 + 2);
  uint64_t v12 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v12 = *v5;
  }
  if (v11 == 17152) {
    uint64_t v13 = *(unsigned int *)(a2 + 4) | 0x100000000;
  }
  else {
    uint64_t v13 = 0;
  }
  LODWORD(v16) = *(_DWORD *)(a2 + 28);
  LODWORD(v15) = *(_DWORD *)(a2 + 48);
  uint64_t result = sub_1CD5D265C(v4, v11, v8, v7, v12, *(_DWORD *)(a2 + 24), v5[1], v5[3], *(void *)(a2 + 32), v15, *(void *)(a2 + 40), *(void *)(a2 + 52), v13, v16, v5[4], v5[5]);
  *a1 = result;
  return result;
}

uint64_t sub_1CD5D11BC(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = (uint64_t *)(v4 & 0xFFFFFFFFFFFFFFF8);
  if ((v4 & 4) != 0) {
    uint64_t v5 = (uint64_t *)*v5;
  }
  uint64_t v6 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v7 = v6[2];
  if (v7)
  {
    unsigned int v8 = *(void **)(v7 + 8);
    size_t v11 = *v8;
    size_t v9 = (unsigned __int8 *)(v8 + 3);
    size_t v10 = v11;
  }
  else
  {
    size_t v10 = 0;
    size_t v9 = 0;
  }
  int v12 = *(unsigned __int16 *)(a2 + 2);
  uint64_t v13 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v13 = *v6;
  }
  uint64_t v14 = *(void *)(a2 + 32);
  uint64_t v15 = *(void *)(a2 + 40);
  int v16 = *(_DWORD *)(a2 + 24);
  unsigned int v17 = *(_DWORD *)(a2 + 28);
  unsigned int v19 = *(_DWORD *)(a2 + 48);
  int v18 = *(_DWORD *)(a2 + 52);
  int v20 = (unsigned __int8 *)v6[7];
  if (v20)
  {
    BOOL v21 = (size_t *)*((void *)v20 + 1);
    size_t v23 = *v21;
    int v20 = (unsigned __int8 *)(v21 + 3);
    size_t v22 = v23;
  }
  else
  {
    size_t v22 = 0;
  }
  uint64_t result = sub_1CD5AED54(v5, v12, v9, v10, v13, v16, v6[1], v6[3], v14, v19, v15, v17, v6[4], v18, v6[5], v6[6], v20, v22, v6[8],
             v6[9],
             v6[10],
             v6[11],
             v6[12],
             v6[13],
             2,
             1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D12B4(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a2 + 16);
  uint64_t v6 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFF8);
  if ((v5 & 4) != 0) {
    uint64_t v6 = (uint64_t *)*v6;
  }
  uint64_t v7 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  unsigned int v8 = (void *)*v7;
  if (*v7)
  {
    size_t v9 = (void *)v8[1];
    int v12 = (void *)*v9;
    size_t v10 = (unsigned __int8 *)(v9 + 3);
    size_t v11 = v12;
  }
  else
  {
    size_t v11 = 0;
    size_t v10 = 0;
  }
  uint64_t v13 = v7[1];
  if (v13)
  {
    uint64_t v14 = *(void **)(v13 + 8);
    unsigned int v17 = (void *)*v14;
    uint64_t v15 = (unsigned __int8 *)(v14 + 3);
    int v16 = v17;
  }
  else
  {
    int v16 = 0;
    uint64_t v15 = 0;
  }
  uint64_t v18 = *(unsigned __int8 *)(a2 + 40);
  if (*(unsigned char *)(a2 + 40))
  {
    unsigned int v19 = *(uint64_t **)(*(void *)(a2 + 32) + 8);
    uint64_t v20 = *v19;
    unsigned int v8 = v19 + 3;
    uint64_t v18 = v20;
    unsigned int v21 = *(_DWORD *)(a2 + 24) & 0xFFFFFF00;
    int v22 = *(_DWORD *)(a2 + 24);
    char v23 = 1;
  }
  else
  {
    int v22 = 0;
    char v23 = 0;
    unsigned int v21 = 0;
  }
  char v24 = *(unsigned char *)(a2 + 56);
  if (v24)
  {
    uint64_t v25 = *(uint64_t **)(*(void *)(a2 + 48) + 8);
    uint64_t v27 = *v25;
    size_t v26 = v25 + 3;
    uint64_t v2 = v27;
    char v24 = 1;
  }
  else
  {
    size_t v26 = 0;
  }
  int v31 = v21 | v22;
  uint64_t v32 = v8;
  uint64_t v33 = v18;
  char v34 = v23;
  v29[0] = v26;
  v29[1] = v2;
  char v30 = v24;
  uint64_t result = sub_1CD5AEA68(v6, v10, v11, v15, v16, (uint64_t)&v31, (uint64_t)v29, 2, 1u);
  *a1 = result;
  return result;
}

char *sub_1CD5D13B8(char **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (uint64_t *)*v4;
  }
  uint64_t v5 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v5 = *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  }
  uint64_t v6 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v7 = v6[1];
  if (v7)
  {
    unsigned int v8 = *(void **)(v7 + 8);
    size_t v11 = *v8;
    size_t v9 = (unsigned __int8 *)(v8 + 3);
    size_t v10 = v11;
  }
  else
  {
    size_t v10 = 0;
    size_t v9 = 0;
  }
  uint64_t v12 = v6[2];
  if (v12)
  {
    uint64_t v13 = *(void **)(v12 + 8);
    int v16 = (void *)*v13;
    uint64_t v14 = (unsigned __int8 *)(v13 + 3);
    uint64_t v15 = v16;
  }
  else
  {
    uint64_t v15 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v17 = v6[3];
  if (v17)
  {
    uint64_t v18 = *(void **)(v17 + 8);
    size_t v21 = *v18;
    unsigned int v19 = (unsigned __int8 *)(v18 + 3);
    size_t v20 = v21;
  }
  else
  {
    size_t v20 = 0;
    unsigned int v19 = 0;
  }
  int v22 = *(_DWORD *)(a2 + 24);
  char v23 = (unsigned __int8 *)v6[9];
  if (v23)
  {
    char v24 = (size_t *)*((void *)v23 + 1);
    size_t v26 = *v24;
    char v23 = (unsigned __int8 *)(v24 + 3);
    size_t v25 = v26;
  }
  else
  {
    size_t v25 = 0;
  }
  int v27 = *(unsigned __int8 *)(a2 + 28);
  int v28 = *(_DWORD *)(a2 + 32);
  int v29 = *(_DWORD *)(a2 + 36);
  unint64_t v30 = v6[4];
  unint64_t v31 = v6[5];
  uint64_t v32 = v6[6];
  uint64_t v33 = v6[7];
  uint64_t v34 = v6[8];
  uint64_t v35 = *(void *)(a2 + 40);
  int v36 = *(unsigned __int8 *)(a2 + 48);
  int v37 = *(unsigned __int8 *)(a2 + 49);
  int v38 = *(_DWORD *)(a2 + 52);
  int v39 = *(unsigned __int8 *)(a2 + 56);
  int v40 = (unsigned __int8 *)v6[10];
  if (v40)
  {
    unint64_t v41 = (size_t *)*((void *)v40 + 1);
    size_t v43 = *v41;
    int v40 = (unsigned __int8 *)(v41 + 3);
    size_t v42 = v43;
  }
  else
  {
    size_t v42 = 0;
  }
  *(void *)&long long v45 = v32;
  *((void *)&v45 + 1) = v33;
  uint64_t result = sub_1CD5AE724(v4, v22, v5, v9, v10, v27 != 0, v14, v15, v28, v19, v20, v29, v30, v31, v45, v34, v35, v36 != 0, v37 != 0,
             v38,
             v39 != 0,
             v23,
             v25,
             v40,
             v42,
             2);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D154C(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v6 = *v5;
  }
  uint64_t result = llvm::DILexicalBlock::getImpl(v4, v5[1], v6, *(_DWORD *)(a2 + 24), *(unsigned __int16 *)(a2 + 28), 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D15B8(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v6 = *v5;
  }
  uint64_t result = llvm::DILexicalBlockFile::getImpl(v4, v5[1], v6, *(_DWORD *)(a2 + 24), 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1620(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = a2 - 8 * *(unsigned int *)(a2 + 8);
  uint64_t v6 = *(void *)(v5 + 8);
  uint64_t v7 = *(void *)(v5 + 16);
  if (v7)
  {
    size_t v10 = *(void **)(v7 + 8);
    size_t v11 = *v10;
    size_t v9 = (unsigned __int8 *)(v10 + 3);
    size_t v8 = v11;
  }
  else
  {
    size_t v8 = 0;
    size_t v9 = 0;
  }
  uint64_t result = sub_1CD5D2760(v4, v6, v9, v8, *(unsigned char *)(a2 + 24) & 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1688(llvm::MDNode **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a2 + 16);
  size_t v10 = (uint64_t *)(v9 & 0xFFFFFFFFFFFFFFF8);
  if ((v9 & 4) != 0) {
    size_t v10 = (uint64_t *)*v10;
  }
  uint64_t v11 = a2;
  if (*(unsigned char *)a2 != 15) {
    uint64_t v11 = *(void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  }
  uint64_t v12 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v13 = v12[2];
  if (v13)
  {
    uint64_t v14 = *(void **)(v13 + 8);
    size_t v17 = *v14;
    uint64_t v15 = (unsigned __int8 *)(v14 + 3);
    size_t v16 = v17;
  }
  else
  {
    size_t v16 = 0;
    uint64_t v15 = 0;
  }
  uint64_t v18 = v12[3];
  if (v18)
  {
    unsigned int v19 = *(void **)(v18 + 8);
    int v22 = (void *)*v19;
    size_t v20 = (unsigned __int8 *)(v19 + 3);
    size_t v21 = v22;
  }
  else
  {
    size_t v21 = 0;
    size_t v20 = 0;
  }
  uint64_t v23 = v12[1];
  char v24 = (unsigned __int8 *)v12[4];
  if (v24)
  {
    size_t v25 = (size_t *)*((void *)v24 + 1);
    size_t v27 = *v25;
    char v24 = (unsigned __int8 *)(v25 + 3);
    size_t v26 = v27;
  }
  else
  {
    size_t v26 = 0;
  }
  int v28 = (unsigned __int8 *)v12[5];
  if (v28)
  {
    int v29 = (size_t *)*((void *)v28 + 1);
    size_t v31 = *v29;
    int v28 = (unsigned __int8 *)(v29 + 3);
    size_t v30 = v31;
  }
  else
  {
    size_t v30 = 0;
  }
  uint64_t result = sub_1CD5AEFD4(v10, v11, v23, v15, v16, v20, v21, a8, v24, v26, v28, v30, *(_DWORD *)(a2 + 24), *(unsigned char *)(a2 + 28), 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1780(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (unsigned __int8 **)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = *v5;
  if (*v5)
  {
    size_t v8 = (size_t *)*((void *)v6 + 1);
    size_t v9 = *v8;
    uint64_t v6 = (unsigned __int8 *)(v8 + 3);
    size_t v7 = v9;
  }
  else
  {
    size_t v7 = 0;
  }
  uint64_t result = sub_1CD5D27E8(v4, v6, v7, (uint64_t)v5[1], *(unsigned char *)(a2 + 24));
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D17E4(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (*v5)
  {
    size_t v8 = *(void **)(*v5 + 8);
    size_t v9 = *v8;
    size_t v7 = (unsigned __int8 *)(v8 + 3);
    size_t v6 = v9;
  }
  else
  {
    size_t v6 = 0;
    size_t v7 = 0;
  }
  uint64_t result = sub_1CD5D2868(v4, *(unsigned __int16 *)(a2 + 2), v7, v6, v5[1], *(unsigned char *)(a2 + 24), v5[2]);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1850(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (uint64_t *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (uint64_t *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = v5[1];
  if (v6)
  {
    size_t v7 = *(void **)(v6 + 8);
    size_t v10 = *v7;
    size_t v8 = (unsigned __int8 *)(v7 + 3);
    size_t v9 = v10;
  }
  else
  {
    size_t v9 = 0;
    size_t v8 = 0;
  }
  uint64_t v11 = v5[5];
  if (v11)
  {
    uint64_t v12 = *(void **)(v11 + 8);
    size_t v15 = *v12;
    uint64_t v13 = (unsigned __int8 *)(v12 + 3);
    size_t v14 = v15;
  }
  else
  {
    size_t v14 = 0;
    uint64_t v13 = 0;
  }
  uint64_t result = sub_1CD5AEED0(v4, *v5, v8, v9, v13, v14, v5[2], *(_DWORD *)(a2 + 24), v5[3], *(_WORD *)(a2 + 32), HIBYTE(*(_WORD *)(a2 + 32)), v5[6], v5[7], *(_DWORD *)(a2 + 28), v5[8], 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D190C(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = v5[1];
  if (v6)
  {
    size_t v9 = *(void **)(v6 + 8);
    size_t v10 = *v9;
    size_t v8 = (unsigned __int8 *)(v9 + 3);
    size_t v7 = v10;
  }
  else
  {
    size_t v7 = 0;
    size_t v8 = 0;
  }
  uint64_t result = sub_1CD5D2908(v4, *v5, v8, v7, v5[2], *(_DWORD *)(a2 + 24), v5[3], *(unsigned __int16 *)(a2 + 32), *(_DWORD *)(a2 + 36), *(_DWORD *)(a2 + 28), v5[4]);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1990(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = v5[1];
  if (v6)
  {
    size_t v9 = *(void **)(v6 + 8);
    size_t v10 = *v9;
    size_t v8 = (unsigned __int8 *)(v9 + 3);
    size_t v7 = v10;
  }
  else
  {
    size_t v7 = 0;
    size_t v8 = 0;
  }
  uint64_t result = sub_1CD5D29D8(v4, *v5, v8, v7, v5[2], *(_DWORD *)(a2 + 24));
  *a1 = result;
  return result;
}

unsigned int *sub_1CD5D19F8(unsigned int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a2 + 16);
  size_t v10 = (uint64_t *)(v9 & 0xFFFFFFFFFFFFFFF8);
  if ((v9 & 4) != 0) {
    size_t v10 = (uint64_t *)*v10;
  }
  uint64_t v11 = (unsigned __int8 **)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v12 = *v11;
  if (*v11)
  {
    uint64_t v13 = (size_t *)*((void *)v12 + 1);
    size_t v15 = *v13;
    uint64_t v12 = (unsigned __int8 *)(v13 + 3);
    size_t v14 = v15;
  }
  else
  {
    size_t v14 = 0;
  }
  size_t v16 = v11[2];
  if (v16)
  {
    size_t v17 = (void *)*((void *)v16 + 1);
    size_t v20 = (void *)*v17;
    uint64_t v18 = (unsigned __int8 *)(v17 + 3);
    unsigned int v19 = v20;
  }
  else
  {
    unsigned int v19 = 0;
    uint64_t v18 = 0;
  }
  size_t v21 = v11[3];
  if (v21)
  {
    int v22 = (size_t *)*((void *)v21 + 1);
    size_t v24 = *v22;
    size_t v21 = (unsigned __int8 *)(v22 + 3);
    size_t v23 = v24;
  }
  else
  {
    size_t v23 = 0;
  }
  uint64_t result = sub_1CD5AEC64(v10, v12, v14, (uint64_t)v11[1], *(_DWORD *)(a2 + 24), v18, v19, a8, v21, v23, *(_DWORD *)(a2 + 28), (uint64_t)v11[4], 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1AB8(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = (void *)(v4 & 0xFFFFFFFFFFFFFFF8);
  if ((v4 & 4) != 0) {
    uint64_t v5 = (void *)*v5;
  }
  int v6 = *(unsigned __int16 *)(a2 + 2);
  size_t v7 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  int v8 = *(_DWORD *)(a2 + 24);
  uint64_t v9 = v7[2];
  if (v9)
  {
    uint64_t v12 = *(void **)(v9 + 8);
    size_t v13 = *v12;
    uint64_t v11 = (unsigned __int8 *)(v12 + 3);
    size_t v10 = v13;
  }
  else
  {
    size_t v10 = 0;
    uint64_t v11 = 0;
  }
  uint64_t result = sub_1CD5D2A68(v5, v6, *v7, v7[1], v7[3], v8, v11, v10, v7[4]);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1B34(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 16);
  uint64_t v5 = (uint64_t *)(v4 & 0xFFFFFFFFFFFFFFF8);
  if ((v4 & 4) != 0) {
    uint64_t v5 = (uint64_t *)*v5;
  }
  unsigned int v6 = *(unsigned __int16 *)(a2 + 2);
  unsigned int v7 = *(_DWORD *)(a2 + 24);
  int v8 = (void *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  if (*v8)
  {
    uint64_t v9 = *(void **)(*v8 + 8);
    size_t v12 = *v9;
    size_t v10 = (unsigned __int8 *)(v9 + 3);
    size_t v11 = v12;
  }
  else
  {
    size_t v11 = 0;
    size_t v10 = 0;
  }
  uint64_t v13 = v8[1];
  if (v13)
  {
    size_t v14 = *(void **)(v13 + 8);
    size_t v17 = *v14;
    size_t v15 = (unsigned __int8 *)(v14 + 3);
    size_t v16 = v17;
  }
  else
  {
    size_t v16 = 0;
    size_t v15 = 0;
  }
  uint64_t result = sub_1CD5AEBAC(v5, v6, v7, v10, v11, v15, v16, 2, 1u);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1BCC(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (unint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t result = llvm::DIMacroFile::getImpl(v4, *(unsigned __int16 *)(a2 + 2), *(_DWORD *)(a2 + 24), *v5, v5[1], 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1C24(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t v6 = v5[2];
  if (v6)
  {
    uint64_t v9 = *(void **)(v6 + 8);
    size_t v10 = *v9;
    int v8 = (unsigned __int8 *)(v9 + 3);
    size_t v7 = v10;
  }
  else
  {
    size_t v7 = 0;
    int v8 = 0;
  }
  uint64_t result = sub_1CD5D2B28(v4, *v5, v5[1], v8, v7, v5[3], *(_DWORD *)(a2 + 24));
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1C90(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t result = llvm::DIStringType::getImpl(v4, *(unsigned __int16 *)(a2 + 2), v5[2], v5[3], v5[4], v5[5], *(void *)(a2 + 32), *(_DWORD *)(a2 + 48), *(_DWORD *)(a2 + 52), 2, 1);
  *a1 = result;
  return result;
}

llvm::MDNode *sub_1CD5D1D00(llvm::MDNode **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = (uint64_t *)(a2 - 8 * *(unsigned int *)(a2 + 8));
  uint64_t result = llvm::DIGenericSubrange::getImpl(v4, *v5, v5[1], v5[2], v5[3], 2, 1);
  *a1 = result;
  return result;
}

uint64_t llvm::MDNode::resolve(uint64_t this)
{
  *(_DWORD *)(this + 12) = 0;
  return llvm::MDNode::dropReplaceableUses(this);
}

uint64_t llvm::MDNode::resolveCycles(uint64_t this)
{
  uint64_t v1 = this;
  if ((*(unsigned char *)(this + 1) & 0x7F) == 2 || *(_DWORD *)(this + 12))
  {
    *(_DWORD *)(this + 12) = 0;
    this = llvm::MDNode::dropReplaceableUses(this);
    uint64_t v2 = *(unsigned int *)(v1 + 8);
    if (v2)
    {
      uint64_t v3 = -8 * v2;
      do
      {
        this = *(void *)(v1 + v3);
        if (this)
        {
          int v4 = sub_1CB8F0DA8((unsigned char *)this);
          this = *(void *)(v1 + v3);
          if (v4) {
            BOOL v5 = this == 0;
          }
          else {
            BOOL v5 = 1;
          }
          if (!v5 && ((*(unsigned char *)(this + 1) & 0x7F) == 2 || *(_DWORD *)(this + 12))) {
            this = llvm::MDNode::resolveCycles((llvm::MDNode *)this);
          }
        }
        v3 += 8;
      }
      while (v3);
    }
  }
  return this;
}

llvm::MDNode *llvm::MDNode::replaceWithPermanentImpl(llvm::MDNode *this)
{
  unsigned int v2 = *(unsigned __int8 *)this;
  BOOL v3 = v2 > 0x22;
  uint64_t v4 = (1 << v2) & 0x7FFFEFFF0;
  if (v3 || v4 == 0) {
    goto LABEL_13;
  }
  uint64_t v6 = *((unsigned int *)this + 2);
  if (v6)
  {
    uint64_t v7 = -8 * v6;
    while (*(llvm::MDNode **)((char *)this + v7) != this)
    {
      v7 += 8;
      if (!v7)
      {
        int v8 = this;
        goto LABEL_12;
      }
    }
    int v8 = (llvm::MDNode *)((char *)this + v7);
  }
  else
  {
    int v8 = (llvm::MDNode *)((char *)this - 8 * v6);
  }
LABEL_12:
  if (v8 == this)
  {
    return llvm::MDNode::replaceWithUniquedImpl(this);
  }
  else
  {
LABEL_13:
    llvm::MDNode::dropReplaceableUses((uint64_t)this);
    llvm::MDNode::storeDistinctInContext(this);
    return this;
  }
}

llvm::MDNode *llvm::MDNode::getMostGenericFPMath(llvm::MDNode *this, llvm::MDNode *a2, llvm::MDNode *a3)
{
  BOOL v3 = 0;
  uint64_t v10[3] = *MEMORY[0x1E4F143B8];
  if (this && a2)
  {
    sub_1CB87DDC4((uint64_t)v10, (uint64_t *)(*(void *)(*((void *)this - *((unsigned int *)this + 2)) + 128) + 32));
    sub_1CB87DDC4((uint64_t)v8, (uint64_t *)(*(void *)(*((void *)a2 - *((unsigned int *)a2 + 2)) + 128) + 32));
    if (sub_1CB88A72C((uint64_t)v9, (uint64_t)v7)) {
      BOOL v3 = a2;
    }
    else {
      BOOL v3 = this;
    }
    sub_1CB87DEE4(v8);
    sub_1CB87DEE4(v10);
  }
  return v3;
}

llvm::MDNode *llvm::MDNode::getMostGenericAlignmentOrDereferenceable(llvm::MDNode *this, llvm::MDNode *a2, llvm::MDNode *a3)
{
  uint64_t v3 = 0;
  if (this && a2)
  {
    uint64_t v4 = *(void *)(*((void *)this - *((unsigned int *)this + 2)) + 128);
    uint64_t v5 = *(void *)(*((void *)a2 - *((unsigned int *)a2 + 2)) + 128);
    uint64_t v6 = (void *)(v4 + 24);
    if (*(_DWORD *)(v4 + 32) >= 0x41u) {
      uint64_t v6 = (void *)*v6;
    }
    uint64_t v7 = (void *)*v6;
    int v8 = (void *)(v5 + 24);
    if (*(_DWORD *)(v5 + 32) >= 0x41u) {
      int v8 = (void *)*v8;
    }
    if ((unint64_t)v7 >= *v8) {
      return a2;
    }
    else {
      return this;
    }
  }
  return (llvm::MDNode *)v3;
}

void llvm::Value::setMetadata(uint64_t a1, unsigned __int8 *a2, size_t a3, llvm::MDNode *a4)
{
  if (a4 || (*(unsigned char *)(a1 + 23) & 0x20) != 0)
  {
    int MDKindID = llvm::LLVMContext::getMDKindID(**(uint64_t ***)a1, a2, a3);
    llvm::Value::setMetadata((uint64_t ***)a1, MDKindID, a4);
  }
}

void llvm::Instruction::addAnnotationMetadata(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v21[4] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = **(uint64_t ***)a1;
  if (!*(void *)(a1 + 48) && (*(unsigned char *)(a1 + 23) & 0x20) == 0)
  {
    unsigned int v19 = v21;
    uint64_t v20 = 0x400000000;
LABEL_15:
    size_t v16 = llvm::MDBuilder::createString(&v18, a2, a3);
    if (v20 >= HIDWORD(v20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v19 + v2llvm::MDNode::dumpTree(this, 0) = v16;
    unsigned int v9 = v20 + 1;
    LODWORD(v2llvm::MDNode::dumpTree(this, 0) = v20 + 1;
    goto LABEL_17;
  }
  uint64_t Metadata = llvm::Value::getMetadata((llvm::Value *)a1, 30);
  unsigned int v19 = v21;
  uint64_t v20 = 0x400000000;
  if (!Metadata) {
    goto LABEL_15;
  }
  uint64_t v7 = Metadata;
  uint64_t v8 = *(unsigned int *)(Metadata + 8);
  if (!v8) {
    goto LABEL_15;
  }
  unsigned int v9 = 0;
  uint64_t v10 = -8 * v8;
  char v11 = 1;
  do
  {
    uint64_t v12 = *(void *)(v7 + v10);
    uint64_t v13 = *(uint64_t **)(v12 + 8);
    uint64_t v15 = *v13;
    size_t v14 = v13 + 3;
    if (v15 == a3 && (!a3 || !memcmp(v14, a2, a3))) {
      char v11 = 0;
    }
    if (v9 >= HIDWORD(v20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v19 + v9) = v12;
    unsigned int v9 = v20 + 1;
    LODWORD(v2llvm::MDNode::dumpTree(this, 0) = v20 + 1;
    v10 += 8;
  }
  while (v10);
  if (v11) {
    goto LABEL_15;
  }
LABEL_17:
  uint64_t Impl = llvm::MDTuple::getImpl(**(void **)a1, v19, v9, 0, 1);
  if (Impl || *(void *)(a1 + 48) || (*(unsigned char *)(a1 + 23) & 0x20) != 0) {
    llvm::Value::setMetadata((uint64_t ***)a1, 30, Impl);
  }
  if (v19 != v21) {
    free(v19);
  }
}

void llvm::GlobalObject::addTypeMetadata(llvm::Type ***this, llvm::LLVMContext *a2, llvm::Metadata *a3)
{
  unsigned int v4 = a2;
  void v11[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = **this;
  Int64Ty = (llvm::ConstantInt *)llvm::Type::getInt64Ty(v6, a2);
  uint64_t v8 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(Int64Ty, v4, 0);
  v11[0] = llvm::ValueAsMetadata::get(v8, v9);
  v11[1] = a3;
  uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)v6, v11, 2, 0, 1);
  llvm::Value::addMetadata((llvm::Value *)this, 19, Impl);
}

void llvm::GlobalObject::setVCallVisibilityMetadata(llvm::Value *a1, unsigned int a2)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  llvm::Value::eraseMetadata(a1, 28);
  unsigned int v4 = **(llvm::Type ***)a1;
  Int64Ty = (llvm::ConstantInt *)llvm::Type::getInt64Ty(v4, v5);
  uint64_t v7 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(Int64Ty, a2, 0);
  v10[0] = llvm::ValueAsMetadata::get(v7, v8);
  uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)v4, v10, 1, 0, 1);
  llvm::Value::addMetadata(a1, 28, Impl);
}

uint64_t llvm::GlobalObject::getVCallVisibility(llvm::GlobalObject *this)
{
  uint64_t result = llvm::Value::getMetadata(this, 28);
  if (result)
  {
    uint64_t v2 = *(void *)(*(void *)(result - 8 * *(unsigned int *)(result + 8)) + 128);
    uint64_t v3 = (unsigned int *)(v2 + 24);
    if (*(_DWORD *)(v2 + 32) >= 0x41u) {
      uint64_t v3 = *(unsigned int **)v3;
    }
    return *v3;
  }
  return result;
}

uint64_t *llvm::GlobalObject::getVTableOffsetRange(llvm::GlobalObject *this)
{
  uint64_t result = (uint64_t *)llvm::Value::getMetadata(this, 28);
  if (result)
  {
    uint64_t v2 = *((unsigned int *)result + 2);
    if (v2 < 3)
    {
      return 0;
    }
    else
    {
      uint64_t v3 = &result[-v2];
      uint64_t v4 = *(void *)(v3[1] + 128);
      uint64_t v5 = (uint64_t *)(v4 + 24);
      if (*(_DWORD *)(v4 + 32) >= 0x41u) {
        uint64_t v5 = (uint64_t *)*v5;
      }
      return (uint64_t *)*v5;
    }
  }
  return result;
}

void llvm::GlobalVariable::addDebugInfo(llvm::Value *a1, llvm::MDNode *a2)
{
}

llvm::MDNode *sub_1CD5D249C(void *a1, int a2, unsigned __int8 *a3, size_t __n, unsigned __int8 **a5, uint64_t a6)
{
  if (__n)
  {
    uint64_t v10 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v11) {
      *(void *)(v10 + 16) = v10;
    }
    uint64_t v12 = v10 + 8;
  }
  else
  {
    uint64_t v12 = 0;
  }

  return llvm::GenericDINode::getImpl(a1, a2, v12, a5, a6, 2, 1);
}

llvm::MDNode *sub_1CD5D252C(void *a1, const llvm::APInt *a2, int a3, unsigned __int8 *a4, size_t __n)
{
  if (__n)
  {
    uint64_t v8 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a4, __n);
    if (v9) {
      *(void *)(v8 + 16) = v8;
    }
    uint64_t v10 = v8 + 8;
  }
  else
  {
    uint64_t v10 = 0;
  }

  return llvm::DIEnumerator::getImpl(a1, a2, a3, v10, 2, 1);
}

llvm::MDNode *sub_1CD5D25B4(void *a1, int a2, unsigned __int8 *a3, size_t __n, uint64_t a5, int a6, int a7, int a8)
{
  if (__n)
  {
    uint64_t v14 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v15) {
      *(void *)(v14 + 16) = v14;
    }
    uint64_t v16 = v14 + 8;
  }
  else
  {
    uint64_t v16 = 0;
  }
  return llvm::DIBasicType::getImpl(a1, a2, v16, a5, a6, a7, a8, 2, 1);
}

uint64_t sub_1CD5D265C(void *a1, int a2, unsigned __int8 *a3, size_t __n, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (__n)
  {
    int v22 = a2;
    uint64_t v23 = a5;
    int v24 = a6;
    uint64_t v25 = a7;
    uint64_t v18 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v19) {
      *(void *)(v18 + 16) = v18;
    }
    uint64_t v20 = v18 + 8;
    a7 = v25;
    a6 = v24;
    a5 = v23;
    a2 = v22;
  }
  else
  {
    uint64_t v20 = 0;
  }

  return llvm::DIDerivedType::getImpl(a1, a2, v20, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, 2, 1);
}

llvm::MDNode *sub_1CD5D2760(void *a1, uint64_t a2, unsigned __int8 *a3, size_t __n, char a5)
{
  if (__n)
  {
    uint64_t v8 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v9) {
      *(void *)(v8 + 16) = v8;
    }
    uint64_t v10 = v8 + 8;
  }
  else
  {
    uint64_t v10 = 0;
  }

  return llvm::DINamespace::getImpl(a1, a2, v10, a5, 2, 1);
}

llvm::MDNode *sub_1CD5D27E8(void *a1, unsigned __int8 *a2, size_t a3, uint64_t a4, char a5)
{
  if (a3)
  {
    uint64_t v8 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a2, a3);
    if (v9) {
      *(void *)(v8 + 16) = v8;
    }
    uint64_t v10 = v8 + 8;
  }
  else
  {
    uint64_t v10 = 0;
  }

  return llvm::DITemplateTypeParameter::getImpl(a1, v10, a4, a5, 2, 1);
}

llvm::MDNode *sub_1CD5D2868(void *a1, int a2, unsigned __int8 *a3, size_t __n, uint64_t a5, char a6, uint64_t a7)
{
  if (__n)
  {
    uint64_t v12 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v13) {
      *(void *)(v12 + 16) = v12;
    }
    uint64_t v14 = v12 + 8;
  }
  else
  {
    uint64_t v14 = 0;
  }

  return llvm::DITemplateValueParameter::getImpl(a1, a2, v14, a5, a6, a7, 2, 1);
}

llvm::MDNode *sub_1CD5D2908(void *a1, uint64_t a2, unsigned __int8 *a3, size_t __n, uint64_t a5, int a6, uint64_t a7, int a8, int a9, int a10, uint64_t a11)
{
  if (__n)
  {
    uint64_t v17 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v18) {
      *(void *)(v17 + 16) = v17;
    }
    uint64_t v19 = v17 + 8;
  }
  else
  {
    uint64_t v19 = 0;
  }
  return llvm::DILocalVariable::getImpl(a1, a2, v19, a5, a6, a7, a8, a9, a10, a11, 2, 1);
}

llvm::MDNode *sub_1CD5D29D8(void *a1, uint64_t a2, unsigned __int8 *a3, size_t __n, uint64_t a5, int a6)
{
  if (__n)
  {
    uint64_t v10 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a3, __n);
    if (v11) {
      *(void *)(v10 + 16) = v10;
    }
    uint64_t v12 = v10 + 8;
  }
  else
  {
    uint64_t v12 = 0;
  }

  return llvm::DILabel::getImpl(a1, a2, v12, a5, a6, 2, 1);
}

llvm::MDNode *sub_1CD5D2A68(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned __int8 *a7, size_t __n, uint64_t a9)
{
  if (__n)
  {
    uint64_t v15 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a7, __n);
    if (v16) {
      *(void *)(v15 + 16) = v15;
    }
    uint64_t v17 = v15 + 8;
  }
  else
  {
    uint64_t v17 = 0;
  }

  return llvm::DIImportedEntity::getImpl(a1, a2, a3, a4, a5, a6, v17, a9, 2, 1);
}

llvm::MDNode *sub_1CD5D2B28(void *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, size_t __n, uint64_t a6, int a7)
{
  if (__n)
  {
    uint64_t v12 = *sub_1CC5FBBE4((uint64_t *)(*a1 + 272), a4, __n);
    if (v13) {
      *(void *)(v12 + 16) = v12;
    }
    uint64_t v14 = v12 + 8;
  }
  else
  {
    uint64_t v14 = 0;
  }

  return llvm::DICommonBlock::getImpl(a1, a2, a3, v14, a6, a7, 2, 1);
}

void *sub_1CD5D2BC8(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC6054A0(a1, *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CC605550(a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
    void v5[2] = 0;
  }
  return v5;
}

void *sub_1CD5D2C30(void *result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  unsigned int v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 5)
  {
    uint64_t v6 = result + 1;
    uint64_t *result = 1;
    uint64_t v7 = result + 13;
    goto LABEL_18;
  }
  if ((v2 & 1) == 0)
  {
    if (v5 != *((_DWORD *)result + 4))
    {
      MEMORY[0x1D25D9CD0](result[1], 8);
      goto LABEL_12;
    }
    uint64_t *result = 0;
    if (!v5) {
      return result;
    }
    uint64_t v6 = (void *)result[1];
    uint64_t v7 = &v6[3 * v5];
    do
    {
LABEL_18:
      *uint64_t v6 = -4096;
      v6 += 3;
    }
    while (v6 != v7);
    return result;
  }
LABEL_12:

  return sub_1CC6052FC(v1, v5);
}

void llvm::SymbolTableListTraits<llvm::GlobalVariable>::transferNodesFromList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v6 = a1 - 8;
    uint64_t v7 = *(llvm::ValueSymbolTable **)(a1 + 104);
    uint64_t v8 = *(uint64_t **)(a2 + 104);
    if (v7 == (llvm::ValueSymbolTable *)v8)
    {
      while (a3 != a4)
      {
        uint64_t v12 = a3 - 56;
        if (!a3) {
          uint64_t v12 = 0;
        }
        *(void *)(v12 + 4llvm::MDNode::dumpTree(this, 0) = v6;
        a3 = *(void *)(a3 + 8);
      }
    }
    else
    {
      while (a3 != a4)
      {
        if (a3) {
          uint64_t v9 = a3 - 56;
        }
        else {
          uint64_t v9 = 0;
        }
        int v10 = *(_DWORD *)(v9 + 20) & 0x10000000;
        if (v8 && v10)
        {
          ValueName = (size_t *)llvm::Value::getValueName((llvm::Value *)v9);
          llvm::ValueSymbolTable::removeValueName(v8, ValueName);
        }
        *(void *)(v9 + 4llvm::MDNode::dumpTree(this, 0) = v6;
        if (v7)
        {
          if (v10) {
            llvm::ValueSymbolTable::reinsertValue(v7, (llvm::Value *)v9);
          }
        }
        a3 = *(void *)(a3 + 8);
      }
    }
  }
}

void llvm::SymbolTableListTraits<llvm::GlobalAlias>::addNodeToList(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 4llvm::MDNode::dumpTree(this, 0) = a1 - 40;
  if ((*(unsigned char *)(a2 + 23) & 0x10) != 0)
  {
    unsigned int v2 = *(llvm::ValueSymbolTable **)(a1 + 72);
    if (v2) {
      llvm::ValueSymbolTable::reinsertValue(v2, (llvm::Value *)a2);
    }
  }
}

int32x2_t llvm::SymbolTableListTraits<llvm::GlobalAlias>::removeNodeFromList(uint64_t a1, llvm::Value *this)
{
  *((void *)this + 5) = 0;
  if ((*((unsigned char *)this + 23) & 0x10) != 0)
  {
    unsigned int v2 = *(uint64_t **)(a1 + 72);
    if (v2)
    {
      ValueName = (size_t *)llvm::Value::getValueName(this);
      return llvm::ValueSymbolTable::removeValueName(v2, ValueName);
    }
  }
  return result;
}

void llvm::SymbolTableListTraits<llvm::GlobalIFunc>::addNodeToList(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 4llvm::MDNode::dumpTree(this, 0) = a1 - 56;
  if ((*(unsigned char *)(a2 + 23) & 0x10) != 0)
  {
    unsigned int v2 = *(llvm::ValueSymbolTable **)(a1 + 56);
    if (v2) {
      llvm::ValueSymbolTable::reinsertValue(v2, (llvm::Value *)a2);
    }
  }
}

int32x2_t llvm::SymbolTableListTraits<llvm::GlobalIFunc>::removeNodeFromList(uint64_t a1, llvm::Value *this)
{
  *((void *)this + 5) = 0;
  if ((*((unsigned char *)this + 23) & 0x10) != 0)
  {
    unsigned int v2 = *(uint64_t **)(a1 + 56);
    if (v2)
    {
      ValueName = (size_t *)llvm::Value::getValueName(this);
      return llvm::ValueSymbolTable::removeValueName(v2, ValueName);
    }
  }
  return result;
}

llvm::detail::IEEEFloat *llvm::Module::getOrInsertGlobal(uint64_t a1, unsigned __int8 *a2, unint64_t a3, llvm::PointerType *a4, uint64_t (*a5)(uint64_t), uint64_t a6)
{
  uint64_t v9 = sub_1CC196FC4(*(uint64_t **)(a1 + 112), a2, a3);
  if (!v9 || (int v10 = (llvm::detail::IEEEFloat *)v9, *(unsigned char *)(v9 + 16) != 3)) {
    int v10 = (llvm::detail::IEEEFloat *)a5(a6);
  }
  char v11 = *(llvm::Constant **)v10;
  unsigned int v12 = *(_DWORD *)(*(void *)v10 + 8);
  if ((v12 & 0xFE) == 0x12) {
    unsigned int v12 = *(_DWORD *)(**((void **)v11 + 2) + 8);
  }
  char v13 = (llvm::Constant *)llvm::PointerType::get(a4, (llvm::Type *)(v12 >> 8));
  if (v11 == v13) {
    return v10;
  }

  return llvm::ConstantExpr::getBitCast(v10, v13, 0);
}

llvm::detail::IEEEFloat *llvm::Module::getOrInsertGlobal(uint64_t a1, unsigned __int8 *a2, unint64_t a3, llvm::PointerType *a4)
{
  v7[0] = a2;
  v7[1] = a3;
  v5[0] = a1;
  v5[1] = &v6;
  void v5[2] = v7;
  uint64_t v6 = a4;
  return llvm::Module::getOrInsertGlobal(a1, a2, a3, a4, (uint64_t (*)(uint64_t))sub_1CC60E26C, (uint64_t)v5);
}

uint64_t llvm::Module::getNamedAlias(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  uint64_t result = sub_1CC196FC4(*(uint64_t **)(a1 + 112), a2, a3);
  if (result)
  {
    if (*(unsigned char *)(result + 16) != 1) {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::Module::getOrInsertModuleFlagsMetadata(llvm::Module *this)
{
  return llvm::Module::getOrInsertNamedMetadata(this, "llvm.module.flags", 0x11uLL);
}

void *llvm::Module::addModuleFlag(uint64_t **a1, llvm::Value *a2, unsigned __int8 *a3, size_t a4, llvm::ValueAsMetadata *this)
{
  uint64_t v9 = llvm::ValueAsMetadata::get(this, a2);

  return llvm::Module::addModuleFlag(a1, a2, a3, a4, v9);
}

void llvm::Module::setModuleFlag(uint64_t **a1, llvm::Type *a2, void *a3, size_t a4, llvm::Metadata *a5)
{
  uint64_t inserted = llvm::Module::getOrInsertNamedMetadata(a1, "llvm.module.flags", 0x11uLL);
  uint64_t v11 = *(unsigned int *)(*(void *)(inserted + 48) + 8);
  if (v11)
  {
    uint64_t v12 = inserted;
    uint64_t v13 = 0;
    uint64_t v14 = 8 * v11;
    while (1)
    {
      uint64_t v15 = *(llvm::MDNode **)(**(void **)(v12 + 48) + v13);
      uint64_t v20 = 0;
      if (llvm::Module::isValidModuleFlag((uint64_t)v15, &v21, &v20, &v19))
      {
        char v16 = *(uint64_t **)(v20 + 8);
        uint64_t v18 = *v16;
        uint64_t v17 = v16 + 3;
        if (v18 == a4 && (!a4 || !memcmp(v17, a3, a4))) {
          break;
        }
      }
      v13 += 8;
      if (v14 == v13) {
        goto LABEL_8;
      }
    }
    llvm::MDNode::replaceOperandWith(v15, 2, a5);
  }
  else
  {
LABEL_8:
    llvm::Module::addModuleFlag(a1, a2, (unsigned __int8 *)a3, a4, (uint64_t)a5);
  }
}

uint64_t llvm::Module::materialize@<X0>(llvm::Module *this@<X0>, llvm::GlobalValue *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = *((void *)this + 20);
  if (result) {
    return (*(uint64_t (**)(uint64_t, llvm::GlobalValue *))(*(void *)result + 16))(result, a2);
  }
  *a3 = 0;
  return result;
}

void *llvm::Module::getIdentifiedStructTypes@<X0>(llvm::Module *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((void *)this + 20);
  if (v4)
  {
    unsigned int v5 = *(uint64_t (**)(void))(*(void *)v4 + 48);
    return (void *)v5();
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    v7[0] = 0;
    v7[1] = 0;
    int v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    int v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    int v17 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v18 = 0;
    char v21 = 0;
    llvm::TypeFinder::run((llvm::TypeFinder *)v7, this, 1);
    sub_1CC60E308(a2, v18, v19, (v19 - v18) >> 3);
    return sub_1CC60DBB0(v7);
  }
}

void llvm::Module::getUniqueIntrinsicName(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, size_t a3@<X2>, int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v12 = a1 + 736;
  int v24 = a4;
  uint64_t v25 = a5;
  unsigned int v26 = 0;
  sub_1CD5D3AB0((uint64_t)&v27, a1 + 736, (uint64_t)&v24, &v26);
  if ((_BYTE)v28)
  {
    int v23 = 0;
    int v22 = sub_1CC60E44C((llvm::StringMapImpl *)(a1 + 704), a2, a3, &v23);
    unsigned int v13 = *(_DWORD *)(*v22 + 8);
    *(void *)a6 = 0;
    *(void *)(a6 + sub_1CD521E44((uint64_t)this + 8) = 0;
    *(void *)(a6 + 16) = 0;
    while (1)
    {
      sub_1CC60C09C(&v27, (uint64_t)a2, a3, v13);
      if (*(char *)(a6 + 23) < 0) {
        operator delete(*(void **)a6);
      }
      *(_OWORD *)a6 = v27;
      unint64_t v14 = v28;
      *(void *)(a6 + 16) = v28;
      unint64_t v15 = HIBYTE(v14);
      BOOL v16 = (v15 & 0x80u) != 0;
      int v17 = (v15 & 0x80u) == 0 ? (unsigned __int8 *)a6 : *(unsigned __int8 **)a6;
      uint64_t v18 = v15 & 0x7F;
      unint64_t v19 = v16 ? *(void *)(a6 + 8) : v18;
      uint64_t v20 = sub_1CC196FC4(*(uint64_t **)(a1 + 112), v17, v19);
      if (!v20) {
        break;
      }
      if (*(unsigned char *)(*(void *)(v20 + 24) + 8) == 14) {
        uint64_t v21 = *(void *)(v20 + 24);
      }
      else {
        uint64_t v21 = 0;
      }
      int v24 = a4;
      uint64_t v25 = v21;
      unsigned int v26 = v13;
      sub_1CD5D3AB0((uint64_t)&v27, v12, (uint64_t)&v24, &v26);
      if (v21 == a5)
      {
        *(_DWORD *)(v27 + 16) = v13;
        goto LABEL_18;
      }
      ++v13;
    }
    LODWORD(v27) = a4;
    *((void *)&v27 + 1) = a5;
    *(_DWORD *)(sub_1CD5D3ED8(v12, (uint64_t)&v27) + 16) = v13;
LABEL_18:
    *(_DWORD *)(*v22 + sub_1CD521E44((uint64_t)this + 8) = v13 + 1;
  }
  else
  {
    sub_1CC60C09C((void *)a6, (uint64_t)a2, a3, *(_DWORD *)(v27 + 16));
  }
}

uint64_t llvm::Module::getInstructionCount(llvm::Module *this)
{
  uint64_t v1 = (char *)this + 24;
  unsigned int v2 = (char *)*((void *)this + 4);
  if (v2 == (char *)this + 24) {
    return 0;
  }
  LODWORD(v3) = 0;
  do
  {
    if (v2) {
      uint64_t v4 = (llvm::Function *)(v2 - 56);
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t v3 = llvm::Function::getInstructionCount(v4) + v3;
    unsigned int v2 = (char *)*((void *)v2 + 1);
  }
  while (v2 != v1);
  return v3;
}

size_t *llvm::Module::getOrInsertComdat(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v5 = a1 + 120;
  llvm::Comdat::Comdat((llvm::Comdat *)v8);
  uint64_t v10 = a2;
  size_t v11 = a3;
  llvm::Comdat::Comdat((uint64_t)v12, (uint64_t)v8);
  uint64_t v6 = *sub_1CD5D3F54(v5, v10, v11, (uint64_t)v12);
  if (v13 != (void *)v12[2]) {
    free(v13);
  }
  if (v9 != (void *)v8[2]) {
    free(v9);
  }
  uint64_t result = v6 + 1;
  v6[1] = (size_t)v6;
  return result;
}

void *llvm::Module::setPICLevel(uint64_t **a1, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(a1, (llvm::Type *)7, "PIC Level", 9uLL, a2);
}

uint64_t llvm::Module::getPIELevel(llvm::Module *this)
{
  uint64_t result = llvm::Module::getModuleFlag(this, "PIE Level", 9uLL);
  if (result)
  {
    uint64_t v2 = *(void *)(result + 128);
    uint64_t v3 = (unsigned int *)(v2 + 24);
    if (*(_DWORD *)(v2 + 32) >= 0x41u) {
      uint64_t v3 = *(unsigned int **)v3;
    }
    return *v3;
  }
  return result;
}

void *llvm::Module::setPIELevel(uint64_t **a1, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(a1, (llvm::Type *)7, "PIE Level", 9uLL, a2);
}

uint64_t llvm::Module::getCodeModel(llvm::Module *this)
{
  uint64_t result = llvm::Module::getModuleFlag(this, "Code Model", 0xAuLL);
  if (result)
  {
    uint64_t v2 = *(void *)(result + 128);
    uint64_t v3 = (unsigned int *)(v2 + 24);
    if (*(_DWORD *)(v2 + 32) >= 0x41u) {
      uint64_t v3 = *(unsigned int **)v3;
    }
    return *v3 | 0x100000000;
  }
  return result;
}

void *llvm::Module::setCodeModel(uint64_t **a1, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(a1, (llvm::Type *)1, "Code Model", 0xAuLL, a2);
}

void llvm::Module::setProfileSummary(uint64_t **a1, llvm::Metadata *a2, int a3)
{
  BOOL v3 = a3 == 1;
  if (a3 == 1) {
    uint64_t v4 = "CSProfileSummary";
  }
  else {
    uint64_t v4 = "ProfileSummary";
  }
  if (v3) {
    size_t v5 = 16;
  }
  else {
    size_t v5 = 14;
  }
  llvm::Module::setModuleFlag(a1, (llvm::Type *)1, v4, v5, a2);
}

void *llvm::Module::setSemanticInterposition(uint64_t **this, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(this, (llvm::Type *)1, "SemanticInterposition", 0x15uLL, a2);
}

uint64_t llvm::Module::setOwnedMemoryBuffer(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t llvm::Module::getRtLibUseGOT(llvm::Module *this)
{
  uint64_t result = llvm::Module::getModuleFlag(this, "RtLibUseGOT", 0xBuLL);
  if (result)
  {
    uint64_t v2 = *(void *)(result + 128);
    uint64_t v3 = (void *)(v2 + 24);
    if (*(_DWORD *)(v2 + 32) >= 0x41u) {
      uint64_t v3 = (void *)*v3;
    }
    return *v3 != 0;
  }
  return result;
}

void *llvm::Module::setRtLibUseGOT(uint64_t **this)
{
  return llvm::Module::addModuleFlag(this, (llvm::Type *)7, "RtLibUseGOT", 0xBuLL, (llvm::Type *)1);
}

uint64_t llvm::Module::getUwtable(llvm::Module *this)
{
  uint64_t result = llvm::Module::getModuleFlag(this, "uwtable", 7uLL);
  if (result)
  {
    uint64_t v2 = *(void *)(result + 128);
    uint64_t v3 = (unsigned int *)(v2 + 24);
    if (*(_DWORD *)(v2 + 32) >= 0x41u) {
      uint64_t v3 = *(unsigned int **)v3;
    }
    return *v3;
  }
  return result;
}

void *llvm::Module::setUwtable(uint64_t **a1, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(a1, (llvm::Type *)7, "uwtable", 7uLL, a2);
}

uint64_t llvm::Module::getFramePointer(llvm::Module *this)
{
  uint64_t result = llvm::Module::getModuleFlag(this, "frame-pointer", 0xDuLL);
  if (result)
  {
    uint64_t v2 = *(void *)(result + 128);
    uint64_t v3 = (unsigned int *)(v2 + 24);
    if (*(_DWORD *)(v2 + 32) >= 0x41u) {
      uint64_t v3 = *(unsigned int **)v3;
    }
    return *v3;
  }
  return result;
}

void *llvm::Module::setFramePointer(uint64_t **a1, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(a1, (llvm::Type *)7, "frame-pointer", 0xDuLL, a2);
}

uint64_t llvm::Module::getStackProtectorGuard(llvm::Module *this)
{
  uint64_t result = llvm::Module::getModuleFlag(this, "stack-protector-guard", 0x15uLL);
  if (result)
  {
    if (*(unsigned char *)result) {
      return 0;
    }
    else {
      return *(void *)(result + 8) + 24;
    }
  }
  return result;
}

void *llvm::Module::setStackProtectorGuard(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v4 = llvm::MDString::get(*a1, a2, a3);

  return llvm::Module::addModuleFlag(a1, (llvm::Type *)1, "stack-protector-guard", 0x15uLL, (uint64_t)v4);
}

void *llvm::Module::setStackProtectorGuardReg(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v4 = llvm::MDString::get(*a1, a2, a3);

  return llvm::Module::addModuleFlag(a1, (llvm::Type *)1, "stack-protector-guard-reg", 0x19uLL, (uint64_t)v4);
}

void *llvm::Module::setStackProtectorGuardOffset(uint64_t **this, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(this, (llvm::Type *)1, "stack-protector-guard-offset", 0x1CuLL, a2);
}

void *llvm::Module::setOverrideStackAlignment(uint64_t **this, llvm::Type *a2)
{
  return llvm::Module::addModuleFlag(this, (llvm::Type *)1, "override-stack-alignment", 0x18uLL, a2);
}

void llvm::Module::setSDKVersion(uint64_t **this, const llvm::VersionTuple *a2)
{
}

void *llvm::Module::setPtrAuthABIVersion(uint64_t **a1, unint64_t a2)
{
  _DWORD v14[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::Type *)*a1;
  size_t v5 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get((llvm::ConstantInt *)(**a1 + 1960), (int)a2, 0);
  uint64_t v7 = llvm::ValueAsMetadata::get(v5, v6);
  Int1Ty = (llvm::ConstantInt *)llvm::Type::getInt1Ty(v4, v8);
  uint64_t v10 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(Int1Ty, HIDWORD(a2) & 1, 0);
  v14[0] = v7;
  v14[1] = llvm::ValueAsMetadata::get(v10, v11);
  v14[0] = llvm::MDTuple::getImpl((uint64_t)v4, v14, 2, 0, 1);
  uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)v4, v14, 1, 0, 1);
  return llvm::Module::addModuleFlag(a1, (llvm::Type *)6, "ptrauth.abi-version", 0x13uLL, (uint64_t)Impl);
}

void *llvm::Module::setDarwinTargetVariantTriple(uint64_t **a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v4 = llvm::MDString::get(*a1, a2, a3);

  return llvm::Module::addModuleFlag(a1, (llvm::Type *)4, "darwin.target_variant.triple", 0x1CuLL, (uint64_t)v4);
}

void llvm::Module::setDarwinTargetVariantSDKVersion(uint64_t **a1, uint64_t a2, int a3)
{
}

uint64_t sub_1CD5D3AB0(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD5D3B5C(*(void *)a2, *(_DWORD *)(a2 + 16), *(_DWORD *)a3, *(void *)(a3 + 8), &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = sub_1CD5D3C58(a2, a3, v12);
    uint64_t v9 = result;
    *(_DWORD *)uint64_t result = *(_DWORD *)a3;
    *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a3 + 8);
    *(_DWORD *)(result + 16) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD5D3B5C(uint64_t a1, int a2, int a3, uint64_t a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((a4 >> 4) ^ (a4 >> 9) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)((a4 >> 4) ^ (a4 >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    char v10 = (int *)(a1 + 24 * v9);
    int v11 = *v10;
    uint64_t v12 = *((void *)v10 + 1);
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      BOOL v16 = 0;
      int v17 = 1;
      while (v11 != -1 || v12 != -4096)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v12 == -8192;
        }
        if (v18 && v11 == -2) {
          BOOL v16 = v10;
        }
        unsigned int v20 = v9 + v17++;
        unsigned int v9 = v20 & v8;
        char v10 = (int *)(a1 + 24 * (v20 & v8));
        int v11 = *v10;
        uint64_t v12 = *((void *)v10 + 1);
        uint64_t v14 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        char v10 = v16;
      }
    }
  }
  else
  {
    char v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

uint64_t sub_1CD5D3C58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1CD5D3D1C(a1, v6);
    uint64_t v8 = 0;
    sub_1CD5D3B5C(*(void *)a1, *(_DWORD *)(a1 + 16), *(_DWORD *)a2, *(void *)(a2 + 8), &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)a3 != -1 || *(void *)(a3 + 8) != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD5D3D1C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5D3DF8(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      _OWORD *result = xmmword_1CFB1B6D0;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5D3DF8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_OWORD **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *int v7 = xmmword_1CFB1B6D0;
      int v7 = (_OWORD *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    int v9 = *(_DWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 8);
    if ((*(_DWORD *)a2 != -1 || v10 != -4096) && (v9 != -2 || v10 != -8192))
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CD5D3B5C(*(void *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *(_DWORD *)a2;
      *((void *)v11 + 1) = *(void *)(a2 + 8);
      uint64_t v11[4] = *(_DWORD *)(a2 + 16);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1CD5D3ED8(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD5D3B5C(*(void *)a1, *(_DWORD *)(a1 + 16), *(_DWORD *)a2, *(void *)(a2 + 8), &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5D3C58(a1, a2, v7);
    *(_DWORD *)uint64_t v5 = *(_DWORD *)a2;
    *(void *)(v5 + sub_1CD521E44((uint64_t)this + 8) = *(void *)(a2 + 8);
    *(_DWORD *)(v5 + 16) = 0;
  }
  return v5;
}

size_t **sub_1CD5D3F54(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4)
{
  uint64_t v8 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (size_t **)(*(void *)a1 + 8 * v8);
  uint64_t v10 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v10)
  {
    while (!v10 || v10 == (size_t *)-8)
    {
      uint64_t v11 = i[1];
      ++i;
      uint64_t v10 = v11;
    }
    return i;
  }
  uint64_t v12 = operator new(a3 + 73, (std::align_val_t)8uLL);
  unsigned int v13 = v12;
  uint64_t v14 = (char *)(v12 + 9);
  if (a3) {
    memcpy(v12 + 9, a2, a3);
  }
  v14[a3] = 0;
  *unsigned int v13 = a3;
  llvm::Comdat::Comdat((uint64_t)(v13 + 1), a4);
  *uint64_t i = v13;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v8));
        !*i || *i + 1 == 0;
  return i;
}

uint64_t llvm::ValueInfo::isDSOLocal(llvm::ValueInfo *this, int a2)
{
  unint64_t v2 = *(void *)this & 0xFFFFFFFFFFFFFFF8;
  unsigned int v3 = *(uint64_t **)(v2 + 24);
  char v4 = *(uint64_t **)(v2 + 32);
  if (a2)
  {
    if (v4 != v3) {
      return HIBYTE(*(unsigned __int16 *)(*v3 + 12)) & 1;
    }
    return 0;
  }
  uint64_t v6 = (char *)v4 - (char *)v3;
  if (!v6) {
    return 0;
  }
  unint64_t v7 = (v6 & 0xFFFFFFFFFFFFFFF8) - 8;
  do
  {
    uint64_t v8 = *v3++;
    unsigned int v9 = *(unsigned __int16 *)(v8 + 12);
    uint64_t result = (v9 >> 8) & 1;
    if ((v9 & 0x100) == 0) {
      break;
    }
    unint64_t v10 = v7;
    v7 -= 8;
  }
  while (v10);
  return result;
}

unint64_t llvm::FunctionSummary::specialRefCounts(llvm::FunctionSummary *this)
{
  uint64_t v1 = *((void *)this + 5);
  unint64_t v2 = (unint64_t)(*((void *)this + 6) - v1) >> 3;
  if ((int)v2 - 1 < 0)
  {
    unint64_t v2 = 0;
LABEL_7:
    unsigned int v6 = 0;
  }
  else
  {
    unint64_t v3 = 0;
    unint64_t v4 = (unint64_t)(*((void *)this + 6) - v1) >> 3;
    while (1)
    {
      unsigned int v5 = v4 - 1;
      if ((*(void *)(v1 + 8 * (v4 - 1)) & 4) == 0) {
        break;
      }
      unint64_t v3 = (v3 + 1);
      LODWORD(v4) = v4 - 1;
      if (!v4) {
        goto LABEL_7;
      }
    }
    unsigned int v6 = 0;
    if ((int)v4 - 1 >= 0)
    {
      while ((*(void *)(v1 + 8 * v5) & 2) != 0)
      {
        ++v6;
        if (--v5 == -1)
        {
          unint64_t v2 = v3;
          unsigned int v6 = v4;
          return v6 | (v2 << 32);
        }
      }
    }
    unint64_t v2 = v3;
  }
  return v6 | (v2 << 32);
}

uint64_t llvm::ModuleSummaryIndex::getFlags(llvm::ModuleSummaryIndex *this)
{
  uint64_t v1 = *((unsigned __int8 *)this + 128);
  if (*((unsigned char *)this + 132)) {
    v1 |= 2uLL;
  }
  if (*((unsigned char *)this + 131)) {
    v1 |= 4uLL;
  }
  if (*((unsigned char *)this + 134)) {
    v1 |= 8uLL;
  }
  if (*((unsigned char *)this + 135)) {
    v1 |= 0x10uLL;
  }
  if (*((unsigned char *)this + 129)) {
    v1 |= 0x20uLL;
  }
  if (*((unsigned char *)this + 130)) {
    return v1 | 0x40;
  }
  else {
    return v1;
  }
}

unsigned char *llvm::ModuleSummaryIndex::setFlags(unsigned char *this, char a2)
{
  if (a2) {
    this[128] = 1;
  }
  if ((a2 & 2) != 0) {
    this[132] = 1;
  }
  if ((a2 & 4) != 0) {
    this[131] = 1;
  }
  if ((a2 & 8) != 0) {
    this[134] = 1;
  }
  if ((a2 & 0x10) != 0) {
    this[135] = 1;
  }
  if ((a2 & 0x20) != 0) {
    this[129] = 1;
  }
  if ((a2 & 0x40) != 0) {
    this[130] = 1;
  }
  return this;
}

uint64_t llvm::ModuleSummaryIndex::collectDefinedFunctionsForModule(uint64_t result, void *__s2, size_t __n, uint64_t a4)
{
  unint64_t v4 = (void *)(result + 8);
  unsigned int v5 = *(void **)result;
  if (*(void *)result != result + 8)
  {
    do
    {
      uint64_t v15 = v5[4];
      unsigned int v9 = (uint64_t *)v5[7];
      unint64_t v10 = (uint64_t *)v5[8];
      while (v9 != v10)
      {
        uint64_t v11 = *v9;
        if (*v9)
        {
          if (*(_DWORD *)(v11 + 8) == 1 && *(void *)(v11 + 32) == __n)
          {
            if (!__n || (uint64_t result = memcmp(*(const void **)(v11 + 24), __s2, __n), !result))
            {
              uint64_t result = (uint64_t)sub_1CD5D47AC(a4, &v15);
              *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = v11;
            }
          }
        }
        ++v9;
      }
      uint64_t v12 = (void *)v5[1];
      if (v12)
      {
        do
        {
          unsigned int v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          unsigned int v13 = (void *)v5[2];
          BOOL v14 = *v13 == (void)v5;
          unsigned int v5 = v13;
        }
        while (!v14);
      }
      unsigned int v5 = v13;
    }
    while (v13 != v4);
  }
  return result;
}

uint64_t llvm::ModuleSummaryIndex::getGlobalValueSummary(llvm::ModuleSummaryIndex *this, unint64_t a2)
{
  unint64_t v4 = (void *)*((void *)this + 1);
  unint64_t v2 = (char *)this + 8;
  unint64_t v3 = v4;
  if (!v4) {
    goto LABEL_12;
  }
  unsigned int v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v3 + 1;
    }
    if (v7) {
      unsigned int v5 = (char *)v3;
    }
    unint64_t v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 == v2 || *((void *)v5 + 4) > a2) {
LABEL_12:
  }
    unsigned int v5 = v2;
  if (v5 == v2) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = v5 + 32;
  }
  return **(void **)(((unint64_t)v9 & 0xFFFFFFFFFFFFFFF8) + 24);
}

void llvm::ModuleSummaryIndex::dumpSCCs(llvm::ModuleSummaryIndex *this, llvm::raw_ostream *a2)
{
  __p[19] = *(void **)MEMORY[0x1E4F143B8];
  __p[0] = this;
  sub_1CD4CB74C((uint64_t *)__p);
}

BOOL sub_1CD5D4640(void *a1, uint64_t a2)
{
  if ((unint64_t)(a2 - (void)a1) > 8) {
    return 1;
  }
  unint64_t v3 = *a1 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v4 = *(uint64_t **)(v3 + 24);
  if (*(uint64_t **)(v3 + 32) == v4)
  {
    BOOL v7 = &qword_1EBD069E0;
    uint64_t v8 = &qword_1EBD069E8;
  }
  else
  {
    uint64_t v5 = *v4;
    if (v5) {
      BOOL v6 = *(_DWORD *)(v5 + 8) == 0;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      uint64_t v5 = *(void *)(v5 + 72);
    }
    BOOL v7 = (uint64_t *)(v5 + 80);
    uint64_t v8 = (uint64_t *)(v5 + 88);
  }
  uint64_t v9 = *v7;
  uint64_t v10 = *v8;
  if (v9 == v10) {
    return 0;
  }
  uint64_t v11 = v9 + 16;
  do
  {
    unint64_t v12 = *(void *)(v11 - 16) & 0xFFFFFFFFFFFFFFF8;
    BOOL result = v12 == v3;
    BOOL v13 = v12 == v3 || v11 == v10;
    v11 += 16;
  }
  while (!v13);
  return result;
}

uint64_t **sub_1CD5D46D4(uint64_t **result, uint64_t a2)
{
  unint64_t v2 = result + 1;
  unint64_t v3 = *result;
  if (*result != (uint64_t *)(result + 1))
  {
    do
    {
      uint64_t v5 = (uint64_t *)v3[4];
      BOOL v14 = v5;
      BOOL v6 = (uint64_t *)v3[7];
      BOOL v7 = (uint64_t *)v3[8];
      while (v6 != v7)
      {
        uint64_t v8 = *v6++;
        long long v13 = *(_OWORD *)(v8 + 24);
        uint64_t v15 = &v13;
        uint64_t v9 = (uint64_t **)sub_1CD5D4C24(a2, (uint64_t)&v13, &v15);
        BOOL result = sub_1CD508D28(v9 + 6, (unint64_t)v5, &v14);
        result[5] = (uint64_t *)v8;
      }
      uint64_t v10 = (uint64_t *)v3[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (uint64_t *)v3[2];
          BOOL v12 = *v11 == (void)v3;
          unint64_t v3 = v11;
        }
        while (!v12);
      }
      unint64_t v3 = v11;
    }
    while (v11 != (uint64_t *)v2);
  }
  return result;
}

void *sub_1CD5D47AC(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    BOOL v6 = sub_1CD5D486C(a1, (uint64_t)a2, a2, v9);
    *BOOL v6 = *a2;
    v6[1] = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  BOOL v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      BOOL v6 = (void *)(*(void *)a1 + 16 * (v13 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

void *sub_1CD5D486C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1CD5D49E4(a1, 2 * v7);
    uint64_t v8 = *a3;
    int v10 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v11 = (37 * *a3) & v10;
    a4 = (void *)(*(void *)a1 + 16 * v11);
    uint64_t v12 = *a4;
    if (*a3 != *a4)
    {
      unsigned int v13 = 0;
      int v14 = 1;
      while (v12 != -1)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -2;
        }
        if (v15) {
          unsigned int v13 = a4;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        a4 = (void *)(*(void *)a1 + 16 * v11);
        uint64_t v12 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      uint64_t v8 = *a4;
      goto LABEL_4;
    }
    sub_1CD5D49E4(a1, v7);
    uint64_t v8 = *a3;
    int v17 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v18 = (37 * *a3) & v17;
    a4 = (void *)(*(void *)a1 + 16 * v18);
    uint64_t v19 = *a4;
    if (*a3 != *a4)
    {
      unsigned int v13 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v13) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          unsigned int v13 = a4;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a4 = (void *)(*(void *)a1 + 16 * v18);
        uint64_t v19 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v13) {
        a4 = v13;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD5D49E4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5D4AB0(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -1;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5D4AB0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    int v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *int v4 = -1;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  if (a2 != a3)
  {
    int v6 = 0;
    int v7 = v3 - 1;
    do
    {
      uint64_t v8 = *a2;
      if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unsigned int v9 = (37 * v8) & v7;
        uint64_t v10 = (void *)(*(void *)result + 16 * v9);
        uint64_t v11 = *v10;
        if (v8 != *v10)
        {
          unsigned int v13 = 0;
          int v14 = 1;
          while (v11 != -1)
          {
            if (v13) {
              BOOL v15 = 0;
            }
            else {
              BOOL v15 = v11 == -2;
            }
            if (v15) {
              unsigned int v13 = v10;
            }
            unsigned int v16 = v9 + v14++;
            unsigned int v9 = v16 & v7;
            uint64_t v10 = (void *)(*(void *)result + 16 * (v16 & v7));
            uint64_t v11 = *v10;
            if (v8 == *v10) {
              goto LABEL_8;
            }
          }
          if (v13) {
            uint64_t v10 = v13;
          }
        }
LABEL_8:
        uint64_t v12 = a2[1];
        void *v10 = v8;
        v10[1] = v12;
        *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = ++v6;
      }
      a2 += 2;
    }
    while (a2 != a3);
  }
  return result;
}

void sub_1CD5D4B7C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = 32 * a2;
    uint64_t v3 = (void *)(a1 + 16);
    do
    {
      if (*(v3 - 2) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *uint64_t v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

void sub_1CD5D4BD0(void *a1)
{
  if (a1)
  {
    sub_1CD5D4BD0(*a1);
    sub_1CD5D4BD0(a1[1]);
    sub_1CD40B1BC((void *)a1[7]);
    operator delete(a1);
  }
}

_OWORD *sub_1CD5D4C24(uint64_t a1, uint64_t a2, _OWORD **a3)
{
  uint64_t v5 = (void **)sub_1CD5D4CDC(a1, &v12, a2);
  int v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    int v6 = operator new(0x48uLL);
    void v6[2] = **a3;
    *((void *)v6 + sub_1CD521E44((uint64_t)this + 8) = 0;
    *((void *)v6 + 7) = 0;
    *((void *)v6 + 6) = (char *)v6 + 56;
    uint64_t v9 = v12;
    *(void *)int v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v9;
    *uint64_t v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = (uint64_t *)v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = (uint64_t *)*v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD5D4CDC(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = v4;
        uint64_t v9 = (uint64_t)(v4 + 4);
        if (!sub_1CC016A40(v7, a3, (uint64_t)(v4 + 4))) {
          break;
        }
        int v4 = (void *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_1CC016A40(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      int v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void *sub_1CD5D4D7C(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    int v6 = sub_1CD5D4E3C(a1, a2, v9);
    uint64_t v10 = *a2;
    void v6[2] = 0;
    _OWORD v6[3] = 0;
    *int v6 = v10;
    v6[1] = 0;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  int v6 = (void *)(*(void *)a1 + 32 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v11 = 0;
    int v12 = 1;
    while (v7 != -1)
    {
      if (v11) {
        BOOL v13 = 0;
      }
      else {
        BOOL v13 = v7 == -2;
      }
      if (v13) {
        uint64_t v11 = v6;
      }
      int v14 = v5 + v12++;
      uint64_t v5 = v14 & v4;
      int v6 = (void *)(*(void *)a1 + 32 * v5);
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v11) {
      uint64_t v9 = v11;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

void *sub_1CD5D4E3C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD5D4FB4(a1, 2 * v6);
    uint64_t v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v10 = (37 * *a2) & v9;
    a3 = (void *)(*(void *)a1 + 32 * v10);
    uint64_t v11 = *a3;
    if (*a2 != *a3)
    {
      int v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          int v12 = a3;
        }
        int v15 = v10 + v13++;
        uint64_t v10 = v15 & v9;
        a3 = (void *)(*(void *)a1 + 32 * v10);
        uint64_t v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      uint64_t v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD5D4FB4(a1, v6);
    uint64_t v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v17 = (37 * *a2) & v16;
    a3 = (void *)(*(void *)a1 + 32 * v17);
    uint64_t v18 = *a3;
    if (*a2 != *a3)
    {
      int v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          int v12 = a3;
        }
        int v21 = v17 + v19++;
        uint64_t v17 = v21 & v16;
        a3 = (void *)(*(void *)a1 + 32 * v17);
        uint64_t v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5D4FB4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5D5080(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -1;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5D5080(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    unsigned int v4 = *(void **)result;
    uint64_t v5 = 32 * v3;
    do
    {
      *unsigned int v4 = -1;
      v4 += 4;
      v5 -= 32;
    }
    while (v5);
  }
  if (a2 != a3)
  {
    int v6 = 0;
    unsigned int v7 = v3 - 1;
    do
    {
      unint64_t v8 = *a2;
      if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v9 = (37 * v8) & v7;
        uint64_t v10 = (unint64_t *)(*(void *)result + 32 * v9);
        unint64_t v11 = *v10;
        if (v8 != *v10)
        {
          int v12 = 0;
          int v13 = 1;
          while (v11 != -1)
          {
            if (v12) {
              BOOL v14 = 0;
            }
            else {
              BOOL v14 = v11 == -2;
            }
            if (v14) {
              int v12 = v10;
            }
            int v15 = v9 + v13++;
            uint64_t v9 = v15 & v7;
            uint64_t v10 = (unint64_t *)(*(void *)result + 32 * v9);
            unint64_t v11 = *v10;
            if (v8 == *v10) {
              goto LABEL_8;
            }
          }
          if (v12) {
            uint64_t v10 = v12;
          }
        }
LABEL_8:
        unint64_t *v10 = v8;
        v10[1] = 0;
        void v10[2] = 0;
        uint64_t v10[3] = 0;
        *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 1);
        uint64_t v10[3] = a2[3];
        ++v6;
        a2[1] = 0;
        a2[2] = 0;
        a2[3] = 0;
        *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = v6;
      }
      a2 += 4;
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t llvm::GEPOperator::getMaxPreservedAlignment(llvm::GEPOperator *this, const llvm::DataLayout *a2)
{
  unsigned int v4 = (const llvm::Value **)sub_1CD5D5300((uint64_t)this);
  int v24 = v4;
  uint64_t v25 = v5;
  int v6 = *((_DWORD *)this + 5);
  if ((v6 & 0x40000000) != 0)
  {
    unint64_t v8 = (char *)*((void *)this - 1);
    uint64_t v7 = v6 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v7 = v6 & 0x7FFFFFF;
    unint64_t v8 = (char *)this - 32 * v7;
  }
  uint64_t v9 = (const llvm::Value **)&v8[32 * v7];
  uint64_t v10 = 32;
  if (v9 != v4)
  {
    do
    {
      if (*((unsigned char *)*v4 + 16) == 16) {
        unint64_t v11 = *v4;
      }
      else {
        unint64_t v11 = 0;
      }
      TypeAtIndex = (llvm::Type *)(v25 & 0xFFFFFFFFFFFFFFF8);
      if ((v25 & 4) != 0 || !TypeAtIndex)
      {
        if (v11)
        {
          int v16 = (uint64_t *)((char *)v11 + 24);
          if (*((_DWORD *)v11 + 8) >= 0x41u) {
            int v16 = (uint64_t *)*v16;
          }
          uint64_t v17 = *v16;
        }
        else
        {
          uint64_t v17 = 1;
        }
        if ((v25 & 4) == 0 || !TypeAtIndex) {
          TypeAtIndex = (llvm::Type *)llvm::StructType::getTypeAtIndex((llvm::StructType *)(v25 & 0xFFFFFFFFFFFFFFF8), *v4);
        }
        unint64_t v18 = (unint64_t)(sub_1CB83544C((uint64_t)a2, (uint64_t)TypeAtIndex) + 7) >> 3;
        BOOL v20 = v19 == 1;
        char Alignment = llvm::DataLayout::getAlignment(a2, TypeAtIndex, 1);
        uint64_t v15 = (((1 << Alignment) + v18 - 1) & -(1 << Alignment)) * v17;
        if (v20) {
      }
        }
      else
      {
        StructLayout = llvm::DataLayout::getStructLayout(a2, (llvm::StructType *)(v25 & 0xFFFFFFFFFFFFFFF8));
        BOOL v14 = (unsigned int *)((char *)v11 + 24);
        if (*((_DWORD *)v11 + 8) >= 0x41u) {
          BOOL v14 = *(unsigned int **)v14;
        }
        uint64_t v15 = *((void *)StructLayout + *v14 + 2);
      }
      uint64_t v10 = 63 - __clz((v15 | (1 << v10)) & -(v15 | (1 << v10)));
      sub_1CB8460E4((uint64_t)&v24);
      unsigned int v4 = v24;
    }
    while (v24 != v9);
  }
  return v10;
}

uint64_t sub_1CD5D5300(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 & 0x40000000) != 0) {
    uint64_t v2 = *(void *)(a1 - 8);
  }
  else {
    uint64_t v2 = a1 - 32 * (v1 & 0x7FFFFFF);
  }
  return v2 + 32;
}

uint64_t sub_1CD5D5344(uint64_t a1, uint64_t *a2)
{
  uint64_t v18 = *a2;
  int v19 = 0;
  sub_1CD5D55BC(a1, &v18, &v19, (uint64_t)&v16);
  uint64_t v4 = v16;
  if (v17)
  {
    uint64_t v5 = (uint64_t *)(a1 + 24);
    uint64_t v6 = *a2;
    int v15 = 1;
    uint64_t v13 = v6;
    uint64_t v14 = 0;
    unint64_t v7 = *(void *)(a1 + 32);
    if (v7 >= *(void *)(a1 + 40))
    {
      unint64_t v8 = sub_1CC612830((char **)(a1 + 24), (uint64_t)&v13);
      unsigned int v12 = v15;
      *(void *)(a1 + 32) = v8;
      if (v12 >= 0x41 && v14)
      {
        MEMORY[0x1D25D9CB0](v14, 0x1000C8000313F17);
        unint64_t v8 = *(char **)(a1 + 32);
      }
    }
    else
    {
      *(_DWORD *)(v7 + 16) = 1;
      *(void *)unint64_t v7 = v6;
      *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0;
      unint64_t v8 = (char *)(v7 + 24);
      *(void *)(a1 + 32) = v7 + 24;
    }
    uint64_t v9 = *v5;
    unsigned int v10 = -1431655765 * ((unint64_t)&v8[-*v5] >> 3) - 1;
    *(_DWORD *)(v4 + sub_1CD521E44((uint64_t)this + 8) = v10;
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(v16 + 8);
    uint64_t v9 = *(void *)(a1 + 24);
  }
  return v9 + 24 * v10 + 8;
}

uint64_t *sub_1CD5D5450(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v7 = *a2;
  int v8 = 0;
  BOOL result = sub_1CC6125EC(a1, &v7, &v8, (uint64_t)&v9);
  if (v10)
  {
    *(_DWORD *)(v9 + sub_1CD521E44((uint64_t)this + 8) = -1431655765 * ((*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
    return (uint64_t *)sub_1CD5D54E4(a1 + 24, a2, a3);
  }
  return result;
}

char *sub_1CD5D54E4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4 >= *(void *)(a1 + 16))
  {
    BOOL result = sub_1CC6126DC((char **)a1, a2, (uint64_t *)a3);
  }
  else
  {
    *(void *)unint64_t v4 = *a2;
    *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 8);
    *(void *)(v4 + sub_1CD521E44((uint64_t)this + 8) = *(void *)a3;
    *(_DWORD *)(a3 + sub_1CD521E44((uint64_t)this + 8) = 0;
    BOOL result = (char *)(v4 + 24);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  return result;
}

uint64_t sub_1CD5D5540(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 24;
      *(void *)(a1 + 16) = v2 - 24;
      if (*(_DWORD *)(v2 - 8) >= 0x41u)
      {
        uint64_t v5 = *(void *)(v2 - 16);
        if (v5)
        {
          MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
          uint64_t v4 = *(void *)(a1 + 16);
        }
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CD5D55BC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v12 = 0;
  uint64_t result = sub_1CBFFD518((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBFFD5B4(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (uint64_t *)result;
    *(void *)uint64_t result = *a2;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

BOOL llvm::OptBisect::shouldRunPass(llvm *a1, uint64_t a2, const void *a3, size_t a4)
{
  int v8 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);

  return llvm::OptBisect::checkPass(a1, v8, v7, a3, a4);
}

BOOL llvm::OptBisect::checkPass(llvm *a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  int v9 = *((_DWORD *)a1 + 2);
  uint64_t v10 = *((int *)a1 + 3);
  unint64_t v11 = v10 + 1;
  *((_DWORD *)a1 + 3) = v10 + 1;
  BOOL v13 = v9 == -1 || (int)v10 < v9;
  if (v13) {
    size_t v14 = 0;
  }
  else {
    size_t v14 = 4;
  }
  int v15 = (llvm::raw_ostream *)llvm::errs(a1);
  uint64_t v16 = sub_1CB8E509C(v15, "BISECT: ");
  char v17 = (_DWORD *)*((void *)v16 + 4);
  if (v14 <= *((void *)v16 + 3) - (void)v17)
  {
    if (!v13)
    {
      *char v17 = 542396238;
      *((void *)v16 + 4) += 4;
    }
  }
  else
  {
    if (v13) {
      uint64_t v18 = (const char *)&unk_1CFBCE2A9;
    }
    else {
      uint64_t v18 = "NOT ";
    }
    uint64_t v16 = llvm::raw_ostream::write(v16, v18, v14);
  }
  int v19 = sub_1CB8E509C(v16, "running pass ");
  BOOL v20 = sub_1CB8E509C(v19, "(");
  int v21 = llvm::raw_ostream::operator<<(v20, v11);
  unsigned int v22 = sub_1CB8E509C(v21, ") ");
  int v23 = (void *)*((void *)v22 + 4);
  if (a3 <= *((void *)v22 + 3) - (void)v23)
  {
    if (a3)
    {
      memcpy(v23, a2, a3);
      *((void *)v22 + 4) += a3;
    }
  }
  else
  {
    llvm::raw_ostream::write(v22, (const char *)a2, a3);
  }
  int v24 = sub_1CB8E509C(v22, " on ");
  uint64_t v25 = (void *)*((void *)v24 + 4);
  if (a5 <= *((void *)v24 + 3) - (void)v25)
  {
    if (a5)
    {
      memcpy(v25, a4, a5);
      *((void *)v24 + 4) += a5;
    }
  }
  else
  {
    llvm::raw_ostream::write(v24, (const char *)a4, a5);
  }
  sub_1CB8E509C(v24, "\n");
  return v13;
}

void sub_1CD5D587C()
{
}

void sub_1CD5D5890(_WORD *a1, int **a2, _WORD *a3, uint64_t a4, __n128 *a5)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD8998, 0, 0);
  dword_1EBCD8A18 = 0;
  qword_1EBCD8A20 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCD8A28 = 0;
  qword_1EBCD8998 = (uint64_t)&unk_1F2643F68;
  qword_1EBCD8A30 = (uint64_t)&unk_1F2643D20;
  qword_1EBCD8A38[0] = (uint64_t)&unk_1F25F7480;
  qword_1EBCD8A50 = (uint64_t)qword_1EBCD8A38;
  sub_1CD5D5998(a1, a2, a3, a4, a5);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8998);
}

__n128 sub_1CD5D5998(_WORD *a1, int **a2, _WORD *a3, uint64_t a4, __n128 *a5)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD8998, "opt-bisect-limit", 0x10uLL);
  word_1EBCD89A2 = word_1EBCD89A2 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v10 = *a2;
  dword_1EBCD8A18 = **a2;
  byte_1EBCD8A2C = 1;
  dword_1EBCD8A28 = *v10;
  word_1EBCD89A2 = word_1EBCD89A2 & 0xFFF8 | *a3 & 7;
  sub_1CC612B08(a4);
  __n128 result = *a5;
  xmmword_1EBCD89B8 = (__int128)*a5;
  return result;
}

uint64_t sub_1CD5D5A3C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1CD5D5AA0(void *a1)
{
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }

  operator delete(a1);
}

uint64_t sub_1CD5D5B38(uint64_t a1, int *a2)
{
  int v5 = *a2;
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2)
  {
    sub_1CB920400();
    llvm::Pass::~Pass(v4);
  }
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)v2 + 48))(v2, &v5);
}

void llvm::ModulePass::createPrinterPass()
{
}

llvm::raw_ostream *llvm::Pass::dumpPassStructure(llvm::Pass *this, int a2)
{
  uint64_t v4 = llvm::dbgs(this);
  int v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  size_t v7 = (const void *)(*(uint64_t (**)(llvm::Pass *))(*(void *)this + 16))(this);
  size_t v8 = v6;
  int v9 = (void *)*((void *)v5 + 4);
  if (v6 <= *((void *)v5 + 3) - (void)v9)
  {
    if (v6)
    {
      memcpy(v9, v7, v6);
      *((void *)v5 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v5, (const char *)v7, v6);
  }

  return sub_1CB8E509C(v5, "\n");
}

llvm::raw_ostream *sub_1CD5D5C70(llvm::raw_ostream *this, const void *a2, size_t a3)
{
  uint64_t v6 = *((void *)this + 3);
  int v5 = (void *)*((void *)this + 4);
  if (a3 <= v6 - (uint64_t)v5)
  {
    if (a3)
    {
      memcpy(v5, a2, a3);
      *((void *)this + 4) += a3;
    }
  }
  else
  {
    llvm::raw_ostream::write(this, (const char *)a2, a3);
  }
  return this;
}

uint64_t llvm::Pass::getPotentialPassManagerType(llvm::Pass *this)
{
  return 0;
}

llvm::raw_ostream *llvm::Pass::print(llvm::Pass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v4 = sub_1CB8E509C(a2, "Pass::print not implemented for pass: '");
  uint64_t v6 = (const void *)(*(uint64_t (**)(llvm::Pass *))(*(void *)this + 16))(this);
  size_t v7 = v5;
  size_t v8 = (void *)*((void *)v4 + 4);
  if (v5 <= *((void *)v4 + 3) - (void)v8)
  {
    if (v5)
    {
      memcpy(v8, v6, v5);
      *((void *)v4 + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(v4, (const char *)v6, v5);
  }

  return sub_1CB8E509C(v4, "'!\n");
}

uint64_t llvm::Pass::dump(llvm::Pass *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = *(uint64_t (**)(llvm::Pass *, llvm *, void))(*(void *)this + 40);

  return v3(this, v2, 0);
}

void llvm::FunctionPass::createPrinterPass()
{
}

uint64_t llvm::Pass::lookupPassInfo(llvm::Pass *this, const void *a2)
{
  atomic_ullong PassRegistry = (std::__shared_mutex_base *)llvm::PassRegistry::getPassRegistry(this);

  return llvm::PassRegistry::getPassInfo(PassRegistry, this);
}

__n128 llvm::PassInstrumentationCallbacks::addClassToPassName(uint64_t a1, unsigned __int8 *a2, size_t a3, const std::string::value_type *a4, std::string::size_type a5)
{
  uint64_t v9 = a1 + 1296;
  uint64_t v10 = sub_1CD5D600C(a1 + 1296, a2, a3);
  if (*((char *)*v10 + 31) < 0) {
    size_t v12 = (*v10)[2];
  }
  else {
    size_t v12 = *((unsigned __int8 *)*v10 + 31);
  }
  if (!v12)
  {
    if (a4) {
      std::string::__init(&v15, a4, a5);
    }
    else {
      memset(&v15, 0, sizeof(v15));
    }
    BOOL v13 = sub_1CD5D600C(v9, a2, a3);
    uint64_t v14 = (uint64_t)(*v13 + 1);
    if (*((char *)*v13 + 31) < 0) {
      operator delete(*(void **)v14);
    }
    __n128 result = *(__n128 *)&v15.__r_.__value_.__l.__data_;
    *(void *)(v14 + 16) = *((void *)&v15.__r_.__value_.__l + 2);
    *(__n128 *)uint64_t v14 = result;
  }
  return result;
}

uint64_t llvm::PassInstrumentationCallbacks::getPassNameForClassName(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v3 = sub_1CD5D600C(a1 + 1296, a2, a3);
  if (*((char *)*v3 + 31) >= 0) {
    return (uint64_t)(*v3 + 1);
  }
  else {
    return (*v3)[1];
  }
}

uint64_t llvm::isSpecialPass(char *__s, size_t __n, uint64_t *a3)
{
  size_t v4 = __n;
  if (__n)
  {
    uint64_t v6 = memchr(__s, 60, __n);
    if (v6)
    {
      if (v4 >= v6 - __s) {
        size_t v7 = v6 - __s;
      }
      else {
        size_t v7 = v4;
      }
      if (v6 - __s != -1) {
        size_t v4 = v7;
      }
    }
  }
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  if (v9 == v8) {
    return 0;
  }
  uint64_t v10 = &__s[v4];
  while (1)
  {
    size_t v11 = *(void *)(v9 + 8);
    if (v4 >= v11 && (!v11 || !memcmp(&v10[-v11], *(const void **)v9, v11))) {
      break;
    }
    v9 += 16;
    if (v9 == v8) {
      return 0;
    }
  }
  return 1;
}

size_t **sub_1CD5D600C(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (size_t **)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      uint64_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  buffer = llvm::allocate_buffer(a3 + 33, (std::align_val_t)8uLL);
  size_t v11 = buffer;
  size_t v12 = (char *)(buffer + 4);
  if (a3) {
    memcpy(buffer + 4, a2, a3);
  }
  v12[a3] = 0;
  *size_t v11 = a3;
  v11[1] = 0;
  void v11[2] = 0;
  void v11[3] = 0;
  *uint64_t i = v11;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

llvm::raw_ostream *llvm::PassManager<llvm::Module,llvm::AnalysisManager<llvm::Module>>::printPipeline(llvm::raw_ostream *result, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *((void *)result + 1) - *(void *)result;
  if ((v4 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0;
    unint64_t v10 = (v4 >> 3);
    do
    {
      __n128 result = (llvm::raw_ostream *)(*(uint64_t (**)(void, llvm::raw_ostream *, uint64_t, uint64_t))(**(void **)(*(void *)v8 + 8 * v9) + 24))(*(void *)(*(void *)v8 + 8 * v9), a2, a3, a4);
      if (++v9 < v10) {
        __n128 result = sub_1CB8E509C(a2, ",");
      }
    }
    while (v10 != v9);
  }
  return result;
}

llvm::raw_ostream *llvm::PassManager<llvm::Function,llvm::AnalysisManager<llvm::Function>>::printPipeline(llvm::raw_ostream *result, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *((void *)result + 1) - *(void *)result;
  if ((v4 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0;
    unint64_t v10 = (v4 >> 3);
    do
    {
      __n128 result = (llvm::raw_ostream *)(*(uint64_t (**)(void, llvm::raw_ostream *, uint64_t, uint64_t))(**(void **)(*(void *)v8 + 8 * v9) + 24))(*(void *)(*(void *)v8 + 8 * v9), a2, a3, a4);
      if (++v9 < v10) {
        __n128 result = sub_1CB8E509C(a2, ",");
      }
    }
    while (v10 != v9);
  }
  return result;
}

int32x2_t sub_1CD5D6284(uint64_t a1, void *a2)
{
  size_t v5 = 0;
  if (sub_1CBFA4D20((uint64_t *)a1, a2, &v5))
  {
    unint64_t v4 = v5;
    sub_1CBFA4F3C(v5 + 1);
    *unint64_t v4 = -8192;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = result;
  }
  return result;
}

llvm::raw_ostream *llvm::ModuleToFunctionPassAdaptor::printPipeline(unsigned char *a1, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  sub_1CB8E509C(a2, "function");
  if (a1[8]) {
    sub_1CB8E509C(a2, "<eager-inv>");
  }
  sub_1CB8E509C(a2, "(");
  (*(void (**)(void, llvm::raw_ostream *, uint64_t, uint64_t))(**(void **)a1 + 24))(*(void *)a1, a2, a3, a4);

  return sub_1CB8E509C(a2, ")");
}

void sub_1CD5D63A0(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    size_t v5 = (uint64_t *)(*(void *)a1 + 8);
    do
    {
      if ((*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CBFA4F3C(v5);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
  }
  if (v3)
  {
    int v6 = 1 << (33 - __clz(v3 - 1));
    if (v6 <= 64) {
      unsigned int v7 = 64;
    }
    else {
      unsigned int v7 = v6;
    }
    uint64_t v8 = *(void **)a1;
    if (v7 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v9 = 32 * v7;
      do
      {
        *uint64_t v8 = -4096;
        v8 += 4;
        v9 -= 32;
      }
      while (v9);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v7 = 0;
    uint64_t v8 = *(void **)a1;
  }
  MEMORY[0x1D25D9CD0](v8, 8);

  sub_1CBC04C8C(a1, v7);
}

uint64_t llvm::PassRegistry::getPassInfo(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)a1);
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 200), a2, a3);
  if (Key == -1 || Key == (unint64_t)*(unsigned int *)(a1 + 208)) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 200) + 8 * Key) + 8);
  }
  std::__shared_mutex_base::unlock_shared((std::__shared_mutex_base *)a1);
  return v7;
}

void sub_1CD5D6518()
{
}

llvm::PassRegistry *sub_1CD5D65A0(llvm::PassRegistry *result)
{
  if (result)
  {
    llvm::PassRegistry::~PassRegistry(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

uint64_t llvm::TimePassesHandler::getPassTimer(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  v12[0] = a2;
  v12[1] = a3;
  int v3 = *(unsigned __int8 *)(a1 + 217);
  uint64_t v4 = *sub_1CD5D7CB0(a1 + 96, a2, a3);
  if (v3)
  {
    int v11 = *((_DWORD *)v4 + 4) + 1;
    v6[0] = "{0} #{1}";
    v6[1] = 8;
    void v6[2] = v9;
    _OWORD v6[3] = 2;
    v7[0] = &unk_1F2617F90;
    v7[1] = v12;
    v8[0] = &unk_1F2617FC0;
    v8[1] = &v11;
    v9[0] = v7;
    v9[1] = v8;
    sub_1CD465B2C((uint64_t)v6, &__p);
    operator new();
  }
  if (!*((_DWORD *)v4 + 4)) {
    operator new();
  }
  return *(void *)v4[1];
}

void llvm::TimePassesHandler::print(llvm::TimePassesHandler *this)
{
  if (*((unsigned char *)this + 216))
  {
    uint64_t v1 = (llvm::raw_ostream *)*((void *)this + 26);
    if (!v1) {
      llvm::CreateInfoOutputFile(this);
    }
    llvm::TimerGroup::print(this, v1, 1);
  }
}

llvm *llvm::TimePassesHandler::dump(uint64_t **this)
{
  uint64_t v2 = llvm::dbgs((llvm *)this);
  int v3 = sub_1CB8E509C(v2, "Dumping timers for ");
  int v52 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::TimePassesHandler]";
  unint64_t v53 = 73;
  unint64_t v4 = llvm::StringRef::find((uint64_t *)&v52, "DesiredTypeName = ", 0x12uLL, 0);
  if (v53 >= v4) {
    unint64_t v5 = v4;
  }
  else {
    unint64_t v5 = v53;
  }
  int v6 = &v52[v5];
  unint64_t v7 = v53 - v5;
  if (v53 - v5 >= 0x12) {
    uint64_t v8 = 18;
  }
  else {
    uint64_t v8 = v53 - v5;
  }
  uint64_t v9 = &v6[v8];
  unint64_t v10 = v7 - v8;
  if (v10 >= v10 - 1) {
    size_t v11 = v10 - 1;
  }
  else {
    size_t v11 = v10;
  }
  size_t v12 = (void *)*((void *)v3 + 4);
  if (v11 <= *((void *)v3 + 3) - (void)v12)
  {
    if (v11)
    {
      memcpy(v12, v9, v11);
      *((void *)v3 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, v9, v11);
  }
  BOOL v13 = sub_1CB8E509C(v3, ":\n\tRunning:\n");
  uint64_t v14 = *((unsigned int *)this + 26);
  std::string v15 = this[12];
  if (v14)
  {
    while (!*v15 || *v15 == -8)
      ++v15;
  }
  uint64_t v50 = (uint64_t)&this[12][v14];
  if (v15 != (uint64_t *)v50)
  {
    uint64_t v17 = *v15;
    do
    {
      unint64_t v18 = *(unsigned int *)(v17 + 16);
      if (v18)
      {
        unint64_t v19 = 0;
        size_t v20 = *(void *)v17;
        do
        {
          unint64_t v21 = *(void *)(*(void *)(v17 + 8) + 8 * v19);
          if (v21 && *(unsigned char *)(v21 + 128))
          {
            unsigned int v22 = llvm::dbgs(v13);
            int v23 = sub_1CB8E509C(v22, "\tTimer ");
            int v24 = llvm::raw_ostream::operator<<(v23, v21);
            uint64_t v25 = sub_1CB8E509C(v24, " for pass ");
            unsigned int v26 = (void *)*((void *)v25 + 4);
            if (v20 <= *((void *)v25 + 3) - (void)v26)
            {
              if (v20)
              {
                memcpy(v26, (const void *)(v17 + 56), v20);
                *((void *)v25 + 4) += v20;
              }
            }
            else
            {
              llvm::raw_ostream::write(v25, (const char *)(v17 + 56), v20);
            }
            long long v27 = sub_1CB8E509C(v25, "(");
            unint64_t v28 = llvm::raw_ostream::operator<<(v27, v19);
            BOOL v13 = sub_1CB8E509C(v28, ")\n");
            unint64_t v18 = *(unsigned int *)(v17 + 16);
          }
          ++v19;
        }
        while (v19 < v18);
      }
      do
      {
        uint64_t v29 = v15[1];
        ++v15;
        uint64_t v17 = v29;
        if (v29) {
          BOOL v30 = v17 == -8;
        }
        else {
          BOOL v30 = 1;
        }
      }
      while (v30);
    }
    while (v15 != (uint64_t *)v50);
  }
  size_t v31 = llvm::dbgs(v13);
  int32x2_t result = sub_1CB8E509C(v31, "\tTriggered:\n");
  uint64_t v33 = *((unsigned int *)this + 26);
  if (v33)
  {
    for (uint64_t i = this[12]; !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = this[12];
  }
  uint64_t v51 = (uint64_t)&this[12][v33];
  if (i != (uint64_t *)v51)
  {
    uint64_t v36 = *i;
    do
    {
      unint64_t v37 = *(unsigned int *)(v36 + 16);
      if (v37)
      {
        unint64_t v38 = 0;
        size_t v39 = *(void *)v36;
        do
        {
          unint64_t v40 = *(void *)(*(void *)(v36 + 8) + 8 * v38);
          if (v40 && *(unsigned char *)(v40 + 129) && !*(unsigned char *)(v40 + 128))
          {
            unint64_t v41 = llvm::dbgs(result);
            size_t v42 = sub_1CB8E509C(v41, "\tTimer ");
            size_t v43 = llvm::raw_ostream::operator<<(v42, v40);
            unint64_t v44 = sub_1CB8E509C(v43, " for pass ");
            long long v45 = (void *)*((void *)v44 + 4);
            if (v39 <= *((void *)v44 + 3) - (void)v45)
            {
              if (v39)
              {
                memcpy(v45, (const void *)(v36 + 56), v39);
                *((void *)v44 + 4) += v39;
              }
            }
            else
            {
              llvm::raw_ostream::write(v44, (const char *)(v36 + 56), v39);
            }
            int v46 = sub_1CB8E509C(v44, "(");
            unint64_t v47 = llvm::raw_ostream::operator<<(v46, v38);
            int32x2_t result = sub_1CB8E509C(v47, ")\n");
            unint64_t v37 = *(unsigned int *)(v36 + 16);
          }
          ++v38;
        }
        while (v38 < v37);
      }
      do
      {
        uint64_t v48 = i[1];
        ++i;
        uint64_t v36 = v48;
        if (v48) {
          BOOL v49 = v36 == -8;
        }
        else {
          BOOL v49 = 1;
        }
      }
      while (v49);
    }
    while (i != (uint64_t *)v51);
  }
  return result;
}

double llvm::TimePassesHandler::startTimer(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  PassTimer = (llvm::Timer *)llvm::TimePassesHandler::getPassTimer(a1, a2, a3);
  unsigned int v6 = *(_DWORD *)(a1 + 136);
  if (v6 >= *(_DWORD *)(a1 + 140)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 128) + 8 * v6) = PassTimer;
  ++*(_DWORD *)(a1 + 136);
  if (!*((unsigned char *)PassTimer + 128))
  {
    return llvm::Timer::startTimer(PassTimer);
  }
  return result;
}

double llvm::TimePassesHandler::runBeforePass(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  v9[0] = xmmword_1E6849980;
  v9[1] = *(_OWORD *)&off_1E6849990;
  void v9[2] = xmmword_1E68499A0;
  sub_1CC61968C(__p, v9, 3uLL);
  char isSpecialPass = llvm::isSpecialPass(a2, a3, (uint64_t *)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if ((isSpecialPass & 1) == 0) {
    return llvm::TimePassesHandler::startTimer(a1, (unsigned __int8 *)a2, a3);
  }
  return result;
}

void llvm::TimePassesHandler::runAfterPass(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  v10[0] = xmmword_1E6849980;
  v10[1] = *(_OWORD *)&off_1E6849990;
  void v10[2] = xmmword_1E68499A0;
  sub_1CC61968C(__p, v10, 3uLL);
  char isSpecialPass = llvm::isSpecialPass(a2, a3, (uint64_t *)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if ((isSpecialPass & 1) == 0)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 136);
    uint64_t v8 = *(llvm::Timer **)(*(void *)(a1 + 128) + 8 * v7 - 8);
    *(_DWORD *)(a1 + 136) = v7 - 1;
    if (*((unsigned char *)v8 + 128)) {
      llvm::Timer::stopTimer(v8);
    }
  }
}

uint64_t llvm::TimePassesHandler::registerCallbacks(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 216))
  {
    uint64_t v2 = *(unsigned int *)(a2 + 296);
    if (v2 >= *(_DWORD *)(a2 + 300)) {
      llvm::SmallVectorBase<unsigned int>::mallocForGrow();
    }
    int v3 = (void *)(*(void *)(a2 + 288) + 32 * v2);
    *int v3 = result;
    v3[3] = (char *)off_1EC7DFA28 + 2;
    *(_DWORD *)(a2 + 296) = v2 + 1;
    uint64_t v4 = *(unsigned int *)(a2 + 440);
    if (v4 >= *(_DWORD *)(a2 + 444)) {
      llvm::SmallVectorBase<unsigned int>::mallocForGrow();
    }
    unint64_t v5 = (void *)(*(void *)(a2 + 432) + 32 * v4);
    void *v5 = result;
    void v5[3] = (char *)off_1EC7DFA30 + 2;
    *(_DWORD *)(a2 + 44llvm::MDNode::dumpTree(this, 0) = v4 + 1;
    uint64_t v6 = *(unsigned int *)(a2 + 584);
    if (v6 >= *(_DWORD *)(a2 + 588)) {
      llvm::SmallVectorBase<unsigned int>::mallocForGrow();
    }
    uint64_t v7 = (void *)(*(void *)(a2 + 576) + 32 * v6);
    *uint64_t v7 = result;
    void v7[3] = (char *)off_1EC7DFA38 + 2;
    *(_DWORD *)(a2 + 584) = v6 + 1;
    uint64_t v8 = *(unsigned int *)(a2 + 728);
    if (v8 >= *(_DWORD *)(a2 + 732)) {
      llvm::SmallVectorBase<unsigned int>::mallocForGrow();
    }
    uint64_t v9 = (void *)(*(void *)(a2 + 720) + 32 * v8);
    *uint64_t v9 = result;
    _OWORD v9[3] = (char *)off_1EC7DFA40 + 2;
    *(_DWORD *)(a2 + 72sub_1CD521E44((uint64_t)this + 8) = v8 + 1;
    uint64_t v10 = *(unsigned int *)(a2 + 872);
    if (v10 >= *(_DWORD *)(a2 + 876)) {
      llvm::SmallVectorBase<unsigned int>::mallocForGrow();
    }
    uint64_t v11 = (void *)(*(void *)(a2 + 864) + 32 * v10);
    *uint64_t v11 = result;
    void v11[3] = (char *)off_1EC7DFA48 + 2;
    *(_DWORD *)(a2 + 872) = v10 + 1;
  }
  return result;
}

unsigned int *sub_1CD5D7368(unsigned int *result)
{
  uint64_t v1 = result;
  unsigned int v2 = result[2];
  if (!v2 && !result[3]) {
    return result;
  }
  uint64_t v3 = result[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)v1 + 1) = 0;
      return result;
    }
    uint64_t v4 = 16 * v3;
    unint64_t v5 = (unsigned int **)(*(void *)result + 8);
    while (1)
    {
      uint64_t v6 = (uint64_t)*(v5 - 1);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 2;
      v4 -= 16;
      if (!v4) {
        goto LABEL_12;
      }
    }
    double result = *v5;
    void *v5 = 0;
    if (result)
    {
      llvm::Timer::~Timer((llvm::Timer *)result);
      double result = (unsigned int *)MEMORY[0x1D25D9CE0]();
    }
LABEL_10:
    *(v5 - 1) = (unsigned int *)-4096;
    goto LABEL_11;
  }

  return sub_1CD5D7444(result);
}

unsigned int *sub_1CD5D7444(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  double result = sub_1CD5D7500(a1);
  if (v2)
  {
    int v4 = 1 << (33 - __clz(v2 - 1));
    if (v4 <= 64) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = v4;
    }
    if (v5 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v6 = 16 * v5;
      uint64_t v7 = *(void **)a1;
      do
      {
        *uint64_t v7 = -4096;
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
      return result;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return result;
    }
    unsigned int v5 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  return sub_1CB837D60(a1, v5);
}

unsigned int *sub_1CD5D7500(unsigned int *result)
{
  uint64_t v1 = result[4];
  if (v1)
  {
    uint64_t v2 = 16 * v1;
    uint64_t v3 = (unsigned int **)(*(void *)result + 8);
    do
    {
      if (((unint64_t)*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        double result = *v3;
        *uint64_t v3 = 0;
        if (result)
        {
          llvm::Timer::~Timer((llvm::Timer *)result);
          double result = (unsigned int *)MEMORY[0x1D25D9CE0]();
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
  return result;
}

void sub_1CD5D7578()
{
}

std::recursive_mutex *sub_1CD5D75BC(std::recursive_mutex *result)
{
  if (result)
  {
    std::recursive_mutex::~recursive_mutex(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void *sub_1CD5D75FC(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD5D7668(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD5D7668(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5D771C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5D771C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5D77E8(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5D77E8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      size_t v12 = 0;
      sub_1CD40EA84(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v10 = v12;
      *size_t v12 = *a2;
      uint64_t v11 = a2[1];
      a2[1] = 0;
      v10[1] = v11;
      ++*(_DWORD *)(v5 + 8);
      double result = a2[1];
      a2[1] = 0;
      if (result)
      {
        llvm::Timer::~Timer((llvm::Timer *)result);
        double result = MEMORY[0x1D25D9CE0]();
      }
    }
    a2 += 2;
  }
  return result;
}

void sub_1CD5D78CC(unsigned char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD8AA0, 0, 0);
  byte_1EBCD8B31 = 0;
  qword_1EBCD8B20 = 0;
  unk_1EBCD8B28 = &unk_1F25EDE58;
  qword_1EBCD8AA0 = (uint64_t)&unk_1F2605290;
  qword_1EBCD8B38 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD8B40 = (uint64_t)&unk_1F26052F8;
  qword_1EBCD8B58 = (uint64_t)&qword_1EBCD8B40;
  sub_1CD5D79BC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8AA0);
}

__n128 sub_1CD5D79BC(unsigned char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD8AA0, "time-passes", 0xBuLL);
  sub_1CC08D588((llvm *)&qword_1EBCD8B20, &qword_1EBCD8AA0, *a1);
  word_1EBCD8AAA = (32 * (*a2 & 3)) | word_1EBCD8AAA & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCD8AC0 = (__int128)*a3;
  return result;
}

void sub_1CD5D7A38(unsigned char **a1, _WORD *a2, long long *a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD8B60, 0, 0);
  byte_1EBCD8BF1 = 0;
  qword_1EBCD8BE0 = 0;
  unk_1EBCD8BE8 = &unk_1F25EDE58;
  qword_1EBCD8B60 = (uint64_t)&unk_1F2605290;
  qword_1EBCD8BF8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD8C00[0] = (uint64_t)&unk_1F26052F8;
  qword_1EBCD8C18 = (uint64_t)qword_1EBCD8C00;
  sub_1CD5D7B38(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8B60);
}

uint64_t sub_1CD5D7B38(unsigned char **a1, _WORD *a2, long long *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD8B60, "time-passes-per-run", 0x13uLL);
  sub_1CC08D588((llvm *)&qword_1EBCD8BE0, &qword_1EBCD8B60, *a1);
  word_1EBCD8B6A = (32 * (*a2 & 3)) | word_1EBCD8B6A & 0xFF9F;
  xmmword_1EBCD8B80 = *a3;

  return sub_1CC619284(a4);
}

void sub_1CD5D7BD4()
{
}

llvm::raw_ostream *sub_1CD5D7BE8(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return sub_1CD5D7BF0(*(void *)(a1 + 8), a2, a3, a4);
}

llvm::raw_ostream *sub_1CD5D7BF0(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a4)
  {
    unint64_t v11 = 0;
    int AsUnsignedInteger = llvm::getAsUnsignedInteger(a3, a4, 0xAu, &v11);
    unint64_t v7 = v11;
    if (AsUnsignedInteger) {
      unint64_t v7 = -1;
    }
  }
  else
  {
    unint64_t v7 = -1;
  }
  uint64_t v8 = *(const char **)a1;
  if (*(void *)(a1 + 8) >= v7) {
    size_t v9 = v7;
  }
  else {
    size_t v9 = *(void *)(a1 + 8);
  }
  __n128 result = (llvm::raw_ostream *)*((void *)a2 + 4);
  if (v9 > *((void *)a2 + 3) - (void)result) {
    return llvm::raw_ostream::write(a2, v8, v9);
  }
  if (v9)
  {
    __n128 result = (llvm::raw_ostream *)memcpy(result, v8, v9);
    *((void *)a2 + 4) += v9;
  }
  return result;
}

void sub_1CD5D7C94()
{
}

llvm::raw_ostream *sub_1CD5D7CA8(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return sub_1CD4C9EB8(*(unsigned int **)(a1 + 8), a2, a3, a4);
}

size_t **sub_1CD5D7CB0(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (size_t **)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      size_t v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  unint64_t v11 = operator new(a3 + 57, (std::align_val_t)8uLL);
  size_t v12 = v11;
  BOOL v13 = (char *)(v11 + 7);
  if (a3) {
    memcpy(v11 + 7, a2, a3);
  }
  v13[a3] = 0;
  *size_t v12 = a3;
  v12[1] = (size_t)(v12 + 3);
  void v12[2] = 0x400000000;
  *uint64_t i = v12;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

void sub_1CD5D7DB0()
{
}

unsigned int *sub_1CD5D7E3C(unsigned int *result, void *a2)
{
  uint64_t v2 = result[2];
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)result;
    uint64_t v4 = 8 * v2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    uint64_t v7 = *(void *)result - 8;
    do
    {
      __n128 result = *(unsigned int **)(v7 + v4);
      *(void *)(v7 + v4) = 0;
      if (result)
      {
        llvm::Timer::~Timer((llvm::Timer *)result);
        __n128 result = (unsigned int *)MEMORY[0x1D25D9CE0]();
      }
      v4 -= 8;
    }
    while (v4);
  }
  return result;
}

BOOL llvm::shouldPrintBeforeSomePass(llvm *this)
{
  if (byte_1EBD06C60) {
    BOOL v1 = 0;
  }
  else {
    BOOL v1 = qword_1EBD06AB0 == unk_1EBD06AB8;
  }
  return !v1;
}

BOOL llvm::shouldPrintAfterSomePass(llvm *this)
{
  if (byte_1EBD06D20) {
    BOOL v1 = 0;
  }
  else {
    BOOL v1 = qword_1EBD06B88 == unk_1EBD06B90;
  }
  return !v1;
}

uint64_t llvm::shouldPrintBeforeAll(llvm *this)
{
  return byte_1EBD06C60;
}

uint64_t llvm::shouldPrintAfterAll(llvm *this)
{
  return byte_1EBD06D20;
}

void *llvm::printBeforePasses@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return sub_1CB906CCC(a1, qword_1EBD06AB0, qword_1EBD06AB8, 0xAAAAAAAAAAAAAAABLL * ((qword_1EBD06AB8 - qword_1EBD06AB0) >> 3));
}

void *llvm::printAfterPasses@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return sub_1CB906CCC(a1, qword_1EBD06B88, qword_1EBD06B90, 0xAAAAAAAAAAAAAAABLL * ((qword_1EBD06B90 - qword_1EBD06B88) >> 3));
}

uint64_t llvm::forcePrintModuleIR(llvm *this)
{
  return byte_1EBD06DE0;
}

uint64_t llvm::isFunctionInPrintList(const std::string::value_type *a1, std::string::size_type a2)
{
  uint64_t v3 = a1;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCD8C20, memory_order_acquire) & 1) == 0)
  {
    std::string::size_type v6 = a2;
    int v8 = __cxa_guard_acquire(&qword_1EBCD8C20);
    uint64_t v3 = a1;
    a2 = v6;
    if (v8)
    {
      uint64_t v9 = qword_1EBCD8CD0;
      uint64_t v10 = unk_1EBCD8CD8;
      xmmword_1EBCD8C28 = 0u;
      *(_OWORD *)algn_1EBCD8C38 = 0u;
      for (dword_1EBCD8C48 = 1065353216; v9 != v10; v9 += 24)
        sub_1CC619C24((uint64_t)&xmmword_1EBCD8C28, v9, v9);
      __cxa_atexit((void (*)(void *))sub_1CC619C20, &xmmword_1EBCD8C28, &dword_1CB82C000);
      __cxa_guard_release(&qword_1EBCD8C20);
      a2 = v6;
      uint64_t v3 = a1;
    }
  }
  if (!qword_1EBCD8C40) {
    return 1;
  }
  std::string::__init(&v11, v3, a2);
  BOOL v4 = sub_1CC619FE0(&xmmword_1EBCD8C28, (uint64_t)&v11) != 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  return v4;
}

void sub_1CD5D80BC(long long *a1, _WORD *a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBD06A30, 1, 0);
  qword_1EBD06AB0 = 0;
  unk_1EBD06AB8 = 0;
  qword_1EBD06AC0 = 0;
  unk_1EBD06AC8 = 0;
  qword_1EBD06A30 = (uint64_t)&unk_1F260A070;
  qword_1EBD06AD0 = 0;
  unk_1EBD06AD8 = 0;
  qword_1EBD06AE0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBD06AE8 = (uint64_t)&unk_1F260AC78;
  qword_1EBD06B00 = (uint64_t)&qword_1EBD06AE8;
  llvm::cl::Option::setArgStr(v6, "print-before", 0xCuLL);
  xmmword_1EBD06A50 = *a1;
  word_1EBD06A3A |= (*a2 & 0x1F) << 9;
  word_1EBD06A3A = (32 * (*a3 & 3)) | word_1EBD06A3A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD06A30);
}

void sub_1CD5D81C4(long long *a1, _WORD *a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBD06B08, 1, 0);
  qword_1EBD06B88 = 0;
  unk_1EBD06B90 = 0;
  qword_1EBD06B98 = 0;
  unk_1EBD06BA0 = 0;
  qword_1EBD06B08 = (uint64_t)&unk_1F260A070;
  qword_1EBD06BA8 = 0;
  unk_1EBD06BB0 = 0;
  qword_1EBD06BB8 = (uint64_t)&unk_1F2643EA0;
  qword_1EBD06BC0 = (uint64_t)&unk_1F260AC78;
  qword_1EBD06BD8 = (uint64_t)&qword_1EBD06BC0;
  llvm::cl::Option::setArgStr(v6, "print-after", 0xBuLL);
  xmmword_1EBD06B28 = *a1;
  word_1EBD06B12 |= (*a2 & 0x1F) << 9;
  word_1EBD06B12 = (32 * (*a3 & 3)) | word_1EBD06B12 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD06B08);
}

void sub_1CD5D82CC(long long *a1, __n128 *a2, _WORD *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD8C50, 1, 0);
  qword_1EBCD8CD0 = 0;
  unk_1EBCD8CD8 = 0;
  qword_1EBCD8CE0 = 0;
  unk_1EBCD8CE8 = 0;
  qword_1EBCD8C50 = (uint64_t)&unk_1F260A070;
  qword_1EBCD8CF0 = 0;
  unk_1EBCD8CF8 = 0;
  qword_1EBCD8D00 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCD8D08 = (uint64_t)&unk_1F260AC78;
  qword_1EBCD8D20 = (uint64_t)&qword_1EBCD8D08;
  sub_1CD5D83B4(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8C50);
}

__n128 sub_1CD5D83B4(long long *a1, __n128 *a2, _WORD *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD8C50, "filter-print-funcs", 0x12uLL);
  xmmword_1EBCD8C80 = *a1;
  __n128 result = *a2;
  xmmword_1EBCD8C70 = (__int128)*a2;
  word_1EBCD8C5A |= (*a3 & 0x1F) << 9;
  word_1EBCD8C5A = (32 * (*a4 & 3)) | word_1EBCD8C5A & 0xFF9F;
  return result;
}

void *sub_1CD5D8444@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  int v8 = operator new(0x28uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + sub_1CD521E44((uint64_t)this + 8) = v7;
  *int v8 = 0;
  v8[1] = a2;
  __n128 result = v8 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    __n128 result = sub_1CB8BDF7C((uint64_t)result, *(const void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__n128 result = *(_OWORD *)a3;
    result[2] = *(void *)(a3 + 16);
  }
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1CD5D84B4(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_1CB833614();
    }
    BOOL v4 = operator new(8 * a2);
    uint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] <= 1uLL)
      {
        v8 &= a2 - 1;
      }
      else if (v8 >= a2)
      {
        v8 %= a2;
      }
      *(void *)(*(void *)a1 + 8 * vsub_1CD521E44((uint64_t)this + 8) = a1 + 16;
      uint64_t v10 = (void *)*v7;
      if (*v7)
      {
        while (1)
        {
          unint64_t v11 = v10[1];
          if (v9.u32[0] <= 1uLL)
          {
            v11 &= a2 - 1;
          }
          else if (v11 >= a2)
          {
            v11 %= a2;
          }
          if (v11 == v8) {
            goto LABEL_28;
          }
          if (*(void *)(*(void *)a1 + 8 * v11)) {
            break;
          }
          *(void *)(*(void *)a1 + 8 * v11) = v7;
LABEL_19:
          uint64_t v7 = v10;
          uint64_t v10 = (void *)*v10;
          unint64_t v8 = v11;
          if (!v10) {
            return;
          }
        }
        *uint64_t v7 = *v10;
        void *v10 = **(void **)(*(void *)a1 + 8 * v11);
        **(void **)(*(void *)a1 + 8 * v11) = v10;
        uint64_t v10 = v7;
LABEL_28:
        unint64_t v11 = v8;
        goto LABEL_19;
      }
    }
  }
  else
  {
    size_t v12 = *(void **)a1;
    *(void *)a1 = 0;
    if (v12) {
      operator delete(v12);
    }
    *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  }
}

uint64_t sub_1CD5D8610(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  BOOL v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void llvm::SafepointIRVerifierPass::run()
{
}

void llvm::initializeSafepointIRVerifierPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD8DF0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC61C3E0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD8DF0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void *sub_1CD5D87E0(void *result, uint64_t a2)
{
  uint64_t v2 = (uint64_t)result;
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  uint64_t v4 = *(void *)a2 + 8 * v3;
  if (*(_DWORD *)(a2 + 8))
  {
    if (v3)
    {
      uint64_t v5 = 8 * v3;
      uint64_t v6 = *(uint64_t **)a2;
      while ((*v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v6;
        v5 -= 8;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v6 = *(uint64_t **)a2;
    }
  }
  else
  {
LABEL_6:
    uint64_t v6 = (uint64_t *)(*(void *)a2 + 8 * v3);
  }
  uint64_t v7 = *(void *)a2 + 8 * v3;
LABEL_8:
  while (v6 != (uint64_t *)v7)
  {
    __n128 result = sub_1CC61CA7C((uint64_t)v9, v2, v6);
    unint64_t v8 = v6 + 1;
    uint64_t v6 = (uint64_t *)v4;
    if (v8 != (uint64_t *)v4)
    {
      uint64_t v6 = v8;
      while ((*v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (++v6 == (uint64_t *)v4)
        {
          uint64_t v6 = (uint64_t *)v4;
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CD5D88AC(uint64_t result, uint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  uint64_t v5 = *(void *)result + 8 * v4;
  if (*(_DWORD *)(result + 8))
  {
    if (v4)
    {
      uint64_t v6 = 8 * v4;
      uint64_t v7 = *(void **)result;
      while ((*v7 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v7;
        v6 -= 8;
        if (!v6) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v7 = *(void **)result;
    }
  }
  else
  {
LABEL_6:
    uint64_t v7 = (void *)(*(void *)result + 8 * v4);
  }
  if (v7 != (void *)(*(void *)result + 8 * v4))
  {
    do
    {
      unint64_t v8 = v7;
      uint8x8_t v9 = v7 + 1;
      uint64_t v7 = (void *)v5;
      if (v9 != (void *)v5)
      {
        while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          if (++v9 == (void *)v5)
          {
            uint64_t v7 = (void *)v5;
            goto LABEL_12;
          }
        }
        uint64_t v7 = v9;
      }
LABEL_12:
      uint64_t v10 = (void *)*v8;
      uint64_t v11 = 0;
      size_t v12 = v10;
      __n128 result = sub_1CBFE4194(a2, &v12, &v11);
      if ((result & 1) == 0)
      {
        size_t v12 = 0;
        __n128 result = sub_1CBFE4194((uint64_t *)v3, v8, &v12);
        if (result)
        {
          *size_t v12 = -8192;
          *(int32x2_t *)(v3 + sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(v3 + 8), (int32x2_t)0x1FFFFFFFFLL);
        }
      }
    }
    while (v7 != (void *)(*(void *)v3 + 8 * *(unsigned int *)(v3 + 16)));
  }
  return result;
}

void *sub_1CD5D89EC(void *result, llvm::Instruction *this, unsigned int a3, uint64_t a4, int a5)
{
  unsigned int v6 = a3;
  if (a3 != a5)
  {
    uint64_t v8 = (uint64_t)result;
    do
    {
      uint64_t Successor = llvm::Instruction::getSuccessor(this, v6);
      __n128 result = (void *)sub_1CD4201D0(v8, &Successor, (uint64_t)v12);
      if (v13)
      {
        uint64_t v9 = llvm::Instruction::getSuccessor(this, v6);
        v12[0] = v9;
        uint64_t v10 = *(uint64_t **)(v8 + 32);
        if ((unint64_t)v10 >= *(void *)(v8 + 40))
        {
          __n128 result = sub_1CBC13470((void **)(v8 + 24), v12);
        }
        else
        {
          uint64_t *v10 = v9;
          __n128 result = v10 + 1;
        }
        *(void *)(v8 + 32) = result;
      }
      ++v6;
    }
    while (a5 != v6);
  }
  return result;
}

uint64_t sub_1CD5D8AA0(uint64_t a1)
{
  uint64_t v2 = (void *)(*(void *)(a1 + 32) - 8);
  uint64_t v4 = 0;
  uint64_t result = sub_1CD420258((uint64_t *)a1, v2, &v4);
  if (result)
  {
    *uint64_t v4 = -8192;
    *(int32x2_t *)(a1 + sub_1CD521E44((uint64_t)this + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  *(void *)(a1 + 32) -= 8;
  return result;
}

uint64_t sub_1CD5D8B0C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      uint64_t v9 = (void *)((v6 + 7) & 0xFFFFFFFFFFFFFFF8);
      uint64_t v10 = v9 + 10;
      while ((unint64_t)v10 <= v8)
      {
        uint64_t v11 = sub_1CD5D8C20(v9);
        uint64_t v10 = v11 + 20;
        uint64_t v9 = v11 + 10;
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v12 = *(unsigned int *)(a1 + 72);
  if (v12)
  {
    char v13 = *(void **)(a1 + 64);
    uint64_t v14 = &v13[2 * v12];
    do
    {
      std::string v15 = (void *)((*v13 + 7) & 0xFFFFFFFFFFFFFFF8);
      unint64_t v16 = *v13 + v13[1];
      uint64_t v17 = v15 + 10;
      while ((unint64_t)v17 <= v16)
      {
        unint64_t v18 = sub_1CD5D8C20(v15);
        uint64_t v17 = v18 + 20;
        std::string v15 = v18 + 10;
      }
      v13 += 2;
    }
    while (v13 != v14);
  }

  return sub_1CBFFBB10(a1);
}

void *sub_1CD5D8C20(void *a1)
{
  return a1;
}

void sub_1CD5D8C68(char **a1)
{
  uint64_t v2 = sub_1CB883A14((uint64_t)qword_1EBCD8D28, 0, 0);
  byte_1EBCD8DA8 = 0;
  qword_1EBCD8DB0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD8DB8 = 0;
  qword_1EBCD8D28[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBCD8DC0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD8DC8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD8DE0 = (uint64_t)&qword_1EBCD8DC8;
  llvm::cl::Option::setArgStr(v2, "safepoint-ir-verifier-print-only", 0x20uLL);
  uint64_t v3 = *a1;
  byte_1EBCD8DA8 = **a1;
  byte_1EBCD8DB9 = 1;
  byte_1EBCD8DB8 = *v3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCD8D28);
}

llvm::MDNode *llvm::ProfileSummary::getDetailedSummaryMD(llvm::ProfileSummary *this, llvm::LLVMContext *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  std::string __p = 0;
  unsigned int v22 = 0;
  unint64_t v23 = 0;
  uint64_t Int32Ty = llvm::Type::getInt32Ty(a2, a2);
  uint64_t v5 = (unsigned int *)*((void *)this + 1);
  uint64_t v6 = (unsigned int *)*((void *)this + 2);
  if (v5 != v6)
  {
    uint64_t v7 = (llvm::ConstantInt *)Int32Ty;
    unint64_t v8 = (llvm::ConstantInt *)(*(void *)a2 + 1984);
    do
    {
      int v24 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v9 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v7, *v5, 0);
      int v24 = (void *)llvm::ValueAsMetadata::get(v9, v10);
      uint64_t v11 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v8, *((void *)v5 + 1), 0);
      uint64_t v25 = (llvm::MDNode *)llvm::ValueAsMetadata::get(v11, v12);
      char v13 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(v7, *((void *)v5 + 2), 0);
      uint64_t v26 = llvm::ValueAsMetadata::get(v13, v14);
      uint64_t Impl = llvm::MDTuple::getImpl((uint64_t)a2, &v24, 3, 0, 1);
      size_t v20 = Impl;
      unint64_t v16 = v22;
      if ((unint64_t)v22 >= v23)
      {
        uint64_t v17 = (char *)sub_1CBC13470(&__p, &v20);
      }
      else
      {
        *(void *)unsigned int v22 = Impl;
        uint64_t v17 = v16 + 8;
      }
      unsigned int v22 = v17;
      v5 += 6;
    }
    while (v5 != v6);
  }
  int v24 = llvm::MDString::get((uint64_t *)a2, "DetailedSummary", 0xFuLL);
  uint64_t v25 = llvm::MDTuple::getImpl((uint64_t)a2, __p, (v22 - (unsigned char *)__p) >> 3, 0, 1);
  unint64_t v18 = llvm::MDTuple::getImpl((uint64_t)a2, &v24, 2, 0, 1);
  if (__p)
  {
    unsigned int v22 = (char *)__p;
    operator delete(__p);
  }
  return v18;
}

llvm::MDNode *llvm::ProfileSummary::getMD(llvm::ProfileSummary *this, llvm::LLVMContext *a2, int a3, int a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = off_1E68499B0[*(unsigned int *)this];
  size_t v20 = llvm::MDString::get((uint64_t *)a2, "ProfileFormat", 0xDuLL);
  size_t v9 = strlen(v8);
  unint64_t v21 = llvm::MDString::get((uint64_t *)a2, (unsigned __int8 *)v8, v9);
  v19[0] = llvm::MDTuple::getImpl((uint64_t)a2, &v20, 2, 0, 1);
  v19[1] = sub_1CC61D168((uint64_t *)a2, "TotalCount", *((void *)this + 4));
  v19[2] = sub_1CC61D168((uint64_t *)a2, "MaxCount", *((void *)this + 5));
  v19[3] = sub_1CC61D168((uint64_t *)a2, "MaxInternalCount", *((void *)this + 6));
  uint64_t v19[4] = sub_1CC61D168((uint64_t *)a2, "MaxFunctionCount", *((void *)this + 7));
  uint64_t v19[5] = sub_1CC61D168((uint64_t *)a2, "NumCounts", *((unsigned int *)this + 16));
  v19[6] = sub_1CC61D168((uint64_t *)a2, "NumFunctions", *((unsigned int *)this + 17));
  unsigned int v18 = 7;
  if (a3)
  {
    v19[7] = sub_1CC61D168((uint64_t *)a2, "IsPartialProfile", *((unsigned __int8 *)this + 72));
    unsigned int v18 = 8;
  }
  if (a4)
  {
    double v11 = *((double *)this + 10);
    DoubleTy = (llvm::ConstantFP **)llvm::Type::getDoubleTy(a2, v10);
    size_t v20 = llvm::MDString::get((uint64_t *)a2, "PartialProfileRatio", 0x13uLL);
    uint64_t v14 = llvm::ConstantFP::get(DoubleTy, v13, v11);
    unint64_t v21 = (void *)llvm::ValueAsMetadata::get(v14, v15);
    v19[v18++] = llvm::MDTuple::getImpl((uint64_t)a2, &v20, 2, 0, 1);
  }
  DetailedSummaryMD = llvm::ProfileSummary::getDetailedSummaryMD(this, a2);
  if (v18 >= 0x10) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  v19[v18] = DetailedSummaryMD;
  return llvm::MDTuple::getImpl((uint64_t)a2, v19, v18 + 1, 0, 1);
}

uint64_t llvm::ProfileSummary::getFromMD(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (*(unsigned char *)a1 != 4) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if ((v2 - 11) < 0xFFFFFFFD) {
    return 0;
  }
  uint64_t v4 = a1 - 8 * v2;
  if (!*(void *)v4)
  {
    if (sub_1CC61D22C(0, "SampleProfile")) {
      goto LABEL_10;
    }
    uint64_t v5 = 0;
    if (sub_1CC61D22C(0, "InstrProf")) {
      goto LABEL_10;
    }
LABEL_43:
    if (!sub_1CC61D22C(v5, "CSInstrProf")) {
      return 0;
    }
    goto LABEL_10;
  }
  if (**(unsigned char **)v4 == 4) {
    uint64_t v5 = *(void *)v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!sub_1CC61D22C(v5, "SampleProfile") && !sub_1CC61D22C(v5, "InstrProf")) {
    goto LABEL_43;
  }
LABEL_10:
  if (**(unsigned char **)(v4 + 8) == 4) {
    uint64_t v6 = *(unsigned __int8 **)(v4 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  if (sub_1CC61DC3C(v6, "TotalCount"))
  {
    unint64_t v8 = **(unsigned char **)(v4 + 16) == 4 ? *(unsigned __int8 **)(v4 + 16) : 0;
    if (sub_1CC61DC3C(v8, "MaxCount"))
    {
      uint64_t v10 = **(unsigned char **)(v4 + 24) == 4 ? *(unsigned __int8 **)(v4 + 24) : 0;
      if (sub_1CC61DC3C(v10, "MaxInternalCount"))
      {
        uint64_t v12 = **(unsigned char **)(v4 + 32) == 4 ? *(unsigned __int8 **)(v4 + 32) : 0;
        if (sub_1CC61DC3C(v12, "MaxFunctionCount"))
        {
          uint64_t v14 = **(unsigned char **)(v4 + 40) == 4 ? *(unsigned __int8 **)(v4 + 40) : 0;
          if (sub_1CC61DC3C(v14, "NumCounts"))
          {
            unsigned int v22 = 7;
            unint64_t v16 = **(unsigned char **)(v4 + 48) == 4 ? *(unsigned __int8 **)(v4 + 48) : 0;
            if (sub_1CC61DC3C(v16, "NumFunctions"))
            {
              uint64_t v21 = 0;
              if (sub_1CC61D31C(a1, &v22, &v21))
              {
                uint64_t v20 = 0;
                if (sub_1CC61D3B4(a1, &v22, (double *)&v20))
                {
                  memset(v19, 0, sizeof(v19));
                  if (**(unsigned char **)(a1 - 8 * *(unsigned int *)(a1 + 8) + 8 * v22) == 4) {
                    uint64_t v18 = *(void *)(a1 - 8 * *(unsigned int *)(a1 + 8) + 8 * v22);
                  }
                  else {
                    uint64_t v18 = 0;
                  }
                  if (sub_1CC61D440(v18, (uint64_t)v19)) {
                    operator new();
                  }
                  if (v19[0]) {
                    operator delete(v19[0]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1CD5D96FC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(float *)(a1 + 16));
}

uint64_t llvm::extractProbeFromDiscriminator@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(this + 48);
  if (v3
    && (uint64_t v4 = *(void *)(v3 - 8 * *(unsigned int *)(v3 + 8)), *(unsigned char *)v4 == 19)
    && ((v5 = *(_DWORD *)(v4 + 24), v5 >= 8) ? (BOOL v6 = (v5 & 7) == 7) : (BOOL v6 = 0), v6))
  {
    *(int8x8_t *)a2 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFE6FFFFFFFDLL), (int8x8_t)0x70000FFFFLL);
    *(_DWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v5 >> 29;
    *(float *)(a2 + 12) = (float)((v5 >> 19) & 0x7F) / 100.0;
    char v7 = 1;
  }
  else
  {
    char v7 = 0;
    *(unsigned char *)a2 = 0;
  }
  *(unsigned char *)(a2 + 16) = v7;
  return this;
}

BOOL llvm::isStatepointDirectiveAttr(uint64_t a1)
{
  uint64_t v2 = a1;
  return llvm::Attribute::hasAttribute(&v2, "statepoint-id", 13)
      || llvm::Attribute::hasAttribute(&v2, "statepoint-num-patch-bytes", 26);
}

uint64_t llvm::Type::getBFloatTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1648;
}

uint64_t llvm::Type::getDoubleTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1696;
}

uint64_t llvm::Type::getX86_FP80Ty(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1768;
}

uint64_t llvm::Type::getFP128Ty(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1792;
}

uint64_t llvm::Type::getX86_MMXTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1840;
}

uint64_t llvm::Type::getX86_AMXTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1864;
}

uint64_t llvm::Type::getTokenTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 1744;
}

BOOL llvm::Type::isIEEE(llvm::Type *this)
{
  void v5[3] = *MEMORY[0x1E4F143B8];
  FltSemantics = llvm::Type::getFltSemantics(this);
  sub_1CB87E68C((uint64_t)v5, (uint64_t)FltSemantics);
  sub_1CC570164((llvm::detail::DoubleAPFloat *)v4, 0);
  BOOL v2 = v5[0] != (void)&unk_1CFB2E344;
  sub_1CB87DEE4(v5);
  return v2;
}

uint64_t llvm::Type::getInt128Ty(llvm::Type *this, llvm::LLVMContext *a2)
{
  return *(void *)this + 2008;
}

unint64_t llvm::Type::getIntNPtrTy(llvm::Type *this, llvm::LLVMContext *a2, llvm::Type *a3)
{
  uint64_t v4 = (llvm::PointerType *)llvm::IntegerType::get(this, a2);

  return llvm::PointerType::get(v4, a3);
}

unint64_t llvm::Type::getInt16PtrTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return llvm::PointerType::get((llvm::PointerType *)(*(void *)this + 1936), a2);
}

unint64_t llvm::Type::getInt64PtrTy(llvm::Type *this, llvm::LLVMContext *a2)
{
  return llvm::PointerType::get((llvm::PointerType *)(*(void *)this + 1984), a2);
}

BOOL llvm::FunctionType::isValidReturnType(llvm::FunctionType *this, llvm::Type *a2)
{
  int v2 = *((unsigned __int8 *)this + 8);
  return v2 != 8 && v2 != 14 && v2 != 9;
}

uint64_t llvm::StructType::get(llvm::StructType *this, llvm::LLVMContext *a2)
{
  return llvm::StructType::get((uint64_t *)this, 0, 0, (int)a2);
}

uint64_t llvm::StructType::create(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, size_t a5, int a6)
{
  uint64_t v9 = llvm::StructType::create(a1, a4, a5);
  llvm::StructType::setBody(v9, a2, a3, a6);
  return v9;
}

uint64_t llvm::StructType::create(uint64_t ***a1, uint64_t a2, unsigned __int8 *a3, size_t a4, int a5)
{
  uint64_t v8 = llvm::StructType::create(**a1, a3, a4);
  llvm::StructType::setBody(v8, (uint64_t)a1, a2, a5);
  return v8;
}

BOOL llvm::StructType::isValidElementType(llvm::StructType *this, llvm::Type *a2)
{
  int v2 = *((_DWORD *)this + 2);
  return ((v2 - 7) >= 8u || ((0x87u >> (v2 - 7)) & 1) == 0)
      && *((_DWORD *)this + 2) != 12;
}

BOOL llvm::StructType::isLayoutIdentical(const void **this, const void **a2)
{
  if (this == a2) {
    return 1;
  }
  if (((*((unsigned __int8 *)this + 9) ^ *((unsigned __int8 *)a2 + 9)) & 2) != 0) {
    return 0;
  }
  uint64_t v2 = *((unsigned int *)this + 3);
  if (v2 != *((_DWORD *)a2 + 3)) {
    return 0;
  }
  return memcmp(this[2], a2[2], 8 * v2) == 0;
}

double llvm::ScalableVectorType::get(uint64_t **this, llvm::Type *a2)
{
  int v2 = (int)a2;
  uint64_t v4 = **this;
  v8[0] = this;
  v8[1] = a2 | 0x100000000;
  unsigned int v5 = sub_1CC624050((uint64_t *)(v4 + 2328), v8);
  if (!v5[2])
  {
    uint64_t v7 = sub_1CB906F34((uint64_t *)(v4 + 2040), 40, 3);
    *(void *)uint64_t v7 = *this;
    *(void *)(v7 + 24) = this;
    *(_DWORD *)(v7 + 32) = v2;
    *(void *)(v7 + 16) = v7 + 24;
    *(void *)&double result = 0x100000013;
    *(void *)(v7 + sub_1CD521E44((uint64_t)this + 8) = 0x100000013;
    void v5[2] = v7;
  }
  return result;
}

uint64_t llvm::PointerType::get(uint64_t **this, llvm::LLVMContext *a2)
{
  int v2 = (int)a2;
  uint64_t v4 = *this;
  uint64_t v7 = 0;
  if (a2)
  {
    int v8 = (int)a2;
    unsigned int v5 = (uint64_t *)(sub_1CC624760(v4 + 297, (uint64_t)&v7) + 16);
  }
  else
  {
    unsigned int v5 = sub_1CD5D9FA4(v4 + 294, &v7) + 1;
  }
  uint64_t result = *v5;
  if (!*v5)
  {
    uint64_t result = sub_1CB906F34(v4 + 255, 32, 3);
    *(void *)uint64_t result = this;
    *(void *)(result + 2llvm::MDNode::dumpTree(this, 0) = 0;
    *(void *)(result + 12) = 0;
    *(_DWORD *)(result + 2sub_1CD521E44((uint64_t)this + 8) = 0;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = (v2 << 8) | 0xF;
    uint64_t *v5 = result;
  }
  return result;
}

uint64_t llvm::TargetExtType::TargetExtType(uint64_t a1, void *a2, void *a3, size_t a4, uint64_t *a5, uint64_t a6, int *a7, uint64_t a8)
{
  *(void *)a1 = a2;
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 21;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = llvm::UniqueStringSaver::save(*a2 + 2136, a3, a4);
  *(void *)(a1 + 32) = v13;
  *(_DWORD *)(a1 + 12) = a6;
  uint64_t v14 = (void *)(a1 + 48);
  *(void *)(a1 + 16) = a1 + 48;
  if (a6)
  {
    uint64_t v15 = 8 * a6;
    do
    {
      uint64_t v16 = *a5++;
      *v14++ = v16;
      v15 -= 8;
    }
    while (v15);
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = *(unsigned __int8 *)(a1 + 8) | (a8 << 8);
  *(void *)(a1 + 4llvm::MDNode::dumpTree(this, 0) = v14;
  if (a8)
  {
    uint64_t v17 = 4 * a8;
    do
    {
      int v18 = *a7++;
      *(_DWORD *)uint64_t v14 = v18;
      uint64_t v14 = (void *)((char *)v14 + 4);
      v17 -= 4;
    }
    while (v17);
  }
  return a1;
}

uint64_t llvm::TargetExtType::get(void *a1, void *a2, size_t a3, uint64_t *a4, uint64_t a5, int *a6, uint64_t a7)
{
  v18[0] = a2;
  v18[1] = a3;
  _OWORD v18[2] = a4;
  void v18[3] = a5;
  _DWORD v18[4] = a6;
  void v18[5] = a7;
  unint64_t v14 = *a1 + 2280;
  uint64_t v19 = 0;
  sub_1CD5DA004(v14, &v19, (uint64_t)v18, (uint64_t)&v20);
  uint64_t v15 = v20;
  if (!v21) {
    return *v20;
  }
  uint64_t v17 = sub_1CB906F34((uint64_t *)(*a1 + 2040), 8 * a5 + 4 * a7 + 48, 3);
  uint64_t result = llvm::TargetExtType::TargetExtType(v17, a1, a2, a3, a4, a5, a6, a7);
  *uint64_t v15 = result;
  return result;
}

BOOL llvm::TargetExtType::hasProperty(llvm::TargetExtType *a1, int a2)
{
  llvm::TargetExtType::getLayoutType(a1);
  return (~v3 & a2) == 0;
}

unint64_t sub_1CD5D9DE4(unint64_t result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5D9E98(*(void *)v5, *(_DWORD *)(v5 + 16), a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

unint64_t sub_1CD5D9E98(unint64_t result, int a2, uint64_t *a3, void *a4)
{
  if (a2)
  {
    unint64_t v8 = result;
    uint64_t result = sub_1CD5D9F48(*a3);
    int v9 = a2 - 1;
    unsigned int v10 = result & (a2 - 1);
    unint64_t v5 = (void *)(v8 + 8 * v10);
    uint64_t v11 = *v5;
    if (*a3 != *v5)
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != -4096)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -8192;
        }
        if (v14) {
          uint64_t v12 = v5;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        unint64_t v5 = (void *)(v8 + 8 * (v15 & v9));
        uint64_t v11 = *v5;
        if (*a3 == *v5) {
          goto LABEL_3;
        }
      }
      if (v12) {
        unint64_t v5 = v12;
      }
    }
  }
  else
  {
    unint64_t v5 = 0;
  }
LABEL_3:
  *a4 = v5;
  return result;
}

unint64_t sub_1CD5D9F48(uint64_t a1)
{
  int v2 = *(void **)(a1 + 16);
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  v4[0] = (*(_DWORD *)(a1 + 8) & 0x200) != 0;
  unint64_t v5 = sub_1CC13A6B8(v2, (uint64_t)&v2[v3]);
  return sub_1CC623948(&v5, v4);
}

void *sub_1CD5D9FA4(uint64_t *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CB915048(a1, a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CC62462C((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1CD5DA004@<X0>(unint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD5DA094(*(void *)a1, *(_DWORD *)(a1 + 16), a3, &v12);
  int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD5DA40C(a1, a3, v12);
    int v9 = (uint64_t *)result;
    *(void *)uint64_t result = *a2;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + sub_1CD521E44((uint64_t)this + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CD5DA094(uint64_t a1, int a2, uint64_t a3, uint64_t **a4)
{
  if (a2)
  {
    int v9 = a2 - 1;
    unsigned int v10 = sub_1CD5DA1E0(a3) & (a2 - 1);
    unint64_t v5 = (uint64_t *)(a1 + 8 * v10);
    uint64_t v11 = *v5;
    if (sub_1CD5DA184(a3, *v5))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v12 = 0;
      int v13 = 1;
      while (v11 != -4096)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -8192;
        }
        if (v14) {
          uint64_t v12 = v5;
        }
        int v15 = v13 + 1;
        unsigned int v10 = (v10 + v13) & v9;
        unint64_t v5 = (uint64_t *)(a1 + 8 * v10);
        uint64_t v11 = *v5;
        BOOL v16 = sub_1CD5DA184(a3, *v5);
        uint64_t result = 1;
        int v13 = v15;
        if (v16) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v12) {
        unint64_t v5 = v12;
      }
    }
  }
  else
  {
    unint64_t v5 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a4 = v5;
  return result;
}

BOOL sub_1CD5DA184(uint64_t a1, uint64_t a2)
{
  if ((a2 | 0x1000) == 0xFFFFFFFFFFFFF000) {
    return 0;
  }
  uint64_t v12 = v2;
  uint64_t v13 = v3;
  long long v7 = *(_OWORD *)(a2 + 24);
  unint64_t v6 = *(unsigned int *)(a2 + 8);
  uint64_t v5 = *(unsigned int *)(a2 + 12);
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = v5;
  uint64_t v10 = *(void *)(a2 + 40);
  unint64_t v11 = v6 >> 8;
  return sub_1CD5DA370(a1, (uint64_t)&v7);
}

unint64_t sub_1CD5DA1E0(uint64_t a1)
{
  unint64_t v4 = sub_1CC13A6B8(*(void **)(a1 + 16), *(void *)(a1 + 16) + 8 * *(void *)(a1 + 24));
  unint64_t v3 = sub_1CC13A6B8(*(void **)(a1 + 32), *(void *)(a1 + 32) + 4 * *(void *)(a1 + 40));
  return sub_1CD5DA23C(a1, (uint64_t *)&v4, (uint64_t *)&v3);
}

unint64_t sub_1CD5DA23C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  return sub_1CD5DA2E4((char *)v7, v7, (char *)v8, *(void **)a1, *(void *)(a1 + 8), a2, a3);
}

unint64_t sub_1CD5DA2E4(char *a1, void *a2, char *a3, void *a4, uint64_t a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v15 = 0;
  unint64_t v12 = llvm::hash_value(a4, a5);
  uint64_t v13 = sub_1CBFFCBA0(a1, &v15, a2, (unint64_t)a3, v12);
  return sub_1CBFFD088(a1, v15, v13, a3, a6, a7);
}

BOOL sub_1CD5DA370(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)(a2 + 8)
    && (!v2 || !memcmp(*(const void **)a1, *(const void **)a2, v2))
    && (uint64_t v5 = *(void *)(a1 + 24), v5 == *(void *)(a2 + 24))
    && !memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), 8 * v5)
    && (uint64_t v7 = *(void *)(a1 + 40), v7 == *(void *)(a2 + 40)))
  {
    return memcmp(*(const void **)(a1 + 32), *(const void **)(a2 + 32), 4 * v7) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t *sub_1CD5DA40C(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5DA4C0(a1, v6);
  uint64_t v8 = 0;
  sub_1CD5DA094(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5DA4C0(unint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5DA58C(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

unint64_t sub_1CD5DA58C(unint64_t result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD5DA640(*(void *)v5, *(_DWORD *)(v5 + 16), a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

unint64_t sub_1CD5DA640(unint64_t result, int a2, uint64_t *a3, void *a4)
{
  if (a2)
  {
    unint64_t v8 = result;
    uint64_t v9 = *a3;
    long long v19 = *(_OWORD *)(*a3 + 24);
    unint64_t v11 = *(unsigned int *)(v9 + 8);
    uint64_t v10 = *(unsigned int *)(v9 + 12);
    uint64_t v20 = *(void *)(v9 + 16);
    uint64_t v21 = v10;
    uint64_t v22 = *(void *)(v9 + 40);
    unint64_t v23 = v11 >> 8;
    uint64_t result = sub_1CD5DA1E0((uint64_t)&v19);
    int v12 = a2 - 1;
    unsigned int v13 = result & (a2 - 1);
    unint64_t v5 = (void *)(v8 + 8 * v13);
    uint64_t v14 = *v5;
    if (*a3 != *v5)
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == -8192;
        }
        if (v17) {
          uint64_t v15 = v5;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        unint64_t v5 = (void *)(v8 + 8 * (v18 & v12));
        uint64_t v14 = *v5;
        if (*a3 == *v5) {
          goto LABEL_3;
        }
      }
      if (v15) {
        unint64_t v5 = v15;
      }
    }
  }
  else
  {
    unint64_t v5 = 0;
  }
LABEL_3:
  *a4 = v5;
  return result;
}

uint64_t llvm::TypedPointerType::get(uint64_t **this, llvm::Type *a2)
{
  int v2 = (int)a2;
  uint64_t v4 = **this;
  v7[0] = this;
  v7[1] = a2;
  uint64_t v5 = sub_1CD5DA7B0(v4 + 2400, (uint64_t)v7);
  uint64_t result = *(void *)(v5 + 16);
  if (!result)
  {
    uint64_t result = sub_1CB906F34((uint64_t *)(v4 + 2040), 32, 3);
    *(void *)uint64_t result = *this;
    *(void *)(result + 24) = this;
    *(void *)(result + 16) = result + 24;
    *(_DWORD *)(result + sub_1CD521E44((uint64_t)this + 8) = (v2 << 8) | 0x14;
    *(_DWORD *)(result + 12) = 1;
    *(void *)(v5 + 16) = result;
  }
  return result;
}

uint64_t sub_1CD5DA7B0(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4674DC(*(void *)a1, *(_DWORD *)(a1 + 16), *(void *)a2, *(_DWORD *)(a2 + 8), &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5DA82C(a1, a2, v7);
    *(void *)uint64_t v5 = *(void *)a2;
    *(_DWORD *)(v5 + sub_1CD521E44((uint64_t)this + 8) = *(_DWORD *)(a2 + 8);
    *(void *)(v5 + 16) = 0;
  }
  return v5;
}

uint64_t sub_1CD5DA82C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5DA8EC(a1, v6);
  uint64_t v9 = 0;
  sub_1CD4674DC(*(void *)a1, *(_DWORD *)(a1 + 16), *(void *)a2, *(_DWORD *)(a2 + 8), &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)a3 != -4096 || *(_DWORD *)(a3 + 8) != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD5DA8EC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5DA9D0(a1, (uint64_t)v4, (uint64_t)v4 + 24 * v3);
    llvm::deallocate_buffer(v4, (void *)(24 * v3));
  }
  *(void *)(a1 + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      _OWORD *result = xmmword_1CFAC30E0;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5DA9D0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + sub_1CD521E44((uint64_t)this + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_OWORD **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *int v7 = xmmword_1CFAC30E0;
      int v7 = (_OWORD *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    int v10 = *(_DWORD *)(a2 + 8);
    if ((*(void *)a2 != -4096 || v10 != -1) && (v9 != -8192 || v10 != -2))
    {
      uint64_t v14 = 0;
      uint64_t result = sub_1CD4674DC(*(void *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      unsigned int v13 = v14;
      *uint64_t v14 = *(void *)a2;
      *((_DWORD *)v13 + 2) = *(_DWORD *)(a2 + 8);
      void v13[2] = *(void *)(a2 + 16);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t llvm::Value::getSingleUndroppableUse(llvm::Value *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = *(void *)(v1 + 24);
      if (sub_1CBF698E4(v3) || sub_1CC27D470(v3))
      {
        uint64_t result = v2;
      }
      else
      {
        uint64_t result = v1;
        if (v2) {
          return 0;
        }
      }
      uint64_t v1 = *(void *)(v1 + 8);
      uint64_t v2 = result;
      if (!v1) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t llvm::Value::dropDroppableUsesIn(uint64_t this, llvm::User *a2)
{
  uint64_t v2 = this;
  int v3 = *((_DWORD *)a2 + 5);
  if ((v3 & 0x40000000) != 0)
  {
    uint64_t v5 = (llvm::Value *)*((void *)a2 - 1);
    uint64_t v4 = v3 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v4 = v3 & 0x7FFFFFF;
    uint64_t v5 = (llvm::User *)((char *)a2 - 32 * v4);
  }
  if (v4)
  {
    uint64_t v6 = 32 * v4;
    do
    {
      if (*(void *)v5 == v2) {
        this = llvm::Value::dropDroppableUse(v5, a2);
      }
      uint64_t v5 = (llvm::Value *)((char *)v5 + 32);
      v6 -= 32;
    }
    while (v6);
  }
  return this;
}

void llvm::Value::replaceNonMetadataUsesWith(llvm::Value *this, llvm::Value *a2)
{
}

void *sub_1CD5DABA0(unint64_t *a1, uint64_t a2)
{
  sub_1CC630870(a1, (void *)(*(void *)a2 + 24 * *(unsigned int *)(a2 + 8) - 24));
  unsigned int v3 = *(_DWORD *)(a2 + 8) - 1;
  *(_DWORD *)(a2 + sub_1CD521E44((uint64_t)this + 8) = v3;
  uint64_t result = (void *)(*(void *)a2 + 24 * v3);
  uint64_t v5 = result[2];
  if (v5 != -8192 && v5 != -4096 && v5 != 0)
  {
    return llvm::ValueHandleBase::RemoveFromUseList(result);
  }
  return result;
}

void llvm::Value::replaceUsesOutsideBlock(uint64_t ***this, llvm::Value *a2, llvm::BasicBlock *a3)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x600000000;
  llvm::findDbgUsers((uint64_t)&v9, this);
  uint64_t v6 = v9;
  if (v10)
  {
    uint64_t v8 = (uint64_t ***)v9;
    uint64_t v7 = 8 * v10;
    do
    {
      if ((*v8)[5] != (uint64_t *)a3) {
        llvm::DbgVariableIntrinsic::replaceVariableLocationOp(*v8, (llvm::Value *)this, a2);
      }
      ++v8;
      v7 -= 8;
    }
    while (v7);
    uint64_t v6 = v9;
  }
  if (v6 != v11) {
    free(v6);
  }
  uint64_t v9 = a3;
  llvm::Value::replaceUsesWithIf((llvm::Value *)this, a2, (unsigned int (*)(uint64_t, uint64_t))sub_1CC630A50, (uint64_t)&v9);
}

BOOL llvm::Value::canBeFreed(llvm::Value *this)
{
  unsigned int v1 = *((unsigned __int8 *)this + 16);
  if (v1 < 0x15) {
    return 0;
  }
  if (v1 == 21)
  {
    if (llvm::Argument::hasPointeeInMemoryValueAttr(this)) {
      return 0;
    }
    uint64_t v4 = *(unsigned char **)(*((void *)this + 3) + 112);
    if (v4 && ((v4[17] & 0x30) != 0 || (v4[15] & 2) != 0) && (v4[16] & 8) != 0) {
      return 0;
    }
    unsigned int v1 = *((unsigned __int8 *)this + 16);
  }
  if (v1 >= 0x1C)
  {
    uint64_t Function = llvm::Instruction::getFunction(this);
    unsigned int v1 = *((unsigned __int8 *)this + 16);
  }
  else
  {
    uint64_t Function = 0;
  }
  if (v1 == 21) {
    uint64_t Function = *((void *)this + 3);
  }
  if (!Function) {
    return 1;
  }
  if ((*(_WORD *)(Function + 18) & 0x4000) == 0) {
    return 1;
  }
  GC = llvm::Function::getGC((llvm::LLVMContext ***)Function);
  if (!sub_1CBA86C10(GC, "statepoint-example") || (*(_DWORD *)(*(void *)this + 8) & 0xFFFFFF00) != 0x100) {
    return 1;
  }
  uint64_t v7 = *(void *)(Function + 40);
  uint64_t v8 = v7 + 24;
  uint64_t v9 = *(void *)(v7 + 32);
  if (v9 == v8) {
    return 0;
  }
  do
  {
    uint64_t v10 = v9 - 56;
    if (!v9) {
      uint64_t v10 = 0;
    }
    int v11 = *(_DWORD *)(v10 + 36);
    BOOL result = v11 == 124;
    if (v11 == 124) {
      break;
    }
    uint64_t v9 = *(void *)(v9 + 8);
  }
  while (v9 != v8);
  return result;
}

BOOL llvm::Value::isTransitiveUsedByMetadataOnly(llvm::Value *this)
{
  unsigned char v15[32] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 1);
  unsigned int v13 = v15;
  uint64_t v14 = 0x2000000000;
  sub_1CC472E24((uint64_t)&v13, v2, 0);
  sub_1CD5DB25C((llvm::SmallPtrSetImplBase *)&v11, *((void *)this + 1), 0);
  unsigned int v3 = v14;
  if (v14)
  {
    do
    {
      uint64_t v4 = *((void *)v13 + --v3);
      LODWORD(v14) = v3;
      unsigned int v5 = *(unsigned __int8 *)(v4 + 16) - 4;
      BOOL v6 = v5 < 0x11;
      if (v5 > 0x10) {
        break;
      }
      uint64_t v7 = *(void *)(v4 + 8);
      if (v7)
      {
        do
        {
          uint64_t v8 = *(void *)(v7 + 24);
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v11, v8);
          if (v9)
          {
            if (v14 >= (unint64_t)HIDWORD(v14)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v13 + v14) = v8;
            LODWORD(v14) = v14 + 1;
          }
          uint64_t v7 = *(void *)(v7 + 8);
        }
        while (v7);
        unsigned int v3 = v14;
      }
    }
    while (v3);
  }
  else
  {
    BOOL v6 = 1;
  }
  if (v12 != v11) {
    free(v12);
  }
  if (v13 != v15) {
    free(v13);
  }
  return v6;
}

void sub_1CD5DAFBC(_WORD *a1, unsigned __int8 **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD8DF8, 0, 0);
  dword_1EBCD8E78 = 0;
  qword_1EBCD8E80 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD8E88 = 0;
  qword_1EBCD8DF8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD8E90 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD8E98 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD8EB0 = (uint64_t)&qword_1EBCD8E98;
  llvm::cl::Option::setArgStr(v6, "use-dereferenceable-at-point-semantics", 0x26uLL);
  word_1EBCD8E02 = (32 * (*a1 & 3)) | word_1EBCD8E02 & 0xFF9F;
  dword_1EBCD8E78 = **a2;
  byte_1EBCD8E8C = 1;
  dword_1EBCD8E88 = dword_1EBCD8E78;
  xmmword_1EBCD8E18 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD8DF8);
}

unint64_t sub_1CD5DB0E4(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 24 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD5DB150();
    }
    sub_1CD5DB150();
  }
  return a2;
}

void sub_1CD5DB150()
{
}

unint64_t *sub_1CD5DB1C0(unint64_t *result, unint64_t *a2)
{
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v4 = result;
    unsigned int v5 = (void *)*result;
    uint64_t v6 = 24 * v2;
    do
    {
      BOOL result = sub_1CC630870(a2, v5);
      v5 += 3;
      a2 += 3;
      v6 -= 24;
    }
    while (v6);
    uint64_t v7 = *((unsigned int *)v4 + 2);
    if (v7)
    {
      unint64_t v8 = *v4;
      uint64_t v9 = 24 * v7;
      do
      {
        uint64_t v10 = *(void *)(v8 + v9 - 8);
        if (v10 != -8192 && v10 != -4096 && v10 != 0) {
          BOOL result = llvm::ValueHandleBase::RemoveFromUseList((void *)(v8 + v9 - 24));
        }
        v9 -= 24;
      }
      while (v9);
    }
  }
  return result;
}

llvm::SmallPtrSetImplBase *sub_1CD5DB25C(llvm::SmallPtrSetImplBase *this, uint64_t a2, uint64_t a3)
{
  *(void *)this = (char *)this + 32;
  *((void *)this + 1) = (char *)this + 32;
  *((void *)this + 2) = 32;
  *((_DWORD *)this + 6) = 0;
  if (a2 != a3)
  {
    uint64_t v5 = a2;
    do
    {
      sub_1CB89694C(this, *(void *)(v5 + 24));
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != a3);
  }
  return this;
}

llvm *llvm::ValueSymbolTable::dump(llvm *this)
{
  uint64_t v1 = *((unsigned int *)this + 2);
  if (v1)
  {
    for (uint64_t i = *(uint64_t **)this; !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = *(uint64_t **)this;
  }
  uint64_t v4 = *(void *)this + 8 * v1;
  if (i != (uint64_t *)v4)
  {
    uint64_t v5 = *i;
    do
    {
      this = llvm::Value::dump(*(llvm::Value **)(v5 + 8));
      do
      {
        uint64_t v6 = i[1];
        ++i;
        uint64_t v5 = v6;
        if (v6) {
          BOOL v7 = v5 == -8;
        }
        else {
          BOOL v7 = 1;
        }
      }
      while (v7);
    }
    while (i != (uint64_t *)v4);
  }
  return this;
}

uint64_t llvm::verifyFunction(uint64_t ***this, const llvm::Function *a2, llvm::raw_ostream *a3)
{
  unsigned int v3 = this;
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  sub_1CC631F04((uint64_t)v5, (uint64_t)a2, 1, this[5]);
  LODWORD(v3) = sub_1CC632100((unint64_t)v5, v3);
  sub_1CC634578((uint64_t)v5);
  return v3 ^ 1;
}

llvm::raw_ostream *sub_1CD5DB3C0(llvm::raw_ostream *result, llvm::Metadata **a2)
{
  if (result)
  {
    uint64_t v8 = v2;
    uint64_t v9 = v3;
    uint64_t v5 = (llvm::raw_ostream **)result;
    uint64_t v6 = "Access tag nodes must have the number of operands that is a multiple of 3!";
    __int16 v7 = 259;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v6);
    if (*v5) {
      return (llvm::raw_ostream *)sub_1CD5DC50C(v5, *a2);
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DB42C(llvm::raw_ostream *result, unsigned char *a2, llvm::Metadata **a3)
{
  if (result)
  {
    uint64_t v11 = v3;
    uint64_t v12 = v4;
    uint64_t v6 = (llvm::raw_ostream **)result;
    char v7 = 1;
    char v10 = 1;
    if (*a2)
    {
      uint64_t v8 = a2;
      char v7 = 3;
    }
    char v9 = v7;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v8);
    if (*v6) {
      return (llvm::raw_ostream *)sub_1CD5DC50C(v6, *a3);
    }
  }
  return result;
}

void sub_1CD5DB4A4(llvm::raw_ostream *a1, llvm::Value **a2, llvm::Metadata **a3, llvm::APInt **a4)
{
  if (a1)
  {
    uint64_t v12 = v4;
    uint64_t v13 = v5;
    char v10 = "Could not find TBAA parent in struct type node";
    __int16 v11 = 259;
    sub_1CD5DBE68(a1, (llvm::Twine *)&v10);
    if (*(void *)a1) {
      sub_1CD5DD328((llvm::raw_ostream **)a1, *a2, a3, a4);
    }
  }
}

llvm::raw_ostream *sub_1CD5DB528(llvm::raw_ostream *result, llvm::Value **a2)
{
  if (result)
  {
    uint64_t v8 = v2;
    uint64_t v9 = v3;
    uint64_t v5 = (llvm::raw_ostream **)result;
    uint64_t v6 = "This instruction shall not have a TBAA access tag!";
    __int16 v7 = 259;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v6);
    if (*v5)
    {
      if (*a2) {
        return sub_1CD5DBED0(v5, *a2);
      }
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DB598(llvm::raw_ostream *result, llvm::Value **a2)
{
  if (result)
  {
    uint64_t v8 = v2;
    uint64_t v9 = v3;
    uint64_t v5 = (llvm::raw_ostream **)result;
    uint64_t v6 = "Old-style TBAA is no longer allowed, use struct-path TBAA instead";
    __int16 v7 = 259;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v6);
    if (*v5)
    {
      if (*a2) {
        return sub_1CD5DBED0(v5, *a2);
      }
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DB608(llvm::raw_ostream *result, llvm::Value **a2, llvm::Metadata **a3, llvm::Metadata **a4, llvm::Metadata **a5)
{
  if (result)
  {
    uint64_t v14 = v5;
    uint64_t v15 = v6;
    __int16 v11 = (llvm::raw_ostream **)result;
    uint64_t v12 = "Malformed struct tag metadata: base and access-type should be non-null and point to Metadata nodes";
    __int16 v13 = 259;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v12);
    if (*v11) {
      return (llvm::raw_ostream *)sub_1CD5DCA08(v11, *a2, a3, a4, a5);
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DB69C(llvm::raw_ostream *result, llvm::Value **a2, llvm::Metadata **a3, llvm::Metadata **a4)
{
  if (result)
  {
    uint64_t v12 = v4;
    uint64_t v13 = v5;
    uint64_t v9 = (llvm::raw_ostream **)result;
    char v10 = "Access type node must be a valid scalar type";
    __int16 v11 = 259;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v10);
    if (*v9) {
      return (llvm::raw_ostream *)sub_1CD5DC92C(v9, *a2, a3, a4);
    }
  }
  return result;
}

void sub_1CD5DB720(llvm::raw_ostream *a1, llvm::Value **a2, llvm::Metadata **a3, llvm::APInt **a4)
{
  if (a1)
  {
    uint64_t v12 = v4;
    uint64_t v13 = v5;
    char v10 = "Offset not zero at the point of scalar access";
    __int16 v11 = 259;
    sub_1CD5DBE68(a1, (llvm::Twine *)&v10);
    if (*(void *)a1) {
      sub_1CD5DD328((llvm::raw_ostream **)a1, *a2, a3, a4);
    }
  }
}

llvm::raw_ostream *sub_1CD5DB7A4(llvm::raw_ostream *result, llvm::Value **a2, llvm::Metadata **a3, unsigned int *a4, unsigned int *a5)
{
  if (result)
  {
    uint64_t v14 = v5;
    uint64_t v15 = v6;
    __int16 v11 = (llvm::raw_ostream **)result;
    uint64_t v12 = "Access bit-width not the same as description bit-width";
    __int16 v13 = 259;
    BOOL result = sub_1CD5DBE68(result, (llvm::Twine *)&v12);
    if (*v11) {
      return sub_1CD5DD3FC(v11, *a2, a3, a4, a5);
    }
  }
  return result;
}

void llvm::initializeVerifierLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD8EC0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC638728;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD8EC0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createVerifierPass(llvm *this)
{
}

uint64_t llvm::VerifierAnalysis::run(llvm *a1, llvm *a2)
{
  uint64_t v3 = llvm::dbgs(a1);
  LOBYTE(v6) = llvm::verifyModule(a2, v3, (llvm::raw_ostream *)((char *)&v6 + 1), v4);
  return v6;
}

uint64_t llvm::VerifierAnalysis::run(llvm *a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = llvm::dbgs(a1);
  sub_1CC631F04((uint64_t)v5, (uint64_t)v3, 1, *(void **)(a2 + 40));
  LODWORD(a2) = sub_1CC632100((unint64_t)v5, (uint64_t ***)a2);
  sub_1CC634578((uint64_t)v5);
  return a2 ^ 1;
}

void llvm::VerifierPass::run()
{
}

{
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

llvm::raw_ostream **sub_1CD5DBB8C(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Type **a4)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    uint64_t v8 = *a4;
    return sub_1CD5DC17C((llvm::raw_ostream **)a1, v8);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DBC00(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Value **a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      BOOL result = sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    uint64_t v8 = *a4;
    if (*a4)
    {
      return sub_1CD5DBED0((llvm::raw_ostream **)a1, v8);
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DBC7C(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, uint64_t *a4, llvm::Value **a5, uint64_t *a6)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    uint64_t v12 = *a4;
    return sub_1CD5DC11C((llvm::raw_ostream **)a1, v12, a5, a6);
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DBD0C(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Metadata **a4)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    uint64_t v8 = *a4;
    return sub_1CD5DC50C((llvm::raw_ostream **)a1, v8);
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DBD80(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Metadata **a4)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DC588(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    uint64_t v8 = *a4;
    return sub_1CD5DC50C((llvm::raw_ostream **)a1, v8);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DBDF4(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Metadata **a3, llvm::Value **a4)
{
  BOOL result = sub_1CD5DC588(a1, a2);
  if (*(void *)a1)
  {
    BOOL result = (llvm::raw_ostream *)sub_1CD5DC50C((llvm::raw_ostream **)a1, *a3);
    uint64_t v8 = *a4;
    if (*a4)
    {
      return sub_1CD5DBED0((llvm::raw_ostream **)a1, v8);
    }
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DBE68(llvm::raw_ostream *result, llvm::Twine *this)
{
  uint64_t v2 = result;
  uint64_t v3 = *(llvm::raw_ostream **)result;
  if (*(void *)result)
  {
    BOOL result = llvm::Twine::print(this, v3);
    uint64_t v4 = (unsigned char *)*((void *)v3 + 4);
    if ((unint64_t)v4 >= *((void *)v3 + 3))
    {
      BOOL result = llvm::raw_ostream::write(v3, 10);
    }
    else
    {
      *((void *)v3 + 4) = v4 + 1;
      *uint64_t v4 = 10;
    }
  }
  *((unsigned char *)v2 + 192) = 1;
  return result;
}

llvm::raw_ostream *sub_1CD5DBED0(llvm::raw_ostream **a1, llvm::Value *this)
{
  unsigned int v4 = *((unsigned __int8 *)this + 16);
  uint64_t v6 = (llvm::ModuleSlotTracker *)(a1 + 2);
  uint64_t v5 = *a1;
  if (v4 < 0x1C) {
    sub_1CC4F9C88((unint64_t *)this, v5, 1, v6);
  }
  else {
    llvm::Value::print(this, v5, v6, 0);
  }
  BOOL result = *a1;
  uint64_t v8 = (unsigned char *)*((void *)*a1 + 4);
  if ((unint64_t)v8 >= *((void *)*a1 + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v8 + 1;
    *uint64_t v8 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DBF64(llvm::raw_ostream **a1, llvm::Value *a2, uint64_t *a3, llvm::Value **a4)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  BOOL result = sub_1CD5DBFD8(*a1, *a3);
  uint64_t v8 = *a4;
  if (*a4)
  {
    return sub_1CD5DBED0(a1, v8);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DBFD8(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v3 = sub_1CB8E509C(a1, "; ModuleID = '");
  uint64_t v6 = *(const char **)(a2 + 168);
  uint64_t v5 = a2 + 168;
  unsigned int v4 = v6;
  char v7 = *(unsigned char *)(v5 + 23);
  int v8 = v7;
  if (v7 >= 0) {
    uint64_t v9 = (const char *)v5;
  }
  else {
    uint64_t v9 = v4;
  }
  size_t v10 = v7 & 0x7F;
  if (v8 >= 0) {
    size_t v11 = v10;
  }
  else {
    size_t v11 = *(void *)(v5 + 8);
  }
  uint64_t v12 = llvm::raw_ostream::write(v3, v9, v11);

  return sub_1CB8E509C(v12, "'\n");
}

llvm::raw_ostream *sub_1CD5DC040(llvm::raw_ostream **a1, llvm::Value *a2, uint64_t *a3, llvm::Value **a4, llvm::Value **a5, uint64_t *a6)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  sub_1CD5DBFD8(*a1, *a3);
  size_t v11 = *a4;

  return sub_1CD5DC0B8(a1, v11, a5, a6);
}

llvm::raw_ostream *sub_1CD5DC0B8(llvm::raw_ostream **a1, llvm::Value *a2, llvm::Value **a3, uint64_t *a4)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  if (*a3) {
    sub_1CD5DBED0(a1, *a3);
  }
  uint64_t v7 = *a4;
  int v8 = *a1;

  return sub_1CD5DBFD8(v8, v7);
}

llvm::raw_ostream *sub_1CD5DC11C(llvm::raw_ostream **a1, uint64_t a2, llvm::Value **a3, uint64_t *a4)
{
  sub_1CD5DBFD8(*a1, a2);
  if (*a3) {
    sub_1CD5DBED0(a1, *a3);
  }
  uint64_t v7 = *a4;
  int v8 = *a1;

  return sub_1CD5DBFD8(v8, v7);
}

llvm::raw_ostream **sub_1CD5DC17C(llvm::raw_ostream **result, llvm::Type *this)
{
  if (this)
  {
    uint64_t v3 = *result;
    unsigned int v4 = (unsigned char *)*((void *)*result + 4);
    if ((unint64_t)v4 >= *((void *)*result + 3))
    {
      llvm::raw_ostream::write(*result, 32);
    }
    else
    {
      *((void *)v3 + 4) = v4 + 1;
      *unsigned int v4 = 32;
    }
    return (llvm::raw_ostream **)llvm::Type::print(this, v3, 0, 0);
  }
  return result;
}

llvm::AttributeList *sub_1CD5DC1F4(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::AttributeList **a3, llvm::Value **a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    BOOL result = *a3;
    if (*a3) {
      BOOL result = llvm::AttributeList::print(result, *(llvm::raw_ostream **)a1);
    }
    int v8 = *a4;
    if (*a4)
    {
      return sub_1CD5DBED0((llvm::raw_ostream **)a1, v8);
    }
  }
  return result;
}

void sub_1CD5DC268(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::AttributeSetNode ***a3, llvm::Value **a4)
{
  sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DC350((llvm::raw_ostream **)a1, *a3);
    uint64_t v7 = *a4;
    if (*a4)
    {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, v7);
    }
  }
}

void sub_1CD5DC2DC(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Attribute **a3, llvm::Value **a4)
{
  sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DC3F4((llvm::raw_ostream **)a1, *a3);
    uint64_t v7 = *a4;
    if (*a4)
    {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, v7);
    }
  }
}

void sub_1CD5DC350(llvm::raw_ostream **a1, llvm::AttributeSetNode **this)
{
  if (this)
  {
    uint64_t v2 = *a1;
    llvm::AttributeSet::getAsString(this, 0, (uint64_t)__p);
    if (v7 >= 0) {
      uint64_t v3 = __p;
    }
    else {
      uint64_t v3 = (void **)__p[0];
    }
    if (v7 >= 0) {
      size_t v4 = v7 & 0x7F;
    }
    else {
      size_t v4 = (size_t)__p[1];
    }
    llvm::raw_ostream::write(v2, (const char *)v3, v4);
    uint64_t v5 = (unsigned char *)*((void *)v2 + 4);
    if ((unint64_t)v5 >= *((void *)v2 + 3))
    {
      llvm::raw_ostream::write(v2, 10);
    }
    else
    {
      *((void *)v2 + 4) = v5 + 1;
      unsigned char *v5 = 10;
    }
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1CD5DC3F4(llvm::raw_ostream **a1, llvm::Attribute *this)
{
  if (this)
  {
    uint64_t v2 = *a1;
    llvm::Attribute::getAsString(this, 0, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    llvm::raw_ostream::write(v2, (const char *)p_p, size);
    uint64_t v5 = (unsigned char *)*((void *)v2 + 4);
    if ((unint64_t)v5 >= *((void *)v2 + 3))
    {
      llvm::raw_ostream::write(v2, 10);
    }
    else
    {
      *((void *)v2 + 4) = v5 + 1;
      unsigned char *v5 = 10;
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

llvm::raw_ostream *sub_1CD5DC498(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Value *a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    return sub_1CD5DBED0((llvm::raw_ostream **)a1, a4);
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DC50C(llvm::raw_ostream **result, llvm::Metadata *this)
{
  if (this) {
    llvm::Metadata::print(this, *result, (llvm::ModuleSlotTracker *)(result + 2), result[1]);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DC588(llvm::raw_ostream *result, llvm::Twine *this)
{
  uint64_t v2 = result;
  uint64_t v3 = *(llvm::raw_ostream **)result;
  if (*(void *)result)
  {
    BOOL result = llvm::Twine::print(this, v3);
    size_t v4 = (unsigned char *)*((void *)v3 + 4);
    if ((unint64_t)v4 >= *((void *)v3 + 3))
    {
      BOOL result = llvm::raw_ostream::write(v3, 10);
    }
    else
    {
      *((void *)v3 + 4) = v4 + 1;
      *size_t v4 = 10;
    }
  }
  *((unsigned char *)v2 + 192) |= *((unsigned char *)v2 + 194);
  *((unsigned char *)v2 + 193) = 1;
  return result;
}

llvm::raw_ostream **sub_1CD5DC600(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Metadata **a3, llvm::Metadata **a4)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DC50C((llvm::raw_ostream **)a1, *a3);
    int v8 = *a4;
    return sub_1CD5DC50C((llvm::raw_ostream **)a1, v8);
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DC670(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Metadata **a3, llvm::Metadata **a4)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DC588(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DC50C((llvm::raw_ostream **)a1, *a3);
    int v8 = *a4;
    return sub_1CD5DC50C((llvm::raw_ostream **)a1, v8);
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DC6E0(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Metadata **a3, llvm::Metadata **a4, llvm::Metadata **a5)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DC588(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DC50C((llvm::raw_ostream **)a1, *a3);
    sub_1CD5DC50C((llvm::raw_ostream **)a1, *a4);
    size_t v10 = *a5;
    return sub_1CD5DC50C((llvm::raw_ostream **)a1, v10);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DC760(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Metadata **a3, unsigned int *a4)
{
  BOOL result = sub_1CD5DC588(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DC50C((llvm::raw_ostream **)a1, *a3);
    unsigned int v8 = *a4;
    uint64_t v9 = *(llvm::raw_ostream **)a1;
    return sub_1CD5DC7D0(v9, v8);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DC7D0(llvm::raw_ostream *a1, unsigned int a2)
{
  BOOL result = sub_1CD098D14(a1, a2, 0, 0, 0);
  size_t v4 = (unsigned char *)*((void *)a1 + 4);
  if ((unint64_t)v4 >= *((void *)a1 + 3))
  {
    return llvm::raw_ostream::write(a1, 10);
  }
  else
  {
    *((void *)a1 + 4) = v4 + 1;
    *size_t v4 = 10;
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DC844(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Metadata **a3, llvm::Value **a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    BOOL result = (llvm::raw_ostream *)sub_1CD5DC50C((llvm::raw_ostream **)a1, *a3);
    unsigned int v8 = *a4;
    if (*a4)
    {
      return sub_1CD5DBED0((llvm::raw_ostream **)a1, v8);
    }
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DC8B8(llvm::raw_ostream **a1, llvm::Metadata *a2, llvm::Value **a3, llvm::Value **a4, llvm::Metadata **a5, llvm::Metadata **a6)
{
  sub_1CD5DC50C(a1, a2);
  if (*a3) {
    sub_1CD5DBED0(a1, *a3);
  }
  size_t v11 = *a4;

  return sub_1CD5DC92C(a1, v11, a5, a6);
}

llvm::raw_ostream **sub_1CD5DC92C(llvm::raw_ostream **a1, llvm::Value *a2, llvm::Metadata **a3, llvm::Metadata **a4)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  sub_1CD5DC50C(a1, *a3);
  char v7 = *a4;

  return sub_1CD5DC50C(a1, v7);
}

llvm::raw_ostream **sub_1CD5DC98C(llvm::raw_ostream **a1, llvm::Metadata *a2, llvm::Value **a3, llvm::Value **a4, llvm::Metadata **a5, llvm::Metadata **a6, llvm::Metadata **a7)
{
  sub_1CD5DC50C(a1, a2);
  if (*a3) {
    sub_1CD5DBED0(a1, *a3);
  }
  __int16 v13 = *a4;

  return sub_1CD5DCA08(a1, v13, a5, a6, a7);
}

llvm::raw_ostream **sub_1CD5DCA08(llvm::raw_ostream **a1, llvm::Value *a2, llvm::Metadata **a3, llvm::Metadata **a4, llvm::Metadata **a5)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  sub_1CD5DC50C(a1, *a3);
  sub_1CD5DC50C(a1, *a4);
  uint64_t v9 = *a5;

  return sub_1CD5DC50C(a1, v9);
}

llvm::raw_ostream *sub_1CD5DCA78(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Value **a4, llvm::Value **a5, llvm::Value **a6)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    uint64_t v12 = *a4;
    return sub_1CD5DCB08(a1, v12, a5, a6);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DCB08(llvm::raw_ostream *result, llvm::Value *a2, llvm::Value **a3, llvm::Value **a4)
{
  uint64_t v6 = (llvm::raw_ostream **)result;
  if (a2) {
    BOOL result = sub_1CD5DBED0((llvm::raw_ostream **)result, a2);
  }
  if (*a3) {
    BOOL result = sub_1CD5DBED0(v6, *a3);
  }
  char v7 = *a4;
  if (*a4)
  {
    return sub_1CD5DBED0(v6, v7);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DCB88(llvm::raw_ostream **a1, llvm::Value *a2, llvm::Type **a3, llvm::Value *a4)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  sub_1CD5DC17C(a1, *a3);

  return sub_1CD5DBED0(a1, a4);
}

llvm::raw_ostream *sub_1CD5DCBE8(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value *a3, llvm::Value *a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    sub_1CD5DBED0((llvm::raw_ostream **)a1, a3);
    return sub_1CD5DBED0((llvm::raw_ostream **)a1, a4);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DCC58(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value *a3, llvm::Value **a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    BOOL result = sub_1CD5DBED0((llvm::raw_ostream **)a1, a3);
    unsigned int v8 = *a4;
    if (*a4)
    {
      return sub_1CD5DBED0((llvm::raw_ostream **)a1, v8);
    }
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DCCCC(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Value **a3, llvm::Value **a4, llvm::Value **a5, llvm::Metadata **a6, llvm::Metadata **a7, llvm::Metadata **a8, llvm::Metadata **a9)
{
  BOOL result = (llvm::raw_ostream **)sub_1CD5DC588(a1, a2);
  if (*(void *)a1)
  {
    if (*a3) {
      sub_1CD5DBED0((llvm::raw_ostream **)a1, *a3);
    }
    BOOL v17 = *a4;
    return sub_1CD5DCD80((llvm::raw_ostream **)a1, v17, a5, a6, a7, a8, a9);
  }
  return result;
}

llvm::raw_ostream **sub_1CD5DCD80(llvm::raw_ostream **a1, llvm::Value *a2, llvm::Value **a3, llvm::Metadata **a4, llvm::Metadata **a5, llvm::Metadata **a6, llvm::Metadata **a7)
{
  if (a2) {
    sub_1CD5DBED0(a1, a2);
  }
  if (*a3) {
    sub_1CD5DBED0(a1, *a3);
  }
  __int16 v13 = *a4;

  return sub_1CD5DCE04(a1, v13, a5, a6, a7);
}

llvm::raw_ostream **sub_1CD5DCE04(llvm::raw_ostream **a1, llvm::Metadata *a2, llvm::Metadata **a3, llvm::Metadata **a4, llvm::Metadata **a5)
{
  sub_1CD5DC50C(a1, a2);
  sub_1CD5DC50C(a1, *a3);
  sub_1CD5DC50C(a1, *a4);
  uint64_t v9 = *a5;

  return sub_1CD5DC50C(a1, v9);
}

void sub_1CD5DCE6C(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 + a2 > (unint64_t)*(unsigned int *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2) {
    bzero((void *)(*(void *)a1 + 8 * v4), 8 * a2);
  }
  *(_DWORD *)(a1 + sub_1CD521E44((uint64_t)this + 8) = v4 + v2;
}

llvm::raw_ostream *sub_1CD5DCEDC(llvm::raw_ostream *a1, llvm::Twine *a2, llvm::Type **a3, llvm::Value **a4)
{
  BOOL result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    BOOL result = (llvm::raw_ostream *)sub_1CD5DC17C((llvm::raw_ostream **)a1, *a3);
    unsigned int v8 = *a4;
    if (*a4)
    {
      return sub_1CD5DBED0((llvm::raw_ostream **)a1, v8);
    }
  }
  return result;
}

uint64_t sub_1CD5DCF50(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1[1];
  if (a3)
  {
    uint64_t v6 = 16 * a3;
    char v7 = (uint64_t *)(a2 + 8);
    uint64_t v8 = 16 * a3;
    unint64_t v9 = a1[1];
    do
    {
      uint64_t v10 = *v7;
      v7 += 2;
      v9 += v10;
      v8 -= 16;
    }
    while (v8);
    uint64_t result = sub_1CC223914((uint64_t)a1, v9);
    uint64_t v12 = (size_t *)(a2 + 8);
    do
    {
      if (*v12)
      {
        uint64_t result = (uint64_t)memmove((void *)(*a1 + v4), (const void *)*(v12 - 1), *v12);
        size_t v13 = *v12;
      }
      else
      {
        size_t v13 = 0;
      }
      v4 += v13;
      v12 += 2;
      v6 -= 16;
    }
    while (v6);
  }
  else
  {
    unint64_t v14 = a1[1];
    return sub_1CC223914((uint64_t)a1, v14);
  }
  return result;
}

llvm::raw_ostream *sub_1CD5DD010(llvm::raw_ostream *a1, llvm::Twine *a2, uint64_t a3)
{
  uint64_t result = sub_1CD5DBE68(a1, a2);
  if (*(void *)a1)
  {
    uint64_t v6 = *(void *)(a3 + 8);
    if (v6)
    {
      char v7 = *(llvm::Value ***)a3;
      uint64_t v8 = 8 * v6;
      do
      {
        if (*v7) {
          uint64_t result = sub_1CD5DBED0((llvm::raw_ostream **)a1, *v7);
        }
        ++v7;
        v8 -= 8;
      }
      while (v8);
    }
  }
  return result;
}