void sub_1CD480A84(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  uint64_t vars8;

  sub_1CB883A14((uint64_t)&qword_1EBCC5470, 0, 0);
  dword_1EBCC54F0 = 0;
  qword_1EBCC54F8 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC5500 = 0;
  qword_1EBCC5470 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC5508 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC5510 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC5528 = (uint64_t)&qword_1EBCC5510;
  sub_1CD480B84(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC5470);
}

__n128 sub_1CD480B84(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC5470, "da-miv-max-level-threshold", 0x1AuLL);
  dword_1EBCC54F0 = **a1;
  byte_1EBCC5504 = 1;
  dword_1EBCC5500 = dword_1EBCC54F0;
  word_1EBCC547A = word_1EBCC547A & 0xFF9F | (32 * (*a2 & 3));
  word_1EBCC547A = word_1EBCC547A & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCC5490 = (__int128)*a4;
  return result;
}

char **sub_1CD480C18(char **a1)
{
  v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    do
    {
      if (*(_DWORD *)&v2[v4 - 8] >= 0x41u)
      {
        uint64_t v5 = *(void *)&v2[v4 - 16];
        if (v5) {
          MEMORY[0x1D25D9CB0](v5, 0x1000C8000313F17);
        }
      }
      v4 -= 16;
    }
    while (v4);
    v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void ***sub_1CD480CA0(void ***result, unint64_t a2)
{
  unint64_t v2 = *((unsigned int *)result + 2);
  if (v2 != a2)
  {
    int v3 = a2;
    uint64_t v4 = result;
    if (v2 > a2)
    {
      __n128 result = sub_1CD480D50((void ***)&(*result)[6 * a2], (void ***)&(*result)[6 * v2]);
    }
    else
    {
      if (*((unsigned int *)result + 3) < a2) {
        sub_1CD480DB0();
      }
      if (v2 != a2)
      {
        uint64_t v5 = (uint64_t)&(*result)[6 * a2];
        uint64_t v6 = (uint64_t)&(*result)[6 * v2];
        int64x2_t v7 = vdupq_n_s64(1uLL);
        do
        {
          *(void *)uint64_t v6 = 0;
          *(void *)(v6 + 8) = 0;
          *(void *)(v6 + 16) = 0;
          *(int64x2_t *)(v6 + 24) = v7;
          *(void *)(v6 + 40) = 1;
          v6 += 48;
        }
        while (v6 != v5);
      }
    }
    *((_DWORD *)v4 + 2) = v3;
  }
  return result;
}

void ***sub_1CD480D50(void ***result, void ***a2)
{
  if (a2 != result)
  {
    unint64_t v2 = a2;
    int v3 = result;
    do
    {
      sub_1CB9F9ED4(v2 - 1);
      sub_1CB9F9ED4(v2 - 2);
      __n128 result = sub_1CB9F9ED4(v2 - 3);
      v2 -= 6;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_1CD480DB0()
{
}

void ***sub_1CD480E20(long long **a1, uint64_t a2)
{
  int v3 = *a1;
  unsigned int v4 = *((_DWORD *)a1 + 2);
  if (v4)
  {
    uint64_t v6 = &v3[3 * v4];
    do
    {
      long long v7 = *v3;
      *(_DWORD *)(a2 + 16) = *((_DWORD *)v3 + 4);
      *(_OWORD *)a2 = v7;
      *(void *)(a2 + 24) = *((void *)v3 + 3);
      *((void *)v3 + 3) = 1;
      *(void *)(a2 + 32) = *((void *)v3 + 4);
      *((void *)v3 + 4) = 1;
      *(void *)(a2 + 40) = *((void *)v3 + 5);
      *((void *)v3 + 5) = 1;
      v3 += 3;
      a2 += 48;
    }
    while (v3 != v6);
    int v3 = *a1;
    unsigned int v5 = *((_DWORD *)a1 + 2);
  }
  else
  {
    unsigned int v5 = 0;
  }
  return sub_1CD480D50((void ***)v3, (void ***)&v3[3 * v5]);
}

uint64_t sub_1CD480E9C(uint64_t a1, long long *a2)
{
  if (!*(_DWORD *)(a1 + 12))
  {
    sub_1CD480F40();
  }
  uint64_t result = (uint64_t)sub_1CBFDFE2C(*(uint64_t **)a1, *(_DWORD *)(a1 + 8) != 0, a2);
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  if (v5 != 1)
  {
    if (v5) {
      uint64_t result = (uint64_t)sub_1CD480D50((void ***)(*(void *)a1 + 48), (void ***)(*(void *)a1 + 48 * v5));
    }
    else {
      uint64_t result = sub_1CBFDFEA0(*(void *)a1, a2);
    }
  }
  *(_DWORD *)(a1 + 8) = 1;
  return result;
}

void sub_1CD480F40()
{
}

uint64_t sub_1CD480FD4(uint64_t result, unint64_t a2, long long *a3)
{
  if (*(unsigned int *)(result + 12) < a2)
  {
    *(_DWORD *)(result + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v4 = (_DWORD *)(result + 8);
  unint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 >= a2) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = *(unsigned int *)(result + 8);
  }
  if (v5)
  {
    uint64_t v6 = *(_OWORD **)result;
    do
    {
      long long v7 = *a3;
      long long v8 = a3[2];
      v6[1] = a3[1];
      v6[2] = v8;
      *uint64_t v6 = v7;
      v6 += 3;
      --v5;
    }
    while (v5);
    unint64_t v3 = *v4;
  }
  unint64_t v9 = v3 - a2;
  if (v3 < a2)
  {
    v10 = (_OWORD *)(*(void *)result + 48 * v3);
    do
    {
      long long v11 = *a3;
      long long v12 = a3[2];
      v10[1] = a3[1];
      v10[2] = v12;
      _OWORD *v10 = v11;
      v10 += 3;
    }
    while (!__CFADD__(v9++, 1));
  }
  *unsigned int v4 = a2;
  return result;
}

uint64_t llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::computeInstructionOrdinals(uint64_t result)
{
  v1 = *(uint64_t **)(result + 24);
  uint64_t v2 = *((unsigned int *)v1 + 2);
  if (v2)
  {
    uint64_t v3 = *v1;
    uint64_t v4 = *v1 + 8 * v2;
    uint64_t v5 = result + 56;
    uint64_t v6 = 1;
    do
    {
      uint64_t v7 = *(void *)v3 + 40;
      uint64_t v8 = *(void *)(*(void *)v3 + 48);
      while (v8 != v7)
      {
        uint64_t v9 = v8 - 24;
        if (!v8) {
          uint64_t v9 = 0;
        }
        uint64_t v10 = v6 + 1;
        uint64_t v12 = v9;
        uint64_t v13 = v6;
        uint64_t result = sub_1CD481EB8((uint64_t)v11, v5, &v12, &v13);
        uint64_t v8 = *(void *)(v8 + 8);
        uint64_t v6 = v10;
      }
      v3 += 8;
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::createFineGrainedNodes(uint64_t result)
{
  v1 = *(uint64_t **)(result + 24);
  uint64_t v2 = *((unsigned int *)v1 + 2);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *v1;
    uint64_t v13 = *v1 + 8 * v2;
    uint64_t v5 = result + 32;
    uint64_t v6 = result + 80;
    uint64_t v7 = result + 56;
    do
    {
      uint64_t v8 = *(void *)v4 + 40;
      for (uint64_t i = *(void *)(*(void *)v4 + 48); i != v8; uint64_t i = *(void *)(i + 8))
      {
        if (i) {
          uint64_t v10 = i - 24;
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24))(v3, v10);
        uint64_t v15 = v10;
        uint64_t v16 = v11;
        sub_1CD4729F8((uint64_t)v14, v5, &v15, &v16);
        v14[0] = v10;
        uint64_t v12 = sub_1CD45F378(v7, v14)[1];
        uint64_t v15 = v11;
        uint64_t v16 = v12;
        uint64_t result = sub_1CD481EB8((uint64_t)v14, v6, &v15, &v16);
      }
      v4 += 8;
    }
    while (v4 != v13);
  }
  return result;
}

char **llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::createPiBlocks(char *a1)
{
  v44[24] = *MEMORY[0x1E4F143B8];
  uint64_t result = (char **)(*(uint64_t (**)(char *))(*(void *)a1 + 88))(a1);
  if (result)
  {
    v42 = (char *)v44;
    uint64_t v43 = 0x400000000;
    uint64_t v3 = *(void *)(*((void *)a1 + 1) + 80);
    LODWORD(v30[0]) = 0;
    v30[1] = 0;
    v30[2] = 0;
    int v31 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    uint64_t v36 = 0;
    sub_1CD482214((int *)v30, v3);
    sub_1CD4822D8(v30);
    uint64_t v29 = 0;
    memset(v28, 0, sizeof(v28));
    sub_1CD4818C0((uint64_t)&v37, (uint64_t)v30, (uint64_t)v28);
    sub_1CD4750A4(v28);
    sub_1CD4750A4(v30);
    sub_1CD4824B0((uint64_t)v25, (uint64_t)&v37);
    sub_1CD4824B0((uint64_t)v41, (uint64_t)v40);
    while (!sub_1CD482544(v25, v41))
    {
      if ((unint64_t)(v27 - v26) >= 9)
      {
        v23 = v27;
        v24 = v26;
        sub_1CD481A18((uint64_t)&v42, &v24, &v23);
      }
      sub_1CD4822D8(v25);
    }
    sub_1CD4750A4(v41);
    sub_1CD4750A4(v25);
    sub_1CD4750A4(v40);
    sub_1CD4750A4(&v37);
    if (v43)
    {
      uint64_t v4 = v42;
      v22 = &v42[48 * v43];
      do
      {
        uint64_t v5 = *(uint64_t **)v4;
        unint64_t v6 = *((unsigned int *)v4 + 2);
        uint64_t v7 = (uint64_t *)(*(void *)v4 + 8 * v6);
        v37 = a1;
        unint64_t v8 = 126 - 2 * __clz(v6);
        if (v6) {
          uint64_t v9 = v8;
        }
        else {
          uint64_t v9 = 0;
        }
        sub_1CD48275C(v5, v7, &v37, v9, 1);
        uint64_t v10 = (*(uint64_t (**)(char *, char *))(*(void *)a1 + 32))(a1, v4);
        sub_1CD482B64((llvm::SmallPtrSetImplBase *)&v37, *(uint64_t **)v4, (uint64_t *)(*(void *)v4 + 8 * *((unsigned int *)v4 + 2)));
        uint64_t v11 = *((void *)a1 + 1);
        uint64_t v12 = *(unsigned int *)(v11 + 96);
        if (v12)
        {
          uint64_t v13 = *(uint64_t **)(v11 + 88);
          v14 = &v13[v12];
          do
          {
            uint64_t v15 = *v13;
            if (v10 != *v13)
            {
              uint64_t v16 = (char *)sub_1CB896AE8((uint64_t)&v37, *v13);
              v17 = v38 == v37 ? (unsigned int *)((char *)&v39 + 4) : (unsigned int *)&v39;
              if (v16 == &v38[8 * *v17])
              {
                v41[0] = 0;
                v24 = a1;
                v25[0] = v41;
                v25[1] = &v24;
                v25[2] = a1;
                uint64_t v18 = *((unsigned int *)v4 + 2);
                if (v18)
                {
                  v19 = *(uint64_t **)v4;
                  uint64_t v20 = 8 * v18;
                  do
                  {
                    uint64_t v21 = *v19++;
                    sub_1CD481A9C((uint64_t)v25, v15, v21);
                    sub_1CD481A9C((uint64_t)v25, v21, v15);
                    v20 -= 8;
                  }
                  while (v20);
                }
              }
            }
            ++v13;
          }
          while (v13 != v14);
        }
        if (v38 != v37) {
          free(v38);
        }
        v4 += 48;
      }
      while (v4 != v22);
    }
    sub_1CD3C7F68((_DWORD *)a1 + 14);
    sub_1CD3C7F68((_DWORD *)a1 + 20);
    return sub_1CD48219C(&v42);
  }
  return result;
}

void llvm::AbstractDependenceGraphBuilder<llvm::DataDependenceGraph>::sortNodesTopologically(void *a1)
{
  v23[64] = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(void *))(*a1 + 88))(a1)) {
    return;
  }
  uint64_t v21 = v23;
  uint64_t v22 = 0x4000000000;
  sub_1CD481C68((uint64_t)v19, *(void *)(a1[1] + 80));
  sub_1CD483184((const void **)&v14, (llvm::SmallPtrSetImplBase *)v19);
  sub_1CD483184((const void **)&v9, (llvm::SmallPtrSetImplBase *)&v20);
  while (1)
  {
    if (v17 != v12) {
      goto LABEL_14;
    }
    if (!v17) {
      break;
    }
    uint64_t v2 = v11;
    uint64_t v3 = v16;
    while (*v3 == *v2 && v3[1] == v2[1])
    {
      v3 += 3;
      v2 += 3;
      if (v3 == (void *)((char *)v16 + 24 * v17)) {
        goto LABEL_19;
      }
    }
LABEL_14:
    uint64_t v5 = *((void *)v16 + 3 * v17 - 3);
    if (*(_DWORD *)(v5 + 56) == 3)
    {
      uint64_t v6 = (*(uint64_t (**)(void *, uint64_t))(*a1 + 64))(a1, v5);
      sub_1CD4832F4((unsigned int *)&v21, (uint64_t)v21 + 8 * v22, *(uint64_t **)v6, (uint64_t *)(*(void *)v6 + 8 * *(unsigned int *)(v6 + 8)));
    }
    if (v22 >= (unint64_t)HIDWORD(v22)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v21 + v22) = v5;
    LODWORD(v22) = v22 + 1;
    if (--v17) {
      sub_1CD483018((unint64_t)&v14);
    }
  }
LABEL_19:
  if (v11 != &v13) {
    free(v11);
  }
  if (v10 != v9) {
    free(v10);
  }
  if (v16 != &v18) {
    free(v16);
  }
  if (v15 != v14) {
    free(v15);
  }
  sub_1CD481E4C(v19);
  uint64_t v7 = a1[1];
  uint64_t v8 = *(void *)(v7 + 88);
  v7 += 88;
  *(_DWORD *)(v7 + 8) = 0;
  sub_1CD475A94(v7, v8, (uint64_t)v21 + 8 * v22, (uint64_t)v21 + 8 * v22, (uint64_t)v21, (uint64_t)v21);
  if (v21 != v23) {
    free(v21);
  }
}

uint64_t sub_1CD481868(llvm::Instruction **a1)
{
  if (llvm::Dependence::isOutput(a1) & 1) != 0 || (llvm::Dependence::isFlow(a1)) {
    return 1;
  }

  return llvm::Dependence::isAnti(a1);
}

void *sub_1CD4818C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v34[0]) = *(_DWORD *)a2;
  int v3 = v34[0];
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  int v5 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  uint64_t v6 = *(void *)(a2 + 48);
  long long v7 = *(_OWORD *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v8 = *(void *)(a2 + 72);
  long long v9 = *(_OWORD *)(a2 + 56);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v10 = *(void *)(a2 + 96);
  long long v11 = *(_OWORD *)(a2 + 80);
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 80) = 0;
  uint64_t v12 = *(void *)(a3 + 8);
  *(void *)(a3 + 8) = 0;
  uint64_t v13 = *(void *)(a3 + 48);
  long long v14 = *(_OWORD *)(a3 + 32);
  uint64_t v15 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  LODWORD(v23[0]) = *(_DWORD *)a3;
  int v16 = v23[0];
  int v17 = *(_DWORD *)(a3 + 24);
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
  uint64_t v18 = *(void *)(a3 + 72);
  long long v19 = *(_OWORD *)(a3 + 56);
  *(void *)(a3 + 64) = 0;
  *(void *)(a3 + 72) = 0;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  uint64_t v20 = *(void *)(a3 + 96);
  long long v21 = *(_OWORD *)(a3 + 80);
  *(void *)(a3 + 88) = 0;
  *(void *)(a3 + 96) = 0;
  *(void *)(a3 + 80) = 0;
  *(_DWORD *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  v34[1] = 0;
  *(void *)(a1 + 16) = v15;
  v34[2] = 0;
  *(_DWORD *)(a1 + 24) = v5;
  int v35 = 0;
  *(_OWORD *)(a1 + 32) = v7;
  *(void *)(a1 + 48) = v6;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  *(_OWORD *)(a1 + 56) = v9;
  *(void *)(a1 + 72) = v8;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  *(_OWORD *)(a1 + 80) = v11;
  *(void *)(a1 + 96) = v10;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  *(_DWORD *)(a1 + 104) = v16;
  *(void *)(a1 + 112) = v12;
  v23[1] = 0;
  *(void *)&long long v7 = *(void *)(a3 + 16);
  *(void *)(a3 + 16) = 0;
  *(void *)(a1 + 120) = v7;
  v23[2] = 0;
  *(_DWORD *)(a1 + 128) = v17;
  int v24 = 0;
  *(_OWORD *)(a1 + 136) = v14;
  *(void *)(a1 + 152) = v13;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  *(_OWORD *)(a1 + 160) = v19;
  *(void *)(a1 + 176) = v18;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  *(_OWORD *)(a1 + 184) = v21;
  *(void *)(a1 + 200) = v20;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  sub_1CD4750A4(v23);
  return sub_1CD4750A4(v34);
}

uint64_t sub_1CD481A18(uint64_t a1, char **a2, char **a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD4825E0();
  }
  int v5 = (void *)(*(void *)a1 + 48 * v4);
  uint64_t v6 = *a2;
  long long v7 = *a3;
  *int v5 = v5 + 2;
  v5[1] = 0x400000000;
  uint64_t result = sub_1CD4570C8((uint64_t)v5, v6, v7);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CD481A9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[10] = *MEMORY[0x1E4F143B8];
  int v3 = *(void ***)(a2 + 32);
  for (uint64_t i = *(void ***)(a2 + 40); v3 != i; ++v3)
  {
    if (**v3 == a3)
    {
      int v5 = v7;
      uint64_t v6 = 0xA00000000;
      llvm::DGNode<llvm::DDGNode,llvm::DDGEdge>::findEdgesTo();
    }
  }
}

void sub_1CD481C68(uint64_t a1, uint64_t a2)
{
  v13[24] = *MEMORY[0x1E4F143B8];
  sub_1CD482F54((unint64_t)&v10, a2);
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  v7[0] = 0;
  memset(v6, 0, sizeof(v6));
  int v3 = (char *)v6 + 8;
  unsigned int v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  sub_1CD482CC0(a1, (uint64_t)&v10, (uint64_t)&v3);
  if (v7[1] != (char *)v8 + 8) {
    free(v7[1]);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v12 != v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
}

void *sub_1CD481D8C(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  int v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_1CD481DD0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == 3) {
    return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
  }
  if (a4 == 2) {
    return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
  }
  return (*(uint64_t (**)(void))(*(void *)a1 + 40))();
}

void **sub_1CD481E4C(void **a1)
{
  uint64_t v2 = (void **)a1[50];
  if (v2 != a1 + 52) {
    free(v2);
  }
  int v3 = a1[39];
  if (v3 != a1[38]) {
    free(v3);
  }
  unsigned int v4 = (void **)a1[12];
  if (v4 != a1 + 14) {
    free(v4);
  }
  uint64_t v5 = a1[1];
  if (v5 != *a1) {
    free(v5);
  }
  return a1;
}

uint64_t sub_1CD481EB8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v13 = 0;
  uint64_t result = sub_1CD40EA84(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v13);
  uint64_t v9 = v13;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD45F3E4(a2, a3, v13);
    uint64_t v9 = (void *)result;
    uint64_t v12 = *a4;
    *(void *)uint64_t result = *a3;
    *(void *)(result + 8) = v12;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD481F50()
{
  return 1;
}

uint64_t sub_1CD481F58(int a1, llvm::Instruction *this)
{
  if (llvm::Instruction::mayReadFromMemory(this)) {
    return 1;
  }

  return llvm::Instruction::mayWriteToMemory(this);
}

void sub_1CD481FA8(void *a1, uint64_t a2, llvm::SmallPtrSetImplBase *a3)
{
  sub_1CD48200C(&v5, a2, a3);
  unsigned int v4 = __p;
  *a1 = v5;
  a1[2] = 0;
  a1[3] = 0;
  a1[1] = 0;
  sub_1CBFE1720(a1 + 1, v4, v7, (v7 - v4) >> 5);
  if (__p)
  {
    long long v7 = __p;
    operator delete(__p);
  }
}

void *sub_1CD48200C(void *a1, uint64_t a2, llvm::SmallPtrSetImplBase *this)
{
  *a1 = this;
  a1[1] = 0;
  uint64_t v5 = (void **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  sub_1CB89694C(this, a2);
  if (v6)
  {
    *(void *)&long long v11 = a2;
    BYTE8(v11) = 0;
    BYTE8(v12) = 0;
    long long v7 = (_OWORD *)a1[2];
    if ((unint64_t)v7 >= a1[3])
    {
      uint64_t v9 = sub_1CBF9AC5C(v5, &v11);
    }
    else
    {
      long long v8 = v12;
      *long long v7 = v11;
      v7[1] = v8;
      uint64_t v9 = v7 + 2;
    }
    a1[2] = v9;
  }
  return a1;
}

char *sub_1CD48209C(char *result)
{
  v1 = result;
  uint64_t v2 = (void **)(result + 8);
  uint64_t v3 = *((void *)result + 2);
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 32);
    if (!*(unsigned char *)(v3 - 8))
    {
      *(void *)(v3 - 24) = *(void *)(v4 + 32);
      *(void *)(v3 - 16) = sub_1CD482194;
      *(unsigned char *)(v3 - 8) = 1;
    }
    while (1)
    {
      uint64_t v5 = *(void **)(v3 - 24);
      if (v5 == *(void **)(v4 + 40)) {
        break;
      }
      char v6 = *(uint64_t (**)(void))(v3 - 16);
      *(void *)(v3 - 24) = v5 + 1;
      uint64_t v7 = v6(*v5);
      uint64_t result = (char *)sub_1CB89694C(*(llvm::SmallPtrSetImplBase **)v1, v7);
      if (v8)
      {
        *(void *)&long long v12 = v7;
        BYTE8(v12) = 0;
        BYTE8(v13) = 0;
        char v10 = (_OWORD *)*((void *)v1 + 2);
        if ((unint64_t)v10 >= *((void *)v1 + 3))
        {
          uint64_t result = (char *)sub_1CBF9AC5C(v2, &v12);
        }
        else
        {
          long long v11 = v13;
          _OWORD *v10 = v12;
          v10[1] = v11;
          uint64_t result = (char *)(v10 + 2);
        }
        *((void *)v1 + 2) = result;
        return result;
      }
    }
    uint64_t v9 = *((void *)v1 + 1);
    uint64_t v3 = *((void *)v1 + 2) - 32;
    *((void *)v1 + 2) = v3;
    if (v9 != v3) {
      continue;
    }
    break;
  }
  return result;
}

uint64_t sub_1CD482194(uint64_t a1)
{
  return *(void *)a1;
}

char **sub_1CD48219C(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 48 * v3;
    do
    {
      uint64_t v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5) {
        free(v5);
      }
      v4 -= 48;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

_OWORD *sub_1CD482214(int *a1, uint64_t a2)
{
  uint64_t v14 = a2;
  int v4 = *a1 + 1;
  *a1 = v4;
  *((_DWORD *)sub_1CD40EB18((uint64_t)(a1 + 2), &v14) + 2) = v4;
  uint64_t v5 = (uint64_t *)*((void *)a1 + 5);
  if ((unint64_t)v5 >= *((void *)a1 + 6))
  {
    char v6 = sub_1CBF63C18((void **)a1 + 4, a2);
  }
  else
  {
    *uint64_t v5 = a2;
    char v6 = v5 + 1;
  }
  *((void *)a1 + 5) = v6;
  uint64_t v7 = *(void *)(a2 + 32);
  int v8 = *a1;
  *(void *)&long long v12 = a2;
  *((void *)&v12 + 1) = v7;
  *(void *)&long long v13 = sub_1CD482194;
  DWORD2(v13) = v8;
  uint64_t v9 = (_OWORD *)*((void *)a1 + 11);
  if ((unint64_t)v9 >= *((void *)a1 + 12))
  {
    uint64_t result = sub_1CBF833E4((void **)a1 + 10, &v12);
  }
  else
  {
    long long v10 = v13;
    *uint64_t v9 = v12;
    v9[1] = v10;
    uint64_t result = v9 + 2;
  }
  *((void *)a1 + 11) = result;
  return result;
}

void *sub_1CD4822D8(void *result)
{
  v1 = (void **)(result + 7);
  result[8] = result[7];
  if (result[10] != result[11])
  {
    uint64_t v2 = result;
    uint64_t v3 = (uint64_t)(result + 1);
    while (1)
    {
      sub_1CD4823E8((uint64_t)v2);
      uint64_t v5 = v2[10];
      uint64_t v4 = v2[11];
      uint64_t v6 = *(void *)(v4 - 32);
      uint64_t v10 = v6;
      unsigned int v7 = *(_DWORD *)(v4 - 8);
      v2[11] = v4 - 32;
      if (v5 != v4 - 32 && *(_DWORD *)(v4 - 40) > v7) {
        *(_DWORD *)(v4 - 40) = v7;
      }
      uint64_t result = sub_1CD40EB18(v3, &v10);
      if (v7 == *((_DWORD *)result + 2)) {
        break;
      }
      if (v2[10] == v2[11]) {
        return result;
      }
    }
    uint64_t result = (void *)v2[8];
    do
    {
      uint64_t v8 = *(void *)(v2[5] - 8);
      if ((unint64_t)result >= v2[9])
      {
        uint64_t v9 = sub_1CBF63C18(v1, v8);
      }
      else
      {
        *uint64_t result = v8;
        uint64_t v9 = result + 1;
      }
      v2[8] = v9;
      v2[5] -= 8;
      *((_DWORD *)sub_1CD40EB18(v3, v9 - 1) + 2) = -1;
      uint64_t result = (void *)v2[8];
    }
    while (*(result - 1) != v6);
  }
  return result;
}

uint64_t sub_1CD4823E8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 88);
  uint64_t v2 = *(void **)(v1 - 24);
  if (v2 != *(void **)(*(void *)(v1 - 32) + 40))
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = *(uint64_t (**)(void))(v1 - 16);
      *(void *)(v1 - 24) = v2 + 1;
      uint64_t v5 = v4(*v2);
      uint64_t v8 = 0;
      uint64_t result = sub_1CD40EA84(*(void *)(v3 + 8), *(_DWORD *)(v3 + 24), v5, &v8);
      if (result) {
        BOOL v6 = v8 == *(void *)(v3 + 8) + 16 * *(unsigned int *)(v3 + 24);
      }
      else {
        BOOL v6 = 1;
      }
      if (v6)
      {
        uint64_t result = (uint64_t)sub_1CD482214((int *)v3, v5);
        uint64_t v1 = *(void *)(v3 + 88);
      }
      else
      {
        unsigned int v7 = *(_DWORD *)(v8 + 8);
        uint64_t v1 = *(void *)(v3 + 88);
        if (*(_DWORD *)(v1 - 8) > v7) {
          *(_DWORD *)(v1 - 8) = v7;
        }
      }
      uint64_t v2 = *(void **)(v1 - 24);
    }
    while (v2 != *(void **)(*(void *)(v1 - 32) + 40));
  }
  return result;
}

uint64_t sub_1CD4824B0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_1CBFCBCC4(a1 + 8, a2 + 8);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  sub_1CBFCBA2C((void *)(a1 + 32), *(const void **)(a2 + 32), *(void *)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = 0;
  sub_1CBFCBA2C((void *)(a1 + 56), *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  sub_1CBFCBD44((void *)(a1 + 80), *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 5);
  return a1;
}

BOOL sub_1CD482544(void *a1, void *a2)
{
  uint64_t v3 = a1[10];
  uint64_t v2 = a1[11];
  uint64_t v4 = a2[10];
  if (v2 - v3 != a2[11] - v4) {
    return 0;
  }
  while (v3 != v2)
  {
    if (*(void *)v3 != *(void *)v4
      || *(void *)(v3 + 8) != *(void *)(v4 + 8)
      || *(_DWORD *)(v3 + 24) != *(_DWORD *)(v4 + 24))
    {
      return 0;
    }
    v3 += 32;
    v4 += 32;
  }
  BOOL v6 = a1 + 7;
  uint64_t v5 = (const void *)a1[7];
  size_t v7 = v6[1] - (void)v5;
  uint64_t v9 = a2 + 7;
  uint64_t v8 = (const void *)a2[7];
  return v7 == v9[1] - (void)v8 && memcmp(v5, v8, v7) == 0;
}

void sub_1CD4825E0()
{
}

void sub_1CD4826A0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = 48 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x400000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CD41C56C((uint64_t)a2, v5);
      }
      v5 += 48;
      a2 += 6;
      v6 -= 48;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = 48 * v7;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 48);
        if ((void *)(v8 + v9 - 32) != v10) {
          free(v10);
        }
        v9 -= 48;
      }
      while (v9);
    }
  }
}

uint64_t *sub_1CD48275C(uint64_t *result, uint64_t *a2, void *a3, uint64_t a4, char a5)
{
  long long v11 = result;
  while (2)
  {
    long long v12 = a2 - 1;
LABEL_3:
    for (uint64_t i = 1 - a4; ; ++i)
    {
      uint64_t v14 = (char *)a2 - (char *)v11;
      unint64_t v15 = a2 - v11;
      if (!(!v6 & v5))
      {
        switch(v15)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v26 = *v11;
            uint64_t v27 = *a3 + 80;
            uint64_t v30 = *v12;
            unint64_t v28 = sub_1CD45F378(v27, &v30)[1];
            uint64_t v30 = v26;
            uint64_t result = sub_1CD45F378(v27, &v30);
            if (v28 < result[1])
            {
              uint64_t v29 = *v11;
              *long long v11 = *v12;
              *long long v12 = v29;
            }
            break;
          case 3uLL:
            uint64_t result = sub_1CBFE19F0(v11, v11 + 1, a2 - 1, a3);
            break;
          case 4uLL:
            uint64_t result = sub_1CBFE2234(v11, v11 + 1, v11 + 2, a2 - 1, a3);
            break;
          case 5uLL:
            uint64_t result = sub_1CBFE2380(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v14 <= 191)
      {
        if (a5)
        {
          return sub_1CBFE17C4(v11, a2, a3);
        }
        else
        {
          return sub_1CBFE18F0(v11, a2, a3);
        }
      }
      if (i == 1)
      {
        if (v11 != a2)
        {
          return sub_1CBFE2528(v11, a2, a2, a3);
        }
        return result;
      }
      unint64_t v16 = v15 >> 1;
      int v17 = &v11[v15 >> 1];
      if ((unint64_t)v14 >= 0x401)
      {
        sub_1CBFE19F0(v11, &v11[v15 >> 1], a2 - 1, a3);
        sub_1CBFE19F0(v11 + 1, v17 - 1, a2 - 2, a3);
        sub_1CBFE19F0(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
        sub_1CBFE19F0(v17 - 1, v17, &v11[v16 + 1], a3);
        uint64_t v18 = *v11;
        *long long v11 = *v17;
        uint64_t *v17 = v18;
      }
      else
      {
        sub_1CBFE19F0(&v11[v15 >> 1], v11, a2 - 1, a3);
      }
      if ((a5 & 1) == 0)
      {
        uint64_t v23 = *v11;
        uint64_t v24 = *a3 + 80;
        uint64_t v30 = *(v11 - 1);
        unint64_t v25 = sub_1CD45F378(v24, &v30)[1];
        uint64_t v30 = v23;
        if (v25 >= sub_1CD45F378(v24, &v30)[1])
        {
          uint64_t result = sub_1CBFE1BC0(v11, a2, a3);
          uint64_t v22 = result;
          goto LABEL_15;
        }
      }
      long long v19 = sub_1CBFE1DD8(v11, a2, a3);
      if ((v20 & 1) == 0) {
        goto LABEL_42;
      }
      BOOL v21 = sub_1CBFE1FCC(v11, v19, a3);
      uint64_t v22 = v19 + 1;
      uint64_t result = (uint64_t *)sub_1CBFE1FCC(v19 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v21)
      {
LABEL_42:
        a4 = -i;
        uint64_t result = (uint64_t *)sub_1CD48275C(v11, v19, a3, -i, a5 & 1);
        a5 = 0;
        long long v11 = v19 + 1;
        goto LABEL_3;
      }
LABEL_15:
      long long v11 = v22;
    }
    a4 = -i;
    a2 = v19;
    if (!v21) {
      continue;
    }
    return result;
  }
}

llvm::SmallPtrSetImplBase *sub_1CD482B64(llvm::SmallPtrSetImplBase *this, uint64_t *a2, uint64_t *a3)
{
  *(void *)this = (char *)this + 32;
  *((void *)this + 1) = (char *)this + 32;
  *((void *)this + 2) = 4;
  *((_DWORD *)this + 6) = 0;
  if (a2 != a3)
  {
    char v5 = a2;
    do
    {
      uint64_t v6 = *v5++;
      sub_1CB89694C(this, v6);
    }
    while (v5 != a3);
  }
  return this;
}

uint64_t sub_1CD482BCC(uint64_t result, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v4 = a2;
  if (a2 == a4)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = a2;
    do
    {
      ++v5;
      uint64_t v7 = v6 + 1;
      while (v7 != a3)
      {
        unint64_t v8 = *v7++;
        if (v8 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v6 = v7 - 1;
          goto LABEL_8;
        }
      }
      uint64_t v6 = a3;
LABEL_8:
      ;
    }
    while (v6 != a4);
  }
  uint64_t v9 = *(unsigned int *)(result + 8);
  if (v5 + v9 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a4)
  {
    uint64_t v10 = (unint64_t *)(*(void *)result + 8 * v9);
    do
    {
      unint64_t v12 = *v4;
      long long v11 = v4 + 1;
      unint64_t *v10 = v12;
      while (v11 != a3)
      {
        unint64_t v13 = *v11++;
        if (v13 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v4 = v11 - 1;
          goto LABEL_18;
        }
      }
      uint64_t v4 = a3;
LABEL_18:
      ++v10;
    }
    while (v4 != a4);
  }
  *(_DWORD *)(result + 8) = v9 + v5;
  return result;
}

void sub_1CD482CC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[24] = *MEMORY[0x1E4F143B8];
  sub_1CD482D9C((uint64_t)&v9, a2);
  sub_1CD482D9C((uint64_t)&v5, a3);
  sub_1CD482D9C(a1, (uint64_t)&v9);
  sub_1CD482D9C(a1 + 304, (uint64_t)&v5);
  if (v7 != &v8) {
    free(v7);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v11 != v12) {
    free(v11);
  }
  if (v10 != v9) {
    free(v10);
  }
}

uint64_t sub_1CD482D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)a2);
  *(void *)(v4 + 96) = v4 + 112;
  uint64_t v5 = v4 + 96;
  *(void *)(v5 + 8) = 0x800000000;
  if (*(_DWORD *)(a2 + 104)) {
    sub_1CD482DFC((char **)v5, (uint64_t **)(a2 + 96));
  }
  return a1;
}

char **sub_1CD482DFC(char **a1, uint64_t **a2)
{
  if (a1 != (char **)a2)
  {
    uint64_t v5 = (uint64_t *)(a2 + 2);
    uint64_t v4 = (char *)*a2;
    if (*a2 == (uint64_t *)(a2 + 2))
    {
      uint64_t v7 = a2 + 1;
      unsigned int v9 = *((_DWORD *)a2 + 2);
      uint64_t v10 = *((unsigned int *)a1 + 2);
      if (v10 >= v9)
      {
        if (v9)
        {
          unint64_t v12 = &v4[24 * v9];
          unint64_t v13 = *a1;
          do
          {
            *(void *)unint64_t v13 = *(void *)v4;
            *(_OWORD *)(v13 + 8) = *(_OWORD *)(v4 + 8);
            v4 += 24;
            v13 += 24;
          }
          while (v4 != v12);
        }
      }
      else
      {
        if (*((_DWORD *)a1 + 3) < v9)
        {
          *((_DWORD *)a1 + 2) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          uint64_t v14 = &v4[24 * v10];
          unint64_t v15 = *a1;
          do
          {
            *(void *)unint64_t v15 = *(void *)v4;
            *(_OWORD *)(v15 + 8) = *(_OWORD *)(v4 + 8);
            v4 += 24;
            v15 += 24;
          }
          while (v4 != v14);
        }
        else
        {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy(&(*a1)[24 * v10], &(*a2)[3 * v10], (char *)&(*a2)[3 * v11] - (char *)&(*a2)[3 * v10]);
        }
      }
      *((_DWORD *)a1 + 2) = v9;
    }
    else
    {
      uint64_t v6 = *a1;
      if (*a1 != (char *)(a1 + 2))
      {
        free(v6);
        uint64_t v4 = (char *)*a2;
      }
      *a1 = v4;
      uint64_t v7 = a2 + 1;
      a1[1] = (char *)a2[1];
      *a2 = v5;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

unint64_t sub_1CD482F54(unint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = a1 + 112;
  uint64_t v4 = (void *)(a1 + 96);
  *(void *)(a1 + 104) = 0x800000000;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  uint64_t v5 = *(void *)(a2 + 32);
  v10[0] = a2;
  v10[1] = v5;
  v10[2] = sub_1CD482194;
  unint64_t v6 = sub_1CD483108((uint64_t)v4, (unint64_t)v10);
  uint64_t v7 = *v4 + 24 * *(unsigned int *)(a1 + 104);
  long long v8 = *(_OWORD *)v6;
  *(void *)(v7 + 16) = *(void *)(v6 + 16);
  *(_OWORD *)uint64_t v7 = v8;
  ++*(_DWORD *)(a1 + 104);
  sub_1CD483018(a1);
  return a1;
}

unint64_t sub_1CD483018(unint64_t result)
{
  uint64_t v1 = (void *)(result + 96);
  uint64_t v2 = *(void *)(result + 96) + 24 * *(unsigned int *)(result + 104);
  uint64_t v3 = *(void **)(v2 - 16);
  if (v3 != *(void **)(*(void *)(v2 - 24) + 40))
  {
    unint64_t v4 = result;
    do
    {
      uint64_t v5 = *(uint64_t (**)(void))(v2 - 8);
      *(void *)(v2 - 16) = v3 + 1;
      uint64_t v6 = v5(*v3);
      uint64_t result = (unint64_t)sub_1CB89694C((llvm::SmallPtrSetImplBase *)v4, v6);
      if (v7)
      {
        uint64_t v9 = *(void *)(v6 + 32);
        v12[0] = v6;
        v12[1] = v9;
        v12[2] = sub_1CD482194;
        uint64_t result = sub_1CD483108((uint64_t)v1, (unint64_t)v12);
        uint64_t v10 = *(void *)(v4 + 96) + 24 * *(unsigned int *)(v4 + 104);
        long long v11 = *(_OWORD *)result;
        *(void *)(v10 + 16) = *(void *)(result + 16);
        *(_OWORD *)uint64_t v10 = v11;
        unsigned int v8 = *(_DWORD *)(v4 + 104) + 1;
        *(_DWORD *)(v4 + 104) = v8;
      }
      else
      {
        unsigned int v8 = *(_DWORD *)(v4 + 104);
      }
      uint64_t v2 = *v1 + 24 * v8;
      uint64_t v3 = *(void **)(v2 - 16);
    }
    while (v3 != *(void **)(*(void *)(v2 - 24) + 40));
  }
  return result;
}

unint64_t sub_1CD483108(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 24 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

const void **sub_1CD483184(const void **a1, llvm::SmallPtrSetImplBase *a2)
{
  unint64_t v4 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, a1 + 4, a2);
  *((void *)v4 + 12) = (char *)v4 + 112;
  uint64_t v5 = (uint64_t *)((char *)v4 + 96);
  v5[1] = 0x800000000;
  if (*((_DWORD *)a2 + 26)) {
    sub_1CD4831E0(v5, (uint64_t *)a2 + 12);
  }
  return a1;
}

uint64_t *sub_1CD4831E0(uint64_t *a1, uint64_t *a2)
{
  if (a1 != a2)
  {
    unsigned int v3 = *((_DWORD *)a2 + 2);
    uint64_t v4 = *((unsigned int *)a1 + 2);
    if (v4 >= v3)
    {
      if (v3)
      {
        uint64_t v6 = *a2;
        uint64_t v7 = *a2 + 24 * v3;
        uint64_t v8 = *a1;
        do
        {
          *(void *)uint64_t v8 = *(void *)v6;
          *(_OWORD *)(v8 + 8) = *(_OWORD *)(v6 + 8);
          v6 += 24;
          v8 += 24;
        }
        while (v6 != v7);
      }
    }
    else
    {
      if (*((_DWORD *)a1 + 3) < v3)
      {
        *((_DWORD *)a1 + 2) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4)
      {
        uint64_t v10 = *a2;
        uint64_t v11 = *a2 + 24 * v4;
        uint64_t v12 = *a1;
        do
        {
          *(void *)uint64_t v12 = *(void *)v10;
          *(_OWORD *)(v12 + 8) = *(_OWORD *)(v10 + 8);
          v10 += 24;
          v12 += 24;
        }
        while (v10 != v11);
      }
      else
      {
        uint64_t v4 = 0;
      }
      uint64_t v5 = *((unsigned int *)a2 + 2);
      if (v4 != v5) {
        memcpy((void *)(*a1 + 24 * v4), (const void *)(*a2 + 24 * v4), *a2 + 24 * v5 - (*a2 + 24 * v4));
      }
    }
    *((_DWORD *)a1 + 2) = v3;
  }
  return a1;
}

unsigned int *sub_1CD4832F4(unsigned int *result, uint64_t a2, uint64_t *__src, uint64_t *a4)
{
  uint64_t v5 = __src;
  uint64_t v6 = *(void *)result;
  uint64_t v7 = result[2];
  if (*(void *)result + 8 * v7 == a2)
  {
    return sub_1CD47792C(result, __src, a4);
  }
  else
  {
    uint64_t v8 = (a2 - v6) >> 3;
    unint64_t v9 = a4 - __src;
    if (v7 + v9 > result[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v10 = (void *)(v6 + 8 * v8);
    uint64_t v11 = (unsigned char *)(v6 + 8 * v7);
    unint64_t v12 = (v11 - (unsigned char *)v10) >> 3;
    if (v12 >= v9)
    {
      uint64_t result = (unsigned int *)sub_1CD4570C8((uint64_t)result, &v11[-8 * v9], (char *)(v6 + 8 * v7));
      if (&v11[-8 * v9] != (unsigned char *)v10) {
        uint64_t result = (unsigned int *)memmove(&v10[v9], v10, &v11[-8 * v9] - (unsigned char *)v10);
      }
      if (v5 != a4)
      {
        return (unsigned int *)memmove(v10, v5, (char *)a4 - (char *)v5);
      }
    }
    else
    {
      unsigned int v13 = v7 + ((unint64_t)((char *)a4 - (char *)__src) >> 3);
      result[2] = v13;
      if (v8 != v7)
      {
        uint64_t result = (unsigned int *)memcpy((void *)(v6 + 8 * v13 - 8 * v12), v10, v11 - (unsigned char *)v10);
        do
        {
          uint64_t v14 = *v5++;
          *v10++ = v14;
          --v12;
        }
        while (v12);
      }
      if (v5 != a4)
      {
        return (unsigned int *)memcpy(v11, v5, (char *)a4 - (char *)v5);
      }
    }
  }
  return result;
}

BOOL llvm::DivergenceAnalysisImpl::markDivergent(llvm::DivergenceAnalysisImpl *this, const llvm::Value *a2)
{
  uint64_t v8 = 0;
  v9[0] = a2;
  if (sub_1CBFE4194((uint64_t *)this + 9, v9, &v8))
  {
    uint64_t v4 = v8;
    uint64_t v5 = *((void *)this + 9);
    uint64_t v6 = *((unsigned int *)this + 22);
  }
  else
  {
    uint64_t v5 = *((void *)this + 9);
    uint64_t v6 = *((unsigned int *)this + 22);
    uint64_t v4 = (const llvm::Value *)(v5 + 8 * v6);
  }
  if (v4 != (const llvm::Value *)(v5 + 8 * v6)) {
    return 0;
  }
  uint64_t v8 = a2;
  sub_1CD48410C((uint64_t)this + 96, (uint64_t *)&v8, (uint64_t)v9);
  return v10 != 0;
}

BOOL llvm::DivergenceAnalysisImpl::inRegion(llvm::DivergenceAnalysisImpl *this, const llvm::Instruction *a2)
{
  uint64_t v2 = *((void *)a2 + 5);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    return *(void *)(v2 + 56) == *(void *)this;
  }
  uint64_t v4 = sub_1CB896AE8(v3 + 56, v2);
  uint64_t v5 = *(void *)(v3 + 64);
  uint64_t v6 = 72;
  if (v5 == *(void *)(v3 + 56)) {
    uint64_t v6 = 76;
  }
  return v4 != (void *)(v5 + 8 * *(unsigned int *)(v3 + v6));
}

BOOL llvm::DivergenceAnalysisImpl::isDivergent(llvm::DivergenceAnalysisImpl *this, const llvm::Value *a2)
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CBFE4194((uint64_t *)this + 12, &v8, &v7))
  {
    uint64_t v3 = v7;
    uint64_t v4 = *((void *)this + 12);
    uint64_t v5 = *((unsigned int *)this + 28);
  }
  else
  {
    uint64_t v4 = *((void *)this + 12);
    uint64_t v5 = *((unsigned int *)this + 28);
    uint64_t v3 = v4 + 8 * v5;
  }
  return v3 != v4 + 8 * v5;
}

void llvm::DivergenceAnalysisImpl::analyzeLoopExitDivergence(llvm::DivergenceAnalysisImpl *this, llvm::BasicBlock **a2, const llvm::Loop *a3)
{
  v23[8] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 64))
  {
    uint64_t v5 = llvm::BasicBlock::phis(a2);
    if (v5 != v6)
    {
      uint64_t v7 = v5;
      uint64_t v8 = v6;
      do
      {
        llvm::DivergenceAnalysisImpl::analyzeTemporalDivergence((uint64_t)this, (const llvm::Instruction *)v7, a3);
        uint64_t v9 = *((void *)v7 + 4);
        if (v9) {
          char v10 = (char *)(v9 - 24);
        }
        else {
          char v10 = 0;
        }
        if (v10[16] == 83) {
          uint64_t v7 = v10;
        }
        else {
          uint64_t v7 = 0;
        }
      }
      while (v7 != v8);
    }
  }
  else
  {
    BOOL v21 = v23;
    v23[0] = a2;
    uint64_t v22 = 0x800000001;
    v18[0] = 0;
    v18[1] = 0;
    int v19 = 0;
    int v17 = a2;
    sub_1CD4201D0((uint64_t)v18, &v17, (uint64_t)v20);
    unsigned int v11 = v22;
    do
    {
      uint64_t v12 = *((void *)v21 + v11 - 1);
      LODWORD(v22) = v11 - 1;
      uint64_t v13 = *((void *)this + 1);
      if (v13)
      {
        uint64_t v14 = sub_1CB896AE8(v13 + 56, v12);
        uint64_t v15 = *(void *)(v13 + 64);
        if (v15 == *(void *)(v13 + 56)) {
          uint64_t v16 = 76;
        }
        else {
          uint64_t v16 = 72;
        }
        if (v14 != (void *)(v15 + 8 * *(unsigned int *)(v13 + v16))) {
LABEL_18:
        }
          llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
      }
      else if (*(void *)(v12 + 56) == *(void *)this)
      {
        goto LABEL_18;
      }
      unsigned int v11 = v22;
    }
    while (v22);
    MEMORY[0x1D25D9CD0](v18[0], 8);
    if (v21 != v23) {
      free(v21);
    }
  }
}

void llvm::DivergenceAnalysisImpl::propagateLoopExitDivergence(llvm::DivergenceAnalysisImpl *this, llvm::BasicBlock **a2, const llvm::Loop *a3)
{
  uint64_t v3 = a3;
  unsigned int v11 = a3;
  uint64_t v12 = 0;
  uint64_t v6 = (uint64_t *)*((void *)this + 3);
  v13[0] = a2;
  if ((sub_1CB834D78(v6, v13, &v12) & 1) != 0 && (uint64_t v7 = *(void **)(v12 + 8)) != 0)
  {
    unsigned int v8 = 0;
    do
    {
      uint64_t v7 = (void *)*v7;
      ++v8;
    }
    while (v7);
  }
  else
  {
    unsigned int v8 = 0;
  }
  uint64_t v9 = v3;
  do
  {
    unsigned int v10 = 0;
    do
    {
      uint64_t v9 = *(const llvm::Loop **)v9;
      ++v10;
    }
    while (v9);
    if (v10 <= v8) {
      break;
    }
    sub_1CD484194((uint64_t)v13, (uint64_t)this + 32, &v11);
    uint64_t v3 = v11;
    uint64_t v9 = *(const llvm::Loop **)v11;
    unsigned int v11 = v9;
  }
  while (v9);
  llvm::DivergenceAnalysisImpl::analyzeLoopExitDivergence(this, a2, v3);
}

uint64_t llvm::DivergenceAnalysisImpl::taintAndPushPhiNodes(uint64_t this, const llvm::BasicBlock *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void *)(this + 8);
  if (!v4)
  {
    if (*((void *)a2 + 7) != *(void *)this) {
      return this;
    }
    goto LABEL_5;
  }
  this = (uint64_t)sub_1CB896AE8(v4 + 56, (uint64_t)a2);
  uint64_t v5 = *(void *)(v4 + 64);
  uint64_t v6 = 72;
  if (v5 == *(void *)(v4 + 56)) {
    uint64_t v6 = 76;
  }
  if (this != v5 + 8 * *(unsigned int *)(v4 + v6))
  {
LABEL_5:
    this = (uint64_t)llvm::BasicBlock::phis((llvm::BasicBlock **)a2);
    if ((llvm::PHINode *)this != v7)
    {
      unsigned int v8 = (llvm::PHINode *)this;
      uint64_t v9 = v7;
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = v8;
        this = sub_1CBFE4194((uint64_t *)(v3 + 96), &v18, &v17);
        if (this)
        {
          uint64_t v10 = v17;
          uint64_t v11 = *(void *)(v3 + 96);
          uint64_t v12 = *(unsigned int *)(v3 + 112);
        }
        else
        {
          uint64_t v11 = *(void *)(v3 + 96);
          uint64_t v12 = *(unsigned int *)(v3 + 112);
          uint64_t v10 = v11 + 8 * v12;
        }
        if (v10 == v11 + 8 * v12)
        {
          this = llvm::PHINode::hasConstantOrUndefValue(v8);
          if ((this & 1) == 0)
          {
            this = llvm::DivergenceAnalysisImpl::markDivergent((llvm::DivergenceAnalysisImpl *)v3, v8);
            if (this)
            {
              uint64_t v16 = *(llvm::PHINode ***)(v3 + 128);
              if ((unint64_t)v16 >= *(void *)(v3 + 136))
              {
                this = (uint64_t)sub_1CBF63C18((void **)(v3 + 120), (uint64_t)v8);
              }
              else
              {
                *uint64_t v16 = v8;
                this = (uint64_t)(v16 + 1);
              }
              *(void *)(v3 + 128) = this;
            }
          }
        }
        uint64_t v13 = (char *)v8 + 24;
        if (!v8) {
          uint64_t v13 = 0;
        }
        uint64_t v14 = *((void *)v13 + 1);
        if (v14) {
          uint64_t v15 = (llvm::PHINode *)(v14 - 24);
        }
        else {
          uint64_t v15 = 0;
        }
        if (*((unsigned char *)v15 + 16) == 83) {
          unsigned int v8 = v15;
        }
        else {
          unsigned int v8 = 0;
        }
      }
      while (v8 != v9);
    }
  }
  return this;
}

uint64_t llvm::DivergenceAnalysisImpl::compute(llvm::DivergenceAnalysisImpl *this)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  sub_1CBFCB9AC((uint64_t)&v10, (uint64_t)this + 96);
  uint64_t v2 = &v10[v12];
  if (v11)
  {
    if (v12)
    {
      uint64_t v3 = 8 * v12;
      uint64_t v4 = v10;
      while (((unint64_t)*v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v4;
        v3 -= 8;
        if (!v3) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v4 = v10;
    }
  }
  else
  {
LABEL_6:
    uint64_t v4 = &v10[v12];
  }
  uint64_t v5 = &v10[v12];
LABEL_8:
  while (v4 != v5)
  {
    uint64_t v6 = v4 + 1;
    llvm::DivergenceAnalysisImpl::pushUsers(this, *v4);
    uint64_t v4 = v2;
    if (v6 != v2)
    {
      uint64_t v4 = v6;
      while (((unint64_t)*v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (++v4 == v2)
        {
          uint64_t v4 = v2;
          goto LABEL_8;
        }
      }
    }
  }
  while (1)
  {
    uint64_t v8 = *((void *)this + 16);
    if (*((void *)this + 15) == v8) {
      break;
    }
    uint64_t v7 = *(const llvm::Value **)(v8 - 8);
    *((void *)this + 16) = v8 - 8;
    llvm::DivergenceAnalysisImpl::pushUsers(this, v7);
  }
  return MEMORY[0x1D25D9CD0](v10, 8);
}

llvm::DivergenceInfo *llvm::DivergenceInfo::DivergenceInfo(llvm::DivergenceInfo *this, llvm::Function *a2, const llvm::DominatorTree *a3, const llvm::PostDominatorTree *a4, const llvm::LoopInfo *a5, const llvm::TargetTransformInfo *a6, char a7)
{
  *(void *)this = a2;
  *((unsigned char *)this + 8) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  if (a7) {
    goto LABEL_8;
  }
  unsigned int v12 = a2;
  __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  sub_1CBF8C36C((char **)&__p, (uint64_t)&v12);
  int v9 = sub_1CBFE347C(&__p, (uint64_t *)a5);
  char v10 = v9;
  if (v9) {
    *((unsigned char *)this + 8) = 1;
  }
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }
  if ((v10 & 1) == 0) {
LABEL_8:
  }
    operator new();
  return this;
}

void llvm::DivergenceAnalysis::run()
{
}

BOOL sub_1CD483FA8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8)) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CBFE4194((uint64_t *)(v3 + 96), &v8, &v7))
  {
    uint64_t v4 = v7;
    uint64_t v5 = *(void *)(v3 + 96);
    uint64_t v6 = *(unsigned int *)(v3 + 112);
  }
  else
  {
    uint64_t v5 = *(void *)(v3 + 96);
    uint64_t v6 = *(unsigned int *)(v3 + 112);
    uint64_t v4 = v5 + 8 * v6;
  }
  return v4 != v5 + 8 * v6;
}

void *sub_1CD484020(void *a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = (void *)a1[11];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[5];
  if (v4 == a1 + 2)
  {
    (*(void (**)(void *))(a1[2] + 32))(a1 + 2);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  return a1;
}

uint64_t sub_1CD48410C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  char v10 = 0;
  uint64_t result = sub_1CBFE4194((uint64_t *)a1, a2, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBFE4230(a1, (uint64_t)a2, a2, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD484194(uint64_t a1, uint64_t a2, void *a3)
{
  char v10 = 0;
  uint64_t result = sub_1CD420258((uint64_t *)a2, a3, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4202F4(a2, (uint64_t)a3, a3, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

void *sub_1CD484224(void *a1)
{
  uint64_t v2 = (void *)a1[15];
  if (v2)
  {
    a1[16] = v2;
    operator delete(v2);
  }
  MEMORY[0x1D25D9CD0](a1[12], 8);
  MEMORY[0x1D25D9CD0](a1[9], 8);
  MEMORY[0x1D25D9CD0](a1[4], 8);
  return a1;
}

uint64_t sub_1CD48427C(uint64_t result)
{
  uint64_t v1 = *(void *)result;
  if (*(void *)result != *(void *)(result + 8))
  {
    uint64_t v2 = (void *)result;
    while (1)
    {
      uint64_t v3 = v2[5];
      if (!v3) {
        break;
      }
      if (v1) {
        uint64_t v4 = v1 - 24;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 48))(v3, v4);
      if ((result & 1) == 0)
      {
        uint64_t v5 = v2[1];
        uint64_t v1 = *(void *)(*v2 + 8);
        void *v2 = v1;
        if (v1 != v5) {
          continue;
        }
      }
      return result;
    }
    sub_1CB920400();
    return llvm::DomTreePrinterPass::run();
  }
  return result;
}

void llvm::DomTreePrinterPass::run()
{
}

void sub_1CD4843B8(llvm::Value *a1, llvm::raw_ostream *a2, const void **a3, char a4)
{
  sub_1CBAD7600(".", a3, (void **)&__p.__r_.__value_.__l.__data_);
  Name = llvm::Value::getName(a1);
  if (Name)
  {
    std::string::__init(&v50, Name, v7);
    LOBYTE(Name) = *((unsigned char *)&v50.__r_.__value_.__s + 23);
    std::string::size_type size = v50.__r_.__value_.__l.__size_;
    std::string::size_type v10 = v50.__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type size = 0;
    std::string::size_type v10 = 0;
    memset(&v50, 0, sizeof(v50));
  }
  BOOL v11 = (char)Name < 0;
  if ((char)Name >= 0) {
    unsigned int v12 = &v50;
  }
  else {
    unsigned int v12 = (std::string *)v10;
  }
  std::string::size_type v13 = Name & 0x7F;
  if (v11) {
    std::string::size_type v14 = size;
  }
  else {
    std::string::size_type v14 = v13;
  }
  uint64_t v15 = std::string::append(&__p, (const std::string::value_type *)v12, v14);
  std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = std::string::append(&v48, ".dot");
  std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
  long long v51 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  uint64_t v52 = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  v49[0] = 0;
  int v19 = (llvm *)std::system_category();
  char v20 = (llvm::raw_ostream *)llvm::errs(v19);
  BOOL v21 = sub_1CB8E509C(v20, "Writing '");
  if (v52 >= 0) {
    uint64_t v22 = (const char *)&v51;
  }
  else {
    uint64_t v22 = (const char *)v51;
  }
  if (v52 >= 0) {
    size_t v23 = HIBYTE(v52) & 0x7F;
  }
  else {
    size_t v23 = *((void *)&v51 + 1);
  }
  uint64_t v24 = llvm::raw_ostream::write(v21, v22, v23);
  sub_1CB8E509C(v24, "'...");
  if (v52 >= 0) {
    unint64_t v25 = &v51;
  }
  else {
    unint64_t v25 = (long long *)v51;
  }
  if (v52 >= 0) {
    uint64_t v26 = HIBYTE(v52) & 0x7F;
  }
  else {
    uint64_t v26 = *((void *)&v51 + 1);
  }
  llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)&v48, v25, v26, (uint64_t)v49, 3);
  *((unsigned char *)&v50.__r_.__value_.__s + 23) = 14;
  strcpy((char *)&v50, "Dominator tree");
  sub_1CBAD7600(" for '", (const void **)&v50.__r_.__value_.__l.__data_, (void **)&v45.__r_.__value_.__l.__data_);
  unint64_t v28 = llvm::Value::getName(a1);
  if (v28)
  {
    std::string::__init(&v44, v28, v27);
    LOBYTE(v28) = *((unsigned char *)&v44.__r_.__value_.__s + 23);
    std::string::size_type v29 = v44.__r_.__value_.__l.__size_;
    std::string::size_type v30 = v44.__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type v29 = 0;
    std::string::size_type v30 = 0;
    memset(&v44, 0, sizeof(v44));
  }
  BOOL v31 = (char)v28 < 0;
  if ((char)v28 >= 0) {
    uint64_t v32 = &v44;
  }
  else {
    uint64_t v32 = (std::string *)v30;
  }
  std::string::size_type v33 = v28 & 0x7F;
  if (v31) {
    std::string::size_type v34 = v29;
  }
  else {
    std::string::size_type v34 = v33;
  }
  int v35 = std::string::append(&v45, (const std::string::value_type *)v32, v34);
  std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  uint64_t v37 = std::string::append(&__p, "' function");
  std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)v46 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  std::string::size_type v47 = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  if (v49[0])
  {
    uint64_t v40 = (llvm::raw_ostream *)llvm::errs((llvm *)v37);
    uint64_t v39 = sub_1CB8E509C(v40, "  error opening file for writing!");
  }
  else
  {
    __int16 v43 = 260;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v46;
    uint64_t v39 = sub_1CD484984((llvm::raw_ostream *)&v48, a2, a4, (llvm::Twine *)&__p);
  }
  uint64_t v41 = (llvm::raw_ostream *)llvm::errs(v39);
  sub_1CB8E509C(v41, "\n");
  if (SHIBYTE(v47) < 0) {
    operator delete(v46[0]);
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v48);
  if (SHIBYTE(v52) < 0) {
    operator delete((void *)v51);
  }
}

void llvm::DomTreeOnlyPrinterPass::run()
{
}

void llvm::createDomPrinterPass(llvm *this)
{
}

void llvm::createDomOnlyPrinterPass(llvm *this)
{
}

void llvm::createDomViewerPass(llvm *this)
{
}

void llvm::createDomOnlyViewerPass(llvm *this)
{
}

void llvm::createPostDomPrinterPass(llvm *this)
{
}

void llvm::createPostDomOnlyPrinterPass(llvm *this)
{
}

void llvm::createPostDomViewerPass(llvm *this)
{
}

void llvm::createPostDomOnlyViewerPass(llvm *this)
{
}

llvm::raw_ostream *sub_1CD484984(llvm::raw_ostream *a1, llvm::raw_ostream *a2, char a3, llvm::Twine *this)
{
  v8[0] = a1;
  v8[1] = a2;
  char v10 = a3;
  char v9 = 0;
  llvm::Twine::str(this, __p);
  sub_1CD4849FC(v8, (uint64_t)__p);
  sub_1CD484C10((uint64_t)v8);
  sub_1CB8E509C(a1, "}\n");
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1CD4849FC(llvm::raw_ostream **a1, uint64_t a2)
{
  char v28 = 14;
  strcpy((char *)v27, "Dominator tree");
  char v4 = *(unsigned char *)(a2 + 23);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  char v8 = sub_1CB8E509C(*a1, "digraph \"");
  if (v7) {
    char v9 = (char *)a2;
  }
  else {
    char v9 = (char *)v27;
  }
  llvm::DOT::EscapeString(v9, (uint64_t)&__p);
  if (v26 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  if (v26 >= 0) {
    size_t v11 = v26 & 0x7F;
  }
  else {
    size_t v11 = v25;
  }
  unsigned int v12 = llvm::raw_ostream::write(v8, p_p, v11);
  sub_1CB8E509C(v12, "\" {\n");
  if (v26 < 0) {
    operator delete(__p);
  }
  char v13 = *(unsigned char *)(a2 + 23);
  int v14 = v13;
  uint64_t v15 = v13 & 0x7F;
  if (v14 < 0) {
    uint64_t v15 = *(void *)(a2 + 8);
  }
  if (v15)
  {
    std::string::size_type v16 = sub_1CB8E509C(*a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)a2, (uint64_t)&__p);
    if (v26 >= 0) {
      uint64_t v17 = (const char *)&__p;
    }
    else {
      uint64_t v17 = (const char *)__p;
    }
    if (v26 >= 0) {
      size_t v18 = v26 & 0x7F;
    }
    else {
      size_t v18 = v25;
    }
    int v19 = v16;
    goto LABEL_24;
  }
  uint64_t v22 = (void *)(v28 & 0x7F);
  if (v28 < 0) {
    uint64_t v22 = v27[1];
  }
  if (v22)
  {
    size_t v23 = sub_1CB8E509C(*a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)v27, (uint64_t)&__p);
    if (v26 >= 0) {
      uint64_t v17 = (const char *)&__p;
    }
    else {
      uint64_t v17 = (const char *)__p;
    }
    if (v26 >= 0) {
      size_t v18 = v26 & 0x7F;
    }
    else {
      size_t v18 = v25;
    }
    int v19 = v23;
LABEL_24:
    char v20 = llvm::raw_ostream::write(v19, v17, v18);
    sub_1CB8E509C(v20, "\";\n");
    if (v26 < 0) {
      operator delete(__p);
    }
  }
  BOOL v21 = *a1;
  char v26 = 0;
  LOBYTE(__p) = 0;
  llvm::raw_ostream::write(v21, (const char *)&__p, 0);
  if (v26 < 0) {
    operator delete(__p);
  }
  sub_1CB8E509C(*a1, "\n");
  if (v28 < 0) {
    operator delete(v27[0]);
  }
}

void sub_1CD484C10(uint64_t a1)
{
  sub_1CD484DE8(*(void *)(a1 + 8), (uint64_t)&v19);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v13, &v15, (const llvm::SmallPtrSetImplBase *)&v19);
  std::string __p = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_1CBF340A8(&__p, v21, v22, 0xAAAAAAAAAAAAAAABLL * ((v22 - (unsigned char *)v21) >> 3));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v7, &v9, (const llvm::SmallPtrSetImplBase *)&v23);
  char v10 = 0;
  size_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CBF340A8(&v10, v25, v26, 0xAAAAAAAAAAAAAAABLL * ((v26 - (unsigned char *)v25) >> 3));
  while (1)
  {
    if (v17 - (unsigned char *)__p != v11 - v10) {
      goto LABEL_16;
    }
    if (__p == v17) {
      break;
    }
    uint64_t v2 = v10 + 8;
    uint64_t v3 = (char *)__p + 8;
    while (1)
    {
      char v4 = v3 - 8;
      if (*((void *)v3 - 1) != *((void *)v2 - 1)) {
        break;
      }
      int v5 = v2[8];
      if (v3[8]) {
        BOOL v6 = v5 == 0;
      }
      else {
        BOOL v6 = 1;
      }
      if (v6)
      {
        if ((v3[8] == 0) == (v5 != 0)) {
          break;
        }
      }
      else if (*(void *)v3 != *(void *)v2)
      {
        break;
      }
      v2 += 24;
      v3 += 24;
      if (v4 + 24 == v17) {
        goto LABEL_17;
      }
    }
LABEL_16:
    sub_1CBFE5D4C(a1, *((void *)v17 - 3));
    sub_1CBFE66A8((llvm::SmallPtrSetImplBase *)&v13);
  }
LABEL_17:
  if (v10)
  {
    size_t v11 = v10;
    operator delete(v10);
  }
  if (v8 != v7) {
    free(v8);
  }
  if (__p)
  {
    uint64_t v17 = (char *)__p;
    operator delete(__p);
  }
  if (v14 != v13) {
    free(v14);
  }
  if (v25)
  {
    char v26 = v25;
    operator delete(v25);
  }
  if (v24 != v23) {
    free(v24);
  }
  if (v21)
  {
    uint64_t v22 = v21;
    operator delete(v21);
  }
  if (v20 != v19) {
    free(v20);
  }
}

void sub_1CD484DE8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 48);
  char v13 = v17;
  int v14 = v17;
  int v16 = 0;
  uint64_t v15 = 0x100000008;
  v17[0] = v3;
  char v4 = (char *)operator new(0x18uLL);
  *(void *)char v4 = v3;
  v4[8] = 0;
  v4[16] = 0;
  int v19 = v4 + 24;
  char v20 = v4 + 24;
  uint64_t v18 = v4;
  memset(v8, 0, sizeof(v8));
  uint64_t v9 = 0;
  std::string __p = 0;
  int v5 = (char *)v8 + 8;
  BOOL v6 = (char *)v8 + 8;
  uint64_t v7 = 8;
  size_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CBFE63FC((uint64_t)&v13, (uint64_t)&v5, a2);
  if (__p)
  {
    size_t v11 = __p;
    operator delete(__p);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v18)
  {
    int v19 = v18;
    operator delete(v18);
  }
  if (v14 != v13) {
    free(v14);
  }
}

void sub_1CD484EE4(llvm::raw_ostream **a1, unint64_t a2, unint64_t a3)
{
  if (a3)
  {
    uint64_t v7 = v3;
    uint64_t v8 = v4;
    char v6 = 0;
    LOBYTE(__p) = 0;
    sub_1CD460084(a1, a2, a3, (uint64_t)&__p);
    if (v6 < 0) {
      operator delete(__p);
    }
  }
}

void sub_1CD484F2C(uint64_t a1, unsigned char *a2, llvm::Value *a3)
{
  if (a3)
  {
    if (*a2)
    {
      sub_1CD465460(a3, (std::string *)a1);
    }
    else
    {
      sub_1CBF94B54(a3, (void (*)(uint64_t, void **, llvm::Value *))sub_1CD4655AC, (uint64_t)&v5, (void (*)(uint64_t, uint64_t, unsigned int *, std::string::size_type))sub_1CD4655B8, (uint64_t)sub_1CD465570, a1);
    }
  }
  else
  {
    uint64_t v4 = (char *)operator new(0x20uLL);
    *(void *)a1 = v4;
    *(_OWORD *)(a1 + 8) = xmmword_1CD91A410;
    strcpy(v4, "Post dominance root node");
  }
}

void sub_1CD48500C(llvm::raw_ostream *a1, llvm::Twine *this, char a3, llvm::Twine *a4)
{
  char v8 = 0;
  LOBYTE(__p) = 0;
  sub_1CBFE76A8((uint64_t)v9, a1, this, a3, a4, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
  char v4 = v10;
  if (v10 >= 0) {
    std::string::size_type v5 = v10 & 0x7F;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v9[1];
  }
  if (v5)
  {
    if (v10 >= 0) {
      char v6 = v9;
    }
    else {
      char v6 = (void **)v9[0];
    }
    llvm::DisplayGraph((std::string::value_type *)v6, v5, 0, 0);
    char v4 = v10;
  }
  if (v4 < 0) {
    operator delete(v9[0]);
  }
}

llvm::raw_ostream *sub_1CD4850A4(llvm::raw_ostream *a1, llvm::raw_ostream *a2, char a3, llvm::Twine *this)
{
  v8[0] = a1;
  v8[1] = a2;
  char v10 = a3;
  char v9 = 0;
  llvm::Twine::str(this, __p);
  sub_1CD48511C(v8, (uint64_t)__p);
  sub_1CD485334((uint64_t)v8);
  sub_1CB8E509C(a1, "}\n");
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1CD48511C(llvm::raw_ostream **a1, uint64_t a2)
{
  HIBYTE(v27[2]) = 19;
  strcpy((char *)v27, "Post dominator tree");
  char v4 = *(unsigned char *)(a2 + 23);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  char v8 = sub_1CB8E509C(*a1, "digraph \"");
  if (v7) {
    char v9 = (char *)a2;
  }
  else {
    char v9 = (char *)v27;
  }
  llvm::DOT::EscapeString(v9, (uint64_t)&__p);
  if (v26 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  if (v26 >= 0) {
    size_t v11 = v26 & 0x7F;
  }
  else {
    size_t v11 = v25;
  }
  uint64_t v12 = llvm::raw_ostream::write(v8, p_p, v11);
  sub_1CB8E509C(v12, "\" {\n");
  if (v26 < 0) {
    operator delete(__p);
  }
  char v13 = *(unsigned char *)(a2 + 23);
  int v14 = v13;
  uint64_t v15 = v13 & 0x7F;
  if (v14 < 0) {
    uint64_t v15 = *(void *)(a2 + 8);
  }
  if (v15)
  {
    int v16 = sub_1CB8E509C(*a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)a2, (uint64_t)&__p);
    if (v26 >= 0) {
      uint64_t v17 = (const char *)&__p;
    }
    else {
      uint64_t v17 = (const char *)__p;
    }
    if (v26 >= 0) {
      size_t v18 = v26 & 0x7F;
    }
    else {
      size_t v18 = v25;
    }
    int v19 = v16;
    goto LABEL_24;
  }
  uint64_t v22 = (void *)(HIBYTE(v27[2]) & 0x7F);
  if (SHIBYTE(v27[2]) < 0) {
    uint64_t v22 = v27[1];
  }
  if (v22)
  {
    size_t v23 = sub_1CB8E509C(*a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)v27, (uint64_t)&__p);
    if (v26 >= 0) {
      uint64_t v17 = (const char *)&__p;
    }
    else {
      uint64_t v17 = (const char *)__p;
    }
    if (v26 >= 0) {
      size_t v18 = v26 & 0x7F;
    }
    else {
      size_t v18 = v25;
    }
    int v19 = v23;
LABEL_24:
    char v20 = llvm::raw_ostream::write(v19, v17, v18);
    sub_1CB8E509C(v20, "\";\n");
    if (v26 < 0) {
      operator delete(__p);
    }
  }
  BOOL v21 = *a1;
  char v26 = 0;
  LOBYTE(__p) = 0;
  llvm::raw_ostream::write(v21, (const char *)&__p, 0);
  if (v26 < 0) {
    operator delete(__p);
  }
  sub_1CB8E509C(*a1, "\n");
  if (SHIBYTE(v27[2]) < 0) {
    operator delete(v27[0]);
  }
}

void sub_1CD485334(uint64_t a1)
{
  sub_1CD485514((uint64_t)&v19, *(void *)(**(void **)(a1 + 8) + 72));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v13, &v15, (const llvm::SmallPtrSetImplBase *)&v19);
  std::string __p = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_1CBF340A8(&__p, v21, v22, 0xAAAAAAAAAAAAAAABLL * ((v22 - (unsigned char *)v21) >> 3));
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v7, &v9, (const llvm::SmallPtrSetImplBase *)&v23);
  char v10 = 0;
  size_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CBF340A8(&v10, v25, v26, 0xAAAAAAAAAAAAAAABLL * ((v26 - (unsigned char *)v25) >> 3));
  while (1)
  {
    if (v17 - (unsigned char *)__p != v11 - v10) {
      goto LABEL_16;
    }
    if (__p == v17) {
      break;
    }
    uint64_t v2 = v10 + 8;
    uint64_t v3 = (char *)__p + 8;
    while (1)
    {
      char v4 = v3 - 8;
      if (*((void *)v3 - 1) != *((void *)v2 - 1)) {
        break;
      }
      int v5 = v2[8];
      if (v3[8]) {
        BOOL v6 = v5 == 0;
      }
      else {
        BOOL v6 = 1;
      }
      if (v6)
      {
        if ((v3[8] == 0) == (v5 != 0)) {
          break;
        }
      }
      else if (*(void *)v3 != *(void *)v2)
      {
        break;
      }
      v2 += 24;
      v3 += 24;
      if (v4 + 24 == v17) {
        goto LABEL_17;
      }
    }
LABEL_16:
    sub_1CBFE5D4C(a1, *((void *)v17 - 3));
    sub_1CBFE66A8((llvm::SmallPtrSetImplBase *)&v13);
  }
LABEL_17:
  if (v10)
  {
    size_t v11 = v10;
    operator delete(v10);
  }
  if (v8 != v7) {
    free(v8);
  }
  if (__p)
  {
    uint64_t v17 = (char *)__p;
    operator delete(__p);
  }
  if (v14 != v13) {
    free(v14);
  }
  if (v25)
  {
    char v26 = v25;
    operator delete(v25);
  }
  if (v24 != v23) {
    free(v24);
  }
  if (v21)
  {
    uint64_t v22 = v21;
    operator delete(v21);
  }
  if (v20 != v19) {
    free(v20);
  }
}

void sub_1CD485514(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    v19[1] = a2;
    char v4 = (char *)operator new(0x18uLL);
    *(void *)char v4 = a2;
    int v5 = v4 + 24;
    v4[8] = 0;
    v4[16] = 0;
    int v6 = 1;
  }
  else
  {
    int v6 = 0;
    char v4 = 0;
    int v5 = 0;
    memset(v19, 0, sizeof(v19));
  }
  uint64_t v15 = &v19[1];
  int v16 = &v19[1];
  int v17 = 8;
  int v18 = v6;
  LODWORD(v19[0]) = 0;
  char v20 = v4;
  BOOL v21 = v5;
  uint64_t v22 = v5;
  memset(v10, 0, sizeof(v10));
  uint64_t v11 = 0;
  std::string __p = 0;
  uint64_t v7 = (char *)v10 + 8;
  char v8 = (char *)v10 + 8;
  uint64_t v9 = 8;
  char v13 = 0;
  uint64_t v14 = 0;
  sub_1CBFE63FC((uint64_t)&v15, (uint64_t)&v7, a1);
  if (__p)
  {
    char v13 = __p;
    operator delete(__p);
  }
  if (v8 != v7) {
    free(v8);
  }
  if (v20)
  {
    BOOL v21 = v20;
    operator delete(v20);
  }
  if (v16 != v15) {
    free(v16);
  }
}

void sub_1CD48563C(llvm::raw_ostream *a1, llvm::Twine *this, char a3, llvm::Twine *a4)
{
  char v8 = 0;
  LOBYTE(__p) = 0;
  sub_1CBFE9544((uint64_t)v9, a1, this, a3, a4, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
  char v4 = v10;
  if (v10 >= 0) {
    std::string::size_type v5 = v10 & 0x7F;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v9[1];
  }
  if (v5)
  {
    if (v10 >= 0) {
      int v6 = v9;
    }
    else {
      int v6 = (void **)v9[0];
    }
    llvm::DisplayGraph((std::string::value_type *)v6, v5, 0, 0);
    char v4 = v10;
  }
  if (v4 < 0) {
    operator delete(v9[0]);
  }
}

uint64_t llvm::DomTreeUpdater::recalculate(llvm::DomTreeUpdater *this, llvm::Function *a2)
{
  if (*((unsigned char *)this + 304))
  {
    *((_WORD *)this + 216) = 257;
    llvm::DomTreeUpdater::forceFlushDeletedBB(this);
    uint64_t v4 = *((void *)this + 36);
    if (v4)
    {
      *(void *)(v4 + 56) = a2;
      llvm::DomTreeBuilder::Calculate<llvm::DominatorTreeBase<llvm::BasicBlock,false>>();
    }
    uint64_t v5 = *((void *)this + 37);
    if (v5)
    {
      *(void *)(v5 + 80) = a2;
      llvm::DomTreeBuilder::Calculate<llvm::DominatorTreeBase<llvm::BasicBlock,true>>();
    }
    *((_WORD *)this + 216) = 0;
    uint64_t v6 = *((unsigned int *)this + 2);
    *((void *)this + 34) = v6;
    *((void *)this + 35) = v6;
    return llvm::DomTreeUpdater::dropOutOfDateUpdates((uint64_t)this);
  }
  else
  {
    uint64_t v8 = *((void *)this + 36);
    if (v8)
    {
      *(void *)(v8 + 56) = a2;
      llvm::DomTreeBuilder::Calculate<llvm::DominatorTreeBase<llvm::BasicBlock,false>>();
    }
    uint64_t result = *((void *)this + 37);
    if (result)
    {
      *(void *)(result + 80) = a2;
      llvm::DomTreeBuilder::Calculate<llvm::DominatorTreeBase<llvm::BasicBlock,true>>();
    }
  }
  return result;
}

BOOL llvm::DomTreeUpdater::isBBPendingDeletion(llvm::DomTreeUpdater *this, llvm::BasicBlock *a2)
{
  if (!*((unsigned char *)this + 304) || *((_DWORD *)this + 83) == *((_DWORD *)this + 84)) {
    return 0;
  }
  uint64_t v4 = sub_1CB896AE8((uint64_t)this + 312, (uint64_t)a2);
  uint64_t v5 = *((void *)this + 40);
  uint64_t v6 = 328;
  if (v5 == *((void *)this + 39)) {
    uint64_t v6 = 332;
  }
  return v4 != (void *)(v5 + 8 * *(unsigned int *)((char *)this + v6));
}

void llvm::DomTreeUpdater::applyUpdatesPermissive(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 288) || *(void *)(a1 + 296))
  {
    v17[0] = v18;
    v17[1] = (void *)0x800000000;
    v20[0] = 0;
    v20[1] = 0;
    int v19 = v20;
    uint64_t v14 = v16;
    uint64_t v15 = 0x800000000;
    if (a3)
    {
      uint64_t v5 = 16 * a3;
      do
      {
        unint64_t v6 = *a2;
        uint64_t v7 = a2[1] & 0xFFFFFFFFFFFFFFF8;
        v21[0].i64[0] = v6;
        v21[0].i64[1] = v7;
        if (v6 != v7 && !sub_1CD485A50((uint64_t)v17, v6, v7))
        {
          uint64_t v8 = sub_1CD485AF0((uint64_t)v17, v21);
          if (llvm::DomTreeUpdater::isUpdateValid(v8, *a2, a2[1]))
          {
            long long v9 = *(_OWORD *)a2;
            if (*(unsigned char *)(a1 + 304) == 1)
            {
              unint64_t v10 = *(unsigned int *)(a1 + 8);
              if (v10 >= *(unsigned int *)(a1 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v11 = (void **)a1;
            }
            else
            {
              unint64_t v10 = v15;
              if (v15 >= (unint64_t)HIDWORD(v15)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v11 = &v14;
              long long v9 = *(_OWORD *)a2;
            }
            *((_OWORD *)*v11 + v10) = v9;
            ++*((_DWORD *)v11 + 2);
          }
        }
        a2 += 2;
        v5 -= 16;
      }
      while (v5);
    }
    if (*(unsigned char *)(a1 + 304) != 1)
    {
      uint64_t v12 = *(void *)(a1 + 288);
      if (v12)
      {
        sub_1CBFEBC30((uint64_t)v21, (unint64_t *)v14, v15, 1u);
        llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,false>>(v12, (uint64_t)v21, 0);
        sub_1CBFEEC7C((uint64_t)v21);
      }
      uint64_t v13 = *(void *)(a1 + 296);
      if (v13)
      {
        sub_1CBFEEDA8((uint64_t)v21, (unint64_t *)v14, v15, 1u);
        llvm::DomTreeBuilder::ApplyUpdates<llvm::DominatorTreeBase<llvm::BasicBlock,true>>(v13, (uint64_t)v21, 0);
        sub_1CBFEF604((uint64_t)v21);
      }
    }
    if (v14 != v16) {
      free(v14);
    }
    sub_1CD3C5048((uint64_t)&v19, v20[0]);
    if (v17[0] != v18) {
      free(v17[0]);
    }
  }
}

BOOL sub_1CD485A50(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (*(void *)(a1 + 160))
  {
    uint64_t v7 = *(void **)(a1 + 152);
    if (!v7) {
      return 0;
    }
    while (1)
    {
      unint64_t v8 = v7[4];
      if (v8 <= a2)
      {
        if (v8 >= a2)
        {
          unint64_t v9 = v7[5];
          if (v9 > a3) {
            goto LABEL_7;
          }
          if (v9 >= a3) {
            return 1;
          }
        }
        ++v7;
      }
LABEL_7:
      BOOL result = 0;
      uint64_t v7 = (void *)*v7;
      if (!v7) {
        return result;
      }
    }
  }
  uint64_t v3 = *(void **)a1;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  uint64_t v5 = *(void *)a1 + 16 * v4;
  if (v4)
  {
    uint64_t v10 = 16 * v4;
    while (*v3 != a2 || v3[1] != a3)
    {
      v3 += 2;
      v10 -= 16;
      if (!v10) {
        goto LABEL_3;
      }
    }
  }
  else
  {
LABEL_3:
    uint64_t v3 = (void *)v5;
  }
  return v3 != (void *)v5;
}

uint64_t sub_1CD485AF0(uint64_t result, int64x2_t *a2)
{
  if (*(void *)(result + 160))
  {
    uint64_t v4 = result + 144;
LABEL_8:
    return sub_1CD486140(v4, (unint64_t *)a2, a2);
  }
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v10 = a2;
    uint64_t v11 = result;
    uint64_t v5 = 16 * v2;
    unint64_t v6 = *(int64x2_t **)result;
    while (1)
    {
      int32x2_t v7 = vmovn_s64(vceqq_s64(*v6, *a2));
      if (v7.i32[0] & v7.i32[1]) {
        break;
      }
      ++v6;
      v5 -= 16;
      if (!v5) {
        goto LABEL_14;
      }
    }
    if (v5) {
      return result;
    }
LABEL_14:
    int64x2_t v3 = *a2;
    if (v2 <= 7) {
      goto LABEL_4;
    }
    uint64_t v8 = result + 144;
    do
    {
      unint64_t v9 = (unint64_t *)(*(void *)v11 + 16 * v2 - 16);
      sub_1CD486140(v8, v9, v9);
      LODWORD(v2) = *(_DWORD *)(v11 + 8) - 1;
      *(_DWORD *)(v11 + 8) = v2;
    }
    while (v2);
    uint64_t v4 = v11 + 144;
    a2 = v10;
    goto LABEL_8;
  }
  int64x2_t v3 = *a2;
LABEL_4:
  if (v2 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(int64x2_t *)(*(void *)result + 16 * v2) = v3;
  ++*(_DWORD *)(result + 8);
  return result;
}

llvm::raw_ostream *llvm::DomTreeUpdater::dump(unint64_t **this)
{
  uint64_t v2 = llvm::dbgs((llvm *)this);
  sub_1CB8E509C(v2, "Available Trees: ");
  if (this[36])
  {
    sub_1CB8E509C(v2, "DomTree ");
    if (!this[37]) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (this[37])
  {
LABEL_5:
    sub_1CB8E509C(v2, "PostDomTree ");
LABEL_6:
    int64x2_t v3 = "\n";
    goto LABEL_7;
  }
  int64x2_t v3 = "None\n";
LABEL_7:
  sub_1CB8E509C(v2, v3);
  sub_1CB8E509C(v2, "UpdateStrategy: ");
  if (*((unsigned char *)this + 304))
  {
    sub_1CB8E509C(v2, "Lazy\n");
    int v42 = 0;
    v41[0] = v2;
    v41[1] = (llvm::raw_ostream *)&v42;
    if (this[36])
    {
      uint64_t v4 = &(*this)[2 * (void)this[34]];
      sub_1CB8E509C(v2, "Applied but not cleared DomTreeUpdates:\n");
      sub_1CBFEB4C4(v41, *this, v4);
      sub_1CB8E509C(v2, "Pending DomTreeUpdates:\n");
      sub_1CBFEB4C4(v41, v4, &(*this)[2 * *((unsigned int *)this + 2)]);
    }
    if (this[37])
    {
      uint64_t v5 = &(*this)[2 * (void)this[35]];
      sub_1CB8E509C(v2, "Applied but not cleared PostDomTreeUpdates:\n");
      sub_1CBFEB4C4(v41, *this, v5);
      sub_1CB8E509C(v2, "Pending PostDomTreeUpdates:\n");
      sub_1CBFEB4C4(v41, v5, &(*this)[2 * *((unsigned int *)this + 2)]);
    }
    sub_1CB8E509C(v2, "Pending DeletedBBs:\n");
    int v42 = 0;
    unint64_t v6 = this[40];
    uint64_t v7 = 328;
    if (v6 == this[39]) {
      uint64_t v7 = 332;
    }
    uint64_t v8 = *(unsigned int *)((char *)this + v7);
    if (v8)
    {
      uint64_t v9 = 8 * v8;
      uint64_t v10 = this[40];
      while (*v10 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v10;
        v9 -= 8;
        if (!v9) {
          goto LABEL_18;
        }
      }
    }
    else
    {
      uint64_t v10 = this[40];
    }
    uint64_t v22 = &v6[v8];
    if (v10 != v22)
    {
      size_t v23 = "  ";
      uint64_t v24 = (llvm::Value *)*v10;
      size_t v25 = " : ";
      char v26 = "(no_name)(";
      std::string::size_type v27 = "(";
LABEL_34:
      char v28 = sub_1CB8E509C(v2, v23);
      std::string::size_type v29 = llvm::raw_ostream::operator<<(v28, v42);
      sub_1CB8E509C(v29, v25);
      ++v42;
      std::string::size_type v30 = (char *)v26;
      if ((*((unsigned char *)v24 + 23) & 0x10) != 0)
      {
        BOOL v31 = v26;
        uint64_t v32 = v25;
        std::string::size_type v33 = v23;
        std::string::size_type v34 = (char *)v27;
        Name = llvm::Value::getName(v24);
        size_t v37 = v35;
        std::string::size_type v38 = (void *)*((void *)v2 + 4);
        if (v35 <= *((void *)v2 + 3) - (void)v38)
        {
          if (v35)
          {
            memcpy(v38, Name, v35);
            *((void *)v2 + 4) += v37;
          }
        }
        else
        {
          llvm::raw_ostream::write(v2, Name, v35);
        }
        std::string::size_type v27 = v34;
        std::string::size_type v30 = v34;
        size_t v23 = v33;
        size_t v25 = v32;
        char v26 = v31;
      }
      sub_1CB8E509C(v2, v30);
      llvm::write_hex(v2, (unint64_t)v24, 3, 0, 0);
      sub_1CB8E509C(v2, ")\n");
      uint64_t v39 = v10 + 1;
      while (v39 != v22)
      {
        unint64_t v40 = *v39++;
        uint64_t v24 = (llvm::Value *)v40;
        if (v40 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v10 = v39 - 1;
          goto LABEL_34;
        }
      }
    }
LABEL_18:
    BOOL result = sub_1CB8E509C(v2, "Pending Callbacks:\n");
    int v42 = 0;
    uint64_t v12 = this[51];
    for (uint64_t i = this[52]; v12 != i; v12 += 9)
    {
      uint64_t v14 = sub_1CB8E509C(v2, "  ");
      uint64_t v15 = llvm::raw_ostream::operator<<(v14, v42);
      sub_1CB8E509C(v15, " : ");
      ++v42;
      int v16 = (llvm::Value *)v12[3];
      int v17 = "(no_name)(";
      if ((*((unsigned char *)v16 + 23) & 0x10) != 0)
      {
        int v19 = llvm::Value::getName(v16);
        size_t v20 = v18;
        BOOL v21 = (void *)*((void *)v2 + 4);
        if (v18 <= *((void *)v2 + 3) - (void)v21)
        {
          if (v18)
          {
            memcpy(v21, v19, v18);
            *((void *)v2 + 4) += v20;
          }
        }
        else
        {
          llvm::raw_ostream::write(v2, v19, v18);
        }
        int v17 = "(";
      }
      sub_1CB8E509C(v2, v17);
      llvm::write_hex(v2, v12[3], 3, 0, 0);
      BOOL result = sub_1CB8E509C(v2, ")\n");
    }
  }
  else
  {
    return sub_1CB8E509C(v2, "Eager\n");
  }
  return result;
}

void *sub_1CD486098(void *a1)
{
  uint64_t v2 = a1 + 5;
  int64x2_t v3 = (void *)a1[8];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = a1[3];
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 1);
  }
  return a1;
}

uint64_t sub_1CD486140(uint64_t a1, unint64_t *a2, _OWORD *a3)
{
  uint64_t v5 = (uint64_t **)sub_1CD4861E8(a1, &v12, a2);
  if (*v5) {
    return 0;
  }
  uint64_t v7 = v5;
  uint64_t v8 = operator new(0x30uLL);
  v8[2] = *a3;
  uint64_t v9 = v12;
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = v9;
  *uint64_t v7 = (uint64_t *)v8;
  uint64_t v10 = **(void **)a1;
  if (v10)
  {
    *(void *)a1 = v10;
    uint64_t v11 = *v7;
  }
  else
  {
    uint64_t v11 = (uint64_t *)v8;
  }
  sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
  ++*(void *)(a1 + 16);
  return 1;
}

void *sub_1CD4861E8(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  BOOL result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unint64_t v6 = *a3;
    unint64_t v7 = a3[1];
    while (1)
    {
      while (1)
      {
        uint64_t v8 = v4;
        unint64_t v9 = v4[4];
        if (v6 >= v9) {
          break;
        }
LABEL_4:
        uint64_t v4 = (void *)*v8;
        BOOL result = v8;
        if (!*v8) {
          goto LABEL_13;
        }
      }
      if (v9 >= v6)
      {
        unint64_t v10 = v8[5];
        if (v7 < v10) {
          goto LABEL_4;
        }
        if (v10 >= v7) {
          goto LABEL_13;
        }
      }
      BOOL result = v8 + 1;
      uint64_t v4 = (void *)v8[1];
      if (!v4) {
        goto LABEL_13;
      }
    }
  }
  uint64_t v8 = result;
LABEL_13:
  *a2 = v8;
  return result;
}

void *llvm::DominanceFrontierBase<llvm::BasicBlock,false>::print(void *result, llvm::raw_ostream *a2)
{
  uint64_t v2 = result + 1;
  int64x2_t v3 = (void *)*result;
  if ((void *)*result != result + 1)
  {
    do
    {
      sub_1CB8E509C(a2, "  DomFrontier for BB ");
      uint64_t v5 = (llvm::Value *)v3[4];
      if (v5) {
        llvm::Value::printAsOperand(v5, a2, 0, 0);
      }
      else {
        sub_1CB8E509C(a2, " <<exit node>>");
      }
      BOOL result = sub_1CB8E509C(a2, " is:\t");
      unint64_t v6 = (void *)v3[5];
      if (v6 != v3 + 6)
      {
        do
        {
          unint64_t v7 = (llvm::Value *)v6[4];
          uint64_t v8 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v8 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 32);
          }
          else
          {
            *((void *)a2 + 4) = v8 + 1;
            *uint64_t v8 = 32;
          }
          if (v7) {
            BOOL result = (void *)llvm::Value::printAsOperand(v7, a2, 0, 0);
          }
          else {
            BOOL result = sub_1CB8E509C(a2, "<<exit node>>");
          }
          unint64_t v9 = (void *)v6[1];
          if (v9)
          {
            do
            {
              unint64_t v10 = v9;
              unint64_t v9 = (void *)*v9;
            }
            while (v9);
          }
          else
          {
            do
            {
              unint64_t v10 = (void *)v6[2];
              BOOL v11 = *v10 == (void)v6;
              unint64_t v6 = v10;
            }
            while (!v11);
          }
          unint64_t v6 = v10;
        }
        while (v10 != v3 + 6);
      }
      uint64_t v12 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v12 >= *((void *)a2 + 3))
      {
        BOOL result = llvm::raw_ostream::write(a2, 10);
      }
      else
      {
        *((void *)a2 + 4) = v12 + 1;
        *uint64_t v12 = 10;
      }
      uint64_t v13 = (void *)v3[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (void *)v3[2];
          BOOL v11 = *v14 == (void)v3;
          int64x2_t v3 = v14;
        }
        while (!v11);
      }
      int64x2_t v3 = v14;
    }
    while (v14 != v2);
  }
  return result;
}

void llvm::ForwardDominanceFrontierBase<llvm::BasicBlock>::analyze(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)*a2;
  *(_DWORD *)(a1 + 32) = 0;
  if (!*(_DWORD *)(a1 + 36)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  **(void **)(a1 + 24) = v2;
  ++*(_DWORD *)(a1 + 32);
  uint64_t v3 = **(void **)(a1 + 24);
  uint64_t v4 = 0;
  uint64_t v5 = v3;
  sub_1CB915048(a2 + 3, &v5, &v4);
  llvm::ForwardDominanceFrontierBase<llvm::BasicBlock>::calculate();
}

uint64_t **llvm::ForwardDominanceFrontierBase<llvm::BasicBlock>::calculate(uint64_t **a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4 = *a3;
  long long v51 = 0;
  uint64_t v52 = 0;
  unint64_t v53 = 0;
  v46 = v50;
  std::string::size_type v47 = v50;
  uint64_t v48 = 32;
  int v49 = 0;
  long long v44 = v4;
  long long v45 = (unint64_t)a3;
  uint64_t v5 = sub_1CBFF08A8((void **)&v51, &v44);
  uint64_t v52 = v5;
  do
  {
    __int16 v43 = 0;
    unint64_t v6 = (uint64_t *)*((void *)v5 - 4);
    int v42 = 0;
    __int16 v43 = v6;
    size_t v37 = (uint64_t *)*((void *)v5 - 3);
    int v42 = v37;
    uint64_t v8 = *((void *)v5 - 2);
    uint64_t v7 = *((void *)v5 - 1);
    std::string::size_type v36 = sub_1CD486E50(a1, (unint64_t)v6, &v43);
    uint64_t v39 = v6;
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v46, (uint64_t)v6);
    if (v9)
    {
      unint64_t v10 = (uint64_t *)v6[5];
      if (v10 != v6 + 5)
      {
        BOOL v11 = v10 ? (unsigned __int8 *)(v10 - 3) : 0;
        if (v11[16] - 29 <= 0xA)
        {
          int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v11);
          if (NumSuccessors)
          {
            int v13 = NumSuccessors;
            for (unsigned int i = 0; i != v13; ++i)
            {
              Successor = 0;
              Successor = (uint64_t *)llvm::Instruction::getSuccessor((llvm::Instruction *)v11, i);
              *(void *)&long long v44 = Successor;
              v54[0] = 0;
              int v15 = sub_1CB915048((uint64_t *)(a2 + 24), &v44, v54);
              uint64_t v16 = v54[0];
              if (!v15) {
                uint64_t v16 = *(void *)(a2 + 24) + 16 * *(unsigned int *)(a2 + 40);
              }
              if (*(void *)(*(void *)(v16 + 8) + 8) != v8) {
                sub_1CD3CFB98(v36 + 5, (unint64_t *)&Successor, &Successor);
              }
            }
          }
        }
      }
    }
    uint64_t v17 = *(unsigned int *)(v8 + 32);
    if (v17)
    {
      char v18 = 0;
      int v19 = *(uint64_t ***)(v8 + 24);
      size_t v20 = &v19[v17];
      while (2)
      {
        unint64_t v40 = v5;
        while (1)
        {
          BOOL v21 = *v19;
          uint64_t v22 = **v19;
          size_t v23 = (char *)sub_1CB896AE8((uint64_t)&v46, v22);
          uint64_t v24 = v47 == v46 ? (uint64_t *)((char *)&v48 + 4) : &v48;
          if (v23 == &v47[8 * *(unsigned int *)v24]) {
            break;
          }
          if (++v19 == v20)
          {
            uint64_t v5 = v40;
            if (v18) {
              goto LABEL_52;
            }
            goto LABEL_30;
          }
        }
        *(void *)&long long v44 = v22;
        *((void *)&v44 + 1) = v39;
        *(void *)&long long v45 = v21;
        *((void *)&v45 + 1) = v8;
        if ((unint64_t)v40 >= v53)
        {
          uint64_t v5 = sub_1CBFF08A8((void **)&v51, &v44);
        }
        else
        {
          long long v25 = v45;
          *unint64_t v40 = v44;
          v40[1] = v25;
          uint64_t v5 = v40 + 2;
        }
        uint64_t v52 = v5;
        ++v19;
        char v18 = 1;
        if (v19 != v20) {
          continue;
        }
        break;
      }
    }
    else
    {
LABEL_30:
      char v26 = v36 + 5;
      if (!v37) {
        goto LABEL_54;
      }
      std::string::size_type v27 = (uint64_t **)v36[5];
      char v28 = sub_1CD486E50(a1, (unint64_t)v37, &v42);
      if (v27 != v36 + 6)
      {
        std::string::size_type v29 = v28 + 5;
        do
        {
          *(void *)&long long v44 = v27[4];
          v54[0] = 0;
          if (sub_1CB915048((uint64_t *)(a2 + 24), &v44, v54)
            && v54[0] != *(void *)(a2 + 24) + 16 * *(unsigned int *)(a2 + 40))
          {
            uint64_t v30 = *(void *)(v54[0] + 8);
            BOOL v31 = v7 == v30 || v7 == 0;
            if (!v31 && v30 != 0) {
              llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
            }
          }
          sub_1CD3CFB98(v29, (unint64_t *)v27 + 4, v27 + 4);
          std::string::size_type v33 = v27[1];
          if (v33)
          {
            do
            {
              std::string::size_type v34 = (uint64_t **)v33;
              std::string::size_type v33 = (uint64_t *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              std::string::size_type v34 = (uint64_t **)v27[2];
              BOOL v31 = *v34 == (uint64_t *)v27;
              std::string::size_type v27 = v34;
            }
            while (!v31);
          }
          std::string::size_type v27 = v34;
        }
        while (v34 != v36 + 6);
        uint64_t v5 = v52;
      }
      v5 -= 2;
      uint64_t v52 = v5;
    }
LABEL_52:
    ;
  }
  while (v51 != v5);
  char v26 = 0;
LABEL_54:
  if (v47 != v46) {
    free(v47);
  }
  if (v51) {
    operator delete(v51);
  }
  return v26;
}

void llvm::initializeDominanceFrontierWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5578, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CBFF03C4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5578, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::DominanceFrontierWrapperPass *llvm::DominanceFrontierWrapperPass::DominanceFrontierWrapperPass(llvm::DominanceFrontierWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::DominanceFrontierWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2603340;
  *((void *)this + 5) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = (char *)this + 72;
  *((void *)this + 8) = 0x100000000;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5578, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFF03C4;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5578, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::DominanceFrontierWrapperPass::releaseMemory(llvm::DominanceFrontierWrapperPass *this)
{
  uint64_t v1 = (void *)((char *)this + 40);
  sub_1CD486DF0((uint64_t)this + 32, *((void **)this + 5));
  *(v1 - 1) = v1;
  void *v1 = 0;
  v1[1] = 0;
}

void llvm::DominanceFrontierWrapperPass::runOnFunction(uint64_t **this, llvm::Function *a2)
{
  ((void (*)(uint64_t **, llvm::Function *))(*this)[11])(this, a2);
  uint64_t v3 = this[1];
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_2:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_2;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::DominatorTreeWrapperPass::ID);
  llvm::ForwardDominanceFrontierBase<llvm::BasicBlock>::analyze();
}

llvm::AnalysisUsage *llvm::DominanceFrontierWrapperPass::getAnalysisUsage(llvm::DominanceFrontierWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
}

void llvm::DominanceFrontierWrapperPass::print(llvm::DominanceFrontierWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

uint64_t llvm::DominanceFrontierWrapperPass::dump(llvm::DominanceFrontierWrapperPass *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = *(uint64_t (**)(llvm::DominanceFrontierWrapperPass *, llvm *, void))(*(void *)this + 40);

  return v3(this, v2, 0);
}

BOOL llvm::DominanceFrontier::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = (void **)a3;
  v8[1] = (void **)&llvm::DominanceFrontierAnalysis::Key;
  uint64_t v4 = sub_1CB896AE8(a3 + 48, (uint64_t)&llvm::DominanceFrontierAnalysis::Key);
  uint64_t v5 = *(void *)(a3 + 56);
  if (v5 == *(void *)(a3 + 48)) {
    uint64_t v6 = (unsigned int *)(a3 + 68);
  }
  else {
    uint64_t v6 = (unsigned int *)(a3 + 64);
  }
  BOOL v9 = v4 != (void *)(v5 + 8 * *v6);
  return !sub_1CBF75724(v8) && !sub_1CBF7593C((uint64_t)v8) && !sub_1CBF75B60((uint64_t)v8);
}

void llvm::DominanceFrontierAnalysis::run(void *a1@<X8>)
{
  a1[1] = 0;
  *a1 = a1 + 1;
  a1[2] = 0;
  a1[3] = a1 + 5;
  a1[4] = 0x100000000;
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void *llvm::DominanceFrontierPrinterPass::DominanceFrontierPrinterPass(void *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

void llvm::DominanceFrontierPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "DominanceFrontier for function: ");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  uint64_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void sub_1CD486D0C(uint64_t a1)
{
  sub_1CD486D80(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::DominanceFrontierWrapperPass>()
{
}

void sub_1CD486D80(uint64_t a1)
{
  *(void *)a1 = &unk_1F2603340;
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2 != (void *)(a1 + 72)) {
    free(v2);
  }
  sub_1CD486DF0(a1 + 32, *(void **)(a1 + 40));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD486DF0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD486DF0(a1, *a2);
    sub_1CD486DF0(a1, a2[1]);
    sub_1CB833A08((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }
}

uint64_t **sub_1CD486E50(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  size_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        size_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        size_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    BOOL v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x40uLL);
    unint64_t v10 = *a3;
    v7[7] = 0;
    v7[6] = 0;
    v7[4] = v10;
    v7[5] = (uint64_t *)(v7 + 6);
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *size_t v6 = (uint64_t *)v7;
    BOOL v11 = (uint64_t *)**a1;
    uint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

char *llvm::getEHPersonalityName(int a1)
{
  return off_1E682C6C8[a1 - 1];
}

uint64_t llvm::getDefaultEHPersonality(llvm *this, const llvm::Triple *a2)
{
  return 2;
}

BOOL llvm::canSimplifyInvokeNoUnwind(llvm *this, const llvm::Function *a2)
{
  PersonalityFn = (llvm::Value *)llvm::Function::getPersonalityFn(this);
  return llvm::classifyEHPersonality(PersonalityFn, v3) - 9 < 0xFFFFFFFE;
}

BOOL sub_1CD486F7C(unint64_t *a1, uint64_t a2)
{
  unint64_t v2 = *a1;
  if ((*a1 & 4) != 0)
  {
    size_t v4 = *(unint64_t **)(v2 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v3 = &v4[*(unsigned int *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8)];
  }
  else
  {
    uint64_t v3 = &a1[v2 > 7];
    size_t v4 = a1;
  }
  if (v4 != v3)
  {
    while (*v4 != a2)
    {
      if (++v4 == v3)
      {
        size_t v4 = v3;
        break;
      }
    }
  }
  if ((v2 & 4) != 0) {
    uint64_t v5 = *(void *)(v2 & 0xFFFFFFFFFFFFFFF8) + 8 * *(unsigned int *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  else {
    uint64_t v5 = (uint64_t)&a1[v2 > 7];
  }
  return v4 != (unint64_t *)v5;
}

unint64_t *sub_1CD486FFC(unint64_t *result, uint64_t a2)
{
  unint64_t v2 = *result;
  if (*result > 7)
  {
    if ((v2 & 4) == 0) {
      operator new();
    }
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v4 = *(_DWORD *)((v2 & 0xFFFFFFFFFFFFFFF8) + 8);
    if (v4 >= *(_DWORD *)(v3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v3 + 8 * v4) = a2;
    ++*(_DWORD *)(v3 + 8);
  }
  else
  {
    *BOOL result = a2 & 0xFFFFFFFFFFFFFFFBLL;
  }
  return result;
}

uint64_t *sub_1CD487110(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if ((*a1 & 4) != 0)
  {
    unint64_t v3 = (void **)(v2 & 0xFFFFFFFFFFFFFFF8);
    if ((v2 & 0xFFFFFFFFFFFFFFF8) != 0)
    {
      if (*v3 != v3 + 2) {
        free(*v3);
      }
      MEMORY[0x1D25D9CE0](v3, 0x1080C40ED926357);
    }
  }
  return a1;
}

void *sub_1CD487170(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4871D4((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4871D4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD487284(a1, v7);
  BOOL v9 = 0;
  sub_1CD3C8538((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD487284(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD487358((uint64_t *)a1, v4, &v4[2 * v3]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *BOOL result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t *sub_1CD487358(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  char v4 = result;
  result[1] = 0;
  uint64_t v5 = *((unsigned int *)result + 4);
  if (v5)
  {
    unint64_t v6 = (void *)*result;
    uint64_t v7 = 16 * v5;
    do
    {
      *unint64_t v6 = -4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    unsigned int v8 = a2 + 1;
    do
    {
      if ((*(v8 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v11 = 0;
        sub_1CD3C8538(v4, v8 - 1, &v11);
        uint64_t v10 = v11;
        *uint64_t v11 = *(v8 - 1);
        v10[1] = *v8;
        *unsigned int v8 = 0;
        ++*((_DWORD *)v4 + 2);
        BOOL result = sub_1CD487110(v8);
      }
      BOOL v9 = v8 + 1;
      v8 += 2;
    }
    while (v9 != a3);
  }
  return result;
}

llvm::raw_ostream *llvm::FunctionPropertiesInfo::print(llvm::FunctionPropertiesInfo *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = sub_1CB8E509C(a2, "BasicBlockCount: ");
  char v4 = llvm::raw_ostream::operator<<(v3, *(void *)this);
  uint64_t v5 = sub_1CB8E509C(v4, "\n");
  unint64_t v6 = sub_1CB8E509C(v5, "BlocksReachedFromConditionalInstruction: ");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, *((void *)this + 1));
  unsigned int v8 = sub_1CB8E509C(v7, "\n");
  BOOL v9 = sub_1CB8E509C(v8, "Uses: ");
  uint64_t v10 = llvm::raw_ostream::operator<<(v9, *((void *)this + 2));
  uint64_t v11 = sub_1CB8E509C(v10, "\n");
  uint64_t v12 = sub_1CB8E509C(v11, "DirectCallsToDefinedFunctions: ");
  int v13 = llvm::raw_ostream::operator<<(v12, *((void *)this + 3));
  uint64_t v14 = sub_1CB8E509C(v13, "\n");
  int v15 = sub_1CB8E509C(v14, "LoadInstCount: ");
  uint64_t v16 = llvm::raw_ostream::operator<<(v15, *((void *)this + 4));
  uint64_t v17 = sub_1CB8E509C(v16, "\n");
  char v18 = sub_1CB8E509C(v17, "StoreInstCount: ");
  int v19 = llvm::raw_ostream::operator<<(v18, *((void *)this + 5));
  size_t v20 = sub_1CB8E509C(v19, "\n");
  BOOL v21 = sub_1CB8E509C(v20, "MaxLoopDepth: ");
  uint64_t v22 = llvm::raw_ostream::operator<<(v21, *((void *)this + 6));
  size_t v23 = sub_1CB8E509C(v22, "\n");
  uint64_t v24 = sub_1CB8E509C(v23, "TopLevelLoopCount: ");
  long long v25 = llvm::raw_ostream::operator<<(v24, *((void *)this + 7));

  return sub_1CB8E509C(v25, "\n\n");
}

void llvm::FunctionPropertiesAnalysis::run()
{
}

void llvm::FunctionPropertiesPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "Printing analysis results of CFA for function ");
  char v4 = sub_1CB8E509C(v3, "'");
  Name = llvm::Value::getName(a2);
  size_t v7 = v5;
  unsigned int v8 = (void *)*((void *)v4 + 4);
  if (v5 <= *((void *)v4 + 3) - (void)v8)
  {
    if (v5)
    {
      memcpy(v8, Name, v5);
      *((void *)v4 + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(v4, Name, v5);
  }
  BOOL v9 = sub_1CB8E509C(v4, "':");
  sub_1CB8E509C(v9, "\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

uint64_t *sub_1CD4876BC(uint64_t *a1, void *a2)
{
  unint64_t v4 = *a1 & 0xFFFFFFFFFFFFFFF8;
  if (v4)
  {
    if ((*(unsigned char *)v4 & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)(v4 + 8), 8);
    }
    MEMORY[0x1D25D9CE0](v4, 0x1000C400BDB4DB4);
  }
  *a1 = *a2 & 7;
  if ((*a2 & 0xFFFFFFFFFFFFFFF8) != 0) {
    operator new();
  }
  return a1;
}

BOOL llvm::GlobalsAAResult::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = sub_1CB896AE8(a3 + 48, (uint64_t)&llvm::GlobalsAA::Key);
  uint64_t v5 = *(void *)(a3 + 56);
  if (v5 == *(void *)(a3 + 48)) {
    unint64_t v6 = (unsigned int *)(a3 + 68);
  }
  else {
    unint64_t v6 = (unsigned int *)(a3 + 64);
  }
  return v4 != (void *)(v5 + 8 * *v6);
}

uint64_t llvm::GlobalsAAResult::GlobalsAAResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = a2;
  uint64_t v4 = *(void *)(a3 + 24);
  if (v4)
  {
    if (v4 == a3)
    {
      *(void *)(a1 + 40) = a1 + 16;
      (*(void (**)(void))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24));
    }
    else
    {
      *(void *)(a1 + 40) = v4;
      *(void *)(a3 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 40) = 0;
  }
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 8;
  *(_DWORD *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = a1 + 184;
  *(void *)(a1 + 160) = a1 + 184;
  *(void *)(a1 + 168) = 8;
  *(_DWORD *)(a1 + 176) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = a1 + 320;
  *(void *)(a1 + 328) = a1 + 320;
  *(void *)(a1 + 336) = 0;
  return a1;
}

void llvm::GlobalsAA::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::RecomputeGlobalsAAPass::run()
{
}

void llvm::initializeGlobalsAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5640, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CBFF5E18;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5640, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createGlobalsAAWrapperPass(llvm *this)
{
}

llvm::GlobalsAAWrapperPass *llvm::GlobalsAAWrapperPass::GlobalsAAWrapperPass(llvm::GlobalsAAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::GlobalsAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F26033E0;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5640, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFF5E18;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5640, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::GlobalsAAWrapperPass::runOnModule(llvm::GlobalsAAWrapperPass *this, llvm::Module *a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t llvm::GlobalsAAWrapperPass::doFinalization(llvm::GlobalsAAWrapperPass *this, llvm::Module *a2)
{
  uint64_t v3 = (llvm::GlobalsAAResult *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3)
  {
    llvm::GlobalsAAResult::~GlobalsAAResult(v3);
    MEMORY[0x1D25D9CE0]();
  }
  return 0;
}

llvm::AnalysisUsage *llvm::GlobalsAAWrapperPass::getAnalysisUsage(llvm::GlobalsAAWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::CallGraphWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
}

void sub_1CD487E98(llvm::ModulePass *a1)
{
  sub_1CD487F6C(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD487ED0(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CBFF5EC8(a1, a2, &v6)) {
    return v6;
  }
  if (*(unsigned char *)a1)
  {
    uint64_t v3 = a1 + 8;
    uint64_t v4 = 16;
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = *(unsigned int *)(a1 + 16);
  }
  return v3 + 16 * v4;
}

void llvm::callDefaultCtor<llvm::GlobalsAAWrapperPass>()
{
}

void sub_1CD487F6C(llvm::ModulePass *this)
{
  *(void *)this = &unk_1F26033E0;
  uint64_t v2 = (llvm::GlobalsAAResult *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2)
  {
    llvm::GlobalsAAResult::~GlobalsAAResult(v2);
    MEMORY[0x1D25D9CE0]();
  }

  llvm::ModulePass::~ModulePass(this);
}

void sub_1CD487FE0(char **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCC5580, 0, 0);
  byte_1EBCC5600 = 0;
  qword_1EBCC5608 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC5610 = 0;
  qword_1EBCC5580 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC5618 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC5620 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC5638 = (uint64_t)&qword_1EBCC5620;
  llvm::cl::Option::setArgStr(v4, "enable-unsafe-globalsmodref-alias-results", 0x29uLL);
  uint64_t v5 = *a1;
  byte_1EBCC5600 = **a1;
  byte_1EBCC5611 = 1;
  byte_1EBCC5610 = *v5;
  word_1EBCC558A = (32 * (*a2 & 3)) | word_1EBCC558A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC5580);
}

void *sub_1CD488100(uint64_t a1, uint64_t *a2)
{
  size_t v7 = 0;
  char v4 = sub_1CBFF64C0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD48816C(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD48816C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD488220(a1, v6);
  unsigned int v8 = 0;
  sub_1CBFF64C0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD488220(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4882EC(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *BOOL result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4882EC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      BOOL result = sub_1CBFF64C0(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

_DWORD *sub_1CD48839C(_DWORD *a1)
{
  int v2 = a1[2];
  BOOL result = (_DWORD *)sub_1CBFF6C98((uint64_t)a1);
  if (v2)
  {
    int v4 = 1 << (33 - __clz(v2 - 1));
    if (v4 <= 64) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = v4;
    }
    if (v5 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v6 = 16 * v5;
      int v7 = *(void **)a1;
      do
      {
        *int v7 = -4096;
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
      return result;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return result;
    }
    unsigned int v5 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  return sub_1CB837D60(a1, v5);
}

llvm::AnalysisUsage *llvm::GPUAAWrapperPass::getAnalysisUsage(llvm::GPUAAWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AssumptionCacheTracker::ID);

  return llvm::AnalysisUsage::addRequiredID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
}

void llvm::createGPUAAWrapperPass(llvm *this)
{
}

llvm::GPUAAWrapperPass *llvm::GPUAAWrapperPass::GPUAAWrapperPass(llvm::GPUAAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::GPUAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2603538;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5648, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFF7A28;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCC5648, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeGPUAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5648, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CBFF7A28;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5648, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::callDefaultCtor<llvm::GPUAAWrapperPass>()
{
}

unint64_t llvm::getMaxFreq(llvm *this, const llvm::Function *a2, const llvm::BlockFrequencyInfo *a3)
{
  uint64_t v3 = (char *)this + 72;
  int v4 = (char *)*((void *)this + 10);
  if (v4 == (char *)this + 72) {
    return 0;
  }
  unint64_t v6 = 0;
  do
  {
    if (v4) {
      int v7 = (const llvm::BasicBlock *)(v4 - 24);
    }
    else {
      int v7 = 0;
    }
    unint64_t BlockFreq = llvm::BlockFrequencyInfo::getBlockFreq(a2, v7);
    if (BlockFreq > v6) {
      unint64_t v6 = BlockFreq;
    }
    int v4 = (char *)*((void *)v4 + 1);
  }
  while (v4 != v3);
  return v6;
}

void llvm::getHeatColor(llvm *this@<X0>, unint64_t a2@<X1>, std::string *a3@<X8>)
{
  if ((unint64_t)this >= a2) {
    int v4 = (llvm *)a2;
  }
  else {
    int v4 = this;
  }
  double v5 = 0.0;
  if (v4)
  {
    double v7 = log2((double)(unint64_t)v4);
    double v5 = v7 / log2((double)a2);
  }
  if (v5 > 1.0) {
    double v5 = 1.0;
  }
  if (v5 >= 0.0) {
    double v8 = v5 * 99.0;
  }
  else {
    double v8 = 0.0;
  }
  uint64_t v9 = &a3d50c3[8 * vcvtad_u64_f64(v8)];
  std::string::size_type v10 = strlen(v9);

  std::string::__init(a3, v9, v10);
}

void llvm::getHeatColor(double a1@<D0>, std::string *a2@<X8>)
{
  if (a1 > 1.0) {
    a1 = 1.0;
  }
  double v4 = a1 * 99.0;
  BOOL v5 = a1 < 0.0;
  double v6 = 0.0;
  if (!v5) {
    double v6 = v4;
  }
  double v7 = &a3d50c3[8 * vcvtad_u64_f64(v6)];
  std::string::size_type v8 = strlen(v7);

  std::string::__init(a2, v7, v8);
}

uint64_t llvm::IRSimilarity::IRInstructionData::setBranchSuccessors(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(v4 + 40);
  uint64_t v18 = 0;
  uint64_t result = sub_1CBFA3AF4((uint64_t *)a2, &v17, &v18);
  uint64_t v6 = v18;
  if (!result) {
    uint64_t v6 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  }
  int v7 = *(_DWORD *)(v4 + 20);
  if ((v7 & 0x40000000) != 0)
  {
    uint64_t v9 = *(void *)(v4 - 8);
    uint64_t v8 = v7 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v8 = v7 & 0x7FFFFFF;
    uint64_t v9 = v4 - 32 * v8;
  }
  uint64_t v10 = v8 == 3;
  if (v8 != v10)
  {
    int v11 = *(_DWORD *)(v6 + 8);
    uint64_t v12 = (uint64_t *)(v9 + 32 * v10);
    uint64_t v13 = 32 * v8 - 32 * v10;
    do
    {
      uint64_t v17 = *v12;
      uint64_t v18 = 0;
      uint64_t result = sub_1CBFA3AF4((uint64_t *)a2, &v17, &v18);
      uint64_t v14 = v18;
      if (!result) {
        uint64_t v14 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
      }
      int v15 = *(_DWORD *)(v14 + 8);
      unint64_t v16 = *(unsigned int *)(a1 + 128);
      if (v16 >= *(unsigned int *)(a1 + 132)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)(a1 + 120) + 4 * v16) = v15 - v11;
      ++*(_DWORD *)(a1 + 128);
      v12 += 4;
      v13 -= 32;
    }
    while (v13);
  }
  return result;
}

uint64_t llvm::IRSimilarity::IRInstructionData::setPHIPredecessors(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v18 = *(void *)(v4 + 40);
  uint64_t v19 = 0;
  uint64_t result = sub_1CBFA3AF4((uint64_t *)a2, &v18, &v19);
  if (result) {
    uint64_t v6 = v19;
  }
  else {
    uint64_t v6 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  }
  int v7 = *(_DWORD *)(v4 + 20);
  unint64_t v8 = v7 & 0x7FFFFFF;
  if ((v7 & 0x7FFFFFF) != 0)
  {
    unint64_t v9 = 0;
    int v10 = *(_DWORD *)(v6 + 8);
    do
    {
      if ((v7 & 0x40000000) != 0) {
        uint64_t v11 = *(void *)(v4 - 8);
      }
      else {
        uint64_t v11 = v4 - 32 * v8;
      }
      uint64_t v18 = *(void *)(v11 + 32 * *(unsigned int *)(v4 + 60) + 8 * v9);
      uint64_t v19 = 0;
      uint64_t result = sub_1CBFA3AF4((uint64_t *)a2, &v18, &v19);
      uint64_t v12 = v19;
      if (!result) {
        uint64_t v12 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
      }
      int v13 = *(_DWORD *)(v12 + 8);
      unint64_t v14 = *(unsigned int *)(a1 + 128);
      if (v14 >= *(unsigned int *)(a1 + 132)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v15 = v13 - v10;
      *(_DWORD *)(*(void *)(a1 + 120) + 4 * v14) = v15;
      unsigned int v16 = *(_DWORD *)(a1 + 132);
      unsigned int v17 = *(_DWORD *)(a1 + 128) + 1;
      *(_DWORD *)(a1 + 128) = v17;
      if (v17 >= v16) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)(a1 + 120) + 4 * v17) = v15;
      ++*(_DWORD *)(a1 + 128);
      ++v9;
      int v7 = *(_DWORD *)(v4 + 20);
      unint64_t v8 = v7 & 0x7FFFFFF;
    }
    while (v9 < v8);
  }
  return result;
}

void llvm::IRSimilarity::IRInstructionMapper::convertToUnsignedVec(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v7 = *(void *)(a2 + 48);
  uint64_t v22 = 0;
  uint64_t v23 = v7;
  uint64_t v8 = a2 + 40;
  std::string __p = 0;
  BOOL v21 = 0;
  unsigned int v17 = 0;
  uint64_t v18 = 0;
  for (uint64_t i = 0; v7 != v8; v23 = v7)
  {
    if (v7) {
      unint64_t v9 = (llvm::Instruction *)(v7 - 24);
    }
    else {
      unint64_t v9 = 0;
    }
    int v10 = sub_1CD488C7C((unsigned __int8 *)(a1 + 88), v9);
    switch(v10)
    {
      case 2:
        *(unsigned char *)(a1 + 56) = 0;
        break;
      case 1:
        llvm::IRSimilarity::IRInstructionMapper::mapToIllegalUnsigned((unsigned int *)a1, &v23, (uint64_t)&__p, (uint64_t)&v17, 0);
        break;
      case 0:
        llvm::IRSimilarity::IRInstructionMapper::mapToLegalUnsigned(a1, &v23, (uint64_t)&__p, (uint64_t)&v17);
        break;
    }
    uint64_t v7 = *(void *)(v7 + 8);
  }
  if (*(unsigned char *)(a1 + 56)) {
    llvm::IRSimilarity::IRInstructionMapper::mapToIllegalUnsigned((unsigned int *)a1, &v23, (uint64_t)&__p, (uint64_t)&v17, 1);
  }
  uint64_t v12 = v17;
  uint64_t v11 = v18;
  if (v17 != v18)
  {
    int v13 = *(uint64_t **)(a1 + 80);
    uint64_t v14 = *v13;
    int v15 = v17;
    do
    {
      unsigned int v16 = *(unint64_t **)v15;
      v15 += 8;
      *unsigned int v16 = v14 & 0xFFFFFFFFFFFFFFF8 | *v16 & 7;
      v16[1] = (unint64_t)v13;
      *(void *)((v14 & 0xFFFFFFFFFFFFFFF8) + 8) = v16;
      uint64_t v14 = *v13 & 7 | (unint64_t)v16;
      *int v13 = v14;
    }
    while (v15 != v11);
  }
  sub_1CBFC93DC(a3, *(void *)(a3 + 8), v12, v11, (v11 - v12) >> 3);
  sub_1CBFFBF40(a4, a4[1], (char *)__p, v21, (v21 - (unsigned char *)__p) >> 2);
  if (v12) {
    operator delete(v12);
  }
  if (__p)
  {
    BOOL v21 = (char *)__p;
    operator delete(__p);
  }
}

uint64_t sub_1CD488C7C(unsigned __int8 *a1, llvm::Instruction *a2)
{
  uint64_t result = 1;
  switch(*((unsigned char *)a2 + 16))
  {
    case 0x1E:
    case 0x53:
      uint64_t result = *a1 == 0;
      break;
    case 0x28:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x4B:
    case 0x4C:
    case 0x4D:
    case 0x4E:
    case 0x51:
    case 0x52:
    case 0x55:
    case 0x56:
    case 0x57:
    case 0x59:
    case 0x5A:
    case 0x5B:
    case 0x5C:
    case 0x5D:
    case 0x5F:
      uint64_t result = 0;
      break;
    case 0x54:
      uint64_t result = sub_1CD48B624((uint64_t)a1, a2);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t llvm::IRSimilarity::IRInstructionMapper::mapToLegalUnsigned(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  *(unsigned char *)(a1 + 56) = 0;
  if (*(unsigned char *)(a1 + 57)) {
    *(unsigned char *)(a1 + 58) = 1;
  }
  *(unsigned char *)(a1 + 57) = 1;
  if (*a2) {
    uint64_t v8 = *a2 - 24;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 80);
  uint64_t v10 = sub_1CB906F34(*(uint64_t **)(a1 + 64), 160, 3);
  *(void *)uint64_t v10 = 0;
  *(void *)(v10 + 8) = 0;
  *(void *)(v10 + 16) = v8;
  *(void *)(v10 + 24) = v10 + 40;
  *(void *)(v10 + 32) = 0x400000000;
  *(unsigned char *)(v10 + 72) = 1;
  *(unsigned char *)(v10 + 76) = 0;
  *(unsigned char *)(v10 + 80) = 0;
  *(unsigned char *)(v10 + 88) = 0;
  *(unsigned char *)(v10 + 112) = 0;
  *(void *)(v10 + 120) = v10 + 136;
  *(void *)(v10 + 128) = 0x400000000;
  *(void *)(v10 + 152) = v9;
  llvm::IRSimilarity::IRInstructionData::initializeInstruction(v10);
  uint64_t v11 = *(uint64_t **)(a4 + 8);
  if ((unint64_t)v11 >= *(void *)(a4 + 16))
  {
    uint64_t v12 = sub_1CBF63C18((void **)a4, v10);
  }
  else
  {
    *uint64_t v11 = v10;
    uint64_t v12 = v11 + 1;
  }
  *(void *)(a4 + 8) = v12;
  uint64_t v13 = *a2;
  uint64_t v14 = *a2 - 24;
  if (!*a2) {
    uint64_t v14 = 0;
  }
  if (*(unsigned char *)(v14 + 16) == 30)
  {
    llvm::IRSimilarity::IRInstructionData::setBranchSuccessors(v10, a1 + 32);
    uint64_t v13 = *a2;
  }
  uint64_t v15 = v13 - 24;
  if (!v13) {
    uint64_t v15 = 0;
  }
  if (*(unsigned char *)(v15 + 16) == 84)
  {
    llvm::IRSimilarity::IRInstructionData::setCalleeName((llvm::IRSimilarity::IRInstructionData *)v10, *(unsigned __int8 *)(a1 + 59));
    uint64_t v13 = *a2;
  }
  if (v13) {
    uint64_t v16 = v13 - 24;
  }
  else {
    uint64_t v16 = 0;
  }
  if (*(unsigned char *)(v16 + 16) == 83) {
    llvm::IRSimilarity::IRInstructionData::setPHIPredecessors(v10, a1 + 32);
  }
  uint64_t v17 = *(unsigned int *)(a1 + 4);
  uint64_t v21 = v10;
  uint64_t v22 = v17;
  sub_1CD48B710((uint64_t)v23, a1 + 8, &v21, &v22);
  uint64_t result = *(unsigned int *)(*(void *)v23 + 8);
  v23[0] = *(_DWORD *)(*(void *)v23 + 8);
  if (v24) {
    ++*(_DWORD *)(a1 + 4);
  }
  uint64_t v19 = *(_DWORD **)(a3 + 8);
  if ((unint64_t)v19 >= *(void *)(a3 + 16))
  {
    size_t v20 = sub_1CBFFBD60((char **)a3, v23);
    uint64_t result = v23[0];
  }
  else
  {
    _DWORD *v19 = result;
    size_t v20 = (char *)(v19 + 1);
  }
  *(void *)(a3 + 8) = v20;
  return result;
}

uint64_t llvm::IRSimilarity::IRInstructionMapper::mapToIllegalUnsigned(unsigned int *a1, void *a2, uint64_t a3, uint64_t a4, char a5)
{
  *((unsigned char *)a1 + 57) = 0;
  if (*((unsigned char *)a1 + 56)) {
    return *a1;
  }
  if (a5)
  {
    uint64_t v10 = *((void *)a1 + 10);
    uint64_t v11 = sub_1CB906F34(*((uint64_t **)a1 + 8), 160, 3);
    *(void *)uint64_t v11 = 0;
    *(void *)(v11 + 8) = 0;
    *(void *)(v11 + 16) = 0;
    *(void *)(v11 + 24) = v11 + 40;
    *(void *)(v11 + 32) = 0x400000000;
    *(unsigned char *)(v11 + 72) = 0;
    *(unsigned char *)(v11 + 76) = 0;
    *(unsigned char *)(v11 + 80) = 0;
    *(unsigned char *)(v11 + 88) = 0;
    *(unsigned char *)(v11 + 112) = 0;
    *(void *)(v11 + 120) = v11 + 136;
    *(void *)(v11 + 128) = 0x400000000;
    *(void *)(v11 + 152) = v10;
  }
  else
  {
    if (*a2) {
      uint64_t v12 = *a2 - 24;
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *((void *)a1 + 10);
    uint64_t v11 = sub_1CB906F34(*((uint64_t **)a1 + 8), 160, 3);
    *(void *)uint64_t v11 = 0;
    *(void *)(v11 + 8) = 0;
    *(void *)(v11 + 16) = v12;
    *(void *)(v11 + 24) = v11 + 40;
    *(void *)(v11 + 32) = 0x400000000;
    *(unsigned char *)(v11 + 72) = 0;
    *(unsigned char *)(v11 + 76) = 0;
    *(unsigned char *)(v11 + 80) = 0;
    *(unsigned char *)(v11 + 88) = 0;
    *(unsigned char *)(v11 + 112) = 0;
    *(void *)(v11 + 120) = v11 + 136;
    *(void *)(v11 + 128) = 0x400000000;
    *(void *)(v11 + 152) = v13;
    llvm::IRSimilarity::IRInstructionData::initializeInstruction(v11);
  }
  uint64_t v14 = *(uint64_t **)(a4 + 8);
  if ((unint64_t)v14 >= *(void *)(a4 + 16))
  {
    uint64_t v15 = sub_1CBF63C18((void **)a4, v11);
  }
  else
  {
    uint64_t *v14 = v11;
    uint64_t v15 = v14 + 1;
  }
  *(void *)(a4 + 8) = v15;
  *((unsigned char *)a1 + 56) = 1;
  uint64_t v6 = *a1;
  *a1 = v6 - 1;
  int v18 = v6;
  uint64_t v16 = *(_DWORD **)(a3 + 8);
  if ((unint64_t)v16 >= *(void *)(a3 + 16))
  {
    uint64_t v17 = sub_1CBFFBD60((char **)a3, &v18);
  }
  else
  {
    *uint64_t v16 = v6;
    uint64_t v17 = (char *)(v16 + 1);
  }
  *(void *)(a3 + 8) = v17;
  return v6;
}

llvm::IRSimilarity::IRSimilarityCandidate *llvm::IRSimilarity::IRSimilarityCandidate::IRSimilarityCandidate(llvm::IRSimilarity::IRSimilarityCandidate *this, unsigned int a2, int a3, llvm::IRSimilarity::IRInstructionData *a4, llvm::IRSimilarity::IRInstructionData *a5)
{
  *(_OWORD *)((char *)this + 24) = 0u;
  uint64_t v7 = (uint64_t *)((char *)this + 24);
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((void *)this + 6) = 0;
  uint64_t v8 = (char *)this + 48;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  int v9 = 1;
  int v10 = a3 + a2;
  int v30 = 1;
  if (a3 + a2 > a2)
  {
    unsigned int v11 = a2;
    uint64_t v12 = a4;
    do
    {
      uint64_t v13 = *((unsigned int *)v12 + 8);
      if (v13)
      {
        uint64_t v14 = (uint64_t *)*((void *)v12 + 3);
        uint64_t v15 = 8 * v13;
        do
        {
          uint64_t v31 = 0;
          uint64_t v31 = *v14;
          v25[0] = v31;
          std::string::size_type v27 = 0;
          if (!sub_1CBFFBC50(v7, v25, &v27)
            || v27 == (uint64_t *)(*((void *)this + 3) + 16 * *((unsigned int *)this + 10)))
          {
            sub_1CD48931C((uint64_t)&v27, (uint64_t)v7, &v31, &v30);
            sub_1CD4893B8((uint64_t)&v27, (uint64_t)v8, &v30, &v31);
            int v30 = ++v9;
          }
          ++v14;
          v15 -= 8;
        }
        while (v15);
      }
      v25[0] = *((void *)v12 + 2);
      std::string::size_type v27 = 0;
      if (!sub_1CBFFBC50(v7, v25, &v27)
        || v27 == (uint64_t *)(*((void *)this + 3) + 16 * *((unsigned int *)this + 10)))
      {
        v25[0] = *((void *)v12 + 2);
        sub_1CD48931C((uint64_t)&v27, (uint64_t)v7, v25, &v30);
        sub_1CD4893B8((uint64_t)&v27, (uint64_t)v8, &v30, (void *)v12 + 2);
        int v30 = ++v9;
      }
      ++v11;
      uint64_t v12 = (llvm::IRSimilarity::IRInstructionData *)*((void *)v12 + 1);
    }
    while (v11 != v10);
  }
  *((void *)this + 1) = a4;
  *((void *)this + 2) = a5;
  std::string::size_type v27 = 0;
  uint64_t v28 = 0;
  unsigned int v29 = 0;
  sub_1CD4894A8((uint64_t)this, (uint64_t)&v27);
  uint64_t v16 = v27;
  uint64_t v17 = &v27[v29];
  if (v28)
  {
    if (v29)
    {
      uint64_t v18 = 8 * v29;
      uint64_t v19 = v27;
      while ((*v19 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v19;
        v18 -= 8;
        if (!v18) {
          goto LABEL_20;
        }
      }
    }
    else
    {
      uint64_t v19 = v27;
    }
  }
  else
  {
LABEL_20:
    uint64_t v19 = &v27[v29];
  }
  size_t v20 = &v27[v29];
  if (v19 != v20)
  {
    do
    {
      uint64_t v26 = 0;
      uint64_t v21 = *v19;
      uint64_t v26 = v21;
      uint64_t v31 = v21;
      v25[0] = 0;
      if (!sub_1CBFFBC50(v7, &v31, v25)
        || v25[0] == *((void *)this + 3) + 16 * *((unsigned int *)this + 10))
      {
        uint64_t v31 = v21;
        sub_1CD48931C((uint64_t)v25, (uint64_t)v7, &v31, &v30);
        sub_1CD4893B8((uint64_t)v25, (uint64_t)v8, &v30, &v26);
        int v30 = ++v9;
      }
      uint64_t v22 = v19 + 1;
      uint64_t v19 = v17;
      if (v22 != v17)
      {
        uint64_t v19 = v22;
        while ((*v19 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          if (++v19 == v17)
          {
            uint64_t v19 = v17;
            break;
          }
        }
      }
    }
    while (v19 != v20);
    uint64_t v16 = v27;
  }
  MEMORY[0x1D25D9CD0](v16, 8);
  return this;
}

uint64_t sub_1CD48931C(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CBFFD518((uint64_t *)a2, a3, &v12);
  int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBFFD5B4(a2, (uint64_t)a3, a3, v12);
    int v9 = (uint64_t *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

_DWORD *sub_1CD4893B8(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    uint64_t v14 = 0;
LABEL_6:
    uint64_t result = sub_1CD48BE5C(a2, a3, v14);
    *uint64_t result = *a3;
    *((void *)result + 1) = *a4;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  unsigned int v10 = (37 * *a3) & (v8 - 1);
  uint64_t result = (_DWORD *)(*(void *)a2 + 16 * v10);
  int v12 = *result;
  if (*a3 != *result)
  {
    uint64_t v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        uint64_t v15 = result;
      }
      unsigned int v18 = v10 + v16++;
      unsigned int v10 = v18 & (v8 - 1);
      uint64_t result = (_DWORD *)(v9 + 16 * v10);
      int v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      uint64_t v14 = v15;
    }
    else {
      uint64_t v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

uint64_t sub_1CD4894A8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  for (i = *(void *)(*(void *)(result + 16) + 8); v2 != i; uint64_t v2 = *(void *)(v2 + 8))
  {
    uint64_t v5 = *(void *)(*(void *)(v2 + 16) + 40);
    uint64_t v6 = 0;
    v7[0] = v5;
    uint64_t result = sub_1CBFFBBB4((uint64_t *)a2, v7, &v6);
    if (!result || v6 == *(void *)a2 + 8 * *(unsigned int *)(a2 + 16)) {
      uint64_t result = sub_1CBB23C3C((_DWORD *)a2, &v5, (uint64_t)v7);
    }
  }
  return result;
}

BOOL checkNumberingAndReplace(uint64_t a1, int a2, int a3)
{
  int v17 = a3;
  int v8 = a3;
  uint64_t v5 = 1;
  sub_1CD48A510((uint64_t)&v9, &v8, 1);
  int v12 = a2;
  v13[0] = v9;
  v13[1] = v10;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  int v14 = v11;
  int v11 = 0;
  sub_1CD48C184((uint64_t)&v15, a1, &v12, (uint64_t)v13);
  uint64_t v6 = v15;
  LODWORD(a1) = v16;
  MEMORY[0x1D25D9CD0](v13[0], 4);
  MEMORY[0x1D25D9CD0](v9, 4);
  if (!a1)
  {
    if (*(_DWORD *)(v6 + 16) < 2u
      || (int *)(*(void *)(v6 + 8) + 4 * *(unsigned int *)(v6 + 24)) == sub_1CD48C650((uint64_t *)(v6 + 8), &v17))
    {
      return *(void *)(v6 + 8) + 4 * *(unsigned int *)(v6 + 24) != (void)sub_1CD48C650((uint64_t *)(v6 + 8), &v17);
    }
    else
    {
      sub_1CBB2A024((void *)(v6 + 8));
      sub_1CBF7CCE0(v6 + 8, &v17, (uint64_t)&v12);
      return 1;
    }
  }
  return v5;
}

uint64_t llvm::IRSimilarity::IRSimilarityCandidate::compareCommutativeOperandMapping(void *a1, uint64_t *a2)
{
  v20[0] = 0;
  v20[1] = 0;
  int v21 = 0;
  int v19 = 0;
  v18[0] = 0;
  v18[1] = 0;
  uint64_t v4 = a1[1];
  int v5 = *(_DWORD *)(v4 + 8);
  if (v5)
  {
    uint64_t v6 = *(uint64_t **)a2[1];
    uint64_t v7 = *(uint64_t **)v4;
    do
    {
      uint64_t v8 = *a1;
      uint64_t v9 = (uint64_t *)(*a1 + 24);
      uint64_t v10 = *v7;
      uint64_t v22 = 0;
      v23[0] = v10;
      if (sub_1CBFFBC50(v9, v23, &v22)) {
        uint64_t v11 = v22;
      }
      else {
        uint64_t v11 = *(void *)(v8 + 24) + 16 * *(unsigned int *)(v8 + 40);
      }
      sub_1CBF7CCE0((uint64_t)v20, (int *)(v11 + 8), (uint64_t)v23);
      uint64_t v12 = *a2;
      char v13 = (uint64_t *)(*a2 + 24);
      uint64_t v14 = *v6;
      uint64_t v22 = 0;
      v23[0] = v14;
      if (sub_1CBFFBC50(v13, v23, &v22)) {
        uint64_t v15 = v22;
      }
      else {
        uint64_t v15 = *(void *)(v12 + 24) + 16 * *(unsigned int *)(v12 + 40);
      }
      sub_1CBF7CCE0((uint64_t)v18, (int *)(v15 + 8), (uint64_t)v23);
      ++v7;
      ++v6;
      --v5;
    }
    while (v5);
    uint64_t v4 = a1[1];
  }
  if (sub_1CBFF92E0((uint64_t *)(*a1 + 24), a1[2], v4, (uint64_t)v18)) {
    uint64_t v16 = sub_1CBFF92E0((uint64_t *)(*a2 + 24), a2[2], a2[1], (uint64_t)v20);
  }
  else {
    uint64_t v16 = 0;
  }
  MEMORY[0x1D25D9CD0](v18[0], 4);
  MEMORY[0x1D25D9CD0](v20[0], 4);
  return v16;
}

BOOL llvm::IRSimilarity::IRSimilarityCandidate::checkRelativeLocations(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(a2 + 16);
  v21[0] = 0;
  v21[1] = 0;
  unsigned int v22 = 0;
  v19[0] = 0;
  v19[1] = 0;
  int v20 = 0;
  sub_1CD4894A8(*(void *)a1, (uint64_t)v21);
  sub_1CD4894A8(*(void *)a2, (uint64_t)v19);
  uint64_t v6 = v21[0];
  if (v22)
  {
    LODWORD(v7) = (v22 - 1) & ((v4 >> 4) ^ (v4 >> 9));
    uint64_t v8 = (uint64_t *)(v21[0] + 8 * v7);
    uint64_t v9 = *v8;
    if (v4 != *v8)
    {
      int v14 = 1;
      do
      {
        if (v9 == -4096)
        {
          uint64_t v6 = v21[0] + 8 * v22;
          goto LABEL_12;
        }
        int v17 = v7 + v14++;
        uint64_t v7 = v17 & (v22 - 1);
        uint64_t v9 = *(void *)(v21[0] + 8 * v7);
      }
      while (v4 != v9);
      uint64_t v8 = (uint64_t *)(v21[0] + 8 * v7);
    }
    uint64_t v6 = v21[0] + 8 * v22;
  }
  else
  {
LABEL_12:
    uint64_t v8 = (uint64_t *)v6;
  }
  if (!v20) {
    goto LABEL_15;
  }
  unsigned int v10 = (v20 - 1) & ((v5 >> 4) ^ (v5 >> 9));
  uint64_t v11 = *(void *)(v19[0] + 8 * v10);
  if (v5 != v11)
  {
    int v15 = 1;
    while (v11 != -4096)
    {
      unsigned int v18 = v10 + v15++;
      unsigned int v10 = v18 & (v20 - 1);
      uint64_t v11 = *(void *)(v19[0] + 8 * v10);
      if (v5 == v11) {
        goto LABEL_6;
      }
    }
LABEL_15:
    BOOL v13 = v8 == (uint64_t *)v6;
LABEL_16:
    BOOL v12 = v13;
    goto LABEL_19;
  }
LABEL_6:
  BOOL v12 = (v8 != (uint64_t *)v6) == (v10 != v20);
  if (v8 != (uint64_t *)v6 && v10 != v20)
  {
    BOOL v13 = *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
    goto LABEL_16;
  }
LABEL_19:
  MEMORY[0x1D25D9CD0](v19[0], 8);
  MEMORY[0x1D25D9CD0](v21[0], 8);
  return v12;
}

void *sub_1CD489AF4(void *result, uint64_t a2)
{
  uint64_t v2 = a2 + 24;
  uint64_t v3 = *(void *)(a2 + 32);
  if (v3 != a2 + 24)
  {
    uint64_t v4 = 0;
    uint64_t v5 = (uint64_t)(result + 4);
    do
    {
      uint64_t v6 = v3 - 56;
      if (!v3) {
        uint64_t v6 = 0;
      }
      uint64_t v7 = v6 + 72;
      uint64_t v8 = *(void *)(v6 + 80);
      if (v8 == v6 + 72)
      {
        uint64_t v10 = v4;
      }
      else
      {
        do
        {
          uint64_t v9 = v8 - 24;
          if (!v8) {
            uint64_t v9 = 0;
          }
          uint64_t v10 = (v4 + 1);
          uint64_t v12 = v9;
          uint64_t v13 = v4;
          uint64_t result = sub_1CBFFB304(v5, &v12, &v13, (uint64_t)v11);
          uint64_t v8 = *(void *)(v8 + 8);
          LODWORD(v4) = v10;
        }
        while (v8 != v7);
      }
      uint64_t v3 = *(void *)(v3 + 8);
      uint64_t v4 = v10;
    }
    while (v3 != v2);
  }
  return result;
}

int *sub_1CD489BC0(uint64_t a1, unsigned int a2, int a3)
{
  if (a2)
  {
    unsigned int v3 = a2 - 1;
    uint64_t v4 = (int *)(a1 + 32 * ((37 * a3) & (a2 - 1)));
    int v5 = *v4;
    if (*v4 == a3) {
      return v4;
    }
    int v7 = 1;
    LODWORD(v8) = (37 * a3) & v3;
    while (v5 != -1)
    {
      int v9 = v8 + v7++;
      uint64_t v8 = v9 & v3;
      int v5 = *(_DWORD *)(a1 + 32 * v8);
      if (v5 == a3) {
        return (int *)(a1 + 32 * v8);
      }
    }
  }
  uint64_t v8 = a2;
  return (int *)(a1 + 32 * v8);
}

_DWORD *llvm::IRSimilarity::IRSimilarityCandidate::createCanonicalMappingFor(_DWORD *result)
{
  uint64_t v1 = *((void *)result + 6);
  uint64_t v2 = result[16];
  unsigned int v3 = (unsigned int *)(v1 + 16 * v2);
  if (result[14])
  {
    if (v2)
    {
      uint64_t v4 = 16 * v2;
      int v5 = (unsigned int *)*((void *)result + 6);
      while (*v5 >= 0xFFFFFFFE)
      {
        v5 += 4;
        v4 -= 16;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      int v5 = (unsigned int *)*((void *)result + 6);
    }
  }
  else
  {
LABEL_6:
    int v5 = (unsigned int *)(v1 + 16 * v2);
  }
  uint64_t v6 = (unsigned int *)(v1 + 16 * v2);
  if (v5 != v6)
  {
    unsigned int v7 = 0;
    uint64_t v8 = (uint64_t)(result + 18);
    uint64_t v9 = (uint64_t)(result + 24);
    do
    {
      unint64_t v14 = *v5 | ((unint64_t)v7 << 32);
      sub_1CBFFD778(v8, &v14, (_DWORD *)&v14 + 1, (uint64_t)v13);
      unsigned int v11 = *v5;
      uint64_t v10 = v5 + 4;
      unint64_t v14 = v7 | ((unint64_t)v11 << 32);
      uint64_t result = sub_1CBFFD778(v9, &v14, (_DWORD *)&v14 + 1, (uint64_t)v13);
      ++v7;
      while (v10 != v3)
      {
        unsigned int v12 = *v10;
        v10 += 4;
        if (v12 <= 0xFFFFFFFD)
        {
          int v5 = v10 - 4;
          goto LABEL_14;
        }
      }
      int v5 = v3;
LABEL_14:
      ;
    }
    while (v5 != v6);
  }
  return result;
}

void sub_1CD489D38(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 32 * v3;
    int v5 = (void **)(*(void *)a1 + 8);
    while (1)
    {
      int v6 = *((_DWORD *)v5 - 2);
      if (v6 == -2) {
        goto LABEL_9;
      }
      if (v6 != -1) {
        break;
      }
LABEL_10:
      v5 += 4;
      v4 -= 32;
      if (!v4) {
        goto LABEL_11;
      }
    }
    unsigned int v7 = v5;
    sub_1CBFFD868(&v7);
LABEL_9:
    *((_DWORD *)v5 - 2) = -1;
    goto LABEL_10;
  }

  sub_1CD48C738(a1);
}

void sub_1CD489E00(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 320))
  {
    int v2 = *(void ***)(a1 + 296);
    uint64_t v3 = *(void ***)(a1 + 304);
    while (v3 != v2)
    {
      v3 -= 3;
      v4[0] = v3;
      sub_1CBFFD868(v4);
    }
    *(void *)(a1 + 304) = v2;
  }
  else
  {
    *(void *)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
    *(void *)(a1 + 312) = 0;
    memset(v4, 0, sizeof(v4));
    *(unsigned char *)(a1 + 320) = 1;
    int v5 = v4;
    sub_1CBFFBCEC((void ***)&v5);
  }
}

uint64_t llvm::IRSimilarity::IRSimilarityIdentifier::findSimilarity(llvm::IRSimilarity::IRSimilarityIdentifier *this, llvm::Module *a2)
{
  sub_1CD489E00((uint64_t)this);
  *((_WORD *)this + 140) = *((_WORD *)this + 144);
  *((unsigned char *)this + 251) = *((unsigned char *)this + 290);
  *((_WORD *)this + 141) = *(_WORD *)((char *)this + 291);
  memset(v8, 0, sizeof(v8));
  std::string __p = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  llvm::IRSimilarity::IRSimilarityIdentifier::populateMapper((uint64_t)this, (uint64_t)a2, (uint64_t)v8, (char **)&__p);
  llvm::IRSimilarity::IRSimilarityIdentifier::findCandidates((uint64_t)this, v8, &__p);
  if (__p)
  {
    int v6 = __p;
    operator delete(__p);
  }
  if (v8[0]) {
    operator delete(v8[0]);
  }
  return (uint64_t)this + 296;
}

void llvm::initializeIRSimilarityIdentifierWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5650, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CBFFB26C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5650, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::IRSimilarityIdentifierWrapperPass *llvm::IRSimilarityIdentifierWrapperPass::IRSimilarityIdentifierWrapperPass(llvm::IRSimilarityIdentifierWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::IRSimilarityIdentifierWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F26035E0;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5650, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CBFFB26C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5650, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::IRSimilarityIdentifierWrapperPass::doInitialization(llvm::IRSimilarityIdentifierWrapperPass *this, llvm::Module *a2)
{
}

uint64_t llvm::IRSimilarityIdentifierWrapperPass::doFinalization(llvm::IRSimilarityIdentifierWrapperPass *this, llvm::Module *a2)
{
  uint64_t v3 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3)
  {
    uint64_t v5 = sub_1CD48B278(v3);
    MEMORY[0x1D25D9CE0](v5, 0x10B2C4033E05AA0);
  }
  return 0;
}

uint64_t llvm::IRSimilarityIdentifierWrapperPass::runOnModule(llvm::IRSimilarity::IRSimilarityIdentifier **this, llvm::Module *a2)
{
  return 0;
}

uint64_t llvm::IRSimilarityAnalysis::run@<X0>(llvm::Module *a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v3 = (llvm::IRSimilarity::IRSimilarityIdentifier *)sub_1CD48B154(a2, byte_1EBD03208 == 0, byte_1EBD032C8 == 0, byte_1EBD03388, byte_1EBD03448 == 0);

  return llvm::IRSimilarity::IRSimilarityIdentifier::findSimilarity(v3, a1);
}

void llvm::IRSimilarityAnalysisPrinterPass::run()
{
}

void sub_1CD48A4CC(llvm::ModulePass *a1)
{
  sub_1CD48B4A0(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD48A504(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

uint64_t sub_1CD48A510(uint64_t a1, int *a2, uint64_t a3)
{
  if (a3)
  {
    unint64_t v6 = (a3 - 1) | ((unint64_t)(a3 - 1) >> 1) | (((a3 - 1) | ((unint64_t)(a3 - 1) >> 1)) >> 2);
    unint64_t v7 = v6 | (v6 >> 4) | ((v6 | (v6 >> 4)) >> 8);
    sub_1CBB23234((void *)a1, (((v7 | (v7 >> 16)) >> 32) | v7 | (v7 >> 16)) + 1);
    uint64_t v8 = 4 * a3;
    do
    {
      sub_1CBF7CCE0(a1, a2++, (uint64_t)&v10);
      v8 -= 4;
    }
    while (v8);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
  }
  return a1;
}

uint64_t sub_1CD48A5AC(int32x2_t *a1, _DWORD *a2)
{
  __int32 v2 = a1[2].i32[0];
  if (v2)
  {
    int32x2_t v3 = *a1;
    __int32 v4 = v2 - 1;
    LODWORD(v5) = (37 * *a2) & (v2 - 1);
    unint64_t v6 = (int *)(*(void *)a1 + 4 * v5);
    int v7 = *v6;
    if (*a2 == *v6)
    {
LABEL_3:
      *unint64_t v6 = -2;
      a1[1] = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
      return 1;
    }
    int v9 = 1;
    while (v7 != -1)
    {
      int v10 = v5 + v9++;
      uint64_t v5 = v10 & v4;
      int v7 = *(_DWORD *)(*(void *)&v3 + 4 * v5);
      if (*a2 == v7)
      {
        unint64_t v6 = (int *)(*(void *)&v3 + 4 * v5);
        goto LABEL_3;
      }
    }
  }
  return 0;
}

int *sub_1CD48A634(uint64_t *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (37 * *a2) & (v3 - 1);
    uint64_t result = (int *)(v2 + 16 * v4);
    int v6 = *result;
    if (*a2 == *result) {
      return result;
    }
    int v7 = 1;
    while (v6 != -1)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      int v6 = *(_DWORD *)(v2 + 16 * v4);
      if (*a2 == v6) {
        return (int *)(v2 + 16 * v4);
      }
    }
  }
  return (int *)(v2 + 16 * v3);
}

uint64_t sub_1CD48A6A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 2;
  if (a2)
  {
    *(void *)(a1 + 48) = sub_1CBC13470((void **)(a1 + 40), &v4);
    sub_1CBFFB3F8((void *)a1);
  }
  return a1;
}

__n128 *sub_1CD48A70C(uint64_t a1, unsigned int a2, int a3, llvm::IRSimilarity::IRInstructionData *a4, llvm::IRSimilarity::IRInstructionData *a5)
{
  int v6 = *(llvm::IRSimilarity::IRSimilarityCandidate **)(a1 + 8);
  if ((unint64_t)v6 < *(void *)(a1 + 16)) {
    uint64_t result = (__n128 *)((char *)llvm::IRSimilarity::IRSimilarityCandidate::IRSimilarityCandidate(v6, a2, a3, a4, a5)
  }
                      + 120);
  else {
    uint64_t result = sub_1CBFFB800((__n128 **)a1, a2, a3, a4, a5);
  }
  *(void *)(a1 + 8) = result;
  return result;
}

__n128 sub_1CD48A754(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  unint64_t v3 = a2[1].n128_u64[0];
  *a1 = *a2;
  a1[1].n128_u64[1] = 0;
  a1[2].n128_u64[0] = 0;
  a1[1].n128_u64[0] = v3;
  a1[2].n128_u32[2] = 0;
  a1[1].n128_u64[1] = a2[1].n128_u64[1];
  a2[1].n128_u64[1] = 0;
  a1[2].n128_u32[0] = a2[2].n128_u32[0];
  a2[2].n128_u32[0] = 0;
  LODWORD(v3) = a1[2].n128_u32[1];
  a1[2].n128_u32[1] = a2[2].n128_u32[1];
  a2[2].n128_u32[1] = v3;
  LODWORD(v3) = a1[2].n128_u32[2];
  a1[2].n128_u32[2] = a2[2].n128_u32[2];
  a2[2].n128_u32[2] = v3;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u32[0] = 0;
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a1[3].n128_u32[2] = a2[3].n128_u32[2];
  a2[3].n128_u32[2] = 0;
  LODWORD(v3) = a1[3].n128_u32[3];
  a1[3].n128_u32[3] = a2[3].n128_u32[3];
  a2[3].n128_u32[3] = v3;
  LODWORD(v3) = a1[4].n128_u32[0];
  a1[4].n128_u32[0] = a2[4].n128_u32[0];
  a2[4].n128_u32[0] = v3;
  a1[4].n128_u64[1] = 0;
  a1[5].n128_u64[0] = 0;
  a1[5].n128_u32[2] = 0;
  a1[4].n128_u64[1] = a2[4].n128_u64[1];
  a2[4].n128_u64[1] = 0;
  a1[5].n128_u32[0] = a2[5].n128_u32[0];
  a2[5].n128_u32[0] = 0;
  LODWORD(v3) = a1[5].n128_u32[1];
  a1[5].n128_u32[1] = a2[5].n128_u32[1];
  a2[5].n128_u32[1] = v3;
  LODWORD(v3) = a1[5].n128_u32[2];
  a1[5].n128_u32[2] = a2[5].n128_u32[2];
  a2[5].n128_u32[2] = v3;
  a1[6].n128_u64[0] = 0;
  a1[6].n128_u64[1] = 0;
  a1[7].n128_u32[0] = 0;
  a1[6].n128_u64[0] = a2[6].n128_u64[0];
  a2[6].n128_u64[0] = 0;
  a1[6].n128_u32[2] = a2[6].n128_u32[2];
  a2[6].n128_u32[2] = 0;
  LODWORD(v3) = a1[6].n128_u32[3];
  a1[6].n128_u32[3] = a2[6].n128_u32[3];
  a2[6].n128_u32[3] = v3;
  LODWORD(v3) = a1[7].n128_u32[0];
  a1[7].n128_u32[0] = a2[7].n128_u32[0];
  a2[7].n128_u32[0] = v3;
  return result;
}

void *sub_1CD48A868(void *a1)
{
  return a1;
}

_DWORD *sub_1CD48A8BC(_DWORD *result)
{
  uint64_t v1 = result;
  int v2 = result[2];
  if (!v2 && !result[3]) {
    return result;
  }
  uint64_t v3 = result[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      *((void *)v1 + 1) = 0;
      return result;
    }
    uint64_t v4 = *(void *)result;
    uint64_t v5 = 32 * v3;
    while (1)
    {
      if (*(_DWORD *)v4 == -2) {
        goto LABEL_9;
      }
      if (*(_DWORD *)v4 != -1) {
        break;
      }
LABEL_10:
      v4 += 32;
      v5 -= 32;
      if (!v5) {
        goto LABEL_11;
      }
    }
    __n128 result = (_DWORD *)MEMORY[0x1D25D9CD0](*(void *)(v4 + 8), 4);
LABEL_9:
    *(_DWORD *)uint64_t v4 = -1;
    goto LABEL_10;
  }

  return sub_1CD48AEA0(result);
}

_DWORD *sub_1CD48A974(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    unint64_t v14 = 0;
LABEL_6:
    __n128 result = sub_1CD48AA80(a2, a3, v14);
    *__n128 result = *a3;
    *((void *)result + 2) = 0;
    *((void *)result + 3) = 0;
    *((void *)result + 1) = 0;
    *(_OWORD *)(result + 2) = *(_OWORD *)a4;
    *((void *)result + 3) = *(void *)(a4 + 16);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  uint64_t v10 = (37 * *a3) & (v8 - 1);
  __n128 result = (_DWORD *)(*(void *)a2 + 32 * v10);
  int v12 = *result;
  if (*a3 != *result)
  {
    int v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        int v15 = result;
      }
      int v18 = v10 + v16++;
      uint64_t v10 = v18 & (v8 - 1);
      __n128 result = (_DWORD *)(v9 + 32 * v10);
      int v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      unint64_t v14 = v15;
    }
    else {
      unint64_t v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 32 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

_DWORD *sub_1CD48AA80(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD48AC08(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      unsigned int v17 = v16 - 1;
      uint64_t v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      int v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          int v12 = a3;
        }
        int v22 = v18 + v20++;
        uint64_t v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD48AC08(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  unsigned int v9 = v8 - 1;
  uint64_t v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  int v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      int v12 = a3;
    }
    int v15 = v10 + v13++;
    uint64_t v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD48AC08(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD48ACD4(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      *__n128 result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CD48ACD4(uint64_t a1, int *a2, int *a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -1;
      v7 += 8;
      v8 -= 32;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(a1 + 16) - 1;
        uint64_t v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)a1 + 32 * v11;
        int v13 = *(_DWORD *)v12;
        if (v9 != *(_DWORD *)v12)
        {
          uint64_t v14 = 0;
          int v15 = 1;
          while (v13 != -1)
          {
            if (v14) {
              BOOL v16 = 0;
            }
            else {
              BOOL v16 = v13 == -2;
            }
            if (v16) {
              uint64_t v14 = v12;
            }
            int v17 = v11 + v15++;
            uint64_t v11 = v17 & v10;
            uint64_t v12 = *(void *)a1 + 32 * v11;
            int v13 = *(_DWORD *)v12;
            if (v9 == *(_DWORD *)v12) {
              goto LABEL_7;
            }
          }
          if (v14) {
            uint64_t v12 = v14;
          }
        }
LABEL_7:
        *(_DWORD *)uint64_t v12 = v9;
        *(void *)(v12 + 16) = 0;
        *(void *)(v12 + 24) = 0;
        *(void *)(v12 + 8) = 0;
        *(_OWORD *)(v12 + 8) = *(_OWORD *)(v4 + 2);
        *(void *)(v12 + 24) = *((void *)v4 + 3);
        *((void *)v4 + 1) = 0;
        *((void *)v4 + 2) = 0;
        *((void *)v4 + 3) = 0;
        ++*(_DWORD *)(a1 + 8);
        uint64_t v18 = (void **)(v4 + 2);
        sub_1CBFFD868(&v18);
      }
      v4 += 8;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD48AE0C(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1CBFCBCC4(a1 + 24, (uint64_t)a2 + 24);
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = 0;
  sub_1CBFCBCC4(a1 + 48, (uint64_t)(a2 + 3));
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  sub_1CBFFB950(a1 + 72, (uint64_t)a2 + 72);
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  sub_1CBFFB950(a1 + 96, (uint64_t)(a2 + 6));
  return a1;
}

_DWORD *sub_1CD48AEA0(_DWORD *a1)
{
  int v2 = a1[2];
  __n128 result = (_DWORD *)sub_1CD48AF5C((uint64_t)a1);
  if (v2)
  {
    int v4 = 1 << (33 - __clz(v2 - 1));
    if (v4 <= 64) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = v4;
    }
    if (v5 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v6 = 32 * v5;
      int v7 = *(_DWORD **)a1;
      do
      {
        *int v7 = -1;
        v7 += 8;
        v6 -= 32;
      }
      while (v6);
      return result;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return result;
    }
    unsigned int v5 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  return sub_1CBFFB9D0(a1, v5);
}

uint64_t sub_1CD48AF5C(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  if (v1)
  {
    uint64_t v2 = 32 * v1;
    uint64_t v3 = (void *)(*(void *)result + 8);
    do
    {
      if (*((_DWORD *)v3 - 2) <= 0xFFFFFFFD) {
        __n128 result = MEMORY[0x1D25D9CD0](*v3, 4);
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
  return result;
}

void *sub_1CD48AFB0(void *a1)
{
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_1CD48AFF4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    int v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      for (unint64_t i = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 64; i <= v8; i += 64)
        MEMORY[0x1D25D9CD0](*(void *)(i - 64), 8);
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v10 = *(unsigned int *)(a1 + 72);
  if (v10)
  {
    uint64_t v11 = *(void **)(a1 + 64);
    uint64_t v12 = &v11[2 * v10];
    do
    {
      unint64_t v13 = *v11 + v11[1];
      for (unint64_t j = ((*v11 + 7) & 0xFFFFFFFFFFFFFFF8) + 64; j <= v13; j += 64)
        MEMORY[0x1D25D9CD0](*(void *)(j - 64), 8);
      v11 += 2;
    }
    while (v11 != v12);
  }

  return sub_1CBFFBB10(a1);
}

void llvm::callDefaultCtor<llvm::IRSimilarityIdentifierWrapperPass>()
{
}

uint64_t sub_1CD48B154(uint64_t a1, char a2, char a3, char a4, char a5)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a1 + 32;
  *(void *)(a1 + 24) = 0x400000000;
  *(void *)(a1 + 64) = a1 + 80;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = a1 + 128;
  *(void *)(a1 + 120) = 0x400000000;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = a1 + 176;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 184) = 0;
  sub_1CD48B20C(a1 + 192, a1, (uint64_t *)(a1 + 96));
  *(unsigned char *)(a1 + 288) = a2;
  *(unsigned char *)(a1 + 289) = a3;
  *(unsigned char *)(a1 + 290) = a4;
  *(unsigned char *)(a1 + 291) = a5;
  *(unsigned char *)(a1 + 292) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 320) = 0;
  return a1;
}

uint64_t sub_1CD48B20C(uint64_t a1, uint64_t a2, uint64_t *__sz)
{
  *(_DWORD *)a1 = -3;
  *(void *)(a1 + 4) = 0;
  *(void *)(a1 + 20) = 0;
  *(void *)(a1 + 12) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a2;
  *(void *)(a1 + 72) = __sz;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  uint64_t v4 = sub_1CB906F34(__sz, 16, 3);
  *(void *)uint64_t v4 = v4 | 4;
  *(void *)(v4 + 8) = v4;
  *(void *)(a1 + 80) = v4;
  return a1;
}

uint64_t sub_1CD48B278(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 320))
  {
    uint64_t v3 = (void **)(a1 + 296);
    sub_1CBFFBCEC(&v3);
    *(unsigned char *)(a1 + 320) = 0;
  }
  sub_1CD48B2E8(a1 + 192);
  sub_1CBFFBB10(a1 + 96);
  sub_1CBFFBA64(a1 + 96);
  sub_1CD48B324(a1);
  return sub_1CBFFBA64(a1);
}

uint64_t sub_1CD48B2E8(uint64_t a1)
{
  return a1;
}

uint64_t sub_1CD48B324(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      unint64_t v9 = (v6 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v10 = v9 + 160;
      while (v10 <= v8)
      {
        uint64_t v11 = sub_1CD48B438(v9);
        unint64_t v10 = v11 + 320;
        unint64_t v9 = v11 + 160;
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v12 = *(unsigned int *)(a1 + 72);
  if (v12)
  {
    unint64_t v13 = *(void **)(a1 + 64);
    uint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = (*v13 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v16 = *v13 + v13[1];
      unint64_t v17 = v15 + 160;
      while (v17 <= v16)
      {
        uint64_t v18 = sub_1CD48B438(v15);
        unint64_t v17 = v18 + 320;
        unint64_t v15 = v18 + 160;
      }
      v13 += 2;
    }
    while (v13 != v14);
  }

  return sub_1CBFFBB10(a1);
}

uint64_t sub_1CD48B438(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  if (v2 != (void *)(a1 + 136)) {
    free(v2);
  }
  if (*(unsigned char *)(a1 + 112))
  {
    if (*(char *)(a1 + 111) < 0) {
      operator delete(*(void **)(a1 + 88));
    }
    *(unsigned char *)(a1 + 112) = 0;
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3 != (void *)(a1 + 40)) {
    free(v3);
  }
  return a1;
}

void sub_1CD48B4A0(llvm::ModulePass *this)
{
  *(void *)this = &unk_1F26035E0;
  uint64_t v2 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2)
  {
    uint64_t v3 = sub_1CD48B278(v2);
    MEMORY[0x1D25D9CE0](v3, 0x10B2C4033E05AA0);
  }

  llvm::ModulePass::~ModulePass(this);
}

uint64_t sub_1CD48B518(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *a1;
  uint64_t v6 = *((unsigned int *)a1 + 2);
  if (*a1 + 8 * v6 == a2)
  {
    if (v6 >= *((_DWORD *)a1 + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(v5 + 8 * v6) = *a3;
    unsigned int v10 = *((_DWORD *)a1 + 2) + 1;
    *((_DWORD *)a1 + 2) = v10;
    return *a1 + 8 * v10 - 8;
  }
  else
  {
    if (v6 >= *((_DWORD *)a1 + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = (void *)(v5 + 8 * ((a2 - v5) >> 3));
    *(void *)(v5 + 8 * v6) = *(void *)(v5 + 8 * v6 - 8);
    uint64_t v8 = *a1 + 8 * v6 - 8;
    if ((void *)v8 != v7)
    {
      memmove(v7 + 1, v7, v8 - (void)v7);
      LODWORD(v6) = *((_DWORD *)a1 + 2);
    }
    *((_DWORD *)a1 + 2) = v6 + 1;
    *uint64_t v7 = *a3;
  }
  return (uint64_t)v7;
}

uint64_t sub_1CD48B624(uint64_t a1, llvm::Instruction *this)
{
  uint64_t v4 = *((void *)this - 4);
  if (!v4 || *(unsigned char *)(v4 + 16) || *(void *)(v4 + 24) != *((void *)this + 9)) {
    goto LABEL_3;
  }
  int v6 = *(_DWORD *)(v4 + 36);
  if (v6 > 196) {
    return llvm::Instruction::isLifetimeStartOrEnd(this)
  }
        || (sub_1CBFFBEB4((uint64_t)this) & 1) != 0
        || *(unsigned char *)(a1 + 2) == 0;
  if ((v6 - 56) < 3) {
    return 2;
  }
  if (v6)
  {
    return llvm::Instruction::isLifetimeStartOrEnd(this)
        || (sub_1CBFFBEB4((uint64_t)this) & 1) != 0
        || *(unsigned char *)(a1 + 2) == 0;
  }
  else
  {
LABEL_3:
    return sub_1CBFFBE34(a1, (uint64_t)this);
  }
}

uint64_t sub_1CD48B710(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD48B7A8(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v12);
  unint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD48BC2C(a2, a3, v12);
    unint64_t v9 = (const llvm::IRSimilarity::IRInstructionData **)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD48B7A8(uint64_t a1, int a2, uint64_t *a3, const llvm::IRSimilarity::IRInstructionData ***a4)
{
  if (a2)
  {
    uint64_t v7 = 0;
    int v8 = a2 - 1;
    unsigned int v10 = (a2 - 1) & sub_1CBFFC13C(*a3);
    for (int i = 1; ; ++i)
    {
      uint64_t v12 = (const llvm::IRSimilarity::IRInstructionData **)(a1 + 16 * v10);
      unint64_t v13 = (llvm::IRSimilarity *)*a3;
      uint64_t v14 = *v12;
      BOOL v15 = *a3 == -1 || v13 == 0;
      BOOL v16 = v15 || v14 == 0;
      if (v16 || (const llvm::IRSimilarity::IRInstructionData *)((char *)v14 + 1) == 0)
      {
        if (v13 == v14)
        {
LABEL_16:
          uint64_t result = 1;
          goto LABEL_17;
        }
      }
      else
      {
        if (llvm::IRSimilarity::isClose(v13, v14, v9)) {
          goto LABEL_16;
        }
        uint64_t v14 = *v12;
      }
      if (!v14) {
        break;
      }
      if (v7) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v14 == (const llvm::IRSimilarity::IRInstructionData *)-1;
      }
      if (v19) {
        uint64_t v7 = (const llvm::IRSimilarity::IRInstructionData **)(a1 + 16 * v10);
      }
      unsigned int v20 = v10 + i;
      unsigned int v10 = v20 & v8;
    }
    uint64_t result = 0;
    if (v7) {
      uint64_t v12 = v7;
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
LABEL_17:
  *a4 = v12;
  return result;
}

unint64_t sub_1CD48B888(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v12 = sub_1CBF65470();
  return sub_1CD48BAC4((char *)v9, v9, (char *)v10, *a1, a2, a3, a4);
}

unint64_t sub_1CD48B940(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  uint64_t v10 = sub_1CBF65470();
  uint64_t v11 = *a1;
  uint64_t v15 = v10;
  uint64_t v13 = v11;
  return sub_1CD48BAC4((char *)&v13, v14, (char *)&v14[3] + 8, *a2, a3, a4, a5);
}

unint64_t sub_1CD48BA0C(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  memset(v10, 0, sizeof(v10));
  uint64_t v6 = sub_1CBF65470();
  uint64_t v7 = *a1;
  uint64_t v11 = v6;
  uint64_t v9 = v7;
  return sub_1CBFFD088((char *)&v9, 0, v10, (char *)&v10[3] + 8, a2, a3);
}

unint64_t sub_1CD48BAC4(char *a1, void *__dst, char *a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v15 = 0;
  uint64_t v12 = sub_1CBFFCBA0(a1, &v15, __dst, (unint64_t)a3, a4);
  uint64_t v16 = v15;
  uint64_t v13 = sub_1CBFFCBA0(a1, &v16, v12, (unint64_t)a3, *a5);
  return sub_1CBFFD088(a1, v16, v13, a3, a6, a7);
}

unint64_t sub_1CD48BB60(void *a1, uint64_t a2)
{
  unint64_t v4 = sub_1CBF65470();
  unint64_t v5 = a2 - (void)a1;
  if ((unint64_t)(a2 - (void)a1) > 0x40)
  {
    sub_1CBFFCE40(a1, v4, v9);
    unint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFC0) - 64;
    if ((v5 & 0xFFFFFFFFFFFFFFC0) != 0x40)
    {
      int v8 = a1 + 8;
      do
      {
        sub_1CBFFCF68(v9, v8);
        v8 += 8;
        v7 -= 64;
      }
      while (v7);
    }
    if ((v5 & 0x3F) != 0) {
      sub_1CBFFCF68(v9, (void *)(a2 - 64));
    }
    return sub_1CBFFD150(v9, v5);
  }
  else
  {
    return sub_1CBAE06B8(a1, a2 - (void)a1, v4);
  }
}

const llvm::IRSimilarity::IRInstructionData **sub_1CD48BC2C(uint64_t a1, uint64_t *a2, const llvm::IRSimilarity::IRInstructionData **a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD48BCDC(a1, v6);
  int v8 = 0;
  sub_1CD48B7A8(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD48BCDC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD48BDA4(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = 0;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD48BDA4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = 0;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((unint64_t)(*(void *)a2 + 1) >= 2)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD48B7A8(*(void *)v5, *(_DWORD *)(v5 + 16), (uint64_t *)a2, &v10);
      uint64_t v9 = v10;
      unsigned int *v10 = *(const llvm::IRSimilarity::IRInstructionData **)a2;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

_DWORD *sub_1CD48BE5C(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD48BFE4(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      uint64_t v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          uint64_t v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD48BFE4(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  uint64_t v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      uint64_t v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD48BFE4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD48C0B0(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD48C0B0(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    uint64_t v4 = *(_DWORD **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *uint64_t v4 = -1;
      v4 += 4;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 4)
  {
    int v6 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & (37 * v6);
      uint64_t v9 = *(void *)result + 16 * v8;
      int v10 = *(_DWORD *)v9;
      if (v6 != *(_DWORD *)v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -1)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -2;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          uint64_t v9 = *(void *)result + 16 * (v14 & v7);
          int v10 = *(_DWORD *)v9;
          if (v6 == *(_DWORD *)v9) {
            goto LABEL_7;
          }
        }
        if (v11) {
          uint64_t v9 = v11;
        }
      }
LABEL_7:
      *(_DWORD *)uint64_t v9 = v6;
      *(void *)(v9 + 8) = *((void *)a2 + 1);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

_DWORD *sub_1CD48C184(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    unsigned int v14 = 0;
LABEL_6:
    uint64_t result = sub_1CD48C2B0(a2, a3, v14);
    *uint64_t result = *a3;
    result[6] = 0;
    *((void *)result + 1) = 0;
    *((void *)result + 2) = 0;
    *((void *)result + 1) = *(void *)a4;
    *(void *)a4 = 0;
    result[4] = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = 0;
    int v15 = result[5];
    result[5] = *(_DWORD *)(a4 + 12);
    *(_DWORD *)(a4 + 12) = v15;
    int v16 = result[6];
    result[6] = *(_DWORD *)(a4 + 16);
    *(_DWORD *)(a4 + 16) = v16;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  uint64_t v10 = (37 * *a3) & (v8 - 1);
  uint64_t result = (_DWORD *)(*(void *)a2 + 32 * v10);
  int v12 = *result;
  if (*a3 != *result)
  {
    int v17 = 0;
    int v18 = 1;
    while (v12 != -1)
    {
      if (v17) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v12 == -2;
      }
      if (v19) {
        int v17 = result;
      }
      int v20 = v10 + v18++;
      uint64_t v10 = v20 & (v8 - 1);
      uint64_t result = (_DWORD *)(v9 + 32 * v10);
      int v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v17) {
      unsigned int v14 = v17;
    }
    else {
      unsigned int v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 32 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

_DWORD *sub_1CD48C2B0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD48C438(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      unsigned int v17 = v16 - 1;
      uint64_t v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      int v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          int v12 = a3;
        }
        int v22 = v18 + v20++;
        uint64_t v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD48C438(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  unsigned int v9 = v8 - 1;
  uint64_t v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  int v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      int v12 = a3;
    }
    int v15 = v10 + v13++;
    uint64_t v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD48C438(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD48C504(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      *uint64_t result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD48C504(uint64_t result, int *a2, int *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -1;
      v7 += 8;
      v8 -= 32;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        int v10 = *(_DWORD *)(v5 + 16) - 1;
        uint64_t v11 = v10 & (37 * v9);
        uint64_t v12 = *(void *)v5 + 32 * v11;
        int v13 = *(_DWORD *)v12;
        if (v9 != *(_DWORD *)v12)
        {
          uint64_t v16 = 0;
          int v17 = 1;
          while (v13 != -1)
          {
            if (v16) {
              BOOL v18 = 0;
            }
            else {
              BOOL v18 = v13 == -2;
            }
            if (v18) {
              uint64_t v16 = v12;
            }
            int v19 = v11 + v17++;
            uint64_t v11 = v19 & v10;
            uint64_t v12 = *(void *)v5 + 32 * v11;
            int v13 = *(_DWORD *)v12;
            if (v9 == *(_DWORD *)v12) {
              goto LABEL_7;
            }
          }
          if (v16) {
            uint64_t v12 = v16;
          }
        }
LABEL_7:
        *(_DWORD *)uint64_t v12 = v9;
        *(void *)(v12 + 8) = 0;
        *(void *)(v12 + 16) = 0;
        *(_DWORD *)(v12 + 24) = 0;
        *(void *)(v12 + 8) = *((void *)v4 + 1);
        *((void *)v4 + 1) = 0;
        *(_DWORD *)(v12 + 16) = v4[4];
        v4[4] = 0;
        int v14 = *(_DWORD *)(v12 + 20);
        *(_DWORD *)(v12 + 20) = v4[5];
        v4[5] = v14;
        int v15 = *(_DWORD *)(v12 + 24);
        *(_DWORD *)(v12 + 24) = v4[6];
        v4[6] = v15;
        ++*(_DWORD *)(v5 + 8);
        uint64_t result = MEMORY[0x1D25D9CD0](0, 4);
      }
      v4 += 8;
    }
    while (v4 != a3);
  }
  return result;
}

int *sub_1CD48C650(uint64_t *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (37 * *a2) & (v3 - 1);
    uint64_t result = (int *)(v2 + 4 * v4);
    int v6 = *result;
    if (*a2 == *result) {
      return result;
    }
    int v7 = 1;
    while (v6 != -1)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      int v6 = *(_DWORD *)(v2 + 4 * v4);
      if (*a2 == v6) {
        return (int *)(v2 + 4 * v4);
      }
    }
  }
  return (int *)(v2 + 4 * v3);
}

uint64_t *sub_1CD48C6C0(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = (void **)(v3 + 8);
    do
    {
      if (*((_DWORD *)v5 - 2) <= 0xFFFFFFFD)
      {
        int v7 = v5;
        sub_1CBFFD868(&v7);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void sub_1CD48C738(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = (void **)(*(void *)a1 + 8);
    do
    {
      if (*((_DWORD *)v5 - 2) <= 0xFFFFFFFD)
      {
        int v10 = v5;
        sub_1CBFFD868(&v10);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
  }
  if (!v3)
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v7 = 0;
    int v8 = *(_DWORD **)a1;
LABEL_16:
    MEMORY[0x1D25D9CD0](v8, 8);
    sub_1CBFFB9D0(a1, v7);
    return;
  }
  int v6 = 1 << (33 - __clz(v3 - 1));
  if (v6 <= 64) {
    unsigned int v7 = 64;
  }
  else {
    unsigned int v7 = v6;
  }
  int v8 = *(_DWORD **)a1;
  if (v7 != a1[4]) {
    goto LABEL_16;
  }
  *((void *)a1 + 1) = 0;
  uint64_t v9 = 32 * v7;
  do
  {
    *int v8 = -1;
    v8 += 8;
    v9 -= 32;
  }
  while (v9);
}

BOOL llvm::RecurrenceDescriptor::areAllUsesIn(uint64_t a1, void *a2)
{
  int v3 = *(_DWORD *)(a1 + 20);
  if ((v3 & 0x40000000) != 0)
  {
    uint64_t v5 = *(uint64_t **)(a1 - 8);
    uint64_t v4 = v3 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v4 = v3 & 0x7FFFFFF;
    uint64_t v5 = (uint64_t *)(a1 - 32 * v4);
  }
  if (!v4) {
    return 1;
  }
  uint64_t v6 = 32 * v4 - 32;
  do
  {
    uint64_t v8 = *v5;
    v5 += 4;
    uint64_t v7 = v8;
    if (*(unsigned __int8 *)(v8 + 16) <= 0x1Bu) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = v7;
    }
    int v10 = sub_1CB896AE8((uint64_t)a2, v9);
    uint64_t v11 = a2[1];
    if (v11 == *a2) {
      uint64_t v12 = (unsigned int *)a2 + 5;
    }
    else {
      uint64_t v12 = (unsigned int *)(a2 + 2);
    }
    int v13 = (void *)(v11 + 8 * *v12);
    BOOL v15 = v10 == v13;
    BOOL result = v10 != v13;
    BOOL v15 = v15 || v6 == 0;
    v6 -= 32;
  }
  while (!v15);
  return result;
}

uint64_t llvm::RecurrenceDescriptor::isReductionPHI(llvm::RecurrenceDescriptor *this, llvm::PHINode *a2, llvm::Loop *a3, llvm::RecurrenceDescriptor *a4, llvm::DemandedBits *a5, llvm::AssumptionCache *a6, llvm::DominatorTree *a7)
{
  uint64_t v9 = *(void *)(**((void **)a2 + 4) + 56);
  uint64_t FnAttribute = llvm::Function::getFnAttribute(v9, "no-nans-fp-math", 0xFuLL);
  llvm::Attribute::getValueAsBool((llvm::Attribute *)&FnAttribute);
  uint64_t FnAttribute = llvm::Function::getFnAttribute(v9, "no-signed-zeros-fp-math", 0x17uLL);
  llvm::Attribute::getValueAsBool((llvm::Attribute *)&FnAttribute);
  uint64_t v10 = 1;
  if ((llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 1, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 2, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 3, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 4, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 5, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 7, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 6, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 9, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 8, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 15, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 11, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 10, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 13, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 12, (uint64_t)a2) & 1) == 0
    && (llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 16, (uint64_t)a2) & 1) == 0)
  {
    return llvm::RecurrenceDescriptor::AddReductionVar((uint64_t)this, 14, (uint64_t)a2);
  }
  return v10;
}

uint64_t sub_1CD48CC08(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CD45714C((_DWORD *)a1, &v13, &v14, (uint64_t)&v11);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v10 = (unint64_t)*a2;
    uint64_t v5 = *(_OWORD **)(a1 + 32);
    if ((unint64_t)v5 >= *(void *)(a1 + 40))
    {
      uint64_t v6 = sub_1CC00319C((void **)(a1 + 24), &v10);
    }
    else
    {
      *uint64_t v5 = v10;
      uint64_t v6 = v5 + 1;
    }
    *(void *)(a1 + 32) = v6;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v7 = (((unint64_t)v6 - v8) >> 4) - 1;
    *(_DWORD *)(v4 + 8) = v7;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(v11 + 8);
    uint64_t v8 = *(void *)(a1 + 24);
  }
  return v8 + 16 * v7 + 8;
}

const llvm::detail::DoubleAPFloat *llvm::RecurrenceDescriptor::getRecurrenceIdentity(void *a1, llvm::Type *a2, llvm::ConstantFP *this, char a4)
{
  switch((int)a2)
  {
    case 2:
      uint64_t v5 = this;
      unint64_t v6 = 1;
      goto LABEL_3;
    case 4:
      uint64_t v5 = this;
      unint64_t v6 = -1;
      uint64_t v7 = 1;
      goto LABEL_4;
    case 6:
      sub_1CBFD9168(*((_DWORD *)this + 2) >> 8, (llvm::APInt *)&v17);
      goto LABEL_25;
    case 7:
      sub_1CBA62420(*((_DWORD *)this + 2) >> 8, (llvm::APInt *)&v17);
LABEL_25:
      long long v10 = llvm::ConstantInt::get((llvm::ConstantInt **)this, (llvm::Type *)&v17, v16);
      if (LODWORD(v18[0]) >= 0x41 && v17) {
        MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
      }
      goto LABEL_28;
    case 8:
      uint64_t v5 = this;
      unint64_t v6 = -1;
      goto LABEL_3;
    case 10:
    case 14:
      if ((a4 & 8) != 0) {
        double v9 = 0.0;
      }
      else {
        double v9 = -0.0;
      }
      goto LABEL_35;
    case 11:
      double v9 = 1.0;
LABEL_35:
      return llvm::ConstantFP::get((llvm::ConstantFP **)this, a2, v9);
    case 12:
      int v14 = this;
      uint64_t v15 = 1;
      goto LABEL_31;
    case 13:
      int v14 = this;
      uint64_t v15 = 0;
LABEL_31:
      BOOL result = llvm::ConstantFP::getInfinity(v14, (llvm::Type *)v15);
      break;
    case 15:
    case 16:
      uint64_t v17 = 6;
      v18[0] = 0;
      long long v10 = (llvm::Value *)a1[2];
      v18[1] = v10;
      if (v10 != (llvm::Value *)-8192 && v10 != (llvm::Value *)-4096 && v10 != 0)
      {
        unint64_t v12 = *a1 & 0xFFFFFFFFFFFFFFF8;
        v18[0] = *(void *)v12;
        uint64_t v13 = (unint64_t *)v18[0];
        *(void *)unint64_t v12 = &v17;
        uint64_t v17 = v12 | 6;
        if (v13) {
          *uint64_t v13 = *v13 & 7 | (unint64_t)v18;
        }
        if (v10 != (llvm::Value *)-4096 && v10) {
          llvm::ValueHandleBase::RemoveFromUseList(&v17);
        }
      }
LABEL_28:
      BOOL result = v10;
      break;
    default:
      uint64_t v5 = this;
      unint64_t v6 = 0;
LABEL_3:
      uint64_t v7 = 0;
LABEL_4:
      BOOL result = (const llvm::detail::DoubleAPFloat *)llvm::ConstantInt::get(v5, v6, (const llvm::APInt *)v7);
      break;
  }
  return result;
}

uint64_t llvm::RecurrenceDescriptor::getOpcode(int a1)
{
  return dword_1CFAC35B0[a1 - 1];
}

uint64_t llvm::InductionDescriptor::getConstIntStepValue(llvm::InductionDescriptor *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (*(_WORD *)(v1 + 24)) {
    return 0;
  }
  else {
    return *(void *)(v1 + 32);
  }
}

uint64_t sub_1CD48CEE8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, char a8, char a9, void *a10, int a11)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 6;
  sub_1CC002D7C((llvm::ValueHandleBase *)a1, a2);
  *(void *)(a1 + 64) = a1 + 96;
  *(void *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 36) = a5;
  *(void *)(a1 + 40) = a6;
  *(void *)(a1 + 48) = a7;
  *(unsigned char *)(a1 + 56) = a8;
  *(unsigned char *)(a1 + 57) = a9;
  *(void *)(a1 + 72) = a1 + 96;
  *(void *)(a1 + 80) = 8;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 160) = a11;
  BOOL v18 = (unint64_t *)a10[1];
  if (v18 == (unint64_t *)*a10) {
    int v19 = (unsigned int *)a10 + 5;
  }
  else {
    int v19 = (unsigned int *)(a10 + 2);
  }
  uint64_t v20 = *v19;
  BOOL v21 = &v18[v20];
  if (v20)
  {
    uint64_t v22 = 8 * v20;
    while (*v18 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v18;
      v22 -= 8;
      if (!v22)
      {
        BOOL v18 = v21;
        break;
      }
    }
  }
  sub_1CC002B9C((llvm::SmallPtrSetImplBase *)(a1 + 64), v18, v21, v21);
  return a1;
}

llvm::ValueHandleBase *sub_1CD48CFE4(llvm::ValueHandleBase *this)
{
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2 != *((void **)this + 8)) {
    free(v2);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3 != -8192 && v3 != -4096 && v3 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(this);
  }
  return this;
}

uint64_t sub_1CD48D03C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = 0;
  if (!sub_1CBA0E618(a1, &v4, &v5) || v5 == *(void *)a1 + 16 * *(unsigned int *)(a1 + 16)) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + 16 * *(unsigned int *)(v5 + 8);
  }
}

void *sub_1CD48D0A8(int32x2_t *a1, void *a2)
{
  uint64_t v17 = 0;
  if (sub_1CB883B0C((uint64_t)a1, a2, &v17))
  {
    void *v17 = -8192;
    a1[1] = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  }
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = a2 + 2;
  if (a2 + 2 == v4)
  {
    a1[4] = (int32x2_t)a2;
  }
  else
  {
    uint64_t v6 = 0;
    unint64_t v7 = ((uint64_t)a2 - *(void *)&a1[3]) >> 4;
    do
    {
      uint64_t v8 = &v5[v6];
      *((_OWORD *)v8 - 1) = *(_OWORD *)&v5[v6];
      v6 += 2;
    }
    while (v8 + 2 != v4);
    a1[4] = (int32x2_t)&a2[v6];
    if (v6 * 8)
    {
      uint64_t v9 = a1[2].u32[0];
      uint64_t v10 = *(void *)a1 + 16 * v9;
      if (a1[1].i32[0])
      {
        if (v9)
        {
          uint64_t v11 = 16 * v9;
          uint64_t v12 = (uint64_t)*a1;
          while ((*(void *)v12 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v12 += 16;
            v11 -= 16;
            if (!v11) {
              goto LABEL_12;
            }
          }
        }
        else
        {
          uint64_t v12 = (uint64_t)*a1;
        }
      }
      else
      {
LABEL_12:
        uint64_t v12 = *(void *)a1 + 16 * v9;
      }
      uint64_t v13 = *(void *)a1 + 16 * v9;
LABEL_14:
      while (v12 != v13)
      {
        unint64_t v14 = *(unsigned int *)(v12 + 8);
        if (v7 < v14) {
          *(_DWORD *)(v12 + 8) = v14 - 1;
        }
        uint64_t v15 = v12 + 16;
        uint64_t v12 = v10;
        if (v15 != v10)
        {
          uint64_t v12 = v15;
          while ((*(void *)v12 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v12 += 16;
            if (v12 == v10)
            {
              uint64_t v12 = v10;
              goto LABEL_14;
            }
          }
        }
      }
    }
  }
  return a2;
}

uint64_t sub_1CD48D1F4(int **a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16) != 85) {
    return 0;
  }
  int v3 = *(_DWORD *)(a2 + 20);
  if ((v3 & 0x40000000) != 0) {
    uint64_t v4 = *(uint64_t **)(a2 - 8);
  }
  else {
    uint64_t v4 = (uint64_t *)(a2 - 32 * (v3 & 0x7FFFFFF));
  }
  return sub_1CD48D228(a1, *v4);
}

uint64_t sub_1CD48D228(int **a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (!v2 || *(void *)(v2 + 8)) {
    return 0;
  }
  unsigned int v4 = *(unsigned __int8 *)(a2 + 16);
  if (v4 < 0x1C || v4 - 81 > 1) {
    return 0;
  }
  **a1 = *(_WORD *)(a2 + 18) & 0x3F;
  return 1;
}

llvm::raw_ostream *llvm::GPUFunctionAnalysisResult::print(llvm::Value **this, llvm::raw_ostream *a2)
{
  int v3 = sub_1CB8E509C(a2, "GPUFunctionAnalysisResult for ");
  Name = llvm::Value::getName(*this);
  size_t v6 = v4;
  unint64_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  uint64_t v8 = sub_1CB8E509C(v3, "\n");
  uint64_t v9 = sub_1CB8E509C(v8, ".. HasMemorySync = ");
  if (*((unsigned char *)this + 8)) {
    uint64_t v10 = "true";
  }
  else {
    uint64_t v10 = "false";
  }
  uint64_t v11 = sub_1CB8E509C(v9, v10);
  uint64_t v12 = sub_1CB8E509C(v11, "\n");
  uint64_t v13 = sub_1CB8E509C(v12, ".. HasLoaderState = ");
  if (*((unsigned char *)this + 9)) {
    unint64_t v14 = "true";
  }
  else {
    unint64_t v14 = "false";
  }
  uint64_t v15 = sub_1CB8E509C(v13, v14);

  return sub_1CB8E509C(v15, "\n");
}

uint64_t llvm::GPUFunctionAnalysis::run(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  LOWORD(v4) = 0;
  llvm::GPUFunctionAnalysisResult::analyze((llvm::GPUFunctionAnalysisResult *)&v3);
  return v3;
}

void llvm::GPUFunctionInfoPrinterPass::run()
{
}

llvm::Value *sub_1CD48D428(llvm *a1)
{
  uint64_t v2 = llvm::dbgs(a1);

  return llvm::GPUFunctionCallInfo::print(a1, v2);
}

llvm::Value *llvm::GPUFunctionCallInfo::print(llvm::GPUFunctionCallInfo *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = sub_1CB8E509C(a2, "IsDylib: ");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, *((unsigned __int8 *)this + 144));
  size_t v6 = sub_1CB8E509C(v5, "\tUseDylibFunction: ");
  unint64_t v7 = llvm::raw_ostream::operator<<(v6, *((unsigned __int8 *)this + 145));
  uint64_t v8 = sub_1CB8E509C(v7, "\tNbUnknownIndCalls: ");
  uint64_t v9 = llvm::raw_ostream::operator<<(v8, *((unsigned int *)this + 37));
  sub_1CB8E509C(v9, "\n");
  sub_1CB8E509C(a2, "- Number of calls (including indirect calls):\n");
  uint64_t v10 = *((unsigned int *)this + 4);
  uint64_t v11 = *(void *)this + 16 * v10;
  if (*((_DWORD *)this + 2))
  {
    if (v10)
    {
      uint64_t v12 = 16 * v10;
      uint64_t v13 = *(void *)this;
      while ((*(void *)v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v13 += 16;
        v12 -= 16;
        if (!v12) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v13 = *(void *)this;
    }
  }
  else
  {
LABEL_6:
    uint64_t v13 = *(void *)this + 16 * v10;
  }
  uint64_t v14 = *(void *)this + 16 * v10;
  while (v13 != v14)
  {
    unint64_t v15 = *(unsigned int *)(v13 + 8);
    Name = llvm::Value::getName(*(llvm::Value **)v13);
    size_t v18 = v16;
    int v19 = (void *)*((void *)a2 + 4);
    if (v16 <= *((void *)a2 + 3) - (void)v19)
    {
      if (v16)
      {
        memcpy(v19, Name, v16);
        *((void *)a2 + 4) += v18;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, Name, v16);
    }
    uint64_t v20 = sub_1CB8E509C(a2, ":");
    BOOL v21 = llvm::raw_ostream::operator<<(v20, v15);
    sub_1CB8E509C(v21, "\n");
    uint64_t v22 = v13 + 16;
    uint64_t v13 = v11;
    if (v22 != v11)
    {
      uint64_t v13 = v22;
      while ((*(void *)v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v13 += 16;
        if (v13 == v11)
        {
          uint64_t v13 = v11;
          break;
        }
      }
    }
  }
  sub_1CB8E509C(a2, "- Number of indirect calls leading to:\n");
  uint64_t v23 = *((void *)this + 3);
  uint64_t v24 = *((unsigned int *)this + 10);
  uint64_t v25 = v23 + 16 * v24;
  if (*((_DWORD *)this + 8))
  {
    if (v24)
    {
      uint64_t v26 = 16 * v24;
      uint64_t v27 = *((void *)this + 3);
      while ((*(void *)v27 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v27 += 16;
        v26 -= 16;
        if (!v26) {
          goto LABEL_24;
        }
      }
    }
    else
    {
      uint64_t v27 = *((void *)this + 3);
    }
  }
  else
  {
LABEL_24:
    uint64_t v27 = v23 + 16 * v24;
  }
  uint64_t v28 = v23 + 16 * v24;
  while (v27 != v28)
  {
    unint64_t v29 = *(unsigned int *)(v27 + 8);
    uint64_t v31 = llvm::Value::getName(*(llvm::Value **)v27);
    size_t v32 = v30;
    std::string::size_type v33 = (void *)*((void *)a2 + 4);
    if (v30 <= *((void *)a2 + 3) - (void)v33)
    {
      if (v30)
      {
        memcpy(v33, v31, v30);
        *((void *)a2 + 4) += v32;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, v31, v30);
    }
    std::string::size_type v34 = sub_1CB8E509C(a2, ":");
    size_t v35 = llvm::raw_ostream::operator<<(v34, v29);
    sub_1CB8E509C(v35, "\n");
    uint64_t v36 = v27 + 16;
    uint64_t v27 = v25;
    if (v36 != v25)
    {
      uint64_t v27 = v36;
      while ((*(void *)v27 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v27 += 16;
        if (v27 == v25)
        {
          uint64_t v27 = v25;
          break;
        }
      }
    }
  }
  BOOL result = sub_1CB8E509C(a2, "- MayUseFunctionsInUnknownContext:\n");
  uint64_t v38 = *((void *)this + 7);
  uint64_t v39 = 64;
  if (v38 == *((void *)this + 6)) {
    uint64_t v39 = 68;
  }
  uint64_t v40 = *(unsigned int *)((char *)this + v39);
  if (v40)
  {
    uint64_t v41 = 8 * v40;
    for (int i = (llvm::Value **)*((void *)this + 7); (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v41 -= 8;
      if (!v41) {
        return result;
      }
    }
  }
  else
  {
    int i = (llvm::Value **)*((void *)this + 7);
  }
  __int16 v43 = (llvm::Value **)(v38 + 8 * v40);
  if (i != v43)
  {
    BOOL result = *i;
LABEL_47:
    long long v45 = llvm::Value::getName(result);
    size_t v46 = v44;
    std::string::size_type v47 = (void *)*((void *)a2 + 4);
    if (v44 <= *((void *)a2 + 3) - (void)v47)
    {
      if (v44)
      {
        memcpy(v47, v45, v44);
        *((void *)a2 + 4) += v46;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, v45, v44);
    }
    BOOL result = sub_1CB8E509C(a2, "\n");
    uint64_t v48 = i + 1;
    while (v48 != v43)
    {
      int v49 = *v48++;
      BOOL result = v49;
      if ((unint64_t)v49 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        int i = v48 - 1;
        goto LABEL_47;
      }
    }
  }
  return result;
}

void llvm::initializeGPUFunctionCallInfoWrapperPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5658, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC004EC4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5658, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::callDefaultCtor<llvm::GPUFunctionCallInfoWrapper>()
{
}

void sub_1CD48D8F4(llvm::ModulePass *a1)
{
  sub_1CD48D934(a1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::Value *sub_1CD48D92C(uint64_t a1, llvm::raw_ostream *a2)
{
  return llvm::GPUFunctionCallInfo::print(*(llvm::GPUFunctionCallInfo **)(a1 + 32), a2);
}

void sub_1CD48D934(llvm::ModulePass *a1)
{
  *(void *)a1 = &unk_1F2603768;
  uint64_t v1 = (void *)*((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v1)
  {
    uint64_t v3 = a1;
    uint64_t v2 = sub_1CC0050AC(v1);
    MEMORY[0x1D25D9CE0](v2, 0x10E0C408DED98BELL);
    a1 = v3;
  }

  llvm::ModulePass::~ModulePass(a1);
}

void llvm::FunctionGroupInfo::create(llvm::FunctionGroupInfo *this, llvm::GPUFunctionInfoCache *a2)
{
}

void llvm::createFunctionGroupInfoWrapperPass(llvm *this)
{
}

void llvm::FunctionGroupInfoPrinterPass::run()
{
}

void llvm::callDefaultCtor<llvm::FunctionGroupInfoWrapperPass>()
{
}

void sub_1CD48DB4C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &llvm::FunctionGroupInfoWrapperPass::ID;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2603808;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5660, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC00610C;
    v3[1] = &PassRegistry;
    uint64_t v2 = v3;
    std::__call_once(&qword_1EBCC5660, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
  operator new();
}

void sub_1CD48DCC8(uint64_t a1)
{
  sub_1CD48DD28(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD48DD00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 88))();
}

void sub_1CD48DD28(uint64_t a1)
{
  *(void *)a1 = &unk_1F2603808;
  sub_1CC0061E4((void **)(a1 + 40), 0);
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

uint64_t sub_1CD48DDB0(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = &unk_1F26038B0;
  *(void *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 1;
  for (uint64_t i = 40; i != 104; i += 16)
    *(void *)(a1 + i) = -4096;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x400000000;
  *(_OWORD *)(a1 + 544) = 0u;
  *(void *)(a1 + 536) = a1 + 544;
  *(void *)(a1 + 560) = a1 + 576;
  *(void *)(a1 + 568) = 0x100000000;
  *(_DWORD *)(a1 + 600) = 128;
  *(void *)(a1 + 584) = operator new(0x4000uLL, (std::align_val_t)8uLL);
  sub_1CC007D7C((void *)(a1 + 584));
  *(unsigned char *)(a1 + 608) = 0;
  *(unsigned char *)(a1 + 632) = 0;
  *(_DWORD *)(a1 + 664) = 128;
  *(void *)(a1 + 648) = operator new(0x1800uLL, (std::align_val_t)8uLL);
  sub_1CC008788((void *)(a1 + 648));
  *(unsigned char *)(a1 + 672) = 0;
  *(unsigned char *)(a1 + 696) = 0;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_DWORD *)(a1 + 728) = 0;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_DWORD *)(a1 + 752) = 0;
  *(_OWORD *)(a1 + 760) = xmmword_1CFAC36C0;
  *(unsigned char *)(a1 + 776) = a3;
  return a1;
}

void sub_1CD48DEE4(uint64_t a1)
{
  sub_1CC00924C(a1);

  JUMPOUT(0x1D25D9CE0);
}

int32x2_t sub_1CD48DF1C(uint64_t a1, unint64_t a2, int32x2_t ****a3)
{
  size_t v6 = (uint64_t *)(a1 + 544);
  unint64_t v7 = *(void **)(a1 + 544);
  if (v7)
  {
    uint64_t v8 = (uint64_t *)(a1 + 544);
    do
    {
      unint64_t v9 = v7[4];
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        uint64_t v11 = v7;
      }
      else {
        uint64_t v11 = v7 + 1;
      }
      if (v10) {
        uint64_t v8 = v7;
      }
      unint64_t v7 = (void *)*v11;
    }
    while (*v11);
    if (v8 != v6 && v8[4] <= a2)
    {
      uint64_t v26 = v8[5];
      v8[5] = 0;
      uint64_t v32 = v26;
      (*(void (**)(uint64_t, unint64_t))(*(void *)v26 + 48))(v26, a2);
      (*(void (**)(uint64_t, int32x2_t ****))(*(void *)v26 + 40))(v26, a3);
      uint64_t v27 = (void *)*v6;
      if (*v6)
      {
        uint64_t v28 = v6;
        do
        {
          unint64_t v29 = v27[4];
          BOOL v30 = v29 >= a2;
          if (v29 >= a2) {
            uint64_t v31 = v27;
          }
          else {
            uint64_t v31 = v27 + 1;
          }
          if (v30) {
            uint64_t v28 = v27;
          }
          uint64_t v27 = (void *)*v31;
        }
        while (*v31);
        if (v28 != v6 && v28[4] <= a2) {
          sub_1CD491AE8((uint64_t **)(a1 + 536), v28);
        }
      }
      sub_1CD491BA4((uint64_t *)(a1 + 536), (unint64_t)a3, (uint64_t)a3, &v32);
      if (v32) {
        (*(void (**)(uint64_t))(*(void *)v32 + 24))(v32);
      }
    }
  }
  uint64_t v12 = (int32x2_t *)(a1 + 584);
  uint64_t v32 = 0;
  if (sub_1CC0127D4(*(void *)(a1 + 584), *(_DWORD *)(a1 + 600), a2, &v32)) {
    BOOL v13 = v32 == *(void *)(a1 + 584) + ((unint64_t)*(unsigned int *)(a1 + 600) << 7);
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    uint64_t v14 = *(unsigned int *)(v32 + 88);
    if (v14)
    {
      unint64_t v15 = *(unint64_t **)(v32 + 80);
      size_t v16 = &v15[v14];
      do
      {
        unint64_t v17 = *v15;
        uint64_t v32 = *v15;
        size_t v18 = (void *)*v6;
        if (*v6)
        {
          int v19 = v6;
          do
          {
            unint64_t v20 = v18[4];
            BOOL v21 = v20 >= v17;
            if (v20 >= v17) {
              uint64_t v22 = v18;
            }
            else {
              uint64_t v22 = v18 + 1;
            }
            if (v21) {
              int v19 = v18;
            }
            size_t v18 = (void *)*v22;
          }
          while (*v22);
          if (v19 != v6 && v17 >= v19[4])
          {
            uint64_t v23 = v19[5];
            (*(void (**)(uint64_t, unint64_t))(*(void *)v23 + 48))(v23, a2);
            (*(void (**)(uint64_t, int32x2_t ****))(*(void *)v23 + 40))(v23, a3);
          }
        }
        uint64_t v24 = sub_1CC011FF0((uint64_t)v12, a3);
        sub_1CC00FA08(v24, &v32);
        ++v15;
      }
      while (v15 != v16);
    }
  }
  return sub_1CC0151BC(v12, a2);
}

llvm::raw_ostream *sub_1CD48E1AC(llvm::raw_ostream *result, llvm::raw_ostream *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = a3 + 24;
    uint64_t v5 = *(void *)(a3 + 32);
    if (v5 != a3 + 24)
    {
      uint64_t v6 = (uint64_t)result;
      do
      {
        if (v5) {
          unint64_t v7 = (llvm::Value *)(v5 - 56);
        }
        else {
          unint64_t v7 = 0;
        }
        uint64_t v8 = sub_1CB8E509C(a2, "Function ");
        Name = llvm::Value::getName(v7);
        size_t v11 = v9;
        uint64_t v12 = (void *)*((void *)v8 + 4);
        if (v9 <= *((void *)v8 + 3) - (void)v12)
        {
          if (v9)
          {
            memcpy(v12, Name, v9);
            *((void *)v8 + 4) += v11;
          }
        }
        else
        {
          llvm::raw_ostream::write(v8, Name, v9);
        }
        sub_1CB8E509C(v8, "'s group contains:\n");
        BOOL result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, llvm::Value *))(*(void *)v6 + 24))(v6, v7);
        if (result) {
          BOOL result = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *, llvm::raw_ostream *))(*(void *)result + 584))(result, a2);
        }
        uint64_t v5 = *(void *)(v5 + 8);
      }
      while (v5 != v4);
    }
  }
  else
  {
    return sub_1CB8E509C(a2, "Cannot print function groups without a module\n");
  }
  return result;
}

void sub_1CD48E334(uint64_t a1)
{
  sub_1CC008720(v3, (void *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 32);
  sub_1CD48E568(v5, v4);
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v3);
  }
}

void sub_1CD48E3C4(uint64_t a1, uint64_t a2)
{
  v21[4] = *MEMORY[0x1E4F143B8];
  sub_1CC008720(v10, (void *)(a1 + 8));
  uint64_t v4 = *(int32x2_t **)(a1 + 32);
  v9[3] = &off_1F2603940;
  uint64_t v12 = v4;
  uint64_t v13 = 0;
  int v5 = sub_1CC007EA8((uint64_t)*v4, v4[2].i32[0], v11, &v13);
  unint64_t v6 = *(void *)v4 + ((unint64_t)v4[2].u32[0] << 7);
  if (v5) {
    uint64_t v7 = v13;
  }
  else {
    uint64_t v7 = v6;
  }
  if (*(void *)v12 + ((unint64_t)v12[2].u32[0] << 7) != v7)
  {
    sub_1CC007F3C((uint64_t)&v18, (unsigned int *)(v7 + 40));
    sub_1CD48E65C(v12, v7);
    uint64_t v8 = v12;
    uint64_t v13 = a2;
    sub_1CC007F3C((uint64_t)v14, &v18);
    sub_1CD48E734((uint64_t)v9, (uint64_t)v8, (unsigned int *)&v13);
    if (v16 != &v17) {
      free(v16);
    }
    if ((v14[0] & 1) == 0) {
      MEMORY[0x1D25D9CD0](v15, 8);
    }
    if (v20 != v21) {
      free(v20);
    }
    if ((v18 & 1) == 0) {
      MEMORY[0x1D25D9CD0](v19, 8);
    }
  }
  if (v11 != -8192 && v11 != -4096)
  {
    if (v11) {
      llvm::ValueHandleBase::RemoveFromUseList(v10);
    }
  }
}

int32x2_t sub_1CD48E568(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  if (sub_1CC007EA8(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    uint64_t v4 = v7;
    int v5 = (uint64_t (**)(llvm::CallbackVH *__hidden))v7[10];
    if (v5 != v7 + 12) {
      free(v5);
    }
    if (((_BYTE)v4[5] & 1) == 0) {
      MEMORY[0x1D25D9CD0](v4[6], 8);
    }
    v8[0] = 2;
    v8[1] = 0;
    uint64_t v9 = -8192;
    BOOL v10 = 0;
    uint64_t v7 = &off_1F2603940;
    sub_1CBF62D84((unint64_t *)v4 + 1, v8);
    uint64_t v6 = v9;
    v4[4] = v10;
    if (v6 != -8192 && v6 != -4096)
    {
      if (v6) {
        llvm::ValueHandleBase::RemoveFromUseList(v8);
      }
    }
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD48E65C(int32x2_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a2 + 80);
  if (v4 != (void *)(a2 + 96)) {
    free(v4);
  }
  if ((*(unsigned char *)(a2 + 40) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a2 + 48), 8);
  }
  v7[0] = 2;
  v7[1] = 0;
  uint64_t v8 = -8192;
  uint64_t v9 = 0;
  sub_1CBF62D84((unint64_t *)(a2 + 8), v7);
  uint64_t v5 = v8;
  *(void *)(a2 + 32) = v9;
  if (v5 != -8192 && v5 != -4096 && v5) {
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1CD48E734(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)a3;
  uint64_t v7 = 2;
  v11[0] = 2;
  v11[1] = 0;
  uint64_t v12 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v11);
    uint64_t v7 = v11[0];
    uint64_t v6 = v12;
  }
  uint64_t v13 = a2;
  unint64_t v17 = v7 & 6;
  v18[0] = 0;
  v18[1] = v6;
  uint64_t v9 = a2;
  if (v6 != -8192)
  {
    uint64_t v9 = a2;
    if (v6 != -4096)
    {
      uint64_t v9 = a2;
      if (v6)
      {
        v18[0] = *(void *)(v7 & 0xFFFFFFFFFFFFFFF8);
        *(void *)(v7 & 0xFFFFFFFFFFFFFFF8) = &v17;
        unint64_t v17 = v7 & 0xFFFFFFFFFFFFFFFELL;
        if (v18[0]) {
          *(void *)v18[0] = *(void *)v18[0] & 7 | (unint64_t)v18;
        }
        uint64_t v9 = v13;
      }
    }
  }
  size_t v16 = &off_1F2603940;
  void v18[2] = v9;
  sub_1CC007F3C((uint64_t)v19, a3 + 2);
  sub_1CD48E8E4((uint64_t)&v14, a2, (uint64_t *)&v16, v19);
  sub_1CD48EA5C((uint64_t)&v16);
  if (v12 != -8192 && v12 != -4096 && v12) {
    llvm::ValueHandleBase::RemoveFromUseList(v11);
  }
  double result = *(double *)&v14;
  *(_OWORD *)a1 = v14;
  *(unsigned char *)(a1 + 16) = v15;
  return result;
}

uint64_t sub_1CD48E8E4(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CC007EA8(*(void *)a2, *(_DWORD *)(a2 + 16), a3[3], &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = sub_1CC008258((_DWORD *)a2, (uint64_t)a3, v12);
    sub_1CBF62D84((unint64_t *)(v9 + 8), a3 + 1);
    *(void *)(v9 + 32) = a3[4];
    uint64_t result = sub_1CC007F3C(v9 + 40, a4);
    char v10 = 1;
  }
  unint64_t v11 = *(void *)a2 + ((unint64_t)*(unsigned int *)(a2 + 16) << 7);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD48E99C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new((unint64_t)v8 << 7, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CC008318(a1, v4, v4 + (v3 << 7));
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CC007D7C((void *)a1);
}

uint64_t sub_1CD48EA5C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2 != (void *)(a1 + 96)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 40) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 48), 8);
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3 != -8192 && v3 != -4096 && v3 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList((void *)(a1 + 8));
  }
  return a1;
}

void sub_1CD48EACC(uint64_t a1)
{
  sub_1CC008720(v3, (void *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 32);
  sub_1CD48EC84(v5, v4);
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v3);
  }
}

int32x2_t *sub_1CD48EB5C(uint64_t a1, uint64_t a2)
{
  sub_1CC008720(v12, (void *)(a1 + 8));
  uint64_t v4 = *(void *)(a1 + 32);
  unint64_t v11 = &off_1F2603968;
  long long v14 = (int32x2_t *)v4;
  v8[0] = 0;
  if (sub_1CC0088B8(*(void *)v4, *(_DWORD *)(v4 + 16), v13, v8)) {
    uint64_t v5 = (unint64_t *)v8[0];
  }
  else {
    uint64_t v5 = (unint64_t *)(*(void *)v4 + 48 * *(unsigned int *)(v4 + 16));
  }
  uint64_t result = v14;
  if ((unint64_t *)(*(void *)v14 + 48 * v14[2].u32[0]) != v5)
  {
    unint64_t v7 = v5[5];
    v5[5] = 0;
    sub_1CD48ED7C(result, v5);
    uint64_t v9 = a2;
    char v10 = (int32x2_t *)v7;
    sub_1CC008944((uint64_t)v8, (uint64_t)v14, (uint64_t)&v9);
    uint64_t result = v10;
    if (v10) {
      uint64_t result = (int32x2_t *)(*(uint64_t (**)(int32x2_t *))(*(void *)v10 + 24))(v10);
    }
  }
  if (v13 != -8192 && v13 != -4096)
  {
    if (v13) {
      return (int32x2_t *)llvm::ValueHandleBase::RemoveFromUseList(v12);
    }
  }
  return result;
}

int32x2_t sub_1CD48EC84(uint64_t a1, uint64_t a2)
{
  unint64_t v7 = 0;
  if (sub_1CC0088B8(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7))
  {
    uint64_t v4 = v7;
    uint64_t v5 = v7[5];
    v7[5] = 0;
    if (v5) {
      (*(void (**)(uint64_t (*)(llvm::CallbackVH *__hidden)))(*(void *)v5 + 24))(v5);
    }
    v8[0] = 2;
    v8[1] = 0;
    uint64_t v9 = -8192;
    char v10 = 0;
    unint64_t v7 = &off_1F2603968;
    sub_1CBF62D84((unint64_t *)v4 + 1, v8);
    uint64_t v6 = v9;
    v4[4] = v10;
    if (v6 != -8192 && v6 != -4096)
    {
      if (v6) {
        llvm::ValueHandleBase::RemoveFromUseList(v8);
      }
    }
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD48ED7C(int32x2_t *a1, unint64_t *a2)
{
  unint64_t v4 = a2[5];
  a2[5] = 0;
  if (v4) {
    (*(void (**)(unint64_t))(*(void *)v4 + 24))(v4);
  }
  v8[0] = 2;
  v8[1] = 0;
  uint64_t v9 = -8192;
  unint64_t v10 = 0;
  sub_1CBF62D84(a2 + 1, v8);
  uint64_t v5 = v9;
  a2[4] = v10;
  if (v5 != -8192 && v5 != -4096 && v5 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v8);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

void *sub_1CD48EE58(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(48 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CC008E98(a1, v4, &v4[6 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CC008788((void *)a1);
}

uint64_t sub_1CD48EF20()
{
  return 3;
}

uint64_t sub_1CD48EF28()
{
  return 0;
}

uint64_t sub_1CD48EF30(uint64_t a1, int a2)
{
  return dword_1CFAC373C[a2];
}

uint64_t sub_1CD48EF40(uint64_t a1)
{
  return 4;
}

char *sub_1CD48EF7C(uint64_t a1, int a2)
{
  return llvm::AGX01CommonRegisterInfo::RegNames[a2];
}

uint64_t sub_1CD48EF8C()
{
  return 4;
}

uint64_t sub_1CD48EF94()
{
  return 4;
}

uint64_t sub_1CD48EF9C(uint64_t a1, int a2)
{
  unsigned int v2 = llvm::AGX01CommonRegisterInfo::RegLimits[a2];
  if (*(unsigned char *)(a1 + 8)) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = a2 == 1;
  }
  if (v3) {
    return v2 + 32;
  }
  else {
    return v2;
  }
}

void sub_1CD48EFC4()
{
}

char *sub_1CD48EFD8(uint64_t a1, int a2)
{
  return llvm::AGX2CommonRegisterInfo::RegNames[a2];
}

void sub_1CD48EFF0()
{
}

void sub_1CD48F008()
{
}

uint64_t sub_1CD48F07C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

void sub_1CD48F084()
{
}

void sub_1CD48F0A0()
{
}

uint64_t sub_1CD48F0BC(uint64_t a1)
{
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 560))(a1)) {
    return a1;
  }
  else {
    return 0;
  }
}

unsigned int *sub_1CD48F110(uint64_t a1, long long *__src, uint64_t a3)
{
  *(_DWORD *)(a1 + 2432) = 0;
  return sub_1CD48FCC4((unsigned int *)(a1 + 2424), *(void *)(a1 + 2424), __src, &__src[a3]);
}

uint64_t sub_1CD48F130(uint64_t a1)
{
  return *(void *)(a1 + 2696);
}

void sub_1CD48F148()
{
}

void sub_1CD48F1A4()
{
}

uint64_t sub_1CD48F208(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(*(void *)(a1 + 4472) + 4 * a2);
}

uint64_t sub_1CD48F214(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 4532);
}

uint64_t sub_1CD48F220(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4533) = a2;
  return result;
}

uint64_t sub_1CD48F22C(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 352))(a1);
  unsigned int v5 = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t, uint64_t))a1)(a1, 7, 0, 1, 3);
  unsigned int v6 = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t, uint64_t))a1)(a1, 6, 0, 1, 1);
  if (a2 < v4 || (unint64_t v7 = a2 - v4 + v5 / v6, (*(uint64_t (**)(uint64_t))(*(void *)a1 + 312))(a1) <= v7))
  {
    uint64_t v11 = 0;
    int v10 = 0;
    unsigned int v9 = 0;
  }
  else
  {
    int v8 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a1 + 320))(a1, v7);
    unsigned int v9 = v8 & 0xFFFFFF00;
    int v10 = v8;
    uint64_t v11 = 0x100000000;
  }
  return v11 | v9 | v10;
}

BOOL sub_1CD48F3B0(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 312))(a1) != 0;
}

uint64_t sub_1CD48F3F8(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 160))(a1, 9) ^ 1;
}

uint64_t sub_1CD48F438(uint64_t (***a1)(void, uint64_t, uint64_t, uint64_t, uint64_t))
{
  return (**a1)(a1, 5, 0xFFFFFFFFLL, 1, 1);
}

uint64_t sub_1CD48F480(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 336))(a1);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 4);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 336))(a1);
  unsigned int v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v5);
  uint64_t v8 = *(void *)(a1 + 2720);
  uint64_t v9 = *(unsigned int *)(v8 + 4 * v5);
  if (v9 % v7) {
    LODWORD(v9) = (v9 + (unint64_t)v7 - 1) / v7 * v7;
  }
  int v10 = v9 + v7 * a2;
  *(_DWORD *)(v8 + 4 * v5) = v10;
  *(_DWORD *)(a1 + 4528) = (v10 + 3) & 0xFFFFFFFC;
  return v9 / v7;
}

uint64_t sub_1CD48F5AC(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 240))(a1);
  if ((result & 0xFF00000000) == 0)
  {
    int v5 = 4 * (*(uint64_t (**)(uint64_t))(*(void *)a1 + 312))(a1);
    uint64_t v7 = a2;
    *(_DWORD *)sub_1CC011050(a1 + 3792, &v7) = v5;
    (*(void (**)(uint64_t, void))(*(void *)a1 + 328))(a1, 0);
    uint64_t v6 = *(uint64_t (**)(uint64_t, void))(*(void *)a1 + 328);
    return v6(a1, 0);
  }
  return result;
}

llvm::raw_ostream *sub_1CD48F6F4(unint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t v4 = sub_1CB8E509C(a2, "Simple function group @");
  int v5 = llvm::raw_ostream::operator<<(v4, a1);
  sub_1CB8E509C(v5, ":\n");
  sub_1CB8E509C(a2, "  Functions: [ ");
  uint64_t v6 = *(unsigned int *)(a1 + 96);
  if (v6)
  {
    uint64_t v7 = *(llvm::Value ***)(a1 + 88);
    uint64_t v8 = 8 * v6;
    do
    {
      Name = llvm::Value::getName(*v7);
      size_t v11 = v9;
      uint64_t v12 = (void *)*((void *)a2 + 4);
      if (v9 <= *((void *)a2 + 3) - (void)v12)
      {
        if (v9)
        {
          memcpy(v12, Name, v9);
          *((void *)a2 + 4) += v11;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, Name, v9);
      }
      sub_1CB8E509C(a2, " ");
      ++v7;
      v8 -= 8;
    }
    while (v8);
  }
  uint64_t result = sub_1CB8E509C(a2, "]\n");
  if (*(_DWORD *)(a1 + 4064))
  {
    uint64_t result = sub_1CB8E509C(a2, "  GlobalValueLiteralConstantOffsetMap:\n");
    uint64_t v14 = *(unsigned int *)(a1 + 4064);
    if (v14)
    {
      uint64_t v15 = *(void *)(a1 + 4056);
      uint64_t v16 = v15 + 16 * v14;
      do
      {
        unint64_t v17 = sub_1CB8E509C(a2, "    [");
        uint64_t v19 = llvm::Value::getName(*(llvm::Value **)v15);
        size_t v20 = v18;
        BOOL v21 = (void *)*((void *)v17 + 4);
        if (v18 <= *((void *)v17 + 3) - (void)v21)
        {
          if (v18)
          {
            memcpy(v21, v19, v18);
            *((void *)v17 + 4) += v20;
          }
        }
        else
        {
          llvm::raw_ostream::write(v17, v19, v18);
        }
        uint64_t v22 = sub_1CB8E509C(v17, "]: ");
        uint64_t result = llvm::raw_ostream::operator<<(v22, *(unsigned int *)(v15 + 8));
        uint64_t v23 = (unsigned char *)*((void *)result + 4);
        if ((unint64_t)v23 >= *((void *)result + 3))
        {
          uint64_t result = llvm::raw_ostream::write(result, 10);
        }
        else
        {
          *((void *)result + 4) = v23 + 1;
          unsigned char *v23 = 10;
        }
        v15 += 16;
      }
      while (v15 != v16);
    }
  }
  if (*(_DWORD *)(a1 + 4480))
  {
    uint64_t result = sub_1CB8E509C(a2, "  LiteralConstants:\n");
    if (*(_DWORD *)(a1 + 4480))
    {
      unint64_t v24 = 0;
      do
      {
        if ((v24 & 7) != 0)
        {
          uint64_t v25 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v25 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 32);
          }
          else
          {
            *((void *)a2 + 4) = v25 + 1;
            *uint64_t v25 = 32;
          }
        }
        else
        {
          sub_1CB8E509C(a2, "    ");
        }
        v45[0] = *(unsigned int *)(*(void *)(a1 + 4472) + 4 * v24);
        v45[1] = 0;
        int v46 = 8;
        __int16 v47 = 1;
        char v48 = 0;
        uint64_t result = llvm::raw_ostream::operator<<(a2, (uint64_t)v45);
        if ((++v24 & 7) == 0 || v24 == *(_DWORD *)(a1 + 4480))
        {
          uint64_t v26 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v26 >= *((void *)a2 + 3))
          {
            uint64_t result = llvm::raw_ostream::write(a2, 10);
          }
          else
          {
            *((void *)a2 + 4) = v26 + 1;
            unsigned char *v26 = 10;
          }
        }
      }
      while (v24 < *(unsigned int *)(a1 + 4480));
    }
  }
  if (*(_DWORD *)(a1 + 4536) >= 2u)
  {
    sub_1CB8E509C(a2, "  RegisterOffsets:\n");
    uint64_t result = (llvm::raw_ostream *)sub_1CD4901AC((int *)(a1 + 4536));
    uint64_t v27 = (uint64_t)result;
    uint64_t v29 = v28;
    if (*(unsigned char *)(a1 + 4536))
    {
      unint64_t v30 = a1 + 4544;
      unsigned int v31 = 64;
    }
    else
    {
      unint64_t v30 = *(void *)(a1 + 4544);
      unsigned int v31 = *(_DWORD *)(a1 + 4552);
    }
    uint64_t v32 = (llvm::raw_ostream *)(v30 + 24 * v31);
    if (v32 != result)
    {
      do
      {
        std::string::size_type v33 = sub_1CB8E509C(a2, "    [");
        size_t v35 = llvm::Value::getName(*(llvm::Value **)v27);
        size_t v36 = v34;
        size_t v37 = (void *)*((void *)v33 + 4);
        if (v34 <= *((void *)v33 + 3) - (void)v37)
        {
          if (v34)
          {
            memcpy(v37, v35, v34);
            *((void *)v33 + 4) += v36;
          }
        }
        else
        {
          llvm::raw_ostream::write(v33, v35, v34);
        }
        uint64_t v38 = sub_1CB8E509C(v33, "]: { idx: ");
        uint64_t v39 = llvm::raw_ostream::operator<<(v38, *(unsigned int *)(v27 + 8));
        uint64_t v40 = sub_1CB8E509C(v39, " size: ");
        uint64_t v41 = llvm::raw_ostream::operator<<(v40, *(unsigned int *)(v27 + 12));
        int v42 = sub_1CB8E509C(v41, " type: ");
        __int16 v43 = sub_1CD49022C(*(_DWORD *)(v27 + 16));
        size_t v44 = sub_1CB8E509C(v42, v43);
        uint64_t result = sub_1CB8E509C(v44, " }\n");
        while (1)
        {
          v27 += 24;
          if (v27 == v29) {
            break;
          }
          if ((*(void *)v27 | 0x1000) != 0xFFFFFFFFFFFFF000) {
            goto LABEL_48;
          }
        }
        uint64_t v27 = v29;
LABEL_48:
        ;
      }
      while ((llvm::raw_ostream *)v27 != v32);
    }
  }
  return result;
}

BOOL sub_1CD48FB40(uint64_t a1)
{
  sub_1CC011BA8(&v4, a1);
  BOOL v2 = sub_1CD49023C((uint64_t)&v4, a1);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return v2;
}

void *sub_1CD48FBE8(void *result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  unsigned int v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 5)
  {
    uint64_t v6 = result + 1;
    *uint64_t result = 1;
    uint64_t v7 = result + 5;
    do
LABEL_10:
      *v6++ = -4096;
    while (v6 != v7);
    return result;
  }
  if ((v2 & 1) == 0)
  {
    if (v5 == *((_DWORD *)result + 4))
    {
      *uint64_t result = 0;
      if (!v5) {
        return result;
      }
      uint64_t v6 = (void *)result[1];
      uint64_t v7 = &v6[v5];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](result[1], 8);
  }

  return sub_1CC007FAC(v1, v5);
}

unsigned int *sub_1CD48FCC4(unsigned int *result, uint64_t a2, long long *__src, long long *a4)
{
  unsigned int v5 = __src;
  uint64_t v6 = *(void *)result;
  uint64_t v7 = result[2];
  if (*(void *)result + 16 * v7 == a2)
  {
    return sub_1CD3D61B4(result, __src, a4);
  }
  else
  {
    uint64_t v8 = (a2 - v6) >> 4;
    unint64_t v9 = a4 - __src;
    if (v7 + v9 > result[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    int v10 = (_OWORD *)(v6 + 16 * v8);
    size_t v11 = (unsigned char *)(v6 + 16 * v7);
    unint64_t v12 = (v11 - (unsigned char *)v10) >> 4;
    if (v12 >= v9)
    {
      uint64_t result = (unsigned int *)sub_1CD3E56A0((uint64_t)result, &v11[-16 * v9], (char *)(v6 + 16 * v7));
      if (&v11[-16 * v9] != (unsigned char *)v10) {
        uint64_t result = (unsigned int *)memmove(&v10[v9], v10, &v11[-16 * v9] - (unsigned char *)v10);
      }
      if (v5 != a4)
      {
        return (unsigned int *)memmove(v10, v5, (char *)a4 - (char *)v5);
      }
    }
    else
    {
      unsigned int v13 = v7 + ((unint64_t)((char *)a4 - (char *)__src) >> 4);
      result[2] = v13;
      if (v8 != v7)
      {
        uint64_t result = (unsigned int *)memcpy((void *)(v6 + 16 * v13 - 16 * v12), v10, v11 - (unsigned char *)v10);
        do
        {
          long long v14 = *v5++;
          *v10++ = v14;
          --v12;
        }
        while (v12);
      }
      if (v5 != a4)
      {
        return (unsigned int *)memcpy(v11, v5, (char *)a4 - (char *)v5);
      }
    }
  }
  return result;
}

void sub_1CD48FE88()
{
}

void sub_1CD48FE9C()
{
}

uint64_t sub_1CD48FF00(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1CD48FF08(uint64_t result)
{
  *(void *)(result + 8) += 16;
  return result;
}

uint64_t sub_1CD48FF1C(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v11 = *(void *)(a1 + 8);
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x10)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC01119C(a1, v11, v11 + 16 * v12);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v6 = 0;
  uint64_t v7 = v14;
  do
  {
    uint64_t v8 = *(void *)(a1 + v6 + 8);
    if ((v8 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)uint64_t v7 = v8;
      *((_DWORD *)v7 + 2) = *(_DWORD *)(a1 + v6 + 16);
      v7 += 16;
    }
    v6 += 16;
  }
  while (v6 != 256);
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v9 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v9;
  }
  return sub_1CC01119C(a1, (uint64_t)v14, (uint64_t)v7);
}

uint64_t sub_1CD4900B4(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD4900E0(a1, a2, a3, a4);
  }
  uint64_t v5 = *(void *)a1 + 16 * v4;
  *(void *)uint64_t v5 = a2;
  *(_DWORD *)(v5 + 8) = a3;
  *(_DWORD *)(v5 + 12) = a4;
  *(_DWORD *)(a1 + 8) = v4 + 1;
  return a1;
}

uint64_t sub_1CD4900E0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v5 = (void *)(*(void *)a1 + 16 * v4);
  *uint64_t v5 = a2;
  v5[1] = a3 | (unint64_t)(a4 << 32);
  LODWORD(v5) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v5;
  return *(void *)a1 + 16 * v5 - 16;
}

uint64_t sub_1CD490168(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = 0;
  *(unsigned char *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  *(void *)uint64_t result = &unk_1F2646F30;
  *(void *)(result + 64) = a2;
  *(_DWORD *)(result + 56) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 16) = 0;
  return result;
}

llvm::raw_ostream *sub_1CD4901A4(llvm::raw_ostream *a1, unsigned int a2)
{
  return llvm::raw_ostream::operator<<(a1, a2);
}

int *sub_1CD4901AC(int *a1)
{
  int v2 = *a1;
  if (*a1 > 1)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      uint64_t v7 = a1 + 386;
LABEL_10:
      while ((*(void *)result | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        result += 6;
        if (result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (int *)*((void *)a1 + 1);
      unsigned int v6 = a1[4];
      if (v6)
      {
        uint64_t v7 = &result[6 * v6];
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v2)
    {
      unint64_t v3 = a1 + 2;
      unsigned int v4 = 64;
    }
    else
    {
      unint64_t v3 = (int *)*((void *)a1 + 1);
      unsigned int v4 = a1[4];
    }
    return &v3[6 * v4];
  }
  return result;
}

char *sub_1CD49022C(int a1)
{
  return off_1E682C778[a1];
}

BOOL sub_1CD49023C(uint64_t a1, uint64_t a2)
{
  sub_1CC011D40(&v9, a1);
  sub_1CC011D40(&v8, a1 + 8);
  BOOL v4 = sub_1CC011C34(&v9, &v8, a2);
  uint64_t v5 = v8;
  uint64_t v8 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = v9;
  uint64_t v9 = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  return v4;
}

void *sub_1CD4902F8(void *a1)
{
  *a1 = &unk_1F2603E78;
  int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

void sub_1CD49034C()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "insertMember";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4903C0()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "removeMember";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490434()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "getNumMembers";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4904A8()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "hasMember";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD49051C(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_1CD490524(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(result + 24);
  if (v3)
  {
    uint64_t v6 = *(uint64_t **)(result + 16);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6++;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 152))(v8, a2, a3);
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

void sub_1CD490598()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "global_resource_clear";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD49060C()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "getVIDMAList";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490680()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "setVIDMAList";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4906F4()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "getVIRemap";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490768()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "setVIRemap";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD4907DC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 64);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 224))();
  }
  return result;
}

uint64_t sub_1CD49080C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 232))();
}

void sub_1CD490834()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "getGlobalValueLiteralConstantOffset";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4908A8()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "global_value_literal_constant_offset_begin";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD49091C()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "global_value_literal_constant_offset_end";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490990()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "global_value_literal_constant_offset_empty";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490A04()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "bound_checking_uniform_alloc_begin";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490A78()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "bound_checking_uniform_alloc_end";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490AEC()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "literal_constant_begin";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490B60()
{
  BOOL v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  int v2 = "literal_constant_end";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD490BD4(uint64_t a1)
{
  __int16 v1 = *(uint64_t **)(a1 + 16);
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 >= 2)
  {
    __int16 v3 = v1 + 1;
    uint64_t v4 = 8 * v2 - 8;
    __int16 v5 = v1 + 1;
    do
    {
      uint64_t v6 = *v5++;
      unint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)*v1 + 312))(*v1);
      if (v7 < (*(uint64_t (**)(uint64_t))(*(void *)v6 + 312))(v6)) {
        __int16 v1 = v3;
      }
      __int16 v3 = v5;
      v4 -= 8;
    }
    while (v4);
  }
  uint64_t v8 = *(uint64_t (**)(void))(*(void *)*v1 + 312);

  return v8();
}

void sub_1CD490CE4()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "literal_constant_at";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD490D58(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 328))();
}

void sub_1CD490D88()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "hasReadLiteralConstantLocation";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490DFC()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "getSharedRegisterLiteralConstantBase";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490E70()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "getCPROGHasCalls";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD490EE4()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "setCPROGHasCalls";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD490F58(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 64);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 376))();
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_1CD490F94(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 64);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  return result;
}

unint64_t sub_1CD490FCC(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  if (!v1) {
    return 0;
  }
  unint64_t v2 = 0;
  __int16 v3 = *(uint64_t **)(a1 + 16);
  uint64_t v4 = 8 * v1;
  do
  {
    uint64_t v5 = *v3++;
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 392))(v5);
    if (v6 > v2) {
      unint64_t v2 = v6;
    }
    v4 -= 8;
  }
  while (v4);
  return v2;
}

void sub_1CD491050()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "setCommonStoreRegisterForGlobal";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4910C4()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "hasSharedRegisterAllocations";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491138()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "hasCoefficientRegisterAllocations";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4911AC()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "getAllocatedCoeffRegisterBytes";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491220()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "getNumAvailableTexRegs";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491294()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "allocateConstantLiteralForGlobalValue";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491308()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "allocateBoundCheckingUniform";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD49137C()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "getNextAvailableResourceAllocationForSize";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4913F0()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "allocateResourceForSize";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD491464(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 408))(*(void *)(a1 + 64));
  if ((result & 1) == 0)
  {
    __int16 v3 = *(uint64_t (**)(void))(**(void **)(a1 + 64) + 496);
    return v3();
  }
  return result;
}

void sub_1CD491524()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "allocateRegisterForDylib";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491598()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  unint64_t v2 = "allocateRegisterForBindlessSamplerBase";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

uint64_t sub_1CD49160C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    uint64_t v2 = **(void **)(a1 + 16);
  }
  return (*(uint64_t (**)(void))(*(void *)v2 + 520))();
}

void sub_1CD49164C()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "resetAllocationForType";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4916C0()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "allocate32BitSharedRegisters";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491734()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "emitGlobalConstant";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD4917A8()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "emitExternGlobal";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD49181C()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "getRepresentativeFunction";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491890()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "onGlobalValueErased";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

llvm::raw_ostream *sub_1CD491904(uint64_t a1, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "Complex function group with subgroups: {\n");
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (v4)
  {
    unint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = 8 * v4;
    do
    {
      uint64_t v8 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v8 >= *((void *)a2 + 3))
      {
        uint64_t v9 = llvm::raw_ostream::write(a2, 91);
      }
      else
      {
        *((void *)a2 + 4) = v8 + 1;
        *uint64_t v8 = 91;
        uint64_t v9 = a2;
      }
      int v10 = llvm::raw_ostream::operator<<(v9, v5);
      sub_1CB8E509C(v10, "]: ");
      (*(void (**)(void))(**(void **)(v6 + 8 * v5++) + 584))();
      v7 -= 8;
    }
    while (v7);
  }

  return sub_1CB8E509C(a2, "}\n");
}

uint64_t sub_1CD491A0C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 608))();
}

uint64_t sub_1CD491A3C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 64) + 616))();
}

void sub_1CD491A6C()
{
  uint64_t v4 = "ComplexFunctionGroup::";
  __int16 v5 = 259;
  uint64_t v2 = "getBindlessSamplerBaseSize";
  __int16 v3 = 259;
  sub_1CD3E3950((uint64_t *)&v4, (uint64_t *)&v2, (uint64_t)v6);
  uint64_t v0 = " not implemented";
  __int16 v1 = 259;
  sub_1CD3E3950(v6, (uint64_t *)&v0, (uint64_t)v7);
  llvm::report_fatal_error((llvm *)v7, (const llvm::Twine *)1);
}

void sub_1CD491AE8(uint64_t **a1, uint64_t *a2)
{
  sub_1CD491B50(a1, a2);
  uint64_t v3 = a2[5];
  a2[5] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  operator delete(a2);
}

uint64_t *sub_1CD491B50(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  return sub_1CB91F7C8(v6, a2);
}

uint64_t *sub_1CD491BA4(uint64_t *result, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = result;
  uint64_t v8 = (uint64_t **)(result + 1);
  uint64_t v7 = (uint64_t *)result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v7;
        unint64_t v10 = v7[4];
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    uint64_t v12 = *a4;
    *a4 = 0;
    v11[4] = a3;
    v11[5] = v12;
    *uint64_t v11 = 0;
    v11[1] = 0;
    void v11[2] = (uint64_t)v9;
    *uint64_t v8 = v11;
    uint64_t v13 = *(void *)*v6;
    if (v13)
    {
      *uint64_t v6 = v13;
      long long v14 = *v8;
    }
    else
    {
      long long v14 = v11;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v6[1], v14);
    ++v6[2];
  }
  return result;
}

double sub_1CD491C70(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 104 * v5;
    do
    {
      uint64_t v7 = *(char **)&v4[v6 - 48];
      if (&v4[v6 - 32] != v7) {
        free(v7);
      }
      if ((v4[v6 - 88] & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)&v4[v6 - 80], 8);
      }
      v6 -= 104;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

llvm::IVUsers *llvm::IVUsersAnalysis::run@<X0>(llvm::Loop *a1@<X1>, llvm::AssumptionCache **a2@<X3>, llvm::IVUsers *a3@<X8>)
{
  return llvm::IVUsers::IVUsers(a3, a1, a2[1], a2[3], a2[2], a2[4]);
}

void llvm::initializeIVUsersWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5668, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC01533C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5668, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::IVUsers::AddUser(llvm::IVUsers *this, llvm::Instruction *a2, llvm::Value *a3)
{
}

llvm::IVUsers *llvm::IVUsers::IVUsers(llvm::IVUsers *this, llvm::Loop *a2, llvm::AssumptionCache *a3, llvm::LoopInfo *a4, llvm::DominatorTree *a5, llvm::ScalarEvolution *a6)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = a5;
  *((void *)this + 4) = a6;
  *((void *)this + 5) = (char *)this + 72;
  *((void *)this + 6) = (char *)this + 72;
  *((void *)this + 7) = 16;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 27) = (char *)this + 248;
  uint64_t v9 = (llvm::IVUsers *)((char *)this + 216);
  *((void *)this + 25) = (char *)this + 200;
  *((void *)this + 26) = (char *)this + 200;
  *((void *)this + 28) = (char *)this + 248;
  *((void *)this + 29) = 32;
  *((_DWORD *)this + 60) = 0;
  sub_1CBFF3560((llvm::IVUsers *)((char *)this + 216));
  llvm::CodeMetrics::collectEphemeralValues((uint64_t)a2, a3, v9);
  for (uint64_t i = *(void *)(**((void **)a2 + 4) + 48); ; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v11 = i ? i - 24 : 0;
    if (*(unsigned char *)(v11 + 16) != 83) {
      break;
    }
    llvm::IVUsers::AddUsersIfInteresting(this, (llvm::Instruction *)(i - 24));
  }
  return this;
}

void llvm::IVUsers::print(llvm::ScalarEvolution **this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  sub_1CB8E509C(a2, "IV Users for loop ");
  llvm::Value::printAsOperand(**((llvm::Value ***)*this + 4), a2, 0, 0);
  if (llvm::ScalarEvolution::hasLoopInvariantBackedgeTakenCount(this[4], *this))
  {
    unsigned int v5 = sub_1CB8E509C(a2, " with backedge-taken count ");
    BackedgeTakenCount = llvm::ScalarEvolution::getBackedgeTakenCount(this[4], *this, 0);
    llvm::SCEV::print(BackedgeTakenCount, v5);
  }
  sub_1CB8E509C(a2, ":\n");
  for (uint64_t i = (llvm::ScalarEvolution **)this[26]; i != this + 25; uint64_t i = (llvm::ScalarEvolution **)i[1])
  {
    if (i) {
      uint64_t v8 = i - 4;
    }
    else {
      uint64_t v8 = 0;
    }
    sub_1CB8E509C(a2, "  ");
    llvm::Value::printAsOperand(v8[9], a2, 0, 0);
    uint64_t v9 = sub_1CB8E509C(a2, " = ");
    SCEV = (llvm::SCEV *)llvm::ScalarEvolution::getSCEV(this[4], v8[9]);
    llvm::SCEV::print(SCEV, v9);
    uint64_t v11 = v8[11];
    uint64_t v12 = 96;
    if (v11 == v8[10]) {
      uint64_t v12 = 100;
    }
    uint64_t v13 = *(unsigned int *)((char *)v8 + v12);
    if (v13)
    {
      uint64_t v14 = 8 * v13;
      uint64_t v15 = (unint64_t *)v8[11];
      while (*v15 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v15;
        v14 -= 8;
        if (!v14) {
          goto LABEL_13;
        }
      }
    }
    else
    {
      uint64_t v15 = (unint64_t *)v8[11];
    }
    size_t v18 = (unint64_t *)((char *)v11 + 8 * v13);
    if (v15 != v18)
    {
      unint64_t v19 = *v15;
LABEL_23:
      sub_1CB8E509C(a2, " (post-inc with loop ");
      llvm::Value::printAsOperand(**(llvm::Value ***)(v19 + 32), a2, 0, 0);
      sub_1CB8E509C(a2, ")");
      size_t v20 = v15 + 1;
      while (v20 != v18)
      {
        unint64_t v21 = *v20++;
        unint64_t v19 = v21;
        if (v21 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v15 = v20 - 1;
          goto LABEL_23;
        }
      }
    }
LABEL_13:
    sub_1CB8E509C(a2, " in  ");
    uint64_t v16 = v8[3];
    if (v16) {
      llvm::Value::print(v16, a2, 0);
    }
    else {
      sub_1CB8E509C(a2, "Printing <null> User");
    }
    unint64_t v17 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v17 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v17 + 1;
      unsigned char *v17 = 10;
    }
  }
}

void llvm::IVUsers::dump(llvm::IVUsers *this)
{
  uint64_t v2 = llvm::dbgs(this);

  llvm::IVUsers::print((llvm::ScalarEvolution **)this, v2, v3);
}

llvm::IVUsersWrapperPass *llvm::IVUsersWrapperPass::IVUsersWrapperPass(llvm::IVUsersWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::IVUsersWrapperPass::ID;
  *((_DWORD *)this + 6) = 1;
  *(void *)this = &unk_1F26041A0;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5668, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC01533C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5668, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::AnalysisUsage *llvm::IVUsersWrapperPass::getAnalysisUsage(llvm::IVUsersWrapperPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  double result = llvm::AnalysisUsage::addRequiredID(a2, llvm::ScalarEvolutionWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

void llvm::IVUsersWrapperPass::runOnLoop(llvm::IVUsersWrapperPass *this, llvm::Loop *a2, llvm::LPPassManager *a3)
{
  unsigned int v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_2:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(char **)v6 != llvm::AssumptionCacheTracker::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_2;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v8 + 96))(v8, llvm::AssumptionCacheTracker::ID);
  llvm::AssumptionCacheTracker::getAssumptionCache(v9, *(llvm::Function **)(**((void **)a2 + 4) + 56));
  unint64_t v10 = (uint64_t *)*((void *)this + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_4:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::LoopInfoWrapperPass::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_4;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::LoopInfoWrapperPass::ID);
  uint64_t v14 = (uint64_t *)*((void *)this + 1);
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_6:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_6;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  (*(void (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::DominatorTreeWrapperPass::ID);
  size_t v18 = (uint64_t *)*((void *)this + 1);
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  if (v19 == v20)
  {
LABEL_8:
    uint64_t v21 = 0;
  }
  else
  {
    while (*(char **)v19 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v19 += 16;
      if (v19 == v20) {
        goto LABEL_8;
      }
    }
    uint64_t v21 = *(void *)(v19 + 8);
  }
  (*(void (**)(uint64_t, char *))(*(void *)v21 + 96))(v21, llvm::ScalarEvolutionWrapperPass::ID);
  operator new();
}

void llvm::IVUsersWrapperPass::print(llvm::ScalarEvolution ***this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

uint64_t llvm::IVUsersWrapperPass::releaseMemory(llvm::IVUsersWrapperPass *this)
{
  uint64_t v1 = *((void *)this + 4);
  uint64_t result = (uint64_t)sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(v1 + 40));
  uint64_t v3 = *(void *)(v1 + 208);
  if (v1 + 200 != v3)
  {
    do
    {
      uint64_t result = sub_1CD492848(v1 + 200, v3);
      uint64_t v3 = result;
    }
    while (v1 + 200 != result);
  }
  return result;
}

uint64_t llvm::IVUsers::getExpr(llvm::ScalarEvolution **this, llvm::Value **a2)
{
  uint64_t SCEV = llvm::ScalarEvolution::getSCEV(this[4], a2[9]);
  uint64_t v5 = (uint64_t)this[4];

  return llvm::normalizeForPostIncUse(SCEV, (uint64_t)(a2 + 10), v5);
}

uint64_t llvm::IVUsers::getStride(llvm::ScalarEvolution **this, llvm::Value **a2, const llvm::Loop *a3)
{
  uint64_t SCEV = llvm::ScalarEvolution::getSCEV(this[4], a2[9]);
  uint64_t v7 = llvm::normalizeForPostIncUse(SCEV, (uint64_t)(a2 + 10), (uint64_t)this[4]);
  uint64_t result = sub_1CC0162DC(v7, (uint64_t)a3);
  if (result)
  {
    uint64_t v9 = this[4];
    return sub_1CBFD7EA0(result, v9);
  }
  return result;
}

void *llvm::IVStrideUse::transformToPostInc(llvm::IVStrideUse *this, const llvm::Loop *a2)
{
  return sub_1CB89694C((llvm::IVStrideUse *)((char *)this + 80), (uint64_t)a2);
}

uint64_t llvm::IVStrideUse::deleted(llvm::IVStrideUse *this)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = sub_1CB896AE8(v2 + 40, *((void *)this + 3));
  uint64_t v4 = *(void *)(v2 + 48);
  uint64_t v5 = 56;
  if (v4 == *(void *)(v2 + 40)) {
    uint64_t v5 = 60;
  }
  if (v3 != (void *)(v4 + 8 * *(unsigned int *)(v2 + v5)))
  {
    *uint64_t v3 = -2;
    ++*(_DWORD *)(v2 + 64);
  }
  uint64_t v6 = *((void *)this + 6) + 200;

  return sub_1CD492848(v6, (uint64_t)this + 32);
}

void sub_1CD492698(llvm::Pass *a1)
{
  sub_1CD4927D0(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4926D0()
{
  return 4;
}

void llvm::callDefaultCtor<llvm::IVUsersWrapperPass>()
{
}

uint64_t sub_1CD492714(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a1 + 8) = 2;
  *(void *)(a1 + 16) = 0;
  uint64_t v7 = (llvm::ValueHandleBase *)(a1 + 8);
  *((void *)v7 + 2) = a3;
  if (a3 != -8192 && a3 != -4096 && a3) {
    llvm::ValueHandleBase::AddToUseList(v7);
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)a1 = &unk_1F2604250;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = 6;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a4;
  if (a4 != -8192 && a4 != -4096 && a4) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)(a1 + 56));
  }
  *(void *)(a1 + 80) = a1 + 112;
  *(void *)(a1 + 88) = a1 + 112;
  *(void *)(a1 + 96) = 2;
  *(_DWORD *)(a1 + 104) = 0;
  return a1;
}

void sub_1CD4927D0(llvm::Pass *this)
{
  *(void *)this = &unk_1F26041A0;
  uint64_t v2 = (void *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2)
  {
    uint64_t v3 = sub_1CD492920(v2);
    MEMORY[0x1D25D9CE0](v3, 0x10E0C402C01844DLL);
  }

  llvm::Pass::~Pass(this);
}

uint64_t sub_1CD492848(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (a2) {
    uint64_t v3 = a2 - 32;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 32);
  uint64_t v5 = *(void **)(v3 + 40);
  *uint64_t v5 = v4;
  *(void *)(v4 + 8) = v5;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 0;
  if (a2)
  {
    uint64_t v7 = sub_1CD4928A8((void *)(a2 - 32));
    MEMORY[0x1D25D9CE0](v7, 0x10E1C40910D9C65);
  }
  return v2;
}

void *sub_1CD4928A8(void *a1)
{
  uint64_t v2 = (void *)a1[11];
  if (v2 != (void *)a1[10]) {
    free(v2);
  }
  uint64_t v3 = a1[9];
  if (v3 != -8192 && v3 != -4096 && v3 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 7);
  }
  uint64_t v5 = a1[3];
  if (v5 != -8192 && v5 != -4096 && v5 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 1);
  }
  return a1;
}

void *sub_1CD492920(void *a1)
{
  uint64_t v2 = (void *)a1[28];
  if (v2 != (void *)a1[27]) {
    free(v2);
  }
  for (uint64_t i = a1[26]; a1 + 25 != (void *)i; uint64_t i = sub_1CD492848((uint64_t)(a1 + 25), i))
    ;
  uint64_t v4 = (void *)a1[6];
  if (v4 != (void *)a1[5]) {
    free(v4);
  }
  return a1;
}

size_t llvm::ImportedFunctionsInliningStatistics::createInlineGraphNode(llvm::ImportedFunctionsInliningStatistics *this, const llvm::Function *a2)
{
  Name = (unsigned __int8 *)llvm::Value::getName(a2);
  size_t result = (*sub_1CD493CC8((uint64_t)this, Name, v4))[1];
  if (!result) {
    operator new();
  }
  return result;
}

_OWORD *llvm::ImportedFunctionsInliningStatistics::recordInline(void **this, const llvm::Function *a2, const llvm::Function *a3)
{
  size_t InlineGraphNode = llvm::ImportedFunctionsInliningStatistics::createInlineGraphNode((llvm::ImportedFunctionsInliningStatistics *)this, a2);
  size_t result = (_OWORD *)llvm::ImportedFunctionsInliningStatistics::createInlineGraphNode((llvm::ImportedFunctionsInliningStatistics *)this, a3);
  ++*((_DWORD *)result + 20);
  if (*(unsigned __int8 *)(InlineGraphNode + 88) | *((unsigned __int8 *)result + 88))
  {
    unsigned int v8 = *(_DWORD *)(InlineGraphNode + 8);
    if (v8 >= *(_DWORD *)(InlineGraphNode + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)InlineGraphNode + 8 * v8) = result;
    ++*(_DWORD *)(InlineGraphNode + 8);
    if (!*(unsigned char *)(InlineGraphNode + 88))
    {
      Name = (unsigned __int8 *)llvm::Value::getName(a2);
      int Key = llvm::StringMapImpl::FindKey((uint64_t *)this, Name, v10);
      if (Key == -1) {
        uint64_t v12 = *((unsigned int *)this + 2);
      }
      else {
        uint64_t v12 = Key;
      }
      uint64_t v13 = (uint64_t *)*((void *)*this + v12);
      uint64_t v14 = *v13;
      *(void *)&long long v16 = v13 + 2;
      *((void *)&v16 + 1) = v14;
      uint64_t v15 = this[5];
      if (v15 >= this[6])
      {
        size_t result = sub_1CC016940(this + 4, &v16);
      }
      else
      {
        *uint64_t v15 = v16;
        size_t result = v15 + 1;
      }
      this[5] = result;
    }
  }
  else
  {
    ++*((_DWORD *)result + 21);
  }
  return result;
}

uint64_t llvm::ImportedFunctionsInliningStatistics::setModuleInfo(uint64_t this, const llvm::Module *a2)
{
  size_t v4 = (char *)*((void *)a2 + 21);
  uint64_t v2 = (char *)a2 + 168;
  uint64_t v3 = v4;
  char v5 = v2[23];
  int v6 = v5;
  if (v5 >= 0) {
    uint64_t v3 = v2;
  }
  uint64_t v7 = v5 & 0x7F;
  if (v6 < 0) {
    uint64_t v7 = *((void *)v2 + 1);
  }
  *(void *)(this + 64) = v3;
  *(void *)(this + 72) = v7;
  unsigned int v8 = v2 - 144;
  uint64_t v9 = *((void *)v2 - 17);
  if ((char *)v9 != v2 - 144)
  {
    uint64_t v10 = this;
    do
    {
      if (v9) {
        uint64_t v11 = (llvm::GlobalValue *)(v9 - 56);
      }
      else {
        uint64_t v11 = 0;
      }
      this = llvm::GlobalValue::isDeclaration(v11);
      if ((this & 1) == 0)
      {
        ++*(_DWORD *)(v10 + 56);
        this = llvm::Value::getMetadata((uint64_t)v11, "thinlto_src_module", 0x12uLL);
        int v12 = *(_DWORD *)(v10 + 60);
        if (this) {
          ++v12;
        }
        *(_DWORD *)(v10 + 60) = v12;
      }
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while ((char *)v9 != v8);
  }
  return this;
}

void llvm::ImportedFunctionsInliningStatistics::dump(size_t *this, int a2)
{
  llvm::ImportedFunctionsInliningStatistics::calculateRealInlines((llvm::ImportedFunctionsInliningStatistics *)this);
  this[5] = this[4];
  llvm::ImportedFunctionsInliningStatistics::getSortedNodes((uint64_t **)this, (uint64_t)&v79);
  memset(&v78, 0, sizeof(v78));
  std::string::reserve(&v78, 0x1388uLL);
  int v70 = 0;
  char v74 = 0;
  uint64_t v75 = 0;
  v77 = &v78;
  int v76 = 0;
  v69 = &unk_1F2646F30;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  size_t v4 = sub_1CB8E509C((llvm::raw_ostream *)&v69, "------- Dumping inliner stats for [");
  char v5 = (const void *)this[8];
  size_t v6 = this[9];
  uint64_t v7 = (void *)*((void *)v4 + 4);
  if (v6 <= *((void *)v4 + 3) - (void)v7)
  {
    if (v6)
    {
      memcpy(v7, v5, this[9]);
      *((void *)v4 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v4, (const char *)v5, this[9]);
  }
  sub_1CB8E509C(v4, "] -------\n");
  if (a2) {
    sub_1CB8E509C((llvm::raw_ostream *)&v69, "-- List of inlined functions:\n");
  }
  uint64_t v9 = v79;
  unsigned int v8 = v80;
  v56 = v79;
  if (v79 == v80)
  {
    uint64_t v13 = 0;
    uint64_t v12 = 0;
    uint64_t v11 = 0;
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    do
    {
      size_t v14 = (*v9)[1];
      if (*(_DWORD *)(v14 + 80))
      {
        int v15 = *(unsigned __int8 *)(v14 + 88);
        BOOL v16 = *(_DWORD *)(v14 + 84) > 0;
        unsigned int v17 = v13 + v16;
        unsigned int v18 = v12 + v16;
        uint64_t v13 = v15 ? v13 : v17;
        uint64_t v12 = v15 ? v18 : v12;
        uint64_t v11 = v15 ? v11 : (v11 + 1);
        uint64_t v10 = v15 ? (v10 + 1) : v10;
        if (a2)
        {
          uint64_t v19 = sub_1CB8E509C((llvm::raw_ostream *)&v69, "Inlined ");
          if (*(unsigned char *)((*v9)[1] + 88)) {
            uint64_t v20 = "imported ";
          }
          else {
            uint64_t v20 = "not imported ";
          }
          uint64_t v21 = sub_1CB8E509C(v19, v20);
          uint64_t v22 = sub_1CB8E509C(v21, "function [");
          uint64_t v23 = *v9 + 2;
          size_t v24 = **v9;
          uint64_t v25 = (void *)*((void *)v22 + 4);
          if (v24 <= *((void *)v22 + 3) - (void)v25)
          {
            if (v24)
            {
              memcpy(v25, v23, **v9);
              *((void *)v22 + 4) += v24;
            }
          }
          else
          {
            llvm::raw_ostream::write(v22, (const char *)v23, **v9);
          }
          uint64_t v26 = sub_1CB8E509C(v22, "]");
          uint64_t v27 = sub_1CB8E509C(v26, ": #inlines = ");
          uint64_t v28 = llvm::raw_ostream::operator<<(v27, *(int *)((*v9)[1] + 80));
          uint64_t v29 = sub_1CB8E509C(v28, ", #inlines_to_importing_module = ");
          unint64_t v30 = llvm::raw_ostream::operator<<(v29, *(int *)((*v9)[1] + 84));
          sub_1CB8E509C(v30, "\n");
        }
      }
      ++v9;
    }
    while (v9 != v8);
  }
  int v31 = *((_DWORD *)this + 15);
  uint64_t v32 = (*((_DWORD *)this + 14) - v31);
  uint64_t v33 = (v31 - v12);
  size_t v34 = sub_1CB8E509C((llvm::raw_ostream *)&v69, "-- Summary:\n");
  size_t v35 = sub_1CB8E509C(v34, "All functions: ");
  size_t v36 = llvm::raw_ostream::operator<<(v35, *((int *)this + 14));
  size_t v37 = sub_1CB8E509C(v36, ", imported functions: ");
  uint64_t v38 = llvm::raw_ostream::operator<<(v37, *((int *)this + 15));
  uint64_t v39 = sub_1CB8E509C(v38, "\n");
  sub_1CC0166DC((uint64_t)v67, "inlined functions", (v10 + v11), *((unsigned int *)this + 14), "all functions", 1);
  if (v68 >= 0) {
    uint64_t v40 = v67;
  }
  else {
    uint64_t v40 = (void **)v67[0];
  }
  if (v68 >= 0) {
    size_t v41 = v68 & 0x7F;
  }
  else {
    size_t v41 = (size_t)v67[1];
  }
  llvm::raw_ostream::write(v39, (const char *)v40, v41);
  sub_1CC0166DC((uint64_t)v65, "imported functions inlined anywhere", v10, *((unsigned int *)this + 15), "imported functions", 1);
  if (v66 >= 0) {
    int v42 = v65;
  }
  else {
    int v42 = (void **)v65[0];
  }
  if (v66 >= 0) {
    size_t v43 = v66 & 0x7F;
  }
  else {
    size_t v43 = (size_t)v65[1];
  }
  llvm::raw_ostream::write(v39, (const char *)v42, v43);
  sub_1CC0166DC((uint64_t)v63, "imported functions inlined into importing module", v12, *((unsigned int *)this + 15), "imported functions", 0);
  if (v64 >= 0) {
    size_t v44 = v63;
  }
  else {
    size_t v44 = (void **)v63[0];
  }
  if (v64 >= 0) {
    size_t v45 = v64 & 0x7F;
  }
  else {
    size_t v45 = (size_t)v63[1];
  }
  llvm::raw_ostream::write(v39, (const char *)v44, v45);
  sub_1CC0166DC((uint64_t)v61, ", remaining", v33, *((unsigned int *)this + 15), "imported functions", 1);
  if (v62 >= 0) {
    int v46 = v61;
  }
  else {
    int v46 = (void **)v61[0];
  }
  if (v62 >= 0) {
    size_t v47 = v62 & 0x7F;
  }
  else {
    size_t v47 = (size_t)v61[1];
  }
  llvm::raw_ostream::write(v39, (const char *)v46, v47);
  sub_1CC0166DC((uint64_t)v59, "non-imported functions inlined anywhere", v11, v32, "non-imported functions", 1);
  if (v60 >= 0) {
    char v48 = v59;
  }
  else {
    char v48 = (void **)v59[0];
  }
  if (v60 >= 0) {
    size_t v49 = v60 & 0x7F;
  }
  else {
    size_t v49 = (size_t)v59[1];
  }
  llvm::raw_ostream::write(v39, (const char *)v48, v49);
  sub_1CC0166DC((uint64_t)__p, "non-imported functions inlined into importing module", v13, v32, "non-imported functions", 1);
  if (v58 >= 0) {
    std::string v50 = __p;
  }
  else {
    std::string v50 = (void **)__p[0];
  }
  if (v58 >= 0) {
    size_t v51 = v58 & 0x7F;
  }
  else {
    size_t v51 = (size_t)__p[1];
  }
  uint64_t v52 = llvm::raw_ostream::write(v39, (const char *)v50, v51);
  if (v58 < 0) {
    operator delete(__p[0]);
  }
  if (v60 < 0) {
    operator delete(v59[0]);
  }
  if (v62 < 0) {
    operator delete(v61[0]);
  }
  if (v64 < 0) {
    operator delete(v63[0]);
  }
  if (v66 < 0) {
    operator delete(v65[0]);
  }
  if (v68 < 0) {
    operator delete(v67[0]);
  }
  if (v73 != v71) {
    uint64_t v52 = (llvm *)llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v69);
  }
  unint64_t v53 = llvm::dbgs(v52);
  if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    v54 = &v78;
  }
  else {
    v54 = (std::string *)v78.__r_.__value_.__r.__words[0];
  }
  if ((v78.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = *((unsigned char *)&v78.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t size = v78.__r_.__value_.__l.__size_;
  }
  llvm::raw_ostream::write(v53, (const char *)v54, size);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v69);
  if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v78.__r_.__value_.__l.__data_);
  }
  if (v56) {
    operator delete(v56);
  }
}

uint64_t llvm::ImportedFunctionsInliningStatistics::calculateRealInlines(llvm::ImportedFunctionsInliningStatistics *this)
{
  uint64_t v2 = (long long *)*((void *)this + 4);
  uint64_t v3 = (long long *)*((void *)this + 5);
  unint64_t v4 = 126 - 2 * __clz(v3 - v2);
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  sub_1CD493DB8(v2, v3, (uint64_t)&v10, v5, 1);
  uint64_t result = (uint64_t)sub_1CC017A1C(*((const void ***)this + 4), *((const void ***)this + 5));
  uint64_t v7 = result;
  uint64_t v8 = *((void *)this + 4);
  if (*((void *)this + 5) != result) {
    *((void *)this + 5) = result;
  }
  while (v8 != v7)
  {
    uint64_t result = (uint64_t)sub_1CD493CC8((uint64_t)this, *(unsigned __int8 **)v8, *(void *)(v8 + 8));
    uint64_t v9 = *(void *)(*(void *)result + 8);
    if (!*(unsigned char *)(v9 + 89)) {
      uint64_t result = llvm::ImportedFunctionsInliningStatistics::dfs((uint64_t)this, (uint64_t **)v9);
    }
    v8 += 16;
  }
  return result;
}

size_t **llvm::ImportedFunctionsInliningStatistics::getSortedNodes@<X0>(uint64_t **this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  sub_1CD45A1D4(a2, *((unsigned int *)this + 3));
  unint64_t v4 = *this;
  uint64_t v5 = *((unsigned int *)this + 2);
  if (v5)
  {
    for (uint64_t i = *this; !*i || *i == -8; ++i)
      ;
  }
  else
  {
    uint64_t i = *this;
  }
  uint64_t v8 = &v4[v5];
  uint64_t v9 = *(size_t ***)(a2 + 8);
  if (i != v8)
  {
    uint64_t v10 = *i;
    do
    {
      if ((unint64_t)v9 >= *(void *)(a2 + 16)) {
        uint64_t v9 = (size_t **)sub_1CBF63C18((void **)a2, v10);
      }
      else {
        *v9++ = (size_t *)v10;
      }
      *(void *)(a2 + 8) = v9;
      do
      {
        uint64_t v11 = i[1];
        ++i;
        uint64_t v10 = v11;
        if (v11) {
          BOOL v12 = v10 == -8;
        }
        else {
          BOOL v12 = 1;
        }
      }
      while (v12);
    }
    while (i != v8);
  }
  uint64_t v13 = *(size_t ***)a2;
  unint64_t v14 = 126 - 2 * __clz(((uint64_t)v9 - *(void *)a2) >> 3);
  if (v9 == *(size_t ***)a2) {
    int v15 = 0;
  }
  else {
    int v15 = (char *)v14;
  }

  return sub_1CC017AF8(v13, v9, v15, 1);
}

uint64_t llvm::ImportedFunctionsInliningStatistics::dfs(uint64_t result, uint64_t **a2)
{
  *((unsigned char *)a2 + 89) = 1;
  uint64_t v2 = *((unsigned int *)a2 + 2);
  if (v2)
  {
    uint64_t v3 = result;
    unint64_t v4 = *a2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v4;
      *(_DWORD *)(v6 + 84) = *(_DWORD *)(*v4 + 84) + 1;
      if (!*(unsigned char *)(v6 + 89)) {
        uint64_t result = llvm::ImportedFunctionsInliningStatistics::dfs(v3);
      }
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  return result;
}

void *sub_1CD493424(void *a1)
{
  *a1 = &unk_1F2604278;
  uint64_t v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F26042E0;
  unint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD49350C(void *a1)
{
  *a1 = &unk_1F26042E0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD493560(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD4935F4(v11);
}

uint64_t sub_1CD4935F4(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD49360C(void *a1)
{
  sub_1CD493424(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD493644(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD493650(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD493660(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    unint64_t v4 = &unk_1F2604330;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD4936E4(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD4936F8(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD493700(void *a1)
{
  *a1 = &unk_1F26042E0;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD493774(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD49377C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD493790(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD4937A4(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD4937B8(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void sub_1CD4937E4(int **a1, uint64_t a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&InlinerFunctionImportStats, 0, 0);
  dword_1EBD03508 = 0;
  qword_1EBD03510 = (uint64_t)&unk_1F2604330;
  *(void *)&dword_1EBD03518 = 0;
  InlinerFunctionImportStats = (uint64_t)&unk_1F2604278;
  qword_1EBD03520 = (uint64_t)&unk_1F26042E0;
  qword_1EBD03528 = (uint64_t)&InlinerFunctionImportStats;
  qword_1EBD03530 = (uint64_t)&unk_1EBD03540;
  qword_1EBD03538 = 0x800000000;
  qword_1EBD036C0 = (uint64_t)&unk_1F2604370;
  qword_1EBD036D8 = (uint64_t)&qword_1EBD036C0;
  sub_1CD4938F8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&InlinerFunctionImportStats);
}

__n128 sub_1CD4938F8(int **a1, uint64_t a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&InlinerFunctionImportStats, "inliner-function-import-stats", 0x1DuLL);
  uint64_t v8 = *a1;
  dword_1EBD03508 = **a1;
  byte_1EBD0351C = 1;
  dword_1EBD03518 = *v8;
  sub_1CD493A14(*(void *)a2, *(_DWORD *)(a2 + 8));
  word_1EBD03492 = (32 * (*a3 & 3)) | word_1EBD03492 & 0xFF9F;
  __n128 result = *a4;
  xmmword_1EBD034A8 = (__int128)*a4;
  return result;
}

void sub_1CD49399C()
{
}

void *sub_1CD4939B0()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F2604370;
  return result;
}

void sub_1CD4939E8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2604370;
}

void sub_1CD493A14(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD493A60(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD493A60(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  void v11[2] = a4;
  v11[3] = a5;
  v11[4] = &unk_1F2604330;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD493B54((unint64_t)v11);
  uint64_t v8 = qword_1EBD03530 + 48 * qword_1EBD03538;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2604350;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2604330;
  LODWORD(qword_1EBD03538) = qword_1EBD03538 + 1;
  llvm::cl::AddLiteralOption(qword_1EBD03528, a1, a2);
}

unint64_t sub_1CD493B54(unint64_t result)
{
  if (qword_1EBD03538 >= HIDWORD(qword_1EBD03538))
  {
    if (qword_1EBD03530 > result || qword_1EBD03530 + 48 * (unint64_t)qword_1EBD03538 <= result) {
      sub_1CD493BD0();
    }
    sub_1CD493BD0();
  }
  return result;
}

void sub_1CD493BD0()
{
}

size_t **sub_1CD493CC8(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t i = (size_t **)(*(void *)a1 + 8 * v6);
  uint64_t v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      long long v9 = i[1];
      ++i;
      uint64_t v8 = v9;
    }
    return i;
  }
  buffer = llvm::allocate_buffer(a3 + 17, (std::align_val_t)8uLL);
  int v12 = buffer;
  char v13 = (char *)(buffer + 2);
  if (a3) {
    memcpy(buffer + 2, a2, a3);
  }
  v13[a3] = 0;
  *int v12 = a3;
  v12[1] = 0;
  *uint64_t i = v12;
  ++*(_DWORD *)(a1 + 12);
  for (uint64_t i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

void sub_1CD493DB8(long long *a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    int v12 = a2 - 1;
LABEL_2:
    for (uint64_t i = 1 - a4; ; ++i)
    {
      uint64_t v14 = (char *)a2 - (char *)a1;
      unint64_t v15 = a2 - a1;
      if (!(!v6 & v5))
      {
        switch(v15)
        {
          case 0uLL:
          case 1uLL:
            return;
          case 2uLL:
            if (sub_1CC016A40(a3, (uint64_t)(a2 - 1), (uint64_t)a1))
            {
              long long v23 = *a1;
              *a1 = *v12;
              *int v12 = v23;
            }
            break;
          case 3uLL:
            sub_1CC016CB4(a1, a1 + 1, a2 - 1, a3);
            break;
          case 4uLL:
            sub_1CC017458(a1, a1 + 1, a1 + 2, a2 - 1, a3);
            break;
          case 5uLL:
            sub_1CC017514(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return;
      }
      if (v14 <= 383)
      {
        if (a5)
        {
          sub_1CC016AAC((uint64_t)a1, a2, a3);
        }
        else
        {
          sub_1CC016BDC((uint64_t)a1, (const void **)a2, a3);
        }
        return;
      }
      if (i == 1)
      {
        if (a1 != a2)
        {
          sub_1CC0175F8((void **)a1, (void **)a2, (void **)a2, a3);
        }
        return;
      }
      unint64_t v16 = v15 >> 1;
      unsigned int v17 = &a1[v15 >> 1];
      if ((unint64_t)v14 >= 0x801)
      {
        sub_1CC016CB4(a1, &a1[v15 >> 1], a2 - 1, a3);
        sub_1CC016CB4(a1 + 1, v17 - 1, a2 - 2, a3);
        sub_1CC016CB4(a1 + 2, &a1[v16 + 1], a2 - 3, a3);
        sub_1CC016CB4(v17 - 1, v17, &a1[v16 + 1], a3);
        long long v22 = *a1;
        *a1 = *v17;
        long long *v17 = v22;
      }
      else
      {
        sub_1CC016CB4(&a1[v15 >> 1], a1, a2 - 1, a3);
      }
      if ((a5 & 1) == 0 && !sub_1CC016A40(a3, (uint64_t)(a1 - 1), (uint64_t)a1))
      {
        unint64_t v21 = sub_1CC016DB0((uint64_t)a1, (const void **)a2);
        goto LABEL_15;
      }
      unsigned int v18 = (long long *)sub_1CC016FEC((uint64_t)a1, (const void **)a2);
      if ((v19 & 1) == 0) {
        goto LABEL_43;
      }
      BOOL v20 = sub_1CC01721C(a1, v18, a3);
      unint64_t v21 = (unint64_t)(v18 + 1);
      if (sub_1CC01721C(v18 + 1, a2, a3)) {
        break;
      }
      if (!v20)
      {
LABEL_43:
        a4 = -i;
        sub_1CD493DB8(a1, v18, a3, -i, a5 & 1);
        a5 = 0;
        a1 = v18 + 1;
        goto LABEL_2;
      }
LABEL_15:
      a1 = (long long *)v21;
    }
    a4 = -i;
    a2 = v18;
    if (!v20) {
      continue;
    }
    break;
  }
}

uint64_t llvm::ICallPromotionAnalysis::getPromotionCandidatesForInstruction(llvm::ICallPromotionAnalysis *this, const llvm::Instruction *a2, unsigned int *a3, unint64_t *a4, unsigned int *a5)
{
  if (llvm::getValueProfDataFromInst((uint64_t)a2, 0, dword_1EBD038E0, *(void *)this, a3, a4, 0))
  {
    LODWORD(v9) = *a3;
    uint64_t result = *(void *)this;
    if (*a3 >= dword_1EBD038E0) {
      uint64_t v9 = dword_1EBD038E0;
    }
    else {
      uint64_t v9 = v9;
    }
    if (v9)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *a4;
      char v13 = (uint64_t *)(result + 8);
      while (1)
      {
        uint64_t v15 = *v13;
        v13 += 2;
        uint64_t v14 = v15;
        unint64_t v16 = 100 * v15;
        if (100 * v15 < v12 * (unint64_t)dword_1EBD03760
          || v16 < *a4 * dword_1EBD03820)
        {
          break;
        }
        v12 -= v14;
        if (v9 == ++v11) {
          goto LABEL_15;
        }
      }
      LODWORD(v9) = v11;
    }
LABEL_15:
    *a5 = v9;
  }
  else
  {
    uint64_t result = 0;
    *a5 = 0;
  }
  return result;
}

void sub_1CD494264(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBD036E0, 0, 0);
  dword_1EBD03760 = 0;
  qword_1EBD03768 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD03770 = 0;
  qword_1EBD036E0 = (uint64_t)&unk_1F2643F00;
  qword_1EBD03778 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD03780 = (uint64_t)&unk_1F25EA168;
  qword_1EBD03798 = (uint64_t)&qword_1EBD03780;
  sub_1CD494364(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD036E0);
}

__n128 sub_1CD494364(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBD036E0, "icp-remaining-percent-threshold", 0x1FuLL);
  dword_1EBD03760 = **a1;
  byte_1EBD03774 = 1;
  dword_1EBD03770 = dword_1EBD03760;
  word_1EBD036EA = word_1EBD036EA & 0xFF9F | (32 * (*a2 & 3));
  word_1EBD036EA = word_1EBD036EA & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBD03700 = (__int128)*a4;
  return result;
}

llvm::cl::Option *sub_1CD4943F8(llvm::cl::Option *a1, char *a2, int **a3, _WORD *a4, _WORD *a5, __n128 *a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(_DWORD *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = &unk_1F25EA1B0;
  *(void *)(v12 + 144) = 0;
  *(void *)uint64_t v12 = &unk_1F2643F00;
  *(void *)(v12 + 152) = &unk_1F2643DB0;
  *(void *)(v12 + 160) = &unk_1F25EA168;
  *(void *)(v12 + 184) = v12 + 160;
  sub_1CD4944F0(v12, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD4944F0(uint64_t a1, char *__s, int **a3, _WORD *a4, _WORD *a5, __n128 *a6)
{
  size_t v12 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v12);
  int v13 = **a3;
  *(_DWORD *)(a1 + 128) = v13;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v13;
  __int16 v14 = *(_WORD *)(a1 + 10) & 0xFF9F | (32 * (*a4 & 3));
  *(_WORD *)(a1 + 10) = v14;
  *(_WORD *)(a1 + 10) = v14 & 0xFFF8 | *a5 & 7;
  __n128 result = *a6;
  *(__n128 *)(a1 + 32) = *a6;
  return result;
}

void sub_1CD494588(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBD03860, 0, 0);
  dword_1EBD038E0 = 0;
  qword_1EBD038E8 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD038F0 = 0;
  qword_1EBD03860 = (uint64_t)&unk_1F2643F00;
  qword_1EBD038F8 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD03900 = (uint64_t)&unk_1F25EA168;
  qword_1EBD03918 = (uint64_t)&qword_1EBD03900;
  sub_1CD494688(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD03860);
}

__n128 sub_1CD494688(int **a1, _WORD *a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBD03860, "icp-max-prom", 0xCuLL);
  dword_1EBD038E0 = **a1;
  byte_1EBD038F4 = 1;
  dword_1EBD038F0 = dword_1EBD038E0;
  word_1EBD0386A = word_1EBD0386A & 0xFF9F | (32 * (*a2 & 3));
  word_1EBD0386A = word_1EBD0386A & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBD03880 = (__int128)*a4;
  return result;
}

uint64_t sub_1CD49471C(uint64_t a1, int a2)
{
  uint64_t result = llvm::AttributeList::getParamByValType((llvm::AttributeList *)(a1 + 64), a2);
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 - 32);
    if (v5 && !*(unsigned char *)(v5 + 16) && *(void *)(v5 + 24) == *(void *)(a1 + 72))
    {
      uint64_t v6 = *(void *)(v5 + 112);
      return llvm::AttributeList::getParamByValType((llvm::AttributeList *)&v6, a2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::getInlineParams@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)(a2 + 12) = 0;
  *(unsigned char *)(a2 + 16) = 0;
  *(unsigned char *)(a2 + 20) = 0;
  *(unsigned char *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 28) = 0;
  *(unsigned char *)(a2 + 32) = 0;
  *(unsigned char *)(a2 + 44) = 0;
  *(unsigned char *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 60) = 0;
  *(_WORD *)(a2 + 64) = 256;
  int v2 = (unsigned __int16)word_1EBD039E8;
  int v3 = dword_1EBD03A60;
  if (!word_1EBD039E8) {
    int v3 = this;
  }
  int v4 = dword_1EBD03B20;
  *(_DWORD *)a2 = v3;
  *(_DWORD *)(a2 + 4) = v4;
  *(unsigned char *)(a2 + 8) = 1;
  *(_DWORD *)(a2 + 36) = dword_1EBD03D60;
  *(unsigned char *)(a2 + 40) = 1;
  if (word_1EBD03DA8)
  {
    *(_DWORD *)(a2 + 44) = dword_1EBD03E20;
    *(unsigned char *)(a2 + 48) = 1;
  }
  *(_DWORD *)(a2 + 52) = dword_1EBD03BE0;
  *(unsigned char *)(a2 + 56) = 1;
  if (!v2)
  {
    *(_DWORD *)(a2 + 28) = 5;
    *(unsigned char *)(a2 + 32) = 1;
    *(_DWORD *)(a2 + 20) = 50;
    *(unsigned char *)(a2 + 24) = 1;
LABEL_7:
    *(_DWORD *)(a2 + 12) = dword_1EBD03CA0;
    *(unsigned char *)(a2 + 16) = 1;
    return this;
  }
  if (word_1EBD03C28) {
    goto LABEL_7;
  }
  return this;
}

uint64_t llvm::getInlineParams@<X0>(uint64_t a1@<X8>)
{
  return llvm::getInlineParams(dword_1EBD039A0, a1);
}

uint64_t llvm::getInlineParams@<X0>(llvm *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (this > 2)
  {
    uint64_t result = llvm::getInlineParams(250, a3);
    int v6 = *(unsigned __int8 *)(a3 + 48);
    *(_DWORD *)(a3 + 44) = dword_1EBD03E20;
    if (!v6) {
      *(unsigned char *)(a3 + 48) = 1;
    }
  }
  else
  {
    if (a2 == 1)
    {
      uint64_t v3 = 50;
    }
    else if (a2 == 2)
    {
      uint64_t v3 = 5;
    }
    else
    {
      uint64_t v3 = dword_1EBD039A0;
    }
    return llvm::getInlineParams(v3, a3);
  }
  return result;
}

llvm::APInt *sub_1CD494920(llvm::APInt *this, uint64_t *a2, uint64_t *a3)
{
  if (*((unsigned char *)this + 32))
  {
    sub_1CD494A40((uint64_t)this);
    *((unsigned char *)this + 32) = 0;
  }
  unsigned int v6 = *((_DWORD *)a2 + 2);
  unsigned int v12 = v6;
  uint64_t v7 = *a2;
  uint64_t v11 = *a2;
  *((_DWORD *)a2 + 2) = 0;
  unsigned int v10 = *((_DWORD *)a3 + 2);
  if (v10 > 0x40) {
    operator new[]();
  }
  uint64_t v9 = *a3;
  uint64_t result = sub_1CD494AB4(this, (const llvm::APInt *)&v11, (llvm::APInt *)&v9);
  if (v6 >= 0x41 && v7) {
    uint64_t result = (llvm::APInt *)MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
  }
  *((unsigned char *)this + 32) = 1;
  return result;
}

uint64_t sub_1CD494A40(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 8) >= 0x41u && *(void *)a1) {
    MEMORY[0x1D25D9CB0](*(void *)a1, 0x1000C8000313F17);
  }
  return a1;
}

llvm::APInt *sub_1CD494AB4(llvm::APInt *this, const llvm::APInt *a2, llvm::APInt *a3)
{
  unsigned int v4 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 2) = v4;
  if (v4 > 0x40) {
    llvm::APInt::initSlowCase(this, a2);
  }
  *(void *)this = *(void *)a2;
  uint64_t v5 = (llvm::APInt *)((char *)this + 16);
  unsigned int v6 = *((_DWORD *)a3 + 2);
  *((_DWORD *)this + 6) = v6;
  if (v6 > 0x40) {
    llvm::APInt::initSlowCase(v5, a3);
  }
  *(void *)uint64_t v5 = *(void *)a3;
  return this;
}

uint64_t sub_1CD494B28(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CC01F8D4(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      unsigned int v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD494BD8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CBB082D8(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      unsigned int v10 = v11;
      *uint64_t v11 = *(void *)a2;
      v10[1] = *(void *)(a2 + 8);
      *((_DWORD *)v10 + 6) = *(_DWORD *)(a2 + 24);
      void v10[2] = *(void *)(a2 + 16);
      *(_DWORD *)(a2 + 24) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

BOOL sub_1CD494C9C(uint64_t a1)
{
  BOOL v2 = sub_1CB845E74(a1);
  BOOL result = 0;
  if (!a1 || !v2) {
    return result;
  }
  unsigned int v4 = *(unsigned __int8 *)(a1 + 16);
  if (v4 > 0x1B) {
    unsigned int v5 = v4 - 28;
  }
  else {
    unsigned int v5 = *(unsigned __int16 *)(a1 + 18);
  }
  if (v5 == 12) {
    return 1;
  }
  if (v5 != 16) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 17) & 0x10) != 0)
  {
    int v8 = *(_DWORD *)(a1 + 20);
    if ((v8 & 0x40000000) != 0) {
      uint64_t v9 = *(llvm::Constant ***)(a1 - 8);
    }
    else {
      uint64_t v9 = (llvm::Constant **)(a1 - 32 * (v8 & 0x7FFFFFF));
    }
    return sub_1CC0241FC((uint64_t)&v11, *v9);
  }
  int v6 = *(_DWORD *)(a1 + 20);
  if ((v6 & 0x40000000) != 0) {
    uint64_t v7 = *(llvm::Constant ***)(a1 - 8);
  }
  else {
    uint64_t v7 = (llvm::Constant **)(a1 - 32 * (v6 & 0x7FFFFFF));
  }
  BOOL result = sub_1CC02435C((uint64_t)&v10, *v7);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sub_1CD494D68(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        sub_1CC024F40(*(std::string **)a2, (std::string *)(*(void *)a2 + (v4 << 6)), *(std::string **)a1);
        int v13 = v12;
        __int16 v14 = *(std::string **)a1;
        uint64_t v5 = *(unsigned int *)(a1 + 8);
      }
      else
      {
        __int16 v14 = *(std::string **)a1;
        int v13 = *(std::string **)a1;
      }
      for (uint64_t i = (uint64_t)v14 + 64 * v5; (std::string *)i != v13; uint64_t i = sub_1CC024FB8(i - 64))
        ;
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        if (v5)
        {
          uint64_t v16 = v5 << 6;
          uint64_t v17 = *(void *)a1 - 64;
          do
          {
            sub_1CC024FB8(v17 + v16);
            v16 -= 64;
          }
          while (v16);
        }
        *(_DWORD *)(a1 + 8) = 0;
        sub_1CD494E94();
      }
      if (v5) {
        sub_1CC024F40(*(std::string **)a2, (std::string *)(*(void *)a2 + (v5 << 6)), *(std::string **)a1);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6)
      {
        uint64_t v7 = *(void *)a1 + (v5 << 6);
        int v8 = (long long *)(*(void *)a2 + (v5 << 6));
        uint64_t v9 = (v6 << 6) - (v5 << 6);
        do
        {
          sub_1CB8BDEEC(v7, v8);
          v8 += 4;
          uint64_t v7 = v10 + 64;
          v9 -= 64;
        }
        while (v9);
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void sub_1CD494E94()
{
}

uint64_t sub_1CD494F04(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v3 = *(long long **)result;
    uint64_t v4 = *(void *)result + (v2 << 6);
    do
    {
      long long v5 = *v3;
      *(void *)(a2 + 16) = *((void *)v3 + 2);
      *(_OWORD *)a2 = v5;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
      *(void *)uint64_t v3 = 0;
      long long v6 = *(long long *)((char *)v3 + 24);
      *(void *)(a2 + 40) = *((void *)v3 + 5);
      *(_OWORD *)(a2 + 24) = v6;
      *((void *)v3 + 4) = 0;
      *((void *)v3 + 5) = 0;
      *((void *)v3 + 3) = 0;
      *(_OWORD *)(a2 + 48) = v3[3];
      v3 += 4;
      a2 += 64;
    }
    while (v3 != (long long *)v4);
    uint64_t v7 = *(unsigned int *)(result + 8);
    if (v7)
    {
      uint64_t v8 = v7 << 6;
      uint64_t v9 = *(void *)result - 64;
      do
      {
        BOOL result = sub_1CC024FB8(v9 + v8);
        v8 -= 64;
      }
      while (v8);
    }
  }
  return result;
}

llvm::APInt *sub_1CD494F9C(llvm::APInt *this, llvm::APInt *a2)
{
  unsigned int v4 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 2) = v4;
  if (v4 > 0x40) {
    llvm::APInt::initSlowCase(this, a2);
  }
  *(void *)this = *(void *)a2;
  long long v5 = (llvm::APInt *)((char *)this + 16);
  long long v6 = (llvm::APInt *)((char *)a2 + 16);
  unsigned int v7 = *((_DWORD *)a2 + 6);
  *((_DWORD *)this + 6) = v7;
  if (v7 > 0x40) {
    llvm::APInt::initSlowCase(v5, v6);
  }
  *(void *)long long v5 = *(void *)v6;
  return this;
}

llvm::cl::Option *sub_1CD495014(llvm::cl::Option *a1, char *a2, _WORD *a3, _DWORD **a4, _WORD *a5, __n128 *a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(_DWORD *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = &unk_1F25F74C8;
  *(void *)(v12 + 144) = 0;
  *(void *)uint64_t v12 = &unk_1F2643F68;
  *(void *)(v12 + 152) = &unk_1F2643D20;
  *(void *)(v12 + 160) = &unk_1F25F7480;
  *(void *)(v12 + 184) = v12 + 160;
  sub_1CD49510C(v12, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD49510C(uint64_t a1, char *__s, _WORD *a3, _DWORD **a4, _WORD *a5, __n128 *a6)
{
  size_t v12 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v12);
  __int16 v13 = *(_WORD *)(a1 + 10) & 0xFF9F | (32 * (*a3 & 3));
  *(_WORD *)(a1 + 10) = v13;
  __int16 v14 = *a4;
  *(_DWORD *)(a1 + 128) = **a4;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v14;
  *(_WORD *)(a1 + 10) = v13 & 0xFFF8 | *a5 & 7;
  __n128 result = *a6;
  *(__n128 *)(a1 + 32) = *a6;
  return result;
}

void sub_1CD4951A8(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBD039E0, 0, 0);
  dword_1EBD03A60 = 0;
  qword_1EBD03A68 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBD03A70 = 0;
  qword_1EBD039E0 = (uint64_t)&unk_1F2643F68;
  qword_1EBD03A78 = (uint64_t)&unk_1F2643D20;
  qword_1EBD03A80 = (uint64_t)&unk_1F25F7480;
  qword_1EBD03A98 = (uint64_t)&qword_1EBD03A80;
  sub_1CD4952A8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD039E0);
}

__n128 sub_1CD4952A8(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBD039E0, "inline-threshold", 0x10uLL);
  word_1EBD039EA = word_1EBD039EA & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  dword_1EBD03A60 = **a2;
  byte_1EBD03A74 = 1;
  dword_1EBD03A70 = *v8;
  word_1EBD039EA = word_1EBD039EA & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBD03A00 = (__int128)*a4;
  return result;
}

void sub_1CD495340(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC58B0, 0, 0);
  dword_1EBCC5930 = 0;
  qword_1EBCC5938 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCC5940 = 0;
  qword_1EBCC58B0 = (uint64_t)&unk_1F2643F68;
  qword_1EBCC5948 = (uint64_t)&unk_1F2643D20;
  qword_1EBCC5950 = (uint64_t)&unk_1F25F7480;
  qword_1EBCC5968 = (uint64_t)&qword_1EBCC5950;
  sub_1CD495440(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC58B0);
}

__n128 sub_1CD495440(_WORD *a1, int **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC58B0, "inline-savings-multiplier", 0x19uLL);
  word_1EBCC58BA = word_1EBCC58BA & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  dword_1EBCC5930 = **a2;
  byte_1EBCC5944 = 1;
  dword_1EBCC5940 = *v8;
  word_1EBCC58BA = word_1EBCC58BA & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCC58D0 = (__int128)*a4;
  return result;
}

llvm::cl::Option *sub_1CD4954D8(llvm::cl::Option *a1, char *a2, _WORD *a3, _DWORD **a4, __n128 *a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25F74C8;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F68;
  *(void *)(v10 + 152) = &unk_1F2643D20;
  *(void *)(v10 + 160) = &unk_1F25F7480;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD4955C8(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD4955C8(uint64_t a1, char *__s, _WORD *a3, _DWORD **a4, __n128 *a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  char v11 = *a4;
  *(_DWORD *)(a1 + 128) = **a4;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v11;
  __n128 result = *a5;
  *(__n128 *)(a1 + 32) = *a5;
  return result;
}

llvm::cl::Option *sub_1CD49565C(llvm::cl::Option *a1, char *a2, _WORD *a3, unsigned char **a4, _WORD *a5, __n128 *a6)
{
  uint64_t v12 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(unsigned char *)(v12 + 128) = 0;
  *(void *)(v12 + 136) = &unk_1F25EDE58;
  *(void *)(v12 + 144) = 0;
  *(void *)uint64_t v12 = &unk_1F26440A0;
  *(void *)(v12 + 152) = &unk_1F2643CC0;
  *(void *)(v12 + 160) = &unk_1F25EDE78;
  *(void *)(v12 + 184) = v12 + 160;
  sub_1CD495754(v12, a2, a3, a4, a5, a6);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD495754(uint64_t a1, char *__s, _WORD *a3, unsigned char **a4, _WORD *a5, __n128 *a6)
{
  size_t v12 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v12);
  __int16 v13 = *(_WORD *)(a1 + 10) & 0xFF9F | (32 * (*a3 & 3));
  *(_WORD *)(a1 + 10) = v13;
  __int16 v14 = *a4;
  *(unsigned char *)(a1 + 128) = **a4;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v14;
  *(_WORD *)(a1 + 10) = v13 & 0xFFF8 | *a5 & 7;
  __n128 result = *a6;
  *(__n128 *)(a1 + 32) = *a6;
  return result;
}

void sub_1CD4957F0(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC5C70, 0, 0);
  byte_1EBCC5CF0 = 0;
  qword_1EBCC5CF8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC5D00 = 0;
  qword_1EBCC5C70 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC5D08 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC5D10 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC5D28 = (uint64_t)&qword_1EBCC5D10;
  sub_1CD4958F0(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC5C70);
}

__n128 sub_1CD4958F0(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC5C70, "inline-caller-superset-nobuiltin", 0x20uLL);
  word_1EBCC5C7A = word_1EBCC5C7A & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  byte_1EBCC5CF0 = **a2;
  byte_1EBCC5D01 = 1;
  byte_1EBCC5D00 = *v8;
  word_1EBCC5C7A = word_1EBCC5C7A & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCC5C90 = (__int128)*a4;
  return result;
}

void llvm::InlineAdvisorAnalysis::Result::tryCreate()
{
}

void llvm::formatCallSiteLocation(llvm::DebugLoc *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)char v58 = *MEMORY[0x1E4F143B8];
  v51[0] = 0;
  v51[1] = 0;
  uint64_t v52 = 0;
  int v43 = 0;
  char v47 = 0;
  uint64_t v48 = 0;
  std::string v50 = v51;
  int v49 = 0;
  int v42 = &unk_1F2646F30;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v4 = llvm::DebugLoc::get(a1);
  if (v4)
  {
    uint64_t v5 = v4;
    char v6 = 1;
    while (1)
    {
      if ((v6 & 1) == 0) {
        sub_1CB8E509C((llvm::raw_ostream *)&v42, " @ ");
      }
      int v7 = *(_DWORD *)(v5 + 4);
      int v8 = *(_DWORD *)(llvm::DILocalScope::getSubprogram(*(void *)(v5 - 8 * *(unsigned int *)(v5 + 8))) + 24);
      unsigned int v9 = sub_1CD495F94(v5);
      uint64_t Subprogram = llvm::DILocalScope::getSubprogram(*(void *)(v5 - 8 * *(unsigned int *)(v5 + 8)));
      char v11 = *(llvm::MDString **)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8) + 24);
      if (!v11 || (String = (const std::string::value_type *)llvm::MDString::getString(v11), !v13))
      {
        uint64_t v14 = llvm::DILocalScope::getSubprogram(*(void *)(v5 - 8 * *(unsigned int *)(v5 + 8)));
        uint64_t v15 = *(llvm::MDString **)(v14 - 8 * *(unsigned int *)(v14 + 8) + 16);
        if (!v15) {
          goto LABEL_11;
        }
        String = (const std::string::value_type *)llvm::MDString::getString(v15);
      }
      if (!String)
      {
LABEL_11:
        std::string::size_type size = 0;
        std::string::size_type v18 = 0;
        char v16 = 0;
        memset(&v41, 0, sizeof(v41));
        goto LABEL_12;
      }
      std::string::__init(&v41, String, v13);
      char v16 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
      std::string::size_type size = v41.__r_.__value_.__l.__size_;
      std::string::size_type v18 = v41.__r_.__value_.__r.__words[0];
LABEL_12:
      BOOL v19 = v16 < 0;
      if (v16 >= 0) {
        BOOL v20 = &v41;
      }
      else {
        BOOL v20 = (std::string *)v18;
      }
      size_t v21 = v16 & 0x7F;
      if (v19) {
        size_t v22 = size;
      }
      else {
        size_t v22 = v21;
      }
      llvm::raw_ostream::write((llvm::raw_ostream *)&v42, (const char *)v20, v22);
      long long v23 = sub_1CB8E509C((llvm::raw_ostream *)&v42, ":");
      if (v7 == v8)
      {
        char v57 = 48;
        size_t v24 = &v57;
      }
      else
      {
        unint64_t v25 = (v7 - v8);
        size_t v24 = v58;
        do
        {
          *--size_t v24 = (v25 % 0xA) | 0x30;
          BOOL v19 = v25 > 9;
          v25 /= 0xAuLL;
        }
        while (v19);
      }
      sub_1CC028D80(__p, v24, v58, v58 - v24);
      if (v56 >= 0) {
        uint64_t v26 = __p;
      }
      else {
        uint64_t v26 = (void **)__p[0];
      }
      if (v56 >= 0) {
        size_t v27 = v56 & 0x7F;
      }
      else {
        size_t v27 = (size_t)__p[1];
      }
      llvm::raw_ostream::write(v23, (const char *)v26, v27);
      if (v56 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      int v28 = *a2;
      if ((*a2 & 0xFFFFFFFD) == 1)
      {
        uint64_t v29 = sub_1CB8E509C((llvm::raw_ostream *)&v42, ":");
        unint64_t v30 = *(unsigned __int16 *)(v5 + 2);
        int v31 = v55;
        if (*(_WORD *)(v5 + 2))
        {
          do
          {
            *--int v31 = (v30 % 0xA) | 0x30;
            BOOL v19 = v30 > 9;
            v30 /= 0xAuLL;
          }
          while (v19);
        }
        else
        {
          int v31 = &v54;
          char v54 = 48;
        }
        sub_1CC028D80(&v41, v31, v55, v55 - v31);
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v32 = &v41;
        }
        else {
          uint64_t v32 = (std::string *)v41.__r_.__value_.__r.__words[0];
        }
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v33 = *((unsigned char *)&v41.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t v33 = v41.__r_.__value_.__l.__size_;
        }
        llvm::raw_ostream::write(v29, (const char *)v32, v33);
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v41.__r_.__value_.__l.__data_);
        }
        int v28 = *a2;
      }
      if ((v28 & 0xFFFFFFFE) == 2)
      {
        if (v9)
        {
          size_t v34 = sub_1CB8E509C((llvm::raw_ostream *)&v42, ".");
          uint64_t v35 = 0;
          unint64_t v36 = v9;
          do
          {
            v55[--v35] = (v36 % 0xA) | 0x30;
            BOOL v19 = v36 > 9;
            v36 /= 0xAuLL;
          }
          while (v19);
          sub_1CC028D80(&v41, &v55[v35], v55, -v35);
          size_t v37 = (v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? &v41
              : (std::string *)v41.__r_.__value_.__r.__words[0];
          size_t v38 = (v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? *((unsigned char *)&v41.__r_.__value_.__s + 23) & 0x7F
              : v41.__r_.__value_.__l.__size_;
          llvm::raw_ostream::write(v34, (const char *)v37, v38);
          if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v41.__r_.__value_.__l.__data_);
          }
        }
      }
      if (*(_DWORD *)(v5 + 8) == 2)
      {
        char v6 = 0;
        uint64_t v5 = *(void *)(v5 - 8);
        if (v5) {
          continue;
        }
      }
      break;
    }
  }
  if (*((char *)v50 + 23) < 0)
  {
    sub_1CB8BDF7C(a3, *v50, (unint64_t)v50[1]);
  }
  else
  {
    long long v39 = *(_OWORD *)v50;
    *(void *)(a3 + 16) = v50[2];
    *(_OWORD *)a3 = v39;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v42);
  if (SHIBYTE(v52) < 0) {
    operator delete(v51[0]);
  }
}

uint64_t sub_1CD495F94(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 - 8 * *(unsigned int *)(a1 + 8));
  if (*(unsigned char *)v1 == 19) {
    unsigned int v2 = *(_DWORD *)(v1 + 24);
  }
  else {
    unsigned int v2 = 0;
  }
  if (byte_1EBD064B8) {
    return v2;
  }
  unsigned int v4 = (v2 >> 1) & 0x1F;
  if ((v2 & 0x40) != 0) {
    unsigned int v4 = (v2 >> 2) & 0xFE0 | (v2 >> 1) & 0x1F;
  }
  if (v2) {
    return 0;
  }
  else {
    return v4;
  }
}

uint64_t llvm::addLocationToRemarks(uint64_t result, llvm::DebugLoc *a2)
{
  if (*(void *)a2)
  {
    uint64_t v3 = result;
    uint64_t v29 = " at callsite ";
    uint64_t v30 = 13;
    unsigned int v4 = (uint64_t *)(result + 80);
    sub_1CC59ADEC((uint64_t *)(result + 80), (uint64_t)&v29);
    uint64_t v5 = llvm::DebugLoc::get(a2);
    if (v5)
    {
      uint64_t v6 = v5;
      char v7 = 1;
      do
      {
        if ((v7 & 1) == 0)
        {
          uint64_t v29 = " @ ";
          uint64_t v30 = 3;
          sub_1CC59ADEC(v4, (uint64_t)&v29);
        }
        int v8 = *(_DWORD *)(v6 + 4);
        int v9 = *(_DWORD *)(llvm::DILocalScope::getSubprogram(*(void *)(v6 - 8 * *(unsigned int *)(v6 + 8))) + 24);
        uint64_t v10 = sub_1CD495F94(v6);
        uint64_t Subprogram = llvm::DILocalScope::getSubprogram(*(void *)(v6 - 8 * *(unsigned int *)(v6 + 8)));
        size_t v12 = *(llvm::MDString **)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8) + 24);
        if (!v12 || (String = (llvm::MDString *)llvm::MDString::getString(v12), !v14))
        {
          uint64_t v15 = llvm::DILocalScope::getSubprogram(*(void *)(v6 - 8 * *(unsigned int *)(v6 + 8)));
          String = *(llvm::MDString **)(v15 - 8 * *(unsigned int *)(v15 + 8) + 16);
          if (String) {
            String = (llvm::MDString *)llvm::MDString::getString(String);
          }
          else {
            uint64_t v14 = 0;
          }
        }
        uint64_t v29 = (const char *)String;
        uint64_t v30 = v14;
        sub_1CC59ADEC(v4, (uint64_t)&v29);
        uint64_t v29 = ":";
        uint64_t v30 = 1;
        sub_1CC59ADEC(v4, (uint64_t)&v29);
        llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v25, "Line", 4, (v8 - v9));
        uint64_t v16 = sub_1CD3D6290(v3, (long long *)v25);
        uint64_t v29 = ":";
        uint64_t v30 = 1;
        sub_1CC59ADEC((uint64_t *)(v16 + 80), (uint64_t)&v29);
        llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v21, "Column", 6, *(unsigned __int16 *)(v6 + 2));
        sub_1CD3D6290(v16, (long long *)v21);
        if (v24 < 0) {
          operator delete(__p);
        }
        if (v22 < 0) {
          operator delete(v21[0]);
        }
        if (v28 < 0) {
          operator delete(v27);
        }
        if (v26 < 0) {
          operator delete(v25[0]);
        }
        if (v10)
        {
          uint64_t v29 = ".";
          uint64_t v30 = 1;
          sub_1CC59ADEC(v4, (uint64_t)&v29);
          llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v17, "Disc", 4, v10);
          sub_1CD3D6290(v3, (long long *)v17);
          if (v20 < 0) {
            operator delete(v19);
          }
          if (v18 < 0) {
            operator delete(v17[0]);
          }
        }
        if (*(_DWORD *)(v6 + 8) != 2) {
          break;
        }
        char v7 = 0;
        uint64_t v6 = *(void *)(v6 - 8);
      }
      while (v6);
    }
    uint64_t v29 = ";";
    uint64_t v30 = 1;
    return sub_1CC59ADEC(v4, (uint64_t)&v29);
  }
  return result;
}

void *llvm::InlineAdvisor::InlineAdvisor(void *result, uint64_t a2, uint64_t a3)
{
  *__n128 result = &unk_1F26046F8;
  result[1] = a2;
  result[2] = a3;
  result[3] = 0;
  if (dword_1EBD03508) {
    operator new();
  }
  return result;
}

void llvm::InlineAdvisor::~InlineAdvisor(llvm::InlineAdvisor *this)
{
  *(void *)this = &unk_1F26046F8;
  uint64_t v1 = (size_t *)*((void *)this + 3);
  if (v1)
  {
    llvm::ImportedFunctionsInliningStatistics::dump(v1, dword_1EBD03508 == 2);
    uint64_t v2 = *((void *)this + 3);
    *((void *)this + 3) = 0;
    if (v2)
    {
      uint64_t v3 = sub_1CD496928(v2);
      MEMORY[0x1D25D9CE0](v3, 0x10F0C40A22A8682);
    }
  }
  else
  {
    *((void *)this + 3) = 0;
  }
}

void llvm::InlineAdvisorAnalysisPrinterPass::run()
{
}

void sub_1CD4964BC(llvm::InlineAdvisor *a1)
{
  llvm::InlineAdvisor::~InlineAdvisor(a1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::raw_ostream *sub_1CD4964F4(int a1, llvm::raw_ostream *a2)
{
  return sub_1CB8E509C(a2, "Unimplemented InlineAdvisor print\n");
}

void *sub_1CD496504(void *a1)
{
  *a1 = &unk_1F26046B8;
  unsigned int v4 = (unsigned __int8 *)a1[4];
  uint64_t v2 = (uint64_t)(a1 + 4);
  uint64_t v3 = v4;
  if (v4) {
    llvm::MetadataTracking::untrack(v2, v3);
  }
  return a1;
}

void sub_1CD496550(void *a1)
{
  *a1 = &unk_1F26046B8;
  uint64_t v3 = (unsigned __int8 *)a1[4];
  uint64_t v1 = (uint64_t)(a1 + 4);
  uint64_t v2 = v3;
  if (v3) {
    llvm::MetadataTracking::untrack(v1, v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

llvm::cl::Option *sub_1CD4965C8(llvm::cl::Option *a1, char *a2, __n128 *a3, _DWORD **a4, _WORD *a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25F74C8;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F68;
  *(void *)(v10 + 152) = &unk_1F2643D20;
  *(void *)(v10 + 160) = &unk_1F25F7480;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD4966B8(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD4966B8(uint64_t a1, char *__s, __n128 *a3, _DWORD **a4, _WORD *a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  __n128 result = *a3;
  *(__n128 *)(a1 + 32) = *a3;
  size_t v12 = *a4;
  *(_DWORD *)(a1 + 128) = **a4;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v12;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  return result;
}

uint64_t sub_1CD49674C(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 0x7FFFFFFF)
  {
    unsigned int v4 = "(cost=never)";
    uint64_t v5 = 12;
    goto LABEL_5;
  }
  if (*(_DWORD *)a2 == 0x80000000)
  {
    unsigned int v4 = "(cost=always)";
    uint64_t v5 = 13;
LABEL_5:
    long long v23 = v4;
    uint64_t v24 = v5;
    sub_1CC59ADEC((uint64_t *)(a1 + 80), (uint64_t)&v23);
    goto LABEL_6;
  }
  long long v23 = "(cost=";
  uint64_t v24 = 6;
  sub_1CC59ADEC((uint64_t *)(a1 + 80), (uint64_t)&v23);
  llvm::DiagnosticInfoOptimizationBase::Argument::Argument(&v19, "Cost", 4uLL, *(_DWORD *)a2);
  uint64_t v9 = sub_1CD3D6290(a1, &v19);
  long long v23 = ", threshold=";
  uint64_t v24 = 12;
  sub_1CC59ADEC((uint64_t *)(v9 + 80), (uint64_t)&v23);
  llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v15, "Threshold", 9uLL, *(_DWORD *)(a2 + 4));
  uint64_t v10 = sub_1CD3D6290(v9, (long long *)v15);
  long long v23 = ")";
  uint64_t v24 = 1;
  sub_1CC59ADEC((uint64_t *)(v10 + 80), (uint64_t)&v23);
  if (v18 < 0) {
    operator delete(v17);
  }
  if (v16 < 0) {
    operator delete(v15[0]);
  }
  if (v22 < 0) {
    operator delete(v21);
  }
  if (v20 < 0) {
    operator delete((void *)v19);
  }
LABEL_6:
  uint64_t v6 = *(char **)(a2 + 8);
  if (v6)
  {
    long long v23 = ": ";
    uint64_t v24 = 2;
    sub_1CC59ADEC((uint64_t *)(a1 + 80), (uint64_t)&v23);
    size_t v8 = strlen(v6);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument(v11, "Reason", 6uLL, v6, v8);
    sub_1CD3D6290(a1, (long long *)v11);
    if (v14 < 0) {
      operator delete(__p);
    }
    if (v12 < 0) {
      operator delete(v11[0]);
    }
  }
  return a1;
}

uint64_t sub_1CD496928(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    *(void *)(a1 + 40) = v1;
    uint64_t v3 = a1;
    operator delete(v1);
    a1 = v3;
  }

  return sub_1CD496974(a1);
}

uint64_t sub_1CD496974(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)(*(void *)a1 + v4);
        if (v6 != -8 && v6 != 0)
        {
          sub_1CC029070((void ***)(v6 + 8));
          MEMORY[0x1D25D9CD0](v6, 8);
        }
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  free(*(void **)a1);
  return a1;
}

uint64_t llvm::InlineSizeEstimatorAnalysis::run()
{
  return 0;
}

void llvm::InlineSizeEstimatorAnalysisPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "[InlineSizeEstimatorAnalysis] size estimate for ");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  char v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, ": ");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

double llvm::InstCountPass::run@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = a1 + 80;
  *(void *)(a1 + 56) = a1 + 80;
  *(void *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a1 + 16) = 0x100000002;
  return result;
}

void llvm::createInstCountPass(llvm *this)
{
}

void *sub_1CD496C0C(void *a1)
{
  *a1 = &unk_1F26048F8;
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

void sub_1CD496C58(void *a1)
{
  *a1 = &unk_1F26048F8;
  MEMORY[0x1D25D9CD0](a1[1], 8);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD496CC4(void *a1)
{
  *a1 = &unk_1F26048F8;
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

void sub_1CD496D10(void *a1)
{
  *a1 = &unk_1F26048F8;
  MEMORY[0x1D25D9CD0](a1[1], 8);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t llvm::replaceAndRecursivelySimplify(llvm::Instruction *a1, llvm::Value *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v40[8] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a1;
  uint64_t v33 = 1;
  int64x2_t v34 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v35 = v34;
  int64x2_t v36 = v34;
  int64x2_t v37 = v34;
  size_t v38 = v40;
  uint64_t v39 = 0x800000000;
  uint64_t Module = llvm::Instruction::getModule(a1);
  if (a2)
  {
    char v12 = v32;
    uint64_t v13 = *((void *)v32 + 1);
    if (v13)
    {
      do
      {
        if (*(llvm::Instruction **)(v13 + 24) != v32)
        {
          v30[0] = *(void *)(v13 + 24);
          sub_1CC04D4E0((uint64_t)&v33, v30);
        }
        uint64_t v13 = *(void *)(v13 + 8);
      }
      while (v13);
      char v12 = v32;
    }
    llvm::Value::replaceAllUsesWith(v12, a2);
    if (*((void *)v32 + 5))
    {
      int v19 = *((unsigned __int8 *)v32 + 16);
      BOOL v20 = (v19 - 38) > 0x38 || ((1 << (v19 - 38)) & 0x100060000000001) == 0;
      if (v20 && (v19 - 29) >= 0xB && (llvm::Instruction::mayHaveSideEffects(v32) & 1) == 0) {
        llvm::Instruction::eraseFromParent(v32);
      }
    }
  }
  else
  {
    sub_1CC04D4E0((uint64_t)&v33, (uint64_t *)&v32);
  }
  if (v39)
  {
    char v21 = 0;
    unsigned int v22 = 0;
    uint64_t v23 = Module + 272;
    while (1)
    {
      uint64_t v32 = (llvm::Instruction *)*((void *)v38 + v22);
      v30[0] = v23;
      v30[1] = a3;
      v30[2] = a4;
      void v30[3] = a5;
      v30[4] = 0;
      __int16 v31 = 257;
      uint64_t v24 = llvm::SimplifyInstruction(v32, (uint64_t)v30, v14, v15, v16, v17, v18);
      if (!v24)
      {
        if (a6) {
          sub_1CC04D4E0(a6, (uint64_t *)&v32);
        }
        goto LABEL_34;
      }
      unint64_t v25 = v24;
      char v26 = v32;
      uint64_t v27 = *((void *)v32 + 1);
      if (v27)
      {
        do
        {
          v30[0] = *(void *)(v27 + 24);
          sub_1CC04D4E0((uint64_t)&v33, v30);
          uint64_t v27 = *(void *)(v27 + 8);
        }
        while (v27);
        char v26 = v32;
      }
      llvm::Value::replaceAllUsesWith(v26, v25);
      if (!*((void *)v32 + 5)) {
        goto LABEL_33;
      }
      int v28 = *((unsigned __int8 *)v32 + 16);
      if ((v28 - 38) < 0x39) {
        break;
      }
      if ((v28 - 29) >= 0xB) {
        goto LABEL_31;
      }
LABEL_33:
      char v21 = 1;
LABEL_34:
      if (v39 == ++v22) {
        goto LABEL_35;
      }
    }
    char v21 = 1;
    if (((0x100060000000001uLL >> (v28 - 38)) & 1) != 0 || (v28 - 29) <= 0xA) {
      goto LABEL_34;
    }
LABEL_31:
    if ((llvm::Instruction::mayHaveSideEffects(v32) & 1) == 0) {
      llvm::Instruction::eraseFromParent(v32);
    }
    goto LABEL_33;
  }
  char v21 = 0;
LABEL_35:
  if (v38 != v40) {
    free(v38);
  }
  if ((v33 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v34.i64[0], 8);
  }
  return v21 & 1;
}

void sub_1CD497034(uint64_t a1)
{
  llvm::IRBuilderFolder::~IRBuilderFolder((llvm::IRBuilderFolder *)(a1 + 8));

  llvm::IRBuilderFolder::~IRBuilderFolder((llvm::IRBuilderFolder *)a1);
}

void sub_1CD497070(uint64_t a1)
{
  llvm::IRBuilderFolder::~IRBuilderFolder((llvm::IRBuilderFolder *)(a1 + 8));
  llvm::IRBuilderFolder::~IRBuilderFolder((llvm::IRBuilderFolder *)a1);

  JUMPOUT(0x1D25D9CE0);
}

llvm::Value *sub_1CD4970C0(uint64_t a1, llvm *a2, llvm::Constant *a3, uint64_t a4, const llvm::DataLayout *a5, llvm::DSOLocalEquivalent **a6)
{
  return sub_1CC02C2C8(a2, a3, a1 + 24, 3, a5, a6);
}

llvm::SmallPtrSetImplBase *sub_1CD4970D8(uint64_t a1, llvm *a2, llvm::Constant *a3, uint64_t a4, const llvm::DataLayout *a5, llvm::DSOLocalEquivalent **a6)
{
  return sub_1CC02DBDC(a2, a3, a1 + 24, 3, a5, a6);
}

llvm::UndefValue *sub_1CD4970F0(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  return sub_1CC02F0F0(a2, a3, a4, a1 + 24, (llvm::SmallPtrSetImplBase *)3);
}

llvm::UndefValue *sub_1CD49710C(uint64_t a1, llvm::Type *a2, unsigned __int8 *a3, uint64_t *a4, uint64_t a5, int a6)
{
  return sub_1CC036F6C(a2, a3, a4, a5, a6, a1 + 24);
}

llvm::Constant *sub_1CD49712C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  return sub_1CC035B70(a2, a3, a4, a1 + 24, 3);
}

llvm::Value *sub_1CD497148(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  FAdd = llvm::ConstantExpr::getFAdd(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)FAdd, v6, 0);
}

llvm::Value *sub_1CD49718C(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  Sub = llvm::ConstantExpr::getSub(this, a3, a4, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Sub, v7, 0);
}

llvm::Value *sub_1CD4971D8(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  FSub = llvm::ConstantExpr::getFSub(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)FSub, v6, 0);
}

llvm::Value *sub_1CD49721C(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  Mul = llvm::ConstantExpr::getMul(this, a3, a4, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Mul, v7, 0);
}

llvm::Value *sub_1CD497268(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  FMul = llvm::ConstantExpr::getFMul(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)FMul, v6, 0);
}

llvm::Value *sub_1CD4972AC(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  UDiv = llvm::ConstantExpr::getUDiv(this, a3, a4, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)UDiv, v6, 0);
}

llvm::Value *sub_1CD4972F4(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  SDiv = llvm::ConstantExpr::getSDiv(this, a3, a4, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)SDiv, v6, 0);
}

llvm::Value *sub_1CD49733C(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  FDiv = llvm::ConstantExpr::getFDiv(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)FDiv, v6, 0);
}

llvm::Value *sub_1CD497380(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  URem = llvm::ConstantExpr::getURem(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)URem, v6, 0);
}

llvm::Value *sub_1CD4973C4(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  SRem = llvm::ConstantExpr::getSRem(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)SRem, v6, 0);
}

llvm::Value *sub_1CD497408(uint64_t a1, llvm::ConstantExpr *a2, llvm::Constant *a3, uint64_t a4, uint64_t a5, llvm::Type *a6)
{
  FRem = llvm::ConstantExpr::getFRem(a2, a3, a3, a4, a5, a6);
  size_t v8 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)FRem, v8, 0);
}

llvm::Value *sub_1CD49744C(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, llvm::Constant *a5)
{
  Shl = llvm::ConstantExpr::getShl(this, a3, a4, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Shl, v7, 0);
}

llvm::Value *sub_1CD497498(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  uint64_t LShr = llvm::ConstantExpr::getLShr(this, a3, a4, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant(LShr, v6, 0);
}

llvm::Value *sub_1CD4974E0(uint64_t a1, llvm::ConstantExpr *a2, llvm::Constant *a3, llvm::Constant *a4, uint64_t a5, llvm::Type *a6)
{
  AShr = llvm::ConstantExpr::getAShr(a2, a3, a4, (BOOL)a4, a5, a6);
  size_t v8 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)AShr, v8, 0);
}

llvm::Value *sub_1CD497528(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4)
{
  uint64_t Xor = llvm::ConstantExpr::getXor(this, a3, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant(Xor, v6, 0);
}

llvm::Value *sub_1CD49756C(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, uint64_t a5, llvm::Type *a6)
{
  char v7 = llvm::ConstantExpr::get(this, a3, a4, 0, 0, a6);
  size_t v8 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)v7, v8, 0);
}

llvm::Value *sub_1CD4975BC(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, const llvm::APFloat *a4)
{
  Neg = llvm::ConstantExpr::getNeg(this, a3, a4);
  size_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Neg, v6, 0);
}

llvm::Value *sub_1CD497604(uint64_t a1, llvm::ConstantExpr *this, uint64_t a3, uint64_t a4, llvm::Type *a5)
{
  uint64_t FNeg = llvm::ConstantExpr::getFNeg(this, this, a3, a4, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant(FNeg, v7, 0);
}

llvm::Value *sub_1CD497644(uint64_t a1, llvm::Constant **this, const llvm::APInt *a3)
{
  Not = llvm::ConstantExpr::getNot(this, (llvm::Constant *)this, a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Not, v5, 0);
}

llvm::Value *sub_1CD497684(uint64_t a1, llvm::ConstantExpr *this, unsigned __int8 *a3, uint64_t a4, llvm::Type *a5)
{
  uint64_t v6 = llvm::ConstantExpr::get(this, a3, 0, 0, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant(v6, v7, 0);
}

llvm::Value *sub_1CD4976D0(uint64_t a1, llvm::ConstantExpr *this, llvm::ConstantExpr *a3, llvm::Constant ***a4)
{
  if (*(llvm::Constant ****)a3 == a4) {
    return a3;
  }
  Cast = llvm::ConstantExpr::getCast(this, a3, a4, 0);
  uint64_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Cast, v6, 0);
}

llvm::Value *sub_1CD497738(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3)
{
  if (*(llvm::Constant **)this == a3) {
    return this;
  }
  PointerCast = llvm::ConstantExpr::getPointerCast(this, a3, a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)PointerCast, v5, 0);
}

llvm::Value *sub_1CD497798(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3)
{
  if (*(llvm::Constant **)this == a3) {
    return this;
  }
  PointerBitCastOrAddrSpaceCast = llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast(this, a3, a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)PointerBitCastOrAddrSpaceCast, v5, 0);
}

llvm::Value *sub_1CD4977F8(uint64_t a1, llvm::ConstantExpr *this, llvm::Type ***a3, llvm::Type *a4)
{
  if (*(llvm::Type ****)this == a3) {
    return this;
  }
  IntegerCast = llvm::ConstantExpr::getIntegerCast(this, a3, a4);
  uint64_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)IntegerCast, v6, 0);
}

llvm::Value *sub_1CD49785C(uint64_t a1, llvm::ConstantExpr *a2, llvm::Type ***a3)
{
  if (*(llvm::Type ****)a2 == a3) {
    return a2;
  }
  FPCast = llvm::ConstantExpr::getFPCast(a2, a3, (llvm::Type *)a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)FPCast, v5, 0);
}

llvm::Value *sub_1CD4978BC(uint64_t a1, llvm::detail::IEEEFloat *a2, llvm::Constant *a3)
{
  if (*(llvm::Constant **)a2 == a3) {
    return a2;
  }
  size_t v4 = sub_1CC56C0C0((llvm *)0x31, a2, a3, 0);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)v4, v5, 0);
}

llvm::Value *sub_1CD49791C(uint64_t a1, llvm::detail::IEEEFloat *a2, llvm::Constant *a3)
{
  if (*(llvm::Constant **)a2 == a3) {
    return a2;
  }
  size_t v4 = sub_1CC56C0C0((llvm *)0x30, a2, a3, 0);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)v4, v5, 0);
}

llvm::Value *sub_1CD49797C(uint64_t a1, llvm::detail::IEEEFloat *a2, llvm::Constant *a3)
{
  if (*(llvm::Constant **)a2 == a3) {
    return a2;
  }
  size_t v4 = sub_1CC56C0C0((llvm *)0x2F, a2, a3, 0);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)v4, v5, 0);
}

llvm::Value *sub_1CD4979DC(uint64_t a1, llvm::Type **this, llvm::Type ***a3)
{
  if (*this == (llvm::Type *)a3) {
    return (llvm::Value *)this;
  }
  ZExtOrBitCast = llvm::ConstantExpr::getZExtOrBitCast(this, a3, (llvm::Type *)a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)ZExtOrBitCast, v5, 0);
}

llvm::Value *sub_1CD497A3C(uint64_t a1, llvm::Type **this, llvm::Type ***a3)
{
  if (*this == (llvm::Type *)a3) {
    return (llvm::Value *)this;
  }
  SExtOrBitCast = llvm::ConstantExpr::getSExtOrBitCast(this, a3, (llvm::Type *)a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)SExtOrBitCast, v5, 0);
}

llvm::Value *sub_1CD497A9C(uint64_t a1, llvm::Type **a2, llvm::Type ***a3)
{
  if (*a2 == (llvm::Type *)a3) {
    return (llvm::Value *)a2;
  }
  TruncOrBitCast = llvm::ConstantExpr::getTruncOrBitCast(a2, a3, (llvm::Type *)a3);
  uint64_t v5 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)TruncOrBitCast, v5, 0);
}

llvm::Value *sub_1CD497AFC(uint64_t a1, unsigned __int16 a2, llvm::Type *a3, llvm::Constant *a4, BOOL a5)
{
  Compare = llvm::ConstantExpr::getCompare((llvm::ConstantExpr *)a2, a3, a4, 0, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Compare, v7, 0);
}

llvm::Value *sub_1CD497B48(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Type *a4)
{
  uint64_t Element = llvm::ConstantExpr::getExtractElement(this, a3, 0, a4);
  uint64_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant(Element, v6, 0);
}

llvm::Value *sub_1CD497B90(uint64_t a1, llvm::ConstantExpr *this, llvm::Constant *a3, llvm::Constant *a4, llvm::Type *a5)
{
  Insertuint64_t Element = llvm::ConstantExpr::getInsertElement(this, a3, a4, 0, a5);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)InsertElement, v7, 0);
}

llvm::Value *sub_1CD497BDC(uint64_t a1, llvm *a2, llvm *a3, int *a4, llvm::Type *a5)
{
  ShuffleVector = llvm::ConstantExpr::getShuffleVector(a2, a3, a4, a5, 0);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)ShuffleVector, v7, 0);
}

llvm::Value *sub_1CD497C2C(uint64_t a1, llvm::Constant *this, unsigned int *a3, uint64_t a4)
{
  Value = llvm::ConstantExpr::getExtractValue(this, a3, a4, 0);
  uint64_t v6 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)Value, v6, 0);
}

llvm::Value *sub_1CD497C78(uint64_t a1, llvm::Constant *a2, uint64_t *a3, _DWORD *a4, uint64_t a5)
{
  InsertValue = llvm::ConstantExpr::getInsertValue(a2, a3, a4, a5, 0);
  char v7 = *(llvm::DataLayout **)(a1 + 16);

  return llvm::ConstantFoldConstant((uint64_t)InsertValue, v7, 0);
}

uint64_t sub_1CD497CC8(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a2 - 64);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3 == v2)
  {
    uint64_t v4 = *(void *)(a2 - 32);
    if (*(void *)(a1 + 16) == v4)
    {
      char v7 = (_DWORD **)a1;
      int SwappedPredicate = *(_WORD *)(a2 + 18) & 0x3F;
LABEL_12:
      **char v7 = SwappedPredicate;
      return 1;
    }
  }
  else
  {
    uint64_t v4 = *(void *)(a2 - 32);
  }
  if (v3 == v4)
  {
    char v7 = (_DWORD **)a1;
    if (*(void *)(a1 + 16) == v2)
    {
      int SwappedPredicate = llvm::CmpInst::getSwappedPredicate(*(_WORD *)(a2 + 18) & 0x3F);
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t sub_1CD497D64(void *a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 16);
  unsigned int v4 = v3 - 28;
  BOOL v6 = v3 < 0x1C && v3 != 5 || a2 == 0;
  int v7 = v6;
  if (!v6)
  {
    if (v3 <= 0x1B) {
      unsigned int v4 = *(unsigned __int16 *)(a2 + 18);
    }
    if (v4 == 47)
    {
      int v9 = *(_DWORD *)(a2 + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(void **)(a2 - 8);
      }
      else {
        uint64_t v10 = (void *)(a2 - 32 * (v9 & 0x7FFFFFF));
      }
      BOOL v2 = *a1 == *v10;
    }
    else
    {
      BOOL v2 = 0;
    }
  }
  return (v7 ^ 1) & v2;
}

BOOL sub_1CD497DD0(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a2)
  {
    if (*(unsigned char *)(a2 + 16) == 84)
    {
      uint64_t v2 = *(void *)(a2 - 32);
      if (v2) {
        return !*(unsigned char *)(v2 + 16) && *(void *)(v2 + 24) == *(void *)(a2 + 72) && *(_DWORD *)(v2 + 36) == *a1;
      }
    }
  }
  return v2;
}

uint64_t sub_1CD497E24(void **a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a2 && *(unsigned char *)(a2 + 16) == 16)
  {
    unsigned int v4 = (void *)(a2 + 24);
    unsigned int v5 = *(_DWORD *)(a2 + 32);
    if (v5 >= 0x41)
    {
      if (v5 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(a2 + 24)) > 0x40) {
        return 0;
      }
      unsigned int v4 = (void *)*v4;
    }
    **a1 = *v4;
    return 1;
  }
  return result;
}

uint64_t sub_1CD497EA4(uint64_t a1, unsigned int a2)
{
  char v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    BOOL v6 = *(void **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD498020(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  size_t v8 = v14;
  for (uint64_t i = 8; i != 72; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD498020(a1, v14, v8);
}

uint64_t sub_1CD498020(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    size_t v8 = (void *)(result + 8);
    int v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    size_t v8 = *(void **)(result + 8);
    int v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CC04D62C((uint64_t)v5, a2, &v10);
      void *v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

llvm::raw_ostream *llvm::Interval::print(llvm::Interval *this, llvm::raw_ostream *a2)
{
  unint64_t v4 = sub_1CB8E509C(a2, "-------------------------------------------------------------\n");
  sub_1CB8E509C(v4, "Interval Contents:\n");
  int v5 = (llvm::Value **)*((void *)this + 1);
  int v6 = (llvm::Value **)*((void *)this + 2);
  while (v5 != v6)
  {
    uint64_t v7 = *v5++;
    llvm::Value::print(v7, a2, 0);
    sub_1CB8E509C(a2, "\n");
  }
  sub_1CB8E509C(a2, "Interval Predecessors:\n");
  size_t v8 = (llvm::Value **)*((void *)this + 7);
  int v9 = (llvm::Value **)*((void *)this + 8);
  while (v8 != v9)
  {
    uint64_t v10 = *v8++;
    llvm::Value::print(v10, a2, 0);
    sub_1CB8E509C(a2, "\n");
  }
  uint64_t result = sub_1CB8E509C(a2, "Interval Successors:\n");
  char v12 = (llvm::Value **)*((void *)this + 4);
  for (i = (llvm::Value **)*((void *)this + 5); v12 != i; uint64_t result = sub_1CB8E509C(a2, "\n"))
  {
    uint64_t v14 = *v12++;
    llvm::Value::print(v14, a2, 0);
  }
  return result;
}

llvm::IntervalPartition *llvm::IntervalPartition::IntervalPartition(llvm::IntervalPartition *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::IntervalPartition::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2604AA0;
  *((void *)this + 6) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5F80, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC04D804;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5F80, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::IntervalPartition::releaseMemory(llvm::IntervalPartition *this)
{
  uint64_t v2 = (void **)*((void *)this + 8);
  unint64_t v3 = (void **)*((void *)this + 9);
  while (v2 != v3)
  {
    if (*v2)
    {
      unint64_t v4 = sub_1CD49870C(*v2);
      MEMORY[0x1D25D9CE0](v4, 0xA0C40CC6163FFLL);
    }
    ++v2;
  }
  int v6 = (void *)*((void *)this + 5);
  int v5 = (void *)((char *)this + 40);
  sub_1CD40B1BC(v6);
  v5[1] = 0;
  void v5[2] = 0;
  *(v5 - 1) = v5;
  *int v5 = 0;
  v5[4] = v5[3];
}

llvm::raw_ostream *llvm::IntervalPartition::print(llvm::raw_ostream *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  unint64_t v3 = (llvm::Interval **)*((void *)this + 8);
  for (uint64_t i = (llvm::Interval **)*((void *)this + 9); v3 != i; this = llvm::Interval::print(v6, a2))
    int v6 = *v3++;
  return this;
}

void *llvm::IntervalPartition::addIntervalToPartition(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(uint64_t **)(a1 + 72);
  if ((unint64_t)v4 >= *(void *)(a1 + 80))
  {
    uint64_t result = sub_1CBF63C18((void **)(a1 + 64), a2);
  }
  else
  {
    *unint64_t v4 = a2;
    uint64_t result = v4 + 1;
  }
  *(void *)(a1 + 72) = result;
  int v6 = *(unint64_t **)(a2 + 8);
  uint64_t v7 = *(unint64_t **)(a2 + 16);
  if (v6 != v7)
  {
    size_t v8 = (uint64_t *)(a1 + 32);
    do
    {
      unint64_t v9 = *v6++;
      uint64_t result = sub_1CD498850(v8, v9, v9, a2);
    }
    while (v6 != v7);
  }
  return result;
}

void *llvm::IntervalPartition::updatePredecessors(void *result, uint64_t *a2)
{
  uint64_t v13 = *a2;
  uint64_t v2 = (unint64_t *)a2[4];
  unint64_t v3 = (unint64_t *)a2[5];
  if (v2 != v3)
  {
    unint64_t v4 = result + 5;
    do
    {
      int v5 = (void *)*v4;
      int v6 = v4;
      if (*v4)
      {
        unint64_t v7 = *v2;
        int v6 = v4;
        do
        {
          unint64_t v8 = v5[4];
          BOOL v9 = v8 >= v7;
          if (v8 >= v7) {
            uint64_t v10 = v5;
          }
          else {
            uint64_t v10 = v5 + 1;
          }
          if (v9) {
            int v6 = v5;
          }
          int v5 = (void *)*v10;
        }
        while (*v10);
      }
      uint64_t v11 = v6[5];
      char v12 = *(void **)(v11 + 64);
      if ((unint64_t)v12 >= *(void *)(v11 + 72))
      {
        uint64_t result = sub_1CBC13470((void **)(v11 + 56), &v13);
      }
      else
      {
        *char v12 = v13;
        uint64_t result = v12 + 1;
      }
      *(void *)(v11 + 64) = result;
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

uint64_t llvm::IntervalPartition::runOnFunction(llvm::IntervalPartition *this, llvm::Function *a2)
{
  uint64_t v18 = 0;
  int v19 = 0;
  v22[0] = 0;
  v22[1] = 0;
  uint64_t v20 = 0;
  char v21 = v22;
  char v23 = 0;
  v22[2] = a2;
  uint64_t v3 = *((void *)a2 + 10);
  if (v3) {
    unint64_t v4 = (uint64_t *)(v3 - 24);
  }
  else {
    unint64_t v4 = 0;
  }
  sub_1CC04DB1C((uint64_t)&v18, v4);
  uint64_t v5 = *((void *)v19 - 2);
  *((void *)this + 7) = v5;
  llvm::IntervalPartition::addIntervalToPartition((uint64_t)this, v5);
  sub_1CD4985E0((uint64_t)&v18);
  int v6 = 0;
  uint64_t v7 = 0;
  memset(v17, 0, sizeof(v17));
  long long v14 = 0u;
  uint64_t v15 = 0;
  char v16 = v17;
  while (1)
  {
    unint64_t v8 = v18;
    if (v19 - v18 == v7 - (void)v6) {
      break;
    }
LABEL_13:
    llvm::IntervalPartition::addIntervalToPartition((uint64_t)this, *((void *)v19 - 2));
    sub_1CD4985E0((uint64_t)&v18);
    uint64_t v7 = *((void *)&v14 + 1);
    int v6 = (void *)v14;
  }
  while (v8 != v19)
  {
    if (*(void *)v8 != *v6 || *((void *)v8 + 1) != v6[1]) {
      goto LABEL_13;
    }
    v8 += 16;
    v6 += 2;
  }
  sub_1CD4987C8((char **)&v14);
  uint64_t v10 = (uint64_t **)*((void *)this + 8);
  uint64_t v11 = (uint64_t **)*((void *)this + 9);
  while (v10 != v11)
  {
    char v12 = *v10++;
    llvm::IntervalPartition::updatePredecessors(this, v12);
  }
  sub_1CD4987C8(&v18);
  return 0;
}

uint64_t sub_1CD4985E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  do
  {
    uint64_t v3 = *(uint64_t ***)(v2 - 8);
    unint64_t v4 = *(uint64_t ***)(*(void *)(v2 - 16) + 40);
    while (v3 != v4)
    {
      char v5 = sub_1CC04DB1C(a1, *v3);
      uint64_t v3 = (uint64_t **)(*(void *)(v2 - 8) + 8);
      *(void *)(v2 - 8) = v3;
      if (v5) {
        return a1;
      }
    }
    uint64_t v6 = *(void *)(a1 + 8);
    if (*(unsigned char *)(a1 + 56))
    {
      uint64_t v7 = *(void **)(v6 - 16);
      if (v7)
      {
        BOOL v9 = sub_1CD49870C(v7);
        MEMORY[0x1D25D9CE0](v9, 0xA0C40CC6163FFLL);
        uint64_t v6 = *(void *)(a1 + 8);
      }
    }
    uint64_t v2 = v6 - 16;
    *(void *)(a1 + 8) = v6 - 16;
  }
  while (*(void *)a1 != v6 - 16);
  return a1;
}

void sub_1CD49868C(uint64_t a1)
{
  sub_1CD498760(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4986C4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::callDefaultCtor<llvm::IntervalPartition>()
{
}

void *sub_1CD49870C(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_1CD498760(uint64_t a1)
{
  *(void *)a1 = &unk_1F2604AA0;
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }
  sub_1CD40B1BC(*(void **)(a1 + 40));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

char **sub_1CD4987C8(char **a1)
{
  if (*((unsigned char *)a1 + 56))
  {
    char v5 = *a1;
    for (uint64_t i = a1[1]; v5 != i; a1[1] = i)
    {
      uint64_t v6 = (void *)*((void *)i - 2);
      if (v6)
      {
        uint64_t v7 = sub_1CD49870C(v6);
        MEMORY[0x1D25D9CE0](v7, 0xA0C40CC6163FFLL);
        char v5 = *a1;
        uint64_t i = a1[1];
      }
      i -= 16;
    }
  }
  sub_1CB833A08((uint64_t)(a1 + 3), a1[4]);
  uint64_t v2 = *a1;
  if (*a1)
  {
    a1[1] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_1CD498850(uint64_t *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  unint64_t v8 = (uint64_t **)(result + 1);
  uint64_t v7 = (uint64_t *)result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        BOOL v9 = (uint64_t **)v7;
        unint64_t v10 = v7[4];
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        unint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        unint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v9 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = a3;
    void v11[5] = a4;
    *uint64_t v11 = 0;
    v11[1] = 0;
    void v11[2] = (uint64_t)v9;
    *unint64_t v8 = v11;
    uint64_t v12 = *(void *)*v6;
    if (v12)
    {
      *uint64_t v6 = v12;
      uint64_t v13 = *v8;
    }
    else
    {
      uint64_t v13 = v11;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

llvm::LazyBranchProbabilityInfoPass *llvm::LazyBranchProbabilityInfoPass::LazyBranchProbabilityInfoPass(llvm::LazyBranchProbabilityInfoPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::LazyBranchProbabilityInfoPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2604B40;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5F88, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC04EA78;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5F88, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::raw_ostream *llvm::LazyBranchProbabilityInfoPass::print(llvm::LazyBranchProbabilityInfoPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v3 = *((void *)this + 4);
  if (!*(unsigned char *)(v3 + 248)) {
    llvm::BranchProbabilityInfo::calculate(*((void *)this + 4), *(void *)(v3 + 256), *(void *)(v3 + 264));
  }
  unint64_t v4 = (llvm::BranchProbabilityInfo *)*((void *)this + 4);

  return llvm::BranchProbabilityInfo::print(v4, a2);
}

llvm::AnalysisUsage *llvm::LazyBranchProbabilityInfoPass::getAnalysisUsage(llvm::LazyBranchProbabilityInfoPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  uint64_t result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

llvm::AnalysisUsage *llvm::LazyBranchProbabilityInfoPass::getLazyBPIAnalysisUsage(llvm::LazyBranchProbabilityInfoPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredTransitiveID(this, (char *)&llvm::LazyBranchProbabilityInfoPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(this, (char *)&llvm::LoopInfoWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredTransitiveID(this, llvm::TargetLibraryInfoWrapperPass::ID);
}

void llvm::initializeLazyBPIPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v3 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5F88, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC04EA78;
    v5[1] = &v3;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5F88, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)this);
  llvm::initializeTargetLibraryInfoWrapperPassPass((uint64_t)this);
}

void sub_1CD498B74(llvm::Pass *a1)
{
  sub_1CD498BE8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LazyBranchProbabilityInfoPass>()
{
}

void sub_1CD498BE8(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2604B40;
  uint64_t v1 = *((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v1)
  {
    uint64_t v3 = a1;
    uint64_t v2 = sub_1CBF8AF10(v1);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4069C990F3);
    a1 = v3;
  }

  llvm::Pass::~Pass(a1);
}

void llvm::initializeLazyBlockFrequencyInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5F90, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC04EF88;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC5F90, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::LazyBlockFrequencyInfoPass *llvm::LazyBlockFrequencyInfoPass::LazyBlockFrequencyInfoPass(llvm::LazyBlockFrequencyInfoPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::LazyBlockFrequencyInfoPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2604BE0;
  uint64_t v2 = (llvm::PassRegistry *)llvm::BlockFrequencyInfo::BlockFrequencyInfo((void *)this + 4);
  *((unsigned char *)this + 40) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5F90, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC04EF88;
    v6[1] = &PassRegistry;
    char v5 = v6;
    std::__call_once(&qword_1EBCC5F90, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::LazyBlockFrequencyInfoPass::print(llvm::LazyBlockFrequencyInfoPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  unint64_t v4 = sub_1CD499004((llvm::LazyBlockFrequencyInfoPass *)((char *)this + 32));

  return llvm::BlockFrequencyInfo::print(v4, a2);
}

llvm::AnalysisUsage *llvm::LazyBlockFrequencyInfoPass::getAnalysisUsage(llvm::LazyBlockFrequencyInfoPass *this, llvm::AnalysisUsage *a2)
{
  llvm::LazyBranchProbabilityInfoPass::getLazyBPIAnalysisUsage(a2, a2);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  uint64_t result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

llvm::AnalysisUsage *llvm::LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(llvm::LazyBlockFrequencyInfoPass *this, llvm::AnalysisUsage *a2)
{
  llvm::LazyBranchProbabilityInfoPass::getLazyBPIAnalysisUsage(this, a2);
  llvm::AnalysisUsage::addRequiredTransitiveID(this, llvm::LazyBlockFrequencyInfoPass::ID);

  return llvm::AnalysisUsage::addRequiredTransitiveID(this, (char *)&llvm::LoopInfoWrapperPass::ID);
}

void llvm::initializeLazyBFIPassPass(llvm *this, llvm::PassRegistry *a2)
{
  llvm::initializeLazyBPIPassPass(this, a2);
  uint64_t v3 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5F90, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC04EF88;
    v5[1] = &v3;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC5F90, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  llvm::initializeLoopInfoWrapperPassPass((uint64_t)this);
}

void sub_1CD498F0C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2604BE0;
  llvm::BlockFrequencyInfo::~BlockFrequencyInfo((llvm::BlockFrequencyInfo *)(a1 + 32));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD498F60(uint64_t a1)
{
  *(void *)a1 = &unk_1F2604BE0;
  llvm::BlockFrequencyInfo::~BlockFrequencyInfo((llvm::BlockFrequencyInfo *)(a1 + 32));
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LazyBlockFrequencyInfoPass>()
{
}

llvm::BlockFrequencyInfo *sub_1CD499004(llvm::BlockFrequencyInfo *this)
{
  if (!*((unsigned char *)this + 8))
  {
    uint64_t v3 = *(void *)(*((void *)this + 3) + 32);
    if (!*(unsigned char *)(v3 + 248)) {
      llvm::BranchProbabilityInfo::calculate(*(void *)(*((void *)this + 3) + 32), *(void *)(v3 + 256), *(void *)(v3 + 264));
    }
    llvm::BlockFrequencyInfo::calculate(this, *((const llvm::Function **)this + 2), (const llvm::BranchProbabilityInfo *)v3, *((const llvm::LoopInfo **)this + 4));
    *((unsigned char *)this + 8) = 1;
  }
  return this;
}

uint64_t llvm::LazyCallGraph::EdgeSequence::insertEdgeInternal(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v11 = a2;
  int v12 = v6;
  uint64_t result = sub_1CC0566DC(a1 + 48, &v11, &v12, (uint64_t)v10);
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  if (v8 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD49A640(a1, a2, a3);
  }
  uint64_t v9 = 4;
  if (!a3) {
    uint64_t v9 = 0;
  }
  *(void *)(*(void *)a1 + 8 * v8) = v9 | a2;
  *(_DWORD *)(a1 + 8) = v8 + 1;
  return result;
}

llvm::raw_ostream *llvm::LazyCallGraph::Node::dump(llvm::LazyCallGraph::Node *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t result = sub_1CC0501EC(v2, (uint64_t)this);
  unint64_t v4 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v4 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v4 + 1;
    *unint64_t v4 = 10;
  }
  return result;
}

uint64_t llvm::LazyCallGraph::LazyCallGraph(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1CC056A04(a1, a2);
  *(_DWORD *)(v4 + 112) = 0;
  *(_OWORD *)(v4 + 96) = 0u;
  *(void *)(v4 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = 0;
  *(_DWORD *)(v4 + 104) = *(_DWORD *)(a2 + 104);
  *(_DWORD *)(a2 + 104) = 0;
  int v5 = *(_DWORD *)(v4 + 108);
  *(_DWORD *)(v4 + 108) = *(_DWORD *)(a2 + 108);
  *(_DWORD *)(a2 + 108) = v5;
  int v6 = *(_DWORD *)(v4 + 112);
  *(_DWORD *)(v4 + 112) = *(_DWORD *)(a2 + 112);
  *(_DWORD *)(a2 + 112) = v6;
  sub_1CC0565F4(v4 + 120, a2 + 120);
  sub_1CC056A04(a1 + 192, a2 + 192);
  *(_DWORD *)(a1 + 304) = 0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(void *)(a2 + 288) = 0;
  *(_DWORD *)(a1 + 296) = *(_DWORD *)(a2 + 296);
  *(_DWORD *)(a2 + 296) = 0;
  int v7 = *(_DWORD *)(a1 + 300);
  *(_DWORD *)(a1 + 300) = *(_DWORD *)(a2 + 300);
  *(_DWORD *)(a2 + 300) = v7;
  int v8 = *(_DWORD *)(a1 + 304);
  *(_DWORD *)(a1 + 304) = *(_DWORD *)(a2 + 304);
  *(_DWORD *)(a2 + 304) = v8;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = a1 + 344;
  *(void *)(a1 + 336) = 0x400000000;
  *(_OWORD *)(a1 + 392) = 0u;
  *(void *)(a1 + 376) = a1 + 392;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 408) = a1 + 424;
  *(void *)(a1 + 416) = 0x1000000000;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_DWORD *)(a1 + 568) = 0;
  sub_1CC007F3C(a1 + 576, (unsigned int *)(a2 + 576));
  llvm::LazyCallGraph::updateGraphPtrs(a1);
  return a1;
}

BOOL llvm::LazyCallGraph::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = (void **)a3;
  v8[1] = (void **)&llvm::LazyCallGraphAnalysis::Key;
  uint64_t v4 = sub_1CB896AE8(a3 + 48, (uint64_t)&llvm::LazyCallGraphAnalysis::Key);
  uint64_t v5 = *(void *)(a3 + 56);
  if (v5 == *(void *)(a3 + 48)) {
    int v6 = (unsigned int *)(a3 + 68);
  }
  else {
    int v6 = (unsigned int *)(a3 + 64);
  }
  BOOL v9 = v4 != (void *)(v5 + 8 * *v6);
  return !sub_1CBF75724(v8) && !sub_1CBFA10B0((uint64_t)v8);
}

llvm::raw_ostream *llvm::LazyCallGraph::SCC::dump(llvm::LazyCallGraph::SCC *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t result = sub_1CC050A50(v2, (uint64_t)this);
  uint64_t v4 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v4 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v4 + 1;
    *uint64_t v4 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::LazyCallGraph::RefSCC::dump(llvm::LazyCallGraph::RefSCC *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t result = sub_1CC0510EC(v2, (uint64_t)this);
  uint64_t v4 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v4 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v4 + 1;
    *uint64_t v4 = 10;
  }
  return result;
}

uint64_t llvm::LazyCallGraph::RefSCC::switchTrivialInternalEdgeToRef(llvm::LazyCallGraph::RefSCC *this, llvm::LazyCallGraph::Node *a2, llvm::LazyCallGraph::Node *a3)
{
  int v6 = a3;
  uint64_t v7 = 0;
  uint64_t result = sub_1CB915048((uint64_t *)a2 + 9, &v6, &v7);
  uint64_t v5 = v7;
  if (!result) {
    uint64_t v5 = *((void *)a2 + 9) + 16 * *((unsigned int *)a2 + 22);
  }
  *(void *)(*((void *)a2 + 3) + 8 * *(int *)(v5 + 8)) &= ~4uLL;
  return result;
}

_DWORD *sub_1CD499474(_DWORD *result, _DWORD *a2)
{
  if (result != a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)result;
    if (*(_DWORD **)result == result + 4 || *(_DWORD **)a2 == a2 + 4)
    {
      if (result[3] < a2[2]) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unsigned int v7 = result[2];
      if (a2[3] < v7) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v8 = a2[2];
      if (v7 >= v8) {
        uint64_t v9 = v8;
      }
      else {
        uint64_t v9 = v7;
      }
      if (v9)
      {
        uint64_t v10 = 0;
        do
        {
          uint64_t v11 = *(void *)a2;
          uint64_t v12 = *(void *)(*(void *)result + v10);
          *(void *)(*(void *)result + v10) = *(void *)(*(void *)a2 + v10);
          *(void *)(v11 + v10) = v12;
          v10 += 8;
        }
        while (8 * v9 != v10);
      }
      if (v8 >= v7)
      {
        if (v8 > v7)
        {
          int v14 = v8 - v7;
          uint64_t result = memcpy((void *)(*(void *)result + 8 * v7), (const void *)(*(void *)a2 + 8 * v9), *(void *)a2 + 8 * v8 - (*(void *)a2 + 8 * v9));
          v3[2] += v14;
          a2[2] = v9;
        }
      }
      else
      {
        int v13 = v7 - v8;
        uint64_t result = memcpy((void *)(*(void *)a2 + 8 * v8), (const void *)(*(void *)result + 8 * v9), *(void *)result + 8 * v7 - (*(void *)result + 8 * v9));
        a2[2] += v13;
        void v3[2] = v9;
      }
    }
    else
    {
      *(void *)uint64_t result = *(void *)a2;
      *(void *)a2 = v4;
      int v5 = result[2];
      result[2] = a2[2];
      a2[2] = v5;
      int v6 = result[3];
      result[3] = a2[3];
      a2[3] = v6;
    }
  }
  return result;
}

uint64_t llvm::LazyCallGraph::RefSCC::switchOutgoingEdgeToCall(llvm::LazyCallGraph::RefSCC *this, llvm::LazyCallGraph::Node *a2, llvm::LazyCallGraph::Node *a3)
{
  int v6 = a3;
  uint64_t v7 = 0;
  uint64_t result = sub_1CB915048((uint64_t *)a2 + 9, &v6, &v7);
  uint64_t v5 = v7;
  if (!result) {
    uint64_t v5 = *((void *)a2 + 9) + 16 * *((unsigned int *)a2 + 22);
  }
  *(void *)(*((void *)a2 + 3) + 8 * *(int *)(v5 + 8)) |= 4uLL;
  return result;
}

uint64_t llvm::LazyCallGraph::RefSCC::switchOutgoingEdgeToRef(llvm::LazyCallGraph::RefSCC *this, llvm::LazyCallGraph::Node *a2, llvm::LazyCallGraph::Node *a3)
{
  int v6 = a3;
  uint64_t v7 = 0;
  uint64_t result = sub_1CB915048((uint64_t *)a2 + 9, &v6, &v7);
  uint64_t v5 = v7;
  if (!result) {
    uint64_t v5 = *((void *)a2 + 9) + 16 * *((unsigned int *)a2 + 22);
  }
  *(void *)(*((void *)a2 + 3) + 8 * *(int *)(v5 + 8)) &= ~4uLL;
  return result;
}

uint64_t llvm::LazyCallGraph::RefSCC::insertTrivialRefEdge(llvm::LazyCallGraph::RefSCC *this, llvm::LazyCallGraph::Node *a2, llvm::LazyCallGraph::Node *a3)
{
  int v5 = *((_DWORD *)a2 + 8);
  uint64_t v8 = a3;
  int v9 = v5;
  uint64_t result = sub_1CC0566DC((uint64_t)a2 + 72, (uint64_t *)&v8, &v9, (uint64_t)v10);
  if (v10[16])
  {
    LOBYTE(v8) = 0;
    uint64_t v7 = *((unsigned int *)a2 + 8);
    if (v7 >= *((_DWORD *)a2 + 9))
    {
      return sub_1CD49AC2C((uint64_t)a2 + 24, (uint64_t)a3, &v8);
    }
    else
    {
      *(void *)(*((void *)a2 + 3) + 8 * v7) = a3;
      *((_DWORD *)a2 + 8) = v7 + 1;
    }
  }
  return result;
}

void *llvm::LazyCallGraph::RefSCC::replaceNodeFunction(int32x2_t **this, llvm::LazyCallGraph::Node *a2, llvm::Function *a3)
{
  uint64_t v6 = *((void *)a2 + 1);
  *((void *)a2 + 1) = a3;
  uint64_t v7 = *this;
  uint64_t v8 = (uint64_t *)&(*this)[12];
  uint64_t v11 = v6;
  uint64_t v12 = 0;
  if (sub_1CB915048(v8, &v11, &v12))
  {
    *(void *)uint64_t v12 = -8192;
    v7[13] = vadd_s32(v7[13], (int32x2_t)0x1FFFFFFFFLL);
  }
  int v9 = (uint64_t *)&(*this)[12];
  uint64_t v12 = a3;
  uint64_t result = sub_1CC05667C(v9, &v12);
  result[1] = a2;
  return result;
}

unint64_t llvm::LazyCallGraph::initNode(llvm::LazyCallGraph *this, llvm::Function *a2)
{
  unint64_t v4 = sub_1CC04FE44((uint64_t)this, (uint64_t)a2);
  unint64_t v5 = v4;
  *(void *)(v4 + 16) = -1;
  if (!*(unsigned char *)(v4 + 96)) {
    llvm::LazyCallGraph::Node::populateSlow((llvm::LazyCallGraph::Node *)v4);
  }
  uint64_t v7 = a2;
  sub_1CC05667C((uint64_t *)this + 12, &v7)[1] = v5;
  return v5;
}

void *sub_1CD499848(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (void *)sub_1CB906F34((uint64_t *)(a1 + 192), 32, 3);
  *unint64_t v5 = a2;
  v5[1] = v5 + 3;
  void v5[2] = 0x100000000;
  if (*(_DWORD *)(a3 + 8)) {
    sub_1CD41C56C((uint64_t)(v5 + 1), a3);
  }
  return v5;
}

uint64_t llvm::LazyCallGraph::addSplitRefRecursiveFunctions(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v41[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (void *)sub_1CC04FE44(a1, a2);
  uint64_t v39 = 0;
  v40[0] = v7;
  size_t v38 = (uint64_t *)(a1 + 288);
  if ((sub_1CBFA3AF4((uint64_t *)(a1 + 288), v40, &v39) & 1) != 0 && (uint64_t v8 = (uint64_t *)v39[1]) != 0) {
    uint64_t v9 = *v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if (!a4) {
    goto LABEL_38;
  }
  char v10 = 0;
  uint64_t v11 = (uint64_t)v7 + 24;
  uint64_t v12 = (llvm::Function **)a3;
  int v13 = (llvm::Function **)&a3[a4];
  do
  {
    while (1)
    {
      unint64_t inited = llvm::LazyCallGraph::initNode((llvm::LazyCallGraph *)a1, *v12);
      uint64_t result = llvm::LazyCallGraph::EdgeSequence::insertEdgeInternal(v11, inited, 0);
      uint64_t v16 = *(void *)(inited + 24);
      uint64_t v17 = *(unsigned int *)(inited + 32);
      if (v17)
      {
        uint64_t v18 = 8 * v17;
        int v19 = *(uint64_t **)(inited + 24);
        while ((*v19 & 0xFFFFFFFFFFFFFFF8) == 0 || !*(void *)(*v19 & 0xFFFFFFFFFFFFFFF8))
        {
          ++v19;
          v18 -= 8;
          if (!v18) {
            goto LABEL_11;
          }
        }
      }
      else
      {
        int v19 = *(uint64_t **)(inited + 24);
      }
      uint64_t v20 = (uint64_t *)(v16 + 8 * v17);
      if (v19 == v20) {
        break;
      }
      uint64_t v21 = *v19;
      while (1)
      {
        uint64_t v39 = 0;
        v40[0] = (void *)(v21 & 0xFFFFFFFFFFFFFFF8);
        uint64_t result = sub_1CBFA3AF4(v38, v40, &v39);
        if (result)
        {
          unsigned int v22 = (void *)v39[1];
          if (v22) {
            unsigned int v22 = (void *)*v22;
          }
        }
        else
        {
          unsigned int v22 = 0;
        }
        BOOL v23 = v22 == (void *)v9;
        if (v23) {
          break;
        }
        if (++v19 != v20)
        {
          v10 |= v23;
          while (1)
          {
            uint64_t v21 = *v19;
            if ((*v19 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              if (*(void *)(*v19 & 0xFFFFFFFFFFFFFFF8)) {
                break;
              }
            }
            if (++v19 == v20) {
              goto LABEL_11;
            }
          }
          if (v19 != v20) {
            continue;
          }
        }
        goto LABEL_11;
      }
      ++v12;
      char v10 = 1;
      if (v12 == v13) {
        goto LABEL_30;
      }
    }
LABEL_11:
    ++v12;
  }
  while (v12 != v13);
  if ((v10 & 1) == 0)
  {
LABEL_38:
    uint64_t v30 = (void *)sub_1CB906F34((uint64_t *)(a1 + 312), 128, 3);
    __int16 v31 = v30;
    *uint64_t v30 = a1;
    v30[1] = v30 + 3;
    v30[2] = 0x400000000;
    v30[7] = 1;
    for (uint64_t i = 8; i != 16; i += 2)
      v30[i] = -4096;
    uint64_t v39 = (void *)v9;
    v40[0] = 0;
    if (sub_1CBFA3AF4((uint64_t *)(a1 + 552), &v39, v40)) {
      uint64_t v33 = v40[0];
    }
    else {
      uint64_t v33 = (_DWORD *)(*(void *)(a1 + 552) + 16 * *(unsigned int *)(a1 + 568));
    }
    int v34 = v33[2];
    uint64_t v35 = *(void *)(a1 + 408) + 8 * v34;
    v40[0] = v31;
    uint64_t result = (uint64_t)sub_1CD49ACAC((unsigned int *)(a1 + 408), v35, v40);
    int v36 = *(_DWORD *)(a1 + 416);
    if (v34 < v36)
    {
      uint64_t v37 = 8 * v34;
      do
      {
        uint64_t result = (uint64_t)sub_1CC057A3C(a1 + 552, (uint64_t *)(*(void *)(a1 + 408) + v37));
        *(_DWORD *)(result + 8) = v34++;
        v37 += 8;
      }
      while (v36 != v34);
    }
    uint64_t v9 = (uint64_t)v31;
  }
LABEL_30:
  if (a4)
  {
    uint64_t v24 = 8 * a4;
    do
    {
      unint64_t v25 = (void *)sub_1CC04FE44(a1, *a3);
      uint64_t v39 = 0;
      v40[0] = v41;
      v41[0] = v25;
      v40[1] = (void *)0x100000001;
      char v26 = sub_1CD499848(a1, v9, (uint64_t)v40);
      if (v40[0] != v41) {
        free(v40[0]);
      }
      uint64_t v39 = v26;
      int v27 = *(_DWORD *)(v9 + 56) >> 1;
      *((_DWORD *)sub_1CD49A8AC((_DWORD *)(v9 + 56), (uint64_t *)&v39) + 2) = v27;
      unint64_t v28 = *(unsigned int *)(v9 + 16);
      if (v28 >= *(unsigned int *)(v9 + 20)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v29 = (uint64_t)v39;
      *(void *)(*(void *)(v9 + 8) + 8 * v28) = v39;
      ++*(_DWORD *)(v9 + 16);
      v40[0] = v25;
      uint64_t result = (uint64_t)sub_1CD49ABC4((uint64_t)v38, (uint64_t *)v40);
      *(void *)(result + 8) = v29;
      ++a3;
      v24 -= 8;
    }
    while (v24);
  }
  return result;
}

uint64_t llvm::LazyCallGraph::insertInto(llvm::LazyCallGraph *this, llvm::Function *a2, llvm::LazyCallGraph::Node **a3)
{
  uint64_t result = sub_1CB906F34((uint64_t *)this, 104, 3);
  *a3 = (llvm::LazyCallGraph::Node *)result;
  *(void *)uint64_t result = this;
  *(void *)(result + 8) = a2;
  *(unsigned char *)(result + 96) = 0;
  *(void *)(result + 16) = 0;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void *llvm::LazyCallGraphPrinterPass::LazyCallGraphPrinterPass(void *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

void llvm::LazyCallGraphPrinterPass::run()
{
}

void *llvm::LazyCallGraphDOTPrinterPass::LazyCallGraphDOTPrinterPass(void *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

void llvm::LazyCallGraphDOTPrinterPass::run()
{
}

uint64_t sub_1CD49A500(uint64_t a1, const void **a2)
{
  if ((const void **)a1 != a2)
  {
    unint64_t v4 = a2 + 2;
    uint64_t v3 = *a2;
    if (*a2 == a2 + 2)
    {
      uint64_t v6 = a2 + 1;
      uint64_t v8 = *((unsigned int *)a2 + 2);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8) {
          memmove(*(void **)a1, *a2, 8 * v8);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9)
        {
          uint64_t v13 = *(unsigned int *)(a1 + 8);
          int v14 = a2;
          memmove(*(void **)a1, v3, 8 * v9);
          uint64_t v10 = v13;
          a2 = v14;
        }
        else
        {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v6;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 8 * v10), (char *)*a2 + 8 * v10, (unsigned char *)*a2 + 8 * v11 - ((unsigned char *)*a2 + 8 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v8;
    }
    else
    {
      unint64_t v5 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        uint64_t v12 = a2;
        free(v5);
        a2 = v12;
        uint64_t v3 = *v12;
      }
      *(void *)a1 = v3;
      uint64_t v6 = a2 + 1;
      *(void *)(a1 + 8) = a2[1];
      *a2 = v4;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v6 = 0;
  }
  return a1;
}

uint64_t sub_1CD49A640(uint64_t result, uint64_t a2, char a3)
{
  unsigned int v3 = *(_DWORD *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)result + 8 * v3) = a2 | (4 * (a3 != 0));
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t sub_1CD49A6B8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = a2 + 16;
    unint64_t v4 = *(uint64_t **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9)
        {
          uint64_t v11 = &v4[2 * v9];
          uint64_t v12 = *(void **)a1;
          do
          {
            uint64_t v13 = *v4;
            uint64_t v14 = v4[1];
            v4 += 2;
            *uint64_t v12 = v13;
            v12[1] = v14;
            v12 += 2;
          }
          while (v4 != v11);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          uint64_t v15 = &v4[2 * v10];
          uint64_t v16 = *(void **)a1;
          do
          {
            uint64_t v17 = *v4;
            uint64_t v18 = v4[1];
            v4 += 2;
            *uint64_t v16 = v17;
            v16[1] = v18;
            v16 += 2;
          }
          while (v4 != v15);
        }
        else
        {
          uint64_t v10 = 0;
        }
        if (v10 != v9) {
          memcpy((void *)(*(void *)a1 + 16 * v10), (const void *)(*(void *)a2 + 16 * v10), *(void *)a2 + 16 * v9 - (*(void *)a2 + 16 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v9;
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        unint64_t v4 = *(uint64_t **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD49A7EC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 16;
  uint64_t v5 = *(uint64_t **)(a1 + 16);
  uint64_t v6 = *(unsigned int *)(a1 + 24);
  if (v6)
  {
    uint64_t v7 = 8 * v6;
    do
    {
      uint64_t v8 = *v5++;
      MEMORY[0x1D25D9CD0](v8, 8);
      v7 -= 8;
    }
    while (v7);
  }
  uint64_t v9 = *(uint64_t **)(a1 + 64);
  uint64_t v10 = *(unsigned int *)(a1 + 72);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      uint64_t v12 = *v9;
      v9 += 2;
      MEMORY[0x1D25D9CD0](v12, 8);
      v11 -= 16;
    }
    while (v11);
  }
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  sub_1CBA6E388(v4, (const void **)(a2 + 16));
  sub_1CD427714(a1 + 64, a2 + 64);
  *(void *)(a2 + 80) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 72) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  return a1;
}

void *sub_1CD49A8AC(_DWORD *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC056A94((uint64_t)a1, *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CC056B38(a1, a2, v7);
    *uint64_t v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t sub_1CD49A910(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD49AA9C(a1, v6, v6 + 16 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)uint64_t v9 = v10;
      *((_DWORD *)v9 + 2) = *(_DWORD *)(a1 + v8 + 16);
      v9 += 16;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD49AA9C(a1, (uint64_t)v14, (uint64_t)v9);
}

uint64_t sub_1CD49AA9C(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CC056A94((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *(void *)a2;
      *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD49AB60(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a2;
  uint64_t v7 = 0;
  if (sub_1CD46E5FC(a1, &v6, &v7)) {
    return v7;
  }
  if (*(unsigned char *)a1)
  {
    uint64_t v4 = a1 + 8;
    uint64_t v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 16 * v5;
}

void *sub_1CD49ABC4(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBF8BDAC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CC0578F8(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1CD49AC2C(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v3) = a2 | (4 * (*a3 != 0));
  unsigned int v4 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v4;
  return *(void *)a1 + 8 * v4 - 8;
}

unsigned int *sub_1CD49ACAC(unsigned int *result, uint64_t a2, void *a3)
{
  unsigned int v4 = result;
  uint64_t v5 = *(void *)result;
  uint64_t v6 = result[2];
  if (*(void *)result + 8 * v6 == a2)
  {
    if (v6 >= result[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(v5 + 8 * v6) = *a3;
    ++result[2];
  }
  else
  {
    if (v6 >= result[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = (void *)(v5 + 8 * ((a2 - v5) >> 3));
    *(void *)(v5 + 8 * v6) = *(void *)(v5 + 8 * v6 - 8);
    uint64_t v8 = *(void *)result + 8 * v6 - 8;
    if ((void *)v8 != v7)
    {
      uint64_t result = (unsigned int *)memmove(v7 + 1, v7, v8 - (void)v7);
      LODWORD(v6) = v4[2];
    }
    void v4[2] = v6 + 1;
    *uint64_t v7 = *a3;
  }
  return result;
}

llvm::LazyValueInfoWrapperPass *llvm::LazyValueInfoWrapperPass::LazyValueInfoWrapperPass(llvm::LazyValueInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::LazyValueInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2604C80;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5FA0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC057C80;
    v5[1] = &PassRegistry;
    unsigned int v4 = v5;
    std::__call_once(&qword_1EBCC5FA0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeLazyValueInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC5FA0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC057C80;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCC5FA0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createLazyValueInfoPass(llvm *this)
{
}

void llvm::LazyValueInfoWrapperPass::getAnalysisUsage(llvm::LazyValueInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::AssumptionCacheTracker::ID);

  sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
}

uint64_t llvm::LazyValueInfo::getConstantRangeOnEdge@<X0>(llvm::LazyValueInfo *this@<X0>, llvm::Value *a2@<X1>, llvm::BasicBlock *a3@<X2>, llvm::BasicBlock *a4@<X3>, llvm::Instruction *a5@<X4>, uint64_t a6@<X8>)
{
  v19[4] = *MEMORY[0x1E4F143B8];
  unsigned int v11 = *(_DWORD *)(*(void *)a2 + 8) >> 8;
  uint64_t v12 = sub_1CC0580B0((uint64_t *)this + 3, *(void *)this, *(void *)(*((void *)a3 + 7) + 40));
  sub_1CC0591D8(v12, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, (uint64_t)&v18);
  char v13 = v18;
  if ((_BYTE)v18)
  {
    if ((v18 & 0xFE) == 4)
    {
      uint64_t result = sub_1CC067C7C(a6, (uint64_t)v19);
      char v13 = v18;
      goto LABEL_6;
    }
    uint64_t v15 = (unint64_t *)a6;
    unsigned int v16 = v11;
    int v17 = 1;
  }
  else
  {
    uint64_t v15 = (unint64_t *)a6;
    unsigned int v16 = v11;
    int v17 = 0;
  }
  uint64_t result = (uint64_t)llvm::ConstantRange::ConstantRange(v15, v16, v17);
LABEL_6:
  if ((v13 & 0xFE) == 4) {
    return sub_1CC05EB8C((uint64_t)v19);
  }
  return result;
}

uint64_t llvm::LazyValueInfo::getPredicateAt(llvm::LazyValueInfo *this, uint64_t SwappedPredicate, llvm::Value *a3, llvm::Value *a4, llvm::Instruction *a5, int a6)
{
  if (!a4 || *((unsigned __int8 *)a4 + 16) > 0x14u)
  {
    if (!a3 || *((unsigned __int8 *)a3 + 16) > 0x14u) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v7 = this;
    int v8 = a6;
    uint64_t v9 = a5;
    uint64_t v10 = a4;
    unsigned int v11 = a3;
    int SwappedPredicate = llvm::CmpInst::getSwappedPredicate(SwappedPredicate);
    this = v7;
    a3 = v10;
    a4 = v11;
    a5 = v9;
    a6 = v8;
  }

  return llvm::LazyValueInfo::getPredicateAt(this, SwappedPredicate, a3, a4, a5, a6);
}

uint64_t *llvm::LazyValueInfo::printLVI(llvm::LazyValueInfo *this, llvm::Function *a2, llvm::DominatorTree *a3, llvm::raw_ostream *a4)
{
  uint64_t v6 = *((void *)this + 3);
  uint64_t result = (uint64_t *)((char *)this + 24);
  if (v6)
  {
    uint64_t v10 = sub_1CC0580B0(result, *(void *)this, *((void *)a2 + 5));
    v11[0] = &unk_1F2604E20;
    v11[1] = v10;
    void v11[2] = a3;
    return llvm::Function::print((const llvm::Module **)a2, a4, (llvm::AssemblyAnnotationWriter *)v11, 0, 0);
  }
  return result;
}

void sub_1CD49B1B8(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F2604C80;
  llvm::LazyValueInfo::releaseMemory(a1 + 4);

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD49B20C(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F2604C80;
  llvm::LazyValueInfo::releaseMemory(a1 + 4);
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LazyValueInfoWrapperPass>()
{
}

uint64_t sub_1CD49B2B0(uint64_t a1, unsigned int *a2)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  *(void *)a1 = 1;
  *(int64x2_t *)(a1 + 8) = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  sub_1CC063910((unsigned int *)a1, a2);
  return a1;
}

void sub_1CD49B310()
{
}

uint64_t sub_1CD49B380(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v3 = a2 + 16;
    unsigned int v4 = (_DWORD *)(*(void *)result + 24);
    uint64_t v5 = 32 * v2;
    do
    {
      *(_DWORD *)(v3 - 8) = *(v4 - 4);
      *(void *)(v3 - 16) = *((void *)v4 - 3);
      *(v4 - 4) = 0;
      *(_DWORD *)(v3 + 8) = *v4;
      *(void *)uint64_t v3 = *((void *)v4 - 1);
      v3 += 32;
      *unsigned int v4 = 0;
      v4 += 8;
      v5 -= 32;
    }
    while (v5);
    uint64_t v6 = *(unsigned int *)(result + 8);
    if (v6)
    {
      uint64_t v7 = 32 * v6;
      uint64_t v8 = *(void *)result - 32;
      do
      {
        uint64_t result = sub_1CC05EB8C(v8 + v7);
        v7 -= 32;
      }
      while (v7);
    }
  }
  return result;
}

int *sub_1CD49B408(int *a1)
{
  int v2 = *a1;
  if (*a1 > 1)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      uint64_t v7 = a1 + 10;
LABEL_10:
      while ((*(void *)result | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        result += 2;
        if (result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (int *)*((void *)a1 + 1);
      uint64_t v6 = a1[4];
      if (v6)
      {
        uint64_t v7 = &result[2 * v6];
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v2)
    {
      uint64_t v3 = a1 + 2;
      uint64_t v4 = 4;
    }
    else
    {
      uint64_t v3 = (int *)*((void *)a1 + 1);
      uint64_t v4 = a1[4];
    }
    return &v3[2 * v4];
  }
  return result;
}

uint64_t sub_1CD49B480(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = a2;
  if (a2 != a4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = a2;
    while (1)
    {
      if (++v6 == a3)
      {
        uint64_t v6 = a3;
LABEL_7:
        ++v5;
        if (v6 == a4) {
          goto LABEL_8;
        }
      }
      else if ((*v6 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        goto LABEL_7;
      }
    }
  }
  uint64_t v5 = 0;
LABEL_8:
  uint64_t v7 = *(unsigned int *)(result + 8);
  if (v5 + v7 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a4)
  {
    uint64_t v8 = (void *)(*(void *)result + 8 * v7);
    do
    {
      uint64_t v9 = *v4++;
      *uint64_t v8 = v9;
      while (v4 != a3)
      {
        if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000) {
          goto LABEL_17;
        }
        ++v4;
      }
      uint64_t v4 = a3;
LABEL_17:
      ++v8;
    }
    while (v4 != a4);
  }
  *(_DWORD *)(result + 8) = v7 + v5;
  return result;
}

llvm::LegacyDivergenceAnalysis *llvm::LegacyDivergenceAnalysis::LegacyDivergenceAnalysis(llvm::LegacyDivergenceAnalysis *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::LegacyDivergenceAnalysis::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2604F08;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 20) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6070, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0688E4;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6070, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeLegacyDivergenceAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6070, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0688E4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6070, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createLegacyDivergenceAnalysisPass(llvm *this)
{
}

llvm::AnalysisUsage *llvm::LegacyDivergenceAnalysis::getAnalysisUsage(llvm::LegacyDivergenceAnalysis *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::PostDominatorTreeWrapperPass::ID);
  uint64_t result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

uint64_t llvm::LegacyDivergenceAnalysis::shouldUseGPUDivergenceAnalysis(llvm::LegacyDivergenceAnalysis *this, const llvm::Function *a2, const llvm::TargetTransformInfo *a3)
{
  if (!byte_1EBCC6030 && !llvm::TargetTransformInfo::useGPUDivergenceAnalysis(a3)) {
    return 0;
  }
  uint64_t v5 = (uint64_t *)*((void *)this + 1);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 == v7)
  {
LABEL_5:
    uint64_t v8 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v6 != &llvm::LoopInfoWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7) {
        goto LABEL_5;
      }
    }
    uint64_t v8 = *(void *)(v6 + 8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void *, const llvm::TargetTransformInfo *))(*(void *)v8 + 96))(v8, &llvm::LoopInfoWrapperPass::ID, a3);
  char v13 = a2;
  std::string __p = 0;
  uint64_t v10 = (uint64_t *)(v9 + 32);
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  sub_1CBF8C36C((char **)&__p, (uint64_t)&v13);
  uint64_t v11 = sub_1CBFE347C(&__p, v10) ^ 1;
  if (__p)
  {
    uint64_t v15 = __p;
    operator delete(__p);
  }
  return v11;
}

uint64_t llvm::LegacyDivergenceAnalysis::isDivergent(llvm::LegacyDivergenceAnalysis *this, const llvm::Value *a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 8))
    {
      return 1;
    }
    else
    {
      uint64_t v4 = *(llvm::DivergenceAnalysisImpl **)(v2 + 24);
      return llvm::DivergenceAnalysisImpl::isDivergent(v4, a2);
    }
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = a2;
    return sub_1CBFE4194((uint64_t *)this + 5, &v6, &v5);
  }
}

void sub_1CD49B8A0(llvm::Pass *a1)
{
  sub_1CD49B914(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LegacyDivergenceAnalysis>()
{
}

void sub_1CD49B914(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2604F08;
  MEMORY[0x1D25D9CD0](*((void *)a1 + 8), 8);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 5), 8);
  uint64_t v2 = *((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v2)
  {
    uint64_t v3 = sub_1CD49B9A4(v2);
    MEMORY[0x1D25D9CE0](v3, 0x1020C40F5E4CFB4);
  }

  llvm::Pass::~Pass(a1);
}

uint64_t sub_1CD49B9A4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2)
  {
    uint64_t v5 = sub_1CD484224(v2);
    MEMORY[0x1D25D9CE0](v5, 0x10E0C405B15C183);
  }
  uint64_t v3 = *(llvm::SyncDependenceAnalysis **)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v3)
  {
    llvm::SyncDependenceAnalysis::~SyncDependenceAnalysis(v3);
    MEMORY[0x1D25D9CE0]();
  }
  return a1;
}

void llvm::LintPass::run()
{
}

void llvm::createLintLegacyPassPass(llvm *this)
{
}

llvm::UndefValue *llvm::FindAvailableLoadedValue(llvm::MemoryLocation *a1, uint64_t a2, uint64_t **a3, int a4, llvm::AAResults *a5, unsigned char *a6, _DWORD *a7)
{
  if ((*((_WORD *)a1 + 9) & 0x301) != 0) {
    return 0;
  }
  llvm::MemoryLocation::get(a1, v17);
  uint64_t v15 = *(llvm::Type **)a1;
  char isAtomic = llvm::Instruction::isAtomic(a1);
  return llvm::findAvailablePtrLoadStore(v17, v15, isAtomic, a2, a3, a4, a5, a6, a7);
}

BOOL llvm::VectorizerParams::isInterleaveForced(llvm::VectorizerParams *this)
{
  return word_1EBCC6158 != 0;
}

int8x16_t *llvm::RuntimeCheckingPtrGroup::RuntimeCheckingPtrGroup(int8x16_t *result, unsigned __int32 a2, uint64_t a3)
{
  int8x16_t v3 = *(int8x16_t *)(*(void *)(a3 + 8) + ((unint64_t)a2 << 6) + 24);
  *uint64_t result = vextq_s8(v3, v3, 8uLL);
  result[1].i64[0] = (uint64_t)result[2].i64;
  result[1].i64[1] = 0x200000000;
  uint64_t v4 = **(void **)(*(void *)(a3 + 8) + ((unint64_t)a2 << 6) + 16);
  unsigned int v5 = *(_DWORD *)(v4 + 8);
  if ((v5 & 0xFE) == 0x12) {
    unsigned int v5 = *(_DWORD *)(**(void **)(v4 + 16) + 8);
  }
  result[2].i32[2] = v5 >> 8;
  result[2].i32[0] = a2;
  result[1].i32[2] = 1;
  return result;
}

void llvm::RuntimePointerChecking::tryToCreateDiffCheck(llvm::RuntimePointerChecking *this, const llvm::RuntimeCheckingPtrGroup *a2, const llvm::RuntimeCheckingPtrGroup *a3)
{
  v68[4] = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 360)) {
    return;
  }
  if (*((_DWORD *)a2 + 6) != 1 || *((_DWORD *)a3 + 6) != 1) {
    goto LABEL_8;
  }
  uint64_t v6 = *((void *)this + 1);
  uint64_t v7 = v6 + ((unint64_t)**((unsigned int **)a2 + 2) << 6);
  uint64_t v8 = **((unsigned int **)a3 + 2);
  uint64_t v9 = *((void *)this + 33);
  unint64_t v10 = *(void *)(v7 + 16);
  int v11 = *(unsigned __int8 *)(v7 + 40);
  uint64_t v12 = *(void *)(v9 + 16);
  unsigned int v13 = *(_DWORD *)(v9 + 32);
  sub_1CD49C184(v12, v13, v10, *(unsigned char *)(v7 + 40) == 0);
  if (v14) {
    goto LABEL_8;
  }
  uint64_t v15 = v6 + (v8 << 6);
  int v16 = *(unsigned __int8 *)(v15 + 40);
  unint64_t v62 = *(void *)(v15 + 16);
  sub_1CD49C184(v12, v13, v62, *(unsigned char *)(v15 + 40) == 0);
  if (v17) {
    goto LABEL_8;
  }
  v61 = a2;
  __int16 v18 = (_DWORD *)sub_1CD49C184(v12, v13, v10, v11 != 0);
  uint64_t v20 = v19;
  uint64_t v21 = (_DWORD *)sub_1CD49C184(v12, v13, v62, v16 != 0);
  if (v20 != 1 || v22 != 1) {
    goto LABEL_8;
  }
  if (*v21 >= *v18) {
    uint64_t v24 = v15;
  }
  else {
    uint64_t v24 = v7;
  }
  if (*v21 >= *v18) {
    uint64_t v15 = v7;
  }
  uint64_t v25 = *(_WORD *)(*(void *)(v15 + 56) + 24) == 7 ? *(void *)(v15 + 56) : 0;
  uint64_t v26 = *(_WORD *)(*(void *)(v24 + 56) + 24) == 7 ? *(void *)(v24 + 56) : 0;
  BOOL v27 = !v25 || v26 == 0;
  if (v27 || (uint64_t v28 = *(void *)(v25 + 48), v28 != *(void *)(v9 + 8)) || *(void *)(v26 + 48) != v28)
  {
LABEL_8:
    *((unsigned char *)this + 360) = 0;
    return;
  }
  uint64_t v29 = *(void *)(*(void *)(**(void **)(v28 + 32) + 56) + 40);
  llvm::MemoryDepChecker::getInstructionsForAccess(v9, *(void *)(v15 + 16), *(unsigned __int8 *)(v15 + 40), (uint64_t)&v67);
  llvm::MemoryDepChecker::getInstructionsForAccess(*((void *)this + 33), *(void *)(v24 + 16), *(unsigned __int8 *)(v24 + 40), (uint64_t)&v65);
  uint64_t v30 = *(void *)v67;
  if (!*(void *)v67 || *(unsigned char *)(v30 + 16) != 60) {
    uint64_t v30 = *(void *)(v30 - 64);
  }
  __int16 v31 = *(llvm::Type **)v30;
  uint64_t v32 = (uint64_t *)v65;
  uint64_t v33 = *(unsigned char **)v65;
  if (!*(void *)v65 || v33[16] != 60) {
    uint64_t v33 = (unsigned char *)*((void *)v33 - 8);
  }
  if (*((unsigned char *)v31 + 8) != 19)
  {
    int v34 = *(llvm::Type **)v33;
    if (*(unsigned char *)(*(void *)v33 + 8) != 19)
    {
      uint64_t v35 = (llvm::DataLayout *)(v29 + 272);
      unint64_t v36 = sub_1CC07112C(v35, v31);
      int v38 = v37;
      unint64_t v40 = sub_1CC07112C(v35, v34);
      int v41 = (int)v39;
      if (v38 == 1) {
      if (v41 == 1)
      }
      if (v36 >= v40) {
        int v42 = v38;
      }
      else {
        int v42 = v41;
      }
      if (v42 == 1) {
      if (v36 <= v40)
      }
        LODWORD(v36) = v40;
      int v43 = ***(llvm::IntegerType ****)(v15 + 16);
      uint64_t PointerAlignElem = llvm::DataLayout::getPointerAlignElem(v35, *((_DWORD *)v61 + 10));
      uint64_t v45 = (llvm::Type *)llvm::IntegerType::get(v43, (llvm::LLVMContext *)*(unsigned int *)(PointerAlignElem + 4));
      uint64_t v46 = sub_1CBFD7EA0(v26, *((llvm::ScalarEvolution **)this + 34));
      if (v46) {
        BOOL v47 = *(unsigned __int16 *)(v46 + 24) == 0;
      }
      else {
        BOOL v47 = 0;
      }
      if (!v47) {
        goto LABEL_58;
      }
      uint64_t v48 = v46;
      if (v46 != sub_1CBFD7EA0(v25, *((llvm::ScalarEvolution **)this + 34))) {
        goto LABEL_58;
      }
      sub_1CBF71A98((const llvm::APInt *)(*(void *)(v48 + 32) + 24), (llvm::APInt *)&v63);
      unsigned int v49 = v64;
      if (v64 >= 0x41)
      {
        if (v49 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v63) >= 0x41)
        {
          if (v63) {
            MEMORY[0x1D25D9CB0](v63, 0x1000C8000313F17);
          }
          goto LABEL_58;
        }
        uint64_t v60 = *v63;
        MEMORY[0x1D25D9CB0]();
        if (v60 != v36)
        {
LABEL_58:
          *((unsigned char *)this + 360) = 0;
LABEL_59:
          uint64_t v32 = (uint64_t *)v65;
          goto LABEL_60;
        }
      }
      else if (v63 != (uint64_t *)v36)
      {
        goto LABEL_58;
      }
      uint64_t v50 = *(void *)(v48 + 32);
      size_t v51 = (uint64_t *)(v50 + 24);
      unsigned int v52 = *(_DWORD *)(v50 + 32);
      unsigned int v53 = v52 - 1;
      if (v52 >= 0x41) {
        size_t v51 = (uint64_t *)(*v51 + 8 * (v53 >> 6));
      }
      uint64_t v54 = 1 << v53;
      uint64_t v55 = *v51;
      if ((v55 & v54) != 0) {
        uint64_t v56 = v26;
      }
      else {
        uint64_t v56 = v25;
      }
      if ((v55 & v54) != 0) {
        uint64_t v57 = v25;
      }
      else {
        uint64_t v57 = v26;
      }
      PtrToIntExpr = llvm::ScalarEvolution::getPtrToIntExpr(*((llvm::ScalarEvolution **)this + 34), **(const llvm::SCEV ***)(v57 + 32), v45);
      v59 = llvm::ScalarEvolution::getPtrToIntExpr(*((llvm::ScalarEvolution **)this + 34), **(const llvm::SCEV ***)(v56 + 32), v45);
      if (*((_WORD *)PtrToIntExpr + 12) != 15 && *((_WORD *)v59 + 12) != 15)
      {
        sub_1CD49C354((uint64_t)this + 368, (uint64_t)v59, (uint64_t)PtrToIntExpr, v36);
        goto LABEL_59;
      }
      goto LABEL_58;
    }
  }
LABEL_60:
  if (v32 != &v66) {
    free(v32);
  }
  if (v67 != v68) {
    free(v67);
  }
}

uint64_t sub_1CD49C184(uint64_t a1, unsigned int a2, unint64_t a3, int a4)
{
  uint64_t v4 = 4;
  if (!a4) {
    uint64_t v4 = 0;
  }
  if (a2)
  {
    unint64_t v5 = a3 & 0xFFFFFFFFFFFFFFFBLL | v4;
    unsigned int v6 = a2 - 1;
    uint64_t v7 = (uint64_t *)(a1 + 32 * ((a2 - 1) & (v5 ^ (a3 >> 9))));
    uint64_t v8 = *v7;
    if (v5 == *v7) {
      goto LABEL_5;
    }
    int v10 = 1;
    LODWORD(v11) = v6 & (v5 ^ (a3 >> 9));
    while (v8 != -4)
    {
      int v12 = v11 + v10++;
      uint64_t v11 = v12 & v6;
      uint64_t v8 = *(void *)(a1 + 32 * v11);
      if (v5 == v8)
      {
        uint64_t v7 = (uint64_t *)(a1 + 32 * v11);
        goto LABEL_5;
      }
    }
  }
  uint64_t v7 = (uint64_t *)(a1 + 32 * a2);
LABEL_5:
  if (v7 == (uint64_t *)(a1 + 32 * a2)) {
    return 0;
  }
  else {
    return v7[1];
  }
}

uint64_t llvm::MemoryDepChecker::getInstructionsForAccess@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a3) {
    uint64_t v5 = 4;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(this + 16);
  uint64_t v7 = *(unsigned int *)(this + 32);
  if (v7)
  {
    unint64_t v8 = a2 & 0xFFFFFFFFFFFFFFFBLL | v5;
    unsigned int v9 = v7 - 1;
    int v10 = (uint64_t *)(v6 + 32 * ((v7 - 1) & (v8 ^ (a2 >> 9))));
    uint64_t v11 = *v10;
    if (v8 == *v10) {
      goto LABEL_6;
    }
    int v15 = 1;
    LODWORD(v16) = v9 & (v8 ^ (a2 >> 9));
    while (v11 != -4)
    {
      int v17 = v16 + v15++;
      uint64_t v16 = v17 & v9;
      uint64_t v11 = *(void *)(v6 + 32 * v16);
      if (v8 == v11)
      {
        int v10 = (uint64_t *)(v6 + 32 * v16);
        goto LABEL_6;
      }
    }
  }
  int v10 = (uint64_t *)(v6 + 32 * v7);
LABEL_6:
  *(void *)a4 = a4 + 16;
  *(void *)(a4 + 8) = 0x400000000;
  int v12 = (unsigned int *)v10[1];
  unsigned int v13 = (unsigned int *)v10[2];
  if (v12 != v13)
  {
    unsigned int v14 = 0;
    do
    {
      if (v14 >= *(_DWORD *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a4 + 8 * v14) = *(void *)(*(void *)(this + 40) + 8 * *v12);
      unsigned int v14 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v14;
      ++v12;
    }
    while (v12 != v13);
  }
  return this;
}

uint64_t sub_1CD49C354(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD49EBD4(a1, a2, a3, a4);
  }
  uint64_t v5 = *(void *)a1 + 24 * v4;
  *(void *)uint64_t v5 = a2;
  *(void *)(v5 + 8) = a3;
  *(_DWORD *)(v5 + 16) = a4;
  *(_DWORD *)(a1 + 8) = v4 + 1;
  return a1;
}

void llvm::RuntimePointerChecking::generateChecks(llvm::RuntimePointerChecking *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = a2 + 16;
  *(void *)(a2 + 8) = 0x400000000;
  unint64_t v2 = *((unsigned int *)this + 40);
  if (v2)
  {
    int8x16_t v3 = this;
    uint64_t v4 = 0;
    uint64_t v5 = 1;
    uint64_t v6 = 48;
    do
    {
      unint64_t v7 = v4 + 1;
      if (v4 + 1 < v2)
      {
        uint64_t v8 = v6;
        unint64_t v9 = v5;
        int v15 = (unsigned int *)v3;
        do
        {
          uint64_t v10 = *((void *)v3 + 19);
          int v11 = llvm::RuntimePointerChecking::needsChecking((uint64_t)v3, v10 + 48 * v4, v10 + v8);
          int8x16_t v3 = (llvm::RuntimePointerChecking *)v15;
          if (v11)
          {
            llvm::RuntimePointerChecking::tryToCreateDiffCheck((llvm::RuntimePointerChecking *)v15, (const llvm::RuntimeCheckingPtrGroup *)(v10 + 48 * v4), (const llvm::RuntimeCheckingPtrGroup *)(v10 + v8));
            unint64_t v12 = *(unsigned int *)(a2 + 8);
            if (v12 >= *(unsigned int *)(a2 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            unsigned int v13 = (void *)(*(void *)a2 + 16 * v12);
            *unsigned int v13 = v10 + 48 * v4;
            v13[1] = v8 + v10;
            ++*(_DWORD *)(a2 + 8);
            int8x16_t v3 = (llvm::RuntimePointerChecking *)v15;
            unint64_t v2 = v15[40];
          }
          ++v9;
          v8 += 48;
        }
        while (v9 < v2);
      }
      ++v5;
      v6 += 48;
      ++v4;
    }
    while (v2 > v7);
  }
}

void llvm::RuntimePointerChecking::generateChecks(llvm::RuntimePointerChecking *a1, uint64_t a2, char a3)
{
  v5[8] = *MEMORY[0x1E4F143B8];
  llvm::RuntimePointerChecking::groupChecks((uint64_t)a1, a2, a3);
  llvm::RuntimePointerChecking::generateChecks(a1, (uint64_t)v4);
  sub_1CD49EC44((uint64_t)a1 + 280, (uint64_t)v4);
  if (v4[0] != v5) {
    free(v4[0]);
  }
}

BOOL llvm::RuntimePointerChecking::needsChecking(llvm::RuntimePointerChecking *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = v3 + ((unint64_t)a2 << 6);
  uint64_t v5 = v3 + ((unint64_t)a3 << 6);
  return *(unsigned __int8 *)(v4 + 40) | *(unsigned __int8 *)(v5 + 40)
      && *(_DWORD *)(v4 + 44) != *(_DWORD *)(v5 + 44)
      && *(_DWORD *)(v3 + ((unint64_t)a2 << 6) + 48) == *(_DWORD *)(v3 + ((unint64_t)a3 << 6) + 48);
}

llvm::SCEV *llvm::RuntimeCheckingPtrGroup::addPointer(llvm::SCEV **this, unsigned int a2, llvm::RuntimePointerChecking *a3, uint64_t a4, unsigned int a5)
{
  unint64_t v5 = *((void *)a3 + 1) + ((unint64_t)a2 << 6);
  return llvm::RuntimeCheckingPtrGroup::addPointer(this, a2, *(const llvm::SCEV **)(v5 + 24), *(const llvm::SCEV **)(v5 + 32), a5, *((llvm::ScalarEvolution **)a3 + 34));
}

uint64_t sub_1CD49C5CC(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD49EDB0(a1, a2);
  uint64_t v4 = *(void *)a1;
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(void *)a1 + 48 * v5;
  *(_OWORD *)uint64_t v6 = *(_OWORD *)v3;
  *(void *)(v6 + 24) = 0x200000000;
  *(void *)(v6 + 16) = v6 + 32;
  uint64_t result = v6 + 16;
  if (*(_DWORD *)(v3 + 24)) {
    uint64_t result = sub_1CC0778D4(result, v3 + 16);
  }
  *(_DWORD *)(v4 + 48 * v5 + 40) = *(_DWORD *)(v3 + 40);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

BOOL llvm::RuntimePointerChecking::arePointersInSamePartition(void *a1, unsigned int a2, unsigned int a3)
{
  int v3 = *(_DWORD *)(*a1 + 4 * a2);
  return v3 != -1 && v3 == *(_DWORD *)(*a1 + 4 * a3);
}

llvm::raw_ostream *llvm::RuntimePointerChecking::printChecks(llvm::raw_ostream *result, llvm::raw_ostream *this, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = *(unsigned int *)(a3 + 8);
  if (v4)
  {
    uint64_t v6 = (uint64_t)result;
    unint64_t v7 = 0;
    uint64_t v8 = *(unint64_t **)a3;
    uint64_t v25 = *(void *)a3 + 16 * v4;
    unsigned int v9 = a4 + 2;
    do
    {
      unint64_t v11 = *v8;
      unint64_t v10 = v8[1];
      unint64_t v12 = llvm::raw_ostream::indent(this, a4);
      unsigned int v13 = sub_1CB8E509C(v12, "Check ");
      unsigned int v14 = llvm::raw_ostream::operator<<(v13, v7);
      sub_1CB8E509C(v14, ":\n");
      int v15 = llvm::raw_ostream::indent(this, v9);
      uint64_t v16 = sub_1CB8E509C(v15, "Comparing group (");
      int v17 = llvm::raw_ostream::operator<<(v16, *v8);
      sub_1CB8E509C(v17, "):\n");
      if (*(_DWORD *)(v11 + 24))
      {
        unint64_t v18 = 0;
        do
        {
          uint64_t v19 = llvm::raw_ostream::indent(this, v9);
          llvm::Value::print(*(llvm::Value **)(*(void *)(v6 + 8)+ ((unint64_t)*(unsigned int *)(*(void *)(v11 + 16) + 4 * v18) << 6)+ 16), v19, 0);
          sub_1CB8E509C(v19, "\n");
          ++v18;
        }
        while (v18 < *(unsigned int *)(v11 + 24));
      }
      uint64_t v20 = llvm::raw_ostream::indent(this, v9);
      uint64_t v21 = sub_1CB8E509C(v20, "Against group (");
      uint64_t v22 = llvm::raw_ostream::operator<<(v21, v8[1]);
      uint64_t result = sub_1CB8E509C(v22, "):\n");
      if (*(_DWORD *)(v10 + 24))
      {
        unint64_t v23 = 0;
        do
        {
          uint64_t v24 = llvm::raw_ostream::indent(this, v9);
          llvm::Value::print(*(llvm::Value **)(*(void *)(v6 + 8)+ ((unint64_t)*(unsigned int *)(*(void *)(v10 + 16) + 4 * v23) << 6)+ 16), v24, 0);
          uint64_t result = sub_1CB8E509C(v24, "\n");
          ++v23;
        }
        while (v23 < *(unsigned int *)(v10 + 24));
      }
      ++v7;
      v8 += 2;
    }
    while (v8 != (unint64_t *)v25);
  }
  return result;
}

llvm::raw_ostream *llvm::RuntimePointerChecking::print(llvm::RuntimePointerChecking *this, llvm::raw_ostream *a2, unsigned int a3)
{
  uint64_t v6 = llvm::raw_ostream::indent(a2, a3);
  sub_1CB8E509C(v6, "Run-time memory checks:\n");
  llvm::RuntimePointerChecking::printChecks(this, a2, (uint64_t)this + 280, a3);
  unint64_t v7 = llvm::raw_ostream::indent(a2, a3);
  uint64_t result = sub_1CB8E509C(v7, "Grouped accesses:\n");
  if (*((_DWORD *)this + 40))
  {
    unint64_t v9 = 0;
    unsigned int v23 = a3 + 2;
    unsigned int v10 = a3 + 4;
    unsigned int v11 = a3 + 6;
    do
    {
      unint64_t v12 = *((void *)this + 19) + 48 * v9;
      unsigned int v13 = llvm::raw_ostream::indent(a2, v23);
      unsigned int v14 = sub_1CB8E509C(v13, "Group ");
      int v15 = llvm::raw_ostream::operator<<(v14, v12);
      sub_1CB8E509C(v15, ":\n");
      uint64_t v16 = llvm::raw_ostream::indent(a2, v10);
      int v17 = sub_1CB8E509C(v16, "(Low: ");
      llvm::SCEV::print(*(llvm::SCEV **)(v12 + 8), v17);
      unint64_t v18 = sub_1CB8E509C(v17, " High: ");
      llvm::SCEV::print(*(llvm::SCEV **)v12, v18);
      uint64_t result = sub_1CB8E509C(v18, ")\n");
      if (*(_DWORD *)(v12 + 24))
      {
        unint64_t v19 = 0;
        unint64_t v20 = v12 + 16;
        do
        {
          uint64_t v21 = llvm::raw_ostream::indent(a2, v11);
          uint64_t v22 = sub_1CB8E509C(v21, "Member: ");
          llvm::SCEV::print(*(llvm::SCEV **)(*((void *)this + 1)+ ((unint64_t)*(unsigned int *)(*(void *)v20 + 4 * v19) << 6)+ 56), v22);
          uint64_t result = sub_1CB8E509C(v22, "\n");
          ++v19;
        }
        while (v19 < *(unsigned int *)(v20 + 8));
      }
      ++v9;
    }
    while (v9 < *((unsigned int *)this + 40));
  }
  return result;
}

uint64_t llvm::sortPtrAccesses(llvm::Type **a1, unint64_t a2, llvm *a3, llvm::Value *a4, const llvm::DataLayout *a5, uint64_t a6)
{
  unint64_t v12 = *a1;
  unsigned int v13 = operator new(0x30uLL);
  v13[4] = 0;
  *((_DWORD *)v13 + 10) = 0;
  *unsigned int v13 = 0;
  v13[1] = 0;
  void v13[2] = &v42;
  int v41 = v13;
  int v42 = v13;
  *((unsigned char *)v13 + 24) = 1;
  uint64_t v43 = 1;
  if (a2 == 1)
  {
    *(_DWORD *)(a6 + 8) = 0;
LABEL_3:
    uint64_t v14 = 1;
    goto LABEL_4;
  }
  uint64_t v16 = a1 + 1;
  unint64_t PointersDiff = llvm::getPointersDiff(a3, v12, a3, a1[1], a4, a5, (llvm::ScalarEvolution *)1, 1, v37);
  if (!HIDWORD(PointersDiff))
  {
LABEL_6:
    uint64_t v14 = 0;
    goto LABEL_4;
  }
  unint64_t v38 = a2;
  uint64_t v39 = a6;
  unint64_t v40 = &a1[a2];
  int v18 = 1;
  BOOL v19 = 1;
  while (1)
  {
    uint64_t v20 = (int)PointersDiff;
    uint64_t v21 = (uint64_t **)operator new(0x30uLL);
    uint64_t v22 = v21;
    v21[4] = (uint64_t *)v20;
    *((_DWORD *)v21 + 10) = v18;
    unsigned int v23 = v42;
    uint64_t v24 = &v42;
    uint64_t v25 = &v42;
    if (v42)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v25 = (uint64_t **)v23;
          uint64_t v26 = v23[4];
          if (v20 >= v26) {
            break;
          }
          unsigned int v23 = (uint64_t *)*v23;
          uint64_t v24 = v25;
          if (!*v25) {
            goto LABEL_15;
          }
        }
        if (v26 >= v20) {
          break;
        }
        unsigned int v23 = (uint64_t *)v23[1];
        if (!v23)
        {
          uint64_t v24 = v25 + 1;
          goto LABEL_15;
        }
      }
      operator delete(v21);
      goto LABEL_6;
    }
LABEL_15:
    *uint64_t v21 = 0;
    v21[1] = 0;
    void v21[2] = (uint64_t *)v25;
    llvm::raw_ostream *v24 = (uint64_t *)v21;
    BOOL v27 = (uint64_t *)v21;
    if (*v41)
    {
      int v41 = (uint64_t *)*v41;
      BOOL v27 = *v24;
    }
    sub_1CB8358B8(v42, v27);
    ++v43;
    if (v19) {
      break;
    }
    if (++v16 == v40)
    {
      __int16 v31 = (uint64_t *)v39;
      *(_DWORD *)(v39 + 8) = 0;
      goto LABEL_31;
    }
    BOOL v19 = 0;
LABEL_27:
    ++v18;
    unint64_t PointersDiff = llvm::getPointersDiff(a3, v12, a3, *v16, a4, a5, (llvm::ScalarEvolution *)1, 1, v38);
    uint64_t v14 = 0;
    if (!HIDWORD(PointersDiff)) {
      goto LABEL_4;
    }
  }
  uint64_t v28 = v22[1];
  if (v28)
  {
    do
    {
      uint64_t v29 = (uint64_t **)v28;
      uint64_t v28 = (uint64_t *)*v28;
    }
    while (v28);
  }
  else
  {
    do
    {
      uint64_t v29 = (uint64_t **)v22[2];
      BOOL v30 = *v29 == (uint64_t *)v22;
      uint64_t v22 = v29;
    }
    while (!v30);
  }
  BOOL v19 = v29 == &v42;
  if (++v16 != v40) {
    goto LABEL_27;
  }
  __int16 v31 = (uint64_t *)v39;
  *(_DWORD *)(v39 + 8) = 0;
  if (v29 == &v42) {
    goto LABEL_3;
  }
LABEL_31:
  sub_1CBB1173C((uint64_t)v31, v38);
  uint64_t v32 = v41;
  if (v41 == (uint64_t *)&v42) {
    goto LABEL_3;
  }
  uint64_t v33 = 0;
  uint64_t v34 = *v31;
  uint64_t v14 = 1;
  do
  {
    *(_DWORD *)(v34 + 4 * v33) = *((_DWORD *)v32 + 10);
    uint64_t v35 = (uint64_t *)v32[1];
    if (v35)
    {
      do
      {
        unint64_t v36 = (uint64_t **)v35;
        uint64_t v35 = (uint64_t *)*v35;
      }
      while (v35);
    }
    else
    {
      do
      {
        unint64_t v36 = (uint64_t **)v32[2];
        BOOL v30 = *v36 == v32;
        uint64_t v32 = (uint64_t *)v36;
      }
      while (!v30);
    }
    ++v33;
    uint64_t v32 = (uint64_t *)v36;
  }
  while (v36 != &v42);
LABEL_4:
  sub_1CBB0D544(v42);
  return v14;
}

BOOL llvm::isConsecutiveAccess(llvm *this, llvm::Value *a2, llvm::Value *a3, const llvm::DataLayout *a4, llvm::ScalarEvolution *a5)
{
  unint64_t v7 = 0;
  int v8 = *((unsigned __int8 *)this + 16);
  if (this) {
    BOOL v9 = v8 == 60;
  }
  else {
    BOOL v9 = 0;
  }
  int v10 = !v9;
  if (this && (v8 - 62) >= 0xFFFFFFFE) {
    unint64_t v7 = (llvm::Type *)*((void *)this - 4);
  }
  uint64_t v11 = 0;
  int v12 = *((unsigned __int8 *)a2 + 16);
  if (a2) {
    BOOL v13 = v12 == 60;
  }
  else {
    BOOL v13 = 0;
  }
  int v14 = !v13;
  if (a2)
  {
    if ((v12 - 62) >= 0xFFFFFFFE)
    {
      uint64_t v11 = 0;
      if (v7)
      {
        int v15 = (llvm::Type *)*((void *)a2 - 4);
        if (v15)
        {
          if (v10) {
            this = (llvm *)*((void *)this - 8);
          }
          uint64_t v16 = *(llvm **)this;
          if (v14) {
            a2 = (llvm::Value *)*((void *)a2 - 8);
          }
          unint64_t PointersDiff = llvm::getPointersDiff(v16, v7, *(llvm::Value **)a2, v15, a3, a4, (llvm::ScalarEvolution *)1, (char)a5, vars0);
          return HIDWORD(PointersDiff) && PointersDiff == 1;
        }
      }
    }
  }
  return v11;
}

BOOL llvm::MemoryDepChecker::Dependence::isPossiblyBackward(llvm::MemoryDepChecker::Dependence *this)
{
  unsigned int v1 = *((_DWORD *)this + 2);
  return v1 > 3 || v1 == 1;
}

llvm::raw_ostream *llvm::MemoryDepChecker::Dependence::print(unsigned int *a1, llvm::raw_ostream *this, unsigned int a3, void *a4)
{
  unsigned int v5 = a3;
  int v8 = llvm::raw_ostream::indent(this, a3);
  BOOL v9 = sub_1CB8E509C(v8, llvm::MemoryDepChecker::Dependence::DepName[a1[2]]);
  sub_1CB8E509C(v9, ":\n");
  v5 += 2;
  int v10 = llvm::raw_ostream::indent(this, v5);
  llvm::Value::print(*(llvm::Value **)(*a4 + 8 * *a1), v10, 0);
  sub_1CB8E509C(v10, " -> \n");
  uint64_t v11 = llvm::raw_ostream::indent(this, v5);
  llvm::Value::print(*(llvm::Value **)(*a4 + 8 * a1[1]), v11, 0);

  return sub_1CB8E509C(v11, "\n");
}

void llvm::LoopAccessInfo::blockNeedsPredication(llvm::LoopAccessInfo *this, llvm::BasicBlock *a2, llvm::Loop *a3, llvm::DominatorTree *a4)
{
}

void *sub_1CD49CEAC(void *result)
{
  unsigned int v1 = result;
  *(unsigned char *)uint64_t result = 0;
  uint64_t v2 = *((unsigned int *)result + 4);
  if (v2)
  {
    uint64_t v3 = result[1];
    uint64_t v4 = v2 << 6;
    do
    {
      uint64_t v5 = *(void *)(v3 + v4 - 48);
      if (v5 != -8192 && v5 != -4096 && v5 != 0) {
        uint64_t result = llvm::ValueHandleBase::RemoveFromUseList((void *)(v3 + v4 - 64));
      }
      v4 -= 64;
    }
    while (v4);
  }
  *((_DWORD *)v1 + 4) = 0;
  *((_DWORD *)v1 + 72) = 0;
  return result;
}

uint64_t llvm::LoopAccessInfo::print(llvm::LoopAccessInfo *this, llvm::raw_ostream *a2, uint64_t a3)
{
  if (*((unsigned char *)this + 48))
  {
    uint64_t v6 = llvm::raw_ostream::indent(a2, a3);
    sub_1CB8E509C(v6, "Memory dependences are safe");
    if (*((void *)this + 5) != -1)
    {
      unint64_t v7 = sub_1CB8E509C(a2, " with a maximum dependence distance of ");
      int v8 = llvm::raw_ostream::operator<<(v7, *((void *)this + 5));
      sub_1CB8E509C(v8, " bytes");
    }
    if (**((unsigned char **)this + 1)) {
      sub_1CB8E509C(a2, " with run-time checks");
    }
    sub_1CB8E509C(a2, "\n");
  }
  if (*((unsigned char *)this + 49))
  {
    BOOL v9 = llvm::raw_ostream::indent(a2, a3);
    sub_1CB8E509C(v9, "Has convergent operation in loop\n");
  }
  if (*((void *)this + 7))
  {
    int v10 = llvm::raw_ostream::indent(a2, a3);
    uint64_t v11 = sub_1CB8E509C(v10, "Report: ");
    llvm::DiagnosticInfoOptimizationBase::getMsg(*((llvm::DiagnosticInfoOptimizationBase **)this + 7), (uint64_t)__p);
    int v12 = v30 >= 0 ? (const char *)__p : (const char *)__p[0];
    BOOL v13 = v30 >= 0 ? (void *)(v30 & 0x7F) : __p[1];
    int v14 = llvm::raw_ostream::write(v11, v12, (size_t)v13);
    sub_1CB8E509C(v14, "\n");
    if (v30 < 0) {
      operator delete(__p[0]);
    }
  }
  uint64_t v15 = *((void *)this + 2);
  if (*(unsigned char *)(v15 + 216))
  {
    uint64_t v25 = llvm::raw_ostream::indent(a2, a3);
    sub_1CB8E509C(v25, "Dependences:\n");
    uint64_t v26 = *(unsigned int *)(v15 + 232);
    if (v26)
    {
      BOOL v27 = *(unsigned int **)(v15 + 224);
      uint64_t v28 = 16 * v26;
      do
      {
        llvm::MemoryDepChecker::Dependence::print(v27, a2, a3 + 2, (void *)(*((void *)this + 2) + 40));
        sub_1CB8E509C(a2, "\n");
        v27 += 4;
        v28 -= 16;
      }
      while (v28);
    }
  }
  else
  {
    uint64_t v16 = llvm::raw_ostream::indent(a2, a3);
    sub_1CB8E509C(v16, "Too many dependences, not recorded\n");
  }
  llvm::RuntimePointerChecking::print(*((llvm::RuntimePointerChecking **)this + 1), a2, a3);
  sub_1CB8E509C(a2, "\n");
  int v17 = llvm::raw_ostream::indent(a2, a3);
  int v18 = sub_1CB8E509C(v17, "Non vectorizable stores to invariant address were ");
  if (*((unsigned char *)this + 50)) {
    BOOL v19 = "";
  }
  else {
    BOOL v19 = "not ";
  }
  uint64_t v20 = sub_1CB8E509C(v18, v19);
  sub_1CB8E509C(v20, "found in loop.\n");
  uint64_t v21 = llvm::raw_ostream::indent(a2, a3);
  sub_1CB8E509C(v21, "SCEV assumptions:\n");
  uint64_t Predicate = llvm::PredicatedScalarEvolution::getPredicate(*(llvm::PredicatedScalarEvolution **)this);
  (*(void (**)(uint64_t, llvm::raw_ostream *, uint64_t))(*(void *)Predicate + 24))(Predicate, a2, a3);
  sub_1CB8E509C(a2, "\n");
  unsigned int v23 = llvm::raw_ostream::indent(a2, a3);
  sub_1CB8E509C(v23, "Expressions re-written:\n");
  return llvm::PredicatedScalarEvolution::print(*(void *)this, a2, a3);
}

llvm::LoopAccessLegacyAnalysis *llvm::LoopAccessLegacyAnalysis::LoopAccessLegacyAnalysis(llvm::LoopAccessLegacyAnalysis *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::LoopAccessLegacyAnalysis::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2605048;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6088, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC07656C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6088, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeLoopAccessLegacyAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6088, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC07656C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6088, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::LoopAccessLegacyAnalysis::getInfo(llvm::LoopAccessLegacyAnalysis *this, llvm::Loop *a2)
{
  uint64_t v3 = a2;
  uint64_t result = sub_1CD49F284((uint64_t)this + 32, (uint64_t *)&v3)[1];
  if (!result) {
    operator new();
  }
  return result;
}

void llvm::LoopAccessLegacyAnalysis::print(llvm::LoopAccessLegacyAnalysis *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v3 = *((void *)this + 11);
  uint64_t v5 = *(uint64_t **)(v3 + 24);
  uint64_t v4 = *(uint64_t **)(v3 + 32);
  if (v5 == v4) {
    return;
  }
  unint64_t v7 = (const void **)&v36;
  int v8 = (const llvm::SmallPtrSetImplBase *)&v44;
  BOOL v9 = (const void **)&v30;
  uint64_t v26 = *(uint64_t **)(v3 + 32);
  do
  {
    uint64_t v48 = *v5;
    sub_1CC076464(&v48, (uint64_t)&v40);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v34, v7, (const llvm::SmallPtrSetImplBase *)&v40);
    std::string __p = 0;
    unint64_t v38 = 0;
    uint64_t v39 = 0;
    sub_1CBF340A8(&__p, v42, v43, 0xAAAAAAAAAAAAAAABLL * ((v43 - (unsigned char *)v42) >> 3));
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v28, v9, v8);
    __int16 v31 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    sub_1CBF340A8(&v31, v46, v47, 0xAAAAAAAAAAAAAAABLL * ((v47 - (unsigned char *)v46) >> 3));
    while (1)
    {
      if (v38 - (unsigned char *)__p != v32 - v31) {
        goto LABEL_19;
      }
      if (__p == v38) {
        break;
      }
      int v10 = v31 + 8;
      uint64_t v11 = (char *)__p + 8;
      while (1)
      {
        int v12 = v11 - 8;
        if (*((void *)v11 - 1) != *((void *)v10 - 1)) {
          break;
        }
        int v13 = v10[8];
        if (v11[8]) {
          BOOL v14 = v13 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14)
        {
          if ((v11[8] == 0) == (v13 != 0)) {
            break;
          }
        }
        else if (*(void *)v11 != *(void *)v10)
        {
          break;
        }
        v10 += 24;
        v11 += 24;
        if (v12 + 24 == v38) {
          goto LABEL_21;
        }
      }
LABEL_19:
      uint64_t v16 = v9;
      int v17 = v8;
      int v18 = v7;
      BOOL v19 = (llvm::Value ***)*((void *)v38 - 3);
      uint64_t v20 = a2;
      uint64_t v21 = llvm::raw_ostream::indent(a2, 2u);
      Name = llvm::Value::getName(*v19[4]);
      size_t v24 = v22;
      uint64_t v25 = (void *)*((void *)v21 + 4);
      if (v22 <= *((void *)v21 + 3) - (void)v25)
      {
        if (v22)
        {
          memcpy(v25, Name, v22);
          *((void *)v21 + 4) += v24;
        }
      }
      else
      {
        llvm::raw_ostream::write(v21, Name, v22);
      }
      sub_1CB8E509C(v21, ":\n");
      Info = (llvm::LoopAccessInfo *)llvm::LoopAccessLegacyAnalysis::getInfo(this, (llvm::Loop *)v19);
      a2 = v20;
      llvm::LoopAccessInfo::print(Info, v20, 4);
      sub_1CC078F58((llvm::SmallPtrSetImplBase *)&v34);
      unint64_t v7 = v18;
      int v8 = v17;
      BOOL v9 = v16;
      uint64_t v4 = v26;
    }
LABEL_21:
    if (v31)
    {
      uint64_t v32 = v31;
      operator delete(v31);
    }
    if (v29 != v28) {
      free(v29);
    }
    if (__p)
    {
      unint64_t v38 = (char *)__p;
      operator delete(__p);
    }
    if (v35 != v34) {
      free(v35);
    }
    if (v46)
    {
      BOOL v47 = v46;
      operator delete(v46);
    }
    if (v45 != v44) {
      free(v45);
    }
    if (v42)
    {
      uint64_t v43 = v42;
      operator delete(v42);
    }
    if (v41 != v40) {
      free(v41);
    }
    ++v5;
  }
  while (v5 != v4);
}

uint64_t llvm::LoopAccessLegacyAnalysis::runOnFunction(llvm::LoopAccessLegacyAnalysis *this, llvm::Function *a2)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(char **)v5 != llvm::ScalarEvolutionWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  *((void *)this + 7) = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::ScalarEvolutionWrapperPass::ID)+ 32);
  uint64_t AnalysisIfAvailable = llvm::AnalysisResolver::getAnalysisIfAvailable(*((llvm::PMDataManager ***)this + 1), llvm::TargetLibraryInfoWrapperPass::ID);
  if (AnalysisIfAvailable)
  {
    uint64_t AnalysisIfAvailable = (*(uint64_t (**)(uint64_t, char *))(*(void *)AnalysisIfAvailable + 96))(AnalysisIfAvailable, llvm::TargetLibraryInfoWrapperPass::ID);
    if (AnalysisIfAvailable) {
      sub_1CBF5AC74(AnalysisIfAvailable, (uint64_t)a2);
    }
  }
  *((void *)this + 8) = AnalysisIfAvailable;
  BOOL v9 = (uint64_t *)*((void *)this + 1);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_11:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(char **)v10 != llvm::AAResultsWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_11;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  *((void *)this + 9) = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::AAResultsWrapperPass::ID)+ 32);
  int v13 = (uint64_t *)*((void *)this + 1);
  uint64_t v14 = *v13;
  uint64_t v15 = v13[1];
  if (v14 == v15)
  {
LABEL_15:
    uint64_t v16 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v14 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_15;
      }
    }
    uint64_t v16 = *(void *)(v14 + 8);
  }
  *((void *)this + 10) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, &llvm::DominatorTreeWrapperPass::ID)+ 32;
  int v17 = (uint64_t *)*((void *)this + 1);
  uint64_t v18 = *v17;
  uint64_t v19 = v17[1];
  if (v18 == v19)
  {
LABEL_19:
    uint64_t v20 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v18 != &llvm::LoopInfoWrapperPass::ID)
    {
      v18 += 16;
      if (v18 == v19) {
        goto LABEL_19;
      }
    }
    uint64_t v20 = *(void *)(v18 + 8);
  }
  *((void *)this + 11) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v20 + 96))(v20, &llvm::LoopInfoWrapperPass::ID)+ 32;
  return 0;
}

llvm::AnalysisUsage *llvm::LoopAccessLegacyAnalysis::getAnalysisUsage(llvm::LoopAccessLegacyAnalysis *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::ScalarEvolutionWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AAResultsWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  uint64_t result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

void sub_1CD49D954(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2605048;
  sub_1CD49E21C((uint64_t)a1 + 32);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 4), 8);

  llvm::Pass::~Pass(a1);
}

void sub_1CD49D9B4(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2605048;
  sub_1CD49E21C((uint64_t)a1 + 32);
  MEMORY[0x1D25D9CD0](*((void *)a1 + 4), 8);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CD49DA28(uint64_t a1)
{
  return sub_1CD49E294((uint64_t *)(a1 + 32));
}

uint64_t sub_1CD49DA30(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  int v11 = 0;
  uint64_t v8 = llvm::cl::parser<unsigned int>::parse(a1 + 152, (void *)a1, a3, a4, a5, a6, &v11);
  if (v8) {
    return v8;
  }
  **(_DWORD **)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD49DAC8();
}

uint64_t sub_1CD49DAC8()
{
  return 2;
}

uint64_t sub_1CD49DAD0(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1CD49DADC(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

void sub_1CD49DAEC(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    unsigned int v3 = **(_DWORD **)(a1 + 128);
LABEL_3:
    int v5 = *(_DWORD *)(a1 + 144);
    char v6 = *(unsigned char *)(a1 + 148);
    uint64_t v4 = &unk_1F25EA1B0;
    llvm::cl::parser<unsigned int>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, v3, (uint64_t)&v4, a2);
    return;
  }
  if (*(unsigned char *)(a1 + 148))
  {
    unsigned int v3 = **(_DWORD **)(a1 + 128);
    if (*(_DWORD *)(a1 + 144) != v3) {
      goto LABEL_3;
    }
  }
}

uint64_t sub_1CD49DB78(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  **(_DWORD **)(result + 128) = v1;
  return result;
}

unint64_t sub_1CD49DB94(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 208 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD49DC00();
    }
    sub_1CD49DC00();
  }
  return a2;
}

void sub_1CD49DC00()
{
}

uint64_t sub_1CD49DC70(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)result;
    uint64_t v6 = 208 * v2;
    do
    {
      uint64_t result = sub_1CD49DCF4(a2, v5);
      v5 += 208;
      a2 += 208;
      v6 -= 208;
    }
    while (v6);
    unsigned int v7 = *(_DWORD *)(v4 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)v4;
      uint64_t v9 = 208 * v7;
      uint64_t v10 = v8 - 208;
      do
      {
        uint64_t result = sub_1CD49DEA4(v10 + v9);
        v9 -= 208;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t sub_1CD49DCF4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = a1 + 24;
  uint64_t v4 = a1 + 8;
  *(void *)(a1 + 16) = 0x800000000;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD49DD84(v4, a2 + 8);
  }
  long long v5 = *(_OWORD *)(a2 + 152);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(_OWORD *)(a1 + 152) = v5;
  *(void *)(a2 + 160) = 0;
  *(void *)(a2 + 168) = 0;
  *(void *)(a2 + 152) = 0;
  long long v6 = *(_OWORD *)(a2 + 176);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(_OWORD *)(a1 + 176) = v6;
  *(void *)(a2 + 184) = 0;
  *(void *)(a2 + 192) = 0;
  *(void *)(a2 + 176) = 0;
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a2 + 200);
  return a1;
}

uint64_t sub_1CD49DD84(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    long long v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      unsigned int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)a1, v4, 16 * v9 - 3);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove(*(void **)a1, v4, 16 * v10 - 3);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 16 * v10), (const void *)(*(void *)a2 + 16 * v10), *(void *)a2 + 16 * v11 - (*(void *)a2 + 16 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v9;
    }
    else
    {
      long long v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      unsigned int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *unsigned int v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD49DEA4(uint64_t a1)
{
  if (*(char *)(a1 + 199) < 0) {
    operator delete(*(void **)(a1 + 176));
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  unsigned int v2 = *(void **)(a1 + 8);
  if (v2 != (void *)(a1 + 24)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD49DEFC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = a1 + 24;
  uint64_t v4 = a1 + 8;
  *(void *)(a1 + 16) = 0x800000000;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD49DFB4(v4, a2 + 8);
  }
  long long v5 = (_OWORD *)(a1 + 152);
  if (*(char *)(a2 + 175) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v5, *(const void **)(a2 + 152), *(void *)(a2 + 160));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 152);
    *(void *)(a1 + 168) = *(void *)(a2 + 168);
    *long long v5 = v6;
  }
  unsigned int v7 = (_OWORD *)(a1 + 176);
  if (*(char *)(a2 + 199) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v7, *(const void **)(a2 + 176), *(void *)(a2 + 184));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 176);
    *(void *)(a1 + 192) = *(void *)(a2 + 192);
    *unsigned int v7 = v8;
  }
  *(_DWORD *)(a1 + 200) = *(_DWORD *)(a2 + 200);
  return a1;
}

uint64_t sub_1CD49DFB4(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 16 * v4 - 3);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 16 * v5 - 3);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 16 * v5), (const void *)(*(void *)a2 + 16 * v5), *(void *)a2 + 16 * v6 - (*(void *)a2 + 16 * v5));
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

uint64_t sub_1CD49E088(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *unsigned int v7 = -4;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    unint64_t v9 = *(void *)a2;
    if (*(void *)a2 != -16 && v9 != -4)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CC076AD8(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *(void *)a2;
      *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t sub_1CD49E138(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *unsigned int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CC076DC4(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v10 = v12;
      uint64_t v11 = a2[1];
      *uint64_t v12 = *a2;
      v10[1] = v11;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void llvm::callDefaultCtor<llvm::LoopAccessLegacyAnalysis>()
{
}

uint64_t sub_1CD49E21C(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  if (v1)
  {
    uint64_t v2 = 16 * v1;
    uint64_t v3 = (uint64_t *)(*(void *)result + 8);
    do
    {
      if ((*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t result = *v3;
        *uint64_t v3 = 0;
        if (result)
        {
          uint64_t v4 = sub_1CC078A80((uint64_t *)result);
          uint64_t result = MEMORY[0x1D25D9CE0](v4, 0x10E0C402B7C74A4);
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
  return result;
}

uint64_t *sub_1CD49E294(uint64_t *result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (!v2 && !*((_DWORD *)result + 3)) {
    return result;
  }
  uint64_t v3 = *((unsigned int *)result + 4);
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      v1[1] = 0;
      return result;
    }
    uint64_t v4 = 16 * v3;
    uint64_t v5 = (uint64_t **)(*result + 8);
    while (1)
    {
      uint64_t v6 = (uint64_t)*(v5 - 1);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 2;
      v4 -= 16;
      if (!v4) {
        goto LABEL_12;
      }
    }
    uint64_t result = *v5;
    *uint64_t v5 = 0;
    if (result)
    {
      unsigned int v7 = sub_1CC078A80(result);
      uint64_t result = (uint64_t *)MEMORY[0x1D25D9CE0](v7, 0x10E0C402B7C74A4);
    }
LABEL_10:
    *(v5 - 1) = (uint64_t *)-4096;
    goto LABEL_11;
  }

  return (uint64_t *)sub_1CD49E368(result);
}

_DWORD *sub_1CD49E368(_DWORD *a1)
{
  int v2 = a1[2];
  uint64_t result = (_DWORD *)sub_1CD49E21C((uint64_t)a1);
  if (v2)
  {
    int v4 = 1 << (33 - __clz(v2 - 1));
    if (v4 <= 64) {
      unsigned int v5 = 64;
    }
    else {
      unsigned int v5 = v4;
    }
    if (v5 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v6 = 16 * v5;
      unsigned int v7 = *(void **)a1;
      do
      {
        *unsigned int v7 = -4096;
        v7 += 2;
        v6 -= 16;
      }
      while (v6);
      return result;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return result;
    }
    unsigned int v5 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  return sub_1CB837D60(a1, v5);
}

void sub_1CD49E424(_WORD *a1, long long *a2, _DWORD **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6090, 0, 0);
  byte_1EBCC6124 = 0;
  qword_1EBCC6110 = 0;
  unk_1EBCC6118 = &unk_1F25EA1B0;
  qword_1EBCC6090 = (uint64_t)&unk_1F26050E8;
  qword_1EBCC6128 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC6130 = (uint64_t)&unk_1F2605150;
  qword_1EBCC6148 = (uint64_t)&qword_1EBCC6130;
  sub_1CD49E514(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6090);
}

uint64_t sub_1CD49E514(_WORD *a1, long long *a2, _DWORD **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6090, "force-vector-width", 0x12uLL);
  word_1EBCC609A = (32 * (*a1 & 3)) | word_1EBCC609A & 0xFF9F;
  xmmword_1EBCC60B0 = *a2;
  uint64_t v6 = *a3;

  return sub_1CC0777B8((uint64_t)&qword_1EBCC6110, &qword_1EBCC6090, v6);
}

void sub_1CD49E5A0()
{
}

void *sub_1CD49E5B4()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2605150;
  return result;
}

void sub_1CD49E5EC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2605150;
}

void sub_1CD49E618(_WORD *a1, long long *a2, _DWORD **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6150, 0, 0);
  byte_1EBCC61E4 = 0;
  qword_1EBCC61D0 = 0;
  unk_1EBCC61D8 = &unk_1F25EA1B0;
  qword_1EBCC6150 = (uint64_t)&unk_1F26050E8;
  qword_1EBCC61E8 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC61F0 = (uint64_t)&unk_1F2605150;
  qword_1EBCC6208 = (uint64_t)&qword_1EBCC61F0;
  sub_1CD49E708(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6150);
}

uint64_t sub_1CD49E708(_WORD *a1, long long *a2, _DWORD **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6150, "force-vector-interleave", 0x17uLL);
  word_1EBCC615A = (32 * (*a1 & 3)) | word_1EBCC615A & 0xFF9F;
  xmmword_1EBCC6170 = *a2;
  uint64_t v6 = *a3;

  return sub_1CC0777B8((uint64_t)&qword_1EBCC61D0, &qword_1EBCC6150, v6);
}

void sub_1CD49E790(_WORD *a1, long long *a2, _DWORD **a3, int **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6210, 0, 0);
  byte_1EBCC62A4 = 0;
  qword_1EBCC6290 = 0;
  unk_1EBCC6298 = &unk_1F25EA1B0;
  qword_1EBCC6210 = (uint64_t)&unk_1F26050E8;
  qword_1EBCC62A8 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC62B0 = (uint64_t)&unk_1F2605150;
  qword_1EBCC62C8 = (uint64_t)&qword_1EBCC62B0;
  sub_1CD49E890(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6210);
}

uint64_t sub_1CD49E890(_WORD *a1, long long *a2, _DWORD **a3, int **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6210, "runtime-memory-check-threshold", 0x1EuLL);
  word_1EBCC621A = (32 * (*a1 & 3)) | word_1EBCC621A & 0xFF9F;
  xmmword_1EBCC6230 = *a2;
  uint64_t result = sub_1CC0777B8((uint64_t)&qword_1EBCC6290, &qword_1EBCC6210, *a3);
  int v9 = **a4;
  *(_DWORD *)qword_1EBCC6290 = v9;
  byte_1EBCC62A4 = 1;
  dword_1EBCC62A0 = v9;
  return result;
}

void sub_1CD49E934(_WORD *a1, long long *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCC6390, 0, 0);
  dword_1EBCC6410 = 0;
  qword_1EBCC6418 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC6420 = 0;
  qword_1EBCC6390 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC6428 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC6430 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC6448 = (uint64_t)&qword_1EBCC6430;
  llvm::cl::Option::setArgStr(v6, "max-dependences", 0xFuLL);
  word_1EBCC639A = (32 * (*a1 & 3)) | word_1EBCC639A & 0xFF9F;
  xmmword_1EBCC63B0 = *a2;
  dword_1EBCC6410 = **a3;
  byte_1EBCC6424 = 1;
  dword_1EBCC6420 = dword_1EBCC6410;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6390);
}

void sub_1CD49EA5C(_WORD *a1, __n128 *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6510, 0, 0);
  byte_1EBCC6590 = 0;
  qword_1EBCC6598 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC65A0 = 0;
  qword_1EBCC6510 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC65A8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC65B0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC65C8 = (uint64_t)&qword_1EBCC65B0;
  sub_1CD49EB4C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6510);
}

__n128 sub_1CD49EB4C(_WORD *a1, __n128 *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6510, "store-to-load-forwarding-conflict-detection", 0x2BuLL);
  word_1EBCC651A = (32 * (*a1 & 3)) | word_1EBCC651A & 0xFF9F;
  __n128 result = *a2;
  xmmword_1EBCC6530 = (__int128)*a2;
  unsigned int v7 = *a3;
  byte_1EBCC6590 = **a3;
  byte_1EBCC65A1 = 1;
  byte_1EBCC65A0 = *v7;
  return result;
}

uint64_t sub_1CD49EBD4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v9[0] = a2;
  v9[1] = a3;
  int v10 = a4;
  unint64_t v5 = sub_1CD483108(a1, (unint64_t)v9);
  uint64_t v6 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 8);
  long long v7 = *(_OWORD *)v5;
  *(void *)(v6 + 16) = *(void *)(v5 + 16);
  *(_OWORD *)uint64_t v6 = v7;
  LODWORD(v6) = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v6;
  return *(void *)a1 + 24 * v6 - 24;
}

uint64_t sub_1CD49EC44(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = a2 + 16;
    uint64_t v3 = *(void **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v6 = (_DWORD *)(a2 + 8);
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7 < v5)
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v7)
        {
          uint64_t v15 = &v3[2 * v7];
          uint64_t v16 = *(void **)a1;
          do
          {
            *uint64_t v16 = *v3;
            v16[1] = v3[1];
            v3 += 2;
            v16 += 2;
          }
          while (v3 != v15);
        }
        else
        {
          uint64_t v7 = 0;
        }
        if (v7 != v5) {
          memcpy((void *)(*(void *)a1 + 16 * v7), (const void *)(*(void *)a2 + 16 * v7), *(void *)a2 + 16 * v5 - (*(void *)a2 + 16 * v7));
        }
      }
      else if (v5)
      {
        int v13 = &v3[2 * v5];
        uint64_t v14 = *(void **)a1;
        do
        {
          void *v14 = *v3;
          v14[1] = v3[1];
          v3 += 2;
          v14 += 2;
        }
        while (v3 != v13);
      }
      *(_DWORD *)(a1 + 8) = v5;
    }
    else
    {
      int v10 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v10);
        uint64_t v3 = *(void **)a2;
      }
      *(void *)a1 = v3;
      uint64_t v11 = a2;
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v6 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = v12;
      *(void *)uint64_t v11 = v4;
      *(_DWORD *)(v11 + 12) = 0;
    }
    *uint64_t v6 = 0;
  }
  return a1;
}

unint64_t sub_1CD49EDB0(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 48 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD49EE1C();
    }
    sub_1CD49EE1C();
  }
  return a2;
}

void sub_1CD49EE1C()
{
}

void sub_1CD49EE90(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a1;
    uint64_t v7 = *a1 + 48 * v2;
    do
    {
      uint64_t v8 = v6 + v5;
      uint64_t v9 = a2 + v5;
      *(_OWORD *)uint64_t v9 = *(_OWORD *)(v6 + v5);
      *(void *)(a2 + v5 + 16) = a2 + v5 + 32;
      *(void *)(v9 + 24) = 0x200000000;
      if (*(_DWORD *)(v6 + v5 + 24)) {
        sub_1CC0778D4(a2 + v5 + 16, v8 + 16);
      }
      *(_DWORD *)(v9 + 40) = *(_DWORD *)(v8 + 40);
      v5 += 48;
    }
    while (v8 + 48 != v7);
    uint64_t v10 = *((unsigned int *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = 48 * v10;
      do
      {
        int v13 = *(void **)(v11 + v12 - 32);
        if ((void *)(v11 + v12 - 16) != v13) {
          free(v13);
        }
        v12 -= 48;
      }
      while (v12);
    }
  }
}

uint64_t sub_1CD49EF74(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD49EDB0(a1, a2);
  uint64_t v4 = *(void *)a1;
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(void *)a1 + 48 * v5;
  *(_OWORD *)uint64_t v6 = *(_OWORD *)v3;
  *(void *)(v6 + 24) = 0x200000000;
  *(void *)(v6 + 16) = v6 + 32;
  uint64_t result = v6 + 16;
  if (*(_DWORD *)(v3 + 24)) {
    uint64_t result = sub_1CC077ABC(result, v3 + 16);
  }
  *(_DWORD *)(v4 + 48 * v5 + 40) = *(_DWORD *)(v3 + 40);
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD49EFFC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *uint64_t v7 = -4;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    unint64_t v9 = *(void *)a2;
    if (*(void *)a2 != -16 && v9 != -4)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CC077698(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *(void *)a2;
      v11[1] = 0;
      void v11[2] = 0;
      void v11[3] = 0;
      *(_OWORD *)(v11 + 1) = *(_OWORD *)(a2 + 8);
      void v11[3] = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

void *sub_1CD49F0C0(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC077838(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD49F120((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD49F120(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_3:
    sub_1CC078804(a1, v7);
    unint64_t v9 = 0;
    sub_1CC077838((uint64_t *)a1, a3, &v9);
    a4 = v9;
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD49F1D4(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *unsigned int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CC077838((uint64_t *)v5, a2, &v10);
      unint64_t v9 = v10;
      void *v10 = *a2;
      v9[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CD49F284(uint64_t a1, uint64_t *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD49F2F0(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD49F2F0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD49F3A4(a1, v6);
  uint64_t v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD49F3A4(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD49F470(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD49F470(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v13 = 0;
      sub_1CD40EA84(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v13);
      uint64_t v10 = v13;
      *int v13 = *a2;
      uint64_t v11 = a2[1];
      a2[1] = 0;
      v10[1] = v11;
      ++*(_DWORD *)(v5 + 8);
      uint64_t result = a2[1];
      a2[1] = 0;
      if (result)
      {
        uint64_t v12 = sub_1CC078A80((uint64_t *)result);
        uint64_t result = MEMORY[0x1D25D9CE0](v12, 0x10E0C402B7C74A4);
      }
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CD49F550(uint64_t a1)
{
  sub_1CC008720(v6, (void *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v5 = &unk_1F2605198;
  uint64_t v8 = v2;
  uint64_t result = (void *)sub_1CD49F6D4(v2, (uint64_t)&v5);
  if (v7 != -8192 && v7 != -4096 && v7 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(v6);
  }
  return result;
}

void sub_1CD49F5E0(uint64_t a1, uint64_t a2)
{
  sub_1CC008720(v10, (void *)(a1 + 8));
  char v4 = *(int32x2_t **)(a1 + 32);
  uint64_t v9 = &unk_1F2605198;
  uint64_t v12 = v4;
  v7[0] = 0;
  if (sub_1CD49F7A0((uint64_t *)v4, (uint64_t)&v9, v7)) {
    uint64_t v5 = v7[0];
  }
  else {
    uint64_t v5 = *(void *)v4 + 48 * v4[2].u32[0];
  }
  if (*(void *)v12 + 48 * v12[2].u32[0] != v5)
  {
    uint64_t v6 = *(unsigned int *)(v5 + 40);
    sub_1CD49F844(v12, v5);
    v8[0] = a2;
    v8[1] = v6;
    sub_1CD49F8F0((uint64_t)v12, v8, (uint64_t)v7);
  }
  if (v11 != -8192 && v11 != -4096)
  {
    if (v11) {
      llvm::ValueHandleBase::RemoveFromUseList(v10);
    }
  }
}

uint64_t sub_1CD49F6D4(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v3 = sub_1CD49F7A0((uint64_t *)a1, a2, (uint64_t *)&v8);
  if (v3)
  {
    char v4 = v8;
    v9[0] = 2;
    v9[1] = 0;
    uint64_t v10 = -8192;
    unint64_t v11 = 0;
    uint64_t v8 = (unint64_t *)&unk_1F2605198;
    sub_1CBF62D84(v4 + 1, v9);
    uint64_t v5 = v10;
    v4[4] = v11;
    if (v5 != -8192 && v5 != -4096 && v5 != 0) {
      llvm::ValueHandleBase::RemoveFromUseList(v9);
    }
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  return v3;
}

uint64_t sub_1CD49F7A0(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *(void *)(a2 + 24);
    int v6 = v3 - 1;
    unsigned int v7 = ((v5 >> 4) ^ (v5 >> 9)) & (v3 - 1);
    uint64_t v8 = *a1 + 48 * v7;
    uint64_t v9 = *(void *)(v8 + 24);
    if (v5 == v9)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v9 != -4096)
      {
        if (v10) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 == -8192;
        }
        if (v13) {
          uint64_t v10 = v8;
        }
        unsigned int v14 = v7 + v11++;
        unsigned int v7 = v14 & v6;
        uint64_t v8 = v4 + 48 * (v14 & v6);
        uint64_t v9 = *(void *)(v8 + 24);
        if (v5 == v9) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v8 = v10;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v8;
  return result;
}

int32x2_t sub_1CD49F844(int32x2_t *a1, uint64_t a2)
{
  v7[0] = 2;
  v7[1] = 0;
  uint64_t v8 = -8192;
  uint64_t v9 = 0;
  sub_1CBF62D84((unint64_t *)(a2 + 8), v7);
  uint64_t v4 = v8;
  *(void *)(a2 + 32) = v9;
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1CD49F8F0@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a2;
  uint64_t v7 = 2;
  v12[0] = 2;
  v12[1] = 0;
  uint64_t v13 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v12);
    uint64_t v7 = v12[0];
    uint64_t v6 = v13;
  }
  uint64_t v14 = a1;
  unint64_t v16 = v7 & 6;
  int v17 = 0;
  uint64_t v18 = v6;
  uint64_t v9 = a1;
  if (v6 != -8192)
  {
    BOOL v10 = v6 == -4096 || v6 == 0;
    uint64_t v9 = a1;
    if (!v10)
    {
      int v17 = *(unint64_t **)(v7 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v7 & 0xFFFFFFFFFFFFFFF8) = &v16;
      unint64_t v16 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if (v17) {
        unint64_t *v17 = *v17 & 7 | (unint64_t)&v17;
      }
      uint64_t v9 = v14;
    }
  }
  uint64_t v15 = &unk_1F2605198;
  uint64_t v19 = v9;
  int v20 = *((_DWORD *)a2 + 2);
  sub_1CD49FA80(a1, (uint64_t)&v15, &v20, (uint64_t)&v21);
  if (v18 != -8192 && v18 != -4096 && v18) {
    llvm::ValueHandleBase::RemoveFromUseList(&v16);
  }
  if (v13 != -8192 && v13 != -4096 && v13) {
    llvm::ValueHandleBase::RemoveFromUseList(v12);
  }
  double result = *(double *)&v21;
  *(_OWORD *)a3 = v21;
  *(unsigned char *)(a3 + 16) = v22;
  return result;
}

unint64_t sub_1CD49FA80@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = 0;
  unint64_t result = sub_1CD49F7A0((uint64_t *)a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = sub_1CD49FB30((uint64_t *)a1, a2, a2, v12);
    unint64_t result = sub_1CBF62D84((unint64_t *)(v9 + 8), (uint64_t *)(a2 + 8));
    *(void *)(v9 + 32) = *(void *)(a2 + 32);
    *(_DWORD *)(v9 + 40) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 48 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CD49FB30(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = *((_DWORD *)a1 + 2);
  unsigned int v5 = *((_DWORD *)a1 + 4);
  if (4 * v4 + 4 >= 3 * v5)
  {
    v5 *= 2;
  }
  else if (v5 + ~v4 - *((_DWORD *)a1 + 3) > v5 >> 3)
  {
    goto LABEL_3;
  }
  uint64_t v8 = a1;
  sub_1CD49FBE0((uint64_t)a1, v5);
  uint64_t v9 = 0;
  sub_1CD49F7A0(v8, a3, &v9);
  a1 = v8;
  a4 = v9;
LABEL_3:
  ++*((_DWORD *)a1 + 2);
  if (*(void *)(a4 + 24) != -4096) {
    --*((_DWORD *)a1 + 3);
  }
  return a4;
}

void *sub_1CD49FBE0(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(48 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CD49FCA8(a1, v4, v4 + 48 * v3);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CC078E24((void *)a1);
}

void *sub_1CD49FCA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result = sub_1CC078E24((void *)a1);
  v15[0] = 2;
  v15[1] = 0;
  uint64_t v16 = -4096;
  uint64_t v17 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = &unk_1F2605198;
  v11[0] = 2;
  v11[1] = 0;
  uint64_t v12 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = *(void *)(a2 + 24);
      if (v7 != v16 && v7 != v12)
      {
        uint64_t v18 = 0;
        sub_1CD49F7A0((uint64_t *)a1, a2, &v18);
        uint64_t v10 = v18;
        unint64_t result = (void *)sub_1CBF62D84((unint64_t *)(v18 + 8), (uint64_t *)(a2 + 8));
        *(void *)(v10 + 32) = *(void *)(a2 + 32);
        *(_DWORD *)(v10 + 40) = *(_DWORD *)(a2 + 40);
        ++*(_DWORD *)(a1 + 8);
        uint64_t v7 = *(void *)(a2 + 24);
      }
      if (v7 != -8192 && v7 != -4096 && v7 != 0) {
        unint64_t result = llvm::ValueHandleBase::RemoveFromUseList((void *)(a2 + 8));
      }
      a2 += 48;
    }
    while (a2 != a3);
    if (v12 != -8192 && v12 != -4096 && v12) {
      unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v11);
    }
  }
  if (v16 != -8192 && v16 != -4096)
  {
    if (v16) {
      return llvm::ValueHandleBase::RemoveFromUseList(v15);
    }
  }
  return result;
}

uint64_t llvm::AnalysisManager<llvm::Loop,llvm::LoopStandardAnalysisResults &>::Invalidator::invalidate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1CBF5BF34(*a1, a2);
  uint64_t v9 = *a1;
  uint64_t v10 = *a1 + 8;
  if (*(unsigned char *)*a1)
  {
    uint64_t v11 = 8;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v11 = *(unsigned int *)(v9 + 16);
  }
  if (v10 + 16 * v11 == v8)
  {
    uint64_t v13 = a1[1];
    v19[0] = a2;
    v19[1] = a3;
    uint64_t v17 = 0;
    if (sub_1CBF5C064((uint64_t *)v13, v19, &v17)) {
      uint64_t v14 = v17;
    }
    else {
      uint64_t v14 = *(void *)v13 + 24 * *(unsigned int *)(v13 + 16);
    }
    uint64_t v15 = *a1;
    char v16 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(*(void *)(v14 + 16) + 24)
                                                                         + 16))(*(void *)(*(void *)(v14 + 16) + 24), a3, a4, a1);
    uint64_t v17 = a2;
    v18[0] = v16;
    sub_1CBF5C150(v15, &v17, v18, (uint64_t)v19);
    uint64_t v8 = v19[0];
  }
  return *(unsigned __int8 *)(v8 + 8);
}

uint64_t sub_1CD49FF54(uint64_t a1, uint64_t *__p)
{
  uint64_t v3 = *__p;
  uint64_t v4 = __p[1];
  *(void *)(v3 + 8) = v4;
  *(void *)__p[1] = v3;
  --*(void *)(a1 + 16);
  uint64_t v5 = __p[3];
  __p[3] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  operator delete(__p);
  return v4;
}

unint64_t *sub_1CD49FFCC(uint64_t *a1, uint64_t a2)
{
  long long v7 = *(_OWORD *)a2;
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v3 = sub_1CD4A01F4(a1, &v7);
  unint64_t v4 = *a1;
  if ((*a1 & 4) != 0) {
    uint64_t v5 = (unint64_t *)(*(void *)(v4 & 0xFFFFFFFFFFFFFFF8)
  }
                            + 8 * *(unsigned int *)((v4 & 0xFFFFFFFFFFFFFFF8) + 8));
  else {
    uint64_t v5 = (unint64_t *)&a1[v4 > 7];
  }
  return sub_1CBFA5ABC((unint64_t *)a1, (unint64_t *)v3, v5);
}

_DWORD *sub_1CD4A0040(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      unint64_t v6 = *(int64x2_t **)result;
      uint64_t v7 = 24 * v2;
      int64x2_t v8 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *unint64_t v6 = v8;
        unint64_t v6 = (int64x2_t *)((char *)v6 + 24);
        v7 -= 24;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CBFA4FD8(v1, v5);
  }
  return result;
}

void sub_1CD4A00F4(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    int v5 = (uint64_t *)(*(void *)a1 + 8);
    do
    {
      if ((*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CC07AE64(v5);
      }
      v5 += 4;
      v4 -= 32;
    }
    while (v4);
  }
  if (v3)
  {
    int v6 = 1 << (33 - __clz(v3 - 1));
    if (v6 <= 64) {
      unsigned int v7 = 64;
    }
    else {
      unsigned int v7 = v6;
    }
    int64x2_t v8 = *(void **)a1;
    if (v7 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v9 = 32 * v7;
      do
      {
        *int64x2_t v8 = -4096;
        v8 += 4;
        v9 -= 32;
      }
      while (v9);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v7 = 0;
    int64x2_t v8 = *(void **)a1;
  }
  MEMORY[0x1D25D9CD0](v8, 8);

  sub_1CBC04C8C(a1, v7);
}

uint64_t *sub_1CD4A01F4(uint64_t *a1, long long *a2)
{
  unint64_t v2 = *a1;
  if ((*a1 & 4) != 0)
  {
    unint64_t v4 = v2 & 0xFFFFFFFFFFFFFFF8;
    a1 = *(uint64_t **)v4;
    int v3 = (uint64_t *)(*(void *)v4 + 8 * *(unsigned int *)(v4 + 8));
  }
  else
  {
    int v3 = &a1[v2 > 7];
  }
  long long v6 = *a2;
  uint64_t v7 = *((void *)a2 + 2);
  return sub_1CC07B22C(a1, v3, (uint64_t)&v6);
}

BOOL llvm::IndexedReference::isAliased(uint64_t ****this, uint64_t ****a2, llvm::AAResults *a3)
{
  llvm::MemoryLocation::getOrNone(this[1], (uint64_t)&v8);
  v7[0] = v8;
  v7[1] = v9;
  uint64_t v7[2] = v10;
  llvm::MemoryLocation::getOrNone(a2[1], (uint64_t)&v8);
  v6[0] = v8;
  v6[1] = v9;
  void v6[2] = v10;
  return llvm::AAResults::alias((uint64_t)a3, (uint64_t)v7, (uint64_t)v6) == 3;
}

uint64_t llvm::IndexedReference::isConsecutive(llvm::IndexedReference *this, const llvm::Loop *a2, unsigned int a3)
{
  int v5 = (uint64_t *)*((void *)this + 3);
  uint64_t v6 = *((unsigned int *)this + 8);
  uint64_t v7 = v5[v6 - 1];
  if (v6)
  {
    uint64_t v9 = 8 * v6;
    while (1)
    {
      uint64_t v10 = *v5;
      if (*v5 != v7)
      {
        if (*(_WORD *)(v10 + 24) == 7)
        {
          if (*(const llvm::Loop **)(v10 + 48) == a2) {
            return 0;
          }
        }
        else if (llvm::ScalarEvolution::getLoopDisposition(*((llvm::ScalarEvolution **)this + 13), (const llvm::SCEV *)v10, a2) != 1)
        {
          return 0;
        }
      }
      ++v5;
      v9 -= 8;
      if (!v9)
      {
        uint64_t v7 = *(void *)(*((void *)this + 3) + 8 * *((unsigned int *)this + 8) - 8);
        break;
      }
    }
  }
  uint64_t v11 = sub_1CBFD7EA0(v7, *((llvm::ScalarEvolution **)this + 13));
  Negativeuint64_t SCEV = (llvm::SCEV *)sub_1CBFD7CB4(*((void *)this + 13), v11, *(void *)(*((void *)this + 8) + 8 * *((unsigned int *)this + 18) - 8), 0, 0);
  uint64_t v13 = (llvm::ScalarEvolution *)*((void *)this + 13);
  Type = (llvm::Type *)llvm::SCEV::getType(NegativeSCEV);
  Constant = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(v13, Type, a3, 0);
  if (llvm::ScalarEvolution::isKnownNegative(*((llvm::ScalarEvolution **)this + 13), NegativeSCEV)) {
    Negativeuint64_t SCEV = (llvm::SCEV *)llvm::ScalarEvolution::getNegativeSCEV(*((llvm::ScalarEvolution **)this + 13), (uint64_t)NegativeSCEV, 0);
  }
  char v16 = (llvm::ScalarEvolution *)*((void *)this + 13);

  return llvm::ScalarEvolution::isKnownPredicate(v16, 0x24u, NegativeSCEV, Constant);
}

BOOL llvm::IndexedReference::isSimpleAddRecurrence(llvm::ScalarEvolution **this, const llvm::SCEV *a2, const llvm::Loop *a3)
{
  if (*((_WORD *)a2 + 12) == 7
    && *((void *)a2 + 5) == 2
    && (int v5 = (const llvm::SCEV *)**((void **)a2 + 4),
        uint64_t v6 = (const llvm::SCEV *)sub_1CBFD7EA0((uint64_t)a2, this[13]),
        llvm::ScalarEvolution::getLoopDisposition(this[13], v5, a3) == 1))
  {
    return llvm::ScalarEvolution::getLoopDisposition(this[13], v6, a3) == 1;
  }
  else
  {
    return 0;
  }
}

uint64_t llvm::CacheCost::CacheCost(uint64_t a1, uint64_t a2, uint64_t a3, llvm::ScalarEvolution *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x800000000;
  if (*(_DWORD *)(a2 + 8)) {
    llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=(a1, a2);
  }
  *(void *)(a1 + 80) = a1 + 96;
  *(void *)(a1 + 88) = 0x300000000;
  *(void *)(a1 + 144) = a1 + 160;
  *(void *)(a1 + 152) = 0x300000000;
  if ((a8 & 0xFF00000000) != 0)
  {
    *(void *)(a1 + 208) = a8;
  }
  else
  {
    *(_DWORD *)(a1 + 208) = dword_1EBCC6710;
    *(unsigned char *)(a1 + 212) = 1;
  }
  *(void *)(a1 + 216) = a3;
  *(void *)(a1 + 224) = a4;
  *(void *)(a1 + 232) = a5;
  *(void *)(a1 + 240) = a6;
  *(void *)(a1 + 248) = a7;
  uint64_t v16 = *(unsigned int *)(a2 + 8);
  if (v16)
  {
    uint64_t v18 = *(const llvm::Loop ***)a2;
    uint64_t v19 = 8 * v16;
    do
    {
      int v20 = *v18;
      unsigned int SmallConstantTripCount = llvm::ScalarEvolution::getSmallConstantTripCount(a4, *v18);
      if (SmallConstantTripCount) {
        char v22 = (const llvm::Loop *)SmallConstantTripCount;
      }
      else {
        char v22 = (const llvm::Loop *)dword_1EBCC6650;
      }
      unint64_t v23 = *(unsigned int *)(a1 + 88);
      if (v23 >= *(unsigned int *)(a1 + 92)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      size_t v24 = (const llvm::Loop **)(*(void *)(a1 + 80) + 16 * v23);
      llvm::raw_ostream *v24 = v20;
      v24[1] = v22;
      ++*(_DWORD *)(a1 + 88);
      ++v18;
      v19 -= 8;
    }
    while (v19);
  }
  llvm::CacheCost::calculateCacheFootprint((llvm::CacheCost *)a1);
  return a1;
}

void llvm::CacheCost::calculateCacheFootprint(llvm::CacheCost *this)
{
  v12[80] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = v12;
  uint64_t v11 = 0x800000000;
  if (llvm::CacheCost::populateReferenceGroups((uint64_t)this, (uint64_t)&v10))
  {
    if (*((_DWORD *)this + 2)) {
      llvm::CacheCost::computeLoopCacheCost((int)this, **(llvm::Loop ***)this);
    }
    unsigned int v5 = *((_DWORD *)this + 38);
    unint64_t v6 = 126 - 2 * __clz(v5);
    if (v5) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0;
    }
    sub_1CD4A11CC(*((uint64_t **)this + 18), (uint64_t *)(*((void *)this + 18) + 16 * v5), v7, 1);
    unint64_t v2 = v10;
    if (v11)
    {
      uint64_t v8 = 80 * v11;
      uint64_t v9 = (char *)v10 - 80;
      do
      {
        sub_1CD4A28E0((char **)&v9[v8]);
        v8 -= 80;
      }
      while (v8);
      unint64_t v2 = v10;
    }
    LODWORD(v11) = 0;
  }
  else
  {
    unint64_t v2 = v10;
    if (v11)
    {
      uint64_t v3 = 80 * v11;
      unint64_t v4 = (char *)v10 - 80;
      do
      {
        sub_1CD4A28E0((char **)&v4[v3]);
        v3 -= 80;
      }
      while (v3);
      unint64_t v2 = v10;
    }
  }
  if (v2 != v12) {
    free(v2);
  }
}

void llvm::CacheCost::getCacheCost(void *a1@<X0>, void *a2@<X8>)
{
  v8[8] = *MEMORY[0x1E4F143B8];
  if (*a1)
  {
    *a2 = 0;
  }
  else
  {
    unint64_t v6 = (void **)v8;
    uint64_t v7 = 0x800000000;
    unint64_t v4 = a1;
    sub_1CC07C66C((uint64_t *)&v4, (uint64_t)v5);
    sub_1CD4A0A40((uint64_t)&v6, (llvm::SmallPtrSetImplBase *)v5);
    sub_1CD4A1090((uint64_t)v5);
    uint64_t v3 = v6;
    if (sub_1CC07C738(v6, v7)) {
      operator new();
    }
    *a2 = 0;
    if (v3 != v8) {
      free(v3);
    }
  }
}

void sub_1CD4A0A40(uint64_t a1, llvm::SmallPtrSetImplBase *a2)
{
  uint64_t v4 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 8);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v10, &v12, a2);
  sub_1CD4A223C((uint64_t)v13, (void *)a2 + 12);
  int v14 = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v5, &v7, (llvm::SmallPtrSetImplBase *)((char *)a2 + 152));
  sub_1CD4A223C((uint64_t)v8, (void *)a2 + 31);
  int v9 = *((_DWORD *)a2 + 74);
  sub_1CD4A1AF4(a1, v4, (llvm::SmallPtrSetImplBase *)&v10, &v5);
  sub_1CC07C814(v8);
  if (v6 != v5) {
    free(v6);
  }
  sub_1CC07C814(v13);
  if (v11 != v10) {
    free(v11);
  }
}

BOOL llvm::CacheCost::populateReferenceGroups(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(***(void ***)(a1 + 232) + 760))(**(void **)(a1 + 232));
  uint64_t v3 = sub_1CC07C738(*(void ***)a1, *(_DWORD *)(a1 + 8));
  uint64_t v4 = v3[4];
  for (uint64_t i = v3[5]; v4 != i; v4 += 8)
  {
    for (uint64_t j = *(void *)(*(void *)v4 + 48); j != *(void *)v4 + 40; uint64_t j = *(void *)(j + 8))
    {
      if (j) {
        uint64_t v6 = j - 24;
      }
      else {
        uint64_t v6 = 0;
      }
      if ((*(unsigned char *)(v6 + 16) & 0xFE) == 0x3C) {
        operator new();
      }
    }
  }
  return *(_DWORD *)(a2 + 8) != 0;
}

void llvm::CacheCost::computeLoopCacheCost(int a1, llvm::Loop *this)
{
}

uint64_t sub_1CD4A0EC0(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  unint64_t v3 = *(void *)result;
  if (v2 >= *(_DWORD *)(result + 12))
  {
    unint64_t v6 = v3 + 8 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD4A280C();
    }
    sub_1CD4A280C();
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(v3 + 8 * v4) = v5;
  *(_DWORD *)(result + 8) = v4 + 1;
  return result;
}

void *sub_1CD4A0F48(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD4A294C(a1, a2);
  unint64_t result = (void *)(*(void *)a1 + 80 * *(unsigned int *)(a1 + 8));
  *unint64_t result = result + 2;
  result[1] = 0x800000000;
  if (*(_DWORD *)(v3 + 8)) {
    unint64_t result = (void *)sub_1CD4A2AD8((uint64_t)result, v3);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

double llvm::LoopCachePrinterPass::run@<D0>(llvm::raw_ostream **a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v6 = *(void *)(**(void **)(a2 + 32) + 56);
  v10[1] = *(void *)a3;
  int8x16_t v11 = vextq_s8(*(int8x16_t *)(a3 + 24), *(int8x16_t *)(a3 + 24), 8uLL);
  uint64_t v12 = v6;
  llvm::CacheCost::getCacheCost((void *)a2, v10);
  uint64_t v7 = v10[0];
  if (v10[0])
  {
    llvm::operator<<(*a1, v10[0]);
    uint64_t v9 = sub_1CD4A27AC(v7);
    MEMORY[0x1D25D9CE0](v9, 0x10E0C40BBC1AD8BLL);
  }
  *(void *)(a4 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a4 = a4 + 32;
  *(void *)(a4 + 8) = a4 + 32;
  *(_DWORD *)(a4 + 24) = 0;
  *(void *)(a4 + 48) = a4 + 80;
  *(void *)(a4 + 56) = a4 + 80;
  *(void *)(a4 + 64) = 2;
  *(_DWORD *)(a4 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a4 + 16) = 0x100000002;
  return result;
}

uint64_t sub_1CD4A1090(uint64_t a1)
{
  sub_1CC07C814((void **)(a1 + 248));
  uint64_t v2 = *(void **)(a1 + 160);
  if (v2 != *(void **)(a1 + 152)) {
    free(v2);
  }
  sub_1CC07C814((void **)(a1 + 96));
  unint64_t v3 = *(void **)(a1 + 8);
  if (v3 != *(void **)a1) {
    free(v3);
  }
  return a1;
}

void sub_1CD4A10E4(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  unint64_t v3 = a1[2] - (void)v2;
  if (v3)
  {
    uint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 >> 7];
    uint64_t v7 = (uint64_t)*v6;
    uint64_t v8 = (uint64_t)*v6 + 32 * (v5 & 0x7F);
    uint64_t v9 = *(uint64_t *)((char *)v2 + (((a1[5] + v5) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((a1[5] + v5) & 0x7F);
    while (v8 != v9)
    {
      if (*(unsigned char *)(v8 + 24)) {
        *(unsigned char *)(v8 + 24) = 0;
      }
      v8 += 32;
      if (v8 - v7 == 4096)
      {
        uint64_t v10 = (uint64_t)v6[1];
        ++v6;
        uint64_t v7 = v10;
        uint64_t v8 = v10;
      }
    }
  }
  else
  {
    uint64_t v4 = a1 + 5;
  }
  *uint64_t v4 = 0;
  if (v3 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v11 = a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v3 = v11 - (void)v2;
    }
    while (v3 > 0x10);
  }
  if (v3 >> 3 == 1)
  {
    uint64_t v12 = 64;
  }
  else
  {
    if (v3 >> 3 != 2) {
      return;
    }
    uint64_t v12 = 128;
  }
  a1[4] = v12;
}

uint64_t *sub_1CD4A11CC(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
LABEL_2:
  while (2)
  {
    for (uint64_t i = 1 - a3; ; ++i)
    {
      uint64_t v11 = (char *)a2 - (char *)v9;
      unint64_t v12 = ((char *)a2 - (char *)v9) >> 4;
      if (!(!v5 & v4))
      {
        switch(v12)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v22 = *(a2 - 1);
            uint64_t v23 = v9[1];
            if (v22 > v23)
            {
              uint64_t v24 = *v9;
              *uint64_t v9 = *(a2 - 2);
              v9[1] = v22;
              *(a2 - 2) = v24;
              *(a2 - 1) = v23;
            }
            break;
          case 3uLL:
            double result = sub_1CC07C8A4(v9, v9 + 2, a2 - 2);
            break;
          case 4uLL:
            double result = sub_1CC07CC6C(v9, v9 + 2, v9 + 4, a2 - 2);
            break;
          case 5uLL:
            double result = sub_1CC07CD0C(v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v11 <= 383)
      {
        uint64_t v25 = v9 + 2;
        BOOL v27 = v9 == a2 || v25 == a2;
        if (a4)
        {
          if (!v27)
          {
            uint64_t v28 = 0;
            uint64_t v29 = v9;
            do
            {
              uint64_t v30 = v29[3];
              uint64_t v31 = v29[1];
              uint64_t v29 = v25;
              if (v30 > v31)
              {
                uint64_t v32 = *v25;
                uint64_t v33 = v28;
                while (1)
                {
                  uint64_t v34 = (char *)v9 + v33;
                  uint64_t v35 = *(uint64_t *)((char *)v9 + v33 + 8);
                  *((void *)v34 + 2) = *(uint64_t *)((char *)v9 + v33);
                  *((void *)v34 + 3) = v35;
                  if (!v33) {
                    break;
                  }
                  v33 -= 16;
                  if (v30 <= *((void *)v34 - 1))
                  {
                    uint64_t v36 = (uint64_t *)((char *)v9 + v33 + 16);
                    goto LABEL_45;
                  }
                }
                uint64_t v36 = v9;
LABEL_45:
                *uint64_t v36 = v32;
                v36[1] = v30;
              }
              uint64_t v25 = v29 + 2;
              v28 += 16;
            }
            while (v29 + 2 != a2);
          }
        }
        else if (!v27)
        {
          BOOL v37 = v9 + 3;
          do
          {
            uint64_t v38 = v9[3];
            uint64_t v39 = v9[1];
            uint64_t v9 = v25;
            if (v38 > v39)
            {
              uint64_t v40 = *v25;
              int v41 = v37;
              do
              {
                int v42 = v41;
                uint64_t v43 = *(v41 - 4);
                *(v41 - 1) = *(v41 - 3);
                uint64_t v44 = *(v41 - 2);
                v41 -= 2;
                uint64_t *v42 = v44;
              }
              while (v38 > v43);
              *(v41 - 1) = v40;
              *int v41 = v38;
            }
            uint64_t v25 = v9 + 2;
            v37 += 2;
          }
          while (v9 + 2 != a2);
        }
        return result;
      }
      if (i == 1)
      {
        if (v9 != a2)
        {
          return (uint64_t *)sub_1CC07CDDC((uint64_t)v9, a2, a2);
        }
        return result;
      }
      unint64_t v13 = v12 >> 1;
      int v14 = &v9[2 * (v12 >> 1)];
      if ((unint64_t)v11 >= 0x801)
      {
        sub_1CC07C8A4(v9, &v9[2 * (v12 >> 1)], a2 - 2);
        sub_1CC07C8A4(v9 + 2, v14 - 2, a2 - 4);
        sub_1CC07C8A4(v9 + 4, &v9[2 * v13 + 2], a2 - 6);
        sub_1CC07C8A4(v14 - 2, v14, &v9[2 * v13 + 2]);
        uint64_t v15 = *v9;
        uint64_t v16 = v9[1];
        uint64_t v17 = v14[1];
        *uint64_t v9 = *v14;
        v9[1] = v17;
        uint64_t *v14 = v15;
        v14[1] = v16;
      }
      else
      {
        sub_1CC07C8A4(&v9[2 * (v12 >> 1)], v9, a2 - 2);
      }
      if ((a4 & 1) == 0 && *(v9 - 1) <= v9[1])
      {
        double result = sub_1CC07C938(v9, a2);
        long long v21 = result;
        goto LABEL_15;
      }
      uint64_t v18 = sub_1CC07CA08(v9, a2);
      if ((v19 & 1) == 0) {
        goto LABEL_62;
      }
      BOOL v20 = sub_1CC07CAD8(v9, v18);
      long long v21 = v18 + 2;
      double result = (uint64_t *)sub_1CC07CAD8(v18 + 2, a2);
      if (result) {
        break;
      }
      if (!v20)
      {
LABEL_62:
        a3 = -i;
        double result = (uint64_t *)sub_1CD4A11CC(v9, v18, -i, a4 & 1);
        a4 = 0;
        uint64_t v9 = v18 + 2;
        goto LABEL_2;
      }
LABEL_15:
      uint64_t v9 = v21;
    }
    a3 = -i;
    a2 = v18;
    if (!v20) {
      continue;
    }
    return result;
  }
}

void sub_1CD4A15A8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v25 = v30;
  uint64_t v7 = *(const void **)a1;
  uint64_t v6 = *(const void **)(a1 + 8);
  if (v6 == *(const void **)a1)
  {
    uint64_t v26 = v30;
    uint64_t v8 = *(unsigned int *)(a1 + 20);
    if (v8) {
      memmove(v30, v6, 8 * v8);
    }
  }
  else
  {
    uint64_t v26 = *(unsigned char **)(a1 + 8);
    *(void *)(a1 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a1 + 20);
  }
  int v27 = *(_DWORD *)(a1 + 16);
  int v28 = v8;
  int v29 = *(_DWORD *)(a1 + 24);
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  long long v31 = *(_OWORD *)(a1 + 96);
  uint64_t v9 = *(void *)(a1 + 120);
  uint64_t v32 = *(void *)(a1 + 112);
  uint64_t v33 = v9;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  long long v34 = *(_OWORD *)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  int v35 = *(_DWORD *)(a1 + 144);
  int v14 = v19;
  uint64_t v11 = *(const void **)a2;
  uint64_t v10 = *(const void **)(a2 + 8);
  if (v10 == *(const void **)a2)
  {
    uint64_t v15 = v19;
    uint64_t v12 = *(unsigned int *)(a2 + 20);
    if (v12) {
      memmove(v19, v10, 8 * v12);
    }
  }
  else
  {
    uint64_t v15 = *(unsigned char **)(a2 + 8);
    *(void *)(a2 + 8) = v11;
    LODWORD(v12) = *(_DWORD *)(a2 + 20);
  }
  int v16 = *(_DWORD *)(a2 + 16);
  int v17 = v12;
  int v18 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  long long v20 = *(_OWORD *)(a2 + 96);
  uint64_t v13 = *(void *)(a2 + 120);
  uint64_t v21 = *(void *)(a2 + 112);
  uint64_t v22 = v13;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  long long v23 = *(_OWORD *)(a2 + 128);
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  int v24 = *(_DWORD *)(a2 + 144);
  sub_1CD4A1748(a3, (uint64_t)&v25, (uint64_t)&v14);
  sub_1CC07C814((void **)&v20);
  if (v15 != v14) {
    free(v15);
  }
  sub_1CC07C814((void **)&v31);
  if (v26 != v25) {
    free(v26);
  }
}

uint64_t sub_1CD4A1748(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)a2);
  *(void *)(v6 + 96) = *(void *)(a2 + 96);
  *(void *)(v6 + 104) = *(void *)(a2 + 104);
  *(void *)(v6 + 112) = *(void *)(a2 + 112);
  *(void *)(v6 + 120) = *(void *)(a2 + 120);
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(void *)(v6 + 128) = *(void *)(a2 + 128);
  *(void *)(v6 + 136) = *(void *)(a2 + 136);
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(_DWORD *)(v6 + 144) = *(_DWORD *)(a2 + 144);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(v6 + 152, (void *)(a1 + 184), 8, (uint64_t *)a3);
  *(void *)(a1 + 248) = *(void *)(a3 + 96);
  *(void *)(a1 + 256) = *(void *)(a3 + 104);
  *(void *)(a1 + 264) = *(void *)(a3 + 112);
  *(void *)(a1 + 272) = *(void *)(a3 + 120);
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(void *)(a1 + 280) = *(void *)(a3 + 128);
  *(void *)(a1 + 288) = *(void *)(a3 + 136);
  *(void *)(a3 + 128) = 0;
  *(void *)(a3 + 136) = 0;
  *(_DWORD *)(a1 + 296) = *(_DWORD *)(a3 + 144);
  return a1;
}

uint64_t sub_1CD4A1828(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  char v4 = (void *)(a1 + 96);
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  *(_DWORD *)(a1 + 144) = 0;
  *(void *)&long long v6 = a2;
  BYTE8(v6) = 0;
  char v7 = 0;
  char v8 = 1;
  sub_1CD4A18C8(v4, &v6);
  LOBYTE(v6) = 0;
  char v8 = 0;
  sub_1CD4A18C8(v4, &v6);
  return a1;
}

void sub_1CD4A18C8(void *a1, long long *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1CD4A197C((uint64_t)a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[4] + a1[5];
  }
  uint64_t v8 = *(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F);
  *(unsigned char *)uint64_t v8 = 0;
  *(unsigned char *)(v8 + 24) = 0;
  if (*((unsigned char *)a2 + 24))
  {
    long long v9 = *a2;
    *(void *)(v8 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    *(unsigned char *)(v8 + 24) = 1;
  }
  ++a1[5];
}

void sub_1CD4A197C(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
LABEL_4:
    uint64_t v5 = *(void **)(a1 + 8);
    *(void *)&long long v18 = *v5;
    *(void *)(a1 + 8) = v5 + 1;
    sub_1CB904CD8(a1, &v18);
    return;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = v6 - *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = v8 - *(void *)a1;
  if (v7 < v9)
  {
    if (v8 != v6)
    {
      *(void *)&long long v18 = operator new(0x1000uLL);
      sub_1CD3F23B4(a1, &v18);
      return;
    }
    *(void *)&long long v18 = operator new(0x1000uLL);
    sub_1CD3F24DC((void **)a1, &v18);
    goto LABEL_4;
  }
  if (v8 == *(void *)a1) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v9 >> 2;
  }
  uint64_t v20 = a1 + 24;
  if (v10 >> 61) {
    sub_1CB833614();
  }
  *(void *)&long long v18 = operator new(8 * v10);
  *((void *)&v18 + 1) = v18 + v7;
  *(void *)&long long v19 = v18 + v7;
  *((void *)&v19 + 1) = v18 + 8 * v10;
  int v17 = operator new(0x1000uLL);
  sub_1CD3F23B4((uint64_t)&v18, &v17);
  uint64_t v11 = *(char **)(a1 + 16);
  if (v11 == *(char **)(a1 + 8))
  {
    uint64_t v12 = *(char **)(a1 + 16);
  }
  else
  {
    do
    {
      v11 -= 8;
      sub_1CD3F24DC((void **)&v18, v11);
    }
    while (v11 != *(char **)(a1 + 8));
    uint64_t v12 = *(char **)(a1 + 16);
  }
  uint64_t v13 = *(void **)a1;
  long long v14 = v18;
  long long v15 = v19;
  *(void *)&long long v18 = *(void *)a1;
  *((void *)&v18 + 1) = v11;
  uint64_t v16 = *(void *)(a1 + 24);
  *(_OWORD *)a1 = v14;
  *(_OWORD *)(a1 + 16) = v15;
  *(void *)&long long v19 = v12;
  *((void *)&v19 + 1) = v16;
  if (v12 != v11) {
    *(void *)&long long v19 = &v12[(v11 - v12 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v13) {
    operator delete(v13);
  }
}

char *sub_1CD4A1AF4(uint64_t a1, uint64_t a2, llvm::SmallPtrSetImplBase *a3, _DWORD *a4)
{
  uint64_t v7 = (a2 - *(void *)a1) >> 3;
  uint64_t v8 = (void *)((char *)a3 + 96);
  uint64_t v9 = a4 + 24;
  if (*(void *)a1 + 8 * *(unsigned int *)(a1 + 8) == a2)
  {
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v64, &v66, a3);
    sub_1CD4A223C((uint64_t)v67, v8);
    int v68 = *((_DWORD *)a3 + 36);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v59, &v61, (const llvm::SmallPtrSetImplBase *)a4);
    sub_1CD4A223C((uint64_t)v62, v9);
    int v63 = a4[36];
    sub_1CD4A1F24(a1, (llvm::SmallPtrSetImplBase *)&v64, (uint64_t)&v59);
    sub_1CC07C814(v62);
    if (v60 != v59) {
      free(v60);
    }
    sub_1CC07C814(v67);
    if (v65 != v64) {
      free(v65);
    }
    return (char *)(*(void *)a1 + 8 * v7);
  }
  else
  {
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v54, &v56, a3);
    sub_1CD4A223C((uint64_t)v57, v8);
    int v58 = *((_DWORD *)a3 + 36);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v50, &v52, (const llvm::SmallPtrSetImplBase *)a4);
    uint64_t v12 = (void **)sub_1CD4A223C((uint64_t)v53, v9);
    v53[12] = a4[36];
    sub_1CC07C814(v12);
    if (v51 != v50) {
      free(v51);
    }
    sub_1CC07C814(v57);
    if (v55 != v54) {
      free(v55);
    }
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v45, &v47, a3);
    sub_1CD4A223C((uint64_t)v48, v8);
    int v49 = *((_DWORD *)a3 + 36);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v40, &v42, (const llvm::SmallPtrSetImplBase *)a4);
    sub_1CD4A223C((uint64_t)v43, v9);
    int v44 = a4[36];
    unint64_t v13 = sub_1CC07D070((uint64_t)&v45, (uint64_t)&v40);
    sub_1CC07C814(v43);
    if (v41 != v40) {
      free(v41);
    }
    sub_1CC07C814(v48);
    if (v46 != v45) {
      free(v46);
    }
    uint64_t v14 = *(unsigned int *)(a1 + 8);
    if (v13 + v14 > *(unsigned int *)(a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v15 = *(void *)a1;
    unint64_t v10 = (char *)(*(void *)a1 + 8 * v7);
    uint64_t v16 = (char *)(*(void *)a1 + 8 * v14);
    unint64_t v17 = (v16 - v10) >> 3;
    if (v17 >= v13)
    {
      uint64_t v21 = &v16[-8 * v13];
      sub_1CD4570C8(a1, v21, (char *)(*(void *)a1 + 8 * v14));
      if (v21 != v10) {
        memmove(&v16[-(v21 - v10)], v10, v21 - v10);
      }
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)v36, &v37, a3);
      sub_1CD4A223C((uint64_t)v38, v8);
      int v39 = *((_DWORD *)a3 + 36);
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v31, &v33, (const llvm::SmallPtrSetImplBase *)a4);
      sub_1CD4A223C((uint64_t)v34, v9);
      int v35 = a4[36];
      sub_1CC07D328((uint64_t)v36, (uint64_t)&v31, v10);
      sub_1CC07C814(v34);
      if (v32 != v31) {
        free(v32);
      }
      sub_1CC07C814(v38);
      uint64_t v20 = (void *)v36[0];
      long long v19 = (void *)v36[1];
    }
    else
    {
      *(_DWORD *)(a1 + 8) = v14 + v13;
      if (v7 != v14)
      {
        memcpy((void *)(v15 + 8 * (v14 + v13) - 8 * v17), v10, v16 - v10);
        long long v18 = v10;
        do
        {
          *(void *)long long v18 = *(void *)(*(void *)(*((void *)a3 + 13)
                                                 + ((*((void *)a3 + 16) >> 4) & 0xFFFFFFFFFFFFFF8))
                                     + 32 * (*((void *)a3 + 16) & 0x7FLL));
          v18 += 8;
          sub_1CD4A2600(a3);
          --v17;
        }
        while (v17);
      }
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)v27, &v28, a3);
      sub_1CD4A223C((uint64_t)v29, v8);
      int v30 = *((_DWORD *)a3 + 36);
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v22, &v24, (const llvm::SmallPtrSetImplBase *)a4);
      sub_1CD4A223C((uint64_t)v25, v9);
      int v26 = a4[36];
      sub_1CD4A2164((llvm::SmallPtrSetImplBase *)v27, (uint64_t)&v22, v16);
      sub_1CC07C814(v25);
      if (v23 != v22) {
        free(v23);
      }
      sub_1CC07C814(v29);
      uint64_t v20 = (void *)v27[0];
      long long v19 = (void *)v27[1];
    }
    if (v19 != v20) {
      free(v19);
    }
  }
  return v10;
}

void sub_1CD4A1F24(uint64_t a1, llvm::SmallPtrSetImplBase *a2, uint64_t a3)
{
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v32, &v34, a2);
  sub_1CD4A223C((uint64_t)v35, (void *)a2 + 12);
  int v36 = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v28, &v30, (const llvm::SmallPtrSetImplBase *)a3);
  uint64_t v6 = (void **)sub_1CD4A223C((uint64_t)v31, (void *)(a3 + 96));
  v31[12] = *(_DWORD *)(a3 + 144);
  sub_1CC07C814(v6);
  if (v29 != v28) {
    free(v29);
  }
  sub_1CC07C814(v35);
  if (v33 != v32) {
    free(v33);
  }
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v23, &v25, a2);
  sub_1CD4A223C((uint64_t)v26, (void *)a2 + 12);
  int v27 = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v18, &v20, (const llvm::SmallPtrSetImplBase *)a3);
  sub_1CD4A223C((uint64_t)v21, (void *)(a3 + 96));
  int v22 = *(_DWORD *)(a3 + 144);
  uint64_t v7 = sub_1CC07D070((uint64_t)&v23, (uint64_t)&v18);
  sub_1CC07C814(v21);
  if (v19 != v18) {
    free(v19);
  }
  sub_1CC07C814(v26);
  if (v24 != v23) {
    free(v24);
  }
  if (v7 + (unint64_t)*(unsigned int *)(a1 + 8) > *(unsigned int *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v13, &v15, a2);
  sub_1CD4A223C((uint64_t)v16, (void *)a2 + 12);
  int v17 = *((_DWORD *)a2 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v8, &v10, (const llvm::SmallPtrSetImplBase *)a3);
  sub_1CD4A223C((uint64_t)v11, (void *)(a3 + 96));
  int v12 = *(_DWORD *)(a3 + 144);
  sub_1CD4A2164((llvm::SmallPtrSetImplBase *)&v13, (uint64_t)&v8, (void *)(*(void *)a1 + 8 * *(unsigned int *)(a1 + 8)));
  sub_1CC07C814(v11);
  if (v9 != v8) {
    free(v9);
  }
  sub_1CC07C814(v16);
  if (v14 != v13) {
    free(v14);
  }
  *(_DWORD *)(a1 + 8) += v7;
}

void sub_1CD4A2164(llvm::SmallPtrSetImplBase *a1, uint64_t a2, void *a3)
{
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v11, &v13, a1);
  sub_1CD4A223C((uint64_t)v14, (void *)a1 + 12);
  int v15 = *((_DWORD *)a1 + 36);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v6, &v8, (const llvm::SmallPtrSetImplBase *)a2);
  sub_1CD4A223C((uint64_t)v9, (void *)(a2 + 96));
  int v10 = *(_DWORD *)(a2 + 144);
  sub_1CC07EB80((uint64_t)&v11, (uint64_t)&v6, a3);
  sub_1CC07C814(v9);
  if (v7 != v6) {
    free(v7);
  }
  sub_1CC07C814(v14);
  if (v12 != v11) {
    free(v12);
  }
}

uint64_t sub_1CD4A223C(uint64_t a1, void *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v4 = a2[4];
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  uint64_t v7 = (char *)(v5 + 8 * (v4 >> 7));
  if (v6 == v5)
  {
    uint64_t v8 = 0;
    uint64_t v11 = 0;
    int v10 = (char *)(v5 + 8 * ((a2[5] + v4) >> 7));
  }
  else
  {
    uint64_t v8 = (long long *)(*(void *)v7 + 32 * (v4 & 0x7F));
    unint64_t v9 = a2[5] + v4;
    int v10 = (char *)(v5 + 8 * (v9 >> 7));
    uint64_t v11 = *(void *)v10 + 32 * (v9 & 0x7F);
  }
  if ((long long *)v11 == v8) {
    unint64_t v12 = 0;
  }
  else {
    unint64_t v12 = ((v11 - *(void *)v10) >> 5) + 16 * (v10 - v7) - (((uint64_t)v8 - *(void *)v7) >> 5);
  }
  sub_1CC07D524((void *)a1, v7, v8, v12);
  return a1;
}

void sub_1CD4A2304(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v3) {
    unint64_t v4 = a2;
  }
  else {
    unint64_t v4 = a2 + 1;
  }
  if ((v4 & 0x7F) != 0) {
    unint64_t v5 = (v4 >> 7) + 1;
  }
  else {
    unint64_t v5 = v4 >> 7;
  }
  unint64_t v6 = *(void *)(a1 + 32);
  if (v5 >= v6 >> 7) {
    unint64_t v7 = v6 >> 7;
  }
  else {
    unint64_t v7 = v5;
  }
  if (v5 <= v6 >> 7)
  {
    for (*(void *)(a1 + 32) = v6 - (v7 << 7); v7; --v7)
    {
      uint64_t v21 = *(void **)(a1 + 8);
      *(void *)&long long v27 = *v21;
      *(void *)(a1 + 8) = v21 + 1;
      sub_1CB904CD8(a1, &v27);
    }
  }
  else
  {
    unint64_t v8 = v5 - v7;
    uint64_t v9 = *(void *)(a1 + 24) - *(void *)a1;
    if (v5 - v7 <= (v9 >> 3) - (v3 >> 3))
    {
      if (v8)
      {
        while (*(void *)(a1 + 24) != *(void *)(a1 + 16))
        {
          *(void *)&long long v27 = operator new(0x1000uLL);
          sub_1CD3F23B4(a1, &v27);
          --v5;
          if (!--v8) {
            goto LABEL_43;
          }
        }
        for (uint64_t i = 0; i != v8; ++i)
        {
          *(void *)&long long v27 = operator new(0x1000uLL);
          sub_1CD3F24DC((void **)a1, &v27);
          if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
            uint64_t v23 = 127;
          }
          else {
            uint64_t v23 = 128;
          }
          uint64_t v24 = v23 + *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v24;
        }
        unint64_t v7 = v5;
      }
      else
      {
LABEL_43:
        uint64_t v24 = *(void *)(a1 + 32);
      }
      for (*(void *)(a1 + 32) = v24 - (v7 << 7); v7; --v7)
      {
        uint64_t v25 = *(void **)(a1 + 8);
        *(void *)&long long v27 = *v25;
        *(void *)(a1 + 8) = v25 + 1;
        sub_1CB904CD8(a1, &v27);
      }
    }
    else
    {
      uint64_t v10 = v3 >> 3;
      if (v9 >> 2 <= v8 + (v3 >> 3)) {
        unint64_t v11 = v8 + v10;
      }
      else {
        unint64_t v11 = v9 >> 2;
      }
      uint64_t v29 = a1 + 24;
      if (v11)
      {
        if (v11 >> 61) {
          sub_1CB833614();
        }
        unint64_t v12 = (char *)operator new(8 * v11);
      }
      else
      {
        unint64_t v12 = 0;
      }
      uint64_t v13 = v7 << 7;
      *(void *)&long long v27 = v12;
      *((void *)&v27 + 1) = &v12[8 * (v10 - v7)];
      *(void *)&long long v28 = *((void *)&v27 + 1);
      *((void *)&v28 + 1) = &v12[8 * v11];
      do
      {
        int v26 = operator new(0x1000uLL);
        sub_1CD3F23B4((uint64_t)&v27, &v26);
        --v8;
      }
      while (v8);
      for (uint64_t j = *(char **)(a1 + 8); v7; --v7)
      {
        sub_1CB904CD8((uint64_t)&v27, j);
        uint64_t j = (char *)(*(void *)(a1 + 8) + 8);
        *(void *)(a1 + 8) = j;
      }
      int v15 = j;
      if (*(char **)(a1 + 16) != j)
      {
        int v15 = *(char **)(a1 + 16);
        do
        {
          v15 -= 8;
          sub_1CD3F24DC((void **)&v27, v15);
        }
        while (v15 != *(char **)(a1 + 8));
        uint64_t j = *(char **)(a1 + 16);
      }
      uint64_t v16 = *(void **)a1;
      long long v17 = v27;
      long long v18 = v28;
      *(void *)&long long v27 = *(void *)a1;
      *((void *)&v27 + 1) = v15;
      uint64_t v19 = *(void *)(a1 + 24);
      uint64_t v20 = *(void *)(a1 + 32);
      *(_OWORD *)a1 = v17;
      *(_OWORD *)(a1 + 16) = v18;
      *(void *)&long long v28 = j;
      *((void *)&v28 + 1) = v19;
      *(void *)(a1 + 32) = v20 - v13;
      if (j != v15) {
        *(void *)&long long v28 = &j[(v15 - j + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v16) {
        operator delete(v16);
      }
    }
  }
}

BOOL sub_1CD4A2594(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 24);
  int v3 = *(unsigned __int8 *)(a2 + 24);
  if (*(unsigned char *)(a1 + 24)) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return (v2 == 0) ^ (v3 != 0);
  }
  if (*(void *)a1 != *(void *)a2) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)(a1 + 16);
  int v3 = *(unsigned __int8 *)(a2 + 16);
  if (!*(unsigned char *)(a1 + 16) || v3 == 0) {
    return (v2 == 0) ^ (v3 != 0);
  }
  return *(void *)(a1 + 8) == *(void *)(a2 + 8);
}

void sub_1CD4A2600(llvm::SmallPtrSetImplBase *this)
{
  int v2 = (void *)((char *)this + 96);
  uint64_t v3 = *(void *)(*((void *)this + 13) + ((*((void *)this + 16) >> 4) & 0xFFFFFFFFFFFFFF8))
     + 32 * (*((void *)this + 16) & 0x7FLL);
  uint64_t v4 = *(void *)v3;
  if (!*(unsigned char *)(v3 + 16)) {
    uint64_t v3 = *(void *)v3;
  }
  unint64_t v5 = *(uint64_t **)(v3 + 8);
  while (v5 != *(uint64_t **)(v4 + 16))
  {
    uint64_t v7 = *v5++;
    uint64_t v6 = v7;
    sub_1CB89694C(this, v7);
    if (v8)
    {
      *(void *)&long long v9 = v6;
      BYTE8(v9) = 0;
      char v10 = 0;
      char v11 = 1;
      sub_1CD4A18C8(v2, &v9);
    }
  }
  sub_1CD4A272C(v2);
  if (*((void *)this + 17)
    && !*(unsigned char *)(*(void *)(*((void *)this + 13) + ((*((void *)this + 16) >> 4) & 0xFFFFFFFFFFFFFF8))
                 + 32 * (*((void *)this + 16) & 0x7FLL)
                 + 24))
  {
    ++*((_DWORD *)this + 36);
    sub_1CD4A272C(v2);
    if (*((void *)this + 17))
    {
      LOBYTE(v9) = 0;
      char v11 = 0;
      sub_1CD4A18C8(v2, &v9);
    }
  }
}

void sub_1CD4A272C(void *a1)
{
  int v2 = (void **)a1[1];
  unint64_t v3 = a1[4];
  uint64_t v4 = *(uint64_t *)((char *)v2 + ((v3 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v3 & 0x7F);
  int v6 = *(unsigned __int8 *)(v4 + 24);
  unint64_t v5 = (unsigned char *)(v4 + 24);
  if (v6) {
    *unint64_t v5 = 0;
  }
  uint64_t v7 = a1[5] - 1;
  unint64_t v8 = v3 + 1;
  a1[4] = v8;
  a1[5] = v7;
  if (v8 >= 0x100)
  {
    operator delete(*v2);
    a1[1] += 8;
    a1[4] -= 128;
  }
}

uint64_t sub_1CD4A27AC(uint64_t a1)
{
  int v2 = *(void **)(a1 + 144);
  if (v2 != (void *)(a1 + 160)) {
    free(v2);
  }
  unint64_t v3 = *(void **)(a1 + 80);
  if (v3 != (void *)(a1 + 96)) {
    free(v3);
  }
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

void sub_1CD4A280C()
{
}

uint64_t **sub_1CD4A287C(uint64_t **result, void *a2)
{
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    unint64_t v3 = *result;
    uint64_t v4 = 8 * v2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    uint64_t v7 = (uint64_t)(*result - 1);
    do
    {
      double result = *(uint64_t ***)(v7 + v4);
      *(void *)(v7 + v4) = 0;
      if (result) {
        double result = (uint64_t **)sub_1CC07EF20(result);
      }
      v4 -= 8;
    }
    while (v4);
  }
  return result;
}

char **sub_1CD4A28E0(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void **)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        sub_1CC07EF20(v6);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

unint64_t sub_1CD4A294C(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 80 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD4A29B8();
    }
    sub_1CD4A29B8();
  }
  return a2;
}

void sub_1CD4A29B8()
{
}

uint64_t sub_1CD4A2A28(uint64_t result, void *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)result;
    uint64_t v6 = 80 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x800000000;
      if (*(_DWORD *)(v5 + 8)) {
        double result = sub_1CD4A2AD8((uint64_t)a2, v5);
      }
      v5 += 80;
      a2 += 10;
      v6 -= 80;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(v4 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)v4;
      uint64_t v9 = 80 * v7;
      uint64_t v10 = v8 - 80;
      do
      {
        double result = (uint64_t)sub_1CD4A28E0((char **)(v10 + v9));
        v9 -= 80;
      }
      while (v9);
    }
  }
  return result;
}

uint64_t sub_1CD4A2AD8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v21 = *(char **)a1;
        if (v5)
        {
          uint64_t v22 = 0;
          do
          {
            uint64_t v23 = *(void *)&v4[v22];
            *(void *)&v4[v22] = 0;
            uint64_t v24 = *(void **)&v21[v22];
            *(void *)&v21[v22] = v23;
            if (v24) {
              sub_1CC07EF20(v24);
            }
            v22 += 8;
          }
          while (8 * v5 != v22);
          uint64_t v6 = *(unsigned int *)(a1 + 8);
          uint64_t v25 = &v21[v22];
          uint64_t v21 = *(char **)a1;
        }
        else
        {
          uint64_t v25 = *(char **)a1;
        }
        int v26 = &v21[8 * v6];
        while (v26 != v25)
        {
          long long v28 = (void *)*((void *)v26 - 1);
          v26 -= 8;
          long long v27 = v28;
          *(void *)int v26 = 0;
          if (v28) {
            sub_1CC07EF20(v27);
          }
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v29 = *(unsigned int *)(a2 + 8);
        if (v29)
        {
          uint64_t v30 = 8 * v29;
          uint64_t v31 = *(void *)a2 - 8;
          do
          {
            uint64_t v32 = *(void **)(v31 + v30);
            *(void *)(v31 + v30) = 0;
            if (v32) {
              sub_1CC07EF20(v32);
            }
            v30 -= 8;
          }
          while (v30);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            uint64_t v34 = 8 * v6;
            uint64_t v35 = *(void *)a1 - 8;
            do
            {
              int v36 = *(void **)(v35 + v34);
              *(void *)(v35 + v34) = 0;
              if (v36) {
                sub_1CC07EF20(v36);
              }
              v34 -= 8;
            }
            while (v34);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD4A280C();
        }
        if (v6)
        {
          uint64_t v7 = *(char **)a1;
          uint64_t v8 = 8 * v6;
          do
          {
            uint64_t v9 = *(void **)v4;
            *(void *)uint64_t v4 = 0;
            uint64_t v10 = *(void **)v7;
            *(void *)uint64_t v7 = v9;
            if (v10) {
              sub_1CC07EF20(v10);
            }
            v4 += 8;
            v7 += 8;
            v8 -= 8;
          }
          while (v8);
        }
        else
        {
          uint64_t v6 = 0;
        }
        char v11 = *(char **)a2;
        uint64_t v12 = *(unsigned int *)(a2 + 8);
        if (v6 != v12)
        {
          uint64_t v13 = (void *)(*(void *)a1 + 8 * v6);
          uint64_t v14 = &v11[8 * v6];
          uint64_t v15 = 8 * v12 - 8 * v6;
          do
          {
            uint64_t v16 = *(void *)v14;
            *(void *)uint64_t v14 = 0;
            v14 += 8;
            *v13++ = v16;
            v15 -= 8;
          }
          while (v15);
          char v11 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v17 = *(unsigned int *)(a2 + 8);
        if (v17)
        {
          uint64_t v18 = 8 * v17;
          uint64_t v19 = v11 - 8;
          do
          {
            uint64_t v20 = *(void **)&v19[v18];
            *(void *)&v19[v18] = 0;
            if (v20) {
              sub_1CC07EF20(v20);
            }
            v18 -= 8;
          }
          while (v18);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CD4A2CD8((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CD4A2CD8(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    uint64_t v7 = v4 - 8;
    do
    {
      uint64_t v8 = *(void **)&v7[v6];
      *(void *)&v7[v6] = 0;
      if (v8) {
        sub_1CC07EF20(v8);
      }
      v6 -= 8;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

llvm::LoopNest *llvm::LoopNest::LoopNest(llvm::LoopNest *this, llvm::Loop *a2, llvm::ScalarEvolution *a3, llvm::ScalarEvolution *a4)
{
  int v7 = 1;
  uint64_t v8 = a2;
  while (1)
  {
    uint64_t v9 = (const llvm::Loop **)*((void *)v8 + 1);
    if (*((void *)v8 + 2) - (void)v9 != 8) {
      break;
    }
    uint64_t v10 = *v9;
    int v11 = llvm::LoopNest::analyzeLoopNestForPerfectNest(v8, *v9, a3, a4);
    ++v7;
    uint64_t v8 = v10;
    if (v11)
    {
      --v7;
      break;
    }
  }
  *(_DWORD *)this = v7;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 2) = 0x800000000;
  uint64_t v13 = a2;
  sub_1CC07C66C((uint64_t *)&v13, (uint64_t)v14);
  sub_1CD4A0A40((uint64_t)this + 8, (llvm::SmallPtrSetImplBase *)v14);
  sub_1CD4A1090((uint64_t)v14);
  return this;
}

void llvm::LoopNest::getLoopNest(llvm::LoopNest *this, llvm::Loop *a2, llvm::ScalarEvolution *a3)
{
}

llvm::BasicBlock *llvm::LoopNest::skipEmptyBlockUntil(llvm::LoopNest *this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3)
{
  uint64_t v3 = this;
  if (this != a2)
  {
    int v4 = (int)a3;
    if (llvm::BasicBlock::getUniqueSuccessor(this))
    {
      uint64_t v14 = v18;
      uint64_t v15 = v18;
      uint64_t v16 = 4;
      int v17 = 0;
      UniqueSuccessor = (const llvm::BasicBlock *)llvm::BasicBlock::getUniqueSuccessor(v3);
      BOOL v7 = UniqueSuccessor == a2;
      if (!UniqueSuccessor || UniqueSuccessor == a2)
      {
        uint64_t v8 = v3;
LABEL_18:
        if (v7) {
          uint64_t v3 = a2;
        }
        else {
          uint64_t v3 = v8;
        }
      }
      else
      {
        while (1)
        {
          uint64_t v8 = UniqueSuccessor;
          uint64_t v9 = 2;
          uint64_t v10 = (void *)((char *)UniqueSuccessor + 40);
          do
          {
            uint64_t v10 = (void *)v10[1];
            --v9;
          }
          while (v10 != (void *)((char *)UniqueSuccessor + 40));
          if (v9) {
            break;
          }
          int v11 = (char *)sub_1CB896AE8((uint64_t)&v14, (uint64_t)UniqueSuccessor);
          uint64_t v12 = v15 == v14 ? (uint64_t *)((char *)&v16 + 4) : &v16;
          if (v11 != &v15[8 * *(unsigned int *)v12] || v4 && !llvm::BasicBlock::getUniquePredecessor(v8)) {
            break;
          }
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v14, (uint64_t)v8);
          UniqueSuccessor = (const llvm::BasicBlock *)llvm::BasicBlock::getUniqueSuccessor(v8);
          BOOL v7 = UniqueSuccessor == a2;
          if (UniqueSuccessor)
          {
            uint64_t v3 = v8;
            if (UniqueSuccessor != a2) {
              continue;
            }
          }
          goto LABEL_18;
        }
      }
      if (v15 != v14) {
        free(v15);
      }
    }
  }
  return v3;
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *a1, int *a2)
{
  sub_1CB8E509C(a1, "IsPerfect=");
  int v4 = *a2;
  uint64_t v5 = (void **)*((void *)a2 + 1);
  uint64_t v6 = v5[a2[4] - 1];
  int v7 = 1;
  do
  {
    uint64_t v6 = (void *)*v6;
    ++v7;
  }
  while (v6);
  uint64_t v8 = *v5;
  do
  {
    uint64_t v8 = (void *)*v8;
    ++v4;
  }
  while (v8);
  if (v7 == v4) {
    uint64_t v9 = "true";
  }
  else {
    uint64_t v9 = "false";
  }
  sub_1CB8E509C(a1, v9);
  uint64_t v10 = sub_1CB8E509C(a1, ", Depth=");
  int v11 = (void **)*((void *)a2 + 1);
  uint64_t v12 = v11[a2[4] - 1];
  LODWORD(v13) = 1;
  do
  {
    uint64_t v12 = (void *)*v12;
    LODWORD(v13) = v13 + 1;
  }
  while (v12);
  uint64_t v14 = *v11;
  do
  {
    uint64_t v14 = (void *)*v14;
    unint64_t v13 = (v13 - 1);
  }
  while (v14);
  llvm::raw_ostream::operator<<(v10, v13);
  uint64_t v15 = sub_1CB8E509C(a1, ", OutermostLoop: ");
  uint64_t v16 = **(llvm::Value ***)(**((void **)a2 + 1) + 32);
  if (v16 && (*((unsigned char *)v16 + 23) & 0x10) != 0)
  {
    Name = llvm::Value::getName(v16);
    size_t v18 = v29;
  }
  else
  {
    Name = "<unnamed loop>";
    size_t v18 = 14;
  }
  uint64_t v19 = (void *)*((void *)v15 + 4);
  if (v18 <= *((void *)v15 + 3) - (void)v19)
  {
    if (v18)
    {
      memcpy(v19, Name, v18);
      *((void *)v15 + 4) += v18;
    }
  }
  else
  {
    llvm::raw_ostream::write(v15, Name, v18);
  }
  sub_1CB8E509C(a1, ", Loops:(");
  uint64_t v20 = a2[4];
  if (v20)
  {
    uint64_t v21 = *((void *)a2 + 1);
    uint64_t v22 = 8 * v20;
    do
    {
      uint64_t v23 = **(llvm::Value ***)(*(void *)v21 + 32);
      if (v23 && (*((unsigned char *)v23 + 23) & 0x10) != 0)
      {
        uint64_t v25 = llvm::Value::getName(v23);
        size_t v24 = v27;
      }
      else
      {
        size_t v24 = 14;
        uint64_t v25 = "<unnamed loop>";
      }
      int v26 = (void *)*((void *)a1 + 4);
      if (v24 <= *((void *)a1 + 3) - (void)v26)
      {
        if (v24)
        {
          memcpy(v26, v25, v24);
          *((void *)a1 + 4) += v24;
        }
      }
      else
      {
        llvm::raw_ostream::write(a1, v25, v24);
      }
      sub_1CB8E509C(a1, " ");
      v21 += 8;
      v22 -= 8;
    }
    while (v22);
  }
  sub_1CB8E509C(a1, ")");
  return a1;
}

void llvm::LoopNestPrinterPass::run()
{
}

uint64_t llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::replaceChildLoopWith(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(void **)(result + 8);
  int v4 = *(void **)(result + 16);
  if (v3 != v4)
  {
    while ((void *)*v3 != a2)
    {
      if (++v3 == v4)
      {
        uint64_t v3 = *(void **)(result + 16);
        break;
      }
    }
  }
  *uint64_t v3 = a3;
  *a2 = 0;
  *a3 = result;
  return result;
}

uint64_t llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::verifyLoopNest(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a1;
  uint64_t result = sub_1CD484194((uint64_t)v9, a2, &v8);
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *(uint64_t **)(a1 + 16);
  while (v6 != v5)
  {
    uint64_t v7 = *v6++;
    uint64_t result = llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::verifyLoopNest(v7, a2);
  }
  return result;
}

void llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print(llvm::Loop *a1, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4, int a5)
{
}

uint64_t llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::verify(uint64_t a1)
{
  if (*(void *)(a1 + 24) != *(void *)(a1 + 32)) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::verifyLoopNest();
  }
  return MEMORY[0x1D25D9CD0](0, 8);
}

uint64_t llvm::Loop::makeLoopInvariant(llvm::Loop *this, llvm::Value *a2, BOOL *a3, llvm::BasicBlock **a4, llvm::MemorySSAUpdater *a5)
{
  if (a2 && *((unsigned __int8 *)a2 + 16) >= 0x1Cu) {
    return llvm::Loop::makeLoopInvariant((uint64_t)this, (uint64_t)a2, a3, a4, (uint64_t *)a5);
  }
  else {
    return 1;
  }
}

void llvm::Loop::getLatchCmpInst(llvm::Loop *this)
{
}

void *llvm::Loop::LoopBounds::getBounds@<X0>(llvm::Loop::LoopBounds *this@<X0>, const llvm::Loop *a2@<X1>, llvm::PHINode *a3@<X2>, unsigned char *a4@<X8>)
{
  void v21[2] = *MEMORY[0x1E4F143B8];
  v13[1] = 0;
  uint64_t v14 = 0;
  v13[0] = 6;
  int v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = v21;
  uint64_t v20 = 0x200000000;
  if ((llvm::InductionDescriptor::isInductionPHI((unint64_t)a2, (uint64_t)this, (uint64_t)a3, (uint64_t)v13, 0) & 1) != 0
    && v14
    && v17)
  {
    uint64_t v9 = v16;
    int v10 = *(_DWORD *)(v17 + 20);
    if ((v10 & 0x40000000) != 0) {
      int v11 = *(llvm::Value ***)(v17 - 8);
    }
    else {
      int v11 = (llvm::Value **)(v17 - 32 * (v10 & 0x7FFFFFF));
    }
    uint64_t v12 = *v11;
    if (llvm::ScalarEvolution::getSCEV(a3, v11[4]) != v9) {
      llvm::ScalarEvolution::getSCEV(a3, v12);
    }
    llvm::Loop::getLatchCmpInst(this);
  }
  *a4 = 0;
  a4[48] = 0;
  return sub_1CC08AF1C(v13);
}

uint64_t llvm::Loop::isLCSSAForm(llvm::Loop *this, const llvm::DominatorTree *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 4);
  uint64_t v3 = *((void *)this + 5) - (void)v2;
  if (!v3) {
    return 1;
  }
  uint64_t v5 = 8 * (v3 >> 3) - 8;
  do
  {
    uint64_t v6 = *v2++;
    uint64_t result = sub_1CC08D608((uint64_t)this, v6);
    if (result) {
      BOOL v8 = v5 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    v5 -= 8;
  }
  while (!v8);
  return result;
}

uint64_t llvm::Loop::isRecursivelyLCSSAForm(llvm::Loop *this, const llvm::DominatorTree *a2, const llvm::LoopInfo *a3)
{
  uint64_t v3 = (uint64_t *)*((void *)this + 4);
  uint64_t v4 = *((void *)this + 5) - (void)v3;
  if (!v4) {
    return 1;
  }
  uint64_t v6 = 8 * (v4 >> 3) - 8;
  do
  {
    uint64_t v7 = *v3++;
    uint64_t v10 = 0;
    uint64_t v11 = v7;
    sub_1CB834D78((uint64_t *)a3, &v11, &v10);
    uint64_t result = sub_1CC08D608(*(void *)(v10 + 8), v7);
    if (result) {
      BOOL v9 = v6 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    v6 -= 8;
  }
  while (!v9);
  return result;
}

void llvm::findOptionMDForLoop(llvm::Loop *a1)
{
}

void llvm::Loop::dump(llvm::Loop *this)
{
  llvm::dbgs(this);

  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print();
}

void llvm::Loop::dumpVerbose(llvm::Loop *this)
{
  llvm::dbgs(this);

  llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print();
}

void llvm::LoopPrinterPass::run()
{
}

void *llvm::printLoop(llvm::Value ***a1, llvm::raw_ostream *a2, uint64_t a3)
{
  int v6 = llvm::forcePrintModuleIR((llvm *)a1);
  char v7 = *(unsigned char *)(a3 + 23);
  BOOL v8 = v7 < 0;
  if (v7 >= 0) {
    BOOL v9 = (const char *)a3;
  }
  else {
    BOOL v9 = *(const char **)a3;
  }
  size_t v10 = v7 & 0x7F;
  if (v8) {
    size_t v11 = *(void *)(a3 + 8);
  }
  else {
    size_t v11 = v10;
  }
  llvm::raw_ostream::write(a2, v9, v11);
  if (!v6) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getLoopPreheader();
  }
  sub_1CB8E509C(a2, " (loop: ");
  llvm::Value::printAsOperand(*a1[4], a2, 0, 0);
  sub_1CB8E509C(a2, ")\n");
  uint64_t Module = (const std::string *)llvm::BasicBlock::getModule(*a1[4]);

  return llvm::Module::print(Module, a2, 0, 0, 0);
}

void llvm::hasMustProgress(llvm *this, const llvm::Loop *a2)
{
}

llvm::LoopInfoWrapperPass *llvm::LoopInfoWrapperPass::LoopInfoWrapperPass(llvm::LoopInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::LoopInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F26051F0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = (char *)this + 112;
  *((void *)this + 13) = 0x400000000;
  *((void *)this + 20) = 0;
  *((void *)this + 18) = (char *)this + 160;
  *((void *)this + 19) = 0;
  *((void *)this + 21) = 1;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6810, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC08A92C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6810, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::LoopInfoWrapperPass::verifyAnalysis(uint64_t this)
{
  if (llvm::VerifyLoopInfo)
  {
    uint64_t v1 = *(uint64_t **)(this + 8);
    uint64_t v2 = *v1;
    uint64_t v3 = v1[1];
    if (v2 == v3)
    {
LABEL_3:
      uint64_t v4 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v2 != &llvm::DominatorTreeWrapperPass::ID)
      {
        v2 += 16;
        if (v2 == v3) {
          goto LABEL_3;
        }
      }
      uint64_t v4 = *(void *)(v2 + 8);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, &llvm::DominatorTreeWrapperPass::ID);
    llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::verify();
  }
  return this;
}

llvm::AnalysisUsage *llvm::LoopInfoWrapperPass::getAnalysisUsage(llvm::LoopInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t llvm::LoopInfoWrapperPass::print(uint64_t this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  if (*(void *)(this + 64) != *(void *)(this + 56)) {
    llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::print();
  }
  return this;
}

void llvm::LoopVerifierPass::run()
{
}

void sub_1CD4A4064(void *a1)
{
  *a1 = &unk_1F26051F0;
  llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase();
}

void sub_1CD4A40B8(void *a1)
{
  *a1 = &unk_1F26051F0;
  llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase();
}

uint64_t sub_1CD4A4120(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  char v11 = 0;
  uint64_t v8 = llvm::cl::parser<BOOL>::parse(a1 + 152, (void *)a1, a3, a4, a5, a6, &v11);
  if (v8) {
    return v8;
  }
  **(unsigned char **)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, char *))(*(void *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD4A41B8();
}

uint64_t sub_1CD4A41B8()
{
  return 1;
}

uint64_t sub_1CD4A41C0(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1CD4A41CC(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

void sub_1CD4A41DC(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    int v3 = **(unsigned __int8 **)(a1 + 128);
LABEL_3:
    __int16 v5 = *(_WORD *)(a1 + 144);
    uint64_t v4 = &unk_1F25EDE58;
    llvm::cl::parser<BOOL>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, v3 != 0, (uint64_t)&v4, a2);
    return;
  }
  if (*(unsigned char *)(a1 + 145))
  {
    int v3 = **(unsigned __int8 **)(a1 + 128);
    if (*(unsigned __int8 *)(a1 + 144) != v3) {
      goto LABEL_3;
    }
  }
}

void llvm::callDefaultCtor<llvm::LoopInfoWrapperPass>()
{
}

llvm::cl::Option *sub_1CD4A42A8(llvm::cl::Option *a1, char *a2, unsigned char **a3, _WORD *a4, __n128 *a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(unsigned char *)(v10 + 145) = 0;
  *(void *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EDE58;
  *(void *)uint64_t v10 = &unk_1F2605290;
  *(void *)(v10 + 152) = &unk_1F2643CC0;
  *(void *)(v10 + 160) = &unk_1F26052F8;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD4A4398(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD4A4398(uint64_t a1, char *__s, unsigned char **a3, _WORD *a4, __n128 *a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  sub_1CC08D588((llvm *)(a1 + 128), (void *)a1, *a3);
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  __n128 result = *a5;
  *(__n128 *)(a1 + 32) = *a5;
  return result;
}

void sub_1CD4A4424()
{
}

void *sub_1CD4A4438()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F26052F8;
  return result;
}

void sub_1CD4A4470(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26052F8;
}

void llvm::LPPassManager::addLoop(llvm::LPPassManager *this, llvm::Loop *a2)
{
  int v3 = (int64x2_t *)((char *)this + 416);
  if (*(void *)a2)
  {
    uint64_t v4 = *((void *)this + 53);
    if (*((void *)this + 54) != v4)
    {
      unint64_t v5 = *((void *)this + 56);
      uint64_t v6 = *((void *)this + 57);
      char v7 = (char **)(v4 + 8 * (v5 >> 9));
      uint64_t v8 = *v7;
      uint64_t v9 = &(*v7)[8 * (v5 & 0x1FF)];
      uint64_t v10 = *(void *)(v4 + (((v6 + v5) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v6 + v5) & 0x1FF);
      while (v9 != (char *)v10)
      {
        uint64_t v11 = *(void *)v9;
        v9 += 8;
        uint64_t v12 = (char *)(v9 - v8);
        if (v11 == *(void *)a2)
        {
          if (v12 == (char *)4096)
          {
            uint64_t v14 = v7[1];
            ++v7;
            uint64_t v9 = v14;
          }
          int v15 = a2;
          sub_1CD4A4674(v3, (char *)v7, (uint64_t)v9, 1uLL, &v15);
          return;
        }
        if (v12 == (char *)4096)
        {
          unint64_t v13 = v7[1];
          ++v7;
          uint64_t v8 = v13;
          uint64_t v9 = v13;
        }
      }
    }
  }
  else
  {
    int v15 = a2;
    sub_1CD4A45F0(v3, &v15);
  }
}

void sub_1CD4A45F0(void *a1, void *a2)
{
  unint64_t v4 = a1[4];
  if (!v4)
  {
    sub_1CD4A583C((uint64_t)a1);
    unint64_t v4 = a1[4];
  }
  uint64_t v5 = a1[1];
  uint64_t v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (a1[2] == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096;
  }
  *(void *)(v7 - 8) = *a2;
  uint64_t v8 = a1[5] + 1;
  a1[4] = v4 - 1;
  a1[5] = v8;
}

void *sub_1CD4A4674(int64x2_t *a1, char *a2, uint64_t a3, unint64_t a4, void *a5)
{
  unint64_t v6 = a4;
  unint64_t v8 = a1[2].u64[0];
  unint64_t v9 = v8 >> 9;
  uint64_t v10 = a1->i64[1];
  uint64_t v11 = a1[1].i64[0];
  uint64_t v12 = (char *)(v10 + 8 * (v8 >> 9));
  if (v11 == v10) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = *(void *)v12 + 8 * (a1[2].i64[0] & 0x1FF);
  }
  if (a3 == v13) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = ((a3 - *(void *)a2) >> 3) + ((a2 - v12) << 6) - ((v13 - *(void *)v12) >> 3);
  }
  uint64_t v15 = a1[2].i64[1];
  if (v14 >= v15 - v14)
  {
    uint64_t v25 = ((v11 - v10) << 6) - 1;
    if (v11 == v10) {
      uint64_t v25 = 0;
    }
    unint64_t v26 = v15 + v8;
    unint64_t v27 = v25 - v26;
    if (a4 > v27)
    {
      sub_1CD4A5EDC((uint64_t)a1, a4 - v27);
      uint64_t v15 = a1[2].i64[1];
      uint64_t v10 = a1->i64[1];
      uint64_t v11 = a1[1].i64[0];
      unint64_t v26 = a1[2].i64[0] + v15;
    }
    long long v28 = (char *)(v10 + 8 * (v26 >> 9));
    if (v11 == v10) {
      size_t v29 = 0;
    }
    else {
      size_t v29 = (char *)(*(void *)v28 + 8 * (v26 & 0x1FF));
    }
    unint64_t v30 = v15 - v14;
    unint64_t v31 = v6 - (v15 - v14);
    if (v6 <= v15 - v14)
    {
      uint64_t v33 = v29;
      uint64_t v32 = v28;
    }
    else
    {
      uint64_t v32 = v28;
      uint64_t v33 = v29;
      do
      {
        *v33++ = *a5;
        if ((void *)((char *)v33 - *(void *)v32) == (void *)4096)
        {
          uint64_t v34 = (void *)*((void *)v32 + 1);
          v32 += 8;
          uint64_t v33 = v34;
        }
        --v31;
      }
      while (v31);
      a1[2].i64[1] = v14 + v6;
      unint64_t v6 = v15 - v14;
    }
    if (v6)
    {
      v65 = a5;
      uint64_t v45 = ((uint64_t)&v29[-*(void *)v28] >> 3) - v6;
      if (v45 < 1)
      {
        unint64_t v51 = 511 - v45;
        uint64_t v46 = &v28[-8 * (v51 >> 9)];
        BOOL v47 = (char *)(*(void *)v46 + 8 * (~(_WORD)v51 & 0x1FF));
      }
      else
      {
        uint64_t v46 = &v28[8 * ((unint64_t)v45 >> 9)];
        BOOL v47 = (char *)(*(void *)v46 + 8 * (v45 & 0x1FF));
      }
      sub_1CD4A616C((uint64_t)a1, v46, (unint64_t)v47, v28, (uint64_t)v29, v32, v33, (unint64_t *)&v65);
      if (v6 < v30)
      {
        uint64_t v52 = ((uint64_t)&v29[-*(void *)v28] >> 3) - v30;
        if (v52 < 1)
        {
          unint64_t v64 = 511 - v52;
          unsigned int v53 = &v28[-8 * (v64 >> 9)];
          uint64_t v54 = (char *)(*(void *)v53 + 8 * (~(_WORD)v64 & 0x1FF));
        }
        else
        {
          unsigned int v53 = &v28[8 * ((unint64_t)v52 >> 9)];
          uint64_t v54 = (char *)(*(void *)v53 + 8 * (v52 & 0x1FF));
        }
        long long v28 = sub_1CC08EB20(v53, v54, v46, v47, v28, v29, (unint64_t *)&v65);
        size_t v29 = v55;
      }
      uint64_t v56 = ((uint64_t)&v29[-*(void *)v28] >> 3) - v6;
      if (v56 < 1)
      {
        unint64_t v61 = 511 - v56;
        LOWORD(v56) = ~(511 - v56);
        uint64_t v57 = &v28[-8 * (v61 >> 9)];
      }
      else
      {
        uint64_t v57 = &v28[8 * ((unint64_t)v56 >> 9)];
      }
      int v58 = (void *)(*(void *)v57 + 8 * (v56 & 0x1FF));
      v59 = v65;
      do
      {
        *v58++ = *v59;
        if ((void *)((char *)v58 - *(void *)v57) == (void *)4096)
        {
          uint64_t v60 = (void *)*((void *)v57 + 1);
          v57 += 8;
          int v58 = v60;
        }
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    if (a4 > v8)
    {
      sub_1CD4A5A2C((uint64_t)a1, a4 - v8);
      unint64_t v8 = a1[2].u64[0];
      uint64_t v10 = a1->i64[1];
      uint64_t v11 = a1[1].i64[0];
      unint64_t v9 = v8 >> 9;
    }
    uint64_t v16 = (char *)(v10 + 8 * v9);
    if (v11 == v10) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = (char *)(*(void *)v16 + 8 * (v8 & 0x1FF));
    }
    uint64_t v18 = (uint64_t)v17;
    uint64_t v19 = (char *)(v10 + 8 * v9);
    unint64_t v20 = v14 - v6;
    if (v14 >= v6)
    {
      unint64_t v21 = v6;
    }
    else
    {
      unint64_t v21 = v14;
      unint64_t v22 = v6 - v14;
      if (v6 != v14)
      {
        uint64_t v23 = a1[2].i64[1];
        uint64_t v19 = v16;
        uint64_t v18 = (uint64_t)v17;
        do
        {
          if (v18 == *(void *)v19)
          {
            uint64_t v24 = *((void *)v19 - 1);
            v19 -= 8;
            uint64_t v18 = v24 + 4096;
          }
          *(void *)(v18 - 8) = *a5;
          v18 -= 8;
          --v6;
        }
        while (v14 != v6);
        a1[2].i64[0] = v20 + v8;
        a1[2].i64[1] = v22 + v23;
        unint64_t v21 = v14;
      }
    }
    if (v21)
    {
      v65 = a5;
      uint64_t v39 = v21 + ((uint64_t)&v17[-*(void *)v16] >> 3);
      if (v39 < 1)
      {
        unint64_t v44 = 511 - v39;
        uint64_t v40 = &v16[-8 * (v44 >> 9)];
        int v41 = (char *)(*(void *)v40 + 8 * (~(_WORD)v44 & 0x1FF));
      }
      else
      {
        uint64_t v40 = &v16[8 * ((unint64_t)v39 >> 9)];
        int v41 = (char *)(*(void *)v40 + 8 * (v39 & 0x1FF));
      }
      sub_1CC08E984(a1, v16, (uint64_t)v17, v40, (unint64_t)v41, v19, v18, (unint64_t *)&v65);
      if (v21 < v14)
      {
        uint64_t v48 = v14 + ((uint64_t)&v17[-*(void *)v16] >> 3);
        if (v48 < 1)
        {
          unint64_t v62 = 511 - v48;
          int v49 = &v16[-8 * (v62 >> 9)];
          uint64_t v50 = (char *)(*(void *)v49 + 8 * (~(_WORD)v62 & 0x1FF));
        }
        else
        {
          int v49 = &v16[8 * ((unint64_t)v48 >> 9)];
          uint64_t v50 = (char *)(*(void *)v49 + 8 * (v48 & 0x1FF));
        }
        uint64_t v16 = sub_1CD4A5CD0(v40, v41, v49, v50, v16, v17, (unint64_t *)&v65);
        uint64_t v17 = v63;
      }
      int v42 = v65;
      do
      {
        *(void *)uint64_t v17 = *v42;
        v17 += 8;
        if (&v17[-*(void *)v16] == (char *)4096)
        {
          uint64_t v43 = (char *)*((void *)v16 + 1);
          v16 += 8;
          uint64_t v17 = v43;
        }
        --v21;
      }
      while (v21);
    }
  }
  uint64_t v35 = a1->i64[1];
  __n128 result = (void *)(v35 + 8 * ((unint64_t)a1[2].i64[0] >> 9));
  if (a1[1].i64[0] == v35) {
    uint64_t v37 = 0;
  }
  else {
    uint64_t v37 = *result + 8 * (a1[2].i64[0] & 0x1FF);
  }
  if (v14)
  {
    uint64_t v38 = v14 + ((v37 - *result) >> 3);
    if (v38 < 1) {
      result -= (unint64_t)(511 - v38) >> 9;
    }
    else {
      result += (unint64_t)v38 >> 9;
    }
  }
  return result;
}

llvm::AnalysisUsage *llvm::LPPassManager::getAnalysisUsage(llvm::LPPassManager *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  __n128 result = llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

void llvm::LPPassManager::dumpPassStructure(llvm::LPPassManager *this, int a2)
{
  unint64_t v4 = (llvm::raw_ostream *)llvm::errs(this);
  uint64_t v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  sub_1CB8E509C(v5, "Loop Pass Manager\n");
  if (*((_DWORD *)this + 14))
  {
    unint64_t v6 = 0;
    uint64_t v7 = (a2 + 1);
    do
    {
      unint64_t v8 = *(llvm::Pass **)(*((void *)this + 6) + 8 * v6);
      (*(void (**)(llvm::Pass *, uint64_t))(*(void *)v8 + 128))(v8, v7);
      llvm::PMDataManager::dumpLastUses((llvm::LPPassManager *)((char *)this + 32), v8, v7);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 14));
  }
}

void llvm::LoopPass::createPrinterPass()
{
}

double llvm::LoopPass::preparePassManager(llvm::LoopPass *this, llvm::PMStack *a2)
{
  uint64_t v4 = *(void *)a2;
  for (uint64_t i = *((void *)a2 + 1); v4 != i; uint64_t i = *((void *)a2 + 1))
  {
    if ((*(int (**)(void))(**(void **)(i - 8) + 40))(*(void *)(i - 8)) <= 4)
    {
      uint64_t v4 = *((void *)a2 + 1);
      break;
    }
    llvm::PMStack::pop(a2);
    uint64_t v4 = *(void *)a2;
  }
  if ((*(unsigned int (**)(void))(**(void **)(v4 - 8) + 40))(*(void *)(v4 - 8)) == 4
    && (llvm::PMDataManager::preserveHigherLevelAnalysis(*(llvm::PMTopLevelManager ***)(*((void *)a2 + 1) - 8), this) & 1) == 0)
  {
    return llvm::PMStack::pop(a2);
  }
  return result;
}

void llvm::LoopPass::assignPassManager(llvm::Pass *a1, llvm::PMStack *a2)
{
  uint64_t v4 = *(void *)a2;
  for (uint64_t i = *((void *)a2 + 1); ; uint64_t i = *((void *)a2 + 1))
  {
    if (v4 == i) {
      goto LABEL_5;
    }
    if ((*(int (**)(void))(**(void **)(i - 8) + 40))(*(void *)(i - 8)) <= 4) {
      break;
    }
    llvm::PMStack::pop(a2);
    uint64_t v4 = *(void *)a2;
  }
  uint64_t v4 = *((void *)a2 + 1);
LABEL_5:
  int v6 = (*(uint64_t (**)(void))(**(void **)(v4 - 8) + 40))(*(void *)(v4 - 8));
  uint64_t v7 = *(void *)(*((void *)a2 + 1) - 8);
  if (v6 == 4)
  {
    if (v7) {
      uint64_t v8 = v7 - 32;
    }
    else {
      uint64_t v8 = 0;
    }
    llvm::PMDataManager::add((llvm::PMDataManager *)(v8 + 32), a1);
  }
  operator new();
}

llvm::LCSSAVerificationPass *llvm::LCSSAVerificationPass::LCSSAVerificationPass(llvm::LCSSAVerificationPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::LCSSAVerificationPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2605430;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6818, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC08E5D4;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6818, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeLCSSAVerificationPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6818, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC08E5D4;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCC6818, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD4A515C(void **a1)
{
  *a1 = &unk_1F2605340;
  uint64_t v2 = (llvm::PMDataManager *)(a1 + 4);
  a1[4] = &unk_1F26053F0;
  sub_1CC08E90C(a1 + 52);
  llvm::PMDataManager::~PMDataManager(v2);

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD4A51DC(void **a1)
{
  *a1 = &unk_1F2605340;
  uint64_t v2 = (llvm::PMDataManager *)(a1 + 4);
  a1[4] = &unk_1F26053F0;
  sub_1CC08E90C(a1 + 52);
  llvm::PMDataManager::~PMDataManager(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4A5270(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD4A527C()
{
  return 4;
}

void sub_1CD4A5284(void **a1)
{
  uint64_t v2 = (llvm::Pass *)(a1 - 4);
  *(a1 - 4) = &unk_1F2605340;
  *a1 = &unk_1F26053F0;
  sub_1CC08E90C(a1 + 48);
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)a1);

  llvm::Pass::~Pass(v2);
}

void sub_1CD4A5304(uint64_t a1)
{
}

uint64_t sub_1CD4A530C(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1CD4A5314()
{
  return 4;
}

void sub_1CD4A5320(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4A5358(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void sub_1CD4A5364(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
LABEL_4:
    uint64_t v5 = *(void **)(a1 + 8);
    *(void *)&long long v18 = *v5;
    *(void *)(a1 + 8) = v5 + 1;
    sub_1CB904CD8(a1, &v18);
    return;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = v6 - *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = v8 - *(void *)a1;
  if (v7 < v9)
  {
    if (v8 != v6)
    {
      *(void *)&long long v18 = operator new(0x1000uLL);
      sub_1CD3F23B4(a1, &v18);
      return;
    }
    *(void *)&long long v18 = operator new(0x1000uLL);
    sub_1CD3F24DC((void **)a1, &v18);
    goto LABEL_4;
  }
  if (v8 == *(void *)a1) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v9 >> 2;
  }
  uint64_t v20 = a1 + 24;
  if (v10 >> 61) {
    sub_1CB833614();
  }
  *(void *)&long long v18 = operator new(8 * v10);
  *((void *)&v18 + 1) = v18 + v7;
  *(void *)&long long v19 = v18 + v7;
  *((void *)&v19 + 1) = v18 + 8 * v10;
  uint64_t v17 = operator new(0x1000uLL);
  sub_1CD4A54E0((uint64_t)&v18, &v17);
  uint64_t v11 = *(char **)(a1 + 16);
  if (v11 == *(char **)(a1 + 8))
  {
    uint64_t v12 = *(char **)(a1 + 16);
  }
  else
  {
    do
    {
      v11 -= 8;
      sub_1CD4A5618((const void **)&v18, v11);
    }
    while (v11 != *(char **)(a1 + 8));
    uint64_t v12 = *(char **)(a1 + 16);
  }
  uint64_t v13 = *(void **)a1;
  long long v14 = v18;
  long long v15 = v19;
  *(void *)&long long v18 = *(void *)a1;
  *((void *)&v18 + 1) = v11;
  uint64_t v16 = *(void *)(a1 + 24);
  *(_OWORD *)a1 = v14;
  *(_OWORD *)(a1 + 16) = v15;
  *(void *)&long long v19 = v12;
  *((void *)&v19 + 1) = v16;
  if (v12 != v11) {
    *(void *)&long long v19 = &v12[(v11 - v12 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v13) {
    operator delete(v13);
  }
}

void sub_1CD4A54E0(uint64_t a1, void *a2)
{
  uint64_t v2 = a1;
  BOOL v3 = *(char **)(a1 + 16);
  if (v3 == *(char **)(a1 + 24))
  {
    unint64_t v21 = a2;
    uint64_t v5 = *(char **)a1;
    unint64_t v4 = *(char **)(a1 + 8);
    if ((unint64_t)v4 <= *(void *)a1)
    {
      if (v3 == v5) {
        unint64_t v13 = 1;
      }
      else {
        unint64_t v13 = (v3 - v5) >> 2;
      }
      if (v13 >> 61) {
        sub_1CB833614();
      }
      long long v14 = (char *)operator new(8 * v13);
      long long v15 = &v14[8 * (v13 >> 2)];
      uint64_t v17 = v3 - v4;
      BOOL v16 = v3 == v4;
      BOOL v3 = v15;
      if (!v16)
      {
        BOOL v3 = &v15[v17 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v18 = 8 * (v17 >> 3);
        long long v19 = &v14[8 * (v13 >> 2)];
        do
        {
          uint64_t v20 = *(void *)v4;
          v4 += 8;
          *(void *)long long v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      a2 = v21;
      uint64_t v2 = a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v15;
      *(void *)(a1 + 16) = v3;
      *(void *)(a1 + 24) = &v14[8 * v13];
      if (v5)
      {
        operator delete(v5);
        a2 = v21;
        uint64_t v2 = a1;
        BOOL v3 = *(char **)(a1 + 16);
      }
    }
    else
    {
      uint64_t v6 = (uint64_t)&v4[-*(void *)a1] >> 3;
      if (v6 >= -1) {
        uint64_t v7 = v6 + 1;
      }
      else {
        uint64_t v7 = v6 + 2;
      }
      uint64_t v8 = -(v7 >> 1);
      uint64_t v9 = v7 >> 1;
      unint64_t v10 = &v4[-8 * v9];
      int64_t v11 = v3 - v4;
      if (v3 != v4)
      {
        memmove(&v4[-8 * v9], v4, v3 - v4);
        BOOL v3 = *(char **)(a1 + 8);
      }
      uint64_t v12 = &v3[8 * v8];
      BOOL v3 = &v10[v11];
      a2 = v21;
      uint64_t v2 = a1;
      *(void *)(a1 + 8) = v12;
      *(void *)(a1 + 16) = &v10[v11];
    }
  }
  *(void *)BOOL v3 = *a2;
  *(void *)(v2 + 16) += 8;
}

void sub_1CD4A5618(const void **a1, void *a2)
{
  uint64_t v2 = a1;
  BOOL v3 = (char *)a1[1];
  if (v3 == *a1)
  {
    __src = a1[1];
    unint64_t v22 = a2;
    uint64_t v6 = a1[2];
    uint64_t v5 = a1[3];
    if (v6 >= v5)
    {
      uint64_t v11 = v5 - v3;
      BOOL v10 = v11 == 0;
      uint64_t v12 = v11 >> 2;
      if (v10) {
        unint64_t v13 = 1;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13 >> 61) {
        sub_1CB833614();
      }
      long long v14 = (char *)operator new(8 * v13);
      long long v15 = &v14[(2 * v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      unint64_t v4 = v15;
      uint64_t v16 = v6 - (unsigned char *)__src;
      if (v6 != (unsigned char *)__src)
      {
        v15 += v16 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v17 = 8 * (v16 >> 3);
        uint64_t v18 = &v14[(2 * v13 + 6) & 0xFFFFFFFFFFFFFFF8];
        long long v19 = __src;
        do
        {
          uint64_t v20 = *v19++;
          *(void *)uint64_t v18 = v20;
          v18 += 8;
          v17 -= 8;
        }
        while (v17);
      }
      a2 = v22;
      uint64_t v2 = a1;
      *a1 = v14;
      a1[1] = v4;
      a1[2] = v15;
      a1[3] = &v14[8 * v13];
      if (__src)
      {
        operator delete(__src);
        a2 = v22;
        uint64_t v2 = a1;
        unint64_t v4 = (char *)a1[1];
      }
    }
    else
    {
      uint64_t v7 = (v5 - v6) >> 3;
      if (v7 >= -1) {
        uint64_t v8 = v7 + 1;
      }
      else {
        uint64_t v8 = v7 + 2;
      }
      uint64_t v9 = v8 >> 1;
      __dst = &v3[8 * (v8 >> 1)];
      if (v6 != v3)
      {
        memmove(__dst, v3, v6 - v3);
        __src = a1[2];
      }
      a2 = v22;
      uint64_t v2 = a1;
      unint64_t v4 = __dst;
      a1[1] = __dst;
      a1[2] = &__src[v9];
    }
  }
  else
  {
    unint64_t v4 = (char *)a1[1];
  }
  *((void *)v4 - 1) = *a2;
  v2[1] = (char *)v2[1] - 8;
}

void llvm::callDefaultCtor<llvm::LCSSAVerificationPass>()
{
}

void *sub_1CD4A57BC(void *result)
{
  uint64_t v1 = (void **)result[1];
  uint64_t v2 = result[2];
  result[5] = 0;
  unint64_t v3 = v2 - (void)v1;
  if (v3 >= 0x11)
  {
    do
    {
      uint64_t v6 = result;
      operator delete(*v1);
      double result = v6;
      uint64_t v5 = v6[2];
      uint64_t v1 = (void **)(v6[1] + 8);
      v6[1] = v1;
      unint64_t v3 = v5 - (void)v1;
    }
    while (v3 > 0x10);
  }
  if (v3 >> 3 == 2)
  {
    uint64_t v4 = 512;
LABEL_4:
    result[4] = v4;
    return result;
  }
  if (v3 >> 3 == 1)
  {
    uint64_t v4 = 256;
    goto LABEL_4;
  }
  return result;
}

void sub_1CD4A583C(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 8);
  unint64_t v3 = *(unsigned char **)(a1 + 16);
  if (v3 == v2) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v3 - v2) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) < 0x200)
  {
    uint64_t v6 = *(char **)(a1 + 24);
    uint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
    if (v3 - v2 >= (unint64_t)v8)
    {
      if (v6 == v7) {
        unint64_t v10 = 1;
      }
      else {
        unint64_t v10 = v8 >> 2;
      }
      uint64_t v23 = a1 + 24;
      if (v10 >> 61) {
        sub_1CB833614();
      }
      uint64_t v20 = (char *)operator new(8 * v10);
      unint64_t v21 = v20;
      *(void *)&long long v22 = v20;
      *((void *)&v22 + 1) = &v20[8 * v10];
      long long v19 = operator new(0x1000uLL);
      sub_1CD4A54E0((uint64_t)&v20, &v19);
      uint64_t v11 = *(char **)(a1 + 8);
      if (v11 == *(char **)(a1 + 16))
      {
        uint64_t v12 = *(char **)(a1 + 8);
      }
      else
      {
        do
        {
          sub_1CB904CD8((uint64_t)&v20, v11);
          v11 += 8;
        }
        while (v11 != *(char **)(a1 + 16));
        uint64_t v12 = *(char **)(a1 + 8);
      }
      unint64_t v13 = *(char **)a1;
      long long v14 = v21;
      *(void *)a1 = v20;
      *(void *)(a1 + 8) = v14;
      uint64_t v20 = v13;
      unint64_t v21 = v12;
      uint64_t v15 = *(void *)(a1 + 24);
      uint64_t v16 = v22;
      *(_OWORD *)(a1 + 16) = v22;
      *(void *)&long long v22 = v11;
      *((void *)&v22 + 1) = v15;
      if (v16 - (void)v14 == 8) {
        uint64_t v17 = 256;
      }
      else {
        uint64_t v17 = *(void *)(a1 + 32) + 512;
      }
      *(void *)(a1 + 32) = v17;
      if (v11 != v12) {
        *(void *)&long long v22 = &v11[(v12 - v11 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      if (v2 == v7)
      {
        uint64_t v20 = (char *)operator new(0x1000uLL);
        sub_1CD3F23B4(a1, &v20);
        uint64_t v9 = *(void *)(a1 + 16);
        uint64_t v20 = *(char **)(v9 - 8);
        *(void *)(a1 + 16) = v9 - 8;
      }
      else
      {
        uint64_t v20 = (char *)operator new(0x1000uLL);
      }
      sub_1CD3F24DC((void **)a1, &v20);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        uint64_t v18 = 256;
      }
      else {
        uint64_t v18 = *(void *)(a1 + 32) + 512;
      }
      *(void *)(a1 + 32) = v18;
    }
  }
  else
  {
    *(void *)(a1 + 32) = v5 + 512;
    uint64_t v20 = (char *)*((void *)v3 - 1);
    *(void *)(a1 + 16) = v3 - 8;
    sub_1CD3F24DC((void **)a1, &v20);
  }
}

void sub_1CD4A5A2C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = v4 - v3;
  if (v4 == v3) {
    unint64_t v6 = a2 + 1;
  }
  else {
    unint64_t v6 = a2;
  }
  if (v4 == v3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v3) << 6) - 1;
  }
  if ((v6 & 0x1FF) != 0) {
    unint64_t v8 = (v6 >> 9) + 1;
  }
  else {
    unint64_t v8 = v6 >> 9;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v7 - (*(void *)(a1 + 40) + v9);
  if (v8 >= v10 >> 9) {
    unint64_t v11 = v10 >> 9;
  }
  else {
    unint64_t v11 = v8;
  }
  if (v8 <= v10 >> 9)
  {
    for (*(void *)(a1 + 32) = v9 + (v11 << 9); v11; --v11)
    {
      uint64_t v25 = *(void *)(a1 + 16);
      *(void *)&long long v31 = *(void *)(v25 - 8);
      *(void *)(a1 + 16) = v25 - 8;
      sub_1CD3F24DC((void **)a1, &v31);
    }
  }
  else
  {
    unint64_t v12 = v8 - v11;
    uint64_t v13 = *(void *)(a1 + 24) - *(void *)a1;
    if (v8 - v11 <= (v13 >> 3) - (v5 >> 3))
    {
      if (v12)
      {
        if (v3 == *(void *)a1)
        {
LABEL_43:
          unint64_t v28 = v12;
          do
          {
            *(void *)&long long v31 = operator new(0x1000uLL);
            sub_1CD3F23B4(a1, &v31);
            --v28;
          }
          while (v28);
          v11 += v12;
          uint64_t v9 = *(void *)(a1 + 32);
        }
        else
        {
          while (1)
          {
            *(void *)&long long v31 = operator new(0x1000uLL);
            sub_1CD3F24DC((void **)a1, &v31);
            uint64_t v26 = *(void *)(a1 + 8);
            uint64_t v27 = *(void *)(a1 + 16) - v26 == 8 ? 511 : 512;
            uint64_t v9 = v27 + *(void *)(a1 + 32);
            *(void *)(a1 + 32) = v9;
            if (!--v12) {
              break;
            }
            if (v26 == *(void *)a1) {
              goto LABEL_43;
            }
          }
        }
      }
      for (*(void *)(a1 + 32) = v9 + (v11 << 9); v11; --v11)
      {
        uint64_t v29 = *(void *)(a1 + 16);
        *(void *)&long long v31 = *(void *)(v29 - 8);
        *(void *)(a1 + 16) = v29 - 8;
        sub_1CD3F24DC((void **)a1, &v31);
      }
    }
    else
    {
      BOOL v14 = v4 == v3;
      if (v13 >> 2 <= v12 + (v5 >> 3)) {
        unint64_t v15 = v12 + (v5 >> 3);
      }
      else {
        unint64_t v15 = v13 >> 2;
      }
      uint64_t v33 = a1 + 24;
      if (v15)
      {
        if (v15 >> 61) {
          sub_1CB833614();
        }
        uint64_t v16 = (char *)operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      unint64_t v17 = (v8 << 9) - v14;
      *(void *)&long long v31 = v16;
      *((void *)&v31 + 1) = v16;
      *(void *)&long long v32 = v16;
      *((void *)&v32 + 1) = &v16[8 * v15];
      do
      {
        unint64_t v30 = operator new(0x1000uLL);
        sub_1CD4A54E0((uint64_t)&v31, &v30);
        --v12;
      }
      while (v12);
      for (uint64_t i = *(void *)(a1 + 16); v11; --v11)
      {
        sub_1CB904CD8((uint64_t)&v31, (void *)(i - 8));
        uint64_t i = *(void *)(a1 + 16) - 8;
        *(void *)(a1 + 16) = i;
      }
      long long v19 = (void *)i;
      if (*(void *)(a1 + 8) != i)
      {
        long long v19 = *(void **)(a1 + 8);
        do
          sub_1CB904CD8((uint64_t)&v31, v19++);
        while (v19 != *(void **)(a1 + 16));
        uint64_t i = *(void *)(a1 + 8);
      }
      uint64_t v20 = *(void **)a1;
      long long v21 = v31;
      long long v22 = v32;
      *(void *)&long long v31 = *(void *)a1;
      *((void *)&v31 + 1) = i;
      uint64_t v23 = *(void *)(a1 + 24);
      uint64_t v24 = *(void *)(a1 + 32);
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v22;
      *(void *)&long long v32 = v19;
      *((void *)&v32 + 1) = v23;
      *(void *)(a1 + 32) = v17 + v24;
      if (v19 != (void *)i) {
        *(void *)&long long v32 = (char *)v19 + ((i - (void)v19 + 7) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v20) {
        operator delete(v20);
      }
    }
  }
}

char *sub_1CD4A5CD0(char *a1, char *__src, char *a3, char *a4, char *a5, char *__dst, unint64_t *a7)
{
  if (a4 != __src)
  {
    uint64_t v9 = __src;
    unint64_t v10 = a1;
    uint64_t v11 = ((uint64_t)&a4[-*(void *)a3] >> 3) + ((a3 - a1) << 6) - ((uint64_t)&__src[-*(void *)a1] >> 3);
    if (v11 >= 1)
    {
      do
      {
        uint64_t v13 = *(void *)v10;
        uint64_t v14 = *(void *)v10 + 4096;
        uint64_t v15 = (v14 - (uint64_t)v9) >> 3;
        if (v15 >= v11) {
          uint64_t v16 = v11;
        }
        else {
          uint64_t v16 = (v14 - (uint64_t)v9) >> 3;
        }
        if (v15 <= v11) {
          unint64_t v17 = *(void *)v10 + 4096;
        }
        else {
          unint64_t v17 = (unint64_t)&v9[8 * v11];
        }
        unint64_t v18 = *a7;
        if ((unint64_t)v9 <= *a7 && v18 < v17)
        {
          if (v9 != __dst)
          {
            uint64_t v20 = ((uint64_t)&__dst[-*(void *)a5] >> 3) - (((uint64_t)&v9[-v13] >> 3) + ((v10 - a5) << 6));
            if (v20)
            {
              uint64_t v30 = v20 + ((uint64_t)(v18 - v13) >> 3);
              if (v30 < 1) {
                unint64_t v18 = *(void *)&v10[-8 * ((unint64_t)(511 - v30) >> 9)] + 8 * (~(511 - (_WORD)v30) & 0x1FF);
              }
              else {
                unint64_t v18 = *(void *)&v10[((unint64_t)v30 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v30 & 0x1FF);
              }
            }
          }
          *a7 = v18;
        }
        if (v9 != (char *)v17)
        {
          long long v22 = *(char **)a5;
          a5 += 8;
          long long v21 = v22;
          uint64_t v23 = v9;
          while (1)
          {
            uint64_t v24 = v21 - __dst + 4096;
            if ((uint64_t)(v17 - (void)v23) >> 3 >= v24 >> 3) {
              uint64_t v25 = v24 >> 3;
            }
            else {
              uint64_t v25 = (uint64_t)(v17 - (void)v23) >> 3;
            }
            if (v25) {
              memmove(__dst, v23, 8 * v25);
            }
            v23 += 8 * v25;
            if (v23 == (char *)v17) {
              break;
            }
            uint64_t v26 = *(char **)a5;
            a5 += 8;
            long long v21 = v26;
            __dst = v26;
          }
          __dst += 8 * v25;
          if ((char *)(*((void *)a5 - 1) + 4096) == __dst) {
            __dst = *(char **)a5;
          }
          else {
            a5 -= 8;
          }
        }
        if (v16)
        {
          uint64_t v27 = v16 + ((uint64_t)&v9[-*(void *)v10] >> 3);
          if (v27 < 1)
          {
            unint64_t v29 = 511 - v27;
            v10 -= 8 * (v29 >> 9);
            uint64_t v9 = (char *)(*(void *)v10 + 8 * (~(_WORD)v29 & 0x1FF));
          }
          else
          {
            v10 += 8 * ((unint64_t)v27 >> 9);
            uint64_t v9 = (char *)(*(void *)v10 + 8 * (v27 & 0x1FF));
          }
        }
        BOOL v28 = v11 <= v16;
        v11 -= v16;
      }
      while (!v28);
    }
  }
  return a5;
}

void sub_1CD4A5EDC(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v3) {
    unint64_t v4 = a2;
  }
  else {
    unint64_t v4 = a2 + 1;
  }
  if ((v4 & 0x1FF) != 0) {
    unint64_t v5 = (v4 >> 9) + 1;
  }
  else {
    unint64_t v5 = v4 >> 9;
  }
  unint64_t v6 = *(void *)(a1 + 32);
  if (v5 >= v6 >> 9) {
    unint64_t v7 = v6 >> 9;
  }
  else {
    unint64_t v7 = v5;
  }
  if (v5 <= v6 >> 9)
  {
    for (*(void *)(a1 + 32) = v6 - (v7 << 9); v7; --v7)
    {
      long long v21 = *(void **)(a1 + 8);
      *(void *)&long long v27 = *v21;
      *(void *)(a1 + 8) = v21 + 1;
      sub_1CB904CD8(a1, &v27);
    }
  }
  else
  {
    unint64_t v8 = v5 - v7;
    uint64_t v9 = *(void *)(a1 + 24) - *(void *)a1;
    if (v5 - v7 <= (v9 >> 3) - (v3 >> 3))
    {
      if (v8)
      {
        while (*(void *)(a1 + 24) != *(void *)(a1 + 16))
        {
          *(void *)&long long v27 = operator new(0x1000uLL);
          sub_1CD3F23B4(a1, &v27);
          --v5;
          if (!--v8) {
            goto LABEL_43;
          }
        }
        for (uint64_t i = 0; i != v8; ++i)
        {
          *(void *)&long long v27 = operator new(0x1000uLL);
          sub_1CD3F24DC((void **)a1, &v27);
          if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
            uint64_t v23 = 511;
          }
          else {
            uint64_t v23 = 512;
          }
          uint64_t v24 = v23 + *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v24;
        }
        unint64_t v7 = v5;
      }
      else
      {
LABEL_43:
        uint64_t v24 = *(void *)(a1 + 32);
      }
      for (*(void *)(a1 + 32) = v24 - (v7 << 9); v7; --v7)
      {
        uint64_t v25 = *(void **)(a1 + 8);
        *(void *)&long long v27 = *v25;
        *(void *)(a1 + 8) = v25 + 1;
        sub_1CB904CD8(a1, &v27);
      }
    }
    else
    {
      uint64_t v10 = v3 >> 3;
      if (v9 >> 2 <= v8 + (v3 >> 3)) {
        unint64_t v11 = v8 + v10;
      }
      else {
        unint64_t v11 = v9 >> 2;
      }
      uint64_t v29 = a1 + 24;
      if (v11)
      {
        if (v11 >> 61) {
          sub_1CB833614();
        }
        unint64_t v12 = (char *)operator new(8 * v11);
      }
      else
      {
        unint64_t v12 = 0;
      }
      uint64_t v13 = v7 << 9;
      *(void *)&long long v27 = v12;
      *((void *)&v27 + 1) = &v12[8 * (v10 - v7)];
      *(void *)&long long v28 = *((void *)&v27 + 1);
      *((void *)&v28 + 1) = &v12[8 * v11];
      do
      {
        uint64_t v26 = operator new(0x1000uLL);
        sub_1CD4A54E0((uint64_t)&v27, &v26);
        --v8;
      }
      while (v8);
      for (uint64_t j = *(char **)(a1 + 8); v7; --v7)
      {
        sub_1CB904CD8((uint64_t)&v27, j);
        uint64_t j = (char *)(*(void *)(a1 + 8) + 8);
        *(void *)(a1 + 8) = j;
      }
      uint64_t v15 = j;
      if (*(char **)(a1 + 16) != j)
      {
        uint64_t v15 = *(char **)(a1 + 16);
        do
        {
          v15 -= 8;
          sub_1CD4A5618((const void **)&v27, v15);
        }
        while (v15 != *(char **)(a1 + 8));
        uint64_t j = *(char **)(a1 + 16);
      }
      uint64_t v16 = *(void **)a1;
      long long v17 = v27;
      long long v18 = v28;
      *(void *)&long long v27 = *(void *)a1;
      *((void *)&v27 + 1) = v15;
      uint64_t v19 = *(void *)(a1 + 24);
      uint64_t v20 = *(void *)(a1 + 32);
      *(_OWORD *)a1 = v17;
      *(_OWORD *)(a1 + 16) = v18;
      *(void *)&long long v28 = j;
      *((void *)&v28 + 1) = v19;
      *(void *)(a1 + 32) = v20 - v13;
      if (j != v15) {
        *(void *)&long long v28 = &j[(v15 - j + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v16) {
        operator delete(v16);
      }
    }
  }
}

uint64_t sub_1CD4A616C(uint64_t result, char *a2, unint64_t a3, char *a4, uint64_t a5, char *a6, void *a7, unint64_t *a8)
{
  if (a5 != a3)
  {
    uint64_t v8 = ((a5 - *(void *)a4) >> 3) + ((a4 - a2) << 6) - ((uint64_t)(a3 - *(void *)a2) >> 3);
    if (v8 >= 1)
    {
      do
      {
        uint64_t v9 = *(void *)a2;
        uint64_t v10 = *(void *)a2 + 4096;
        uint64_t v11 = (uint64_t)(v10 - a3) >> 3;
        unint64_t v12 = a3 + 8 * v8;
        if (v11 <= v8) {
          unint64_t v12 = *(void *)a2 + 4096;
        }
        if (v11 >= v8) {
          uint64_t v13 = v8;
        }
        else {
          uint64_t v13 = (uint64_t)(v10 - a3) >> 3;
        }
        unint64_t v14 = *a8;
        if (a3 <= *a8 && v14 < v12)
        {
          if (a7 != (void *)a3)
          {
            uint64_t v16 = (((uint64_t)a7 - *(void *)a6) >> 3) + ((a6 - a2) << 6);
            if (v16 != (uint64_t)(a3 - v9) >> 3)
            {
              uint64_t v24 = v16 - ((uint64_t)(a3 - v9) >> 3) + ((uint64_t)(v14 - v9) >> 3);
              if (v24 < 1) {
                unint64_t v14 = *(void *)&a2[-8 * ((unint64_t)(511 - v24) >> 9)] + 8 * (~(511 - (_WORD)v24) & 0x1FF);
              }
              else {
                unint64_t v14 = *(void *)&a2[((unint64_t)v24 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v24 & 0x1FF);
              }
            }
          }
          *a8 = v14;
        }
        if (a3 != v12)
        {
          uint64_t v17 = *(void *)(result + 40);
          long long v18 = (uint64_t *)a3;
          do
          {
            uint64_t v19 = *v18++;
            *a7++ = v19;
            if ((void *)((char *)a7 - *(void *)a6) == (void *)4096)
            {
              uint64_t v20 = (void *)*((void *)a6 + 1);
              a6 += 8;
              a7 = v20;
            }
            ++v17;
          }
          while (v18 != (uint64_t *)v12);
          *(void *)(result + 40) = v17;
        }
        if (v13)
        {
          uint64_t v21 = v13 + ((uint64_t)(a3 - *(void *)a2) >> 3);
          if (v21 < 1)
          {
            unint64_t v23 = 511 - v21;
            a2 -= 8 * (v23 >> 9);
            a3 = *(void *)a2 + 8 * (~(_WORD)v23 & 0x1FF);
          }
          else
          {
            a2 += 8 * ((unint64_t)v21 >> 9);
            a3 = *(void *)a2 + 8 * (v21 & 0x1FF);
          }
        }
        BOOL v22 = v8 <= v13;
        v8 -= v13;
      }
      while (!v22);
    }
  }
  return result;
}

uint64_t sub_1CD4A62E4(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12 = 0;
  llvm::cl::parser<float>::parse(a1 + 152, (void *)a1, a3, a4, a5, a6, (float *)&v12);
  uint64_t v9 = v8;
  if (v8) {
    return v9;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v10 = *(void *)(a1 + 184);
  if (v10)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v10 + 48))(v10, &v12);
    return v9;
  }
  sub_1CB920400();
  return sub_1CD4A6378();
}

uint64_t sub_1CD4A6378()
{
  return 2;
}

uint64_t sub_1CD4A6380(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1CD4A638C(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

float sub_1CD4A639C(uint64_t a1, int a2, int a3, float result)
{
  if (a3)
  {
    double result = *(float *)(a1 + 128);
LABEL_3:
    int v5 = *(_DWORD *)(a1 + 144);
    char v6 = *(unsigned char *)(a1 + 148);
    unint64_t v4 = &unk_1F2605730;
    llvm::cl::parser<float>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, (uint64_t)&v4, a2, result);
    return result;
  }
  if (*(unsigned char *)(a1 + 148))
  {
    double result = *(float *)(a1 + 128);
    if (*(float *)(a1 + 144) != result) {
      goto LABEL_3;
    }
  }
  return result;
}

BOOL sub_1CD4A6424(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(float *)(a1 + 8) != *(float *)(a2 + 8);
}

void sub_1CD4A6454()
{
}

void *sub_1CD4A6468()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F2605750;
  return result;
}

void sub_1CD4A64A0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2605750;
}

void llvm::createMemDepPrinter(llvm *this)
{
}

void llvm::createMemDerefPrinter(llvm *this)
{
}

BOOL llvm::isAllocationFn(uint64_t a1, uint64_t (*a2)(uint64_t, unint64_t), uint64_t a3)
{
  int v5 = byte_1EBD04470;
  char v11 = 0;
  unint64_t v6 = sub_1CC0960E8(a1, &v11);
  BOOL result = 0;
  if (v6 && !v11)
  {
    uint64_t v8 = (uint64_t *)a2(a3, v6);
    if (v5) {
      int v9 = 59;
    }
    else {
      int v9 = 63;
    }
    sub_1CC095384(v6, v9, v8, (uint64_t)v10);
    return v10[24] != 0;
  }
  return result;
}

uint64_t llvm::isReallocLikeFn(unint64_t a1, uint64_t *a2)
{
  sub_1CC095384(a1, 16, a2, (uint64_t)v3);
  return v3[24];
}

uint64_t llvm::isAllocRemovable(uint64_t a1, uint64_t *a2)
{
  if (byte_1EBD04470) {
    int v3 = 43;
  }
  else {
    int v3 = 47;
  }
  sub_1CC095244(a1, v3, a2, v5);
  return v5[24];
}

llvm::UndefValue *llvm::getInitialValueOfAllocation(uint64_t a1, uint64_t *a2, llvm::UndefValue *a3)
{
  sub_1CC095244(a1, 3, a2, v10);
  if (v11 || !byte_1EBD04470 && (sub_1CC095244(a1, 4, a2, v10), v11))
  {
    return llvm::UndefValue::get(a3, v6);
  }
  else
  {
    sub_1CC095244(a1, 8, a2, v10);
    if (v11)
    {
      return llvm::Constant::getNullValue(a3, v8, v9);
    }
    else
    {
      return 0;
    }
  }
}

BOOL llvm::isLibFreeFunction(llvm::Function *a1, int a2)
{
  uint64_t v2 = 0;
  while (dword_1CFAC3D00[v2] != a2)
  {
    v2 += 3;
    if (v2 == 90) {
      return 0;
    }
  }
  uint64_t v4 = *((void *)a1 + 3);
  int v5 = *(void **)(v4 + 16);
  if (*(unsigned char *)(*v5 + 8) != 7 || *(_DWORD *)(v4 + 12) - 1 != dword_1CFAC3D00[v2 + 1]) {
    return 0;
  }
  uint64_t v6 = v5[1];
  uint64_t Context = llvm::Function::getContext(a1);
  return v6 == llvm::PointerType::get((llvm::PointerType *)(*(void *)Context + 1912), 0);
}

llvm::Value *llvm::lowerObjectSizeCall(llvm::Instruction *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return llvm::lowerObjectSizeCall(a1, a2, a3, 0, a4, a6, a7);
}

llvm::Value *llvm::lowerObjectSizeCall(llvm::Instruction *this, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  v59[56] = *(llvm::IntegerType **)MEMORY[0x1E4F143B8];
  int v12 = (char *)this - 32 * (*((_DWORD *)this + 5) & 0x7FFFFFF);
  uint64_t v13 = *((void *)v12 + 4);
  unint64_t v14 = (llvm::APInt *)(v13 + 24);
  unsigned int v15 = *(_DWORD *)(v13 + 32);
  if (v15 > 0x40) {
    BOOL v16 = llvm::APInt::countLeadingZerosSlowCase(v14) == v15;
  }
  else {
    BOOL v16 = *(void *)v14 == 0;
  }
  uint64_t v17 = v16;
  uint64_t v18 = 1;
  if (v17) {
    uint64_t v18 = 2;
  }
  if (a5) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = *((void *)v12 + 8);
  uint64_t v21 = (llvm::APInt *)(v20 + 24);
  unsigned int v22 = *(_DWORD *)(v20 + 32);
  if (v22 > 0x40) {
    BOOL v23 = llvm::APInt::countLeadingZerosSlowCase(v21) == v22 - 1;
  }
  else {
    BOOL v23 = *(void *)v21 == 1;
  }
  int v24 = v23;
  BOOL v16 = v24 == 0;
  uint64_t v25 = 0x10000;
  if (v16) {
    uint64_t v25 = 0;
  }
  uint64_t v26 = v25 | v19;
  long long v27 = *(unsigned int **)this;
  uint64_t v28 = *((void *)v12 + 12);
  uint64_t v29 = (llvm::APInt *)(v28 + 24);
  unsigned int v30 = *(_DWORD *)(v28 + 32);
  if (v30 > 0x40)
  {
    if (llvm::APInt::countLeadingZerosSlowCase(v29) != v30)
    {
LABEL_23:
      Function = (llvm::Function *)llvm::Instruction::getFunction(this);
      uint64_t Context = llvm::Function::getContext(Function);
      llvm::ObjectSizeOffsetEvaluator::ObjectSizeOffsetEvaluator((uint64_t)v59, a2, a3, Context, v26, a4);
      uint64_t v33 = (uint64_t)llvm::ObjectSizeOffsetEvaluator::compute((llvm::ObjectSizeOffsetEvaluator *)v59, *((llvm::Value **)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF)));
      if (v33 | v34)
      {
        uint64_t v35 = v33;
        uint64_t v36 = v34;
        v49[1] = &unk_1F2602158;
        v49[2] = a2;
        v49[0] = &unk_1F2617008;
        v50[0] = v51;
        v50[1] = (void *)0x200000000;
        v51[6] = Context;
        v51[7] = v57;
        v51[8] = &v58;
        v51[9] = 0;
        int v52 = 0;
        __int16 v53 = 512;
        char v54 = 7;
        v51[4] = 0;
        v51[5] = 0;
        uint64_t v55 = 0;
        uint64_t v56 = 0;
        v57[0] = &unk_1F2602158;
        v57[1] = a2;
        int v58 = &unk_1F2617008;
        llvm::IRBuilderDefaultInserter::~IRBuilderDefaultInserter((llvm::IRBuilderDefaultInserter *)v49);
        sub_1CC096F34((uint64_t)v50, (uint64_t)this);
        __int16 v48 = 257;
        uint64_t v37 = (unsigned __int8 *)sub_1CB84494C((uint64_t)v50, v35, v36, (uint64_t)v47, 0, 0);
        __int16 v48 = 257;
        uint64_t v38 = sub_1CB845F20((uint64_t)v50, 36, (void *)v35, v36, (uint64_t)v47);
        __int16 v48 = 257;
        uint64_t v39 = sub_1CB844B8C((uint64_t)v50, v37, (uint64_t)v27, (uint64_t)v47);
        uint64_t v40 = (llvm::Value *)llvm::ConstantInt::get((llvm::ConstantInt *)v27, 0, 0);
        __int16 v48 = 257;
        Select = llvm::IRBuilderBase::CreateSelect((llvm::IRBuilderBase *)v50, v38, v40, v39, (const llvm::Twine *)v47, 0);
        if (*(unsigned __int8 *)(v35 + 16) > 0x14u || *(unsigned __int8 *)(v36 + 16) >= 0x15u)
        {
          int v42 = llvm::ConstantInt::get((llvm::ConstantInt *)v27, 0xFFFFFFFFFFFFFFFFLL, 0);
          __int16 v48 = 257;
          uint64_t v43 = sub_1CB845F20((uint64_t)v50, 33, Select, (uint64_t)v42, (uint64_t)v47);
          llvm::IRBuilderBase::CreateAssumption((uint64_t *)v50, (uint64_t)v43, 0, 0);
        }
        sub_1CD4A75C4(v50);
        sub_1CD4A7604((uint64_t)v59);
        return Select;
      }
      sub_1CD4A7604((uint64_t)v59);
      if (!a5) {
        return 0;
      }
      return (llvm::Value *)llvm::ConstantInt::get((llvm::ConstantInt *)v27, v17 << 63 >> 63, 0);
    }
  }
  else if (*(void *)v29)
  {
    goto LABEL_23;
  }
  v59[0] = 0;
  if (!llvm::getObjectSize(*(llvm::Value **)v12, v59, a2, a3, v26, a4, a7)
    || (unint64_t v44 = v27[2], v45 = v59[0], !(v44 >> 14))
    && (llvm::IntegerType *)(0xFFFFFFFFFFFFFFFFLL >> -(uint64_t)(v44 >> 8)) < v59[0])
  {
    if ((a5 & 1) == 0) {
      return 0;
    }
    return (llvm::Value *)llvm::ConstantInt::get((llvm::ConstantInt *)v27, v17 << 63 >> 63, 0);
  }

  return (llvm::Value *)llvm::ConstantInt::get((llvm::ConstantInt *)v27, (unint64_t)v45, 0);
}

uint64_t sub_1CD4A6C40(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CD4A77A4(a1, a2, &v6)) {
    return v6;
  }
  if (*(unsigned char *)a1)
  {
    uint64_t v4 = a1 + 8;
    unsigned int v5 = 8;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unsigned int v5 = *(_DWORD *)(a1 + 16);
  }
  return v4 + 40 * v5;
}

unint64_t *sub_1CD4A6CA4(unint64_t *result, unint64_t a2)
{
  uint64_t v2 = *((unsigned int *)result + 2);
  unint64_t v3 = *result;
  if (v2 >= *((_DWORD *)result + 3))
  {
    unint64_t v5 = v3 + 32 * v2;
    if (v3 > a2 || v5 <= a2) {
      sub_1CD4A7D00();
    }
    sub_1CD4A7D00();
  }
  unint64_t v4 = v3 + 32 * *((unsigned int *)result + 2);
  *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)unint64_t v4 = *(void *)a2;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(v4 + 24) = *(_DWORD *)(a2 + 24);
  *(void *)(v4 + 16) = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = 0;
  ++*((_DWORD *)result + 2);
  return result;
}

uint64_t llvm::ObjectSizeOffsetVisitor::visitSelectInst@<X0>(llvm::ObjectSizeOffsetVisitor *this@<X0>, llvm::Value **a2@<X1>, uint64_t a3@<X8>)
{
  llvm::ObjectSizeOffsetVisitor::compute(v8, this, *(a2 - 8));
  llvm::ObjectSizeOffsetVisitor::compute(v7, this, *(a2 - 4));
  llvm::ObjectSizeOffsetVisitor::combineSizeOffset((uint64_t)this, (uint64_t)v8, (uint64_t)v7, a3);
  sub_1CB8F0DC4((uint64_t)v7);
  return sub_1CB8F0DC4((uint64_t)v8);
}

llvm::Instruction *sub_1CD4A6DC8(uint64_t **a1, llvm::CallBase *a2)
{
  switch(*((unsigned char *)a2 + 16))
  {
    case '!':
    case '\'':
    case 'T':
      BOOL result = llvm::ObjectSizeOffsetEvaluator::visitCallBase(a1, a2);
      break;
    case ';':
      BOOL result = llvm::ObjectSizeOffsetEvaluator::visitAllocaInst((llvm::DataLayout **)a1, a2);
      break;
    case 'S':
      BOOL result = llvm::ObjectSizeOffsetEvaluator::visitPHINode((llvm::ObjectSizeOffsetEvaluator *)a1, a2);
      break;
    case 'U':
      BOOL result = llvm::ObjectSizeOffsetEvaluator::visitSelectInst((llvm::ObjectSizeOffsetEvaluator *)a1, (llvm::Value **)a2);
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

llvm::Instruction *llvm::ObjectSizeOffsetEvaluator::visitAllocaInst(llvm::DataLayout **this, llvm::AllocaInst *a2)
{
  uint64_t v4 = *((void *)a2 + 8);
  unsigned int v5 = *(unsigned __int8 *)(v4 + 8);
  if (v5 > 0x11) {
    goto LABEL_9;
  }
  if (((1 << v5) & 0xAC7F) == 0)
  {
    if (((1 << v5) & 0x30000) != 0)
    {
LABEL_7:
      if (llvm::Type::isSizedDerivedType(v4, 0)) {
        goto LABEL_3;
      }
      return 0;
    }
LABEL_9:
    if ((v5 & 0xFE) != 0x12 && v5 != 21) {
      return 0;
    }
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v6 = (unsigned __int8 *)*((void *)a2 - 4);
  uint64_t IntPtrType = llvm::DataLayout::getIntPtrType(*this, **(llvm::LLVMContext ***)a2, 0);
  __int16 v22 = 257;
  uint64_t v8 = sub_1CB844B8C((uint64_t)(this + 3), v6, IntPtrType, (uint64_t)v21);
  int v9 = *(llvm::ConstantInt **)v8;
  uint64_t v10 = *this;
  char v11 = (llvm::Type *)*((void *)a2 + 8);
  unint64_t v12 = (unint64_t)(sub_1CB83544C((uint64_t)*this, (uint64_t)v11) + 7) >> 3;
  BOOL v14 = v13 == 1;
  char Alignment = llvm::DataLayout::getAlignment(v10, v11, 1);
  unint64_t v17 = ((1 << Alignment) + v12 - 1) & -(1 << Alignment);
  if (v14) {
  uint64_t v18 = llvm::ConstantInt::get(v9, v17, 0);
  }
  __int16 v22 = 257;
  return sub_1CC09A1EC((uint64_t)(this + 3), (uint64_t)v18, (uint64_t)v8, (uint64_t)v21, 0, 0);
}

llvm::Instruction *llvm::ObjectSizeOffsetEvaluator::visitCallBase(uint64_t **this, llvm::CallBase *a2)
{
  sub_1CC095D98((uint64_t)v13, (uint64_t)a2, this[1]);
  uint64_t v4 = 0;
  if (v16)
  {
    if (v13[0] != 32)
    {
      unsigned int v5 = (unsigned __int8 *)*((void *)a2 + 4 * v14 + -4 * (*((_DWORD *)a2 + 5) & 0x7FFFFFF));
      uint64_t v6 = (uint64_t)this[25];
      __int16 v12 = 257;
      uint64_t v4 = sub_1CB844B8C((uint64_t)(this + 3), v5, v6, (uint64_t)v11);
      if ((v15 & 0x80000000) == 0)
      {
        unint64_t v7 = (unsigned __int8 *)*((void *)a2 + 4 * v15 + -4 * (*((_DWORD *)a2 + 5) & 0x7FFFFFF));
        uint64_t v8 = (uint64_t)this[25];
        __int16 v12 = 257;
        int v9 = sub_1CB844B8C((uint64_t)(this + 3), v7, v8, (uint64_t)v11);
        __int16 v12 = 257;
        return sub_1CC09A1EC((uint64_t)(this + 3), (uint64_t)v4, (uint64_t)v9, (uint64_t)v11, 0, 0);
      }
    }
  }
  return v4;
}

llvm::Value *sub_1CD4A7084(uint64_t a1, uint64_t a2, llvm::GEPOperator *this, unsigned __int8 a4)
{
  int v8 = *((_DWORD *)this + 5);
  if ((v8 & 0x40000000) != 0) {
    int v9 = (unsigned __int8 **)*((void *)this - 1);
  }
  else {
    int v9 = (unsigned __int8 **)((char *)this - 32 * (v8 & 0x7FFFFFF));
  }
  uint64_t SourceElementType = llvm::GEPOperator::getSourceElementType(this);
  int v11 = *((_DWORD *)this + 5);
  if ((v11 & 0x40000000) != 0) {
    __int16 v12 = (char *)*((void *)this - 1);
  }
  else {
    __int16 v12 = (char *)this - 32 * (v11 & 0x7FFFFFF);
  }
  int v13 = (llvm::Constant **)(v12 + 32);
  uint64_t v14 = SourceElementType | 4;
  uint64_t v15 = *(void *)this;
  Name = llvm::Value::getName(this);
  return sub_1CC09AC18(a1, a2, v13, v14, v9 + 4, &v9[4 * (v8 & 0x7FFFFFF)], v15, v18, Name, v17, (*((unsigned char *)this + 17) & 2) != 0, a4);
}

llvm::Instruction *llvm::ObjectSizeOffsetEvaluator::visitPHINode(llvm::ObjectSizeOffsetEvaluator *this, llvm::PHINode *a2)
{
  uint64_t v4 = (char *)this + 24;
  uint64_t v5 = *((void *)this + 25);
  int v6 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  __int16 v37 = 257;
  unint64_t v7 = sub_1CB93113C((uint64_t)this + 24, v5, v6, (uint64_t)v36);
  uint64_t v8 = *((void *)this + 25);
  int v9 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  __int16 v37 = 257;
  uint64_t v10 = sub_1CB93113C((uint64_t)v4, v8, v9, (uint64_t)v36);
  v36[0] = (uint64_t)a2;
  int v11 = sub_1CD4A7F38((uint64_t)this + 216, v36);
  sub_1CC002D7C((llvm::ValueHandleBase *)(v11 + 1), (uint64_t)v7);
  sub_1CC002D7C((llvm::ValueHandleBase *)(v11 + 4), (uint64_t)v10);
  uint64_t v13 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
  if (v13)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 32 * v13;
    do
    {
      int v17 = *((_DWORD *)a2 + 5);
      if ((v17 & 0x40000000) != 0) {
        uint64_t v18 = (char *)*((void *)a2 - 1);
      }
      else {
        uint64_t v18 = (char *)a2 - 32 * (v17 & 0x7FFFFFF);
      }
      uint64_t FirstInsertionPt = llvm::BasicBlock::getFirstInsertionPt(*(llvm::BasicBlock **)&v18[32
                                                                                        * *((unsigned int *)a2 + 15)
                                                                                        + v14]);
      if (FirstInsertionPt) {
        uint64_t v20 = FirstInsertionPt - 24;
      }
      else {
        uint64_t v20 = 0;
      }
      sub_1CC096F34((uint64_t)v4, v20);
      int v21 = *((_DWORD *)a2 + 5);
      if ((v21 & 0x40000000) != 0) {
        __int16 v22 = (char *)*((void *)a2 - 1);
      }
      else {
        __int16 v22 = (char *)a2 - 32 * (v21 & 0x7FFFFFF);
      }
      uint64_t v23 = llvm::ObjectSizeOffsetEvaluator::compute_(this, *(llvm::Value **)&v22[v15]);
      if (v23) {
        BOOL v25 = v24 == 0;
      }
      else {
        BOOL v25 = 1;
      }
      if (v25)
      {
        uint64_t v33 = llvm::UndefValue::get(*((llvm::UndefValue **)this + 25), v24);
        llvm::Value::doRAUW(v10, v33, (llvm::Value *)1);
        llvm::Instruction::eraseFromParent(v10);
      }
      uint64_t v26 = (uint64_t)v24;
      int v27 = *((_DWORD *)a2 + 5);
      if ((v27 & 0x40000000) != 0) {
        uint64_t v28 = (char *)*((void *)a2 - 1);
      }
      else {
        uint64_t v28 = (char *)a2 - 32 * (v27 & 0x7FFFFFF);
      }
      sub_1CC09A30C((uint64_t)v7, v23, *(void *)&v28[32 * *((unsigned int *)a2 + 15) + v14]);
      int v29 = *((_DWORD *)a2 + 5);
      if ((v29 & 0x40000000) != 0) {
        unsigned int v30 = (char *)*((void *)a2 - 1);
      }
      else {
        unsigned int v30 = (char *)a2 - 32 * (v29 & 0x7FFFFFF);
      }
      sub_1CC09A30C((uint64_t)v10, v26, *(void *)&v30[32 * *((unsigned int *)a2 + 15) + v14]);
      v15 += 32;
      v14 += 8;
    }
    while (v16 != v15);
  }
  long long v31 = llvm::PHINode::hasConstantValue(v7, v12);
  if (v31)
  {
    llvm::Value::doRAUW(v7, v31, (llvm::Value *)1);
    llvm::Instruction::eraseFromParent(v7);
  }
  uint64_t v34 = llvm::PHINode::hasConstantValue(v10, v32);
  if (v34)
  {
    llvm::Value::doRAUW(v10, v34, (llvm::Value *)1);
    llvm::Instruction::eraseFromParent(v10);
  }
  return v7;
}

llvm::Value *llvm::ObjectSizeOffsetEvaluator::visitSelectInst(llvm::ObjectSizeOffsetEvaluator *this, llvm::Value **a2)
{
  Select = (llvm::Value *)llvm::ObjectSizeOffsetEvaluator::compute_(this, *(a2 - 8));
  int v6 = v5;
  unint64_t v7 = (llvm::Value *)llvm::ObjectSizeOffsetEvaluator::compute_(this, *(a2 - 4));
  if (Select) {
    BOOL v9 = v6 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    return 0;
  }
  uint64_t v10 = v8;
  if (!v7 || v8 == 0) {
    return 0;
  }
  if (Select != v7 || v6 != v8)
  {
    uint64_t v14 = (llvm::ObjectSizeOffsetEvaluator *)((char *)this + 24);
    uint64_t v15 = *(a2 - 12);
    __int16 v18 = 257;
    Select = llvm::IRBuilderBase::CreateSelect(v14, v15, Select, v7, (const llvm::Twine *)v17, 0);
    uint64_t v16 = *(a2 - 12);
    __int16 v18 = 257;
    llvm::IRBuilderBase::CreateSelect(v14, v16, v6, v10, (const llvm::Twine *)v17, 0);
  }
  return Select;
}

void **sub_1CD4A75C4(void **a1)
{
  if (*a1 != a1 + 2) {
    free(*a1);
  }
  return a1;
}

uint64_t sub_1CD4A7604(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 360);
  if (v2 != *(void **)(a1 + 352)) {
    free(v2);
  }
  unint64_t v3 = *(void **)(a1 + 248);
  if (v3 != *(void **)(a1 + 240)) {
    free(v3);
  }
  sub_1CD4A765C((uint64_t *)(a1 + 216));
  sub_1CC09A504((void **)(a1 + 24));
  return a1;
}

uint64_t *sub_1CD4A765C(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 56 * v2;
    uint64_t v5 = (llvm::ValueHandleBase *)(v3 + 8);
    do
    {
      if ((*((void *)v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v5 = sub_1CD4A76CC(v5);
      }
      uint64_t v5 = (llvm::ValueHandleBase *)((char *)v5 + 56);
      v4 -= 56;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

llvm::ValueHandleBase *sub_1CD4A76CC(llvm::ValueHandleBase *this)
{
  uint64_t v2 = *((void *)this + 5);
  if (v2 != -8192 && v2 != -4096 && v2 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList((void *)this + 3);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(this);
  }
  return this;
}

void *sub_1CD4A7730(_DWORD *a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD4A77A4((uint64_t)a1, *a2, &v8);
  uint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4A7858(a1, a2, v8);
    uint64_t v7 = *a2;
    *((_DWORD *)v5 + 4) = 1;
    *uint64_t v5 = v7;
    v5[1] = 0;
    *((_DWORD *)v5 + 8) = 1;
    v5[3] = 0;
  }
  return v5;
}

uint64_t sub_1CD4A77A4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 40 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 40 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD4A7858(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4A7918((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A77A4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD4A7918(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v2 > 8)
    {
      *(void *)(a1 + 8) = operator new(40 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4A7AF4(a1, v7, v7 + 40 * v8);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  uint64_t v10 = v14;
  do
  {
    uint64_t v11 = a1 + v9;
    uint64_t v12 = *(void *)(a1 + v9 + 8);
    if ((v12 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *(void *)uint64_t v10 = v12;
      *((_DWORD *)v10 + 4) = *(_DWORD *)(v11 + 24);
      *((void *)v10 + 1) = *(void *)(v11 + 16);
      *(_DWORD *)(v11 + 24) = 0;
      *((_DWORD *)v10 + 8) = *(_DWORD *)(v11 + 40);
      *((void *)v10 + 3) = *(void *)(v11 + 32);
      *(_DWORD *)(v11 + 40) = 0;
      v10 += 40;
      sub_1CB8F0DC4(v11 + 16);
    }
    v9 += 40;
  }
  while (v9 != 320);
  if (v2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(40 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  return sub_1CD4A7AF4(a1, (uint64_t)v14, (uint64_t)v10);
}

uint64_t sub_1CD4A7AF4(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    unsigned int v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 328);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    unsigned int v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[5 * v7];
  }
  do
  {
    *unsigned int v8 = -4096;
    v8 += 5;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      sub_1CD4A77A4((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *(void *)a2;
      *((_DWORD *)v11 + 4) = *(_DWORD *)(a2 + 16);
      v11[1] = *(void *)(a2 + 8);
      *(_DWORD *)(a2 + 16) = 0;
      *((_DWORD *)v11 + 8) = *(_DWORD *)(a2 + 32);
      void v11[3] = *(void *)(a2 + 24);
      *(_DWORD *)(a2 + 32) = 0;
      *v5 += 2;
      uint64_t result = sub_1CB8F0DC4(a2 + 8);
    }
    a2 += 40;
  }
  return result;
}

void sub_1CD4A7BEC(_DWORD **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBD043F0, 0, 0);
  byte_1EBD04470 = 0;
  qword_1EBD04478 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD04480 = 0;
  qword_1EBD043F0[0] = (uint64_t)&unk_1F26440A0;
  qword_1EBD04488 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD04490 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD044A8 = (uint64_t)&qword_1EBD04490;
  llvm::cl::Option::setArgStr(v4, "disable-aligned-alloc-awareness", 0x1FuLL);
  byte_1EBD04470 = **a1 != 0;
  byte_1EBD04481 = 1;
  byte_1EBD04480 = byte_1EBD04470;
  xmmword_1EBD04410 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBD043F0);
}

void sub_1CD4A7D00()
{
}

uint64_t sub_1CD4A7D70(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v3 = a2 + 16;
    uint64_t v4 = (_DWORD *)(*(void *)result + 24);
    uint64_t v5 = 32 * v2;
    do
    {
      *(_DWORD *)(v3 - 8) = *(v4 - 4);
      *(void *)(v3 - 16) = *((void *)v4 - 3);
      *(v4 - 4) = 0;
      *(_DWORD *)(v3 + 8) = *v4;
      *(void *)uint64_t v3 = *((void *)v4 - 1);
      v3 += 32;
      *uint64_t v4 = 0;
      v4 += 8;
      v5 -= 32;
    }
    while (v5);
    uint64_t v6 = *(unsigned int *)(result + 8);
    if (v6)
    {
      uint64_t v7 = 32 * v6;
      uint64_t v8 = *(void *)result - 32;
      do
      {
        uint64_t result = sub_1CB8F0DC4(v8 + v7);
        v7 -= 32;
      }
      while (v7);
    }
  }
  return result;
}

uint64_t sub_1CD4A7DF8(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

uint64_t sub_1CD4A7E34(uint64_t result)
{
  if (*(unsigned char *)result)
  {
    uint64_t v2 = result + 8;
    uint64_t v1 = 8;
  }
  else
  {
    uint64_t v1 = *(unsigned int *)(result + 16);
    if (!v1) {
      return result;
    }
    uint64_t v2 = *(void *)(result + 8);
  }
  uint64_t v3 = 40 * v1;
  uint64_t result = v2 + 8;
  do
  {
    if ((*(void *)(result - 8) | 0x1000) != 0xFFFFFFFFFFFFF000) {
      uint64_t result = sub_1CB8F0DC4(result);
    }
    result += 40;
    v3 -= 40;
  }
  while (v3);
  return result;
}

uint64_t sub_1CD4A7E9C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 56 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 56 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD4A7F38(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD4A7FB4(a1, a2, v7);
    *unsigned int v5 = *a2;
    v5[1] = 6;
    void v5[2] = 0;
    v5[3] = 0;
    v5[4] = 6;
    v5[5] = 0;
    v5[6] = 0;
  }
  return v5;
}

void *sub_1CD4A7FB4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4A8068(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4A8068(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4A8140((llvm::ValueHandleBase *)a1, v4, &v4[7 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

llvm::ValueHandleBase *sub_1CD4A8140(llvm::ValueHandleBase *result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v5 = result;
  *((void *)result + 1) = 0;
  uint64_t v6 = *((unsigned int *)result + 4);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      sub_1CD4A7E9C(*(void *)v5, *((_DWORD *)v5 + 4), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      sub_1CC09AB4C((unint64_t *)v10 + 1, a2 + 1);
      ++*((_DWORD *)v5 + 2);
      uint64_t result = sub_1CD4A76CC((llvm::ValueHandleBase *)(a2 + 1));
    }
    a2 += 7;
  }
  return result;
}

uint64_t sub_1CD4A8208(uint64_t a1, uint64_t a2, uint64_t *a3, long long *a4)
{
  unsigned int v13 = 0;
  uint64_t result = sub_1CC0A2428(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v13);
  uint64_t v9 = v13;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4A8858(a2, a3, v13);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    long long v12 = *a4;
    *(void *)(result + 24) = *((void *)a4 + 2);
    *(_OWORD *)(result + 8) = v12;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 32 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void llvm::initializeMemoryDependenceWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC69C0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0A12A8;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCC69C0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::MemoryDependenceWrapperPass *llvm::MemoryDependenceWrapperPass::MemoryDependenceWrapperPass(llvm::MemoryDependenceWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MemoryDependenceWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2605968;
  *((unsigned char *)this + 32) = 0;
  *((unsigned char *)this + 440) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC69C0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0A12A8;
    v5[1] = &PassRegistry;
    char v4 = v5;
    std::__call_once(&qword_1EBCC69C0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::MemoryDependenceWrapperPass::releaseMemory(uint64_t this)
{
  if (*(unsigned char *)(this + 440))
  {
    uint64_t v1 = this;
    this = sub_1CC0A20B8(this + 32);
    *(unsigned char *)(v1 + 440) = 0;
  }
  return this;
}

llvm::AnalysisUsage *llvm::MemoryDependenceWrapperPass::getAnalysisUsage(llvm::MemoryDependenceWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::PhiValuesWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AAResultsWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
}

void llvm::MemoryDependenceWrapperPass::runOnFunction(llvm::MemoryDependenceWrapperPass *this, llvm::Function *a2)
{
  char v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(char **)v5 != llvm::AAResultsWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  (*(void (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::AAResultsWrapperPass::ID);
  uint64_t v8 = (uint64_t *)*((void *)this + 1);
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  if (v9 == v10)
  {
LABEL_8:
    uint64_t v11 = 0;
  }
  else
  {
    while (*(char **)v9 != llvm::AssumptionCacheTracker::ID)
    {
      v9 += 16;
      if (v9 == v10) {
        goto LABEL_8;
      }
    }
    uint64_t v11 = *(void *)(v9 + 8);
  }
  long long v12 = (llvm::AssumptionCacheTracker *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v11 + 96))(v11, llvm::AssumptionCacheTracker::ID);
  llvm::AssumptionCacheTracker::getAssumptionCache(v12, a2);
  unsigned int v13 = (uint64_t *)*((void *)this + 1);
  uint64_t v14 = *v13;
  uint64_t v15 = v13[1];
  if (v14 == v15)
  {
LABEL_12:
    uint64_t v16 = 0;
  }
  else
  {
    while (*(char **)v14 != llvm::TargetLibraryInfoWrapperPass::ID)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_12;
      }
    }
    uint64_t v16 = *(void *)(v14 + 8);
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v16 + 96))(v16, llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CBF5AC74(v17, (uint64_t)a2);
}

void llvm::callDefaultCtor<llvm::MemoryDependenceWrapperPass>()
{
}

void *sub_1CD4A8858(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4A890C(a1, v6);
  uint64_t v8 = 0;
  sub_1CC0A2428(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4A890C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4A89D8(a1, v4, v4 + 32 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4A89D8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      long long v12 = 0;
      uint64_t result = sub_1CC0A2428(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v12);
      uint64_t v10 = v12;
      *long long v12 = *(void *)a2;
      long long v11 = *(_OWORD *)(a2 + 8);
      _OWORD v10[3] = *(void *)(a2 + 24);
      *(_OWORD *)(v10 + 1) = v11;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

void *sub_1CD4A8A90(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4A8B14(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4A8BB0(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = v5 + 5;
    void v5[2] = v5 + 5;
    v5[3] = 4;
    *((_DWORD *)v5 + 8) = 0;
  }
  return v5;
}

uint64_t sub_1CD4A8B14(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 72 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 72 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD4A8BB0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4A8C64(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A8B14(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4A8C64(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(72 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4A8D3C(a1, v4, &v4[9 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 72 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 9;
      v11 -= 72;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4A8D3C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 72 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 9;
      v8 -= 72;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v13 = 0;
      sub_1CD4A8B14(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      uint64_t v10 = v13;
      uint64_t v11 = v13 + 5;
      *unsigned int v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 4, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      BOOL v12 = (void *)a2[2];
      if (v12 != (void *)a2[1]) {
        free(v12);
      }
    }
    a2 += 9;
  }
}

void sub_1CD4A8E10()
{
}

void *sub_1CD4A8E84(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CBC5D0DC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CC0A2A6C(a1, a2, v8);
    uint64_t v6 = *a2;
    *((unsigned char *)v5 + 32) = 0;
    void v5[2] = 0;
    v5[3] = 0;
    *unint64_t v5 = v6;
    v5[1] = 0;
  }
  return v5;
}

llvm::raw_ostream *llvm::LocationSize::print(llvm::LocationSize *this, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "LocationSize::");
  switch(*(void *)this)
  {
    case 0xFFFFFFFFFFFFFFFCLL:
      char v4 = "mapTombstone";
      goto LABEL_10;
    case 0xFFFFFFFFFFFFFFFDLL:
      char v4 = "mapEmpty";
      goto LABEL_10;
    case 0xFFFFFFFFFFFFFFFELL:
      char v4 = "afterPointer";
      goto LABEL_10;
    case 0xFFFFFFFFFFFFFFFFLL:
      char v4 = "beforeOrAfterPointer";
LABEL_10:
      uint64_t result = sub_1CB8E509C(a2, v4);
      break;
    default:
      if ((*(void *)this & 0x8000000000000000) != 0) {
        unint64_t v5 = "upperBound(";
      }
      else {
        unint64_t v5 = "precise(";
      }
      uint64_t v6 = sub_1CB8E509C(a2, v5);
      uint64_t result = llvm::raw_ostream::operator<<(v6, *(void *)this & 0x7FFFFFFFFFFFFFFFLL);
      uint64_t v8 = (unsigned char *)*((void *)result + 4);
      if ((unint64_t)v8 >= *((void *)result + 3))
      {
        uint64_t result = llvm::raw_ostream::write(result, 41);
      }
      else
      {
        *((void *)result + 4) = v8 + 1;
        *uint64_t v8 = 41;
      }
      break;
  }
  return result;
}

void llvm::initializeMemorySSAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC69C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0A4EB0;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCC69C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::MemorySSAUtil::defClobbersUseOrDef(uint64_t a1, uint64_t a2, llvm::AAResults *a3)
{
  uint64_t v6 = *(void *)(a2 + 72);
  uint64_t v7 = *(unsigned __int8 *)(v6 + 16);
  if (*(unsigned __int8 *)(v6 + 16) > 0x3Eu)
  {
    if (v7 == 63) {
      goto LABEL_9;
    }
    if (v7 != 84)
    {
LABEL_4:
      llvm::MemoryLocation::getOrNone(*(uint64_t ****)(a2 + 72), (uint64_t)&v12);
      uint64_t v7 = v12;
      long long v9 = v13[0];
      long long v10 = v13[1];
      uint64_t v11 = *(void *)&v13[2];
      uint64_t v6 = *(void *)(a2 + 72);
LABEL_9:
      uint64_t v12 = v7;
      v13[0] = v9;
      v13[1] = v10;
      *(void *)&void v13[2] = v11;
      return sub_1CC0AF304(a1, (long long *)&v12, v6, a3) & 1;
    }
  }
  else if (v7 != 33 && v7 != 39)
  {
    goto LABEL_4;
  }
  uint64_t v12 = 0;
  *(void *)&v13[0] = -1;
  memset((char *)v13 + 8, 0, 32);
  return sub_1CC0AF304(a1, (long long *)&v12, v6, a3) & 1;
}

void *llvm::MemorySSA::insertIntoListsBefore(uint64_t a1, uint64_t a2, const llvm::BasicBlock *a3, void *a4)
{
  uint64_t v26 = 0;
  int v27 = a3;
  if (sub_1CBA0E618(a1 + 48, &v27, &v26))
  {
    uint64_t v8 = v26;
    uint64_t v9 = *(void *)(a1 + 48);
    uint64_t v10 = *(unsigned int *)(a1 + 64);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 48);
    uint64_t v10 = *(unsigned int *)(a1 + 64);
    uint64_t v8 = v9 + 16 * v10;
  }
  if (v8 == v9 + 16 * v10) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void **)(v8 + 8);
  }
  uint64_t v12 = *a4;
  *(void *)(a2 + 32) = *a4;
  *(void *)(a2 + 40) = a4;
  *(void *)(v12 + 8) = a2 + 32;
  *a4 = a2 + 32;
  if (*(unsigned char *)(a2 + 16) != 25)
  {
    DefsList = llvm::MemorySSA::getOrCreateDefsList((llvm::MemorySSA *)a1, a3);
    if (v11 == a4)
    {
LABEL_7:
      uint64_t v14 = *(void *)DefsList;
      *(void *)(a2 + 48) = *(void *)DefsList;
      *(void *)(a2 + 56) = DefsList;
      uint64_t v15 = a2 + 48;
      *(void *)(v14 + 8) = v15;
      *(void *)DefsList = v15;
    }
    else if (*((unsigned char *)a4 - 16) == 26)
    {
      uint64_t v20 = a4[2];
      uint64_t v19 = a4 + 2;
      *(void *)(a2 + 48) = v20;
      *(void *)(a2 + 56) = v19;
      uint64_t v21 = a2 + 48;
      *(void *)(v20 + 8) = v21;
      void *v19 = v21;
    }
    else
    {
      while (1)
      {
        __int16 v22 = a4 - 4;
        if (!a4) {
          __int16 v22 = 0;
        }
        if (*((unsigned char *)v22 + 16) == 26) {
          break;
        }
        a4 = (void *)a4[1];
        if (a4 == v11) {
          goto LABEL_7;
        }
      }
      uint64_t v24 = v22[6];
      uint64_t v23 = v22 + 6;
      *(void *)(a2 + 48) = v24;
      *(void *)(a2 + 56) = v23;
      uint64_t v25 = a2 + 48;
      *(void *)(v24 + 8) = v25;
      void *v23 = v25;
    }
  }
  uint64_t result = sub_1CB896AE8(a1 + 104, (uint64_t)a3);
  uint64_t v17 = *(void *)(a1 + 112);
  uint64_t v18 = 120;
  if (v17 == *(void *)(a1 + 104)) {
    uint64_t v18 = 124;
  }
  if (result != (void *)(v17 + 8 * *(unsigned int *)(a1 + v18)))
  {
    *uint64_t result = -2;
    ++*(_DWORD *)(a1 + 128);
  }
  return result;
}

void *llvm::MemorySSA::moveTo(int32x2_t *a1, uint64_t a2, const llvm::BasicBlock *a3, void *a4)
{
  llvm::MemorySSA::prepareForMoveTo(a1, a2, (uint64_t)a3);

  return llvm::MemorySSA::insertIntoListsBefore((uint64_t)a1, a2, a3, a4);
}

void *llvm::MemorySSA::dump(const llvm::Module ***this)
{
  uint64_t v2 = llvm::dbgs((llvm *)this);
  v4[0] = &unk_1F2605BB8;
  v4[1] = this;
  return llvm::Function::print(this[2], v2, (llvm::AssemblyAnnotationWriter *)v4, 0, 0);
}

llvm::raw_ostream *llvm::MemoryAccess::print(llvm::MemoryDef *this, llvm::raw_ostream *a2)
{
  int v2 = *((unsigned __int8 *)this + 16);
  if (v2 == 25) {
    return llvm::MemoryUse::print(this, a2);
  }
  if (v2 == 26) {
    return llvm::MemoryDef::print(this, a2);
  }
  return llvm::MemoryPhi::print(this, a2);
}

llvm::raw_ostream *llvm::MemoryPhi::print(llvm::MemoryPhi *this, llvm::raw_ostream *a2)
{
  sub_1CD098D14(a2, *((unsigned int *)this + 18), 0, 0, 0);
  uint64_t result = sub_1CB8E509C(a2, " = MemoryPhi(");
  int v5 = *((_DWORD *)this + 5);
  if ((v5 & 0x40000000) != 0)
  {
    uint64_t v7 = (char *)*((void *)this - 1);
    uint64_t v6 = v5 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v6 = v5 & 0x7FFFFFF;
    uint64_t v7 = (char *)this - 32 * v6;
  }
  if (v6)
  {
    char v8 = 0;
    uint64_t v9 = 32 * v6;
    uint64_t v10 = v7;
    do
    {
      int v11 = *((_DWORD *)this + 5);
      if ((v11 & 0x40000000) != 0) {
        uint64_t v12 = (char *)*((void *)this - 1);
      }
      else {
        uint64_t v12 = (char *)this - 32 * (v11 & 0x7FFFFFF);
      }
      unsigned int v13 = *(llvm::Value **)&v12[32 * *((unsigned int *)this + 19)
                                + 8 * ((unint64_t)(v10 - v12) >> 5)];
      uint64_t v14 = *(void *)v7;
      size_t v15 = v8 & 1;
      uint64_t v16 = (unsigned char *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v16 >= v15)
      {
        if (v8)
        {
          memcpy(v16, ",", v8 & 1);
          uint64_t v16 = (unsigned char *)(*((void *)a2 + 4) + v15);
          *((void *)a2 + 4) = v16;
        }
      }
      else
      {
        if (v8) {
          uint64_t v17 = ",";
        }
        else {
          uint64_t v17 = 0;
        }
        llvm::raw_ostream::write(a2, v17, v15);
        uint64_t v16 = (unsigned char *)*((void *)a2 + 4);
      }
      if ((unint64_t)v16 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 123);
      }
      else
      {
        *((void *)a2 + 4) = v16 + 1;
        *uint64_t v16 = 123;
      }
      if ((*((unsigned char *)v13 + 23) & 0x10) != 0)
      {
        Name = llvm::Value::getName(v13);
        size_t v20 = v18;
        uint64_t v21 = (void *)*((void *)a2 + 4);
        if (v18 <= *((void *)a2 + 3) - (void)v21)
        {
          if (v18)
          {
            memcpy(v21, Name, v18);
            *((void *)a2 + 4) += v20;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, Name, v18);
        }
      }
      else
      {
        llvm::Value::printAsOperand(v13, a2, 0, 0);
      }
      __int16 v22 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v22 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 44);
      }
      else
      {
        *((void *)a2 + 4) = v22 + 1;
        unsigned char *v22 = 44;
      }
      if (*(unsigned char *)(v14 + 16) != 26 || v14 == 0) {
        uint64_t v24 = 72;
      }
      else {
        uint64_t v24 = 88;
      }
      unint64_t v25 = *(unsigned int *)(v14 + v24);
      if (v25) {
        uint64_t result = sub_1CD098D14(a2, v25, 0, 0, 0);
      }
      else {
        uint64_t result = sub_1CB8E509C(a2, "liveOnEntry");
      }
      uint64_t v26 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v26 >= *((void *)a2 + 3))
      {
        uint64_t result = llvm::raw_ostream::write(a2, 125);
      }
      else
      {
        *((void *)a2 + 4) = v26 + 1;
        unsigned char *v26 = 125;
      }
      v7 += 32;
      v10 += 32;
      char v8 = 1;
      v9 -= 32;
    }
    while (v9);
  }
  int v27 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v27 >= *((void *)a2 + 3))
  {
    return llvm::raw_ostream::write(a2, 41);
  }
  else
  {
    *((void *)a2 + 4) = v27 + 1;
    unsigned char *v27 = 41;
  }
  return result;
}

llvm::raw_ostream *llvm::MemoryDef::print(llvm::MemoryDef *this, llvm::raw_ostream *a2)
{
  if (*((unsigned char *)this + 16) == 25) {
    char v4 = this;
  }
  else {
    char v4 = 0;
  }
  if (v4) {
    int v5 = (uint64_t *)((char *)v4 - 32);
  }
  else {
    int v5 = (uint64_t *)((char *)this - 64);
  }
  uint64_t v6 = *v5;
  sub_1CD098D14(a2, *((unsigned int *)this + 22), 0, 0, 0);
  sub_1CB8E509C(a2, " = MemoryDef(");
  sub_1CC0AAC58(a2, v6);
  uint64_t result = sub_1CB8E509C(a2, ")");
  uint64_t v8 = *((void *)this - 4);
  if (v8)
  {
    uint64_t v9 = 72;
    if (*(unsigned char *)(v8 + 16) == 26) {
      uint64_t v9 = 88;
    }
    if (*((_DWORD *)this + 23) == *(_DWORD *)(v8 + v9))
    {
      sub_1CB8E509C(a2, "->");
      sub_1CC0AAC58(a2, *((void *)this - 4));
      uint64_t result = (llvm::raw_ostream *)sub_1CC0AD3C8((uint64_t)this);
      if (result)
      {
        uint64_t v10 = *((void *)this + 10);
        if ((v10 & 0xFF00000000) != 0)
        {
          int v11 = sub_1CB8E509C(a2, " ");
          return llvm::operator<<(v11, v10);
        }
      }
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MemoryUse::print(llvm::MemoryUse *this, llvm::raw_ostream *a2)
{
  if (*((unsigned char *)this + 16) == 25) {
    char v4 = this;
  }
  else {
    char v4 = 0;
  }
  if (v4) {
    int v5 = (uint64_t *)((char *)v4 - 32);
  }
  else {
    int v5 = (uint64_t *)((char *)this - 64);
  }
  uint64_t v6 = *v5;
  sub_1CB8E509C(a2, "MemoryUse(");
  if (v6)
  {
    if (*(unsigned char *)(v6 + 16) == 26)
    {
      unsigned int v7 = *(_DWORD *)(v6 + 88);
      if (v7)
      {
LABEL_10:
        sub_1CD098D14(a2, v7, 0, 0, 0);
        goto LABEL_13;
      }
    }
    else
    {
      unsigned int v7 = *(_DWORD *)(v6 + 72);
      if (v7) {
        goto LABEL_10;
      }
    }
  }
  sub_1CB8E509C(a2, "liveOnEntry");
LABEL_13:
  uint64_t v8 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v8 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 41);
  }
  else
  {
    *((void *)a2 + 4) = v8 + 1;
    *uint64_t v8 = 41;
  }
  uint64_t result = (llvm::raw_ostream *)sub_1CC0AD3C8((uint64_t)this);
  if (result)
  {
    uint64_t v10 = *((void *)this + 10);
    if ((v10 & 0xFF00000000) != 0)
    {
      int v11 = sub_1CB8E509C(a2, " ");
      return llvm::operator<<(v11, v10);
    }
  }
  return result;
}

void llvm::MemorySSAPrinterPass::run()
{
}

void llvm::MemorySSAWalkerPrinterPass::run()
{
}

void llvm::MemorySSAVerifierPass::run()
{
}

llvm::MemorySSAWrapperPass *llvm::MemorySSAWrapperPass::MemorySSAWrapperPass(llvm::MemorySSAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MemorySSAWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2605AA8;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC69C8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0A4EB0;
    v5[1] = &PassRegistry;
    char v4 = v5;
    std::__call_once(&qword_1EBCC69C8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::AnalysisUsage *llvm::MemorySSAWrapperPass::getAnalysisUsage(llvm::MemorySSAWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AAResultsWrapperPass::ID);
}

void *llvm::MemorySSAWrapperPass::print(llvm::MemorySSAWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v3 = *((void *)this + 4);
  v5[0] = &unk_1F2605BB8;
  v5[1] = v3;
  return llvm::Function::print(*(const llvm::Module ***)(v3 + 16), a2, (llvm::AssemblyAnnotationWriter *)v5, 0, 0);
}

void sub_1CD4A9E20(llvm::Pass *a1)
{
  sub_1CD4A9E94(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MemorySSAWrapperPass>()
{
}

void sub_1CD4A9E94(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2605AA8;
  uint64_t v1 = (llvm::MemorySSA *)*((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v1)
  {
    int v2 = a1;
    llvm::MemorySSA::~MemorySSA(v1);
    MEMORY[0x1D25D9CE0]();
    a1 = v2;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CD4A9F18(long long *a1, long long *a2, const char **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)qword_1EBCC6B58, 0, 0);
  xmmword_1EBCC6BD8 = 0uLL;
  qword_1EBCC6C00 = 0;
  unk_1EBCC6C08 = 0;
  byte_1EBCC6C10 = 0;
  qword_1EBCC6BF8 = 0;
  unk_1EBCC6BE8 = 0;
  unk_1EBCC6BF0 = &unk_1F2643C20;
  qword_1EBCC6B58[0] = (uint64_t)&unk_1F2643FD0;
  qword_1EBCC6C18 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCC6C20 = (uint64_t)&unk_1F25F6428;
  qword_1EBCC6C38 = (uint64_t)&qword_1EBCC6C20;
  llvm::cl::Option::setArgStr(v6, "dot-cfg-mssa", 0xCuLL);
  xmmword_1EBCC6B88 = *a1;
  xmmword_1EBCC6B78 = *a2;
  sub_1CBAD7D28(a3, (uint64_t)qword_1EBCC6B58);

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCC6B58);
}

void sub_1CD4AA030(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCC69D8, 0, 0);
  dword_1EBCC6A58 = 0;
  qword_1EBCC6A60 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC6A68 = 0;
  qword_1EBCC69D8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC6A70 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC6A78 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC6A90 = (uint64_t)&qword_1EBCC6A78;
  llvm::cl::Option::setArgStr(v6, "memssa-check-limit", 0x12uLL);
  word_1EBCC69E2 = (32 * (*a1 & 3)) | word_1EBCC69E2 & 0xFF9F;
  dword_1EBCC6A58 = **a2;
  byte_1EBCC6A6C = 1;
  dword_1EBCC6A68 = dword_1EBCC6A58;
  xmmword_1EBCC69F8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC69D8);
}

void sub_1CD4AA160()
{
}

void sub_1CD4AA174()
{
}

uint64_t sub_1CD4AA188(uint64_t a1, uint64_t a2, long long *a3)
{
  int v4 = dword_1EBCC6A58;
  return sub_1CC0B15B8(*(void *)(a1 + 16), a2, a3, &v4);
}

void sub_1CD4AA1BC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v2 = *(unsigned __int8 *)(a2 + 16);
    if ((v2 - 27) >= 0xFFFFFFFE)
    {
      if (v2 == 26)
      {
        *(_DWORD *)(a2 + 92) = -1;
        if (*(void *)(a2 - 32))
        {
          **(void **)(a2 - 16) = *(void *)(a2 - 24);
          uint64_t v3 = *(void *)(a2 - 24);
          if (v3) {
            *(void *)(v3 + 16) = *(void *)(a2 - 16);
          }
        }
        *(void *)(a2 - 32) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 88) = -1;
      }
    }
  }
}

uint64_t sub_1CD4AA214@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CBA0E618(a1, a2, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC0B1698(a1, (uint64_t)a2, a2, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(void *)(result + 8) = *a3;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

void sub_1CD4AA2A8()
{
}

uint64_t sub_1CD4AA2BC(uint64_t a1, uint64_t a2)
{
  int v3 = dword_1EBCC6A58;
  return sub_1CC0ACD38(*(void *)(a1 + 16), a2, &v3, 1);
}

uint64_t sub_1CD4AA2F4(uint64_t a1, uint64_t a2, long long *a3)
{
  int v4 = dword_1EBCC6A58;
  return sub_1CD4AA380(*(void *)(a1 + 16), a2, a3, &v4);
}

void sub_1CD4AA328(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v2 = *(unsigned __int8 *)(a2 + 16);
    if ((v2 - 27) >= 0xFFFFFFFE)
    {
      if (v2 == 26)
      {
        *(_DWORD *)(a2 + 92) = -1;
        if (*(void *)(a2 - 32))
        {
          **(void **)(a2 - 16) = *(void *)(a2 - 24);
          uint64_t v3 = *(void *)(a2 - 24);
          if (v3) {
            *(void *)(v3 + 16) = *(void *)(a2 - 16);
          }
        }
        *(void *)(a2 - 32) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 88) = -1;
      }
    }
  }
}

uint64_t sub_1CD4AA380(uint64_t a1, uint64_t a2, long long *a3, _DWORD *a4)
{
  if (!a2
    || *(unsigned __int8 *)(a2 + 16) - 27 < 0xFFFFFFFE
    || *(void *)(*(void *)(a1 + 2392) + 96) != a2
    && ((unsigned int v4 = *(unsigned __int8 *)(*(void *)(a2 + 72) + 16) - 37,
         BOOL v5 = v4 > 0x2B,
         uint64_t v6 = (1 << v4) & 0x80004000001,
         !v5)
      ? (BOOL v7 = v6 == 0)
      : (BOOL v7 = 1),
        v7))
  {
    int v16 = 1;
    char v17 = 1;
    char v18 = 0;
    long long v8 = a3[1];
    long long v11 = *a3;
    long long v12 = v8;
    long long v13 = a3[2];
    uint64_t v14 = 0;
    uint64_t v15 = a2;
    v10[0] = 0;
    return sub_1CC0AD43C(a1, a2, (uint64_t)v10, a4);
  }
  return a2;
}

uint64_t sub_1CD4AA428(uint64_t a1, uint64_t a2, llvm::Twine *this)
{
  v7[0] = a1;
  v7[1] = a2;
  __int16 v8 = 0;
  llvm::Twine::str(this, __p);
  sub_1CD4AA484((uint64_t)v7, (uint64_t)__p);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

llvm::raw_ostream *sub_1CD4AA484(uint64_t a1, uint64_t a2)
{
  sub_1CD4AA504(a1, a2);
  uint64_t v3 = ***(void ***)(a1 + 8);
  uint64_t v4 = v3 + 72;
  for (uint64_t i = *(void *)(v3 + 80); i != v4; uint64_t i = *(void *)(i + 8))
  {
    if (i) {
      char v6 = (llvm::Value *)(i - 24);
    }
    else {
      char v6 = 0;
    }
    sub_1CC0B19CC((uint64_t **)a1, v6);
  }
  BOOL v7 = *(uint64_t **)a1;

  return sub_1CB8E509C((llvm::raw_ostream *)v7, "}\n");
}

void sub_1CD4AA504(uint64_t a1, uint64_t a2)
{
  sub_1CD4AA748(&v28, ***(llvm::Value ****)(a1 + 8));
  char v4 = *(unsigned char *)(a2 + 23);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 < 0) {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  if (v6)
  {
    BOOL v7 = sub_1CB8E509C(*(llvm::raw_ostream **)a1, "digraph \"");
    __int16 v8 = (std::string *)a2;
  }
  else
  {
    std::string::size_type size = *((unsigned char *)&v28.__r_.__value_.__s + 23) & 0x7F;
    if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v28.__r_.__value_.__l.__size_;
    }
    __int16 v22 = *(llvm::raw_ostream **)a1;
    if (!size)
    {
      sub_1CB8E509C(v22, "digraph unnamed {\n");
      goto LABEL_13;
    }
    BOOL v7 = sub_1CB8E509C(v22, "digraph \"");
    __int16 v8 = &v28;
  }
  llvm::DOT::EscapeString((char *)v8, (uint64_t)&__p);
  if (v27 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  if (v27 >= 0) {
    size_t v10 = v27 & 0x7F;
  }
  else {
    size_t v10 = v26;
  }
  long long v11 = llvm::raw_ostream::write(v7, p_p, v10);
  sub_1CB8E509C(v11, "\" {\n");
  if (v27 < 0) {
    operator delete(__p);
  }
LABEL_13:
  char v12 = *(unsigned char *)(a2 + 23);
  int v13 = v12;
  uint64_t v14 = v12 & 0x7F;
  if (v13 < 0) {
    uint64_t v14 = *(void *)(a2 + 8);
  }
  if (v14)
  {
    uint64_t v15 = sub_1CB8E509C(*(llvm::raw_ostream **)a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)a2, (uint64_t)&__p);
    if (v27 >= 0) {
      int v16 = (const char *)&__p;
    }
    else {
      int v16 = (const char *)__p;
    }
    if (v27 >= 0) {
      size_t v17 = v27 & 0x7F;
    }
    else {
      size_t v17 = v26;
    }
    char v18 = v15;
    goto LABEL_23;
  }
  std::string::size_type v23 = *((unsigned char *)&v28.__r_.__value_.__s + 23) & 0x7F;
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v23 = v28.__r_.__value_.__l.__size_;
  }
  if (v23)
  {
    uint64_t v24 = sub_1CB8E509C(*(llvm::raw_ostream **)a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)&v28, (uint64_t)&__p);
    if (v27 >= 0) {
      int v16 = (const char *)&__p;
    }
    else {
      int v16 = (const char *)__p;
    }
    if (v27 >= 0) {
      size_t v17 = v27 & 0x7F;
    }
    else {
      size_t v17 = v26;
    }
    char v18 = v24;
LABEL_23:
    uint64_t v19 = llvm::raw_ostream::write(v18, v16, v17);
    sub_1CB8E509C(v19, "\";\n");
    if (v27 < 0) {
      operator delete(__p);
    }
  }
  size_t v20 = *(llvm::raw_ostream **)a1;
  char v27 = 0;
  LOBYTE(__p) = 0;
  llvm::raw_ostream::write(v20, (const char *)&__p, 0);
  if (v27 < 0) {
    operator delete(__p);
  }
  sub_1CB8E509C(*(llvm::raw_ostream **)a1, "\n");
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
}

void sub_1CD4AA748(std::string *a1, llvm::Value *this)
{
  Name = llvm::Value::getName(this);
  if (Name) {
    std::string::__init(&v8, Name, v4);
  }
  else {
    memset(&v8, 0, sizeof(v8));
  }
  int v5 = std::string::insert(&v8, 0, "MSSA CFG for '");
  std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  BOOL v7 = std::string::append(&v9, "' function");
  *a1 = *v7;
  v7->__r_.__value_.__r.__words[0] = 0;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v8.__r_.__value_.__l.__data_);
  }
}

void sub_1CD4AA810(std::string *a1, llvm::Value *a2, uint64_t a3)
{
  uint64_t v9 = a3;
  sub_1CBF94B54(a2, (void (*)(uint64_t, void **, llvm::Value *))sub_1CD4AA984, (uint64_t)&v9, (void (*)(uint64_t, uint64_t, unsigned int *, std::string::size_type))sub_1CD4AA9A0, (uint64_t)&v8, (uint64_t)&v7);
  std::string::size_type v4 = std::string::find(&v7, 59, 0);
  if (v4 == -1) {
    int v5 = "";
  }
  else {
    int v5 = "style=filled, fillcolor=lightpink";
  }
  if (v4 == -1) {
    std::string::size_type v6 = 0;
  }
  else {
    std::string::size_type v6 = 33;
  }
  std::string::__init(a1, v5, v6);
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
}

void sub_1CD4AA8BC(llvm::raw_ostream **a1, unint64_t a2, int a3, llvm::Instruction *this, unsigned int a5)
{
  uint64_t Successor = llvm::Instruction::getSuccessor(this, a5);
  if (Successor)
  {
    unint64_t v10 = Successor;
    sub_1CBF94EC4(a2, a5, (uint64_t)__p);
    if ((v14 & 0x80u) == 0) {
      unint64_t v11 = v14;
    }
    else {
      unint64_t v11 = (unint64_t)__p[1];
    }
    if ((char)v14 < 0) {
      operator delete(__p[0]);
    }
    if (v11) {
      int v12 = a3;
    }
    else {
      int v12 = -1;
    }
    unsigned __int8 v14 = 0;
    LOBYTE(__p[0]) = 0;
    sub_1CD4655CC(a1, a2, v12, v10, (uint64_t)__p);
    if ((char)v14 < 0) {
      operator delete(__p[0]);
    }
  }
}

void *sub_1CD4AA984(uint64_t a1, llvm::raw_ostream *a2, const llvm::Function **this)
{
  return llvm::BasicBlock::print(this, a2, (llvm::AssemblyAnnotationWriter *)(*(void *)a1 + 8), 1, 1);
}

void sub_1CD4AA9A0(int a1, std::string *__str, _DWORD *a3, unsigned int a4)
{
}

void sub_1CD4AA9B0(std::string *__str, _DWORD *a2, unsigned int a3)
{
  std::string::basic_string(&v9, __str, *a2, a3 - *a2, (std::allocator<char> *)v8);
  std::string::size_type v6 = (std::string *)v9.__r_.__value_.__r.__words[0];
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v6 = &v9;
  }
  std::string::size_type size = *((unsigned char *)&v9.__r_.__value_.__s + 23) & 0x7F;
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v9.__r_.__value_.__l.__size_;
  }
  v8[0] = v6;
  v8[1] = size;
  if (!llvm::StringRef::count(v8, " = MemoryDef(", 0xDuLL) {
    && !llvm::StringRef::count(v8, " = MemoryPhi(", 0xDuLL)
  }
    && !llvm::StringRef::count(v8, "MemoryUse(", 0xAuLL))
  {
    std::string::erase(__str, *a2, a3 - (unint64_t)*a2);
    --*a2;
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

uint64_t llvm::MemorySSAUpdater::removeDuplicatePhiEdgesBetween(llvm::MemorySSAUpdater *this, const llvm::BasicBlock *a2, const llvm::BasicBlock *a3)
{
  uint64_t v5 = *(void *)this + 24;
  uint64_t v13 = 0;
  unsigned __int8 v14 = a3;
  uint64_t result = sub_1CBA0E618(v5, &v14, &v13);
  if (result)
  {
    std::string v7 = *(_DWORD **)(v13 + 8);
    if (v7)
    {
      int v8 = v7[5];
      int v9 = v8 & 0x7FFFFFF;
      if ((v8 & 0x7FFFFFF) != 0)
      {
        unsigned int v10 = 0;
        int v11 = 0;
        do
        {
          if ((v8 & 0x40000000) != 0) {
            int v12 = (_DWORD *)*((void *)v7 - 1);
          }
          else {
            int v12 = &v7[-8 * (v8 & 0x7FFFFFF)];
          }
          if (*(const llvm::BasicBlock **)&v12[8 * v7[19] + 2 * v10] == a2)
          {
            if (v11)
            {
              sub_1CC0B7954((uint64_t)v7, v10);
              int v8 = v7[5];
              int v9 = v8 & 0x7FFFFFF;
              --v10;
            }
            int v11 = 1;
          }
          ++v10;
        }
        while (v10 != v9);
      }
      return (uint64_t)llvm::MemorySSAUpdater::tryRemoveTrivialPhi(this, v7);
    }
  }
  return result;
}

void llvm::MemorySSAUpdater::updateExitBlocksForClonedLoop(int32x2_t **a1, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  std::string::size_type v6 = (uint64_t *)*MEMORY[0x1E4F143B8];
  uint64_t v5 = a4;
  sub_1CD4AABE0(a1, a2, a3, &v5, &v6, a5);
}

void sub_1CD4AABE0(int32x2_t **a1, uint64_t *a2, uint64_t a3, uint64_t **a4, uint64_t **a5, uint64_t a6)
{
  v26[8] = *MEMORY[0x1E4F143B8];
  uint64_t v24 = v26;
  uint64_t v25 = 0x400000000;
  if (a3)
  {
    unsigned int v10 = a2;
    uint64_t v21 = a6;
    int v11 = &a2[a3];
    do
    {
      if (a4 != a5)
      {
        uint64_t v12 = *v10;
        uint64_t v13 = a4;
        do
        {
          sub_1CC0B7008(v22, **v13, *((_DWORD *)*v13 + 4), v12);
          uint64_t v14 = v23;
          if (v23 != -8192 && v23 != -4096 && v23 != 0) {
            llvm::ValueHandleBase::RemoveFromUseList(v22);
          }
          if (v14)
          {
            uint64_t v16 = *(void *)(v14 + 40);
            if (v16 == v14 + 40)
            {
              char v18 = 0;
            }
            else
            {
              if (v16) {
                size_t v17 = (unsigned __int8 *)(v16 - 24);
              }
              else {
                size_t v17 = 0;
              }
              if (v17[16] - 29 >= 0xB) {
                char v18 = 0;
              }
              else {
                char v18 = (llvm::Instruction *)v17;
              }
            }
            uint64_t Successor = llvm::Instruction::getSuccessor(v18, 0);
            if (v25 >= (unint64_t)HIDWORD(v25)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            size_t v20 = (char *)v24 + 16 * v25;
            *size_t v20 = v14;
            v20[1] = Successor & 0xFFFFFFFFFFFFFFFBLL;
            LODWORD(v25) = v25 + 1;
          }
          ++v13;
        }
        while (v13 != a5);
      }
      ++v10;
    }
    while (v10 != v11);
    std::string v7 = v24;
    a3 = v25;
    a6 = v21;
  }
  else
  {
    std::string v7 = v26;
  }
  llvm::MemorySSAUpdater::applyInsertUpdates(a1, (uint64_t)v7, a3, a6);
  if (v24 != v26) {
    free(v24);
  }
}

void llvm::MemorySSAUpdater::updateExitBlocksForClonedLoop(int32x2_t **a1, uint64_t *a2, uint64_t a3, uint64_t **a4, uint64_t a5, uint64_t a6)
{
  v28[8] = *MEMORY[0x1E4F143B8];
  size_t v26 = v28;
  uint64_t v27 = 0x400000000;
  if (a3)
  {
    int v9 = a2;
    __int16 v22 = a1;
    uint64_t v23 = a6;
    uint64_t v10 = 8 * a5;
    int v11 = &a2[a3];
    do
    {
      if (a5)
      {
        uint64_t v12 = *v9;
        uint64_t v13 = v10;
        uint64_t v14 = a4;
        do
        {
          sub_1CC0B7008(v24, **v14, *((_DWORD *)*v14 + 4), v12);
          uint64_t v15 = v25;
          if (v25 != -8192 && v25 != -4096 && v25 != 0) {
            llvm::ValueHandleBase::RemoveFromUseList(v24);
          }
          if (v15)
          {
            uint64_t v17 = *(void *)(v15 + 40);
            if (v17 == v15 + 40)
            {
              uint64_t v19 = 0;
            }
            else
            {
              if (v17) {
                char v18 = (unsigned __int8 *)(v17 - 24);
              }
              else {
                char v18 = 0;
              }
              if (v18[16] - 29 >= 0xB) {
                uint64_t v19 = 0;
              }
              else {
                uint64_t v19 = (llvm::Instruction *)v18;
              }
            }
            uint64_t Successor = llvm::Instruction::getSuccessor(v19, 0);
            if (v27 >= (unint64_t)HIDWORD(v27)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v21 = (char *)v26 + 16 * v27;
            *uint64_t v21 = v15;
            v21[1] = Successor & 0xFFFFFFFFFFFFFFFBLL;
            LODWORD(v27) = v27 + 1;
          }
          ++v14;
          v13 -= 8;
        }
        while (v13);
      }
      ++v9;
    }
    while (v9 != v11);
    std::string::size_type v6 = v26;
    a3 = v27;
    a6 = v23;
    a1 = v22;
  }
  else
  {
    std::string::size_type v6 = v28;
  }
  llvm::MemorySSAUpdater::applyInsertUpdates(a1, (uint64_t)v6, a3, a6);
  if (v26 != v28) {
    free(v26);
  }
}

uint64_t llvm::MemorySSAUpdater::applyInsertUpdates(int32x2_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[8] = *MEMORY[0x1E4F143B8];
  v7[0] = 1;
  for (uint64_t i = 1; i != 37; i += 9)
    v7[i] = -4096;
  v7[37] = 1;
  for (uint64_t j = 38; j != 74; j += 9)
    v7[j] = -4096;
  char v8 = 0;
  int v9 = v11;
  uint64_t v10 = 0x400000000;
  llvm::MemorySSAUpdater::applyInsertUpdates(a1, a2, a3, a4, (uint64_t)v7);
  return sub_1CBFEEC7C((uint64_t)v7);
}

void *sub_1CD4AB038(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1CD4ABF48((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 48);
    if (v6 >= *(_DWORD *)(a1 + 52)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 40) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 48);
  }
  return result;
}

void llvm::MemorySSAUpdater::moveAfter(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t llvm::MemorySSAUpdater::moveAllAfterSpliceBlocks(int32x2_t **this, llvm::BasicBlock *a2, llvm::BasicBlock **a3, llvm::Instruction *a4)
{
  uint64_t result = (uint64_t)llvm::MemorySSAUpdater::moveAllAccesses(this, a2, (llvm::BasicBlock *)a3, a4);
  char v8 = a3[5];
  if (v8 != (llvm::BasicBlock *)(a3 + 5))
  {
    int v9 = v8 ? (unsigned __int8 *)v8 - 24 : 0;
    if (v9[16] - 29 <= 0xA)
    {
      uint64_t result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v9);
      if (result)
      {
        int v10 = result;
        for (unsigned int i = 0; i != v10; ++i)
        {
          uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v9, i);
          uint64_t v13 = (uint64_t)&(*this)[3];
          uint64_t v20 = 0;
          uint64_t v21 = Successor;
          uint64_t result = sub_1CBA0E618(v13, &v21, &v20);
          if (result)
          {
            uint64_t v14 = *(void *)(v20 + 8);
            if (v14)
            {
              int v15 = *(_DWORD *)(v14 + 20);
              uint64_t v16 = v15 & 0x7FFFFFF;
              if ((v15 & 0x7FFFFFF) != 0)
              {
                uint64_t v17 = 0;
                while (1)
                {
                  uint64_t v18 = v14 - 32 * v16;
                  if ((v15 & 0x40000000) != 0) {
                    uint64_t v18 = *(void *)(v14 - 8);
                  }
                  if (*(llvm::BasicBlock **)(v18 + 32 * *(unsigned int *)(v14 + 76) + 8 * v17) == a2) {
                    break;
                  }
                  if (v16 == ++v17) {
                    goto LABEL_16;
                  }
                }
              }
              else
              {
LABEL_16:
                LODWORD(v17) = -1;
              }
              if ((v15 & 0x40000000) != 0) {
                uint64_t v19 = *(void *)(v14 - 8);
              }
              else {
                uint64_t v19 = v14 - 32 * v16;
              }
              *(void *)(v19 + 32 * *(unsigned int *)(v14 + 76) + 8 * v17) = a3;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t llvm::MemorySSAUpdater::removeBlocks(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 80);
  if (v2)
  {
    std::string::size_type v4 = (llvm::MemorySSAUpdater *)result;
    uint64_t v5 = *(uint64_t **)(a2 + 72);
    unsigned int v6 = &v5[v2];
    do
    {
      uint64_t v7 = *v5;
      uint64_t v8 = *(void *)(*v5 + 40);
      if (v8 != *v5 + 40)
      {
        int v9 = (llvm::Instruction *)(v8 - 24);
        int v10 = v8 ? (unsigned __int8 *)(v8 - 24) : 0;
        if (v10[16] - 29 <= 0xA)
        {
          int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v10);
          if (NumSuccessors)
          {
            int v12 = NumSuccessors;
            for (unsigned int i = 0; i != v12; ++i)
            {
              uint64_t Successor = llvm::Instruction::getSuccessor(v9, i);
              uint64_t v38 = 0;
              uint64_t v39 = Successor;
              if ((sub_1CD4AC5C0(a2, &v39, &v38) & 1) == 0)
              {
                uint64_t v15 = *(void *)v4 + 24;
                uint64_t v38 = 0;
                uint64_t v39 = Successor;
                if (sub_1CBA0E618(v15, &v39, &v38))
                {
                  uint64_t v16 = (_DWORD *)v38[1];
                  if (v16)
                  {
                    uint64_t v38 = &v39;
                    uint64_t v39 = v7;
                    sub_1CC0BCE8C((uint64_t)v16, &v38);
                    llvm::MemorySSAUpdater::tryRemoveTrivialPhi(v4, v16);
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v17 = *(int32x2_t **)v4;
      uint64_t v18 = *(void *)v4 + 48;
      uint64_t v38 = 0;
      uint64_t v39 = v7;
      uint64_t result = sub_1CBA0E618(v18, &v39, &v38);
      if (result)
      {
        uint64_t v19 = v38;
        int32x2_t v20 = v17[6];
        uint64_t v21 = v17[8].u32[0];
      }
      else
      {
        int32x2_t v20 = v17[6];
        uint64_t v21 = v17[8].u32[0];
        uint64_t v19 = (uint64_t *)(*(void *)&v20 + 16 * v21);
      }
      if (v19 != (uint64_t *)(*(void *)&v20 + 16 * v21))
      {
        uint64_t v22 = v19[1];
        if (v22)
        {
          for (uint64_t j = *(void *)(v22 + 8); j != v22; uint64_t j = *(void *)(j + 8))
          {
            if (j) {
              uint64_t v24 = j - 32;
            }
            else {
              uint64_t v24 = 0;
            }
            uint64_t result = sub_1CC0BCC78(v24);
          }
        }
      }
      ++v5;
    }
    while (v5 != v6);
    uint64_t v25 = *(unsigned int *)(a2 + 80);
    if (v25)
    {
      size_t v26 = *(uint64_t **)(a2 + 72);
      uint64_t v27 = &v26[v25];
      do
      {
        uint64_t v28 = *v26;
        int v29 = *(int32x2_t **)v4;
        uint64_t v30 = *(void *)v4 + 48;
        uint64_t v38 = 0;
        uint64_t v39 = v28;
        uint64_t result = sub_1CBA0E618(v30, &v39, &v38);
        if (result)
        {
          long long v31 = v38;
          int32x2_t v32 = v29[6];
          uint64_t v33 = v29[8].u32[0];
        }
        else
        {
          int32x2_t v32 = v29[6];
          uint64_t v33 = v29[8].u32[0];
          long long v31 = (uint64_t *)(*(void *)&v32 + 16 * v33);
        }
        if (v31 != (uint64_t *)(*(void *)&v32 + 16 * v33))
        {
          uint64_t v34 = v31[1];
          if (v34)
          {
            uint64_t v35 = *(void *)(v34 + 8);
            if (v35 != v34)
            {
              do
              {
                uint64_t v36 = *(void *)(v35 + 8);
                if (v35) {
                  uint64_t v37 = v35 - 32;
                }
                else {
                  uint64_t v37 = 0;
                }
                llvm::MemorySSA::removeFromLookups(*(int32x2_t **)v4, v37);
                uint64_t result = (uint64_t)llvm::MemorySSA::removeFromLists(*(int32x2_t **)v4, v37, 1);
                uint64_t v35 = v36;
              }
              while (v36 != v34);
            }
          }
        }
        ++v26;
      }
      while (v26 != v27);
    }
  }
  return result;
}

char **llvm::MemorySSAUpdater::changeToUnreachable(int32x2_t **this, const llvm::Instruction *a2)
{
  v24[48] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)*((void *)a2 + 5);
  std::string::size_type v4 = (char *)a2 + 24;
  uint64_t v5 = v3 + 40;
  if ((char *)a2 + 24 != v3 + 40)
  {
    do
    {
      unsigned int v6 = (char *)*((void *)v4 + 1);
      if (v4) {
        uint64_t v7 = (uint64_t)(v4 - 24);
      }
      else {
        uint64_t v7 = 0;
      }
      sub_1CC0BCCDC(this, v7, 0);
      std::string::size_type v4 = v6;
    }
    while (v6 != v5);
  }
  uint64_t v22 = (char *)v24;
  uint64_t v23 = 0x1000000000;
  uint64_t v8 = *(void **)v5;
  if (*(char **)v5 != v5)
  {
    int v9 = v8 ? (unsigned __int8 *)(v8 - 3) : 0;
    if (v9[16] - 29 <= 0xA)
    {
      int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v9);
      if (NumSuccessors)
      {
        int v11 = NumSuccessors;
        for (unsigned int i = 0; i != v11; ++i)
        {
          uint64_t Successor = (const llvm::BasicBlock *)llvm::Instruction::getSuccessor((llvm::Instruction *)v9, i);
          llvm::MemorySSAUpdater::removeDuplicatePhiEdgesBetween((llvm::MemorySSAUpdater *)this, (const llvm::BasicBlock *)v3, Successor);
          uint64_t v14 = (uint64_t)&(*this)[3];
          v19[0] = Successor;
          uint64_t v21 = 0;
          if (sub_1CBA0E618(v14, v19, &v21))
          {
            uint64_t v16 = v21[1];
            if (v16)
            {
              v19[0] = v3;
              uint64_t v21 = v19;
              sub_1CC0BCE8C(v16, &v21);
              v19[0] = 4;
              v19[1] = 0;
              uint64_t v20 = v16;
              if ((v16 | 0x1000) != 0xFFFFFFFFFFFFF000) {
                llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v19);
              }
              sub_1CC0B4168((unsigned int *)&v22, (char *)v19);
              if (v20 != -8192 && v20 != -4096 && v20) {
                llvm::ValueHandleBase::RemoveFromUseList(v19);
              }
            }
          }
        }
        if (v23)
        {
          uint64_t v17 = 24 * v23;
          uint64_t v18 = v22 + 16;
          do
          {
            if (*(void *)v18) {
              llvm::MemorySSAUpdater::tryRemoveTrivialPhi((llvm::MemorySSAUpdater *)this, *(_DWORD **)v18);
            }
            v18 += 24;
            v17 -= 24;
          }
          while (v17);
        }
      }
    }
  }
  return sub_1CC0BD0FC(&v22);
}

char *llvm::MemorySSAUpdater::createMemoryAccessBefore(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  DefinedAccess = llvm::MemorySSA::createDefinedAccess(*a1, a2, a3, 0);
  llvm::MemorySSA::insertIntoListsBefore((uint64_t)*a1, (uint64_t)DefinedAccess, *(const llvm::BasicBlock **)(a4 + 64), (void *)(a4 + 32));
  return DefinedAccess;
}

char *llvm::MemorySSAUpdater::createMemoryAccessAfter(uint64_t **this, llvm::Instruction *a2, llvm::MemoryAccess *a3, const llvm::BasicBlock **a4)
{
  DefinedAccess = llvm::MemorySSA::createDefinedAccess(*this, (uint64_t)a2, (uint64_t)a3, 0);
  llvm::MemorySSA::insertIntoListsBefore((uint64_t)*this, (uint64_t)DefinedAccess, a4[8], a4[5]);
  return DefinedAccess;
}

void *sub_1CD4AB6EC(void *a1, unsigned int a2)
{
  if (a2 <= 4)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v3 = a2;
    uint64_t result = operator new(8 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    int v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      unsigned int v6 = &result[v3];
      goto LABEL_6;
    }
  }
  uint64_t result = a1 + 1;
  unsigned int v6 = a1 + 5;
  do
LABEL_6:
    *result++ = -4096;
  while (result != v6);
  return result;
}

void sub_1CD4AB770()
{
}

uint64_t *sub_1CD4AB7E4(uint64_t *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string::size_type v4 = result;
  unsigned int v6 = (uint64_t **)(result + 1);
  int v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[6];
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      int v5 = v7[1];
      if (!v5)
      {
        unsigned int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    sub_1CD4AB89C((uint64_t)&v11, (uint64_t)result, a3, a4);
    int v9 = v11;
    *int v11 = 0;
    v9[1] = 0;
    uint64_t v9[2] = (uint64_t)v7;
    *unsigned int v6 = v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *std::string::size_type v4 = v10;
      int v9 = *v6;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v4[1], v9);
    ++v4[2];
  }
  return result;
}

unint64_t *sub_1CD4AB89C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a2 + 8;
  unint64_t v8 = operator new(0x38uLL);
  *(void *)a1 = v8;
  *(void *)(a1 + 8) = v7;
  int v9 = v8;
  v8[6] = a4;
  uint64_t v8[4] = 4;
  uint64_t result = v8 + 4;
  v9[5] = 0;
  unint64_t v11 = (unint64_t)(v9 + 5);
  if (a4 != -8192 && a4 != -4096)
  {
    if (a4)
    {
      *(void *)unint64_t v11 = *(void *)(a3 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(a3 & 0xFFFFFFFFFFFFFFF8) = result;
      *uint64_t result = a3 & 0xFFFFFFFFFFFFFFF8 | 4;
      if (*(void *)v11) {
        **(void **)unint64_t v11 = **(void **)v11 & 7 | v11;
      }
    }
  }
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

uint64_t sub_1CD4AB93C(uint64_t **a1, unint64_t a2, uint64_t a3)
{
  unsigned int v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        return 0;
      }
      int v5 = v7[1];
      if (!v5)
      {
        unsigned int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    int v9 = (uint64_t *)operator new(0x28uLL);
    void v9[4] = a3;
    *int v9 = 0;
    v9[1] = 0;
    uint64_t v9[2] = (uint64_t)v7;
    *unsigned int v6 = v9;
    uint64_t v10 = (uint64_t *)**a1;
    if (v10)
    {
      *a1 = v10;
      unint64_t v11 = *v6;
    }
    else
    {
      unint64_t v11 = v9;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return 1;
  }
}

uint64_t sub_1CD4ABA00(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      unsigned int v6 = v2;
    }
    else {
      unsigned int v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == (uint64_t *)(a1 + 8) || v3[4] > a2) {
    return 0;
  }
  sub_1CD491B50((uint64_t **)a1, v3);
  operator delete(v3);
  return 1;
}

uint64_t sub_1CD4ABA78(uint64_t a1, unsigned int a2)
{
  char v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(void **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4ABC04(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  int v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *int v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4ABC04(a1, v14, v9);
}

uint64_t sub_1CD4ABC04(uint64_t result, void *a2, void *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    int v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    int v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CC0BE050((uint64_t)v5, a2, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1CD4ABCCC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1 == *(void *)(a1 + 32)) {
    return 0;
  }
  else {
    return v1 - 8;
  }
}

uint64_t sub_1CD4ABCE4(uint64_t a1)
{
  if (*(void *)(a1 + 16) == *(void *)(a1 + 40)) {
    return 0;
  }
  else {
    return *(void *)(a1 + 16);
  }
}

uint64_t sub_1CD4ABCF8(uint64_t a1, unsigned int a2)
{
  char v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4ABE84(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  int v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *int v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4ABE84(a1, v14, v9);
}

uint64_t sub_1CD4ABE84(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    int v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    int v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      int v12 = 0;
      uint64_t result = sub_1CC0BECBC((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *int v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CD4ABF48(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v14 = 0;
  uint64_t result = (void *)sub_1CD4AC008(a2, *a3, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 4;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    char v11 = 0;
    uint64_t v10 = v12 + 8 * v13;
  }
  else
  {
    uint64_t result = sub_1CD4AC0AC((_DWORD *)a2, a3, v14);
    uint64_t v7 = result;
    *uint64_t result = *a3;
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 4;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v10 = v8 + 8 * v9;
    char v11 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v10;
  *(unsigned char *)(a1 + 16) = v11;
  return result;
}

uint64_t sub_1CD4AC008(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
LABEL_17:
    uint64_t result = 1;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1;
    while (v8 != -4096)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v9 = v7;
      }
      unsigned int v13 = v6 + v10++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_17;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

void *sub_1CD4AC0AC(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v3 = *a1 >> 1;
  if (*a1) {
    unsigned int v4 = 4;
  }
  else {
    unsigned int v4 = a1[4];
  }
  if (4 * v3 + 4 >= 3 * v4)
  {
    v4 *= 2;
  }
  else if (v4 + ~v3 - a1[1] > v4 >> 3)
  {
    goto LABEL_5;
  }
  uint64_t v7 = (uint64_t)a1;
  sub_1CD4AC170((uint64_t)a1, v4);
  uint64_t v8 = 0;
  sub_1CD4AC008(v7, *a2, &v8);
  a1 = (_DWORD *)v7;
  a3 = v8;
LABEL_5:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD4AC170(uint64_t a1, unsigned int a2)
{
  v14[4] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4AC2EC(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 40; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4AC2EC(a1, v14, v8);
}

uint64_t sub_1CD4AC2EC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 40);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD4AC008((uint64_t)v5, v10, &v11);
      *uint64_t v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

void sub_1CD4AC3B0(unsigned int *a1, char *a2, char *a3)
{
  unint64_t v4 = a2;
  unint64_t v6 = a3 - a2;
  uint64_t v7 = a1[2];
  unint64_t v8 = v7 + ((a3 - a2) >> 3);
  if (v8 > a1[3])
  {
    sub_1CC0BD844(a1, v8);
    LODWORD(v7) = a1[2];
  }
  if (v4 != a3)
  {
    uint64_t v9 = (llvm::ValueHandleBase *)(*(void *)a1 + 24 * v7);
    do
    {
      uint64_t v10 = *(void *)v4;
      *(void *)uint64_t v9 = 4;
      *((void *)v9 + 1) = 0;
      *((void *)v9 + 2) = v10;
      if (v10 != -8192 && v10 != -4096 && v10 != 0) {
        llvm::ValueHandleBase::AddToUseList(v9);
      }
      v4 += 8;
      uint64_t v9 = (llvm::ValueHandleBase *)((char *)v9 + 24);
    }
    while (v4 != a3);
    LODWORD(v7) = a1[2];
  }
  a1[2] = v7 + (v6 >> 3);
}

void *sub_1CD4AC46C(void *result)
{
  int v1 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if (v1)
    {
      uint64_t v2 = result + 1;
      unint64_t v3 = result + 5;
    }
    else
    {
      uint64_t v5 = *((unsigned int *)result + 4);
      if (((2 * v1) & 0xFFFFFFFC) < v5)
      {
        if (v5 > 0x40) {
          return sub_1CD4AC4E8(result);
        }
      }
      else if (!v5)
      {
        int v4 = 0;
LABEL_6:
        *(_DWORD *)uint64_t result = v4;
        *((_DWORD *)result + 1) = 0;
        return result;
      }
      uint64_t v2 = (void *)result[1];
      unint64_t v3 = &v2[v5];
    }
    do
      *v2++ = -4096;
    while (v2 != v3);
    int v4 = *(_DWORD *)result & 1;
    goto LABEL_6;
  }
  return result;
}

void *sub_1CD4AC4E8(void *result)
{
  int v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  unsigned int v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if (v3 - 28 >= 3) {
    int v4 = 1 << (33 - v3);
  }
  else {
    int v4 = 64;
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 5)
  {
    unint64_t v6 = result + 1;
    *uint64_t result = 1;
    uint64_t v7 = result + 5;
    do
LABEL_10:
      *v6++ = -4096;
    while (v6 != v7);
    return result;
  }
  if ((v2 & 1) == 0)
  {
    if (v5 == *((_DWORD *)result + 4))
    {
      *uint64_t result = 0;
      if (!v5) {
        return result;
      }
      unint64_t v6 = (void *)result[1];
      uint64_t v7 = &v6[v5];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](result[1], 8);
  }

  return sub_1CD4AB6EC(v1, v5);
}

uint64_t sub_1CD4AC5C0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void llvm::createModuleDebugInfoPrinterPass(llvm *this)
{
}

double llvm::ModuleDebugInfoPrinterPass::ModuleDebugInfoPrinterPass(llvm::ModuleDebugInfoPrinterPass *this, llvm::raw_ostream *a2)
{
  *(void *)this = (char *)this + 16;
  *((void *)this + 1) = 0x800000000;
  *((void *)this + 10) = (char *)this + 96;
  *((void *)this + 11) = 0x800000000;
  *((void *)this + 20) = (char *)this + 176;
  *((void *)this + 21) = 0x800000000;
  *((void *)this + 30) = (char *)this + 256;
  *((void *)this + 31) = 0x800000000;
  *((void *)this + 40) = (char *)this + 336;
  *((void *)this + 41) = 0x800000000;
  *((void *)this + 50) = (char *)this + 432;
  *((void *)this + 51) = (char *)this + 432;
  *(void *)&double result = 32;
  *((void *)this + 52) = 32;
  *((_DWORD *)this + 106) = 0;
  *((void *)this + 86) = a2;
  return result;
}

double llvm::ModuleDebugInfoPrinterPass::run@<D0>(llvm::raw_ostream **a1@<X0>, const llvm::Module *a2@<X1>, uint64_t a3@<X8>)
{
  llvm::DebugInfoFinder::processModule((llvm::DebugInfoFinder *)a1, a2);
  sub_1CC0BF1B4(a1[86], (unsigned __int8 ***)a1);
  *(void *)(a3 + 32) = &llvm::PreservedAnalyses::AllAnalysesKey;
  *(void *)a3 = a3 + 32;
  *(void *)(a3 + 8) = a3 + 32;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 48) = a3 + 80;
  *(void *)(a3 + 56) = a3 + 80;
  *(void *)(a3 + 64) = 2;
  *(_DWORD *)(a3 + 72) = 0;
  *(void *)&double result = 0x100000002;
  *(void *)(a3 + 16) = 0x100000002;
  return result;
}

uint64_t sub_1CD4AC784(llvm::GlobalValue *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  llvm::GlobalValue::getGlobalIdentifier(a1, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = (int *)&__p;
  }
  else {
    p_p = (int *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t size = __p.__r_.__value_.__l.__size_;
  }
  long long v7 = xmmword_1CFAC4320;
  uint64_t v8 = 0;
  llvm::MD5::update((int *)&v7, p_p, size);
  llvm::MD5::final((int *)&v7, v6);
  uint64_t v3 = *(void *)v6;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v3;
}

void llvm::ModuleSummaryIndexAnalysis::run()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::initializeModuleSummaryIndexWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6C50, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0C3198;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6C50, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::ModuleSummaryIndexWrapperPass *llvm::ModuleSummaryIndexWrapperPass::ModuleSummaryIndexWrapperPass(llvm::ModuleSummaryIndexWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::ModuleSummaryIndexWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2605DD0;
  *((unsigned char *)this + 32) = 0;
  *((unsigned char *)this + 336) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6C50, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0C3198;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCC6C50, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::ModuleSummaryIndexWrapperPass::runOnModule(llvm::ModuleSummaryIndexWrapperPass *this, llvm::Module *a2)
{
  v15[38] = *MEMORY[0x1E4F143B8];
  int v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_2:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(char **)v5 != llvm::ProfileSummaryInfoWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_2;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 96))(v7, llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
  char v10 = llvm::needsParamAccessSummary((uint64_t)a2);
  v13[0] = &unk_1F2606128;
  v13[1] = this;
  uint64_t v14 = v13;
  v11[0] = &unk_1F2606170;
  v11[1] = &v10;
  void v11[2] = this;
  BOOL v12 = v11;
  ((void (*)(void *__return_ptr, llvm::Module *, void *, uint64_t, void *))llvm::buildModuleSummaryIndex)(v15, a2, v13, v8, v11);
  if (*((unsigned char *)this + 336))
  {
    sub_1CD4AFAF4((uint64_t)this + 32);
    *((unsigned char *)this + 336) = 0;
  }
  sub_1CD4B05C8((uint64_t)this + 32, (uint64_t)v15);
  *((unsigned char *)this + 336) = 1;
  sub_1CD4AFAF4((uint64_t)v15);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void))(*v14 + 40))();
  }
  return 0;
}

uint64_t llvm::ModuleSummaryIndexWrapperPass::doFinalization(llvm::ModuleSummaryIndexWrapperPass *this, llvm::Module *a2)
{
  if (*((unsigned char *)this + 336))
  {
    sub_1CD4AFAF4((uint64_t)this + 32);
    *((unsigned char *)this + 336) = 0;
  }
  return 0;
}

llvm::AnalysisUsage *llvm::ModuleSummaryIndexWrapperPass::getAnalysisUsage(llvm::ModuleSummaryIndexWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, llvm::BlockFrequencyInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::ProfileSummaryInfoWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredID(a2, llvm::StackSafetyInfoWrapperPass::ID);
}

llvm::ImmutableModuleSummaryIndexWrapperPass *llvm::ImmutableModuleSummaryIndexWrapperPass::ImmutableModuleSummaryIndexWrapperPass(llvm::ImmutableModuleSummaryIndexWrapperPass *this, const llvm::ModuleSummaryIndex *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::ImmutableModuleSummaryIndexWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2605E70;
  *((void *)this + 4) = a2;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6C58, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC0C328C;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCC6C58, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeImmutableModuleSummaryIndexWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6C58, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0C328C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6C58, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::ImmutableModuleSummaryIndexWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::createImmutableModuleSummaryIndexWrapperPass(llvm *this, const llvm::ModuleSummaryIndex *a2)
{
}

void sub_1CD4ACF98(llvm::ModulePass *this)
{
  *(void *)this = &unk_1F2605DD0;
  if (*((unsigned char *)this + 336))
  {
    sub_1CD4AFAF4((uint64_t)this + 32);
    *((unsigned char *)this + 336) = 0;
  }

  llvm::ModulePass::~ModulePass(this);
}

void sub_1CD4AD000(llvm::ModulePass *this)
{
  *(void *)this = &unk_1F2605DD0;
  if (*((unsigned char *)this + 336))
  {
    sub_1CD4AFAF4((uint64_t)this + 32);
    *((unsigned char *)this + 336) = 0;
  }
  llvm::ModulePass::~ModulePass(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4AD080(llvm::ImmutablePass *a1)
{
  llvm::ImmutablePass::~ImmutablePass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD4AD0B8(void *a1)
{
  *a1 = &unk_1F2605F18;
  unsigned int v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2605F80;
  int v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD4AD1A0(void *a1)
{
  *a1 = &unk_1F2605F80;
  unsigned int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD4AD1F4(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  **(_DWORD **)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD4AD28C(v11);
}

uint64_t sub_1CD4AD28C(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD4AD2A4(void *a1)
{
  sub_1CD4AD0B8(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD4AD2DC(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD4AD2E8(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD4AD2F8(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = **((_DWORD **)result + 16);
LABEL_3:
    int v4 = &unk_1F2605FD0;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = **((_DWORD **)result + 16);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD4AD384(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  **(_DWORD **)(result + 128) = v1;
  return result;
}

void *sub_1CD4AD39C(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD4AD3A4(void *a1)
{
  *a1 = &unk_1F2605F80;
  unsigned int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4AD418(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD4AD420(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD4AD434(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD4AD448(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD4AD45C(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

double sub_1CD4AD488(uint64_t a1, char a2, char a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x2800000000;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = a1 + 112;
  *(_DWORD *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 0;
  *(unsigned char *)(a1 + 133) = a2;
  *(unsigned char *)(a1 + 134) = a3;
  *(_WORD *)(a1 + 135) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = a1 + 176;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = a1 + 232;
  *(void *)(a1 + 224) = 0x400000000;
  *(void *)(a1 + 264) = a1 + 280;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)&double result = 1;
  *(_OWORD *)(a1 + 288) = xmmword_1CD91D2E0;
  return result;
}

uint64_t sub_1CD4AD530(uint64_t a1, unint64_t *a2)
{
  uint64_t v13 = *a2;
  int v14 = 0;
  sub_1CD4AE6E8((uint64_t)&v11, a1, &v13, &v14);
  uint64_t v4 = v11;
  if (v12)
  {
    long long v10 = *a2;
    int v5 = *(_OWORD **)(a1 + 32);
    if ((unint64_t)v5 >= *(void *)(a1 + 40))
    {
      char v6 = sub_1CC00319C((void **)(a1 + 24), &v10);
    }
    else
    {
      *int v5 = v10;
      char v6 = v5 + 1;
    }
    *(void *)(a1 + 32) = v6;
    uint64_t v8 = *(void *)(a1 + 24);
    unsigned int v7 = (((unint64_t)v6 - v8) >> 4) - 1;
    *(_DWORD *)(v4 + 8) = v7;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(v11 + 8);
    uint64_t v8 = *(void *)(a1 + 24);
  }
  return v8 + 16 * v7 + 8;
}

uint64_t sub_1CD4AD5F0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    int v3 = (_DWORD *)result;
    v8[1] = 0;
    uint64_t v9 = a2;
    __int16 v10 = 8;
    v8[0] = a3;
    sub_1CBF7DF38((uint64_t)&v9, (uint64_t)v8);
    double result = sub_1CBF830A4((uint64_t)&v9);
    unint64_t v4 = *v3;
    unint64_t v5 = result + (v4 >> 3);
    BOOL v6 = __CFADD__(result, v4 >> 3);
    if (v5 < v4 >> 3) {
      BOOL v6 = 1;
    }
    if (v5 >= 0x1FFFFFFF) {
      LODWORD(v5) = 0x1FFFFFFF;
    }
    int v7 = 8 * v5;
    if (v6) {
      int v7 = -8;
    }
    *int v3 = v7 & 0xFFFFFFF8 | *v3 & 7;
  }
  return result;
}

uint64_t sub_1CD4AD67C(uint64_t a1, void *a2)
{
  uint64_t v9 = 0;
  uint64_t v4 = sub_1CD4AD868((uint64_t *)a1, a2, &v9);
  if (v4)
  {
    *uint64_t v9 = -16;
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    BOOL v6 = *(char **)(a1 + 24);
    unint64_t v5 = *(char **)(a1 + 32);
    if (v6 != v5)
    {
      while ((*(void *)v6 & 0xFFFFFFFFFFFFFFF8) != (*a2 & 0xFFFFFFFFFFFFFFF8))
      {
        v6 += 8;
        if (v6 == v5)
        {
          BOOL v6 = *(char **)(a1 + 32);
          break;
        }
      }
    }
    int64_t v7 = v5 - (v6 + 8);
    if (v5 != v6 + 8) {
      memmove(v6, v6 + 8, v5 - (v6 + 8));
    }
    *(void *)(a1 + 32) = &v6[v7];
  }
  return v4;
}

uint64_t sub_1CD4AD73C(uint64_t a1, llvm::GlobalValue *a2, uint64_t *a3)
{
  unint64_t v6 = sub_1CD4AC784(a2);
  int64_t v7 = sub_1CD4ADB54(a1, v6);
  *((void *)v7 + 1) = a2;
  unint64_t v8 = (unint64_t)v7 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(a1 + 133);
  uint64_t v9 = *a3;
  *a3 = 0;
  uint64_t v11 = v9;
  sub_1CC0C4C58(a1, v8, &v11);
  uint64_t result = v11;
  uint64_t v11 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t sub_1CD4AD7E0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  __int16 v10 = 0;
  uint64_t result = sub_1CD4AD868((uint64_t *)a1, a2, &v10);
  int64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4AD90C(a1, (uint64_t)a2, a2, v10);
    int64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD4AD868(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unint64_t v6 = *a2 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v7 = (v3 - 1) & *a2 & 0xFFFFFFF8;
    char v8 = (void *)(*a1 + 8 * v7);
    unint64_t v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
    if (v6 == v9)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      uint64_t result = 1;
      while (v9 != -8)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 == -16;
        }
        if (v13) {
          uint64_t v11 = v8;
        }
        unsigned int v14 = v7 + v12++;
        unsigned int v7 = v14 & v5;
        char v8 = (void *)(v4 + 8 * (v14 & v5));
        unint64_t v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
        if (v6 == v9) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v11) {
        char v8 = v11;
      }
    }
  }
  else
  {
    char v8 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v8;
  return result;
}

void *sub_1CD4AD90C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4AD9C0(a1, v7);
  unint64_t v9 = 0;
  sub_1CD4AD868((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if ((~*a4 & 0xFFFFFFFFFFFFFFF8) != 0) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void sub_1CD4AD9C0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  unint64_t v9 = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = v9;
  if (v4)
  {
    sub_1CD4ADAA4(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    memset_pattern16(v9, &unk_1CFAC4330, 8 * v10);
  }
}

void sub_1CD4ADAA4(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6) {
    memset_pattern16(*(void **)a1, &unk_1CFAC4330, 8 * v6);
  }
  for (; a2 != a3; ++a2)
  {
    if ((~*a2 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      int v7 = 0;
      sub_1CD4AD868((uint64_t *)a1, a2, &v7);
      *int v7 = *a2;
      ++*(_DWORD *)(a1 + 8);
    }
  }
}

char *sub_1CD4ADB54(uint64_t a1, unint64_t a2)
{
  unint64_t v7 = a2;
  if (*(unsigned char *)(a1 + 133))
  {
    unsigned int v2 = 0;
  }
  else
  {
    v5[1] = 0;
    unsigned int v2 = "";
  }
  v5[0] = v2;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = sub_1CD4ADBD0((uint64_t **)a1, &v7, &v7, (uint64_t)v5) + 32;
  unsigned int v8 = (void **)v6;
  sub_1CC0C3EE0(&v8);
  return v3;
}

char *sub_1CD4ADBD0(uint64_t **a1, unint64_t *a2, void *a3, uint64_t a4)
{
  unsigned int v8 = a1 + 1;
  unint64_t v7 = (char *)a1[1];
  if (v7)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v10 = v7;
        unint64_t v11 = *((void *)v7 + 4);
        if (v9 >= v11) {
          break;
        }
        unint64_t v7 = *(char **)v10;
        unsigned int v8 = (uint64_t **)v10;
        if (!*(void *)v10) {
          goto LABEL_10;
        }
      }
      if (v11 >= v9) {
        break;
      }
      unint64_t v7 = (char *)*((void *)v10 + 1);
      if (!v7)
      {
        unsigned int v8 = (uint64_t **)(v10 + 8);
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v10 = (char *)(a1 + 1);
LABEL_10:
    int v12 = v10;
    uint64_t v10 = (char *)operator new(0x50uLL);
    long long v13 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v10 + 40) = *(_OWORD *)a4;
    *((void *)v10 + 4) = *a3;
    *(_OWORD *)(v10 + 56) = v13;
    *((void *)v10 + 9) = *(void *)(a4 + 32);
    *(void *)(a4 + 24) = 0;
    *(void *)(a4 + 32) = 0;
    *(void *)(a4 + 16) = 0;
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v12;
    *unsigned int v8 = (uint64_t *)v10;
    unsigned int v14 = (uint64_t *)**a1;
    uint64_t v15 = (uint64_t *)v10;
    if (v14)
    {
      *a1 = v14;
      uint64_t v15 = *v8;
    }
    sub_1CB8358B8(a1[1], v15);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

void *sub_1CD4ADCD0@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (!v6)
  {
    int v12 = 0;
LABEL_6:
    uint64_t result = sub_1CD4ADDB8(a1, (uint64_t)a2, a2, v12);
    *uint64_t result = *a2;
    uint64_t v7 = *(void *)a1;
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    char v11 = 1;
    goto LABEL_4;
  }
  uint64_t v7 = *(void *)a1;
  unsigned int v8 = (37 * *a2) & (v6 - 1);
  uint64_t result = (void *)(*(void *)a1 + 8 * v8);
  uint64_t v10 = *result;
  if (*a2 != *result)
  {
    long long v13 = 0;
    int v14 = 1;
    while (v10 != -1)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v10 == -2;
      }
      if (v15) {
        long long v13 = result;
      }
      unsigned int v16 = v8 + v14++;
      unsigned int v8 = v16 & (v6 - 1);
      uint64_t result = (void *)(v7 + 8 * v8);
      uint64_t v10 = *result;
      if (*a2 == *result) {
        goto LABEL_3;
      }
    }
    if (v13) {
      int v12 = v13;
    }
    else {
      int v12 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v11 = 0;
LABEL_4:
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v7 + 8 * v6;
  *(unsigned char *)(a3 + 16) = v11;
  return result;
}

void *sub_1CD4ADDB8(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1CD4ADF30(a1, 2 * v7);
    uint64_t v8 = *a3;
    int v10 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v11 = (37 * *a3) & v10;
    a4 = (void *)(*(void *)a1 + 8 * v11);
    uint64_t v12 = *a4;
    if (*a3 != *a4)
    {
      long long v13 = 0;
      int v14 = 1;
      while (v12 != -1)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -2;
        }
        if (v15) {
          long long v13 = a4;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        a4 = (void *)(*(void *)a1 + 8 * v11);
        uint64_t v12 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      uint64_t v8 = *a4;
      goto LABEL_4;
    }
    sub_1CD4ADF30(a1, v7);
    uint64_t v8 = *a3;
    int v17 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v18 = (37 * *a3) & v17;
    a4 = (void *)(*(void *)a1 + 8 * v18);
    uint64_t v19 = *a4;
    if (*a3 != *a4)
    {
      long long v13 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v13) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          long long v13 = a4;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a4 = (void *)(*(void *)a1 + 8 * v18);
        uint64_t v19 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v13) {
        a4 = v13;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD4ADF30(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4AE010((void *)a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    return memset(result, 255, 8 * v10);
  }
  return result;
}

void *sub_1CD4AE010(void *result, uint64_t *a2, uint64_t *a3)
{
  unint64_t v5 = result;
  result[1] = 0;
  unint64_t v6 = (char *)*result;
  uint64_t v7 = *((unsigned int *)result + 4);
  if (v7) {
    uint64_t result = memset((void *)*result, 255, 8 * v7);
  }
  if (a2 != a3)
  {
    int v8 = 0;
    int v9 = v7 - 1;
    do
    {
      uint64_t v10 = *a2;
      if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        unsigned int v11 = (37 * v10) & v9;
        uint64_t v12 = &v6[8 * v11];
        uint64_t v13 = *(void *)v12;
        if (v10 != *(void *)v12)
        {
          int v14 = 0;
          int v15 = 1;
          while (v13 != -1)
          {
            if (v14) {
              BOOL v16 = 0;
            }
            else {
              BOOL v16 = v13 == -2;
            }
            if (v16) {
              int v14 = v12;
            }
            unsigned int v17 = v11 + v15++;
            unsigned int v11 = v17 & v9;
            uint64_t v12 = &v6[8 * (v17 & v9)];
            uint64_t v13 = *(void *)v12;
            if (v10 == *(void *)v12) {
              goto LABEL_7;
            }
          }
          if (v14) {
            uint64_t v12 = v14;
          }
        }
LABEL_7:
        *(void *)uint64_t v12 = v10;
        *((_DWORD *)v5 + 2) = ++v8;
      }
      ++a2;
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t sub_1CD4AE104(uint64_t a1, void *a2)
{
  uint64_t result = sub_1CD4AE428((uint64_t)v5, a1, a2);
  if (v5[16])
  {
    return sub_1CC0C445C((uint64_t *)(a1 + 24), (uint64_t)a2);
  }
  return result;
}

uint64_t sub_1CD4AE170(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD4AE204(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4AE2A0(a2, a3, v10);
    uint64_t v7 = (void *)result;
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CD4AE204(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a2)
  {
    int v5 = a2 - 1;
    unsigned int v6 = (a2 - 1) & a3;
    uint64_t v7 = (void *)(a1 + 16 * v6);
    uint64_t v8 = *v7;
    uint64_t v9 = v7[1];
    if (*v7 == a3 && v9 == a4)
    {
      uint64_t v11 = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = 1;
      while (v8 || v9 != -1)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v9 == -2;
        }
        if (v15 && v8 == 0) {
          uint64_t v13 = v7;
        }
        unsigned int v17 = v6 + v14++;
        unsigned int v6 = v17 & v5;
        uint64_t v7 = (void *)(a1 + 16 * (v17 & v5));
        uint64_t v8 = *v7;
        uint64_t v9 = v7[1];
        uint64_t v11 = 1;
        if (*v7 == a3 && v9 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v11 = 0;
      if (v13) {
        uint64_t v7 = v13;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v11 = 0;
  }
LABEL_8:
  *a5 = v7;
  return v11;
}

void *sub_1CD4AE2A0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4AE358(a1, v6);
  uint64_t v9 = 0;
  sub_1CD4AE204(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = a3[1] == -1;
  }
  if (!v7) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD4AE358(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC0C43A8(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *result++ = xmmword_1CD91C150;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4AE428(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CC0C44C4(*(void *)a2, *(_DWORD *)(a2 + 16), a3, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4AE4B0(a2, v10, (uint64_t)a3);
    int v7 = (void *)result;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 40 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

void *sub_1CD4AE4B0(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = sub_1CC0C46DC(a1, (void *)a3, a2);
  unint64_t v5 = v4;
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
  if (v4 != (void *)a3) {
    sub_1CBFAFDE4(v4 + 2, *(char **)(a3 + 16), *(char **)(a3 + 24), (uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 3);
  }
  return v5;
}

char *sub_1CD4AE508(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(__n128 **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC0C47A8(a1, v4, (__n128 *)((char *)v4 + 40 * v3));
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = &result[40 * v10];
    do
    {
      *(_OWORD *)uint64_t result = xmmword_1CD91C150;
      *((void *)result + 3) = 0;
      *((void *)result + 4) = 0;
      *((void *)result + 2) = 0;
      result += 40;
    }
    while (result != v11);
  }
  return result;
}

uint64_t *sub_1CD4AE5F0(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 40;
      *(_OWORD *)(v4 - 40) = *(_OWORD *)(v3 - 40);
      *(void *)(v4 - 16) = 0;
      *(void *)(v4 - 8) = 0;
      *(void *)(v4 - 24) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      v3 -= 40;
      v4 -= 40;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v6 = *result;
  *uint64_t result = v5;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1CD4AE684(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 40;
    uint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CD4AE6E8(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD4AE784((uint64_t *)a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4AE828(a2, (uint64_t)a3, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD4AE784(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unint64_t v6 = *a2 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v7 = (v3 - 1) & *a2 & 0xFFFFFFF8;
    uint64_t v8 = (void *)(*a1 + 16 * v7);
    unint64_t v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
    if (v6 == v9)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      uint64_t result = 1;
      while (v9 != -8)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 == -16;
        }
        if (v13) {
          uint64_t v11 = v8;
        }
        unsigned int v14 = v7 + v12++;
        unsigned int v7 = v14 & v5;
        uint64_t v8 = (void *)(v4 + 16 * (v14 & v5));
        unint64_t v9 = *v8 & 0xFFFFFFFFFFFFFFF8;
        if (v6 == v9) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v8 = v11;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v8;
  return result;
}

void *sub_1CD4AE828(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4AE8DC(a1, v7);
  unint64_t v9 = 0;
  sub_1CD4AE784((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if ((~*a4 & 0xFFFFFFFFFFFFFFF8) != 0) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD4AE8DC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4AE9A8(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -8;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4AE9A8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -8;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      if ((~*(void *)v4 & 0xFFFFFFFFFFFFFFF0) != 0)
      {
        uint64_t v10 = 0;
        uint64_t result = sub_1CD4AE784((uint64_t *)v5, (void *)v4, &v10);
        unint64_t v9 = v10;
        void *v10 = *(void *)v4;
        *((_DWORD *)v9 + 2) = *(_DWORD *)(v4 + 8);
        ++*(_DWORD *)(v5 + 8);
      }
      v4 += 16;
    }
    while (v4 != a3);
  }
  return result;
}

void sub_1CD4AEA64(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1CD4AEAE8(a1);
    }
    else
    {
      if (v3) {
        memset_pattern16(*(void **)a1, &unk_1CFAC4330, 8 * v3);
      }
      *(void *)(a1 + 8) = 0;
    }
  }
}

void sub_1CD4AEAE8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 8);
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *(void *)(a1 + 8) = 0;
    if (v2)
    {
      uint64_t v6 = *(void **)a1;
      memset_pattern16(v6, &unk_1CFAC4330, 8 * v2);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC0C3CFC(a1, v5);
  }
}

void sub_1CD4AEBA8(void **a1)
{
  int v1 = (char *)*a1;
  if (*a1)
  {
    int v3 = (char *)a1[1];
    int v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        int v5 = (void **)(v3 - 24);
        sub_1CC0C49BC(&v5);
        sub_1CC05EB8C((uint64_t)(v3 - 56));
        v3 -= 64;
      }
      while (v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

__n128 sub_1CD4AEC2C(uint64_t a1, int a2, int a3, int a4, uint64_t a5, long long *a6, __n128 *a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  uint64_t v13 = *((void *)a6 + 2);
  long long v14 = *a6;
  *((void *)a6 + 1) = 0;
  *((void *)a6 + 2) = 0;
  *(void *)a6 = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 12) = a2;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 40) = v14;
  *(void *)(a1 + 56) = v13;
  *(void *)a1 = &unk_1F26061B8;
  *(_DWORD *)(a1 + 64) = a3;
  *(_DWORD *)(a1 + 68) = a4;
  *(void *)(a1 + 72) = a5;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  __n128 result = *a7;
  *(__n128 *)(a1 + 80) = *a7;
  *(void *)(a1 + 96) = a7[1].n128_u64[0];
  a7->n128_u64[0] = 0;
  a7->n128_u64[1] = 0;
  a7[1].n128_u64[0] = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  if (*a8 != a8[1] || *a9 != a9[1] || *a10 != a10[1] || *a11 != a11[1] || *a12 != a12[1])
  {
    *a8 = 0;
    a8[1] = 0;
    a8[2] = 0;
    a9[1] = 0;
    a9[2] = 0;
    *a9 = 0;
    a10[1] = 0;
    a10[2] = 0;
    *a10 = 0;
    a11[1] = 0;
    a11[2] = 0;
    *a11 = 0;
    a12[1] = 0;
    a12[2] = 0;
    *a12 = 0;
    operator new();
  }
  if (*a13 != a13[1]) {
    operator new();
  }
  return result;
}

void sub_1CD4AEEB8(void *a1)
{
  sub_1CD4AF02C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD4AEEF0(void *a1)
{
  *a1 = &unk_1F26061D8;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1CD4AEF40(void *a1)
{
  *a1 = &unk_1F26061D8;
  uint64_t v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4AEFB0(uint64_t a1)
{
  uint64_t v6 = (void **)(a1 + 96);
  sub_1CC0C4BCC(&v6);
  uint64_t v6 = (void **)(a1 + 72);
  sub_1CC0C4BCC(&v6);
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  int v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  int v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
  }
  return a1;
}

void *sub_1CD4AF02C(void *a1)
{
  *a1 = &unk_1F26061B8;
  uint64_t v2 = (void **)a1[14];
  a1[14] = 0;
  if (v2)
  {
    uint64_t v8 = v2;
    sub_1CC0C4A94(&v8);
    MEMORY[0x1D25D9CE0](v2, 0x20C40960023A9);
  }
  uint64_t v3 = a1[13];
  a1[13] = 0;
  if (v3)
  {
    uint64_t v7 = sub_1CD4AEFB0(v3);
    MEMORY[0x1D25D9CE0](v7, 0x30C4045335465);
  }
  int v4 = (void *)a1[10];
  if (v4)
  {
    a1[11] = v4;
    operator delete(v4);
  }
  *a1 = &unk_1F26061D8;
  int v5 = (void *)a1[5];
  if (v5)
  {
    a1[6] = v5;
    operator delete(v5);
  }
  return a1;
}

_DWORD *sub_1CD4AF108(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD4AF158(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          void *v2 = -8;
          v2 += 2;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

_DWORD *sub_1CD4AF158(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(void **)result;
      uint64_t v7 = 16 * v2;
      do
      {
        *uint64_t v6 = -8;
        v6 += 2;
        v7 -= 16;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC0C3C68(v1, v5);
  }
  return result;
}

void *sub_1CD4AF204(void *result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (v2 || *((_DWORD *)result + 3))
  {
    uint64_t v3 = *((unsigned int *)result + 4);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      return sub_1CD4AF284(result);
    }
    else
    {
      if (v3) {
        __n128 result = memset((void *)*result, 255, 8 * v3);
      }
      v1[1] = 0;
    }
  }
  return result;
}

void *sub_1CD4AF284(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    result[1] = 0;
    if (v2)
    {
      uint64_t v6 = (void *)*result;
      return memset(v6, 255, 8 * v2);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*result, 8);
    return sub_1CC0C3328(v1, v5);
  }
  return result;
}

_DWORD *sub_1CD4AF340(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD4AF394(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(_OWORD **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          *v2++ = xmmword_1CD91C150;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

_DWORD *sub_1CD4AF394(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(_OWORD **)result;
      uint64_t v7 = 16 * v2;
      do
      {
        *v6++ = xmmword_1CD91C150;
        v7 -= 16;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC0C3DA0(v1, v5);
  }
  return result;
}

void sub_1CD4AF444(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  if (v2 || a1[3])
  {
    unsigned int v3 = a1[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1CD4AF508(a1);
    }
    else
    {
      if (v3)
      {
        int v4 = *(_OWORD **)a1;
        uint64_t v5 = *(void *)a1 + 40 * v3;
        do
        {
          uint64_t v6 = v4 + 1;
          *int v4 = xmmword_1CD91C150;
          int v4 = (_OWORD *)((char *)v4 + 40);
          sub_1CBFAFDE4(v6, 0, 0, 0);
        }
        while (v4 != (_OWORD *)v5);
      }
      *((void *)a1 + 1) = 0;
    }
  }
}

void sub_1CD4AF508(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CC0C4B6C(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(void *)a1;
      uint64_t v6 = *(void *)a1 + 40 * v4;
      do
      {
        *(_OWORD *)uint64_t v5 = xmmword_1CD91C150;
        *(void *)(v5 + 24) = 0;
        *(void *)(v5 + 32) = 0;
        *(void *)(v5 + 16) = 0;
        v5 += 40;
      }
      while (v5 != v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC0C3E38((char *)a1, v4);
  }
}

uint64_t **sub_1CD4AF5CC(uint64_t **result, uint64_t *a2, unint64_t a3)
{
  unint64_t v7 = a3;
  if (a3 && a2 != (uint64_t *)a3)
  {
    unsigned int v4 = result + 13;
    uint64_t v5 = result[14];
    if (!v5) {
      goto LABEL_5;
    }
    while (1)
    {
      unint64_t v6 = v5[4];
      if (v6 <= a3)
      {
        if (v6 >= a3)
        {
          uint64_t v8 = (uint64_t **)&v7;
          if (sub_1CD4AF6BC(result + 13, &v7, (uint64_t)&std::piecewise_construct, &v8)[5] != a2)
          {
            uint64_t v8 = (uint64_t **)&v7;
            __n128 result = sub_1CD4AF6BC(v4, &v7, (uint64_t)&std::piecewise_construct, &v8);
            result[5] = 0;
            return result;
          }
LABEL_5:
          uint64_t v8 = (uint64_t **)&v7;
          __n128 result = sub_1CD4AF6BC(v4, &v7, (uint64_t)&std::piecewise_construct, &v8);
          result[5] = a2;
          return result;
        }
        ++v5;
      }
      uint64_t v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t **sub_1CD4AF6BC(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t ***a4)
{
  unint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)v9;
    unint64_t v9 = (uint64_t **)operator new(0x30uLL);
    void v9[4] = **a4;
    v9[5] = 0;
    *unint64_t v9 = 0;
    v9[1] = 0;
    uint64_t v9[2] = v11;
    *unint64_t v7 = (uint64_t *)v9;
    int v12 = (uint64_t *)**a1;
    uint64_t v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1 = v12;
      uint64_t v13 = *v7;
    }
    sub_1CB8358B8(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

char *sub_1CD4AF7A0(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
  uint64_t v3 = a1 + 80;
  std::string::__init(&v6, a2, a3);
  unint64_t v7 = &v6;
  unsigned int v4 = sub_1CD4AF80C(v3, (uint64_t)&v6, (uint64_t)&std::piecewise_construct, (_OWORD **)&v7);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  return (char *)v4 + 56;
}

_OWORD *sub_1CD4AF80C(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  std::string v6 = (void **)sub_1CD4AF8D4(a1, &v15, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v9 = v6;
    unint64_t v7 = operator new(0x50uLL);
    unint64_t v10 = *a4;
    uint64_t v11 = *((void *)*a4 + 2);
    void v7[2] = **a4;
    *((void *)v7 + 6) = v11;
    v10[1] = 0;
    uint64_t v10[2] = 0;
    void *v10 = 0;
    *((void *)v7 + 7) = 0;
    *((void *)v7 + 8) = 0;
    *((void *)v7 + 9) = 0;
    uint64_t v12 = v15;
    *(void *)unint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v12;
    *unint64_t v9 = v7;
    uint64_t v13 = **(void **)a1;
    long long v14 = (uint64_t *)v7;
    if (v13)
    {
      *(void *)a1 = v13;
      long long v14 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v14);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

void *sub_1CD4AF8D4(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  unsigned int v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = v4;
        unint64_t v9 = v4 + 4;
        unint64_t v8 = (const void *)v4[4];
        char v10 = *((unsigned char *)v9 + 23);
        int v11 = v10;
        if (v10 >= 0) {
          unint64_t v8 = v9;
        }
        uint64_t v12 = v10 & 0x7F;
        if (v11 < 0) {
          uint64_t v12 = v9[1];
        }
        unsigned int v18 = v8;
        uint64_t v19 = v12;
        if ((sub_1CC0C5278((const void **)a3, (uint64_t)&v18) & 0x80000000) == 0) {
          break;
        }
        unsigned int v4 = (void *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_17;
        }
      }
      char v13 = *(unsigned char *)(a3 + 23);
      BOOL v14 = v13 < 0;
      uint64_t v15 = *(const void **)a3;
      if (v13 >= 0) {
        uint64_t v15 = (const void *)a3;
      }
      uint64_t v16 = v13 & 0x7F;
      if (v14) {
        uint64_t v16 = *(void *)(a3 + 8);
      }
      unsigned int v18 = v15;
      uint64_t v19 = v16;
      if ((sub_1CC0C5278((const void **)v9, (uint64_t)&v18) & 0x80000000) == 0) {
        break;
      }
      uint64_t v5 = v7 + 1;
      unsigned int v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v7 = (void *)(a1 + 8);
  }
LABEL_17:
  *a2 = v7;
  return v5;
}

uint64_t sub_1CD4AF9B4(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1CD4AF9FC(void *a1)
{
  sub_1CC0C52DC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD4AFA34(void *a1)
{
  *a1 = &unk_1F26061D8;
  unsigned int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_1CD4AFA84(void *a1)
{
  *a1 = &unk_1F26061D8;
  unsigned int v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4AFAF4(uint64_t a1)
{
  return a1;
}

void sub_1CD4AFB70(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD4AFB70(a1, *a2);
    sub_1CD4AFB70(a1, a2[1]);
    sub_1CD4AF9B4((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1CD4AFBCC(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1CD4AFBCC(a1, *(void *)a2);
    sub_1CD4AFBCC(a1, *((void *)a2 + 1));
    sub_1CD4AFC3C((uint64_t)(a2 + 104), *((char **)a2 + 14));
    if (a2[63] < 0) {
      operator delete(*((void **)a2 + 5));
    }
    operator delete(a2);
  }
}

void sub_1CD4AFC3C(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1CD4AFC3C(a1, *(void *)a2);
    sub_1CD4AFC3C(a1, *((void *)a2 + 1));
    sub_1CD4AFCAC((uint64_t)(a2 + 72), *((void **)a2 + 10));
    if (a2[71] < 0) {
      operator delete(*((void **)a2 + 6));
    }
    operator delete(a2);
  }
}

void sub_1CD4AFCAC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD4AFCAC(a1, *a2);
    sub_1CD4AFCAC(a1, a2[1]);
    uint64_t v5 = (void *)a2[4];
    if (v5)
    {
      a2[5] = v5;
      operator delete(v5);
    }
    operator delete(a2);
  }
}

uint64_t sub_1CD4AFD10(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = *(unsigned int *)(a1 + 8);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8 * v2;
      do
      {
        uint64_t v5 = *(void *)(*(void *)a1 + v3);
        if (v5 != -8 && v5 != 0) {
          MEMORY[0x1D25D9CD0]();
        }
        v3 += 8;
      }
      while (v4 != v3);
    }
  }
  free(*(void **)a1);
  return a1;
}

void sub_1CD4AFD84(uint64_t a1, char *a2)
{
  if (a2)
  {
    void v6[3] = v2;
    int v6[4] = v3;
    sub_1CD4AFD84(a1, *(void *)a2);
    sub_1CD4AFD84(a1, *((void *)a2 + 1));
    v6[0] = (void **)(a2 + 56);
    sub_1CC0C3EE0(v6);
    operator delete(a2);
  }
}

void llvm::callDefaultCtor<llvm::ModuleSummaryIndexWrapperPass>()
{
}

void llvm::callDefaultCtor<llvm::ImmutableModuleSummaryIndexWrapperPass>()
{
}

void sub_1CD4AFE64(_WORD *a1, llvm **a2, long long *a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&FSEC, 0, 0);
  byte_1EBD04604 = 0;
  qword_1EBD045F0 = 0;
  unk_1EBD045F8 = &unk_1F2605FD0;
  FSEC = (uint64_t)&unk_1F2605F18;
  qword_1EBD04608 = (uint64_t)&unk_1F2605F80;
  qword_1EBD04610 = (uint64_t)&FSEC;
  qword_1EBD04618 = (uint64_t)&unk_1EBD04628;
  qword_1EBD04620 = 0x800000000;
  qword_1EBD047A8 = (uint64_t)&unk_1F2606050;
  qword_1EBD047C0 = (uint64_t)&qword_1EBD047A8;
  sub_1CD4AFF78(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&FSEC);
}

void sub_1CD4AFF78(_WORD *a1, llvm **a2, long long *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&FSEC, "force-summary-edges-cold", 0x18uLL);
  word_1EBD0457A = (32 * (*a1 & 3)) | word_1EBD0457A & 0xFF9F;
  sub_1CD4B008C(*a2);
  xmmword_1EBD04590 = *a3;
  uint64_t v8 = *(void *)a4;
  unsigned int v9 = *(_DWORD *)(a4 + 8);

  sub_1CD4B0108(v8, v9);
}

void sub_1CD4B0014()
{
}

void *sub_1CD4B0028()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F2606050;
  return result;
}

void sub_1CD4B0060(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2606050;
}

llvm *sub_1CD4B008C(llvm *result)
{
  if (qword_1EBD045F0)
  {
    uint64_t v2 = "cl::location(x) specified more than once!";
    __int16 v3 = 259;
    uint64_t v1 = (llvm::raw_ostream *)llvm::errs(result);
    return (llvm *)llvm::cl::Option::error(&FSEC, (llvm::Twine *)&v2, 0, 0, v1);
  }
  else
  {
    qword_1EBD045F0 = (uint64_t)result;
    byte_1EBD04604 = 1;
    dword_1EBD04600 = *(_DWORD *)result;
  }
  return result;
}

void sub_1CD4B0108(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD4B0154(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD4B0154(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  void v11[2] = a4;
  void v11[3] = a5;
  v11[4] = &unk_1F2605FD0;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD4B0248((unint64_t)v11);
  uint64_t v8 = qword_1EBD04618 + 48 * qword_1EBD04620;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2605FF0;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2605FD0;
  LODWORD(qword_1EBD04620) = qword_1EBD04620 + 1;
  llvm::cl::AddLiteralOption(qword_1EBD04610, a1, a2);
}

unint64_t sub_1CD4B0248(unint64_t result)
{
  if (qword_1EBD04620 >= HIDWORD(qword_1EBD04620))
  {
    if (qword_1EBD04618 > result || qword_1EBD04618 + 48 * (unint64_t)qword_1EBD04620 <= result) {
      sub_1CD4B02C4();
    }
    sub_1CD4B02C4();
  }
  return result;
}

void sub_1CD4B02C4()
{
}

void sub_1CD4B03BC(const char **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&ModuleSummaryDotFile, 0, 0);
  qword_1EBD04848 = 0;
  qword_1EBD04850 = 0;
  qword_1EBD04870 = 0;
  unk_1EBD04878 = 0;
  byte_1EBD04880 = 0;
  qword_1EBD04868 = 0;
  unk_1EBD04858 = 0;
  unk_1EBD04860 = &unk_1F2643C20;
  ModuleSummaryDotFile = (uint64_t)&unk_1F2643FD0;
  qword_1EBD04888 = (uint64_t)&unk_1F2643EA0;
  qword_1EBD04890 = (uint64_t)&unk_1F25F6428;
  qword_1EBD048A8 = (uint64_t)&qword_1EBD04890;
  sub_1CD4B04C8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&ModuleSummaryDotFile);
}

__n128 sub_1CD4B04C8(const char **a1, _WORD *a2, long long *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&ModuleSummaryDotFile, "module-summary-dot-file", 0x17uLL);
  sub_1CBAD7D28(a1, (uint64_t)&ModuleSummaryDotFile);
  word_1EBD047D2 = (32 * (*a2 & 3)) | word_1EBD047D2 & 0xFF9F;
  xmmword_1EBD047F8 = *a3;
  __n128 result = *a4;
  xmmword_1EBD047E8 = (__int128)*a4;
  return result;
}

void *sub_1CD4B0554(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)v6;
      *(void *)(v4 + 24) = 0;
      *(void *)(v4 + 32) = 0;
      *(void *)(v4 + 16) = 0;
      __n128 result = sub_1CBFCBA2C((void *)(v4 + 16), *(const void **)(v6 + 16), *(void *)(v6 + 24), (uint64_t)(*(void *)(v6 + 24) - *(void *)(v6 + 16)) >> 3);
      v4 += 40;
      v6 += 40;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

uint64_t sub_1CD4B05C8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = (void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = v5;
  uint64_t v6 = a1 + 8;
  uint64_t v7 = *(void *)(a2 + 16);
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v5 + 16) = v6;
    *(void *)a2 = v4;
    *uint64_t v4 = 0;
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    *(void *)a1 = v6;
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  uint64_t v8 = (void *)(a2 + 64);
  uint64_t v9 = *(void *)(a2 + 64);
  *(void *)(a1 + 64) = v9;
  uint64_t v10 = a1 + 64;
  uint64_t v11 = *(void *)(a2 + 72);
  *(void *)(a1 + 72) = v11;
  if (v11)
  {
    *(void *)(v9 + 16) = v10;
    *(void *)(a2 + 56) = v8;
    *uint64_t v8 = 0;
    *(void *)(a2 + 72) = 0;
  }
  else
  {
    *(void *)(a1 + 56) = v10;
  }
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  int v12 = (void *)(a2 + 88);
  uint64_t v13 = *(void *)(a2 + 88);
  *(void *)(a1 + 88) = v13;
  uint64_t v14 = a1 + 88;
  uint64_t v15 = *(void *)(a2 + 96);
  *(void *)(a1 + 96) = v15;
  if (v15)
  {
    *(void *)(v13 + 16) = v14;
    *(void *)(a2 + 80) = v12;
    *int v12 = 0;
    *(void *)(a2 + 96) = 0;
  }
  else
  {
    *(void *)(a1 + 80) = v14;
  }
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  uint64_t v16 = (void *)(a2 + 112);
  uint64_t v17 = *(void *)(a2 + 112);
  *(void *)(a1 + 112) = v17;
  uint64_t v18 = a1 + 112;
  uint64_t v19 = *(void *)(a2 + 120);
  *(void *)(a1 + 120) = v19;
  if (v19)
  {
    *(void *)(v17 + 16) = v18;
    *(void *)(a2 + 104) = v16;
    *uint64_t v16 = 0;
    *(void *)(a2 + 120) = 0;
  }
  else
  {
    *(void *)(a1 + 104) = v18;
  }
  uint64_t v20 = *(void *)(a2 + 128);
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 136);
  *(void *)(a1 + 128) = v20;
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  BOOL v21 = (void *)(a2 + 152);
  uint64_t v22 = *(void *)(a2 + 152);
  *(void *)(a1 + 152) = v22;
  uint64_t v23 = a1 + 152;
  uint64_t v24 = *(void *)(a2 + 160);
  *(void *)(a1 + 160) = v24;
  if (v24)
  {
    *(void *)(v22 + 16) = v23;
    *(void *)(a2 + 144) = v21;
    *BOOL v21 = 0;
    *(void *)(a2 + 160) = 0;
  }
  else
  {
    *(void *)(a1 + 144) = v23;
  }
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  uint64_t v25 = (void *)(a2 + 176);
  uint64_t v26 = *(void *)(a2 + 176);
  *(void *)(a1 + 176) = v26;
  uint64_t v27 = a1 + 176;
  uint64_t v28 = *(void *)(a2 + 184);
  *(void *)(a1 + 184) = v28;
  if (v28)
  {
    *(void *)(v26 + 16) = v27;
    *(void *)(a2 + 168) = v25;
    *uint64_t v25 = 0;
    *(void *)(a2 + 184) = 0;
  }
  else
  {
    *(void *)(a1 + 168) = v27;
  }
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  sub_1CC056A04(a1 + 200, a2 + 200);
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  return a1;
}

unint64_t *llvm::LoopSafetyInfo::copyColors(llvm::LoopSafetyInfo *this, llvm::BasicBlock *a2, llvm::BasicBlock *a3)
{
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  uint64_t v3 = (uint64_t *)((char *)this + 8);
  uint64_t v4 = sub_1CD487170((uint64_t *)this + 1, &v8) + 1;
  uint64_t v5 = sub_1CD487170(v3, &v7);
  return sub_1CC0C61CC(v4, v5 + 1);
}

uint64_t llvm::SimpleLoopSafetyInfo::blockMayThrow(llvm::SimpleLoopSafetyInfo *this, const llvm::BasicBlock *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 8))();
}

uint64_t llvm::SimpleLoopSafetyInfo::anyBlockMayThrow(llvm::SimpleLoopSafetyInfo *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t *llvm::SimpleLoopSafetyInfo::computeLoopSafetyInfo(llvm::SimpleLoopSafetyInfo *this, llvm ***a2)
{
  char v5 = llvm::isGuaranteedToTransferExecutionToSuccessor(*a2[4], (const llvm::BasicBlock *)a2) ^ 1;
  *((unsigned char *)this + 33) = v5;
  *((unsigned char *)this + 32) = v5;
  uint64_t v6 = a2[4];
  uint64_t v7 = (char *)a2[5] - (char *)v6;
  if (v7 != 8)
  {
    uint64_t v9 = v6 + 1;
    uint64_t v10 = 8 * (v7 >> 3) - 8;
    do
    {
      if (v5) {
        break;
      }
      uint64_t v11 = *v9++;
      char v5 = *((unsigned char *)this + 32) | llvm::isGuaranteedToTransferExecutionToSuccessor(v11, v4) ^ 1;
      *((unsigned char *)this + 32) = v5;
      v10 -= 8;
    }
    while (v10);
  }

  return llvm::LoopSafetyInfo::computeBlockColors((uint64_t *)this, (const llvm::Loop *)a2);
}

uint64_t *sub_1CD4B08AC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)a1 + 4);
  uint64_t v5 = *a1;
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    uint64_t v7 = (uint64_t *)(v5 + 8);
    do
    {
      if ((*(v7 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v7 = sub_1CD487110(v7);
      }
      v7 += 2;
      v6 -= 16;
    }
    while (v6);
    uint64_t v5 = *a1;
  }
  MEMORY[0x1D25D9CD0](v5, 8);
  *a1 = 0;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  *a1 = *a2;
  *a2 = 0;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = 0;
  int v8 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v8;
  int v9 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = v9;
  return a1;
}

uint64_t llvm::SimpleLoopSafetyInfo::isGuaranteedToExecute(llvm::SimpleLoopSafetyInfo *this, const llvm::Instruction *a2, const llvm::DominatorTree *a3, const llvm::BasicBlock ***a4)
{
  uint64_t v5 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (v5 == *a4[4])
  {
    return !*((unsigned char *)this + 33)
        || llvm::BasicBlock::getFirstNonPHIOrDbg(*((llvm::BasicBlock **)a2 + 5), 1) == (char *)a2;
  }
  else
  {
    return llvm::LoopSafetyInfo::allLoopPathsLeadToBlock(this, a4, v5, a3);
  }
}

BOOL llvm::ICFLoopSafetyInfo::doesNotWriteMemoryBefore(int32x2_t *this, const llvm::BasicBlock *a2, const llvm::BasicBlock ***a3)
{
  if (*a3[4] == a2) {
    return 1;
  }
  uint64_t v14 = v18;
  uint64_t v15 = v18;
  uint64_t v16 = 4;
  int v17 = 0;
  sub_1CC0C7110((uint64_t)a3, (uint64_t)a2, (llvm::SmallPtrSetImplBase *)&v14);
  uint64_t v5 = v14;
  uint64_t v4 = v15;
  if (v15 == v14) {
    uint64_t v6 = (uint64_t *)((char *)&v16 + 4);
  }
  else {
    uint64_t v6 = &v16;
  }
  uint64_t v7 = *(unsigned int *)v6;
  int v8 = (const llvm::BasicBlock **)v15;
  if (v7)
  {
    uint64_t v9 = 0;
    while (*(void *)&v15[v9] >= 0xFFFFFFFFFFFFFFFELL)
    {
      v9 += 8;
      if (8 * v7 == v9) {
        goto LABEL_9;
      }
    }
    int v8 = (const llvm::BasicBlock **)&v15[v9];
  }
  int v12 = (const llvm::BasicBlock **)&v15[8 * v7];
  if (v8 == v12)
  {
LABEL_9:
    BOOL v10 = 1;
  }
  else
  {
    uint64_t v13 = this + 9;
    if (llvm::InstructionPrecedenceTracking::getFirstSpecialInstruction(this + 9, *v8))
    {
      BOOL v10 = 0;
    }
    else
    {
      do
        BOOL v10 = ++v8 == v12;
      while (v8 != v12
           && ((unint64_t)*v8 >= 0xFFFFFFFFFFFFFFFELL
            || !llvm::InstructionPrecedenceTracking::getFirstSpecialInstruction(v13, *v8)));
    }
    uint64_t v5 = v14;
    uint64_t v4 = v15;
  }
  if (v4 != v5) {
    free(v4);
  }
  return v10;
}

BOOL llvm::ICFLoopSafetyInfo::doesNotWriteMemoryBefore(int32x2_t *this, const llvm::Instruction *a2, const llvm::BasicBlock ***a3)
{
  uint64_t v5 = (const llvm::BasicBlock *)*((void *)a2 + 5);
  if (llvm::InstructionPrecedenceTracking::isPreceededBySpecialInstruction(this + 9, (const llvm::BasicBlock **)a2)) {
    return 0;
  }

  return llvm::ICFLoopSafetyInfo::doesNotWriteMemoryBefore(this, v5, a3);
}

void llvm::createMustExecutePrinter(llvm *this)
{
}

void llvm::createMustBeExecutedContextPrinter(llvm *this)
{
}

llvm::BasicBlock *llvm::MustBeExecutedContextExplorer::getMustBeExecutedNextInstruction(llvm::MustBeExecutedContextExplorer *this, llvm::MustBeExecutedIterator *a2, const llvm::BasicBlock **a3)
{
  if (!a3) {
    return 0;
  }
  if (!*(unsigned char *)this && *((unsigned __int8 *)a3 + 16) - 29 < 0xB
    || !llvm::isGuaranteedToTransferExecutionToSuccessor((llvm *)a3, a2))
  {
    return 0;
  }
  if (*((unsigned __int8 *)a3 + 16) - 29 >= 0xB)
  {
    int v8 = a3[4];
    if (v8) {
      BOOL v9 = v8 == (const llvm::BasicBlock *)((char *)a3[5] + 40);
    }
    else {
      BOOL v9 = 1;
    }
    if (v9) {
      return 0;
    }
    else {
      return (const llvm::BasicBlock *)((char *)v8 - 24);
    }
  }
  int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)a3);
  if (!NumSuccessors) {
    return 0;
  }
  if (NumSuccessors == 1)
  {
    __n128 result = (llvm::BasicBlock *)llvm::Instruction::getSuccessor((llvm::Instruction *)a3, 0);
  }
  else
  {
    __n128 result = llvm::MustBeExecutedContextExplorer::findForwardJoinPoint(this, a3[5]);
    if (!result) {
      return result;
    }
  }
  uint64_t v7 = *((void *)result + 6);
  if (v7) {
    return (llvm::BasicBlock *)(v7 - 24);
  }
  else {
    return 0;
  }
}

uint64_t llvm::MustBeExecutedIterator::resetInstruction(llvm::MustBeExecutedIterator *this, unint64_t a2)
{
  *((void *)this + 4) = a2;
  *((void *)this + 5) = 0;
  uint64_t v4 = (unint64_t *)((char *)this + 40);
  *((void *)this + 6) = 0;
  unint64_t v5 = a2 & 0xFFFFFFFFFFFFFFFBLL;
  unint64_t v8 = a2 | 4;
  sub_1CD4B3184((uint64_t)this, &v8, (uint64_t)v9);
  unint64_t v8 = v5;
  uint64_t result = sub_1CD4B3184((uint64_t)this, &v8, (uint64_t)v9);
  uint64_t v7 = *((void *)this + 3);
  if (*(unsigned char *)(v7 + 1)) {
    *uint64_t v4 = a2;
  }
  if (*(unsigned char *)(v7 + 2)) {
    *((void *)this + 6) = a2;
  }
  return result;
}

uint64_t llvm::MustBeExecutedIterator::advance(llvm::MustBeExecutedIterator *this, llvm::MustBeExecutedIterator *a2)
{
  MustBeExecutedNextInstruction = llvm::MustBeExecutedContextExplorer::getMustBeExecutedNextInstruction(*((llvm::MustBeExecutedContextExplorer **)this + 3), a2, *((const llvm::BasicBlock ***)this + 5));
  *((void *)this + 5) = MustBeExecutedNextInstruction;
  if (MustBeExecutedNextInstruction)
  {
    unint64_t v7 = (unint64_t)MustBeExecutedNextInstruction | 4;
    sub_1CD4B3184((uint64_t)this, &v7, (uint64_t)v8);
    if (v9) {
      return *((void *)this + 5);
    }
  }
  *((void *)this + 5) = 0;
  MustBeExecutedPrevInstruction = llvm::MustBeExecutedContextExplorer::getMustBeExecutedPrevInstruction(*((llvm::MustBeExecutedContextExplorer **)this + 3), v4, *((void *)this + 6));
  *((void *)this + 6) = MustBeExecutedPrevInstruction;
  if (MustBeExecutedPrevInstruction)
  {
    unint64_t v7 = (unint64_t)MustBeExecutedPrevInstruction & 0xFFFFFFFFFFFFFFFBLL;
    sub_1CD4B3184((uint64_t)this, &v7, (uint64_t)v8);
    if (v9) {
      return *((void *)this + 6);
    }
  }
  uint64_t result = 0;
  *((void *)this + 6) = 0;
  return result;
}

void llvm::MustExecutePrinterPass::run()
{
}

void llvm::MustBeExecutedContextPrinterPass::run()
{
}

uint64_t sub_1CD4B1600(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1CD4B25C4(a2, a3);
  v12[0] = 0;
  v12[1] = 0;
  int v13 = 0;
  sub_1CBFCB9AC((uint64_t)v12, v5);
  long long v6 = *(_OWORD *)(v5 + 40);
  long long v14 = *(_OWORD *)(v5 + 24);
  long long v15 = v6;
  v8[0] = 0;
  v8[1] = 0;
  int v9 = 0;
  sub_1CBFCB9AC((uint64_t)v8, a2 + 176);
  long long v10 = *(_OWORD *)(a2 + 200);
  long long v11 = *(_OWORD *)(a2 + 216);
  sub_1CD4B2524(a1, v12, v8);
  MEMORY[0x1D25D9CD0](v8[0], 8);
  return MEMORY[0x1D25D9CD0](v12[0], 8);
}

void *sub_1CD4B16B0(void *a1)
{
  *a1 = &unk_1F26065B0;
  sub_1CC0CADD4(a1 + 1);
  return a1;
}

void sub_1CD4B16F4(void *a1)
{
  *a1 = &unk_1F26065B0;
  sub_1CC0CADD4(a1 + 1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4B175C(void *a1)
{
  sub_1CC0CAB50(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4B1794(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  unint64_t v3 = *(void *)result;
  if (v2 >= *(_DWORD *)(result + 12))
  {
    unint64_t v6 = v3 + 8 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD4B18A4();
    }
    sub_1CD4B18A4();
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(v3 + 8 * v4) = v5;
  *(_DWORD *)(result + 8) = v4 + 1;
  return result;
}

uint64_t sub_1CD4B181C(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  unint64_t v3 = *(void *)result;
  if (v2 >= *(_DWORD *)(result + 12))
  {
    unint64_t v6 = v3 + 8 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD4B197C();
    }
    sub_1CD4B197C();
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(v3 + 8 * v4) = v5;
  *(_DWORD *)(result + 8) = v4 + 1;
  return result;
}

void sub_1CD4B18A4()
{
}

void sub_1CD4B1914(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = *(uint64_t **)a1;
    uint64_t v4 = 8 * v2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    uint64_t v7 = *(void *)a1 - 8;
    do
    {
      uint64_t v8 = *(void *)(v7 + v4);
      *(void *)(v7 + v4) = 0;
      if (v8) {
        sub_1CBF8FF20(v7 + v4, v8);
      }
      v4 -= 8;
    }
    while (v4);
  }
}

void sub_1CD4B197C()
{
}

uint64_t sub_1CD4B19EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    unint64_t v3 = *(uint64_t **)result;
    uint64_t v4 = 8 * v2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    uint64_t v7 = *(void *)result - 8;
    do
    {
      uint64_t result = *(void *)(v7 + v4);
      *(void *)(v7 + v4) = 0;
      if (result) {
        llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase();
      }
      v4 -= 8;
    }
    while (v4);
  }
  return result;
}

uint64_t sub_1CD4B1A64(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  unint64_t v3 = *(void *)result;
  if (v2 >= *(_DWORD *)(result + 12))
  {
    unint64_t v6 = v3 + 8 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD4B1AEC();
    }
    sub_1CD4B1AEC();
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(v3 + 8 * v4) = v5;
  *(_DWORD *)(result + 8) = v4 + 1;
  return result;
}

void sub_1CD4B1AEC()
{
}

void sub_1CD4B1B5C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = *(uint64_t **)a1;
    uint64_t v4 = 8 * v2;
    uint64_t v5 = 8 * v2;
    do
    {
      uint64_t v6 = *v3;
      *v3++ = 0;
      *a2++ = v6;
      v5 -= 8;
    }
    while (v5);
    uint64_t v7 = *(void *)a1 - 8;
    do
    {
      uint64_t v8 = *(void *)(v7 + v4);
      *(void *)(v7 + v4) = 0;
      if (v8) {
        sub_1CBF8FFEC(v7 + v4, v8);
      }
      v4 -= 8;
    }
    while (v4);
  }
}

uint64_t sub_1CD4B1BC4(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1CD4B1C28(char *__p)
{
  uint64_t v2 = __p + 8;
  unint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  operator delete(__p);
}

uint64_t sub_1CD4B1CC0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return v2();
  }
  else
  {
    sub_1CB920400();
    return sub_1CD4B1D10(v4);
  }
}

uint64_t sub_1CD4B1D10(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1CD4B1D74(char *__p)
{
  uint64_t v2 = __p + 8;
  unint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  operator delete(__p);
}

uint64_t sub_1CD4B1E0C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return v2();
  }
  else
  {
    sub_1CB920400();
    return sub_1CD4B1E5C(v4);
  }
}

uint64_t sub_1CD4B1E5C(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void sub_1CD4B1EC0(char *__p)
{
  uint64_t v2 = __p + 8;
  unint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }

  operator delete(__p);
}

char **sub_1CD4B1F58(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);
    return (char **)v2();
  }
  else
  {
    sub_1CB920400();
    return sub_1CD4B1FA8(v4);
  }
}

char **sub_1CD4B1FA8(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void *)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        llvm::LoopInfoBase<llvm::BasicBlock,llvm::Loop>::~LoopInfoBase();
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD4B2028(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void *)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        sub_1CBF8FF20((uint64_t)&v5[v4], v6);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD4B2098(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(void *)&v5[v4];
      *(void *)&v5[v4] = 0;
      if (v6) {
        sub_1CBF8FFEC((uint64_t)&v5[v4], v6);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void *sub_1CD4B2114(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4B2190(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
  }
  return v5;
}

void *sub_1CD4B2190(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B2244(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4B2244(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4B231C(a1, v4, v4 + 56 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4B231C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int v13 = 0;
        sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *int v13 = *(void *)v4;
        uint64_t v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD41C56C(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        int v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

double sub_1CD4B2418(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = 0;
  if (sub_1CD4A7E9C(a2, a3, a4, &v7))
  {
    uint64_t v5 = v7;
    *a1 = a1 + 2;
    *(void *)&double result = 0x400000000;
    a1[1] = 0x400000000;
    if (*(_DWORD *)(v5 + 16))
    {
      llvm::DirectedGraph<llvm::DDGNode,llvm::DDGEdge>::operator=((uint64_t)a1, v5 + 8);
    }
  }
  else
  {
    *a1 = a1 + 2;
    *(void *)&double result = 0x400000000;
    a1[1] = 0x400000000;
  }
  return result;
}

void sub_1CD4B24BC(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 56 * v1;
    uint64_t v3 = *(void *)a1 + 24;
    do
    {
      if ((*(void *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4) {
          free(v4);
        }
      }
      v3 += 56;
      v2 -= 56;
    }
    while (v2);
  }
}

void sub_1CD4B2524(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  int v4 = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = 0;
  uint64_t v5 = *a3;
  *(void *)a1 = v3;
  uint64_t v6 = a2[1];
  a2[1] = 0;
  LODWORD(v3) = *((_DWORD *)a3 + 4);
  *((_DWORD *)a3 + 4) = 0;
  *(void *)(a1 + 8) = v6;
  *(_DWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 3);
  long long v7 = *(_OWORD *)(a2 + 5);
  *a3 = 0;
  *(_OWORD *)(a1 + 40) = v7;
  *(void *)(a1 + 56) = v5;
  *(void *)&long long v7 = a3[1];
  a3[1] = 0;
  *(void *)(a1 + 64) = v7;
  *(_DWORD *)(a1 + 72) = v3;
  long long v8 = *(_OWORD *)(a3 + 5);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a3 + 3);
  *(_OWORD *)(a1 + 96) = v8;
  MEMORY[0x1D25D9CD0](0, 8);

  JUMPOUT(0x1D25D9CD0);
}

uint64_t sub_1CD4B25C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = sub_1CD4B266C((uint64_t *)(a1 + 152), &v4)[1];
  if (!v2) {
    operator new();
  }
  return v2;
}

void *sub_1CD4B266C(uint64_t *a1, void *a2)
{
  long long v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4B26D0((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4B26D0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B2780(a1, v7);
  uint64_t v9 = 0;
  sub_1CD3C8538((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD4B2780(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4B284C(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *double result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4B284C(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v5 = *(unsigned int *)(a1 + 16);
  if (v5)
  {
    unint64_t v6 = *(void **)a1;
    uint64_t v7 = 16 * v5;
    do
    {
      *unint64_t v6 = -4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    unsigned int v8 = a2 + 1;
    do
    {
      if ((*(v8 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int v13 = 0;
        sub_1CD3C8538((uint64_t *)a1, v8 - 1, &v13);
        uint64_t v10 = v13;
        *int v13 = *(v8 - 1);
        uint64_t v11 = (void *)*v8;
        *unsigned int v8 = 0;
        v10[1] = v11;
        ++*(_DWORD *)(a1 + 8);
        int v12 = (void *)*v8;
        *unsigned int v8 = 0;
        if (v12) {
          sub_1CC0CAAF8((uint64_t)v8, v12);
        }
      }
      uint64_t v9 = v8 + 1;
      v8 += 2;
    }
    while (v9 != a3);
  }
}

void *sub_1CD4B2924(void *a1)
{
  return a1;
}

uint64_t sub_1CD4B2960(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 176), 8);
  sub_1CD4B2AE8((unsigned int *)(a1 + 152));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 152), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 128), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 104), 8);
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2 == a1 + 72)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 72) + 32))(a1 + 72);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3 == a1 + 40)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 32))(a1 + 40);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  return a1;
}

void sub_1CD4B2AE8(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 16 * v1;
    uint64_t v3 = (void *)(*(void *)a1 + 8);
    do
    {
      if ((*(v3 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = (void *)*v3;
        *uint64_t v3 = 0;
        if (v4) {
          sub_1CC0CAAF8((uint64_t)v3, v4);
        }
      }
      v3 += 2;
      v2 -= 16;
    }
    while (v2);
  }
}

void *sub_1CD4B2B50(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4B2BC0(a1, a2, v7);
    *uint64_t v5 = *a2;
    *((_WORD *)v5 + 4) = 0;
  }
  return v5;
}

void *sub_1CD4B2BC0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B2C74(a1, v6);
  unsigned int v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4B2C74(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4B2D40(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *double result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4B2D40(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      double result = sub_1CD40EA84(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((_WORD *)v10 + 4) = *(_WORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

uint64_t *sub_1CD4B2DF8(uint64_t *result, uint64_t a2, llvm::Instruction *this, unsigned int a4, uint64_t a5, int a6)
{
  unsigned int v7 = a4;
  uint64_t v9 = *result;
  uint64_t v10 = *((unsigned int *)result + 2);
  if (*result + 8 * v10 == a2)
  {
    return (uint64_t *)sub_1CD4B2F9C((uint64_t)result, this, a4, a5, a6);
  }
  else
  {
    uint64_t v11 = (a2 - v9) >> 3;
    unsigned int v12 = a6 - a4;
    unint64_t v13 = (int)(a6 - a4);
    if (v10 + v13 > *((unsigned int *)result + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    long long v14 = (char *)(v9 + 8 * v11);
    long long v15 = (char *)(v9 + 8 * v10);
    unint64_t v16 = (v15 - v14) >> 3;
    if (v16 >= v13)
    {
      double result = (uint64_t *)sub_1CD4570C8((uint64_t)result, &v15[-8 * v13], (char *)(v9 + 8 * v10));
      if (&v15[-8 * v13] != v14) {
        double result = (uint64_t *)memmove(&v14[8 * v13], v14, &v15[-8 * v13] - v14);
      }
      if (v7 != a6)
      {
        unsigned int v17 = v7;
        do
        {
          double result = (uint64_t *)llvm::Instruction::getSuccessor(this, v17);
          *(void *)long long v14 = result;
          v14 += 8;
          unsigned int v17 = ++v7;
        }
        while (v7 != a6);
      }
    }
    else
    {
      *((_DWORD *)result + 2) = v10 + v12;
      if (v11 != v10)
      {
        memcpy((void *)(v9 + 8 * (v10 + v12) - 8 * v16), v14, v15 - v14);
        do
        {
          double result = (uint64_t *)llvm::Instruction::getSuccessor(this, v7);
          *(void *)long long v14 = result;
          v14 += 8;
          ++v7;
          --v16;
        }
        while (v16);
      }
      for (; a6 != v7; ++v7)
      {
        double result = (uint64_t *)llvm::Instruction::getSuccessor(this, v7);
        *(void *)long long v15 = result;
        v15 += 8;
      }
    }
  }
  return result;
}

uint64_t sub_1CD4B2F9C(uint64_t result, llvm::Instruction *this, unsigned int a3, uint64_t a4, int a5)
{
  unsigned int v6 = a3;
  uint64_t v8 = result;
  int v9 = a5 - a3;
  uint64_t v10 = *(unsigned int *)(result + 8);
  if (v10 + (int)(a5 - a3) > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a3 != a5)
  {
    uint64_t v11 = (void *)(*(void *)result + 8 * v10);
    unsigned int v12 = a3;
    do
    {
      double result = llvm::Instruction::getSuccessor(this, v12);
      *v11++ = result;
      unsigned int v12 = ++v6;
    }
    while (v6 != a5);
  }
  *(_DWORD *)(v8 + 8) = v10 + v9;
  return result;
}

void sub_1CD4B3040(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 || *(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 16);
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1CD4B30C4(a1);
    }
    else
    {
      if (v3) {
        memset_pattern16(*(void **)a1, &unk_1CFAC4340, 8 * v3);
      }
      *(void *)(a1 + 8) = 0;
    }
  }
}

void sub_1CD4B30C4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 8);
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *(void *)(a1 + 8) = 0;
    if (v2)
    {
      unsigned int v6 = *(void **)a1;
      memset_pattern16(v6, &unk_1CFAC4340, 8 * v2);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC0CA620(a1, v5);
  }
}

uint64_t sub_1CD4B3184@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD4B3214(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v10);
  unsigned int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4B32A8(a1, a2, v10);
    unsigned int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD4B3214(uint64_t a1, int a2, unint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (a2 - 1) & ((a3 >> 9) ^ a3);
    unsigned int v6 = (void *)(a1 + 8 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -16;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unsigned int v6 = (void *)(a1 + 8 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unsigned int v6 = v10;
      }
    }
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD4B32A8(uint64_t a1, unint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B335C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4B3214(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CD4B335C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(unint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t v9 = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = v9;
  if (v4)
  {
    sub_1CD4B3440(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    memset_pattern16(v9, &unk_1CFAC4340, 8 * v10);
  }
}

void sub_1CD4B3440(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6) {
    memset_pattern16(*(void **)a1, &unk_1CFAC4340, 8 * v6);
  }
  while (a2 != a3)
  {
    unint64_t v7 = *a2;
    if (*a2 != -16 && v7 != -4)
    {
      uint64_t v9 = 0;
      sub_1CD4B3214(*(void *)a1, *(_DWORD *)(a1 + 16), v7, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(a1 + 8);
    }
    ++a2;
  }
}

uint64_t llvm::objcarc::ObjCARCAAResult::alias(uint64_t a1, llvm::Value **a2, llvm::Value **a3)
{
  if (llvm::objcarc::EnableARCOpts)
  {
    unint64_t v5 = sub_1CD4B3548(*a2);
    uint64_t v6 = sub_1CD4B3548(*a3);
    sub_1CD4B35A0(v5);
    sub_1CD4B35A0(v6);
  }
  return 1;
}

llvm::Value *sub_1CD4B3548(llvm::Value *a1)
{
  uint64_t v1 = llvm::Value::stripPointerCasts(a1);
  char v3 = sub_1CD4B36C8((uint64_t)v1, v2);
  if (llvm::objcarc::IsForwarding(v3))
  {
    do
    {
      uint64_t v1 = llvm::Value::stripPointerCasts(*((llvm::Value **)v1 - 4 * (*((_DWORD *)v1 + 5) & 0x7FFFFFF)));
      char v5 = sub_1CD4B36C8((uint64_t)v1, v4);
    }
    while ((llvm::objcarc::IsForwarding(v5) & 1) != 0);
  }
  return v1;
}

llvm *sub_1CD4B35A0(llvm *a1)
{
  UnderlyingObject = llvm::getUnderlyingObject(a1, (const llvm::Value *)6);
  char v3 = sub_1CD4B36C8((uint64_t)UnderlyingObject, v2);
  if (llvm::objcarc::IsForwarding(v3))
  {
    do
    {
      UnderlyingObject = llvm::getUnderlyingObject(*((llvm **)UnderlyingObject - 4 * (*((_DWORD *)UnderlyingObject + 5) & 0x7FFFFFF)), (const llvm::Value *)6);
      char v5 = sub_1CD4B36C8((uint64_t)UnderlyingObject, v4);
    }
    while ((llvm::objcarc::IsForwarding(v5) & 1) != 0);
  }
  return UnderlyingObject;
}

uint64_t llvm::objcarc::ObjCARCAAResult::pointsToConstantMemory(uint64_t a1, llvm::Value **a2)
{
  if (llvm::objcarc::EnableARCOpts)
  {
    char v3 = sub_1CD4B3548(*a2);
    sub_1CD4B35A0(v3);
  }
  return 0;
}

uint64_t llvm::objcarc::ObjCARCAAResult::getModRefBehavior(llvm::objcarc::ObjCARCAAResult *this, const llvm::Function *a2)
{
  uint64_t v2 = 63;
  if (llvm::objcarc::EnableARCOpts)
  {
    if (llvm::objcarc::GetFunctionClass(a2, a2) == 9) {
      return 4;
    }
    else {
      return 63;
    }
  }
  return v2;
}

uint64_t llvm::objcarc::ObjCARCAAResult::getModRefInfo(uint64_t a1, const llvm::Function *a2)
{
  if (llvm::objcarc::EnableARCOpts && (unsigned int v3 = sub_1CD4B36C8((uint64_t)a2, a2), v3 <= 0xB)) {
    return byte_1CFAC4350[v3];
  }
  else {
    return 7;
  }
}

uint64_t sub_1CD4B36C8(uint64_t a1, const llvm::Function *a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v2 == 84)
  {
    uint64_t v3 = *(void *)(a1 - 32);
    if (v3 && !*(unsigned char *)(v3 + 16) && *(void *)(v3 + 24) == *(void *)(a1 + 72)) {
      return llvm::objcarc::GetFunctionClass(*(llvm::objcarc **)(a1 - 32), a2);
    }
    else {
      return 21;
    }
  }
  else if (v2 == 33)
  {
    return 21;
  }
  else
  {
    return 23;
  }
}

uint64_t llvm::objcarc::ObjCARCAA::run@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t result = llvm::Module::getDataLayout(*(llvm::Module **)(a1 + 40));
  *a2 = 0;
  a2[1] = result;
  return result;
}

void llvm::initializeObjCARCAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6C78, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0CB06C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6C78, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createObjCARCAAWrapperPass(llvm *this)
{
}

llvm::objcarc::ObjCARCAAWrapperPass *llvm::objcarc::ObjCARCAAWrapperPass::ObjCARCAAWrapperPass(llvm::objcarc::ObjCARCAAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::objcarc::ObjCARCAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F26066C8;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6C78, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0CB06C;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCC6C78, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::objcarc::ObjCARCAAWrapperPass::doInitialization(llvm::objcarc::ObjCARCAAWrapperPass *this, llvm::Module *a2)
{
}

uint64_t llvm::objcarc::ObjCARCAAWrapperPass::doFinalization(llvm::objcarc::ObjCARCAAWrapperPass *this, llvm::Module *a2)
{
  uint64_t v3 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3) {
    MEMORY[0x1D25D9CE0](v3, 0x60C40FAFB2B2FLL);
  }
  return 0;
}

void llvm::objcarc::ObjCARCAAWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::callDefaultCtor<llvm::objcarc::ObjCARCAAWrapperPass>()
{
}

BOOL llvm::objcarc::IsPotentialRetainableObjPtr(llvm::objcarc *this, const llvm::Value *a2, llvm::AAResults *a3)
{
  BOOL result = sub_1CC0CB204(this);
  if (result)
  {
    unsigned int v8 = this;
    uint64_t v9 = -1;
    long long v10 = 0u;
    long long v11 = 0u;
    char v6 = llvm::AAResults::pointsToConstantMemory((uint64_t)a2, (uint64_t)&v8, 0);
    BOOL result = 0;
    if ((v6 & 1) == 0)
    {
      if (!this) {
        return 1;
      }
      if (*((unsigned char *)this + 16) != 60) {
        return 1;
      }
      unsigned int v8 = (llvm::objcarc *)*((void *)this - 4);
      uint64_t v9 = -1;
      long long v10 = 0u;
      long long v11 = 0u;
      char v7 = llvm::AAResults::pointsToConstantMemory((uint64_t)a2, (uint64_t)&v8, 0);
      BOOL result = 0;
      if ((v7 & 1) == 0) {
        return 1;
      }
    }
  }
  return result;
}

void sub_1CD4B3A50(long long *a1, unsigned char **a2, char **a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6C80, 0, 0);
  byte_1EBCC6D11 = 0;
  qword_1EBCC6D00 = 0;
  unk_1EBCC6D08 = &unk_1F25EDE58;
  qword_1EBCC6C80 = (uint64_t)&unk_1F2605290;
  qword_1EBCC6D18 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC6D20 = (uint64_t)&unk_1F26052F8;
  qword_1EBCC6D38 = (uint64_t)&qword_1EBCC6D20;
  sub_1CD4B3B50(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6C80);
}

uint64_t sub_1CD4B3B50(long long *a1, unsigned char **a2, char **a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6C80, "enable-objc-arc-opts", 0x14uLL);
  xmmword_1EBCC6CA0 = *a1;
  uint64_t result = sub_1CC08D588((llvm *)&qword_1EBCC6D00, &qword_1EBCC6C80, *a2);
  uint64_t v9 = *a3;
  *(unsigned char *)qword_1EBCC6D00 = **a3;
  byte_1EBCC6D11 = 1;
  byte_1EBCC6D10 = *v9;
  word_1EBCC6C8A = (32 * (*a4 & 3)) | word_1EBCC6C8A & 0xFF9F;
  return result;
}

uint64_t llvm::objcarc::GetFunctionClass(llvm::objcarc *this, const llvm::Function *a2)
{
  int v2 = *((_DWORD *)this + 9) - 204;
  if (v2 > 0x1F) {
    return 21;
  }
  else {
    return dword_1CFAC435C[v2];
  }
}

uint64_t llvm::objcarc::GetARCInstKind(llvm::objcarc *this, const llvm::Value *a2)
{
  if (!this || *((unsigned __int8 *)this + 16) < 0x1Cu) {
    return 24;
  }
  switch(*((unsigned char *)this + 16))
  {
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x29:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3E:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x4C:
    case 0x4D:
    case 0x52:
    case 0x53:
    case 0x55:
    case 0x58:
    case 0x59:
    case 0x5A:
    case 0x5B:
    case 0x5C:
      return 24;
    case 0x21:
      goto LABEL_29;
    case 0x51:
      int v6 = *((_DWORD *)this + 5);
      if ((v6 & 0x40000000) != 0) {
        char v7 = (llvm::Argument **)*((void *)this - 1);
      }
      else {
        char v7 = (llvm::Argument **)((char *)this - 32 * (v6 & 0x7FFFFFF));
      }
      if (!sub_1CC0CB204(v7[4])) {
        return 24;
      }
      return 23;
    case 0x54:
      uint64_t v9 = *((void *)this - 4);
      if (!v9 || *(unsigned char *)(v9 + 16) || *(void *)(v9 + 24) != *((void *)this + 9)) {
        goto LABEL_29;
      }
      unsigned int v13 = this;
      uint64_t v10 = *((void *)this - 4);
      uint64_t result = llvm::objcarc::GetFunctionClass((llvm::objcarc *)v9, a2);
      if (result != 21) {
        return result;
      }
      int v11 = *(_DWORD *)(v10 + 36);
      if (sub_1CC0CBA30(v11)) {
        return 24;
      }
      BOOL v12 = (v11 - 194) > 5 || ((1 << (v11 + 62)) & 0x29) == 0;
      this = v13;
      if (!v12) {
        return 23;
      }
LABEL_29:
      return sub_1CD4B3D7C((uint64_t)this);
    default:
      int v3 = *((_DWORD *)this + 5);
      if ((v3 & 0x40000000) != 0)
      {
        char v5 = (llvm::Argument **)*((void *)this - 1);
        uint64_t v4 = v3 & 0x7FFFFFF;
      }
      else
      {
        uint64_t v4 = v3 & 0x7FFFFFF;
        char v5 = (llvm::Argument **)((char *)this - 32 * v4);
      }
      if (!v4) {
        return 24;
      }
      uint64_t v8 = 32 * v4;
      break;
  }
  while (!sub_1CC0CB204(*v5))
  {
    v5 += 4;
    v8 -= 32;
    if (!v8) {
      return 24;
    }
  }
  return 23;
}

uint64_t sub_1CD4B3D7C(uint64_t a1)
{
  int v2 = (llvm::Argument **)(a1 - 32 * (*(_DWORD *)(a1 + 20) & 0x7FFFFFF));
  uint64_t v3 = sub_1CBF5BBBC(a1);
  if (v2 == (llvm::Argument **)v3)
  {
LABEL_5:
    BOOL v5 = sub_1CBF99AB0(a1, 45) == 0;
    unsigned int v6 = 22;
    unsigned int v7 = 24;
  }
  else
  {
    uint64_t v4 = (llvm::Argument **)v3;
    while (!sub_1CC0CB204(*v2))
    {
      v2 += 4;
      if (v2 == v4) {
        goto LABEL_5;
      }
    }
    BOOL v5 = sub_1CBF99AB0(a1, 45) == 0;
    unsigned int v6 = 21;
    unsigned int v7 = 23;
  }
  if (v5) {
    return v6;
  }
  else {
    return v7;
  }
}

BOOL llvm::objcarc::IsRetain(unsigned int a1)
{
  return a1 < 2;
}

BOOL llvm::objcarc::IsAutorelease(int a1)
{
  return (a1 - 5) < 2;
}

uint64_t llvm::objcarc::IsForwarding(char a1)
{
  return (0x267u >> a1) & 1;
}

BOOL llvm::objcarc::IsNoopOnNull(unsigned int a1)
{
  return a1 < 7;
}

uint64_t llvm::objcarc::IsNoopOnGlobal(char a1)
{
  return (0xC7Fu >> a1) & 1;
}

uint64_t llvm::objcarc::IsAlwaysTail(char a1)
{
  return (0x47u >> a1) & 1;
}

BOOL llvm::objcarc::IsNeverTail(int a1)
{
  return a1 == 5;
}

uint64_t llvm::objcarc::IsNoThrow(char a1)
{
  return (0x1F7u >> a1) & 1;
}

uint64_t llvm::objcarc::CanInterruptRV(char a1)
{
  return (0x600D60u >> a1) & 1;
}

uint64_t llvm::objcarc::CanDecrementRefCount(char a1)
{
  return (0x6FF19Cu >> a1) & 1;
}

unint64_t llvm::OptimizationRemarkEmitter::emit(uint64_t ***this, llvm::DiagnosticInfoOptimizationBase *a2)
{
  uint64_t v4 = (const llvm::BasicBlock *)*((void *)a2 + 45);
  if (v4)
  {
    BlockProfileCount = (llvm::BlockFrequencyInfoImplBase **)this[1];
    if (BlockProfileCount) {
      BlockProfileCount = (llvm::BlockFrequencyInfoImplBase **)llvm::BlockFrequencyInfo::getBlockProfileCount(BlockProfileCount, v4, 0);
    }
    else {
      uint64_t v6 = 0;
    }
    *((void *)a2 + 8) = BlockProfileCount;
    *((void *)a2 + 9) = v6;
  }
  else
  {
    BlockProfileCount = (llvm::BlockFrequencyInfoImplBase **)*((void *)a2 + 8);
    LOBYTE(v6) = *((unsigned char *)a2 + 72);
  }
  if ((_BYTE)v6) {
    unint64_t v7 = (unint64_t)BlockProfileCount;
  }
  else {
    unint64_t v7 = 0;
  }
  unint64_t result = llvm::LLVMContext::getDiagnosticsHotnessThreshold((llvm::LLVMContext *)***this);
  if (v7 >= result)
  {
    uint64_t v9 = ***this;
    return llvm::LLVMContext::diagnose(v9, a2);
  }
  return result;
}

llvm::OptimizationRemarkEmitterWrapperPass *llvm::OptimizationRemarkEmitterWrapperPass::OptimizationRemarkEmitterWrapperPass(llvm::OptimizationRemarkEmitterWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::OptimizationRemarkEmitterWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2606770;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6D40, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0CC058;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6D40, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeOptimizationRemarkEmitterWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6D40, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0CC058;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6D40, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::AnalysisUsage *llvm::OptimizationRemarkEmitterWrapperPass::getAnalysisUsage(llvm::OptimizationRemarkEmitterWrapperPass *this, llvm::AnalysisUsage *a2)
{
  llvm::LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(a2, a2);
  unint64_t result = llvm::AnalysisUsage::addRequiredID(a2, llvm::ProfileSummaryInfoWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

void llvm::callDefaultCtor<llvm::OptimizationRemarkEmitterWrapperPass>()
{
}

uint64_t sub_1CD4B4100(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1CBF5BF34(*a1, a2);
  uint64_t v9 = *a1;
  uint64_t v10 = *a1 + 8;
  if (*(unsigned char *)*a1)
  {
    uint64_t v11 = 8;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 8);
    uint64_t v11 = *(unsigned int *)(v9 + 16);
  }
  if (v10 + 16 * v11 == v8)
  {
    uint64_t v13 = a1[1];
    v19[0] = a2;
    v19[1] = a3;
    uint64_t v17 = 0;
    if (sub_1CBF5C064((uint64_t *)v13, v19, &v17)) {
      uint64_t v14 = v17;
    }
    else {
      uint64_t v14 = *(void *)v13 + 24 * *(unsigned int *)(v13 + 16);
    }
    uint64_t v15 = *a1;
    char v16 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t *))(**(void **)(*(void *)(v14 + 16) + 24)
                                                                         + 16))(*(void *)(*(void *)(v14 + 16) + 24), a3, a4, a1);
    uint64_t v17 = a2;
    v18[0] = v16;
    sub_1CBF5C150(v15, &v17, v18, (uint64_t)v19);
    uint64_t v8 = v19[0];
  }
  return *(unsigned __int8 *)(v8 + 8);
}

llvm *llvm::PHITransAddr::dump(llvm::PHITransAddr *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = llvm::dbgs(this);
  if (v2)
  {
    BOOL v5 = sub_1CB8E509C(v3, "PHITransAddr: ");
    llvm::Value::print(*(llvm::Value **)this, v5, 0);
    unint64_t result = sub_1CB8E509C(v5, "\n");
    uint64_t v6 = *((unsigned int *)this + 10);
    if (v6)
    {
      for (unint64_t i = 0; i != v6; ++i)
      {
        uint64_t v8 = llvm::dbgs(result);
        uint64_t v9 = sub_1CB8E509C(v8, "  Input #");
        sub_1CD098D14(v9, i, 0, 0, 0);
        uint64_t v10 = sub_1CB8E509C(v9, " is ");
        llvm::Value::print(*(llvm::Value **)(*((void *)this + 4) + 8 * i), v10, 0);
        unint64_t result = sub_1CB8E509C(v10, "\n");
      }
    }
  }
  else
  {
    return sub_1CB8E509C(v3, "PHITransAddr: null\n");
  }
  return result;
}

llvm::raw_ostream *sub_1CD4B4340(llvm::raw_ostream *a1, llvm::Value *a2)
{
  return a1;
}

llvm::raw_ostream *sub_1CD4B4374(llvm::raw_ostream *result, char a2)
{
  uint64_t v2 = (char *)*((void *)result + 4);
  if ((unint64_t)v2 >= *((void *)result + 3)) {
    return llvm::raw_ostream::write(result, a2);
  }
  *((void *)result + 4) = v2 + 1;
  char *v2 = a2;
  return result;
}

void llvm::PhiValues::PhiValuesCallbackVH::deleted(llvm::PhiValues **this)
{
}

void llvm::PhiValues::PhiValuesCallbackVH::allUsesReplacedWith(llvm::PhiValues **this, llvm::Value *a2)
{
}

void *sub_1CD4B43C4(uint64_t a1, uint64_t *a2)
{
  unint64_t result = sub_1CD4B58BC((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 48);
    if (v6 >= *(_DWORD *)(a1 + 52)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 40) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 48);
  }
  return result;
}

void *sub_1CD4B4448(void *result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v10 = v3;
    uint64_t v11 = v4;
    unsigned int v6 = a2;
    uint64_t v7 = (uint64_t)result;
    do
    {
      unint64_t result = sub_1CD4B58BC((uint64_t)v9, v7, v6);
      if (v9[16])
      {
        unint64_t v8 = *(unsigned int *)(v7 + 48);
        if (v8 >= *(unsigned int *)(v7 + 52)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v7 + 40) + 8 * v8) = *v6;
        ++*(_DWORD *)(v7 + 48);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

_DWORD *llvm::PhiValues::getValuesForPhi(llvm::PhiValues *this, const llvm::PHINode *a2)
{
  v11[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t *)((char *)this + 8);
  uint64_t v9 = 0;
  v10[0] = a2;
  if ((sub_1CD3C8538((uint64_t *)this + 1, v10, &v9) & 1) == 0 || (int v7 = *((_DWORD *)v9 + 2)) == 0)
  {
    v10[0] = v11;
    v10[1] = (void *)0x800000000;
    llvm::PhiValues::processPhi((uint64_t *)this, (uint64_t)a2, (uint64_t)v10);
    uint64_t v8 = 0;
    uint64_t v9 = a2;
    if (sub_1CD3C8538(v4, &v9, &v8)) {
      int v5 = *(_DWORD *)(v8 + 8);
    }
    else {
      int v5 = 0;
    }
    int v7 = v5;
    if (v10[0] != v11) {
      free(v10[0]);
    }
  }
  return sub_1CD4B5BB8((uint64_t)this + 32, &v7) + 2;
}

int32x2_t sub_1CD4B45FC(uint64_t a1, int a2)
{
  uint64_t v6 = 0;
  if (sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    uint64_t v4 = v6;
    int v5 = *(void **)(v6 + 48);
    if (v5 != (void *)(v6 + 64)) {
      free(v5);
    }
    if ((*(unsigned char *)(v4 + 8) & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)(v4 + 16), 8);
    }
    *(_DWORD *)uint64_t v4 = -2;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

int32x2_t sub_1CD4B468C(uint64_t a1, int a2)
{
  uint64_t v6 = 0;
  if (sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v6))
  {
    uint64_t v4 = v6;
    int v5 = *(void **)(v6 + 48);
    if (v5 != (void *)(v6 + 64)) {
      free(v5);
    }
    if ((*(unsigned char *)(v4 + 8) & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)(v4 + 16), 8);
    }
    *(_DWORD *)uint64_t v4 = -2;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

void sub_1CD4B4718(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_14:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = *(void *)a1 + 64;
    uint64_t v5 = 96 * v3;
    while (1)
    {
      int v6 = *(_DWORD *)(v4 - 64);
      if (v6 == -2) {
        goto LABEL_12;
      }
      if (v6 != -1) {
        break;
      }
LABEL_13:
      v4 += 96;
      v5 -= 96;
      if (!v5) {
        goto LABEL_14;
      }
    }
    int v7 = *(void **)(v4 - 16);
    if ((void *)v4 != v7) {
      free(v7);
    }
    if ((*(unsigned char *)(v4 - 56) & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)(v4 - 48), 8);
    }
LABEL_12:
    *(_DWORD *)(v4 - 64) = -1;
    goto LABEL_13;
  }

  sub_1CD4B5F7C(a1);
}

void sub_1CD4B47F4(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_14:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = *(void *)a1 + 64;
    uint64_t v5 = 96 * v3;
    while (1)
    {
      int v6 = *(_DWORD *)(v4 - 64);
      if (v6 == -2) {
        goto LABEL_12;
      }
      if (v6 != -1) {
        break;
      }
LABEL_13:
      v4 += 96;
      v5 -= 96;
      if (!v5) {
        goto LABEL_14;
      }
    }
    int v7 = *(void **)(v4 - 16);
    if ((void *)v4 != v7) {
      free(v7);
    }
    if ((*(unsigned char *)(v4 - 56) & 1) == 0) {
      MEMORY[0x1D25D9CD0](*(void *)(v4 - 48), 8);
    }
LABEL_12:
    *(_DWORD *)(v4 - 64) = -1;
    goto LABEL_13;
  }

  sub_1CD4B6030(a1);
}

void llvm::PhiValuesPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "PHI Values for function: ");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  int v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

llvm::PhiValuesWrapperPass *llvm::PhiValuesWrapperPass::PhiValuesWrapperPass(llvm::PhiValuesWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::PhiValuesWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2606810;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6D48, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0CE7B4;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCC6D48, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializePhiValuesWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6D48, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0CE7B4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6D48, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::PhiValuesWrapperPass::runOnFunction(llvm::PhiValuesWrapperPass *this, llvm::Function *a2)
{
}

void llvm::PhiValuesWrapperPass::releaseMemory(llvm::PhiValuesWrapperPass *this)
{
  uint64_t v1 = (_DWORD *)*((void *)this + 4);
  sub_1CD3C7F68(v1 + 2);
  sub_1CD4B4718(v1 + 8);

  sub_1CD4B47F4(v1 + 14);
}

void llvm::PhiValuesWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void sub_1CD4B4C54(llvm::Pass *a1)
{
  sub_1CD4B4DF0(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD4B4C8C(void *result)
{
  result[1] = 0;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = -4096;
  uint64_t v12 = 0;
  uint64_t v1 = *((unsigned int *)result + 4);
  if (v1)
  {
    int v2 = result;
    int32x2_t result = v10;
    uint64_t v3 = *v2;
    uint64_t v4 = 40 * v1;
    uint64_t v5 = (void *)(*v2 + 16);
    do
    {
      uint64_t v6 = v10[0] & 6;
      *(v5 - 1) = v6;
      *uint64_t v5 = 0;
      uint64_t v7 = v11;
      v5[1] = v11;
      if (v7 != -8192 && v7 != -4096 && v7 != 0)
      {
        unint64_t v9 = v10[0] & 0xFFFFFFFFFFFFFFF8;
        *uint64_t v5 = *(void *)(v10[0] & 0xFFFFFFFFFFFFFFF8);
        *(void *)unint64_t v9 = v5 - 1;
        *(v5 - 1) = v9 | v6;
        if (*v5) {
          *(void *)*uint64_t v5 = *(void *)*v5 & 7 | (v3 + 16);
        }
      }
      *(v5 - 2) = off_1F26068B0;
      void v5[2] = v12;
      v5 += 5;
      v3 += 40;
      v4 -= 40;
    }
    while (v4);
    if (v11 != -8192 && v11 != -4096)
    {
      if (v11) {
        return llvm::ValueHandleBase::RemoveFromUseList(v10);
      }
    }
  }
  return result;
}

void llvm::callDefaultCtor<llvm::PhiValuesWrapperPass>()
{
}

void sub_1CD4B4DF0(llvm::Pass *this)
{
  *(void *)this = &unk_1F2606810;
  int v2 = (void *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v2)
  {
    uint64_t v3 = sub_1CC0CE9E0(v2);
    MEMORY[0x1D25D9CE0](v3, 0x1060C4015D4655FLL);
  }

  llvm::Pass::~Pass(this);
}

void *sub_1CD4B4E64(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4B4EC8((uint64_t)a1, a2, v7);
    *uint64_t v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void *sub_1CD4B4EC8(uint64_t a1, void *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD3CDE3C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD3C8538((uint64_t *)a1, a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

unint64_t sub_1CD4B4F78(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  unint64_t result = sub_1CD4B501C(*(void *)a2, *(_DWORD *)(a2 + 16), a3[3], &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t v7 = sub_1CD4B50B8(a2, (uint64_t)a3, v10);
    unint64_t result = sub_1CBF62D84((unint64_t *)(v7 + 8), a3 + 1);
    *(void *)(v7 + 32) = a3[4];
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 40 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CD4B501C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = a1 + 40 * v5;
    uint64_t v7 = *(void *)(v6 + 24);
    if (v7 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = a1 + 40 * (v13 & v4);
        uint64_t v7 = *(void *)(v6 + 24);
        uint64_t v8 = 1;
        if (v7 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

uint64_t sub_1CD4B50B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B516C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4B501C(*(void *)a1, *(_DWORD *)(a1 + 16), *(void *)(a2 + 24), &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)(a3 + 24) != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4B516C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(40 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CD4B5234(a1, v4, &v4[5 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CD4B4C8C((void *)a1);
}

void *sub_1CD4B5234(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t result = sub_1CD4B4C8C((void *)a1);
  v15[0] = 2;
  v15[1] = 0;
  uint64_t v16 = -4096;
  uint64_t v17 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = off_1F26068B0;
  v11[0] = 2;
  v11[1] = 0;
  uint64_t v12 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = a2[3];
      if (v7 != v16 && v7 != v12)
      {
        uint64_t v18 = 0;
        sub_1CD4B501C(*(void *)a1, *(_DWORD *)(a1 + 16), v7, &v18);
        uint64_t v10 = v18;
        unint64_t result = (void *)sub_1CBF62D84((unint64_t *)(v18 + 8), a2 + 1);
        *(void *)(v10 + 32) = a2[4];
        ++*(_DWORD *)(a1 + 8);
        uint64_t v7 = a2[3];
      }
      if (v7 != -8192 && v7 != -4096 && v7 != 0) {
        unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(a2 + 1);
      }
      a2 += 5;
    }
    while (a2 != a3);
    if (v12 != -8192 && v12 != -4096 && v12) {
      unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v11);
    }
  }
  if (v16 != -8192 && v16 != -4096)
  {
    if (v16) {
      return llvm::ValueHandleBase::RemoveFromUseList(v15);
    }
  }
  return result;
}

uint64_t sub_1CD4B53A4(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    unint64_t v6 = (_DWORD *)(a1 + 96 * v5);
    int v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unint64_t v6 = (_DWORD *)(a1 + 96 * (v13 & v4));
        int v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unint64_t v6 = v10;
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1CD4B5440(uint64_t a1, int *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unsigned int v5 = v8;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD4B54EC(a1, a2, v8);
    *unsigned int v5 = *a2;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((void *)v5 + 1) = 1;
    int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    *((int64x2_t *)v5 + 1) = v7;
    *((int64x2_t *)v5 + 2) = v7;
    *((void *)v5 + 6) = v5 + 16;
    *((void *)v5 + 7) = 0x400000000;
  }
  return v5;
}

_DWORD *sub_1CD4B54EC(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B55A0(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD4B55A0(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  unint64_t result = operator new(96 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4B5678(a1, v4, v4 + 96 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 96 * v10;
    do
    {
      *unint64_t result = -1;
      result += 24;
      v11 -= 96;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4B5678(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 96 * v6;
    do
    {
      *int v7 = -1;
      v7 += 24;
      v8 -= 96;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    int v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      BOOL v12 = 0;
      sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      uint64_t v10 = v12;
      *BOOL v12 = *(_DWORD *)a2;
      sub_1CD4B575C((uint64_t)(v10 + 2), (unsigned int *)(a2 + 8));
      ++*(_DWORD *)(a1 + 8);
      uint64_t v11 = *(void **)(a2 + 48);
      if ((void *)(a2 + 64) != v11) {
        free(v11);
      }
      if ((*(unsigned char *)(a2 + 8) & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)(a2 + 16), 8);
      }
    }
    a2 += 96;
  }
}

uint64_t sub_1CD4B575C(uint64_t a1, unsigned int *a2)
{
  *(void *)a1 = 1;
  int64x2_t v4 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  *(int64x2_t *)(a1 + 8) = v4;
  *(int64x2_t *)(a1 + 24) = v4;
  sub_1CD4B57D0((unsigned int *)a1, a2);
  *(void *)(a1 + 40) = a1 + 56;
  *(void *)(a1 + 48) = 0x400000000;
  if (a2[12]) {
    sub_1CD41C56C(a1 + 40, (uint64_t)(a2 + 10));
  }
  return a1;
}

unsigned int *sub_1CD4B57D0(unsigned int *result, unsigned int *a2)
{
  unsigned int v2 = *a2;
  *a2 = *result & 0xFFFFFFFE | *a2 & 1;
  unsigned int v3 = result[1];
  *unint64_t result = v2 & 0xFFFFFFFE | *result & 1;
  result[1] = a2[1];
  a2[1] = v3;
  unsigned int v4 = *a2;
  if ((*result & 1) == 0)
  {
    if ((v4 & 1) == 0)
    {
      uint64_t v5 = *((void *)result + 1);
      *((void *)result + 1) = *((void *)a2 + 1);
      *((void *)a2 + 1) = v5;
      LODWORD(v5) = result[4];
      result[4] = a2[4];
      a2[4] = v5;
      return result;
    }
    unsigned int v4 = *result;
    uint64_t v6 = result;
    unint64_t result = a2;
    goto LABEL_7;
  }
  if ((v4 & 1) == 0)
  {
    uint64_t v6 = a2;
LABEL_7:
    long long v12 = *(_OWORD *)(v6 + 2);
    *uint64_t v6 = v4 | 1;
    for (uint64_t i = 2; i != 10; i += 2)
      *(void *)&v6[i] = *(void *)&result[i];
    *result &= ~1u;
    *(_OWORD *)(result + 2) = v12;
    return result;
  }
  uint64_t v8 = 0;
  int v9 = (int *)(result + 2);
  uint64_t v10 = (int *)(a2 + 2);
  do
  {
    uint64_t v11 = *(void *)&v9[v8];
    *(void *)&v9[v8] = *(void *)&v10[v8];
    *(void *)&v10[v8] = v11;
    v8 += 2;
  }
  while (v8 != 8);
  return result;
}

void *sub_1CD4B58BC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v14 = 0;
  unint64_t result = (void *)sub_1CD426E14(a2, *a3, &v14);
  int v7 = v14;
  if (result)
  {
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 4;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 8 * v9;
  }
  else
  {
    unint64_t result = sub_1CD4B597C((_DWORD *)a2, a3, v14);
    int v7 = result;
    *unint64_t result = *a3;
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 4;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v11 = v12 + 8 * v13;
    char v10 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD4B597C(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4B5A3C((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD426E14((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD4B5A3C(uint64_t a1, unsigned int a2)
{
  v14[4] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4270FC(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 40; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4270FC(a1, v14, v8);
}

_DWORD *sub_1CD4B5BB8(uint64_t a1, int *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  int v5 = v8;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD4B5C64(a1, a2, v8);
    *int v5 = *a2;
    *((_OWORD *)v5 + 1) = 0u;
    *((_OWORD *)v5 + 2) = 0u;
    *((_OWORD *)v5 + 3) = 0u;
    *((_OWORD *)v5 + 5) = 0u;
    *((_OWORD *)v5 + 4) = 0u;
    *((void *)v5 + 1) = 1;
    int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    *((int64x2_t *)v5 + 1) = v7;
    *((int64x2_t *)v5 + 2) = v7;
    *((void *)v5 + 6) = v5 + 16;
    *((void *)v5 + 7) = 0x400000000;
  }
  return v5;
}

_DWORD *sub_1CD4B5C64(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4B5D18(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD4B5D18(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  unint64_t result = operator new(96 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4B5DF0(a1, v4, v4 + 96 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 96 * v10;
    do
    {
      *unint64_t result = -1;
      result += 24;
      v11 -= 96;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4B5DF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = 96 * v6;
    do
    {
      *int v7 = -1;
      v7 += 24;
      v8 -= 96;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    int v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      uint64_t v12 = 0;
      sub_1CD4B53A4(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      uint64_t v10 = v12;
      *uint64_t v12 = *(_DWORD *)a2;
      sub_1CC00ACE8(v10 + 2, (unsigned int *)(a2 + 8));
      ++*(_DWORD *)(a1 + 8);
      uint64_t v11 = *(void **)(a2 + 48);
      if ((void *)(a2 + 64) != v11) {
        free(v11);
      }
      if ((*(unsigned char *)(a2 + 8) & 1) == 0) {
        MEMORY[0x1D25D9CD0](*(void *)(a2 + 16), 8);
      }
    }
    a2 += 96;
  }
}

int32x2_t sub_1CD4B5ED0(int32x2_t *a1, uint64_t a2)
{
  v7[0] = 2;
  v7[1] = 0;
  uint64_t v8 = -8192;
  uint64_t v9 = 0;
  sub_1CBF62D84((unint64_t *)(a2 + 8), v7);
  uint64_t v4 = v8;
  *(void *)(a2 + 32) = v9;
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v7);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

void sub_1CD4B5F7C(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC0CE8F0((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      unint64_t v5 = *(_DWORD **)a1;
      uint64_t v6 = 96 * v4;
      do
      {
        *unint64_t v5 = -1;
        v5 += 24;
        v6 -= 96;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC0CE854(a1, v4);
  }
}

void sub_1CD4B6030(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC0CE968((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      unint64_t v5 = *(_DWORD **)a1;
      uint64_t v6 = 96 * v4;
      do
      {
        *unint64_t v5 = -1;
        v5 += 24;
        v6 -= 96;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC0CE854(a1, v4);
  }
}

llvm::PostDominatorTreeWrapperPass *llvm::PostDominatorTreeWrapperPass::PostDominatorTreeWrapperPass(llvm::PostDominatorTreeWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::PostDominatorTreeWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F26068D8;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0x400000000;
  *((_DWORD *)this + 31) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((unsigned char *)this + 120) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6D50, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0CEBDC;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6D50, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

BOOL llvm::PostDominatorTree::dominates(llvm::PostDominatorTree *this, const llvm::Instruction *a2, const llvm::Instruction *a3)
{
  uint64_t v3 = *((void *)a2 + 5);
  if (v3 != *((void *)a3 + 5)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,true>::dominates();
  }
  if (*((unsigned char *)a2 + 16) == 83 && *((unsigned char *)a3 + 16) == 83) {
    return 0;
  }
  unint64_t v5 = (uint64_t *)(v3 + 48);
  do
  {
    uint64_t v6 = *v5;
    int v7 = (const llvm::Instruction *)(v6 - 24);
    if (!v6) {
      int v7 = 0;
    }
    BOOL result = v7 == a3;
    unint64_t v5 = (uint64_t *)(v6 + 8);
  }
  while (v7 != a2 && v7 != a3);
  return result;
}

void llvm::PostDominatorTreeWrapperPass::print(llvm::PostDominatorTreeWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

void llvm::createPostDomTree(llvm *this)
{
}

void *llvm::PostDominatorTreePrinterPass::PostDominatorTreePrinterPass(void *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

void llvm::PostDominatorTreePrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "PostDominatorTree for function: ");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  int v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void sub_1CD4B6390(uint64_t *a1)
{
  sub_1CC0CEE60(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4B63C8(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::callDefaultCtor<llvm::PostDominatorTreeWrapperPass>()
{
}

llvm::raw_ostream *sub_1CD4B6410(uint64_t a1, llvm::raw_ostream *a2, unsigned int a3)
{
  size_t v6 = llvm::raw_ostream::indent(a2, 2 * a3);
  int v7 = sub_1CB8E509C(v6, "[");
  uint64_t v8 = llvm::raw_ostream::operator<<(v7, a3);
  uint64_t v9 = sub_1CB8E509C(v8, "] ");
  BOOL result = sub_1CD4B64A0(v9, a1);
  uint64_t v11 = *(unsigned int *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(uint64_t **)(a1 + 24);
    uint64_t v13 = a3 + 1;
    uint64_t v14 = 8 * v11;
    do
    {
      uint64_t v15 = *v12++;
      BOOL result = (llvm::raw_ostream *)sub_1CD4B6410(v15, a2, v13);
      v14 -= 8;
    }
    while (v14);
  }
  return result;
}

llvm::raw_ostream *sub_1CD4B64A0(llvm::raw_ostream *a1, uint64_t a2)
{
  if (*(void *)a2) {
    llvm::Value::printAsOperand(*(llvm::Value **)a2, a1, 0, 0);
  }
  else {
    sub_1CB8E509C(a1, " <<exit node>>");
  }
  size_t v4 = sub_1CB8E509C(a1, " {");
  unint64_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(a2 + 72));
  size_t v6 = sub_1CB8E509C(v5, ",");
  int v7 = llvm::raw_ostream::operator<<(v6, *(unsigned int *)(a2 + 76));
  uint64_t v8 = sub_1CB8E509C(v7, "} [");
  uint64_t v9 = llvm::raw_ostream::operator<<(v8, *(unsigned int *)(a2 + 16));
  sub_1CB8E509C(v9, "]\n");
  return a1;
}

uint64_t llvm::ProfileSummaryInfo::computeThresholds(llvm::ProfileSummaryInfo *this)
{
  int v2 = (char **)(*((void *)this + 1) + 8);
  EntryForPercentile = llvm::ProfileSummaryBuilder::getEntryForPercentile(v2, dword_1EBD0ADA8);
  uint64_t HotCountThreshold = llvm::ProfileSummaryBuilder::getHotCountThreshold(v2);
  if (!*((unsigned char *)this + 24)) {
    *((unsigned char *)this + 24) = 1;
  }
  *((void *)this + 2) = HotCountThreshold;
  uint64_t result = llvm::ProfileSummaryBuilder::getColdCountThreshold(v2);
  if (!*((unsigned char *)this + 40)) {
    *((unsigned char *)this + 40) = 1;
  }
  *((void *)this + 4) = result;
  uint64_t v6 = *((void *)this + 1);
  if (v6 && *(_DWORD *)v6 == 2 && (byte_1EBD04938 || *(unsigned char *)(v6 + 72)) && byte_1EBD049F8)
  {
    unint64_t v7 = (unint64_t)(*(double *)&xmmword_1EBCC6DD8
                          * (*(double *)(v6 + 80)
                           * (double)*((unint64_t *)EntryForPercentile + 2)));
    BOOL v8 = v7 > dword_1EBD0AF28;
    if (!*((unsigned char *)this + 49)) {
      *((unsigned char *)this + 49) = 1;
    }
    int v10 = *((unsigned __int8 *)this + 51);
    uint64_t v9 = (char *)this + 51;
    *(v9 - 3) = v8;
    *(v9 - 1) = v7 > dword_1EBD0AFE8;
    if (!v10) {
LABEL_17:
    }
      *uint64_t v9 = 1;
  }
  else
  {
    BOOL v11 = *((void *)EntryForPercentile + 2) > (unint64_t)dword_1EBD0AF28;
    if (!*((unsigned char *)this + 49)) {
      *((unsigned char *)this + 49) = 1;
    }
    int v12 = *((unsigned __int8 *)this + 51);
    uint64_t v9 = (char *)this + 51;
    *(v9 - 3) = v11;
    *(v9 - 1) = *((void *)EntryForPercentile + 2) > (unint64_t)dword_1EBD0AFE8;
    if (!v12) {
      goto LABEL_17;
    }
  }
  return result;
}

unint64_t llvm::ProfileSummaryInfo::getProfileCount(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock **a2, llvm::BlockFrequencyInfoImplBase **a3, int a4)
{
  size_t v4 = (_DWORD *)*((void *)this + 1);
  if (v4 && *v4 == 2)
  {
    unint64_t v9 = 0;
    int v5 = llvm::Instruction::extractProfTotalWeight((llvm::Instruction *)a2, &v9);
    unint64_t v6 = v9 & 0xFFFFFFFFFFFFFF00;
    if (v5)
    {
      LOBYTE(BlockProfileCount) = v9;
    }
    else
    {
      unint64_t v6 = 0;
      LOBYTE(BlockProfileCount) = 0;
    }
  }
  else if (a3)
  {
    uint64_t BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a3, a2[5], a4);
    unint64_t v6 = BlockProfileCount & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    unint64_t v6 = 0;
    LOBYTE(BlockProfileCount) = 0;
  }
  return BlockProfileCount | v6;
}

BOOL llvm::ProfileSummaryInfo::isHotCount(llvm::ProfileSummaryInfo *this, unint64_t a2)
{
  return *((unsigned char *)this + 24) && *((void *)this + 2) <= a2;
}

BOOL llvm::ProfileSummaryInfo::isColdCount(llvm::ProfileSummaryInfo *this, unint64_t a2)
{
  return *((unsigned char *)this + 40) && *((void *)this + 4) >= a2;
}

BOOL llvm::ProfileSummaryInfo::isColdBlock(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock *a2, llvm::BlockFrequencyInfoImplBase **a3)
{
  unint64_t BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a3, a2, 0);
  return v5 && *((unsigned char *)this + 40) && *((void *)this + 4) >= BlockProfileCount;
}

BOOL llvm::ProfileSummaryInfo::isFunctionHotnessUnknown(llvm::ProfileSummaryInfo *this, uint64_t ***a2)
{
  llvm::Function::getEntryCount(a2, 0, (uint64_t)v3);
  return v3[16] == 0;
}

BOOL llvm::ProfileSummaryInfo::hasPartialSampleProfile(llvm::ProfileSummaryInfo *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (!v1 || *(_DWORD *)v1 != 2) {
    return 0;
  }
  if (byte_1EBD04938) {
    return 1;
  }
  return *(unsigned char *)(v1 + 72) != 0;
}

unint64_t llvm::ProfileSummaryInfo::computeThreshold(llvm::ProfileSummaryInfo *this, int a2)
{
  int v8 = a2;
  unint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    size_t v4 = (char *)this + 56;
    char v5 = sub_1CBAA0414((uint64_t *)this + 7, &v8);
    if ((int *)(*((void *)this + 7) + 16 * *((unsigned int *)this + 18)) == v5)
    {
      uint64_t v6 = *((void *)llvm::ProfileSummaryBuilder::getEntryForPercentile((char **)(*((void *)this + 1) + 8), v8) + 1);
      *((void *)sub_1CBAA05D4((uint64_t)v4, &v8) + 1) = v6;
    }
    else
    {
      uint64_t v6 = *((void *)v5 + 1);
    }
    unint64_t v2 = v6 & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    LOBYTE(v6) = 0;
  }
  return v2 | v6;
}

BOOL llvm::ProfileSummaryInfo::hasLargeWorkingSetSize(llvm::ProfileSummaryInfo *this)
{
  return *((unsigned char *)this + 51) && *((unsigned char *)this + 50) != 0;
}

BOOL llvm::ProfileSummaryInfo::isHotCountNthPercentile(llvm::ProfileSummaryInfo *this, int a2, unint64_t a3)
{
  unint64_t v4 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
  if (v5) {
    BOOL v6 = v4 > a3;
  }
  else {
    BOOL v6 = 1;
  }
  return !v6;
}

BOOL llvm::ProfileSummaryInfo::isColdCountNthPercentile(llvm::ProfileSummaryInfo *this, int a2, unint64_t a3)
{
  unint64_t v4 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
  return v5 && v4 >= a3;
}

uint64_t llvm::ProfileSummaryInfo::getOrCompColdCountThreshold(llvm::ProfileSummaryInfo *this)
{
  if (*((unsigned char *)this + 40)) {
    return *((void *)this + 4);
  }
  else {
    return 0;
  }
}

BOOL llvm::ProfileSummaryInfo::isHotBlockNthPercentile(llvm::ProfileSummaryInfo *this, int a2, const llvm::BasicBlock *a3, llvm::BlockFrequencyInfoImplBase **a4)
{
  unint64_t BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a4, a3, 0);
  BOOL result = 0;
  if (v8)
  {
    unint64_t v9 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
    if (v10) {
      BOOL v11 = v9 > BlockProfileCount;
    }
    else {
      BOOL v11 = 1;
    }
    return !v11;
  }
  return result;
}

BOOL llvm::ProfileSummaryInfo::isColdBlockNthPercentile(llvm::ProfileSummaryInfo *this, int a2, const llvm::BasicBlock *a3, llvm::BlockFrequencyInfoImplBase **a4)
{
  unint64_t BlockProfileCount = llvm::BlockFrequencyInfo::getBlockProfileCount(a4, a3, 0);
  BOOL result = 0;
  if (v8)
  {
    unint64_t v9 = llvm::ProfileSummaryInfo::computeThreshold(this, a2);
    return v10 && v9 >= BlockProfileCount;
  }
  return result;
}

BOOL llvm::ProfileSummaryInfo::isHotCallSite(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock **a2, llvm::BlockFrequencyInfoImplBase **a3)
{
  unint64_t ProfileCount = llvm::ProfileSummaryInfo::getProfileCount(this, a2, a3, 0);
  return v5 && *((unsigned char *)this + 24) && *((void *)this + 2) <= ProfileCount;
}

BOOL llvm::ProfileSummaryInfo::isColdCallSite(llvm::ProfileSummaryInfo *this, const llvm::BasicBlock **a2, llvm::BlockFrequencyInfoImplBase **a3)
{
  unint64_t ProfileCount = llvm::ProfileSummaryInfo::getProfileCount(this, a2, a3, 0);
  if (v6)
  {
    if (*((unsigned char *)this + 40)) {
      return *((void *)this + 4) >= ProfileCount;
    }
  }
  else
  {
    char v8 = (_DWORD *)*((void *)this + 1);
    if (v8 && *v8 == 2)
    {
      Caller = (uint64_t ***)llvm::CallBase::getCaller((llvm::CallBase *)a2);
      llvm::Function::getEntryCount(Caller, 0, (uint64_t)v10);
      return v10[16] != 0;
    }
  }
  return 0;
}

void llvm::initializeProfileSummaryInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6E20, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0CF9B4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6E20, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::ProfileSummaryInfoWrapperPass *llvm::ProfileSummaryInfoWrapperPass::ProfileSummaryInfoWrapperPass(llvm::ProfileSummaryInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::ProfileSummaryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2606978;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6E20, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0CF9B4;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6E20, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::ProfileSummaryPrinterPass::run()
{
}

void sub_1CD4B6EAC(llvm::ImmutablePass *a1)
{
  sub_1CD4B6F2C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4B6EE4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::callDefaultCtor<llvm::ProfileSummaryInfoWrapperPass>()
{
}

void sub_1CD4B6F2C(llvm::ImmutablePass *a1)
{
  *(void *)a1 = &unk_1F2606978;
  uint64_t v1 = *((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v1)
  {
    uint64_t v3 = a1;
    uint64_t v2 = sub_1CC0CFB78(v1);
    MEMORY[0x1D25D9CE0](v2, 0x1060C40BAADE331);
    a1 = v3;
  }

  llvm::ImmutablePass::~ImmutablePass(a1);
}

void sub_1CD4B6FB0(_WORD *a1, char **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBD048B8, 0, 0);
  byte_1EBD04938 = 0;
  qword_1EBD04940 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD04948 = 0;
  qword_1EBD048B8 = (uint64_t)&unk_1F26440A0;
  qword_1EBD04950 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD04958 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD04970 = (uint64_t)&qword_1EBD04958;
  sub_1CD4B70A0(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD048B8);
}

__n128 sub_1CD4B70A0(_WORD *a1, char **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBD048B8, "partial-profile", 0xFuLL);
  word_1EBD048C2 = (32 * (*a1 & 3)) | word_1EBD048C2 & 0xFF9F;
  char v6 = *a2;
  byte_1EBD04938 = **a2;
  byte_1EBD04949 = 1;
  byte_1EBD04948 = *v6;
  __n128 result = *a3;
  xmmword_1EBD048D8 = (__int128)*a3;
  return result;
}

void sub_1CD4B7128(_WORD *a1, uint64_t **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6D58, 0, 0);
  xmmword_1EBCC6DD8 = 0u;
  *(_OWORD *)&qword_1EBCC6DE8 = 0u;
  *((void *)&xmmword_1EBCC6DD8 + 1) = &unk_1F2601200;
  qword_1EBCC6D58 = (uint64_t)&unk_1F2601198;
  qword_1EBCC6DF8 = (uint64_t)&unk_1F2643E40;
  qword_1EBCC6E00 = (uint64_t)&unk_1F2601220;
  qword_1EBCC6E18 = (uint64_t)&qword_1EBCC6E00;
  sub_1CD4B721C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6D58);
}

__n128 sub_1CD4B721C(_WORD *a1, uint64_t **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6D58, "partial-sample-profile-working-set-size-scale-factor", 0x34uLL);
  word_1EBCC6D62 = (32 * (*a1 & 3)) | word_1EBCC6D62 & 0xFF9F;
  char v6 = *a2;
  *(void *)&xmmword_1EBCC6DD8 = **a2;
  byte_1EBCC6DF0 = 1;
  qword_1EBCC6DE8 = *v6;
  __n128 result = *a3;
  xmmword_1EBCC6D78 = (__int128)*a3;
  return result;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v8 = 0;
  uint64_t v9 = a2;
  if (sub_1CB915048((uint64_t *)(v3 + 24), &v9, &v8))
  {
    uint64_t v4 = v8;
    uint64_t v5 = *(void *)(v3 + 24);
    uint64_t v6 = *(unsigned int *)(v3 + 40);
  }
  else
  {
    uint64_t v5 = *(void *)(v3 + 24);
    uint64_t v6 = *(unsigned int *)(v3 + 40);
    uint64_t v4 = v5 + 16 * v6;
  }
  if (v4 == v5 + 16 * v6 || !*(void *)(v4 + 8)) {
    return 0;
  }
  if (*(void *)(a1 + 32)) {
    llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
  }
  return 1;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyWalk(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  uint64_t v3 = a2;
  sub_1CD3CFB98(a3, (unint64_t *)&v3, &v3);
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyBBInRegion();
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *(uint64_t **)(a1 + 48);
  while (v1 != v2)
  {
    uint64_t v3 = *v1++;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest(v3);
  }

  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegion();
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegion()
{
  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::VerifyRegionInfo)
  {
    v1[0] = 0;
    v1[1] = 0;
    uint64_t v0 = v1;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyWalk();
  }
}

{
  while (1)
    ;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::replaceExit(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::replaceEntryRecursive(void *a1, uint64_t a2)
{
  int v12 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  uint64_t v3 = *a1;
  BOOL v11 = a1;
  uint64_t v4 = sub_1CBC13470((void **)&v12, &v11);
  uint64_t v13 = v4;
  uint64_t v5 = v12;
  if (v12 != v4)
  {
    unint64_t v6 = v3 & 0xFFFFFFFFFFFFFFF8;
    do
    {
      unint64_t v7 = (uint64_t *)*--v4;
      uint64_t v13 = v4;
      *unint64_t v7 = *v7 & 7 | a2;
      uint64_t v8 = (void *)v7[5];
      uint64_t v9 = (void *)v7[6];
      if (v8 != v9)
      {
        do
        {
          char v10 = (void *)*v8;
          if ((*(void *)*v8 & 0xFFFFFFFFFFFFFFF8) == v6)
          {
            BOOL v11 = (void *)*v8;
            if ((unint64_t)v4 >= v14) {
              uint64_t v4 = sub_1CBC13470((void **)&v12, &v11);
            }
            else {
              *v4++ = v10;
            }
            uint64_t v13 = v4;
          }
          ++v8;
        }
        while (v8 != v9);
        uint64_t v5 = v12;
      }
    }
    while (v5 != v4);
  }
  if (v4)
  {
    uint64_t v13 = v4;
    operator delete(v4);
  }
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getDepth(uint64_t result)
{
  uint64_t v1 = result;
  LODWORD(result) = -1;
  do
  {
    uint64_t v1 = *(void *)(v1 + 8);
    __n128 result = (result + 1);
  }
  while (v1);
  return result;
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::getRegionFor(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = a2;
  int v2 = sub_1CD3C8538((uint64_t *)(a1 + 40), &v5, &v4);
  uint64_t result = 0;
  if (v2) {
    return *(void *)(v4 + 8);
  }
  return result;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::isSimple(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getEnteringBlock();
  }
  return 0;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getNameStr(void *a1@<X0>, std::string *a2@<X8>)
{
  memset(&v22, 0, sizeof(v22));
  memset(&__p, 0, sizeof(__p));
  uint64_t v4 = (llvm::Value *)(*a1 & 0xFFFFFFFFFFFFFFF8);
  Name = llvm::Value::getName(v4);
  if (v6)
  {
    std::string::__init(&v14, Name, v6);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v14;
  }
  else
  {
    LODWORD(v14.__r_.__value_.__r.__words[1]) = 0;
    char v17 = 0;
    uint64_t v18 = 0;
    p_p = &__p;
    int v19 = 0;
    v14.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
    v14.__r_.__value_.__r.__words[2] = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    llvm::Value::printAsOperand(v4, (llvm::raw_ostream *)&v14, 0, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v14);
  }
  unint64_t v7 = (llvm::Value *)a1[4];
  if (v7)
  {
    llvm::Value::getName(v7);
    if (v8)
    {
      uint64_t v9 = llvm::Value::getName(v7);
      std::string::__init(&v14, v9, v10);
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v22.__r_.__value_.__l.__data_);
      }
      std::string v22 = v14;
    }
    else
    {
      LODWORD(v14.__r_.__value_.__r.__words[1]) = 0;
      char v17 = 0;
      uint64_t v18 = 0;
      p_p = &v22;
      int v19 = 0;
      v14.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
      v14.__r_.__value_.__r.__words[2] = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      llvm::Value::printAsOperand(v7, (llvm::raw_ostream *)&v14, 0, 0);
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v14);
    }
  }
  else
  {
    MEMORY[0x1D25D9630](&v22, "<Function Return>");
  }
  sub_1CBAD7600(" => ", (const void **)&__p.__r_.__value_.__l.__data_, (void **)&v14.__r_.__value_.__l.__data_);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    BOOL v11 = &v22;
  }
  else {
    BOOL v11 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&v22.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = v22.__r_.__value_.__l.__size_;
  }
  uint64_t v13 = std::string::append(&v14, (const std::string::value_type *)v11, size);
  *a2 = *v13;
  v13->__r_.__value_.__r.__words[0] = 0;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::blocks(void *a1@<X0>, void *a2@<X8>)
{
  sub_1CD4BA8F0((uint64_t)&v7, *a1 & 0xFFFFFFFFFFFFFFF8, a1[4]);
  sub_1CD4BA860((uint64_t)&v3);
  sub_1CD473714(a2, (uint64_t)&v7, (uint64_t)&v3);
  if (__p)
  {
    std::string::size_type v6 = __p;
    operator delete(__p);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v9)
  {
    std::string::size_type v10 = v9;
    operator delete(v9);
  }
  if (v8 != v7) {
    free(v8);
  }
}

{
  void *v3;
  void *v4;
  void *__p;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  sub_1CD4BA79C((uint64_t)&v7, *a1 & 0xFFFFFFFFFFFFFFF8, a1[4]);
  sub_1CD4BA860((uint64_t)&v3);
  sub_1CD473714(a2, (uint64_t)&v7, (uint64_t)&v3);
  if (__p)
  {
    std::string::size_type v6 = __p;
    operator delete(__p);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v9)
  {
    std::string::size_type v10 = v9;
    operator delete(v9);
  }
  if (v8 != v7) {
    free(v8);
  }
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::elements()
{
}

{
  sub_1CD4B7F98();
}

{
  while (1)
    ;
}

{
  while (1)
    ;
}

llvm::raw_ostream *sub_1CD4B7AA4(llvm::raw_ostream *a1, void *a2)
{
  if ((*a2 & 4) != 0) {
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getNameStr();
  }
  Name = llvm::Value::getName((llvm::Value *)(*a2 & 0xFFFFFFFFFFFFFFF8));
  size_t v5 = v3;
  std::string::size_type v6 = (void *)*((void *)a1 + 4);
  if (v3 <= *((void *)a1 + 3) - (void)v6)
  {
    if (v3)
    {
      memcpy(v6, Name, v3);
      *((void *)a1 + 4) += v5;
    }
  }
  else
  {
    llvm::raw_ostream::write(a1, Name, v3);
  }
  return a1;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains();
  }
  return 1;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getSubRegionNode(uint64_t a1, uint64_t a2)
{
  size_t v3 = (uint64_t *)(*(void *)(a1 + 16) + 40);
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CD3C8538(v3, &v8, &v7))
  {
    uint64_t v4 = *(void *)(v7 + 8);
    if (v4) {
      BOOL v5 = v4 == a1;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5) {
      llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::contains();
    }
  }
  return 0;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getNode()
{
}

{
  while (1)
    ;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode(uint64_t a1, unint64_t a2)
{
  int v2 = *(void **)(a1 + 72);
  if (!v2) {
    goto LABEL_13;
  }
  size_t v3 = (void *)(a1 + 72);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      std::string::size_type v6 = v2;
    }
    else {
      std::string::size_type v6 = v2 + 1;
    }
    if (v5) {
      size_t v3 = v2;
    }
    int v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == (void *)(a1 + 72) || v3[4] > a2) {
LABEL_13:
  }
    operator new();
  return v3[5];
}

void *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::setRegionFor(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  uint64_t result = sub_1CD467E2C(a1 + 40, &v5);
  result[1] = a3;
  return result;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::clearNodeCache(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 72);
  sub_1CD4B9F64(*(void **)(a1 + 72));
  *(v1 - 1) = v1;
  void *v1 = 0;
  v1[1] = 0;
  size_t v3 = (uint64_t *)*(v1 - 4);
  int v2 = (uint64_t *)*(v1 - 3);
  while (v3 != v2)
  {
    uint64_t v4 = *v3++;
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::clearNodeCache(v4);
  }
}

void sub_1CD4B7F98()
{
}

void sub_1CD4B8004(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v11, &v13, 8, (uint64_t *)a1);
  *(_OWORD *)std::string v14 = *(_OWORD *)(a1 + 96);
  uint64_t v15 = *(void *)(a1 + 112);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)&v6, &v8, 8, (uint64_t *)a2);
  *(_OWORD *)std::string __p = *(_OWORD *)(a2 + 96);
  uint64_t v10 = *(void *)(a2 + 112);
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  sub_1CD473714(a3, (uint64_t)&v11, (uint64_t)&v6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v7 != v6) {
    free(v7);
  }
  if (v14[0])
  {
    v14[1] = v14[0];
    operator delete(v14[0]);
  }
  if (v12 != v11) {
    free(v12);
  }
}

void sub_1CD4B80EC()
{
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::RegionInfoBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = &unk_1F2606A20;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 48) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a2 + 52) = v4;
  LODWORD(v4) = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a2 + 56) = v4;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  sub_1CD3C7F68((_DWORD *)(a2 + 40));
  return a1;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::~RegionInfoBase(void *a1)
{
  *a1 = &unk_1F2606A20;
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::releaseMemory();
}

_DWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::releaseMemory(uint64_t a1)
{
  uint64_t result = sub_1CD3C7F68((_DWORD *)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    sub_1CD4B9F64(*(void **)(v3 + 72));
    *(void *)(v3 + 64) = v3 + 72;
    *(void *)(v3 + 80) = 0;
    *(void *)(v3 + 72) = 0;
    uint64_t v4 = (void **)(v3 + 40);
    sub_1CC0D3220(&v4);
    uint64_t result = (_DWORD *)MEMORY[0x1D25D9CE0](v3, 0x1020C406A19994FLL);
  }
  *(void *)(a1 + 32) = 0;
  return result;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::verifyBBMap()
{
}

{
  while (1)
    ;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::isRegion(uint64_t a1, unint64_t a2)
{
  int v2 = *(void **)(*(void *)(a1 + 24) + 8);
  if (v2)
  {
    do
    {
      if (v2[4] >= a2) {
        uint64_t v3 = v2;
      }
      else {
        uint64_t v3 = v2 + 1;
      }
      int v2 = (void *)*v3;
    }
    while (*v3);
  }
  llvm::DominatorTreeBase<llvm::BasicBlock,false>::dominates();
}

void *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::insertShortCut(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = a2;
  uint64_t v8 = a3;
  uint64_t v9 = 0;
  if (sub_1CD3C8538((uint64_t *)a4, &v8, &v9) && v9 != *(void *)a4 + 16 * *(unsigned int *)(a4 + 16)) {
    uint64_t v5 = *(void *)(v9 + 8);
  }
  uint64_t result = sub_1CC025000((uint64_t *)a4, &v7);
  result[1] = v5;
  return result;
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::getNextPostDom(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v10 = *a2;
  uint64_t v11 = 0;
  if (sub_1CD3C8538((uint64_t *)a3, &v10, &v11)
    && v11 != *(void *)a3 + 16 * *(unsigned int *)(a3 + 16))
  {
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v7 = *(void *)(v11 + 8);
    uint64_t v10 = 0;
    uint64_t v11 = v7;
    if (sub_1CB915048((uint64_t *)(v6 + 48), &v11, &v10)) {
      uint64_t v8 = v10;
    }
    else {
      uint64_t v8 = *(void *)(v6 + 48) + 16 * *(unsigned int *)(v6 + 64);
    }
    uint64_t v4 = *(uint64_t **)(v8 + 8);
  }
  return v4[1];
}

BOOL llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::isTrivialRegion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4 == a2 + 40)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = (llvm::Instruction *)(v4 - 24);
    if (v4) {
      uint64_t v7 = (unsigned __int8 *)(v4 - 24);
    }
    else {
      uint64_t v7 = 0;
    }
    if (v7[16] - 29 <= 0xA)
    {
      unsigned int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      uint64_t v5 = v6;
      if (NumSuccessors > 1) {
        return 0;
      }
    }
  }
  return llvm::Instruction::getSuccessor(v5, 0) == a3;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::createRegion()
{
}

{
  while (1)
    ;
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::findRegionsWithEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  uint64_t result = sub_1CB915048((uint64_t *)(v2 + 48), &v8, &v7);
  if (result)
  {
    uint64_t v4 = v7;
    uint64_t v5 = *(void *)(v2 + 48);
    uint64_t v6 = *(unsigned int *)(v2 + 64);
  }
  else
  {
    uint64_t v5 = *(void *)(v2 + 48);
    uint64_t v6 = *(unsigned int *)(v2 + 64);
    uint64_t v4 = v5 + 16 * v6;
  }
  if (v4 != v5 + 16 * v6)
  {
    if (*(void *)(v4 + 8)) {
      llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::getNextPostDom();
    }
  }
  return result;
}

void **llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::scanForRegions(uint64_t a1, uint64_t a2)
{
  v24[30] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a2 + 80);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v4 = (void *)(v2 - 24);
  }
  else {
    uint64_t v4 = 0;
  }
  v23[0] = v4;
  uint64_t v18 = 0;
  if (sub_1CB915048((uint64_t *)(v3 + 24), v23, &v18))
  {
    uint64_t v5 = v18;
    uint64_t v6 = *(void *)(v3 + 24);
    uint64_t v7 = *(unsigned int *)(v3 + 40);
  }
  else
  {
    uint64_t v6 = *(void *)(v3 + 24);
    uint64_t v7 = *(unsigned int *)(v3 + 40);
    uint64_t v5 = (void *)(v6 + 16 * v7);
  }
  if (v5 == (void *)(v6 + 16 * v7)) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v5[1];
  }
  sub_1CD4B8CB4((uint64_t)v23, v8);
  sub_1CD4BAE30((const void **)&v18, (llvm::SmallPtrSetImplBase *)v23);
  sub_1CD4BAE30((const void **)&v13, (llvm::SmallPtrSetImplBase *)v24);
  if (v21 != v16) {
    goto LABEL_20;
  }
  if (v21)
  {
    uint64_t v9 = v15;
    uint64_t v10 = v20;
    while (*v10 == *v9 && v10[1] == v9[1])
    {
      v10 += 2;
      v9 += 2;
      if (v10 == (void *)((char *)v20 + 16 * v21)) {
        goto LABEL_21;
      }
    }
LABEL_20:
    llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::findRegionsWithEntry();
  }
LABEL_21:
  if (v15 != &v17) {
    free(v15);
  }
  if (v14 != v13) {
    free(v14);
  }
  if (v20 != &v22) {
    free(v20);
  }
  if (v19 != v18) {
    free(v19);
  }
  return sub_1CD4B9AEC(v23);
}

void sub_1CD4B8CB4(uint64_t a1, uint64_t a2)
{
  v13[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAC98((uint64_t)&v10, a2);
  v7[0] = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v9 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = (char *)v6 + 8;
  uint64_t v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  sub_1CD4BAA08(a1, (uint64_t)&v10, (uint64_t)&v3);
  if (v7[1] != (char *)v8 + 8) {
    free(v7[1]);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v12 != v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
}

void *llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::buildRegionsTree(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = *(void *)a2;
  uint64_t v14 = *(void *)a2;
  for (uint64_t i = *(void *)(a3 + 32); v6 == i; uint64_t i = *(void *)(v3 + 32))
    uint64_t v3 = *(void *)(v3 + 8);
  uint64_t v15 = v6;
  uint64_t v16 = 0;
  if (sub_1CD3C8538((uint64_t *)(a1 + 40), &v15, &v16)
    && v16 != *(void *)(a1 + 40) + 16 * *(unsigned int *)(a1 + 56))
  {
    uint64_t v8 = *(void *)(v16 + 8);
    do
      uint64_t v8 = *(void *)(v8 + 8);
    while (v8);
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::addSubRegion();
  }
  uint64_t result = sub_1CD467E2C(a1 + 40, &v14);
  result[1] = v3;
  uint64_t v9 = *(unsigned int *)(a2 + 32);
  if (v9)
  {
    uint64_t v10 = *(uint64_t **)(a2 + 24);
    uint64_t v11 = 8 * v9;
    do
    {
      uint64_t v12 = *v10++;
      uint64_t result = (void *)llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::buildRegionsTree(a1, v12, v3);
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::calculate()
{
}

{
  while (1)
    ;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::dump(llvm *a1)
{
  uint64_t v1 = llvm::dbgs(a1);
  sub_1CB8E509C(v1, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::print();
}

void llvm::RegionInfo::~RegionInfo(llvm::RegionInfo *this)
{
}

BOOL llvm::RegionInfo::invalidate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[0] = (void **)a3;
  v8[1] = (void **)&llvm::RegionInfoAnalysis::Key;
  uint64_t v4 = sub_1CB896AE8(a3 + 48, (uint64_t)&llvm::RegionInfoAnalysis::Key);
  uint64_t v5 = *(void *)(a3 + 56);
  if (v5 == *(void *)(a3 + 48)) {
    uint64_t v6 = (unsigned int *)(a3 + 68);
  }
  else {
    uint64_t v6 = (unsigned int *)(a3 + 64);
  }
  BOOL v9 = v4 != (void *)(v5 + 8 * *v6);
  return !sub_1CBF75724(v8) && !sub_1CBF7593C((uint64_t)v8) && !sub_1CBF75B60((uint64_t)v8);
}

void llvm::RegionInfo::updateStatistics(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 32)) {
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getEnteringBlock();
  }
}

void llvm::RegionInfo::recalculate(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  a1[1] = a3;
  a1[2] = a4;
  a1[3] = a5;
  operator new();
}

llvm::RegionInfoPass *llvm::RegionInfoPass::RegionInfoPass(llvm::RegionInfoPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::RegionInfoPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2606A70;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 4) = &unk_1F2606A48;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6E28, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC0D3040;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC6E28, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeRegionInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC6E28, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC0D3040;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC6E28, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::RegionInfoPass::runOnFunction(uint64_t **this, llvm::Function *a2)
{
  ((void (*)(uint64_t **))(*this)[11])(this);
  uint64_t v4 = this[1];
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_2:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_2;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::DominatorTreeWrapperPass::ID);
  BOOL v9 = this[1];
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_4:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(char **)v10 != llvm::PostDominatorTreeWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_4;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v12 + 96))(v12, llvm::PostDominatorTreeWrapperPass::ID);
  uint64_t v14 = this[1];
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_6:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::DominanceFrontierWrapperPass::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_6;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  uint64_t v18 = v13 + 32;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::DominanceFrontierWrapperPass::ID);
  llvm::RegionInfo::recalculate(this + 4, (uint64_t)a2, v8 + 32, v18, v19 + 32);
}

void llvm::RegionInfoPass::releaseMemory(llvm::RegionInfoPass *this)
{
}

void llvm::RegionInfoPass::verifyAnalysis(llvm::RegionInfoPass *this)
{
  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::Function>>::VerifyRegionInfo) {
    llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegionNest();
  }
}

llvm::AnalysisUsage *llvm::RegionInfoPass::getAnalysisUsage(llvm::RegionInfoPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::PostDominatorTreeWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredID(a2, llvm::DominanceFrontierWrapperPass::ID);
}

void llvm::RegionInfoPass::print(llvm::RegionInfoPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

void llvm::RegionInfoPass::dump(llvm::RegionInfoPass *this)
{
}

void llvm::createRegionInfoPass(llvm *this)
{
}

void llvm::RegionInfoAnalysis::run(uint64_t a1@<X8>)
{
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1F2606A48;
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void *llvm::RegionInfoPrinterPass::RegionInfoPrinterPass(void *this, llvm::raw_ostream *a2)
{
  *this = a2;
  return this;
}

void llvm::RegionInfoPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "Region Tree for function: ");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  uint64_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void llvm::RegionInfoVerifierPass::run()
{
}

uint64_t sub_1CD4B99A4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = 0;
  size_t v4 = (void **)(a1 + 96);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  *(void *)&v10[0] = a2;
  BYTE8(v10[0]) = 0;
  LOBYTE(v11) = 0;
  unint64_t v5 = *(void *)(a1 + 104);
  if (v5 >= *(void *)(a1 + 112))
  {
    uint64_t v8 = sub_1CC0D30FC(v4, (uint64_t)v10);
  }
  else
  {
    long long v6 = v10[0];
    long long v7 = v10[1];
    *(void *)(v5 + 32) = v11;
    *(_OWORD *)unint64_t v5 = v6;
    *(_OWORD *)(v5 + 16) = v7;
    uint64_t v8 = (char *)(v5 + 40);
  }
  *(void *)(a1 + 104) = v8;
  return a1;
}

uint64_t sub_1CD4B9A48(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = 0;
  size_t v4 = (void **)(a1 + 96);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  *(void *)&v9[0] = a2;
  BYTE8(v9[0]) = 0;
  LOBYTE(v10) = 0;
  unint64_t v5 = *(void *)(a1 + 104);
  if (v5 >= *(void *)(a1 + 112))
  {
    long long v7 = sub_1CC0D30FC(v4, (uint64_t)v9);
  }
  else
  {
    long long v6 = v9[1];
    *(_OWORD *)unint64_t v5 = v9[0];
    *(_OWORD *)(v5 + 16) = v6;
    *(void *)(v5 + 32) = v10;
    long long v7 = (char *)(v5 + 40);
  }
  *(void *)(a1 + 104) = v7;
  return a1;
}

void **sub_1CD4B9AEC(void **a1)
{
  uint64_t v2 = (void **)a1[42];
  if (v2 != a1 + 44) {
    free(v2);
  }
  uint64_t v3 = a1[31];
  if (v3 != a1[30]) {
    free(v3);
  }
  size_t v4 = (void **)a1[12];
  if (v4 != a1 + 14) {
    free(v4);
  }
  unint64_t v5 = a1[1];
  if (v5 != *a1) {
    free(v5);
  }
  return a1;
}

void *sub_1CD4B9B58(void *a1)
{
  *a1 = &unk_1F2606B10;
  uint64_t v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2606B78;
  size_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD4B9C40(void *a1)
{
  *a1 = &unk_1F2606B78;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD4B9C94(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  **(_DWORD **)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD4B9D2C(v11);
}

uint64_t sub_1CD4B9D2C(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD4B9D44(void *a1)
{
  sub_1CD4B9B58(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD4B9D7C(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD4B9D88(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD4B9D98(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = **((_DWORD **)result + 16);
LABEL_3:
    size_t v4 = &unk_1F2606BC8;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = **((_DWORD **)result + 16);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD4B9E24(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  **(_DWORD **)(result + 128) = v1;
  return result;
}

void *sub_1CD4B9E3C(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD4B9E44(void *a1)
{
  *a1 = &unk_1F2606B78;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4B9EB8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD4B9EC0(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD4B9ED4(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD4B9EE8(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD4B9EFC(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void llvm::callDefaultCtor<llvm::RegionInfoPass>()
{
}

void sub_1CD4B9F64(void *a1)
{
  if (a1)
  {
    sub_1CD4B9F64(*a1);
    sub_1CD4B9F64(a1[1]);
    uint64_t v3 = a1[5];
    a1[5] = 0;
    if (v3) {
      MEMORY[0x1D25D9CE0](v3, 0x1020C405730B0C9);
    }
    operator delete(a1);
  }
}

_OWORD *sub_1CD4B9FD0(void **a1)
{
  uint64_t v2 = a1 + 12;
  uint64_t v3 = (uint64_t)a1[13];
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 32);
    if (!*(unsigned char *)(v3 - 8))
    {
      uint64_t v15 = *(void *)(v4 + 40);
      if (v15 == v4 + 40)
      {
        uint64_t v16 = 0;
      }
      else
      {
        if (v15) {
          uint64_t v16 = v15 - 24;
        }
        else {
          uint64_t v16 = 0;
        }
        if (*(unsigned __int8 *)(v16 + 16) - 29 >= 0xB) {
          uint64_t v16 = 0;
        }
      }
      *(void *)(v3 - 24) = v16;
      *(void *)(v3 - 16) = 0;
      *(unsigned char *)(v3 - 8) = 1;
    }
    int v5 = (void *)(v4 + 40);
    while (1)
    {
      char v6 = (void *)*v5;
      if ((void *)*v5 == v5
        || (v6 ? (long long v7 = (unsigned __int8 *)(v6 - 3)) : (long long v7 = 0), v7[16] - 29 > 0xA))
      {
        uint64_t result = 0;
      }
      else
      {
        uint64_t result = (_OWORD *)llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      }
      int v9 = *(_DWORD *)(v3 - 16);
      if (v9 == result) {
        break;
      }
      uint64_t v10 = *(llvm::Instruction **)(v3 - 24);
      unsigned int v11 = *(_DWORD *)(v3 - 16);
      *(_DWORD *)(v3 - 16) = v9 + 1;
      uint64_t Successor = llvm::Instruction::getSuccessor(v10, v11);
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, Successor);
      if (v13)
      {
        *(void *)&long long v19 = Successor;
        BYTE8(v19) = 0;
        BYTE8(v20) = 0;
        uint64_t v17 = a1[13];
        if (v17 >= a1[14])
        {
          uint64_t result = sub_1CBF9AC5C(v2, &v19);
        }
        else
        {
          long long v18 = v20;
          _OWORD *v17 = v19;
          v17[1] = v18;
          uint64_t result = v17 + 2;
        }
        a1[13] = result;
        return result;
      }
    }
    uint64_t v14 = a1[12];
    uint64_t v3 = (uint64_t)a1[13] - 32;
    a1[13] = (void *)v3;
    if (v14 != (void *)v3) {
      continue;
    }
    break;
  }
  return result;
}

uint64_t sub_1CD4BA124(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  do
  {
    uint64_t v3 = *(uint64_t **)(v2 - 40);
    uint64_t v4 = (_OWORD *)(v2 - 32);
    if (!*(unsigned char *)(v2 - 8))
    {
      sub_1CD4BA334((uint64_t)&v12, *(void *)(v2 - 40));
      if (*(unsigned char *)(v2 - 8)) {
        *(unsigned char *)(v2 - 8) = 0;
      }
      long long v11 = v12;
      *(void *)(v2 - 16) = v13;
      *uint64_t v4 = v11;
      *(unsigned char *)(v2 - 8) = 1;
    }
    uint64_t v5 = *v3;
    unint64_t v6 = *v3 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v7 = *(void *)(v6 + 40);
    if (v7 == v6 + 40 || (v7 ? (uint64_t v8 = (unsigned __int8 *)(v7 - 24)) : (uint64_t v8 = 0), v8[16] - 29 > 0xA)) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v8);
    }
    if ((*(void *)v4 & 6) != 0)
    {
      if ((*(void *)v4 & 6) != (v5 & 4)) {
        goto LABEL_12;
      }
    }
    else if (*(_DWORD *)(v2 - 16) != result)
    {
LABEL_12:
      long long v12 = *v4;
      *(void *)&long long v13 = *(void *)(v2 - 16);
      sub_1CD4BA460((unint64_t *)(v2 - 32));
      sub_1CD4BA2AC((uint64_t)&v12);
    }
    uint64_t v10 = *(void *)(a1 + 96);
    uint64_t v2 = *(void *)(a1 + 104) - 40;
    *(void *)(a1 + 104) = v2;
  }
  while (v10 != v2);
  return result;
}

void sub_1CD4BA2AC(uint64_t a1)
{
  if ((*(void *)a1 & 6) == 0) {
    llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a1 + 8), *(_DWORD *)(a1 + 16));
  }
  llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getSubRegionNode();
}

uint64_t sub_1CD4BA334(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = (*(void *)a2 >> 1) & 2;
  unint64_t v6 = v5 | a2 & 0xFFFFFFFFFFFFFFF9;
  *(void *)a1 = v6;
  uint64_t v8 = (void *)((v4 & 0xFFFFFFFFFFFFFFF8) + 40);
  uint64_t v7 = (void *)*v8;
  if ((void *)*v8 == v8)
  {
    int v9 = 0;
  }
  else
  {
    if (v7) {
      int v9 = v7 - 3;
    }
    else {
      int v9 = 0;
    }
    if (*((unsigned __int8 *)v9 + 16) - 29 >= 0xB) {
      int v9 = 0;
    }
  }
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = 0;
  if (!v5)
  {
    for (unsigned int i = 0; ; *(_DWORD *)(a1 + 16) = i)
    {
      unint64_t v11 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v12 = *(void *)(v11 + 40);
      if (v12 == v11 + 40
        || (v12 ? (long long v13 = (unsigned __int8 *)(v12 - 24)) : (long long v13 = 0), v13[16] - 29 > 0xA))
      {
        int NumSuccessors = 0;
      }
      else
      {
        int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v13);
      }
      if (NumSuccessors == i) {
        break;
      }
      uint64_t Successor = llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a1 + 8), i);
      unint64_t v6 = *(void *)a1;
      if (*(void *)(*(void *)((*(void *)a1 & 0xFFFFFFFFFFFFFFF8) + 8) + 32) != Successor) {
        break;
      }
      unsigned int i = *(_DWORD *)(a1 + 16) + 1;
    }
  }
  if ((v6 & 6) != 0
    && *(void *)(*(void *)((v6 & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == *(void *)((v6 & 0xFFFFFFFFFFFFFFF8) + 32))
  {
    *(void *)a1 = v6 & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  return a1;
}

unint64_t *sub_1CD4BA460(unint64_t *a1)
{
  unint64_t v2 = *a1;
  if ((*a1 & 6) != 0)
  {
    *a1 = v2 & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else
  {
    do
    {
      unsigned int v4 = *((_DWORD *)a1 + 4) + 1;
      *((_DWORD *)a1 + 4) = v4;
      unint64_t v5 = *(void *)(v2 & 0xFFFFFFFFFFFFFFF8) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v6 = *(void *)(v5 + 40);
      if (v6 == v5 + 40 || (v6 ? (uint64_t v7 = (unsigned __int8 *)(v6 - 24)) : (uint64_t v7 = 0), v7[16] - 29 > 0xA)) {
        int NumSuccessors = 0;
      }
      else {
        int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v7);
      }
      if (v4 == NumSuccessors) {
        break;
      }
      uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)a1[1], v4);
      unint64_t v2 = *a1;
    }
    while (*(void *)(*(void *)((*a1 & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == Successor);
  }
  return a1;
}

uint64_t **sub_1CD4BA518(uint64_t **a1, unint64_t *a2, long long *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v10 = v5[4];
        if (v9 >= v10) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }
      if (v10 >= v9) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    unint64_t v11 = operator new(0x30uLL);
    v16[0] = v11;
    v16[1] = v6;
    long long v12 = *a3;
    *((void *)a3 + 1) = 0;
    void v11[2] = v12;
    char v17 = 1;
    *(void *)unint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v8;
    *uint64_t v7 = (uint64_t *)v11;
    long long v13 = (uint64_t *)**a1;
    if (v13)
    {
      *a1 = v13;
      uint64_t v14 = *v7;
    }
    else
    {
      uint64_t v14 = (uint64_t *)v11;
    }
    sub_1CB8358B8(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v8 = (uint64_t **)v16[0];
    v16[0] = 0;
    sub_1CC0D342C((uint64_t)v16);
  }
  return v8;
}

uint64_t sub_1CD4BA61C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  do
  {
    uint64_t v3 = *(uint64_t **)(v2 - 40);
    unsigned int v4 = (_OWORD *)(v2 - 32);
    if (!*(unsigned char *)(v2 - 8))
    {
      sub_1CD4BA334((uint64_t)&v13, *(void *)(v2 - 40));
      if (*(unsigned char *)(v2 - 8)) {
        *(unsigned char *)(v2 - 8) = 0;
      }
      long long v12 = v13;
      *(void *)(v2 - 16) = v14;
      *unsigned int v4 = v12;
      *(unsigned char *)(v2 - 8) = 1;
    }
    uint64_t v5 = *v3;
    unint64_t v6 = *v3 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v7 = *(void *)(v6 + 40);
    if (v7 == v6 + 40 || (v7 ? (uint64_t v8 = (unsigned __int8 *)(v7 - 24)) : (uint64_t v8 = 0), v8[16] - 29 > 0xA)) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v8);
    }
    if ((*(void *)v4 & 6) != 0)
    {
      if ((*(void *)v4 & 6) != (v5 & 4)) {
        goto LABEL_12;
      }
    }
    else if (*(_DWORD *)(v2 - 16) != result)
    {
LABEL_12:
      long long v10 = *v4;
      *(void *)&long long v14 = *(void *)(v2 - 16);
      long long v13 = v10;
      sub_1CD4BA460((unint64_t *)(v2 - 32));
      sub_1CD4BA2AC((uint64_t)&v13);
    }
    uint64_t v11 = *(void *)(a1 + 96);
    uint64_t v2 = *(void *)(a1 + 104) - 40;
    *(void *)(a1 + 104) = v2;
  }
  while (v11 != v2);
  return result;
}

uint64_t sub_1CD4BA79C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = v12;
  unint64_t v9 = v12;
  int v11 = 0;
  uint64_t v10 = 0x100000008;
  v12[0] = a2;
  unint64_t v6 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v6 = a2;
  v6[8] = 0;
  v6[24] = 0;
  *((void *)&v13 + 1) = v6 + 32;
  long long v14 = v6 + 32;
  *(void *)&long long v13 = v6;
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)&v8);
  *(_OWORD *)(a1 + 96) = v13;
  *(void *)(a1 + 112) = v14;
  long long v14 = 0;
  long long v13 = 0uLL;
  if (v9 != v8) {
    free(v9);
  }
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a3);
  return a1;
}

uint64_t sub_1CD4BA860(uint64_t a1)
{
  uint64_t v8 = 0;
  long long v9 = 0uLL;
  memset(v7, 0, sizeof(v7));
  unsigned int v4 = (char *)v7 + 8;
  uint64_t v5 = (char *)v7 + 8;
  uint64_t v6 = 8;
  uint64_t v10 = 0;
  uint64_t v2 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)&v4);
  *(_OWORD *)(v2 + 96) = v9;
  *(void *)(v2 + 112) = v10;
  uint64_t v10 = 0;
  long long v9 = 0uLL;
  if (v5 != v4) {
    free(v5);
  }
  return a1;
}

uint64_t sub_1CD4BA8F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1CD4BA970((uint64_t)&v6, a2);
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)&v6);
  *(_OWORD *)(a1 + 96) = v8;
  *(void *)(a1 + 112) = v9;
  uint64_t v9 = 0;
  long long v8 = 0uLL;
  if (v7 != v6) {
    free(v7);
  }
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a3);
  return a1;
}

uint64_t sub_1CD4BA970(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = 0;
  unsigned int v4 = (void **)(a1 + 96);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  *(void *)&long long v9 = a2;
  BYTE8(v9) = 0;
  BYTE8(v10) = 0;
  uint64_t v5 = *(_OWORD **)(a1 + 104);
  if ((unint64_t)v5 >= *(void *)(a1 + 112))
  {
    uint64_t v7 = sub_1CBF9AC5C(v4, &v9);
  }
  else
  {
    long long v6 = v10;
    *uint64_t v5 = v9;
    v5[1] = v6;
    uint64_t v7 = v5 + 2;
  }
  *(void *)(a1 + 104) = v7;
  return a1;
}

void sub_1CD4BAA08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  sub_1CD4BAAE4((uint64_t)&v9, a2);
  sub_1CD4BAAE4((uint64_t)&v5, a3);
  sub_1CD4BAAE4(a1, (uint64_t)&v9);
  sub_1CD4BAAE4(a1 + 240, (uint64_t)&v5);
  if (v7 != &v8) {
    free(v7);
  }
  if (v6 != v5) {
    free(v6);
  }
  if (v11 != v12) {
    free(v11);
  }
  if (v10 != v9) {
    free(v10);
  }
}

uint64_t sub_1CD4BAAE4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(a1, (void *)(a1 + 32), 8, (uint64_t *)a2);
  *(void *)(v4 + 96) = v4 + 112;
  uint64_t v5 = v4 + 96;
  *(void *)(v5 + 8) = 0x800000000;
  if (*(_DWORD *)(a2 + 104)) {
    sub_1CD4BAB44(v5, a2 + 96);
  }
  return a1;
}

uint64_t sub_1CD4BAB44(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = a2 + 16;
    uint64_t v4 = *(void **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9)
        {
          int v11 = &v4[2 * v9];
          long long v12 = *(void **)a1;
          do
          {
            *long long v12 = *v4;
            v12[1] = v4[1];
            v4 += 2;
            v12 += 2;
          }
          while (v4 != v11);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          long long v13 = &v4[2 * v10];
          long long v14 = *(void **)a1;
          do
          {
            void *v14 = *v4;
            v14[1] = v4[1];
            v4 += 2;
            v14 += 2;
          }
          while (v4 != v13);
        }
        else
        {
          uint64_t v10 = 0;
        }
        if (v10 != v9) {
          memcpy((void *)(*(void *)a1 + 16 * v10), (const void *)(*(void *)a2 + 16 * v10), *(void *)a2 + 16 * v9 - (*(void *)a2 + 16 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v9;
    }
    else
    {
      long long v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

uint64_t sub_1CD4BAC98(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = a1 + 112;
  *(void *)(a1 + 104) = 0x800000000;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  uint64_t v4 = *(void *)(a2 + 24);
  unsigned int v5 = *(_DWORD *)(a1 + 104);
  if (v5 >= *(_DWORD *)(a1 + 108)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  long long v6 = (uint64_t *)(*(void *)(a1 + 96) + 16 * v5);
  *long long v6 = a2;
  v6[1] = v4;
  ++*(_DWORD *)(a1 + 104);
  sub_1CD4BAD50((void *)a1);
  return a1;
}

void *sub_1CD4BAD50(void *this)
{
  uint64_t v1 = this + 12;
  uint64_t v2 = this[12] + 16 * *((unsigned int *)this + 26);
  unsigned int v5 = *(uint64_t **)(v2 - 8);
  uint64_t v3 = (void *)(v2 - 8);
  uint64_t v4 = v5;
  if (v5 != (uint64_t *)(*(void *)(*(v3 - 1) + 24) + 8 * *(unsigned int *)(*(v3 - 1) + 32)))
  {
    uint64_t v6 = (uint64_t)this;
    do
    {
      *uint64_t v3 = v4 + 1;
      uint64_t v7 = *v4;
      this = sub_1CB89694C((llvm::SmallPtrSetImplBase *)v6, *v4);
      unsigned int v8 = *(_DWORD *)(v6 + 104);
      if (v9)
      {
        uint64_t v10 = *(void *)(v7 + 24);
        if (v8 >= *(_DWORD *)(v6 + 108)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v11 = (uint64_t *)(*(void *)(v6 + 96) + 16 * v8);
        *int v11 = v7;
        v11[1] = v10;
        unsigned int v8 = *(_DWORD *)(v6 + 104) + 1;
        *(_DWORD *)(v6 + 104) = v8;
      }
      uint64_t v12 = *v1 + 16 * v8;
      long long v13 = *(uint64_t **)(v12 - 8);
      uint64_t v3 = (void *)(v12 - 8);
      uint64_t v4 = v13;
    }
    while (v13 != (uint64_t *)(*(void *)(*(v3 - 1) + 24) + 8 * *(unsigned int *)(*(v3 - 1) + 32)));
  }
  return this;
}

const void **sub_1CD4BAE30(const void **a1, llvm::SmallPtrSetImplBase *a2)
{
  uint64_t v4 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, a1 + 4, a2);
  *((void *)v4 + 12) = (char *)v4 + 112;
  uint64_t v5 = (uint64_t)v4 + 96;
  *(void *)(v5 + 8) = 0x800000000;
  if (*((_DWORD *)a2 + 26)) {
    sub_1CD41E954(v5, (uint64_t)a2 + 96);
  }
  return a1;
}

void sub_1CD4BAE8C(unsigned char **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCC6E30, 0, 0);
  qword_1EBCC6EB0 = 0;
  byte_1EBCC6EC1 = 0;
  qword_1EBCC6EB8 = (uint64_t)&unk_1F25EDE58;
  qword_1EBCC6E30[0] = (uint64_t)&unk_1F2605290;
  qword_1EBCC6EC8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC6ED0 = (uint64_t)&unk_1F26052F8;
  qword_1EBCC6EE8 = (uint64_t)&qword_1EBCC6ED0;
  llvm::cl::Option::setArgStr(v4, "verify-region-info", 0x12uLL);
  sub_1CC08D588((llvm *)&qword_1EBCC6EB0, qword_1EBCC6E30, *a1);
  xmmword_1EBCC6E50 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCC6E30);
}

void sub_1CD4BAF98(llvm **a1, _WORD *a2, long long *a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC6EF0, 0, 0);
  byte_1EBCC6F84 = 0;
  qword_1EBCC6F70 = 0;
  unk_1EBCC6F78 = &unk_1F2606BC8;
  qword_1EBCC6EF0 = (uint64_t)&unk_1F2606B10;
  qword_1EBCC6F88 = (uint64_t)&unk_1F2606B78;
  qword_1EBCC6F90 = (uint64_t)&qword_1EBCC6EF0;
  qword_1EBCC6F98 = (uint64_t)&unk_1EBCC6FA8;
  qword_1EBCC6FA0 = 0x800000000;
  qword_1EBCC7128 = (uint64_t)&unk_1F2606C08;
  qword_1EBCC7140 = (uint64_t)&qword_1EBCC7128;
  sub_1CD4BB0AC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC6EF0);
}

void sub_1CD4BB0AC(llvm **a1, _WORD *a2, long long *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC6EF0, "print-region-style", 0x12uLL);
  sub_1CD4BB1C0(*a1);
  word_1EBCC6EFA = (32 * (*a2 & 3)) | word_1EBCC6EFA & 0xFF9F;
  xmmword_1EBCC6F10 = *a3;
  uint64_t v8 = *(void *)a4;
  unsigned int v9 = *(_DWORD *)(a4 + 8);

  sub_1CD4BB23C(v8, v9);
}

void sub_1CD4BB148()
{
}

void *sub_1CD4BB15C()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F2606C08;
  return result;
}

void sub_1CD4BB194(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2606C08;
}

llvm *sub_1CD4BB1C0(llvm *result)
{
  if (qword_1EBCC6F70)
  {
    uint64_t v2 = "cl::location(x) specified more than once!";
    __int16 v3 = 259;
    uint64_t v1 = (llvm::raw_ostream *)llvm::errs(result);
    return (llvm *)llvm::cl::Option::error(&qword_1EBCC6EF0, (llvm::Twine *)&v2, 0, 0, v1);
  }
  else
  {
    qword_1EBCC6F70 = (uint64_t)result;
    byte_1EBCC6F84 = 1;
    dword_1EBCC6F80 = *(_DWORD *)result;
  }
  return result;
}

void sub_1CD4BB23C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD4BB288(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD4BB288(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  void v11[2] = a4;
  void v11[3] = a5;
  v11[4] = &unk_1F2606BC8;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD4BB37C((unint64_t)v11);
  uint64_t v8 = qword_1EBCC6F98 + 48 * qword_1EBCC6FA0;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F2606BE8;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F2606BC8;
  LODWORD(qword_1EBCC6FA0) = qword_1EBCC6FA0 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCC6F90, a1, a2);
}

unint64_t sub_1CD4BB37C(unint64_t result)
{
  if (qword_1EBCC6FA0 >= HIDWORD(qword_1EBCC6FA0))
  {
    if (qword_1EBCC6F98 > result || qword_1EBCC6F98 + 48 * (unint64_t)qword_1EBCC6FA0 <= result) {
      sub_1CD4BB3F8();
    }
    sub_1CD4BB3F8();
  }
  return result;
}

void sub_1CD4BB3F8()
{
}

double llvm::RGPassManager::RGPassManager(llvm::RGPassManager *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::RGPassManager::ID;
  *((_DWORD *)this + 6) = 2;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = (char *)this + 64;
  *((void *)this + 7) = 0x1000000000;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((void *)this + 33) = (char *)this + 280;
  *((void *)this + 34) = 0x1000000000;
  *((_DWORD *)this + 102) = 0;
  double result = 0.0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(void *)this = &unk_1F2606C50;
  *((void *)this + 4) = &unk_1F2606D00;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::RGPassManager::ID;
  *((_DWORD *)this + 6) = 2;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = (char *)this + 64;
  *((void *)this + 7) = 0x1000000000;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((void *)this + 33) = (char *)this + 280;
  *((void *)this + 34) = 0x1000000000;
  *((_DWORD *)this + 102) = 0;
  double result = 0.0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *(void *)this = &unk_1F2606C50;
  *((void *)this + 4) = &unk_1F2606D00;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  return result;
}

llvm::AnalysisUsage *llvm::RGPassManager::getAnalysisUsage(llvm::RGPassManager *this, llvm::AnalysisUsage *a2)
{
  double result = llvm::AnalysisUsage::addRequiredID(a2, llvm::RegionInfoPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

uint64_t llvm::RGPassManager::runOnFunction(llvm::RGPassManager *this, llvm::Function *a2)
{
  uint64_t v3 = (uint64_t *)*((void *)this + 1);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(char **)v4 != llvm::RegionInfoPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v6 + 96))(v6, llvm::RegionInfoPass::ID) + 32;
  *((void *)this + 58) = v7;
  uint64_t v9 = *(void *)(*((void *)this + 5) + 8);
  uint64_t v8 = *(void *)(*((void *)this + 5) + 16);
  if (v8 != v9)
  {
    unsigned int v10 = 0;
    do
    {
      uint64_t v11 = *(void *)(v8 - 8);
      v8 -= 8;
      int v12 = (char *)this + 8 * v10++ + 32;
      *((void *)v12 + 20) = v11 + 208;
    }
    while (v8 != v9);
    uint64_t v7 = *((void *)this + 58);
  }
  sub_1CC0D37B0(*(void *)(v7 + 32), (void *)this + 52);
  uint64_t v13 = *((void *)this + 57);
  if (!v13)
  {
    LOBYTE(v20) = 0;
    return v20 & 1;
  }
  uint64_t v14 = *((void *)this + 53);
  if (*((void *)this + 54) == v14
    || (unint64_t v15 = *((void *)this + 56),
        uint64_t v16 = (char **)(v14 + 8 * (v15 >> 9)),
        char v17 = *v16,
        long long v18 = (uint64_t *)&(*v16)[8 * (v15 & 0x1FF)],
        uint64_t v19 = *(void *)(v14 + (((v15 + v13) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v15 + v13) & 0x1FF),
        v18 == (uint64_t *)v19))
  {
    int v20 = 0;
  }
  else
  {
    int v20 = 0;
    LODWORD(v21) = *((_DWORD *)this + 14);
    int v22 = v21;
    do
    {
      if (v22)
      {
        unint64_t v23 = 0;
        uint64_t v24 = *v18;
        do
        {
          uint64_t v25 = *(void *)(*((void *)this + 6) + 8 * v23);
          v20 |= (*(uint64_t (**)(uint64_t, uint64_t, llvm::RGPassManager *))(*(void *)v25 + 144))(v25, v24, this);
          ++v23;
          unint64_t v21 = *((unsigned int *)this + 14);
        }
        while (v23 < v21);
        char v17 = *v16;
        int v22 = *((_DWORD *)this + 14);
      }
      if ((char *)++v18 - v17 == 4096)
      {
        uint64_t v26 = v16[1];
        ++v16;
        char v17 = v26;
        long long v18 = (uint64_t *)v26;
      }
    }
    while (v18 != (uint64_t *)v19);
    uint64_t v13 = *((void *)this + 57);
    if (!v13) {
      goto LABEL_42;
    }
  }
  do
  {
    *((void *)this + 59) = *(void *)(*(void *)(*((void *)this + 53)
                                                   + (((unint64_t)(*((void *)this + 56) + v13 - 1) >> 6) & 0x3FFFFFFFFFFFFF8))
                                       + 8 * ((*((void *)this + 56) + v13 - 1) & 0x1FF));
    if (*((_DWORD *)this + 14))
    {
      uint64_t v27 = (const void ****)**((void **)this + 6);
      if (llvm::PMDataManager::isPassDebuggingExecutionsOrMore((llvm::RGPassManager *)((char *)this + 32))) {
        llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getNameStr();
      }
      llvm::PMDataManager::initializeAnalysisImpl((llvm::PMTopLevelManager **)this + 4, v27);
      uint64_t v28 = (void *)(**((void **)this + 59) & 0xFFFFFFFFFFFFFFF8);
      llvm::PrettyStackTraceEntry::PrettyStackTraceEntry((uint64_t)__p, 0);
      __p[0] = &unk_1F26174E8;
      __p[3] = v27;
      __p[4] = v28;
      __p[5] = 0;
      PassTimer = (llvm::Timer *)llvm::getPassTimer((llvm *)v27, v29);
      int32x2_t v32 = PassTimer;
      if (PassTimer) {
        v31.n128_f64[0] = llvm::Timer::startTimer(PassTimer);
      }
      int v33 = ((uint64_t (*)(const void ****, void, llvm::RGPassManager *, __n128))(*v27)[17])(v27, *((void *)this + 59), this, v31);
      if (v32) {
        llvm::Timer::stopTimer(v32);
      }
      llvm::PrettyStackTraceEntry::~PrettyStackTraceEntry((llvm::PrettyStackTraceEntry *)__p);
      if (llvm::PMDataManager::isPassDebuggingExecutionsOrMore((llvm::RGPassManager *)((char *)this + 32)))
      {
        if (v33) {
          llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getNameStr();
        }
        llvm::PMDataManager::dumpPreservedSet((llvm::RGPassManager *)((char *)this + 32), (const llvm::Pass *)v27);
      }
      uint64_t v35 = (llvm::Timer *)llvm::getPassTimer((llvm *)v27, v34);
      if (v35)
      {
        llvm::Timer::startTimer(v35);
        llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegion();
      }
      llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::verifyRegion();
    }
    *((void *)this + 57) = v13 - 1;
    sub_1CC0D41E4((void *)this + 52);
    if (*(void *)(*((void *)this + 58) + 32)) {
      llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::clearNodeCache();
    }
    uint64_t v13 = *((void *)this + 57);
  }
  while (v13);
  LODWORD(v21) = *((_DWORD *)this + 14);
LABEL_42:
  if (v21)
  {
    unint64_t v36 = 0;
    do
    {
      uint64_t v37 = *(void *)(*((void *)this + 6) + 8 * v36);
      v20 |= (*(uint64_t (**)(uint64_t))(*(void *)v37 + 152))(v37);
      ++v36;
    }
    while (v36 < *((unsigned int *)this + 14));
  }
  return v20 & 1;
}

void llvm::RGPassManager::dumpPassStructure(llvm::RGPassManager *this, int a2)
{
  uint64_t v4 = (llvm::raw_ostream *)llvm::errs(this);
  uint64_t v5 = llvm::raw_ostream::indent(v4, 2 * a2);
  sub_1CB8E509C(v5, "Region Pass Manager\n");
  if (*((_DWORD *)this + 14))
  {
    unint64_t v6 = 0;
    uint64_t v7 = (a2 + 1);
    do
    {
      uint64_t v8 = *(llvm::Pass **)(*((void *)this + 6) + 8 * v6);
      (*(void (**)(llvm::Pass *, uint64_t))(*(void *)v8 + 128))(v8, v7);
      llvm::PMDataManager::dumpLastUses((llvm::RGPassManager *)((char *)this + 32), v8, v7);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 14));
  }
}

double llvm::RegionPass::preparePassManager(llvm::RegionPass *this, llvm::PMStack *a2)
{
  uint64_t v4 = *(void *)a2;
  for (uint64_t i = *((void *)a2 + 1); v4 != i; uint64_t i = *((void *)a2 + 1))
  {
    if ((*(int (**)(void))(**(void **)(i - 8) + 40))(*(void *)(i - 8)) <= 5)
    {
      uint64_t v4 = *((void *)a2 + 1);
      break;
    }
    llvm::PMStack::pop(a2);
    uint64_t v4 = *(void *)a2;
  }
  if ((*(unsigned int (**)(void))(**(void **)(v4 - 8) + 40))(*(void *)(v4 - 8)) == 5
    && (llvm::PMDataManager::preserveHigherLevelAnalysis(*(llvm::PMTopLevelManager ***)(*((void *)a2 + 1) - 8), this) & 1) == 0)
  {
    return llvm::PMStack::pop(a2);
  }
  return result;
}

void llvm::RegionPass::assignPassManager(llvm::Pass *a1, llvm::PMStack *a2)
{
  uint64_t v4 = *(void *)a2;
  for (uint64_t i = *((void *)a2 + 1); ; uint64_t i = *((void *)a2 + 1))
  {
    if (v4 == i) {
      goto LABEL_6;
    }
    if ((*(int (**)(void))(**(void **)(i - 8) + 40))(*(void *)(i - 8)) <= 5) {
      break;
    }
    llvm::PMStack::pop(a2);
    uint64_t v4 = *(void *)a2;
  }
  uint64_t v4 = *((void *)a2 + 1);
LABEL_6:
  int v6 = (*(uint64_t (**)(void))(**(void **)(v4 - 8) + 40))(*(void *)(v4 - 8));
  uint64_t v7 = *(void *)(*((void *)a2 + 1) - 8);
  if (v6 == 5)
  {
    if (v7) {
      uint64_t v8 = v7 - 32;
    }
    else {
      uint64_t v8 = 0;
    }
    llvm::PMDataManager::add((llvm::PMDataManager *)(v8 + 32), a1);
  }
  operator new();
}

void llvm::RegionPass::createPrinterPass()
{
}

uint64_t sub_1CD4BBFAC()
{
  return 5;
}

uint64_t sub_1CD4BBFB4()
{
  return 0;
}

uint64_t sub_1CD4BBFBC()
{
  return 0;
}

void sub_1CD4BBFC4(void **a1)
{
  *a1 = &unk_1F2606C50;
  uint64_t v2 = (llvm::PMDataManager *)(a1 + 4);
  a1[4] = &unk_1F2606D00;
  sub_1CB904DFC(a1 + 52);
  llvm::PMDataManager::~PMDataManager(v2);

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD4BC044(void **a1)
{
  *a1 = &unk_1F2606C50;
  uint64_t v2 = (llvm::PMDataManager *)(a1 + 4);
  a1[4] = &unk_1F2606D00;
  sub_1CB904DFC(a1 + 52);
  llvm::PMDataManager::~PMDataManager(v2);
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CD4BC0D8()
{
  return "Region Pass Manager";
}

uint64_t sub_1CD4BC0E8(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_1CD4BC0F4()
{
  return 5;
}

void sub_1CD4BC0FC(void **a1)
{
  uint64_t v2 = (llvm::Pass *)(a1 - 4);
  *(a1 - 4) = &unk_1F2606C50;
  *a1 = &unk_1F2606D00;
  sub_1CB904DFC(a1 + 48);
  llvm::PMDataManager::~PMDataManager((llvm::PMDataManager *)a1);

  llvm::Pass::~Pass(v2);
}

void sub_1CD4BC17C(uint64_t a1)
{
}

uint64_t sub_1CD4BC184(uint64_t a1)
{
  return a1 - 32;
}

uint64_t sub_1CD4BC18C()
{
  return 5;
}

void llvm::createRegionPrinterPass(llvm *this)
{
}

void llvm::createRegionOnlyPrinterPass(llvm *this)
{
}

void llvm::createRegionViewerPass(llvm *this)
{
}

void llvm::createRegionOnlyViewerPass(llvm *this)
{
}

void sub_1CD4BC284(llvm::raw_ostream *a1, llvm::raw_ostream *a2, char a3, llvm::Twine *this)
{
  v5[0] = a1;
  v5[1] = a2;
  char v7 = a3;
  char v6 = 0;
  llvm::Twine::str(this, __p);
  sub_1CD4BC2E4(v5, (uint64_t)__p);
}

void sub_1CD4BC2E4(llvm::raw_ostream **a1, uint64_t a2)
{
}

void sub_1CD4BC350(llvm::raw_ostream **a1, uint64_t a2)
{
  char v28 = 12;
  strcpy((char *)v27, "Region Graph");
  char v4 = *(unsigned char *)(a2 + 23);
  int v5 = v4;
  uint64_t v6 = v4 & 0x7F;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = *(void *)(a2 + 8);
  }
  uint64_t v8 = sub_1CB8E509C(*a1, "digraph \"");
  if (v7) {
    uint64_t v9 = (char *)a2;
  }
  else {
    uint64_t v9 = (char *)v27;
  }
  llvm::DOT::EscapeString(v9, (uint64_t)&__p);
  if (v26 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  if (v26 >= 0) {
    size_t v11 = v26 & 0x7F;
  }
  else {
    size_t v11 = v25;
  }
  int v12 = llvm::raw_ostream::write(v8, p_p, v11);
  sub_1CB8E509C(v12, "\" {\n");
  if (v26 < 0) {
    operator delete(__p);
  }
  char v13 = *(unsigned char *)(a2 + 23);
  int v14 = v13;
  uint64_t v15 = v13 & 0x7F;
  if (v14 < 0) {
    uint64_t v15 = *(void *)(a2 + 8);
  }
  if (v15)
  {
    uint64_t v16 = sub_1CB8E509C(*a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)a2, (uint64_t)&__p);
    if (v26 >= 0) {
      char v17 = (const char *)&__p;
    }
    else {
      char v17 = (const char *)__p;
    }
    if (v26 >= 0) {
      size_t v18 = v26 & 0x7F;
    }
    else {
      size_t v18 = v25;
    }
    uint64_t v19 = v16;
    goto LABEL_24;
  }
  int v22 = (void *)(v28 & 0x7F);
  if (v28 < 0) {
    int v22 = v27[1];
  }
  if (v22)
  {
    unint64_t v23 = sub_1CB8E509C(*a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)v27, (uint64_t)&__p);
    if (v26 >= 0) {
      char v17 = (const char *)&__p;
    }
    else {
      char v17 = (const char *)__p;
    }
    if (v26 >= 0) {
      size_t v18 = v26 & 0x7F;
    }
    else {
      size_t v18 = v25;
    }
    uint64_t v19 = v23;
LABEL_24:
    int v20 = llvm::raw_ostream::write(v19, v17, v18);
    sub_1CB8E509C(v20, "\";\n");
    if (v26 < 0) {
      operator delete(__p);
    }
  }
  unint64_t v21 = *a1;
  char v26 = 0;
  LOBYTE(__p) = 0;
  llvm::raw_ostream::write(v21, (const char *)&__p, 0);
  if (v26 < 0) {
    operator delete(__p);
  }
  sub_1CB8E509C(*a1, "\n");
  if (v28 < 0) {
    operator delete(v27[0]);
  }
}

void sub_1CD4BC568()
{
}

void sub_1CD4BC6C8()
{
}

uint64_t sub_1CD4BC7B4(uint64_t a1)
{
  do
  {
    unsigned int v2 = *(_DWORD *)(a1 + 16) + 1;
    *(_DWORD *)(a1 + 16) = v2;
    uint64_t v3 = *(void **)a1;
    unint64_t v4 = **(void **)a1 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v5 = *(void *)(v4 + 40);
    if (v5 == v4 + 40 || (v5 ? (uint64_t v6 = (unsigned __int8 *)(v5 - 24)) : (uint64_t v6 = 0), v6[16] - 29 > 0xA)) {
      int NumSuccessors = 0;
    }
    else {
      int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v6);
    }
    if (v2 == NumSuccessors) {
      break;
    }
    uint64_t v8 = *(void *)(v3[1] + 32);
  }
  while (v8 == llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a1 + 8), v2));
  return a1;
}

unsigned __int8 *sub_1CD4BC850(uint64_t a1, llvm::raw_ostream *a2, void *a3)
{
  double result = (unsigned __int8 *)sub_1CD4BC9D8((uint64_t)v15, a3);
  unint64_t v7 = *a3 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v8 = *(void *)(v7 + 40);
  if (v8 == v7 + 40
    || (v8 ? (double result = (unsigned __int8 *)(v8 - 24)) : (double result = 0), result[16] - 29 > 0xA))
  {
    int v9 = 0;
  }
  else
  {
    double result = (unsigned __int8 *)llvm::Instruction::getNumSuccessors((llvm::Instruction *)result);
    int v9 = (int)result;
  }
  if (*(unsigned char *)(a1 + 16)) {
    double result = (unsigned __int8 *)sub_1CB8E509C(a2, "</tr><tr>");
  }
  if (v16 != v9 || v15[0] != (void)a3)
  {
    int v11 = 63;
    do
    {
      double result = (unsigned __int8 *)sub_1CD4BC7B4((uint64_t)v15);
      BOOL v13 = v11-- != 0;
      BOOL v14 = (void *)v15[0] == a3 && v16 == v9;
    }
    while (!v14 && v13);
  }
  return result;
}

void sub_1CD4BC92C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1CD4BC9D8(uint64_t a1, void *a2)
{
  unsigned int v2 = a2;
  *(void *)a1 = a2;
  unint64_t v4 = *a2 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v5 = *(void *)(v4 + 40);
  if (v5 == v4 + 40)
  {
    uint64_t v6 = 0;
  }
  else
  {
    if (v5) {
      uint64_t v6 = v5 - 24;
    }
    else {
      uint64_t v6 = 0;
    }
    if (*(unsigned __int8 *)(v6 + 16) - 29 >= 0xB) {
      uint64_t v6 = 0;
    }
  }
  unsigned int v7 = 0;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = 0;
  while (1)
  {
    unint64_t v8 = *v2 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v9 = *(void *)(v8 + 40);
    if (v9 == v8 + 40 || (v9 ? (unsigned int v10 = (unsigned __int8 *)(v9 - 24)) : (unsigned int v10 = 0), v10[16] - 29 > 0xA)) {
      int NumSuccessors = 0;
    }
    else {
      int NumSuccessors = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v10);
    }
    if (NumSuccessors == v7) {
      break;
    }
    uint64_t v12 = *(void *)(v2[1] + 32);
    if (v12 != llvm::Instruction::getSuccessor(*(llvm::Instruction **)(a1 + 8), v7)) {
      break;
    }
    unsigned int v7 = *(_DWORD *)(a1 + 16) + 1;
    *(_DWORD *)(a1 + 16) = v7;
    unsigned int v2 = *(void **)a1;
  }
  return a1;
}

void sub_1CD4BCAC0(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if ((a3 & 4) != 0)
  {
    *(unsigned char *)(a1 + 23) = 15;
    strcpy((char *)a1, "Not implemented");
  }
  else if (*a2)
  {
    sub_1CD465460((llvm::Value *)(a3 & 0xFFFFFFFFFFFFFFF8), (std::string *)a1);
  }
  else
  {
    sub_1CBF94B54((llvm::Value *)(a3 & 0xFFFFFFFFFFFFFFF8), (void (*)(uint64_t, void **, llvm::Value *))sub_1CD4655AC, (uint64_t)&v3, (void (*)(uint64_t, uint64_t, unsigned int *, std::string::size_type))sub_1CD4655B8, (uint64_t)sub_1CD465570, a1);
  }
}

void sub_1CD4BCB80(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_1CD4BCC74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  do
  {
    char v3 = *(void **)(v2 - 40);
    if (!*(unsigned char *)(v2 - 8))
    {
      sub_1CD4BC9D8((uint64_t)&v13, *(void **)(v2 - 40));
      if (*(unsigned char *)(v2 - 8)) {
        *(unsigned char *)(v2 - 8) = 0;
      }
      long long v12 = v13;
      *(void *)(v2 - 16) = v14;
      *(_OWORD *)(v2 - 32) = v12;
      *(unsigned char *)(v2 - 8) = 1;
    }
    unint64_t v4 = *v3 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v5 = *(void *)(v4 + 40);
    if (v5 == v4 + 40 || (v5 ? (uint64_t v6 = (unsigned __int8 *)(v5 - 24)) : (uint64_t v6 = 0), v6[16] - 29 > 0xA)) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v6);
    }
    unsigned int v8 = *(_DWORD *)(v2 - 16);
    if (v8 != result || *(void *)(v2 - 32) != (void)v3)
    {
      unsigned int v10 = *(llvm::Instruction **)(v2 - 24);
      sub_1CD4BC7B4(v2 - 32);
      llvm::Instruction::getSuccessor(v10, v8);
      llvm::RegionBase<llvm::RegionTraits<llvm::Function>>::getBBNode();
    }
    uint64_t v11 = *(void *)(a1 + 96);
    uint64_t v2 = *(void *)(a1 + 104) - 40;
    *(void *)(a1 + 104) = v2;
  }
  while (v11 != v2);
  return result;
}

void sub_1CD4BCDF8(llvm::raw_ostream *a1, llvm::Twine *this, char a3, llvm::Twine *a4)
{
  char v8 = 0;
  LOBYTE(__p) = 0;
  sub_1CC0D70B0(v9, a1, this, a3, a4, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
  char v4 = v10;
  if (v10 >= 0) {
    std::string::size_type v5 = v10 & 0x7F;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v9[1];
  }
  if (v5)
  {
    if (v10 >= 0) {
      uint64_t v6 = v9;
    }
    else {
      uint64_t v6 = (void **)v9[0];
    }
    llvm::DisplayGraph((std::string::value_type *)v6, v5, 0, 0);
    char v4 = v10;
  }
  if (v4 < 0) {
    operator delete(v9[0]);
  }
}

llvm::cl::Option *sub_1CD4BCE90(llvm::cl::Option *a1, char *a2, __n128 *a3, _WORD *a4, unsigned char **a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(unsigned char *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EDE58;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F26440A0;
  *(void *)(v10 + 152) = &unk_1F2643CC0;
  *(void *)(v10 + 160) = &unk_1F25EDE78;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD4BCF80(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD4BCF80(uint64_t a1, char *__s, __n128 *a3, _WORD *a4, unsigned char **a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  __n128 result = *a3;
  *(__n128 *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  long long v12 = *a5;
  *(unsigned char *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v12;
  return result;
}

void *llvm::ReplayInlineAdvisor::ReplayInlineAdvisor(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, long long *a6, char a7)
{
  uint64_t v11 = a1;
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  long long v12 = llvm::InlineAdvisor::InlineAdvisor(a1, a2, a3);
  *long long v12 = &unk_1F26073E0;
  uint64_t v13 = *a5;
  *a5 = 0;
  v12[4] = v13;
  *((unsigned char *)v12 + 40) = 0;
  long long v14 = *a6;
  long long v15 = a6[1];
  v12[15] = 0;
  int v16 = (llvm::StringMapImpl *)(v12 + 15);
  *((_OWORD *)v12 + 4) = v15;
  *((_OWORD *)v12 + 3) = v14;
  *((unsigned char *)v12 + 80) = a7;
  v12[11] = 0;
  unint64_t v62 = (llvm::StringMapImpl *)(v12 + 11);
  v12[12] = 0;
  v12[13] = 0x1000000000;
  v12[16] = 0;
  void v12[17] = 0x800000000;
  __int16 v83 = 261;
  uint64_t v17 = *((void *)a6 + 1);
  v82[0] = *(void *)a6;
  v82[1] = v17;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)v82, 0, 1, (uint64_t)&v86);
  if (v87)
  {
    uint64_t v19 = *(const llvm::MemoryBuffer **)&v86.__val_;
    std::error_code v85 = v86;
    if (v86.__val_)
    {
      std::error_code::message(&v65, &v85);
      uint64_t v55 = std::string::insert(&v65, 0, "Could not open remarks file: ");
      std::string::size_type v56 = v55->__r_.__value_.__r.__words[2];
      *(_OWORD *)v69 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
      *(void *)&long long v70 = v56;
      v55->__r_.__value_.__l.__size_ = 0;
      v55->__r_.__value_.__r.__words[2] = 0;
      v55->__r_.__value_.__r.__words[0] = 0;
      __int16 v83 = 260;
      v82[0] = v69;
      llvm::LLVMContext::emitError(a4, (uint64_t)v82);
      if (SBYTE7(v70) < 0) {
        operator delete(v69[0]);
      }
      if ((SHIBYTE(v65.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_79;
      }
      uint64_t v57 = (void *)v65.__r_.__value_.__r.__words[0];
LABEL_84:
      operator delete(v57);
      goto LABEL_79;
    }
    uint64_t v60 = a4;
    unint64_t v61 = v11;
  }
  else
  {
    uint64_t v60 = a4;
    unint64_t v61 = v11;
    size_t v18 = std::system_category();
    *(void *)&v85.__val_ = 0;
    v85.__cat_ = v18;
    uint64_t v19 = *(const llvm::MemoryBuffer **)&v86.__val_;
  }
  llvm::line_iterator::line_iterator((llvm::line_iterator *)v82, v19, 1, 0);
  v81[23] = 16;
  strcpy(v81, "' inlined into '");
  v79 = operator new(0x20uLL);
  long long v80 = xmmword_1CDB15B50;
  strcpy((char *)v79, "' will not be inlined into '");
  if ((_BYTE)v83)
  {
    while (1)
    {
      long long v78 = v84;
      unint64_t v20 = llvm::StringRef::find((uint64_t *)&v78, " at callsite ", 0xDuLL, 0);
      if (v20 == -1)
      {
        uint64_t v23 = 0;
        unint64_t v24 = 0;
        long long v75 = v78;
      }
      else
      {
        if (*((void *)&v78 + 1) >= v20) {
          unint64_t v21 = v20;
        }
        else {
          unint64_t v21 = *((void *)&v78 + 1);
        }
        if (*((void *)&v78 + 1) >= v20 + 13) {
          unint64_t v22 = v20 + 13;
        }
        else {
          unint64_t v22 = *((void *)&v78 + 1);
        }
        uint64_t v23 = v78 + v22;
        unint64_t v24 = *((void *)&v78 + 1) - v22;
        *(void *)&long long v75 = v78;
        *((void *)&v75 + 1) = v21;
      }
      uint64_t v76 = v23;
      unint64_t v77 = v24;
      if (v80 >= 0) {
        size_t v25 = (char *)&v79;
      }
      else {
        size_t v25 = (char *)v79;
      }
      if (v80 >= 0) {
        size_t v26 = HIBYTE(v80) & 0x7F;
      }
      else {
        size_t v26 = v80;
      }
      uint64_t v27 = llvm::StringRef::find((uint64_t *)&v75, v25, v26, 0);
      uint64_t v28 = v27;
      if (v27 == -1) {
        int v29 = (void **)v81;
      }
      else {
        int v29 = &v79;
      }
      uint64_t v30 = &v81[23];
      if (v27 != -1) {
        uint64_t v30 = (char *)&v80 + 15;
      }
      int v31 = *v30;
      int32x2_t v32 = (long long *)&v81[8];
      if (v27 != -1) {
        int32x2_t v32 = &v80;
      }
      BOOL v33 = v31 < 0;
      uint64_t v34 = v31 >= 0 ? (char *)v29 : (char *)*v29;
      uint64_t v35 = v31 & 0x7F;
      size_t v36 = v33 ? *(void *)v32 : v35;
      unint64_t v37 = llvm::StringRef::find((uint64_t *)&v75, v34, v36, 0);
      if (v37 == -1)
      {
        uint64_t v40 = 0;
        size_t v41 = 0;
        long long v72 = v75;
      }
      else
      {
        unint64_t v38 = *((void *)&v75 + 1) >= v37 ? v37 : *((void *)&v75 + 1);
        unint64_t v39 = *((void *)&v75 + 1) >= v37 + v36 ? v37 + v36 : *((void *)&v75 + 1);
        uint64_t v40 = v75 + v39;
        size_t v41 = *((void *)&v75 + 1) - v39;
        *(void *)&long long v72 = v75;
        *((void *)&v72 + 1) = v38;
      }
      uint64_t v73 = (unsigned __int8 *)v40;
      size_t v74 = v41;
      uint64_t v42 = llvm::StringRef::rfind((uint64_t *)&v72, ": '", 3uLL);
      if (v42 == -1)
      {
        std::string::size_type v44 = 0;
        std::string::size_type v45 = 0;
      }
      else
      {
        uint64_t v43 = v42 + 3;
        if (*((void *)&v72 + 1) < (unint64_t)(v42 + 3)) {
          uint64_t v43 = *((void *)&v72 + 1);
        }
        std::string::size_type v44 = v72 + v43;
        std::string::size_type v45 = *((void *)&v72 + 1) - v43;
      }
      unint64_t v46 = llvm::StringRef::rfind((uint64_t *)&v73, "'", 1uLL);
      if (v46 == -1)
      {
        BOOL v47 = v73;
        size_t v48 = v74;
      }
      else
      {
        BOOL v47 = v73;
        size_t v48 = v74 >= v46 ? v46 : v74;
      }
      unint64_t v49 = llvm::StringRef::find(&v76, ";", 1uLL, 0);
      if (v49 == -1)
      {
        uint64_t v50 = v76;
        uint64_t v51 = v77;
      }
      else
      {
        uint64_t v50 = v76;
        uint64_t v51 = v77;
        if (v77 >= v49) {
          uint64_t v51 = v49;
        }
      }
      if (!v45 || !v48 || !v51) {
        break;
      }
      __int16 v66 = 261;
      BOOL v52 = v28 == -1;
      v65.__r_.__value_.__r.__words[0] = v44;
      v65.__r_.__value_.__l.__size_ = v45;
      __int16 v64 = 261;
      v63[0] = v50;
      v63[1] = v51;
      sub_1CB8F1E58((uint64_t *)&v65, v63, (uint64_t)v69);
      llvm::Twine::str((llvm::Twine *)v69, __p);
      if (v68 >= 0) {
        __int16 v53 = (unsigned __int8 *)__p;
      }
      else {
        __int16 v53 = (unsigned __int8 *)__p[0];
      }
      if (v68 >= 0) {
        size_t v54 = v68 & 0x7F;
      }
      else {
        size_t v54 = (size_t)__p[1];
      }
      *(unsigned char *)(*sub_1CC0D7D50(v62, v53, v54) + 8) = v52;
      if (!*((_DWORD *)a6 + 4)) {
        sub_1CC0D7F54(v16, v47, v48);
      }
      if (v68 < 0) {
        operator delete(__p[0]);
      }
      llvm::line_iterator::advance((uint64_t)v82);
      if (!(_BYTE)v83) {
        goto LABEL_75;
      }
    }
    __int16 v71 = 1283;
    v69[0] = "Invalid remark format: ";
    long long v70 = v78;
    llvm::LLVMContext::emitError(v60, (uint64_t)v69);
    uint64_t v11 = v61;
  }
  else
  {
LABEL_75:
    uint64_t v11 = v61;
    *((unsigned char *)v61 + 40) = 1;
  }
  if (SHIBYTE(v80) < 0) {
    operator delete(v79);
  }
  if (v81[23] < 0)
  {
    uint64_t v57 = *(void **)v81;
    goto LABEL_84;
  }
LABEL_79:
  if ((v87 & 1) == 0)
  {
    uint64_t v58 = *(void *)&v86.__val_;
    *(void *)&v86.__val_ = 0;
    if (v58) {
      (*(void (**)(uint64_t))(*(void *)v58 + 8))(v58);
    }
  }
  return v11;
}

void llvm::getReplayInlineAdvisor()
{
}

void llvm::ReplayInlineAdvisor::getAdviceImpl(llvm::ReplayInlineAdvisor *this, llvm::CallBase *a2)
{
}

void sub_1CD4BD934(llvm::InlineAdvisor *a1)
{
  sub_1CD4BD96C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD4BD96C(llvm::InlineAdvisor *a1)
{
  *(void *)a1 = &unk_1F26073E0;
  sub_1CC0D7CD8((uint64_t)a1 + 120);
  sub_1CC0D7CD8((uint64_t)a1 + 88);
  uint64_t v2 = *((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  llvm::InlineAdvisor::~InlineAdvisor(a1);
}

llvm *llvm::SCEV::dump(llvm::SCEV *this)
{
  uint64_t v2 = llvm::dbgs(this);
  char v3 = llvm::SCEV::print(this, v2);
  __n128 result = llvm::dbgs(v3);
  std::string::size_type v5 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v5 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v5 + 1;
    *std::string::size_type v5 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::SCEV::print(llvm::SCEV *this, llvm::raw_ostream *a2)
{
  uint64_t v2 = " + ";
  char v3 = a2;
  switch(*((_WORD *)this + 12))
  {
    case 1:
      unint64_t v22 = (llvm::SCEV *)*((void *)this + 4);
      uint64_t v23 = "(trunc ";
      goto LABEL_56;
    case 2:
      unint64_t v22 = (llvm::SCEV *)*((void *)this + 4);
      uint64_t v23 = "(zext ";
      goto LABEL_56;
    case 3:
      unint64_t v22 = (llvm::SCEV *)*((void *)this + 4);
      uint64_t v23 = "(sext ";
      goto LABEL_56;
    case 4:
      goto LABEL_8;
    case 5:
      uint64_t v2 = " * ";
      goto LABEL_8;
    case 6:
      unint64_t v24 = sub_1CB8E509C(a2, "(");
      llvm::SCEV::print(*((llvm::SCEV **)this + 4), v24);
      char v3 = sub_1CB8E509C(v24, " /u ");
      llvm::SCEV::print(*((llvm::SCEV **)this + 5), v3);
      goto LABEL_57;
    case 7:
      size_t v25 = sub_1CB8E509C(a2, "{");
      llvm::SCEV::print(**((llvm::SCEV ***)this + 4), v25);
      uint64_t v26 = *((void *)this + 5);
      if (v26 != 1)
      {
        uint64_t v27 = 1;
        do
        {
          uint64_t v28 = sub_1CB8E509C(v3, ",+,");
          llvm::SCEV::print(*(llvm::SCEV **)(*((void *)this + 4) + 8 * v27++), v28);
        }
        while (v26 != v27);
      }
      sub_1CB8E509C(v3, "}<");
      __int16 v29 = *((_WORD *)this + 14);
      if ((v29 & 2) != 0)
      {
        sub_1CB8E509C(v3, "nuw><");
        __int16 v29 = *((_WORD *)this + 14);
      }
      if ((v29 & 4) != 0)
      {
        sub_1CB8E509C(v3, "nsw><");
        __int16 v29 = *((_WORD *)this + 14);
      }
      if ((v29 & 7) == 1) {
        sub_1CB8E509C(v3, "nw><");
      }
      llvm::Value::printAsOperand(**(llvm::Value ***)(*((void *)this + 6) + 32), v3, 0, 0);
      uint64_t v17 = ">";
      goto LABEL_28;
    case 8:
      uint64_t v2 = " umax ";
      goto LABEL_8;
    case 9:
      uint64_t v2 = " smax ";
      goto LABEL_8;
    case 0xA:
      uint64_t v2 = " umin ";
      goto LABEL_8;
    case 0xB:
      uint64_t v2 = " smin ";
      goto LABEL_8;
    case 0xC:
      uint64_t v2 = " umin_seq ";
LABEL_8:
      sub_1CB8E509C(a2, "(");
      size_t v5 = strlen(v2);
      uint64_t v6 = *((void *)this + 5);
      if (v6)
      {
        size_t v7 = v5;
        char v8 = 0;
        uint64_t v9 = (llvm::SCEV **)*((void *)this + 4);
        uint64_t v10 = 8 * v6;
        do
        {
          uint64_t v11 = *v9;
          if (v8) {
            size_t v12 = v7;
          }
          else {
            size_t v12 = 0;
          }
          if (v8) {
            uint64_t v13 = v2;
          }
          else {
            uint64_t v13 = 0;
          }
          long long v14 = (void *)*((void *)v3 + 4);
          if (v12 <= *((void *)v3 + 3) - (void)v14)
          {
            if (v12)
            {
              memcpy(v14, v13, v12);
              *((void *)v3 + 4) += v12;
            }
          }
          else
          {
            llvm::raw_ostream::write(v3, v13, v12);
          }
          llvm::SCEV::print(v11, v3);
          ++v9;
          char v8 = 1;
          v10 -= 8;
        }
        while (v10);
      }
      __n128 result = sub_1CB8E509C(v3, ")");
      if ((*((_WORD *)this + 12) & 0xFFFE) != 4) {
        return result;
      }
      __int16 v16 = *((_WORD *)this + 14);
      if ((v16 & 2) != 0)
      {
        __n128 result = sub_1CB8E509C(v3, "<nuw>");
        __int16 v16 = *((_WORD *)this + 14);
      }
      if ((v16 & 4) == 0) {
        return result;
      }
      uint64_t v17 = "<nsw>";
LABEL_28:
      return sub_1CB8E509C(v3, v17);
    case 0xD:
      unint64_t v22 = (llvm::SCEV *)*((void *)this + 4);
      uint64_t v23 = "(ptrtoint ";
LABEL_56:
      uint64_t v30 = sub_1CB8E509C(v3, v23);
      Type = (llvm::Type *)llvm::SCEV::getType(v22);
      llvm::Type::print(Type, v30, 0, 0);
      int32x2_t v32 = sub_1CB8E509C(v30, " ");
      llvm::SCEV::print(v22, v32);
      char v3 = sub_1CB8E509C(v32, " to ");
      llvm::Type::print(*((llvm::Type **)this + 5), v3, 0, 0);
LABEL_57:
      uint64_t v17 = ")";
      goto LABEL_28;
    case 0xE:
      size_t v36 = 0;
      if (llvm::SCEVUnknown::isSizeOf((llvm::SCEV *)((char *)this - 32), &v36))
      {
        size_t v18 = "sizeof(";
LABEL_33:
        uint64_t v19 = sub_1CB8E509C(v3, v18);
        llvm::Type::print(v36, v19, 0, 0);
        unint64_t v20 = v19;
        return sub_1CB8E509C(v20, ")");
      }
      if (llvm::SCEVUnknown::isAlignOf((llvm::SCEV *)((char *)this - 32), &v36))
      {
        size_t v18 = "alignof(";
        goto LABEL_33;
      }
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      if (llvm::SCEVUnknown::isOffsetOf((llvm::SCEV *)((char *)this - 32), &v35, &v34))
      {
        BOOL v33 = sub_1CB8E509C(v3, "offsetof(");
        llvm::Type::print(v35, v33, 0, 0);
        sub_1CB8E509C(v33, ", ");
        llvm::Value::printAsOperand(v34, v3, 0, 0);
        unint64_t v20 = v3;
        return sub_1CB8E509C(v20, ")");
      }
      return (llvm::raw_ostream *)llvm::Value::printAsOperand(*((llvm::Value **)this - 1), v3, 0, 0);
    case 0xF:
      uint64_t v17 = "***COULDNOTCOMPUTE***";
      goto LABEL_28;
    default:
      unint64_t v21 = (llvm::Value *)*((void *)this + 4);
      return (llvm::raw_ostream *)llvm::Value::printAsOperand(v21, a2, 0, 0);
  }
}

llvm::raw_ostream *sub_1CD4BDF50(llvm::raw_ostream *a1, llvm::SCEV *this)
{
  return a1;
}

uint64_t llvm::ScalarEvolution::getCouldNotCompute(llvm::ScalarEvolution *this)
{
  return *((void *)this + 6);
}

llvm::detail::IEEEFloat **llvm::ScalarEvolution::getPtrToIntExpr(llvm::ScalarEvolution *this, const llvm::SCEV *a2, llvm::Type *a3)
{
  __n128 result = (llvm::detail::IEEEFloat **)llvm::ScalarEvolution::getLosslessPtrToIntExpr(this, a2);
  if (*((_WORD *)result + 12) != 15)
  {
    return llvm::ScalarEvolution::getTruncateOrZeroExtend(this, result, a3, 0);
  }
  return result;
}

const llvm::SCEV *llvm::ScalarEvolution::getCastExpr(llvm::ScalarEvolution *a1, int a2, llvm::SCEV *a3, llvm::Type *a4)
{
  switch(a2)
  {
    case 2:
      return (const llvm::SCEV *)llvm::ScalarEvolution::getZeroExtendExpr(a1, a3, a4, 0);
    case 13:
      __n128 result = llvm::ScalarEvolution::getLosslessPtrToIntExpr(a1, a3);
      if (*((_WORD *)result + 12) != 15)
      {
        return (const llvm::SCEV *)llvm::ScalarEvolution::getTruncateOrZeroExtend(a1, result, a4, 0);
      }
      break;
    case 3:
      return (const llvm::SCEV *)llvm::ScalarEvolution::getSignExtendExpr(a1, (llvm::detail::IEEEFloat **)a3, (uint64_t **)a4, 0);
    default:
      return (const llvm::SCEV *)llvm::ScalarEvolution::getTruncateExpr(a1, a3, a4, 0);
  }
  return result;
}

BOOL llvm::ScalarEvolution::isAvailableAtLoopEntry(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::BasicBlock ***a3)
{
  return llvm::ScalarEvolution::getLoopDisposition(this, a2, (const llvm::Loop *)a3) == 1
      && llvm::ScalarEvolution::getBlockDisposition(this, a2, *a3[4]) == 2;
}

void gcd(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  sub_1CBF71A98((const llvm::APInt *)(*(void *)(a1 + 32) + 24), (llvm::APInt *)&v15);
  sub_1CBF71A98((const llvm::APInt *)(*(void *)(a2 + 32) + 24), (llvm::APInt *)&v13);
  unsigned int v5 = v16;
  unsigned int v6 = v14;
  if (v16 <= v14)
  {
    if (v16 < v14)
    {
      llvm::APInt::zext(&v15, v14, (uint64_t)&v11);
      if (v16 >= 0x41 && v15) {
        MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
      }
      uint64_t v15 = v11;
      unsigned int v5 = v12;
      unsigned int v6 = v14;
    }
  }
  else
  {
    llvm::APInt::zext(&v13, v16, (uint64_t)&v11);
    if (v14 >= 0x41 && v13) {
      MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
    }
    uint64_t v13 = v11;
    unsigned int v6 = v12;
    unsigned int v5 = v16;
  }
  unsigned int v10 = v5;
  uint64_t v9 = v15;
  unsigned int v16 = 0;
  unsigned int v8 = v6;
  uint64_t v7 = v13;
  unsigned int v14 = 0;
  llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v9, (uint64_t)&v7, a3);
  if (v8 >= 0x41 && v7) {
    MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
  }
  if (v10 >= 0x41 && v9) {
    MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
  }
  if (v14 >= 0x41 && v13) {
    MEMORY[0x1D25D9CB0](v13, 0x1000C8000313F17);
  }
  if (v16 >= 0x41)
  {
    if (v15) {
      MEMORY[0x1D25D9CB0](v15, 0x1000C8000313F17);
    }
  }
}

uint64_t llvm::ScalarEvolution::getSMaxExpr(uint64_t a1, uint64_t **a2)
{
  return llvm::ScalarEvolution::getMinMaxExpr(a1, 9, a2);
}

uint64_t llvm::ScalarEvolution::getUMaxExpr(uint64_t a1, uint64_t **a2)
{
  return llvm::ScalarEvolution::getMinMaxExpr(a1, 8, a2);
}

uint64_t llvm::ScalarEvolution::getSMinExpr(uint64_t a1, uint64_t **a2)
{
  return llvm::ScalarEvolution::getMinMaxExpr(a1, 11, a2);
}

uint64_t llvm::ScalarEvolution::getUMinExpr(uint64_t a1, unsigned int *a2, int a3)
{
  if (a3) {
    return llvm::ScalarEvolution::getSequentialMinMaxExpr(a1, 12, a2);
  }
  else {
    return llvm::ScalarEvolution::getMinMaxExpr(a1, 10, (uint64_t **)a2);
  }
}

unint64_t llvm::ScalarEvolution::getSizeOfScalableVectorExpr(llvm::ScalarEvolution *this, llvm::Type *a2, llvm::ScalableVectorType *a3)
{
  PointerTo = (llvm::Constant *)llvm::Type::getPointerTo(a3, 0);
  NullValue = (uint64_t *)llvm::Constant::getNullValue(PointerTo, v7, v8);
  uint64_t v13 = llvm::ConstantInt::get(a2, 1uLL, 0);
  ElementPtr = (llvm::detail::IEEEFloat *)llvm::ConstantExpr::getGetElementPtr((uint64_t)a3, NullValue, (uint64_t)&v13, 1, 0, 0, 0);
  uint64_t v11 = sub_1CC56C0C0((llvm *)0x2F, ElementPtr, a2, 0);
  return llvm::ScalarEvolution::getUnknown(this, v11);
}

uint64_t llvm::ScalarEvolution::instructionCouldExistWitthOperands(llvm::DominatorTree **this, const llvm::SCEV *a2, const llvm::SCEV *a3)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  __int16 v9 = 0;
  v10[0] = (uint64_t)a2;
  DefiningScopeBound = llvm::ScalarEvolution::getDefiningScopeBound((llvm::ScalarEvolution *)this, v10, 1, (unsigned char *)&v9 + 1);
  v10[0] = (uint64_t)a3;
  unsigned int v6 = llvm::ScalarEvolution::getDefiningScopeBound((llvm::ScalarEvolution *)this, v10, 1, &v9);
  uint64_t result = 0;
  if (HIBYTE(v9)) {
    BOOL v8 = v9 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    if (DefiningScopeBound == v6 || (llvm::DominatorTree::dominates(this[4], DefiningScopeBound, v6) & 1) != 0) {
      return 1;
    }
    else {
      return llvm::DominatorTree::dominates(this[4], v6, DefiningScopeBound);
    }
  }
  return result;
}

const llvm::SCEV *llvm::ScalarEvolution::getNoopOrAnyExtend(llvm::ScalarEvolution *this, const llvm::SCEV *a2, llvm::Type *a3)
{
  Type = (llvm::Type *)llvm::SCEV::getType(a2);
  uint64_t TypeSizeInBits = llvm::ScalarEvolution::getTypeSizeInBits(this, Type);
  if (TypeSizeInBits == llvm::ScalarEvolution::getTypeSizeInBits(this, a3)) {
    return a2;
  }

  return llvm::ScalarEvolution::getAnyExtendExpr(this, a2, a3);
}

uint64_t llvm::ScalarEvolution::getUMaxFromMismatchedTypes(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::SCEV *ZeroExtendExpr)
{
  NoopOrZeroExtend = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  Type = (llvm::Type *)llvm::SCEV::getType(a2);
  unint64_t TypeSizeInBits = llvm::ScalarEvolution::getTypeSizeInBits(this, Type);
  BOOL v8 = (llvm::Type *)llvm::SCEV::getType(ZeroExtendExpr);
  if (TypeSizeInBits <= llvm::ScalarEvolution::getTypeSizeInBits(this, v8))
  {
    unsigned int v10 = (llvm::Type *)llvm::SCEV::getType(ZeroExtendExpr);
    NoopOrZeroExtend = llvm::ScalarEvolution::getNoopOrZeroExtend(this, NoopOrZeroExtend, v10);
  }
  else
  {
    __int16 v9 = (llvm::Type *)llvm::SCEV::getType(NoopOrZeroExtend);
    ZeroExtendExpr = (const llvm::SCEV *)llvm::ScalarEvolution::getZeroExtendExpr(this, ZeroExtendExpr, v9, 0);
  }
  v13[0] = v14;
  v14[0] = NoopOrZeroExtend;
  v14[1] = ZeroExtendExpr;
  v13[1] = (void *)0x200000002;
  uint64_t MinMaxExpr = llvm::ScalarEvolution::getMinMaxExpr((uint64_t)this, 8, (uint64_t **)v13);
  if (v13[0] != v14) {
    free(v13[0]);
  }
  return MinMaxExpr;
}

uint64_t llvm::ScalarEvolution::getWrapPredicate(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unsigned int v14 = v16;
  v16[0] = 2;
  uint64_t v15 = 0x2000000001;
  sub_1CC1312F4((uint64_t)&v14, a2);
  if (v15 >= HIDWORD(v15)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((_DWORD *)v14 + v15) = a3;
  LODWORD(v15) = v15 + 1;
  uint64_t v13 = 0;
  uint64_t v6 = a1 + 848;
  NodeOrInsertPos = llvm::FoldingSetBase::FindNodeOrInsertPos(a1 + 848, (uint64_t)&v14, &v13, (uint64_t)off_1F26076B8);
  if (NodeOrInsertPos)
  {
    uint64_t v8 = (uint64_t)(NodeOrInsertPos - 1);
  }
  else
  {
    unsigned int v10 = (uint64_t *)(a1 + 864);
    uint64_t v8 = sub_1CB906F34((uint64_t *)(a1 + 864), 56, 3);
    uint64_t v11 = llvm::FoldingSetNodeID::Intern((uint64_t)&v14, v10);
    *(void *)(v8 + 8) = 0;
    *(void *)(v8 + 16) = v11;
    *(void *)(v8 + 24) = v12;
    *(_DWORD *)(v8 + 32) = 2;
    *(void *)uint64_t v8 = &unk_1F2607550;
    *(void *)(v8 + 40) = a2;
    *(_DWORD *)(v8 + 48) = a3;
    llvm::FoldingSetBase::InsertNode(v6, (uint64_t *)(v8 + 8), v13, (uint64_t)off_1F26076B8);
  }
  if (v14 != v16) {
    free(v14);
  }
  return v8;
}

uint64_t llvm::PredicatedScalarEvolution::areAddRecsEqualWithPreds(llvm::ScalarEvolution **this, const llvm::SCEVAddRecExpr *a2, const llvm::SCEVAddRecExpr *a3)
{
  if (a2 == a3) {
    return 1;
  }
  void v11[5] = v3;
  v11[6] = v4;
  v11[0] = (uint64_t)this;
  uint64_t result = sub_1CC0F7938(v11, **((void **)a2 + 4), **((void **)a3 + 4));
  if (result)
  {
    uint64_t v9 = sub_1CBFD7EA0((uint64_t)a2, this[11]);
    uint64_t v10 = sub_1CBFD7EA0((uint64_t)a3, this[11]);
    return sub_1CC0F7938(v11, v9, v10);
  }
  return result;
}

unint64_t *llvm::ScalarEvolution::getRangeForAffineNoSelfWrappingAR@<X0>(llvm::ScalarEvolution *a1@<X0>, uint64_t a2@<X1>, const llvm::SCEV *a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  v44[2] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = sub_1CBFD7EA0(a2, a1);
  if (*(_WORD *)(v12 + 24)
    || (uint64_t v14 = v12,
        uint64_t v15 = (llvm::Type *)llvm::SCEV::getType(a3),
        unint64_t TypeSizeInBits = llvm::ScalarEvolution::getTypeSizeInBits(a1, v15),
        uint64_t v17 = (llvm::Type *)llvm::SCEV::getType(**(llvm::SCEV ***)(a2 + 32)),
        TypeSizeInBits > llvm::ScalarEvolution::getTypeSizeInBits(a1, v17)))
  {
    return llvm::ConstantRange::ConstantRange((unint64_t *)a6, a4, 1);
  }
  else
  {
    Type = (llvm::Type *)llvm::SCEV::getType(**(llvm::SCEV ***)(a2 + 32));
    NoopOrZeroExtend = llvm::ScalarEvolution::getNoopOrZeroExtend(a1, a3, Type);
    unint64_t v20 = (llvm::Type *)llvm::SCEV::getType(**(llvm::SCEV ***)(a2 + 32));
    Constant = (const llvm::SCEV *)llvm::ScalarEvolution::getConstant(a1, v20, 0xFFFFFFFFFFFFFFFFLL, (const llvm::APInt *)1);
    v43[0] = v44;
    v44[0] = v14;
    v44[1] = llvm::ScalarEvolution::getNegativeSCEV(a1, v14, 0);
    v43[1] = (void *)0x200000002;
    unint64_t MinMaxExpr = llvm::ScalarEvolution::getMinMaxExpr((uint64_t)a1, 10, (uint64_t **)v43);
    if (v43[0] != v44) {
      free(v43[0]);
    }
    UDivExpr = (const llvm::APInt *)llvm::ScalarEvolution::getUDivExpr(a1, Constant, MinMaxExpr);
    if (llvm::ScalarEvolution::isKnownPredicateViaConstantRanges(a1, 0x25u, NoopOrZeroExtend, UDivExpr))
    {
      if (a5 == 1) {
        unsigned int v24 = 41;
      }
      else {
        unsigned int v24 = 37;
      }
      if (a5 == 1) {
        unsigned int v25 = 39;
      }
      else {
        unsigned int v25 = 35;
      }
      uint64_t v26 = (const llvm::APInt *)llvm::SCEVAddRecExpr::evaluateAtIteration(*(uint64_t **)(a2 + 32), *(void *)(a2 + 40), NoopOrZeroExtend, a1);
      uint64_t v27 = **(llvm::SCEV ***)(a2 + 32);
      uint64_t RangeRef = llvm::ScalarEvolution::getRangeRef(a1, v27, a5, 0);
      sub_1CC067C7C((uint64_t)v43, RangeRef);
      uint64_t v29 = llvm::ScalarEvolution::getRangeRef(a1, v26, a5, 0);
      sub_1CC067C7C((uint64_t)v40, v29);
      llvm::ConstantRange::unionWith((uint64_t)v43, v40, 0, (uint64_t)&v36);
      if (llvm::ConstantRange::isFullSet(&v36))
      {
LABEL_16:
        *(_DWORD *)(a6 + 8) = v37;
        *(void *)a6 = v36;
        *(_DWORD *)(a6 + 24) = v39;
        *(void *)(a6 + 16) = v38;
        int v37 = 0;
        int v39 = 0;
LABEL_17:
        sub_1CC05EB8C((uint64_t)&v36);
        sub_1CC05EB8C((uint64_t)v40);
        return (unint64_t *)sub_1CC05EB8C((uint64_t)v43);
      }
      if (a5 == 1)
      {
        if (llvm::ConstantRange::isSignWrappedSet((llvm::ConstantRange *)&v36)) {
          goto LABEL_23;
        }
      }
      else if (llvm::ConstantRange::isWrappedSet((llvm::ConstantRange *)&v36))
      {
        goto LABEL_23;
      }
      uint64_t v30 = llvm::ScalarEvolution::getRangeRef(a1, v14, 1, 0);
      llvm::ConstantRange::getSignedMin(v30, (uint64_t)&v41);
      int v31 = sub_1CBBE05BC((uint64_t)&v41);
      if (v42 >= 0x41 && v41) {
        MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
      }
      if (v31 && llvm::ScalarEvolution::isKnownPredicateViaConstantRanges(a1, v24, v27, v26)) {
        goto LABEL_16;
      }
      int32x2_t v32 = (_DWORD *)llvm::ScalarEvolution::getRangeRef(a1, v14, 1, 0);
      llvm::ConstantRange::getSignedMax(v32, (uint64_t)&v41);
      unsigned int v33 = v42 - 1;
      uint64_t v34 = v42 >= 0x41 ? (uint64_t *)(v41 + 8 * (v33 >> 6)) : &v41;
      uint64_t v35 = (1 << v33) & *v34;
      if (v42 >= 0x41 && v41) {
        MEMORY[0x1D25D9CB0]();
      }
      if (v35 && llvm::ScalarEvolution::isKnownPredicateViaConstantRanges(a1, v25, v27, v26)) {
        goto LABEL_16;
      }
LABEL_23:
      llvm::ConstantRange::ConstantRange((unint64_t *)a6, a4, 1);
      goto LABEL_17;
    }
    return llvm::ConstantRange::ConstantRange((unint64_t *)a6, a4, 1);
  }
}

uint64_t llvm::ScalarEvolution::getSmallConstantTripCount(llvm::ScalarEvolution *this, const llvm::Loop *a2)
{
  BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(this, a2);
  uint64_t Exact = llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)a2, (uint64_t)this);
  if (*(_WORD *)(Exact + 24)) {
    uint64_t Exact = 0;
  }

  return sub_1CC10ADDC(Exact);
}

unint64_t llvm::ScalarEvolution::getElementSize(llvm::ScalarEvolution *this, llvm::Instruction *a2)
{
  int v3 = *((unsigned __int8 *)a2 + 16);
  if (a2 && v3 == 61)
  {
    a2 = (llvm::Instruction *)*((void *)a2 - 8);
  }
  else if (!a2 || v3 != 60)
  {
    return 0;
  }
  uint64_t v4 = *(llvm::Type **)a2;
  unsigned int v5 = (llvm::Type *)llvm::PointerType::get(*(llvm::PointerType **)a2, 0);
  if (*((unsigned char *)v5 + 8) != 13)
  {
    llvm::DataLayout::getIndexType((llvm::DataLayout *)(*(void *)(*(void *)this + 40) + 272), v5);
    unsigned int v5 = v6;
  }

  return llvm::ScalarEvolution::getSizeOfExpr(this, v5, v4);
}

uint64_t llvm::ScalarEvolution::getPredicatedBackedgeTakenCount(llvm::ScalarEvolution *a1, const llvm::Loop *a2)
{
  PredicatedBackedgeTakenInfo = llvm::ScalarEvolution::getPredicatedBackedgeTakenInfo(a1, a2);

  return llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)PredicatedBackedgeTakenInfo, (uint64_t)a2, (uint64_t)a1);
}

void llvm::ScalarEvolution::forgetAllLoops(llvm::ScalarEvolution *this)
{
  sub_1CC10DF90((char **)this + 68);
  sub_1CC10DF90((char **)this + 71);
  sub_1CD4BEE74((unsigned int *)this + 148);
  sub_1CD3C7F68((_DWORD *)this + 178);
  sub_1CD3C7F68((_DWORD *)this + 154);
  sub_1CC10E0D0((void *)this + 13);
  sub_1CD4BEF34((_DWORD *)this + 160);
  sub_1CD4BEF34((_DWORD *)this + 166);
  sub_1CC10E410((_DWORD *)this + 172);
  sub_1CD4BEFF8((_DWORD *)this + 184);
  sub_1CD4BF0BC((_DWORD *)this + 196);
  sub_1CD4BF0BC((_DWORD *)this + 202);
  sub_1CC10E4DC((uint64_t)this + 80);
  sub_1CBB8977C((_DWORD *)this + 14);
  sub_1CD3C7F68((_DWORD *)this + 130);

  sub_1CD4BF174((_DWORD *)this + 246);
}

void sub_1CD4BEE74(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = *(void **)a1;
    uint64_t v5 = 72 * v3;
    while (1)
    {
      if (*v4 == -8192) {
        goto LABEL_10;
      }
      if (*v4 != -4096) {
        break;
      }
LABEL_11:
      v4 += 9;
      v5 -= 72;
      if (!v5) {
        goto LABEL_12;
      }
    }
    uint64_t v6 = (void *)v4[2];
    if (v6 != (void *)v4[1]) {
      free(v6);
    }
LABEL_10:
    *uint64_t v4 = -4096;
    goto LABEL_11;
  }

  sub_1CD4C1C7C(a1);
}

void sub_1CD4BEF34(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 56 * v3;
    uint64_t v5 = *(void *)a1 + 24;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 24);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 56;
      v4 -= 56;
      if (!v4) {
        goto LABEL_12;
      }
    }
    uint64_t v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(void *)(v5 - 24) = -4096;
    goto LABEL_11;
  }

  sub_1CD4C1D30(a1);
}

void sub_1CD4BEFF8(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 40 * v3;
    uint64_t v5 = *(void *)a1 + 24;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 24);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 40;
      v4 -= 40;
      if (!v4) {
        goto LABEL_12;
      }
    }
    uint64_t v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(void *)(v5 - 24) = -4096;
    goto LABEL_11;
  }

  sub_1CD4C1DE4(a1);
}

_DWORD *sub_1CD4BF0BC(_DWORD *result)
{
  uint64_t v1 = result;
  int v2 = result[2];
  if (!v2 && !result[3]) {
    return result;
  }
  uint64_t v3 = result[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      *((void *)v1 + 1) = 0;
      return result;
    }
    uint64_t v4 = 40 * v3;
    uint64_t result = (_DWORD *)(*(void *)result + 8);
    while (1)
    {
      uint64_t v5 = *((void *)result - 1);
      if (v5 == -8192) {
        goto LABEL_9;
      }
      if (v5 != -4096) {
        break;
      }
LABEL_10:
      result += 10;
      v4 -= 40;
      if (!v4) {
        goto LABEL_11;
      }
    }
    uint64_t result = (_DWORD *)sub_1CC05EB8C((uint64_t)result);
LABEL_9:
    *((void *)result - 1) = -4096;
    goto LABEL_10;
  }

  return sub_1CD4C1E98(result);
}

void sub_1CD4BF174(_DWORD *a1)
{
  int v2 = a1[2];
  if (v2 || a1[3])
  {
    uint64_t v3 = a1[4];
    if (v3 > 4 * v2 && v3 >= 0x41)
    {
      sub_1CD4C1F8C(a1);
    }
    else
    {
      if (v3)
      {
        uint64_t v4 = v3 << 6;
        uint64_t v5 = *(void *)a1 + 40;
        do
        {
          uint64_t v7 = *(void *)(v5 - 40);
          uint64_t v6 = *(void *)(v5 - 32);
          if (v7 != -4096 || v6 != -4096)
          {
            if (v7 != -8192 || v6 != -8192)
            {
              uint64_t v8 = *(void **)(v5 - 16);
              if ((void *)v5 != v8) {
                free(v8);
              }
            }
            *(void *)(v5 - 40) = -4096;
            *(void *)(v5 - 32) = -4096;
          }
          v5 += 64;
          v4 -= 64;
        }
        while (v4);
      }
      *((void *)a1 + 1) = 0;
    }
  }
}

uint64_t sub_1CD4BF244(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20);
  if ((v2 & 0x40000000) != 0) {
    uint64_t v3 = *(void *)(a1 - 8);
  }
  else {
    uint64_t v3 = a1 - 32 * (v2 & 0x7FFFFFF);
  }
  if (*(void *)(v3 + 32) == a2) {
    return 0;
  }
  int v4 = (v2 >> 1) & 0x3FFFFFF;
  uint64_t v5 = (v4 - 1);
  if (v4 == 1) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 2 * v5;
  do
  {
    uint64_t v9 = a1 - 32 * (v2 & 0x7FFFFFF);
    if ((v2 & 0x40000000) != 0) {
      uint64_t v9 = *(void *)(a1 - 8);
    }
    uint64_t v10 = (v6 + 3);
    if (v6 == 0x1FFFFFFFCLL) {
      uint64_t v10 = 1;
    }
    if (*(void *)(v9 + 32 * v10) == a2)
    {
      if (v7) {
        return 0;
      }
      uint64_t v11 = a1 - 32 * (v2 & 0x7FFFFFF);
      if ((v2 & 0x40000000) != 0) {
        uint64_t v11 = *(void *)(a1 - 8);
      }
      uint64_t v7 = *(void *)(v11 + 32 * ((v6 + 2) & 0xFFFFFFFE));
    }
    v6 += 2;
  }
  while (v8 != v6);
  return v7;
}

uint64_t llvm::ScalarEvolution::isKnownPredicateAt(llvm::ScalarEvolution *a1, uint64_t a2, const llvm::SCEV *a3, const llvm::SCEV *a4, uint64_t a5)
{
  if (llvm::ScalarEvolution::isKnownPredicate(a1, a2, a3, a4)) {
    return 1;
  }
  uint64_t v10 = *(llvm::BasicBlock **)(a5 + 40);

  return llvm::ScalarEvolution::isBasicBlockEntryGuardedByCond((uint64_t)a1, v10, a2, (uint64_t)a3, (uint64_t)a4);
}

uint64_t llvm::ScalarEvolution::getLoopInvariantExitCondDuringFirstIterations@<X0>(llvm::SCEV *a1@<X3>, llvm::Loop *a2@<X4>, llvm::ScalarEvolution *a3@<X0>, uint64_t a4@<X1>, const llvm::SCEV *a5@<X2>, uint64_t a6@<X5>, llvm::SCEV *a7@<X6>, uint64_t a8@<X8>)
{
  uint64_t v11 = a1;
  uint64_t result = llvm::ScalarEvolution::getLoopDisposition(a3, a1, a2);
  if (result == 1)
  {
    size_t v18 = v11;
    uint64_t v11 = a5;
  }
  else
  {
    uint64_t result = llvm::ScalarEvolution::getLoopDisposition(a3, a5, a2);
    if (result != 1) {
      goto LABEL_3;
    }
    uint64_t result = llvm::CmpInst::getSwappedPredicate(a4);
    a4 = result;
    size_t v18 = a5;
  }
  if (v11)
  {
    if (*((_WORD *)v11 + 12) == 7 && *((llvm::Loop **)v11 + 6) == a2)
    {
      uint64_t v28 = (uint64_t)v18;
      if ((a4 & 0xFFFFFFFE) != 0x20)
      {
        uint64_t v19 = (llvm::SCEV *)sub_1CBFD7EA0((uint64_t)v11, a3);
        Type = (llvm::Type *)llvm::SCEV::getType(v19);
        unint64_t Constant = llvm::ScalarEvolution::getConstant(a3, Type, 1uLL, 0);
        uint64_t result = llvm::ScalarEvolution::getNegativeSCEV(a3, Constant, 0);
        uint64_t v27 = result;
        if (v19 == (llvm::SCEV *)Constant || v19 == (llvm::SCEV *)result)
        {
          unint64_t v22 = (llvm::SCEV **)*((void *)v11 + 4);
          uint64_t v23 = llvm::SCEV::getType(*v22);
          uint64_t result = llvm::SCEV::getType(a7);
          if (v23 == result)
          {
            unsigned int v24 = (const llvm::SCEV *)llvm::SCEVAddRecExpr::evaluateAtIteration((uint64_t *)v22, *((void *)v11 + 5), a7, a3);
            uint64_t result = llvm::ScalarEvolution::isLoopBackedgeGuardedByCond((uint64_t)a3, (uint64_t)a2, a4, (uint64_t)v24, v28);
            if (result)
            {
              uint64_t SwappedPredicate = (a4 - 38) >= 4 ? 37 : 41;
              if (v19 == (llvm::SCEV *)v27) {
                uint64_t SwappedPredicate = llvm::CmpInst::getSwappedPredicate(SwappedPredicate);
              }
              uint64_t v26 = (const llvm::SCEV *)**((void **)v11 + 4);
              uint64_t result = llvm::ScalarEvolution::isKnownPredicate(a3, SwappedPredicate, v26, v24);
              if ((result & 1) != 0
                || (uint64_t result = llvm::ScalarEvolution::isBasicBlockEntryGuardedByCond((uint64_t)a3, *(llvm::BasicBlock **)(a6 + 40), SwappedPredicate, (uint64_t)v26, (uint64_t)v24), (result & 1) != 0))
              {
                *(_DWORD *)a8 = a4;
                char v17 = 1;
                *(void *)(a8 + 8) = v26;
                *(void *)(a8 + 16) = v28;
                goto LABEL_4;
              }
            }
          }
        }
      }
    }
  }
LABEL_3:
  char v17 = 0;
  *(unsigned char *)a8 = 0;
LABEL_4:
  *(unsigned char *)(a8 + 24) = v17;
  return result;
}

BOOL llvm::ScalarEvolution::canIVOverflowOnGT(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::SCEV *a3, int a4)
{
  Type = (llvm::Type *)llvm::SCEV::getType(a2);
  uint64_t TypeSizeInBits = llvm::ScalarEvolution::getTypeSizeInBits(this, Type);
  uint64_t v10 = (llvm::Type *)llvm::SCEV::getType(a3);
  unint64_t Constant = (const llvm::APInt *)llvm::ScalarEvolution::getConstant(this, v10, 1uLL, 0);
  if (a4)
  {
    uint64_t RangeRef = llvm::ScalarEvolution::getRangeRef(this, a2, 1, 0);
    llvm::ConstantRange::getSignedMin(RangeRef, (uint64_t)&v39);
    sub_1CBA62420(TypeSizeInBits, (llvm::APInt *)&v37);
    Minusuint64_t SCEV = llvm::ScalarEvolution::getMinusSCEV(this, a3, Constant, 0, 0);
    unint64_t v21 = (_DWORD *)llvm::ScalarEvolution::getRangeRef(this, MinusSCEV, 1, 0);
    llvm::ConstantRange::getSignedMax(v21, (uint64_t)&v35);
    unsigned int v32 = v38;
    uint64_t v31 = v37;
    unsigned int v38 = 0;
    llvm::APInt::operator+=((uint64_t)&v31, &v35);
    unsigned int v22 = v32;
    unsigned int v34 = v32;
    uint64_t v23 = v31;
    uint64_t v33 = v31;
    unsigned int v32 = 0;
    int v17 = llvm::APInt::compareSigned((llvm::APInt *)&v33, (const llvm::APInt *)&v39);
    if (v22 >= 0x41)
    {
      if (v23)
      {
        int v24 = v17;
        MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
        int v17 = v24;
        if (v32 >= 0x41)
        {
          uint64_t v25 = v31;
          if (v31) {
            goto LABEL_21;
          }
        }
      }
    }
  }
  else
  {
    uint64_t v12 = llvm::ScalarEvolution::getRangeRef(this, a2, 0, 0);
    llvm::ConstantRange::getUnsignedMin(v12, (uint64_t)&v39);
    sub_1CB8F1EEC((uint64_t)&v37, TypeSizeInBits, 0);
    unint64_t v13 = llvm::ScalarEvolution::getMinusSCEV(this, a3, Constant, 0, 0);
    uint64_t v14 = (char **)llvm::ScalarEvolution::getRangeRef(this, v13, 0, 0);
    llvm::ConstantRange::getUnsignedMax(v14, (uint64_t)&v35);
    unsigned int v30 = v38;
    uint64_t v29 = v37;
    unsigned int v38 = 0;
    llvm::APInt::operator+=((uint64_t)&v29, &v35);
    unsigned int v15 = v30;
    unsigned int v34 = v30;
    uint64_t v16 = v29;
    uint64_t v33 = v29;
    unsigned int v30 = 0;
    int v17 = llvm::APInt::compare((llvm::APInt *)&v33, (const llvm::APInt *)&v39);
    if (v15 >= 0x41)
    {
      if (v16)
      {
        int v24 = v17;
        MEMORY[0x1D25D9CB0](v16, 0x1000C8000313F17);
        int v17 = v24;
        if (v30 >= 0x41)
        {
          uint64_t v25 = v29;
          if (v29)
          {
LABEL_21:
            MEMORY[0x1D25D9CB0](v25, 0x1000C8000313F17);
            int v17 = v24;
          }
        }
      }
    }
  }
  if (v36 >= 0x41 && v35)
  {
    int v26 = v17;
    MEMORY[0x1D25D9CB0](v35, 0x1000C8000313F17);
    int v17 = v26;
  }
  if (v38 >= 0x41 && v37)
  {
    int v27 = v17;
    MEMORY[0x1D25D9CB0](v37, 0x1000C8000313F17);
    int v17 = v27;
  }
  if (v40 >= 0x41 && v39)
  {
    int v28 = v17;
    MEMORY[0x1D25D9CB0](v39, 0x1000C8000313F17);
    int v17 = v28;
  }
  return v17 > 0;
}

uint64_t llvm::ScalarEvolution::containsUndefs(llvm::ScalarEvolution *this, const llvm::SCEV *a2)
{
  v20[8] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v11 = 0;
  uint64_t v12 = &v11;
  unint64_t v13 = v15;
  uint64_t v14 = 0x800000000;
  uint64_t v16 = v20;
  int v17 = v20;
  uint64_t v18 = 8;
  int v19 = 0;
  sub_1CBFCF81C((uint64_t)&v12, (uint64_t)a2);
  unsigned int v2 = v14;
  while (v2)
  {
    if (*v12) {
      break;
    }
    uint64_t v3 = *((void *)v13 + --v2);
    LODWORD(v14) = v2;
    switch(*(_WORD *)(v3 + 24))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v9 = (uint64_t *)(v3 + 32);
        goto LABEL_13;
      case 4:
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        uint64_t v4 = *(void *)(v3 + 40);
        if (v4)
        {
          uint64_t v5 = *(uint64_t **)(v3 + 32);
          uint64_t v6 = 8 * v4 - 8;
          do
          {
            uint64_t v7 = *v5++;
            sub_1CBFCF81C((uint64_t)&v12, v7);
            if (*v12) {
              BOOL v8 = 1;
            }
            else {
              BOOL v8 = v6 == 0;
            }
            v6 -= 8;
          }
          while (!v8);
        }
        goto LABEL_14;
      case 6:
        sub_1CBFCF81C((uint64_t)&v12, *(void *)(v3 + 32));
        uint64_t v9 = (uint64_t *)(v3 + 40);
LABEL_13:
        sub_1CBFCF81C((uint64_t)&v12, *v9);
LABEL_14:
        unsigned int v2 = v14;
        break;
      default:
        break;
    }
  }
  if (v17 != v16) {
    free(v17);
  }
  if (v13 != v15) {
    free(v13);
  }
  return v11;
}

BOOL llvm::ScalarEvolution::hasLoopInvariantBackedgeTakenCount(llvm::ScalarEvolution *this, const llvm::Loop *a2)
{
  BackedgeTakenInfo = llvm::ScalarEvolution::getBackedgeTakenInfo(this, a2);
  return *(unsigned __int16 *)(llvm::ScalarEvolution::BackedgeTakenInfo::getExact((uint64_t)BackedgeTakenInfo, (uint64_t)a2, (uint64_t)this)+ 24) != 15;
}

llvm::raw_ostream *llvm::ScalarEvolution::print(llvm::Value **this, llvm::raw_ostream *a2)
{
  if (byte_1EBCC7EB8)
  {
    sub_1CB8E509C(a2, "Classifying expressions for: ");
    llvm::Value::printAsOperand(*this, a2, 0, 0);
    sub_1CB8E509C(a2, "\n");
    uint64_t v7 = (uint64_t)*this + 72;
    for (uint64_t i = *((void *)*this + 10); i != v7; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v9 = i - 24;
      if (!i) {
        uint64_t v9 = 0;
      }
      uint64_t v10 = *(void *)(v9 + 48);
      if (v10 != v9 + 40)
      {
        while (1)
        {
          if (v10) {
            unint64_t v11 = v10 - 24;
          }
          else {
            unint64_t v11 = 0;
          }
          if ((*(_DWORD *)(*(void *)v11 + 8) & 0xFD) == 0xD
            && *(unsigned __int8 *)(v11 + 16) - 81 >= 2)
          {
            llvm::Value::print((llvm::Value *)v11, a2, 0);
            unint64_t v21 = (unsigned char *)*((void *)a2 + 4);
            if ((unint64_t)v21 >= *((void *)a2 + 3))
            {
              llvm::raw_ostream::write(a2, 10);
            }
            else
            {
              *((void *)a2 + 4) = v21 + 1;
              *unint64_t v21 = 10;
            }
            sub_1CB8E509C(a2, "  -->  ");
            Existinguint64_t SCEV = (llvm::SCEV *)llvm::ScalarEvolution::getExistingSCEV((uint64_t)this, v11);
            if (!ExistingSCEV) {
              Existinguint64_t SCEV = (llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)this, v11);
            }
            llvm::SCEV::print(ExistingSCEV, a2);
            if (*((_WORD *)ExistingSCEV + 12) != 15)
            {
              sub_1CB8E509C(a2, " U: ");
              uint64_t RangeRef = llvm::ScalarEvolution::getRangeRef((uint64_t)this, (uint64_t)ExistingSCEV, 0, 0);
              sub_1CC067C7C((uint64_t)&v58, RangeRef);
              llvm::ConstantRange::print((llvm::ConstantRange *)&v58, a2);
              sub_1CC05EB8C((uint64_t)&v58);
              sub_1CB8E509C(a2, " S: ");
              uint64_t v24 = llvm::ScalarEvolution::getRangeRef((uint64_t)this, (uint64_t)ExistingSCEV, 1, 0);
              sub_1CC067C7C((uint64_t)&v58, v24);
              llvm::ConstantRange::print((llvm::ConstantRange *)&v58, a2);
              sub_1CC05EB8C((uint64_t)&v58);
            }
            uint64_t v25 = (uint64_t *)this[5];
            uint64_t v58 = *(void **)(v11 + 40);
            BOOL v52 = 0;
            int v26 = 0;
            if (sub_1CB834D78(v25, &v58, &v52)) {
              int v26 = (const llvm::Loop *)v52[1];
            }
            SCEVAtScope = llvm::ScalarEvolution::getSCEVAtScope((llvm::ScalarEvolution *)this, ExistingSCEV, v26);
            if (SCEVAtScope != ExistingSCEV)
            {
              unsigned int v36 = SCEVAtScope;
              sub_1CB8E509C(a2, "  -->  ");
              llvm::SCEV::print(v36, a2);
              if (*((_WORD *)v36 + 12) != 15)
              {
                sub_1CB8E509C(a2, " U: ");
                uint64_t v37 = llvm::ScalarEvolution::getRangeRef((uint64_t)this, (uint64_t)v36, 0, 0);
                sub_1CC067C7C((uint64_t)&v58, v37);
                llvm::ConstantRange::print((llvm::ConstantRange *)&v58, a2);
                sub_1CC05EB8C((uint64_t)&v58);
                sub_1CB8E509C(a2, " S: ");
                uint64_t v38 = llvm::ScalarEvolution::getRangeRef((uint64_t)this, (uint64_t)v36, 1, 0);
                sub_1CC067C7C((uint64_t)&v58, v38);
                llvm::ConstantRange::print((llvm::ConstantRange *)&v58, a2);
                sub_1CC05EB8C((uint64_t)&v58);
              }
            }
            if (v26)
            {
              int v19 = (llvm::Value ***)v26;
              sub_1CB8E509C(a2, "\t\tExits: ");
              uint64_t v39 = llvm::ScalarEvolution::getSCEVAtScope((llvm::ScalarEvolution *)this, ExistingSCEV, *(const llvm::Loop **)v26);
              if (llvm::ScalarEvolution::getLoopDisposition((llvm::ScalarEvolution *)this, v39, (const llvm::Loop *)v19) == 1)llvm::SCEV::print(v39, a2); {
              else
              }
                sub_1CB8E509C(a2, "<<Unknown>>");
              uint64_t v45 = (uint64_t)v19;
              unint64_t v20 = "\t\tLoopDispositions: { ";
              do
              {
                sub_1CB8E509C(a2, v20);
                llvm::Value::printAsOperand(*v19[4], a2, 0, 0);
                uint64_t v14 = sub_1CB8E509C(a2, ": ");
                unsigned int LoopDisposition = llvm::ScalarEvolution::getLoopDisposition((llvm::ScalarEvolution *)this, ExistingSCEV, (const llvm::Loop *)v19);
                size_t v16 = qword_1CFAC44B0[LoopDisposition];
                int v17 = off_1E682C898[LoopDisposition];
                uint64_t v18 = (void *)*((void *)v14 + 4);
                if (v16 <= *((void *)v14 + 3) - (void)v18)
                {
                  memcpy(v18, v17, v16);
                  *((void *)v14 + 4) += v16;
                }
                else
                {
                  llvm::raw_ostream::write(v14, v17, v16);
                }
                int v19 = (llvm::Value ***)*v19;
                unint64_t v20 = ", ";
              }
              while (v19);
              uint64_t v35 = v45;
              sub_1CD4C01BC(&v58, v45);
              llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v52, &v54, (const llvm::SmallPtrSetImplBase *)&v58);
              std::string __p = 0;
              std::string::size_type v56 = 0;
              uint64_t v57 = 0;
              sub_1CBF340A8(&__p, v60, v61, 0xAAAAAAAAAAAAAAABLL * ((v61 - (unsigned char *)v60) >> 3));
              llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v46, &v48, (const llvm::SmallPtrSetImplBase *)&v62);
              unint64_t v49 = 0;
              uint64_t v50 = 0;
              uint64_t v51 = 0;
              sub_1CBF340A8(&v49, v64, v65, 0xAAAAAAAAAAAAAAABLL * ((v65 - (unsigned char *)v64) >> 3));
              while (1)
              {
                if (v56 - (unsigned char *)__p == v50 - v49)
                {
                  if (__p == v56)
                  {
LABEL_63:
                    if (v49)
                    {
                      uint64_t v50 = v49;
                      operator delete(v49);
                    }
                    if (v47 != v46) {
                      free(v47);
                    }
                    if (__p)
                    {
                      std::string::size_type v56 = (char *)__p;
                      operator delete(__p);
                    }
                    if (v53 != v52) {
                      free(v53);
                    }
                    if (v64)
                    {
                      std::string v65 = v64;
                      operator delete(v64);
                    }
                    if (v63 != v62) {
                      free(v63);
                    }
                    if (v60)
                    {
                      unint64_t v61 = v60;
                      operator delete(v60);
                    }
                    if (v59 != v58) {
                      free(v59);
                    }
                    sub_1CB8E509C(a2, " }");
                    break;
                  }
                  int v28 = v49 + 8;
                  uint64_t v29 = (char *)__p + 8;
                  while (1)
                  {
                    unsigned int v30 = v29 - 8;
                    if (*((void *)v29 - 1) != *((void *)v28 - 1)) {
                      break;
                    }
                    int v31 = v28[8];
                    if (v29[8]) {
                      BOOL v32 = v31 == 0;
                    }
                    else {
                      BOOL v32 = 1;
                    }
                    if (v32)
                    {
                      if ((v29[8] == 0) == (v31 != 0)) {
                        break;
                      }
                    }
                    else if (*(void *)v29 != *(void *)v28)
                    {
                      break;
                    }
                    v28 += 24;
                    v29 += 24;
                    if (v30 + 24 == v56) {
                      goto LABEL_63;
                    }
                  }
                }
                uint64_t v33 = (llvm::Value ***)v35;
                unsigned int v34 = (llvm::Value ***)*((void *)v56 - 3);
                if (v34 != v33)
                {
                  sub_1CB8E509C(a2, ", ");
                  llvm::Value::printAsOperand(*v34[4], a2, 0, 0);
                  unsigned int v40 = sub_1CB8E509C(a2, ": ");
                  unsigned int v41 = llvm::ScalarEvolution::getLoopDisposition((llvm::ScalarEvolution *)this, ExistingSCEV, (const llvm::Loop *)v34);
                  size_t v42 = qword_1CFAC44B0[v41];
                  uint64_t v43 = off_1E682C898[v41];
                  std::string::size_type v44 = (void *)*((void *)v40 + 4);
                  if (v42 <= *((void *)v40 + 3) - (void)v44)
                  {
                    memcpy(v44, v43, v42);
                    *((void *)v40 + 4) += v42;
                  }
                  else
                  {
                    llvm::raw_ostream::write(v40, v43, v42);
                  }
                }
                sub_1CD4C2580((char *)&v52);
                uint64_t v35 = v45;
              }
            }
            sub_1CB8E509C(a2, "\n");
          }
          uint64_t v10 = *(void *)(v10 + 8);
          uint64_t v12 = i - 24;
          if (!i) {
            uint64_t v12 = 0;
          }
          if (v10 == v12 + 40) {
            break;
          }
LABEL_19:
          if (i == v7) {
            goto LABEL_2;
          }
        }
        while (1)
        {
          uint64_t i = *(void *)(i + 8);
          if (i == v7) {
            goto LABEL_2;
          }
          uint64_t v13 = i - 24;
          if (!i) {
            uint64_t v13 = 0;
          }
          uint64_t v10 = *(void *)(v13 + 48);
          if (v10 != v13 + 40) {
            goto LABEL_19;
          }
        }
      }
    }
  }
LABEL_2:
  sub_1CB8E509C(a2, "Determining loop execution counts for: ");
  llvm::Value::printAsOperand(*this, a2, 0, 0);
  uint64_t result = sub_1CB8E509C(a2, "\n");
  uint64_t v5 = this[5];
  uint64_t v6 = (uint64_t *)*((void *)v5 + 3);
  if (v6 != *((uint64_t **)v5 + 4)) {
    sub_1CC128B64(a2, (uint64_t)this, *v6);
  }
  return result;
}

void sub_1CD4C01BC(void *a1, uint64_t a2)
{
  sub_1CD4737AC((uint64_t)&v11, a2);
  uint64_t v7 = 0;
  std::string __p = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v3 = (char *)v6 + 8;
  uint64_t v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_1CD4C2404(a1, (uint64_t)&v11, (uint64_t)&v3);
  if (__p)
  {
    uint64_t v9 = __p;
    operator delete(__p);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v13)
  {
    uint64_t v14 = v13;
    operator delete(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
}

void sub_1CD4C0270()
{
}

void llvm::ScalarEvolutionVerifierPass::run()
{
}

void llvm::ScalarEvolutionPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "Printing analysis 'Scalar Evolution Analysis' for function '");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  uint64_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "':\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

void llvm::initializeScalarEvolutionWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC7230, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC12DC58;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC7230, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::ScalarEvolutionWrapperPass *llvm::ScalarEvolutionWrapperPass::ScalarEvolutionWrapperPass(llvm::ScalarEvolutionWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::ScalarEvolutionWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F2607450;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC7230, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC12DC58;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCC7230, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::raw_ostream *llvm::ScalarEvolutionWrapperPass::print(llvm::Value ***this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  return llvm::ScalarEvolution::print(this[4], a2);
}

uint64_t llvm::ScalarEvolutionWrapperPass::verifyAnalysis(uint64_t this)
{
  if (llvm::VerifySCEV) {
    llvm::ScalarEvolution::verify(*(llvm::ScalarEvolution **)(this + 32));
  }
  return this;
}

llvm::AnalysisUsage *llvm::ScalarEvolutionWrapperPass::getAnalysisUsage(llvm::ScalarEvolutionWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::AssumptionCacheTracker::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::LoopInfoWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::DominatorTreeWrapperPass::ID);

  return llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::TargetLibraryInfoWrapperPass::ID);
}

uint64_t llvm::ScalarEvolution::getEqualPredicate(llvm::ScalarEvolution *this, const llvm::SCEV *a2, const llvm::SCEV *a3)
{
  return llvm::ScalarEvolution::getComparePredicate((uint64_t)this, 32, (uint64_t)a2, (uint64_t)a3);
}

uint64_t llvm::ScalarEvolution::getComparePredicate(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  v16[0] = v17;
  v17[0] = 1;
  v17[1] = a2;
  v16[1] = (void *)0x2000000002;
  sub_1CC1312F4((uint64_t)v16, a3);
  sub_1CC1312F4((uint64_t)v16, a4);
  uint64_t v15 = 0;
  uint64_t v8 = a1 + 848;
  NodeOrInsertPos = llvm::FoldingSetBase::FindNodeOrInsertPos(a1 + 848, (uint64_t)v16, &v15, (uint64_t)off_1F26076B8);
  if (NodeOrInsertPos)
  {
    uint64_t v11 = (uint64_t)(NodeOrInsertPos - 1);
  }
  else
  {
    uint64_t v10 = (uint64_t *)(a1 + 864);
    uint64_t v11 = sub_1CB906F34((uint64_t *)(a1 + 864), 56, 3);
    uint64_t v12 = llvm::FoldingSetNodeID::Intern((uint64_t)v16, v10);
    *(void *)(v11 + 8) = 0;
    *(void *)(v11 + 16) = v12;
    *(void *)(v11 + 24) = v13;
    *(_DWORD *)(v11 + 32) = 1;
    *(_DWORD *)(v11 + 36) = a2;
    *(void *)uint64_t v11 = &unk_1F2607520;
    *(void *)(v11 + 40) = a3;
    *(void *)(v11 + 48) = a4;
    llvm::FoldingSetBase::InsertNode(v8, (uint64_t *)(v11 + 8), v15, (uint64_t)off_1F26076B8);
  }
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v11;
}

BOOL llvm::SCEVComparePredicate::implies(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  if (a2 && *(_DWORD *)(a2 + 32) == 1) {
    return *(_DWORD *)(a1 + 36) == 32
  }
        && *(void *)(a2 + 40) == *(void *)(a1 + 40)
        && *(void *)(a2 + 48) == *(void *)(a1 + 48);
  return v2;
}

uint64_t llvm::SCEVComparePredicate::isAlwaysTrue(llvm::SCEVComparePredicate *this)
{
  return 0;
}

llvm::raw_ostream *llvm::SCEVComparePredicate::print(llvm::SCEVComparePredicate *this, llvm::raw_ostream *a2, unsigned int a3)
{
  int v5 = *((_DWORD *)this + 9);
  llvm::raw_ostream::indent(a2, a3);
  if (v5 == 32)
  {
    size_t v6 = sub_1CB8E509C(a2, "Equal predicate: ");
    llvm::SCEV::print(*((llvm::SCEV **)this + 5), v6);
    uint64_t v7 = " == ";
  }
  else
  {
    uint64_t v8 = sub_1CB8E509C(a2, "Compare predicate: ");
    llvm::SCEV::print(*((llvm::SCEV **)this + 5), v8);
    size_t v6 = sub_1CB8E509C(v8, " ");
    PredicateName = llvm::CmpInst::getPredicateName(*((_DWORD *)this + 9));
    size_t v11 = v9;
    uint64_t v12 = (void *)*((void *)v6 + 4);
    if (v9 <= *((void *)v6 + 3) - (void)v12)
    {
      if (v9)
      {
        memcpy(v12, PredicateName, v9);
        *((void *)v6 + 4) += v11;
      }
    }
    else
    {
      llvm::raw_ostream::write(v6, PredicateName, v9);
    }
    uint64_t v7 = ") ";
  }
  uint64_t v13 = sub_1CB8E509C(v6, v7);
  llvm::SCEV::print(*((llvm::SCEV **)this + 6), v13);

  return sub_1CB8E509C(v13, "\n");
}

uint64_t llvm::SCEVWrapPredicate::getExpr(llvm::SCEVWrapPredicate *this)
{
  return *((void *)this + 5);
}

BOOL llvm::SCEVWrapPredicate::implies(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a2 && *(_DWORD *)(a2 + 32) == 2) {
    return *(void *)(a2 + 40) == *(void *)(a1 + 40)
  }
        && (*(_DWORD *)(a2 + 48) | *(_DWORD *)(a1 + 48)) == *(_DWORD *)(a1 + 48);
  return result;
}

BOOL llvm::SCEVWrapPredicate::isAlwaysTrue(llvm::SCEVWrapPredicate *this)
{
  int v1 = *(_WORD *)(*((void *)this + 5) + 28) & 7;
  if ((v1 | 4) == v1) {
    unsigned int v2 = *((_DWORD *)this + 12) & 0xFFFFFFFD;
  }
  else {
    unsigned int v2 = *((_DWORD *)this + 12);
  }
  return v2 == 0;
}

llvm::raw_ostream *llvm::SCEVWrapPredicate::print(llvm::SCEV **this, llvm::raw_ostream *a2, unsigned int a3)
{
  llvm::raw_ostream::indent(a2, a3);
  llvm::SCEV::print(this[5], a2);
  sub_1CB8E509C(a2, " Added Flags: ");
  int v5 = *((_DWORD *)this + 12);
  if (v5)
  {
    sub_1CB8E509C(a2, "<nusw>");
    int v5 = *((_DWORD *)this + 12);
  }
  if ((v5 & 2) != 0) {
    sub_1CB8E509C(a2, "<nssw>");
  }

  return sub_1CB8E509C(a2, "\n");
}

uint64_t llvm::SCEVUnionPredicate::isAlwaysTrue(llvm::SCEVUnionPredicate *this)
{
  uint64_t v1 = *((unsigned int *)this + 12);
  if (!v1) {
    return 1;
  }
  uint64_t v3 = (uint64_t *)*((void *)this + 5);
  uint64_t v4 = 8 * v1 - 8;
  do
  {
    uint64_t v5 = *v3++;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8))(v5);
    if (result) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    v4 -= 8;
  }
  while (!v6);
  return result;
}

uint64_t llvm::SCEVUnionPredicate::print(uint64_t this, llvm::raw_ostream *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(this + 48);
  if (v3)
  {
    BOOL v6 = *(uint64_t **)(this + 40);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6++;
      this = (*(uint64_t (**)(uint64_t, llvm::raw_ostream *, uint64_t))(*(void *)v8 + 24))(v8, a2, a3);
      v7 -= 8;
    }
    while (v7);
  }
  return this;
}

uint64_t llvm::PredicatedScalarEvolution::updateGeneration(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 112);
  *(_DWORD *)(this + 112) = v1 + 1;
  if (v1 == -1)
  {
    uint64_t v2 = *(void *)this;
    uint64_t v9 = this;
    uint64_t v3 = *(unsigned int *)(this + 16);
    uint64_t v4 = *(void *)this + 24 * v3;
    if (*(_DWORD *)(this + 8))
    {
      if (v3)
      {
        uint64_t v5 = 24 * v3;
        uint64_t v6 = *(void *)this;
        while ((*(void *)v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v6 += 24;
          v5 -= 24;
          if (!v5) {
            goto LABEL_8;
          }
        }
      }
      else
      {
        uint64_t v6 = *(void *)this;
      }
    }
    else
    {
LABEL_8:
      uint64_t v6 = v2 + 24 * v3;
    }
    uint64_t v7 = v2 + 24 * v3;
LABEL_10:
    while (v6 != v7)
    {
      this = llvm::ScalarEvolution::rewriteUsingPredicate(*(void *)(v9 + 88), *(void *)(v6 + 16), *(void *)(v9 + 96), *(void *)(v9 + 104));
      *(_DWORD *)(v6 + 8) = *(_DWORD *)(v9 + 112);
      *(void *)(v6 + 16) = this;
      uint64_t v8 = v6 + 24;
      uint64_t v6 = v4;
      if (v8 != v4)
      {
        uint64_t v6 = v8;
        while ((*(void *)v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v6 += 24;
          if (v6 == v4)
          {
            uint64_t v6 = v4;
            goto LABEL_10;
          }
        }
      }
    }
  }
  return this;
}

uint64_t llvm::PredicatedScalarEvolution::getPredicate(llvm::PredicatedScalarEvolution *this)
{
  return *((void *)this + 13);
}

void llvm::PredicatedScalarEvolution::setNoOverflow(uint64_t a1, llvm::Value *a2, int a3)
{
  uint64_t SCEV = (llvm::SCEVWrapPredicate *)llvm::PredicatedScalarEvolution::getSCEV((int8x16_t *)a1, a2);
  unsigned int v8 = a3 & ~llvm::SCEVWrapPredicate::getImpliedFlags(SCEV, *(const llvm::SCEVAddRecExpr **)(a1 + 88), v7);
  Wrapuint64_t Predicate = llvm::ScalarEvolution::getWrapPredicate(*(void *)(a1 + 88), (uint64_t)SCEV, v8);
  llvm::PredicatedScalarEvolution::addPredicate(a1, WrapPredicate);
  uint64_t v10 = a2;
  unsigned int v11 = v8;
  sub_1CD49F8F0(a1 + 24, (uint64_t *)&v10, (uint64_t)&v12);
  if (!v13) {
    *(_DWORD *)(v12 + 40) |= v8;
  }
}

void sub_1CD4C0C8C(llvm::Pass *a1)
{
  sub_1CD4C117C(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4C0CC4()
{
  return 1;
}

uint64_t sub_1CD4C0CCC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t sub_1CD4C0CD4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v11 = 0;
      uint64_t result = sub_1CC133950(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *unsigned int v11 = *(void *)a2;
      *((_DWORD *)v10 + 4) = *(_DWORD *)(a2 + 16);
      v10[1] = *(void *)(a2 + 8);
      *(_DWORD *)(a2 + 16) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1CD4C0D94(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *(unsigned int *)(a2 + 8);
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if (v4 >= v3)
    {
      if (v3) {
        memmove(*(void **)a1, *(const void **)a2, 8 * v3);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v3)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4)
      {
        uint64_t v8 = *(unsigned int *)(a1 + 8);
        uint64_t v9 = a2;
        memmove(*(void **)a1, *(const void **)a2, 8 * v4);
        uint64_t v5 = v8;
        a2 = v9;
      }
      else
      {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 8 * v5), (const void *)(*(void *)a2 + 8 * v5), *(void *)a2 + 8 * v6 - (*(void *)a2 + 8 * v5));
      }
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
  return a1;
}

uint64_t sub_1CD4C0E78(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v5 = a2;
    uint64_t v4 = *(void **)(a1 + 8);
    if (v4 != (void *)(a1 + 24)) {
      free(v4);
    }
    *(unsigned char *)(a1 + 48) = 0;
    a2 = v5;
  }
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = a1 + 24;
  uint64_t result = a1 + 8;
  *(void *)(a1 + 16) = 0x300000000;
  if (*(_DWORD *)(a2 + 16)) {
    uint64_t result = sub_1CC1340B4(result, a2 + 8);
  }
  *(unsigned char *)(a1 + 48) = 1;
  return result;
}

uint64_t sub_1CD4C0F04(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 56) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 48);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 40) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 24) >= 0x41u)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4) {
      MEMORY[0x1D25D9CB0](v4, 0x1000C8000313F17);
    }
  }
  if (*(_DWORD *)(a1 + 8) >= 0x41u && *(void *)a1) {
    MEMORY[0x1D25D9CB0](*(void *)a1, 0x1000C8000313F17);
  }
  return a1;
}

uint64_t sub_1CD4C0FC8(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(unsigned char *)(result + 16))
  {
    if (*(_DWORD *)(result + 8) >= 0x41u)
    {
      uint64_t result = *(void *)result;
      if (*(void *)v3) {
        uint64_t result = MEMORY[0x1D25D9CB0]();
      }
    }
    *(unsigned char *)(v3 + 16) = 0;
  }
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)uint64_t v3 = *(void *)a2;
  *(_DWORD *)(a2 + 8) = 0;
  *(unsigned char *)(v3 + 16) = 1;
  return result;
}

uint64_t sub_1CD4C103C(uint64_t this, llvm::APInt *a2)
{
  uint64_t v3 = this;
  if (*(unsigned char *)(this + 16))
  {
    if (*(_DWORD *)(this + 8) >= 0x41u)
    {
      this = *(void *)this;
      if (*(void *)v3) {
        this = MEMORY[0x1D25D9CB0]();
      }
    }
    *(unsigned char *)(v3 + 16) = 0;
  }
  unsigned int v4 = *((_DWORD *)a2 + 2);
  *(_DWORD *)(v3 + 8) = v4;
  if (v4 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)v3, a2);
  }
  *(void *)uint64_t v3 = *(void *)a2;
  *(unsigned char *)(v3 + 16) = 1;
  return this;
}

BOOL sub_1CD4C10C4(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 16);
  if (*(unsigned char *)(a1 + 16)) {
    BOOL v3 = v2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return (*(unsigned char *)(a1 + 16) == 0) ^ (v2 != 0);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 > 0x40) {
    return memcmp(*(const void **)a1, *(const void **)a2, ((unint64_t)(v5 + 63) >> 3) & 0x3FFFFFF8) == 0;
  }
  else {
    return *(void *)a1 == *(void *)a2;
  }
}

void llvm::callDefaultCtor<llvm::ScalarEvolutionWrapperPass>()
{
}

void sub_1CD4C117C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2607450;
  int v1 = (llvm::ScalarEvolution *)*((void *)a1 + 4);
  *((void *)a1 + 4) = 0;
  if (v1)
  {
    int v2 = a1;
    llvm::ScalarEvolution::~ScalarEvolution(v1);
    MEMORY[0x1D25D9CE0]();
    a1 = v2;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CD4C1200(_WORD *a1, _WORD *a2, __n128 *a3, int **a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC7238, 0, 0);
  dword_1EBCC72B8 = 0;
  qword_1EBCC72C0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC72C8 = 0;
  qword_1EBCC7238 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC72D0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC72D8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC72F0 = (uint64_t)&qword_1EBCC72D8;
  sub_1CD4C1300(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC7238);
}

__n128 sub_1CD4C1300(_WORD *a1, _WORD *a2, __n128 *a3, int **a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC7238, "scalar-evolution-max-iterations", 0x1FuLL);
  word_1EBCC7242 = word_1EBCC7242 & 0xFF9F | (32 * (*a1 & 3));
  word_1EBCC7242 = word_1EBCC7242 & 0xFFF8 | *a2 & 7;
  __n128 result = *a3;
  xmmword_1EBCC7258 = (__int128)*a3;
  dword_1EBCC72B8 = **a4;
  byte_1EBCC72CC = 1;
  dword_1EBCC72C8 = dword_1EBCC72B8;
  return result;
}

void sub_1CD4C1394(_WORD *a1, unsigned char **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC72F8, 0, 0);
  byte_1EBCC7389 = 0;
  qword_1EBCC7378 = 0;
  unk_1EBCC7380 = &unk_1F25EDE58;
  qword_1EBCC72F8 = (uint64_t)&unk_1F2605290;
  qword_1EBCC7390 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC7398 = (uint64_t)&unk_1F26052F8;
  qword_1EBCC73B0 = (uint64_t)&qword_1EBCC7398;
  sub_1CD4C1484(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC72F8);
}

__n128 sub_1CD4C1484(_WORD *a1, unsigned char **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC72F8, "verify-scev", 0xBuLL);
  word_1EBCC7302 = (32 * (*a1 & 3)) | word_1EBCC7302 & 0xFF9F;
  sub_1CC08D588((llvm *)&qword_1EBCC7378, &qword_1EBCC72F8, *a2);
  __n128 result = *a3;
  xmmword_1EBCC7318 = (__int128)*a3;
  return result;
}

uint64_t sub_1CD4C1500(uint64_t a1, char *a2, _WORD *a3, _OWORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(unsigned char *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = &unk_1F25EDE58;
  *(void *)(v8 + 144) = 0;
  *(void *)uint64_t v8 = &unk_1F26440A0;
  *(void *)(v8 + 152) = &unk_1F2643CC0;
  *(void *)(v8 + 160) = &unk_1F25EDE78;
  *(void *)(v8 + 184) = v8 + 160;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CD4C1608(_WORD *a1, long long *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCC7838, 0, 0);
  dword_1EBCC78B8 = 0;
  qword_1EBCC78C0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC78C8 = 0;
  qword_1EBCC7838 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC78D0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC78D8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC78F0 = (uint64_t)&qword_1EBCC78D8;
  llvm::cl::Option::setArgStr(v6, "scalar-evolution-max-scev-operations-implication-depth", 0x36uLL);
  word_1EBCC7842 = (32 * (*a1 & 3)) | word_1EBCC7842 & 0xFF9F;
  xmmword_1EBCC7858 = *a2;
  dword_1EBCC78B8 = **a3;
  byte_1EBCC78CC = 1;
  dword_1EBCC78C8 = dword_1EBCC78B8;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC7838);
}

void sub_1CD4C1730(_WORD *a1, long long *a2, int **a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCC7A78, 0, 0);
  dword_1EBCC7AF8 = 0;
  qword_1EBCC7B00 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC7B08 = 0;
  qword_1EBCC7A78 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC7B10 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC7B18 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC7B30 = (uint64_t)&qword_1EBCC7B18;
  llvm::cl::Option::setArgStr(v6, "scalar-evolution-max-constant-evolving-depth", 0x2CuLL);
  word_1EBCC7A82 = (32 * (*a1 & 3)) | word_1EBCC7A82 & 0xFF9F;
  xmmword_1EBCC7A98 = *a2;
  dword_1EBCC7AF8 = **a3;
  byte_1EBCC7B0C = 1;
  dword_1EBCC7B08 = dword_1EBCC7AF8;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC7A78);
}

void sub_1CD4C1858(_WORD *a1, char **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC7EF8, 0, 0);
  byte_1EBCC7F78 = 0;
  qword_1EBCC7F80 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC7F88 = 0;
  qword_1EBCC7EF8 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC7F90 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC7F98 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC7FB0 = (uint64_t)&qword_1EBCC7F98;
  sub_1CD4C1948(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC7EF8);
}

__n128 sub_1CD4C1948(_WORD *a1, char **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC7EF8, "scalar-evolution-use-expensive-range-sharpening", 0x2FuLL);
  word_1EBCC7F02 = (32 * (*a1 & 3)) | word_1EBCC7F02 & 0xFF9F;
  uint64_t v6 = *a2;
  byte_1EBCC7F78 = **a2;
  byte_1EBCC7F89 = 1;
  byte_1EBCC7F88 = *v6;
  __n128 result = *a3;
  xmmword_1EBCC7F18 = (__int128)*a3;
  return result;
}

void sub_1CD4C19D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void sub_1CD4C19D8(unsigned char *__src, uint64_t a2, uint64_t a3)
{
  v5[16] = *MEMORY[0x1E4F143B8];
  v4[0] = v5;
  v4[1] = (void *)0x2000000000;
  sub_1CB925718((unsigned int *)v4, __src, &__src[4 * a2]);
  sub_1CC0778D4(a3, (uint64_t)v4);
  if (v4[0] != v5) {
    free(v4[0]);
  }
}

void sub_1CD4C1A74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(int64x2_t **)a1;
    uint64_t v8 = v6 << 6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      *uint64_t v7 = v9;
      v7 += 4;
      v8 -= 64;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *(void *)v4;
      uint64_t v11 = *(void *)(v4 + 8);
      if ((*(void *)v4 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
      {
        int v17 = 0;
        sub_1CC13C5D8(*(void *)a1, *(_DWORD *)(a1 + 16), v10, v11, &v17);
        uint64_t v12 = v17;
        char v13 = v17;
        void *v17 = *(void *)v4;
        long long v14 = *(_OWORD *)(v4 + 8);
        void v12[3] = v13 + 5;
        uint64_t v15 = (uint64_t)(v12 + 3);
        *(_OWORD *)(v15 - 16) = v14;
        *(void *)(v15 + 8) = 0x300000000;
        if (*(_DWORD *)(v4 + 32)) {
          sub_1CC1340B4(v15, v4 + 24);
        }
        ++*(_DWORD *)(a1 + 8);
        size_t v16 = *(void **)(v4 + 24);
        if ((void *)(v4 + 40) != v16) {
          free(v16);
        }
      }
      v4 += 64;
    }
    while (v4 != a3);
  }
}

char **sub_1CD4C1B88(char **result)
{
  int v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  if (v2)
  {
    uint64_t v4 = 144 * v2;
    __n128 result = (char **)(*result + 8);
    do
    {
      if (((unint64_t)*(result - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        __n128 result = sub_1CC136BDC(result);
      }
      result += 18;
      v4 -= 144;
    }
    while (v4);
  }
  int v5 = 1 << (33 - __clz(v3 - 1));
  if (v5 <= 64) {
    int v5 = 64;
  }
  if (v3) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6 == *((_DWORD *)v1 + 4))
  {
    v1[1] = 0;
    if (v6)
    {
      uint64_t v7 = *v1;
      uint64_t v8 = 144 * v6;
      do
      {
        *(void *)uint64_t v7 = -4096;
        v7 += 144;
        v8 -= 144;
      }
      while (v8);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v1, 8);
    return (char **)sub_1CC13D104(v1, v6);
  }
  return result;
}

void sub_1CD4C1C7C(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CC13D1A0(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      int v5 = *(void **)a1;
      uint64_t v6 = 72 * v4;
      do
      {
        *int v5 = -4096;
        v5 += 9;
        v6 -= 72;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC13D214(a1, v4);
  }
}

void sub_1CD4C1D30(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC13D488((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      int v5 = *(void **)a1;
      uint64_t v6 = 56 * v4;
      do
      {
        *int v5 = -4096;
        v5 += 7;
        v6 -= 56;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CBF7A0E8(a1, v4);
  }
}

void sub_1CD4C1DE4(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC13D5A8((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      int v5 = *(void **)a1;
      uint64_t v6 = 40 * v4;
      do
      {
        *int v5 = -4096;
        v5 += 5;
        v6 -= 40;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CBAEFC5C(a1, v4);
  }
}

_DWORD *sub_1CD4C1E98(_DWORD *result)
{
  int v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  if (v2)
  {
    uint64_t v4 = 40 * v2;
    __n128 result = (_DWORD *)(*(void *)result + 8);
    do
    {
      if ((*((void *)result - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        __n128 result = (_DWORD *)sub_1CC05EB8C((uint64_t)result);
      }
      result += 10;
      v4 -= 40;
    }
    while (v4);
  }
  int v5 = 1 << (33 - __clz(v3 - 1));
  if (v5 <= 64) {
    int v5 = 64;
  }
  if (v3) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6 == *((_DWORD *)v1 + 4))
  {
    v1[1] = 0;
    if (v6)
    {
      uint64_t v7 = (void *)*v1;
      uint64_t v8 = 40 * v6;
      do
      {
        *uint64_t v7 = -4096;
        v7 += 5;
        v8 -= 40;
      }
      while (v8);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v1, 8);
    return sub_1CBAEFC5C(v1, v6);
  }
  return result;
}

void sub_1CD4C1F8C(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC13D698((uint64_t)a1);
  if (v2)
  {
    int v3 = 1 << (33 - __clz(v2 - 1));
    if (v3 <= 64) {
      unsigned int v4 = 64;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v4 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      int v5 = *(int64x2_t **)a1;
      unint64_t v6 = (unint64_t)v4 << 6;
      int64x2_t v7 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *int v5 = v7;
        v5 += 4;
        v6 -= 64;
      }
      while (v6);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v4 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CC13D728(a1, v4);
}

void sub_1CD4C204C()
{
}

void sub_1CD4C2110(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a1 + 96 * v2;
    uint64_t v6 = a2 + 32;
    int64x2_t v7 = (uint64_t *)(v4 + 32);
    do
    {
      *(void *)(v6 - 32) = *(v7 - 4);
      long long v8 = *(_OWORD *)(v7 - 3);
      *(unsigned char *)(v6 - 8) = *((unsigned char *)v7 - 8);
      *(_OWORD *)(v6 - 24) = v8;
      uint64_t v6 = llvm::SmallPtrSetImplBase::SmallPtrSetImplBase(v6, (void *)(v6 + 32), 4, v7) + 96;
      int64x2_t v9 = v7 + 8;
      v7 += 12;
    }
    while (v9 != (uint64_t *)v5);
    uint64_t v10 = *((unsigned int *)a1 + 2);
    if (v10)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = 96 * v10;
      do
      {
        char v13 = *(void **)(v11 + v12 - 56);
        if (v13 != *(void **)(v11 + v12 - 64)) {
          free(v13);
        }
        v12 -= 96;
      }
      while (v12);
    }
  }
}

void *sub_1CD4C21C4(uint64_t a1, uint64_t *a2)
{
  int64x2_t v7 = 0;
  char v4 = sub_1CC13D070(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4C222C(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4C222C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
LABEL_3:
    sub_1CC13DE5C(a1, v6);
    long long v8 = 0;
    sub_1CC13D070(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
    a3 = v8;
    goto LABEL_4;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3) {
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

uint64_t sub_1CD4C22E4(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int64x2_t v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int64x2_t v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      __n128 result = sub_1CC13D070(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1CD4C2394(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 8);
  if (v3 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  char v4 = (void *)(*(void *)result + 16 * v3);
  *char v4 = a2;
  v4[1] = a3;
  ++*(_DWORD *)(result + 8);
  return result;
}

void sub_1CD4C2404(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v20 = v25;
  uint64_t v6 = *(const void **)(a2 + 8);
  int64x2_t v7 = *(const void **)a2;
  if (v6 == *(const void **)a2)
  {
    unint64_t v21 = v25;
    uint64_t v8 = *(unsigned int *)(a2 + 20);
    if (v8) {
      memmove(v25, v6, 8 * v8);
    }
  }
  else
  {
    unint64_t v21 = v6;
    *(void *)(a2 + 8) = v7;
    LODWORD(v8) = *(_DWORD *)(a2 + 20);
  }
  int v22 = *(_DWORD *)(a2 + 16);
  int v23 = v8;
  int v24 = *(_DWORD *)(a2 + 24);
  *(void *)(a2 + 16) = 8;
  *(_DWORD *)(a2 + 24) = 0;
  *(_OWORD *)int v26 = *(_OWORD *)(a2 + 96);
  uint64_t v27 = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v12 = v17;
  uint64_t v10 = *(const void **)a3;
  uint64_t v9 = *(const void **)(a3 + 8);
  if (v9 == *(const void **)a3)
  {
    char v13 = v17;
    uint64_t v11 = *(unsigned int *)(a3 + 20);
    if (v11) {
      memmove(v17, v9, 8 * v11);
    }
  }
  else
  {
    char v13 = *(unsigned char **)(a3 + 8);
    *(void *)(a3 + 8) = v10;
    LODWORD(v11) = *(_DWORD *)(a3 + 20);
  }
  int v14 = *(_DWORD *)(a3 + 16);
  int v15 = v11;
  int v16 = *(_DWORD *)(a3 + 24);
  *(void *)(a3 + 16) = 8;
  *(_DWORD *)(a3 + 24) = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)(a3 + 96);
  uint64_t v19 = *(void *)(a3 + 112);
  *(void *)(a3 + 96) = 0;
  *(void *)(a3 + 104) = 0;
  *(void *)(a3 + 112) = 0;
  sub_1CD473714(a1, (uint64_t)&v20, (uint64_t)&v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v13 != v12) {
    free(v13);
  }
  if (v26[0])
  {
    v26[1] = v26[0];
    operator delete(v26[0]);
  }
  if (v21 != v20) {
    free(v21);
  }
}

char *sub_1CD4C2580(char *this)
{
  int v1 = (llvm::SmallPtrSetImplBase *)this;
  unsigned int v2 = (void **)(this + 96);
  uint64_t v3 = *((void *)this + 13);
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 24);
    if (!*(unsigned char *)(v3 - 8))
    {
      *(void *)(v3 - 16) = *(void *)(v4 + 8);
      *(unsigned char *)(v3 - 8) = 1;
    }
    while (1)
    {
      uint64_t v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 16)) {
        break;
      }
      *(void *)(v3 - 16) = v5 + 1;
      uint64_t v6 = *v5;
      this = (char *)sub_1CB89694C(v1, *v5);
      if (v7)
      {
        *(void *)&long long v10 = v6;
        BYTE8(v10) = 0;
        LOBYTE(v11) = 0;
        unint64_t v9 = *((void *)v1 + 13);
        if (v9 >= *((void *)v1 + 14))
        {
          this = sub_1CBF56DE8(v2, (uint64_t)&v10);
        }
        else
        {
          *(_OWORD *)unint64_t v9 = v10;
          *(void *)(v9 + 16) = v11;
          this = (char *)(v9 + 24);
        }
        *((void *)v1 + 13) = this;
        return this;
      }
    }
    uint64_t v8 = *((void *)v1 + 12);
    uint64_t v3 = *((void *)v1 + 13) - 24;
    *((void *)v1 + 13) = v3;
    if (v8 != v3) {
      continue;
    }
    break;
  }
  return this;
}

uint64_t sub_1CD4C2668(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if (*(void *)a1 + 8 * v9 == a2)
  {
    sub_1CBAACC38(a1, a3, a4);
    return *(void *)a1 + 8 * v8;
  }
  else
  {
    unint64_t v10 = (a4 - a3) >> 3;
    if (v9 + v10 > *(unsigned int *)(a1 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v11 = (unsigned char *)(v7 + 8 * v8);
    uint64_t v12 = (char *)(v7 + 8 * v9);
    unint64_t v13 = (v12 - v11) >> 3;
    if (v13 >= v10)
    {
      sub_1CD4570C8(a1, &v12[-8 * v10], (char *)(v7 + 8 * v9));
      if (&v12[-8 * v10] != v11) {
        memmove(&v11[8 * v10], v11, &v12[-8 * v10] - v11);
      }
      if (a4 != v5) {
        memmove(v11, v5, a4 - v5);
      }
    }
    else
    {
      unsigned int v14 = v9 + ((unint64_t)(a4 - a3) >> 3);
      *(_DWORD *)(a1 + 8) = v14;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 8 * v14 - 8 * v13), v11, v12 - v11);
        int v15 = v11;
        do
        {
          uint64_t v16 = *(void *)v5;
          v5 += 8;
          *v15++ = v16;
          --v13;
        }
        while (v13);
      }
      while (v5 != a4)
      {
        uint64_t v17 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v12 = v17;
        v12 += 8;
      }
    }
  }
  return (uint64_t)v11;
}

uint64_t sub_1CD4C27C4(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  if (sub_1CC00FB54(a1, &v7, &v6)) {
    return v6;
  }
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    uint64_t v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 8 * v5;
}

void sub_1CD4C2828(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2 - 8;
  if (!a2) {
    uint64_t v3 = 0;
  }
  sub_1CD4C19D8(*(unsigned char **)(v3 + 16), *(void *)(v3 + 24), a3);
}

BOOL sub_1CD4C283C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    uint64_t v3 = a2 - 8;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 24);
  return v4 == *(_DWORD *)(a3 + 8) && memcmp(*(const void **)a3, *(const void **)(v3 + 16), 4 * v4) == 0;
}

unint64_t sub_1CD4C288C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - 8;
  if (!a2) {
    uint64_t v2 = 0;
  }
  return sub_1CC13A6B8(*(void **)(v2 + 16), *(void *)(v2 + 16) + 4 * *(void *)(v2 + 24));
}

uint64_t sub_1CD4C28B8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      *uint64_t v7 = -4096;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unint64_t v10 = 0;
      __n128 result = sub_1CC13F758((uint64_t *)v5, (void *)a2, &v10);
      uint64_t v9 = v10;
      void *v10 = *(void *)a2;
      *(_OWORD *)(v9 + 1) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

uint64_t sub_1CD4C296C(llvm::ScalarEvolution **a1, const llvm::SCEV *a2)
{
  LosslessPtrToIntExpr = a2;
  uint64_t v4 = (const llvm::SCEV *)sub_1CC130A70(a1, *((void *)a2 + 4));
  if (v4 == *((const llvm::SCEV **)LosslessPtrToIntExpr + 4)) {
    return (uint64_t)LosslessPtrToIntExpr;
  }
  uint64_t v5 = *a1;
  uint64_t v6 = (llvm::Type *)*((void *)LosslessPtrToIntExpr + 5);
  LosslessPtrToIntExpr = llvm::ScalarEvolution::getLosslessPtrToIntExpr(v5, v4);
  if (*((_WORD *)LosslessPtrToIntExpr + 12) == 15) {
    return (uint64_t)LosslessPtrToIntExpr;
  }

  return llvm::ScalarEvolution::getTruncateOrZeroExtend(v5, LosslessPtrToIntExpr, v6, 0);
}

uint64_t sub_1CD4C2A04(uint64_t *a1, uint64_t a2)
{
  Sequentialunint64_t MinMaxExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    uint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CC130A70(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      unint64_t v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      Sequentialunint64_t MinMaxExpr = llvm::ScalarEvolution::getSequentialMinMaxExpr(*a1, 12, (unsigned int *)&v12);
      unint64_t v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return SequentialMinMaxExpr;
}

uint64_t llvm::SCEVAAResult::alias(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = *(void *)(a2 + 8);
  if (v4 <= 0xFFFFFFFFFFFFFFFDLL && (v4 & 0x7FFFFFFFFFFFFFFFLL) == 0) {
    return 0;
  }
  unint64_t v7 = *(void *)(a3 + 8);
  if (v7 <= 0xFFFFFFFFFFFFFFFDLL && (v7 & 0x7FFFFFFFFFFFFFFFLL) == 0) {
    return 0;
  }
  uint64_t SCEV = (llvm::SCEV *)llvm::ScalarEvolution::getSCEV(*(llvm::ScalarEvolution **)(a1 + 8), *(llvm::Value **)a2);
  uint64_t v13 = llvm::ScalarEvolution::getSCEV(*(llvm::ScalarEvolution **)(a1 + 8), *(llvm::Value **)a3);
  if (SCEV == (llvm::SCEV *)v13) {
    return 3;
  }
  unsigned int v14 = (llvm::SCEV *)v13;
  int v15 = *(llvm::ScalarEvolution **)(a1 + 8);
  Type = (llvm::Type *)llvm::SCEV::getType(SCEV);
  llvm::ScalarEvolution::getEffectiveSCEVType(v15, Type);
  uint64_t v18 = v17;
  uint64_t v19 = (llvm::Type *)llvm::SCEV::getType(v14);
  llvm::ScalarEvolution::getEffectiveSCEVType(v15, v19);
  if (v18 == exist)
  {
    uint64_t exist = llvm::ScalarEvolution::instructionCouldExistWitthOperands((llvm::DominatorTree **)v15, SCEV, v14);
    if (exist)
    {
      int v26 = *(llvm::ScalarEvolution **)(a1 + 8);
      uint64_t v27 = (llvm::Type *)llvm::SCEV::getType(SCEV);
      unsigned int TypeSizeInBits = llvm::ScalarEvolution::getTypeSizeInBits(v26, v27);
      unint64_t v29 = *(void *)(a2 + 8);
      uint64_t v30 = v29 >= 0xFFFFFFFFFFFFFFFELL ? -1 : v29 & 0x7FFFFFFFFFFFFFFFLL;
      sub_1CB8F1EEC((uint64_t)&v74, TypeSizeInBits, v30);
      unint64_t v31 = *(void *)(a3 + 8);
      uint64_t v32 = v31 >= 0xFFFFFFFFFFFFFFFELL ? -1 : v31 & 0x7FFFFFFFFFFFFFFFLL;
      sub_1CB8F1EEC((uint64_t)&v72, TypeSizeInBits, v32);
      Minusuint64_t SCEV = (llvm::SCEVCouldNotCompute *)llvm::ScalarEvolution::getMinusSCEV(*(llvm::ScalarEvolution **)(a1 + 8), v14, SCEV, 0, 0);
      if (llvm::SCEVCouldNotCompute::classof(MinusSCEV, v34)) {
        goto LABEL_25;
      }
      uint64_t RangeRef = llvm::ScalarEvolution::getRangeRef(*(void *)(a1 + 8), (uint64_t)MinusSCEV, 0, 0);
      sub_1CC067C7C((uint64_t)v59, RangeRef);
      llvm::ConstantRange::getUnsignedMin((uint64_t)v59, (uint64_t)&v70);
      LOBYTE(v40) = 0;
      if ((int)llvm::APInt::compare((llvm::APInt *)&v74, (const llvm::APInt *)&v70) <= 0)
      {
        unsigned int v67 = v73;
        if (v73 > 0x40) {
          operator new[]();
        }
        uint64_t v66 = v72;
        sub_1CBA14940((uint64_t)&v66);
        llvm::APInt::operator++((uint64_t)&v66);
        unsigned int v69 = v67;
        uint64_t v68 = v66;
        unsigned int v67 = 0;
        uint64_t v48 = llvm::ScalarEvolution::getRangeRef(*(void *)(a1 + 8), (uint64_t)MinusSCEV, 0, 0);
        sub_1CC067C7C((uint64_t)v56, v48);
        llvm::ConstantRange::getUnsignedMax(v56, (uint64_t)&v64);
        int v49 = llvm::APInt::compare((llvm::APInt *)&v68, (const llvm::APInt *)&v64);
        int v50 = v49;
        if (v65 >= 0x41 && v64) {
          MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
        }
        unsigned int v51 = ~v50;
        sub_1CC05EB8C((uint64_t)v56);
        if (v69 >= 0x41 && v68) {
          MEMORY[0x1D25D9CB0](v68, 0x1000C8000313F17);
        }
        unsigned int v40 = v51 >> 31;
        if (v67 >= 0x41 && v66) {
          MEMORY[0x1D25D9CB0](v66, 0x1000C8000313F17);
        }
      }
      if (v71 >= 0x41 && v70) {
        MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
      }
      uint64_t exist = sub_1CC05EB8C((uint64_t)v59);
      if ((v40 & 1) == 0)
      {
LABEL_25:
        uint64_t v35 = (llvm::SCEVCouldNotCompute *)llvm::ScalarEvolution::getMinusSCEV(*(llvm::ScalarEvolution **)(a1 + 8), SCEV, v14, 0, 0);
        uint64_t exist = llvm::SCEVCouldNotCompute::classof(v35, v36);
        int v37 = 0;
        if ((exist & 1) == 0)
        {
          uint64_t v38 = llvm::ScalarEvolution::getRangeRef(*(void *)(a1 + 8), (uint64_t)v35, 0, 0);
          sub_1CC067C7C((uint64_t)v59, v38);
          llvm::ConstantRange::getUnsignedMin((uint64_t)v59, (uint64_t)&v70);
          int v37 = 0;
          if ((int)llvm::APInt::compare((llvm::APInt *)&v72, (const llvm::APInt *)&v70) <= 0)
          {
            unsigned int v63 = v75;
            if (v75 > 0x40) {
              operator new[]();
            }
            uint64_t v62 = v74;
            sub_1CBA14940((uint64_t)&v62);
            llvm::APInt::operator++((uint64_t)&v62);
            unsigned int v69 = v63;
            uint64_t v68 = v62;
            unsigned int v63 = 0;
            uint64_t v52 = llvm::ScalarEvolution::getRangeRef(*(void *)(a1 + 8), (uint64_t)v35, 0, 0);
            sub_1CC067C7C((uint64_t)v56, v52);
            llvm::ConstantRange::getUnsignedMax(v56, (uint64_t)&v64);
            int v53 = llvm::APInt::compare((llvm::APInt *)&v68, (const llvm::APInt *)&v64);
            int v54 = v53;
            if (v65 >= 0x41 && v64) {
              MEMORY[0x1D25D9CB0](v64, 0x1000C8000313F17);
            }
            unsigned int v55 = ~v54;
            sub_1CC05EB8C((uint64_t)v56);
            if (v69 >= 0x41 && v68) {
              MEMORY[0x1D25D9CB0](v68, 0x1000C8000313F17);
            }
            int v37 = v55 >> 31;
            if (v63 >= 0x41 && v62) {
              MEMORY[0x1D25D9CB0](v62, 0x1000C8000313F17);
            }
          }
          if (v71 >= 0x41 && v70) {
            MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
          }
          uint64_t exist = sub_1CC05EB8C((uint64_t)v59);
        }
      }
      else
      {
        int v37 = 1;
      }
      if (v73 >= 0x41)
      {
        uint64_t exist = v72;
        if (v72) {
          uint64_t exist = MEMORY[0x1D25D9CB0](v72, 0x1000C8000313F17);
        }
      }
      if (v75 >= 0x41)
      {
        uint64_t exist = v74;
        if (v74) {
          uint64_t exist = MEMORY[0x1D25D9CB0](v74, 0x1000C8000313F17);
        }
      }
      if (v37) {
        return 0;
      }
    }
  }
  BaseValue = (llvm::SCEVAAResult *)llvm::SCEVAAResult::GetBaseValue((llvm::SCEVAAResult *)exist, SCEV);
  uint64_t v22 = llvm::SCEVAAResult::GetBaseValue(BaseValue, v14);
  if (BaseValue && BaseValue != *(llvm::SCEVAAResult **)a2)
  {
    int v24 = *(llvm::Value **)a3;
LABEL_46:
    int64x2_t v41 = 0uLL;
    uint64_t v42 = -1;
    long long v43 = 0uLL;
    goto LABEL_47;
  }
  if (!v22) {
    return 1;
  }
  int v24 = *(llvm::Value **)a3;
  if (v22 == *(void *)a3) {
    return 1;
  }
  if (BaseValue) {
    goto LABEL_46;
  }
  uint64_t v42 = *(void *)(a2 + 8);
  BaseValue = *(llvm::SCEVAAResult **)a2;
  int64x2_t v41 = *(int64x2_t *)(a2 + 16);
  long long v43 = *(_OWORD *)(a2 + 32);
LABEL_47:
  v23.i64[0] = 0;
  v59[0] = BaseValue;
  v59[1] = v42;
  int64x2_t v60 = v41;
  long long v61 = v43;
  v41.i64[0] = v22;
  int8x16_t v44 = (int8x16_t)vdupq_lane_s64(vceqq_s64(v41, v23).i64[0], 0);
  int8x16_t v45 = vandq_s8(*(int8x16_t *)(a3 + 32), v44);
  int8x16_t v46 = vandq_s8(*(int8x16_t *)(a3 + 16), v44);
  if (v22) {
    int v24 = (llvm::Value *)v22;
  }
  uint64_t v47 = *(void *)(a3 + 8);
  if (v22) {
    uint64_t v47 = -1;
  }
  v56[0] = (char *)v24;
  v56[1] = (char *)v47;
  int8x16_t v57 = v46;
  int8x16_t v58 = v45;
  uint64_t result = llvm::SCEVAAResult::alias(a1, v59, v56, a4);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t llvm::SCEVAAResult::invalidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  return sub_1CBF745FC(a4, (uint64_t)&llvm::ScalarEvolutionAnalysis::Key, a2, a3);
}

void llvm::SCEVAA::run()
{
}

void llvm::initializeSCEVAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8138, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC140150;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC8138, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createSCEVAAWrapperPass(llvm *this)
{
}

llvm::SCEVAAWrapperPass *llvm::SCEVAAWrapperPass::SCEVAAWrapperPass(llvm::SCEVAAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::SCEVAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F26076E0;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8138, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC140150;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC8138, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::AnalysisUsage *llvm::SCEVAAWrapperPass::getAnalysisUsage(llvm::SCEVAAWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredID(a2, llvm::ScalarEvolutionWrapperPass::ID);
}

void llvm::callDefaultCtor<llvm::SCEVAAWrapperPass>()
{
}

void llvm::SCEVDivision::divide(llvm::SCEVDivision *this, llvm::ScalarEvolution *a2, const llvm::SCEV ***a3, llvm::ScalarEvolution **a4, const llvm::SCEV **a5, const llvm::SCEV **a6)
{
  uint64_t v9 = a2;
  llvm::SCEVDivision::SCEVDivision((llvm::SCEVDivision *)v24, this, a2, (const llvm::SCEV *)a3);
  if (v9 == (const llvm::SCEV *)a3)
  {
    uint64_t v13 = v27;
    uint64_t v12 = v28;
LABEL_6:
    *a4 = v12;
    *a5 = v13;
    return;
  }
  if (llvm::SCEV::isZero(v9))
  {
    uint64_t v11 = v27;
    *a4 = v27;
LABEL_4:
    *a5 = v11;
    return;
  }
  if (llvm::SCEV::isOne((llvm::SCEV *)a3))
  {
    *a4 = v9;
    uint64_t v11 = v27;
    goto LABEL_4;
  }
  if (!a3 || *((_WORD *)a3 + 12) != 5)
  {
    sub_1CD4C34B4((unint64_t)v24, (uint64_t)v9, v14, v15, v16, v17);
    uint64_t v12 = v25;
    uint64_t v13 = v26;
    goto LABEL_6;
  }
  uint64_t v22 = 0;
  int64x2_t v23 = 0;
  *a4 = v9;
  uint64_t v18 = a3[5];
  if (v18)
  {
    uint64_t v19 = a3[4];
    uint64_t v20 = 8 * (void)v18;
    while (1)
    {
      llvm::SCEVDivision::divide(this, *a4, *v19, (const llvm::SCEV *)&v23, &v22, v17);
      unint64_t v21 = v22;
      *a4 = v23;
      if (!llvm::SCEV::isZero(v21)) {
        break;
      }
      ++v19;
      v20 -= 8;
      if (!v20) {
        goto LABEL_15;
      }
    }
    *a4 = v27;
  }
  else
  {
LABEL_15:
    uint64_t v9 = v27;
  }
  *a5 = v9;
}

void sub_1CD4C34B4(unint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, llvm::APInt *a5, const llvm::SCEV **a6)
{
  switch(*(_WORD *)(a2 + 24))
  {
    case 1:
    case 2:
    case 3:
    case 6:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
      return;
    case 4:
      llvm::SCEVDivision::visitAddExpr(result, a2);
      break;
    case 5:
      llvm::SCEVDivision::visitMulExpr(result, (llvm::SCEV *)a2);
      break;
    case 7:
      llvm::SCEVDivision::visitAddRecExpr((llvm::SCEVDivision **)result, (llvm::ScalarEvolution ***)a2, a3, a4, (uint64_t)a5, a6);
      break;
    default:
      llvm::SCEVDivision::visitConstant(result, a2, a3, a4, a5);
      break;
  }
}

llvm::SCEVDivision **llvm::SCEVDivision::visitAddRecExpr(llvm::SCEVDivision **this, llvm::ScalarEvolution ***a2, uint64_t a3, uint64_t a4, uint64_t a5, const llvm::SCEV **a6)
{
  uint64_t v6 = (const llvm::SCEVAddRecExpr *)a2;
  uint64_t v7 = (uint64_t)this;
  if (a2[5] != (llvm::ScalarEvolution **)2) {
    goto LABEL_2;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  llvm::SCEVDivision::divide(*this, *a2[4], this[1], (const llvm::SCEV *)&v19, &v18, a6);
  uint64_t v8 = *(llvm::SCEVDivision **)v7;
  uint64_t v9 = (llvm::ScalarEvolution *)sub_1CBFD7EA0((uint64_t)v6, *(llvm::ScalarEvolution **)v7);
  llvm::SCEVDivision::divide(v8, v9, *(const llvm::SCEV **)(v7 + 8), (const llvm::SCEV *)&v17, &v16, v10);
  uint64_t Type = llvm::SCEV::getType(*(llvm::SCEV **)(v7 + 8));
  uint64_t v12 = v19;
  this = (llvm::SCEVDivision **)llvm::SCEV::getType(v19);
  if ((llvm::SCEVDivision **)Type != this) {
    goto LABEL_2;
  }
  uint64_t v13 = v18;
  this = (llvm::SCEVDivision **)llvm::SCEV::getType(v18);
  if ((llvm::SCEVDivision **)Type == this
    && (uint64_t v14 = v17, this = (llvm::SCEVDivision **)llvm::SCEV::getType(v17), (llvm::SCEVDivision **)Type == this)
    && (uint64_t v15 = v16, this = (llvm::SCEVDivision **)llvm::SCEV::getType(v16), (llvm::SCEVDivision **)Type == this))
  {
    *(void *)(v7 + 16) = llvm::ScalarEvolution::getAddRecExpr(*(llvm::ScalarEvolution **)v7, (uint64_t)v12, (uint64_t)v14, *((const llvm::Loop **)v6 + 6), *((_WORD *)v6 + 14) & 7);
    this = (llvm::SCEVDivision **)llvm::ScalarEvolution::getAddRecExpr(*(llvm::ScalarEvolution **)v7, (uint64_t)v13, (uint64_t)v15, *((const llvm::Loop **)v6 + 6), *((_WORD *)v6 + 14) & 7);
    uint64_t v6 = (const llvm::SCEVAddRecExpr *)this;
  }
  else
  {
LABEL_2:
    *(void *)(v7 + 16) = *(void *)(v7 + 32);
  }
  *(void *)(v7 + 24) = v6;
  return this;
}

void llvm::SCEVDivision::visitAddExpr(uint64_t a1, uint64_t a2)
{
  void v20[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = v20;
  uint64_t v19 = 0x200000000;
  uint64_t v15 = v17;
  uint64_t v16 = 0x200000000;
  uint64_t Type = llvm::SCEV::getType(*(llvm::SCEV **)(a1 + 8));
  uint64_t v6 = *(void *)(a2 + 40);
  if (v6)
  {
    uint64_t v7 = Type;
    uint64_t v8 = *(llvm::ScalarEvolution ***)(a2 + 32);
    uint64_t v9 = 8 * v6;
    while (1)
    {
      unint64_t v10 = *v8;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)a1, v10, *(const llvm::SCEV **)(a1 + 8), (const llvm::SCEV *)&v14, &v13, v5);
      uint64_t v11 = v14;
      if (v7 != llvm::SCEV::getType(v14)) {
        break;
      }
      uint64_t v12 = v13;
      if (v7 != llvm::SCEV::getType(v13)) {
        break;
      }
      if (v19 >= (unint64_t)HIDWORD(v19)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v18 + v19) = v11;
      LODWORD(v19) = v19 + 1;
      if (v16 >= (unint64_t)HIDWORD(v16)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v15 + v16) = v12;
      LODWORD(v16) = v16 + 1;
      ++v8;
      v9 -= 8;
      if (!v9) {
        goto LABEL_8;
      }
    }
    *(void *)(a1 + 16) = *(void *)(a1 + 32);
    *(void *)(a1 + 24) = a2;
  }
  else
  {
LABEL_8:
    if (v19 == 1)
    {
      *(void *)(a1 + 16) = *(void *)v18;
      *(void *)(a1 + 24) = *(void *)v15;
    }
    else
    {
      *(void *)(a1 + 16) = llvm::ScalarEvolution::getAddExpr(*(void *)a1, (unint64_t **)&v18, 0, 0);
      *(void *)(a1 + 24) = llvm::ScalarEvolution::getAddExpr(*(void *)a1, (unint64_t **)&v15, 0, 0);
    }
  }
  if (v15 != v17) {
    free(v15);
  }
  if (v18 != v20) {
    free(v18);
  }
}

void llvm::SCEVDivision::visitMulExpr(uint64_t a1, llvm::SCEV *a2)
{
  v29[2] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = v29;
  uint64_t v28 = 0x200000000;
  uint64_t Type = llvm::SCEV::getType(*(llvm::SCEV **)(a1 + 8));
  uint64_t v5 = *((void *)a2 + 5);
  if (v5)
  {
    uint64_t v6 = Type;
    uint64_t v7 = (llvm::SCEV **)*((void *)a2 + 4);
    uint64_t v8 = *v7;
    if (Type != llvm::SCEV::getType(*v7))
    {
LABEL_3:
      *(void *)(a1 + 16) = *(void *)(a1 + 32);
      *(void *)(a1 + 24) = a2;
      goto LABEL_4;
    }
    char v10 = 0;
    uint64_t v11 = &v7[v5];
    while (1)
    {
      if ((v10 & 1) == 0)
      {
        v24[0] = 0;
        int v26 = 0;
        llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)a1, v8, *(const llvm::SCEV **)(a1 + 8), (const llvm::SCEV *)v24, &v26, v9);
        if (!llvm::SCEV::isZero(v26))
        {
          if (v28 >= (unint64_t)HIDWORD(v28)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v27 + v28) = v8;
          LODWORD(v28) = v28 + 1;
          if (++v7 == v11) {
            break;
          }
          char v10 = 0;
          goto LABEL_12;
        }
        uint64_t v8 = v24[0];
        if (v6 != llvm::SCEV::getType(v24[0])) {
          goto LABEL_3;
        }
      }
      if (v28 >= (unint64_t)HIDWORD(v28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v27 + v28) = v8;
      int v12 = v28 + 1;
      LODWORD(v28) = v28 + 1;
      if (++v7 == v11)
      {
        *(void *)(a1 + 24) = *(void *)(a1 + 32);
        if (v12 == 1) {
          *(void *)(a1 + 16) = *(void *)v27;
        }
        else {
          *(void *)(a1 + 16) = llvm::ScalarEvolution::getMulExpr(*(void *)a1, (uint64_t)&v27, 0, 0);
        }
        goto LABEL_4;
      }
      char v10 = 1;
LABEL_12:
      uint64_t v8 = *v7;
      if (v6 != llvm::SCEV::getType(*v7)) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v13 = *(void *)(a1 + 8);
  if (*(_WORD *)(v13 + 24) != 14) {
    goto LABEL_3;
  }
  v24[0] = 0;
  v24[1] = 0;
  int v25 = 0;
  uint64_t v14 = *(void *)(a1 + 32);
  int v26 = *(llvm::SCEV **)(v13 - 8);
  sub_1CD467E2C((uint64_t)v24, (uint64_t *)&v26)[1] = v14;
  uint64_t v15 = (llvm::SCEV *)sub_1CD4C3B54((uint64_t)a2, *(void *)a1, (uint64_t)v24);
  *(void *)(a1 + 24) = v15;
  if (llvm::SCEV::isZero(v15))
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v21 = *(void *)(a1 + 8);
    if (v21) {
      uint64_t v22 = v21 - 32;
    }
    else {
      uint64_t v22 = 0;
    }
    int v26 = *(llvm::SCEV **)(v22 + 24);
    sub_1CD467E2C((uint64_t)v24, (uint64_t *)&v26)[1] = v20;
    *(void *)(a1 + 16) = sub_1CD4C3B54((uint64_t)a2, *(void *)a1, (uint64_t)v24);
    goto LABEL_25;
  }
  int v26 = 0;
  int64x2_t v23 = 0;
  Minusuint64_t SCEV = (llvm::ScalarEvolution *)llvm::ScalarEvolution::getMinusSCEV(*(llvm::ScalarEvolution **)a1, a2, *(const llvm::APInt **)(a1 + 24), 0, 0);
  int v17 = sub_1CC140788((uint64_t)MinusSCEV);
  if (v17 <= (int)sub_1CC140788((uint64_t)a2))
  {
    llvm::SCEVDivision::divide(*(llvm::SCEVDivision **)a1, MinusSCEV, *(const llvm::SCEV **)(a1 + 8), (const llvm::SCEV *)&v26, &v23, v18);
    uint64_t v19 = *(const llvm::SCEV **)(a1 + 32);
    if (v23 == v19)
    {
      *(void *)(a1 + 16) = v26;
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v19 = *(const llvm::SCEV **)(a1 + 32);
  }
  *(void *)(a1 + 16) = v19;
  *(void *)(a1 + 24) = a2;
LABEL_25:
  MEMORY[0x1D25D9CD0](v24[0], 8);
LABEL_4:
  if (v27 != v29) {
    free(v27);
  }
}

uint64_t sub_1CD4C3B54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v5 = a2;
  int v8 = 0;
  uint64_t v9 = a3;
  uint64_t v3 = sub_1CD4C3C34((uint64_t)&v5, a1);
  MEMORY[0x1D25D9CD0](v6, 8);
  return v3;
}

llvm::SCEVDivision *llvm::SCEVDivision::SCEVDivision(llvm::SCEVDivision *this, llvm::ScalarEvolution *a2, const llvm::SCEV *a3, const llvm::SCEV *a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a4;
  uint64_t Type = (llvm::Type *)llvm::SCEV::getType(a4);
  *((void *)this + 4) = llvm::ScalarEvolution::getConstant(a2, Type, 0, 0);
  uint64_t v9 = *(llvm::ScalarEvolution **)this;
  char v10 = (llvm::Type *)llvm::SCEV::getType(a4);
  *((void *)this + 5) = llvm::ScalarEvolution::getConstant(v9, v10, 1uLL, 0);
  *((void *)this + 2) = *((void *)this + 4);
  *((void *)this + 3) = a3;
  return this;
}

uint64_t sub_1CD4C3C34(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = a2;
  unint64_t v9 = a2;
  uint64_t v4 = a1 + 8;
  v7[0] = 0;
  if (!sub_1CBFFD518((uint64_t *)(a1 + 8), &v9, v7)
    || (uint64_t v5 = v7[0], v7[0] == *(void *)(a1 + 8) + 16 * *(unsigned int *)(a1 + 24)))
  {
    unint64_t v9 = sub_1CD4C3CD0((llvm::ScalarEvolution **)a1, a2);
    sub_1CC140960((uint64_t)v7, v4, &v8, &v9);
    uint64_t v5 = v7[0];
  }
  return *(void *)(v5 + 8);
}

unint64_t sub_1CD4C3CD0(llvm::ScalarEvolution **a1, uint64_t a2)
{
  switch(*(_WORD *)(a2 + 24))
  {
    case 1:
      unint64_t result = sub_1CD4C3D9C(a1, a2);
      break;
    case 2:
      unint64_t result = sub_1CD4C3E04(a1, a2);
      break;
    case 3:
      unint64_t result = sub_1CD4C3E6C(a1, a2);
      break;
    case 4:
      unint64_t result = sub_1CD4C3ED4((uint64_t *)a1, a2);
      break;
    case 5:
      unint64_t result = sub_1CD4C4014((uint64_t *)a1, a2);
      break;
    case 6:
      unint64_t result = sub_1CD4C4154(a1, a2);
      break;
    case 7:
      unint64_t result = sub_1CD4C41E0(a1, a2);
      break;
    case 8:
      unint64_t result = sub_1CD4C445C((uint64_t *)a1, a2);
      break;
    case 9:
      unint64_t result = sub_1CD4C4324((uint64_t *)a1, a2);
      break;
    case 0xA:
      unint64_t result = sub_1CD4C46CC((uint64_t *)a1, a2);
      break;
    case 0xB:
      unint64_t result = sub_1CD4C4594((uint64_t *)a1, a2);
      break;
    case 0xC:
      unint64_t result = sub_1CD4C4808((uint64_t *)a1, a2);
      break;
    case 0xD:
      unint64_t result = (unint64_t)sub_1CD4C3D38(a1, a2);
      break;
    case 0xE:
      unint64_t result = sub_1CD4C4944((uint64_t)a1, a2 - 32);
      break;
    default:
      unint64_t result = a2;
      break;
  }
  return result;
}

llvm::detail::IEEEFloat **sub_1CD4C3D38(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD4C3C34(a1, *(void *)(a2 + 32));
  if (v4 == *(void *)(a2 + 32)) {
    return (llvm::detail::IEEEFloat **)a2;
  }
  uint64_t v5 = (const llvm::SCEV *)v4;
  uint64_t v6 = *a1;
  uint64_t v7 = *(llvm::Type **)(a2 + 40);

  return llvm::ScalarEvolution::getPtrToIntExpr(v6, v5, v7);
}

uint64_t sub_1CD4C3D9C(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD4C3C34(a1, *(void *)(a2 + 32));
  if (v4 == *(void *)(a2 + 32)) {
    return a2;
  }
  uint64_t v5 = (const llvm::SCEV *)v4;
  uint64_t v6 = *a1;
  uint64_t v7 = *(llvm::Type **)(a2 + 40);

  return llvm::ScalarEvolution::getTruncateExpr(v6, v5, v7, 0);
}

unint64_t sub_1CD4C3E04(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD4C3C34(a1, *(void *)(a2 + 32));
  if (v4 == *(void *)(a2 + 32)) {
    return a2;
  }
  uint64_t v5 = (llvm::detail::IEEEFloat **)v4;
  uint64_t v6 = *a1;
  uint64_t v7 = *(uint64_t ***)(a2 + 40);

  return llvm::ScalarEvolution::getZeroExtendExpr(v6, v5, v7, 0);
}

unint64_t sub_1CD4C3E6C(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t v4 = sub_1CD4C3C34(a1, *(void *)(a2 + 32));
  if (v4 == *(void *)(a2 + 32)) {
    return a2;
  }
  uint64_t v5 = (llvm::detail::IEEEFloat **)v4;
  uint64_t v6 = *a1;
  uint64_t v7 = *(uint64_t ***)(a2 + 40);

  return llvm::ScalarEvolution::getSignExtendExpr(v6, v5, v7, 0);
}

uint64_t sub_1CD4C3ED4(uint64_t *a1, uint64_t a2)
{
  uint64_t AddExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    uint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t AddExpr = llvm::ScalarEvolution::getAddExpr(*a1, (unint64_t **)&v12, 0, 0);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return AddExpr;
}

uint64_t sub_1CD4C4014(uint64_t *a1, uint64_t a2)
{
  uint64_t MulExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    uint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t MulExpr = llvm::ScalarEvolution::getMulExpr(*a1, (uint64_t)&v12, 0, 0);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return MulExpr;
}

uint64_t sub_1CD4C4154(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t v4 = (const llvm::SCEV *)sub_1CD4C3C34(a1, *(void *)(a2 + 32));
  uint64_t v5 = sub_1CD4C3C34(a1, *(void *)(a2 + 40));
  unint64_t v6 = v5;
  if (v4 == *(const llvm::SCEV **)(a2 + 32) && v5 == *(void *)(a2 + 40)) {
    return a2;
  }
  uint64_t v7 = *a1;

  return llvm::ScalarEvolution::getUDivExpr(v7, v4, v6);
}

uint64_t sub_1CD4C41E0(llvm::ScalarEvolution **a1, uint64_t a2)
{
  uint64_t AddRecExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    unint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t AddRecExpr = llvm::ScalarEvolution::getAddRecExpr(*a1, (uint64_t **)&v12, *(const llvm::Loop **)(AddRecExpr + 48), *(_WORD *)(AddRecExpr + 28) & 7);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return AddRecExpr;
}

uint64_t sub_1CD4C4324(uint64_t *a1, uint64_t a2)
{
  uint64_t SMaxExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    unint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t SMaxExpr = llvm::ScalarEvolution::getSMaxExpr(*a1, (uint64_t **)&v12);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return SMaxExpr;
}

uint64_t sub_1CD4C445C(uint64_t *a1, uint64_t a2)
{
  uint64_t UMaxExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    unint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t UMaxExpr = llvm::ScalarEvolution::getUMaxExpr(*a1, (uint64_t **)&v12);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return UMaxExpr;
}

uint64_t sub_1CD4C4594(uint64_t *a1, uint64_t a2)
{
  uint64_t SMinExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    unint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t SMinExpr = llvm::ScalarEvolution::getSMinExpr(*a1, (uint64_t **)&v12);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return SMinExpr;
}

uint64_t sub_1CD4C46CC(uint64_t *a1, uint64_t a2)
{
  uint64_t UMinExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    unint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t UMinExpr = llvm::ScalarEvolution::getUMinExpr(*a1, (unsigned int *)&v12, 0);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return UMinExpr;
}

uint64_t sub_1CD4C4808(uint64_t *a1, uint64_t a2)
{
  uint64_t UMinExpr = a2;
  v14[2] = *MEMORY[0x1E4F143B8];
  int v12 = v14;
  uint64_t v13 = 0x200000000;
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3)
  {
    char v5 = 0;
    unint64_t v6 = *(void **)(a2 + 32);
    uint64_t v7 = 8 * v3;
    do
    {
      uint64_t v8 = *v6;
      uint64_t v9 = sub_1CD4C3C34(a1, *v6);
      if (v13 >= (unint64_t)HIDWORD(v13)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v12 + v13) = v9;
      LODWORD(v13) = v13 + 1;
      char v10 = v12;
      v5 |= v8 != *((void *)v12 + v13 - 1);
      ++v6;
      v7 -= 8;
    }
    while (v7);
    if (v5)
    {
      uint64_t UMinExpr = llvm::ScalarEvolution::getUMinExpr(*a1, (unsigned int *)&v12, 1);
      char v10 = v12;
    }
    if (v10 != v14) {
      free(v10);
    }
  }
  return UMinExpr;
}

uint64_t sub_1CD4C4944(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v8 = 0;
  if (sub_1CD40EA84(*(void *)v4, *(_DWORD *)(v4 + 16), v5, &v8)) {
    uint64_t v6 = v8;
  }
  else {
    uint64_t v6 = *(void *)v4 + 16 * *(unsigned int *)(v4 + 16);
  }
  if (v6 == **(void **)(a1 + 32) + 16 * *(unsigned int *)(*(void *)(a1 + 32) + 16)) {
    return a2 + 32;
  }
  else {
    return *(void *)(v6 + 8);
  }
}

uint64_t llvm::normalizeForPostIncUse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a2;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v5 = a3;
  int v9 = 0;
  int v8 = 0;
  char v10 = sub_1CC1415FC;
  uint64_t v11 = &v12;
  uint64_t v3 = sub_1CC140C18((uint64_t)&v5, a1);
  MEMORY[0x1D25D9CD0](v6, 8);
  return v3;
}

uint64_t llvm::normalizeForPostIncUseIf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v6 = a4;
  int v10 = 0;
  int v9 = 0;
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  uint64_t v4 = sub_1CC140C18((uint64_t)&v6, a1);
  MEMORY[0x1D25D9CD0](v7, 8);
  return v4;
}

uint64_t llvm::denormalizeForPostIncUse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a2;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v5 = a3;
  int v8 = 0;
  int v9 = 1;
  int v10 = sub_1CC1416F0;
  uint64_t v11 = &v12;
  uint64_t v3 = sub_1CC140C18((uint64_t)&v5, a1);
  MEMORY[0x1D25D9CD0](v6, 8);
  return v3;
}

uint64_t llvm::StackLifetime::getLiveRange(llvm::StackLifetime *this, const llvm::AllocaInst *a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = a2;
  if (sub_1CD3C8538((uint64_t *)this + 77, &v6, &v5)) {
    uint64_t v3 = v5;
  }
  else {
    uint64_t v3 = *((void *)this + 77) + 16 * *((unsigned int *)this + 158);
  }
  return *((void *)this + 80) + 72 * *(unsigned int *)(v3 + 8);
}

BOOL llvm::StackLifetime::isReachable(llvm::StackLifetime *this, const llvm::Instruction *a2)
{
  uint64_t v3 = *((void *)a2 + 5);
  uint64_t v8 = 0;
  uint64_t v9 = v3;
  if (sub_1CD3C8538((uint64_t *)this + 71, &v9, &v8))
  {
    uint64_t v4 = v8;
    uint64_t v5 = *((void *)this + 71);
    uint64_t v6 = *((unsigned int *)this + 146);
  }
  else
  {
    uint64_t v5 = *((void *)this + 71);
    uint64_t v6 = *((unsigned int *)this + 146);
    uint64_t v4 = v5 + 16 * v6;
  }
  return v4 != v5 + 16 * v6;
}

uint64_t llvm::StackLifetime::isAliveAfter(llvm::StackLifetime *this, const llvm::AllocaInst *a2, const llvm::Instruction *a3)
{
  uint64_t v6 = (const llvm::AllocaInst *)*((void *)a3 + 5);
  uint64_t v17 = 0;
  uint64_t v18 = v6;
  if (sub_1CD3C8538((uint64_t *)this + 71, &v18, &v17)) {
    uint64_t v7 = v17;
  }
  else {
    uint64_t v7 = *((void *)this + 71) + 16 * *((unsigned int *)this + 146);
  }
  uint64_t v8 = *((void *)this + 5);
  uint64_t v9 = v8 + 8 * *(unsigned int *)(v7 + 8) + 8;
  uint64_t v10 = 8 * *(unsigned int *)(v7 + 12) - (8 * *(unsigned int *)(v7 + 8) + 8);
  if (v10)
  {
    unint64_t v11 = v10 >> 3;
    do
    {
      uint64_t v12 = (const llvm::Instruction **)(v9 + 8 * (v11 >> 1));
      uint64_t v14 = *v12;
      uint64_t v13 = v12 + 1;
      if (llvm::Instruction::comesBefore(a3, v14))
      {
        v11 >>= 1;
      }
      else
      {
        uint64_t v9 = (uint64_t)v13;
        v11 += ~(v11 >> 1);
      }
    }
    while (v11);
    uint64_t v8 = *((void *)this + 5);
  }
  uint64_t v17 = 0;
  uint64_t v18 = a2;
  if (sub_1CD3C8538((uint64_t *)this + 77, &v18, &v17)) {
    uint64_t v15 = v17;
  }
  else {
    uint64_t v15 = *((void *)this + 77) + 16 * *((unsigned int *)this + 158);
  }
  return (*(void *)(*(void *)(*((void *)this + 80) + 72 * *(unsigned int *)(v15 + 8))
                    + 8 * (((unint64_t)(v9 - v8 - 8) >> 9) & 0x3FFFFFF)) >> ((unint64_t)(v9 - v8 - 8) >> 3)) & 1;
}

void sub_1CD4C4D08(void *a1, uint64_t a2)
{
  if (a2) {
    uint64_t v3 = a2 - 24;
  }
  else {
    uint64_t v3 = 0;
  }
  sub_1CD4BA970((uint64_t)&v12, v3);
  uint64_t v8 = 0;
  std::string __p = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t v4 = (char *)v7 + 8;
  uint64_t v5 = (char *)v7 + 8;
  uint64_t v6 = 8;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  sub_1CD47362C(a1, (uint64_t)&v12, (uint64_t)&v4);
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  if (v5 != v4) {
    free(v5);
  }
  if (v14)
  {
    uint64_t v15 = v14;
    operator delete(v14);
  }
  if (v13 != v12) {
    free(v13);
  }
}

uint64_t sub_1CD4C4DC8(uint64_t a1, uint64_t a2, uint64_t *a3, int *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD4C688C(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = sub_1CD4C6928(a2, a3, v12);
    *uint64_t v9 = *a3;
    uint64_t result = sub_1CD4C6C64((uint64_t)(v9 + 1), *a4);
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 296 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

int *sub_1CD4C4E74(int *a1)
{
  int v2 = *a1;
  if (*a1 > 1)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      uint64_t v7 = a1 + 18;
LABEL_9:
      while ((*(void *)result | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        result += 4;
        if (result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (int *)*((void *)a1 + 1);
      uint64_t v6 = a1[4];
      if (v6)
      {
        uint64_t v7 = &result[4 * v6];
        goto LABEL_9;
      }
    }
  }
  else
  {
    if (v2)
    {
      uint64_t v3 = a1 + 2;
      uint64_t v4 = 4;
    }
    else
    {
      uint64_t v3 = (int *)*((void *)a1 + 1);
      uint64_t v4 = a1[4];
    }
    return &v3[4 * v4];
  }
  return result;
}

uint64_t sub_1CD4C4EE8(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CD4C64C4(a1, a2, &v6)) {
    return v6;
  }
  if (*(unsigned char *)a1)
  {
    uint64_t v4 = a1 + 8;
    uint64_t v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 16);
  }
  return v4 + 16 * v5;
}

uint64_t llvm::StackLifetime::calculateLiveIntervals(uint64_t this)
{
  uint64_t v1 = this;
  v41[36] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(this + 16);
  unsigned int v3 = *(_DWORD *)(this + 32);
  uint64_t v4 = v2 + 296 * v3;
  if (*(_DWORD *)(this + 24))
  {
    if (v3)
    {
      uint64_t v5 = 296 * v3;
      uint64_t v6 = *(void *)(this + 16);
      while ((*(void *)v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v6 += 296;
        v5 -= 296;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v6 = *(void *)(this + 16);
    }
  }
  else
  {
LABEL_6:
    uint64_t v6 = v2 + 296 * v3;
  }
  uint64_t v32 = v2 + 296 * v3;
  if (v6 != v32)
  {
    unint64_t v31 = (uint64_t *)(this + 568);
    uint64_t v30 = this + 1304;
    do
    {
      uint64_t v40 = *(void *)v6;
      sub_1CD4C5930((uint64_t)v41, (_DWORD *)(v6 + 8));
      uint64_t v33 = v40;
      uint64_t v7 = sub_1CD4C6D28(v31, &v33);
      int v8 = *((_DWORD *)v7 + 2);
      unsigned int v9 = *((_DWORD *)v7 + 3);
      v38[0] = v39;
      v38[1] = (void *)0x600000000;
      v39[12] = 0;
      v36[0] = v37;
      v36[1] = (void *)0x600000000;
      v37[12] = 0;
      sub_1CB8F8DF4((uint64_t)v38, *(_DWORD *)(v1 + 608), 0);
      sub_1CB8F8DF4((uint64_t)v36, *(_DWORD *)(v1 + 608), 0);
      v34[0] = v35;
      v34[1] = (void *)0x800000000;
      sub_1CBB1173C((uint64_t)v34, *(unsigned int *)(v1 + 608));
      unint64_t v10 = *(unsigned int *)(v1 + 608);
      if (v10)
      {
        unint64_t v11 = 0;
        uint64_t v12 = v41[18];
        uint64_t v13 = v38[0];
        uint64_t v14 = v34[0];
        do
        {
          uint64_t v15 = v11 >> 6;
          if (((1 << v11) & *(void *)(v12 + 8 * v15)) != 0)
          {
            v13[v15] |= 1 << v11;
            v14[v11] = v8;
            unint64_t v10 = *(unsigned int *)(v1 + 608);
          }
          ++v11;
        }
        while (v11 < v10);
      }
      uint64_t v16 = sub_1CD4C6F10(v30, &v33);
      unsigned int v17 = *((_DWORD *)v16 + 4);
      if (v17)
      {
        uint64_t v18 = v16[1];
        uint64_t v19 = v18 + 12 * v17;
        do
        {
          unsigned int v20 = *(_DWORD *)v18;
          unint64_t v21 = *(unsigned int *)(v18 + 4);
          uint64_t v22 = 1 << v21;
          unint64_t v23 = v21 >> 6;
          uint64_t v24 = *((void *)v38[0] + (v21 >> 6));
          uint64_t v25 = (1 << v21) & v24;
          if (*(unsigned char *)(v18 + 8))
          {
            if (!v25)
            {
              *((void *)v38[0] + v23) = v22 | v24;
              *((void *)v36[0] + v23) &= ~v22;
              *((_DWORD *)v34[0] + v21) = v20;
            }
          }
          else
          {
            if (v25)
            {
              sub_1CC143874((uint64_t *)(*(void *)(v1 + 640) + 72 * v21), *((_DWORD *)v34[0] + v21), v20);
              *((void *)v38[0] + v23) &= ~v22;
            }
            *((void *)v36[0] + v23) |= v22;
          }
          v18 += 12;
        }
        while (v18 != v19);
      }
      unint64_t v26 = *(unsigned int *)(v1 + 608);
      if (v26)
      {
        uint64_t v27 = 0;
        for (unint64_t i = 0; i < v26; ++i)
        {
          if ((*((void *)v38[0] + (i >> 6)) >> i))
          {
            sub_1CC143874((uint64_t *)(*(void *)(v1 + 640) + v27), *((_DWORD *)v34[0] + i), v9);
            unint64_t v26 = *(unsigned int *)(v1 + 608);
          }
          v27 += 72;
        }
      }
      if (v34[0] != v35) {
        free(v34[0]);
      }
      if (v36[0] != v37) {
        free(v36[0]);
      }
      if (v38[0] != v39) {
        free(v38[0]);
      }
      this = sub_1CD4C5A08((uint64_t)v41);
      uint64_t v29 = v6 + 296;
      uint64_t v6 = v4;
      if (v29 != v4)
      {
        uint64_t v6 = v29;
        while ((*(void *)v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v6 += 296;
          if (v6 == v4)
          {
            uint64_t v6 = v4;
            break;
          }
        }
      }
    }
    while (v6 != v32);
  }
  return this;
}

llvm *llvm::StackLifetime::dumpAllocas(llvm::StackLifetime *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t result = sub_1CB8E509C(v2, "Allocas:\n");
  if (*((_DWORD *)this + 152))
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = llvm::dbgs(result);
      uint64_t v6 = sub_1CB8E509C(v5, "  ");
      sub_1CD098D14(v6, v4, 0, 0, 0);
      uint64_t v7 = sub_1CB8E509C(v6, ": ");
      llvm::Value::print(*(llvm::Value **)(*((void *)this + 74) + 8 * v4), v7, 0);
      uint64_t result = sub_1CB8E509C(v7, "\n");
      ++v4;
    }
    while (v4 < *((unsigned int *)this + 152));
  }
  return result;
}

llvm *llvm::StackLifetime::dumpLiveRanges(llvm::StackLifetime *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t result = sub_1CB8E509C(v2, "Alloca liveness:\n");
  if (*((_DWORD *)this + 152))
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = llvm::dbgs(result);
      uint64_t v7 = sub_1CB8E509C(v6, "  ");
      sub_1CD098D14(v7, v5, 0, 0, 0);
      int v8 = sub_1CB8E509C(v7, ": ");
      unsigned int v9 = sub_1CC1433D8(v8, *((void *)this + 80) + v4);
      uint64_t result = sub_1CB8E509C(v9, "\n");
      ++v5;
      v4 += 72;
    }
    while (v5 < *((unsigned int *)this + 152));
  }
  return result;
}

void llvm::StackLifetime::StackLifetime(llvm::StackLifetime *this, uint64_t a2, void *a3, uint64_t a4, int a5)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a5;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = (char *)this + 56;
  *((void *)this + 6) = 0x4000000000;
  *((_DWORD *)this + 146) = 0;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((void *)this + 74) = a3;
  *((void *)this + 75) = a4;
  *((_DWORD *)this + 152) = a4;
  uint64_t v6 = (uint64_t *)((char *)this + 616);
  *((_DWORD *)this + 158) = 0;
  *(_OWORD *)((char *)this + 616) = 0u;
  *((void *)this + 80) = (char *)this + 656;
  *((void *)this + 81) = 0x800000000;
  *((void *)this + 154) = (char *)this + 1248;
  *((void *)this + 155) = 0x600000000;
  *((_DWORD *)this + 324) = 0;
  *((unsigned char *)this + 1328) = 0;
  *((_DWORD *)this + 330) = 0;
  *(_OWORD *)((char *)this + 1304) = 0u;
  if (a4)
  {
    uint64_t v7 = a3;
    unint64_t v8 = 0;
    do
      *((_DWORD *)sub_1CD4C7374(v6, v7++) + 2) = v8++;
    while (v8 < *((unsigned int *)this + 152));
  }
  llvm::StackLifetime::collectMarkers(this);
}

void llvm::StackLifetime::run(llvm::StackLifetime *this)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 1328))
  {
    int v2 = *((_DWORD *)this + 2);
    if (v2 == 1)
    {
      uint64_t v6 = (char *)this + 640;
      unint64_t v7 = *((unsigned int *)this + 152);
      int v8 = *((_DWORD *)this + 12);
      uint64_t v15 = v17;
      uint64_t v16 = 0x600000000;
      sub_1CB90D610((uint64_t)&v15, (v8 + 63) >> 6, 0);
      int v18 = v8;
      sub_1CD4C5750((uint64_t)v6, v7, (unint64_t)&v15);
      unsigned int v9 = v15;
      if (v15 != v17) {
LABEL_12:
      }
        free(v9);
    }
    else if (!v2)
    {
      unint64_t v10 = (char *)this + 640;
      unint64_t v11 = *((unsigned int *)this + 152);
      sub_1CB9F9A80((uint64_t)&v15, *((_DWORD *)this + 12), 1);
      sub_1CD4C5750((uint64_t)v10, v11, (unint64_t)&v15);
      unsigned int v9 = v15;
      if (v15 != v17) {
        goto LABEL_12;
      }
    }
  }
  else
  {
    unint64_t v3 = *((unsigned int *)this + 152);
    int v4 = *((_DWORD *)this + 12);
    uint64_t v15 = v17;
    uint64_t v16 = 0x600000000;
    sub_1CB90D610((uint64_t)&v15, (v4 + 63) >> 6, 0);
    int v18 = v4;
    sub_1CD4C5750((uint64_t)this + 640, v3, (unint64_t)&v15);
    if (v15 != v17) {
      free(v15);
    }
    unint64_t v5 = *((unsigned int *)this + 152);
    if (v5)
    {
      unint64_t v12 = 0;
      uint64_t v13 = 64;
      do
      {
        if (((*(void *)(*((void *)this + 154) + 8 * (v12 >> 6)) >> v12) & 1) == 0)
        {
          sub_1CB9F9A80((uint64_t)&v15, *((_DWORD *)this + 12), 1);
          uint64_t v14 = (_DWORD *)(*((void *)this + 80) + v13);
          sub_1CB837F14((uint64_t)(v14 - 16), (uint64_t)&v15);
          _DWORD *v14 = v18;
          if (v15 != v17) {
            free(v15);
          }
          unint64_t v5 = *((unsigned int *)this + 152);
        }
        ++v12;
        v13 += 72;
      }
      while (v12 < v5);
    }
    llvm::StackLifetime::calculateLocalLiveness(this);
    llvm::StackLifetime::calculateLiveIntervals((uint64_t)this);
  }
}

void sub_1CD4C5750(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = *(unsigned int *)(a1 + 8);
  BOOL v5 = a2 >= v4;
  uint64_t v6 = a2 - v4;
  if (v6)
  {
    if (v5)
    {
      sub_1CD4C7488(a1, v6, a3);
    }
    else
    {
      uint64_t v8 = 9 * v4;
      unsigned int v9 = (void **)(*(void *)a1 + 8 * v8 - 72);
      uint64_t v10 = 72 * a2 - 8 * v8;
      do
      {
        if (v9 + 2 != *v9) {
          free(*v9);
        }
        v9 -= 9;
        v10 += 72;
      }
      while (v10);
      *(_DWORD *)(a1 + 8) = a2;
    }
  }
}

llvm::raw_ostream *llvm::StackLifetimePrinterPass::printPipeline(_DWORD *a1, llvm::raw_ostream *a2, uint64_t (*a3)(uint64_t, const char *, uint64_t), uint64_t a4)
{
  sub_1CD4C5884(a2, a3, a4);
  sub_1CB8E509C(a2, "<");
  if (*a1)
  {
    if (*a1 != 1) {
      goto LABEL_6;
    }
    uint64_t v6 = "must";
  }
  else
  {
    uint64_t v6 = "may";
  }
  sub_1CB8E509C(a2, v6);
LABEL_6:

  return sub_1CB8E509C(a2, ">");
}

llvm::raw_ostream *sub_1CD4C5884(llvm::raw_ostream *a1, uint64_t (*a2)(uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v6 = sub_1CD4C76CC();
  unsigned int v9 = (const void *)a2(a3, v6, v7);
  size_t v10 = v8;
  uint64_t result = (llvm::raw_ostream *)*((void *)a1 + 4);
  if (v8 <= *((void *)a1 + 3) - (void)result)
  {
    if (v8)
    {
      uint64_t result = (llvm::raw_ostream *)memcpy(result, v9, v8);
      *((void *)a1 + 4) += v10;
    }
  }
  else
  {
    return llvm::raw_ostream::write(a1, (const char *)v9, v8);
  }
  return result;
}

uint64_t sub_1CD4C5930(uint64_t a1, _DWORD *a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x600000000;
  if (a2[2]) {
    sub_1CBAF13E8(a1, (uint64_t)a2);
  }
  int v4 = a2[16];
  *(void *)(a1 + 72) = a1 + 88;
  *(_DWORD *)(a1 + 64) = v4;
  *(void *)(a1 + 80) = 0x600000000;
  if (a2[20]) {
    sub_1CBAF13E8(a1 + 72, (uint64_t)(a2 + 18));
  }
  int v5 = a2[34];
  *(void *)(a1 + 144) = a1 + 160;
  *(_DWORD *)(a1 + 136) = v5;
  *(void *)(a1 + 152) = 0x600000000;
  if (a2[38]) {
    sub_1CBAF13E8(a1 + 144, (uint64_t)(a2 + 36));
  }
  int v6 = a2[52];
  *(void *)(a1 + 216) = a1 + 232;
  *(_DWORD *)(a1 + 208) = v6;
  *(void *)(a1 + 224) = 0x600000000;
  if (a2[56]) {
    sub_1CBAF13E8(a1 + 216, (uint64_t)(a2 + 54));
  }
  *(_DWORD *)(a1 + 280) = a2[70];
  return a1;
}

uint64_t sub_1CD4C5A08(uint64_t a1)
{
  int v2 = *(void **)(a1 + 216);
  if (v2 != (void *)(a1 + 232)) {
    free(v2);
  }
  unint64_t v3 = *(void **)(a1 + 144);
  if (v3 != (void *)(a1 + 160)) {
    free(v3);
  }
  int v4 = *(void **)(a1 + 72);
  if (v4 != (void *)(a1 + 88)) {
    free(v4);
  }
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  return a1;
}

void sub_1CD4C5A7C()
{
}

void sub_1CD4C5A90(uint64_t a1, uint64_t a2, llvm::raw_ostream *a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (sub_1CD3C8538((uint64_t *)(v5 + 568), &v8, &v7)) {
    uint64_t v6 = v7;
  }
  else {
    uint64_t v6 = *(void *)(v5 + 568) + 16 * *(unsigned int *)(v5 + 584);
  }
  if (v6 != *(void *)(*(void *)(a1 + 8) + 568) + 16 * *(unsigned int *)(*(void *)(a1 + 8) + 584)) {
    sub_1CD4C5B20(a1, *(_DWORD *)(v6 + 8), a3);
  }
}

void sub_1CD4C5B20(uint64_t a1, unsigned int a2, llvm::raw_ostream *a3)
{
  unint64_t v3 = a3;
  v28[32] = *MEMORY[0x1E4F143B8];
  __base = v28;
  uint64_t v27 = 0x1000000000;
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(_DWORD *)(v5 + 624);
  uint64_t v7 = *(void *)(v5 + 616);
  uint64_t v8 = *(unsigned int *)(v5 + 632);
  uint64_t v9 = v7 + 16 * v8;
  if (v6)
  {
    if (v8)
    {
      uint64_t v10 = 16 * v8;
      uint64_t v11 = v7;
      while ((*(void *)v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v11 += 16;
        v10 -= 16;
        if (!v10) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v11 = v7;
    }
  }
  else
  {
LABEL_6:
    uint64_t v11 = v7 + 16 * v8;
  }
  uint64_t v12 = v7 + 16 * v8;
  if (v11 != v12)
  {
    unsigned int v13 = 0;
    uint64_t v14 = 1 << a2;
    uint64_t v15 = a2 >> 6;
    do
    {
      if ((*(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 640) + 72 * *(unsigned int *)(v11 + 8))
                      + 8 * v15) & v14) != 0)
      {
        Name = llvm::Value::getName(*(llvm::Value **)v11);
        if (v13 >= HIDWORD(v27)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v18 = (char **)((char *)__base + 16 * v13);
        *int v18 = Name;
        v18[1] = v16;
        unsigned int v13 = v27 + 1;
        LODWORD(v27) = v27 + 1;
      }
      uint64_t v19 = v11 + 16;
      uint64_t v11 = v9;
      if (v19 != v9)
      {
        uint64_t v11 = v19;
        while ((*(void *)v11 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v11 += 16;
          if (v11 == v9)
          {
            uint64_t v11 = v9;
            break;
          }
        }
      }
    }
    while (v11 != v12);
    unint64_t v3 = a3;
    if (v13 >= 2) {
      qsort(__base, v13, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1CD4C5D78);
    }
  }
  unsigned int v20 = sub_1CB8E509C(v3, "  ; Alive: <");
  sub_1CC143D18(&__p, (uint64_t)__base, (uint64_t)__base + 16 * v27);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t size = __p.__r_.__value_.__l.__size_;
  }
  unint64_t v23 = llvm::raw_ostream::write(v20, (const char *)p_p, size);
  sub_1CB8E509C(v23, ">\n");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (__base != v28) {
    free(__base);
  }
}

uint64_t sub_1CD4C5D78(uint64_t a1, uint64_t a2)
{
  if (sub_1CC016A40((uint64_t)&v6, a1, a2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return sub_1CC016A40((uint64_t)&v5, a2, a1);
  }
}

void sub_1CD4C5DD0(uint64_t a1)
{
}

void sub_1CD4C5E04()
{
  uint64_t v1 = *(void **)(v0 + 1232);
  if (v1 != (void *)(v0 + 1248)) {
    free(v1);
  }
  sub_1CD4C5EDC((char **)(v0 + 640));
  llvm::deallocate_buffer(*(llvm **)(v0 + 616), (void *)(16 * *(unsigned int *)(v0 + 632)));
}

void sub_1CD4C5E34()
{
  llvm::deallocate_buffer(*(llvm **)(v0 + 568), (void *)(16 * *(unsigned int *)(v0 + 584)));
}

void sub_1CD4C5E48()
{
  uint64_t v1 = *(void **)(v0 + 40);
  if (v1 != (void *)(v0 + 56)) {
    free(v1);
  }
  sub_1CD4C5F54(v0 + 16);
}

uint64_t sub_1CD4C5E64()
{
  return v0;
}

void sub_1CD4C5E74(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 72 * v1;
    uint64_t v3 = *(void *)a1 + 24;
    do
    {
      if ((*(void *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4) {
          free(v4);
        }
      }
      v3 += 72;
      v2 -= 72;
    }
    while (v2);
  }
}

char **sub_1CD4C5EDC(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 72 * v3;
    do
    {
      char v5 = *(char **)&v2[v4 - 72];
      if (&v2[v4 - 56] != v5) {
        free(v5);
      }
      v4 -= 72;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD4C5F54(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  uint64_t v3 = *(llvm **)a1;
  if (v2)
  {
    uint64_t v4 = 296 * v2;
    uint64_t v5 = (uint64_t)v3 + 8;
    do
    {
      if ((*(void *)(v5 - 8) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v5 = sub_1CD4C5A08(v5);
      }
      v5 += 296;
      v4 -= 296;
    }
    while (v4);
    uint64_t v3 = *(llvm **)a1;
    uint64_t v6 = 296 * *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v6 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v6);
}

void sub_1CD4C5FD8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 16);
  uint64_t v3 = *(llvm **)a1;
  if (v2)
  {
    uint64_t v4 = 80 * v2;
    uint64_t v5 = (uint64_t)v3 + 8;
    do
    {
      if ((*(void *)(v5 - 8) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t v5 = sub_1CD4C605C(v5);
      }
      v5 += 80;
      v4 -= 80;
    }
    while (v4);
    uint64_t v3 = *(llvm **)a1;
    uint64_t v6 = 80 * *(unsigned int *)(a1 + 16);
  }
  else
  {
    uint64_t v6 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v6);
}

uint64_t sub_1CD4C605C(uint64_t result)
{
  if ((*(unsigned char *)result & 1) == 0) {
    llvm::deallocate_buffer(*(llvm **)(result + 8), (void *)(16 * *(unsigned int *)(result + 16)));
  }
  return result;
}

void *sub_1CD4C609C(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = 0;
  char v4 = sub_1CD4C612C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v9);
  uint64_t v5 = v9;
  if ((v4 & 1) == 0)
  {
    uint64_t v7 = sub_1CD4C61C8(a1, a2, v9);
    uint64_t v5 = v7;
    *uint64_t v7 = *a2;
    v7[1] = 1;
    for (uint64_t i = 2; i != 10; i += 2)
      v7[i] = -4096;
  }
  return v5;
}

uint64_t sub_1CD4C612C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 80 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 80 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD4C61C8(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4C627C(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4C612C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4C627C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(80 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4C635C(a1, (uint64_t)v4, (uint64_t)v4 + 80 * v3);
    llvm::deallocate_buffer(v4, (void *)(80 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 80 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 10;
      v11 -= 80;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4C635C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 80 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 10;
      v8 -= 80;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v14 = 0;
        sub_1CD4C612C(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v14);
        uint64_t v10 = 0;
        uint64_t v11 = v14;
        void *v14 = *(void *)v4;
        BOOL v12 = v11 + 2;
        v11[1] = 1;
        unsigned int v13 = (unsigned int *)(v11 + 1);
        do
        {
          v12[v10] = -4096;
          v10 += 2;
        }
        while (v10 != 8);
        sub_1CC143DC8(v13, (unsigned int *)(v4 + 8));
        ++*(_DWORD *)(v5 + 8);
        uint64_t result = sub_1CD4C605C(v4 + 8);
      }
      v4 += 80;
    }
    while (v4 != a3);
  }
  return result;
}

void *sub_1CD4C6460(_DWORD *a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4C64C4((uint64_t)a1, *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4C6570(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1CD4C64C4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      int v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  int v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      int v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      int v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD4C6570(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4C6630((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD4C64C4((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD4C6630(uint64_t a1, unsigned int a2)
{
  char v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = llvm::allocate_buffer(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4C67C0(a1, v6, &v6[2 * v7]);
    llvm::deallocate_buffer((llvm *)v6, (void *)(16 * v7));
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *uint64_t v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 64);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = llvm::allocate_buffer(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4C67C0(a1, v14, v9);
}

uint64_t sub_1CD4C67C0(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    *uint64_t v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v12 = 0;
      uint64_t result = sub_1CD4C64C4((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *BOOL v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

uint64_t sub_1CD4C688C(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 296 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 296 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD4C6928(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4C69DC(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4C688C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4C69DC(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(296 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4C6AC0(a1, (uint64_t)v4, (uint64_t)v4 + 296 * v3);
    llvm::deallocate_buffer(v4, (void *)(296 * v3));
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 296 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 37;
      v11 -= 296;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4C6AC0(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  unsigned int v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 296 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 37;
      v8 -= 296;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      sub_1CD4C688C(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      unsigned int v10 = v11;
      *uint64_t v11 = *(void *)a2;
      sub_1CD4C6B8C((uint64_t)(v10 + 1), (_DWORD *)(a2 + 8));
      ++*(_DWORD *)(v5 + 8);
      uint64_t result = sub_1CD4C5A08(a2 + 8);
    }
    a2 += 296;
  }
  return result;
}

uint64_t sub_1CD4C6B8C(uint64_t a1, _DWORD *a2)
{
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x600000000;
  if (a2[2]) {
    sub_1CB837F14(a1, (uint64_t)a2);
  }
  int v4 = a2[16];
  *(void *)(a1 + 72) = a1 + 88;
  *(_DWORD *)(a1 + 64) = v4;
  *(void *)(a1 + 80) = 0x600000000;
  if (a2[20]) {
    sub_1CB837F14(a1 + 72, (uint64_t)(a2 + 18));
  }
  int v5 = a2[34];
  *(void *)(a1 + 144) = a1 + 160;
  *(_DWORD *)(a1 + 136) = v5;
  *(void *)(a1 + 152) = 0x600000000;
  if (a2[38]) {
    sub_1CB837F14(a1 + 144, (uint64_t)(a2 + 36));
  }
  int v6 = a2[52];
  *(void *)(a1 + 216) = a1 + 232;
  *(_DWORD *)(a1 + 208) = v6;
  *(void *)(a1 + 224) = 0x600000000;
  if (a2[56]) {
    sub_1CB837F14(a1 + 216, (uint64_t)(a2 + 54));
  }
  *(_DWORD *)(a1 + 280) = a2[70];
  return a1;
}

uint64_t sub_1CD4C6C64(uint64_t a1, int a2)
{
  unint64_t v4 = (a2 + 63) >> 6;
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x600000000;
  sub_1CB90D610(a1, v4, 0);
  *(_DWORD *)(a1 + 64) = a2;
  *(void *)(a1 + 72) = a1 + 88;
  *(void *)(a1 + 80) = 0x600000000;
  sub_1CB90D610(a1 + 72, v4, 0);
  *(_DWORD *)(a1 + 136) = a2;
  *(void *)(a1 + 144) = a1 + 160;
  *(void *)(a1 + 152) = 0x600000000;
  sub_1CB90D610(a1 + 144, v4, 0);
  *(_DWORD *)(a1 + 208) = a2;
  *(void *)(a1 + 216) = a1 + 232;
  *(void *)(a1 + 224) = 0x600000000;
  sub_1CB90D610(a1 + 216, v4, 0);
  *(_DWORD *)(a1 + 280) = a2;
  return a1;
}

void *sub_1CD4C6D28(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD4C6D8C((uint64_t)a1, (uint64_t)a2, a2, v7);
    *int v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4C6D8C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4C6E3C(a1, v7);
  uint64_t v9 = 0;
  sub_1CD3C8538((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD4C6E3C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD475EA0(a1, v4, (void *)v4 + 2 * v3);
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void *sub_1CD4C6F10(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4A8B14(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD4C6F8C(a1, a2, v7);
    *unint64_t v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
  }
  return v5;
}

void *sub_1CD4C6F8C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4C7040(a1, v6);
  unsigned int v8 = 0;
  sub_1CD4A8B14(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4C7040(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(72 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4C7120(a1, (uint64_t)v4, (uint64_t)v4 + 72 * v3);
    llvm::deallocate_buffer(v4, (void *)(72 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 72 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 9;
      v11 -= 72;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4C7120(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 72 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 9;
      v8 -= 72;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CD4A8B14(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *unsigned int v13 = *(void *)v4;
        uint64_t v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (char **)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD4C721C(v11, (uint64_t **)(v4 + 8));
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 72;
    }
    while (v4 != a3);
  }
}

char **sub_1CD4C721C(char **a1, uint64_t **a2)
{
  if (a1 != (char **)a2)
  {
    unint64_t v5 = (uint64_t *)(a2 + 2);
    uint64_t v4 = (char *)*a2;
    if (*a2 == (uint64_t *)(a2 + 2))
    {
      int v7 = a2 + 1;
      unsigned int v9 = *((_DWORD *)a2 + 2);
      uint64_t v10 = *((unsigned int *)a1 + 2);
      if (v10 >= v9)
      {
        if (v9)
        {
          BOOL v12 = &v4[12 * v9];
          unsigned int v13 = *a1;
          do
          {
            *(_DWORD *)unsigned int v13 = *(_DWORD *)v4;
            *(void *)(v13 + 4) = *(void *)(v4 + 4);
            v4 += 12;
            v13 += 12;
          }
          while (v4 != v12);
        }
      }
      else
      {
        if (*((_DWORD *)a1 + 3) < v9)
        {
          *((_DWORD *)a1 + 2) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          uint64_t v14 = &v4[12 * v10];
          uint64_t v15 = *a1;
          do
          {
            *(_DWORD *)uint64_t v15 = *(_DWORD *)v4;
            *(void *)(v15 + 4) = *(void *)(v4 + 4);
            v4 += 12;
            v15 += 12;
          }
          while (v4 != v14);
        }
        else
        {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy(&(*a1)[12 * v10], (char *)*a2 + 12 * v10, (char *)*a2 + 12 * v11 - ((char *)*a2 + 12 * v10));
        }
      }
      *((_DWORD *)a1 + 2) = v9;
    }
    else
    {
      uint64_t v6 = *a1;
      if (*a1 != (char *)(a1 + 2))
      {
        free(v6);
        uint64_t v4 = (char *)*a2;
      }
      *a1 = v4;
      int v7 = a2 + 1;
      a1[1] = (char *)a2[1];
      *a2 = v5;
      *((_DWORD *)a2 + 3) = 0;
    }
    *int v7 = 0;
  }
  return a1;
}

void *sub_1CD4C7374(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD4C73D8((uint64_t)a1, a2, v7);
    *unint64_t v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void *sub_1CD4C73D8(uint64_t a1, void *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD41D8B8(a1, v6);
  uint64_t v8 = 0;
  sub_1CD3C8538((uint64_t *)a1, a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

unint64_t sub_1CD4C7488(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t result = sub_1CD4C7534(a1, a3, a2);
  if (a2)
  {
    uint64_t v6 = result;
    uint64_t v7 = *(void *)a1 + 72 * *(unsigned int *)(a1 + 8);
    uint64_t v8 = a2;
    do
    {
      *(void *)uint64_t v7 = v7 + 16;
      *(void *)(v7 + 8) = 0x600000000;
      if (*(_DWORD *)(v6 + 8)) {
        unint64_t result = sub_1CBAF13E8(v7, v6);
      }
      *(_DWORD *)(v7 + 64) = *(_DWORD *)(v6 + 64);
      v7 += 72;
      --v8;
    }
    while (v8);
  }
  *(_DWORD *)(a1 + 8) += a2;
  return result;
}

unint64_t sub_1CD4C7534(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 72 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD4C75A0();
    }
    sub_1CD4C75A0();
  }
  return a2;
}

void sub_1CD4C75A0()
{
}

void sub_1CD4C7610(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = 72 * v2;
    do
    {
      *(void *)a2 = a2 + 16;
      *(void *)(a2 + 8) = 0x600000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CB837F14(a2, v5);
      }
      *(_DWORD *)(a2 + 64) = *(_DWORD *)(v5 + 64);
      v5 += 72;
      a2 += 72;
      v6 -= 72;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = 72 * v7;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 72);
        if ((void *)(v8 + v9 - 56) != v10) {
          free(v10);
        }
        v9 -= 72;
      }
      while (v9);
    }
  }
}

const char *sub_1CD4C76CC()
{
  uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = llvm::StackLifetimePrinterPass]";
  unint64_t v11 = 80;
  unint64_t v0 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
  if (v11 >= v0) {
    unint64_t v1 = v0;
  }
  else {
    unint64_t v1 = v11;
  }
  uint64_t v2 = &v10[v1];
  unint64_t v3 = v11 - v1;
  if (v11 - v1 >= 0x12) {
    uint64_t v4 = 18;
  }
  else {
    uint64_t v4 = v11 - v1;
  }
  unint64_t result = &v2[v4];
  unint64_t v6 = v3 - v4;
  if (v6 >= v6 - 1) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = v6;
  }
  if (v7 >= 6 && *(_DWORD *)result == 1836477548 && *((_WORD *)result + 2) == 14906) {
    result += 6;
  }
  return result;
}

llvm::raw_ostream *llvm::StackSafetyInfo::print(llvm::StackSafetyInfo *this, llvm::raw_ostream *a2)
{
  Info = llvm::StackSafetyInfo::getInfo(this);
  uint64_t v5 = *(llvm::Value **)this;
  Name = llvm::Value::getName(v5);
  sub_1CC144998(Info, a2, Name, v7, (uint64_t)v5);

  return sub_1CB8E509C(a2, "\n");
}

uint64_t llvm::StackSafetyGlobalInfo::getInfo(llvm::StackSafetyGlobalInfo *this)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t result = *((void *)this + 6);
  if (!result)
  {
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v24 = &v25;
    uint64_t v3 = *(void *)this + 24;
    uint64_t v4 = *(void *)(*(void *)this + 32);
    if (v4 == v3) {
LABEL_35:
    }
      operator new();
    while (1)
    {
      if (v4) {
        uint64_t v5 = v4 - 56;
      }
      else {
        uint64_t v5 = 0;
      }
      if (v4 && *(unsigned char *)(v5 + 16) == 3)
      {
        if ((*(_DWORD *)(v5 + 20) & 0x7FFFFFF) != 0) {
          goto LABEL_11;
        }
      }
      else if (*(unsigned char *)(v5 + 16) || *(void *)(v5 + 72) != v5 + 72 || (*(unsigned char *)(v5 + 34) & 0x80) != 0)
      {
LABEL_11:
        uint64_t v6 = *((void *)this + 4);
        if (!v6) {
          sub_1CB920400();
        }
        size_t v7 = (llvm::StackSafetyInfo *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 48))(v6, v5);
        Info = llvm::StackSafetyInfo::getInfo(v7);
        sub_1CC145224(&v29, (uint64_t)Info);
        uint64_t v9 = (uint64_t *)operator new(0x60uLL);
        uint64_t v10 = v9;
        v27[0] = v9;
        v27[1] = &v25;
        LOBYTE(v28) = 0;
        unint64_t v11 = v29;
        BOOL v12 = v30;
        void v9[4] = v5;
        v9[5] = (uint64_t)v11;
        v9[6] = (uint64_t)v12;
        unsigned int v13 = (char *)(v9 + 6);
        uint64_t v14 = v31;
        unint64_t v9[7] = v31;
        if (v14)
        {
          uint64_t v12[2] = v13;
          uint64_t v29 = (uint64_t *)&v30;
          uint64_t v30 = 0;
          uint64_t v31 = 0;
        }
        else
        {
          v9[5] = (uint64_t)v13;
        }
        uint64_t v16 = v32;
        uint64_t v15 = v33;
        v9[9] = (uint64_t)v33;
        unsigned int v17 = (char *)(v9 + 9);
        v9[8] = (uint64_t)v16;
        uint64_t v18 = v34;
        v9[10] = v34;
        if (v18)
        {
          void v15[2] = v17;
          uint64_t v32 = &v33;
          uint64_t v33 = 0;
          uint64_t v34 = 0;
        }
        else
        {
          v9[8] = (uint64_t)v17;
        }
        *((_DWORD *)v9 + 22) = v35;
        LOBYTE(v28) = 1;
        uint64_t v19 = v25;
        unsigned int v20 = &v25;
        unint64_t v21 = &v25;
        if (v25)
        {
          unint64_t v22 = v9[4];
          do
          {
            while (1)
            {
              unint64_t v21 = (uint64_t **)v19;
              unint64_t v23 = v19[4];
              if (v22 >= v23) {
                break;
              }
              uint64_t v19 = (uint64_t *)*v19;
              unsigned int v20 = v21;
              if (!*v21) {
                goto LABEL_24;
              }
            }
            if (v23 >= v22) {
              goto LABEL_27;
            }
            uint64_t v19 = (uint64_t *)v19[1];
          }
          while (v19);
          unsigned int v20 = v21 + 1;
        }
LABEL_24:
        *uint64_t v9 = 0;
        v9[1] = 0;
        _OWORD v9[2] = (uint64_t)v21;
        *unsigned int v20 = v9;
        if (*v24)
        {
          uint64_t v24 = (uint64_t **)*v24;
          uint64_t v10 = *v20;
        }
        sub_1CB8358B8(v25, v10);
        ++v26;
        v27[0] = 0;
LABEL_27:
        sub_1CC14B950((uint64_t)v27);
        sub_1CC14A7DC(v33);
        sub_1CC14A7DC(v30);
      }
      uint64_t v4 = *(void *)(v4 + 8);
      if (v4 == v3) {
        goto LABEL_35;
      }
    }
  }
  return result;
}

void llvm::StackSafetyInfo::getParamAccesses(llvm::StackSafetyInfo *this@<X0>, llvm::ModuleSummaryIndex *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  Info = llvm::StackSafetyInfo::getInfo(this);
  uint64_t v6 = (uint64_t *)Info[3];
  size_t v7 = Info + 4;
  if (v6 != Info + 4)
  {
    do
    {
      if (!llvm::ConstantRange::isFullSet((const void **)v6 + 5))
      {
        sub_1CD4C883C(a3, *((_DWORD *)v6 + 8), (uint64_t)(v6 + 5));
        uint64_t v11 = a3[1] - 24;
        sub_1CD4C8898(v11, v6[14]);
        BOOL v12 = (const void **)v6[12];
        if (v12 != (const void **)(v6 + 13))
        {
          while (!llvm::ConstantRange::isFullSet(v12 + 6))
          {
            unsigned int v13 = (llvm::GlobalValue *)v12[4];
            unint64_t v14 = sub_1CD4AC784(v13);
            uint64_t v15 = sub_1CD4ADB54((uint64_t)a2, v14);
            *((void *)v15 + 1) = v13;
            sub_1CD4C89C0(v11, (uint64_t)v12[5], (unint64_t)v15 & 0xFFFFFFFFFFFFFFF8 | *((unsigned __int8 *)a2 + 133), (uint64_t)(v12 + 6));
            uint64_t v16 = (const void **)v12[1];
            if (v16)
            {
              do
              {
                unsigned int v17 = (const void ***)v16;
                uint64_t v16 = (const void **)*v16;
              }
              while (v16);
            }
            else
            {
              do
              {
                unsigned int v17 = (const void ***)v12[2];
                BOOL v10 = *v17 == v12;
                BOOL v12 = (const void **)v17;
              }
              while (!v10);
            }
            BOOL v12 = (const void **)v17;
            if (v17 == (const void ***)(v6 + 13)) {
              goto LABEL_3;
            }
          }
          uint64_t v18 = a3[1];
          uint64_t v25 = (void **)(v18 - 24);
          sub_1CC0C49BC(&v25);
          sub_1CC05EB8C(v18 - 56);
          a3[1] = v18 - 64;
        }
      }
LABEL_3:
      uint64_t v8 = (uint64_t *)v6[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (uint64_t *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          uint64_t v6 = v9;
        }
        while (!v10);
      }
      uint64_t v6 = v9;
    }
    while (v9 != v7);
    uint64_t v20 = *a3;
    for (uint64_t i = a3[1]; v20 != i; v20 += 64)
    {
      uint64_t v21 = *(void *)(v20 + 40);
      uint64_t v22 = *(void *)(v20 + 48);
      unint64_t v23 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 4));
      if (v22 == v21) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = v23;
      }
      sub_1CC14C7FC(v21, v22, v24, 1);
    }
  }
}

char *sub_1CD4C883C(uint64_t *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = (void *)a1[1];
  if ((unint64_t)v4 >= a1[2])
  {
    uint64_t result = sub_1CC14C314(a1, a2, a3);
  }
  else
  {
    *uint64_t v4 = a2;
    sub_1CC067C7C((uint64_t)(v4 + 1), a3);
    uint64_t result = (char *)(v4 + 8);
    v4[5] = 0;
    v4[6] = 0;
    v4[7] = 0;
  }
  a1[1] = (uint64_t)result;
  return result;
}

void sub_1CD4C8898(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556) {
      abort();
    }
    uint64_t v4 = *(unsigned char **)(a1 + 8);
    uint64_t v5 = 3 * a2;
    uint64_t v6 = (char *)operator new(48 * a2);
    size_t v7 = &v6[16 * v5];
    uint64_t v8 = &v6[v4 - v2];
    if (v4 == v2)
    {
      *(void *)a1 = v8;
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + 16) = v7;
    }
    else
    {
      uint64_t v9 = 0;
      do
      {
        BOOL v10 = &v8[v9];
        uint64_t v11 = &v4[v9];
        *((_OWORD *)v10 - 3) = *(_OWORD *)&v4[v9 - 48];
        *((_DWORD *)v10 - 6) = *(_DWORD *)&v4[v9 - 24];
        *((void *)v10 - 4) = *(void *)&v4[v9 - 32];
        *((_DWORD *)v11 - 6) = 0;
        *((_DWORD *)v10 - 2) = *(_DWORD *)&v4[v9 - 8];
        *((void *)v10 - 2) = *(void *)&v4[v9 - 16];
        *((_DWORD *)v11 - 2) = 0;
        v9 -= 48;
      }
      while (&v4[v9] != v2);
      *(void *)a1 = &v8[v9];
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + 16) = v7;
      do
      {
        sub_1CC05EB8C((uint64_t)(v4 - 32));
        v4 -= 48;
      }
      while (v4 != v2);
    }
    if (v2)
    {
      operator delete(v2);
    }
  }
}

char *sub_1CD4C89C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if ((unint64_t)v5 >= *(void *)(a1 + 16))
  {
    uint64_t result = sub_1CC14C570((void **)a1, a2, a3, a4);
  }
  else
  {
    *uint64_t v5 = a2;
    v5[1] = a3;
    sub_1CC067C7C((uint64_t)(v5 + 2), a4);
    uint64_t result = (char *)(v5 + 6);
  }
  *(void *)(a1 + 8) = result;
  return result;
}

void *llvm::StackSafetyGlobalInfo::operator=(void *a1, void *a2)
{
  *a1 = *a2;
  sub_1CC14FAE0(a1 + 1, (uint64_t)(a2 + 1));
  a1[5] = a2[5];
  uint64_t v4 = a2[6];
  a2[6] = 0;
  uint64_t v5 = a1[6];
  a1[6] = v4;
  if (v5)
  {
    uint64_t v7 = sub_1CD4C9FF0(v5);
    MEMORY[0x1D25D9CE0](v7, 0x10E0C40953490F3);
  }
  return a1;
}

void llvm::StackSafetyGlobalInfo::~StackSafetyGlobalInfo(llvm::StackSafetyGlobalInfo *this)
{
  uint64_t v2 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2)
  {
    uint64_t v4 = sub_1CD4C9FF0(v2);
    MEMORY[0x1D25D9CE0](v4, 0x10E0C40953490F3);
  }
  uint64_t v3 = (llvm::StackSafetyGlobalInfo *)*((void *)this + 4);
  if (v3 == (llvm::StackSafetyGlobalInfo *)((char *)this + 8))
  {
    (*(void (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8);
  }
  else if (v3)
  {
    (*(void (**)(llvm::StackSafetyGlobalInfo *))(*(void *)v3 + 40))(v3);
  }
}

BOOL llvm::StackSafetyGlobalInfo::isSafe(llvm::StackSafetyGlobalInfo *this, const llvm::AllocaInst *a2)
{
  uint64_t Info = llvm::StackSafetyGlobalInfo::getInfo(this);
  uint64_t v4 = sub_1CB896AE8(Info + 24, (uint64_t)a2);
  uint64_t v5 = *(void *)(Info + 32);
  if (v5 == *(void *)(Info + 24)) {
    uint64_t v6 = (unsigned int *)(Info + 44);
  }
  else {
    uint64_t v6 = (unsigned int *)(Info + 40);
  }
  return v4 != (void *)(v5 + 8 * *v6);
}

BOOL llvm::StackSafetyGlobalInfo::stackAccessIsSafe(llvm::StackSafetyGlobalInfo *this, const llvm::Instruction *a2)
{
  uint64_t Info = llvm::StackSafetyGlobalInfo::getInfo(this);
  uint64_t v6 = *(void **)(Info + 128);
  uint64_t v4 = Info + 128;
  uint64_t v5 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = (void *)v4;
  do
  {
    unint64_t v8 = v5[4];
    BOOL v9 = v8 >= (unint64_t)a2;
    if (v8 >= (unint64_t)a2) {
      BOOL v10 = v5;
    }
    else {
      BOOL v10 = v5 + 1;
    }
    if (v9) {
      uint64_t v7 = v5;
    }
    uint64_t v5 = (void *)*v10;
  }
  while (*v10);
  if (v7 == (void *)v4 || v7[4] > (unint64_t)a2) {
LABEL_12:
  }
    uint64_t v7 = (void *)v4;
  return v7 == (void *)v4;
}

void llvm::StackSafetyGlobalInfo::dump(llvm::StackSafetyGlobalInfo *this)
{
  uint64_t v2 = llvm::dbgs(this);

  llvm::StackSafetyGlobalInfo::print(this, v2);
}

void llvm::StackSafetyAnalysis::run(uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  a3[3] = a1;
  a3[4] = a3 + 1;
  *a3 = a1;
  a3[1] = &unk_1F2607938;
  a3[2] = a2;
  a3[5] = 0;
}

void llvm::StackSafetyPrinterPass::run(llvm::raw_ostream **a1, llvm::Value *a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "'Stack Safety Local Analysis' for function '");
  Name = llvm::Value::getName(a2);
  size_t v6 = v4;
  uint64_t v7 = (void *)*((void *)v3 + 4);
  if (v4 <= *((void *)v3 + 3) - (void)v7)
  {
    if (v4)
    {
      memcpy(v7, Name, v4);
      *((void *)v3 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v3, Name, v4);
  }
  sub_1CB8E509C(v3, "'\n");
  llvm::AnalysisManager<llvm::Function>::getResultImpl();
}

llvm::StackSafetyInfoWrapperPass *llvm::StackSafetyInfoWrapperPass::StackSafetyInfoWrapperPass(llvm::StackSafetyInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::StackSafetyInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 2;
  *(void *)this = &unk_1F26077C8;
  *((void *)this + 4) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8140, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC1478AC;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCC8140, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeStackSafetyInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8140, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC1478AC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC8140, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::AnalysisUsage *llvm::StackSafetyInfoWrapperPass::getAnalysisUsage(llvm::StackSafetyInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  uint64_t result = llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::ScalarEvolutionWrapperPass::ID);
  *((unsigned char *)a2 + 160) = 1;
  return result;
}

llvm::raw_ostream *llvm::StackSafetyInfoWrapperPass::print(llvm::StackSafetyInfoWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  return llvm::StackSafetyInfo::print((llvm::StackSafetyInfoWrapperPass *)((char *)this + 32), a2);
}

void llvm::StackSafetyGlobalPrinterPass::run(llvm::raw_ostream **a1, uint64_t a2)
{
  uint64_t v3 = sub_1CB8E509C(*a1, "'Stack Safety Analysis' for module '");
  size_t v4 = v3;
  char v5 = *(unsigned char *)(a2 + 191);
  if (v5 >= 0) {
    size_t v6 = (const void *)(a2 + 168);
  }
  else {
    size_t v6 = *(const void **)(a2 + 168);
  }
  if (v5 >= 0) {
    size_t v7 = v5 & 0x7F;
  }
  else {
    size_t v7 = *(void *)(a2 + 176);
  }
  uint64_t v9 = *((void *)v3 + 3);
  unint64_t v8 = (void *)*((void *)v3 + 4);
  if (v7 <= v9 - (uint64_t)v8)
  {
    if (v7)
    {
      memcpy(v8, v6, v7);
      *((void *)v4 + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(v4, (const char *)v6, v7);
  }
  sub_1CB8E509C(v4, "'\n");
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

llvm::StackSafetyGlobalInfoWrapperPass *llvm::StackSafetyGlobalInfoWrapperPass::StackSafetyGlobalInfoWrapperPass(llvm::StackSafetyGlobalInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::StackSafetyGlobalInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2607868;
  *((void *)this + 4) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8148, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC147950;
    v5[1] = &PassRegistry;
    size_t v4 = v5;
    std::__call_once(&qword_1EBCC8148, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeStackSafetyGlobalInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8148, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC147950;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC8148, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::StackSafetyGlobalInfoWrapperPass::print(llvm::StackSafetyGlobalInfoWrapperPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

llvm::AnalysisUsage *llvm::StackSafetyGlobalInfoWrapperPass::getAnalysisUsage(llvm::StackSafetyGlobalInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  return llvm::AnalysisUsage::addRequiredID(a2, llvm::StackSafetyInfoWrapperPass::ID);
}

uint64_t sub_1CD4C91FC(uint64_t *a1)
{
  unint64_t v2 = a1[1];
  if (v2 >= a1[2])
  {
    uint64_t v3 = sub_1CC150B7C(a1);
  }
  else
  {
    *(_OWORD *)unint64_t v2 = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_DWORD *)(v2 + 16) = 64;
    *(void *)(v2 + 8) = -1;
    *(void *)(v2 + 24) = -1;
    *(void *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 32) = 64;
    uint64_t v3 = v2 + 64;
    *(void *)(v2 + 48) = 0;
    *(void *)(v2 + 56) = 0;
    *(void *)(v2 + 40) = 0;
  }
  a1[1] = v3;
  return v3 - 64;
}

void sub_1CD4C9268(uint64_t a1)
{
  *(void *)a1 = &unk_1F26077C8;
  llvm::StackSafetyInfo::~StackSafetyInfo((llvm::StackSafetyInfo *)(a1 + 32));

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CD4C92BC(uint64_t a1)
{
  *(void *)a1 = &unk_1F26077C8;
  llvm::StackSafetyInfo::~StackSafetyInfo((llvm::StackSafetyInfo *)(a1 + 32));
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CD4C9324(uint64_t *result, unint64_t a2, uint64_t a3)
{
  size_t v4 = result;
  size_t v6 = (uint64_t **)(result + 1);
  char v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        size_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        char v5 = *v7;
        size_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      char v5 = v7[1];
      if (!v5)
      {
        size_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    size_t v7 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x28uLL);
    void v9[4] = a3;
    *uint64_t v9 = 0;
    v9[1] = 0;
    _OWORD v9[2] = (uint64_t)v7;
    *size_t v6 = v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *size_t v4 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = v9;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

uint64_t sub_1CD4C93DC(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

void *sub_1CD4C93F8(uint64_t a1, uint64_t *a2)
{
  size_t v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  char v5 = v7;
  if ((v4 & 1) == 0)
  {
    char v5 = sub_1CD4C9474(a1, a2, v7);
    *char v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
  }
  return v5;
}

void *sub_1CD4C9474(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4C9528(a1, v6);
  unint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4C9528(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4C9600(a1, v4, v4 + 56 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4C9600(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *unsigned int v13 = *(void *)v4;
        uint64_t v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CBA6E388(v11, (const void **)(v4 + 8));
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD4C96F8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD4C9788(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4C981C(a2, a3, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a3;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a2 + 8 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 16) = v8;
  return result;
}

uint64_t sub_1CD4C9788(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 8 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 8 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD4C981C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4C98D0(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4C9788(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4C98D0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4C999C(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4C999C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD4C9788(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v10);
      uint64_t *v10 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD4C9A4C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v4 = 0;
  uint64_t result = sub_1CD4C9788(*(void *)a1, *(_DWORD *)(a1 + 16), *(void *)(v2 - 8), &v4);
  if (result)
  {
    *int v4 = -8192;
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  *(void *)(a1 + 32) -= 8;
  return result;
}

void llvm::callDefaultCtor<llvm::StackSafetyInfoWrapperPass>()
{
}

void llvm::callDefaultCtor<llvm::StackSafetyGlobalInfoWrapperPass>()
{
}

void sub_1CD4C9B38(int **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCC8150, 0, 0);
  dword_1EBCC81D0 = 0;
  qword_1EBCC81D8 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCC81E0 = 0;
  qword_1EBCC8150 = (uint64_t)&unk_1F2643F68;
  qword_1EBCC81E8 = (uint64_t)&unk_1F2643D20;
  qword_1EBCC81F0 = (uint64_t)&unk_1F25F7480;
  qword_1EBCC8208 = (uint64_t)&qword_1EBCC81F0;
  llvm::cl::Option::setArgStr(v4, "stack-safety-max-iterations", 0x1BuLL);
  uint64_t v5 = *a1;
  dword_1EBCC81D0 = **a1;
  byte_1EBCC81E4 = 1;
  dword_1EBCC81E0 = *v5;
  word_1EBCC815A = (32 * (*a2 & 3)) | word_1EBCC815A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC8150);
}

void sub_1CD4C9C58(char **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCC8210, 0, 0);
  byte_1EBCC8290 = 0;
  qword_1EBCC8298 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC82A0 = 0;
  qword_1EBCC8210 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC82A8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC82B0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC82C8 = (uint64_t)&qword_1EBCC82B0;
  llvm::cl::Option::setArgStr(v4, "stack-safety-print", 0x12uLL);
  uint64_t v5 = *a1;
  byte_1EBCC8290 = **a1;
  byte_1EBCC82A1 = 1;
  byte_1EBCC82A0 = *v5;
  word_1EBCC821A = (32 * (*a2 & 3)) | word_1EBCC821A & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC8210);
}

void sub_1CD4C9D78(char **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCC82D0, 0, 0);
  byte_1EBCC8350 = 0;
  qword_1EBCC8358 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC8360 = 0;
  qword_1EBCC82D0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC8368 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC8370 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC8388 = (uint64_t)&qword_1EBCC8370;
  llvm::cl::Option::setArgStr(v4, "stack-safety-run", 0x10uLL);
  uint64_t v5 = *a1;
  byte_1EBCC8350 = **a1;
  byte_1EBCC8361 = 1;
  byte_1EBCC8360 = *v5;
  word_1EBCC82DA = (32 * (*a2 & 3)) | word_1EBCC82DA & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC82D0);
}

void sub_1CD4C9E9C()
{
}

llvm::raw_ostream *sub_1CD4C9EB0(uint64_t a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  return sub_1CD4C9EB8(*(unsigned int **)(a1 + 8), a2, a3, a4);
}

llvm::raw_ostream *sub_1CD4C9EB8(unsigned int *a1, llvm::raw_ostream *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  int v14 = 0;
  if (sub_1CD465E40(&v15, &v14))
  {
    int v7 = v14;
    unint64_t v17 = 0;
    if (llvm::consumeUnsignedInteger((llvm *)&v15, (llvm::StringRef *)0xA, &v17, v6)) {
      unint64_t v8 = 0;
    }
    else {
      unint64_t v8 = v17;
    }
    if (llvm::isPrefixedHexStyle(v7)) {
      unint64_t v9 = v8 + 2;
    }
    else {
      unint64_t v9 = v8;
    }
    return llvm::write_hex(a2, *a1, v14, v9, 1);
  }
  if (v16)
  {
    int v11 = 0;
    unsigned int v12 = *v15;
    if (v12 <= 0x63)
    {
      if (v12 != 68)
      {
        if (v12 != 78) {
          goto LABEL_20;
        }
        goto LABEL_17;
      }
LABEL_18:
      int v11 = 0;
      ++v15;
      goto LABEL_19;
    }
    if (v12 == 100) {
      goto LABEL_18;
    }
    if (v12 == 110)
    {
LABEL_17:
      ++v15;
      int v11 = 1;
LABEL_19:
      --v16;
    }
  }
  else
  {
    int v11 = 0;
  }
LABEL_20:
  unint64_t v17 = 0;
  if (llvm::consumeUnsignedInteger((llvm *)&v15, (llvm::StringRef *)0xA, &v17, v6)) {
    size_t v13 = 0;
  }
  else {
    size_t v13 = v17;
  }
  return llvm::write_integer(a2, *a1, v13, v11);
}

uint64_t sub_1CD4C9FF0(uint64_t a1)
{
  sub_1CD40B1BC(*(void **)(a1 + 128));
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2 != *(void **)(a1 + 24)) {
    free(v2);
  }
  sub_1CC14BE8C(*(void **)(a1 + 8));
  return a1;
}

uint64_t **sub_1CD4CA034(void **a1, void *a2, unint64_t a3, uint64_t *a4)
{
  uint64_t result = (uint64_t **)sub_1CD4CA0D8(a1, a2, &v13, &v12, a3);
  if (!*result)
  {
    int v7 = result;
    unint64_t v8 = (uint64_t *)operator new(0x28uLL);
    uint64_t v8[4] = *a4;
    uint64_t v9 = v13;
    *unint64_t v8 = 0;
    v8[1] = 0;
    uint64_t v8[2] = v9;
    *int v7 = v8;
    uint64_t v10 = (void *)**a1;
    if (v10)
    {
      *a1 = v10;
      int v11 = *v7;
    }
    else
    {
      int v11 = v8;
    }
    uint64_t result = (uint64_t **)sub_1CB8358B8(a1[1], v11);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return result;
}

void *sub_1CD4CA0D8(void *a1, void *a2, void *a3, void *a4, unint64_t a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = a2[4], v6 > a5))
  {
    uint64_t v7 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v9 = a2;
    }
    else
    {
      if (v7)
      {
        unint64_t v8 = (void *)*a2;
        do
        {
          uint64_t v9 = v8;
          unint64_t v8 = (void *)v8[1];
        }
        while (v8);
      }
      else
      {
        uint64_t v13 = a2;
        do
        {
          uint64_t v9 = (void *)v13[2];
          BOOL v14 = *v9 == (void)v13;
          uint64_t v13 = v9;
        }
        while (v14);
      }
      if (v9[4] >= a5)
      {
        uint64_t v15 = (void *)*v5;
        if (*v5)
        {
          do
          {
            while (1)
            {
              a4 = v15;
              unint64_t v16 = v15[4];
              if (v16 <= a5) {
                break;
              }
              uint64_t v15 = (void *)*a4;
              uint64_t v5 = a4;
              if (!*a4) {
                goto LABEL_36;
              }
            }
            if (v16 >= a5) {
              break;
            }
            uint64_t v5 = a4 + 1;
            uint64_t v15 = (void *)a4[1];
          }
          while (v15);
LABEL_27:
          *a3 = a4;
          return v5;
        }
        goto LABEL_44;
      }
    }
    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  else
  {
    if (v6 >= a5)
    {
      *a3 = a2;
      *a4 = a2;
      return a4;
    }
    uint64_t v10 = a2[1];
    if (v10)
    {
      int v11 = (void *)a2[1];
      do
      {
        a4 = v11;
        int v11 = (void *)*v11;
      }
      while (v11);
    }
    else
    {
      unint64_t v17 = a2;
      do
      {
        a4 = (void *)v17[2];
        BOOL v14 = *a4 == (void)v17;
        unint64_t v17 = a4;
      }
      while (!v14);
    }
    if (a4 != v5 && a4[4] <= a5)
    {
      uint64_t v18 = (void *)*v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            a4 = v18;
            unint64_t v19 = v18[4];
            if (v19 <= a5) {
              break;
            }
            uint64_t v18 = (void *)*a4;
            uint64_t v5 = a4;
            if (!*a4) {
              goto LABEL_36;
            }
          }
          if (v19 >= a5) {
            break;
          }
          uint64_t v5 = a4 + 1;
          uint64_t v18 = (void *)a4[1];
        }
        while (v18);
        goto LABEL_27;
      }
LABEL_44:
      *a3 = v5;
      return v5;
    }
    if (v10)
    {
LABEL_36:
      *a3 = a4;
    }
    else
    {
      *a3 = a2;
      return a2 + 1;
    }
  }
  return a4;
}

uint64_t sub_1CD4CA25C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    uint64_t v5 = (void **)(i - 24);
    sub_1CC0C49BC(&v5);
    sub_1CC05EB8C(i - 56);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

llvm::SyncDependenceAnalysis *llvm::SyncDependenceAnalysis::SyncDependenceAnalysis(llvm::SyncDependenceAnalysis *this, const llvm::DominatorTree *a2, const llvm::PostDominatorTree *a3, const llvm::LoopInfo *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *((void *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_DWORD *)this + 14) = 1065353216;
  *((void *)this + 8) = a2;
  *((void *)this + 9) = a3;
  *((void *)this + 13) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = a4;
  *((void *)this + 11) = (char *)this + 96;
  uint64_t v6 = *(void *)(**(void **)a2 + 56);
  v17[0] = &unk_1F2607A58;
  v17[1] = this;
  uint64_t v18 = v17;
  v16[0] = 0;
  v16[1] = 0;
  unint64_t v14 = 0;
  uint64_t v15 = v16;
  std::string __p = 0;
  uint64_t v13 = 0;
  sub_1CBF7ACFC((uint64_t)&__p, 0x18uLL);
  uint64_t v7 = *(void *)(v6 + 80);
  if (v7) {
    uint64_t v8 = v7 - 24;
  }
  else {
    uint64_t v8 = 0;
  }
  v19[0] = v8;
  uint64_t v9 = v13;
  if ((unint64_t)v13 >= v14)
  {
    uint64_t v10 = sub_1CBC13470(&__p, v19);
  }
  else
  {
    *uint64_t v13 = v8;
    uint64_t v10 = v9 + 1;
  }
  uint64_t v13 = v10;
  if (v18)
  {
    if (v18 == v17)
    {
      uint64_t v20 = v19;
      (*(void (**)(void *, void *))(v17[0] + 24))(v17, v19);
    }
    else
    {
      uint64_t v20 = (void *)(*(uint64_t (**)(void))(*v18 + 16))();
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  sub_1CC150DAC((char **)&__p, (uint64_t *)a4, 0, v19, (uint64_t)&v15);
  if (v20 == v19)
  {
    (*(void (**)(void *))(v19[0] + 32))(v19);
  }
  else if (v20)
  {
    (*(void (**)(void))(*v20 + 40))();
  }
  if (__p)
  {
    uint64_t v13 = __p;
    operator delete(__p);
  }
  sub_1CD40B1BC(v16[0]);
  if (v18 == v17)
  {
    (*(void (**)(void *))(v17[0] + 32))(v17);
  }
  else if (v18)
  {
    (*(void (**)(void))(*v18 + 40))();
  }
  return this;
}

uint64_t *llvm::SyncDependenceAnalysis::getJoinBlocks(llvm::SyncDependenceAnalysis *this, const llvm::Instruction *a2)
{
  if (llvm::Instruction::getNumSuccessors(a2) < 2) {
    return &llvm::SyncDependenceAnalysis::EmptyDivergenceDesc;
  }
  uint64_t v6 = (void *)*((void *)this + 12);
  if (!v6) {
    goto LABEL_16;
  }
  uint64_t v7 = (void *)((char *)this + 96);
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= (unint64_t)a2;
    if (v8 >= (unint64_t)a2) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v6 + 1;
    }
    if (v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = (void *)*v10;
  }
  while (*v10);
  if (v7 == (void *)((char *)this + 96) || v7[4] > (unint64_t)a2) {
LABEL_16:
  }
    sub_1CD4CAB40(v11, this, *((void *)this + 8), *((void *)this + 9), *((void *)this + 10), *((void *)a2 + 5));
  return (uint64_t *)v7[5];
}

uint64_t sub_1CD4CA6AC@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t v36[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)a1[3];
  uint64_t v4 = (void *)a1[4];
  uint64_t v34 = 0;
  v35[0] = v4;
  uint64_t result = sub_1CB834D78(v3, v35, &v34);
  uint64_t v6 = 0;
  if (result) {
    uint64_t v6 = *(void **)(v34 + 8);
  }
  int v7 = ((*(void *)(*a1 + 8) - *(void *)*a1) >> 3) - 1;
  uint64_t v8 = a1[4];
  uint64_t v9 = *(void *)(v8 + 40);
  if (v9 != v8 + 40)
  {
    uint64_t v10 = v9 ? (unsigned __int8 *)(v9 - 24) : 0;
    if (v10[16] - 29 <= 0xA)
    {
      uint64_t result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v10);
      if (result)
      {
        int v11 = result;
        LODWORD(v12) = 0;
        for (unsigned int i = 0; i != v11; ++i)
        {
          uint64_t Successor = (void *)llvm::Instruction::getSuccessor((llvm::Instruction *)v10, i);
          uint64_t result = (uint64_t)sub_1CD4CAC44((void *)(*a1 + 24), (unint64_t)Successor);
          uint64_t v15 = *(unsigned int *)(result + 24);
          *(void *)(a1[5] + 8 * v15) = Successor;
          if ((int)v12 <= (int)v15) {
            uint64_t v12 = v15;
          }
          else {
            uint64_t v12 = v12;
          }
          if ((int)v15 < v7) {
            int v7 = v15;
          }
          if (v6)
          {
            unint64_t v16 = (uint64_t *)a1[3];
            uint64_t v34 = 0;
            v35[0] = Successor;
            uint64_t result = sub_1CB834D78(v16, v35, &v34);
            if ((result & 1) != 0 && (unint64_t v17 = *(void **)(v34 + 8)) != 0)
            {
              while (v17 != v6)
              {
                if (!v17) {
                  goto LABEL_21;
                }
                unint64_t v17 = (void *)*v17;
              }
            }
            else
            {
LABEL_21:
              uint64_t result = (uint64_t)sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1[8] + 64), (uint64_t)Successor);
            }
          }
        }
        goto LABEL_23;
      }
    }
  }
  if (v7 <= 0)
  {
    uint64_t v12 = 0;
LABEL_23:
    unint64_t v18 = 0;
    do
    {
      unint64_t v19 = *(void *)(a1[5] + 8 * v12);
      if (v19)
      {
        uint64_t v20 = *(void **)(*(void *)*a1 + 8 * v12);
        uint64_t v21 = (uint64_t *)a1[3];
        uint64_t v34 = 0;
        v35[0] = v20;
        uint64_t result = sub_1CB834D78(v21, v35, &v34);
        if (result)
        {
          uint64_t v22 = *(void *)(v34 + 8);
          if (v22)
          {
            if (**(void ***)(v22 + 32) == v20)
            {
              v35[0] = v36;
              v35[1] = (void *)0x400000000;
              llvm::LoopBase<llvm::BasicBlock,llvm::Loop>::getExitBlocks();
            }
          }
        }
        unint64_t v23 = (void *)v20[5];
        int v24 = v7;
        if (v23 == v20 + 5) {
          goto LABEL_39;
        }
        uint64_t v25 = v23 ? (unsigned __int8 *)(v23 - 3) : 0;
        int v24 = v7;
        if (v25[16] - 29 > 0xA) {
          goto LABEL_39;
        }
        uint64_t result = llvm::Instruction::getNumSuccessors((llvm::Instruction *)v25);
        int v24 = v7;
        if (!result) {
          goto LABEL_39;
        }
        int v26 = result;
        int v27 = 0;
        unsigned int v28 = 0;
        int v33 = v7;
        int v24 = v7;
        do
        {
          unint64_t v29 = llvm::Instruction::getSuccessor((llvm::Instruction *)v25, v28);
          v27 |= sub_1CC151C14(a1, v29, v19);
          uint64_t result = (uint64_t)sub_1CD4CAC44((void *)(*a1 + 24), v29);
          if (*(_DWORD *)(result + 24) < v24) {
            int v24 = *(_DWORD *)(result + 24);
          }
          ++v28;
        }
        while (v26 != v28);
        int v7 = v33;
        if ((v27 & 1) == 0)
        {
LABEL_39:
          if (v18 != v19) {
            int v7 = v24;
          }
          goto LABEL_44;
        }
        int v7 = v24;
      }
      unint64_t v19 = v18;
LABEL_44:
      BOOL v30 = v12-- <= v7;
      unint64_t v18 = v19;
    }
    while (!v30);
  }
  uint64_t v31 = a1[8];
  a1[8] = 0;
  *a2 = v31;
  return result;
}

void **sub_1CD4CAA70(void **a1)
{
  uint64_t v2 = a1[9];
  if (v2 != a1[8]) {
    free(v2);
  }
  uint64_t v3 = a1[1];
  if (v3 != *a1) {
    free(v3);
  }
  return a1;
}

uint64_t sub_1CD4CAAB8(uint64_t a1)
{
  sub_1CD4CAAF4(a1 + 24);
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1CD4CAAF4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void sub_1CD4CAB40(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  a1[3] = a5;
  a1[4] = a6;
  uint64_t v6 = ((a2[1] - *a2) >> 3);
  uint64_t v7 = 0;
  sub_1CD4CABD8(a1 + 5, v6, &v7);
  operator new();
}

void *sub_1CD4CABD8(void *a1, uint64_t a2, uint64_t *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    uint64_t v6 = 8 * a2;
    uint64_t v7 = operator new(8 * a2);
    *a1 = v7;
    a1[1] = v7;
    uint64_t v8 = &v7[a2];
    a1[2] = v8;
    uint64_t v9 = *a3;
    do
    {
      *v7++ = v9;
      v6 -= 8;
    }
    while (v6);
    a1[1] = v8;
  }
  return a1;
}

void *sub_1CD4CAC44(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v5;
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v5 == v10)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *sub_1CD4CAD30(void *a1)
{
  int8x8_t v2 = (void **)a1[8];
  a1[8] = 0;
  if (v2)
  {
    unint64_t v5 = sub_1CD4CAA70(v2);
    MEMORY[0x1D25D9CE0](v5, 0x10C0C408B65D6DCLL);
  }
  unint64_t v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1CD4CAD8C(void *a1)
{
  if (a1)
  {
    sub_1CD4CAD8C(*a1);
    sub_1CD4CAD8C(a1[1]);
    unint64_t v3 = (void **)a1[5];
    a1[5] = 0;
    if (v3)
    {
      unint64_t v4 = sub_1CD4CAA70(v3);
      MEMORY[0x1D25D9CE0](v4, 0x10C0C408B65D6DCLL);
    }
    operator delete(a1);
  }
}

void *sub_1CD4CAE00(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = (*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v7 = a2;
  *((_DWORD *)sub_1CC151E74(a1 + 24, a2, &v7) + 6) = v4;
  unint64_t v7 = a2;
  unint64_t v5 = *(unint64_t **)(a1 + 8);
  if ((unint64_t)v5 >= *(void *)(a1 + 16))
  {
    uint64_t result = sub_1CBC13470((void **)a1, &v7);
  }
  else
  {
    *unint64_t v5 = a2;
    uint64_t result = v5 + 1;
  }
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t **sub_1CD4CAE78(uint64_t **a1, unint64_t *a2, uint64_t **a3, uint64_t **a4)
{
  uint64_t v8 = a1 + 1;
  unint64_t v7 = a1[1];
  if (v7)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v10 = (uint64_t **)v7;
        unint64_t v11 = v7[4];
        if (v9 >= v11) {
          break;
        }
        unint64_t v7 = *v10;
        uint64_t v8 = v10;
        if (!*v10) {
          goto LABEL_10;
        }
      }
      if (v11 >= v9) {
        break;
      }
      unint64_t v7 = v10[1];
      if (!v7)
      {
        uint64_t v8 = v10 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unint64_t v10 = a1 + 1;
LABEL_10:
    uint64_t v12 = (uint64_t *)v10;
    unint64_t v10 = (uint64_t **)operator new(0x30uLL);
    uint64_t v13 = *a3;
    unint64_t v14 = *a4;
    *a4 = 0;
    _OWORD v10[4] = v13;
    v10[5] = v14;
    unsigned __int8 *v10 = 0;
    v10[1] = 0;
    uint64_t v10[2] = v12;
    *uint64_t v8 = (uint64_t *)v10;
    uint64_t v15 = (uint64_t *)**a1;
    unint64_t v16 = (uint64_t *)v10;
    if (v15)
    {
      *a1 = v15;
      unint64_t v16 = *v8;
    }
    sub_1CB8358B8(a1[1], v16);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

void llvm::SyntheticCountsUtils<llvm::CallGraph const*>::propagate(uint64_t a1)
{
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  uint64_t v6 = 0;
  sub_1CD4CB48C(a1, (unint64_t)v1);
  while (v2 != v3)
  {
    sub_1CC152198(&v4, (uint64_t)&v2);
    sub_1CC152B90((unint64_t)v1);
  }
  sub_1CD4750A4(v1);
  if (v5 != v4) {
    llvm::SyntheticCountsUtils<llvm::CallGraph const*>::propagateFromSCC();
  }
  v1[0] = (void **)&v4;
  sub_1CBF7EDF0(v1);
}

uint64_t llvm::SyntheticCountsUtils<llvm::CallGraph const*>::propagateFromSCC(uint64_t **a1, void (*a2)(unint64_t *__return_ptr, uint64_t, void, void), uint64_t a3, void (*a4)(uint64_t, void, unint64_t, uint64_t), uint64_t a5)
{
  v63[16] = *MEMORY[0x1E4F143B8];
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  unsigned int v54 = 0;
  long long v61 = (char *)v63;
  uint64_t v62 = 0x800000000;
  int8x16_t v58 = v60;
  uint64_t v59 = 0x800000000;
  uint64_t v8 = *a1;
  unint64_t v7 = a1[1];
  if (*a1 == v7)
  {
    unsigned int v10 = 0;
    unint64_t v9 = 0;
  }
  else
  {
    do
      sub_1CD4C96F8((uint64_t)&v55, (uint64_t)&v52, v8++);
    while (v8 != v7);
    unint64_t v9 = v52;
    unsigned int v10 = v54;
    if (v53)
    {
      unint64_t v11 = &v52[v54];
      if (v54)
      {
        uint64_t v12 = 0;
        while ((v52[v12] | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          if (v54 == ++v12)
          {
            uint64_t v13 = &v52[v54];
            goto LABEL_11;
          }
        }
        uint64_t v13 = &v52[v12];
      }
      else
      {
        uint64_t v13 = v52;
      }
      goto LABEL_11;
    }
  }
  uint64_t v13 = &v9[v10];
  unint64_t v11 = v13;
LABEL_11:
  unint64_t v14 = &v9[v10];
  if (v13 == v14) {
    goto LABEL_34;
  }
  unsigned int v15 = v10 - 1;
  do
  {
    uint64_t v17 = *(void *)(*v13 + 16);
    uint64_t v16 = *(void *)(*v13 + 24);
    while (v17 != v16)
    {
      if (v10)
      {
        uint64_t v18 = *(void *)(v17 + 32);
        unsigned int v19 = ((v18 >> 4) ^ (v18 >> 9)) & v15;
        uint64_t v20 = v9[v19];
        if (v18 == v20)
        {
LABEL_17:
          int v21 = v62;
          if (v62 < HIDWORD(v62))
          {
            uint64_t v22 = &v61[16 * v62];
            *(void *)uint64_t v22 = *v13;
            *((void *)v22 + 1) = v17;
            LODWORD(v62) = v21 + 1;
            goto LABEL_19;
          }
          uint64_t v27 = *v13;
          unsigned int v28 = (void **)&v61;
          goto LABEL_33;
        }
        int v26 = 1;
        while (v20 != -4096)
        {
          unsigned int v45 = v19 + v26++;
          unsigned int v19 = v45 & v15;
          uint64_t v20 = v9[v19];
          if (v18 == v20) {
            goto LABEL_17;
          }
        }
      }
      int v23 = v59;
      if (v59 < HIDWORD(v59))
      {
        int v24 = (uint64_t *)((char *)v58 + 16 * v59);
        uint64_t *v24 = *v13;
        v24[1] = v17;
        LODWORD(v59) = v23 + 1;
        goto LABEL_19;
      }
      uint64_t v27 = *v13;
      unsigned int v28 = &v58;
LABEL_33:
      sub_1CD4C2394((uint64_t)v28, v27, v17);
LABEL_19:
      v17 += 40;
    }
    uint64_t v25 = v13 + 1;
    uint64_t v13 = v11;
    if (v25 != v11)
    {
      uint64_t v13 = v25;
      while ((*v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (++v13 == v11)
        {
          uint64_t v13 = v11;
          break;
        }
      }
    }
  }
  while (v13 != v14);
LABEL_34:
  unsigned int v55 = 0;
  uint64_t v56 = 0;
  unsigned int v57 = 0;
  unsigned int v29 = v62;
  if (!v62)
  {
    uint64_t v36 = 0;
    uint64_t v32 = a5;
    int v33 = a4;
LABEL_48:
    uint64_t v39 = &v36[3 * v29];
    int v37 = v39;
    goto LABEL_49;
  }
  uint64_t v30 = 16 * v62;
  uint64_t v31 = v61 + 8;
  uint64_t v32 = a5;
  int v33 = a4;
  do
  {
    a2(&v49, a3, *(v31 - 1), *v31);
    if (v51)
    {
      uint64_t v48 = *(void *)(*v31 + 32);
      uint64_t v34 = sub_1CD4CB550((uint64_t)&v55, &v48);
      v34[1] = sub_1CD45F614(v34[1], *((_WORD *)v34 + 8), v49, v50);
      *((_WORD *)v34 + 8) = v35;
      if (v35 >= 0x4000)
      {
        v34[1] = -1;
        *((_WORD *)v34 + 8) = 0x3FFF;
      }
    }
    v31 += 2;
    v30 -= 16;
  }
  while (v30);
  uint64_t v36 = v55;
  unsigned int v29 = v57;
  if (!v56) {
    goto LABEL_48;
  }
  int v37 = &v55[3 * v57];
  if (v57)
  {
    uint64_t v38 = 0;
    while ((v55[v38] | 0x1000) == 0xFFFFFFFFFFFFF000)
    {
      v38 += 3;
      if (3 * v57 == v38)
      {
        uint64_t v39 = &v55[3 * v57];
        goto LABEL_49;
      }
    }
    uint64_t v39 = &v55[v38];
  }
  else
  {
    uint64_t v39 = v55;
  }
LABEL_49:
  uint64_t v40 = &v36[3 * v29];
LABEL_50:
  while (v39 != v40)
  {
    v33(v32, *v39, v39[1], v39[2]);
    int64x2_t v41 = v39 + 3;
    uint64_t v39 = v37;
    if (v41 != v37)
    {
      uint64_t v39 = v41;
      while ((*v39 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v39 += 3;
        if (v39 == v37)
        {
          uint64_t v39 = v37;
          goto LABEL_50;
        }
      }
    }
  }
  if (v59)
  {
    uint64_t v42 = 16 * v59;
    long long v43 = (char *)v58 + 8;
    do
    {
      a2(&v49, a3, *(v43 - 1), *v43);
      if (v51) {
        v33(v32, *(void *)(*v43 + 32), v49, v50);
      }
      v43 += 2;
      v42 -= 16;
    }
    while (v42);
  }
  MEMORY[0x1D25D9CD0](v36, 8);
  if (v58 != v60) {
    free(v58);
  }
  if (v61 != (char *)v63) {
    free(v61);
  }
  return MEMORY[0x1D25D9CD0](v52, 8);
}

unint64_t sub_1CD4CB48C@<X0>(uint64_t a1@<X0>, unint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 80);
  *(_DWORD *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(void *)(a2 + 96) = 0;
  sub_1CC152980((int *)a2, v3);

  return sub_1CC152B90(a2);
}

uint64_t sub_1CD4CB4EC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1CD4CB550(uint64_t a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD45B528(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD4CB5C0(a1, a2, v7);
    *unint64_t v5 = *a2;
    v5[1] = 0;
    void v5[2] = 0;
  }
  return v5;
}

void *sub_1CD4CB5C0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4CB674(a1, v6);
  uint64_t v8 = 0;
  sub_1CD45B528(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4CB674(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD45B758(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 3;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4CB74C(uint64_t *a1)
{
}

void sub_1CD4CB7B0(uint64_t a1)
{
  sub_1CC15303C(a1, (uint64_t)&v1);
  operator new();
}

uint64_t sub_1CD4CB994(uint64_t a1)
{
  unsigned int v3 = (void **)(a1 + 24);
  sub_1CC0C3EE0(&v3);
  return a1;
}

unint64_t sub_1CD4CB9D0(unint64_t result, uint64_t **a2)
{
  unint64_t v11 = result;
  if (*(void *)((result & 0xFFFFFFFFFFFFFFF8) + 32) != *(void *)((result & 0xFFFFFFFFFFFFFFF8) + 24))
  {
    char v10 = 0;
    uint64_t result = (unint64_t)sub_1CD4CBBF4(a2, &v11, (uint64_t **)&v11, &v10);
    if (v3)
    {
      uint64_t v4 = **(void **)((v11 & 0xFFFFFFFFFFFFFFF8) + 24);
      if (*(_DWORD *)(v4 + 8) != 1) {
        uint64_t v4 = 0;
      }
      unint64_t v5 = *(uint64_t ***)(v4 + 80);
      uint64_t v6 = *(void *)(v4 + 88) - (void)v5;
      if (v6)
      {
        uint64_t v7 = 16 * (v6 >> 4);
        do
        {
          char v9 = 1;
          uint64_t result = (unint64_t)sub_1CD4CBBF4(a2, v5, v5, &v9);
          if (v8)
          {
            uint64_t result = sub_1CD4CB9D0(*v5, a2);
          }
          else if (!*(unsigned char *)(result + 40))
          {
            *(unsigned char *)(result + 40) = 1;
          }
          v5 += 2;
          v7 -= 16;
        }
        while (v7);
      }
    }
  }
  return result;
}

void sub_1CD4CBAB0(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  __n128 v14 = *a1;
  unint64_t v15 = a1[1].n128_u64[0];
  a1->n128_u64[0] = 0;
  a1->n128_u64[1] = 0;
  a1[1].n128_u64[0] = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v11 = 0;
  char v9 = 0;
  uint64_t v10 = 0;
  uint64_t v7 = 0;
  char v8 = 0;
  std::string __p = 0;
  uint64_t v6 = 0;
  memset(v4, 0, sizeof(v4));
  memset(v3, 0, sizeof(v3));
  memset(v2, 0, sizeof(v2));
  sub_1CD4AEC2C(a2, 193, 0, 0, 0, &v16, &v14, &v11, &v8, &__p, v4, v3, v2);
  uint64_t v18 = (void **)v2;
  sub_1CC0C4A94(&v18);
  uint64_t v18 = (void **)v3;
  sub_1CC0C4BCC(&v18);
  uint64_t v18 = v4;
  sub_1CC0C4BCC(&v18);
  if (__p)
  {
    uint64_t v6 = __p;
    operator delete(__p);
  }
  if (v8)
  {
    char v9 = v8;
    operator delete(v8);
  }
  if (v11)
  {
    uint64_t v12 = v11;
    operator delete(v11);
  }
  if (v14.n128_u64[0])
  {
    v14.n128_u64[1] = v14.n128_u64[0];
    operator delete((void *)v14.n128_u64[0]);
  }
  if ((void)v16)
  {
    *((void *)&v16 + 1) = v16;
    operator delete((void *)v16);
  }
}

uint64_t **sub_1CD4CBBF4(uint64_t **a1, void *a2, uint64_t **a3, unsigned char *a4)
{
  char v8 = a1 + 1;
  uint64_t v7 = a1[1];
  if (v7)
  {
    unint64_t v9 = *(void *)(*a2 & 0xFFFFFFFFFFFFFFF8);
    while (1)
    {
      while (1)
      {
        uint64_t v10 = (uint64_t **)v7;
        unint64_t v11 = *(void *)(v7[4] & 0xFFFFFFFFFFFFFFF8);
        if (v9 >= v11) {
          break;
        }
        uint64_t v7 = *v10;
        char v8 = v10;
        if (!*v10) {
          goto LABEL_10;
        }
      }
      if (v11 >= v9) {
        break;
      }
      uint64_t v7 = v10[1];
      if (!v7)
      {
        char v8 = v10 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v10 = a1 + 1;
LABEL_10:
    uint64_t v12 = (uint64_t *)v10;
    uint64_t v10 = (uint64_t **)operator new(0x30uLL);
    _OWORD v10[4] = *a3;
    *((unsigned char *)v10 + 40) = *a4;
    unsigned __int8 *v10 = 0;
    v10[1] = 0;
    uint64_t v10[2] = v12;
    *char v8 = (uint64_t *)v10;
    uint64_t v13 = (uint64_t *)**a1;
    __n128 v14 = (uint64_t *)v10;
    if (v13)
    {
      *a1 = v13;
      __n128 v14 = *v8;
    }
    sub_1CB8358B8(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

_OWORD *sub_1CD4CBCF0(int *a1, uint64_t a2)
{
  uint64_t v16 = a2;
  int v3 = *a1 + 1;
  *a1 = v3;
  *((_DWORD *)sub_1CD4CBF00((uint64_t *)a1 + 1, &v16) + 2) = v3;
  uint64_t v4 = (void *)*((void *)a1 + 5);
  if ((unint64_t)v4 >= *((void *)a1 + 6))
  {
    unint64_t v5 = sub_1CC1533E4((char **)a1 + 4, &v16);
  }
  else
  {
    *uint64_t v4 = v16;
    unint64_t v5 = (char *)(v4 + 1);
  }
  *((void *)a1 + 5) = v5;
  uint64_t v6 = *(void **)((v16 & 0xFFFFFFFFFFFFFFF8) + 24);
  if (*(void **)((v16 & 0xFFFFFFFFFFFFFFF8) + 32) == v6)
  {
    uint64_t v7 = &llvm::FunctionSummary::ExternalNode;
  }
  else
  {
    uint64_t v7 = (_DWORD *)*v6;
    if (v7) {
      BOOL v8 = v7[2] == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8) {
      uint64_t v7 = (_DWORD *)*((void *)v7 + 9);
    }
  }
  uint64_t v9 = *((void *)v7 + 10);
  int v10 = *a1;
  *(void *)&long long v14 = v16;
  *((void *)&v14 + 1) = v9;
  *(void *)&long long v15 = sub_1CD4CBF68;
  DWORD2(v15) = v10;
  unint64_t v11 = (_OWORD *)*((void *)a1 + 11);
  if ((unint64_t)v11 >= *((void *)a1 + 12))
  {
    uint64_t result = sub_1CBF833E4((void **)a1 + 10, &v14);
  }
  else
  {
    long long v12 = v15;
    *unint64_t v11 = v14;
    v11[1] = v12;
    uint64_t result = v11 + 2;
  }
  *((void *)a1 + 11) = result;
  return result;
}

void *sub_1CD4CBDE8(void *result)
{
  long long v1 = (char **)(result + 7);
  result[8] = result[7];
  if (result[10] != result[11])
  {
    uint64_t v2 = result;
    int v3 = result + 1;
    while (1)
    {
      sub_1CD4CBF70((uint64_t)v2);
      uint64_t v5 = v2[10];
      uint64_t v4 = v2[11];
      uint64_t v10 = *(void *)(v4 - 32);
      unsigned int v6 = *(_DWORD *)(v4 - 8);
      v2[11] = v4 - 32;
      if (v5 != v4 - 32 && *(_DWORD *)(v4 - 40) > v6) {
        *(_DWORD *)(v4 - 40) = v6;
      }
      uint64_t result = sub_1CD4CBF00(v3, &v10);
      if (v6 == *((_DWORD *)result + 2)) {
        break;
      }
      if (v2[10] == v2[11]) {
        return result;
      }
    }
    uint64_t result = (void *)v2[8];
    do
    {
      uint64_t v7 = v2[5];
      BOOL v8 = (void *)(v7 - 8);
      if ((unint64_t)result >= v2[9])
      {
        uint64_t v9 = sub_1CC1533E4(v1, v8);
        uint64_t v7 = v2[5];
      }
      else
      {
        *uint64_t result = *v8;
        uint64_t v9 = (char *)(result + 1);
      }
      v2[8] = v9;
      v2[5] = v7 - 8;
      *((_DWORD *)sub_1CD4CBF00(v3, (void *)v9 - 1) + 2) = -1;
      uint64_t result = (void *)v2[8];
    }
    while ((*(result - 1) & 0xFFFFFFFFFFFFFFF8) != (v10 & 0xFFFFFFFFFFFFFFF8));
  }
  return result;
}

void *sub_1CD4CBF00(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4AE784(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4AE828((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t sub_1CD4CBF68(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1CD4CBF70(uint64_t a1)
{
  uint64_t v2 = (uint64_t *)(a1 + 8);
  while (1)
  {
    uint64_t v3 = *(void *)(a1 + 88);
    unint64_t v4 = *(void *)(v3 - 32) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v5 = *(uint64_t **)(v4 + 24);
    if (*(uint64_t **)(v4 + 32) == v5)
    {
      BOOL v8 = &qword_1EBD069E8;
    }
    else
    {
      uint64_t v6 = *v5;
      if (v6) {
        BOOL v7 = *(_DWORD *)(v6 + 8) == 0;
      }
      else {
        BOOL v7 = 0;
      }
      if (v7) {
        uint64_t v6 = *(void *)(v6 + 72);
      }
      BOOL v8 = (uint64_t *)(v6 + 88);
    }
    uint64_t result = *(void *)(v3 - 24);
    if (result == *v8) {
      break;
    }
    uint64_t v10 = *(uint64_t (**)(void))(v3 - 16);
    *(void *)(v3 - 24) = result + 16;
    uint64_t v13 = v10();
    uint64_t v14 = 0;
    if (!sub_1CD4AE784(v2, &v13, &v14) || v14 == *(void *)(a1 + 8) + 16 * *(unsigned int *)(a1 + 24))
    {
      sub_1CD4CBCF0((int *)a1, v13);
    }
    else
    {
      unsigned int v11 = *(_DWORD *)(v14 + 8);
      uint64_t v12 = *(void *)(a1 + 88);
      if (*(_DWORD *)(v12 - 8) > v11) {
        *(_DWORD *)(v12 - 8) = v11;
      }
    }
  }
  return result;
}

BOOL llvm::TargetLibraryInfoImpl::isCallingConvCCompatible(llvm::TargetLibraryInfoImpl *this, llvm::Function *a2)
{
  uint64_t v2 = *((void *)this + 5);
  uint64_t v5 = *(void *)(v2 + 216);
  uint64_t v3 = v2 + 216;
  uint64_t v4 = v5;
  char v6 = *(unsigned char *)(v3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = v3;
  }
  else {
    uint64_t v7 = v4;
  }
  uint64_t v8 = *(void *)(v3 + 8);
  if (v6 >= 0) {
    uint64_t v9 = v6 & 0x7F;
  }
  else {
    uint64_t v9 = v8;
  }
  return sub_1CC153868((*((unsigned __int16 *)this + 9) >> 4) & 0x3FF, v7, v9, *((void *)this + 3));
}

llvm::TargetLibraryInfoImpl *llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(llvm::TargetLibraryInfoImpl *this)
{
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  *(_OWORD *)this = v2;
  *((_OWORD *)this + 1) = v2;
  *((_OWORD *)this + 2) = v2;
  *((_OWORD *)this + 3) = v2;
  *((_OWORD *)this + 4) = v2;
  *((_OWORD *)this + 5) = v2;
  *((_OWORD *)this + 6) = v2;
  *(void *)((char *)this + 109) = -1;
  long long v5 = 0u;
  long long v6 = 0u;
  *(_OWORD *)std::string __p = 0u;
  sub_1CC153974((uint64_t)this, (int *)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
  return this;
}

llvm::TargetLibraryInfoImpl *llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(llvm::TargetLibraryInfoImpl *this, const llvm::TargetLibraryInfoImpl *a2)
{
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 15) = 0;
  sub_1CC156ED8((uint64_t)this + 120, (uint64_t)a2 + 120);
  *((_WORD *)this + 72) = *((_WORD *)a2 + 72);
  *((unsigned char *)this + 146) = *((unsigned char *)a2 + 146);
  *((_DWORD *)this + 37) = *((_DWORD *)a2 + 37);
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  long long v4 = *(_OWORD *)a2;
  long long v5 = *((_OWORD *)a2 + 1);
  long long v6 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v6;
  *(_OWORD *)this = v4;
  *((_OWORD *)this + 1) = v5;
  long long v7 = *((_OWORD *)a2 + 4);
  long long v8 = *((_OWORD *)a2 + 5);
  long long v9 = *((_OWORD *)a2 + 6);
  *(void *)((char *)this + 109) = *(void *)((char *)a2 + 109);
  *((_OWORD *)this + 5) = v8;
  *((_OWORD *)this + 6) = v9;
  *((_OWORD *)this + 4) = v7;
  if (this != a2)
  {
    sub_1CC156F94((void *)this + 19, *((char **)a2 + 19), *((char **)a2 + 20), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 20) - *((void *)a2 + 19)) >> 3));
    sub_1CC156F94((void *)this + 22, *((char **)a2 + 22), *((char **)a2 + 23), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a2 + 23) - *((void *)a2 + 22)) >> 3));
  }
  return this;
}

uint64_t llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(void *)(a2 + 120) = 0;
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 128);
  *(_DWORD *)(a2 + 128) = 0;
  int v4 = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(a2 + 132) = v4;
  int v5 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_DWORD *)(a2 + 136) = v5;
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a2 + 144);
  *(unsigned char *)(a1 + 145) = *(unsigned char *)(a2 + 145);
  *(unsigned char *)(a1 + 146) = *(unsigned char *)(a2 + 146);
  *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
  *(_OWORD *)(a1 + 152) = 0u;
  long long v6 = (void *)(a1 + 152);
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  memmove((void *)a1, (const void *)a2, 0x75uLL);
  if (a1 != a2)
  {
    sub_1CC156F94(v6, *(char **)(a2 + 152), *(char **)(a2 + 160), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 160) - *(void *)(a2 + 152)) >> 3));
    sub_1CC156F94((void *)(a1 + 176), *(char **)(a2 + 176), *(char **)(a2 + 184), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 184) - *(void *)(a2 + 176)) >> 3));
  }
  return a1;
}

uint64_t *sub_1CD4CC35C(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *((unsigned int *)a1 + 4);
  uint64_t v5 = *a1;
  if (v4)
  {
    uint64_t v6 = 32 * v4;
    do
    {
      if (*(_DWORD *)v5 <= 0xFFFFFFFD && *(char *)(v5 + 31) < 0) {
        operator delete(*(void **)(v5 + 8));
      }
      v5 += 32;
      v6 -= 32;
    }
    while (v6);
    uint64_t v5 = *a1;
  }
  MEMORY[0x1D25D9CD0](v5, 8);
  *a1 = 0;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  *a1 = *a2;
  *a2 = 0;
  *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
  *((_DWORD *)a2 + 2) = 0;
  int v7 = *((_DWORD *)a1 + 3);
  *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
  *((_DWORD *)a2 + 3) = v7;
  int v8 = *((_DWORD *)a1 + 4);
  *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)a2 + 4) = v8;
  return a1;
}

double llvm::TargetLibraryInfoImpl::disableAllFunctions(llvm::TargetLibraryInfoImpl *this)
{
  *(void *)((char *)this + 109) = 0;
  double result = 0.0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  return result;
}

void llvm::TargetLibraryInfoImpl::addVectorizableFunctions(void *a1, char *__src, uint64_t a3)
{
  uint64_t v6 = &__src[40 * a3];
  sub_1CC157108((uint64_t)(a1 + 19), a1[20], __src, v6, a3);
  uint64_t v8 = a1[19];
  long long v9 = (__n128 *)a1[20];
  unint64_t v10 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v9 - v8) >> 3));
  uint64_t v17 = sub_1CC1563DC;
  if (v9 == (__n128 *)v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  sub_1CD4CFFD0(v8, v9, (uint64_t (**)(long long *, long long *))&v17, v11, 1, v7);
  sub_1CC157108((uint64_t)(a1 + 22), a1[23], __src, v6, a3);
  uint64_t v13 = a1[22];
  uint64_t v14 = (__n128 *)a1[23];
  unint64_t v15 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v14 - v13) >> 3));
  uint64_t v17 = sub_1CC156440;
  if (v14 == (__n128 *)v13) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = v15;
  }
  sub_1CD4CFFD0(v13, v14, (uint64_t (**)(long long *, long long *))&v17, v16, 1, v12);
}

void llvm::TargetLibraryInfoImpl::addVectorizableFunctionsFromVecLib()
{
  unint64_t v0 = (void *)MEMORY[0x1F4188790]();
  uint64_t v650 = *MEMORY[0x1E4F143B8];
  if (!(!v3 & v2))
  {
    switch(v1)
    {
      case 1:
        __src = "ceilf";
        uint64_t v6 = 5;
        __n128 v7 = "vceilf";
        long long v8 = xmmword_1CFAC4810;
        long long v9 = "fabsf";
        uint64_t v10 = 5;
        uint64_t v11 = "vfabsf";
        long long v12 = xmmword_1CFAC4810;
        uint64_t v13 = "llvm.fabs.f32";
        uint64_t v14 = 13;
        unint64_t v15 = "vfabsf";
        long long v16 = xmmword_1CFAC4810;
        uint64_t v17 = "floorf";
        uint64_t v18 = 6;
        unsigned int v19 = "vfloorf";
        long long v20 = xmmword_1CFAC4760;
        int v21 = "sqrtf";
        uint64_t v22 = 5;
        long long v24 = xmmword_1CFAC4810;
        int v23 = "vsqrtf";
        uint64_t v25 = "llvm.sqrt.f32";
        uint64_t v26 = 13;
        uint64_t v27 = "vsqrtf";
        long long v28 = xmmword_1CFAC4810;
        unsigned int v29 = "expf";
        uint64_t v30 = 4;
        uint64_t v31 = "vexpf";
        uint64_t v32 = 5;
        uint64_t v33 = 4;
        uint64_t v34 = "llvm.exp.f32";
        uint64_t v35 = 12;
        uint64_t v36 = "vexpf";
        long long v37 = xmmword_1CFAC4820;
        uint64_t v38 = "expm1f";
        uint64_t v39 = 6;
        uint64_t v40 = "vexpm1f";
        uint64_t v41 = 7;
        uint64_t v42 = 4;
        long long v43 = "logf";
        uint64_t v44 = 4;
        unsigned int v45 = "vlogf";
        long long v46 = xmmword_1CFAC4820;
        uint64_t v47 = "llvm.log.f32";
        uint64_t v48 = 12;
        unint64_t v49 = "vlogf";
        uint64_t v50 = 5;
        uint64_t v51 = 4;
        uint64_t v52 = "log1pf";
        uint64_t v53 = 6;
        unsigned int v54 = "vlog1pf";
        long long v55 = xmmword_1CFAC4760;
        uint64_t v56 = "log10f";
        uint64_t v57 = 6;
        int8x16_t v58 = "vlog10f";
        uint64_t v59 = 7;
        uint64_t v60 = 4;
        long long v61 = "llvm.log10.f32";
        uint64_t v62 = 14;
        unsigned int v63 = "vlog10f";
        long long v64 = xmmword_1CFAC4760;
        unsigned int v65 = "logbf";
        uint64_t v66 = 5;
        unsigned int v67 = "vlogbf";
        uint64_t v68 = 6;
        uint64_t v69 = 4;
        uint64_t v70 = "sinf";
        uint64_t v71 = 4;
        uint64_t v72 = "vsinf";
        long long v73 = xmmword_1CFAC4820;
        uint64_t v74 = "llvm.sin.f32";
        uint64_t v75 = 12;
        uint64_t v76 = "vsinf";
        uint64_t v77 = 5;
        uint64_t v78 = 4;
        v79 = "cosf";
        uint64_t v80 = 4;
        v81 = "vcosf";
        long long v82 = xmmword_1CFAC4820;
        __int16 v83 = "llvm.cos.f32";
        uint64_t v84 = 12;
        std::error_code v85 = "vcosf";
        uint64_t v86 = 5;
        uint64_t v87 = 4;
        uint64_t v88 = "tanf";
        uint64_t v89 = 4;
        v90 = "vtanf";
        long long v91 = xmmword_1CFAC4820;
        v92 = "asinf";
        uint64_t v93 = 5;
        v94 = "vasinf";
        uint64_t v95 = 6;
        uint64_t v96 = 4;
        v97 = "acosf";
        uint64_t v98 = 5;
        v99 = "vacosf";
        long long v100 = xmmword_1CFAC4810;
        v101 = "atanf";
        uint64_t v102 = 5;
        v103 = "vatanf";
        uint64_t v104 = 6;
        uint64_t v105 = 4;
        v106 = "sinhf";
        uint64_t v107 = 5;
        v108 = "vsinhf";
        long long v109 = xmmword_1CFAC4810;
        v110 = "coshf";
        uint64_t v111 = 5;
        v112 = "vcoshf";
        uint64_t v113 = 6;
        uint64_t v114 = 4;
        v115 = "tanhf";
        uint64_t v116 = 5;
        v117 = "vtanhf";
        long long v118 = xmmword_1CFAC4810;
        v119 = "asinhf";
        uint64_t v120 = 6;
        v121 = "vasinhf";
        uint64_t v122 = 7;
        uint64_t v123 = 4;
        v124 = "acoshf";
        uint64_t v125 = 6;
        v126 = "vacoshf";
        long long v127 = xmmword_1CFAC4760;
        v128 = "atanhf";
        uint64_t v129 = 6;
        v130 = "vatanhf";
        uint64_t v131 = 7;
        uint64_t v132 = 4;
        uint64_t v4 = 29;
        break;
      case 2:
        __src = "exp";
        uint64_t v6 = 3;
        __n128 v7 = "_simd_exp_d2";
        long long v8 = xmmword_1CFAC4790;
        long long v9 = "llvm.exp.f64";
        uint64_t v10 = 12;
        uint64_t v11 = "_simd_exp_d2";
        long long v12 = xmmword_1CFAC4790;
        uint64_t v13 = "expf";
        uint64_t v14 = 4;
        unint64_t v15 = "_simd_exp_f4";
        long long v16 = xmmword_1CFAC46C0;
        uint64_t v17 = "llvm.exp.f32";
        uint64_t v18 = 12;
        unsigned int v19 = "_simd_exp_f4";
        long long v20 = xmmword_1CFAC46C0;
        int v21 = "acos";
        uint64_t v22 = 4;
        long long v24 = xmmword_1CFAC4800;
        int v23 = "_simd_acos_d2";
        uint64_t v25 = "acosf";
        uint64_t v26 = 5;
        uint64_t v27 = "_simd_acos_f4";
        long long v28 = xmmword_1CFAC46F0;
        unsigned int v29 = "asin";
        uint64_t v30 = 4;
        uint64_t v31 = "_simd_asin_d2";
        uint64_t v32 = 13;
        uint64_t v33 = 2;
        uint64_t v34 = "asinf";
        uint64_t v35 = 5;
        uint64_t v36 = "_simd_asin_f4";
        long long v37 = xmmword_1CFAC46F0;
        uint64_t v38 = "atan";
        uint64_t v39 = 4;
        uint64_t v40 = "_simd_atan_d2";
        uint64_t v41 = 13;
        uint64_t v42 = 2;
        long long v43 = "atanf";
        uint64_t v44 = 5;
        unsigned int v45 = "_simd_atan_f4";
        long long v46 = xmmword_1CFAC46F0;
        uint64_t v47 = "atan2";
        uint64_t v48 = 5;
        unint64_t v49 = "_simd_atan2_d2";
        uint64_t v50 = 14;
        uint64_t v51 = 2;
        uint64_t v52 = "atan2f";
        uint64_t v53 = 6;
        unsigned int v54 = "_simd_atan2_f4";
        long long v55 = xmmword_1CFAC4710;
        uint64_t v56 = "cos";
        uint64_t v57 = 3;
        int8x16_t v58 = "_simd_cos_d2";
        uint64_t v59 = 12;
        uint64_t v60 = 2;
        long long v61 = "llvm.cos.f64";
        uint64_t v62 = 12;
        unsigned int v63 = "_simd_cos_d2";
        long long v64 = xmmword_1CFAC4790;
        unsigned int v65 = "cosf";
        uint64_t v66 = 4;
        unsigned int v67 = "_simd_cos_f4";
        uint64_t v68 = 12;
        uint64_t v69 = 4;
        uint64_t v70 = "llvm.cos.f32";
        uint64_t v71 = 12;
        uint64_t v72 = "_simd_cos_f4";
        long long v73 = xmmword_1CFAC46C0;
        uint64_t v74 = "sin";
        uint64_t v75 = 3;
        uint64_t v76 = "_simd_sin_d2";
        uint64_t v77 = 12;
        uint64_t v78 = 2;
        v79 = "llvm.sin.f64";
        uint64_t v80 = 12;
        v81 = "_simd_sin_d2";
        long long v82 = xmmword_1CFAC4790;
        __int16 v83 = "sinf";
        uint64_t v84 = 4;
        std::error_code v85 = "_simd_sin_f4";
        uint64_t v86 = 12;
        uint64_t v87 = 4;
        uint64_t v88 = "llvm.sin.f32";
        uint64_t v89 = 12;
        v90 = "_simd_sin_f4";
        long long v91 = xmmword_1CFAC46C0;
        v92 = "cbrt";
        uint64_t v93 = 4;
        v94 = "_simd_cbrt_d2";
        uint64_t v95 = 13;
        uint64_t v96 = 2;
        v97 = "cbrtf";
        uint64_t v98 = 5;
        v99 = "_simd_cbrt_f4";
        long long v100 = xmmword_1CFAC46F0;
        v101 = "erf";
        uint64_t v102 = 3;
        v103 = "_simd_erf_d2";
        uint64_t v104 = 12;
        uint64_t v105 = 2;
        v106 = "erff";
        uint64_t v107 = 4;
        v108 = "_simd_erf_f4";
        long long v109 = xmmword_1CFAC46C0;
        v110 = "pow";
        uint64_t v111 = 3;
        v112 = "_simd_pow_d2";
        uint64_t v113 = 12;
        uint64_t v114 = 2;
        v115 = "llvm.pow.f64";
        uint64_t v116 = 12;
        v117 = "_simd_pow_d2";
        long long v118 = xmmword_1CFAC4790;
        v119 = "powf";
        uint64_t v120 = 4;
        v121 = "_simd_pow_f4";
        uint64_t v122 = 12;
        uint64_t v123 = 4;
        v124 = "llvm.pow.f32";
        uint64_t v125 = 12;
        v126 = "_simd_pow_f4";
        long long v127 = xmmword_1CFAC46C0;
        v128 = "sinh";
        uint64_t v129 = 4;
        v130 = "_simd_sinh_d2";
        uint64_t v131 = 13;
        uint64_t v132 = 2;
        v133 = "sinhf";
        uint64_t v134 = 5;
        v135 = "_simd_sinh_f4";
        long long v136 = xmmword_1CFAC46F0;
        v137 = "cosh";
        uint64_t v138 = 4;
        v139 = "_simd_cosh_d2";
        uint64_t v140 = 13;
        uint64_t v141 = 2;
        v142 = "coshf";
        uint64_t v143 = 5;
        v144 = "_simd_cosh_f4";
        long long v145 = xmmword_1CFAC46F0;
        v146 = "tanh";
        uint64_t v147 = 4;
        v148 = "_simd_tanh_d2";
        uint64_t v149 = 13;
        uint64_t v150 = 2;
        v151 = "tanhf";
        uint64_t v152 = 5;
        v153 = "_simd_tanh_f4";
        long long v154 = xmmword_1CFAC46F0;
        v155 = "asinh";
        uint64_t v156 = 5;
        v157 = "_simd_asinh_d2";
        uint64_t v158 = 14;
        uint64_t v159 = 2;
        v160 = "asinhf";
        uint64_t v161 = 6;
        v162 = "_simd_asinh_f4";
        long long v163 = xmmword_1CFAC4710;
        v164 = "acosh";
        uint64_t v165 = 5;
        v166 = "_simd_acosh_d2";
        uint64_t v167 = 14;
        uint64_t v168 = 2;
        v169 = "acoshf";
        uint64_t v170 = 6;
        v171 = "_simd_acosh_f4";
        long long v172 = xmmword_1CFAC4710;
        v173 = "atanh";
        uint64_t v174 = 5;
        v175 = "_simd_atanh_d2";
        uint64_t v176 = 14;
        uint64_t v177 = 2;
        v178 = "atanhf";
        uint64_t v179 = 6;
        v180 = "_simd_atanh_f4";
        long long v181 = xmmword_1CFAC4710;
        uint64_t v4 = 40;
        break;
      case 3:
        __src = "sin";
        uint64_t v6 = 3;
        __n128 v7 = "_ZGVbN2v_sin";
        long long v8 = xmmword_1CFAC4790;
        long long v9 = "sin";
        uint64_t v10 = 3;
        uint64_t v11 = "_ZGVdN4v_sin";
        long long v12 = xmmword_1CFAC46C0;
        uint64_t v13 = "sinf";
        uint64_t v14 = 4;
        unint64_t v15 = "_ZGVbN4v_sinf";
        long long v16 = xmmword_1CFAC46F0;
        uint64_t v17 = "sinf";
        uint64_t v18 = 4;
        unsigned int v19 = "_ZGVdN8v_sinf";
        long long v20 = xmmword_1CFAC47A0;
        int v21 = "llvm.sin.f64";
        uint64_t v22 = 12;
        long long v24 = xmmword_1CFAC4790;
        int v23 = "_ZGVbN2v_sin";
        uint64_t v25 = "llvm.sin.f64";
        uint64_t v26 = 12;
        uint64_t v27 = "_ZGVdN4v_sin";
        long long v28 = xmmword_1CFAC46C0;
        unsigned int v29 = "llvm.sin.f32";
        uint64_t v30 = 12;
        uint64_t v31 = "_ZGVbN4v_sinf";
        uint64_t v32 = 13;
        uint64_t v33 = 4;
        uint64_t v34 = "llvm.sin.f32";
        uint64_t v35 = 12;
        uint64_t v36 = "_ZGVdN8v_sinf";
        long long v37 = xmmword_1CFAC47A0;
        uint64_t v38 = "cos";
        uint64_t v39 = 3;
        uint64_t v40 = "_ZGVbN2v_cos";
        uint64_t v41 = 12;
        uint64_t v42 = 2;
        long long v43 = "cos";
        uint64_t v44 = 3;
        unsigned int v45 = "_ZGVdN4v_cos";
        long long v46 = xmmword_1CFAC46C0;
        uint64_t v47 = "cosf";
        uint64_t v48 = 4;
        unint64_t v49 = "_ZGVbN4v_cosf";
        uint64_t v50 = 13;
        uint64_t v51 = 4;
        uint64_t v52 = "cosf";
        uint64_t v53 = 4;
        unsigned int v54 = "_ZGVdN8v_cosf";
        long long v55 = xmmword_1CFAC47A0;
        uint64_t v56 = "llvm.cos.f64";
        uint64_t v57 = 12;
        int8x16_t v58 = "_ZGVbN2v_cos";
        uint64_t v59 = 12;
        uint64_t v60 = 2;
        long long v61 = "llvm.cos.f64";
        uint64_t v62 = 12;
        unsigned int v63 = "_ZGVdN4v_cos";
        long long v64 = xmmword_1CFAC46C0;
        unsigned int v65 = "llvm.cos.f32";
        uint64_t v66 = 12;
        unsigned int v67 = "_ZGVbN4v_cosf";
        uint64_t v68 = 13;
        uint64_t v69 = 4;
        uint64_t v70 = "llvm.cos.f32";
        uint64_t v71 = 12;
        uint64_t v72 = "_ZGVdN8v_cosf";
        long long v73 = xmmword_1CFAC47A0;
        uint64_t v74 = "pow";
        uint64_t v75 = 3;
        uint64_t v76 = "_ZGVbN2vv_pow";
        uint64_t v77 = 13;
        uint64_t v78 = 2;
        v79 = "pow";
        uint64_t v80 = 3;
        v81 = "_ZGVdN4vv_pow";
        long long v82 = xmmword_1CFAC46F0;
        __int16 v83 = "powf";
        uint64_t v84 = 4;
        std::error_code v85 = "_ZGVbN4vv_powf";
        uint64_t v86 = 14;
        uint64_t v87 = 4;
        uint64_t v88 = "powf";
        uint64_t v89 = 4;
        v90 = "_ZGVdN8vv_powf";
        long long v91 = xmmword_1CFAC47B0;
        v92 = "__pow_finite";
        uint64_t v93 = 12;
        v94 = "_ZGVbN2vv___pow_finite";
        uint64_t v95 = 22;
        uint64_t v96 = 2;
        v97 = "__pow_finite";
        uint64_t v98 = 12;
        v99 = "_ZGVdN4vv___pow_finite";
        long long v100 = xmmword_1CFAC47C0;
        v101 = "__powf_finite";
        uint64_t v102 = 13;
        v103 = "_ZGVbN4vv___powf_finite";
        uint64_t v104 = 23;
        uint64_t v105 = 4;
        v106 = "__powf_finite";
        uint64_t v107 = 13;
        v108 = "_ZGVdN8vv___powf_finite";
        long long v109 = xmmword_1CFAC47D0;
        v110 = "llvm.pow.f64";
        uint64_t v111 = 12;
        v112 = "_ZGVbN2vv_pow";
        uint64_t v113 = 13;
        uint64_t v114 = 2;
        v115 = "llvm.pow.f64";
        uint64_t v116 = 12;
        v117 = "_ZGVdN4vv_pow";
        long long v118 = xmmword_1CFAC46F0;
        v119 = "llvm.pow.f32";
        uint64_t v120 = 12;
        v121 = "_ZGVbN4vv_powf";
        uint64_t v122 = 14;
        uint64_t v123 = 4;
        v124 = "llvm.pow.f32";
        uint64_t v125 = 12;
        v126 = "_ZGVdN8vv_powf";
        long long v127 = xmmword_1CFAC47B0;
        v128 = "exp";
        uint64_t v129 = 3;
        v130 = "_ZGVbN2v_exp";
        uint64_t v131 = 12;
        uint64_t v132 = 2;
        v133 = "exp";
        uint64_t v134 = 3;
        v135 = "_ZGVdN4v_exp";
        long long v136 = xmmword_1CFAC46C0;
        v137 = "expf";
        uint64_t v138 = 4;
        v139 = "_ZGVbN4v_expf";
        uint64_t v140 = 13;
        uint64_t v141 = 4;
        v142 = "expf";
        uint64_t v143 = 4;
        v144 = "_ZGVdN8v_expf";
        long long v145 = xmmword_1CFAC47A0;
        v146 = "__exp_finite";
        uint64_t v147 = 12;
        v148 = "_ZGVbN2v___exp_finite";
        uint64_t v149 = 21;
        uint64_t v150 = 2;
        v151 = "__exp_finite";
        uint64_t v152 = 12;
        v153 = "_ZGVdN4v___exp_finite";
        long long v154 = xmmword_1CFAC47E0;
        v155 = "__expf_finite";
        uint64_t v156 = 13;
        v157 = "_ZGVbN4v___expf_finite";
        uint64_t v158 = 22;
        uint64_t v159 = 4;
        v160 = "__expf_finite";
        uint64_t v161 = 13;
        v162 = "_ZGVdN8v___expf_finite";
        long long v163 = xmmword_1CFAC47F0;
        v164 = "llvm.exp.f64";
        uint64_t v165 = 12;
        v166 = "_ZGVbN2v_exp";
        uint64_t v167 = 12;
        uint64_t v168 = 2;
        v169 = "llvm.exp.f64";
        uint64_t v170 = 12;
        v171 = "_ZGVdN4v_exp";
        long long v172 = xmmword_1CFAC46C0;
        v173 = "llvm.exp.f32";
        uint64_t v174 = 12;
        v175 = "_ZGVbN4v_expf";
        uint64_t v176 = 13;
        uint64_t v177 = 4;
        v178 = "llvm.exp.f32";
        uint64_t v179 = 12;
        v180 = "_ZGVdN8v_expf";
        long long v181 = xmmword_1CFAC47A0;
        v182 = "log";
        uint64_t v183 = 3;
        v184 = "_ZGVbN2v_log";
        uint64_t v185 = 12;
        uint64_t v186 = 2;
        v187 = "log";
        uint64_t v188 = 3;
        v189 = "_ZGVdN4v_log";
        long long v190 = xmmword_1CFAC46C0;
        v191 = "logf";
        uint64_t v192 = 4;
        v193 = "_ZGVbN4v_logf";
        uint64_t v194 = 13;
        uint64_t v195 = 4;
        v196 = "logf";
        uint64_t v197 = 4;
        v198 = "_ZGVdN8v_logf";
        long long v199 = xmmword_1CFAC47A0;
        v200 = "__log_finite";
        uint64_t v201 = 12;
        v202 = "_ZGVbN2v___log_finite";
        uint64_t v203 = 21;
        uint64_t v204 = 2;
        v205 = "__log_finite";
        uint64_t v206 = 12;
        v207 = "_ZGVdN4v___log_finite";
        long long v208 = xmmword_1CFAC47E0;
        v209 = "__logf_finite";
        uint64_t v210 = 13;
        v211 = "_ZGVbN4v___logf_finite";
        uint64_t v212 = 22;
        uint64_t v213 = 4;
        v214 = "__logf_finite";
        uint64_t v215 = 13;
        v216 = "_ZGVdN8v___logf_finite";
        long long v217 = xmmword_1CFAC47F0;
        v218 = "llvm.log.f64";
        uint64_t v219 = 12;
        v220 = "_ZGVbN2v_log";
        uint64_t v221 = 12;
        uint64_t v222 = 2;
        v223 = "llvm.log.f64";
        uint64_t v224 = 12;
        v225 = "_ZGVdN4v_log";
        long long v226 = xmmword_1CFAC46C0;
        v227 = "llvm.log.f32";
        uint64_t v228 = 12;
        v229 = "_ZGVbN4v_logf";
        uint64_t v230 = 13;
        uint64_t v231 = 4;
        v232 = "llvm.log.f32";
        uint64_t v233 = 12;
        v234 = "_ZGVdN8v_logf";
        long long v235 = xmmword_1CFAC47A0;
        uint64_t v4 = 52;
        break;
      case 4:
        __src = "cbrt";
        uint64_t v6 = 4;
        __n128 v7 = "__cbrtd2";
        long long v8 = xmmword_1CFAC4730;
        long long v9 = "cbrtf";
        uint64_t v10 = 5;
        uint64_t v11 = "__cbrtf4";
        long long v12 = xmmword_1CFAC4740;
        uint64_t v13 = "pow";
        uint64_t v14 = 3;
        unint64_t v15 = "__powd2";
        long long v16 = xmmword_1CFAC4750;
        uint64_t v17 = "llvm.pow.f64";
        uint64_t v18 = 12;
        unsigned int v19 = "__powd2";
        long long v20 = xmmword_1CFAC4750;
        int v21 = "powf";
        uint64_t v22 = 4;
        long long v24 = xmmword_1CFAC4760;
        int v23 = "__powf4";
        uint64_t v25 = "llvm.pow.f32";
        uint64_t v26 = 12;
        uint64_t v27 = "__powf4";
        long long v28 = xmmword_1CFAC4760;
        unsigned int v29 = "exp";
        uint64_t v30 = 3;
        uint64_t v31 = "__expd2";
        uint64_t v32 = 7;
        uint64_t v33 = 2;
        uint64_t v34 = "llvm.exp.f64";
        uint64_t v35 = 12;
        uint64_t v36 = "__expd2";
        long long v37 = xmmword_1CFAC4750;
        uint64_t v38 = "expf";
        uint64_t v39 = 4;
        uint64_t v40 = "__expf4";
        uint64_t v41 = 7;
        uint64_t v42 = 4;
        long long v43 = "llvm.exp.f32";
        uint64_t v44 = 12;
        unsigned int v45 = "__expf4";
        long long v46 = xmmword_1CFAC4760;
        uint64_t v47 = "exp2";
        uint64_t v48 = 4;
        unint64_t v49 = "__exp2d2";
        uint64_t v50 = 8;
        uint64_t v51 = 2;
        uint64_t v52 = "llvm.exp2.f64";
        uint64_t v53 = 13;
        unsigned int v54 = "__exp2d2";
        long long v55 = xmmword_1CFAC4730;
        uint64_t v56 = "exp2f";
        uint64_t v57 = 5;
        int8x16_t v58 = "__exp2f4";
        uint64_t v59 = 8;
        uint64_t v60 = 4;
        long long v61 = "llvm.exp2.f32";
        uint64_t v62 = 13;
        unsigned int v63 = "__exp2f4";
        long long v64 = xmmword_1CFAC4740;
        unsigned int v65 = "expm1";
        uint64_t v66 = 5;
        unsigned int v67 = "__expm1d2";
        uint64_t v68 = 9;
        uint64_t v69 = 2;
        uint64_t v70 = "expm1f";
        uint64_t v71 = 6;
        uint64_t v72 = "__expm1f4";
        long long v73 = xmmword_1CFAC4770;
        uint64_t v74 = "log";
        uint64_t v75 = 3;
        uint64_t v76 = "__logd2";
        uint64_t v77 = 7;
        uint64_t v78 = 2;
        v79 = "llvm.log.f64";
        uint64_t v80 = 12;
        v81 = "__logd2";
        long long v82 = xmmword_1CFAC4750;
        __int16 v83 = "logf";
        uint64_t v84 = 4;
        std::error_code v85 = "__logf4";
        uint64_t v86 = 7;
        uint64_t v87 = 4;
        uint64_t v88 = "llvm.log.f32";
        uint64_t v89 = 12;
        v90 = "__logf4";
        long long v91 = xmmword_1CFAC4760;
        v92 = "log1p";
        uint64_t v93 = 5;
        v94 = "__log1pd2";
        uint64_t v95 = 9;
        uint64_t v96 = 2;
        v97 = "log1pf";
        uint64_t v98 = 6;
        v99 = "__log1pf4";
        long long v100 = xmmword_1CFAC4770;
        v101 = "log10";
        uint64_t v102 = 5;
        v103 = "__log10d2";
        uint64_t v104 = 9;
        uint64_t v105 = 2;
        v106 = "llvm.log10.f64";
        uint64_t v107 = 14;
        v108 = "__log10d2";
        long long v109 = xmmword_1CFAC4780;
        v110 = "log10f";
        uint64_t v111 = 6;
        v112 = "__log10f4";
        uint64_t v113 = 9;
        uint64_t v114 = 4;
        v115 = "llvm.log10.f32";
        uint64_t v116 = 14;
        v117 = "__log10f4";
        long long v118 = xmmword_1CFAC4770;
        v119 = "log2";
        uint64_t v120 = 4;
        v121 = "__log2d2";
        uint64_t v122 = 8;
        uint64_t v123 = 2;
        v124 = "llvm.log2.f64";
        uint64_t v125 = 13;
        v126 = "__log2d2";
        long long v127 = xmmword_1CFAC4730;
        v128 = "log2f";
        uint64_t v129 = 5;
        v130 = "__log2f4";
        uint64_t v131 = 8;
        uint64_t v132 = 4;
        v133 = "llvm.log2.f32";
        uint64_t v134 = 13;
        v135 = "__log2f4";
        long long v136 = xmmword_1CFAC4740;
        v137 = "sin";
        uint64_t v138 = 3;
        v139 = "__sind2";
        uint64_t v140 = 7;
        uint64_t v141 = 2;
        v142 = "llvm.sin.f64";
        uint64_t v143 = 12;
        v144 = "__sind2";
        long long v145 = xmmword_1CFAC4750;
        v146 = "sinf";
        uint64_t v147 = 4;
        v148 = "__sinf4";
        uint64_t v149 = 7;
        uint64_t v150 = 4;
        v151 = "llvm.sin.f32";
        uint64_t v152 = 12;
        v153 = "__sinf4";
        long long v154 = xmmword_1CFAC4760;
        v155 = "cos";
        uint64_t v156 = 3;
        v157 = "__cosd2";
        uint64_t v158 = 7;
        uint64_t v159 = 2;
        v160 = "llvm.cos.f64";
        uint64_t v161 = 12;
        v162 = "__cosd2";
        long long v163 = xmmword_1CFAC4750;
        v164 = "cosf";
        uint64_t v165 = 4;
        v166 = "__cosf4";
        uint64_t v167 = 7;
        uint64_t v168 = 4;
        v169 = "llvm.cos.f32";
        uint64_t v170 = 12;
        v171 = "__cosf4";
        long long v172 = xmmword_1CFAC4760;
        v173 = "tan";
        uint64_t v174 = 3;
        v175 = "__tand2";
        uint64_t v176 = 7;
        uint64_t v177 = 2;
        v178 = "tanf";
        uint64_t v179 = 4;
        v180 = "__tanf4";
        long long v181 = xmmword_1CFAC4760;
        v182 = "asin";
        uint64_t v183 = 4;
        v184 = "__asind2";
        uint64_t v185 = 8;
        uint64_t v186 = 2;
        v187 = "asinf";
        uint64_t v188 = 5;
        v189 = "__asinf4";
        long long v190 = xmmword_1CFAC4740;
        v191 = "acos";
        uint64_t v192 = 4;
        v193 = "__acosd2";
        uint64_t v194 = 8;
        uint64_t v195 = 2;
        v196 = "acosf";
        uint64_t v197 = 5;
        v198 = "__acosf4";
        long long v199 = xmmword_1CFAC4740;
        v200 = "atan";
        uint64_t v201 = 4;
        v202 = "__atand2";
        uint64_t v203 = 8;
        uint64_t v204 = 2;
        v205 = "atanf";
        uint64_t v206 = 5;
        v207 = "__atanf4";
        long long v208 = xmmword_1CFAC4740;
        v209 = "atan2";
        uint64_t v210 = 5;
        v211 = "__atan2d2";
        uint64_t v212 = 9;
        uint64_t v213 = 2;
        v214 = "atan2f";
        uint64_t v215 = 6;
        v216 = "__atan2f4";
        long long v217 = xmmword_1CFAC4770;
        v218 = "sinh";
        uint64_t v219 = 4;
        v220 = "__sinhd2";
        uint64_t v221 = 8;
        uint64_t v222 = 2;
        v223 = "sinhf";
        uint64_t v224 = 5;
        v225 = "__sinhf4";
        long long v226 = xmmword_1CFAC4740;
        v227 = "cosh";
        uint64_t v228 = 4;
        v229 = "__coshd2";
        uint64_t v230 = 8;
        uint64_t v231 = 2;
        v232 = "coshf";
        uint64_t v233 = 5;
        v234 = "__coshf4";
        long long v235 = xmmword_1CFAC4740;
        v236 = "tanh";
        uint64_t v237 = 4;
        v238 = "__tanhd2";
        uint64_t v239 = 8;
        uint64_t v240 = 2;
        v241 = "tanhf";
        uint64_t v242 = 5;
        v243 = "__tanhf4";
        long long v244 = xmmword_1CFAC4740;
        v245 = "asinh";
        uint64_t v246 = 5;
        v247 = "__asinhd2";
        uint64_t v248 = 9;
        uint64_t v249 = 2;
        v250 = "asinhf";
        uint64_t v251 = 6;
        v252 = "__asinhf4";
        long long v253 = xmmword_1CFAC4770;
        v254 = "acosh";
        uint64_t v255 = 5;
        v256 = "__acoshd2";
        uint64_t v257 = 9;
        uint64_t v258 = 2;
        v259 = "acoshf";
        uint64_t v260 = 6;
        v261 = "__acoshf4";
        long long v262 = xmmword_1CFAC4770;
        v263 = "atanh";
        uint64_t v264 = 5;
        v265 = "__atanhd2";
        uint64_t v266 = 9;
        uint64_t v267 = 2;
        v268 = "atanhf";
        uint64_t v269 = 6;
        v270 = "__atanhf4";
        long long v271 = xmmword_1CFAC4770;
        uint64_t v4 = 60;
        break;
      case 5:
        __src = "sin";
        uint64_t v6 = 3;
        __n128 v7 = "__svml_sin2";
        long long v8 = xmmword_1CFAC4690;
        long long v9 = "sin";
        uint64_t v10 = 3;
        uint64_t v11 = "__svml_sin4";
        long long v12 = xmmword_1CFAC46A0;
        uint64_t v13 = "sin";
        uint64_t v14 = 3;
        unint64_t v15 = "__svml_sin8";
        long long v16 = xmmword_1CFAC46B0;
        uint64_t v17 = "sinf";
        uint64_t v18 = 4;
        unsigned int v19 = "__svml_sinf4";
        long long v20 = xmmword_1CFAC46C0;
        int v21 = "sinf";
        uint64_t v22 = 4;
        long long v24 = xmmword_1CFAC46D0;
        int v23 = "__svml_sinf8";
        uint64_t v25 = "sinf";
        uint64_t v26 = 4;
        uint64_t v27 = "__svml_sinf16";
        long long v28 = xmmword_1CFAC46E0;
        unsigned int v29 = "llvm.sin.f64";
        uint64_t v30 = 12;
        uint64_t v31 = "__svml_sin2";
        uint64_t v32 = 11;
        uint64_t v33 = 2;
        uint64_t v34 = "llvm.sin.f64";
        uint64_t v35 = 12;
        uint64_t v36 = "__svml_sin4";
        long long v37 = xmmword_1CFAC46A0;
        uint64_t v38 = "llvm.sin.f64";
        uint64_t v39 = 12;
        uint64_t v40 = "__svml_sin8";
        uint64_t v41 = 11;
        uint64_t v42 = 8;
        long long v43 = "llvm.sin.f32";
        uint64_t v44 = 12;
        unsigned int v45 = "__svml_sinf4";
        long long v46 = xmmword_1CFAC46C0;
        uint64_t v47 = "llvm.sin.f32";
        uint64_t v48 = 12;
        unint64_t v49 = "__svml_sinf8";
        uint64_t v50 = 12;
        uint64_t v51 = 8;
        uint64_t v52 = "llvm.sin.f32";
        uint64_t v53 = 12;
        unsigned int v54 = "__svml_sinf16";
        long long v55 = xmmword_1CFAC46E0;
        uint64_t v56 = "cos";
        uint64_t v57 = 3;
        int8x16_t v58 = "__svml_cos2";
        uint64_t v59 = 11;
        uint64_t v60 = 2;
        long long v61 = "cos";
        uint64_t v62 = 3;
        unsigned int v63 = "__svml_cos4";
        long long v64 = xmmword_1CFAC46A0;
        unsigned int v65 = "cos";
        uint64_t v66 = 3;
        unsigned int v67 = "__svml_cos8";
        uint64_t v68 = 11;
        uint64_t v69 = 8;
        uint64_t v70 = "cosf";
        uint64_t v71 = 4;
        uint64_t v72 = "__svml_cosf4";
        long long v73 = xmmword_1CFAC46C0;
        uint64_t v74 = "cosf";
        uint64_t v75 = 4;
        uint64_t v76 = "__svml_cosf8";
        uint64_t v77 = 12;
        uint64_t v78 = 8;
        v79 = "cosf";
        uint64_t v80 = 4;
        v81 = "__svml_cosf16";
        long long v82 = xmmword_1CFAC46E0;
        __int16 v83 = "llvm.cos.f64";
        uint64_t v84 = 12;
        std::error_code v85 = "__svml_cos2";
        uint64_t v86 = 11;
        uint64_t v87 = 2;
        uint64_t v88 = "llvm.cos.f64";
        uint64_t v89 = 12;
        v90 = "__svml_cos4";
        long long v91 = xmmword_1CFAC46A0;
        v92 = "llvm.cos.f64";
        uint64_t v93 = 12;
        v94 = "__svml_cos8";
        uint64_t v95 = 11;
        uint64_t v96 = 8;
        v97 = "llvm.cos.f32";
        uint64_t v98 = 12;
        v99 = "__svml_cosf4";
        long long v100 = xmmword_1CFAC46C0;
        v101 = "llvm.cos.f32";
        uint64_t v102 = 12;
        v103 = "__svml_cosf8";
        uint64_t v104 = 12;
        uint64_t v105 = 8;
        v106 = "llvm.cos.f32";
        uint64_t v107 = 12;
        v108 = "__svml_cosf16";
        long long v109 = xmmword_1CFAC46E0;
        v110 = "pow";
        uint64_t v111 = 3;
        v112 = "__svml_pow2";
        uint64_t v113 = 11;
        uint64_t v114 = 2;
        v115 = "pow";
        uint64_t v116 = 3;
        v117 = "__svml_pow4";
        long long v118 = xmmword_1CFAC46A0;
        v119 = "pow";
        uint64_t v120 = 3;
        v121 = "__svml_pow8";
        uint64_t v122 = 11;
        uint64_t v123 = 8;
        v124 = "powf";
        uint64_t v125 = 4;
        v126 = "__svml_powf4";
        long long v127 = xmmword_1CFAC46C0;
        v128 = "powf";
        uint64_t v129 = 4;
        v130 = "__svml_powf8";
        uint64_t v131 = 12;
        uint64_t v132 = 8;
        v133 = "powf";
        uint64_t v134 = 4;
        v135 = "__svml_powf16";
        long long v136 = xmmword_1CFAC46E0;
        v137 = "__pow_finite";
        uint64_t v138 = 12;
        v139 = "__svml_pow2";
        uint64_t v140 = 11;
        uint64_t v141 = 2;
        v142 = "__pow_finite";
        uint64_t v143 = 12;
        v144 = "__svml_pow4";
        long long v145 = xmmword_1CFAC46A0;
        v146 = "__pow_finite";
        uint64_t v147 = 12;
        v148 = "__svml_pow8";
        uint64_t v149 = 11;
        uint64_t v150 = 8;
        v151 = "__powf_finite";
        uint64_t v152 = 13;
        v153 = "__svml_powf4";
        long long v154 = xmmword_1CFAC46C0;
        v155 = "__powf_finite";
        uint64_t v156 = 13;
        v157 = "__svml_powf8";
        uint64_t v158 = 12;
        uint64_t v159 = 8;
        v160 = "__powf_finite";
        uint64_t v161 = 13;
        v162 = "__svml_powf16";
        long long v163 = xmmword_1CFAC46E0;
        v164 = "llvm.pow.f64";
        uint64_t v165 = 12;
        v166 = "__svml_pow2";
        uint64_t v167 = 11;
        uint64_t v168 = 2;
        v169 = "llvm.pow.f64";
        uint64_t v170 = 12;
        v171 = "__svml_pow4";
        long long v172 = xmmword_1CFAC46A0;
        v173 = "llvm.pow.f64";
        uint64_t v174 = 12;
        v175 = "__svml_pow8";
        uint64_t v176 = 11;
        uint64_t v177 = 8;
        v178 = "llvm.pow.f32";
        uint64_t v179 = 12;
        v180 = "__svml_powf4";
        long long v181 = xmmword_1CFAC46C0;
        v182 = "llvm.pow.f32";
        uint64_t v183 = 12;
        v184 = "__svml_powf8";
        uint64_t v185 = 12;
        uint64_t v186 = 8;
        v187 = "llvm.pow.f32";
        uint64_t v188 = 12;
        v189 = "__svml_powf16";
        long long v190 = xmmword_1CFAC46E0;
        v191 = "exp";
        uint64_t v192 = 3;
        v193 = "__svml_exp2";
        uint64_t v194 = 11;
        uint64_t v195 = 2;
        v196 = "exp";
        uint64_t v197 = 3;
        v198 = "__svml_exp4";
        long long v199 = xmmword_1CFAC46A0;
        v200 = "exp";
        uint64_t v201 = 3;
        v202 = "__svml_exp8";
        v205 = "expf";
        v207 = "__svml_expf4";
        v209 = "expf";
        v211 = "__svml_expf8";
        v214 = "expf";
        v216 = "__svml_expf16";
        v218 = "__exp_finite";
        v220 = "__svml_exp2";
        v223 = "__exp_finite";
        v225 = "__svml_exp4";
        v227 = "__exp_finite";
        v232 = "__expf_finite";
        v234 = "__svml_expf4";
        v236 = "__expf_finite";
        v238 = "__svml_expf8";
        v241 = "__expf_finite";
        v243 = "__svml_expf16";
        v245 = "llvm.exp.f64";
        v247 = "__svml_exp2";
        v250 = "llvm.exp.f64";
        v252 = "__svml_exp4";
        v254 = "llvm.exp.f64";
        v261 = "__svml_expf4";
        v265 = "__svml_expf8";
        v270 = "__svml_expf16";
        v272 = "log";
        uint64_t v273 = 3;
        v277 = "log";
        uint64_t v278 = 3;
        v279 = "__svml_log4";
        v281 = "log";
        uint64_t v282 = 3;
        v283 = "__svml_log8";
        v286 = "logf";
        v290 = "logf";
        v295 = "logf";
        v297 = "__svml_logf16";
        v299 = "__log_finite";
        v304 = "__log_finite";
        v306 = "__svml_log4";
        v308 = "__log_finite";
        v310 = "__svml_log8";
        v313 = "__logf_finite";
        v317 = "__logf_finite";
        v322 = "__logf_finite";
        v324 = "__svml_logf16";
        v333 = "__svml_log4";
        v337 = "__svml_log8";
        v340 = "llvm.log.f32";
        v344 = "llvm.log.f32";
        v349 = "llvm.log.f32";
        v351 = "__svml_logf16";
        uint64_t v390 = 13;
        v391 = "__svml_log28";
        uint64_t v392 = 12;
        uint64_t v386 = 13;
        v387 = "__svml_log24";
        long long v388 = xmmword_1CFAC46C0;
        v389 = "__log2_finite";
        v367 = "log2f";
        uint64_t v368 = 5;
        uint64_t v383 = 12;
        uint64_t v384 = 2;
        v385 = "__log2_finite";
        long long v379 = xmmword_1CFAC4700;
        v380 = "__log2_finite";
        uint64_t v381 = 13;
        v382 = "__svml_log22";
        v376 = "log2f";
        uint64_t v377 = 5;
        v378 = "__svml_log2f16";
        v373 = "__svml_log2f8";
        uint64_t v374 = 13;
        uint64_t v375 = 8;
        v369 = "__svml_log2f4";
        long long v370 = xmmword_1CFAC46F0;
        v371 = "log2f";
        uint64_t v372 = 5;
        uint64_t v363 = 4;
        v364 = "__svml_log28";
        uint64_t v365 = 12;
        uint64_t v366 = 8;
        v353 = "log2";
        v358 = "log2";
        uint64_t v359 = 4;
        v360 = "__svml_log24";
        long long v361 = xmmword_1CFAC46C0;
        v362 = "log2";
        uint64_t v354 = 4;
        v355 = "__svml_log22";
        uint64_t v356 = 12;
        uint64_t v357 = 2;
        uint64_t v203 = 11;
        v292 = "__svml_logf8";
        v319 = "__svml_logf8";
        uint64_t v348 = 8;
        uint64_t v350 = 12;
        long long v352 = xmmword_1CFAC46E0;
        v346 = "__svml_logf8";
        long long v343 = xmmword_1CFAC46C0;
        uint64_t v345 = 12;
        uint64_t v347 = 12;
        uint64_t v204 = 8;
        v288 = "__svml_logf4";
        v315 = "__svml_logf4";
        uint64_t v339 = 8;
        uint64_t v341 = 12;
        v342 = "__svml_logf4";
        long long v334 = xmmword_1CFAC46A0;
        v335 = "llvm.log.f64";
        uint64_t v336 = 12;
        uint64_t v338 = 11;
        uint64_t v206 = 4;
        v326 = "llvm.log.f64";
        uint64_t v329 = 11;
        uint64_t v330 = 2;
        v331 = "llvm.log.f64";
        uint64_t v332 = 12;
        uint64_t v323 = 13;
        long long v325 = xmmword_1CFAC46E0;
        uint64_t v327 = 12;
        v328 = "__svml_log2";
        long long v208 = xmmword_1CFAC46C0;
        uint64_t v210 = 4;
        uint64_t v212 = 12;
        uint64_t v318 = 13;
        uint64_t v320 = 12;
        uint64_t v321 = 8;
        uint64_t v213 = 8;
        uint64_t v215 = 4;
        uint64_t v311 = 11;
        uint64_t v312 = 8;
        uint64_t v314 = 13;
        long long v316 = xmmword_1CFAC46C0;
        long long v217 = xmmword_1CFAC46E0;
        uint64_t v219 = 12;
        uint64_t v221 = 11;
        uint64_t v305 = 12;
        long long v307 = xmmword_1CFAC46A0;
        uint64_t v309 = 12;
        uint64_t v222 = 2;
        uint64_t v224 = 12;
        uint64_t v300 = 12;
        v301 = "__svml_log2";
        uint64_t v302 = 11;
        uint64_t v303 = 2;
        long long v226 = xmmword_1CFAC46A0;
        uint64_t v228 = 12;
        uint64_t v293 = 12;
        uint64_t v294 = 8;
        uint64_t v296 = 4;
        long long v298 = xmmword_1CFAC46E0;
        v229 = "__svml_exp8";
        uint64_t v230 = 11;
        uint64_t v231 = 8;
        uint64_t v287 = 4;
        long long v289 = xmmword_1CFAC46C0;
        uint64_t v291 = 4;
        uint64_t v233 = 13;
        long long v235 = xmmword_1CFAC46C0;
        uint64_t v237 = 13;
        uint64_t v239 = 12;
        uint64_t v284 = 11;
        uint64_t v285 = 8;
        uint64_t v240 = 8;
        uint64_t v242 = 13;
        long long v244 = xmmword_1CFAC46E0;
        uint64_t v275 = 11;
        uint64_t v276 = 2;
        long long v280 = xmmword_1CFAC46A0;
        uint64_t v246 = 12;
        uint64_t v248 = 11;
        uint64_t v249 = 2;
        uint64_t v251 = 12;
        long long v271 = xmmword_1CFAC46E0;
        v274 = "__svml_log2";
        uint64_t v266 = 12;
        uint64_t v267 = 8;
        v268 = "llvm.exp.f32";
        uint64_t v269 = 12;
        long long v253 = xmmword_1CFAC46A0;
        uint64_t v255 = 12;
        uint64_t v260 = 12;
        long long v262 = xmmword_1CFAC46C0;
        v263 = "llvm.exp.f32";
        uint64_t v264 = 12;
        v256 = "__svml_exp8";
        uint64_t v257 = 11;
        uint64_t v258 = 8;
        v259 = "llvm.exp.f32";
        uint64_t v393 = 8;
        v394 = "__log2f_finite";
        uint64_t v395 = 14;
        v396 = "__svml_log2f4";
        long long v397 = xmmword_1CFAC46F0;
        v398 = "__log2f_finite";
        uint64_t v399 = 14;
        v400 = "__svml_log2f8";
        uint64_t v401 = 13;
        uint64_t v402 = 8;
        v403 = "__log2f_finite";
        uint64_t v404 = 14;
        v405 = "__svml_log2f16";
        long long v406 = xmmword_1CFAC4700;
        v407 = "llvm.log2.f64";
        uint64_t v408 = 13;
        v409 = "__svml_log22";
        uint64_t v410 = 12;
        uint64_t v411 = 2;
        v412 = "llvm.log2.f64";
        uint64_t v413 = 13;
        v414 = "__svml_log24";
        long long v415 = xmmword_1CFAC46C0;
        v416 = "llvm.log2.f64";
        uint64_t v417 = 13;
        v418 = "__svml_log28";
        uint64_t v419 = 12;
        uint64_t v420 = 8;
        v421 = "llvm.log2.f32";
        uint64_t v422 = 13;
        v423 = "__svml_log2f4";
        long long v424 = xmmword_1CFAC46F0;
        v425 = "llvm.log2.f32";
        uint64_t v426 = 13;
        v427 = "__svml_log2f8";
        uint64_t v428 = 13;
        uint64_t v429 = 8;
        v430 = "llvm.log2.f32";
        uint64_t v431 = 13;
        v432 = "__svml_log2f16";
        long long v433 = xmmword_1CFAC4700;
        v434 = "log10";
        uint64_t v435 = 5;
        v436 = "__svml_log102";
        uint64_t v437 = 13;
        uint64_t v438 = 2;
        v439 = "log10";
        uint64_t v440 = 5;
        v441 = "__svml_log104";
        long long v442 = xmmword_1CFAC46F0;
        v443 = "log10";
        uint64_t v444 = 5;
        v445 = "__svml_log108";
        uint64_t v446 = 13;
        uint64_t v447 = 8;
        v448 = "log10f";
        uint64_t v449 = 6;
        v450 = "__svml_log10f4";
        long long v451 = xmmword_1CFAC4710;
        v452 = "log10f";
        uint64_t v453 = 6;
        v454 = "__svml_log10f8";
        uint64_t v455 = 14;
        uint64_t v456 = 8;
        v457 = "log10f";
        uint64_t v458 = 6;
        v459 = "__svml_log10f16";
        long long v460 = xmmword_1CFAC4720;
        v461 = "__log10_finite";
        uint64_t v462 = 14;
        v463 = "__svml_log102";
        uint64_t v464 = 13;
        uint64_t v465 = 2;
        v466 = "__log10_finite";
        uint64_t v467 = 14;
        v468 = "__svml_log104";
        long long v469 = xmmword_1CFAC46F0;
        v470 = "__log10_finite";
        uint64_t v471 = 14;
        v472 = "__svml_log108";
        uint64_t v473 = 13;
        uint64_t v474 = 8;
        v475 = "__log10f_finite";
        uint64_t v476 = 15;
        v477 = "__svml_log10f4";
        long long v478 = xmmword_1CFAC4710;
        v479 = "__log10f_finite";
        uint64_t v480 = 15;
        v481 = "__svml_log10f8";
        uint64_t v482 = 14;
        uint64_t v483 = 8;
        v484 = "__log10f_finite";
        uint64_t v485 = 15;
        v486 = "__svml_log10f16";
        long long v487 = xmmword_1CFAC4720;
        v488 = "llvm.log10.f64";
        uint64_t v489 = 14;
        v490 = "__svml_log102";
        uint64_t v491 = 13;
        uint64_t v492 = 2;
        v493 = "llvm.log10.f64";
        uint64_t v494 = 14;
        v495 = "__svml_log104";
        long long v496 = xmmword_1CFAC46F0;
        v497 = "llvm.log10.f64";
        uint64_t v498 = 14;
        v499 = "__svml_log108";
        uint64_t v500 = 13;
        uint64_t v501 = 8;
        v502 = "llvm.log10.f32";
        uint64_t v503 = 14;
        v504 = "__svml_log10f4";
        long long v505 = xmmword_1CFAC4710;
        v506 = "llvm.log10.f32";
        uint64_t v507 = 14;
        v508 = "__svml_log10f8";
        uint64_t v509 = 14;
        uint64_t v510 = 8;
        v511 = "llvm.log10.f32";
        uint64_t v512 = 14;
        v513 = "__svml_log10f16";
        long long v514 = xmmword_1CFAC4720;
        v515 = "sqrt";
        uint64_t v516 = 4;
        v517 = "__svml_sqrt2";
        uint64_t v518 = 12;
        uint64_t v519 = 2;
        v520 = "sqrt";
        uint64_t v521 = 4;
        v522 = "__svml_sqrt4";
        long long v523 = xmmword_1CFAC46C0;
        v524 = "sqrt";
        uint64_t v525 = 4;
        v526 = "__svml_sqrt8";
        uint64_t v527 = 12;
        uint64_t v528 = 8;
        v529 = "sqrtf";
        uint64_t v530 = 5;
        v531 = "__svml_sqrtf4";
        long long v532 = xmmword_1CFAC46F0;
        v533 = "sqrtf";
        uint64_t v534 = 5;
        v535 = "__svml_sqrtf8";
        uint64_t v536 = 13;
        uint64_t v537 = 8;
        v538 = "sqrtf";
        uint64_t v539 = 5;
        v540 = "__svml_sqrtf16";
        long long v541 = xmmword_1CFAC4700;
        v542 = "__sqrt_finite";
        uint64_t v543 = 13;
        v544 = "__svml_sqrt2";
        uint64_t v545 = 12;
        uint64_t v546 = 2;
        v547 = "__sqrt_finite";
        uint64_t v548 = 13;
        v549 = "__svml_sqrt4";
        long long v550 = xmmword_1CFAC46C0;
        v551 = "__sqrt_finite";
        uint64_t v552 = 13;
        v553 = "__svml_sqrt8";
        uint64_t v554 = 12;
        uint64_t v555 = 8;
        v556 = "__sqrtf_finite";
        uint64_t v557 = 14;
        v558 = "__svml_sqrtf4";
        long long v559 = xmmword_1CFAC46F0;
        v560 = "__sqrtf_finite";
        uint64_t v561 = 14;
        v562 = "__svml_sqrtf8";
        uint64_t v563 = 13;
        uint64_t v564 = 8;
        v565 = "__sqrtf_finite";
        uint64_t v566 = 14;
        v567 = "__svml_sqrtf16";
        long long v568 = xmmword_1CFAC4700;
        v569 = "exp2";
        uint64_t v570 = 4;
        v571 = "__svml_exp22";
        uint64_t v572 = 12;
        uint64_t v573 = 2;
        v574 = "exp2";
        uint64_t v575 = 4;
        v576 = "__svml_exp24";
        long long v577 = xmmword_1CFAC46C0;
        v578 = "exp2";
        uint64_t v579 = 4;
        v580 = "__svml_exp28";
        uint64_t v581 = 12;
        uint64_t v582 = 8;
        v583 = "exp2f";
        uint64_t v584 = 5;
        v585 = "__svml_exp2f4";
        long long v586 = xmmword_1CFAC46F0;
        v587 = "exp2f";
        uint64_t v588 = 5;
        v589 = "__svml_exp2f8";
        uint64_t v590 = 13;
        uint64_t v591 = 8;
        v592 = "exp2f";
        uint64_t v593 = 5;
        v594 = "__svml_exp2f16";
        long long v595 = xmmword_1CFAC4700;
        v596 = "llvm.exp2.f64";
        uint64_t v597 = 13;
        v598 = "__svml_exp22";
        uint64_t v599 = 12;
        uint64_t v600 = 2;
        v601 = "llvm.exp2.f64";
        uint64_t v602 = 13;
        v603 = "__svml_exp24";
        long long v604 = xmmword_1CFAC46C0;
        v605 = "llvm.exp2.f64";
        uint64_t v606 = 13;
        v607 = "__svml_exp28";
        uint64_t v608 = 12;
        uint64_t v609 = 8;
        v610 = "llvm.exp2.f32";
        uint64_t v611 = 13;
        v612 = "__svml_exp2f4";
        long long v613 = xmmword_1CFAC46F0;
        v614 = "llvm.exp2.f32";
        uint64_t v615 = 13;
        v616 = "__svml_exp2f8";
        uint64_t v617 = 13;
        uint64_t v618 = 8;
        v619 = "llvm.exp2.f32";
        uint64_t v620 = 13;
        v621 = "__svml_exp2f16";
        long long v622 = xmmword_1CFAC4700;
        v623 = "__exp2_finite";
        uint64_t v624 = 13;
        v625 = "__svml_exp22";
        uint64_t v626 = 12;
        uint64_t v627 = 2;
        v628 = "__exp2_finite";
        uint64_t v629 = 13;
        v630 = "__svml_exp24";
        long long v631 = xmmword_1CFAC46C0;
        v632 = "__exp2_finite";
        uint64_t v633 = 13;
        v634 = "__svml_exp28";
        uint64_t v635 = 12;
        uint64_t v636 = 8;
        v637 = "__exp2f_finite";
        uint64_t v638 = 14;
        v639 = "__svml_exp2f4";
        long long v640 = xmmword_1CFAC46F0;
        v641 = "__exp2f_finite";
        uint64_t v642 = 14;
        v643 = "__svml_exp2f8";
        uint64_t v644 = 13;
        uint64_t v645 = 8;
        v646 = "__exp2f_finite";
        uint64_t v647 = 14;
        v648 = "__svml_exp2f16";
        long long v649 = xmmword_1CFAC4700;
        uint64_t v4 = 144;
        break;
      default:
        JUMPOUT(0);
    }
    llvm::TargetLibraryInfoImpl::addVectorizableFunctions(v0, (char *)&__src, v4);
  }
}

unsigned char *llvm::TargetLibraryInfoImpl::getVectorizedFunction(uint64_t a1, unsigned char *a2, size_t __n, int *a4)
{
  __n128 v7 = sub_1CC154CDC(a2, __n);
  if (v6)
  {
    size_t v8 = v6;
    uint64_t v9 = *(void *)(a1 + 152);
    uint64_t v10 = *(void *)(a1 + 160);
    if (v10 != v9)
    {
      unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - v9) >> 3);
      do
      {
        uint64_t v12 = v9 + 40 * (v11 >> 1);
        BOOL v13 = sub_1CC1565A8(v12, v7, v8);
        if (v13) {
          v11 += ~(v11 >> 1);
        }
        else {
          v11 >>= 1;
        }
        if (v13) {
          uint64_t v9 = v12 + 40;
        }
      }
      while (v11);
    }
    if (v9 != v10)
    {
      int v15 = *a4;
      int v14 = a4[1];
      while (*(void *)(v9 + 8) == v8 && !memcmp(*(const void **)v9, v7, v8))
      {
        if (*(_DWORD *)(v9 + 32) == v15 && *(_DWORD *)(v9 + 36) == v14) {
          return *(unsigned char **)(v9 + 16);
        }
        v9 += 40;
        if (v9 == v10) {
          return 0;
        }
      }
    }
    return 0;
  }
  return v7;
}

uint64_t llvm::TargetLibraryInfoImpl::getWCharSize(llvm::TargetLibraryInfoImpl *this, const llvm::Module *a2)
{
  uint64_t result = llvm::Module::getModuleFlag(a2, "wchar_size", 0xAuLL);
  if (result)
  {
    uint64_t v3 = *(void *)(result + 128);
    uint64_t v4 = (unsigned int *)(v3 + 24);
    if (*(_DWORD *)(v3 + 32) >= 0x41u) {
      uint64_t v4 = *(unsigned int **)v4;
    }
    return *v4;
  }
  return result;
}

llvm::TargetLibraryInfoWrapperPass *llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(llvm::TargetLibraryInfoWrapperPass *this)
{
  v8[25] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::TargetLibraryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2607AA0;
  char v2 = (char *)this + 32;
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((llvm::TargetLibraryInfoImpl *)v8);
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v2, (uint64_t)v8);
  *((unsigned char *)this + 232) = 1;
  uint64_t v3 = sub_1CD4CFA4C(v8);
  *((unsigned char *)this + 240) = 0;
  *((unsigned char *)this + 320) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v3);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC85E8, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CC156794;
    v7[1] = &PassRegistry;
    size_t v6 = v7;
    std::__call_once(&qword_1EBCC85E8, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::TargetLibraryInfoWrapperPass *llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(llvm::TargetLibraryInfoWrapperPass *this, const llvm::Triple *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::TargetLibraryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2607AA0;
  uint64_t v3 = (char *)this + 32;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  *(void *)&long long v4 = -1;
  *((void *)&v4 + 1) = -1;
  v10[0] = v4;
  v10[1] = v4;
  uint64_t v10[2] = v4;
  _OWORD v10[3] = v4;
  _OWORD v10[4] = v4;
  v10[5] = v4;
  *(_OWORD *)unint64_t v11 = v4;
  *(void *)&v11[13] = -1;
  sub_1CC153974((uint64_t)v10, (int *)a2);
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v3, (uint64_t)v10);
  *((unsigned char *)this + 232) = 1;
  uint64_t v5 = sub_1CD4CFA4C((uint64_t *)v10);
  *((unsigned char *)this + 240) = 0;
  *((unsigned char *)this + 320) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v5);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC85E8, memory_order_acquire) != -1)
  {
    v9[0] = sub_1CC156794;
    v9[1] = &PassRegistry;
    size_t v8 = v9;
    std::__call_once(&qword_1EBCC85E8, &v8, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

llvm::TargetLibraryInfoWrapperPass *llvm::TargetLibraryInfoWrapperPass::TargetLibraryInfoWrapperPass(llvm::TargetLibraryInfoWrapperPass *this, const llvm::TargetLibraryInfoImpl *a2)
{
  v9[25] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::TargetLibraryInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2607AA0;
  uint64_t v3 = (char *)this + 32;
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((llvm::TargetLibraryInfoImpl *)v9, a2);
  llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl((uint64_t)v3, (uint64_t)v9);
  *((unsigned char *)this + 232) = 1;
  long long v4 = sub_1CD4CFA4C(v9);
  *((unsigned char *)this + 240) = 0;
  *((unsigned char *)this + 320) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v4);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC85E8, memory_order_acquire) != -1)
  {
    v8[0] = sub_1CC156794;
    v8[1] = &PassRegistry;
    __n128 v7 = v8;
    std::__call_once(&qword_1EBCC85E8, &v7, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::TargetLibraryInfoImpl::getWidestVF(uint64_t a1, unsigned char *a2, size_t __n, void *a4, void *a5)
{
  uint64_t result = (uint64_t)sub_1CC154CDC(a2, __n);
  *a5 = 0x100000000;
  *a4 = 1;
  if (v9)
  {
    uint64_t v10 = (const void *)result;
    size_t v11 = v9;
    uint64_t v12 = *(void *)(a1 + 152);
    uint64_t v13 = *(void *)(a1 + 160);
    if (v13 != v12)
    {
      unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((v13 - v12) >> 3);
      do
      {
        uint64_t v15 = v12 + 40 * (v14 >> 1);
        uint64_t result = sub_1CC1565A8(v15, v10, v11);
        if (result) {
          v14 += ~(v14 >> 1);
        }
        else {
          v14 >>= 1;
        }
        if (result) {
          uint64_t v12 = v15 + 40;
        }
      }
      while (v14);
    }
    for (; v12 != v13; v12 += 40)
    {
      if (*(void *)(v12 + 8) != v11) {
        break;
      }
      uint64_t result = memcmp(*(const void **)v12, v10, v11);
      if (result) {
        break;
      }
      int v16 = *(_DWORD *)(v12 + 36);
      BOOL v17 = v16 == 1;
      uint64_t v18 = v16 == 1 ? a5 : a4;
      BOOL v19 = !v17 && *((_DWORD *)v18 + 1) == 1;
      if (!v19 && *(_DWORD *)(v12 + 32) > *(_DWORD *)v18)
      {
        *uint64_t v18 = *(void *)(v12 + 32);
        uint64_t v13 = *(void *)(a1 + 160);
      }
    }
  }
  return result;
}

void sub_1CD4CF1BC(llvm::ImmutablePass *a1)
{
  sub_1CD4CFB68(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD4CF1F4(void *a1)
{
  *a1 = &unk_1F2607B50;
  char v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2607BB8;
  long long v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD4CF2DC(void *a1)
{
  *a1 = &unk_1F2607BB8;
  char v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD4CF330(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD4CF3C4(v11);
}

uint64_t sub_1CD4CF3C4(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD4CF3DC(void *a1)
{
  sub_1CD4CF1F4(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD4CF414(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD4CF420(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD4CF430(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    long long v4 = &unk_1F2607C08;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD4CF4B4(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD4CF4C8(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD4CF4D0(void *a1)
{
  *a1 = &unk_1F2607BB8;
  char v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD4CF544(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD4CF54C(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD4CF560(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD4CF574(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD4CF588(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

double sub_1CD4CF5B4(uint64_t a1, unsigned int a2, const std::string::value_type *__s2, char *__n)
{
  uint64_t v8 = &(&llvm::TargetLibraryInfoImpl::StandardNames)[2 * a2];
  if (v8[1] == __n && (!__n || !memcmp(*v8, __s2, (size_t)__n)))
  {
    *(unsigned char *)(a1 + ((unint64_t)a2 >> 2)) |= 3 << (2 * (a2 & 3));
  }
  else
  {
    *(unsigned char *)(a1 + ((unint64_t)a2 >> 2)) = *(unsigned char *)(a1 + ((unint64_t)a2 >> 2)) & ~(3 << (2 * (a2 & 3))) | (1 << (2 * (a2 & 3)));
    std::string::__init(&v13, __s2, (std::string::size_type)__n);
    unsigned int v12 = a2;
    uint64_t v10 = sub_1CD4CF730(a1 + 120, &v12);
    uint64_t v11 = (void **)(v10 + 2);
    if (*((char *)v10 + 31) < 0) {
      operator delete(*v11);
    }
    double result = *(double *)&v13.__r_.__value_.__l.__data_;
    *(std::string *)uint64_t v11 = v13;
  }
  return result;
}

uint64_t sub_1CD4CF6B4(llvm::Triple *a1, unsigned int a2)
{
  v11[0] = llvm::Triple::getEnvironmentVersion(a1);
  v11[1] = v4;
  if (llvm::Triple::isArch64Bit(a1) && LODWORD(v11[0]) <= 0x14)
  {
    uint64_t v9 = 21;
    uint64_t v10 = 0;
    v8[0] = a2;
    v8[1] = 0;
    int v5 = &v9;
    char v6 = v8;
  }
  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = 0;
    int v5 = v11;
    char v6 = &v9;
  }
  return sub_1CC156834(v5, v6);
}

_DWORD *sub_1CD4CF730(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    char v6 = sub_1CD4CF7F8(a1, (uint64_t)a2, a2, v9);
    *char v6 = *a2;
    *((void *)v6 + 2) = 0;
    *((void *)v6 + 3) = 0;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  char v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      int v13 = v5 + v11++;
      uint64_t v5 = v13 & v4;
      char v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD4CF7F8(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3) {
      goto LABEL_3;
    }
    sub_1CD4CF980(a1, v7);
    int v17 = *(_DWORD *)(a1 + 16);
    if (v17)
    {
      unsigned int v18 = v17 - 1;
      uint64_t v19 = (37 * *a3) & v18;
      a4 = (_DWORD *)(*(void *)a1 + 32 * v19);
      int v20 = *a4;
      if (*a3 == *a4) {
        goto LABEL_3;
      }
      int v13 = 0;
      int v21 = 1;
      while (v20 != -1)
      {
        if (v13) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v20 == -2;
        }
        if (v22) {
          int v13 = a4;
        }
        int v23 = v19 + v21++;
        uint64_t v19 = v23 & v18;
        a4 = (_DWORD *)(*(void *)a1 + 32 * v19);
        int v20 = *a4;
        if (*a3 == *a4) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a4 = 0;
    goto LABEL_3;
  }
  sub_1CD4CF980(a1, 2 * v7);
  int v9 = *(_DWORD *)(a1 + 16);
  if (!v9) {
    goto LABEL_24;
  }
  unsigned int v10 = v9 - 1;
  uint64_t v11 = (37 * *a3) & v10;
  a4 = (_DWORD *)(*(void *)a1 + 32 * v11);
  int v12 = *a4;
  if (*a3 == *a4) {
    goto LABEL_3;
  }
  int v13 = 0;
  int v14 = 1;
  while (v12 != -1)
  {
    if (v13) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v12 == -2;
    }
    if (v15) {
      int v13 = a4;
    }
    int v16 = v11 + v14++;
    uint64_t v11 = v16 & v10;
    a4 = (_DWORD *)(*(void *)a1 + 32 * v11);
    int v12 = *a4;
    if (*a3 == *a4) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v13) {
    a4 = v13;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_DWORD *sub_1CD4CF980(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC1568B0(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      *double result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t *sub_1CD4CFA4C(uint64_t *a1)
{
  char v2 = (void *)a1[22];
  if (v2)
  {
    a1[23] = (uint64_t)v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[19];
  if (v3)
  {
    a1[20] = (uint64_t)v3;
    operator delete(v3);
  }
  sub_1CD4CFAA0(a1 + 15);
  return a1;
}

uint64_t *sub_1CD4CFAA0(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v6 = v3;
    uint64_t v5 = 32 * v2;
    do
    {
      if (*(_DWORD *)v6 <= 0xFFFFFFFD && *(char *)(v6 + 31) < 0) {
        operator delete(*(void **)(v6 + 8));
      }
      v6 += 32;
      v5 -= 32;
    }
    while (v5);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void llvm::callDefaultCtor<llvm::TargetLibraryInfoWrapperPass>()
{
}

void sub_1CD4CFB68(llvm::ImmutablePass *this)
{
  *(void *)this = &unk_1F2607AA0;
  if (*((unsigned char *)this + 320))
  {
    uint64_t v2 = (char *)*((void *)this + 31);
    if (v2 != (char *)this + 264) {
      free(v2);
    }
    *((unsigned char *)this + 320) = 0;
  }
  if (*((unsigned char *)this + 232))
  {
    sub_1CD4CFA4C((uint64_t *)this + 4);
    *((unsigned char *)this + 232) = 0;
  }

  llvm::ImmutablePass::~ImmutablePass(this);
}

void sub_1CD4CFBEC(_WORD *a1, long long *a2, int **a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC8390, 0, 0);
  dword_1EBCC8410 = 0;
  qword_1EBCC8418 = (uint64_t)&unk_1F2607C08;
  *(void *)&dword_1EBCC8420 = 0;
  qword_1EBCC8390 = (uint64_t)&unk_1F2607B50;
  qword_1EBCC8428 = (uint64_t)&unk_1F2607BB8;
  qword_1EBCC8430 = (uint64_t)&qword_1EBCC8390;
  qword_1EBCC8438 = (uint64_t)&unk_1EBCC8448;
  qword_1EBCC8440 = 0x800000000;
  qword_1EBCC85C8 = (uint64_t)&unk_1F2607C48;
  qword_1EBCC85E0 = (uint64_t)&qword_1EBCC85C8;
  sub_1CD4CFD00(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC8390);
}

void sub_1CD4CFD00(_WORD *a1, long long *a2, int **a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC8390, "vector-library", 0xEuLL);
  word_1EBCC839A = (32 * (*a1 & 3)) | word_1EBCC839A & 0xFF9F;
  xmmword_1EBCC83B0 = *a2;
  unsigned int v8 = *a3;
  dword_1EBCC8410 = **a3;
  byte_1EBCC8424 = 1;
  dword_1EBCC8420 = *v8;
  uint64_t v9 = *(void *)a4;
  unsigned int v10 = *(_DWORD *)(a4 + 8);

  sub_1CC156D40(v9, v10);
}

void sub_1CD4CFDB0()
{
}

void *sub_1CD4CFDC4()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1F2607C48;
  return result;
}

void sub_1CD4CFDFC(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2607C48;
}

void sub_1CD4CFE28()
{
}

uint64_t *sub_1CD4CFF20(uint64_t *result, uint64_t *a2)
{
  result[1] = a2[1];
  if (*((_DWORD *)result + 4))
  {
    uint64_t v3 = result;
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = *v3;
      uint64_t v7 = *a2;
      unsigned int v8 = *(_DWORD *)(*a2 + v4);
      *(_DWORD *)(*v3 + v4) = v8;
      if (v8 <= 0xFFFFFFFD)
      {
        double result = (uint64_t *)(v6 + v4 + 8);
        uint64_t v9 = v7 + v4;
        uint64_t v10 = v7 + v4 + 8;
        if (*(char *)(v9 + 31) < 0)
        {
          double result = (uint64_t *)sub_1CB8BDF7C((uint64_t)result, *(const void **)v10, *(void *)(v9 + 16));
        }
        else
        {
          long long v11 = *(_OWORD *)v10;
          result[2] = *(void *)(v10 + 16);
          *(_OWORD *)double result = v11;
        }
      }
      ++v5;
      v4 += 32;
    }
    while (v5 < *((unsigned int *)v3 + 4));
  }
  return result;
}

void sub_1CD4CFFD0(uint64_t a1, __n128 *a2, uint64_t (**a3)(long long *, long long *), uint64_t a4, char a5, __n128 a6)
{
  while (2)
  {
    int v13 = &a2[-3].n128_i8[8];
LABEL_2:
    for (uint64_t i = 1 - a4; ; ++i)
    {
      uint64_t v15 = (uint64_t)a2 - a1;
      unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a2 - a1) >> 3);
      if (!(!v7 & v6))
      {
        switch(v16)
        {
          case 0uLL:
          case 1uLL:
            return;
          case 2uLL:
            if ((*a3)((long long *)&a2[-3].n128_i8[8], (long long *)a1))
            {
              long long v32 = *(_OWORD *)a1;
              __n128 v33 = *(__n128 *)(a1 + 16);
              unint64_t v61 = *(void *)(a1 + 32);
              long long v59 = v32;
              __n128 v60 = v33;
              long long v34 = *(_OWORD *)v13;
              long long v35 = *(long long *)((char *)&a2[-2] + 8);
              *(void *)(a1 + 32) = a2[-1].n128_u64[1];
              *(_OWORD *)a1 = v34;
              *(_OWORD *)(a1 + 16) = v35;
              *(_OWORD *)int v13 = v59;
              *(__n128 *)((char *)a2 - 24) = v60;
              a2[-1].n128_u64[1] = v61;
            }
            break;
          case 3uLL:
            sub_1CC1573DC((long long *)a1, (long long *)(a1 + 40), (long long *)&a2[-3].n128_i8[8], a3);
            break;
          case 4uLL:
            sub_1CC1579F0(a1, a1 + 40, a1 + 80, (uint64_t)&a2[-3].n128_i64[1], a3);
            break;
          case 5uLL:
            sub_1CC157ADC(a1, a1 + 40, a1 + 80, a1 + 120, (uint64_t)&a2[-3].n128_i64[1], a3);
            break;
          default:
            JUMPOUT(0);
        }
        return;
      }
      if (v15 <= 959)
      {
        uint64_t v36 = (long long *)(a1 + 40);
        BOOL v38 = (__n128 *)a1 == a2 || v36 == (long long *)a2;
        if (a5)
        {
          if (!v38)
          {
            uint64_t v39 = 0;
            uint64_t v40 = a1;
            do
            {
              uint64_t v41 = (long long *)v40;
              uint64_t v40 = (uint64_t)v36;
              if ((*a3)(v36, v41))
              {
                long long v42 = *(_OWORD *)v40;
                __n128 v43 = *(__n128 *)(v40 + 16);
                unint64_t v61 = *(void *)(v40 + 32);
                long long v59 = v42;
                __n128 v60 = v43;
                uint64_t v44 = v39;
                while (1)
                {
                  uint64_t v45 = a1 + v44;
                  long long v46 = *(_OWORD *)(a1 + v44 + 16);
                  *(_OWORD *)(v45 + 40) = *(_OWORD *)(a1 + v44);
                  *(_OWORD *)(v45 + 56) = v46;
                  *(void *)(v45 + 72) = *(void *)(a1 + v44 + 32);
                  if (!v44) {
                    break;
                  }
                  v44 -= 40;
                  if (((*a3)(&v59, (long long *)(v44 + a1)) & 1) == 0)
                  {
                    uint64_t v47 = a1 + v44 + 40;
                    goto LABEL_45;
                  }
                }
                uint64_t v47 = a1;
LABEL_45:
                long long v48 = v59;
                __n128 v49 = v60;
                *(void *)(v47 + 32) = v61;
                *(_OWORD *)uint64_t v47 = v48;
                *(__n128 *)(v47 + 16) = v49;
              }
              uint64_t v36 = (long long *)(v40 + 40);
              v39 += 40;
            }
            while ((__n128 *)(v40 + 40) != a2);
          }
        }
        else if (!v38)
        {
          uint64_t v50 = a1 - 40;
          do
          {
            uint64_t v51 = (long long *)a1;
            a1 = (uint64_t)v36;
            if ((*a3)(v36, v51))
            {
              long long v52 = *(_OWORD *)a1;
              __n128 v53 = *(__n128 *)(a1 + 16);
              unint64_t v61 = *(void *)(a1 + 32);
              long long v59 = v52;
              __n128 v60 = v53;
              uint64_t v54 = v50;
              do
              {
                long long v55 = *(_OWORD *)(v54 + 56);
                *(_OWORD *)(v54 + 80) = *(_OWORD *)(v54 + 40);
                *(_OWORD *)(v54 + 96) = v55;
                *(void *)(v54 + 112) = *(void *)(v54 + 72);
                char v56 = (*a3)(&v59, (long long *)v54);
                v54 -= 40;
              }
              while ((v56 & 1) != 0);
              long long v57 = v59;
              __n128 v58 = v60;
              *(void *)(v54 + 112) = v61;
              *(_OWORD *)(v54 + 80) = v57;
              *(__n128 *)(v54 + 96) = v58;
            }
            uint64_t v36 = (long long *)(a1 + 40);
            v50 += 40;
          }
          while ((__n128 *)(a1 + 40) != a2);
        }
        return;
      }
      if (i == 1)
      {
        if ((__n128 *)a1 != a2)
        {
          sub_1CC157C08(a1, a2, a2, (unsigned int (**)(int64_t, uint64_t))a3, a6);
        }
        return;
      }
      unint64_t v17 = v16 >> 1;
      unint64_t v18 = a1 + 40 * (v16 >> 1);
      if ((unint64_t)v15 >= 0x1401)
      {
        sub_1CC1573DC((long long *)a1, (long long *)(a1 + 40 * (v16 >> 1)), (long long *)&a2[-3].n128_i8[8], a3);
        uint64_t v19 = 5 * v17;
        int v20 = (long long *)(a1 + 40 * v17 - 40);
        sub_1CC1573DC((long long *)(a1 + 40), v20, (long long *)&a2[-5], a3);
        int v21 = (long long *)(a1 + 40 + 8 * v19);
        sub_1CC1573DC((long long *)(a1 + 80), v21, (long long *)&a2[-8].n128_i8[8], a3);
        sub_1CC1573DC(v20, (long long *)v18, v21, a3);
        long long v22 = *(_OWORD *)a1;
        __n128 v23 = *(__n128 *)(a1 + 16);
        unint64_t v61 = *(void *)(a1 + 32);
        long long v59 = v22;
        __n128 v60 = v23;
        long long v24 = *(_OWORD *)v18;
        long long v25 = *(_OWORD *)(v18 + 16);
        *(void *)(a1 + 32) = *(void *)(v18 + 32);
        *(_OWORD *)a1 = v24;
        *(_OWORD *)(a1 + 16) = v25;
        long long v26 = v59;
        __n128 v27 = v60;
        *(void *)(v18 + 32) = v61;
        *(_OWORD *)unint64_t v18 = v26;
        *(__n128 *)(v18 + 16) = v27;
      }
      else
      {
        sub_1CC1573DC((long long *)(a1 + 40 * (v16 >> 1)), (long long *)a1, (long long *)&a2[-3].n128_i8[8], a3);
      }
      if ((a5 & 1) == 0 && ((*a3)((long long *)(a1 - 40), (long long *)a1) & 1) == 0)
      {
        uint64_t v31 = sub_1CC157518((long long *)a1, (long long *)a2, a3);
        goto LABEL_15;
      }
      uint64_t v28 = sub_1CC157678((long long *)a1, (char *)a2, (uint64_t (**)(char *, long long *))a3);
      if ((v29 & 1) == 0) {
        goto LABEL_62;
      }
      BOOL v30 = sub_1CC1577D8(a1, v28, a3);
      uint64_t v31 = (long long *)(v28 + 40);
      if (sub_1CC1577D8(v28 + 40, (uint64_t)a2, a3)) {
        break;
      }
      if (!v30)
      {
LABEL_62:
        a4 = -i;
        sub_1CD4CFFD0(a1, v28, a3, -i, a5 & 1);
        a5 = 0;
        a1 = v28 + 40;
        goto LABEL_2;
      }
LABEL_15:
      a1 = (uint64_t)v31;
    }
    a4 = -i;
    a2 = (__n128 *)v28;
    if (!v30) {
      continue;
    }
    break;
  }
}

uint64_t sub_1CD4D04B8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 200))
  {
    sub_1CD4CC35C((uint64_t *)(a1 + 120), (uint64_t *)(a2 + 120));
    *(_WORD *)(a1 + 144) = *(_WORD *)(a2 + 144);
    *(unsigned char *)(a1 + 146) = *(unsigned char *)(a2 + 146);
    *(_DWORD *)(a1 + 148) = *(_DWORD *)(a2 + 148);
    memmove((void *)a1, (const void *)a2, 0x75uLL);
  }
  else
  {
    llvm::TargetLibraryInfoImpl::TargetLibraryInfoImpl(a1, a2);
    *(unsigned char *)(a1 + 200) = 1;
  }
  return a1;
}

uint64_t llvm::HardwareLoopInfo::canAnalyze(llvm::HardwareLoopInfo *this, llvm::LoopInfo *a2)
{
  sub_1CBFCBAB0((uint64_t)v5, *(void *)this);
  llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)v5, a2);
  uint64_t v3 = sub_1CC1581E4(v5, (uint64_t *)a2) ^ 1;
  sub_1CBFCBB34(v5);
  return v3;
}

uint64_t llvm::IntrinsicCostAttributes::IntrinsicCostAttributes(uint64_t a1, int a2, uint64_t a3, uint64_t *__src, uint64_t a5)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x400000000;
  *(void *)(a1 + 72) = a1 + 88;
  *(void *)(a1 + 80) = 0x400000000;
  *(_DWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 128) = xmmword_1CD96D880;
  sub_1CD4D069C((unsigned int *)(a1 + 72), a1 + 88, __src, &__src[a5]);
  unsigned int v6 = *(_DWORD *)(a1 + 80);
  if (*(_DWORD *)(a1 + 36) < v6) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v6)
  {
    uint64_t v7 = 0;
    unsigned int v8 = *(_DWORD *)(a1 + 32);
    do
    {
      if (v8 >= *(_DWORD *)(a1 + 36)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 24) + 8 * v8) = **(void **)(*(void *)(a1 + 72) + v7);
      unsigned int v8 = *(_DWORD *)(a1 + 32) + 1;
      *(_DWORD *)(a1 + 32) = v8;
      v7 += 8;
    }
    while (8 * v6 != v7);
  }
  return a1;
}

unsigned char *sub_1CD4D069C(unsigned int *a1, uint64_t a2, uint64_t *__src, uint64_t *a4)
{
  unint64_t v5 = __src;
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v9 = a1[2];
  if (*(void *)a1 + 8 * v9 == a2)
  {
    sub_1CD47792C(a1, __src, a4);
    return (unsigned char *)(*(void *)a1 + 8 * v8);
  }
  else
  {
    unint64_t v10 = a4 - __src;
    if (v9 + v10 > a1[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    long long v11 = (unsigned char *)(v7 + 8 * v8);
    int v12 = (unsigned char *)(v7 + 8 * v9);
    unint64_t v13 = (v12 - v11) >> 3;
    if (v13 >= v10)
    {
      sub_1CD4570C8((uint64_t)a1, &v12[-8 * v10], (char *)(v7 + 8 * v9));
      if (&v12[-8 * v10] != v11) {
        memmove(&v11[8 * v10], v11, &v12[-8 * v10] - v11);
      }
      if (v5 != a4) {
        memmove(v11, v5, (char *)a4 - (char *)v5);
      }
    }
    else
    {
      unsigned int v14 = v9 + ((unint64_t)((char *)a4 - (char *)__src) >> 3);
      a1[2] = v14;
      if (v8 != v9)
      {
        memcpy((void *)(v7 + 8 * v14 - 8 * v13), v11, v12 - v11);
        uint64_t v15 = v11;
        do
        {
          uint64_t v16 = *v5++;
          *v15++ = v16;
          --v13;
        }
        while (v13);
      }
      if (v5 != a4) {
        memcpy(v12, v5, (char *)a4 - (char *)v5);
      }
    }
  }
  return v11;
}

uint64_t llvm::TargetTransformInfo::getGEPCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 24))();
}

uint64_t llvm::TargetTransformInfo::useGPUDivergenceAnalysis(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 96))();
}

uint64_t llvm::TargetTransformInfo::isSourceOfDivergence(llvm::TargetTransformInfo *this, const llvm::Value *a2)
{
  return (*(uint64_t (**)(void, const llvm::Value *))(**(void **)this + 104))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isAlwaysUniform(llvm::TargetTransformInfo *this, const llvm::Value *a2)
{
  return (*(uint64_t (**)(void, const llvm::Value *))(**(void **)this + 112))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getFlatAddressSpace(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 120))();
}

uint64_t llvm::TargetTransformInfo::collectFlatAddressOperands(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 128))();
}

uint64_t llvm::TargetTransformInfo::isNoopAddrSpaceCast(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 136))();
}

uint64_t llvm::TargetTransformInfo::getAssumedAddrSpace(llvm::TargetTransformInfo *this, const llvm::Value *a2)
{
  return (*(uint64_t (**)(void, const llvm::Value *))(**(void **)this + 152))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::rewriteIntrinsicWithAddressSpace(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 168))();
}

uint64_t llvm::TargetTransformInfo::isHardwareLoopProfitable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 200))();
}

uint64_t llvm::TargetTransformInfo::preferPredicateOverEpilogue(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 208))(*a1);
}

uint64_t llvm::TargetTransformInfo::emitGetActiveLaneMask(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 216))();
}

uint64_t llvm::TargetTransformInfo::isLegalAddImmediate(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 248))();
}

uint64_t llvm::TargetTransformInfo::isLegalICmpImmediate(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 256))();
}

uint64_t llvm::TargetTransformInfo::isLegalAddressingMode(llvm::TargetTransformInfo *this, llvm::Type *a2, llvm::GlobalValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, llvm::Instruction *a8)
{
  return (*(uint64_t (**)(void, llvm::Type *, llvm::GlobalValue *, uint64_t, uint64_t, uint64_t, uint64_t, llvm::Instruction *))(**(void **)this + 264))(*(void *)this, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t llvm::TargetTransformInfo::isLSRCostLess(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 272))();
}

uint64_t llvm::TargetTransformInfo::isNumRegsMajorCostOfLSR(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 280))();
}

uint64_t llvm::TargetTransformInfo::isProfitableLSRChainElement(llvm::TargetTransformInfo *this, llvm::Instruction *a2)
{
  return (*(uint64_t (**)(void, llvm::Instruction *))(**(void **)this + 288))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::canMacroFuseCmp(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 296))();
}

uint64_t llvm::TargetTransformInfo::canSaveCmp(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 304))(*a1);
}

uint64_t llvm::TargetTransformInfo::getPreferredAddressingMode(llvm::TargetTransformInfo *this, const llvm::Loop *a2, llvm::ScalarEvolution *a3)
{
  return (*(uint64_t (**)(void, const llvm::Loop *, llvm::ScalarEvolution *))(**(void **)this + 312))(*(void *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedStore(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 320))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedLoad(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 328))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalNTStore(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 336))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalNTLoad(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 344))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalBroadcastLoad(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 352))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedGather(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 368))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedScatter(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 360))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::forceScalarizeMaskedGather(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 376))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::forceScalarizeMaskedScatter(void *a1, uint64_t a2, unsigned __int8 a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)*a1 + 384))(*a1, a2, a3);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedCompressStore(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 392))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isLegalMaskedExpandLoad(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 400))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::enableOrderedReductions(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 408))();
}

uint64_t llvm::TargetTransformInfo::hasDivRemOp(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 416))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::hasVolatileVariant(llvm::TargetTransformInfo *this, llvm::Instruction *a2)
{
  return (*(uint64_t (**)(void, llvm::Instruction *))(**(void **)this + 424))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::prefersVectorizedAddressing(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 432))();
}

uint64_t llvm::TargetTransformInfo::getScalingFactorCost(llvm::TargetTransformInfo *this, llvm::Type *a2, llvm::GlobalValue *a3)
{
  return (*(uint64_t (**)(void, llvm::Type *, llvm::GlobalValue *))(**(void **)this + 440))(*(void *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::LSRWithInstrQueries(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 448))();
}

uint64_t llvm::TargetTransformInfo::useAA(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 472))();
}

uint64_t llvm::TargetTransformInfo::isTypeLegal(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 480))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getRegUsageForType(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 488))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::shouldBuildRelLookupTables(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 512))();
}

uint64_t llvm::TargetTransformInfo::getScalarizationOverhead(llvm::TargetTransformInfo *this, llvm::VectorType *a2, const llvm::APInt *a3)
{
  return (*(uint64_t (**)(void, llvm::VectorType *, const llvm::APInt *))(**(void **)this + 528))(*(void *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::getOperandsScalarizationOverhead(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 536))();
}

uint64_t llvm::TargetTransformInfo::supportsEfficientVectorElementLoadStore(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 544))();
}

uint64_t llvm::TargetTransformInfo::enableAggressiveInterleaving(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 552))();
}

uint64_t llvm::TargetTransformInfo::enableMemCmpExpansion(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 560))();
}

uint64_t llvm::TargetTransformInfo::enableInterleavedAccessVectorization(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 568))();
}

uint64_t llvm::TargetTransformInfo::enableMaskedInterleavedAccessVectorization(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 576))();
}

uint64_t llvm::TargetTransformInfo::shouldDistributeLoopToImproveMemoryThroughput(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 584))();
}

uint64_t llvm::TargetTransformInfo::isFPVectorizationPotentiallyUnsafe(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 592))();
}

uint64_t llvm::TargetTransformInfo::getPopcntSupport(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 608))();
}

uint64_t llvm::TargetTransformInfo::haveFastSqrt(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 616))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::isFCmpOrdCheaperThanFCmpZero(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 624))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getIntImmCodeSizeCost(llvm::TargetTransformInfo *this, uint64_t a2, uint64_t a3, const llvm::APInt *a4, llvm::Type *a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, const llvm::APInt *, llvm::Type *))(**(void **)this
                                                                                                + 640))(*(void *)this, a2, a3, a4, a5);
}

uint64_t llvm::TargetTransformInfo::getIntImmCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 648))();
}

uint64_t llvm::TargetTransformInfo::getIntImmCostInst(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 656))();
}

uint64_t llvm::TargetTransformInfo::getIntImmCostIntrin(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 664))();
}

uint64_t llvm::TargetTransformInfo::getNumberOfRegisters(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 672))();
}

uint64_t llvm::TargetTransformInfo::getRegisterClassForType(llvm::TargetTransformInfo *this, uint64_t a2, llvm::Type *a3)
{
  return (*(uint64_t (**)(void, uint64_t, llvm::Type *))(**(void **)this + 680))(*(void *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::getRegisterBitWidth(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 696))();
}

uint64_t llvm::TargetTransformInfo::getMinVectorRegisterBitWidth(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 704))();
}

uint64_t llvm::TargetTransformInfo::getMaxVScale(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 712))();
}

uint64_t llvm::TargetTransformInfo::getVScaleForTuning(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 720))();
}

uint64_t llvm::TargetTransformInfo::shouldMaximizeVectorBandwidth(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 728))();
}

uint64_t llvm::TargetTransformInfo::getMinimumVF(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 736))();
}

uint64_t llvm::TargetTransformInfo::getMaximumVF(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 744))();
}

uint64_t llvm::TargetTransformInfo::getCacheLineSize(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 760))();
}

uint64_t llvm::TargetTransformInfo::getPrefetchDistance(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 784))();
}

uint64_t llvm::TargetTransformInfo::getMinPrefetchStride(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 792))();
}

uint64_t llvm::TargetTransformInfo::getMaxPrefetchIterationsAhead(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 800))();
}

uint64_t llvm::TargetTransformInfo::enableWritePrefetching(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 808))();
}

uint64_t llvm::TargetTransformInfo::getMaxInterleaveFactor(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 816))();
}

uint64_t llvm::TargetTransformInfo::getShuffleCost(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 832))(*a1);
}

uint64_t llvm::TargetTransformInfo::getCastInstrCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 840))();
}

uint64_t llvm::TargetTransformInfo::getExtractWithExtendCost(llvm::TargetTransformInfo *this, uint64_t a2, llvm::Type *a3, llvm::VectorType *a4)
{
  return (*(uint64_t (**)(void, uint64_t, llvm::Type *, llvm::VectorType *))(**(void **)this + 848))(*(void *)this, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getCFInstrCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 856))();
}

uint64_t llvm::TargetTransformInfo::getVectorInstrCost(llvm::TargetTransformInfo *this, uint64_t a2, llvm::Type *a3)
{
  return (*(uint64_t (**)(void, uint64_t, llvm::Type *))(**(void **)this + 872))(*(void *)this, a2, a3);
}

uint64_t llvm::TargetTransformInfo::getMemoryOpCost(void *a1, uint64_t a2, uint64_t a3, unsigned __int8 a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)*a1 + 888))(*a1, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getMaskedMemoryOpCost(void *a1, uint64_t a2, uint64_t a3, unsigned __int8 a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(*(void *)*a1 + 904))(*a1, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getGatherScatterOpCost(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)*a1 + 912))(*a1, a2, a3, a4, a5, a6);
}

uint64_t llvm::TargetTransformInfo::getInterleavedMemoryOpCost(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)*a1 + 920))(*a1, a2, a3, a4, a5, a6, a7);
}

uint64_t llvm::TargetTransformInfo::getIntrinsicInstrCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 952))();
}

uint64_t llvm::TargetTransformInfo::getCallInstrCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 960))();
}

uint64_t llvm::TargetTransformInfo::getNumberOfParts(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 968))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getAddressComputationCost(llvm::TargetTransformInfo *this, llvm::Type *a2, llvm::ScalarEvolution *a3, const llvm::SCEV *a4)
{
  return (*(uint64_t (**)(void, llvm::Type *, llvm::ScalarEvolution *, const llvm::SCEV *))(**(void **)this + 976))(*(void *)this, a2, a3, a4);
}

uint64_t llvm::TargetTransformInfo::getArithmeticReductionCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 928))();
}

uint64_t llvm::TargetTransformInfo::getMinMaxReductionCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 936))();
}

uint64_t llvm::TargetTransformInfo::getExtendedAddReductionCost(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 944))();
}

uint64_t llvm::TargetTransformInfo::getCostOfKeepingLiveOverCall(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 984))();
}

uint64_t llvm::TargetTransformInfo::getAtomicMemIntrinsicMaxElementSize(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 1000))();
}

uint64_t llvm::TargetTransformInfo::getOrCreateResultFromMemIntrinsic(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 1008))();
}

uint64_t llvm::TargetTransformInfo::isIndexedLoadLegal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 1048))();
}

uint64_t llvm::TargetTransformInfo::isIndexedStoreLegal(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 1056))();
}

uint64_t llvm::TargetTransformInfo::isLegalToVectorizeReduction(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 1104))();
}

uint64_t llvm::TargetTransformInfo::isElementTypeLegalForScalableVector(llvm::TargetTransformInfo *this, llvm::Type *a2)
{
  return (*(uint64_t (**)(void, llvm::Type *))(**(void **)this + 1112))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::preferInLoopReduction(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)*a1 + 1136))(*a1, a2, a3, *(void *)&a4 & 0xFFFFFFLL);
}

uint64_t llvm::TargetTransformInfo::preferPredicatedReductionSelect(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)*a1 + 1144))(*a1, a2, a3, *(void *)&a4 & 0xFFFFFFLL);
}

uint64_t llvm::TargetTransformInfo::getVPLegalizationStrategy(llvm::TargetTransformInfo *this, const llvm::VPIntrinsic *a2)
{
  return (*(uint64_t (**)(void, const llvm::VPIntrinsic *))(**(void **)this + 1200))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::shouldExpandReduction(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 1152))();
}

uint64_t llvm::TargetTransformInfo::getGISelRematGlobalCost(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 1160))();
}

uint64_t llvm::TargetTransformInfo::supportsScalableVectors(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 1176))();
}

uint64_t llvm::TargetTransformInfo::enableScalableVectorization(llvm::TargetTransformInfo *this)
{
  return (*(uint64_t (**)(void))(**(void **)this + 1168))();
}

uint64_t llvm::TargetTransformInfo::getInstructionLatency(llvm::TargetTransformInfo *this, const llvm::Instruction *a2)
{
  return (*(uint64_t (**)(void, const llvm::Instruction *))(**(void **)this + 1192))(*(void *)this, a2);
}

uint64_t llvm::TargetTransformInfo::getInstructionThroughput(llvm::TargetTransformInfo *this, const llvm::Instruction *a2)
{
  unsigned int v2 = *((unsigned __int8 *)a2 + 16) - 29;
  BOOL v3 = v2 > 0x3F;
  unint64_t v4 = (1 << v2) & 0xF1F3FFE3BFFFF807;
  if (v3 || v4 == 0) {
    return -1;
  }
  else {
    return sub_1CBFB51A8(this, (uint64_t)a2);
  }
}

void llvm::TargetIRAnalysis::getDefaultTTI(llvm::TargetIRAnalysis *this, const llvm::Function *a2)
{
}

llvm::TargetTransformInfoWrapperPass *llvm::TargetTransformInfoWrapperPass::TargetTransformInfoWrapperPass(llvm::TargetTransformInfoWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = llvm::TargetTransformInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2607C90;
  *((void *)this + 4) = &unk_1F2608228;
  *((void *)this + 5) = llvm::TargetIRAnalysis::getDefaultTTI;
  *((void *)this + 7) = (char *)this + 32;
  *((unsigned char *)this + 64) = 0;
  *((unsigned char *)this + 72) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC86B0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC15A204;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCC86B0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::TargetTransformInfoWrapperPass::TargetTransformInfoWrapperPass(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &llvm::TargetTransformInfoWrapperPass::ID;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F2607C90;
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 56) = a1 + 32;
      a1 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1 + 32);
    }
    else
    {
      *(void *)(a1 + 56) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 56) = 0;
  }
  *(unsigned char *)(v2 + 64) = 0;
  *(unsigned char *)(v2 + 72) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC86B0, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CC15A204;
    v7[1] = &PassRegistry;
    unsigned int v6 = v7;
    std::__call_once(&qword_1EBCC86B0, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return v2;
}

void llvm::createTargetTransformInfoWrapperPass()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1CD4D2110(uint64_t a1)
{
  sub_1CD4D2184(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::TargetTransformInfoWrapperPass>()
{
}

void sub_1CD4D2184(uint64_t a1)
{
  *(void *)a1 = &unk_1F2607C90;
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v2 = *(void *)(a1 + 64);
    *(void *)(a1 + 64) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    *(unsigned char *)(a1 + 72) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3 == a1 + 32)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }

  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

void sub_1CD4D2278()
{
}

void *sub_1CD4D228C(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1F2608228;
  result[1] = v3;
  return result;
}

uint64_t sub_1CD4D22D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2608228;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CD4D2300(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

BOOL llvm::MDNode::isTBAAVtableAccess(llvm::MDNode *this)
{
  int v2 = sub_1CB8F0DA8(*((unsigned char **)this - *((unsigned int *)this + 2)));
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v2) {
    BOOL v4 = v3 > 2;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    unsigned int v6 = (char *)this - 8 * v3;
    uint64_t v7 = (unsigned char *)*((void *)v6 + 1);
    if (v7)
    {
      if (sub_1CB8F0DA8(v7)) {
        uint64_t v8 = *((void *)v6 + 1);
      }
      else {
        uint64_t v8 = 0;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *(unsigned int *)(v8 + 8);
    if (v9 >= 3)
    {
      if (sub_1CB8F0DA8(*(unsigned char **)(v8 - 8 * v9))) {
        uint64_t v10 = 2;
      }
      else {
        uint64_t v10 = 0;
      }
      LODWORD(v9) = *(_DWORD *)(v8 + 8);
    }
    else
    {
      uint64_t v10 = 0;
    }
    unint64_t v5 = *(llvm::MDString **)(v8 - 8 * v9 + 8 * v10);
  }
  else
  {
    if (!v3) {
      return 0;
    }
    unint64_t v5 = (llvm::MDString *)*((void *)this - v3);
  }
  if (*(unsigned char *)v5) {
    return 0;
  }
  String = (void *)llvm::MDString::getString(v5);
  if (v13 != 14) {
    return 0;
  }
  return *String == 0x7020656C62617476 && *(void *)((char *)String + 6) == 0x7265746E696F7020;
}

llvm::MDNode *llvm::AAMDNodes::merge@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *a1;
  uint64_t v7 = *a2;
  uint64_t v11 = 0;
  ((void (*)(uint64_t, uint64_t, uint64_t *))loc_1CC15C65C)(v6, v7, &v11);
  *a3 = v11;
  a3[1] = 0;
  a3[2] = llvm::MDNode::getMostGenericAliasScope((llvm::MDNode *)a1[2], (llvm::MDNode *)a2[2], v8);
  double result = llvm::MDNode::intersect((llvm::MDNode *)a1[3], (llvm::MDNode *)a2[3], v9);
  a3[3] = result;
  return result;
}

llvm::MDNode *llvm::AAMDNodes::concat@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, llvm::MDNode *a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = llvm::MDNode::getMostGenericAliasScope(*(llvm::MDNode **)(a1 + 16), *(llvm::MDNode **)(a2 + 16), a3);
  double result = llvm::MDNode::intersect(*(llvm::MDNode **)(a1 + 24), *(llvm::MDNode **)(a2 + 24), v7);
  a4[3] = result;
  return result;
}

void llvm::initializeTypeBasedAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC86B8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC15CAB0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC86B8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createTypeBasedAAWrapperPass(llvm *this)
{
}

llvm::TypeBasedAAWrapperPass *llvm::TypeBasedAAWrapperPass::TypeBasedAAWrapperPass(llvm::TypeBasedAAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::TypeBasedAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2608270;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC86B8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC15CAB0;
    v5[1] = &PassRegistry;
    BOOL v4 = v5;
    std::__call_once(&qword_1EBCC86B8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::TypeBasedAAWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

llvm::MDNode *llvm::AAMDNodes::extendToTBAA(llvm::AAMDNodes *this, llvm::MDNode *a2)
{
  v19[4] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  Impl = this;
  if (!sub_1CB8F0DA8(*((unsigned char **)this - *((unsigned int *)this + 2)))) {
    return Impl;
  }
  uint64_t v4 = *((unsigned int *)Impl + 2);
  if (v4 < 3) {
    return Impl;
  }
  uint64_t v16 = Impl;
  if (!sub_1CC15D024((uint64_t)&v16)) {
    return Impl;
  }
  if (a2 == (llvm::MDNode *)-1) {
    return 0;
  }
  unint64_t v17 = v19;
  uint64_t v18 = 0x400000000;
  sub_1CB91FB58((uint64_t)&v17, (char *)Impl - 8 * v4, (char *)Impl);
  unint64_t v5 = v17;
  uint64_t v6 = *(void *)(*((void *)v17 + 3) + 128);
  uint64_t v7 = (llvm::MDNode *)(v6 + 24);
  unsigned int v8 = *(_DWORD *)(v6 + 32);
  if (v8 >= 0x41)
  {
    if (v8 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(v6 + 24)) > 0x40) {
      goto LABEL_8;
    }
    uint64_t v7 = *(llvm::MDNode **)v7;
  }
  if (*(llvm::MDNode **)v7 != a2)
  {
LABEL_8:
    uint64_t v9 = (llvm::ValueAsMetadata *)llvm::ConstantInt::get(*(llvm::ConstantInt **)v6, (unint64_t)a2, 0);
    uint64_t v11 = llvm::ValueAsMetadata::get(v9, v10);
    int v12 = v17;
    *((void *)v17 + 3) = v11;
    uint64_t v13 = *((void *)Impl + 2);
    unsigned int v14 = (void *)(v13 & 0xFFFFFFFFFFFFFFF8);
    if ((v13 & 4) != 0) {
      unsigned int v14 = (void *)*v14;
    }
    Impl = llvm::MDTuple::getImpl((uint64_t)v14, v12, v18, 0, 1);
    unint64_t v5 = v17;
  }
  if (v5 != v19) {
    free(v5);
  }
  return Impl;
}

void llvm::callDefaultCtor<llvm::TypeBasedAAWrapperPass>()
{
}

void sub_1CD4D27FC(char **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBD04AB8, 0, 0);
  byte_1EBD04B38 = 0;
  qword_1EBD04B40 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD04B48 = 0;
  qword_1EBD04AB8 = (uint64_t)&unk_1F26440A0;
  qword_1EBD04B50 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD04B58 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD04B70 = (uint64_t)&qword_1EBD04B58;
  llvm::cl::Option::setArgStr(v4, "enable-tbaa", 0xBuLL);
  unint64_t v5 = *a1;
  byte_1EBD04B38 = **a1;
  byte_1EBD04B49 = 1;
  byte_1EBD04B48 = *v5;
  word_1EBD04AC2 = (32 * (*a2 & 3)) | word_1EBD04AC2 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD04AB8);
}

llvm *llvm::getPointerAtOffset(llvm *this, unint64_t a2, unint64_t a3, llvm::Module *a4, llvm::Constant *a5)
{
  uint64_t v6 = this;
  uint64_t v7 = *(llvm::StructType **)this;
  if (*(unsigned char *)(*(void *)this + 8) == 15)
  {
LABEL_2:
    BOOL v8 = a2 == 0;
LABEL_3:
    if (v8) {
      return v6;
    }
    else {
      return 0;
    }
  }
  else
  {
    int v12 = (llvm::DataLayout *)(a3 + 272);
    while (1)
    {
      int v13 = *((unsigned __int8 *)v6 + 16);
      if (v13 == 8) {
        break;
      }
      if (v13 == 9)
      {
        StructLayout = llvm::DataLayout::getStructLayout(v12, v7);
        if (*(void *)StructLayout <= a2) {
          return 0;
        }
        uint64_t v19 = StructLayout;
        unsigned int ElementContainingOffset = llvm::StructLayout::getElementContainingOffset(StructLayout, a2);
        int v21 = *((_DWORD *)v6 + 5);
        if ((v21 & 0x40000000) != 0) {
          __n128 v33 = (char *)*((void *)v6 - 1);
        }
        else {
          __n128 v33 = (char *)v6 - 32 * (v21 & 0x7FFFFFF);
        }
        uint64_t v6 = *(llvm **)&v33[32 * ElementContainingOffset];
        a2 -= *((void *)v19 + ElementContainingOffset + 2);
      }
      else
      {
        if (!a2 && v13 == 16)
        {
          long long v32 = (void *)((char *)v6 + 24);
          if (*((_DWORD *)v6 + 8) >= 0x41u) {
            long long v32 = (void *)*v32;
          }
          BOOL v8 = *v32 == 0;
          goto LABEL_3;
        }
        if (v13 != 5) {
          return 0;
        }
        int v14 = *((unsigned __int16 *)v6 + 9);
        if (v14 == 38 || v14 == 47)
        {
          uint64_t v6 = (llvm *)*((void *)v6 - 4 * (*((_DWORD *)v6 + 5) & 0x7FFFFFF));
        }
        else
        {
          if (v14 != 15) {
            return 0;
          }
          uint64_t v15 = (llvm **)((char *)v6 - 32 * (*((_DWORD *)v6 + 5) & 0x7FFFFFF));
          uint64_t v6 = *v15;
          uint64_t PointerAtOffset = llvm::getPointerAtOffset(v15[4], 0, a3, 0, a5);
          BOOL v17 = PointerAtOffset && *(unsigned char *)(PointerAtOffset + 16) == 5;
          if (v17 && *(_WORD *)(PointerAtOffset + 18) == 34) {
            uint64_t PointerAtOffset = *(void *)(PointerAtOffset - 32 * (*(_DWORD *)(PointerAtOffset + 20) & 0x7FFFFFF));
          }
          if ((llvm::Module *)PointerAtOffset != a4) {
            return 0;
          }
        }
      }
      uint64_t v7 = *(llvm::StructType **)v6;
      if (*(unsigned char *)(*(void *)v6 + 8) == 15) {
        goto LABEL_2;
      }
    }
    long long v22 = (llvm::Type *)*((void *)v7 + 3);
    unint64_t v23 = (unint64_t)(sub_1CB83544C((uint64_t)v12, (uint64_t)v22) + 7) >> 3;
    BOOL v25 = v24 == 1;
    char Alignment = llvm::DataLayout::getAlignment(v12, v22, 1);
    v34[0] = ((1 << Alignment) + v23 - 1) & -(1 << Alignment);
    v34[1] = v25;
    unint64_t v29 = llvm::TypeSize::operator unsigned long long(v34, v27);
    double result = 0;
    int v30 = *((_DWORD *)v6 + 5);
    if ((v30 & 0x7FFFFFFu) > (a2 / v29))
    {
      if ((v30 & 0x40000000) != 0) {
        uint64_t v31 = (char *)*((void *)v6 - 1);
      }
      else {
        uint64_t v31 = (char *)v6 - 32 * (v30 & 0x7FFFFFF);
      }
      return (llvm *)llvm::getPointerAtOffset(*(llvm **)&v31[32 * (a2 / v29)], (llvm::Constant *)(a2 % v29), a3, a4, v28);
    }
  }
  return result;
}

void llvm::initializeScopedNoAliasAAWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC86C0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC15F6CC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCC86C0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createScopedNoAliasAAWrapperPass(llvm *this)
{
}

llvm::ScopedNoAliasAAWrapperPass *llvm::ScopedNoAliasAAWrapperPass::ScopedNoAliasAAWrapperPass(llvm::ScopedNoAliasAAWrapperPass *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::ScopedNoAliasAAWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F2608318;
  *((void *)this + 4) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC86C0, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC15F6CC;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCC86C0, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::ScopedNoAliasAAWrapperPass::getAnalysisUsage(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::callDefaultCtor<llvm::ScopedNoAliasAAWrapperPass>()
{
}

uint64_t sub_1CD4D2D28(uint64_t a1, char *a2, unsigned char **a3, _WORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(unsigned char *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = &unk_1F25EDE58;
  *(void *)(v8 + 144) = 0;
  *(void *)uint64_t v8 = &unk_1F26440A0;
  *(void *)(v8 + 152) = &unk_1F2643CC0;
  *(void *)(v8 + 160) = &unk_1F25EDE78;
  *(void *)(v8 + 184) = v8 + 160;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  uint64_t v10 = *a3;
  *(unsigned char *)(a1 + 128) = **a3;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v10;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

uint64_t llvm::isOnlyUsedInZeroEqualityComparison(llvm *this, const llvm::Instruction *a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (!v2) {
    return 0;
  }
  do
  {
    uint64_t v3 = *(void *)(v2 + 24);
    int v6 = 0;
    unint64_t v5 = &v6;
    LODWORD(result) = sub_1CD4D3B70(&v5, v3);
    if ((v6 & 0xFFFFFFFE) == 0x20) {
      uint64_t result = result;
    }
    else {
      uint64_t result = 0;
    }
    if (result != 1) {
      break;
    }
    uint64_t v2 = *(void *)(v2 + 8);
  }
  while (v2);
  return result;
}

unint64_t llvm::isKnownNonNegative(llvm *this, const llvm::Value *a2, const llvm::DataLayout *a3, const llvm::DataLayout *a4, llvm::AssumptionCache *a5, const llvm::Instruction *a6, const llvm::DominatorTree *a7)
{
  llvm::computeKnownBits(this, a2, a3, a5, a6, 0, a7, a4, (uint64_t)&v10, v10);
  if (v11 >= 0x41) {
    uint64_t v7 = (BOOL *)(v10 + 8 * ((v11 - 1) >> 6));
  }
  else {
    uint64_t v7 = &v10;
  }
  unint64_t v8 = (unint64_t)*v7 >> (v11 - 1);
  sub_1CB8F0DC4((uint64_t)&v10);
  return v8 & 1;
}

llvm::Value *llvm::FindInsertedValue(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a1;
  v25[5] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return (llvm::Value *)a1;
  }
  uint64_t v6 = a3;
  while (1)
  {
    while (1)
    {
      unsigned int v8 = *(unsigned __int8 *)(v4 + 16);
      if (!v4 || v8 > 0x14) {
        break;
      }
      Aggregateuint64_t Element = (llvm::Value *)llvm::Constant::getAggregateElement((llvm::Constant *)v4, (llvm::Type *)*a2);
      if (!AggregateElement) {
        return 0;
      }
      uint64_t v4 = (uint64_t)AggregateElement;
      ++a2;
      InsertedValue = AggregateElement;
      if (!--v6) {
        return InsertedValue;
      }
    }
    if (!v4 || v8 != 93) {
      break;
    }
    uint64_t v11 = *(unsigned int *)(v4 + 72);
    if (v11)
    {
      unint64_t v12 = 0;
      uint64_t v13 = 4 * v11;
      int v14 = &a2[v6];
      while (4 * v6 != v12)
      {
        if (a2[v12 / 4] != *(_DWORD *)(*(void *)(v4 + 64) + v12))
        {
          uint64_t v16 = (uint64_t *)(v4 - 64);
          goto LABEL_18;
        }
        v12 += 4;
        if (v13 == v12)
        {
          uint64_t v15 = &a2[v12 / 4];
          goto LABEL_17;
        }
      }
      if (a4)
      {
        Indexeduint64_t Type = (llvm::UndefValue *)llvm::ExtractValueInst::getIndexedType(*(void *)v4, a2, (4 * v6) >> 2);
        uint64_t v19 = llvm::UndefValue::get(IndexedType, v18);
        unint64_t v23 = v25;
        uint64_t v24 = 0xA00000000;
        sub_1CB925718((unsigned int *)&v23, a2, v14);
        InsertedValue = sub_1CC184644(v4, v19, (uint64_t)IndexedType, (uint64_t)&v23, v24, a4);
        int v20 = v23;
        if (v23 == v25) {
          return InsertedValue;
        }
        goto LABEL_23;
      }
      return 0;
    }
    uint64_t v15 = a2;
LABEL_17:
    uint64_t v16 = (uint64_t *)(v4 - 32);
    uint64_t v6 = &a2[v6] - v15;
    a2 = v15;
LABEL_18:
    uint64_t v4 = *v16;
    InsertedValue = (llvm::Value *)*v16;
    if (!v6) {
      return InsertedValue;
    }
  }
  InsertedValue = 0;
  if (v4 && v8 == 92)
  {
    unsigned int v22 = *(_DWORD *)(v4 + 72);
    unint64_t v23 = v25;
    uint64_t v24 = 0x500000000;
    if (v22 + v6 >= 6) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    sub_1CB925718((unsigned int *)&v23, *(unsigned char **)(v4 + 64), (unsigned char *)(*(void *)(v4 + 64) + 4 * v22));
    sub_1CB925718((unsigned int *)&v23, a2, &a2[v6]);
    InsertedValue = (llvm::Value *)llvm::FindInsertedValue(*(void *)(v4 - 32), v23, v24, a4);
    int v20 = v23;
    if (v23 != v25) {
LABEL_23:
    }
      free(v20);
  }
  return InsertedValue;
}

BOOL llvm::getConstantStringInfo(llvm *this, const llvm::Value *a2, llvm::StringRef *a3, int a4)
{
  BOOL result = llvm::getConstantDataArrayInfo(this, (uint64_t *)&v15, 8u, (unint64_t)a3);
  if (result)
  {
    if (v15)
    {
      uint64_t RawDataValues = llvm::ConstantDataSequential::getRawDataValues(v15);
      unint64_t v9 = v16;
      if (v8 >= v16) {
        unint64_t v10 = v16;
      }
      else {
        unint64_t v10 = v8;
      }
      unint64_t v11 = RawDataValues + v10;
      size_t v12 = v8 - v10;
      *(void *)a2 = RawDataValues + v10;
      *((void *)a2 + 1) = v8 - v10;
      if (a4)
      {
        if (v8 > v9 && (uint64_t v13 = memchr((void *)(RawDataValues + v10), 0, v12)) != 0) {
          unint64_t v14 = (unint64_t)v13 - v11;
        }
        else {
          unint64_t v14 = -1;
        }
        if (v12 < v14) {
          unint64_t v14 = v12;
        }
        *((void *)a2 + 1) = v14;
      }
      return 1;
    }
    if (a4)
    {
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
      return 1;
    }
    if (v17 == 1)
    {
      BOOL result = 1;
      *(void *)a2 = "";
      *((void *)a2 + 1) = 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::GetStringLength(llvm *this, const llvm::Value *a2)
{
  if (*(unsigned char *)(*(void *)this + 8) != 15) {
    return 0;
  }
  unint64_t v5 = v9;
  uint64_t v6 = v9;
  uint64_t v7 = 32;
  int v8 = 0;
  uint64_t v2 = sub_1CC166508(this, (uint64_t)&v5, (uint64_t)a2);
  if (v2 == -1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = v2;
  }
  if (v6 != v5) {
    free(v6);
  }
  return v3;
}

uint64_t llvm::computeOverflowForSignedAdd(uint64_t a1, const llvm::DataLayout *a2, uint64_t a3, const llvm::DataLayout *a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a1 + 20);
  if ((v5 & 0x40000000) != 0) {
    uint64_t v6 = *(uint64_t **)(a1 - 8);
  }
  else {
    uint64_t v6 = (uint64_t *)(a1 - 32 * (v5 & 0x7FFFFFF));
  }
  return sub_1CC16A7F0(*v6, v6[4], (unsigned char *)a1, a2, a3, a4, a5);
}

uint64_t llvm::isGuaranteedToTransferExecutionToSuccessor(llvm *this, const llvm::BasicBlock *a2)
{
  uint64_t v2 = (char *)this + 40;
  uint64_t v3 = (void *)*((void *)this + 6);
  if (v3 == (void *)((char *)this + 40)) {
    return 1;
  }
  do
  {
    if (v3) {
      uint64_t v4 = (llvm *)(v3 - 3);
    }
    else {
      uint64_t v4 = 0;
    }
    uint64_t result = llvm::isGuaranteedToTransferExecutionToSuccessor(v4, a2);
    if ((result & 1) == 0) {
      break;
    }
    uint64_t v3 = (void *)v3[1];
  }
  while (v3 != (void *)v2);
  return result;
}

uint64_t llvm::isGuaranteedToExecuteForEveryIteration(llvm *this, const llvm::Instruction *a2, const llvm::Loop *a3)
{
  uint64_t v3 = *((void *)this + 5);
  if (v3 == **((void **)a2 + 4))
  {
    uint64_t v5 = v3 + 40;
    uint64_t v6 = *(void *)(v3 + 48);
    if (v6 != v3 + 40)
    {
      while (1)
      {
        int v8 = v6 ? (llvm *)(v6 - 24) : 0;
        if (v8 == this) {
          break;
        }
        if ((llvm::isGuaranteedToTransferExecutionToSuccessor(v8, a2) & 1) == 0) {
          goto LABEL_2;
        }
        uint64_t v6 = *(void *)(v6 + 8);
        if (v6 == v5) {
          return v3 & 1;
        }
      }
      LOBYTE(v3) = 1;
    }
  }
  else
  {
LABEL_2:
    LOBYTE(v3) = 0;
  }
  return v3 & 1;
}

uint64_t llvm::canConvertToMinOrMaxIntrinsic(uint64_t *a1, uint64_t a2)
{
  unsigned int v3 = 0;
  uint64_t v4 = 8 * a2;
  LOBYTE(v5) = 1;
  do
  {
    uint64_t v6 = *a1;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unsigned int matched = llvm::matchSelectPattern(v6, (uint64_t)&v16, &v15, 0, 0);
    BOOL v8 = matched > 8 || ((1 << matched) & 0x181) == 0;
    if (!v8
      || matched - 7 > 0xFFFFFFFD
      || ((*(_DWORD *)(*(void *)v6 + 8) & 0xFE) != 0x12
        ? (int v9 = *(_DWORD *)(*(void *)v6 + 8))
        : (int v9 = *(unsigned __int8 *)(**(void **)(*(void *)v6 + 16) + 8)),
          v9 != 13 || v3 && v3 != matched))
    {
      uint64_t v14 = 0;
      uint64_t v5 = 0;
      return v14 | (v5 << 32);
    }
    if (*(unsigned char *)(v6 + 16) == 85)
    {
      int v10 = *(_DWORD *)(v6 + 20);
      if ((v10 & 0x40000000) != 0) {
        uint64_t v11 = *(void *)(v6 - 8);
      }
      else {
        uint64_t v11 = v6 - 32 * (v10 & 0x7FFFFFF);
      }
      uint64_t v12 = *(void *)(*(void *)v11 + 8);
      if (v12) {
        LODWORD(v12) = *(void *)(v12 + 8) == 0;
      }
    }
    else
    {
      LODWORD(v12) = 0;
    }
    if ((_BYTE)v5) {
      uint64_t v5 = v12;
    }
    else {
      uint64_t v5 = 0;
    }
    ++a1;
    unsigned int v3 = matched;
    v4 -= 8;
  }
  while (v4);
  uint64_t v14 = 275;
  switch(matched)
  {
    case 2u:
      uint64_t v14 = 306;
      break;
    case 3u:
      uint64_t v14 = 274;
      break;
    case 4u:
      uint64_t v14 = 305;
      break;
    default:
      return v14 | (v5 << 32);
  }
  return v14 | (v5 << 32);
}

unint64_t llvm::isPointerOffset(llvm *this, const llvm::Value *a2, const llvm::Value *a3, const llvm::DataLayout *a4)
{
  Indexunsigned int TypeSizeInBits = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)a3, *(void *)this);
  sub_1CB8F1EEC((uint64_t)&v43, IndexTypeSizeInBits, 0);
  unsigned int v8 = llvm::DataLayout::getIndexTypeSizeInBits((uint64_t)a3, *(void *)a2);
  sub_1CB8F1EEC((uint64_t)&v41, v8, 0);
  int v10 = llvm::Value::stripAndAccumulateConstantOffsets(this, a3, (llvm::APInt *)&v43, 1, 0, 0, v9);
  uint64_t v12 = llvm::Value::stripAndAccumulateConstantOffsets(a2, a3, (llvm::APInt *)&v41, 1, 0, 0, v11);
  if (v10 == v12)
  {
    if (v42 > 0x40) {
      uint64_t v15 = *v41;
    }
    else {
      uint64_t v15 = (uint64_t)((void)v41 << -(uint64_t)v42) >> -(uint64_t)v42;
    }
    if (v44 > 0x40) {
      uint64_t v21 = *v43;
    }
    else {
      uint64_t v21 = (uint64_t)((void)v43 << -(uint64_t)v44) >> -(uint64_t)v44;
    }
LABEL_22:
    unsigned __int8 v17 = v15 - v21;
    unint64_t v18 = (v15 - v21) & 0xFFFFFFFFFFFFFF00;
    goto LABEL_29;
  }
  uint64_t v13 = (uint64_t)v12;
  int v14 = *((unsigned __int8 *)v10 + 16);
  if (v14 != 62)
  {
    if (v14 == 5)
    {
      if (*((_WORD *)v10 + 9) != 34) {
        int v10 = 0;
      }
    }
    else
    {
      int v10 = 0;
    }
  }
  int v16 = *((unsigned __int8 *)v12 + 16);
  if (v16 != 62)
  {
    if (v16 != 5) {
      goto LABEL_28;
    }
    if (*((_WORD *)v12 + 9) != 34) {
      uint64_t v13 = 0;
    }
  }
  unsigned __int8 v17 = 0;
  if (!v10) {
    goto LABEL_48;
  }
  unint64_t v18 = 0;
  if (v13)
  {
    int v19 = *((_DWORD *)v10 + 5);
    if ((v19 & 0x40000000) != 0) {
      int v20 = (uint64_t *)*((void *)v10 - 1);
    }
    else {
      int v20 = (uint64_t *)((char *)v10 - 32 * (v19 & 0x7FFFFFF));
    }
    uint64_t v22 = *v20;
    int v23 = *(_DWORD *)(v13 + 20);
    if ((v23 & 0x40000000) != 0) {
      uint64_t v24 = *(void **)(v13 - 8);
    }
    else {
      uint64_t v24 = (void *)(v13 - 32 * (v23 & 0x7FFFFFF));
    }
    if (v22 == *v24)
    {
      uint64_t v26 = 24;
      if (*((unsigned char *)v10 + 16) == 62) {
        uint64_t v27 = 64;
      }
      else {
        uint64_t v27 = 24;
      }
      uint64_t v28 = *(void *)((char *)v10 + v27);
      if (*(unsigned char *)(v13 + 16) == 62) {
        uint64_t v26 = 64;
      }
      if (v28 == *(void *)(v13 + v26))
      {
        uint64_t v29 = v19 & 0x7FFFFFF;
        if (v29 == 1)
        {
          LODWORD(v30) = 1;
        }
        else
        {
          uint64_t v30 = v23 & 0x7FFFFFF;
          unsigned int v37 = 1;
          while (v30 != v37)
          {
            BOOL v38 = (char *)v10 - 32 * v29;
            if ((v19 & 0x40000000) != 0) {
              BOOL v38 = (char *)*((void *)v10 - 1);
            }
            uint64_t v39 = v13 - 32 * v30;
            if ((v23 & 0x40000000) != 0) {
              uint64_t v39 = *(void *)(v13 - 8);
            }
            if (*(void *)&v38[32 * v37] != *(void *)(v39 + 32 * v37))
            {
              LODWORD(v30) = v37;
              break;
            }
            if (v29 == ++v37)
            {
              LODWORD(v30) = v19 & 0x7FFFFFF;
              break;
            }
          }
        }
        uint64_t v31 = sub_1CC173AC0((uint64_t)v10, v30, a3);
        char v33 = v32;
        uint64_t v34 = sub_1CC173AC0(v13, v30, a3);
        unsigned __int8 v17 = 0;
        if (v33)
        {
          unint64_t v18 = 0;
          if (!v35) {
            goto LABEL_29;
          }
          if (v42 > 0x40) {
            uint64_t v36 = *v41;
          }
          else {
            uint64_t v36 = (uint64_t)((void)v41 << -(uint64_t)v42) >> -(uint64_t)v42;
          }
          if (v44 > 0x40) {
            uint64_t v40 = *v43;
          }
          else {
            uint64_t v40 = (uint64_t)((void)v43 << -(uint64_t)v44) >> -(uint64_t)v44;
          }
          uint64_t v15 = v34 + v36;
          uint64_t v21 = v31 + v40;
          goto LABEL_22;
        }
LABEL_48:
        unint64_t v18 = 0;
        goto LABEL_29;
      }
    }
LABEL_28:
    unsigned __int8 v17 = 0;
    unint64_t v18 = 0;
  }
LABEL_29:
  if (v42 >= 0x41 && v41) {
    MEMORY[0x1D25D9CB0](v41, 0x1000C8000313F17);
  }
  if (v44 >= 0x41 && v43) {
    MEMORY[0x1D25D9CB0](v43, 0x1000C8000313F17);
  }
  return v18 | v17;
}

void sub_1CD4D3A54(_WORD *a1, int **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCC86C8, 0, 0);
  dword_1EBCC8748 = 0;
  qword_1EBCC8750 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC8758 = 0;
  qword_1EBCC86C8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC8760 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC8768 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC8780 = (uint64_t)&qword_1EBCC8768;
  llvm::cl::Option::setArgStr(v4, "dom-conditions-max-uses", 0x17uLL);
  word_1EBCC86D2 = (32 * (*a1 & 3)) | word_1EBCC86D2 & 0xFF9F;
  dword_1EBCC8748 = **a2;
  byte_1EBCC875C = 1;
  dword_1EBCC8758 = dword_1EBCC8748;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC86C8);
}

uint64_t sub_1CD4D3B70(int **a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a2 && *(unsigned char *)(a2 + 16) == 81)
  {
    uint64_t v5 = *(unsigned __int8 **)(a2 - 32);
    if (v5) {
      BOOL v6 = v5[16] > 0x14u;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6
      && (char isNullValue = llvm::Constant::isNullValue(*(llvm::Constant **)(a2 - 32)),
          (isNullValue & 1) != 0 || (sub_1CC03F414((uint64_t)&v8, (llvm::Constant *)v5) & 1) != 0))
    {
      **a1 = *(_WORD *)(a2 + 18) & 0x3F;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::isTriviallyVectorizable(llvm *this)
{
  int v1 = (int)this;
  uint64_t result = 1;
  if (v1 > 138)
  {
    if (((v1 - 139) > 0x36 || ((1 << (v1 + 117)) & 0x6000700000061BLL) == 0)
      && ((v1 - 201) > 0x3D || ((1 << (v1 + 55)) & 0x2E00006000000007) == 0))
    {
      unsigned int v3 = v1 - 273;
      if (v3 > 0x26 || ((1 << v3) & 0x4F0880049FLL) == 0) {
        return 0;
      }
    }
  }
  else if ((v1 > 0x36 || ((1 << v1) & 0x78000000086302) == 0) && (v1 - 75) >= 2)
  {
    return 0;
  }
  return result;
}

BOOL llvm::hasVectorInstrinsicOverloadedScalarOpd(llvm *this, int a2)
{
  return this == 239 && a2 == 1;
}

uint64_t llvm::widenShuffleMaskElts(int a1, int *__s2, unint64_t a3, unsigned int *a4)
{
  unint64_t v5 = a3;
  BOOL v6 = __s2;
  if (a1 == 1)
  {
    a4[2] = 0;
    sub_1CC1899BC(a4, __s2, &__s2[a3]);
    return 1;
  }
  if ((int)a3 % a1) {
    return 0;
  }
  a4[2] = 0;
  if (a4[3] < (unint64_t)((int)a3 / a1)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  while (1)
  {
    unint64_t v9 = v5 >= a1 ? a1 : v5;
    int v10 = *v6;
    if ((*v6 & 0x80000000) == 0) {
      break;
    }
    if (v9 != 1 && (!v9 || memcmp(v6 + 1, v6, 4 * v9 - 4))) {
      return 0;
    }
    unint64_t v12 = a4[2];
    if (v12 >= a4[3]) {
LABEL_24:
    }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
LABEL_22:
    *(_DWORD *)(*(void *)a4 + 4 * v12) = v10;
    ++a4[2];
    v6 += a1;
    uint64_t result = 1;
    v5 -= a1;
    if (!v5) {
      return result;
    }
  }
  if (v10 % a1) {
    return 0;
  }
  if (a1 < 2)
  {
LABEL_16:
    unint64_t v12 = a4[2];
    v10 /= a1;
    if (v12 >= a4[3]) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  uint64_t v11 = 1;
  while (v10 + v11 == v6[v11])
  {
    if (a1 == ++v11) {
      goto LABEL_16;
    }
  }
  return 0;
}

void llvm::processShuffleMasks(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, void (*a6)(uint64_t), uint64_t a7, uint64_t a8, unint64_t a9, unsigned char *a10, unint64_t a11, uint64_t a12)
{
  uint64_t v75 = a6;
  uint64_t v76 = a7;
  unsigned int v70 = a5;
  v84[10] = *MEMORY[0x1E4F143B8];
  unsigned int v74 = a4;
  uint64_t v15 = a4;
  v79 = v81;
  uint64_t v80 = 0x100000000;
  uint64_t v71 = v84;
  long long v82 = v84;
  uint64_t v83 = 0x100000000;
  sub_1CD4D6920((char **)&v82, a4, (uint64_t)&v79);
  int v16 = (char *)v79;
  if (v80)
  {
    unint64_t v17 = (unint64_t)v80 << 6;
    do
    {
      unint64_t v18 = *(char **)&v16[v17 - 64];
      if (&v16[v17 - 48] != v18) {
        free(v18);
      }
      v17 -= 64;
    }
    while (v17);
    int v16 = (char *)v79;
  }
  if (v16 != v81) {
    free(v16);
  }
  if (v74)
  {
    uint64_t v19 = 0;
    uint64_t v72 = v81;
    unint64_t v73 = a3;
    unint64_t v78 = a2 / v74;
    if (a2 / v74 <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = a2 / v74;
    }
    unsigned int v21 = a2 / a3;
    do
    {
      uint64_t v22 = (uint64_t *)((char *)v82 + 80 * v19);
      int v23 = v72;
      v79 = v72;
      uint64_t v80 = 0xC00000000;
      sub_1CD4D4370((uint64_t)v22, v73, (uint64_t)&v79);
      if (v79 != v23) {
        free(v79);
      }
      if (a2 >= v74)
      {
        uint64_t v24 = 0;
        int v25 = v78 * v19;
        unint64_t v77 = (unint64_t)v22;
        do
        {
          int v26 = v24 + v25;
          if (v24 + v25 == a2) {
            break;
          }
          int v27 = *(_DWORD *)(a1 + 4 * v26);
          if (v27 < (int)a2 && v27 != -1)
          {
            uint64_t v29 = (int)(v27 / v21);
            uint64_t v30 = *v22;
            uint64_t v31 = *v22 + (v29 << 6);
            if (!*(_DWORD *)(v31 + 8))
            {
              uint64_t v32 = v20;
              uint64_t v33 = v19;
              uint64_t v34 = v26;
              sub_1CBF8EBE4(v31, v78, -1);
              int v27 = *(_DWORD *)(a1 + 4 * v34);
              uint64_t v19 = v33;
              uint64_t v20 = v32;
              uint64_t v22 = (uint64_t *)v77;
              uint64_t v30 = *(void *)v77;
            }
            *(_DWORD *)(*(void *)(v30 + (v29 << 6)) + 4 * v24) = v27 % v21;
          }
          ++v24;
        }
        while (v20 != v24);
      }
      ++v19;
    }
    while (v19 != v15);
  }
  if (v70)
  {
    char v35 = 0;
    unint64_t v73 = a9;
    uint64_t v72 = a10;
    unint64_t v77 = v70;
    unint64_t v78 = a11;
    do
    {
      uint64_t v36 = (char *)v82 + 80 * (void)v35;
      uint64_t v37 = *((unsigned int *)v36 + 2);
      if (!v37) {
        goto LABEL_42;
      }
      int v38 = 0;
      uint64_t v39 = *(void *)v36;
      uint64_t v40 = *(void *)v36 + (v37 << 6);
      uint64_t v41 = v37 << 6;
      unsigned int v42 = (int *)(*(void *)v36 + 8);
      uint64_t v43 = v41;
      do
      {
        int v44 = *v42;
        v42 += 16;
        if (v44) {
          ++v38;
        }
        v43 -= 64;
      }
      while (v43);
      if (v38)
      {
        if (v38 == 1)
        {
          while (1)
          {
            uint64_t v45 = *(unsigned int *)(v39 + 8);
            if (v45) {
              break;
            }
            v39 += 64;
            v41 -= 64;
            if (!v41)
            {
              uint64_t v45 = *(unsigned int *)(v40 + 8);
              goto LABEL_78;
            }
          }
          uint64_t v40 = v39;
LABEL_78:
          ((void (*)(unsigned char *, void, uint64_t, unint64_t))v73)(v72, *(void *)v40, v45, (unint64_t)(v40 - *(void *)v36) >> 6);
          goto LABEL_43;
        }
        if (v74)
        {
          uint64_t v46 = 0;
          uint64_t v47 = 0;
          long long v48 = 0;
          int v49 = 0;
          uint64_t v50 = 0;
          uint64_t v51 = 0xFFFFFFFFLL;
          uint64_t v52 = 0xFFFFFFFFLL;
          while (1)
          {
            uint64_t v53 = *(void *)v36 + (v46 << 6);
            if (*(_DWORD *)(v53 + 8))
            {
              uint64_t v54 = *(int **)v53;
              if (v52 != v51)
              {
                if ((int)v47 <= 0)
                {
                  ((void (*)(uint64_t, int *, uint64_t, uint64_t, uint64_t))v78)(a12, v48, v47, v52, v46);
                }
                else
                {
                  uint64_t v62 = v48;
                  uint64_t v63 = v47;
                  do
                  {
                    int v65 = *v54++;
                    int v64 = v65;
                    if (v65 != -1) {
                      *uint64_t v62 = v64 + v47;
                    }
                    ++v62;
                    --v63;
                  }
                  while (v63);
                  ((void (*)(uint64_t, int *, uint64_t, uint64_t, uint64_t))v78)(a12, v48, v47, v52, v46);
                  uint64_t v66 = 0;
                  do
                  {
                    if (v48[v66] != -1) {
                      v48[v66] = v66;
                    }
                    ++v66;
                  }
                  while (v47 != v66);
                }
                *(_DWORD *)(v53 + 8) = 0;
                uint64_t v50 = v48;
                int v49 = v47;
                uint64_t v55 = v52;
                goto LABEL_51;
              }
              long long v48 = *(int **)v53;
              uint64_t v47 = *(unsigned int *)(v53 + 8);
              uint64_t v52 = v46;
            }
            uint64_t v55 = v51;
LABEL_51:
            ++v46;
            uint64_t v51 = v55;
            if (v46 == v15)
            {
              if (v52 != v55 && (v55 & 0x80000000) == 0)
              {
                if (v49 < 1)
                {
                  ((void (*)(uint64_t, int *))v78)(a12, v50);
                  *(_DWORD *)(*(void *)v36 + ((uint64_t)(int)v52 << 6) + 8) = 0;
                }
                else
                {
                  uint64_t v56 = v49;
                  long long v57 = v50;
                  uint64_t v58 = v49;
                  do
                  {
                    int v60 = *v48++;
                    int v59 = v60;
                    if (v60 != -1) {
                      *long long v57 = v59 + v49;
                    }
                    ++v57;
                    --v58;
                  }
                  while (v58);
                  ((void (*)(uint64_t, int *))v78)(a12, v50);
                  uint64_t v61 = 0;
                  *(_DWORD *)(*(void *)v36 + ((uint64_t)(int)v52 << 6) + 8) = 0;
                  do
                  {
                    if (v50[v61] != -1) {
                      v50[v61] = v61;
                    }
                    ++v61;
                  }
                  while (v56 != v61);
                }
              }
              uint64_t v46 = 0;
              uint64_t v47 = 0;
              long long v48 = 0;
              int v49 = 0;
              uint64_t v50 = 0;
              uint64_t v51 = 0xFFFFFFFFLL;
              uint64_t v52 = 0xFFFFFFFFLL;
              if ((v55 & 0x80000000) != 0) {
                break;
              }
            }
          }
        }
      }
      else
      {
LABEL_42:
        v75(v76);
      }
LABEL_43:
      char v35 = (void *)((char *)v35 + 1);
    }
    while (v35 != (void *)v77);
  }
  unsigned int v67 = v82;
  if (v83)
  {
    uint64_t v68 = 80 * v83;
    uint64_t v69 = (char *)v82 - 80;
    do
    {
      sub_1CD4D68AC((char **)&v69[v68]);
      v68 -= 80;
    }
    while (v68);
    unsigned int v67 = v82;
  }
  if (v67 != v71) {
    free(v67);
  }
}

void sub_1CD4D4370(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    sub_1CD4D6DF4();
  }
  unint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = *(unsigned int *)(a1 + 8);
  }
  if (v7)
  {
    uint64_t v8 = *(void *)a1;
    do
    {
      sub_1CD41B6B0(v8, a3);
      v8 += 64;
      --v7;
    }
    while (v7);
    unint64_t v6 = *(unsigned int *)(a1 + 8);
  }
  unint64_t v9 = v6 - a2;
  if (v6 >= a2)
  {
    if (v6 > a2)
    {
      unint64_t v12 = (void **)(*(void *)a1 + (v6 << 6) - 64);
      unint64_t v13 = (a2 << 6) - (v6 << 6);
      do
      {
        if (v12 + 2 != *v12) {
          free(*v12);
        }
        v12 -= 8;
        v13 += 64;
      }
      while (v13);
    }
  }
  else
  {
    int v10 = (void *)(*(void *)a1 + (v6 << 6));
    do
    {
      void *v10 = v10 + 2;
      v10[1] = 0xC00000000;
      if (*(_DWORD *)(a3 + 8)) {
        sub_1CD41B6B0((uint64_t)v10, a3);
      }
      v10 += 8;
    }
    while (!__CFADD__(v9++, 1));
  }
  *(_DWORD *)(a1 + 8) = a2;
}

uint64_t sub_1CD4D44B0(uint64_t **a1, uint64_t *a2)
{
  unsigned int v3 = sub_1CD4D6F30(a1, (unint64_t)a2, a2);
  if (a1 + 1 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = sub_1CD4D6EE8((uint64_t)(v3 + 4));
  }
  return v4 + 16;
}

uint64_t sub_1CD4D44F8(uint64_t **a1, uint64_t *a2, unint64_t *a3)
{
  unint64_t v5 = sub_1CD4D6F30(a1, (unint64_t)a2, a2);
  unint64_t v6 = sub_1CD4D6F30(a1, *a3, (uint64_t *)*a3);
  unint64_t v7 = a1 + 1;
  if (v7 == v5) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = sub_1CD4D6EE8((uint64_t)(v5 + 4));
  }
  if (v7 == v6) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = sub_1CD4D6EE8((uint64_t)(v6 + 4));
  }
  if (v8 != result)
  {
    *(void *)(*(void *)v8 + 8) = *(void *)(*(void *)v8 + 8) & 1 | result;
    uint64_t v10 = *(void *)(result + 8);
    *(void *)uint64_t v8 = *(void *)result;
    *(void *)uint64_t result = v8;
    *(void *)(result + 8) = v10 & 0xFFFFFFFFFFFFFFFELL;
  }
  return result;
}

llvm *llvm::uniteAccessGroups(llvm *this, llvm::MDNode *a2, llvm::MDNode *a3)
{
  Impl = a2;
  v13[4] = *MEMORY[0x1E4F143B8];
  if (this)
  {
    if (!a2 || this == a2)
    {
      return this;
    }
    else
    {
      uint64_t v8 = 1;
      int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      int64x2_t v10 = v9;
      uint64_t v11 = v13;
      uint64_t v12 = 0x400000000;
      sub_1CC187D0C((uint64_t)&v8, (uint64_t)this);
      sub_1CC187D0C((uint64_t)&v8, (uint64_t)Impl);
      if (v12)
      {
        if (v12 == 1)
        {
          Impl = *(llvm::MDNode **)v11;
        }
        else
        {
          uint64_t v6 = *((void *)this + 2);
          unint64_t v7 = (void *)(v6 & 0xFFFFFFFFFFFFFFF8);
          if ((v6 & 4) != 0) {
            unint64_t v7 = (void *)*v7;
          }
          Impl = llvm::MDTuple::getImpl((uint64_t)v7, v11, v12, 0, 1);
        }
      }
      else
      {
        Impl = 0;
      }
      if (v11 != v13) {
        free(v11);
      }
      if ((v8 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v9.i64[0], 8);
      }
    }
  }
  return Impl;
}

llvm::MDNode *llvm::intersectAccessGroups(llvm *this, const llvm::Instruction *a2, const llvm::Instruction *a3)
{
  v30[4] = *MEMORY[0x1E4F143B8];
  if (llvm::Instruction::mayReadFromMemory(this))
  {
    if (llvm::Instruction::mayReadFromMemory(a2))
    {
LABEL_3:
      if (*((void *)this + 6) || (*((unsigned char *)this + 23) & 0x20) != 0) {
        uint64_t MetadataImpl = llvm::Instruction::getMetadataImpl(this, 25);
      }
      else {
        uint64_t MetadataImpl = 0;
      }
      if (*((void *)a2 + 6) || (*((unsigned char *)a2 + 23) & 0x20) != 0)
      {
        uint64_t v6 = llvm::Instruction::getMetadataImpl(a2, 25);
        Impl = 0;
        if (MetadataImpl)
        {
          uint64_t v8 = v6;
          if (v6)
          {
            if (MetadataImpl == v6)
            {
              return (llvm::MDNode *)MetadataImpl;
            }
            else
            {
              int v23 = v27;
              uint64_t v24 = v27;
              uint64_t v25 = 4;
              int v26 = 0;
              uint64_t v9 = *(unsigned int *)(v6 + 8);
              if (v9)
              {
                uint64_t v10 = -8 * v9;
                do
                {
                  sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v23, *(void *)(v8 + v10));
                  v10 += 8;
                }
                while (v10);
              }
              else
              {
                sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v23, v6);
              }
              uint64_t v28 = v30;
              uint64_t v29 = 0x400000000;
              uint64_t v15 = *(unsigned int *)(MetadataImpl + 8);
              if (v15)
              {
                uint64_t v16 = -8 * v15;
                do
                {
                  uint64_t v17 = *(void *)(MetadataImpl + v16);
                  unint64_t v18 = (char *)sub_1CB896AE8((uint64_t)&v23, v17);
                  if (v24 == v23) {
                    uint64_t v19 = (uint64_t *)((char *)&v25 + 4);
                  }
                  else {
                    uint64_t v19 = &v25;
                  }
                  if (v18 != &v24[8 * *(unsigned int *)v19])
                  {
                    if (v29 >= (unint64_t)HIDWORD(v29)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v28 + v29) = v17;
                    LODWORD(v29) = v29 + 1;
                  }
                  v16 += 8;
                }
                while (v16);
                unsigned int v20 = v29;
              }
              else
              {
                unsigned int v21 = (char *)sub_1CB896AE8((uint64_t)&v23, MetadataImpl);
                if (v24 == v23) {
                  uint64_t v22 = (uint64_t *)((char *)&v25 + 4);
                }
                else {
                  uint64_t v22 = &v25;
                }
                unsigned int v20 = v29;
                if (v21 != &v24[8 * *(unsigned int *)v22])
                {
                  if (v29 >= HIDWORD(v29)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v28 + v29) = MetadataImpl;
                  unsigned int v20 = v29 + 1;
                  LODWORD(v29) = v29 + 1;
                }
              }
              if (v20)
              {
                if (v20 == 1) {
                  Impl = *(llvm::MDNode **)v28;
                }
                else {
                  Impl = llvm::MDTuple::getImpl(**(void **)this, v28, v20, 0, 1);
                }
              }
              else
              {
                Impl = 0;
              }
              if (v28 != v30) {
                free(v28);
              }
              if (v24 != v23) {
                free(v24);
              }
            }
          }
        }
        return Impl;
      }
      return 0;
    }
    LOBYTE(v14) = llvm::Instruction::mayWriteToMemory(a2);
    goto LABEL_21;
  }
  int v11 = llvm::Instruction::mayWriteToMemory(this);
  if (llvm::Instruction::mayReadFromMemory(a2))
  {
    if (v11) {
      goto LABEL_3;
    }
    goto LABEL_15;
  }
  int v14 = llvm::Instruction::mayWriteToMemory(a2);
  if ((v11 | v14) != 1) {
    return 0;
  }
  if ((v11 & 1) == 0)
  {
LABEL_15:
    if (!*((void *)a2 + 6) && (*((unsigned char *)a2 + 23) & 0x20) == 0) {
      return 0;
    }
    uint64_t v12 = a2;
    goto LABEL_17;
  }
LABEL_21:
  if (v14) {
    goto LABEL_3;
  }
  if (!*((void *)this + 6) && (*((unsigned char *)this + 23) & 0x20) == 0) {
    return 0;
  }
  uint64_t v12 = this;
LABEL_17:

  return (llvm::MDNode *)llvm::Instruction::getMetadataImpl(v12, 25);
}

llvm::Value *llvm::createBitMaskForGaps(uint64_t a1, int a2, unsigned int *a3)
{
  v21[16] = *MEMORY[0x1E4F143B8];
  unsigned int v3 = *a3;
  if (a3[4] == *a3) {
    return 0;
  }
  uint64_t v19 = v21;
  uint64_t v20 = 0x1000000000;
  if (a2)
  {
    unsigned int v9 = 0;
    int v10 = 0;
    int v11 = (uint64_t *)(a3 + 2);
    do
    {
      if (v3)
      {
        unsigned int v12 = 0;
        do
        {
          unsigned int v18 = v12 + a3[8];
          unint64_t v13 = sub_1CD4D6838(v11, &v18) != 0;
          Int1Ty = (llvm::ConstantInt *)llvm::Type::getInt1Ty(*(llvm::Type **)(a1 + 64), v14);
          uint64_t v16 = llvm::ConstantInt::get(Int1Ty, v13, 0);
          if (v20 >= (unint64_t)HIDWORD(v20)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v19 + v20) = v16;
          unsigned int v9 = v20 + 1;
          LODWORD(v20) = v20 + 1;
          ++v12;
          unsigned int v3 = *a3;
        }
        while (v12 < *a3);
      }
      ++v10;
    }
    while (v10 != a2);
    uint64_t v17 = (llvm::FixedVectorType ***)v19;
  }
  else
  {
    unsigned int v9 = 0;
    uint64_t v17 = (llvm::FixedVectorType ***)v21;
  }
  uint64_t v4 = llvm::ConstantVector::get(v17, (llvm::Type *)v9);
  if (v19 != v21) {
    free(v19);
  }
  return v4;
}

uint64_t llvm::createReplicatedMask@<X0>(uint64_t this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x1000000000;
  if (a2)
  {
    unsigned int v4 = 0;
    for (int i = 0; i != a2; ++i)
    {
      for (int j = this; j; --j)
      {
        if (v4 >= *(_DWORD *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)a3 + 4 * v4) = i;
        unsigned int v4 = *(_DWORD *)(a3 + 8) + 1;
        *(_DWORD *)(a3 + 8) = v4;
      }
    }
  }
  return this;
}

uint64_t llvm::createInterleaveMask@<X0>(uint64_t this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x1000000000;
  if (this)
  {
    unsigned int v4 = 0;
    int v5 = 0;
    do
    {
      int v6 = v5;
      for (int i = a2; i; --i)
      {
        if (v4 >= *(_DWORD *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)a3 + 4 * v4) = v6;
        unsigned int v4 = *(_DWORD *)(a3 + 8) + 1;
        *(_DWORD *)(a3 + 8) = v4;
        v6 += this;
      }
      ++v5;
    }
    while (v5 != this);
  }
  return this;
}

uint64_t llvm::createStrideMask@<X0>(uint64_t this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)a4 = a4 + 16;
  *(void *)(a4 + 8) = 0x1000000000;
  if (a3)
  {
    int v5 = a3;
    int v6 = this;
    unsigned int v7 = 0;
    do
    {
      if (v7 >= *(_DWORD *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a4 + 4 * v7) = v6;
      unsigned int v7 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v7;
      v6 += a2;
      --v5;
    }
    while (v5);
  }
  return this;
}

uint64_t llvm::createSequentialMask@<X0>(uint64_t this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  int v4 = a3;
  *(void *)a4 = a4 + 16;
  *(void *)(a4 + 8) = 0x1000000000;
  if (a2)
  {
    int v6 = a2;
    int v7 = this;
    unsigned int v8 = 0;
    do
    {
      if (v8 >= *(_DWORD *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a4 + 4 * v8) = v7;
      unsigned int v8 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
  else
  {
    unsigned int v8 = 0;
  }
  if (a3)
  {
    do
    {
      if (v8 >= *(_DWORD *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a4 + 4 * v8) = -1;
      unsigned int v8 = *(_DWORD *)(a4 + 8) + 1;
      *(_DWORD *)(a4 + 8) = v8;
      --v4;
    }
    while (v4);
  }
  return this;
}

uint64_t llvm::concatenateVectors(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  v32[8] = *MEMORY[0x1E4F143B8];
  int v27 = v29;
  uint64_t v28 = 0x800000000;
  sub_1CC188254((unsigned int *)&v27, a2, &a2[8 * a3]);
  do
  {
    uint64_t v24 = v26;
    uint64_t v25 = 0x800000000;
    unsigned int v4 = v3 - 1;
    if (v3 == 1)
    {
      unsigned int v17 = 0;
      uint64_t v18 = *((void *)v27 + v4);
LABEL_19:
      *((void *)v24 + v17) = v18;
      LODWORD(v25) = v25 + 1;
      goto LABEL_20;
    }
    unsigned int v5 = 0;
    do
    {
      uint64_t v6 = *((void *)v27 + v5);
      int v7 = (llvm::PoisonValue **)*((void *)v27 + v5 + 1);
      uint64_t v8 = *(void *)v6;
      if ((*(_DWORD *)(*(void *)v6 + 8) & 0xFE) != 0x12) {
        uint64_t v8 = 0;
      }
      unsigned int v9 = *v7;
      if ((*((_DWORD *)*v7 + 2) & 0xFE) != 0x12) {
        unsigned int v9 = 0;
      }
      unsigned int v10 = *(_DWORD *)(v8 + 32);
      unsigned int v11 = *((_DWORD *)v9 + 8);
      if (v10 > v11)
      {
        llvm::createSequentialMask(0, *((_DWORD *)v9 + 8), v10 - v11, (uint64_t)&v30);
        unsigned int v12 = v30;
        unint64_t v13 = (llvm::Type *)v31;
        __int16 v23 = 257;
        uint64_t v15 = llvm::PoisonValue::get(*v7, v14);
        int v7 = (llvm::PoisonValue **)sub_1CB935A74(a1, (uint64_t)v7, (uint64_t)v15, v12, v13, (uint64_t)v22);
        if (v30 != v32) {
          free(v30);
        }
      }
      llvm::createSequentialMask(0, v11 + v10, 0, (uint64_t)&v30);
      __int16 v23 = 257;
      uint64_t v16 = sub_1CB935A74(a1, v6, (uint64_t)v7, v30, (llvm::Type *)v31, (uint64_t)v22);
      if (v30 != v32) {
        free(v30);
      }
      if (v25 >= (unint64_t)HIDWORD(v25)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v24 + v25) = v16;
      unsigned int v17 = v25 + 1;
      LODWORD(v25) = v25 + 1;
      v5 += 2;
    }
    while (v5 < v4);
    if (v3)
    {
      uint64_t v18 = *((void *)v27 + v4);
      if (v17 >= HIDWORD(v25)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      goto LABEL_19;
    }
LABEL_20:
    sub_1CBB08064((uint64_t)&v27, (uint64_t)&v24);
    unsigned int v3 = v28;
    if (v24 != v26) {
      free(v24);
    }
  }
  while (v3 > 1);
  uint64_t v19 = *(void *)v27;
  if (v27 != v29) {
    free(v27);
  }
  return v19;
}

uint64_t llvm::maskIsAllZeroOrUndef(llvm *this, llvm::Value *a2)
{
  uint64_t result = 0;
  if (this && *((unsigned __int8 *)this + 16) <= 0x14u)
  {
    if ((llvm::Constant::isNullValue(this) & 1) != 0 || *((unsigned __int8 *)this + 16) - 11 < 2) {
      return 1;
    }
    if (*(unsigned char *)(*(void *)this + 8) == 19) {
      return 0;
    }
    int v4 = *(_DWORD *)(*(void *)this + 32);
    if (!v4)
    {
      return 1;
    }
    else
    {
      unsigned int v5 = 0;
      do
      {
        uint64_t result = (uint64_t)llvm::Constant::getAggregateElement(this, v5);
        if (!result) {
          break;
        }
        uint64_t v6 = result;
        if ((llvm::Constant::isNullValue((llvm::Constant *)result) & 1) == 0
          && *(unsigned __int8 *)(v6 + 16) - 11 > 1)
        {
          return 0;
        }
        unsigned int v5 = (llvm::Type *)(v5 + 1);
        uint64_t result = 1;
      }
      while (v4 != v5);
    }
  }
  return result;
}

uint64_t llvm::maskIsAllOneOrUndef(llvm *this, llvm::Value *a2)
{
  uint64_t result = 0;
  if (this && *((unsigned __int8 *)this + 16) <= 0x14u)
  {
    if (llvm::Constant::isAllOnesValue(this) || *((unsigned __int8 *)this + 16) - 11 < 2) {
      return 1;
    }
    if (*(unsigned char *)(*(void *)this + 8) == 19) {
      return 0;
    }
    int v4 = *(_DWORD *)(*(void *)this + 32);
    if (!v4)
    {
      return 1;
    }
    else
    {
      unsigned int v5 = 0;
      do
      {
        uint64_t result = (uint64_t)llvm::Constant::getAggregateElement(this, v5);
        if (!result) {
          break;
        }
        uint64_t v6 = result;
        if (!llvm::Constant::isAllOnesValue((llvm::Constant *)result)
          && *(unsigned __int8 *)(v6 + 16) - 11 > 1)
        {
          return 0;
        }
        unsigned int v5 = (llvm::Type *)(v5 + 1);
        uint64_t result = 1;
      }
      while (v4 != v5);
    }
  }
  return result;
}

uint64_t llvm::possiblyDemandedEltsInMask@<X0>(llvm *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3 = (unsigned __int8 *)this;
  unsigned int v5 = *(_DWORD *)(*(void *)this + 32);
  uint64_t result = sub_1CB8F1EEC(a2, v5, -1);
  int v7 = v3[16];
  if (v7 != 10) {
    unsigned int v3 = 0;
  }
  if (v5) {
    BOOL v8 = v7 == 10;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    unsigned int v9 = 0;
    do
    {
      Aggregateuint64_t Element = (llvm::Constant *)llvm::Constant::getAggregateElement((llvm::Constant *)v3, v9);
      uint64_t result = llvm::Constant::isNullValue(AggregateElement);
      if (result)
      {
        if (*(_DWORD *)(a2 + 8) >= 0x41u) {
          unsigned int v11 = (void *)(*(void *)a2 + 8 * (v9 >> 6));
        }
        else {
          unsigned int v11 = (void *)a2;
        }
        *v11 &= ~(1 << (char)v9);
      }
      unsigned int v9 = (llvm::Type *)(v9 + 1);
    }
    while (v5 != v9);
  }
  return result;
}

void *llvm::InterleavedAccessInfo::collectConstStrideAccesses(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(*(void *)(**(void **)(v4 + 32) + 56) + 40);
  sub_1CBFCBAB0((uint64_t)v36, v4);
  llvm::LoopBlocksDFS::perform((llvm::LoopBlocksDFS *)v36, *(llvm::LoopInfo **)(a1 + 24));
  uint64_t v6 = v38;
  uint64_t v33 = v37;
  if (v38 != v37)
  {
    int v7 = (llvm::DataLayout *)(v5 + 272);
    do
    {
      uint64_t v9 = v6 - 8;
      uint64_t v8 = *(void *)(v6 - 8);
      uint64_t v34 = v9;
      uint64_t v10 = v8 + 40;
      for (uint64_t i = *(void *)(v8 + 48); i != v10; uint64_t i = *(void *)(i + 8))
      {
        unsigned int v12 = (uint64_t *)(i - 24);
        if (i) {
          uint64_t v13 = i - 24;
        }
        else {
          uint64_t v13 = 0;
        }
        int v14 = *(unsigned __int8 *)(v13 + 16);
        if (i && v14 == 60)
        {
          uint64_t v15 = *(llvm::Value **)(v13 - 32);
          if (!v15) {
            continue;
          }
        }
        else
        {
          if (!i) {
            continue;
          }
          if (v14 != 61) {
            continue;
          }
          uint64_t v15 = *(llvm::Value **)(v13 - 32);
          if (!v15) {
            continue;
          }
          unsigned int v12 = *(uint64_t **)(v13 - 64);
        }
        uint64_t v16 = (llvm::Type *)*v12;
        uint64_t v17 = sub_1CB83544C((uint64_t)v7, *v12);
        BOOL v19 = v18 == 1;
        char Alignment = llvm::DataLayout::getAlignment(v7, v16, 1);
        if (v19) {
        uint64_t v22 = sub_1CB83544C((uint64_t)v7, (uint64_t)v16);
        }
        if (v23 == 1)
        {
          uint64_t v30 = v22;
          uint64_t v22 = v30;
        }
        unint64_t v24 = ((1 << Alignment) + ((unint64_t)(v17 + 7) >> 3) - 1) & -(1 << Alignment);
        if (8 * v24 == v22)
        {
          uint64_t PtrStride = llvm::getPtrStride(*(int8x16_t **)a1, v16, v15, *(void *)(a1 + 8), a3, 1, 0);
          uint64_t v26 = llvm::replaceSymbolicStrideSCEV(*(int8x16_t **)a1, a3, v15);
          char v27 = __clz(1 << ((unint64_t)*(unsigned __int16 *)(v13 + 18) >> 1)) ^ 0x3F;
          uint64_t v35 = v13;
          uint64_t v28 = sub_1CD4D55EC(a2, &v35);
          *(void *)uint64_t v28 = PtrStride;
          *(void *)(v28 + 8) = v26;
          *(void *)(v28 + 16) = v24;
          *(unsigned char *)(v28 + 24) = v27;
        }
      }
      uint64_t v6 = v34;
    }
    while (v34 != v33);
  }
  return sub_1CBFCBB34(v36);
}

uint64_t sub_1CD4D55EC(uint64_t a1, uint64_t *a2)
{
  uint64_t v16 = *a2;
  int v17 = 0;
  sub_1CD45714C((_DWORD *)a1, &v16, &v17, (uint64_t)&v14);
  uint64_t v4 = v14;
  if (v15)
  {
    HIDWORD(v13) = 0;
    *(_DWORD *)((char *)&v13 + 1) = 0;
    long long v11 = (unint64_t)*a2;
    long long v12 = 0uLL;
    LOBYTE(v13) = 0;
    unint64_t v5 = *(void *)(a1 + 32);
    if (v5 >= *(void *)(a1 + 40))
    {
      int v7 = sub_1CC0D30FC((void **)(a1 + 24), (uint64_t)&v11);
    }
    else
    {
      long long v6 = v12;
      *(_OWORD *)unint64_t v5 = v11;
      *(_OWORD *)(v5 + 16) = v6;
      *(void *)(v5 + 32) = v13;
      int v7 = (char *)(v5 + 40);
    }
    *(void *)(a1 + 32) = v7;
    uint64_t v9 = *(void *)(a1 + 24);
    unsigned int v8 = -858993459 * ((unint64_t)&v7[-v9] >> 3) - 1;
    *(_DWORD *)(v4 + 8) = v8;
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(v14 + 8);
    uint64_t v9 = *(void *)(a1 + 24);
  }
  return v9 + 40 * v8 + 8;
}

void *sub_1CD4D56D0(void *result)
{
  uint64_t v1 = result[4];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 16);
    if (*(unsigned char *)(v2 + 216))
    {
      uint64_t v3 = *(unsigned int *)(v2 + 232);
      if (v3)
      {
        uint64_t v4 = result;
        unint64_t v5 = *(unsigned int **)(v2 + 224);
        long long v6 = &v5[4 * v3];
        uint64_t v7 = (uint64_t)(result + 17);
        do
        {
          uint64_t v8 = *v5;
          uint64_t v9 = v5[1];
          v5 += 4;
          uint64_t v11 = *(void *)(*(void *)(*(void *)(v4[4] + 16) + 40) + 8 * v8);
          uint64_t v10 = sub_1CD4D60C0(v7, &v11);
          uint64_t result = sub_1CB89694C((llvm::SmallPtrSetImplBase *)(v10 + 1), *(void *)(*(void *)(*(void *)(v4[4] + 16) + 40) + 8 * v9));
        }
        while (v5 != v6);
      }
    }
  }
  return result;
}

void sub_1CD4D5774(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  operator new();
}

void *sub_1CD4D5854(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (void *)sub_1CC18A12C((_DWORD *)a1, *a2);
  if (result)
  {
    uint64_t result = *(void **)(a1 + 40);
    uint64_t v5 = *(unsigned int *)(a1 + 48);
    long long v6 = &result[v5];
    if (v5)
    {
      uint64_t v7 = 8 * v5;
      while (*result != *a2)
      {
        ++result;
        v7 -= 8;
        if (!v7)
        {
          uint64_t result = v6;
          break;
        }
      }
    }
    if (v6 != result + 1)
    {
      uint64_t result = memmove(result, result + 1, (char *)v6 - (char *)(result + 1));
      LODWORD(v5) = *(_DWORD *)(a1 + 48);
    }
    *(_DWORD *)(a1 + 48) = v5 - 1;
  }
  return result;
}

uint64_t sub_1CD4D58D4(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2)
  {
    unsigned int v4 = 0;
    do
    {
      unsigned int v10 = v4 + *(_DWORD *)(a2 + 32);
      uint64_t v5 = sub_1CD4D6838((uint64_t *)(a2 + 8), &v10);
      if (v5)
      {
        uint64_t v11 = 0;
        if (sub_1CD40EA84(*(void *)(a1 + 48), *(_DWORD *)(a1 + 64), v5, &v11))
        {
          *uint64_t v11 = -8192;
          *(int32x2_t *)(a1 + 56) = vadd_s32(*(int32x2_t *)(a1 + 56), (int32x2_t)0x1FFFFFFFFLL);
        }
      }
      ++v4;
    }
    while (v4 < *(_DWORD *)a2);
  }
  long long v6 = sub_1CB896AE8(a1 + 72, a2);
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = 88;
  if (v7 == *(void *)(a1 + 72)) {
    uint64_t v8 = 92;
  }
  if (v6 != (void *)(v7 + 8 * *(unsigned int *)(a1 + v8)))
  {
    *long long v6 = -2;
    ++*(_DWORD *)(a1 + 96);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a2 + 8), 8);
  return MEMORY[0x1D25D9CE0](a2, 0x1020C40BF128421);
}

int *sub_1CD4D5A00(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int **)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  unsigned int v4 = &v2[4 * v3];
  if (*(_DWORD *)(a1 + 16))
  {
    if (v3)
    {
      uint64_t v5 = 16 * v3;
      long long v6 = *(int **)(a1 + 8);
      while ((*v6 - 0x7FFFFFFF) <= 1)
      {
        v6 += 4;
        v5 -= 16;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      long long v6 = *(int **)(a1 + 8);
    }
  }
  else
  {
LABEL_6:
    long long v6 = &v2[4 * v3];
  }
  uint64_t v7 = &v2[4 * v3];
  if (v6 != v7)
  {
    while (*((void *)v6 + 1) != a2)
    {
      uint64_t v2 = v6 + 4;
      while (v2 != v4)
      {
        int v8 = *v2;
        v2 += 4;
        if ((v8 - 0x7FFFFFFF) >= 2)
        {
          long long v6 = v2 - 4;
          goto LABEL_14;
        }
      }
      long long v6 = v4;
LABEL_14:
      if (v6 == v7) {
        return v2;
      }
    }
    return (int *)(*v6 - *(_DWORD *)(a1 + 32));
  }
  return v2;
}

uint64_t sub_1CD4D5AB4(unsigned int *a1, uint64_t a2, signed int a3, unsigned __int8 a4)
{
  unint64_t v8 = sub_1CC18A180(a3, a1[8], (void (*)(uint64_t **__return_ptr, char *, uint64_t *, char *))llvm::APInt::sadd_ov, 0);
  if (!HIDWORD(v8)) {
    return 0;
  }
  signed int v9 = v8;
  int v16 = v8;
  if ((v8 - 0x7FFFFFFF) < 2) {
    return 0;
  }
  uint64_t v11 = *((void *)a1 + 1);
  uint64_t v12 = a1[6];
  if ((int *)(v11 + 16 * v12) != sub_1CD4D7294(v11, a1[6], v8)) {
    return 0;
  }
  signed int v13 = a1[9];
  if (v13 >= v9)
  {
    if ((int)a1[8] <= v9) {
      goto LABEL_12;
    }
    unint64_t v14 = sub_1CC18A180(v13, v9, (void (*)(uint64_t **__return_ptr, char *, uint64_t *, char *))llvm::APInt::ssub_ov, 0);
    if (HIDWORD(v14) && *a1 > (uint64_t)(int)v14)
    {
      a1[8] = v9;
      goto LABEL_12;
    }
    return 0;
  }
  if ((int)*a1 <= a3) {
    return 0;
  }
  a1[9] = v9;
LABEL_12:
  unsigned int v15 = *((unsigned __int8 *)a1 + 5);
  if (v15 >= a4) {
    LOBYTE(v15) = a4;
  }
  *((unsigned char *)a1 + 5) = v15;
  *((void *)sub_1CD4D63A4((uint64_t)(a1 + 2), &v16) + 1) = a2;
  return 1;
}

uint64_t llvm::InterleavedAccessInfo::invalidateGroupsRequiringScalarEpilogue(uint64_t this)
{
  if (*(unsigned char *)(this + 40))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 80);
    if (v2 == *(void *)(this + 72)) {
      uint64_t v3 = (unsigned int *)(this + 92);
    }
    else {
      uint64_t v3 = (unsigned int *)(this + 88);
    }
    uint64_t v4 = *v3;
    if (v4)
    {
      uint64_t v5 = 8 * v4;
      long long v6 = *(unint64_t **)(this + 80);
      while (*v6 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v6;
        v5 -= 8;
        if (!v5) {
          goto LABEL_9;
        }
      }
    }
    else
    {
      long long v6 = *(unint64_t **)(this + 80);
    }
    uint64_t v7 = (unint64_t *)(v2 + 8 * v4);
    while (v6 != v7)
    {
      unint64_t v8 = (uint64_t **)v6;
      signed int v9 = v6 + 1;
      while (v9 != v7)
      {
        unint64_t v10 = *v9++;
        if (v10 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          long long v6 = v9 - 1;
          goto LABEL_19;
        }
      }
      long long v6 = v7;
LABEL_19:
      uint64_t v11 = *v8;
      int v12 = *(_DWORD *)*v8 + *((_DWORD *)*v8 + 8) - 1;
      this = sub_1CD4D6838(v11 + 1, &v12);
      if (!this) {
        this = sub_1CD4D58D4(v1, (uint64_t)v11);
      }
    }
LABEL_9:
    *(unsigned char *)(v1 + 40) = 0;
  }
  return this;
}

void llvm::InterleaveGroup<llvm::Instruction>::addMetadata(uint64_t a1, llvm *a2)
{
  v12[4] = *(llvm::MDNode **)MEMORY[0x1E4F143B8];
  int v11 = 0;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  uint64_t v4 = (int *)(v2 + 16 * v3);
  if (*(_DWORD *)(a1 + 16))
  {
    if (v3)
    {
      uint64_t v5 = 16 * v3;
      long long v6 = *(int **)(a1 + 8);
      while ((*v6 - 0x7FFFFFFF) <= 1)
      {
        v6 += 4;
        v5 -= 16;
        if (!v5) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      long long v6 = *(int **)(a1 + 8);
    }
  }
  else
  {
LABEL_6:
    long long v6 = (int *)(v2 + 16 * v3);
  }
  uint64_t v7 = (int *)(v2 + 16 * v3);
  if (v6 == v7)
  {
    uint64_t v8 = 0;
  }
  else
  {
    LODWORD(v8) = 0;
    do
    {
      if (v8 >= 4) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v12[v8] = (llvm::MDNode *)*((void *)v6 + 1);
      uint64_t v8 = ++v11;
      signed int v9 = v6 + 4;
      while (v9 != v4)
      {
        int v10 = *v9;
        v9 += 4;
        if ((v10 - 0x7FFFFFFF) >= 2)
        {
          long long v6 = v9 - 4;
          goto LABEL_15;
        }
      }
      long long v6 = v4;
LABEL_15:
      ;
    }
    while (v6 != v7);
  }
  llvm::propagateMetadata(a2, v12, v8);
}

void llvm::VFABI::mangleTLIVectorName(const void *a1@<X0>, size_t a2@<X1>, const void *a3@<X2>, size_t a4@<X3>, int a5@<W4>, unint64_t a6@<X5>, std::string *a7@<X8>)
{
  v32[32] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = &v30;
  uint64_t v30 = v32;
  long long v31 = xmmword_1CD96DBF0;
  int v22 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  int v28 = 0;
  unsigned int v21 = &unk_1F2646FA8;
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  unint64_t v14 = sub_1CB8E509C((llvm::raw_ostream *)&v21, "_ZGV");
  unsigned int v15 = sub_1CB8E509C(v14, "_LLVM_");
  sub_1CB8E509C(v15, "N");
  if (HIDWORD(a6) == 1)
  {
    int v16 = v25;
    if ((unint64_t)v25 >= v24)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v21, 120);
    }
    else
    {
      ++v25;
      *int v16 = 120;
    }
  }
  else
  {
    sub_1CD098D14((llvm::raw_ostream *)&v21, a6, 0, 0, 0);
  }
  for (; a5; --a5)
    sub_1CB8E509C((llvm::raw_ostream *)&v21, "v");
  int v17 = sub_1CB8E509C((llvm::raw_ostream *)&v21, "_");
  int v18 = (void *)*((void *)v17 + 4);
  if (a4 <= *((void *)v17 + 3) - (void)v18)
  {
    if (a4)
    {
      memcpy(v18, a3, a4);
      *((void *)v17 + 4) += a4;
    }
  }
  else
  {
    llvm::raw_ostream::write(v17, (const char *)a3, a4);
  }
  BOOL v19 = sub_1CB8E509C(v17, "(");
  uint64_t v20 = (void *)*((void *)v19 + 4);
  if (a2 <= *((void *)v19 + 3) - (void)v20)
  {
    if (a2)
    {
      memcpy(v20, a1, a2);
      *((void *)v19 + 4) += a2;
    }
  }
  else
  {
    llvm::raw_ostream::write(v19, (const char *)a1, a2);
  }
  sub_1CB8E509C(v19, ")");
  std::string::__init(a7, (const std::string::value_type *)*v29, (std::string::size_type)v29[1]);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v21);
  if (v30 != v32) {
    free(v30);
  }
}

void *sub_1CD4D60C0(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4D6144(a1, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = v5 + 5;
    void v5[2] = v5 + 5;
    v5[3] = 2;
    *((_DWORD *)v5 + 8) = 0;
  }
  return v5;
}

void *sub_1CD4D6144(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4D61F8(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4D61F8(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4D62D0(a1, v4, &v4[7 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 7;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

void sub_1CD4D62D0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 56 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      signed int v13 = 0;
      sub_1CD4A7E9C(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      uint64_t v10 = v13;
      uint64_t v11 = v13 + 5;
      *signed int v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 2, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      int v12 = (void *)a2[2];
      if (v12 != (void *)a2[1]) {
        free(v12);
      }
    }
    a2 += 7;
  }
}

_DWORD *sub_1CD4D63A4(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD4D6468(a1, a2, v9);
    *uint64_t v6 = *a2;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != 0x7FFFFFFF)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == 0x80000000;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD4D6468(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD4D65FC(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != 0x7FFFFFFF)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == 0x80000000;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD4D65FC(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != 0x7FFFFFFF)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == 0x80000000;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != 0x7FFFFFFF) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD4D65FC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4D66C8(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = 0x7FFFFFFF;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4D66C8(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    int v4 = *(_DWORD **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *int v4 = 0x7FFFFFFF;
      v4 += 4;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 4)
  {
    int v6 = *a2;
    if ((*a2 - 0x7FFFFFFF) >= 2)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      unsigned int v8 = v7 & (37 * v6);
      uint64_t v9 = *(void *)result + 16 * v8;
      int v10 = *(_DWORD *)v9;
      if (v6 != *(_DWORD *)v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != 0x7FFFFFFF)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == 0x80000000;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          unsigned int v14 = v8 + v12++;
          unsigned int v8 = v14 & v7;
          uint64_t v9 = *(void *)result + 16 * (v14 & v7);
          int v10 = *(_DWORD *)v9;
          if (v6 == *(_DWORD *)v9) {
            goto LABEL_7;
          }
        }
        if (v11) {
          uint64_t v9 = v11;
        }
      }
LABEL_7:
      *(_DWORD *)uint64_t v9 = v6;
      *(void *)(v9 + 8) = *((void *)a2 + 1);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

double sub_1CD4D67A8(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = 0;
  if (sub_1CD4A7E9C(a2, a3, a4, &v7))
  {
    uint64_t v5 = (const llvm::SmallPtrSetImplBase *)(v7 + 8);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)a1, (const void **)(a1 + 32), v5);
  }
  else
  {
    *(void *)a1 = a1 + 32;
    *(void *)(a1 + 8) = a1 + 32;
    *(void *)&double result = 2;
    *(void *)(a1 + 16) = 2;
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}

uint64_t sub_1CD4D6838(uint64_t *a1, _DWORD *a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  if (v2)
  {
    uint64_t v3 = *a1;
    unsigned int v4 = v2 - 1;
    uint64_t v5 = (37 * *a2) & (v2 - 1);
    int v6 = *(_DWORD *)(*a1 + 16 * ((37 * *a2) & v4));
    if (*a2 == v6) {
      return *(void *)(v3 + 16 * v5 + 8);
    }
    int v8 = 1;
    while (v6 != 0x7FFFFFFF)
    {
      int v9 = v5 + v8++;
      uint64_t v5 = v9 & v4;
      int v6 = *(_DWORD *)(v3 + 16 * v5);
      if (*a2 == v6) {
        return *(void *)(v3 + 16 * v5 + 8);
      }
    }
  }
  return 0;
}

char **sub_1CD4D68AC(char **a1)
{
  int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = v3 << 6;
    do
    {
      uint64_t v5 = *(char **)&v2[v4 - 64];
      if (&v2[v4 - 48] != v5) {
        free(v5);
      }
      v4 -= 64;
    }
    while (v4);
    int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD4D6920(char **result, unint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  if (*((unsigned int *)result + 3) < a2)
  {
    sub_1CD4D6A48();
  }
  unint64_t v6 = *((unsigned int *)result + 2);
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = *((unsigned int *)result + 2);
  }
  if (v7)
  {
    double result = (char **)*result;
    do
    {
      double result = (char **)(sub_1CD4D6B28((uint64_t)result, a3) + 80);
      --v7;
    }
    while (v7);
    unint64_t v6 = *((unsigned int *)v5 + 2);
  }
  unint64_t v8 = v6 - a2;
  if (v6 >= a2)
  {
    if (v6 > a2)
    {
      uint64_t v10 = 5 * v6;
      uint64_t v11 = 80 * a2 - 16 * v10;
      double result = (char **)&(*v5)[16 * v10 - 80];
      do
      {
        double result = sub_1CD4D68AC(result) - 10;
        v11 += 80;
      }
      while (v11);
    }
  }
  else
  {
    double result = (char **)&(*v5)[80 * v6];
    do
    {
      *double result = (char *)(result + 2);
      result[1] = (char *)0x100000000;
      if (*(_DWORD *)(a3 + 8)) {
        double result = (char **)sub_1CD4D6B28((uint64_t)result, a3);
      }
      result += 10;
    }
    while (!__CFADD__(v8++, 1));
  }
  *((_DWORD *)v5 + 2) = a2;
  return result;
}

void sub_1CD4D6A48()
{
}

uint64_t sub_1CD4D6B28(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v9 = 0;
        uint64_t v10 = *(void *)a2;
        uint64_t v11 = *(void *)a1;
        do
        {
          sub_1CD41B6B0(v11 + v9, v10 + v9);
          v9 += 64;
        }
        while (v4 << 6 != v9);
        uint64_t v5 = *(unsigned int *)(a1 + 8);
        uint64_t v12 = *(void *)a1;
        uint64_t v13 = v11 + v9;
      }
      else
      {
        uint64_t v12 = *(void *)a1;
        uint64_t v13 = *(void *)a1;
      }
      uint64_t v14 = v12 + (v5 << 6);
      while (v14 != v13)
      {
        int v16 = *(void **)(v14 - 64);
        v14 -= 64;
        unsigned int v15 = v16;
        if ((void *)(v14 + 16) != v16) {
          free(v15);
        }
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        if (v5)
        {
          uint64_t v17 = *(void *)a1;
          uint64_t v18 = v5 << 6;
          do
          {
            int v19 = *(void **)(v17 + v18 - 64);
            if ((void *)(v17 + v18 - 48) != v19) {
              free(v19);
            }
            v18 -= 64;
          }
          while (v18);
        }
        *(_DWORD *)(a1 + 8) = 0;
        sub_1CD4D6CD0();
      }
      if (v5)
      {
        uint64_t v6 = *(void *)a2;
        uint64_t v7 = *(void *)a1;
        uint64_t v8 = v5 << 6;
        do
        {
          sub_1CD41B6B0(v7, v6);
          v6 += 64;
          v7 += 64;
          v8 -= 64;
        }
        while (v8);
      }
      else
      {
        uint64_t v5 = 0;
      }
      uint64_t v20 = *(unsigned int *)(a2 + 8);
      if (v5 != v20)
      {
        uint64_t v22 = *(void *)a2;
        uint64_t v23 = *(void *)a1;
        uint64_t v24 = v5 << 6;
        uint64_t v25 = v20 << 6;
        do
        {
          char v26 = (void *)(v23 + v24);
          void *v26 = v23 + v24 + 16;
          v26[1] = 0xC00000000;
          if (*(_DWORD *)(v22 + v24 + 8)) {
            sub_1CD41B6B0((uint64_t)v26, v22 + v24);
          }
          v23 += 64;
          v25 -= 64;
          v22 += 64;
        }
        while (v24 != v25);
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void sub_1CD4D6CD0()
{
}

void sub_1CD4D6D40(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = v2 << 6;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0xC00000000;
      if (*(_DWORD *)(v5 + 8)) {
        sub_1CD41B598((uint64_t)a2, v5);
      }
      v5 += 64;
      a2 += 8;
      v6 -= 64;
    }
    while (v6);
    uint64_t v7 = *(unsigned int *)(a1 + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = v7 << 6;
      do
      {
        uint64_t v10 = *(void **)(v8 + v9 - 64);
        if ((void *)(v8 + v9 - 48) != v10) {
          free(v10);
        }
        v9 -= 64;
      }
      while (v9);
    }
  }
}

void sub_1CD4D6DF4()
{
}

uint64_t sub_1CD4D6EE8(uint64_t a1)
{
  uint64_t v1 = a1;
  if ((*(unsigned char *)(a1 + 8) & 1) == 0)
  {
    uint64_t v2 = *(void *)a1;
    if ((*(unsigned char *)(*(void *)v1 + 8) & 1) == 0)
    {
      uint64_t v2 = sub_1CD4D6EE8();
      *(void *)uint64_t v1 = v2;
    }
    return v2;
  }
  return v1;
}

uint64_t **sub_1CD4D6F30(uint64_t **a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[6];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x38uLL);
    _OWORD v7[4] = (uint64_t *)(v7 + 4);
    v7[5] = (uint64_t *)1;
    v7[6] = a3;
    *uint64_t v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1CD4D7004(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4D7068((uint64_t)a1, (uint64_t)a2, a2, v7);
    *uint64_t v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4D7068(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4D7118(a1, v7);
  uint64_t v9 = 0;
  sub_1CD3C8538((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD4D7118(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4D71E4(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *double result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4D71E4(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *int v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      double result = sub_1CD3C8538((uint64_t *)v5, a2, &v11);
      uint64_t v9 = v11;
      uint64_t v10 = a2[1];
      *uint64_t v11 = *a2;
      v9[1] = v10;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

int *sub_1CD4D7294(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2) {
    return (int *)(a1 + 16 * a2);
  }
  LODWORD(v3) = (37 * a3) & (a2 - 1);
  char v4 = (int *)(a1 + 16 * v3);
  int v5 = *v4;
  if (*v4 != a3)
  {
    int v7 = 1;
    while (v5 != 0x7FFFFFFF)
    {
      int v8 = v3 + v7++;
      uint64_t v3 = v8 & (a2 - 1);
      int v5 = *(_DWORD *)(a1 + 16 * v3);
      if (v5 == a3) {
        return (int *)(a1 + 16 * v3);
      }
    }
    return (int *)(a1 + 16 * a2);
  }
  return v4;
}

uint64_t sub_1CD4D72FC(uint64_t result, _OWORD *a2, _OWORD *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_OWORD **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      *v7++ = xmmword_1CFAC4A20;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(void *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v9 = 0;
      double result = sub_1CC18A4C4((uint64_t *)v5, (uint64_t)a2, &v9);
      *uint64_t v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t llvm::LLLexer::Error(uint64_t a1, char *a2, llvm::Twine *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  llvm::SourceMgr::GetMessage(this, *(uint64_t **)(a1 + 32), a2, 0, 0, 0, 0, 0, (uint64_t)v5);
  sub_1CD4D7434(*(void *)(a1 + 24), (uint64_t)v5);
  sub_1CC192528((uint64_t)v5);
  return 1;
}

uint64_t sub_1CD4D7434(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = a1 + 16;
  uint64_t v5 = (long long *)(a2 + 16);
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)v4);
  }
  long long v6 = *v5;
  *(void *)(v4 + 16) = *((void *)v5 + 2);
  *(_OWORD *)uint64_t v4 = v6;
  *(unsigned char *)(a2 + 39) = 0;
  *(unsigned char *)(a2 + 16) = 0;
  int v7 = *(_DWORD *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_DWORD *)(a1 + 48) = v7;
  uint64_t v8 = (void **)(a1 + 56);
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*v8);
  }
  long long v9 = *(_OWORD *)(a2 + 56);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)uint64_t v8 = v9;
  *(unsigned char *)(a2 + 79) = 0;
  *(unsigned char *)(a2 + 56) = 0;
  uint64_t v10 = (void **)(a1 + 80);
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*v10);
  }
  long long v11 = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)uint64_t v10 = v11;
  *(unsigned char *)(a2 + 103) = 0;
  *(unsigned char *)(a2 + 80) = 0;
  sub_1CD46D2D8(a1 + 104, (__n128 *)(a2 + 104));
  sub_1CD4D8320(a1 + 128, a2 + 128);
  return a1;
}

uint64_t sub_1CD4D7520(uint64_t a1, llvm::Twine *this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  llvm::SourceMgr::GetMessage(this, *(uint64_t **)(a1 + 32), *(char **)(a1 + 48), 0, 0, 0, 0, 0, (uint64_t)v4);
  sub_1CD4D7434(*(void *)(a1 + 24), (uint64_t)v4);
  return sub_1CC192528((uint64_t)v4);
}

uint64_t llvm::LLLexer::HexToIntPair(uint64_t this, const char *a2, const char *a3, unint64_t *a4)
{
  *a4 = 0;
  if (a3 - a2 >= 16)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = 16 * v5;
      *a4 = v6;
      unint64_t v5 = v6 + word_1CFAC4A4C[a2[v4]];
      *a4 = v5;
      ++v4;
    }
    while (v4 != 16);
    a2 += v4;
  }
  a4[1] = 0;
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = 16 * v8;
      a4[1] = v9;
      uint64_t v10 = &a2[v7 + 1];
      unint64_t v8 = v9 + word_1CFAC4A4C[a2[v7]];
      a4[1] = v8;
      if (v7 > 0xE) {
        break;
      }
      ++v7;
    }
    while (v10 != a3);
    if (v10 != a3)
    {
      long long v11 = "constant bigger than 128 bits detected!";
      __int16 v12 = 259;
      return sub_1CD4D7520(this, (llvm::Twine *)&v11);
    }
  }
  return this;
}

uint64_t llvm::LLLexer::FP80HexToIntPair(uint64_t this, const char *a2, const char *a3, unint64_t *a4)
{
  a4[1] = 0;
  if (a2 != a3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = 16 * v5;
      a4[1] = v6;
      uint64_t v7 = &a2[v4 + 1];
      unint64_t v5 = v6 + word_1CFAC4A4C[a2[v4]];
      a4[1] = v5;
      uint64_t v8 = v4 + 1;
      if (v4 > 2) {
        break;
      }
      ++v4;
    }
    while (v7 != a3);
    a2 += v8;
  }
  *a4 = 0;
  if (a2 != a3)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = 16 * v10;
      *a4 = v11;
      __int16 v12 = &a2[v9 + 1];
      unint64_t v10 = v11 + word_1CFAC4A4C[a2[v9]];
      *a4 = v10;
      if (v9 > 0xE) {
        break;
      }
      ++v9;
    }
    while (v12 != a3);
    if (v12 != a3)
    {
      uint64_t v13 = "constant bigger than 128 bits detected!";
      __int16 v14 = 259;
      return sub_1CD4D7520(this, (llvm::Twine *)&v13);
    }
  }
  return this;
}

uint64_t llvm::LLLexer::LexPositive(llvm::LLLexer *this)
{
  void v13[3] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v1 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * **(unsigned __int8 **)this + 60) & 0x400) == 0) {
    return 1;
  }
  uint64_t v4 = (unsigned __int8 *)(*(void *)this + 1);
  do
  {
    *(void *)this = v4;
    unsigned int v6 = *v4++;
    unsigned int v5 = v6;
  }
  while ((*(_DWORD *)(v1 + 4 * v6 + 60) & 0x400) != 0);
  if (v5 != 46)
  {
    *(void *)this = *((void *)this + 6) + 1;
    return 1;
  }
  uint64_t v7 = v4 + 1;
  do
  {
    *(void *)this = v7 - 1;
    uint64_t v8 = *(v7++ - 1);
  }
  while ((*(_DWORD *)(v1 + 4 * v8 + 60) & 0x400) != 0);
  uint64_t v9 = v7 - 2;
  if ((v8 | 0x20) == 0x65)
  {
    uint64_t v10 = *(v7 - 1);
    if ((*(_DWORD *)(v1 + 4 * v10 + 60) & 0x400) != 0
      || (v10 == 43 || v10 == 45) && (*(_DWORD *)(v1 + 4 * *v7 + 60) & 0x400) != 0)
    {
      do
      {
        *(void *)this = v7;
        unsigned int v11 = *v7++;
      }
      while ((*(_DWORD *)(v1 + 4 * v11 + 60) & 0x400) != 0);
      uint64_t v9 = v7 - 1;
    }
  }
  llvm::APFloat::APFloat((uint64_t)v12, &unk_1CFB2E31C, *((unsigned __int8 **)this + 6), (unint64_t)&v9[-*((void *)this + 6)]);
  sub_1CB9190C0((uint64_t *)this + 14, v13);
  sub_1CB87DEE4((uint64_t *)v13);
  return 456;
}

uint64_t llvm::LLLexer::LexQuote(llvm::LLLexer *this)
{
  uint64_t result = llvm::LLLexer::ReadString((uint64_t)this, 442);
  if (result >= 2 && **(unsigned char **)this == 58)
  {
    ++*(void *)this;
    char v3 = *((unsigned char *)this + 87);
    int v4 = v3;
    size_t v5 = v3 & 0x7F;
    if (v4 >= 0) {
      size_t v6 = v5;
    }
    else {
      size_t v6 = *((void *)this + 9);
    }
    if (!v6) {
      return 437;
    }
    uint64_t v7 = v4 >= 0 ? (llvm::LLLexer *)((char *)this + 64) : (llvm::LLLexer *)*((void *)this + 8);
    uint64_t v8 = memchr(v7, 0, v6);
    if (!v8 || v8 - (unsigned char *)v7 == -1)
    {
      return 437;
    }
    else
    {
      uint64_t v10 = "Null bytes are not allowed in names";
      __int16 v11 = 259;
      sub_1CD4D7520((uint64_t)this, (llvm::Twine *)&v10);
      return 1;
    }
  }
  return result;
}

uint64_t llvm::LLLexer::LexExclaim(llvm::LLLexer *this)
{
  int v2 = **(char **)this;
  uint64_t v3 = **(unsigned __int8 **)this;
  uint64_t v4 = MEMORY[0x1E4F14390];
  if (v2 < 0) {
    int v5 = __maskrune(v3, 0x100uLL);
  }
  else {
    int v5 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v3 + 60) & 0x100;
  }
  if (!v5)
  {
    unsigned int v6 = **(unsigned __int8 **)this - 36;
    BOOL v7 = v6 > 0x3B;
    uint64_t v8 = (1 << v6) & 0x900000000000601;
    if (v7 || v8 == 0) {
      return 14;
    }
  }
  while (1)
  {
    uint64_t v10 = (char *)(*(void *)this + 1);
    *(void *)this = v10;
    uint64_t v11 = *v10;
    if (*v10 < 0) {
      int v12 = __maskrune(v11, 0x500uLL);
    }
    else {
      int v12 = *(_DWORD *)(v4 + 4 * v11 + 60) & 0x500;
    }
    if (!v12)
    {
      unsigned int v13 = **(unsigned __int8 **)this - 36;
      BOOL v7 = v13 > 0x3B;
      uint64_t v14 = (1 << v13) & 0x900000000000601;
      if (v7 || v14 == 0) {
        break;
      }
    }
  }
  sub_1CC19262C((std::string *)((char *)this + 64), (std::string::value_type *)(*((void *)this + 6) + 1), *(std::string::value_type **)this, *(void *)this - (*((void *)this + 6) + 1));
  sub_1CC192388((std::string *)((char *)this + 64));
  return 441;
}

uint64_t llvm::LLLexer::LexVar(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(unsigned char **)a1;
  if (**(unsigned char **)a1 == 34)
  {
    unsigned int v6 = v5 + 1;
    for (uint64_t i = 1 - (void)v5; ; --i)
    {
      *(void *)a1 = v6 + 1;
      if (*v6)
      {
        if (*v6 == 34)
        {
          uint64_t v8 = (void *)(a1 + 64);
          sub_1CC19262C((std::string *)(a1 + 64), (std::string::value_type *)(*(void *)(a1 + 48) + 2), v6, -i - *(void *)(a1 + 48));
          sub_1CC192388((std::string *)(a1 + 64));
          char v9 = *(unsigned char *)(a1 + 87);
          int v10 = v9;
          size_t v11 = v9 & 0x7F;
          if (v10 >= 0) {
            size_t v12 = v11;
          }
          else {
            size_t v12 = *(void *)(a1 + 72);
          }
          if (v12)
          {
            if (v10 < 0) {
              uint64_t v8 = (void *)*v8;
            }
            unsigned int v13 = memchr(v8, 0, v12);
            if (v13 && v13 - (unsigned char *)v8 != -1)
            {
              uint64_t v17 = "Null bytes are not allowed in names";
LABEL_25:
              uint64_t v18 = v17;
              __int16 v19 = 259;
              sub_1CD4D7520(a1, (llvm::Twine *)&v18);
              return 1;
            }
          }
          return a2;
        }
      }
      else if (v6 == (std::string::value_type *)(*(void *)(a1 + 8) + *(void *)(a1 + 16)))
      {
        *(void *)a1 = v6;
        uint64_t v17 = "end of file in global variable name";
        goto LABEL_25;
      }
      ++v6;
    }
  }
  if (llvm::LLLexer::ReadVarName((llvm::LLLexer *)a1)) {
    return a2;
  }

  return llvm::LLLexer::LexUIntID((unsigned __int8 **)a1, a3);
}

uint64_t llvm::LLLexer::ReadVarName(llvm::LLLexer *this)
{
  int v2 = *(std::string::value_type **)this;
  int v3 = **(char **)this;
  uint64_t v4 = **(unsigned __int8 **)this;
  uint64_t v5 = MEMORY[0x1E4F14390];
  if (v3 < 0) {
    int v6 = __maskrune(v4, 0x100uLL);
  }
  else {
    int v6 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x100;
  }
  if (!v6)
  {
    unsigned int v7 = **(unsigned __int8 **)this - 36;
    BOOL v8 = v7 > 0x3B;
    uint64_t v9 = (1 << v7) & 0x800000000000601;
    if (v8 || v9 == 0) {
      return 0;
    }
  }
  while (1)
  {
    size_t v11 = (char *)(*(void *)this + 1);
    *(void *)this = v11;
    uint64_t v12 = *v11;
    if (*v11 < 0) {
      int v13 = __maskrune(v12, 0x500uLL);
    }
    else {
      int v13 = *(_DWORD *)(v5 + 4 * v12 + 60) & 0x500;
    }
    if (!v13)
    {
      unsigned int v14 = **(unsigned __int8 **)this - 36;
      BOOL v8 = v14 > 0x3B;
      uint64_t v15 = (1 << v14) & 0x800000000000601;
      if (v8 || v15 == 0) {
        break;
      }
    }
  }
  sub_1CC19262C((std::string *)((char *)this + 64), v2, *(std::string::value_type **)this, *(void *)this - (void)v2);
  return 1;
}

uint64_t llvm::LLLexer::ReadString(uint64_t a1, uint64_t a2)
{
  std::string::size_type v3 = 0;
  uint64_t v4 = *(std::string::value_type **)a1;
  while (1)
  {
    *(void *)a1 = &v4[v3 + 1];
    if (!v4[v3]) {
      break;
    }
    if (v4[v3] == 34)
    {
      uint64_t v5 = (std::string *)(a1 + 64);
      sub_1CC19262C((std::string *)(a1 + 64), v4, &v4[v3], v3);
      sub_1CC192388(v5);
      return a2;
    }
LABEL_6:
    ++v3;
  }
  if (&v4[v3] != (std::string::value_type *)(*(void *)(a1 + 8) + *(void *)(a1 + 16))) {
    goto LABEL_6;
  }
  *(void *)a1 = &v4[v3];
  unsigned int v7 = "end of file in string constant";
  __int16 v8 = 259;
  sub_1CD4D7520(a1, (llvm::Twine *)&v7);
  return 1;
}

uint64_t llvm::LLLexer::LexUIntID(unsigned __int8 **a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * **a1 + 60) & 0x400) == 0) {
    return 1;
  }
  uint64_t v3 = a2;
  uint64_t v5 = *a1 + 1;
  do
  {
    *a1 = v5;
    unsigned int v6 = *v5++;
  }
  while ((*(_DWORD *)(v2 + 4 * v6 + 60) & 0x400) != 0);
  unint64_t v7 = 0;
  __int16 v8 = a1[6];
  uint64_t v9 = v5 - 2;
  while (v9 != v8)
  {
    uint64_t v10 = (char)*++v8;
    BOOL v11 = v10 + 10 * v7 - 48 >= v7;
    unint64_t v7 = v10 + 10 * v7 - 48;
    if (!v11)
    {
      v13[0] = "constant bigger than 64 bits detected!";
      __int16 v14 = 259;
      sub_1CD4D7520((uint64_t)a1, (llvm::Twine *)v13);
      LODWORD(v7) = 0;
      goto LABEL_11;
    }
  }
  if (HIDWORD(v7))
  {
    v13[0] = "invalid value number (too large)!";
    __int16 v14 = 259;
    sub_1CD4D7520((uint64_t)a1, (llvm::Twine *)v13);
  }
LABEL_11:
  *((_DWORD *)a1 + 22) = v7;
  return v3;
}

uint64_t llvm::LLLexer::Lex0x(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(this + 48);
  *(void *)this = v2 + 2;
  unsigned int v3 = *(unsigned __int8 *)(v2 + 2);
  if (v3 - 75 < 3 || v3 == 82 || v3 == 72)
  {
    *(void *)this = v2 + 3;
    int v4 = *(char *)(v2 + 2);
    unsigned int v3 = *(unsigned __int8 *)(v2 + 3);
    uint64_t v5 = 3;
  }
  else
  {
    int v4 = 74;
    uint64_t v5 = 2;
  }
  uint64_t v6 = MEMORY[0x1E4F14390];
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v3 + 60) & 0x10000) != 0)
  {
    do
    {
      uint64_t v7 = v5++;
      __int16 v8 = (unsigned __int8 *)(v2 + v7 + 1);
      *(void *)this = v8;
    }
    while ((*(_DWORD *)(v6 + 4 * *v8 + 60) & 0x10000) != 0);
    if (v4 == 74)
    {
      if (v5 != 2)
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        while (1)
        {
          unint64_t v9 = 16 * v16 + word_1CFAC4A4C[*(unsigned __int8 *)(v2 + 2 + v15)];
          if (v9 < v16) {
            break;
          }
          ++v15;
          unint64_t v16 = v9;
          if (v7 - 1 == v15) {
            goto LABEL_9;
          }
        }
        uint64_t v29 = "constant bigger than 64 bits detected!";
        __int16 v31 = 259;
        sub_1CD4D7520(this, (llvm::Twine *)&v29);
      }
      unint64_t v9 = 0;
LABEL_9:
      unsigned int v28 = 64;
      unint64_t v27 = v9;
      llvm::detail::IEEEFloat::initFromDoubleAPInt((llvm::detail::IEEEFloat *)v30, (const llvm::APInt **)&v27);
      sub_1CB9190C0((uint64_t *)(v1 + 112), v30);
      sub_1CB87DEE4((uint64_t *)v30);
    }
    else
    {
      uint64_t v10 = (const char *)(v2 + v5);
      switch(v4)
      {
        case 'I':
        case 'J':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
          __break(1u);
          return this;
        case 'K':
          uint64_t v24 = (llvm::APFloatBase *)llvm::LLLexer::FP80HexToIntPair(this, (const char *)(v2 + 3), v10, &v27);
          uint64_t v22 = llvm::APFloatBase::x87DoubleExtended(v24);
          int v23 = 80;
          goto LABEL_36;
        case 'L':
          BOOL v21 = (llvm::APFloatBase *)llvm::LLLexer::HexToIntPair(this, (const char *)(v2 + 3), v10, &v27);
          uint64_t v22 = llvm::APFloatBase::IEEEquad(v21);
          int v23 = 128;
LABEL_36:
          llvm::APInt::APInt((uint64_t)&v25, v23, (uint64_t *)&v27);
          sub_1CB919070((llvm::detail::IEEEFloat *)v30, v22, &v25);
          sub_1CB9190C0((uint64_t *)(v1 + 112), v30);
          goto LABEL_37;
        case 'M':
          llvm::LLLexer::HexToIntPair(this, (const char *)(v2 + 3), v10, &v27);
          llvm::APInt::APInt((uint64_t)&v25, 128, (uint64_t *)&v27);
          llvm::detail::DoubleAPFloat::DoubleAPFloat(v30, &unk_1CFB2E344, &v25);
          sub_1CB9190C0((uint64_t *)(v1 + 112), v30);
LABEL_37:
          sub_1CB87DEE4((uint64_t *)v30);
          if (v26 < 0x41) {
            return 456;
          }
          uint64_t v18 = v25;
          if (!v25) {
            return 456;
          }
          goto LABEL_28;
        case 'R':
          BOOL v11 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)this);
          if (v5 == 3) {
            goto LABEL_25;
          }
          uint64_t v19 = 0;
          unint64_t v20 = 0;
          while (1)
          {
            unint64_t v14 = 16 * v20 + word_1CFAC4A4C[*(unsigned __int8 *)(v2 + 3 + v19)];
            if (v14 < v20) {
              goto LABEL_41;
            }
            ++v19;
            unint64_t v20 = v14;
            if (v7 - 2 == v19) {
              goto LABEL_32;
            }
          }
        default:
          BOOL v11 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)this);
          if (v5 == 3) {
            goto LABEL_25;
          }
          uint64_t v12 = 0;
          unint64_t v13 = 0;
          break;
      }
      while (1)
      {
        unint64_t v14 = 16 * v13 + word_1CFAC4A4C[*(unsigned __int8 *)(v2 + 3 + v12)];
        if (v14 < v13) {
          break;
        }
        ++v12;
        unint64_t v13 = v14;
        if (v7 - 2 == v12)
        {
LABEL_32:
          unint64_t v17 = (unsigned __int16)v14;
          goto LABEL_26;
        }
      }
LABEL_41:
      uint64_t v29 = "constant bigger than 64 bits detected!";
      __int16 v31 = 259;
      sub_1CD4D7520(v1, (llvm::Twine *)&v29);
LABEL_25:
      unint64_t v17 = 0;
LABEL_26:
      unsigned int v28 = 16;
      unint64_t v27 = v17;
      sub_1CB919070((llvm::detail::IEEEFloat *)v30, v11, (const llvm::APInt **)&v27);
      sub_1CB9190C0((uint64_t *)(v1 + 112), v30);
      sub_1CB87DEE4((uint64_t *)v30);
      if (v28 >= 0x41)
      {
        uint64_t v18 = (const llvm::APInt *)v27;
        if (v27) {
LABEL_28:
        }
          MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
      }
    }
    return 456;
  }
  else
  {
    *(void *)this = v2 + 1;
    return 1;
  }
}

uint64_t sub_1CD4D8320(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      unsigned int v5 = *(_DWORD *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v15 = *(void *)a1;
        if (v5)
        {
          sub_1CC1924A0((uint64_t)v4, (uint64_t)&v4[40 * v5], v15);
          uint64_t v17 = v16;
          uint64_t v15 = *(void *)a1;
          LODWORD(v6) = *(_DWORD *)(a1 + 8);
        }
        else
        {
          uint64_t v17 = *(void *)a1;
        }
        for (uint64_t i = v15 + 40 * v6; i != v17; i -= 40)
        {
          if (*(char *)(i - 1) < 0) {
            operator delete(*(void **)(i - 24));
          }
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v19 = *(unsigned int *)(a2 + 8);
        if (v19)
        {
          unint64_t v20 = *(char **)a2;
          uint64_t v21 = 40 * v19;
          do
          {
            if (v20[v21 - 1] < 0) {
              operator delete(*(void **)&v20[v21 - 24]);
            }
            v21 -= 40;
          }
          while (v21);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            uint64_t v23 = *(void *)a1;
            uint64_t v24 = 40 * v6;
            do
            {
              if (*(char *)(v23 + v24 - 1) < 0) {
                operator delete(*(void **)(v23 + v24 - 24));
              }
              v24 -= 40;
            }
            while (v24);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD4D8598();
        }
        if (v6) {
          sub_1CC1924A0((uint64_t)v4, (uint64_t)&v4[40 * v6], *(void *)a1);
        }
        else {
          uint64_t v6 = 0;
        }
        uint64_t v7 = *(char **)a2;
        uint64_t v8 = *(unsigned int *)(a2 + 8);
        if (v6 != v8)
        {
          unint64_t v9 = &v7[40 * v8];
          uint64_t v10 = *(void *)a1 + 40 * v6;
          BOOL v11 = &v7[40 * v6];
          do
          {
            *(_OWORD *)uint64_t v10 = *(_OWORD *)v11;
            long long v12 = *((_OWORD *)v11 + 1);
            *(void *)(v10 + 32) = *((void *)v11 + 4);
            *(_OWORD *)(v10 + 16) = v12;
            *((void *)v11 + 3) = 0;
            *((void *)v11 + 4) = 0;
            *((void *)v11 + 2) = 0;
            v11 += 40;
            v10 += 40;
          }
          while (v11 != v9);
          uint64_t v7 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v13 = *(unsigned int *)(a2 + 8);
        if (v13)
        {
          uint64_t v14 = 40 * v13;
          do
          {
            if (v7[v14 - 1] < 0) {
              operator delete(*(void **)&v7[v14 - 24]);
            }
            v14 -= 40;
          }
          while (v14);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CD4D850C((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CD4D850C(char **a1, char **a2)
{
  int v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 40 * v5;
    do
    {
      if (v4[v6 - 1] < 0) {
        operator delete(*(void **)&v4[v6 - 24]);
      }
      v6 -= 40;
    }
    while (v6);
    int v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

void sub_1CD4D8598()
{
}

void sub_1CD4D8608(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *a1 + 40 * v2;
    do
    {
      *(_OWORD *)a2 = *(_OWORD *)v3;
      long long v5 = *(_OWORD *)(v3 + 16);
      *(void *)(a2 + 32) = *(void *)(v3 + 32);
      *(_OWORD *)(a2 + 16) = v5;
      *(void *)(v3 + 24) = 0;
      *(void *)(v3 + 32) = 0;
      *(void *)(v3 + 16) = 0;
      v3 += 40;
      a2 += 40;
    }
    while (v3 != v4);
    uint64_t v6 = *((unsigned int *)a1 + 2);
    if (v6)
    {
      uint64_t v7 = *a1;
      uint64_t v8 = 40 * v6;
      do
      {
        if (*(char *)(v7 + v8 - 1) < 0) {
          operator delete(*(void **)(v7 + v8 - 24));
        }
        v8 -= 40;
      }
      while (v8);
    }
  }
}

uint64_t llvm::LLParser::Run(uint64_t a1, llvm::MDNode *a2, void (*a3)(void **__return_ptr, uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  if ((llvm::LLVMContext::hasSetOpaquePointersValue(*(llvm::LLVMContextImpl ***)a1) & 1) == 0)
  {
    while (1)
    {
      unsigned int v10 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 8));
      *(_DWORD *)(a1 + 64) = v10;
      if (v10 <= 5 && ((1 << v10) & 0x23) != 0) {
        break;
      }
      uint64_t v12 = *(void *)(a1 + 104);
      if (v12)
      {
        if (*(unsigned char *)(v12 + 8) == 15) {
          break;
        }
      }
    }
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if (*(unsigned char *)(**(void **)a1 + 2664))
  {
    uint64_t v13 = *(char **)(a1 + 216);
    __p[0] = "Can't read textual IR with a Context that discards named Values";
    __int16 v27 = 259;
    return llvm::LLLexer::Error(a1 + 168, v13, (llvm::Twine *)__p);
  }
  if (!*(void *)(a1 + 328)) {
    goto LABEL_4;
  }
  if ((llvm::LLParser::parseTargetDefinitions((llvm::LLParser *)a1) & 1) == 0)
  {
    uint64_t v14 = *(void *)(a1 + 328);
    uint64_t v17 = *(void *)(v14 + 216);
    uint64_t v15 = v14 + 216;
    uint64_t v16 = v17;
    char v18 = *(unsigned char *)(v15 + 23);
    if (v18 >= 0) {
      uint64_t v19 = v15;
    }
    else {
      uint64_t v19 = v16;
    }
    uint64_t v20 = *(void *)(v15 + 8);
    if (v18 >= 0) {
      uint64_t v21 = v18 & 0x7F;
    }
    else {
      uint64_t v21 = v20;
    }
    a3(__p, a4, v19, v21);
    if (v26)
    {
      if (v25 >= 0) {
        uint64_t v22 = __p;
      }
      else {
        uint64_t v22 = (void **)__p[0];
      }
      if (v25 >= 0) {
        unint64_t v23 = v25 & 0x7F;
      }
      else {
        unint64_t v23 = (unint64_t)__p[1];
      }
      llvm::Module::setDataLayout(*(void *)(a1 + 328), v22, v23);
      if (v26 && v25 < 0) {
        operator delete(__p[0]);
      }
    }
LABEL_4:
    if ((llvm::LLParser::parseTopLevelEntities((llvm::LLParser *)a1) & 1) == 0
      && (llvm::LLParser::validateEndOfModule((llvm::LLParser *)a1, a2, v8) & 1) == 0)
    {
      return llvm::LLParser::validateEndOfIndex((llvm::LLParser *)a1);
    }
  }
  return 1;
}

uint64_t llvm::LLParser::parseTargetDefinitions(llvm::LLParser *this)
{
  while (1)
  {
    while (1)
    {
      int v2 = *((_DWORD *)this + 56);
      if (v2 != 64) {
        break;
      }
      if (llvm::LLParser::parseSourceFileName(this)) {
        return 1;
      }
    }
    if (v2 != 62) {
      break;
    }
    if (llvm::LLParser::parseTargetDefinition(this)) {
      return 1;
    }
  }
  return 0;
}

uint64_t llvm::LLParser::parseTopLevelEntities(llvm::LLParser *this)
{
  if (*((void *)this + 41))
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            int v2 = *((_DWORD *)this + 56);
            if (v2 <= 348) {
              break;
            }
            switch(v2)
            {
              case 433:
                if (llvm::LLParser::parseUnnamedGlobal(this)) {
                  return 1;
                }
                continue;
              case 434:
                if (llvm::LLParser::parseUnnamedType(this)) {
                  return 1;
                }
                continue;
              case 435:
              case 437:
                goto LABEL_51;
              case 436:
                if (llvm::LLParser::parseSummaryEntry(this)) {
                  return 1;
                }
                continue;
              case 438:
                if (llvm::LLParser::parseNamedGlobal(this)) {
                  return 1;
                }
                continue;
              case 439:
                if (llvm::LLParser::parseComdat(this)) {
                  return 1;
                }
                continue;
              case 440:
                if (llvm::LLParser::parseNamedType(this)) {
                  return 1;
                }
                continue;
              case 441:
                if (llvm::LLParser::parseNamedMetadata(this)) {
                  return 1;
                }
                continue;
              default:
                if (v2 == 349)
                {
                  if (llvm::LLParser::parseUseListOrder(this, 0)) {
                    return 1;
                  }
                }
                else
                {
                  if (v2 != 350) {
                    goto LABEL_51;
                  }
                  if (llvm::LLParser::parseUseListOrderBB(this)) {
                    return 1;
                  }
                }
                break;
            }
          }
          if (v2 <= 21) {
            break;
          }
          switch(v2)
          {
            case 22:
              if (llvm::LLParser::parseDefine(this)) {
                return 1;
              }
              break;
            case 96:
              if (llvm::LLParser::parseModuleAsm(this)) {
                return 1;
              }
              break;
            case 162:
              if (llvm::LLParser::parseUnnamedAttrGrp(this)) {
                return 1;
              }
              break;
            default:
              goto LABEL_51;
          }
        }
        if (v2 != 14) {
          break;
        }
        if (llvm::LLParser::parseStandaloneMetadata(this)) {
          return 1;
        }
      }
      if (v2 != 21) {
        break;
      }
      if (llvm::LLParser::parseDeclare(this)) {
        return 1;
      }
    }
    if (v2)
    {
LABEL_51:
      long long v5 = "expected top-level entity";
      __int16 v6 = 259;
      return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v5);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    do
    {
      while (1)
      {
        while (1)
        {
          int v4 = *((_DWORD *)this + 56);
          if (v4 != 64) {
            break;
          }
          if (llvm::LLParser::parseSourceFileName(this)) {
            return 1;
          }
        }
        if (v4 == 436) {
          break;
        }
        if (!v4) {
          return 0;
        }
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      }
    }
    while ((llvm::LLParser::parseSummaryEntry(this) & 1) == 0);
    return 1;
  }
}

uint64_t llvm::LLParser::validateEndOfModule(llvm::LLParser *this, llvm::MDNode *a2, const llvm::APFloat *a3)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 41)) {
    return 0;
  }
  char v92 = (char)a2;
  long long v5 = (char *)*((void *)this + 139);
  __int16 v6 = (char *)this + 1120;
  if (v5 != (char *)this + 1120)
  {
    uint64_t v7 = (char **)((char *)this + 1144);
    do
    {
      uint64_t v105 = *(void ***)this;
      v106 = &v108;
      uint64_t v107 = 0x800000000;
      uint64_t v8 = *((void *)v5 + 4);
      unint64_t v9 = (unsigned int *)*((void *)v5 + 5);
      unsigned int v10 = (unsigned int *)*((void *)v5 + 6);
      while (v9 != v10)
      {
        BOOL v11 = *v7;
        if (*v7)
        {
          unsigned int v12 = *v9;
          uint64_t v13 = (char **)((char *)this + 1144);
          do
          {
            unsigned int v14 = *((_DWORD *)v11 + 8);
            BOOL v15 = v14 >= v12;
            if (v14 >= v12) {
              uint64_t v16 = (char **)v11;
            }
            else {
              uint64_t v16 = (char **)(v11 + 8);
            }
            if (v15) {
              uint64_t v13 = (char **)v11;
            }
            BOOL v11 = *v16;
          }
          while (*v16);
          if (v13 != v7 && v12 >= *((_DWORD *)v13 + 8)) {
            llvm::AttrBuilder::merge((uint64_t)&v105, (const llvm::AttrBuilder *)(v13 + 5));
          }
        }
        ++v9;
      }
      int v17 = *(unsigned __int8 *)(v8 + 16);
      if (*(unsigned char *)(v8 + 16)) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v8 == 0;
      }
      if (v18)
      {
        BOOL v19 = v17 != 84 || v8 == 0;
        if (v19 && (v17 == 33 ? (BOOL v20 = v8 == 0) : (BOOL v20 = 1), v20 && (v17 == 39 ? (v21 = v8 == 0) : (v21 = 1), v21)))
        {
          if (v17 == 3) {
            uint64_t v22 = v8;
          }
          else {
            uint64_t v22 = 0;
          }
          llvm::AttrBuilder::AttrBuilder(__p, **((void **)this + 41), *(char **)(v22 + 72));
          llvm::AttrBuilder::merge((uint64_t)__p, (const llvm::AttrBuilder *)&v105);
          *(void *)(v22 + 72) = llvm::AttributeSet::get(*(llvm::AttributeSet **)this, (uint64_t **)__p, v23);
        }
        else
        {
          v99.__r_.__value_.__r.__words[0] = *(void *)(v8 + 64);
          uint64_t v31 = **((void **)this + 41);
          FnAttrs = (char *)llvm::AttributeList::getFnAttrs((llvm::AttributeList *)&v99);
          llvm::AttrBuilder::AttrBuilder(__p, v31, FnAttrs);
          v99.__r_.__value_.__r.__words[0] = llvm::AttributeList::removeAttributesAtIndex((llvm::AttributeList *)&v99, *(llvm::LLVMContext **)this, -1);
          llvm::AttrBuilder::merge((uint64_t)__p, (const llvm::AttrBuilder *)&v105);
          v99.__r_.__value_.__r.__words[0] = llvm::AttributeList::addAttributesAtIndex((llvm::AttributeList *)&v99, *(llvm::LLVMContext **)this, -1, (const llvm::AttrBuilder *)__p);
          *(void *)(v8 + 64) = v99.__r_.__value_.__r.__words[0];
        }
      }
      else
      {
        v99.__r_.__value_.__r.__words[0] = *(void *)(v8 + 112);
        uint64_t v24 = **((void **)this + 41);
        char v25 = (char *)llvm::AttributeList::getFnAttrs((llvm::AttributeList *)&v99);
        llvm::AttrBuilder::AttrBuilder(__p, v24, v25);
        v99.__r_.__value_.__r.__words[0] = llvm::AttributeList::removeAttributesAtIndex((llvm::AttributeList *)&v99, *(llvm::LLVMContext **)this, -1);
        llvm::AttrBuilder::merge((uint64_t)__p, (const llvm::AttrBuilder *)&v105);
        if (llvm::AttrBuilder::hasAlignmentAttr((llvm::AttrBuilder *)__p))
        {
          unint64_t RawIntAttr = llvm::AttrBuilder::getRawIntAttr((uint64_t)__p, 74);
          unint64_t v28 = __clz(RawIntAttr) ^ 0x13F;
          if (!RawIntAttr) {
            unint64_t v28 = 0;
          }
          unint64_t v3 = v28 | v3 & 0xFFFFFFFFFFFF0000;
          llvm::GlobalObject::setAlignment(v8, v3);
          llvm::AttrBuilder::removeAttribute((uint64_t)__p, 74);
        }
        v99.__r_.__value_.__r.__words[0] = llvm::AttributeList::addAttributesAtIndex((llvm::AttributeList *)&v99, *(llvm::LLVMContext **)this, -1, (const llvm::AttrBuilder *)__p);
        *(void *)(v8 + 112) = v99.__r_.__value_.__r.__words[0];
      }
      if (__p[1] != &v103) {
        free(__p[1]);
      }
      if (v106 != &v108) {
        free(v106);
      }
      uint64_t v29 = (char *)*((void *)v5 + 1);
      if (v29)
      {
        do
        {
          uint64_t v30 = v29;
          uint64_t v29 = *(char **)v29;
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v30 = (char *)*((void *)v5 + 2);
          BOOL v18 = *(void *)v30 == (void)v5;
          long long v5 = v30;
        }
        while (!v18);
      }
      long long v5 = v30;
    }
    while (v30 != v6);
  }
  if (*((void *)this + 137))
  {
    uint64_t v69 = *(char **)(*((void *)this + 135) + 40);
    uint64_t v105 = (void **)"expected function name in blockaddress";
    __int16 v109 = 259;
    unsigned int v70 = (char *)this + 168;
    return llvm::LLLexer::Error((uint64_t)v70, v69, (llvm::Twine *)&v105);
  }
  uint64_t v33 = (char *)*((void *)this + 114);
  uint64_t v34 = (char *)this + 920;
  if (v33 != (char *)this + 920)
  {
    while (1)
    {
      uint64_t v35 = (char *)*((void *)v33 + 6);
      if (v35) {
        break;
      }
      uint64_t v36 = (char *)*((void *)v33 + 1);
      if (v36)
      {
        do
        {
          uint64_t v37 = v36;
          uint64_t v36 = *(char **)v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          uint64_t v37 = (char *)*((void *)v33 + 2);
          BOOL v18 = *(void *)v37 == (void)v33;
          uint64_t v33 = v37;
        }
        while (!v18);
      }
      uint64_t v33 = v37;
      if (v37 == v34) {
        goto LABEL_69;
      }
    }
    v99.__r_.__value_.__r.__words[0] = (std::string::size_type)"use of undefined type '%";
    __int16 v100 = 259;
    int v81 = *((_DWORD *)v33 + 8);
    __int16 v98 = 264;
    LODWORD(v97[0]) = v81;
    sub_1CB8F1E58((uint64_t *)&v99, v97, (uint64_t)__p);
    v95[0] = (uint64_t)"'";
    __int16 v96 = 259;
    long long v82 = (std::string *)v95;
    goto LABEL_153;
  }
LABEL_69:
  uint64_t v38 = *((unsigned int *)this + 222);
  if (v38)
  {
    for (uint64_t i = (uint64_t **)*((void *)this + 110); !*i || *i + 1 == 0; ++i)
      ;
  }
  else
  {
    uint64_t i = (uint64_t **)*((void *)this + 110);
  }
  uint64_t v41 = *((void *)this + 110) + 8 * v38;
  if (i != (uint64_t **)v41)
  {
    unsigned int v42 = *i;
    while (1)
    {
      uint64_t v35 = (char *)v42[2];
      if (v35) {
        break;
      }
      do
      {
        uint64_t v43 = i[1];
        ++i;
        unsigned int v42 = v43;
        if (v43) {
          BOOL v44 = v42 + 1 == 0;
        }
        else {
          BOOL v44 = 1;
        }
      }
      while (v44);
      if (i == (uint64_t **)v41) {
        goto LABEL_86;
      }
    }
    uint64_t v83 = *v42;
    __int16 v104 = 1283;
    __p[0] = "use of undefined type named '";
    uint64_t v102 = v42 + 3;
    uint64_t v103 = v83;
    v99.__r_.__value_.__r.__words[0] = (std::string::size_type)"'";
    __int16 v100 = 259;
    long long v82 = &v99;
LABEL_153:
    sub_1CB8F1E58((uint64_t *)__p, (uint64_t *)v82, (uint64_t)&v105);
    unsigned int v70 = (char *)this + 168;
    uint64_t v69 = v35;
    return llvm::LLLexer::Error((uint64_t)v70, v69, (llvm::Twine *)&v105);
  }
LABEL_86:
  if (*((void *)this + 134))
  {
    uint64_t v71 = *(char **)(*((void *)this + 132) + 56);
  }
  else
  {
    if (!*((void *)this + 125))
    {
      if (*((void *)this + 128))
      {
        uint64_t v74 = *((void *)this + 126);
        uint64_t v75 = *(char **)(v74 + 48);
        uint64_t v76 = "use of undefined value '@";
      }
      else
      {
        if (!*((void *)this + 122))
        {
          uint64_t v45 = (llvm::LLParser *)*((void *)this + 117);
          if (v45 != (llvm::LLParser *)((char *)this + 944))
          {
            do
            {
              uint64_t v46 = *((void *)v45 + 5);
              if (v46 && ((*(unsigned char *)(v46 + 1) & 0x7F) == 2 || *(_DWORD *)(v46 + 12))) {
                llvm::MDNode::resolveCycles(v46);
              }
              uint64_t v47 = (llvm::LLParser *)*((void *)v45 + 1);
              if (v47)
              {
                do
                {
                  long long v48 = v47;
                  uint64_t v47 = *(llvm::LLParser **)v47;
                }
                while (v47);
              }
              else
              {
                do
                {
                  long long v48 = (llvm::LLParser *)*((void *)v45 + 2);
                  BOOL v18 = *(void *)v48 == (void)v45;
                  uint64_t v45 = v48;
                }
                while (!v18);
              }
              uint64_t v45 = v48;
            }
            while (v48 != (llvm::LLParser *)((char *)this + 944));
          }
          uint64_t v49 = *((unsigned int *)this + 90);
          if (v49)
          {
            uint64_t v50 = (llvm::Instruction **)*((void *)this + 44);
            uint64_t v51 = 8 * v49;
            do
            {
              uint64_t v52 = *v50;
              if (*((void *)*v50 + 6) || (*((unsigned char *)v52 + 23) & 0x20) != 0) {
                uint64_t MetadataImpl = (llvm *)llvm::Instruction::getMetadataImpl(*v50, 1);
              }
              else {
                uint64_t MetadataImpl = 0;
              }
              uint64_t v54 = llvm::UpgradeTBAANode(MetadataImpl, a2, a3);
              if (MetadataImpl != v54) {
                llvm::Instruction::setMetadata(v52, 1, v54);
              }
              ++v50;
              v51 -= 8;
            }
            while (v51);
          }
          uint64_t v55 = *((void *)this + 41);
          uint64_t v56 = v55 + 24;
          uint64_t v57 = *(void *)(v55 + 32);
          if (v57 == v55 + 24)
          {
            char v58 = v92;
          }
          else
          {
            char v58 = v92;
            do
            {
              uint64_t v59 = *(void *)(v57 + 8);
              if (v57) {
                int v60 = (llvm *)(v57 - 56);
              }
              else {
                int v60 = 0;
              }
              llvm::UpgradeCallsToIntrinsic(v60, a2, (llvm::Function **)a3);
              uint64_t v57 = v59;
            }
            while (v59 != v56);
            uint64_t v55 = *((void *)this + 41);
            uint64_t v57 = *(void *)(v55 + 32);
          }
          uint64_t v61 = v55 + 24;
          if (v57 != v55 + 24)
          {
            do
            {
              uint64_t v62 = *(void *)(v57 + 8);
              if (v57) {
                uint64_t v63 = (llvm::Intrinsic *)(v57 - 56);
              }
              else {
                uint64_t v63 = 0;
              }
              int v64 = llvm::Intrinsic::remangleIntrinsicFunction(v63, a2);
              if ((_BYTE)a2)
              {
                llvm::Value::doRAUW(v63, v64, (llvm::Value *)1);
                llvm::Function::eraseFromParent(v63);
              }
              uint64_t v57 = v62;
            }
            while (v62 != v61);
            uint64_t v55 = *((void *)this + 41);
          }
          if (v58)
          {
            llvm::UpgradeDebugInfo((llvm **)v55, a2);
            uint64_t v55 = *((void *)this + 41);
          }
          llvm::UpgradeModuleFlags((llvm *)v55, a2);
          llvm::UpgradeSectionAttributes(*((llvm **)this + 41), v65);
          uint64_t v66 = *((void *)this + 43);
          if (v66)
          {
            sub_1CD46D2D8(v66, (__n128 *)((char *)this + 1032));
            sub_1CD4F3AD8(*((void *)this + 43) + 24, (void *)this + 117);
            uint64_t v78 = *((unsigned int *)this + 222);
            if (v78)
            {
              for (int j = (uint64_t *)*((void *)this + 110); !*j || *j == -8; ++j)
                ;
            }
            else
            {
              int j = (uint64_t *)*((void *)this + 110);
            }
            uint64_t v84 = *((void *)this + 110) + 8 * v78;
            if (j != (uint64_t *)v84)
            {
              uint64_t v85 = *j;
              do
              {
                uint64_t v86 = *((void *)this + 43) + 48;
                size_t v93 = *(void *)v85;
                size_t v94 = *(void *)(v85 + 8);
                sub_1CD4F3B44(v86, (unsigned __int8 *)(v85 + 24), v93, &v94);
                do
                {
                  uint64_t v87 = j[1];
                  ++j;
                  uint64_t v85 = v87;
                  if (v87) {
                    BOOL v88 = v85 == -8;
                  }
                  else {
                    BOOL v88 = 1;
                  }
                }
                while (v88);
              }
              while (j != (uint64_t *)v84);
            }
            uint64_t v89 = (char *)*((void *)this + 114);
            if (v89 != v34)
            {
              do
              {
                sub_1CD4F3C3C((uint64_t *)(*((void *)this + 43) + 80), *((_DWORD *)v89 + 8), *((_DWORD *)v89 + 8), *((void *)v89 + 5));
                v90 = (char *)*((void *)v89 + 1);
                if (v90)
                {
                  do
                  {
                    long long v91 = v90;
                    v90 = *(char **)v90;
                  }
                  while (v90);
                }
                else
                {
                  do
                  {
                    long long v91 = (char *)*((void *)v89 + 2);
                    BOOL v18 = *(void *)v91 == (void)v89;
                    uint64_t v89 = v91;
                  }
                  while (!v18);
                }
                uint64_t v67 = 0;
                uint64_t v89 = v91;
              }
              while (v91 != v34);
              return v67;
            }
          }
          return 0;
        }
        uint64_t v74 = *((void *)this + 120);
        uint64_t v75 = *(char **)(v74 + 48);
        uint64_t v76 = "use of undefined metadata '!";
      }
      v99.__r_.__value_.__r.__words[0] = (std::string::size_type)v76;
      __int16 v100 = 259;
      int v77 = *(_DWORD *)(v74 + 32);
      __int16 v98 = 264;
      LODWORD(v97[0]) = v77;
      sub_1CB8F1E58((uint64_t *)&v99, v97, (uint64_t)__p);
      v95[0] = (uint64_t)"'";
      __int16 v96 = 259;
      sub_1CB8F1E58((uint64_t *)__p, v95, (uint64_t)&v105);
      unsigned int v70 = (char *)this + 168;
      uint64_t v69 = v75;
      return llvm::LLLexer::Error((uint64_t)v70, v69, (llvm::Twine *)&v105);
    }
    uint64_t v71 = *(char **)(*((void *)this + 123) + 64);
  }
  std::operator+<char>();
  uint64_t v72 = std::string::append(&v99, "'");
  unint64_t v73 = (void *)v72->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
  uint64_t v102 = v73;
  v72->__r_.__value_.__l.__size_ = 0;
  v72->__r_.__value_.__r.__words[2] = 0;
  v72->__r_.__value_.__r.__words[0] = 0;
  __int16 v109 = 260;
  uint64_t v105 = __p;
  uint64_t v67 = llvm::LLLexer::Error((uint64_t)this + 168, v71, (llvm::Twine *)&v105);
  if (SHIBYTE(v102) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v99.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v99.__r_.__value_.__l.__data_);
  }
  return v67;
}

uint64_t llvm::LLParser::validateEndOfIndex(llvm::LLParser *this)
{
  if (!*((void *)this + 42)) {
    return 0;
  }
  if (*((void *)this + 147))
  {
    uint64_t v3 = *((void *)this + 145);
LABEL_9:
    int v4 = *(char **)(*(void *)(v3 + 40) + 8);
    long long v5 = "use of undefined summary '^";
LABEL_10:
    BOOL v11 = v5;
    __int16 v12 = 259;
    int v6 = *(_DWORD *)(v3 + 32);
    __int16 v10 = 264;
    LODWORD(v9[0]) = v6;
    sub_1CB8F1E58((uint64_t *)&v11, v9, (uint64_t)v13);
    uint64_t v7 = "'";
    __int16 v8 = 259;
    sub_1CB8F1E58(v13, (uint64_t *)&v7, (uint64_t)v14);
    return llvm::LLLexer::Error((uint64_t)this + 168, v4, (llvm::Twine *)v14);
  }
  if (*((void *)this + 150))
  {
    uint64_t v3 = *((void *)this + 148);
    goto LABEL_9;
  }
  if (*((void *)this + 156))
  {
    uint64_t v3 = *((void *)this + 154);
    int v4 = *(char **)(*(void *)(v3 + 40) + 8);
    long long v5 = "use of undefined type id summary '^";
    goto LABEL_10;
  }
  return 0;
}

uint64_t llvm::LLParser::parseStandaloneConstantValue(uint64_t a1, llvm::Constant **a2, uint64_t a3)
{
  llvm::LLParser::restoreParsingState(a1, a3);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  uint64_t v7 = 0;
  v8[0] = "expected type";
  __int16 v9 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v7, (const llvm::Twine *)v8, 0) & 1) != 0
    || (llvm::LLParser::parseConstantValue((llvm::LLParser *)a1, v7, a2) & 1) != 0)
  {
    return 1;
  }
  if (!*(_DWORD *)(a1 + 224)) {
    return 0;
  }
  int v6 = *(char **)(a1 + 216);
  v8[0] = "expected end of string";
  __int16 v9 = 259;
  return llvm::LLLexer::Error(a1 + 168, v6, (llvm::Twine *)v8);
}

void llvm::LLParser::restoreParsingState(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    int v4 = (void *)(a1 + 1032);
    if (v4 != (void *)a2) {
      sub_1CBFAFDE4(v4, *(char **)a2, *(char **)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
    }
    if (a1 + 936 != a2 + 24) {
      sub_1CD4F3590(a1 + 936, *(void **)(a2 + 24), (void *)(a2 + 32));
    }
    uint64_t v5 = *(unsigned int *)(a2 + 56);
    if (v5)
    {
      for (uint64_t i = *(size_t ***)(a2 + 48); ; ++i)
      {
        BOOL v7 = !*i || *i + 1 == 0;
        if (!v7) {
          break;
        }
      }
    }
    else
    {
      uint64_t i = *(size_t ***)(a2 + 48);
    }
    uint64_t v8 = *(void *)(a2 + 48) + 8 * v5;
    if (i != (size_t **)v8)
    {
      __int16 v9 = *i;
      do
      {
        __int16 v10 = (unsigned __int8 *)(v9 + 2);
        size_t v11 = *v9;
        size_t v12 = v9[1];
        uint64_t v24 = v10;
        size_t v25 = v11;
        long long v26 = v12;
        sub_1CD4F3918(a1 + 880, v10, v11, &v26);
        do
        {
          uint64_t v13 = i[1];
          ++i;
          __int16 v9 = v13;
          if (v13) {
            BOOL v14 = v9 + 1 == 0;
          }
          else {
            BOOL v14 = 1;
          }
        }
        while (v14);
      }
      while (i != (size_t **)v8);
    }
    BOOL v15 = *(void **)(a2 + 80);
    uint64_t v16 = (void *)(a2 + 88);
    if (v15 != v16)
    {
      int v17 = (uint64_t *)(a1 + 912);
      do
      {
        uint64_t v18 = v15[5];
        unsigned int v21 = *((_DWORD *)v15 + 8);
        uint64_t v22 = v18;
        uint64_t v23 = 0;
        sub_1CD4F3A14(v17, v21, (uint64_t)&v21);
        BOOL v19 = (void *)v15[1];
        if (v19)
        {
          do
          {
            BOOL v20 = v19;
            BOOL v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            BOOL v20 = (void *)v15[2];
            BOOL v7 = *v20 == (void)v15;
            BOOL v15 = v20;
          }
          while (!v7);
        }
        BOOL v15 = v20;
      }
      while (v20 != v16);
    }
  }
}

uint64_t llvm::LLParser::parseConstantValue(llvm::LLParser *this, llvm::Type *a2, llvm::Constant **a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  unsigned int v13 = 0;
  uint64_t v14 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v6 = 1;
  int v20 = 1;
  char v21 = 0;
  sub_1CB892E1C((uint64_t)v22, 0.0);
  v22[5] = 0;
  char v23 = 0;
  BOOL v7 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v13, 0, 0)) {
    goto LABEL_2;
  }
  if (v13 > 0xF)
  {
LABEL_9:
    v11[0] = "expected a constant value";
    __int16 v12 = 259;
    uint64_t v6 = llvm::LLLexer::Error((uint64_t)this + 168, v7, (llvm::Twine *)v11);
    goto LABEL_2;
  }
  if (((1 << v13) & 0xD0B0) == 0)
  {
    if (v13 == 6)
    {
      uint64_t v6 = 0;
      *a3 = llvm::Constant::getNullValue(a2, v8, v9);
      goto LABEL_2;
    }
    goto LABEL_9;
  }
  v11[0] = 0;
  uint64_t v6 = llvm::LLParser::convertValIDToValue((llvm::ConstantInt **)this, (uint64_t)a2, (int *)&v13, v11, 0);
  if ((v6 & 1) == 0) {
    *a3 = (llvm::Constant *)v11[0];
  }
LABEL_2:
  sub_1CD4F271C((uint64_t)&v13);
  return v6;
}

uint64_t llvm::LLParser::parseTargetDefinition(llvm::LLParser *this)
{
  memset(&__p, 0, sizeof(__p));
  int v2 = (llvm::LLParser *)((char *)this + 168);
  int v3 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v3;
  if (v3 == 63)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
    if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after target triple") & 1) == 0
      && (llvm::LLParser::parseStringConstant((uint64_t)this, &__p) & 1) == 0)
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t size = __p.__r_.__value_.__l.__size_;
      }
      sub_1CBF4BD94(*((void *)this + 41), p_p, size);
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v6 = 1;
    goto LABEL_14;
  }
  if (v3 != 67)
  {
    __int16 v10 = "unknown target property";
    __int16 v11 = 259;
    uint64_t v6 = llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v10);
    goto LABEL_14;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after target datalayout") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, &__p) & 1) != 0)
  {
    goto LABEL_13;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v4 = &__p;
  }
  else {
    int v4 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v5 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    unint64_t v5 = __p.__r_.__value_.__l.__size_;
  }
  llvm::Module::setDataLayout(*((void *)this + 41), v4, v5);
LABEL_26:
  uint64_t v6 = 0;
LABEL_14:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v6;
}

uint64_t llvm::LLParser::parseSourceFileName(llvm::LLParser *this)
{
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after source_filename") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, (std::string *)((char *)this + 1288)) & 1) != 0)
  {
    return 1;
  }
  uint64_t result = *((void *)this + 41);
  if (result)
  {
    char v3 = *((unsigned char *)this + 1311);
    int v4 = v3;
    if (v3 >= 0) {
      unint64_t v5 = (char *)this + 1288;
    }
    else {
      unint64_t v5 = (char *)*((void *)this + 161);
    }
    size_t v6 = v3 & 0x7F;
    if (v4 >= 0) {
      size_t v7 = v6;
    }
    else {
      size_t v7 = *((void *)this + 162);
    }
    LLVMSetSourceFileName_0(result, v5, v7);
    return 0;
  }
  return result;
}

uint64_t llvm::LLParser::parseSummaryEntry(llvm::LLParser *this)
{
  int v2 = (char *)this + 168;
  unsigned int v3 = *((_DWORD *)this + 64);
  uint64_t v4 = 1;
  *((unsigned char *)this + 320) = 1;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here")) {
    return v4;
  }
  if (*((void *)this + 42))
  {
    int v6 = *((_DWORD *)this + 56);
    if (v6 == 402)
    {
      uint64_t v7 = llvm::LLParser::parseTypeIdCompatibleVtableEntry(this, v3);
LABEL_6:
      uint64_t v4 = v7;
      *((unsigned char *)this + 320) = 0;
      return v4;
    }
    if (v6 <= 356)
    {
      if (v6 == 96)
      {
        uint64_t v7 = llvm::LLParser::parseModuleEntry(this, v3);
        goto LABEL_6;
      }
      if (v6 == 353)
      {
        uint64_t v7 = llvm::LLParser::parseGVEntry(this, v3);
        goto LABEL_6;
      }
    }
    else
    {
      switch(v6)
      {
        case 357:
          uint64_t v7 = llvm::LLParser::parseSummaryIndexFlags(this);
          goto LABEL_6;
        case 358:
          uint64_t v7 = llvm::LLParser::parseBlockCount(this);
          goto LABEL_6;
        case 401:
          uint64_t v7 = llvm::LLParser::parseTypeIdEntry(this, v3);
          goto LABEL_6;
      }
    }
    uint64_t v8 = (char *)*((void *)this + 27);
    __int16 v9 = "unexpected summary kind";
    __int16 v10 = 259;
    uint64_t v7 = llvm::LLLexer::Error((uint64_t)v2, v8, (llvm::Twine *)&v9);
    goto LABEL_6;
  }

  return llvm::LLParser::skipModuleSummaryEntry(this);
}

uint64_t llvm::LLParser::parseDeclare(llvm::LLParser *this)
{
  int v2 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v2;
  std::string __p = 0;
  __int16 v12 = 0;
  unint64_t v13 = 0;
  if (v2 == 441)
  {
    unsigned int v3 = 0;
    while (1)
    {
      unsigned int v10 = 0;
      __int16 v9 = 0;
      if (llvm::LLParser::parseMetadataAttachment(this, &v10, &v9)) {
        break;
      }
      LODWORD(v8[0]) = v10;
      v8[1] = v9;
      if ((unint64_t)v3 >= v13) {
        unsigned int v3 = sub_1CC00319C(&__p, v8);
      }
      else {
        *v3++ = *(_OWORD *)v8;
      }
      __int16 v12 = v3;
      if (*((_DWORD *)this + 56) != 441) {
        goto LABEL_14;
      }
    }
    uint64_t v4 = 1;
  }
  else
  {
    unsigned int v3 = 0;
LABEL_14:
    v8[0] = 0;
    uint64_t v4 = llvm::LLParser::parseFunctionHeader(this, v8, 0);
    if ((v4 & 1) == 0)
    {
      int v6 = (llvm::MDNode **)__p;
      if (__p != v3)
      {
        uint64_t v7 = v8[0];
        do
        {
          llvm::Value::addMetadata(v7, *(_DWORD *)v6, v6[1]);
          v6 += 2;
        }
        while (v6 != (llvm::MDNode **)v3);
      }
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v4;
}

uint64_t llvm::LLParser::parseDefine(llvm::LLParser *this)
{
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  uint64_t v4 = 0;
  if (llvm::LLParser::parseFunctionHeader(this, &v4, 1)) {
    return 1;
  }
  unsigned int v3 = v4;
  while (*((_DWORD *)this + 56) == 441)
  {
    if (llvm::LLParser::parseGlobalObjectMetadataAttachment(this, v3)) {
      return 1;
    }
  }

  return llvm::LLParser::parseFunctionBody(this, v3);
}

uint64_t llvm::LLParser::parseModuleAsm(llvm::LLParser *this)
{
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  memset(&__p, 0, sizeof(__p));
  if ((llvm::LLParser::parseToken((uint64_t)this, 97, "expected 'module asm'") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, &__p) & 1) != 0)
  {
    uint64_t v2 = 1;
  }
  else
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    LLVMAppendModuleInlineAsm_0(*((void *)this + 41), (const std::string::value_type *)p_p, size);
    uint64_t v2 = 0;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v2;
}

uint64_t llvm::LLParser::parseUnnamedType(llvm::LLParser *this)
{
  uint64_t v2 = (char *)this + 168;
  unsigned int v3 = (char *)*((void *)this + 27);
  unsigned int v4 = *((_DWORD *)this + 64);
  unsigned int v14 = v4;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after name")) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 242, "expected 'type' after '='")) {
    return 1;
  }
  unint64_t v13 = 0;
  int v6 = (uint64_t **)((char *)this + 912);
  uint64_t v7 = sub_1CD4F3D04((uint64_t **)this + 114, v4, &v14);
  if (llvm::LLParser::parseStructDefinition((uint64_t)this, v3, "", 0, (uint64_t *)v7 + 5, &v13)) {
    return 1;
  }
  uint64_t v8 = v13;
  if (*((unsigned char *)v13 + 8) == 16) {
    return 0;
  }
  __int16 v9 = sub_1CD4F3D04(v6, v4, &v14);
  if (v9[5])
  {
    __int16 v11 = "non-struct types may not be recursive";
    __int16 v12 = 259;
    return llvm::LLLexer::Error((uint64_t)v2, v3, (llvm::Twine *)&v11);
  }
  else
  {
    unsigned int v10 = v9;
    uint64_t result = 0;
    v10[5] = (uint64_t *)v8;
    _OWORD v10[6] = 0;
  }
  return result;
}

uint64_t llvm::LLParser::parseNamedType(llvm::LLParser *this)
{
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  if (*((char *)this + 255) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *((const void **)this + 29), *((void *)this + 30));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)((char *)this + 232);
    uint64_t v19 = *((void *)this + 31);
  }
  unsigned int v3 = (char *)*((void *)this + 27);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after name") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 242, "expected 'type' after name") & 1) != 0
    || ((v17 = 0, v19 >= 0) ? (int v6 = (unsigned __int8 *)__p) : (int v6 = (unsigned __int8 *)__p[0]),
        v19 >= 0 ? (size_t v7 = HIBYTE(v19) & 0x7F) : (size_t v7 = (size_t)__p[1]),
        uint64_t v8 = (char *)this + 880,
        __int16 v9 = sub_1CD4F3DD4((uint64_t)this + 880, v6, v7),
        (llvm::LLParser::parseStructDefinition((uint64_t)this, v3, v6, v7, (uint64_t *)*v9 + 1, &v17) & 1) != 0))
  {
    uint64_t v4 = 1;
  }
  else
  {
    unsigned int v10 = v17;
    if (*((unsigned char *)v17 + 8) == 16)
    {
      uint64_t v4 = 0;
    }
    else
    {
      if (v19 >= 0) {
        __int16 v11 = (unsigned __int8 *)__p;
      }
      else {
        __int16 v11 = (unsigned __int8 *)__p[0];
      }
      if (v19 >= 0) {
        size_t v12 = HIBYTE(v19) & 0x7F;
      }
      else {
        size_t v12 = (size_t)__p[1];
      }
      unint64_t v13 = sub_1CD4F3DD4((uint64_t)v8, v11, v12);
      unsigned int v14 = *v13;
      if ((*v13)[1])
      {
        long long v15 = "non-struct types may not be recursive";
        __int16 v16 = 259;
        uint64_t v4 = llvm::LLLexer::Error((uint64_t)v2, v3, (llvm::Twine *)&v15);
      }
      else
      {
        uint64_t v4 = 0;
        v14[1] = (size_t)v10;
        v14[2] = 0;
      }
    }
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

uint64_t llvm::LLParser::parseUnnamedGlobal(llvm::LLParser *this)
{
  uint64_t v2 = *((void *)this + 130);
  uint64_t v3 = *((void *)this + 129);
  v21[0] = 0;
  v21[1] = 0;
  uint64_t v22 = 0;
  uint64_t v4 = (llvm::LLParser *)((char *)this + 168);
  unint64_t v5 = (char *)*((void *)this + 27);
  if (*((_DWORD *)this + 56) == 433)
  {
    unint64_t v6 = (unint64_t)(v2 - v3) >> 3;
    if (*((_DWORD *)this + 64) != v6)
    {
      *(void *)long long v17 = "variable expected to be numbered '%";
      __int16 v18 = 259;
      __int16 v16 = 264;
      v15[0] = v6;
      sub_1CB8F1E58((uint64_t *)v17, (uint64_t *)v15, (uint64_t)v19);
      *(void *)unint64_t v13 = "'";
      __int16 v14 = 259;
      sub_1CB8F1E58(v19, (uint64_t *)v13, (uint64_t)v20);
      return llvm::LLLexer::Error((uint64_t)v4, v5, (llvm::Twine *)v20);
    }
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if (llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after name")) {
      return 1;
    }
  }
  v13[0] = 0;
  v20[0] = 0;
  LODWORD(v19[0]) = 0;
  v17[0] = 0;
  BOOL v12 = 0;
  v15[0] = 0;
  if ((llvm::LLParser::parseOptionalLinkage(this, v20, v13, (unsigned int *)v19, v17, &v12) & 1) == 0
    && (llvm::LLParser::parseOptionalThreadLocal((uint64_t)this, v15) & 1) == 0)
  {
    int v9 = *((_DWORD *)this + 56);
    if (v9 == 41)
    {
      char v10 = 2;
    }
    else
    {
      if (v9 != 42)
      {
        char v10 = 0;
        goto LABEL_17;
      }
      char v10 = 1;
    }
    int v9 = llvm::LLLexer::LexToken(v4);
    *((_DWORD *)this + 56) = v9;
LABEL_17:
    if ((v9 & 0xFFFFFFFE) == 0x5E) {
      uint64_t v11 = llvm::LLParser::parseAliasOrIFunc((uint64_t)this, (uint64_t)v21, v5, v20[0], v19[0], v17[0], v12, v15[0], v10);
    }
    else {
      uint64_t v11 = llvm::LLParser::parseGlobal((uint64_t)this, (uint64_t)v21, v5, v20[0], v13[0], v19[0], v17[0], v12, v15[0], SBYTE1(v15[0]));
    }
    uint64_t v7 = v11;
    goto LABEL_7;
  }
  uint64_t v7 = 1;
LABEL_7:
  if (SHIBYTE(v22) < 0) {
    operator delete(v21[0]);
  }
  return v7;
}

uint64_t llvm::LLParser::parseNamedGlobal(llvm::LLParser *this)
{
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  uint64_t v3 = (char *)*((void *)this + 27);
  if (*((char *)this + 255) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *((const void **)this + 29), *((void *)this + 30));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)((char *)this + 232);
    uint64_t v15 = *((void *)this + 31);
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
  BOOL v13 = 0;
  unsigned int v12 = 0;
  *(void *)uint64_t v11 = 0;
  BOOL v10 = 0;
  int v9 = 0;
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' in global variable") & 1) == 0
    && (llvm::LLParser::parseOptionalLinkage(this, &v12, &v13, &v11[1], v11, &v10) & 1) == 0
    && (llvm::LLParser::parseOptionalThreadLocal((uint64_t)this, &v9) & 1) == 0)
  {
    int v6 = *((_DWORD *)this + 56);
    if (v6 == 41)
    {
      char v7 = 2;
    }
    else
    {
      if (v6 != 42)
      {
        char v7 = 0;
        goto LABEL_16;
      }
      char v7 = 1;
    }
    int v6 = llvm::LLLexer::LexToken(v2);
    *((_DWORD *)this + 56) = v6;
LABEL_16:
    if ((v6 & 0xFFFFFFFE) == 0x5E) {
      uint64_t v8 = llvm::LLParser::parseAliasOrIFunc((uint64_t)this, (uint64_t)__p, v3, v12, v11[1], v11[0], v10, v9, v7);
    }
    else {
      uint64_t v8 = llvm::LLParser::parseGlobal((uint64_t)this, (uint64_t)__p, v3, v12, v13, v11[1], v11[0], v10, v9, SBYTE1(v9));
    }
    uint64_t v4 = v8;
    goto LABEL_6;
  }
  uint64_t v4 = 1;
LABEL_6:
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

uint64_t llvm::LLParser::parseComdat(llvm::LLParser *this)
{
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  if (*((char *)this + 255) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *((const void **)this + 29), *((void *)this + 30));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)((char *)this + 232);
    uint64_t v29 = *((void *)this + 31);
  }
  uint64_t v3 = (char *)*((void *)this + 27);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
  if (llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here"))
  {
    uint64_t v4 = 1;
    goto LABEL_6;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 244, "expected comdat keyword"))
  {
    uint64_t v19 = "expected comdat type";
LABEL_32:
    v26[0] = v19;
    __int16 v27 = 259;
    uint64_t v4 = llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)v26);
    goto LABEL_6;
  }
  unsigned int v6 = *((_DWORD *)this + 56) - 245;
  if (v6 >= 5)
  {
    uint64_t v19 = "unknown selection kind";
    goto LABEL_32;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
  uint64_t v7 = *((void *)this + 41);
  if (v29 >= 0) {
    uint64_t v8 = (unsigned __int8 *)__p;
  }
  else {
    uint64_t v8 = (unsigned __int8 *)__p[0];
  }
  if (v29 >= 0) {
    size_t v9 = HIBYTE(v29) & 0x7F;
  }
  else {
    size_t v9 = (size_t)__p[1];
  }
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(v7 + 120), v8, v9);
  uint64_t v11 = *(void *)(v7 + 120);
  if (Key == -1)
  {
    uint64_t v13 = *(unsigned int *)(v7 + 128);
    uint64_t v12 = v13;
    goto LABEL_19;
  }
  uint64_t v12 = Key;
  uint64_t v13 = *(unsigned int *)(v7 + 128);
  if (Key == v13)
  {
LABEL_19:
    uint64_t v14 = *(void *)(v7 + 120);
LABEL_20:
    uint64_t v15 = (void *)(v11 + 8 * v12);
    if (v15 == (void *)(v14 + 8 * v13))
    {
      if (v29 >= 0) {
        long long v17 = (unsigned __int8 *)__p;
      }
      else {
        long long v17 = (unsigned __int8 *)__p[0];
      }
      if (v29 >= 0) {
        size_t v18 = HIBYTE(v29) & 0x7F;
      }
      else {
        size_t v18 = (size_t)__p[1];
      }
      inserted = llvm::Module::getOrInsertComdat(*((void *)this + 41), v17, v18);
    }
    else
    {
      inserted = (size_t *)(*v15 + 8);
    }
    uint64_t v4 = 0;
    *((_DWORD *)inserted + 2) = v6;
    goto LABEL_6;
  }
  int v20 = (llvm::LLParser *)sub_1CD4F3EC8((uint64_t)this + 1056, __p);
  if ((llvm::LLParser *)((char *)this + 1064) != v20)
  {
    sub_1CD4F3F94((uint64_t **)this + 132, (uint64_t)v20);
    uint64_t v14 = *(void *)(v7 + 120);
    uint64_t v13 = *(unsigned int *)(v7 + 128);
    goto LABEL_20;
  }
  std::operator+<char>();
  char v21 = std::string::append(&v23, "'");
  std::string::size_type v22 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)uint64_t v24 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  std::string::size_type v25 = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  __int16 v27 = 260;
  v26[0] = v24;
  uint64_t v4 = llvm::LLLexer::Error((uint64_t)v2, v3, (llvm::Twine *)v26);
  if (SHIBYTE(v25) < 0) {
    operator delete(v24[0]);
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
LABEL_6:
  if (SHIBYTE(v29) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

uint64_t llvm::LLParser::parseStandaloneMetadata(llvm::LLParser *this)
{
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  unsigned int v20 = 0;
  if ((llvm::LLParser::parseUInt32((char **)this, &v20) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here") & 1) != 0)
  {
    return 1;
  }
  int v4 = *((_DWORD *)this + 56);
  if (v4 == 455)
  {
    unint64_t v5 = "unexpected type in metadata definition";
    goto LABEL_6;
  }
  int v6 = *((_DWORD *)this + 56);
  if (v4 == 348)
  {
    int v6 = llvm::LLLexer::LexToken(v2);
    *((_DWORD *)this + 56) = v6;
  }
  uint64_t v19 = 0;
  if (v6 == 441)
  {
    if ((llvm::LLParser::parseSpecializedMDNode((char **)this, &v19, v4 == 348) & 1) == 0) {
      goto LABEL_11;
    }
    return 1;
  }
  if ((llvm::LLParser::parseToken((uint64_t)this, 14, "Expected '!' here") & 1) != 0
    || (llvm::LLParser::parseMDTuple(this, &v19, v4 == 348) & 1) != 0)
  {
    return 1;
  }
LABEL_11:
  uint64_t v7 = (char *)*((void *)this + 121);
  if (v7)
  {
    uint64_t v11 = (uint64_t *)((char *)this + 968);
    do
    {
      unsigned int v12 = *((_DWORD *)v7 + 8);
      BOOL v13 = v12 >= v20;
      if (v12 >= v20) {
        uint64_t v14 = (char **)v7;
      }
      else {
        uint64_t v14 = (char **)(v7 + 8);
      }
      if (v13) {
        uint64_t v11 = (uint64_t *)v7;
      }
      uint64_t v7 = *v14;
    }
    while (*v14);
    if (v11 != (uint64_t *)((char *)this + 968))
    {
      uint64_t v15 = v11;
      if (v20 >= *((_DWORD *)v11 + 8))
      {
        uint64_t v16 = *(void *)(v11[5] + 16);
        if ((v16 & 4) != 0) {
          llvm::ReplaceableMetadataImpl::replaceAllUsesWith((llvm::ReplaceableMetadataImpl *)(v16 & 0xFFFFFFFFFFFFFFF8), v19);
        }
        sub_1CD4F40AC((uint64_t **)this + 120, v15);
        return 0;
      }
    }
  }
  uint64_t v8 = (uint64_t *)*((void *)this + 118);
  if (!v8)
  {
LABEL_13:
    size_t v9 = sub_1CD4F3FDC((uint64_t **)this + 117, v20, &v20);
    sub_1CC19E068((unsigned __int8 **)v9 + 5, (unsigned __int8 *)v19);
    return 0;
  }
  while (1)
  {
    unsigned int v10 = *((_DWORD *)v8 + 8);
    if (v20 >= v10) {
      break;
    }
LABEL_18:
    uint64_t v8 = (uint64_t *)*v8;
    if (!v8) {
      goto LABEL_13;
    }
  }
  if (v10 < v20)
  {
    ++v8;
    goto LABEL_18;
  }
  unint64_t v5 = "Metadata id is already used";
LABEL_6:
  long long v17 = v5;
  __int16 v18 = 259;
  return llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v17);
}

uint64_t llvm::LLParser::parseNamedMetadata(llvm::LLParser *this)
{
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  uint64_t v3 = (void *)((char *)this + 232);
  if (*((char *)this + 255) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *((const void **)this + 29), *((void *)this + 30));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v15 = *((void *)this + 31);
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 14, "Expected '!' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 8, "Expected '{' here") & 1) != 0)
  {
LABEL_5:
    uint64_t v4 = 1;
    goto LABEL_6;
  }
  if (v15 >= 0) {
    int v6 = (unsigned __int8 *)__p;
  }
  else {
    int v6 = (unsigned __int8 *)__p[0];
  }
  if (v15 >= 0) {
    size_t v7 = HIBYTE(v15) & 0x7F;
  }
  else {
    size_t v7 = (size_t)__p[1];
  }
  inserted = (llvm::NamedMDNode *)llvm::Module::getOrInsertNamedMetadata(*((_DWORD **)this + 41), v6, v7);
  int v9 = *((_DWORD *)this + 56);
  if (v9 == 9)
  {
LABEL_28:
    uint64_t v10 = llvm::LLParser::parseToken((uint64_t)this, 9, "expected end of metadata node");
    goto LABEL_29;
  }
  while (1)
  {
    BOOL v13 = 0;
    if (v9 == 441)
    {
      if (sub_1CBA86C10(v3, "DIExpression"))
      {
        if (llvm::LLParser::parseDIExpression(this, &v13, 0)) {
          goto LABEL_5;
        }
        goto LABEL_26;
      }
      if (*((_DWORD *)this + 56) == 441 && sub_1CBA86C10(v3, "DIArgList")) {
        break;
      }
    }
    if ((llvm::LLParser::parseToken((uint64_t)this, 14, "Expected '!' here") & 1) != 0
      || llvm::LLParser::parseMDNodeID(this, &v13))
    {
      goto LABEL_5;
    }
LABEL_26:
    llvm::NamedMDNode::addOperand(inserted, v13);
    if (*((_DWORD *)this + 56) != 4) {
      goto LABEL_28;
    }
    int v9 = llvm::LLLexer::LexToken(v2);
    *((_DWORD *)this + 56) = v9;
  }
  uint64_t v11 = "found DIArgList outside of function";
  __int16 v12 = 259;
  uint64_t v10 = llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v11);
LABEL_29:
  uint64_t v4 = v10;
LABEL_6:
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

uint64_t llvm::LLParser::parseUnnamedAttrGrp(llvm::LLParser *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  uint64_t v3 = (char *)*((void *)this + 27);
  int v4 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v4;
  if (v4 == 435)
  {
    unsigned int v5 = *((_DWORD *)this + 64);
    memset(__p, 0, sizeof(__p));
    BOOL v13 = 0;
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v2);
    if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' here") & 1) != 0
      || (llvm::LLParser::parseToken((uint64_t)this, 8, "expected '{' here") & 1) != 0)
    {
      uint64_t v6 = 1;
    }
    else
    {
      uint64_t v8 = *((void *)this + 143);
      if (!v8) {
        goto LABEL_24;
      }
      int v9 = (uint64_t *)((char *)this + 1144);
      do
      {
        unsigned int v10 = *(_DWORD *)(v8 + 32);
        BOOL v11 = v10 >= v5;
        if (v10 >= v5) {
          __int16 v12 = (uint64_t *)v8;
        }
        else {
          __int16 v12 = (uint64_t *)(v8 + 8);
        }
        if (v11) {
          int v9 = (uint64_t *)v8;
        }
        uint64_t v8 = *v12;
      }
      while (*v12);
      if (v9 == (uint64_t *)((char *)this + 1144) || v5 < *((_DWORD *)v9 + 8))
      {
LABEL_24:
        uint64_t v15 = (const char *)**((void **)this + 41);
        uint64_t v16 = &v18;
        uint64_t v17 = 0x800000000;
        int v9 = sub_1CD4F41C4((uint64_t)this + 1136, v5, v5, (uint64_t)&v15);
        if (v16 != &v18) {
          free(v16);
        }
      }
      uint64_t v6 = 1;
      if ((llvm::LLParser::parseFnAttributeValuePairs((uint64_t)this, (uint64_t)(v9 + 5), (char **)__p, 1, &v13) & 1) == 0
        && (llvm::LLParser::parseToken((uint64_t)this, 9, "expected end of attribute group") & 1) == 0)
      {
        if (*((_DWORD *)v9 + 14))
        {
          uint64_t v6 = 0;
        }
        else
        {
          uint64_t v15 = "attribute group has no attributes";
          __int16 v19 = 259;
          uint64_t v6 = llvm::LLLexer::Error((uint64_t)v2, v3, (llvm::Twine *)&v15);
        }
      }
    }
    if (__p[0]) {
      operator delete(__p[0]);
    }
  }
  else
  {
    uint64_t v15 = "expected attribute group id";
    __int16 v19 = 259;
    return llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v15);
  }
  return v6;
}

uint64_t llvm::LLParser::parseUseListOrder(llvm::LLParser *this, llvm::LLParser::PerFunctionState *a2)
{
  unsigned char v10[8] = *MEMORY[0x1E4F143B8];
  int v4 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 349, "expected uselistorder directive")) {
    return 1;
  }
  size_t v7 = 0;
  uint64_t v8 = v10;
  *(void *)int v9 = 0x1000000000;
  if ((llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v7, a2) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected comma in uselistorder directive") & 1) != 0
    || (llvm::LLParser::parseUseListOrderIndexes((uint64_t)this, (uint64_t)&v8) & 1) != 0)
  {
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v5 = llvm::LLParser::sortUseListOrder((uint64_t)this, (uint64_t)v7, (uint64_t)v8, v9[0], v4);
  }
  if (v8 != v10) {
    free(v8);
  }
  return v5;
}

uint64_t llvm::LLParser::parseUseListOrderBB(llvm::LLParser *this)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (char *)this + 168;
  uint64_t v3 = (char *)*((void *)this + 27);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  int v33 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v34 = 0;
  uint64_t v4 = 1;
  int v41 = 1;
  char v42 = 0;
  sub_1CB892E1C((uint64_t)v43, 0.0);
  v43[5] = 0;
  char v44 = 0;
  int v22 = 0;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  std::string v23 = 0;
  int v29 = 1;
  char v30 = 0;
  sub_1CB892E1C((uint64_t)v31, 0.0);
  v31[5] = 0;
  char v32 = 0;
  __int16 v19 = v21;
  *(void *)uint64_t v20 = 0x1000000000;
  if ((llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v33, 0, 0) & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 4, "expected comma in uselistorder_bb directive") & 1) == 0
    && (llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v22, 0, 0) & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 4, "expected comma in uselistorder_bb directive") & 1) == 0
    && (llvm::LLParser::parseUseListOrderIndexes((uint64_t)this, (uint64_t)&v19) & 1) == 0)
  {
    if (v33 == 1)
    {
      uint64_t v10 = *((void *)this + 129);
      if (v35 >= (unint64_t)((*((void *)this + 130) - v10) >> 3)) {
        goto LABEL_16;
      }
      uint64_t NamedValue = *(void *)(v10 + 8 * v35);
    }
    else
    {
      if (v33 != 3) {
        goto LABEL_23;
      }
      if (v37 >= 0) {
        uint64_t v5 = (unsigned __int8 *)&v36 + 8;
      }
      else {
        uint64_t v5 = (unsigned __int8 *)*((void *)&v36 + 1);
      }
      if (v37 >= 0) {
        unint64_t v6 = HIBYTE(v37) & 0x7F;
      }
      else {
        unint64_t v6 = v37;
      }
      uint64_t NamedValue = llvm::Module::getNamedValue(*((void *)this + 41), v5, v6);
    }
    if (!NamedValue)
    {
LABEL_16:
      uint64_t v8 = v34;
      int v9 = "invalid function forward reference in uselistorder_bb";
      goto LABEL_24;
    }
    if (!*(unsigned char *)(NamedValue + 16))
    {
      if (*(void *)(NamedValue + 72) != NamedValue + 72 || (*(unsigned char *)(NamedValue + 34) & 0x80) != 0)
      {
        if (v22 == 2)
        {
          BOOL v13 = *(uint64_t **)(NamedValue + 104);
          if (v25 >= 0) {
            uint64_t v14 = (unsigned __int8 *)&v24 + 8;
          }
          else {
            uint64_t v14 = (unsigned __int8 *)*((void *)&v24 + 1);
          }
          if (v25 >= 0) {
            unint64_t v15 = HIBYTE(v25) & 0x7F;
          }
          else {
            unint64_t v15 = v25;
          }
          uint64_t v16 = sub_1CC196FC4(v13, v14, v15);
          if (v16)
          {
            if (*(unsigned char *)(v16 + 16) == 22)
            {
              uint64_t v11 = llvm::LLParser::sortUseListOrder((uint64_t)this, v16, (uint64_t)v19, v20[0], v3);
              goto LABEL_25;
            }
            uint64_t v8 = v23;
            int v9 = "expected basic block in uselistorder_bb";
          }
          else
          {
            uint64_t v8 = v23;
            int v9 = "invalid basic block in uselistorder_bb";
          }
        }
        else
        {
          uint64_t v8 = v23;
          if (v22) {
            int v9 = "expected basic block name in uselistorder_bb";
          }
          else {
            int v9 = "invalid numeric label in uselistorder_bb";
          }
        }
      }
      else
      {
        uint64_t v8 = v34;
        int v9 = "invalid declaration in uselistorder_bb";
      }
LABEL_24:
      uint64_t v17 = v9;
      __int16 v18 = 259;
      uint64_t v11 = llvm::LLLexer::Error((uint64_t)v2, v8, (llvm::Twine *)&v17);
LABEL_25:
      uint64_t v4 = v11;
      goto LABEL_26;
    }
LABEL_23:
    uint64_t v8 = v34;
    int v9 = "expected function name in uselistorder_bb";
    goto LABEL_24;
  }
LABEL_26:
  if (v19 != v21) {
    free(v19);
  }
  sub_1CD4F271C((uint64_t)&v22);
  sub_1CD4F271C((uint64_t)&v33);
  return v4;
}

uint64_t llvm::LLParser::parseToken(uint64_t a1, int a2, unsigned char *a3)
{
  uint64_t v4 = (llvm::LLLexer *)(a1 + 168);
  if (*(_DWORD *)(a1 + 224) == a2)
  {
    int v5 = llvm::LLLexer::LexToken(v4);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 224) = v5;
  }
  else
  {
    char v7 = 1;
    char v10 = 1;
    if (*a3)
    {
      uint64_t v8 = a3;
      char v7 = 3;
    }
    char v9 = v7;
    return llvm::LLLexer::Error((uint64_t)v4, *(char **)(a1 + 216), (llvm::Twine *)&v8);
  }
  return result;
}

uint64_t llvm::LLParser::parseStringConstant(uint64_t a1, std::string *this)
{
  uint64_t v3 = (llvm::LLLexer *)(a1 + 168);
  if (*(_DWORD *)(a1 + 224) == 442)
  {
    std::string::operator=(this, (const std::string *)(a1 + 232));
    int v4 = llvm::LLLexer::LexToken(v3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 224) = v4;
  }
  else
  {
    unint64_t v6 = "expected string constant";
    __int16 v7 = 259;
    return llvm::LLLexer::Error(a1 + 168, *(char **)(a1 + 216), (llvm::Twine *)&v6);
  }
  return result;
}

void LLVMAppendModuleInlineAsm_0(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
  int v4 = (std::string *)(a1 + 88);
  std::string::append((std::string *)(a1 + 88), a2, a3);
  if (*(char *)(a1 + 111) < 0)
  {
    uint64_t v5 = *(void *)(a1 + 96);
    if (!v5) {
      return;
    }
    unint64_t v6 = (std::string *)v4->__r_.__value_.__r.__words[0];
  }
  else
  {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 111);
    if (!*(unsigned char *)(a1 + 111)) {
      return;
    }
    unint64_t v6 = v4;
  }
  if (v6->__r_.__value_.__s.__data_[v5 - 1] != 10)
  {
    std::string::push_back(v4, 10);
  }
}

uint64_t llvm::LLParser::parseStructDefinition(uint64_t a1, char *a2, unsigned __int8 *a3, size_t a4, uint64_t *a5, llvm::Type **a6)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*a5) {
    BOOL v8 = a5[1] == 0;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    char v21 = "redefinition of type";
    __int16 v24 = 259;
    uint64_t v17 = a1 + 168;
    return llvm::LLLexer::Error(v17, a2, (llvm::Twine *)&v21);
  }
  int v13 = *(_DWORD *)(a1 + 224);
  if (v13 == 243)
  {
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    a5[1] = 0;
    uint64_t v14 = *a5;
    if (!*a5)
    {
      uint64_t v14 = llvm::StructType::create(*(uint64_t **)a1, a3, a4);
      *a5 = v14;
    }
    uint64_t v15 = 0;
    *a6 = (llvm::Type *)v14;
    return v15;
  }
  int v19 = *(_DWORD *)(a1 + 224);
  if (v13 == 10)
  {
    int v19 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v19;
  }
  if (v19 == 8)
  {
    a5[1] = 0;
    uint64_t v20 = *a5;
    if (!*a5)
    {
      uint64_t v20 = llvm::StructType::create(*(uint64_t **)a1, a3, a4);
      *a5 = v20;
    }
    char v21 = v23;
    uint64_t v22 = 0x800000000;
    if ((llvm::LLParser::parseStructBody(a1, (uint64_t)&v21) & 1) != 0
      || v13 == 10 && (llvm::LLParser::parseToken(a1, 11, "expected '>' in packed struct") & 1) != 0)
    {
      uint64_t v15 = 1;
    }
    else
    {
      llvm::StructType::setBody(v20, (uint64_t)v21, v22, v13 == 10);
      uint64_t v15 = 0;
      *a6 = (llvm::Type *)v20;
    }
    if (v21 != v23) {
      free(v21);
    }
    return v15;
  }
  if (*a5)
  {
    uint64_t v17 = a1 + 168;
    char v21 = "forward references to non-struct type";
    __int16 v24 = 259;
    return llvm::LLLexer::Error(v17, a2, (llvm::Twine *)&v21);
  }
  *a6 = 0;
  if (v13 != 10)
  {
    char v21 = "expected type";
    __int16 v24 = 259;
    return llvm::LLParser::parseType((llvm::LLParser *)a1, a6, (const llvm::Twine *)&v21, 0);
  }

  return llvm::LLParser::parseArrayVectorType((llvm::LLParser *)a1, a6, 1);
}

uint64_t llvm::LLParser::parseMetadataAttachment(llvm::LLParser *this, unsigned int *a2, llvm::MDNode **a3)
{
  unint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  if (*((char *)this + 255) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, *((const void **)this + 29), *((void *)this + 30));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)((char *)this + 232);
    uint64_t v12 = *((void *)this + 31);
  }
  if (v12 >= 0) {
    __int16 v7 = (unsigned __int8 *)__p;
  }
  else {
    __int16 v7 = (unsigned __int8 *)__p[0];
  }
  if (v12 >= 0) {
    size_t v8 = HIBYTE(v12) & 0x7F;
  }
  else {
    size_t v8 = (size_t)__p[1];
  }
  *a2 = llvm::Module::getMDKindID(*((uint64_t ***)this + 41), v7, v8);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
  uint64_t v9 = llvm::LLParser::parseMDNode((char **)this, a3);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  return v9;
}

uint64_t llvm::LLParser::parseFunctionHeader(llvm::LLParser *this, llvm::Function **a2, int a3)
{
  v194[8] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = (char *)*((void *)this + 27);
  *(void *)long long v172 = 0;
  unsigned int v171 = 0;
  BOOL v170 = 0;
  v191 = (uint64_t *)**((void **)this + 41);
  uint64_t v192 = v194;
  uint64_t v193 = 0x800000000;
  BOOL v168 = 0;
  uint64_t v167 = 0;
  if ((llvm::LLParser::parseOptionalLinkage(this, &v172[1], &v168, v172, &v171, &v170) & 1) != 0
    || (unsigned int v169 = 0, (llvm::LLParser::parseOptionalCallingConv(this, &v169) & 1) != 0)
    || (llvm::LLParser::parseOptionalParamOrReturnAttrs(this, (llvm::AttrBuilder *)&v191, 0) & 1) != 0)
  {
    uint64_t v7 = 1;
    goto LABEL_3;
  }
  uint64_t v9 = (char *)*((void *)this + 27);
  v187 = "expected type";
  __int16 v190 = 259;
  uint64_t v7 = 1;
  if ((llvm::LLParser::parseType(this, &v167, (const llvm::Twine *)&v187, 1) & 1) == 0)
  {
    uint64_t v11 = this;
    uint64_t v12 = (llvm::LLParser *)((char *)this + 168);
    int v13 = v172[1];
    if (v172[1] <= 0xA)
    {
      if (((1 << SLOBYTE(v172[1])) & 0x1BE) != 0)
      {
        if ((a3 & 1) == 0)
        {
          uint64_t v14 = "invalid linkage for function declaration";
          goto LABEL_18;
        }
        if (v172[1] >= 7 && v172[0])
        {
          uint64_t v14 = "symbol with local linkage must have default visibility";
LABEL_18:
          v187 = v14;
          __int16 v190 = 259;
          uint64_t v15 = (uint64_t)v12;
          uint64_t v16 = v6;
LABEL_19:
          uint64_t v7 = llvm::LLLexer::Error(v15, v16, (llvm::Twine *)&v187);
          goto LABEL_3;
        }
      }
      else
      {
        if (((1 << SLOBYTE(v172[1])) & 0x440) != 0)
        {
          uint64_t v14 = "invalid function linkage type";
          goto LABEL_18;
        }
        if (v172[1] == 9 && a3)
        {
          uint64_t v14 = "invalid linkage for function definition";
          goto LABEL_18;
        }
      }
    }
    uint64_t v17 = v167;
    if (!llvm::FunctionType::isValidReturnType(v167, v10))
    {
      v187 = "invalid function return type";
      __int16 v190 = 259;
      uint64_t v15 = (uint64_t)v12;
      uint64_t v16 = v9;
      goto LABEL_19;
    }
    long long v118 = (char *)*((void *)v11 + 27);
    memset(&__str, 0, sizeof(__str));
    int v18 = *((_DWORD *)v11 + 56);
    if (v18 == 433)
    {
      uint64_t v20 = (uint64_t)(*((void *)v11 + 130) - *((void *)v11 + 129)) >> 3;
      if (v20 != *((_DWORD *)v11 + 64))
      {
        uint64_t v183 = "function expected to be numbered '%";
        v186[4] = 259;
        v145.__r_.__value_.__r.__words[0] = v20;
        v182[8] = 266;
        v180 = &v145;
        sub_1CB8F1E58((uint64_t *)&v183, (uint64_t *)&v180, (uint64_t)v173);
        v163[0] = "'";
        __int16 v165 = 259;
        sub_1CB8F1E58((uint64_t *)v173, (uint64_t *)v163, (uint64_t)&v187);
LABEL_46:
        uint64_t v22 = (char *)*((void *)v11 + 27);
        uint64_t v21 = (uint64_t)v12;
        goto LABEL_47;
      }
    }
    else
    {
      if (v18 != 438)
      {
        v187 = "expected function name";
        __int16 v190 = 259;
        uint64_t v21 = (uint64_t)v12;
        uint64_t v22 = v118;
LABEL_47:
        uint64_t v7 = llvm::LLLexer::Error(v21, v22, (llvm::Twine *)&v187);
LABEL_48:
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        goto LABEL_3;
      }
      std::string::operator=(&__str, (const std::string *)((char *)v11 + 232));
    }
    int v19 = llvm::LLLexer::LexToken(v12);
    *((_DWORD *)v11 + 56) = v19;
    if (v19 == 12)
    {
      v187 = (char *)&v189;
      uint64_t v188 = 0x800000000;
      unsigned __int8 v162 = 0;
      uint64_t v183 = (const char *)**((void **)v11 + 41);
      v184 = v186;
      uint64_t v185 = 0x800000000;
      v160 = 0;
      __src = 0;
      uint64_t v161 = 0;
      *(void *)uint64_t v158 = 0;
      memset(&v157, 0, sizeof(v157));
      memset(&v156, 0, sizeof(v156));
      __int16 v155 = 0;
      memset(v154, 0, 28);
      v153 = 0;
      uint64_t v152 = 0;
      v151 = 0;
      uint64_t v150 = 0;
      if (llvm::LLParser::parseArgumentList((uint64_t)v11, (uint64_t)&v187, &v162))
      {
LABEL_29:
        uint64_t v7 = 1;
LABEL_30:
        if (SHIBYTE(v154[6]) < 0) {
          operator delete(*(void **)&v154[1]);
        }
        if (SHIBYTE(v156.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v156.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v157.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v157.__r_.__value_.__l.__data_);
        }
        if (__src) {
          operator delete(__src);
        }
        if (v184 != v186) {
          free(v184);
        }
        sub_1CD4F486C(&v187);
        goto LABEL_48;
      }
      int v23 = *((_DWORD *)v11 + 56);
      if (v23 == 41)
      {
        int v24 = 128;
      }
      else
      {
        if (v23 != 42)
        {
          int v112 = 0;
          goto LABEL_55;
        }
        int v24 = 64;
      }
      int v112 = v24;
      *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
LABEL_55:
      if ((llvm::LLParser::parseOptionalAddrSpace(v11, v154, *(_DWORD *)(*((void *)v11 + 41) + 284)) & 1) != 0
        || (llvm::LLParser::parseFnAttributeValuePairs((uint64_t)v11, (uint64_t)&v183, (char **)&__src, 0, (char **)v158) & 1) != 0)
      {
        goto LABEL_29;
      }
      int v25 = *((_DWORD *)v11 + 56);
      if (v25 == 92)
      {
        *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
        if (llvm::LLParser::parseStringConstant((uint64_t)v11, &v157)) {
          goto LABEL_29;
        }
        int v25 = *((_DWORD *)v11 + 56);
      }
      if (v25 == 93)
      {
        *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
        if (llvm::LLParser::parseStringConstant((uint64_t)v11, &v156)) {
          goto LABEL_29;
        }
      }
      long long v26 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__str
          : (std::string *)__str.__r_.__value_.__r.__words[0];
      std::string::size_type v27 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F
          : __str.__r_.__value_.__l.__size_;
      if (llvm::LLParser::parseOptionalComdat((uint64_t)v11, (const std::string::value_type *)v26, v27, (uint64_t *)&v150) & 1) != 0|| (llvm::LLParser::parseOptionalAlignment((uint64_t)v11, &v155, 0))
      {
        goto LABEL_29;
      }
      int v28 = *((_DWORD *)v11 + 56);
      if (v28 == 101)
      {
        *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
        if (llvm::LLParser::parseStringConstant((uint64_t)v11, (std::string *)&v154[1])) {
          goto LABEL_29;
        }
        int v28 = *((_DWORD *)v11 + 56);
      }
      if (v28 == 102)
      {
        *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
        if (llvm::LLParser::parseGlobalTypeAndValue((llvm::ConstantInt **)v11, &v153)) {
          goto LABEL_29;
        }
        int v28 = *((_DWORD *)v11 + 56);
      }
      if (v28 == 103)
      {
        *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
        if (llvm::LLParser::parseGlobalTypeAndValue((llvm::ConstantInt **)v11, &v152)) {
          goto LABEL_29;
        }
        int v28 = *((_DWORD *)v11 + 56);
      }
      if (v28 == 315)
      {
        *((_DWORD *)v11 + 56) = llvm::LLLexer::LexToken(v12);
        if (llvm::LLParser::parseGlobalTypeAndValue((llvm::ConstantInt **)v11, &v151)) {
          goto LABEL_29;
        }
      }
      if (llvm::AttrBuilder::contains((uint64_t)&v183, 4))
      {
        v173[0] = (uint64_t *)"'builtin' attribute not valid on function";
        LOWORD(v175[1]) = 259;
        uint64_t v7 = llvm::LLLexer::Error((uint64_t)v12, *(char **)v158, (llvm::Twine *)v173);
        goto LABEL_30;
      }
      if (llvm::AttrBuilder::hasAlignmentAttr((llvm::AttrBuilder *)&v183))
      {
        unint64_t RawIntAttr = llvm::AttrBuilder::getRawIntAttr((uint64_t)&v183, 74);
        int v31 = __clz(RawIntAttr) ^ 0x3F | 0x100;
        if (!RawIntAttr) {
          LOWORD(v31) = 0;
        }
        __int16 v155 = v31;
        llvm::AttrBuilder::removeAttribute((uint64_t)&v183, 74);
      }
      uint64_t v116 = 0;
      v148 = 0;
      uint64_t v147 = 0;
      unint64_t v149 = 0;
      v180 = v182;
      size_t __n = 0x800000000;
      if (v188)
      {
        uint64_t v45 = 0;
        uint64_t v116 = 0;
        unsigned int v46 = 0;
        *(void *)v115 = 48 * v188;
        do
        {
          uint64_t v47 = *(void *)&v187[v45 + 8];
          if ((unint64_t)v116 >= v149)
          {
            uint64_t v116 = (llvm::ValueAsMetadata *)sub_1CBF63C18(&v147, v47);
            unsigned int v46 = __n;
          }
          else
          {
            *(void *)uint64_t v116 = v47;
            uint64_t v116 = (llvm::ValueAsMetadata *)((char *)v116 + 8);
          }
          v148 = v116;
          if (v46 >= HIDWORD(__n)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v180 + v46) = *(void *)&v187[v45 + 16];
          unsigned int v46 = __n + 1;
          LODWORD(__n) = __n + 1;
          v45 += 48;
        }
        while (*(void *)v115 != v45);
      }
      char v32 = *(uint64_t **)v11;
      uint64_t v113 = llvm::AttributeSet::get(*(llvm::AttributeSet **)v11, (uint64_t **)&v183, v29);
      uint64_t v34 = llvm::AttributeSet::get(*(llvm::AttributeSet **)v11, &v191, v33);
      uint64_t v146 = llvm::AttributeList::get(v32, v113, v34, v180, __n);
      if ((llvm::AttributeList::hasAttributeAtIndex(&v146, 1, 73) & 1) != 0 && *((unsigned char *)v17 + 8) != 7)
      {
        v173[0] = (uint64_t *)"functions with 'sret' argument must return void";
        LOWORD(v175[1]) = 259;
        uint64_t v54 = (uint64_t)v12;
        uint64_t v55 = v9;
      }
      else
      {
        unsigned int v35 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)v17, (uint64_t)v147, (v116 - (llvm::ValueAsMetadata *)v147) >> 3, v162);
        long long v36 = (llvm::Type *)v154[0];
        uint64_t v114 = (llvm::Type *)llvm::PointerType::get(v35, (llvm::Type *)v154[0]);
        *a2 = 0;
        std::string::size_type size = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __str.__r_.__value_.__l.__size_;
        }
        if (!size)
        {
          long long v38 = (char *)*((void *)v11 + 127);
          if (v38)
          {
            uint64_t v56 = *((void *)v11 + 130) - *((void *)v11 + 129);
            unint64_t v57 = (unint64_t)v56 >> 3;
            char v58 = (char *)v11 + 1016;
            do
            {
              unsigned int v59 = *((_DWORD *)v38 + 8);
              BOOL v60 = v59 >= v57;
              if (v59 >= v57) {
                uint64_t v61 = (char **)v38;
              }
              else {
                uint64_t v61 = (char **)(v38 + 8);
              }
              if (v60) {
                char v58 = v38;
              }
              long long v38 = *v61;
            }
            while (*v61);
            if (v58 != (char *)v11 + 1016 && *((_DWORD *)v58 + 8) <= v57)
            {
              v117 = (llvm::Type **)*((void *)v58 + 5);
              if (*v117 == v114)
              {
                sub_1CD491B50((uint64_t **)v11 + 126, (uint64_t *)v58);
                operator delete(v58);
                goto LABEL_96;
              }
              v140.__r_.__value_.__r.__words[0] = (std::string::size_type)"type of definition and forward reference of '@";
              __int16 v141 = 259;
              __int16 v139 = 266;
              uint64_t v136 = v56 >> 3;
              v137[0] = &v136;
              sub_1CB8F1E58((uint64_t *)&v140, (uint64_t *)v137, (uint64_t)&v142);
              v133[0] = "' disagree: expected '";
              __int16 v135 = 259;
              sub_1CB8F1E58((uint64_t *)&v142, (uint64_t *)v133, (uint64_t)&v143);
              sub_1CC196EB4((uint64_t)v129, v114);
              __int16 v132 = 260;
              v131[0] = (uint64_t)v129;
              sub_1CB8F1E58((uint64_t *)&v143, v131, (uint64_t)&v144);
              long long v127 = "' but was '";
              __int16 v128 = 259;
              sub_1CB8F1E58((uint64_t *)&v144, (uint64_t *)&v127, (uint64_t)&v145);
              sub_1CC196EB4((uint64_t)v123, *v117);
              __int16 v126 = 260;
              uint64_t v125 = v123;
              sub_1CB8F1E58((uint64_t *)&v145, (uint64_t *)&v125, (uint64_t)v163);
              v121 = "'";
              __int16 v122 = 259;
              sub_1CB8F1E58((uint64_t *)v163, (uint64_t *)&v121, (uint64_t)v173);
              uint64_t v7 = llvm::LLLexer::Error((uint64_t)v12, v118, (llvm::Twine *)v173);
              if (v124 < 0) {
                operator delete(v123[0]);
              }
              if ((v130 & 0x80000000) == 0) {
                goto LABEL_127;
              }
              size_t v94 = (void *)v129[0];
LABEL_204:
              operator delete(v94);
              goto LABEL_127;
            }
          }
LABEL_95:
          v117 = 0;
LABEL_96:
          LOWORD(v175[1]) = 260;
          v173[0] = (uint64_t *)&__str;
          unint64_t v39 = *((void *)v11 + 41);
          uint64_t v40 = operator new(0x80uLL);
          *((_DWORD *)v40 + 7) = *((_DWORD *)v40 + 7) & 0x38000000 | 0x40000000;
          *(void *)uint64_t v40 = 0;
          int v41 = llvm::Function::Function((unint64_t *)v40 + 1, v35, 0, v36, (const char **)v173, v39);
          *a2 = (llvm::Function *)v41;
          std::string::size_type v42 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type v42 = __str.__r_.__value_.__l.__size_;
          }
          if (!v42)
          {
            v173[0] = (uint64_t *)v41;
            uint64_t v43 = (unint64_t **)*((void *)v11 + 130);
            if ((unint64_t)v43 >= *((void *)v11 + 131))
            {
              char v44 = sub_1CBC13470((void **)v11 + 129, v173);
            }
            else
            {
              *uint64_t v43 = v41;
              char v44 = v43 + 1;
            }
            *((void *)v11 + 130) = v44;
            int v41 = (unint64_t *)*a2;
          }
          sub_1CC1966A4((llvm::GlobalValue *)v41, v13);
          if (v170) {
            *((_DWORD *)*a2 + 8) |= 0x4000u;
          }
          sub_1CC196644((uint64_t)*a2, v172[0]);
          *((_DWORD *)*a2 + 8) = *((_DWORD *)*a2 + 8) & 0xFFFFFCFF | ((v171 & 3) << 8);
          uint64_t v63 = (unint64_t *)*a2;
          *((_WORD *)v63 + 9) = *((_WORD *)*a2 + 9) & 0xC00F | (16 * v169);
          v63[14] = v146;
          *((_DWORD *)*a2 + 8) = *((_DWORD *)*a2 + 8) & 0xFFFFFF3F | v112;
          llvm::GlobalObject::setAlignment((uint64_t)*a2, v155);
          if ((v157.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int v64 = &v157;
          }
          else {
            int v64 = (std::string *)v157.__r_.__value_.__r.__words[0];
          }
          if ((v157.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v65 = *((unsigned char *)&v157.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            size_t v65 = v157.__r_.__value_.__l.__size_;
          }
          llvm::GlobalObject::setSection(*a2, v64, v65);
          if ((v156.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v66 = &v156;
          }
          else {
            uint64_t v66 = (std::string *)v156.__r_.__value_.__r.__words[0];
          }
          if ((v156.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t v67 = *((unsigned char *)&v156.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            size_t v67 = v156.__r_.__value_.__l.__size_;
          }
          llvm::GlobalValue::setPartition(*a2, v66, v67);
          llvm::GlobalObject::setComdat(*a2, v150);
          llvm::Function::setPersonalityFn(*a2, v151);
          uint64_t v68 = HIBYTE(v154[6]) & 0x7F;
          if ((v154[6] & 0x80000000) != 0) {
            uint64_t v68 = *(void *)&v154[3];
          }
          if (v68)
          {
            uint64_t v71 = *a2;
            if (SHIBYTE(v154[6]) < 0)
            {
              sub_1CB8BDF7C((uint64_t)v119, *(const void **)&v154[1], *(unint64_t *)&v154[3]);
            }
            else
            {
              *(_OWORD *)v119 = *(_OWORD *)&v154[1];
              uint64_t v120 = *(void *)&v154[5];
            }
            llvm::Function::setGC((uint64_t)v71, (uint64_t)v119);
            if (SHIBYTE(v120) < 0) {
              operator delete(v119[0]);
            }
          }
          llvm::Function::setPrefixData(*a2, v153);
          llvm::Function::setPrologueData(*a2, v152);
          v173[0] = (uint64_t *)*a2;
          uint64_t v69 = sub_1CD4F40F4((uint64_t **)v11 + 139, (unint64_t)v173[0], v173);
          sub_1CC19E0C8(v69 + 5, (char *)__src, v160, (v160 - (unsigned char *)__src) >> 2);
          unsigned int v70 = *a2;
          if (*((_WORD *)*a2 + 9)) {
            llvm::Function::BuildLazyArguments(*a2);
          }
          if (!v188)
          {
LABEL_169:
            if (v117)
            {
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v117, *a2, (llvm::Value *)1);
              llvm::GlobalValue::eraseFromParent((llvm::GlobalValue *)v117);
            }
            if (a3)
            {
              uint64_t v7 = 0;
            }
            else
            {
              LODWORD(v173[0]) = 0;
              memset(v175, 0, sizeof(v175));
              v173[1] = 0;
              int v176 = 1;
              char v177 = 0;
              sub_1CB892E1C((uint64_t)v178, 0.0);
              v178[5] = 0;
              char v179 = 0;
              std::string::size_type v85 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
              if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type v85 = __str.__r_.__value_.__l.__size_;
              }
              if (v85)
              {
                LODWORD(v173[0]) = 3;
                std::string::operator=((std::string *)&v175[1], &__str);
              }
              else
              {
                int v86 = ((*((void *)v11 + 130) - *((void *)v11 + 129)) >> 3) - 1;
                LODWORD(v173[0]) = 1;
                int v174 = v86;
              }
              uint64_t v95 = sub_1CD4F4DB4((uint64_t)v11 + 1080, v173);
              if ((llvm::LLParser *)((char *)v11 + 1088) == (llvm::LLParser *)v95)
              {
                uint64_t v7 = 0;
              }
              else
              {
                __int16 v96 = *(char **)(v95 + 40);
                v163[0] = "cannot take blockaddress inside a declaration";
                __int16 v165 = 259;
                uint64_t v7 = llvm::LLLexer::Error((uint64_t)v12, v96, (llvm::Twine *)v163);
              }
              sub_1CD4F271C((uint64_t)v173);
            }
            goto LABEL_127;
          }
          uint64_t v72 = 0;
          unint64_t v73 = (llvm::Value *)*((void *)v70 + 11);
          uint64_t v74 = v187;
          uint64_t v75 = 48 * v188;
          while (1)
          {
            uint64_t v76 = &v74[v72];
            if (v74[v72 + 47] < 0 ? *((void *)v76 + 4) : v74[v72 + 47])
            {
              LOWORD(v175[1]) = 260;
              v173[0] = (uint64_t *)(v76 + 24);
              llvm::Value::setName(v73, (const char **)v173);
              Name = llvm::Value::getName(v73);
              uint64_t v80 = v79;
              uint64_t v74 = v187;
              int v81 = &v187[v72];
              char v82 = v187[v72 + 47];
              uint64_t v83 = v82 >= 0 ? &v187[v72 + 24] : *(char **)&v187[v72 + 24];
              size_t v84 = v82 >= 0 ? v82 & 0x7F : *(void *)&v187[v72 + 32];
              if (v80 != v84 || v84 && memcmp(Name, v83, v84)) {
                break;
              }
            }
            unint64_t v73 = (llvm::Value *)((char *)v73 + 40);
            v72 += 48;
            if (v75 == v72) {
              goto LABEL_169;
            }
          }
          uint64_t v87 = *(char **)v81;
          std::operator+<char>();
          BOOL v88 = std::string::append(&v145, "'");
          std::string::size_type v89 = v88->__r_.__value_.__r.__words[2];
          *(_OWORD *)long long v163 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
          std::string::size_type v164 = v89;
          v88->__r_.__value_.__l.__size_ = 0;
          v88->__r_.__value_.__r.__words[2] = 0;
          v88->__r_.__value_.__r.__words[0] = 0;
          LOWORD(v175[1]) = 260;
          v173[0] = (uint64_t *)v163;
          uint64_t v90 = (uint64_t)v12;
          long long v91 = v87;
          goto LABEL_200;
        }
        uint64_t v48 = sub_1CD4F3EC8((uint64_t)v11 + 984, &__str);
        if ((llvm::LLParser *)((char *)v11 + 992) == (llvm::LLParser *)v48)
        {
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_str = &__str;
          }
          else {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            unint64_t v50 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            unint64_t v50 = __str.__r_.__value_.__l.__size_;
          }
          Function = (llvm::Function *)llvm::Module::getFunction(*((void *)v11 + 41), (unsigned __int8 *)p_str, v50);
          *a2 = Function;
          if (Function
            || ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? (uint64_t v52 = &__str)
              : (uint64_t v52 = (std::string *)__str.__r_.__value_.__r.__words[0]),
                (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
              ? (unint64_t v53 = *((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x7F)
              : (unint64_t v53 = __str.__r_.__value_.__l.__size_),
                llvm::Module::getNamedValue(*((void *)v11 + 41), (unsigned __int8 *)v52, v53)))
          {
            std::operator+<char>();
            char v92 = std::string::append(&v145, "'");
            std::string::size_type v93 = v92->__r_.__value_.__r.__words[2];
            *(_OWORD *)long long v163 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
            std::string::size_type v164 = v93;
            v92->__r_.__value_.__l.__size_ = 0;
            v92->__r_.__value_.__r.__words[2] = 0;
            v92->__r_.__value_.__r.__words[0] = 0;
            LOWORD(v175[1]) = 260;
            v173[0] = (uint64_t *)v163;
            uint64_t v90 = (uint64_t)v12;
            long long v91 = v118;
LABEL_200:
            uint64_t v7 = llvm::LLLexer::Error(v90, v91, (llvm::Twine *)v173);
            if (SHIBYTE(v164) < 0) {
              operator delete(v163[0]);
            }
            if ((SHIBYTE(v145.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_127;
            }
            size_t v94 = (void *)v145.__r_.__value_.__r.__words[0];
            goto LABEL_204;
          }
          goto LABEL_95;
        }
        v117 = *(llvm::Type ***)(v48 + 56);
        uint64_t v62 = *v117;
        if (!*((void *)*v117 + 3) || *(unsigned char *)(**((void **)v62 + 2) + 8) == 14)
        {
          if (v62 == v114)
          {
            sub_1CD4F3F94((uint64_t **)v11 + 123, v48);
            goto LABEL_96;
          }
          v97 = *(char **)(v48 + 64);
          std::operator+<char>();
          __int16 v98 = std::string::append(&v140, "' with wrong type: expected '");
          std::string::size_type v99 = v98->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v142.__r_.__value_.__l.__data_ = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
          v142.__r_.__value_.__r.__words[2] = v99;
          v98->__r_.__value_.__l.__size_ = 0;
          v98->__r_.__value_.__r.__words[2] = 0;
          v98->__r_.__value_.__r.__words[0] = 0;
          sub_1CC196EB4((uint64_t)v137, v114);
          if (v138 >= 0) {
            __int16 v100 = v137;
          }
          else {
            __int16 v100 = (void **)v137[0];
          }
          if (v138 >= 0) {
            std::string::size_type v101 = v138 & 0x7F;
          }
          else {
            std::string::size_type v101 = (std::string::size_type)v137[1];
          }
          uint64_t v102 = std::string::append(&v142, (const std::string::value_type *)v100, v101);
          std::string::size_type v103 = v102->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v143.__r_.__value_.__l.__data_ = *(_OWORD *)&v102->__r_.__value_.__l.__data_;
          v143.__r_.__value_.__r.__words[2] = v103;
          v102->__r_.__value_.__l.__size_ = 0;
          v102->__r_.__value_.__r.__words[2] = 0;
          v102->__r_.__value_.__r.__words[0] = 0;
          __int16 v104 = std::string::append(&v143, "' but was '");
          std::string::size_type v105 = v104->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v144.__r_.__value_.__l.__data_ = *(_OWORD *)&v104->__r_.__value_.__l.__data_;
          v144.__r_.__value_.__r.__words[2] = v105;
          v104->__r_.__value_.__l.__size_ = 0;
          v104->__r_.__value_.__r.__words[2] = 0;
          v104->__r_.__value_.__r.__words[0] = 0;
          sub_1CC196EB4((uint64_t)v133, *v117);
          if (v134 >= 0) {
            v106 = v133;
          }
          else {
            v106 = (void **)v133[0];
          }
          if (v134 >= 0) {
            std::string::size_type v107 = v134 & 0x7F;
          }
          else {
            std::string::size_type v107 = (std::string::size_type)v133[1];
          }
          uint64_t v108 = std::string::append(&v144, (const std::string::value_type *)v106, v107);
          std::string::size_type v109 = v108->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v145.__r_.__value_.__l.__data_ = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
          v145.__r_.__value_.__r.__words[2] = v109;
          v108->__r_.__value_.__l.__size_ = 0;
          v108->__r_.__value_.__r.__words[2] = 0;
          v108->__r_.__value_.__r.__words[0] = 0;
          uint64_t v110 = std::string::append(&v145, "'");
          std::string::size_type v111 = v110->__r_.__value_.__r.__words[2];
          *(_OWORD *)long long v163 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
          std::string::size_type v164 = v111;
          v110->__r_.__value_.__l.__size_ = 0;
          v110->__r_.__value_.__r.__words[2] = 0;
          v110->__r_.__value_.__r.__words[0] = 0;
          LOWORD(v175[1]) = 260;
          v173[0] = (uint64_t *)v163;
          uint64_t v7 = llvm::LLLexer::Error((uint64_t)v12, v97, (llvm::Twine *)v173);
          if (SHIBYTE(v164) < 0) {
            operator delete(v163[0]);
          }
          if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v145.__r_.__value_.__l.__data_);
          }
          if (v134 < 0) {
            operator delete(v133[0]);
          }
          if (SHIBYTE(v144.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v144.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v143.__r_.__value_.__l.__data_);
          }
          if (v138 < 0) {
            operator delete(v137[0]);
          }
          if (SHIBYTE(v142.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v142.__r_.__value_.__l.__data_);
          }
          if ((SHIBYTE(v140.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_127;
          }
          size_t v94 = (void *)v140.__r_.__value_.__r.__words[0];
          goto LABEL_204;
        }
        uint64_t v55 = *(char **)(v48 + 64);
        v173[0] = (uint64_t *)"invalid forward reference to function as global value!";
        LOWORD(v175[1]) = 259;
        uint64_t v54 = (uint64_t)v12;
      }
      uint64_t v7 = llvm::LLLexer::Error(v54, v55, (llvm::Twine *)v173);
LABEL_127:
      if (v180 != v182) {
        free(v180);
      }
      if (v147) {
        operator delete(v147);
      }
      goto LABEL_30;
    }
    v187 = "expected '(' in function argument list";
    __int16 v190 = 259;
    goto LABEL_46;
  }
LABEL_3:
  if (v192 != v194) {
    free(v192);
  }
  return v7;
}

uint64_t llvm::LLParser::parseFunctionBody(llvm::LLParser *this, llvm::Function *a2)
{
  uint64_t v3 = (llvm::LLParser *)((char *)this + 168);
  if (*((_DWORD *)this + 56) == 8)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if ((*((unsigned char *)a2 + 23) & 0x10) != 0) {
      int v5 = -1;
    }
    else {
      int v5 = ((*((void *)this + 130) - *((void *)this + 129)) >> 3) - 1;
    }
    llvm::LLParser::PerFunctionState::PerFunctionState((llvm::LLParser::PerFunctionState *)v14, this, a2, v5);
    if (llvm::LLParser::PerFunctionState::resolveForwardRefBlockAddresses((llvm::LLParser::PerFunctionState *)v14))
    {
      uint64_t v6 = 1;
    }
    else
    {
      uint64_t v8 = *((void *)this + 138);
      *((void *)this + 138) = v14;
      int v9 = *((_DWORD *)this + 56);
      if (v9 == 9 || v9 == 349)
      {
        uint64_t v12 = "function body requires at least one basic block";
        __int16 v13 = 259;
        uint64_t v10 = llvm::LLLexer::Error((uint64_t)v3, *((char **)this + 27), (llvm::Twine *)&v12);
      }
      else
      {
        while (v9 != 349 && v9 != 9)
        {
          if (llvm::LLParser::parseBasicBlock(this, (llvm::LLParser::PerFunctionState *)v14))
          {
LABEL_23:
            uint64_t v6 = 1;
            goto LABEL_12;
          }
          int v9 = *((_DWORD *)this + 56);
        }
        while (*((_DWORD *)this + 56) != 9)
        {
          if (llvm::LLParser::parseUseListOrder(this, (llvm::LLParser::PerFunctionState *)v14)) {
            goto LABEL_23;
          }
        }
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v3);
        uint64_t v10 = llvm::LLParser::PerFunctionState::finishFunction((llvm::LLParser::PerFunctionState *)v14);
      }
      uint64_t v6 = v10;
LABEL_12:
      *((void *)this + 138) = v8;
    }
    llvm::LLParser::PerFunctionState::~PerFunctionState((llvm::LLParser::PerFunctionState *)v14, v7);
  }
  else
  {
    v14[0] = "expected '{' in function body";
    __int16 v15 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)v14);
  }
  return v6;
}

uint64_t llvm::LLParser::parseGlobalType(llvm::LLParser *this, BOOL *a2)
{
  uint64_t v3 = (llvm::LLParser *)((char *)this + 168);
  int v4 = *((_DWORD *)this + 56);
  if (v4 == 23)
  {
    BOOL v5 = 0;
  }
  else
  {
    if (v4 != 24)
    {
      *a2 = 0;
      uint64_t v8 = "expected 'global' or 'constant'";
      __int16 v9 = 259;
      return llvm::LLLexer::Error((uint64_t)v3, *((char **)this + 27), (llvm::Twine *)&v8);
    }
    BOOL v5 = 1;
  }
  *a2 = v5;
  int v6 = llvm::LLLexer::LexToken(v3);
  uint64_t result = 0;
  *((_DWORD *)this + 56) = v6;
  return result;
}

uint64_t llvm::LLParser::parseOptionalLinkage(llvm::LLParser *this, unsigned int *a2, BOOL *a3, unsigned int *a4, unsigned int *a5, BOOL *a6)
{
  uint64_t v11 = (llvm::LLParser *)((char *)this + 168);
  *a2 = sub_1CC197270(*((_DWORD *)this + 56), a3);
  if (*a3) {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v11);
  }
  llvm::LLParser::parseOptionalDSOLocal(this, a6);
  int v12 = *((_DWORD *)this + 56);
  if ((v12 - 38) >= 3)
  {
    *a4 = 0;
  }
  else
  {
    *a4 = v12 - 38;
    int v12 = llvm::LLLexer::LexToken(v11);
    *((_DWORD *)this + 56) = v12;
  }
  if (v12 == 34)
  {
    unsigned int v13 = 1;
  }
  else
  {
    if (v12 != 35)
    {
      uint64_t result = 0;
      *a5 = 0;
      return result;
    }
    unsigned int v13 = 2;
  }
  *a5 = v13;
  int v14 = llvm::LLLexer::LexToken(v11);
  uint64_t result = 0;
  *((_DWORD *)this + 56) = v14;
  if (*a6 && *a5 == 1)
  {
    uint64_t v16 = (char *)*((void *)this + 27);
    uint64_t v17 = "dso_location and DLL-StorageClass mismatch";
    __int16 v18 = 259;
    return llvm::LLLexer::Error((uint64_t)v11, v16, (llvm::Twine *)&v17);
  }
  return result;
}

uint64_t llvm::LLParser::parseOptionalThreadLocal(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 0;
  *a2 = 0;
  if (*(_DWORD *)(a1 + 224) == 46)
  {
    int v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v5;
    *a2 = 1;
    if (v5 == 12)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if (llvm::LLParser::parseTLSModel(a1, a2))
      {
        return 1;
      }
      else
      {
        return llvm::LLParser::parseToken(a1, 13, "expected ')' after thread local model");
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::LLParser::parseGlobal(uint64_t a1, uint64_t a2, char *a3, int a4, int a5, int a6, char a7, int a8, char a9, char a10)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  if ((a4 - 9) >= 0xFFFFFFFE && a6 != 0)
  {
    std::string::size_type v89 = "symbol with local linkage must have default visibility";
    __int16 v93 = 259;
    uint64_t v20 = a1 + 168;
    uint64_t v21 = a3;
    return llvm::LLLexer::Error(v20, v21, (llvm::Twine *)&v89);
  }
  char v15 = a6;
  unsigned int v88 = 0;
  BOOL v87 = 0;
  int v86 = 0;
  if (llvm::LLParser::parseOptionalAddrSpace((llvm::LLParser *)a1, &v88, 0)) {
    return 1;
  }
  int v23 = *(_DWORD *)(a1 + 224);
  if (v23 == 43) {
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  }
  if (llvm::LLParser::parseGlobalType((llvm::LLParser *)a1, &v87)) {
    return 1;
  }
  uint64_t v78 = *(char **)(a1 + 216);
  std::string::size_type v89 = "expected type";
  __int16 v93 = 259;
  if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v86, (const llvm::Twine *)&v89, 0)) {
    return 1;
  }
  std::string::size_type v85 = 0;
  if (!a5 || a4 && a4 != 9) && (llvm::LLParser::parseGlobalValue((llvm::ConstantInt **)a1, v86, &v85)) {
    return 1;
  }
  int v25 = v86;
  if (*((unsigned char *)v86 + 8) == 14 || !llvm::PointerType::isValidElementType(v86, v24))
  {
    size_t v67 = "invalid type for global variable";
    goto LABEL_93;
  }
  char v26 = *(unsigned char *)(a2 + 23);
  int v27 = v26;
  uint64_t v28 = v26 & 0x7F;
  if (v27 < 0) {
    uint64_t v28 = *(void *)(a2 + 8);
  }
  uint64_t v79 = v25;
  if (v28)
  {
    uint64_t v68 = sub_1CD4F3EC8(a1 + 984, (void *)a2);
    if (a1 + 992 == v68)
    {
      char v69 = *(unsigned char *)(a2 + 23);
      BOOL v70 = v69 < 0;
      if (v69 >= 0) {
        uint64_t v71 = (unsigned __int8 *)a2;
      }
      else {
        uint64_t v71 = *(unsigned __int8 **)a2;
      }
      unint64_t v72 = v69 & 0x7F;
      if (v70) {
        unint64_t v73 = *(void *)(a2 + 8);
      }
      else {
        unint64_t v73 = v72;
      }
      if (llvm::Module::getNamedValue(*(void *)(a1 + 328), v71, v73))
      {
        std::operator+<char>();
        uint64_t v74 = std::string::append(&v82, "'");
        std::string::size_type v75 = v74->__r_.__value_.__r.__words[2];
        *(_OWORD *)std::string __p = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
        std::string::size_type v84 = v75;
        v74->__r_.__value_.__l.__size_ = 0;
        v74->__r_.__value_.__r.__words[2] = 0;
        v74->__r_.__value_.__r.__words[0] = 0;
        __int16 v93 = 260;
        std::string::size_type v89 = (const char *)__p;
        uint64_t v19 = llvm::LLLexer::Error(a1 + 168, a3, (llvm::Twine *)&v89);
        if (SHIBYTE(v84) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v82.__r_.__value_.__l.__data_);
        }
        return v19;
      }
      goto LABEL_33;
    }
    int v77 = *(llvm::ValueAsMetadata **)(v68 + 56);
    sub_1CD4F3F94((uint64_t **)(a1 + 984), v68);
  }
  else
  {
    uint64_t v29 = *(void *)(a1 + 1016);
    if (!v29) {
      goto LABEL_33;
    }
    uint64_t v30 = (*(void *)(a1 + 1040) - *(void *)(a1 + 1032)) >> 3;
    uint64_t v31 = a1 + 1016;
    do
    {
      unsigned int v32 = *(_DWORD *)(v29 + 32);
      BOOL v33 = v32 >= v30;
      if (v32 >= v30) {
        uint64_t v34 = (uint64_t *)v29;
      }
      else {
        uint64_t v34 = (uint64_t *)(v29 + 8);
      }
      if (v33) {
        uint64_t v31 = v29;
      }
      uint64_t v29 = *v34;
    }
    while (*v34);
    if (v31 == a1 + 1016 || *(_DWORD *)(v31 + 32) > v30)
    {
LABEL_33:
      int v77 = 0;
      goto LABEL_34;
    }
    int v77 = *(llvm::ValueAsMetadata **)(v31 + 40);
    sub_1CD491B50((uint64_t **)(a1 + 1008), (uint64_t *)v31);
    operator delete((void *)v31);
  }
LABEL_34:
  unsigned int v35 = operator new(0x78uLL);
  v35[13] = v35[13] & 0x38000000 | 1;
  *(void *)unsigned int v35 = 0;
  *((void *)v35 + 1) = 0;
  *((void *)v35 + 2) = 0;
  *((void *)v35 + 3) = v35 + 8;
  uint64_t v36 = *(void *)(a1 + 328);
  __int16 v93 = 260;
  std::string::size_type v89 = (const char *)a2;
  unsigned int v76 = v88;
  uint64_t v80 = (llvm::GlobalValue *)(v35 + 8);
  llvm::GlobalVariable::GlobalVariable((unint64_t *)v35 + 4, v36, v79, 0, 0, 0, &v89, 0, 0, (llvm::Type *)(v88 | 0x100000000), 0);
  char v37 = *(unsigned char *)(a2 + 23);
  int v38 = v37;
  uint64_t v39 = v37 & 0x7F;
  if (v38 < 0) {
    uint64_t v39 = *(void *)(a2 + 8);
  }
  if (!v39)
  {
    std::string::size_type v89 = (const char *)(v35 + 8);
    size_t v65 = *(llvm::GlobalValue ***)(a1 + 1040);
    if ((unint64_t)v65 >= *(void *)(a1 + 1048))
    {
      uint64_t v66 = sub_1CBC13470((void **)(a1 + 1032), &v89);
    }
    else
    {
      llvm::Module *v65 = v80;
      uint64_t v66 = v65 + 1;
    }
    *(void *)(a1 + 1040) = v66;
  }
  if (v85) {
    llvm::GlobalVariable::setInitializer((uint64_t)v80, v85);
  }
  *((unsigned char *)v35 + 112) = v35[28] & 0xFE | v87;
  sub_1CC1966A4(v80, a4);
  if (a8) {
    v35[16] |= 0x4000u;
  }
  unint64_t v40 = v23 == 43;
  sub_1CC196644((uint64_t)v80, v15);
  unsigned int v41 = v35[16] & 0xFFFFE03F;
  *((unsigned char *)v35 + 112) = v35[28] & 0xFD | (2 * v40);
  v35[16] = ((a7 & 3) << 8) & 0xE33F | ((a9 & 7) << 10) | ((a10 & 3) << 6) | v41;
  if (v77)
  {
    uint64_t v42 = *(void *)v77;
    if (v42 == llvm::Type::getPointerTo(v79, v76))
    {
      llvm::Value::doRAUW(v77, v80, (llvm::Value *)1);
      llvm::GlobalValue::eraseFromParent(v77);
      goto LABEL_44;
    }
    size_t v67 = "forward reference and definition of global have different types";
LABEL_93:
    std::string::size_type v89 = v67;
    __int16 v93 = 259;
    uint64_t v20 = a1 + 168;
    uint64_t v21 = v78;
    return llvm::LLLexer::Error(v20, v21, (llvm::Twine *)&v89);
  }
LABEL_44:
  if (*(_DWORD *)(a1 + 224) != 4)
  {
LABEL_80:
    std::string::size_type v89 = **(const char ***)(a1 + 328);
    uint64_t v90 = &v92;
    uint64_t v91 = 0x800000000;
    __p[0] = 0;
    __p[1] = 0;
    std::string::size_type v84 = 0;
    uint64_t v19 = llvm::LLParser::parseFnAttributeValuePairs(a1, (uint64_t)&v89, (char **)__p, 0, &v82.__r_.__value_.__l.__data_);
    uint64_t v62 = (char *)__p[0];
    if ((v19 & 1) == 0)
    {
      uint64_t v63 = (char *)__p[1];
      if (v91 || __p[0] != __p[1])
      {
        *((void *)v35 + 13) = llvm::AttributeSet::get(*(llvm::AttributeSet **)a1, (uint64_t **)&v89, v61);
        int v81 = (uint64_t *)(v35 + 8);
        int v64 = sub_1CD4F40F4((uint64_t **)(a1 + 1112), (unint64_t)v80, &v81);
        sub_1CC19E0C8(v64 + 5, v62, v63, (v63 - v62) >> 2);
      }
    }
    if (v62) {
      operator delete(v62);
    }
    if (v90 != &v92) {
      free(v90);
    }
    return v19;
  }
  while (1)
  {
    int v43 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v43;
    if (v43 > 92)
    {
      if (v43 == 93)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        char v51 = *(unsigned char *)(a1 + 255);
        BOOL v52 = v51 < 0;
        if (v51 >= 0) {
          unint64_t v53 = (void *)(a1 + 232);
        }
        else {
          unint64_t v53 = *(void **)(a1 + 232);
        }
        size_t v54 = v51 & 0x7F;
        if (v52) {
          size_t v55 = *(void *)(a1 + 240);
        }
        else {
          size_t v55 = v54;
        }
        llvm::GlobalValue::setPartition(v80, v53, v55);
        uint64_t v49 = a1;
        unint64_t v50 = "expected partition string";
LABEL_68:
        if (llvm::LLParser::parseToken(v49, 442, v50)) {
          return 1;
        }
        goto LABEL_69;
      }
      if (v43 == 441)
      {
        if (llvm::LLParser::parseGlobalObjectMetadataAttachment((llvm::LLParser *)a1, v80)) {
          return 1;
        }
        goto LABEL_69;
      }
    }
    else
    {
      if (v43 == 90)
      {
        LOWORD(v89) = 0;
        if (llvm::LLParser::parseOptionalAlignment(a1, &v89, 0)) {
          return 1;
        }
        unint64_t v40 = v40 & 0xFFFFFFFFFFFF0000 | (unsigned __int16)v89;
        llvm::GlobalObject::setAlignment((uint64_t)v80, v40);
        goto LABEL_69;
      }
      if (v43 == 92)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        char v44 = *(unsigned char *)(a1 + 255);
        BOOL v45 = v44 < 0;
        if (v44 >= 0) {
          unsigned int v46 = (void *)(a1 + 232);
        }
        else {
          unsigned int v46 = *(void **)(a1 + 232);
        }
        size_t v47 = v44 & 0x7F;
        if (v45) {
          size_t v48 = *(void *)(a1 + 240);
        }
        else {
          size_t v48 = v47;
        }
        llvm::GlobalObject::setSection(v80, v46, v48);
        uint64_t v49 = a1;
        unint64_t v50 = "expected global section string";
        goto LABEL_68;
      }
    }
    __p[0] = 0;
    char v56 = *(unsigned char *)(a2 + 23);
    BOOL v57 = v56 < 0;
    if (v56 >= 0) {
      char v58 = (const std::string::value_type *)a2;
    }
    else {
      char v58 = *(const std::string::value_type **)a2;
    }
    std::string::size_type v59 = v56 & 0x7F;
    if (v57) {
      std::string::size_type v60 = *(void *)(a2 + 8);
    }
    else {
      std::string::size_type v60 = v59;
    }
    if (llvm::LLParser::parseOptionalComdat(a1, v58, v60, (uint64_t *)__p)) {
      return 1;
    }
    if (!__p[0]) {
      break;
    }
    llvm::GlobalObject::setComdat(v80, (llvm::Comdat *)__p[0]);
LABEL_69:
    if (*(_DWORD *)(a1 + 224) != 4) {
      goto LABEL_80;
    }
  }
  std::string::size_type v89 = "unknown global variable property!";
  __int16 v93 = 259;
  uint64_t v21 = *(char **)(a1 + 216);
  uint64_t v20 = a1 + 168;
  return llvm::LLLexer::Error(v20, v21, (llvm::Twine *)&v89);
}

uint64_t llvm::LLParser::parseMDString(uint64_t **this, llvm::MDString **a2)
{
  memset(&__p, 0, sizeof(__p));
  uint64_t v4 = llvm::LLParser::parseStringConstant((uint64_t)this, &__p);
  if ((v4 & 1) == 0)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    *a2 = (llvm::MDString *)llvm::MDString::get(*this, (unsigned __int8 *)p_p, size);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v4;
}

uint64_t llvm::LLParser::parseMDNodeID(llvm::LLParser *this, llvm::MDNode **a2)
{
  uint64_t v4 = (uint64_t *)*((void *)this + 27);
  unsigned int v15 = 0;
  uint64_t v5 = llvm::LLParser::parseUInt32((char **)this, &v15);
  if ((v5 & 1) == 0)
  {
    uint64_t v7 = (uint64_t *)*((void *)this + 118);
    for (i = v15; v7; uint64_t v7 = (uint64_t *)*v7)
    {
      unsigned int v14 = *((_DWORD *)v7 + 8);
      if (v15 >= v14)
      {
        if (v14 >= v15)
        {
          *a2 = (llvm::MDNode *)sub_1CD4F3FDC((uint64_t **)this + 117, v15, &v15)[5];
          return v5;
        }
        ++v7;
      }
    }
    __int16 v9 = sub_1CD4F3D04((uint64_t **)this + 120, v15, &v15);
    Impl = llvm::MDTuple::getImpl(*(void *)this, 0, 0, 2, 1);
    int v12 = (llvm::MDNode *)v9[5];
    v9[5] = (uint64_t *)Impl;
    if (v12)
    {
      llvm::MDNode::deleteTemporary(v12, v11);
      Impl = (llvm::MDNode *)v9[5];
    }
    v9[6] = v4;
    *a2 = Impl;
    unsigned int v13 = sub_1CD4F3FDC((uint64_t **)this + 117, i, &v15);
    sub_1CC19E068((unsigned __int8 **)v13 + 5, (unsigned __int8 *)*a2);
  }
  return v5;
}

uint64_t llvm::LLParser::parseUInt32(char **this, unsigned int *a2)
{
  uint64_t v3 = (llvm::LLLexer *)(this + 21);
  if (*((_DWORD *)this + 56) != 457 || !*((unsigned char *)this + 316))
  {
    uint64_t v10 = "expected integer";
LABEL_13:
    uint64_t v11 = v10;
    __int16 v12 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, this[27], (llvm::Twine *)&v11);
  }
  uint64_t v5 = (unint64_t **)(this + 38);
  unsigned int v6 = *((_DWORD *)this + 78);
  if (v6 >= 0x41)
  {
    if (v6 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(this + 38)) > 0x40)
    {
LABEL_12:
      uint64_t v10 = "expected 32-bit integer (too large)";
      goto LABEL_13;
    }
    unint64_t v7 = **v5;
  }
  else
  {
    unint64_t v7 = (unint64_t)*v5;
  }
  if (v7 > 0x100000000 || HIDWORD(v7)) {
    goto LABEL_12;
  }
  *a2 = v7;
  int v8 = llvm::LLLexer::LexToken(v3);
  uint64_t result = 0;
  *((_DWORD *)this + 56) = v8;
  return result;
}

uint64_t llvm::LLParser::parseDIExpression(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  v39[8] = *MEMORY[0x1E4F143B8];
  unsigned int v6 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  char v37 = v39;
  uint64_t v38 = 0x800000000;
  int v9 = *((_DWORD *)this + 56);
  if (v9 == 13)
  {
LABEL_5:
    if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here"))
    {
      uint64_t v7 = 1;
    }
    else
    {
      uint64_t v7 = 0;
      *a2 = llvm::DIExpression::getImpl(*(void **)this, v37, v38, a3, 1);
    }
    goto LABEL_36;
  }
  while (1)
  {
    if (v9 == 444)
    {
      char v16 = *((unsigned char *)this + 255);
      BOOL v17 = v16 < 0;
      if (v16 >= 0) {
        __int16 v18 = (char *)this + 232;
      }
      else {
        __int16 v18 = (char *)*((void *)this + 29);
      }
      uint64_t v19 = v16 & 0x7F;
      if (v17) {
        uint64_t v20 = *((void *)this + 30);
      }
      else {
        uint64_t v20 = v19;
      }
      unsigned int AttributeEncoding = llvm::dwarf::getAttributeEncoding((uint64_t)v18, v20);
      if (!AttributeEncoding)
      {
        int v25 = "invalid DWARF attribute encoding '";
        goto LABEL_40;
      }
      goto LABEL_25;
    }
    if (v9 != 457)
    {
      if (v9 != 450) {
        goto LABEL_38;
      }
      char v10 = *((unsigned char *)this + 255);
      BOOL v11 = v10 < 0;
      if (v10 >= 0) {
        __int16 v12 = (char *)this + 232;
      }
      else {
        __int16 v12 = (char *)*((void *)this + 29);
      }
      uint64_t v13 = v10 & 0x7F;
      if (v11) {
        uint64_t v14 = *((void *)this + 30);
      }
      else {
        uint64_t v14 = v13;
      }
      unsigned int AttributeEncoding = llvm::dwarf::getOperationEncoding((uint64_t)v12, v14);
      if (!AttributeEncoding)
      {
        int v25 = "invalid DWARF op '";
LABEL_40:
        v31[0] = (uint64_t)v25;
        __int16 v32 = 259;
        __int16 v30 = 260;
        v29[0] = (uint64_t)this + 232;
        sub_1CB8F1E58(v31, v29, (uint64_t)v33);
        int v27 = "'";
        __int16 v28 = 259;
        char v26 = (uint64_t *)&v27;
        goto LABEL_41;
      }
LABEL_25:
      unsigned int v21 = AttributeEncoding;
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      if (v38 >= (unint64_t)HIDWORD(v38)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v37[v38] = v21;
      LODWORD(v38) = v38 + 1;
      int v22 = *((_DWORD *)this + 56);
      goto LABEL_27;
    }
    if (!*((unsigned char *)this + 316))
    {
LABEL_38:
      v35[0] = "expected unsigned integer";
      __int16 v36 = 259;
      goto LABEL_42;
    }
    unsigned int v23 = *((_DWORD *)this + 78);
    int v24 = (void *)((char *)this + 304);
    if (v23 >= 0x41) {
      break;
    }
LABEL_33:
    if (v38 >= (unint64_t)HIDWORD(v38)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v37[v38] = *v24;
    LODWORD(v38) = v38 + 1;
    int v22 = llvm::LLLexer::LexToken(v6);
    *((_DWORD *)this + 56) = v22;
LABEL_27:
    if (v22 != 4) {
      goto LABEL_5;
    }
    int v9 = llvm::LLLexer::LexToken(v6);
    *((_DWORD *)this + 56) = v9;
  }
  if (v23 - llvm::APInt::countLeadingZerosSlowCase((llvm::LLParser *)((char *)this + 304)) <= 0x40)
  {
    int v24 = (void *)*((void *)this + 38);
    goto LABEL_33;
  }
  v33[0] = (uint64_t)"element too large, limit is ";
  __int16 v34 = 259;
  v29[0] = -1;
  __int16 v32 = 268;
  v31[0] = (uint64_t)v29;
  char v26 = v31;
LABEL_41:
  sub_1CB8F1E58(v33, v26, (uint64_t)v35);
LABEL_42:
  uint64_t v7 = llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v35);
LABEL_36:
  if (v37 != v39) {
    free(v37);
  }
  return v7;
}

uint64_t llvm::LLParser::parseSpecializedMDNode(char **this, llvm::MDNode **a2, int a3)
{
  unsigned int v6 = this + 29;
  if (sub_1CBA86C10(this + 29, "DILocation"))
  {
    return llvm::LLParser::parseDILocation((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIExpression"))
  {
    return llvm::LLParser::parseDIExpression((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIGlobalVariableExpression"))
  {
    return llvm::LLParser::parseDIGlobalVariableExpression((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "GenericDINode"))
  {
    return llvm::LLParser::parseGenericDINode((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DISubrange"))
  {
    return llvm::LLParser::parseDISubrange((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIEnumerator"))
  {
    return llvm::LLParser::parseDIEnumerator((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIBasicType"))
  {
    return llvm::LLParser::parseDIBasicType((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIDerivedType"))
  {
    return llvm::LLParser::parseDIDerivedType((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DICompositeType"))
  {
    return llvm::LLParser::parseDICompositeType((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DISubroutineType"))
  {
    return llvm::LLParser::parseDISubroutineType((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIFile"))
  {
    return llvm::LLParser::parseDIFile((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DICompileUnit"))
  {
    return llvm::LLParser::parseDICompileUnit((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DISubprogram"))
  {
    return llvm::LLParser::parseDISubprogram((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DILexicalBlock"))
  {
    return llvm::LLParser::parseDILexicalBlock((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DILexicalBlockFile"))
  {
    return llvm::LLParser::parseDILexicalBlockFile((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DINamespace"))
  {
    return llvm::LLParser::parseDINamespace((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIModule"))
  {
    return llvm::LLParser::parseDIModule((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DITemplateTypeParameter"))
  {
    return llvm::LLParser::parseDITemplateTypeParameter((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DITemplateValueParameter"))
  {
    return llvm::LLParser::parseDITemplateValueParameter((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIGlobalVariable"))
  {
    return llvm::LLParser::parseDIGlobalVariable((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DILocalVariable"))
  {
    return llvm::LLParser::parseDILocalVariable((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DILabel"))
  {
    return llvm::LLParser::parseDILabel((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIObjCProperty"))
  {
    return llvm::LLParser::parseDIObjCProperty((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIImportedEntity"))
  {
    return llvm::LLParser::parseDIImportedEntity((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIMacro"))
  {
    return llvm::LLParser::parseDIMacro((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIMacroFile"))
  {
    return llvm::LLParser::parseDIMacroFile((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DICommonBlock"))
  {
    return llvm::LLParser::parseDICommonBlock((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIArgList"))
  {
    return llvm::LLParser::parseDIArgList((llvm::LLParser *)this, a2, a3, 0);
  }
  else if (sub_1CBA86C10(v6, "DIStringType"))
  {
    return llvm::LLParser::parseDIStringType((llvm::LLParser *)this, a2, a3);
  }
  else if (sub_1CBA86C10(v6, "DIGenericSubrange"))
  {
    return llvm::LLParser::parseDIGenericSubrange((llvm::LLParser *)this, a2, a3);
  }
  else
  {
    int v8 = "expected metadata type";
    __int16 v9 = 259;
    return llvm::LLLexer::Error((uint64_t)(this + 21), this[27], (llvm::Twine *)&v8);
  }
}

uint64_t llvm::LLParser::parseMDTuple(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  v11[16] = *MEMORY[0x1E4F143B8];
  __int16 v9 = v11;
  uint64_t v10 = 0x1000000000;
  uint64_t v6 = llvm::LLParser::parseMDNodeVector(this, (uint64_t)&v9);
  if ((v6 & 1) == 0)
  {
    if (a3) {
      uint64_t v7 = sub_1CD4E3F38(*(void *)this, v9, v10);
    }
    else {
      uint64_t v7 = sub_1CD4E3F44(*(void *)this, v9, v10);
    }
    *a2 = v7;
  }
  if (v9 != v11) {
    free(v9);
  }
  return v6;
}

uint64_t llvm::LLParser::skipModuleSummaryEntry(llvm::LLParser *this)
{
  uint64_t v2 = (llvm::LLParser *)((char *)this + 168);
  int v3 = *((_DWORD *)this + 56);
  if (v3 <= 356)
  {
    if (v3 != 96 && v3 != 353) {
      goto LABEL_17;
    }
  }
  else
  {
    if (v3 == 357)
    {
      return llvm::LLParser::parseSummaryIndexFlags(this);
    }
    if (v3 == 358)
    {
      return llvm::LLParser::parseBlockCount(this);
    }
    if (v3 != 401)
    {
LABEL_17:
      uint64_t v6 = "Expected 'gv', 'module', 'typeid', 'flags' or 'blockcount' at the start of summary entry";
      goto LABEL_18;
    }
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' at start of summary entry") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' at start of summary entry") & 1) != 0)
  {
    return 1;
  }
  int v7 = *((_DWORD *)this + 56);
  int v8 = 1;
  while (1)
  {
    if (v7 == 12)
    {
      ++v8;
      goto LABEL_27;
    }
    if (v7 == 13)
    {
      --v8;
      goto LABEL_27;
    }
    if (!v7) {
      break;
    }
LABEL_27:
    int v7 = llvm::LLLexer::LexToken(v2);
    uint64_t v4 = 0;
    *((_DWORD *)this + 56) = v7;
    if (!v8) {
      return v4;
    }
  }
  uint64_t v6 = "found end of file while parsing summary entry";
LABEL_18:
  __int16 v9 = v6;
  __int16 v10 = 259;
  return llvm::LLLexer::Error((uint64_t)v2, *((char **)this + 27), (llvm::Twine *)&v9);
}

uint64_t llvm::LLParser::parseSummaryIndexFlags(llvm::LLParser *this)
{
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here")) {
    return 1;
  }
  unint64_t v5 = 0;
  uint64_t v2 = llvm::LLParser::parseUInt64((char **)this, &v5);
  if ((v2 & 1) == 0)
  {
    uint64_t v4 = (unsigned char *)*((void *)this + 42);
    if (v4) {
      llvm::ModuleSummaryIndex::setFlags(v4, v5);
    }
  }
  return v2;
}

uint64_t llvm::LLParser::parseBlockCount(llvm::LLParser *this)
{
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here")) {
    return 1;
  }
  unint64_t v4 = 0;
  uint64_t result = llvm::LLParser::parseUInt64((char **)this, &v4);
  if ((result & 1) == 0)
  {
    uint64_t v3 = *((void *)this + 42);
    if (v3) {
      *(void *)(v3 + 296) = v4;
    }
  }
  return result;
}

uint64_t llvm::LLParser::parseGVEntry(llvm::LLParser *this, unsigned int a2)
{
  unint64_t v4 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0)
  {
    return 1;
  }
  memset(&v22, 0, sizeof(v22));
  unint64_t v21 = 0;
  int v7 = *((_DWORD *)this + 56);
  if (v7 == 354)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v4);
    if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
      || (llvm::LLParser::parseUInt64((char **)this, &v21) & 1) != 0)
    {
      goto LABEL_11;
    }
  }
  else
  {
    if (v7 != 355)
    {
      int v8 = (char *)*((void *)this + 27);
      __int16 v9 = "expected name or guid tag";
LABEL_15:
      uint64_t v19 = v9;
      __int16 v20 = 259;
      uint64_t v10 = llvm::LLLexer::Error((uint64_t)v4, v8, (llvm::Twine *)&v19);
LABEL_16:
      uint64_t v5 = v10;
      goto LABEL_12;
    }
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v4);
    if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
      || (llvm::LLParser::parseStringConstant((uint64_t)this, &v22) & 1) != 0)
    {
      goto LABEL_11;
    }
  }
  if (*((_DWORD *)this + 56) == 4)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v4);
    if ((llvm::LLParser::parseToken((uint64_t)this, 356, "expected 'summaries' here") & 1) == 0
      && (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) == 0
      && (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) == 0)
    {
      for (int i = *((_DWORD *)this + 56); ; *((_DWORD *)this + 56) = i)
      {
        switch(i)
        {
          case 94:
            if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
              sub_1CB8BDF7C((uint64_t)&__p, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
            }
            else {
              std::string __p = v22;
            }
            char v12 = llvm::LLParser::parseAliasSummary(this);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            {
              uint64_t v13 = (void *)__p.__r_.__value_.__r.__words[0];
              goto LABEL_33;
            }
            break;
          case 387:
            if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
              sub_1CB8BDF7C((uint64_t)&v15, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
            }
            else {
              std::string v15 = v22;
            }
            char v12 = llvm::LLParser::parseVariableSummary((uint64_t)this);
            if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
            {
              uint64_t v13 = (void *)v15.__r_.__value_.__r.__words[0];
LABEL_33:
              operator delete(v13);
            }
            break;
          case 365:
            if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
              sub_1CB8BDF7C((uint64_t)&v16, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
            }
            else {
              std::string v16 = v22;
            }
            char v12 = llvm::LLParser::parseFunctionSummary((uint64_t)this);
            if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
            {
              uint64_t v13 = (void *)v16.__r_.__value_.__r.__words[0];
              goto LABEL_33;
            }
            break;
          default:
            int v8 = (char *)*((void *)this + 27);
            __int16 v9 = "expected summary type";
            goto LABEL_15;
        }
        if (v12) {
          break;
        }
        if (*((_DWORD *)this + 56) != 4)
        {
          if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
            break;
          }
          uint64_t v10 = llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here");
          goto LABEL_16;
        }
        int i = llvm::LLLexer::LexToken(v4);
      }
    }
  }
  else if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) == 0)
  {
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      sub_1CB8BDF7C((uint64_t)&v18, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
    }
    else {
      std::string v18 = v22;
    }
    uint64_t v17 = 0;
    llvm::LLParser::addGlobalValueToIndex((uint64_t)this, &v18, v21, 0, a2, &v17);
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    uint64_t v5 = 0;
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v5 = 1;
LABEL_12:
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
  return v5;
}

uint64_t llvm::LLParser::parseModuleEntry(llvm::LLParser *this, unsigned int a2)
{
  unsigned int v16 = a2;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  memset(&__p, 0, sizeof(__p));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 351, "expected 'path' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, &__p) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 352, "expected 'hash' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0
    || (llvm::LLParser::parseUInt32((char **)this, v13) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseUInt32((char **)this, &v13[1]) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseUInt32((char **)this, &v13[2]) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseUInt32((char **)this, &v13[3]) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseUInt32((char **)this, &v14) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0)
  {
    uint64_t v4 = 1;
  }
  else
  {
    uint64_t v6 = *((void *)this + 42);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    long long v20 = *(_OWORD *)v13;
    unsigned int v21 = v14;
    uint64_t v17 = p_p;
    size_t v18 = size;
    uint64_t v19 = a2;
    __int16 v9 = sub_1CD4F289C(v6 + 24, (unsigned __int8 *)p_p, size, &v19);
    uint64_t v10 = *v9 + 40;
    BOOL v11 = *(uint64_t **)*v9;
    char v12 = sub_1CD4F3D04((uint64_t **)this + 157, a2, &v16);
    uint64_t v4 = 0;
    v12[5] = (uint64_t *)v10;
    v12[6] = v11;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v4;
}

uint64_t llvm::LLParser::parseTypeIdEntry(llvm::LLParser *this, unsigned int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  memset(&__p, 0, sizeof(__p));
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 355, "expected 'name' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, &__p) & 1) != 0
    || ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (uint64_t v6 = (int *)&__p)
      : (uint64_t v6 = (int *)__p.__r_.__value_.__r.__words[0]),
        (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (size_t v7 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F)
      : (size_t v7 = __p.__r_.__value_.__l.__size_),
        (int v8 = sub_1CD4EFDD8(*((void *)this + 42), v6, v7),
         (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) != 0)
     || (llvm::LLParser::parseTypeIdSummary((uint64_t)this, (uint64_t)v8) & 1) != 0
     || (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) != 0))
  {
    uint64_t v4 = 1;
  }
  else
  {
    __int16 v9 = (char *)*((void *)this + 155);
    if (v9)
    {
      uint64_t v10 = (uint64_t **)((char *)this + 1232);
      BOOL v11 = (char *)this + 1240;
      char v12 = (char *)this + 1240;
      do
      {
        unsigned int v13 = *((_DWORD *)v9 + 8);
        BOOL v14 = v13 >= a2;
        if (v13 >= a2) {
          std::string v15 = (char **)v9;
        }
        else {
          std::string v15 = (char **)(v9 + 8);
        }
        if (v14) {
          char v12 = v9;
        }
        __int16 v9 = *v15;
      }
      while (*v15);
      if (v12 != v11 && *((_DWORD *)v12 + 8) <= a2)
      {
        unsigned int v16 = (void *)*((void *)v12 + 5);
        for (int i = (void *)*((void *)v12 + 6); v16 != i; *v18 = *(void *)v23)
        {
          uint64_t v19 = (void *)*v16;
          v16 += 2;
          size_t v18 = v19;
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = (int *)&__p;
          }
          else {
            p_p = (int *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
          }
          else {
            size_t size = __p.__r_.__value_.__l.__size_;
          }
          long long v24 = xmmword_1CFAC4320;
          uint64_t v25 = 0;
          llvm::MD5::update((int *)&v24, p_p, size);
          llvm::MD5::final((int *)&v24, v23);
        }
        sub_1CD4F4E84(v10, (uint64_t *)v12);
      }
    }
    uint64_t v4 = 0;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v4;
}

uint64_t llvm::LLParser::parseGlobalTypeAndValue(llvm::ConstantInt **this, llvm::Constant **a2)
{
  uint64_t v5 = 0;
  uint64_t v6 = "expected type";
  __int16 v7 = 259;
  if (llvm::LLParser::parseType((llvm::LLParser *)this, &v5, (const llvm::Twine *)&v6, 0)) {
    return 1;
  }
  else {
    return llvm::LLParser::parseGlobalValue(this, v5, a2);
  }
}

uint64_t llvm::LLParser::parseOptionalAddrSpace(llvm::LLParser *this, unsigned int *a2, unsigned int a3)
{
  *a2 = a3;
  if (*((_DWORD *)this + 56) != 91) {
    return 0;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' in address space") & 1) != 0
    || (llvm::LLParser::parseUInt32((char **)this, a2) & 1) != 0)
  {
    return 1;
  }

  return llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' in address space");
}

uint64_t llvm::LLParser::parseGlobalValue(llvm::ConstantInt **this, llvm::Type *a2, llvm::Constant **a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  int v12 = 0;
  *(void *)unsigned int v13 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v6 = 1;
  int v19 = 1;
  char v20 = 0;
  sub_1CB892E1C((uint64_t)v21, 0.0);
  void v21[5] = 0;
  char v22 = 0;
  BOOL v11 = 0;
  if ((llvm::LLParser::parseValID(this, &v12, 0, a2) & 1) == 0)
  {
    uint64_t v6 = llvm::LLParser::convertValIDToValue(this, (uint64_t)a2, &v12, &v11, 0);
    __int16 v7 = (llvm::Constant *)v11;
    if (v11)
    {
      if (v11[16] >= 0x15u) {
        __int16 v7 = 0;
      }
      *a3 = v7;
      if (!v7)
      {
        __int16 v9 = "global values must be constants";
        __int16 v10 = 259;
        uint64_t v6 = llvm::LLLexer::Error((uint64_t)(this + 21), *(char **)v13, (llvm::Twine *)&v9);
      }
    }
  }
  sub_1CD4F271C((uint64_t)&v12);
  return v6;
}

uint64_t llvm::LLParser::parseOptionalAlignment(uint64_t a1, _WORD *a2, int a3)
{
  uint64_t result = 0;
  *a2 = 0;
  if (*(_DWORD *)(a1 + 224) == 90)
  {
    int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v7;
    int v8 = *(char **)(a1 + 216);
    unint64_t v13 = 0;
    if (a3 && v7 == 12)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if ((llvm::LLParser::parseUInt64((char **)a1, &v13) & 1) == 0)
      {
        if (*(_DWORD *)(a1 + 224) != 13)
        {
          __int16 v10 = "expected ')'";
LABEL_13:
          BOOL v11 = v10;
          __int16 v12 = 259;
          return llvm::LLLexer::Error(a1 + 168, v8, (llvm::Twine *)&v11);
        }
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
LABEL_9:
        uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] == 1)
        {
          if (v13 < 0x100000001)
          {
            uint64_t result = 0;
            *a2 = (63 - __clz(v13)) | 0x100;
            return result;
          }
          __int16 v10 = "huge alignments are not supported yet";
        }
        else
        {
          __int16 v10 = "alignment is not a power of two";
        }
        goto LABEL_13;
      }
    }
    else if ((llvm::LLParser::parseUInt64((char **)a1, &v13) & 1) == 0)
    {
      goto LABEL_9;
    }
    return 1;
  }
  return result;
}

uint64_t llvm::LLParser::parseGlobalObjectMetadataAttachment(llvm::LLParser *this, llvm::GlobalObject *a2)
{
  unsigned int v6 = 0;
  uint64_t v5 = 0;
  uint64_t v3 = llvm::LLParser::parseMetadataAttachment(this, &v6, &v5);
  if ((v3 & 1) == 0) {
    llvm::Value::addMetadata(a2, v6, v5);
  }
  return v3;
}

uint64_t llvm::LLParser::parseOptionalComdat(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, uint64_t *a4)
{
  *a4 = 0;
  if (*(_DWORD *)(a1 + 224) != 244) {
    return 0;
  }
  uint8x8_t v9 = (llvm::LLLexer *)(a1 + 168);
  uint64_t v10 = *(void *)(a1 + 216);
  int v11 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v11;
  if (v11 == 12)
  {
    int v12 = llvm::LLLexer::LexToken(v9);
    *(_DWORD *)(a1 + 224) = v12;
    if (v12 == 439)
    {
      *a4 = llvm::LLParser::getComdat(a1, a1 + 232, *(void *)(a1 + 216));
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v9);
      return (llvm::LLParser::parseToken(a1, 13, "expected ')' after comdat var") & 1) != 0;
    }
    unint64_t v13 = "expected comdat variable";
LABEL_11:
    v14.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
    __int16 v15 = 259;
    return llvm::LLLexer::Error((uint64_t)v9, *(char **)(a1 + 216), (llvm::Twine *)&v14);
  }
  if (!a3)
  {
    unint64_t v13 = "comdat cannot be unnamed";
    goto LABEL_11;
  }
  std::string::__init(&v14, a2, a3);
  *a4 = llvm::LLParser::getComdat(a1, (uint64_t)&v14, v10);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  return 0;
}

uint64_t llvm::LLParser::parseEnumAttribute(uint64_t a1, unsigned int a2, uint64_t **a3)
{
  if (a2 - 68 <= 5)
  {
    int v6 = *(_DWORD *)(a1 + 224);
    return llvm::LLParser::parseRequiredTypeAttr(a1, a3, v6, a2);
  }
  else
  {
    llvm::AttrBuilder::addAttribute(a3, a2);
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    return 0;
  }
}

uint64_t llvm::LLParser::parseRequiredTypeAttr(uint64_t a1, uint64_t **a2, int a3, int a4)
{
  int v12 = 0;
  if (*(_DWORD *)(a1 + 224) != a3) {
    return 1;
  }
  int v8 = (llvm::LLLexer *)(a1 + 168);
  int v9 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v9;
  if (v9 != 12)
  {
    uint64_t v10 = *(char **)(a1 + 216);
    int v11 = "expected '('";
LABEL_9:
    v13[0] = v11;
    __int16 v14 = 259;
    return llvm::LLLexer::Error((uint64_t)v8, v10, (llvm::Twine *)v13);
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v8);
  v13[0] = "expected type";
  __int16 v14 = 259;
  if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v12, (const llvm::Twine *)v13, 0) & 1) == 0)
  {
    if (*(_DWORD *)(a1 + 224) == 13)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v8);
      llvm::AttrBuilder::addTypeAttr(a2, a4, (uint64_t)v12);
      return 0;
    }
    uint64_t v10 = *(char **)(a1 + 216);
    int v11 = "expected ')'";
    goto LABEL_9;
  }
  return 1;
}

uint64_t llvm::LLParser::parseOptionalStackAlignment(llvm::LLParser *this, unsigned int *a2)
{
  uint64_t result = 0;
  *a2 = 0;
  if (*((_DWORD *)this + 56) == 99)
  {
    int v5 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v5;
    if (v5 == 12)
    {
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      int v6 = (char *)*((void *)this + 27);
      if (llvm::LLParser::parseUInt32((char **)this, a2)) {
        return 1;
      }
      if (*((_DWORD *)this + 56) == 13)
      {
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
        uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)*a2);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.i32[0] == 1) {
          return 0;
        }
        int v11 = "stack alignment is not a power of two";
        __int16 v12 = 259;
        int v9 = (char *)this + 168;
        int v7 = v6;
        return llvm::LLLexer::Error((uint64_t)v9, v7, (llvm::Twine *)&v11);
      }
      int v7 = (char *)*((void *)this + 27);
      int v8 = "expected ')'";
    }
    else
    {
      int v7 = (char *)*((void *)this + 27);
      int v8 = "expected '('";
    }
    int v11 = v8;
    __int16 v12 = 259;
    int v9 = (char *)this + 168;
    return llvm::LLLexer::Error((uint64_t)v9, v7, (llvm::Twine *)&v11);
  }
  return result;
}

uint64_t llvm::LLParser::parseAllocSizeArguments(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  int v6 = (llvm::LLLexer *)(a1 + 168);
  int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v7;
  if (v7 == 12)
  {
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
    if (llvm::LLParser::parseUInt32((char **)a1, a2)) {
      return 1;
    }
    if (*(_DWORD *)(a1 + 224) == 4)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
      unint64_t v13 = *(char **)(a1 + 216);
      unsigned int v15 = 0;
      if (llvm::LLParser::parseUInt32((char **)a1, &v15)) {
        return 1;
      }
      unsigned int v14 = v15;
      if (v15 == *a2)
      {
        long long v16 = "'allocsize' indices can't refer to the same parameter";
        __int16 v17 = 259;
        uint64_t v11 = (uint64_t)v6;
        int v9 = v13;
        return llvm::LLLexer::Error(v11, v9, (llvm::Twine *)&v16);
      }
      if (!*(unsigned char *)(a3 + 4)) {
        *(unsigned char *)(a3 + 4) = 1;
      }
      *(_DWORD *)a3 = v14;
    }
    else
    {
      *(void *)a3 = 0;
    }
    if (*(_DWORD *)(a1 + 224) == 13)
    {
      int v12 = llvm::LLLexer::LexToken(v6);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 224) = v12;
      return result;
    }
    int v9 = *(char **)(a1 + 216);
    uint8x8_t v10 = "expected ')'";
  }
  else
  {
    int v9 = *(char **)(a1 + 216);
    uint8x8_t v10 = "expected '('";
  }
  long long v16 = v10;
  __int16 v17 = 259;
  uint64_t v11 = (uint64_t)v6;
  return llvm::LLLexer::Error(v11, v9, (llvm::Twine *)&v16);
}

uint64_t llvm::LLParser::parseVScaleRangeArguments(llvm::LLParser *this, unsigned int *a2, unsigned int *a3)
{
  int v6 = (llvm::LLParser *)((char *)this + 168);
  int v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v7;
  if (v7 == 12)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
    if (llvm::LLParser::parseUInt32((char **)this, a2)) {
      return 1;
    }
    int v11 = *((_DWORD *)this + 56);
    if (v11 == 4)
    {
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      if (llvm::LLParser::parseUInt32((char **)this, a3)) {
        return 1;
      }
      int v11 = *((_DWORD *)this + 56);
    }
    else
    {
      *a3 = *a2;
    }
    if (v11 == 13)
    {
      int v12 = llvm::LLLexer::LexToken(v6);
      uint64_t result = 0;
      *((_DWORD *)this + 56) = v12;
      return result;
    }
    int v9 = (char *)*((void *)this + 27);
    uint8x8_t v10 = "expected ')'";
  }
  else
  {
    int v9 = (char *)*((void *)this + 27);
    uint8x8_t v10 = "expected '('";
  }
  unint64_t v13 = v10;
  __int16 v14 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v9, (llvm::Twine *)&v13);
}

uint64_t llvm::LLParser::parseOptionalDerefAttrBytes(uint64_t a1, int a2, unint64_t *a3)
{
  *a3 = 0;
  if (*(_DWORD *)(a1 + 224) != a2) {
    return 0;
  }
  int v6 = (llvm::LLLexer *)(a1 + 168);
  int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v7;
  if (v7 != 12)
  {
    int v9 = *(char **)(a1 + 216);
    uint8x8_t v10 = "expected '('";
LABEL_8:
    int v12 = v10;
    __int16 v13 = 259;
    uint64_t v11 = (uint64_t)v6;
    return llvm::LLLexer::Error(v11, v9, (llvm::Twine *)&v12);
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
  int v8 = *(char **)(a1 + 216);
  if (llvm::LLParser::parseUInt64((char **)a1, a3)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 224) != 13)
  {
    int v9 = *(char **)(a1 + 216);
    uint8x8_t v10 = "expected ')'";
    goto LABEL_8;
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
  if (!*a3)
  {
    int v12 = "dereferenceable bytes must be non-zero";
    __int16 v13 = 259;
    uint64_t v11 = (uint64_t)v6;
    int v9 = v8;
    return llvm::LLLexer::Error(v11, v9, (llvm::Twine *)&v12);
  }
  return 0;
}

uint64_t llvm::LLParser::parseOptionalUWTableKind(uint64_t a1, int *a2)
{
  uint64_t v4 = (llvm::LLLexer *)(a1 + 168);
  int v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v5;
  *a2 = 2;
  if (v5 != 12) {
    return 0;
  }
  int v7 = llvm::LLLexer::LexToken(v4);
  *(_DWORD *)(a1 + 224) = v7;
  if (v7 == 240)
  {
    int v8 = 1;
  }
  else
  {
    if (v7 != 241)
    {
      int v9 = *(char **)(a1 + 216);
      uint8x8_t v10 = "expected unwind table kind";
      __int16 v11 = 259;
      return llvm::LLLexer::Error((uint64_t)v4, v9, (llvm::Twine *)&v10);
    }
    int v8 = 2;
  }
  *a2 = v8;
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);

  return llvm::LLParser::parseToken(a1, 13, "expected ')'");
}

uint64_t llvm::LLParser::parseStringAttribute(llvm::LLParser *this, uint64_t **a2)
{
  uint64_t v4 = (llvm::LLParser *)((char *)this + 168);
  if (*((char *)this + 255) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v18, *((const void **)this + 29), *((void *)this + 30));
  }
  else
  {
    *(_OWORD *)uint64_t v18 = *(_OWORD *)((char *)this + 232);
    uint64_t v19 = *((void *)this + 31);
  }
  int v5 = llvm::LLLexer::LexToken(v4);
  *((_DWORD *)this + 56) = v5;
  memset(&__p, 0, sizeof(__p));
  if (v5 == 3)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v4);
    if (llvm::LLParser::parseStringConstant((uint64_t)this, &__p))
    {
      uint64_t v15 = 1;
      goto LABEL_18;
    }
    char v8 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
    std::string::size_type v7 = __p.__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type size = 0;
    std::string::size_type v7 = 0;
    char v8 = 0;
  }
  if (v19 >= 0) {
    int v9 = (unsigned __int8 *)v18;
  }
  else {
    int v9 = (unsigned __int8 *)v18[0];
  }
  if (v19 >= 0) {
    size_t v10 = HIBYTE(v19) & 0x7F;
  }
  else {
    size_t v10 = (size_t)v18[1];
  }
  BOOL v11 = v8 < 0;
  if (v8 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)v7;
  }
  size_t v13 = v8 & 0x7F;
  if (v11) {
    size_t v14 = size;
  }
  else {
    size_t v14 = v13;
  }
  llvm::AttrBuilder::addAttribute(a2, v9, v10, (unsigned __int8 *)p_p, v14);
  uint64_t v15 = 0;
LABEL_18:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  return v15;
}

llvm::Type **llvm::LLParser::checkValidVariableType(uint64_t a1, char *a2, uint64_t *a3, llvm::Type *a4, llvm::Type **a5)
{
  int v5 = a5;
  if (*a5 != a4)
  {
    if (*((unsigned char *)a4 + 8) == 8)
    {
      v30[0] = (uint64_t)"'";
      __int16 v31 = 259;
      sub_1CB8F1E58(v30, a3, (uint64_t)v32);
      v28[0] = (uint64_t)"' is not a basic block";
      __int16 v29 = 259;
      sub_1CB8F1E58(v32, v28, (uint64_t)v33);
      llvm::LLLexer::Error(a1 + 168, a2, (llvm::Twine *)v33);
    }
    else
    {
      long long v24 = "'";
      __int16 v25 = 259;
      sub_1CB8F1E58((uint64_t *)&v24, a3, (uint64_t)v26);
      char v22 = "' defined with type '";
      __int16 v23 = 259;
      sub_1CB8F1E58(v26, (uint64_t *)&v22, (uint64_t)v27);
      sub_1CC196EB4((uint64_t)v18, *v5);
      __int16 v21 = 260;
      char v20 = v18;
      sub_1CB8F1E58(v27, (uint64_t *)&v20, (uint64_t)v28);
      long long v16 = "' but expected '";
      __int16 v17 = 259;
      sub_1CB8F1E58(v28, (uint64_t *)&v16, (uint64_t)v30);
      sub_1CC196EB4((uint64_t)__p, a4);
      __int16 v15 = 260;
      size_t v14 = __p;
      sub_1CB8F1E58(v30, (uint64_t *)&v14, (uint64_t)v32);
      size_t v10 = "'";
      __int16 v11 = 259;
      sub_1CB8F1E58(v32, (uint64_t *)&v10, (uint64_t)v33);
      llvm::LLLexer::Error(a1 + 168, a2, (llvm::Twine *)v33);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      if (v19 < 0) {
        operator delete(v18[0]);
      }
    }
    return 0;
  }
  return v5;
}

void *llvm::LLParser::getGlobalVal(uint64_t a1, uint64_t *a2, llvm::Type *a3, char *a4)
{
  if (a3 && *((unsigned char *)a3 + 8) == 15)
  {
    std::string::size_type v7 = a2;
    char v8 = *(uint64_t **)(*(void *)(a1 + 328) + 112);
    char v9 = *((unsigned char *)a2 + 23);
    BOOL v10 = v9 < 0;
    unint64_t v11 = a2[1];
    if (v9 < 0) {
      a2 = (uint64_t *)*a2;
    }
    unint64_t v12 = v9 & 0x7F;
    if (v10) {
      unint64_t v13 = v11;
    }
    else {
      unint64_t v13 = v12;
    }
    size_t v14 = (llvm::Type **)sub_1CC196FC4(v8, (unsigned __int8 *)a2, v13);
    if (v14 || (uint64_t v15 = sub_1CD4F3EC8(a1 + 984, v7), a1 + 992 != v15) && (v14 = *(llvm::Type ***)(v15 + 56)) != 0)
    {
      std::operator+<char>();
      __int16 v22 = 260;
      v21[0] = (uint64_t)&__p;
      long long v16 = llvm::LLParser::checkValidVariableType(a1, a4, v21, a3, v14);
      if (v20 < 0) {
        operator delete(__p);
      }
    }
    else
    {
      long long v16 = sub_1CC197104(*(void ***)(a1 + 328), (uint64_t)a3);
      v21[0] = (uint64_t)v7;
      __int16 v17 = sub_1CD4F4300(a1 + 984, (uint64_t)v7, v21);
      v17[7] = (uint64_t)v16;
      void v17[8] = (uint64_t)a4;
    }
  }
  else
  {
    v21[0] = (uint64_t)"global variable reference must have pointer type";
    __int16 v22 = 259;
    llvm::LLLexer::Error(a1 + 168, a4, (llvm::Twine *)v21);
    return 0;
  }
  return v16;
}

llvm::Type **llvm::LLParser::getGlobalVal(uint64_t a1, unsigned int a2, llvm::Type *a3, char *a4)
{
  unsigned int v24 = a2;
  if (a3 && *((unsigned char *)a3 + 8) == 15)
  {
    uint64_t v8 = *(void *)(a1 + 1032);
    if (a2 < (unint64_t)((*(void *)(a1 + 1040) - v8) >> 3))
    {
      char v9 = *(llvm::Type ***)(v8 + 8 * a2);
      if (v9) {
        goto LABEL_20;
      }
    }
    uint64_t v10 = *(void *)(a1 + 1016);
    if (!v10) {
      goto LABEL_6;
    }
    uint64_t v14 = a1 + 1016;
    do
    {
      unsigned int v15 = *(_DWORD *)(v10 + 32);
      BOOL v16 = v15 >= a2;
      if (v15 >= a2) {
        __int16 v17 = (uint64_t *)v10;
      }
      else {
        __int16 v17 = (uint64_t *)(v10 + 8);
      }
      if (v16) {
        uint64_t v14 = v10;
      }
      uint64_t v10 = *v17;
    }
    while (*v17);
    if (v14 != a1 + 1016 && *(_DWORD *)(v14 + 32) <= a2 && (char v9 = *(llvm::Type ***)(v14 + 40)) != 0)
    {
LABEL_20:
      char v20 = "@";
      __int16 v21 = 259;
      __int16 v19 = 264;
      LODWORD(v18[0]) = a2;
      sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
      return llvm::LLParser::checkValidVariableType(a1, a4, v22, a3, v9);
    }
    else
    {
LABEL_6:
      unint64_t v11 = sub_1CC197104(*(void ***)(a1 + 328), (uint64_t)a3);
      unint64_t v12 = sub_1CD4F3D04((uint64_t **)(a1 + 1008), a2, &v24);
      v12[5] = (uint64_t *)v11;
      v12[6] = (uint64_t *)a4;
    }
  }
  else
  {
    v22[0] = (uint64_t)"global variable reference must have pointer type";
    __int16 v23 = 259;
    llvm::LLLexer::Error(a1 + 168, a4, (llvm::Twine *)v22);
    return 0;
  }
  return (llvm::Type **)v11;
}

uint64_t llvm::LLParser::getComdat(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 328);
  char v7 = *(unsigned char *)(a2 + 23);
  BOOL v8 = v7 < 0;
  if (v7 >= 0) {
    char v9 = (unsigned __int8 *)a2;
  }
  else {
    char v9 = *(unsigned __int8 **)a2;
  }
  size_t v10 = v7 & 0x7F;
  if (v8) {
    size_t v11 = *(void *)(a2 + 8);
  }
  else {
    size_t v11 = v10;
  }
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(v6 + 120), v9, v11);
  if (Key != -1 && Key != (unint64_t)*(unsigned int *)(v6 + 128)) {
    return *(void *)(*(void *)(v6 + 120) + 8 * Key) + 8;
  }
  inserted = llvm::Module::getOrInsertComdat(v6, v9, v11);
  uint64_t v15 = a2;
  sub_1CD4F4418(a1 + 1056, a2, &v15)[7] = a3;
  return (uint64_t)inserted;
}

uint64_t llvm::LLParser::parseUInt64(char **this, unint64_t *a2)
{
  uint64_t v3 = (llvm::LLLexer *)(this + 21);
  if (*((_DWORD *)this + 56) != 457 || !*((unsigned char *)this + 316))
  {
    size_t v10 = "expected integer";
    __int16 v11 = 259;
    return llvm::LLLexer::Error((uint64_t)(this + 21), this[27], (llvm::Twine *)&v10);
  }
  int v5 = (unint64_t *)(this + 38);
  unsigned int v6 = *((_DWORD *)this + 78);
  if (v6 >= 0x41)
  {
    if (v6 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)(this + 38)) > 0x40)
    {
      unint64_t v7 = -1;
      goto LABEL_5;
    }
    int v5 = (unint64_t *)*v5;
  }
  unint64_t v7 = *v5;
LABEL_5:
  *a2 = v7;
  int v8 = llvm::LLLexer::LexToken(v3);
  uint64_t result = 0;
  *((_DWORD *)this + 56) = v8;
  return result;
}

uint64_t llvm::LLParser::parseTLSModel(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = (llvm::LLLexer *)(a1 + 168);
  int v4 = *(_DWORD *)(a1 + 224);
  if ((v4 - 47) >= 3)
  {
    unint64_t v7 = "expected localdynamic, initialexec or localexec";
    __int16 v8 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, *(char **)(a1 + 216), (llvm::Twine *)&v7);
  }
  else
  {
    *a2 = v4 - 45;
    int v5 = llvm::LLLexer::LexToken(v3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 224) = v5;
  }
  return result;
}

uint64_t llvm::LLParser::parseOptionalParamOrReturnAttrs(llvm::LLParser *this, llvm::AttrBuilder *a2, int a3)
{
  int v6 = 0;
  *((_DWORD *)a2 + 4) = 0;
  while (1)
  {
    while (1)
    {
      int v7 = *((_DWORD *)this + 56);
      if (v7 != 442) {
        break;
      }
      if (llvm::LLParser::parseStringAttribute(this, (uint64_t **)a2)) {
        goto LABEL_11;
      }
    }
    __int16 v8 = (char *)*((void *)this + 27);
    unsigned int v9 = sub_1CC1969A4(v7);
    if (!v9) {
      return v6 & 1;
    }
    int v10 = v9;
    if (llvm::LLParser::parseEnumAttribute((uint64_t)this, v9, (uint64_t **)a2)) {
      break;
    }
    if (a3)
    {
      if ((llvm::Attribute::canUseAsParamAttr(v10) & 1) == 0)
      {
        unint64_t v12 = (char *)this + 168;
        unint64_t v13 = "this attribute does not apply to parameters";
        goto LABEL_13;
      }
    }
    else if ((llvm::Attribute::canUseAsRetAttr(v10) & 1) == 0)
    {
      unint64_t v12 = (char *)this + 168;
      unint64_t v13 = "this attribute does not apply to return values";
LABEL_13:
      uint64_t v14 = v13;
      __int16 v15 = 259;
      v6 |= llvm::LLLexer::Error((uint64_t)v12, v8, (llvm::Twine *)&v14);
    }
  }
LABEL_11:
  LOBYTE(v6) = 1;
  return v6 & 1;
}

llvm::LLLexer *llvm::LLParser::parseOptionalDSOLocal(llvm::LLParser *this, BOOL *a2)
{
  uint64_t result = (llvm::LLParser *)((char *)this + 168);
  int v4 = *((_DWORD *)this + 56);
  if (v4 == 25)
  {
    *a2 = 1;
    goto LABEL_5;
  }
  if (v4 == 26)
  {
    *a2 = 0;
LABEL_5:
    uint64_t result = (llvm::LLLexer *)llvm::LLLexer::LexToken(result);
    *((_DWORD *)this + 56) = result;
    return result;
  }
  *a2 = 0;
  return result;
}

uint64_t llvm::LLParser::parseOptionalCallingConv(llvm::LLParser *this, unsigned int *a2)
{
  int v3 = *((_DWORD *)this + 56) - 105;
  unsigned int v5 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  switch(v3)
  {
    case 0:
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      return llvm::LLParser::parseUInt32((char **)this, a2);
    case 1:
      goto LABEL_57;
    case 2:
      unsigned int v5 = 8;
      goto LABEL_57;
    case 3:
      unsigned int v5 = 9;
      goto LABEL_57;
    case 4:
      unsigned int v5 = 77;
      goto LABEL_57;
    case 5:
      unsigned int v5 = 19;
      goto LABEL_57;
    case 6:
      unsigned int v5 = 64;
      goto LABEL_57;
    case 7:
      unsigned int v5 = 65;
      goto LABEL_57;
    case 8:
      unsigned int v5 = 70;
      goto LABEL_57;
    case 9:
      unsigned int v5 = 80;
      goto LABEL_57;
    case 10:
      unsigned int v5 = 92;
      goto LABEL_57;
    case 11:
      unsigned int v5 = 66;
      goto LABEL_57;
    case 12:
      unsigned int v5 = 67;
      goto LABEL_57;
    case 13:
      unsigned int v5 = 68;
      goto LABEL_57;
    case 14:
      unsigned int v5 = 97;
      goto LABEL_57;
    case 15:
      unsigned int v5 = 98;
      goto LABEL_57;
    case 16:
      unsigned int v5 = 69;
      goto LABEL_57;
    case 17:
      unsigned int v5 = 84;
      goto LABEL_57;
    case 18:
      unsigned int v5 = 85;
      goto LABEL_57;
    case 19:
      unsigned int v5 = 71;
      goto LABEL_57;
    case 20:
      unsigned int v5 = 72;
      goto LABEL_57;
    case 21:
      unsigned int v5 = 76;
      goto LABEL_57;
    case 22:
      unsigned int v5 = 75;
      goto LABEL_57;
    case 23:
      unsigned int v5 = 100;
      goto LABEL_57;
    case 24:
      unsigned int v5 = 101;
      goto LABEL_57;
    case 25:
      unsigned int v5 = 102;
      goto LABEL_57;
    case 26:
      unsigned int v5 = 103;
      goto LABEL_57;
    case 27:
      unsigned int v5 = 104;
      goto LABEL_57;
    case 28:
      unsigned int v5 = 105;
      goto LABEL_57;
    case 29:
      unsigned int v5 = 106;
      goto LABEL_57;
    case 30:
      unsigned int v5 = 107;
      goto LABEL_57;
    case 32:
      unsigned int v5 = 108;
      goto LABEL_57;
    case 33:
      unsigned int v5 = 78;
      goto LABEL_57;
    case 34:
      unsigned int v5 = 79;
      goto LABEL_57;
    case 35:
      unsigned int v5 = 12;
      goto LABEL_57;
    case 36:
      unsigned int v5 = 13;
      goto LABEL_57;
    case 37:
      unsigned int v5 = 16;
      goto LABEL_57;
    case 38:
      unsigned int v5 = 20;
      goto LABEL_57;
    case 39:
      unsigned int v5 = 14;
      goto LABEL_57;
    case 40:
      unsigned int v5 = 15;
      goto LABEL_57;
    case 41:
      unsigned int v5 = 10;
      goto LABEL_57;
    case 42:
      unsigned int v5 = 83;
      goto LABEL_57;
    case 43:
      unsigned int v5 = 81;
      goto LABEL_57;
    case 44:
      unsigned int v5 = 82;
      goto LABEL_57;
    case 45:
      unsigned int v5 = 17;
      goto LABEL_57;
    case 46:
      unsigned int v5 = 87;
      goto LABEL_57;
    case 47:
      unsigned int v5 = 95;
      goto LABEL_57;
    case 48:
      unsigned int v5 = 93;
      goto LABEL_57;
    case 49:
      unsigned int v5 = 96;
      goto LABEL_57;
    case 50:
      unsigned int v5 = 88;
      goto LABEL_57;
    case 51:
      unsigned int v5 = 89;
      goto LABEL_57;
    case 52:
      unsigned int v5 = 90;
      goto LABEL_57;
    case 53:
      unsigned int v5 = 91;
      goto LABEL_57;
    case 54:
      unsigned int v5 = 109;
      goto LABEL_57;
    case 55:
      unsigned int v5 = 18;
      goto LABEL_57;
    case 56:
      unsigned int v5 = 255;
LABEL_57:
      *a2 = v5;
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      break;
    default:
      *a2 = 0;
      break;
  }
  return 0;
}

uint64_t llvm::LLParser::parseInstructionMetadata(char **this, llvm::Instruction *a2)
{
  int v3 = (llvm::LLLexer *)(this + 21);
  if (*((_DWORD *)this + 56) == 441)
  {
    while (1)
    {
      unsigned int v9 = 0;
      v10[0] = 0;
      if (llvm::LLParser::parseMetadataAttachment((llvm::LLParser *)this, &v9, v10)) {
        return 1;
      }
      unsigned int v5 = v9;
      llvm::Instruction::setMetadata(a2, v9, v10[0]);
      if (v5 == 1)
      {
        unint64_t v6 = *((unsigned int *)this + 90);
        if (v6 >= *((unsigned int *)this + 91)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)&this[44][8 * v6] = a2;
        ++*((_DWORD *)this + 90);
      }
      if (*((_DWORD *)this + 56) != 4) {
        return 0;
      }
      int v7 = llvm::LLLexer::LexToken(v3);
      *((_DWORD *)this + 56) = v7;
      if (v7 != 441) {
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v10[0] = (llvm::MDNode *)"expected metadata after comma";
    __int16 v11 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, this[27], (llvm::Twine *)v10);
  }
}

uint64_t llvm::LLParser::parseOptionalCommaAlign(uint64_t a1, _WORD *a2, unsigned char *a3)
{
  *a3 = 0;
  unint64_t v6 = (llvm::LLLexer *)(a1 + 168);
  do
  {
    int v7 = *(_DWORD *)(a1 + 224);
    BOOL v8 = v7 == 4;
    if (v7 != 4) {
      break;
    }
    int v9 = llvm::LLLexer::LexToken(v6);
    *(_DWORD *)(a1 + 224) = v9;
    if (v9 != 90)
    {
      if (v9 == 441)
      {
        BOOL v8 = 0;
        *a3 = 1;
      }
      else
      {
        __int16 v11 = *(char **)(a1 + 216);
        unint64_t v12 = "expected metadata or 'align'";
        __int16 v13 = 259;
        return llvm::LLLexer::Error((uint64_t)v6, v11, (llvm::Twine *)&v12);
      }
      return v8;
    }
  }
  while (!llvm::LLParser::parseOptionalAlignment(a1, a2, 0));
  return v8;
}

uint64_t llvm::LLParser::parseOptionalCommaAddrSpace(uint64_t a1, unsigned int *a2, void *a3, unsigned char *a4)
{
  *a4 = 0;
  BOOL v8 = (llvm::LLLexer *)(a1 + 168);
  do
  {
    int v9 = *(_DWORD *)(a1 + 224);
    BOOL v10 = v9 == 4;
    if (v9 != 4) {
      break;
    }
    int v11 = llvm::LLLexer::LexToken(v8);
    *(_DWORD *)(a1 + 224) = v11;
    if (v11 == 441)
    {
      BOOL v10 = 0;
      *a4 = 1;
      return v10;
    }
    *a3 = *(void *)(a1 + 216);
    if (v11 != 91)
    {
      __int16 v13 = *(char **)(a1 + 216);
      uint64_t v14 = "expected metadata or 'addrspace'";
      __int16 v15 = 259;
      return llvm::LLLexer::Error((uint64_t)v8, v13, (llvm::Twine *)&v14);
    }
  }
  while (!llvm::LLParser::parseOptionalAddrSpace((llvm::LLParser *)a1, a2, 0));
  return v10;
}

uint64_t llvm::LLParser::parseScope(llvm::LLParser *this, unsigned __int8 *a2)
{
  *a2 = 1;
  if (*((_DWORD *)this + 56) != 76)
  {
LABEL_2:
    LOBYTE(v2) = 0;
    return v2 & 1;
  }
  uint64_t v2 = a2;
  unsigned int v5 = (llvm::LLParser *)((char *)this + 168);
  int v6 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v6;
  if (v6 != 12)
  {
    int v11 = (char *)*((void *)this + 27);
    v15[0] = "Expected '(' in syncscope";
    __int16 v16 = 259;
    LOBYTE(v2) = llvm::LLLexer::Error((uint64_t)v5, v11, (llvm::Twine *)v15);
    return v2 & 1;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v5);
  memset(&__p, 0, sizeof(__p));
  int v7 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseStringConstant((uint64_t)this, &__p))
  {
    v15[0] = "Expected synchronization scope name";
    __int16 v16 = 259;
    uint64_t v12 = (uint64_t)v5;
    __int16 v13 = v7;
  }
  else
  {
    if (*((_DWORD *)this + 56) == 13)
    {
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v5);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t size = __p.__r_.__value_.__l.__size_;
      }
      unsigned __int8 *v2 = llvm::LLVMContext::getOrInsertSyncScopeID(*(void **)this, (unsigned __int8 *)p_p, size);
      int v10 = 1;
      goto LABEL_14;
    }
    __int16 v13 = (char *)*((void *)this + 27);
    v15[0] = "Expected ')' in syncscope";
    __int16 v16 = 259;
    uint64_t v12 = (uint64_t)v5;
  }
  LOBYTE(v2) = llvm::LLLexer::Error(v12, v13, (llvm::Twine *)v15);
  int v10 = 0;
LABEL_14:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v10) {
    goto LABEL_2;
  }
  return v2 & 1;
}

uint64_t llvm::LLParser::parseOrdering(uint64_t a1, _DWORD *a2)
{
  int v3 = (llvm::LLLexer *)(a1 + 168);
  int v4 = *(_DWORD *)(a1 + 224) - 70;
  if (v4 >= 6)
  {
    int v7 = "Expected ordering on atomic instruction";
    __int16 v8 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, *(char **)(a1 + 216), (llvm::Twine *)&v7);
  }
  else
  {
    *a2 = dword_1CFAC4CCC[v4];
    int v5 = llvm::LLLexer::LexToken(v3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 224) = v5;
  }
  return result;
}

uint64_t llvm::LLParser::parseIndexList(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
  int v4 = (llvm::LLLexer *)(a1 + 168);
  if (*(_DWORD *)(a1 + 224) == 4)
  {
    while (1)
    {
      int v7 = llvm::LLLexer::LexToken(v4);
      *(_DWORD *)(a1 + 224) = v7;
      if (v7 == 441) {
        break;
      }
      v11[0] = 0;
      if (llvm::LLParser::parseUInt32((char **)a1, v11)) {
        return 1;
      }
      unint64_t v8 = *(unsigned int *)(a2 + 8);
      if (v8 >= *(unsigned int *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a2 + 4 * v8) = v11[0];
      ++*(_DWORD *)(a2 + 8);
      if (*(_DWORD *)(a1 + 224) != 4) {
        return 0;
      }
    }
    if (*(_DWORD *)(a2 + 8))
    {
      uint64_t result = 0;
      *a3 = 1;
      return result;
    }
    int v10 = "expected index";
  }
  else
  {
    int v10 = "expected ',' as start of index list";
  }
  *(void *)int v11 = v10;
  __int16 v12 = 259;
  return llvm::LLLexer::Error((uint64_t)v4, *(char **)(a1 + 216), (llvm::Twine *)v11);
}

uint64_t llvm::LLParser::parseType(llvm::LLParser *this, llvm::Type **a2, const llvm::Twine *a3, char a4)
{
  int v7 = (llvm::LLParser *)((char *)this + 168);
  unint64_t v8 = (char *)*((void *)this + 27);
  int v9 = *((_DWORD *)this + 56);
  if (v9 == 455)
  {
    *a2 = (llvm::Type *)*((void *)this + 33);
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if (!llvm::Type::isOpaquePointerTy(*a2)) {
      goto LABEL_3;
    }
    LODWORD(v40) = 0;
    if (llvm::LLParser::parseOptionalAddrSpace(this, (unsigned int *)&v40, 0)) {
      return 1;
    }
    *a2 = (llvm::Type *)llvm::PointerType::get(*(uint64_t ***)this, (llvm::LLVMContext *)v40);
    int v37 = *((_DWORD *)this + 56);
    if (v37 != 5)
    {
      if (v37 == 12) {
        goto LABEL_3;
      }
      return 0;
    }
    __int16 v30 = "ptr* is invalid - use ptr instead";
LABEL_48:
    v38[0] = (llvm::Type *)v30;
    __int16 v39 = 259;
    __int16 v31 = (char *)*((void *)this + 27);
    uint64_t v32 = (uint64_t)v7;
    return llvm::LLLexer::Error(v32, v31, (llvm::Twine *)v38);
  }
  if (v9 > 61)
  {
    switch(v9)
    {
      case 62:
        if ((llvm::LLParser::parseTargetExtType(this, a2) & 1) == 0) {
          goto LABEL_3;
        }
        return 1;
      case 434:
        LODWORD(v38[0]) = *((_DWORD *)this + 64);
        __int16 v34 = sub_1CD4F3D04((uint64_t **)this + 114, v38[0], v38);
        unsigned int v24 = (llvm::Type *)v34[5];
        if (!v24)
        {
          unsigned int v24 = (llvm::Type *)llvm::StructType::create(*(llvm::StructType **)this, v33);
          v34[5] = (uint64_t *)v24;
          v34[6] = (uint64_t *)*((void *)this + 27);
        }
        break;
      case 440:
        __int16 v16 = (char *)this + 880;
        char v17 = *((unsigned char *)this + 255);
        int v18 = v17;
        if (v17 >= 0) {
          __int16 v19 = (unsigned __int8 *)this + 232;
        }
        else {
          __int16 v19 = (unsigned __int8 *)*((void *)this + 29);
        }
        size_t v20 = v17 & 0x7F;
        if (v18 >= 0) {
          size_t v21 = v20;
        }
        else {
          size_t v21 = *((void *)this + 30);
        }
        __int16 v22 = sub_1CD4F3DD4((uint64_t)v16, v19, v21);
        __int16 v23 = *v22;
        unsigned int v24 = (llvm::Type *)(*v22)[1];
        if (!v24)
        {
          char v25 = *((unsigned char *)this + 255);
          BOOL v26 = v25 < 0;
          if (v25 >= 0) {
            int v27 = (unsigned __int8 *)this + 232;
          }
          else {
            int v27 = (unsigned __int8 *)*((void *)this + 29);
          }
          size_t v28 = v25 & 0x7F;
          if (v26) {
            size_t v29 = *((void *)this + 30);
          }
          else {
            size_t v29 = v28;
          }
          unsigned int v24 = (llvm::Type *)llvm::StructType::create(*(uint64_t **)this, v27, v29);
          v23[1] = (size_t)v24;
          v23[2] = *((void *)this + 27);
        }
        break;
      default:
        goto LABEL_59;
    }
    *a2 = v24;
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v7);
    goto LABEL_3;
  }
  switch(v9)
  {
    case 6:
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      if ((llvm::LLParser::parseArrayVectorType(this, a2, 0) & 1) == 0) {
        goto LABEL_3;
      }
      return 1;
    case 8:
      if ((llvm::LLParser::parseAnonStructType((uint64_t **)this, a2, 0) & 1) == 0) {
        goto LABEL_3;
      }
      return 1;
    case 10:
      int v15 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      *((_DWORD *)this + 56) = v15;
      uint64_t v14 = 1;
      if (v15 != 8)
      {
        if ((llvm::LLParser::parseArrayVectorType(this, a2, 1) & 1) == 0) {
          goto LABEL_3;
        }
        return v14;
      }
      if ((llvm::LLParser::parseAnonStructType((uint64_t **)this, a2, 1) & 1) != 0
        || (llvm::LLParser::parseToken((uint64_t)this, 11, "expected '>' at end of packed struct") & 1) != 0)
      {
        return v14;
      }
      while (1)
      {
        while (1)
        {
LABEL_3:
          while (1)
          {
            int v11 = *((_DWORD *)this + 56);
            if (v11 != 5) {
              break;
            }
            int v12 = *((unsigned __int8 *)*a2 + 8);
            if (v12 == 7)
            {
              __int16 v30 = "pointers to void are invalid - use i8* instead";
              goto LABEL_48;
            }
            if (v12 == 8) {
              goto LABEL_46;
            }
            if (!llvm::PointerType::isValidElementType(*a2, v10)) {
              goto LABEL_47;
            }
            *a2 = (llvm::Type *)llvm::PointerType::get(*a2, 0);
            *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v7);
          }
          if (v11 != 12) {
            break;
          }
          if (llvm::LLParser::parseFunctionType((char **)this, a2)) {
            return 1;
          }
        }
        if (v11 != 91) {
          break;
        }
        int v13 = *((unsigned __int8 *)*a2 + 8);
        if (v13 == 7)
        {
          __int16 v30 = "pointers to void are invalid; use i8* instead";
          goto LABEL_48;
        }
        if (v13 == 8)
        {
LABEL_46:
          __int16 v30 = "basic block pointers are invalid";
          goto LABEL_48;
        }
        if (!llvm::PointerType::isValidElementType(*a2, v10))
        {
LABEL_47:
          __int16 v30 = "pointer to this type is invalid";
          goto LABEL_48;
        }
        LODWORD(v38[0]) = 0;
        if ((llvm::LLParser::parseOptionalAddrSpace(this, (unsigned int *)v38, 0) & 1) != 0
          || (llvm::LLParser::parseToken((uint64_t)this, 5, "expected '*' in address space") & 1) != 0)
        {
          return 1;
        }
        *a2 = (llvm::Type *)llvm::PointerType::get(*a2, (llvm::Type *)LODWORD(v38[0]));
      }
      if ((a4 & 1) != 0 || *((unsigned char *)*a2 + 8) != 7) {
        return 0;
      }
      v38[0] = (llvm::Type *)"void type only allowed for function results";
      __int16 v39 = 259;
      uint64_t v32 = (uint64_t)v7;
      __int16 v31 = v8;
      return llvm::LLLexer::Error(v32, v31, (llvm::Twine *)v38);
  }
LABEL_59:
  unsigned int v35 = (char *)this + 168;

  return llvm::LLLexer::Error((uint64_t)v35, v8, a3);
}

uint64_t llvm::LLParser::parseTargetExtType(llvm::LLParser *this, llvm::Type **a2)
{
  void v22[6] = *MEMORY[0x1E4F143B8];
  int v4 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  memset(&__p, 0, sizeof(__p));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' in target extension type") & 1) != 0
    || (llvm::LLParser::parseStringConstant((uint64_t)this, &__p) & 1) != 0)
  {
    uint64_t v5 = 1;
  }
  else
  {
    size_t v20 = v22;
    uint64_t v21 = 0x600000000;
    char v17 = v19;
    uint64_t v18 = 0xC00000000;
    if (*((_DWORD *)this + 56) == 4)
    {
      BOOL v7 = 0;
      do
      {
        int v8 = llvm::LLLexer::LexToken(v4);
        *((_DWORD *)this + 56) = v8;
        BOOL v9 = v8 == 457;
        if (v8 == 457)
        {
          v15[0] = 0;
          if (llvm::LLParser::parseUInt32((char **)this, v15)) {
            goto LABEL_19;
          }
          if (v18 >= (unint64_t)HIDWORD(v18)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((_DWORD *)v17 + v18) = v15[0];
          LODWORD(v18) = v18 + 1;
        }
        else
        {
          if (v7)
          {
            *(void *)int v15 = "expected uint32 param";
            __int16 v16 = 259;
            uint64_t v5 = llvm::LLLexer::Error((uint64_t)v4, *((char **)this + 27), (llvm::Twine *)v15);
            goto LABEL_20;
          }
          int v13 = 0;
          *(void *)int v15 = "expected type";
          __int16 v16 = 259;
          if (llvm::LLParser::parseType(this, &v13, (const llvm::Twine *)v15, 1)) {
            goto LABEL_19;
          }
          if (v21 >= (unint64_t)HIDWORD(v21)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v20 + v21) = v13;
          LODWORD(v21) = v21 + 1;
        }
        BOOL v7 = v9;
      }
      while (*((_DWORD *)this + 56) == 4);
    }
    if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' in target extension type"))
    {
LABEL_19:
      uint64_t v5 = 1;
    }
    else
    {
      int v10 = *(void **)this;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t size = __p.__r_.__value_.__l.__size_;
      }
      uint64_t v5 = 0;
      *a2 = (llvm::Type *)llvm::TargetExtType::get(v10, p_p, size, (uint64_t *)v20, v21, (int *)v17, v18);
    }
LABEL_20:
    if (v17 != v19) {
      free(v17);
    }
    if (v20 != v22) {
      free(v20);
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v5;
}

uint64_t llvm::LLParser::parseAnonStructType(uint64_t **this, llvm::Type **a2, int a3)
{
  unsigned char v10[8] = *MEMORY[0x1E4F143B8];
  int v8 = v10;
  uint64_t v9 = 0x800000000;
  uint64_t v6 = llvm::LLParser::parseStructBody((uint64_t)this, (uint64_t)&v8);
  if ((v6 & 1) == 0) {
    *a2 = (llvm::Type *)llvm::StructType::get(*this, (uint64_t)v8, v9, a3);
  }
  if (v8 != v10) {
    free(v8);
  }
  return v6;
}

uint64_t llvm::LLParser::parseArrayVectorType(llvm::LLParser *this, llvm::Type **a2, int a3)
{
  if (a3 && *((_DWORD *)this + 56) == 17)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if (llvm::LLParser::parseToken((uint64_t)this, 18, "expected 'x' after vscale")) {
      return 1;
    }
    uint64_t v7 = 0x100000000;
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (*((_DWORD *)this + 56) == 457 && *((unsigned char *)this + 316) && *((_DWORD *)this + 78) < 0x41u)
  {
    int v10 = (char *)*((void *)this + 27);
    int v11 = (llvm::Type *)*((void *)this + 38);
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if (llvm::LLParser::parseToken((uint64_t)this, 18, "expected 'x' after element count")) {
      return 1;
    }
    int v12 = (char *)*((void *)this + 27);
    uint64_t v21 = 0;
    v22[0] = "expected type";
    __int16 v23 = 259;
    if (llvm::LLParser::parseType(this, &v21, (const llvm::Twine *)v22, 0)) {
      return 1;
    }
    int v13 = a3 ? 11 : 7;
    if (llvm::LLParser::parseToken((uint64_t)this, v13, "expected end of sequential type")) {
      return 1;
    }
    if (a3)
    {
      if (v11)
      {
        if (!((unint64_t)v11 >> 32))
        {
          int v15 = v21;
          if (llvm::VectorType::isValidElementType(v21, v14))
          {
            llvm::VectorType::get(v15, (llvm::Type *)((unint64_t)v11 | v7));
LABEL_26:
            uint64_t v18 = v16;
            uint64_t result = 0;
            *a2 = v18;
            return result;
          }
          size_t v20 = "invalid vector element type";
          goto LABEL_29;
        }
        __int16 v19 = "size too large for vector";
      }
      else
      {
        __int16 v19 = "zero element vector is illegal";
      }
      v22[0] = v19;
      __int16 v23 = 259;
      uint64_t v9 = (char *)this + 168;
      int v8 = v10;
      return llvm::LLLexer::Error((uint64_t)v9, v8, (llvm::Twine *)v22);
    }
    char v17 = v21;
    if (llvm::ArrayType::isValidElementType(v21, v14))
    {
      __int16 v16 = llvm::ArrayType::get(v17, v11);
      goto LABEL_26;
    }
    size_t v20 = "invalid array element type";
LABEL_29:
    v22[0] = v20;
    __int16 v23 = 259;
    uint64_t v9 = (char *)this + 168;
    int v8 = v12;
    return llvm::LLLexer::Error((uint64_t)v9, v8, (llvm::Twine *)v22);
  }
  v22[0] = "expected number in address space";
  __int16 v23 = 259;
  int v8 = (char *)*((void *)this + 27);
  uint64_t v9 = (char *)this + 168;
  return llvm::LLLexer::Error((uint64_t)v9, v8, (llvm::Twine *)v22);
}

uint64_t llvm::LLParser::parseFunctionType(char **this, llvm::Type **a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!llvm::FunctionType::isValidReturnType(*a2, (llvm::Type *)a2))
  {
    __int16 v19 = "invalid function return type";
    v21[8] = 259;
    return llvm::LLLexer::Error((uint64_t)(this + 21), this[27], (llvm::Twine *)&v19);
  }
  __int16 v19 = (char *)v21;
  uint64_t v20 = 0x800000000;
  unsigned __int8 v15 = 0;
  if (llvm::LLParser::parseArgumentList((uint64_t)this, (uint64_t)&v19, &v15))
  {
    uint64_t v4 = 1;
    goto LABEL_4;
  }
  if (!v20)
  {
    uint64_t v6 = 0;
    __int16 v16 = v18;
    uint64_t v17 = 0x1000000000;
    uint64_t v7 = v18;
    goto LABEL_9;
  }
  int v8 = v19;
  uint64_t v9 = v20;
  do
  {
    if (v8[47] < 0) {
      uint64_t v10 = *((void *)v8 + 4);
    }
    else {
      uint64_t v10 = v8[47];
    }
    if (v10)
    {
      int v11 = *(char **)v8;
      int v12 = "argument name invalid in function type";
LABEL_22:
      __int16 v16 = v12;
      unsigned char v18[8] = 259;
      uint64_t v4 = llvm::LLLexer::Error((uint64_t)(this + 21), v11, (llvm::Twine *)&v16);
      goto LABEL_4;
    }
    if (*((void *)v8 + 2))
    {
      int v11 = *(char **)v8;
      int v12 = "argument attributes invalid in function type";
      goto LABEL_22;
    }
    v8 += 48;
    --v9;
  }
  while (v9);
  uint64_t v13 = 0;
  LODWORD(v6) = 0;
  __int16 v16 = v18;
  uint64_t v17 = 0x1000000000;
  uint64_t v14 = 48 * v20;
  do
  {
    if (v6 >= HIDWORD(v17)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v16 + v6) = *(void *)&v19[v13 + 8];
    uint64_t v6 = (v17 + 1);
    LODWORD(v17) = v17 + 1;
    v13 += 48;
  }
  while (v14 != v13);
  uint64_t v7 = v16;
LABEL_9:
  *a2 = (llvm::Type *)llvm::FunctionType::get((uint64_t **)*a2, (uint64_t)v7, v6, v15);
  if (v16 != v18) {
    free(v16);
  }
  uint64_t v4 = 0;
LABEL_4:
  sub_1CD4F486C(&v19);
  return v4;
}

uint64_t llvm::LLParser::parseParameterList(uint64_t a1, uint64_t a2, llvm::LLParser::PerFunctionState *a3, int a4, int a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (llvm::LLParser::parseToken(a1, 12, "expected '(' in call"))
    return 1;
  while (1)
  {
    int v11 = *(_DWORD *)(a1 + 224);
    if (v11 == 13)
    {
      unsigned __int8 v15 = (llvm::LLLexer *)(a1 + 168);
      if (!a4 || !a5)
      {
        int v16 = llvm::LLLexer::LexToken(v15);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 224) = v16;
        return result;
      }
      __int16 v30 = "expected '...' at end of argument list for musttail call in varargs function";
      __int16 v34 = 259;
      __int16 v23 = *(char **)(a1 + 216);
      return llvm::LLLexer::Error((uint64_t)v15, v23, (llvm::Twine *)&v30);
    }
    if (*(_DWORD *)(a2 + 8))
    {
      if (llvm::LLParser::parseToken(a1, 4, "expected ',' in argument list")) {
        return 1;
      }
      int v11 = *(_DWORD *)(a1 + 224);
    }
    if (v11 == 2) {
      break;
    }
    char v25 = 0;
    v26[0] = 0;
    int v12 = *(llvm::Metadata **)(a1 + 216);
    __int16 v30 = "expected type";
    __int16 v34 = 259;
    if (llvm::LLParser::parseType((llvm::LLParser *)a1, v26, (const llvm::Twine *)&v30, 0)) {
      return 1;
    }
    __int16 v30 = **(const char ***)(a1 + 328);
    __int16 v31 = &v33;
    uint64_t v32 = 0x800000000;
    uint64_t v13 = v26[0];
    if (*((unsigned char *)v26[0] + 8) != 9)
    {
      if ((llvm::LLParser::parseOptionalParamOrReturnAttrs((llvm::LLParser *)a1, (llvm::AttrBuilder *)&v30, 1) & 1) != 0
        || (llvm::LLParser::parseValue((llvm::ConstantInt **)a1, v13, (llvm::Value **)&v25, a3) & 1) != 0)
      {
        goto LABEL_9;
      }
      uint64_t v18 = v25;
LABEL_23:
      __int16 v19 = (llvm::Metadata *)llvm::AttributeSet::get(**v18, (uint64_t **)&v30, v17);
      v28[0] = v12;
      v28[1] = (llvm::Metadata *)v18;
      v28[2] = v19;
      unint64_t v20 = sub_1CD483108(a2, (unint64_t)v28);
      uint64_t v21 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 8);
      long long v22 = *(_OWORD *)v20;
      *(void *)(v21 + 16) = *(void *)(v20 + 16);
      *(_OWORD *)uint64_t v21 = v22;
      ++*(_DWORD *)(a2 + 8);
      char v14 = 1;
      goto LABEL_10;
    }
    v28[0] = 0;
    if ((llvm::LLParser::parseMetadata(a1, v28, a3) & 1) == 0)
    {
      uint64_t v18 = (llvm::AttributeSet ***)llvm::MetadataAsValue::get(*(void *)a1, (unsigned __int8 *)v28[0]);
      char v25 = v18;
      goto LABEL_23;
    }
LABEL_9:
    char v14 = 0;
LABEL_10:
    if (v31 != &v33) {
      free(v31);
    }
    uint64_t result = 1;
    if ((v14 & 1) == 0) {
      return result;
    }
  }
  if ((a4 & 1) == 0)
  {
    v28[0] = (llvm::Metadata *)"unexpected ellipsis in argument list for ";
    __int16 v29 = 259;
    unsigned int v24 = "non-musttail call";
LABEL_30:
    v26[0] = (llvm::Type *)v24;
    __int16 v27 = 259;
    sub_1CB8F1E58((uint64_t *)v28, (uint64_t *)v26, (uint64_t)&v30);
    __int16 v23 = *(char **)(a1 + 216);
    unsigned __int8 v15 = (llvm::LLLexer *)(a1 + 168);
    return llvm::LLLexer::Error((uint64_t)v15, v23, (llvm::Twine *)&v30);
  }
  if ((a5 & 1) == 0)
  {
    v28[0] = (llvm::Metadata *)"unexpected ellipsis in argument list for ";
    __int16 v29 = 259;
    unsigned int v24 = "musttail call in non-varargs function";
    goto LABEL_30;
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  return llvm::LLParser::parseToken(a1, 13, "expected ')' at end of argument list");
}

uint64_t llvm::LLParser::parseOptionalOperandBundles(uint64_t a1, uint64_t a2, llvm::LLParser::PerFunctionState *a3)
{
  if (*(_DWORD *)(a1 + 224) != 6) {
    return 0;
  }
  uint64_t v6 = (llvm::LLLexer *)(a1 + 168);
  uint64_t v7 = *(char **)(a1 + 216);
  int v8 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v8;
  if (v8 == 7)
  {
LABEL_3:
    if (*(_DWORD *)(a2 + 8))
    {
      int v9 = llvm::LLLexer::LexToken(v6);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 224) = v9;
    }
    else
    {
      v19[0] = "operand bundle set must not be empty";
      __int16 v20 = 259;
      return llvm::LLLexer::Error((uint64_t)v6, v7, (llvm::Twine *)v19);
    }
  }
  else
  {
    while (!*(_DWORD *)(a2 + 8) || (llvm::LLParser::parseToken(a1, 4, "expected ',' in input list") & 1) == 0)
    {
      memset(&__p, 0, sizeof(__p));
      if ((llvm::LLParser::parseStringConstant(a1, &__p) & 1) != 0
        || (llvm::LLParser::parseToken(a1, 12, "expected '(' in operand bundle") & 1) != 0)
      {
        int v11 = 1;
      }
      else
      {
        __n128 v16 = 0uLL;
        unint64_t v17 = 0;
        if (*(_DWORD *)(a1 + 224) == 13)
        {
LABEL_27:
          sub_1CD4E1C44(a2, (uint64_t *)&__p, &v16);
          int v11 = 0;
          *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
        }
        else
        {
          int v12 = 0;
          while ((void *)v16.n128_u64[0] == v12
               || (llvm::LLParser::parseToken(a1, 4, "expected ',' in input list") & 1) == 0)
          {
            char v14 = 0;
            unsigned __int8 v15 = 0;
            v19[0] = "expected type";
            __int16 v20 = 259;
            if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v15, (const llvm::Twine *)v19, 0) & 1) != 0
              || (llvm::LLParser::parseValue((llvm::ConstantInt **)a1, v15, &v14, a3) & 1) != 0)
            {
              break;
            }
            unint64_t v13 = v16.n128_u64[1];
            if (v16.n128_u64[1] >= v17)
            {
              int v12 = sub_1CBC13470((void **)&v16, &v14);
            }
            else
            {
              *(void *)v16.n128_u64[1] = v14;
              int v12 = (void *)(v13 + 8);
            }
            v16.n128_u64[1] = (unint64_t)v12;
            if (*(_DWORD *)(a1 + 224) == 13) {
              goto LABEL_27;
            }
          }
          int v11 = 1;
        }
        if (v16.n128_u64[0])
        {
          v16.n128_u64[1] = v16.n128_u64[0];
          operator delete((void *)v16.n128_u64[0]);
        }
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v11) {
        break;
      }
      if (*(_DWORD *)(a1 + 224) == 7) {
        goto LABEL_3;
      }
    }
    return 1;
  }
  return result;
}

__n128 sub_1CD4E1C44(uint64_t a1, uint64_t *a2, __n128 *a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD4F4530();
  }
  uint64_t v4 = *(void *)a1 + 48 * v3;
  uint64_t v5 = *a2;
  *(void *)&long long v9 = a2[1];
  *(void *)((char *)&v9 + 7) = *(uint64_t *)((char *)a2 + 15);
  char v6 = *((unsigned char *)a2 + 23);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  unint64_t v7 = a3[1].n128_u64[0];
  __n128 result = *a3;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  *(void *)uint64_t v4 = v5;
  *(void *)(v4 + 8) = v9;
  *(void *)(v4 + 15) = *(void *)((char *)&v9 + 7);
  *(unsigned char *)(v4 + 23) = v6;
  *(void *)(v4 + 32) = 0;
  *(void *)(v4 + 40) = 0;
  *(__n128 *)(v4 + 24) = result;
  *(void *)(v4 + 40) = v7;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t llvm::LLParser::parseArgumentList(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  v37[8] = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  char v6 = (llvm::LLLexer *)(a1 + 168);
  int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v7;
  if (v7 == 13) {
    goto LABEL_4;
  }
  if (v7 == 2)
  {
    *a3 = 1;
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
    goto LABEL_4;
  }
  uint64_t v10 = *(char **)(a1 + 216);
  __int16 v30 = 0;
  __int16 v31 = v10;
  __int16 v34 = **(uint64_t ***)(a1 + 328);
  uint64_t v35 = v37;
  uint64_t v36 = 0x800000000;
  memset(&__p, 0, sizeof(__p));
  v32[0] = (uint64_t)"expected type";
  __int16 v33 = 259;
  if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v30, (const llvm::Twine *)v32, 0))
  {
LABEL_7:
    int v11 = 0;
    LOBYTE(v8) = 1;
    goto LABEL_8;
  }
  LODWORD(v8) = 1;
  if (llvm::LLParser::parseOptionalParamOrReturnAttrs((llvm::LLParser *)a1, (llvm::AttrBuilder *)&v34, 1)) {
    goto LABEL_15;
  }
  unint64_t v13 = v30;
  if (*((unsigned char *)v30 + 8) == 7)
  {
LABEL_17:
    char v14 = "argument can not have void type";
LABEL_18:
    v32[0] = (uint64_t)v14;
    __int16 v33 = 259;
    goto LABEL_19;
  }
  int v15 = *(_DWORD *)(a1 + 224);
  if (v15 == 434)
  {
    if (*(_DWORD *)(a1 + 256))
    {
      BOOL v26 = "argument expected to be numbered '%";
      __int16 v27 = 259;
      __int16 v25 = 264;
      LODWORD(v24[0]) = 0;
      goto LABEL_41;
    }
  }
  else
  {
    if (v15 != 440)
    {
      LODWORD(v8) = 0;
      goto LABEL_24;
    }
    std::string::operator=(&__p, (const std::string *)(a1 + 232));
    LODWORD(v8) = 0;
  }
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
LABEL_24:
  if (!llvm::FunctionType::isValidArgumentType(v13, v12))
  {
LABEL_38:
    char v14 = "invalid type for function argument";
    goto LABEL_18;
  }
  v32[0] = llvm::AttributeSet::get(*(llvm::AttributeSet **)v13, &v34, v16);
  sub_1CD4E2128(a2, &v31, (uint64_t *)&v30, v32, (long long *)&__p);
  if (*(_DWORD *)(a1 + 224) != 4)
  {
    int v11 = 1;
    goto LABEL_8;
  }
  int v17 = (int)v8;
  while (1)
  {
    int v18 = llvm::LLLexer::LexToken(v6);
    *(_DWORD *)(a1 + 224) = v18;
    if (v18 == 2)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
      int v11 = 1;
      *a3 = 1;
      goto LABEL_8;
    }
    uint64_t v10 = *(char **)(a1 + 216);
    __int16 v31 = v10;
    v32[0] = (uint64_t)"expected type";
    __int16 v33 = 259;
    if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v30, (const llvm::Twine *)v32, 0)) {
      goto LABEL_7;
    }
    LOBYTE(v8) = 1;
    if (llvm::LLParser::parseOptionalParamOrReturnAttrs((llvm::LLParser *)a1, (llvm::AttrBuilder *)&v34, 1)) {
      goto LABEL_15;
    }
    int v8 = (llvm::AttributeSet **)v30;
    if (*((unsigned char *)v30 + 8) == 7) {
      goto LABEL_17;
    }
    int v19 = *(_DWORD *)(a1 + 224);
    if (v19 == 434) {
      break;
    }
    if (v19 == 440)
    {
      std::string::operator=(&__p, (const std::string *)(a1 + 232));
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
      goto LABEL_34;
    }
LABEL_33:
    ++v17;
    MEMORY[0x1D25D9630](&__p, "");
LABEL_34:
    int v21 = *((unsigned __int8 *)v8 + 8);
    if (v21 == 14 || v21 == 7) {
      goto LABEL_38;
    }
    v32[0] = llvm::AttributeSet::get(*v8, &v34, v20);
    sub_1CD4E2128(a2, &v31, (uint64_t *)&v30, v32, (long long *)&__p);
    int v11 = 1;
    LOBYTE(v8) = 1;
    if (*(_DWORD *)(a1 + 224) != 4) {
      goto LABEL_8;
    }
  }
  if (*(_DWORD *)(a1 + 256) == v17)
  {
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v6);
    goto LABEL_33;
  }
  BOOL v26 = "argument expected to be numbered '%";
  __int16 v27 = 259;
  __int16 v25 = 264;
  LODWORD(v24[0]) = v17;
LABEL_41:
  sub_1CB8F1E58((uint64_t *)&v26, v24, (uint64_t)v28);
  long long v22 = "'";
  __int16 v23 = 259;
  sub_1CB8F1E58(v28, (uint64_t *)&v22, (uint64_t)v32);
LABEL_19:
  LOBYTE(v8) = llvm::LLLexer::Error((uint64_t)v6, v10, (llvm::Twine *)v32);
LABEL_15:
  int v11 = 0;
LABEL_8:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v35 != v37) {
    free(v35);
  }
  if (v11) {
LABEL_4:
  }
    LOBYTE(v8) = llvm::LLParser::parseToken(a1, 13, "expected ')' at end of argument list");
  return v8 & 1;
}

_OWORD *sub_1CD4E2128(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4, long long *a5)
{
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  if (v6 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD4F46E4();
  }
  int v7 = (void *)(*(void *)a1 + 48 * v6);
  uint64_t v8 = *a3;
  uint64_t v9 = *a4;
  *int v7 = *a2;
  v7[1] = v8;
  void v7[2] = v9;
  __n128 result = v7 + 3;
  if (*((char *)a5 + 23) < 0)
  {
    __n128 result = sub_1CB8BDF7C((uint64_t)result, *(const void **)a5, *((void *)a5 + 1));
  }
  else
  {
    long long v11 = *a5;
    v7[5] = *((void *)a5 + 2);
    *__n128 result = v11;
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t llvm::LLParser::parseStructBody(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (llvm::LLLexer *)(a1 + 168);
  int v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v5;
  if (v5 == 9)
  {
    int v6 = llvm::LLLexer::LexToken(v4);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 224) = v6;
    return result;
  }
  uint64_t v8 = *(char **)(a1 + 216);
  int v18 = 0;
  v19[0] = "expected type";
  __int16 v20 = 259;
  if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v18, (const llvm::Twine *)v19, 0)) {
    return 1;
  }
  uint64_t v10 = v18;
  unsigned int v11 = *(_DWORD *)(a2 + 8);
  if (v11 >= *(_DWORD *)(a2 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a2 + 8 * v11) = v18;
  ++*(_DWORD *)(a2 + 8);
  if (llvm::StructType::isValidElementType(v10, v9))
  {
    if (*(_DWORD *)(a1 + 224) != 4) {
      return llvm::LLParser::parseToken(a1, 9, "expected '}' at end of struct");
    }
    while (1)
    {
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
      int v12 = *(char **)(a1 + 216);
      v19[0] = "expected type";
      __int16 v20 = 259;
      if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v18, (const llvm::Twine *)v19, 0)) {
        break;
      }
      char v14 = v18;
      if (!llvm::StructType::isValidElementType(v18, v13))
      {
        v19[0] = "invalid element type for struct";
        __int16 v20 = 259;
        uint64_t v16 = (uint64_t)v4;
        int v17 = v12;
        return llvm::LLLexer::Error(v16, v17, (llvm::Twine *)v19);
      }
      unint64_t v15 = *(unsigned int *)(a2 + 8);
      if (v15 >= *(unsigned int *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a2 + 8 * v15) = v14;
      ++*(_DWORD *)(a2 + 8);
      if (*(_DWORD *)(a1 + 224) != 4) {
        return llvm::LLParser::parseToken(a1, 9, "expected '}' at end of struct");
      }
    }
    return 1;
  }
  v19[0] = "invalid element type for struct";
  __int16 v20 = 259;
  uint64_t v16 = (uint64_t)v4;
  int v17 = v8;
  return llvm::LLLexer::Error(v16, v17, (llvm::Twine *)v19);
}

llvm::LLParser::PerFunctionState *llvm::LLParser::PerFunctionState::PerFunctionState(llvm::LLParser::PerFunctionState *this, llvm::LLParser *a2, llvm::Function *a3, int a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((void *)this + 8) = 0;
  int v5 = (void **)((char *)this + 64);
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = (char *)this + 48;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = a4;
  uint64_t v6 = sub_1CB923B44(a3);
  if (v6 != v7)
  {
    uint64_t v8 = v6;
    uint64_t v9 = v7;
    do
    {
      if ((*(unsigned char *)(v8 + 23) & 0x10) == 0)
      {
        uint64_t v13 = v8;
        uint64_t v10 = (uint64_t *)*((void *)this + 9);
        if ((unint64_t)v10 >= *((void *)this + 10))
        {
          unsigned int v11 = sub_1CBC13470(v5, &v13);
        }
        else
        {
          uint64_t *v10 = v8;
          unsigned int v11 = v10 + 1;
        }
        *((void *)this + 9) = v11;
      }
      v8 += 40;
    }
    while (v8 != v9);
  }
  return this;
}

void llvm::LLParser::PerFunctionState::~PerFunctionState(llvm::LLParser::PerFunctionState *this, llvm::Type *a2)
{
  unsigned int v3 = (char *)*((void *)this + 2);
  uint64_t v4 = (char *)this + 24;
  if (v3 != (char *)this + 24)
  {
    do
    {
      uint64_t v5 = *((void *)v3 + 7);
      if (*(unsigned char *)(v5 + 16) != 22)
      {
        uint64_t v6 = llvm::UndefValue::get(*(llvm::UndefValue **)v5, a2);
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)v5, v6, (llvm::Value *)1);
        llvm::Value::deleteValue(*((void (***)(void))v3 + 7), v7);
      }
      uint64_t v8 = (char *)*((void *)v3 + 1);
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = *(char **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (char *)*((void *)v3 + 2);
          BOOL v10 = *(void *)v9 == (void)v3;
          unsigned int v3 = v9;
        }
        while (!v10);
      }
      unsigned int v3 = v9;
    }
    while (v9 != v4);
  }
  unsigned int v11 = (llvm::LLParser::PerFunctionState *)*((void *)this + 5);
  if (v11 != (llvm::LLParser::PerFunctionState *)((char *)this + 48))
  {
    do
    {
      uint64_t v12 = *((void *)v11 + 5);
      if (*(unsigned char *)(v12 + 16) != 22)
      {
        uint64_t v13 = llvm::UndefValue::get(*(llvm::UndefValue **)v12, a2);
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)v12, v13, (llvm::Value *)1);
        llvm::Value::deleteValue(*((void (***)(void))v11 + 5), v14);
      }
      unint64_t v15 = (llvm::LLParser::PerFunctionState *)*((void *)v11 + 1);
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          unint64_t v15 = *(llvm::LLParser::PerFunctionState **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (llvm::LLParser::PerFunctionState *)*((void *)v11 + 2);
          BOOL v10 = *(void *)v16 == (void)v11;
          unsigned int v11 = v16;
        }
        while (!v10);
      }
      unsigned int v11 = v16;
    }
    while (v16 != (llvm::LLParser::PerFunctionState *)((char *)this + 48));
  }
  int v17 = (void *)*((void *)this + 8);
  if (v17)
  {
    *((void *)this + 9) = v17;
    operator delete(v17);
  }
  sub_1CD40B1BC(*((void **)this + 6));
  sub_1CD4F48E0(*((char **)this + 3));
}

uint64_t llvm::LLParser::PerFunctionState::finishFunction(llvm::LLParser::PerFunctionState *this)
{
  if (*((void *)this + 4))
  {
    uint64_t v3 = *(void *)this;
    uint64_t v4 = *(char **)(*((void *)this + 2) + 64);
    std::operator+<char>();
    uint64_t v5 = std::string::append(&v14, "'");
    std::string::size_type v6 = v5->__r_.__value_.__r.__words[2];
    long long v16 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    std::string::size_type v17 = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    __int16 v19 = 260;
    v18[0] = &v16;
    uint64_t v1 = llvm::LLLexer::Error(v3 + 168, v4, (llvm::Twine *)v18);
    if (SHIBYTE(v17) < 0) {
      operator delete((void *)v16);
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14.__r_.__value_.__l.__data_);
    }
  }
  else if (*((void *)this + 7))
  {
    uint64_t v7 = *(void *)this;
    uint64_t v8 = *((void *)this + 5);
    uint64_t v9 = *(char **)(v8 + 48);
    v14.__r_.__value_.__r.__words[0] = (std::string::size_type)"use of undefined value '%";
    __int16 v15 = 259;
    LODWORD(v8) = *(_DWORD *)(v8 + 32);
    __int16 v13 = 264;
    LODWORD(v12[0]) = v8;
    sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)&v16);
    BOOL v10 = "'";
    __int16 v11 = 259;
    sub_1CB8F1E58((uint64_t *)&v16, (uint64_t *)&v10, (uint64_t)v18);
    return llvm::LLLexer::Error(v7 + 168, v9, (llvm::Twine *)v18);
  }
  else
  {
    return 0;
  }
  return v1;
}

llvm::Type **llvm::LLParser::PerFunctionState::getVal(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, char *a4)
{
  std::string::size_type v6 = a2;
  uint64_t v8 = *(uint64_t **)(*(void *)(a1 + 8) + 104);
  char v9 = *((unsigned char *)a2 + 23);
  BOOL v10 = v9 < 0;
  unint64_t v11 = a2[1];
  if (v9 < 0) {
    a2 = (uint64_t *)*a2;
  }
  unint64_t v12 = v9 & 0x7F;
  if (v10) {
    unint64_t v13 = v11;
  }
  else {
    unint64_t v13 = v12;
  }
  std::string v14 = (llvm::Type **)sub_1CC196FC4(v8, (unsigned __int8 *)a2, v13);
  if (v14 || (uint64_t v15 = sub_1CD4F3EC8(a1 + 16, v6), a1 + 24 != v15) && (v14 = *(llvm::Type ***)(v15 + 56)) != 0)
  {
    uint64_t v19 = *(void *)a1;
    std::operator+<char>();
    __int16 v24 = 260;
    v23[0] = (uint64_t)&__p;
    int v18 = llvm::LLParser::checkValidVariableType(v19, a4, v23, (llvm::Type *)a3, v14);
    if (v22 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    int v16 = a3[8];
    if (v16 != 14)
    {
      if (v16 == 8)
      {
        llvm::Function::getContext(*(llvm::Function **)(a1 + 8));
        __int16 v24 = 260;
        v23[0] = (uint64_t)v6;
        operator new();
      }
      if (v16 != 7) {
        operator new();
      }
    }
    uint64_t v17 = *(void *)a1;
    v23[0] = (uint64_t)"invalid use of a non-first-class type";
    __int16 v24 = 259;
    llvm::LLLexer::Error(v17 + 168, a4, (llvm::Twine *)v23);
    return 0;
  }
  return v18;
}

llvm::Type **llvm::LLParser::PerFunctionState::getVal(uint64_t a1, unsigned int a2, unsigned __int8 *a3, char *a4)
{
  unsigned int v24 = a2;
  uint64_t v6 = *(void *)(a1 + 64);
  if (a2 < (unint64_t)((*(void *)(a1 + 72) - v6) >> 3))
  {
    uint64_t v7 = *(llvm::Type ***)(v6 + 8 * a2);
    if (v7) {
      goto LABEL_19;
    }
  }
  uint64_t v8 = *(void *)(a1 + 48);
  if (!v8) {
    goto LABEL_4;
  }
  uint64_t v12 = a1 + 48;
  do
  {
    unsigned int v13 = *(_DWORD *)(v8 + 32);
    BOOL v14 = v13 >= a2;
    if (v13 >= a2) {
      uint64_t v15 = (uint64_t *)v8;
    }
    else {
      uint64_t v15 = (uint64_t *)(v8 + 8);
    }
    if (v14) {
      uint64_t v12 = v8;
    }
    uint64_t v8 = *v15;
  }
  while (*v15);
  if (v12 != a1 + 48 && *(_DWORD *)(v12 + 32) <= a2 && (uint64_t v7 = *(llvm::Type ***)(v12 + 40)) != 0)
  {
LABEL_19:
    uint64_t v16 = *(void *)a1;
    __int16 v20 = "%";
    __int16 v21 = 259;
    __int16 v19 = 264;
    LODWORD(v18[0]) = a2;
    sub_1CB8F1E58((uint64_t *)&v20, v18, (uint64_t)v22);
    return llvm::LLParser::checkValidVariableType(v16, a4, v22, (llvm::Type *)a3, v7);
  }
  else
  {
LABEL_4:
    int v9 = a3[8];
    if (v9 != 14)
    {
      if (v9 == 8)
      {
        llvm::Function::getContext(*(llvm::Function **)(a1 + 8));
        __int16 v23 = 257;
        operator new();
      }
      if (v9 != 7) {
        operator new();
      }
    }
    uint64_t v10 = *(void *)a1;
    v22[0] = (uint64_t)"invalid use of a non-first-class type";
    __int16 v23 = 259;
    llvm::LLLexer::Error(v10 + 168, a4, (llvm::Twine *)v22);
    return 0;
  }
}

uint64_t llvm::LLParser::PerFunctionState::setInstName(uint64_t *a1, unint64_t a2, uint64_t a3, char *a4, llvm::Value *a5)
{
  if (*(unsigned char *)(*(void *)a5 + 8) == 7)
  {
    if (a2 == -1)
    {
      char v8 = *(unsigned char *)(a3 + 23);
      int v9 = v8;
      uint64_t v10 = v8 & 0x7F;
      if (v9 < 0) {
        uint64_t v10 = *(void *)(a3 + 8);
      }
      if (!v10) {
        return 0;
      }
    }
    BOOL v26 = (uint64_t *)*a1;
    v62[0] = "instructions returning void cannot have a name";
    __int16 v63 = 259;
    uint64_t v27 = (uint64_t)(v26 + 21);
    return llvm::LLLexer::Error(v27, a4, (llvm::Twine *)v62);
  }
  char v14 = *(unsigned char *)(a3 + 23);
  int v15 = v14;
  uint64_t v16 = v14 & 0x7F;
  if (v15 < 0) {
    uint64_t v16 = *(void *)(a3 + 8);
  }
  if (!v16)
  {
    uint64_t v17 = (void *)a1[9];
    uint64_t v18 = (uint64_t)v17 - a1[8];
    if (a2 == -1) {
      a2 = (unint64_t)v18 >> 3;
    }
    uint64_t v19 = v18 >> 3;
    if (v19 != a2)
    {
      unsigned int v41 = (uint64_t *)*a1;
      v58.__r_.__value_.__r.__words[0] = (std::string::size_type)"instruction expected to be numbered '%";
      __int16 v59 = 259;
      __int16 v57 = 266;
      uint64_t v55 = v19;
      v56.__r_.__value_.__r.__words[0] = (std::string::size_type)&v55;
      sub_1CB8F1E58((uint64_t *)&v58, (uint64_t *)&v56, (uint64_t)&__p);
      unint64_t v53 = "'";
      __int16 v54 = 259;
      sub_1CB8F1E58((uint64_t *)&__p, (uint64_t *)&v53, (uint64_t)v62);
      uint64_t v27 = (uint64_t)(v41 + 21);
      return llvm::LLLexer::Error(v27, a4, (llvm::Twine *)v62);
    }
    uint64_t v20 = a1[6];
    if (!v20) {
      goto LABEL_25;
    }
    __int16 v21 = a1 + 6;
    do
    {
      unsigned int v22 = *(_DWORD *)(v20 + 32);
      BOOL v23 = v22 >= a2;
      if (v22 >= a2) {
        unsigned int v24 = (uint64_t *)v20;
      }
      else {
        unsigned int v24 = (uint64_t *)(v20 + 8);
      }
      if (v23) {
        __int16 v21 = (uint64_t *)v20;
      }
      uint64_t v20 = *v24;
    }
    while (*v24);
    if (v21 == a1 + 6 || a2 < *((_DWORD *)v21 + 8)) {
      goto LABEL_25;
    }
    uint64_t v42 = (void (**)(void))v21[5];
    int v43 = *v42;
    if (*v42 == *(void (**)(void))a5)
    {
      llvm::Value::doRAUW((llvm::ValueAsMetadata *)v21[5], a5, (llvm::Value *)1);
      llvm::Value::deleteValue(v42, v44);
      sub_1CD491B50((uint64_t **)a1 + 5, v21);
      operator delete(v21);
      uint64_t v17 = (void *)a1[9];
LABEL_25:
      v62[0] = (const char *)a5;
      if ((unint64_t)v17 >= a1[10])
      {
        __int16 v25 = sub_1CBC13470((void **)a1 + 8, v62);
      }
      else
      {
        void *v17 = a5;
        __int16 v25 = v17 + 1;
      }
      uint64_t v11 = 0;
      a1[9] = (uint64_t)v25;
      return v11;
    }
LABEL_50:
    size_t v48 = (uint64_t *)*a1;
    sub_1CC196EB4((uint64_t)&v56, (llvm::Type *)v43);
    uint64_t v49 = std::string::insert(&v56, 0, "instruction forward referenced with type '");
    std::string::size_type v50 = v49->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v58.__r_.__value_.__l.__data_ = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
    v58.__r_.__value_.__r.__words[2] = v50;
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    char v51 = std::string::append(&v58, "'");
    std::string::size_type v52 = v51->__r_.__value_.__r.__words[2];
    long long __p = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    std::string::size_type v61 = v52;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    __int16 v63 = 260;
    v62[0] = (const char *)&__p;
    uint64_t v11 = llvm::LLLexer::Error((uint64_t)(v48 + 21), a4, (llvm::Twine *)v62);
    if (SHIBYTE(v61) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v58.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
    {
      unint64_t v40 = (void *)v56.__r_.__value_.__r.__words[0];
      goto LABEL_56;
    }
    return v11;
  }
  uint64_t v28 = sub_1CD4F3EC8((uint64_t)(a1 + 2), (void *)a3);
  if (a1 + 3 != (uint64_t *)v28)
  {
    uint64_t v45 = v28;
    unsigned int v46 = *(void (***)(void))(v28 + 56);
    int v43 = *v46;
    if (*v46 != *(void (**)(void))a5) {
      goto LABEL_50;
    }
    llvm::Value::doRAUW(*(llvm::ValueAsMetadata **)(v28 + 56), a5, (llvm::Value *)1);
    llvm::Value::deleteValue(v46, v47);
    sub_1CD4F3F94((uint64_t **)a1 + 2, v45);
  }
  __int16 v63 = 260;
  v62[0] = (const char *)a3;
  llvm::Value::setName(a5, v62);
  Name = llvm::Value::getName(a5);
  uint64_t v31 = v30;
  char v32 = *(unsigned char *)(a3 + 23);
  BOOL v33 = v32 < 0;
  if (v32 >= 0) {
    __int16 v34 = (const void *)a3;
  }
  else {
    __int16 v34 = *(const void **)a3;
  }
  size_t v35 = v32 & 0x7F;
  if (v33) {
    size_t v36 = *(void *)(a3 + 8);
  }
  else {
    size_t v36 = v35;
  }
  if (v31 == v36 && (!v36 || !memcmp(Name, v34, v36))) {
    return 0;
  }
  int v37 = (uint64_t *)*a1;
  std::operator+<char>();
  uint64_t v38 = std::string::append(&v58, "'");
  std::string::size_type v39 = v38->__r_.__value_.__r.__words[2];
  long long __p = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  std::string::size_type v61 = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  __int16 v63 = 260;
  v62[0] = (const char *)&__p;
  uint64_t v11 = llvm::LLLexer::Error((uint64_t)(v37 + 21), a4, (llvm::Twine *)v62);
  if (SHIBYTE(v61) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
  {
    unint64_t v40 = (void *)v58.__r_.__value_.__r.__words[0];
LABEL_56:
    operator delete(v40);
  }
  return v11;
}

llvm::Type **llvm::LLParser::PerFunctionState::getBB(uint64_t a1, uint64_t *a2, char *a3)
{
  uint64_t Context = (llvm::Type *)llvm::Function::getContext(*(llvm::Function **)(a1 + 8));
  LabelTy = (unsigned __int8 *)llvm::Type::getLabelTy(Context, v7);
  uint64_t result = llvm::LLParser::PerFunctionState::getVal(a1, a2, LabelTy, a3);
  if (result)
  {
    if (*((unsigned char *)result + 16) != 22) {
      return 0;
    }
  }
  return result;
}

llvm::Type **llvm::LLParser::PerFunctionState::getBB(uint64_t a1, unsigned int a2, char *a3)
{
  uint64_t Context = (llvm::Type *)llvm::Function::getContext(*(llvm::Function **)(a1 + 8));
  LabelTy = (unsigned __int8 *)llvm::Type::getLabelTy(Context, v7);
  uint64_t result = llvm::LLParser::PerFunctionState::getVal(a1, a2, LabelTy, a3);
  if (result)
  {
    if (*((unsigned char *)result + 16) != 22) {
      return 0;
    }
  }
  return result;
}

llvm::Type **llvm::LLParser::PerFunctionState::defineBB(uint64_t a1, uint64_t a2, int a3, char *a4)
{
  char v7 = *(unsigned char *)(a2 + 23);
  int v8 = v7;
  uint64_t v9 = v7 & 0x7F;
  if (v8 < 0) {
    uint64_t v9 = *(void *)(a2 + 8);
  }
  if (v9)
  {
    BB = llvm::LLParser::PerFunctionState::getBB(a1, (uint64_t *)a2, a4);
    if (!BB)
    {
      uint64_t v16 = *(void *)a1;
      std::operator+<char>();
      uint64_t v17 = std::string::append(&v31, "'");
      std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long __p = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
      std::string::size_type v34 = v18;
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      __int16 v36 = 260;
      v35[0] = __p;
      llvm::LLLexer::Error(v16 + 168, a4, (llvm::Twine *)v35);
      if (SHIBYTE(v34) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v31.__r_.__value_.__l.__data_);
      }
      return 0;
    }
  }
  else
  {
    if (a3 == -1)
    {
      uint64_t v10 = *(void *)(a1 + 72) - *(void *)(a1 + 64);
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 72) - *(void *)(a1 + 64);
      if (v10 >> 3 != a3)
      {
        uint64_t v24 = *(void *)a1;
        v31.__r_.__value_.__r.__words[0] = (std::string::size_type)"label expected to be numbered '";
        __int16 v32 = 259;
        __int16 v30 = 266;
        uint64_t v28 = v10 >> 3;
        v29[0] = (uint64_t)&v28;
        sub_1CB8F1E58((uint64_t *)&v31, v29, (uint64_t)__p);
        v26[0] = (uint64_t)"'";
        __int16 v27 = 259;
        sub_1CB8F1E58((uint64_t *)__p, v26, (uint64_t)v35);
        uint64_t v14 = v24 + 168;
        goto LABEL_8;
      }
    }
    BB = llvm::LLParser::PerFunctionState::getBB(a1, (unint64_t)v10 >> 3, a4);
    if (!BB)
    {
      uint64_t v12 = *(void *)a1;
      v31.__r_.__value_.__r.__words[0] = (std::string::size_type)"unable to create block numbered '";
      __int16 v32 = 259;
      uint64_t v13 = (uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 3;
      __int16 v30 = 266;
      uint64_t v28 = v13;
      v29[0] = (uint64_t)&v28;
      sub_1CB8F1E58((uint64_t *)&v31, v29, (uint64_t)__p);
      v26[0] = (uint64_t)"'";
      __int16 v27 = 259;
      sub_1CB8F1E58((uint64_t *)__p, v26, (uint64_t)v35);
      uint64_t v14 = v12 + 168;
LABEL_8:
      llvm::LLLexer::Error(v14, a4, (llvm::Twine *)v35);
      return 0;
    }
  }
  sub_1CC19E208(*(void *)(a1 + 8) + 72, (uint64_t *)(*(void *)(a1 + 8) + 72), *(void *)(a1 + 8) + 72, (uint64_t *)BB + 3);
  char v19 = *(unsigned char *)(a2 + 23);
  int v20 = v19;
  uint64_t v21 = v19 & 0x7F;
  if (v20 < 0) {
    uint64_t v21 = *(void *)(a2 + 8);
  }
  if (v21)
  {
    uint64_t v25 = sub_1CD4F3EC8(a1 + 16, (void *)a2);
    if (a1 + 24 != v25) {
      sub_1CD4F3F94((uint64_t **)(a1 + 16), v25);
    }
  }
  else
  {
    sub_1CD4F493C(a1 + 40, (*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 3);
    v35[0] = BB;
    unsigned int v22 = *(llvm::Type ****)(a1 + 72);
    if ((unint64_t)v22 >= *(void *)(a1 + 80))
    {
      BOOL v23 = sub_1CBC13470((void **)(a1 + 64), v35);
    }
    else
    {
      const char *v22 = BB;
      BOOL v23 = v22 + 1;
    }
    *(void *)(a1 + 72) = v23;
  }
  return BB;
}

uint64_t llvm::LLParser::parseGlobalValueVector(llvm::LLParser *this, uint64_t a2, uint64_t a3)
{
  int v6 = *((_DWORD *)this + 56);
  if (v6 - 7) < 7 && ((0x55u >> (v6 - 7))) {
    return 0;
  }
  while (1)
  {
    if (a3)
    {
      if (!*(unsigned char *)(a3 + 4) && v6 == 89)
      {
        *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
        int v8 = *(unsigned __int8 *)(a3 + 4);
        *(_DWORD *)a3 = *(_DWORD *)(a2 + 8);
        if (!v8) {
          *(unsigned char *)(a3 + 4) = 1;
        }
      }
    }
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = "expected type";
    __int16 v13 = 259;
    if (llvm::LLParser::parseType(this, &v11, (const llvm::Twine *)&v12, 0)
      || (llvm::LLParser::parseGlobalValue((llvm::ConstantInt **)this, v11, &v10) & 1) != 0)
    {
      break;
    }
    unint64_t v7 = *(unsigned int *)(a2 + 8);
    if (v7 >= *(unsigned int *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a2 + 8 * v7) = v10;
    ++*(_DWORD *)(a2 + 8);
    if (*((_DWORD *)this + 56) != 4) {
      return 0;
    }
    int v6 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v6;
  }
  return 1;
}

uint64_t sub_1CD4E3398(uint64_t a1, uint64_t a2)
{
  char v6 = 0;
  if (llvm::LLParser::parseIndexList(a1, a2, &v6)) {
    return 1;
  }
  if (!v6) {
    return 0;
  }
  uint64_t v4 = "expected index";
  __int16 v5 = 259;
  return llvm::LLLexer::Error(a1 + 168, *(char **)(a1 + 216), (llvm::Twine *)&v4);
}

uint64_t llvm::LLParser::parseCmpPredicate(llvm::LLParser *this, unsigned int *a2, int a3)
{
  int v4 = *((_DWORD *)this + 56);
  if (a3 == 54)
  {
    int v5 = v4 - 256;
    unsigned int v6 = 1;
    switch(v5)
    {
      case 0:
        unsigned int v6 = 12;
        goto LABEL_6;
      case 1:
        unsigned int v6 = 10;
        goto LABEL_6;
      case 2:
        unsigned int v6 = 13;
        goto LABEL_6;
      case 3:
        unsigned int v6 = 11;
        goto LABEL_6;
      case 4:
        goto LABEL_6;
      case 5:
        unsigned int v6 = 6;
        goto LABEL_6;
      case 6:
        unsigned int v6 = 4;
        goto LABEL_6;
      case 7:
        unsigned int v6 = 2;
        goto LABEL_6;
      case 8:
        unsigned int v6 = 5;
        goto LABEL_6;
      case 9:
        unsigned int v6 = 3;
        goto LABEL_6;
      case 10:
        unsigned int v6 = 7;
        goto LABEL_6;
      case 11:
        unsigned int v6 = 8;
        goto LABEL_6;
      case 12:
        unsigned int v6 = 9;
        goto LABEL_6;
      case 13:
        unsigned int v6 = 14;
        goto LABEL_6;
      default:
        uint64_t v10 = (char *)this + 168;
        uint64_t v11 = "expected fcmp predicate (e.g. 'oeq')";
        goto LABEL_21;
    }
  }
  unsigned int v7 = v4 - 250;
  if (v7 >= 0xA)
  {
    uint64_t v10 = (char *)this + 168;
    uint64_t v11 = "expected icmp predicate (e.g. 'eq')";
LABEL_21:
    uint64_t v12 = v11;
    __int16 v13 = 259;
    return llvm::LLLexer::Error((uint64_t)v10, *((char **)this + 27), (llvm::Twine *)&v12);
  }
  else
  {
    unsigned int v6 = dword_1CFAC4CE4[v7];
LABEL_6:
    *a2 = v6;
    int v8 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    uint64_t result = 0;
    *((_DWORD *)this + 56) = v8;
  }
  return result;
}

uint64_t llvm::LLParser::convertValIDToValue(llvm::ConstantInt **a1, uint64_t a2, int *a3, void *a4, uint64_t a5)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  int v7 = *(_DWORD *)(a2 + 8);
  if (v7 == 14)
  {
    __int16 v36 = (char *)*((void *)a3 + 1);
    int v37 = "functions are not values, refer to them as pointers";
LABEL_75:
    std::string::size_type v89 = (void **)v37;
    __int16 v91 = 259;
    uint64_t v49 = (uint64_t)(a1 + 21);
    return llvm::LLLexer::Error(v49, v36, (llvm::Twine *)&v89);
  }
  else
  {
    int v8 = *a3;
    switch(*a3)
    {
      case 1:
        GlobalVal = (llvm::NoCFIValue *)llvm::LLParser::getGlobalVal((uint64_t)a1, a3[4], (llvm::Type *)a2, *((char **)a3 + 1));
        goto LABEL_105;
      case 2:
        if (!a5) {
          goto LABEL_102;
        }
        GlobalVal = (llvm::NoCFIValue *)llvm::LLParser::PerFunctionState::getVal(a5, (uint64_t *)a3 + 4, (unsigned __int8 *)a2, *((char **)a3 + 1));
        goto LABEL_110;
      case 3:
        GlobalVal = (llvm::NoCFIValue *)llvm::LLParser::getGlobalVal((uint64_t)a1, (uint64_t *)a3 + 4, (llvm::Type *)a2, *((char **)a3 + 1));
LABEL_105:
        *a4 = GlobalVal;
        if (GlobalVal) {
          BOOL v60 = *((unsigned char *)a3 + 144) == 0;
        }
        else {
          BOOL v60 = 1;
        }
        if (v60) {
          goto LABEL_111;
        }
        GlobalVal = (llvm::NoCFIValue *)llvm::NoCFIValue::get(GlobalVal, v59);
        goto LABEL_110;
      case 4:
        if (v7 != 13)
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "integer constant must have integer type";
          goto LABEL_75;
        }
        char v44 = a3 + 20;
        unsigned int PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits((llvm::Type *)a2);
        if (v45 == 1) {
        sub_1CC197F50((llvm::APInt *)(a3 + 20), PrimitiveSizeInBits, (uint64_t)&v89);
        }
        if (a3[22] >= 0x41 && *v44) {
          MEMORY[0x1D25D9CB0](*v44, 0x1000C8000313F17);
        }
        *((void *)a3 + 10) = v89;
        a3[22] = (int)v90[0];
        *((unsigned char *)a3 + 92) = BYTE4(v90[0]);
        uint64_t NullValue = (uint64_t)llvm::ConstantInt::get(*a1, (llvm::LLVMContext *)(a3 + 20), v47);
        goto LABEL_44;
      case 5:
        if (v7 > 6u
          || (llvm::ConstantFP::isValueValidForType((llvm::ConstantFP *)a2, (llvm::Type *)(a3 + 24), (const llvm::APFloat *)a3) & 1) == 0)
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "floating point constant invalid for type";
          goto LABEL_75;
        }
        if (*((_UNKNOWN **)a3 + 13) != &unk_1CFB2E31C) {
          goto LABEL_55;
        }
        BOOL isSignaling = llvm::detail::IEEEFloat::isSignaling((llvm::detail::IEEEFloat *)(a3 + 26));
        BOOL v51 = isSignaling;
        int v52 = *(unsigned __int8 *)(a2 + 8);
        if (v52 == 2)
        {
          unint64_t v53 = llvm::APFloatBase::IEEEsingle((llvm::APFloatBase *)isSignaling);
        }
        else if (v52 == 1)
        {
          unint64_t v53 = llvm::APFloatBase::BFloat((llvm::APFloatBase *)isSignaling);
        }
        else
        {
          if (*(unsigned char *)(a2 + 8)) {
            goto LABEL_91;
          }
          unint64_t v53 = llvm::APFloatBase::IEEEhalf((llvm::APFloatBase *)isSignaling);
        }
        llvm::APFloat::convert((uint64_t)(a3 + 24), v53, 1, &v80);
LABEL_91:
        if (v51)
        {
          sub_1CB867534((uint64_t)(a3 + 24), (uint64_t)__p);
          __int16 v54 = (void *)*((void *)a3 + 13);
          uint64_t v55 = v54 == &unk_1CFB2E344 ? (int *)*((void *)a3 + 14) : a3 + 24;
          int v56 = (*((unsigned __int8 *)v55 + 28) >> 3) & 1;
          LODWORD(v82.__r_.__value_.__l.__data_) = 0;
          sub_1CB87E68C((uint64_t)v90, (uint64_t)v54);
          sub_1CBFC6FE8((uint64_t)&v89, 1, v56, (const llvm::APInt *)__p);
          sub_1CB9190C0((uint64_t *)a3 + 13, v90);
          sub_1CB87DEE4((uint64_t *)v90);
          if (LODWORD(__p[1]) >= 0x41)
          {
            if (__p[0]) {
              MEMORY[0x1D25D9CB0](__p[0], 0x1000C8000313F17);
            }
          }
        }
LABEL_55:
        int v43 = llvm::ConstantFP::get(*a1, (llvm::LLVMContext *)(a3 + 24), v42);
        *a4 = v43;
        if (*(void *)v43 == a2) {
          return 0;
        }
        unint64_t v73 = (char *)*((void *)a3 + 1);
        sub_1CC196EB4((uint64_t)&v80, (llvm::Type *)a2);
        uint64_t v74 = std::string::insert(&v80, 0, "floating point constant does not have type '");
        std::string::size_type v75 = v74->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v82.__r_.__value_.__l.__data_ = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
        v82.__r_.__value_.__r.__words[2] = v75;
        v74->__r_.__value_.__l.__size_ = 0;
        v74->__r_.__value_.__r.__words[2] = 0;
        v74->__r_.__value_.__r.__words[0] = 0;
        unsigned int v76 = std::string::append(&v82, "'");
        std::string::size_type v77 = v76->__r_.__value_.__r.__words[2];
        *(_OWORD *)long long __p = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
        std::string::size_type v85 = v77;
        v76->__r_.__value_.__l.__size_ = 0;
        v76->__r_.__value_.__r.__words[2] = 0;
        v76->__r_.__value_.__r.__words[0] = 0;
        __int16 v91 = 260;
        std::string::size_type v89 = __p;
        uint64_t v39 = llvm::LLLexer::Error((uint64_t)(a1 + 21), v73, (llvm::Twine *)&v89);
        if (SHIBYTE(v85) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v82.__r_.__value_.__l.__data_);
        }
        if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v39;
        }
        unint64_t v72 = (void *)v80.__r_.__value_.__r.__words[0];
        goto LABEL_130;
      case 6:
        if (v7 == 15)
        {
          uint64_t NullValue = (uint64_t)llvm::ConstantPointerNull::get((llvm::ConstantPointerNull *)a2, (llvm::PointerType *)a2);
          goto LABEL_44;
        }
        __int16 v36 = (char *)*((void *)a3 + 1);
        int v37 = "null must be a pointer type";
        goto LABEL_75;
      case 7:
        if (v7 > 0xEu || ((1 << v7) & 0x4180) == 0) {
          goto LABEL_39;
        }
        __int16 v36 = (char *)*((void *)a3 + 1);
        int v37 = "invalid type for undef constant";
        goto LABEL_75;
      case 8:
        BOOL v48 = v7 > 0xEu || ((1 << v7) & 0x4180) == 0;
        if (v48 && (v7 != 21 || llvm::TargetExtType::hasProperty((llvm::TargetExtType *)a2, 1))) {
          goto LABEL_43;
        }
        __int16 v36 = (char *)*((void *)a3 + 1);
        int v37 = "invalid type for null constant";
        goto LABEL_75;
      case 9:
        if (v7 == 12)
        {
LABEL_43:
          uint64_t NullValue = (uint64_t)llvm::Constant::getNullValue((llvm::Constant *)a2, (llvm::Type *)a2, (const llvm::APFloat *)a3);
          goto LABEL_44;
        }
        __int16 v36 = (char *)*((void *)a3 + 1);
        int v37 = "invalid type for none constant";
        goto LABEL_75;
      case 10:
        if (v7 <= 0xEu && ((1 << v7) & 0x4180) != 0)
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "invalid type for poison constant";
          goto LABEL_75;
        }
        uint64_t NullValue = (uint64_t)llvm::PoisonValue::get((llvm::PoisonValue *)a2, (llvm::Type *)a2);
        goto LABEL_44;
      case 11:
        if (v7 == 17 && !*(void *)(a2 + 32))
        {
LABEL_39:
          uint64_t NullValue = (uint64_t)llvm::UndefValue::get((llvm::UndefValue *)a2, (llvm::Type *)a2);
          goto LABEL_44;
        }
        __int16 v36 = (char *)*((void *)a3 + 1);
        int v37 = "invalid empty array initializer";
        goto LABEL_75;
      case 12:
        uint64_t v38 = (llvm::Type **)*((void *)a3 + 16);
        if (*v38 == (llvm::Type *)a2)
        {
          uint64_t v39 = 0;
          *a4 = v38;
        }
        else
        {
          std::string::size_type v61 = (char *)*((void *)a3 + 1);
          sub_1CC196EB4((uint64_t)&v88, *v38);
          uint64_t v62 = std::string::insert(&v88, 0, "constant expression type mismatch: got type '");
          std::string::size_type v63 = v62->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v78.__r_.__value_.__l.__data_ = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
          v78.__r_.__value_.__r.__words[2] = v63;
          v62->__r_.__value_.__l.__size_ = 0;
          v62->__r_.__value_.__r.__words[2] = 0;
          v62->__r_.__value_.__r.__words[0] = 0;
          int v64 = std::string::append(&v78, "' but expected '");
          std::string::size_type v65 = v64->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v80.__r_.__value_.__l.__data_ = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
          v80.__r_.__value_.__r.__words[2] = v65;
          v64->__r_.__value_.__l.__size_ = 0;
          v64->__r_.__value_.__r.__words[2] = 0;
          v64->__r_.__value_.__r.__words[0] = 0;
          sub_1CC196EB4((uint64_t)v86, (llvm::Type *)a2);
          if (v87 >= 0) {
            uint64_t v66 = (const std::string::value_type *)v86;
          }
          else {
            uint64_t v66 = (const std::string::value_type *)v86[0];
          }
          if (v87 >= 0) {
            std::string::size_type v67 = v87 & 0x7F;
          }
          else {
            std::string::size_type v67 = (std::string::size_type)v86[1];
          }
          uint64_t v68 = std::string::append(&v80, v66, v67);
          std::string::size_type v69 = v68->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v82.__r_.__value_.__l.__data_ = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
          v82.__r_.__value_.__r.__words[2] = v69;
          v68->__r_.__value_.__l.__size_ = 0;
          v68->__r_.__value_.__r.__words[2] = 0;
          v68->__r_.__value_.__r.__words[0] = 0;
          BOOL v70 = std::string::append(&v82, "'");
          std::string::size_type v71 = v70->__r_.__value_.__r.__words[2];
          *(_OWORD *)long long __p = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
          std::string::size_type v85 = v71;
          v70->__r_.__value_.__l.__size_ = 0;
          v70->__r_.__value_.__r.__words[2] = 0;
          v70->__r_.__value_.__r.__words[0] = 0;
          __int16 v91 = 260;
          std::string::size_type v89 = __p;
          uint64_t v39 = llvm::LLLexer::Error((uint64_t)(a1 + 21), v61, (llvm::Twine *)&v89);
          if (SHIBYTE(v85) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v82.__r_.__value_.__l.__data_);
          }
          if (v87 < 0) {
            operator delete(v86[0]);
          }
          if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v80.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v78.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v78.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0)
          {
            unint64_t v72 = (void *)v88.__r_.__value_.__r.__words[0];
LABEL_130:
            operator delete(v72);
          }
        }
        return v39;
      case 13:
        uint64_t v15 = *((void *)a3 + 3);
        if (!v15
          || ((uint64_t v16 = (uint64_t)(a3 + 14), v17 = *((unsigned char *)a3 + 79), v18 = v17, v17 >= 0)
            ? (char v19 = (char *)(a3 + 14))
            : (char v19 = (char *)*((void *)a3 + 7)),
              (uint64_t v20 = v17 & 0x7F, v18 >= 0) ? (v21 = v20) : (v21 = *((void *)a3 + 8)),
              !llvm::InlineAsm::Verify(v15, v19, v21)))
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "invalid type for inline asm constraint string";
          goto LABEL_75;
        }
        uint64_t v24 = *((void *)a3 + 4);
        uint64_t v23 = (uint64_t)(a3 + 8);
        uint64_t v22 = v24;
        char v25 = *(unsigned char *)(v23 + 23);
        int v26 = v25;
        if (v25 >= 0) {
          uint64_t v27 = v23;
        }
        else {
          uint64_t v27 = v22;
        }
        uint64_t v28 = v25 & 0x7F;
        if (v26 >= 0) {
          uint64_t v29 = v28;
        }
        else {
          uint64_t v29 = *(void *)(v23 + 8);
        }
        char v30 = *(unsigned char *)(v23 + 47);
        BOOL v31 = v30 < 0;
        if (v30 >= 0) {
          uint64_t v32 = v16;
        }
        else {
          uint64_t v32 = *(void *)(v23 + 24);
        }
        uint64_t v33 = v30 & 0x7F;
        if (v31) {
          uint64_t v34 = *(void *)(v23 + 32);
        }
        else {
          uint64_t v34 = v33;
        }
        uint64_t NullValue = llvm::InlineAsm::get(*(llvm::PointerType **)(v23 - 8), v27, v29, v32, v34, *(_DWORD *)(v23 - 16) & 1, (*(_DWORD *)(v23 - 16) & 2) != 0, (*(_DWORD *)(v23 - 16) >> 2) & 1, (*(_DWORD *)(v23 - 16) & 8) != 0);
        goto LABEL_44;
      case 14:
      case 15:
        if (v7 != 16)
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "constant expression type mismatch";
          goto LABEL_75;
        }
        uint64_t v11 = *(unsigned int *)(a2 + 12);
        if (v11 != a3[4])
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "initializer with struct type has wrong # elements";
          goto LABEL_75;
        }
        if ((v8 != 15) == (unsigned __int16)(v7 & 0x200) >> 9)
        {
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "packed'ness of initializer and type don't match";
          goto LABEL_75;
        }
        uint64_t v12 = (llvm::Type *)*((void *)a3 + 17);
        if (v11)
        {
          for (uint64_t i = 0; i != v11; ++i)
          {
            if (**((void **)v12 + i) != *(void *)(*(void *)(a2 + 16) + 8 * i))
            {
              __int16 v57 = (char *)*((void *)a3 + 1);
              v82.__r_.__value_.__r.__words[0] = (std::string::size_type)"element ";
              __int16 v83 = 259;
              __int16 v81 = 264;
              LODWORD(v80.__r_.__value_.__l.__data_) = i;
              sub_1CB8F1E58((uint64_t *)&v82, (uint64_t *)&v80, (uint64_t)__p);
              v78.__r_.__value_.__r.__words[0] = (std::string::size_type)" of struct initializer doesn't match struct element type";
              __int16 v79 = 259;
              sub_1CB8F1E58((uint64_t *)__p, (uint64_t *)&v78, (uint64_t)&v89);
              uint64_t v49 = (uint64_t)(a1 + 21);
              __int16 v36 = v57;
              return llvm::LLLexer::Error(v49, v36, (llvm::Twine *)&v89);
            }
          }
        }
        else
        {
          uint64_t v11 = 0;
        }
        uint64_t NullValue = (uint64_t)llvm::ConstantStruct::get((llvm::PoisonValue *)a2, v12, v11);
LABEL_44:
        uint64_t v39 = 0;
        *a4 = NullValue;
        return v39;
      default:
        if (!a5)
        {
LABEL_102:
          __int16 v36 = (char *)*((void *)a3 + 1);
          int v37 = "invalid use of function-local name";
          goto LABEL_75;
        }
        GlobalVal = (llvm::NoCFIValue *)llvm::LLParser::PerFunctionState::getVal(a5, a3[4], (unsigned __int8 *)a2, *((char **)a3 + 1));
LABEL_110:
        *a4 = GlobalVal;
LABEL_111:
        uint64_t v39 = GlobalVal == 0;
        break;
    }
  }
  return v39;
}

uint64_t llvm::LLParser::parseMDNodeVector(_DWORD *a1, uint64_t a2)
{
  if (llvm::LLParser::parseToken((uint64_t)a1, 8, "expected '{' here")) {
    return 1;
  }
  int v5 = a1[56];
  if (v5 == 9)
  {
    int v6 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 42));
    uint64_t result = 0;
    a1[56] = v6;
  }
  else
  {
    while (1)
    {
      if (v5 == 53)
      {
        a1[56] = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 42));
        unint64_t v7 = *(unsigned int *)(a2 + 8);
        if (v7 >= *(unsigned int *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v7) = 0;
      }
      else
      {
        uint64_t v9 = 0;
        if (llvm::LLParser::parseMetadata((llvm::LLParser *)a1, &v9, 0)) {
          return 1;
        }
        unint64_t v8 = *(unsigned int *)(a2 + 8);
        if (v8 >= *(unsigned int *)(a2 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a2 + 8 * v8) = v9;
      }
      ++*(_DWORD *)(a2 + 8);
      if (a1[56] != 4) {
        break;
      }
      int v5 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 42));
      a1[56] = v5;
    }
    return llvm::LLParser::parseToken((uint64_t)a1, 9, "expected end of metadata node");
  }
  return result;
}

llvm::MDNode *sub_1CD4E3F38(uint64_t a1, void *a2, uint64_t a3)
{
  return llvm::MDTuple::getImpl(a1, a2, a3, 1, 1);
}

llvm::MDNode *sub_1CD4E3F44(uint64_t a1, void *a2, uint64_t a3)
{
  return llvm::MDTuple::getImpl(a1, a2, a3, 0, 1);
}

uint64_t llvm::LLParser::parseDILocation(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  char v25 = 0;
  uint64_t v26 = 0xFFFFFFFFLL;
  uint64_t v21 = 0;
  char v22 = 0;
  uint64_t v23 = 0xFFFFLL;
  uint64_t v24 = 0;
  uint64_t v19 = 0;
  __int16 v20 = 0;
  uint64_t v17 = 0;
  __int16 v18 = 256;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v16 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "line"))
      {
        if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v24)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "column"))
      {
        if (sub_1CC19E350((uint64_t)this, (uint64_t)&v21)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "scope"))
        {
          uint64_t v10 = &v19;
          uint64_t v11 = this;
          uint64_t v12 = "scope";
          uint64_t v13 = 5;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "inlinedAt"))
          {
            if (sub_1CBA86C10((void *)this + 29, "isImplicitCode"))
            {
              if (sub_1CC19E4DC((uint64_t)this, (uint64_t)"isImplicitCode", 14, (char *)&v16)) {
                return 1;
              }
            }
            else
            {
              BOOL v31 = "invalid field '";
              __int16 v32 = 259;
              __int16 v30 = 260;
              v29[0] = (uint64_t)this + 232;
              sub_1CB8F1E58((uint64_t *)&v31, v29, (uint64_t)v33);
              uint64_t v27 = "'";
              __int16 v28 = 259;
              sub_1CB8F1E58(v33, (uint64_t *)&v27, (uint64_t)v34);
              if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34)) {
                return 1;
              }
            }
            goto LABEL_6;
          }
          uint64_t v10 = &v17;
          uint64_t v11 = this;
          uint64_t v12 = "inlinedAt";
          uint64_t v13 = 9;
        }
        if (sub_1CC19E414((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_22;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_25;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_25:
    v34[0] = "expected field label here";
    __int16 v35 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34)) {
      return 1;
    }
  }
LABEL_22:
  uint64_t v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v20)
  {
    Impl = (llvm::MDNode *)llvm::DILocation::getImpl(*(void **)this, v24, v21, v19, v17, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v34[0] = "missing required field 'scope'";
    __int16 v35 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v34);
  }
  return result;
}

uint64_t llvm::LLParser::parseDIGlobalVariableExpression(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v19 = 0;
  __int16 v20 = 256;
  uint64_t v17 = 0;
  __int16 v18 = 256;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "var"))
      {
        int v9 = &v19;
        uint64_t v10 = this;
        uint64_t v11 = "var";
        uint64_t v12 = 3;
      }
      else
      {
        if (!sub_1CBA86C10((void *)this + 29, "expr"))
        {
          char v25 = "invalid field '";
          __int16 v26 = 259;
          __int16 v24 = 260;
          v23[0] = (uint64_t)this + 232;
          sub_1CB8F1E58((uint64_t *)&v25, v23, (uint64_t)v27);
          uint64_t v21 = "'";
          __int16 v22 = 259;
          sub_1CB8F1E58(v27, (uint64_t *)&v21, (uint64_t)v28);
          if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v28)) {
            return 1;
          }
          goto LABEL_7;
        }
        int v9 = &v17;
        uint64_t v10 = this;
        uint64_t v11 = "expr";
        uint64_t v12 = 4;
      }
      if (sub_1CC19E414((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_15;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_19;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_19:
    v28[0] = "expected field label here";
    __int16 v29 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v28)) {
      return 1;
    }
  }
LABEL_15:
  uint64_t v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v20)
  {
    if ((_BYTE)v18)
    {
      Impl = llvm::DIGlobalVariableExpression::getImpl(*(void **)this, v19, v17, a3, 1);
      uint64_t result = 0;
      *a2 = Impl;
      return result;
    }
    __int16 v16 = "missing required field 'expr'";
  }
  else
  {
    __int16 v16 = "missing required field 'var'";
  }
  v28[0] = v16;
  __int16 v29 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v28);
}

uint64_t llvm::LLParser::parseGenericDINode(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  char v18 = 0;
  uint64_t v19 = 0xFFFFLL;
  uint64_t v15 = 0;
  __int16 v16 = 256;
  __int16 v26 = v28;
  uint64_t v27 = 0x400000000;
  char v29 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    goto LABEL_2;
  int v9 = *((_DWORD *)this + 56);
  if (v9 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v17)) {
          goto LABEL_2;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "header"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"header", 6, (uint64_t)&v15)) {
          goto LABEL_2;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "operands"))
        {
          if (!v29)
          {
            *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
            uint64_t v33 = v35;
            uint64_t v34 = 0x400000000;
            char v11 = llvm::LLParser::parseMDNodeVector(this, (uint64_t)&v33);
            if ((v11 & 1) == 0)
            {
              v30[0] = v31;
              v30[1] = (void *)0x400000000;
              if (v34) {
                sub_1CD41C56C((uint64_t)v30, (uint64_t)&v33);
              }
              char v29 = 1;
              sub_1CD41C56C((uint64_t)&v26, (uint64_t)v30);
              if (v30[0] != v31) {
                free(v30[0]);
              }
            }
            if (v33 != v35) {
              free(v33);
            }
            if (v11) {
              goto LABEL_2;
            }
            goto LABEL_9;
          }
          __int16 v32 = 1283;
          v30[0] = "field '";
          v31[0] = "operands";
          v31[1] = 8;
          v24[0] = (uint64_t)"' cannot be specified more than once";
          __int16 v25 = 259;
          uint64_t v12 = v24;
        }
        else
        {
          v24[0] = (uint64_t)"invalid field '";
          __int16 v25 = 259;
          __int16 v23 = 260;
          v22[0] = (uint64_t)this + 232;
          sub_1CB8F1E58(v24, v22, (uint64_t)v30);
          __int16 v20 = "'";
          __int16 v21 = 259;
          uint64_t v12 = (uint64_t *)&v20;
        }
        sub_1CB8F1E58((uint64_t *)v30, v12, (uint64_t)&v33);
        if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v33)) {
          goto LABEL_2;
        }
      }
LABEL_9:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_27;
      }
      int v10 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v10;
      if (v10 != 437) {
        goto LABEL_30;
      }
    }
  }
  if (v9 != 13)
  {
LABEL_30:
    uint64_t v33 = "expected field label here";
    __int16 v36 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v33)) {
      goto LABEL_2;
    }
  }
LABEL_27:
  int v13 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here"))
  {
LABEL_2:
    uint64_t v7 = 1;
    goto LABEL_3;
  }
  if (v18)
  {
    Impl = llvm::GenericDINode::getImpl(*(void **)this, v17, v15, (unsigned __int8 **)v26, v27, a3, 1);
    uint64_t v7 = 0;
    *a2 = Impl;
  }
  else
  {
    uint64_t v33 = "missing required field 'tag'";
    __int16 v36 = 259;
    uint64_t v7 = llvm::LLLexer::Error((uint64_t)v6, v13, (llvm::Twine *)&v33);
  }
LABEL_3:
  if (v26 != v28) {
    free(v26);
  }
  return v7;
}

uint64_t llvm::LLParser::parseDISubrange(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  *(void *)&long long v43 = -1;
  BYTE8(v43) = 0;
  long long v44 = xmmword_1CFAC4C50;
  HIDWORD(v46) = 0;
  long long v45 = 0uLL;
  LOBYTE(v46) = 0;
  *(void *)&long long v39 = 0;
  BYTE8(v39) = 0;
  long long v40 = xmmword_1CFAC4C60;
  long long v41 = xmmword_1CD96DBF0;
  LOBYTE(v42) = 0;
  HIDWORD(v42) = 0;
  *(void *)&long long v35 = 0;
  BYTE8(v35) = 0;
  long long v36 = xmmword_1CFAC4C60;
  long long v37 = xmmword_1CD96DBF0;
  LOBYTE(v38) = 0;
  HIDWORD(v38) = 0;
  *(void *)&long long v31 = 0;
  BYTE8(v31) = 0;
  long long v32 = xmmword_1CFAC4C60;
  long long v33 = xmmword_1CD96DBF0;
  LOBYTE(v34) = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  HIDWORD(v34) = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "count"))
      {
        int v9 = &v43;
        int v10 = this;
        char v11 = "count";
        uint64_t v12 = 5;
        goto LABEL_6;
      }
      if (sub_1CBA86C10((void *)this + 29, "lowerBound")) {
        break;
      }
      if (sub_1CBA86C10((void *)this + 29, "upperBound"))
      {
        int v9 = &v35;
        int v10 = this;
        char v11 = "upperBound";
        goto LABEL_12;
      }
      if (!sub_1CBA86C10((void *)this + 29, "stride"))
      {
        BOOL v51 = "invalid field '";
        __int16 v52 = 259;
        __int16 v50 = 260;
        v49[0] = (uint64_t)this + 232;
        sub_1CB8F1E58((uint64_t *)&v51, v49, (uint64_t)v53);
        size_t v47 = "'";
        __int16 v48 = 259;
        sub_1CB8F1E58(v53, (uint64_t *)&v47, (uint64_t)v54);
        if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v54)) {
          return 1;
        }
        goto LABEL_7;
      }
      int v9 = &v31;
      int v10 = this;
      char v11 = "stride";
      uint64_t v12 = 6;
LABEL_6:
      if (sub_1CC19EB20((uint64_t)v10, (uint64_t)v11, v12, v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_20;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_22;
      }
    }
    int v9 = &v39;
    int v10 = this;
    char v11 = "lowerBound";
LABEL_12:
    uint64_t v12 = 10;
    goto LABEL_6;
  }
  if (v8 != 13)
  {
LABEL_22:
    v54[0] = "expected field label here";
    __int16 v55 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v54)) {
      return 1;
    }
  }
LABEL_20:
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  v29[0] = v43;
  v29[1] = v44;
  v29[2] = v45;
  uint64_t v30 = v46;
  uint64_t v15 = sub_1CC197D7C((uint64_t)this, (uint64_t)v29, v14);
  v27[0] = v39;
  v27[1] = v40;
  void v27[2] = v41;
  uint64_t v28 = v42;
  uint64_t v17 = sub_1CC197D7C((uint64_t)this, (uint64_t)v27, v16);
  v25[0] = v35;
  v25[1] = v36;
  v25[2] = v37;
  uint64_t v26 = v38;
  uint64_t v19 = sub_1CC197D7C((uint64_t)this, (uint64_t)v25, v18);
  v23[0] = v31;
  v23[1] = v32;
  v23[2] = v33;
  uint64_t v24 = v34;
  uint64_t v21 = sub_1CC197D7C((uint64_t)this, (uint64_t)v23, v20);
  Impl = llvm::DISubrange::getImpl(*(void **)this, v15, v17, v19, v21, a3, 1);
  uint64_t result = 0;
  *a2 = Impl;
  return result;
}

uint64_t llvm::LLParser::parseDIBasicType(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v29 = 36;
  char v30 = 0;
  uint64_t v31 = 0xFFFFLL;
  __int16 v28 = 256;
  char v25 = 0;
  uint64_t v26 = -1;
  uint64_t v27 = 0;
  char v22 = 0;
  uint64_t v23 = 0xFFFFFFFFLL;
  uint64_t v24 = 0;
  uint64_t v18 = 0;
  char v19 = 0;
  uint64_t v20 = 255;
  uint64_t v21 = 0;
  int v16 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  char v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v29)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v27)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "size"))
        {
          int v10 = &v24;
          char v11 = this;
          uint64_t v12 = "size";
          uint64_t v13 = 4;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "align"))
          {
            if (sub_1CBA86C10((void *)this + 29, "encoding"))
            {
              if (sub_1CC19F260((uint64_t)this, (uint64_t)&v18)) {
                return 1;
              }
            }
            else if (sub_1CBA86C10((void *)this + 29, "flags"))
            {
              if (sub_1CC19F40C((uint64_t)this, (uint64_t)&v16)) {
                return 1;
              }
            }
            else
            {
              long long v36 = "invalid field '";
              __int16 v37 = 259;
              __int16 v35 = 260;
              v34[0] = (uint64_t)this + 232;
              sub_1CB8F1E58((uint64_t *)&v36, v34, (uint64_t)v38);
              long long v32 = "'";
              __int16 v33 = 259;
              sub_1CB8F1E58(v38, (uint64_t *)&v32, (uint64_t)v39);
              if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v39)) {
                return 1;
              }
            }
            goto LABEL_7;
          }
          int v10 = &v21;
          char v11 = this;
          uint64_t v12 = "align";
          uint64_t v13 = 5;
        }
        if (sub_1CC19E288((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_26;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_28;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_28:
    v39[0] = "expected field label here";
    __int16 v40 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v39)) {
      return 1;
    }
  }
LABEL_26:
  char v14 = llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here");
  uint64_t result = 1;
  if ((v14 & 1) == 0)
  {
    Impl = llvm::DIBasicType::getImpl(*(void **)this, v29, v27, v24, v21, v18, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  return result;
}

uint64_t llvm::LLParser::parseDIDerivedType(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v66 = 0;
  char v67 = 0;
  uint64_t v68 = 0xFFFFLL;
  uint64_t v64 = 0;
  __int16 v65 = 256;
  __int16 v63 = 256;
  uint64_t v59 = 0;
  char v60 = 0;
  uint64_t v61 = 0xFFFFFFFFLL;
  uint64_t v62 = 0;
  uint64_t v57 = 0;
  __int16 v58 = 256;
  __int16 v56 = 256;
  char v53 = 0;
  uint64_t v54 = -1;
  uint64_t v55 = 0;
  char v50 = 0;
  uint64_t v51 = 0xFFFFFFFFLL;
  uint64_t v52 = 0;
  uint64_t v46 = 0;
  char v47 = 0;
  uint64_t v48 = -1;
  uint64_t v49 = 0;
  int v44 = 0;
  char v45 = 0;
  uint64_t v41 = 0xFFFFFFFFLL;
  uint64_t v42 = 0;
  __int16 v43 = 256;
  uint64_t v39 = 0xFFFFFFFFLL;
  char v40 = 0;
  __int16 v38 = 256;
  uint64_t v34 = 0;
  char v35 = 0;
  uint64_t v36 = 7;
  uint64_t v37 = 0;
  __int16 v33 = 0;
  uint64_t v30 = 0;
  char v31 = 0;
  uint64_t v32 = 0xFFFFLL;
  int v29 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  __int16 v28 = a2;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v66)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v64)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "file"))
        {
          int v10 = &v62;
          char v11 = this;
          uint64_t v12 = "file";
          uint64_t v13 = 4;
        }
        else
        {
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v59)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "scope"))
          {
            int v10 = &v57;
            char v11 = this;
            uint64_t v12 = "scope";
            uint64_t v13 = 5;
          }
          else
          {
            if (sub_1CBA86C10((void *)this + 29, "baseType"))
            {
              char v14 = sub_1CC19E414((uint64_t)this, (uint64_t)"baseType", 8, (uint64_t)&v55);
              goto LABEL_23;
            }
            if (sub_1CBA86C10((void *)this + 29, "size"))
            {
              char v14 = sub_1CC19E288((uint64_t)this, (uint64_t)"size", 4, (uint64_t)&v52);
              goto LABEL_23;
            }
            if (sub_1CBA86C10((void *)this + 29, "align"))
            {
              char v14 = sub_1CC19E288((uint64_t)this, (uint64_t)"align", 5, (uint64_t)&v49);
              goto LABEL_23;
            }
            if (sub_1CBA86C10((void *)this + 29, "offset"))
            {
              char v14 = sub_1CC19E288((uint64_t)this, (uint64_t)"offset", 6, (uint64_t)&v46);
LABEL_23:
              if (v14) {
                return 1;
              }
              goto LABEL_6;
            }
            if (sub_1CBA86C10((void *)this + 29, "flags"))
            {
              if (sub_1CC19F40C((uint64_t)this, (uint64_t)&v44)) {
                return 1;
              }
              goto LABEL_6;
            }
            if (sub_1CBA86C10((void *)this + 29, "extraData"))
            {
              int v10 = &v42;
              char v11 = this;
              uint64_t v12 = "extraData";
              uint64_t v13 = 9;
            }
            else
            {
              if (sub_1CBA86C10((void *)this + 29, "dwarfAddressSpace"))
              {
                char v19 = "dwarfAddressSpace";
                uint64_t v20 = &v39;
                uint64_t v21 = this;
                uint64_t v22 = 17;
LABEL_50:
                if (sub_1CC19E288((uint64_t)v21, (uint64_t)v19, v22, (uint64_t)v20)) {
                  return 1;
                }
                goto LABEL_6;
              }
              if (!sub_1CBA86C10((void *)this + 29, "annotations"))
              {
                if (sub_1CBA86C10((void *)this + 29, "ptrAuthKey"))
                {
                  char v19 = "ptrAuthKey";
                  uint64_t v20 = &v34;
                  uint64_t v21 = this;
                  uint64_t v22 = 10;
                }
                else
                {
                  if (sub_1CBA86C10((void *)this + 29, "ptrAuthIsAddressDiscriminated"))
                  {
                    uint64_t v24 = "ptrAuthIsAddressDiscriminated";
                    char v25 = (char *)&v33;
                    uint64_t v26 = this;
                    uint64_t v27 = 29;
LABEL_61:
                    if (sub_1CC19E4DC((uint64_t)v26, (uint64_t)v24, v27, v25)) {
                      return 1;
                    }
                    goto LABEL_6;
                  }
                  if (!sub_1CBA86C10((void *)this + 29, "ptrAuthExtraDiscriminator"))
                  {
                    if (sub_1CBA86C10((void *)this + 29, "ptrAuthIsaPointer"))
                    {
                      uint64_t v24 = "ptrAuthIsaPointer";
                      char v25 = (char *)&v29 + 2;
                      uint64_t v26 = this;
                      uint64_t v27 = 17;
                    }
                    else
                    {
                      if (!sub_1CBA86C10((void *)this + 29, "ptrAuthAuthenticatesNullValues"))
                      {
                        unint64_t v73 = "invalid field '";
                        __int16 v74 = 259;
                        __int16 v72 = 260;
                        v71[0] = (uint64_t)this + 232;
                        sub_1CB8F1E58((uint64_t *)&v73, v71, (uint64_t)v75);
                        std::string::size_type v69 = "'";
                        __int16 v70 = 259;
                        sub_1CB8F1E58(v75, (uint64_t *)&v69, (uint64_t)v76);
                        if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v76)) {
                          return 1;
                        }
                        goto LABEL_6;
                      }
                      uint64_t v24 = "ptrAuthAuthenticatesNullValues";
                      char v25 = (char *)&v29;
                      uint64_t v26 = this;
                      uint64_t v27 = 30;
                    }
                    goto LABEL_61;
                  }
                  char v19 = "ptrAuthExtraDiscriminator";
                  uint64_t v20 = &v30;
                  uint64_t v21 = this;
                  uint64_t v22 = 25;
                }
                goto LABEL_50;
              }
              uint64_t v12 = "annotations";
              int v10 = &v37;
              char v11 = this;
              uint64_t v13 = 11;
            }
          }
        }
        if (sub_1CC19E414((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_30;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_39;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_39:
    v76[0] = "expected field label here";
    __int16 v77 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v76)) {
      return 1;
    }
  }
LABEL_30:
  uint64_t v15 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (!v67)
  {
    uint64_t v23 = "missing required field 'tag'";
LABEL_55:
    v76[0] = v23;
    __int16 v77 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v15, (llvm::Twine *)v76);
  }
  if (!(_BYTE)v56)
  {
    uint64_t v23 = "missing required field 'baseType'";
    goto LABEL_55;
  }
  uint64_t v16 = v34;
  if (v34) {
    uint64_t v16 = v34 & 0xF | (16 * v33) | (32 * v30) & 0xE0 | (BYTE2(v29) << 21) | (32 * v30) & 0x1FFF00 | (v29 << 22) | 0x100000000;
  }
  if (v39 == 0xFFFFFFFFLL) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v39 | 0x100000000;
  }
  uint64_t Impl = llvm::DIDerivedType::getImpl(*(void **)this, v66, v64, v62, v59, v57, v55, v52, v49, v46, v17, v16, v44, v42, v37, a3, 1);
  uint64_t result = 0;
  *__int16 v28 = (llvm::MDNode *)Impl;
  return result;
}

uint64_t llvm::LLParser::parseDICompositeType(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v111 = 0;
  char v112 = 0;
  uint64_t v113 = 0xFFFFLL;
  uint64_t v109 = 0;
  __int16 v110 = 256;
  uint64_t v107 = 0;
  __int16 v108 = 256;
  uint64_t v104 = 0;
  char v105 = 0;
  uint64_t v106 = 0xFFFFFFFFLL;
  uint64_t v102 = 0;
  __int16 v103 = 256;
  __int16 v101 = 256;
  uint64_t v96 = 0xFFFFFFFFLL;
  uint64_t v97 = 0;
  char v98 = 0;
  uint64_t v99 = -1;
  uint64_t v100 = 0;
  uint64_t v93 = -1;
  uint64_t v94 = 0;
  char v95 = 0;
  uint64_t v91 = 0;
  char v92 = 0;
  unsigned int v89 = 0;
  char v90 = 0;
  uint64_t v86 = 0xFFFFLL;
  uint64_t v87 = 0;
  __int16 v88 = 256;
  uint64_t v84 = 0;
  char v85 = 0;
  uint64_t v82 = 0;
  __int16 v83 = 256;
  uint64_t v80 = 0;
  __int16 v81 = 256;
  uint64_t v78 = 0;
  __int16 v79 = 256;
  unint64_t v76 = 0;
  __int16 v77 = 256;
  uint64_t v74 = 0;
  __int16 v75 = 256;
  uint64_t v72 = 0;
  __int16 v73 = 256;
  uint64_t v70 = 0;
  __int16 v71 = 256;
  *(void *)&long long v65 = 0;
  BYTE8(v65) = 0;
  long long v66 = xmmword_1CFAC4C60;
  long long v67 = xmmword_1CD96DBF0;
  char v68 = 0;
  int v69 = 0;
  uint64_t v63 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v64 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v61 = a3;
  uint64_t v62 = a2;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v111)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          int v10 = &v109;
          char v11 = this;
          uint64_t v12 = "name";
          uint64_t v13 = 4;
        }
        else
        {
          if (sub_1CBA86C10((void *)this + 29, "file"))
          {
            char v14 = &v107;
            uint64_t v15 = this;
            uint64_t v16 = "file";
            uint64_t v17 = 4;
            goto LABEL_15;
          }
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v104)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "scope"))
          {
            char v14 = &v102;
            uint64_t v15 = this;
            uint64_t v16 = "scope";
            uint64_t v17 = 5;
            goto LABEL_15;
          }
          if (sub_1CBA86C10((void *)this + 29, "baseType"))
          {
            uint64_t v18 = &v100;
            char v19 = this;
            uint64_t v20 = "baseType";
            uint64_t v21 = 8;
            goto LABEL_24;
          }
          if (sub_1CBA86C10((void *)this + 29, "size"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"size", 4, (uint64_t)&v97)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "align"))
          {
            __int16 v28 = &v94;
            int v29 = this;
            uint64_t v30 = "align";
            uint64_t v31 = 5;
            goto LABEL_32;
          }
          if (sub_1CBA86C10((void *)this + 29, "offset"))
          {
            __int16 v28 = &v91;
            int v29 = this;
            uint64_t v30 = "offset";
            uint64_t v31 = 6;
LABEL_32:
            if (sub_1CC19E288((uint64_t)v29, (uint64_t)v30, v31, (uint64_t)v28)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "flags"))
          {
            if (sub_1CC19F40C((uint64_t)this, (uint64_t)&v89)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "elements"))
          {
            char v14 = &v87;
            uint64_t v15 = this;
            uint64_t v16 = "elements";
            uint64_t v17 = 8;
            goto LABEL_15;
          }
          if (sub_1CBA86C10((void *)this + 29, "runtimeLang"))
          {
            if (sub_1CC19F5D0((uint64_t)this, (uint64_t)"runtimeLang", 11, (uint64_t)&v84)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "vtableHolder"))
          {
            uint64_t v16 = "vtableHolder";
            char v14 = &v82;
            goto LABEL_60;
          }
          if (sub_1CBA86C10((void *)this + 29, "templateParams"))
          {
            uint64_t v16 = "templateParams";
            char v14 = &v80;
            uint64_t v15 = this;
            uint64_t v17 = 14;
            goto LABEL_15;
          }
          if (!sub_1CBA86C10((void *)this + 29, "identifier"))
          {
            if (sub_1CBA86C10((void *)this + 29, "discriminator"))
            {
              uint64_t v16 = "discriminator";
              char v14 = (uint64_t *)&v76;
              uint64_t v15 = this;
              uint64_t v17 = 13;
            }
            else
            {
              if (!sub_1CBA86C10((void *)this + 29, "dataLocation"))
              {
                if (!sub_1CBA86C10((void *)this + 29, "associated"))
                {
                  if (sub_1CBA86C10((void *)this + 29, "allocated"))
                  {
                    uint64_t v20 = "allocated";
                    uint64_t v18 = &v70;
                    char v19 = this;
                    uint64_t v21 = 9;
                    goto LABEL_24;
                  }
                  if (sub_1CBA86C10((void *)this + 29, "rank"))
                  {
                    char v22 = sub_1CC19EB20((uint64_t)this, (uint64_t)"rank", 4, &v65);
                  }
                  else if (sub_1CBA86C10((void *)this + 29, "annotations"))
                  {
                    uint64_t v20 = "annotations";
                    uint64_t v18 = &v63;
                    char v19 = this;
                    uint64_t v21 = 11;
LABEL_24:
                    char v22 = sub_1CC19E414((uint64_t)v19, (uint64_t)v20, v21, (uint64_t)v18);
                  }
                  else
                  {
                    long long v118 = "invalid field '";
                    __int16 v119 = 259;
                    __int16 v117 = 260;
                    v116[0] = (uint64_t)this + 232;
                    sub_1CB8F1E58((uint64_t *)&v118, v116, (uint64_t)v120);
                    uint64_t v114 = "'";
                    __int16 v115 = 259;
                    sub_1CB8F1E58(v120, (uint64_t *)&v114, (uint64_t)v121);
                    char v22 = llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v121);
                  }
                  if (v22) {
                    return 1;
                  }
                  goto LABEL_6;
                }
                uint64_t v16 = "associated";
                char v14 = &v72;
                uint64_t v15 = this;
                uint64_t v17 = 10;
                goto LABEL_15;
              }
              uint64_t v16 = "dataLocation";
              char v14 = &v74;
LABEL_60:
              uint64_t v15 = this;
              uint64_t v17 = 12;
            }
LABEL_15:
            if (sub_1CC19E414((uint64_t)v15, (uint64_t)v16, v17, (uint64_t)v14)) {
              return 1;
            }
            goto LABEL_6;
          }
          uint64_t v12 = "identifier";
          int v10 = &v78;
          char v11 = this;
          uint64_t v13 = 10;
        }
        if (sub_1CC19E984((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_35;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_40;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_40:
    v121[0] = "expected field label here";
    __int16 v122 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v121)) {
      return 1;
    }
  }
LABEL_35:
  uint64_t v23 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (v112)
  {
    if (v69 == 2)
    {
      uint64_t v27 = v67;
    }
    else if (v69 == 1)
    {
      Signed = (llvm::ValueAsMetadata *)llvm::ConstantInt::getSigned((llvm::ConstantInt *)(**(void **)this + 1984), v65, v24);
      uint64_t v27 = llvm::ValueAsMetadata::get(Signed, v26);
    }
    else
    {
      uint64_t v27 = 0;
    }
    uint64_t v32 = v78;
    uint64_t v33 = v109;
    uint64_t v34 = v107;
    uint64_t v35 = v102;
    uint64_t v36 = v100;
    unsigned int v37 = v89;
    uint64_t v38 = v87;
    uint64_t v39 = v82;
    uint64_t v40 = v80;
    unint64_t v41 = v76;
    uint64_t v42 = v74;
    uint64_t v43 = v72;
    uint64_t v44 = v70;
    uint64_t v45 = v63;
    if (!v78) {
      goto LABEL_53;
    }
    uint64_t v59 = v80;
    uint64_t v60 = v78;
    uint64_t v46 = v109;
    unint64_t v56 = v76;
    uint64_t v57 = v72;
    uint64_t v58 = v87;
    uint64_t v47 = v102;
    uint64_t v48 = v74;
    uint64_t v49 = v82;
    uint64_t v50 = v107;
    uint64_t v55 = v70;
    uint64_t v51 = v100;
    uint64_t v52 = v27;
    uint64_t Impl = llvm::DICompositeType::buildODRType(*(void **)this, v78, v111, v109, v107, v104, v102, v100, v97, v94, v91, v89, v87, v84, v82, v80, v76, v74, v72,
             v70,
             v27,
             v63);
    uint64_t v39 = v49;
    uint64_t v42 = v48;
    uint64_t v27 = v52;
    uint64_t v36 = v51;
    uint64_t v44 = v55;
    unint64_t v41 = v56;
    uint64_t v34 = v50;
    uint64_t v43 = v57;
    uint64_t v38 = v58;
    uint64_t v33 = v46;
    uint64_t v35 = v47;
    uint64_t v40 = v59;
    uint64_t v32 = v60;
    if (!Impl) {
LABEL_53:
    }
      uint64_t Impl = llvm::DICompositeType::getImpl(*(void **)this, v111, v33, v34, v104, v35, v36, v97, v94, v91, v37, v38, v84, v39, v40, v32, v41, v42, v43,
               v44,
               v27,
               v45,
               v61,
               1);
    uint64_t v54 = (llvm::MDNode *)Impl;
    uint64_t result = 0;
    *uint64_t v62 = v54;
  }
  else
  {
    v121[0] = "missing required field 'tag'";
    __int16 v122 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v23, (llvm::Twine *)v121);
  }
  return result;
}

uint64_t llvm::LLParser::parseDISubroutineType(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  int v27 = 0;
  char v28 = 0;
  uint64_t v24 = 0;
  char v25 = 0;
  uint64_t v26 = 255;
  uint64_t v22 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v23 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "flags"))
      {
        if (sub_1CC19F40C((uint64_t)this, (uint64_t)&v27)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "cc"))
      {
        if (v25)
        {
          __int16 v40 = 1283;
          v39[0] = (uint64_t)"field '";
          v39[2] = (uint64_t)"cc";
          v39[3] = 2;
          v37[0] = (uint64_t)"' cannot be specified more than once";
          __int16 v38 = 259;
          uint64_t v18 = v37;
          goto LABEL_29;
        }
        int v11 = llvm::LLLexer::LexToken(v6);
        *((_DWORD *)this + 56) = v11;
        if (v11 == 447)
        {
          char v12 = *((unsigned char *)this + 255);
          BOOL v13 = v12 < 0;
          if (v12 >= 0) {
            char v14 = (char *)this + 232;
          }
          else {
            char v14 = (char *)*((void *)this + 29);
          }
          uint64_t v15 = v12 & 0x7F;
          if (v13) {
            uint64_t v16 = *((void *)this + 30);
          }
          else {
            uint64_t v16 = v15;
          }
          unsigned int CallingConvention = llvm::dwarf::getCallingConvention((uint64_t)v14, v16);
          if (CallingConvention)
          {
            char v25 = 1;
            uint64_t v24 = CallingConvention;
            int v9 = llvm::LLLexer::LexToken(v6);
            *((_DWORD *)this + 56) = v9;
            goto LABEL_7;
          }
          v35[0] = (uint64_t)"invalid DWARF calling convention";
          __int16 v36 = 259;
          v33[0] = (uint64_t)" '";
          __int16 v34 = 259;
          sub_1CB8F1E58(v35, v33, (uint64_t)v37);
          __int16 v32 = 260;
          v31[0] = (uint64_t)this + 232;
          sub_1CB8F1E58(v37, v31, (uint64_t)v39);
          int v29 = "'";
          __int16 v30 = 259;
          uint64_t v18 = (uint64_t *)&v29;
LABEL_29:
          sub_1CB8F1E58(v39, v18, (uint64_t)v41);
LABEL_30:
          if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v41)) {
            return 1;
          }
          goto LABEL_6;
        }
        if (v11 != 457)
        {
          v41[0] = "expected DWARF calling convention";
          __int16 v42 = 259;
          goto LABEL_30;
        }
        if (sub_1CC19E5CC((uint64_t)this, (uint64_t)"cc", 2, (uint64_t)&v24)) {
          return 1;
        }
      }
      else
      {
        if (!sub_1CBA86C10((void *)this + 29, "types"))
        {
          v37[0] = (uint64_t)"invalid field '";
          __int16 v38 = 259;
          __int16 v36 = 260;
          v35[0] = (uint64_t)this + 232;
          sub_1CB8F1E58(v37, v35, (uint64_t)v39);
          v33[0] = (uint64_t)"'";
          __int16 v34 = 259;
          uint64_t v18 = v33;
          goto LABEL_29;
        }
        if (sub_1CC19E414((uint64_t)this, (uint64_t)"types", 5, (uint64_t)&v22)) {
          return 1;
        }
      }
LABEL_6:
      int v9 = *((_DWORD *)this + 56);
LABEL_7:
      if (v9 != 4) {
        goto LABEL_35;
      }
      int v10 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v10;
      if (v10 != 437) {
        goto LABEL_38;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_38:
    v41[0] = "expected field label here";
    __int16 v42 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v41)) {
      return 1;
    }
  }
LABEL_35:
  char v19 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v23)
  {
    llvm::DISubroutineType::getImpl(*(void **)this, v27, v24, v22, a3, 1);
    uint64_t v21 = v20;
    uint64_t result = 0;
    *a2 = v21;
  }
  else
  {
    v41[0] = "missing required field 'types'";
    __int16 v42 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v19, (llvm::Twine *)v41);
  }
  return result;
}

uint64_t llvm::LLParser::parseDIFile(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v42 = 0;
  __int16 v43 = 256;
  uint64_t v40 = 0;
  __int16 v41 = 256;
  uint64_t v38 = 0;
  __int16 v39 = 256;
  uint64_t v36 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v37 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  uint64_t v35 = a2;
  int v34 = a3;
  int v9 = 0;
  if (v8 == 437)
  {
    int v10 = 1;
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "filename"))
      {
        int v11 = &v42;
        char v12 = this;
        BOOL v13 = "filename";
        goto LABEL_7;
      }
      if (sub_1CBA86C10((void *)this + 29, "directory")) {
        break;
      }
      if (!sub_1CBA86C10((void *)this + 29, "checksumkind"))
      {
        if (sub_1CBA86C10((void *)this + 29, "checksum"))
        {
          int v11 = &v38;
          char v12 = this;
          BOOL v13 = "checksum";
LABEL_7:
          uint64_t v14 = 8;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "source"))
          {
            v52[0] = (uint64_t)"invalid field '";
            __int16 v53 = 259;
            __int16 v51 = 260;
            v50[0] = (uint64_t)this + 232;
            sub_1CB8F1E58(v52, v50, (uint64_t)v54);
            v48[0] = (uint64_t)"'";
            __int16 v49 = 259;
            uint64_t v24 = v48;
LABEL_31:
            sub_1CB8F1E58(v54, v24, (uint64_t)&v56);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v56)) {
              return 1;
            }
            goto LABEL_9;
          }
          int v11 = &v36;
          char v12 = this;
          BOOL v13 = "source";
          uint64_t v14 = 6;
        }
LABEL_8:
        if (sub_1CC19E984((uint64_t)v12, (uint64_t)v13, v14, (uint64_t)v11)) {
          return 1;
        }
        goto LABEL_9;
      }
      if (v9)
      {
        __int16 v55 = 1283;
        v54[0] = (uint64_t)"field '";
        void v54[2] = (uint64_t)"checksumkind";
        v54[3] = 12;
        v52[0] = (uint64_t)"' cannot be specified more than once";
        __int16 v53 = 259;
        uint64_t v24 = v52;
        goto LABEL_31;
      }
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v6);
      char v17 = *((unsigned char *)this + 255);
      BOOL v18 = v17 < 0;
      if (v17 >= 0) {
        char v19 = (char *)this + 232;
      }
      else {
        char v19 = (char *)*((void *)this + 29);
      }
      uint64_t v20 = v17 & 0x7F;
      if (v18) {
        uint64_t v21 = *((void *)this + 30);
      }
      else {
        uint64_t v21 = v20;
      }
      uint64_t ChecksumKind = llvm::DIFile::getChecksumKind((uint64_t)v19, v21);
      if (*((_DWORD *)this + 56) == 454)
      {
        int v23 = ChecksumKind;
        if ((ChecksumKind & 0xFF00000000) != 0)
        {
          int v15 = llvm::LLLexer::LexToken(v6);
          *((_DWORD *)this + 56) = v15;
          int v9 = 1;
          int v10 = v23;
          goto LABEL_10;
        }
      }
      v50[0] = (uint64_t)"invalid checksum kind";
      __int16 v51 = 259;
      v48[0] = (uint64_t)" '";
      __int16 v49 = 259;
      sub_1CB8F1E58(v50, v48, (uint64_t)v52);
      __int16 v47 = 260;
      v46[0] = (uint64_t)this + 232;
      sub_1CB8F1E58(v52, v46, (uint64_t)v54);
      uint64_t v44 = "'";
      __int16 v45 = 259;
      sub_1CB8F1E58(v54, (uint64_t *)&v44, (uint64_t)&v56);
      if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v56)) {
        return 1;
      }
LABEL_9:
      int v15 = *((_DWORD *)this + 56);
LABEL_10:
      if (v15 != 4) {
        goto LABEL_36;
      }
      int v16 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v16;
      if (v16 != 437) {
        goto LABEL_46;
      }
    }
    int v11 = &v40;
    char v12 = this;
    BOOL v13 = "directory";
    uint64_t v14 = 9;
    goto LABEL_8;
  }
  int v10 = 1;
  if (v8 != 13)
  {
LABEL_46:
    *(void *)&long long v56 = "expected field label here";
    __int16 v58 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v56)) {
      return 1;
    }
  }
LABEL_36:
  char v25 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (!(_BYTE)v43)
  {
    uint64_t v31 = "missing required field 'filename'";
LABEL_54:
    *(void *)&long long v56 = v31;
    __int16 v58 = 259;
    uint64_t v32 = (uint64_t)v6;
    uint64_t v33 = v25;
    return llvm::LLLexer::Error(v32, v33, (llvm::Twine *)&v56);
  }
  if (!(_BYTE)v41)
  {
    uint64_t v31 = "missing required field 'directory'";
    goto LABEL_54;
  }
  char v27 = v39;
  if (!v9 || !(_BYTE)v39)
  {
    if (!v9 && !(_BYTE)v39)
    {
      int v10 = 0;
      goto LABEL_42;
    }
    *(void *)&long long v56 = "'checksumkind' and 'checksum' must be provided together";
    __int16 v58 = 259;
    uint64_t v33 = (char *)*((void *)this + 27);
    uint64_t v32 = (uint64_t)v6;
    return llvm::LLLexer::Error(v32, v33, (llvm::Twine *)&v56);
  }
  char v27 = 1;
  uint64_t v26 = v38;
LABEL_42:
  char v28 = *(void **)this;
  if ((_BYTE)v37) {
    uint64_t v29 = v36;
  }
  else {
    uint64_t v29 = 0;
  }
  LODWORD(v56) = v10;
  *((void *)&v56 + 1) = v26;
  char v57 = v27;
  uint64_t Impl = llvm::DIFile::getImpl(v28, v42, v40, &v56, v29, v37, v34 != 0, 1);
  uint64_t result = 0;
  *uint64_t v35 = Impl;
  return result;
}

uint64_t llvm::LLParser::parseDICompileUnit(llvm::LLParser *this, llvm::MDNode **a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    BOOL v13 = (char *)this + 168;
    v80[0] = "missing 'distinct', required for !DICompileUnit";
    __int16 v81 = 259;
    uint64_t v14 = (char *)*((void *)this + 27);
    return llvm::LLLexer::Error((uint64_t)v13, v14, (llvm::Twine *)v80);
  }
  uint64_t v70 = 0;
  char v71 = 0;
  uint64_t v72 = 0xFFFFLL;
  uint64_t v68 = 0;
  __int16 v69 = 0;
  uint64_t v66 = 0;
  __int16 v67 = 256;
  __int16 v65 = 0;
  __int16 v64 = 256;
  uint64_t v60 = 0;
  char v61 = 0;
  uint64_t v62 = 0xFFFFFFFFLL;
  uint64_t v63 = 0;
  __int16 v59 = 256;
  uint64_t v55 = 0;
  char v56 = 0;
  uint64_t v57 = 3;
  uint64_t v58 = 0;
  uint64_t v53 = 0;
  __int16 v54 = 256;
  uint64_t v51 = 0;
  __int16 v52 = 256;
  uint64_t v49 = 0;
  __int16 v50 = 256;
  uint64_t v47 = 0;
  __int16 v48 = 256;
  __int16 v46 = 256;
  uint64_t v42 = 0;
  char v43 = 0;
  uint64_t v44 = -1;
  uint64_t v45 = 0;
  uint64_t v5 = 1;
  __int16 v41 = 1;
  __int16 v40 = 0;
  uint64_t v37 = 0;
  char v38 = 0;
  uint64_t v39 = 2;
  __int16 v36 = 0;
  uint64_t v34 = 0;
  __int16 v35 = 256;
  uint64_t v32 = 0;
  __int16 v33 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) == 0)
  {
    int v6 = *((_DWORD *)this + 56);
    if (v6 == 437)
    {
      while (1)
      {
        if (sub_1CBA86C10((void *)this + 29, "language"))
        {
          if (sub_1CC19F5D0((uint64_t)this, (uint64_t)"language", 8, (uint64_t)&v70)) {
            return 1;
          }
        }
        else if (sub_1CBA86C10((void *)this + 29, "file"))
        {
          if (sub_1CC19E414((uint64_t)this, (uint64_t)"file", 4, (uint64_t)&v68)) {
            return 1;
          }
        }
        else
        {
          if (sub_1CBA86C10((void *)this + 29, "producer"))
          {
            int v8 = &v66;
            int v9 = this;
            int v10 = "producer";
            uint64_t v11 = 8;
            goto LABEL_14;
          }
          if (sub_1CBA86C10((void *)this + 29, "isOptimized"))
          {
            if (sub_1CC19E4DC((uint64_t)this, (uint64_t)"isOptimized", 11, (char *)&v65)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "flags"))
          {
            int v8 = &v63;
            int v9 = this;
            int v10 = "flags";
            uint64_t v11 = 5;
LABEL_14:
            if (sub_1CC19E984((uint64_t)v9, (uint64_t)v10, v11, (uint64_t)v8)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (!sub_1CBA86C10((void *)this + 29, "runtimeVersion"))
          {
            if (sub_1CBA86C10((void *)this + 29, "splitDebugFilename"))
            {
              char v12 = sub_1CC19E984((uint64_t)this, (uint64_t)"splitDebugFilename", 18, (uint64_t)&v58);
              goto LABEL_26;
            }
            if (sub_1CBA86C10((void *)this + 29, "emissionKind"))
            {
              char v12 = sub_1CC19F780((uint64_t)this, (uint64_t)&v55);
              goto LABEL_26;
            }
            if (sub_1CBA86C10((void *)this + 29, "enums"))
            {
              char v17 = &v53;
              BOOL v18 = this;
              char v19 = "enums";
              uint64_t v20 = 5;
              goto LABEL_42;
            }
            if (sub_1CBA86C10((void *)this + 29, "retainedTypes"))
            {
              char v17 = &v51;
              BOOL v18 = this;
              char v19 = "retainedTypes";
              uint64_t v20 = 13;
              goto LABEL_42;
            }
            if (sub_1CBA86C10((void *)this + 29, "globals"))
            {
              char v17 = &v49;
              BOOL v18 = this;
              char v19 = "globals";
              goto LABEL_47;
            }
            if (sub_1CBA86C10((void *)this + 29, "imports"))
            {
              char v19 = "imports";
              char v17 = &v47;
              BOOL v18 = this;
LABEL_47:
              uint64_t v20 = 7;
LABEL_42:
              char v12 = sub_1CC19E414((uint64_t)v18, (uint64_t)v19, v20, (uint64_t)v17);
LABEL_26:
              if (v12) {
                return 1;
              }
              goto LABEL_6;
            }
            if (sub_1CBA86C10((void *)this + 29, "macros"))
            {
              char v19 = "macros";
              char v17 = &v45;
              BOOL v18 = this;
              uint64_t v20 = 6;
              goto LABEL_42;
            }
            if (sub_1CBA86C10((void *)this + 29, "dwoId"))
            {
              char v12 = sub_1CC19E288((uint64_t)this, (uint64_t)"dwoId", 5, (uint64_t)&v42);
              goto LABEL_26;
            }
            if (sub_1CBA86C10((void *)this + 29, "splitDebugInlining"))
            {
              uint64_t v22 = "splitDebugInlining";
              int v23 = (char *)&v41;
              uint64_t v24 = this;
              uint64_t v25 = 18;
            }
            else if (sub_1CBA86C10((void *)this + 29, "debugInfoForProfiling"))
            {
              uint64_t v22 = "debugInfoForProfiling";
              int v23 = (char *)&v40;
              uint64_t v24 = this;
              uint64_t v25 = 21;
            }
            else
            {
              if (sub_1CBA86C10((void *)this + 29, "nameTableKind"))
              {
                char v12 = sub_1CC19F930((uint64_t)this, (uint64_t)&v37);
                goto LABEL_26;
              }
              if (!sub_1CBA86C10((void *)this + 29, "rangesBaseAddress"))
              {
                if (sub_1CBA86C10((void *)this + 29, "sysroot"))
                {
                  uint64_t v26 = "sysroot";
                  char v27 = &v34;
                  char v28 = this;
                  uint64_t v29 = 7;
                }
                else
                {
                  if (!sub_1CBA86C10((void *)this + 29, "sdk"))
                  {
                    __int16 v77 = "invalid field '";
                    __int16 v78 = 259;
                    __int16 v76 = 260;
                    v75[0] = (uint64_t)this + 232;
                    sub_1CB8F1E58((uint64_t *)&v77, v75, (uint64_t)v79);
                    __int16 v73 = "'";
                    __int16 v74 = 259;
                    sub_1CB8F1E58(v79, (uint64_t *)&v73, (uint64_t)v80);
                    char v12 = llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)v80);
                    goto LABEL_26;
                  }
                  uint64_t v26 = "sdk";
                  char v27 = &v32;
                  char v28 = this;
                  uint64_t v29 = 3;
                }
                char v12 = sub_1CC19E984((uint64_t)v28, (uint64_t)v26, v29, (uint64_t)v27);
                goto LABEL_26;
              }
              uint64_t v22 = "rangesBaseAddress";
              int v23 = (char *)&v36;
              uint64_t v24 = this;
              uint64_t v25 = 17;
            }
            char v12 = sub_1CC19E4DC((uint64_t)v24, (uint64_t)v22, v25, v23);
            goto LABEL_26;
          }
          if (sub_1CC19E288((uint64_t)this, (uint64_t)"runtimeVersion", 14, (uint64_t)&v60)) {
            return 1;
          }
        }
LABEL_6:
        if (*((_DWORD *)this + 56) != 4) {
          goto LABEL_34;
        }
        int v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
        *((_DWORD *)this + 56) = v7;
        if (v7 != 437) {
          goto LABEL_38;
        }
      }
    }
    if (v6 != 13)
    {
LABEL_38:
      v80[0] = "expected field label here";
      __int16 v81 = 259;
      if (llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)v80)) {
        return 1;
      }
    }
LABEL_34:
    int v16 = (char *)*((void *)this + 27);
    if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) == 0)
    {
      if (v71)
      {
        if ((_BYTE)v69)
        {
          *(void *)&long long v31 = v49;
          *((void *)&v31 + 1) = v47;
          *(void *)&long long v30 = v53;
          *((void *)&v30 + 1) = v51;
          uint64_t v5 = 0;
          *a2 = (llvm::MDNode *)llvm::DICompileUnit::getImpl(*(void *)this, v70, v68, v66, v65, v63, v60, v58, v55, v30, v31, v45, v42, v41, v40, v37, v36, v34, v32,
                                  1);
          return v5;
        }
        uint64_t v21 = "missing required field 'file'";
      }
      else
      {
        uint64_t v21 = "missing required field 'language'";
      }
      v80[0] = v21;
      __int16 v81 = 259;
      BOOL v13 = (char *)this + 168;
      uint64_t v14 = v16;
      return llvm::LLLexer::Error((uint64_t)v13, v14, (llvm::Twine *)v80);
    }
    return 1;
  }
  return v5;
}

uint64_t llvm::LLParser::parseDISubprogram(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  int v6 = (char *)*((void *)this + 27);
  __int16 v75 = 0;
  int v7 = (llvm::LLParser *)((char *)this + 168);
  __int16 v76 = 256;
  uint64_t v73 = 0;
  __int16 v74 = 256;
  char v71 = 0;
  __int16 v72 = 256;
  __int16 v70 = 256;
  uint64_t v66 = 0;
  char v67 = 0;
  uint64_t v68 = 0xFFFFFFFFLL;
  __int16 v69 = 0;
  *(void *)&v65[1] = 0;
  v65[5] = 256;
  v65[0] = 0;
  uint64_t v8 = 1;
  *(_WORD *)__int16 v64 = 1;
  uint64_t v61 = 0;
  char v62 = 0;
  uint64_t v63 = 0xFFFFFFFFLL;
  __int16 v60 = 256;
  uint64_t v55 = 0xFFFFFFFFLL;
  *(void *)char v56 = 0;
  char v57 = 0;
  uint64_t v58 = 2;
  uint64_t v59 = 0;
  uint64_t v53 = 0;
  char v54 = 0;
  uint64_t v50 = 0;
  char v51 = 0;
  long long v52 = xmmword_1CFAC4C70;
  unsigned int v48 = 0;
  char v49 = 0;
  unsigned int v46 = 0;
  char v47 = 0;
  *(_WORD *)uint64_t v45 = 0;
  uint64_t v43 = 0;
  __int16 v44 = 256;
  uint64_t v41 = 0;
  __int16 v42 = 256;
  uint64_t v39 = 0;
  __int16 v40 = 256;
  uint64_t v37 = 0;
  __int16 v38 = 256;
  uint64_t v35 = 0;
  __int16 v36 = 256;
  uint64_t v33 = 0;
  __int16 v34 = 256;
  uint64_t v31 = 0;
  __int16 v32 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return v8;
  int v10 = *((_DWORD *)this + 56);
  if (v10 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        uint64_t v11 = (uint64_t *)&v75;
        char v12 = this;
        BOOL v13 = "scope";
        uint64_t v14 = 5;
        goto LABEL_6;
      }
      if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        int v16 = &v73;
        char v17 = this;
        BOOL v18 = "name";
        uint64_t v19 = 4;
        goto LABEL_12;
      }
      if (sub_1CBA86C10((void *)this + 29, "linkageName"))
      {
        int v16 = (uint64_t *)&v71;
        char v17 = this;
        BOOL v18 = "linkageName";
        uint64_t v19 = 11;
LABEL_12:
        if (sub_1CC19E984((uint64_t)v17, (uint64_t)v18, v19, (uint64_t)v16)) {
          return 1;
        }
        goto LABEL_7;
      }
      if (sub_1CBA86C10((void *)this + 29, "file")) {
        break;
      }
      if (sub_1CBA86C10((void *)this + 29, "line"))
      {
        if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v66)) {
          return 1;
        }
        goto LABEL_7;
      }
      if (sub_1CBA86C10((void *)this + 29, "type"))
      {
        uint64_t v20 = (uint64_t *)&v65[1];
        uint64_t v21 = this;
        uint64_t v22 = "type";
        uint64_t v23 = 4;
        goto LABEL_24;
      }
      if (sub_1CBA86C10((void *)this + 29, "isLocal"))
      {
        uint64_t v25 = (BOOL *)v65;
        uint64_t v26 = this;
        char v27 = "isLocal";
        uint64_t v28 = 7;
        goto LABEL_29;
      }
      if (sub_1CBA86C10((void *)this + 29, "isDefinition"))
      {
        char v30 = sub_1CC19E4DC((uint64_t)this, (uint64_t)"isDefinition", 12, (char *)v64);
        goto LABEL_33;
      }
      if (sub_1CBA86C10((void *)this + 29, "scopeLine"))
      {
        char v30 = sub_1CC19E288((uint64_t)this, (uint64_t)"scopeLine", 9, (uint64_t)&v61);
        goto LABEL_33;
      }
      if (sub_1CBA86C10((void *)this + 29, "containingType"))
      {
        uint64_t v11 = &v59;
        char v12 = this;
        BOOL v13 = "containingType";
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "virtuality"))
        {
          if (sub_1CC19FAE0((uint64_t)this, (uint64_t)v56)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "virtualIndex"))
        {
          if (sub_1CC19E288((uint64_t)this, (uint64_t)"virtualIndex", 12, (uint64_t)&v53)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "thisAdjustment"))
        {
          if (sub_1CC19FC90((uint64_t)this, (uint64_t)&v50)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "flags"))
        {
          if (sub_1CC19F40C((uint64_t)this, (uint64_t)&v48)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "spFlags"))
        {
          if (sub_1CC19FD54((uint64_t)this, (uint64_t)&v46)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "isOptimized"))
        {
          char v27 = "isOptimized";
          uint64_t v25 = v45;
          uint64_t v26 = this;
          uint64_t v28 = 11;
LABEL_29:
          if (sub_1CC19E4DC((uint64_t)v26, (uint64_t)v27, v28, (char *)v25)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "unit"))
        {
          BOOL v13 = "unit";
          uint64_t v11 = &v43;
          char v12 = this;
          goto LABEL_18;
        }
        if (!sub_1CBA86C10((void *)this + 29, "templateParams"))
        {
          if (sub_1CBA86C10((void *)this + 29, "declaration"))
          {
            uint64_t v22 = "declaration";
            uint64_t v20 = &v39;
            goto LABEL_74;
          }
          if (sub_1CBA86C10((void *)this + 29, "retainedNodes"))
          {
            uint64_t v22 = "retainedNodes";
            uint64_t v20 = &v37;
            uint64_t v21 = this;
            uint64_t v23 = 13;
LABEL_24:
            char v24 = sub_1CC19E414((uint64_t)v21, (uint64_t)v22, v23, (uint64_t)v20);
LABEL_25:
            if (v24) {
              return 1;
            }
            goto LABEL_7;
          }
          if (sub_1CBA86C10((void *)this + 29, "thrownTypes"))
          {
            uint64_t v22 = "thrownTypes";
            uint64_t v20 = &v35;
          }
          else
          {
            if (!sub_1CBA86C10((void *)this + 29, "annotations"))
            {
              if (!sub_1CBA86C10((void *)this + 29, "targetFuncName"))
              {
                __int16 v81 = "invalid field '";
                __int16 v82 = 259;
                __int16 v80 = 260;
                v79[0] = (uint64_t)this + 232;
                sub_1CB8F1E58((uint64_t *)&v81, v79, (uint64_t)v83);
                __int16 v77 = "'";
                __int16 v78 = 259;
                sub_1CB8F1E58(v83, (uint64_t *)&v77, (uint64_t)v84);
                char v30 = llvm::LLLexer::Error((uint64_t)v7, *((char **)this + 27), (llvm::Twine *)v84);
LABEL_33:
                if (v30) {
                  return 1;
                }
                goto LABEL_7;
              }
              char v24 = sub_1CC19E984((uint64_t)this, (uint64_t)"targetFuncName", 14, (uint64_t)&v31);
              goto LABEL_25;
            }
            uint64_t v22 = "annotations";
            uint64_t v20 = &v33;
          }
LABEL_74:
          uint64_t v21 = this;
          uint64_t v23 = 11;
          goto LABEL_24;
        }
        BOOL v13 = "templateParams";
        uint64_t v11 = &v41;
        char v12 = this;
      }
      uint64_t v14 = 14;
LABEL_6:
      if (sub_1CC19E414((uint64_t)v12, (uint64_t)v13, v14, (uint64_t)v11)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_36;
      }
      int v15 = llvm::LLLexer::LexToken(v7);
      *((_DWORD *)this + 56) = v15;
      if (v15 != 437) {
        goto LABEL_42;
      }
    }
    uint64_t v11 = (uint64_t *)&v69;
    char v12 = this;
    BOOL v13 = "file";
LABEL_18:
    uint64_t v14 = 4;
    goto LABEL_6;
  }
  if (v10 != 13)
  {
LABEL_42:
    v84[0] = "expected field label here";
    __int16 v85 = 259;
    if (llvm::LLLexer::Error((uint64_t)v7, *((char **)this + 27), (llvm::Twine *)v84)) {
      return 1;
    }
  }
LABEL_36:
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (v47) {
    unsigned int v29 = v46;
  }
  else {
    unsigned int v29 = llvm::DISubprogram::toSPFlags((llvm::DISubprogram *)LOBYTE(v65[0]), v64[0], v45[0], v56[0], 0);
  }
  if ((v29 & 8) != 0 && (a3 & 1) == 0)
  {
    v84[0] = "missing 'distinct', required for !DISubprogram that is a Definition";
    __int16 v85 = 259;
    return llvm::LLLexer::Error((uint64_t)v7, v6, (llvm::Twine *)v84);
  }
  else
  {
    uint64_t v8 = 0;
    *a2 = (llvm::MDNode *)llvm::DISubprogram::getImpl(*(void **)this, v75, v73, v71, v69, v66, *(void **)&v65[1], v61, v59, __SPAIR64__(v50, v53), __SPAIR64__(v29, v48), v43, v41, v39, v37, v35, v33, v31, a3,
                            1);
  }
  return v8;
}

uint64_t llvm::LLParser::parseDILexicalBlock(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v24 = 0;
  __int16 v25 = 0;
  __int16 v23 = 256;
  char v20 = 0;
  uint64_t v21 = 0xFFFFFFFFLL;
  uint64_t v22 = 0;
  uint64_t v16 = 0;
  uint64_t v18 = 0xFFFFLL;
  uint64_t v19 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  char v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        int v9 = &v24;
        int v10 = this;
        uint64_t v11 = "scope";
        uint64_t v12 = 5;
      }
      else
      {
        if (!sub_1CBA86C10((void *)this + 29, "file"))
        {
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v19)) {
              return 1;
            }
          }
          else if (sub_1CBA86C10((void *)this + 29, "column"))
          {
            if (sub_1CC19E350((uint64_t)this, (uint64_t)&v16)) {
              return 1;
            }
          }
          else
          {
            char v30 = "invalid field '";
            __int16 v31 = 259;
            __int16 v29 = 260;
            v28[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v30, v28, (uint64_t)v32);
            uint64_t v26 = "'";
            __int16 v27 = 259;
            sub_1CB8F1E58(v32, (uint64_t *)&v26, (uint64_t)v33);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
              return 1;
            }
          }
          goto LABEL_7;
        }
        int v9 = &v22;
        int v10 = this;
        uint64_t v11 = "file";
        uint64_t v12 = 4;
      }
      if (sub_1CC19E414((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_21;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_24;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_24:
    v33[0] = "expected field label here";
    __int16 v34 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
      return 1;
    }
  }
LABEL_21:
  uint64_t v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v25)
  {
    uint64_t Impl = llvm::DILexicalBlock::getImpl(*(void **)this, v24, v22, v19, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v33[0] = "missing required field 'scope'";
    __int16 v34 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v33);
  }
  return result;
}

uint64_t llvm::LLParser::parseDILexicalBlockFile(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v22 = 0;
  __int16 v23 = 0;
  __int16 v21 = 256;
  uint64_t v17 = 0;
  char v18 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  uint64_t v19 = 0xFFFFFFFFLL;
  uint64_t v20 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        int v9 = &v22;
        int v10 = this;
        uint64_t v11 = "scope";
        uint64_t v12 = 5;
      }
      else
      {
        if (!sub_1CBA86C10((void *)this + 29, "file"))
        {
          if (sub_1CBA86C10((void *)this + 29, "discriminator"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"discriminator", 13, (uint64_t)&v17)) {
              return 1;
            }
          }
          else
          {
            uint64_t v28 = "invalid field '";
            __int16 v29 = 259;
            __int16 v27 = 260;
            v26[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v28, v26, (uint64_t)v30);
            uint64_t v24 = "'";
            __int16 v25 = 259;
            sub_1CB8F1E58(v30, (uint64_t *)&v24, (uint64_t)v31);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v31)) {
              return 1;
            }
          }
          goto LABEL_7;
        }
        int v9 = &v20;
        int v10 = this;
        uint64_t v11 = "file";
        uint64_t v12 = 4;
      }
      if (sub_1CC19E414((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_18;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_22;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_22:
    v31[0] = "expected field label here";
    __int16 v32 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v31)) {
      return 1;
    }
  }
LABEL_18:
  uint64_t v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v23)
  {
    if (v18)
    {
      uint64_t Impl = llvm::DILexicalBlockFile::getImpl(*(void **)this, v22, v20, v17, a3, 1);
      uint64_t result = 0;
      *a2 = Impl;
      return result;
    }
    uint64_t v16 = "missing required field 'discriminator'";
  }
  else
  {
    uint64_t v16 = "missing required field 'scope'";
  }
  v31[0] = v16;
  __int16 v32 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v31);
}

uint64_t llvm::LLParser::parseDINamespace(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v15 = 0;
  __int16 v16 = 256;
  uint64_t v13 = 0;
  __int16 v14 = 256;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v12 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    do
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        if (sub_1CC19E414((uint64_t)this, (uint64_t)"scope", 5, (uint64_t)&v15)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v13)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "exportSymbols"))
      {
        if (sub_1CC19E4DC((uint64_t)this, (uint64_t)"exportSymbols", 13, (char *)&v12)) {
          return 1;
        }
      }
      else
      {
        __int16 v21 = "invalid field '";
        __int16 v22 = 259;
        __int16 v20 = 260;
        v19[0] = (uint64_t)this + 232;
        sub_1CB8F1E58((uint64_t *)&v21, v19, (uint64_t)v23);
        uint64_t v17 = "'";
        __int16 v18 = 259;
        sub_1CB8F1E58(v23, (uint64_t *)&v17, (uint64_t)v24);
        if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v24)) {
          return 1;
        }
      }
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_18;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
    }
    while (v9 == 437);
  }
  else if (v8 == 13)
  {
    goto LABEL_18;
  }
  v24[0] = "expected field label here";
  __int16 v25 = 259;
  if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v24)) {
    return 1;
  }
LABEL_18:
  int v10 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v16)
  {
    uint64_t Impl = llvm::DINamespace::getImpl(*(void **)this, v15, v13, v12, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v24[0] = "missing required field 'scope'";
    __int16 v25 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v10, (llvm::Twine *)v24);
  }
  return result;
}

uint64_t llvm::LLParser::parseDIModule(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v32 = 0;
  __int16 v33 = 256;
  uint64_t v30 = 0;
  __int16 v31 = 256;
  uint64_t v28 = 0;
  __int16 v29 = 256;
  uint64_t v26 = 0;
  __int16 v27 = 256;
  uint64_t v24 = 0;
  __int16 v25 = 256;
  __int16 v23 = 256;
  uint64_t v19 = 0;
  char v20 = 0;
  uint64_t v21 = 0xFFFFFFFFLL;
  uint64_t v22 = 0;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v18 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        if (sub_1CC19E414((uint64_t)this, (uint64_t)"scope", 5, (uint64_t)&v32)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          int v10 = &v30;
          uint64_t v11 = this;
          __int16 v12 = "name";
          uint64_t v13 = 4;
        }
        else if (sub_1CBA86C10((void *)this + 29, "configMacros"))
        {
          int v10 = &v28;
          uint64_t v11 = this;
          __int16 v12 = "configMacros";
          uint64_t v13 = 12;
        }
        else if (sub_1CBA86C10((void *)this + 29, "includePath"))
        {
          int v10 = &v26;
          uint64_t v11 = this;
          __int16 v12 = "includePath";
          uint64_t v13 = 11;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "apinotes"))
          {
            if (sub_1CBA86C10((void *)this + 29, "file"))
            {
              char v14 = sub_1CC19E414((uint64_t)this, (uint64_t)"file", 4, (uint64_t)&v22);
            }
            else if (sub_1CBA86C10((void *)this + 29, "line"))
            {
              char v14 = sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v19);
            }
            else if (sub_1CBA86C10((void *)this + 29, "isDecl"))
            {
              char v14 = sub_1CC19E4DC((uint64_t)this, (uint64_t)"isDecl", 6, (char *)&v18);
            }
            else
            {
              __int16 v38 = "invalid field '";
              __int16 v39 = 259;
              __int16 v37 = 260;
              v36[0] = (uint64_t)this + 232;
              sub_1CB8F1E58((uint64_t *)&v38, v36, (uint64_t)v40);
              __int16 v34 = "'";
              __int16 v35 = 259;
              sub_1CB8F1E58(v40, (uint64_t *)&v34, (uint64_t)v41);
              char v14 = llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v41);
            }
            if (v14) {
              return 1;
            }
            goto LABEL_6;
          }
          int v10 = &v24;
          uint64_t v11 = this;
          __int16 v12 = "apinotes";
          uint64_t v13 = 8;
        }
        if (sub_1CC19E984((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_28;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_32;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_32:
    v41[0] = "expected field label here";
    __int16 v42 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v41)) {
      return 1;
    }
  }
LABEL_28:
  uint64_t v15 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v33)
  {
    if ((_BYTE)v31)
    {
      uint64_t Impl = llvm::DIModule::getImpl(*(void **)this, v22, v32, v30, v28, v26, v24, v19, v18, a3, 1);
      uint64_t result = 0;
      *a2 = Impl;
      return result;
    }
    uint64_t v17 = "missing required field 'name'";
  }
  else
  {
    uint64_t v17 = "missing required field 'scope'";
  }
  v41[0] = v17;
  __int16 v42 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v15, (llvm::Twine *)v41);
}

uint64_t llvm::LLParser::parseDITemplateTypeParameter(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v15 = 0;
  __int16 v16 = 256;
  uint64_t v13 = 0;
  __int16 v14 = 256;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v12 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    do
    {
      if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v15)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "type"))
      {
        if (sub_1CC19E414((uint64_t)this, (uint64_t)"type", 4, (uint64_t)&v13)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "defaulted"))
      {
        if (sub_1CC19E4DC((uint64_t)this, (uint64_t)"defaulted", 9, (char *)&v12)) {
          return 1;
        }
      }
      else
      {
        uint64_t v21 = "invalid field '";
        __int16 v22 = 259;
        __int16 v20 = 260;
        v19[0] = (uint64_t)this + 232;
        sub_1CB8F1E58((uint64_t *)&v21, v19, (uint64_t)v23);
        uint64_t v17 = "'";
        __int16 v18 = 259;
        sub_1CB8F1E58(v23, (uint64_t *)&v17, (uint64_t)v24);
        if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v24)) {
          return 1;
        }
      }
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_18;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
    }
    while (v9 == 437);
  }
  else if (v8 == 13)
  {
    goto LABEL_18;
  }
  v24[0] = "expected field label here";
  __int16 v25 = 259;
  if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v24)) {
    return 1;
  }
LABEL_18:
  int v10 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v14)
  {
    uint64_t Impl = llvm::DITemplateTypeParameter::getImpl(*(void **)this, v15, v13, v12, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v24[0] = "missing required field 'type'";
    __int16 v25 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v10, (llvm::Twine *)v24);
  }
  return result;
}

uint64_t llvm::LLParser::parseDITemplateValueParameter(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v23 = 48;
  char v24 = 0;
  uint64_t v25 = 0xFFFFLL;
  uint64_t v21 = 0;
  __int16 v22 = 256;
  uint64_t v19 = 0;
  __int16 v20 = 256;
  __int16 v18 = 0;
  __int16 v17 = 256;
  int v6 = (llvm::LLParser *)((char *)this + 168);
  uint64_t v16 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v23)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v21)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "type"))
        {
          int v10 = &v19;
          uint64_t v11 = this;
          __int16 v12 = "type";
          uint64_t v13 = 4;
        }
        else
        {
          if (sub_1CBA86C10((void *)this + 29, "defaulted"))
          {
            if (sub_1CC19E4DC((uint64_t)this, (uint64_t)"defaulted", 9, (char *)&v18)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (!sub_1CBA86C10((void *)this + 29, "value"))
          {
            uint64_t v30 = "invalid field '";
            __int16 v31 = 259;
            __int16 v29 = 260;
            v28[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v30, v28, (uint64_t)v32);
            uint64_t v26 = "'";
            __int16 v27 = 259;
            sub_1CB8F1E58(v32, (uint64_t *)&v26, (uint64_t)v33);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
              return 1;
            }
            goto LABEL_6;
          }
          int v10 = &v16;
          uint64_t v11 = this;
          __int16 v12 = "value";
          uint64_t v13 = 5;
        }
        if (sub_1CC19E414((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_22;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_25;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_25:
    v33[0] = "expected field label here";
    __int16 v34 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
      return 1;
    }
  }
LABEL_22:
  __int16 v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v17)
  {
    uint64_t Impl = llvm::DITemplateValueParameter::getImpl(*(void **)this, v23, v21, v19, v18, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v33[0] = "missing required field 'value'";
    __int16 v34 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v33);
  }
  return result;
}

uint64_t llvm::LLParser::parseDIGlobalVariable(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v43 = 0;
  __int16 v44 = 0;
  uint64_t v41 = 0;
  __int16 v42 = 256;
  uint64_t v39 = 0;
  __int16 v40 = 256;
  __int16 v38 = 256;
  uint64_t v34 = 0;
  char v35 = 0;
  uint64_t v36 = 0xFFFFFFFFLL;
  uint64_t v37 = 0;
  uint64_t v32 = 0;
  __int16 v33 = 256;
  __int16 v31 = 0;
  uint64_t v6 = 1;
  __int16 v30 = 1;
  uint64_t v28 = 0;
  __int16 v29 = 256;
  uint64_t v25 = 0xFFFFFFFFLL;
  uint64_t v26 = 0;
  __int16 v27 = 256;
  uint64_t v23 = 0;
  char v24 = 0;
  uint64_t v21 = 0;
  int v7 = (llvm::LLParser *)((char *)this + 168);
  __int16 v22 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if ((llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here") & 1) == 0)
  {
    int v9 = *((_DWORD *)this + 56);
    if (v9 == 437)
    {
      while (1)
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          int v10 = &v43;
          uint64_t v11 = this;
          __int16 v12 = "name";
          uint64_t v13 = 4;
        }
        else
        {
          if (sub_1CBA86C10((void *)this + 29, "scope"))
          {
            uint64_t v15 = &v41;
            uint64_t v16 = this;
            __int16 v17 = "scope";
            uint64_t v18 = 5;
LABEL_12:
            if (sub_1CC19E414((uint64_t)v16, (uint64_t)v17, v18, (uint64_t)v15)) {
              return 1;
            }
            goto LABEL_7;
          }
          if (!sub_1CBA86C10((void *)this + 29, "linkageName"))
          {
            if (sub_1CBA86C10((void *)this + 29, "file"))
            {
              uint64_t v15 = &v37;
              uint64_t v16 = this;
              __int16 v17 = "file";
              uint64_t v18 = 4;
            }
            else
            {
              if (sub_1CBA86C10((void *)this + 29, "line"))
              {
                if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v34)) {
                  return 1;
                }
                goto LABEL_7;
              }
              if (sub_1CBA86C10((void *)this + 29, "type"))
              {
                char v19 = sub_1CC19E414((uint64_t)this, (uint64_t)"type", 4, (uint64_t)&v32);
                goto LABEL_23;
              }
              if (sub_1CBA86C10((void *)this + 29, "isLocal"))
              {
                char v19 = sub_1CC19E4DC((uint64_t)this, (uint64_t)"isLocal", 7, (char *)&v31);
                goto LABEL_23;
              }
              if (sub_1CBA86C10((void *)this + 29, "isDefinition"))
              {
                char v19 = sub_1CC19E4DC((uint64_t)this, (uint64_t)"isDefinition", 12, (char *)&v30);
                goto LABEL_23;
              }
              if (sub_1CBA86C10((void *)this + 29, "templateParams"))
              {
                char v19 = sub_1CC19E414((uint64_t)this, (uint64_t)"templateParams", 14, (uint64_t)&v28);
LABEL_23:
                if (v19) {
                  return 1;
                }
                goto LABEL_7;
              }
              if (sub_1CBA86C10((void *)this + 29, "declaration"))
              {
                uint64_t v15 = &v26;
                uint64_t v16 = this;
                __int16 v17 = "declaration";
              }
              else
              {
                if (sub_1CBA86C10((void *)this + 29, "align"))
                {
                  if (sub_1CC19E288((uint64_t)this, (uint64_t)"align", 5, (uint64_t)&v23)) {
                    return 1;
                  }
                  goto LABEL_7;
                }
                if (!sub_1CBA86C10((void *)this + 29, "annotations"))
                {
                  char v49 = "invalid field '";
                  __int16 v50 = 259;
                  __int16 v48 = 260;
                  v47[0] = (uint64_t)this + 232;
                  sub_1CB8F1E58((uint64_t *)&v49, v47, (uint64_t)v51);
                  uint64_t v45 = "'";
                  __int16 v46 = 259;
                  sub_1CB8F1E58(v51, (uint64_t *)&v45, (uint64_t)v52);
                  if (llvm::LLLexer::Error((uint64_t)v7, *((char **)this + 27), (llvm::Twine *)v52)) {
                    return 1;
                  }
                  goto LABEL_7;
                }
                uint64_t v15 = &v21;
                uint64_t v16 = this;
                __int16 v17 = "annotations";
              }
              uint64_t v18 = 11;
            }
            goto LABEL_12;
          }
          int v10 = &v39;
          uint64_t v11 = this;
          __int16 v12 = "linkageName";
          uint64_t v13 = 11;
        }
        if (sub_1CC19E984((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
LABEL_7:
        if (*((_DWORD *)this + 56) != 4) {
          goto LABEL_30;
        }
        int v14 = llvm::LLLexer::LexToken(v7);
        *((_DWORD *)this + 56) = v14;
        if (v14 != 437) {
          goto LABEL_33;
        }
      }
    }
    if (v9 != 13)
    {
LABEL_33:
      v52[0] = "expected field label here";
      __int16 v53 = 259;
      if (llvm::LLLexer::Error((uint64_t)v7, *((char **)this + 27), (llvm::Twine *)v52)) {
        return 1;
      }
    }
LABEL_30:
    __int16 v20 = (char *)*((void *)this + 27);
    if ((llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here") & 1) == 0)
    {
      if ((_BYTE)v44)
      {
        uint64_t v6 = 0;
        *a2 = llvm::DIGlobalVariable::getImpl(*(void **)this, v41, v43, v39, v37, v34, v32, v31, v30, v26, v28, v23, v21, a3, 1);
      }
      else
      {
        v52[0] = "missing required field 'name'";
        __int16 v53 = 259;
        return llvm::LLLexer::Error((uint64_t)v7, v20, (llvm::Twine *)v52);
      }
      return v6;
    }
    return 1;
  }
  return v6;
}

uint64_t llvm::LLParser::parseDILocalVariable(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v36 = 0;
  __int16 v37 = 0;
  __int16 v35 = 256;
  uint64_t v31 = 0;
  char v32 = 0;
  uint64_t v33 = 0xFFFFLL;
  uint64_t v34 = 0;
  __int16 v30 = 256;
  uint64_t v26 = 0;
  char v27 = 0;
  uint64_t v28 = 0xFFFFFFFFLL;
  uint64_t v29 = 0;
  uint64_t v24 = 0;
  __int16 v25 = 256;
  int v22 = 0;
  char v23 = 0;
  uint64_t v19 = 0;
  char v20 = 0;
  uint64_t v21 = 0xFFFFFFFFLL;
  uint64_t v17 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v18 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        int v9 = &v36;
        int v10 = this;
        uint64_t v11 = "scope";
        uint64_t v12 = 5;
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v34)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (sub_1CBA86C10((void *)this + 29, "arg"))
        {
          if (sub_1CC19E288((uint64_t)this, (uint64_t)"arg", 3, (uint64_t)&v31)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (!sub_1CBA86C10((void *)this + 29, "file"))
        {
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v26)) {
              return 1;
            }
          }
          else
          {
            if (sub_1CBA86C10((void *)this + 29, "type"))
            {
              char v14 = sub_1CC19E414((uint64_t)this, (uint64_t)"type", 4, (uint64_t)&v24);
            }
            else if (sub_1CBA86C10((void *)this + 29, "flags"))
            {
              char v14 = sub_1CC19F40C((uint64_t)this, (uint64_t)&v22);
            }
            else if (sub_1CBA86C10((void *)this + 29, "align"))
            {
              char v14 = sub_1CC19E288((uint64_t)this, (uint64_t)"align", 5, (uint64_t)&v19);
            }
            else if (sub_1CBA86C10((void *)this + 29, "annotations"))
            {
              char v14 = sub_1CC19E414((uint64_t)this, (uint64_t)"annotations", 11, (uint64_t)&v17);
            }
            else
            {
              __int16 v42 = "invalid field '";
              __int16 v43 = 259;
              __int16 v41 = 260;
              v40[0] = (uint64_t)this + 232;
              sub_1CB8F1E58((uint64_t *)&v42, v40, (uint64_t)v44);
              __int16 v38 = "'";
              __int16 v39 = 259;
              sub_1CB8F1E58(v44, (uint64_t *)&v38, (uint64_t)v45);
              char v14 = llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v45);
            }
            if (v14) {
              return 1;
            }
          }
          goto LABEL_7;
        }
        int v9 = &v29;
        int v10 = this;
        uint64_t v11 = "file";
        uint64_t v12 = 4;
      }
      if (sub_1CC19E414((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_30;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_33;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_33:
    v45[0] = "expected field label here";
    __int16 v46 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v45)) {
      return 1;
    }
  }
LABEL_30:
  uint64_t v15 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v37)
  {
    uint64_t Impl = llvm::DILocalVariable::getImpl(*(void **)this, v36, v34, v29, v26, v24, v31, v22, v19, v17, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v45[0] = "missing required field 'scope'";
    __int16 v46 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v15, (llvm::Twine *)v45);
  }
  return result;
}

uint64_t llvm::LLParser::parseDILabel(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v24 = 0;
  __int16 v25 = 0;
  uint64_t v22 = 0;
  __int16 v23 = 256;
  __int16 v21 = 256;
  uint64_t v17 = 0;
  uint64_t v19 = 0xFFFFFFFFLL;
  uint64_t v20 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  char v18 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        int v9 = &v24;
        int v10 = this;
        uint64_t v11 = "scope";
        uint64_t v12 = 5;
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v22)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (!sub_1CBA86C10((void *)this + 29, "file"))
        {
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v17)) {
              return 1;
            }
          }
          else
          {
            __int16 v30 = "invalid field '";
            __int16 v31 = 259;
            __int16 v29 = 260;
            v28[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v30, v28, (uint64_t)v32);
            uint64_t v26 = "'";
            __int16 v27 = 259;
            sub_1CB8F1E58(v32, (uint64_t *)&v26, (uint64_t)v33);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
              return 1;
            }
          }
          goto LABEL_7;
        }
        int v9 = &v20;
        int v10 = this;
        uint64_t v11 = "file";
        uint64_t v12 = 4;
      }
      if (sub_1CC19E414((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_21;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_27;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_27:
    v33[0] = "expected field label here";
    __int16 v34 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
      return 1;
    }
  }
LABEL_21:
  char v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v25)
  {
    if ((_BYTE)v23)
    {
      if ((_BYTE)v21)
      {
        if (v18)
        {
          uint64_t Impl = llvm::DILabel::getImpl(*(void **)this, v24, v22, v20, v17, a3, 1);
          uint64_t result = 0;
          *a2 = Impl;
          return result;
        }
        uint64_t v16 = "missing required field 'line'";
      }
      else
      {
        uint64_t v16 = "missing required field 'file'";
      }
    }
    else
    {
      uint64_t v16 = "missing required field 'name'";
    }
  }
  else
  {
    uint64_t v16 = "missing required field 'scope'";
  }
  v33[0] = v16;
  __int16 v34 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v33);
}

uint64_t llvm::LLParser::parseDIObjCProperty(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v33 = 0;
  __int16 v34 = 256;
  __int16 v32 = 256;
  uint64_t v28 = 0;
  char v29 = 0;
  uint64_t v30 = 0xFFFFFFFFLL;
  uint64_t v31 = 0;
  uint64_t v26 = 0;
  __int16 v27 = 256;
  uint64_t v23 = 0xFFFFFFFFLL;
  uint64_t v24 = 0;
  __int16 v25 = 256;
  uint64_t v21 = 0;
  char v22 = 0;
  uint64_t v19 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v20 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        int v9 = &v33;
        int v10 = this;
        uint64_t v11 = "name";
        uint64_t v12 = 4;
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "file"))
        {
          char v14 = &v31;
          uint64_t v15 = this;
          uint64_t v16 = "file";
LABEL_13:
          if (sub_1CC19E414((uint64_t)v15, (uint64_t)v16, 4, (uint64_t)v14)) {
            return 1;
          }
          goto LABEL_8;
        }
        if (sub_1CBA86C10((void *)this + 29, "line"))
        {
          if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v28)) {
            return 1;
          }
          goto LABEL_8;
        }
        if (sub_1CBA86C10((void *)this + 29, "setter"))
        {
          int v9 = &v26;
          int v10 = this;
          uint64_t v11 = "setter";
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "getter"))
          {
            if (sub_1CBA86C10((void *)this + 29, "attributes"))
            {
              if (sub_1CC19E288((uint64_t)this, (uint64_t)"attributes", 10, (uint64_t)&v21)) {
                return 1;
              }
              goto LABEL_8;
            }
            if (!sub_1CBA86C10((void *)this + 29, "type"))
            {
              __int16 v39 = "invalid field '";
              __int16 v40 = 259;
              __int16 v38 = 260;
              v37[0] = (uint64_t)this + 232;
              sub_1CB8F1E58((uint64_t *)&v39, v37, (uint64_t)v41);
              __int16 v35 = "'";
              __int16 v36 = 259;
              sub_1CB8F1E58(v41, (uint64_t *)&v35, (uint64_t)v42);
              if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v42)) {
                return 1;
              }
              goto LABEL_8;
            }
            char v14 = &v19;
            uint64_t v15 = this;
            uint64_t v16 = "type";
            goto LABEL_13;
          }
          int v9 = &v24;
          int v10 = this;
          uint64_t v11 = "getter";
        }
        uint64_t v12 = 6;
      }
      if (sub_1CC19E984((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_8:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_29;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_31;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_31:
    v42[0] = "expected field label here";
    __int16 v43 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v42)) {
      return 1;
    }
  }
LABEL_29:
  char v17 = llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here");
  uint64_t result = 1;
  if ((v17 & 1) == 0)
  {
    uint64_t Impl = llvm::DIObjCProperty::getImpl(*(void **)this, v33, v31, v28, v26, v24, v21, v19, a3, 1);
    uint64_t result = 0;
    *a2 = (llvm::MDNode *)Impl;
  }
  return result;
}

uint64_t llvm::LLParser::parseDIImportedEntity(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v30 = 0;
  char v31 = 0;
  uint64_t v32 = 0xFFFFLL;
  uint64_t v28 = 0;
  __int16 v29 = 256;
  uint64_t v26 = 0;
  __int16 v27 = 256;
  __int16 v25 = 256;
  uint64_t v21 = 0;
  char v22 = 0;
  uint64_t v23 = 0xFFFFFFFFLL;
  uint64_t v24 = 0;
  uint64_t v19 = 0;
  __int16 v20 = 256;
  uint64_t v17 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  __int16 v18 = 256;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v30)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "scope"))
        {
          int v10 = &v28;
          uint64_t v11 = this;
          uint64_t v12 = "scope";
          uint64_t v13 = 5;
        }
        else if (sub_1CBA86C10((void *)this + 29, "entity"))
        {
          int v10 = &v26;
          uint64_t v11 = this;
          uint64_t v12 = "entity";
          uint64_t v13 = 6;
        }
        else if (sub_1CBA86C10((void *)this + 29, "file"))
        {
          int v10 = &v24;
          uint64_t v11 = this;
          uint64_t v12 = "file";
          uint64_t v13 = 4;
        }
        else
        {
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v21)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (sub_1CBA86C10((void *)this + 29, "name"))
          {
            if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v19)) {
              return 1;
            }
            goto LABEL_6;
          }
          if (!sub_1CBA86C10((void *)this + 29, "elements"))
          {
            __int16 v37 = "invalid field '";
            __int16 v38 = 259;
            __int16 v36 = 260;
            v35[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v37, v35, (uint64_t)v39);
            uint64_t v33 = "'";
            __int16 v34 = 259;
            sub_1CB8F1E58(v39, (uint64_t *)&v33, (uint64_t)v40);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v40)) {
              return 1;
            }
            goto LABEL_6;
          }
          int v10 = &v17;
          uint64_t v11 = this;
          uint64_t v12 = "elements";
          uint64_t v13 = 8;
        }
        if (sub_1CC19E414((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_26;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_30;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_30:
    v40[0] = "expected field label here";
    __int16 v41 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v40)) {
      return 1;
    }
  }
LABEL_26:
  char v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (v31)
  {
    if ((_BYTE)v29)
    {
      uint64_t Impl = llvm::DIImportedEntity::getImpl(*(void **)this, v30, v28, v26, v24, v21, v19, v17, a3, 1);
      uint64_t result = 0;
      *a2 = Impl;
      return result;
    }
    uint64_t v16 = "missing required field 'scope'";
  }
  else
  {
    uint64_t v16 = "missing required field 'tag'";
  }
  v40[0] = v16;
  __int16 v41 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v40);
}

uint64_t llvm::LLParser::parseDIMacro(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  char v25 = 0;
  uint64_t v26 = 255;
  uint64_t v21 = 0;
  char v22 = 0;
  uint64_t v23 = 0xFFFFFFFFLL;
  uint64_t v24 = 0;
  unint64_t v19 = 0;
  __int16 v20 = 256;
  __int16 v18 = 256;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  unint64_t v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "type"))
      {
        if (sub_1CC19FF18((uint64_t)this, (uint64_t)&v24)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "line"))
      {
        if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v21)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          int v10 = &v19;
          uint64_t v11 = this;
          uint64_t v12 = "name";
          uint64_t v13 = 4;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "value"))
          {
            char v31 = "invalid field '";
            __int16 v32 = 259;
            __int16 v30 = 260;
            v29[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v31, v29, (uint64_t)v33);
            __int16 v27 = "'";
            __int16 v28 = 259;
            sub_1CB8F1E58(v33, (uint64_t *)&v27, (uint64_t)v34);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34)) {
              return 1;
            }
            goto LABEL_6;
          }
          int v10 = &v17;
          uint64_t v11 = this;
          uint64_t v12 = "value";
          uint64_t v13 = 5;
        }
        if (sub_1CC19E984((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_21;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_25;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_25:
    v34[0] = "expected field label here";
    __int16 v35 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34)) {
      return 1;
    }
  }
LABEL_21:
  char v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (v25)
  {
    if ((_BYTE)v20)
    {
      uint64_t Impl = llvm::DIMacro::getImpl(*(void **)this, v24, v21, v19, v17, a3, 1);
      uint64_t result = 0;
      *a2 = Impl;
      return result;
    }
    uint64_t v16 = "missing required field 'name'";
  }
  else
  {
    uint64_t v16 = "missing required field 'type'";
  }
  v34[0] = v16;
  __int16 v35 = 259;
  return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v34);
}

uint64_t llvm::LLParser::parseDIMacroFile(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v23 = 3;
  char v24 = 0;
  uint64_t v25 = 255;
  uint64_t v20 = 0;
  char v21 = 0;
  uint64_t v22 = 0xFFFFFFFFLL;
  unint64_t v18 = 0;
  __int16 v19 = 256;
  __int16 v17 = 256;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  unint64_t v16 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "type"))
      {
        if (sub_1CC19FF18((uint64_t)this, (uint64_t)&v23)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "line"))
      {
        if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v20)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "file"))
        {
          int v10 = &v18;
          uint64_t v11 = this;
          uint64_t v12 = "file";
          uint64_t v13 = 4;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "nodes"))
          {
            __int16 v30 = "invalid field '";
            __int16 v31 = 259;
            __int16 v29 = 260;
            v28[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v30, v28, (uint64_t)v32);
            uint64_t v26 = "'";
            __int16 v27 = 259;
            sub_1CB8F1E58(v32, (uint64_t *)&v26, (uint64_t)v33);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
              return 1;
            }
            goto LABEL_6;
          }
          int v10 = &v16;
          uint64_t v11 = this;
          uint64_t v12 = "nodes";
          uint64_t v13 = 5;
        }
        if (sub_1CC19E414((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_6:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_21;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_24;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_24:
    v33[0] = "expected field label here";
    __int16 v34 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v33)) {
      return 1;
    }
  }
LABEL_21:
  char v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v19)
  {
    uint64_t Impl = llvm::DIMacroFile::getImpl(*(void **)this, v23, v20, v18, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v33[0] = "missing required field 'file'";
    __int16 v34 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v33);
  }
  return result;
}

uint64_t llvm::LLParser::parseDICommonBlock(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v25 = 0;
  __int16 v26 = 256;
  uint64_t v23 = 0;
  __int16 v24 = 256;
  uint64_t v21 = 0;
  __int16 v22 = 256;
  __int16 v20 = 256;
  uint64_t v16 = 0;
  uint64_t v18 = 0xFFFFFFFFLL;
  uint64_t v19 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  char v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "scope"))
      {
        int v9 = &v25;
        int v10 = this;
        uint64_t v11 = "scope";
        uint64_t v12 = 5;
      }
      else if (sub_1CBA86C10((void *)this + 29, "declaration"))
      {
        int v9 = &v23;
        int v10 = this;
        uint64_t v11 = "declaration";
        uint64_t v12 = 11;
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "name"))
        {
          if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v21)) {
            return 1;
          }
          goto LABEL_7;
        }
        if (!sub_1CBA86C10((void *)this + 29, "file"))
        {
          if (sub_1CBA86C10((void *)this + 29, "line"))
          {
            if (sub_1CC19E288((uint64_t)this, (uint64_t)"line", 4, (uint64_t)&v16)) {
              return 1;
            }
          }
          else
          {
            __int16 v31 = "invalid field '";
            __int16 v32 = 259;
            __int16 v30 = 260;
            v29[0] = (uint64_t)this + 232;
            sub_1CB8F1E58((uint64_t *)&v31, v29, (uint64_t)v33);
            __int16 v27 = "'";
            __int16 v28 = 259;
            sub_1CB8F1E58(v33, (uint64_t *)&v27, (uint64_t)v34);
            if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34)) {
              return 1;
            }
          }
          goto LABEL_7;
        }
        int v9 = &v19;
        int v10 = this;
        uint64_t v11 = "file";
        uint64_t v12 = 4;
      }
      if (sub_1CC19E414((uint64_t)v10, (uint64_t)v11, v12, (uint64_t)v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_21;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_24;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_24:
    v34[0] = "expected field label here";
    __int16 v35 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v34)) {
      return 1;
    }
  }
LABEL_21:
  char v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if ((_BYTE)v26)
  {
    uint64_t Impl = llvm::DICommonBlock::getImpl(*(void **)this, v25, v23, v21, v19, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  else
  {
    v34[0] = "missing required field 'scope'";
    __int16 v35 = 259;
    return llvm::LLLexer::Error((uint64_t)v6, v14, (llvm::Twine *)v34);
  }
  return result;
}

uint64_t llvm::LLParser::parseDIStringType(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v33 = 18;
  char v34 = 0;
  uint64_t v35 = 0xFFFFLL;
  uint64_t v31 = 0;
  __int16 v32 = 256;
  uint64_t v29 = 0;
  __int16 v30 = 256;
  uint64_t v27 = 0;
  __int16 v28 = 256;
  __int16 v26 = 256;
  char v23 = 0;
  uint64_t v24 = -1;
  uint64_t v25 = 0;
  char v20 = 0;
  uint64_t v21 = 0xFFFFFFFFLL;
  uint64_t v22 = 0;
  uint64_t v16 = 0;
  uint64_t v18 = 255;
  uint64_t v19 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  char v17 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "tag"))
      {
        if (sub_1CC19E7D4((uint64_t)this, (uint64_t)&v33)) {
          return 1;
        }
      }
      else if (sub_1CBA86C10((void *)this + 29, "name"))
      {
        if (sub_1CC19E984((uint64_t)this, (uint64_t)"name", 4, (uint64_t)&v31)) {
          return 1;
        }
      }
      else
      {
        if (sub_1CBA86C10((void *)this + 29, "stringLength"))
        {
          int v10 = &v29;
          uint64_t v11 = this;
          uint64_t v12 = "stringLength";
          uint64_t v13 = 12;
        }
        else if (sub_1CBA86C10((void *)this + 29, "stringLengthExpression"))
        {
          int v10 = &v27;
          uint64_t v11 = this;
          uint64_t v12 = "stringLengthExpression";
          uint64_t v13 = 22;
        }
        else
        {
          if (!sub_1CBA86C10((void *)this + 29, "stringLocationExpression"))
          {
            if (sub_1CBA86C10((void *)this + 29, "size"))
            {
              if (sub_1CC19E288((uint64_t)this, (uint64_t)"size", 4, (uint64_t)&v22)) {
                return 1;
              }
            }
            else if (sub_1CBA86C10((void *)this + 29, "align"))
            {
              if (sub_1CC19E288((uint64_t)this, (uint64_t)"align", 5, (uint64_t)&v19)) {
                return 1;
              }
            }
            else if (sub_1CBA86C10((void *)this + 29, "encoding"))
            {
              if (sub_1CC19F260((uint64_t)this, (uint64_t)&v16)) {
                return 1;
              }
            }
            else
            {
              __int16 v40 = "invalid field '";
              __int16 v41 = 259;
              __int16 v39 = 260;
              v38[0] = (uint64_t)this + 232;
              sub_1CB8F1E58((uint64_t *)&v40, v38, (uint64_t)v42);
              __int16 v36 = "'";
              __int16 v37 = 259;
              sub_1CB8F1E58(v42, (uint64_t *)&v36, (uint64_t)v43);
              if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v43)) {
                return 1;
              }
            }
            goto LABEL_7;
          }
          int v10 = &v25;
          uint64_t v11 = this;
          uint64_t v12 = "stringLocationExpression";
          uint64_t v13 = 24;
        }
        if (sub_1CC19E414((uint64_t)v11, (uint64_t)v12, v13, (uint64_t)v10)) {
          return 1;
        }
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_31;
      }
      int v9 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v9;
      if (v9 != 437) {
        goto LABEL_33;
      }
    }
  }
  if (v8 != 13)
  {
LABEL_33:
    v43[0] = "expected field label here";
    __int16 v44 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)v43)) {
      return 1;
    }
  }
LABEL_31:
  char v14 = llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here");
  uint64_t result = 1;
  if ((v14 & 1) == 0)
  {
    uint64_t Impl = llvm::DIStringType::getImpl(*(void **)this, v33, v31, v29, v27, v25, v22, v19, v16, a3, 1);
    uint64_t result = 0;
    *a2 = Impl;
  }
  return result;
}

uint64_t llvm::LLParser::parseDIGenericSubrange(llvm::LLParser *this, llvm::MDNode **a2, int a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v41 = 0;
  char v42 = 0;
  long long v43 = xmmword_1CFAC4C60;
  long long v44 = xmmword_1CD96DBF0;
  char v45 = 0;
  int v46 = 0;
  uint64_t v35 = 0;
  char v36 = 0;
  long long v37 = xmmword_1CFAC4C60;
  long long v38 = xmmword_1CD96DBF0;
  char v39 = 0;
  int v40 = 0;
  uint64_t v29 = 0;
  char v30 = 0;
  long long v31 = xmmword_1CFAC4C60;
  long long v32 = xmmword_1CD96DBF0;
  char v33 = 0;
  int v34 = 0;
  uint64_t v23 = 0;
  char v24 = 0;
  long long v25 = xmmword_1CFAC4C60;
  long long v26 = xmmword_1CD96DBF0;
  char v27 = 0;
  uint64_t v6 = (llvm::LLParser *)((char *)this + 168);
  int v28 = 0;
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  int v8 = *((_DWORD *)this + 56);
  if (v8 == 437)
  {
    while (1)
    {
      if (sub_1CBA86C10((void *)this + 29, "count"))
      {
        int v9 = (long long *)&v41;
        int v10 = this;
        uint64_t v11 = "count";
        uint64_t v12 = 5;
        goto LABEL_6;
      }
      if (sub_1CBA86C10((void *)this + 29, "lowerBound")) {
        break;
      }
      if (sub_1CBA86C10((void *)this + 29, "upperBound"))
      {
        int v9 = (long long *)&v29;
        int v10 = this;
        uint64_t v11 = "upperBound";
        goto LABEL_12;
      }
      if (!sub_1CBA86C10((void *)this + 29, "stride"))
      {
        char v51 = "invalid field '";
        __int16 v52 = 259;
        __int16 v50 = 260;
        v49[0] = (uint64_t)this + 232;
        sub_1CB8F1E58((uint64_t *)&v51, v49, (uint64_t)v53);
        char v47 = "'";
        __int16 v48 = 259;
        sub_1CB8F1E58(v53, (uint64_t *)&v47, (uint64_t)&v54);
        if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v54)) {
          return 1;
        }
        goto LABEL_7;
      }
      int v9 = (long long *)&v23;
      int v10 = this;
      uint64_t v11 = "stride";
      uint64_t v12 = 6;
LABEL_6:
      if (sub_1CC19EB20((uint64_t)v10, (uint64_t)v11, v12, v9)) {
        return 1;
      }
LABEL_7:
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_20;
      }
      int v13 = llvm::LLLexer::LexToken(v6);
      *((_DWORD *)this + 56) = v13;
      if (v13 != 437) {
        goto LABEL_24;
      }
    }
    int v9 = (long long *)&v35;
    int v10 = this;
    uint64_t v11 = "lowerBound";
LABEL_12:
    uint64_t v12 = 10;
    goto LABEL_6;
  }
  if (v8 != 13)
  {
LABEL_24:
    uint64_t v54 = (uint64_t)"expected field label here";
    __int16 v56 = 259;
    if (llvm::LLLexer::Error((uint64_t)v6, *((char **)this + 27), (llvm::Twine *)&v54)) {
      return 1;
    }
  }
LABEL_20:
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here")) {
    return 1;
  }
  if (v46 == 2)
  {
    uint64_t Impl = (llvm::MDNode *)v44;
  }
  else if (v46 == 1)
  {
    char v14 = *(void **)this;
    uint64_t v54 = 17;
    uint64_t v55 = v41;
    uint64_t Impl = llvm::DIExpression::getImpl(v14, &v54, 2, 0, 1);
  }
  else
  {
    uint64_t Impl = 0;
  }
  if (v40 == 2)
  {
    char v17 = (llvm::MDNode *)v38;
  }
  else if (v40 == 1)
  {
    uint64_t v16 = *(void **)this;
    uint64_t v54 = 17;
    uint64_t v55 = v35;
    char v17 = llvm::DIExpression::getImpl(v16, &v54, 2, 0, 1);
  }
  else
  {
    char v17 = 0;
  }
  if (v34 == 2)
  {
    uint64_t v19 = (llvm::MDNode *)v32;
  }
  else if (v34 == 1)
  {
    uint64_t v18 = *(void **)this;
    uint64_t v54 = 17;
    uint64_t v55 = v29;
    uint64_t v19 = llvm::DIExpression::getImpl(v18, &v54, 2, 0, 1);
  }
  else
  {
    uint64_t v19 = 0;
  }
  if (v28 == 2)
  {
    uint64_t v21 = (llvm::MDNode *)v26;
  }
  else if (v28 == 1)
  {
    char v20 = *(void **)this;
    uint64_t v54 = 17;
    uint64_t v55 = v23;
    uint64_t v21 = llvm::DIExpression::getImpl(v20, &v54, 2, 0, 1);
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t v22 = llvm::DIGenericSubrange::getImpl(*(void **)this, (uint64_t)Impl, (uint64_t)v17, (uint64_t)v19, (uint64_t)v21, a3, 1);
  uint64_t result = 0;
  *a2 = v22;
  return result;
}

uint64_t llvm::LLParser::parseDIArgList(llvm::LLParser *this, llvm::MDNode **a2, int a3, llvm::LLParser::PerFunctionState *a4)
{
  uint64_t v18[4] = *MEMORY[0x1E4F143B8];
  int v8 = (llvm::LLParser *)((char *)this + 168);
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  if (llvm::LLParser::parseToken((uint64_t)this, 12, "expected '(' here"))
    return 1;
  uint64_t v16 = v18;
  uint64_t v17 = 0x400000000;
  if (*((_DWORD *)this + 56) != 13)
  {
    uint64_t v15 = 0;
    for (uint64_t i = "expected value-as-metadata operand"; ; uint64_t i = "expected value-as-metadata operand")
    {
      __int16 v14 = 259;
      if (llvm::LLParser::parseValueAsMetadata(this, &v15, (const llvm::Twine *)&i, a4)) {
        break;
      }
      uint64_t v11 = v15;
      if (v17 >= (unint64_t)HIDWORD(v17)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (*(unsigned __int8 *)v15 - 1 >= 2) {
        uint64_t v11 = 0;
      }
      *((void *)v16 + v17) = v11;
      LODWORD(v17) = v17 + 1;
      if (*((_DWORD *)this + 56) != 4) {
        goto LABEL_5;
      }
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v8);
      uint64_t v15 = 0;
    }
    goto LABEL_6;
  }
LABEL_5:
  if (llvm::LLParser::parseToken((uint64_t)this, 13, "expected ')' here"))
  {
LABEL_6:
    uint64_t v9 = 1;
    goto LABEL_7;
  }
  uint64_t Impl = llvm::DIArgList::getImpl(*(void **)this, v16, (const void *)v17, a3, 1);
  uint64_t v9 = 0;
  *a2 = Impl;
LABEL_7:
  if (v16 != v18) {
    free(v16);
  }
  return v9;
}

uint64_t llvm::LLParser::parseValueAsMetadata(llvm::LLParser *this, llvm::Metadata **a2, const llvm::Twine *a3, llvm::LLParser::PerFunctionState *a4)
{
  int v13 = 0;
  int v7 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseType(this, &v13, a3, 0)) {
    return 1;
  }
  if (*((unsigned char *)v13 + 8) == 9)
  {
    v11[0] = (llvm::ValueAsMetadata *)"invalid metadata-value-metadata roundtrip";
    __int16 v12 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v7, (llvm::Twine *)v11);
  }
  else
  {
    v11[0] = 0;
    uint64_t v8 = llvm::LLParser::parseValue((llvm::ConstantInt **)this, v13, v11, a4);
    if ((v8 & 1) == 0) {
      *a2 = (llvm::Metadata *)llvm::ValueAsMetadata::get(v11[0], v10);
    }
  }
  return v8;
}

uint64_t llvm::LLParser::parseValue(llvm::ConstantInt **this, llvm::Type *a2, llvm::Value **a3, llvm::LLParser::PerFunctionState *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v8 = 1;
  int v17 = 1;
  char v18 = 0;
  sub_1CB892E1C((uint64_t)v19, 0.0);
  uint64_t v19[5] = 0;
  char v20 = 0;
  if ((llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v10, a4, a2) & 1) == 0) {
    uint64_t v8 = llvm::LLParser::convertValIDToValue(this, (uint64_t)a2, &v10, a3, (uint64_t)a4);
  }
  sub_1CD4F271C((uint64_t)&v10);
  return v8;
}

uint64_t llvm::LLParser::parseTypeAndValue(llvm::ConstantInt **this, llvm::Value **a2, llvm::LLParser::PerFunctionState *a3)
{
  int v7 = 0;
  uint64_t v8 = "expected type";
  __int16 v9 = 259;
  if (llvm::LLParser::parseType((llvm::LLParser *)this, &v7, (const llvm::Twine *)&v8, 0)) {
    return 1;
  }
  else {
    return llvm::LLParser::parseValue(this, v7, a2, a3);
  }
}

uint64_t llvm::LLParser::parseTypeAndBasicBlock(uint64_t a1, llvm::Value **a2, char **a3, llvm::LLParser::PerFunctionState *a4)
{
  uint64_t v11 = 0;
  *a3 = *(char **)(a1 + 216);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)a1, &v11, a4)) {
    return 1;
  }
  if (*((unsigned char *)v11 + 16) == 22)
  {
    uint64_t result = 0;
    *a2 = v11;
  }
  else
  {
    uint64_t v8 = *a3;
    __int16 v9 = "expected a basic block";
    __int16 v10 = 259;
    return llvm::LLLexer::Error(a1 + 168, v8, (llvm::Twine *)&v9);
  }
  return result;
}

uint64_t llvm::LLParser::PerFunctionState::resolveForwardRefBlockAddresses(llvm::LLParser::PerFunctionState *this)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  int v26 = 0;
  uint64_t v27 = 0;
  memset(__p, 0, sizeof(__p));
  long long v30 = 0u;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  int v33 = 1;
  char v34 = 0;
  sub_1CB892E1C((uint64_t)v35, 0.0);
  v35[5] = 0;
  char v36 = 0;
  int v2 = *((_DWORD *)this + 22);
  if (v2 == -1)
  {
    int v26 = 3;
    Name = llvm::Value::getName(*((llvm::Value **)this + 1));
    std::string::__init(&v24, Name, v4);
    if (SHIBYTE(__p[3]) < 0) {
      operator delete(__p[1]);
    }
    *(std::string *)&__p[1] = v24;
  }
  else
  {
    int v26 = 1;
    int v28 = v2;
  }
  uint64_t v5 = sub_1CD4F4DB4(*(void *)this + 1080, &v26);
  uint64_t v6 = *(void *)this;
  if (*(void *)this + 1088 == v5) {
    goto LABEL_7;
  }
  uint64_t v9 = v5;
  __int16 v10 = *(void **)(v5 + 184);
  uint64_t v11 = (void *)(v5 + 192);
  if (v10 == (void *)(v5 + 192))
  {
LABEL_10:
    sub_1CD4F4E34((uint64_t **)(v6 + 1080), v9);
LABEL_7:
    uint64_t v7 = 0;
    goto LABEL_8;
  }
  while (1)
  {
    long long v12 = (llvm::Type **)v10[23];
    if (*((_DWORD *)v10 + 8) == 2) {
      BB = llvm::LLParser::PerFunctionState::getBB((uint64_t)this, v10 + 8, (char *)v10[5]);
    }
    else {
      BB = llvm::LLParser::PerFunctionState::getBB((uint64_t)this, *((_DWORD *)v10 + 12), (char *)v10[5]);
    }
    if (!BB)
    {
      uint64_t v22 = *(void *)this;
      uint64_t v23 = (char *)v10[5];
      v24.__r_.__value_.__r.__words[0] = (std::string::size_type)"referenced value is not a basic block";
      __int16 v25 = 259;
      uint64_t v7 = llvm::LLLexer::Error(v22 + 168, v23, (llvm::Twine *)&v24);
      goto LABEL_8;
    }
    uint64_t v15 = (llvm::Type **)llvm::BlockAddress::get(*((llvm::BlockAddress **)this + 1), (llvm::Function *)BB, v14);
    uint64_t v16 = *(void *)this;
    int v17 = (char *)v10[5];
    __int16 v25 = 260;
    v24.__r_.__value_.__r.__words[0] = (std::string::size_type)(v10 + 8);
    char v18 = llvm::LLParser::checkValidVariableType(v16, v17, (uint64_t *)&v24, *v12, v15);
    if (!v18) {
      break;
    }
    llvm::Value::doRAUW((llvm::ValueAsMetadata *)v12, (llvm::Value *)v18, (llvm::Value *)1);
    llvm::GlobalValue::eraseFromParent((llvm::GlobalValue *)v12);
    uint64_t v19 = (void *)v10[1];
    if (v19)
    {
      do
      {
        char v20 = v19;
        uint64_t v19 = (void *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        char v20 = (void *)v10[2];
        BOOL v21 = *v20 == (void)v10;
        __int16 v10 = v20;
      }
      while (!v21);
    }
    __int16 v10 = v20;
    if (v20 == v11)
    {
      uint64_t v6 = *(void *)this;
      goto LABEL_10;
    }
  }
  uint64_t v7 = 1;
LABEL_8:
  sub_1CD4F271C((uint64_t)&v26);
  return v7;
}

uint64_t llvm::LLParser::parseBasicBlock(llvm::LLParser *this, llvm::LLParser::PerFunctionState *a2)
{
  memset(&v15, 0, sizeof(v15));
  std::string::size_type v4 = (llvm::LLParser *)((char *)this + 168);
  uint64_t v5 = (char *)*((void *)this + 27);
  int v6 = *((_DWORD *)this + 56);
  if (v6 == 432)
  {
    int v8 = *((_DWORD *)this + 64);
    int v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    goto LABEL_5;
  }
  if (v6 == 437)
  {
    std::string::operator=(&v15, (const std::string *)((char *)this + 232));
    int v7 = llvm::LLLexer::LexToken(v4);
    int v8 = -1;
LABEL_5:
    *((_DWORD *)this + 56) = v7;
    goto LABEL_6;
  }
  int v8 = -1;
LABEL_6:
  if (!llvm::LLParser::PerFunctionState::defineBB((uint64_t)a2, (uint64_t)&v15, v8, v5)) {
    goto LABEL_20;
  }
  memset(&v14, 0, sizeof(v14));
  long long v13 = 0;
  MEMORY[0x1D25D9630](&v14, "");
  int v10 = *((_DWORD *)this + 56);
  if (v10 == 440)
  {
    std::string::operator=(&v14, (const std::string *)((char *)this + 232));
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v4);
    if (llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after instruction name")) {
      goto LABEL_18;
    }
LABEL_9:
    int v11 = llvm::LLParser::parseInstruction(this, &v13, v9, a2);
    if (!v11) {
      llvm::SymbolTableListTraits<llvm::Instruction>::addNodeToList();
    }
    if (v11 == 2) {
      llvm::SymbolTableListTraits<llvm::Instruction>::addNodeToList();
    }
    goto LABEL_18;
  }
  if (v10 != 434) {
    goto LABEL_9;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v4);
  if ((llvm::LLParser::parseToken((uint64_t)this, 3, "expected '=' after instruction id") & 1) == 0) {
    goto LABEL_9;
  }
LABEL_18:
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
LABEL_20:
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v15.__r_.__value_.__l.__data_);
  }
  return 1;
}

uint64_t llvm::LLParser::parseRet(llvm::LLParser *this, llvm::Instruction **a2, llvm::BasicBlock *a3, llvm::LLParser::PerFunctionState *a4)
{
  int v7 = (char *)*((void *)this + 27);
  int v26 = 0;
  v27[0] = "expected type";
  __int16 v28 = 259;
  uint64_t v8 = 1;
  if ((llvm::LLParser::parseType(this, &v26, (const llvm::Twine *)v27, 1) & 1) == 0)
  {
    int v10 = **(llvm::Type ***)(*(void *)(*((void *)a4 + 1) + 24) + 16);
    if (*((unsigned char *)v26 + 8) == 7)
    {
      if (*((unsigned char *)v10 + 8) == 7)
      {
        int v11 = *(llvm::LLVMContext **)this;
        long long v12 = (llvm::ReturnInst *)operator new(0x40uLL);
        *((_DWORD *)v12 + 5) &= 0x38000000u;
        uint64_t v8 = 0;
        *a2 = (llvm::Instruction *)llvm::ReturnInst::ReturnInst(v12, v11, 0, 0);
        return v8;
      }
    }
    else
    {
      BOOL v21 = 0;
      if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, v26, &v21, a4)) {
        return 1;
      }
      long long v13 = v21;
      if (v10 == *(llvm::Type **)v21)
      {
        std::string v14 = *(llvm::LLVMContext **)this;
        std::string v15 = operator new(0x60uLL);
        v15[13] = v15[13] & 0x38000000 | 1;
        uint64_t v16 = (llvm::Instruction *)(v15 + 8);
        *(void *)std::string v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = 0;
        *((void *)v15 + 3) = v15 + 8;
        llvm::ReturnInst::ReturnInst((llvm::ReturnInst *)(v15 + 8), v14, v13, 0);
        uint64_t v8 = 0;
        *a2 = v16;
        return v8;
      }
    }
    sub_1CC196EB4((uint64_t)&v22, v10);
    int v17 = std::string::insert(&v22, 0, "value doesn't match function result type '");
    std::string::size_type v18 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    uint64_t v19 = std::string::append(&v23, "'");
    std::string::size_type v20 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    std::string::size_type v25 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    __int16 v28 = 260;
    v27[0] = __p;
    uint64_t v8 = llvm::LLLexer::Error((uint64_t)this + 168, v7, (llvm::Twine *)v27);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v23.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
  }
  return v8;
}

uint64_t llvm::LLParser::parseSwitch(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v33 = 0;
  char v34 = 0;
  int v6 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v33, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after switch condition")) {
    return 1;
  }
  uint64_t v32 = 0;
  if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v32, &v34, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' with switch table") & 1) != 0)
  {
    return 1;
  }
  uint64_t v9 = v33;
  if (*(unsigned char *)(*(void *)v33 + 8) == 13)
  {
    uint64_t v27 = v31;
    __int16 v28 = v31;
    uint64_t v29 = 32;
    int v30 = 0;
    uint64_t v35 = v37;
    uint64_t v36 = 0x2000000000;
    if (*((_DWORD *)this + 56) == 7)
    {
LABEL_9:
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      int v10 = v32;
      unsigned int v11 = v36;
      long long v12 = operator new(0x48uLL);
      long long v13 = (llvm::Instruction *)(v12 + 2);
      v12[7] = v12[7] & 0x38000000 | 0x40000000;
      *(void *)long long v12 = 0;
      llvm::SwitchInst::SwitchInst((llvm::SwitchInst *)(v12 + 2), v9, v10, v11, 0);
      if (v36)
      {
        uint64_t v14 = 0;
        uint64_t v15 = 16 * v36;
        do
        {
          llvm::SwitchInst::addCase(v13, *(llvm::ConstantInt **)((char *)v35 + v14), *(llvm::BasicBlock **)((char *)v35 + v14 + 8));
          v14 += 16;
        }
        while (v15 != v14);
      }
      uint64_t v7 = 0;
      *a2 = v13;
    }
    else
    {
      while (1)
      {
        std::string::size_type v25 = 0;
        int v26 = 0;
        uint64_t v16 = (char *)*((void *)this + 27);
        if ((llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v26, a3) & 1) != 0
          || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after case value") & 1) != 0
          || (v23[0] = 0, (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v25, v23, a3) & 1) != 0))
        {
          uint64_t v7 = 1;
          goto LABEL_13;
        }
        int v17 = v26;
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v27, (uint64_t)v26);
        if (!v18)
        {
          BOOL v21 = (char *)this + 168;
          std::string v22 = "duplicate case value in switch";
          goto LABEL_29;
        }
        if (*((unsigned char *)v17 + 16) != 16) {
          break;
        }
        uint64_t v19 = v25;
        if (v36 >= (unint64_t)HIDWORD(v36)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        std::string::size_type v20 = (llvm::Value **)((char *)v35 + 16 * v36);
        *std::string::size_type v20 = v17;
        v20[1] = v19;
        LODWORD(v36) = v36 + 1;
        if (*((_DWORD *)this + 56) == 7) {
          goto LABEL_9;
        }
      }
      BOOL v21 = (char *)this + 168;
      std::string v22 = "case value is not a constant integer";
LABEL_29:
      v23[0] = v22;
      __int16 v24 = 259;
      uint64_t v7 = llvm::LLLexer::Error((uint64_t)v21, v16, (llvm::Twine *)v23);
    }
LABEL_13:
    if (v35 != v37) {
      free(v35);
    }
    if (v28 != v27) {
      free(v28);
    }
  }
  else
  {
    uint64_t v35 = "switch condition must have integer type";
    v37[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)&v35);
  }
  return v7;
}

uint64_t llvm::LLParser::parseIndirectBr(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v16 = 0;
  int v6 = (char *)*((void *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v16, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after indirectbr address") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' with indirectbr") & 1) != 0)
  {
    return 1;
  }
  if (*(unsigned char *)(*(void *)v16 + 8) != 15)
  {
    char v18 = "indirectbr address must have pointer type";
    v20[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)&v18);
  }
  uint64_t v14 = v16;
  char v18 = v20;
  uint64_t v19 = 0x1000000000;
  if (*((_DWORD *)this + 56) != 7)
  {
    uint64_t v15 = 0;
    int v17 = 0;
    if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v15, &v17, a3)) {
      goto LABEL_9;
    }
    if (v19 >= HIDWORD(v19)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    for (*((void *)v18 + v19) = v15; ; *((void *)v18 + v19) = v15)
    {
      LODWORD(v19) = v19 + 1;
      if (*((_DWORD *)this + 56) != 4) {
        break;
      }
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
      int v17 = 0;
      if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v15, &v17, a3)) {
        goto LABEL_9;
      }
      if (v19 >= (unint64_t)HIDWORD(v19)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
    }
  }
  if ((llvm::LLParser::parseToken((uint64_t)this, 7, "expected ']' at end of block list") & 1) == 0)
  {
    unsigned int v9 = v19;
    int v10 = operator new(0x48uLL);
    unsigned int v11 = (llvm::IndirectBrInst *)(v10 + 2);
    _OWORD v10[7] = v10[7] & 0x38000000 | 0x40000000;
    *(void *)int v10 = 0;
    llvm::IndirectBrInst::IndirectBrInst((llvm::IndirectBrInst *)(v10 + 2), v14, v9, 0);
    if (v19)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8 * v19;
      do
      {
        llvm::IndirectBrInst::addDestination(v11, *(llvm::BasicBlock **)((char *)v18 + v12));
        v12 += 8;
      }
      while (v13 != v12);
    }
    uint64_t v7 = 0;
    *a2 = v11;
    goto LABEL_10;
  }
LABEL_9:
  uint64_t v7 = 1;
LABEL_10:
  if (v18 != v20) {
    free(v18);
  }
  return v7;
}

uint64_t llvm::LLParser::parseInvoke(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  v99[8] = *MEMORY[0x1E4F143B8];
  int v6 = (char *)*((void *)this + 27);
  uint64_t v96 = (uint64_t *)**((void **)this + 41);
  uint64_t v97 = v99;
  uint64_t v98 = 0x800000000;
  char v92 = v96;
  uint64_t v93 = v95;
  uint64_t v94 = 0x800000000;
  long long __p = 0;
  uint64_t v66 = 0;
  uint64_t v67 = 0;
  uint64_t v63 = 0;
  __int16 v64 = 0;
  char v62 = 0;
  int v81 = 0;
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  uint64_t v87 = 0;
  uint64_t v82 = 0;
  uint64_t v86 = 0;
  char v7 = 1;
  int v88 = 1;
  char v89 = 0;
  sub_1CB892E1C((uint64_t)v90, 0.0);
  v90[5] = 0;
  char v91 = 0;
  __int16 v78 = v80;
  uint64_t v79 = 0x1000000000;
  __int16 v75 = v77;
  uint64_t v76 = 0x200000000;
  __int16 v60 = 0;
  uint64_t v61 = 0;
  if ((llvm::LLParser::parseOptionalCallingConv(this, (unsigned int *)&v63 + 1) & 1) == 0
    && (llvm::LLParser::parseOptionalParamOrReturnAttrs(this, (llvm::AttrBuilder *)&v96, 0) & 1) == 0
    && (llvm::LLParser::parseOptionalAddrSpace(this, (unsigned int *)&v63, *(_DWORD *)(*((void *)this + 41) + 284)) & 1) == 0)
  {
    uint64_t v8 = (char *)*((void *)this + 27);
    char v71 = "expected type";
    __int16 v74 = 259;
    if ((llvm::LLParser::parseType(this, &v62, (const llvm::Twine *)&v71, 1) & 1) == 0
      && (llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v81, a3, 0) & 1) == 0
      && (llvm::LLParser::parseParameterList((uint64_t)this, (uint64_t)&v78, a3, 0, 0) & 1) == 0
      && (llvm::LLParser::parseFnAttributeValuePairs((uint64_t)this, (uint64_t)&v92, (char **)&__p, 0, &v64) & 1) == 0
      && (llvm::LLParser::parseOptionalOperandBundles((uint64_t)this, (uint64_t)&v75, a3) & 1) == 0
      && (llvm::LLParser::parseToken((uint64_t)this, 55, "expected 'to' in invoke") & 1) == 0)
    {
      char v71 = 0;
      if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v61, (char **)&v71, a3) & 1) == 0
        && (llvm::LLParser::parseToken((uint64_t)this, 65, "expected 'unwind' in invoke") & 1) == 0)
      {
        char v71 = 0;
        if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v60, (char **)&v71, a3) & 1) == 0)
        {
          char v49 = (char *)this + 168;
          uint64_t v14 = v62;
          if (v62)
          {
            if (*((unsigned char *)v62 + 8) == 14) {
              goto LABEL_30;
            }
          }
          __int16 v50 = v62;
          __src = 0;
          size_t __n = 0;
          v70[0] = 0;
          if (v79)
          {
            uint64_t v17 = 0;
            char v18 = 0;
            uint64_t v19 = 24 * v79;
            __int16 v52 = v8;
            do
            {
              std::string::size_type v20 = **(void ***)((char *)v78 + v17 + 8);
              char v71 = v20;
              if ((unint64_t)v18 >= v70[0])
              {
                uint64_t v21 = v19;
                char v18 = sub_1CBC13470(&__src, &v71);
                uint64_t v19 = v21;
                uint64_t v8 = v52;
              }
              else
              {
                *v18++ = v20;
              }
              size_t __n = (size_t)v18;
              v17 += 24;
            }
            while (v19 != v17);
          }
          char v7 = (char)v50;
          isValidReturnuint64_t Type = llvm::FunctionType::isValidReturnType(v50, v9);
          if (isValidReturnType)
          {
            char v51 = (llvm::FunctionType *)llvm::FunctionType::get((uint64_t **)v50, (uint64_t)__src, (uint64_t)(__n - (void)__src) >> 3, 0);
          }
          else
          {
            char v71 = "Invalid result type for LLVM function";
            __int16 v74 = 259;
            char v7 = llvm::LLLexer::Error((uint64_t)v49, v8, (llvm::Twine *)&v71);
            char v51 = 0;
          }
          if (__src)
          {
            size_t __n = (size_t)__src;
            operator delete(__src);
          }
          uint64_t v14 = v51;
          if (isValidReturnType)
          {
LABEL_30:
            *(void *)&long long v83 = v14;
            uint64_t v59 = 0;
            uint64_t v15 = v14;
            unint64_t v16 = llvm::PointerType::get(v14, (llvm::Type *)v63);
            if (llvm::LLParser::convertValIDToValue((llvm::ConstantInt **)this, v16, &v81, &v59, (uint64_t)a3))
            {
              char v7 = 1;
            }
            else
            {
              char v71 = v73;
              uint64_t v72 = 0x800000000;
              __src = v70;
              size_t __n = 0x800000000;
              uint64_t v22 = *((void *)v15 + 2);
              std::string v23 = (llvm::Type **)(v22 + 8);
              __int16 v24 = (llvm::Type **)(v22 + 8 * *((unsigned int *)v15 + 3));
              uint64_t v25 = (uint64_t)v15;
              if (v79)
              {
                uint64_t v29 = 0;
                uint64_t v30 = 24 * v79;
                do
                {
                  if (v23 == v24)
                  {
                    int v33 = (char *)v78;
                    if (*(_DWORD *)(v25 + 8) <= 0xFFu)
                    {
                      uint64_t v35 = *(char **)((char *)v78 + v29);
                      v57[0] = (uint64_t *)"too many arguments specified";
                      __int16 v58 = 259;
                      char v34 = (char *)this + 168;
                      goto LABEL_61;
                    }
                    std::string v23 = v24;
                  }
                  else
                  {
                    uint64_t v32 = *v23++;
                    uint64_t v31 = v32;
                    int v33 = (char *)v78;
                    if (v32 && v31 != **(llvm::Type ***)((char *)v78 + v29 + 8))
                    {
                      long long v43 = *(char **)((char *)v78 + v29);
                      sub_1CC196EB4((uint64_t)&v53, v31);
                      long long v44 = std::string::insert(&v53, 0, "argument is not of expected type '");
                      std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
                      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
                      v54.__r_.__value_.__r.__words[2] = v45;
                      v44->__r_.__value_.__l.__size_ = 0;
                      v44->__r_.__value_.__r.__words[2] = 0;
                      v44->__r_.__value_.__r.__words[0] = 0;
                      int v46 = std::string::append(&v54, "'");
                      std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
                      *(_OWORD *)uint64_t v55 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
                      std::string::size_type v56 = v47;
                      v46->__r_.__value_.__l.__size_ = 0;
                      v46->__r_.__value_.__r.__words[2] = 0;
                      v46->__r_.__value_.__r.__words[0] = 0;
                      __int16 v58 = 260;
                      v57[0] = (uint64_t *)v55;
                      char v7 = llvm::LLLexer::Error((uint64_t)v49, v43, (llvm::Twine *)v57);
                      if (SHIBYTE(v56) < 0) {
                        operator delete(v55[0]);
                      }
                      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v54.__r_.__value_.__l.__data_);
                      }
                      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
                        operator delete(v53.__r_.__value_.__l.__data_);
                      }
                      goto LABEL_62;
                    }
                  }
                  if (v72 >= (unint64_t)HIDWORD(v72)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v71 + v72) = *(void *)&v33[v29 + 8];
                  LODWORD(v72) = v72 + 1;
                  if (__n >= (unint64_t)HIDWORD(__n)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)__src + __n) = *(void *)((char *)v78 + v29 + 16);
                  LODWORD(__n) = __n + 1;
                  v29 += 24;
                }
                while (v30 != v29);
              }
              if (v23 == v24)
              {
                uint64_t v26 = v25;
                if (!llvm::AttrBuilder::hasAlignmentAttr((llvm::AttrBuilder *)&v92))
                {
                  uint64_t v36 = *(uint64_t **)this;
                  uint64_t v37 = llvm::AttributeSet::get(*(llvm::AttributeSet **)this, &v92, v27);
                  uint64_t v39 = llvm::AttributeSet::get(*(llvm::AttributeSet **)this, &v96, v38);
                  uint64_t v40 = llvm::AttributeList::get(v36, v37, v39, __src, __n);
                  __int16 v58 = 257;
                  uint64_t v41 = sub_1CD4EF89C(v26, v59, (uint64_t)v61, (uint64_t)v60, (uint64_t *)v71, v72, (uint64_t)v75, v76, (const char **)v57, 0);
                  *((_WORD *)v41 + 9) = *((_WORD *)v41 + 9) & 0xF003 | (4 * WORD2(v63));
                  *((void *)v41 + 8) = v40;
                  v57[0] = (uint64_t *)v41;
                  char v42 = sub_1CD4F40F4((uint64_t **)this + 139, (unint64_t)v41, v57);
                  sub_1CC19E0C8(v42 + 5, (char *)__p, v66, (v66 - (unsigned char *)__p) >> 2);
                  char v7 = 0;
                  *a2 = (llvm::Instruction *)v41;
                  goto LABEL_62;
                }
                __int16 v28 = "invoke instructions may not have an alignment";
              }
              else
              {
                __int16 v28 = "not enough parameters specified for call";
              }
              v57[0] = (uint64_t *)v28;
              __int16 v58 = 259;
              char v34 = (char *)this + 168;
              uint64_t v35 = v6;
LABEL_61:
              char v7 = llvm::LLLexer::Error((uint64_t)v34, v35, (llvm::Twine *)v57);
LABEL_62:
              if (__src != v70) {
                free(__src);
              }
              if (v71 != v73) {
                free(v71);
              }
            }
          }
        }
      }
    }
  }
  int v10 = v75;
  if (v76)
  {
    uint64_t v11 = 48 * v76;
    uint64_t v12 = (char *)v75 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v12[v11]);
      v11 -= 48;
    }
    while (v11);
    int v10 = v75;
  }
  if (v10 != v77) {
    free(v10);
  }
  if (v78 != v80) {
    free(v78);
  }
  sub_1CD4F271C((uint64_t)&v81);
  if (__p) {
    operator delete(__p);
  }
  if (v93 != v95) {
    free(v93);
  }
  if (v97 != v99) {
    free(v97);
  }
  return v7 & 1;
}

uint64_t llvm::LLParser::parseResume(llvm::ConstantInt **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  unsigned int v9 = 0;
  uint64_t v4 = llvm::LLParser::parseTypeAndValue(this, &v9, a3);
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = v9;
    int v6 = operator new(0x60uLL);
    v6[13] = v6[13] & 0x38000000 | 1;
    char v7 = (llvm::Instruction *)(v6 + 8);
    *(void *)int v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = 0;
    *((void *)v6 + 3) = v6 + 8;
    llvm::ResumeInst::ResumeInst((llvm::ResumeInst *)(v6 + 8), v5, 0);
    *a2 = v7;
  }
  return v4;
}

uint64_t llvm::LLParser::parseCleanupRet(llvm::Type **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v14 = 0;
  if (llvm::LLParser::parseToken((uint64_t)this, 58, "expected 'from' after cleanupret")) {
    return 1;
  }
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*this, v6);
  if ((llvm::LLParser::parseValue(this, TokenTy, &v14, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 65, "expected 'unwind' in cleanupret") & 1) != 0)
  {
    return 1;
  }
  uint64_t v13 = 0;
  if (*((_DWORD *)this + 56) != 55)
  {
    uint64_t v15 = 0;
    if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v13, &v15, a3) & 1) == 0)
    {
      unsigned int v9 = v13;
      goto LABEL_11;
    }
    return 1;
  }
  *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLLexer *)(this + 21));
  if (llvm::LLParser::parseToken((uint64_t)this, 56, "expected 'caller' in cleanupret")) {
    return 1;
  }
  unsigned int v9 = 0;
LABEL_11:
  int v10 = v14;
  if (v9) {
    unsigned int v11 = 2;
  }
  else {
    unsigned int v11 = 1;
  }
  uint64_t v12 = (llvm::CleanupReturnInst *)llvm::User::operator new((llvm::User *)0x40, v11);
  llvm::CleanupReturnInst::CleanupReturnInst(v12, v10, v9, v11, 0);
  uint64_t result = 0;
  *a2 = v12;
  return result;
}

uint64_t llvm::LLParser::parseCatchRet(llvm::Type **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v14 = 0;
  if (llvm::LLParser::parseToken((uint64_t)this, 58, "expected 'from' after catchret")) {
    return 1;
  }
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*this, v6);
  if (llvm::LLParser::parseValue(this, TokenTy, &v14, a3)) {
    return 1;
  }
  uint64_t v13 = 0;
  if (llvm::LLParser::parseToken((uint64_t)this, 55, "expected 'to' in catchret")) {
    return 1;
  }
  uint64_t v15 = 0;
  if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v13, &v15, a3)) {
    return 1;
  }
  int v10 = v13;
  unsigned int v9 = v14;
  unsigned int v11 = operator new(0x80uLL);
  unsigned char v11[21] = v11[21] & 0x38000000 | 2;
  uint64_t v12 = (llvm::Instruction *)(v11 + 16);
  *(void *)unsigned int v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *((void *)v11 + 3) = v11 + 16;
  *((void *)v11 + 4) = 0;
  *((void *)v11 + 5) = 0;
  *((void *)v11 + 6) = 0;
  *((void *)v11 + 7) = v11 + 16;
  llvm::CatchReturnInst::CatchReturnInst((llvm::CatchReturnInst *)(v11 + 16), v9, v10, 0);
  uint64_t result = 0;
  *a2 = v12;
  return result;
}

uint64_t llvm::LLParser::parseCatchSwitch(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (llvm::LLParser::parseToken((uint64_t)this, 57, "expected 'within' after catchswitch")) {
    return 1;
  }
  int v9 = *((_DWORD *)this + 56);
  if (v9 != 54 && v9 != 434 && v9 != 440)
  {
    std::string v23 = "expected scope value for catchswitch";
    v25[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v23);
  }
  uint64_t v22 = 0;
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*(llvm::Type **)this, v6);
  if ((llvm::LLParser::parseValue((llvm::ConstantInt **)this, TokenTy, &v22, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' with catchswitch labels") & 1) != 0)
  {
    return 1;
  }
  std::string v23 = v25;
  uint64_t v24 = 0x2000000000;
  while (1)
  {
    uint64_t v21 = 0;
    v19[0] = 0;
    if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v21, v19, a3)) {
      goto LABEL_16;
    }
    if (v24 >= (unint64_t)HIDWORD(v24)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v23 + v24) = v21;
    LODWORD(v24) = v24 + 1;
    if (*((_DWORD *)this + 56) != 4) {
      break;
    }
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  }
  if ((llvm::LLParser::parseToken((uint64_t)this, 7, "expected ']' after catchswitch labels") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 65, "expected 'unwind' after catchswitch scope") & 1) != 0)
  {
    goto LABEL_16;
  }
  uint64_t v21 = 0;
  if (*((_DWORD *)this + 56) == 55)
  {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    if ((llvm::LLParser::parseToken((uint64_t)this, 56, "expected 'caller' in catchswitch") & 1) == 0)
    {
      unsigned int v11 = 0;
      goto LABEL_26;
    }
LABEL_16:
    uint64_t v7 = 1;
    goto LABEL_17;
  }
  v19[0] = 0;
  if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v21, v19, a3)) {
    goto LABEL_16;
  }
  unsigned int v11 = v21;
LABEL_26:
  uint64_t v12 = v22;
  unsigned int v13 = v24;
  __int16 v20 = 257;
  uint64_t v14 = operator new(0x48uLL);
  uint64_t v15 = (llvm::CatchSwitchInst *)(v14 + 2);
  _OWORD v14[7] = v14[7] & 0x38000000 | 0x40000000;
  *(void *)uint64_t v14 = 0;
  llvm::CatchSwitchInst::CatchSwitchInst((llvm::CatchSwitchInst *)(v14 + 2), v12, v11, v13, (const llvm::Twine *)v19, 0);
  if (v24)
  {
    unint64_t v16 = (llvm::BasicBlock **)v23;
    uint64_t v17 = 8 * v24;
    do
    {
      char v18 = *v16++;
      llvm::CatchSwitchInst::addHandler(v15, v18);
      v17 -= 8;
    }
    while (v17);
  }
  uint64_t v7 = 0;
  *a2 = v15;
LABEL_17:
  if (v23 != v25) {
    free(v23);
  }
  return v7;
}

uint64_t llvm::LLParser::parseCatchPad(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  char v18 = 0;
  if (llvm::LLParser::parseToken((uint64_t)this, 57, "expected 'within' after catchpad")) {
    return 1;
  }
  int v9 = *((_DWORD *)this + 56);
  if (v9 != 434 && v9 != 440)
  {
    uint64_t v19 = "expected scope value for catchpad";
    v21[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v19);
  }
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*(llvm::Type **)this, v6);
  if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, TokenTy, &v18, a3)) {
    return 1;
  }
  uint64_t v19 = v21;
  uint64_t v20 = 0x800000000;
  uint64_t v7 = llvm::LLParser::parseExceptionArgs(this, (uint64_t)&v19, a3);
  if ((v7 & 1) == 0)
  {
    unsigned int v11 = (llvm::Type **)v18;
    uint64_t v12 = (uint64_t *)v19;
    uint64_t v13 = v20;
    unsigned int v14 = v20 + 1;
    __int16 v17 = 257;
    uint64_t v15 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, (int)v20 + 1);
    *a2 = llvm::FuncletPadInst::FuncletPadInst(v15, 52, v11, v12, v13, v14, &v16, 0);
  }
  if (v19 != v21) {
    free(v19);
  }
  return v7;
}

uint64_t llvm::LLParser::parseCleanupPad(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  char v18 = 0;
  if (llvm::LLParser::parseToken((uint64_t)this, 57, "expected 'within' after cleanuppad")) {
    return 1;
  }
  int v9 = *((_DWORD *)this + 56);
  if (v9 != 54 && v9 != 434 && v9 != 440)
  {
    uint64_t v19 = "expected scope value for cleanuppad";
    v21[8] = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v19);
  }
  TokenTy = (llvm::Type *)llvm::Type::getTokenTy(*(llvm::Type **)this, v6);
  if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, TokenTy, &v18, a3)) {
    return 1;
  }
  uint64_t v19 = v21;
  uint64_t v20 = 0x800000000;
  uint64_t v7 = llvm::LLParser::parseExceptionArgs(this, (uint64_t)&v19, a3);
  if ((v7 & 1) == 0)
  {
    unsigned int v11 = (llvm::Type **)v18;
    uint64_t v12 = (uint64_t *)v19;
    uint64_t v13 = v20;
    unsigned int v14 = v20 + 1;
    __int16 v17 = 257;
    uint64_t v15 = (llvm::Instruction *)llvm::User::operator new((llvm::User *)0x40, (int)v20 + 1);
    *a2 = llvm::FuncletPadInst::FuncletPadInst(v15, 51, v11, v12, v13, v14, &v16, 0);
  }
  if (v19 != v21) {
    free(v19);
  }
  return v7;
}

uint64_t llvm::LLParser::parseCallBr(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  v102[8] = *MEMORY[0x1E4F143B8];
  int v6 = (char *)*((void *)this + 27);
  uint64_t v99 = (uint64_t *)**((void **)this + 41);
  uint64_t v100 = v102;
  uint64_t v101 = 0x800000000;
  char v95 = v99;
  uint64_t v96 = v98;
  uint64_t v97 = 0x800000000;
  long long __p = 0;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  __int16 v65 = 0;
  unsigned int v64 = 0;
  uint64_t v63 = 0;
  int v84 = 0;
  long long v86 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  uint64_t v90 = 0;
  uint64_t v85 = 0;
  uint64_t v89 = 0;
  uint64_t v7 = 1;
  int v91 = 1;
  char v92 = 0;
  sub_1CB892E1C((uint64_t)v93, 0.0);
  v93[5] = 0;
  char v94 = 0;
  int v81 = v83;
  uint64_t v82 = 0x1000000000;
  __int16 v78 = v80;
  uint64_t v79 = 0x200000000;
  char v62 = 0;
  if (llvm::LLParser::parseOptionalCallingConv(this, &v64)) {
    goto LABEL_11;
  }
  if (llvm::LLParser::parseOptionalParamOrReturnAttrs(this, (llvm::AttrBuilder *)&v99, 0)) {
    goto LABEL_11;
  }
  uint64_t v8 = (char *)*((void *)this + 27);
  __int16 v75 = "expected type";
  v77[8] = 259;
  if (llvm::LLParser::parseType(this, &v63, (const llvm::Twine *)&v75, 1)) {
    goto LABEL_11;
  }
  if (llvm::LLParser::parseValID((uint64_t **)this, (uint64_t)&v84, a3, 0)) {
    goto LABEL_11;
  }
  if (llvm::LLParser::parseParameterList((uint64_t)this, (uint64_t)&v81, a3, 0, 0)) {
    goto LABEL_11;
  }
  if (llvm::LLParser::parseFnAttributeValuePairs((uint64_t)this, (uint64_t)&v95, (char **)&__p, 0, &v65)) {
    goto LABEL_11;
  }
  if (llvm::LLParser::parseOptionalOperandBundles((uint64_t)this, (uint64_t)&v78, a3)) {
    goto LABEL_11;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 55, "expected 'to' in callbr")) {
    goto LABEL_11;
  }
  __int16 v75 = 0;
  if ((llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, &v62, (char **)&v75, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' in callbr") & 1) != 0)
  {
    goto LABEL_11;
  }
  std::string v53 = (llvm::LLParser *)((char *)this + 168);
  __int16 v75 = v77;
  uint64_t v76 = 0x1000000000;
  if (*((_DWORD *)this + 56) != 7)
  {
    __src = 0;
    uint64_t v72 = 0;
    if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, (llvm::Value **)&__src, (char **)&v72, a3)) {
      goto LABEL_28;
    }
    if (v76 >= HIDWORD(v76)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    for (*((void *)v75 + v76) = __src; ; *((void *)v75 + v76) = __src)
    {
      LODWORD(v76) = v76 + 1;
      if (*((_DWORD *)this + 56) != 4) {
        break;
      }
      *((_DWORD *)this + 56) = llvm::LLLexer::LexToken(v53);
      uint64_t v72 = 0;
      if (llvm::LLParser::parseTypeAndBasicBlock((uint64_t)this, (llvm::Value **)&__src, (char **)&v72, a3)) {
        goto LABEL_28;
      }
      if (v76 >= (unint64_t)HIDWORD(v76)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
    }
  }
  if ((llvm::LLParser::parseToken((uint64_t)this, 7, "expected ']' at end of block list") & 1) == 0)
  {
    unsigned int v14 = v63;
    if (!v63 || *((unsigned char *)v63 + 8) != 14)
    {
      __int16 v52 = v63;
      __src = 0;
      size_t __n = 0;
      v71[0] = 0;
      if (v82)
      {
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        uint64_t v25 = 24 * v82;
        std::string v54 = v6;
        do
        {
          uint64_t v26 = **(void ***)((char *)v81 + v23 + 8);
          uint64_t v72 = v26;
          if ((unint64_t)v24 >= v71[0])
          {
            uint64_t v27 = a2;
            __int16 v28 = v8;
            uint64_t v29 = v25;
            uint64_t v24 = sub_1CBC13470(&__src, &v72);
            uint64_t v25 = v29;
            uint64_t v8 = v28;
            a2 = v27;
            int v6 = v54;
          }
          else
          {
            *v24++ = v26;
          }
          size_t __n = (size_t)v24;
          v23 += 24;
        }
        while (v25 != v23);
      }
      isValidReturnuint64_t Type = llvm::FunctionType::isValidReturnType(v52, v13);
      if (isValidReturnType)
      {
        uint64_t v30 = llvm::FunctionType::get((uint64_t **)v52, (uint64_t)__src, (uint64_t)(__n - (void)__src) >> 3, 0);
        uint64_t v7 = 1;
      }
      else
      {
        uint64_t v72 = "Invalid result type for LLVM function";
        v74[8] = 259;
        uint64_t v7 = llvm::LLLexer::Error((uint64_t)v53, v8, (llvm::Twine *)&v72);
        uint64_t v30 = 0;
      }
      if (__src)
      {
        size_t __n = (size_t)__src;
        operator delete(__src);
      }
      unsigned int v14 = (llvm::PointerType *)v30;
      if (!isValidReturnType) {
        goto LABEL_29;
      }
    }
    *(void *)&long long v86 = v14;
    uint64_t v61 = 0;
    uint64_t v15 = v14;
    unint64_t v16 = llvm::PointerType::get(v14, 0);
    if ((llvm::LLParser::convertValIDToValue((llvm::ConstantInt **)this, v16, &v84, &v61, (uint64_t)a3) & 1) == 0)
    {
      uint64_t v72 = v74;
      uint64_t v73 = 0x800000000;
      __src = v71;
      size_t __n = 0x800000000;
      uint64_t v17 = *((void *)v15 + 2);
      char v18 = (llvm::Type **)(v17 + 8);
      uint64_t v19 = (llvm::Type **)(v17 + 8 * *((unsigned int *)v15 + 3));
      if (v82)
      {
        uint64_t v31 = 0;
        uint64_t v32 = 24 * v82;
        do
        {
          if (v18 == v19)
          {
            uint64_t v35 = (char *)v81;
            if (*((_DWORD *)v15 + 2) <= 0xFFu)
            {
              uint64_t v37 = *(char **)((char *)v81 + v31);
              v59[0] = (uint64_t *)"too many arguments specified";
              __int16 v60 = 259;
              uint64_t v36 = (char *)this + 168;
              goto LABEL_70;
            }
            char v18 = v19;
          }
          else
          {
            char v34 = *v18++;
            int v33 = v34;
            uint64_t v35 = (char *)v81;
            if (v34 && v33 != **(llvm::Type ***)((char *)v81 + v31 + 8))
            {
              int v46 = *(char **)((char *)v81 + v31);
              sub_1CC196EB4((uint64_t)&v55, v33);
              std::string::size_type v47 = std::string::insert(&v55, 0, "argument is not of expected type '");
              std::string::size_type v48 = v47->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v56.__r_.__value_.__l.__data_ = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
              v56.__r_.__value_.__r.__words[2] = v48;
              v47->__r_.__value_.__l.__size_ = 0;
              v47->__r_.__value_.__r.__words[2] = 0;
              v47->__r_.__value_.__r.__words[0] = 0;
              char v49 = std::string::append(&v56, "'");
              std::string::size_type v50 = v49->__r_.__value_.__r.__words[2];
              *(_OWORD *)uint64_t v57 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
              std::string::size_type v58 = v50;
              v49->__r_.__value_.__l.__size_ = 0;
              v49->__r_.__value_.__r.__words[2] = 0;
              v49->__r_.__value_.__r.__words[0] = 0;
              __int16 v60 = 260;
              v59[0] = (uint64_t *)v57;
              uint64_t v7 = llvm::LLLexer::Error((uint64_t)v53, v46, (llvm::Twine *)v59);
              if (SHIBYTE(v58) < 0) {
                operator delete(v57[0]);
              }
              if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v56.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v55.__r_.__value_.__l.__data_);
              }
              goto LABEL_71;
            }
          }
          if (v73 >= (unint64_t)HIDWORD(v73)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v72 + v73) = *(void *)&v35[v31 + 8];
          LODWORD(v73) = v73 + 1;
          if (__n >= (unint64_t)HIDWORD(__n)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)__src + __n) = *(void *)((char *)v81 + v31 + 16);
          LODWORD(__n) = __n + 1;
          v31 += 24;
        }
        while (v32 != v31);
      }
      if (v18 == v19)
      {
        uint64_t v20 = (uint64_t)v15;
        if (!llvm::AttrBuilder::hasAlignmentAttr((llvm::AttrBuilder *)&v95))
        {
          uint64_t v38 = *(uint64_t **)this;
          uint64_t v39 = llvm::AttributeSet::get(*(llvm::AttributeSet **)this, &v95, v21);
          uint64_t v41 = llvm::AttributeSet::get(*(llvm::AttributeSet **)this, &v99, v40);
          uint64_t v42 = llvm::AttributeList::get(v38, v39, v41, __src, __n);
          __int16 v60 = 257;
          long long v44 = sub_1CD4EFB0C(v20, v61, (uint64_t)v62, (uint64_t)v75, v76, (uint64_t *)v72, v73, v43, (uint64_t)v78, v79, (const char **)v59, 0);
          *((_WORD *)v44 + 9) = *((_WORD *)v44 + 9) & 0xF003 | (4 * v64);
          *((void *)v44 + 8) = v42;
          v59[0] = (uint64_t *)v44;
          std::string::size_type v45 = sub_1CD4F40F4((uint64_t **)this + 139, (unint64_t)v44, v59);
          sub_1CC19E0C8(v45 + 5, (char *)__p, v67, (v67 - (unsigned char *)__p) >> 2);
          uint64_t v7 = 0;
          *a2 = (llvm::Instruction *)v44;
          goto LABEL_71;
        }
        uint64_t v22 = "callbr instructions may not have an alignment";
      }
      else
      {
        uint64_t v22 = "not enough parameters specified for call";
      }
      v59[0] = (uint64_t *)v22;
      __int16 v60 = 259;
      uint64_t v36 = (char *)this + 168;
      uint64_t v37 = v6;
LABEL_70:
      uint64_t v7 = llvm::LLLexer::Error((uint64_t)v36, v37, (llvm::Twine *)v59);
LABEL_71:
      if (__src != v71) {
        free(__src);
      }
      if (v72 != v74) {
        free(v72);
      }
      goto LABEL_29;
    }
  }
LABEL_28:
  uint64_t v7 = 1;
LABEL_29:
  if (v75 != v77) {
    free(v75);
  }
LABEL_11:
  int v9 = v78;
  if (v79)
  {
    uint64_t v10 = 48 * v79;
    unsigned int v11 = (char *)v78 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v11[v10]);
      v10 -= 48;
    }
    while (v10);
    int v9 = v78;
  }
  if (v9 != v80) {
    free(v9);
  }
  if (v81 != v83) {
    free(v81);
  }
  sub_1CD4F271C((uint64_t)&v84);
  if (__p) {
    operator delete(__p);
  }
  if (v96 != v98) {
    free(v96);
  }
  if (v100 != v102) {
    free(v100);
  }
  return v7;
}

uint64_t sub_1CD4ED1D4(uint64_t a1)
{
  uint64_t result = 0;
  int v3 = *(_DWORD *)(a1 + 224);
  while (1)
  {
    uint64_t v4 = 0xFFFFFFFFLL;
    switch(v3)
    {
      case 'M':
        uint64_t v4 = result | 2;
        break;
      case 'N':
        uint64_t v4 = result | 4;
        break;
      case 'O':
        uint64_t v4 = result | 8;
        break;
      case 'P':
        uint64_t v4 = result | 0x10;
        break;
      case 'Q':
        uint64_t v4 = result | 0x20;
        break;
      case 'R':
        uint64_t v4 = result | 1;
        break;
      case 'S':
        uint64_t v4 = result | 0x40;
        break;
      case 'T':
        break;
      default:
        return result;
    }
    int v3 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v3;
    uint64_t result = v4;
  }
}

uint64_t llvm::LLParser::parseUnaryOp(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, char a4, int a5)
{
  unint64_t v16 = 0;
  int v9 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v16, a3)) {
    return 1;
  }
  uint64_t v11 = *(void *)v16;
  unsigned int v12 = *(_DWORD *)(*(void *)v16 + 8);
  if (a5)
  {
    if ((*(_DWORD *)(*(void *)v16 + 8) & 0xFE) == 0x12) {
      unsigned int v12 = *(unsigned __int8 *)(**(void **)(v11 + 16) + 8);
    }
    if (v12 >= 7)
    {
LABEL_7:
      v14[0] = "invalid operand type for instruction";
      __int16 v15 = 259;
      return llvm::LLLexer::Error((uint64_t)this + 168, v9, (llvm::Twine *)v14);
    }
  }
  else
  {
    if ((*(_DWORD *)(*(void *)v16 + 8) & 0xFE) == 0x12) {
      unsigned int v12 = *(unsigned __int8 *)(**(void **)(v11 + 16) + 8);
    }
    if (v12 != 13) {
      goto LABEL_7;
    }
  }
  __int16 v15 = 257;
  uint64_t v13 = llvm::UnaryOperator::Create(a4, (uint64_t *)v16, v14, 0);
  uint64_t result = 0;
  *a2 = v13;
  return result;
}

uint64_t llvm::LLParser::parseArithmetic(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, char a4, int a5)
{
  uint64_t v19 = 0;
  uint64_t v10 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v19, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' in arithmetic operation")) {
    return 1;
  }
  char v18 = 0;
  unsigned int v12 = v19;
  if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, *(llvm::Type **)v19, &v18, a3)) {
    return 1;
  }
  uint64_t v13 = *(void *)v12;
  unsigned int v14 = *(_DWORD *)(*(void *)v12 + 8);
  if (a5)
  {
    if ((*(_DWORD *)(*(void *)v12 + 8) & 0xFE) == 0x12) {
      unsigned int v14 = *(unsigned __int8 *)(**(void **)(v13 + 16) + 8);
    }
    if (v14 >= 7)
    {
LABEL_9:
      v16[0] = "invalid operand type for instruction";
      __int16 v17 = 259;
      return llvm::LLLexer::Error((uint64_t)this + 168, v10, (llvm::Twine *)v16);
    }
  }
  else
  {
    if ((*(_DWORD *)(*(void *)v12 + 8) & 0xFE) == 0x12) {
      unsigned int v14 = *(unsigned __int8 *)(**(void **)(v13 + 16) + 8);
    }
    if (v14 != 13) {
      goto LABEL_9;
    }
  }
  __int16 v17 = 257;
  __int16 v15 = llvm::BinaryOperator::Create(a4, v12, (uint64_t)v18, v16, 0);
  uint64_t result = 0;
  *a2 = v15;
  return result;
}

uint64_t llvm::LLParser::parseLogical(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, char a4)
{
  unint64_t v16 = 0;
  uint64_t v8 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v16, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' in logical operation")) {
    return 1;
  }
  __int16 v15 = 0;
  uint64_t v10 = v16;
  if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, *(llvm::Type **)v16, &v15, a3)) {
    return 1;
  }
  if ((*(_DWORD *)(*(void *)v10 + 8) & 0xFE) == 0x12) {
    int v11 = *(unsigned __int8 *)(**(void **)(*(void *)v10 + 16) + 8);
  }
  else {
    int v11 = *(_DWORD *)(*(void *)v10 + 8);
  }
  if (v11 == 13)
  {
    __int16 v14 = 257;
    unsigned int v12 = llvm::BinaryOperator::Create(a4, v10, (uint64_t)v15, v13, 0);
    uint64_t result = 0;
    *a2 = v12;
  }
  else
  {
    v13[0] = "instruction requires integer or integer vector operands";
    __int16 v14 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v8, (llvm::Twine *)v13);
  }
  return result;
}

uint64_t llvm::LLParser::parseCompare(char **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, int a4)
{
  unsigned int v29 = 0;
  if (llvm::LLParser::parseCmpPredicate((llvm::LLParser *)this, &v29, a4)) {
    return 1;
  }
  __int16 v28 = 0;
  int v9 = this[27];
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v28, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after compare value")) {
    return 1;
  }
  uint64_t v24 = v9;
  uint64_t v27 = 0;
  uint64_t v10 = v28;
  if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, *(llvm::Type **)v28, &v27, a3)) {
    return 1;
  }
  uint64_t v11 = *(void *)v10;
  unsigned int v12 = *(_DWORD *)(*(void *)v10 + 8);
  int v13 = *(_DWORD *)(*(void *)v10 + 8) & 0xFE;
  if (a4 == 54)
  {
    if (v13 == 18) {
      unsigned int v12 = *(unsigned __int8 *)(**(void **)(v11 + 16) + 8);
    }
    if (v12 < 7)
    {
      __int16 v14 = operator new(0x80uLL);
      v14[21] = v14[21] & 0x38000000 | 2;
      __int16 v15 = (llvm::Value *)(v14 + 16);
      *(void *)__int16 v14 = 0;
      *((void *)v14 + 1) = 0;
      *((void *)v14 + 2) = 0;
      *((void *)v14 + 3) = v14 + 16;
      *((void *)v14 + 4) = 0;
      *((void *)v14 + 5) = 0;
      *((void *)v14 + 6) = 0;
      *((void *)v14 + 7) = v14 + 16;
      __int16 v16 = v29;
      __int16 v17 = v27;
      __int16 v26 = 257;
      sub_1CB90C994(*(_DWORD **)v10);
      llvm::CmpInst::CmpInst(v15, v18, 54, v16, (uint64_t)v10, (uint64_t)v17, v25, 0, 0);
LABEL_16:
      uint64_t result = 0;
      *a2 = v15;
      return result;
    }
    uint64_t v23 = "fcmp requires floating point operands";
  }
  else
  {
    if (v13 == 18) {
      unsigned int v12 = *(unsigned __int8 *)(**(void **)(v11 + 16) + 8);
    }
    if (v12 == 13 || v12 == 15)
    {
      uint64_t v19 = operator new(0x80uLL);
      v19[21] = v19[21] & 0x38000000 | 2;
      __int16 v15 = (llvm::Value *)(v19 + 16);
      *(void *)uint64_t v19 = 0;
      *((void *)v19 + 1) = 0;
      *((void *)v19 + 2) = 0;
      *((void *)v19 + 3) = v19 + 16;
      *((void *)v19 + 4) = 0;
      *((void *)v19 + 5) = 0;
      *((void *)v19 + 6) = 0;
      *((void *)v19 + 7) = v19 + 16;
      __int16 v20 = v29;
      uint64_t v21 = v27;
      __int16 v26 = 257;
      sub_1CB90C994(*(_DWORD **)v10);
      llvm::CmpInst::CmpInst(v15, v22, 53, v20, (uint64_t)v10, (uint64_t)v21, v25, 0, 0);
      goto LABEL_16;
    }
    uint64_t v23 = "icmp requires integer operands";
  }
  v25[0] = v23;
  __int16 v26 = 259;
  return llvm::LLLexer::Error((uint64_t)(this + 21), v24, (llvm::Twine *)v25);
}

uint64_t llvm::LLParser::parseCast(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3, int a4)
{
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v7 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v31, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 55, "expected 'to' after cast value")) {
    return 1;
  }
  v32[0] = "expected type";
  __int16 v33 = 259;
  if (llvm::LLParser::parseType(this, &v30, (const llvm::Twine *)v32, 0)) {
    return 1;
  }
  uint64_t v10 = v30;
  uint64_t v11 = (llvm::Type **)v31;
  if (llvm::CastInst::castIsValid(a4, *(llvm::Type **)v31, (uint64_t)v30))
  {
    __int16 v33 = 257;
    uint64_t v8 = 0;
    *a2 = llvm::CastInst::Create(a4, (uint64_t)v11, (uint64_t)v10, v32, 0);
  }
  else
  {
    llvm::CastInst::castIsValid(a4, *v11, (uint64_t)v10);
    sub_1CC196EB4((uint64_t)&v24, *v11);
    unsigned int v12 = std::string::insert(&v24, 0, "invalid cast opcode for cast from '");
    std::string::size_type v13 = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    __int16 v14 = std::string::append(&v25, "' to '");
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    sub_1CC196EB4((uint64_t)v22, v10);
    if (v23 >= 0) {
      __int16 v16 = v22;
    }
    else {
      __int16 v16 = (void **)v22[0];
    }
    if (v23 >= 0) {
      std::string::size_type v17 = v23 & 0x7F;
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v22[1];
    }
    uint64_t v18 = std::string::append(&v26, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    __int16 v20 = std::string::append(&v27, "'");
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    std::string::size_type v29 = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    v32[0] = (const char *)__p;
    uint64_t v8 = llvm::LLLexer::Error((uint64_t)this + 168, v7, (llvm::Twine *)v32);
    if (SHIBYTE(v29) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v27.__r_.__value_.__l.__data_);
    }
    if (v23 < 0) {
      operator delete(v22[0]);
    }
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v26.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v25.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v24.__r_.__value_.__l.__data_);
    }
  }
  return v8;
}

uint64_t llvm::LLParser::parseSelect(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v18 = 0;
  int v6 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v18, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after select condition")) {
    return 1;
  }
  std::string::size_type v17 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v17, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after select value")) {
    return 1;
  }
  __int16 v16 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v16, a3)) {
    return 1;
  }
  int v9 = (uint64_t *)v17;
  uint64_t v8 = v18;
  uint64_t v10 = v16;
  uint64_t v11 = llvm::SelectInst::areInvalidOperands((uint64_t *)v18, (uint64_t *)v17, v16);
  if (v11)
  {
    char v13 = 1;
    HIBYTE(v15) = 1;
    if (*v11)
    {
      v14[0] = v11;
      char v13 = 3;
    }
    LOBYTE(v15) = v13;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v14);
  }
  else
  {
    __int16 v15 = 257;
    unsigned int v12 = sub_1CC199EFC((uint64_t)v8, v9, (uint64_t)v10, v14, 0, 0);
    uint64_t result = 0;
    *a2 = v12;
  }
  return result;
}

uint64_t llvm::LLParser::parseVAArg(llvm::ConstantInt **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  char v13 = 0;
  __int16 v14 = 0;
  if (llvm::LLParser::parseTypeAndValue(this, &v14, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after vaarg operand")) {
    return 1;
  }
  int v6 = (char *)this[27];
  v15[0] = "expected type";
  __int16 v16 = 259;
  if (llvm::LLParser::parseType((llvm::LLParser *)this, &v13, (const llvm::Twine *)v15, 0)) {
    return 1;
  }
  uint64_t v7 = v13;
  int v8 = *((unsigned __int8 *)v13 + 8);
  if (v8 == 14 || v8 == 7)
  {
    v15[0] = "va_arg requires operand with first class type";
    __int16 v16 = 259;
    return llvm::LLLexer::Error((uint64_t)(this + 21), v6, (llvm::Twine *)v15);
  }
  else
  {
    uint64_t v10 = operator new(0x60uLL);
    uint64_t v11 = (llvm::Instruction *)(v10 + 8);
    v10[13] = v10[13] & 0x38000000 | 1;
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
    *((void *)v10 + 3) = v10 + 8;
    __int16 v16 = 257;
    unsigned int v12 = sub_1CC19DDB4((llvm::Value *)(v10 + 8), (uint64_t)v7, 60, (uint64_t)v14, 0);
    llvm::Value::setName(v12, v15);
    uint64_t result = 0;
    *a2 = v11;
  }
  return result;
}

uint64_t llvm::LLParser::parseExtractElement(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  __int16 v15 = 0;
  int v6 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v15, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after extract value")) {
    return 1;
  }
  __int16 v14 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v14, a3)) {
    return 1;
  }
  int v8 = v15;
  if ((*(_DWORD *)(*(void *)v15 + 8) & 0xFE) == 0x12 && (int v9 = v14, *(unsigned char *)(*(void *)v14 + 8) == 13))
  {
    __int16 v13 = 257;
    uint64_t v10 = operator new(0x80uLL);
    v10[21] = v10[21] & 0x38000000 | 2;
    uint64_t v11 = (llvm::Instruction *)(v10 + 16);
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = 0;
    *((void *)v10 + 3) = v10 + 16;
    *((void *)v10 + 4) = 0;
    *((void *)v10 + 5) = 0;
    *((void *)v10 + 6) = 0;
    *((void *)v10 + 7) = v10 + 16;
    llvm::ExtractElementInst::ExtractElementInst((llvm::ExtractElementInst *)(v10 + 16), v8, v9, v12, 0);
    uint64_t result = 0;
    *a2 = v11;
  }
  else
  {
    v12[0] = "invalid extractelement operands";
    __int16 v13 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v12);
  }
  return result;
}

uint64_t llvm::LLParser::parseInsertElement(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  std::string::size_type v21 = 0;
  int v6 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v21, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after insertelement value")) {
    return 1;
  }
  __int16 v20 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v20, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after insertelement value")) {
    return 1;
  }
  std::string::size_type v19 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v19, a3)) {
    return 1;
  }
  int v9 = v21;
  if ((*(_DWORD *)(*(void *)v21 + 8) & 0xFE) == 0x12
    && (uint64_t v10 = v20, *(void *)v20 == *(void *)(*(void *)v21 + 24))
    && (uint64_t v11 = v19, *(unsigned char *)(*(void *)v19 + 8) == 13))
  {
    __int16 v18 = 257;
    unsigned int v12 = operator new(0xA0uLL);
    uint64_t v13 = 0;
    __int16 v14 = (llvm::InsertElementInst *)(v12 + 24);
    v12[29] = v12[29] & 0x38000000 | 3;
    do
    {
      __int16 v15 = &v12[v13];
      *__int16 v15 = 0;
      v15[1] = 0;
      void v15[2] = 0;
      v15[3] = v14;
      v13 += 8;
    }
    while (v13 != 24);
    inserted = (llvm::Instruction *)llvm::InsertElementInst::InsertElementInst(v14, v9, v10, v11, (const llvm::Twine *)v17, 0);
    uint64_t v7 = 0;
    *a2 = inserted;
  }
  else
  {
    v17[0] = "invalid insertelement operands";
    __int16 v18 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v17);
  }
  return v7;
}

uint64_t llvm::LLParser::parseShuffleVector(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  __int16 v18 = 0;
  int v6 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v18, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after shuffle mask")) {
    return 1;
  }
  std::string::size_type v17 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v17, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after shuffle value")) {
    return 1;
  }
  __int16 v16 = 0;
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v16, a3)) {
    return 1;
  }
  uint64_t v10 = v17;
  int v9 = v18;
  uint64_t v11 = v16;
  if (llvm::ShuffleVectorInst::isValidOperands(v18, v17, v16, v8))
  {
    unsigned int v12 = operator new(0xA8uLL);
    v12[21] = v12[21] & 0x38000000 | 2;
    uint64_t v13 = (llvm::Instruction *)(v12 + 16);
    *(void *)unsigned int v12 = 0;
    *((void *)v12 + 1) = 0;
    *((void *)v12 + 2) = 0;
    *((void *)v12 + 3) = v12 + 16;
    *((void *)v12 + 4) = 0;
    *((void *)v12 + 5) = 0;
    *((void *)v12 + 6) = 0;
    *((void *)v12 + 7) = v12 + 16;
    __int16 v15 = 257;
    llvm::ShuffleVectorInst::ShuffleVectorInst((llvm::ShuffleVectorInst *)(v12 + 16), v9, v10, v11, (const llvm::Twine *)v14, 0);
    uint64_t result = 0;
    *a2 = v13;
  }
  else
  {
    v14[0] = "invalid shufflevector operands";
    __int16 v15 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v14);
  }
  return result;
}

uint64_t llvm::LLParser::parsePHI(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v6 = (char *)*((void *)this + 27);
  std::string::size_type v29 = 0;
  uint64_t v30 = "expected type";
  v32[8] = 259;
  if (llvm::LLParser::parseType(this, &v29, (const llvm::Twine *)&v30, 0)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' in phi value list")) {
    return 1;
  }
  __int16 v28 = 0;
  int v9 = (unsigned __int8 *)v29;
  if (llvm::LLParser::parseValue((llvm::ConstantInt **)this, v29, &v28, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after insertelement value")) {
    return 1;
  }
  std::string v27 = 0;
  LabelTy = (llvm::Type *)llvm::Type::getLabelTy(*(llvm::Type **)this, v10);
  unsigned int v12 = this;
  uint64_t v13 = (llvm::ConstantInt **)this;
  __int16 v14 = a3;
  if ((llvm::LLParser::parseValue(v13, LabelTy, &v27, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)v12, 7, "expected ']' in phi value list") & 1) != 0)
  {
    return 1;
  }
  uint64_t v30 = v32;
  uint64_t v31 = 0x1000000000;
  uint64_t v15 = (uint64_t)v12 + 168;
  while (1)
  {
    __int16 v16 = v27;
    if (v31 >= (unint64_t)HIDWORD(v31)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    std::string::size_type v17 = (llvm::Value **)((char *)v30 + 16 * v31);
    llvm::Value *v17 = v28;
    v17[1] = v16;
    LODWORD(v31) = v31 + 1;
    if (*((_DWORD *)v12 + 56) != 4) {
      break;
    }
    int v18 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)v12 + 168));
    *((_DWORD *)v12 + 56) = v18;
    if (v18 == 441)
    {
      uint64_t v7 = 2;
      goto LABEL_22;
    }
    if ((llvm::LLParser::parseToken((uint64_t)v12, 6, "expected '[' in phi value list") & 1) == 0
      && (llvm::LLParser::parseValue((llvm::ConstantInt **)v12, (llvm::Type *)v9, &v28, v14) & 1) == 0
      && (llvm::LLParser::parseToken((uint64_t)v12, 4, "expected ',' after insertelement value") & 1) == 0)
    {
      __int16 v20 = (llvm::Type *)llvm::Type::getLabelTy(*(llvm::Type **)v12, v19);
      if ((llvm::LLParser::parseValue((llvm::ConstantInt **)v12, v20, &v27, v14) & 1) == 0
        && (llvm::LLParser::parseToken((uint64_t)v12, 7, "expected ']' in phi value list") & 1) == 0)
      {
        continue;
      }
    }
    uint64_t v7 = 1;
    goto LABEL_19;
  }
  uint64_t v7 = 0;
LABEL_22:
  int v21 = v9[8];
  if (v21 == 14 || v21 == 7)
  {
    v25[0] = "phi node must have first class type";
    __int16 v26 = 259;
    uint64_t v7 = llvm::LLLexer::Error(v15, v6, (llvm::Twine *)v25);
  }
  else
  {
    __int16 v26 = 257;
    uint64_t v22 = sub_1CC19A1F8((uint64_t)v9, v31, v25, 0);
    if (v31)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 16 * v31;
      do
      {
        sub_1CC09A30C((uint64_t)v22, *(void *)((char *)v30 + v23), *(void *)((char *)v30 + v23 + 8));
        v23 += 16;
      }
      while (v24 != v23);
    }
    *a2 = v22;
  }
LABEL_19:
  if (v30 != v32) {
    free(v30);
  }
  return v7;
}

uint64_t llvm::LLParser::parseFreeze(llvm::ConstantInt **this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v10 = 0;
  uint64_t v4 = llvm::LLParser::parseTypeAndValue(this, &v10, a3);
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = operator new(0x60uLL);
    int v6 = (llvm::Instruction *)(v5 + 8);
    v5[13] = v5[13] & 0x38000000 | 1;
    *(void *)uint64_t v5 = 0;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 3) = v5 + 8;
    __int16 v9 = 257;
    llvm::FreezeInst::FreezeInst((llvm::FreezeInst *)(v5 + 8), v10, &v8, 0);
    *a2 = v6;
  }
  return v4;
}

uint64_t llvm::LLParser::parseCall(uint64_t a1, unint64_t *a2, const llvm::APInt *a3, int a4)
{
  v96[8] = *MEMORY[0x1E4F143B8];
  uint64_t v93 = **(uint64_t ***)(a1 + 328);
  char v94 = v96;
  uint64_t v95 = 0x800000000;
  uint64_t v89 = v93;
  uint64_t v90 = v92;
  uint64_t v91 = 0x800000000;
  long long __p = 0;
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  __int16 v60 = 0;
  uint64_t v61 = 0;
  uint64_t v59 = 0;
  int v78 = 0;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v82 = 0u;
  uint64_t v84 = 0;
  uint64_t v79 = 0;
  uint64_t v83 = 0;
  int v85 = 1;
  char v86 = 0;
  sub_1CB892E1C((uint64_t)v87, 0.0);
  v87[5] = 0;
  char v88 = 0;
  __int16 v75 = v77;
  uint64_t v76 = 0x1000000000;
  uint64_t v72 = v74;
  uint64_t v73 = 0x200000000;
  int v8 = *(char **)(a1 + 216);
  if (a4 && (llvm::LLParser::parseToken(a1, 298, "expected 'tail call', 'musttail call', or 'notail call'") & 1) != 0) {
    goto LABEL_6;
  }
  LODWORD(v9) = sub_1CD4ED1D4(a1);
  if ((llvm::LLParser::parseOptionalCallingConv((llvm::LLParser *)a1, (unsigned int *)&v60) & 1) != 0
    || (llvm::LLParser::parseOptionalParamOrReturnAttrs((llvm::LLParser *)a1, (llvm::AttrBuilder *)&v93, 0) & 1) != 0
    || (llvm::LLParser::parseOptionalAddrSpace((llvm::LLParser *)a1, (unsigned int *)&v60 + 1, *(_DWORD *)(*(void *)(a1 + 328) + 284)) & 1) != 0)
  {
    goto LABEL_6;
  }
  int v51 = v9;
  std::string::size_type v50 = a2;
  __int16 v14 = *(char **)(a1 + 216);
  __src = "expected type";
  __int16 v71 = 259;
  LOBYTE(v9) = 1;
  if ((llvm::LLParser::parseType((llvm::LLParser *)a1, &v59, (const llvm::Twine *)&__src, 1) & 1) == 0
    && (llvm::LLParser::parseValID((uint64_t **)a1, (uint64_t)&v78, a3, 0) & 1) == 0
    && (llvm::LLParser::parseParameterList(a1, (uint64_t)&v75, a3, a4 == 2, *(_DWORD *)(*(void *)(*((void *)a3 + 1) + 24) + 8) > 0xFFu) & 1) == 0&& (llvm::LLParser::parseFnAttributeValuePairs(a1, (uint64_t)&v89, (char **)&__p, 0, &v61) & 1) == 0&& (llvm::LLParser::parseOptionalOperandBundles(a1, (uint64_t)&v72, a3) & 1) == 0)
  {
    std::string::size_type v48 = v14;
    uint64_t v49 = a1 + 168;
    uint64_t v16 = (uint64_t)v59;
    if (v59)
    {
      if (*((unsigned char *)v59 + 8) == 14) {
        goto LABEL_29;
      }
    }
    std::string::size_type v47 = v59;
    __int16 v65 = 0;
    uint64_t v66 = 0;
    v67[0] = 0;
    if (v76)
    {
      uint64_t v9 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 24 * v76;
      do
      {
        std::string v25 = **(void ***)((char *)v75 + v9 + 8);
        __src = v25;
        if ((unint64_t)v23 >= v67[0]) {
          uint64_t v23 = sub_1CBC13470(&v65, &__src);
        }
        else {
          *v23++ = v25;
        }
        uint64_t v66 = (uint64_t)v23;
        v9 += 24;
      }
      while (v24 != v9);
    }
    isValidReturnuint64_t Type = llvm::FunctionType::isValidReturnType(v47, v15);
    if (isValidReturnType)
    {
      uint64_t v16 = llvm::FunctionType::get((uint64_t **)v47, (uint64_t)v65, (v66 - (uint64_t)v65) >> 3, 0);
    }
    else
    {
      __src = "Invalid result type for LLVM function";
      __int16 v71 = 259;
      LOBYTE(v9) = llvm::LLLexer::Error(v49, v48, (llvm::Twine *)&__src);
      uint64_t v16 = 0;
    }
    if (v65)
    {
      uint64_t v66 = (uint64_t)v65;
      operator delete(v65);
    }
    if (isValidReturnType)
    {
LABEL_29:
      *(void *)&long long v80 = v16;
      std::string::size_type v58 = 0;
      unint64_t v17 = llvm::PointerType::get((llvm::PointerType *)v16, (llvm::Type *)HIDWORD(v60));
      if (llvm::LLParser::convertValIDToValue((llvm::ConstantInt **)a1, v17, &v78, &v58, (uint64_t)a3))
      {
LABEL_6:
        LOBYTE(v9) = 1;
        goto LABEL_7;
      }
      __src = v70;
      size_t __n = 0x800000000;
      __int16 v65 = v67;
      uint64_t v66 = 0x800000000;
      uint64_t v18 = *(void *)(v16 + 16);
      std::string::size_type v19 = (llvm::Type **)(v18 + 8);
      __int16 v20 = (llvm::Type **)(v18 + 8 * *(unsigned int *)(v16 + 12));
      if (v76)
      {
        uint64_t v26 = 0;
        uint64_t v27 = 24 * v76;
        do
        {
          if (v19 == v20)
          {
            uint64_t v30 = (char *)v75;
            if (*(_DWORD *)(v16 + 8) <= 0xFFu)
            {
              uint64_t v32 = *(char **)((char *)v75 + v26);
              v56[0] = (uint64_t *)"too many arguments specified";
              __int16 v57 = 259;
              uint64_t v31 = a1 + 168;
              goto LABEL_59;
            }
            std::string::size_type v19 = v20;
          }
          else
          {
            std::string::size_type v29 = *v19++;
            __int16 v28 = v29;
            uint64_t v30 = (char *)v75;
            if (v29 && v28 != **(llvm::Type ***)((char *)v75 + v26 + 8))
            {
              uint64_t v40 = *(char **)((char *)v75 + v26);
              sub_1CC196EB4((uint64_t)&v52, v28);
              uint64_t v41 = std::string::insert(&v52, 0, "argument is not of expected type '");
              std::string::size_type v42 = v41->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v53.__r_.__value_.__l.__data_ = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
              v53.__r_.__value_.__r.__words[2] = v42;
              v41->__r_.__value_.__l.__size_ = 0;
              v41->__r_.__value_.__r.__words[2] = 0;
              v41->__r_.__value_.__r.__words[0] = 0;
              uint64_t v43 = std::string::append(&v53, "'");
              std::string::size_type v44 = v43->__r_.__value_.__r.__words[2];
              *(_OWORD *)std::string v54 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
              std::string::size_type v55 = v44;
              v43->__r_.__value_.__l.__size_ = 0;
              v43->__r_.__value_.__r.__words[2] = 0;
              v43->__r_.__value_.__r.__words[0] = 0;
              __int16 v57 = 260;
              v56[0] = (uint64_t *)v54;
              LOBYTE(v9) = llvm::LLLexer::Error(v49, v40, (llvm::Twine *)v56);
              if (SHIBYTE(v55) < 0) {
                operator delete(v54[0]);
              }
              if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v53.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v52.__r_.__value_.__l.__data_);
              }
              goto LABEL_60;
            }
          }
          if (v66 >= (unint64_t)HIDWORD(v66)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v65 + v66) = *(void *)&v30[v26 + 8];
          LODWORD(v66) = v66 + 1;
          if (__n >= (unint64_t)HIDWORD(__n)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)__src + __n) = *(void *)((char *)v75 + v26 + 16);
          LODWORD(__n) = __n + 1;
          v26 += 24;
        }
        while (v27 != v26);
      }
      if (v19 == v20)
      {
        if (!llvm::AttrBuilder::hasAlignmentAttr((llvm::AttrBuilder *)&v89))
        {
          uint64_t v33 = *(uint64_t **)a1;
          uint64_t v34 = llvm::AttributeSet::get(*(llvm::AttributeSet **)a1, &v89, v21);
          uint64_t v36 = llvm::AttributeSet::get(*(llvm::AttributeSet **)a1, &v93, v35);
          uint64_t v9 = llvm::AttributeList::get(v33, v34, v36, __src, __n);
          __int16 v57 = 257;
          uint64_t v37 = sub_1CC19A3E0((uint64_t **)v16, v58, (uint64_t *)v65, v66, (uint64_t)v72, v73, (const char **)v56, 0);
          unint64_t v38 = v37;
          *(_WORD *)(v37 + 18) = *(_WORD *)(v37 + 18) & 0xF000 | a4 & 0xF003 | (4 * (_WORD)v60);
          if (v51)
          {
            if (!sub_1CB845E74(v37))
            {
              llvm::Value::deleteValue((void (**)(void))v38, v45);
              uint64_t v22 = "fast-math-flags specified for call without floating-point scalar or vector return type";
              goto LABEL_58;
            }
            *(unsigned char *)(v38 + 17) |= 2 * (_BYTE)v51;
          }
          *(void *)(v38 + 64) = v9;
          v56[0] = (uint64_t *)v38;
          uint64_t v39 = sub_1CD4F40F4((uint64_t **)(a1 + 1112), v38, v56);
          sub_1CC19E0C8(v39 + 5, (char *)__p, v63, (v63 - (unsigned char *)__p) >> 2);
          LOBYTE(v9) = 0;
          *std::string::size_type v50 = v38;
          goto LABEL_60;
        }
        uint64_t v22 = "call instructions may not have an alignment";
      }
      else
      {
        uint64_t v22 = "not enough parameters specified for call";
      }
LABEL_58:
      v56[0] = (uint64_t *)v22;
      __int16 v57 = 259;
      uint64_t v31 = a1 + 168;
      uint64_t v32 = v8;
LABEL_59:
      LOBYTE(v9) = llvm::LLLexer::Error(v31, v32, (llvm::Twine *)v56);
LABEL_60:
      if (v65 != v67) {
        free(v65);
      }
      if (__src != v70) {
        free(__src);
      }
    }
  }
LABEL_7:
  uint64_t v10 = v72;
  if (v73)
  {
    uint64_t v11 = 48 * v73;
    unsigned int v12 = (char *)v72 - 48;
    do
    {
      sub_1CD4AF9B4((uint64_t)&v12[v11]);
      v11 -= 48;
    }
    while (v11);
    uint64_t v10 = v72;
  }
  if (v10 != v74) {
    free(v10);
  }
  if (v75 != v77) {
    free(v75);
  }
  sub_1CD4F271C((uint64_t)&v78);
  if (__p) {
    operator delete(__p);
  }
  if (v90 != v92) {
    free(v90);
  }
  if (v94 != v96) {
    free(v94);
  }
  return v9 & 1;
}

uint64_t llvm::LLParser::parseAlloc(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  uint64_t v36 = 0;
  __int16 v34 = 0;
  unsigned int v33 = 0;
  uint64_t v32 = 0;
  int v6 = *((_DWORD *)this + 56);
  int v7 = v6;
  if (v6 == 172)
  {
    int v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v7;
  }
  if (v7 == 229) {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  }
  int v8 = (char *)*((void *)this + 27);
  uint64_t v26 = "expected type";
  v30[0] = 259;
  if (llvm::LLParser::parseType(this, &v32, (const llvm::Twine *)&v26, 0)) {
    return 1;
  }
  unsigned int v12 = (unsigned __int8 *)v32;
  if (*((unsigned char *)v32 + 8) == 14 || !llvm::PointerType::isValidElementType(v32, v9))
  {
    uint64_t v26 = "invalid type for alloca";
    v30[0] = 259;
    uint64_t v15 = (char *)this + 168;
    uint64_t v16 = v8;
    return llvm::LLLexer::Error((uint64_t)v15, v16, (llvm::Twine *)&v26);
  }
  unsigned __int8 v31 = 0;
  if (*((_DWORD *)this + 56) != 4) {
    goto LABEL_22;
  }
  int v13 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v13;
  switch(v13)
  {
    case 441:
      __int16 v14 = 0;
LABEL_13:
      unsigned __int8 v31 = 1;
      goto LABEL_23;
    case 91:
      if ((llvm::LLParser::parseOptionalAddrSpace(this, &v33, 0) & 1) == 0)
      {
LABEL_22:
        __int16 v14 = 0;
        goto LABEL_23;
      }
      return 1;
    case 90:
      if ((llvm::LLParser::parseOptionalAlignment((uint64_t)this, &v34, 0) & 1) == 0
        && (llvm::LLParser::parseOptionalCommaAddrSpace((uint64_t)this, &v33, &v35, &v31) & 1) == 0)
      {
        goto LABEL_22;
      }
      return 1;
  }
  __int16 v14 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v36, a3)) {
    return 1;
  }
  if (*((_DWORD *)this + 56) != 4) {
    goto LABEL_23;
  }
  int v23 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  *((_DWORD *)this + 56) = v23;
  if (v23 == 441) {
    goto LABEL_13;
  }
  if (v23 == 91)
  {
    if ((llvm::LLParser::parseOptionalAddrSpace(this, &v33, 0) & 1) == 0) {
      goto LABEL_23;
    }
    return 1;
  }
  if (v23 == 90
    && ((llvm::LLParser::parseOptionalAlignment((uint64_t)this, &v34, 0) & 1) != 0
     || (llvm::LLParser::parseOptionalCommaAddrSpace((uint64_t)this, &v33, &v35, &v31) & 1) != 0))
  {
    return 1;
  }
LABEL_23:
  unint64_t v17 = v36;
  if (v36 && *(unsigned char *)(*(void *)v36 + 8) != 13)
  {
    uint64_t v26 = "element count must have integer type";
    v30[0] = 259;
    uint64_t v15 = (char *)this + 168;
    uint64_t v16 = v14;
    return llvm::LLLexer::Error((uint64_t)v15, v16, (llvm::Twine *)&v26);
  }
  uint64_t v26 = (const char *)v30;
  uint64_t v27 = (char *)v30;
  uint64_t v28 = 4;
  int v29 = 0;
  if (HIBYTE(v34))
  {
    unsigned __int8 PrefTypeAlign = v34;
LABEL_27:
    __int16 v19 = v7 == 229;
    __int16 v20 = (char *)operator new(0x68uLL);
    *((_DWORD *)v20 + 13) = *((_DWORD *)v20 + 13) & 0x38000000 | 1;
    *(void *)__int16 v20 = 0;
    *((void *)v20 + 1) = 0;
    *((void *)v20 + 2) = 0;
    *((void *)v20 + 3) = v20 + 32;
    __int16 v25 = 257;
    int v21 = llvm::AllocaInst::AllocaInst((unint64_t *)v20 + 4, (llvm::PointerType *)v12, (llvm::Type *)v33, v17, PrefTypeAlign, v24, 0);
    *((_WORD *)v20 + 25) = ((v6 == 172) << 6) | (v19 << 7) | *((_WORD *)v20 + 25) & 0xFF3F;
    *a2 = (llvm::Instruction *)v21;
    uint64_t v10 = 2 * v31;
    goto LABEL_28;
  }
  unsigned int v22 = v12[8];
  if (v22 <= 0x11)
  {
    if (((1 << v22) & 0xAC7F) != 0)
    {
LABEL_32:
      unsigned __int8 PrefTypeAlign = llvm::DataLayout::getPrefTypeAlign((llvm::DataLayout *)(*((void *)this + 41) + 272), (llvm::Type *)v12);
      goto LABEL_27;
    }
    if (((1 << v22) & 0x30000) != 0) {
      goto LABEL_34;
    }
  }
  if ((v22 & 0xFE) == 0x12 || v22 == 21)
  {
LABEL_34:
    if (llvm::Type::isSizedDerivedType((uint64_t)v12, (uint64_t)&v26)) {
      goto LABEL_32;
    }
  }
  v24[0] = "Cannot allocate unsized type";
  __int16 v25 = 259;
  uint64_t v10 = llvm::LLLexer::Error((uint64_t)this + 168, v8, (llvm::Twine *)v24);
LABEL_28:
  if (v27 != v26) {
    free(v27);
  }
  return v10;
}

uint64_t llvm::LLParser::parseCmpXchg(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  unsigned __int8 v41 = 0;
  unsigned int v39 = 0;
  unsigned int v40 = 0;
  unsigned __int8 v38 = 1;
  __int16 v37 = 0;
  int v6 = *((_DWORD *)this + 56);
  int v7 = v6;
  if (v6 == 31)
  {
    int v7 = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
    *((_DWORD *)this + 56) = v7;
  }
  if (v7 == 68) {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  }
  std::string::size_type v44 = 0;
  int v8 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v44, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after cmpxchg address")) {
    return 1;
  }
  uint64_t v43 = 0;
  uint64_t v10 = (char *)*((void *)this + 27);
  if (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v43, a3)) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' after cmpxchg cmp operand")) {
    return 1;
  }
  std::string::size_type v42 = 0;
  uint64_t v11 = (char *)*((void *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v42, a3) & 1) != 0
    || (llvm::LLParser::parseScope(this, &v38) & 1) != 0
    || (llvm::LLParser::parseOrdering((uint64_t)this, &v40) & 1) != 0
    || (llvm::LLParser::parseOrdering((uint64_t)this, &v39) & 1) != 0
    || (llvm::LLParser::parseOptionalCommaAlign((uint64_t)this, &v37, &v41) & 1) != 0)
  {
    return 1;
  }
  __int16 v12 = v40;
  if (v40 <= 1)
  {
    uint64_t v30 = "invalid cmpxchg success ordering";
    goto LABEL_34;
  }
  __int16 v13 = v39;
  if (v39 <= 6 && ((1 << v39) & 0x63) != 0)
  {
    uint64_t v30 = "invalid cmpxchg failure ordering";
LABEL_34:
    uint64_t v35 = v30;
    __int16 v36 = 259;
    unsigned __int8 v31 = (char *)this + 168;
    uint64_t v32 = (char *)*((void *)this + 27);
    return llvm::LLLexer::Error((uint64_t)v31, v32, (llvm::Twine *)&v35);
  }
  __int16 v34 = v44;
  if (*(unsigned char *)(*(void *)v44 + 8) != 15)
  {
    uint64_t v35 = "cmpxchg operand must be a pointer";
    __int16 v36 = 259;
    unsigned __int8 v31 = (char *)this + 168;
    uint64_t v32 = v8;
    return llvm::LLLexer::Error((uint64_t)v31, v32, (llvm::Twine *)&v35);
  }
  __int16 v14 = (uint64_t ***)v43;
  uint64_t v15 = *(void *)v43;
  uint64_t v16 = *(void *)(*(void *)v44 + 24);
  if (v16 && v16 != v15)
  {
    uint64_t v35 = "compare value and pointer type do not match";
    __int16 v36 = 259;
    unsigned __int8 v31 = (char *)this + 168;
    uint64_t v32 = v10;
    return llvm::LLLexer::Error((uint64_t)v31, v32, (llvm::Twine *)&v35);
  }
  unint64_t v17 = v42;
  uint64_t v18 = *(void *)v42;
  if (v16 && v16 != v18)
  {
    unsigned int v33 = "new value and pointer type do not match";
    goto LABEL_37;
  }
  if (v15 != v18)
  {
    unsigned int v33 = "compare value and new value type do not match";
    goto LABEL_37;
  }
  int v19 = *(unsigned __int8 *)(v15 + 8);
  if (v19 == 14 || v19 == 7)
  {
    unsigned int v33 = "cmpxchg operand must be a first class value";
LABEL_37:
    uint64_t v35 = v33;
    __int16 v36 = 259;
    unsigned __int8 v31 = (char *)this + 168;
    uint64_t v32 = v11;
    return llvm::LLLexer::Error((uint64_t)v31, v32, (llvm::Twine *)&v35);
  }
  unint64_t v21 = (unint64_t)(sub_1CB83544C(*(void *)(*((void *)a3 + 1) + 40) + 272, v15) + 7) >> 3;
  if (v20 == 1) {
  char v22 = __clz(v21);
  }
  int v23 = operator new(0xA0uLL);
  uint64_t v24 = 0;
  uint64_t v25 = (uint64_t)(v23 + 24);
  v23[29] = v23[29] & 0x38000000 | 3;
  do
  {
    uint64_t v26 = &v23[v24];
    void *v26 = 0;
    v26[1] = 0;
    v26[2] = 0;
    v26[3] = v25;
    v24 += 8;
  }
  while (v24 != 24);
  __int16 v27 = v7 == 68;
  unsigned __int8 v28 = 63 - v22;
  if (HIBYTE(v37)) {
    unsigned __int8 v28 = v37;
  }
  int v29 = (llvm::Instruction *)llvm::AtomicCmpXchgInst::AtomicCmpXchgInst(v25, (uint64_t)v34, v14, (uint64_t)v17, v28, v12, v13, v38, 0);
  *((_WORD *)v23 + 57) = v27 | (2 * (v6 == 31)) | *((_WORD *)v23 + 57) & 0xFFFC;
  *a2 = v29;
  return 2 * v41;
}

uint64_t llvm::LLParser::parseFence(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  int v14 = 0;
  uint64_t v5 = 1;
  unsigned __int8 v13 = 1;
  if ((llvm::LLParser::parseScope(this, &v13) & 1) == 0
    && (llvm::LLParser::parseOrdering((uint64_t)this, &v14) & 1) == 0)
  {
    __int16 v7 = v14;
    if (v14 == 2)
    {
      uint64_t v10 = "fence cannot be monotonic";
    }
    else
    {
      if (v14 != 1)
      {
        int v8 = (llvm::Instruction *)operator new(0x40uLL);
        *((_DWORD *)v8 + 5) &= 0x38000000u;
        uint64_t v9 = llvm::FenceInst::FenceInst(v8, *(void *)this, v7, v13, 0);
        uint64_t v5 = 0;
        *a2 = v9;
        return v5;
      }
      uint64_t v10 = "fence cannot be unordered";
    }
    uint64_t v11 = v10;
    __int16 v12 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v11);
  }
  return v5;
}

uint64_t llvm::LLParser::parseExtractValue(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  void v18[2] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  uint64_t v16 = v18;
  uint64_t v17 = 0x400000000;
  uint64_t v5 = (char *)*((void *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v15, a3) & 1) != 0
    || (unsigned __int8 v14 = 0, (llvm::LLParser::parseIndexList((uint64_t)this, (uint64_t)&v16, &v14) & 1) != 0))
  {
    uint64_t v6 = 1;
    goto LABEL_3;
  }
  int v8 = (uint64_t *)v15;
  if ((*(_DWORD *)(*(void *)v15 + 8) & 0xFE) == 0x10)
  {
    uint64_t v9 = (unsigned int *)v16;
    uint64_t v10 = v17;
    if (llvm::ExtractValueInst::getIndexedType(*(void *)v15, (unsigned int *)v16, v17))
    {
      __int16 v13 = 257;
      *a2 = sub_1CC19A650(v8, v9, v10, v12, 0);
      uint64_t v6 = 2 * v14;
      goto LABEL_3;
    }
    uint64_t v11 = "invalid indices for extractvalue";
  }
  else
  {
    uint64_t v11 = "extractvalue operand must be aggregate type";
  }
  v12[0] = v11;
  __int16 v13 = 259;
  uint64_t v6 = llvm::LLLexer::Error((uint64_t)this + 168, v5, (llvm::Twine *)v12);
LABEL_3:
  if (v16 != v18) {
    free(v16);
  }
  return v6;
}

uint64_t llvm::LLParser::parseInsertValue(llvm::LLParser *this, llvm::Instruction **a2, llvm::LLParser::PerFunctionState *a3)
{
  void v41[2] = *MEMORY[0x1E4F143B8];
  unsigned __int8 v38 = 0;
  unsigned int v39 = (unsigned int *)v41;
  uint64_t v40 = 0x400000000;
  uint64_t v6 = (char *)*((void *)this + 27);
  if ((llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v38, a3) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 4, "expected comma after insertvalue operand") & 1) != 0
    || (__int16 v37 = 0,
        uint64_t v9 = (char *)*((void *)this + 27),
        (llvm::LLParser::parseTypeAndValue((llvm::ConstantInt **)this, &v37, a3) & 1) != 0)
    || (unsigned __int8 v36 = 0, (llvm::LLParser::parseIndexList((uint64_t)this, (uint64_t)&v39, &v36) & 1) != 0))
  {
    uint64_t v7 = 1;
    goto LABEL_3;
  }
  uint64_t v10 = v38;
  if ((*(_DWORD *)(*(void *)v38 + 8) & 0xFE) != 0x10)
  {
    unsigned __int8 v14 = "insertvalue operand must be aggregate type";
LABEL_15:
    v34[0] = v14;
    __int16 v35 = 259;
    uint64_t v7 = llvm::LLLexer::Error((uint64_t)this + 168, v6, (llvm::Twine *)v34);
    goto LABEL_3;
  }
  uint64_t v11 = v39;
  uint64_t v12 = v40;
  Indexeduint64_t Type = llvm::ExtractValueInst::getIndexedType(*(void *)v38, v39, v40);
  if (!IndexedType)
  {
    unsigned __int8 v14 = "invalid indices for insertvalue";
    goto LABEL_15;
  }
  if (IndexedType == *(void *)v37)
  {
    __int16 v35 = 257;
    *a2 = sub_1CC19A834(v10, (uint64_t)v37, v11, v12, v34, 0);
    uint64_t v7 = 2 * v36;
  }
  else
  {
    uint64_t v15 = (llvm::Type *)IndexedType;
    sub_1CC196EB4((uint64_t)&v28, *(llvm::Type **)v37);
    uint64_t v16 = std::string::insert(&v28, 0, "insertvalue operand and field disagree in type: '");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = std::string::append(&v29, "' instead of '");
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    sub_1CC196EB4((uint64_t)v26, v15);
    if (v27 >= 0) {
      __int16 v20 = v26;
    }
    else {
      __int16 v20 = (void **)v26[0];
    }
    if (v27 >= 0) {
      std::string::size_type v21 = v27 & 0x7F;
    }
    else {
      std::string::size_type v21 = (std::string::size_type)v26[1];
    }
    char v22 = std::string::append(&v30, (const std::string::value_type *)v20, v21);
    std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    uint64_t v24 = std::string::append(&v31, "'");
    std::string::size_type v25 = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)long long __p = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    std::string::size_type v33 = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    __int16 v35 = 260;
    v34[0] = (const char *)__p;
    uint64_t v7 = llvm::LLLexer::Error((uint64_t)this + 168, v9, (llvm::Twine *)v34);
    if (SHIBYTE(v33) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v31.__r_.__value_.__l.__data_);
    }
    if (v27 < 0) {
      operator delete(v26[0]);
    }
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v29.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v28.__r_.__value_.__l.__data_);
    }
  }
LABEL_3:
  if (v39 != (unsigned int *)v41) {
    free(v39);
  }
  return v7;
}

char *sub_1CD4EF89C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8, const char **a9, llvm::Instruction *a10)
{
  int v16 = 0;
  if (a8)
  {
    uint64_t v17 = 48 * a8;
    uint64_t v18 = (void *)(a7 + 32);
    do
    {
      v16 += (*v18 - *(v18 - 1)) >> 3;
      v18 += 6;
      v17 -= 48;
    }
    while (v17);
  }
  signed int v19 = a6 + v16 + 3;
  __int16 v20 = llvm::User::operator new((llvm::User *)0x50, v19, 16 * (int)a8);
  std::string::size_type v21 = llvm::Instruction::Instruction((llvm::Instruction *)v20, **(llvm::Type ***)(a1 + 16), 5, (llvm::Use *)&v20[-32 * v19], v19, a10);
  *((void *)v21 + 8) = 0;
  llvm::InvokeInst::init((uint64_t)v21, a1, a2, a3, a4, a5, a6, v22, a7, a8, a9);
  return v20;
}

uint64_t llvm::LLParser::parseExceptionArgs(_DWORD *a1, uint64_t a2, llvm::LLParser::PerFunctionState *a3)
{
  if ((llvm::LLParser::parseToken((uint64_t)a1, 6, "expected '[' in catchpad/cleanuppad") & 1) == 0)
  {
    if (a1[56] == 7)
    {
LABEL_5:
      int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 42));
      uint64_t result = 0;
      a1[56] = v7;
      return result;
    }
    int v8 = *(_DWORD *)(a2 + 8);
    while (!v8 || (llvm::LLParser::parseToken((uint64_t)a1, 4, "expected ',' in argument list") & 1) == 0)
    {
      uint64_t v12 = 0;
      v13[0] = (llvm::Metadata *)"expected type";
      __int16 v14 = 259;
      if (llvm::LLParser::parseType((llvm::LLParser *)a1, &v12, (const llvm::Twine *)v13, 0)) {
        break;
      }
      uint64_t v11 = 0;
      if (*((unsigned char *)v12 + 8) == 9)
      {
        v13[0] = 0;
        if (llvm::LLParser::parseMetadata((uint64_t)a1, v13, a3)) {
          return 1;
        }
        uint64_t v9 = llvm::MetadataAsValue::get(*(void *)a1, (unsigned __int8 *)v13[0]);
      }
      else
      {
        if (llvm::LLParser::parseValue((llvm::ConstantInt **)a1, v12, &v11, a3)) {
          return 1;
        }
        uint64_t v9 = (uint64_t)v11;
      }
      unint64_t v10 = *(unsigned int *)(a2 + 8);
      if (v10 >= *(unsigned int *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a2 + 8 * v10) = v9;
      int v8 = *(_DWORD *)(a2 + 8) + 1;
      *(_DWORD *)(a2 + 8) = v8;
      if (a1[56] == 7) {
        goto LABEL_5;
      }
    }
  }
  return 1;
}

char *sub_1CD4EFB0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const char **a11, llvm::Instruction *a12)
{
  int v16 = 0;
  if (a10)
  {
    uint64_t v17 = 48 * a10;
    uint64_t v18 = (void *)(a9 + 32);
    do
    {
      v16 += (*v18 - *(v18 - 1)) >> 3;
      v18 += 6;
      v17 -= 48;
    }
    while (v17);
  }
  signed int v19 = a5 + a7 + v16 + 2;
  __int16 v20 = llvm::User::operator new((llvm::User *)0x58, v19, 16 * (int)a10);
  std::string::size_type v21 = llvm::Instruction::Instruction((llvm::Instruction *)v20, **(llvm::Type ***)(a1 + 16), 11, (llvm::Use *)&v20[-32 * v19], v19, a12);
  *((void *)v21 + 8) = 0;
  llvm::CallBrInst::init((uint64_t)v21, a1, a2, a3, a4, a5, a6, a7, a9, a10, a11);
  return v20;
}

uint64_t llvm::LLParser::parseUseListOrderIndexes(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(char **)(a1 + 216);
  if (llvm::LLParser::parseToken(a1, 8, "expected '{' here")) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 224) == 9)
  {
    *(void *)uint64_t v15 = "expected non-empty list of uselistorder indexes";
    __int16 v16 = 259;
    uint64_t v6 = *(char **)(a1 + 216);
    uint64_t v7 = a1 + 168;
    return llvm::LLLexer::Error(v7, v6, (llvm::Twine *)v15);
  }
  v15[0] = 0;
  if (llvm::LLParser::parseUInt32((char **)a1, v15)) {
    return 1;
  }
  int v8 = 0;
  unsigned int v9 = 0;
  int v10 = 1;
  while (1)
  {
    if (v9 <= v15[0]) {
      unsigned int v9 = v15[0];
    }
    unsigned int v11 = *(_DWORD *)(a2 + 8);
    BOOL v12 = v15[0] == v11;
    if (v11 >= *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v8 += v15[0] - v11;
    *(_DWORD *)(*(void *)a2 + 4 * v11) = v15[0];
    v10 &= v12;
    ++*(_DWORD *)(a2 + 8);
    if (*(_DWORD *)(a1 + 224) != 4) {
      break;
    }
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    v15[0] = 0;
    if (llvm::LLParser::parseUInt32((char **)a1, v15)) {
      return 1;
    }
  }
  if (llvm::LLParser::parseToken(a1, 9, "expected '}' here")) {
    return 1;
  }
  unsigned int v13 = *(_DWORD *)(a2 + 8);
  if (v13 <= 1)
  {
    __int16 v14 = "expected >= 2 uselistorder indexes";
LABEL_23:
    *(void *)uint64_t v15 = v14;
    __int16 v16 = 259;
    uint64_t v7 = a1 + 168;
    uint64_t v6 = v4;
    return llvm::LLLexer::Error(v7, v6, (llvm::Twine *)v15);
  }
  if (v8 || v13 <= v9)
  {
    __int16 v14 = "expected distinct uselistorder indexes in range [0, size)";
    goto LABEL_23;
  }
  if (v10)
  {
    __int16 v14 = "expected uselistorder indexes to change the order";
    goto LABEL_23;
  }
  return 0;
}

uint64_t *sub_1CD4EFDD8(uint64_t a1, int *a2, size_t a3)
{
  v31[10] = *(char **)MEMORY[0x1E4F143B8];
  long long v28 = xmmword_1CFAC4320;
  uint64_t v5 = a1 + 56;
  uint64_t v29 = 0;
  llvm::MD5::update((int *)&v28, a2, a3);
  llvm::MD5::final((int *)&v28, (int *)&v22);
  *(void *)&long long v28 = v22.__r_.__value_.__r.__words[0];
  uint64_t v6 = sub_1CD4F29A8(v5, (unint64_t *)&v28);
  if (v6 == v7)
  {
LABEL_17:
    long long v28 = xmmword_1CFAC4320;
    uint64_t v29 = 0;
    llvm::MD5::update((int *)&v28, a2, a3);
    llvm::MD5::final((int *)&v28, (int *)&v22);
    std::string::size_type v16 = v22.__r_.__value_.__r.__words[0];
    std::string::__init(&v21, (const std::string::value_type *)a2, a3);
    LODWORD(v18[0]) = 5;
    memset((char *)v18 + 4, 0, 28);
    std::string v22 = v21;
    long long v23 = v18[0];
    long long v20 = 0u;
    signed int v19 = &v20;
    memset(&v21, 0, sizeof(v21));
    long long v24 = v18[1];
    long long v27 = 0u;
    uint64_t v25 = 0;
    uint64_t v26 = &v27;
    *(void *)&long long v28 = v16;
    sub_1CC19DEC4((uint64_t)&v28 + 8, (long long *)&v22);
    int v8 = sub_1CD4F2A40(v5, (uint64_t)&v28);
    sub_1CD4AFC3C((uint64_t)v31, v31[1]);
    if (v30 < 0) {
      operator delete(*((void **)&v28 + 1));
    }
    sub_1CD4AFC3C((uint64_t)&v26, (char *)v27);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    sub_1CD4AFC3C((uint64_t)&v19, (char *)v20);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v21.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    int v8 = v6;
    unsigned int v9 = v7;
    while (1)
    {
      char v10 = *((unsigned char *)v8 + 63);
      if (v10 >= 0) {
        unsigned int v11 = v8 + 5;
      }
      else {
        unsigned int v11 = (const void *)v8[5];
      }
      uint64_t v12 = v8[6];
      if (v10 >= 0) {
        uint64_t v12 = v10 & 0x7F;
      }
      if (v12 == a3 && (!a3 || !memcmp(v11, a2, a3))) {
        break;
      }
      unsigned int v13 = (uint64_t *)v8[1];
      if (v13)
      {
        do
        {
          __int16 v14 = v13;
          unsigned int v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          __int16 v14 = (uint64_t *)v8[2];
          BOOL v15 = *v14 == (void)v8;
          int v8 = v14;
        }
        while (!v15);
      }
      int v8 = v14;
      if (v14 == v9) {
        goto LABEL_17;
      }
    }
  }
  return v8 + 8;
}

uint64_t llvm::LLParser::parseTypeIdSummary(uint64_t a1, uint64_t a2)
{
  if (llvm::LLParser::parseToken(a1, 403, "expected 'summary' here")) {
    return 1;
  }
  if (llvm::LLParser::parseToken(a1, 16, "expected ':' here")) {
    return 1;
  }
  if (llvm::LLParser::parseToken(a1, 12, "expected '(' here"))
    return 1;
  if (llvm::LLParser::parseTypeTestResolution(a1, a2)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 224) == 4)
  {
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    if (llvm::LLParser::parseOptionalWpdResolutions(a1, (uint64_t **)(a2 + 40))) {
      return 1;
    }
  }

  return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
}

uint64_t sub_1CD4F0108(int *__src, size_t __n)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  long long v4 = xmmword_1CFAC4320;
  uint64_t v5 = 0;
  llvm::MD5::update((int *)&v4, __src, __n);
  llvm::MD5::final((int *)&v4, v3);
  return *(void *)v3;
}

uint64_t llvm::LLParser::parseTypeTestResolution(uint64_t a1, uint64_t a2)
{
  if ((llvm::LLParser::parseToken(a1, 404, "expected 'typeTestRes' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 405, "expected 'kind' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
  {
    return 1;
  }
  int v5 = *(_DWORD *)(a1 + 224);
  switch(v5)
  {
    case 406:
      int v6 = 0;
      goto LABEL_16;
    case 407:
      int v6 = 1;
      goto LABEL_16;
    case 408:
      int v6 = 2;
      goto LABEL_16;
    case 409:
      int v6 = 3;
      goto LABEL_16;
    case 410:
      int v6 = 4;
      goto LABEL_16;
    default:
      if (v5 != 383)
      {
        unsigned int v9 = *(char **)(a1 + 216);
        char v10 = "unexpected TypeTestResolution kind";
LABEL_37:
        *(void *)unsigned int v11 = v10;
        __int16 v12 = 259;
        return llvm::LLLexer::Error(a1 + 168, v9, (llvm::Twine *)v11);
      }
      int v6 = 5;
LABEL_16:
      *(_DWORD *)a2 = v6;
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if ((llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) != 0
        || (llvm::LLParser::parseToken(a1, 411, "expected 'sizeM1BitWidth' here") & 1) != 0
        || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
        || (llvm::LLParser::parseUInt32((char **)a1, (unsigned int *)(a2 + 4)) & 1) != 0)
      {
        return 1;
      }
      if (*(_DWORD *)(a1 + 224) == 4)
      {
        while (2)
        {
          int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
          *(_DWORD *)(a1 + 224) = v7;
          switch(v7)
          {
            case 412:
              *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
              if (llvm::LLParser::parseToken(a1, 16, "expected ':'")) {
                return 1;
              }
              int v8 = (unint64_t *)(a2 + 8);
              goto LABEL_31;
            case 413:
              *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
              if (llvm::LLParser::parseToken(a1, 16, "expected ':'")) {
                return 1;
              }
              int v8 = (unint64_t *)(a2 + 16);
              goto LABEL_31;
            case 414:
              v11[0] = 0;
              *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
              if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
                || llvm::LLParser::parseUInt32((char **)a1, v11))
              {
                return 1;
              }
              *(unsigned char *)(a2 + 24) = v11[0];
              goto LABEL_32;
            case 415:
              *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
              if (llvm::LLParser::parseToken(a1, 16, "expected ':'")) {
                return 1;
              }
              int v8 = (unint64_t *)(a2 + 32);
LABEL_31:
              if (llvm::LLParser::parseUInt64((char **)a1, v8)) {
                return 1;
              }
LABEL_32:
              if (*(_DWORD *)(a1 + 224) != 4) {
                break;
              }
              continue;
            default:
              unsigned int v9 = *(char **)(a1 + 216);
              char v10 = "expected optional TypeTestResolution field";
              goto LABEL_37;
          }
          break;
        }
      }
      uint64_t result = llvm::LLParser::parseToken(a1, 13, "expected ')' here");
      break;
  }
  return result;
}

uint64_t llvm::LLParser::parseOptionalWpdResolutions(uint64_t a1, uint64_t **a2)
{
  if ((llvm::LLParser::parseToken(a1, 417, "expected 'wpdResolutions' here") & 1) == 0
    && (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) == 0)
  {
    while (1)
    {
      unint64_t v13 = 0;
      int v9 = 0;
      memset(&__p, 0, sizeof(__p));
      v12[0] = 0;
      v12[1] = 0;
      unsigned int v11 = v12;
      int v5 = 0;
      if ((llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) == 0)
      {
        if ((llvm::LLParser::parseToken(a1, 399, "expected 'offset' here") & 1) != 0
          || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
          || (llvm::LLParser::parseUInt64((char **)a1, &v13) & 1) != 0
          || (llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) != 0
          || (llvm::LLParser::parseWpdRes(a1, (uint64_t)&v9) & 1) != 0
          || (llvm::LLParser::parseToken(a1, 13, "expected ')' here") & 1) != 0)
        {
          int v5 = 0;
        }
        else
        {
          __int16 v14 = &v13;
          int v6 = sub_1CD4F4FFC(a2, &v13, (uint64_t)&std::piecewise_construct, &v14);
          *((_DWORD *)v6 + 10) = v9;
          int v7 = (int *)(v6 + 40);
          int v8 = v6;
          std::string::operator=((std::string *)v6 + 2, &__p);
          if (v7 != &v9) {
            sub_1CD4F31B8((uint64_t)(v8 + 72), v11, v12);
          }
          int v5 = 1;
        }
      }
      sub_1CD4AFCAC((uint64_t)&v11, v12[0]);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (!v5) {
        break;
      }
      if (*(_DWORD *)(a1 + 224) != 4) {
        return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
      }
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    }
  }
  return 1;
}

uint64_t llvm::LLParser::parseGVReference(llvm::LLParser *this, llvm::ValueInfo *a2, unsigned int *a3)
{
  int v6 = *((_DWORD *)this + 56);
  BOOL v7 = v6 != 214;
  if (v6 == 235 || v6 == 214) {
    *((_DWORD *)this + 56) = llvm::LLLexer::LexToken((llvm::LLParser *)((char *)this + 168));
  }
  else {
    BOOL v7 = 0;
  }
  uint64_t result = llvm::LLParser::parseToken((uint64_t)this, 436, "expected GV ID");
  if ((result & 1) == 0)
  {
    unint64_t v9 = *((unsigned int *)this + 64);
    *a3 = v9;
    uint64_t v10 = *((void *)this + 151);
    if (v9 >= (*((void *)this + 152) - v10) >> 3) {
      uint64_t v11 = -8;
    }
    else {
      uint64_t v11 = *(void *)(v10 + 8 * v9);
    }
    if (v6 == 214) {
      v11 |= 2uLL;
    }
    *(void *)a2 = v11;
    if (v7) {
      *(void *)a2 = v11 | 4;
    }
  }
  return result;
}

uint64_t llvm::LLParser::parseWpdRes(uint64_t a1, uint64_t a2)
{
  if ((llvm::LLParser::parseToken(a1, 418, "expected 'wpdRes' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 405, "expected 'kind' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
  {
    return 1;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 224) - 419;
  if (v5 >= 3)
  {
    int v8 = *(char **)(a1 + 216);
    unint64_t v9 = "unexpected WholeProgramDevirtResolution kind";
    goto LABEL_20;
  }
  *(_DWORD *)a2 = v5;
  int v6 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  *(_DWORD *)(a1 + 224) = v6;
  if (v6 != 4)
  {
LABEL_16:
    return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
  }
  while (1)
  {
    int v7 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    *(_DWORD *)(a1 + 224) = v7;
    if (v7 == 423)
    {
      if (llvm::LLParser::parseOptionalResByArg(a1, a2 + 32)) {
        return 1;
      }
      goto LABEL_15;
    }
    if (v7 != 422) {
      break;
    }
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
      || (llvm::LLParser::parseStringConstant(a1, (std::string *)(a2 + 8)) & 1) != 0)
    {
      return 1;
    }
LABEL_15:
    if (*(_DWORD *)(a1 + 224) != 4) {
      goto LABEL_16;
    }
  }
  int v8 = *(char **)(a1 + 216);
  unint64_t v9 = "expected optional WholeProgramDevirtResolution field";
LABEL_20:
  uint64_t v10 = v9;
  __int16 v11 = 259;
  return llvm::LLLexer::Error(a1 + 168, v8, (llvm::Twine *)&v10);
}

uint64_t llvm::LLParser::parseOptionalResByArg(uint64_t a1, uint64_t a2)
{
  if ((llvm::LLParser::parseToken(a1, 423, "expected 'resByArg' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
  {
    char v2 = 1;
    return v2 & 1;
  }
  while (2)
  {
    std::string __p = 0;
    signed int v19 = 0;
    uint64_t v20 = 0;
    if ((llvm::LLParser::parseArgs(a1, (uint64_t)&__p) & 1) != 0
      || (llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 424, "expected 'byArg here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 405, "expected 'kind' here") & 1) != 0
      || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0)
    {
LABEL_7:
      int v6 = 1;
      char v2 = 1;
      goto LABEL_8;
    }
    *((void *)&v16 + 1) = 0;
    uint64_t v17 = 0;
    switch(*(_DWORD *)(a1 + 224))
    {
      case 0x1A3:
        LODWORD(v16) = 0;
        goto LABEL_26;
      case 0x1A9:
        int v7 = 1;
        goto LABEL_25;
      case 0x1AA:
        int v7 = 2;
        goto LABEL_25;
      case 0x1AB:
        int v7 = 3;
LABEL_25:
        LODWORD(v16) = v7;
LABEL_26:
        int v8 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        *(_DWORD *)(a1 + 224) = v8;
        if (v8 != 4) {
          goto LABEL_39;
        }
        break;
      default:
        __int16 v12 = *(char **)(a1 + 216);
        unint64_t v13 = "unexpected WholeProgramDevirtResolution::ByArg kind";
        goto LABEL_42;
    }
    do
    {
      int v9 = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      *(_DWORD *)(a1 + 224) = v9;
      if (v9 == 430)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        if (llvm::LLParser::parseToken(a1, 16, "expected ':' here")) {
          goto LABEL_7;
        }
        uint64_t v10 = (unsigned int *)&v17 + 1;
        goto LABEL_37;
      }
      if (v9 == 429)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        if (llvm::LLParser::parseToken(a1, 16, "expected ':' here")) {
          goto LABEL_7;
        }
        uint64_t v10 = (unsigned int *)&v17;
LABEL_37:
        if (llvm::LLParser::parseUInt32((char **)a1, v10)) {
          goto LABEL_7;
        }
        continue;
      }
      if (v9 != 428)
      {
        __int16 v12 = *(char **)(a1 + 216);
        unint64_t v13 = "expected optional whole program devirt field";
LABEL_42:
        v14[0] = (uint64_t)v13;
        __int16 v15 = 259;
        char v2 = llvm::LLLexer::Error(a1 + 168, v12, (llvm::Twine *)v14);
        int v6 = 1;
        goto LABEL_8;
      }
      *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
      if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
        || (llvm::LLParser::parseUInt64((char **)a1, (unint64_t *)&v16 + 1) & 1) != 0)
      {
        goto LABEL_7;
      }
    }
    while (*(_DWORD *)(a1 + 224) == 4);
LABEL_39:
    if (llvm::LLParser::parseToken(a1, 13, "expected ')' here")) {
      goto LABEL_7;
    }
    v14[0] = (uint64_t)&__p;
    __int16 v11 = sub_1CD4F50FC(a2, (unint64_t **)&__p, (uint64_t)&std::piecewise_construct, v14);
    int v6 = 0;
    *(_OWORD *)(v11 + 7) = v16;
    void v11[9] = v17;
LABEL_8:
    if (__p)
    {
      signed int v19 = __p;
      operator delete(__p);
    }
    if (!v6)
    {
      if (*(_DWORD *)(a1 + 224) == 4)
      {
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
        continue;
      }
      char v2 = llvm::LLParser::parseToken(a1, 13, "expected ')' here");
    }
    return v2 & 1;
  }
}

uint64_t llvm::LLParser::parseFunctionSummary(uint64_t a1)
{
  char v2 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  __n128 v21 = 0uLL;
  __int16 v20 = 0;
  unsigned int v19 = 0;
  long long v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  memset(v15, 0, 120);
  memset(v14, 0, sizeof(v14));
  std::string __p = 0;
  __int16 v12 = 0;
  uint64_t v13 = 0;
  int v10 = 0;
  if (llvm::LLParser::parseToken(a1, 16, "expected ':' here"))
  {
    uint64_t v3 = 1;
  }
  else
  {
    if ((llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) == 0)
    {
      llvm::LLParser::parseModuleReference((llvm::LLParser *)a1, &v21);
      if ((v5 & 1) == 0
        && (llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) == 0
        && (llvm::LLParser::parseGVFlags(a1, &v20) & 1) == 0
        && (llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) == 0
        && (llvm::LLParser::parseToken(a1, 366, "expected 'insts' here") & 1) == 0
        && (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) == 0
        && (llvm::LLParser::parseUInt32((char **)a1, &v19) & 1) == 0)
      {
        while (*(_DWORD *)(a1 + 224) == 4)
        {
          int v6 = llvm::LLLexer::LexToken(v2);
          *(_DWORD *)(a1 + 224) = v6;
          if (v6 <= 379)
          {
            if (v6 == 378)
            {
              if (llvm::LLParser::parseOptionalCalls(a1, &v16)) {
                goto LABEL_14;
              }
            }
            else
            {
              if (v6 != 367)
              {
LABEL_36:
                int v7 = *(char **)(a1 + 216);
                v8[0] = (void **)"expected optional function summary field";
                __int16 v9 = 259;
                uint64_t v3 = llvm::LLLexer::Error((uint64_t)v2, v7, (llvm::Twine *)v8);
                goto LABEL_15;
              }
              if (llvm::LLParser::parseOptionalFFlags(a1, &v10)) {
                goto LABEL_14;
              }
            }
          }
          else
          {
            switch(v6)
            {
              case 391:
                if (llvm::LLParser::parseOptionalRefs(a1, (char **)&__p)) {
                  goto LABEL_14;
                }
                break;
              case 380:
                if (llvm::LLParser::parseOptionalParamAccesses((_DWORD *)a1, v14)) {
                  goto LABEL_14;
                }
                break;
              case 392:
                if (llvm::LLParser::parseOptionalTypeIdInfo(a1, v15)) {
                  goto LABEL_14;
                }
                break;
              default:
                goto LABEL_36;
            }
          }
        }
        if ((llvm::LLParser::parseToken(a1, 13, "expected ')' here") & 1) == 0) {
          sub_1CC0C3A60();
        }
      }
    }
LABEL_14:
    uint64_t v3 = 1;
LABEL_15:
    if (__p)
    {
      __int16 v12 = __p;
      operator delete(__p);
    }
  }
  v8[0] = (void **)v14;
  sub_1CC0C4A94(v8);
  sub_1CD4AEFB0((uint64_t)v15);
  if (v16)
  {
    uint64_t v17 = v16;
    operator delete(v16);
  }
  return v3;
}

__n128 llvm::LLParser::parseModuleReference(llvm::LLParser *this, __n128 *a2)
{
  if ((llvm::LLParser::parseToken((uint64_t)this, 96, "expected 'module' here") & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 436, "expected module ID") & 1) == 0)
  {
    char v5 = (char *)*((void *)this + 158);
    if (!v5) {
      goto LABEL_16;
    }
    unsigned int v6 = *((_DWORD *)this + 64);
    int v7 = (char *)this + 1264;
    do
    {
      unsigned int v8 = *((_DWORD *)v5 + 8);
      BOOL v9 = v8 >= v6;
      if (v8 >= v6) {
        int v10 = (char **)v5;
      }
      else {
        int v10 = (char **)(v5 + 8);
      }
      if (v9) {
        int v7 = v5;
      }
      char v5 = *v10;
    }
    while (*v10);
    if (v7 == (char *)this + 1264 || v6 < *((_DWORD *)v7 + 8)) {
LABEL_16:
    }
      int v7 = (char *)this + 1264;
    __n128 result = *(__n128 *)(v7 + 40);
    *a2 = result;
  }
  return result;
}

uint64_t llvm::LLParser::parseGVFlags(uint64_t a1, _WORD *a2)
{
  long long v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if (llvm::LLParser::parseToken(a1, 16, "expected ':' here")) {
    return 1;
  }
  uint64_t v5 = 1;
  if (llvm::LLParser::parseToken(a1, 12, "expected '(' here")) {
    return v5;
  }
  int v7 = *(_DWORD *)(a1 + 224);
  while (2)
  {
    unsigned int v16 = 0;
    switch(v7)
    {
      case 359:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if (llvm::LLParser::parseToken(a1, 16, "expected ':'")) {
          return 1;
        }
        *a2 = *a2 & 0xFFF0 | sub_1CC197270(*(_DWORD *)(a1 + 224), &v15);
        int v8 = llvm::LLLexer::LexToken(v4);
        *(_DWORD *)(a1 + 224) = v8;
        goto LABEL_26;
      case 360:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if (llvm::LLParser::parseToken(a1, 16, "expected ':'")) {
          return 1;
        }
        int v9 = *(_DWORD *)(a1 + 224);
        switch(v9)
        {
          case '&':
            unsigned int v11 = 0;
            unsigned int v16 = 0;
LABEL_36:
            *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
            goto LABEL_24;
          case '\'':
            unsigned int v16 = 1;
            unsigned int v11 = 16;
            goto LABEL_36;
          case '(':
            unsigned int v16 = 2;
            unsigned int v11 = 32;
            goto LABEL_36;
        }
        unsigned int v11 = 0;
        unsigned int v16 = 0;
LABEL_24:
        int v10 = *a2 & 0xFFCF | (16 * ((v11 >> 4) & 3));
LABEL_25:
        *a2 = v10;
        int v8 = *(_DWORD *)(a1 + 224);
LABEL_26:
        if (v8 == 4)
        {
          int v7 = llvm::LLLexer::LexToken(v4);
          *(_DWORD *)(a1 + 224) = v7;
          continue;
        }
        return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
      case 361:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFFBF | ((v16 & 1) << 6);
        goto LABEL_25;
      case 362:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFF7F | ((v16 & 1) << 7);
        goto LABEL_25;
      case 363:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFEFF | ((v16 & 1) << 8);
        goto LABEL_25;
      case 364:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v16) & 1) != 0)
        {
          return 1;
        }
        LOWORD(v10) = *a2 & 0xFDFF | ((v16 & 1) << 9);
        goto LABEL_25;
      default:
        __int16 v12 = *(char **)(a1 + 216);
        uint64_t v13 = "expected gv flag type";
        __int16 v14 = 259;
        return llvm::LLLexer::Error((uint64_t)v4, v12, (llvm::Twine *)&v13);
    }
  }
}

uint64_t llvm::LLParser::parseOptionalFFlags(uint64_t a1, _WORD *a2)
{
  long long v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' in funcFlags") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' in funcFlags") & 1) != 0)
  {
    return 1;
  }
  int v6 = *(_DWORD *)(a1 + 224);
  while (2)
  {
    unsigned int v11 = 0;
    switch(v6)
    {
      case 368:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFFE | v11 & 1;
        goto LABEL_9;
      case 369:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFFD | (2 * (v11 & 1));
        goto LABEL_9;
      case 370:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFFB | (4 * (v11 & 1));
        goto LABEL_9;
      case 371:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFF7 | (8 * (v11 & 1));
        goto LABEL_9;
      case 372:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFEF | (16 * (v11 & 1));
        goto LABEL_9;
      case 373:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFDF | (32 * (v11 & 1));
        goto LABEL_9;
      case 374:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFFBF | ((v11 & 1) << 6);
        goto LABEL_9;
      case 375:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFF7F | ((v11 & 1) << 7);
        goto LABEL_9;
      case 376:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFEFF | ((v11 & 1) << 8);
        goto LABEL_9;
      case 377:
        *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v4);
        if ((llvm::LLParser::parseToken(a1, 16, "expected ':'") & 1) != 0
          || (llvm::LLParser::parseFlag((llvm::LLParser *)a1, &v11) & 1) != 0)
        {
          return 1;
        }
        __int16 v7 = *a2 & 0xFDFF | ((v11 & 1) << 9);
LABEL_9:
        *a2 = v7;
        if (*(_DWORD *)(a1 + 224) == 4)
        {
          int v6 = llvm::LLLexer::LexToken(v4);
          *(_DWORD *)(a1 + 224) = v6;
          continue;
        }
        return llvm::LLParser::parseToken(a1, 13, "expected ')' in funcFlags");
      default:
        int v8 = *(char **)(a1 + 216);
        int v9 = "expected function flag type";
        __int16 v10 = 259;
        return llvm::LLLexer::Error((uint64_t)v4, v8, (llvm::Twine *)&v9);
    }
  }
}

uint64_t llvm::LLParser::parseOptionalTypeIdInfo(uint64_t a1, unint64_t **a2)
{
  long long v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' in typeIdInfo") & 1) != 0)
  {
    return 1;
  }
  int v7 = *(_DWORD *)(a1 + 224);
  while (2)
  {
    switch(v7)
    {
      case 393:
        if (llvm::LLParser::parseTypeTests(a1, a2)) {
          return 1;
        }
        goto LABEL_16;
      case 394:
        uint64_t v8 = a1;
        int v9 = a2 + 3;
        goto LABEL_11;
      case 395:
        uint64_t v8 = a1;
        int v9 = a2 + 6;
LABEL_11:
        if (llvm::LLParser::parseVFuncIdList(v8, v6, v9)) {
          return 1;
        }
        goto LABEL_16;
      case 396:
        uint64_t v10 = a1;
        unsigned int v11 = (uint64_t *)(a2 + 9);
        goto LABEL_15;
      case 397:
        uint64_t v10 = a1;
        unsigned int v11 = (uint64_t *)(a2 + 12);
LABEL_15:
        if (llvm::LLParser::parseConstVCallList(v10, v6, v11)) {
          return 1;
        }
LABEL_16:
        if (*(_DWORD *)(a1 + 224) == 4)
        {
          int v7 = llvm::LLLexer::LexToken(v4);
          *(_DWORD *)(a1 + 224) = v7;
          continue;
        }
        return llvm::LLParser::parseToken(a1, 13, "expected ')' in typeIdInfo");
      default:
        __int16 v12 = *(char **)(a1 + 216);
        uint64_t v13 = "invalid typeIdInfo list type";
        __int16 v14 = 259;
        return llvm::LLLexer::Error((uint64_t)v4, v12, (llvm::Twine *)&v13);
    }
  }
}

uint64_t llvm::LLParser::parseOptionalParamAccesses(_DWORD *a1, uint64_t *a2)
{
  long long v4 = (llvm::LLLexer *)(a1 + 42);
  a1[56] = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 42));
  if ((llvm::LLParser::parseToken((uint64_t)a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)a1, 12, "expected '(' here") & 1) != 0)
  {
    return 1;
  }
  memset(__p, 0, sizeof(__p));
  int v20 = 64;
  long long v19 = xmmword_1CD91C150;
  int v22 = 64;
  uint64_t v21 = -1;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  for (uint64_t i = 0; ; uint64_t i = 0)
  {
    if (llvm::LLParser::parseParamAccess(a1, (unint64_t *)&v19, (uint64_t)__p))
    {
      p_uint64_t i = (void **)&i;
      sub_1CC0C49BC(&p_i);
      sub_1CC05EB8C((uint64_t)&v19 + 8);
LABEL_10:
      uint64_t v5 = 1;
      goto LABEL_11;
    }
    sub_1CD4F2408(a2, (uint64_t)&v19);
    p_uint64_t i = (void **)&i;
    sub_1CC0C49BC(&p_i);
    sub_1CC05EB8C((uint64_t)&v19 + 8);
    if (a1[56] != 4) {
      break;
    }
    a1[56] = llvm::LLLexer::LexToken(v4);
    int v20 = 64;
    long long v19 = xmmword_1CD91C150;
    int v22 = 64;
    uint64_t v21 = -1;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
  }
  if (llvm::LLParser::parseToken((uint64_t)a1, 13, "expected ')' here")) {
    goto LABEL_10;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (*a2 == v8)
  {
    uint64_t v5 = 0;
  }
  else
  {
    int v9 = (char *)__p[0];
    uint64_t v10 = (uint64_t **)(a1 + 290);
    do
    {
      unsigned int v11 = *(void **)(v7 + 40);
      __int16 v12 = *(void **)(v7 + 48);
      if (v11 != v12)
      {
        uint64_t v13 = v11 + 1;
        do
        {
          if ((~*v13 & 0xFFFFFFFFFFFFFFF8) == 0)
          {
            char v15 = sub_1CD4F4F28(v10, *(_DWORD *)v9, v9);
            unsigned int v16 = v15;
            uint64_t v17 = v15[6];
            if (v17 >= v15[7])
            {
              uint64_t v18 = sub_1CC1A08EC((char **)v15 + 5, (uint64_t)v13, *((void *)v9 + 1));
            }
            else
            {
              uint64_t *v17 = (uint64_t)v13;
              v17[1] = *((void *)v9 + 1);
              uint64_t v18 = (char *)(v17 + 2);
            }
            v16[6] = (uint64_t *)v18;
          }
          v9 += 16;
          __int16 v14 = v13 + 5;
          v13 += 6;
        }
        while (v14 != v12);
      }
      uint64_t v5 = 0;
      v7 += 64;
    }
    while (v7 != v8);
  }
LABEL_11:
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v5;
}

uint64_t llvm::LLParser::parseGVarFlags(uint64_t a1, unsigned char *a2)
{
  long long v4 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
  {
    return 1;
  }
  for (int i = *(_DWORD *)(a1 + 224); ; *(_DWORD *)(a1 + 224) = i)
  {
    unsigned int v11 = 0;
    if (i > 234)
    {
      if (i == 235)
      {
        if (sub_1CC19DD44((_DWORD *)a1, &v11)) {
          return 1;
        }
        char v7 = *a2 & 0xFD | (2 * (v11 & 1));
      }
      else
      {
        if (i != 416)
        {
LABEL_24:
          uint64_t v8 = *(char **)(a1 + 216);
          int v9 = "expected gvar flag type";
          __int16 v10 = 259;
          return llvm::LLLexer::Error((uint64_t)v4, v8, (llvm::Twine *)&v9);
        }
        if (sub_1CC19DD44((_DWORD *)a1, &v11)) {
          return 1;
        }
        char v7 = *a2 & 0xE7 | (8 * (v11 & 3));
      }
    }
    else if (i == 24)
    {
      if (sub_1CC19DD44((_DWORD *)a1, &v11)) {
        return 1;
      }
      char v7 = *a2 & 0xFB | (4 * (v11 & 1));
    }
    else
    {
      if (i != 214) {
        goto LABEL_24;
      }
      if (sub_1CC19DD44((_DWORD *)a1, &v11)) {
        return 1;
      }
      char v7 = *a2 & 0xFE | v11 & 1;
    }
    *a2 = v7;
    if (*(_DWORD *)(a1 + 224) != 4) {
      break;
    }
    int i = llvm::LLLexer::LexToken(v4);
  }

  return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
}

uint64_t sub_1CD4F1D80(int a1, uint64_t a2, void *__s2, size_t __n)
{
  long long v4 = *(uint64_t **)((a2 & 0xFFFFFFFFFFFFFFF8) + 24);
  uint64_t v5 = *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 32) - (void)v4;
  if (!v5) {
    return 0;
  }
  uint64_t v8 = 8 * (v5 >> 3);
  while (1)
  {
    uint64_t v9 = *v4;
    if (*(void *)(*v4 + 32) == __n && (!__n || !memcmp(*(const void **)(v9 + 24), __s2, __n))) {
      break;
    }
    ++v4;
    v8 -= 8;
    if (!v8) {
      return 0;
    }
  }
  return v9;
}

uint64_t llvm::LLParser::parseFlag(llvm::LLParser *this, unsigned int *a2)
{
  uint64_t v3 = (llvm::LLParser *)((char *)this + 168);
  if (*((_DWORD *)this + 56) == 457 && *((unsigned char *)this + 316))
  {
    uint64_t v5 = (llvm::LLParser *)((char *)this + 304);
    unsigned int v6 = *((_DWORD *)this + 78);
    if (v6 > 0x40) {
      BOOL v7 = llvm::APInt::countLeadingZerosSlowCase(v5) == v6;
    }
    else {
      BOOL v7 = *(void *)v5 == 0;
    }
    int v8 = v7;
    *a2 = v8 ^ 1;
    int v9 = llvm::LLLexer::LexToken(v3);
    uint64_t result = 0;
    *((_DWORD *)this + 56) = v9;
  }
  else
  {
    unsigned int v11 = "expected integer";
    __int16 v12 = 259;
    return llvm::LLLexer::Error((uint64_t)this + 168, *((char **)this + 27), (llvm::Twine *)&v11);
  }
  return result;
}

uint64_t llvm::LLParser::parseHotness(uint64_t a1, char *a2)
{
  uint64_t v3 = (llvm::LLLexer *)(a1 + 168);
  int v4 = *(_DWORD *)(a1 + 224);
  if (v4 <= 382)
  {
    if (v4 == 54)
    {
      char v5 = 2;
      goto LABEL_12;
    }
    if (v4 == 173)
    {
      char v5 = 1;
      goto LABEL_12;
    }
LABEL_14:
    int v8 = *(char **)(a1 + 216);
    int v9 = "invalid call edge hotness";
    __int16 v10 = 259;
    return llvm::LLLexer::Error((uint64_t)v3, v8, (llvm::Twine *)&v9);
  }
  if (v4 == 383)
  {
    char v5 = 0;
    goto LABEL_12;
  }
  if (v4 == 384)
  {
    char v5 = 3;
    goto LABEL_12;
  }
  if (v4 != 385) {
    goto LABEL_14;
  }
  char v5 = 4;
LABEL_12:
  *a2 = v5;
  int v6 = llvm::LLLexer::LexToken(v3);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 224) = v6;
  return result;
}

uint64_t llvm::LLParser::parseParamNo(char **this, unint64_t *a2)
{
  if ((llvm::LLParser::parseToken((uint64_t)this, 381, "expected 'param' here") & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) != 0)
  {
    return 1;
  }

  return llvm::LLParser::parseUInt64(this, a2);
}

uint64_t llvm::LLParser::parseParamAccessOffset(llvm::LLParser *this, llvm::ConstantRange *a2)
{
  uint64_t v4 = 1;
  unsigned int v19 = 1;
  uint64_t v18 = 0;
  char v20 = 0;
  unsigned int v16 = 1;
  __src = 0;
  char v17 = 0;
  if (llvm::LLParser::parseToken((uint64_t)this, 399, "expected 'offset' here")) {
    goto LABEL_2;
  }
  if ((llvm::LLParser::parseToken((uint64_t)this, 16, "expected ':' here") & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 6, "expected '[' here") & 1) == 0
    && (sub_1CC19CB54((uint64_t)this, &v18) & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 4, "expected ',' here") & 1) == 0
    && (sub_1CC19CB54((uint64_t)this, &__src) & 1) == 0
    && (llvm::LLParser::parseToken((uint64_t)this, 7, "expected ']' here") & 1) == 0)
  {
    llvm::APInt::operator++((uint64_t)&__src);
    unsigned int v6 = v19;
    if (v19 > 0x40)
    {
      if (!llvm::APInt::equalSlowCase((const void **)&v18, (const void **)&__src)
        || llvm::APInt::countTrailingOnesSlowCase((llvm::APInt *)&v18) == v6)
      {
        unsigned int v10 = v6;
        operator new[]();
      }
    }
    else if (!v19 || v18 != __src || v18 == (void *)(0xFFFFFFFFFFFFFFFFLL >> -(char)v19))
    {
      unsigned int v10 = v19;
      int v9 = v18;
      unsigned int v8 = v16;
      if (v16 > 0x40) {
        operator new[]();
      }
      BOOL v7 = __src;
      llvm::ConstantRange::ConstantRange((uint64_t)&v11, (uint64_t)&v9, (uint64_t)&v7);
      sub_1CC149928((uint64_t)a2, (uint64_t)&v11);
      sub_1CC05EB8C((uint64_t)&v11);
      if (v8 >= 0x41 && v7) {
        MEMORY[0x1D25D9CB0](v7, 0x1000C8000313F17);
      }
      if (v10 >= 0x41 && v9) {
        MEMORY[0x1D25D9CB0](v9, 0x1000C8000313F17);
      }
      goto LABEL_33;
    }
    int v12 = 64;
    uint64_t v11 = 0;
    int v14 = 64;
    uint64_t v13 = 0;
    sub_1CC149928((uint64_t)a2, (uint64_t)&v11);
    sub_1CC05EB8C((uint64_t)&v11);
LABEL_33:
    uint64_t v4 = 0;
  }
  if (v16 >= 0x41 && __src) {
    MEMORY[0x1D25D9CB0](__src, 0x1000C8000313F17);
  }
LABEL_2:
  if (v19 >= 0x41 && v18) {
    MEMORY[0x1D25D9CB0](v18, 0x1000C8000313F17);
  }
  return v4;
}

uint64_t llvm::LLParser::parseParamAccessCall(llvm::LLParser *a1, unint64_t *a2, uint64_t a3)
{
  if (llvm::LLParser::parseToken((uint64_t)a1, 12, "expected '(' here"))
    return 1;
  if (llvm::LLParser::parseToken((uint64_t)a1, 379, "expected 'callee' here")) {
    return 1;
  }
  if (llvm::LLParser::parseToken((uint64_t)a1, 16, "expected ':' here")) {
    return 1;
  }
  unsigned int v11 = 0;
  unint64_t v10 = 0;
  uint64_t v7 = *((void *)a1 + 27);
  if (llvm::LLParser::parseGVReference(a1, (llvm::ValueInfo *)&v10, &v11)) {
    return 1;
  }
  a2[1] = v10;
  unint64_t v8 = *(void *)(a3 + 8);
  if (v8 >= *(void *)(a3 + 16))
  {
    int v9 = sub_1CC1A06D8((char **)a3, v11, v7);
  }
  else
  {
    *(_DWORD *)unint64_t v8 = v11;
    *(void *)(v8 + 8) = v7;
    int v9 = (char *)(v8 + 16);
  }
  *(void *)(a3 + 8) = v9;
  if ((llvm::LLParser::parseToken((uint64_t)a1, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseParamNo((char **)a1, a2) & 1) != 0
    || (llvm::LLParser::parseToken((uint64_t)a1, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseParamAccessOffset(a1, (llvm::ConstantRange *)(a2 + 2)) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return llvm::LLParser::parseToken((uint64_t)a1, 13, "expected ')' here");
  }
}

uint64_t sub_1CD4F2408(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  if (v3 >= a1[2])
  {
    uint64_t result = sub_1CC1A07C8(a1, a2);
  }
  else
  {
    *(void *)unint64_t v3 = *(void *)a2;
    *(_DWORD *)(v3 + 16) = *(_DWORD *)(a2 + 16);
    *(void *)(v3 + 8) = *(void *)(a2 + 8);
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(v3 + 32) = *(_DWORD *)(a2 + 32);
    *(void *)(v3 + 24) = *(void *)(a2 + 24);
    *(_DWORD *)(a2 + 32) = 0;
    *(void *)(v3 + 40) = 0;
    *(void *)(v3 + 48) = 0;
    *(void *)(v3 + 56) = 0;
    *(_OWORD *)(v3 + 40) = *(_OWORD *)(a2 + 40);
    *(void *)(v3 + 56) = *(void *)(a2 + 56);
    uint64_t result = v3 + 64;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
    *(void *)(a2 + 56) = 0;
  }
  a1[1] = result;
  return result;
}

uint64_t llvm::LLParser::parseVFuncId(uint64_t a1, unint64_t *a2, uint64_t **a3, unsigned int a4)
{
  unint64_t v8 = (llvm::LLLexer *)(a1 + 168);
  *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
  if ((llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 12, "expected '(' here") & 1) != 0)
  {
    return 1;
  }
  if (*(_DWORD *)(a1 + 224) == 436)
  {
    *a2 = 0;
    unsigned int v16 = *(_DWORD *)(a1 + 256);
    uint64_t v10 = *(void *)(a1 + 216);
    unsigned int v11 = sub_1CD4F4F28(a3, v16, &v16);
    int v12 = v11;
    *(void *)&long long v15 = a4;
    *((void *)&v15 + 1) = v10;
    uint64_t v13 = v11[6];
    if (v13 >= v11[7])
    {
      int v14 = (uint64_t *)sub_1CC00319C((void **)v11 + 5, &v15);
    }
    else
    {
      *(_OWORD *)uint64_t v13 = v15;
      int v14 = v13 + 2;
    }
    v12[6] = v14;
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken(v8);
  }
  else if ((llvm::LLParser::parseToken(a1, 354, "expected 'guid' here") & 1) != 0 {
         || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
  }
         || (llvm::LLParser::parseUInt64((char **)a1, a2) & 1) != 0)
  {
    return 1;
  }
  if ((llvm::LLParser::parseToken(a1, 4, "expected ',' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 399, "expected 'offset' here") & 1) != 0
    || (llvm::LLParser::parseToken(a1, 16, "expected ':' here") & 1) != 0
    || (llvm::LLParser::parseUInt64((char **)a1, a2 + 1) & 1) != 0)
  {
    return 1;
  }

  return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
}

uint64_t llvm::LLParser::parseConstVCall(uint64_t a1, unint64_t *a2, uint64_t **a3, unsigned int a4)
{
  if (llvm::LLParser::parseToken(a1, 12, "expected '(' here"))
    return 1;
  if (llvm::LLParser::parseVFuncId(a1, a2, a3, a4)) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 224) == 4)
  {
    *(_DWORD *)(a1 + 224) = llvm::LLLexer::LexToken((llvm::LLLexer *)(a1 + 168));
    if (llvm::LLParser::parseArgs(a1, (uint64_t)(a2 + 2))) {
      return 1;
    }
  }

  return llvm::LLParser::parseToken(a1, 13, "expected ')' here");
}

uint64_t sub_1CD4F271C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0;
  if (v2) {
    MEMORY[0x1D25D9CB0](v2, 0x20C8093837F09);
  }
  sub_1CB87DEE4((uint64_t *)(a1 + 104));
  if (*(_DWORD *)(a1 + 88) >= 0x41u)
  {
    uint64_t v3 = *(void *)(a1 + 80);
    if (v3) {
      MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
    }
  }
  if (*(char *)(a1 + 79) < 0) {
    operator delete(*(void **)(a1 + 56));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

uint64_t sub_1CD4F27B0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v4 = a1 + 32;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_1CB8BDF7C(v4, *(const void **)(a2 + 32), *(void *)(a2 + 40));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    *(void *)(v4 + 16) = *(void *)(a2 + 48);
    *(_OWORD *)uint64_t v4 = v5;
  }
  unsigned int v6 = (_OWORD *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v6, *(const void **)(a2 + 56), *(void *)(a2 + 64));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *unsigned int v6 = v7;
  }
  unint64_t v8 = (llvm::APInt *)(a1 + 80);
  int v9 = (const llvm::APInt *)(a2 + 80);
  unsigned int v10 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a1 + 88) = v10;
  if (v10 > 0x40) {
    llvm::APInt::initSlowCase(v8, v9);
  }
  *(void *)unint64_t v8 = *(void *)v9;
  *(unsigned char *)(a1 + 92) = *(unsigned char *)(a2 + 92);
  sub_1CB87DDC4(a1 + 104, (uint64_t *)(a2 + 104));
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(void *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a2 + 144);
  return a1;
}

uint64_t *sub_1CD4F289C(uint64_t a1, unsigned __int8 *a2, size_t a3, _OWORD *a4)
{
  uint64_t v8 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  int i = (uint64_t *)(*(void *)a1 + 8 * v8);
  uint64_t v10 = *i;
  if (*i == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v10)
  {
    while (!v10 || v10 == -8)
    {
      uint64_t v11 = i[1];
      ++i;
      uint64_t v10 = v11;
    }
    return i;
  }
  int v12 = (char *)operator new(a3 + 41, (std::align_val_t)8uLL);
  uint64_t v13 = v12;
  int v14 = v12 + 40;
  if (a3) {
    memcpy(v12 + 40, a2, a3);
  }
  v14[a3] = 0;
  *(void *)uint64_t v13 = a3;
  long long v15 = a4[1];
  *(_OWORD *)(v13 + 8) = *a4;
  *(_OWORD *)(v13 + 24) = v15;
  *int i = (uint64_t)v13;
  ++*(_DWORD *)(a1 + 12);
  for (int i = (uint64_t *)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v8));
        !*i || *i == -8;
  return i;
}

void *sub_1CD4F29A8(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unint64_t v4 = *a2;
  while (1)
  {
    unint64_t v5 = v3[4];
    if (v4 >= v5) {
      break;
    }
    uint64_t v2 = v3;
LABEL_7:
    uint64_t v3 = (void *)*v3;
    if (!v3) {
      return v2;
    }
  }
  if (v5 < v4)
  {
    ++v3;
    goto LABEL_7;
  }
  long long v7 = (void *)*v3;
  uint64_t result = v3;
  if (*v3)
  {
    uint64_t result = v3;
    do
    {
      unint64_t v8 = v7[4];
      BOOL v9 = v8 >= v4;
      if (v8 >= v4) {
        uint64_t v10 = v7;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      if (v9) {
        uint64_t result = v7;
      }
      long long v7 = (void *)*v10;
    }
    while (*v10);
  }
  uint64_t v11 = (void *)v3[1];
  if (v11)
  {
    do
    {
      if (v4 >= v11[4]) {
        int v12 = v11 + 1;
      }
      else {
        int v12 = v11;
      }
      uint64_t v11 = (void *)*v12;
    }
    while (*v12);
  }
  return result;
}

uint64_t *sub_1CD4F2A40(uint64_t a1, uint64_t a2)
{
  sub_1CD4F2AF0(a1, a2, (uint64_t)&v9);
  uint64_t v3 = v9;
  unint64_t v4 = (uint64_t **)(a1 + 8);
  unint64_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    do
    {
      while (1)
      {
        unint64_t v4 = (uint64_t **)v5;
        if (v9[4] >= (unint64_t)v5[4]) {
          break;
        }
        unint64_t v5 = (uint64_t *)*v5;
        unsigned int v6 = v4;
        if (!*v4) {
          goto LABEL_8;
        }
      }
      unint64_t v5 = (uint64_t *)v5[1];
    }
    while (v5);
    unsigned int v6 = v4 + 1;
  }
  else
  {
    unsigned int v6 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  *BOOL v9 = 0;
  v3[1] = 0;
  void v3[2] = (uint64_t)v4;
  *unsigned int v6 = v3;
  uint64_t v7 = **(void **)a1;
  if (v7)
  {
    *(void *)a1 = v7;
    uint64_t v3 = *v6;
  }
  sub_1CB8358B8(*(uint64_t **)(a1 + 8), v3);
  ++*(void *)(a1 + 16);
  return v9;
}

char *sub_1CD4F2AF0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t result = (char *)operator new(0x80uLL);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  *((void *)result + 4) = *(void *)a2;
  *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 8);
  *((void *)result + 7) = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  long long v7 = *(_OWORD *)(a2 + 48);
  *((_OWORD *)result + 4) = *(_OWORD *)(a2 + 32);
  *((_OWORD *)result + 5) = v7;
  uint64_t v8 = *(void *)(a2 + 72);
  BOOL v9 = (void *)(a2 + 80);
  uint64_t v10 = *(void *)(a2 + 80);
  *((void *)result + 12) = *(void *)(a2 + 64);
  *((void *)result + 13) = v8;
  *((void *)result + 14) = v10;
  uint64_t v11 = result + 112;
  uint64_t v12 = *(void *)(a2 + 88);
  *((void *)result + 15) = v12;
  if (v12)
  {
    *(void *)(v10 + 16) = v11;
    *(void *)(a2 + 72) = v9;
    *BOOL v9 = 0;
    *(void *)(a2 + 88) = 0;
  }
  else
  {
    *((void *)result + 13) = v11;
  }
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void *sub_1CD4F2B94(void **a1, void *a2, unint64_t *a3, void *a4)
{
  unsigned int v6 = (void **)sub_1CD4F2C50(a1, a2, &v14, &v13, a3);
  long long v7 = *v6;
  if (!*v6)
  {
    BOOL v9 = v6;
    long long v7 = operator new(0x60uLL);
    _OWORD v7[4] = *a4;
    sub_1CD4F2DE8((_DWORD *)v7 + 10, (uint64_t)(a4 + 1));
    uint64_t v10 = v14;
    *long long v7 = 0;
    v7[1] = 0;
    void v7[2] = v10;
    *BOOL v9 = v7;
    uint64_t v11 = (void *)**a1;
    uint64_t v12 = v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1CD4F2C50(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
    }
    else
    {
      if (v8)
      {
        BOOL v9 = (void *)*a2;
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = (void *)v9[1];
        }
        while (v9);
      }
      else
      {
        uint64_t v14 = a2;
        do
        {
          uint64_t v10 = (void *)v14[2];
          BOOL v15 = *v10 == (void)v14;
          uint64_t v14 = v10;
        }
        while (v15);
      }
      unint64_t v16 = *a5;
      if (v10[4] >= *a5)
      {
        char v17 = (void *)*v5;
        if (*v5)
        {
          do
          {
            while (1)
            {
              a4 = v17;
              unint64_t v18 = v17[4];
              if (v16 >= v18) {
                break;
              }
              char v17 = (void *)*a4;
              uint64_t v5 = a4;
              if (!*a4) {
                goto LABEL_36;
              }
            }
            if (v18 >= v16) {
              break;
            }
            uint64_t v5 = a4 + 1;
            char v17 = (void *)a4[1];
          }
          while (v17);
LABEL_27:
          *a3 = a4;
          return v5;
        }
        goto LABEL_44;
      }
    }
    if (v8)
    {
      *a3 = v10;
      return v10 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  else
  {
    if (v7 >= v6)
    {
      *a3 = a2;
      *a4 = a2;
      return a4;
    }
    uint64_t v11 = a2[1];
    if (v11)
    {
      uint64_t v12 = (void *)a2[1];
      do
      {
        a4 = v12;
        uint64_t v12 = (void *)*v12;
      }
      while (v12);
    }
    else
    {
      unsigned int v19 = a2;
      do
      {
        a4 = (void *)v19[2];
        BOOL v15 = *a4 == (void)v19;
        unsigned int v19 = a4;
      }
      while (!v15);
    }
    if (a4 != v5 && v6 >= a4[4])
    {
      char v20 = (void *)*v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            a4 = v20;
            unint64_t v21 = v20[4];
            if (v6 >= v21) {
              break;
            }
            char v20 = (void *)*a4;
            uint64_t v5 = a4;
            if (!*a4) {
              goto LABEL_36;
            }
          }
          if (v21 >= v6) {
            break;
          }
          uint64_t v5 = a4 + 1;
          char v20 = (void *)a4[1];
        }
        while (v20);
        goto LABEL_27;
      }
LABEL_44:
      *a3 = v5;
      return v5;
    }
    if (v11)
    {
LABEL_36:
      *a3 = a4;
    }
    else
    {
      *a3 = a2;
      return a2 + 1;
    }
  }
  return a4;
}

_DWORD *sub_1CD4F2DE8(_DWORD *a1, uint64_t a2)
{
  *a1 = *(_DWORD *)a2;
  uint64_t v4 = (uint64_t)(a1 + 2);
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1CB8BDF7C(v4, *(const void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 8);
    *(void *)(v4 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }
  sub_1CC19DFD0((uint64_t)(a1 + 8), (void *)(a2 + 32));
  return a1;
}

char *sub_1CD4F2E4C(void **a1, void *a2, unint64_t **a3, uint64_t a4)
{
  unint64_t v6 = (void **)sub_1CD4F2F1C(a1, a2, &v14, &v13, a3);
  unint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    BOOL v9 = v6;
    unint64_t v7 = (char *)operator new(0x50uLL);
    *((void *)v7 + 5) = 0;
    *((void *)v7 + 6) = 0;
    *((void *)v7 + 4) = 0;
    sub_1CBFCBA2C((void *)v7 + 4, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
    *(_OWORD *)(v7 + 56) = *(_OWORD *)(a4 + 24);
    *((void *)v7 + 9) = *(void *)(a4 + 40);
    uint64_t v10 = v14;
    *(void *)unint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v10;
    *BOOL v9 = v7;
    uint64_t v11 = (void *)**a1;
    uint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = (uint64_t *)*v9;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (void *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1CD4F2F1C(void *a1, void *a2, void *a3, void *a4, unint64_t **a5)
{
  if (a1 + 1 != a2)
  {
    long long v5 = *a5;
    unint64_t v6 = a5[1];
    unint64_t v7 = (unint64_t *)a2[4];
    uint64_t v8 = (unint64_t *)a2[5];
    if (v7 == v8)
    {
LABEL_11:
      if (v5 == v6)
      {
LABEL_20:
        *a3 = a2;
        *a4 = a2;
      }
      else
      {
        uint64_t v14 = v5 + 1;
        while (v7 != v8)
        {
          unint64_t v15 = *v7;
          unint64_t v16 = *(v14 - 1);
          if (*v7 < v16) {
            break;
          }
          ++v7;
          if (v16 < v15 || v14++ == v6) {
            goto LABEL_20;
          }
        }
        uint64_t v22 = a2[1];
        if (v22)
        {
          long long v23 = (void *)a2[1];
          do
          {
            a4 = v23;
            long long v23 = (void *)*v23;
          }
          while (v23);
        }
        else
        {
          std::string v31 = a2;
          do
          {
            a4 = (void *)v31[2];
            BOOL v13 = *a4 == (void)v31;
            std::string v31 = a4;
          }
          while (!v13);
        }
        if (a4 != a1 + 1)
        {
          uint64_t v33 = a4[4];
          uint64_t v32 = a4[5];
          if (v33 == v32) {
            return sub_1CD4F30F8((uint64_t)a1, a3, a5);
          }
          uint64_t v34 = v33 + 8;
          while (v5 != v6)
          {
            unint64_t v35 = *v5;
            unint64_t v36 = *(void *)(v34 - 8);
            if (*v5 < v36) {
              break;
            }
            ++v5;
            BOOL v37 = v36 < v35 || v34 == v32;
            v34 += 8;
            if (v37) {
              return sub_1CD4F30F8((uint64_t)a1, a3, a5);
            }
          }
        }
        if (v22)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
      }
      return a4;
    }
    BOOL v9 = v7 + 1;
    uint64_t v10 = *a5;
    while (v10 != v6)
    {
      unint64_t v11 = *v10;
      unint64_t v12 = *(v9 - 1);
      if (*v10 < v12) {
        break;
      }
      ++v10;
      BOOL v13 = v12 < v11 || v9++ == v8;
      if (v13) {
        goto LABEL_11;
      }
    }
  }
  uint64_t v18 = *a2;
  if ((void *)*a1 == a2)
  {
    char v20 = a2;
LABEL_27:
    if (v18)
    {
      *a3 = v20;
      return v20 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  if (v18)
  {
    unsigned int v19 = (void *)*a2;
    do
    {
      char v20 = v19;
      unsigned int v19 = (void *)v19[1];
    }
    while (v19);
  }
  else
  {
    uint64_t v24 = a2;
    do
    {
      char v20 = (void *)v24[2];
      BOOL v13 = *v20 == (void)v24;
      uint64_t v24 = v20;
    }
    while (v13);
  }
  uint64_t v25 = a5[1];
  if (*a5 != v25)
  {
    uint64_t v26 = (unint64_t *)v20[4];
    uint64_t v27 = (uint64_t)(*a5 + 1);
    while (v26 != (unint64_t *)v20[5])
    {
      unint64_t v28 = *v26;
      unint64_t v29 = *(void *)(v27 - 8);
      if (*v26 < v29) {
        break;
      }
      ++v26;
      BOOL v30 = v29 < v28 || v27 == (void)v25;
      v27 += 8;
      if (v30) {
        return sub_1CD4F30F8((uint64_t)a1, a3, a5);
      }
    }
    goto LABEL_27;
  }
  return sub_1CD4F30F8((uint64_t)a1, a3, a5);
}

void *sub_1CD4F30F8(uint64_t a1, void *a2, unint64_t **a3)
{
  long long v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unint64_t v6 = a3[1];
    do
    {
      while (1)
      {
        unint64_t v7 = v4;
        uint64_t v8 = (unint64_t *)v4[4];
        BOOL v9 = (unint64_t *)v7[5];
        if (v8 != v9) {
          break;
        }
LABEL_12:
        if (*a3 != v6)
        {
          uint64_t v15 = (uint64_t)(*a3 + 1);
          while (v8 != v9)
          {
            unint64_t v16 = *v8;
            unint64_t v17 = *(void *)(v15 - 8);
            if (*v8 < v17) {
              break;
            }
            ++v8;
            BOOL v18 = v17 < v16 || v15 == (void)v6;
            v15 += 8;
            if (v18) {
              goto LABEL_27;
            }
          }
          uint64_t result = v7 + 1;
          uint64_t v4 = (void *)v7[1];
          if (v4) {
            continue;
          }
        }
        goto LABEL_27;
      }
      uint64_t v10 = v8 + 1;
      unint64_t v11 = *a3;
      while (v11 != v6)
      {
        unint64_t v12 = *v11;
        unint64_t v13 = *(v10 - 1);
        if (*v11 < v13) {
          break;
        }
        ++v11;
        if (v13 < v12 || v10++ == v9) {
          goto LABEL_12;
        }
      }
      uint64_t v4 = (void *)*v7;
      uint64_t result = v7;
    }
    while (*v7);
  }
  else
  {
    unint64_t v7 = result;
  }
LABEL_27:
  *a2 = v7;
  return result;
}

void sub_1CD4F31B8(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    unint64_t v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    uint64_t v8 = v6[1] ? v6[1] : (uint64_t)v6;
    if (v8)
    {
      unint64_t v12 = sub_1CD4F3428(v8);
      if (a2 == a3)
      {
        unint64_t v13 = (void *)v8;
      }
      else
      {
        uint64_t v15 = a2;
        do
        {
          unint64_t v13 = v12;
          if ((void *)v8 != v15) {
            sub_1CBFAFDE4((void *)(v8 + 32), (char *)v15[4], (char *)v15[5], (uint64_t)(v15[5] - v15[4]) >> 3);
          }
          long long v16 = *(_OWORD *)(v15 + 7);
          *(void *)(v8 + 72) = v15[9];
          *(_OWORD *)(v8 + 56) = v16;
          sub_1CD4F3354((uint64_t **)a1, (uint64_t *)v8);
          if (v12) {
            unint64_t v12 = sub_1CD4F3428((uint64_t)v12);
          }
          else {
            unint64_t v12 = 0;
          }
          unint64_t v17 = (void *)v15[1];
          if (v17)
          {
            do
            {
              a2 = v17;
              unint64_t v17 = (void *)*v17;
            }
            while (v17);
          }
          else
          {
            do
            {
              a2 = (void *)v15[2];
              BOOL v11 = *a2 == (void)v15;
              uint64_t v15 = a2;
            }
            while (!v11);
          }
          if (!v13) {
            break;
          }
          uint64_t v15 = a2;
          uint64_t v8 = (uint64_t)v13;
        }
        while (a2 != a3);
      }
      sub_1CD4AFCAC(a1, v13);
      if (v12)
      {
        do
        {
          uint64_t v14 = v12;
          unint64_t v12 = (void *)v12[2];
        }
        while (v12);
        sub_1CD4AFCAC(a1, v14);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD4F347C((uint64_t **)a1, (uint64_t)(a2 + 4));
      BOOL v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

uint64_t *sub_1CD4F3354(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 1;
  uint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        uint64_t v5 = v4[4];
        unint64_t v6 = v3[5];
        if ((uint64_t *)v5 == v6) {
          break;
        }
        uint64_t v7 = (uint64_t *)(v5 + 8);
        uint64_t v8 = (unint64_t *)a2[4];
        while (v8 != (unint64_t *)a2[5])
        {
          unint64_t v9 = *v8;
          unint64_t v10 = *(v7 - 1);
          if (*v8 < v10) {
            break;
          }
          ++v8;
          if (v10 < v9 || v7++ == v6) {
            goto LABEL_11;
          }
        }
        uint64_t v4 = *v3;
        unint64_t v12 = v3;
        if (!*v3) {
          goto LABEL_16;
        }
      }
LABEL_11:
      uint64_t v4 = v3[1];
    }
    while (v4);
    unint64_t v12 = v3 + 1;
  }
  else
  {
    unint64_t v12 = a1 + 1;
  }
LABEL_16:
  *a2 = 0;
  a2[1] = 0;
  a2[2] = (uint64_t)v3;
  *unint64_t v12 = a2;
  unint64_t v13 = (uint64_t *)**a1;
  if (v13)
  {
    *a1 = v13;
    a2 = *v12;
  }
  uint64_t result = sub_1CB8358B8(a1[1], a2);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void *sub_1CD4F3428(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *uint64_t result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t *sub_1CD4F347C(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = (char *)operator new(0x50uLL);
  *((void *)v4 + 5) = 0;
  *((void *)v4 + 6) = 0;
  *((void *)v4 + 4) = 0;
  sub_1CBFCBA2C((void *)v4 + 4, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  uint64_t v5 = (char **)(a1 + 1);
  unint64_t v6 = (char *)a1[1];
  *(_OWORD *)(v4 + 56) = *(_OWORD *)(a2 + 24);
  *((void *)v4 + 9) = *(void *)(a2 + 40);
  if (v6)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = (char **)v6;
        uint64_t v8 = *((void *)v6 + 4);
        uint64_t v7 = *((void *)v6 + 5);
        if (v8 == v7) {
          break;
        }
        uint64_t v9 = v8 + 8;
        unint64_t v10 = (unint64_t *)*((void *)v4 + 4);
        while (v10 != *((unint64_t **)v4 + 5))
        {
          unint64_t v11 = *v10;
          unint64_t v12 = *(void *)(v9 - 8);
          if (*v10 < v12) {
            break;
          }
          ++v10;
          BOOL v13 = v12 < v11 || v9 == v7;
          v9 += 8;
          if (v13) {
            goto LABEL_11;
          }
        }
        unint64_t v6 = *v5;
        uint64_t v14 = v5;
        if (!*v5) {
          goto LABEL_16;
        }
      }
LABEL_11:
      unint64_t v6 = v5[1];
    }
    while (v6);
    uint64_t v14 = v5 + 1;
  }
  else
  {
    uint64_t v14 = (char **)(a1 + 1);
  }
LABEL_16:
  *(void *)uint64_t v4 = 0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = v5;
  void *v14 = v4;
  uint64_t v15 = (uint64_t *)**a1;
  if (v15)
  {
    *a1 = v15;
    uint64_t v4 = *v14;
  }
  uint64_t result = sub_1CB8358B8(a1[1], (uint64_t *)v4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void sub_1CD4F3590(uint64_t a1, void *a2, void *a3)
{
  if (*(void *)(a1 + 16))
  {
    unint64_t v6 = *(uint64_t **)a1;
    uint64_t v7 = *(void *)(a1 + 8);
    *(void *)a1 = a1 + 8;
    *(void *)(v7 + 16) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
    uint64_t v8 = v6[1] ? (uint64_t *)v6[1] : v6;
    if (v8)
    {
      unint64_t v12 = sub_1CD4F3428((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v14 = a2;
        do
        {
          uint64_t v15 = (uint64_t)v8;
          uint64_t v8 = v12;
          *(_DWORD *)(v15 + 32) = *((_DWORD *)v14 + 8);
          sub_1CB896804((unsigned __int8 **)(v15 + 40), (unsigned __int8 **)v14 + 5);
          sub_1CD4F3704((uint64_t **)a1, v15);
          if (v12) {
            unint64_t v12 = sub_1CD4F3428((uint64_t)v12);
          }
          long long v16 = (void *)v14[1];
          if (v16)
          {
            do
            {
              a2 = v16;
              long long v16 = (void *)*v16;
            }
            while (v16);
          }
          else
          {
            do
            {
              a2 = (void *)v14[2];
              BOOL v11 = *a2 == (void)v14;
              uint64_t v14 = a2;
            }
            while (!v11);
          }
          if (!v8) {
            break;
          }
          uint64_t v14 = a2;
        }
        while (a2 != a3);
      }
      sub_1CD4F379C(a1, v8);
      if (v12)
      {
        do
        {
          BOOL v13 = v12;
          unint64_t v12 = (uint64_t *)v12[2];
        }
        while (v12);
        sub_1CD4F379C(a1, v13);
      }
    }
  }
  if (a2 != a3)
  {
    do
    {
      sub_1CD4F3800(a1, *((_DWORD *)a2 + 8), (unsigned __int8 *)a2[5]);
      uint64_t v9 = (void *)a2[1];
      if (v9)
      {
        do
        {
          unint64_t v10 = v9;
          uint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unint64_t v10 = (void *)a2[2];
          BOOL v11 = *v10 == (void)a2;
          a2 = v10;
        }
        while (!v11);
      }
      a2 = v10;
    }
    while (v10 != a3);
  }
}

uint64_t *sub_1CD4F3704(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)(a1 + 1);
  uint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = v4;
        if (*(_DWORD *)(a2 + 32) >= *((_DWORD *)v4 + 8)) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }
      uint64_t v4 = (uint64_t *)v4[1];
    }
    while (v4);
    uint64_t v5 = v3 + 1;
  }
  else
  {
    uint64_t v5 = (uint64_t *)(a1 + 1);
  }
LABEL_8:
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = v3;
  *uint64_t v5 = a2;
  unint64_t v6 = (uint64_t *)**a1;
  if (v6)
  {
    *a1 = v6;
    a2 = *v5;
  }
  uint64_t result = sub_1CB8358B8(a1[1], (uint64_t *)a2);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void sub_1CD4F379C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD4F379C(a1, *a2);
    sub_1CD4F379C(a1, a2[1]);
    uint64_t v5 = (unsigned __int8 *)a2[5];
    if (v5) {
      llvm::MetadataTracking::untrack((uint64_t)(a2 + 5), v5);
    }
    operator delete(a2);
  }
}

uint64_t *sub_1CD4F3800(uint64_t a1, int a2, unsigned __int8 *a3)
{
  sub_1CD4F38B8((uint64_t)v10, a1, a2, a3);
  uint64_t v4 = (uint64_t *)v10[0];
  uint64_t v5 = (uint64_t **)(a1 + 8);
  unint64_t v6 = *(uint64_t ***)(a1 + 8);
  if (v6)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v6;
        if (*(_DWORD *)(v10[0] + 32) >= *((_DWORD *)v6 + 8)) {
          break;
        }
        unint64_t v6 = (uint64_t **)*v6;
        uint64_t v7 = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      unint64_t v6 = (uint64_t **)v6[1];
    }
    while (v6);
    uint64_t v7 = v5 + 1;
  }
  else
  {
    uint64_t v7 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  *(void *)v10[0] = 0;
  v4[1] = 0;
  void v4[2] = (uint64_t)v5;
  *uint64_t v7 = v4;
  uint64_t v8 = **(void **)a1;
  if (v8)
  {
    *(void *)a1 = v8;
    uint64_t v4 = *v7;
  }
  uint64_t result = sub_1CB8358B8(*(uint64_t **)(a1 + 8), v4);
  ++*(void *)(a1 + 16);
  return result;
}

uint64_t sub_1CD4F38B8(uint64_t a1, uint64_t a2, int a3, unsigned __int8 *a4)
{
  uint64_t v7 = a2 + 8;
  uint64_t v8 = operator new(0x30uLL);
  *(void *)a1 = v8;
  *(void *)(a1 + 8) = v7;
  _OWORD v8[8] = a3;
  *((void *)v8 + 5) = a4;
  uint64_t result = (uint64_t)(v8 + 10);
  if (a4) {
    uint64_t result = llvm::MetadataTracking::track(result, a4, 2);
  }
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

uint64_t sub_1CD4F3918(uint64_t a1, unsigned __int8 *a2, size_t a3, _OWORD *a4)
{
  uint64_t result = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t v9 = *(void *)a1;
  uint64_t v10 = result;
  uint64_t v11 = *(void *)(*(void *)a1 + 8 * result);
  if (v11 == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v11)
  {
    return result;
  }
  unint64_t v12 = (char *)operator new(a3 + 25, (std::align_val_t)8uLL);
  BOOL v13 = v12;
  uint64_t v14 = v12 + 24;
  if (a3) {
    memcpy(v12 + 24, a2, a3);
  }
  v14[a3] = 0;
  *(void *)BOOL v13 = a3;
  *(_OWORD *)(v13 + 8) = *a4;
  *(void *)(v9 + 8 * v10) = v13;
  ++*(_DWORD *)(a1 + 12);
  uint64_t result = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v10);
  for (int i = (void *)(*(void *)a1 + 8 * result); !*i || *i == -8; ++i)
    ;
  return result;
}

uint64_t *sub_1CD4F3A14(uint64_t *result, unsigned int a2, uint64_t a3)
{
  uint64_t v4 = result;
  unint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        unsigned int v8 = *(_DWORD *)(v5 + 32);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    uint64_t v9 = (char *)operator new(0x38uLL);
    *((_DWORD *)v9 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v9 + 40) = *(_OWORD *)(a3 + 8);
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    *unint64_t v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *uint64_t v4 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v9;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

void sub_1CD4F3AD8(uint64_t a1, void *a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  sub_1CD4F379C(a1, *(void **)(a1 + 8));
  *(void *)a1 = *a2;
  uint64_t v5 = a2 + 1;
  uint64_t v6 = a2[1];
  *uint64_t v4 = v6;
  uint64_t v7 = a2[2];
  *(void *)(a1 + 16) = v7;
  if (v7)
  {
    *(void *)(v6 + 16) = v4;
    *a2 = v5;
    *uint64_t v5 = 0;
    a2[2] = 0;
  }
  else
  {
    *(void *)a1 = v4;
  }
}

uint64_t sub_1CD4F3B44(uint64_t a1, unsigned __int8 *a2, size_t a3, size_t *a4)
{
  uint64_t result = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  uint64_t v9 = *(void *)a1;
  uint64_t v10 = result;
  uint64_t v11 = *(void *)(*(void *)a1 + 8 * result);
  if (v11 == -8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v11)
  {
    return result;
  }
  unint64_t v12 = operator new(a3 + 17, (std::align_val_t)8uLL);
  BOOL v13 = v12;
  uint64_t v14 = (char *)(v12 + 2);
  if (a3) {
    memcpy(v12 + 2, a2, a3);
  }
  v14[a3] = 0;
  size_t v15 = *a4;
  *BOOL v13 = a3;
  v13[1] = v15;
  *(void *)(v9 + 8 * v10) = v13;
  ++*(_DWORD *)(a1 + 12);
  uint64_t result = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v10);
  for (int i = (void *)(*(void *)a1 + 8 * result); !*i || *i == -8; ++i)
    ;
  return result;
}

uint64_t *sub_1CD4F3C3C(uint64_t *result, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v6 = result;
  unsigned int v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (void *)v7;
        unsigned int v10 = *(_DWORD *)(v7 + 32);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        unsigned int v8 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        unsigned int v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = result + 1;
LABEL_9:
    uint64_t v11 = operator new(0x30uLL);
    unsigned int v11[8] = a3;
    *((void *)v11 + 5) = a4;
    *(void *)uint64_t v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    *unsigned int v8 = (uint64_t *)v11;
    uint64_t v12 = *(void *)*v6;
    if (v12)
    {
      *uint64_t v6 = v12;
      BOOL v13 = *v8;
    }
    else
    {
      BOOL v13 = (uint64_t *)v11;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

uint64_t **sub_1CD4F3D04(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x38uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *uint64_t v7 = 0;
    v7[1] = 0;
    v7[5] = 0;
    v7[6] = 0;
    void v7[2] = v9;
    *uint64_t v6 = (uint64_t *)v7;
    unsigned int v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

size_t **sub_1CD4F3DD4(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  int i = (size_t **)(*(void *)a1 + 8 * v6);
  unsigned int v8 = *i;
  if (*i == (size_t *)-8)
  {
    --*(_DWORD *)(a1 + 16);
  }
  else if (v8)
  {
    while (!v8 || v8 == (size_t *)-8)
    {
      uint64_t v9 = i[1];
      ++i;
      unsigned int v8 = v9;
    }
    return i;
  }
  uint64_t v11 = operator new(a3 + 25, (std::align_val_t)8uLL);
  uint64_t v12 = v11;
  BOOL v13 = (char *)(v11 + 3);
  if (a3) {
    memcpy(v11 + 3, a2, a3);
  }
  v13[a3] = 0;
  v12[1] = 0;
  uint64_t v12[2] = 0;
  *uint64_t v12 = a3;
  *int i = v12;
  ++*(_DWORD *)(a1 + 12);
  for (int i = (size_t **)(*(void *)a1
                      + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
        !*i || *i + 1 == 0;
  return i;
}

uint64_t sub_1CD4F3EC8(uint64_t a1, void *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    char v6 = *((unsigned char *)a2 + 23);
    BOOL v7 = v6 < 0;
    unsigned int v8 = (const void *)*a2;
    if (v6 >= 0) {
      unsigned int v8 = a2;
    }
    uint64_t v9 = v6 & 0x7F;
    if (v7) {
      uint64_t v9 = a2[1];
    }
    BOOL v18 = v8;
    uint64_t v19 = v9;
    int v10 = sub_1CC0C5278((const void **)(v3 + 32), (uint64_t)&v18);
    uint64_t v11 = (uint64_t *)(v3 + 8);
    if (v10 >= 0)
    {
      uint64_t v11 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v11;
  }
  while (*v11);
  if (v5 == v2) {
    return v2;
  }
  uint64_t v12 = *(const void **)(v5 + 32);
  char v13 = *(unsigned char *)(v5 + 55);
  int v14 = v13;
  if (v13 >= 0) {
    uint64_t v12 = (const void *)(v5 + 32);
  }
  uint64_t v15 = *(void *)(v5 + 40);
  uint64_t v16 = v13 & 0x7F;
  if (v14 >= 0) {
    uint64_t v15 = v16;
  }
  BOOL v18 = v12;
  uint64_t v19 = v15;
  if ((sub_1CC0C5278((const void **)a2, (uint64_t)&v18) & 0x80000000) != 0) {
    return v2;
  }
  return v5;
}

void sub_1CD4F3F94(uint64_t **a1, uint64_t a2)
{
  sub_1CD491B50(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }

  operator delete((void *)a2);
}

uint64_t **sub_1CD4F3FDC(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  char v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        char v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        char v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    BOOL v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = 0;
    *BOOL v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *char v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void sub_1CD4F40AC(uint64_t **a1, uint64_t *a2)
{
  sub_1CD491B50(a1, a2);
  uint64_t v4 = (llvm::MDNode *)a2[5];
  a2[5] = 0;
  if (v4) {
    llvm::MDNode::deleteTemporary(v4, v3);
  }

  operator delete(a2);
}

uint64_t **sub_1CD4F40F4(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  char v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        char v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        char v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    BOOL v7 = (uint64_t **)operator new(0x40uLL);
    int v10 = *a3;
    *BOOL v7 = 0;
    v7[1] = 0;
    _OWORD v7[4] = v10;
    v7[5] = 0;
    v7[6] = 0;
    v7[7] = 0;
    void v7[2] = v9;
    *char v6 = (uint64_t *)v7;
    uint64_t v11 = (uint64_t *)**a1;
    uint64_t v12 = (uint64_t *)v7;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_1CD4F41C4(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  char v6 = (uint64_t **)(a1 + 8);
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        BOOL v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        char v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        char v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    BOOL v7 = (uint64_t **)(a1 + 8);
LABEL_9:
    sub_1CD4F4284((uint64_t)&v12, a1, a3, a4);
    uint64_t v9 = v12;
    *uint64_t v12 = 0;
    v9[1] = 0;
    int v9[2] = (uint64_t)v7;
    *char v6 = v9;
    uint64_t v10 = **(void **)a1;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v9 = *v6;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v9);
    ++*(void *)(a1 + 16);
    return v12;
  }
  return (uint64_t *)v7;
}

uint64_t sub_1CD4F4284(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = a2 + 8;
  unsigned int v8 = operator new(0x80uLL);
  *(void *)a1 = v8;
  *(void *)(a1 + 8) = v7;
  _OWORD v8[8] = a3;
  *((void *)v8 + 5) = *(void *)a4;
  *((void *)v8 + 7) = 0x800000000;
  *((void *)v8 + 6) = v8 + 16;
  uint64_t result = (uint64_t)(v8 + 12);
  if (*(_DWORD *)(a4 + 16)) {
    uint64_t result = sub_1CD41C56C(result, a4 + 8);
  }
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

uint64_t *sub_1CD4F4300(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t **)sub_1CD4AF8D4(a1, &v13, a2);
  char v6 = *v5;
  if (!*v5)
  {
    unsigned int v8 = v5;
    sub_1CD4F43A4((uint64_t)&v12, a1, *a3);
    uint64_t v9 = v13;
    char v6 = v12;
    *uint64_t v12 = 0;
    v6[1] = 0;
    void v6[2] = v9;
    *unsigned int v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = *v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

_OWORD *sub_1CD4F43A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  char v6 = operator new(0x48uLL);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v5;
  uint64_t result = v6 + 4;
  if (*(char *)(a3 + 23) < 0)
  {
    uint64_t result = sub_1CB8BDF7C((uint64_t)result, *(const void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *uint64_t result = *(_OWORD *)a3;
    v6[6] = *(void *)(a3 + 16);
  }
  v6[7] = 0;
  v6[8] = 0;
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

uint64_t *sub_1CD4F4418(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t **)sub_1CD4AF8D4(a1, &v13, a2);
  char v6 = *v5;
  if (!*v5)
  {
    unsigned int v8 = v5;
    sub_1CD4F44BC((uint64_t)&v12, a1, *a3);
    uint64_t v9 = v13;
    char v6 = v12;
    *uint64_t v12 = 0;
    v6[1] = 0;
    void v6[2] = v9;
    *unsigned int v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = *v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

_OWORD *sub_1CD4F44BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2 + 8;
  char v6 = (char *)operator new(0x40uLL);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v5;
  uint64_t result = v6 + 32;
  if (*(char *)(a3 + 23) < 0)
  {
    uint64_t result = sub_1CB8BDF7C((uint64_t)result, *(const void **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *uint64_t result = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
  }
  *((void *)v6 + 7) = 0;
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

void sub_1CD4F4530()
{
}

uint64_t sub_1CD4F4644(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2)
  {
    uint64_t v3 = *(long long **)result;
    uint64_t v4 = *(void *)result + 48 * v2;
    do
    {
      long long v5 = *v3;
      *(void *)(a2 + 16) = *((void *)v3 + 2);
      *(_OWORD *)a2 = v5;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
      *(void *)uint64_t v3 = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      *(_OWORD *)(a2 + 24) = *(long long *)((char *)v3 + 24);
      *(void *)(a2 + 40) = *((void *)v3 + 5);
      *((void *)v3 + 3) = 0;
      *((void *)v3 + 4) = 0;
      *((void *)v3 + 5) = 0;
      v3 += 3;
      a2 += 48;
    }
    while (v3 != (long long *)v4);
    uint64_t v6 = *(unsigned int *)(result + 8);
    if (v6)
    {
      uint64_t v7 = 48 * v6;
      uint64_t v8 = *(void *)result - 48;
      do
      {
        uint64_t result = sub_1CD4AF9B4(v8 + v7);
        v7 -= 48;
      }
      while (v7);
    }
  }
  return result;
}

void sub_1CD4F46E4()
{
}

void sub_1CD4F47D4(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = (long long *)*a1;
    uint64_t v4 = *a1 + 48 * v2;
    do
    {
      long long v5 = *v3;
      *(void *)(a2 + 16) = *((void *)v3 + 2);
      *(_OWORD *)a2 = v5;
      long long v6 = *(long long *)((char *)v3 + 24);
      *(void *)(a2 + 40) = *((void *)v3 + 5);
      *(_OWORD *)(a2 + 24) = v6;
      *((void *)v3 + 4) = 0;
      *((void *)v3 + 5) = 0;
      *((void *)v3 + 3) = 0;
      v3 += 3;
      a2 += 48;
    }
    while (v3 != (long long *)v4);
    uint64_t v7 = *((unsigned int *)a1 + 2);
    if (v7)
    {
      uint64_t v8 = (long long *)*a1;
      uint64_t v9 = 3 * v7;
      do
      {
        if (SHIBYTE(v8[v9 - 1]) < 0) {
          operator delete(*((void **)&v8[v9 - 1] - 1));
        }
        v9 -= 3;
      }
      while (v9 * 16);
    }
  }
}

char **sub_1CD4F486C(char **a1)
{
  unsigned int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 48 * v3;
    do
    {
      if (v2[v4 - 1] < 0) {
        operator delete(*(void **)&v2[v4 - 24]);
      }
      v4 -= 48;
    }
    while (v4);
    unsigned int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD4F48E0(char *a1)
{
  if (a1)
  {
    sub_1CD4F48E0(*(void *)a1);
    sub_1CD4F48E0(*((void *)a1 + 1));
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void sub_1CD4F493C(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = a1 + 8;
    do
    {
      unsigned int v4 = *(_DWORD *)(v2 + 32);
      BOOL v5 = v4 >= a2;
      if (v4 >= a2) {
        long long v6 = (uint64_t *)v2;
      }
      else {
        long long v6 = (uint64_t *)(v2 + 8);
      }
      if (v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 8 && *(_DWORD *)(v3 + 32) <= a2)
    {
      sub_1CD491B50((uint64_t **)a1, (uint64_t *)v3);
      operator delete((void *)v3);
    }
  }
}

uint64_t sub_1CD4F49C0(uint64_t *a1, void *a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    uint64_t v4 = 1;
    do
    {
      BOOL v5 = (const void *)v3[4];
      char v6 = *((unsigned char *)v3 + 55);
      int v7 = v6;
      if (v6 >= 0) {
        BOOL v5 = v3 + 4;
      }
      uint64_t v8 = v6 & 0x7F;
      if (v7 < 0) {
        uint64_t v8 = v3[5];
      }
      int v14 = v5;
      uint64_t v15 = v8;
      if ((sub_1CC0C5278((const void **)a2, (uint64_t)&v14) & 0x80000000) == 0)
      {
        char v9 = *((unsigned char *)a2 + 23);
        BOOL v10 = v9 < 0;
        uint64_t v11 = (const void *)*a2;
        if (v9 >= 0) {
          uint64_t v11 = a2;
        }
        uint64_t v12 = v9 & 0x7F;
        if (v10) {
          uint64_t v12 = a2[1];
        }
        int v14 = v11;
        uint64_t v15 = v12;
        if ((sub_1CC0C5278((const void **)v3 + 4, (uint64_t)&v14) & 0x80000000) == 0) {
          return v4;
        }
        ++v3;
      }
      uint64_t v3 = (uint64_t *)*v3;
    }
    while (v3);
  }
  return 0;
}

void sub_1CD4F4A78(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1CD4F4A78(a1, *a2);
    sub_1CD4F4A78(a1, a2[1]);
    sub_1CD4F271C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t *sub_1CD4F4AD4(uint64_t a1, _DWORD *a2, void *a3)
{
  BOOL v5 = (uint64_t **)sub_1CD4F4B78(a1, &v13, a2);
  char v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    sub_1CD4F4C0C((uint64_t)&v12, a1, a3);
    uint64_t v9 = v13;
    char v6 = v12;
    *uint64_t v12 = 0;
    v6[1] = 0;
    void v6[2] = v9;
    *uint64_t v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = *v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD4F4B78(uint64_t a1, void *a2, _DWORD *a3)
{
  BOOL v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        int v7 = (void *)v4;
        uint64_t v8 = (_DWORD *)(v4 + 32);
        if (!sub_1CD4F4C98(a3, v4 + 32)) {
          break;
        }
        uint64_t v4 = *v7;
        BOOL v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (!sub_1CD4F4C98(v8, (uint64_t)a3)) {
        break;
      }
      BOOL v5 = v7 + 1;
      uint64_t v4 = v7[1];
    }
    while (v4);
  }
  else
  {
    int v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t sub_1CD4F4C0C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a2 + 8;
  char v6 = operator new(0xD0uLL);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v5;
  uint64_t result = sub_1CD4F27B0((uint64_t)(v6 + 4), (uint64_t)a3);
  uint64_t v8 = a3 + 20;
  uint64_t v9 = a3[20];
  v6[23] = a3[19];
  v6[24] = v9;
  uint64_t v10 = v6 + 24;
  uint64_t v11 = a3[21];
  v6[25] = v11;
  if (v11)
  {
    *(void *)(v9 + 16) = v10;
    a3[19] = v8;
    *uint64_t v8 = 0;
    a3[21] = 0;
  }
  else
  {
    v6[23] = v10;
  }
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

BOOL sub_1CD4F4C98(_DWORD *a1, uint64_t a2)
{
  if (*a1 <= 1u) {
    return a1[4] < *(_DWORD *)(a2 + 16);
  }
  uint64_t v3 = (const void **)(a1 + 8);
  uint64_t v6 = *(void *)(a2 + 32);
  uint64_t v4 = a2 + 32;
  uint64_t v5 = v6;
  char v7 = *(unsigned char *)(v4 + 23);
  int v8 = v7;
  if (v7 >= 0) {
    uint64_t v5 = v4;
  }
  uint64_t v9 = v7 & 0x7F;
  if (v8 < 0) {
    uint64_t v9 = *(void *)(v4 + 8);
  }
  v10[0] = v5;
  v10[1] = v9;
  return sub_1CC0C5278(v3, (uint64_t)v10) >> 31;
}

uint64_t *sub_1CD4F4D08(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)sub_1CD4F4B78(a1, &v12, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    int v8 = v5;
    uint64_t v6 = (uint64_t *)operator new(0xC0uLL);
    sub_1CD4F27B0((uint64_t)(v6 + 4), a3);
    v6[23] = 0;
    uint64_t v9 = v12;
    *uint64_t v6 = 0;
    v6[1] = 0;
    void v6[2] = v9;
    *int v8 = v6;
    uint64_t v10 = **(void **)a1;
    uint64_t v11 = v6;
    if (v10)
    {
      *(void *)a1 = v10;
      uint64_t v11 = *v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

uint64_t sub_1CD4F4DB4(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    BOOL v6 = sub_1CD4F4C98((_DWORD *)(v3 + 32), (uint64_t)a2);
    char v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      char v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || sub_1CD4F4C98(a2, v5 + 32)) {
    return v2;
  }
  return v5;
}

void sub_1CD4F4E34(uint64_t **a1, uint64_t a2)
{
  sub_1CD491B50(a1, (uint64_t *)a2);
  sub_1CD4F4A78(a2 + 184, *(void **)(a2 + 192));
  sub_1CD4F271C(a2 + 32);

  operator delete((void *)a2);
}

void sub_1CD4F4E84(uint64_t **a1, uint64_t *a2)
{
  sub_1CD491B50(a1, a2);
  uint64_t v3 = (void *)a2[5];
  if (v3)
  {
    a2[6] = (uint64_t)v3;
    operator delete(v3);
  }

  operator delete(a2);
}

void sub_1CD4F4ECC(void *a1)
{
  if (a1)
  {
    sub_1CD4F4ECC(*a1);
    sub_1CD4F4ECC(a1[1]);
    uint64_t v3 = (void *)a1[5];
    if (v3)
    {
      a1[6] = v3;
      operator delete(v3);
    }
    operator delete(a1);
  }
}

uint64_t **sub_1CD4F4F28(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  BOOL v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        char v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        BOOL v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        BOOL v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    char v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    char v7 = (uint64_t **)operator new(0x40uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *char v7 = 0;
    v7[1] = 0;
    v7[6] = 0;
    v7[7] = 0;
    v7[5] = 0;
    void v7[2] = v9;
    *BOOL v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

char *sub_1CD4F4FFC(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  char v7 = a1 + 1;
  BOOL v6 = (char *)a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = v6;
        unint64_t v10 = *((void *)v6 + 4);
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *(char **)v9;
        char v7 = (uint64_t **)v9;
        if (!*(void *)v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      BOOL v6 = (char *)*((void *)v9 + 1);
      if (!v6)
      {
        char v7 = (uint64_t **)(v9 + 8);
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = (char *)(a1 + 1);
LABEL_10:
    uint64_t v11 = v9;
    uint64_t v9 = (char *)operator new(0x60uLL);
    *((void *)v9 + 4) = **a4;
    *(_OWORD *)(v9 + 72) = 0u;
    *((void *)v9 + 11) = 0;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 40) = 0u;
    *((void *)v9 + 9) = v9 + 80;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v11;
    *char v7 = (uint64_t *)v9;
    uint64_t v12 = (uint64_t *)**a1;
    uint64_t v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1 = v12;
      uint64_t v13 = *v7;
    }
    sub_1CB8358B8(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

uint64_t *sub_1CD4F50FC(uint64_t a1, unint64_t **a2, uint64_t a3, uint64_t *a4)
{
  BOOL v6 = (uint64_t **)sub_1CD4F30F8(a1, &v14, a2);
  char v7 = *v6;
  if (!*v6)
  {
    uint64_t v9 = v6;
    char v7 = (uint64_t *)operator new(0x50uLL);
    uint64_t v10 = *a4;
    v7[5] = 0;
    v7[6] = 0;
    _OWORD v7[4] = 0;
    sub_1CBFCBA2C(v7 + 4, *(const void **)v10, *(void *)(v10 + 8), (uint64_t)(*(void *)(v10 + 8) - *(void *)v10) >> 3);
    v7[7] = 0;
    v7[8] = 0;
    v7[9] = 0;
    uint64_t v11 = v14;
    *char v7 = 0;
    v7[1] = 0;
    void v7[2] = v11;
    *uint64_t v9 = v7;
    uint64_t v12 = **(void **)a1;
    uint64_t v13 = v7;
    if (v12)
    {
      *(void *)a1 = v12;
      uint64_t v13 = *v9;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v13);
    ++*(void *)(a1 + 16);
  }
  return v7;
}

void sub_1CD4F51C4(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(a1[1], 8 * a2);
      v5 += 8 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    BOOL v6 = *a1;
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 3);
    if (v8 >> 61) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 2 > v8) {
      unint64_t v8 = v9 >> 2;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 61) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(8 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v11[8 * (v7 >> 3)];
    uint64_t v13 = &v11[8 * v10];
    bzero(v12, 8 * a2);
    while (v5 != v6)
    {
      uint64_t v14 = *((void *)v5 - 1);
      v5 -= 8;
      *((void *)v12 - 1) = v14;
      v12 -= 8;
    }
    *a1 = v12;
    a1[1] = &v11[8 * a2 + v7];
    a1[2] = v13;
    if (v6)
    {
      operator delete(v6);
    }
  }
}

void llvm::parseAssembly()
{
}

llvm::Constant *llvm::parseConstantValue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 0;
  memset(v18, 0, sizeof(v18));
  llvm::MemoryBuffer::getMemBuffer(a1, a2, (uint64_t)"", 0, &v17);
  uint64_t v16 = v17;
  sub_1CD452CE0((uint64_t)v18, &v16, 0);
  uint64_t v10 = v16;
  uint64_t v16 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *a4;
  uint64_t v15 = 0;
  sub_1CD4F5514((uint64_t)v20, a1, a2, (uint64_t)v18, a3, (uint64_t)a4, 0, v11, 0);
  int v12 = llvm::LLParser::parseStandaloneConstantValue((uint64_t)v20, &v15, a5);
  sub_1CD4F568C((uint64_t)v20);
  if (v12) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = v15;
  }
  llvm::SourceMgr::~SourceMgr((llvm::SourceMgr *)v18);
  return v13;
}

uint64_t sub_1CD4F5514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(void *)a1 = a8;
  llvm::LLLexer::LLLexer(a1 + 8, a2, a3, a4, a5, a8);
  llvm::LLLexer::LLLexer(a1 + 168, a2, a3, a4, a5, a8);
  *(void *)(a1 + 328) = a6;
  *(void *)(a1 + 336) = a7;
  *(void *)(a1 + 344) = a9;
  *(void *)(a1 + 352) = a1 + 368;
  *(void *)(a1 + 360) = 0x4000000000;
  *(_OWORD *)(a1 + 880) = 0u;
  *(void *)(a1 + 896) = 0x1800000000;
  *(_OWORD *)(a1 + 920) = 0u;
  *(void *)(a1 + 912) = a1 + 920;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 968) = 0u;
  *(void *)(a1 + 936) = a1 + 944;
  *(void *)(a1 + 960) = a1 + 968;
  *(_OWORD *)(a1 + 992) = 0u;
  *(void *)(a1 + 984) = a1 + 992;
  *(_OWORD *)(a1 + 1016) = 0u;
  *(void *)(a1 + 1008) = a1 + 1016;
  *(void *)(a1 + 1048) = 0;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_OWORD *)(a1 + 1064) = 0u;
  *(void *)(a1 + 1056) = a1 + 1064;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(void *)(a1 + 1080) = a1 + 1088;
  *(void *)(a1 + 1104) = 0;
  *(_OWORD *)(a1 + 1120) = 0u;
  *(void *)(a1 + 1112) = a1 + 1120;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(void *)(a1 + 1136) = a1 + 1144;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(void *)(a1 + 1160) = a1 + 1168;
  *(_OWORD *)(a1 + 1192) = 0u;
  *(void *)(a1 + 1184) = a1 + 1192;
  *(_OWORD *)(a1 + 1208) = 0u;
  *(void *)(a1 + 1224) = 0;
  *(_OWORD *)(a1 + 1240) = 0u;
  *(void *)(a1 + 1232) = a1 + 1240;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(void *)(a1 + 1256) = a1 + 1264;
  *(void *)(a1 + 1304) = 0;
  *(_OWORD *)(a1 + 1288) = 0u;
  return a1;
}

uint64_t sub_1CD4F568C(uint64_t a1)
{
  if (*(char *)(a1 + 1311) < 0) {
    operator delete(*(void **)(a1 + 1288));
  }
  sub_1CD40B1BC(*(void **)(a1 + 1264));
  sub_1CD4F4ECC(*(void **)(a1 + 1240));
  uint64_t v2 = *(void **)(a1 + 1208);
  if (v2)
  {
    *(void *)(a1 + 1216) = v2;
    operator delete(v2);
  }
  sub_1CD4F4ECC(*(void **)(a1 + 1192));
  sub_1CD4F4ECC(*(void **)(a1 + 1168));
  sub_1CD4F5778(*(void **)(a1 + 1144));
  sub_1CD4F4ECC(*(void **)(a1 + 1120));
  sub_1CD4F57D8(*(void **)(a1 + 1088));
  sub_1CD4F48E0(*(char **)(a1 + 1064));
  uint64_t v3 = *(void **)(a1 + 1032);
  if (v3)
  {
    *(void *)(a1 + 1040) = v3;
    operator delete(v3);
  }
  sub_1CD40B1BC(*(void **)(a1 + 1016));
  sub_1CD4F48E0(*(char **)(a1 + 992));
  sub_1CD4F583C(*(void **)(a1 + 968));
  sub_1CD4F379C(a1 + 936, *(void **)(a1 + 944));
  sub_1CD40B1BC(*(void **)(a1 + 920));
  sub_1CD4AFD10(a1 + 880);
  uint64_t v4 = *(void **)(a1 + 352);
  if (v4 != (void *)(a1 + 368)) {
    free(v4);
  }
  sub_1CD4F5898(a1 + 168);
  sub_1CD4F5898(a1 + 8);
  return a1;
}

void sub_1CD4F5778(void *a1)
{
  if (a1)
  {
    sub_1CD4F5778(*a1);
    sub_1CD4F5778(a1[1]);
    uint64_t v3 = (void *)a1[6];
    if (v3 != a1 + 8) {
      free(v3);
    }
    operator delete(a1);
  }
}

void sub_1CD4F57D8(void *a1)
{
  if (a1)
  {
    sub_1CD4F57D8(*a1);
    sub_1CD4F57D8(a1[1]);
    sub_1CD4F4A78((uint64_t)(a1 + 23), (void *)a1[24]);
    sub_1CD4F271C((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void sub_1CD4F583C(void *a1)
{
  if (a1)
  {
    sub_1CD4F583C(*a1);
    sub_1CD4F583C(a1[1]);
    uint64_t v4 = (llvm::MDNode *)a1[5];
    a1[5] = 0;
    if (v4) {
      llvm::MDNode::deleteTemporary(v4, v3);
    }
    operator delete(a1);
  }
}

uint64_t sub_1CD4F5898(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 144) >= 0x41u)
  {
    uint64_t v2 = *(void *)(a1 + 136);
    if (v2) {
      MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
    }
  }
  sub_1CB87DEE4((uint64_t *)(a1 + 112));
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  return a1;
}

uint64_t llvm::COFF::encodeSectionName(llvm::COFF *this, unint64_t a2)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  unint64_t v13 = a2;
  if (a2 <= 0x98967F)
  {
    uint64_t v14 = v16;
    long long v15 = xmmword_1CD96EEC0;
    __int16 v11 = 263;
    LOBYTE(v10[0]) = 47;
    __int16 v9 = 268;
    unint64_t v8 = &v13;
    sub_1CB8F1E58(v10, (uint64_t *)&v8, (uint64_t)v12);
    llvm::Twine::toVector((uint64_t)v12, (uint64_t)&v14);
    uint64_t v3 = v14;
    memcpy(this, v14, v15);
    if (v3 != v16) {
      free(v3);
    }
    return 1;
  }
  if (!(a2 >> 36))
  {
    *(_WORD *)this = 12079;
    uint64_t v5 = (char *)this + 7;
    int v6 = 6;
    do
    {
      unint64_t v7 = a2 & 0x3F;
      a2 >>= 6;
      *v5-- = aAbcdefghijklmn[v7];
      --v6;
    }
    while (v6);
    return 1;
  }
  return 0;
}

uint64_t llvm::dwarf::AttributeVersion(int a1)
{
  if ((a1 - 1) > 0x8B) {
    return 0;
  }
  else {
    return dword_1CFAC4E58[(__int16)(a1 - 1)];
  }
}

const char *llvm::dwarf::AttributeEncodingString(llvm::dwarf *this)
{
  switch((int)this)
  {
    case 1:
      uint64_t result = "DW_ATE_address";
      break;
    case 2:
      uint64_t result = "DW_ATE_BOOLean";
      break;
    case 3:
      uint64_t result = "DW_ATE_complex_float";
      break;
    case 4:
      uint64_t result = "DW_ATE_float";
      break;
    case 5:
      uint64_t result = "DW_ATE_signed";
      break;
    case 6:
      uint64_t result = "DW_ATE_signed_char";
      break;
    case 7:
      uint64_t result = "DW_ATE_unsigned";
      break;
    case 8:
      uint64_t result = "DW_ATE_unsigned_char";
      break;
    case 9:
      uint64_t result = "DW_ATE_imaginary_float";
      break;
    case 10:
      uint64_t result = "DW_ATE_packed_decimal";
      break;
    case 11:
      uint64_t result = "DW_ATE_numeric_string";
      break;
    case 12:
      uint64_t result = "DW_ATE_edited";
      break;
    case 13:
      uint64_t result = "DW_ATE_signed_fixed";
      break;
    case 14:
      uint64_t result = "DW_ATE_unsigned_fixed";
      break;
    case 15:
      uint64_t result = "DW_ATE_decimal_float";
      break;
    case 16:
      uint64_t result = "DW_ATE_UTF";
      break;
    case 17:
      uint64_t result = "DW_ATE_UCS";
      break;
    case 18:
      uint64_t result = "DW_ATE_ASCII";
      break;
    default:
      if (!v2 & v1) {
        return 0;
      }
      switch((int)this)
      {
        case 129:
          uint64_t result = "DW_ATE_HP_complex_float";
          break;
        case 130:
          uint64_t result = "DW_ATE_HP_float128";
          break;
        case 131:
          uint64_t result = "DW_ATE_HP_complex_float128";
          break;
        case 132:
          uint64_t result = "DW_ATE_HP_floathpintel";
          break;
        case 133:
          uint64_t result = "DW_ATE_HP_imaginary_float90";
          break;
        case 134:
          uint64_t result = "DW_ATE_HP_imaginary_float128";
          break;
        default:
          JUMPOUT(0);
      }
      return result;
  }
  return result;
}

char *llvm::dwarf::AccessibilityString(llvm::dwarf *this)
{
  if ((this - 1) > 2) {
    return 0;
  }
  else {
    return off_1E682E820[(int)this - 1];
  }
}

uint64_t llvm::dwarf::LanguageLowerBound(int a1)
{
  switch(a1)
  {
    case 1:
    case 2:
    case 4:
    case 11:
    case 12:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 32:
    case 33:
    case 36:
    case 37:
      uint64_t v1 = 0;
      uint64_t v2 = 0x100000000;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 23:
    case 31:
    case 34:
    case 35:
      uint64_t v2 = 0x100000000;
      uint64_t v1 = 1;
      break;
    default:
      uint64_t v2 = 0x100000000;
      uint64_t v4 = 0x100000000;
      if (a1 != 45056) {
        uint64_t v4 = 0;
      }
      if (a1 != 36439) {
        uint64_t v2 = v4;
      }
      uint64_t v1 = 0;
      break;
  }
  return v1 | v2;
}

const char *llvm::dwarf::ConventionString(llvm::dwarf *this)
{
  if ((int)this <= 175)
  {
    switch((int)this)
    {
      case 1:
        uint64_t result = "DW_CC_normal";
        break;
      case 2:
        uint64_t result = "DW_CC_program";
        break;
      case 3:
        uint64_t result = "DW_CC_nocall";
        break;
      case 4:
        uint64_t result = "DW_CC_pass_by_reference";
        break;
      case 5:
        uint64_t result = "DW_CC_pass_by_value";
        break;
      default:
        uint64_t v3 = "DW_CC_GNU_borland_fastcall_i386";
        if (this != 65) {
          uint64_t v3 = 0;
        }
        if (this == 64) {
          uint64_t result = "DW_CC_GNU_renesas_sh";
        }
        else {
          uint64_t result = v3;
        }
        break;
    }
  }
  else
  {
    int v1 = this - 176;
    uint64_t result = 0;
    switch(v1)
    {
      case 0:
        uint64_t result = "DW_CC_BORLAND_safecall";
        break;
      case 1:
        uint64_t result = "DW_CC_BORLAND_stdcall";
        break;
      case 2:
        uint64_t result = "DW_CC_BORLAND_pascal";
        break;
      case 3:
        uint64_t result = "DW_CC_BORLAND_msfastcall";
        break;
      case 4:
        uint64_t result = "DW_CC_BORLAND_msreturn";
        break;
      case 5:
        uint64_t result = "DW_CC_BORLAND_thiscall";
        break;
      case 6:
        uint64_t result = "DW_CC_BORLAND_fastcall";
        break;
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 29:
      case 30:
      case 31:
        return result;
      case 16:
        uint64_t result = "DW_CC_LLVM_vectorcall";
        break;
      case 17:
        uint64_t result = "DW_CC_LLVM_Win64";
        break;
      case 18:
        uint64_t result = "DW_CC_LLVM_X86_64SysV";
        break;
      case 19:
        uint64_t result = "DW_CC_LLVM_AAPCS";
        break;
      case 20:
        uint64_t result = "DW_CC_LLVM_AAPCS_VFP";
        break;
      case 21:
        uint64_t result = "DW_CC_LLVM_IntelOclBicc";
        break;
      case 22:
        uint64_t result = "DW_CC_LLVM_SpirFunction";
        break;
      case 23:
        uint64_t result = "DW_CC_LLVM_OpenCLKernel";
        break;
      case 24:
        uint64_t result = "DW_CC_LLVM_Swift";
        break;
      case 25:
        uint64_t result = "DW_CC_LLVM_PreserveMost";
        break;
      case 26:
        uint64_t result = "DW_CC_LLVM_PreserveAll";
        break;
      case 27:
        uint64_t result = "DW_CC_LLVM_X86RegCall";
        break;
      case 28:
        uint64_t result = "DW_CC_LLVM_SwiftTail";
        break;
      case 32:
        uint64_t result = "DW_CC_LLVM_AGX_thread_invariant";
        break;
      default:
        uint64_t result = 0;
        break;
    }
  }
  return result;
}

char *llvm::dwarf::LNStandardString(llvm::dwarf *this)
{
  if (this > 0xC) {
    return 0;
  }
  else {
    return off_1E682E5F0[(int)this];
  }
}

char *llvm::dwarf::LNExtendedString(llvm::dwarf *this)
{
  if ((this - 1) > 3) {
    return 0;
  }
  else {
    return off_1E682E658[(int)this - 1];
  }
}

const char *llvm::dwarf::MacinfoString(llvm::dwarf *this)
{
  int v1 = this + 1;
  uint64_t result = 0;
  switch(v1)
  {
    case 0:
      uint64_t result = "DW_MACINFO_invalid";
      break;
    case 1:
      return result;
    case 2:
      uint64_t result = "DW_MACINFO_define";
      break;
    case 3:
      uint64_t result = "DW_MACINFO_undef";
      break;
    case 4:
      uint64_t result = "DW_MACINFO_start_file";
      break;
    case 5:
      uint64_t result = "DW_MACINFO_end_file";
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

char *llvm::dwarf::MacroString(llvm::dwarf *this)
{
  if ((this - 1) > 0xB) {
    return 0;
  }
  else {
    return off_1E682E678[(int)this - 1];
  }
}

char *llvm::dwarf::GnuMacroString(llvm::dwarf *this)
{
  if ((this - 1) > 9) {
    return 0;
  }
  else {
    return off_1E682E6D8[(int)this - 1];
  }
}

char *llvm::dwarf::RangeListEncodingString(llvm::dwarf *this)
{
  if (this > 7) {
    return 0;
  }
  else {
    return off_1E682E910[(int)this];
  }
}

char *llvm::dwarf::LocListEncodingString(llvm::dwarf *this)
{
  if (this > 8) {
    return 0;
  }
  else {
    return off_1E682E728[(int)this];
  }
}

const char *llvm::dwarf::ApplePropertyString(llvm::dwarf *this)
{
  int v1 = (int)this;
  uint64_t result = 0;
  if (v1 > 255)
  {
    if (v1 <= 2047)
    {
      __int16 v11 = "DW_APPLE_PROPERTY_weak";
      int v12 = "DW_APPLE_PROPERTY_strong";
      if (v1 != 1024) {
        int v12 = 0;
      }
      if (v1 != 512) {
        __int16 v11 = v12;
      }
      if (v1 == 256) {
        return "DW_APPLE_PROPERTY_atomic";
      }
      else {
        return v11;
      }
    }
    else
    {
      uint64_t v3 = "DW_APPLE_PROPERTY_null_resettable";
      uint64_t v4 = "DW_APPLE_PROPERTY_class";
      if (v1 != 0x4000) {
        uint64_t v4 = 0;
      }
      if (v1 != 0x2000) {
        uint64_t v3 = v4;
      }
      uint64_t v5 = "DW_APPLE_PROPERTY_unsafe_unretained";
      int v6 = "DW_APPLE_PROPERTY_nullability";
      if (v1 != 4096) {
        int v6 = 0;
      }
      if (v1 != 2048) {
        uint64_t v5 = v6;
      }
      if (v1 < 0x2000) {
        return v5;
      }
      else {
        return v3;
      }
    }
  }
  else if (v1 > 15)
  {
    unint64_t v7 = "DW_APPLE_PROPERTY_nonatomic";
    unint64_t v8 = "DW_APPLE_PROPERTY_setter";
    if (v1 != 128) {
      unint64_t v8 = 0;
    }
    if (v1 != 64) {
      unint64_t v7 = v8;
    }
    __int16 v9 = "DW_APPLE_PROPERTY_retain";
    uint64_t v10 = "DW_APPLE_PROPERTY_copy";
    if (v1 != 32) {
      uint64_t v10 = 0;
    }
    if (v1 != 16) {
      __int16 v9 = v10;
    }
    if (v1 <= 63) {
      return v9;
    }
    else {
      return v7;
    }
  }
  else
  {
    switch(v1)
    {
      case 1:
        uint64_t result = "DW_APPLE_PROPERTY_readonly";
        break;
      case 2:
        uint64_t result = "DW_APPLE_PROPERTY_getter";
        break;
      case 4:
        uint64_t result = "DW_APPLE_PROPERTY_assign";
        break;
      case 8:
        uint64_t result = "DW_APPLE_PROPERTY_readwrite";
        break;
      default:
        return result;
    }
  }
  return result;
}

char *llvm::dwarf::UnitTypeString(llvm::dwarf *this)
{
  if ((this - 1) > 5) {
    return 0;
  }
  else {
    return off_1E682E770[(int)this - 1];
  }
}