void sub_1CC43DA08(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unsigned int v5;
  void *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  __int16 v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  BOOL v24;
  int v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  uint64_t v40;
  unint64_t *v41;
  uint64_t v42;
  unint64_t *v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  char *v47;
  uint64_t v48;
  unint64_t *v49;
  int v50;
  BOOL v51;
  unsigned int v52;
  unint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  unsigned int v57;
  int v58;
  char v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  int v64;
  uint64_t v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int *v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  BOOL v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  int v92;
  int v93;
  void *v94;
  __int16 v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unsigned int v99;
  int v100;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  int v107;
  int v108;
  int v109;
  unsigned int v110;
  uint64_t v111;
  unint64_t v112;
  unsigned int v113;
  uint64_t v114;
  unint64_t v115;
  __int16 v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unsigned int v120;
  int v121;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  int v129;
  int v130;
  unsigned int v131;
  void *v132;
  uint64_t v133;
  unsigned int v134;
  unsigned int v135;
  void *v136;
  unint64_t v137;
  unint64_t v138;
  uint64_t v139;
  BOOL v140;
  unint64_t v141;
  BOOL v142;
  unsigned int v144;
  uint64_t v145;
  unsigned int v146;
  uint64_t v148;
  uint64_t v149;
  unsigned int v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  unsigned int v154;
  char *v155;
  char *v156;
  uint64_t v157;
  int v158;
  unsigned char v159[64];
  _DWORD *v160;
  uint64_t v161;
  void v162[6];

  v5 = a2;
  v6 = (void *)a1;
  v162[4] = *MEMORY[0x1E4F143B8];
  v7 = a3 - 1;
  v144 = a3;
  v150 = a3 - 1;
  if (a3 - 1 < 0x3FFFFFFF)
  {
    v8 = 0;
    goto LABEL_40;
  }
  v9 = *(void *)(a1 + 288);
  v10 = a3 & 0x7FFFFFFF;
  v11 = (void *)(v9 + 408);
  v12 = *(unsigned int *)(v9 + 416);
  v140 = v10 >= v12;
  v13 = v10 - v12;
  if (v140)
  {
    sub_1CB9153B8((uint64_t)v11, v13 + 1, *(void *)(v9 + 424));
LABEL_237:
    llvm::LiveIntervals::createInterval();
  }
  v8 = *(void *)(*v11 + 8 * v10);
  if (!v8) {
    goto LABEL_237;
  }
  if (*(void *)(v8 + 104)) {
    v14 = a3 == a2;
  }
  else {
    v14 = 1;
  }
  if (!v14)
  {
    v15 = *(void *)(a1 + 264);
    v16 = (uint64_t *)((a3 & 0x80000000) != 0 ? *(void *)(v15 + 24) + 16 * v10 + 8 : *(void *)(v15 + 272) + 8 * a3);
    v17 = *v16;
    if (*v16)
    {
      while (1)
      {
        if ((*(_DWORD *)v17 & 0x10000000) != 0) {
          goto LABEL_33;
        }
        v18 = (*(_DWORD *)v17 >> 8) & 0xFFF;
        if (!v18) {
          goto LABEL_33;
        }
        v19 = *(void *)(v17 + 8);
        if (**(unsigned __int16 **)(v19 + 16) - 13 < 5) {
          goto LABEL_33;
        }
        v20 = *(_WORD *)(v19 + 44);
        v21 = *(void *)(v17 + 8);
        if ((v20 & 4) != 0)
        {
          do
            v21 = *(void *)v21 & 0xFFFFFFFFFFFFFFF8;
          while ((*(_WORD *)(v21 + 44) & 4) != 0);
        }
        if ((v20 & 8) != 0)
        {
          do
            v19 = *(void *)(v19 + 8);
          while ((*(_WORD *)(v19 + 44) & 8) != 0);
        }
        v22 = *(void *)(v19 + 8);
        if (v21 != v22)
        {
          while (1)
          {
            v23 = **(unsigned __int16 **)(v21 + 16);
            v24 = v23 > 0x17;
            v25 = (1 << v23) & 0x83E000;
            if (v24 || v25 == 0) {
              break;
            }
            v21 = *(void *)(v21 + 8);
            if (v21 == v22)
            {
              v21 = v22;
              break;
            }
          }
        }
        v27 = *(void *)(*(void *)(a1 + 288) + 288);
        v28 = *(void *)(v27 + 368);
        v29 = *(unsigned int *)(v27 + 384);
        if (!v29) {
          goto LABEL_31;
        }
        LODWORD(v30) = ((v21 >> 4) ^ (v21 >> 9)) & (v29 - 1);
        v31 = (uint64_t *)(v28 + 16 * v30);
        v32 = *v31;
        if (v21 != *v31) {
          break;
        }
LABEL_32:
        sub_1CC441F6C(a1, v8, v31[1] & 0xFFFFFFFFFFFFFFF8 | 2, (int *)v17, v18);
LABEL_33:
        v17 = *(void *)(v17 + 24);
        if (!v17)
        {
          v5 = a2;
          a3 = v144;
          goto LABEL_39;
        }
      }
      v33 = 1;
      while (v32 != -4096)
      {
        v34 = v30 + v33++;
        v30 = v34 & (v29 - 1);
        v32 = *(void *)(v28 + 16 * v30);
        if (v21 == v32)
        {
          v31 = (uint64_t *)(v28 + 16 * v30);
          goto LABEL_32;
        }
      }
LABEL_31:
      v31 = (uint64_t *)(v28 + 16 * v29);
      goto LABEL_32;
    }
  }
LABEL_39:
  v6 = (void *)a1;
  v7 = v150;
LABEL_40:
  v155 = v159;
  v156 = v159;
  v157 = 8;
  v158 = 0;
  v35 = v6[33];
  if ((v5 & 0x80000000) != 0) {
    v36 = (uint64_t *)(*(void *)(v35 + 24) + 16 * (v5 & 0x7FFFFFFF) + 8);
  }
  else {
    v36 = (uint64_t *)(*(void *)(v35 + 272) + 8 * v5);
  }
  v37 = *v36;
  if (*v36)
  {
    v142 = v7 > 0x3FFFFFFE;
    v153 = v8;
    v154 = a3;
    v152 = 16 * (a3 & 0x7FFFFFFF);
    v145 = a4;
    v146 = a4;
    while (1)
    {
      v38 = *(void *)(v37 + 8);
      do
        v37 = *(void *)(v37 + 24);
      while (v37 && *(void *)(v37 + 8) == v38);
      if (v5 != a3) {
        goto LABEL_81;
      }
      v39 = v156;
      v40 = HIDWORD(v157);
      if (v156 == v155)
      {
        if (HIDWORD(v157))
        {
          v41 = 0;
          v42 = 8 * HIDWORD(v157);
          v43 = (unint64_t *)v156;
          do
          {
            if (*v43 == v38) {
              goto LABEL_222;
            }
            if (*v43 == -2) {
              v41 = v43;
            }
            ++v43;
            v42 -= 8;
          }
          while (v42);
          if (v41)
          {
            *v41 = v38;
            --v158;
            goto LABEL_81;
          }
        }
        v44 = v157;
        if (HIDWORD(v157) < v157)
        {
          ++HIDWORD(v157);
          *(void *)&v156[8 * v40] = v38;
          goto LABEL_81;
        }
      }
      else
      {
        v44 = v157;
      }
      if (3 * v44 <= 4 * (HIDWORD(v157) - v158)) {
        break;
      }
      if (v44 - HIDWORD(v157) < v44 >> 3) {
        goto LABEL_228;
      }
LABEL_62:
      v45 = v44 - 1;
      v46 = (v44 - 1) & ((v38 >> 4) ^ (v38 >> 9));
      v47 = &v39[8 * v46];
      v48 = *(void *)v47;
      if (*(void *)v47 == -1)
      {
        v49 = 0;
      }
      else
      {
        v49 = 0;
        v50 = 1;
        do
        {
          if (v48 == v38) {
            goto LABEL_222;
          }
          if (v49) {
            v51 = 0;
          }
          else {
            v51 = v48 == -2;
          }
          if (v51) {
            v49 = (unint64_t *)v47;
          }
          v52 = v46 + v50++;
          v46 = v52 & v45;
          v47 = &v39[8 * (v52 & v45)];
          v48 = *(void *)v47;
        }
        while (*(void *)v47 != -1);
      }
      if (v49) {
        v53 = v49;
      }
      else {
        v53 = (unint64_t *)v47;
      }
      if (*v53 != v38)
      {
        if (*v53 == -2) {
          --v158;
        }
        else {
          ++HIDWORD(v157);
        }
        *v53 = v38;
LABEL_81:
        v160 = v162;
        v161 = 0x800000000;
        v54 = *(unsigned int *)(v38 + 40);
        if (v54)
        {
          v55 = 0;
          v56 = 0;
          v57 = 0;
          v58 = 0;
          v59 = 0;
          v60 = 0;
          v61 = 32 * v54;
          do
          {
            v62 = *(void *)(v38 + 32);
            if (!*(unsigned char *)(v62 + v55) && *(_DWORD *)(v62 + v55 + 4) == v5)
            {
              if (v57 >= HIDWORD(v161)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v160[v57] = v56;
              v57 = v161 + 1;
              LODWORD(v161) = v161 + 1;
              v63 = *(_DWORD *)(v62 + v55);
              if ((v63 & 0x1000000) != 0)
              {
                v14 = (v63 & 0xFFF00) == 0;
                v64 = (v63 >> 28) & 1;
                if (v14) {
                  v64 = 1;
                }
                v60 |= v64;
                v58 |= v64 ^ 1;
              }
              else
              {
                v59 |= (v63 & 0x10000000) == 0;
              }
            }
            ++v56;
            v55 += 32;
          }
          while (v61 != v55);
          if (v59)
          {
            LOBYTE(v65) = 1;
            v6 = (void *)a1;
LABEL_103:
            v66 = v150;
            if (!v57) {
              goto LABEL_219;
            }
LABEL_104:
            v67 = 0;
            if (v65) {
              v68 = 0;
            }
            else {
              v68 = 0x10000000;
            }
            v151 = v68;
            v69 = v57;
LABEL_108:
            v70 = (int *)(*(void *)(v38 + 32) + 32 * v160[v67]);
            v71 = *v70;
            if (a4)
            {
              if ((v71 & 0x1000000) != 0)
              {
                v71 = v71 & 0xEFFFFFFF | v151;
                *v70 = v71;
              }
              if (v66 < 0x3FFFFFFF || (v71 & 0x1000000) != 0) {
                goto LABEL_163;
              }
              v72 = a4;
              if (((v71 >> 8) & 0xFFF) != 0)
              {
                v72 = (*(uint64_t (**)(void, uint64_t))(*(void *)v6[34] + 208))(v6[34], a4);
                if (!v72) {
                  goto LABEL_165;
                }
              }
            }
            else
            {
              if (v66 < 0x3FFFFFFF || (v71 & 0x1000000) != 0) {
                goto LABEL_163;
              }
              v72 = (v71 >> 8) & 0xFFF;
              if (!v72) {
                goto LABEL_165;
              }
            }
            v73 = v6[33];
            v74 = *(void *)(v73 + 24);
            if (*(unsigned char *)(v73 + 16)) {
              v75 = *(unsigned char *)((*(void *)(v74 + v152) & 0xFFFFFFFFFFFFFFF8) + 34) == 0;
            }
            else {
              v75 = 1;
            }
            if (v75) {
              goto LABEL_165;
            }
            v76 = v6[36];
            if (!*(void *)(v153 + 104))
            {
              v149 = *(void *)(*(void *)(v6[34] + 232) + 8 * v145);
              v77 = *(void *)((*(void *)(v74 + 16 * (*(_DWORD *)(v153 + 112) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8)
                              + 24);
              *(void *)(v76 + 392) += 120;
              v78 = *(void *)(v76 + 312);
              v148 = v77;
              if (((v78 + 7) & 0xFFFFFFFFFFFFFFF8) - v78 + 120 > *(void *)(v76 + 320) - v78)
              {
                v110 = *(_DWORD *)(v76 + 336) >> 7;
                if (v110 >= 0x1E) {
                  LOBYTE(v110) = 30;
                }
                v111 = 4096 << v110;
                v79 = operator new(4096 << v110, (std::align_val_t)8uLL);
                v112 = *(unsigned int *)(v76 + 336);
                if (v112 >= *(unsigned int *)(v76 + 340)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*(void *)(v76 + 328) + 8 * v112) = v79;
                ++*(_DWORD *)(v76 + 336);
                *(void *)(v76 + 320) = (char *)v79 + v111;
              }
              else
              {
                v79 = (void *)((v78 + 7) & 0xFFFFFFFFFFFFFFF8);
              }
              *(void *)(v76 + 312) = v79 + 15;
              *v79 = v79 + 2;
              v79[1] = 0x200000000;
              v79[8] = v79 + 10;
              v79[9] = 0x200000000;
              v79[12] = 0;
              sub_1CC2CD2F8((uint64_t)v79, v153, v76 + 312);
              v80 = v149;
              v79[14] = v149;
              v79[13] = *(void *)(v153 + 104);
              *(void *)(v153 + 104) = v79;
              *(void *)(v76 + 392) += 120;
              v81 = *(void *)(v76 + 312);
              if (((v81 + 7) & 0xFFFFFFFFFFFFFFF8) - v81 + 120 > *(void *)(v76 + 320) - v81)
              {
                v113 = *(_DWORD *)(v76 + 336) >> 7;
                if (v113 >= 0x1E) {
                  LOBYTE(v113) = 30;
                }
                v114 = 4096 << v113;
                v82 = operator new(4096 << v113, (std::align_val_t)8uLL);
                v115 = *(unsigned int *)(v76 + 336);
                if (v115 >= *(unsigned int *)(v76 + 340)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v83 = v148;
                v80 = v149;
                *(void *)(*(void *)(v76 + 328) + 8 * v115) = v82;
                ++*(_DWORD *)(v76 + 336);
                *(void *)(v76 + 320) = (char *)v82 + v114;
                v79 = *(void **)(v153 + 104);
              }
              else
              {
                v82 = (void *)((v81 + 7) & 0xFFFFFFFFFFFFFFF8);
                v83 = v148;
              }
              *(void *)(v76 + 312) = v82 + 15;
              *v82 = v82 + 2;
              v82[1] = 0x200000000;
              v82[8] = v82 + 10;
              v82[9] = 0x200000000;
              v82[13] = v79;
              v82[14] = v83 & ~v80;
              v82[12] = 0;
              *(void *)(v153 + 104) = v82;
              v6 = (void *)a1;
              v76 = *(void *)(a1 + 288);
              a4 = v146;
            }
            v84 = *(void *)(v76 + 288);
            if (**(unsigned __int16 **)(v38 + 16) - 13 > 4)
            {
              v95 = *(_WORD *)(v38 + 44);
              v96 = v38;
              v66 = v150;
              if ((v95 & 4) != 0)
              {
                do
                  v96 = *(void *)v96 & 0xFFFFFFFFFFFFFFF8;
                while ((*(_WORD *)(v96 + 44) & 4) != 0);
              }
              v97 = v38;
              if ((v95 & 8) != 0)
              {
                do
                  v97 = *(void *)(v97 + 8);
                while ((*(_WORD *)(v97 + 44) & 8) != 0);
              }
              v98 = *(void *)(v97 + 8);
              if (v96 != v98)
              {
                do
                {
                  v99 = **(unsigned __int16 **)(v96 + 16);
                  v24 = v99 > 0x17;
                  v100 = (1 << v99) & 0x83E000;
                  if (v24 || v100 == 0) {
                    goto LABEL_154;
                  }
                  v96 = *(void *)(v96 + 8);
                }
                while (v96 != v98);
                v96 = v98;
              }
LABEL_154:
              v102 = *(void *)(v84 + 368);
              v103 = *(unsigned int *)(v84 + 384);
              if (v103)
              {
                LODWORD(v104) = ((v96 >> 4) ^ (v96 >> 9)) & (v103 - 1);
                v105 = (uint64_t *)(v102 + 16 * v104);
                v106 = *v105;
                if (v96 != *v105)
                {
                  v107 = 1;
                  do
                  {
                    if (v106 == -4096) {
                      goto LABEL_160;
                    }
                    v108 = v104 + v107++;
                    v104 = v108 & (v103 - 1);
                    v106 = *(void *)(v102 + 16 * v104);
                  }
                  while (v96 != v106);
                  v105 = (uint64_t *)(v102 + 16 * v104);
                }
              }
              else
              {
LABEL_160:
                v105 = (uint64_t *)(v102 + 16 * v103);
              }
              v94 = v105 + 1;
              goto LABEL_162;
            }
            v85 = *(void *)(v38 + 24);
            v86 = v38;
            v66 = v150;
            while (1)
            {
              if (v86 == *(void *)(v85 + 56))
              {
                v94 = (void *)(*(void *)(v84 + 392) + 16 * *(unsigned int *)(v85 + 24));
LABEL_162:
                sub_1CC441F6C((uint64_t)v6, v153, *v94 & 0xFFFFFFFFFFFFFFF8 | 2, v70, v72);
LABEL_163:
                if (v66 <= 0x3FFFFFFE)
                {
                  llvm::MachineOperand::substPhysReg((unsigned int *)v70, v154, v6[34]);
                  goto LABEL_170;
                }
LABEL_165:
                if (!a4)
                {
                  llvm::MachineOperand::setReg((uint64_t)v70, v154);
                  goto LABEL_170;
                }
                if (((*v70 >> 8) & 0xFFF) == 0)
                {
                  llvm::MachineOperand::setReg((uint64_t)v70, v154);
                  LOWORD(v109) = a4;
                  goto LABEL_169;
                }
                v109 = (*(uint64_t (**)(void, uint64_t))(*(void *)v6[34] + 208))(v6[34], a4);
                llvm::MachineOperand::setReg((uint64_t)v70, v154);
                if (v109) {
LABEL_169:
                }
                  *v70 = *v70 & 0xFFF000FF | ((v109 & 0xFFF) << 8);
LABEL_170:
                if (++v67 == v69)
                {
LABEL_219:
                  if (v160 != (_DWORD *)v162) {
                    free(v160);
                  }
                  v5 = a2;
                  a3 = v144;
                  goto LABEL_222;
                }
                goto LABEL_108;
              }
              v86 = *(void *)v86 & 0xFFFFFFFFFFFFFFF8;
              if (!v86 || (*(unsigned char *)v86 & 4) == 0)
              {
                while ((*(_WORD *)(v86 + 44) & 4) != 0)
                  v86 = *(void *)v86 & 0xFFFFFFFFFFFFFFF8;
              }
              v87 = *(void *)(v84 + 368);
              v88 = *(unsigned int *)(v84 + 384);
              if (!v88) {
                goto LABEL_142;
              }
              LODWORD(v89) = ((v86 >> 4) ^ (v86 >> 9)) & (v88 - 1);
              v90 = (uint64_t *)(v87 + 16 * v89);
              v91 = *v90;
              if (v86 != *v90) {
                break;
              }
LABEL_143:
              if (v90 != (uint64_t *)(v87 + 16 * v88))
              {
                v94 = v90 + 1;
                goto LABEL_162;
              }
            }
            v92 = 1;
            while (v91 != -4096)
            {
              v93 = v89 + v92++;
              v89 = v93 & (v88 - 1);
              v91 = *(void *)(v87 + 16 * v89);
              if (v86 == v91)
              {
                v90 = (uint64_t *)(v87 + 16 * v89);
                goto LABEL_143;
              }
            }
LABEL_142:
            v90 = (uint64_t *)(v87 + 16 * v88);
            goto LABEL_143;
          }
          v6 = (void *)a1;
        }
        else
        {
          v57 = 0;
          v58 = 0;
          v60 = 0;
        }
        LODWORD(v65) = v58 & (v60 ^ 1);
        if (((v142 && a4 != 0) & (v65 ^ 1)) != 1) {
          goto LABEL_103;
        }
        v66 = v150;
        if (**(unsigned __int16 **)(v38 + 16) - 13 < 5)
        {
LABEL_101:
          LOBYTE(v65) = 0;
          if (!v57) {
            goto LABEL_219;
          }
          goto LABEL_104;
        }
        v116 = *(_WORD *)(v38 + 44);
        v117 = v38;
        if ((v116 & 4) != 0)
        {
          do
            v117 = *(void *)v117 & 0xFFFFFFFFFFFFFFF8;
          while ((*(_WORD *)(v117 + 44) & 4) != 0);
        }
        v118 = v38;
        if ((v116 & 8) != 0)
        {
          do
            v118 = *(void *)(v118 + 8);
          while ((*(_WORD *)(v118 + 44) & 8) != 0);
        }
        v119 = *(void *)(v118 + 8);
        if (v117 != v119)
        {
          do
          {
            v120 = **(unsigned __int16 **)(v117 + 16);
            v24 = v120 > 0x17;
            v121 = (1 << v120) & 0x83E000;
            if (v24 || v121 == 0) {
              goto LABEL_198;
            }
            v117 = *(void *)(v117 + 8);
          }
          while (v117 != v119);
          v117 = v119;
        }
LABEL_198:
        v123 = *(void *)(v6[36] + 288);
        v124 = *(void *)(v123 + 368);
        v125 = *(unsigned int *)(v123 + 384);
        if (v125)
        {
          LODWORD(v126) = ((v117 >> 4) ^ (v117 >> 9)) & (v125 - 1);
          v127 = (uint64_t *)(v124 + 16 * v126);
          v128 = *v127;
          if (v117 != *v127)
          {
            v129 = 1;
            do
            {
              if (v128 == -4096) {
                goto LABEL_205;
              }
              v130 = v126 + v129++;
              v126 = v130 & (v125 - 1);
              v128 = *(void *)(v124 + 16 * v126);
            }
            while (v117 != v128);
            v127 = (uint64_t *)(v124 + 16 * v126);
          }
        }
        else
        {
LABEL_205:
          v127 = (uint64_t *)(v124 + 16 * v125);
        }
        v65 = v127[1];
        v131 = *(_DWORD *)(v153 + 8);
        v132 = *(void **)v153;
        if (v131)
        {
          v133 = v132[3 * v131 - 2];
          v134 = *(_DWORD *)((v65 & 0xFFFFFFFFFFFFFFF8) + 24) | (v65 >> 1) & 3;
          v135 = (v133 >> 1) & 3 | *(_DWORD *)((v133 & 0xFFFFFFFFFFFFFFF8) + 24);
          v136 = *(void **)v153;
          v137 = *(unsigned int *)(v153 + 8);
          if (v134 < v135)
          {
            do
            {
              v138 = v137 >> 1;
              v139 = v136[3 * (v137 >> 1) + 1];
              LODWORD(v139) = (v139 >> 1) & 3 | *(_DWORD *)((v139 & 0xFFFFFFFFFFFFFFF8) + 24);
              v137 -= (v137 >> 1) + 1;
              v140 = v134 >= v139;
              if (v134 >= v139) {
                v141 = v138 + 1;
              }
              else {
                v141 = 0;
              }
              v136 += 3 * v141;
              if (!v140) {
                v137 = v138;
              }
            }
            while (v137);
LABEL_217:
            if (v136 != &v132[3 * v131])
            {
              LOBYTE(v65) = ((*v136 >> 1) & 3 | *(_DWORD *)((*v136 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((v65 & 0xFFFFFFFFFFFFFFF8) + 24) | (v65 >> 1) & 3);
              if (!v57) {
                goto LABEL_219;
              }
              goto LABEL_104;
            }
            goto LABEL_101;
          }
        }
        else
        {
          v131 = 0;
        }
        v136 = &v132[3 * v131];
        goto LABEL_217;
      }
LABEL_222:
      if (!v37)
      {
        if (v156 != v155) {
          free(v156);
        }
        return;
      }
    }
    if (v44 >= 0x40) {
      v44 *= 2;
    }
    else {
      v44 = 128;
    }
LABEL_228:
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v155, v44);
    v5 = a2;
    a3 = v144;
    v44 = v157;
    v39 = v156;
    goto LABEL_62;
  }
}

uint64_t sub_1CC43E7DC(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char a11)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(void *)(a1 + 16) = a5;
  *(unsigned char *)(a1 + 24) = a10;
  *(unsigned char *)(a1 + 25) = a11;
  *(void *)(a1 + 32) = a6;
  *(void *)(a1 + 40) = a7;
  uint64_t v13 = *(void *)(a8 + 288);
  *(void *)(a1 + 48) = a8;
  *(void *)(a1 + 56) = v13;
  *(void *)(a1 + 64) = a9;
  *(void *)(a1 + 72) = a1 + 88;
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  *(_DWORD *)(a1 + 84) = 8;
  if (v14 >= 9)
  {
    *(_DWORD *)(a1 + 80) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v14) {
    memset((void *)(a1 + 88), 255, 4 * v14);
  }
  *(void *)(a1 + 120) = a1 + 136;
  *(_DWORD *)(a1 + 80) = v14;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  *(_DWORD *)(a1 + 132) = 8;
  if (v15 >= 9)
  {
    *(_DWORD *)(a1 + 128) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v15) {
    bzero((void *)(a1 + 136), 48 * v15);
  }
  *(_DWORD *)(a1 + 128) = v15;
  return a1;
}

uint64_t sub_1CC43E8E4(void *a1, uint64_t **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(*a1 + 72);
  if (!v4) {
    return 1;
  }
  uint64_t v6 = 0;
  v79 = a2;
  uint64_t v76 = *(unsigned int *)(*a1 + 72);
  while (1)
  {
    uint64_t v7 = a1[15];
    v8 = (_DWORD *)(v7 + 48 * v6);
    if (*v8 == 4) {
      break;
    }
LABEL_112:
    if (++v6 == v4) {
      return 1;
    }
  }
  if (*((unsigned char *)a1 + 24)) {
    return 0;
  }
  uint64_t v9 = *(void *)(*(void *)(*a1 + 64) + 8 * v6);
  uint64_t v10 = v7 + 48 * v6;
  uint64_t v11 = a2[15][6 * **(unsigned int **)(v10 + 32) + 2];
  uint64_t v12 = *(void *)(v10 + 8);
  int v80 = 0;
  uint64_t v13 = a1[7];
  unint64_t v14 = *(void *)(v9 + 8);
  if (v14 >= 8 && (uint64_t v15 = *(void *)((v14 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
  {
    v16 = (void *)(v15 + 24);
  }
  else
  {
    uint64_t v41 = *(unsigned int *)(v13 + 544);
    if (v41)
    {
      unsigned int v42 = *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24) | (v14 >> 1) & 3;
      v43 = *(void **)(v13 + 536);
      unint64_t v44 = *(unsigned int *)(v13 + 544);
      do
      {
        unint64_t v45 = v44 >> 1;
        v46 = &v43[2 * (v44 >> 1)];
        uint64_t v48 = *v46;
        v47 = v46 + 2;
        a4 = (v48 >> 1) & 3 | *(_DWORD *)((v48 & 0xFFFFFFFFFFFFFFF8) + 24);
        v44 += ~(v44 >> 1);
        if (a4 < v42) {
          v43 = v47;
        }
        else {
          unint64_t v44 = v45;
        }
      }
      while (v44);
      if (v43 == (void *)(*(void *)(v13 + 536) + 16 * v41)
        || ((*v43 >> 1) & 3 | *(_DWORD *)((*v43 & 0xFFFFFFFFFFFFFFF8) + 24)) > v42)
      {
        v43 -= 2;
      }
    }
    else
    {
      v43 = *(void **)(v13 + 536);
    }
    v16 = v43 + 1;
  }
  uint64_t v17 = *(void *)(*(void *)(v13 + 392) + 16 * *(unsigned int *)(*v16 + 24) + 8);
  unint64_t v18 = *((unsigned int *)*a2 + 2);
  uint64_t v19 = **a2;
  v77 = v8;
  uint64_t v78 = v6;
  if (v18)
  {
    uint64_t v20 = *(void *)(v19 + 24 * v18 - 16);
    unsigned int v21 = *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24) | (v14 >> 1) & 3;
    if (v21 < ((v20 >> 1) & 3 | *(_DWORD *)((v20 & 0xFFFFFFFFFFFFFFF8) + 24)))
    {
      do
      {
        unint64_t v22 = v18 >> 1;
        uint64_t v23 = *(void *)(v19 + 24 * (v18 >> 1) + 8);
        LODWORD(v23) = (v23 >> 1) & 3 | *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFF8) + 24);
        v18 -= (v18 >> 1) + 1;
        BOOL v24 = v21 >= v23;
        if (v21 >= v23) {
          unint64_t v25 = v22 + 1;
        }
        else {
          unint64_t v25 = 0;
        }
        v19 += 24 * v25;
        if (!v24) {
          unint64_t v18 = v22;
        }
      }
      while (v18);
      goto LABEL_19;
    }
  }
  else
  {
    LODWORD(v18) = 0;
  }
  v19 += 24 * v18;
LABEL_19:
  unsigned int v26 = 0;
  uint64_t v27 = v12 & v11;
  unsigned int v28 = (v17 >> 1) & 3;
  int v29 = *(_DWORD *)((v17 & 0xFFFFFFFFFFFFFFF8) + 24);
  uint64_t v30 = v19 + 24;
  uint64_t v31 = v27;
  while (1)
  {
    uint64_t v32 = *(void *)(v30 - 16);
    if (((v32 >> 1) & 3 | *(_DWORD *)((v32 & 0xFFFFFFFFFFFFFFF8) + 24)) >= (v29 | v28)) {
      break;
    }
    if ((~(_BYTE)v32 & 6) != 0)
    {
      if (v26 >= 8) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v33 = &v81[v26];
      void *v33 = v32;
      v33[1] = v31;
      unsigned int v26 = ++v80;
      if (v30 != **a2 + 24 * *((unsigned int *)*a2 + 2))
      {
        int v29 = *(_DWORD *)((v17 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (((*(void *)v30 >> 1) & 3 | *(_DWORD *)((*(void *)v30 & 0xFFFFFFFFFFFFFFF8) + 24)) < (v29 | v28))
        {
          uint64_t v34 = (uint64_t)&a2[15][6 * **(unsigned int **)(v30 + 16)];
          v31 &= ~*(void *)(v34 + 8);
          v30 += 24;
          if (*(void *)(v34 + 24) && v31 != 0) {
            continue;
          }
        }
      }
    }
    uint64_t v36 = a1[7];
    unint64_t v37 = *(void *)(v9 + 8);
    if (v37 >= 8)
    {
      uint64_t v38 = *(void *)((v37 & 0xFFFFFFFFFFFFFFF8) + 16);
      if (v38)
      {
        uint64_t v39 = *(void *)(v9 + 8) & 6;
        if ((v37 & 6) != 0) {
          goto LABEL_35;
        }
        uint64_t v40 = *(void *)(v38 + 24);
LABEL_40:
        uint64_t v38 = *(void *)(v40 + 56);
LABEL_69:
        if (*(void *)&v81[0] < 8uLL) {
          uint64_t v58 = 0;
        }
        else {
          uint64_t v58 = *(void *)((*(void *)&v81[0] & 0xFFFFFFFFFFFFFFF8) + 16);
        }
        LODWORD(v59) = 0;
        while (2)
        {
          int v60 = **(unsigned __int16 **)(v38 + 16);
          if ((v60 - 13) >= 5 && v60 != 23)
          {
            uint64_t v63 = *(unsigned int *)(v38 + 40);
            if (v63)
            {
              int v65 = *((_DWORD *)a2 + 2);
              uint64_t v64 = *((unsigned int *)a2 + 3);
              uint64_t v66 = 32 * v63;
              v67 = (_DWORD *)(*(void *)(v38 + 32) + 4);
              do
              {
                unsigned int v68 = *(v67 - 1);
                if ((v68 & 0x10000FF) == 0)
                {
                  BOOL v69 = (v68 & 0x10FFF00) != 0x1000000 && (v68 & 0x30000000) == 0;
                  if (v69 && *v67 == v65)
                  {
                    v71 = (void *)a1[8];
                    uint64_t v72 = (v68 >> 8) & 0xFFF;
                    if (v64)
                    {
                      if (v72)
                      {
                        int v73 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v71 + 208))(v71, v64, v72, a4, 24, 17825536, 0x1000000);
                        a2 = v79;
                        LODWORD(v72) = v73;
                        v71 = (void *)a1[8];
                      }
                      else
                      {
                        LODWORD(v72) = v64;
                      }
                    }
                    if ((*(void *)(v71[29] + 8 * v72) & v27) != 0) {
                      goto LABEL_109;
                    }
                  }
                }
                v67 += 8;
                v66 -= 32;
              }
              while (v66);
            }
          }
          if (v38 == v58)
          {
            uint64_t v59 = (v59 + 1);
            if (v80 == v59)
            {
              _DWORD *v77 = 3;
              int v74 = 1;
              goto LABEL_111;
            }
            unint64_t v62 = *(void *)&v81[v59];
            if (v62 < 8) {
              uint64_t v58 = 0;
            }
            else {
              uint64_t v58 = *(void *)((v62 & 0xFFFFFFFFFFFFFFF8) + 16);
            }
            uint64_t v27 = *((void *)&v81[v59] + 1);
            if (v38) {
              goto LABEL_86;
            }
          }
          else
          {
            if (!v38) {
              break;
            }
LABEL_86:
            if ((*(unsigned char *)v38 & 4) != 0)
            {
LABEL_90:
              uint64_t v38 = *(void *)(v38 + 8);
              continue;
            }
          }
          break;
        }
        while ((*(_WORD *)(v38 + 44) & 8) != 0)
          uint64_t v38 = *(void *)(v38 + 8);
        goto LABEL_90;
      }
    }
    uint64_t v49 = *(void *)(v36 + 536);
    unint64_t v50 = *(unsigned int *)(v36 + 544);
    if (v50)
    {
      unsigned int v51 = *(_DWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 24) | (v37 >> 1) & 3;
      v52 = *(void **)(v36 + 536);
      unint64_t v53 = v50;
      do
      {
        unint64_t v54 = v53 >> 1;
        v55 = &v52[2 * (v53 >> 1)];
        uint64_t v57 = *v55;
        v56 = v55 + 2;
        v53 += ~(v53 >> 1);
        if (((v57 >> 1) & 3 | *(_DWORD *)((v57 & 0xFFFFFFFFFFFFFFF8) + 24)) < v51) {
          v52 = v56;
        }
        else {
          unint64_t v53 = v54;
        }
      }
      while (v53);
      if (v52 == (void *)(v49 + 16 * v50)
        || ((*v52 >> 1) & 3 | *(_DWORD *)((*v52 & 0xFFFFFFFFFFFFFFF8) + 24)) > v51)
      {
        v52 -= 2;
      }
    }
    else
    {
      v52 = *(void **)(v36 + 536);
    }
    uint64_t v39 = *(void *)(v9 + 8) & 6;
    if ((v37 & 6) == 0)
    {
      uint64_t v40 = v52[1];
      goto LABEL_40;
    }
    if (v37 < 8)
    {
      uint64_t v38 = 0;
      if (v39 == 2) {
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v38 = *(void *)((v37 & 0xFFFFFFFFFFFFFFF8) + 16);
LABEL_35:
      if (v39 == 2) {
        goto LABEL_69;
      }
      if (v38 && (*(unsigned char *)v38 & 4) != 0)
      {
LABEL_68:
        uint64_t v38 = *(void *)(v38 + 8);
        goto LABEL_69;
      }
    }
    while ((*(_WORD *)(v38 + 44) & 8) != 0)
      uint64_t v38 = *(void *)(v38 + 8);
    goto LABEL_68;
  }
LABEL_109:
  int v74 = 0;
LABEL_111:
  uint64_t v4 = v76;
  uint64_t v6 = v78;
  if (v74) {
    goto LABEL_112;
  }
  return 0;
}

uint64_t sub_1CC43EF48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)(a1 + 288);
  uint64_t v13 = operator new(0x28uLL);
  *uint64_t v13 = &unk_1F26121D8;
  v13[1] = a1;
  v13[2] = v12 + 312;
  v13[3] = a3;
  v13[4] = a5;
  v16 = v13;
  llvm::LiveInterval::refineSubRanges(a2, v12 + 312, a4, (uint64_t)v15, *(void *)(v12 + 288), *(void **)(a1 + 272), a6);
  uint64_t result = (uint64_t)v16;
  if (v16 == v15) {
    return (*(uint64_t (**)(void *))(v15[0] + 32))(v15);
  }
  if (v16) {
    return (*(uint64_t (**)(void))(*v16 + 40))();
  }
  return result;
}

void sub_1CC43F084(uint64_t *a1, uint64_t a2, void *a3)
{
  v71[8] = *MEMORY[0x1E4F143B8];
  uint64_t v63 = *(unsigned int *)(*a1 + 72);
  if (!v63) {
    return;
  }
  uint64_t v4 = 0;
  char v5 = 0;
  unint64_t v62 = (uint64_t *)(a2 + 104);
  do
  {
    uint64_t v6 = a1[15];
    v67 = (int *)(v6 + 48 * v4);
    if (*v67 == 1
      || !*v67
      && ((uint64_t v7 = v6 + 48 * v4, v8 = *(unsigned __int8 *)(v7 + 40), v9 = *(unsigned __int8 *)(v7 + 41), v8)
        ? (BOOL v10 = v9 == 0)
        : (BOOL v10 = 1),
          !v10))
    {
      uint64_t v11 = v6 + 48 * v4;
      int v13 = *(unsigned __int8 *)(v11 + 43);
      uint64_t v12 = (unsigned char *)(v11 + 43);
      uint64_t v14 = v13 ? *(void *)(*(void *)(v6 + 48 * v4 + 32) + 8) : 0;
      uint64_t v15 = *v62;
      if (*v62)
      {
        unint64_t v16 = *(void *)(*(void *)(*(void *)(*a1 + 64) + 8 * v4) + 8) & 0xFFFFFFFFFFFFFFF8;
        unint64_t v65 = v14 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v66 = *(void *)(*(void *)(*(void *)(*a1 + 64) + 8 * v4) + 8);
        uint64_t v64 = v12;
        while (1)
        {
          unsigned int v17 = *(_DWORD *)(v15 + 8);
          unint64_t v18 = *(void **)v15;
          if (!v17) {
            break;
          }
          uint64_t v19 = v18[3 * v17 - 2];
          unsigned int v20 = *(_DWORD *)(v16 + 24);
          unsigned int v21 = (v19 >> 1) & 3 | *(_DWORD *)((v19 & 0xFFFFFFFFFFFFFFF8) + 24);
          unint64_t v22 = *(void **)v15;
          unint64_t v23 = *(unsigned int *)(v15 + 8);
          if (v20 >= v21) {
            goto LABEL_24;
          }
          do
          {
            unint64_t v24 = v23 >> 1;
            uint64_t v25 = v22[3 * (v23 >> 1) + 1];
            LODWORD(v25) = (v25 >> 1) & 3 | *(_DWORD *)((v25 & 0xFFFFFFFFFFFFFFF8) + 24);
            v23 -= (v23 >> 1) + 1;
            BOOL v26 = v20 >= v25;
            if (v20 >= v25) {
              unint64_t v27 = v24 + 1;
            }
            else {
              unint64_t v27 = 0;
            }
            v22 += 3 * v27;
            if (!v26) {
              unint64_t v23 = v24;
            }
          }
          while (v23);
LABEL_25:
          unsigned int v28 = &v18[3 * v17];
          if (v22 == v28) {
            goto LABEL_79;
          }
          unsigned int v29 = *(_DWORD *)((*v22 & 0xFFFFFFFFFFFFFFF8) + 24);
          unsigned int v30 = *(_DWORD *)(v16 + 24);
          if (((*v22 >> 1) & 3 | v29) > v30)
          {
            uint64_t v31 = 0;
            goto LABEL_34;
          }
          uint64_t v31 = v22[2];
          if (v16 != (v22[1] & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_30;
          }
          v22 += 3;
          if (v22 != v28)
          {
            unsigned int v29 = *(_DWORD *)((*v22 & 0xFFFFFFFFFFFFFFF8) + 24);
LABEL_30:
            if (*(void *)(v31 + 8) == v16) {
              uint64_t v31 = 0;
            }
LABEL_34:
            if (v30 >= v29)
            {
              uint64_t v32 = v22[2];
              if (v32)
              {
                if (!v31) {
                  goto LABEL_40;
                }
                uint64_t v33 = v22[1];
                int v34 = *v67;
                if (*v12 && v34 == 1)
                {
                  if (*(void *)(v32 + 8) == v66)
                  {
LABEL_40:
                    BOOL v69 = v71;
                    uint64_t v70 = 0x800000000;
                    llvm::LiveIntervals::pruneValue(a1[6], v15, v66, (uint64_t)&v69);
                    *(void *)(v32 + 8) = 0;
                    if (!*v12) {
                      goto LABEL_74;
                    }
                    unsigned int v35 = *(_DWORD *)(v15 + 8);
                    uint64_t v36 = *(void **)v15;
                    if (v35)
                    {
                      uint64_t v37 = v36[3 * v35 - 2];
                      unsigned int v38 = *(_DWORD *)(v65 + 24);
                      unsigned int v39 = (v37 >> 1) & 3 | *(_DWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 24);
                      uint64_t v40 = *(void **)v15;
                      unint64_t v41 = *(unsigned int *)(v15 + 8);
                      if (v38 < v39)
                      {
                        do
                        {
                          unint64_t v42 = v41 >> 1;
                          uint64_t v43 = v40[3 * (v41 >> 1) + 1];
                          LODWORD(v43) = (v43 >> 1) & 3 | *(_DWORD *)((v43 & 0xFFFFFFFFFFFFFFF8) + 24);
                          v41 -= (v41 >> 1) + 1;
                          BOOL v44 = v38 >= v43;
                          if (v38 >= v43) {
                            unint64_t v45 = v42 + 1;
                          }
                          else {
                            unint64_t v45 = 0;
                          }
                          v40 += 3 * v45;
                          if (!v44) {
                            unint64_t v41 = v42;
                          }
                        }
                        while (v41);
LABEL_64:
                        v47 = &v36[3 * v35];
                        if (v40 != v47)
                        {
                          unsigned int v48 = *(_DWORD *)((*v40 & 0xFFFFFFFFFFFFFFF8) + 24);
                          unsigned int v49 = *(_DWORD *)(v65 + 24);
                          if (((*v40 >> 1) & 3 | v48) > v49 || v65 != (v40[1] & 0xFFFFFFFFFFFFFFF8)) {
                            goto LABEL_69;
                          }
                          v40 += 3;
                          if (v40 != v47)
                          {
                            unsigned int v48 = *(_DWORD *)((*v40 & 0xFFFFFFFFFFFFFFF8) + 24);
LABEL_69:
                            if (v49 >= v48)
                            {
                              if (v40[2])
                              {
                                unint64_t v50 = (unint64_t *)v69;
                                uint64_t v51 = a1[6];
                                uint64_t v52 = v70;
                                uint64_t v53 = *(void *)(v51 + 304);
                                uint64_t v54 = *(void *)(v51 + 248);
                                *(void *)uint64_t v53 = v54;
                                *(void *)(v53 + 8) = *(void *)(v54 + 40);
                                *(_OWORD *)(v53 + 16) = *(_OWORD *)(v51 + 288);
                                *(void *)(v53 + 32) = v51 + 312;
                                llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)v53);
                                *(_DWORD *)(v53 + 184) = 0;
                                if (v52)
                                {
                                  uint64_t v55 = 8 * v52;
                                  do
                                  {
                                    unint64_t v56 = *v50++;
                                    llvm::LiveRangeCalc::extend(*(llvm::LiveRangeCalc **)(v51 + 304), v15, v56, 0, 0, 0);
                                    v55 -= 8;
                                  }
                                  while (v55);
                                }
                              }
                            }
                          }
                        }
LABEL_74:
                        if ((*(unsigned char *)(v32 + 8) & 6) == 0) {
                          *a3 |= *(void *)(v15 + 112);
                        }
                        if (v69 != v71) {
                          free(v69);
                        }
                        char v5 = 1;
                        uint64_t v12 = v64;
                        goto LABEL_79;
                      }
                    }
                    else
                    {
                      unsigned int v35 = 0;
                    }
                    uint64_t v40 = &v36[3 * v35];
                    goto LABEL_64;
                  }
                  if ((~(_BYTE)v33 & 6) != 0) {
                    goto LABEL_56;
                  }
                }
                else if ((~(_BYTE)v33 & 6) != 0)
                {
                  if (v34 != 1) {
                    goto LABEL_79;
                  }
LABEL_56:
                  if ((*(unsigned char *)(v31 + 8) & 6) != 0) {
                    goto LABEL_79;
                  }
                  uint64_t v46 = (~(_BYTE)v33 & 6) != 0 ? v32 : 0;
                  if (v31 != v46) {
                    goto LABEL_79;
                  }
                }
LABEL_51:
                *a3 |= *(void *)(v15 + 112);
                goto LABEL_79;
              }
            }
          }
          if (v31) {
            goto LABEL_51;
          }
LABEL_79:
          uint64_t v15 = *(void *)(v15 + 104);
          if (!v15) {
            goto LABEL_80;
          }
        }
        unsigned int v17 = 0;
LABEL_24:
        unint64_t v22 = &v18[3 * v17];
        goto LABEL_25;
      }
    }
LABEL_80:
    ++v4;
  }
  while (v4 != v63);
  uint64_t v57 = v62;
  uint64_t v58 = *v62;
  if ((v5 & (*v62 != 0)) == 1)
  {
    do
    {
      uint64_t v61 = v58;
      if (!*(_DWORD *)(v58 + 8))
      {
        while (1)
        {
          uint64_t v59 = *(void *)(v61 + 96);
          uint64_t v58 = *(void *)(v61 + 104);
          *(void *)(v61 + 96) = 0;
          if (v59)
          {
            sub_1CB833A08(v59, *(void **)(v59 + 8));
            MEMORY[0x1D25D9CE0](v59, 0x1020C4062D53EE8);
          }
          int v60 = *(void **)(v61 + 64);
          if (v60 != (void *)(v61 + 80)) {
            free(v60);
          }
          if (*(void *)v61 == v61 + 16)
          {
            if (!v58)
            {
LABEL_96:
              *uint64_t v57 = 0;
              return;
            }
          }
          else
          {
            free(*(void **)v61);
            if (!v58) {
              goto LABEL_96;
            }
          }
          uint64_t v61 = v58;
          if (*(_DWORD *)(v58 + 8))
          {
            *uint64_t v57 = v58;
            break;
          }
        }
      }
      uint64_t v57 = (uint64_t *)(v58 + 104);
      uint64_t v58 = *(void *)(v58 + 104);
    }
    while (v58);
  }
}

void sub_1CC43F5DC(uint64_t *a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(unsigned int *)(*a1 + 72);
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      unint64_t v10 = *(void *)(*(void *)(*(void *)(*a1 + 64) + 8 * i) + 8);
      int v11 = *(_DWORD *)(a1[15] + 48 * i);
      if ((v11 - 1) >= 2)
      {
        if (v11 == 3)
        {
          llvm::LiveIntervals::pruneValue(a1[6], *a2, *(void *)(*(void *)(*(void *)(*a1 + 64) + 8 * i) + 8), a3);
          uint64_t v12 = a2[15] + 48 * **(unsigned int **)(a1[15] + 48 * i + 32);
          int v13 = *(unsigned __int8 *)(v12 + 40);
          int v14 = *(_DWORD *)v12;
          BOOL v15 = v13 && v14 == 0;
          BOOL v16 = v15;
          if ((v10 & 6) != 0)
          {
            if (a4)
            {
              uint64_t v17 = *(void *)((v10 & 0xFFFFFFFFFFFFFFF8) + 16);
              uint64_t v18 = *(unsigned int *)(v17 + 40);
              if (v18)
              {
                uint64_t v19 = *(unsigned int **)(v17 + 32);
                uint64_t v20 = 32 * v18;
                do
                {
                  unsigned int v21 = *v19;
                  if ((*v19 & 0x10000FF) == 0x1000000 && v19[1] == *((_DWORD *)a1 + 2))
                  {
                    if ((v21 & 0x10000000) == 0 || v16) {
                      unsigned int v23 = *v19;
                    }
                    else {
                      unsigned int v23 = v21 & 0xEFFFFFFF;
                    }
                    if ((v21 & 0xFFF00) != 0) {
                      unsigned int v21 = v23;
                    }
                    *uint64_t v19 = v21 & 0xFBFFFFFF;
                  }
                  v19 += 8;
                  v20 -= 32;
                }
                while (v20);
              }
            }
            if (!v16)
            {
              unint64_t v24 = *(unsigned int *)(a3 + 8);
              if (v24 >= *(unsigned int *)(a3 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)a3 + 8 * v24) = v10;
              ++*(_DWORD *)(a3 + 8);
            }
          }
        }
      }
      else if (sub_1CC441744((uint64_t)a1, i, (uint64_t)a2))
      {
        llvm::LiveIntervals::pruneValue(a1[6], *a1, v10, a3);
      }
    }
  }
}

void sub_1CC43F7B8(uint64_t **a1, llvm::SmallPtrSetImplBase *this, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *((unsigned int *)*a1 + 18);
  if (!v4) {
    return;
  }
  for (uint64_t i = 0; i != v4; ++i)
  {
    int v9 = *a1;
    uint64_t v10 = *(void *)((*a1)[8] + 8 * i);
    unint64_t v11 = *(void *)(v10 + 8);
    uint64_t v12 = a1[15];
    int v13 = v12[6 * i];
    if (v13 == 1) {
      goto LABEL_67;
    }
    if (v13 || !LOBYTE(v12[6 * i + 5]) || !BYTE1(v12[6 * i + 5])) {
      continue;
    }
    if (!a4)
    {
      llvm::LiveRange::removeValNo(v9, *(void *)((*a1)[8] + 8 * i));
      *(void *)(v10 + 8) = 0;
      goto LABEL_67;
    }
    unsigned int v14 = *((_DWORD *)v9 + 2);
    uint64_t v15 = *v9;
    if (v14)
    {
      uint64_t v16 = *(void *)(v15 + 24 * v14 - 16);
      unsigned int v17 = *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24) | (v11 >> 1) & 3;
      unsigned int v18 = (v16 >> 1) & 3 | *(_DWORD *)((v16 & 0xFFFFFFFFFFFFFFF8) + 24);
      uint64_t v19 = (void *)*v9;
      unint64_t v20 = *((unsigned int *)v9 + 2);
      if (v17 < v18)
      {
        do
        {
          unint64_t v21 = v20 >> 1;
          uint64_t v22 = v19[3 * (v20 >> 1) + 1];
          LODWORD(v22) = (v22 >> 1) & 3 | *(_DWORD *)((v22 & 0xFFFFFFFFFFFFFFF8) + 24);
          v20 -= (v20 >> 1) + 1;
          BOOL v23 = v17 >= v22;
          if (v17 >= v22) {
            unint64_t v24 = v21 + 1;
          }
          else {
            unint64_t v24 = 0;
          }
          v19 += 3 * v24;
          if (!v23) {
            unint64_t v20 = v21;
          }
        }
        while (v20);
        goto LABEL_20;
      }
    }
    else
    {
      unsigned int v14 = 0;
    }
    uint64_t v19 = (void *)(v15 + 24 * v14);
LABEL_20:
    uint64_t v25 = (void *)(v15 + 24 * v14);
    if (v19 == v25
      || ((*v19 >> 1) & 3 | *(_DWORD *)((*v19 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24) | (v11 >> 1) & 3))
    {
      uint64_t v19 = v25;
    }
    unint64_t v26 = v19[1];
    llvm::LiveRange::removeValNo(v9, *(void *)((*a1)[8] + 8 * i));
    *(void *)(v10 + 8) = 0;
    uint64_t v27 = *(void *)(a4 + 104);
    if (!v27) {
      goto LABEL_67;
    }
    unint64_t v28 = 0;
    unint64_t v29 = 0;
    unint64_t v84 = 0;
    unint64_t v30 = v11 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v31 = (v11 >> 1) & 3;
    do
    {
      unsigned int v32 = *(_DWORD *)(v27 + 8);
      uint64_t v33 = *(unint64_t **)v27;
      if (!v32)
      {
        unsigned int v32 = 0;
LABEL_34:
        uint64_t v37 = &v33[3 * v32];
        goto LABEL_35;
      }
      unint64_t v34 = v33[3 * v32 - 2];
      unsigned int v35 = *(_DWORD *)(v30 + 24) | v31;
      unsigned int v36 = (v34 >> 1) & 3 | *(_DWORD *)((v34 & 0xFFFFFFFFFFFFFFF8) + 24);
      uint64_t v37 = *(unint64_t **)v27;
      unint64_t v38 = *(unsigned int *)(v27 + 8);
      if (v35 >= v36) {
        goto LABEL_34;
      }
      do
      {
        unint64_t v39 = v38 >> 1;
        unint64_t v40 = v37[3 * (v38 >> 1) + 1];
        LODWORD(v40) = (v40 >> 1) & 3 | *(_DWORD *)((v40 & 0xFFFFFFFFFFFFFFF8) + 24);
        v38 -= (v38 >> 1) + 1;
        BOOL v41 = v35 >= v40;
        if (v35 >= v40) {
          unint64_t v42 = v39 + 1;
        }
        else {
          unint64_t v42 = 0;
        }
        v37 += 3 * v42;
        if (!v41) {
          unint64_t v38 = v39;
        }
      }
      while (v38);
LABEL_35:
      if (v37 != &v33[3 * v32])
      {
        unsigned int v43 = (*v37 >> 1) & 3 | *(_DWORD *)((*v37 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v43 <= (*(_DWORD *)(v30 + 24) | v31))
        {
          BOOL v44 = v37 + 1;
          if (v29 >= 8
            && (*(_DWORD *)((v29 & 0xFFFFFFFFFFFFFFF8) + 24) | (v29 >> 1) & 3) >= ((*v44 >> 1) & 3 | *(_DWORD *)((*v44 & 0xFFFFFFFFFFFFFFF8) + 24)))
          {
            BOOL v44 = &v84;
          }
          unint64_t v29 = *v44;
          unint64_t v84 = *v44;
        }
        else if (v28 < 8)
        {
          unint64_t v28 = *v37;
        }
        else if (v43 < (*(_DWORD *)((v28 & 0xFFFFFFFFFFFFFFF8) + 24) | (v28 >> 1) & 3))
        {
          unint64_t v28 = *v37;
        }
      }
      uint64_t v27 = *(void *)(v27 + 104);
    }
    while (v27);
    if (v29 > 7
      && (*(_DWORD *)((v29 & 0xFFFFFFFFFFFFFFF8) + 24) | (v29 >> 1) & 3) < (*(_DWORD *)((v26 & 0xFFFFFFFFFFFFFFF8) + 24) | (v26 >> 1) & 3))
    {
      unint64_t v26 = v29;
    }
    if (v28 >= 8
      && (*(_DWORD *)((v28 & 0xFFFFFFFFFFFFFFF8) + 24) | (v28 >> 1) & 3) < (*(_DWORD *)((v26 & 0xFFFFFFFFFFFFFFF8) + 24) | (v26 >> 1) & 3))
    {
      unint64_t v26 = v28;
    }
    if (v29 < 8) {
      goto LABEL_67;
    }
    unint64_t v45 = *((unsigned int *)*a1 + 2);
    uint64_t v46 = **a1;
    if (!v45)
    {
      LODWORD(v45) = 0;
LABEL_64:
      uint64_t v49 = v46 + 24 * v45;
      goto LABEL_65;
    }
    uint64_t v47 = *(void *)(v46 + 24 * v45 - 16);
    unsigned int v48 = *(_DWORD *)(v30 + 24) | v31;
    uint64_t v49 = **a1;
    if (v48 >= ((v47 >> 1) & 3 | *(_DWORD *)((v47 & 0xFFFFFFFFFFFFFFF8) + 24))) {
      goto LABEL_64;
    }
    do
    {
      unint64_t v50 = v45 >> 1;
      uint64_t v51 = *(void *)(v49 + 24 * (v45 >> 1) + 8);
      LODWORD(v51) = (v51 >> 1) & 3 | *(_DWORD *)((v51 & 0xFFFFFFFFFFFFFFF8) + 24);
      v45 -= (v45 >> 1) + 1;
      BOOL v52 = v48 >= v51;
      if (v48 >= v51) {
        unint64_t v53 = v50 + 1;
      }
      else {
        unint64_t v53 = 0;
      }
      v49 += 24 * v53;
      if (!v52) {
        unint64_t v45 = v50;
      }
    }
    while (v45);
LABEL_65:
    if (v49 != v46) {
      *(void *)(v49 - 16) = v26;
    }
LABEL_67:
    if (v11 < 8) {
      uint64_t v54 = 0;
    }
    else {
      uint64_t v54 = *(void *)((v11 & 0xFFFFFFFFFFFFFFF8) + 16);
    }
    if (**(_WORD **)(v54 + 16) == 19)
    {
      int v55 = *(_DWORD *)(*(void *)(v54 + 32) + 36);
      if (v55 < 0)
      {
        unint64_t v56 = a1[5];
        if (v55 != *((_DWORD *)v56 + 3) && v55 != *((_DWORD *)v56 + 2))
        {
          unint64_t v57 = *(unsigned int *)(a3 + 8);
          if (v57 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(_DWORD *)(*(void *)a3 + 4 * v57) = v55;
          ++*(_DWORD *)(a3 + 8);
        }
      }
    }
    uint64_t v58 = *((void *)this + 1);
    uint64_t v59 = *((unsigned int *)this + 5);
    unsigned int v60 = v54 >> 4;
    if (v58 != *(void *)this)
    {
      unsigned int v64 = *((_DWORD *)this + 4);
      goto LABEL_87;
    }
    if (!v59)
    {
LABEL_84:
      unsigned int v64 = *((_DWORD *)this + 4);
      if (v59 < v64)
      {
        *((_DWORD *)this + 5) = v59 + 1;
        *(void *)(v58 + 8 * v59) = v54;
        goto LABEL_108;
      }
LABEL_87:
      if (3 * v64 <= 4 * ((int)v59 - *((_DWORD *)this + 6)))
      {
        if (v64 >= 0x40) {
          v64 *= 2;
        }
        else {
          unsigned int v64 = 128;
        }
      }
      else if (v64 - v59 >= v64 >> 3)
      {
        goto LABEL_89;
      }
      llvm::SmallPtrSetImplBase::Grow(this, v64);
      unsigned int v64 = *((_DWORD *)this + 4);
      uint64_t v58 = *((void *)this + 1);
LABEL_89:
      unsigned int v65 = v64 - 1;
      unsigned int v66 = (v64 - 1) & (v60 ^ (v54 >> 9));
      v67 = (void *)(v58 + 8 * v66);
      uint64_t v68 = *v67;
      if (*v67 == -1)
      {
        BOOL v69 = 0;
LABEL_101:
        if (v69) {
          int v73 = v69;
        }
        else {
          int v73 = v67;
        }
        if (*v73 != v54)
        {
          if (*v73 == -2) {
            --*((_DWORD *)this + 6);
          }
          else {
            ++*((_DWORD *)this + 5);
          }
          *int v73 = v54;
        }
      }
      else
      {
        BOOL v69 = 0;
        int v70 = 1;
        while (v68 != v54)
        {
          if (v69) {
            BOOL v71 = 0;
          }
          else {
            BOOL v71 = v68 == -2;
          }
          if (v71) {
            BOOL v69 = v67;
          }
          unsigned int v72 = v66 + v70++;
          unsigned int v66 = v72 & v65;
          v67 = (void *)(v58 + 8 * (v72 & v65));
          uint64_t v68 = *v67;
          if (*v67 == -1) {
            goto LABEL_101;
          }
        }
      }
      goto LABEL_108;
    }
    uint64_t v61 = 0;
    uint64_t v62 = 8 * v59;
    uint64_t v63 = (void *)*((void *)this + 1);
    while (*v63 != v54)
    {
      if (*v63 == -2) {
        uint64_t v61 = v63;
      }
      ++v63;
      v62 -= 8;
      if (!v62)
      {
        if (!v61) {
          goto LABEL_84;
        }
        *uint64_t v61 = v54;
        --*((_DWORD *)this + 6);
        break;
      }
    }
LABEL_108:
    int v74 = (int32x2_t *)a1[6][36];
    int32x2_t v75 = v74[46];
    uint64_t v76 = v74[48].u32[0];
    if (v76)
    {
      LODWORD(v77) = (v76 - 1) & (v60 ^ (v54 >> 9));
      uint64_t v78 = (uint64_t *)(*(void *)&v75 + 16 * v77);
      uint64_t v79 = *v78;
      if (*v78 != v54)
      {
        int v80 = 1;
        while (v79 != -4096)
        {
          int v81 = v77 + v80++;
          uint64_t v77 = v81 & (v76 - 1);
          uint64_t v79 = *(void *)(*(void *)&v75 + 16 * v77);
          if (v79 == v54)
          {
            uint64_t v78 = (uint64_t *)(*(void *)&v75 + 16 * v77);
            goto LABEL_115;
          }
        }
        goto LABEL_114;
      }
    }
    else
    {
LABEL_114:
      uint64_t v78 = (uint64_t *)(*(void *)&v75 + 16 * v76);
    }
LABEL_115:
    if (v78 != (uint64_t *)(*(void *)&v75 + 16 * v76))
    {
      unint64_t v82 = v78[1] & 0xFFFFFFFFFFFFFFF8;
      *uint64_t v78 = -8192;
      v74[47] = vadd_s32(v74[47], (int32x2_t)0x1FFFFFFFFLL);
      *(void *)(v82 + 16) = 0;
    }
    llvm::MachineInstr::eraseFromParent((llvm::MachineInstr *)v54);
  }
}

uint64_t sub_1CC43FE3C(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = a1;
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    unsigned int v4 = (37 * *a2) & (v3 - 1);
    uint64_t result = *(void *)a1 + 16 * v4;
    int v6 = *(_DWORD *)result;
    if (*a2 == *(_DWORD *)result) {
      return result;
    }
    uint64_t v7 = 0;
    int v8 = 1;
    while (v6 != -1)
    {
      if (v7) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = v6 == -2;
      }
      if (v9) {
        uint64_t v7 = result;
      }
      unsigned int v10 = v4 + v8++;
      unsigned int v4 = v10 & (v3 - 1);
      uint64_t result = *(void *)v2 + 16 * v4;
      int v6 = *(_DWORD *)result;
      if (*a2 == *(_DWORD *)result) {
        return result;
      }
    }
    if (v7) {
      uint64_t result = v7;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  int v11 = *(_DWORD *)(v2 + 8);
  if (4 * v11 + 4 >= 3 * v3)
  {
    int v13 = a2;
    sub_1CC440068(v2, 2 * v3);
    uint64_t v14 = v2;
    a2 = v13;
    int v12 = *v13;
    int v15 = *(_DWORD *)(v2 + 16) - 1;
    unsigned int v16 = (37 * *v13) & v15;
    uint64_t result = *(void *)v2 + 16 * v16;
    int v17 = *(_DWORD *)result;
    if (*v13 == *(_DWORD *)result)
    {
LABEL_33:
      uint64_t v2 = v14;
      goto LABEL_18;
    }
    uint64_t v18 = 0;
    int v19 = 1;
    while (v17 != -1)
    {
      if (v18) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v17 == -2;
      }
      if (v20) {
        uint64_t v18 = result;
      }
      unsigned int v21 = v16 + v19++;
      unsigned int v16 = v21 & v15;
      uint64_t result = *(void *)v2 + 16 * v16;
      int v17 = *(_DWORD *)result;
      if (v12 == *(_DWORD *)result) {
        goto LABEL_33;
      }
    }
LABEL_36:
    if (v18) {
      uint64_t result = v18;
    }
    uint64_t v2 = v14;
    goto LABEL_17;
  }
  if (v3 + ~v11 - *(_DWORD *)(v2 + 12) <= v3 >> 3)
  {
    uint64_t v22 = a2;
    sub_1CC440068(v2, v3);
    uint64_t v14 = v2;
    a2 = v22;
    int v12 = *v22;
    int v23 = *(_DWORD *)(v2 + 16) - 1;
    unsigned int v24 = (37 * *v22) & v23;
    uint64_t result = *(void *)v2 + 16 * v24;
    int v25 = *(_DWORD *)result;
    if (*v22 == *(_DWORD *)result) {
      goto LABEL_33;
    }
    uint64_t v18 = 0;
    int v26 = 1;
    while (v25 != -1)
    {
      if (v18) {
        BOOL v27 = 0;
      }
      else {
        BOOL v27 = v25 == -2;
      }
      if (v27) {
        uint64_t v18 = result;
      }
      unsigned int v28 = v24 + v26++;
      unsigned int v24 = v28 & v23;
      uint64_t result = *(void *)v2 + 16 * v24;
      int v25 = *(_DWORD *)result;
      if (v12 == *(_DWORD *)result) {
        goto LABEL_33;
      }
    }
    goto LABEL_36;
  }
LABEL_17:
  int v12 = *(_DWORD *)result;
LABEL_18:
  ++*(_DWORD *)(v2 + 8);
  if (v12 != -1) {
    --*(_DWORD *)(v2 + 12);
  }
  *(_DWORD *)uint64_t result = *a2;
  *(void *)(result + 8) = 0;
  return result;
}

_DWORD *sub_1CC440068(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC440134(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -1;
      result += 4;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CC440134(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(_DWORD **)result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 16 * v4;
    unint64_t v6 = *(_DWORD **)result;
    do
    {
      *unint64_t v6 = -1;
      v6 += 4;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 4)
  {
    int v7 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v8 = *(_DWORD *)(result + 16) - 1;
      unsigned int v9 = v8 & (37 * v7);
      uint64_t v10 = &v3[4 * v9];
      int v11 = *v10;
      if (v7 != *v10)
      {
        int v12 = 0;
        int v13 = 1;
        while (v11 != -1)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == -2;
          }
          if (v14) {
            int v12 = v10;
          }
          unsigned int v15 = v9 + v13++;
          unsigned int v9 = v15 & v8;
          uint64_t v10 = &v3[4 * (v15 & v8)];
          int v11 = *v10;
          if (v7 == *v10) {
            goto LABEL_18;
          }
        }
        if (v12) {
          uint64_t v10 = v12;
        }
      }
LABEL_18:
      *uint64_t v10 = v7;
      *((void *)v10 + 1) = *((void *)a2 + 1);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t sub_1CC440204(uint64_t result, unsigned int a2, uint64_t **a3)
{
  uint64_t v3 = *(void *)(result + 120);
  uint64_t v4 = v3 + 48 * a2;
  uint64_t v5 = (int64x2_t *)(v4 + 8);
  if (*(void *)(v4 + 8)) {
    return result;
  }
  unint64_t v6 = (uint64_t **)result;
  uint64_t v7 = a2;
  uint64_t v8 = *(void *)(*(void *)(*(void *)result + 64) + 8 * a2);
  unint64_t v9 = *(void *)(v8 + 8);
  if (v9 > 7)
  {
    int v11 = a3;
    if ((v9 & 6) == 0)
    {
      if (*(unsigned char *)(result + 24)) {
        unint64_t v14 = 1;
      }
      else {
        unint64_t v14 = *(void *)(*(void *)(*(void *)(result + 64) + 232) + 8 * *(unsigned int *)(result + 12));
      }
      uint64_t v12 = 0;
      *uint64_t v5 = vdupq_n_s64(v14);
      goto LABEL_54;
    }
    uint64_t v12 = *(void *)((v9 & 0xFFFFFFFFFFFFFFF8) + 16);
    if (*(unsigned char *)(result + 24))
    {
      *uint64_t v5 = vdupq_n_s64(1uLL);
      if (**(_WORD **)(v12 + 16) == 10)
      {
        uint64_t v13 = v3 + 48 * a2;
        *(void *)(v13 + 16) = 0;
        *(unsigned char *)(v13 + 40) = 1;
      }
      goto LABEL_54;
    }
    uint64_t v15 = *(unsigned int *)(v12 + 40);
    uint64_t v155 = v12;
    if (!v15)
    {
      v5->i64[0] = 0;
      *(void *)(v4 + 16) = 0;
      goto LABEL_52;
    }
    uint64_t v151 = *(void *)(*(void *)(*(void *)result + 64) + 8 * a2);
    uint64_t v16 = 0;
    char v17 = 0;
    uint64_t v18 = *(unsigned int **)(v12 + 32);
    uint64_t v19 = 32 * v15;
    do
    {
      unsigned int v20 = *v18;
      if (!*v18 && (v20 & 0x1000000) != 0 && v18[1] == *((_DWORD *)v6 + 2))
      {
        unsigned int v21 = v6[8];
        unsigned int v22 = (v20 >> 8) & 0xFFF;
        if (*((_DWORD *)v6 + 3))
        {
          if (v22)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t *))(*v21 + 208))(v6[8]);
            unsigned int v22 = result;
            unsigned int v20 = *v18;
          }
          else
          {
            unsigned int v22 = *((_DWORD *)v6 + 3);
          }
        }
        v16 |= *(void *)(v21[29] + 8 * v22);
        if ((v20 & 0x10FFF00) != 0x1000000 && (v20 & 0x30000000) == 0) {
          char v17 = 1;
        }
      }
      v18 += 8;
      v19 -= 32;
    }
    while (v19);
    v5->i64[0] = v16;
    uint64_t v24 = v3 + 48 * v7;
    *(void *)(v24 + 16) = v16;
    int v25 = (void *)(v24 + 16);
    uint64_t v8 = v151;
    int v11 = a3;
    if (!v17) {
      goto LABEL_52;
    }
    unint64_t v26 = *(void *)(v151 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v27 = *((_DWORD *)*v6 + 2);
    uint64_t v28 = **v6;
    if (v27)
    {
      uint64_t v29 = *(void *)(v28 + 24 * v27 - 16);
      unsigned int v30 = *(_DWORD *)(v26 + 24);
      if (v30 < ((v29 >> 1) & 3 | *(_DWORD *)((v29 & 0xFFFFFFFFFFFFFFF8) + 24)))
      {
        unsigned int v31 = (void *)**v6;
        unint64_t v32 = *((unsigned int *)*v6 + 2);
        do
        {
          unint64_t v33 = v32 >> 1;
          uint64_t v34 = v31[3 * (v32 >> 1) + 1];
          LODWORD(v34) = (v34 >> 1) & 3 | *(_DWORD *)((v34 & 0xFFFFFFFFFFFFFFF8) + 24);
          v32 -= (v32 >> 1) + 1;
          BOOL v35 = v30 >= v34;
          if (v30 >= v34) {
            unint64_t v36 = v33 + 1;
          }
          else {
            unint64_t v36 = 0;
          }
          v31 += 3 * v36;
          if (!v35) {
            unint64_t v32 = v33;
          }
        }
        while (v32);
LABEL_42:
        uint64_t v37 = (void *)(v28 + 24 * v27);
        if (v31 != v37
          && ((*v31 >> 1) & 3 | *(_DWORD *)((*v31 & 0xFFFFFFFFFFFFFFF8) + 24)) <= *(_DWORD *)(v26 + 24))
        {
          unint64_t v38 = (unsigned int *)v31[2];
          unint64_t v39 = v31[1] & 0xFFFFFFFFFFFFFFF8;
          unint64_t v40 = v31 + 3;
          if (v26 == v39 && v40 == v37)
          {
            uint64_t v120 = v3 + 48 * v7;
            *(void *)(v120 + 24) = v38;
            unsigned int v43 = (unsigned int **)(v120 + 24);
            if (v38) {
              goto LABEL_50;
            }
LABEL_52:
            uint64_t v12 = v155;
            if (**(_WORD **)(v155 + 16) == 10) {
              *(unsigned char *)(v3 + 48 * v7 + 40) = 1;
            }
LABEL_54:
            uint64_t v44 = *(void *)(v8 + 8);
            unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFF8;
            unsigned int v46 = *((_DWORD *)*v11 + 2);
            uint64_t v47 = **v11;
            if (v46)
            {
              uint64_t v48 = *(void *)(v47 + 24 * v46 - 16);
              unsigned int v49 = *(_DWORD *)(v45 + 24);
              if (v49 < ((v48 >> 1) & 3 | *(_DWORD *)((v48 & 0xFFFFFFFFFFFFFFF8) + 24)))
              {
                unint64_t v50 = (void *)**v11;
                unint64_t v51 = *((unsigned int *)*v11 + 2);
                do
                {
                  unint64_t v52 = v51 >> 1;
                  uint64_t v53 = v50[3 * (v51 >> 1) + 1];
                  LODWORD(v53) = (v53 >> 1) & 3 | *(_DWORD *)((v53 & 0xFFFFFFFFFFFFFFF8) + 24);
                  uint64_t result = (v51 >> 1) + 1;
                  v51 -= result;
                  BOOL v54 = v49 >= v53;
                  if (v49 >= v53) {
                    unint64_t v55 = v52 + 1;
                  }
                  else {
                    unint64_t v55 = 0;
                  }
                  v50 += 3 * v55;
                  if (!v54) {
                    unint64_t v51 = v52;
                  }
                }
                while (v51);
LABEL_66:
                unint64_t v56 = (void *)(v47 + 24 * v46);
                if (v50 == v56)
                {
                  int v10 = 0;
                  *(void *)(v3 + 48 * v7 + 32) = 0;
                  goto LABEL_122;
                }
                unsigned int v57 = *(_DWORD *)((*v50 & 0xFFFFFFFFFFFFFFF8) + 24);
                unsigned int v58 = *(_DWORD *)(v45 + 24);
                if (((*v50 >> 1) & 3 | v57) > v58)
                {
                  uint64_t v60 = 0;
                  BOOL v61 = 0;
                  uint64_t v59 = 0;
                }
                else
                {
                  uint64_t v60 = v50[1];
                  uint64_t v59 = (unsigned int *)v50[2];
                  BOOL v61 = v45 == (v60 & 0xFFFFFFFFFFFFFFF8);
                  if (v45 == (v60 & 0xFFFFFFFFFFFFFFF8))
                  {
                    v50 += 3;
                    if (v50 == v56)
                    {
                      BOOL v61 = 1;
                      goto LABEL_82;
                    }
                    unsigned int v57 = *(_DWORD *)((*v50 & 0xFFFFFFFFFFFFFFF8) + 24);
                  }
                  if (*((void *)v59 + 1) == v45) {
                    uint64_t v59 = 0;
                  }
                }
                if (v58 >= v57)
                {
                  uint64_t v62 = v12;
                  uint64_t v63 = (unsigned int *)v50[2];
                  if (v59 != v63 && v63 != 0)
                  {
                    unsigned int v77 = (*((void *)v63 + 1) >> 1) & 3 | *(_DWORD *)((*((void *)v63 + 1) & 0xFFFFFFFFFFFFFFF8)
                                                                                    + 24);
                    unsigned int v78 = v58 | (v44 >> 1) & 3;
                    if (v77 >= v78)
                    {
                      if (v59 && v78 < v77)
                      {
                        *(void *)(v3 + 48 * v7 + 32) = v59;
                        goto LABEL_106;
                      }
                    }
                    else
                    {
                      uint64_t result = sub_1CC440204(v11, *v63, v6);
                    }
                    *(void *)(v3 + 48 * v7 + 32) = v63;
                    uint64_t v79 = v11[15];
                    if (v79[6 * *v63 + 1])
                    {
                      if ((*(unsigned char *)(v8 + 8) & 6) == 0
                        || (*(void *)(v3 + 48 * v7 + 16) & v79[6 * *v63 + 2]) == 0)
                      {
                        int v80 = 2;
LABEL_102:
                        *(_DWORD *)uint64_t v4 = v80;
                        *((_DWORD *)v6[9] + v7) = *((_DWORD *)v11[9]
                                                  + **(unsigned int **)(v3 + 48 * v7 + 32));
                        return result;
                      }
                      goto LABEL_106;
                    }
                    goto LABEL_121;
                  }
                  uint64_t v60 = v50[1];
                  uint64_t v12 = v62;
                }
LABEL_82:
                uint64_t v65 = v3 + 48 * v7;
                *(void *)(v65 + 32) = v59;
                unsigned int v66 = (unsigned int **)(v65 + 32);
                if (v59)
                {
                  BOOL v154 = v61;
                  uint64_t v152 = v60;
                  uint64_t result = sub_1CC440204(v11, *v59, v6);
                  v156 = v66;
                  v67 = *v66;
                  unsigned int v68 = **v66;
                  BOOL v69 = v11[15];
                  int v70 = &v69[6 * v68];
                  int v72 = *((unsigned __int8 *)v70 + 40);
                  BOOL v71 = v70 + 5;
                  if (v72)
                  {
                    if (!v12) {
                      goto LABEL_96;
                    }
                    int v73 = v6[7];
                    unint64_t v74 = *((void *)v67 + 1);
                    if (v74 >= 8 && (uint64_t v75 = *(void *)((v74 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
                    {
                      uint64_t v76 = (void *)(v75 + 24);
                    }
                    else
                    {
                      v121 = (void *)v73[67];
                      unint64_t v122 = *((unsigned int *)v73 + 136);
                      if (v122)
                      {
                        unsigned int v123 = *(_DWORD *)((v74 & 0xFFFFFFFFFFFFFFF8) + 24) | (v74 >> 1) & 3;
                        v124 = v121;
                        unint64_t v125 = v122;
                        do
                        {
                          unint64_t v126 = v125 >> 1;
                          v127 = &v124[2 * (v125 >> 1)];
                          uint64_t v129 = *v127;
                          v128 = v127 + 2;
                          uint64_t result = (v129 >> 1) & 3 | *(_DWORD *)((v129 & 0xFFFFFFFFFFFFFFF8) + 24);
                          v125 += ~(v125 >> 1);
                          if (result < v123) {
                            v124 = v128;
                          }
                          else {
                            unint64_t v125 = v126;
                          }
                        }
                        while (v125);
                        if (v124 == &v121[2 * v122]
                          || ((*v124 >> 1) & 3 | *(_DWORD *)((*v124 & 0xFFFFFFFFFFFFFFF8) + 24)) > v123)
                        {
                          v124 -= 2;
                        }
                      }
                      else
                      {
                        v124 = (void *)v73[67];
                      }
                      uint64_t v76 = v124 + 1;
                    }
                    if (*(void *)(v12 + 24) == *v76) {
LABEL_96:
                    }
                      v69[6 * v68 + 2] &= ~v69[6 * v68 + 1];
                    else {
                      unsigned char *v71 = 0;
                    }
                  }
                  if ((*(unsigned char *)(v8 + 8) & 6) == 0) {
                    goto LABEL_115;
                  }
                  if (**(_WORD **)(v12 + 16) == 10)
                  {
LABEL_101:
                    int v80 = 1;
                    goto LABEL_102;
                  }
                  uint64_t result = llvm::CoalescerPair::isCoalescable((llvm::CoalescerPair *)v6[5], (const llvm::MachineInstr *)v12);
                  if (result)
                  {
                    *(void *)(v3 + 48 * v7 + 16) &= v69[6 * v68 + 2] | ~v5->i64[0];
                    goto LABEL_101;
                  }
                  BOOL v81 = v154;
                  if (!v154
                    || (*(_DWORD *)((v152 & 0xFFFFFFFFFFFFFFF8) + 24) | (v152 >> 1) & 3) > ((*(void *)(v8 + 8) >> 1) & 3 | *(_DWORD *)((*(void *)(v8 + 8) & 0xFFFFFFFFFFFFFFF8) + 24)))
                  {
                    uint64_t v82 = v12;
                    uint64_t v83 = v8;
                    if (**(_WORD **)(v82 + 16) == 19)
                    {
                      unint64_t v84 = *(_DWORD **)(v82 + 32);
                      if ((*v84 & 0xFFF00) == 0 && (v84[8] & 0xFFF00) == 0 && !*((unsigned char *)v6[5] + 24))
                      {
                        v135 = *v156;
                        uint64_t result = sub_1CC440E94((uint64_t)v6, v83);
                        int v137 = v136;
                        uint64_t v138 = (uint64_t)v135;
                        uint64_t v139 = result;
                        if (v138 == result && *((_DWORD *)v11 + 2) == v137) {
                          goto LABEL_191;
                        }
                        int v150 = v137;
                        uint64_t result = sub_1CC440E94((uint64_t)v11, v138);
                        if (v139 && result) {
                          BOOL v141 = *(void *)(v139 + 8) == *(void *)(result + 8);
                        }
                        else {
                          BOOL v141 = v139 == result;
                        }
                        BOOL v81 = v154;
                        if (v141 && v150 == v140)
                        {
LABEL_191:
                          int v80 = 1;
                          *(unsigned char *)(v3 + 48 * v7 + 43) = 1;
                          goto LABEL_102;
                        }
                      }
                    }
                    if (!*((unsigned char *)v6 + 24) && (v5->i64[0] & v69[6 * v68 + 2]) != 0)
                    {
                      if (v81 || (*(void *)(v6[8][29] + 8 * *((unsigned int *)v11 + 3)) & ~v5->i64[0]) == 0) {
                        goto LABEL_106;
                      }
                      if (*((unsigned char *)v6 + 25))
                      {
                        v94 = v6[6];
                        unint64_t v95 = v11[1] & 0x7FFFFFFF;
                        uint64_t result = (uint64_t)(v94 + 51);
                        unint64_t v96 = *((unsigned int *)v94 + 104);
                        BOOL v35 = v95 >= v96;
                        unint64_t v97 = v95 - v96;
                        if (v35)
                        {
                          sub_1CB9153B8(result, v97 + 1, v94[53]);
                        }
                        else
                        {
                          uint64_t v98 = *(void *)(*(void *)result + 8 * v95);
                          if (v98)
                          {
                            uint64_t v99 = *(void *)(v98 + 104);
                            if (v99)
                            {
                              while (1)
                              {
                                uint64_t v100 = *((unsigned int *)v11 + 3);
                                uint64_t v101 = *(void *)(v99 + 112);
                                if (v100)
                                {
                                  uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6[8] + 216))(v6[8], v100, v101);
                                  uint64_t v101 = result;
                                }
                                if ((v5->i64[0] & v101) == 0) {
                                  goto LABEL_160;
                                }
                                uint64_t v102 = *(void *)(v83 + 8);
                                unint64_t v103 = v102 & 0xFFFFFFFFFFFFFFF8;
                                unsigned int v104 = *(_DWORD *)(v99 + 8);
                                v105 = *(void **)v99;
                                if (!v104) {
                                  break;
                                }
                                uint64_t v106 = v105[3 * v104 - 2];
                                unsigned int v107 = *(_DWORD *)(v103 + 24);
                                unsigned int v108 = (v106 >> 1) & 3 | *(_DWORD *)((v106 & 0xFFFFFFFFFFFFFFF8) + 24);
                                v109 = *(void **)v99;
                                unint64_t v110 = *(unsigned int *)(v99 + 8);
                                if (v107 >= v108) {
                                  goto LABEL_146;
                                }
                                do
                                {
                                  unint64_t v111 = v110 >> 1;
                                  uint64_t v112 = v109[3 * (v110 >> 1) + 1];
                                  LODWORD(v112) = (v112 >> 1) & 3 | *(_DWORD *)((v112 & 0xFFFFFFFFFFFFFFF8)
                                                                                            + 24);
                                  v110 -= (v110 >> 1) + 1;
                                  BOOL v113 = v107 >= v112;
                                  if (v107 >= v112) {
                                    unint64_t v114 = v111 + 1;
                                  }
                                  else {
                                    unint64_t v114 = 0;
                                  }
                                  v109 += 3 * v114;
                                  if (!v113) {
                                    unint64_t v110 = v111;
                                  }
                                }
                                while (v110);
LABEL_147:
                                v115 = &v105[3 * v104];
                                if (v109 == v115) {
                                  goto LABEL_160;
                                }
                                unsigned int v116 = *(_DWORD *)((*v109 & 0xFFFFFFFFFFFFFFF8) + 24);
                                unsigned int v117 = *(_DWORD *)(v103 + 24);
                                if (((*v109 >> 1) & 3 | v116) > v117)
                                {
                                  uint64_t v118 = 0;
                                  uint64_t v119 = 0;
                                }
                                else
                                {
                                  uint64_t v118 = v109[1];
                                  uint64_t v119 = v109[2];
                                  if (v103 == (v118 & 0xFFFFFFFFFFFFFFF8))
                                  {
                                    v109 += 3;
                                    if (v109 == v115) {
                                      goto LABEL_158;
                                    }
                                    unsigned int v116 = *(_DWORD *)((*v109 & 0xFFFFFFFFFFFFFFF8) + 24);
                                  }
                                  if (*(void *)(v119 + 8) == v103) {
                                    uint64_t v119 = 0;
                                  }
                                }
                                if (v117 >= v116) {
                                  uint64_t v118 = v109[1];
                                }
LABEL_158:
                                if (v119
                                  && (*(_DWORD *)((v118 & 0xFFFFFFFFFFFFFFF8) + 24) | (v118 >> 1) & 3) > (v117 | (v102 >> 1) & 3))
                                {
                                  goto LABEL_106;
                                }
LABEL_160:
                                uint64_t v99 = *(void *)(v99 + 104);
                                int v85 = 3;
                                if (!v99) {
                                  goto LABEL_116;
                                }
                              }
                              unsigned int v104 = 0;
LABEL_146:
                              v109 = &v105[3 * v104];
                              goto LABEL_147;
                            }
                            if ((v5->i64[0] & *(void *)(v6[8][29] + 8 * *((unsigned int *)v11 + 3))) == 0) {
                              goto LABEL_115;
                            }
LABEL_106:
                            int v10 = 5;
                            goto LABEL_122;
                          }
                        }
                        llvm::LiveIntervals::createInterval();
                      }
                      v130 = v6[7];
                      unint64_t v131 = *(void *)(v83 + 8);
                      if (v131 >= 8 && (uint64_t v132 = *(void *)((v131 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
                      {
                        v133 = (void *)(v132 + 24);
                      }
                      else
                      {
                        uint64_t v142 = *((unsigned int *)v130 + 136);
                        if (v142)
                        {
                          unsigned int v143 = *(_DWORD *)((v131 & 0xFFFFFFFFFFFFFFF8) + 24) | (v131 >> 1) & 3;
                          v144 = (void *)v130[67];
                          unint64_t v145 = *((unsigned int *)v130 + 136);
                          do
                          {
                            unint64_t v146 = v145 >> 1;
                            v147 = &v144[2 * (v145 >> 1)];
                            uint64_t v149 = *v147;
                            v148 = v147 + 2;
                            uint64_t result = ~(v145 >> 1);
                            v145 += result;
                            if (((v149 >> 1) & 3 | *(_DWORD *)((v149 & 0xFFFFFFFFFFFFFFF8) + 24)) < v143) {
                              v144 = v148;
                            }
                            else {
                              unint64_t v145 = v146;
                            }
                          }
                          while (v145);
                          if (v144 == (void *)(v130[67] + 16 * v142)
                            || ((*v144 >> 1) & 3 | *(_DWORD *)((*v144 & 0xFFFFFFFFFFFFFFF8) + 24)) > v143)
                          {
                            v144 -= 2;
                          }
                        }
                        else
                        {
                          v144 = (void *)v130[67];
                        }
                        v133 = v144 + 1;
                      }
                      uint64_t v134 = *(void *)(v130[49] + 16 * *(unsigned int *)(*v133 + 24) + 8);
                      if ((*(_DWORD *)((v152 & 0xFFFFFFFFFFFFFFF8) + 24) | (v152 >> 1) & 3) < ((v134 >> 1) & 3 | *(_DWORD *)((v134 & 0xFFFFFFFFFFFFFFF8) + 24)))
                      {
                        int v85 = 4;
LABEL_116:
                        *(_DWORD *)uint64_t v4 = v85;
                        unsigned int v86 = **v156;
                        v87 = v11[15];
                        v88 = &v87[6 * v86];
                        int v90 = *((unsigned __int8 *)v88 + 40);
                        v89 = v88 + 5;
                        if (v90
                          && *((unsigned char *)v6 + 25)
                          && (v87[6 * v86 + 1] & ~*(void *)(v3 + 48 * v7 + 16)) != 0)
                        {
                          unsigned char *v89 = 0;
                          v87[6 * v86 + 2] = -1;
                        }
                        BYTE1(v87[6 * v86 + 5]) = 1;
                        goto LABEL_123;
                      }
                      goto LABEL_106;
                    }
LABEL_115:
                    int v85 = 3;
                    goto LABEL_116;
                  }
                }
LABEL_121:
                int v10 = 0;
                goto LABEL_122;
              }
            }
            else
            {
              unsigned int v46 = 0;
            }
            unint64_t v50 = (void *)(v47 + 24 * v46);
            goto LABEL_66;
          }
          if (*((void *)v38 + 1) != v26)
          {
            uint64_t v42 = v3 + 48 * v7;
            *(void *)(v42 + 24) = v38;
            unsigned int v43 = (unsigned int **)(v42 + 24);
LABEL_50:
            uint64_t result = sub_1CC440204(v6, *v38, a3);
            *v25 |= v6[15][6 * **v43 + 2];
            goto LABEL_52;
          }
        }
        *(void *)(v3 + 48 * v7 + 24) = 0;
        goto LABEL_52;
      }
    }
    else
    {
      unsigned int v27 = 0;
    }
    unsigned int v31 = (void *)(v28 + 24 * v27);
    goto LABEL_42;
  }
  int v10 = 0;
  v5->i64[0] = -1;
LABEL_122:
  *(_DWORD *)uint64_t v4 = v10;
LABEL_123:
  v91 = v6[4];
  *((_DWORD *)v6[9] + v7) = *((_DWORD *)v91 + 2);
  uint64_t v92 = *(void *)((*v6)[8] + 8 * v7);
  unsigned int v93 = *((_DWORD *)v91 + 2);
  if (v93 >= *((_DWORD *)v91 + 3)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*v91 + 8 * v93) = v92;
  ++*((_DWORD *)v91 + 2);
  return result;
}

uint64_t sub_1CC440E94(uint64_t a1, uint64_t a2)
{
  while (1)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if ((v4 & 6) == 0) {
      return a2;
    }
    uint64_t v5 = v4 < 8 ? 0 : *(void *)((v4 & 0xFFFFFFFFFFFFFFF8) + 16);
    if (**(_WORD **)(v5 + 16) != 19) {
      return a2;
    }
    unint64_t v6 = *(_DWORD **)(v5 + 32);
    if ((*v6 & 0xFFF00) != 0) {
      return a2;
    }
    if ((v6[8] & 0xFFF00) != 0) {
      return a2;
    }
    int v7 = v6[9];
    if ((v7 & 0x80000000) == 0) {
      return a2;
    }
    uint64_t v8 = *(void *)(a1 + 48);
    unint64_t v9 = (void *)(v8 + 408);
    unint64_t v10 = *(unsigned int *)(v8 + 416);
    BOOL v27 = (v7 & 0x7FFFFFFFu) >= v10;
    unint64_t v11 = (v7 & 0x7FFFFFFF) - v10;
    if (v27)
    {
      sub_1CB9153B8((uint64_t)v9, v11 + 1, *(void *)(v8 + 424));
LABEL_65:
      llvm::LiveIntervals::createInterval();
    }
    uint64_t v12 = *(void *)(*v9 + 8 * (v7 & 0x7FFFFFFF));
    if (!v12) {
      goto LABEL_65;
    }
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v13 = *(void *)(v12 + 104);
      if (v13)
      {
        uint64_t v14 = 0;
        unint64_t v15 = v4 & 0xFFFFFFFFFFFFFFF8;
        while (1)
        {
          uint64_t v16 = *(unsigned int *)(a1 + 12);
          uint64_t v17 = *(void *)(v13 + 112);
          if (v16) {
            uint64_t v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 216))(*(void *)(a1 + 64), v16, v17);
          }
          if ((*(void *)(a1 + 16) & v17) == 0) {
            goto LABEL_42;
          }
          unsigned int v18 = *(_DWORD *)(v13 + 8);
          uint64_t v19 = *(void **)v13;
          if (!v18) {
            break;
          }
          uint64_t v20 = v19[3 * v18 - 2];
          unsigned int v21 = *(_DWORD *)(v15 + 24);
          unsigned int v22 = (v20 >> 1) & 3 | *(_DWORD *)((v20 & 0xFFFFFFFFFFFFFFF8) + 24);
          int v23 = *(void **)v13;
          unint64_t v24 = *(unsigned int *)(v13 + 8);
          if (v21 >= v22) {
            goto LABEL_27;
          }
          do
          {
            unint64_t v25 = v24 >> 1;
            uint64_t v26 = v23[3 * (v24 >> 1) + 1];
            LODWORD(v26) = (v26 >> 1) & 3 | *(_DWORD *)((v26 & 0xFFFFFFFFFFFFFFF8) + 24);
            v24 -= (v24 >> 1) + 1;
            BOOL v27 = v21 >= v26;
            if (v21 >= v26) {
              unint64_t v28 = v25 + 1;
            }
            else {
              unint64_t v28 = 0;
            }
            v23 += 3 * v28;
            if (!v27) {
              unint64_t v24 = v25;
            }
          }
          while (v24);
LABEL_28:
          uint64_t v29 = &v19[3 * v18];
          if (v23 == v29
            || ((*v23 >> 1) & 3 | *(_DWORD *)((*v23 & 0xFFFFFFFFFFFFFFF8) + 24)) > *(_DWORD *)(v15 + 24))
          {
            uint64_t v30 = 0;
            if (!v14) {
              goto LABEL_41;
            }
          }
          else
          {
            uint64_t v30 = v23[2];
            unint64_t v31 = v23[1] & 0xFFFFFFFFFFFFFFF8;
            unint64_t v32 = v23 + 3;
            BOOL v33 = v15 == v31 && v32 == v29;
            if (!v33 && *(void *)(v30 + 8) == v15) {
              uint64_t v30 = 0;
            }
            if (!v14)
            {
LABEL_41:
              uint64_t v14 = v30;
              goto LABEL_42;
            }
          }
          if (v30 && v14 != v30) {
            return a2;
          }
LABEL_42:
          uint64_t v13 = *(void *)(v13 + 104);
          if (!v13) {
            goto LABEL_62;
          }
        }
        unsigned int v18 = 0;
LABEL_27:
        int v23 = &v19[3 * v18];
        goto LABEL_28;
      }
    }
    unint64_t v34 = v4 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v35 = *(_DWORD *)(v12 + 8);
    unint64_t v36 = *(void **)v12;
    if (!v35)
    {
      unsigned int v35 = 0;
LABEL_54:
      unint64_t v40 = &v36[3 * v35];
      goto LABEL_55;
    }
    uint64_t v37 = v36[3 * v35 - 2];
    unsigned int v38 = *(_DWORD *)(v34 + 24);
    unsigned int v39 = (v37 >> 1) & 3 | *(_DWORD *)((v37 & 0xFFFFFFFFFFFFFFF8) + 24);
    unint64_t v40 = *(void **)v12;
    unint64_t v41 = *(unsigned int *)(v12 + 8);
    if (v38 >= v39) {
      goto LABEL_54;
    }
    do
    {
      unint64_t v42 = v41 >> 1;
      uint64_t v43 = v40[3 * (v41 >> 1) + 1];
      LODWORD(v43) = (v43 >> 1) & 3 | *(_DWORD *)((v43 & 0xFFFFFFFFFFFFFFF8) + 24);
      v41 -= (v41 >> 1) + 1;
      BOOL v44 = v38 >= v43;
      if (v38 >= v43) {
        unint64_t v45 = v42 + 1;
      }
      else {
        unint64_t v45 = 0;
      }
      v40 += 3 * v45;
      if (!v44) {
        unint64_t v41 = v42;
      }
    }
    while (v41);
LABEL_55:
    unsigned int v46 = &v36[3 * v35];
    if (v40 == v46
      || ((*v40 >> 1) & 3 | *(_DWORD *)((*v40 & 0xFFFFFFFFFFFFFFF8) + 24)) > *(_DWORD *)(v34 + 24))
    {
      return 0;
    }
    uint64_t v14 = v40[2];
    unint64_t v47 = v40[1] & 0xFFFFFFFFFFFFFFF8;
    uint64_t v48 = v40 + 3;
    BOOL v49 = v34 == v47 && v48 == v46;
    if (!v49 && *(void *)(v14 + 8) == v34) {
      return 0;
    }
LABEL_62:
    a2 = v14;
    if (!v14) {
      return a2;
    }
  }
}

void sub_1CC441248()
{
}

__n128 sub_1CC44125C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F26121D8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1CC4412B0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26121D8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

double sub_1CC4412E8(void *a1, uint64_t a2)
{
  v54[16] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 8))
  {
    uint64_t v5 = a1[2];
    uint64_t v4 = a1[3];
    uint64_t v6 = a1[1];
    v34[0] = v35;
    v34[1] = (void *)0x200000000;
    unint64_t v36 = v38;
    uint64_t v37 = 0x200000000;
    uint64_t v39 = 0;
    sub_1CC2CD2F8((uint64_t)v34, v4, v5);
    uint64_t v7 = *(void *)(a2 + 112);
    uint64_t v8 = (int *)a1[4];
    v53[0] = v54;
    v53[1] = (void *)0x1000000000;
    sub_1CC43E7DC((uint64_t)v48, (uint64_t)v34, v8[3], v8[5], v7, (uint64_t)v53, (uint64_t)v8, *(void *)(v6 + 288), *(void *)(v6 + 272), 1, 1);
    sub_1CC43E7DC((uint64_t)v43, a2, v8[2], v8[4], v7, (uint64_t)v53, (uint64_t)v8, *(void *)(v6 + 288), *(void *)(v6 + 272), 1, 1);
    uint64_t v11 = *((unsigned int *)v43[0] + 18);
    if (v11)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = v11 - 1;
      do
      {
        sub_1CC440204((uint64_t)v43, v13, v48);
        BOOL v15 = *(_DWORD *)((char *)v46 + v12) == 5 || v14 == v13++;
        v12 += 48;
      }
      while (!v15);
    }
    uint64_t v16 = *((unsigned int *)v48[0] + 18);
    if (v16)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = v16 - 1;
      do
      {
        sub_1CC440204((uint64_t)v48, v18, v43);
        BOOL v20 = *(_DWORD *)((char *)v51 + v17) == 5 || v19 == v18++;
        v17 += 48;
      }
      while (!v20);
    }
    sub_1CC43E8E4(v43, v48, v9, v10);
    sub_1CC43E8E4(v48, v43, v21, v22);
    unint64_t v40 = v42;
    uint64_t v41 = 0x800000000;
    sub_1CC43F5DC((uint64_t *)v43, (uint64_t *)v48, (uint64_t)&v40, 0);
    sub_1CC43F5DC((uint64_t *)v48, (uint64_t *)v43, (uint64_t)&v40, 0);
    sub_1CC4416B8((uint64_t *)v43);
    sub_1CC4416B8((uint64_t *)v48);
    llvm::LiveRange::join(a2, (unsigned int *)v34, (uint64_t)v44, (uint64_t)v49, (uint64_t *)v53);
    uint64_t v24 = v41;
    if (v41)
    {
      uint64_t v25 = *(void *)(v6 + 288);
      uint64_t v26 = (unint64_t *)v40;
      uint64_t v27 = *(void *)(v25 + 304);
      uint64_t v28 = *(void *)(v25 + 248);
      *(void *)uint64_t v27 = v28;
      *(void *)(v27 + 8) = *(void *)(v28 + 40);
      *(_OWORD *)(v27 + 16) = *(_OWORD *)(v25 + 288);
      *(void *)(v27 + 32) = v25 + 312;
      llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)v27);
      *(_DWORD *)(v27 + 184) = 0;
      uint64_t v29 = 8 * v24;
      do
      {
        unint64_t v30 = *v26++;
        llvm::LiveRangeCalc::extend(*(llvm::LiveRangeCalc **)(v25 + 304), a2, v30, 0, 0, 0);
        v29 -= 8;
      }
      while (v29);
    }
    if (v40 != v42) {
      free(v40);
    }
    if (v46 != &v47) {
      free(v46);
    }
    if (v44 != &v45) {
      free(v44);
    }
    if (v51 != &v52) {
      free(v51);
    }
    if (v49 != &v50) {
      free(v49);
    }
    if (v53[0] != v54) {
      free(v53[0]);
    }
    uint64_t v31 = v39;
    uint64_t v39 = 0;
    if (v31)
    {
      sub_1CB833A08(v31, *(void **)(v31 + 8));
      MEMORY[0x1D25D9CE0](v31, 0x1020C4062D53EE8);
    }
    if (v36 != v38) {
      free(v36);
    }
    if (v34[0] != v35) {
      free(v34[0]);
    }
  }
  else
  {
    uint64_t v33 = a1[2];
    uint64_t v32 = a1[3];
    *(void *)&double result = sub_1CC2CD2F8(a2, v32, v33).n128_u64[0];
  }
  return result;
}

uint64_t *sub_1CC4416B8(uint64_t *result)
{
  uint64_t v1 = *(unsigned int *)(*result + 72);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 48 * v1;
    do
    {
      uint64_t v6 = (int *)(v2[15] + v4);
      int v7 = *v6;
      int v8 = *((unsigned __int8 *)v6 + 40);
      int v9 = *((unsigned __int8 *)v6 + 41);
      if (v7) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v8 == 0;
      }
      if (!v10 && v9 != 0)
      {
        uint64_t v12 = (uint64_t *)*v2;
        uint64_t v13 = *(void *)(*(void *)(*v2 + 64) + v3);
        *(void *)(v13 + 8) = 0;
        double result = llvm::LiveRange::removeValNo(v12, v13);
      }
      v4 += 48;
      v3 += 8;
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t sub_1CC441744(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 120);
  uint64_t v4 = v3 + 48 * a2;
  int v7 = *(unsigned __int8 *)(v4 + 41);
  uint64_t v6 = (unsigned char *)(v4 + 41);
  int v5 = v7;
  if (v7) {
    return v5 != 0;
  }
  uint64_t v8 = v3 + 48 * a2;
  int v10 = *(unsigned __int8 *)(v8 + 42);
  int v9 = (unsigned char *)(v8 + 42);
  if (v10) {
    return v5 != 0;
  }
  if ((*(_DWORD *)(v3 + 48 * a2) - 1) >= 2) {
    return 0;
  }
  *int v9 = 1;
  uint64_t result = sub_1CC441744(a3, **(unsigned int **)(v3 + 48 * a2 + 32), a1);
  *uint64_t v6 = result;
  return result;
}

void sub_1CC4417E0()
{
}

__n128 sub_1CC4417F4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F2612220;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1CC441848(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2612220;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CC441880(uint64_t a1, int *a2)
{
  return sub_1CC441898(*(void *)(*(void *)(a1 + 8) + 600), *(_DWORD *)(*(void *)(a1 + 8) + 616), *a2, *(void *)(a1 + 16), *(uint64_t **)(a1 + 24), *(void *)(a1 + 32));
}

uint64_t sub_1CC441898(uint64_t result, unsigned int a2, int a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  if (a2)
  {
    uint64_t v32 = (37 * a3) & (a2 - 1);
    uint64_t v10 = result + 32 * v32;
    int v33 = *(_DWORD *)v10;
    if (*(_DWORD *)v10 == a3) {
      goto LABEL_3;
    }
    int v34 = 1;
    while (v33 != -1)
    {
      int v35 = v32 + v34++;
      uint64_t v32 = v35 & (a2 - 1);
      int v33 = *(_DWORD *)(result + 32 * v32);
      if (v33 == a3)
      {
        uint64_t v10 = result + 32 * v32;
        goto LABEL_3;
      }
    }
  }
  uint64_t v10 = result + 32 * a2;
LABEL_3:
  if (result + 32 * a2 != v10)
  {
    uint64_t v12 = *(uint64_t **)(v10 + 8);
    uint64_t v11 = *(uint64_t **)(v10 + 16);
    if (v12 != v11)
    {
      uint64_t v13 = 0;
      BOOL v14 = 0;
      BOOL v15 = *(void **)a4;
      do
      {
        if (v15 == (void *)(*(void *)a4 + 24 * *(unsigned int *)(a4 + 8))) {
          return result;
        }
        unsigned int v16 = (*v12 >> 1) & 3 | *(_DWORD *)((*v12 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v16 >= (*(_DWORD *)((v15[1] & 0xFFFFFFFFFFFFFFF8) + 24) | (v15[1] >> 1) & 3))
        {
          v15 += 3;
          continue;
        }
        if (v16 < ((*v15 >> 1) & 3 | *(_DWORD *)((*v15 & 0xFFFFFFFFFFFFFFF8) + 24)))
        {
LABEL_36:
          v12 += 2;
          continue;
        }
        __n128 result = v12[1];
        uint64_t v17 = *(void *)(result + 32);
        if (**(_WORD **)(result + 16) != 14)
        {
          uint64_t v19 = v17 + 32;
          goto LABEL_13;
        }
        uint64_t v18 = *(unsigned int *)(result + 40);
        if (v18 == 2)
        {
LABEL_16:
          int v20 = 0;
        }
        else
        {
          uint64_t v19 = v17 + 32 * v18;
          v17 += 64;
LABEL_13:
          while (*(unsigned char *)v17 || *(_DWORD *)(v17 + 4) != a3)
          {
            v17 += 32;
            if (v17 == v19) {
              goto LABEL_16;
            }
          }
          int v20 = 1;
        }
        if (v13 == *v12)
        {
          int v21 = v14;
          goto LABEL_34;
        }
        unsigned int v22 = *((_DWORD *)a5 + 2);
        uint64_t v23 = *a5;
        if (v22)
        {
          uint64_t v24 = *(void *)(v23 + 24 * v22 - 16);
          unsigned int v25 = (v24 >> 1) & 3 | *(_DWORD *)((v24 & 0xFFFFFFFFFFFFFFF8) + 24);
          uint64_t v26 = *a5;
          unint64_t v27 = *((unsigned int *)a5 + 2);
          if (v16 < v25)
          {
            do
            {
              unint64_t v28 = v27 >> 1;
              uint64_t v29 = *(void *)(v26 + 24 * (v27 >> 1) + 8);
              LODWORD(v29) = (v29 >> 1) & 3 | *(_DWORD *)((v29 & 0xFFFFFFFFFFFFFFF8) + 24);
              v27 -= (v27 >> 1) + 1;
              BOOL v30 = v16 >= v29;
              if (v16 >= v29) {
                unint64_t v31 = v28 + 1;
              }
              else {
                unint64_t v31 = 0;
              }
              v26 += 24 * v31;
              if (!v30) {
                unint64_t v27 = v28;
              }
            }
            while (v27);
            goto LABEL_31;
          }
        }
        else
        {
          unsigned int v22 = 0;
        }
        uint64_t v26 = v23 + 24 * v22;
LABEL_31:
        if (v26 == v23 + 24 * v22)
        {
          int v21 = 1;
        }
        else
        {
          BOOL v14 = *(_DWORD *)(*(void *)(a6 + 120) + 48 * **(unsigned int **)(v26 + 16)) > 1u;
          uint64_t v13 = *v12;
          int v21 = v14;
        }
LABEL_34:
        if ((v20 & v21) != 1) {
          goto LABEL_36;
        }
        __n128 result = sub_1CD5485A8(result);
        uint64_t v11 = *(uint64_t **)(v10 + 16);
      }
      while (v12 != v11);
    }
  }
  return result;
}

void sub_1CC441B28()
{
}

__n128 sub_1CC441B3C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F2612268;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 sub_1CC441B90(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2612268;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CC441BC8(uint64_t a1, int *a2)
{
  return sub_1CC441898(*(void *)(*(void *)(a1 + 8) + 600), *(_DWORD *)(*(void *)(a1 + 8) + 616), *a2, *(void *)(a1 + 16), *(uint64_t **)(a1 + 24), *(void *)(a1 + 32));
}

uint64_t sub_1CC441BE0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  if (a4)
  {
    unsigned __int8 v8 = 0;
    int v9 = 0;
    uint64_t v10 = (void *)(a3 + 16);
    uint64_t v11 = 24 * a4;
    do
    {
      if (*v10 == a5)
      {
        long long v13 = *((_OWORD *)v10 - 1);
        uint64_t v14 = a2;
        if ((~*(_DWORD *)(llvm::LiveRange::addSegment(a1, (uint64_t)&v13) + 8) & 6) == 0) {
          int v9 = 1;
        }
        unsigned __int8 v8 = 1;
      }
      v10 += 3;
      v11 -= 24;
    }
    while (v11);
  }
  else
  {
    int v9 = 0;
    unsigned __int8 v8 = 0;
  }
  return v8 | (v9 << 8);
}

void sub_1CC441C94()
{
}

__n128 sub_1CC441CA8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F26122B0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 sub_1CC441D04(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F26122B0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t sub_1CC441D44(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4)
  {
    int v5 = *(void **)a2;
    uint64_t v6 = *(void *)a2 + 24 * v4;
    unsigned int v7 = *(_DWORD *)((*(void *)(a1 + 24) & 0xFFFFFFFFFFFFFFF8) + 24) | (*(void *)(a1 + 24) >> 1) & 3;
    if (v7 >= ((*(void *)(v6 - 16) >> 1) & 3 | *(_DWORD *)((*(void *)(v6 - 16) & 0xFFFFFFFFFFFFFFF8)
                                                                          + 24)))
      goto LABEL_11;
    do
    {
      unsigned __int8 v8 = v5;
      unint64_t v9 = v4 >> 1;
      uint64_t v10 = v5[3 * (v4 >> 1) + 1];
      LODWORD(v10) = (v10 >> 1) & 3 | *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8) + 24);
      v4 -= (v4 >> 1) + 1;
      BOOL v11 = v7 >= v10;
      if (v7 >= v10) {
        unint64_t v12 = v9 + 1;
      }
      else {
        unint64_t v12 = 0;
      }
      int v5 = &v8[3 * v12];
      if (!v11) {
        unint64_t v4 = v9;
      }
    }
    while (v4);
    if (v5 == (void *)v6 || ((*v5 >> 1) & 3 | *(_DWORD *)((*v5 & 0xFFFFFFFFFFFFFFF8) + 24)) > v7) {
LABEL_11:
    }
      uint64_t v13 = 0;
    else {
      uint64_t v13 = v8[3 * v12 + 2];
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 24);
    uint64_t v15 = *(void *)(a1 + 8);
    *(void *)(v15 + 80) += 16;
    if (((*(void *)v15 + 7) & 0xFFFFFFFFFFFFFFF8) - *(void *)v15 + 16 > *(void *)(v15 + 8) - *(void *)v15)
    {
      unsigned int v19 = *(_DWORD *)(v15 + 24) >> 7;
      if (v19 >= 0x1E) {
        LOBYTE(v19) = 30;
      }
      uint64_t v20 = 4096 << v19;
      uint64_t v13 = (uint64_t)operator new(4096 << v19, (std::align_val_t)8uLL);
      unsigned int v21 = *(_DWORD *)(v15 + 24);
      if (v21 >= *(_DWORD *)(v15 + 28)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v15 + 16) + 8 * v21) = v13;
      ++*(_DWORD *)(v15 + 24);
      *(void *)(v15 + 8) = v13 + v20;
    }
    else
    {
      uint64_t v13 = (*(void *)v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)uint64_t v15 = v13 + 16;
    unsigned int v16 = *(_DWORD *)(a2 + 72);
    unsigned int v17 = *(_DWORD *)(a2 + 76);
    *(_DWORD *)uint64_t v13 = v16;
    *(void *)(v13 + 8) = v14;
    if (v16 >= v17) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a2 + 64) + 8 * v16) = v13;
    ++*(_DWORD *)(a2 + 72);
  }
  uint64_t result = sub_1CC441BE0(a2, v13, **(void **)(a1 + 16), *(_DWORD *)(*(void *)(a1 + 16) + 8), *(void *)(a1 + 32));
  **(unsigned char **)(a1 + 40) |= BYTE1(result);
  if (result) {
    *(void *)(v13 + 8) = *(void *)(*(void *)(a1 + 32) + 8);
  }
  return result;
}

uint64_t sub_1CC441F6C(uint64_t result, uint64_t a2, uint64_t a3, int *a4, unsigned int a5)
{
  int v5 = *a4;
  uint64_t v6 = *(void *)(a2 + 104);
  unint64_t v7 = a3 & 0xFFFFFFFFFFFFFFF8;
  if (v6)
  {
    uint64_t v8 = *(void *)(*(void *)(*(void *)(result + 272) + 232) + 8 * a5) ^ ((uint64_t)(v5 << 7) >> 31);
    unsigned int v9 = (a3 >> 1) & 3;
    while (1)
    {
      if ((*(void *)(v6 + 112) & v8) == 0) {
        goto LABEL_17;
      }
      unsigned int v10 = *(_DWORD *)(v6 + 8);
      BOOL v11 = *(void **)v6;
      if (!v10) {
        break;
      }
      uint64_t v12 = v11[3 * v10 - 2];
      unsigned int v13 = *(_DWORD *)(v7 + 24) | v9;
      unsigned int v14 = (v12 >> 1) & 3 | *(_DWORD *)((v12 & 0xFFFFFFFFFFFFFFF8) + 24);
      uint64_t v15 = *(void **)v6;
      unint64_t v16 = *(unsigned int *)(v6 + 8);
      if (v13 >= v14) {
        goto LABEL_14;
      }
      do
      {
        unint64_t v17 = v16 >> 1;
        uint64_t v18 = v15[3 * (v16 >> 1) + 1];
        LODWORD(v18) = (v18 >> 1) & 3 | *(_DWORD *)((v18 & 0xFFFFFFFFFFFFFFF8) + 24);
        v16 -= (v16 >> 1) + 1;
        BOOL v19 = v13 >= v18;
        if (v13 >= v18) {
          unint64_t v20 = v17 + 1;
        }
        else {
          unint64_t v20 = 0;
        }
        v15 += 3 * v20;
        if (!v19) {
          unint64_t v16 = v17;
        }
      }
      while (v16);
LABEL_15:
      if (v15 != &v11[3 * v10]
        && ((*v15 >> 1) & 3 | *(_DWORD *)((*v15 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)(v7 + 24) | v9))
      {
        return result;
      }
LABEL_17:
      uint64_t v6 = *(void *)(v6 + 104);
      if (!v6) {
        goto LABEL_18;
      }
    }
    unsigned int v10 = 0;
LABEL_14:
    uint64_t v15 = &v11[3 * v10];
    goto LABEL_15;
  }
LABEL_18:
  *a4 = v5 | 0x10000000;
  unsigned int v21 = *(_DWORD *)(a2 + 8);
  unsigned int v22 = *(void **)a2;
  if (v21)
  {
    uint64_t v23 = v22[3 * v21 - 2];
    unsigned int v24 = *(_DWORD *)(v7 + 24);
    if (v24 < ((v23 >> 1) & 3 | *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFF8) + 24)))
    {
      unsigned int v25 = *(void **)a2;
      unint64_t v26 = *(unsigned int *)(a2 + 8);
      do
      {
        unint64_t v27 = v26 >> 1;
        uint64_t v28 = v25[3 * (v26 >> 1) + 1];
        LODWORD(v28) = (v28 >> 1) & 3 | *(_DWORD *)((v28 & 0xFFFFFFFFFFFFFFF8) + 24);
        v26 -= (v26 >> 1) + 1;
        BOOL v29 = v24 >= v28;
        if (v24 >= v28) {
          unint64_t v30 = v27 + 1;
        }
        else {
          unint64_t v30 = 0;
        }
        v25 += 3 * v30;
        if (!v29) {
          unint64_t v26 = v27;
        }
      }
      while (v26);
      goto LABEL_30;
    }
  }
  else
  {
    unsigned int v21 = 0;
  }
  unsigned int v25 = &v22[3 * v21];
LABEL_30:
  unint64_t v31 = &v22[3 * v21];
  if (v25 == v31) {
    goto LABEL_41;
  }
  unsigned int v32 = *(_DWORD *)((*v25 & 0xFFFFFFFFFFFFFFF8) + 24);
  unsigned int v33 = *(_DWORD *)(v7 + 24);
  if (((*v25 >> 1) & 3 | v32) > v33 || v7 != (v25[1] & 0xFFFFFFFFFFFFFFF8)) {
    goto LABEL_35;
  }
  v25 += 3;
  if (v25 == v31)
  {
LABEL_41:
    *(unsigned char *)(result + 656) = 1;
    return result;
  }
  unsigned int v32 = *(_DWORD *)((*v25 & 0xFFFFFFFFFFFFFFF8) + 24);
LABEL_35:
  if (v33 < v32) {
    goto LABEL_41;
  }
  if ((~*((_DWORD *)v25 + 2) & 6) == 0 || v25[2] == 0) {
    goto LABEL_41;
  }
  return result;
}

uint64_t sub_1CC442178(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

uint64_t sub_1CC442194()
{
  v3.n128_u64[0] = (unint64_t)"Coalesce copies (default=true)";
  v3.n128_u64[1] = 30;
  LOBYTE(v1) = 1;
  uint64_t v2 = &v1;
  int v4 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCD2C50, "join-liveintervals", &v3, (unsigned char **)&v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD2C50, &dword_1CB82C000);
  v3.n128_u64[0] = (unint64_t)"Apply the terminal rule";
  v3.n128_u64[1] = 23;
  LOBYTE(v1) = 0;
  uint64_t v2 = &v1;
  int v4 = 1;
  sub_1CD56FBD8(&v3, (char **)&v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCD2D10, &dword_1CB82C000);
  v3.n128_u64[0] = (unint64_t)"Coalesce copies on split edges (default=subtarget)";
  v3.n128_u64[1] = 50;
  LODWORD(v2) = 1;
  sub_1CD56FD50((long long *)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCD2DD0, &dword_1CB82C000);
  v3.n128_u64[0] = (unint64_t)"Coalesce copies that span blocks (default=subtarget)";
  v3.n128_u64[1] = 52;
  int v4 = 0;
  uint64_t v2 = &v4;
  int v1 = 1;
  sub_1CD56FE5C(&v3, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CC243CA8, &qword_1EBCD2E90, &dword_1CB82C000);
  v3.n128_u64[0] = (unint64_t)"Verify machine instrs before and after register coalescing";
  v3.n128_u64[1] = 58;
  LODWORD(v2) = 1;
  sub_1CD56FFD4((long long *)&v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCD2F50, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"During rematerialization for a copy, if the def instruction has many other copy use"
                                     "s to be rematerialized, delay the multiple separate live interval update work and d"
                                     "o them all at once after all those rematerialization are done. It will save a lot o"
                                     "f repeated work. ";
  v3.n128_u64[1] = 266;
  int v1 = 100;
  uint64_t v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCD3010, "late-remat-update-threshold", &v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD3010, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"If the valnos size of an interval is larger than the threshold, it is regarded as a"
                                     " large interval. ";
  v3.n128_u64[1] = 100;
  int v1 = 100;
  uint64_t v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCD30D0, "large-interval-size-threshold", &v4, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD30D0, &dword_1CB82C000);
  int v4 = 1;
  v3.n128_u64[0] = (unint64_t)"For a large interval, if it is coalesed with other live intervals many times more t"
                                     "han the threshold, stop its coalescing to control the compile time. ";
  v3.n128_u64[1] = 151;
  int v1 = 100;
  uint64_t v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCD3190, "large-interval-freq-threshold", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD3190, &dword_1CB82C000);
}

BOOL llvm::RegPressureTracker::isTopClosed(llvm::RegPressureTracker *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*((unsigned char *)this + 56)) {
    return *(void *)(v1 + 312) > 7uLL;
  }
  else {
    return *(void *)(v1 + 312) == 0;
  }
}

BOOL llvm::RegPressureTracker::isBottomClosed(llvm::RegPressureTracker *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (*((unsigned char *)this + 56)) {
    return *(void *)(v1 + 320) > 7uLL;
  }
  else {
    return *(void *)(v1 + 320) == 0;
  }
}

llvm *llvm::RegPressureDelta::dump(llvm::RegPressureDelta *this)
{
  uint64_t v2 = llvm::dbgs(this);
  __n128 v3 = (void *)*((void *)v2 + 4);
  if (*((void *)v2 + 3) - (void)v3 > 7uLL)
  {
    *__n128 v3 = 0x3D7373656378455BLL;
    *((void *)v2 + 4) += 8;
  }
  else
  {
    llvm::raw_ostream::write(v2, "[Excess=", 8uLL);
  }
  int v4 = llvm::PressureChange::dump(this);
  int v5 = llvm::dbgs(v4);
  uint64_t v6 = (void *)*((void *)v5 + 4);
  if (*((void *)v5 + 3) - (void)v6 > 0xDuLL)
  {
    qmemcpy(v6, ", CriticalMax=", 14);
    *((void *)v5 + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(v5, ", CriticalMax=", 0xEuLL);
  }
  unint64_t v7 = llvm::PressureChange::dump((llvm::RegPressureDelta *)((char *)this + 4));
  uint64_t v8 = llvm::dbgs(v7);
  unsigned int v9 = (void *)*((void *)v8 + 4);
  if (*((void *)v8 + 3) - (void)v9 > 0xCuLL)
  {
    qmemcpy(v9, ", CurrentMax=", 13);
    *((void *)v8 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(v8, ", CurrentMax=", 0xDuLL);
  }
  unsigned int v10 = llvm::PressureChange::dump((llvm::RegPressureDelta *)((char *)this + 8));
  uint64_t result = llvm::dbgs(v10);
  uint64_t v12 = (_WORD *)*((void *)result + 4);
  if (*((void *)result + 3) - (void)v12 > 1uLL)
  {
    *uint64_t v12 = 2653;
    *((void *)result + 4) += 2;
  }
  else
  {
    return llvm::raw_ostream::write(result, "]\n", 2uLL);
  }
  return result;
}

uint64_t llvm::RegPressureTracker::increaseRegPressure(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a3 && a4)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void **)(result + 24);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(*v6 + 16) + 176))(*(void *)(*v6 + 16));
    uint64_t v8 = v7;
    if ((a2 & 0x80000000) != 0)
    {
      unint64_t v9 = *(void *)(v6[3] + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v10 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v7 + 320))(v7, v9);
      uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v8 + 280))(v8, v9);
    }
    else
    {
      unsigned int v10 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 328))(v7, a2);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 288))(v8, a2);
    }
    uint64_t v11 = *v10;
    if (v11 != -1)
    {
      uint64_t v12 = *(void *)(v5 + 72);
      uint64_t v13 = **(void **)(v5 + 48);
      unsigned int v14 = v10 + 1;
      do
      {
        *(_DWORD *)(v12 + 4 * v11) += result;
        uint64_t v15 = *(v14 - 1);
        unsigned int v16 = *(_DWORD *)(v13 + 4 * v15);
        if (v16 <= *(_DWORD *)(v12 + 4 * v15)) {
          unsigned int v16 = *(_DWORD *)(v12 + 4 * v15);
        }
        *(_DWORD *)(v13 + 4 * v15) = v16;
        unsigned int v17 = *v14++;
        uint64_t v11 = v17;
      }
      while (v17 != -1);
    }
  }
  return result;
}

uint64_t llvm::RegPressureTracker::decreaseRegPressure(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4 && a3)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void **)(result + 24);
    uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(*v6 + 16) + 176))(*(void *)(*v6 + 16));
    uint64_t v8 = v7;
    if ((a2 & 0x80000000) != 0)
    {
      unint64_t v9 = *(void *)(v6[3] + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v10 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v7 + 320))(v7, v9);
      uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v8 + 280))(v8, v9);
    }
    else
    {
      unsigned int v10 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 328))(v7, a2);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 288))(v8, a2);
    }
    uint64_t v11 = *v10;
    if (v11 != -1)
    {
      uint64_t v12 = *(void *)(v5 + 72);
      uint64_t v13 = v10 + 1;
      do
      {
        *(_DWORD *)(v12 + 4 * v11) -= result;
        unsigned int v14 = *v13++;
        uint64_t v11 = v14;
      }
      while (v14 != -1);
    }
  }
  return result;
}

uint64_t llvm::IntervalPressure::reset(uint64_t this)
{
  *(void *)(this + 312) = 0;
  *(void *)(this + 320) = 0;
  *(void *)(this + 8) = *(void *)this;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 176) = 0;
  return this;
}

uint64_t llvm::RegionPressure::reset(uint64_t this)
{
  *(void *)(this + 312) = 0;
  *(void *)(this + 320) = 0;
  *(void *)(this + 8) = *(void *)this;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 176) = 0;
  return this;
}

uint64_t llvm::IntervalPressure::openTop(uint64_t result, uint64_t a2)
{
  if (((*(void *)(result + 312) >> 1) & 3 | *(_DWORD *)((*(void *)(result + 312) & 0xFFFFFFFFFFFFFFF8)
                                                                       + 24)) > (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8)
                                                                                           + 24) | (a2 >> 1) & 3))
  {
    *(void *)(result + 312) = 0;
    *(_DWORD *)(result + 32) = 0;
  }
  return result;
}

uint64_t llvm::RegionPressure::openTop(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 312) == a2)
  {
    *(void *)(result + 312) = 0;
    *(_DWORD *)(result + 32) = 0;
  }
  return result;
}

uint64_t llvm::IntervalPressure::openBottom(uint64_t result, uint64_t a2)
{
  if (((*(void *)(result + 320) >> 1) & 3 | *(_DWORD *)((*(void *)(result + 320) & 0xFFFFFFFFFFFFFFF8)
                                                                       + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8)
                                                                                            + 24) | (a2 >> 1) & 3))
  {
    *(void *)(result + 320) = 0;
    *(_DWORD *)(result + 32) = 0;
  }
  return result;
}

uint64_t llvm::RegionPressure::openBottom(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 320) == a2)
  {
    *(void *)(result + 320) = 0;
    *(_DWORD *)(result + 32) = 0;
  }
  return result;
}

_DWORD *llvm::LiveRegSet::init(llvm::LiveRegSet *this, const llvm::MachineRegisterInfo *a2)
{
  uint64_t result = (_DWORD *)(*(uint64_t (**)(void))(**(void **)(*(void *)a2 + 16) + 176))(*(void *)(*(void *)a2 + 16));
  int v5 = result[4];
  size_t v6 = (*((_DWORD *)a2 + 8) + v5);
  unsigned int v7 = *((_DWORD *)this + 38);
  if (v7 < v6 || v7 >> 2 > v6)
  {
    free(*((void **)this + 18));
    uint64_t result = malloc_type_calloc(v6, 1uLL, 0x6D9A4F0CuLL);
    if (!result && (v6 || (uint64_t result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *((void *)this + 18) = result;
    *((_DWORD *)this + 38) = v6;
  }
  *((_DWORD *)this + 40) = v5;
  return result;
}

uint64_t llvm::LiveRegSet::clear(uint64_t this)
{
  *(_DWORD *)(this + 8) = 0;
  return this;
}

uint64_t llvm::RegPressureTracker::reset(uint64_t this)
{
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 80) = *(void *)(this + 72);
  *(void *)(this + 336) = *(void *)(this + 328);
  uint64_t v1 = *(uint64_t **)(this + 48);
  uint64_t v2 = *v1;
  v1[39] = 0;
  v1[40] = 0;
  v1[1] = v2;
  *((_DWORD *)v1 + 8) = 0;
  *((_DWORD *)v1 + 44) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 272) = 0;
  return this;
}

_DWORD *llvm::RegPressureTracker::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, int a8)
{
  *(void *)(a1 + 32) = 0;
  uint64_t v15 = (void *)(a1 + 32);
  unsigned int v17 = (void *)(a1 + 72);
  uint64_t v16 = *(void *)(a1 + 72);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 80) = v16;
  *(void *)(a1 + 336) = *(void *)(a1 + 328);
  uint64_t v18 = *(uint64_t **)(a1 + 48);
  uint64_t v19 = *v18;
  v18[39] = 0;
  v18[40] = 0;
  v18[1] = v19;
  *((_DWORD *)v18 + 8) = 0;
  *((_DWORD *)v18 + 44) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(void *)a1 = a2;
  uint64_t v20 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  *(void *)(a1 + 8) = v20;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = *(void *)(*(void *)a1 + 40);
  *(void *)(a1 + 40) = a5;
  *(unsigned char *)(a1 + 57) = a8;
  *(unsigned char *)(a1 + 58) = a7;
  if (*(unsigned char *)(a1 + 56)) {
    *uint64_t v15 = a4;
  }
  *(void *)(a1 + 64) = a6;
  unsigned int v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 296))(v20);
  unint64_t v22 = v21;
  uint64_t v23 = *(void *)(a1 + 88);
  unsigned int v24 = *(char **)(a1 + 72);
  if (v21 > (unint64_t)((v23 - (uint64_t)v24) >> 2))
  {
    if (v24)
    {
      *(void *)(a1 + 80) = v24;
      operator delete(v24);
      uint64_t v23 = 0;
      *unsigned int v17 = 0;
      v17[1] = 0;
      v17[2] = 0;
    }
    uint64_t v40 = v23 >> 1;
    if (v23 >> 1 <= v22) {
      uint64_t v40 = v22;
    }
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v41 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v41 = v40;
    }
    if (v41 >> 62) {
      abort();
    }
    unsigned int v24 = (char *)operator new(4 * v41);
    *(void *)(a1 + 72) = v24;
    *(void *)(a1 + 88) = &v24[4 * v41];
    bzero(v24, 4 * v22);
  }
  else
  {
    unsigned int v25 = *(unsigned char **)(a1 + 80);
    unint64_t v26 = (v25 - v24) >> 2;
    if (v26 >= v21) {
      uint64_t v27 = v21;
    }
    else {
      uint64_t v27 = (v25 - v24) >> 2;
    }
    if (v27) {
      bzero(*(void **)(a1 + 72), 4 * v27);
    }
    BOOL v28 = v22 >= v26;
    unint64_t v29 = v22 - v26;
    if (v29 != 0 && v28)
    {
      bzero(v25, 4 * v22 - ((v25 - v24) & 0xFFFFFFFFFFFFFFFCLL));
      unint64_t v30 = &v25[4 * v29];
      goto LABEL_12;
    }
  }
  unint64_t v30 = &v24[4 * v22];
LABEL_12:
  *(void *)(a1 + 80) = v30;
  unint64_t v31 = *(void **)(a1 + 48);
  if (v31 != v17) {
    sub_1CC19E0C8(v31, v24, v30, (v30 - v24) >> 2);
  }
  unsigned int v32 = *(_DWORD **)(a1 + 24);
  uint64_t result = (_DWORD *)(*(uint64_t (**)(void))(**(void **)(*(void *)v32 + 16) + 176))(*(void *)(*(void *)v32 + 16));
  int v34 = result[4];
  size_t v35 = (v32[8] + v34);
  unsigned int v36 = *(_DWORD *)(a1 + 248);
  if (v36 < v35 || v36 >> 2 > v35)
  {
    free(*(void **)(a1 + 240));
    uint64_t result = malloc_type_calloc(v35, 1uLL, 0x6D9A4F0CuLL);
    if (!result && (v35 || (uint64_t result = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_42:
    }
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    *(void *)(a1 + 240) = result;
    *(_DWORD *)(a1 + 248) = v35;
  }
  *(_DWORD *)(a1 + 256) = v34;
  if (a8)
  {
    size_t v38 = *(unsigned int *)(*(void *)(a1 + 24) + 32);
    unsigned int v39 = *(_DWORD *)(a1 + 320);
    if (v39 < v38 || v39 >> 2 > v38)
    {
      free(*(void **)(a1 + 312));
      uint64_t result = malloc_type_calloc(v38, 1uLL, 0x6D9A4F0CuLL);
      if (!result)
      {
        if (v38) {
          goto LABEL_42;
        }
        uint64_t result = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!result) {
          goto LABEL_42;
        }
      }
      *(void *)(a1 + 312) = result;
      *(_DWORD *)(a1 + 320) = v38;
    }
  }
  return result;
}

unint64_t llvm::RegPressureTracker::getCurrSlot(llvm::RegPressureTracker *this)
{
  unint64_t v1 = *((void *)this + 8);
  uint64_t v2 = *((void *)this + 5);
  uint64_t v3 = v2 + 48;
  if (v1 != v2 + 48)
  {
    while (1)
    {
      int v4 = **(unsigned __int16 **)(v1 + 16);
      if ((v4 - 13) >= 5 && v4 != 23) {
        break;
      }
      if ((*(unsigned char *)v1 & 4) == 0)
      {
        while ((*(_WORD *)(v1 + 44) & 8) != 0)
          unint64_t v1 = *(void *)(v1 + 8);
      }
      unint64_t v1 = *(void *)(v1 + 8);
      if (v1 == v3) {
        return *(void *)(*(void *)(*(void *)(*((void *)this + 4) + 288) + 392)
      }
                         + 16 * *(unsigned int *)(v2 + 24)
                         + 8);
    }
  }
  if (v3 == v1) {
    return *(void *)(*(void *)(*(void *)(*((void *)this + 4) + 288) + 392)
  }
                     + 16 * *(unsigned int *)(v2 + 24)
                     + 8);
  uint64_t v7 = *(void *)(*((void *)this + 4) + 288);
  __int16 v8 = *(_WORD *)(v1 + 44);
  unint64_t v9 = v1;
  if ((v8 & 0xC) != 0)
  {
    if ((v8 & 4) != 0)
    {
      unint64_t v9 = v1;
      do
        unint64_t v9 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v9 + 44) & 4) != 0);
    }
    if ((v8 & 8) != 0)
    {
      do
        unint64_t v1 = *(void *)(v1 + 8);
      while ((*(_WORD *)(v1 + 44) & 8) != 0);
    }
  }
  unint64_t v10 = *(void *)(v1 + 8);
  if (v9 != v10)
  {
    while (1)
    {
      unsigned int v11 = **(unsigned __int16 **)(v9 + 16);
      BOOL v12 = v11 > 0x17;
      int v13 = (1 << v11) & 0x83E000;
      if (v12 || v13 == 0) {
        break;
      }
      unint64_t v9 = *(void *)(v9 + 8);
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t v15 = *(void *)(v7 + 368);
  uint64_t v16 = *(unsigned int *)(v7 + 384);
  if (!v16) {
    goto LABEL_27;
  }
  LODWORD(v17) = ((v9 >> 4) ^ (v9 >> 9)) & (v16 - 1);
  uint64_t v18 = (uint64_t *)(v15 + 16 * v17);
  uint64_t v19 = *v18;
  if (v9 != *v18)
  {
    int v20 = 1;
    while (v19 != -4096)
    {
      int v21 = v17 + v20++;
      uint64_t v17 = v21 & (v16 - 1);
      uint64_t v19 = *(void *)(v15 + 16 * v17);
      if (v9 == v19)
      {
        uint64_t v18 = (uint64_t *)(v15 + 16 * v17);
        return v18[1] & 0xFFFFFFFFFFFFFFF8 | 4;
      }
    }
LABEL_27:
    uint64_t v18 = (uint64_t *)(v15 + 16 * v16);
  }
  return v18[1] & 0xFFFFFFFFFFFFFFF8 | 4;
}

uint64_t sub_1CC442FE8(uint64_t result, uint64_t a2)
{
  if (result != a2)
  {
    while (1)
    {
      int v2 = **(unsigned __int16 **)(result + 16);
      if ((v2 - 13) >= 5 && v2 != 23) {
        break;
      }
      if ((*(unsigned char *)result & 4) == 0)
      {
        while ((*(_WORD *)(result + 44) & 8) != 0)
          uint64_t result = *(void *)(result + 8);
      }
      uint64_t result = *(void *)(result + 8);
      if (result == a2) {
        return a2;
      }
    }
  }
  return result;
}

unint64_t llvm::RegPressureTracker::closeTop(unint64_t this)
{
  unint64_t v1 = this;
  if (*(unsigned char *)(this + 56))
  {
    this = llvm::RegPressureTracker::getCurrSlot((llvm::RegPressureTracker *)this);
    uint64_t v2 = *(void *)(v1 + 48);
    *(void *)(v2 + 312) = this;
  }
  else
  {
    *(void *)(*(void *)(this + 48) + 312) = *(void *)(this + 64);
    uint64_t v2 = *(void *)(this + 48);
  }
  unsigned int v3 = *(_DWORD *)(v1 + 104);
  if (*(_DWORD *)(v2 + 36) < v3) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    int v5 = (void *)(*(void *)(v1 + 96) + 8);
    do
    {
      uint64_t v6 = *v5;
      if (*v5)
      {
        unsigned int v7 = *(_DWORD *)(v1 + 256);
        unsigned int v8 = *((_DWORD *)v5 - 2);
        BOOL v9 = v8 >= v7;
        LODWORD(v10) = (v8 - v7) | 0x80000000;
        if (v9) {
          uint64_t v10 = v10;
        }
        else {
          uint64_t v10 = v8;
        }
        unint64_t v11 = *(unsigned int *)(v2 + 32);
        if (v11 >= *(unsigned int *)(v2 + 36)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        BOOL v12 = (void *)(*(void *)(v2 + 24) + 16 * v11);
        *BOOL v12 = v10;
        v12[1] = v6;
        ++*(_DWORD *)(v2 + 32);
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
  }
  return this;
}

unint64_t llvm::RegPressureTracker::closeBottom(unint64_t this)
{
  unint64_t v1 = this;
  if (*(unsigned char *)(this + 56))
  {
    this = llvm::RegPressureTracker::getCurrSlot((llvm::RegPressureTracker *)this);
    uint64_t v2 = *(void *)(v1 + 48);
    *(void *)(v2 + 320) = this;
  }
  else
  {
    *(void *)(*(void *)(this + 48) + 320) = *(void *)(this + 64);
    uint64_t v2 = *(void *)(this + 48);
  }
  unsigned int v3 = *(_DWORD *)(v1 + 104);
  if (*(_DWORD *)(v2 + 180) < v3) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    int v5 = (void *)(*(void *)(v1 + 96) + 8);
    do
    {
      uint64_t v6 = *v5;
      if (*v5)
      {
        unsigned int v7 = *(_DWORD *)(v1 + 256);
        unsigned int v8 = *((_DWORD *)v5 - 2);
        BOOL v9 = v8 >= v7;
        LODWORD(v10) = (v8 - v7) | 0x80000000;
        if (v9) {
          uint64_t v10 = v10;
        }
        else {
          uint64_t v10 = v8;
        }
        unint64_t v11 = *(unsigned int *)(v2 + 176);
        if (v11 >= *(unsigned int *)(v2 + 180)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        BOOL v12 = (void *)(*(void *)(v2 + 168) + 16 * v11);
        *BOOL v12 = v10;
        v12[1] = v6;
        ++*(_DWORD *)(v2 + 176);
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
  }
  return this;
}

uint64_t llvm::RegPressureTracker::closeRegion(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 48);
  if (*(unsigned char *)(this + 56))
  {
    unint64_t v3 = *(void *)(v2 + 320);
    if (*(void *)(v2 + 312) <= 7uLL)
    {
      if (v3 <= 7) {
        return this;
      }
      this = llvm::RegPressureTracker::getCurrSlot((llvm::RegPressureTracker *)this);
      *(void *)(v2 + 312) = this;
LABEL_5:
      unsigned int v4 = *(_DWORD *)(v1 + 104);
      if (*(_DWORD *)(v2 + 36) < v4) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4)
      {
        uint64_t v5 = 16 * v4;
        uint64_t v6 = (void *)(*(void *)(v1 + 96) + 8);
        do
        {
          uint64_t v7 = *v6;
          if (*v6)
          {
            unsigned int v8 = *(_DWORD *)(v1 + 256);
            unsigned int v9 = *((_DWORD *)v6 - 2);
            BOOL v10 = v9 >= v8;
            LODWORD(v11) = (v9 - v8) | 0x80000000;
            if (v10) {
              uint64_t v11 = v11;
            }
            else {
              uint64_t v11 = v9;
            }
            unint64_t v12 = *(unsigned int *)(v2 + 32);
            if (v12 >= *(unsigned int *)(v2 + 36)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v13 = (void *)(*(void *)(v2 + 24) + 16 * v12);
            *int v13 = v11;
            v13[1] = v7;
            ++*(_DWORD *)(v2 + 32);
          }
          v6 += 2;
          v5 -= 16;
        }
        while (v5);
      }
      return this;
    }
    if (v3 > 7) {
      return this;
    }
  }
  else
  {
    uint64_t v14 = *(void *)(v2 + 320);
    if (*(void *)(v2 + 312))
    {
      if (v14) {
        return this;
      }
      *(void *)(v2 + 312) = *(void *)(this + 64);
      uint64_t v2 = *(void *)(this + 48);
      goto LABEL_5;
    }
    if (!v14) {
      return this;
    }
  }

  return llvm::RegPressureTracker::closeBottom(this);
}

void llvm::RegPressureTracker::initLiveThru(llvm::RegPressureTracker *this, const llvm::RegPressureTracker *a2)
{
  unsigned int v4 = (uint64_t *)((char *)this + 328);
  unint64_t v5 = (*(unsigned int (**)(void))(**((void **)this + 1) + 296))(*((void *)this + 1));
  uint64_t v6 = *((void *)this + 43);
  uint64_t v7 = (char *)*((void *)this + 41);
  if (v5 > (v6 - (uint64_t)v7) >> 2)
  {
    if (v7)
    {
      *((void *)this + 42) = v7;
      operator delete(v7);
      uint64_t v6 = 0;
      *unsigned int v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
    }
    uint64_t v32 = v6 >> 1;
    if (v6 >> 1 <= v5) {
      uint64_t v32 = v5;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v32;
    }
    if (v33 >> 62) {
      abort();
    }
    int v34 = (char *)operator new(4 * v33);
    *((void *)this + 41) = v34;
    *((void *)this + 43) = &v34[4 * v33];
    bzero(v34, 4 * v5);
    size_t v35 = &v34[4 * v5];
  }
  else
  {
    unsigned int v8 = (unsigned char *)*((void *)this + 42);
    int64_t v9 = v8 - v7;
    unint64_t v10 = (v8 - v7) >> 2;
    if (v10 >= v5) {
      uint64_t v11 = v5;
    }
    else {
      uint64_t v11 = (v8 - v7) >> 2;
    }
    if (v11)
    {
      unsigned int v36 = (char *)*((void *)this + 41);
      bzero(v7, 4 * v11);
      uint64_t v7 = v36;
    }
    BOOL v12 = v5 >= v10;
    unint64_t v13 = v5 - v10;
    if (v13 != 0 && v12)
    {
      bzero(v8, 4 * v5 - (v9 & 0xFFFFFFFFFFFFFFFCLL));
      size_t v35 = &v8[4 * v13];
    }
    else
    {
      size_t v35 = &v7[4 * v5];
    }
  }
  *((void *)this + 42) = v35;
  uint64_t v14 = *((void *)this + 6);
  uint64_t v15 = *(unsigned int *)(v14 + 176);
  if (v15)
  {
    uint64_t v16 = *(int **)(v14 + 168);
    uint64_t v17 = &v16[4 * v15];
    do
    {
      int v18 = *v16;
      if (*v16 < 0)
      {
        uint64_t v19 = v18 & 0x7FFFFFFF;
        unsigned int v20 = *(unsigned __int8 *)(*((void *)a2 + 39) + v19);
        unsigned int v21 = *((_DWORD *)a2 + 68);
        if (v21 <= v20) {
          goto LABEL_16;
        }
        while (((*(_DWORD *)(*((void *)a2 + 33) + 4 * v20) ^ v18) & 0x7FFFFFFF) != 0)
        {
          v20 += 256;
          if (v20 >= v21) {
            goto LABEL_16;
          }
        }
        if (v21 == v20)
        {
LABEL_16:
          if (*((void *)v16 + 1))
          {
            unint64_t v22 = (void *)*((void *)this + 3);
            uint64_t v23 = (*(uint64_t (**)(void))(**(void **)(*v22 + 16) + 176))(*(void *)(*v22 + 16));
            unint64_t v24 = *(void *)(v22[3] + 16 * v19) & 0xFFFFFFFFFFFFFFF8;
            unsigned int v25 = (unsigned int *)(*(uint64_t (**)(void))(*(void *)v23 + 320))();
            unint64_t v26 = (int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v23 + 280))(v23, v24);
            uint64_t v27 = *v25;
            if (v27 != -1)
            {
              int v28 = *v26;
              uint64_t v29 = *v4;
              unint64_t v30 = v25 + 1;
              do
              {
                *(_DWORD *)(v29 + 4 * v27) += v28;
                unsigned int v31 = *v30++;
                uint64_t v27 = v31;
              }
              while (v31 != -1);
            }
          }
        }
      }
      v16 += 4;
    }
    while (v16 != v17);
  }
}

void *llvm::RegisterOperands::collect(void *this, const llvm::MachineInstr *a2, const llvm::TargetRegisterInfo *a3, const llvm::MachineRegisterInfo *a4, int a5, char a6)
{
  uint64_t v7 = (uint64_t)this;
  v52[0] = this;
  v52[1] = a3;
  v52[2] = a4;
  char v53 = a6;
  __int16 v8 = *((_WORD *)a2 + 22);
  int64_t v9 = a2;
  if (!a5)
  {
    if ((v8 & 4) != 0)
    {
      int64_t v9 = a2;
      do
        int64_t v9 = (const llvm::MachineInstr *)(*(void *)v9 & 0xFFFFFFFFFFFFFFF8);
      while ((*((_WORD *)v9 + 22) & 4) != 0);
    }
    uint64_t v26 = *((void *)a2 + 3) + 48;
    uint64_t v27 = (int *)*((void *)v9 + 4);
    uint64_t v28 = *((unsigned int *)v9 + 10);
    uint64_t v29 = &v27[8 * v28];
    if (!v28)
    {
      uint64_t v43 = *((void *)v9 + 1);
      if (v43 == v26)
      {
        int64_t v9 = (const llvm::MachineInstr *)(*((void *)a2 + 3) + 48);
      }
      else
      {
        int64_t v9 = (const llvm::MachineInstr *)(*((void *)a2 + 3) + 48);
        if ((*(_WORD *)(v43 + 44) & 4) != 0)
        {
          do
          {
            uint64_t v50 = v43;
            uint64_t v51 = *(unsigned int *)(v43 + 40);
            if (v51)
            {
              int64_t v9 = (const llvm::MachineInstr *)v43;
              goto LABEL_93;
            }
            uint64_t v43 = *(void *)(v43 + 8);
          }
          while (v43 != v26 && (*(_WORD *)(v43 + 44) & 4) != 0);
          int64_t v9 = (const llvm::MachineInstr *)(*((void *)a2 + 3) + 48);
LABEL_93:
          uint64_t v27 = *(int **)(v50 + 32);
          uint64_t v29 = &v27[8 * v51];
        }
      }
    }
    if (v27 == v29)
    {
LABEL_54:
      uint64_t v37 = *(unsigned int *)(v7 + 152);
      if (v37)
      {
        size_t v38 = *(uint64_t **)(v7 + 144);
        unsigned int v39 = &v38[2 * v37];
        uint64_t v40 = (void *)(v7 + 288);
        do
        {
          uint64_t v41 = *v38;
          uint64_t v42 = v38[1];
          v38 += 2;
          this = sub_1CC44554C(v40, v41, v42);
        }
        while (v38 != v39);
      }
      return this;
    }
    while (1)
    {
      int v30 = *v27;
      if (!*v27)
      {
        unsigned int v31 = v27[1];
        if (v31)
        {
          int v32 = v30 & 0x30000000;
          if ((v30 & 0x1000000) == 0)
          {
            unint64_t v33 = (uint64_t *)v7;
            if (v32) {
              goto LABEL_37;
            }
LABEL_36:
            this = sub_1CC446AFC((uint64_t)v52, v31, v33);
            goto LABEL_37;
          }
          if (v32) {
            BOOL v35 = 1;
          }
          else {
            BOOL v35 = (v30 & 0xFFF00) == 0;
          }
          if (!v35)
          {
            this = sub_1CC446AFC((uint64_t)v52, v27[1], (uint64_t *)v7);
            int v30 = *v27;
          }
          int v36 = v30 & 0x5000000;
          if (v36 == 83886080) {
            unint64_t v33 = (uint64_t *)(v7 + 288);
          }
          else {
            unint64_t v33 = (uint64_t *)(v7 + 144);
          }
          if (v36 != 83886080 || (a6 & 1) == 0) {
            goto LABEL_36;
          }
        }
      }
LABEL_37:
      v27 += 8;
      if (v27 == v29)
      {
        uint64_t v34 = *((void *)v9 + 1);
        if (v34 == v26) {
          goto LABEL_54;
        }
        uint64_t v27 = v29;
        int64_t v9 = (const llvm::MachineInstr *)v26;
        if ((*(_WORD *)(v34 + 44) & 4) != 0)
        {
          while (1)
          {
            uint64_t v48 = v34;
            uint64_t v49 = *(unsigned int *)(v34 + 40);
            if (v49) {
              break;
            }
            uint64_t v34 = *(void *)(v34 + 8);
            if (v34 == v26 || (*(_WORD *)(v34 + 44) & 4) == 0)
            {
              int64_t v9 = (const llvm::MachineInstr *)v26;
              goto LABEL_88;
            }
          }
          int64_t v9 = (const llvm::MachineInstr *)v34;
LABEL_88:
          uint64_t v27 = *(int **)(v48 + 32);
          uint64_t v29 = &v27[8 * v49];
        }
      }
      if (v27 == v29) {
        goto LABEL_54;
      }
    }
  }
  if ((v8 & 4) != 0)
  {
    int64_t v9 = a2;
    do
      int64_t v9 = (const llvm::MachineInstr *)(*(void *)v9 & 0xFFFFFFFFFFFFFFF8);
    while ((*((_WORD *)v9 + 22) & 4) != 0);
  }
  uint64_t v10 = *((void *)a2 + 3) + 48;
  uint64_t v11 = (unsigned int *)*((void *)v9 + 4);
  uint64_t v12 = *((unsigned int *)v9 + 10);
  unint64_t v13 = &v11[8 * v12];
  if (!v12)
  {
    uint64_t v25 = *((void *)v9 + 1);
    if (v25 == v10)
    {
      int64_t v9 = (const llvm::MachineInstr *)(*((void *)a2 + 3) + 48);
    }
    else
    {
      int64_t v9 = (const llvm::MachineInstr *)(*((void *)a2 + 3) + 48);
      if ((*(_WORD *)(v25 + 44) & 4) != 0)
      {
        do
        {
          uint64_t v46 = v25;
          uint64_t v47 = *(unsigned int *)(v25 + 40);
          if (v47)
          {
            int64_t v9 = (const llvm::MachineInstr *)v25;
            goto LABEL_78;
          }
          uint64_t v25 = *(void *)(v25 + 8);
        }
        while (v25 != v10 && (*(_WORD *)(v25 + 44) & 4) != 0);
        int64_t v9 = (const llvm::MachineInstr *)(*((void *)a2 + 3) + 48);
LABEL_78:
        uint64_t v11 = *(unsigned int **)(v46 + 32);
        unint64_t v13 = &v11[8 * v47];
      }
    }
  }
  while (v11 != v13)
  {
    unsigned int v14 = *v11;
    if (!*v11)
    {
      unsigned int v15 = v11[1];
      if (v15)
      {
        unsigned int v16 = (v14 >> 8) & 0xFFF;
        if ((v14 & 0x1000000) == 0)
        {
          if ((v14 & 0x30000000) != 0) {
            goto LABEL_11;
          }
          uint64_t v17 = (uint64_t *)v7;
          goto LABEL_10;
        }
        if ((v14 & 0x10000000) != 0) {
          unsigned int v16 = 0;
        }
        if ((~v14 & 0x5000000) != 0)
        {
          uint64_t v17 = (uint64_t *)(v7 + 144);
LABEL_10:
          this = sub_1CC446A00((uint64_t)v52, v15, v16, v17);
          goto LABEL_11;
        }
        if ((a6 & 1) == 0)
        {
          uint64_t v17 = (uint64_t *)(v7 + 288);
          goto LABEL_10;
        }
      }
    }
LABEL_11:
    v11 += 8;
    if (v11 == v13)
    {
      uint64_t v18 = *((void *)v9 + 1);
      if (v18 == v10) {
        break;
      }
      uint64_t v11 = v13;
      int64_t v9 = (const llvm::MachineInstr *)v10;
      if ((*(_WORD *)(v18 + 44) & 4) != 0)
      {
        while (1)
        {
          uint64_t v44 = v18;
          uint64_t v45 = *(unsigned int *)(v18 + 40);
          if (v45) {
            break;
          }
          uint64_t v18 = *(void *)(v18 + 8);
          if (v18 == v10 || (*(_WORD *)(v18 + 44) & 4) == 0)
          {
            int64_t v9 = (const llvm::MachineInstr *)v10;
            goto LABEL_73;
          }
        }
        int64_t v9 = (const llvm::MachineInstr *)v18;
LABEL_73:
        uint64_t v11 = *(unsigned int **)(v44 + 32);
        unint64_t v13 = &v11[8 * v45];
      }
    }
  }
  uint64_t v19 = *(unsigned int *)(v7 + 152);
  if (v19)
  {
    unsigned int v20 = *(uint64_t **)(v7 + 144);
    unsigned int v21 = &v20[2 * v19];
    unint64_t v22 = (void *)(v7 + 288);
    do
    {
      uint64_t v23 = *v20;
      uint64_t v24 = v20[1];
      v20 += 2;
      this = sub_1CC44554C(v22, v23, v24);
    }
    while (v20 != v21);
  }
  return this;
}

uint64_t llvm::RegisterOperands::adjustLaneLiveness(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = result;
  if (*(_DWORD *)(result + 152))
  {
    uint64_t v13 = *(void *)(result + 144);
    do
    {
      uint64_t result = sub_1CC4464AC(a2, a3, 1, *(_DWORD *)v13, a4 & 0xFFFFFFFFFFFFFFF8 | 6, -1, (unsigned int (*)(void))sub_1CC446BC8);
      if (a5)
      {
        unsigned int v14 = *(_DWORD *)v13;
        if ((*(_DWORD *)v13 & 0x80000000) != 0 && (result & ~*(void *)(v13 + 8)) == 0)
        {
          uint64_t v15 = *(unsigned int *)(a5 + 40);
          if (v15)
          {
            unsigned int v16 = *(int **)(a5 + 32);
            uint64_t v17 = 32 * v15;
            do
            {
              int v18 = *v16;
              if ((*v16 & 0x10000FF) == 0x1000000 && (v18 & 0xFFF00) != 0 && v16[1] == v14) {
                int *v16 = v18 | 0x10000000;
              }
              v16 += 8;
              v17 -= 32;
            }
            while (v17);
          }
        }
      }
      if ((*(void *)(v13 + 8) & result) != 0)
      {
        *(void *)(v13 + 8) &= result;
        v13 += 16;
        unsigned int v20 = *(_DWORD *)(v9 + 152);
      }
      else
      {
        uint64_t v21 = *(unsigned int *)(v9 + 152);
        uint64_t v22 = *(void *)(v9 + 144) + 16 * v21;
        if (v22 != v13 + 16)
        {
          uint64_t result = (uint64_t)memmove((void *)v13, (const void *)(v13 + 16), v22 - (v13 + 16));
          LODWORD(v21) = *(_DWORD *)(v9 + 152);
        }
        unsigned int v20 = v21 - 1;
        *(_DWORD *)(v9 + 152) = v20;
      }
    }
    while (v13 != *(void *)(v9 + 144) + 16 * v20);
  }
  if (*(_DWORD *)(v9 + 8))
  {
    uint64_t v10 = *(void *)v9;
    do
    {
      uint64_t result = sub_1CC4464AC(a2, a3, 1, *(_DWORD *)v10, a4 & 0xFFFFFFFFFFFFFFF8, -1, (unsigned int (*)(void))sub_1CC446BC8);
      if ((*(void *)(v10 + 8) & result) != 0)
      {
        *(void *)(v10 + 8) &= result;
        v10 += 16;
        unsigned int v11 = *(_DWORD *)(v9 + 8);
      }
      else
      {
        uint64_t v32 = *(unsigned int *)(v9 + 8);
        uint64_t v33 = *(void *)v9 + 16 * v32;
        if (v33 != v10 + 16)
        {
          uint64_t result = (uint64_t)memmove((void *)v10, (const void *)(v10 + 16), v33 - (v10 + 16));
          LODWORD(v32) = *(_DWORD *)(v9 + 8);
        }
        unsigned int v11 = v32 - 1;
        *(_DWORD *)(v9 + 8) = v11;
      }
    }
    while (v10 != *(void *)v9 + 16 * v11);
  }
  if (a5)
  {
    uint64_t v12 = *(unsigned int *)(v9 + 296);
    if (v12)
    {
      uint64_t v23 = *(unsigned int **)(v9 + 288);
      uint64_t v24 = &v23[4 * v12];
      unint64_t v25 = a4 & 0xFFFFFFFFFFFFFFF8 | 6;
      do
      {
        unsigned int v26 = *v23;
        if ((*v23 & 0x80000000) != 0)
        {
          uint64_t result = sub_1CC4464AC(a2, a3, 1, *v23, v25, -1, (unsigned int (*)(void))sub_1CC446BC8);
          if (!result)
          {
            uint64_t v27 = *(unsigned int *)(a5 + 40);
            if (v27)
            {
              uint64_t v28 = *(int **)(a5 + 32);
              uint64_t v29 = 32 * v27;
              do
              {
                int v30 = *v28;
                if ((*v28 & 0x10000FF) == 0x1000000 && (v30 & 0xFFF00) != 0 && v28[1] == v26) {
                  *uint64_t v28 = v30 | 0x10000000;
                }
                v28 += 8;
                v29 -= 32;
              }
              while (v29);
            }
          }
        }
        v23 += 4;
      }
      while (v23 != v24);
    }
  }
  return result;
}

void llvm::PressureDiffs::init(llvm::PressureDiffs *this, unsigned int a2)
{
  *((_DWORD *)this + 2) = a2;
  if (*((_DWORD *)this + 3) < a2)
  {
    *((_DWORD *)this + 3) = a2;
    free(*(void **)this);
    uint64_t v6 = malloc_type_calloc(a2, 0x40uLL, 0x6D9A4F0CuLL);
    if (!v6) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    *(void *)this = v6;
  }
  else
  {
    unsigned int v4 = *(void **)this;
    size_t v5 = (unint64_t)a2 << 6;
    bzero(v4, v5);
  }
}

void *llvm::PressureDiffs::addInstruction(void *result, unsigned int a2, uint64_t a3, void *a4)
{
  uint64_t v6 = *result + ((unint64_t)a2 << 6);
  uint64_t v7 = *(unsigned int *)(a3 + 152);
  if (v7)
  {
    __int16 v8 = *(unsigned int **)(a3 + 144);
    uint64_t v9 = 16 * v7;
    do
    {
      unsigned int v10 = *v8;
      v8 += 4;
      uint64_t result = (void *)llvm::PressureDiff::addPressureChange(v6, v10, 1, a4);
      v9 -= 16;
    }
    while (v9);
  }
  uint64_t v11 = *(unsigned int *)(a3 + 8);
  if (v11)
  {
    uint64_t v12 = *(unsigned int **)a3;
    uint64_t v13 = 16 * v11;
    do
    {
      unsigned int v14 = *v12;
      v12 += 4;
      uint64_t result = (void *)llvm::PressureDiff::addPressureChange(v6, v14, 0, a4);
      v13 -= 16;
    }
    while (v13);
  }
  return result;
}

uint64_t llvm::PressureDiff::addPressureChange(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(*a4 + 16) + 176))(*(void *)(*a4 + 16));
  uint64_t v9 = v8;
  if ((a2 & 0x80000000) != 0)
  {
    unint64_t v10 = *(void *)(a4[3] + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v11 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v8 + 320))(v8, v10);
    uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v9 + 280))(v9, v10);
  }
  else
  {
    uint64_t v11 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 328))(v8, a2);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 288))(v9, a2);
  }
  unsigned int v13 = *v11;
  if (*v11 != -1)
  {
    if (a3) {
      int v14 = -(int)result;
    }
    else {
      int v14 = result;
    }
    do
    {
      uint64_t v15 = 0;
      while (*(_WORD *)(a1 + v15))
      {
        unsigned int v16 = *(unsigned __int16 *)(a1 + v15) - 1;
        if (v16 >= v13)
        {
          if (v16 == v13) {
            goto LABEL_13;
          }
          break;
        }
        v15 += 4;
        if (v15 == 64) {
          return result;
        }
      }
      unsigned __int16 v20 = v13 + 1;
      if ((_WORD)v13 != 0xFFFF)
      {
        unsigned int v21 = 0;
        uint64_t v22 = v15;
        do
        {
          int v23 = *(_DWORD *)(a1 + v22);
          *(_DWORD *)(a1 + v22) = v21 | v20;
          if (v22 == 60) {
            break;
          }
          unsigned int v21 = v23 & 0xFFFF0000;
          v22 += 4;
          unsigned __int16 v20 = v23;
        }
        while ((_WORD)v23);
      }
LABEL_13:
      uint64_t v17 = a1 + v15;
      int v18 = v14 + *(__int16 *)(a1 + v15 + 2);
      if (v18)
      {
        *(_WORD *)(v17 + 2) = v18;
      }
      else
      {
        if (v15 != 60)
        {
          while (1)
          {
            uint64_t v17 = a1 + v15;
            if (!*(_WORD *)(a1 + v15 + 4)) {
              break;
            }
            *(_DWORD *)uint64_t v17 = *(_DWORD *)(v17 + 4);
            v15 += 4;
            if (v15 == 60)
            {
              uint64_t v17 = a1 + 60;
              break;
            }
          }
        }
        *(_DWORD *)uint64_t v17 = 0;
      }
      unsigned int v19 = v11[1];
      ++v11;
      unsigned int v13 = v19;
    }
    while (v19 != -1);
  }
  return result;
}

uint64_t llvm::RegPressureTracker::addLiveRegs(uint64_t result, unsigned int *a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v4 = a2;
    uint64_t v5 = result;
    uint64_t v6 = &a2[4 * a3];
    do
    {
      unsigned int v7 = *v4;
      if ((*v4 & 0x80000000) != 0) {
        unsigned int v7 = *(_DWORD *)(v5 + 256) + (v7 & 0x7FFFFFFF);
      }
      unint64_t v8 = *((void *)v4 + 1);
      uint64_t v9 = v7;
      unint64_t v3 = v3 & 0xFFFFFFFF00000000 | v7;
      uint64_t v10 = *(void *)(v5 + 240);
      unsigned int v11 = *(unsigned __int8 *)(v10 + v7);
      unsigned int v12 = *(_DWORD *)(v5 + 104);
      if (v12 <= v11) {
        goto LABEL_9;
      }
      uint64_t v13 = *(void *)(v5 + 96);
      while (1)
      {
        unsigned int v14 = v11;
        if (*(_DWORD *)(v13 + 16 * v11) == v9) {
          break;
        }
        v11 += 256;
        if (v14 + 256 >= v12) {
          goto LABEL_9;
        }
      }
      if (v12 == v11)
      {
LABEL_9:
        *(unsigned char *)(v10 + v9) = v12;
        unint64_t v15 = *(unsigned int *)(v5 + 104);
        if (v15 >= *(unsigned int *)(v5 + 108)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v16 = 0;
        uint64_t v17 = (unint64_t *)(*(void *)(v5 + 96) + 16 * v15);
        *uint64_t v17 = v3;
        v17[1] = v8;
        ++*(_DWORD *)(v5 + 104);
      }
      else
      {
        uint64_t v32 = v13 + 16 * v11;
        uint64_t v16 = *(void *)(v32 + 8);
        *(void *)(v32 + 8) = v16 | v8;
      }
      if (v16) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = *((void *)v4 + 1) == 0;
      }
      if (!v18)
      {
        uint64_t v19 = *v4;
        unsigned __int16 v20 = *(void **)(v5 + 24);
        uint64_t v21 = (*(uint64_t (**)(void))(**(void **)(*v20 + 16) + 176))(*(void *)(*v20 + 16));
        uint64_t v22 = v21;
        if ((v19 & 0x80000000) != 0)
        {
          unint64_t v23 = *(void *)(v20[3] + 16 * (v19 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v24 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v21 + 320))(v21, v23);
          uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v22 + 280))(v22, v23);
        }
        else
        {
          uint64_t v24 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 328))(v21, v19);
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v22 + 288))(v22, v19);
        }
        uint64_t v25 = *v24;
        if (v25 != -1)
        {
          uint64_t v26 = *(void *)(v5 + 72);
          uint64_t v27 = **(void **)(v5 + 48);
          uint64_t v28 = v24 + 1;
          do
          {
            *(_DWORD *)(v26 + 4 * v25) += result;
            uint64_t v29 = *(v28 - 1);
            unsigned int v30 = *(_DWORD *)(v27 + 4 * v29);
            if (v30 <= *(_DWORD *)(v26 + 4 * v29)) {
              unsigned int v30 = *(_DWORD *)(v26 + 4 * v29);
            }
            *(_DWORD *)(v27 + 4 * v29) = v30;
            unsigned int v31 = *v28++;
            uint64_t v25 = v31;
          }
          while (v31 != -1);
        }
      }
      v4 += 4;
    }
    while (v4 != v6);
  }
  return result;
}

uint64_t llvm::RegPressureTracker::discoverLiveInOrOut(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = a3;
  uint64_t v6 = *a4;
  uint64_t v7 = *((unsigned int *)a4 + 2);
  if (v7)
  {
    unint64_t v8 = (uint64_t *)(v6 + 8);
    uint64_t v9 = 16 * v7;
    while (*((_DWORD *)v8 - 2) != a2)
    {
      v8 += 2;
      v9 -= 16;
      if (!v9) {
        goto LABEL_5;
      }
    }
    uint64_t v22 = *v8;
    uint64_t v4 = *v8 | a3;
    uint64_t *v8 = v4;
    BOOL v10 = v22 != 0;
  }
  else
  {
LABEL_5:
    if (v7 >= *((_DWORD *)a4 + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    BOOL v10 = 0;
    unsigned int v11 = (void *)(v6 + 16 * v7);
    *unsigned int v11 = a2;
    v11[1] = a3;
    ++*((_DWORD *)a4 + 2);
  }
  if (!v10 && v4)
  {
    unsigned int v12 = *(uint64_t **)(result + 48);
    uint64_t v13 = *(void **)(result + 24);
    uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(*v13 + 16) + 176))(*(void *)(*v13 + 16));
    uint64_t v15 = v14;
    if ((a2 & 0x80000000) != 0)
    {
      unint64_t v16 = *(void *)(v13[3] + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v17 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 320))(v14, v16);
      uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v15 + 280))(v15, v16);
    }
    else
    {
      uint64_t v17 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 328))(v14, a2);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 288))(v15, a2);
    }
    uint64_t v18 = *v17;
    if (v18 != -1)
    {
      uint64_t v19 = *v12;
      unsigned __int16 v20 = v17 + 1;
      do
      {
        *(_DWORD *)(v19 + 4 * v18) += result;
        unsigned int v21 = *v20++;
        uint64_t v18 = v21;
      }
      while (v21 != -1);
    }
  }
  return result;
}

uint64_t llvm::RegPressureTracker::discoverLiveIn(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::RegPressureTracker::discoverLiveInOrOut(a1, a2, a3, (uint64_t *)(*(void *)(a1 + 48) + 24));
}

uint64_t llvm::RegPressureTracker::discoverLiveOut(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return llvm::RegPressureTracker::discoverLiveInOrOut(a1, a2, a3, (uint64_t *)(*(void *)(a1 + 48) + 168));
}

uint64_t llvm::RegPressureTracker::bumpDeadDefs(uint64_t result, unsigned int *a2, uint64_t a3)
{
  if (a3)
  {
    unint64_t v3 = a2;
    uint64_t v4 = result;
    uint64_t v5 = &a2[4 * a3];
    uint64_t v6 = a2;
    do
    {
      uint64_t v7 = *v6;
      unsigned int v8 = v7;
      if ((v7 & 0x80000000) != 0) {
        unsigned int v8 = *(_DWORD *)(v4 + 256) + (v7 & 0x7FFFFFFF);
      }
      unsigned int v9 = *(unsigned __int8 *)(*(void *)(v4 + 240) + v8);
      unsigned int v10 = *(_DWORD *)(v4 + 104);
      if (v10 <= v9) {
        goto LABEL_6;
      }
      uint64_t v12 = *(void *)(v4 + 96);
      do
      {
        unsigned int v13 = v9;
        if (*(_DWORD *)(v12 + 16 * v9) == v8) {
          break;
        }
        uint64_t v11 = 0;
        v9 += 256;
      }
      while (v13 + 256 < v10);
      if (v10 == v9) {
LABEL_6:
      }
        uint64_t v11 = 0;
      else {
        uint64_t v11 = *(void *)(v12 + 16 * v9 + 8);
      }
      if (!v11 && *((void *)v6 + 1))
      {
        uint64_t v14 = *(void **)(v4 + 24);
        uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(*v14 + 16) + 176))(*(void *)(*v14 + 16));
        uint64_t v16 = v7;
        if ((v7 & 0x80000000) != 0)
        {
          unint64_t v17 = *(void *)(v14[3] + 16 * (v7 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v18 = v15;
          uint64_t v46 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v15 + 320))(v15, v17);
          uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v18 + 280))(v18, v17);
        }
        else
        {
          uint64_t v44 = v15;
          uint64_t v45 = v16;
          uint64_t v46 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v15 + 328))(v15, v16);
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v44 + 288))(v44, v45);
        }
        uint64_t v19 = *v46;
        if (v19 != -1)
        {
          uint64_t v20 = *(void *)(v4 + 72);
          uint64_t v21 = **(void **)(v4 + 48);
          uint64_t v22 = v46 + 1;
          do
          {
            *(_DWORD *)(v20 + 4 * v19) += result;
            uint64_t v23 = *(v22 - 1);
            unsigned int v24 = *(_DWORD *)(v21 + 4 * v23);
            if (v24 <= *(_DWORD *)(v20 + 4 * v23)) {
              unsigned int v24 = *(_DWORD *)(v20 + 4 * v23);
            }
            *(_DWORD *)(v21 + 4 * v23) = v24;
            unsigned int v25 = *v22++;
            uint64_t v19 = v25;
          }
          while (v25 != -1);
        }
      }
      v6 += 4;
    }
    while (v6 != v5);
    do
    {
      uint64_t v26 = *v3;
      unsigned int v27 = v26;
      if ((v26 & 0x80000000) != 0) {
        unsigned int v27 = *(_DWORD *)(v4 + 256) + (v26 & 0x7FFFFFFF);
      }
      unsigned int v28 = *(unsigned __int8 *)(*(void *)(v4 + 240) + v27);
      unsigned int v29 = *(_DWORD *)(v4 + 104);
      if (v29 <= v28) {
        goto LABEL_23;
      }
      uint64_t v31 = *(void *)(v4 + 96);
      do
      {
        unsigned int v32 = v28;
        if (*(_DWORD *)(v31 + 16 * v28) == v27) {
          break;
        }
        uint64_t v30 = 0;
        v28 += 256;
      }
      while (v32 + 256 < v29);
      if (v29 == v28) {
LABEL_23:
      }
        uint64_t v30 = 0;
      else {
        uint64_t v30 = *(void *)(v31 + 16 * v28 + 8);
      }
      if (!v30 && *((void *)v3 + 1))
      {
        uint64_t v33 = *(void **)(v4 + 24);
        uint64_t v34 = (*(uint64_t (**)(void))(**(void **)(*v33 + 16) + 176))(*(void *)(*v33 + 16));
        uint64_t v35 = v26;
        if ((v26 & 0x80000000) != 0)
        {
          unint64_t v36 = *(void *)(v33[3] + 16 * (v26 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v37 = v34;
          uint64_t v47 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v34 + 320))(v34, v36);
          uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v37 + 280))(v37, v36);
        }
        else
        {
          uint64_t v42 = v34;
          uint64_t v43 = v35;
          uint64_t v47 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v34 + 328))(v34, v35);
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v42 + 288))(v42, v43);
        }
        uint64_t v38 = *v47;
        if (v38 != -1)
        {
          uint64_t v39 = *(void *)(v4 + 72);
          uint64_t v40 = v47 + 1;
          do
          {
            *(_DWORD *)(v39 + 4 * v38) -= result;
            unsigned int v41 = *v40++;
            uint64_t v38 = v41;
          }
          while (v41 != -1);
        }
      }
      v3 += 4;
    }
    while (v3 != v5);
  }
  return result;
}

uint64_t llvm::RegPressureTracker::recede(uint64_t a1, unsigned int **a2, uint64_t a3)
{
  uint64_t result = llvm::RegPressureTracker::bumpDeadDefs(a1, a2[36], *((unsigned int *)a2 + 74));
  uint64_t v8 = *((unsigned int *)a2 + 38);
  if (v8)
  {
    uint64_t v59 = a2[18];
    uint64_t v60 = &v59[4 * v8];
    do
    {
      uint64_t v61 = *v59;
      if ((v61 & 0x80000000) != 0) {
        unsigned int v62 = *(_DWORD *)(a1 + 256) + (v61 & 0x7FFFFFFF);
      }
      else {
        unsigned int v62 = *v59;
      }
      uint64_t v63 = *((void *)v59 + 1);
      unsigned int v64 = *(unsigned __int8 *)(*(void *)(a1 + 240) + v62);
      unsigned int v65 = *(_DWORD *)(a1 + 104);
      if (v65 <= v64) {
        goto LABEL_77;
      }
      uint64_t v66 = *(void *)(a1 + 96);
      while (1)
      {
        unsigned int v67 = v64;
        if (*(_DWORD *)(v66 + 16 * v64) == v62) {
          break;
        }
        v64 += 256;
        if (v67 + 256 >= v65) {
          goto LABEL_77;
        }
      }
      if (v65 == v64)
      {
LABEL_77:
        unint64_t v69 = 0;
      }
      else
      {
        uint64_t v68 = v66 + 16 * v64;
        unint64_t v69 = *(void *)(v68 + 8);
        *(void *)(v68 + 8) = v69 & ~v63;
        uint64_t v63 = *((void *)v59 + 1);
      }
      unint64_t v3 = v69;
      if ((v63 & ~v69) != 0)
      {
        llvm::RegPressureTracker::discoverLiveInOrOut(a1, v61, v63 & ~v69, (uint64_t *)(*(void *)(a1 + 48) + 168));
        uint64_t v100 = *(void **)(a1 + 24);
        uint64_t v101 = (*(uint64_t (**)(void))(**(void **)(*v100 + 16) + 176))(*(void *)(*v100 + 16));
        uint64_t v102 = v101;
        if ((v61 & 0x80000000) != 0)
        {
          unint64_t v103 = *(void *)(v100[3] + 16 * (v61 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v104 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v101 + 320))(v101, v103);
          unint64_t v105 = v103;
          uint64_t v106 = (unsigned int *)v104;
          uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v102 + 280))(v102, v105);
        }
        else
        {
          uint64_t v106 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v101 + 328))(v101, v61);
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v102 + 288))(v102, v61);
        }
        uint64_t v81 = *v106;
        if (v81 == -1)
        {
          unint64_t v3 = 1;
        }
        else
        {
          uint64_t v107 = *(void *)(a1 + 72);
          uint64_t v82 = v106 + 1;
          do
          {
            *(_DWORD *)(v107 + 4 * v81) += result;
            unsigned int v83 = *v82++;
            uint64_t v81 = v83;
            unint64_t v3 = 1;
          }
          while (v83 != -1);
        }
      }
      if ((v69 & ~v63) == 0)
      {
        if (a3 && *(unsigned char *)(a1 + 58))
        {
          int v70 = *(_DWORD **)a3;
          uint64_t v71 = *(unsigned int *)(a3 + 8);
          if (v71)
          {
            unsigned int v108 = v70 + 2;
            uint64_t v109 = 16 * v71;
            while (v61 != *((_DWORD *)v108 - 2))
            {
              v108 += 2;
              v109 -= 16;
              if (!v109) {
                goto LABEL_64;
              }
            }
            *unsigned int v108 = 0;
          }
          else
          {
LABEL_64:
            if (v71 >= *(_DWORD *)(a3 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v72 = (uint64_t *)&v70[4 * v71];
            *int v72 = v61;
            v72[1] = 0;
            ++*(_DWORD *)(a3 + 8);
          }
        }
        if (v3)
        {
          int v73 = *(void **)(a1 + 24);
          uint64_t v74 = (*(uint64_t (**)(void))(**(void **)(*v73 + 16) + 176))(*(void *)(*v73 + 16));
          unint64_t v3 = v74;
          if ((v61 & 0x80000000) != 0)
          {
            unint64_t v75 = *(void *)(v73[3] + 16 * (v61 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
            uint64_t v76 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v74 + 320))(v74, v75);
            uint64_t result = *(unsigned int *)(*(uint64_t (**)(unint64_t, unint64_t))(*(void *)v3 + 280))(v3, v75);
          }
          else
          {
            uint64_t v76 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v74 + 328))(v74, v61);
            uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v3 + 288))(v3, v61);
          }
          uint64_t v77 = *v76;
          if (v77 != -1)
          {
            uint64_t v78 = *(void *)(a1 + 72);
            uint64_t v79 = v76 + 1;
            do
            {
              *(_DWORD *)(v78 + 4 * v77) -= result;
              unsigned int v80 = *v79++;
              uint64_t v77 = v80;
            }
            while (v80 != -1);
          }
        }
      }
      v59 += 4;
    }
    while (v59 != v60);
  }
  if (*(unsigned char *)(a1 + 56))
  {
    unint64_t v9 = *(void *)(a1 + 64);
    uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 288);
    __int16 v11 = *(_WORD *)(v9 + 44);
    unint64_t v12 = v9;
    if ((v11 & 0xC) != 0)
    {
      if ((v11 & 4) != 0)
      {
        unint64_t v12 = *(void *)(a1 + 64);
        do
          unint64_t v12 = *(void *)v12 & 0xFFFFFFFFFFFFFFF8;
        while ((*(_WORD *)(v12 + 44) & 4) != 0);
      }
      if ((v11 & 8) != 0)
      {
        do
          unint64_t v9 = *(void *)(v9 + 8);
        while ((*(_WORD *)(v9 + 44) & 8) != 0);
      }
    }
    unint64_t v13 = *(void *)(v9 + 8);
    if (v12 != v13)
    {
      while (1)
      {
        unsigned int v14 = **(unsigned __int16 **)(v12 + 16);
        BOOL v15 = v14 > 0x17;
        int v16 = (1 << v14) & 0x83E000;
        if (v15 || v16 == 0) {
          break;
        }
        unint64_t v12 = *(void *)(v12 + 8);
        if (v12 == v13)
        {
          unint64_t v12 = v13;
          break;
        }
      }
    }
    uint64_t v18 = *(void *)(v10 + 368);
    uint64_t v19 = *(unsigned int *)(v10 + 384);
    if (v19)
    {
      LODWORD(v20) = ((v12 >> 4) ^ (v12 >> 9)) & (v19 - 1);
      uint64_t v21 = (uint64_t *)(v18 + 16 * v20);
      uint64_t v22 = *v21;
      if (v12 == *v21)
      {
LABEL_12:
        unint64_t v23 = v21[1] & 0xFFFFFFFFFFFFFFF8 | 4;
        goto LABEL_13;
      }
      int v84 = 1;
      while (v22 != -4096)
      {
        int v85 = v20 + v84++;
        uint64_t v20 = v85 & (v19 - 1);
        uint64_t v22 = *(void *)(v18 + 16 * v20);
        if (v12 == v22)
        {
          uint64_t v21 = (uint64_t *)(v18 + 16 * v20);
          goto LABEL_12;
        }
      }
    }
    uint64_t v21 = (uint64_t *)(v18 + 16 * v19);
    goto LABEL_12;
  }
  unint64_t v23 = 0;
LABEL_13:
  uint64_t v24 = *((unsigned int *)a2 + 2);
  if (v24)
  {
    unsigned int v25 = *a2;
    uint64_t v26 = (uint64_t)&(*a2)[4 * v24];
    do
    {
      uint64_t v27 = *v25;
      if ((v27 & 0x80000000) != 0) {
        unsigned int v28 = *(_DWORD *)(a1 + 256) + (v27 & 0x7FFFFFFF);
      }
      else {
        unsigned int v28 = *v25;
      }
      unint64_t v29 = *((void *)v25 + 1);
      uint64_t v30 = v28;
      unint64_t v3 = v3 & 0xFFFFFFFF00000000 | v28;
      uint64_t v31 = *(void *)(a1 + 240);
      unsigned int v32 = *(unsigned __int8 *)(v31 + v28);
      unsigned int v33 = *(_DWORD *)(a1 + 104);
      if (v33 <= v32) {
        goto LABEL_21;
      }
      uint64_t v34 = *(void *)(a1 + 96);
      while (1)
      {
        unsigned int v35 = v32;
        if (*(_DWORD *)(v34 + 16 * v32) == v30) {
          break;
        }
        v32 += 256;
        if (v35 + 256 >= v33) {
          goto LABEL_21;
        }
      }
      if (v33 == v32)
      {
LABEL_21:
        *(unsigned char *)(v31 + v30) = v33;
        unint64_t v36 = *(unsigned int *)(a1 + 104);
        if (v36 >= *(unsigned int *)(a1 + 108)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v37 = (unint64_t *)(*(void *)(a1 + 96) + 16 * v36);
        *uint64_t v37 = v3;
        v37[1] = v29;
        ++*(_DWORD *)(a1 + 104);
        uint64_t v38 = *((void *)v25 + 1);
        if (v38)
        {
LABEL_23:
          if (a3)
          {
            if (*(unsigned char *)(a1 + 58) && (uint64_t v55 = *(unsigned int *)(a3 + 8), v55))
            {
              unint64_t v56 = *(_DWORD **)a3;
              uint64_t v57 = 16 * v55;
              while (v27 != *v56)
              {
                v56 += 4;
                v57 -= 16;
                if (!v57) {
                  goto LABEL_47;
                }
              }
              sub_1CC44554C((void *)a3, v27, v38);
            }
            else
            {
LABEL_47:
              sub_1CC4454A0((uint64_t *)a3, v27, v38);
            }
          }
          if (*(unsigned char *)(a1 + 56))
          {
            uint64_t v39 = sub_1CC4464AC(*(void *)(a1 + 32), *(void *)(a1 + 24), *(unsigned char *)(a1 + 58), v27, v23, 0, (unsigned int (*)(void))sub_1CC446F40);
            if (v39) {
              llvm::RegPressureTracker::discoverLiveInOrOut(a1, v27, v39, (uint64_t *)(*(void *)(a1 + 48) + 168));
            }
          }
          uint64_t v40 = *(void **)(a1 + 24);
          uint64_t v41 = (*(uint64_t (**)(void))(**(void **)(*v40 + 16) + 176))(*(void *)(*v40 + 16));
          uint64_t v42 = v41;
          if ((v27 & 0x80000000) != 0)
          {
            unint64_t v43 = *(void *)(v40[3] + 16 * (v27 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
            uint64_t v44 = (unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v41 + 320))(v41, v43);
            uint64_t result = *(unsigned int *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v42 + 280))(v42, v43);
          }
          else
          {
            uint64_t v44 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v41 + 328))(v41, v27);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v42 + 288))(v42, v27);
          }
          uint64_t v45 = *v44;
          if (v45 != -1)
          {
            uint64_t v46 = *(void *)(a1 + 72);
            uint64_t v47 = **(void **)(a1 + 48);
            uint64_t v48 = v44 + 1;
            do
            {
              *(_DWORD *)(v46 + 4 * v45) += result;
              uint64_t v49 = *(v48 - 1);
              unsigned int v50 = *(_DWORD *)(v47 + 4 * v49);
              if (v50 <= *(_DWORD *)(v46 + 4 * v49)) {
                unsigned int v50 = *(_DWORD *)(v46 + 4 * v49);
              }
              *(_DWORD *)(v47 + 4 * v49) = v50;
              unsigned int v51 = *v48++;
              uint64_t v45 = v51;
            }
            while (v51 != -1);
          }
        }
      }
      else
      {
        uint64_t v52 = v34 + 16 * v32;
        uint64_t v53 = *(void *)(v52 + 8);
        *(void *)(v52 + 8) = v53 | v29;
        uint64_t v38 = *((void *)v25 + 1) | v53;
        if (v53) {
          BOOL v54 = 1;
        }
        else {
          BOOL v54 = v38 == 0;
        }
        if (!v54) {
          goto LABEL_23;
        }
      }
      v25 += 4;
    }
    while (v25 != (unsigned int *)v26);
  }
  if (*(unsigned char *)(a1 + 57))
  {
    uint64_t v58 = *((unsigned int *)a2 + 38);
    if (v58)
    {
      unsigned int v86 = a2[18];
      v87 = &v86[4 * v58];
      do
      {
        unsigned int v88 = *v86;
        if ((*v86 & 0x80000000) != 0)
        {
          uint64_t v89 = v88 & 0x7FFFFFFF;
          unsigned int v90 = *(_DWORD *)(a1 + 256) + (v88 & 0x7FFFFFFF);
          unsigned int v91 = *(unsigned __int8 *)(*(void *)(a1 + 240) + v90);
          unsigned int v92 = *(_DWORD *)(a1 + 104);
          if (v92 <= v91) {
            goto LABEL_88;
          }
          uint64_t v93 = *(void *)(a1 + 96);
          while (1)
          {
            unsigned int v94 = v91;
            if (*(_DWORD *)(v93 + 16 * v91) == v90) {
              break;
            }
            v91 += 256;
            if (v94 + 256 >= v92) {
              goto LABEL_88;
            }
          }
          if (v92 == v91) {
LABEL_88:
          }
            uint64_t v95 = 0;
          else {
            uint64_t v95 = *(void *)(v93 + 16 * v91 + 8);
          }
          if ((*((void *)v86 + 1) & v95) == 0)
          {
            uint64_t v96 = *(void *)(a1 + 312);
            unsigned int v97 = *(unsigned __int8 *)(v96 + v89);
            unsigned int v98 = *(_DWORD *)(a1 + 272);
            if (v98 <= v97) {
              goto LABEL_95;
            }
            while ((*(_DWORD *)(*(void *)(a1 + 264) + 4 * v97) & 0x7FFFFFFF) != v89)
            {
              v97 += 256;
              if (v97 >= v98) {
                goto LABEL_95;
              }
            }
            if (v98 == v97)
            {
LABEL_95:
              *(unsigned char *)(v96 + v89) = v98;
              unint64_t v99 = *(unsigned int *)(a1 + 272);
              if (v99 >= *(unsigned int *)(a1 + 276)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(_DWORD *)(*(void *)(a1 + 264) + 4 * v99) = v88;
              ++*(_DWORD *)(a1 + 272);
            }
          }
        }
        v86 += 4;
      }
      while (v86 != v87);
    }
  }
  return result;
}

uint64_t *sub_1CC445438(uint64_t *result, unsigned int a2, uint64_t a3)
{
  if ((a2 & 0x80000000) != 0) {
    a2 = *((_DWORD *)result + 40) + (a2 & 0x7FFFFFFF);
  }
  unsigned int v3 = *(unsigned __int8 *)(result[18] + a2);
  unsigned int v4 = *((_DWORD *)result + 2);
  if (v4 > v3)
  {
    uint64_t v5 = *result;
    while (1)
    {
      unsigned int v6 = v3;
      if (*(_DWORD *)(v5 + 16 * v3) == a2) {
        break;
      }
      v3 += 256;
      if (v6 + 256 >= v4) {
        return result;
      }
    }
    if (v4 != v3) {
      *(void *)(v5 + 16 * v3 + 8) &= ~a3;
    }
  }
  return result;
}

uint64_t *sub_1CC4454A0(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *result;
  uint64_t v4 = *((unsigned int *)result + 2);
  if (v4)
  {
    uint64_t v5 = (void *)(v3 + 8);
    uint64_t v6 = 16 * v4;
    while (a2 != *((_DWORD *)v5 - 2))
    {
      v5 += 2;
      v6 -= 16;
      if (!v6) {
        goto LABEL_5;
      }
    }
    *v5 |= a3;
  }
  else
  {
LABEL_5:
    if (v4 >= *((_DWORD *)result + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = (void *)(v3 + 16 * v4);
    *uint64_t v7 = a2;
    v7[1] = a3;
    ++*((_DWORD *)result + 2);
  }
  return result;
}

void *sub_1CC44554C(void *result, int a2, uint64_t a3)
{
  uint64_t v3 = *((unsigned int *)result + 2);
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    uint64_t v6 = *result;
    uint64_t v7 = 16 * v3;
    while (a2 != *(_DWORD *)(v6 + v5))
    {
      v5 += 16;
      if (v7 == v5) {
        return result;
      }
    }
    uint64_t result = (void *)(v6 + v5);
    uint64_t v8 = *(void *)(v6 + v5 + 8) & ~a3;
    result[1] = v8;
    if (!v8)
    {
      if (v7 - 16 != v5)
      {
        uint64_t result = memmove(result, result + 2, v7 - v5 - 16);
        LODWORD(v3) = *((_DWORD *)v4 + 2);
      }
      *((_DWORD *)v4 + 2) = v3 - 1;
    }
  }
  return result;
}

uint64_t llvm::RegPressureTracker::getLiveThroughAt(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_1CC4464AC(*(void *)(a1 + 32), *(void *)(a1 + 24), *(unsigned char *)(a1 + 58), a2, a3, 0, (unsigned int (*)(void))sub_1CC446F40);
}

unint64_t llvm::RegPressureTracker::recedeSkipDebugValues(unint64_t this)
{
  unint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 48);
  if (*(unsigned char *)(this + 56))
  {
    if (*(void *)(v2 + 320) > 7uLL) {
      goto LABEL_3;
    }
    this = llvm::RegPressureTracker::getCurrSlot((llvm::RegPressureTracker *)this);
    *(void *)(v2 + 320) = this;
LABEL_41:
    unsigned int v26 = *(_DWORD *)(v1 + 104);
    if (*(_DWORD *)(v2 + 180) < v26) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v26)
    {
      uint64_t v27 = 16 * v26;
      unsigned int v28 = (void *)(*(void *)(v1 + 96) + 8);
      do
      {
        uint64_t v29 = *v28;
        if (*v28)
        {
          unsigned int v30 = *(_DWORD *)(v1 + 256);
          unsigned int v31 = *((_DWORD *)v28 - 2);
          BOOL v32 = v31 >= v30;
          LODWORD(v33) = (v31 - v30) | 0x80000000;
          if (v32) {
            uint64_t v33 = v33;
          }
          else {
            uint64_t v33 = v31;
          }
          unint64_t v34 = *(unsigned int *)(v2 + 176);
          if (v34 >= *(unsigned int *)(v2 + 180)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unsigned int v35 = (void *)(*(void *)(v2 + 168) + 16 * v34);
          *unsigned int v35 = v33;
          v35[1] = v29;
          ++*(_DWORD *)(v2 + 176);
        }
        v28 += 2;
        v27 -= 16;
      }
      while (v27);
    }
    goto LABEL_3;
  }
  if (*(void *)(v2 + 320))
  {
    *(void *)(v2 + 320) = *(void *)(this + 64);
    uint64_t v2 = *(void *)(this + 48);
    goto LABEL_41;
  }
LABEL_3:
  if (!*(unsigned char *)(v1 + 56))
  {
    uint64_t v36 = *(void *)(v1 + 48);
    if (!*(void *)(v36 + 312) && !*(void *)(v1 + 64))
    {
      *(void *)(v36 + 312) = 0;
      *(_DWORD *)(v36 + 32) = 0;
    }
  }
  unint64_t v3 = *(void *)(*(void *)(v1 + 40) + 56);
  unint64_t v4 = **(void **)(v1 + 64) & 0xFFFFFFFFFFFFFFF8;
  if (!v4 || (*(unsigned char *)v4 & 4) == 0)
  {
    while ((*(_WORD *)(v4 + 44) & 4) != 0)
      unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
  }
  while (v4 != v3)
  {
    int v5 = **(unsigned __int16 **)(v4 + 16);
    if ((v5 - 13) >= 5 && v5 != 23)
    {
      unint64_t v3 = v4;
      break;
    }
    unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
    if (!v4 || (*(unsigned char *)v4 & 4) == 0)
    {
      while ((*(_WORD *)(v4 + 44) & 4) != 0)
        unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
    }
  }
  *(void *)(v1 + 64) = v3;
  if (*(unsigned char *)(v1 + 56))
  {
    unsigned int v7 = **(unsigned __int16 **)(v3 + 16) - 13;
    if (v7 < 0xB && ((0x41Fu >> v7) & 1) != 0)
    {
      unint64_t v21 = 0;
LABEL_32:
      uint64_t v22 = *(void *)(v1 + 48);
      unint64_t v23 = *(void *)(v22 + 312);
      if (v23 >= 8
        && (*(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFF8) + 24) | (v23 >> 1) & 3) > (*(_DWORD *)((v21 & 0xFFFFFFFFFFFFFFF8) + 24) | (v21 >> 1) & 3))
      {
        *(void *)(v22 + 312) = 0;
        *(_DWORD *)(v22 + 32) = 0;
      }
      return this;
    }
    uint64_t v8 = *(void *)(*(void *)(v1 + 32) + 288);
    __int16 v9 = *(_WORD *)(v3 + 44);
    unint64_t v10 = v3;
    if ((v9 & 0xC) != 0)
    {
      if ((v9 & 4) != 0)
      {
        unint64_t v10 = v3;
        do
          unint64_t v10 = *(void *)v10 & 0xFFFFFFFFFFFFFFF8;
        while ((*(_WORD *)(v10 + 44) & 4) != 0);
      }
      if ((v9 & 8) != 0)
      {
        do
          unint64_t v3 = *(void *)(v3 + 8);
        while ((*(_WORD *)(v3 + 44) & 8) != 0);
      }
    }
    unint64_t v11 = *(void *)(v3 + 8);
    if (v10 != v11)
    {
      while (1)
      {
        unsigned int v12 = **(unsigned __int16 **)(v10 + 16);
        BOOL v13 = v12 > 0x17;
        int v14 = (1 << v12) & 0x83E000;
        if (v13 || v14 == 0) {
          break;
        }
        unint64_t v10 = *(void *)(v10 + 8);
        if (v10 == v11)
        {
          unint64_t v10 = v11;
          break;
        }
      }
    }
    uint64_t v16 = *(void *)(v8 + 368);
    uint64_t v17 = *(unsigned int *)(v8 + 384);
    if (v17)
    {
      LODWORD(v18) = ((v10 >> 4) ^ (v10 >> 9)) & (v17 - 1);
      uint64_t v19 = (uint64_t *)(v16 + 16 * v18);
      uint64_t v20 = *v19;
      if (v10 == *v19)
      {
LABEL_31:
        unint64_t v21 = v19[1] & 0xFFFFFFFFFFFFFFF8 | 4;
        goto LABEL_32;
      }
      int v24 = 1;
      while (v20 != -4096)
      {
        int v25 = v18 + v24++;
        uint64_t v18 = v25 & (v17 - 1);
        uint64_t v20 = *(void *)(v16 + 16 * v18);
        if (v10 == v20)
        {
          uint64_t v19 = (uint64_t *)(v16 + 16 * v18);
          goto LABEL_31;
        }
      }
    }
    uint64_t v19 = (uint64_t *)(v16 + 16 * v17);
    goto LABEL_31;
  }
  return this;
}

void llvm::RegPressureTracker::recede(unint64_t a1, uint64_t a2)
{
  v45[16] = *MEMORY[0x1E4F143B8];
  llvm::RegPressureTracker::recedeSkipDebugValues(a1);
  unint64_t v4 = *(unsigned __int16 ***)(a1 + 64);
  unsigned int v5 = *v4[2];
  BOOL v6 = v5 > 0x17;
  int v7 = (1 << v5) & 0x83E000;
  if (!v6 && v7 != 0) {
    return;
  }
  uint64_t v37 = v39;
  uint64_t v38 = 0x800000000;
  uint64_t v40 = v42;
  uint64_t v41 = 0x800000000;
  unint64_t v43 = v45;
  uint64_t v44 = 0x800000000;
  llvm::RegisterOperands::collect(&v37, (const llvm::MachineInstr *)v4, *(const llvm::TargetRegisterInfo **)(a1 + 8), *(const llvm::MachineRegisterInfo **)(a1 + 24), *(unsigned __int8 *)(a1 + 58), 0);
  if (!*(unsigned char *)(a1 + 58))
  {
    if (*(unsigned char *)(a1 + 56)) {
      llvm::RegisterOperands::detectDeadDefs((llvm::RegisterOperands *)&v37, (const llvm::MachineInstr *)v4, *(const llvm::LiveIntervals **)(a1 + 32));
    }
    goto LABEL_22;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = *(void *)(a1 + 64);
  uint64_t v11 = *(void *)(v9 + 288);
  __int16 v12 = *(_WORD *)(v10 + 44);
  unint64_t v13 = v10;
  if ((v12 & 0xC) != 0)
  {
    if ((v12 & 4) != 0)
    {
      unint64_t v13 = *(void *)(a1 + 64);
      do
        unint64_t v13 = *(void *)v13 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v13 + 44) & 4) != 0);
    }
    if ((v12 & 8) != 0)
    {
      do
        unint64_t v10 = *(void *)(v10 + 8);
      while ((*(_WORD *)(v10 + 44) & 8) != 0);
    }
  }
  unint64_t v14 = *(void *)(v10 + 8);
  if (v13 != v14)
  {
    while (1)
    {
      unsigned int v15 = **(unsigned __int16 **)(v13 + 16);
      BOOL v6 = v15 > 0x17;
      int v16 = (1 << v15) & 0x83E000;
      if (v6 || v16 == 0) {
        break;
      }
      unint64_t v13 = *(void *)(v13 + 8);
      if (v13 == v14)
      {
        unint64_t v13 = v14;
        break;
      }
    }
  }
  uint64_t v18 = *(void *)(v11 + 368);
  uint64_t v19 = *(unsigned int *)(v11 + 384);
  if (!v19) {
    goto LABEL_38;
  }
  LODWORD(v20) = ((v13 >> 4) ^ (v13 >> 9)) & (v19 - 1);
  unint64_t v21 = (uint64_t *)(v18 + 16 * v20);
  uint64_t v22 = *v21;
  if (v13 != *v21)
  {
    int v31 = 1;
    while (v22 != -4096)
    {
      int v32 = v20 + v31++;
      uint64_t v20 = v32 & (v19 - 1);
      uint64_t v22 = *(void *)(v18 + 16 * v20);
      if (v13 == v22)
      {
        unint64_t v21 = (uint64_t *)(v18 + 16 * v20);
        goto LABEL_16;
      }
    }
LABEL_38:
    unint64_t v21 = (uint64_t *)(v18 + 16 * v19);
  }
LABEL_16:
  unint64_t v23 = v21[1] & 0xFFFFFFFFFFFFFFF8;
  uint64_t v24 = *(void *)(a1 + 24);
  if (v41)
  {
    unsigned int v28 = (unsigned int *)v40;
    do
    {
      uint64_t v29 = sub_1CC4464AC(v9, v24, 1, *v28, v23 | 6, -1, (unsigned int (*)(void))sub_1CC446BC8);
      if ((*((void *)v28 + 1) & v29) != 0)
      {
        *((void *)v28 + 1) &= v29;
        v28 += 4;
        unsigned int v30 = v41;
      }
      else
      {
        int v33 = v41;
        unint64_t v34 = (unsigned int *)((char *)v40 + 16 * v41);
        if (v34 != v28 + 4)
        {
          memmove(v28, v28 + 4, (char *)v34 - (char *)(v28 + 4));
          int v33 = v41;
        }
        unsigned int v30 = v33 - 1;
        LODWORD(v41) = v30;
      }
    }
    while (v28 != (unsigned int *)((char *)v40 + 16 * v30));
  }
  if (v38)
  {
    int v25 = (unsigned int *)v37;
    do
    {
      uint64_t v26 = sub_1CC4464AC(v9, v24, 1, *v25, v23, -1, (unsigned int (*)(void))sub_1CC446BC8);
      if ((*((void *)v25 + 1) & v26) != 0)
      {
        *((void *)v25 + 1) &= v26;
        v25 += 4;
        unsigned int v27 = v38;
      }
      else
      {
        int v35 = v38;
        uint64_t v36 = (unsigned int *)((char *)v37 + 16 * v38);
        if (v36 != v25 + 4)
        {
          memmove(v25, v25 + 4, (char *)v36 - (char *)(v25 + 4));
          int v35 = v38;
        }
        unsigned int v27 = v35 - 1;
        LODWORD(v38) = v27;
      }
    }
    while (v25 != (unsigned int *)((char *)v37 + 16 * v27));
  }
LABEL_22:
  llvm::RegPressureTracker::recede(a1, (unsigned int **)&v37, a2);
  if (v43 != v45) {
    free(v43);
  }
  if (v40 != v42) {
    free(v40);
  }
  if (v37 != v39) {
    free(v37);
  }
}

uint64_t llvm::RegPressureTracker::getLastUsedLanes(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_1CC4464AC(*(void *)(a1 + 32), *(void *)(a1 + 24), *(unsigned char *)(a1 + 58), a2, a3 & 0xFFFFFFFFFFFFFFF8, 0, (unsigned int (*)(void))sub_1CC446E54);
}

void llvm::RegPressureTracker::advance(llvm::RegPressureTracker *this)
{
  v25[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (const llvm::MachineInstr *)*((void *)this + 8);
  uint64_t v17 = v19;
  uint64_t v18 = 0x800000000;
  uint64_t v20 = v22;
  uint64_t v21 = 0x800000000;
  unint64_t v23 = v25;
  uint64_t v24 = 0x800000000;
  llvm::RegisterOperands::collect(&v17, v2, *((const llvm::TargetRegisterInfo **)this + 1), *((const llvm::MachineRegisterInfo **)this + 3), *((unsigned __int8 *)this + 58), 0);
  if (*((unsigned char *)this + 58))
  {
    unint64_t CurrSlot = llvm::RegPressureTracker::getCurrSlot(this);
    uint64_t v5 = *((void *)this + 3);
    uint64_t v4 = *((void *)this + 4);
    if (v21)
    {
      __int16 v12 = (unsigned int *)v20;
      do
      {
        uint64_t v13 = sub_1CC4464AC(v4, v5, 1, *v12, CurrSlot & 0xFFFFFFFFFFFFFFF8 | 6, -1, (unsigned int (*)(void))sub_1CC446BC8);
        if ((*((void *)v12 + 1) & v13) != 0)
        {
          *((void *)v12 + 1) &= v13;
          v12 += 4;
          unsigned int v14 = v21;
        }
        else
        {
          int v15 = v21;
          int v16 = (unsigned int *)((char *)v20 + 16 * v21);
          if (v16 != v12 + 4)
          {
            memmove(v12, v12 + 4, (char *)v16 - (char *)(v12 + 4));
            int v15 = v21;
          }
          unsigned int v14 = v15 - 1;
          LODWORD(v21) = v14;
        }
      }
      while (v12 != (unsigned int *)((char *)v20 + 16 * v14));
    }
    if (v18)
    {
      BOOL v6 = (unsigned int *)v17;
      unint64_t v7 = CurrSlot & 0xFFFFFFFFFFFFFFF8;
      do
      {
        uint64_t v8 = sub_1CC4464AC(v4, v5, 1, *v6, v7, -1, (unsigned int (*)(void))sub_1CC446BC8);
        if ((*((void *)v6 + 1) & v8) != 0)
        {
          *((void *)v6 + 1) &= v8;
          v6 += 4;
          unsigned int v9 = v18;
        }
        else
        {
          int v10 = v18;
          uint64_t v11 = (unsigned int *)((char *)v17 + 16 * v18);
          if (v11 != v6 + 4)
          {
            memmove(v6, v6 + 4, (char *)v11 - (char *)(v6 + 4));
            int v10 = v18;
          }
          unsigned int v9 = v10 - 1;
          LODWORD(v18) = v9;
        }
      }
      while (v6 != (unsigned int *)((char *)v17 + 16 * v9));
    }
  }
  llvm::RegPressureTracker::advance(this, (unsigned int **)&v17);
  if (v23 != v25) {
    free(v23);
  }
  if (v20 != v22) {
    free(v20);
  }
  if (v17 != v19) {
    free(v17);
  }
}

double llvm::RegPressureTracker::getMaxUpwardPressureDelta(uint64_t a1, const llvm::MachineInstr *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v28 = 0;
  sub_1CBA85A80(__p, *(const void **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2);
  uint64_t v15 = *(void *)(a1 + 48);
  int v25 = 0;
  uint64_t v26 = 0;
  uint64_t v24 = 0;
  sub_1CBA85A80(&v24, *(const void **)v15, *(void *)(v15 + 8), (uint64_t)(*(void *)(v15 + 8) - *(void *)v15) >> 2);
  llvm::RegPressureTracker::bumpUpwardPressure((llvm::RegPressureTracker *)a1, a2);
  sub_1CC4460EC((uint64_t)__p[0], ((char *)__p[1] - (char *)__p[0]) >> 2, *(void *)(a1 + 72), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2, a4, *(llvm::RegisterClassInfo **)(a1 + 16), *(void *)(a1 + 328), (uint64_t)(*(void *)(a1 + 336) - *(void *)(a1 + 328)) >> 2);
  uint64_t v16 = (uint64_t)v24;
  sub_1CC4461D4((uint64_t)v24, (v25 - v24) >> 2, **(void **)(a1 + 48), (uint64_t)(*(void *)(*(void *)(a1 + 48) + 8) - **(void **)(a1 + 48)) >> 2, a5, a6, a7, a8, a4);
  uint64_t v17 = *(void *)(a1 + 48);
  uint64_t v18 = *(unsigned char **)v17;
  *(void *)uint64_t v17 = v16;
  *(void *)(v17 + 8) = v25;
  uint64_t v19 = *(void *)(v17 + 16);
  *(void *)(v17 + 16) = v26;
  uint64_t v24 = v18;
  uint64_t v26 = v19;
  long long v20 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)__p;
  *(_OWORD *)__p = v20;
  uint64_t v21 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v28;
  uint64_t v28 = v21;
  if (v18)
  {
    int v25 = v18;
    operator delete(v18);
    uint64_t v22 = __p[0];
    if (__p[0])
    {
LABEL_3:
      __p[1] = v22;
      operator delete(v22);
    }
  }
  else
  {
    uint64_t v22 = (void *)v20;
    if ((void)v20) {
      goto LABEL_3;
    }
  }
  return *(double *)&v20;
}

uint64_t sub_1CC4460EC(uint64_t result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, llvm::RegisterClassInfo *this, uint64_t a7, uint64_t a8)
{
  *(_DWORD *)a5 = 0;
  uint64_t v8 = a2;
  if (a2)
  {
    uint64_t v14 = result;
    uint64_t v15 = 0;
    while (1)
    {
      unsigned int v16 = *(_DWORD *)(v14 + 4 * v15);
      unsigned int v17 = *(_DWORD *)(a3 + 4 * v15);
      if (v17 == v16) {
        goto LABEL_15;
      }
      uint64_t result = *(unsigned int *)(*((void *)this + 27) + 4 * v15);
      if (result) {
        break;
      }
      uint64_t result = llvm::RegisterClassInfo::computePSetLimit(this, v15);
      *(_DWORD *)(*((void *)this + 27) + 4 * v15) = result;
      if (a8) {
        goto LABEL_6;
      }
LABEL_7:
      if (result <= v17) {
        unsigned int v18 = v17;
      }
      else {
        unsigned int v18 = result;
      }
      unsigned int v19 = v18 - v16;
      unsigned int v20 = v17 - result;
      if (v17 < result) {
        unsigned int v20 = 0;
      }
      if (result > v16) {
        unsigned int v19 = v20;
      }
      if (v19)
      {
        *(_DWORD *)a5 = (unsigned __int16)(v15 + 1);
        *(_WORD *)(a5 + 2) = v19;
        return result;
      }
LABEL_15:
      if (v8 == ++v15) {
        return result;
      }
    }
    if (!a8) {
      goto LABEL_7;
    }
LABEL_6:
    uint64_t result = (*(_DWORD *)(a7 + 4 * v15) + result);
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_1CC4461D4(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *(_DWORD *)(a9 + 4) = 0;
  *(_DWORD *)(a9 + 8) = 0;
  if (a2)
  {
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    unint64_t v12 = 0;
    unsigned int v13 = 0;
    do
    {
      unsigned int v14 = *(_DWORD *)(a3 + 4 * v12);
      unsigned int v15 = v14 - *(_DWORD *)(result + 4 * v12);
      if (v15)
      {
        if (v11 || v13 == a6)
        {
LABEL_13:
          if (v10) {
            goto LABEL_20;
          }
        }
        else
        {
          while (1)
          {
            unint64_t v16 = *(unsigned __int16 *)(a5 + 4 * v13) - 1;
            if (v16 >= v12) {
              break;
            }
            if (a6 == ++v13)
            {
              int v11 = 0;
              unsigned int v13 = a6;
              if (v10) {
                goto LABEL_20;
              }
              goto LABEL_14;
            }
          }
          if (v16 == v12)
          {
            int v17 = v14 - *(__int16 *)(a5 + 4 * v13 + 2);
            if (v17 >= 1)
            {
              int v9 = (unsigned __int16)(v12 + 1);
              *(_DWORD *)(a9 + 4) = v9;
              *(_WORD *)(a9 + 6) = v17;
              int v11 = v9;
              goto LABEL_13;
            }
          }
          int v11 = 0;
          if (v10) {
            goto LABEL_20;
          }
        }
LABEL_14:
        if (v14 <= *(_DWORD *)(a7 + 4 * v12))
        {
          int v10 = 0;
        }
        else
        {
          int v10 = (unsigned __int16)(v12 + 1);
          *(_DWORD *)(a9 + 8) = v10;
          *(_WORD *)(a9 + 10) = v15;
          if (v13 == a6 || v9) {
            return result;
          }
          int v11 = 0;
        }
      }
LABEL_20:
      ++v12;
    }
    while (v12 != a2);
  }
  return result;
}

uint64_t llvm::RegPressureTracker::getUpwardPressureDelta(uint64_t result, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = 0;
  uint64_t v8 = a3 + 32;
  do
  {
    int v9 = *a3;
    if (!*a3) {
      break;
    }
    uint64_t v10 = (v9 - 1);
    int v11 = *(llvm::RegisterClassInfo **)(result + 16);
    unsigned int v12 = *(_DWORD *)(*((void *)v11 + 27) + 4 * v10);
    if (!v12)
    {
      uint64_t v33 = result;
      uint64_t v34 = (v9 - 1);
      uint64_t v32 = a7;
      uint64_t v26 = a4;
      uint64_t v27 = a6;
      unsigned int v30 = a3;
      uint64_t v31 = a5;
      uint64_t v21 = *(void *)(result + 16);
      uint64_t v29 = v7;
      int v25 = v8;
      int v28 = *a3;
      unsigned int v22 = llvm::RegisterClassInfo::computePSetLimit(v11, v34);
      int v9 = v28;
      uint64_t v8 = v25;
      a4 = v26;
      uint64_t v7 = v29;
      a3 = v30;
      a5 = v31;
      a6 = v27;
      a7 = v32;
      unsigned int v12 = v22;
      uint64_t result = v33;
      uint64_t v10 = v34;
      *(_DWORD *)(*(void *)(v21 + 216) + 4 * v34) = v12;
    }
    uint64_t v13 = *(void *)(result + 328);
    if (v13 != *(void *)(result + 336)) {
      v12 += *(_DWORD *)(v13 + 4 * v10);
    }
    unsigned int v14 = *(_DWORD *)(*(void *)(result + 72) + 4 * v10);
    unsigned int v15 = *(_DWORD *)(**(void **)(result + 48) + 4 * v10);
    unsigned int v16 = v14 + (__int16)a3[1];
    if (v16 <= v15) {
      unsigned int v17 = *(_DWORD *)(**(void **)(result + 48) + 4 * v10);
    }
    else {
      unsigned int v17 = v14 + (__int16)a3[1];
    }
    if (!*(_WORD *)a4)
    {
      unsigned int v18 = v14 - v12;
      if (v14 < v12) {
        unsigned int v18 = 0;
      }
      if (v14 <= v12) {
        int v19 = v16 - v12;
      }
      else {
        int v19 = (__int16)a3[1];
      }
      if (v16 <= v12) {
        int v20 = -v18;
      }
      else {
        int v20 = v19;
      }
      if (v20)
      {
        *(_DWORD *)a4 = v9;
        *(_WORD *)(a4 + 2) = v20;
      }
    }
    if (v15 < v16)
    {
      if (!*(_WORD *)(a4 + 4) && v7 != a6)
      {
        while (1)
        {
          int v23 = *(unsigned __int16 *)(a5 + 4 * v7);
          if (v23 - 1 >= v10) {
            break;
          }
          uint64_t v7 = (v7 + 1);
          if (a6 == v7)
          {
            uint64_t v7 = a6;
            goto LABEL_24;
          }
        }
        if (v23 == v9)
        {
          unsigned int v24 = v17 - *(__int16 *)(a5 + 4 * v7 + 2);
          if (v24 - 0x8000 >= 0xFFFF8001)
          {
            *(_DWORD *)(a4 + 4) = v9;
            *(_WORD *)(a4 + 6) = v24;
          }
        }
      }
LABEL_24:
      if (!*(_WORD *)(a4 + 8) && v17 > *(_DWORD *)(a7 + 4 * v10))
      {
        *(_DWORD *)(a4 + 8) = v9;
        *(_WORD *)(a4 + 10) = v17 - v15;
      }
    }
    a3 += 2;
  }
  while (a3 != v8);
  return result;
}

uint64_t llvm::RegPressureTracker::getLiveLanesAt(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_1CC4464AC(*(void *)(a1 + 32), *(void *)(a1 + 24), *(unsigned char *)(a1 + 58), a2, a3, -1, (unsigned int (*)(void))sub_1CC446D78);
}

uint64_t sub_1CC4464AC(uint64_t a1, uint64_t a2, char a3, unsigned int a4, uint64_t a5, uint64_t a6, unsigned int (*a7)(void))
{
  if ((a4 & 0x80000000) == 0)
  {
    uint64_t v11 = *(void *)(*(void *)(a1 + 680) + 8 * a4);
    if (!v11) {
      return a6;
    }
    return ((uint64_t (*)(uint64_t, uint64_t))a7)(v11, a5) << 63 >> 63;
  }
  unint64_t v13 = a4 & 0x7FFFFFFF;
  unsigned int v14 = (void *)(a1 + 408);
  unint64_t v15 = *(unsigned int *)(a1 + 416);
  BOOL v16 = v13 >= v15;
  unint64_t v17 = v13 - v15;
  if (v16)
  {
    sub_1CB9153B8((uint64_t)v14, v17 + 1, *(void *)(a1 + 424));
LABEL_17:
    operator new();
  }
  uint64_t v11 = *(void *)(*v14 + 8 * v13);
  if (!v11) {
    goto LABEL_17;
  }
  if ((a3 & 1) == 0) {
    return ((uint64_t (*)(uint64_t, uint64_t))a7)(v11, a5) << 63 >> 63;
  }
  uint64_t v18 = *(void *)(v11 + 104);
  if (v18)
  {
    a6 = 0;
    do
    {
      if (((unsigned int (*)(uint64_t, uint64_t))a7)(v18, a5)) {
        a6 |= *(void *)(v18 + 112);
      }
      uint64_t v18 = *(void *)(v18 + 104);
    }
    while (v18);
  }
  else if (a7())
  {
    return *(void *)((*(void *)(*(void *)(a2 + 24) + 16 * v13) & 0xFFFFFFFFFFFFFFF8) + 24);
  }
  else
  {
    return 0;
  }
  return a6;
}

double llvm::RegPressureTracker::getMaxDownwardPressureDelta(uint64_t a1, const llvm::MachineInstr *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v27 = 0;
  sub_1CBA85A80(__p, *(const void **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2);
  uint64_t v14 = *(void *)(a1 + 48);
  unsigned int v24 = 0;
  uint64_t v25 = 0;
  int v23 = 0;
  sub_1CBA85A80(&v23, *(const void **)v14, *(void *)(v14 + 8), (uint64_t)(*(void *)(v14 + 8) - *(void *)v14) >> 2);
  llvm::RegPressureTracker::bumpDownwardPressure((llvm::RegPressureTracker *)a1, a2);
  sub_1CC4460EC((uint64_t)__p[0], ((char *)__p[1] - (char *)__p[0]) >> 2, *(void *)(a1 + 72), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 2, a3, *(llvm::RegisterClassInfo **)(a1 + 16), *(void *)(a1 + 328), (uint64_t)(*(void *)(a1 + 336) - *(void *)(a1 + 328)) >> 2);
  uint64_t v15 = (uint64_t)v23;
  sub_1CC4461D4((uint64_t)v23, (v24 - v23) >> 2, **(void **)(a1 + 48), (uint64_t)(*(void *)(*(void *)(a1 + 48) + 8) - **(void **)(a1 + 48)) >> 2, a4, a5, a6, a7, a3);
  uint64_t v16 = *(void *)(a1 + 48);
  unint64_t v17 = *(unsigned char **)v16;
  *(void *)uint64_t v16 = v15;
  *(void *)(v16 + 8) = v24;
  uint64_t v18 = *(void *)(v16 + 16);
  *(void *)(v16 + 16) = v25;
  int v23 = v17;
  uint64_t v25 = v18;
  long long v19 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)__p;
  *(_OWORD *)__p = v19;
  uint64_t v20 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v27;
  uint64_t v27 = v20;
  if (v17)
  {
    unsigned int v24 = v17;
    operator delete(v17);
    uint64_t v21 = __p[0];
    if (__p[0])
    {
LABEL_3:
      __p[1] = v21;
      operator delete(v21);
    }
  }
  else
  {
    uint64_t v21 = (void *)v19;
    if ((void)v19) {
      goto LABEL_3;
    }
  }
  return *(double *)&v19;
}

uint64_t llvm::RegPressureTracker::getUpwardPressure(char **this, llvm::MachineInstr *a2, char **a3, char **a4)
{
  if (this + 9 != a3) {
    sub_1CC19E0C8(a3, this[9], this[10], (this[10] - this[9]) >> 2);
  }
  uint64_t v8 = (char **)this[6];
  if (v8 != a4) {
    sub_1CC19E0C8(a4, *v8, v8[1], (v8[1] - *v8) >> 2);
  }
  uint64_t result = llvm::RegPressureTracker::bumpUpwardPressure((llvm::RegPressureTracker *)this, a2);
  uint64_t v10 = this[6];
  uint64_t v11 = *(char **)v10;
  *(void *)uint64_t v10 = *a4;
  *a4 = v11;
  unsigned int v12 = (char *)*((void *)v10 + 1);
  *((void *)v10 + 1) = a4[1];
  a4[1] = v12;
  unint64_t v13 = (char *)*((void *)v10 + 2);
  *((void *)v10 + 2) = a4[2];
  a4[2] = v13;
  uint64_t v14 = this[9];
  this[9] = *a3;
  *a3 = v14;
  uint64_t v15 = this[10];
  this[10] = a3[1];
  a3[1] = v15;
  uint64_t v16 = this[11];
  this[11] = a3[2];
  a3[2] = v16;
  return result;
}

uint64_t llvm::RegPressureTracker::getDownwardPressure(char **this, llvm::MachineInstr *a2, char **a3, char **a4)
{
  if (this + 9 != a3) {
    sub_1CC19E0C8(a3, this[9], this[10], (this[10] - this[9]) >> 2);
  }
  uint64_t v8 = (char **)this[6];
  if (v8 != a4) {
    sub_1CC19E0C8(a4, *v8, v8[1], (v8[1] - *v8) >> 2);
  }
  uint64_t result = llvm::RegPressureTracker::bumpDownwardPressure((llvm::RegPressureTracker *)this, a2);
  uint64_t v10 = this[6];
  uint64_t v11 = *(char **)v10;
  *(void *)uint64_t v10 = *a4;
  *a4 = v11;
  unsigned int v12 = (char *)*((void *)v10 + 1);
  *((void *)v10 + 1) = a4[1];
  a4[1] = v12;
  unint64_t v13 = (char *)*((void *)v10 + 2);
  *((void *)v10 + 2) = a4[2];
  a4[2] = v13;
  uint64_t v14 = this[9];
  this[9] = *a3;
  *a3 = v14;
  uint64_t v15 = this[10];
  this[10] = a3[1];
  a3[1] = v15;
  uint64_t v16 = this[11];
  this[11] = a3[2];
  a3[2] = v16;
  return result;
}

uint64_t *sub_1CC446A00(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t *a4)
{
  if ((a2 & 0x80000000) != 0)
  {
    if (a3) {
      uint64_t v16 = (uint64_t *)(*(void *)(*(void *)(a1 + 8) + 232) + 8 * a3);
    }
    else {
      uint64_t v16 = (uint64_t *)((*(void *)(*(void *)(*(void *)(a1 + 16) + 24) + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8)
    }
                      + 24);
    uint64_t v17 = *v16;
    return sub_1CC4454A0(a4, a2, v17);
  }
  else
  {
    uint64_t result = (uint64_t *)sub_1CB946A80(*(void **)(a1 + 16), a2);
    if (result)
    {
      uint64_t v9 = *(void *)(a1 + 8);
      if (v9) {
        uint64_t v10 = (void *)(v9 + 8);
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = (unsigned __int16 *)(v10[6]
                               + (((unint64_t)*(unsigned int *)(*v10 + 24 * a2 + 16) >> 3) & 0x1FFFFFFE));
      int v13 = *v11;
      unsigned int v12 = v11 + 1;
      int v14 = v13 + (*(_DWORD *)(*v10 + 24 * a2 + 16) & 0xF) * a2;
      do
      {
        uint64_t result = sub_1CC4454A0(a4, (unsigned __int16)v14, -1);
        int v15 = *v12++;
        v14 += v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t *sub_1CC446AFC(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  if ((a2 & 0x80000000) != 0)
  {
    return sub_1CC4454A0(a3, a2, -1);
  }
  else
  {
    uint64_t result = (uint64_t *)sub_1CB946A80(*(void **)(a1 + 16), a2);
    if (result)
    {
      uint64_t v8 = *(void *)(a1 + 8);
      if (v8) {
        uint64_t v9 = (void *)(v8 + 8);
      }
      else {
        uint64_t v9 = 0;
      }
      unint64_t v10 = *(unsigned int *)(*v9 + 24 * a2 + 16);
      uint64_t v11 = (unsigned __int16 *)(v9[6] + ((v10 >> 3) & 0x1FFFFFFE));
      int v13 = *v11;
      unsigned int v12 = v11 + 1;
      int v14 = v13 + (v10 & 0xF) * a2;
      do
      {
        uint64_t result = sub_1CC4454A0(a3, (unsigned __int16)v14, -1);
        int v15 = *v12++;
        v14 += v15;
      }
      while (v15);
    }
  }
  return result;
}

BOOL sub_1CC446BC8(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unint64_t v3 = *(void **)a1;
  if (!v2)
  {
    unsigned int v2 = 0;
    goto LABEL_12;
  }
  uint64_t v4 = v3[3 * v2 - 2];
  unsigned int v5 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3;
  if (v5 >= ((v4 >> 1) & 3 | *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_12:
    BOOL v6 = &v3[3 * v2];
    return v6 != &v3[3 * v2]
        && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3);
  }
  BOOL v6 = *(void **)a1;
  unint64_t v7 = *(unsigned int *)(a1 + 8);
  do
  {
    unint64_t v8 = v7 >> 1;
    uint64_t v9 = v6[3 * (v7 >> 1) + 1];
    LODWORD(v9) = (v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24);
    v7 -= (v7 >> 1) + 1;
    BOOL v10 = v5 >= v9;
    if (v5 >= v9) {
      unint64_t v11 = v8 + 1;
    }
    else {
      unint64_t v11 = 0;
    }
    v6 += 3 * v11;
    if (!v10) {
      unint64_t v7 = v8;
    }
  }
  while (v7);
  return v6 != &v3[3 * v2]
      && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3);
}

uint64_t sub_1CC446CA4(uint64_t *a1, unsigned int *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a1[18];
  unsigned int v4 = *(unsigned __int8 *)(v3 + v2);
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (v5 > v4)
  {
    uint64_t v6 = *a1;
    while (1)
    {
      unsigned int v7 = v4;
      if (*(_DWORD *)(v6 + 16 * v4) == v2) {
        break;
      }
      v4 += 256;
      if (v7 + 256 >= v5) {
        goto LABEL_5;
      }
    }
    if (v5 != v4) {
      return v6 + 16 * v4;
    }
  }
LABEL_5:
  *(unsigned char *)(v3 + v2) = v5;
  unsigned int v8 = *((_DWORD *)a1 + 2);
  if (v8 >= *((_DWORD *)a1 + 3)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(_OWORD *)(*a1 + 16 * v8) = *(_OWORD *)a2;
  unsigned int v9 = *((_DWORD *)a1 + 2) + 1;
  *((_DWORD *)a1 + 2) = v9;
  return *a1 + 16 * v9 - 16;
}

BOOL sub_1CC446D78(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (!v2)
  {
    unsigned int v2 = 0;
    goto LABEL_12;
  }
  uint64_t v4 = v3[3 * v2 - 2];
  unsigned int v5 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3;
  if (v5 >= ((v4 >> 1) & 3 | *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_12:
    uint64_t v6 = &v3[3 * v2];
    return v6 != &v3[3 * v2]
        && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3);
  }
  uint64_t v6 = *(void **)a1;
  unint64_t v7 = *(unsigned int *)(a1 + 8);
  do
  {
    unint64_t v8 = v7 >> 1;
    uint64_t v9 = v6[3 * (v7 >> 1) + 1];
    LODWORD(v9) = (v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24);
    v7 -= (v7 >> 1) + 1;
    BOOL v10 = v5 >= v9;
    if (v5 >= v9) {
      unint64_t v11 = v8 + 1;
    }
    else {
      unint64_t v11 = 0;
    }
    v6 += 3 * v11;
    if (!v10) {
      unint64_t v7 = v8;
    }
  }
  while (v7);
  return v6 != &v3[3 * v2]
      && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3);
}

BOOL sub_1CC446E54(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (!v2)
  {
    unsigned int v2 = 0;
    goto LABEL_12;
  }
  uint64_t v4 = v3[3 * v2 - 2];
  unsigned int v5 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3;
  if (v5 >= ((v4 >> 1) & 3 | *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_12:
    uint64_t v6 = &v3[3 * v2];
    return v6 != &v3[3 * v2]
        && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3)
        && v6[1] == (a2 & 0xFFFFFFFFFFFFFFF8 | 4);
  }
  uint64_t v6 = *(void **)a1;
  unint64_t v7 = *(unsigned int *)(a1 + 8);
  do
  {
    unint64_t v8 = v7 >> 1;
    uint64_t v9 = v6[3 * (v7 >> 1) + 1];
    LODWORD(v9) = (v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24);
    v7 -= (v7 >> 1) + 1;
    BOOL v10 = v5 >= v9;
    if (v5 >= v9) {
      unint64_t v11 = v8 + 1;
    }
    else {
      unint64_t v11 = 0;
    }
    v6 += 3 * v11;
    if (!v10) {
      unint64_t v7 = v8;
    }
  }
  while (v7);
  return v6 != &v3[3 * v2]
      && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3)
      && v6[1] == (a2 & 0xFFFFFFFFFFFFFFF8 | 4);
}

BOOL sub_1CC446F40(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (!v2)
  {
    unsigned int v2 = 0;
    goto LABEL_12;
  }
  uint64_t v4 = v3[3 * v2 - 2];
  unsigned int v5 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3;
  if (v5 >= ((v4 >> 1) & 3 | *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_12:
    uint64_t v6 = &v3[3 * v2];
    goto LABEL_13;
  }
  uint64_t v6 = *(void **)a1;
  unint64_t v7 = *(unsigned int *)(a1 + 8);
  do
  {
    unint64_t v8 = v7 >> 1;
    uint64_t v9 = v6[3 * (v7 >> 1) + 1];
    LODWORD(v9) = (v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24);
    v7 -= (v7 >> 1) + 1;
    BOOL v10 = v5 >= v9;
    if (v5 >= v9) {
      unint64_t v11 = v8 + 1;
    }
    else {
      unint64_t v11 = 0;
    }
    v6 += 3 * v11;
    if (!v10) {
      unint64_t v7 = v8;
    }
  }
  while (v7);
LABEL_13:
  if (v6 == &v3[3 * v2]) {
    return 0;
  }
  unsigned int v12 = (*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24);
  int v13 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24);
  unsigned int v14 = v13 | (a2 >> 1) & 3;
  unsigned int v15 = v13 | 1;
  return v12 <= v14 && v12 < v15 && v6[1] != (a2 & 0xFFFFFFFFFFFFFFF8 | 6);
}

void *sub_1CC447034(void *result, unsigned int a2, uint64_t a3)
{
  if (*result) {
    uint64_t v3 = (void *)(*result + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3 + 24 * a2;
  unint64_t v5 = *(unsigned int *)(v4 + 16);
  uint64_t v6 = v3[7];
  unint64_t v7 = (_WORD *)(v3[6] + ((v5 >> 3) & 0x1FFFFFFE));
  __int16 v9 = *v7;
  unint64_t v8 = v7 + 1;
  unsigned __int16 v10 = v9 + (v5 & 0xF) * a2;
  unint64_t v11 = (void *)(v6 + 8 * *(unsigned __int16 *)(v4 + 20));
  do
  {
    if (*v11) {
      BOOL v12 = (*v11 & a3) == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12) {
      *(void *)(result[1] + 8 * (v10 >> 6)) |= 1 << v10;
    }
    ++v11;
    int v13 = *v8++;
    v10 += v13;
  }
  while (v13);
  return result;
}

void llvm::RegScavenger::init(llvm::RegScavenger *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v4 = *((void *)a2 + 4);
  *((void *)this + 1) = (*(uint64_t (**)(void))(**(void **)(v4 + 16) + 104))(*(void *)(v4 + 16));
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v4 + 16) + 176))(*(void *)(v4 + 16));
  *(void *)this = v5;
  *((void *)this + 2) = *(void *)(v4 + 40);
  *((void *)this + 12) = v5;
  uint64_t v6 = *((void *)this + 13);
  uint64_t v7 = *((unsigned int *)this + 28);
  if (v7) {
    bzero(*((void **)this + 13), 8 * v7);
  }
  int v8 = *(_DWORD *)(v5 + 44);
  if ((*((_DWORD *)this + 42) & 0x3F) != 0) {
    *(void *)(v6 + 8 * v7 - 8) &= ~(-1 << (*((_DWORD *)this + 42) & 0x3F));
  }
  *((_DWORD *)this + 42) = v8;
  uint64_t v9 = (v8 + 63) >> 6;
  if (v9 != v7)
  {
    if (v9 >= v7)
    {
      if (v9 > *((_DWORD *)this + 29)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      bzero((void *)(v6 + 8 * v7), 8 * (v9 - v7));
      LODWORD(v7) = (v8 + 63) >> 6;
    }
    else
    {
      LODWORD(v7) = (v8 + 63) >> 6;
    }
    *((_DWORD *)this + 28) = v7;
  }
  if ((v8 & 0x3F) != 0) {
    *(void *)(v6 + 8 * v7 - 8) &= ~(-1 << (v8 & 0x3F));
  }
  if (!*((void *)this + 3))
  {
    int v13 = *(_DWORD *)(*(void *)this + 44);
    *((_DWORD *)this + 10) = v13;
    sub_1CB8F8DF4((uint64_t)this + 176, v13, 0);
    sub_1CB8F8DF4((uint64_t)this + 248, *((_DWORD *)this + 10), 0);
    sub_1CB8F8DF4((uint64_t)this + 320, *((_DWORD *)this + 10), 0);
  }
  *((void *)this + 3) = a2;
  uint64_t v10 = *((unsigned int *)this + 14);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    BOOL v12 = (void *)(*((void *)this + 6) + 8);
    do
    {
      *((_DWORD *)v12 - 1) = 0;
      *BOOL v12 = 0;
      v12 += 2;
      v11 -= 16;
    }
    while (v11);
  }
  *((unsigned char *)this + 44) = 0;
}

uint64_t llvm::RegScavenger::enterBasicBlockEnd(llvm::RegScavenger *this, llvm::MachineBasicBlock *a2)
{
  llvm::RegScavenger::init(this, a2);
  uint64_t result = llvm::LiveRegUnits::addLiveOuts((llvm::RegScavenger *)((char *)this + 96), a2);
  uint64_t v5 = (_WORD *)(*((void *)a2 + 6) & 0xFFFFFFFFFFFFFFF8);
  if ((_WORD *)((char *)a2 + 48) != v5)
  {
    if (!v5 || (*(unsigned char *)v5 & 4) == 0)
    {
      while ((v5[22] & 4) != 0)
        uint64_t v5 = (_WORD *)(*(void *)v5 & 0xFFFFFFFFFFFFFFF8);
    }
    *((void *)this + 4) = v5;
    *((unsigned char *)this + 44) = 1;
  }
  return result;
}

void *llvm::RegScavenger::removeRegUnits(void *result, uint64_t *a2, unsigned int a3)
{
  if (*result) {
    uint64_t v3 = (void *)(*result + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = *(unsigned int *)(*v3 + 24 * a3 + 16);
  uint64_t v5 = (unsigned __int16 *)(v3[6] + ((v4 >> 3) & 0x1FFFFFFE));
  int v7 = *v5;
  uint64_t v6 = v5 + 1;
  int v8 = v7 + (v4 & 0xF) * a3;
  uint64_t v9 = *a2;
  do
  {
    *(void *)(v9 + 8 * ((unsigned __int16)v8 >> 6)) &= ~(1 << v8);
    int v10 = *v6++;
    v8 += v10;
  }
  while (v10);
  return result;
}

uint64_t sub_1CC447398(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 64);
  if (*(_DWORD *)(a1 + 64) < v4)
  {
    int v10 = *(_DWORD *)(a1 + 64) & 0x3F;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v10) {
      *(void *)(*(void *)a1 + 8 * v11 - 8) &= ~(-1 << v10);
    }
    unsigned int v12 = v11;
    *(_DWORD *)(a1 + 64) = v4;
    unsigned int v13 = v4 + 63;
    if (v11 != (v4 + 63) >> 6)
    {
      uint64_t v14 = v13 >> 6;
      if (v11 > v14)
      {
        *(_DWORD *)(a1 + 8) = v14;
        unsigned int v12 = v13 >> 6;
      }
      else
      {
        if (v14 > *(_DWORD *)(a1 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v14 != v11) {
          bzero((void *)(*(void *)a1 + 8 * v11), 8 * (v14 - v11));
        }
        unsigned int v12 = v14;
        *(_DWORD *)(a1 + 8) = v14;
        unsigned int v4 = *(_DWORD *)(a1 + 64);
      }
    }
    int v15 = v4 & 0x3F;
    if (v15) {
      *(void *)(*(void *)a1 + 8 * v12 - 8) &= ~(-1 << v15);
    }
  }
  uint64_t v5 = *(unsigned int *)(a2 + 8);
  if (v5)
  {
    uint64_t v6 = *(uint64_t **)a2;
    int v7 = *(void **)a1;
    do
    {
      uint64_t v8 = *v6++;
      *v7++ |= v8;
      --v5;
    }
    while (v5);
  }
  return a1;
}

void *llvm::RegScavenger::backward(llvm::RegScavenger *this)
{
  unsigned int v2 = (const llvm::MachineInstr *)*((void *)this + 4);
  uint64_t result = llvm::LiveRegUnits::stepBackward((llvm::RegScavenger *)((char *)this + 96), v2);
  uint64_t v4 = *((unsigned int *)this + 14);
  if (v4)
  {
    uint64_t v7 = 16 * v4;
    uint64_t v8 = (void *)(*((void *)this + 6) + 8);
    do
    {
      if ((const llvm::MachineInstr *)*v8 == v2)
      {
        *((_DWORD *)v8 - 1) = 0;
        void *v8 = 0;
      }
      v8 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  uint64_t v5 = (void *)*((void *)this + 4);
  if (v5 == *(void **)(*((void *)this + 3) + 56))
  {
    *((void *)this + 4) = 0;
    *((unsigned char *)this + 44) = 0;
  }
  else
  {
    unint64_t v6 = *v5 & 0xFFFFFFFFFFFFFFF8;
    if (!v6 || (*(unsigned char *)v6 & 4) == 0)
    {
      while ((*(_WORD *)(v6 + 44) & 4) != 0)
        unint64_t v6 = *(void *)v6 & 0xFFFFFFFFFFFFFFF8;
    }
    *((void *)this + 4) = v6;
  }
  return result;
}

BOOL llvm::RegScavenger::isRegUsed(void *a1, unsigned int a2, BOOL a3)
{
  if (((*(void *)(*(void *)(a1[2] + 352) + 8 * (a2 >> 6)) >> a2) & 1) == 0)
  {
    uint64_t v3 = a1[12];
    if (v3) {
      uint64_t v4 = (void *)(v3 + 8);
    }
    else {
      uint64_t v4 = 0;
    }
    unint64_t v5 = *(unsigned int *)(*v4 + 24 * (unsigned __int16)a2 + 16);
    unint64_t v6 = (_WORD *)(v4[6] + ((v5 >> 3) & 0x1FFFFFFE));
    __int16 v8 = *v6;
    uint64_t v7 = v6 + 1;
    unsigned __int16 v9 = v8 + (v5 & 0xF) * a2;
    do
    {
      uint64_t v10 = (1 << v9) & *(void *)(a1[13] + 8 * (v9 >> 6));
      a3 = v10 != 0;
      if (v10) {
        break;
      }
      int v11 = *v7++;
      v9 += v11;
    }
    while (v11);
  }
  return a3;
}

uint64_t llvm::RegScavenger::getRegsAvailable@<X0>(void *a1@<X0>, unsigned __int16 ***a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(*a1 + 16);
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x600000000;
  uint64_t result = sub_1CB90D610(a3, (v6 + 63) >> 6, 0);
  *(_DWORD *)(a3 + 64) = v6;
  if (*((_WORD *)*a2 + 10))
  {
    __int16 v8 = **a2;
    unsigned __int16 v9 = &v8[*((unsigned __int16 *)*a2 + 10)];
    uint64_t v10 = *(void *)(a1[2] + 352);
    uint64_t v11 = *(void *)a3;
    do
    {
      unint64_t v12 = *v8;
      if (((*(void *)(v10 + ((v12 >> 3) & 0x1FF8)) >> v12) & 1) == 0)
      {
        uint64_t v13 = a1[12];
        if (v13) {
          uint64_t v14 = (void *)(v13 + 8);
        }
        else {
          uint64_t v14 = 0;
        }
        unint64_t v15 = *(unsigned int *)(*v14 + 24 * *v8 + 16);
        uint64_t v16 = (unsigned __int16 *)(v14[6] + ((v15 >> 3) & 0x1FFFFFFE));
        int v18 = *v16;
        uint64_t v17 = v16 + 1;
        uint64_t result = v18 + (v15 & 0xF) * v12;
        while (((*(void *)(a1[13] + 8 * ((unsigned __int16)result >> 6)) >> result) & 1) == 0)
        {
          int v19 = *v17++;
          uint64_t result = (v19 + result);
          if (!v19)
          {
            *(void *)(v11 + ((v12 >> 3) & 0x1FF8)) |= 1 << v12;
            break;
          }
        }
      }
      ++v8;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t llvm::RegScavenger::findSurvivorReg(llvm::MachineBasicBlock **a1, unint64_t a2, uint64_t a3, int a4, unint64_t *a5)
{
  int v8 = *(_DWORD *)(a3 + 64);
  if (v8)
  {
    uint64_t v9 = 0;
    int v10 = -v8;
    int v11 = v8 - 1;
    unint64_t v12 = *(uint64_t **)a3;
    unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> v10;
    uint64_t v14 = v11 & 0xFFFFFFC0;
    while (1)
    {
      uint64_t v16 = *v12++;
      uint64_t v15 = v16;
      unint64_t v17 = v14 == v9 ? v13 : -1;
      unint64_t v18 = v17 & v15;
      if (v18) {
        break;
      }
      v9 += 64;
      if (v14 + 64 == v9) {
        goto LABEL_8;
      }
    }
    uint64_t v19 = __clz(__rbit64(v18)) + v9;
  }
  else
  {
LABEL_8:
    uint64_t v19 = 0xFFFFFFFFLL;
  }
  unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator(a1[3]);
  unint64_t v21 = FirstTerminator;
  if (!a2 || (unint64_t v22 = a2, (*(unsigned char *)a2 & 4) == 0))
  {
    unint64_t v22 = a2;
    if ((*(_WORD *)(a2 + 44) & 8) != 0)
    {
      unint64_t v22 = a2;
      do
        unint64_t v22 = *(void *)(v22 + 8);
      while ((*(_WORD *)(v22 + 44) & 8) != 0);
    }
  }
  unint64_t v23 = *(void *)(v22 + 8);
  if (a4 && v23 != FirstTerminator)
  {
    char v72 = 0;
    do
    {
      int v24 = **(unsigned __int16 **)(v23 + 16);
      if ((v24 - 13) < 5 || v24 == 23)
      {
        ++a4;
      }
      else
      {
        uint64_t v70 = v19;
        unint64_t v71 = a2;
        uint64_t v26 = *(unsigned int *)(v23 + 40);
        if (v26)
        {
          char v27 = 0;
          int v28 = 0;
          uint64_t v29 = *(int **)(v23 + 32);
          unsigned int v30 = &v29[8 * v26];
          do
          {
            unsigned int v31 = *v29;
            if (*v29 == 12)
            {
              sub_1CC2F5880(a3, *((unsigned int **)v29 + 2), 0xFFFFFFFF);
              unsigned int v31 = *v29;
            }
            if ((v31 & 0x100000FF) == 0)
            {
              unsigned int v32 = v29[1];
              if (v32)
              {
                if ((v32 & 0x80000000) != 0)
                {
                  if ((v31 & 0x1000000) != 0) {
                    char v27 = 1;
                  }
                  else {
                    v28 |= (v31 >> 26) & ~HIBYTE(v31);
                  }
                }
                else
                {
                  if (*a1) {
                    uint64_t v33 = (uint64_t *)((char *)*a1 + 8);
                  }
                  else {
                    uint64_t v33 = 0;
                  }
                  uint64_t v34 = *v33;
                  int v35 = *(_DWORD *)(*v33 + 24 * v32 + 16) & 0xF;
                  unint64_t v36 = ((unint64_t)*(unsigned int *)(*v33 + 24 * v32 + 16) >> 3) & 0x1FFFFFFE;
                  uint64_t v39 = v33 + 5;
                  uint64_t v38 = v33[5];
                  uint64_t v37 = v39[1];
                  uint64_t v40 = (unsigned __int16 *)(v37 + v36);
                  int v42 = *v40;
                  uint64_t v41 = v40 + 1;
                  int v43 = v42 + v35 * v32;
                  while (1)
                  {
                    uint64_t v44 = 4 * (unsigned __int16)v43;
                    uint64_t v45 = *(unsigned __int16 *)(v38 + v44);
                    if (*(_WORD *)(v38 + v44) && v37 != 0) {
                      break;
                    }
                    int v47 = (unsigned __int16)*v41++;
                    v43 += v47;
                    if (!v47) {
                      goto LABEL_31;
                    }
                  }
                  unsigned int v48 = *(unsigned __int16 *)(v38 + 4 * (unsigned __int16)v43 + 2) << 16;
                  uint64_t v49 = *(uint64_t **)a3;
                  for (unsigned int i = v45; ; unsigned int i = v45)
                  {
                    while (1)
                    {
                      unsigned int v51 = (unsigned __int16 *)(v37 + 2 * *(unsigned int *)(v34 + 24 * v45 + 8));
                      do
                      {
                        v49[(unsigned __int16)i >> 6] &= ~(1 << i);
                        int v52 = *v51++;
                        i += v52;
                      }
                      while (v52);
                      uint64_t v45 = HIWORD(v48);
                      if (!v45) {
                        break;
                      }
                      unsigned int i = HIWORD(v48);
                      v48 >>= 16;
                    }
                    if (!*v41) {
                      break;
                    }
                    v43 += (unsigned __int16)*v41++;
                    uint64_t v53 = (unsigned __int16 *)(v38 + 4 * (unsigned __int16)v43);
                    uint64_t v45 = *v53;
                    unsigned int v48 = v53[1] << 16;
                  }
                }
              }
            }
LABEL_31:
            v29 += 8;
          }
          while (v29 != v30);
        }
        else
        {
          LOBYTE(v28) = 0;
          char v27 = 0;
        }
        uint64_t v19 = v70;
        a2 = v71;
        if ((v72 & 1) == 0) {
          a2 = v23;
        }
        BOOL v54 = *(uint64_t **)a3;
        if (((*(void *)(*(void *)a3 + 8 * (v70 >> 6)) >> v70) & 1) == 0)
        {
          uint64_t v55 = *(unsigned int *)(a3 + 8);
          if (!v55) {
            break;
          }
          uint64_t v56 = 8 * v55;
          uint64_t v57 = *(uint64_t **)a3;
          while (!*v57)
          {
            ++v57;
            v56 -= 8;
            if (!v56) {
              goto LABEL_81;
            }
          }
          int v58 = *(_DWORD *)(a3 + 64);
          if (v58)
          {
            uint64_t v59 = 0;
            int v60 = v58 - 1;
            unint64_t v61 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v58;
            uint64_t v62 = v60 & 0xFFFFFFC0;
            while (1)
            {
              uint64_t v64 = *v54++;
              uint64_t v63 = v64;
              unint64_t v65 = v62 == v59 ? v61 : -1;
              unint64_t v66 = v65 & v63;
              if (v66) {
                break;
              }
              v59 += 64;
              uint64_t v19 = 0xFFFFFFFFLL;
              if (v62 + 64 == v59) {
                goto LABEL_73;
              }
            }
            uint64_t v19 = __clz(__rbit64(v66)) + v59;
          }
          else
          {
            uint64_t v19 = 0xFFFFFFFFLL;
          }
        }
LABEL_73:
        char v72 = v27 | (v28 ^ 1) & v72;
        if (!v23)
        {
LABEL_76:
          while ((*(_WORD *)(v23 + 44) & 8) != 0)
            unint64_t v23 = *(void *)(v23 + 8);
          goto LABEL_77;
        }
      }
      if ((*(unsigned char *)v23 & 4) == 0) {
        goto LABEL_76;
      }
LABEL_77:
      unint64_t v23 = *(void *)(v23 + 8);
      --a4;
    }
    while (a4 && v23 != v21);
  }
LABEL_81:
  if (v23 == v21) {
    unint64_t v67 = v21;
  }
  else {
    unint64_t v67 = a2;
  }
  *a5 = v67;
  return v19;
}

uint64_t llvm::RegScavenger::scavengeRegister(uint64_t a1, unsigned __int16 ***a2, unint64_t a3, uint64_t a4, int a5)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  llvm::TargetRegisterInfo::getAllocatableSet(*(void *)a1, *(void *)(*(void *)(a3 + 24) + 32), a2, (uint64_t)&__dst);
  uint64_t v10 = *(unsigned int *)(a3 + 40);
  if (v10)
  {
    int v11 = *(_DWORD **)(a3 + 32);
    unint64_t v12 = &v11[8 * v10];
    unint64_t v13 = __dst;
    do
    {
      if (!*v11)
      {
        unsigned int v14 = v11[1];
        if ((*v11 & 0x11000000) != 0x10000000 && (int)v14 >= 1)
        {
          if (*(void *)a1) {
            uint64_t v16 = (uint64_t *)(*(void *)a1 + 8);
          }
          else {
            uint64_t v16 = 0;
          }
          uint64_t v17 = *v16;
          int v18 = *(_DWORD *)(*v16 + 24 * v14 + 16) & 0xF;
          unint64_t v19 = ((unint64_t)*(unsigned int *)(*v16 + 24 * v14 + 16) >> 3) & 0x1FFFFFFE;
          unint64_t v22 = v16 + 5;
          uint64_t v21 = v16[5];
          uint64_t v20 = v22[1];
          unint64_t v23 = (unsigned __int16 *)(v20 + v19);
          int v25 = *v23;
          int v24 = v23 + 1;
          int v26 = v25 + v18 * v14;
          while (1)
          {
            uint64_t v27 = (unsigned __int16)v26;
            unsigned int v28 = *(unsigned __int16 *)(v21 + 4 * (unsigned __int16)v26);
            if (*(_WORD *)(v21 + 4 * (unsigned __int16)v26) && v20 != 0) {
              break;
            }
            int v30 = (unsigned __int16)*v24++;
            v26 += v30;
            if (!v30) {
              goto LABEL_9;
            }
          }
          while (1)
          {
            unsigned int v31 = *(unsigned __int16 *)(v21 + 4 * v27 + 2) << 16;
            uint64_t v32 = (unsigned __int16)v28;
            while (1)
            {
              uint64_t v33 = (unsigned __int16 *)(v20 + 2 * *(unsigned int *)(v17 + 24 * v32 + 8));
              do
              {
                v13[(unsigned __int16)v28 >> 6] &= ~(1 << v28);
                int v34 = *v33++;
                v28 += v34;
              }
              while (v34);
              uint64_t v32 = HIWORD(v31);
              if (!v32) {
                break;
              }
              unsigned int v28 = HIWORD(v31);
              v31 >>= 16;
            }
            if (!*v24) {
              break;
            }
            v26 += (unsigned __int16)*v24++;
            uint64_t v27 = (unsigned __int16)v26;
            unsigned int v28 = *(unsigned __int16 *)(v21 + 4 * (unsigned __int16)v26);
          }
        }
      }
LABEL_9:
      v11 += 8;
    }
    while (v11 != v12);
  }
  uint64_t v35 = *(unsigned int *)(a1 + 56);
  if (v35)
  {
    uint64_t v36 = *(void *)(a1 + 48);
    uint64_t v37 = v36 + 16 * v35;
    uint64_t v38 = __dst;
    do
    {
      unint64_t v39 = *(unsigned int *)(v36 + 4);
      if (v39)
      {
        if (((*(void *)(*(void *)(*(void *)(a1 + 16) + 352) + ((v39 >> 3) & 0x1FFFFFF8)) >> v39) & 1) == 0)
        {
          uint64_t v59 = *(void *)(a1 + 96);
          if (v59) {
            int v60 = (void *)(v59 + 8);
          }
          else {
            int v60 = 0;
          }
          unint64_t v61 = *(unsigned int *)(*v60 + 24 * (unsigned __int16)*(_DWORD *)(v36 + 4) + 16);
          uint64_t v62 = (_WORD *)(v60[6] + ((v61 >> 3) & 0x1FFFFFFE));
          __int16 v64 = *v62;
          uint64_t v63 = v62 + 1;
          unsigned __int16 v65 = v64 + (v61 & 0xF) * v39;
          while (((*(void *)(*(void *)(a1 + 104) + 8 * (v65 >> 6)) >> v65) & 1) == 0)
          {
            int v66 = *v63++;
            v65 += v66;
            if (!v66) {
              goto LABEL_57;
            }
          }
        }
        if (*(void *)a1) {
          uint64_t v40 = (uint64_t *)(*(void *)a1 + 8);
        }
        else {
          uint64_t v40 = 0;
        }
        uint64_t v41 = *v40;
        int v42 = *(_DWORD *)(*v40 + 24 * v39 + 16) & 0xF;
        unint64_t v43 = ((unint64_t)*(unsigned int *)(*v40 + 24 * v39 + 16) >> 3) & 0x1FFFFFFE;
        uint64_t v46 = v40 + 5;
        uint64_t v45 = v40[5];
        uint64_t v44 = v46[1];
        int v47 = (unsigned __int16 *)(v44 + v43);
        int v49 = *v47;
        unsigned int v48 = v47 + 1;
        int v50 = v49 + v42 * v39;
        while (1)
        {
          uint64_t v51 = (unsigned __int16)v50;
          int v52 = *(unsigned __int16 *)(v45 + 4 * (unsigned __int16)v50);
          if (*(_WORD *)(v45 + 4 * (unsigned __int16)v50) && v44 != 0) {
            break;
          }
          int v54 = (unsigned __int16)*v48++;
          v50 += v54;
          if (!v54) {
            goto LABEL_57;
          }
        }
        while (1)
        {
          unsigned int v55 = *(unsigned __int16 *)(v45 + 4 * v51 + 2) << 16;
          for (i = (unsigned __int16)v52; ; int v52 = i)
          {
            uint64_t v57 = (unsigned __int16 *)(v44 + 2 * *(unsigned int *)(v41 + 24 * i + 8));
            do
            {
              v38[(unsigned __int16)v52 >> 6] &= ~(1 << v52);
              int v58 = *v57++;
              v52 += v58;
            }
            while (v58);
            uint64_t i = HIWORD(v55);
            if (!i) {
              break;
            }
            v55 >>= 16;
          }
          if (!*v48) {
            break;
          }
          v50 += (unsigned __int16)*v48++;
          uint64_t v51 = (unsigned __int16)v50;
          int v52 = *(unsigned __int16 *)(v45 + 4 * (unsigned __int16)v50);
        }
      }
LABEL_57:
      v36 += 16;
    }
    while (v36 != v37);
  }
  llvm::RegScavenger::getRegsAvailable((void *)a1, a2, (uint64_t)&__src);
  uint64_t v67 = v94;
  uint64_t v68 = v97;
  if (v97 >= v94) {
    uint64_t v69 = v94;
  }
  else {
    uint64_t v69 = v97;
  }
  uint64_t v70 = __src;
  if (v69)
  {
    unint64_t v71 = (uint64_t *)__dst;
    char v72 = __src;
    uint64_t v73 = v69;
    do
    {
      uint64_t v74 = *v71++;
      *v72++ &= v74;
      --v73;
    }
    while (v73);
  }
  if (v67 > v68)
  {
    do
    {
      v70[v69] = 0;
      LODWORD(v69) = v69 + 1;
    }
    while (v67 != v69);
  }
  if (v67)
  {
    unint64_t v75 = 0;
    size_t v76 = 8 * v67;
    while (!v70[v75 / 8])
    {
      v75 += 8;
      if (v76 == v75) {
        goto LABEL_81;
      }
    }
    if (v67 <= v68)
    {
      memmove(__dst, v70, v76);
    }
    else
    {
      if (v98 < v67)
      {
        unsigned int v97 = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v68)
      {
        uint64_t v91 = v68;
        memmove(__dst, v70, 8 * v68);
        uint64_t v77 = v91;
      }
      else
      {
        uint64_t v77 = 0;
      }
      if (v77 != v94) {
        memcpy((char *)__dst + 8 * v77, (char *)__src + 8 * v77, 8 * v94 - 8 * v77);
      }
    }
    unsigned int v97 = v67;
    v99[12] = v95[12];
  }
LABEL_81:
  unsigned int v92 = 0;
  uint64_t SurvivorReg = llvm::RegScavenger::findSurvivorReg((llvm::MachineBasicBlock **)a1, a3, (uint64_t)&__dst, 25, (unint64_t *)&v92);
  uint64_t v79 = SurvivorReg;
  if (((*(void *)(*(void *)(*(void *)(a1 + 16) + 352)
                   + (((unint64_t)SurvivorReg >> 3) & 0x1FFFFFF8)) >> SurvivorReg) & 1) != 0)
  {
    if (!a5)
    {
LABEL_83:
      uint64_t v79 = 0;
      goto LABEL_84;
    }
  }
  else
  {
    uint64_t v81 = *(void *)(a1 + 96);
    if (v81) {
      uint64_t v82 = (void *)(v81 + 8);
    }
    else {
      uint64_t v82 = 0;
    }
    unint64_t v83 = *(unsigned int *)(*v82 + 24 * (unsigned __int16)SurvivorReg + 16);
    int v84 = (_WORD *)(v82[6] + ((v83 >> 3) & 0x1FFFFFFE));
    __int16 v86 = *v84;
    int v85 = v84 + 1;
    unsigned __int16 v87 = v86 + (v83 & 0xF) * SurvivorReg;
    while (((*(void *)(*(void *)(a1 + 104) + 8 * (v87 >> 6)) >> v87) & 1) == 0)
    {
      int v88 = *v85++;
      v87 += v88;
      if (!v88) {
        goto LABEL_84;
      }
    }
    if ((a5 & 1) == 0) {
      goto LABEL_83;
    }
  }
  uint64_t v89 = llvm::RegScavenger::spill((void *)a1, SurvivorReg, (uint64_t)a2, a4, (void *)a3, &v92);
  unint64_t v90 = *v92 & 0xFFFFFFFFFFFFFFF8;
  if (!v90 || (*(unsigned char *)v90 & 4) == 0)
  {
    while ((*(_WORD *)(v90 + 44) & 4) != 0)
      unint64_t v90 = *(void *)v90 & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v89 + 8) = v90;
LABEL_84:
  if (__src != v95) {
    free(__src);
  }
  if (__dst != v99) {
    free(__dst);
  }
  return v79;
}

unint64_t llvm::RegScavenger::scavengeRegisterBackwards(void *a1, uint64_t a2, void *a3, int a4, unsigned int a5, int a6)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(uint64_t (**)(void))(a2 + 48);
  uint64_t v61 = a3[3];
  if (v7)
  {
    uint64_t v62 = v7(*(void *)(a3[3] + 32));
    uint64_t v8 = v44;
  }
  else
  {
    uint64_t v62 = **(void **)a2;
    uint64_t v8 = *(unsigned __int16 *)(*(void *)a2 + 20);
  }
  uint64_t v10 = a1 + 4;
  unint64_t v9 = a1[4];
  int v11 = (void *)a1[2];
  uint64_t v59 = *(void *)(v9 + 24);
  uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(*v11 + 16) + 176))(*(void *)(*v11 + 16));
  uint64_t v65 = 0x600000000;
  uint64_t v63 = (void *)v12;
  __int16 v64 = v66;
  int v13 = *(_DWORD *)(v12 + 44);
  int v67 = v13;
  unsigned int v14 = v13 + 63;
  if ((v13 + 63) < 0x40)
  {
    uint64_t v16 = 0;
  }
  else
  {
    uint64_t v15 = v14 >> 6;
    if (v14 >= 0x1C0) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    bzero(v66, 8 * v15);
    uint64_t v16 = v15;
    LODWORD(v65) = v15;
  }
  if ((v13 & 0x3F) != 0) {
    v66[v16 - 1] &= ~(-1 << (v13 & 0x3F));
  }
  uint64_t v51 = 0;
  unint64_t v52 = 0;
  char v17 = 0;
  int v58 = (void *)(v59 + 48);
  int v53 = 25;
  unint64_t v18 = v9;
  while (1)
  {
    llvm::LiveRegUnits::accumulate((llvm::LiveRegUnits *)&v63, (const llvm::MachineInstr *)v18);
    if ((void *)v18 == a3) {
      break;
    }
    if (v17) {
      goto LABEL_33;
    }
    char v17 = 0;
LABEL_44:
    unint64_t v18 = *(void *)v18 & 0xFFFFFFFFFFFFFFF8;
    if (!v18 || (*(unsigned char *)v18 & 4) == 0)
    {
      while ((*(_WORD *)(v18 + 44) & 4) != 0)
        unint64_t v18 = *(void *)v18 & 0xFFFFFFFFFFFFFFF8;
    }
  }
  if (v8)
  {
    unint64_t v19 = v64;
    if (v63) {
      uint64_t v20 = v63 + 1;
    }
    else {
      uint64_t v20 = 0;
    }
    uint64_t v21 = (unsigned __int16 *)v62;
    do
    {
      unint64_t v22 = *v21;
      if (((*(void *)(v11[44] + ((v22 >> 3) & 0x1FF8)) >> v22) & 1) == 0)
      {
        unint64_t v23 = *(unsigned int *)(*v20 + 24 * *v21 + 16);
        __int16 v24 = v23 & 0xF;
        int v25 = (_WORD *)(v20[6] + ((v23 >> 3) & 0x1FFFFFFE));
        __int16 v27 = *v25;
        int v26 = v25 + 1;
        unsigned __int16 v28 = v27 + v24 * v22;
        while (((*((void *)v64 + (v28 >> 6)) >> v28) & 1) == 0)
        {
          int v29 = *v26++;
          v28 += v29;
          if (!v29)
          {
            uint64_t v30 = a1[12];
            if (v30) {
              unsigned int v31 = (void *)(v30 + 8);
            }
            else {
              unsigned int v31 = 0;
            }
            unint64_t v32 = *(unsigned int *)(*v31 + 24 * *v21 + 16);
            uint64_t v33 = (_WORD *)(v31[6] + ((v32 >> 3) & 0x1FFFFFFE));
            __int16 v35 = *v33;
            int v34 = v33 + 1;
            unsigned __int16 v36 = v35 + (v32 & 0xF) * v22;
            while (((*(void *)(a1[13] + 8 * (v36 >> 6)) >> v36) & 1) == 0)
            {
              int v37 = *v34++;
              v36 += v37;
              if (!v37) {
                goto LABEL_58;
              }
            }
            break;
          }
        }
      }
      ++v21;
    }
    while (v21 != (unsigned __int16 *)(v62 + 2 * v8));
  }
  uint64_t v51 = a3;
  if (a4)
  {
    unint64_t v38 = v9;
    if ((*(unsigned char *)v9 & 4) == 0)
    {
      unint64_t v38 = v9;
      if ((*(_WORD *)(v9 + 44) & 8) != 0)
      {
        unint64_t v38 = v9;
        do
          unint64_t v38 = *(void *)(v38 + 8);
        while ((*(_WORD *)(v38 + 44) & 8) != 0);
      }
    }
    llvm::LiveRegUnits::accumulate((llvm::LiveRegUnits *)&v63, *(const llvm::MachineInstr **)(v38 + 8));
    uint64_t v51 = a3;
  }
LABEL_33:
  if ((_WORD)v52 && sub_1CBAF9370(&v63, (unsigned __int16)v52))
  {
    unint64_t v49 = v52;
  }
  else
  {
    if (!v8) {
      goto LABEL_57;
    }
    uint64_t v50 = 2 * v8;
    int v42 = (_WORD *)v62;
    while (1)
    {
      unint64_t v49 = (unsigned __int16)*v42;
      if (((*(void *)(v11[44] + ((v49 >> 3) & 0x1FF8)) >> *v42) & 1) == 0 && sub_1CBAF9370(&v63, v49)) {
        break;
      }
      ++v42;
      v50 -= 2;
      if (!v50) {
        goto LABEL_57;
      }
    }
    if (!v49) {
      goto LABEL_57;
    }
  }
  if (--v53)
  {
    uint64_t v39 = *(unsigned int *)(v18 + 40);
    if (v39)
    {
      uint64_t v40 = 32 * v39;
      uint64_t v41 = (_DWORD *)(*(void *)(v18 + 32) + 4);
      while (*((unsigned char *)v41 - 4) || (*v41 & 0x80000000) == 0)
      {
        v41 += 8;
        v40 -= 32;
        if (!v40) {
          goto LABEL_42;
        }
      }
      int v53 = 25;
      uint64_t v51 = (void *)v18;
    }
LABEL_42:
    if (v18 != *(void *)(v59 + 56))
    {
      char v17 = 1;
      unint64_t v52 = v49;
      goto LABEL_44;
    }
  }
  LOWORD(v52) = v49;
LABEL_57:
  unint64_t v22 = (unsigned __int16)v52;
  unint64_t v19 = v64;
  int v58 = v51;
LABEL_58:
  if (v19 != v66) {
    free(v19);
  }
  if (v22 != 0 && v61 + 48 == (void)v58) {
    unint64_t result = v22;
  }
  else {
    unint64_t result = 0;
  }
  if ((v22 == 0 || v61 + 48 != (void)v58) && a6)
  {
    if (a4)
    {
      uint64_t v45 = *v10;
      if (!*v10 || (*(unsigned char *)v45 & 4) == 0)
      {
        while ((*(_WORD *)(v45 + 44) & 8) != 0)
          uint64_t v45 = *(void *)(v45 + 8);
      }
      uint64_t v10 = (uint64_t *)(v45 + 8);
    }
    uint64_t v46 = *v10;
    if (!*v10 || (*(unsigned char *)v46 & 4) == 0)
    {
      while ((*(_WORD *)(v46 + 44) & 8) != 0)
        uint64_t v46 = *(void *)(v46 + 8);
    }
    uint64_t v63 = *(void **)(v46 + 8);
    uint64_t v47 = llvm::RegScavenger::spill(a1, v22, a2, a5, v58, &v63);
    unint64_t v48 = *v58 & 0xFFFFFFFFFFFFFFF8;
    if (!v48 || (*(unsigned char *)v48 & 4) == 0)
    {
      while ((*(_WORD *)(v48 + 44) & 4) != 0)
        unint64_t v48 = *(void *)v48 & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v47 + 8) = v48;
    sub_1CC309F80(a1 + 12, v22);
    return v22;
  }
  return result;
}

void *llvm::scavengeFrameVirtualRegs(void *this, llvm::MachineFunction *a2, llvm::RegScavenger *a3)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v4 = (_DWORD *)this[5];
  if (v4[8])
  {
    unint64_t v5 = (llvm::MachineBasicBlock *)(this + 40);
    int v6 = (llvm::MachineBasicBlock *)this[41];
    if (v6 != (llvm::MachineBasicBlock *)(this + 40))
    {
      do
      {
        if ((llvm::MachineBasicBlock *)((char *)v6 + 48) != (llvm::MachineBasicBlock *)(*((void *)v6 + 6) & 0xFFFFFFFFFFFFFFF8)
          && sub_1CC448668(v4, a2, v6)
          && sub_1CC448668(v4, a2, v6))
        {
          llvm::report_fatal_error((llvm *)"Incomplete scavenging after 2nd pass", (const llvm::Twine *)1);
        }
        int v6 = (llvm::MachineBasicBlock *)*((void *)v6 + 1);
      }
      while (v6 != v5);
    }
    this = (void *)llvm::MachineRegisterInfo::clearVirtRegs((uint64_t)v4);
  }
  **(void **)(v3 + 360) |= 8uLL;
  return this;
}

BOOL sub_1CC448668(_DWORD *a1, llvm::RegScavenger *a2, llvm::MachineBasicBlock *a3)
{
  uint64_t v37 = (*(uint64_t (**)(void))(**(void **)(*(void *)a1 + 16) + 176))(*(void *)(*(void *)a1 + 16));
  llvm::RegScavenger::enterBasicBlockEnd(a2, a3);
  unsigned int v6 = a1[8];
  unint64_t v7 = (unint64_t)a3 + 48;
  unsigned __int16 v36 = a3;
  if ((llvm::MachineBasicBlock *)((char *)a3 + 48) == *((llvm::MachineBasicBlock **)a3 + 7))
  {
    int v34 = a1[8];
  }
  else
  {
    LOBYTE(v8) = 0;
    do
    {
      unint64_t v7 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
      if (!v7 || (*(unsigned char *)v7 & 4) == 0)
      {
        while ((*(_WORD *)(v7 + 44) & 4) != 0)
          unint64_t v7 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
      }
      while (*((void *)a2 + 4) != v7)
        llvm::RegScavenger::backward(a2);
      if (v8)
      {
        if (!v7 || (unint64_t v9 = v7, (*(unsigned char *)v7 & 4) == 0))
        {
          unint64_t v9 = v7;
          if ((*(_WORD *)(v7 + 44) & 8) != 0)
          {
            unint64_t v9 = v7;
            do
              unint64_t v9 = *(void *)(v9 + 8);
            while ((*(_WORD *)(v9 + 44) & 8) != 0);
          }
        }
        uint64_t v10 = *(void *)(v9 + 8);
        uint64_t v11 = *(unsigned int *)(v10 + 40);
        if (v11)
        {
          uint64_t v12 = *(int **)(v10 + 32);
          int v13 = &v12[8 * v11];
          do
          {
            int v14 = *v12;
            if (!*v12 && (v14 & 0x10FFF00) != 0x1000000 && (v14 & 0x30000000) == 0)
            {
              unsigned int v16 = v12[1];
              if ((v16 & 0x80000000) != 0 && (v16 & 0x7FFFFFFF) < v6)
              {
                unsigned int v17 = sub_1CC448A28(a1, a2, v16, 1);
                llvm::MachineInstr::addRegisterKilled((llvm::MachineInstr *)v10, v17, v37, 0);
                uint64_t v19 = *((void *)a2 + 12);
                uint64_t v18 = *((void *)a2 + 13);
                if (v19) {
                  uint64_t v20 = (void *)(v19 + 8);
                }
                else {
                  uint64_t v20 = 0;
                }
                unint64_t v21 = *(unsigned int *)(*v20 + 24 * v17 + 16);
                unint64_t v22 = (unsigned __int16 *)(v20[6] + ((v21 >> 3) & 0x1FFFFFFE));
                int v24 = *v22;
                unint64_t v23 = v22 + 1;
                int v25 = v24 + (v21 & 0xF) * v17;
                do
                {
                  *(void *)(v18 + 8 * ((unsigned __int16)v25 >> 6)) |= 1 << v25;
                  int v26 = *v23++;
                  v25 += v26;
                }
                while (v26);
              }
            }
            v12 += 8;
          }
          while (v12 != v13);
        }
      }
      uint64_t v27 = *(unsigned int *)(v7 + 40);
      if (v27)
      {
        int v8 = 0;
        uint64_t v28 = 32 * v27;
        int v29 = (unsigned int *)(*(void *)(v7 + 32) + 4);
        do
        {
          int v30 = *(v29 - 1);
          if (!(_BYTE)v30)
          {
            unsigned int v31 = *v29;
            if ((*v29 & 0x80000000) != 0 && (v31 & 0x7FFFFFFF) < v6)
            {
              if ((v30 & 0x10FFF00) == 0x1000000) {
                int v32 = v8;
              }
              else {
                int v32 = 1;
              }
              if ((v30 & 0x30000000) == 0) {
                int v8 = v32;
              }
              if ((v30 & 0x1000000) != 0)
              {
                unsigned int v33 = sub_1CC448A28(a1, a2, v31, 0);
                llvm::MachineInstr::addRegisterDead((llvm::MachineInstr *)v7, v33, v37, 0);
              }
            }
          }
          v29 += 8;
          v28 -= 32;
        }
        while (v28);
      }
      else
      {
        LOBYTE(v8) = 0;
      }
    }
    while (v7 != *((void *)v36 + 7));
    int v34 = a1[8];
  }
  return v34 != v6;
}

void llvm::initializeScavengerTestPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EA61BEC0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC44898C;
    v3[1] = &v1;
    unsigned int v2 = v3;
    std::__call_once(&qword_1EA61BEC0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC44898C()
{
}

uint64_t sub_1CC448A28(void *a1, void *a2, unsigned int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(*a1 + 16) + 176))(*(void *)(*a1 + 16));
  uint64_t v9 = a3 & 0x7FFFFFFF;
  uint64_t v10 = *(void *)(a1[3] + 16 * v9 + 8);
  if (*(unsigned char *)(v10 + 3)) {
    goto LABEL_3;
  }
  do
  {
    uint64_t v10 = *(void *)(v10 + 24);
LABEL_3:
    ;
  }
  while (llvm::MachineInstr::findRegisterUseOperandIdx(*(void *)(v10 + 8), a3, 0, v8) != -1);
  uint64_t v11 = llvm::RegScavenger::scavengeRegisterBackwards(a2, *(void *)(a1[3] + 16 * v9) & 0xFFFFFFFFFFFFFFF8, *(void **)(v10 + 8), a4, 0, 1);
  uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(*a1 + 16) + 176))(*(void *)(*a1 + 16));
  if ((a3 & 0x80000000) != 0) {
    int v13 = (uint64_t *)(a1[3] + 16 * v9 + 8);
  }
  else {
    int v13 = (uint64_t *)(a1[34] + 8 * a3);
  }
  uint64_t v14 = *v13;
  if (*v13)
  {
    do
    {
      uint64_t v15 = *(void *)(v14 + 24);
      if ((v11 - 1) <= 0x3FFFFFFE) {
        llvm::MachineOperand::substPhysReg((unsigned int *)v14, v11, v12);
      }
      else {
        llvm::MachineOperand::setReg(v14, v11);
      }
      uint64_t v14 = v15;
    }
    while (v15);
  }
  return v11;
}

void sub_1CC448B90()
{
}

void sub_1CC448C34(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  uint64_t v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  unsigned int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    unint64_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  uint64_t v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    unsigned int v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC448CE8(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  unsigned int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC448D94(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
  uint64_t v7 = 0;
  v8[0] = 0;
  *(void *)((char *)v8 + 5) = 0;
  uint64_t v9 = v11;
  uint64_t v10 = 0x200000000;
  v11[4] = 0;
  uint64_t v12 = v14;
  uint64_t v13 = 0x600000000;
  v14[12] = 0;
  uint64_t v15 = v17;
  uint64_t v16 = 0x600000000;
  v17[12] = 0;
  uint64_t v18 = v20;
  uint64_t v19 = 0x600000000;
  v20[12] = 0;
  unint64_t v21 = v23;
  uint64_t v22 = 0x600000000;
  v23[12] = 0;
  (*(void (**)(void))(*(void *)v3 + 264))();
  (*(void (**)(uint64_t, uint64_t, unsigned char *))(*(void *)v3 + 272))(v3, a2, v6);
  llvm::scavengeFrameVirtualRegs((void *)a2, (llvm::MachineFunction *)v6, v4);
  if (v21 != v23) {
    free(v21);
  }
  if (v18 != v20) {
    free(v18);
  }
  if (v15 != v17) {
    free(v15);
  }
  if (v12 != v14) {
    free(v12);
  }
  if (v9 != v11) {
    free(v9);
  }
  return 1;
}

void sub_1CC448FBC()
{
}

void sub_1CC449058()
{
}

void sub_1CC44916C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  uint64_t v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  unsigned int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    unint64_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  uint64_t v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    unsigned int v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC449220(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  unsigned int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC4492CC(llvm::PassRegistry *a1, uint64_t a2)
{
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC449340(uint64_t a1, void **a2)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = (uint64_t ***)*a2;
  if ((*((unsigned char *)*a2 + 23) & 0x20) == 0) {
    goto LABEL_155;
  }
  uint64_t v4 = ***v2;
  uint64_t v109 = *a2;
  int v5 = *(_DWORD *)(v4 + 2496);
  if (!v5)
  {
    uint64_t v95 = 0;
LABEL_160:
    uint64_t v9 = sub_1CC609054(v4 + 2480, (uint64_t)&v109, (uint64_t *)&v109, v95);
    uint64_t v96 = v109;
    v9[3] = 0;
    v9[4] = 0;
    *uint64_t v9 = v96;
    v9[1] = v9 + 3;
    v9[2] = 0x100000000;
    goto LABEL_12;
  }
  uint64_t v6 = *(void *)(v4 + 2480);
  int v7 = v5 - 1;
  unsigned int v8 = v7 & ((v2 >> 4) ^ (v2 >> 9));
  uint64_t v9 = (void *)(v6 + 40 * v8);
  uint64_t v10 = (void ***)*v9;
  if ((uint64_t ***)*v9 != v2)
  {
    uint64_t v11 = 0;
    int v12 = 1;
    while (v10 != (void ***)-4096)
    {
      if (v11) {
        BOOL v13 = 0;
      }
      else {
        BOOL v13 = v10 == (void ***)-8192;
      }
      if (v13) {
        uint64_t v11 = v9;
      }
      unsigned int v14 = v8 + v12++;
      unsigned int v8 = v14 & v7;
      uint64_t v9 = (void *)(v6 + 40 * v8);
      uint64_t v10 = (void ***)*v9;
      if ((uint64_t ***)*v9 == v2) {
        goto LABEL_12;
      }
    }
    if (v11) {
      uint64_t v95 = v11;
    }
    else {
      uint64_t v95 = v9;
    }
    goto LABEL_160;
  }
LABEL_12:
  uint64_t v15 = *((unsigned int *)v9 + 4);
  if (!v15) {
    goto LABEL_155;
  }
  uint64_t v16 = (void *)(v9[1] + 8);
  uint64_t v17 = 16 * v15;
  LOBYTE(v18) = 0;
  while (*((_DWORD *)v16 - 2))
  {
    v16 += 2;
    v17 -= 16;
    if (!v17) {
      return v18 & 1;
    }
  }
  if (!*v16) {
    goto LABEL_155;
  }
  uint64_t v19 = *a2;
  uint64_t v20 = ***(void ***)*a2;
  uint64_t v109 = *a2;
  int v21 = *(_DWORD *)(v20 + 2496);
  if (v21)
  {
    uint64_t v22 = *(void *)(v20 + 2480);
    int v23 = v21 - 1;
    unsigned int v24 = v23 & ((v19 >> 4) ^ (v19 >> 9));
    int v25 = (void *)(v22 + 40 * v24);
    int v26 = (void *)*v25;
    if ((void *)*v25 == v19) {
      goto LABEL_28;
    }
    uint64_t v27 = 0;
    int v28 = 1;
    while (v26 != (void *)-4096)
    {
      if (v27) {
        BOOL v29 = 0;
      }
      else {
        BOOL v29 = v26 == (void *)-8192;
      }
      if (v29) {
        uint64_t v27 = v25;
      }
      unsigned int v30 = v24 + v28++;
      unsigned int v24 = v30 & v23;
      int v25 = (void *)(v22 + 40 * v24);
      int v26 = (void *)*v25;
      if ((void *)*v25 == v19) {
        goto LABEL_28;
      }
    }
    if (v27) {
      unsigned int v97 = v27;
    }
    else {
      unsigned int v97 = v25;
    }
  }
  else
  {
    unsigned int v97 = 0;
  }
  int v25 = sub_1CC609054(v20 + 2480, (uint64_t)&v109, (uint64_t *)&v109, v97);
  unsigned int v98 = v109;
  v25[3] = 0;
  v25[4] = 0;
  *int v25 = v98;
  v25[1] = v25 + 3;
  v25[2] = 0x100000000;
LABEL_28:
  uint64_t v31 = v25[1];
  if (*(_DWORD *)v31)
  {
    uint64_t v32 = 16 * *((unsigned int *)v25 + 4) - 16;
    do
    {
      int v33 = *(_DWORD *)(v31 + 16);
      v31 += 16;
      v32 -= 16;
    }
    while (v33);
  }
  if (*(_DWORD *)(*(void *)(*(void *)(v31 + 8) - 8 * *(unsigned int *)(*(void *)(v31 + 8) + 8) + 40) + 36))
  {
    int v34 = (void **)a2[41];
    unint64_t v99 = a2 + 40;
    if (v34 != a2 + 40)
    {
      int v18 = 0;
      while (1)
      {
        v112.i64[0] = (uint64_t)&v113;
        v112.i64[1] = 0x800000000;
        uint64_t v35 = 8;
        uint64_t v109 = (void *)1;
        do
        {
          unsigned __int16 v36 = (char *)&v109 + v35;
          *(void *)unsigned __int16 v36 = 0;
          v36[8] = 0;
          v36[24] = 0;
          *((void *)v36 + 4) = 0;
          v35 += 40;
        }
        while (v36 + 40 != (char *)&v112);
        uint64_t v37 = v34 + 6;
        unint64_t v38 = (unint64_t)v34[6] & 0xFFFFFFFFFFFFFFF8;
        if (!v38 || (*(unsigned char *)v38 & 4) == 0)
        {
          while ((*(_WORD *)(v38 + 44) & 4) != 0)
            unint64_t v38 = *(void *)v38 & 0xFFFFFFFFFFFFFFF8;
        }
        if ((void *)v38 == v37)
        {
LABEL_85:
          __int32 v100 = 0;
          goto LABEL_86;
        }
        do
        {
          int v39 = **(unsigned __int16 **)(v38 + 16);
          if ((v39 - 13) > 1)
          {
            if (v109 > 1 || HIDWORD(v109) != 0)
            {
              if ((v109 & 1) == 0)
              {
                if (((2 * v109) & 0xFFFFFFFC) >= v111[0])
                {
                  if (v111[0]) {
                    goto LABEL_54;
                  }
                  unsigned int v47 = 0;
                }
                else
                {
                  if (v111[0] > 0x40u)
                  {
                    sub_1CD571DA8((uint64_t)&v109);
                    goto LABEL_69;
                  }
LABEL_54:
                  uint64_t v45 = (uint64_t *)v110;
                  uint64_t v46 = (uint64_t *)(v110 + 40 * v111[0]);
                  do
                  {
LABEL_55:
                    *uint64_t v45 = 0;
                    *((unsigned char *)v45 + 8) = 0;
                    *(uint64_t *)((char *)v45 + 9) = v105;
                    v45[2] = *(void *)((char *)&v105 + 7);
                    *((unsigned char *)v45 + 24) = 0;
                    *(_DWORD *)((char *)v45 + 25) = v103.i32[0];
                    *((_DWORD *)v45 + 7) = *(__int32 *)((char *)v103.i32 + 3);
                    v45[4] = 0;
                    v45 += 5;
                  }
                  while (v45 != v46);
                  unsigned int v47 = v109 & 1;
                }
                uint64_t v109 = (void *)v47;
                goto LABEL_69;
              }
              uint64_t v45 = &v110;
              uint64_t v46 = (uint64_t *)&v112;
              goto LABEL_55;
            }
          }
          else
          {
            BOOL v13 = v39 == 14;
            uint64_t v40 = v39 != 14;
            uint64_t v41 = 96;
            if (v13) {
              uint64_t v41 = 32;
            }
            uint64_t v42 = *(void *)(v38 + 56);
            if (*(_DWORD *)(v42 + 8) == 2) {
              uint64_t v43 = *(void *)(v42 - 8);
            }
            else {
              uint64_t v43 = 0;
            }
            uint64_t v48 = *(void *)(v38 + 32);
            uint64_t v49 = *(void *)(v48 + (v40 << 6) + 16);
            uint64_t v50 = *(void *)(v48 + v41 + 16);
            *(void *)&long long v105 = v49;
            if (v50)
            {
              llvm::DIExpression::getFragmentInfo(*(uint64_t **)(v50 + 24), *(uint64_t **)(v50 + 32), (int8x16_t *)((char *)&v105 + 8));
            }
            else
            {
              BYTE8(v105) = 0;
              char v107 = 0;
            }
            uint64_t v108 = v43;
            sub_1CC449D74((uint64_t)&v109, (uint64_t)&v105, (uint64_t)&v103);
            if (**(_WORD **)(v38 + 16) == 13 && **(unsigned char **)(v38 + 32))
            {
              if (!v104) {
                sub_1CD571D48(&v109, (uint64_t *)&v105);
              }
            }
            else if (!v104)
            {
              if (v112.u32[2] >= (unint64_t)v112.u32[3]) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(v112.i64[0] + 8 * v112.u32[2]) = v38;
              ++v112.i32[2];
            }
          }
LABEL_69:
          unint64_t v38 = *(void *)v38 & 0xFFFFFFFFFFFFFFF8;
          if (!v38 || (*(unsigned char *)v38 & 4) == 0)
          {
            while ((*(_WORD *)(v38 + 44) & 4) != 0)
              unint64_t v38 = *(void *)v38 & 0xFFFFFFFFFFFFFFF8;
          }
        }
        while ((void *)v38 != v37);
        if (!v112.i32[2]) {
          goto LABEL_85;
        }
        uint64_t v51 = (llvm::MachineInstr **)v112.i64[0];
        uint64_t v52 = 8 * v112.u32[2];
        do
        {
          int v53 = *v51++;
          llvm::MachineInstr::eraseFromParent(v53);
          v52 -= 8;
        }
        while (v52);
        __int32 v100 = v112.i32[2];
LABEL_86:
        if ((v109 & 1) == 0) {
          MEMORY[0x1D25D9CD0](v110, 8);
        }
        int v102 = v18;
        if ((long long *)v112.i64[0] != &v113) {
          free((void *)v112.i64[0]);
        }
        uint64_t v109 = v111;
        uint64_t v110 = 0x800000000;
        long long v105 = 0uLL;
        unsigned int v106 = 0;
        uint64_t v54 = (*(uint64_t (**)(void))(**((void **)v34[4] + 2) + 176))(*((void *)v34[4] + 2));
        uint64_t v101 = v34;
        uint64_t v55 = (uint64_t)v34[7];
        if ((void *)v55 != v37)
        {
          uint64_t v56 = v54;
          uint64_t v57 = 0;
          while (1)
          {
            int v58 = *(unsigned __int16 **)(v55 + 16);
            int v59 = *v58;
            if ((v59 - 13) <= 1)
            {
              uint64_t v60 = v59 != 14;
              uint64_t v61 = *(void *)(v55 + 56);
              if (*(_DWORD *)(v61 + 8) == 2) {
                uint64_t v62 = *(void *)(v61 - 8);
              }
              else {
                uint64_t v62 = 0;
              }
              v112.i64[0] = *(void *)(*(void *)(v55 + 32) + (v60 << 6) + 16);
              v112.i8[8] = 0;
              BYTE8(v113) = 0;
              uint64_t v114 = v62;
              v103.i64[0] = 0;
              unsigned int v63 = v106;
              int v64 = sub_1CC44A2AC(v57, v106, v112.i64, v103.i64);
              uint64_t v65 = v103.i64[0];
              uint64_t v66 = v57 + 56 * v106;
              if (!v64) {
                uint64_t v65 = v57 + 56 * v106;
              }
              int v67 = **(unsigned __int16 **)(v55 + 16);
              if (v67 == 14 && v65 != v66) {
                goto LABEL_105;
              }
              uint64_t v69 = *(void *)(v55 + 32);
              uint64_t v70 = (unsigned char *)(v69 + ((unint64_t)(v67 == 14) << 6));
              if (*v70)
              {
                if (v65 == v66) {
                  goto LABEL_135;
                }
LABEL_105:
                *(void *)uint64_t v65 = 0;
                *(void *)(v65 + 8) = 0;
                *(void *)(v65 + 16) = 0;
                *(unsigned char *)(v65 + 24) = 1;
                *(void *)(v65 + 32) = 0;
                *((int32x2_t *)&v105 + 1) = vadd_s32(*(int32x2_t *)((char *)&v105 + 8), (int32x2_t)0x1FFFFFFFFLL);
                goto LABEL_135;
              }
              if (v65 == v66
                || *(_DWORD *)(*(void *)(v65 + 40) + 4) != *(_DWORD *)(v69 + ((unint64_t)(v67 == 14) << 6) + 4))
              {
                goto LABEL_111;
              }
              uint64_t v71 = *(void *)(v65 + 48);
              uint64_t v72 = 96;
              if (v67 == 14) {
                uint64_t v72 = 32;
              }
              if (v71 != *(void *)(v69 + v72 + 16))
              {
LABEL_111:
                uint64_t v73 = 96;
                if (v67 == 14) {
                  uint64_t v73 = 32;
                }
                uint64_t v74 = *(void *)(v69 + v73 + 16);
                v103.i64[0] = 0;
                char v75 = sub_1CC44A2AC(v57, v63, v112.i64, v103.i64);
                uint64_t v76 = v103.i64[0];
                if (v75) {
                  goto LABEL_121;
                }
                if (4 * DWORD2(v105) + 4 >= 3 * v63)
                {
                  int v86 = 2 * v63;
                }
                else
                {
                  if (v63 + ~DWORD2(v105) - HIDWORD(v105) > v63 >> 3)
                  {
LABEL_116:
                    ++DWORD2(v105);
                    if (*(void *)v76 || *(unsigned char *)(v76 + 24) || *(void *)(v76 + 32)) {
                      --HIDWORD(v105);
                    }
                    long long v77 = v113;
                    uint64_t v78 = v114;
                    *(int64x2_t *)uint64_t v76 = v112;
                    *(_OWORD *)(v76 + 16) = v77;
                    *(void *)(v76 + 40) = 0;
                    *(void *)(v76 + 48) = 0;
                    *(void *)(v76 + 32) = v78;
LABEL_121:
                    *(void *)(v76 + 40) = v70;
                    *(void *)(v76 + 48) = v74;
                    goto LABEL_135;
                  }
                  int v86 = v63;
                }
                sub_1CC44A418((uint64_t)&v105, v86);
                v103.i64[0] = 0;
                uint64_t v57 = v105;
                sub_1CC44A2AC(v105, v106, v112.i64, v103.i64);
                uint64_t v76 = v103.i64[0];
                goto LABEL_116;
              }
              if (v110 >= (unint64_t)HIDWORD(v110)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v109 + v110) = v55;
              LODWORD(v110) = v110 + 1;
              int v58 = *(unsigned __int16 **)(v55 + 16);
            }
            if ((v58[4] & 0x10) == 0)
            {
              unsigned int v79 = DWORD2(v105);
              int v80 = v106;
              unint64_t v81 = v57 + 56 * v106;
              if (DWORD2(v105))
              {
                v112.i64[0] = v57;
                v112.i64[1] = v57 + 56 * v106;
                sub_1CC44A3C8(&v112);
                int64x2_t v82 = v112;
              }
              else
              {
                int64x2_t v82 = vdupq_n_s64(v81);
              }
              int64x2_t v103 = v82;
              unint64_t v83 = (uint64_t *)v82.i64[0];
              if (v81 != v82.i64[0])
              {
                unsigned int v84 = HIDWORD(v105);
                do
                {
                  if (llvm::MachineInstr::findRegisterDefOperandIdx(v55, *(_DWORD *)(v83[5] + 4), 0, 1, v56) != -1)
                  {
                    v112.i64[0] = 0;
                    if (sub_1CC44A2AC(v57, v80, v83, v112.i64))
                    {
                      uint64_t v85 = v112.i64[0];
                      *(void *)v112.i64[0] = 0;
                      *(void *)(v85 + 8) = 0;
                      *(void *)(v85 + 16) = 0;
                      *(unsigned char *)(v85 + 24) = 1;
                      *(void *)(v85 + 32) = 0;
                      --v79;
                      ++v84;
                    }
                  }
                  v103.i64[0] += 56;
                  sub_1CC44A3C8(&v103);
                  unint64_t v83 = (uint64_t *)v103.i64[0];
                }
                while (v103.i64[0] != v81);
                *((void *)&v105 + 1) = __PAIR64__(v84, v79);
                if (!v55)
                {
LABEL_138:
                  while ((*(_WORD *)(v55 + 44) & 8) != 0)
                    uint64_t v55 = *(void *)(v55 + 8);
                  goto LABEL_139;
                }
              }
            }
LABEL_135:
            if ((*(unsigned char *)v55 & 4) == 0) {
              goto LABEL_138;
            }
LABEL_139:
            uint64_t v55 = *(void *)(v55 + 8);
            if ((void *)v55 == v37) {
              goto LABEL_146;
            }
          }
        }
        uint64_t v57 = 0;
LABEL_146:
        if (v110)
        {
          unsigned __int16 v87 = (llvm::MachineInstr **)v109;
          uint64_t v88 = 8 * v110;
          int v89 = v102;
          unint64_t v90 = v101;
          __int32 v91 = v100;
          do
          {
            unsigned int v92 = *v87++;
            llvm::MachineInstr::eraseFromParent(v92);
            v88 -= 8;
          }
          while (v88);
          int v93 = v110;
        }
        else
        {
          int v93 = 0;
          int v89 = v102;
          unint64_t v90 = v101;
          __int32 v91 = v100;
        }
        MEMORY[0x1D25D9CD0](v57, 8);
        if (v109 != v111) {
          free(v109);
        }
        int v18 = v89 | ((v93 | v91) != 0);
        int v34 = (void **)v90[1];
        if (v34 == v99) {
          return v18 & 1;
        }
      }
    }
  }
LABEL_155:
  LOBYTE(v18) = 0;
  return v18 & 1;
}

int *sub_1CC449D24(int *result)
{
  int v1 = *result;
  *(void *)unint64_t result = *result & 1;
  if (v1)
  {
    uint64_t v3 = result + 2;
    uint64_t v4 = result + 42;
  }
  else
  {
    unsigned int v2 = result[4];
    if (!v2) {
      return result;
    }
    uint64_t v3 = (int *)*((void *)result + 1);
    uint64_t v4 = &v3[10 * v2];
  }
  do
  {
    *(void *)uint64_t v3 = 0;
    *((unsigned char *)v3 + 8) = 0;
    *((unsigned char *)v3 + 24) = 0;
    *((void *)v3 + 4) = 0;
    v3 += 10;
  }
  while (v3 != v4);
  return result;
}

uint64_t sub_1CC449D74@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v16 = 0;
  uint64_t result = sub_1CC449E40(a1, (uint64_t *)a2, &v16);
  uint64_t v7 = v16;
  if (result)
  {
    uint64_t v14 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      unsigned int v15 = 4;
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 8);
      unsigned int v15 = *(_DWORD *)(a1 + 16);
    }
    char v13 = 0;
    uint64_t v12 = v14 + 40 * v15;
  }
  else
  {
    uint64_t result = sub_1CC449F70((_DWORD *)a1, a2, (uint64_t *)a2, v16);
    uint64_t v7 = result;
    long long v8 = *(_OWORD *)a2;
    long long v9 = *(_OWORD *)(a2 + 16);
    *(void *)(result + 32) = *(void *)(a2 + 32);
    *(_OWORD *)uint64_t result = v8;
    *(_OWORD *)(result + 16) = v9;
    uint64_t v10 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      unsigned int v11 = 4;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 16);
    }
    uint64_t v12 = v10 + 40 * v11;
    char v13 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v12;
  *(unsigned char *)(a3 + 16) = v13;
  return result;
}

uint64_t sub_1CC449E40(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v6 = 4;
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 16);
    if (!v6)
    {
      uint64_t v9 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v5 = *(void *)(a1 + 8);
  }
  int v7 = v6 - 1;
  unsigned int v8 = sub_1CC2E9470(a2) & (v6 - 1);
  uint64_t v9 = v5 + 40 * v8;
  if (sub_1CC2E9944((uint64_t)a2, v9))
  {
    uint64_t result = 1;
    goto LABEL_7;
  }
  uint64_t v11 = 0;
  int v12 = 1;
  while (1)
  {
    if (*(void *)v9) {
      goto LABEL_11;
    }
    if (!*(unsigned char *)(v9 + 24)) {
      break;
    }
    if (*(_OWORD *)(v9 + 8) == 0)
    {
      BOOL v13 = *(void *)(v9 + 32) == 0;
      goto LABEL_12;
    }
LABEL_11:
    BOOL v13 = 0;
LABEL_12:
    if (v13 && v11 == 0) {
      uint64_t v11 = v9;
    }
    int v14 = v12 + 1;
    unsigned int v8 = (v8 + v12) & v7;
    uint64_t v9 = v5 + 40 * v8;
    BOOL v15 = sub_1CC2E9944((uint64_t)a2, v9);
    uint64_t result = 1;
    int v12 = v14;
    if (v15) {
      goto LABEL_7;
    }
  }
  if (*(void *)(v9 + 32)) {
    goto LABEL_11;
  }
  uint64_t result = 0;
  if (v11) {
    uint64_t v9 = v11;
  }
LABEL_7:
  *a3 = v9;
  return result;
}

uint64_t sub_1CC449F70(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 4;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_11;
  }
  if (v7 + ~v6 - a1[1] <= v7 >> 3)
  {
LABEL_11:
    sub_1CC44A040((uint64_t)a1, v7);
    uint64_t v9 = 0;
    sub_1CC449E40((uint64_t)a1, a3, &v9);
    a4 = v9;
  }
  *a1 += 2;
  if (*(void *)a4 || *(unsigned char *)(a4 + 24) || *(void *)(a4 + 32)) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CC44A040(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(long long **)(a1 + 8);
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v15 = a2;
      *(void *)(a1 + 8) = operator new(40 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v15;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CC44A208((int *)a1, v6, (long long *)((char *)v6 + 40 * v7));
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v16;
  do
  {
    uint64_t v10 = a1 + v8;
    if (*(void *)(a1 + v8 + 8) || *(unsigned char *)(v10 + 32) && *(_OWORD *)(a1 + v8 + 16) != 0 || *(void *)(v10 + 40))
    {
      long long v11 = *(_OWORD *)(a1 + v8 + 8);
      long long v12 = *(_OWORD *)(a1 + v8 + 24);
      *((void *)v9 + 4) = *(void *)(a1 + v8 + 40);
      *uint64_t v9 = v11;
      v9[1] = v12;
      uint64_t v9 = (long long *)((char *)v9 + 40);
    }
    v8 += 40;
  }
  while (v8 != 160);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v13 = a2;
    *(void *)(a1 + 8) = operator new(40 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v13;
  }
  return sub_1CC44A208((int *)a1, v16, v9);
}

uint64_t sub_1CC44A208(int *a1, long long *a2, long long *a3)
{
  uint64_t result = (uint64_t)sub_1CC449D24(a1);
  while (a2 != a3)
  {
    if (*(void *)a2 || *((unsigned char *)a2 + 24) && *(long long *)((char *)a2 + 8) != 0 || *((void *)a2 + 4))
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CC449E40((uint64_t)a1, (uint64_t *)a2, &v10);
      unsigned int v7 = (_OWORD *)v10;
      long long v8 = *a2;
      long long v9 = a2[1];
      *(void *)(v10 + 32) = *((void *)a2 + 4);
      *unsigned int v7 = v8;
      v7[1] = v9;
      *a1 += 2;
    }
    a2 = (long long *)((char *)a2 + 40);
  }
  return result;
}

uint64_t sub_1CC44A2AC(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  if (!a2)
  {
    uint64_t v9 = 0;
    uint64_t result = 0;
    goto LABEL_5;
  }
  int v7 = a2 - 1;
  unsigned int v8 = sub_1CC2E9470(a3) & (a2 - 1);
  uint64_t v9 = a1 + 56 * v8;
  if (sub_1CC2E9944((uint64_t)a3, v9))
  {
    uint64_t result = 1;
    goto LABEL_5;
  }
  uint64_t v11 = 0;
  int v12 = 1;
  while (1)
  {
    if (*(void *)v9) {
      goto LABEL_8;
    }
    if (!*(unsigned char *)(v9 + 24)) {
      break;
    }
    if (*(_OWORD *)(v9 + 8) == 0)
    {
      BOOL v13 = *(void *)(v9 + 32) == 0;
      goto LABEL_9;
    }
LABEL_8:
    BOOL v13 = 0;
LABEL_9:
    if (v13 && v11 == 0) {
      uint64_t v11 = v9;
    }
    int v14 = v12 + 1;
    unsigned int v8 = (v8 + v12) & v7;
    uint64_t v9 = a1 + 56 * v8;
    BOOL v15 = sub_1CC2E9944((uint64_t)a3, v9);
    uint64_t result = 1;
    int v12 = v14;
    if (v15) {
      goto LABEL_5;
    }
  }
  if (*(void *)(v9 + 32)) {
    goto LABEL_8;
  }
  uint64_t result = 0;
  if (v11) {
    uint64_t v9 = v11;
  }
LABEL_5:
  *a4 = v9;
  return result;
}

void *sub_1CC44A3C8(void *result)
{
  int v1 = (void *)result[1];
  if ((void *)*result != v1)
  {
    unsigned int v2 = (void *)(*result + 32);
    do
    {
      if (*(v2 - 4) || *((unsigned char *)v2 - 8) && *(_OWORD *)(v2 - 3) != 0) {
        break;
      }
      if (*v2) {
        break;
      }
      unint64_t v3 = v2 + 3;
      *uint64_t result = v2 + 3;
      v2 += 7;
    }
    while (v3 != v1);
  }
  return result;
}

char *sub_1CC44A418(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unint64_t v4 = *(long long **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC44A4FC(a1, v4, (long long *)((char *)v4 + 56 * v3));
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = &result[56 * v10];
    do
    {
      *(void *)uint64_t result = 0;
      result[8] = 0;
      result[24] = 0;
      *((void *)result + 4) = 0;
      result += 56;
    }
    while (result != v11);
  }
  return result;
}

uint64_t sub_1CC44A4FC(uint64_t result, long long *a2, long long *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  unsigned int v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)result;
    uint64_t v8 = *(void *)result + 56 * v6;
    do
    {
      *(void *)uint64_t v7 = 0;
      *(unsigned char *)(v7 + 8) = 0;
      *(unsigned char *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      v7 += 56;
    }
    while (v7 != v8);
  }
  while (a2 != a3)
  {
    if (*(void *)a2 || *((unsigned char *)a2 + 24) && *(long long *)((char *)a2 + 8) != 0 || *((void *)a2 + 4))
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CC44A2AC(*(void *)v5, *(_DWORD *)(v5 + 16), (uint64_t *)a2, &v12);
      uint64_t v9 = (_OWORD *)v12;
      long long v10 = *a2;
      long long v11 = a2[1];
      *(void *)(v12 + 32) = *((void *)a2 + 4);
      *uint64_t v9 = v10;
      v9[1] = v11;
      *(_OWORD *)((char *)v9 + 40) = *(long long *)((char *)a2 + 40);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 = (long long *)((char *)a2 + 56);
  }
  return result;
}

void sub_1CC44A5DC(uint64_t a1)
{
}

void sub_1CC44A684()
{
}

void sub_1CC44A728(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  int v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    unint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  unsigned int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    uint64_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  unsigned int v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    unsigned int v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC44A7DC(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  unsigned int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  unint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC44A888()
{
  return "Rename Disconnected Subregister Components";
}

void sub_1CC44A898(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v4 = a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LiveIntervals::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::LiveIntervals::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::SlotIndexes::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::SlotIndexes::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC44A964(void *a1, uint64_t a2)
{
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a2 + 40);
  a1[32] = v2;
  if (*(unsigned char *)(v2 + 16))
  {
    uint64_t v4 = a1;
    uint64_t v5 = (uint64_t *)a1[1];
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    if (v6 == v7)
    {
LABEL_5:
      uint64_t v8 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v6 != &llvm::LiveIntervals::ID)
      {
        v6 += 16;
        if (v6 == v7) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = *(void *)(v6 + 8);
    }
    v4[31] = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::LiveIntervals::ID);
    v4[33] = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
    uint64_t v9 = *(unsigned int *)(v4[32] + 32);
    if (v9)
    {
      uint64_t v10 = 0;
      int v11 = 0;
      v121 = v4;
      uint64_t v114 = *(unsigned int *)(v4[32] + 32);
      while (1)
      {
        uint64_t v12 = v4[31];
        if ((v10 & 0x7FFFFFFF) >= (unint64_t)*(unsigned int *)(v12 + 416)) {
          goto LABEL_175;
        }
        uint64_t v13 = *(void *)(*(void *)(v12 + 408) + 8 * (v10 & 0x7FFFFFFF));
        if (!v13) {
          goto LABEL_175;
        }
        int v14 = *(const llvm::LiveRange **)(v13 + 104);
        if (!v14) {
          goto LABEL_175;
        }
        if (*(_DWORD *)(v13 + 72) >= 2u) {
          break;
        }
LABEL_174:
        uint64_t v4 = v121;
LABEL_175:
        if (++v10 == v9) {
          return v11 & 1;
        }
      }
      uint64_t v122 = *(void *)(*(void *)(v12 + 408) + 8 * (v10 & 0x7FFFFFFF));
      uint64_t v115 = v10;
      int v116 = v11;
      unsigned int v15 = 0;
      v127 = v129;
      uint64_t v128 = 0x400000000;
      unsigned int v123 = v125;
      uint64_t v124 = 0x800000000;
      unsigned int v126 = 0;
      do
      {
        uint64_t v16 = (void *)v4[31];
        v130 = v16;
        unint64_t v131 = v133;
        uint64_t v132 = 0x800000000;
        v133[8] = 0;
        uint64_t v134 = v14;
        unsigned int v135 = v15;
        int v17 = v128;
        int v18 = (char *)v127;
        if (v128 >= HIDWORD(v128))
        {
          unint64_t v28 = v128 + 1;
          BOOL v29 = v127 <= &v130 && (char *)v127 + 80 * v128 > (char *)&v130;
          int v30 = v29;
          unint64_t v31 = 0xCCCCCCCCCCCCCCCDLL * (((char *)&v130 - (unsigned char *)v127) >> 4);
          if (v30 != 1) {
            unint64_t v31 = -1;
          }
          if (v128 == -1) {
            sub_1CD0A88F0(v28);
          }
          unint64_t v119 = v31;
          if (HIDWORD(v128) == -1) {
            sub_1CD0A89A8(0xFFFFFFFFuLL);
          }
          unint64_t v32 = (2 * HIDWORD(v128)) | 1;
          if (v32 <= v28) {
            unint64_t v32 = v128 + 1;
          }
          if (v32 >= 0xFFFFFFFF) {
            uint64_t v33 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v33 = v32;
          }
          int v34 = (char *)malloc_type_malloc(80 * v33, 0x4065EBACuLL);
          if (!v34) {
            llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
          }
          int v18 = v34;
          uint64_t v35 = (char *)v127;
          if (v128)
          {
            int v117 = v33;
            int v118 = v30;
            uint64_t v36 = 0;
            uint64_t v120 = 80 * v128;
            do
            {
              uint64_t v37 = &v35[v36];
              unint64_t v38 = &v18[v36];
              *(void *)unint64_t v38 = *(void *)&v35[v36];
              int v39 = &v18[v36 + 24];
              *(void *)&v18[v36 + 8] = v39;
              *((void *)v38 + 2) = 0x800000000;
              unsigned int v40 = *(_DWORD *)&v35[v36 + 16];
              if (v40) {
                BOOL v41 = v37 == v38;
              }
              else {
                BOOL v41 = 1;
              }
              if (!v41)
              {
                uint64_t v42 = (char *)*((void *)v37 + 1);
                if (v37 + 24 == v42)
                {
                  uint64_t v43 = v35;
                  if (v40 >= 9) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v39, v42, 4 * *(unsigned int *)&v35[v36 + 16]);
                  *((_DWORD *)v38 + 4) = v40;
                  uint64_t v35 = v43;
                }
                else
                {
                  *(void *)&v18[v36 + 8] = v42;
                  *((_DWORD *)v38 + 4) = v40;
                  *((_DWORD *)v38 + 5) = *(_DWORD *)&v35[v36 + 20];
                  *((void *)v37 + 1) = v37 + 24;
                  *(_DWORD *)&v35[v36 + 20] = 0;
                }
                *((_DWORD *)v37 + 4) = 0;
              }
              *((_DWORD *)v38 + 14) = *((_DWORD *)v37 + 14);
              uint64_t v44 = *((void *)v37 + 8);
              *((_DWORD *)v38 + 18) = *((_DWORD *)v37 + 18);
              *((void *)v38 + 8) = v44;
              v36 += 80;
            }
            while (v120 != v36);
            uint64_t v35 = (char *)v127;
            if (v128)
            {
              uint64_t v45 = 80 * v128;
              int v30 = v118;
              LODWORD(v33) = v117;
              do
              {
                uint64_t v46 = *(char **)&v35[v45 - 72];
                if (&v35[v45 - 56] != v46)
                {
                  unsigned int v47 = v35;
                  free(v46);
                  uint64_t v35 = v47;
                }
                v45 -= 80;
              }
              while (v45);
              uint64_t v35 = (char *)v127;
              uint64_t v4 = v121;
            }
            else
            {
              uint64_t v4 = v121;
              int v30 = v118;
              LODWORD(v33) = v117;
            }
          }
          if (v35 != v129) {
            free(v35);
          }
          v127 = v18;
          HIDWORD(v128) = v33;
          if (v30) {
            uint64_t v19 = (void **)&v18[80 * v119];
          }
          else {
            uint64_t v19 = &v130;
          }
          uint64_t v20 = &v132;
          if (v30) {
            uint64_t v20 = (uint64_t *)&v18[80 * v119 + 16];
          }
          int v17 = v128;
          uint64_t v16 = *v19;
        }
        else
        {
          uint64_t v19 = &v130;
          uint64_t v20 = &v132;
        }
        int v21 = (void **)&v18[80 * v17];
        *int v21 = v16;
        v21[1] = v21 + 3;
        v21[2] = (void *)0x800000000;
        if (*(_DWORD *)v20 && v21 != v19)
        {
          uint64_t v22 = (void **)v19[1];
          if (v22 == v19 + 3)
          {
            int v23 = v19 + 2;
            unsigned int v24 = *((_DWORD *)v19 + 4);
            if (v24)
            {
              if (v24 >= 9) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (*((_DWORD *)v19 + 4)) {
                memcpy(v21[1], v19[1], 4 * *((unsigned int *)v19 + 4));
              }
              *((_DWORD *)v21 + 4) = v24;
            }
          }
          else
          {
            v21[1] = v22;
            int v23 = v19 + 2;
            v21[2] = v19[2];
            v19[1] = v19 + 3;
            *((_DWORD *)v19 + 5) = 0;
          }
          *int v23 = 0;
          uint64_t v4 = v121;
        }
        *((_DWORD *)v21 + 14) = *((_DWORD *)v19 + 14);
        int v25 = &v18[80 * v17];
        int v26 = v19[8];
        *((_DWORD *)v25 + 18) = *((_DWORD *)v19 + 18);
        *((void *)v25 + 8) = v26;
        unsigned int v27 = v128 + 1;
        LODWORD(v128) = v128 + 1;
        if (v131 != v133)
        {
          free(v131);
          unsigned int v27 = v128;
        }
        v15 += llvm::ConnectedVNInfoEqClasses::Classify((llvm::ConnectedVNInfoEqClasses *)((char *)v127 + 80 * v27 - 80), v14);
        int v14 = (const llvm::LiveRange *)*((void *)v14 + 13);
      }
      while (v14);
      if (v128 < 2)
      {
        int v11 = v116;
        uint64_t v9 = v114;
        uint64_t v10 = v115;
LABEL_164:
        if (v123 != v125) {
          free(v123);
        }
        uint64_t v110 = (char *)v127;
        if (v128)
        {
          uint64_t v111 = 80 * v128;
          do
          {
            int64x2_t v112 = *(char **)&v110[v111 - 72];
            if (&v110[v111 - 56] != v112) {
              free(v112);
            }
            v111 -= 80;
          }
          while (v111);
          uint64_t v110 = (char *)v127;
        }
        if (v110 != v129) {
          free(v110);
        }
        goto LABEL_174;
      }
      uint64_t v48 = *(void *)(*(void *)v4[32] + 16);
      uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 176))(v48);
      if (HIDWORD(v124) < v15) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unsigned int v50 = v124;
      while (v50 < v15)
      {
        if (v50 >= HIDWORD(v124)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v123 + v50) = v50;
        unsigned int v50 = v124 + 1;
        LODWORD(v124) = v124 + 1;
      }
      uint64_t v51 = *(unsigned int *)(v122 + 112);
      uint64_t v52 = v121[32];
      if ((v51 & 0x80000000) != 0) {
        int v53 = (int **)(*(void *)(v52 + 24) + 16 * (v51 & 0x7FFFFFFF) + 8);
      }
      else {
        int v53 = (int **)(*(void *)(v52 + 272) + 8 * v51);
      }
      int v11 = v116;
      uint64_t v9 = v114;
      uint64_t v10 = v115;
      uint64_t v54 = *v53;
      if (v54)
      {
        while (1)
        {
          unsigned int v55 = *v54;
          if ((*v54 & 0x80000000) == 0) {
            break;
          }
          uint64_t v54 = (int *)*((void *)v54 + 3);
          if (!v54) {
            goto LABEL_90;
          }
        }
        uint64_t v69 = (char *)v127;
LABEL_106:
        if (((v55 & 0x1000000) != 0 || (v55 & 0x30000000) == 0 && (v55 & 0x10FFF00) != 0x1000000) && v128)
        {
          uint64_t v70 = *(void *)(*(void *)(v49 + 232) + 8 * ((v55 >> 8) & 0xFFF));
          uint64_t v71 = &v69[80 * v128];
          uint64_t v72 = 0xFFFFFFFFLL;
          uint64_t v73 = v123;
          uint64_t v74 = v69;
          while (1)
          {
            uint64_t v75 = *((void *)v74 + 8);
            if ((*(void *)(v75 + 112) & v70) == 0) {
              goto LABEL_153;
            }
            unint64_t v76 = *((void *)v54 + 1);
            __int16 v77 = *(_WORD *)(v76 + 44);
            unint64_t v78 = v76;
            if ((v77 & 4) != 0)
            {
              do
                unint64_t v78 = *(void *)v78 & 0xFFFFFFFFFFFFFFF8;
              while ((*(_WORD *)(v78 + 44) & 4) != 0);
            }
            if ((v77 & 8) != 0)
            {
              do
                unint64_t v76 = *(void *)(v76 + 8);
              while ((*(_WORD *)(v76 + 44) & 8) != 0);
            }
            unint64_t v79 = *(void *)(v76 + 8);
            if (v78 != v79)
            {
              do
              {
                unsigned int v80 = **(unsigned __int16 **)(v78 + 16);
                BOOL v29 = v80 > 0x17;
                int v81 = (1 << v80) & 0x83E000;
                if (v29 || v81 == 0) {
                  goto LABEL_121;
                }
                unint64_t v78 = *(void *)(v78 + 8);
              }
              while (v78 != v79);
              unint64_t v78 = v79;
            }
LABEL_121:
            uint64_t v83 = *(void *)(v121[31] + 288);
            uint64_t v84 = *(void *)(v83 + 368);
            uint64_t v85 = *(unsigned int *)(v83 + 384);
            if (v85)
            {
              LODWORD(v86) = ((v78 >> 4) ^ (v78 >> 9)) & (v85 - 1);
              unsigned __int16 v87 = (uint64_t *)(v84 + 16 * v86);
              uint64_t v88 = *v87;
              if (v78 != *v87)
              {
                int v89 = 1;
                do
                {
                  if (v88 == -4096) {
                    goto LABEL_127;
                  }
                  int v90 = v86 + v89++;
                  uint64_t v86 = v90 & (v85 - 1);
                  uint64_t v88 = *(void *)(v84 + 16 * v86);
                }
                while (v78 != v88);
                unsigned __int16 v87 = (uint64_t *)(v84 + 16 * v86);
              }
            }
            else
            {
LABEL_127:
              unsigned __int16 v87 = (uint64_t *)(v84 + 16 * v85);
            }
            uint64_t v91 = v87[1];
            if ((*v54 & 0x1000000) != 0)
            {
              unint64_t v93 = v91 & 0xFFFFFFFFFFFFFFF8;
              uint64_t v94 = 2;
              if ((*v54 & 0x40000000) == 0) {
                uint64_t v94 = 4;
              }
              unint64_t v92 = v94 | v93;
            }
            else
            {
              unint64_t v92 = v91 & 0xFFFFFFFFFFFFFFF8;
            }
            unint64_t v95 = *(unsigned int *)(v75 + 8);
            uint64_t v96 = *(void **)v75;
            if (!v95) {
              break;
            }
            uint64_t v97 = v96[3 * v95 - 2];
            unsigned int v98 = *(_DWORD *)((v92 & 0xFFFFFFFFFFFFFFF8) + 24) | (v92 >> 1) & 3;
            unsigned int v99 = (v97 >> 1) & 3 | *(_DWORD *)((v97 & 0xFFFFFFFFFFFFFFF8) + 24);
            __int32 v100 = v96;
            unint64_t v101 = v95;
            if (v98 >= v99) {
              goto LABEL_143;
            }
            do
            {
              unint64_t v102 = v101 >> 1;
              uint64_t v103 = v100[3 * (v101 >> 1) + 1];
              LODWORD(v103) = (v103 >> 1) & 3 | *(_DWORD *)((v103 & 0xFFFFFFFFFFFFFFF8) + 24);
              v101 -= (v101 >> 1) + 1;
              BOOL v104 = v98 >= v103;
              if (v98 >= v103) {
                unint64_t v105 = v102 + 1;
              }
              else {
                unint64_t v105 = 0;
              }
              v100 += 3 * v105;
              if (!v104) {
                unint64_t v101 = v102;
              }
            }
            while (v101);
LABEL_144:
            if (v100 != &v96[3 * v95]
              && ((*v100 >> 1) & 3 | *(_DWORD *)((*v100 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((v92 & 0xFFFFFFFFFFFFFFF8) + 24) | (v92 >> 1) & 3))
            {
              unsigned int v106 = (unsigned int *)v100[2];
              if (v106)
              {
                unsigned int v107 = *((_DWORD *)v74 + 18) + *(_DWORD *)(*((void *)v74 + 1) + 4 * *v106);
                if (v72 == -1)
                {
                  uint64_t v108 = (*((_DWORD *)v74 + 18) + *(_DWORD *)(*((void *)v74 + 1) + 4 * *v106));
                }
                else
                {
                  uint64_t v108 = v73[v72];
                  unsigned int v109 = v73[v107];
                  while (v108 != v109)
                  {
                    if (v108 < v109)
                    {
                      v73[v107] = v108;
                      unsigned int v107 = v109;
                      unsigned int v109 = v73[v109];
                    }
                    else
                    {
                      v73[v72] = v109;
                      LODWORD(v72) = v108;
                      uint64_t v108 = v73[v108];
                    }
                  }
                }
                goto LABEL_154;
              }
            }
LABEL_153:
            uint64_t v108 = v72;
LABEL_154:
            v74 += 80;
            uint64_t v72 = v108;
            if (v74 == v71) {
              goto LABEL_161;
            }
          }
          LODWORD(v95) = 0;
LABEL_143:
          __int32 v100 = &v96[3 * v95];
          goto LABEL_144;
        }
LABEL_161:
        while (1)
        {
          uint64_t v54 = (int *)*((void *)v54 + 3);
          if (!v54) {
            break;
          }
          unsigned int v55 = *v54;
          if ((*v54 & 0x80000000) == 0) {
            goto LABEL_106;
          }
        }
      }
LABEL_90:
      unsigned int v56 = v126;
      if (!v126)
      {
        uint64_t v57 = v124;
        if (!v124) {
          goto LABEL_164;
        }
        uint64_t v58 = 0;
        int v59 = v123;
        do
        {
          uint64_t v60 = v59[v58];
          if (v58 == v60) {
            unsigned int v61 = v126++;
          }
          else {
            unsigned int v61 = v59[v60];
          }
          v59[v58++] = v61;
        }
        while (v57 != v58);
        unsigned int v56 = v126;
      }
      if (v56 >= 2)
      {
        unint64_t v62 = *(void *)(*(void *)(v52 + 24) + 16 * (*(_DWORD *)(v122 + 112) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
        uint64_t v63 = v121[32];
        unint64_t v64 = llvm::MachineRegisterInfo::createIncompleteVirtualRegister(v63, "", 0) & 0x7FFFFFFF;
        *(void *)(*(void *)(v63 + 24) + 16 * v64) = v62;
        uint64_t v65 = *(void *)(v63 + 8);
        if (v65) {
          (*(void (**)(uint64_t))(*(void *)v65 + 24))(v65);
        }
        uint64_t v66 = v121[31];
        unint64_t v67 = *(unsigned int *)(v66 + 416);
        BOOL v104 = v64 >= v67;
        unint64_t v68 = v64 - v67;
        if (v104) {
          sub_1CB9153B8(v66 + 408, v68 + 1, *(void *)(v66 + 424));
        }
        operator new();
      }
      goto LABEL_164;
    }
  }
  LOBYTE(v11) = 0;
  return v11 & 1;
}

uint64_t llvm::stableHashValue(llvm *this, const llvm::MachineBasicBlock *a2)
{
  v13[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0xCBF29CE484222325;
  unsigned int v12 = 0;
  unsigned int v3 = (char *)this + 48;
  uint64_t v4 = *((void *)this + 7);
  if ((llvm *)v4 != (llvm *)((char *)this + 48))
  {
    do
    {
      uint64_t v5 = llvm::stableHashValue((llvm *)v4, 0, 0, 0);
      if (v12 >= 6uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v13[v12] = v5;
      int v6 = ++v12;
      if ((*(unsigned char *)v4 & 4) == 0)
      {
        while ((*(_WORD *)(v4 + 44) & 8) != 0)
          uint64_t v4 = *(void *)(v4 + 8);
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while ((char *)v4 != v3);
    if (v6)
    {
      uint64_t v7 = &v13[v6];
      uint64_t v8 = v13;
      do
      {
        unint64_t v9 = *v8;
        int v10 = 8;
        do
        {
          uint64_t v2 = 0x100000001B3 * (v9 ^ (unint64_t)v2);
          v9 >>= 8;
          --v10;
        }
        while (v10);
        ++v8;
      }
      while (v8 != v7);
    }
  }
  return v2;
}

uint64_t llvm::stableHashValue(llvm *this, const llvm::MachineFunction *a2)
{
  v13[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0xCBF29CE484222325;
  unsigned int v12 = 0;
  unsigned int v3 = (llvm *)((char *)this + 320);
  uint64_t v4 = (llvm *)*((void *)this + 41);
  if (v4 != (llvm *)((char *)this + 320))
  {
    do
    {
      uint64_t v5 = llvm::stableHashValue(v4, a2);
      if (v12 >= 6uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v13[v12] = v5;
      int v6 = ++v12;
      uint64_t v4 = (llvm *)*((void *)v4 + 1);
    }
    while (v4 != v3);
    if (v6)
    {
      uint64_t v7 = &v13[v6];
      uint64_t v8 = v13;
      do
      {
        unint64_t v9 = *v8;
        int v10 = 8;
        do
        {
          uint64_t v2 = 0x100000001B3 * (v9 ^ (unint64_t)v2);
          v9 >>= 8;
          --v10;
        }
        while (v10);
        ++v8;
      }
      while (v8 != v7);
    }
  }
  return v2;
}

uint64_t llvm::VRegRenamer::createVirtualRegister(llvm::VRegRenamer *this, unsigned int a2)
{
  uint64_t v4 = *(void *)this;
  if ((a2 & 0x80000000) != 0) {
    uint64_t v5 = (uint64_t *)(*(void *)(v4 + 24) + 16 * (a2 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v5 = (uint64_t *)(*(void *)(v4 + 272) + 8 * a2);
  }
  uint64_t v6 = *v5;
  if ((*(unsigned char *)(v6 + 3) & 1) == 0) {
    uint64_t v6 = *(void *)(v6 + 24);
  }
  llvm::VRegRenamer::getInstructionOpcodeHash(this, *(llvm::MachineInstr **)(v6 + 8), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t VirtualRegisterWithLowerName = llvm::VRegRenamer::createVirtualRegisterWithLowerName((uint64_t *)this, a2, (uint64_t)p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return VirtualRegisterWithLowerName;
}

void *sub_1CC44CD14(llvm::StringMapImpl *a1, unsigned __int8 *a2, size_t __n)
{
  unsigned int v5 = *((_DWORD *)a1 + 2);
  if (!v5)
  {
    *((_DWORD *)a1 + 3) = 0;
    *((_DWORD *)a1 + 4) = 0;
    int v25 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
    if (!v25) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    v25[16] = 2;
    *(void *)a1 = v25;
    unsigned int v5 = 16;
    *((_DWORD *)a1 + 2) = 16;
  }
  int v6 = 0;
  if (__n)
  {
    size_t v7 = __n;
    uint64_t v8 = a2;
    do
    {
      int v9 = *v8++;
      int v6 = 33 * v6 + v9;
      --v7;
    }
    while (v7);
  }
  uint64_t v10 = *(void *)a1;
  unsigned int v11 = v5 - 1;
  uint64_t v12 = *(void *)a1 + 8 * v5 + 8;
  int v13 = -1;
  int v14 = 1;
  int v15 = v6;
  while (1)
  {
    uint64_t v16 = v15 & v11;
    int v17 = *(void **)(v10 + 8 * v16);
    if (!v17) {
      break;
    }
    if (v17 == (void *)-8)
    {
      if (v13 == -1) {
        int v13 = v15 & v11;
      }
    }
    else if (*(_DWORD *)(v12 + 4 * v16) == v6 {
           && __n == *v17
    }
           && (!__n || !memcmp(a2, (char *)v17 + *((unsigned int *)a1 + 5), __n)))
    {
      goto LABEL_17;
    }
    int v15 = v14 + v16;
    ++v14;
  }
  uint64_t v18 = v13;
  if (v13 == -1)
  {
    uint64_t v18 = v16;
    uint64_t v16 = v16;
  }
  else
  {
    uint64_t v16 = v13;
  }
  *(_DWORD *)(v12 + 4 * v18) = v6;
  int v17 = *(void **)(v10 + 8 * v16);
LABEL_17:
  uint64_t i = (void *)(v10 + 8 * v16);
  if (v17)
  {
    if (v17 != (void *)-8) {
      return i;
    }
    --*((_DWORD *)a1 + 4);
  }
  uint64_t v20 = (char *)operator new(__n + 17, (std::align_val_t)8uLL);
  int v21 = v20;
  uint64_t v22 = v20 + 16;
  if (__n) {
    memcpy(v20 + 16, a2, __n);
  }
  v22[__n] = 0;
  *(void *)int v21 = __n;
  *((_DWORD *)v21 + 2) = 0;
  *uint64_t i = v21;
  ++*((_DWORD *)a1 + 3);
  for (uint64_t i = (void *)(*(void *)a1 + 8 * llvm::StringMapImpl::RehashTable(a1, v16));
        !*i || *i == -8;
  return i;
}

char *sub_1CC44CF1C(int64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = (a1->i64[1] - a1->i64[0]) >> 5;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 59) {
    abort();
  }
  uint64_t v6 = a1[1].i64[0] - a1->i64[0];
  if (v6 >> 4 > v3) {
    unint64_t v3 = v6 >> 4;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v7 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v22 = a1 + 1;
  if (v7)
  {
    if (v7 >> 59) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(32 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v9 = &v8[32 * v2];
  *(_DWORD *)int v9 = *(_DWORD *)a2;
  *(_OWORD *)(v9 + 8) = *(_OWORD *)(a2 + 8);
  *((void *)v9 + 3) = *(void *)(a2 + 24);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 8) = 0;
  uint64_t v11 = a1->i64[0];
  unint64_t v10 = a1->u64[1];
  if (v10 == a1->i64[0])
  {
    int64x2_t v12 = vdupq_n_s64(v10);
    int v13 = &v8[32 * v2];
  }
  else
  {
    int v13 = &v8[32 * v2];
    do
    {
      int v14 = *(_DWORD *)(v10 - 32);
      v10 -= 32;
      *((_DWORD *)v13 - 8) = v14;
      v13 -= 32;
      long long v15 = *(_OWORD *)(v10 + 8);
      *((void *)v13 + 3) = *(void *)(v10 + 24);
      *(_OWORD *)(v13 + 8) = v15;
      *(void *)(v10 + 16) = 0;
      *(void *)(v10 + 24) = 0;
      *(void *)(v10 + 8) = 0;
    }
    while (v10 != v11);
    int64x2_t v12 = *a1;
  }
  uint64_t v16 = v9 + 32;
  a1->i64[0] = (uint64_t)v13;
  a1->i64[1] = (uint64_t)(v9 + 32);
  int64x2_t v20 = v12;
  uint64_t v17 = a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)&v8[32 * v7];
  uint64_t v21 = v17;
  uint64_t v19 = v12.i64[0];
  sub_1CD4FF274((uint64_t)&v19);
  return v16;
}

uint64_t sub_1CC44D050()
{
  char v3 = 0;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Use Stable Hashing for MIR VReg Renaming";
  v1.n128_u64[1] = 40;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCD3260, "mir-vreg-namer-use-stable-hash", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3260, &dword_1CB82C000);
}

void sub_1CC44D0DC()
{
}

void sub_1CC44D178()
{
}

void sub_1CC44D21C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  __n128 v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    unsigned int v5 = a1;
    free(v2);
    a1 = v5;
  }
  char v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC44D2D0(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC44D37C()
{
  return "Rename virtual register operands";
}

void sub_1CC44D38C(llvm::PassRegistry *a1, uint64_t a2)
{
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC44D400(uint64_t a1, void *a2)
{
  if ((void *)a2[40] == a2 + 40)
  {
    LOBYTE(v2) = 0;
    return v2 & 1;
  }
  uint64_t v4 = a2[5];
  uint64_t v13 = 0;
  uint64_t v14 = v4;
  int v15 = 0;
  uint64_t v10 = a2[41];
  std::string __p = 0;
  int64x2_t v12 = 0;
  sub_1CD50D084((char **)&__p, &v10);
  uint64_t v6 = (char *)__p;
  unsigned int v5 = v12;
  if (v12 == __p)
  {
    LOBYTE(v2) = 0;
    if (!v12) {
      return v2 & 1;
    }
LABEL_10:
    int64x2_t v12 = v5;
    operator delete(v5);
    return v2 & 1;
  }
  int v2 = 0;
  int v7 = 0;
  do
  {
    uint64_t v8 = (llvm::MachineBasicBlock *)*((void *)v5 - 1);
    v5 -= 8;
    int v9 = v7 + 1;
    int v15 = v7;
    v2 |= llvm::VRegRenamer::renameInstsInMBB((llvm::VRegRenamer *)&v14, v8);
    int v7 = v9;
  }
  while (v5 != v6);
  unsigned int v5 = (char *)__p;
  if (__p) {
    goto LABEL_10;
  }
  return v2 & 1;
}

void sub_1CC44D4C4()
{
}

void sub_1CC44D560()
{
}

void sub_1CC44D604(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  __n128 v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    unsigned int v5 = a1;
    free(v2);
    a1 = v5;
  }
  char v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC44D6B8(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC44D764()
{
  return "Rename register operands in a canonical ordering.";
}

void sub_1CC44D774(llvm::PassRegistry *a1, uint64_t a2)
{
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC44D7E8(uint64_t a1, void *a2)
{
  uint64_t v212 = *MEMORY[0x1E4F143B8];
  if (dword_1EBCD33B8 == -1)
  {
    if ((void *)a2[40] != a2 + 40) {
      goto LABEL_10;
    }
LABEL_7:
    char v5 = 0;
    return v5 & 1;
  }
  int v3 = dword_1EBCD3330++;
  BOOL v4 = dword_1EBCD33B8 != v3 || a2[40] == (void)(a2 + 40);
  if (v4) {
    goto LABEL_7;
  }
LABEL_10:
  v206[0] = a2[41];
  v209 = 0;
  uint64_t v210 = 0;
  v208 = 0;
  sub_1CD50D084((char **)&v208, v206);
  uint64_t v8 = v208;
  int v7 = v209;
  int64_t v9 = (char *)v209 - (char *)v208;
  if ((char *)v209 - (char *)v208 < 1)
  {
    v187 = 0;
    v188 = 0;
    if (!v208) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v10 = (char *)operator new((char *)v209 - (char *)v208);
    uint64_t v11 = 0;
    v187 = (uint64_t *)&v10[v9 & 0xFFFFFFFFFFFFFFF8];
    int64x2_t v12 = v7 - 1;
    do
    {
      uint64_t v13 = *v12--;
      *(void *)&v10[v11] = v13;
      v11 += 8;
    }
    while ((v9 & 0xFFFFFFFFFFFFFFF8) != v11);
    v188 = (uint64_t *)v10;
    if (!v8) {
      goto LABEL_15;
    }
  }
  v209 = v8;
  operator delete(v8);
LABEL_15:
  uint64_t v199 = a2[5];
  int v200 = 0;
  uint64_t v14 = v188;
  if (v188 == v187)
  {
    char v190 = 0;
    goto LABEL_338;
  }
  int v193 = 0;
  char v190 = 0;
  int v15 = v188;
  do
  {
    uint64_t v16 = *v15;
    uint64_t v17 = *v15 + 48;
    uint64_t v18 = *(void *)(*v15 + 56);
    uint64_t v198 = v17;
    v186 = v15;
    v189 = (llvm::MachineBasicBlock *)*v15;
    if (v18 == v17)
    {
      char v185 = 0;
    }
    else
    {
      uint64_t v19 = 0;
      int64x2_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = *(void **)(*(void *)(v16 + 32) + 40);
      do
      {
        if (**(_WORD **)(v18 + 16) == 19)
        {
          if (v20 >= v21)
          {
            uint64_t v23 = (v20 - v19) >> 3;
            unint64_t v24 = v23 + 1;
            if ((unint64_t)(v23 + 1) >> 61) {
              goto LABEL_341;
            }
            if ((v21 - v19) >> 2 > v24) {
              unint64_t v24 = (v21 - v19) >> 2;
            }
            if ((unint64_t)(v21 - v19) >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v25 = v24;
            }
            if (v25)
            {
              if (v25 >> 61) {
LABEL_342:
              }
                sub_1CB833614();
              int v26 = (char *)operator new(8 * v25);
            }
            else
            {
              int v26 = 0;
            }
            unsigned int v27 = &v26[8 * v23];
            *(void *)unsigned int v27 = v18;
            unint64_t v28 = v27 + 8;
            while (v20 != v19)
            {
              uint64_t v29 = *((void *)v20 - 1);
              v20 -= 8;
              *((void *)v27 - 1) = v29;
              v27 -= 8;
            }
            uint64_t v21 = &v26[8 * v25];
            if (v19) {
              operator delete(v19);
            }
            int64x2_t v20 = v28;
            uint64_t v19 = v27;
            uint64_t v17 = v198;
          }
          else
          {
            *(void *)int64x2_t v20 = v18;
            v20 += 8;
          }
        }
        uint64_t v18 = *(void *)(v18 + 8);
      }
      while (v18 != v17);
      if (v19 == v20)
      {
        char v30 = 0;
      }
      else
      {
        char v30 = 0;
        uint64_t v151 = (llvm::MachineInstr **)v19;
        __srcb = v22;
        do
        {
          uint64_t v152 = *v151;
          uint64_t v153 = *((void *)*v151 + 4);
          if (!*(unsigned char *)v153 && !*(unsigned char *)(v153 + 32))
          {
            int v154 = *(_DWORD *)(v153 + 4);
            if (v154 < 0)
            {
              unsigned int v155 = *(_DWORD *)(v153 + 36);
              if ((v155 & 0x80000000) != 0)
              {
                uint64_t v156 = v154 & 0x7FFFFFFF;
                uint64_t v157 = v22[3];
                uint64_t v158 = *(void *)(v157 + 16 * v156);
                if ((v158 & 4) == 0)
                {
                  unint64_t v159 = v158 & 0xFFFFFFFFFFFFFFF8;
                  if (v159)
                  {
                    if (v159 == (*(void *)(v157 + 16 * (v155 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8))
                    {
                      uint64_t v160 = *(void *)(v157 + 16 * v156 + 8);
                      if (v160)
                      {
                        while ((*(unsigned char *)(v160 + 3) & 1) != 0)
                        {
                          uint64_t v160 = *(void *)(v160 + 24);
                          if (!v160) {
                            goto LABEL_302;
                          }
                        }
                        v161 = 0;
                        v162 = 0;
                        v163 = 0;
LABEL_304:
                        if (v162 >= v163)
                        {
                          uint64_t v165 = (v162 - v161) >> 3;
                          unint64_t v166 = v165 + 1;
                          if ((unint64_t)(v165 + 1) >> 61) {
                            goto LABEL_341;
                          }
                          unint64_t v167 = v163 - v161;
                          unint64_t v168 = (v163 - v161) >> 2;
                          if (v168 > v166) {
                            unint64_t v166 = v168;
                          }
                          BOOL v169 = v167 >= 0x7FFFFFFFFFFFFFF8;
                          unint64_t v170 = 0x1FFFFFFFFFFFFFFFLL;
                          if (!v169) {
                            unint64_t v170 = v166;
                          }
                          unint64_t v192 = v170;
                          if (v170)
                          {
                            if (v170 >> 61) {
                              goto LABEL_342;
                            }
                            v171 = (char *)operator new(8 * v170);
                          }
                          else
                          {
                            v171 = 0;
                          }
                          v172 = &v171[8 * v165];
                          *(void *)v172 = v160;
                          v164 = v172 + 8;
                          if (v162 == v161)
                          {
                            unint64_t v173 = v192;
                          }
                          else
                          {
                            unint64_t v173 = v192;
                            do
                            {
                              uint64_t v174 = *((void *)v162 - 1);
                              v162 -= 8;
                              *((void *)v172 - 1) = v174;
                              v172 -= 8;
                            }
                            while (v162 != v161);
                          }
                          v163 = &v171[8 * v173];
                          if (v161)
                          {
                            v175 = v161;
                            v176 = v163;
                            operator delete(v175);
                            v163 = v176;
                          }
                          v161 = v172;
                        }
                        else
                        {
                          *(void *)v162 = v160;
                          v164 = v162 + 8;
                        }
                        uint64_t v22 = __srcb;
                        while (1)
                        {
                          uint64_t v160 = *(void *)(v160 + 24);
                          if (!v160) {
                            break;
                          }
                          if ((*(unsigned char *)(v160 + 3) & 1) == 0)
                          {
                            v162 = v164;
                            goto LABEL_304;
                          }
                        }
                        v177 = (uint64_t *)v161;
                        if (v161 != v164)
                        {
                          do
                          {
                            uint64_t v178 = *v177++;
                            llvm::MachineOperand::setReg(v178, v155);
                          }
                          while (v177 != (uint64_t *)v164);
                        }
                        llvm::MachineInstr::eraseFromParent(v152);
                        if (v161) {
                          operator delete(v161);
                        }
                        char v30 = 1;
                        uint64_t v17 = v198;
                      }
                      else
                      {
LABEL_302:
                        llvm::MachineInstr::eraseFromParent(*v151);
                        char v30 = 1;
                      }
                    }
                  }
                }
              }
            }
          }
          ++v151;
        }
        while (v151 != (llvm::MachineInstr **)v20);
      }
      char v185 = v30;
      if (v19) {
        operator delete(v19);
      }
      uint64_t v16 = (uint64_t)v189;
    }
    uint64_t v205 = v16;
    uint64_t v31 = *(void *)(v16 + 56);
    if (v31 != v17)
    {
      int v34 = 0;
      uint64_t v33 = 0;
      unint64_t v32 = 0;
      while (1)
      {
        if (v33 >= v34)
        {
          uint64_t v35 = (v33 - v32) >> 3;
          unint64_t v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 61) {
            goto LABEL_341;
          }
          if ((v34 - v32) >> 2 > v36) {
            unint64_t v36 = (v34 - v32) >> 2;
          }
          if ((unint64_t)(v34 - v32) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v36;
          }
          if (v37)
          {
            if (v37 >> 61) {
              goto LABEL_342;
            }
            unint64_t v38 = (char *)operator new(8 * v37);
          }
          else
          {
            unint64_t v38 = 0;
          }
          int v39 = &v38[8 * v35];
          *(void *)int v39 = v31;
          unsigned int v40 = v39 + 8;
          if (v33 != v32)
          {
            do
            {
              uint64_t v41 = *((void *)v33 - 1);
              v33 -= 8;
              *((void *)v39 - 1) = v41;
              v39 -= 8;
            }
            while (v33 != v32);
            uint64_t v33 = v32;
          }
          unint64_t v32 = v39;
          int v34 = &v38[8 * v37];
          if (v33) {
            operator delete(v33);
          }
          uint64_t v33 = v40;
          if (!v31)
          {
LABEL_70:
            while ((*(_WORD *)(v31 + 44) & 8) != 0)
              uint64_t v31 = *(void *)(v31 + 8);
            goto LABEL_71;
          }
        }
        else
        {
          *(void *)uint64_t v33 = v31;
          v33 += 8;
          if (!v31) {
            goto LABEL_70;
          }
        }
        if ((*(unsigned char *)v31 & 4) == 0) {
          goto LABEL_70;
        }
LABEL_71:
        uint64_t v31 = *(void *)(v31 + 8);
        if (v31 == v17) {
          goto LABEL_72;
        }
      }
    }
    unint64_t v32 = 0;
    uint64_t v33 = 0;
LABEL_72:
    v204[0] = 0;
    v204[1] = 0;
    v203 = (uint64_t *)v204;
    v202[0] = 0;
    v202[1] = 0;
    v201 = (uint64_t *)v202;
    v191 = v32;
    uint64_t v42 = 0;
    if (v32 != v33)
    {
      uint64_t v46 = v32;
      unsigned int v47 = 0;
      uint64_t v48 = 0;
      do
      {
        uint64_t v49 = *(void *)v46;
        if (*(_DWORD *)(*(void *)v46 + 40) >= 2u)
        {
          unint64_t v50 = 1;
          uint64_t v51 = v47;
          while (1)
          {
            uint64_t v52 = *(void *)(v49 + 32);
            if (*(_DWORD *)(v52 + 32 * v50)) {
              goto LABEL_78;
            }
            if ((*(_DWORD *)(v52 + 32 * v50) & 0x1000000) == 0) {
              goto LABEL_78;
            }
            int v53 = *(_DWORD *)(v52 + 32 * v50 + 4);
            if (v53 < 0) {
              goto LABEL_78;
            }
            if (v51 < v48) {
              break;
            }
            uint64_t v54 = (v51 - v42) >> 2;
            unint64_t v55 = v54 + 1;
            if ((unint64_t)(v54 + 1) >> 62) {
              goto LABEL_341;
            }
            if ((v48 - v42) >> 1 > v55) {
              unint64_t v55 = (v48 - v42) >> 1;
            }
            if ((unint64_t)(v48 - v42) >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v56 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v56 = v55;
            }
            if (v56)
            {
              if (v56 >> 62) {
                goto LABEL_342;
              }
              uint64_t v57 = (char *)operator new(4 * v56);
            }
            else
            {
              uint64_t v57 = 0;
            }
            uint64_t v58 = &v57[4 * v54];
            *(_DWORD *)uint64_t v58 = v53;
            unsigned int v47 = v58 + 4;
            while (v51 != v42)
            {
              int v59 = *((_DWORD *)v51 - 1);
              v51 -= 4;
              *((_DWORD *)v58 - 1) = v59;
              v58 -= 4;
            }
            uint64_t v48 = &v57[4 * v56];
            if (v42) {
              operator delete(v42);
            }
            uint64_t v42 = v58;
LABEL_79:
            ++v50;
            uint64_t v51 = v47;
            if (v50 >= *(unsigned int *)(v49 + 40)) {
              goto LABEL_101;
            }
          }
          *(_DWORD *)uint64_t v51 = v53;
          v51 += 4;
LABEL_78:
          unsigned int v47 = v51;
          goto LABEL_79;
        }
LABEL_101:
        v46 += 8;
      }
      while (v46 != v33);
      uint64_t v45 = 0;
      unsigned int v184 = 0;
      uint64_t v44 = 0;
      uint64_t v43 = 0;
      uint64_t v60 = 0;
      unsigned int v61 = (uint64_t *)v191;
      while (1)
      {
        uint64_t v62 = *v61;
        uint64_t v63 = *(unsigned int *)(*v61 + 40);
        if (!v63) {
          goto LABEL_114;
        }
        unint64_t v64 = *(unsigned __int16 **)(v62 + 16);
        unsigned int v65 = *v64 - 1;
        if (v65 <= 1 && (*(unsigned char *)(*(void *)(v62 + 32) + 48) & 8) != 0) {
          goto LABEL_114;
        }
        unsigned int v66 = *(unsigned __int16 *)(v62 + 44);
        BOOL v4 = (v66 & 0xC) == 0;
        int v67 = (v66 >> 2) & 1;
        if (v4) {
          LOBYTE(v67) = 1;
        }
        uint64_t v68 = *((void *)v64 + 1);
        if (v67)
        {
          if ((v68 & 0x80000) != 0) {
            goto LABEL_114;
          }
        }
        else
        {
          int v118 = v60;
          unint64_t v119 = v44;
          uint64_t v120 = v45;
          uint64_t v121 = *v61;
          if ((v68 & 0x80000) != 0)
          {
LABEL_227:
            uint64_t v45 = v120;
            uint64_t v44 = v119;
            uint64_t v60 = v118;
            goto LABEL_114;
          }
          while (1)
          {
            uint64_t v45 = v120;
            uint64_t v44 = v119;
            uint64_t v60 = v118;
            if ((*(_WORD *)(v121 + 44) & 8) == 0) {
              break;
            }
            uint64_t v121 = *(void *)(v121 + 8);
            if ((*(unsigned char *)(*(void *)(v121 + 16) + 10) & 8) != 0) {
              goto LABEL_227;
            }
          }
        }
        if (v65 <= 1 && (*(unsigned char *)(*(void *)(v62 + 32) + 48) & 0x10) != 0) {
          goto LABEL_114;
        }
        if (v67)
        {
          if ((v68 & 0x100000) != 0) {
            goto LABEL_114;
          }
        }
        else
        {
          uint64_t v122 = v60;
          unsigned int v123 = v44;
          uint64_t v124 = v45;
          uint64_t v125 = *v61;
          if ((v68 & 0x100000) != 0)
          {
LABEL_228:
            uint64_t v45 = v124;
            uint64_t v44 = v123;
            uint64_t v60 = v122;
            goto LABEL_114;
          }
          while (1)
          {
            uint64_t v45 = v124;
            uint64_t v44 = v123;
            uint64_t v60 = v122;
            if ((*(_WORD *)(v125 + 44) & 8) == 0) {
              break;
            }
            uint64_t v125 = *(void *)(v125 + 8);
            if ((*(unsigned char *)(*(void *)(v125 + 16) + 10) & 0x10) != 0) {
              goto LABEL_228;
            }
          }
        }
        uint64_t v69 = *(_DWORD **)(v62 + 32);
        if (!*v69 && (*v69 & 0x1000000) != 0)
        {
          int v70 = v69[1];
          if (v70 < 0)
          {
            if (v63 < 2)
            {
LABEL_130:
              if (v43 >= v60)
              {
                uint64_t v74 = (v43 - v44) >> 3;
                unint64_t v75 = v74 + 1;
                if ((unint64_t)(v74 + 1) >> 61) {
                  goto LABEL_341;
                }
                if ((v60 - v44) >> 2 > v75) {
                  unint64_t v75 = (v60 - v44) >> 2;
                }
                if ((unint64_t)(v60 - v44) >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v76 = v75;
                }
                if (v76)
                {
                  if (v76 >> 61) {
                    goto LABEL_342;
                  }
                  __int16 v77 = v44;
                  unint64_t v78 = (char *)operator new(8 * v76);
                  uint64_t v44 = v77;
                }
                else
                {
                  unint64_t v78 = 0;
                }
                unint64_t v101 = &v78[8 * v74];
                *(void *)unint64_t v101 = v62;
                unint64_t v102 = v101 + 8;
                while (v43 != v44)
                {
                  uint64_t v103 = *((void *)v43 - 1);
                  v43 -= 8;
                  *((void *)v101 - 1) = v103;
                  v101 -= 8;
                }
                uint64_t v60 = &v78[8 * v76];
                if (v44)
                {
                  BOOL v104 = &v78[8 * v76];
                  operator delete(v44);
                  uint64_t v60 = v104;
                }
                uint64_t v43 = v102;
                uint64_t v44 = v101;
              }
              else
              {
                *(void *)uint64_t v43 = v62;
                v43 += 8;
              }
            }
            else
            {
              uint64_t v71 = 1;
              while (1)
              {
                if (LOBYTE(v69[8 * v71]) != 1)
                {
                  if (LOBYTE(v69[8 * v71])) {
                    break;
                  }
                  int v72 = v69[8 * v71 + 1];
                  if (v72 < 0) {
                    break;
                  }
                  uint64_t v73 = v47;
                  if (v42 != v47)
                  {
                    uint64_t v73 = v42;
                    while (*(_DWORD *)v73 != v72)
                    {
                      v73 += 4;
                      if (v73 == v47)
                      {
                        uint64_t v73 = v47;
                        break;
                      }
                    }
                  }
                  if (v73 != v47) {
                    break;
                  }
                }
                if (++v71 == v63) {
                  goto LABEL_130;
                }
              }
              v208 = 0;
              uint64_t v79 = v205;
              uint64_t v80 = *(void *)(*(void *)(*(void *)(*(void *)(v205 + 32) + 40) + 24)
                              + 16 * (v70 & 0x7FFFFFFF)
                              + 8);
              if (v80)
              {
                while ((*(_DWORD *)v80 & 0x81000000) != 0)
                {
                  uint64_t v80 = *(void *)(v80 + 24);
                  if (!v80) {
                    goto LABEL_144;
                  }
                }
                uint64_t v83 = 0;
                unsigned int v84 = -1;
LABEL_146:
                uint64_t v85 = *(void *)(v62 + 24);
                uint64_t v86 = *(void *)(v85 + 56);
                if (v86 == v85 + 48)
                {
LABEL_155:
                  unsigned int v88 = -1;
                }
                else
                {
                  unsigned int v87 = 0;
                  while (1)
                  {
                    unsigned int v88 = v87;
                    if (v86 == v62) {
                      break;
                    }
                    ++v87;
                    if (!v86 || (*(unsigned char *)v86 & 4) == 0)
                    {
                      while ((*(_WORD *)(v86 + 44) & 8) != 0)
                        uint64_t v86 = *(void *)(v86 + 8);
                    }
                    uint64_t v86 = *(void *)(v86 + 8);
                    if (v86 == v85 + 48) {
                      goto LABEL_155;
                    }
                  }
                }
                int64x2_t v82 = *(uint64_t **)(v80 + 8);
                uint64_t v89 = v82[3];
                uint64_t v90 = *(void *)(v89 + 56);
                if (v90 == v89 + 48)
                {
LABEL_165:
                  unsigned int v92 = -1;
                }
                else
                {
                  unsigned int v91 = 0;
                  while (1)
                  {
                    unsigned int v92 = v91;
                    if ((uint64_t *)v90 == v82) {
                      break;
                    }
                    ++v91;
                    if (!v90 || (*(unsigned char *)v90 & 4) == 0)
                    {
                      while ((*(_WORD *)(v90 + 44) & 8) != 0)
                        uint64_t v90 = *(void *)(v90 + 8);
                    }
                    uint64_t v90 = *(void *)(v90 + 8);
                    if (v90 == v89 + 48) {
                      goto LABEL_165;
                    }
                  }
                }
                if (v89 == v85 && v92 > v88 && (unsigned int v93 = v92 - v88, v92 - v88 < v84))
                {
                  unsigned int __srcc = v45;
                  LODWORD(v206[0]) = v184;
                  uint64_t v94 = v44;
                  v182 = v60;
                  unint64_t v95 = sub_1CD4F3FDC(&v201, v184, v206);
                  uint64_t v60 = v182;
                  uint64_t v44 = v94;
                  v95[5] = v82;
                  unsigned int v84 = v93;
                  ++v184;
                  uint64_t v45 = __srcc;
                }
                else
                {
                  int64x2_t v82 = v83;
                }
                while (1)
                {
                  uint64_t v80 = *(void *)(v80 + 24);
                  if (!v80) {
                    break;
                  }
                  if ((*(_DWORD *)v80 & 0x81000000) == 0)
                  {
                    uint64_t v83 = v82;
                    goto LABEL_146;
                  }
                }
                uint64_t v81 = v45;
                v208 = v82;
                uint64_t v79 = v205;
              }
              else
              {
LABEL_144:
                uint64_t v81 = v45;
                int64x2_t v82 = 0;
              }
              uint64_t v96 = (unint64_t *)(v79 + 48);
              uint64_t v97 = *(uint64_t **)(v79 + 56);
              if (v97 != (uint64_t *)v96)
              {
                unsigned int v98 = v96;
                unsigned int v99 = v96;
                do
                {
                  if (v98 != v96 && v99 != v96) {
                    break;
                  }
                  __int32 v100 = v97 == v82 ? (unint64_t *)v97 : v99;
                  if (v97 == (uint64_t *)v62) {
                    unsigned int v98 = (unint64_t *)v97;
                  }
                  else {
                    unsigned int v99 = v100;
                  }
                  uint64_t v97 = (uint64_t *)v97[1];
                }
                while (v97 != (uint64_t *)v96);
                if (v98 != v96 && v99 != v96)
                {
                  v183 = v60;
                  __src = v44;
                  unint64_t v105 = sub_1CD4F40F4(&v203, (unint64_t)v82, &v208);
                  unsigned int v106 = v105;
                  uint64_t v108 = v105[6];
                  unsigned int v107 = v105[7];
                  if (v108 >= v107)
                  {
                    v181 = v105;
                    uint64_t v110 = v105[5];
                    uint64_t v111 = v108 - v110;
                    unint64_t v112 = v111 + 1;
                    if ((unint64_t)(v111 + 1) >> 61) {
                      goto LABEL_341;
                    }
                    uint64_t v113 = (char *)v107 - (char *)v110;
                    if (v113 >> 2 > v112) {
                      unint64_t v112 = v113 >> 2;
                    }
                    if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    unint64_t v180 = v112;
                    if (v112)
                    {
                      v179 = v105[5];
                      if (v112 >> 61) {
                        goto LABEL_342;
                      }
                      uint64_t v114 = (char *)operator new(8 * v112);
                      uint64_t v110 = v179;
                    }
                    else
                    {
                      uint64_t v114 = 0;
                    }
                    uint64_t v115 = (uint64_t *)&v114[8 * v111];
                    uint64_t *v115 = v62;
                    unsigned int v109 = v115 + 1;
                    if (v108 == v110)
                    {
                      unsigned int v106 = v181;
                    }
                    else
                    {
                      unsigned int v106 = v181;
                      do
                      {
                        uint64_t v116 = *--v108;
                        *--uint64_t v115 = v116;
                      }
                      while (v108 != v110);
                      uint64_t v108 = v181[5];
                    }
                    v106[5] = v115;
                    v106[6] = v109;
                    v106[7] = (uint64_t *)&v114[8 * v180];
                    if (v108)
                    {
                      int v117 = v109;
                      operator delete(v108);
                      unsigned int v109 = v117;
                    }
                  }
                  else
                  {
                    *uint64_t v108 = v62;
                    unsigned int v109 = v108 + 1;
                  }
                  v106[6] = v109;
                  sub_1CB9173F0(v205, v99, v205, v98);
                  uint64_t v81 = 1;
                  uint64_t v44 = __src;
                  uint64_t v60 = v183;
                }
              }
              uint64_t v45 = v81;
            }
          }
        }
LABEL_114:
        if (++v61 == (uint64_t *)v33) {
          goto LABEL_229;
        }
      }
    }
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    LOBYTE(v45) = 0;
LABEL_229:
    unsigned int v126 = v201;
    __srca = v44;
    if (v201 != (uint64_t *)v202)
    {
      do
      {
        uint64_t v131 = *(void *)(v205 + 56);
        if (v131 != v205 + 48)
        {
          unint64_t v132 = v126[5];
          while (v132 != v131)
          {
            uint64_t v131 = *(void *)(v131 + 8);
            if (v131 == v205 + 48) {
              goto LABEL_236;
            }
          }
          v206[0] = v126[5];
          unsigned int v135 = sub_1CD4F40F4(&v203, v132, (uint64_t **)v126 + 5);
          int v137 = v135[5];
          uint64_t v136 = v135[6];
          int64_t v138 = (char *)v136 - (char *)v137;
          if (v136 == v137)
          {
            uint64_t v139 = 0;
            int v140 = 0;
          }
          else
          {
            if (v138 < 0) {
              goto LABEL_341;
            }
            uint64_t v139 = (char *)operator new((char *)v136 - (char *)v137);
            int v140 = (llvm::MachineInstr **)&v139[8 * (v138 >> 3)];
            memmove(v139, v137, v138);
          }
          v208 = (uint64_t *)&unk_1F26126B8;
          v209 = v206;
          v211 = &v208;
          BOOL v141 = sub_1CC44E7C8((llvm::MachineInstr **)v139, v140, v205, (uint64_t)&v208);
          if (v211 == &v208)
          {
            ((void (*)(uint64_t **))v208[4])(&v208);
          }
          else if (v211)
          {
            ((void (*)(void))(*v211)[5])();
          }
          LOBYTE(v45) = v45 | v141;
          if (v139) {
            operator delete(v139);
          }
          uint64_t v44 = __srca;
        }
LABEL_236:
        v133 = (uint64_t *)v126[1];
        if (v133)
        {
          do
          {
            uint64_t v134 = v133;
            v133 = (uint64_t *)*v133;
          }
          while (v133);
        }
        else
        {
          do
          {
            uint64_t v134 = (uint64_t *)v126[2];
            BOOL v4 = *v134 == (void)v126;
            unsigned int v126 = v134;
          }
          while (!v4);
        }
        unsigned int v126 = v134;
      }
      while (v134 != (uint64_t *)v202);
    }
    int64_t v127 = v43 - v44;
    if (v43 == v44)
    {
      uint64_t v128 = 0;
      uint64_t v129 = 0;
      uint64_t v130 = v198;
    }
    else
    {
      uint64_t v130 = v198;
      if (v127 < 0) {
LABEL_341:
      }
        abort();
      uint64_t v128 = (char *)operator new(v43 - v44);
      uint64_t v129 = (llvm::MachineInstr **)&v128[8 * (v127 >> 3)];
      memmove(v128, __srca, v127);
    }
    v206[0] = (uint64_t)&unk_1F2612700;
    v206[1] = (uint64_t)&v205;
    v207 = v206;
    BOOL v142 = sub_1CC44E7C8((llvm::MachineInstr **)v128, v129, v205, (uint64_t)v206);
    if (v207 == v206)
    {
      (*(void (**)(uint64_t *))(v206[0] + 32))(v206);
      unsigned int v143 = v186;
      if (v128) {
        goto LABEL_333;
      }
    }
    else
    {
      unsigned int v143 = v186;
      if (v207)
      {
        (*(void (**)(void))(*v207 + 40))();
        if (v128)
        {
LABEL_333:
          operator delete(v128);
          if (!v42) {
            goto LABEL_263;
          }
LABEL_262:
          operator delete(v42);
          goto LABEL_263;
        }
      }
      else if (v128)
      {
        goto LABEL_333;
      }
    }
    if (v42) {
      goto LABEL_262;
    }
LABEL_263:
    if (__srca) {
      operator delete(__srca);
    }
    sub_1CD40B1BC(v202[0]);
    sub_1CD4F4ECC(v204[0]);
    if (v191) {
      operator delete(v191);
    }
    int v200 = v193;
    BOOL v144 = llvm::VRegRenamer::renameInstsInMBB((llvm::VRegRenamer *)&v199, v189);
    uint64_t v145 = *((void *)v189 + 7);
    if (v145 == v130)
    {
      char v146 = 0;
      goto LABEL_287;
    }
    char v146 = 0;
    do
    {
      uint64_t v147 = *(unsigned int *)(v145 + 40);
      if (!v147) {
        goto LABEL_280;
      }
      v148 = *(unsigned int **)(v145 + 32);
      uint64_t v149 = 32 * v147;
      do
      {
        unsigned int v150 = *v148;
        if (*v148) {
          goto LABEL_275;
        }
        if ((v150 & 0x1000000) == 0)
        {
          if (((v150 >> 26) & ~HIBYTE(v150) & 1) == 0) {
            goto LABEL_275;
          }
LABEL_274:
          unsigned int *v148 = v150 & 0xFBFFFFFF;
          char v146 = 1;
          goto LABEL_275;
        }
        if ((~v150 & 0x5000000) == 0) {
          goto LABEL_274;
        }
LABEL_275:
        v148 += 8;
        v149 -= 32;
      }
      while (v149);
      if (v145)
      {
LABEL_280:
        if ((*(unsigned char *)v145 & 4) != 0) {
          goto LABEL_284;
        }
      }
      while ((*(_WORD *)(v145 + 44) & 8) != 0)
        uint64_t v145 = *(void *)(v145 + 8);
LABEL_284:
      uint64_t v145 = *(void *)(v145 + 8);
    }
    while (v145 != v130);
LABEL_287:
    ++v193;
    v190 |= v146 | v185 | v45 | (v142 || v144);
    int v15 = v143 + 1;
    uint64_t v14 = v188;
  }
  while (v15 != v187);
LABEL_338:
  if (v14) {
    operator delete(v14);
  }
  char v5 = v190;
  return v5 & 1;
}

BOOL sub_1CC44E7C8(llvm::MachineInstr **a1, llvm::MachineInstr **a2, uint64_t a3, uint64_t a4)
{
  v58[2] = *MEMORY[0x1E4F143B8];
  __p[0] = 0;
  __p[1] = 0;
  int v53 = 0;
  if (a1 == a2)
  {
    int v26 = 0;
    unint64_t v25 = 0;
  }
  else
  {
    uint64_t v6 = a2;
    int v7 = a1;
    do
    {
      uint64_t v8 = *v7;
      memset(&__str, 0, sizeof(__str));
      int v43 = 0;
      char v47 = 0;
      uint64_t v48 = 0;
      uint64_t v42 = &unk_1F2646F30;
      p_str = &__str;
      int v49 = 0;
      uint64_t v45 = 0;
      uint64_t v46 = 0;
      uint64_t v44 = 0;
      llvm::MachineInstr::print(v8, (llvm::raw_ostream *)&v42, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
      if (v46 != v44)
      {
        uint64_t v46 = v44;
        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v42, v44);
      }
      std::string::size_type v9 = std::string::find(&__str, 61, 0);
      if (v9 == -1)
      {
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          sub_1CB8BDF7C((uint64_t)&v41, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
        }
        else {
          std::string v41 = __str;
        }
      }
      else
      {
        std::string::basic_string(&v41, &__str, v9, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v54);
      }
      v58[0] = v41.__r_.__value_.__l.__size_;
      std::string::size_type v10 = v41.__r_.__value_.__r.__words[0];
      *(void *)((char *)v58 + 7) = *(std::string::size_type *)((char *)&v41.__r_.__value_.__r.__words[1] + 7);
      char v11 = HIBYTE(v41.__r_.__value_.__r.__words[2]);
      memset(&v41, 0, sizeof(v41));
      uint64_t v13 = (char *)__p[1];
      int64x2_t v12 = v53;
      if (__p[1] >= v53)
      {
        unsigned int v40 = v6;
        uint64_t v16 = (char *)__p[0];
        unint64_t v17 = (((char *)__p[1] - (char *)__p[0]) >> 5) + 1;
        if (v17 >> 59) {
          goto LABEL_52;
        }
        int64_t v39 = ((char *)__p[1] - (char *)__p[0]) >> 5;
        if ((v53 - (char *)__p[0]) >> 4 > v17) {
          unint64_t v17 = (v53 - (char *)__p[0]) >> 4;
        }
        unint64_t v18 = 0x7FFFFFFFFFFFFFFLL;
        if ((unint64_t)(v53 - (char *)__p[0]) < 0x7FFFFFFFFFFFFFE0) {
          unint64_t v18 = v17;
        }
        unint64_t v56 = 0;
        uint64_t v57 = (void **)&v53;
        if (v18 >> 59) {
          sub_1CB833614();
        }
        unint64_t v38 = v18;
        uint64_t v19 = (char *)operator new(32 * v18);
        int64x2_t v20 = &v19[32 * v39];
        uint64_t v21 = v58[0];
        *(void *)int64x2_t v20 = v10;
        *((void *)v20 + 1) = v21;
        *(void *)(v20 + 15) = *(void *)((char *)v58 + 7);
        v20[23] = v11;
        v58[0] = 0;
        *(void *)((char *)v58 + 7) = 0;
        *((void *)v20 + 3) = v8;
        if (v13 == v16)
        {
          int64x2_t v22 = vdupq_n_s64((unint64_t)v13);
          uint64_t v23 = &v19[32 * v39];
        }
        else
        {
          uint64_t v23 = &v19[32 * v39];
          do
          {
            long long v24 = *((_OWORD *)v13 - 2);
            *((void *)v23 - 2) = *((void *)v13 - 2);
            *((_OWORD *)v23 - 2) = v24;
            *((void *)v13 - 3) = 0;
            *((void *)v13 - 2) = 0;
            *((void *)v13 - 4) = 0;
            *((void *)v23 - 1) = *((void *)v13 - 1);
            v23 -= 32;
            v13 -= 32;
          }
          while (v13 != v16);
          int64x2_t v22 = *(int64x2_t *)__p;
          int64x2_t v12 = v53;
        }
        int v15 = v20 + 32;
        __p[0] = v23;
        __p[1] = v20 + 32;
        int64x2_t v55 = v22;
        int v53 = &v19[32 * v38];
        unint64_t v56 = v12;
        uint64_t v54 = v22.i64[0];
        sub_1CD573B00((uint64_t)&v54);
        uint64_t v6 = v40;
      }
      else
      {
        uint64_t v14 = v58[0];
        *(void *)__p[1] = v10;
        *((void *)v13 + 1) = v14;
        *(void *)(v13 + 15) = *(void *)((char *)v58 + 7);
        v13[23] = v11;
        *((void *)v13 + 3) = v8;
        int v15 = v13 + 32;
      }
      __p[1] = v15;
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
      uint64_t v42 = &unk_1F2646B98;
      if (v49 == 1 && v44) {
        MEMORY[0x1D25D9CB0](v44, 0x1000C8077774924);
      }
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      ++v7;
    }
    while (v7 != v6);
    unint64_t v25 = __p[0];
    int v26 = __p[1];
  }
  unint64_t v27 = 126 - 2 * __clz((v26 - v25) >> 5);
  if (v26 == v25) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = v27;
  }
  sub_1CC44EC38((unint64_t)v25, (uint64_t)v26, v28, 1);
  uint64_t v29 = (unint64_t **)__p[0];
  char v30 = (unint64_t **)__p[1];
  if (__p[0] == __p[1])
  {
    int v34 = (void **)__p[0];
    if (__p[0]) {
      goto LABEL_44;
    }
    return v29 != v30;
  }
  uint64_t v31 = (unint64_t **)__p[0];
  do
  {
    uint64_t v32 = *(void *)(a4 + 24);
    if (!v32)
    {
      sub_1CB920400();
LABEL_52:
      abort();
    }
    uint64_t v33 = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(void *)v32 + 48))(v32);
    sub_1CB9173F0(a3, v33, a3, v31[3]);
    v31 += 4;
  }
  while (v31 != v30);
  int v34 = (void **)__p[0];
  if (!__p[0]) {
    return v29 != v30;
  }
LABEL_44:
  uint64_t v35 = (void **)__p[1];
  unint64_t v36 = v34;
  if (__p[1] != v34)
  {
    do
    {
      if (*((char *)v35 - 9) < 0) {
        operator delete(*(v35 - 4));
      }
      v35 -= 4;
    }
    while (v35 != v34);
    unint64_t v36 = (void **)__p[0];
  }
  __p[1] = v34;
  operator delete(v36);
  return v29 != v30;
}

void sub_1CC44EC38(unint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v323 = *MEMORY[0x1E4F143B8];
  while (2)
  {
    uint64_t v9 = a2 - 32;
    v309 = (const void **)(a2 - 96);
    v310 = (const void **)(a2 - 64);
    std::string::size_type v10 = (const void **)a1;
    v312 = (void **)a2;
    uint64_t v314 = a2 - 32;
    while (1)
    {
      while (1)
      {
        a1 = (unint64_t)v10;
        uint64_t v11 = a2 - (void)v10;
        uint64_t v12 = (a2 - (uint64_t)v10) >> 5;
        if (v5 || !v4)
        {
          switch(v12)
          {
            case 0:
            case 1:
              return;
            case 2:
              char v142 = *(unsigned char *)(a1 + 23);
              BOOL v143 = v142 < 0;
              if (v142 >= 0) {
                BOOL v144 = (const void *)a1;
              }
              else {
                BOOL v144 = *(const void **)a1;
              }
              size_t v145 = v142 & 0x7F;
              if (v143) {
                size_t v146 = *(void *)(a1 + 8);
              }
              else {
                size_t v146 = v145;
              }
              if (*(char *)(a2 - 9) < 0)
              {
                v148 = *(const void **)(a2 - 32);
                size_t v147 = *(void *)(a2 - 24);
              }
              else
              {
                size_t v147 = *(unsigned __int8 *)(a2 - 9);
                v148 = (const void *)v9;
              }
              if (v146 >= v147) {
                size_t v149 = v147;
              }
              else {
                size_t v149 = v146;
              }
              int v150 = memcmp(v148, v144, v149);
              BOOL v151 = v147 < v146;
              if (v150) {
                BOOL v151 = v150 < 0;
              }
              if (v151)
              {
                long long v152 = *(_OWORD *)a1;
                v319 = *(const void **)(a1 + 16);
                *(_OWORD *)std::string __p = v152;
                long long v153 = *(_OWORD *)v9;
                *(void *)(a1 + 16) = *(void *)(v9 + 16);
                *(_OWORD *)a1 = v153;
                long long v154 = *(_OWORD *)__p;
                *(void *)(v9 + 16) = v319;
                *(_OWORD *)uint64_t v9 = v154;
                uint64_t v155 = *(void *)(a1 + 24);
                *(void *)(a1 + 24) = *(void *)(a2 - 8);
                *(void *)(a2 - 8) = v155;
              }
              break;
            case 3:
              sub_1CC4501BC((const void **)a1, (void *)(a1 + 32), (const void **)v9);
              break;
            case 4:
              sub_1CC450798(a1, (long long *)(a1 + 32), (long long *)(a1 + 64), (long long *)v9);
              break;
            case 5:
              sub_1CC44FF38(a1, a1 + 32, a1 + 64, a1 + 96, v9);
              break;
            default:
              JUMPOUT(0);
          }
          return;
        }
        if (v11 <= 767)
        {
          if (a4)
          {
            if (a1 != a2)
            {
              unint64_t v156 = a1 + 32;
              if (a1 + 32 != a2)
              {
                uint64_t v157 = 0;
                uint64_t v158 = (const void **)a1;
                do
                {
                  unint64_t v159 = (const void **)v156;
                  char v160 = *((unsigned char *)v158 + 23);
                  BOOL v161 = v160 < 0;
                  if (v160 >= 0) {
                    v162 = v158;
                  }
                  else {
                    v162 = *v158;
                  }
                  size_t v163 = v160 & 0x7F;
                  if (v161) {
                    size_t v164 = (size_t)v158[1];
                  }
                  else {
                    size_t v164 = v163;
                  }
                  if (*((char *)v158 + 55) < 0)
                  {
                    size_t v165 = (size_t)v158[5];
                    unint64_t v166 = *v159;
                  }
                  else
                  {
                    size_t v165 = *((unsigned __int8 *)v158 + 55);
                    unint64_t v166 = v159;
                  }
                  if (v164 >= v165) {
                    size_t v167 = v165;
                  }
                  else {
                    size_t v167 = v164;
                  }
                  int v168 = memcmp(v166, v162, v167);
                  BOOL v169 = v165 < v164;
                  if (v168) {
                    BOOL v169 = v168 < 0;
                  }
                  if (v169)
                  {
                    long long v170 = *(_OWORD *)v159;
                    v319 = v159[2];
                    *(_OWORD *)std::string __p = v170;
                    v159[1] = 0;
                    v159[2] = 0;
                    *unint64_t v159 = 0;
                    v320 = v158[7];
                    uint64_t v171 = v157;
                    while (1)
                    {
                      uint64_t v172 = a1 + v171;
                      unint64_t v173 = (void **)(a1 + v171 + 32);
                      if (*(char *)(a1 + v171 + 55) < 0) {
                        operator delete(*v173);
                      }
                      *(_OWORD *)unint64_t v173 = *(_OWORD *)v172;
                      uint64_t v174 = *(void *)(v172 + 24);
                      *(void *)(a1 + v171 + 48) = *(void *)(v172 + 16);
                      *(unsigned char *)(v172 + 23) = 0;
                      *(unsigned char *)uint64_t v172 = 0;
                      *(void *)(v172 + 56) = v174;
                      if (!v171) {
                        break;
                      }
                      char v175 = *(unsigned char *)(a1 + v171 - 9);
                      if (v175 >= 0) {
                        v176 = (const void *)(a1 + v171 - 32);
                      }
                      else {
                        v176 = *(const void **)(a1 + v171 - 32);
                      }
                      if (v175 >= 0) {
                        size_t v177 = v175 & 0x7F;
                      }
                      else {
                        size_t v177 = *(void *)(a1 + v171 - 24);
                      }
                      if (SHIBYTE(v319) >= 0) {
                        uint64_t v178 = (void *)(HIBYTE(v319) & 0x7F);
                      }
                      else {
                        uint64_t v178 = __p[1];
                      }
                      if (SHIBYTE(v319) >= 0) {
                        v179 = __p;
                      }
                      else {
                        v179 = (void **)__p[0];
                      }
                      if (v177 >= (unint64_t)v178) {
                        size_t v180 = (size_t)v178;
                      }
                      else {
                        size_t v180 = v177;
                      }
                      int v181 = memcmp(v179, v176, v180);
                      BOOL v182 = (unint64_t)v178 < v177;
                      if (v181) {
                        BOOL v182 = v181 < 0;
                      }
                      v171 -= 32;
                      if (!v182)
                      {
                        uint64_t v183 = a1 + v171 + 32;
                        goto LABEL_281;
                      }
                    }
                    uint64_t v183 = a1;
LABEL_281:
                    if (*(char *)(v183 + 23) < 0) {
                      operator delete(*(void **)v183);
                    }
                    long long v184 = *(_OWORD *)__p;
                    *(void *)(v183 + 16) = v319;
                    *(_OWORD *)uint64_t v183 = v184;
                    *(void *)(v183 + 24) = v320;
                  }
                  unint64_t v156 = (unint64_t)(v159 + 4);
                  v157 += 32;
                  uint64_t v158 = v159;
                }
                while (v159 + 4 != (const void **)a2);
              }
            }
          }
          else if (a1 != a2)
          {
            unint64_t v280 = a1 + 32;
            if (a1 + 32 != a2)
            {
              v281 = (void *)(a1 + 56);
              do
              {
                v282 = (const void **)v280;
                char v283 = *(unsigned char *)(a1 + 23);
                BOOL v284 = v283 < 0;
                if (v283 >= 0) {
                  v285 = (const void *)a1;
                }
                else {
                  v285 = *(const void **)a1;
                }
                size_t v286 = v283 & 0x7F;
                if (v284) {
                  size_t v287 = *(void *)(a1 + 8);
                }
                else {
                  size_t v287 = v286;
                }
                if (*(char *)(a1 + 55) < 0)
                {
                  size_t v288 = *(void *)(a1 + 40);
                  v289 = *v282;
                }
                else
                {
                  size_t v288 = *(unsigned __int8 *)(a1 + 55);
                  v289 = v282;
                }
                if (v287 >= v288) {
                  size_t v290 = v288;
                }
                else {
                  size_t v290 = v287;
                }
                int v291 = memcmp(v289, v285, v290);
                BOOL v292 = v288 < v287;
                if (v291) {
                  BOOL v292 = v291 < 0;
                }
                if (v292)
                {
                  long long v293 = *(_OWORD *)v282;
                  v319 = v282[2];
                  *(_OWORD *)std::string __p = v293;
                  v282[1] = 0;
                  v282[2] = 0;
                  *v282 = 0;
                  v320 = *(const void **)(a1 + 56);
                  v294 = v281;
                  do
                  {
                    v295 = (void **)(v294 - 3);
                    if (*((char *)v294 - 1) < 0) {
                      operator delete(*v295);
                    }
                    *(_OWORD *)v295 = *(_OWORD *)(v294 - 7);
                    *(v294 - 1) = *(v294 - 5);
                    *((unsigned char *)v294 - 33) = 0;
                    *((unsigned char *)v294 - 56) = 0;
                    v296 = v294 - 4;
                    void *v294 = *(v294 - 4);
                    char v297 = *((unsigned char *)v294 - 65);
                    int v298 = v297;
                    if (v297 >= 0) {
                      v299 = v294 - 11;
                    }
                    else {
                      v299 = (void *)*(v294 - 11);
                    }
                    size_t v300 = v297 & 0x7F;
                    if (v298 >= 0) {
                      size_t v301 = v300;
                    }
                    else {
                      size_t v301 = *(v294 - 10);
                    }
                    if (SHIBYTE(v319) >= 0) {
                      v302 = (void *)(HIBYTE(v319) & 0x7F);
                    }
                    else {
                      v302 = __p[1];
                    }
                    if (SHIBYTE(v319) >= 0) {
                      v303 = __p;
                    }
                    else {
                      v303 = (void **)__p[0];
                    }
                    if (v301 >= (unint64_t)v302) {
                      size_t v304 = (size_t)v302;
                    }
                    else {
                      size_t v304 = v301;
                    }
                    int v305 = memcmp(v303, v299, v304);
                    BOOL v306 = (unint64_t)v302 < v301;
                    if (v305) {
                      BOOL v306 = v305 < 0;
                    }
                    v294 = v296;
                  }
                  while (v306);
                  v307 = (void **)(v296 - 3);
                  if (*((char *)v296 - 1) < 0) {
                    operator delete(*v307);
                  }
                  long long v308 = *(_OWORD *)__p;
                  *(v296 - 1) = v319;
                  *(_OWORD *)v307 = v308;
                  HIBYTE(v319) = 0;
                  LOBYTE(__p[0]) = 0;
                  void *v296 = v320;
                }
                unint64_t v280 = (unint64_t)(v282 + 4);
                v281 += 4;
                a1 = (unint64_t)v282;
              }
              while (v282 + 4 != (const void **)a2);
            }
          }
          return;
        }
        if (!a3)
        {
          if (a1 != a2)
          {
            int64_t v185 = (unint64_t)(v12 - 2) >> 1;
            int64_t v186 = v185;
            do
            {
              int64_t v187 = v186;
              if (v185 >= v186)
              {
                uint64_t v188 = (2 * v186) | 1;
                unint64_t v189 = a1 + 32 * v188;
                if (2 * v186 + 2 < v12)
                {
                  char v190 = *(unsigned char *)(v189 + 55);
                  int v191 = v190;
                  if (v190 >= 0) {
                    unint64_t v192 = (const void *)(v189 + 32);
                  }
                  else {
                    unint64_t v192 = *(const void **)(v189 + 32);
                  }
                  size_t v193 = v190 & 0x7F;
                  if (v191 >= 0) {
                    size_t v194 = v193;
                  }
                  else {
                    size_t v194 = *(void *)(v189 + 40);
                  }
                  if (*(char *)(v189 + 23) < 0)
                  {
                    v196 = *(const void **)v189;
                    size_t v195 = *(void *)(v189 + 8);
                  }
                  else
                  {
                    size_t v195 = *(unsigned __int8 *)(v189 + 23);
                    v196 = (const void *)(a1 + 32 * v188);
                  }
                  if (v194 >= v195) {
                    size_t v197 = v195;
                  }
                  else {
                    size_t v197 = v194;
                  }
                  int v198 = memcmp(v196, v192, v197);
                  BOOL v199 = v195 < v194;
                  if (v198) {
                    BOOL v199 = v198 < 0;
                  }
                  if (v199)
                  {
                    v189 += 32;
                    uint64_t v188 = 2 * v187 + 2;
                  }
                }
                unint64_t v200 = a1 + 32 * v187;
                char v201 = *(unsigned char *)(v200 + 23);
                BOOL v202 = v201 < 0;
                if (v201 >= 0) {
                  v203 = (const void *)(a1 + 32 * v187);
                }
                else {
                  v203 = *(const void **)v200;
                }
                size_t v204 = v201 & 0x7F;
                if (v202) {
                  size_t v205 = *(void *)(v200 + 8);
                }
                else {
                  size_t v205 = v204;
                }
                if (*(char *)(v189 + 23) < 0)
                {
                  v207 = *(const void **)v189;
                  size_t v206 = *(void *)(v189 + 8);
                }
                else
                {
                  size_t v206 = *(unsigned __int8 *)(v189 + 23);
                  v207 = (const void *)v189;
                }
                if (v205 >= v206) {
                  size_t v208 = v206;
                }
                else {
                  size_t v208 = v205;
                }
                int v209 = memcmp(v207, v203, v208);
                BOOL v210 = v206 < v205;
                if (v209) {
                  BOOL v210 = v209 < 0;
                }
                int64_t v185 = (unint64_t)(v12 - 2) >> 1;
                if (!v210)
                {
                  long long v211 = *(_OWORD *)v200;
                  v319 = *(const void **)(v200 + 16);
                  *(_OWORD *)std::string __p = v211;
                  *(void *)(v200 + 8) = 0;
                  *(void *)(v200 + 16) = 0;
                  *(void *)unint64_t v200 = 0;
                  v320 = *(const void **)(a1 + 32 * v187 + 24);
                  do
                  {
                    unint64_t v212 = v189;
                    if (*(char *)(v200 + 23) < 0) {
                      operator delete(*(void **)v200);
                    }
                    long long v213 = *(_OWORD *)v189;
                    *(void *)(v200 + 16) = *(void *)(v189 + 16);
                    *(_OWORD *)unint64_t v200 = v213;
                    *(unsigned char *)(v189 + 23) = 0;
                    *(unsigned char *)unint64_t v189 = 0;
                    *(void *)(v200 + 24) = *(void *)(v189 + 24);
                    if (v185 < v188) {
                      break;
                    }
                    uint64_t v214 = (2 * v188) | 1;
                    unint64_t v189 = a1 + 32 * v214;
                    uint64_t v188 = 2 * v188 + 2;
                    if (v188 < v12)
                    {
                      char v215 = *(unsigned char *)(v189 + 55);
                      int v216 = v215;
                      if (v215 >= 0) {
                        v217 = (const void *)(v189 + 32);
                      }
                      else {
                        v217 = *(const void **)(v189 + 32);
                      }
                      size_t v218 = v215 & 0x7F;
                      if (v216 >= 0) {
                        size_t v219 = v218;
                      }
                      else {
                        size_t v219 = *(void *)(v189 + 40);
                      }
                      if (*(char *)(v189 + 23) < 0)
                      {
                        v221 = *(const void **)v189;
                        size_t v220 = *(void *)(v189 + 8);
                      }
                      else
                      {
                        size_t v220 = *(unsigned __int8 *)(v189 + 23);
                        v221 = (const void *)(a1 + 32 * v214);
                      }
                      if (v219 >= v220) {
                        size_t v222 = v220;
                      }
                      else {
                        size_t v222 = v219;
                      }
                      int v223 = memcmp(v221, v217, v222);
                      BOOL v224 = v220 < v219;
                      if (v223) {
                        BOOL v224 = v223 < 0;
                      }
                      if (v224) {
                        v189 += 32;
                      }
                      else {
                        uint64_t v188 = v214;
                      }
                      int64_t v185 = (unint64_t)(v12 - 2) >> 1;
                    }
                    else
                    {
                      uint64_t v188 = v214;
                    }
                    if (SHIBYTE(v319) >= 0) {
                      v225 = __p;
                    }
                    else {
                      v225 = (void **)__p[0];
                    }
                    if (SHIBYTE(v319) >= 0) {
                      v226 = (void *)(HIBYTE(v319) & 0x7F);
                    }
                    else {
                      v226 = __p[1];
                    }
                    if (*(char *)(v189 + 23) < 0)
                    {
                      v228 = *(const void **)v189;
                      size_t v227 = *(void *)(v189 + 8);
                    }
                    else
                    {
                      size_t v227 = *(unsigned __int8 *)(v189 + 23);
                      v228 = (const void *)v189;
                    }
                    if ((unint64_t)v226 >= v227) {
                      size_t v229 = v227;
                    }
                    else {
                      size_t v229 = (size_t)v226;
                    }
                    int v230 = memcmp(v228, v225, v229);
                    BOOL v231 = v227 < (unint64_t)v226;
                    if (v230) {
                      BOOL v231 = v230 < 0;
                    }
                    unint64_t v200 = v212;
                  }
                  while (!v231);
                  if (*(char *)(v212 + 23) < 0) {
                    operator delete(*(void **)v212);
                  }
                  long long v232 = *(_OWORD *)__p;
                  *(void *)(v212 + 16) = v319;
                  *(_OWORD *)unint64_t v212 = v232;
                  *(void *)(v212 + 24) = v320;
                }
              }
              int64_t v186 = v187 - 1;
            }
            while (v187);
            v233 = v312;
            do
            {
              uint64_t v234 = 0;
              v315 = *(void **)a1;
              *(void *)&long long v321 = *(void *)(a1 + 8);
              *(void *)((char *)&v321 + 7) = *(void *)(a1 + 15);
              char v317 = *(unsigned char *)(a1 + 23);
              *(void *)(a1 + 8) = 0;
              *(void *)(a1 + 16) = 0;
              *(void *)a1 = 0;
              v311 = v233;
              v313 = *(void **)(a1 + 24);
              unint64_t v235 = a1;
              do
              {
                uint64_t v236 = v235 + 32 * v234 + 32;
                uint64_t v237 = 2 * v234;
                uint64_t v234 = (2 * v234) | 1;
                uint64_t v238 = v237 + 2;
                if (v237 + 2 < v12)
                {
                  char v239 = *(unsigned char *)(v236 + 55);
                  int v240 = v239;
                  if (v239 >= 0) {
                    v241 = (const void *)(v236 + 32);
                  }
                  else {
                    v241 = *(const void **)(v236 + 32);
                  }
                  size_t v242 = v239 & 0x7F;
                  if (v240 >= 0) {
                    size_t v243 = v242;
                  }
                  else {
                    size_t v243 = *(void *)(v236 + 40);
                  }
                  if (*(char *)(v236 + 23) < 0)
                  {
                    v245 = *(const void **)v236;
                    size_t v244 = *(void *)(v236 + 8);
                  }
                  else
                  {
                    size_t v244 = *(unsigned __int8 *)(v236 + 23);
                    v245 = (const void *)v236;
                  }
                  if (v243 >= v244) {
                    size_t v246 = v244;
                  }
                  else {
                    size_t v246 = v243;
                  }
                  int v247 = memcmp(v245, v241, v246);
                  BOOL v248 = v244 < v243;
                  if (v247) {
                    BOOL v248 = v247 < 0;
                  }
                  if (v248)
                  {
                    v236 += 32;
                    uint64_t v234 = v238;
                  }
                }
                if (*(char *)(v235 + 23) < 0) {
                  operator delete(*(void **)v235);
                }
                long long v249 = *(_OWORD *)v236;
                *(void *)(v235 + 16) = *(void *)(v236 + 16);
                *(_OWORD *)unint64_t v235 = v249;
                *(unsigned char *)(v236 + 23) = 0;
                *(unsigned char *)uint64_t v236 = 0;
                *(void *)(v235 + 24) = *(void *)(v236 + 24);
                unint64_t v235 = v236;
              }
              while (v234 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
              v233 = v311 - 4;
              int v250 = *(char *)(v236 + 23);
              if ((void **)v236 == v311 - 4)
              {
                if (v250 < 0) {
                  operator delete(*(void **)v236);
                }
                *(void *)uint64_t v236 = v315;
                uint64_t v277 = *(void *)((char *)&v321 + 7);
                *(void *)(v236 + 8) = v321;
                *(void *)(v236 + 15) = v277;
                *(unsigned char *)(v236 + 23) = v317;
                *(void *)(v236 + 24) = v313;
              }
              else
              {
                if (v250 < 0) {
                  operator delete(*(void **)v236);
                }
                long long v251 = *(_OWORD *)v233;
                *(void *)(v236 + 16) = *(v311 - 2);
                *(_OWORD *)uint64_t v236 = v251;
                *((unsigned char *)v311 - 9) = 0;
                *((unsigned char *)v311 - 32) = 0;
                *(void *)(v236 + 24) = *(v311 - 1);
                if (*((char *)v311 - 9) < 0) {
                  operator delete(*v233);
                }
                *(v311 - 4) = v315;
                v252 = (void *)v321;
                *(void **)((char *)v311 - 17) = *(void **)((char *)&v321 + 7);
                *(v311 - 3) = v252;
                *((unsigned char *)v311 - 9) = v317;
                *(v311 - 1) = v313;
                uint64_t v253 = v236 + 32 - a1;
                if (v253 >= 33)
                {
                  unint64_t v254 = (((unint64_t)v253 >> 5) - 2) >> 1;
                  unint64_t v255 = a1 + 32 * v254;
                  char v256 = *(unsigned char *)(v236 + 23);
                  BOOL v257 = v256 < 0;
                  if (v256 >= 0) {
                    v258 = (const void *)v236;
                  }
                  else {
                    v258 = *(const void **)v236;
                  }
                  size_t v259 = v256 & 0x7F;
                  if (v257) {
                    size_t v260 = *(void *)(v236 + 8);
                  }
                  else {
                    size_t v260 = v259;
                  }
                  if (*(char *)(v255 + 23) < 0)
                  {
                    v262 = *(const void **)v255;
                    size_t v261 = *(void *)(v255 + 8);
                  }
                  else
                  {
                    size_t v261 = *(unsigned __int8 *)(v255 + 23);
                    v262 = (const void *)(a1 + 32 * v254);
                  }
                  if (v260 >= v261) {
                    size_t v263 = v261;
                  }
                  else {
                    size_t v263 = v260;
                  }
                  int v264 = memcmp(v262, v258, v263);
                  BOOL v265 = v261 < v260;
                  if (v264) {
                    BOOL v265 = v264 < 0;
                  }
                  if (v265)
                  {
                    long long v266 = *(_OWORD *)v236;
                    v267 = *(const void **)(v236 + 24);
                    v319 = *(const void **)(v236 + 16);
                    *(_OWORD *)std::string __p = v266;
                    *(void *)(v236 + 8) = 0;
                    *(void *)(v236 + 16) = 0;
                    *(void *)uint64_t v236 = 0;
                    v320 = v267;
                    do
                    {
                      uint64_t v268 = v255;
                      if (*(char *)(v236 + 23) < 0) {
                        operator delete(*(void **)v236);
                      }
                      long long v269 = *(_OWORD *)v255;
                      *(void *)(v236 + 16) = *(void *)(v255 + 16);
                      *(_OWORD *)uint64_t v236 = v269;
                      *(unsigned char *)(v255 + 23) = 0;
                      *(unsigned char *)unint64_t v255 = 0;
                      *(void *)(v236 + 24) = *(void *)(v255 + 24);
                      if (!v254) {
                        break;
                      }
                      unint64_t v254 = (v254 - 1) >> 1;
                      unint64_t v255 = a1 + 32 * v254;
                      if (SHIBYTE(v319) >= 0) {
                        v270 = __p;
                      }
                      else {
                        v270 = (void **)__p[0];
                      }
                      if (SHIBYTE(v319) >= 0) {
                        v271 = (void *)(HIBYTE(v319) & 0x7F);
                      }
                      else {
                        v271 = __p[1];
                      }
                      if (*(char *)(v255 + 23) < 0)
                      {
                        v273 = *(const void **)v255;
                        size_t v272 = *(void *)(v255 + 8);
                      }
                      else
                      {
                        size_t v272 = *(unsigned __int8 *)(v255 + 23);
                        v273 = (const void *)(a1 + 32 * v254);
                      }
                      if ((unint64_t)v271 >= v272) {
                        size_t v274 = v272;
                      }
                      else {
                        size_t v274 = (size_t)v271;
                      }
                      int v275 = memcmp(v273, v270, v274);
                      BOOL v276 = v272 < (unint64_t)v271;
                      if (v275) {
                        BOOL v276 = v275 < 0;
                      }
                      uint64_t v236 = v268;
                    }
                    while (v276);
                    if (*(char *)(v268 + 23) < 0) {
                      operator delete(*(void **)v268);
                    }
                    long long v278 = *(_OWORD *)__p;
                    *(void *)(v268 + 16) = v319;
                    *(_OWORD *)uint64_t v268 = v278;
                    *(void *)(v268 + 24) = v320;
                  }
                }
              }
            }
            while (v12-- > 2);
          }
          return;
        }
        unint64_t v13 = (unint64_t)v12 >> 1;
        unint64_t v14 = a1 + 32 * ((unint64_t)v12 >> 1);
        if ((unint64_t)v11 <= 0x1000)
        {
          sub_1CC4501BC((const void **)v14, (void *)a1, (const void **)v9);
        }
        else
        {
          sub_1CC4501BC((const void **)a1, (void *)v14, (const void **)v9);
          sub_1CC4501BC((const void **)(a1 + 32), (void *)(v14 - 32), v310);
          sub_1CC4501BC((const void **)(a1 + 64), (void *)(a1 + 32 + 32 * v13), v309);
          sub_1CC4501BC((const void **)(v14 - 32), (void *)v14, (const void **)(a1 + 32 + 32 * v13));
          long long v15 = *(_OWORD *)a1;
          uint64_t v16 = *(void *)(a1 + 24);
          v319 = *(const void **)(a1 + 16);
          *(_OWORD *)std::string __p = v15;
          uint64_t v17 = *(void *)(v14 + 16);
          uint64_t v18 = *(void *)(v14 + 24);
          *(_OWORD *)a1 = *(_OWORD *)v14;
          *(void *)(a1 + 16) = v17;
          *(void *)(a1 + 24) = v18;
          uint64_t v19 = v319;
          *(_OWORD *)unint64_t v14 = *(_OWORD *)__p;
          *(void *)(v14 + 16) = v19;
          *(void *)(v14 + 24) = v16;
        }
        --a3;
        if (a4) {
          break;
        }
        char v20 = *(unsigned char *)(a1 + 23);
        BOOL v21 = v20 < 0;
        if (v20 >= 0) {
          int64x2_t v22 = (const void *)a1;
        }
        else {
          int64x2_t v22 = *(const void **)a1;
        }
        size_t v23 = v20 & 0x7F;
        if (v21) {
          size_t v24 = *(void *)(a1 + 8);
        }
        else {
          size_t v24 = v23;
        }
        if (*(char *)(a1 - 9) < 0)
        {
          unint64_t v25 = *(const void **)(a1 - 32);
          size_t v26 = *(void *)(a1 - 24);
        }
        else
        {
          unint64_t v25 = (const void *)(a1 - 32);
          size_t v26 = *(unsigned __int8 *)(a1 - 9);
        }
        if (v24 >= v26) {
          size_t v27 = v26;
        }
        else {
          size_t v27 = v24;
        }
        int v28 = memcmp(v25, v22, v27);
        BOOL v29 = v26 < v24;
        if (v28) {
          BOOL v29 = v28 < 0;
        }
        if (v29) {
          break;
        }
        long long v76 = *(_OWORD *)a1;
        __int16 v77 = *(const void **)(a1 + 24);
        v319 = *(const void **)(a1 + 16);
        *(_OWORD *)std::string __p = v76;
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)a1 = 0;
        v320 = v77;
        char v78 = *(unsigned char *)(a2 - 9);
        BOOL v79 = v78 < 0;
        if (v78 >= 0) {
          uint64_t v80 = (const void *)v9;
        }
        else {
          uint64_t v80 = *(const void **)(a2 - 32);
        }
        size_t v81 = v78 & 0x7F;
        if (v79) {
          size_t v82 = *(void *)(a2 - 24);
        }
        else {
          size_t v82 = v81;
        }
        if (SHIBYTE(v319) >= 0) {
          uint64_t v83 = (void *)(HIBYTE(v319) & 0x7F);
        }
        else {
          uint64_t v83 = __p[1];
        }
        if (SHIBYTE(v319) >= 0) {
          unsigned int v84 = __p;
        }
        else {
          unsigned int v84 = (void **)__p[0];
        }
        if (v82 >= (unint64_t)v83) {
          size_t v85 = (size_t)v83;
        }
        else {
          size_t v85 = v82;
        }
        int v86 = memcmp(v84, v80, v85);
        BOOL v87 = (unint64_t)v83 < v82;
        if (v86) {
          BOOL v87 = v86 < 0;
        }
        if (v87)
        {
          unsigned int v88 = (const void **)(a1 + 32);
          do
          {
            char v89 = *((unsigned char *)v88 + 23);
            BOOL v90 = v89 < 0;
            if (v89 >= 0) {
              unsigned int v91 = v88;
            }
            else {
              unsigned int v91 = *v88;
            }
            size_t v92 = v89 & 0x7F;
            if (v90) {
              size_t v93 = (size_t)v88[1];
            }
            else {
              size_t v93 = v92;
            }
            if (v93 >= (unint64_t)v83) {
              size_t v94 = (size_t)v83;
            }
            else {
              size_t v94 = v93;
            }
            int v95 = memcmp(v84, v91, v94);
            BOOL v96 = (unint64_t)v83 < v93;
            if (v95) {
              BOOL v96 = v95 < 0;
            }
            v88 += 4;
          }
          while (!v96);
          std::string::size_type v10 = v88 - 4;
        }
        else
        {
          uint64_t v97 = (void **)(a1 + 32);
          do
          {
            std::string::size_type v10 = (const void **)v97;
            if (v97 >= v312) {
              break;
            }
            char v98 = *((unsigned char *)v97 + 23);
            BOOL v99 = v98 < 0;
            if (v98 >= 0) {
              __int32 v100 = v10;
            }
            else {
              __int32 v100 = *v10;
            }
            size_t v101 = v98 & 0x7F;
            if (v99) {
              size_t v102 = (size_t)v10[1];
            }
            else {
              size_t v102 = v101;
            }
            if (v102 >= (unint64_t)v83) {
              size_t v103 = (size_t)v83;
            }
            else {
              size_t v103 = v102;
            }
            int v104 = memcmp(v84, v100, v103);
            BOOL v105 = v104 < 0;
            if (!v104) {
              BOOL v105 = (unint64_t)v83 < v102;
            }
            uint64_t v97 = (void **)(v10 + 4);
          }
          while (!v105);
        }
        unint64_t v106 = (unint64_t)v312;
        if (v10 < (const void **)v312)
        {
          unsigned int v107 = (const void **)v314;
          do
          {
            char v108 = *((unsigned char *)v107 + 23);
            BOOL v109 = v108 < 0;
            if (v108 >= 0) {
              uint64_t v110 = v107;
            }
            else {
              uint64_t v110 = *v107;
            }
            size_t v111 = v108 & 0x7F;
            if (v109) {
              size_t v112 = (size_t)v107[1];
            }
            else {
              size_t v112 = v111;
            }
            if (v112 >= (unint64_t)v83) {
              size_t v113 = (size_t)v83;
            }
            else {
              size_t v113 = v112;
            }
            int v114 = memcmp(v84, v110, v113);
            BOOL v115 = (unint64_t)v83 < v112;
            if (v114) {
              BOOL v115 = v114 < 0;
            }
            v107 -= 4;
          }
          while (v115);
          goto LABEL_169;
        }
        while ((unint64_t)v10 < v106)
        {
          long long v116 = *(_OWORD *)v10;
          v322 = v10[2];
          long long v321 = v116;
          long long v117 = *(_OWORD *)v106;
          v10[2] = *(const void **)(v106 + 16);
          *(_OWORD *)std::string::size_type v10 = v117;
          long long v118 = v321;
          *(void *)(v106 + 16) = v322;
          *(_OWORD *)unint64_t v106 = v118;
          unint64_t v119 = v10[3];
          v10[3] = *(const void **)(v106 + 24);
          *(void *)(v106 + 24) = v119;
          if (SHIBYTE(v319) >= 0) {
            uint64_t v120 = (void *)(HIBYTE(v319) & 0x7F);
          }
          else {
            uint64_t v120 = __p[1];
          }
          if (SHIBYTE(v319) >= 0) {
            uint64_t v121 = __p;
          }
          else {
            uint64_t v121 = (void **)__p[0];
          }
          uint64_t v122 = v10 + 4;
          do
          {
            char v123 = *((unsigned char *)v122 + 23);
            BOOL v124 = v123 < 0;
            if (v123 >= 0) {
              uint64_t v125 = v122;
            }
            else {
              uint64_t v125 = *v122;
            }
            size_t v126 = v123 & 0x7F;
            if (v124) {
              size_t v127 = (size_t)v122[1];
            }
            else {
              size_t v127 = v126;
            }
            if (v127 >= (unint64_t)v120) {
              size_t v128 = (size_t)v120;
            }
            else {
              size_t v128 = v127;
            }
            int v129 = memcmp(v121, v125, v128);
            BOOL v130 = (unint64_t)v120 < v127;
            if (v129) {
              BOOL v130 = v129 < 0;
            }
            v122 += 4;
          }
          while (!v130);
          std::string::size_type v10 = v122 - 4;
          unsigned int v107 = (const void **)(v106 - 32);
          do
          {
            char v131 = *((unsigned char *)v107 + 23);
            BOOL v132 = v131 < 0;
            if (v131 >= 0) {
              v133 = v107;
            }
            else {
              v133 = *v107;
            }
            size_t v134 = v131 & 0x7F;
            if (v132) {
              size_t v135 = (size_t)v107[1];
            }
            else {
              size_t v135 = v134;
            }
            if (v135 >= (unint64_t)v120) {
              size_t v136 = (size_t)v120;
            }
            else {
              size_t v136 = v135;
            }
            int v137 = memcmp(v121, v133, v136);
            BOOL v138 = (unint64_t)v120 < v135;
            if (v137) {
              BOOL v138 = v137 < 0;
            }
            v107 -= 4;
          }
          while (v138);
LABEL_169:
          unint64_t v106 = (unint64_t)(v107 + 4);
        }
        uint64_t v139 = (void **)(v10 - 4);
        BOOL v4 = (unint64_t)(v10 - 4) >= a1;
        BOOL v5 = v10 - 4 == (const void **)a1;
        a2 = (uint64_t)v312;
        uint64_t v9 = v314;
        if (v10 - 4 != (const void **)a1)
        {
          if (*(char *)(a1 + 23) < 0) {
            operator delete(*(void **)a1);
          }
          long long v140 = *(_OWORD *)v139;
          *(void *)(a1 + 16) = *(v10 - 2);
          *(_OWORD *)a1 = v140;
          *((unsigned char *)v10 - 9) = 0;
          *((unsigned char *)v10 - 32) = 0;
          *(void *)(a1 + 24) = *(v10 - 1);
        }
        if (*((char *)v10 - 9) < 0) {
          operator delete(*v139);
        }
        long long v141 = *(_OWORD *)__p;
        *(v10 - 2) = v319;
        *(_OWORD *)uint64_t v139 = v141;
        HIBYTE(v319) = 0;
        LOBYTE(__p[0]) = 0;
        *(v10 - 1) = v320;
        if (SHIBYTE(v319) < 0) {
          operator delete(__p[0]);
        }
LABEL_107:
        a4 = 0;
      }
      uint64_t v30 = 0;
      long long v31 = *(_OWORD *)a1;
      uint64_t v32 = *(const void **)(a1 + 24);
      v319 = *(const void **)(a1 + 16);
      *(_OWORD *)std::string __p = v31;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)a1 = 0;
      v320 = v32;
      if (SHIBYTE(v319) >= 0) {
        uint64_t v33 = (void *)(HIBYTE(v319) & 0x7F);
      }
      else {
        uint64_t v33 = __p[1];
      }
      if (SHIBYTE(v319) >= 0) {
        int v34 = __p;
      }
      else {
        int v34 = (void **)__p[0];
      }
      do
      {
        uint64_t v35 = (void *)(a1 + v30 + 32);
        if (*(char *)(a1 + v30 + 55) < 0)
        {
          size_t v36 = *(void *)(a1 + v30 + 40);
          uint64_t v35 = (void *)*v35;
        }
        else
        {
          size_t v36 = *(unsigned __int8 *)(a1 + v30 + 55);
        }
        if ((unint64_t)v33 >= v36) {
          size_t v37 = v36;
        }
        else {
          size_t v37 = (size_t)v33;
        }
        int v38 = memcmp(v35, v34, v37);
        BOOL v39 = v36 < (unint64_t)v33;
        if (v38) {
          BOOL v39 = v38 < 0;
        }
        v30 += 32;
      }
      while (v39);
      unint64_t v40 = a1 + v30;
      std::string v41 = (char *)v9;
      if (v30 == 32)
      {
        while (1)
        {
          unint64_t v52 = v9 + 32;
          if (v40 >= v9 + 32) {
            break;
          }
          if (*(char *)(v9 + 23) < 0)
          {
            char v47 = *(const void **)v9;
            size_t v48 = *(void *)(v9 + 8);
          }
          else
          {
            size_t v48 = *(unsigned __int8 *)(v9 + 23);
            char v47 = (const void *)v9;
          }
          if ((unint64_t)v33 >= v48) {
            size_t v49 = v48;
          }
          else {
            size_t v49 = (size_t)v33;
          }
          int v50 = memcmp(v47, v34, v49);
          BOOL v51 = v48 < (unint64_t)v33;
          if (v50) {
            BOOL v51 = v50 < 0;
          }
          v9 -= 32;
          if (v51)
          {
            unint64_t v52 = v9 + 32;
            break;
          }
        }
        uint64_t v9 = v314;
      }
      else
      {
        do
        {
          if (v41[23] < 0)
          {
            int v43 = *(char **)v41;
            size_t v42 = *((void *)v41 + 1);
          }
          else
          {
            size_t v42 = v41[23];
            int v43 = v41;
          }
          if ((unint64_t)v33 >= v42) {
            size_t v44 = v42;
          }
          else {
            size_t v44 = (size_t)v33;
          }
          int v45 = memcmp(v43, v34, v44);
          BOOL v46 = v42 < (unint64_t)v33;
          if (v45) {
            BOOL v46 = v45 < 0;
          }
          v41 -= 32;
        }
        while (!v46);
        unint64_t v52 = (unint64_t)(v41 + 32);
      }
      std::string::size_type v10 = (const void **)v40;
      if (v40 < v52)
      {
        int v53 = (char *)v52;
        do
        {
          long long v54 = *(_OWORD *)v10;
          v322 = v10[2];
          long long v321 = v54;
          long long v55 = *(_OWORD *)v53;
          v10[2] = (const void *)*((void *)v53 + 2);
          *(_OWORD *)std::string::size_type v10 = v55;
          long long v56 = v321;
          *((void *)v53 + 2) = v322;
          *(_OWORD *)int v53 = v56;
          uint64_t v57 = v10[3];
          v10[3] = (const void *)*((void *)v53 + 3);
          *((void *)v53 + 3) = v57;
          if (SHIBYTE(v319) >= 0) {
            uint64_t v58 = __p;
          }
          else {
            uint64_t v58 = (void **)__p[0];
          }
          if (SHIBYTE(v319) >= 0) {
            int v59 = (void *)(HIBYTE(v319) & 0x7F);
          }
          else {
            int v59 = __p[1];
          }
          uint64_t v60 = (char *)(v10 + 4);
          do
          {
            if (v60[23] < 0)
            {
              uint64_t v62 = *(char **)v60;
              size_t v61 = *((void *)v60 + 1);
            }
            else
            {
              size_t v61 = v60[23];
              uint64_t v62 = v60;
            }
            if ((unint64_t)v59 >= v61) {
              size_t v63 = v61;
            }
            else {
              size_t v63 = (size_t)v59;
            }
            int v64 = memcmp(v62, v58, v63);
            BOOL v65 = v61 < (unint64_t)v59;
            if (v64) {
              BOOL v65 = v64 < 0;
            }
            v60 += 32;
          }
          while (v65);
          std::string::size_type v10 = (const void **)(v60 - 32);
          unsigned int v66 = v53 - 32;
          do
          {
            if (v66[23] < 0)
            {
              uint64_t v68 = *(char **)v66;
              size_t v67 = *((void *)v66 + 1);
            }
            else
            {
              size_t v67 = v66[23];
              uint64_t v68 = v66;
            }
            if ((unint64_t)v59 >= v67) {
              size_t v69 = v67;
            }
            else {
              size_t v69 = (size_t)v59;
            }
            int v70 = memcmp(v68, v58, v69);
            BOOL v71 = v67 < (unint64_t)v59;
            if (v70) {
              BOOL v71 = v70 < 0;
            }
            v66 -= 32;
          }
          while (!v71);
          int v53 = v66 + 32;
        }
        while (v10 < (const void **)v66 + 4);
        a2 = (uint64_t)v312;
        uint64_t v9 = v314;
      }
      int v72 = (void **)(v10 - 4);
      if (v10 - 4 != (const void **)a1)
      {
        if (*(char *)(a1 + 23) < 0) {
          operator delete(*(void **)a1);
        }
        long long v73 = *(_OWORD *)v72;
        *(void *)(a1 + 16) = *(v10 - 2);
        *(_OWORD *)a1 = v73;
        *((unsigned char *)v10 - 9) = 0;
        *((unsigned char *)v10 - 32) = 0;
        *(void *)(a1 + 24) = *(v10 - 1);
      }
      if (*((char *)v10 - 9) < 0) {
        operator delete(*v72);
      }
      long long v74 = *(_OWORD *)__p;
      *(v10 - 2) = v319;
      *(_OWORD *)int v72 = v74;
      HIBYTE(v319) = 0;
      LOBYTE(__p[0]) = 0;
      *(v10 - 1) = v320;
      if (SHIBYTE(v319) < 0) {
        operator delete(__p[0]);
      }
      if (v40 < v52)
      {
LABEL_106:
        sub_1CC44EC38(a1, v10 - 4, a3, a4 & 1);
        goto LABEL_107;
      }
      BOOL v75 = sub_1CC45046C(a1, (uint64_t)(v10 - 4));
      if (sub_1CC45046C((uint64_t)v10, a2)) {
        break;
      }
      if (!v75) {
        goto LABEL_106;
      }
    }
    a2 = (uint64_t)(v10 - 4);
    if (!v75) {
      continue;
    }
    break;
  }
}

__n128 sub_1CC44FF38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_1CC450798(a1, (long long *)a2, (long long *)a3, (long long *)a4);
  char v10 = *(unsigned char *)(a4 + 23);
  BOOL v11 = v10 < 0;
  if (v10 >= 0) {
    uint64_t v12 = (const void *)a4;
  }
  else {
    uint64_t v12 = *(const void **)a4;
  }
  size_t v13 = v10 & 0x7F;
  if (v11) {
    size_t v14 = *(void *)(a4 + 8);
  }
  else {
    size_t v14 = v13;
  }
  if (*(char *)(a5 + 23) < 0)
  {
    uint64_t v16 = *(const void **)a5;
    size_t v15 = *(void *)(a5 + 8);
  }
  else
  {
    size_t v15 = *(unsigned __int8 *)(a5 + 23);
    uint64_t v16 = (const void *)a5;
  }
  if (v14 >= v15) {
    size_t v17 = v15;
  }
  else {
    size_t v17 = v14;
  }
  int v18 = memcmp(v16, v12, v17);
  BOOL v20 = v15 < v14;
  if (v18) {
    BOOL v20 = v18 < 0;
  }
  if (v20)
  {
    uint64_t v21 = *(void *)(a4 + 16);
    long long v22 = *(_OWORD *)a4;
    uint64_t v23 = *(void *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(void *)(a4 + 16) = v23;
    *(_OWORD *)a5 = v22;
    *(void *)(a5 + 16) = v21;
    uint64_t v24 = *(void *)(a4 + 24);
    *(void *)(a4 + 24) = *(void *)(a5 + 24);
    *(void *)(a5 + 24) = v24;
    char v25 = *(unsigned char *)(a3 + 23);
    BOOL v26 = v25 < 0;
    if (v25 >= 0) {
      size_t v27 = (const void *)a3;
    }
    else {
      size_t v27 = *(const void **)a3;
    }
    size_t v28 = v25 & 0x7F;
    if (v26) {
      size_t v29 = *(void *)(a3 + 8);
    }
    else {
      size_t v29 = v28;
    }
    if (*(char *)(a4 + 23) < 0)
    {
      long long v31 = *(const void **)a4;
      size_t v30 = *(void *)(a4 + 8);
    }
    else
    {
      size_t v30 = *(unsigned __int8 *)(a4 + 23);
      long long v31 = (const void *)a4;
    }
    if (v29 >= v30) {
      size_t v32 = v30;
    }
    else {
      size_t v32 = v29;
    }
    int v33 = memcmp(v31, v27, v32);
    BOOL v34 = v30 < v29;
    if (v33) {
      BOOL v34 = v33 < 0;
    }
    if (v34)
    {
      uint64_t v35 = *(void *)(a3 + 16);
      long long v36 = *(_OWORD *)a3;
      uint64_t v37 = *(void *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(void *)(a3 + 16) = v37;
      *(_OWORD *)a4 = v36;
      *(void *)(a4 + 16) = v35;
      uint64_t v38 = *(void *)(a3 + 24);
      *(void *)(a3 + 24) = *(void *)(a4 + 24);
      *(void *)(a4 + 24) = v38;
      char v39 = *(unsigned char *)(a2 + 23);
      BOOL v40 = v39 < 0;
      if (v39 >= 0) {
        std::string v41 = (const void *)a2;
      }
      else {
        std::string v41 = *(const void **)a2;
      }
      size_t v42 = v39 & 0x7F;
      if (v40) {
        size_t v43 = *(void *)(a2 + 8);
      }
      else {
        size_t v43 = v42;
      }
      if (*(char *)(a3 + 23) < 0)
      {
        int v45 = *(const void **)a3;
        size_t v44 = *(void *)(a3 + 8);
      }
      else
      {
        size_t v44 = *(unsigned __int8 *)(a3 + 23);
        int v45 = (const void *)a3;
      }
      if (v43 >= v44) {
        size_t v46 = v44;
      }
      else {
        size_t v46 = v43;
      }
      int v47 = memcmp(v45, v41, v46);
      BOOL v48 = v44 < v43;
      if (v47) {
        BOOL v48 = v47 < 0;
      }
      if (v48)
      {
        uint64_t v49 = *(void *)(a2 + 16);
        long long v50 = *(_OWORD *)a2;
        uint64_t v51 = *(void *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(void *)(a2 + 16) = v51;
        *(_OWORD *)a3 = v50;
        *(void *)(a3 + 16) = v49;
        uint64_t v52 = *(void *)(a2 + 24);
        *(void *)(a2 + 24) = *(void *)(a3 + 24);
        *(void *)(a3 + 24) = v52;
        char v53 = *(unsigned char *)(a1 + 23);
        BOOL v54 = v53 < 0;
        if (v53 >= 0) {
          long long v55 = (const void *)a1;
        }
        else {
          long long v55 = *(const void **)a1;
        }
        size_t v56 = v53 & 0x7F;
        if (v54) {
          size_t v57 = *(void *)(a1 + 8);
        }
        else {
          size_t v57 = v56;
        }
        if (*(char *)(a2 + 23) < 0)
        {
          int v59 = *(const void **)a2;
          size_t v58 = *(void *)(a2 + 8);
        }
        else
        {
          size_t v58 = *(unsigned __int8 *)(a2 + 23);
          int v59 = (const void *)a2;
        }
        if (v57 >= v58) {
          size_t v60 = v58;
        }
        else {
          size_t v60 = v57;
        }
        int v61 = memcmp(v59, v55, v60);
        BOOL v62 = v58 < v57;
        if (v61) {
          BOOL v62 = v61 < 0;
        }
        if (v62)
        {
          uint64_t v63 = *(void *)(a1 + 16);
          __n128 result = *(__n128 *)a1;
          uint64_t v64 = *(void *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(void *)(a1 + 16) = v64;
          *(__n128 *)a2 = result;
          *(void *)(a2 + 16) = v63;
          uint64_t v65 = *(void *)(a1 + 24);
          *(void *)(a1 + 24) = *(void *)(a2 + 24);
          *(void *)(a2 + 24) = v65;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CC4501BC(const void **a1, void *__s1, const void **a3)
{
  char v6 = *((unsigned char *)a1 + 23);
  BOOL v7 = v6 < 0;
  if (v6 >= 0) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = *a1;
  }
  size_t v9 = v6 & 0x7F;
  if (v7) {
    size_t v10 = (size_t)a1[1];
  }
  else {
    size_t v10 = v9;
  }
  if (*((char *)__s1 + 23) < 0)
  {
    uint64_t v12 = (void *)*__s1;
    size_t v11 = __s1[1];
  }
  else
  {
    size_t v11 = *((unsigned __int8 *)__s1 + 23);
    uint64_t v12 = __s1;
  }
  if (v10 >= v11) {
    size_t v13 = v11;
  }
  else {
    size_t v13 = v10;
  }
  int v14 = memcmp(v12, v8, v13);
  BOOL v15 = v11 < v10;
  if (v14) {
    BOOL v15 = v14 < 0;
  }
  size_t v16 = *((unsigned __int8 *)a3 + 23);
  size_t v17 = a3;
  if (v15)
  {
    if ((v16 & 0x80) != 0)
    {
      size_t v17 = *a3;
      size_t v16 = (size_t)a3[1];
    }
    if (v11 >= v16) {
      size_t v18 = v16;
    }
    else {
      size_t v18 = v11;
    }
    uint64_t result = memcmp(v17, v12, v18);
    BOOL v20 = v16 < v11;
    if (result) {
      BOOL v20 = (int)result < 0;
    }
    if (v20)
    {
      uint64_t v21 = (uint64_t *)(a1 + 3);
      long long v22 = a1[2];
      long long v23 = *(_OWORD *)a1;
      uint64_t v24 = a3[2];
      *(_OWORD *)a1 = *(_OWORD *)a3;
      a1[2] = v24;
LABEL_62:
      *(_OWORD *)a3 = v23;
      a3[2] = v22;
      long long v31 = (uint64_t *)(a3 + 3);
      goto LABEL_63;
    }
    size_t v44 = a1[2];
    long long v45 = *(_OWORD *)a1;
    size_t v46 = (const void *)__s1[2];
    *(_OWORD *)a1 = *(_OWORD *)__s1;
    a1[2] = v46;
    *(_OWORD *)__s1 = v45;
    __s1[2] = v44;
    uint64_t v21 = __s1 + 3;
    int v47 = a1[3];
    a1[3] = (const void *)__s1[3];
    __s1[3] = v47;
    char v48 = *((unsigned char *)__s1 + 23);
    BOOL v49 = v48 < 0;
    if (v48 >= 0) {
      long long v50 = __s1;
    }
    else {
      long long v50 = (void *)*__s1;
    }
    size_t v51 = v48 & 0x7F;
    if (v49) {
      size_t v52 = __s1[1];
    }
    else {
      size_t v52 = v51;
    }
    if (*((char *)a3 + 23) < 0)
    {
      BOOL v54 = *a3;
      size_t v53 = (size_t)a3[1];
    }
    else
    {
      size_t v53 = *((unsigned __int8 *)a3 + 23);
      BOOL v54 = a3;
    }
    if (v52 >= v53) {
      size_t v55 = v53;
    }
    else {
      size_t v55 = v52;
    }
    uint64_t result = memcmp(v54, v50, v55);
    BOOL v56 = v53 < v52;
    if (result) {
      BOOL v56 = (int)result < 0;
    }
    if (v56)
    {
      long long v22 = (const void *)__s1[2];
      long long v23 = *(_OWORD *)__s1;
      size_t v57 = a3[2];
      *(_OWORD *)__s1 = *(_OWORD *)a3;
      __s1[2] = v57;
      goto LABEL_62;
    }
  }
  else
  {
    if ((v16 & 0x80) != 0)
    {
      size_t v17 = *a3;
      size_t v16 = (size_t)a3[1];
    }
    if (v11 >= v16) {
      size_t v25 = v16;
    }
    else {
      size_t v25 = v11;
    }
    uint64_t result = memcmp(v17, v12, v25);
    BOOL v26 = v16 < v11;
    if (result) {
      BOOL v26 = (int)result < 0;
    }
    if (v26)
    {
      size_t v27 = (const void *)__s1[2];
      long long v28 = *(_OWORD *)__s1;
      size_t v29 = a3[2];
      *(_OWORD *)__s1 = *(_OWORD *)a3;
      __s1[2] = v29;
      *(_OWORD *)a3 = v28;
      a3[2] = v27;
      long long v31 = __s1 + 3;
      size_t v30 = (const void *)__s1[3];
      __s1[3] = a3[3];
      a3[3] = v30;
      char v32 = *((unsigned char *)a1 + 23);
      BOOL v33 = v32 < 0;
      if (v32 >= 0) {
        BOOL v34 = a1;
      }
      else {
        BOOL v34 = *a1;
      }
      size_t v35 = v32 & 0x7F;
      if (v33) {
        size_t v36 = (size_t)a1[1];
      }
      else {
        size_t v36 = v35;
      }
      if (*((char *)__s1 + 23) < 0)
      {
        uint64_t v38 = (void *)*__s1;
        size_t v37 = __s1[1];
      }
      else
      {
        size_t v37 = *((unsigned __int8 *)__s1 + 23);
        uint64_t v38 = __s1;
      }
      if (v36 >= v37) {
        size_t v39 = v37;
      }
      else {
        size_t v39 = v36;
      }
      uint64_t result = memcmp(v38, v34, v39);
      BOOL v40 = v37 < v36;
      if (result) {
        BOOL v40 = (int)result < 0;
      }
      if (v40)
      {
        std::string v41 = a1[2];
        long long v42 = *(_OWORD *)a1;
        size_t v43 = (const void *)__s1[2];
        *(_OWORD *)a1 = *(_OWORD *)__s1;
        a1[2] = v43;
        *(_OWORD *)__s1 = v42;
        __s1[2] = v41;
        uint64_t v21 = (uint64_t *)(a1 + 3);
LABEL_63:
        uint64_t v58 = *v21;
        *uint64_t v21 = *v31;
        *long long v31 = v58;
      }
    }
  }
  return result;
}

BOOL sub_1CC45046C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      char v6 = (_OWORD *)(a2 - 32);
      char v7 = *(unsigned char *)(a1 + 23);
      BOOL v8 = v7 < 0;
      if (v7 >= 0) {
        size_t v9 = (const void *)a1;
      }
      else {
        size_t v9 = *(const void **)a1;
      }
      size_t v10 = v7 & 0x7F;
      if (v8) {
        size_t v11 = *(void *)(a1 + 8);
      }
      else {
        size_t v11 = v10;
      }
      if (*(char *)(a2 - 9) < 0)
      {
        size_t v13 = *(const void **)(a2 - 32);
        size_t v12 = *(void *)(a2 - 24);
      }
      else
      {
        size_t v12 = *(unsigned __int8 *)(a2 - 9);
        size_t v13 = (const void *)(a2 - 32);
      }
      if (v11 >= v12) {
        size_t v14 = v12;
      }
      else {
        size_t v14 = v11;
      }
      int v15 = memcmp(v13, v9, v14);
      BOOL v16 = v12 < v11;
      if (v15) {
        BOOL v16 = v15 < 0;
      }
      if (v16)
      {
        uint64_t v17 = *(void *)(a1 + 16);
        long long v18 = *(_OWORD *)a1;
        uint64_t v19 = *(void *)(a2 - 16);
        *(_OWORD *)a1 = *v6;
        *(void *)(a1 + 16) = v19;
        *char v6 = v18;
        *(void *)(a2 - 16) = v17;
        uint64_t v20 = *(void *)(a1 + 24);
        *(void *)(a1 + 24) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v20;
      }
      return 1;
    case 3:
      sub_1CC4501BC((const void **)a1, (void *)(a1 + 32), (const void **)(a2 - 32));
      return 1;
    case 4:
      sub_1CC450798(a1, (long long *)(a1 + 32), (long long *)(a1 + 64), (long long *)(a2 - 32));
      return 1;
    case 5:
      sub_1CC44FF38(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32);
      return 1;
    default:
      uint64_t v21 = (const void **)(a1 + 64);
      sub_1CC4501BC((const void **)a1, (void *)(a1 + 32), (const void **)(a1 + 64));
      uint64_t v22 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v23 = 0;
      int v24 = 0;
      break;
  }
  while (1)
  {
    char v25 = *((unsigned char *)v21 + 23);
    BOOL v26 = v25 < 0;
    if (v25 >= 0) {
      size_t v27 = v21;
    }
    else {
      size_t v27 = *v21;
    }
    size_t v28 = v25 & 0x7F;
    if (v26) {
      size_t v29 = (size_t)v21[1];
    }
    else {
      size_t v29 = v28;
    }
    if (*(char *)(v22 + 23) < 0)
    {
      long long v31 = *(const void **)v22;
      size_t v30 = *(void *)(v22 + 8);
    }
    else
    {
      size_t v30 = *(unsigned __int8 *)(v22 + 23);
      long long v31 = (const void *)v22;
    }
    if (v29 >= v30) {
      size_t v32 = v30;
    }
    else {
      size_t v32 = v29;
    }
    int v33 = memcmp(v31, v27, v32);
    BOOL v34 = v30 < v29;
    if (v33) {
      BOOL v34 = v33 < 0;
    }
    if (v34)
    {
      long long v50 = *(_OWORD *)v22;
      uint64_t v35 = *(void *)(v22 + 16);
      uint64_t v36 = *(void *)(v22 + 24);
      *(void *)(v22 + 8) = 0;
      *(void *)(v22 + 16) = 0;
      *(void *)uint64_t v22 = 0;
      uint64_t v51 = v35;
      uint64_t v52 = v36;
      uint64_t v37 = v23;
      while (1)
      {
        uint64_t v38 = a1 + v37;
        size_t v39 = (void **)(a1 + v37 + 96);
        if (*(char *)(a1 + v37 + 119) < 0) {
          operator delete(*v39);
        }
        *(_OWORD *)size_t v39 = *(_OWORD *)(v38 + 64);
        *(void *)(a1 + v37 + 112) = *(void *)(v38 + 80);
        *(unsigned char *)(v38 + 87) = 0;
        *(unsigned char *)(v38 + 64) = 0;
        *(void *)(v38 + 120) = *(void *)(v38 + 88);
        if (v37 == -64) {
          break;
        }
        char v40 = *(unsigned char *)(a1 + v37 + 55);
        if (v40 >= 0) {
          std::string v41 = (const void *)(a1 + v37 + 32);
        }
        else {
          std::string v41 = *(const void **)(a1 + v37 + 32);
        }
        if (v40 >= 0) {
          size_t v42 = v40 & 0x7F;
        }
        else {
          size_t v42 = *(void *)(a1 + v37 + 40);
        }
        if (v51 >= 0) {
          size_t v43 = HIBYTE(v51) & 0x7F;
        }
        else {
          size_t v43 = *((void *)&v50 + 1);
        }
        if (v51 >= 0) {
          size_t v44 = &v50;
        }
        else {
          size_t v44 = (long long *)v50;
        }
        if (v42 >= v43) {
          size_t v45 = v43;
        }
        else {
          size_t v45 = v42;
        }
        int v46 = memcmp(v44, v41, v45);
        BOOL v47 = v43 < v42;
        if (v46) {
          BOOL v47 = v46 < 0;
        }
        v37 -= 32;
        if (!v47)
        {
          uint64_t v48 = a1 + v37 + 96;
          goto LABEL_57;
        }
      }
      uint64_t v48 = a1;
LABEL_57:
      if (*(char *)(v48 + 23) < 0) {
        operator delete(*(void **)v48);
      }
      *(_OWORD *)uint64_t v48 = v50;
      uint64_t v49 = v52;
      *(void *)(v48 + 16) = v51;
      *(void *)(v48 + 24) = v49;
      if (++v24 == 8) {
        return v22 + 32 == a2;
      }
    }
    uint64_t v21 = (const void **)v22;
    v23 += 32;
    v22 += 32;
    if (v22 == a2) {
      return 1;
    }
  }
}

__n128 sub_1CC450798(uint64_t a1, long long *a2, long long *a3, long long *a4)
{
  sub_1CC4501BC((const void **)a1, a2, (const void **)a3);
  char v8 = *((unsigned char *)a3 + 23);
  BOOL v9 = v8 < 0;
  if (v8 >= 0) {
    size_t v10 = a3;
  }
  else {
    size_t v10 = *(const void **)a3;
  }
  size_t v11 = v8 & 0x7F;
  if (v9) {
    size_t v12 = *((void *)a3 + 1);
  }
  else {
    size_t v12 = v11;
  }
  if (*((char *)a4 + 23) < 0)
  {
    size_t v14 = *(const void **)a4;
    size_t v13 = *((void *)a4 + 1);
  }
  else
  {
    size_t v13 = *((unsigned __int8 *)a4 + 23);
    size_t v14 = a4;
  }
  if (v12 >= v13) {
    size_t v15 = v13;
  }
  else {
    size_t v15 = v12;
  }
  int v16 = memcmp(v14, v10, v15);
  BOOL v18 = v13 < v12;
  if (v16) {
    BOOL v18 = v16 < 0;
  }
  if (v18)
  {
    uint64_t v19 = *((void *)a3 + 2);
    long long v20 = *a3;
    uint64_t v21 = *((void *)a4 + 2);
    *a3 = *a4;
    *((void *)a3 + 2) = v21;
    *a4 = v20;
    *((void *)a4 + 2) = v19;
    uint64_t v22 = *((void *)a3 + 3);
    *((void *)a3 + 3) = *((void *)a4 + 3);
    *((void *)a4 + 3) = v22;
    char v23 = *((unsigned char *)a2 + 23);
    BOOL v24 = v23 < 0;
    if (v23 >= 0) {
      char v25 = a2;
    }
    else {
      char v25 = *(const void **)a2;
    }
    size_t v26 = v23 & 0x7F;
    if (v24) {
      size_t v27 = *((void *)a2 + 1);
    }
    else {
      size_t v27 = v26;
    }
    if (*((char *)a3 + 23) < 0)
    {
      size_t v29 = *(const void **)a3;
      size_t v28 = *((void *)a3 + 1);
    }
    else
    {
      size_t v28 = *((unsigned __int8 *)a3 + 23);
      size_t v29 = a3;
    }
    if (v27 >= v28) {
      size_t v30 = v28;
    }
    else {
      size_t v30 = v27;
    }
    int v31 = memcmp(v29, v25, v30);
    BOOL v32 = v28 < v27;
    if (v31) {
      BOOL v32 = v31 < 0;
    }
    if (v32)
    {
      uint64_t v33 = *((void *)a2 + 2);
      long long v34 = *a2;
      uint64_t v35 = *((void *)a3 + 2);
      *a2 = *a3;
      *((void *)a2 + 2) = v35;
      *a3 = v34;
      *((void *)a3 + 2) = v33;
      uint64_t v36 = *((void *)a2 + 3);
      *((void *)a2 + 3) = *((void *)a3 + 3);
      *((void *)a3 + 3) = v36;
      char v37 = *(unsigned char *)(a1 + 23);
      BOOL v38 = v37 < 0;
      if (v37 >= 0) {
        size_t v39 = (const void *)a1;
      }
      else {
        size_t v39 = *(const void **)a1;
      }
      size_t v40 = v37 & 0x7F;
      if (v38) {
        size_t v41 = *(void *)(a1 + 8);
      }
      else {
        size_t v41 = v40;
      }
      if (*((char *)a2 + 23) < 0)
      {
        size_t v43 = *(const void **)a2;
        size_t v42 = *((void *)a2 + 1);
      }
      else
      {
        size_t v42 = *((unsigned __int8 *)a2 + 23);
        size_t v43 = a2;
      }
      if (v41 >= v42) {
        size_t v44 = v42;
      }
      else {
        size_t v44 = v41;
      }
      int v45 = memcmp(v43, v39, v44);
      BOOL v46 = v42 < v41;
      if (v45) {
        BOOL v46 = v45 < 0;
      }
      if (v46)
      {
        uint64_t v47 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v48 = *((void *)a2 + 2);
        *(_OWORD *)a1 = *a2;
        *(void *)(a1 + 16) = v48;
        *a2 = (__int128)result;
        *((void *)a2 + 2) = v47;
        uint64_t v49 = *(void *)(a1 + 24);
        *(void *)(a1 + 24) = *((void *)a2 + 3);
        *((void *)a2 + 3) = v49;
      }
    }
  }
  return result;
}

void sub_1CC450988()
{
}

void *sub_1CC45099C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F26126B8;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC4509E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F26126B8;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CC450A10(uint64_t a1)
{
  return **(void **)(a1 + 8);
}

void sub_1CC450A20()
{
}

void *sub_1CC450A34(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F2612700;
  result[1] = v3;
  return result;
}

uint64_t sub_1CC450A7C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2612700;
  a2[1] = v2;
  return result;
}

uint64_t sub_1CC450AA8(uint64_t a1)
{
  return *(void *)(**(void **)(a1 + 8) + 56);
}

uint64_t sub_1CC450AB8()
{
  int v5 = 1;
  int v3 = -1;
  uint64_t v4 = &v3;
  *(void *)&long long v2 = "N";
  *((void *)&v2 + 1) = 1;
  v1.n128_u64[0] = (unint64_t)"Function number to canonicalize.";
  v1.n128_u64[1] = 32;
  sub_1CD573B64(&v5, &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCD3338, &dword_1CB82C000);
}

void sub_1CC450B40()
{
}

uint64_t llvm::PhysicalRegisterUsageInfo::setTargetMachine(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

uint64_t llvm::PhysicalRegisterUsageInfo::doInitialization(llvm::PhysicalRegisterUsageInfo *this, llvm::Module *a2)
{
  long long v2 = (char *)a2 + 24;
  int v3 = -1;
  uint64_t v4 = v2;
  do
  {
    uint64_t v4 = (char *)*((void *)v4 + 1);
    ++v3;
  }
  while (v4 != v2);
  sub_1CC450C24((uint64_t)this + 32, v3);
  return 0;
}

void *sub_1CC450C24(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v12 = *(unsigned int *)(a1 + 16);
    if (v12)
    {
      uint64_t v13 = 32 * v12;
      do
      {
        *__n128 result = -4096;
        result += 4;
        v13 -= 32;
      }
      while (v13);
    }
    if (v3)
    {
      uint64_t v14 = 32 * v3;
      size_t v15 = (void *)v4;
      do
      {
        if (*v15 != -4096 && *v15 != -8192)
        {
          uint64_t v17 = v15;
          BOOL v18 = 0;
          sub_1CC451048((uint64_t *)a1, v15, &v18);
          size_t v15 = v17;
          int v16 = v18;
          *BOOL v18 = *v17;
          v16[1] = 0;
          v16[2] = 0;
          v16[3] = 0;
          *(_OWORD *)(v16 + 1) = *(_OWORD *)(v17 + 1);
          v16[3] = v17[3];
          v17[1] = 0;
          v17[2] = 0;
          v17[3] = 0;
          ++*(_DWORD *)(a1 + 8);
        }
        v15 += 4;
        v14 -= 32;
      }
      while (v14);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      *__n128 result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t llvm::PhysicalRegisterUsageInfo::doFinalization(llvm::PhysicalRegisterUsageInfo *this, llvm::Module *a2)
{
  if (byte_1EBCD3478)
  {
    size_t v15 = llvm::errs(this);
    (*(void (**)(llvm::PhysicalRegisterUsageInfo *, void *, void))(*(void *)this + 40))(this, v15, 0);
  }
  uint64_t v3 = (void *)((char *)this + 32);
  int v4 = *((_DWORD *)this + 10);
  sub_1CC450FE0((unsigned int *)this + 8);
  if (v4)
  {
    int v6 = 1 << (33 - __clz(v4 - 1));
    if (v6 <= 64) {
      unsigned int v7 = 64;
    }
    else {
      unsigned int v7 = v6;
    }
    if (v7 == *((_DWORD *)this + 12))
    {
      *((void *)this + 5) = 0;
      uint64_t v13 = 32 * v7;
      uint64_t v14 = (void *)*((void *)this + 4);
      do
      {
        *uint64_t v14 = -4096;
        v14 += 4;
        v13 -= 32;
      }
      while (v13);
    }
    else
    {
      MEMORY[0x1D25D9CD0](*((void *)this + 4), 8);
      unint64_t v8 = (4 * v7 / 3 + 1) | ((unint64_t)(4 * v7 / 3 + 1) >> 1);
      unint64_t v9 = v8 | (v8 >> 2) | ((v8 | (v8 >> 2)) >> 4);
      LODWORD(v9) = (((v9 | (v9 >> 8)) >> 16) | v9 | (v9 >> 8)) + 1;
      *((_DWORD *)this + 12) = v9;
      uint64_t v10 = operator new(32 * v9, (std::align_val_t)8uLL);
      *((void *)this + 4) = v10;
      *((void *)this + 5) = 0;
      uint64_t v11 = *((unsigned int *)this + 12);
      if (v11)
      {
        uint64_t v12 = 32 * v11;
        do
        {
          *uint64_t v10 = -4096;
          v10 += 4;
          v12 -= 32;
        }
        while (v12);
      }
    }
  }
  else if (*((_DWORD *)this + 12))
  {
    MEMORY[0x1D25D9CD0](*v3, 8);
    *uint64_t v3 = 0;
    *((void *)this + 5) = 0;
    *((_DWORD *)this + 12) = 0;
  }
  else
  {
    *((void *)this + 5) = 0;
  }
  return 0;
}

double llvm::PhysicalRegisterUsageInfo::storeUpdateRegUsageInfo(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4)
{
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  sub_1CBA85A80(&v10, a3, (uint64_t)a3 + 4 * a4, a4);
  uint64_t v9 = a2;
  int v6 = sub_1CC4510E4((uint64_t *)(a1 + 32), &v9);
  unsigned int v7 = (void *)v6[1];
  if (v7)
  {
    void v6[2] = v7;
    operator delete(v7);
  }
  double result = *(double *)&v10;
  *(_OWORD *)(v6 + 1) = v10;
  v6[3] = v11;
  return result;
}

uint64_t llvm::PhysicalRegisterUsageInfo::getRegUsageInfo(llvm::PhysicalRegisterUsageInfo *this, const llvm::Function *a2)
{
  int v4 = a2;
  uint64_t v5 = 0;
  if (!sub_1CC451048((uint64_t *)this + 4, &v4, &v5)) {
    return 0;
  }
  uint64_t result = 0;
  if (v5 != *((void *)this + 4) + 32 * *((unsigned int *)this + 12)) {
    return *(void *)(v5 + 8);
  }
  return result;
}

void sub_1CC450FE0(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 32 * v1;
    uint64_t v3 = (void *)(*(void *)a1 + 16);
    do
    {
      uint64_t v4 = *(v3 - 2);
      if (v4 != -4096 && v4 != -8192)
      {
        uint64_t v5 = (void *)*(v3 - 1);
        if (v5)
        {
          *uint64_t v3 = v5;
          operator delete(v5);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

uint64_t sub_1CC451048(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    unsigned int v5 = v3 - 1;
    uint64_t v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    unsigned int v7 = (void *)(*a1 + 32 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v9 = v7;
        }
        int v13 = v6 + v10++;
        uint64_t v6 = v13 & v5;
        unsigned int v7 = (void *)(v4 + 32 * v6);
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v9) {
        unsigned int v7 = v9;
      }
    }
  }
  else
  {
    unsigned int v7 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CC4510E4(uint64_t *a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CC451048(a1, a2, &v8);
  unsigned int v5 = v8;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CC451148(a1, (uint64_t)a2, a2, v8);
    uint64_t v6 = *a2;
    void v5[2] = 0;
    v5[3] = 0;
    *unsigned int v5 = v6;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CC451148(uint64_t *a1, uint64_t a2, void *a3, void *a4)
{
  int v4 = *((_DWORD *)a1 + 2);
  unsigned int v5 = *((_DWORD *)a1 + 4);
  if (4 * v4 + 4 >= 3 * v5)
  {
    v5 *= 2;
  }
  else if (v5 + ~v4 - *((_DWORD *)a1 + 3) > v5 >> 3)
  {
    goto LABEL_3;
  }
  uint64_t v8 = a1;
  sub_1CC450C24((uint64_t)a1, v5);
  uint64_t v9 = 0;
  sub_1CC451048(v8, a3, &v9);
  a1 = v8;
  a4 = v9;
LABEL_3:
  ++*((_DWORD *)a1 + 2);
  if (*a4 != -4096) {
    --*((_DWORD *)a1 + 3);
  }
  return a4;
}

char *sub_1CC4511F8(char *result, uint64_t *****a2, uint64_t a3, char a4)
{
  unsigned int v7 = (uint64_t *****)result;
LABEL_2:
  v850 = a2 - 2;
  v851 = a2 - 1;
  v855 = a2;
  v849 = a2 - 3;
  uint64_t v8 = v7;
  while (1)
  {
    uint64_t v9 = v8;
    uint64_t v10 = (char *)v855 - (char *)v8;
    uint64_t v11 = v855 - v8;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0:
        case 1:
          return result;
        case 2:
          v373 = *(v855 - 1);
          v374 = *v9;
          v375 = *v373;
          if ((*((unsigned char *)*v373 + 23) & 0x10) != 0)
          {
            uint64_t v376 = ***v375;
            uint64_t v377 = *(void *)(v376 + 152);
            uint64_t v378 = *(unsigned int *)(v376 + 168);
            if (v378)
            {
              LODWORD(v379) = (v378 - 1) & ((v375 >> 4) ^ (v375 >> 9));
              v380 = (uint64_t ****)(v377 + 16 * v379);
              v381 = *v380;
              if (*v380 != v375)
              {
                int v382 = 1;
                do
                {
                  if (v381 == (uint64_t ***)-4096) {
                    goto LABEL_802;
                  }
                  int v383 = v379 + v382++;
                  uint64_t v379 = v383 & (v378 - 1);
                  v381 = *(uint64_t ****)(v377 + 16 * v379);
                }
                while (v381 != v375);
                v380 = (uint64_t ****)(v377 + 16 * v379);
              }
            }
            else
            {
LABEL_802:
              v380 = (uint64_t ****)(v377 + 16 * v378);
            }
            v733 = v380[1];
            size_t v735 = (size_t)*v733;
            uint64_t result = (char *)(v733 + 2);
            size_t v734 = v735;
            goto LABEL_804;
          }
          size_t v734 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_804:
          v736 = *v374;
          if ((*((unsigned char *)*v374 + 23) & 0x10) != 0)
          {
            uint64_t v737 = ***v736;
            uint64_t v738 = *(void *)(v737 + 152);
            uint64_t v739 = *(unsigned int *)(v737 + 168);
            if (v739)
            {
              LODWORD(v740) = (v739 - 1) & ((v736 >> 4) ^ (v736 >> 9));
              v741 = (uint64_t ****)(v738 + 16 * v740);
              v742 = *v741;
              if (*v741 != v736)
              {
                int v743 = 1;
                do
                {
                  if (v742 == (uint64_t ***)-4096) {
                    goto LABEL_820;
                  }
                  int v744 = v740 + v743++;
                  uint64_t v740 = v744 & (v739 - 1);
                  v742 = *(uint64_t ****)(v738 + 16 * v740);
                }
                while (v742 != v736);
                v741 = (uint64_t ****)(v738 + 16 * v740);
              }
            }
            else
            {
LABEL_820:
              v741 = (uint64_t ****)(v738 + 16 * v739);
            }
            v757 = v741[1];
            size_t v760 = (size_t)*v757;
            v758 = (char *)(v757 + 2);
            size_t v759 = v760;
            goto LABEL_822;
          }
          size_t v759 = 0;
          v758 = &byte_1CFBCE98E;
LABEL_822:
          if (v759 >= v734) {
            size_t v761 = v734;
          }
          else {
            size_t v761 = v759;
          }
          if (v761 && (uint64_t result = (char *)memcmp(result, v758, v761), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v734 >= v759)
          {
            return result;
          }
          *uint64_t v9 = v373;
          *(v855 - 1) = v374;
          return result;
        case 3:
          return sub_1CC453CD4(v9, v9 + 1, v851);
        case 4:
          return sub_1CC454E30(v9, v9 + 1, v9 + 2, v851);
        case 5:
          v384 = v9 + 2;
          v385 = v9 + 3;
          sub_1CC454E30(v9, v9 + 1, v9 + 2, v9 + 3);
          v386 = *(v855 - 1);
          v387 = v9[3];
          v388 = *v386;
          if ((*((unsigned char *)*v386 + 23) & 0x10) != 0)
          {
            uint64_t v389 = ***v388;
            uint64_t v390 = *(void *)(v389 + 152);
            uint64_t v391 = *(unsigned int *)(v389 + 168);
            if (v391)
            {
              LODWORD(v392) = (v391 - 1) & ((v388 >> 4) ^ (v388 >> 9));
              v393 = (uint64_t ****)(v390 + 16 * v392);
              v394 = *v393;
              if (*v393 != v388)
              {
                int v395 = 1;
                do
                {
                  if (v394 == (uint64_t ***)-4096) {
                    goto LABEL_811;
                  }
                  int v396 = v392 + v395++;
                  uint64_t v392 = v396 & (v391 - 1);
                  v394 = *(uint64_t ****)(v390 + 16 * v392);
                }
                while (v394 != v388);
                v393 = (uint64_t ****)(v390 + 16 * v392);
              }
            }
            else
            {
LABEL_811:
              v393 = (uint64_t ****)(v390 + 16 * v391);
            }
            v745 = v393[1];
            size_t v747 = (size_t)*v745;
            uint64_t result = (char *)(v745 + 2);
            size_t v746 = v747;
            goto LABEL_813;
          }
          size_t v746 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_813:
          v748 = *v387;
          if ((*((unsigned char *)*v387 + 23) & 0x10) != 0)
          {
            uint64_t v749 = ***v748;
            uint64_t v750 = *(void *)(v749 + 152);
            uint64_t v751 = *(unsigned int *)(v749 + 168);
            if (v751)
            {
              LODWORD(v752) = (v751 - 1) & ((v748 >> 4) ^ (v748 >> 9));
              v753 = (uint64_t ****)(v750 + 16 * v752);
              v754 = *v753;
              if (*v753 != v748)
              {
                int v755 = 1;
                do
                {
                  if (v754 == (uint64_t ***)-4096) {
                    goto LABEL_831;
                  }
                  int v756 = v752 + v755++;
                  uint64_t v752 = v756 & (v751 - 1);
                  v754 = *(uint64_t ****)(v750 + 16 * v752);
                }
                while (v754 != v748);
                v753 = (uint64_t ****)(v750 + 16 * v752);
              }
            }
            else
            {
LABEL_831:
              v753 = (uint64_t ****)(v750 + 16 * v751);
            }
            v762 = v753[1];
            size_t v765 = (size_t)*v762;
            v763 = (char *)(v762 + 2);
            size_t v764 = v765;
            goto LABEL_833;
          }
          size_t v764 = 0;
          v763 = &byte_1CFBCE98E;
LABEL_833:
          if (v764 >= v746) {
            size_t v766 = v746;
          }
          else {
            size_t v766 = v764;
          }
          if (v766 && (uint64_t result = (char *)memcmp(result, v763, v766), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v746 >= v764)
          {
            return result;
          }
          *v385 = v386;
          *(v855 - 1) = v387;
          v767 = *v385;
          v768 = *v384;
          v769 = **v385;
          if ((*((unsigned char *)v769 + 23) & 0x10) != 0)
          {
            uint64_t v770 = ***v769;
            uint64_t v771 = *(void *)(v770 + 152);
            uint64_t v772 = *(unsigned int *)(v770 + 168);
            if (v772)
            {
              LODWORD(v773) = (v772 - 1) & ((v769 >> 4) ^ (v769 >> 9));
              v774 = (uint64_t ****)(v771 + 16 * v773);
              v775 = *v774;
              if (*v774 != v769)
              {
                int v776 = 1;
                do
                {
                  if (v775 == (uint64_t ***)-4096) {
                    goto LABEL_848;
                  }
                  int v777 = v773 + v776++;
                  uint64_t v773 = v777 & (v772 - 1);
                  v775 = *(uint64_t ****)(v771 + 16 * v773);
                }
                while (v775 != v769);
                v774 = (uint64_t ****)(v771 + 16 * v773);
              }
            }
            else
            {
LABEL_848:
              v774 = (uint64_t ****)(v771 + 16 * v772);
            }
            v778 = v774[1];
            size_t v780 = (size_t)*v778;
            uint64_t result = (char *)(v778 + 2);
            size_t v779 = v780;
            goto LABEL_850;
          }
          size_t v779 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_850:
          v781 = *v768;
          if ((*((unsigned char *)*v768 + 23) & 0x10) != 0)
          {
            uint64_t v782 = ***v781;
            uint64_t v783 = *(void *)(v782 + 152);
            uint64_t v784 = *(unsigned int *)(v782 + 168);
            if (v784)
            {
              LODWORD(v785) = (v784 - 1) & ((v781 >> 4) ^ (v781 >> 9));
              v786 = (uint64_t ****)(v783 + 16 * v785);
              v787 = *v786;
              if (*v786 != v781)
              {
                int v788 = 1;
                do
                {
                  if (v787 == (uint64_t ***)-4096) {
                    goto LABEL_857;
                  }
                  int v789 = v785 + v788++;
                  uint64_t v785 = v789 & (v784 - 1);
                  v787 = *(uint64_t ****)(v783 + 16 * v785);
                }
                while (v787 != v781);
                v786 = (uint64_t ****)(v783 + 16 * v785);
              }
            }
            else
            {
LABEL_857:
              v786 = (uint64_t ****)(v783 + 16 * v784);
            }
            v790 = v786[1];
            size_t v793 = (size_t)*v790;
            v791 = (char *)(v790 + 2);
            size_t v792 = v793;
            goto LABEL_859;
          }
          size_t v792 = 0;
          v791 = &byte_1CFBCE98E;
LABEL_859:
          if (v792 >= v779) {
            size_t v794 = v779;
          }
          else {
            size_t v794 = v792;
          }
          if (v794 && (uint64_t result = (char *)memcmp(result, v791, v794), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v779 >= v792)
          {
            return result;
          }
          *v384 = v767;
          *v385 = v768;
          v795 = v9[1];
          v796 = *v767;
          if ((*((unsigned char *)*v767 + 23) & 0x10) != 0)
          {
            uint64_t v797 = ***v796;
            uint64_t v798 = *(void *)(v797 + 152);
            uint64_t v799 = *(unsigned int *)(v797 + 168);
            if (v799)
            {
              LODWORD(v800) = (v799 - 1) & ((v796 >> 4) ^ (v796 >> 9));
              v801 = (uint64_t ****)(v798 + 16 * v800);
              v802 = *v801;
              if (*v801 != v796)
              {
                int v803 = 1;
                do
                {
                  if (v802 == (uint64_t ***)-4096) {
                    goto LABEL_874;
                  }
                  int v804 = v800 + v803++;
                  uint64_t v800 = v804 & (v799 - 1);
                  v802 = *(uint64_t ****)(v798 + 16 * v800);
                }
                while (v802 != v796);
                v801 = (uint64_t ****)(v798 + 16 * v800);
              }
            }
            else
            {
LABEL_874:
              v801 = (uint64_t ****)(v798 + 16 * v799);
            }
            v805 = v801[1];
            size_t v807 = (size_t)*v805;
            uint64_t result = (char *)(v805 + 2);
            size_t v806 = v807;
            goto LABEL_876;
          }
          size_t v806 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_876:
          v808 = *v795;
          if ((*((unsigned char *)*v795 + 23) & 0x10) != 0)
          {
            uint64_t v809 = ***v808;
            uint64_t v810 = *(void *)(v809 + 152);
            uint64_t v811 = *(unsigned int *)(v809 + 168);
            if (v811)
            {
              LODWORD(v812) = (v811 - 1) & ((v808 >> 4) ^ (v808 >> 9));
              v813 = (uint64_t ****)(v810 + 16 * v812);
              v814 = *v813;
              if (*v813 != v808)
              {
                int v815 = 1;
                do
                {
                  if (v814 == (uint64_t ***)-4096) {
                    goto LABEL_883;
                  }
                  int v816 = v812 + v815++;
                  uint64_t v812 = v816 & (v811 - 1);
                  v814 = *(uint64_t ****)(v810 + 16 * v812);
                }
                while (v814 != v808);
                v813 = (uint64_t ****)(v810 + 16 * v812);
              }
            }
            else
            {
LABEL_883:
              v813 = (uint64_t ****)(v810 + 16 * v811);
            }
            v817 = v813[1];
            size_t v820 = (size_t)*v817;
            v818 = (char *)(v817 + 2);
            size_t v819 = v820;
            goto LABEL_885;
          }
          size_t v819 = 0;
          v818 = &byte_1CFBCE98E;
LABEL_885:
          if (v819 >= v806) {
            size_t v821 = v806;
          }
          else {
            size_t v821 = v819;
          }
          if (v821 && (uint64_t result = (char *)memcmp(result, v818, v821), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v806 >= v819)
          {
            return result;
          }
          v9[1] = v767;
          v9[2] = v795;
          v822 = *v9;
          v823 = *v767;
          if ((*((unsigned char *)*v767 + 23) & 0x10) != 0)
          {
            uint64_t v824 = ***v823;
            uint64_t v825 = *(void *)(v824 + 152);
            uint64_t v826 = *(unsigned int *)(v824 + 168);
            if (v826)
            {
              LODWORD(v827) = (v826 - 1) & ((v823 >> 4) ^ (v823 >> 9));
              v828 = (uint64_t ****)(v825 + 16 * v827);
              v829 = *v828;
              if (*v828 != v823)
              {
                int v830 = 1;
                do
                {
                  if (v829 == (uint64_t ***)-4096) {
                    goto LABEL_904;
                  }
                  int v831 = v827 + v830++;
                  uint64_t v827 = v831 & (v826 - 1);
                  v829 = *(uint64_t ****)(v825 + 16 * v827);
                }
                while (v829 != v823);
                v828 = (uint64_t ****)(v825 + 16 * v827);
              }
            }
            else
            {
LABEL_904:
              v828 = (uint64_t ****)(v825 + 16 * v826);
            }
            v832 = v828[1];
            size_t v834 = (size_t)*v832;
            uint64_t result = (char *)(v832 + 2);
            size_t v833 = v834;
            goto LABEL_906;
          }
          size_t v833 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_906:
          v835 = *v822;
          if ((*((unsigned char *)*v822 + 23) & 0x10) != 0)
          {
            uint64_t v836 = ***v835;
            uint64_t v837 = *(void *)(v836 + 152);
            uint64_t v838 = *(unsigned int *)(v836 + 168);
            if (v838)
            {
              LODWORD(v839) = (v838 - 1) & ((v835 >> 4) ^ (v835 >> 9));
              v840 = (uint64_t ****)(v837 + 16 * v839);
              v841 = *v840;
              if (*v840 != v835)
              {
                int v842 = 1;
                do
                {
                  if (v841 == (uint64_t ***)-4096) {
                    goto LABEL_913;
                  }
                  int v843 = v839 + v842++;
                  uint64_t v839 = v843 & (v838 - 1);
                  v841 = *(uint64_t ****)(v837 + 16 * v839);
                }
                while (v841 != v835);
                v840 = (uint64_t ****)(v837 + 16 * v839);
              }
            }
            else
            {
LABEL_913:
              v840 = (uint64_t ****)(v837 + 16 * v838);
            }
            v844 = v840[1];
            size_t v847 = (size_t)*v844;
            v845 = (char *)(v844 + 2);
            size_t v846 = v847;
            goto LABEL_915;
          }
          size_t v846 = 0;
          v845 = &byte_1CFBCE98E;
LABEL_915:
          if (v846 >= v833) {
            size_t v848 = v833;
          }
          else {
            size_t v848 = v846;
          }
          if (v848 && (uint64_t result = (char *)memcmp(result, v845, v848), result))
          {
            if ((result & 0x80000000) == 0) {
              return result;
            }
          }
          else if (v833 >= v846)
          {
            return result;
          }
          *uint64_t v9 = v767;
          v9[1] = v822;
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    v856 = v9;
    if (v10 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v9 == v855) {
        return result;
      }
      int64_t v458 = (unint64_t)(v11 - 2) >> 1;
      int64_t v858 = v458;
      do
      {
        int64_t v459 = v458;
        if (v858 >= v458)
        {
          uint64_t v460 = (2 * v458) | 1;
          v461 = &v9[v460];
          v462 = v461;
          if (2 * v458 + 2 < v11)
          {
            v463 = **v461;
            if ((*((unsigned char *)v463 + 23) & 0x10) != 0)
            {
              uint64_t v464 = ***v463;
              uint64_t v465 = *(void *)(v464 + 152);
              uint64_t v466 = *(unsigned int *)(v464 + 168);
              if (v466)
              {
                LODWORD(v467) = (v466 - 1) & ((v463 >> 4) ^ (v463 >> 9));
                v468 = (uint64_t ****)(v465 + 16 * v467);
                v469 = *v468;
                if (*v468 != v463)
                {
                  int v470 = 1;
                  do
                  {
                    if (v469 == (uint64_t ***)-4096) {
                      goto LABEL_508;
                    }
                    int v471 = v467 + v470++;
                    uint64_t v467 = v471 & (v466 - 1);
                    v469 = *(uint64_t ****)(v465 + 16 * v467);
                  }
                  while (v469 != v463);
                  v468 = (uint64_t ****)(v465 + 16 * v467);
                }
              }
              else
              {
LABEL_508:
                v468 = (uint64_t ****)(v465 + 16 * v466);
              }
              v472 = v468[1];
              size_t v475 = (size_t)*v472;
              v473 = (char *)(v472 + 2);
              size_t v474 = v475;
            }
            else
            {
              size_t v474 = 0;
              v473 = &byte_1CFBCE98E;
            }
            v476 = v461[1];
            v462 = v461 + 1;
            v477 = *v476;
            if ((*((unsigned char *)*v476 + 23) & 0x10) != 0)
            {
              uint64_t v478 = ***v477;
              uint64_t v479 = *(void *)(v478 + 152);
              uint64_t v480 = *(unsigned int *)(v478 + 168);
              if (v480)
              {
                LODWORD(v481) = (v480 - 1) & ((v477 >> 4) ^ (v477 >> 9));
                v482 = (uint64_t ****)(v479 + 16 * v481);
                v483 = *v482;
                if (*v482 != v477)
                {
                  int v484 = 1;
                  do
                  {
                    if (v483 == (uint64_t ***)-4096) {
                      goto LABEL_517;
                    }
                    int v485 = v481 + v484++;
                    uint64_t v481 = v485 & (v480 - 1);
                    v483 = *(uint64_t ****)(v479 + 16 * v481);
                  }
                  while (v483 != v477);
                  v482 = (uint64_t ****)(v479 + 16 * v481);
                }
              }
              else
              {
LABEL_517:
                v482 = (uint64_t ****)(v479 + 16 * v480);
              }
              v486 = v482[1];
              size_t v489 = (size_t)*v486;
              v487 = (char *)(v486 + 2);
              size_t v488 = v489;
            }
            else
            {
              size_t v488 = 0;
              v487 = &byte_1CFBCE98E;
            }
            if (v488 >= v474) {
              size_t v490 = v474;
            }
            else {
              size_t v490 = v488;
            }
            if (v490 && (int v491 = memcmp(v473, v487, v490)) != 0)
            {
              int v492 = (v491 >> 31) | 1;
            }
            else
            {
              if (v474 < v488) {
                int v492 = -1;
              }
              else {
                int v492 = 1;
              }
              if (v474 == v488) {
                int v492 = 0;
              }
            }
            uint64_t v9 = v856;
            if (v492 == -1) {
              uint64_t v460 = 2 * v459 + 2;
            }
            else {
              v462 = v461;
            }
          }
          v493 = &v9[v459];
          v494 = *v462;
          v495 = *v493;
          v496 = **v462;
          if ((*((unsigned char *)v496 + 23) & 0x10) != 0)
          {
            uint64_t v497 = ***v496;
            uint64_t v498 = *(void *)(v497 + 152);
            uint64_t v499 = *(unsigned int *)(v497 + 168);
            if (v499)
            {
              LODWORD(v500) = (v499 - 1) & ((v496 >> 4) ^ (v496 >> 9));
              v501 = (uint64_t ****)(v498 + 16 * v500);
              v502 = *v501;
              if (*v501 != v496)
              {
                int v503 = 1;
                do
                {
                  if (v502 == (uint64_t ***)-4096) {
                    goto LABEL_540;
                  }
                  int v504 = v500 + v503++;
                  uint64_t v500 = v504 & (v499 - 1);
                  v502 = *(uint64_t ****)(v498 + 16 * v500);
                }
                while (v502 != v496);
                v501 = (uint64_t ****)(v498 + 16 * v500);
              }
            }
            else
            {
LABEL_540:
              v501 = (uint64_t ****)(v498 + 16 * v499);
            }
            v505 = v501[1];
            size_t v507 = (size_t)*v505;
            uint64_t result = (char *)(v505 + 2);
            size_t v506 = v507;
          }
          else
          {
            size_t v506 = 0;
            uint64_t result = &byte_1CFBCE98E;
          }
          v508 = *v495;
          if ((*((unsigned char *)*v495 + 23) & 0x10) != 0)
          {
            uint64_t v509 = ***v508;
            uint64_t v510 = *(void *)(v509 + 152);
            uint64_t v511 = *(unsigned int *)(v509 + 168);
            if (v511)
            {
              LODWORD(v512) = (v511 - 1) & ((v508 >> 4) ^ (v508 >> 9));
              v513 = (uint64_t ****)(v510 + 16 * v512);
              v514 = *v513;
              if (*v513 != v508)
              {
                int v515 = 1;
                do
                {
                  if (v514 == (uint64_t ***)-4096) {
                    goto LABEL_549;
                  }
                  int v516 = v512 + v515++;
                  uint64_t v512 = v516 & (v511 - 1);
                  v514 = *(uint64_t ****)(v510 + 16 * v512);
                }
                while (v514 != v508);
                v513 = (uint64_t ****)(v510 + 16 * v512);
              }
            }
            else
            {
LABEL_549:
              v513 = (uint64_t ****)(v510 + 16 * v511);
            }
            v517 = v513[1];
            size_t v520 = (size_t)*v517;
            v518 = (char *)(v517 + 2);
            size_t v519 = v520;
          }
          else
          {
            size_t v519 = 0;
            v518 = &byte_1CFBCE98E;
          }
          if (v519 >= v506) {
            size_t v521 = v506;
          }
          else {
            size_t v521 = v519;
          }
          if (v521 && (uint64_t result = (char *)memcmp(result, v518, v521), result))
          {
            uint64_t v9 = v856;
            if ((result & 0x80000000) == 0) {
              goto LABEL_560;
            }
          }
          else
          {
            BOOL v4 = v506 >= v519;
            uint64_t v9 = v856;
            if (v4)
            {
              do
              {
LABEL_560:
                v522 = v462;
                *v493 = v494;
                if (v858 < v460) {
                  break;
                }
                uint64_t v523 = (2 * v460) | 1;
                v462 = &v856[v523];
                uint64_t v524 = 2 * v460 + 2;
                if (v524 < v11)
                {
                  v525 = **v462;
                  if ((*((unsigned char *)v525 + 23) & 0x10) != 0)
                  {
                    uint64_t v526 = ***v525;
                    uint64_t v527 = *(void *)(v526 + 152);
                    uint64_t v528 = *(unsigned int *)(v526 + 168);
                    if (v528)
                    {
                      LODWORD(v529) = (v528 - 1) & ((v525 >> 4) ^ (v525 >> 9));
                      v530 = (uint64_t ****)(v527 + 16 * v529);
                      v531 = *v530;
                      if (*v530 != v525)
                      {
                        int v532 = 1;
                        do
                        {
                          if (v531 == (uint64_t ***)-4096) {
                            goto LABEL_570;
                          }
                          int v533 = v529 + v532++;
                          uint64_t v529 = v533 & (v528 - 1);
                          v531 = *(uint64_t ****)(v527 + 16 * v529);
                        }
                        while (v531 != v525);
                        v530 = (uint64_t ****)(v527 + 16 * v529);
                      }
                    }
                    else
                    {
LABEL_570:
                      v530 = (uint64_t ****)(v527 + 16 * v528);
                    }
                    v534 = v530[1];
                    unint64_t v537 = (unint64_t)*v534;
                    v535 = (char *)(v534 + 2);
                    unint64_t v536 = v537;
                  }
                  else
                  {
                    unint64_t v536 = 0;
                    v535 = &byte_1CFBCE98E;
                  }
                  v538 = v462[1];
                  ++v462;
                  v539 = *v538;
                  if ((*((unsigned char *)*v538 + 23) & 0x10) != 0)
                  {
                    uint64_t v540 = ***v539;
                    uint64_t v541 = *(void *)(v540 + 152);
                    uint64_t v542 = *(unsigned int *)(v540 + 168);
                    if (v542)
                    {
                      LODWORD(v543) = (v542 - 1) & ((v539 >> 4) ^ (v539 >> 9));
                      v544 = (uint64_t ****)(v541 + 16 * v543);
                      v545 = *v544;
                      if (*v544 != v539)
                      {
                        int v546 = 1;
                        do
                        {
                          if (v545 == (uint64_t ***)-4096) {
                            goto LABEL_579;
                          }
                          int v547 = v543 + v546++;
                          uint64_t v543 = v547 & (v542 - 1);
                          v545 = *(uint64_t ****)(v541 + 16 * v543);
                        }
                        while (v545 != v539);
                        v544 = (uint64_t ****)(v541 + 16 * v543);
                      }
                    }
                    else
                    {
LABEL_579:
                      v544 = (uint64_t ****)(v541 + 16 * v542);
                    }
                    v548 = v544[1];
                    unint64_t v551 = (unint64_t)*v548;
                    v549 = (char *)(v548 + 2);
                    unint64_t v550 = v551;
                  }
                  else
                  {
                    unint64_t v550 = 0;
                    v549 = &byte_1CFBCE98E;
                  }
                  size_t v552 = v550 >= v536 ? v536 : v550;
                  if (v552 && (int v553 = memcmp(v535, v549, v552)) != 0)
                  {
                    int v554 = (v553 >> 31) | 1;
                  }
                  else
                  {
                    if (v536 < v550) {
                      int v554 = -1;
                    }
                    else {
                      int v554 = 1;
                    }
                    if (v536 == v550) {
                      int v554 = 0;
                    }
                  }
                  if (v554 == -1)
                  {
                    uint64_t v460 = v524;
                  }
                  else
                  {
                    v462 = &v856[v523];
                    uint64_t v460 = v523;
                  }
                }
                else
                {
                  uint64_t v460 = (2 * v460) | 1;
                }
                v494 = *v462;
                v555 = **v462;
                if ((*((unsigned char *)v555 + 23) & 0x10) != 0)
                {
                  uint64_t v556 = ***v555;
                  uint64_t v557 = *(void *)(v556 + 152);
                  uint64_t v558 = *(unsigned int *)(v556 + 168);
                  if (v558)
                  {
                    LODWORD(v559) = (v558 - 1) & ((v555 >> 4) ^ (v555 >> 9));
                    v560 = (uint64_t ****)(v557 + 16 * v559);
                    v561 = *v560;
                    if (*v560 != v555)
                    {
                      int v562 = 1;
                      do
                      {
                        if (v561 == (uint64_t ***)-4096) {
                          goto LABEL_602;
                        }
                        int v563 = v559 + v562++;
                        uint64_t v559 = v563 & (v558 - 1);
                        v561 = *(uint64_t ****)(v557 + 16 * v559);
                      }
                      while (v561 != v555);
                      v560 = (uint64_t ****)(v557 + 16 * v559);
                    }
                  }
                  else
                  {
LABEL_602:
                    v560 = (uint64_t ****)(v557 + 16 * v558);
                  }
                  v564 = v560[1];
                  unint64_t v566 = (unint64_t)*v564;
                  uint64_t result = (char *)(v564 + 2);
                  unint64_t v565 = v566;
                }
                else
                {
                  unint64_t v565 = 0;
                  uint64_t result = &byte_1CFBCE98E;
                }
                v567 = *v495;
                if ((*((unsigned char *)*v495 + 23) & 0x10) != 0)
                {
                  uint64_t v568 = ***v567;
                  uint64_t v569 = *(void *)(v568 + 152);
                  uint64_t v570 = *(unsigned int *)(v568 + 168);
                  if (v570)
                  {
                    LODWORD(v571) = (v570 - 1) & ((v567 >> 4) ^ (v567 >> 9));
                    v572 = (uint64_t ****)(v569 + 16 * v571);
                    v573 = *v572;
                    if (*v572 != v567)
                    {
                      int v574 = 1;
                      do
                      {
                        if (v573 == (uint64_t ***)-4096) {
                          goto LABEL_611;
                        }
                        int v575 = v571 + v574++;
                        uint64_t v571 = v575 & (v570 - 1);
                        v573 = *(uint64_t ****)(v569 + 16 * v571);
                      }
                      while (v573 != v567);
                      v572 = (uint64_t ****)(v569 + 16 * v571);
                    }
                  }
                  else
                  {
LABEL_611:
                    v572 = (uint64_t ****)(v569 + 16 * v570);
                  }
                  v576 = v572[1];
                  unint64_t v579 = (unint64_t)*v576;
                  v577 = (char *)(v576 + 2);
                  unint64_t v578 = v579;
                }
                else
                {
                  unint64_t v578 = 0;
                  v577 = &byte_1CFBCE98E;
                }
                size_t v580 = v578 >= v565 ? v565 : v578;
                if (v580 && (uint64_t result = (char *)memcmp(result, v577, v580), result))
                {
                  int v581 = ((int)result >> 31) | 1;
                }
                else if (v565 == v578)
                {
                  int v581 = 0;
                }
                else
                {
                  if (v565 < v578) {
                    break;
                  }
                  int v581 = 1;
                }
                v493 = v522;
              }
              while (v581 != -1);
              *v522 = v495;
              uint64_t v9 = v856;
            }
          }
        }
        int64_t v458 = v459 - 1;
      }
      while (v459);
      v582 = v855;
LABEL_636:
      v583 = v582;
      uint64_t v584 = 0;
      v859 = *v9;
      v585 = v9;
      while (1)
      {
        v586 = &v585[v584 + 1];
        uint64_t v587 = (2 * v584) | 1;
        uint64_t v588 = 2 * v584 + 2;
        if (v588 < v11) {
          break;
        }
LABEL_669:
        *v585 = *v586;
        v585 = v586;
        uint64_t v584 = v587;
        if (v587 > (uint64_t)((unint64_t)(v11 - 2) >> 1))
        {
          --v582;
          if (v586 == v583 - 1)
          {
            *v586 = v859;
            goto LABEL_734;
          }
          *v586 = *v582;
          *v582 = v859;
          uint64_t v616 = (char *)v586 - (char *)v856 + 8;
          if (v616 >= 9)
          {
            unint64_t v617 = (((unint64_t)v616 >> 3) - 2) >> 1;
            v618 = &v856[v617];
            v619 = *v618;
            v620 = **v618;
            if ((*((unsigned char *)v620 + 23) & 0x10) != 0)
            {
              uint64_t v621 = ***v620;
              uint64_t v622 = *(void *)(v621 + 152);
              uint64_t v623 = *(unsigned int *)(v621 + 168);
              if (!v623) {
                goto LABEL_683;
              }
              LODWORD(v624) = (v623 - 1) & ((v620 >> 4) ^ (v620 >> 9));
              v625 = (uint64_t ****)(v622 + 16 * v624);
              v626 = *v625;
              if (*v625 != v620)
              {
                int v627 = 1;
                while (v626 != (uint64_t ***)-4096)
                {
                  int v628 = v624 + v627++;
                  uint64_t v624 = v628 & (v623 - 1);
                  v626 = *(uint64_t ****)(v622 + 16 * v624);
                  if (v626 == v620)
                  {
                    v625 = (uint64_t ****)(v622 + 16 * v624);
                    goto LABEL_684;
                  }
                }
LABEL_683:
                v625 = (uint64_t ****)(v622 + 16 * v623);
              }
LABEL_684:
              v629 = v625[1];
              size_t v631 = (size_t)*v629;
              uint64_t result = (char *)(v629 + 2);
              size_t v630 = v631;
            }
            else
            {
              size_t v630 = 0;
              uint64_t result = &byte_1CFBCE98E;
            }
            v632 = *v586;
            v633 = **v586;
            if ((*((unsigned char *)v633 + 23) & 0x10) != 0)
            {
              uint64_t v634 = ***v633;
              uint64_t v635 = *(void *)(v634 + 152);
              uint64_t v636 = *(unsigned int *)(v634 + 168);
              if (!v636) {
                goto LABEL_692;
              }
              LODWORD(v637) = (v636 - 1) & ((v633 >> 4) ^ (v633 >> 9));
              v638 = (uint64_t ****)(v635 + 16 * v637);
              v639 = *v638;
              if (*v638 != v633)
              {
                int v640 = 1;
                while (v639 != (uint64_t ***)-4096)
                {
                  int v641 = v637 + v640++;
                  uint64_t v637 = v641 & (v636 - 1);
                  v639 = *(uint64_t ****)(v635 + 16 * v637);
                  if (v639 == v633)
                  {
                    v638 = (uint64_t ****)(v635 + 16 * v637);
                    goto LABEL_693;
                  }
                }
LABEL_692:
                v638 = (uint64_t ****)(v635 + 16 * v636);
              }
LABEL_693:
              v642 = v638[1];
              size_t v645 = (size_t)*v642;
              v643 = (char *)(v642 + 2);
              size_t v644 = v645;
            }
            else
            {
              size_t v644 = 0;
              v643 = &byte_1CFBCE98E;
            }
            if (v644 >= v630) {
              size_t v646 = v630;
            }
            else {
              size_t v646 = v644;
            }
            if (v646)
            {
              uint64_t result = (char *)memcmp(result, v643, v646);
              if (result)
              {
                if ((result & 0x80000000) == 0) {
                  goto LABEL_734;
                }
LABEL_702:
                while (2)
                {
                  v647 = v618;
                  *v586 = v619;
                  if (!v617)
                  {
LABEL_733:
                    *v647 = v632;
                    goto LABEL_734;
                  }
                  unint64_t v617 = (v617 - 1) >> 1;
                  v618 = &v856[v617];
                  v619 = *v618;
                  v648 = **v618;
                  if ((*((unsigned char *)v648 + 23) & 0x10) != 0)
                  {
                    uint64_t v649 = ***v648;
                    uint64_t v650 = *(void *)(v649 + 152);
                    uint64_t v651 = *(unsigned int *)(v649 + 168);
                    if (!v651) {
                      goto LABEL_710;
                    }
                    LODWORD(v652) = (v651 - 1) & ((v648 >> 4) ^ (v648 >> 9));
                    v653 = (uint64_t ****)(v650 + 16 * v652);
                    v654 = *v653;
                    if (*v653 != v648)
                    {
                      int v655 = 1;
                      while (v654 != (uint64_t ***)-4096)
                      {
                        int v656 = v652 + v655++;
                        uint64_t v652 = v656 & (v651 - 1);
                        v654 = *(uint64_t ****)(v650 + 16 * v652);
                        if (v654 == v648)
                        {
                          v653 = (uint64_t ****)(v650 + 16 * v652);
                          goto LABEL_711;
                        }
                      }
LABEL_710:
                      v653 = (uint64_t ****)(v650 + 16 * v651);
                    }
LABEL_711:
                    v657 = v653[1];
                    size_t v659 = (size_t)*v657;
                    uint64_t result = (char *)(v657 + 2);
                    size_t v658 = v659;
                  }
                  else
                  {
                    size_t v658 = 0;
                    uint64_t result = &byte_1CFBCE98E;
                  }
                  v660 = *v632;
                  if ((*((unsigned char *)*v632 + 23) & 0x10) != 0)
                  {
                    uint64_t v661 = ***v660;
                    uint64_t v662 = *(void *)(v661 + 152);
                    uint64_t v663 = *(unsigned int *)(v661 + 168);
                    if (!v663) {
                      goto LABEL_719;
                    }
                    LODWORD(v664) = (v663 - 1) & ((v660 >> 4) ^ (v660 >> 9));
                    v665 = (uint64_t ****)(v662 + 16 * v664);
                    v666 = *v665;
                    if (*v665 != v660)
                    {
                      int v667 = 1;
                      while (v666 != (uint64_t ***)-4096)
                      {
                        int v668 = v664 + v667++;
                        uint64_t v664 = v668 & (v663 - 1);
                        v666 = *(uint64_t ****)(v662 + 16 * v664);
                        if (v666 == v660)
                        {
                          v665 = (uint64_t ****)(v662 + 16 * v664);
                          goto LABEL_720;
                        }
                      }
LABEL_719:
                      v665 = (uint64_t ****)(v662 + 16 * v663);
                    }
LABEL_720:
                    v669 = v665[1];
                    size_t v672 = (size_t)*v669;
                    v670 = (char *)(v669 + 2);
                    size_t v671 = v672;
                  }
                  else
                  {
                    size_t v671 = 0;
                    v670 = &byte_1CFBCE98E;
                  }
                  if (v671 >= v658) {
                    size_t v673 = v658;
                  }
                  else {
                    size_t v673 = v671;
                  }
                  if (v673 && (uint64_t result = (char *)memcmp(result, v670, v673), result))
                  {
                    int v674 = ((int)result >> 31) | 1;
                  }
                  else
                  {
                    if (v658 >= v671) {
                      goto LABEL_733;
                    }
                    int v674 = -1;
                  }
                  v586 = v647;
                  if (v674 != -1) {
                    goto LABEL_733;
                  }
                  continue;
                }
              }
            }
            if (v630 < v644) {
              goto LABEL_702;
            }
          }
LABEL_734:
          BOOL v675 = v11-- <= 2;
          uint64_t v9 = v856;
          if (v675) {
            return result;
          }
          goto LABEL_636;
        }
      }
      v589 = **v586;
      if ((*((unsigned char *)v589 + 23) & 0x10) == 0)
      {
        size_t v599 = 0;
        uint64_t result = &byte_1CFBCE98E;
LABEL_647:
        v601 = *v586[1];
        if ((*((unsigned char *)v601 + 23) & 0x10) == 0)
        {
          size_t v612 = 0;
          v611 = &byte_1CFBCE98E;
          goto LABEL_656;
        }
        uint64_t v602 = ***v601;
        uint64_t v603 = *(void *)(v602 + 152);
        uint64_t v604 = *(unsigned int *)(v602 + 168);
        if (v604)
        {
          LODWORD(v605) = (v604 - 1) & ((v601 >> 4) ^ (v601 >> 9));
          v606 = (uint64_t ****)(v603 + 16 * v605);
          v607 = *v606;
          if (*v606 == v601)
          {
LABEL_655:
            v610 = v606[1];
            size_t v613 = (size_t)*v610;
            v611 = (char *)(v610 + 2);
            size_t v612 = v613;
LABEL_656:
            if (v612 >= v599) {
              size_t v614 = v599;
            }
            else {
              size_t v614 = v612;
            }
            if (v614 && (uint64_t result = (char *)memcmp(result, v611, v614), result))
            {
              int v615 = ((int)result >> 31) | 1;
            }
            else
            {
              if (v599 < v612) {
                int v615 = -1;
              }
              else {
                int v615 = 1;
              }
              if (v599 == v612) {
                int v615 = 0;
              }
            }
            if (v615 == -1)
            {
              ++v586;
              uint64_t v587 = v588;
            }
            goto LABEL_669;
          }
          int v608 = 1;
          while (v607 != (uint64_t ***)-4096)
          {
            int v609 = v605 + v608++;
            uint64_t v605 = v609 & (v604 - 1);
            v607 = *(uint64_t ****)(v603 + 16 * v605);
            if (v607 == v601)
            {
              v606 = (uint64_t ****)(v603 + 16 * v605);
              goto LABEL_655;
            }
          }
        }
        v606 = (uint64_t ****)(v603 + 16 * v604);
        goto LABEL_655;
      }
      uint64_t v590 = ***v589;
      uint64_t v591 = *(void *)(v590 + 152);
      uint64_t v592 = *(unsigned int *)(v590 + 168);
      if (v592)
      {
        LODWORD(v593) = (v592 - 1) & ((v589 >> 4) ^ (v589 >> 9));
        v594 = (uint64_t ****)(v591 + 16 * v593);
        v595 = *v594;
        if (*v594 == v589)
        {
LABEL_646:
          v598 = v594[1];
          size_t v600 = (size_t)*v598;
          uint64_t result = (char *)(v598 + 2);
          size_t v599 = v600;
          goto LABEL_647;
        }
        int v596 = 1;
        while (v595 != (uint64_t ***)-4096)
        {
          int v597 = v593 + v596++;
          uint64_t v593 = v597 & (v592 - 1);
          v595 = *(uint64_t ****)(v591 + 16 * v593);
          if (v595 == v589)
          {
            v594 = (uint64_t ****)(v591 + 16 * v593);
            goto LABEL_646;
          }
        }
      }
      v594 = (uint64_t ****)(v591 + 16 * v592);
      goto LABEL_646;
    }
    unint64_t v12 = (unint64_t)v11 >> 1;
    int v13 = &v9[(unint64_t)v11 >> 1];
    if ((unint64_t)v10 < 0x401)
    {
      sub_1CC453CD4(v13, v9, v851);
    }
    else
    {
      sub_1CC453CD4(v9, v13, v851);
      sub_1CC453CD4(v9 + 1, v13 - 1, v850);
      sub_1CC453CD4(v9 + 2, &v9[v12 + 1], v849);
      sub_1CC453CD4(v13 - 1, v13, &v9[v12 + 1]);
      uint64_t v14 = *v9;
      *uint64_t v9 = *v13;
      *int v13 = v14;
    }
    size_t v15 = *v9;
    uint64_t v854 = a3 - 1;
    v857 = *v9;
    if (a4)
    {
      int v16 = *v15;
      int v17 = *((_DWORD *)*v15 + 5) & 0x10000000;
LABEL_44:
      unsigned int v55 = (v16 >> 4) ^ (v16 >> 9);
      BOOL v56 = v9;
      do
      {
        size_t v57 = v56;
        int v59 = v56[1];
        ++v56;
        uint64_t v58 = v59;
        size_t v60 = *v59;
        if ((*((unsigned char *)*v59 + 23) & 0x10) == 0)
        {
          size_t v71 = 0;
          int v70 = &byte_1CFBCE98E;
          if (!v17) {
            goto LABEL_73;
          }
LABEL_54:
          uint64_t v73 = ***v16;
          uint64_t v74 = *(void *)(v73 + 152);
          uint64_t v75 = *(unsigned int *)(v73 + 168);
          if (v75)
          {
            LODWORD(v76) = (v75 - 1) & v55;
            __int16 v77 = (uint64_t ****)(v74 + 16 * v76);
            char v78 = *v77;
            if (*v77 == v16)
            {
LABEL_61:
              size_t v81 = v77[1];
              size_t v84 = (size_t)*v81;
              size_t v82 = (char *)(v81 + 2);
              size_t v83 = v84;
              goto LABEL_62;
            }
            int v79 = 1;
            while (v78 != (uint64_t ***)-4096)
            {
              int v80 = v76 + v79++;
              uint64_t v76 = v80 & (v75 - 1);
              char v78 = *(uint64_t ****)(v74 + 16 * v76);
              if (v78 == v16)
              {
                __int16 v77 = (uint64_t ****)(v74 + 16 * v76);
                goto LABEL_61;
              }
            }
          }
          __int16 v77 = (uint64_t ****)(v74 + 16 * v75);
          goto LABEL_61;
        }
        uint64_t v61 = ***v60;
        uint64_t v62 = *(void *)(v61 + 152);
        uint64_t v63 = *(unsigned int *)(v61 + 168);
        if (v63)
        {
          LODWORD(v64) = (v63 - 1) & ((v60 >> 4) ^ (v60 >> 9));
          uint64_t v65 = (uint64_t ****)(v62 + 16 * v64);
          unsigned int v66 = *v65;
          if (*v65 == v60) {
            goto LABEL_53;
          }
          int v67 = 1;
          while (v66 != (uint64_t ***)-4096)
          {
            int v68 = v64 + v67++;
            uint64_t v64 = v68 & (v63 - 1);
            unsigned int v66 = *(uint64_t ****)(v62 + 16 * v64);
            if (v66 == v60)
            {
              uint64_t v65 = (uint64_t ****)(v62 + 16 * v64);
              goto LABEL_53;
            }
          }
        }
        uint64_t v65 = (uint64_t ****)(v62 + 16 * v63);
LABEL_53:
        size_t v69 = v65[1];
        size_t v72 = (size_t)*v69;
        int v70 = (char *)(v69 + 2);
        size_t v71 = v72;
        if (v17) {
          goto LABEL_54;
        }
LABEL_73:
        size_t v83 = 0;
        size_t v82 = &byte_1CFBCE98E;
LABEL_62:
        if (v83 >= v71) {
          size_t v85 = v71;
        }
        else {
          size_t v85 = v83;
        }
        if (v85 && (int v86 = memcmp(v70, v82, v85)) != 0)
        {
          int v87 = (v86 >> 31) | 1;
        }
        else
        {
          if (v71 >= v83) {
            break;
          }
          int v87 = -1;
        }
      }
      while (v87 == -1);
      unsigned int v88 = v855;
      if (v57 != v856)
      {
        while (1)
        {
          char v89 = *--v88;
          BOOL v90 = *v89;
          if ((*((unsigned char *)*v89 + 23) & 0x10) != 0) {
            break;
          }
          size_t v101 = 0;
          __int32 v100 = &byte_1CFBCE98E;
          if (!v17)
          {
LABEL_105:
            size_t v113 = 0;
            size_t v112 = &byte_1CFBCE98E;
            goto LABEL_92;
          }
LABEL_84:
          uint64_t v103 = ***v16;
          uint64_t v104 = *(void *)(v103 + 152);
          uint64_t v105 = *(unsigned int *)(v103 + 168);
          if (!v105) {
            goto LABEL_90;
          }
          LODWORD(v106) = (v105 - 1) & v55;
          unsigned int v107 = (uint64_t ****)(v104 + 16 * v106);
          char v108 = *v107;
          if (*v107 != v16)
          {
            int v109 = 1;
            while (v108 != (uint64_t ***)-4096)
            {
              int v110 = v106 + v109++;
              uint64_t v106 = v110 & (v105 - 1);
              char v108 = *(uint64_t ****)(v104 + 16 * v106);
              if (v108 == v16)
              {
                unsigned int v107 = (uint64_t ****)(v104 + 16 * v106);
                goto LABEL_91;
              }
            }
LABEL_90:
            unsigned int v107 = (uint64_t ****)(v104 + 16 * v105);
          }
LABEL_91:
          size_t v111 = v107[1];
          size_t v114 = (size_t)*v111;
          size_t v112 = (char *)(v111 + 2);
          size_t v113 = v114;
LABEL_92:
          if (v113 >= v101) {
            size_t v115 = v101;
          }
          else {
            size_t v115 = v113;
          }
          if (v115 && (int v116 = memcmp(v100, v112, v115)) != 0)
          {
            int v117 = (v116 >> 31) | 1;
          }
          else if (v101 == v113)
          {
            int v117 = 0;
          }
          else
          {
            if (v101 < v113) {
              goto LABEL_139;
            }
            int v117 = 1;
          }
          if (v117 == -1) {
            goto LABEL_139;
          }
        }
        uint64_t v91 = ***v90;
        uint64_t v92 = *(void *)(v91 + 152);
        uint64_t v93 = *(unsigned int *)(v91 + 168);
        if (v93)
        {
          LODWORD(v94) = (v93 - 1) & ((v90 >> 4) ^ (v90 >> 9));
          int v95 = (uint64_t ****)(v92 + 16 * v94);
          BOOL v96 = *v95;
          if (*v95 != v90)
          {
            int v97 = 1;
            while (v96 != (uint64_t ***)-4096)
            {
              int v98 = v94 + v97++;
              uint64_t v94 = v98 & (v93 - 1);
              BOOL v96 = *(uint64_t ****)(v92 + 16 * v94);
              if (v96 == v90)
              {
                int v95 = (uint64_t ****)(v92 + 16 * v94);
                goto LABEL_83;
              }
            }
            goto LABEL_82;
          }
        }
        else
        {
LABEL_82:
          int v95 = (uint64_t ****)(v92 + 16 * v93);
        }
LABEL_83:
        BOOL v99 = v95[1];
        size_t v102 = (size_t)*v99;
        __int32 v100 = (char *)(v99 + 2);
        size_t v101 = v102;
        if (!v17) {
          goto LABEL_105;
        }
        goto LABEL_84;
      }
      unsigned int v88 = v855;
      while (2)
      {
        if (v56 < v88)
        {
          long long v118 = *--v88;
          unint64_t v119 = *v118;
          if ((*((unsigned char *)*v118 + 23) & 0x10) != 0)
          {
            uint64_t v120 = ***v119;
            uint64_t v121 = *(void *)(v120 + 152);
            uint64_t v122 = *(unsigned int *)(v120 + 168);
            if (!v122) {
              goto LABEL_115;
            }
            LODWORD(v123) = (v122 - 1) & ((v119 >> 4) ^ (v119 >> 9));
            BOOL v124 = (uint64_t ****)(v121 + 16 * v123);
            uint64_t v125 = *v124;
            if (*v124 != v119)
            {
              int v126 = 1;
              while (v125 != (uint64_t ***)-4096)
              {
                int v127 = v123 + v126++;
                uint64_t v123 = v127 & (v122 - 1);
                uint64_t v125 = *(uint64_t ****)(v121 + 16 * v123);
                if (v125 == v119)
                {
                  BOOL v124 = (uint64_t ****)(v121 + 16 * v123);
                  goto LABEL_116;
                }
              }
LABEL_115:
              BOOL v124 = (uint64_t ****)(v121 + 16 * v122);
            }
LABEL_116:
            size_t v128 = v124[1];
            size_t v131 = (size_t)*v128;
            int v129 = (char *)(v128 + 2);
            size_t v130 = v131;
            if (v17)
            {
LABEL_117:
              uint64_t v132 = ***v16;
              uint64_t v133 = *(void *)(v132 + 152);
              uint64_t v134 = *(unsigned int *)(v132 + 168);
              if (!v134) {
                goto LABEL_123;
              }
              LODWORD(v135) = (v134 - 1) & v55;
              size_t v136 = (uint64_t ****)(v133 + 16 * v135);
              int v137 = *v136;
              if (*v136 != v16)
              {
                int v138 = 1;
                while (v137 != (uint64_t ***)-4096)
                {
                  int v139 = v135 + v138++;
                  uint64_t v135 = v139 & (v134 - 1);
                  int v137 = *(uint64_t ****)(v133 + 16 * v135);
                  if (v137 == v16)
                  {
                    size_t v136 = (uint64_t ****)(v133 + 16 * v135);
                    goto LABEL_124;
                  }
                }
LABEL_123:
                size_t v136 = (uint64_t ****)(v133 + 16 * v134);
              }
LABEL_124:
              long long v140 = v136[1];
              size_t v143 = (size_t)*v140;
              long long v141 = (char *)(v140 + 2);
              size_t v142 = v143;
LABEL_125:
              if (v142 >= v130) {
                size_t v144 = v130;
              }
              else {
                size_t v144 = v142;
              }
              if (v144 && (int v145 = memcmp(v129, v141, v144)) != 0)
              {
                int v146 = (v145 >> 31) | 1;
              }
              else if (v130 == v142)
              {
                int v146 = 0;
              }
              else
              {
                if (v130 < v142) {
                  break;
                }
                int v146 = 1;
              }
              if (v146 == -1) {
                break;
              }
              continue;
            }
          }
          else
          {
            size_t v130 = 0;
            int v129 = &byte_1CFBCE98E;
            if (v17) {
              goto LABEL_117;
            }
          }
          size_t v142 = 0;
          long long v141 = &byte_1CFBCE98E;
          goto LABEL_125;
        }
        break;
      }
LABEL_139:
      v853 = v88;
      if (v56 >= v88)
      {
        uint64_t v8 = v56;
        goto LABEL_204;
      }
      size_t v147 = v88;
      v148 = *v88;
      uint64_t v8 = v56;
      while (2)
      {
        uint64_t *v8 = v148;
        uint64_t *v147 = v58;
        size_t v149 = *v857;
        int v150 = *((_DWORD *)*v857 + 5);
        unsigned int v151 = (*v857 >> 4) ^ (*v857 >> 9);
        while (2)
        {
          long long v152 = v8[1];
          ++v8;
          uint64_t v58 = v152;
          long long v153 = *v152;
          if ((*((unsigned char *)*v152 + 23) & 0x10) == 0)
          {
            size_t v164 = 0;
            size_t v163 = &byte_1CFBCE98E;
            if ((v150 & 0x10000000) != 0) {
              goto LABEL_151;
            }
LABEL_170:
            size_t v176 = 0;
            char v175 = &byte_1CFBCE98E;
            goto LABEL_159;
          }
          uint64_t v154 = ***v153;
          uint64_t v155 = *(void *)(v154 + 152);
          uint64_t v156 = *(unsigned int *)(v154 + 168);
          if (!v156) {
            goto LABEL_149;
          }
          LODWORD(v157) = (v156 - 1) & ((v153 >> 4) ^ (v153 >> 9));
          uint64_t v158 = (uint64_t ****)(v155 + 16 * v157);
          unint64_t v159 = *v158;
          if (*v158 != v153)
          {
            int v160 = 1;
            while (v159 != (uint64_t ***)-4096)
            {
              int v161 = v157 + v160++;
              uint64_t v157 = v161 & (v156 - 1);
              unint64_t v159 = *(uint64_t ****)(v155 + 16 * v157);
              if (v159 == v153)
              {
                uint64_t v158 = (uint64_t ****)(v155 + 16 * v157);
                goto LABEL_150;
              }
            }
LABEL_149:
            uint64_t v158 = (uint64_t ****)(v155 + 16 * v156);
          }
LABEL_150:
          v162 = v158[1];
          size_t v165 = (size_t)*v162;
          size_t v163 = (char *)(v162 + 2);
          size_t v164 = v165;
          if ((v150 & 0x10000000) == 0) {
            goto LABEL_170;
          }
LABEL_151:
          uint64_t v166 = ***v149;
          uint64_t v167 = *(void *)(v166 + 152);
          uint64_t v168 = *(unsigned int *)(v166 + 168);
          if (!v168) {
            goto LABEL_157;
          }
          LODWORD(v169) = (v168 - 1) & v151;
          long long v170 = (uint64_t ****)(v167 + 16 * v169);
          uint64_t v171 = *v170;
          if (*v170 != v149)
          {
            int v172 = 1;
            while (v171 != (uint64_t ***)-4096)
            {
              int v173 = v169 + v172++;
              uint64_t v169 = v173 & (v168 - 1);
              uint64_t v171 = *(uint64_t ****)(v167 + 16 * v169);
              if (v171 == v149)
              {
                long long v170 = (uint64_t ****)(v167 + 16 * v169);
                goto LABEL_158;
              }
            }
LABEL_157:
            long long v170 = (uint64_t ****)(v167 + 16 * v168);
          }
LABEL_158:
          uint64_t v174 = v170[1];
          size_t v177 = (size_t)*v174;
          char v175 = (char *)(v174 + 2);
          size_t v176 = v177;
LABEL_159:
          if (v176 >= v164) {
            size_t v178 = v164;
          }
          else {
            size_t v178 = v176;
          }
          if (v178 && (int v179 = memcmp(v163, v175, v178)) != 0)
          {
            int v180 = (v179 >> 31) | 1;
          }
          else
          {
            if (v164 >= v176) {
              break;
            }
            int v180 = -1;
          }
          if (v180 == -1) {
            continue;
          }
          break;
        }
        while (2)
        {
          int64_t v185 = *--v147;
          v148 = v185;
          int64_t v186 = *v185;
          if ((*((unsigned char *)*v185 + 23) & 0x10) == 0)
          {
            size_t v181 = 0;
            BOOL v182 = &byte_1CFBCE98E;
            if ((v150 & 0x10000000) != 0) {
              goto LABEL_182;
            }
LABEL_172:
            size_t v183 = 0;
            long long v184 = &byte_1CFBCE98E;
            goto LABEL_190;
          }
          uint64_t v187 = ***v186;
          uint64_t v188 = *(void *)(v187 + 152);
          uint64_t v189 = *(unsigned int *)(v187 + 168);
          if (!v189) {
            goto LABEL_180;
          }
          LODWORD(v190) = (v189 - 1) & ((v186 >> 4) ^ (v186 >> 9));
          int v191 = (uint64_t ****)(v188 + 16 * v190);
          unint64_t v192 = *v191;
          if (*v191 != v186)
          {
            int v193 = 1;
            while (v192 != (uint64_t ***)-4096)
            {
              int v194 = v190 + v193++;
              uint64_t v190 = v194 & (v189 - 1);
              unint64_t v192 = *(uint64_t ****)(v188 + 16 * v190);
              if (v192 == v186)
              {
                int v191 = (uint64_t ****)(v188 + 16 * v190);
                goto LABEL_181;
              }
            }
LABEL_180:
            int v191 = (uint64_t ****)(v188 + 16 * v189);
          }
LABEL_181:
          size_t v195 = v191[1];
          size_t v196 = (size_t)*v195;
          BOOL v182 = (char *)(v195 + 2);
          size_t v181 = v196;
          if ((v150 & 0x10000000) == 0) {
            goto LABEL_172;
          }
LABEL_182:
          uint64_t v197 = ***v149;
          uint64_t v198 = *(void *)(v197 + 152);
          uint64_t v199 = *(unsigned int *)(v197 + 168);
          if (!v199) {
            goto LABEL_188;
          }
          LODWORD(v200) = (v199 - 1) & v151;
          char v201 = (uint64_t ****)(v198 + 16 * v200);
          BOOL v202 = *v201;
          if (*v201 != v149)
          {
            int v203 = 1;
            while (v202 != (uint64_t ***)-4096)
            {
              int v204 = v200 + v203++;
              uint64_t v200 = v204 & (v199 - 1);
              BOOL v202 = *(uint64_t ****)(v198 + 16 * v200);
              if (v202 == v149)
              {
                char v201 = (uint64_t ****)(v198 + 16 * v200);
                goto LABEL_189;
              }
            }
LABEL_188:
            char v201 = (uint64_t ****)(v198 + 16 * v199);
          }
LABEL_189:
          size_t v205 = v201[1];
          size_t v206 = (size_t)*v205;
          long long v184 = (char *)(v205 + 2);
          size_t v183 = v206;
LABEL_190:
          if (v183 >= v181) {
            size_t v207 = v181;
          }
          else {
            size_t v207 = v183;
          }
          if (v207 && (int v208 = memcmp(v182, v184, v207)) != 0)
          {
            int v209 = (v208 >> 31) | 1;
          }
          else if (v181 == v183)
          {
            int v209 = 0;
          }
          else
          {
            if (v181 < v183) {
              break;
            }
            int v209 = 1;
          }
          if (v209 != -1) {
            continue;
          }
          break;
        }
        if (v8 < v147) {
          continue;
        }
        break;
      }
LABEL_204:
      BOOL v210 = v8 - 1;
      unsigned int v7 = v856;
      if (v8 - 1 != v856) {
        *v856 = *v210;
      }
      *BOOL v210 = v857;
      a3 = v854;
      if (v56 < v853)
      {
LABEL_209:
        uint64_t result = (char *)sub_1CC4511F8(v856, v8 - 1, v854, a4 & 1);
        a4 = 0;
      }
      else
      {
        BOOL v211 = sub_1CC454398(v856, v8 - 1);
        uint64_t result = (char *)sub_1CC454398(v8, v855);
        if (result)
        {
          a2 = v8 - 1;
          if (v211) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v211) {
          goto LABEL_209;
        }
      }
    }
    else
    {
      BOOL v18 = **(v9 - 1);
      if ((*((unsigned char *)v18 + 23) & 0x10) != 0)
      {
        uint64_t v19 = ***v18;
        uint64_t v20 = *(void *)(v19 + 152);
        uint64_t v21 = *(unsigned int *)(v19 + 168);
        if (v21)
        {
          LODWORD(v22) = (v21 - 1) & ((v18 >> 4) ^ (v18 >> 9));
          char v23 = (uint64_t ****)(v20 + 16 * v22);
          BOOL v24 = *v23;
          if (*v23 == v18)
          {
LABEL_20:
            size_t v27 = v23[1];
            size_t v30 = (size_t)*v27;
            size_t v28 = (char *)(v27 + 2);
            size_t v29 = v30;
            goto LABEL_21;
          }
          int v25 = 1;
          while (v24 != (uint64_t ***)-4096)
          {
            int v26 = v22 + v25++;
            uint64_t v22 = v26 & (v21 - 1);
            BOOL v24 = *(uint64_t ****)(v20 + 16 * v22);
            if (v24 == v18)
            {
              char v23 = (uint64_t ****)(v20 + 16 * v22);
              goto LABEL_20;
            }
          }
        }
        char v23 = (uint64_t ****)(v20 + 16 * v21);
        goto LABEL_20;
      }
      size_t v29 = 0;
      size_t v28 = &byte_1CFBCE98E;
LABEL_21:
      int v16 = *v15;
      int v31 = *((_DWORD *)*v15 + 5);
      unsigned int v32 = *v15 >> 4;
      if ((v31 & 0x10000000) != 0)
      {
        uint64_t v33 = ***v16;
        uint64_t v34 = *(void *)(v33 + 152);
        uint64_t v35 = *(unsigned int *)(v33 + 168);
        if (v35)
        {
          LODWORD(v36) = (v35 - 1) & (v32 ^ (v16 >> 9));
          char v37 = (uint64_t ****)(v34 + 16 * v36);
          BOOL v38 = *v37;
          if (*v37 == v16)
          {
LABEL_29:
            size_t v41 = v37[1];
            size_t v44 = (size_t)*v41;
            size_t v42 = (char *)(v41 + 2);
            size_t v43 = v44;
            goto LABEL_30;
          }
          int v39 = 1;
          while (v38 != (uint64_t ***)-4096)
          {
            int v40 = v36 + v39++;
            uint64_t v36 = v40 & (v35 - 1);
            BOOL v38 = *(uint64_t ****)(v34 + 16 * v36);
            if (v38 == v16)
            {
              char v37 = (uint64_t ****)(v34 + 16 * v36);
              goto LABEL_29;
            }
          }
        }
        char v37 = (uint64_t ****)(v34 + 16 * v35);
        goto LABEL_29;
      }
      size_t v43 = 0;
      size_t v42 = &byte_1CFBCE98E;
LABEL_30:
      int v17 = v31 & 0x10000000;
      if (v43 >= v29) {
        size_t v45 = v29;
      }
      else {
        size_t v45 = v43;
      }
      if (v45 && (int v46 = memcmp(v28, v42, v45)) != 0)
      {
        if (v46 < 0) {
          goto LABEL_44;
        }
      }
      else if (v29 < v43)
      {
        goto LABEL_44;
      }
      if (v17)
      {
        uint64_t v47 = ***v16;
        uint64_t v48 = *(void *)(v47 + 152);
        uint64_t v49 = *(unsigned int *)(v47 + 168);
        if (!v49) {
          goto LABEL_212;
        }
        LODWORD(v50) = (v49 - 1) & (v32 ^ (v16 >> 9));
        uint64_t v51 = (uint64_t ****)(v48 + 16 * v50);
        uint64_t v52 = *v51;
        if (*v51 != v16)
        {
          int v53 = 1;
          while (v52 != (uint64_t ***)-4096)
          {
            int v54 = v50 + v53++;
            uint64_t v50 = v54 & (v49 - 1);
            uint64_t v52 = *(uint64_t ****)(v48 + 16 * v50);
            if (v52 == v16)
            {
              uint64_t v51 = (uint64_t ****)(v48 + 16 * v50);
              goto LABEL_213;
            }
          }
LABEL_212:
          uint64_t v51 = (uint64_t ****)(v48 + 16 * v49);
        }
LABEL_213:
        unint64_t v212 = v51[1];
        size_t v214 = (size_t)*v212;
        uint64_t result = (char *)(v212 + 2);
        size_t v213 = v214;
        goto LABEL_214;
      }
      size_t v213 = 0;
      uint64_t result = &byte_1CFBCE98E;
LABEL_214:
      char v215 = **v851;
      if ((*((unsigned char *)v215 + 23) & 0x10) != 0)
      {
        uint64_t v216 = ***v215;
        uint64_t v217 = *(void *)(v216 + 152);
        uint64_t v218 = *(unsigned int *)(v216 + 168);
        if (!v218) {
          goto LABEL_221;
        }
        LODWORD(v219) = (v218 - 1) & ((v215 >> 4) ^ (v215 >> 9));
        size_t v220 = (uint64_t ****)(v217 + 16 * v219);
        v221 = *v220;
        if (*v220 != v215)
        {
          int v222 = 1;
          while (v221 != (uint64_t ***)-4096)
          {
            int v223 = v219 + v222++;
            uint64_t v219 = v223 & (v218 - 1);
            v221 = *(uint64_t ****)(v217 + 16 * v219);
            if (v221 == v215)
            {
              size_t v220 = (uint64_t ****)(v217 + 16 * v219);
              goto LABEL_222;
            }
          }
LABEL_221:
          size_t v220 = (uint64_t ****)(v217 + 16 * v218);
        }
LABEL_222:
        BOOL v224 = v220[1];
        size_t v227 = (size_t)*v224;
        v225 = (char *)(v224 + 2);
        size_t v226 = v227;
        goto LABEL_223;
      }
      size_t v226 = 0;
      v225 = &byte_1CFBCE98E;
LABEL_223:
      if (v226 >= v213) {
        size_t v228 = v213;
      }
      else {
        size_t v228 = v226;
      }
      if (v228)
      {
        uint64_t result = (char *)memcmp(result, v225, v228);
        if (result)
        {
          if ((result & 0x80000000) == 0) {
            goto LABEL_229;
          }
          goto LABEL_264;
        }
      }
      if (v213 >= v226)
      {
LABEL_229:
        uint64_t v8 = v9;
        while (1)
        {
          if (++v8 >= v855) {
            goto LABEL_297;
          }
          if (v17) {
            break;
          }
          size_t v238 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_240:
          int v240 = **v8;
          if ((*((unsigned char *)v240 + 23) & 0x10) == 0)
          {
            size_t v251 = 0;
            int v250 = &byte_1CFBCE98E;
            goto LABEL_249;
          }
          uint64_t v241 = ***v240;
          uint64_t v242 = *(void *)(v241 + 152);
          uint64_t v243 = *(unsigned int *)(v241 + 168);
          if (!v243) {
            goto LABEL_247;
          }
          LODWORD(v244) = (v243 - 1) & ((v240 >> 4) ^ (v240 >> 9));
          v245 = (uint64_t ****)(v242 + 16 * v244);
          size_t v246 = *v245;
          if (*v245 != v240)
          {
            int v247 = 1;
            while (v246 != (uint64_t ***)-4096)
            {
              int v248 = v244 + v247++;
              uint64_t v244 = v248 & (v243 - 1);
              size_t v246 = *(uint64_t ****)(v242 + 16 * v244);
              if (v246 == v240)
              {
                v245 = (uint64_t ****)(v242 + 16 * v244);
                goto LABEL_248;
              }
            }
LABEL_247:
            v245 = (uint64_t ****)(v242 + 16 * v243);
          }
LABEL_248:
          long long v249 = v245[1];
          size_t v252 = (size_t)*v249;
          int v250 = (char *)(v249 + 2);
          size_t v251 = v252;
LABEL_249:
          if (v251 >= v238) {
            size_t v253 = v238;
          }
          else {
            size_t v253 = v251;
          }
          if (v253 && (uint64_t result = (char *)memcmp(result, v250, v253), result))
          {
            int v254 = ((int)result >> 31) | 1;
          }
          else if (v238 == v251)
          {
            int v254 = 0;
          }
          else
          {
            if (v238 < v251) {
              goto LABEL_297;
            }
            int v254 = 1;
          }
          if (v254 == -1) {
            goto LABEL_297;
          }
        }
        uint64_t v229 = ***v16;
        uint64_t v230 = *(void *)(v229 + 152);
        uint64_t v231 = *(unsigned int *)(v229 + 168);
        if (v231)
        {
          LODWORD(v232) = (v231 - 1) & (v32 ^ (v16 >> 9));
          v233 = (uint64_t ****)(v230 + 16 * v232);
          uint64_t v234 = *v233;
          if (*v233 != v16)
          {
            int v235 = 1;
            while (v234 != (uint64_t ***)-4096)
            {
              int v236 = v232 + v235++;
              uint64_t v232 = v236 & (v231 - 1);
              uint64_t v234 = *(uint64_t ****)(v230 + 16 * v232);
              if (v234 == v16)
              {
                v233 = (uint64_t ****)(v230 + 16 * v232);
                goto LABEL_239;
              }
            }
            goto LABEL_238;
          }
        }
        else
        {
LABEL_238:
          v233 = (uint64_t ****)(v230 + 16 * v231);
        }
LABEL_239:
        uint64_t v237 = v233[1];
        size_t v239 = (size_t)*v237;
        uint64_t result = (char *)(v237 + 2);
        size_t v238 = v239;
        goto LABEL_240;
      }
LABEL_264:
      uint64_t v8 = v9;
      do
      {
        if (v17)
        {
          uint64_t v255 = ***v16;
          uint64_t v256 = *(void *)(v255 + 152);
          uint64_t v257 = *(unsigned int *)(v255 + 168);
          if (!v257) {
            goto LABEL_272;
          }
          LODWORD(v258) = (v257 - 1) & (v32 ^ (v16 >> 9));
          size_t v259 = (uint64_t ****)(v256 + 16 * v258);
          size_t v260 = *v259;
          if (*v259 != v16)
          {
            int v261 = 1;
            while (v260 != (uint64_t ***)-4096)
            {
              int v262 = v258 + v261++;
              uint64_t v258 = v262 & (v257 - 1);
              size_t v260 = *(uint64_t ****)(v256 + 16 * v258);
              if (v260 == v16)
              {
                size_t v259 = (uint64_t ****)(v256 + 16 * v258);
                goto LABEL_273;
              }
            }
LABEL_272:
            size_t v259 = (uint64_t ****)(v256 + 16 * v257);
          }
LABEL_273:
          size_t v263 = v259[1];
          size_t v265 = (size_t)*v263;
          uint64_t result = (char *)(v263 + 2);
          size_t v264 = v265;
          goto LABEL_274;
        }
        size_t v264 = 0;
        uint64_t result = &byte_1CFBCE98E;
LABEL_274:
        long long v266 = v8[1];
        ++v8;
        v267 = *v266;
        if ((*((unsigned char *)*v266 + 23) & 0x10) != 0)
        {
          uint64_t v268 = ***v267;
          uint64_t v269 = *(void *)(v268 + 152);
          uint64_t v270 = *(unsigned int *)(v268 + 168);
          if (!v270) {
            goto LABEL_281;
          }
          LODWORD(v271) = (v270 - 1) & ((v267 >> 4) ^ (v267 >> 9));
          size_t v272 = (uint64_t ****)(v269 + 16 * v271);
          v273 = *v272;
          if (*v272 != v267)
          {
            int v274 = 1;
            while (v273 != (uint64_t ***)-4096)
            {
              int v275 = v271 + v274++;
              uint64_t v271 = v275 & (v270 - 1);
              v273 = *(uint64_t ****)(v269 + 16 * v271);
              if (v273 == v267)
              {
                size_t v272 = (uint64_t ****)(v269 + 16 * v271);
                goto LABEL_282;
              }
            }
LABEL_281:
            size_t v272 = (uint64_t ****)(v269 + 16 * v270);
          }
LABEL_282:
          BOOL v276 = v272[1];
          size_t v279 = (size_t)*v276;
          uint64_t v277 = (char *)(v276 + 2);
          size_t v278 = v279;
          goto LABEL_283;
        }
        size_t v278 = 0;
        uint64_t v277 = &byte_1CFBCE98E;
LABEL_283:
        if (v278 >= v264) {
          size_t v280 = v264;
        }
        else {
          size_t v280 = v278;
        }
        if (v280 && (uint64_t result = (char *)memcmp(result, v277, v280), result))
        {
          int v281 = ((int)result >> 31) | 1;
        }
        else if (v264 == v278)
        {
          int v281 = 0;
        }
        else
        {
          if (v264 < v278) {
            break;
          }
          int v281 = 1;
        }
      }
      while (v281 != -1);
LABEL_297:
      v282 = v855;
      if (v8 < v855)
      {
        unsigned int v283 = v32 ^ (v16 >> 9);
        v282 = v855;
        while (!v17)
        {
          size_t v293 = 0;
          uint64_t result = &byte_1CFBCE98E;
LABEL_308:
          v295 = *--v282;
          v296 = *v295;
          if ((*((unsigned char *)*v295 + 23) & 0x10) == 0)
          {
            size_t v307 = 0;
            BOOL v306 = &byte_1CFBCE98E;
            goto LABEL_317;
          }
          uint64_t v297 = ***v296;
          uint64_t v298 = *(void *)(v297 + 152);
          uint64_t v299 = *(unsigned int *)(v297 + 168);
          if (!v299) {
            goto LABEL_315;
          }
          LODWORD(v300) = (v299 - 1) & ((v296 >> 4) ^ (v296 >> 9));
          size_t v301 = (uint64_t ****)(v298 + 16 * v300);
          v302 = *v301;
          if (*v301 != v296)
          {
            int v303 = 1;
            while (v302 != (uint64_t ***)-4096)
            {
              int v304 = v300 + v303++;
              uint64_t v300 = v304 & (v299 - 1);
              v302 = *(uint64_t ****)(v298 + 16 * v300);
              if (v302 == v296)
              {
                size_t v301 = (uint64_t ****)(v298 + 16 * v300);
                goto LABEL_316;
              }
            }
LABEL_315:
            size_t v301 = (uint64_t ****)(v298 + 16 * v299);
          }
LABEL_316:
          int v305 = v301[1];
          size_t v308 = (size_t)*v305;
          BOOL v306 = (char *)(v305 + 2);
          size_t v307 = v308;
LABEL_317:
          if (v307 >= v293) {
            size_t v309 = v293;
          }
          else {
            size_t v309 = v307;
          }
          if (v309 && (uint64_t result = (char *)memcmp(result, v306, v309), result))
          {
            int v310 = ((int)result >> 31) | 1;
          }
          else
          {
            if (v293 >= v307) {
              goto LABEL_329;
            }
            int v310 = -1;
          }
          if (v310 != -1) {
            goto LABEL_329;
          }
        }
        uint64_t v284 = ***v16;
        uint64_t v285 = *(void *)(v284 + 152);
        uint64_t v286 = *(unsigned int *)(v284 + 168);
        if (v286)
        {
          LODWORD(v287) = (v286 - 1) & v283;
          size_t v288 = (uint64_t ****)(v285 + 16 * v287);
          v289 = *v288;
          if (*v288 != v16)
          {
            int v290 = 1;
            while (v289 != (uint64_t ***)-4096)
            {
              int v291 = v287 + v290++;
              uint64_t v287 = v291 & (v286 - 1);
              v289 = *(uint64_t ****)(v285 + 16 * v287);
              if (v289 == v16)
              {
                size_t v288 = (uint64_t ****)(v285 + 16 * v287);
                goto LABEL_307;
              }
            }
            goto LABEL_306;
          }
        }
        else
        {
LABEL_306:
          size_t v288 = (uint64_t ****)(v285 + 16 * v286);
        }
LABEL_307:
        BOOL v292 = v288[1];
        size_t v294 = (size_t)*v292;
        uint64_t result = (char *)(v292 + 2);
        size_t v293 = v294;
        goto LABEL_308;
      }
LABEL_329:
      if (v8 >= v282) {
        goto LABEL_394;
      }
      v311 = *v8;
      v312 = *v282;
      while (2)
      {
        uint64_t *v8 = v312;
        *v282 = v311;
        v313 = *v15;
        int v314 = *((_DWORD *)*v15 + 5);
        unsigned int v315 = (*v15 >> 4) ^ (*v15 >> 9);
        while (2)
        {
          v316 = v8[1];
          ++v8;
          v311 = v316;
          if ((v314 & 0x10000000) != 0)
          {
            uint64_t v317 = ***v313;
            uint64_t v318 = *(void *)(v317 + 152);
            uint64_t v319 = *(unsigned int *)(v317 + 168);
            if (!v319) {
              goto LABEL_339;
            }
            LODWORD(v320) = (v319 - 1) & v315;
            long long v321 = (uint64_t ****)(v318 + 16 * v320);
            v322 = *v321;
            if (*v321 != v313)
            {
              int v323 = 1;
              while (v322 != (uint64_t ***)-4096)
              {
                int v324 = v320 + v323++;
                uint64_t v320 = v324 & (v319 - 1);
                v322 = *(uint64_t ****)(v318 + 16 * v320);
                if (v322 == v313)
                {
                  long long v321 = (uint64_t ****)(v318 + 16 * v320);
                  goto LABEL_340;
                }
              }
LABEL_339:
              long long v321 = (uint64_t ****)(v318 + 16 * v319);
            }
LABEL_340:
            v325 = v321[1];
            size_t v328 = (size_t)*v325;
            v326 = (char *)(v325 + 2);
            size_t v327 = v328;
          }
          else
          {
            size_t v327 = 0;
            v326 = &byte_1CFBCE98E;
          }
          v329 = *v311;
          if ((*((unsigned char *)*v311 + 23) & 0x10) != 0)
          {
            uint64_t v330 = ***v329;
            uint64_t v331 = *(void *)(v330 + 152);
            uint64_t v332 = *(unsigned int *)(v330 + 168);
            if (!v332) {
              goto LABEL_348;
            }
            LODWORD(v333) = (v332 - 1) & ((v329 >> 4) ^ (v329 >> 9));
            v334 = (uint64_t ****)(v331 + 16 * v333);
            v335 = *v334;
            if (*v334 != v329)
            {
              int v336 = 1;
              while (v335 != (uint64_t ***)-4096)
              {
                int v337 = v333 + v336++;
                uint64_t v333 = v337 & (v332 - 1);
                v335 = *(uint64_t ****)(v331 + 16 * v333);
                if (v335 == v329)
                {
                  v334 = (uint64_t ****)(v331 + 16 * v333);
                  goto LABEL_349;
                }
              }
LABEL_348:
              v334 = (uint64_t ****)(v331 + 16 * v332);
            }
LABEL_349:
            v338 = v334[1];
            size_t v341 = (size_t)*v338;
            v339 = (char *)(v338 + 2);
            size_t v340 = v341;
          }
          else
          {
            size_t v340 = 0;
            v339 = &byte_1CFBCE98E;
          }
          if (v340 >= v327) {
            size_t v342 = v327;
          }
          else {
            size_t v342 = v340;
          }
          if (v342 && (int v343 = memcmp(v326, v339, v342)) != 0)
          {
            int v344 = (v343 >> 31) | 1;
          }
          else if (v327 == v340)
          {
            int v344 = 0;
          }
          else
          {
            if (v327 < v340) {
              break;
            }
            int v344 = 1;
          }
          if (v344 != -1) {
            continue;
          }
          break;
        }
        while (2)
        {
          v348 = *--v282;
          v312 = v348;
          if ((v314 & 0x10000000) != 0)
          {
            uint64_t v349 = ***v313;
            uint64_t v350 = *(void *)(v349 + 152);
            uint64_t v351 = *(unsigned int *)(v349 + 168);
            if (!v351) {
              goto LABEL_373;
            }
            LODWORD(v352) = (v351 - 1) & v315;
            v353 = (uint64_t ****)(v350 + 16 * v352);
            v354 = *v353;
            if (*v353 != v313)
            {
              int v355 = 1;
              while (v354 != (uint64_t ***)-4096)
              {
                int v356 = v352 + v355++;
                uint64_t v352 = v356 & (v351 - 1);
                v354 = *(uint64_t ****)(v350 + 16 * v352);
                if (v354 == v313)
                {
                  v353 = (uint64_t ****)(v350 + 16 * v352);
                  goto LABEL_374;
                }
              }
LABEL_373:
              v353 = (uint64_t ****)(v350 + 16 * v351);
            }
LABEL_374:
            v357 = v353[1];
            size_t v358 = (size_t)*v357;
            uint64_t result = (char *)(v357 + 2);
            size_t v345 = v358;
          }
          else
          {
            size_t v345 = 0;
            uint64_t result = &byte_1CFBCE98E;
          }
          v359 = *v312;
          if ((*((unsigned char *)*v312 + 23) & 0x10) != 0)
          {
            uint64_t v360 = ***v359;
            uint64_t v361 = *(void *)(v360 + 152);
            uint64_t v362 = *(unsigned int *)(v360 + 168);
            if (!v362) {
              goto LABEL_382;
            }
            LODWORD(v363) = (v362 - 1) & ((v359 >> 4) ^ (v359 >> 9));
            v364 = (uint64_t ****)(v361 + 16 * v363);
            v365 = *v364;
            if (*v364 != v359)
            {
              int v366 = 1;
              while (v365 != (uint64_t ***)-4096)
              {
                int v367 = v363 + v366++;
                uint64_t v363 = v367 & (v362 - 1);
                v365 = *(uint64_t ****)(v361 + 16 * v363);
                if (v365 == v359)
                {
                  v364 = (uint64_t ****)(v361 + 16 * v363);
                  goto LABEL_383;
                }
              }
LABEL_382:
              v364 = (uint64_t ****)(v361 + 16 * v362);
            }
LABEL_383:
            v368 = v364[1];
            size_t v369 = (size_t)*v368;
            v347 = (char *)(v368 + 2);
            size_t v346 = v369;
          }
          else
          {
            size_t v346 = 0;
            v347 = &byte_1CFBCE98E;
          }
          if (v346 >= v345) {
            size_t v370 = v345;
          }
          else {
            size_t v370 = v346;
          }
          if (v370 && (uint64_t result = (char *)memcmp(result, v347, v370), result))
          {
            int v371 = ((int)result >> 31) | 1;
          }
          else
          {
            if (v345 >= v346) {
              break;
            }
            int v371 = -1;
          }
          if (v371 == -1) {
            continue;
          }
          break;
        }
        if (v8 < v282) {
          continue;
        }
        break;
      }
LABEL_394:
      v372 = v8 - 1;
      BOOL v4 = v8 - 1 >= v856;
      BOOL v5 = v8 - 1 == v856;
      if (v8 - 1 != v856) {
        *v856 = *v372;
      }
      a4 = 0;
      *v372 = v15;
      a3 = v854;
    }
  }
  v397 = v9 + 1;
  BOOL v399 = v9 == v855 || v397 == v855;
  if ((a4 & 1) == 0)
  {
    if (v399) {
      return result;
    }
    while (1)
    {
      v676 = v9;
      uint64_t v9 = v397;
      v677 = v676[1];
      v678 = *v677;
      if ((*((unsigned char *)*v677 + 23) & 0x10) != 0)
      {
        uint64_t v679 = ***v678;
        uint64_t v680 = *(void *)(v679 + 152);
        uint64_t v681 = *(unsigned int *)(v679 + 168);
        if (v681)
        {
          LODWORD(v682) = (v681 - 1) & ((v678 >> 4) ^ (v678 >> 9));
          v683 = (uint64_t ****)(v680 + 16 * v682);
          v684 = *v683;
          if (*v683 != v678)
          {
            int v685 = 1;
            do
            {
              if (v684 == (uint64_t ***)-4096) {
                goto LABEL_747;
              }
              int v686 = v682 + v685++;
              uint64_t v682 = v686 & (v681 - 1);
              v684 = *(uint64_t ****)(v680 + 16 * v682);
            }
            while (v684 != v678);
            v683 = (uint64_t ****)(v680 + 16 * v682);
          }
        }
        else
        {
LABEL_747:
          v683 = (uint64_t ****)(v680 + 16 * v681);
        }
        v687 = v683[1];
        size_t v689 = (size_t)*v687;
        uint64_t result = (char *)(v687 + 2);
        size_t v688 = v689;
      }
      else
      {
        size_t v688 = 0;
        uint64_t result = &byte_1CFBCE98E;
      }
      v690 = *v676;
      v691 = **v676;
      if ((*((unsigned char *)v691 + 23) & 0x10) != 0)
      {
        uint64_t v692 = ***v691;
        uint64_t v693 = *(void *)(v692 + 152);
        uint64_t v694 = *(unsigned int *)(v692 + 168);
        if (v694)
        {
          LODWORD(v695) = (v694 - 1) & ((v691 >> 4) ^ (v691 >> 9));
          v696 = (uint64_t ****)(v693 + 16 * v695);
          v697 = *v696;
          if (*v696 != v691)
          {
            int v698 = 1;
            do
            {
              if (v697 == (uint64_t ***)-4096) {
                goto LABEL_756;
              }
              int v699 = v695 + v698++;
              uint64_t v695 = v699 & (v694 - 1);
              v697 = *(uint64_t ****)(v693 + 16 * v695);
            }
            while (v697 != v691);
            v696 = (uint64_t ****)(v693 + 16 * v695);
          }
        }
        else
        {
LABEL_756:
          v696 = (uint64_t ****)(v693 + 16 * v694);
        }
        v700 = v696[1];
        size_t v703 = (size_t)*v700;
        v701 = (char *)(v700 + 2);
        size_t v702 = v703;
      }
      else
      {
        size_t v702 = 0;
        v701 = &byte_1CFBCE98E;
      }
      if (v702 >= v688) {
        size_t v704 = v688;
      }
      else {
        size_t v704 = v702;
      }
      if (v704 && (uint64_t result = (char *)memcmp(result, v701, v704), result))
      {
        if ((result & 0x80000000) == 0) {
          goto LABEL_798;
        }
      }
      else if (v688 >= v702)
      {
        goto LABEL_798;
      }
      v705 = v9;
      do
      {
        *v705 = v690;
        v705 = v676;
        v706 = *v677;
        if ((*((unsigned char *)*v677 + 23) & 0x10) != 0)
        {
          uint64_t v707 = ***v706;
          uint64_t v708 = *(void *)(v707 + 152);
          uint64_t v709 = *(unsigned int *)(v707 + 168);
          if (v709)
          {
            LODWORD(v710) = (v709 - 1) & ((v706 >> 4) ^ (v706 >> 9));
            v711 = (uint64_t ****)(v708 + 16 * v710);
            v712 = *v711;
            if (*v711 != v706)
            {
              int v713 = 1;
              do
              {
                if (v712 == (uint64_t ***)-4096) {
                  goto LABEL_774;
                }
                int v714 = v710 + v713++;
                uint64_t v710 = v714 & (v709 - 1);
                v712 = *(uint64_t ****)(v708 + 16 * v710);
              }
              while (v712 != v706);
              v711 = (uint64_t ****)(v708 + 16 * v710);
            }
          }
          else
          {
LABEL_774:
            v711 = (uint64_t ****)(v708 + 16 * v709);
          }
          v715 = v711[1];
          size_t v717 = (size_t)*v715;
          uint64_t result = (char *)(v715 + 2);
          size_t v716 = v717;
        }
        else
        {
          size_t v716 = 0;
          uint64_t result = &byte_1CFBCE98E;
        }
        --v676;
        v690 = *(v705 - 1);
        v718 = *v690;
        if ((*((unsigned char *)*v690 + 23) & 0x10) != 0)
        {
          uint64_t v719 = ***v718;
          uint64_t v720 = *(void *)(v719 + 152);
          uint64_t v721 = *(unsigned int *)(v719 + 168);
          if (v721)
          {
            LODWORD(v722) = (v721 - 1) & ((v718 >> 4) ^ (v718 >> 9));
            v723 = (uint64_t ****)(v720 + 16 * v722);
            v724 = *v723;
            if (*v723 != v718)
            {
              int v725 = 1;
              do
              {
                if (v724 == (uint64_t ***)-4096) {
                  goto LABEL_783;
                }
                int v726 = v722 + v725++;
                uint64_t v722 = v726 & (v721 - 1);
                v724 = *(uint64_t ****)(v720 + 16 * v722);
              }
              while (v724 != v718);
              v723 = (uint64_t ****)(v720 + 16 * v722);
            }
          }
          else
          {
LABEL_783:
            v723 = (uint64_t ****)(v720 + 16 * v721);
          }
          v727 = v723[1];
          size_t v730 = (size_t)*v727;
          v728 = (char *)(v727 + 2);
          size_t v729 = v730;
        }
        else
        {
          size_t v729 = 0;
          v728 = &byte_1CFBCE98E;
        }
        if (v729 >= v716) {
          size_t v731 = v716;
        }
        else {
          size_t v731 = v729;
        }
        if (v731 && (uint64_t result = (char *)memcmp(result, v728, v731), result))
        {
          int v732 = ((int)result >> 31) | 1;
        }
        else
        {
          if (v716 >= v729) {
            break;
          }
          int v732 = -1;
        }
      }
      while (v732 == -1);
      *v705 = v677;
LABEL_798:
      v397 = v9 + 1;
      if (v9 + 1 == v855) {
        return result;
      }
    }
  }
  if (v399) {
    return result;
  }
  v400 = v9;
  while (2)
  {
    v401 = v400;
    v400 = v397;
    v402 = v401[1];
    v403 = *v402;
    if ((*((unsigned char *)*v402 + 23) & 0x10) != 0)
    {
      uint64_t v404 = ***v403;
      uint64_t v405 = *(void *)(v404 + 152);
      uint64_t v406 = *(unsigned int *)(v404 + 168);
      if (!v406) {
        goto LABEL_439;
      }
      LODWORD(v407) = (v406 - 1) & ((v403 >> 4) ^ (v403 >> 9));
      v408 = (uint64_t ****)(v405 + 16 * v407);
      v409 = *v408;
      if (*v408 != v403)
      {
        int v410 = 1;
        while (v409 != (uint64_t ***)-4096)
        {
          int v411 = v407 + v410++;
          uint64_t v407 = v411 & (v406 - 1);
          v409 = *(uint64_t ****)(v405 + 16 * v407);
          if (v409 == v403)
          {
            v408 = (uint64_t ****)(v405 + 16 * v407);
            goto LABEL_440;
          }
        }
LABEL_439:
        v408 = (uint64_t ****)(v405 + 16 * v406);
      }
LABEL_440:
      v412 = v408[1];
      size_t v414 = (size_t)*v412;
      uint64_t result = (char *)(v412 + 2);
      size_t v413 = v414;
    }
    else
    {
      size_t v413 = 0;
      uint64_t result = &byte_1CFBCE98E;
    }
    v415 = *v401;
    v416 = **v401;
    if ((*((unsigned char *)v416 + 23) & 0x10) != 0)
    {
      uint64_t v417 = ***v416;
      uint64_t v418 = *(void *)(v417 + 152);
      uint64_t v419 = *(unsigned int *)(v417 + 168);
      if (!v419) {
        goto LABEL_448;
      }
      LODWORD(v420) = (v419 - 1) & ((v416 >> 4) ^ (v416 >> 9));
      v421 = (uint64_t ****)(v418 + 16 * v420);
      v422 = *v421;
      if (*v421 != v416)
      {
        int v423 = 1;
        while (v422 != (uint64_t ***)-4096)
        {
          int v424 = v420 + v423++;
          uint64_t v420 = v424 & (v419 - 1);
          v422 = *(uint64_t ****)(v418 + 16 * v420);
          if (v422 == v416)
          {
            v421 = (uint64_t ****)(v418 + 16 * v420);
            goto LABEL_449;
          }
        }
LABEL_448:
        v421 = (uint64_t ****)(v418 + 16 * v419);
      }
LABEL_449:
      v425 = v421[1];
      size_t v428 = (size_t)*v425;
      v426 = (char *)(v425 + 2);
      size_t v427 = v428;
    }
    else
    {
      size_t v427 = 0;
      v426 = &byte_1CFBCE98E;
    }
    if (v427 >= v413) {
      size_t v429 = v413;
    }
    else {
      size_t v429 = v427;
    }
    if (v429 && (uint64_t result = (char *)memcmp(result, v426, v429), result))
    {
      if ((result & 0x80000000) == 0) {
        goto LABEL_493;
      }
    }
    else if (v413 >= v427)
    {
      goto LABEL_493;
    }
    v430 = v400;
    while (2)
    {
      *v430 = v415;
      if (v401 == v9)
      {
        v430 = v9;
        goto LABEL_492;
      }
      v430 = v401;
      v431 = *v402;
      if ((*((unsigned char *)*v402 + 23) & 0x10) != 0)
      {
        uint64_t v432 = ***v431;
        uint64_t v433 = *(void *)(v432 + 152);
        uint64_t v434 = *(unsigned int *)(v432 + 168);
        if (!v434) {
          goto LABEL_467;
        }
        LODWORD(v435) = (v434 - 1) & ((v431 >> 4) ^ (v431 >> 9));
        v436 = (uint64_t ****)(v433 + 16 * v435);
        v437 = *v436;
        if (*v436 != v431)
        {
          int v438 = 1;
          while (v437 != (uint64_t ***)-4096)
          {
            int v439 = v435 + v438++;
            uint64_t v435 = v439 & (v434 - 1);
            v437 = *(uint64_t ****)(v433 + 16 * v435);
            if (v437 == v431)
            {
              v436 = (uint64_t ****)(v433 + 16 * v435);
              goto LABEL_468;
            }
          }
LABEL_467:
          v436 = (uint64_t ****)(v433 + 16 * v434);
        }
LABEL_468:
        v440 = v436[1];
        size_t v442 = (size_t)*v440;
        uint64_t result = (char *)(v440 + 2);
        size_t v441 = v442;
      }
      else
      {
        size_t v441 = 0;
        uint64_t result = &byte_1CFBCE98E;
      }
      --v401;
      v415 = *(v430 - 1);
      v443 = *v415;
      if ((*((unsigned char *)*v415 + 23) & 0x10) != 0)
      {
        uint64_t v444 = ***v443;
        uint64_t v445 = *(void *)(v444 + 152);
        uint64_t v446 = *(unsigned int *)(v444 + 168);
        if (!v446) {
          goto LABEL_476;
        }
        LODWORD(v447) = (v446 - 1) & ((v443 >> 4) ^ (v443 >> 9));
        v448 = (uint64_t ****)(v445 + 16 * v447);
        v449 = *v448;
        if (*v448 != v443)
        {
          int v450 = 1;
          while (v449 != (uint64_t ***)-4096)
          {
            int v451 = v447 + v450++;
            uint64_t v447 = v451 & (v446 - 1);
            v449 = *(uint64_t ****)(v445 + 16 * v447);
            if (v449 == v443)
            {
              v448 = (uint64_t ****)(v445 + 16 * v447);
              goto LABEL_477;
            }
          }
LABEL_476:
          v448 = (uint64_t ****)(v445 + 16 * v446);
        }
LABEL_477:
        v452 = v448[1];
        size_t v455 = (size_t)*v452;
        v453 = (char *)(v452 + 2);
        size_t v454 = v455;
      }
      else
      {
        size_t v454 = 0;
        v453 = &byte_1CFBCE98E;
      }
      if (v454 >= v441) {
        size_t v456 = v441;
      }
      else {
        size_t v456 = v454;
      }
      if (v456)
      {
        uint64_t result = (char *)memcmp(result, v453, v456);
        if (result)
        {
          int v457 = ((int)result >> 31) | 1;
          goto LABEL_486;
        }
      }
      if (v441 < v454)
      {
        int v457 = -1;
LABEL_486:
        uint64_t v9 = v856;
        if (v457 != -1) {
          goto LABEL_492;
        }
        continue;
      }
      break;
    }
    uint64_t v9 = v856;
LABEL_492:
    *v430 = v402;
LABEL_493:
    v397 = v400 + 1;
    if (v400 + 1 != v855) {
      continue;
    }
    return result;
  }
}

char *sub_1CC453CD4(uint64_t *****a1, uint64_t *****a2, uint64_t *****a3)
{
  BOOL v4 = a2;
  BOOL v5 = a1;
  uint64_t v6 = *a2;
  unsigned int v7 = *a1;
  uint64_t v8 = **a2;
  int v9 = *((_DWORD *)v8 + 5);
  unsigned int v10 = v8 >> 4;
  if ((v9 & 0x10000000) != 0)
  {
    uint64_t v11 = ***v8;
    uint64_t v12 = *(void *)(v11 + 152);
    uint64_t v13 = *(unsigned int *)(v11 + 168);
    if (v13)
    {
      LODWORD(v14) = (v13 - 1) & (v10 ^ (v8 >> 9));
      size_t v15 = (uint64_t ****)(v12 + 16 * v14);
      int v16 = *v15;
      if (*v15 == v8)
      {
LABEL_9:
        uint64_t v19 = v15[1];
        size_t v22 = (size_t)*v19;
        uint64_t v20 = (char *)(v19 + 2);
        size_t v21 = v22;
        goto LABEL_10;
      }
      int v17 = 1;
      while (v16 != (uint64_t ***)-4096)
      {
        int v18 = v14 + v17++;
        uint64_t v14 = v18 & (v13 - 1);
        int v16 = *(uint64_t ****)(v12 + 16 * v14);
        if (v16 == v8)
        {
          size_t v15 = (uint64_t ****)(v12 + 16 * v14);
          goto LABEL_9;
        }
      }
    }
    size_t v15 = (uint64_t ****)(v12 + 16 * v13);
    goto LABEL_9;
  }
  size_t v21 = 0;
  uint64_t v20 = &byte_1CFBCE98E;
LABEL_10:
  char v23 = *v7;
  if ((*((unsigned char *)*v7 + 23) & 0x10) != 0)
  {
    uint64_t v24 = ***v23;
    uint64_t v25 = *(void *)(v24 + 152);
    uint64_t v26 = *(unsigned int *)(v24 + 168);
    if (v26)
    {
      LODWORD(v27) = (v26 - 1) & ((v23 >> 4) ^ (v23 >> 9));
      size_t v28 = (uint64_t ****)(v25 + 16 * v27);
      size_t v29 = *v28;
      if (*v28 == v23)
      {
LABEL_18:
        unsigned int v32 = v28[1];
        size_t v35 = (size_t)*v32;
        uint64_t v33 = (char *)(v32 + 2);
        size_t v34 = v35;
        goto LABEL_19;
      }
      int v30 = 1;
      while (v29 != (uint64_t ***)-4096)
      {
        int v31 = v27 + v30++;
        uint64_t v27 = v31 & (v26 - 1);
        size_t v29 = *(uint64_t ****)(v25 + 16 * v27);
        if (v29 == v23)
        {
          size_t v28 = (uint64_t ****)(v25 + 16 * v27);
          goto LABEL_18;
        }
      }
    }
    size_t v28 = (uint64_t ****)(v25 + 16 * v26);
    goto LABEL_18;
  }
  size_t v34 = 0;
  uint64_t v33 = &byte_1CFBCE98E;
LABEL_19:
  if (v34 >= v21) {
    size_t v36 = v21;
  }
  else {
    size_t v36 = v34;
  }
  if (v36)
  {
    int v37 = memcmp(v20, v33, v36);
    if (v37)
    {
      if ((v37 & 0x80000000) == 0) {
        goto LABEL_25;
      }
LABEL_33:
      uint64_t v48 = *a3;
      uint64_t v49 = **a3;
      if ((*((unsigned char *)v49 + 23) & 0x10) == 0)
      {
        size_t v85 = 0;
        uint64_t result = &byte_1CFBCE98E;
        if ((v9 & 0x10000000) != 0)
        {
LABEL_67:
          uint64_t v87 = ***v8;
          uint64_t v88 = *(void *)(v87 + 152);
          uint64_t v89 = *(unsigned int *)(v87 + 168);
          if (v89)
          {
            LODWORD(v90) = (v89 - 1) & (v10 ^ (v8 >> 9));
            uint64_t v91 = (uint64_t ****)(v88 + 16 * v90);
            uint64_t v92 = *v91;
            if (*v91 == v8)
            {
LABEL_74:
              int v95 = v91[1];
              size_t v98 = (size_t)*v95;
              BOOL v96 = (char *)(v95 + 2);
              size_t v97 = v98;
              goto LABEL_75;
            }
            int v93 = 1;
            while (v92 != (uint64_t ***)-4096)
            {
              int v94 = v90 + v93++;
              uint64_t v90 = v94 & (v89 - 1);
              uint64_t v92 = *(uint64_t ****)(v88 + 16 * v90);
              if (v92 == v8)
              {
                uint64_t v91 = (uint64_t ****)(v88 + 16 * v90);
                goto LABEL_74;
              }
            }
          }
          uint64_t v91 = (uint64_t ****)(v88 + 16 * v89);
          goto LABEL_74;
        }
LABEL_135:
        size_t v97 = 0;
        BOOL v96 = &byte_1CFBCE98E;
LABEL_75:
        if (v97 >= v85) {
          size_t v99 = v85;
        }
        else {
          size_t v99 = v97;
        }
        if (v99 && (uint64_t result = (char *)memcmp(result, v96, v99), result))
        {
          if ((result & 0x80000000) == 0) {
            goto LABEL_81;
          }
        }
        else if (v85 >= v97)
        {
LABEL_81:
          *BOOL v5 = v6;
          *BOOL v4 = v7;
          uint64_t v48 = *a3;
          __int32 v100 = **a3;
          if ((*((unsigned char *)v100 + 23) & 0x10) == 0)
          {
            size_t v122 = 0;
            uint64_t result = &byte_1CFBCE98E;
LABEL_101:
            BOOL v124 = *v7;
            if ((*((unsigned char *)*v7 + 23) & 0x10) == 0)
            {
              size_t v140 = 0;
              int v139 = &byte_1CFBCE98E;
              goto LABEL_120;
            }
            uint64_t v125 = ***v124;
            uint64_t v126 = *(void *)(v125 + 152);
            uint64_t v127 = *(unsigned int *)(v125 + 168);
            if (v127)
            {
              LODWORD(v128) = (v127 - 1) & ((v124 >> 4) ^ (v124 >> 9));
              int v129 = (uint64_t ****)(v126 + 16 * v128);
              size_t v130 = *v129;
              if (*v129 == v124)
              {
LABEL_119:
                int v138 = v129[1];
                size_t v141 = (size_t)*v138;
                int v139 = (char *)(v138 + 2);
                size_t v140 = v141;
LABEL_120:
                if (v140 >= v122) {
                  size_t v142 = v122;
                }
                else {
                  size_t v142 = v140;
                }
                if (v142)
                {
                  uint64_t result = (char *)memcmp(result, v139, v142);
                  if (result)
                  {
                    BOOL v5 = v4;
                    BOOL v4 = a3;
                    goto LABEL_126;
                  }
                }
                BOOL v5 = v4;
                BOOL v4 = a3;
                if (v122 >= v140) {
                  return result;
                }
LABEL_116:
                *BOOL v5 = v48;
                *BOOL v4 = v7;
                return result;
              }
              int v131 = 1;
              while (v130 != (uint64_t ***)-4096)
              {
                int v132 = v128 + v131++;
                uint64_t v128 = v132 & (v127 - 1);
                size_t v130 = *(uint64_t ****)(v126 + 16 * v128);
                if (v130 == v124)
                {
                  int v129 = (uint64_t ****)(v126 + 16 * v128);
                  goto LABEL_119;
                }
              }
            }
            int v129 = (uint64_t ****)(v126 + 16 * v127);
            goto LABEL_119;
          }
          uint64_t v101 = ***v100;
          uint64_t v102 = *(void *)(v101 + 152);
          uint64_t v103 = *(unsigned int *)(v101 + 168);
          if (v103)
          {
            LODWORD(v104) = (v103 - 1) & ((v100 >> 4) ^ (v100 >> 9));
            uint64_t v105 = (uint64_t ****)(v102 + 16 * v104);
            uint64_t v106 = *v105;
            if (*v105 == v100)
            {
LABEL_100:
              uint64_t v121 = v105[1];
              size_t v123 = (size_t)*v121;
              uint64_t result = (char *)(v121 + 2);
              size_t v122 = v123;
              goto LABEL_101;
            }
            int v107 = 1;
            while (v106 != (uint64_t ***)-4096)
            {
              int v108 = v104 + v107++;
              uint64_t v104 = v108 & (v103 - 1);
              uint64_t v106 = *(uint64_t ****)(v102 + 16 * v104);
              if (v106 == v100)
              {
                uint64_t v105 = (uint64_t ****)(v102 + 16 * v104);
                goto LABEL_100;
              }
            }
          }
          uint64_t v105 = (uint64_t ****)(v102 + 16 * v103);
          goto LABEL_100;
        }
        BOOL v4 = a3;
        goto LABEL_116;
      }
      uint64_t v50 = ***v49;
      uint64_t v51 = *(void *)(v50 + 152);
      uint64_t v52 = *(unsigned int *)(v50 + 168);
      if (v52)
      {
        LODWORD(v53) = (v52 - 1) & ((v49 >> 4) ^ (v49 >> 9));
        int v54 = (uint64_t ****)(v51 + 16 * v53);
        unsigned int v55 = *v54;
        if (*v54 == v49) {
          goto LABEL_66;
        }
        int v56 = 1;
        while (v55 != (uint64_t ***)-4096)
        {
          int v57 = v53 + v56++;
          uint64_t v53 = v57 & (v52 - 1);
          unsigned int v55 = *(uint64_t ****)(v51 + 16 * v53);
          if (v55 == v49)
          {
            int v54 = (uint64_t ****)(v51 + 16 * v53);
            goto LABEL_66;
          }
        }
      }
      int v54 = (uint64_t ****)(v51 + 16 * v52);
LABEL_66:
      size_t v84 = v54[1];
      size_t v86 = (size_t)*v84;
      uint64_t result = (char *)(v84 + 2);
      size_t v85 = v86;
      if ((v9 & 0x10000000) != 0) {
        goto LABEL_67;
      }
      goto LABEL_135;
    }
  }
  if (v21 < v34) {
    goto LABEL_33;
  }
LABEL_25:
  BOOL v38 = *a3;
  int v39 = **a3;
  if ((*((unsigned char *)v39 + 23) & 0x10) != 0)
  {
    uint64_t v40 = ***v39;
    uint64_t v41 = *(void *)(v40 + 152);
    uint64_t v42 = *(unsigned int *)(v40 + 168);
    if (v42)
    {
      LODWORD(v43) = (v42 - 1) & ((v39 >> 4) ^ (v39 >> 9));
      size_t v44 = (uint64_t ****)(v41 + 16 * v43);
      size_t v45 = *v44;
      if (*v44 == v39) {
        goto LABEL_41;
      }
      int v46 = 1;
      while (v45 != (uint64_t ***)-4096)
      {
        int v47 = v43 + v46++;
        uint64_t v43 = v47 & (v42 - 1);
        size_t v45 = *(uint64_t ****)(v41 + 16 * v43);
        if (v45 == v39)
        {
          size_t v44 = (uint64_t ****)(v41 + 16 * v43);
          goto LABEL_41;
        }
      }
    }
    size_t v44 = (uint64_t ****)(v41 + 16 * v42);
LABEL_41:
    uint64_t v58 = v44[1];
    size_t v61 = (size_t)*v58;
    uint64_t result = (char *)(v58 + 2);
    size_t v60 = v61;
    if ((v9 & 0x10000000) != 0) {
      goto LABEL_42;
    }
    goto LABEL_133;
  }
  size_t v60 = 0;
  uint64_t result = &byte_1CFBCE98E;
  if ((v9 & 0x10000000) != 0)
  {
LABEL_42:
    uint64_t v62 = ***v8;
    uint64_t v63 = *(void *)(v62 + 152);
    uint64_t v64 = *(unsigned int *)(v62 + 168);
    if (v64)
    {
      LODWORD(v65) = (v64 - 1) & (v10 ^ (v8 >> 9));
      unsigned int v66 = (uint64_t ****)(v63 + 16 * v65);
      int v67 = *v66;
      if (*v66 == v8)
      {
LABEL_49:
        int v70 = v66[1];
        size_t v73 = (size_t)*v70;
        size_t v71 = (char *)(v70 + 2);
        size_t v72 = v73;
        goto LABEL_50;
      }
      int v68 = 1;
      while (v67 != (uint64_t ***)-4096)
      {
        int v69 = v65 + v68++;
        uint64_t v65 = v69 & (v64 - 1);
        int v67 = *(uint64_t ****)(v63 + 16 * v65);
        if (v67 == v8)
        {
          unsigned int v66 = (uint64_t ****)(v63 + 16 * v65);
          goto LABEL_49;
        }
      }
    }
    unsigned int v66 = (uint64_t ****)(v63 + 16 * v64);
    goto LABEL_49;
  }
LABEL_133:
  size_t v72 = 0;
  size_t v71 = &byte_1CFBCE98E;
LABEL_50:
  if (v72 >= v60) {
    size_t v74 = v60;
  }
  else {
    size_t v74 = v72;
  }
  if (v74 && (uint64_t result = (char *)memcmp(result, v71, v74), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v60 >= v72)
  {
    return result;
  }
  *BOOL v4 = v38;
  *a3 = v6;
  uint64_t v48 = *v4;
  unsigned int v7 = *v5;
  uint64_t v75 = **v4;
  if ((*((unsigned char *)v75 + 23) & 0x10) != 0)
  {
    uint64_t v76 = ***v75;
    uint64_t v77 = *(void *)(v76 + 152);
    uint64_t v78 = *(unsigned int *)(v76 + 168);
    if (v78)
    {
      LODWORD(v79) = (v78 - 1) & ((v75 >> 4) ^ (v75 >> 9));
      int v80 = (uint64_t ****)(v77 + 16 * v79);
      size_t v81 = *v80;
      if (*v80 == v75)
      {
LABEL_91:
        int v109 = v80[1];
        size_t v111 = (size_t)*v109;
        uint64_t result = (char *)(v109 + 2);
        size_t v110 = v111;
        goto LABEL_92;
      }
      int v82 = 1;
      while (v81 != (uint64_t ***)-4096)
      {
        int v83 = v79 + v82++;
        uint64_t v79 = v83 & (v78 - 1);
        size_t v81 = *(uint64_t ****)(v77 + 16 * v79);
        if (v81 == v75)
        {
          int v80 = (uint64_t ****)(v77 + 16 * v79);
          goto LABEL_91;
        }
      }
    }
    int v80 = (uint64_t ****)(v77 + 16 * v78);
    goto LABEL_91;
  }
  size_t v110 = 0;
  uint64_t result = &byte_1CFBCE98E;
LABEL_92:
  size_t v112 = *v7;
  if ((*((unsigned char *)*v7 + 23) & 0x10) != 0)
  {
    uint64_t v113 = ***v112;
    uint64_t v114 = *(void *)(v113 + 152);
    uint64_t v115 = *(unsigned int *)(v113 + 168);
    if (v115)
    {
      LODWORD(v116) = (v115 - 1) & ((v112 >> 4) ^ (v112 >> 9));
      int v117 = (uint64_t ****)(v114 + 16 * v116);
      long long v118 = *v117;
      if (*v117 == v112)
      {
LABEL_109:
        uint64_t v133 = v117[1];
        size_t v136 = (size_t)*v133;
        uint64_t v134 = (char *)(v133 + 2);
        size_t v135 = v136;
        goto LABEL_110;
      }
      int v119 = 1;
      while (v118 != (uint64_t ***)-4096)
      {
        int v120 = v116 + v119++;
        uint64_t v116 = v120 & (v115 - 1);
        long long v118 = *(uint64_t ****)(v114 + 16 * v116);
        if (v118 == v112)
        {
          int v117 = (uint64_t ****)(v114 + 16 * v116);
          goto LABEL_109;
        }
      }
    }
    int v117 = (uint64_t ****)(v114 + 16 * v115);
    goto LABEL_109;
  }
  size_t v135 = 0;
  uint64_t v134 = &byte_1CFBCE98E;
LABEL_110:
  if (v135 >= v110) {
    size_t v137 = v110;
  }
  else {
    size_t v137 = v135;
  }
  if (!v137 || (uint64_t result = (char *)memcmp(result, v134, v137), !result))
  {
    if (v110 >= v135) {
      return result;
    }
    goto LABEL_116;
  }
LABEL_126:
  if ((result & 0x80000000) != 0) {
    goto LABEL_116;
  }
  return result;
}

BOOL sub_1CC454398(uint64_t *****a1, uint64_t *****a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      unsigned int v7 = *a1;
      uint64_t v8 = *v6;
      if ((*((unsigned char *)*v6 + 23) & 0x10) != 0)
      {
        uint64_t v9 = ***v8;
        uint64_t v10 = *(void *)(v9 + 152);
        uint64_t v11 = *(unsigned int *)(v9 + 168);
        if (v11)
        {
          LODWORD(v12) = (v11 - 1) & ((v8 >> 4) ^ (v8 >> 9));
          uint64_t v13 = (uint64_t ****)(v10 + 16 * v12);
          uint64_t v14 = *v13;
          if (*v13 != v8)
          {
            int v15 = 1;
            do
            {
              if (v14 == (uint64_t ***)-4096) {
                goto LABEL_85;
              }
              int v16 = v12 + v15++;
              uint64_t v12 = v16 & (v11 - 1);
              uint64_t v14 = *(uint64_t ****)(v10 + 16 * v12);
            }
            while (v14 != v8);
            uint64_t v13 = (uint64_t ****)(v10 + 16 * v12);
          }
        }
        else
        {
LABEL_85:
          uint64_t v13 = (uint64_t ****)(v10 + 16 * v11);
        }
        int v93 = v13[1];
        size_t v96 = (size_t)*v93;
        int v94 = (char *)(v93 + 2);
        size_t v95 = v96;
      }
      else
      {
        size_t v95 = 0;
        int v94 = &byte_1CFBCE98E;
      }
      size_t v97 = *v7;
      if ((*((unsigned char *)*v7 + 23) & 0x10) != 0)
      {
        uint64_t v98 = ***v97;
        uint64_t v99 = *(void *)(v98 + 152);
        uint64_t v100 = *(unsigned int *)(v98 + 168);
        if (v100)
        {
          LODWORD(v101) = (v100 - 1) & ((v97 >> 4) ^ (v97 >> 9));
          uint64_t v102 = (uint64_t ****)(v99 + 16 * v101);
          uint64_t v103 = *v102;
          if (*v102 != v97)
          {
            int v104 = 1;
            do
            {
              if (v103 == (uint64_t ***)-4096) {
                goto LABEL_103;
              }
              int v105 = v101 + v104++;
              uint64_t v101 = v105 & (v100 - 1);
              uint64_t v103 = *(uint64_t ****)(v99 + 16 * v101);
            }
            while (v103 != v97);
            uint64_t v102 = (uint64_t ****)(v99 + 16 * v101);
          }
        }
        else
        {
LABEL_103:
          uint64_t v102 = (uint64_t ****)(v99 + 16 * v100);
        }
        int v119 = v102[1];
        size_t v122 = (size_t)*v119;
        int v120 = (char *)(v119 + 2);
        size_t v121 = v122;
      }
      else
      {
        size_t v121 = 0;
        int v120 = &byte_1CFBCE98E;
      }
      if (v121 >= v95) {
        size_t v123 = v95;
      }
      else {
        size_t v123 = v121;
      }
      if (v123 && (int v124 = memcmp(v94, v120, v123)) != 0)
      {
        if ((v124 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v95 >= v121)
      {
        return 1;
      }
      *a1 = v6;
      *(a2 - 1) = v7;
      return 1;
    case 3:
      sub_1CC453CD4(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CC454E30(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      int v80 = a1 + 2;
      size_t v81 = a1 + 3;
      sub_1CC454E30(a1, a1 + 1, a1 + 2, a1 + 3);
      int v82 = *(a2 - 1);
      int v83 = a1[3];
      size_t v84 = *v82;
      if ((*((unsigned char *)*v82 + 23) & 0x10) != 0)
      {
        uint64_t v85 = ***v84;
        uint64_t v86 = *(void *)(v85 + 152);
        uint64_t v87 = *(unsigned int *)(v85 + 168);
        if (v87)
        {
          LODWORD(v88) = (v87 - 1) & ((v84 >> 4) ^ (v84 >> 9));
          uint64_t v89 = (uint64_t ****)(v86 + 16 * v88);
          uint64_t v90 = *v89;
          if (*v89 != v84)
          {
            int v91 = 1;
            do
            {
              if (v90 == (uint64_t ***)-4096) {
                goto LABEL_94;
              }
              int v92 = v88 + v91++;
              uint64_t v88 = v92 & (v87 - 1);
              uint64_t v90 = *(uint64_t ****)(v86 + 16 * v88);
            }
            while (v90 != v84);
            uint64_t v89 = (uint64_t ****)(v86 + 16 * v88);
          }
        }
        else
        {
LABEL_94:
          uint64_t v89 = (uint64_t ****)(v86 + 16 * v87);
        }
        uint64_t v106 = v89[1];
        size_t v109 = (size_t)*v106;
        int v107 = (char *)(v106 + 2);
        size_t v108 = v109;
        goto LABEL_96;
      }
      size_t v108 = 0;
      int v107 = &byte_1CFBCE98E;
LABEL_96:
      size_t v110 = *v83;
      if ((*((unsigned char *)*v83 + 23) & 0x10) != 0)
      {
        uint64_t v111 = ***v110;
        uint64_t v112 = *(void *)(v111 + 152);
        uint64_t v113 = *(unsigned int *)(v111 + 168);
        if (v113)
        {
          LODWORD(v114) = (v113 - 1) & ((v110 >> 4) ^ (v110 >> 9));
          uint64_t v115 = (uint64_t ****)(v112 + 16 * v114);
          uint64_t v116 = *v115;
          if (*v115 != v110)
          {
            int v117 = 1;
            do
            {
              if (v116 == (uint64_t ***)-4096) {
                goto LABEL_114;
              }
              int v118 = v114 + v117++;
              uint64_t v114 = v118 & (v113 - 1);
              uint64_t v116 = *(uint64_t ****)(v112 + 16 * v114);
            }
            while (v116 != v110);
            uint64_t v115 = (uint64_t ****)(v112 + 16 * v114);
          }
        }
        else
        {
LABEL_114:
          uint64_t v115 = (uint64_t ****)(v112 + 16 * v113);
        }
        uint64_t v125 = v115[1];
        size_t v128 = (size_t)*v125;
        uint64_t v126 = (char *)(v125 + 2);
        size_t v127 = v128;
        goto LABEL_116;
      }
      size_t v127 = 0;
      uint64_t v126 = &byte_1CFBCE98E;
LABEL_116:
      if (v127 >= v108) {
        size_t v129 = v108;
      }
      else {
        size_t v129 = v127;
      }
      if (v129 && (int v130 = memcmp(v107, v126, v129)) != 0)
      {
        if ((v130 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v108 >= v127)
      {
        return 1;
      }
      *size_t v81 = v82;
      *(a2 - 1) = v83;
      int v131 = *v81;
      int v132 = *v80;
      uint64_t v133 = **v81;
      if ((*((unsigned char *)v133 + 23) & 0x10) != 0)
      {
        uint64_t v134 = ***v133;
        uint64_t v135 = *(void *)(v134 + 152);
        uint64_t v136 = *(unsigned int *)(v134 + 168);
        if (v136)
        {
          LODWORD(v137) = (v136 - 1) & ((v133 >> 4) ^ (v133 >> 9));
          int v138 = (uint64_t ****)(v135 + 16 * v137);
          int v139 = *v138;
          if (*v138 != v133)
          {
            int v140 = 1;
            do
            {
              if (v139 == (uint64_t ***)-4096) {
                goto LABEL_131;
              }
              int v141 = v137 + v140++;
              uint64_t v137 = v141 & (v136 - 1);
              int v139 = *(uint64_t ****)(v135 + 16 * v137);
            }
            while (v139 != v133);
            int v138 = (uint64_t ****)(v135 + 16 * v137);
          }
        }
        else
        {
LABEL_131:
          int v138 = (uint64_t ****)(v135 + 16 * v136);
        }
        size_t v142 = v138[1];
        size_t v145 = (size_t)*v142;
        size_t v143 = (char *)(v142 + 2);
        size_t v144 = v145;
        goto LABEL_133;
      }
      size_t v144 = 0;
      size_t v143 = &byte_1CFBCE98E;
LABEL_133:
      int v146 = *v132;
      if ((*((unsigned char *)*v132 + 23) & 0x10) != 0)
      {
        uint64_t v147 = ***v146;
        uint64_t v148 = *(void *)(v147 + 152);
        uint64_t v149 = *(unsigned int *)(v147 + 168);
        if (v149)
        {
          LODWORD(v150) = (v149 - 1) & ((v146 >> 4) ^ (v146 >> 9));
          unsigned int v151 = (uint64_t ****)(v148 + 16 * v150);
          long long v152 = *v151;
          if (*v151 != v146)
          {
            int v153 = 1;
            do
            {
              if (v152 == (uint64_t ***)-4096) {
                goto LABEL_140;
              }
              int v154 = v150 + v153++;
              uint64_t v150 = v154 & (v149 - 1);
              long long v152 = *(uint64_t ****)(v148 + 16 * v150);
            }
            while (v152 != v146);
            unsigned int v151 = (uint64_t ****)(v148 + 16 * v150);
          }
        }
        else
        {
LABEL_140:
          unsigned int v151 = (uint64_t ****)(v148 + 16 * v149);
        }
        uint64_t v155 = v151[1];
        size_t v158 = (size_t)*v155;
        uint64_t v156 = (char *)(v155 + 2);
        size_t v157 = v158;
        goto LABEL_142;
      }
      size_t v157 = 0;
      uint64_t v156 = &byte_1CFBCE98E;
LABEL_142:
      if (v157 >= v144) {
        size_t v159 = v144;
      }
      else {
        size_t v159 = v157;
      }
      if (v159 && (int v160 = memcmp(v143, v156, v159)) != 0)
      {
        if ((v160 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v144 >= v157)
      {
        return 1;
      }
      *int v80 = v131;
      *size_t v81 = v132;
      int v161 = a1[1];
      v162 = *v131;
      if ((*((unsigned char *)*v131 + 23) & 0x10) != 0)
      {
        uint64_t v163 = ***v162;
        uint64_t v164 = *(void *)(v163 + 152);
        uint64_t v165 = *(unsigned int *)(v163 + 168);
        if (v165)
        {
          LODWORD(v166) = (v165 - 1) & ((v162 >> 4) ^ (v162 >> 9));
          uint64_t v167 = (uint64_t ****)(v164 + 16 * v166);
          uint64_t v168 = *v167;
          if (*v167 != v162)
          {
            int v169 = 1;
            do
            {
              if (v168 == (uint64_t ***)-4096) {
                goto LABEL_157;
              }
              int v170 = v166 + v169++;
              uint64_t v166 = v170 & (v165 - 1);
              uint64_t v168 = *(uint64_t ****)(v164 + 16 * v166);
            }
            while (v168 != v162);
            uint64_t v167 = (uint64_t ****)(v164 + 16 * v166);
          }
        }
        else
        {
LABEL_157:
          uint64_t v167 = (uint64_t ****)(v164 + 16 * v165);
        }
        uint64_t v171 = v167[1];
        size_t v174 = (size_t)*v171;
        int v172 = (char *)(v171 + 2);
        size_t v173 = v174;
        goto LABEL_159;
      }
      size_t v173 = 0;
      int v172 = &byte_1CFBCE98E;
LABEL_159:
      char v175 = *v161;
      if ((*((unsigned char *)*v161 + 23) & 0x10) != 0)
      {
        uint64_t v176 = ***v175;
        uint64_t v177 = *(void *)(v176 + 152);
        uint64_t v178 = *(unsigned int *)(v176 + 168);
        if (v178)
        {
          LODWORD(v179) = (v178 - 1) & ((v175 >> 4) ^ (v175 >> 9));
          int v180 = (uint64_t ****)(v177 + 16 * v179);
          size_t v181 = *v180;
          if (*v180 != v175)
          {
            int v182 = 1;
            do
            {
              if (v181 == (uint64_t ***)-4096) {
                goto LABEL_166;
              }
              int v183 = v179 + v182++;
              uint64_t v179 = v183 & (v178 - 1);
              size_t v181 = *(uint64_t ****)(v177 + 16 * v179);
            }
            while (v181 != v175);
            int v180 = (uint64_t ****)(v177 + 16 * v179);
          }
        }
        else
        {
LABEL_166:
          int v180 = (uint64_t ****)(v177 + 16 * v178);
        }
        long long v184 = v180[1];
        size_t v187 = (size_t)*v184;
        int64_t v185 = (char *)(v184 + 2);
        size_t v186 = v187;
        goto LABEL_168;
      }
      size_t v186 = 0;
      int64_t v185 = &byte_1CFBCE98E;
LABEL_168:
      if (v186 >= v173) {
        size_t v188 = v173;
      }
      else {
        size_t v188 = v186;
      }
      if (v188 && (int v189 = memcmp(v172, v185, v188)) != 0)
      {
        if ((v189 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v173 >= v186)
      {
        return 1;
      }
      a1[1] = v131;
      a1[2] = v161;
      uint64_t v190 = *a1;
      int v191 = *v131;
      if ((*((unsigned char *)*v131 + 23) & 0x10) != 0)
      {
        uint64_t v192 = ***v191;
        uint64_t v193 = *(void *)(v192 + 152);
        uint64_t v194 = *(unsigned int *)(v192 + 168);
        if (v194)
        {
          LODWORD(v195) = (v194 - 1) & ((v191 >> 4) ^ (v191 >> 9));
          size_t v196 = (uint64_t ****)(v193 + 16 * v195);
          uint64_t v197 = *v196;
          if (*v196 != v191)
          {
            int v198 = 1;
            do
            {
              if (v197 == (uint64_t ***)-4096) {
                goto LABEL_187;
              }
              int v199 = v195 + v198++;
              uint64_t v195 = v199 & (v194 - 1);
              uint64_t v197 = *(uint64_t ****)(v193 + 16 * v195);
            }
            while (v197 != v191);
            size_t v196 = (uint64_t ****)(v193 + 16 * v195);
          }
        }
        else
        {
LABEL_187:
          size_t v196 = (uint64_t ****)(v193 + 16 * v194);
        }
        uint64_t v200 = v196[1];
        size_t v203 = (size_t)*v200;
        char v201 = (char *)(v200 + 2);
        size_t v202 = v203;
        goto LABEL_189;
      }
      size_t v202 = 0;
      char v201 = &byte_1CFBCE98E;
LABEL_189:
      int v204 = *v190;
      if ((*((unsigned char *)*v190 + 23) & 0x10) != 0)
      {
        uint64_t v205 = ***v204;
        uint64_t v206 = *(void *)(v205 + 152);
        uint64_t v207 = *(unsigned int *)(v205 + 168);
        if (v207)
        {
          LODWORD(v208) = (v207 - 1) & ((v204 >> 4) ^ (v204 >> 9));
          int v209 = (uint64_t ****)(v206 + 16 * v208);
          BOOL v210 = *v209;
          if (*v209 != v204)
          {
            int v211 = 1;
            do
            {
              if (v210 == (uint64_t ***)-4096) {
                goto LABEL_196;
              }
              int v212 = v208 + v211++;
              uint64_t v208 = v212 & (v207 - 1);
              BOOL v210 = *(uint64_t ****)(v206 + 16 * v208);
            }
            while (v210 != v204);
            int v209 = (uint64_t ****)(v206 + 16 * v208);
          }
        }
        else
        {
LABEL_196:
          int v209 = (uint64_t ****)(v206 + 16 * v207);
        }
        size_t v213 = v209[1];
        size_t v216 = (size_t)*v213;
        size_t v214 = (char *)(v213 + 2);
        size_t v215 = v216;
        goto LABEL_198;
      }
      size_t v215 = 0;
      size_t v214 = &byte_1CFBCE98E;
LABEL_198:
      if (v215 >= v202) {
        size_t v217 = v202;
      }
      else {
        size_t v217 = v215;
      }
      if (v217 && (int v218 = memcmp(v201, v214, v217)) != 0)
      {
        if ((v218 & 0x80000000) == 0) {
          return 1;
        }
      }
      else if (v202 >= v215)
      {
        return 1;
      }
      *a1 = v131;
      a1[1] = v190;
      return 1;
    default:
      int v17 = a1 + 2;
      sub_1CC453CD4(a1, a1 + 1, a1 + 2);
      int v18 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v19 = 0;
      break;
  }
  do
  {
    uint64_t v20 = *v18;
    size_t v21 = **v18;
    if ((*((unsigned char *)v21 + 23) & 0x10) != 0)
    {
      uint64_t v22 = ***v21;
      uint64_t v23 = *(void *)(v22 + 152);
      uint64_t v24 = *(unsigned int *)(v22 + 168);
      if (v24)
      {
        LODWORD(v25) = (v24 - 1) & ((v21 >> 4) ^ (v21 >> 9));
        uint64_t v26 = (uint64_t ****)(v23 + 16 * v25);
        uint64_t v27 = *v26;
        if (*v26 == v21)
        {
LABEL_19:
          int v30 = v26[1];
          size_t v33 = (size_t)*v30;
          int v31 = (char *)(v30 + 2);
          size_t v32 = v33;
          goto LABEL_20;
        }
        int v28 = 1;
        while (v27 != (uint64_t ***)-4096)
        {
          int v29 = v25 + v28++;
          uint64_t v25 = v29 & (v24 - 1);
          uint64_t v27 = *(uint64_t ****)(v23 + 16 * v25);
          if (v27 == v21)
          {
            uint64_t v26 = (uint64_t ****)(v23 + 16 * v25);
            goto LABEL_19;
          }
        }
      }
      uint64_t v26 = (uint64_t ****)(v23 + 16 * v24);
      goto LABEL_19;
    }
    size_t v32 = 0;
    int v31 = &byte_1CFBCE98E;
LABEL_20:
    size_t v34 = *v17;
    size_t v35 = **v17;
    if ((*((unsigned char *)v35 + 23) & 0x10) == 0)
    {
      size_t v46 = 0;
      size_t v45 = &byte_1CFBCE98E;
      goto LABEL_29;
    }
    uint64_t v36 = ***v35;
    uint64_t v37 = *(void *)(v36 + 152);
    uint64_t v38 = *(unsigned int *)(v36 + 168);
    if (!v38) {
      goto LABEL_27;
    }
    LODWORD(v39) = (v38 - 1) & ((v35 >> 4) ^ (v35 >> 9));
    uint64_t v40 = (uint64_t ****)(v37 + 16 * v39);
    uint64_t v41 = *v40;
    if (*v40 != v35)
    {
      int v42 = 1;
      while (v41 != (uint64_t ***)-4096)
      {
        int v43 = v39 + v42++;
        uint64_t v39 = v43 & (v38 - 1);
        uint64_t v41 = *(uint64_t ****)(v37 + 16 * v39);
        if (v41 == v35)
        {
          uint64_t v40 = (uint64_t ****)(v37 + 16 * v39);
          goto LABEL_28;
        }
      }
LABEL_27:
      uint64_t v40 = (uint64_t ****)(v37 + 16 * v38);
    }
LABEL_28:
    size_t v44 = v40[1];
    size_t v47 = (size_t)*v44;
    size_t v45 = (char *)(v44 + 2);
    size_t v46 = v47;
LABEL_29:
    if (v46 >= v32) {
      size_t v48 = v32;
    }
    else {
      size_t v48 = v46;
    }
    if (v48 && (int v49 = memcmp(v31, v45, v48)) != 0)
    {
      if ((v49 & 0x80000000) == 0) {
        goto LABEL_71;
      }
    }
    else if (v32 >= v46)
    {
      goto LABEL_71;
    }
    uint64_t v50 = v18;
    while (1)
    {
      *uint64_t v50 = v34;
      if (v17 == a1) {
        break;
      }
      uint64_t v50 = v17;
      uint64_t v51 = *v20;
      if ((*((unsigned char *)*v20 + 23) & 0x10) != 0)
      {
        uint64_t v52 = ***v51;
        uint64_t v53 = *(void *)(v52 + 152);
        uint64_t v54 = *(unsigned int *)(v52 + 168);
        if (!v54) {
          goto LABEL_46;
        }
        LODWORD(v55) = (v54 - 1) & ((v51 >> 4) ^ (v51 >> 9));
        int v56 = (uint64_t ****)(v53 + 16 * v55);
        int v57 = *v56;
        if (*v56 != v51)
        {
          int v58 = 1;
          while (v57 != (uint64_t ***)-4096)
          {
            int v59 = v55 + v58++;
            uint64_t v55 = v59 & (v54 - 1);
            int v57 = *(uint64_t ****)(v53 + 16 * v55);
            if (v57 == v51)
            {
              int v56 = (uint64_t ****)(v53 + 16 * v55);
              goto LABEL_47;
            }
          }
LABEL_46:
          int v56 = (uint64_t ****)(v53 + 16 * v54);
        }
LABEL_47:
        size_t v60 = v56[1];
        size_t v63 = (size_t)*v60;
        size_t v61 = (char *)(v60 + 2);
        size_t v62 = v63;
        goto LABEL_48;
      }
      size_t v62 = 0;
      size_t v61 = &byte_1CFBCE98E;
LABEL_48:
      --v17;
      size_t v34 = *(v50 - 1);
      uint64_t v64 = *v34;
      if ((*((unsigned char *)*v34 + 23) & 0x10) == 0)
      {
        size_t v75 = 0;
        size_t v74 = &byte_1CFBCE98E;
        goto LABEL_57;
      }
      uint64_t v65 = ***v64;
      uint64_t v66 = *(void *)(v65 + 152);
      uint64_t v67 = *(unsigned int *)(v65 + 168);
      if (!v67) {
        goto LABEL_55;
      }
      LODWORD(v68) = (v67 - 1) & ((v64 >> 4) ^ (v64 >> 9));
      int v69 = (uint64_t ****)(v66 + 16 * v68);
      int v70 = *v69;
      if (*v69 != v64)
      {
        int v71 = 1;
        while (v70 != (uint64_t ***)-4096)
        {
          int v72 = v68 + v71++;
          uint64_t v68 = v72 & (v67 - 1);
          int v70 = *(uint64_t ****)(v66 + 16 * v68);
          if (v70 == v64)
          {
            int v69 = (uint64_t ****)(v66 + 16 * v68);
            goto LABEL_56;
          }
        }
LABEL_55:
        int v69 = (uint64_t ****)(v66 + 16 * v67);
      }
LABEL_56:
      size_t v73 = v69[1];
      size_t v76 = (size_t)*v73;
      size_t v74 = (char *)(v73 + 2);
      size_t v75 = v76;
LABEL_57:
      if (v75 >= v62) {
        size_t v77 = v62;
      }
      else {
        size_t v77 = v75;
      }
      if (v77 && (int v78 = memcmp(v61, v74, v77)) != 0)
      {
        int v79 = (v78 >> 31) | 1;
      }
      else
      {
        if (v62 >= v75) {
          goto LABEL_70;
        }
        int v79 = -1;
      }
      if (v79 != -1) {
        goto LABEL_70;
      }
    }
    uint64_t v50 = a1;
LABEL_70:
    *uint64_t v50 = v20;
    if (++v19 == 8) {
      return v18 + 1 == a2;
    }
LABEL_71:
    int v17 = v18++;
  }
  while (v18 != a2);
  return 1;
}

char *sub_1CC454E30(uint64_t *****a1, uint64_t *****a2, uint64_t *****a3, uint64_t *****a4)
{
  sub_1CC453CD4(a1, a2, a3);
  uint64_t v8 = *a4;
  uint64_t v9 = *a3;
  uint64_t v10 = **a4;
  if ((*((unsigned char *)v10 + 23) & 0x10) != 0)
  {
    uint64_t v11 = ***v10;
    uint64_t v12 = *(void *)(v11 + 152);
    uint64_t v13 = *(unsigned int *)(v11 + 168);
    if (v13)
    {
      LODWORD(v14) = (v13 - 1) & ((v10 >> 4) ^ (v10 >> 9));
      int v15 = (uint64_t ****)(v12 + 16 * v14);
      int v16 = *v15;
      if (*v15 == v10)
      {
LABEL_9:
        int v19 = v15[1];
        size_t v22 = (size_t)*v19;
        BOOL result = (char *)(v19 + 2);
        size_t v21 = v22;
        goto LABEL_10;
      }
      int v17 = 1;
      while (v16 != (uint64_t ***)-4096)
      {
        int v18 = v14 + v17++;
        uint64_t v14 = v18 & (v13 - 1);
        int v16 = *(uint64_t ****)(v12 + 16 * v14);
        if (v16 == v10)
        {
          int v15 = (uint64_t ****)(v12 + 16 * v14);
          goto LABEL_9;
        }
      }
    }
    int v15 = (uint64_t ****)(v12 + 16 * v13);
    goto LABEL_9;
  }
  size_t v21 = 0;
  BOOL result = &byte_1CFBCE98E;
LABEL_10:
  uint64_t v23 = *v9;
  if ((*((unsigned char *)*v9 + 23) & 0x10) != 0)
  {
    uint64_t v24 = ***v23;
    uint64_t v25 = *(void *)(v24 + 152);
    uint64_t v26 = *(unsigned int *)(v24 + 168);
    if (v26)
    {
      LODWORD(v27) = (v26 - 1) & ((v23 >> 4) ^ (v23 >> 9));
      int v28 = (uint64_t ****)(v25 + 16 * v27);
      int v29 = *v28;
      if (*v28 == v23)
      {
LABEL_18:
        size_t v32 = v28[1];
        size_t v35 = (size_t)*v32;
        size_t v33 = (char *)(v32 + 2);
        size_t v34 = v35;
        goto LABEL_19;
      }
      int v30 = 1;
      while (v29 != (uint64_t ***)-4096)
      {
        int v31 = v27 + v30++;
        uint64_t v27 = v31 & (v26 - 1);
        int v29 = *(uint64_t ****)(v25 + 16 * v27);
        if (v29 == v23)
        {
          int v28 = (uint64_t ****)(v25 + 16 * v27);
          goto LABEL_18;
        }
      }
    }
    int v28 = (uint64_t ****)(v25 + 16 * v26);
    goto LABEL_18;
  }
  size_t v34 = 0;
  size_t v33 = &byte_1CFBCE98E;
LABEL_19:
  if (v34 >= v21) {
    size_t v36 = v21;
  }
  else {
    size_t v36 = v34;
  }
  if (v36 && (BOOL result = (char *)memcmp(result, v33, v36), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v21 >= v34)
  {
    return result;
  }
  *a3 = v8;
  *a4 = v9;
  uint64_t v37 = *a3;
  uint64_t v38 = *a2;
  uint64_t v39 = **a3;
  if ((*((unsigned char *)v39 + 23) & 0x10) != 0)
  {
    uint64_t v40 = ***v39;
    uint64_t v41 = *(void *)(v40 + 152);
    uint64_t v42 = *(unsigned int *)(v40 + 168);
    if (v42)
    {
      LODWORD(v43) = (v42 - 1) & ((v39 >> 4) ^ (v39 >> 9));
      size_t v44 = (uint64_t ****)(v41 + 16 * v43);
      size_t v45 = *v44;
      if (*v44 == v39)
      {
LABEL_35:
        size_t v48 = v44[1];
        size_t v50 = (size_t)*v48;
        BOOL result = (char *)(v48 + 2);
        size_t v49 = v50;
        goto LABEL_36;
      }
      int v46 = 1;
      while (v45 != (uint64_t ***)-4096)
      {
        int v47 = v43 + v46++;
        uint64_t v43 = v47 & (v42 - 1);
        size_t v45 = *(uint64_t ****)(v41 + 16 * v43);
        if (v45 == v39)
        {
          size_t v44 = (uint64_t ****)(v41 + 16 * v43);
          goto LABEL_35;
        }
      }
    }
    size_t v44 = (uint64_t ****)(v41 + 16 * v42);
    goto LABEL_35;
  }
  size_t v49 = 0;
  BOOL result = &byte_1CFBCE98E;
LABEL_36:
  uint64_t v51 = *v38;
  if ((*((unsigned char *)*v38 + 23) & 0x10) != 0)
  {
    uint64_t v52 = ***v51;
    uint64_t v53 = *(void *)(v52 + 152);
    uint64_t v54 = *(unsigned int *)(v52 + 168);
    if (v54)
    {
      LODWORD(v55) = (v54 - 1) & ((v51 >> 4) ^ (v51 >> 9));
      int v56 = (uint64_t ****)(v53 + 16 * v55);
      int v57 = *v56;
      if (*v56 == v51)
      {
LABEL_44:
        size_t v60 = v56[1];
        size_t v63 = (size_t)*v60;
        size_t v61 = (char *)(v60 + 2);
        size_t v62 = v63;
        goto LABEL_45;
      }
      int v58 = 1;
      while (v57 != (uint64_t ***)-4096)
      {
        int v59 = v55 + v58++;
        uint64_t v55 = v59 & (v54 - 1);
        int v57 = *(uint64_t ****)(v53 + 16 * v55);
        if (v57 == v51)
        {
          int v56 = (uint64_t ****)(v53 + 16 * v55);
          goto LABEL_44;
        }
      }
    }
    int v56 = (uint64_t ****)(v53 + 16 * v54);
    goto LABEL_44;
  }
  size_t v62 = 0;
  size_t v61 = &byte_1CFBCE98E;
LABEL_45:
  if (v62 >= v49) {
    size_t v64 = v49;
  }
  else {
    size_t v64 = v62;
  }
  if (v64 && (BOOL result = (char *)memcmp(result, v61, v64), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v49 >= v62)
  {
    return result;
  }
  *a2 = v37;
  *a3 = v38;
  uint64_t v65 = *a2;
  uint64_t v66 = *a1;
  uint64_t v67 = **a2;
  if ((*((unsigned char *)v67 + 23) & 0x10) != 0)
  {
    uint64_t v68 = ***v67;
    uint64_t v69 = *(void *)(v68 + 152);
    uint64_t v70 = *(unsigned int *)(v68 + 168);
    if (v70)
    {
      LODWORD(v71) = (v70 - 1) & ((v67 >> 4) ^ (v67 >> 9));
      int v72 = (uint64_t ****)(v69 + 16 * v71);
      size_t v73 = *v72;
      if (*v72 == v67)
      {
LABEL_61:
        size_t v76 = v72[1];
        size_t v78 = (size_t)*v76;
        BOOL result = (char *)(v76 + 2);
        size_t v77 = v78;
        goto LABEL_62;
      }
      int v74 = 1;
      while (v73 != (uint64_t ***)-4096)
      {
        int v75 = v71 + v74++;
        uint64_t v71 = v75 & (v70 - 1);
        size_t v73 = *(uint64_t ****)(v69 + 16 * v71);
        if (v73 == v67)
        {
          int v72 = (uint64_t ****)(v69 + 16 * v71);
          goto LABEL_61;
        }
      }
    }
    int v72 = (uint64_t ****)(v69 + 16 * v70);
    goto LABEL_61;
  }
  size_t v77 = 0;
  BOOL result = &byte_1CFBCE98E;
LABEL_62:
  int v79 = *v66;
  if ((*((unsigned char *)*v66 + 23) & 0x10) != 0)
  {
    uint64_t v80 = ***v79;
    uint64_t v81 = *(void *)(v80 + 152);
    uint64_t v82 = *(unsigned int *)(v80 + 168);
    if (v82)
    {
      LODWORD(v83) = (v82 - 1) & ((v79 >> 4) ^ (v79 >> 9));
      size_t v84 = (uint64_t ****)(v81 + 16 * v83);
      uint64_t v85 = *v84;
      if (*v84 == v79)
      {
LABEL_70:
        uint64_t v88 = v84[1];
        size_t v91 = (size_t)*v88;
        uint64_t v89 = (char *)(v88 + 2);
        size_t v90 = v91;
        goto LABEL_71;
      }
      int v86 = 1;
      while (v85 != (uint64_t ***)-4096)
      {
        int v87 = v83 + v86++;
        uint64_t v83 = v87 & (v82 - 1);
        uint64_t v85 = *(uint64_t ****)(v81 + 16 * v83);
        if (v85 == v79)
        {
          size_t v84 = (uint64_t ****)(v81 + 16 * v83);
          goto LABEL_70;
        }
      }
    }
    size_t v84 = (uint64_t ****)(v81 + 16 * v82);
    goto LABEL_70;
  }
  size_t v90 = 0;
  uint64_t v89 = &byte_1CFBCE98E;
LABEL_71:
  if (v90 >= v77) {
    size_t v92 = v77;
  }
  else {
    size_t v92 = v90;
  }
  if (v92 && (BOOL result = (char *)memcmp(result, v89, v92), result))
  {
    if ((result & 0x80000000) == 0) {
      return result;
    }
  }
  else if (v77 >= v90)
  {
    return result;
  }
  *a1 = v65;
  *a2 = v66;
  return result;
}

uint64_t sub_1CC455274()
{
  char v3 = 0;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"print register usage details collected for analysis.";
  v1.n128_u64[1] = 52;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCD33F8, "print-regusage", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD33F8, &dword_1CB82C000);
}

void sub_1CC455300(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CC4553A0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCD34C0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)(a1 + 40) = 0x600000001;
  *(_DWORD *)(a1 + 96) = 11;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x600000001;
  *(_DWORD *)(a1 + 168) = 11;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0x600000001;
  *(_DWORD *)(a1 + 240) = 11;
  *(void *)a1 = &unk_1F26127F0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34C8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC455300;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCD34C8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC455498()
{
}

void sub_1CC4554D4(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  __n128 v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    BOOL v5 = a1;
    free(v2);
    a1 = v5;
  }
  char v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC455588(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC455634()
{
  return "Register Usage Information Collector Pass";
}

void sub_1CC455644(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PhysicalRegisterUsageInfo::ID);
  *(unsigned char *)(a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC455698(uint64_t a1, uint64_t a2)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void **)(a2 + 40);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
  uint64_t v6 = *(void *)a2;
  unsigned int v7 = ((*(unsigned __int16 *)(*(void *)a2 + 18) >> 4) & 0x3FF) - 87;
  BOOL v8 = v7 > 9;
  int v9 = (1 << v7) & 0x35F;
  if (v8 || v9 == 0)
  {
    uint64_t v12 = v5;
    uint64_t v13 = *(void *)(a2 + 8);
    if (*(void *)(v6 + 8) || (*(unsigned char *)(v6 + 23) & 8) != 0)
    {
      uint64_t v81 = 0;
      uint64_t v82 = 0;
      std::string __p = 0;
      unsigned int v14 = *(_DWORD *)(v5 + 16) + 31;
      LODWORD(v83) = -1;
      if (v14 >= 0x20)
      {
        sub_1CC2DC07C((uint64_t)&__p, v14 >> 5, &v83);
        uint64_t v6 = *(void *)a2;
      }
      int v15 = *(uint64_t **)(a1 + 8);
      uint64_t v16 = *v15;
      uint64_t v17 = v15[1];
      if (v16 == v17)
      {
LABEL_13:
        uint64_t v18 = 0;
      }
      else
      {
        while (*(_UNKNOWN **)v16 != &llvm::PhysicalRegisterUsageInfo::ID)
        {
          v16 += 16;
          if (v16 == v17) {
            goto LABEL_13;
          }
        }
        uint64_t v18 = *(void *)(v16 + 8);
      }
      uint64_t v19 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::PhysicalRegisterUsageInfo::ID);
      *(void *)(v19 + 56) = v13;
      uint64_t v83 = v85;
      uint64_t v84 = 0x600000000;
      int v86 = 0;
      uint64_t v20 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
      size_t v21 = (void *)(*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
      int v86 = 0;
      LODWORD(v84) = 0;
      (*(void (**)(uint64_t, uint64_t, void **))(*(void *)v20 + 256))(v20, a2, &v83);
      if (v84)
      {
        size_t v22 = v83;
        uint64_t v23 = 8 * v84;
        while (!*v22)
        {
          ++v22;
          v23 -= 8;
          if (!v23) {
            goto LABEL_27;
          }
        }
        uint64_t v24 = (_WORD *)(*(uint64_t (**)(void *, uint64_t))(*v21 + 32))(v21, a2);
        int v25 = (unsigned __int16)*v24;
        if (*v24)
        {
          int v26 = 0;
          uint64_t v27 = v83;
          do
          {
            if ((v27[(unsigned __int16)v25 >> 6] >> v25))
            {
              uint64_t v28 = v21[7];
              uint64_t v29 = *(unsigned int *)(v21[1] + 24 * (unsigned __int16)v25 + 4);
              if (*(_WORD *)(v28 + 2 * v29))
              {
                int v30 = *(unsigned __int16 *)(v28 + 2 * v29) + v25;
                int v31 = (unsigned __int16 *)(v28 + 2 * v29 + 2);
                do
                {
                  v27[(unsigned __int16)v30 >> 6] |= 1 << v30;
                  int v32 = *v31++;
                  v30 += v32;
                }
                while (v32);
              }
            }
            int v25 = (unsigned __int16)v24[++v26];
          }
          while (v24[v26]);
        }
      }
LABEL_27:
      size_t v33 = (unsigned __int16 *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 64))(v12, a2);
      if (v34)
      {
        size_t v35 = &v33[v34];
        uint64_t v36 = *(void *)(v12 + 8);
        uint64_t v38 = *(void *)(v12 + 48);
        uint64_t v37 = *(void *)(v12 + 56);
        uint64_t v39 = __p;
        do
        {
          unint64_t v40 = ((unint64_t)*(unsigned int *)(v36 + 24 * *v33 + 16) >> 3) & 0x1FFFFFFE;
          int v41 = *(unsigned __int16 *)(v37 + v40) + (*(_DWORD *)(v36 + 24 * *v33 + 16) & 0xF) * *v33;
          uint64_t v42 = (_WORD *)(v37 + 2 + v40);
          while (1)
          {
            uint64_t v43 = (unsigned __int16)v41;
            unsigned int v44 = *(unsigned __int16 *)(v38 + 4 * (unsigned __int16)v41);
            if (*(_WORD *)(v38 + 4 * (unsigned __int16)v41) && v37 != 0) {
              break;
            }
            int v46 = (unsigned __int16)*v42++;
            v41 += v46;
            if (!v46) {
              goto LABEL_36;
            }
          }
          while (1)
          {
            unsigned int v47 = *(unsigned __int16 *)(v38 + 4 * v43 + 2) << 16;
            uint64_t v48 = (unsigned __int16)v44;
            while (1)
            {
              size_t v49 = (unsigned __int16 *)(v37 + 2 * *(unsigned int *)(v36 + 24 * v48 + 8));
              do
              {
                v39[(unsigned __int16)v44 >> 5] &= ~(1 << v44);
                int v50 = *v49++;
                v44 += v50;
              }
              while (v50);
              uint64_t v48 = HIWORD(v47);
              if (!v48) {
                break;
              }
              unsigned int v44 = HIWORD(v47);
              v47 >>= 16;
            }
            if (!*v42) {
              break;
            }
            v41 += (unsigned __int16)*v42++;
            uint64_t v43 = (unsigned __int16)v41;
            unsigned int v44 = *(unsigned __int16 *)(v38 + 4 * (unsigned __int16)v41);
          }
LABEL_36:
          ++v33;
        }
        while (v33 != v35);
      }
      uint64_t v51 = *(unsigned int *)(v12 + 16);
      if (v51 >= 2)
      {
        uint64_t v52 = v83;
        uint64_t v53 = __p;
        for (uint64_t i = 1; i != v51; ++i)
        {
          uint64_t v55 = i >> 6;
          if (((1 << i) & v52[v55]) == 0)
          {
            if ((i & 0x80000000) != 0) {
              int v56 = (uint64_t *)(v4[3] + 16 * (i & 0x7FFFFFFF) + 8);
            }
            else {
              int v56 = (uint64_t *)(v4[34] + 8 * i);
            }
            uint64_t v57 = *v56;
            if (v57
              && ((*(unsigned char *)(v57 + 3) & 1) != 0 || (uint64_t v75 = *(void *)(v57 + 24)) != 0 && (*(unsigned char *)(v75 + 3) & 1) != 0))
            {
              uint64_t v58 = *(void *)(v12 + 8);
              uint64_t v60 = *(void *)(v12 + 48);
              uint64_t v59 = *(void *)(v12 + 56);
              size_t v61 = (unsigned __int16 *)(v59
                                       + (((unint64_t)*(unsigned int *)(v58 + 24 * i + 16) >> 3) & 0x1FFFFFFE));
              int v63 = *v61;
              size_t v62 = v61 + 1;
              int v64 = v63 + (*(_DWORD *)(v58 + 24 * i + 16) & 0xF) * i;
              while (1)
              {
                uint64_t v65 = 4 * (unsigned __int16)v64;
                uint64_t v66 = *(unsigned __int16 *)(v60 + v65);
                if (*(_WORD *)(v60 + v65) && v59 != 0) {
                  break;
                }
                int v68 = (unsigned __int16)*v62++;
                v64 += v68;
                if (!v68) {
                  goto LABEL_54;
                }
              }
              unsigned int v69 = *(unsigned __int16 *)(v60 + 4 * (unsigned __int16)v64 + 2) << 16;
              uint64_t v70 = __p;
              while (1)
              {
                while (1)
                {
                  unsigned __int16 v71 = v66;
                  int v72 = (unsigned __int16 *)(v59 + 2 * *(unsigned int *)(v58 + 24 * v66 + 8));
                  do
                  {
                    if (((v52[v71 >> 6] >> v71) & 1) == 0) {
                      v70[v71 >> 5] &= ~(1 << v71);
                    }
                    int v73 = *v72++;
                    v71 += v73;
                  }
                  while (v73);
                  uint64_t v66 = HIWORD(v69);
                  if (!v66) {
                    break;
                  }
                  v69 >>= 16;
                }
                if (!*v62) {
                  break;
                }
                v64 += (unsigned __int16)*v62++;
                int v74 = (unsigned __int16 *)(v60 + 4 * (unsigned __int16)v64);
                uint64_t v66 = *v74;
                unsigned int v69 = v74[1] << 16;
              }
            }
            else if ((*(void *)(v4[35] + 8 * v55) & (1 << i)) != 0)
            {
              v53[i >> 5] &= ~(1 << i);
            }
          }
LABEL_54:
          ;
        }
      }
      if ((*(_DWORD *)(v6 + 32) & 0xFu) - 7 <= 1
        && (llvm::Function::hasAddressTaken((llvm::Function *)v6, 0, 0, 1, 0, 0) & 1) == 0)
      {
        uint64_t v76 = *(void *)(v6 + 112);
        if (v76)
        {
          if ((*(unsigned char *)(v76 + 15) & 0x40) != 0)
          {
            uint64_t v77 = *(void *)(v6 + 8);
            if (v77)
            {
              while (1)
              {
                uint64_t v78 = *(void *)(v77 + 24);
                if (*(unsigned char *)(v78 + 16) == 84 && (*(_WORD *)(v78 + 18) & 3u) - 1 < 2) {
                  break;
                }
                uint64_t v77 = *(void *)(v77 + 8);
                if (!v77) {
                  goto LABEL_88;
                }
              }
            }
            else
            {
LABEL_88:
              uint64_t v79 = *(void *)(*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
              (*(void (**)(void))(v79 + 344))();
            }
          }
        }
      }
      llvm::PhysicalRegisterUsageInfo::storeUpdateRegUsageInfo(v19, v6, __p, (v81 - (unsigned char *)__p) >> 2);
      if (v83 != v85) {
        free(v83);
      }
      if (__p)
      {
        uint64_t v81 = __p;
        operator delete(__p);
      }
    }
  }
  return 0;
}

void sub_1CC455D68(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CC455E08(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCD34D0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)(a1 + 40) = 0x600000001;
  *(_DWORD *)(a1 + 96) = 11;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x600000001;
  *(_DWORD *)(a1 + 168) = 11;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0x600000001;
  *(_DWORD *)(a1 + 240) = 11;
  *(void *)a1 = &unk_1F26128B0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34D8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC455D68;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCD34D8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC455F00()
{
}

void sub_1CC455F3C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  __n128 v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    uint64_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  char v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC455FF0(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  char v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC45609C()
{
  return "Register Usage Information Propagation";
}

void sub_1CC4560AC(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::PhysicalRegisterUsageInfo::ID);
  *(unsigned char *)(a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

BOOL sub_1CC456100(uint64_t a1, llvm::MachineFunction *a2)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  char v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::PhysicalRegisterUsageInfo::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v69 = *(void *)(*(void *)a2 + 40);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::PhysicalRegisterUsageInfo::ID);
  BOOL v8 = (llvm::PhysicalRegisterUsageInfo *)v7;
  uint64_t v9 = *((void *)a2 + 7);
  if (!*(unsigned char *)(v9 + 62) && !*(unsigned char *)(v9 + 654)) {
    return 0;
  }
  uint64_t v10 = (void *)*((void *)a2 + 41);
  uint64_t v67 = (void *)((char *)a2 + 320);
  if (v10 != (void *)((char *)a2 + 320))
  {
    uint64_t v66 = a2;
    int v73 = 0;
    int v68 = (llvm::PhysicalRegisterUsageInfo *)v7;
    while (1)
    {
      uint64_t v11 = v10 + 6;
      unsigned __int16 v71 = v10;
      int v72 = v10 + 6;
      uint64_t v12 = v10[7];
      if ((void *)v12 != v10 + 6) {
        break;
      }
LABEL_109:
      uint64_t v10 = (void *)v71[1];
      if (v10 == v67) {
        return v73 != 0;
      }
    }
    while (1)
    {
      uint64_t v13 = *(void *)(*(void *)(v12 + 16) + 8);
      if ((*(_WORD *)(v12 + 44) & 0xC) != 0 && (*(_WORD *)(v12 + 44) & 4) == 0)
      {
        uint64_t v21 = v12;
        if ((v13 & 0x80) == 0)
        {
          do
          {
            if ((*(_WORD *)(v21 + 44) & 8) == 0) {
              goto LABEL_100;
            }
            uint64_t v21 = *(void *)(v21 + 8);
          }
          while ((*(unsigned char *)(*(void *)(v21 + 16) + 8) & 0x80) == 0);
        }
      }
      else if ((v13 & 0x80) == 0)
      {
        goto LABEL_100;
      }
      uint64_t v15 = *(unsigned int *)(v12 + 40);
      if (!v15) {
        goto LABEL_100;
      }
      uint64_t v16 = *(void *)(v12 + 32);
      uint64_t v17 = v16 + 32 * v15;
      uint64_t v18 = (const char **)(v16 + 16);
      uint64_t v19 = 32 * v15;
      while (1)
      {
        int v20 = *((unsigned __int8 *)v18 - 16);
        if (v20 == 9) {
          break;
        }
        if (v20 == 10)
        {
          size_t v22 = (char *)*v18;
          if ((*v18)[16]) {
            goto LABEL_68;
          }
          goto LABEL_27;
        }
        v18 += 4;
        v19 -= 32;
        if (!v19) {
          goto LABEL_68;
        }
      }
      uint64_t v28 = *v18;
      uint64_t v74 = v17;
      if (*v18)
      {
        size_t v29 = strlen(v28);
        uint64_t v30 = *(void *)(v69 + 112);
        size_t v31 = *(unsigned int *)(v30 + 32);
        if (v31 <= 1) {
          unint64_t v32 = 1;
        }
        else {
          unint64_t v32 = v31;
        }
        if (v29 < v32) {
          unint64_t v32 = v29;
        }
        if (v29 <= v31) {
          unint64_t v32 = v29;
        }
        if ((v31 & 0x80000000) == 0) {
          size_t v33 = v32;
        }
        else {
          size_t v33 = v29;
        }
        uint64_t v76 = *(uint64_t **)(v69 + 112);
        unsigned int v34 = *(_DWORD *)(v30 + 8);
        if (!v34) {
          goto LABEL_68;
        }
        BOOL v75 = v33 == 0;
        if (v33)
        {
          uint64_t v35 = 0;
          int v36 = 0;
          do
            int v36 = 33 * v36 + v28[v35++];
          while (v33 != v35);
          goto LABEL_55;
        }
      }
      else
      {
        uint64_t v76 = *(uint64_t **)(v69 + 112);
        unsigned int v34 = *((_DWORD *)v76 + 2);
        if (!v34) {
          goto LABEL_68;
        }
        size_t v33 = 0;
      }
      int v36 = 0;
      BOOL v75 = 1;
LABEL_55:
      unsigned int v37 = v34 - 1;
      uint64_t v38 = *v76;
      uint64_t v70 = v34;
      uint64_t v39 = *v76 + 8 * v34 + 8;
      int v40 = 1;
      int v41 = v36;
      while (1)
      {
        uint64_t v42 = v41 & v37;
        uint64_t v43 = *(void **)(v38 + 8 * v42);
        if (v43 != (void *)-8)
        {
          if (!v43) {
            goto LABEL_67;
          }
          if (*(_DWORD *)(v39 + 4 * v42) == v36
            && v33 == *v43
            && (v75 || !memcmp(v28, (char *)v43 + *((unsigned int *)v76 + 5), v33)))
          {
            break;
          }
        }
        int v41 = v40 + v42;
        ++v40;
      }
      if (v42 == -1)
      {
LABEL_67:
        BOOL v8 = v68;
        uint64_t v11 = v72;
        uint64_t v17 = v74;
        goto LABEL_68;
      }
      BOOL v8 = v68;
      uint64_t v17 = v74;
      if ((int)v42 == v70 || (size_t v22 = *(char **)(*(void *)(v38 + 8 * (int)v42) + 8)) == 0)
      {
        uint64_t v11 = v72;
        goto LABEL_68;
      }
      uint64_t v11 = v72;
      if (v22[16])
      {
        while (1)
        {
LABEL_68:
          if (*(unsigned char *)v16 == 14)
          {
            uint64_t v44 = *(void *)(v16 + 16);
            uint64_t v45 = *(unsigned int *)(v44 + 8);
            if (!v45)
            {
              unsigned int v77 = 0;
LABEL_84:
              llvm::MachineFunction::allocateRegMask(v66);
              uint64_t v52 = v51;
              unsigned int v53 = *(_DWORD *)((*(uint64_t (**)(void))(**((void **)v66 + 2) + 176))(*((void *)v66 + 2))
                              + 16)
                  + 31;
              unsigned int v54 = v53 >> 5;
              memcpy(v52, *(const void **)&v78[0], 4 * (v53 >> 5));
              if (v77 >= 2)
              {
                if (v54 <= 1) {
                  uint64_t v55 = 1;
                }
                else {
                  uint64_t v55 = v54;
                }
                for (uint64_t i = 1; i != v77; ++i)
                {
                  if (v53 >= 0x20)
                  {
                    uint64_t v57 = *(int **)&v78[i];
                    uint64_t v58 = v52;
                    uint64_t v59 = v55;
                    do
                    {
                      int v60 = *v57++;
                      *v58++ &= v60;
                      --v59;
                    }
                    while (v59);
                  }
                }
              }
              uint64_t v61 = *(void *)(v12 + 32);
              uint64_t v62 = *(unsigned int *)(v12 + 40);
              if (v62)
              {
                uint64_t v63 = 32 * v62;
                uint64_t v64 = v61 + 32 * v62;
                while (*(unsigned char *)v61 != 12)
                {
                  v61 += 32;
                  v63 -= 32;
                  if (!v63)
                  {
                    uint64_t v61 = v64;
                    break;
                  }
                }
              }
              *(void *)(v61 + 16) = v52;
LABEL_99:
              if (v12) {
                goto LABEL_100;
              }
              goto LABEL_103;
            }
            uint64_t v46 = -8 * v45;
            while (*(void *)(v44 + v46))
            {
              v46 += 8;
              if (!v46)
              {
                if (v44)
                {
                  unsigned int v77 = 0;
                  uint64_t v47 = -8 * v45;
                  while (1)
                  {
                    uint64_t RegUsageInfo = llvm::PhysicalRegisterUsageInfo::getRegUsageInfo(v8, *(const llvm::Function **)(*(void *)(v44 + v47) + 128));
                    if (!v49) {
                      break;
                    }
                    if (v77 >= 4uLL) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    int v50 = (uint64_t *)&v78[v77];
                    *int v50 = RegUsageInfo;
                    v50[1] = v49;
                    ++v77;
                    v47 += 8;
                    if (!v47) {
                      goto LABEL_84;
                    }
                  }
                }
                goto LABEL_99;
              }
            }
          }
          v16 += 32;
          if (v16 == v17) {
            goto LABEL_99;
          }
        }
      }
LABEL_27:
      if (((1 << (*((_DWORD *)v22 + 8) & 0xF)) & 0x7D5) == 0) {
        goto LABEL_99;
      }
      if (llvm::GlobalValue::isInterposable((llvm::GlobalValue *)v22)) {
        goto LABEL_99;
      }
      uint64_t v23 = llvm::PhysicalRegisterUsageInfo::getRegUsageInfo(v8, (const llvm::Function *)v22);
      if (!v24) {
        goto LABEL_99;
      }
      uint64_t v25 = *(unsigned int *)(v12 + 40);
      if (v25)
      {
        uint64_t v26 = 32 * v25;
        uint64_t v27 = (uint64_t *)(*(void *)(v12 + 32) + 16);
        do
        {
          if (*((unsigned char *)v27 - 16) == 12) {
            *uint64_t v27 = v23;
          }
          v27 += 4;
          int v73 = 1;
          v26 -= 32;
        }
        while (v26);
        goto LABEL_99;
      }
      int v73 = 1;
LABEL_100:
      if ((*(unsigned char *)v12 & 4) == 0)
      {
LABEL_103:
        while ((*(_WORD *)(v12 + 44) & 8) != 0)
          uint64_t v12 = *(void *)(v12 + 8);
      }
      uint64_t v12 = *(void *)(v12 + 8);
      if ((void *)v12 == v11) {
        goto LABEL_109;
      }
    }
  }
  int v73 = 0;
  return v73 != 0;
}

void llvm::ReplaceWithVeclib::run()
{
}

uint64_t sub_1CC456804(uint64_t *a1, uint64_t a2)
{
  v162[1] = *MEMORY[0x1E4F143B8];
  int v2 = v144;
  size_t v142 = v144;
  uint64_t v143 = 0x600000000;
  uint64_t v3 = a2 + 72;
  uint64_t v4 = *(void *)(a2 + 80);
  if (v4 == a2 + 72)
  {
LABEL_6:
    LOBYTE(v8) = 0;
    return v8 & 1;
  }
  while (1)
  {
    uint64_t v6 = v4 - 24;
    if (!v4) {
      uint64_t v6 = 0;
    }
    uint64_t v7 = *(void *)(v6 + 48);
    if (v7 != v6 + 40) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == v3) {
      goto LABEL_6;
    }
  }
  int v8 = 0;
  uint64_t v9 = &v147;
  uint64_t v10 = &v161;
  uint64_t v11 = v162;
  std::string::pointer v12 = &__dst.__r_.__value_.__s.__data_[16];
  uint64_t v13 = &v160;
  unsigned int v14 = v156;
  uint64_t v15 = &v153;
  uint64_t v16 = &v150;
  while (1)
  {
    uint64_t v17 = v7 - 24;
    if (!v7) {
      uint64_t v17 = 0;
    }
    int v18 = *(unsigned __int8 *)(v17 + 16);
    if (v18 == 84) {
      uint64_t v19 = v17;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v7)
    {
      if (v18 == 84)
      {
        uint64_t v20 = *(void *)(v19 - 32);
        if (v20)
        {
          if (!*(unsigned char *)(v20 + 16) && *(void *)(v20 + 24) == *(void *)(v19 + 72))
          {
            unint64_t v23 = *(unsigned int *)(v20 + 36);
            if (v23)
            {
              int v120 = v8;
              size_t v121 = v2;
              size_t v122 = v9;
              uint64_t v24 = 0;
              uint64_t v139 = 0;
              size_t v145 = v9;
              uint64_t v146 = 0x600000000;
              int v25 = *(unsigned __int8 *)(v19 + 16);
              if (v25 != 84)
              {
                if (v25 == 39) {
                  uint64_t v24 = (*(_DWORD *)(v19 + 80) + 1);
                }
                else {
                  uint64_t v24 = 2;
                }
              }
              int v26 = *(_DWORD *)(v19 + 20);
              uint64_t v27 = v26 & 0x7FFFFFF;
              uint64_t v28 = (uint64_t **)(v19 - 32 * v27);
              if (v26 < 0)
              {
                uint64_t v102 = (uint64_t)*(v28 - 1);
                if ((v102 & 0xFFFFFFFF0) != 0) {
                  uint64_t v29 = (*((_DWORD *)v28 - 3) - *(_DWORD *)((char *)v28 - v102));
                }
                else {
                  uint64_t v29 = 0;
                }
              }
              else
              {
                uint64_t v29 = 0;
              }
              int v130 = v16;
              int v131 = v15;
              uint64_t v125 = v14;
              uint64_t v126 = v13;
              size_t v123 = (llvm::ValueAsMetadata *)v19;
              std::string::size_type v124 = (std::string::size_type)v12;
              size_t v127 = v11;
              size_t v128 = v10;
              size_t v129 = a1;
              if (v28 != (uint64_t **)(v19 - 32 * v24 - 32 * v29 - 32))
              {
                unsigned int v30 = 0;
                uint64_t v31 = 0;
                int v32 = 0;
                uint64_t v33 = 32 * v27 - 32 * v24 - 32 * v29 - 32;
                *(void *)int v132 = v23;
                while (1)
                {
                  uint64_t v34 = **v28;
                  if (llvm::hasVectorInstrinsicScalarOpd((llvm *)v23, v32))
                  {
                    if (v30 >= HIDWORD(v146)) {
                      goto LABEL_46;
                    }
                    uint64_t v35 = v31;
                  }
                  else
                  {
                    BOOL v36 = (*(_DWORD *)(v34 + 8) & 0xFE) != 0x12 || v34 == 0;
                    if (v36
                      || *(_DWORD *)(v34 + 8) == 19
                      || (uint64_t v35 = *(unsigned int *)(v34 + 32), v31) && v31 != v35)
                    {
                      BOOL v37 = 0;
                      int v2 = v121;
                      uint64_t v9 = v122;
                      a1 = v129;
                      int v8 = v120;
                      std::string::pointer v12 = (std::string::pointer)v124;
                      goto LABEL_74;
                    }
                    uint64_t v139 = *(unsigned int *)(v34 + 32);
                    uint64_t v34 = *(void *)(v34 + 24);
                    if (v30 >= HIDWORD(v146)) {
LABEL_46:
                    }
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v145 + v30) = v34;
                  unsigned int v30 = v146 + 1;
                  LODWORD(v146) = v146 + 1;
                  v28 += 4;
                  ++v32;
                  uint64_t v31 = v35;
                  v33 -= 32;
                  unint64_t v23 = *(void *)v132;
                  if (!v33) {
                    goto LABEL_49;
                  }
                }
              }
              unsigned int v30 = 0;
LABEL_49:
              memset(&__p, 0, sizeof(__p));
              if ((byte_1CFADA6F7[v23 >> 3] >> (v23 & 7)))
              {
                sub_1CC5B8334(v23, (uint64_t)v145, v30, *(uint64_t ***)(*(void *)(*((void *)v123 + 5) + 56) + 40), 0, &__dst);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                std::string __p = __dst;
                a1 = v129;
LABEL_65:
                char v44 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  p_p = &__p;
                }
                else {
                  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  size_t size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
                }
                else {
                  size_t size = __p.__r_.__value_.__l.__size_;
                }
                uint64_t v47 = *a1;
                if (!llvm::TargetLibraryInfoImpl::isFunctionVectorizable(*a1, p_p, size))
                {
                  BOOL v37 = 0;
                  int v2 = v121;
                  uint64_t v9 = v122;
                  int v8 = v120;
                  std::string::pointer v12 = (std::string::pointer)v124;
                  if ((v44 & 0x80) == 0)
                  {
LABEL_74:
                    if (v145 != v9) {
                      free(v145);
                    }
                    uint64_t v11 = v127;
                    uint64_t v10 = v128;
                    unsigned int v14 = v125;
                    uint64_t v13 = v126;
                    uint64_t v16 = v130;
                    uint64_t v15 = v131;
                    if (v37)
                    {
                      if (v143 >= (unint64_t)HIDWORD(v143)) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      *((void *)v142 + v143) = v123;
                      LODWORD(v143) = v143 + 1;
                      int v8 = 1;
                    }
                    goto LABEL_18;
                  }
LABEL_73:
                  operator delete(__p.__r_.__value_.__l.__data_);
                  goto LABEL_74;
                }
                VectorizedFunction = llvm::TargetLibraryInfoImpl::getVectorizedFunction(v47, p_p, size, (int *)&v139);
                if (v49 > 0x7FFFFFFFFFFFFFF7) {
LABEL_196:
                }
                  abort();
                int v50 = VectorizedFunction;
                size_t v51 = v49;
                if (v49 >= 0x17)
                {
                  uint64_t v53 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v49 | 7) != 0x17) {
                    uint64_t v53 = v49 | 7;
                  }
                  uint64_t v54 = v53 + 1;
                  uint64_t v52 = operator new(v53 + 1);
                  size_t v136 = v51;
                  int64_t v137 = v54 | 0x8000000000000000;
                  uint64_t v135 = v52;
                }
                else
                {
                  HIBYTE(v137) = v49;
                  uint64_t v52 = &v135;
                  if (!v49)
                  {
LABEL_87:
                    *((unsigned char *)v52 + v51) = 0;
                    char v55 = HIBYTE(v137);
                    if (v137 >= 0) {
                      size_t v56 = HIBYTE(v137) & 0x7F;
                    }
                    else {
                      size_t v56 = v136;
                    }
                    BOOL v37 = v56 != 0;
                    if (!v56)
                    {
                      int v2 = v121;
                      uint64_t v9 = v122;
                      int v8 = v120;
                      std::string::pointer v12 = (std::string::pointer)v124;
                      goto LABEL_151;
                    }
                    if (v137 >= 0) {
                      uint64_t v57 = (unsigned __int8 *)&v135;
                    }
                    else {
                      uint64_t v57 = (unsigned __int8 *)v135;
                    }
                    uint64_t v58 = *((void *)v123 - 4);
                    if (!v58 || *(unsigned char *)(v58 + 16) || *(void *)(v58 + 24) != *((void *)v123 + 9)) {
                      uint64_t v58 = 0;
                    }
                    uint64_t v116 = (const llvm::Function *)v58;
                    uint64_t v114 = *(void **)(*(void *)(*((void *)v123 + 5) + 56) + 40);
                    *(void *)uint64_t v133 = v114[14];
                    size_t v59 = *(unsigned int *)(*(void *)v133 + 32);
                    size_t v60 = v56;
                    if ((v59 & 0x80000000) == 0)
                    {
                      if (v59 <= 1) {
                        unint64_t v61 = 1;
                      }
                      else {
                        unint64_t v61 = v59;
                      }
                      if (v56 < v61) {
                        unint64_t v61 = v56;
                      }
                      if (v56 > v59) {
                        size_t v60 = v61;
                      }
                      else {
                        size_t v60 = v56;
                      }
                    }
                    std::string::size_type v115 = v56;
                    uint64_t v117 = *(unsigned int *)(*(void *)v133 + 8);
                    if (!v117) {
                      goto LABEL_121;
                    }
                    uint64_t v62 = 0;
                    int v63 = 0;
                    do
                      int v63 = 33 * v63 + v57[v62++];
                    while (v60 != v62);
                    uint64_t v64 = (v117 - 1);
                    uint64_t v65 = **(void **)v133;
                    uint64_t v66 = **(void **)v133 + 8 * v117 + 8;
                    int v67 = 1;
                    int v68 = v63;
                    BOOL v119 = v56 != 0;
                    uint64_t v118 = v66;
                    while (1)
                    {
                      uint64_t v69 = v68 & v64;
                      uint64_t v70 = *(void **)(v65 + 8 * v69);
                      if (v70 != (void *)-8)
                      {
                        if (!v70) {
                          goto LABEL_121;
                        }
                        if (*(_DWORD *)(v66 + 4 * v69) == v63 && v60 == *v70)
                        {
                          uint64_t v71 = v64;
                          int v72 = memcmp(v57, (char *)v70 + *(unsigned int *)(*(void *)v133 + 20), v60);
                          uint64_t v66 = v118;
                          uint64_t v64 = v71;
                          BOOL v37 = v119;
                          if (!v72) {
                            break;
                          }
                        }
                      }
                      int v68 = v67 + v69;
                      ++v67;
                    }
                    if (v69 == -1
                      || (int)v69 == v117
                      || (int v73 = *(unint64_t **)(*(void *)(v65 + 8 * (int)v69) + 8)) == 0
                      || *((unsigned char *)v73 + 16))
                    {
LABEL_121:
                      uint64_t v74 = (llvm::PointerType *)*((void *)v116 + 3);
                      __int16 v155 = 261;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v57;
                      __dst.__r_.__value_.__l.__size_ = v115;
                      int v73 = llvm::Function::Create(v74, 0, (const char **)&__dst.__r_.__value_.__l.__data_, (unint64_t)v114);
                      llvm::Function::copyAttributesFrom((llvm::Function *)v73, v116);
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
                      sub_1CD1CF0D0(v114, "llvm.compiler.used", (const char *)0x12, (llvm::ConstantExpr **)&__dst, 1);
                    }
                    BOOL v75 = 0;
                    uint64_t v76 = **(void **)v123;
                    __dst.__r_.__value_.__r.__words[0] = v124;
                    __dst.__r_.__value_.__l.__size_ = 0x200000000;
                    v156[2] = v76;
                    v156[3] = v128;
                    v156[4] = v127;
                    v156[5] = 0;
                    int v157 = 0;
                    __int16 v158 = 512;
                    char v159 = 7;
                    *uint64_t v125 = 0;
                    v125[1] = 0;
                    *uint64_t v126 = 0;
                    v126[1] = 0;
                    int v161 = &unk_1F2616E88;
                    v162[0] = &unk_1F2617008;
                    v156[0] = *((void *)v123 + 5);
                    v156[1] = (char *)v123 + 24;
                    unsigned int v77 = (void *)*((void *)v123 + 6);
                    uint64_t v148 = v77;
                    if (v77)
                    {
                      llvm::MetadataTracking::track((uint64_t)&v148, (unsigned __int8 *)v77, 2);
                      BOOL v75 = v148;
                    }
                    sub_1CB8461A4((uint64_t)&__dst, 0, (uint64_t)v75);
                    uint64_t v79 = v130;
                    uint64_t v78 = v131;
                    uint64_t v80 = v123;
                    *(void *)uint64_t v134 = v73;
                    if (v148)
                    {
                      int v98 = *(unsigned __int8 *)v148;
                      if ((v98 - 4) > 0x1E)
                      {
                        if ((v98 - 3) >= 0xFFFFFFFE) {
                          uint64_t v101 = v148;
                        }
                        else {
                          uint64_t v101 = 0;
                        }
                        if ((v98 - 3) < 0xFFFFFFFE)
                        {
                          uint64_t v79 = v130;
                          uint64_t v78 = v131;
                          uint64_t v80 = v123;
                          if (v98 == 3) {
                            *((void *)v148 + 1) = 0;
                          }
                          goto LABEL_125;
                        }
                        unint64_t v100 = (unint64_t)v101 + 8;
                      }
                      else
                      {
                        if ((*((unsigned char *)v148 + 1) & 0x7F) != 2 && !*((_DWORD *)v148 + 3)) {
                          goto LABEL_125;
                        }
                        uint64_t v99 = *((void *)v148 + 2);
                        if ((v99 & 4) == 0) {
                          goto LABEL_125;
                        }
                        unint64_t v100 = v99 & 0xFFFFFFFFFFFFFFF8;
                        if (!v100) {
                          goto LABEL_125;
                        }
                      }
                      unsigned int v151 = &v148;
                      sub_1CC5FA668(v100 + 16, &v151);
                      uint64_t v79 = v130;
                      uint64_t v78 = v131;
                      uint64_t v80 = v123;
                    }
LABEL_125:
                    int v81 = *((_DWORD *)v80 + 5);
                    int v82 = *((unsigned __int8 *)v80 + 16);
                    if (v82 == 84)
                    {
                      uint64_t v83 = 0;
                    }
                    else if (v82 == 39)
                    {
                      uint64_t v80 = v123;
                      uint64_t v83 = (*((_DWORD *)v123 + 20) + 1);
                      uint64_t v79 = v130;
                      uint64_t v78 = v131;
                    }
                    else
                    {
                      uint64_t v83 = 2;
                      uint64_t v79 = v130;
                      uint64_t v78 = v131;
                      uint64_t v80 = v123;
                    }
                    uint64_t v84 = v81 & 0x7FFFFFF;
                    uint64_t v85 = (void *)((char *)v80 - 32 * v84);
                    if (v81 < 0)
                    {
                      uint64_t v103 = *(v85 - 1);
                      if ((v103 & 0xFFFFFFFF0) != 0) {
                        uint64_t v86 = (*((_DWORD *)v85 - 3) - *(_DWORD *)((char *)v85 - v103));
                      }
                      else {
                        uint64_t v86 = 0;
                      }
                      uint64_t v79 = v130;
                      uint64_t v78 = v131;
                      uint64_t v80 = v123;
                    }
                    else
                    {
                      uint64_t v86 = 0;
                    }
                    uint64_t v87 = (uint64_t)v80 + -32 * v86 + -32 * v83 - 32;
                    unsigned int v151 = v78;
                    *(void *)long long v152 = 0x600000000;
                    unint64_t v88 = v87 - (void)v85;
                    if ((unint64_t)(v87 - (void)v85) >= 0xC1) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v85 != (void *)v87)
                    {
                      uint64_t v89 = v151;
                      uint64_t v90 = 32 * v84 - 32 * v83 - 32 * v86 - 32;
                      do
                      {
                        uint64_t v91 = *v85;
                        v85 += 4;
                        *v89++ = v91;
                        v90 -= 32;
                      }
                      while (v90);
                    }
                    v152[0] = v88 >> 5;
                    uint64_t v148 = v79;
                    *(void *)uint64_t v149 = 0x100000000;
                    int v92 = *((_DWORD *)v80 + 5);
                    if (v92 < 0)
                    {
                      unint64_t v104 = *((void *)v80 - 4 * (v92 & 0x7FFFFFF) - 1);
                      if ((v104 & 0xFFFFFFFF0) != 0)
                      {
                        uint64_t v105 = (v104 >> 4);
                        uint64_t v106 = v80;
                        do
                        {
                          uint64_t v107 = *((_DWORD *)v80 + 5) & 0x7FFFFFF;
                          size_t v108 = (char *)v80 - 32 * v107;
                          size_t v109 = (unsigned int *)((char *)v106 - *((void *)v108 - 1) + -32 * v107);
                          uint64_t v110 = *v109;
                          uint64_t v111 = v109[1];
                          uint64_t v112 = *((void *)v109 - 1);
                          v140[0] = &v108[32 * v110];
                          v140[1] = v111 - v110;
                          v140[2] = v112;
                          sub_1CD5C74F0((uint64_t)&v148, (uint64_t)v140);
                          uint64_t v80 = v123;
                          uint64_t v106 = (llvm::ValueAsMetadata *)((char *)v106 + 16);
                          --v105;
                        }
                        while (v105);
                      }
                    }
                    int v2 = v121;
                    uint64_t v9 = v122;
                    int v8 = v120;
                    if (*(void *)v134) {
                      int v93 = *(uint64_t ***)(*(void *)v134 + 24);
                    }
                    else {
                      int v93 = 0;
                    }
                    a1 = v129;
                    __int16 v141 = 257;
                    int v94 = (llvm::Value *)sub_1CC233B6C((uint64_t *)&__dst, v93, *(uint64_t ***)v134, (uint64_t *)v151, v152[0], (uint64_t)v148, v149[0], (uint64_t)v140, 0);
                    llvm::Value::doRAUW(v123, v94, (llvm::Value *)1);
                    if (sub_1CB845E74((uint64_t)v94)) {
                      *((unsigned char *)v94 + 17) = *((unsigned char *)v123 + 17) & 0xFE | *((unsigned char *)v94 + 17) & 1;
                    }
                    size_t v95 = (uint64_t *)v148;
                    if (v149[0])
                    {
                      uint64_t v96 = 48 * v149[0];
                      size_t v97 = (char *)v148 - 48;
                      std::string::pointer v12 = (std::string::pointer)v124;
                      do
                      {
                        sub_1CD4AF9B4((uint64_t)&v97[v96]);
                        v96 -= 48;
                      }
                      while (v96);
                      size_t v95 = (uint64_t *)v148;
                      a1 = v129;
                    }
                    else
                    {
                      std::string::pointer v12 = (std::string::pointer)v124;
                    }
                    if (v95 != v130) {
                      free(v95);
                    }
                    if (v151 != v131) {
                      free(v151);
                    }
                    if (__dst.__r_.__value_.__l.__data_ != v12) {
                      free(__dst.__r_.__value_.__l.__data_);
                    }
                    char v55 = HIBYTE(v137);
LABEL_151:
                    if (v55 < 0) {
                      operator delete(v135);
                    }
                    if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0) {
                      goto LABEL_74;
                    }
                    goto LABEL_73;
                  }
                }
                memmove(v52, v50, v51);
                goto LABEL_87;
              }
              uint64_t v38 = off_1E6830B58[v23];
              if (!v38)
              {
                memset(&__dst, 0, sizeof(__dst));
                a1 = v129;
LABEL_64:
                std::string __p = __dst;
                goto LABEL_65;
              }
              size_t v39 = strlen(off_1E6830B58[v23]);
              a1 = v129;
              if (v39 > 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_196;
              }
              std::string::size_type v40 = v39;
              if (v39 >= 0x17)
              {
                uint64_t v42 = (v39 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v39 | 7) != 0x17) {
                  uint64_t v42 = v39 | 7;
                }
                uint64_t v43 = v42 + 1;
                p_dst = (std::string *)operator new(v42 + 1);
                __dst.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
                __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                __dst.__r_.__value_.__l.__size_ = v40;
              }
              else
              {
                *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v39;
                p_dst = &__dst;
                if (!v39)
                {
LABEL_62:
                  p_dst->__r_.__value_.__s.__data_[v40] = 0;
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__p.__r_.__value_.__l.__data_);
                  }
                  goto LABEL_64;
                }
              }
              memmove(p_dst, v38, v40);
              goto LABEL_62;
            }
          }
        }
      }
    }
LABEL_18:
    uint64_t v7 = *(void *)(v7 + 8);
    uint64_t v21 = v4 - 24;
    if (!v4) {
      uint64_t v21 = 0;
    }
    if (v7 == v21 + 40) {
      break;
    }
LABEL_25:
    if (v4 == v3) {
      goto LABEL_191;
    }
  }
  while (1)
  {
    uint64_t v4 = *(void *)(v4 + 8);
    if (v4 == v3) {
      break;
    }
    uint64_t v22 = v4 - 24;
    if (!v4) {
      uint64_t v22 = 0;
    }
    uint64_t v7 = *(void *)(v22 + 48);
    if (v7 != v22 + 40) {
      goto LABEL_25;
    }
  }
LABEL_191:
  if (v143) {
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
  if (v142 != v2) {
    free(v142);
  }
  return v8 & 1;
}

void llvm::initializeReplaceWithVeclibLegacyPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EA61BED8, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC4574F0;
    v3[1] = &v1;
    int v2 = v3;
    std::__call_once(&qword_1EA61BED8, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC4574F0(uint64_t a1)
{
}

void llvm::initializeResetMachineFunctionPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EA61BEE0, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC457600;
    v3[1] = &v1;
    int v2 = v3;
    std::__call_once(&qword_1EA61BEE0, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CC457600()
{
}

void sub_1CC45769C()
{
}

void sub_1CC457744(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260E110;
  uint64_t v1 = (void *)*((void *)a1 + 22);
  if (v1 != (void *)((char *)a1 + 192))
  {
    uint64_t v4 = a1;
    free(v1);
    a1 = v4;
  }
  int v2 = (void *)*((void *)a1 + 13);
  if (v2 != (void *)((char *)a1 + 120))
  {
    uint64_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  uint64_t v3 = (void *)*((void *)a1 + 4);
  if (v3 != (void *)((char *)a1 + 48))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC4577F8(llvm::Pass *this)
{
  *(void *)this = &unk_1F260E110;
  int v2 = (char *)*((void *)this + 22);
  if (v2 != (char *)this + 192) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 13);
  if (v3 != (char *)this + 120) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4 != (char *)this + 48) {
    free(v4);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC4578A4()
{
  return "ResetMachineFunction";
}

void sub_1CC4578B4(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::StackProtector::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

unint64_t sub_1CC457904(uint64_t a1, llvm::MachineFunction *this)
{
  unint64_t v3 = **((void **)this + 45);
  if ((v3 & 0x10) != 0)
  {
    if (!*(unsigned char *)(a1 + 249))
    {
      llvm::MachineFunction::clear(this);
      llvm::MachineFunction::init(this);
    }
    llvm::report_fatal_error((llvm *)"Instruction selection failed", (const llvm::Twine *)1);
  }
  unint64_t result = (v3 >> 4) & 1;
  *(_DWORD *)(*((void *)this + 5) + 432) = 0;
  return result;
}

llvm::RegisterBank *llvm::RegisterBank::RegisterBank(llvm::RegisterBank *this, int a2, const char *a3, int a4, unsigned int *a5, int a6)
{
  char v6 = a6;
  *(_DWORD *)this = a2;
  *((void *)this + 1) = a3;
  *((_DWORD *)this + 4) = a4;
  uint64_t v9 = (char *)this + 40;
  *((void *)this + 3) = (char *)this + 40;
  uint64_t v10 = (char *)this + 24;
  *((void *)this + 4) = 0x600000000;
  *((_DWORD *)this + 22) = a6;
  unsigned int v11 = a6 + 63;
  if ((a6 + 63) < 0x40)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v12 = v11 >> 6;
    if (v11 >= 0x1C0) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    bzero(v9, 8 * v12);
    uint64_t v13 = v12;
    *((_DWORD *)this + 8) = v12;
  }
  if ((v6 & 0x3F) != 0) {
    *(void *)&v9[8 * v13 - 8] &= ~(-1 << (v6 & 0x3F));
  }
  sub_1CB9F9B60((uint64_t)v10, a5, 0xFFFFFFFF);
  return this;
}

{
  char *v8;

  *(_DWORD *)this = a2;
  *((void *)this + 1) = a3;
  *((_DWORD *)this + 4) = a4;
  *((void *)this + 3) = (char *)this + 40;
  int v8 = (char *)this + 24;
  *((void *)this + 4) = 0x600000000;
  *((_DWORD *)this + 22) = 0;
  sub_1CB8F8DF4((uint64_t)this + 24, a6, 0);
  sub_1CB9F9B60((uint64_t)v8, a5, 0xFFFFFFFF);
  return this;
}

uint64_t llvm::RegisterBank::verify()
{
  return 1;
}

uint64_t llvm::RegisterBank::covers(uint64_t a1, uint64_t a2)
{
  return (*(void *)(*(void *)(a1 + 24)
                    + (((unint64_t)*(unsigned __int16 *)(*(void *)a2 + 24) >> 3) & 0x1FF8)) >> *(_WORD *)(*(void *)a2 + 24)) & 1;
}

BOOL llvm::RegisterBank::isValid(llvm::RegisterBank *this)
{
  return *(_DWORD *)this != -1 && *((void *)this + 1) && *((_DWORD *)this + 4) && *((_DWORD *)this + 22) != 0;
}

BOOL llvm::RegisterBank::operator==(uint64_t a1, uint64_t a2)
{
  return a2 == a1;
}

uint64_t llvm::RegisterBankInfo::RegisterBankInfo(uint64_t this, llvm::RegisterBank **a2, int a3)
{
  *(void *)this = &unk_1F2612AD0;
  *(void *)(this + 8) = a2;
  *(_DWORD *)(this + 16) = a3;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 56) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(void *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(void *)(this + 96) = 0;
  *(void *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(void *)(this + 120) = 0;
  *(void *)(this + 128) = 0;
  return this;
}

{
  *(void *)this = &unk_1F2612AD0;
  *(void *)(this + 8) = a2;
  *(_DWORD *)(this + 16) = a3;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(void *)(this + 48) = 0;
  *(void *)(this + 56) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(void *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(void *)(this + 96) = 0;
  *(void *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(void *)(this + 120) = 0;
  *(void *)(this + 128) = 0;
  return this;
}

uint64_t llvm::RegisterBankInfo::verify()
{
  return 1;
}

unint64_t llvm::RegisterBankInfo::getRegBank(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a2 - 1 <= 0x3FFFFFFE)
  {
    unint64_t MinimalPhysRegClass = (unint64_t)llvm::RegisterBankInfo::getMinimalPhysRegClass(a1, a2, a4);
    uint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 24);
    uint64_t v13 = a1;
    uint64_t v14 = 0;
LABEL_15:
    return v12(v13, MinimalPhysRegClass, v14);
  }
  unint64_t v6 = a2 & 0x7FFFFFFF;
  uint64_t v7 = *(void *)(*(void *)(a3 + 24) + 16 * v6);
  unint64_t MinimalPhysRegClass = v7 & 0xFFFFFFFFFFFFFFF8;
  BOOL v9 = (v7 & 0xFFFFFFFFFFFFFFF8) == 0 || (*(void *)(*(void *)(a3 + 24) + 16 * v6) & 4) == 0;
  unint64_t result = v7 & 0xFFFFFFFFFFFFFFF8;
  if (v9)
  {
    unint64_t result = 0;
    if ((v7 & 4) == 0)
    {
      if (MinimalPhysRegClass)
      {
        uint64_t v11 = 0;
        if ((a2 & 0x80000000) != 0 && v6 < *(unsigned int *)(a3 + 432)) {
          uint64_t v11 = *(void *)(*(void *)(a3 + 424) + 8 * v6);
        }
        uint64_t v12 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 24);
        uint64_t v13 = a1;
        uint64_t v14 = v11;
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t llvm::RegisterBankInfo::constrainGenericRegister(int a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = (uint64_t *)(a3[3] + 16 * (a1 & 0x7FFFFFFF));
  uint64_t v5 = *v4;
  if ((*v4 & 4) == 0) {
    return sub_1CC38D61C(a3, a1, v5 & 0xFFFFFFFFFFFFFFF8, a2, 0);
  }
  unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFF8;
  if (v7
    && ((*(void *)(*(void *)(v7 + 24)
                   + (((unint64_t)*(unsigned __int16 *)(*(void *)a2 + 24) >> 3) & 0x1FF8)) >> *(_WORD *)(*(void *)a2 + 24)) & 1) == 0)
  {
    return 0;
  }
  *uint64_t v4 = a2;
  return v3;
}

uint64_t llvm::RegisterBankInfo::getSizeInBits(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  if (a2 - 1 <= 0x3FFFFFFE) {
    return *(unsigned int *)(*(void *)(a4 + 264)
  }
                           + 24
                           * (*(unsigned __int16 *)(*llvm::RegisterBankInfo::getMinimalPhysRegClass(a1, a2, a4) + 24)
                            + *(_DWORD *)(a4 + 272)
                            * ((*(void *)(a4 + 248) - *(void *)(a4 + 240)) >> 3)));
  return llvm::TargetRegisterInfo::getRegSizeInBits(a4, a2, a3);
}

unint64_t llvm::hash_value(llvm *this, const llvm::RegisterBankInfo::PartialMapping *a2)
{
  int v2 = *((_DWORD *)this + 1);
  uint64_t v3 = (_DWORD *)*((void *)this + 1);
  int v7 = *(_DWORD *)this;
  int v6 = v2;
  if (v3) {
    LODWORD(v3) = *v3;
  }
  int v5 = (int)v3;
  return sub_1CD5764A0(&v7, &v6, &v5);
}

uint64_t llvm::RegisterBankInfo::getOperandsMapping(uint64_t a1, void *a2, uint64_t a3)
{
  return sub_1CD5753D0(a1, a2, (uint64_t)&a2[a3]);
}

uint64_t llvm::RegisterBankInfo::PartialMapping::verify(llvm::RegisterBankInfo::PartialMapping *this)
{
  return 1;
}

BOOL llvm::RegisterBankInfo::ValueMapping::partsAllUniform(llvm::RegisterBankInfo::ValueMapping *this)
{
  uint64_t v1 = *((unsigned int *)this + 2);
  if (v1 < 2) {
    return 1;
  }
  uint64_t v3 = *(void *)this;
  uint64_t v4 = (void *)(*(void *)this + 24);
  uint64_t v5 = 16 * v1 - 16;
  do
  {
    BOOL result = v5 == 0;
    if (!v5) {
      break;
    }
    if (*((_DWORD *)v4 - 1) != *(_DWORD *)(v3 + 4)) {
      break;
    }
    uint64_t v6 = *v4;
    v4 += 2;
    v5 -= 16;
  }
  while (v6 == *(void *)(v3 + 8));
  return result;
}

uint64_t llvm::RegisterBankInfo::ValueMapping::verify(unsigned int **this)
{
  uint64_t v1 = *((unsigned int *)this + 2);
  if (v1)
  {
    unsigned int v2 = 0;
    uint64_t v3 = *this;
    uint64_t v4 = *this;
    do
    {
      unsigned int v5 = *v4;
      unsigned int v6 = v4[1];
      v4 += 4;
      unsigned int v7 = v6 + v5;
      if (v2 <= v7) {
        unsigned int v2 = v7;
      }
    }
    while (v4 != &(*this)[4 * v1]);
    if (v2 >= 0x41) {
      operator new[]();
    }
    uint64_t v8 = 0;
    uint64_t v10 = &v3[4 * v1];
    do
    {
      unsigned int v12 = *v3;
      unsigned int v11 = v3[1];
      unsigned int v15 = v2;
      uint64_t v14 = 0;
      if (v11)
      {
        unsigned int v13 = v11 + v12;
        if (v12 > 0x3F || v13 > 0x40) {
          llvm::APInt::setBitsSlowCase(&v14, v12, v13);
        }
        else {
          v14 |= 0xFFFFFFFFFFFFFFFFLL >> -(char)v11 << v12;
        }
      }
      v8 ^= v14;
      v3 += 4;
    }
    while (v3 != v10);
  }
  return 1;
}

uint64_t llvm::RegisterBankInfo::InstructionMapping::verify(llvm::RegisterBankInfo::InstructionMapping *this, const llvm::MachineInstr *a2)
{
  uint64_t v2 = *(void *)(*(void *)(*((void *)a2 + 3) + 32) + 16);
  (*(void (**)(uint64_t))(*(void *)v2 + 184))(v2);
  return 1;
}

uint64_t llvm::RegisterBankInfo::OperandsMapper::getNewVRegsEnd(llvm::RegisterBankInfo::OperandsMapper *this, int a2, int a3)
{
  unsigned int v3 = *((_DWORD *)this + 14);
  if (v3 >= a3 + a2) {
    unsigned int v3 = a3 + a2;
  }
  return *((void *)this + 6) + 4 * v3;
}

{
  unsigned int v3;

  unsigned int v3 = *((_DWORD *)this + 14);
  if (v3 >= a3 + a2) {
    unsigned int v3 = a3 + a2;
  }
  return *((void *)this + 6) + 4 * v3;
}

uint64_t llvm::RegisterBankInfo::OperandsMapper::setVRegs(llvm::RegisterBankInfo::OperandsMapper *a1, unsigned int a2, int a3, int a4)
{
  uint64_t result = llvm::RegisterBankInfo::OperandsMapper::getVRegsMem(a1, a2);
  *(_DWORD *)(*((void *)a1 + 6) + 4 * (*(_DWORD *)(*(void *)a1 + 4 * a2) + a3)) = a4;
  return result;
}

uint64_t sub_1CC458150(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  unint64_t v4 = *(unsigned int *)(result + 12);
  BOOL v5 = v3 + a2 > v4;
  BOOL v6 = v3 + a2 <= v4;
  if (!v5 && a2)
  {
    unsigned int v7 = (_DWORD *)(*(void *)result + 4 * v3);
    uint64_t v8 = a2;
    do
    {
      *v7++ = a3;
      --v8;
    }
    while (v8);
LABEL_5:
    LODWORD(v3) = *(_DWORD *)(result + 8);
    goto LABEL_6;
  }
  if (!v6) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2)
  {
    BOOL v9 = (_DWORD *)(*(void *)result + 4 * v3);
    uint64_t v10 = a2;
    do
    {
      *v9++ = a3;
      --v10;
    }
    while (v10);
    goto LABEL_5;
  }
LABEL_6:
  *(_DWORD *)(result + 8) = v3 + a2;
  return result;
}

void sub_1CC458200(uint64_t a1)
{
}

uint64_t sub_1CC4582A8(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCD34E0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2612B20;
  *(void *)(a1 + 32) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD34E8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC458200;
    v5[1] = &PassRegistry;
    unint64_t v4 = v5;
    std::__call_once(&qword_1EBCD34E8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC45835C()
{
}

void sub_1CC45839C(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC4583D4(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::TargetPassConfig::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::TargetLibraryInfoWrapperPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AssumptionCacheTracker::ID);

  sub_1CB843600(a2, a2 + 112, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

uint64_t sub_1CC45844C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(v5 + 112);
  if (v6 && (*(unsigned char *)(v6 + 18) & 2) != 0)
  {
    uint64_t v8 = v5;
    uint64_t v9 = v4;
    if (*(unsigned char *)(v5 + 16))
    {
      if (*(unsigned char *)(v5 + 16) == 3 && (*(_DWORD *)(v5 + 20) & 0x7FFFFFF) == 0) {
        return 0;
      }
    }
    else if (*(void *)(v5 + 72) == v5 + 72 && (*(unsigned char *)(v5 + 34) & 0x80) == 0)
    {
      return 0;
    }
    uint64_t v10 = *(uint64_t **)(v4 + 8);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v11 == v12)
    {
LABEL_13:
      uint64_t v13 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v11 != &llvm::TargetPassConfig::ID)
      {
        v11 += 16;
        if (v11 == v12) {
          goto LABEL_13;
        }
      }
      uint64_t v13 = *(void *)(v11 + 8);
    }
    uint64_t v14 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::TargetPassConfig::ID)+ 112);
    *(void *)(v9 + 32) = v14;
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 16))(v14, v8);
    if (!(*(uint64_t (**)(uint64_t))(*(void *)v15 + 120))(v15)) {
      llvm::report_fatal_error((llvm *)"TargetLowering instance is required", (const llvm::Twine *)1);
    }
    uint64_t v16 = *(uint64_t **)(v9 + 8);
    uint64_t v17 = *v16;
    uint64_t v18 = v16[1];
    if (v17 == v18)
    {
LABEL_19:
      uint64_t v19 = 0;
    }
    else
    {
      while (*(char **)v17 != llvm::TargetLibraryInfoWrapperPass::ID)
      {
        v17 += 16;
        if (v17 == v18) {
          goto LABEL_19;
        }
      }
      uint64_t v19 = *(void *)(v17 + 8);
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v19 + 96))(v19, llvm::TargetLibraryInfoWrapperPass::ID);
    uint64_t v40 = 0;
    size_t v39 = 0;
    int v41 = 0;
    uint64_t v43 = 0;
    uint64_t v42 = 0;
    LODWORD(v44) = 0;
    uint64_t v46 = 0;
    uint64_t v45 = 0;
    LODWORD(v47) = 0;
    uint64_t v21 = v20 + 32;
    if (!*(unsigned char *)(v20 + 232))
    {
      uint64_t v22 = *(void *)(v8 + 40) + 216;
      __int16 v49 = 260;
      v48[0] = v22;
      llvm::Triple::Triple((llvm::Triple *)v24, (const llvm::Twine *)v48);
      uint64_t v34 = 0;
      uint64_t v33 = 0;
      int v35 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      *(void *)&long long v23 = -1;
      *((void *)&v23 + 1) = -1;
      long long v26 = v23;
      long long v27 = v23;
      long long v28 = v23;
      long long v29 = v23;
      long long v30 = v23;
      long long v31 = v23;
      *(_OWORD *)int v32 = v23;
      *(void *)&v32[13] = -1;
      sub_1CC153974((uint64_t)&v26, (int *)v24);
      sub_1CD4D04B8(v21, (uint64_t)&v26);
      sub_1CD4CFA4C((uint64_t *)&v26);
      if (v25 < 0) {
        operator delete(v24[0]);
      }
    }
    sub_1CC1569E8(&v26, v21);
  }
  return 0;
}

uint64_t sub_1CC45DAF8(llvm::DataLayout *a1, llvm::AllocaInst *a2)
{
  uint64_t v4 = (llvm::Type *)*((void *)a2 + 8);
  unint64_t v5 = (unint64_t)(sub_1CB83544C((uint64_t)a1, (uint64_t)v4) + 7) >> 3;
  BOOL v7 = v6 == 1;
  char Alignment = llvm::DataLayout::getAlignment(a1, v4, 1);
  uint64_t v10 = ((1 << Alignment) + v5 - 1) & -(1 << Alignment);
  if (v7) {
  int isArrayAllocation = llvm::AllocaInst::isArrayAllocation(a2);
  }
  uint64_t result = v10;
  if (isArrayAllocation)
  {
    uint64_t result = 0;
    uint64_t v13 = *((void *)a2 - 4);
    if (v13)
    {
      if (*(unsigned char *)(v13 + 16) == 16)
      {
        uint64_t v14 = (void *)(v13 + 24);
        if (*(_DWORD *)(v13 + 32) >= 0x41u) {
          uint64_t v14 = (void *)*v14;
        }
        return *v14 * v10;
      }
    }
  }
  return result;
}

uint64_t sub_1CC45DBCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v70[8] = *MEMORY[0x1E4F143B8];
  unint64_t v61 = v65;
  uint64_t v62 = v65;
  uint64_t v63 = 16;
  int v64 = 0;
  int v67 = v70;
  unsigned int v69 = 8;
  v70[0] = a2;
  unsigned int v6 = 1;
  while (1)
  {
    BOOL v7 = (uint64_t *)*((void *)v67 + --v6);
    unsigned int v68 = v6;
    uint64_t v8 = (unint64_t *)v7[1];
    if (v8) {
      break;
    }
LABEL_109:
    if (!v6)
    {
      uint64_t v59 = 1;
      goto LABEL_112;
    }
  }
  while (1)
  {
    uint64_t v9 = v8[3];
    unsigned int v10 = *(unsigned __int8 *)(v9 + 16);
    if (v10 <= 0x3C) {
      break;
    }
    if (v10 == 61)
    {
      int v22 = *(_DWORD *)(v9 + 20);
      if ((v22 & 0x40000000) != 0) {
        long long v23 = *(uint64_t ***)(v9 - 8);
      }
      else {
        long long v23 = (uint64_t **)(v9 - 32 * (v22 & 0x7FFFFFF));
      }
      long long v30 = *v23;
      if (v7 == v30) {
        goto LABEL_111;
      }
      unint64_t v31 = *v8;
      uint64_t v33 = sub_1CB83544C(*(void *)(a1 + 16), *v30);
      if (v32 == 1) {
      unint64_t v14 = (unint64_t)(v33 + 7) >> 3;
      }
      uint64_t v15 = a1;
      unint64_t v16 = v31;
      goto LABEL_94;
    }
    if (v10 == 84) {
      goto LABEL_13;
    }
    if (v10 != 88) {
      goto LABEL_25;
    }
LABEL_95:
    uint64_t v8 = (unint64_t *)v8[1];
    if (!v8)
    {
      unsigned int v6 = v68;
      goto LABEL_109;
    }
  }
  if (v10 != 33)
  {
    if (v10 == 60)
    {
      unint64_t v11 = *v8;
      uint64_t v13 = sub_1CB83544C(*(void *)(a1 + 16), *(void *)v9);
      if (v12 == 1) {
      unint64_t v14 = (unint64_t)(v13 + 7) >> 3;
      }
      uint64_t v15 = a1;
      unint64_t v16 = v11;
LABEL_94:
      if (!sub_1CC45E168(v15, v16, v14, a2, a3)) {
        goto LABEL_111;
      }
      goto LABEL_95;
    }
    if (v10 == 29) {
      goto LABEL_111;
    }
LABEL_25:
    uint64_t v24 = v62;
    uint64_t v25 = HIDWORD(v63);
    if (v62 == v61)
    {
      if (HIDWORD(v63))
      {
        long long v26 = 0;
        uint64_t v27 = 8 * HIDWORD(v63);
        long long v28 = (uint64_t *)v62;
        while (*v28 != v9)
        {
          if (*v28 == -2) {
            long long v26 = v28;
          }
          ++v28;
          v27 -= 8;
          if (!v27)
          {
            if (!v26) {
              goto LABEL_33;
            }
            *long long v26 = v9;
            --v64;
            goto LABEL_82;
          }
        }
        goto LABEL_95;
      }
LABEL_33:
      unsigned int v29 = v63;
      if (HIDWORD(v63) < v63)
      {
        ++HIDWORD(v63);
        *(void *)&v62[8 * v25] = v9;
LABEL_82:
        if (v68 >= (unint64_t)v69) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v67 + v68++) = v9;
        goto LABEL_95;
      }
    }
    else
    {
      unsigned int v29 = v63;
    }
    if (3 * v29 <= 4 * (HIDWORD(v63) - v64))
    {
      if (v29 >= 0x40) {
        v29 *= 2;
      }
      else {
        unsigned int v29 = 128;
      }
    }
    else if (v29 - HIDWORD(v63) >= v29 >> 3)
    {
LABEL_63:
      unsigned int v45 = v29 - 1;
      unsigned int v46 = (v29 - 1) & ((v9 >> 4) ^ (v9 >> 9));
      uint64_t v47 = &v24[8 * v46];
      uint64_t v48 = *(void *)v47;
      if (*(void *)v47 != -1)
      {
        __int16 v49 = 0;
        int v50 = 1;
        while (v48 != v9)
        {
          if (v49) {
            BOOL v51 = 0;
          }
          else {
            BOOL v51 = v48 == -2;
          }
          if (v51) {
            __int16 v49 = (uint64_t *)v47;
          }
          unsigned int v52 = v46 + v50++;
          unsigned int v46 = v52 & v45;
          uint64_t v47 = &v24[8 * (v52 & v45)];
          uint64_t v48 = *(void *)v47;
          if (*(void *)v47 == -1) {
            goto LABEL_75;
          }
        }
        goto LABEL_95;
      }
      __int16 v49 = 0;
LABEL_75:
      if (v49) {
        uint64_t v53 = v49;
      }
      else {
        uint64_t v53 = (uint64_t *)v47;
      }
      if (*v53 == v9) {
        goto LABEL_95;
      }
      if (*v53 == -2) {
        --v64;
      }
      else {
        ++HIDWORD(v63);
      }
      *uint64_t v53 = v9;
      goto LABEL_82;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v61, v29);
    unsigned int v29 = v63;
    uint64_t v24 = v62;
    goto LABEL_63;
  }
LABEL_13:
  if (llvm::Instruction::isLifetimeStartOrEnd((llvm::Instruction *)v8[3])) {
    goto LABEL_95;
  }
  if (sub_1CBFB3AB0(v9))
  {
    unsigned int v17 = *(_DWORD *)(*(void *)(v9 - 32) + 36) - 194;
    if (v17 > 3 || v17 == 1)
    {
      uint64_t v54 = *(_DWORD *)(v9 + 20) & 0x7FFFFFF;
      unint64_t v16 = *(void *)(v9 - 32 * v54);
      if (v16 != *v8) {
        goto LABEL_95;
      }
      uint64_t v20 = -v54;
    }
    else
    {
      uint64_t v19 = *(_DWORD *)(v9 + 20) & 0x7FFFFFF;
      uint64_t v20 = -v19;
      uint64_t v21 = (void *)(v9 - 32 * v19);
      unint64_t v16 = v21[4];
      if (v16 != *v8)
      {
        if (*v21 != *v8) {
          goto LABEL_95;
        }
        unint64_t v16 = *v8;
      }
    }
    uint64_t v55 = *(void *)(v9 + 32 * v20 + 64);
    if (v55) {
      BOOL v56 = *(unsigned char *)(v55 + 16) == 16;
    }
    else {
      BOOL v56 = 0;
    }
    if (!v56) {
      goto LABEL_111;
    }
    uint64_t v57 = (unint64_t *)(v55 + 24);
    if (*(_DWORD *)(v55 + 32) >= 0x41u) {
      uint64_t v57 = (unint64_t *)*v57;
    }
    unint64_t v14 = *v57;
    uint64_t v15 = a1;
    goto LABEL_94;
  }
  int v34 = *(unsigned __int8 *)(v9 + 16);
  if (v34 == 84)
  {
    uint64_t v35 = 0;
  }
  else if (v34 == 39)
  {
    uint64_t v35 = (*(_DWORD *)(v9 + 80) + 1);
  }
  else
  {
    uint64_t v35 = 2;
  }
  int v36 = *(_DWORD *)(v9 + 20);
  uint64_t v37 = v36 & 0x7FFFFFF;
  uint64_t v38 = v9 - 32 * v37;
  if (v36 < 0 && (uint64_t v58 = *(void *)(v38 - 8), (v58 & 0xFFFFFFFF0) != 0)) {
    uint64_t v39 = (*(_DWORD *)(v38 - 12) - *(_DWORD *)(v38 - v58));
  }
  else {
    uint64_t v39 = 0;
  }
  if (v38 == v9 - 32 * v35 - 32 * v39 - 32) {
    goto LABEL_95;
  }
  int v40 = 0;
  unint64_t v41 = (32 * v35 + 32 * v39) ^ 0xFFFFFFFFFFFFFFE0;
  uint64_t v42 = -32 * v37;
  while (1)
  {
    if (*(uint64_t **)(v9 + v42) == v7)
    {
      if (!sub_1CBF5BC2C(v9, v40, 22)) {
        break;
      }
      if ((sub_1CBF5BC2C(v9, v40, 44) & 1) == 0)
      {
        uint64_t v43 = *(void *)(v9 + 64);
        if (!v43 || (*(unsigned char *)(v43 + 17) & 0x10) == 0)
        {
          __int32 v66 = 7;
          if (sub_1CC5CB59C(v9, &v66, 1uLL))
          {
            uint64_t v44 = *(void *)(v9 - 32);
            if (!v44
              || *(unsigned char *)(v44 + 16)
              || *(void *)(v44 + 24) != *(void *)(v9 + 72)
              || *(_DWORD *)(v44 + 36) != 7)
            {
              break;
            }
          }
          if (!llvm::CallBase::hasFnAttrOnCalledFunction(v9, 44)) {
            break;
          }
        }
      }
    }
    v42 += 32;
    ++v40;
    if (v41 == v42) {
      goto LABEL_95;
    }
  }
LABEL_111:
  uint64_t v59 = 0;
LABEL_112:
  if (v67 != v70) {
    free(v67);
  }
  if (v62 != v61) {
    free(v62);
  }
  return v59;
}

BOOL sub_1CC45E168(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 104);
  unsigned int v11 = *(_DWORD *)(v9 + 120);
  if (!v11)
  {
LABEL_7:
    uint64_t v14 = v10 + 48 * v11;
    goto LABEL_8;
  }
  unsigned int v12 = v11 - 1;
  unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v14 = v10 + 48 * v13;
  uint64_t v15 = *(void *)(v14 + 24);
  if (v15 != a2)
  {
    int v16 = 1;
    while (v15 != -4096)
    {
      unsigned int v17 = v13 + v16++;
      unsigned int v13 = v17 & v12;
      uint64_t v14 = v10 + 48 * (v17 & v12);
      uint64_t v15 = *(void *)(v14 + 24);
      if (v15 == a2) {
        goto LABEL_8;
      }
    }
    goto LABEL_7;
  }
LABEL_8:
  if (v14 == v10 + 48 * v11 || (SCEVIter = *(const llvm::SCEV **)(v14 + 40)) == 0)
  {
    SCEVIter = (const llvm::SCEV *)llvm::ScalarEvolution::createSCEVIter((llvm::ScalarEvolution *)v9, a2);
    uint64_t v9 = *(void *)(a1 + 32);
  }
  PointerBase = llvm::ScalarEvolution::getPointerBase((llvm::ScalarEvolution *)v9, SCEVIter);
  if (PointerBase) {
    BOOL v21 = *((unsigned __int16 *)PointerBase + 12) == 14;
  }
  else {
    BOOL v21 = 0;
  }
  if (!v21 || *((void *)PointerBase - 1) != a4) {
    return 0;
  }
  uint64_t v24 = llvm::ScalarEvolution::removePointerBase(*(llvm::ScalarEvolution **)(a1 + 32), SCEVIter, v20);
  uint64_t v25 = v24;
  while (2)
  {
    switch(*(_WORD *)(v25 + 24))
    {
      case 1:
      case 2:
      case 3:
      case 0xD:
        uint64_t v27 = (uint64_t *)(v25 + 40);
        goto LABEL_27;
      case 4:
        uint64_t v27 = (uint64_t *)(v25 + 48);
        goto LABEL_27;
      case 5:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xC:
        long long v26 = *(uint64_t **)(v25 + 32);
        goto LABEL_22;
      case 6:
        long long v26 = (uint64_t *)(v25 + 40);
LABEL_22:
        uint64_t v25 = *v26;
        continue;
      case 0xE:
        uint64_t v27 = *(uint64_t **)(v25 - 8);
        goto LABEL_27;
      default:
        uint64_t v27 = *(uint64_t **)(v25 + 32);
LABEL_27:
        uint64_t v28 = *v27;
        unsigned int v29 = *(_DWORD *)(*v27 + 8);
        uint64_t v30 = *(void *)(**(void **)(a1 + 32) + 40);
        if (v29 == 15)
        {
          if ((v29 & 0xFE) == 0x12) {
            unsigned int v29 = *(_DWORD *)(**(void **)(v28 + 16) + 8);
          }
          uint64_t v36 = *(void *)(v30 + 504);
          if (v29 < 0x100) {
            goto LABEL_57;
          }
          unsigned int v37 = v29 >> 8;
          unint64_t v38 = *(unsigned int *)(v30 + 512);
          uint64_t v39 = *(void *)(v30 + 504);
          if (v38)
          {
            uint64_t v39 = v36;
            unint64_t v40 = v38;
            do
            {
              unint64_t v41 = v40 >> 1;
              uint64_t v42 = v39 + 16 * (v40 >> 1);
              unsigned int v43 = *(_DWORD *)(v42 + 8);
              uint64_t v44 = v42 + 16;
              v40 += ~(v40 >> 1);
              if (v43 < v37) {
                uint64_t v39 = v44;
              }
              else {
                unint64_t v40 = v41;
              }
            }
            while (v40);
          }
          if (v39 == v36 + 16 * v38 || *(_DWORD *)(v39 + 8) != v37) {
LABEL_57:
          }
            uint64_t v39 = v36;
          unsigned int v32 = *(_DWORD *)(v39 + 12);
        }
        else
        {
          unsigned int v32 = sub_1CB83544C(v30 + 272, v28);
          if (v31 == 1) {
        }
          }
        uint64_t RangeRef = llvm::ScalarEvolution::getRangeRef(*(void *)(a1 + 32), v24, 0, 0);
        unsigned int v58 = *(_DWORD *)(RangeRef + 8);
        if (v58 > 0x40) {
          operator new[]();
        }
        uint64_t v57 = *(void *)RangeRef;
        unsigned int v60 = *(_DWORD *)(RangeRef + 24);
        if (v60 > 0x40) {
          operator new[]();
        }
        uint64_t v59 = *(void *)(RangeRef + 16);
        if (v32 > 0x40) {
          operator new[]();
        }
        if (v32) {
          unint64_t v34 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v32;
        }
        else {
          unint64_t v34 = 0;
        }
        unsigned int v54 = v32;
        uint64_t v53 = 0;
        unsigned int v56 = v32;
        unint64_t v55 = v34 & a3;
        llvm::ConstantRange::add((uint64_t)&v57, (const llvm::ConstantRange *)&v53, (uint64_t)&v49);
        if (v32) {
          unint64_t v35 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v32;
        }
        else {
          unint64_t v35 = 0;
        }
        unsigned int v46 = v32;
        uint64_t v45 = 0;
        unsigned int v48 = v32;
        unint64_t v47 = v35 & a5;
        BOOL v22 = llvm::ConstantRange::contains((llvm::ConstantRange *)&v45, (const llvm::ConstantRange *)&v49);
        if (v52 >= 0x41 && v51) {
          MEMORY[0x1D25D9CB0](v51, 0x1000C8000313F17);
        }
        if (v50 >= 0x41 && v49) {
          MEMORY[0x1D25D9CB0](v49, 0x1000C8000313F17);
        }
        if (v56 >= 0x41 && v55) {
          MEMORY[0x1D25D9CB0](v55, 0x1000C8000313F17);
        }
        if (v54 >= 0x41 && v53) {
          MEMORY[0x1D25D9CB0](v53, 0x1000C8000313F17);
        }
        if (v60 >= 0x41 && v59) {
          MEMORY[0x1D25D9CB0](v59, 0x1000C8000313F17);
        }
        if (v58 >= 0x41 && v57) {
          MEMORY[0x1D25D9CB0](v57, 0x1000C8000313F17);
        }
        break;
    }
    return v22;
  }
}

uint64_t sub_1CC45E7A4(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(result + 20);
  uint64_t v4 = v3 & 0x7FFFFFF;
  if ((v3 & 0x7FFFFFF) != 0)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    BOOL v7 = (uint64_t *)(a3 + 8);
    uint64_t v8 = 8 * v4;
    do
    {
      int v9 = *(_DWORD *)(result + 20);
      if ((v9 & 0x40000000) != 0) {
        uint64_t v10 = *(void *)(result - 8);
      }
      else {
        uint64_t v10 = result - 32 * (v9 & 0x7FFFFFF);
      }
      if (*(void *)(v10 + 32 * *(unsigned int *)(result + 60) + v6) == a2)
      {
        uint64_t v11 = v10 + v5;
        if (*(void *)(v10 + v5))
        {
          **(void **)(v11 + 16) = *(void *)(v11 + 8);
          uint64_t v14 = *(void *)(v11 + 8);
          if (v14) {
            *(void *)(v14 + 16) = *(void *)(v11 + 16);
          }
        }
        *(void *)uint64_t v11 = a3;
        if (a3)
        {
          uint64_t v12 = *v7;
          uint64_t v13 = v10 + v5;
          *(void *)(v13 + 8) = *v7;
          if (v12) {
            *(void *)(v12 + 16) = v13 + 8;
          }
          *(void *)(v13 + 16) = v7;
          *BOOL v7 = v11;
        }
      }
      v6 += 8;
      v5 += 32;
    }
    while (v8 != v6);
  }
  return result;
}

uint64_t sub_1CC45E850(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

char **sub_1CC45E8E8(char **a1)
{
  uint64_t v2 = *a1;
  int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v5 = &v2[24 * v3];
    do
    {
      uint64_t v6 = *((void *)v5 - 1);
      if (v6 != -8192 && v6 != -4096 && v6 != 0)
      {
        unint64_t v8 = *((void *)v5 - 3) & 0xFFFFFFFFFFFFFFF8;
        *(void *)unint64_t v8 = *((void *)v5 - 2);
        int v9 = (unint64_t *)*((void *)v5 - 2);
        if (v9)
        {
          *int v9 = *v9 & 7 | v8;
        }
        else
        {
          uint64_t v10 = *((void *)v5 - 1);
          uint64_t v11 = ***(int32x2_t ****)v10;
          unint64_t v12 = (unint64_t)v11[303];
          if (v12 <= v8)
          {
            uint64_t v13 = v11[305].u32[0];
            if (v12 + 16 * v13 > v8)
            {
              unsigned int v14 = v13 - 1;
              LODWORD(v15) = v14 & ((v10 >> 4) ^ (v10 >> 9));
              int v16 = (uint64_t *)(v12 + 16 * v15);
              uint64_t v17 = *v16;
              if (v10 == *v16)
              {
LABEL_24:
                uint64_t *v16 = -8192;
                v11[304] = vadd_s32(v11[304], (int32x2_t)0x1FFFFFFFFLL);
                uint64_t v10 = *((void *)v5 - 1);
              }
              else
              {
                int v18 = 1;
                while (v17 != -4096)
                {
                  int v19 = v15 + v18++;
                  uint64_t v15 = v19 & v14;
                  uint64_t v17 = *(void *)(v12 + 16 * v15);
                  if (v10 == v17)
                  {
                    int v16 = (uint64_t *)(v12 + 16 * v15);
                    goto LABEL_24;
                  }
                }
              }
              *(unsigned char *)(v10 + 17) &= ~1u;
            }
          }
        }
      }
      v5 -= 24;
    }
    while (v5 != v2);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CC45EA38()
{
  LOBYTE(v3) = 0;
  v4.n128_u64[0] = (unint64_t)&v3;
  LODWORD(v2) = 1;
  sub_1CD578674((char **)&v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCD3540, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"enable safe stack coloring";
  v4.n128_u64[1] = 26;
  int v3 = 1;
  char v1 = 1;
  uint64_t v2 = &v1;
  sub_1CD4BCE90((llvm::cl::Option *)&unk_1EBCD3600, "safe-stack-coloring", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3600, &dword_1CB82C000);
}

void *llvm::safestack::StackLayout::layoutObject(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)a2;
  uint64_t v3 = a1;
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  if (!byte_1EBCD3740)
  {
    uint64_t v33 = (uint64_t *)(a1 + 8);
    unsigned int v34 = *(_DWORD *)(v3 + 16);
    if (v34) {
      unsigned int v34 = *(_DWORD *)(*v33 + 80 * v34 - 76);
    }
    int v35 = *(_DWORD *)(a2 + 8);
    unsigned int v36 = (v35 + v34 + (1 << *(unsigned char *)(a2 + 12)) - 1) & -(1 << *(unsigned char *)(a2 + 12));
    unsigned int v83 = v36;
    LODWORD(v84) = v36 - v35;
    sub_1CD578BF8(v33, &v84, (int *)&v83, a2 + 16);
    int v37 = *(_DWORD *)(v3 + 2040);
    if (v37)
    {
      uint64_t v38 = *(void *)(v3 + 2024);
      int v39 = v37 - 1;
      unsigned int v40 = ((*v2 >> 4) ^ (*v2 >> 9)) & v39;
      uint64_t result = (void *)(v38 + 16 * v40);
      uint64_t v42 = *result;
      if (*v2 == *result)
      {
LABEL_72:
        *((_DWORD *)result + 2) = v36;
        return result;
      }
      unsigned int v43 = 0;
      int v44 = 1;
      while (v42 != -4096)
      {
        if (v43) {
          BOOL v45 = 0;
        }
        else {
          BOOL v45 = v42 == -8192;
        }
        if (v45) {
          unsigned int v43 = result;
        }
        unsigned int v46 = v40 + v44++;
        unsigned int v40 = v46 & v39;
        uint64_t result = (void *)(v38 + 16 * v40);
        uint64_t v42 = *result;
        if (*v2 == *result) {
          goto LABEL_72;
        }
      }
      if (v43) {
        uint64_t v51 = v43;
      }
      else {
        uint64_t v51 = result;
      }
    }
    else
    {
      uint64_t v51 = 0;
    }
    uint64_t result = sub_1CC21DC7C(v3 + 2024, (uint64_t)v2, v2, v51);
    *uint64_t result = *v2;
    *((_DWORD *)result + 2) = 0;
    goto LABEL_72;
  }
  int v4 = *(_DWORD *)(a2 + 8);
  uint64_t v5 = 1 << *(unsigned char *)(a2 + 12);
  int v6 = v5 - 1;
  uint64_t v7 = -v5;
  unsigned int v8 = (v5 - 1 + v4) & -(int)v5;
  unsigned int v9 = v8 - v4;
  unsigned int v82 = v8;
  unsigned int v83 = v8 - v4;
  uint64_t v11 = (uint64_t *)(a1 + 8);
  uint64_t v10 = *(void *)(a1 + 8);
  unint64_t v12 = *(unsigned int *)(a1 + 16);
  if (v12)
  {
    uint64_t v13 = v10 + 80 * v12;
    unsigned int v14 = *(_DWORD *)(a2 + 24);
    do
    {
      unsigned int v15 = *(_DWORD *)(v10 + 4);
      if (v9 < v15)
      {
        LODWORD(v16) = *(_DWORD *)(v10 + 16);
        if (v16 >= v14) {
          uint64_t v16 = v14;
        }
        else {
          uint64_t v16 = v16;
        }
        if (v16)
        {
          uint64_t v17 = *(uint64_t **)(v10 + 8);
          int v18 = (uint64_t *)v2[2];
          while (1)
          {
            uint64_t v20 = *v18++;
            uint64_t v19 = v20;
            uint64_t v21 = *v17++;
            if ((v21 & v19) != 0) {
              break;
            }
            if (!--v16) {
              goto LABEL_12;
            }
          }
          unsigned int v8 = (v6 + v15 + v4) & v7;
          unsigned int v9 = v8 - v4;
        }
        else
        {
LABEL_12:
          if (v8 <= v15) {
            break;
          }
        }
      }
      v10 += 80;
    }
    while (v10 != v13);
    unsigned int v82 = v8;
    unsigned int v83 = v9;
    unsigned int v22 = *(_DWORD *)(v13 - 76);
  }
  else
  {
    unsigned int v22 = 0;
  }
  unsigned int v81 = v22;
  uint64_t v80 = v3;
  if (v8 > v22)
  {
    if (v9 > v22)
    {
      uint64_t v84 = &v86;
      std::string __dst = (void *)0x600000000;
      v87[10] = 0;
      sub_1CD578BF8(v11, &v81, (int *)&v83, (uint64_t)&v84);
      if (v84 != &v86) {
        free(v84);
      }
      unsigned int v81 = v9;
    }
    sub_1CD578BF8(v11, &v81, (int *)&v82, (uint64_t)(v2 + 2));
    unsigned int v81 = v8;
    unint64_t v12 = *(unsigned int *)(v3 + 16);
    if (!*(_DWORD *)(v3 + 16)) {
      goto LABEL_104;
    }
  }
  else if (!v12)
  {
    goto LABEL_104;
  }
  uint64_t v79 = v2;
  uint64_t v23 = 0;
  unint64_t v24 = 0;
  while (1)
  {
    uint64_t v25 = *v11;
    uint64_t v26 = *v11 + v23;
    unsigned int v27 = *(_DWORD *)(v26 + 4);
    if (v9 > *(_DWORD *)v26 && v9 < v27)
    {
      uint64_t v84 = *(void **)v26;
      std::string __dst = v87;
      uint64_t v86 = 0x600000000;
      unsigned int v30 = *(_DWORD *)(v26 + 16);
      unint64_t v31 = (void **)(v26 + 8);
      if (v30) {
        BOOL v32 = v31 == &__dst;
      }
      else {
        BOOL v32 = 1;
      }
      if (!v32)
      {
        if (v30 >= 7) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        memcpy(v87, *v31, 8 * *(unsigned int *)(v26 + 16));
        LODWORD(v86) = v30;
      }
      unsigned int v88 = *(_DWORD *)(v25 + v23 + 72);
      HIDWORD(v84) = v9;
      *(_DWORD *)(v25 + v23) = v9;
      sub_1CD57912C((uint64_t)v11, v26, (unint64_t)&v84);
      if (__dst != v87) {
        free(__dst);
      }
      uint64_t v3 = v80;
      unint64_t v12 = *(unsigned int *)(v80 + 16);
      goto LABEL_31;
    }
    if (v8 > *(_DWORD *)v26 && v8 < v27) {
      break;
    }
LABEL_31:
    ++v24;
    v23 += 80;
    if (v24 >= v12) {
      goto LABEL_77;
    }
  }
  unint64_t v47 = (unsigned int *)(v25 + v23);
  uint64_t v84 = *(void **)(v25 + v23);
  std::string __dst = v87;
  uint64_t v86 = 0x600000000;
  unsigned int v48 = *(_DWORD *)(v25 + v23 + 16);
  uint64_t v49 = (void **)(v25 + v23 + 8);
  if (v48) {
    BOOL v50 = v49 == &__dst;
  }
  else {
    BOOL v50 = 1;
  }
  if (!v50)
  {
    if (v48 >= 7) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    memcpy(v87, *v49, 8 * *(unsigned int *)(v25 + v23 + 16));
    LODWORD(v86) = v48;
  }
  unsigned int v88 = v47[18];
  unsigned int *v47 = v8;
  HIDWORD(v84) = v8;
  sub_1CD57912C((uint64_t)v11, v25 + v23, (unint64_t)&v84);
  if (__dst != v87) {
    free(__dst);
  }
  unint64_t v12 = *(unsigned int *)(v3 + 16);
LABEL_77:
  if (v12)
  {
    uint64_t v52 = *v11;
    uint64_t v53 = *v11 + 80 * v12;
    uint64_t v2 = v79;
    do
    {
      if (v83 < *(_DWORD *)(v52 + 4) && v8 > *(_DWORD *)v52)
      {
        unsigned int v54 = (void *)(v52 + 8);
        unsigned int v55 = *((_DWORD *)v79 + 20);
        if (*(_DWORD *)(v52 + 72) < v55)
        {
          int v62 = *(_DWORD *)(v52 + 72) & 0x3F;
          uint64_t v63 = *(unsigned int *)(v52 + 16);
          if (v62)
          {
            uint64_t v68 = *(void *)(v52 + 8) + 8 * v63;
            *(void *)(v68 - 8) &= ~(-1 << v62);
          }
          unsigned int v64 = v63;
          *(_DWORD *)(v52 + 72) = v55;
          unsigned int v65 = v55 + 63;
          if (v63 != (v55 + 63) >> 6)
          {
            uint64_t v66 = v65 >> 6;
            if (v63 > v66)
            {
              *(_DWORD *)(v52 + 16) = v66;
              unsigned int v64 = v65 >> 6;
            }
            else
            {
              if (v66 > *(_DWORD *)(v52 + 20)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v66 != v63) {
                bzero((void *)(*v54 + 8 * v63), 8 * (v66 - v63));
              }
              unsigned int v64 = v66;
              *(_DWORD *)(v52 + 16) = v66;
              unsigned int v55 = *(_DWORD *)(v52 + 72);
            }
          }
          int v67 = v55 & 0x3F;
          if (v67) {
            *(void *)(*v54 + 8 * v64 - 8) &= ~(-1 << v67);
          }
        }
        uint64_t v56 = *((unsigned int *)v79 + 6);
        if (v56)
        {
          uint64_t v57 = (uint64_t *)v79[2];
          unsigned int v58 = (void *)*v54;
          do
          {
            uint64_t v59 = *v57++;
            *v58++ |= v59;
            --v56;
          }
          while (v56);
        }
      }
      unsigned int v8 = v82;
      unsigned int v60 = *(_DWORD *)(v52 + 4);
      v52 += 80;
    }
    while (v82 > v60 && v52 != v53);
  }
  else
  {
    uint64_t v2 = v79;
  }
LABEL_104:
  int v69 = *(_DWORD *)(v3 + 2040);
  if (!v69)
  {
    uint64_t v78 = 0;
    goto LABEL_118;
  }
  uint64_t v70 = *(void *)(v3 + 2024);
  int v71 = v69 - 1;
  unsigned int v72 = ((*v2 >> 4) ^ (*v2 >> 9)) & v71;
  uint64_t result = (void *)(v70 + 16 * v72);
  uint64_t v73 = *result;
  if (*v2 != *result)
  {
    uint64_t v74 = 0;
    int v75 = 1;
    while (v73 != -4096)
    {
      if (v74) {
        BOOL v76 = 0;
      }
      else {
        BOOL v76 = v73 == -8192;
      }
      if (v76) {
        uint64_t v74 = result;
      }
      unsigned int v77 = v72 + v75++;
      unsigned int v72 = v77 & v71;
      uint64_t result = (void *)(v70 + 16 * v72);
      uint64_t v73 = *result;
      if (*v2 == *result) {
        goto LABEL_119;
      }
    }
    if (v74) {
      uint64_t v78 = v74;
    }
    else {
      uint64_t v78 = result;
    }
LABEL_118:
    uint64_t result = sub_1CC21DC7C(v3 + 2024, (uint64_t)v2, v2, v78);
    *uint64_t result = *v2;
    *((_DWORD *)result + 2) = 0;
  }
LABEL_119:
  *((_DWORD *)result + 2) = v8;
  return result;
}

uint64_t sub_1CC45F194(void *a1, unsigned int a2, int a3, unsigned int a4)
{
  if (a2 == a3) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = a2 >> 6;
  unsigned int v5 = a3 - 1;
  if (a2 >> 6 > (a3 - 1) >> 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0;
  uint64_t v7 = v5 >> 6;
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v5;
  uint64_t v9 = v7 - v4;
  if ((a2 & 0x3F) != 0) {
    unint64_t v10 = ~(0xFFFFFFFFFFFFFFFFLL >> -(a2 & 0x3F));
  }
  else {
    unint64_t v10 = -1;
  }
  uint64_t v11 = *a1 + 8 * v4;
  for (int i = -64 * v4; ; i -= 64)
  {
    uint64_t v13 = v6 ? -1 : v10;
    unint64_t v14 = v9 == v6 ? v8 : -1;
    unint64_t v15 = (*(void *)(v11 + 8 * v6) ^ (a4 - 1)) & v13 & v14;
    if (v15) {
      break;
    }
    if (v9 + 1 == ++v6) {
      return 0xFFFFFFFFLL;
    }
  }
  return __clz(__rbit64(v15)) - i;
}

void sub_1CC45F238(uint64_t a1, uint64_t *a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  if (a3 >= 2)
  {
    unsigned int v5 = a2;
    if (a3 == 2)
    {
      if (*((_DWORD *)a2 - 20) > *(_DWORD *)(a1 + 8))
      {
        uint64_t v7 = (uint64_t)(a2 - 11);
        sub_1CC461568(a1, v7);
      }
    }
    else if ((uint64_t)a3 <= 0)
    {
      if ((uint64_t *)a1 != a2)
      {
        unint64_t v14 = (void *)(a1 + 88);
        if ((uint64_t *)(a1 + 88) != a2)
        {
          uint64_t v15 = 0;
          uint64_t v16 = a1;
          do
          {
            uint64_t v17 = v14;
            if (*(_DWORD *)(v16 + 96) > *(_DWORD *)(v16 + 8))
            {
              uint64_t v18 = *(void *)((char *)v14 + 5);
              *(void *)uint64_t v90 = *v14;
              *(void *)&v90[5] = v18;
              uint64_t v91 = v93;
              unint64_t v92 = 0x600000000;
              unsigned int v19 = *(_DWORD *)(v16 + 112);
              if (v19 && &v91 != (void **)(v16 + 104))
              {
                uint64_t v20 = *(const void **)(v16 + 104);
                if (v20 == (const void *)(v16 + 120))
                {
                  if (v19 >= 7) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v93, v20, 8 * *(unsigned int *)(v16 + 112));
                  LODWORD(v92) = v19;
                }
                else
                {
                  uint64_t v91 = *(void **)(v16 + 104);
                  unint64_t v92 = __PAIR64__(*(_DWORD *)(v16 + 116), v19);
                  *(void *)(v16 + 104) = v16 + 120;
                  *(_DWORD *)(v16 + 116) = 0;
                }
                *(_DWORD *)(v16 + 112) = 0;
              }
              int v94 = *(_DWORD *)(v16 + 168);
              uint64_t v21 = v15;
              while (1)
              {
                uint64_t v22 = a1 + v21;
                *(void *)(v22 + 88) = *(void *)(a1 + v21);
                *(void *)(v22 + 93) = *(void *)(a1 + v21 + 5);
                uint64_t v23 = (void **)(a1 + v21 + 104);
                unint64_t v24 = *(const void **)(a1 + v21 + 16);
                uint64_t v25 = a1 + v21 + 32;
                if ((const void *)v25 == v24)
                {
                  uint64_t v26 = (_DWORD *)(v22 + 24);
                  uint64_t v27 = *(unsigned int *)(v22 + 24);
                  uint64_t v28 = *(unsigned int *)(v22 + 112);
                  if (v28 < v27)
                  {
                    if (*(_DWORD *)(a1 + v21 + 116) < v27)
                    {
                      *(_DWORD *)(v22 + 112) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v28) {
                      memmove(*v23, v24, 8 * v28);
                    }
                    else {
                      uint64_t v28 = 0;
                    }
                    uint64_t v30 = *v26;
                    if (v28 != v30) {
                      memcpy((void *)(*(void *)(v22 + 104) + 8 * v28), (const void *)(*(void *)(v22 + 16) + 8 * v28), 8 * v30 - 8 * v28);
                    }
                  }
                  else if (v27)
                  {
                    memmove(*v23, v24, 8 * v27);
                  }
                  *(_DWORD *)(v22 + 112) = v27;
                }
                else
                {
                  unint64_t v31 = *v23;
                  if ((void *)(v22 + 120) != v31)
                  {
                    free(v31);
                    unint64_t v24 = *(const void **)(v22 + 16);
                  }
                  uint64_t v32 = a1 + v21;
                  *(void *)(v22 + 104) = v24;
                  uint64_t v26 = (_DWORD *)(v16 + 24);
                  *(void *)(v32 + 112) = *(void *)(a1 + v21 + 24);
                  *(void *)(v22 + 16) = v25;
                  *(_DWORD *)(v32 + 28) = 0;
                }
                *uint64_t v26 = 0;
                uint64_t v29 = a1 + v21;
                *(_DWORD *)(a1 + v21 + 168) = *(_DWORD *)(a1 + v21 + 80);
                if (!v21) {
                  break;
                }
                v16 -= 88;
                v21 -= 88;
                if (*(_DWORD *)&v90[8] <= *(_DWORD *)(v29 - 80))
                {
                  uint64_t v33 = a1 + v21 + 88;
                  goto LABEL_43;
                }
              }
              uint64_t v33 = a1;
LABEL_43:
              *(void *)uint64_t v33 = *(void *)v90;
              *(void *)(v33 + 5) = *(void *)&v90[5];
              unsigned int v34 = v91;
              if ((unsigned char *)v33 != v90)
              {
                int v35 = (void **)(v29 + 16);
                if (v91 == v93)
                {
                  int v36 = v92;
                  uint64_t v37 = *(unsigned int *)(v33 + 24);
                  if (v37 < v92)
                  {
                    if (*(_DWORD *)(v33 + 28) < v92)
                    {
                      *(_DWORD *)(v33 + 24) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v37) {
                      memmove(*v35, v93, 8 * v37);
                    }
                    else {
                      uint64_t v37 = 0;
                    }
                    if (v37 != v92) {
                      memcpy((char *)*v35 + 8 * v37, (char *)v91 + 8 * v37, 8 * v92 - 8 * v37);
                    }
                  }
                  else if (v92)
                  {
                    memmove(*v35, v93, 8 * v92);
                  }
                  *(_DWORD *)(v33 + 24) = v36;
                }
                else
                {
                  if (*v35 != (void *)(v33 + 32))
                  {
                    free(*v35);
                    unsigned int v34 = v91;
                  }
                  *int v35 = v34;
                  *(void *)(v33 + 24) = v92;
                  uint64_t v91 = v93;
                  HIDWORD(v92) = 0;
                }
                LODWORD(v92) = 0;
                unsigned int v34 = v91;
              }
              *(_DWORD *)(v33 + 80) = v94;
              if (v34 != v93) {
                free(v34);
              }
              unsigned int v5 = a2;
            }
            unint64_t v14 = v17 + 11;
            v15 += 88;
            uint64_t v16 = (uint64_t)v17;
          }
          while (v17 + 11 != v5);
        }
      }
    }
    else
    {
      unint64_t v11 = a3 >> 1;
      unint64_t v12 = (uint64_t *)(a1 + 88 * (a3 >> 1));
      unint64_t v13 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CC45FC74((uint64_t *)a1, v12, v13, (uint64_t)a4);
        uint64_t v38 = (uint64_t)&a4[22 * v11];
        sub_1CC45FC74((uint64_t *)(a1 + 88 * (a3 >> 1)), v5, a3 - (a3 >> 1), v38);
        unint64_t v87 = a3;
        uint64_t v89 = a4;
        int v39 = &a4[22 * a3];
        unsigned int v40 = (_DWORD *)(a1 + 80);
        uint64_t v41 = v38;
        uint64_t v42 = a4;
        while ((_DWORD *)v41 != v39)
        {
          unsigned int v43 = v40 - 20;
          int v44 = (void **)(v40 - 16);
          if (*(_DWORD *)(v41 + 8) <= v42[2])
          {
            uint64_t v50 = *(void *)v42;
            *(void *)((char *)v40 - 75) = *(void *)((char *)v42 + 5);
            void *v43 = v50;
            if (v43 != (void *)v42)
            {
              uint64_t v51 = (_DWORD *)*((void *)v42 + 2);
              if (v51 == v42 + 8)
              {
                uint64_t v53 = v42 + 6;
                uint64_t v52 = v42[6];
                uint64_t v54 = *(v40 - 14);
                if (v54 < v52)
                {
                  if (*(v40 - 13) < v52)
                  {
                    *(v40 - 14) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v54) {
                    memmove(*v44, v51, 8 * v54);
                  }
                  else {
                    uint64_t v54 = 0;
                  }
                  uint64_t v56 = *v53;
                  if (v54 != v56) {
                    memcpy((char *)*v44 + 8 * v54, (const void *)(*((void *)v42 + 2) + 8 * v54), 8 * v56 - 8 * v54);
                  }
                }
                else if (v52)
                {
                  memmove(*v44, v51, 8 * v52);
                }
                *(v40 - 14) = v52;
              }
              else
              {
                unsigned int v58 = (_DWORD *)*((void *)v40 - 8);
                if (v40 - 12 != v58)
                {
                  free(v58);
                  uint64_t v51 = (_DWORD *)*((void *)v42 + 2);
                }
                *((void *)v40 - 8) = v51;
                uint64_t v53 = v42 + 6;
                *((void *)v40 - 7) = *((void *)v42 + 3);
                *((void *)v42 + 2) = v42 + 8;
                v42[7] = 0;
              }
              *uint64_t v53 = 0;
            }
            *unsigned int v40 = v42[20];
            v42 += 22;
          }
          else
          {
            uint64_t v45 = *(void *)v41;
            *(void *)((char *)v40 - 75) = *(void *)(v41 + 5);
            void *v43 = v45;
            if (v43 != (void *)v41)
            {
              unsigned int v46 = *(const void **)(v41 + 16);
              if (v46 == (const void *)(v41 + 32))
              {
                unsigned int v48 = (_DWORD *)(v41 + 24);
                uint64_t v47 = *(unsigned int *)(v41 + 24);
                uint64_t v49 = *(v40 - 14);
                if (v49 < v47)
                {
                  if (*(v40 - 13) < v47)
                  {
                    *(v40 - 14) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v49) {
                    memmove(*v44, v46, 8 * v49);
                  }
                  else {
                    uint64_t v49 = 0;
                  }
                  uint64_t v55 = *v48;
                  if (v49 != v55) {
                    memcpy((char *)*v44 + 8 * v49, (const void *)(*(void *)(v41 + 16) + 8 * v49), 8 * v55 - 8 * v49);
                  }
                }
                else if (v47)
                {
                  memmove(*v44, v46, 8 * v47);
                }
                *(v40 - 14) = v47;
              }
              else
              {
                uint64_t v57 = (_DWORD *)*((void *)v40 - 8);
                if (v40 - 12 != v57)
                {
                  free(v57);
                  unsigned int v46 = *(const void **)(v41 + 16);
                }
                *((void *)v40 - 8) = v46;
                unsigned int v48 = (_DWORD *)(v41 + 24);
                *((void *)v40 - 7) = *(void *)(v41 + 24);
                *(void *)(v41 + 16) = v41 + 32;
                *(_DWORD *)(v41 + 28) = 0;
              }
              *unsigned int v48 = 0;
            }
            *unsigned int v40 = *(_DWORD *)(v41 + 80);
            v41 += 88;
          }
          v40 += 22;
          if (v42 == (_DWORD *)v38)
          {
            if ((_DWORD *)v41 != v39)
            {
              uint64_t v71 = 0;
              uint64_t v72 = v41;
              do
              {
                uint64_t v73 = v41 + v71 * 4;
                uint64_t v74 = &v40[v71];
                uint64_t v75 = *(void *)(v41 + v71 * 4);
                *(void *)((char *)&v40[v71 - 18] - 3) = *(void *)(v41 + v71 * 4 + 5);
                *(void *)&v40[v71 - 20] = v75;
                if (&v40[v71 - 20] != (_DWORD *)(v41 + v71 * 4))
                {
                  BOOL v76 = *(const void **)(v73 + 16);
                  if ((const void *)(v73 + 32) == v76)
                  {
                    unsigned int v77 = (void **)(v74 - 16);
                    uint64_t v79 = (_DWORD *)(v41 + v71 * 4 + 24);
                    uint64_t v78 = *v79;
                    uint64_t v80 = &v40[v71];
                    uint64_t v81 = v40[v71 - 14];
                    if (v81 < v78)
                    {
                      if (*(v80 - 13) < v78)
                      {
                        *(v80 - 14) = 0;
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      if (v81) {
                        memmove(*v77, v76, 8 * v81);
                      }
                      else {
                        uint64_t v81 = 0;
                      }
                      uint64_t v82 = *v79;
                      if (v81 != v82) {
                        memcpy((char *)*v77 + 8 * v81, (const void *)(*(void *)(v73 + 16) + 8 * v81), 8 * v82 - 8 * v81);
                      }
                    }
                    else if (v78)
                    {
                      memmove(*v77, v76, 8 * v78);
                    }
                    *(v80 - 14) = v78;
                  }
                  else
                  {
                    unsigned int v83 = (_DWORD *)*((void *)v74 - 8);
                    if (&v40[v71 - 12] != v83)
                    {
                      free(v83);
                      BOOL v76 = *(const void **)(v73 + 16);
                    }
                    *((void *)v74 - 8) = v76;
                    uint64_t v79 = (_DWORD *)(v72 + 24);
                    *(void *)&v40[v71 - 14] = *(void *)(v41 + v71 * 4 + 24);
                    *(void *)(v73 + 16) = v73 + 32;
                    *(_DWORD *)(v41 + v71 * 4 + 28) = 0;
                  }
                  *uint64_t v79 = 0;
                }
                v40[v71] = *(_DWORD *)(v73 + 80);
                v71 += 22;
                uint64_t v72 = v73 + 88;
              }
              while ((_DWORD *)(v73 + 88) != v39);
            }
            goto LABEL_150;
          }
        }
        if (v42 != (_DWORD *)v38)
        {
          uint64_t v59 = 0;
          unsigned int v60 = v42;
          do
          {
            unint64_t v61 = &v42[v59];
            uint64_t v62 = *(void *)((char *)&v42[v59 + 1] + 1);
            *(void *)&v40[v59 - 20] = *(void *)&v42[v59];
            uint64_t v63 = (uint64_t)&v40[v59 - 20];
            *(void *)(v63 + 5) = v62;
            if ((_DWORD *)v63 != &v42[v59])
            {
              unsigned int v64 = (void **)&v40[v59 - 16];
              unsigned int v65 = (_DWORD *)*((void *)v61 + 2);
              if (v61 + 8 == v65)
              {
                int v67 = &v42[v59 + 6];
                uint64_t v66 = *v67;
                uint64_t v68 = &v40[v59];
                uint64_t v69 = v40[v59 - 14];
                if (v69 < v66)
                {
                  if (*(v68 - 13) < v66)
                  {
                    *(v68 - 14) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v69) {
                    memmove(*v64, v65, 8 * v69);
                  }
                  else {
                    uint64_t v69 = 0;
                  }
                  uint64_t v70 = *v67;
                  if (v69 != v70) {
                    memcpy((char *)*v64 + 8 * v69, (const void *)(*((void *)v61 + 2) + 8 * v69), 8 * v70 - 8 * v69);
                  }
                }
                else if (v66)
                {
                  memmove(*v64, v65, 8 * v66);
                }
                *(v68 - 14) = v66;
              }
              else
              {
                if (&v40[v59 - 12] != *v64)
                {
                  free(*v64);
                  unsigned int v65 = (_DWORD *)*((void *)v61 + 2);
                }
                *unsigned int v64 = v65;
                int v67 = v60 + 6;
                *(void *)&v40[v59 - 14] = *(void *)&v42[v59 + 6];
                *((void *)v61 + 2) = v61 + 8;
                v42[v59 + 7] = 0;
              }
              _DWORD *v67 = 0;
            }
            v40[v59] = v61[20];
            v59 += 22;
            unsigned int v60 = v61 + 22;
          }
          while (v61 + 22 != (_DWORD *)v38);
        }
LABEL_150:
        if (v89)
        {
          unint64_t v84 = v87;
          uint64_t v85 = v89 + 8;
          do
          {
            uint64_t v86 = (void *)*(v85 - 2);
            if (v85 != v86) {
              free(v86);
            }
            v85 += 11;
            --v84;
          }
          while (v84);
        }
      }
      else
      {
        sub_1CC45F238(a1, v12, v13, a4, a5);
        sub_1CC45F238(a1 + 88 * (a3 >> 1), v5, a3 - (a3 >> 1), a4, a5);
        sub_1CC460888(a1, a1 + 88 * (a3 >> 1), (uint64_t)v5, a3 >> 1, a3 - (a3 >> 1), a4, a5);
      }
    }
  }
}

void sub_1CC45FC74(uint64_t *a1, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v6 = a2;
    uint64_t v7 = a1;
    if (a3 == 2)
    {
      unint64_t v13 = a2 - 11;
      unint64_t v14 = (void *)(a4 + 32);
      if (*((_DWORD *)a2 - 20) <= *((_DWORD *)a1 + 2))
      {
        uint64_t v62 = *a1;
        *(void *)(a4 + 5) = *(uint64_t *)((char *)a1 + 5);
        *(void *)a4 = v62;
        *(void *)(a4 + 16) = v14;
        *(void *)(a4 + 24) = 0x600000000;
        unsigned int v63 = *((_DWORD *)a1 + 6);
        if (v63 && (uint64_t *)a4 != a1)
        {
          unsigned int v64 = (uint64_t *)a1[2];
          if (v64 == a1 + 4)
          {
            if (v63 >= 7) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy(v14, v64, 8 * *((unsigned int *)a1 + 6));
            *(_DWORD *)(v4 + 24) = v63;
          }
          else
          {
            *(void *)(a4 + 16) = v64;
            int v102 = *((_DWORD *)a1 + 7);
            *(_DWORD *)(a4 + 24) = v63;
            *(_DWORD *)(a4 + 28) = v102;
            a1[2] = (uint64_t)(a1 + 4);
            *((_DWORD *)a1 + 7) = 0;
          }
          *((_DWORD *)v7 + 6) = 0;
        }
        *(_DWORD *)(v4 + 80) = *((_DWORD *)v7 + 20);
        uint64_t v65 = *v13;
        uint64_t v66 = *(uint64_t *)((char *)v6 - 83);
        *(void *)(v4 + 104) = v4 + 120;
        *(void *)(v4 + 93) = v66;
        *(void *)(v4 + 88) = v65;
        *(void *)(v4 + 112) = 0x600000000;
        unsigned int v67 = *((_DWORD *)v6 - 16);
        if (v67 && (uint64_t *)(v4 + 104) != v6 - 9)
        {
          uint64_t v68 = (uint64_t *)*(v6 - 9);
          if (v68 == v6 - 7)
          {
            if (v67 >= 7) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            memcpy((void *)(v4 + 120), v68, 8 * *((unsigned int *)v6 - 16));
            *(_DWORD *)(v4 + 112) = v67;
          }
          else
          {
            *(void *)(v4 + 104) = v68;
            int v103 = *((_DWORD *)v6 - 15);
            *(_DWORD *)(v4 + 112) = v67;
            *(_DWORD *)(v4 + 116) = v103;
            *(v6 - 9) = (uint64_t)(v6 - 7);
            *((_DWORD *)v6 - 15) = 0;
          }
          *((_DWORD *)v6 - 16) = 0;
        }
        unint64_t v12 = (_DWORD *)(v4 + 168);
        unint64_t v24 = v6 - 1;
        goto LABEL_106;
      }
      uint64_t v15 = *v13;
      *(void *)(a4 + 5) = *(uint64_t *)((char *)a2 - 83);
      *(void *)a4 = v15;
      *(void *)(a4 + 16) = v14;
      *(void *)(a4 + 24) = 0x600000000;
      unsigned int v16 = *((_DWORD *)a2 - 16);
      if (v16 && (uint64_t *)(a4 + 16) != a2 - 9)
      {
        uint64_t v17 = (uint64_t *)*(a2 - 9);
        uint64_t v18 = a2 - 7;
        if (v17 == v6 - 7)
        {
          if (v16 >= 7) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v14, v18, 8 * *((unsigned int *)v6 - 16));
          *(_DWORD *)(v4 + 24) = v16;
        }
        else
        {
          *(void *)(a4 + 16) = v17;
          int v100 = *((_DWORD *)v6 - 15);
          *(_DWORD *)(a4 + 24) = v16;
          *(_DWORD *)(a4 + 28) = v100;
          *(v6 - 9) = (uint64_t)v18;
          *((_DWORD *)v6 - 15) = 0;
        }
        *((_DWORD *)v6 - 16) = 0;
      }
      *(_DWORD *)(v4 + 80) = *((_DWORD *)v6 - 2);
      uint64_t v19 = *v7;
      uint64_t v20 = *(uint64_t *)((char *)v7 + 5);
      *(void *)(v4 + 104) = v4 + 120;
      *(void *)(v4 + 93) = v20;
      *(void *)(v4 + 88) = v19;
      *(void *)(v4 + 112) = 0x600000000;
      unsigned int v21 = *((_DWORD *)v7 + 6);
      if (v21 && (uint64_t *)(v4 + 104) != v7 + 2)
      {
        uint64_t v22 = (uint64_t *)v7[2];
        uint64_t v23 = v7 + 4;
        if (v22 == v7 + 4)
        {
          if (v21 >= 7) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((void *)(v4 + 120), v23, 8 * *((unsigned int *)v7 + 6));
          *(_DWORD *)(v4 + 112) = v21;
        }
        else
        {
          *(void *)(v4 + 104) = v22;
          int v101 = *((_DWORD *)v7 + 7);
          *(_DWORD *)(v4 + 112) = v21;
          *(_DWORD *)(v4 + 116) = v101;
          v7[2] = (uint64_t)v23;
          *((_DWORD *)v7 + 7) = 0;
        }
        *((_DWORD *)v7 + 6) = 0;
      }
      unint64_t v12 = (_DWORD *)(v4 + 168);
LABEL_25:
      unint64_t v24 = v7 + 10;
LABEL_106:
      *unint64_t v12 = *(_DWORD *)v24;
      return;
    }
    if (a3 == 1)
    {
      uint64_t v8 = *a1;
      *(void *)(a4 + 5) = *(uint64_t *)((char *)a1 + 5);
      *(void *)a4 = v8;
      *(void *)(a4 + 16) = a4 + 32;
      *(void *)(a4 + 24) = 0x600000000;
      unsigned int v9 = *((_DWORD *)a1 + 6);
      if (v9 && (uint64_t *)a4 != a1)
      {
        unint64_t v10 = (uint64_t *)a1[2];
        unint64_t v11 = a1 + 4;
        if (v10 == a1 + 4)
        {
          if (v9 >= 7) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((void *)(a4 + 32), v11, 8 * *((unsigned int *)a1 + 6));
          *(_DWORD *)(v4 + 24) = v9;
        }
        else
        {
          *(void *)(a4 + 16) = v10;
          int v99 = *((_DWORD *)a1 + 7);
          *(_DWORD *)(a4 + 24) = v9;
          *(_DWORD *)(a4 + 28) = v99;
          a1[2] = (uint64_t)v11;
          *((_DWORD *)a1 + 7) = 0;
        }
        *((_DWORD *)v7 + 6) = 0;
      }
      unint64_t v12 = (_DWORD *)(v4 + 80);
      goto LABEL_25;
    }
    if ((uint64_t)a3 > 8)
    {
      uint64_t v69 = 11 * (a3 >> 1);
      uint64_t v70 = &a1[v69];
      sub_1CC45F238(a1, &a1[v69], a3 >> 1, a4, a3 >> 1);
      sub_1CC45F238(&v7[v69], v6, a3 - (a3 >> 1), v4 + v69 * 8, a3 - (a3 >> 1));
      uint64_t v71 = &v7[v69];
      while (v71 != v6)
      {
        uint64_t v72 = (void *)(v4 + 32);
        if (*((_DWORD *)v71 + 2) <= *((_DWORD *)v7 + 2))
        {
          uint64_t v76 = *v7;
          *(void *)(v4 + 5) = *(uint64_t *)((char *)v7 + 5);
          *(void *)uint64_t v4 = v76;
          *(void *)(v4 + 16) = v72;
          *(void *)(v4 + 24) = 0x600000000;
          unsigned int v77 = *((_DWORD *)v7 + 6);
          if (v77 && (uint64_t *)v4 != v7)
          {
            uint64_t v78 = (uint64_t *)v7[2];
            if (v78 == v7 + 4)
            {
              if (v77 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v72, v78, 8 * *((unsigned int *)v7 + 6));
              *(_DWORD *)(v4 + 24) = v77;
            }
            else
            {
              *(void *)(v4 + 16) = v78;
              int v80 = *((_DWORD *)v7 + 7);
              *(_DWORD *)(v4 + 24) = v77;
              *(_DWORD *)(v4 + 28) = v80;
              v7[2] = (uint64_t)(v7 + 4);
              *((_DWORD *)v7 + 7) = 0;
            }
            *((_DWORD *)v7 + 6) = 0;
          }
          *(_DWORD *)(v4 + 80) = *((_DWORD *)v7 + 20);
          v7 += 11;
        }
        else
        {
          uint64_t v73 = *v71;
          *(void *)(v4 + 5) = *(uint64_t *)((char *)v71 + 5);
          *(void *)uint64_t v4 = v73;
          *(void *)(v4 + 16) = v72;
          *(void *)(v4 + 24) = 0x600000000;
          unsigned int v74 = *((_DWORD *)v71 + 6);
          if (v74 && (uint64_t *)v4 != v71)
          {
            uint64_t v75 = (uint64_t *)v71[2];
            if (v75 == v71 + 4)
            {
              if (v74 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v72, v75, 8 * *((unsigned int *)v71 + 6));
              *(_DWORD *)(v4 + 24) = v74;
            }
            else
            {
              *(void *)(v4 + 16) = v75;
              int v79 = *((_DWORD *)v71 + 7);
              *(_DWORD *)(v4 + 24) = v74;
              *(_DWORD *)(v4 + 28) = v79;
              v71[2] = (uint64_t)(v71 + 4);
              *((_DWORD *)v71 + 7) = 0;
            }
            *((_DWORD *)v71 + 6) = 0;
          }
          *(_DWORD *)(v4 + 80) = *((_DWORD *)v71 + 20);
          v71 += 11;
        }
        v4 += 88;
        if (v7 == v70)
        {
          if (v71 != v6)
          {
            uint64_t v90 = 0;
            do
            {
              uint64_t v91 = &v71[v90];
              unint64_t v92 = (uint64_t *)(v4 + v90 * 8);
              uint64_t v93 = v71[v90];
              *(uint64_t *)((char *)v92 + 5) = *(uint64_t *)((char *)&v71[v90] + 5);
              *unint64_t v92 = v93;
              int v94 = (void *)(v4 + v90 * 8 + 32);
              *(void *)(v4 + v90 * 8 + 16) = v94;
              v92[3] = 0x600000000;
              unsigned int v95 = v71[v90 + 3];
              if (v95) {
                BOOL v96 = v92 == v91;
              }
              else {
                BOOL v96 = 1;
              }
              if (!v96)
              {
                size_t v97 = (uint64_t *)v91[2];
                if (v91 + 4 == v97)
                {
                  if (v95 >= 7) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  memcpy(v94, v97, 8 * LODWORD(v71[v90 + 3]));
                  *((_DWORD *)v92 + 6) = v95;
                }
                else
                {
                  v92[2] = (uint64_t)v97;
                  int v98 = HIDWORD(v71[v90 + 3]);
                  *((_DWORD *)v92 + 6) = v95;
                  *((_DWORD *)v92 + 7) = v98;
                  v91[2] = (uint64_t)(v91 + 4);
                  HIDWORD(v71[v90 + 3]) = 0;
                }
                *((_DWORD *)v91 + 6) = 0;
              }
              *((_DWORD *)v92 + 20) = *((_DWORD *)v91 + 20);
              v90 += 11;
            }
            while (&v71[v90] != v6);
          }
          return;
        }
      }
      if (v7 != v70)
      {
        uint64_t v81 = 0;
        do
        {
          uint64_t v82 = (uint64_t *)(v4 + v81 * 8);
          unsigned int v83 = &v7[v81];
          uint64_t v84 = v7[v81];
          *(uint64_t *)((char *)v82 + 5) = *(uint64_t *)((char *)&v7[v81] + 5);
          *uint64_t v82 = v84;
          uint64_t v85 = (void *)(v4 + v81 * 8 + 32);
          *(void *)(v4 + v81 * 8 + 16) = v85;
          v82[3] = 0x600000000;
          unsigned int v86 = v7[v81 + 3];
          if (v86) {
            BOOL v87 = v82 == v83;
          }
          else {
            BOOL v87 = 1;
          }
          if (!v87)
          {
            unsigned int v88 = (uint64_t *)v83[2];
            if (v83 + 4 == v88)
            {
              if (v86 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v85, v88, 8 * LODWORD(v7[v81 + 3]));
              *((_DWORD *)v82 + 6) = v86;
            }
            else
            {
              *(void *)(v4 + v81 * 8 + 16) = v88;
              int v89 = HIDWORD(v7[v81 + 3]);
              *((_DWORD *)v82 + 6) = v86;
              *((_DWORD *)v82 + 7) = v89;
              v83[2] = (uint64_t)(v83 + 4);
              HIDWORD(v7[v81 + 3]) = 0;
            }
            *((_DWORD *)v83 + 6) = 0;
          }
          *((_DWORD *)v82 + 20) = *((_DWORD *)v83 + 20);
          v81 += 11;
        }
        while (&v7[v81] != v70);
      }
    }
    else if (a1 != a2)
    {
      uint64_t v25 = *a1;
      *(void *)(a4 + 5) = *(uint64_t *)((char *)a1 + 5);
      *(void *)a4 = v25;
      *(void *)(a4 + 16) = a4 + 32;
      *(void *)(a4 + 24) = 0x600000000;
      unsigned int v26 = *((_DWORD *)a1 + 6);
      if (v26 && (uint64_t *)a4 != a1)
      {
        uint64_t v27 = (uint64_t *)a1[2];
        uint64_t v28 = a1 + 4;
        if (v27 == a1 + 4)
        {
          if (v26 >= 7) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy((void *)(a4 + 32), v28, 8 * *((unsigned int *)a1 + 6));
          *(_DWORD *)(v4 + 24) = v26;
        }
        else
        {
          *(void *)(a4 + 16) = v27;
          int v104 = *((_DWORD *)a1 + 7);
          *(_DWORD *)(a4 + 24) = v26;
          *(_DWORD *)(a4 + 28) = v104;
          a1[2] = (uint64_t)v28;
          *((_DWORD *)a1 + 7) = 0;
        }
        *((_DWORD *)v7 + 6) = 0;
      }
      *(_DWORD *)(v4 + 80) = *((_DWORD *)v7 + 20);
      uint64_t v29 = v7 + 11;
      if (v7 + 11 != v6)
      {
        uint64_t v30 = 0;
        unint64_t v31 = (uint64_t *)v4;
        uint64_t v105 = v6;
        do
        {
          uint64_t v32 = v29;
          uint64_t v33 = v31 + 11;
          unsigned int v34 = v31 + 15;
          if (*((_DWORD *)v7 + 24) <= *((_DWORD *)v31 + 2))
          {
            uint64_t v48 = *v32;
            *(uint64_t *)((char *)v31 + 93) = *(void *)((char *)v32 + 5);
            uint64_t *v33 = v48;
            v31[13] = (uint64_t)v34;
            v31[14] = 0x600000000;
            unsigned int v49 = *((_DWORD *)v7 + 28);
            if (v49 && v31 != v7)
            {
              uint64_t v50 = (uint64_t *)v7[13];
              if (v50 == v7 + 15)
              {
                if (v49 >= 7) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memcpy(v34, v50, 8 * *((unsigned int *)v7 + 28));
                *((_DWORD *)v31 + 28) = v49;
              }
              else
              {
                v31[13] = (uint64_t)v50;
                int v61 = *((_DWORD *)v7 + 29);
                *((_DWORD *)v31 + 28) = v49;
                *((_DWORD *)v31 + 29) = v61;
                v7[13] = (uint64_t)(v7 + 15);
                *((_DWORD *)v7 + 29) = 0;
              }
              *((_DWORD *)v7 + 28) = 0;
            }
            *((_DWORD *)v31 + 42) = *((_DWORD *)v7 + 42);
          }
          else
          {
            uint64_t *v33 = *v31;
            *(uint64_t *)((char *)v31 + 93) = *(uint64_t *)((char *)v31 + 5);
            v31[13] = (uint64_t)v34;
            v31[14] = 0x600000000;
            unsigned int v35 = *((_DWORD *)v31 + 6);
            if (v35)
            {
              int v36 = (uint64_t *)v31[2];
              if (v36 == v31 + 4)
              {
                if (v35 >= 7) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memcpy(v34, v36, 8 * *((unsigned int *)v31 + 6));
                *((_DWORD *)v31 + 28) = v35;
              }
              else
              {
                v31[13] = (uint64_t)v36;
                int v60 = *((_DWORD *)v31 + 7);
                *((_DWORD *)v31 + 28) = v35;
                *((_DWORD *)v31 + 29) = v60;
                v31[2] = (uint64_t)(v31 + 4);
                *((_DWORD *)v31 + 7) = 0;
              }
              *((_DWORD *)v31 + 6) = 0;
            }
            uint64_t v106 = v31 + 11;
            uint64_t v107 = v32;
            *((_DWORD *)v31 + 42) = *((_DWORD *)v31 + 20);
            uint64_t v37 = v4;
            if (v31 != (uint64_t *)v4)
            {
              uint64_t v38 = v30;
              while (1)
              {
                uint64_t v37 = v4 + v38;
                if (*((_DWORD *)v7 + 24) <= *(_DWORD *)(v4 + v38 - 80)) {
                  break;
                }
                *(void *)uint64_t v37 = *(void *)(v37 - 88);
                *(void *)(v37 + 5) = *(void *)(v37 - 83);
                int v39 = (void **)(v37 + 16);
                unsigned int v40 = *(const void **)(v37 - 72);
                if ((const void *)(v37 - 56) == v40)
                {
                  uint64_t v41 = v4 + v38;
                  unsigned int v43 = (uint64_t *)(v4 + v38 - 64);
                  uint64_t v42 = *(unsigned int *)v43;
                  uint64_t v44 = *(unsigned int *)(v4 + v38 + 24);
                  if (v44 < v42)
                  {
                    if (*(_DWORD *)(v41 + 28) < v42)
                    {
                      *(_DWORD *)(v41 + 24) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v44) {
                      memmove(*v39, v40, 8 * v44);
                    }
                    else {
                      uint64_t v44 = 0;
                    }
                    uint64_t v45 = *(unsigned int *)v43;
                    if (v44 != v45) {
                      memcpy((void *)(*(void *)(v37 + 16) + 8 * v44), (const void *)(*(void *)(v37 - 72) + 8 * v44), 8 * v45 - 8 * v44);
                    }
                  }
                  else if (v42)
                  {
                    memmove(*v39, v40, 8 * v42);
                  }
                  *(_DWORD *)(v41 + 24) = v42;
                }
                else
                {
                  unsigned int v46 = *v39;
                  uint64_t v47 = v4 + v38;
                  if ((void *)(v4 + v38 + 32) != v46)
                  {
                    free(v46);
                    unsigned int v40 = *(const void **)(v37 - 72);
                  }
                  *(void *)(v37 + 16) = v40;
                  unsigned int v43 = v31 - 8;
                  *(void *)(v47 + 24) = *(void *)(v47 - 64);
                  *(void *)(v37 - 72) = v37 - 56;
                  *(_DWORD *)(v47 - 60) = 0;
                }
                v31 -= 11;
                *(_DWORD *)unsigned int v43 = 0;
                *(_DWORD *)(v4 + v38 + 80) = *(_DWORD *)(v4 + v38 - 8);
                v38 -= 88;
                if (!v38)
                {
                  uint64_t v37 = v4;
                  break;
                }
              }
            }
            uint64_t v51 = *v107;
            *(void *)(v37 + 5) = *(void *)((char *)v107 + 5);
            *(void *)uint64_t v37 = v51;
            if ((uint64_t *)v37 != v7 + 11)
            {
              uint64_t v52 = (uint64_t **)(v7 + 13);
              uint64_t v53 = (uint64_t *)v7[13];
              if (v53 == v7 + 15)
              {
                uint64_t v54 = (void **)(v37 + 16);
                uint64_t v55 = v7 + 14;
                uint64_t v56 = *((unsigned int *)v7 + 28);
                uint64_t v57 = *(unsigned int *)(v37 + 24);
                if (v57 < v56)
                {
                  if (*(_DWORD *)(v37 + 28) < v56)
                  {
                    *(_DWORD *)(v37 + 24) = 0;
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v57) {
                    memmove(*v54, v7 + 15, 8 * v57);
                  }
                  else {
                    uint64_t v57 = 0;
                  }
                  uint64_t v58 = *v55;
                  if (v57 != v58) {
                    memcpy((char *)*v54 + 8 * v57, &(*v52)[v57], (char *)&(*v52)[v58] - (char *)&(*v52)[v57]);
                  }
                }
                else if (v56)
                {
                  memmove(*v54, v7 + 15, 8 * v56);
                }
                *(_DWORD *)(v37 + 24) = v56;
              }
              else
              {
                uint64_t v59 = *(void **)(v37 + 16);
                if (v59 != (void *)(v37 + 32))
                {
                  free(v59);
                  uint64_t v53 = *v52;
                }
                *(void *)(v37 + 16) = v53;
                uint64_t v55 = v7 + 14;
                *(void *)(v37 + 24) = v7[14];
                v7[13] = (uint64_t)(v7 + 15);
                *((_DWORD *)v7 + 29) = 0;
              }
              _DWORD *v55 = 0;
            }
            *(_DWORD *)(v37 + 80) = *((_DWORD *)v7 + 42);
            uint64_t v6 = v105;
            uint64_t v33 = v106;
            uint64_t v32 = v107;
          }
          uint64_t v29 = v32 + 11;
          v30 += 88;
          unint64_t v31 = v33;
          uint64_t v7 = v32;
        }
        while (v32 + 11 != v6);
      }
    }
  }
}

void sub_1CC460888(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7)
{
  if (!a5) {
    return;
  }
  uint64_t v7 = a5;
  while (a4 > a7 && v7 > a7)
  {
    if (!a4) {
      return;
    }
    uint64_t v11 = 0;
    uint64_t v12 = -a4;
    while (1)
    {
      uint64_t v13 = a1 + v11;
      if (*(_DWORD *)(a2 + 8) > *(_DWORD *)(a1 + v11 + 8)) {
        break;
      }
      v11 += 88;
      if (__CFADD__(v12++, 1)) {
        return;
      }
    }
    uint64_t v15 = -v12;
    if (-v12 >= v7)
    {
      if (v12 == -1)
      {
        sub_1CC461568(a1 + v11, a2);
        return;
      }
      if (v12 > 0) {
        uint64_t v15 = 1 - v12;
      }
      uint64_t v25 = v15 >> 1;
      uint64_t v24 = a3;
      if (a3 != a2)
      {
        unint64_t v26 = 0x2E8BA2E8BA2E8BA3 * ((a3 - a2) >> 3);
        uint64_t v24 = a2;
        do
        {
          unint64_t v27 = v26 >> 1;
          unint64_t v28 = v24 + 88 * (v26 >> 1);
          unsigned int v29 = *(_DWORD *)(v28 + 8);
          uint64_t v30 = v28 + 88;
          v26 += ~(v26 >> 1);
          if (v29 > *(_DWORD *)(a1 + 88 * v25 + v11 + 8)) {
            uint64_t v24 = v30;
          }
          else {
            unint64_t v26 = v27;
          }
        }
        while (v26);
      }
      uint64_t v18 = a1 + 88 * v25 + v11;
      uint64_t v17 = 0x2E8BA2E8BA2E8BA3 * ((v24 - a2) >> 3);
    }
    else
    {
      if (v7 >= 0) {
        uint64_t v16 = v7;
      }
      else {
        uint64_t v16 = v7 + 1;
      }
      uint64_t v17 = v16 >> 1;
      uint64_t v18 = a2;
      if (v13 != a2)
      {
        unint64_t v19 = 0x2E8BA2E8BA2E8BA3 * ((a2 - a1 - v11) >> 3);
        uint64_t v18 = a1 + v11;
        do
        {
          unint64_t v20 = v19 >> 1;
          unint64_t v21 = v18 + 88 * (v19 >> 1);
          unsigned int v22 = *(_DWORD *)(v21 + 8);
          uint64_t v23 = v21 + 88;
          v19 += ~(v19 >> 1);
          if (*(_DWORD *)(a2 + 88 * v17 + 8) > v22) {
            unint64_t v19 = v20;
          }
          else {
            uint64_t v18 = v23;
          }
        }
        while (v19);
      }
      uint64_t v24 = a2 + 88 * v17;
      uint64_t v25 = 0x2E8BA2E8BA2E8BA3 * ((v18 - a1 - v11) >> 3);
    }
    uint64_t v31 = v24;
    if (v18 != a2)
    {
      uint64_t v31 = v18;
      if (a2 != v24)
      {
        uint64_t v135 = v25;
        uint64_t v136 = v17;
        uint64_t v137 = a7;
        uint64_t v139 = a3;
        sub_1CC461568(v18, a2);
        uint64_t v31 = v18 + 88;
        for (uint64_t i = a2 + 88; i != v24; i += 88)
        {
          if (v31 == a2) {
            a2 = i;
          }
          sub_1CC461568(v31, i);
          v31 += 88;
        }
        if (v31 == a2)
        {
          uint64_t v31 = a2;
        }
        else
        {
          uint64_t v33 = v31;
          uint64_t v34 = a2;
          do
          {
            while (1)
            {
              sub_1CC461568(v33, a2);
              v33 += 88;
              a2 += 88;
              if (a2 == v24) {
                break;
              }
              if (v33 == v34) {
                uint64_t v34 = a2;
              }
            }
            a2 = v34;
          }
          while (v33 != v34);
        }
        a7 = v137;
        a3 = v139;
        uint64_t v25 = v135;
        uint64_t v17 = v136;
      }
    }
    a4 = -(v25 + v12);
    uint64_t v35 = v7 - v17;
    if (v25 + v17 >= v7 - (v25 + v17) - v12)
    {
      uint64_t v38 = v25;
      uint64_t v39 = -(v25 + v12);
      uint64_t v40 = v17;
      uint64_t v37 = a7;
      sub_1CC460888(v31, v24, a3, v39, v35, a6);
      uint64_t v24 = v18;
      uint64_t v35 = v40;
      a4 = v38;
      a3 = v31;
    }
    else
    {
      uint64_t v36 = a3;
      uint64_t v37 = a7;
      sub_1CC460888(v13, v18, v31, v25, v17, a6);
      a3 = v36;
      uint64_t v13 = v31;
    }
    uint64_t v7 = v35;
    a1 = v13;
    a2 = v24;
    a7 = v37;
    if (!v35) {
      return;
    }
  }
  if (a4 <= v7)
  {
    if (a1 == a2) {
      return;
    }
    unint64_t v53 = 0;
    uint64_t v42 = 0;
    unsigned int v43 = a6;
    do
    {
      uint64_t v54 = &a6[v53 / 4];
      uint64_t v55 = (_DWORD *)(a1 + v53);
      uint64_t v56 = *(void *)(a1 + v53);
      *(void *)((char *)v54 + 5) = *(void *)(a1 + v53 + 5);
      *(void *)uint64_t v54 = v56;
      uint64_t v57 = &a6[v53 / 4 + 8];
      *(void *)&a6[v53 / 4 + 4] = v57;
      *((void *)v54 + 3) = 0x600000000;
      unsigned int v58 = *(_DWORD *)(a1 + v53 + 24);
      if (v58) {
        BOOL v59 = v55 == v54;
      }
      else {
        BOOL v59 = 1;
      }
      if (!v59)
      {
        int v60 = (_DWORD *)*((void *)v55 + 2);
        if (v55 + 8 == v60)
        {
          uint64_t v61 = a3;
          if (v58 >= 7) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v57, v60, 8 * *(unsigned int *)(a1 + v53 + 24));
          v54[6] = v58;
          a3 = v61;
        }
        else
        {
          *((void *)v54 + 2) = v60;
          int v62 = *(_DWORD *)(a1 + v53 + 28);
          v54[6] = v58;
          v54[7] = v62;
          *((void *)v55 + 2) = v55 + 8;
          *(_DWORD *)(a1 + v53 + 28) = 0;
        }
        v55[6] = 0;
      }
      v54[20] = v55[20];
      ++v42;
      v53 += 88;
    }
    while (a1 + v53 != a2);
    if (v53)
    {
      unsigned int v83 = (uint64_t *)&a6[v53 / 4];
      uint64_t v138 = (uint64_t)&a6[v53 / 4 - 22];
      uint64_t v140 = a3;
      uint64_t v84 = (_DWORD *)(a1 + 80);
      uint64_t v85 = (uint64_t *)a6;
      while (a2 != a3)
      {
        unsigned int v86 = (uint64_t *)(v84 - 20);
        BOOL v87 = (void **)(v84 - 16);
        if (*(_DWORD *)(a2 + 8) <= *((_DWORD *)v85 + 2))
        {
          uint64_t v95 = *v85;
          *(void *)((char *)v84 - 75) = *(uint64_t *)((char *)v85 + 5);
          *unsigned int v86 = v95;
          if (v86 != v85)
          {
            BOOL v96 = (uint64_t *)v85[2];
            if (v96 == v85 + 4)
            {
              int v98 = v85 + 3;
              uint64_t v97 = *((unsigned int *)v85 + 6);
              uint64_t v99 = *(v84 - 14);
              if (v99 < v97)
              {
                if (*(v84 - 13) < v97)
                {
                  *(v84 - 14) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v99) {
                  memmove(*v87, v96, 8 * v99);
                }
                else {
                  uint64_t v99 = 0;
                }
                uint64_t v103 = *v98;
                if (v99 != v103) {
                  memcpy((char *)*v87 + 8 * v99, (const void *)(v85[2] + 8 * v99), 8 * v103 - 8 * v99);
                }
                *(v84 - 14) = v97;
                a3 = v140;
              }
              else
              {
                if (v97)
                {
                  int v100 = *v87;
                  uint64_t v101 = a3;
                  memmove(v100, v96, 8 * v97);
                  a3 = v101;
                }
                *(v84 - 14) = v97;
              }
            }
            else
            {
              uint64_t v105 = (_DWORD *)*((void *)v84 - 8);
              if (v84 - 12 != v105)
              {
                uint64_t v107 = a3;
                free(v105);
                a3 = v107;
                BOOL v96 = (uint64_t *)v85[2];
              }
              *((void *)v84 - 8) = v96;
              int v98 = v85 + 3;
              *((void *)v84 - 7) = v85[3];
              v85[2] = (uint64_t)(v85 + 4);
              *((_DWORD *)v85 + 7) = 0;
            }
            *int v98 = 0;
          }
          *uint64_t v84 = *((_DWORD *)v85 + 20);
          v85 += 11;
        }
        else
        {
          uint64_t v88 = *(void *)a2;
          *(void *)((char *)v84 - 75) = *(void *)(a2 + 5);
          *unsigned int v86 = v88;
          if (v86 != (uint64_t *)a2)
          {
            int v89 = *(const void **)(a2 + 16);
            if (v89 == (const void *)(a2 + 32))
            {
              uint64_t v91 = (_DWORD *)(a2 + 24);
              uint64_t v90 = *(unsigned int *)(a2 + 24);
              uint64_t v92 = *(v84 - 14);
              if (v92 < v90)
              {
                if (*(v84 - 13) < v90)
                {
                  *(v84 - 14) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v92) {
                  memmove(*v87, v89, 8 * v92);
                }
                else {
                  uint64_t v92 = 0;
                }
                uint64_t v102 = *v91;
                if (v92 != v102) {
                  memcpy((char *)*v87 + 8 * v92, (const void *)(*(void *)(a2 + 16) + 8 * v92), 8 * v102 - 8 * v92);
                }
                *(v84 - 14) = v90;
                a3 = v140;
              }
              else
              {
                if (v90)
                {
                  uint64_t v93 = *v87;
                  uint64_t v94 = a3;
                  memmove(v93, v89, 8 * v90);
                  a3 = v94;
                }
                *(v84 - 14) = v90;
              }
            }
            else
            {
              int v104 = (_DWORD *)*((void *)v84 - 8);
              if (v84 - 12 != v104)
              {
                uint64_t v106 = a3;
                free(v104);
                a3 = v106;
                int v89 = *(const void **)(a2 + 16);
              }
              *((void *)v84 - 8) = v89;
              uint64_t v91 = (_DWORD *)(a2 + 24);
              *((void *)v84 - 7) = *(void *)(a2 + 24);
              *(void *)(a2 + 16) = a2 + 32;
              *(_DWORD *)(a2 + 28) = 0;
            }
            _DWORD *v91 = 0;
          }
          *uint64_t v84 = *(_DWORD *)(a2 + 80);
          a2 += 88;
        }
        v84 += 22;
        if (v83 == v85) {
          goto LABEL_216;
        }
      }
      if (v83 != v85)
      {
        unint64_t v121 = 0;
        size_t v122 = v85;
        do
        {
          size_t v123 = &v85[v121 / 8];
          uint64_t v124 = *(uint64_t *)((char *)&v85[v121 / 8] + 5);
          *(void *)&v84[v121 / 4 - 20] = v85[v121 / 8];
          uint64_t v125 = (uint64_t)&v84[v121 / 4 - 20];
          *(void *)(v125 + 5) = v124;
          if ((uint64_t *)v125 != &v85[v121 / 8])
          {
            uint64_t v126 = (void **)&v84[v121 / 4 - 16];
            size_t v127 = (uint64_t *)v123[2];
            if (v123 + 4 == v127)
            {
              size_t v129 = &v85[v121 / 8 + 3];
              uint64_t v128 = *(unsigned int *)v129;
              int v130 = &v84[v121 / 4];
              uint64_t v131 = v84[v121 / 4 - 14];
              if (v131 < v128)
              {
                if (*(v130 - 13) < v128)
                {
                  *(v130 - 14) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v131) {
                  memmove(*v126, v127, 8 * v131);
                }
                else {
                  uint64_t v131 = 0;
                }
                uint64_t v132 = *(unsigned int *)v129;
                if (v131 != v132) {
                  memcpy((char *)*v126 + 8 * v131, (const void *)(v123[2] + 8 * v131), 8 * v132 - 8 * v131);
                }
              }
              else if (v128)
              {
                memmove(*v126, v127, 8 * v128);
              }
              *(v130 - 14) = v128;
            }
            else
            {
              if (&v84[v121 / 4 - 12] != *v126)
              {
                free(*v126);
                size_t v127 = (uint64_t *)v123[2];
              }
              *uint64_t v126 = v127;
              size_t v129 = v122 + 3;
              *(void *)&v84[v121 / 4 - 14] = v85[v121 / 8 + 3];
              v123[2] = (uint64_t)(v123 + 4);
              HIDWORD(v85[v121 / 8 + 3]) = 0;
            }
            *(_DWORD *)size_t v129 = 0;
            unsigned int v43 = a6;
          }
          v84[v121 / 4] = *((_DWORD *)v123 + 20);
          v121 += 88;
          size_t v122 = v123 + 11;
        }
        while ((uint64_t *)v138 != v123);
      }
    }
  }
  else
  {
    if (a2 == a3) {
      return;
    }
    unint64_t v41 = 0;
    uint64_t v42 = 0;
    unsigned int v43 = a6;
    do
    {
      uint64_t v44 = &a6[v41 / 4];
      uint64_t v45 = (_DWORD *)(a2 + v41);
      uint64_t v46 = *(void *)(a2 + v41);
      *(void *)((char *)v44 + 5) = *(void *)(a2 + v41 + 5);
      *(void *)uint64_t v44 = v46;
      uint64_t v47 = &a6[v41 / 4 + 8];
      *(void *)&a6[v41 / 4 + 4] = v47;
      *((void *)v44 + 3) = 0x600000000;
      unsigned int v48 = *(_DWORD *)(a2 + v41 + 24);
      if (v48) {
        BOOL v49 = v45 == v44;
      }
      else {
        BOOL v49 = 1;
      }
      if (!v49)
      {
        uint64_t v50 = (_DWORD *)*((void *)v45 + 2);
        if (v45 + 8 == v50)
        {
          uint64_t v51 = a3;
          if (v48 >= 7) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          memcpy(v47, v50, 8 * *(unsigned int *)(a2 + v41 + 24));
          v44[6] = v48;
          a3 = v51;
        }
        else
        {
          *((void *)v44 + 2) = v50;
          int v52 = *(_DWORD *)(a2 + v41 + 28);
          v44[6] = v48;
          v44[7] = v52;
          *((void *)v45 + 2) = v45 + 8;
          *(_DWORD *)(a2 + v41 + 28) = 0;
        }
        v45[6] = 0;
      }
      v44[20] = v45[20];
      ++v42;
      v41 += 88;
    }
    while (a2 + v41 != a3);
    if (v41)
    {
      unsigned int v63 = &a6[v41 / 4];
      unsigned int v64 = (_DWORD *)(a3 - 8);
      do
      {
        if (a2 == a1)
        {
          if (v63 != a6)
          {
            uint64_t v108 = 0;
            size_t v109 = v63;
            do
            {
              uint64_t v110 = &v63[v108];
              uint64_t v111 = &v64[v108];
              uint64_t v112 = *(void *)&v63[v108 - 22];
              *(void *)((char *)v111 - 75) = *(void *)((char *)&v63[v108 - 20] - 3);
              *((void *)v111 - 10) = v112;
              if (&v64[v108 + 2] != &v63[v108])
              {
                uint64_t v113 = (void **)(v111 - 16);
                uint64_t v114 = (_DWORD *)*((void *)v110 - 9);
                if (v110 - 14 == v114)
                {
                  uint64_t v116 = &v63[v108 - 16];
                  uint64_t v115 = *v116;
                  uint64_t v117 = &v64[v108];
                  uint64_t v118 = v64[v108 - 14];
                  if (v118 < v115)
                  {
                    if (*(v117 - 13) < v115)
                    {
                      *(v117 - 14) = 0;
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    if (v118)
                    {
                      __int16 v141 = (void **)(v111 - 16);
                      memmove(*v113, v114, 8 * v118);
                      uint64_t v113 = v141;
                    }
                    else
                    {
                      uint64_t v118 = 0;
                    }
                    uint64_t v119 = *v116;
                    if (v118 != v119) {
                      memcpy((char *)*v113 + 8 * v118, (const void *)(*((void *)v110 - 9) + 8 * v118), 8 * v119 - 8 * v118);
                    }
                  }
                  else if (v115)
                  {
                    memmove(*v113, v114, 8 * v115);
                  }
                  *(v117 - 14) = v115;
                  unsigned int v43 = a6;
                }
                else
                {
                  if (&v64[v108 - 12] != *v113)
                  {
                    int v120 = (void **)(v111 - 16);
                    free(*v113);
                    uint64_t v113 = v120;
                    uint64_t v114 = (_DWORD *)*((void *)v110 - 9);
                  }
                  *uint64_t v113 = v114;
                  uint64_t v116 = v109 - 16;
                  *(void *)&v64[v108 - 14] = *(void *)&v63[v108 - 16];
                  *((void *)v110 - 9) = v110 - 14;
                  v63[v108 - 15] = 0;
                }
                *uint64_t v116 = 0;
              }
              v109 -= 22;
              v64[v108] = *(v110 - 2);
              v108 -= 22;
            }
            while (&v63[v108] != v43);
          }
          break;
        }
        uint64_t v65 = v64 + 2;
        uint64_t v66 = v64 - 20;
        unsigned int v67 = (void **)(v64 - 16);
        if (*(v63 - 20) <= *(_DWORD *)(a2 - 80))
        {
          uint64_t v75 = v63 - 22;
          uint64_t v74 = *((void *)v63 - 11);
          *(void *)((char *)v64 - 75) = *(void *)((char *)v63 - 83);
          *uint64_t v66 = v74;
          if (v65 == v63)
          {
            uint64_t v73 = (uint64_t)v63;
            goto LABEL_103;
          }
          uint64_t v76 = (_DWORD *)*((void *)v63 - 9);
          if (v76 == v63 - 14)
          {
            uint64_t v77 = *(v63 - 16);
            uint64_t v78 = *(v64 - 14);
            if (v78 < v77)
            {
              if (*(v64 - 13) < v77)
              {
                *(v64 - 14) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v78) {
                memmove(*v67, v76, 8 * v78);
              }
              else {
                uint64_t v78 = 0;
              }
              uint64_t v80 = *(v63 - 16);
              if (v78 != v80) {
                memcpy((char *)*v67 + 8 * v78, (const void *)(*((void *)v63 - 9) + 8 * v78), 8 * v80 - 8 * v78);
              }
            }
            else if (v77)
            {
              memmove(*v67, v76, 8 * v77);
            }
            *(v64 - 14) = v77;
          }
          else
          {
            uint64_t v82 = (_DWORD *)*((void *)v64 - 8);
            if (v64 - 12 != v82)
            {
              free(v82);
              uint64_t v76 = (_DWORD *)*((void *)v63 - 9);
            }
            *((void *)v64 - 8) = v76;
            *((void *)v64 - 7) = *((void *)v63 - 8);
            *((void *)v63 - 9) = v63 - 14;
            *(v63 - 15) = 0;
          }
          uint64_t v73 = (uint64_t)v63;
          uint64_t v69 = a2;
          v63 -= 22;
        }
        else
        {
          uint64_t v69 = a2 - 88;
          uint64_t v68 = *(void *)(a2 - 88);
          *(void *)((char *)v64 - 75) = *(void *)(a2 - 83);
          *uint64_t v66 = v68;
          if (v65 == (_DWORD *)a2)
          {
            uint64_t v73 = a2;
            goto LABEL_102;
          }
          uint64_t v70 = *(const void **)(a2 - 72);
          if (v70 == (const void *)(a2 - 56))
          {
            uint64_t v71 = *(unsigned int *)(a2 - 64);
            uint64_t v72 = *(v64 - 14);
            if (v72 < v71)
            {
              if (*(v64 - 13) < v71)
              {
                *(v64 - 14) = 0;
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v72) {
                memmove(*v67, v70, 8 * v72);
              }
              else {
                uint64_t v72 = 0;
              }
              uint64_t v79 = *(unsigned int *)(a2 - 64);
              if (v72 != v79) {
                memcpy((char *)*v67 + 8 * v72, (const void *)(*(void *)(a2 - 72) + 8 * v72), 8 * v79 - 8 * v72);
              }
            }
            else if (v71)
            {
              memmove(*v67, v70, 8 * v71);
            }
            *(v64 - 14) = v71;
          }
          else
          {
            uint64_t v81 = (_DWORD *)*((void *)v64 - 8);
            if (v64 - 12 != v81)
            {
              free(v81);
              uint64_t v70 = *(const void **)(a2 - 72);
            }
            *((void *)v64 - 8) = v70;
            *((void *)v64 - 7) = *(void *)(a2 - 64);
            *(void *)(a2 - 72) = a2 - 56;
            *(_DWORD *)(a2 - 60) = 0;
          }
          uint64_t v73 = a2;
        }
        *(_DWORD *)(v73 - 64) = 0;
LABEL_102:
        a2 = v69;
        uint64_t v75 = v63;
LABEL_103:
        *unsigned int v64 = *(_DWORD *)(v73 - 8);
        v64 -= 22;
        unsigned int v63 = v75;
      }
      while (v75 != a6);
    }
  }
LABEL_216:
  if (v43 && v42)
  {
    uint64_t v133 = a6 + 8;
    do
    {
      uint64_t v134 = (void *)*(v133 - 2);
      if (v133 != v134) {
        free(v134);
      }
      v133 += 11;
      --v42;
    }
    while (v42);
  }
}

void sub_1CC461568(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 5);
  *(void *)uint64_t v18 = *(void *)a1;
  *(void *)&v18[5] = v4;
  unint64_t v19 = v21;
  unint64_t v20 = 0x600000000;
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if (v5 && v18 != (unsigned char *)a1)
  {
    uint64_t v6 = *(const void **)(a1 + 16);
    if (v6 == (const void *)(a1 + 32))
    {
      if (v5 >= 7) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      memcpy(v21, v6, 8 * v5);
      LODWORD(v20) = v5;
    }
    else
    {
      unint64_t v19 = *(void **)(a1 + 16);
      unint64_t v20 = __PAIR64__(*(_DWORD *)(a1 + 28), v5);
      *(void *)(a1 + 16) = a1 + 32;
      *(_DWORD *)(a1 + 28) = 0;
    }
    LODWORD(v5) = 0;
    *(_DWORD *)(a1 + 24) = 0;
  }
  int v22 = *(_DWORD *)(a1 + 80);
  uint64_t v7 = *(void *)(a2 + 5);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 5) = v7;
  uint64_t v8 = (void **)(a2 + 16);
  if (a1 != a2)
  {
    unsigned int v9 = *(void **)(a2 + 16);
    if (v9 == (void *)(a2 + 32))
    {
      unint64_t v10 = (void **)(a1 + 16);
      uint64_t v12 = (_DWORD *)(a2 + 24);
      uint64_t v11 = *(unsigned int *)(a2 + 24);
      if (v5 < v11)
      {
        if (*(_DWORD *)(a1 + 28) < v11)
        {
          *(_DWORD *)(a1 + 24) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v5)
        {
          uint64_t v5 = v5;
          memmove(*v10, v9, 8 * v5);
          unint64_t v10 = (void **)(a1 + 16);
        }
        else
        {
          uint64_t v5 = 0;
        }
        uint64_t v16 = *v12;
        if (v5 != v16) {
          memcpy((char *)*v10 + 8 * v5, (char *)*v8 + 8 * v5, (unsigned char *)*v8 + 8 * v16 - ((unsigned char *)*v8 + 8 * v5));
        }
      }
      else if (v11)
      {
        memmove(*v10, v9, 8 * v11);
      }
      *(_DWORD *)(a1 + 24) = v11;
    }
    else
    {
      uint64_t v17 = *(void **)(a1 + 16);
      if (v17 != (void *)(a1 + 32))
      {
        free(v17);
        unsigned int v9 = *v8;
      }
      *(void *)(a1 + 16) = v9;
      uint64_t v12 = (_DWORD *)(a2 + 24);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(void *)(a2 + 16) = a2 + 32;
      *(_DWORD *)(a2 + 28) = 0;
    }
    *uint64_t v12 = 0;
  }
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(void *)a2 = *(void *)v18;
  *(void *)(a2 + 5) = *(void *)&v18[5];
  uint64_t v13 = v19;
  if (v18 != (unsigned char *)a2)
  {
    if (v19 == v21)
    {
      int v14 = v20;
      uint64_t v15 = *(unsigned int *)(a2 + 24);
      if (v15 < v20)
      {
        if (*(_DWORD *)(a2 + 28) < v20)
        {
          *(_DWORD *)(a2 + 24) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v15) {
          memmove(*v8, v21, 8 * v15);
        }
        else {
          uint64_t v15 = 0;
        }
        if (v15 != v20) {
          memcpy((char *)*v8 + 8 * v15, (char *)v19 + 8 * v15, 8 * v20 - 8 * v15);
        }
      }
      else if (v20)
      {
        memmove(*v8, v21, 8 * v20);
      }
      *(_DWORD *)(a2 + 24) = v14;
    }
    else
    {
      if (*(void *)(a2 + 16) != a2 + 32)
      {
        free(*(void **)(a2 + 16));
        uint64_t v13 = v19;
      }
      *(void *)(a2 + 16) = v13;
      *(void *)(a2 + 24) = v20;
      unint64_t v19 = v21;
      HIDWORD(v20) = 0;
    }
    LODWORD(v20) = 0;
    uint64_t v13 = v19;
  }
  *(_DWORD *)(a2 + 80) = v22;
  if (v13 != v21) {
    free(v13);
  }
}

uint64_t sub_1CC4618B8()
{
  v4.n128_u64[0] = (unint64_t)"enable safe stack layout";
  v4.n128_u64[1] = 24;
  int v3 = 1;
  char v1 = 1;
  uint64_t v2 = &v1;
  sub_1CD4BCE90((llvm::cl::Option *)&unk_1EBCD36C0, "safe-stack-layout", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD36C0, &dword_1CB82C000);
}

llvm::ScheduleDAG *llvm::ScheduleDAG::ScheduleDAG(llvm::ScheduleDAG *this, llvm::MachineFunction *a2)
{
  uint64_t v4 = *((void *)a2 + 1);
  *(void *)this = &unk_1F2612C08;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 104))(*((void *)a2 + 2));
  *((void *)this + 3) = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  *((void *)this + 4) = a2;
  *((void *)this + 5) = *((void *)a2 + 5);
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = (char *)this + 120;
  *((void *)this + 14) = 0x400000000;
  *((void *)this + 23) = (char *)this + 200;
  *((void *)this + 24) = 0x400000000;
  *((_DWORD *)this + 66) = -1;
  *((_DWORD *)this + 76) = 0;
  *((_WORD *)this + 150) = 0;
  *(_OWORD *)((char *)this + 284) = 0u;
  *(_OWORD *)((char *)this + 268) = 0u;
  *((unsigned char *)this + 308) &= 0xFCu;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((void *)this + 47) = (char *)this + 392;
  *((void *)this + 48) = 0x400000000;
  *((void *)this + 57) = (char *)this + 472;
  *((void *)this + 58) = 0x400000000;
  *((_DWORD *)this + 134) = -1;
  *((_DWORD *)this + 144) = 0;
  *(_OWORD *)((char *)this + 540) = 0u;
  *(_OWORD *)((char *)this + 556) = 0u;
  *((_WORD *)this + 286) = 0;
  *((unsigned char *)this + 580) &= 0xFCu;
  *(_OWORD *)((char *)this + 584) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  return this;
}

void llvm::ScheduleDAG::~ScheduleDAG(llvm::ScheduleDAG *this)
{
  *(void *)this = &unk_1F2612C08;
  uint64_t v2 = (char *)*((void *)this + 57);
  if (v2 != (char *)this + 472) {
    free(v2);
  }
  int v3 = (char *)*((void *)this + 47);
  if (v3 != (char *)this + 392) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 23);
  if (v4 != (char *)this + 200) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 13);
  if (v5 != (char *)this + 120) {
    free(v5);
  }
  uint64_t v6 = *((void *)this + 6);
  if (v6)
  {
    sub_1CC463D08((uint64_t)this + 48, v6);
    operator delete(*((void **)this + 6));
  }
}

__n128 llvm::ScheduleDAG::clearDAG(llvm::ScheduleDAG *this)
{
  char v1 = this;
  sub_1CC463D08((uint64_t)this + 48, *((void *)this + 6));
  memset(&v3[3], 0, 32);
  *(_OWORD *)((char *)v1 + 72) = 0u;
  char v1 = (llvm::ScheduleDAG *)((char *)v1 + 72);
  *(_OWORD *)((char *)v1 + 237) = *(_OWORD *)v3;
  *((_OWORD *)v1 + 1) = 0u;
  *((_DWORD *)v1 + 10) = 0;
  *((_DWORD *)v1 + 30) = 0;
  *((_DWORD *)v1 + 48) = -1;
  *(_OWORD *)((char *)v1 + 196) = 0u;
  *(_OWORD *)((char *)v1 + 212) = 0u;
  *((_WORD *)v1 + 114) = 0;
  *((_DWORD *)v1 + 58) = 0;
  *((unsigned char *)v1 + 236) = 0;
  *(_OWORD *)((char *)v1 + 253) = *(_OWORD *)&v3[16];
  *((_DWORD *)v1 + 67) = 0;
  memset(&v3[3], 0, 32);
  *((_OWORD *)v1 + 17) = 0u;
  *((_OWORD *)v1 + 18) = 0u;
  *((_DWORD *)v1 + 78) = 0;
  *((_DWORD *)v1 + 98) = 0;
  *((_DWORD *)v1 + 116) = -1;
  *(_OWORD *)((char *)v1 + 468) = 0u;
  *(_OWORD *)((char *)v1 + 484) = 0u;
  *((_WORD *)v1 + 250) = 0;
  *((_DWORD *)v1 + 126) = 0;
  *((unsigned char *)v1 + 508) = 0;
  __n128 result = *(__n128 *)v3;
  *(_OWORD *)((char *)v1 + 509) = *(_OWORD *)v3;
  *(_OWORD *)((char *)v1 + 525) = *(_OWORD *)&v3[16];
  *((_DWORD *)v1 + 135) = 0;
  return result;
}

uint64_t llvm::SUnit::addPred(uint64_t a1, uint64_t *a2, char a3)
{
  v40[8] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(unsigned int *)(a1 + 40);
  uint64_t v5 = *a2;
  unint64_t v6 = *a2 & 0xFFFFFFFFFFFFFFF8;
  if (v4)
  {
    int v7 = *((_DWORD *)a2 + 2);
    uint64_t v8 = (unsigned int *)(v3 + 12);
    uint64_t v9 = 16 * v4;
    while (1)
    {
      uint64_t v10 = *(void *)(v8 - 3);
      if ((a3 & 1) == 0 && (v10 & 0xFFFFFFFFFFFFFFF8) == v6) {
        return 0;
      }
      if (v10 == v5 && *(v8 - 1) == v7) {
        break;
      }
      v8 += 4;
      v9 -= 16;
      if (!v9) {
        goto LABEL_6;
      }
    }
    unsigned int v28 = *((_DWORD *)a2 + 3);
    if (*v8 >= v28) {
      return 0;
    }
    uint64_t v29 = *(unsigned int *)(v6 + 120);
    if (v29)
    {
      uint64_t v30 = (unsigned int *)(*(void *)(v6 + 112) + 12);
      uint64_t v31 = 16 * v29;
      while (*(void *)(v30 - 3) != (*a2 & 7 | a1) || *(v30 - 1) != v7 || *v30 != *v8)
      {
        v30 += 4;
        v31 -= 16;
        if (!v31) {
          goto LABEL_52;
        }
      }
      *uint64_t v30 = v28;
      unsigned int v28 = *((_DWORD *)a2 + 3);
    }
LABEL_52:
    uint64_t result = 0;
    unsigned int *v8 = v28;
  }
  else
  {
LABEL_6:
    unint64_t v11 = a2[1];
    uint64_t v12 = *a2 & 6;
    if ((v5 & 6) == 0)
    {
      ++*(_DWORD *)(a1 + 200);
      ++*(_DWORD *)(v6 + 204);
    }
    if ((*(_WORD *)(v6 + 228) & 0x400) == 0)
    {
      BOOL v13 = v12 == 6 && *((_DWORD *)a2 + 2) >= 4u;
      int v14 = (_DWORD *)(a1 + 208);
      if (v13) {
        int v14 = (_DWORD *)(a1 + 216);
      }
      ++*v14;
    }
    if ((*(_WORD *)(a1 + 228) & 0x400) == 0)
    {
      BOOL v15 = v12 == 6 && *((_DWORD *)a2 + 2) >= 4u;
      uint64_t v16 = (_DWORD *)(v6 + 212);
      if (v15) {
        uint64_t v16 = (_DWORD *)(v6 + 220);
      }
      ++*v16;
    }
    uint64_t v17 = a2[1];
    if (v4 >= *(_DWORD *)(a1 + 44)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v18 = (void *)(v3 + 16 * v4);
    *uint64_t v18 = v5;
    v18[1] = v17;
    ++*(_DWORD *)(a1 + 40);
    unsigned int v19 = *(_DWORD *)(v6 + 120);
    if (v19 >= *(_DWORD *)(v6 + 124)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unint64_t v20 = (uint64_t *)(*(void *)(v6 + 112) + 16 * v19);
    *unint64_t v20 = v5 & 7 | a1;
    v20[1] = v11;
    ++*(_DWORD *)(v6 + 120);
    if (HIDWORD(v11))
    {
      if (*(unsigned char *)(a1 + 236))
      {
        unsigned int v39 = 8;
        v40[0] = a1;
        unsigned int v32 = 1;
        do
        {
          uint64_t v33 = v40[--v32];
          unsigned int v38 = v32;
          *(unsigned char *)(v33 + 236) &= ~1u;
          uint64_t v34 = *(unsigned int *)(v33 + 120);
          if (v34)
          {
            uint64_t v35 = *(void **)(v33 + 112);
            uint64_t v36 = 16 * v34;
            do
            {
              unint64_t v37 = *v35 & 0xFFFFFFFFFFFFFFF8;
              if (*(unsigned char *)(v37 + 236))
              {
                if (v32 >= v39) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v40[v32] = v37;
                unsigned int v32 = ++v38;
              }
              v35 += 2;
              v36 -= 16;
            }
            while (v36);
          }
        }
        while (v32);
      }
      if ((*(unsigned char *)(v6 + 236) & 2) != 0)
      {
        unsigned int v39 = 8;
        v40[0] = v6;
        unsigned int v22 = 1;
        do
        {
          uint64_t v23 = v40[--v22];
          unsigned int v38 = v22;
          *(unsigned char *)(v23 + 236) &= ~2u;
          uint64_t v24 = *(unsigned int *)(v23 + 40);
          if (v24)
          {
            uint64_t v25 = *(void **)(v23 + 32);
            uint64_t v26 = 16 * v24;
            do
            {
              unint64_t v27 = *v25 & 0xFFFFFFFFFFFFFFF8;
              if ((*(unsigned char *)(v27 + 236) & 2) != 0)
              {
                if (v22 >= v39) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v40[v22] = v27;
                unsigned int v22 = ++v38;
              }
              v25 += 2;
              v26 -= 16;
            }
            while (v26);
          }
        }
        while (v22);
      }
    }
    return 1;
  }
  return result;
}

void llvm::SUnit::setDepthDirty(llvm::SUnit *this)
{
  v9[8] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 236))
  {
    unsigned int v8 = 8;
    v9[0] = this;
    unsigned int v1 = 1;
    do
    {
      uint64_t v2 = v9[--v1];
      unsigned int v7 = v1;
      *(unsigned char *)(v2 + 236) &= ~1u;
      uint64_t v3 = *(unsigned int *)(v2 + 120);
      if (v3)
      {
        uint64_t v4 = *(void **)(v2 + 112);
        uint64_t v5 = 16 * v3;
        do
        {
          unint64_t v6 = *v4 & 0xFFFFFFFFFFFFFFF8;
          if (*(unsigned char *)(v6 + 236))
          {
            if (v1 >= v8) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v9[v1] = v6;
            unsigned int v1 = ++v7;
          }
          v4 += 2;
          v5 -= 16;
        }
        while (v5);
      }
    }
    while (v1);
  }
}

void llvm::SUnit::setHeightDirty(llvm::SUnit *this)
{
  v9[8] = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 236) & 2) != 0)
  {
    unsigned int v8 = 8;
    v9[0] = this;
    unsigned int v1 = 1;
    do
    {
      uint64_t v2 = v9[--v1];
      unsigned int v7 = v1;
      *(unsigned char *)(v2 + 236) &= ~2u;
      uint64_t v3 = *(unsigned int *)(v2 + 40);
      if (v3)
      {
        uint64_t v4 = *(void **)(v2 + 32);
        uint64_t v5 = 16 * v3;
        do
        {
          unint64_t v6 = *v4 & 0xFFFFFFFFFFFFFFF8;
          if ((*(unsigned char *)(v6 + 236) & 2) != 0)
          {
            if (v1 >= v8) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v9[v1] = v6;
            unsigned int v1 = ++v7;
          }
          v4 += 2;
          v5 -= 16;
        }
        while (v5);
      }
    }
    while (v1);
  }
}

void llvm::SUnit::removePred(uint64_t a1, uint64_t a2)
{
  v33[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned int *)(a1 + 40);
  uint64_t v6 = v4;
  if (v5)
  {
    uint64_t v7 = 16 * v5;
    uint64_t v6 = *(void *)(a1 + 32);
    while (*(void *)v6 != *(void *)a2
         || *(_DWORD *)(v6 + 8) != *(_DWORD *)(a2 + 8)
         || *(_DWORD *)(v6 + 12) != *(_DWORD *)(a2 + 12))
    {
      v6 += 16;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v6 = v4 + 16 * v5;
        break;
      }
    }
  }
  if (v5 != (v6 - v4) >> 4)
  {
    int v8 = *(_DWORD *)(a2 + 12);
    uint64_t v9 = *(void *)a2 & 7 | a1;
    unint64_t v10 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v11 = *(void *)(v10 + 112);
    uint64_t v12 = *(unsigned int *)(v10 + 120);
    uint64_t v13 = v11 + 16 * v12;
    if (v12)
    {
      uint64_t v14 = 16 * v12;
      while (*(void *)v11 != v9 || *(_DWORD *)(v11 + 8) != *(_DWORD *)(a2 + 8) || *(_DWORD *)(v11 + 12) != v8)
      {
        v11 += 16;
        v14 -= 16;
        if (!v14)
        {
          uint64_t v11 = v13;
          break;
        }
      }
    }
    if (v13 != v11 + 16)
    {
      memmove((void *)v11, (const void *)(v11 + 16), v13 - (v11 + 16));
      LODWORD(v12) = *(_DWORD *)(v10 + 120);
      uint64_t v4 = *(void *)(a1 + 32);
    }
    *(_DWORD *)(v10 + 120) = v12 - 1;
    uint64_t v15 = *(unsigned int *)(a1 + 40);
    uint64_t v16 = v4 + 16 * v15;
    if (v16 != v6 + 16)
    {
      memmove((void *)v6, (const void *)(v6 + 16), v16 - (v6 + 16));
      LODWORD(v15) = *(_DWORD *)(a1 + 40);
    }
    *(_DWORD *)(a1 + 40) = v15 - 1;
    if ((v9 & 6) == 0)
    {
      --*(_DWORD *)(a1 + 200);
      --*(_DWORD *)(v10 + 204);
    }
    if ((*(_WORD *)(v10 + 228) & 0x400) == 0)
    {
      if ((~*(_DWORD *)a2 & 6) != 0 || *(_DWORD *)(a2 + 8) < 4u) {
        uint64_t v17 = (_DWORD *)(a1 + 208);
      }
      else {
        uint64_t v17 = (_DWORD *)(a1 + 216);
      }
      --*v17;
    }
    if ((*(_WORD *)(a1 + 228) & 0x400) == 0)
    {
      if ((~*(_DWORD *)a2 & 6) != 0 || *(_DWORD *)(a2 + 8) < 4u) {
        uint64_t v18 = (_DWORD *)(v10 + 212);
      }
      else {
        uint64_t v18 = (_DWORD *)(v10 + 220);
      }
      --*v18;
    }
    if (v8)
    {
      if (*(unsigned char *)(a1 + 236))
      {
        unsigned int v32 = 8;
        v33[0] = a1;
        unsigned int v25 = 1;
        do
        {
          uint64_t v26 = v33[--v25];
          unsigned int v31 = v25;
          *(unsigned char *)(v26 + 236) &= ~1u;
          uint64_t v27 = *(unsigned int *)(v26 + 120);
          if (v27)
          {
            unsigned int v28 = *(void **)(v26 + 112);
            uint64_t v29 = 16 * v27;
            do
            {
              unint64_t v30 = *v28 & 0xFFFFFFFFFFFFFFF8;
              if (*(unsigned char *)(v30 + 236))
              {
                if (v25 >= v32) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v33[v25] = v30;
                unsigned int v25 = ++v31;
              }
              v28 += 2;
              v29 -= 16;
            }
            while (v29);
          }
        }
        while (v25);
      }
      if ((*(unsigned char *)(v10 + 236) & 2) != 0)
      {
        unsigned int v32 = 8;
        v33[0] = v10;
        unsigned int v19 = 1;
        do
        {
          uint64_t v20 = v33[--v19];
          unsigned int v31 = v19;
          *(unsigned char *)(v20 + 236) &= ~2u;
          uint64_t v21 = *(unsigned int *)(v20 + 40);
          if (v21)
          {
            unsigned int v22 = *(void **)(v20 + 32);
            uint64_t v23 = 16 * v21;
            do
            {
              unint64_t v24 = *v22 & 0xFFFFFFFFFFFFFFF8;
              if ((*(unsigned char *)(v24 + 236) & 2) != 0)
              {
                if (v19 >= v32) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v33[v19] = v24;
                unsigned int v19 = ++v31;
              }
              v22 += 2;
              v23 -= 16;
            }
            while (v23);
          }
        }
        while (v19);
      }
    }
  }
}

void llvm::SUnit::ComputeDepth(llvm::SUnit *this)
{
  v21[8] = *MEMORY[0x1E4F143B8];
  v17[0] = this;
  uint64_t v16 = 0x800000001;
  unsigned int v1 = 1;
  while (2)
  {
    while (1)
    {
      uint64_t v2 = v17[v1 - 1];
      uint64_t v3 = *(unsigned int *)(v2 + 40);
      if (v3) {
        break;
      }
      unsigned int v4 = 0;
LABEL_15:
      LODWORD(v16) = --v1;
      if (v4 != *(_DWORD *)(v2 + 240))
      {
        if (*(unsigned char *)(v2 + 236))
        {
          uint64_t v18 = v21;
          unsigned int v20 = 8;
          v21[0] = v2;
          unsigned int v10 = 1;
          do
          {
            uint64_t v11 = *((void *)v18 + --v10);
            unsigned int v19 = v10;
            *(unsigned char *)(v11 + 236) &= ~1u;
            uint64_t v12 = *(unsigned int *)(v11 + 120);
            if (v12)
            {
              uint64_t v13 = *(void **)(v11 + 112);
              uint64_t v14 = 16 * v12;
              do
              {
                unint64_t v15 = *v13 & 0xFFFFFFFFFFFFFFF8;
                if (*(unsigned char *)(v15 + 236))
                {
                  if (v10 >= v20) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v18 + v10) = v15;
                  unsigned int v10 = ++v19;
                }
                v13 += 2;
                v14 -= 16;
              }
              while (v14);
            }
          }
          while (v10);
          if (v18 != v21) {
            free(v18);
          }
          unsigned int v1 = v16;
        }
        *(_DWORD *)(v2 + 240) = v4;
      }
      *(unsigned char *)(v2 + 236) |= 1u;
      if (!v1) {
        return;
      }
    }
    unsigned int v4 = 0;
    uint64_t v5 = *(void *)(v2 + 32);
    uint64_t v6 = v5 + 16 * v3;
    char v7 = 1;
    while (2)
    {
      v5 += 16;
      while (1)
      {
        uint64_t v8 = v5 - 16;
        unint64_t v9 = *(void *)(v5 - 16) & 0xFFFFFFFFFFFFFFF8;
        if ((*(unsigned char *)(v9 + 236) & 1) == 0) {
          break;
        }
        if (v4 <= *(_DWORD *)(v5 - 4) + *(_DWORD *)(v9 + 240)) {
          unsigned int v4 = *(_DWORD *)(v5 - 4) + *(_DWORD *)(v9 + 240);
        }
        v5 += 16;
        if (v8 + 16 == v6)
        {
          if (v7) {
            goto LABEL_15;
          }
          goto LABEL_12;
        }
      }
      if (v1 >= HIDWORD(v16)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      char v7 = 0;
      v17[v1] = v9;
      unsigned int v1 = v16 + 1;
      LODWORD(v16) = v16 + 1;
      if (v5 != v6) {
        continue;
      }
      break;
    }
LABEL_12:
    if (v1) {
      continue;
    }
    break;
  }
}

void llvm::SUnit::ComputeHeight(llvm::SUnit *this)
{
  v23[8] = *MEMORY[0x1E4F143B8];
  v19[0] = this;
  uint64_t v18 = 0x800000001;
  unsigned int v1 = 1;
  do
  {
    uint64_t v2 = v19[v1 - 1];
    uint64_t v3 = *(unsigned int *)(v2 + 120);
    if (v3)
    {
      unsigned int v4 = 0;
      uint64_t v5 = *(void *)(v2 + 112);
      uint64_t v6 = v5 + 16 * v3;
      char v7 = 1;
      while (2)
      {
        v5 += 16;
        while (1)
        {
          uint64_t v8 = v5 - 16;
          unint64_t v9 = *(void *)(v5 - 16) & 0xFFFFFFFFFFFFFFF8;
          if ((*(unsigned char *)(v9 + 236) & 2) == 0) {
            break;
          }
          if (v4 <= *(_DWORD *)(v5 - 4) + *(_DWORD *)(v9 + 244)) {
            unsigned int v4 = *(_DWORD *)(v5 - 4) + *(_DWORD *)(v9 + 244);
          }
          v5 += 16;
          if (v8 + 16 == v6)
          {
            if ((v7 & 1) == 0) {
              goto LABEL_14;
            }
            goto LABEL_10;
          }
        }
        if (v1 >= HIDWORD(v18)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        char v7 = 0;
        v19[v1] = v9;
        unsigned int v1 = v18 + 1;
        LODWORD(v18) = v18 + 1;
        if (v5 != v6) {
          continue;
        }
        break;
      }
    }
    else
    {
      unsigned int v4 = 0;
LABEL_10:
      LODWORD(v18) = --v1;
      if (v4 != *(_DWORD *)(v2 + 244))
      {
        if ((*(unsigned char *)(v2 + 236) & 2) != 0)
        {
          unsigned int v17 = v4;
          uint64_t v16 = v2;
          unsigned int v20 = v23;
          unsigned int v22 = 8;
          v23[0] = v2;
          unsigned int v10 = 1;
          do
          {
            uint64_t v11 = *((void *)v20 + --v10);
            unsigned int v21 = v10;
            *(unsigned char *)(v11 + 236) &= ~2u;
            uint64_t v12 = *(unsigned int *)(v11 + 40);
            if (v12)
            {
              uint64_t v13 = *(void **)(v11 + 32);
              uint64_t v14 = 16 * v12;
              do
              {
                unint64_t v15 = *v13 & 0xFFFFFFFFFFFFFFF8;
                if ((*(unsigned char *)(v15 + 236) & 2) != 0)
                {
                  if (v10 >= v22) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v20 + v10) = v15;
                  unsigned int v10 = ++v21;
                }
                v13 += 2;
                v14 -= 16;
              }
              while (v14);
            }
          }
          while (v10);
          if (v20 != v23) {
            free(v20);
          }
          unsigned int v1 = v18;
          uint64_t v2 = v16;
          unsigned int v4 = v17;
        }
        *(_DWORD *)(v2 + 244) = v4;
      }
      *(unsigned char *)(v2 + 236) |= 2u;
    }
LABEL_14:
    ;
  }
  while (v1);
}

__n128 llvm::SUnit::biasCriticalPath(llvm::SUnit *this)
{
  if (*((_DWORD *)this + 50) >= 2u)
  {
    uint64_t v2 = (__n128 *)*((void *)this + 4);
    unint64_t v3 = v2->n128_u64[0] & 0xFFFFFFFFFFFFFFF8;
    unsigned int v4 = v2;
    if ((*(unsigned char *)(v3 + 236) & 1) == 0)
    {
      llvm::SUnit::ComputeDepth((llvm::SUnit *)(v2->n128_u64[0] & 0xFFFFFFFFFFFFFFF8));
      unsigned int v4 = (__n128 *)*((void *)this + 4);
    }
    uint64_t v6 = &v4[*((unsigned int *)this + 10)];
    char v7 = v2 + 1;
    if (&v2[1] != v6)
    {
      unsigned int v8 = *(_DWORD *)(v3 + 240);
      do
      {
        unint64_t v9 = v7->n128_u64[0];
        if ((v7->n128_u64[0] & 6) == 0)
        {
          unsigned int v10 = (llvm::SUnit *)(v9 & 0xFFFFFFFFFFFFFFF8);
          if ((*(unsigned char *)((v9 & 0xFFFFFFFFFFFFFFF8) + 236) & 1) == 0) {
            llvm::SUnit::ComputeDepth(v10);
          }
          if (*((_DWORD *)v10 + 60) > v8) {
            uint64_t v2 = v7;
          }
        }
        ++v7;
      }
      while (v7 != v6);
      unsigned int v4 = (__n128 *)*((void *)this + 4);
    }
    if (v2 != v4)
    {
      __n128 v11 = *v4;
      *unsigned int v4 = *v2;
      __n128 result = v11;
      *uint64_t v2 = v11;
    }
  }
  return result;
}

void llvm::ScheduleDAGTopologicalSort::InitDAGTopologicalSorting(uint64_t **this)
{
  *((unsigned char *)this + 16) = 0;
  *((_DWORD *)this + 8) = 0;
  unsigned int v2 = -252645135 * (((*this)[1] - **this) >> 4);
  std::string __p = 0;
  uint64_t v61 = 0;
  int v62 = 0;
  sub_1CBF7ACFC((uint64_t)&__p, v2);
  unint64_t v3 = this[37];
  unint64_t v4 = ((char *)this[38] - (char *)v3) >> 2;
  BOOL v59 = this + 37;
  if (v2 <= v4)
  {
    if (v2 < v4) {
      this[38] = (uint64_t *)((char *)v3 + 4 * v2);
    }
  }
  else
  {
    sub_1CC3C0DF8((char **)this + 37, v2 - v4);
  }
  uint64_t v5 = this + 40;
  uint64_t v6 = this[40];
  unint64_t v7 = ((char *)this[41] - (char *)v6) >> 2;
  if (v2 <= v7)
  {
    if (v2 < v7) {
      this[41] = (uint64_t *)((char *)v6 + 4 * v2);
    }
  }
  else
  {
    sub_1CC3C0DF8((char **)this + 40, v2 - v7);
  }
  unsigned int v8 = this[1];
  if (v8)
  {
    unint64_t v9 = v61;
    if (v61 >= v62)
    {
      __n128 v11 = (char *)__p;
      uint64_t v12 = (v61 - (unsigned char *)__p) >> 3;
      unint64_t v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 61) {
LABEL_91:
      }
        abort();
      uint64_t v14 = v62 - (unsigned char *)__p;
      if ((v62 - (unsigned char *)__p) >> 2 > v13) {
        unint64_t v13 = v14 >> 2;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15)
      {
        if (v15 >> 61) {
LABEL_92:
        }
          sub_1CB833614();
        uint64_t v16 = (char *)operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      unsigned int v17 = &v16[8 * v12];
      *(void *)unsigned int v17 = v8;
      unsigned int v10 = v17 + 8;
      if (v9 != v11)
      {
        do
        {
          uint64_t v18 = *((void *)v9 - 1);
          v9 -= 8;
          *((void *)v17 - 1) = v18;
          v17 -= 8;
        }
        while (v9 != v11);
        unint64_t v9 = (char *)__p;
      }
      std::string __p = v17;
      uint64_t v61 = v10;
      int v62 = &v16[8 * v15];
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *(void *)uint64_t v61 = v8;
      unsigned int v10 = v9 + 8;
    }
    uint64_t v61 = v10;
  }
  unsigned int v58 = (llvm::ScheduleDAGTopologicalSort *)this;
  uint64_t v19 = **this;
  for (uint64_t i = (*this)[1]; v19 != i; v19 += 272)
  {
    int v21 = *(_DWORD *)(v19 + 120);
    *(_DWORD *)(*v5 + 4 * *(int *)(v19 + 192)) = v21;
    if (!v21)
    {
      unsigned int v22 = v61;
      if (v61 >= v62)
      {
        unint64_t v24 = (char *)__p;
        uint64_t v25 = (v61 - (unsigned char *)__p) >> 3;
        unint64_t v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 61) {
          goto LABEL_91;
        }
        uint64_t v27 = v62 - (unsigned char *)__p;
        if ((v62 - (unsigned char *)__p) >> 2 > v26) {
          unint64_t v26 = v27 >> 2;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28)
        {
          if (v28 >> 61) {
            goto LABEL_92;
          }
          uint64_t v29 = (char *)operator new(8 * v28);
        }
        else
        {
          uint64_t v29 = 0;
        }
        unint64_t v30 = &v29[8 * v25];
        *(void *)unint64_t v30 = v19;
        uint64_t v23 = v30 + 8;
        if (v22 != v24)
        {
          do
          {
            uint64_t v31 = *((void *)v22 - 1);
            v22 -= 8;
            *((void *)v30 - 1) = v31;
            v30 -= 8;
          }
          while (v22 != v24);
          unsigned int v22 = (char *)__p;
        }
        std::string __p = v30;
        uint64_t v61 = v23;
        int v62 = &v29[8 * v28];
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        *(void *)uint64_t v61 = v19;
        uint64_t v23 = v22 + 8;
      }
      uint64_t v61 = v23;
    }
  }
  unsigned int v32 = v61;
  if (__p != v61)
  {
    signed int v33 = v2;
    do
    {
      uint64_t v35 = *((void *)v32 - 1);
      v32 -= 8;
      uint64_t v34 = v35;
      uint64_t v61 = v32;
      unsigned int v36 = *(_DWORD *)(v35 + 192);
      if (v36 < v2)
      {
        *(_DWORD *)(*v5 + 4 * (int)v36) = --v33;
        *(_DWORD *)(*v59 + 4 * v33) = v36;
      }
      uint64_t v37 = *(unsigned int *)(v34 + 40);
      if (v37)
      {
        unsigned int v38 = *(void **)(v34 + 32);
        unsigned int v39 = &v38[2 * v37];
        do
        {
          unint64_t v40 = *v38 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v41 = *(unsigned int *)(v40 + 192);
          if (v41 < v2)
          {
            int v42 = *(_DWORD *)(*v5 + 4 * v41) - 1;
            *(_DWORD *)(*v5 + 4 * v41) = v42;
            if (!v42)
            {
              if (v32 >= v62)
              {
                uint64_t v44 = (char *)__p;
                uint64_t v45 = (v32 - (unsigned char *)__p) >> 3;
                unint64_t v46 = v45 + 1;
                if ((unint64_t)(v45 + 1) >> 61) {
                  goto LABEL_91;
                }
                uint64_t v47 = v62 - (unsigned char *)__p;
                if ((v62 - (unsigned char *)__p) >> 2 > v46) {
                  unint64_t v46 = v47 >> 2;
                }
                if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v48 = v46;
                }
                if (v48)
                {
                  if (v48 >> 61) {
                    goto LABEL_92;
                  }
                  BOOL v49 = (char *)operator new(8 * v48);
                }
                else
                {
                  BOOL v49 = 0;
                }
                uint64_t v50 = (unint64_t *)&v49[8 * v45];
                *uint64_t v50 = v40;
                unsigned int v43 = (char *)(v50 + 1);
                if (v32 != v44)
                {
                  do
                  {
                    unint64_t v51 = *((void *)v32 - 1);
                    v32 -= 8;
                    *--uint64_t v50 = v51;
                  }
                  while (v32 != v44);
                  unsigned int v32 = (char *)__p;
                }
                std::string __p = v50;
                uint64_t v61 = v43;
                int v62 = &v49[8 * v48];
                if (v32) {
                  operator delete(v32);
                }
              }
              else
              {
                *(void *)unsigned int v32 = v40;
                unsigned int v43 = v32 + 8;
              }
              uint64_t v61 = v43;
              unsigned int v32 = v43;
            }
          }
          v38 += 2;
        }
        while (v38 != v39);
      }
    }
    while (__p != v32);
  }
  uint64_t v52 = *((unsigned int *)v58 + 88);
  if ((*((_DWORD *)v58 + 102) & 0x3F) != 0)
  {
    uint64_t v57 = *((void *)v58 + 43) + 8 * v52;
    *(void *)(v57 - 8) &= ~(-1 << (*((_DWORD *)v58 + 102) & 0x3F));
  }
  unsigned int v53 = v52;
  uint64_t v54 = (void *)((char *)v58 + 344);
  *((_DWORD *)v58 + 102) = v2;
  unsigned int v55 = v2 + 63;
  if (v52 != (v2 + 63) >> 6)
  {
    uint64_t v56 = v55 >> 6;
    if (v52 > v56)
    {
      *((_DWORD *)v58 + 88) = v56;
      unsigned int v53 = v55 >> 6;
    }
    else
    {
      if (v56 > *((_DWORD *)v58 + 89)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v56 != v52) {
        bzero((void *)(*v54 + 8 * v52), 8 * (v56 - v52));
      }
      unsigned int v53 = v56;
      *((_DWORD *)v58 + 88) = v56;
      unsigned int v2 = *((_DWORD *)v58 + 102);
    }
  }
  if ((v2 & 0x3F) != 0) {
    *(void *)(*v54 + 8 * v53 - 8) &= ~(-1 << (v2 & 0x3F));
  }
  if (__p)
  {
    uint64_t v61 = (char *)__p;
    operator delete(__p);
  }
}

uint64_t llvm::ScheduleDAGTopologicalSort::Allocate(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(*(void *)(this + 320) + 4 * a2) = a3;
  *(_DWORD *)(*(void *)(this + 296) + 4 * a3) = a2;
  return this;
}

void llvm::ScheduleDAGTopologicalSort::FixOrder(uint64_t **this)
{
  if (*((unsigned char *)this + 16))
  {
    llvm::ScheduleDAGTopologicalSort::InitDAGTopologicalSorting(this);
  }
  else
  {
    uint64_t v1 = *((unsigned int *)this + 8);
    if (v1)
    {
      unsigned int v2 = (llvm::SUnit **)this[3];
      unint64_t v3 = &v2[2 * v1];
      do
      {
        uint64_t v6 = (llvm::ScheduleDAGTopologicalSort *)this;
        unint64_t v4 = *v2;
        uint64_t v5 = v2[1];
        v2 += 2;
        llvm::ScheduleDAGTopologicalSort::AddPred((llvm::ScheduleDAGTopologicalSort *)this, v4, v5);
        this = (uint64_t **)v6;
      }
      while (v2 != v3);
    }
    *((_DWORD *)this + 8) = 0;
  }
}

uint64_t llvm::ScheduleDAGTopologicalSort::AddPredQueued(uint64_t this, llvm::SUnit *a2, llvm::SUnit *a3)
{
  unint64_t v4 = a3;
  uint64_t v5 = a2;
  if (*(unsigned char *)(this + 16))
  {
    *(unsigned char *)(this + 16) = 1;
  }
  else
  {
    unsigned int v3 = *(_DWORD *)(this + 32);
    *(unsigned char *)(this + 16) = v3 > 0xA;
    if (v3 <= 0xA) {
      return sub_1CBAF10A8(this + 24, &v5, (uint64_t *)&v4);
    }
  }
  return this;
}

void llvm::ScheduleDAGTopologicalSort::DFS(void *a1, unint64_t a2, int a3, unsigned char *a4)
{
  uint64_t v41 = 0;
  int v42 = 0;
  unsigned int v43 = 0;
  sub_1CBF7ACFC((uint64_t)&v41, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(*a1 + 8) - *(void *)*a1) >> 4));
  unsigned int v8 = v42;
  unint64_t v40 = a4;
  if (v42 >= v43)
  {
    unsigned int v10 = v41;
    uint64_t v11 = v42 - v41;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
LABEL_54:
    }
      abort();
    uint64_t v13 = (char *)v43 - (char *)v41;
    if (((char *)v43 - (char *)v41) >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 61) {
LABEL_55:
      }
        sub_1CB833614();
      unint64_t v15 = (char *)operator new(8 * v14);
    }
    else
    {
      unint64_t v15 = 0;
    }
    uint64_t v16 = (unint64_t *)&v15[8 * v11];
    unsigned int v17 = &v15[8 * v14];
    unint64_t *v16 = a2;
    unint64_t v9 = v16 + 1;
    if (v8 != v10)
    {
      do
      {
        unint64_t v18 = *--v8;
        *--uint64_t v16 = v18;
      }
      while (v8 != v10);
      unsigned int v8 = v41;
    }
    uint64_t v41 = v16;
    unsigned int v43 = (unint64_t *)v17;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *int v42 = a2;
    unint64_t v9 = v8 + 1;
  }
  int v42 = v9;
  do
  {
    uint64_t v20 = *--v9;
    uint64_t v19 = v20;
    int v42 = v9;
    *(void *)(a1[43] + (((unint64_t)*(unsigned int *)(v20 + 192) >> 3) & 0x1FFFFFF8)) |= 1 << *(_DWORD *)(v20 + 192);
    uint64_t v21 = *(unsigned int *)(v20 + 120);
    if (v21)
    {
      uint64_t v22 = *(void *)(v19 + 112);
      uint64_t v23 = v22 + 16 * v21;
      do
      {
        uint64_t v24 = *(void *)(v23 - 16);
        v23 -= 16;
        unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v26 = *(unsigned int *)((v24 & 0xFFFFFFFFFFFFFFF8) + 192);
        uint64_t v27 = a1[40];
        if (v26 < (a1[41] - v27) >> 2)
        {
          int v28 = *(_DWORD *)(v27 + 4 * v26);
          if (v28 == a3)
          {
            unint64_t v9 = v41;
            *unint64_t v40 = 1;
            if (!v9) {
              return;
            }
            goto LABEL_49;
          }
          uint64_t v29 = *(void *)(a1[43] + 8 * (v26 >> 6)) & (1 << v26);
          if (v28 < a3 && v29 == 0)
          {
            if (v9 >= v43)
            {
              unsigned int v32 = v41;
              uint64_t v33 = v9 - v41;
              unint64_t v34 = v33 + 1;
              if ((unint64_t)(v33 + 1) >> 61) {
                goto LABEL_54;
              }
              uint64_t v35 = (char *)v43 - (char *)v41;
              if (((char *)v43 - (char *)v41) >> 2 > v34) {
                unint64_t v34 = v35 >> 2;
              }
              if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v36 = v34;
              }
              if (v36)
              {
                if (v36 >> 61) {
                  goto LABEL_55;
                }
                uint64_t v37 = (char *)operator new(8 * v36);
              }
              else
              {
                uint64_t v37 = 0;
              }
              unsigned int v38 = (unint64_t *)&v37[8 * v33];
              *unsigned int v38 = v25;
              uint64_t v31 = v38 + 1;
              if (v9 != v32)
              {
                do
                {
                  unint64_t v39 = *--v9;
                  *--unsigned int v38 = v39;
                }
                while (v9 != v32);
                unint64_t v9 = v41;
              }
              uint64_t v41 = v38;
              unsigned int v43 = (unint64_t *)&v37[8 * v36];
              if (v9) {
                operator delete(v9);
              }
            }
            else
            {
              *unint64_t v9 = v25;
              uint64_t v31 = v9 + 1;
            }
            int v42 = v31;
            unint64_t v9 = v31;
          }
        }
      }
      while (v23 != v22);
    }
  }
  while (v41 != v9);
  if (!v9) {
    return;
  }
LABEL_49:

  operator delete(v9);
}

void llvm::ScheduleDAGTopologicalSort::GetSubGraph(llvm::ScheduleDAGTopologicalSort *this@<X0>, const llvm::SUnit *a2@<X1>, const llvm::SUnit *a3@<X2>, BOOL *a4@<X3>, char **a5@<X8>)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  std::string __p = 0;
  uint64_t v97 = 0;
  uint64_t v6 = *((void *)this + 40);
  int v7 = *(_DWORD *)(v6 + 4 * *((unsigned int *)a2 + 48));
  int v8 = *(_DWORD *)(v6 + 4 * *((unsigned int *)a3 + 48));
  int v98 = 0;
  uint64_t v99 = v101;
  uint64_t v100 = 0x600000000;
  int v102 = 0;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  if (v7 > v8)
  {
    unint64_t v9 = 0;
    BOOL v10 = 0;
    goto LABEL_126;
  }
  sub_1CBF7ACFC((uint64_t)&__p, 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 4));
  uint64_t v14 = *((unsigned int *)this + 88);
  if (v14) {
    bzero(*((void **)this + 43), 8 * v14);
  }
  unint64_t v15 = v97;
  int v95 = v7;
  uint64_t v92 = a3;
  uint64_t v93 = a4;
  if (v97 >= v98)
  {
    uint64_t v16 = (char *)__p;
    uint64_t v17 = (v97 - (unsigned char *)__p) >> 3;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 61) {
LABEL_132:
    }
      abort();
    uint64_t v19 = v98 - (unsigned char *)__p;
    if ((v98 - (unsigned char *)__p) >> 2 > v18) {
      unint64_t v18 = v19 >> 2;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      if (v20 >> 61) {
        goto LABEL_133;
      }
      uint64_t v21 = (char *)operator new(8 * v20);
    }
    else
    {
      uint64_t v21 = 0;
    }
    uint64_t v22 = &v21[8 * v17];
    uint64_t v23 = &v21[8 * v20];
    *(void *)uint64_t v22 = a2;
    unint64_t v9 = v22 + 8;
    if (v15 == v16)
    {
      int v7 = v95;
    }
    else
    {
      int v7 = v95;
      do
      {
        uint64_t v24 = *((void *)v15 - 1);
        v15 -= 8;
        *((void *)v22 - 1) = v24;
        v22 -= 8;
      }
      while (v15 != v16);
      unint64_t v15 = (char *)__p;
    }
    std::string __p = v22;
    int v98 = v23;
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    *(void *)uint64_t v97 = a2;
    unint64_t v9 = v15 + 8;
  }
  char v25 = 0;
  uint64_t v97 = v9;
  do
  {
    uint64_t v27 = *((void *)v9 - 1);
    v9 -= 8;
    uint64_t v26 = v27;
    uint64_t v97 = v9;
    uint64_t v28 = *(unsigned int *)(v27 + 120);
    if (v28)
    {
      uint64_t v29 = *(void *)(v26 + 112);
      uint64_t v30 = v29 + 16 * v28;
      do
      {
        uint64_t v31 = *(void *)(v30 - 16);
        v30 -= 16;
        unint64_t v32 = v31 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v33 = *(unsigned int *)((v31 & 0xFFFFFFFFFFFFFFF8) + 192);
        if (v33 != -1)
        {
          int v34 = *(_DWORD *)(*((void *)this + 40) + 4 * v33);
          if (v34 == v8)
          {
            char v25 = 1;
          }
          else
          {
            uint64_t v35 = 1 << v33;
            unint64_t v36 = v33 >> 6;
            uint64_t v37 = *((void *)this + 43);
            uint64_t v38 = *(void *)(v37 + 8 * v36);
            if (v34 < v8 && (v38 & v35) == 0)
            {
              *(void *)(v37 + 8 * v36) = v38 | v35;
              if (v9 >= v98)
              {
                uint64_t v41 = (char *)__p;
                uint64_t v42 = (v9 - (unsigned char *)__p) >> 3;
                unint64_t v43 = v42 + 1;
                if ((unint64_t)(v42 + 1) >> 61) {
                  goto LABEL_132;
                }
                uint64_t v44 = v98 - (unsigned char *)__p;
                if ((v98 - (unsigned char *)__p) >> 2 > v43) {
                  unint64_t v43 = v44 >> 2;
                }
                if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v45 = v43;
                }
                if (v45)
                {
                  if (v45 >> 61) {
                    goto LABEL_133;
                  }
                  unint64_t v46 = (char *)operator new(8 * v45);
                }
                else
                {
                  unint64_t v46 = 0;
                }
                uint64_t v47 = (unint64_t *)&v46[8 * v42];
                unint64_t *v47 = v32;
                unint64_t v40 = (char *)(v47 + 1);
                if (v9 != v41)
                {
                  do
                  {
                    unint64_t v48 = *((void *)v9 - 1);
                    v9 -= 8;
                    *--uint64_t v47 = v48;
                  }
                  while (v9 != v41);
                  unint64_t v9 = (char *)__p;
                }
                std::string __p = v47;
                uint64_t v97 = v40;
                int v98 = &v46[8 * v45];
                int v7 = v95;
                if (v9) {
                  operator delete(v9);
                }
              }
              else
              {
                *(void *)unint64_t v9 = v32;
                unint64_t v40 = v9 + 8;
              }
              uint64_t v97 = v40;
              unint64_t v9 = v40;
            }
          }
        }
      }
      while (v30 != v29);
    }
  }
  while (__p != v9);
  if (v25)
  {
    int v49 = -252645135 * ((*(void *)(*(void *)this + 8) - **(void **)this) >> 4);
    uint64_t v50 = v100;
    if ((v102 & 0x3F) != 0) {
      *((void *)v99 + v100 - 1) &= ~(-1 << (v102 & 0x3F));
    }
    unsigned int v51 = v50;
    int v102 = v49;
    unsigned int v52 = v49 + 63;
    if (v50 != (v49 + 63) >> 6)
    {
      uint64_t v53 = v52 >> 6;
      if (v50 > v53)
      {
        LODWORD(v100) = v52 >> 6;
        unsigned int v51 = v52 >> 6;
      }
      else
      {
        if (v53 > HIDWORD(v100)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v53 != v50) {
          bzero((char *)v99 + 8 * v50, 8 * (v53 - v50));
        }
        unsigned int v51 = v53;
        LODWORD(v100) = v53;
        LOBYTE(v49) = v102;
      }
    }
    int v54 = v49 & 0x3F;
    if (v54) {
      *((void *)v99 + v51 - 1) &= ~(-1 << v54);
    }
    if (v9 < v98)
    {
      *(void *)unint64_t v9 = v92;
      unsigned int v55 = v9 + 8;
      goto LABEL_77;
    }
    unint64_t v56 = (v98 - v9) >> 2;
    if (v56 <= 1) {
      unint64_t v56 = 1;
    }
    if ((unint64_t)(v98 - v9) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v57 = v56;
    }
    if (!(v57 >> 61))
    {
      unsigned int v58 = (char *)operator new(8 * v57);
      BOOL v59 = &v58[8 * v57];
      *(void *)unsigned int v58 = v92;
      unsigned int v55 = v58 + 8;
      std::string __p = v58;
      uint64_t v97 = v58 + 8;
      int v98 = v59;
      if (v9) {
        operator delete(v9);
      }
LABEL_77:
      uint64_t v97 = v55;
      unint64_t v9 = v55;
      do
      {
        uint64_t v61 = *((void *)v9 - 1);
        v9 -= 8;
        uint64_t v60 = v61;
        int v62 = v9;
        uint64_t v97 = v9;
        uint64_t v63 = *(unsigned int *)(v61 + 40);
        if (v63)
        {
          uint64_t v64 = *(void *)(v60 + 32);
          uint64_t v65 = v64 + 16 * v63;
          do
          {
            uint64_t v66 = *(void *)(v65 - 16);
            v65 -= 16;
            unint64_t v67 = v66 & 0xFFFFFFFFFFFFFFF8;
            unint64_t v68 = *(unsigned int *)((v66 & 0xFFFFFFFFFFFFFFF8) + 192);
            if (v68 == -1
              || *(_DWORD *)(*((void *)this + 40) + 4 * v68) == v7
              || (uint64_t v69 = 1 << v68, v70 = v68 >> 6, v71 = *((void *)v99 + (v68 >> 6)), (v71 & (1 << v68)) != 0)
              || (*(void *)(*((void *)this + 43) + 8 * v70) & v69) == 0)
            {
              unint64_t v9 = v62;
            }
            else
            {
              *((void *)v99 + v70) = v71 | v69;
              if (v62 >= v98)
              {
                uint64_t v72 = (char *)__p;
                uint64_t v73 = (v62 - (unsigned char *)__p) >> 3;
                unint64_t v74 = v73 + 1;
                if ((unint64_t)(v73 + 1) >> 61) {
                  goto LABEL_132;
                }
                uint64_t v75 = v98 - (unsigned char *)__p;
                if ((v98 - (unsigned char *)__p) >> 2 > v74) {
                  unint64_t v74 = v75 >> 2;
                }
                if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v76 = v74;
                }
                if (v76)
                {
                  if (v76 >> 61) {
                    goto LABEL_133;
                  }
                  uint64_t v77 = (char *)operator new(8 * v76);
                }
                else
                {
                  uint64_t v77 = 0;
                }
                uint64_t v78 = (unint64_t *)&v77[8 * v73];
                *uint64_t v78 = v67;
                unint64_t v9 = (char *)(v78 + 1);
                if (v62 != v72)
                {
                  do
                  {
                    unint64_t v79 = *((void *)v62 - 1);
                    v62 -= 8;
                    *--uint64_t v78 = v79;
                  }
                  while (v62 != v72);
                  int v62 = (char *)__p;
                }
                std::string __p = v78;
                uint64_t v97 = v9;
                int v98 = &v77[8 * v76];
                int v7 = v95;
                if (v62) {
                  operator delete(v62);
                }
              }
              else
              {
                *(void *)int v62 = v67;
                unint64_t v9 = v62 + 8;
              }
              uint64_t v97 = v9;
              uint64_t v80 = a5;
              uint64_t v82 = a5[1];
              unint64_t v81 = (unint64_t)a5[2];
              if ((unint64_t)v82 >= v81)
              {
                uint64_t v84 = *a5;
                uint64_t v85 = (v82 - *a5) >> 2;
                unint64_t v86 = v85 + 1;
                if ((unint64_t)(v85 + 1) >> 62) {
                  goto LABEL_132;
                }
                uint64_t v87 = v81 - (void)v84;
                if (v87 >> 1 > v86) {
                  unint64_t v86 = v87 >> 1;
                }
                if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v88 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v88 = v86;
                }
                if (v88)
                {
                  if (v88 >> 62) {
                    goto LABEL_133;
                  }
                  int v89 = (char *)operator new(4 * v88);
                }
                else
                {
                  int v89 = 0;
                }
                uint64_t v90 = &v89[4 * v85];
                *(_DWORD *)uint64_t v90 = v68;
                unsigned int v83 = v90 + 4;
                while (v82 != v84)
                {
                  int v91 = *((_DWORD *)v82 - 1);
                  v82 -= 4;
                  *((_DWORD *)v90 - 1) = v91;
                  v90 -= 4;
                }
                *a5 = v90;
                a5[2] = &v89[4 * v88];
                if (v84) {
                  operator delete(v84);
                }
                uint64_t v80 = a5;
                int v7 = v95;
              }
              else
              {
                *(_DWORD *)uint64_t v82 = v68;
                unsigned int v83 = v82 + 4;
              }
              v80[1] = v83;
            }
            int v62 = v9;
          }
          while (v65 != v64);
        }
      }
      while (__p != v9);
      BOOL v10 = 1;
      goto LABEL_125;
    }
LABEL_133:
    sub_1CB833614();
  }
  BOOL v10 = 0;
LABEL_125:
  a4 = v93;
LABEL_126:
  *a4 = v10;
  if (v99 != v101) {
    free(v99);
  }
  if (v9)
  {
    uint64_t v97 = v9;
    operator delete(v9);
  }
}

uint64_t llvm::ScheduleDAGTopologicalSort::WillCreateCycle(uint64_t **this, llvm::SUnit *a2, llvm::SUnit *a3)
{
  llvm::ScheduleDAGTopologicalSort::FixOrder(this);
  if (llvm::ScheduleDAGTopologicalSort::IsReachable((llvm::ScheduleDAGTopologicalSort *)this, a3, a2)) {
    return 1;
  }
  uint64_t v7 = *((unsigned int *)a2 + 10);
  if (v7)
  {
    uint64_t v8 = *((void *)a2 + 4);
    uint64_t v9 = 16 * v7;
    for (uint64_t i = (_DWORD *)(v8 + 8); ; i += 4)
    {
      uint64_t v11 = *((void *)i - 1);
      if ((v11 & 6) == 0
        && *i
        && llvm::ScheduleDAGTopologicalSort::IsReachable((llvm::ScheduleDAGTopologicalSort *)this, a3, (const llvm::SUnit *)(v11 & 0xFFFFFFFFFFFFFFF8)))
      {
        break;
      }
      v9 -= 16;
      if (!v9) {
        return 0;
      }
    }
    return 1;
  }
  return 0;
}

BOOL llvm::ScheduleDAGTopologicalSort::IsReachable(llvm::ScheduleDAGTopologicalSort *this, const llvm::SUnit *a2, const llvm::SUnit *a3)
{
  llvm::ScheduleDAGTopologicalSort::FixOrder((uint64_t **)this);
  BOOL result = 0;
  uint64_t v7 = *((void *)this + 40);
  int v8 = *(_DWORD *)(v7 + 4 * *((unsigned int *)a3 + 48));
  int v9 = *(_DWORD *)(v7 + 4 * *((unsigned int *)a2 + 48));
  char v11 = 0;
  if (v8 < v9)
  {
    uint64_t v10 = *((unsigned int *)this + 88);
    if (v10) {
      bzero(*((void **)this + 43), 8 * v10);
    }
    llvm::ScheduleDAGTopologicalSort::DFS(this, (unint64_t)a3, v9, &v11);
    return v11 != 0;
  }
  return result;
}

double llvm::ScheduleDAGTopologicalSort::ScheduleDAGTopologicalSort(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x1000000000;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(void *)(a1 + 344) = a1 + 360;
  *(void *)&double result = 0x600000000;
  *(void *)(a1 + 352) = 0x600000000;
  *(_DWORD *)(a1 + 408) = 0;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 32) = 0x1000000000;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(void *)(a1 + 344) = a1 + 360;
  *(void *)&double result = 0x600000000;
  *(void *)(a1 + 352) = 0x600000000;
  *(_DWORD *)(a1 + 408) = 0;
  return result;
}

void sub_1CC463D08(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 272)
  {
    uint64_t v5 = *(void **)(i - 160);
    if ((void *)(i - 144) != v5) {
      free(v5);
    }
    uint64_t v6 = *(void **)(i - 240);
    if ((void *)(i - 224) != v6) {
      free(v6);
    }
  }
  *(void *)(a1 + 8) = a2;
}

char *sub_1CC463D78(char **a1, int a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = a1[1];
  uint64_t v4 = (v3 - *a1) >> 2;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 62) {
    abort();
  }
  uint64_t v8 = a1[2] - v2;
  if (v8 >> 1 > v5) {
    unint64_t v5 = v8 >> 1;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 62) {
      sub_1CB833614();
    }
    uint64_t v10 = (char *)operator new(4 * v9);
  }
  else
  {
    uint64_t v10 = 0;
  }
  char v11 = &v10[4 * v4];
  *(_DWORD *)char v11 = a2;
  unint64_t v12 = v11 + 4;
  while (v3 != v2)
  {
    int v13 = *((_DWORD *)v3 - 1);
    v3 -= 4;
    *((_DWORD *)v11 - 1) = v13;
    v11 -= 4;
  }
  *a1 = v11;
  a1[1] = v12;
  a1[2] = &v10[4 * v9];
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

llvm::ScheduleDAGInstrs *llvm::ScheduleDAGInstrs::ScheduleDAGInstrs(llvm::ScheduleDAGInstrs *this, const llvm::TargetSubtargetInfo **a2, const llvm::MachineLoopInfo *a3, char a4)
{
  uint64_t v8 = llvm::ScheduleDAG::ScheduleDAG(this, (llvm::MachineFunction *)a2);
  *(void *)uint64_t v8 = &unk_1F2612D78;
  *((void *)v8 + 77) = a3;
  *((void *)v8 + 78) = a2[7];
  unint64_t v9 = (llvm::ScheduleDAG *)((char *)v8 + 632);
  *((void *)v8 + 87) = 0;
  *(_OWORD *)((char *)v8 + 664) = xmmword_1CFB28DF0;
  *(_OWORD *)((char *)v8 + 680) = unk_1CFB28E00;
  *(_OWORD *)((char *)v8 + 632) = llvm::MCSchedModel::Default;
  *(_OWORD *)((char *)v8 + 648) = unk_1CFB28DE0;
  *((void *)v8 + 96) = 0;
  *((_OWORD *)v8 + 46) = xmmword_1CFB28DF0;
  *((_OWORD *)v8 + 47) = unk_1CFB28E00;
  *((_OWORD *)v8 + 44) = llvm::MCSchedModel::Default;
  *((_OWORD *)v8 + 45) = unk_1CFB28DE0;
  *(_OWORD *)((char *)v8 + 792) = 0u;
  *(_OWORD *)((char *)v8 + 808) = 0u;
  *(_OWORD *)((char *)v8 + 776) = 0u;
  *((void *)v8 + 103) = (char *)v8 + 840;
  *((void *)v8 + 104) = 0x1000000000;
  *((void *)v8 + 113) = 0;
  *((unsigned char *)v8 + 912) = a4;
  *(_WORD *)((char *)v8 + 913) = 0;
  *((_OWORD *)v8 + 58) = 0u;
  *((_DWORD *)v8 + 242) = 0;
  *(_OWORD *)((char *)v8 + 952) = 0u;
  *((void *)v8 + 122) = (char *)v8 + 992;
  *((void *)v8 + 123) = 0x800000000;
  *((void *)v8 + 148) = 0;
  *((_DWORD *)v8 + 298) = 0;
  *((void *)v8 + 150) = 0xFFFFFFFFLL;
  *((void *)v8 + 151) = (char *)v8 + 1224;
  *((void *)v8 + 152) = 0x800000000;
  *((void *)v8 + 177) = 0;
  *((_DWORD *)v8 + 356) = 0;
  *((void *)v8 + 179) = 0xFFFFFFFFLL;
  *((void *)v8 + 180) = (char *)v8 + 1456;
  *((void *)v8 + 181) = 0x800000000;
  *((void *)v8 + 214) = 0;
  *((_DWORD *)v8 + 430) = 0;
  *((void *)v8 + 216) = 0xFFFFFFFFLL;
  *((void *)v8 + 217) = (char *)v8 + 1752;
  *((void *)v8 + 218) = 0x800000000;
  *((void *)v8 + 259) = 0;
  *((_DWORD *)v8 + 520) = 0;
  *(void *)((char *)v8 + 2100) = 0;
  *(void *)((char *)v8 + 2092) = 0;
  *((_DWORD *)v8 + 527) = 0;
  uint64_t v10 = (llvm::UndefValue *)(***(void ***)*a2 + 1576);
  *((_DWORD *)this + 522) = -1;
  *((void *)this + 264) = llvm::UndefValue::get(v10, v11);
  *((void *)this + 265) = (char *)this + 48;
  *((void *)this + 266) = (char *)this + 344;
  *((unsigned char *)this + 2136) = 0;
  *((void *)this + 268) = (char *)this + 2160;
  *((void *)this + 269) = 0x1000000000;
  *((_OWORD *)this + 151) = 0u;
  *((_OWORD *)this + 152) = 0u;
  *((_OWORD *)this + 153) = 0u;
  *((void *)this + 308) = (char *)this + 2480;
  *((void *)this + 309) = 0x600000000;
  *((_DWORD *)this + 632) = 0;
  *(_OWORD *)((char *)this + 2536) = 0u;
  *(_OWORD *)((char *)this + 2552) = 0u;
  *((void *)this + 321) = 0;
  *((void *)this + 322) = (char *)this + 2600;
  *((void *)this + 323) = 0;
  *((void *)this + 324) = 8;
  *((void *)this + 327) = 0;
  *((_DWORD *)this + 656) = 0;
  llvm::TargetSchedModel::init(v9, a2[2]);
  return this;
}

uint64_t llvm::ScheduleDAGInstrs::startBlock(uint64_t this, llvm::MachineBasicBlock *a2)
{
  *(void *)(this + 920) = a2;
  return this;
}

uint64_t llvm::ScheduleDAGInstrs::finishBlock(uint64_t this)
{
  *(void *)(this + 920) = 0;
  return this;
}

uint64_t llvm::ScheduleDAGInstrs::enterRegion(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  *(void *)(result + 928) = a3;
  *(void *)(result + 936) = a4;
  *(_DWORD *)(result + 944) = a5;
  return result;
}

void llvm::ScheduleDAGInstrs::addSchedBarrierDeps(llvm::ScheduleDAGInstrs *this)
{
  unint64_t v2 = *((void *)this + 117);
  if (v2 == *((void *)this + 115) + 48)
  {
    uint64_t v27 = (char *)this + 344;
    *((void *)this + 44) = 0;
LABEL_36:
    uint64_t v15 = *((void *)this + 115);
    uint64_t v16 = *(void *)(v15 + 88);
    for (uint64_t i = *(void *)(v15 + 96); v16 != i; v16 += 8)
    {
      unint64_t v18 = *(unsigned __int16 **)(*(void *)v16 + 152);
      for (j = *(unsigned __int16 **)(*(void *)v16 + 160); v18 != j; v18 += 8)
      {
        uint64_t v20 = *v18;
        unsigned int v21 = *(unsigned __int16 *)(*((void *)this + 177) + 2 * v20);
        unsigned int v22 = *((_DWORD *)this + 304);
        if (v22 > v21)
        {
          uint64_t v23 = *((void *)this + 151);
          while (1)
          {
            unsigned int v24 = v21;
            if (*(_DWORD *)(v23 + 24 * v21 + 12) == v20)
            {
              unsigned int v25 = *(_DWORD *)(v23 + 24 * v21 + 16);
              if (v25 != -1 && *(_DWORD *)(v23 + 24 * v25 + 20) == -1) {
                break;
              }
            }
            unsigned int v21 = v24 + 0x10000;
            if (v24 + 0x10000 >= v22) {
              goto LABEL_39;
            }
          }
        }
        else
        {
LABEL_39:
          uint64_t v28 = v27;
          int v29 = -1;
          int v30 = v20;
          sub_1CC464314((uint64_t)this + 1208, (uint64_t)&v28);
        }
      }
    }
    return;
  }
  uint64_t v3 = *((void *)this + 116);
  if (v2 != v3)
  {
    do
    {
      int v4 = **(unsigned __int16 **)(v2 + 16);
      if ((v4 - 13) >= 5 && v4 != 23)
      {
        uint64_t v27 = (char *)this + 344;
        *((void *)this + 44) = v2;
        goto LABEL_16;
      }
      unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
      if (!v2 || (*(unsigned char *)v2 & 4) == 0)
      {
        while ((*(_WORD *)(v2 + 44) & 4) != 0)
          unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
      }
    }
    while (v2 != v3);
    unint64_t v2 = *((void *)this + 116);
  }
  uint64_t v27 = (char *)this + 344;
  *((void *)this + 44) = v2;
  if (!v2) {
    goto LABEL_36;
  }
LABEL_16:
  uint64_t v6 = *(unsigned int *)(v2 + 40);
  if (v6)
  {
    uint64_t v7 = *(void *)(v2 + 32);
    uint64_t v8 = 32 * v6;
    unint64_t v9 = (int *)(v7 + 4);
    do
    {
      int v10 = *(v9 - 1);
      if ((v10 & 0x10000FF) == 0)
      {
        int v11 = *v9;
        if ((*v9 - 1) > 0x3FFFFFFE)
        {
          BOOL v12 = (v10 & 0x10FFF00) != 0x1000000 && (v10 & 0x30000000) == 0;
          if (v12 && v11 < 0) {
            llvm::ScheduleDAGInstrs::addVRegUseDeps((uint64_t)this, (unint64_t)v27, (unint64_t)(v7 - *(void *)(v2 + 32)) >> 5);
          }
        }
        else
        {
          uint64_t v28 = v27;
          int v29 = -1;
          int v30 = v11;
          sub_1CC464314((uint64_t)this + 1208, (uint64_t)&v28);
        }
      }
      v7 += 32;
      v9 += 8;
      v8 -= 32;
    }
    while (v8);
  }
  uint64_t v13 = *(void *)(*(void *)(v2 + 16) + 8);
  if ((*(_WORD *)(v2 + 44) & 0xC) == 0 || (*(_WORD *)(v2 + 44) & 4) != 0)
  {
    if ((v13 & 0x180) != 0) {
      return;
    }
    goto LABEL_36;
  }
  if ((v13 & 0x80) == 0)
  {
    unint64_t v26 = v2;
    while ((*(_WORD *)(v26 + 44) & 8) != 0)
    {
      unint64_t v26 = *(void *)(v26 + 8);
      if ((*(unsigned char *)(*(void *)(v26 + 16) + 8) & 0x80) != 0) {
        return;
      }
    }
    if ((v13 & 0x100) == 0)
    {
      while ((*(_WORD *)(v2 + 44) & 8) != 0)
      {
        unint64_t v2 = *(void *)(v2 + 8);
        if (*(unsigned char *)(*(void *)(v2 + 16) + 9)) {
          return;
        }
      }
      goto LABEL_36;
    }
  }
}

void sub_1CC464314(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 12);
  unsigned int v4 = *(unsigned __int16 *)(*(void *)(a1 + 208) + 2 * v3);
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  if (v5 > v4)
  {
    uint64_t v7 = *(void *)a1;
    while (1)
    {
      unsigned int v8 = v4;
      if (*(_DWORD *)(v7 + 24 * v4 + 12) == v3)
      {
        unsigned int v9 = *(_DWORD *)(v7 + 24 * v4 + 16);
        if (v9 != -1 && *(_DWORD *)(v7 + 24 * v9 + 20) == -1) {
          break;
        }
      }
      unsigned int v4 = v8 + 0x10000;
      if (v8 + 0x10000 >= v5) {
        goto LABEL_2;
      }
    }
    sub_1CC46A664(a1, *(void *)a2, *(void *)(a2 + 8));
    uint64_t v10 = *(void *)a1;
    uint64_t v11 = *(void *)a1 + 24 * v8;
    unsigned int v12 = *(_DWORD *)(v11 + 16);
    *(_DWORD *)(*(void *)a1 + 24 * v12 + 20) = v13;
    *(_DWORD *)(v11 + 16) = v13;
    *(_DWORD *)(v10 + 24 * v13 + 16) = v12;
  }
  else
  {
LABEL_2:
    sub_1CC46A664(a1, *(void *)a2, *(void *)(a2 + 8));
    *(_WORD *)(*(void *)(a1 + 208) + 2 * v3) = v6;
    *(_DWORD *)(*(void *)a1 + 24 * v6 + 16) = v6;
  }
}

uint64_t llvm::ScheduleDAGInstrs::addVRegUseDeps(uint64_t this, unint64_t a2, unsigned int a3)
{
  uint64_t v4 = this;
  unsigned int v5 = (unsigned int *)(*(void *)(*(void *)(a2 + 8) + 32) + 32 * a3);
  unsigned int v6 = v5[1];
  if (!*(unsigned char *)(this + 914))
  {
    uint64_t v7 = v6 & 0x7FFFFFFF;
    goto LABEL_38;
  }
  uint64_t v7 = v6 & 0x7FFFFFFF;
  unint64_t v8 = *(void *)(*(void *)(*(void *)(this + 40) + 24) + 16 * v7) & 0xFFFFFFFFFFFFFFF8;
  if (!*(unsigned char *)(v8 + 34))
  {
LABEL_38:
    uint64_t v10 = -1;
    goto LABEL_5;
  }
  unint64_t v9 = ((unint64_t)*v5 >> 8) & 0xFFF;
  if (v9) {
    uint64_t v10 = *(void *)(*(void *)(*(void *)(this + 24) + 232) + 8 * v9);
  }
  else {
    uint64_t v10 = *(void *)(v8 + 24);
  }
LABEL_5:
  uint64_t v11 = (uint64_t *)(this + 1736);
  unsigned int v12 = *(unsigned __int8 *)(*(void *)(this + 2072) + v7);
  unsigned int v13 = *(_DWORD *)(this + 1744);
  if (v13 <= v12)
  {
    unsigned int v16 = -1;
  }
  else
  {
    uint64_t v14 = *v11;
    while (1)
    {
      if ((*(_DWORD *)(v14 + 40 * v12) & 0x7FFFFFFF) == v7)
      {
        unsigned int v15 = *(_DWORD *)(v14 + 40 * v12 + 32);
        if (v15 != -1 && *(_DWORD *)(v14 + 40 * v15 + 36) == -1) {
          break;
        }
      }
      v12 += 256;
      unsigned int v16 = -1;
      if (v12 >= v13) {
        goto LABEL_13;
      }
    }
    unsigned int v16 = v12;
  }
LABEL_13:
  if (*(_DWORD *)(this + 2092))
  {
    unsigned int v17 = *(_DWORD *)(this + 2088);
    uint64_t v18 = *(void *)(this + 1736) + 40 * v17;
    int v19 = *(_DWORD *)(v18 + 36);
    *(_DWORD *)uint64_t v18 = v6;
    *(void *)(v18 + 8) = v10;
    *(void *)(v18 + 16) = a2;
    *(_DWORD *)(v18 + 24) = a3;
    *(void *)(v18 + 32) = -1;
    *(_DWORD *)(this + 2088) = v19;
    --*(_DWORD *)(this + 2092);
  }
  else
  {
    LODWORD(v34) = v6;
    *((void *)&v34 + 1) = v10;
    *(void *)&long long v35 = a2;
    DWORD2(v35) = a3;
    uint64_t v36 = -1;
    unint64_t v29 = *(void *)(this + 1736);
    if (v13 >= *(_DWORD *)(this + 1748))
    {
      BOOL v33 = v29 + 40 * v13 > (unint64_t)&v34;
      if (v29 > (unint64_t)&v34 || !v33) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v30 = v29 + 40 * *(unsigned int *)(this + 1744);
    long long v31 = v34;
    long long v32 = v35;
    *(void *)(v30 + 32) = v36;
    *(_OWORD *)uint64_t v30 = v31;
    *(_OWORD *)(v30 + 16) = v32;
    unsigned int v17 = *(_DWORD *)(this + 1744);
    *(_DWORD *)(this + 1744) = v17 + 1;
  }
  if (v16 == -1)
  {
    *(unsigned char *)(*(void *)(this + 2072) + v7) = v17;
    *(_DWORD *)(*(void *)(this + 1736) + 40 * v17 + 32) = v17;
  }
  else
  {
    uint64_t v26 = *v11;
    uint64_t v27 = *v11 + 40 * v16;
    unsigned int v28 = *(_DWORD *)(v27 + 32);
    *(_DWORD *)(*v11 + 40 * v28 + 36) = v17;
    *(_DWORD *)(v27 + 32) = v17;
    *(_DWORD *)(v26 + 40 * v17 + 32) = v28;
  }
  unsigned int v20 = *(unsigned __int8 *)(*(void *)(this + 1712) + v7);
  unsigned int v21 = *(_DWORD *)(this + 1448);
  if (v21 > v20)
  {
    uint64_t v22 = *(void *)(this + 1440);
    while (1)
    {
      if ((*(_DWORD *)(v22 + 32 * v20) & 0x7FFFFFFF) == v7)
      {
        uint64_t v23 = *(unsigned int *)(v22 + 32 * v20 + 24);
        if (v23 != -1 && *(_DWORD *)(v22 + 32 * v23 + 28) == -1) {
          break;
        }
      }
      v20 += 256;
      if (v20 >= v21) {
        return this;
      }
    }
    do
    {
      uint64_t v24 = v20;
      uint64_t v25 = v22 + 32 * v20;
      if ((*(void *)(v25 + 8) & v10) != 0)
      {
        this = *(void *)(v25 + 16);
        if (this != a2)
        {
          *(void *)&long long v34 = a2 & 0xFFFFFFFFFFFFFFF9 | 2;
          *((void *)&v34 + 1) = v6;
          this = llvm::SUnit::addPred(this, (uint64_t *)&v34, 1);
          uint64_t v22 = *(void *)(v4 + 1440);
        }
      }
      unsigned int v20 = *(_DWORD *)(v22 + 32 * v24 + 28);
    }
    while (v20 != -1);
  }
  return this;
}

void *llvm::ScheduleDAGInstrs::addPhysRegDataDeps(void *this, unint64_t a2, unsigned int a3)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v48 = *(void *)(this[4] + 16);
  uint64_t v5 = *(void *)(v4 + 16);
  unsigned int v6 = *(_DWORD *)(*(void *)(v4 + 32) + 32 * a3 + 4);
  if (*(unsigned __int16 *)(v5 + 2) <= a3)
  {
    uint64_t v36 = *(_WORD **)(v5 + 32);
    if (v36 && (int v37 = (unsigned __int16)*v36, *v36))
    {
      uint64_t v38 = v36 + 1;
      do
      {
        BOOL v7 = v6 != v37;
        if (v6 == v37) {
          break;
        }
        int v39 = *v38++;
        int v37 = v39;
      }
      while (v39);
    }
    else
    {
      BOOL v7 = 1;
    }
  }
  else
  {
    BOOL v7 = 0;
  }
  uint64_t v8 = this[3];
  if (v8) {
    unint64_t v9 = (void *)(v8 + 8);
  }
  else {
    unint64_t v9 = 0;
  }
  uint64_t v11 = v9[5];
  uint64_t v10 = v9[6];
  unsigned int v12 = (unsigned __int16 *)(v10 + (((unint64_t)*(unsigned int *)(*v9 + 24 * v6 + 16) >> 3) & 0x1FFFFFFE));
  int v14 = *v12;
  unsigned int v13 = v12 + 1;
  int v15 = v14 + (*(_DWORD *)(*v9 + 24 * v6 + 16) & 0xF) * v6;
  do
  {
    unsigned __int16 v16 = *(_WORD *)(v11 + 4 * (unsigned __int16)v15);
    if (v16) {
      BOOL v17 = v10 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    if (!v17)
    {
      unsigned int v18 = *(unsigned __int16 *)(v11 + 4 * (unsigned __int16)v15 + 2) << 16;
      int v19 = (unsigned __int16 *)(v10
                               + 2
                               * *(unsigned int *)(*v9
                                                 + 24 * *(unsigned __int16 *)(v11 + 4 * (unsigned __int16)v15)
                                                 + 8));
      unint64_t v45 = a2 | 6;
      unint64_t v46 = (llvm::TargetSchedModel *)(this + 79);
      int v20 = v15;
      unsigned int v51 = (const llvm::MachineInstr **)a2;
      uint64_t v47 = v9;
      while (1)
      {
        unsigned int v21 = v16;
        unsigned int v22 = *(unsigned __int16 *)(*(void *)(v3 + 1416) + 2 * v16);
        unsigned int v23 = *(_DWORD *)(v3 + 1216);
        if (v23 > v22) {
          break;
        }
LABEL_13:
        int v25 = *v19++;
        __int16 v24 = v25;
        if (v25)
        {
          unsigned __int16 v16 = v24 + v21;
        }
        else
        {
          unsigned int v27 = HIWORD(v18);
          if (HIWORD(v18))
          {
            v18 >>= 16;
          }
          else
          {
            if (!*v13) {
              return this;
            }
            v20 += (unsigned __int16)*v13++;
            unsigned int v28 = (unsigned __int16 *)(v9[5] + 4 * (unsigned __int16)v20);
            unsigned int v27 = *v28;
            unsigned int v18 = v28[1] << 16;
          }
          unsigned __int16 v16 = v27;
          int v19 = (unsigned __int16 *)(v9[6] + 2 * *(unsigned int *)(*v9 + 24 * v27 + 8));
        }
        if (!v13) {
          return this;
        }
      }
      uint64_t v26 = *(void *)(v3 + 1208);
      while (1)
      {
        if (*(_DWORD *)(v26 + 24 * v22 + 12) == v21)
        {
          unsigned int v29 = *(_DWORD *)(v26 + 24 * v22 + 16);
          if (v29 != -1 && *(_DWORD *)(v26 + 24 * v29 + 20) == -1) {
            break;
          }
        }
        v22 += 0x10000;
        if (v22 >= v23) {
          goto LABEL_13;
        }
      }
      unsigned int v49 = v18;
      while (1)
      {
        uint64_t v30 = v26 + 24 * v22;
        long long v31 = *(llvm::SUnit **)v30;
        if (*(void *)v30 != a2) {
          break;
        }
LABEL_34:
        unsigned int v22 = *(_DWORD *)(v26 + 24 * v22 + 20);
        if (v22 == -1) {
          goto LABEL_13;
        }
      }
      uint64_t v32 = *(unsigned int *)(v30 + 8);
      if ((v32 & 0x80000000) != 0)
      {
        BOOL v33 = 0;
        unint64_t v52 = v45;
        uint64_t v53 = 3;
      }
      else
      {
        *(_WORD *)(a2 + 228) |= 0x40u;
        unint64_t v52 = a2 & 0xFFFFFFFFFFFFFFF9;
        uint64_t v53 = v21 | 0x100000000;
        BOOL v33 = (const llvm::MachineInstr *)*((void *)v31 + 1);
        if (v33)
        {
          uint64_t v35 = *((void *)v33 + 2);
          if (v35)
          {
            if (v32 >= *(unsigned __int16 *)(v35 + 2))
            {
              unint64_t v40 = *(unsigned __int16 **)(v35 + 24);
              if (!v40) {
                goto LABEL_40;
              }
              unsigned __int16 v41 = *v40;
              if (!*v40) {
                goto LABEL_40;
              }
              uint64_t v42 = v40 + 1;
              while (v21 != v41)
              {
                int v34 = 0;
                int v43 = *v42++;
                unsigned __int16 v41 = v43;
                if (!v43) {
                  goto LABEL_33;
                }
              }
            }
          }
        }
      }
      if (!v7)
      {
        int v34 = llvm::TargetSchedModel::computeOperandLatency(v46, v51[1], a3, v33, v32);
LABEL_33:
        HIDWORD(v53) = v34;
        (*(void (**)(uint64_t, const llvm::MachineInstr **, void, llvm::SUnit *, uint64_t, unint64_t *))(*(void *)v48 + 304))(v48, v51, a3, v31, v32, &v52);
        this = (void *)llvm::SUnit::addPred((uint64_t)v31, (uint64_t *)&v52, 1);
        a2 = (unint64_t)v51;
        uint64_t v26 = *(void *)(v3 + 1208);
        unint64_t v9 = v47;
        unsigned int v18 = v49;
        goto LABEL_34;
      }
LABEL_40:
      int v34 = 0;
      goto LABEL_33;
    }
    int v44 = (unsigned __int16)*v13++;
    v15 += v44;
  }
  while (v44);
  return this;
}

void llvm::ScheduleDAGInstrs::addPhysRegDeps(llvm::ScheduleDAGInstrs *this, llvm::SUnit *a2, unsigned int a3)
{
  unsigned int v6 = (const llvm::MachineInstr *)*((void *)a2 + 1);
  BOOL v7 = (int *)(*((void *)v6 + 4) + 32 * a3);
  unsigned int v8 = v7[1];
  if (llvm::MachineRegisterInfo::isConstantPhysReg(*((void **)this + 5), v8)) {
    return;
  }
  unint64_t v79 = (unint64_t)a2;
  unsigned int v78 = a3;
  uint64_t v9 = *((void *)this + 3);
  uint64_t v10 = *(void *)(*((void *)this + 4) + 16);
  if (v9) {
    uint64_t v11 = (void *)(v9 + 8);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v13 = v11[5];
  uint64_t v12 = v11[6];
  int v14 = (unsigned __int16 *)(v12 + (((unint64_t)*(unsigned int *)(*v11 + 24 * v8 + 16) >> 3) & 0x1FFFFFFE));
  int v16 = *v14;
  int v15 = v14 + 1;
  uint64_t v17 = v16 + (*(_DWORD *)(*v11 + 24 * v8 + 16) & 0xF) * v8;
  int v18 = *v7;
  while (1)
  {
    BOOL v19 = !*(_WORD *)(v13 + 4 * (unsigned __int16)v17) || v12 == 0;
    if (!v19) {
      break;
    }
    int v57 = (unsigned __int16)*v15++;
    uint64_t v17 = (v57 + v17);
    if (!v57) {
      goto LABEL_31;
    }
  }
  unsigned int v20 = *(unsigned __int16 *)(v13 + 4 * (unsigned __int16)v17 + 2) << 16;
  unsigned int v21 = (unsigned __int16 *)(v12
                           + 2
                           * *(unsigned int *)(*v11 + 24 * *(unsigned __int16 *)(v13 + 4 * (unsigned __int16)v17) + 8));
  unsigned __int16 v22 = *(_WORD *)(v13 + 4 * (unsigned __int16)v17);
  uint64_t v23 = v17;
  while (1)
  {
    unsigned int v24 = v22;
    unsigned int v25 = v22;
    unsigned int v26 = *(unsigned __int16 *)(*((void *)this + 148) + 2 * v22);
    unsigned int v27 = *((_DWORD *)this + 246);
    if (v27 > v26)
    {
      uint64_t v30 = *((void *)this + 122);
      unsigned int v31 = v26;
      while (1)
      {
        unsigned int v32 = v31;
        if (*(_DWORD *)(v30 + 24 * v31 + 12) == v24)
        {
          unsigned int v35 = *(_DWORD *)(v30 + 24 * v31 + 16);
          if (v35 != -1 && *(_DWORD *)(v30 + 24 * v35 + 20) == -1) {
            break;
          }
        }
        unsigned int v31 = v32 + 0x10000;
        if (v32 + 0x10000 >= v27) {
          goto LABEL_13;
        }
      }
      while (1)
      {
        if (*(_DWORD *)(v30 + 24 * v26 + 12) == v24)
        {
          unsigned int v48 = *(_DWORD *)(v30 + 24 * v26 + 16);
          if (v48 != -1 && *(_DWORD *)(v30 + 24 * v48 + 20) == -1) {
            break;
          }
        }
        v26 += 0x10000;
        if (v26 >= v27) {
          goto LABEL_13;
        }
      }
      if (v26 != -1)
      {
        unsigned int v49 = (char *)this + 344;
        do
        {
          unsigned int v50 = v26;
          uint64_t v51 = *(void *)(v30 + 24 * v26);
          if ((char *)v51 == v49 || v51 == v79) {
            goto LABEL_60;
          }
          unint64_t v53 = v79 & 0xFFFFFFFFFFFFFFF9;
          uint64_t v76 = v51;
          uint64_t v77 = v10;
          int v74 = v18;
          uint64_t v73 = v23;
          unsigned int v72 = v20;
          uint64_t v71 = v49;
          unsigned int v75 = v50;
          if ((v18 & 0x1000000) != 0)
          {
            if ((~*v7 & 0x5000000) == 0)
            {
              int RegisterDefOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx(*(void *)(v51 + 8), v25, 1, 0, 0);
              unint64_t v53 = v79 & 0xFFFFFFFFFFFFFFF9;
              unsigned int v49 = v71;
              unsigned int v50 = v75;
              unsigned int v20 = v72;
              uint64_t v23 = v73;
              int v18 = v74;
              uint64_t v10 = v77;
              if (RegisterDefOperandIdx != -1) {
                goto LABEL_60;
              }
            }
            unint64_t v80 = v53 | 4;
            unsigned int v81 = v24;
            unsigned int v82 = 0;
            unsigned int v55 = llvm::TargetSchedModel::computeOutputLatency((llvm::ScheduleDAGInstrs *)((char *)this + 632), v6, v78, *(const llvm::MachineInstr **)(v76 + 8));
            uint64_t v54 = v78;
            unsigned int v50 = v75;
            uint64_t v51 = v76;
            unsigned int v82 = v55;
            uint64_t v10 = v77;
            uint64_t v30 = *((void *)this + 122);
          }
          else
          {
            unint64_t v80 = v53 | 2;
            unsigned int v81 = v24;
            unsigned int v82 = 0;
            uint64_t v54 = v78;
          }
          (*(void (**)(uint64_t, unint64_t, uint64_t, uint64_t, void, unint64_t *))(*(void *)v10 + 304))(v77, v79, v54, v51, *(unsigned int *)(v30 + 24 * v50 + 8), &v80);
          llvm::SUnit::addPred(v76, (uint64_t *)&v80, 1);
          unsigned int v50 = v75;
          uint64_t v10 = v77;
          int v18 = v74;
          uint64_t v23 = v73;
          unsigned int v20 = v72;
          unsigned int v49 = v71;
LABEL_60:
          uint64_t v30 = *((void *)this + 122);
          unsigned int v26 = *(_DWORD *)(v30 + 24 * v50 + 20);
        }
        while (v26 != -1);
      }
    }
LABEL_13:
    int v29 = *v21++;
    __int16 v28 = v29;
    if (!v29) {
      break;
    }
    unsigned __int16 v22 = v28 + v24;
LABEL_15:
    if (!v15) {
      goto LABEL_30;
    }
  }
  unsigned int v33 = HIWORD(v20);
  if (HIWORD(v20))
  {
    v20 >>= 16;
    goto LABEL_24;
  }
  if (*v15)
  {
    uint64_t v23 = (unsigned __int16)*v15++ + v23;
    int v34 = (unsigned __int16 *)(v11[5] + 4 * (unsigned __int16)v23);
    unsigned int v33 = *v34;
    unsigned int v20 = v34[1] << 16;
LABEL_24:
    unsigned __int16 v22 = v33;
    unsigned int v21 = (unsigned __int16 *)(v11[6] + 2 * *(unsigned int *)(*v11 + 24 * v33 + 8));
    goto LABEL_15;
  }
LABEL_30:
  int v18 = *v7;
LABEL_31:
  unsigned int v36 = v78;
  if ((v18 & 0x1000000) != 0)
  {
    llvm::ScheduleDAGInstrs::addPhysRegDataDeps(this, v79, v78);
    uint64_t v37 = *((void *)this + 3);
    uint64_t v38 = (void *)(v37 + 8);
    if (!v37) {
      uint64_t v38 = 0;
    }
    uint64_t v39 = v38[6];
    if (v39)
    {
      unint64_t v40 = (unsigned __int16 *)(v39 + 2 * *(unsigned int *)(*v38 + 24 * v8 + 4));
      unsigned __int16 v41 = v8;
      do
      {
        unsigned int v42 = v41;
        unsigned int v43 = *(unsigned __int16 *)(*((void *)this + 177) + 2 * v41);
        unsigned int v44 = *((_DWORD *)this + 304);
        if (v44 > v43)
        {
          uint64_t v46 = *((void *)this + 151);
          while (1)
          {
            unsigned int v47 = v43;
            if (*(_DWORD *)(v46 + 24 * v43 + 12) == v42)
            {
              unsigned int v56 = *(_DWORD *)(v46 + 24 * v43 + 16);
              if (v56 != -1 && *(_DWORD *)(v46 + 24 * v56 + 20) == -1) {
                break;
              }
            }
            unsigned int v43 = v47 + 0x10000;
            if (v47 + 0x10000 >= v44) {
              goto LABEL_39;
            }
          }
          sub_1CC465048((uint64_t *)this + 151, v42);
        }
LABEL_39:
        if ((~*v7 & 0x5000000) != 0) {
          sub_1CC465048((uint64_t *)this + 122, v42);
        }
        int v45 = *v40++;
        unsigned __int16 v41 = v45 + v42;
      }
      while (v45);
    }
    if ((~*v7 & 0x5000000) == 0 && (*(_WORD *)(v79 + 228) & 2) != 0)
    {
      BOOL v59 = sub_1CC46A5DC((uint64_t *)this + 122, v8);
      int v60 = v58;
      if ((uint64_t *)((char *)this + 976) != v59 || v58 != -1)
      {
        uint64_t v61 = v58 | 0xFFFFFFFFLL;
        int v62 = (uint64_t *)((char *)this + 976);
        while (1)
        {
          if (v61 == 0xFFFFFFFFLL)
          {
            uint64_t v63 = sub_1CC46A5DC(v62, HIDWORD(v61));
            uint64_t v65 = (unsigned int *)(*v63 + 24 * v64 + 16);
            uint64_t v66 = *v62;
          }
          else
          {
            uint64_t v66 = *v62;
            uint64_t v65 = (unsigned int *)(*v62 + 24 * v61 + 16);
          }
          uint64_t v67 = *v65;
          unsigned int v36 = v78;
          if ((*(_WORD *)(*(void *)(v66 + 24 * v67) + 228) & 2) == 0) {
            break;
          }
          unint64_t v68 = sub_1CC46A76C((uint64_t *)this + 122, (unsigned int *)(*((void *)this + 122) + 24 * v67));
          uint64_t v69 = *((void *)this + 122) + 24 * v67;
          unsigned int v36 = v78;
          *(_DWORD *)(v69 + 16) = -1;
          *(_DWORD *)(v69 + 20) = *((_DWORD *)this + 300);
          *((_DWORD *)this + 300) = v67;
          ++*((_DWORD *)this + 301);
          BOOL v19 = v62 == v59;
          int v62 = v68;
          if (v19)
          {
            int v62 = v68;
            if (v67 == v60) {
              break;
            }
          }
        }
      }
    }
    unint64_t v80 = v79;
    unsigned int v81 = v36;
    unsigned int v82 = v8;
    sub_1CC464314((uint64_t)this + 976, (uint64_t)&v80);
  }
  else
  {
    *(_WORD *)(v79 + 228) |= 0x20u;
    unint64_t v80 = v79;
    unsigned int v81 = v78;
    unsigned int v82 = v8;
    sub_1CC464314((uint64_t)this + 1208, (uint64_t)&v80);
    if (*((unsigned char *)this + 912)) {
      *v7 &= ~0x4000000u;
    }
  }
}

uint64_t *sub_1CC465048(uint64_t *result, unsigned int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(result[26] + 2 * a2);
  unsigned int v3 = *((_DWORD *)result + 2);
  if (v3 > v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = *result;
    while (1)
    {
      uint64_t v6 = v2;
      if (*(_DWORD *)(v5 + 24 * v2 + 12) == a2)
      {
        unsigned int v7 = *(_DWORD *)(v5 + 24 * v2 + 16);
        if (v7 != -1 && *(_DWORD *)(v5 + 24 * v7 + 20) == -1) {
          break;
        }
      }
      unsigned int v2 = v6 + 0x10000;
      if ((int)v6 + 0x10000 >= v3) {
        return result;
      }
    }
    unsigned int v8 = v6;
    do
    {
      uint64_t v9 = 3 * v6;
      double result = sub_1CC46A76C(v4, (unsigned int *)(v5 + 24 * v6));
      uint64_t v5 = *v4;
      uint64_t v11 = *v4 + 8 * v9;
      int v12 = *((_DWORD *)v4 + 56);
      int v13 = *((_DWORD *)v4 + 57);
      *(_DWORD *)(v11 + 16) = -1;
      *(_DWORD *)(v11 + 20) = v12;
      *((_DWORD *)v4 + 56) = v8;
      *((_DWORD *)v4 + 57) = v13 + 1;
      uint64_t v6 = v10;
      BOOL v14 = result == v4 && v10 == 0xFFFFFFFFLL;
      unsigned int v8 = v10;
    }
    while (!v14);
  }
  return result;
}

uint64_t llvm::ScheduleDAGInstrs::getLaneMaskForMO(llvm::ScheduleDAGInstrs *this, const llvm::MachineOperand *a2)
{
  unint64_t v2 = *(void *)(*(void *)(*((void *)this + 5) + 24) + 16 * (*((_DWORD *)a2 + 1) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
  if (!*(unsigned char *)(v2 + 34)) {
    return -1;
  }
  unint64_t v3 = ((unint64_t)*(unsigned int *)a2 >> 8) & 0xFFF;
  if (v3) {
    uint64_t v4 = *(void *)(*((void *)this + 3) + 232) + 8 * v3;
  }
  else {
    uint64_t v4 = v2 + 24;
  }
  return *(void *)v4;
}

BOOL llvm::ScheduleDAGInstrs::deadDefHasNoUse(llvm::ScheduleDAGInstrs *this, const llvm::MachineOperand *a2)
{
  uint64_t v2 = *((_DWORD *)a2 + 1) & 0x7FFFFFFF;
  unsigned int v3 = *(unsigned __int8 *)(*((void *)this + 259) + v2);
  unsigned int v4 = *((_DWORD *)this + 436);
  if (v4 <= v3) {
    return 1;
  }
  uint64_t v5 = *((void *)this + 217);
  while (1)
  {
    unsigned int v6 = v3;
    if ((*(_DWORD *)(v5 + 40 * v3) & 0x7FFFFFFF) == v2)
    {
      unsigned int v7 = *(_DWORD *)(v5 + 40 * v3 + 32);
      if (v7 != -1 && *(_DWORD *)(v5 + 40 * v7 + 36) == -1) {
        break;
      }
    }
    unsigned int v3 = v6 + 256;
    uint64_t v8 = 1;
    if (v3 >= v4) {
      return v8;
    }
  }
  uint64_t v9 = (void *)(v5 + 40 * v6 + 8);
  unint64_t v10 = *(void *)(*(void *)(*((void *)this + 5) + 24) + 16 * v2) & 0xFFFFFFFFFFFFFFF8;
  if (*(unsigned char *)(v10 + 34))
  {
    unint64_t v11 = ((unint64_t)*(unsigned int *)a2 >> 8) & 0xFFF;
    if (v11) {
      int v12 = (uint64_t *)(*(void *)(*((void *)this + 3) + 232) + 8 * v11);
    }
    else {
      int v12 = (uint64_t *)(v10 + 24);
    }
    uint64_t v13 = *v12;
  }
  else
  {
    uint64_t v13 = -1;
  }
  return (*v9 & v13) == 0;
}

uint64_t llvm::ScheduleDAGInstrs::addVRegDefDeps(uint64_t this, unint64_t a2, unsigned int a3)
{
  uint64_t v4 = this;
  uint64_t v67 = *(llvm::MachineInstr **)(a2 + 8);
  uint64_t v5 = *((void *)v67 + 4);
  unsigned int v6 = (unsigned int *)(v5 + 32 * a3);
  unint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  uint64_t v66 = v8;
  if (*(unsigned char *)(this + 914))
  {
    if ((v7 & 0xFFF00) != 0) {
      unsigned int v9 = (v7 >> 28) & 1;
    }
    else {
      unsigned int v9 = 1;
    }
    unint64_t v10 = *(void *)(*(void *)(*(void *)(this + 40) + 24) + 16 * (v8 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
    if (*(unsigned char *)(v10 + 34))
    {
      uint64_t v11 = (v7 >> 8) & 0xFFF;
      if (v11) {
        int v12 = (uint64_t *)(*(void *)(*(void *)(this + 24) + 232) + 8 * v11);
      }
      else {
        int v12 = (uint64_t *)(v10 + 24);
      }
      uint64_t v13 = *v12;
    }
    else
    {
      uint64_t v13 = -1;
    }
    if (v9) {
      uint64_t v14 = -1;
    }
    else {
      uint64_t v14 = v13;
    }
    if ((v7 & 0xFFF00) != 0 && (v7 & 0x10000000) != 0)
    {
      uint64_t v49 = *((unsigned int *)v67 + 10);
      uint64_t v50 = a3 + 1;
      if (v50 != v49)
      {
        uint64_t v51 = 32 * v49 - 32 * v50;
        unint64_t v52 = (_DWORD *)(v5 + 32 * v50 + 4);
        do
        {
          unint64_t v53 = *(v52 - 1);
          if ((v53 & 0x10000FF) == 0x1000000)
          {
            if (*v52 == v8)
            {
              if (*(unsigned char *)(v10 + 34))
              {
                uint64_t v59 = (v53 >> 8) & 0xFFF;
                if (v59) {
                  int v60 = (uint64_t *)(*(void *)(*(void *)(this + 24) + 232) + 8 * v59);
                }
                else {
                  int v60 = (uint64_t *)(v10 + 24);
                }
                uint64_t v61 = *v60;
              }
              else
              {
                uint64_t v61 = -1;
              }
              v14 &= ~v61;
            }
            uint64_t v8 = v6[1];
          }
          v52 += 8;
          v51 -= 32;
        }
        while (v51);
      }
    }
    LODWORD(v7) = v7 & 0xEFFFFFFF;
    *unsigned int v6 = v7;
  }
  else
  {
    uint64_t v14 = -1;
    uint64_t v13 = -1;
  }
  if ((~v7 & 0x5000000) != 0)
  {
    unsigned int v16 = *(unsigned __int8 *)(*(void *)(this + 2072) + (v8 & 0x7FFFFFFF));
    unsigned int v17 = *(_DWORD *)(this + 1744);
    if (v17 > v16)
    {
      uint64_t v65 = *(void *)(*(void *)(this + 32) + 16);
      uint64_t v18 = *(void *)(this + 1736);
      while (1)
      {
        if ((*(_DWORD *)(v18 + 40 * v16) & 0x7FFFFFFF) == (v8 & 0x7FFFFFFF))
        {
          unsigned int v19 = *(_DWORD *)(v18 + 40 * v16 + 32);
          if (v19 != -1 && *(_DWORD *)(v18 + 40 * v19 + 36) == -1) {
            break;
          }
        }
        v16 += 256;
        if (v16 >= v17) {
          goto LABEL_25;
        }
      }
      int v62 = (llvm::TargetSchedModel *)(this + 632);
      unint64_t v63 = a2 & 0xFFFFFFFFFFFFFFF9;
      uint64_t v64 = ~v14;
      do
      {
        uint64_t v33 = v18 + 40 * v16;
        uint64_t v34 = *(void *)(v33 + 8);
        if ((v34 & v14) != 0)
        {
          uint64_t v35 = v13;
          if ((v34 & v13) != 0)
          {
            uint64_t v36 = *(void *)(v33 + 16);
            uint64_t v37 = *(const llvm::MachineInstr **)(v36 + 8);
            *(void *)&long long v69 = v63;
            *((void *)&v69 + 1) = v8 | 0x100000000;
            HIDWORD(v69) = llvm::TargetSchedModel::computeOperandLatency(v62, v67, a3, v37, *(unsigned int *)(v18 + 40 * v16 + 24));
            uint64_t v8 = v66;
            (*(void (**)(void))(*(void *)v65 + 304))();
            this = llvm::SUnit::addPred(v36, (uint64_t *)&v69, 1);
            uint64_t v18 = *(void *)(v4 + 1736);
          }
          uint64_t v13 = v35;
          if ((v34 & v64) != 0)
          {
            uint64_t v48 = v18 + 40 * v16;
            *(void *)(v48 + 8) = v34 & v64;
            unsigned int v41 = *(_DWORD *)(v48 + 36);
          }
          else
          {
            uint64_t v38 = (_DWORD *)(v18 + 40 * v16);
            uint64_t v39 = v38 + 8;
            unsigned int v40 = v38[8];
            if (v16 == v40)
            {
              unsigned int v41 = -1;
            }
            else
            {
              uint64_t v43 = v18 + 40 * v16;
              unsigned int v46 = *(_DWORD *)(v43 + 36);
              unsigned int v44 = (unsigned int *)(v43 + 36);
              unsigned int v45 = v46;
              if (*(_DWORD *)(v18 + 40 * v40 + 36) == -1)
              {
                *(unsigned char *)(*(void *)(v4 + 2072) + (*v38 & 0x7FFFFFFF)) = v45;
                unsigned int v41 = *v44;
                uint64_t v18 = *(void *)(v4 + 1736);
                *(_DWORD *)(v18 + 40 * v41 + 32) = *v39;
              }
              else if (v45 == -1)
              {
                uint64_t v54 = *v38 & 0x7FFFFFFF;
                unsigned int v55 = *(unsigned __int8 *)(*(void *)(v4 + 2072) + v54);
                unsigned int v56 = *(_DWORD *)(v4 + 1744);
                unsigned int v41 = -1;
                if (v56 <= v55)
                {
                  unsigned int v58 = -1;
                }
                else
                {
                  while (1)
                  {
                    if ((*(_DWORD *)(v18 + 40 * v55) & 0x7FFFFFFF) == v54)
                    {
                      unsigned int v57 = *(_DWORD *)(v18 + 40 * v55 + 32);
                      if (v57 != -1 && *(_DWORD *)(v18 + 40 * v57 + 36) == -1) {
                        break;
                      }
                    }
                    v55 += 256;
                    unsigned int v58 = -1;
                    if (v55 >= v56) {
                      goto LABEL_83;
                    }
                  }
                  unsigned int v58 = v55;
                }
LABEL_83:
                *(_DWORD *)(v18 + 40 * v58 + 32) = v40;
                *(_DWORD *)(v18 + 40 * *v39 + 36) = -1;
              }
              else
              {
                *(_DWORD *)(v18 + 40 * v45 + 32) = v40;
                *(_DWORD *)(v18 + 40 * *v39 + 36) = v45;
                unsigned int v41 = *v44;
              }
            }
            uint64_t v42 = v18 + 40 * v16;
            *(_DWORD *)(v42 + 32) = -1;
            *(_DWORD *)(v42 + 36) = *(_DWORD *)(v4 + 2088);
            *(_DWORD *)(v4 + 2088) = v16;
            ++*(_DWORD *)(v4 + 2092);
          }
        }
        else
        {
          unsigned int v41 = *(_DWORD *)(v18 + 40 * v16 + 36);
        }
        unsigned int v16 = v41;
      }
      while (v41 != -1);
    }
  }
LABEL_25:
  uint64_t v20 = *(void *)(v4 + 40);
  if ((v8 & 0x80000000) != 0) {
    unsigned int v21 = (uint64_t *)(*(void *)(v20 + 24) + 16 * (v8 & 0x7FFFFFFF) + 8);
  }
  else {
    unsigned int v21 = (uint64_t *)(*(void *)(v20 + 272) + 8 * v8);
  }
  uint64_t v22 = *v21;
  if (!v22
    || (*(unsigned char *)(v22 + 3) & 1) == 0 && ((uint64_t v22 = *(void *)(v22 + 24)) == 0 || (*(unsigned char *)(v22 + 3) & 1) == 0)
    || (uint64_t v47 = *(void *)(v22 + 24)) != 0 && (*(unsigned char *)(v47 + 3) & 1) != 0)
  {
    uint64_t v23 = (uint64_t *)(v4 + 1440);
    unsigned int v24 = *(unsigned __int8 *)(*(void *)(v4 + 1712) + (v8 & 0x7FFFFFFF));
    unsigned int v25 = *(_DWORD *)(v4 + 1448);
    if (v25 > v24)
    {
      uint64_t v26 = *v23;
      while (1)
      {
        if ((*(_DWORD *)(v26 + 32 * v24) & 0x7FFFFFFF) == (v8 & 0x7FFFFFFF))
        {
          uint64_t v27 = *(unsigned int *)(v26 + 32 * v24 + 24);
          if (v27 != -1 && *(_DWORD *)(v26 + 32 * v27 + 28) == -1) {
            break;
          }
        }
        v24 += 256;
        if (v24 >= v25) {
          goto LABEL_42;
        }
      }
      do
      {
        uint64_t v28 = v24;
        uint64_t v29 = v26 + 32 * v24;
        if ((*(void *)(v29 + 8) & v13) != 0)
        {
          uint64_t v30 = *(const llvm::MachineInstr ***)(v29 + 16);
          if (v30 != (const llvm::MachineInstr **)a2)
          {
            unint64_t v71 = a2 & 0xFFFFFFFFFFFFFFF9 | 4;
            int v72 = v8;
            int v73 = llvm::TargetSchedModel::computeOutputLatency((llvm::TargetSchedModel *)(v4 + 632), v67, a3, v30[1]);
            this = llvm::SUnit::addPred((uint64_t)v30, (uint64_t *)&v71, 1);
            uint64_t v31 = *(void *)(v29 + 8);
            *(void *)(v29 + 8) = v31 & v13;
            *(void *)(v29 + 16) = a2;
            uint64_t v32 = v31 & ~v13;
            if (v32)
            {
              LODWORD(v69) = v8;
              *((void *)&v69 + 1) = v32;
              unint64_t v70 = (unint64_t)v30;
              this = sub_1CC390AA0(v4 + 1440, &v69);
            }
            uint64_t v26 = *v23;
          }
        }
        unsigned int v24 = *(_DWORD *)(v26 + 32 * v28 + 28);
      }
      while (v24 != -1);
    }
LABEL_42:
    if (v13)
    {
      LODWORD(v69) = v8;
      *((void *)&v69 + 1) = v13;
      unint64_t v70 = a2;
      return sub_1CC390AA0(v4 + 1440, &v69);
    }
  }
  return this;
}

uint64_t llvm::ScheduleDAGInstrs::addChainDependency(llvm::AAResults **this, unint64_t a2, const llvm::MachineInstr **a3, int a4)
{
  uint64_t result = llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(a2 + 8), this[262], a3[1], byte_1EBCD38C0);
  if (result)
  {
    unint64_t v8 = a2 | 6;
    int v9 = 1;
    int v10 = a4;
    return llvm::SUnit::addPred((uint64_t)a3, (uint64_t *)&v8, 1);
  }
  return result;
}

void llvm::ScheduleDAGInstrs::initSUnits(llvm::ScheduleDAGInstrs *this)
{
  uint64_t v38 = (uint64_t *)((char *)this + 48);
  sub_1CC465C50((uint64_t *)this + 6, *((unsigned int *)this + 236));
  uint64_t v2 = *((void *)this + 116);
  uint64_t v3 = *((void *)this + 117);
  if (v2 == v3) {
    return;
  }
  do
  {
    unsigned int v4 = **(unsigned __int16 **)(v2 + 16);
    BOOL v5 = v4 > 0x17;
    int v6 = (1 << v4) & 0x83E000;
    if (!v5 && v6 != 0)
    {
LABEL_41:
      if ((*(unsigned char *)v2 & 4) == 0) {
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    unint64_t v8 = *((void *)this + 7);
    int v9 = -252645135 * ((v8 - *((void *)this + 6)) >> 4);
    if (v8 >= *((void *)this + 8))
    {
      uint64_t v10 = sub_1CC4698C8(v38, v2, v9);
    }
    else
    {
      *(void *)unint64_t v8 = 0;
      *(void *)(v8 + 8) = v2;
      *(void *)(v8 + 16) = 0;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 32) = v8 + 48;
      *(void *)(v8 + 40) = 0x400000000;
      *(void *)(v8 + 112) = v8 + 128;
      *(void *)(v8 + 120) = 0x400000000;
      *(_DWORD *)(v8 + 192) = v9;
      *(_DWORD *)(v8 + 232) = 0;
      *(_OWORD *)(v8 + 196) = 0u;
      *(_OWORD *)(v8 + 212) = 0u;
      *(_WORD *)(v8 + 228) = 0;
      *(unsigned char *)(v8 + 236) &= 0xFCu;
      uint64_t v10 = v8 + 272;
      *(_OWORD *)(v8 + 240) = 0u;
      *(_OWORD *)(v8 + 256) = 0u;
    }
    *((void *)this + 7) = v10;
    uint64_t v39 = v2;
    int v11 = *((_DWORD *)this + 242);
    if (!v11)
    {
      unsigned int v21 = 0;
LABEL_23:
      int v15 = sub_1CC38046C((uint64_t)this + 952, (uint64_t)&v39, &v39, v21);
      *int v15 = v39;
      v15[1] = 0;
      goto LABEL_24;
    }
    uint64_t v12 = *((void *)this + 119);
    int v13 = v11 - 1;
    unsigned int v14 = v13 & ((v2 >> 4) ^ (v2 >> 9));
    int v15 = (void *)(v12 + 16 * v14);
    uint64_t v16 = *v15;
    if (v2 != *v15)
    {
      unsigned int v17 = 0;
      int v18 = 1;
      while (v16 != -4096)
      {
        if (v17) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v16 == -8192;
        }
        if (v19) {
          unsigned int v17 = v15;
        }
        unsigned int v20 = v14 + v18++;
        unsigned int v14 = v20 & v13;
        int v15 = (void *)(v12 + 16 * v14);
        uint64_t v16 = *v15;
        if (v2 == *v15) {
          goto LABEL_24;
        }
      }
      if (v17) {
        unsigned int v21 = v17;
      }
      else {
        unsigned int v21 = v15;
      }
      goto LABEL_23;
    }
LABEL_24:
    v15[1] = v10 - 272;
    __int16 v22 = *(_WORD *)(v2 + 44);
    uint64_t v23 = *(void *)(*(void *)(v2 + 16) + 8);
    if ((v22 & 0xC) != 0 && (v22 & 4) == 0)
    {
      uint64_t v37 = v2;
      if ((v23 & 0x80) == 0)
      {
        while ((*(_WORD *)(v37 + 44) & 8) != 0)
        {
          uint64_t v37 = *(void *)(v37 + 8);
          if ((*(unsigned char *)(*(void *)(v37 + 16) + 8) & 0x80) != 0) {
            goto LABEL_56;
          }
        }
        __int16 v26 = 0;
        unsigned int v25 = (_WORD *)(v10 - 44);
        __int16 v24 = *(_WORD *)(v10 - 44);
        goto LABEL_29;
      }
LABEL_56:
      unsigned int v25 = (_WORD *)(v10 - 44);
      __int16 v24 = *(_WORD *)(v10 - 44);
LABEL_28:
      __int16 v26 = 2;
      goto LABEL_29;
    }
    unsigned int v25 = (_WORD *)(v10 - 44);
    __int16 v24 = *(_WORD *)(v10 - 44);
    if ((v23 & 0x80) != 0) {
      goto LABEL_28;
    }
    __int16 v26 = 0;
LABEL_29:
    __int16 v27 = v26 | v24 & 0xFFFD;
    *(_WORD *)(v10 - 44) = v27;
    *(_WORD *)(v10 - 44) = (*(_DWORD *)(*(void *)(v2 + 16) + 8) >> 21) & 0x10 | v27 & 0xFFEF;
    *(_WORD *)(v10 - 46) = llvm::TargetSchedModel::computeInstrLatency((llvm::ScheduleDAGInstrs *)((char *)this + 632), *(const llvm::MachineInstr **)(v10 - 264), 1);
    if (!byte_1EBD06248) {
      goto LABEL_41;
    }
    uint64_t v28 = *((void *)this + 84);
    if (!v28) {
      goto LABEL_41;
    }
    uint64_t v29 = *(_WORD **)(v10 - 248);
    if (!v29)
    {
      uint64_t v29 = (_WORD *)(v28 + 24 * *(unsigned __int16 *)(*(void *)(*(void *)(v10 - 264) + 16) + 6));
      if ((v29[4] & 0x1FFF) == 0x1FFE)
      {
        do
        {
          unsigned int v35 = (*(uint64_t (**)(void))(**((void **)this + 101) + 200))(*((void *)this + 101));
          uint64_t v36 = *((void *)this + 84);
        }
        while ((*(_WORD *)(v36 + 24 * v35 + 8) & 0x1FFF) == 0x1FFE);
        uint64_t v29 = (_WORD *)(v36 + 24 * v35);
      }
      *(void *)(v10 - 248) = v29;
    }
    uint64_t v30 = (unsigned __int16)v29[6];
    if (!v29[6]) {
      goto LABEL_41;
    }
    uint64_t v31 = (unsigned __int16 *)(*(void *)(*((void *)this + 101) + 136) + 4 * (unsigned __int16)v29[5]);
    uint64_t v32 = 4 * v30;
    do
    {
      int v33 = *(_DWORD *)(*((void *)this + 83) + 32 * *v31 + 16);
      if (!v33)
      {
        __int16 v34 = 0x8000;
LABEL_38:
        *v25 |= v34;
        goto LABEL_39;
      }
      if (v33 == 1)
      {
        __int16 v34 = 0x4000;
        goto LABEL_38;
      }
LABEL_39:
      v31 += 2;
      v32 -= 4;
    }
    while (v32);
    if (v2) {
      goto LABEL_41;
    }
LABEL_42:
    while ((*(_WORD *)(v2 + 44) & 8) != 0)
      uint64_t v2 = *(void *)(v2 + 8);
LABEL_43:
    uint64_t v2 = *(void *)(v2 + 8);
  }
  while (v2 != v3);
}

void sub_1CC465C50(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = (char *)*a1;
  if (0xF0F0F0F0F0F0F0F1 * ((a1[2] - *a1) >> 4) < a2)
  {
    if (a2 >= 0xF0F0F0F0F0F0F1) {
      abort();
    }
    uint64_t v4 = a1[1];
    uint64_t v5 = 17 * a2;
    int v6 = (char *)operator new(272 * a2);
    unint64_t v7 = &v6[16 * v5];
    uint64_t v8 = (uint64_t)&v6[v4 - (void)v2];
    if ((char *)v4 == v2)
    {
      *a1 = v8;
      a1[1] = v8;
      a1[2] = (uint64_t)v7;
    }
    else
    {
      uint64_t v12 = v8;
      int v13 = v7;
      do
      {
        v4 -= 272;
        uint64_t v8 = sub_1CD57A99C(v8 - 272, v4);
      }
      while ((char *)v4 != v2);
      uint64_t v2 = (char *)*a1;
      int v9 = (char *)a1[1];
      *a1 = v8;
      a1[1] = v12;
      a1[2] = (uint64_t)v13;
      while (v9 != v2)
      {
        uint64_t v10 = (char *)*((void *)v9 - 20);
        if (v9 - 144 != v10) {
          free(v10);
        }
        int v11 = (char *)*((void *)v9 - 30);
        if (v9 - 224 != v11) {
          free(v11);
        }
        v9 -= 272;
      }
    }
    if (v2)
    {
      operator delete(v2);
    }
  }
}

uint64_t llvm::ScheduleDAGInstrs::addChainDependencies(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 24);
  uint64_t v11 = *(void *)(a3 + 32);
  if (v3 != v11)
  {
    uint64_t v5 = result;
    uint64_t v6 = a2 | 6;
    do
    {
      uint64_t v7 = *(void *)(v3 + 16);
      if (v7 != v3 + 8)
      {
        int v8 = *(_DWORD *)(a3 + 52);
        do
        {
          uint64_t v9 = *(void *)(v7 + 16);
          uint64_t result = llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(a2 + 8), *(llvm::AAResults **)(v5 + 2096), *(const llvm::MachineInstr **)(v9 + 8), byte_1EBCD38C0);
          if (result)
          {
            uint64_t v12 = v6;
            int v13 = 1;
            int v14 = v8;
            uint64_t result = llvm::SUnit::addPred(v9, &v12, 1);
          }
          uint64_t v7 = *(void *)(v7 + 8);
        }
        while (v7 != v3 + 8);
      }
      v3 += 32;
    }
    while (v3 != v11);
  }
  return result;
}

uint64_t llvm::ScheduleDAGInstrs::addChainDependencies(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v5 = result;
  uint64_t v6 = *a3;
  uint64_t v7 = *((unsigned int *)a3 + 4);
  if (v7)
  {
    LODWORD(v9) = (v7 - 1) & (37 * a4);
    int v8 = (uint64_t *)(v6 + 16 * v9);
    uint64_t v10 = *v8;
    if (a4 == *v8) {
      goto LABEL_3;
    }
    int v11 = 1;
    while (v10 != -4096)
    {
      int v12 = v9 + v11++;
      uint64_t v9 = v12 & (v7 - 1);
      uint64_t v10 = *(void *)(v6 + 16 * v9);
      if (a4 == v10)
      {
        int v8 = (uint64_t *)(v6 + 16 * v9);
        goto LABEL_3;
      }
    }
  }
  int v8 = (uint64_t *)(v6 + 16 * v7);
LABEL_3:
  if ((uint64_t *)(v6 + 16 * v7) != v8)
  {
    uint64_t v13 = a3[3] + 32 * *((unsigned int *)v8 + 2);
    if (v13 != a3[4])
    {
      uint64_t v14 = v13 + 8;
      uint64_t v15 = *(void *)(v13 + 16);
      if (v15 != v13 + 8)
      {
        int v16 = *((_DWORD *)a3 + 13);
        do
        {
          uint64_t v17 = *(void *)(v15 + 16);
          uint64_t result = llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(a2 + 8), *(llvm::AAResults **)(v5 + 2096), *(const llvm::MachineInstr **)(v17 + 8), byte_1EBCD38C0);
          if (result)
          {
            uint64_t v18 = a2 | 6;
            int v19 = 1;
            int v20 = v16;
            uint64_t result = llvm::SUnit::addPred(v17, &v18, 1);
          }
          uint64_t v15 = *(void *)(v15 + 8);
        }
        while (v15 != v14);
      }
    }
  }
  return result;
}

void *llvm::ScheduleDAGInstrs::addBarrierChain(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  for (uint64_t i = (void *)(a2 + 24); v4 != v5; v4 += 32)
  {
    for (uint64_t j = *(void *)(v4 + 16); j != v4 + 8; uint64_t j = *(void *)(j + 8))
      sub_1CC466058(*(void *)(j + 16), *(void *)(a1 + 2104));
  }
  if (*(void *)(a2 + 8))
  {
    uint64_t v9 = *(unsigned int *)(a2 + 16);
    if (v9 > 4 * *(_DWORD *)(a2 + 8) && v9 >= 0x41)
    {
      sub_1CD3C8060((_DWORD *)a2);
    }
    else
    {
      if (v9)
      {
        uint64_t v10 = *(void **)a2;
        uint64_t v11 = 16 * v9;
        do
        {
          *uint64_t v10 = -4096;
          v10 += 2;
          v11 -= 16;
        }
        while (v11);
      }
      *(void *)(a2 + 8) = 0;
    }
  }
  uint64_t result = sub_1CC469BDC(i, *(void *)(a2 + 24));
  *(_DWORD *)(a2 + 48) = 0;
  return result;
}

uint64_t sub_1CC466058(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = a2 | 6;
  uint64_t v13 = 0;
  uint64_t v2 = *(void *)(a2 + 8);
  uint64_t v3 = *(unsigned __int16 **)(v2 + 16);
  if (*v3 - 1 > 1 || (*(unsigned char *)(*(void *)(v2 + 32) + 48) & 0x10) == 0)
  {
    uint64_t v4 = *((void *)v3 + 1);
    if ((*(_WORD *)(v2 + 44) & 0xC) != 0 && (*(_WORD *)(v2 + 44) & 4) == 0)
    {
      if ((v4 & 0x100000) == 0)
      {
        while ((*(_WORD *)(v2 + 44) & 8) != 0)
        {
          uint64_t v2 = *(void *)(v2 + 8);
          if ((*(unsigned char *)(*(void *)(v2 + 16) + 10) & 0x10) != 0) {
            goto LABEL_7;
          }
        }
        goto LABEL_26;
      }
    }
    else if ((v4 & 0x100000) == 0)
    {
      goto LABEL_26;
    }
  }
LABEL_7:
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(unsigned __int16 **)(v6 + 16);
  if (*v7 - 1 <= 1 && (*(unsigned char *)(*(void *)(v6 + 32) + 48) & 8) != 0) {
    goto LABEL_21;
  }
  uint64_t v8 = *((void *)v7 + 1);
  if ((*(_WORD *)(v6 + 44) & 0xC) != 0 && (*(_WORD *)(v6 + 44) & 4) == 0)
  {
    if ((v8 & 0x80000) != 0)
    {
LABEL_21:
      unsigned int v10 = 1;
      goto LABEL_13;
    }
    while ((*(_WORD *)(v6 + 44) & 8) != 0)
    {
      uint64_t v6 = *(void *)(v6 + 8);
      unsigned int v10 = 1;
      if ((*(unsigned char *)(*(void *)(v6 + 16) + 10) & 8) != 0) {
        goto LABEL_13;
      }
    }
LABEL_26:
    unsigned int v10 = 0;
    goto LABEL_13;
  }
  unsigned int v10 = (v8 >> 19) & 1;
LABEL_13:
  HIDWORD(v13) = v10;
  return llvm::SUnit::addPred(a1, &v12, 1);
}

uint64_t llvm::ScheduleDAGInstrs::buildSchedGraph(llvm::ScheduleDAGInstrs *this, llvm::AAResults *a2, llvm::RegPressureTracker *a3, llvm::PressureDiffs *a4, llvm::LiveIntervals *a5, int a6)
{
  v424[2] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(*((void *)this + 4) + 16);
  uint64_t v373 = v10;
  if (word_1EBCD3788) {
    int v11 = byte_1EBCD3800 != 0;
  }
  else {
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 368))(v10);
  }
  uint64_t v12 = a2;
  if (!v11) {
    uint64_t v12 = 0;
  }
  *((void *)this + 262) = v12;
  *((void *)this + 263) = 0;
  *((unsigned char *)this + 914) = a6;
  uint64_t v13 = (void *)((char *)this + 952);
  int v14 = *((_DWORD *)this + 240);
  int v371 = a6;
  uint64_t v377 = a3;
  if (v14)
  {
    unsigned int v15 = *((_DWORD *)this + 242);
    if (v15 > 4 * v14 && v15 >= 0x41)
    {
      int v16 = 1 << (33 - __clz(v14 - 1));
      if (v16 <= 64) {
        int v17 = 64;
      }
      else {
        int v17 = v16;
      }
LABEL_11:
      if (v17 == v15)
      {
        *((void *)this + 120) = 0;
        uint64_t v23 = (void *)*((void *)this + 119);
        uint64_t v24 = 16 * v15;
        do
        {
          *uint64_t v23 = -4096;
          v23 += 2;
          v24 -= 16;
        }
        while (v24);
      }
      else
      {
        MEMORY[0x1D25D9CD0](*v13, 8);
        if (v17)
        {
          unint64_t v18 = (4 * v17 / 3u + 1) | ((unint64_t)(4 * v17 / 3u + 1) >> 1);
          unint64_t v19 = v18 | (v18 >> 2) | ((v18 | (v18 >> 2)) >> 4);
          LODWORD(v19) = (((v19 | (v19 >> 8)) >> 16) | v19 | (v19 >> 8)) + 1;
          *((_DWORD *)this + 242) = v19;
          int v20 = operator new(16 * v19, (std::align_val_t)8uLL);
          *((void *)this + 119) = v20;
          *((void *)this + 120) = 0;
          uint64_t v21 = *((unsigned int *)this + 242);
          if (v21)
          {
            uint64_t v22 = 16 * v21;
            do
            {
              *int v20 = -4096;
              v20 += 2;
              v22 -= 16;
            }
            while (v22);
          }
        }
        else
        {
          *uint64_t v13 = 0;
          *((void *)this + 120) = 0;
          *((_DWORD *)this + 242) = 0;
        }
      }
      goto LABEL_29;
    }
  }
  else
  {
    if (!*((_DWORD *)this + 241)) {
      goto LABEL_29;
    }
    unsigned int v15 = *((_DWORD *)this + 242);
    if (v15 > 0x40)
    {
      int v17 = 0;
      goto LABEL_11;
    }
  }
  if (v15)
  {
    unsigned int v25 = (void *)*v13;
    uint64_t v26 = 16 * v15;
    do
    {
      *unsigned int v25 = -4096;
      v25 += 2;
      v26 -= 16;
    }
    while (v26);
  }
  *((void *)this + 120) = 0;
LABEL_29:
  sub_1CC463D08((uint64_t)this + 48, *((void *)this + 6));
  memset(&v411[3], 0, 32);
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 28) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 66) = -1;
  *((_WORD *)this + 150) = 0;
  *(_OWORD *)((char *)this + 268) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  *((_DWORD *)this + 76) = 0;
  *((unsigned char *)this + 308) = 0;
  long long v27 = *(_OWORD *)&v411[16];
  *(_OWORD *)((char *)this + 309) = *(_OWORD *)v411;
  *(_OWORD *)((char *)this + 325) = v27;
  *((_DWORD *)this + 85) = *(_DWORD *)&v411[31];
  memset(&v411[3], 0, 32);
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_DWORD *)this + 96) = 0;
  *((_DWORD *)this + 116) = 0;
  *((_DWORD *)this + 134) = -1;
  *(_OWORD *)((char *)this + 540) = 0u;
  v372 = (char *)this + 344;
  *(_OWORD *)((char *)this + 556) = 0u;
  *((_WORD *)this + 286) = 0;
  *((_DWORD *)this + 144) = 0;
  *((unsigned char *)this + 580) = 0;
  long long v28 = *(_OWORD *)&v411[16];
  *(_OWORD *)((char *)this + 581) = *(_OWORD *)v411;
  *(_OWORD *)((char *)this + 597) = v28;
  *((_DWORD *)this + 153) = *(_DWORD *)&v411[31];
  llvm::ScheduleDAGInstrs::initSUnits(this);
  if (a4)
  {
    unint64_t v29 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)this + 7) - *((void *)this + 6)) >> 4);
    *((_DWORD *)a4 + 2) = v29;
    if (*((_DWORD *)a4 + 3) < v29)
    {
      *((_DWORD *)a4 + 3) = v29;
      free(*(void **)a4);
      long long v249 = malloc_type_calloc(v29, 0x40uLL, 0x6D9A4F0CuLL);
      if (!v249)
      {
        uint64_t v319 = "Allocation failed";
        goto LABEL_585;
      }
      *(void *)a4 = v249;
    }
    else
    {
      bzero(*(void **)a4, (unint64_t)v29 << 6);
    }
  }
  uint64_t v403 = 0;
  v402 = 0;
  unsigned int v404 = 0;
  long long v405 = 0u;
  long long v406 = 0u;
  uint64_t v396 = 0;
  int v395 = 0;
  unsigned int v397 = 0;
  v398 = 0;
  BOOL v399 = 0;
  uint64_t v400 = 0;
  uint64_t v401 = 0x100000000;
  uint64_t v390 = 0;
  uint64_t v391 = 0;
  unsigned int v392 = 0;
  long long v393 = 0u;
  long long v394 = 0u;
  int v383 = 0;
  uint64_t v384 = 0;
  unsigned int v385 = 0;
  v386 = 0;
  v387 = 0;
  uint64_t v388 = 0;
  *(void *)uint64_t v389 = 0x100000000;
  uint64_t v378 = 0;
  uint64_t v379 = 0;
  unsigned int v380 = 0;
  long long __p = 0u;
  long long v382 = 0u;
  *((void *)this + 318) = *((void *)this + 317);
  *((void *)this + 320) = 0;
  size_t v30 = *(unsigned int *)(*((void *)this + 3) + 16);
  unsigned int v31 = *((_DWORD *)this + 298);
  if (v31 < v30 || v31 >> 2 > v30)
  {
    free(*((void **)this + 148));
    int v250 = malloc_type_calloc(v30, 2uLL, 0x6D9A4F0CuLL);
    if (!v250)
    {
      if (v30) {
        goto LABEL_597;
      }
      int v250 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v250) {
        goto LABEL_597;
      }
    }
    *((void *)this + 148) = v250;
    *((_DWORD *)this + 298) = v30;
    LODWORD(v30) = *(_DWORD *)(*((void *)this + 3) + 16);
  }
  unsigned int v32 = *((_DWORD *)this + 356);
  if (v32 < v30 || v32 >> 2 > v30)
  {
    free(*((void **)this + 177));
    size_t v251 = malloc_type_calloc(v30, 2uLL, 0x6D9A4F0CuLL);
    if (!v251)
    {
      if (v30) {
        goto LABEL_597;
      }
      size_t v251 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v251) {
        goto LABEL_597;
      }
    }
    *((void *)this + 177) = v251;
    *((_DWORD *)this + 356) = v30;
  }
  size_t v33 = *(unsigned int *)(*((void *)this + 5) + 32);
  unsigned int v34 = *((_DWORD *)this + 430);
  if (v34 < v33 || v34 >> 2 > v33)
  {
    free(*((void **)this + 214));
    size_t v252 = malloc_type_calloc(v33, 1uLL, 0x6D9A4F0CuLL);
    if (v252 || !v33 && (size_t v252 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      *((void *)this + 214) = v252;
      *((_DWORD *)this + 430) = v33;
      goto LABEL_38;
    }
LABEL_597:
    uint64_t v319 = "Allocation failed";
LABEL_585:
    llvm::report_bad_alloc_error((llvm *)v319, (const char *)1);
  }
LABEL_38:
  unsigned int v35 = *((_DWORD *)this + 520);
  if (v35 >= v33 && v35 >> 2 <= v33) {
    goto LABEL_40;
  }
  free(*((void **)this + 259));
  size_t v253 = malloc_type_calloc(v33, 1uLL, 0x6D9A4F0CuLL);
  if (!v253)
  {
    if (v33) {
      goto LABEL_597;
    }
    size_t v253 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
    if (!v253) {
      goto LABEL_597;
    }
  }
  *((void *)this + 259) = v253;
  *((_DWORD *)this + 520) = v33;
LABEL_40:
  llvm::ScheduleDAGInstrs::addSchedBarrierDeps(this);
  unint64_t v36 = *((void *)this + 117);
  uint64_t v375 = *((void *)this + 116);
  if (v36 == v375) {
    goto LABEL_346;
  }
  unint64_t v37 = 0;
  do
  {
    unint64_t v38 = *(void *)v36 & 0xFFFFFFFFFFFFFFF8;
    if (!v38 || (*(unsigned char *)v38 & 4) == 0)
    {
      while ((*(_WORD *)(v38 + 44) & 4) != 0)
        unint64_t v38 = *(void *)v38 & 0xFFFFFFFFFFFFFFF8;
    }
    if (v37)
    {
      *(void *)int v411 = v37;
      *(void *)&v411[8] = v38;
      BOOL v292 = (_OWORD *)*((void *)this + 318);
      if ((unint64_t)v292 >= *((void *)this + 319))
      {
        size_t v293 = sub_1CC00319C((void **)this + 317, v411);
      }
      else
      {
        *BOOL v292 = *(_OWORD *)v411;
        size_t v293 = v292 + 1;
      }
      *((void *)this + 318) = v293;
    }
    unsigned int v39 = **(unsigned __int16 **)(v38 + 16);
    if (v39 <= 0x17)
    {
      int v40 = 1 << v39;
      if ((v40 & 0x16000) != 0)
      {
        unint64_t v37 = v38;
        goto LABEL_132;
      }
      if ((v40 & 0x828000) != 0) {
        goto LABEL_131;
      }
    }
    *(void *)int v411 = v38;
    int v41 = *((_DWORD *)this + 242);
    if (v41)
    {
      uint64_t v42 = *((void *)this + 119);
      int v43 = v41 - 1;
      unsigned int v44 = v43 & ((v38 >> 4) ^ (v38 >> 9));
      unsigned int v45 = (void *)(v42 + 16 * v44);
      uint64_t v46 = *v45;
      if (v38 == *v45) {
        goto LABEL_64;
      }
      uint64_t v47 = 0;
      int v48 = 1;
      while (v46 != -4096)
      {
        if (v47) {
          BOOL v49 = 0;
        }
        else {
          BOOL v49 = v46 == -8192;
        }
        if (v49) {
          uint64_t v47 = v45;
        }
        unsigned int v50 = v44 + v48++;
        unsigned int v44 = v50 & v43;
        unsigned int v45 = (void *)(v42 + 16 * v44);
        uint64_t v46 = *v45;
        if (v38 == *v45) {
          goto LABEL_64;
        }
      }
      if (v47) {
        uint64_t v51 = v47;
      }
      else {
        uint64_t v51 = v45;
      }
    }
    else
    {
      uint64_t v51 = 0;
    }
    unsigned int v45 = sub_1CC38046C((uint64_t)this + 952, (uint64_t)v411, (uint64_t *)v411, v51);
    *unsigned int v45 = *(void *)v411;
    v45[1] = 0;
LABEL_64:
    unint64_t v52 = v45[1];
    if (!a3) {
      goto LABEL_93;
    }
    *(void *)int v411 = &v411[16];
    *(void *)&v411[8] = 0x800000000;
    size_t v413 = v415;
    uint64_t v414 = 0x800000000;
    v416 = v418;
    uint64_t v417 = 0x800000000;
    llvm::RegisterOperands::collect(v411, (const llvm::MachineInstr *)v38, *((const llvm::TargetRegisterInfo **)this + 3), *((const llvm::MachineRegisterInfo **)this + 5), a6, 0);
    if (a6)
    {
      __int16 v53 = *(_WORD *)(v38 + 44);
      unint64_t v54 = v38;
      unint64_t v55 = v38;
      if ((v53 & 0xC) != 0)
      {
        unint64_t v54 = v38;
        if ((v53 & 4) != 0)
        {
          unint64_t v54 = v38;
          do
            unint64_t v54 = *(void *)v54 & 0xFFFFFFFFFFFFFFF8;
          while ((*(_WORD *)(v54 + 44) & 4) != 0);
        }
        unint64_t v55 = v38;
        if ((v53 & 8) != 0)
        {
          do
            unint64_t v55 = *(void *)(v55 + 8);
          while ((*(_WORD *)(v55 + 44) & 8) != 0);
        }
        a6 = v371;
      }
      unint64_t v56 = *(void *)(v55 + 8);
      if (v54 != v56)
      {
        while (1)
        {
          unsigned int v57 = **(unsigned __int16 **)(v54 + 16);
          BOOL v58 = v57 > 0x17;
          int v59 = (1 << v57) & 0x83E000;
          if (v58 || v59 == 0) {
            break;
          }
          unint64_t v54 = *(void *)(v54 + 8);
          if (v54 == v56)
          {
            unint64_t v54 = v56;
            break;
          }
        }
      }
      uint64_t v61 = *((void *)a5 + 36);
      uint64_t v62 = *(void *)(v61 + 368);
      uint64_t v63 = *(unsigned int *)(v61 + 384);
      if (v63)
      {
        LODWORD(v64) = ((v54 >> 4) ^ (v54 >> 9)) & (v63 - 1);
        uint64_t v65 = (uint64_t *)(v62 + 16 * v64);
        uint64_t v66 = *v65;
        if (v54 == *v65)
        {
LABEL_75:
          llvm::RegisterOperands::adjustLaneLiveness((uint64_t)v411, (uint64_t)a5, *((void *)this + 5), v65[1], 0);
          goto LABEL_76;
        }
        int v99 = 1;
        while (v66 != -4096)
        {
          int v100 = v64 + v99++;
          uint64_t v64 = v100 & (v63 - 1);
          uint64_t v66 = *(void *)(v62 + 16 * v64);
          if (v54 == v66)
          {
            uint64_t v65 = (uint64_t *)(v62 + 16 * v64);
            goto LABEL_75;
          }
        }
      }
      uint64_t v65 = (uint64_t *)(v62 + 16 * v63);
      goto LABEL_75;
    }
LABEL_76:
    if (a4)
    {
      uint64_t v67 = (void *)*((void *)this + 5);
      uint64_t v68 = *(void *)a4 + ((unint64_t)*(unsigned int *)(v52 + 192) << 6);
      if (v414)
      {
        BOOL v96 = (unsigned int *)v413;
        uint64_t v97 = 16 * v414;
        do
        {
          unsigned int v98 = *v96;
          v96 += 4;
          llvm::PressureDiff::addPressureChange(v68, v98, 1, v67);
          v97 -= 16;
        }
        while (v97);
      }
      if (*(_DWORD *)&v411[8])
      {
        long long v69 = *(unsigned int **)v411;
        uint64_t v70 = 16 * *(unsigned int *)&v411[8];
        do
        {
          unsigned int v71 = *v69;
          v69 += 4;
          llvm::PressureDiff::addPressureChange(v68, v71, 0, v67);
          v70 -= 16;
        }
        while (v70);
      }
    }
    a3 = v377;
    uint64_t v72 = *((void *)v377 + 8);
    if (v72 != v38 || v72 == *((void *)this + 117)) {
      llvm::RegPressureTracker::recedeSkipDebugValues((unint64_t)v377);
    }
    llvm::RegPressureTracker::recede((uint64_t)v377, (unsigned int **)v411, 0);
    if (v416 != v418) {
      free(v416);
    }
    if (v413 != v415) {
      free(v413);
    }
    if (*(unsigned char **)v411 != &v411[16]) {
      free(*(void **)v411);
    }
LABEL_93:
    uint64_t v74 = *(unsigned int *)(v38 + 40);
    if (v74)
    {
      uint64_t v75 = 0;
      uint64_t v76 = 0;
      char v77 = 0;
      do
      {
        uint64_t v78 = *(void *)(v38 + 32);
        if ((*(_DWORD *)(v78 + v75) & 0x10000FF) == 0x1000000)
        {
          int v79 = *(_DWORD *)(v78 + v75 + 4);
          if ((v79 - 1) <= 0x3FFFFFFE)
          {
            llvm::ScheduleDAGInstrs::addPhysRegDeps(this, (llvm::SUnit *)v52, v76);
          }
          else if (v79 < 0)
          {
            llvm::ScheduleDAGInstrs::addVRegDefDeps((uint64_t)this, v52, v76);
            char v77 = 1;
          }
        }
        ++v76;
        v75 += 32;
      }
      while (v74 != v76);
      uint64_t v80 = *(unsigned int *)(v38 + 40);
      if (v80)
      {
        uint64_t v81 = 0;
        for (uint64_t i = 0; i != v80; ++i)
        {
          uint64_t v83 = *(void *)(v38 + 32);
          int v84 = *(_DWORD *)(v83 + v81);
          if ((v84 & 0x10000FF) == 0)
          {
            int v85 = *(_DWORD *)(v83 + v81 + 4);
            if ((v85 - 1) <= 0x3FFFFFFE)
            {
              llvm::ScheduleDAGInstrs::addPhysRegDeps(this, (llvm::SUnit *)v52, i);
            }
            else if ((v84 & 0x30000000) == 0 && v85 < 0)
            {
              llvm::ScheduleDAGInstrs::addVRegUseDeps((uint64_t)this, v52, i);
            }
          }
          v81 += 32;
        }
      }
      a3 = v377;
    }
    else
    {
      char v77 = 0;
    }
    if (!*(_DWORD *)(v52 + 204))
    {
      unsigned int v101 = *(unsigned __int16 *)(v52 + 226);
      if (v101 >= 2)
      {
        if ((v77 & 1) != 0
          || (int v102 = *(unsigned __int16 **)(v38 + 16), *v102 - 1 <= 1)
          && (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 8) != 0)
        {
LABEL_146:
          *(void *)int v411 = v52 | 6;
          *(_DWORD *)&v411[8] = 3;
          *(_DWORD *)&v411[12] = v101 - 1;
          (*(void (**)(uint64_t, unint64_t, void, char *, void, unsigned char *))(*(void *)v373 + 304))(v373, v52, 0, v372, 0, v411);
          llvm::SUnit::addPred((uint64_t)v372, (uint64_t *)v411, 1);
          goto LABEL_112;
        }
        __int16 v103 = *(_WORD *)(v38 + 44);
        uint64_t v104 = *((void *)v102 + 1);
        if ((v103 & 0xC) != 0 && (v103 & 4) == 0)
        {
          unint64_t v311 = v38;
          if ((v104 & 0x80000) != 0) {
            goto LABEL_146;
          }
          while ((*(_WORD *)(v311 + 44) & 8) != 0)
          {
            unint64_t v311 = *(void *)(v311 + 8);
            if ((*(unsigned char *)(*(void *)(v311 + 16) + 10) & 8) != 0) {
              goto LABEL_146;
            }
          }
        }
        else if ((v104 & 0x80000) != 0)
        {
          goto LABEL_146;
        }
      }
    }
LABEL_112:
    unint64_t v86 = *(unsigned __int16 **)(v38 + 16);
    uint64_t v87 = *((void *)v86 + 1);
    if ((*(_WORD *)(v38 + 44) & 0xC) != 0 && (*(_WORD *)(v38 + 44) & 4) == 0)
    {
      unint64_t v294 = v38;
      if ((v87 & 0x80) != 0) {
        goto LABEL_204;
      }
      while ((*(_WORD *)(v294 + 44) & 8) != 0)
      {
        unint64_t v294 = *(void *)(v294 + 8);
        a6 = v371;
        a3 = v377;
        if ((*(unsigned char *)(*(void *)(v294 + 16) + 8) & 0x80) != 0) {
          goto LABEL_204;
        }
      }
      a6 = v371;
      a3 = v377;
      if ((v87 & 0x1000000) != 0)
      {
LABEL_204:
        uint64_t v132 = *((void *)this + 263);
        if (v132) {
          sub_1CC466058(v132, v52);
        }
        *((void *)this + 263) = v52;
        uint64_t v133 = *((void *)&v405 + 1);
        uint64_t v134 = v405;
        for (uint64_t j = v405; j != v133; a3 = v377)
        {
          for (uint64_t k = *(void *)(j + 16); k != j + 8; uint64_t k = *(void *)(k + 8))
            sub_1CC466058(*(void *)(k + 16), *((void *)this + 263));
          j += 32;
          a6 = v371;
        }
        if (v403)
        {
          if (v404 > 4 * (int)v403 && v404 >= 0x41)
          {
            sub_1CD3C8060(&v402);
            uint64_t v134 = v405;
          }
          else
          {
            if (v404)
            {
              uint64_t v148 = v402;
              uint64_t v149 = 16 * v404;
              do
              {
                void *v148 = -4096;
                v148 += 2;
                v149 -= 16;
              }
              while (v149);
            }
            uint64_t v403 = 0;
          }
        }
        sub_1CC469BDC(&v405, v134);
        DWORD2(v406) = 0;
        uint64_t v136 = v398;
        uint64_t v137 = v399;
        uint64_t v138 = (char *)v398;
        if (v398 != v399)
        {
          do
          {
            for (m = (char *)*((void *)v138 + 2); m != v138 + 8; m = (char *)*((void *)m + 1))
              sub_1CC466058(*((void *)m + 2), *((void *)this + 263));
            v138 += 32;
            a6 = v371;
            a3 = v377;
          }
          while (v138 != v137);
        }
        if (v396)
        {
          if (v397 > 4 * (int)v396 && v397 >= 0x41)
          {
            sub_1CD3C8060(&v395);
            uint64_t v136 = v398;
          }
          else
          {
            if (v397)
            {
              uint64_t v150 = v395;
              uint64_t v151 = 16 * v397;
              do
              {
                *uint64_t v150 = -4096;
                v150 += 2;
                v151 -= 16;
              }
              while (v151);
            }
            uint64_t v396 = 0;
          }
        }
        sub_1CC469BDC(&v398, (uint64_t)v136);
        LODWORD(v401) = 0;
        uint64_t v139 = *((void *)&v393 + 1);
        uint64_t v140 = v393;
        for (uint64_t n = v393; n != v139; a3 = v377)
        {
          for (iuint64_t i = *(void *)(n + 16); ii != n + 8; iuint64_t i = *(void *)(ii + 8))
            sub_1CC466058(*(void *)(ii + 16), *((void *)this + 263));
          n += 32;
          a6 = v371;
        }
        if (v391)
        {
          if (v392 > 4 * (int)v391 && v392 >= 0x41)
          {
            sub_1CD3C8060(&v390);
            uint64_t v140 = v393;
          }
          else
          {
            if (v392)
            {
              long long v152 = v390;
              uint64_t v153 = 16 * v392;
              do
              {
                *long long v152 = -4096;
                v152 += 2;
                v153 -= 16;
              }
              while (v153);
            }
            uint64_t v391 = 0;
          }
        }
        sub_1CC469BDC(&v393, v140);
        DWORD2(v394) = 0;
        uint64_t v143 = v386;
        size_t v142 = v387;
        size_t v144 = v386;
        if (v386 != v387)
        {
          do
          {
            for (juint64_t j = (void *)v144[2]; jj != v144 + 1; juint64_t j = (void *)jj[1])
              sub_1CC466058(jj[2], *((void *)this + 263));
            v144 += 4;
            a6 = v371;
            a3 = v377;
          }
          while (v144 != v142);
        }
        if (v384)
        {
          if (v385 > 4 * (int)v384 && v385 >= 0x41)
          {
            sub_1CD3C8060(&v383);
            uint64_t v143 = v386;
          }
          else
          {
            if (v385)
            {
              int v154 = v383;
              uint64_t v155 = 16 * v385;
              do
              {
                *int v154 = -4096;
                v154 += 2;
                v155 -= 16;
              }
              while (v155);
            }
            uint64_t v384 = 0;
          }
        }
        sub_1CC469BDC(&v386, (uint64_t)v143);
        v389[0] = 0;
        uint64_t v145 = *((void *)&__p + 1);
        uint64_t v146 = __p;
        for (uint64_t kk = __p; kk != v145; a3 = v377)
        {
          for (uint64_t mm = *(void *)(kk + 16); mm != kk + 8; uint64_t mm = *(void *)(mm + 8))
            sub_1CC466058(*(void *)(mm + 16), *((void *)this + 263));
          kk += 32;
          a6 = v371;
        }
        if (v379)
        {
          if (v380 > 4 * (int)v379 && v380 >= 0x41)
          {
            sub_1CD3C8060(&v378);
            uint64_t v146 = __p;
          }
          else
          {
            if (v380)
            {
              uint64_t v156 = v378;
              uint64_t v157 = 16 * v380;
              do
              {
                *uint64_t v156 = -4096;
                v156 += 2;
                v157 -= 16;
              }
              while (v157);
            }
            uint64_t v379 = 0;
          }
        }
        sub_1CC469BDC(&__p, v146);
        unint64_t v37 = 0;
        DWORD2(v382) = 0;
        goto LABEL_132;
      }
      unint64_t v295 = v38;
      while ((*(_WORD *)(v295 + 44) & 8) != 0)
      {
        unint64_t v295 = *(void *)(v295 + 8);
        if (*(unsigned char *)(*(void *)(v295 + 16) + 11)) {
          goto LABEL_204;
        }
      }
    }
    else if ((v87 & 0x1000080) != 0)
    {
      goto LABEL_204;
    }
    if (*v86 - 1 <= 1 && (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 1) != 0
      || llvm::MachineInstr::hasOrderedMemoryRef((llvm::MachineInstr *)v38)
      && (llvm::MachineInstr::isDereferenceableInvariantLoad((llvm::MachineInstr *)v38, a2) & 1) == 0)
    {
      goto LABEL_204;
    }
    __int16 v89 = *(_WORD *)(v38 + 44);
    uint64_t v90 = *(void *)(*(void *)(v38 + 16) + 8);
    if ((v89 & 0xC) != 0 && (v89 & 4) == 0)
    {
      unint64_t v298 = v38;
      if ((v90 & 0x200000) == 0)
      {
        while ((*(_WORD *)(v298 + 44) & 8) != 0)
        {
          unint64_t v298 = *(void *)(v298 + 8);
          if ((*(unsigned char *)(*(void *)(v298 + 16) + 10) & 0x20) != 0) {
            goto LABEL_518;
          }
        }
        goto LABEL_122;
      }
LABEL_518:
      if ((*(_WORD *)(v38 + 44) & 0x4000) == 0)
      {
        uint64_t v299 = *((void *)this + 263);
        if (v299) {
          sub_1CC466058(v299, v52);
        }
        *(void *)int v411 = *((void *)this + 264) & 0xFFFFFFFFFFFFFFFBLL;
        uint64_t v300 = (uint64_t *)sub_1CC469C70((uint64_t)&v378, (uint64_t *)v411);
        size_t v301 = operator new(0x18uLL);
        v301[1] = v300;
        v301[2] = v52;
        *size_t v301 = 0;
        uint64_t v302 = *v300;
        *size_t v301 = *v300;
        *(void *)(v302 + 8) = v301;
        *uint64_t v300 = (uint64_t)v301;
        ++v300[2];
        ++DWORD2(v382);
        a6 = v371;
        a3 = v377;
        if (DWORD2(v382) >= dword_1EBCD3980)
        {
          memset(v411, 0, 20);
          *(_OWORD *)&v411[24] = 0u;
          long long v412 = 0u;
          if (word_1EBCD39C8) {
            unsigned int v303 = dword_1EBCD3A40;
          }
          else {
            unsigned int v303 = dword_1EBCD3980 >> 1;
          }
          llvm::ScheduleDAGInstrs::reduceHugeMemNodeMaps((uint64_t)this, (int32x2_t *)&v378, (int32x2_t *)v411, v303);
          sub_1CC46A240(v411);
        }
      }
      goto LABEL_122;
    }
    if ((v90 & 0x200000) != 0) {
      goto LABEL_518;
    }
LABEL_122:
    int v91 = *(unsigned __int16 **)(v38 + 16);
    unsigned int v92 = *v91 - 1;
    if (v92 <= 1 && (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 0x10) != 0) {
      goto LABEL_155;
    }
    unsigned int v93 = *(unsigned __int16 *)(v38 + 44);
    BOOL v49 = (v93 & 0xC) == 0;
    int v94 = (v93 >> 2) & 1;
    if (v49) {
      LOBYTE(v94) = 1;
    }
    uint64_t v95 = *((void *)v91 + 1);
    if (v94)
    {
      if ((v95 & 0x100000) != 0) {
        goto LABEL_155;
      }
    }
    else
    {
      unint64_t v296 = v38;
      if ((v95 & 0x100000) != 0) {
        goto LABEL_155;
      }
      while ((*(_WORD *)(v296 + 44) & 8) != 0)
      {
        unint64_t v296 = *(void *)(v296 + 8);
        if ((*(unsigned char *)(*(void *)(v296 + 16) + 10) & 0x10) != 0) {
          goto LABEL_155;
        }
      }
    }
    if (v92 <= 1 && (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 8) != 0) {
      goto LABEL_154;
    }
    if (v94)
    {
      if ((v95 & 0x80000) == 0)
      {
LABEL_131:
        unint64_t v37 = 0;
        goto LABEL_132;
      }
LABEL_154:
      if (llvm::MachineInstr::isDereferenceableInvariantLoad((llvm::MachineInstr *)v38, a2)) {
        goto LABEL_131;
      }
LABEL_155:
      uint64_t v105 = *((void *)this + 263);
      if (v105) {
        sub_1CC466058(v105, v52);
      }
      *(void *)int v411 = &v411[16];
      *(void *)&v411[8] = 0x400000000;
      v408 = v410;
      uint64_t v409 = 0x400000000;
      uint64_t v407 = *((void *)this + 78);
      v422 = v424;
      uint64_t v423 = 0x200000000;
      uint64_t v419 = (uint64_t *)v421;
      uint64_t v420 = 0x200000000;
      uint64_t v107 = (int *)(v38 + 48);
      unint64_t v106 = *(void *)(v38 + 48);
      if (v106 < 8)
      {
        unsigned int v112 = 0;
        uint64_t v111 = v424;
      }
      else
      {
        if ((v106 & 7) == 0)
        {
          *(void *)(v38 + 48) = v106 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v108 = v38 + 56;
          goto LABEL_160;
        }
        unsigned int v112 = 0;
        if ((*(void *)(v38 + 48) & 7) == 3)
        {
          uint64_t v111 = v424;
          int v304 = (int *)(v106 & 0xFFFFFFFFFFFFFFF8);
          a6 = v371;
          if ((v106 & 0xFFFFFFFFFFFFFFF8) != 0)
          {
            uint64_t v306 = *v304;
            uint64_t v107 = v304 + 2;
            uint64_t v305 = v306;
            if (!v306)
            {
              unsigned int v112 = 0;
              goto LABEL_534;
            }
            unint64_t v108 = (unint64_t)&v107[2 * v305];
            a6 = v371;
            do
            {
LABEL_160:
              if ((*(_WORD *)(*(void *)v107 + 32) & 2) != 0)
              {
                uint64_t v109 = v423;
                if (v423 >= (unint64_t)HIDWORD(v423)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v110 = &v422;
              }
              else
              {
                uint64_t v109 = v420;
                if (v420 >= (unint64_t)HIDWORD(v420)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v110 = &v419;
              }
              (*v110)[v109] = *(void *)v107;
              ++*((_DWORD *)v110 + 2);
              v107 += 2;
            }
            while (v107 != (int *)v108);
            uint64_t v111 = v422;
            unsigned int v112 = v423;
          }
        }
        else
        {
LABEL_534:
          uint64_t v111 = v424;
          a6 = v371;
        }
      }
      char v113 = sub_1CC46A290(&v407, v111, v112, (uint64_t)v411);
      if ((v113 & 1) == 0) {
        *(_DWORD *)&v411[8] = 0;
      }
      char v114 = sub_1CC46A290(&v407, v419, v420, (uint64_t)&v408);
      if ((v114 & 1) == 0) {
        LODWORD(v409) = 0;
      }
      if (v419 != (uint64_t *)v421) {
        free(v419);
      }
      if (v422 != v424) {
        free(v422);
      }
      if ((v113 & 1) == 0)
      {
        uint64_t v158 = v405;
        if ((void)v405 != *((void *)&v405 + 1))
        {
          int v254 = HIDWORD(v406);
          uint64_t v367 = *((void *)&v405 + 1);
          do
          {
            for (nuint64_t n = *(void *)(v158 + 16); nn != v158 + 8; nuint64_t n = *(void *)(nn + 8))
            {
              uint64_t v243 = *(void *)(nn + 16);
              if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v243 + 8), byte_1EBCD38C0))
              {
                v422 = (uint64_t *)(v52 | 6);
                LODWORD(v423) = 1;
                HIDWORD(v423) = v254;
                llvm::SUnit::addPred(v243, (uint64_t *)&v422, 1);
              }
            }
            v158 += 32;
            a6 = v371;
          }
          while (v158 != v367);
        }
        uint64_t v160 = *((void *)&v393 + 1);
        uint64_t v159 = v393;
        if ((void)v393 != *((void *)&v393 + 1))
        {
          int v315 = HIDWORD(v394);
          do
          {
            for (uint64_t i1 = *(void *)(v159 + 16); i1 != v159 + 8; uint64_t i1 = *(void *)(i1 + 8))
              llvm::ScheduleDAGInstrs::addChainDependency((llvm::AAResults **)this, v52, *(const llvm::MachineInstr ***)(i1 + 16), v315);
            v159 += 32;
            a6 = v371;
          }
          while (v159 != v160);
        }
        int v161 = (char *)v398;
        v162 = v399;
        if (v398 != v399)
        {
          int v256 = HIDWORD(v401);
          do
          {
            for (i2 = (char *)*((void *)v161 + 2); i2 != v161 + 8; i2 = (char *)*((void *)i2 + 1))
            {
              uint64_t v247 = *((void *)i2 + 2);
              if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v247 + 8), byte_1EBCD38C0))
              {
                v422 = (uint64_t *)(v52 | 6);
                LODWORD(v423) = 1;
                HIDWORD(v423) = v256;
                llvm::SUnit::addPred(v247, (uint64_t *)&v422, 1);
              }
            }
            v161 += 32;
            a6 = v371;
          }
          while (v161 != v162);
        }
        uint64_t v163 = v386;
        uint64_t v164 = v387;
        if (v386 != v387)
        {
          int v317 = v389[1];
          do
          {
            for (uint64_t i3 = v163[2]; (void *)i3 != v163 + 1; uint64_t i3 = *(void *)(i3 + 8))
              llvm::ScheduleDAGInstrs::addChainDependency((llvm::AAResults **)this, v52, *(const llvm::MachineInstr ***)(i3 + 16), v317);
            v163 += 4;
            a6 = v371;
          }
          while (v163 != v164);
        }
        v422 = (uint64_t *)(*((void *)this + 264) & 0xFFFFFFFFFFFFFFFBLL);
        uint64_t v165 = (uint64_t *)sub_1CC469C70((uint64_t)&v402, (uint64_t *)&v422);
        uint64_t v166 = operator new(0x18uLL);
        v166[1] = v165;
        v166[2] = v52;
        *uint64_t v166 = 0;
        uint64_t v167 = *v165;
        *uint64_t v166 = *v165;
        *(void *)(v167 + 8) = v166;
        *uint64_t v165 = (uint64_t)v166;
        ++v165[2];
        ++DWORD2(v406);
        a3 = v377;
        goto LABEL_197;
      }
      uint64_t v115 = *(unsigned __int16 **)(v38 + 16);
      a3 = v377;
      if (*v115 - 1 > 1 || (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 0x10) == 0)
      {
        __int16 v116 = *(_WORD *)(v38 + 44);
        uint64_t v117 = *((void *)v115 + 1);
        if ((v116 & 0xC) != 0 && (v116 & 4) == 0)
        {
          unint64_t v314 = v38;
          if ((v117 & 0x100000) != 0) {
            goto LABEL_313;
          }
          while ((*(_WORD *)(v314 + 44) & 8) != 0)
          {
            unint64_t v314 = *(void *)(v314 + 8);
            if ((*(unsigned char *)(*(void *)(v314 + 16) + 10) & 0x10) != 0) {
              goto LABEL_313;
            }
          }
        }
        else if ((v117 & 0x100000) != 0)
        {
          goto LABEL_313;
        }
        goto LABEL_180;
      }
LABEL_313:
      int32x2_t v224 = (int32x2_t)v395;
      uint64_t v223 = v397;
      if (!*(_DWORD *)&v411[8])
      {
LABEL_314:
        if (!v223) {
          goto LABEL_315;
        }
        unint64_t v257 = *((void *)this + 264) & 0xFFFFFFFFFFFFFFFBLL;
        LODWORD(v193) = (37 * v257) & (v223 - 1);
        uint64_t v290 = *(void *)&v224 + 16 * v193;
        uint64_t v194 = *(void *)v290;
        if (v257 != *(void *)v290)
        {
          int v192 = 1;
          while (v194 != -4096)
          {
            int v191 = v193 + v192++;
            uint64_t v193 = v191 & (v223 - 1);
            uint64_t v194 = *(void *)(*(void *)&v224 + 16 * v193);
            if (v257 == v194)
            {
              uint64_t v290 = *(void *)&v224 + 16 * v193;
              goto LABEL_316;
            }
          }
LABEL_315:
          uint64_t v290 = *(void *)&v224 + 16 * v223;
        }
LABEL_316:
        a3 = v377;
        if (*(void *)&v224 + 16 * v223 != v290)
        {
          v282 = (char *)v398 + 32 * *(unsigned int *)(v290 + 8);
          if (v282 != v399)
          {
            unsigned int v283 = v282 + 8;
            uint64_t v284 = *((void *)v282 + 2);
            if ((char *)v284 != v282 + 8)
            {
              int v369 = HIDWORD(v401);
              do
              {
                uint64_t v285 = *(void *)(v284 + 16);
                if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v285 + 8), byte_1EBCD38C0))
                {
                  v422 = (uint64_t *)(v52 | 6);
                  LODWORD(v423) = 1;
                  HIDWORD(v423) = v369;
                  llvm::SUnit::addPred(v285, (uint64_t *)&v422, 1);
                }
                uint64_t v284 = *(void *)(v284 + 8);
                a3 = v377;
              }
              while ((char *)v284 != v283);
            }
          }
        }
        if (v404)
        {
          unint64_t v258 = *((void *)this + 264) & 0xFFFFFFFFFFFFFFFBLL;
          LODWORD(v197) = (37 * v258) & (v404 - 1);
          uint64_t v291 = (uint64_t)&v402[2 * v197];
          uint64_t v198 = *(void *)v291;
          if (v258 != *(void *)v291)
          {
            int v196 = 1;
            while (v198 != -4096)
            {
              int v195 = v197 + v196++;
              uint64_t v197 = v195 & (v404 - 1);
              uint64_t v198 = v402[2 * v197];
              if (v258 == v198)
              {
                uint64_t v291 = (uint64_t)&v402[2 * v197];
                goto LABEL_319;
              }
            }
            goto LABEL_318;
          }
        }
        else
        {
LABEL_318:
          uint64_t v291 = (uint64_t)&v402[2 * v404];
        }
LABEL_319:
        if (&v402[2 * v404] != (void *)v291)
        {
          uint64_t v286 = v405 + 32 * *(unsigned int *)(v291 + 8);
          if (v286 != *((void *)&v405 + 1))
          {
            uint64_t v287 = v286 + 8;
            uint64_t v288 = *(void *)(v286 + 16);
            if (v288 != v286 + 8)
            {
              int v370 = HIDWORD(v406);
              do
              {
                uint64_t v289 = *(void *)(v288 + 16);
                if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v289 + 8), byte_1EBCD38C0))
                {
                  v422 = (uint64_t *)(v52 | 6);
                  LODWORD(v423) = 1;
                  HIDWORD(v423) = v370;
                  llvm::SUnit::addPred(v289, (uint64_t *)&v422, 1);
                }
                uint64_t v288 = *(void *)(v288 + 8);
                a3 = v377;
              }
              while (v288 != v287);
            }
          }
        }
LABEL_180:
        uint64_t v118 = *(unsigned __int16 **)(v38 + 16);
        if (*v118 - 1 > 1 || (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 8) == 0)
        {
          uint64_t v119 = *((void *)v118 + 1);
          if ((*(_WORD *)(v38 + 44) & 0xC) != 0 && (*(_WORD *)(v38 + 44) & 4) == 0)
          {
            unint64_t v310 = v38;
            if ((v119 & 0x80000) != 0) {
              goto LABEL_186;
            }
            while ((*(_WORD *)(v310 + 44) & 8) != 0)
            {
              unint64_t v310 = *(void *)(v310 + 8);
              if ((*(unsigned char *)(*(void *)(v310 + 16) + 10) & 8) != 0) {
                goto LABEL_186;
              }
            }
          }
          else if ((v119 & 0x80000) != 0)
          {
            goto LABEL_186;
          }
          goto LABEL_191;
        }
LABEL_186:
        if (llvm::MachineInstr::isDereferenceableInvariantLoad((llvm::MachineInstr *)v38, a2)) {
          goto LABEL_191;
        }
        if ((v114 & 1) == 0)
        {
          uint64_t v122 = *((void *)&v405 + 1);
          uint64_t v121 = v405;
          if ((void)v405 != *((void *)&v405 + 1))
          {
            int v364 = HIDWORD(v406);
            do
            {
              for (uint64_t i4 = *(void *)(v121 + 16); i4 != v121 + 8; uint64_t i4 = *(void *)(i4 + 8))
              {
                uint64_t v245 = *(void *)(i4 + 16);
                if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v245 + 8), byte_1EBCD38C0))
                {
                  v422 = (uint64_t *)(v52 | 6);
                  LODWORD(v423) = 1;
                  HIDWORD(v423) = v364;
                  llvm::SUnit::addPred(v245, (uint64_t *)&v422, 1);
                }
              }
              v121 += 32;
            }
            while (v121 != v122);
          }
          uint64_t v124 = *((void *)&v393 + 1);
          uint64_t v123 = v393;
          if ((void)v393 != *((void *)&v393 + 1))
          {
            int v312 = HIDWORD(v394);
            do
            {
              for (uint64_t i5 = *(void *)(v123 + 16); i5 != v123 + 8; uint64_t i5 = *(void *)(i5 + 8))
                llvm::ScheduleDAGInstrs::addChainDependency((llvm::AAResults **)this, v52, *(const llvm::MachineInstr ***)(i5 + 16), v312);
              v123 += 32;
            }
            while (v123 != v124);
          }
          v422 = (uint64_t *)(*((void *)this + 264) & 0xFFFFFFFFFFFFFFFBLL);
          uint64_t v125 = (uint64_t *)sub_1CC469C70((uint64_t)&v395, (uint64_t *)&v422);
          uint64_t v126 = operator new(0x18uLL);
          v126[1] = v125;
          v126[2] = v52;
          *uint64_t v126 = 0;
          uint64_t v127 = *v125;
          *uint64_t v126 = *v125;
          *(void *)(v127 + 8) = v126;
          *uint64_t v125 = (uint64_t)v126;
          ++v125[2];
          LODWORD(v401) = v401 + 1;
          a3 = v377;
          goto LABEL_191;
        }
        int32x2_t v190 = (int32x2_t)v402;
        uint64_t v183 = v404;
        if (!v409)
        {
LABEL_260:
          a3 = v377;
          if (!v183) {
            goto LABEL_261;
          }
          unint64_t v255 = *((void *)this + 264) & 0xFFFFFFFFFFFFFFFBLL;
          LODWORD(v170) = (37 * v255) & (v183 - 1);
          uint64_t v273 = *(void *)&v190 + 16 * v170;
          uint64_t v171 = *(void *)v273;
          if (v255 != *(void *)v273)
          {
            int v169 = 1;
            while (v171 != -4096)
            {
              int v168 = v170 + v169++;
              uint64_t v170 = v168 & (v183 - 1);
              uint64_t v171 = *(void *)(*(void *)&v190 + 16 * v170);
              if (v255 == v171)
              {
                uint64_t v273 = *(void *)&v190 + 16 * v170;
                goto LABEL_262;
              }
            }
LABEL_261:
            uint64_t v273 = *(void *)&v190 + 16 * v183;
          }
LABEL_262:
          if (*(void *)&v190 + 16 * v183 != v273)
          {
            uint64_t v268 = v405 + 32 * *(unsigned int *)(v273 + 8);
            if (v268 != *((void *)&v405 + 1))
            {
              uint64_t v269 = v268 + 8;
              uint64_t v270 = *(void *)(v268 + 16);
              if (v270 != v268 + 8)
              {
                int v271 = HIDWORD(v406);
                do
                {
                  uint64_t v272 = *(void *)(v270 + 16);
                  if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v272 + 8), byte_1EBCD38C0))
                  {
                    v422 = (uint64_t *)(v52 | 6);
                    LODWORD(v423) = 1;
                    HIDWORD(v423) = v271;
                    llvm::SUnit::addPred(v272, (uint64_t *)&v422, 1);
                  }
                  uint64_t v270 = *(void *)(v270 + 8);
                  a3 = v377;
                }
                while (v270 != v269);
              }
            }
          }
LABEL_191:
          uint64_t v128 = *(unsigned __int16 **)(v38 + 16);
          a6 = v371;
          if (*v128 - 1 <= 1 && (*(unsigned char *)(*(void *)(v38 + 32) + 48) & 0x10) != 0)
          {
LABEL_321:
            if (*(_DWORD *)&v411[8])
            {
              uint64_t v234 = *(uint64_t **)v411;
              uint64_t v241 = 8 * *(unsigned int *)&v411[8];
              do
              {
                uint64_t v235 = *v234++;
                int v236 = (uint64_t *)(v235 & 0xFFFFFFFFFFFFFFFCLL);
                if ((v235 & 2) != 0) {
                  uint64_t v237 = (int32x2_t *)&v402;
                }
                else {
                  uint64_t v237 = (int32x2_t *)&v390;
                }
                v422 = v236;
                size_t v238 = (uint64_t *)sub_1CC469C70((uint64_t)v237, (uint64_t *)&v422);
                size_t v239 = operator new(0x18uLL);
                v239[1] = v238;
                v239[2] = v52;
                *size_t v239 = 0;
                uint64_t v240 = *v238;
                *size_t v239 = *v238;
                *(void *)(v240 + 8) = v239;
                *size_t v238 = (uint64_t)v239;
                ++v238[2];
                a3 = v377;
                ++v237[6].i32[0];
                v241 -= 8;
              }
              while (v241);
            }
          }
          else
          {
            uint64_t v129 = *((void *)v128 + 1);
            if ((*(_WORD *)(v38 + 44) & 0xC) != 0 && (*(_WORD *)(v38 + 44) & 4) == 0)
            {
              if ((v129 & 0x100000) != 0) {
                goto LABEL_321;
              }
              while ((*(_WORD *)(v38 + 44) & 8) != 0)
              {
                unint64_t v38 = *(void *)(v38 + 8);
                if ((*(unsigned char *)(*(void *)(v38 + 16) + 10) & 0x10) != 0) {
                  goto LABEL_321;
                }
              }
            }
            else if ((v129 & 0x100000) != 0)
            {
              goto LABEL_321;
            }
          }
LABEL_197:
          unsigned int v131 = dword_1EBCD3980;
          if ((int)v401 + DWORD2(v406) >= dword_1EBCD3980)
          {
            if (word_1EBCD39C8) {
              unsigned int v307 = dword_1EBCD3A40;
            }
            else {
              unsigned int v307 = dword_1EBCD3980 >> 1;
            }
            llvm::ScheduleDAGInstrs::reduceHugeMemNodeMaps((uint64_t)this, (int32x2_t *)&v402, (int32x2_t *)&v395, v307);
            unsigned int v131 = dword_1EBCD3980;
          }
          if (v389[0] + DWORD2(v394) >= v131)
          {
            unsigned int v308 = v131 >> 1;
            if (word_1EBCD39C8) {
              int v309 = dword_1EBCD3A40;
            }
            else {
              int v309 = v308;
            }
            llvm::ScheduleDAGInstrs::reduceHugeMemNodeMaps((uint64_t)this, (int32x2_t *)&v390, (int32x2_t *)&v383, v309);
          }
          if (v408 != v410) {
            free(v408);
          }
          if (*(unsigned char **)v411 != &v411[16]) {
            free(*(void **)v411);
          }
          goto LABEL_131;
        }
        int v182 = (char *)v408;
        int32x2_t v361 = (int32x2_t)v390;
        uint64_t v363 = (char *)v408 + 8 * v409;
        unsigned int v359 = v392;
        uint64_t v355 = *((void *)&v393 + 1);
        uint64_t v357 = v393;
        uint64_t v351 = *((void *)&v405 + 1);
        uint64_t v353 = v405;
        int v349 = HIDWORD(v394);
        int v347 = HIDWORD(v406);
        uint64_t v366 = v404;
        while (2)
        {
          uint64_t v172 = *(void *)v182;
          unint64_t v173 = *(void *)v182 & 0xFFFFFFFFFFFFFFFCLL;
          if ((*(void *)v182 & 2) != 0) {
            int32x2_t v174 = v190;
          }
          else {
            int32x2_t v174 = v361;
          }
          if ((*(void *)v182 & 2) != 0) {
            unsigned int v175 = v183;
          }
          else {
            unsigned int v175 = v359;
          }
          uint64_t v176 = *(void *)&v174 + 16 * v175;
          if (v175)
          {
            unsigned int v184 = v175 - 1;
            LODWORD(v185) = (v175 - 1) & (37 * v173);
            uint64_t v177 = *(void *)&v174 + 16 * v185;
            uint64_t v186 = *(void *)v177;
            if (v173 != *(void *)v177)
            {
              int v187 = 1;
              while (v186 != -4096)
              {
                int v188 = v185 + v187++;
                uint64_t v185 = v188 & v184;
                uint64_t v186 = *(void *)(*(void *)&v174 + 16 * v185);
                if (v173 == v186)
                {
                  uint64_t v177 = *(void *)&v174 + 16 * v185;
                  goto LABEL_244;
                }
              }
              goto LABEL_243;
            }
          }
          else
          {
LABEL_243:
            uint64_t v177 = v176;
          }
LABEL_244:
          if (v176 != v177)
          {
            uint64_t v264 = v357;
            if ((v172 & 2) != 0) {
              uint64_t v264 = v353;
            }
            uint64_t v265 = v264 + 32 * *(unsigned int *)(v177 + 8);
            uint64_t v266 = v355;
            if ((v172 & 2) != 0) {
              uint64_t v266 = v351;
            }
            if (v265 != v266)
            {
              int v267 = v349;
              if ((v172 & 2) != 0) {
                int v267 = v347;
              }
              int v340 = v267;
              uint64_t v189 = *(void *)(v265 + 16);
              for (i6 = v265 + 8; v189 != i6; uint64_t v189 = *(void *)(v189 + 8))
              {
                uint64_t v345 = *(void *)(v189 + 16);
                if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v345 + 8), byte_1EBCD38C0))
                {
                  v422 = (uint64_t *)(v52 | 6);
                  LODWORD(v423) = 1;
                  HIDWORD(v423) = v340;
                  llvm::SUnit::addPred(v345, (uint64_t *)&v422, 1);
                }
              }
            }
          }
          if ((v172 & 2) != 0) {
            uint64_t v178 = (int32x2_t *)&v395;
          }
          else {
            uint64_t v178 = (int32x2_t *)&v383;
          }
          v422 = (uint64_t *)v173;
          uint64_t v179 = (uint64_t *)sub_1CC469C70((uint64_t)v178, (uint64_t *)&v422);
          int v180 = operator new(0x18uLL);
          v180[1] = v179;
          v180[2] = v52;
          *int v180 = 0;
          uint64_t v181 = *v179;
          *int v180 = *v179;
          *(void *)(v181 + 8) = v180;
          uint64_t *v179 = (uint64_t)v180;
          ++v179[2];
          ++v178[6].i32[0];
          v182 += 8;
          uint64_t v183 = v366;
          if (v182 == v363) {
            goto LABEL_260;
          }
          continue;
        }
      }
      int v209 = *(uint64_t **)v411;
      int32x2_t v225 = (int32x2_t)v390;
      uint64_t v226 = *(void *)v411 + 8 * *(unsigned int *)&v411[8];
      int32x2_t v227 = (int32x2_t)v402;
      unsigned int v228 = v392;
      unsigned int v229 = v404;
      uint64_t v365 = *((void *)&v393 + 1);
      uint64_t v368 = v393;
      uint64_t v360 = *((void *)&v405 + 1);
      uint64_t v362 = v405;
      int v358 = HIDWORD(v394);
      int v356 = HIDWORD(v406);
      int32x2_t v230 = (int32x2_t)v383;
      unsigned int v231 = v385;
      uint64_t v352 = (char *)v387;
      v354 = (char *)v386;
      v348 = v399;
      uint64_t v350 = (char *)v398;
      unsigned int v346 = v389[1];
      unsigned int v343 = HIDWORD(v401);
      while (2)
      {
        uint64_t v199 = *v209;
        unint64_t v200 = *v209 & 0xFFFFFFFFFFFFFFFCLL;
        if ((*v209 & 2) != 0) {
          int32x2_t v201 = v227;
        }
        else {
          int32x2_t v201 = v225;
        }
        if ((*v209 & 2) != 0) {
          unsigned int v202 = v229;
        }
        else {
          unsigned int v202 = v228;
        }
        uint64_t v203 = *(void *)&v201 + 16 * v202;
        if (v202)
        {
          unsigned int v210 = v202 - 1;
          LODWORD(v211) = (v202 - 1) & (37 * v200);
          uint64_t v204 = *(void *)&v201 + 16 * v211;
          uint64_t v212 = *(void *)v204;
          if (v200 != *(void *)v204)
          {
            int v213 = 1;
            while (v212 != -4096)
            {
              int v214 = v211 + v213++;
              uint64_t v211 = v214 & v210;
              uint64_t v212 = *(void *)(*(void *)&v201 + 16 * v211);
              if (v200 == v212)
              {
                uint64_t v204 = *(void *)&v201 + 16 * v211;
                goto LABEL_278;
              }
            }
            goto LABEL_277;
          }
        }
        else
        {
LABEL_277:
          uint64_t v204 = v203;
        }
LABEL_278:
        if (v203 != v204)
        {
          uint64_t v274 = v368;
          if ((v199 & 2) != 0) {
            uint64_t v274 = v362;
          }
          uint64_t v275 = v274 + 32 * *(unsigned int *)(v204 + 8);
          uint64_t v276 = v365;
          if ((v199 & 2) != 0) {
            uint64_t v276 = v360;
          }
          if (v275 != v276)
          {
            int v277 = v358;
            if ((v199 & 2) != 0) {
              int v277 = v356;
            }
            int v320 = v277;
            uint64_t v222 = *(void *)(v275 + 16);
            uint64_t v324 = v275 + 8;
            if (v222 != v275 + 8)
            {
              uint64_t v338 = v226;
              int32x2_t v341 = v225;
              int32x2_t v336 = v227;
              unsigned int v332 = v229;
              unsigned int v334 = v228;
              int32x2_t v330 = v230;
              unsigned int v328 = v231;
              unint64_t v321 = *v209 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v322 = *v209;
              uint64_t v326 = v223;
              do
              {
                int32x2_t v220 = v224;
                uint64_t v221 = *(void *)(v222 + 16);
                if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v221 + 8), byte_1EBCD38C0))
                {
                  v422 = (uint64_t *)(v52 | 6);
                  LODWORD(v423) = 1;
                  HIDWORD(v423) = v320;
                  llvm::SUnit::addPred(v221, (uint64_t *)&v422, 1);
                }
                uint64_t v222 = *(void *)(v222 + 8);
                uint64_t v223 = v326;
                int32x2_t v224 = v220;
                uint64_t v226 = v338;
                int32x2_t v225 = v341;
                int32x2_t v227 = v336;
                unsigned int v229 = v332;
                unsigned int v228 = v334;
                int32x2_t v230 = v330;
                unsigned int v231 = v328;
                unint64_t v200 = v321;
                LOBYTE(v199) = v322;
              }
              while (v222 != v324);
            }
          }
        }
        if ((v199 & 2) != 0) {
          int32x2_t v205 = v224;
        }
        else {
          int32x2_t v205 = v230;
        }
        if ((v199 & 2) != 0) {
          unsigned int v206 = v223;
        }
        else {
          unsigned int v206 = v231;
        }
        uint64_t v207 = *(void *)&v205 + 16 * v206;
        if (v206)
        {
          unsigned int v215 = v206 - 1;
          LODWORD(v216) = (v206 - 1) & (37 * v200);
          uint64_t v208 = *(void *)&v205 + 16 * v216;
          uint64_t v217 = *(void *)v208;
          if (v200 != *(void *)v208)
          {
            int v218 = 1;
            while (v217 != -4096)
            {
              int v219 = v216 + v218++;
              uint64_t v216 = v219 & v215;
              uint64_t v217 = *(void *)(*(void *)&v205 + 16 * v216);
              if (v200 == v217)
              {
                uint64_t v208 = *(void *)&v205 + 16 * v216;
                goto LABEL_287;
              }
            }
            goto LABEL_286;
          }
        }
        else
        {
LABEL_286:
          uint64_t v208 = v207;
        }
LABEL_287:
        if (v207 != v208)
        {
          size_t v278 = v354;
          if ((v199 & 2) != 0) {
            size_t v278 = v350;
          }
          size_t v279 = &v278[32 * *(unsigned int *)(v208 + 8)];
          size_t v280 = v352;
          if ((v199 & 2) != 0) {
            size_t v280 = v348;
          }
          if (v279 != v280)
          {
            unsigned int v281 = v346;
            if ((v199 & 2) != 0) {
              unsigned int v281 = v343;
            }
            unsigned int v323 = v281;
            uint64_t v233 = *((void *)v279 + 2);
            v325 = v279 + 8;
            if ((char *)v233 != v279 + 8)
            {
              uint64_t v339 = v226;
              int32x2_t v342 = v225;
              int32x2_t v337 = v227;
              unsigned int v333 = v229;
              unsigned int v335 = v228;
              int32x2_t v331 = v230;
              unsigned int v329 = v231;
              uint64_t v327 = v223;
              do
              {
                uint64_t v232 = *(void *)(v233 + 16);
                if (llvm::MachineInstr::mayAlias(*(llvm::MachineInstr **)(v52 + 8), *((llvm::AAResults **)this + 262), *(const llvm::MachineInstr **)(v232 + 8), byte_1EBCD38C0))
                {
                  v422 = (uint64_t *)(v52 | 6);
                  LODWORD(v423) = 1;
                  HIDWORD(v423) = v323;
                  llvm::SUnit::addPred(v232, (uint64_t *)&v422, 1);
                }
                uint64_t v233 = *(void *)(v233 + 8);
                uint64_t v223 = v327;
                uint64_t v226 = v339;
                int32x2_t v225 = v342;
                int32x2_t v227 = v337;
                unsigned int v229 = v333;
                unsigned int v228 = v335;
                int32x2_t v230 = v331;
                unsigned int v231 = v329;
              }
              while ((char *)v233 != v325);
            }
          }
        }
        if (++v209 == (uint64_t *)v226) {
          goto LABEL_314;
        }
        continue;
      }
    }
    unint64_t v297 = v38;
    if ((v95 & 0x80000) != 0) {
      goto LABEL_154;
    }
    while ((*(_WORD *)(v297 + 44) & 8) != 0)
    {
      unint64_t v297 = *(void *)(v297 + 8);
      a6 = v371;
      a3 = v377;
      if ((*(unsigned char *)(*(void *)(v297 + 16) + 10) & 8) != 0) {
        goto LABEL_154;
      }
    }
    unint64_t v37 = 0;
    a6 = v371;
    a3 = v377;
LABEL_132:
    unint64_t v36 = *(void *)v36 & 0xFFFFFFFFFFFFFFF8;
    if (!v36 || (*(unsigned char *)v36 & 4) == 0)
    {
      while ((*(_WORD *)(v36 + 44) & 4) != 0)
        unint64_t v36 = *(void *)v36 & 0xFFFFFFFFFFFFFFF8;
    }
  }
  while (v36 != v375);
  if (v37) {
    *((void *)this + 320) = v37;
  }
LABEL_346:
  *((_DWORD *)this + 246) = 0;
  *((void *)this + 150) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 304) = 0;
  *((void *)this + 179) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 362) = 0;
  *((void *)this + 216) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 436) = 0;
  *((void *)this + 261) = 0xFFFFFFFFLL;
  *((unsigned char *)this + 2136) = 1;
  if ((void)__p)
  {
    sub_1CC469BDC(&__p, __p);
    operator delete((void *)__p);
  }
  MEMORY[0x1D25D9CD0](v378, 8);
  if (v386)
  {
    sub_1CC469BDC(&v386, (uint64_t)v386);
    operator delete(v386);
  }
  MEMORY[0x1D25D9CD0](v383, 8);
  if ((void)v393)
  {
    sub_1CC469BDC(&v393, v393);
    operator delete((void *)v393);
  }
  MEMORY[0x1D25D9CD0](v390, 8);
  if (v398)
  {
    sub_1CC469BDC(&v398, (uint64_t)v398);
    operator delete(v398);
  }
  MEMORY[0x1D25D9CD0](v395, 8);
  if ((void)v405)
  {
    sub_1CC469BDC(&v405, v405);
    operator delete((void *)v405);
  }
  return MEMORY[0x1D25D9CD0](v402, 8);
}

uint64_t llvm::operator<<(uint64_t a1, void (***a2)(void, uint64_t))
{
  return a1;
}

llvm *llvm::ScheduleDAGInstrs::Value2SUsMap::dump(llvm *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  for (uint64_t i = (uint64_t *)*((void *)this + 4); v1 != i; v1 += 4)
  {
    uint64_t v3 = *v1;
    if ((*v1 & 4) != 0)
    {
      uint64_t v8 = llvm::dbgs(this);
      uint64_t v6 = (llvm::raw_ostream *)(**(uint64_t (***)(unint64_t, llvm *))(*v1 & 0xFFFFFFFFFFFFFFF8))(*v1 & 0xFFFFFFFFFFFFFFF8, v8);
    }
    else
    {
      uint64_t v4 = (llvm::Value *)(v3 & 0xFFFFFFFFFFFFFFF8);
      unsigned int v5 = *(unsigned __int8 *)((v3 & 0xFFFFFFFFFFFFFFF8) + 16) - 11;
      uint64_t v6 = llvm::dbgs(this);
      if (v5 > 1)
      {
        uint64_t v6 = (llvm::raw_ostream *)llvm::Value::printAsOperand(v4, v6, 1, 0);
      }
      else
      {
        uint64_t v7 = (_DWORD *)*((void *)v6 + 4);
        if (*((void *)v6 + 3) - (void)v7 > 6uLL)
        {
          *(_DWORD *)((char *)v7 + 3) = 1853321070;
          *uint64_t v7 = 1852534357;
          *((void *)v6 + 4) += 7;
        }
        else
        {
          uint64_t v6 = llvm::raw_ostream::write(v6, "Unknown", 7uLL);
        }
      }
    }
    uint64_t v9 = llvm::dbgs(v6);
    uint64_t v10 = *((void *)v9 + 4);
    if ((unint64_t)(*((void *)v9 + 3) - v10) > 2)
    {
      *(unsigned char *)(v10 + 2) = 32;
      *(_WORD *)uint64_t v10 = 14880;
      *((void *)v9 + 4) += 3;
    }
    else
    {
      uint64_t v9 = llvm::raw_ostream::write(v9, " : ", 3uLL);
    }
    int v11 = llvm::dbgs(v9);
    uint64_t v12 = (_WORD *)*((void *)v11 + 4);
    if (*((void *)v11 + 3) - (void)v12 > 1uLL)
    {
      *uint64_t v12 = 8315;
      *((void *)v11 + 4) += 2;
    }
    else
    {
      int v11 = llvm::raw_ostream::write(v11, "{ ", 2uLL);
    }
    uint64_t v13 = v1 + 1;
    for (uint64_t j = (void *)v1[2]; j != v13; uint64_t j = (void *)j[1])
    {
      uint64_t v15 = j[2];
      int v16 = llvm::dbgs(v11);
      int v17 = v16;
      uint64_t v18 = *((void *)v16 + 4);
      if ((unint64_t)(*((void *)v16 + 3) - v18) > 2)
      {
        *(unsigned char *)(v18 + 2) = 40;
        *(_WORD *)uint64_t v18 = 21843;
        *((void *)v16 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(v16, "SU(", 3uLL);
      }
      int v11 = sub_1CD098D14(v17, *(unsigned int *)(v15 + 192), 0, 0, 0);
      unint64_t v19 = (unsigned char *)*((void *)v17 + 4);
      if (*((unsigned char **)v17 + 3) == v19)
      {
        int v11 = llvm::raw_ostream::write(v17, ")", 1uLL);
      }
      else
      {
        *unint64_t v19 = 41;
        ++*((void *)v17 + 4);
      }
      if (v15 != *(void *)(*v13 + 16))
      {
        int v11 = llvm::dbgs(v11);
        int v20 = (_WORD *)*((void *)v11 + 4);
        if (*((void *)v11 + 3) - (void)v20 > 1uLL)
        {
          *int v20 = 8236;
          *((void *)v11 + 4) += 2;
        }
        else
        {
          int v11 = llvm::raw_ostream::write(v11, ", ", 2uLL);
        }
      }
    }
    this = llvm::dbgs(v11);
    uint64_t v21 = (_WORD *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v21 > 1uLL)
    {
      *uint64_t v21 = 2685;
      *((void *)this + 4) += 2;
    }
    else
    {
      this = llvm::raw_ostream::write(this, "}\n", 2uLL);
    }
  }
  return this;
}

const llvm::MachineRegisterInfo *sub_1CC468870(const llvm::MachineRegisterInfo *result, llvm::LivePhysRegs *this, unsigned int *a3, unsigned int a4, int a5)
{
  if (a4)
  {
    uint64_t v8 = result;
    uint64_t v9 = 32 * a4;
    do
    {
      BOOL v10 = (*a3 & 0x300000FF) != 0 || (*a3 & 0x10FFF00) == 0x1000000;
      if (!v10 && a3[1])
      {
        unsigned int v11 = (unsigned __int16)a3[1];
        uint64_t result = (const llvm::MachineRegisterInfo *)llvm::LivePhysRegs::available(this, v8, v11);
        if (result) {
          int v12 = 0x4000000;
        }
        else {
          int v12 = 0;
        }
        *a3 = *a3 & 0xFBFFFFFF | v12;
        if (a5) {
          uint64_t result = (const llvm::MachineRegisterInfo *)sub_1CD51C45C((uint64_t *)this, v11);
        }
      }
      a3 += 8;
      v9 -= 32;
    }
    while (v9);
  }
  return result;
}

void llvm::SchedDFSResult::compute(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5 = 0;
  uint64_t v139 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3;
  uint64_t v126 = a1;
  uint64_t v127 = v129;
  uint64_t v128 = 0x800000000;
  unsigned int v130 = 0;
  if (v6 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  while (v5 < v6)
  {
    if (v5 >= HIDWORD(v128)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((_DWORD *)v127 + v5) = v5;
    unsigned int v5 = v128 + 1;
    LODWORD(v128) = v128 + 1;
  }
  long long __p = 0;
  uint64_t v132 = 0;
  uint64_t v133 = 0;
  uint64_t v134 = v136;
  uint64_t v135 = 0x800000000;
  uint64_t v137 = 0;
  int v138 = 0;
  unint64_t v7 = *(void *)(v126 + 16) - *(void *)(v126 + 8);
  unint64_t v8 = v7 >> 3;
  if ((v7 >> 3))
  {
    uint64_t v9 = malloc_type_calloc((v7 >> 3), 1uLL, 0x6D9A4F0CuLL);
    if (!v9) {
      llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
    }
    uint64_t v137 = v9;
    int v138 = v8;
  }
  if (a3)
  {
    uint64_t v10 = a2 + 272 * a3;
    uint64_t v124 = v10;
    do
    {
      uint64_t v11 = *(unsigned int *)(a2 + 192);
      uint64_t v12 = *(void *)(v126 + 8);
      if (*(_DWORD *)(v12 + 8 * v11 + 4) == -1)
      {
        uint64_t v13 = *(unsigned int *)(a2 + 120);
        if (v13)
        {
          int v14 = *(void **)(a2 + 112);
          uint64_t v15 = 16 * v13;
          while ((*v14 & 6) != 0 || *(_DWORD *)((*v14 & 0xFFFFFFFFFFFFFFF8) + 192) == -1)
          {
            v14 += 2;
            v15 -= 16;
            if (!v15) {
              goto LABEL_17;
            }
          }
        }
        else
        {
LABEL_17:
          int v16 = *(unsigned __int16 **)(*(void *)(a2 + 8) + 16);
          int v17 = *v16;
          if ((v17 - 9) <= 0x3C && ((1 << (v17 - 9)) & 0x1000000000000605) != 0
            || v17 == 0)
          {
            int v20 = 1;
          }
          else
          {
            int v20 = (*((unsigned __int8 *)v16 + 8) >> 4) & 1;
          }
          *(_DWORD *)(v12 + 8 * v11) = v20 ^ 1;
          uint64_t v21 = *(void *)(a2 + 32);
          uint64_t v22 = (char *)operator new(0x10uLL);
          uint64_t v23 = v22 + 16;
          uint64_t v125 = a2;
          *(void *)uint64_t v22 = a2;
          *((void *)v22 + 1) = v21;
          uint64_t v24 = (unint64_t *)(v22 + 16);
          while (1)
          {
            uint64_t v26 = *(v24 - 2);
            unsigned int v25 = (uint64_t *)*(v24 - 1);
            uint64_t v27 = *(void *)(v26 + 32) + 16 * *(unsigned int *)(v26 + 40);
            long long v28 = v24;
            while (v25 != (uint64_t *)v27)
            {
              uint64_t v29 = *v25;
              *(v28 - 1) = (unint64_t)(v25 + 2);
              if ((v29 & 6) == 0)
              {
                unint64_t v30 = v29 & 0xFFFFFFFFFFFFFFF8;
                uint64_t v31 = *(unsigned int *)((v29 & 0xFFFFFFFFFFFFFFF8) + 192);
                if (v31 != -1)
                {
                  uint64_t v32 = *(void *)(v126 + 8);
                  if (*(_DWORD *)(v32 + 8 * v31 + 4) == -1)
                  {
                    unsigned int v35 = *(unsigned __int16 **)(*(void *)(v30 + 8) + 16);
                    int v36 = *v35;
                    if ((v36 - 9) <= 0x3C
                      && ((1 << (v36 - 9)) & 0x1000000000000605) != 0
                      || v36 == 0)
                    {
                      int v39 = 1;
                    }
                    else
                    {
                      int v39 = (*((unsigned __int8 *)v35 + 8) >> 4) & 1;
                    }
                    *(_DWORD *)(v32 + 8 * v31) = v39 ^ 1;
                    unint64_t v40 = *(void *)(v30 + 32);
                    if (v28 >= (unint64_t *)v23)
                    {
                      uint64_t v47 = ((char *)v28 - v22) >> 4;
                      unint64_t v48 = v47 + 1;
                      if ((unint64_t)(v47 + 1) >> 60) {
LABEL_152:
                      }
                        abort();
                      if ((v23 - v22) >> 3 > v48) {
                        unint64_t v48 = (v23 - v22) >> 3;
                      }
                      if ((unint64_t)(v23 - v22) >= 0x7FFFFFFFFFFFFFF0) {
                        unint64_t v49 = 0xFFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v49 = v48;
                      }
                      if (v49)
                      {
                        if (v49 >> 60) {
                          goto LABEL_153;
                        }
                        unsigned int v50 = (char *)operator new(16 * v49);
                      }
                      else
                      {
                        unsigned int v50 = 0;
                      }
                      __int16 v53 = (unint64_t *)&v50[16 * v47];
                      uint64_t v23 = &v50[16 * v49];
                      *__int16 v53 = v30;
                      v53[1] = v40;
                      unint64_t v54 = v53 + 2;
                      if (v28 == (unint64_t *)v22) {
                        goto LABEL_73;
                      }
                      do
                      {
                        *((_OWORD *)v53 - 1) = *((_OWORD *)v28 - 1);
                        v53 -= 2;
                        v28 -= 2;
                      }
                      while (v28 != (unint64_t *)v22);
                      if (v22) {
LABEL_73:
                      }
                        operator delete(v22);
                      long long v28 = v54;
                      uint64_t v22 = (char *)v53;
                    }
                    else
                    {
                      *long long v28 = v30;
                      v28[1] = v40;
                      v28 += 2;
                    }
                  }
                  else
                  {
                    size_t v33 = v132;
                    if (v132 >= v133)
                    {
                      int v41 = __p;
                      uint64_t v42 = (v132 - (unsigned char *)__p) >> 4;
                      unint64_t v43 = v42 + 1;
                      if ((unint64_t)(v42 + 1) >> 60) {
                        goto LABEL_152;
                      }
                      uint64_t v44 = v133 - (unsigned char *)__p;
                      if ((v133 - (unsigned char *)__p) >> 3 > v43) {
                        unint64_t v43 = v44 >> 3;
                      }
                      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0) {
                        unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v45 = v43;
                      }
                      if (v45)
                      {
                        if (v45 >> 60) {
                          goto LABEL_153;
                        }
                        uint64_t v46 = (char *)operator new(16 * v45);
                      }
                      else
                      {
                        uint64_t v46 = 0;
                      }
                      uint64_t v51 = (unint64_t *)&v46[16 * v42];
                      *uint64_t v51 = v30;
                      v51[1] = v26;
                      unint64_t v52 = v51;
                      if (v33 != v41)
                      {
                        do
                        {
                          *((_OWORD *)v52 - 1) = *((_OWORD *)v33 - 1);
                          v52 -= 2;
                          v33 -= 2;
                        }
                        while (v33 != v41);
                        size_t v33 = __p;
                      }
                      unsigned int v34 = (char *)(v51 + 2);
                      long long __p = v52;
                      uint64_t v132 = (char *)(v51 + 2);
                      uint64_t v133 = &v46[16 * v45];
                      if (v33) {
                        operator delete(v33);
                      }
                    }
                    else
                    {
                      *(void *)uint64_t v132 = v30;
                      v33[1] = v26;
                      unsigned int v34 = (char *)(v33 + 2);
                    }
                    uint64_t v132 = v34;
                  }
                }
              }
              uint64_t v26 = *(v28 - 2);
              unsigned int v25 = (uint64_t *)*(v28 - 1);
              uint64_t v27 = *(void *)(v26 + 32) + 16 * *(unsigned int *)(v26 + 40);
            }
            uint64_t v24 = v28 - 2;
            if (v22 == (char *)(v28 - 2)) {
              break;
            }
            uint64_t v55 = *(v28 - 3);
            sub_1CC469304((unsigned int *)&v126, v26);
            uint64_t v56 = v126;
            unint64_t v57 = *(void *)(v55 - 16) & 0xFFFFFFFFFFFFFFF8;
            unint64_t v58 = *(unsigned int *)(v57 + 192);
            uint64_t v59 = *(void *)(v126 + 8);
            int v60 = (_DWORD *)(v59 + 8 * v58);
            unint64_t v61 = *(unsigned int *)(*(v28 - 4) + 192);
            *(_DWORD *)(v59 + 8 * v61) += *v60;
            if (v60[1] == v58)
            {
              uint64_t v62 = *(unsigned int *)(v57 + 120);
              if (v62)
              {
                int v63 = 0;
                uint64_t v64 = *(unsigned char **)(v57 + 112);
                uint64_t v65 = 16 * v62;
                while ((*v64 & 6) != 0 || ++v63 <= 3)
                {
                  v64 += 16;
                  v65 -= 16;
                  if (!v65) {
                    goto LABEL_83;
                  }
                }
              }
              else
              {
LABEL_83:
                if (*v60 <= *(_DWORD *)(v56 + 4))
                {
                  v60[1] = v61;
                  uint64_t v66 = v127;
                  unint64_t v67 = *((unsigned int *)v127 + v61);
                  unint64_t v68 = *((unsigned int *)v127 + v58);
                  while (v67 != v68)
                  {
                    if (v67 < v68)
                    {
                      v66[v58] = v67;
                      unint64_t v58 = v68;
                      unint64_t v68 = v66[v68];
                    }
                    else
                    {
                      v66[v61] = v68;
                      unint64_t v61 = v67;
                      unint64_t v67 = v66[v67];
                    }
                  }
                }
              }
            }
          }
          sub_1CC469304((unsigned int *)&v126, v26);
          uint64_t v10 = v124;
          a2 = v125;
          if (v22) {
            operator delete(v22);
          }
        }
      }
      a2 += 272;
    }
    while (a2 != v10);
  }
  unsigned int v69 = v130;
  if (!v130)
  {
    uint64_t v70 = v128;
    if (v128)
    {
      uint64_t v71 = 0;
      uint64_t v72 = v127;
      do
      {
        uint64_t v73 = v72[v71];
        if (v71 == v73) {
          int v74 = v130++;
        }
        else {
          int v74 = v72[v73];
        }
        v72[v71++] = v74;
      }
      while (v70 != v71);
      unsigned int v69 = v130;
    }
    else
    {
      unsigned int v69 = 0;
    }
  }
  uint64_t v75 = v126;
  unsigned int v76 = *(_DWORD *)(v126 + 40);
  if (v76 != v69)
  {
    if (v76 <= v69)
    {
      if (*(_DWORD *)(v126 + 44) < v69) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v76 != v69) {
        memset_pattern16((void *)(*(void *)(v126 + 32) + 8 * v76), &unk_1CFAC7300, 8 * (v69 - (unint64_t)v76));
      }
    }
    *(_DWORD *)(v75 + 40) = v69;
    uint64_t v75 = v126;
  }
  if (v135)
  {
    char v77 = (char *)v134;
    uint64_t v78 = v127;
    int v79 = (char *)v134 + 12 * v135;
    uint64_t v80 = *(void *)(v75 + 32);
    do
    {
      uint64_t v81 = *((unsigned int *)v77 + 1);
      uint64_t v82 = v78[*(unsigned int *)v77];
      if (v81 != -1) {
        *(_DWORD *)(v80 + 8 * v82) = v78[v81];
      }
      *(_DWORD *)(v80 + 8 * v82 + 4) = *((_DWORD *)v77 + 2);
      v77 += 12;
    }
    while (v77 != v79);
  }
  uint64_t v83 = v130;
  int v85 = *(char **)(v75 + 176);
  int v84 = *(char **)(v75 + 184);
  unint64_t v86 = 0xAAAAAAAAAAAAAAABLL * ((v84 - v85) >> 4);
  unint64_t v87 = v130 - v86;
  if (v130 <= v86)
  {
    if (v130 < v86)
    {
      uint64_t v117 = &v85[48 * v130];
      while (v84 != v117)
      {
        uint64_t v119 = (char *)*((void *)v84 - 6);
        v84 -= 48;
        uint64_t v118 = v119;
        if (v84 + 16 != v119) {
          free(v118);
        }
      }
      *(void *)(v75 + 184) = v117;
    }
  }
  else
  {
    uint64_t v88 = *(void *)(v75 + 192);
    if (0xAAAAAAAAAAAAAAABLL * ((v88 - (uint64_t)v84) >> 4) < v87)
    {
      unint64_t v92 = 0x5555555555555556 * ((v88 - (uint64_t)v85) >> 4);
      if (v92 <= v130) {
        unint64_t v92 = v130;
      }
      if (0xAAAAAAAAAAAAAAABLL * ((v88 - (uint64_t)v85) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v93 = 0x555555555555555;
      }
      else {
        unint64_t v93 = v92;
      }
      if (v93 > 0x555555555555555) {
LABEL_153:
      }
        sub_1CB833614();
      int v94 = (char *)operator new(48 * v93);
      uint64_t v95 = &v94[16 * ((v84 - v85) >> 4)];
      uint64_t v96 = 3 * v83;
      uint64_t v97 = &v94[48 * v83];
      uint64_t v98 = 16 * v96;
      int v99 = v95 + 16;
      uint64_t v100 = v98 - 16 * ((v84 - v85) >> 4);
      do
      {
        *((void *)v99 - 2) = v99;
        *((void *)v99 - 1) = 0x400000000;
        v99 += 48;
        v100 -= 48;
      }
      while (v100);
      unsigned int v101 = &v94[48 * v93];
      if (v84 == v85)
      {
        *(void *)(v75 + 176) = v95;
        *(void *)(v75 + 184) = v97;
        *(void *)(v75 + 192) = v101;
      }
      else
      {
        uint64_t v120 = 0;
        do
        {
          *(void *)&v95[v120 - 48] = &v95[v120 - 32];
          *(void *)&v95[v120 - 40] = 0x400000000;
          if (*(_DWORD *)&v84[v120 - 40]) {
            sub_1CD41C56C((uint64_t)&v95[v120 - 48], (uint64_t)&v84[v120 - 48]);
          }
          v120 -= 48;
        }
        while (&v84[v120] != v85);
        uint64_t v121 = *(char **)(v75 + 176);
        int v84 = *(char **)(v75 + 184);
        *(void *)(v75 + 176) = &v95[v120];
        *(void *)(v75 + 184) = v97;
        *(void *)(v75 + 192) = v101;
        if (v84 != v121)
        {
          do
          {
            uint64_t v123 = (char *)*((void *)v84 - 6);
            v84 -= 48;
            uint64_t v122 = v123;
            if (v84 + 16 != v123) {
              free(v122);
            }
          }
          while (v84 != v121);
          int v84 = v121;
        }
      }
      if (v84) {
        operator delete(v84);
      }
    }
    else
    {
      __int16 v89 = &v84[48 * v87];
      uint64_t v90 = 48 * v130 - 16 * ((v84 - v85) >> 4);
      int v91 = v84 + 16;
      do
      {
        *((void *)v91 - 2) = v91;
        *((void *)v91 - 1) = 0x400000000;
        v91 += 48;
        v90 -= 48;
      }
      while (v90);
      *(void *)(v75 + 184) = v89;
    }
  }
  uint64_t v102 = v126;
  uint64_t v103 = *(void *)(v126 + 200);
  unint64_t v104 = (*(void *)(v126 + 208) - v103) >> 2;
  if (v130 <= v104)
  {
    if (v130 < v104) {
      *(void *)(v126 + 208) = v103 + 4 * v130;
    }
  }
  else
  {
    sub_1CBF2A8C4((char **)(v126 + 200), v130 - v104);
    uint64_t v102 = v126;
  }
  uint64_t v105 = *(void *)(v102 + 8);
  unint64_t v106 = *(void *)(v102 + 16) - v105;
  if ((v106 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v107 = (int *)v127;
    uint64_t v108 = (v106 >> 3);
    uint64_t v109 = (_DWORD *)(v105 + 4);
    do
    {
      int v110 = *v107++;
      _DWORD *v109 = v110;
      v109 += 2;
      --v108;
    }
    while (v108);
  }
  uint64_t v111 = (llvm::SUnit **)__p;
  unsigned int v112 = (llvm::SUnit **)v132;
  while (v111 != v112)
  {
    char v113 = *v111;
    unsigned int v114 = *((_DWORD *)v127 + *((unsigned int *)*v111 + 48));
    unsigned int v115 = *((_DWORD *)v127 + *((unsigned int *)v111[1] + 48));
    if (v114 != v115)
    {
      if ((*((unsigned char *)v113 + 236) & 1) == 0) {
        llvm::SUnit::ComputeDepth(*v111);
      }
      uint64_t v116 = *((unsigned int *)v113 + 60);
      sub_1CC46A4E4(&v126, v114, v115, v116);
      sub_1CC46A4E4(&v126, v115, v114, v116);
    }
    v111 += 2;
  }
  free(v137);
  if (v134 != v136) {
    free(v134);
  }
  if (__p)
  {
    uint64_t v132 = (char *)__p;
    operator delete(__p);
  }
  if (v127 != v129) {
    free(v127);
  }
}

void *sub_1CC469304(unsigned int *a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 192);
  uint64_t v4 = *(void *)(*(void *)a1 + 8);
  *(_DWORD *)(v4 + 8 * v3 + 4) = v3;
  unsigned int v5 = *(unsigned __int16 **)(*(void *)(a2 + 8) + 16);
  int v6 = *v5;
  int v9 = ((v6 - 9) > 0x3C || ((1 << (v6 - 9)) & 0x1000000000000605) == 0)
    && v6 != 0
    && (v5[4] & 0x10) == 0;
  uint64_t v10 = *(unsigned int *)(a2 + 40);
  if (v10)
  {
    int v11 = *(_DWORD *)(v4 + 8 * v3);
    uint64_t v12 = *(uint64_t **)(a2 + 32);
    uint64_t v13 = &v12[2 * v10];
    do
    {
      uint64_t v14 = *v12;
      if ((*v12 & 6) == 0)
      {
        unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v16 = *(unsigned int *)((v14 & 0xFFFFFFFFFFFFFFF8) + 192);
        uint64_t v17 = *(void *)(*(void *)a1 + 8);
        if ((v11 - *(_DWORD *)(v17 + 8 * v16)) < *(_DWORD *)(*(void *)a1 + 4))
        {
          uint64_t v18 = v17 + 8 * v16;
          int v20 = *(_DWORD *)(v18 + 4);
          unint64_t v19 = (_DWORD *)(v18 + 4);
          if (v20 == v16)
          {
            uint64_t v21 = *(unsigned int *)(v15 + 120);
            if (v21)
            {
              int v22 = 0;
              uint64_t v23 = *(unsigned char **)(v15 + 112);
              uint64_t v24 = 16 * v21;
              while ((*v23 & 6) != 0 || ++v22 <= 3)
              {
                v23 += 16;
                v24 -= 16;
                if (!v24) {
                  goto LABEL_19;
                }
              }
            }
            else
            {
LABEL_19:
              unint64_t v25 = *(unsigned int *)(a2 + 192);
              *unint64_t v19 = v25;
              uint64_t v26 = *((void *)a1 + 1);
              unint64_t v27 = *(unsigned int *)(v26 + 4 * v25);
              unint64_t v28 = *(unsigned int *)(v26 + 4 * v16);
              if (v27 != v28)
              {
                unint64_t v50 = v16;
                do
                {
                  if (v27 < v28)
                  {
                    *(_DWORD *)(v26 + 4 * v50) = v27;
                    unint64_t v50 = v28;
                    unint64_t v28 = *(unsigned int *)(v26 + 4 * v28);
                  }
                  else
                  {
                    *(_DWORD *)(v26 + 4 * v25) = v28;
                    unint64_t v25 = v27;
                    unint64_t v27 = *(unsigned int *)(v26 + 4 * v27);
                  }
                }
                while (v27 != v28);
              }
            }
          }
        }
        if (*(_DWORD *)(v17 + 8 * v16 + 4) == v16)
        {
          uint64_t v44 = *((void *)a1 + 25);
          unsigned int v45 = *(unsigned __int8 *)(v44 + v16);
          unsigned int v46 = a1[24];
          uint64_t v47 = *((void *)a1 + 11);
          if (v46 <= v45)
          {
LABEL_45:
            unint64_t v48 = (_DWORD *)(v47 + 12 * v46);
          }
          else
          {
            while (1)
            {
              unint64_t v48 = (_DWORD *)(v47 + 12 * v45);
              if (*v48 == v16) {
                break;
              }
              v45 += 256;
              if (v45 >= v46) {
                goto LABEL_45;
              }
            }
          }
          unint64_t v49 = v16 | 0xFFFFFFFF00000000;
          if (v48 == (_DWORD *)(v47 + 12 * v46))
          {
            *(unsigned char *)(v44 + v16) = v46;
            unint64_t v51 = a1[24];
            if (v51 >= a1[25]) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v52 = *((void *)a1 + 11) + 12 * v51;
            *(void *)uint64_t v52 = v49;
            *(_DWORD *)(v52 + 8) = 0;
            unsigned int v46 = a1[24] + 1;
            a1[24] = v46;
            uint64_t v47 = *((void *)a1 + 11);
            unint64_t v48 = (_DWORD *)(v47 + 12 * v46 - 12);
          }
          if (v48[1] == -1)
          {
            uint64_t v63 = *((void *)a1 + 25);
            unsigned int v64 = *(unsigned __int8 *)(v63 + v16);
            if (v46 <= v64)
            {
LABEL_69:
              unsigned int v66 = v46;
              uint64_t v65 = (_DWORD *)(v47 + 12 * v46);
            }
            else
            {
              while (1)
              {
                uint64_t v65 = (_DWORD *)(v47 + 12 * v64);
                if (*v65 == v16) {
                  break;
                }
                v64 += 256;
                if (v64 >= v46) {
                  goto LABEL_69;
                }
              }
              unsigned int v66 = v46;
            }
            int v67 = *(_DWORD *)(a2 + 192);
            if (v65 == (_DWORD *)(v47 + 12 * v66))
            {
              *(unsigned char *)(v63 + v16) = v46;
              unint64_t v68 = a1[24];
              if (v68 >= a1[25]) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v69 = *((void *)a1 + 11) + 12 * v68;
              *(void *)uint64_t v69 = v49;
              *(_DWORD *)(v69 + 8) = 0;
              LODWORD(v69) = a1[24] + 1;
              a1[24] = v69;
              uint64_t v65 = (_DWORD *)(*((void *)a1 + 11) + 12 * v69 - 12);
            }
            v65[1] = v67;
          }
        }
        else
        {
          uint64_t v29 = *((void *)a1 + 25);
          unsigned int v30 = *(unsigned __int8 *)(v29 + v16);
          uint64_t v31 = a1[24];
          uint64_t v32 = *((void *)a1 + 11);
          unsigned int v33 = v30;
          if (v31 <= v30)
          {
LABEL_24:
            unsigned int v34 = (_DWORD *)(v32 + 12 * v31);
          }
          else
          {
            while (1)
            {
              unsigned int v34 = (_DWORD *)(v32 + 12 * v33);
              if (*v34 == v16) {
                break;
              }
              v33 += 256;
              if (v33 >= v31) {
                goto LABEL_24;
              }
            }
          }
          if (v34 != (_DWORD *)(v32 + 12 * v31))
          {
            unsigned int v35 = *(unsigned __int8 *)(v29 + v16);
            if (v31 <= v30) {
              goto LABEL_29;
            }
            while (1)
            {
              uint64_t v36 = v35;
              unint64_t v37 = (_DWORD *)(v32 + 12 * v35);
              if (*v37 == v16) {
                break;
              }
              unsigned int v35 = v36 + 256;
              if ((int)v36 + 256 >= v31) {
                goto LABEL_29;
              }
            }
            if (v31 == v36)
            {
LABEL_29:
              *(unsigned char *)(v29 + v16) = v31;
              unint64_t v38 = a1[24];
              if (v38 >= a1[25]) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v31 = *((void *)a1 + 11) + 12 * v38;
              *(void *)uint64_t v31 = v16 | 0xFFFFFFFF00000000;
              *(_DWORD *)(v31 + 8) = 0;
              LODWORD(v31) = a1[24] + 1;
              a1[24] = v31;
              uint64_t v32 = *((void *)a1 + 11);
              unint64_t v37 = (_DWORD *)(v32 + 12 * v31 - 12);
              unsigned int v30 = *(unsigned __int8 *)(*((void *)a1 + 25) + v16);
            }
            int v39 = v37[2];
            if (v31 <= v30)
            {
LABEL_35:
              unsigned int v41 = v31;
              unint64_t v40 = (_DWORD *)(v32 + 12 * v31);
            }
            else
            {
              while (1)
              {
                unint64_t v40 = (_DWORD *)(v32 + 12 * v30);
                if (*v40 == v16) {
                  break;
                }
                v30 += 256;
                if (v30 >= v31) {
                  goto LABEL_35;
                }
              }
              unsigned int v41 = v31;
            }
            v9 += v39;
            uint64_t v42 = (_DWORD *)(v32 + 12 * v41);
            if (v40 != v42)
            {
              unint64_t v43 = v42 - 3;
              if (v43 != v40)
              {
                uint64_t v31 = *(void *)v43;
                v40[2] = v43[2];
                *(void *)unint64_t v40 = v31;
                *(unsigned char *)(*((void *)a1 + 25) + *(unsigned int *)(*((void *)a1 + 11) + 12 * a1[24] - 12)) = -85 * ((v40 - *((void *)a1 + 11)) >> 2);
                LODWORD(v31) = a1[24];
              }
              a1[24] = v31 - 1;
            }
          }
        }
      }
      v12 += 2;
    }
    while (v12 != v13);
  }
  uint64_t result = a1 + 22;
  uint64_t v54 = *((void *)a1 + 11);
  uint64_t v55 = *(unsigned int *)(a2 + 192);
  uint64_t v56 = *((void *)a1 + 25);
  unsigned int v57 = *(unsigned __int8 *)(v56 + v55);
  unsigned int v58 = a1[24];
  if (v58 <= v57)
  {
LABEL_61:
    uint64_t v59 = (_DWORD *)(v54 + 12 * v58);
  }
  else
  {
    while (1)
    {
      uint64_t v59 = (_DWORD *)(v54 + 12 * v57);
      if (*v59 == v55) {
        break;
      }
      v57 += 256;
      if (v57 >= v58) {
        goto LABEL_61;
      }
    }
  }
  if (v59 == (_DWORD *)(v54 + 12 * v58))
  {
    unint64_t v60 = v55 | 0xFFFFFFFF00000000;
    *(unsigned char *)(v56 + v55) = v58;
    unsigned int v61 = a1[24];
    if (v61 >= a1[25]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v62 = *((void *)a1 + 11) + 12 * v61;
    *(void *)uint64_t v62 = v60;
    *(_DWORD *)(v62 + 8) = 0;
    LODWORD(v62) = a1[24] + 1;
    a1[24] = v62;
    uint64_t v59 = (_DWORD *)(*((void *)a1 + 11) + 12 * v62 - 12);
  }
  *uint64_t v59 = v3;
  v59[1] = -1;
  v59[2] = v9;
  return result;
}

uint64_t llvm::SchedDFSResult::scheduleTree(uint64_t this, unsigned int a2)
{
  uint64_t v2 = *(void *)(this + 176) + 48 * a2;
  uint64_t v3 = *(unsigned int *)(v2 + 8);
  if (v3)
  {
    uint64_t v4 = *(unsigned int **)v2;
    unsigned int v5 = &v4[2 * v3];
    uint64_t v6 = *(void *)(this + 200);
    do
    {
      uint64_t v7 = *v4;
      unsigned int v8 = v4[1];
      v4 += 2;
      if (*(_DWORD *)(v6 + 4 * v7) > v8) {
        unsigned int v8 = *(_DWORD *)(v6 + 4 * v7);
      }
      *(_DWORD *)(v6 + 4 * v7) = v8;
    }
    while (v4 != v5);
  }
  return this;
}

uint64_t sub_1CC4698C8(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4 = (char *)*a1;
  uint64_t v3 = (char *)a1[1];
  unint64_t v5 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)&v3[-*a1] >> 4);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0xF0F0F0F0F0F0F0) {
    abort();
  }
  if (0xE1E1E1E1E1E1E1E2 * ((a1[2] - (uint64_t)v4) >> 4) > v6) {
    unint64_t v6 = 0xE1E1E1E1E1E1E1E2 * ((a1[2] - (uint64_t)v4) >> 4);
  }
  if (0xF0F0F0F0F0F0F0F1 * ((a1[2] - (uint64_t)v4) >> 4) >= 0x78787878787878) {
    unint64_t v10 = 0xF0F0F0F0F0F0F0;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0xF0F0F0F0F0F0F0) {
      sub_1CB833614();
    }
    int v11 = (char *)operator new(272 * v10);
  }
  else
  {
    int v11 = 0;
  }
  uint64_t v12 = (uint64_t)&v11[272 * v5];
  *(void *)uint64_t v12 = 0;
  *(void *)(v12 + 8) = a2;
  *(void *)(v12 + 16) = 0;
  *(void *)(v12 + 24) = 0;
  uint64_t v13 = &v11[272 * v10];
  *(void *)(v12 + 32) = v12 + 48;
  *(void *)(v12 + 40) = 0x400000000;
  *(void *)(v12 + 112) = v12 + 128;
  *(void *)(v12 + 120) = 0x400000000;
  *(_DWORD *)(v12 + 192) = a3;
  *(_DWORD *)(v12 + 232) = 0;
  *(_OWORD *)(v12 + 196) = 0u;
  *(_OWORD *)(v12 + 212) = 0u;
  *(_WORD *)(v12 + 228) = 0;
  *(unsigned char *)(v12 + 236) &= 0xFCu;
  *(_OWORD *)(v12 + 240) = 0u;
  *(_OWORD *)(v12 + 256) = 0u;
  uint64_t v14 = v12 + 272;
  if (v3 == v4)
  {
    *a1 = v12;
    a1[1] = v14;
    a1[2] = (uint64_t)v13;
  }
  else
  {
    do
    {
      v3 -= 272;
      uint64_t v12 = sub_1CD57A99C(v12 - 272, (uint64_t)v3);
    }
    while (v3 != v4);
    uint64_t v3 = (char *)*a1;
    unint64_t v15 = (char *)a1[1];
    *a1 = v12;
    a1[1] = v14;
    a1[2] = (uint64_t)v13;
    while (v15 != v3)
    {
      unint64_t v16 = (char *)*((void *)v15 - 20);
      if (v15 - 144 != v16) {
        free(v16);
      }
      uint64_t v17 = (char *)*((void *)v15 - 30);
      if (v15 - 224 != v17) {
        free(v17);
      }
      v15 -= 272;
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v14;
}

void *sub_1CC469A68(void *result, uint64_t a2)
{
  if (result != (void *)a2)
  {
    uint64_t v4 = (const void *)(a2 + 16);
    uint64_t v3 = *(const void **)a2;
    if (v3 == v4)
    {
      unint64_t v5 = (_DWORD *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (*((_DWORD *)result + 2) < v6)
      {
        uint64_t v10 = *((unsigned int *)result + 2);
        unint64_t v16 = (unsigned int *)(a2 + 8);
        uint64_t v12 = (void *)a2;
        unint64_t v19 = result;
        int v13 = *(_DWORD *)(a2 + 8);
        if (*((_DWORD *)result + 3) < v6)
        {
          *((_DWORD *)result + 2) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove((void *)*result, v3, 16 * v10);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v9 = *v16;
        if (v10 != v9) {
          memcpy((void *)(*v19 + 16 * v10), (const void *)(*v12 + 16 * v10), *v12 + 16 * v9 - (*v12 + 16 * v10));
        }
        unint64_t v5 = v16;
        uint64_t result = v19;
        *((_DWORD *)v19 + 2) = v13;
      }
      else
      {
        if (v6)
        {
          int v20 = result;
          int v14 = *(_DWORD *)(a2 + 8);
          uint64_t v17 = (_DWORD *)(a2 + 8);
          memmove((void *)*result, v3, 16 * v6);
          unint64_t v5 = v17;
          uint64_t result = v20;
          LODWORD(v6) = v14;
        }
        *((_DWORD *)result + 2) = v6;
      }
    }
    else
    {
      unint64_t v15 = v4;
      uint64_t v11 = a2;
      uint64_t v18 = result;
      unsigned int v8 = result + 2;
      uint64_t v7 = (void *)*result;
      if (v7 != v8)
      {
        free(v7);
        uint64_t v3 = *(const void **)v11;
      }
      uint64_t result = v18;
      *uint64_t v18 = v3;
      unint64_t v5 = (_DWORD *)(v11 + 8);
      v18[1] = *(void *)(v11 + 8);
      *(void *)uint64_t v11 = v15;
      *(_DWORD *)(v11 + 12) = 0;
    }
    *unint64_t v5 = 0;
  }
  return result;
}

void *sub_1CC469BDC(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  for (uint64_t i = result[1]; i != a2; i -= 32)
  {
    if (*(void *)(i - 8))
    {
      uint64_t v5 = *(void *)(i - 24);
      uint64_t result = *(void **)(i - 16);
      uint64_t v6 = *result;
      *(void *)(v6 + 8) = *(void *)(v5 + 8);
      **(void **)(v5 + 8) = v6;
      *(void *)(i - 8) = 0;
      if (result != (void *)(i - 24))
      {
        do
        {
          uint64_t v7 = (void *)result[1];
          operator delete(result);
          uint64_t result = v7;
        }
        while (v7 != (void *)(i - 24));
      }
    }
  }
  v3[1] = a2;
  return result;
}

uint64_t sub_1CC469C70(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v67 = *a2;
  int v68 = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if (v5)
  {
    uint64_t v6 = *(void *)a1;
    unsigned int v7 = v5 - 1;
    uint64_t v8 = (v5 - 1) & (37 * v4);
    uint64_t v9 = (void *)(*(void *)a1 + 16 * v8);
    uint64_t v10 = *v9;
    if (v4 == *v9)
    {
LABEL_11:
      unsigned int v15 = *(_DWORD *)(v6 + 16 * v8 + 8);
      uint64_t v16 = *(void *)(a1 + 24);
      return v16 + 32 * v15 + 8;
    }
    uint64_t v11 = 0;
    int v12 = 1;
    while (v10 != -4096)
    {
      if (v11) {
        BOOL v13 = 0;
      }
      else {
        BOOL v13 = v10 == -8192;
      }
      if (v13) {
        uint64_t v11 = v9;
      }
      int v14 = v8 + v12++;
      uint64_t v8 = v14 & v7;
      uint64_t v9 = (void *)(v6 + 16 * v8);
      uint64_t v10 = *v9;
      if (v4 == *v9) {
        goto LABEL_11;
      }
    }
    if (v11) {
      uint64_t v17 = v11;
    }
    else {
      uint64_t v17 = v9;
    }
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v18 = sub_1CC469FEC(a1, &v67, v17);
  *uint64_t v18 = v4;
  *((_DWORD *)v18 + 2) = 0;
  uint64_t v60 = (uint64_t)&v60;
  unsigned int v61 = &v60;
  uint64_t v19 = *a2;
  uint64_t v62 = 0;
  uint64_t v63 = v19;
  uint64_t v64 = (uint64_t)&v64;
  uint64_t v65 = &v64;
  uint64_t v66 = 0;
  uint64_t v21 = *(char **)(a1 + 32);
  unint64_t v20 = *(void *)(a1 + 40);
  if ((unint64_t)v21 >= v20)
  {
    uint64_t v23 = *(char **)(a1 + 24);
    uint64_t v24 = (v21 - v23) >> 5;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 59) {
      abort();
    }
    uint64_t v26 = v20 - (void)v23;
    if (v26 >> 4 > v25) {
      unint64_t v25 = v26 >> 4;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v27 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27 >> 59) {
      sub_1CB833614();
    }
    unint64_t v28 = (char *)operator new(32 * v27);
    uint64_t v29 = &v28[32 * v24];
    *(void *)uint64_t v29 = v19;
    *((void *)v29 + 1) = v29 + 8;
    unsigned int v30 = &v28[32 * v27];
    *((void *)v29 + 2) = v29 + 8;
    *((void *)v29 + 3) = 0;
    uint64_t v31 = v29 + 32;
    if (v21 == v23)
    {
      *(void *)(a1 + 24) = v29;
      *(void *)(a1 + 32) = v31;
      *(void *)(a1 + 40) = v30;
    }
    else
    {
      uint64_t v32 = 0;
      do
      {
        unsigned int v33 = &v29[v32];
        unsigned int v34 = &v21[v32];
        unsigned int v35 = &v29[v32 - 24];
        *((void *)v33 - 4) = *(void *)&v21[v32 - 32];
        *((void *)v33 - 3) = v35;
        *((void *)v33 - 2) = v35;
        *((void *)v33 - 1) = 0;
        uint64_t v36 = *(void *)&v21[v32 - 8];
        if (v36)
        {
          uint64_t v38 = *((void *)v34 - 3);
          unint64_t v37 = (uint64_t *)*((void *)v34 - 2);
          uint64_t v39 = *v37;
          *(void *)(v39 + 8) = *(void *)(v38 + 8);
          **(void **)(v38 + 8) = v39;
          uint64_t v40 = *(void *)v35;
          *(void *)(v40 + 8) = v37;
          *unint64_t v37 = v40;
          *(void *)unsigned int v35 = v38;
          *(void *)(v38 + 8) = v35;
          *((void *)v33 - 1) = v36;
          *((void *)v34 - 1) = 0;
        }
        v32 -= 32;
      }
      while (&v21[v32] != v23);
      uint64_t v21 = *(char **)(a1 + 24);
      unsigned int v41 = *(char **)(a1 + 32);
      *(void *)(a1 + 24) = &v29[v32];
      *(void *)(a1 + 32) = v31;
      *(void *)(a1 + 40) = v30;
      while (v41 != v21)
      {
        if (*((void *)v41 - 1))
        {
          uint64_t v43 = *((void *)v41 - 3);
          uint64_t v42 = (char *)*((void *)v41 - 2);
          uint64_t v44 = *(void *)v42;
          *(void *)(v44 + 8) = *(void *)(v43 + 8);
          **(void **)(v43 + 8) = v44;
          *((void *)v41 - 1) = 0;
          if (v42 != v41 - 24)
          {
            do
            {
              unsigned int v45 = (char *)*((void *)v42 + 1);
              operator delete(v42);
              uint64_t v42 = v45;
            }
            while (v45 != v41 - 24);
          }
        }
        v41 -= 32;
      }
    }
    if (v21) {
      operator delete(v21);
    }
    uint64_t v46 = v66;
    *(void *)(a1 + 32) = v31;
    if (v46)
    {
      uint64_t v57 = v64;
      uint64_t v56 = v65;
      uint64_t v58 = *v65;
      *(void *)(v58 + 8) = *(void *)(v64 + 8);
      **(void **)(v57 + 8) = v58;
      uint64_t v66 = 0;
      if (v56 != &v64)
      {
        do
        {
          uint64_t v59 = (uint64_t *)v56[1];
          operator delete(v56);
          uint64_t v56 = v59;
        }
        while (v59 != &v64);
      }
    }
  }
  else
  {
    *(void *)uint64_t v21 = v19;
    *((void *)v21 + 1) = v21 + 8;
    *((void *)v21 + 2) = v21 + 8;
    *((void *)v21 + 3) = 0;
    uint64_t v22 = v66;
    if (v66)
    {
      uint64_t v49 = v64;
      unint64_t v48 = v65;
      uint64_t v50 = *v65;
      *(void *)(v50 + 8) = *(void *)(v64 + 8);
      **(void **)(v49 + 8) = v50;
      uint64_t v51 = *((void *)v21 + 1);
      *(void *)(v51 + 8) = v48;
      *unint64_t v48 = v51;
      *((void *)v21 + 1) = v49;
      *(void *)(v49 + 8) = v21 + 8;
      *((void *)v21 + 3) = v22;
      uint64_t v66 = 0;
    }
    *(void *)(a1 + 32) = v21 + 32;
  }
  if (v62)
  {
    uint64_t v53 = v60;
    uint64_t v52 = v61;
    uint64_t v54 = *v61;
    *(void *)(v54 + 8) = *(void *)(v60 + 8);
    **(void **)(v53 + 8) = v54;
    uint64_t v62 = 0;
    if (v52 != &v60)
    {
      do
      {
        uint64_t v55 = (uint64_t *)v52[1];
        operator delete(v52);
        uint64_t v52 = v55;
      }
      while (v55 != &v60);
    }
  }
  uint64_t v16 = *(void *)(a1 + 24);
  unsigned int v15 = ((unint64_t)(*(void *)(a1 + 32) - v16) >> 5) - 1;
  *((_DWORD *)v18 + 2) = v15;
  return v16 + 32 * v15 + 8;
}

void *sub_1CC469FEC(uint64_t a1, void *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_8;
    }
    sub_1CC46A174(a1, v6);
    int v14 = *(_DWORD *)(a1 + 16);
    if (v14)
    {
      int v15 = v14 - 1;
      unsigned int v16 = (37 * *a2) & v15;
      a3 = (void *)(*(void *)a1 + 16 * v16);
      uint64_t v17 = *a3;
      if (*a2 == *a3) {
        goto LABEL_8;
      }
      uint64_t v11 = 0;
      int v18 = 1;
      while (v17 != -4096)
      {
        if (v11) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = v17 == -8192;
        }
        if (v19) {
          uint64_t v11 = a3;
        }
        unsigned int v20 = v16 + v18++;
        unsigned int v16 = v20 & v15;
        a3 = (void *)(*(void *)a1 + 16 * v16);
        uint64_t v17 = *a3;
        if (*a2 == *a3) {
          goto LABEL_8;
        }
      }
      goto LABEL_6;
    }
LABEL_23:
    a3 = 0;
    goto LABEL_8;
  }
  sub_1CC46A174(a1, 2 * v6);
  int v7 = *(_DWORD *)(a1 + 16);
  if (!v7) {
    goto LABEL_23;
  }
  int v8 = v7 - 1;
  unsigned int v9 = (37 * *a2) & v8;
  a3 = (void *)(*(void *)a1 + 16 * v9);
  uint64_t v10 = *a3;
  if (*a2 == *a3) {
    goto LABEL_8;
  }
  uint64_t v11 = 0;
  int v12 = 1;
  while (v10 != -4096)
  {
    if (v11) {
      BOOL v21 = 0;
    }
    else {
      BOOL v21 = v10 == -8192;
    }
    if (v21) {
      uint64_t v11 = a3;
    }
    unsigned int v22 = v9 + v12++;
    unsigned int v9 = v22 & v8;
    a3 = (void *)(*(void *)a1 + 16 * v9);
    uint64_t v10 = *a3;
    if (*a2 == *a3) {
      goto LABEL_8;
    }
  }
LABEL_6:
  if (v11) {
    a3 = v11;
  }
LABEL_8:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC46A174(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD57AA30(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void *sub_1CC46A240(void *a1)
{
  uint64_t v3 = (void **)(a1 + 3);
  uint64_t v2 = a1[3];
  if (v2)
  {
    sub_1CC469BDC(a1 + 3, v2);
    operator delete(*v3);
  }
  MEMORY[0x1D25D9CD0](*a1, 8);
  return a1;
}

uint64_t sub_1CC46A290(void *a1, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  v22[4] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 1;
  }
  unint64_t v5 = a2;
  int v7 = &a2[a3];
  while (1)
  {
    unsigned int v8 = (uint64_t *)*v5;
    if ((*(_WORD *)(*v5 + 32) & 4) != 0 || (*((_WORD *)v8 + 18) & 0xF00) != 0) {
      break;
    }
    uint64_t v9 = *v8;
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF8;
    if ((v9 & 4) != 0 && v10)
    {
      if (*(unsigned char *)(*a1 + 654)
        || ((*(uint64_t (**)(unint64_t))(*(void *)v10 + 32))(v10) & 1) != 0)
      {
        return 0;
      }
      if ((*(unsigned int (**)(unint64_t, void))(*(void *)v10 + 40))(v10, *a1)) {
        uint64_t v11 = 2;
      }
      else {
        uint64_t v11 = 0;
      }
      unint64_t v12 = *(unsigned int *)(a4 + 8);
      if (v12 >= *(unsigned int *)(a4 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a4 + 8 * v12) = v10 | v11 | 4;
      ++*(_DWORD *)(a4 + 8);
    }
    else
    {
      uint64_t v13 = v9 & 4;
      if (v10) {
        BOOL v14 = v13 == 0;
      }
      else {
        BOOL v14 = 0;
      }
      if (!v14) {
        return 0;
      }
      unsigned int v20 = v22;
      uint64_t v21 = 0x400000000;
      UnderlyingObjectsForCodeGeuint64_t n = llvm::getUnderlyingObjectsForCodeGen(v10, (uint64_t)&v20);
      unsigned int v16 = v20;
      if (UnderlyingObjectsForCodeGen && v21)
      {
        unsigned int v17 = *(_DWORD *)(a4 + 8);
        uint64_t v18 = 8 * v21;
        do
        {
          if (v17 >= *(_DWORD *)(a4 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a4 + 8 * v17) = *v16 & 0xFFFFFFFFFFFFFFF9 | 2;
          unsigned int v17 = *(_DWORD *)(a4 + 8) + 1;
          *(_DWORD *)(a4 + 8) = v17;
          ++v16;
          v18 -= 8;
        }
        while (v18);
        unsigned int v16 = v20;
      }
      if (v16 != v22) {
        free(v16);
      }
      if (!UnderlyingObjectsForCodeGen) {
        return 0;
      }
    }
    if (++v5 == v7) {
      return 1;
    }
  }
  return 0;
}

uint64_t *sub_1CC46A4E4(uint64_t *result, unsigned int a2, unsigned int a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v4 = a2;
    uint64_t v5 = *result;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 + 176) + 48 * v4;
      uint64_t v7 = *(void *)v6;
      uint64_t v8 = *(unsigned int *)(v6 + 8);
      if (v8) {
        break;
      }
LABEL_7:
      if (v8 >= *(_DWORD *)(v6 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(v7 + 8 * v8) = a3 | (unint64_t)(a4 << 32);
      ++*(_DWORD *)(v6 + 8);
      uint64_t v5 = *result;
      uint64_t v4 = *(unsigned int *)(*(void *)(*result + 32) + 8 * v4);
      if (v4 == -1) {
        return result;
      }
    }
    uint64_t v9 = (int *)(v7 + 4);
    uint64_t v10 = 8 * v8;
    while (*(v9 - 1) != a3)
    {
      v9 += 2;
      v10 -= 8;
      if (!v10) {
        goto LABEL_7;
      }
    }
    int v11 = *v9;
    if (*v9 <= a4) {
      int v11 = a4;
    }
    *uint64_t v9 = v11;
  }
  return result;
}

uint64_t *sub_1CC46A5DC(uint64_t *result, unsigned int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(result[26] + 2 * a2);
  unsigned int v3 = *((_DWORD *)result + 2);
  if (v3 > v2)
  {
    uint64_t v4 = *result;
    do
    {
      if (*(_DWORD *)(v4 + 24 * v2 + 12) == a2)
      {
        unsigned int v5 = *(_DWORD *)(v4 + 24 * v2 + 16);
        if (v5 != -1 && *(_DWORD *)(v4 + 24 * v5 + 20) == -1) {
          break;
        }
      }
      v2 += 0x10000;
    }
    while (v2 < v3);
  }
  return result;
}

double sub_1CC46A664(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 228))
  {
    uint64_t v7 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 224);
    int v8 = *(_DWORD *)(v7 + 20);
    *(void *)uint64_t v7 = a2;
    *(void *)(v7 + 8) = a3;
    *(void *)&long long v6 = -1;
    *(void *)(v7 + 16) = -1;
    LODWORD(v7) = *(_DWORD *)(a1 + 228) - 1;
    *(_DWORD *)(a1 + 224) = v8;
    *(_DWORD *)(a1 + 228) = v7;
  }
  else
  {
    *(void *)&long long v11 = a2;
    *((void *)&v11 + 1) = a3;
    uint64_t v12 = -1;
    unsigned int v3 = *(_DWORD *)(a1 + 8);
    unint64_t v4 = *(void *)a1;
    if (v3 >= *(_DWORD *)(a1 + 12))
    {
      BOOL v9 = v4 + 24 * v3 > (unint64_t)&v11;
      if (v4 > (unint64_t)&v11 || !v9) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v5 = v4 + 24 * *(unsigned int *)(a1 + 8);
    long long v6 = v11;
    *(void *)(v5 + 16) = v12;
    *(_OWORD *)uint64_t v5 = v6;
    ++*(_DWORD *)(a1 + 8);
  }
  return *(double *)&v6;
}

uint64_t *sub_1CC46A76C(uint64_t *result, unsigned int *a2)
{
  unsigned int v2 = a2[4];
  uint64_t v3 = *result;
  if ((unsigned int *)(*result + 24 * v2) != a2)
  {
    unsigned int v4 = a2[5];
    if (*(_DWORD *)(v3 + 24 * v2 + 20) == -1)
    {
      *(_WORD *)(result[26] + 2 * a2[3]) = v4;
      *(_DWORD *)(v3 + 24 * v4 + 16) = v2;
    }
    else
    {
      unsigned int v9 = a2[4];
      uint64_t v10 = *result;
      if (v4 == -1)
      {
        uint64_t v5 = a2 + 3;
        long long v6 = result;
        uint64_t v7 = sub_1CC46A5DC(result, a2[3]);
        uint64_t result = v6;
        *(_DWORD *)(*v7 + 24 * v8 + 16) = v9;
        *(_DWORD *)(v10 + 24 * v5[1] + 20) = -1;
      }
      else
      {
        *(_DWORD *)(v3 + 24 * v4 + 16) = v9;
        *(_DWORD *)(v3 + 24 * a2[4] + 20) = v4;
      }
    }
  }
  return result;
}

uint64_t sub_1CC46A874()
{
  int v4 = 1;
  int v2 = 1;
  char v1 = 0;
  uint64_t v3 = &v1;
  v5.n128_u64[0] = (unint64_t)"Enable use of AA during MI DAG construction";
  v5.n128_u64[1] = 43;
  sub_1CD57AB10(&v4, &v2, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCD3780, &dword_1CB82C000);
  int v4 = 1;
  LOBYTE(v2) = 1;
  uint64_t v3 = (char *)&v2;
  v5.n128_u64[0] = (unint64_t)"Enable use of TBAA during MI DAG construction";
  v5.n128_u64[1] = 45;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCD3840, "use-tbaa-in-sched-mi", &v4, &v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3840, &dword_1CB82C000);
  int v4 = 1;
  int v2 = 1000;
  uint64_t v3 = (char *)&v2;
  v5.n128_u64[0] = (unint64_t)"The limit to use while constructing the DAG prior to scheduling, at which point a t"
                                     "rade-off is made to avoid excessive compile time.";
  v5.n128_u64[1] = 132;
  sub_1CD45A86C((uint64_t)&unk_1EBCD3900, "dag-maps-huge-region", &v4, (int **)&v3, &v5);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD3900, &dword_1CB82C000);
  LODWORD(v3) = 1;
  v5.n128_u64[0] = (unint64_t)"A huge scheduling region will have maps reduced by this many nodes at a time. Defau"
                                     "lts to HugeRegion / 2.";
  v5.n128_u64[1] = 105;
  sub_1CD57ACA8(&v3, (long long *)&v5);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCD39C0, &dword_1CB82C000);
}

uint64_t llvm::DOTGraphTraits<llvm::ScheduleDAG *>::getNodeLabel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48))(a3);
}

void llvm::ScoreboardHazardRecognizer::ScoreboardHazardRecognizer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1F2612E08;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  if (a2
    && (uint64_t v6 = *(void *)(a2 + 96)) != 0
    && ((unsigned int v7 = *(unsigned __int16 *)(v6 + 2), v8 = *(unsigned __int16 *)(v6 + 4), v7 == 0xFFFF)
      ? (BOOL v9 = v8 == 0xFFFF)
      : (BOOL v9 = 0),
        !v9))
  {
    int v10 = 0;
    uint64_t v11 = *(void *)(a2 + 72);
    unsigned int v5 = 1;
    do
    {
      if (v7 != v8)
      {
        unsigned int v14 = 0;
        int v15 = 0;
        unsigned int v16 = (int *)(v11 + 24 * v8);
        unsigned int v17 = (int *)(v11 + 24 * v7);
        do
        {
          int v18 = *v17;
          if (v14 <= *v17 + v15) {
            unsigned int v14 = *v17 + v15;
          }
          if (v17[4] >= 0) {
            int v18 = v17[4];
          }
          v15 += v18;
          v17 += 6;
        }
        while (v17 != v16);
        if (v14 > v5)
        {
          do
          {
            BOOL v19 = v14 > 2 * v5;
            v5 *= 2;
          }
          while (v19);
          *(_DWORD *)(a1 + 8) = v5;
        }
      }
      uint64_t v12 = v6 + 10 * ++v10;
      unsigned int v7 = *(unsigned __int16 *)(v12 + 2);
      unsigned int v8 = *(unsigned __int16 *)(v12 + 4);
    }
    while (v7 != 0xFFFF || v8 != 0xFFFF);
  }
  else
  {
    unsigned int v5 = 1;
  }
  *(void *)(a1 + 56) = v5;
  operator new[]();
}

uint64_t llvm::ScoreboardHazardRecognizer::getHazardType(void *a1, void *a2, unsigned int a3)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 96);
    if (v4)
    {
      uint64_t v5 = a2[1];
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 16);
        if (v6) {
          goto LABEL_5;
        }
      }
      else if (*a2)
      {
        int v20 = *(__int16 *)(*a2 + 24);
        if (v20 < 0)
        {
          uint64_t v6 = *(void *)(*(void *)(a1[4] + 16) + 8) + 48 * (unsigned __int16)~(_WORD)v20;
          if (v6)
          {
LABEL_5:
            uint64_t v7 = v4 + 10 * *(unsigned __int16 *)(v6 + 6);
            unsigned int v8 = *(unsigned __int16 *)(v7 + 2);
            unsigned int v9 = *(unsigned __int16 *)(v7 + 4);
            if (v8 != v9)
            {
              uint64_t v10 = *(void *)(v3 + 72);
              uint64_t v11 = (unsigned int *)(v10 + 24 * v9);
              uint64_t v12 = (unsigned int *)(v10 + 24 * v8);
              while (1)
              {
                unsigned int v13 = *v12;
                if (*v12) {
                  break;
                }
LABEL_18:
                uint64_t v3 = 0;
                if ((v12[4] & 0x80000000) == 0) {
                  unsigned int v13 = v12[4];
                }
                a3 += v13;
                v12 += 6;
                if (v12 == v11) {
                  return v3;
                }
              }
              unsigned int v14 = a3;
              uint64_t v15 = *v12;
              while (1)
              {
                if ((v14 & 0x80000000) != 0) {
                  goto LABEL_17;
                }
                uint64_t v16 = a1[10];
                if ((int)v14 >= (int)v16) {
                  goto LABEL_18;
                }
                uint64_t v17 = *((void *)v12 + 1);
                unsigned int v18 = v12[5];
                if (v18)
                {
                  if (v18 != 1) {
                    goto LABEL_16;
                  }
                  uint64_t v19 = v14;
                }
                else
                {
                  uint64_t v19 = v14;
                  v17 &= ~*(void *)(a1[6] + 8 * ((a1[7] - 1) & (a1[8] + v14)));
                }
                v17 &= ~*(void *)(a1[9] + 8 * ((a1[11] + v19) & (v16 - 1)));
LABEL_16:
                if (!v17) {
                  return 1;
                }
LABEL_17:
                ++v14;
                if (!--v15) {
                  goto LABEL_18;
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return v3;
}

void sub_1CC46AD0C(void *a1)
{
  *a1 = &unk_1F2612E08;
  uint64_t v2 = a1[9];
  if (v2) {
    MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = a1[6];
  if (v3) {
    MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CC46ADA4(void *a1)
{
  *a1 = &unk_1F2612E08;
  uint64_t v2 = a1[9];
  if (v2) {
    MEMORY[0x1D25D9CB0](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = a1[6];
  if (v3) {
    MEMORY[0x1D25D9CB0](v3, 0x1000C8000313F17);
  }
  return a1;
}

void sub_1CC46AE1C(llvm *a1, llvm::PassRegistry *a2)
{
}

void llvm::createShadowStackGCLoweringPass(llvm *this)
{
}

uint64_t sub_1CC46AEFC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EA61EF4B;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2612E88;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3A80, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC46AE1C;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCD3A80, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CC46AFBC()
{
}

void sub_1CC46AFF8(llvm::Pass *this)
{
  *(void *)this = &unk_1F2612E88;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }

  llvm::Pass::~Pass(this);
}

void sub_1CC46B058(llvm::Pass *this)
{
  *(void *)this = &unk_1F2612E88;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
  llvm::Pass::~Pass(this);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CC46B0CC(void *a1, uint64_t a2)
{
  uint64_t v2 = a2 + 24;
  uint64_t v3 = *(void *)(a2 + 32);
  if (v3 == a2 + 24) {
    return 0;
  }
  while (1)
  {
    if (v3) {
      uint64_t v6 = v3 - 56;
    }
    else {
      uint64_t v6 = 0;
    }
    if ((*(_WORD *)(v6 + 18) & 0x4000) == 0) {
      goto LABEL_21;
    }
    GC = llvm::LLVMContext::getGC(**(llvm::LLVMContext ***)v6, (const llvm::Function *)v6);
    char v50 = 12;
    strcpy((char *)__s2, "shadow-stack");
    char v8 = *((unsigned char *)GC + 23);
    uint64_t v9 = v8 & 0x7F;
    uint64_t v10 = v8 >= 0 ? v8 & 0x7F : GC[1];
    if (v10 != 12) {
      goto LABEL_21;
    }
    if ((*((unsigned char *)GC + 23) & 0x80) == 0) {
      break;
    }
    if (!memcmp((const void *)*GC, __s2, GC[1])) {
      goto LABEL_23;
    }
LABEL_21:
    uint64_t v3 = *(void *)(v3 + 8);
    if (v3 == v2) {
      return 0;
    }
  }
  if ((v8 & 0x7F) != 0)
  {
    uint64_t v11 = 0;
    uint64_t v12 = v9 - 1;
    do
    {
      int v13 = *((unsigned __int8 *)GC + v11);
      int v14 = *((unsigned __int8 *)__s2 + v11);
    }
    while (v13 == v14 && v12 != v11++);
    if (v13 != v14) {
      goto LABEL_21;
    }
  }
LABEL_23:
  uint64_t v17 = **(void **)a2 + 1960;
  unsigned int v18 = (uint64_t ***)operator new(0x10uLL);
  *unsigned int v18 = (uint64_t **)v17;
  v18[1] = (uint64_t **)v17;
  uint64_t v19 = (llvm::PointerType *)llvm::StructType::create(v18, 2, "gc_map", 6uLL, 0);
  a1[6] = v19;
  unint64_t v20 = llvm::PointerType::get(v19, 0);
  uint64_t v21 = (llvm::PointerType *)llvm::StructType::create(*(uint64_t **)a2, "gc_stackentry", 0xDuLL);
  a1[5] = v21;
  *unsigned int v18 = (uint64_t **)llvm::PointerType::get(v21, 0);
  v18[1] = (uint64_t **)v20;
  long long __p = v18;
  llvm::StructType::setBody(a1[5], (uint64_t)v18, 2, 0);
  unsigned int v45 = (llvm::Constant *)llvm::PointerType::get((llvm::PointerType *)a1[5], 0);
  unsigned int v22 = *(uint64_t **)(a2 + 112);
  unsigned int v23 = *((_DWORD *)v22 + 8);
  if (v23 <= 1) {
    uint64_t v24 = 1;
  }
  else {
    uint64_t v24 = v23;
  }
  if (v23 <= 0x11) {
    size_t v25 = v24;
  }
  else {
    size_t v25 = 18;
  }
  uint64_t v47 = *((unsigned int *)v22 + 2);
  uint64_t v48 = *(void *)(a2 + 112);
  if (!v47) {
    goto LABEL_42;
  }
  uint64_t v26 = 0;
  int v27 = 0;
  do
    int v27 = 33 * v27 + aLlvmGcRootChai[v26++];
  while (v25 != v26);
  uint64_t v28 = *v22;
  uint64_t v29 = *v22 + 8 * v47 + 8;
  int v30 = 1;
  int v31 = v27;
  while (1)
  {
    uint64_t v32 = v31 & (v47 - 1);
    unsigned int v33 = *(void **)(v28 + 8 * v32);
    if (v33 != (void *)-8)
    {
      if (!v33) {
        goto LABEL_42;
      }
      if (*(_DWORD *)(v29 + 4 * v32) == v27
        && v25 == *v33
        && !memcmp("llvm_gc_root_chain", (char *)v33 + *(unsigned int *)(v48 + 20), v25))
      {
        break;
      }
    }
    int v31 = v30 + v32;
    ++v30;
  }
  if (v32 != -1
    && (int)v32 != v47
    && (uint64_t v36 = *(void *)(*(void *)(v28 + 8 * (int)v32) + 8)) != 0
    && *(unsigned char *)(v36 + 16) == 3
    && (*(_DWORD *)(v36 + 32) & 0xFu) - 7 > 1)
  {
    a1[4] = v36;
    if ((*(unsigned char *)(v36 + 32) & 0xF) == 0 && (*(_DWORD *)(v36 + 20) & 0x7FFFFFF) == 0)
    {
      NullValue = llvm::Constant::getNullValue(v45, v34, v35);
      llvm::GlobalVariable::setInitializer(v36, NullValue);
      uint64_t v43 = (llvm::GlobalValue *)a1[4];
      int v44 = *((_DWORD *)v43 + 8);
      *((_DWORD *)v43 + 8) = v44 & 0xFFFFFFF0 | 2;
      if ((v44 & 0x30) != 0 && (llvm::GlobalValue::hasExternalWeakLinkage(v43) & 1) == 0) {
        *((_DWORD *)v43 + 8) |= 0x4000u;
      }
    }
  }
  else
  {
LABEL_42:
    a1[4] = 0;
    unint64_t v37 = (char *)operator new(0x78uLL);
    *((_DWORD *)v37 + 13) = *((_DWORD *)v37 + 13) & 0x38000000 | 1;
    uint64_t v38 = (unint64_t *)(v37 + 32);
    *(void *)unint64_t v37 = 0;
    *((void *)v37 + 1) = 0;
    *((void *)v37 + 2) = 0;
    *((void *)v37 + 3) = v37 + 32;
    unsigned int v41 = llvm::Constant::getNullValue(v45, v39, v40);
    __s2[0] = "llvm_gc_root_chain";
    __int16 v51 = 259;
    llvm::GlobalVariable::GlobalVariable(v38, a2, v45, 0, 2, (unint64_t)v41, __s2, 0, 0, 0, 0);
    a1[4] = v38;
  }
  operator delete(__p);
  return 1;
}

void sub_1CC46B47C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CC46B490(void *a1, uint64_t a2)
{
  uint64_t v278 = *MEMORY[0x1E4F143B8];
  if ((*(_WORD *)(a2 + 18) & 0x4000) == 0) {
    return 0;
  }
  uint64_t v2 = (uint64_t **)a2;
  GC = llvm::LLVMContext::getGC(**(llvm::LLVMContext ***)a2, (const llvm::Function *)a2);
  v267[7] = 12;
  strcpy((char *)&__s2, "shadow-stack");
  char v5 = *((unsigned char *)GC + 23);
  uint64_t v6 = v5 & 0x7F;
  uint64_t v7 = v5 >= 0 ? v5 & 0x7F : GC[1];
  if (v7 != 12) {
    return 0;
  }
  if ((*((unsigned char *)GC + 23) & 0x80) != 0)
  {
    if (memcmp((const void *)*GC, &__s2, GC[1])) {
      return 0;
    }
  }
  else if ((v5 & 0x7F) != 0)
  {
    uint64_t v8 = 0;
    uint64_t v9 = v6 - 1;
    do
    {
      int v10 = *((unsigned __int8 *)GC + v8);
      int v11 = v267[v8 - 16];
    }
    while (v10 == v11 && v9 != v8++);
    if (v10 != v11) {
      return 0;
    }
  }
  uint64_t j = **v2;
  *(void *)&long long __s2 = v267;
  *((void *)&__s2 + 1) = 0x1000000000;
  int v14 = v2 + 9;
  uint64_t v15 = v2[10];
  if (v15 == (uint64_t *)(v2 + 9))
  {
    size_t v252 = (long long **)(a1 + 7);
    goto LABEL_116;
  }
  int v250 = v2;
  size_t v252 = (long long **)(a1 + 7);
  do
  {
    uint64_t v16 = v15 - 3;
    if (!v15) {
      uint64_t v16 = 0;
    }
    uint64_t v17 = v16 + 5;
    for (uint64_t i = (uint64_t *)v16[6]; i != v17; uint64_t i = (uint64_t *)i[1])
    {
      uint64_t v19 = i - 3;
      if (i) {
        unint64_t v20 = i - 3;
      }
      else {
        unint64_t v20 = 0;
      }
      if (*((unsigned char *)v20 + 16) == 84)
      {
        uint64_t v21 = *(v20 - 4);
        if (v21)
        {
          if (!*(unsigned char *)(v21 + 16) && *(void *)(v21 + 24) == v20[9] && (*(unsigned char *)(v21 + 33) & 0x20) != 0)
          {
            uint64_t v22 = *(i - 7);
            if (v22)
            {
              if (!*(unsigned char *)(v22 + 16) && *(void *)(v22 + 24) == i[6] && *(_DWORD *)(v22 + 36) == 151)
              {
                unsigned int v23 = llvm::Value::stripPointerCasts((llvm::Value *)v19[-4 * (*((_DWORD *)i - 1) & 0x7FFFFFF)]);
                uint64_t v24 = v19[-4 * (*((_DWORD *)i - 1) & 0x7FFFFFF) + 4];
                if (!v24) {
                  goto LABEL_40;
                }
                unsigned int v25 = *(unsigned __int8 *)(v24 + 16);
                if (v25 > 0x14) {
                  goto LABEL_40;
                }
                if (v25 == 16)
                {
                  uint64_t v26 = *(unsigned int *)(v24 + 32);
                  if (v26 >= 0x41)
                  {
                    int v39 = 0;
                    int64_t v40 = (unint64_t)(v26 + 63) >> 6;
                    do
                    {
                      BOOL v41 = v40-- < 1;
                      if (v41) {
                        break;
                      }
                      unint64_t v42 = *(void *)(*(void *)(v24 + 24) + 8 * v40);
                      v39 += __clz(v42);
                    }
                    while (!v42);
                    int v43 = v26 | 0xFFFFFFC0;
                    if ((v26 & 0x3F) == 0) {
                      int v43 = 0;
                    }
                    if (v39 + v43 != v26)
                    {
LABEL_40:
                      if (DWORD2(__s2) >= (unint64_t)HIDWORD(__s2)) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      int v27 = (uint64_t **)(__s2 + 16 * DWORD2(__s2));
                      *int v27 = v19;
                      v27[1] = (uint64_t *)v23;
                      ++DWORD2(__s2);
                      continue;
                    }
                  }
                  else if (*(void *)(v24 + 24))
                  {
                    goto LABEL_40;
                  }
                }
                else if (v25 == 17)
                {
                  if ((sub_1CB844168(v24, 0.0) & 1) == 0) {
                    goto LABEL_40;
                  }
                }
                else if (v25 - 18 >= 3 && v25 != 13)
                {
                  goto LABEL_40;
                }
                uint64_t v253 = j;
                int v30 = (long long *)a1[8];
                unint64_t v29 = a1[9];
                uint64_t v244 = a1;
                if ((unint64_t)v30 >= v29)
                {
                  uint64_t v32 = *v252;
                  uint64_t v33 = v30 - *v252;
                  unint64_t v34 = v33 + 1;
                  if ((unint64_t)(v33 + 1) >> 60) {
                    goto LABEL_309;
                  }
                  uint64_t v35 = v29 - (void)v32;
                  if (v35 >> 3 > v34) {
                    unint64_t v34 = v35 >> 3;
                  }
                  if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  unint64_t v247 = v34;
                  if (v34)
                  {
                    if (v34 >> 60) {
                      goto LABEL_310;
                    }
                    uint64_t v36 = (char *)operator new(16 * v34);
                  }
                  else
                  {
                    uint64_t v36 = 0;
                  }
                  unint64_t v37 = &v36[16 * v33];
                  *(void *)unint64_t v37 = v19;
                  *((void *)v37 + 1) = v23;
                  uint64_t v38 = v37;
                  if (v30 != v32)
                  {
                    do
                    {
                      *((_OWORD *)v38 - 1) = *(v30 - 1);
                      v38 -= 16;
                      --v30;
                    }
                    while (v30 != v32);
                    int v30 = *v252;
                  }
                  int v31 = v37 + 16;
                  v244[7] = v38;
                  v244[8] = v37 + 16;
                  v244[9] = &v36[16 * v247];
                  if (v30) {
                    operator delete(v30);
                  }
                }
                else
                {
                  *(void *)int v30 = v19;
                  *((void *)v30 + 1) = v23;
                  int v31 = v30 + 1;
                }
                uint64_t j = v253;
                v244[8] = v31;
                a1 = v244;
              }
            }
          }
        }
      }
    }
    uint64_t v15 = (uint64_t *)v15[1];
  }
  while (v15 != (uint64_t *)v14);
  uint64_t v44 = DWORD2(__s2);
  if (DWORD2(__s2))
  {
    uint64_t v45 = j;
    uint64_t v46 = (long long *)__s2;
    uint64_t v47 = *v252;
    uint64_t v49 = (long long *)a1[8];
    uint64_t v48 = a1[9];
    uint64_t v50 = (char *)v49 - (char *)*v252;
    uint64_t v51 = v50 >> 4;
    if (DWORD2(__s2) <= (v48 - (uint64_t)v49) >> 4)
    {
      if (v51 >= DWORD2(__s2))
      {
        uint64_t v58 = (long long *)(__s2 + 16 * DWORD2(__s2));
        uint64_t v60 = (long long *)a1[8];
        uint64_t v2 = v250;
      }
      else
      {
        unint64_t v57 = 0;
        uint64_t v58 = (long long *)(__s2 + 16 * v51);
        uint64_t v59 = 16 * DWORD2(__s2) - 16 * v51;
        uint64_t v2 = v250;
        do
        {
          v49[v57 / 0x10] = v58[v57 / 0x10];
          v57 += 16;
        }
        while (v59 != v57);
        uint64_t v60 = &v49[v57 / 0x10];
        a1[8] = v60;
        if (v50 < 1) {
          goto LABEL_115;
        }
      }
      unsigned int v61 = &v47[v44];
      uint64_t v62 = &v60[-v44];
      uint64_t v63 = v60;
      if (v62 < v49)
      {
        uint64_t v63 = v60;
        do
        {
          long long v64 = *v62++;
          *v63++ = v64;
        }
        while (v62 < v49);
      }
      a1[8] = v63;
      if (v60 != v61)
      {
        uint64_t v65 = v60 - v61;
        uint64_t v66 = (void *)v60 - 1;
        uint64_t v67 = v65;
        do
        {
          *(v66 - 1) = *(void *)&v47[v67 - 1];
          *uint64_t v66 = *((void *)&v47[v67 - 1] + 1);
          v66 -= 2;
          --v67;
        }
        while (v67 * 16);
      }
      for (uint64_t j = v45; v46 != v58; ++v47)
      {
        long long v68 = *v46++;
        long long *v47 = v68;
      }
    }
    else
    {
      unint64_t v52 = v51 + DWORD2(__s2);
      if (v52 >> 60) {
LABEL_309:
      }
        abort();
      uint64_t v53 = a1;
      uint64_t v54 = v48 - (void)v47;
      if (v54 >> 3 > v52) {
        unint64_t v52 = v54 >> 3;
      }
      if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v55 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v52;
      }
      uint64_t v2 = v250;
      if (v55)
      {
        if (v55 >> 60) {
LABEL_310:
        }
          sub_1CB833614();
        uint64_t v56 = (char *)operator new(16 * v55);
      }
      else
      {
        uint64_t v56 = 0;
      }
      uint64_t v69 = 0;
      uint64_t v70 = &v56[16 * v44];
      do
      {
        *(_OWORD *)&v56[v69 * 16] = v46[v69];
        ++v69;
      }
      while (v44 != v69);
      uint64_t v71 = &v56[16 * v55];
      if (v47 == v49)
      {
        a1 = v53;
      }
      else
      {
        uint64_t v72 = v47;
        a1 = v53;
        do
        {
          long long v73 = *v72++;
          *(_OWORD *)uint64_t v70 = v73;
          v70 += 16;
        }
        while (v72 != v49);
      }
      a1[7] = v56;
      a1[8] = v70;
      a1[9] = v71;
      if (v47) {
        operator delete(v47);
      }
LABEL_115:
      uint64_t j = v45;
    }
  }
  else
  {
    uint64_t v2 = v250;
  }
LABEL_116:
  if ((unsigned char *)__s2 != v267) {
    free((void *)__s2);
  }
  if (a1[7] == a1[8]) {
    return 0;
  }
  uint64_t v254 = j;
  LOBYTE(__s2) = 0;
  char v268 = 0;
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass(*(llvm::PMDataManager **)(a1[1] + 24), &llvm::DominatorTreeWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t v76 = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::DominatorTreeWrapperPass::ID);
    if (v76)
    {
      LOBYTE(v255) = 1;
      sub_1CD516784((uint64_t)&__s2, v76 + 32, (char *)&v255);
    }
  }
  size_t v251 = v2;
  char v77 = (llvm::Constant *)llvm::PointerType::get((llvm::PointerType *)(*(void *)**v2 + 1912), 0);
  LODWORD(v2) = 0;
  unint64_t v255 = v257;
  uint64_t v256 = 0x1000000000;
  uint64_t v78 = a1[7];
  if (a1[8] != v78)
  {
    uint64_t v83 = 0;
    int v84 = 0;
    LODWORD(v85) = 0;
    while (1)
    {
      unint64_t v86 = *(llvm::detail::IEEEFloat **)(*(void *)(v78 + 16 * v83)
                                        - 32 * (*(_DWORD *)(*(void *)(v78 + 16 * v83) + 20) & 0x7FFFFFF)
                                        + 32);
      unsigned int v87 = *((unsigned __int8 *)v86 + 16);
      if (!v86 || v87 != 16) {
        break;
      }
      uint64_t v89 = *((unsigned int *)v86 + 8);
      if (v89 >= 0x41)
      {
        int v93 = 0;
        int64_t v94 = (unint64_t)(v89 + 63) >> 6;
        do
        {
          BOOL v41 = v94-- < 1;
          if (v41) {
            break;
          }
          unint64_t v95 = *(void *)(*((void *)v86 + 3) + 8 * v94);
          v93 += __clz(v95);
        }
        while (!v95);
        int v96 = v89 | 0xFFFFFFC0;
        if ((v89 & 0x3F) == 0) {
          int v96 = 0;
        }
        int v85 = (uint64_t **)(v85 + 1);
        uint64_t v2 = v85;
        if (v93 + v96 != v89) {
          goto LABEL_145;
        }
LABEL_134:
        uint64_t v2 = v84;
        goto LABEL_145;
      }
      int v85 = (uint64_t **)(v85 + 1);
      uint64_t v2 = v85;
      if (!*((void *)v86 + 3)) {
        goto LABEL_134;
      }
LABEL_145:
      if (*(llvm::Constant **)v86 != v77) {
        unint64_t v86 = sub_1CC56C0C0((llvm *)0x31, v86, v77, 0);
      }
      if (v256 >= (unint64_t)HIDWORD(v256)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v255 + v256) = v86;
      LODWORD(v256) = v256 + 1;
      uint64_t v83 = v85;
      uint64_t v78 = a1[7];
      int v84 = v2;
      if (v85 == (a1[8] - v78) >> 4) {
        goto LABEL_124;
      }
    }
    if (v86) {
      BOOL v90 = v87 == 17;
    }
    else {
      BOOL v90 = 0;
    }
    if (v90)
    {
      int v85 = (uint64_t **)(v85 + 1);
      uint64_t v2 = v85;
      if ((sub_1CB844168((uint64_t)v86, 0.0) & 1) == 0) {
        goto LABEL_145;
      }
    }
    else
    {
      BOOL v41 = v87 > 0x14;
      int v91 = (1 << v87) & 0x1C2000;
      int v85 = (uint64_t **)(v85 + 1);
      if (v41 || v91 == 0)
      {
        uint64_t v2 = v85;
        goto LABEL_145;
      }
    }
    goto LABEL_134;
  }
LABEL_124:
  unint64_t v79 = v2;
  sub_1CC34BDE0((uint64_t)&v255, v2);
  uint64_t v80 = (llvm::ConstantInt *)(*(void *)**v251 + 1960);
  uint64_t v273 = 0;
  uint64_t v274 = 0;
  uint64_t v273 = (const char *)llvm::ConstantInt::get(v80, (uint64_t)(a1[8] - a1[7]) >> 4, 0);
  uint64_t v274 = llvm::ConstantInt::get(v80, v2, 0);
  int v271 = 0;
  uint64_t v272 = 0;
  int v271 = (uint64_t ***)llvm::ConstantStruct::get((llvm::PoisonValue *)a1[6], (llvm::Type *)&v273, 2);
  uint64_t v81 = llvm::ArrayType::get(v77, (llvm::Type *)v2);
  uint64_t v272 = llvm::ConstantArray::get(v81, (llvm::Type *)v255, v256);
  uint64_t v269 = 0;
  uint64_t v270 = 0;
  uint64_t v269 = *v271;
  uint64_t v270 = *(void *)v272;
  if (v2)
  {
    uint64_t v82 = (char *)v261 + 5;
    do
    {
      *--uint64_t v82 = (v79 % 0xA) | 0x30;
      BOOL v41 = v79 > 9;
      v79 /= 0xAuLL;
    }
    while (v41);
  }
  else
  {
    uint64_t v82 = (char *)v261 + 4;
    BYTE4(v261[0]) = 48;
  }
  sub_1CC028D80(&v276, v82, (char *)v261 + 5, (char *)v261 + 5 - v82);
  uint64_t v97 = std::string::insert(&v276, 0, "gc_map.");
  std::string::size_type v98 = v97->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = *(_OWORD *)&v97->__r_.__value_.__l.__data_;
  v261[0] = v98;
  v97->__r_.__value_.__l.__size_ = 0;
  v97->__r_.__value_.__r.__words[2] = 0;
  v97->__r_.__value_.__r.__words[0] = 0;
  if (v261[0] >= 0) {
    int v99 = (unsigned __int8 *)__p;
  }
  else {
    int v99 = (unsigned __int8 *)__p[0];
  }
  if (v261[0] >= 0) {
    size_t v100 = HIBYTE(v261[0]) & 0x7F;
  }
  else {
    size_t v100 = (size_t)__p[1];
  }
  unsigned int v101 = (llvm::PoisonValue *)llvm::StructType::create(&v269, 2, v99, v100, 0);
  if (SHIBYTE(v261[0]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v276.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v276.__r_.__value_.__l.__data_);
  }
  uint64_t v102 = llvm::ConstantStruct::get(v101, (llvm::Type *)&v271, 2);
  uint64_t v103 = (char *)operator new(0x78uLL);
  unint64_t v104 = (uint64_t *)(v103 + 32);
  *((_DWORD *)v103 + 13) = *((_DWORD *)v103 + 13) & 0x38000000 | 1;
  *(void *)uint64_t v103 = 0;
  *((void *)v103 + 1) = 0;
  *((void *)v103 + 2) = 0;
  *((void *)v103 + 3) = v103 + 32;
  uint64_t v105 = (uint64_t)v251[5];
  unint64_t v106 = (llvm::PointerType *)*v102;
  if ((*((unsigned char *)v251 + 23) & 0x10) != 0)
  {
    uint64_t v107 = *(void *)**v251;
    uint64_t v108 = *(void *)(v107 + 152);
    uint64_t v109 = *(unsigned int *)(v107 + 168);
    if (!v109) {
      goto LABEL_179;
    }
    LODWORD(v110) = (v109 - 1) & ((v251 >> 4) ^ (v251 >> 9));
    uint64_t v111 = (uint64_t ***)(v108 + 16 * v110);
    unsigned int v112 = *v111;
    if (*v111 != v251)
    {
      int v113 = 1;
      while (v112 != (uint64_t **)-4096)
      {
        int v114 = v110 + v113++;
        uint64_t v110 = v114 & (v109 - 1);
        unsigned int v112 = *(uint64_t ***)(v108 + 16 * v110);
        if (v112 == v251)
        {
          uint64_t v111 = (uint64_t ***)(v108 + 16 * v110);
          goto LABEL_180;
        }
      }
LABEL_179:
      uint64_t v111 = (uint64_t ***)(v108 + 16 * v109);
    }
LABEL_180:
    unsigned int v115 = v111[1];
    uint64_t v118 = *v115;
    uint64_t v116 = (char *)(v115 + 2);
    uint64_t v117 = v118;
  }
  else
  {
    uint64_t v117 = 0;
    uint64_t v116 = &byte_1CFBCE98E;
  }
  __int16 v262 = 1283;
  __p[0] = "__gc_";
  v261[0] = v116;
  v261[1] = v117;
  llvm::GlobalVariable::GlobalVariable((unint64_t *)v103 + 4, v105, v106, 1, 7, (unint64_t)v102, (const char **)__p, 0, 0, 0, 0);
  *(_OWORD *)&v276.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v120 = *(void *)**v251;
  uint64_t v121 = *(llvm::ConstantInt **)(v120 + 1960);
  unsigned int v122 = *(_DWORD *)(v120 + 1968);
  LODWORD(__p[1]) = v122 >> 8;
  if (v122 >> 8 >= 0x41) {
    operator new[]();
  }
  __p[0] = 0;
  uint64_t v124 = llvm::ConstantInt::get(v121, (llvm::LLVMContext *)__p, v119);
  if (LODWORD(__p[1]) >= 0x41 && __p[0]) {
    MEMORY[0x1D25D9CB0](__p[0], 0x1000C8000313F17);
  }
  v276.__r_.__value_.__r.__words[0] = (std::string::size_type)v124;
  uint64_t v125 = *(void *)**v251;
  uint64_t v126 = *(llvm::ConstantInt **)(v125 + 1960);
  unsigned int v127 = *(_DWORD *)(v125 + 1968);
  LODWORD(__p[1]) = v127 >> 8;
  if (v127 >> 8 >= 0x41) {
    operator new[]();
  }
  __p[0] = 0;
  uint64_t v128 = llvm::ConstantInt::get(v126, (llvm::LLVMContext *)__p, v123);
  if (LODWORD(__p[1]) >= 0x41 && __p[0]) {
    MEMORY[0x1D25D9CB0](__p[0], 0x1000C8000313F17);
  }
  v276.__r_.__value_.__l.__size_ = (std::string::size_type)v128;
  uint64_t ElementPtr = llvm::ConstantExpr::getGetElementPtr(*v102, v104, (uint64_t)&v276, 2, 0, 0, 0);
  if (v255 != v257) {
    free(v255);
  }
  uint64_t v129 = a1[5];
  unsigned int v130 = (char *)operator new(8uLL);
  unsigned int v131 = v130;
  uint64_t v132 = a1;
  *(void *)unsigned int v130 = v129;
  uint64_t v133 = v130 + 8;
  uint64_t v134 = v132[7];
  uint64_t v135 = v132[8];
  uint64_t v245 = v132;
  if (v134 != v135)
  {
    uint64_t v137 = v130 + 8;
    while (1)
    {
      uint64_t v138 = *(void *)(*(void *)(v134 + 8) + 64);
      if (v137 >= v133) {
        break;
      }
      *(void *)uint64_t v137 = v138;
      uint64_t v136 = v137 + 8;
LABEL_209:
      v134 += 16;
      uint64_t v137 = v136;
      if (v134 == v135) {
        goto LABEL_210;
      }
    }
    uint64_t v139 = (v137 - v131) >> 3;
    unint64_t v140 = v139 + 1;
    if ((unint64_t)(v139 + 1) >> 61) {
      goto LABEL_309;
    }
    if ((v133 - v131) >> 2 > v140) {
      unint64_t v140 = (v133 - v131) >> 2;
    }
    if ((unint64_t)(v133 - v131) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v141 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v141 = v140;
    }
    if (v141)
    {
      if (v141 >> 61) {
        goto LABEL_310;
      }
      size_t v142 = (char *)operator new(8 * v141);
    }
    else
    {
      size_t v142 = 0;
    }
    uint64_t v143 = &v142[8 * v139];
    uint64_t v133 = &v142[8 * v141];
    *(void *)uint64_t v143 = v138;
    uint64_t v136 = v143 + 8;
    if (v137 == v131)
    {
      unsigned int v131 = v137;
    }
    else
    {
      do
      {
        uint64_t v144 = *((void *)v137 - 1);
        v137 -= 8;
        *((void *)v143 - 1) = v144;
        v143 -= 8;
      }
      while (v137 != v131);
      if (!v131) {
        goto LABEL_208;
      }
    }
    operator delete(v131);
LABEL_208:
    unsigned int v131 = v143;
    goto LABEL_209;
  }
  uint64_t v136 = v130 + 8;
LABEL_210:
  if ((*((unsigned char *)v251 + 23) & 0x10) != 0)
  {
    uint64_t v145 = *(void *)**v251;
    uint64_t v146 = *(void *)(v145 + 152);
    uint64_t v147 = *(unsigned int *)(v145 + 168);
    if (!v147) {
      goto LABEL_217;
    }
    LODWORD(v148) = (v147 - 1) & ((v251 >> 4) ^ (v251 >> 9));
    uint64_t v149 = (uint64_t ***)(v146 + 16 * v148);
    uint64_t v150 = *v149;
    if (*v149 != v251)
    {
      int v151 = 1;
      while (v150 != (uint64_t **)-4096)
      {
        int v152 = v148 + v151++;
        uint64_t v148 = v152 & (v147 - 1);
        uint64_t v150 = *(uint64_t ***)(v146 + 16 * v148);
        if (v150 == v251)
        {
          uint64_t v149 = (uint64_t ***)(v146 + 16 * v148);
          goto LABEL_218;
        }
      }
LABEL_217:
      uint64_t v149 = (uint64_t ***)(v146 + 16 * v147);
    }
LABEL_218:
    uint64_t v153 = v149[1];
    uint64_t v156 = *v153;
    int v154 = (char *)(v153 + 2);
    uint64_t v155 = v156;
  }
  else
  {
    uint64_t v155 = 0;
    int v154 = &byte_1CFBCE98E;
  }
  LOWORD(v258) = 1283;
  unint64_t v255 = "gc_stackentry.";
  v257[0] = v154;
  v257[1] = v155;
  llvm::Twine::str((llvm::Twine *)&v255, __p);
  if (v261[0] >= 0) {
    uint64_t v157 = (unsigned __int8 *)__p;
  }
  else {
    uint64_t v157 = (unsigned __int8 *)__p[0];
  }
  if (v261[0] >= 0) {
    size_t v158 = HIBYTE(v261[0]) & 0x7F;
  }
  else {
    size_t v158 = (size_t)__p[1];
  }
  uint64_t v159 = (llvm::Type *)llvm::StructType::create((uint64_t ***)v131, (v136 - v131) >> 3, v157, v158, 0);
  if (SHIBYTE(v261[0]) < 0) {
    operator delete(__p[0]);
  }
  if (v131) {
    operator delete(v131);
  }
  uint64_t v160 = v251[10];
  if (v160) {
    int v161 = v160 - 3;
  }
  else {
    int v161 = 0;
  }
  uint64_t v162 = v161[6];
  uint64_t v163 = v162 - 24;
  if (!v162) {
    uint64_t v163 = 0;
  }
  sub_1CBF537B4((uint64_t)__p, *(uint64_t ***)(v163 + 40), v162, 0, 0, 0);
  unint64_t v255 = "gc_frame";
  LOWORD(v258) = 259;
  uint64_t v164 = (uint64_t *)sub_1CB935044((uint64_t *)__p, v159, 0, (uint64_t)&v255);
  uint64_t v165 = v251[10];
  if (v165) {
    uint64_t v166 = (llvm::BasicBlock *)(v165 - 3);
  }
  else {
    uint64_t v166 = 0;
  }
  size_t v263 = v166;
  FirstNonPHIOrDbgOrAlloca = llvm::BasicBlock::getFirstNonPHIOrDbgOrAlloca(v166);
  uint64_t v264 = FirstNonPHIOrDbgOrAlloca;
  int v168 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)v245[5], 0);
  uint64_t v169 = v245[4];
  v276.__r_.__value_.__r.__words[0] = (std::string::size_type)"gc_currhead";
  __int16 v277 = 259;
  char Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*((void *)v263 + 7) + 40) + 272), v168, 1);
  uint64_t v171 = operator new(0x60uLL);
  v171[13] = v171[13] & 0x38000000 | 1;
  uint64_t v172 = (llvm::Instruction *)(v171 + 8);
  *(void *)uint64_t v171 = 0;
  *((void *)v171 + 1) = 0;
  *((void *)v171 + 2) = 0;
  *((void *)v171 + 3) = v171 + 8;
  uint64_t v243 = v171;
  LOWORD(v258) = 257;
  llvm::LoadInst::LoadInst((llvm::Value *)(v171 + 8), (uint64_t)v168, v169, (const char **)&v255, 0, Alignment, 0);
  (*(void (**)(uint64_t, llvm::Instruction *, std::string *, llvm::BasicBlock *, char *))(*(void *)v265
                                                                                                  + 16))(v265, v172, &v276, v263, v264);
  if (LODWORD(__p[1]))
  {
    uint64_t v232 = (llvm::MDNode **)__p[0];
    uint64_t v233 = (llvm::MDNode **)((char *)__p[0] + 16 * LODWORD(__p[1]));
    do
    {
      llvm::Instruction::setMetadata(v172, *(_DWORD *)v232, v232[1]);
      v232 += 2;
    }
    while (v232 != v233);
  }
  uint64_t v173 = sub_1CC46CC78(v254, (uint64_t *)__p, v159, v164, 1u, "gc_frame.map");
  char v174 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*((void *)v263 + 7) + 40) + 272), *(llvm::Type **)ElementPtr, 1);
  unsigned int v175 = (char *)operator new(0x80uLL);
  *((_DWORD *)v175 + 21) = *((_DWORD *)v175 + 21) & 0x38000000 | 2;
  *(void *)unsigned int v175 = 0;
  *((void *)v175 + 2) = 0;
  *((void *)v175 + 1) = 0;
  *((void *)v175 + 5) = 0;
  *((void *)v175 + 6) = 0;
  *((void *)v175 + 4) = 0;
  uint64_t v176 = (uint64_t *)(v175 + 32);
  *((void *)v175 + 8) = ***(void ***)ElementPtr + 1576;
  uint64_t v177 = (llvm::Instruction *)(v175 + 64);
  *((void *)v175 + 3) = v175 + 64;
  *((void *)v175 + 7) = v175 + 64;
  *((void *)v175 + 9) = 0;
  v175[80] = 61;
  v175[81] = 0;
  *((_WORD *)v175 + 41) = 0;
  *((_DWORD *)v175 + 21) = 2;
  *(_OWORD *)(v175 + 88) = 0u;
  *(_OWORD *)(v175 + 104) = 0u;
  *((_DWORD *)v175 + 30) = 0;
  *(void *)unsigned int v175 = ElementPtr;
  uint64_t v179 = (void *)(ElementPtr + 8);
  uint64_t v178 = *(void *)(ElementPtr + 8);
  *((void *)v175 + 1) = v178;
  if (v178) {
    *(void *)(v178 + 16) = v175 + 8;
  }
  *((void *)v175 + 2) = v179;
  void *v179 = v175;
  if (*((void *)v175 + 4))
  {
    **((void **)v175 + 6) = *((void *)v175 + 5);
    uint64_t v240 = *((void *)v175 + 5);
    if (v240) {
      *(void *)(v240 + 16) = *((void *)v175 + 6);
    }
  }
  uint64_t *v176 = v173;
  if (v173)
  {
    uint64_t v182 = *(void *)(v173 + 8);
    uint64_t v181 = (uint64_t **)(v173 + 8);
    uint64_t v180 = v182;
    *((void *)v175 + 5) = v182;
    if (v182) {
      *(void *)(v180 + 16) = v175 + 40;
    }
    *((void *)v175 + 6) = v181;
    *uint64_t v181 = v176;
  }
  uint64_t v242 = v172;
  size_t v246 = v164;
  long long v249 = v159;
  *((_WORD *)v175 + 41) = 2 * (v174 & 0x3F);
  v175[124] = 1;
  LOWORD(v258) = 257;
  (*(void (**)(uint64_t, llvm::Instruction *, void **, llvm::BasicBlock *, char *))(*(void *)v265 + 16))(v265, v177, &v255, v263, v264);
  if (LODWORD(__p[1]))
  {
    uint64_t v234 = (llvm::MDNode **)__p[0];
    uint64_t v235 = (llvm::MDNode **)((char *)__p[0] + 16 * LODWORD(__p[1]));
    do
    {
      llvm::Instruction::setMetadata(v177, *(_DWORD *)v234, v234[1]);
      v234 += 2;
    }
    while (v234 != v235);
  }
  unint64_t v183 = v245[8] - v245[7];
  if ((v183 & 0xFFFFFFFF0) != 0)
  {
    uint64_t v184 = 0;
    uint64_t v185 = (v183 >> 4);
    uint64_t v186 = 8;
    do
    {
      int v187 = (int32x2_t ****)sub_1CC46CFB0(v254, (uint64_t *)__p, v249, v164, ++v184, "gc_root");
      int v188 = *(llvm::Value **)((char *)*v252 + v186);
      llvm::Value::takeName(v187, v188);
      llvm::Value::doRAUW(v188, (llvm::Value *)v187, (llvm::Value *)1);
      v186 += 16;
    }
    while (v185 != v184);
  }
  uint64_t v189 = FirstNonPHIOrDbgOrAlloca - 24;
  if (!FirstNonPHIOrDbgOrAlloca) {
    uint64_t v189 = 0;
  }
  if (v189[16] == 61)
  {
    uint64_t v190 = v254;
    int v192 = v164;
    int v191 = v249;
    uint64_t v194 = v242;
    uint64_t v193 = v243;
    do
    {
      FirstNonPHIOrDbgOrAlloca = (char *)*((void *)FirstNonPHIOrDbgOrAlloca + 1);
      int v195 = FirstNonPHIOrDbgOrAlloca - 24;
      if (!FirstNonPHIOrDbgOrAlloca) {
        int v195 = 0;
      }
    }
    while (v195[16] == 61);
  }
  else
  {
    uint64_t v190 = v254;
    int v192 = v164;
    int v191 = v249;
    uint64_t v194 = v242;
    uint64_t v193 = v243;
  }
  sub_1CBF5385C((uint64_t)__p, *((void *)FirstNonPHIOrDbgOrAlloca + 2), (uint64_t)FirstNonPHIOrDbgOrAlloca);
  uint64_t v196 = sub_1CC46CC78(v190, (uint64_t *)__p, v191, v192, 0, "gc_frame.next");
  uint64_t v197 = sub_1CC46CFB0(v190, (uint64_t *)__p, v191, v192, 0, "gc_newhead");
  char v198 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*((void *)v263 + 7) + 40) + 272), *((llvm::Type **)v193 + 4), 1);
  uint64_t v199 = (char *)operator new(0x80uLL);
  *((_DWORD *)v199 + 21) = *((_DWORD *)v199 + 21) & 0x38000000 | 2;
  *(void *)uint64_t v199 = 0;
  *((void *)v199 + 2) = 0;
  *((void *)v199 + 1) = 0;
  *((void *)v199 + 4) = 0;
  *((void *)v199 + 5) = 0;
  *((void *)v199 + 6) = 0;
  *((void *)v199 + 8) = ***((void ***)v193 + 4) + 1576;
  unint64_t v200 = (llvm::Instruction *)(v199 + 64);
  *((void *)v199 + 3) = v199 + 64;
  *((void *)v199 + 7) = v199 + 64;
  *((void *)v199 + 9) = 0;
  v199[80] = 61;
  v199[81] = 0;
  *((_DWORD *)v199 + 21) = 2;
  *(_OWORD *)(v199 + 88) = 0u;
  *(_OWORD *)(v199 + 104) = 0u;
  *((_DWORD *)v199 + 30) = 0;
  uint64_t v203 = *((void *)v193 + 5);
  unsigned int v202 = v193 + 10;
  uint64_t v201 = v203;
  *(void *)uint64_t v199 = v194;
  *((void *)v199 + 1) = v203;
  if (v203) {
    *(void *)(v201 + 16) = v199 + 8;
  }
  *((void *)v199 + 2) = v202;
  *unsigned int v202 = v199;
  *((void *)v199 + 4) = v196;
  if (v196)
  {
    uint64_t v206 = *(void *)(v196 + 8);
    int32x2_t v205 = (void *)(v196 + 8);
    uint64_t v204 = v206;
    *((void *)v199 + 5) = v206;
    if (v206) {
      *(void *)(v204 + 16) = v199 + 40;
    }
    *((void *)v199 + 6) = v205;
    *int32x2_t v205 = v199 + 32;
  }
  *((_WORD *)v199 + 41) = 2 * (v198 & 0x3F);
  v199[124] = 1;
  LOWORD(v258) = 257;
  (*(void (**)(uint64_t, llvm::Instruction *, void **, llvm::BasicBlock *, char *))(*(void *)v265 + 16))(v265, v200, &v255, v263, v264);
  if (LODWORD(__p[1]))
  {
    int v236 = (llvm::MDNode **)__p[0];
    uint64_t v237 = (llvm::MDNode **)((char *)__p[0] + 16 * LODWORD(__p[1]));
    do
    {
      llvm::Instruction::setMetadata(v200, *(_DWORD *)v236, v236[1]);
      v236 += 2;
    }
    while (v236 != v237);
  }
  uint64_t v207 = v245[4];
  char v208 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*((void *)v263 + 7) + 40) + 272), *(llvm::Type **)v197, 1);
  int v209 = (char *)operator new(0x80uLL);
  *((_DWORD *)v209 + 21) = *((_DWORD *)v209 + 21) & 0x38000000 | 2;
  *(void *)int v209 = 0;
  *((void *)v209 + 2) = 0;
  *((void *)v209 + 1) = 0;
  *((void *)v209 + 5) = 0;
  *((void *)v209 + 6) = 0;
  *((void *)v209 + 4) = 0;
  unsigned int v210 = v209 + 32;
  *((void *)v209 + 8) = ***(void ***)v197 + 1576;
  uint64_t v211 = (llvm::Instruction *)(v209 + 64);
  *((void *)v209 + 3) = v209 + 64;
  *((void *)v209 + 7) = v209 + 64;
  *((void *)v209 + 9) = 0;
  v209[80] = 61;
  v209[81] = 0;
  *((_WORD *)v209 + 41) = 0;
  *((_DWORD *)v209 + 21) = 2;
  *(_OWORD *)(v209 + 88) = 0u;
  *(_OWORD *)(v209 + 104) = 0u;
  *((_DWORD *)v209 + 30) = 0;
  *(void *)int v209 = v197;
  uint64_t v214 = *(void *)(v197 + 8);
  int v213 = (void *)(v197 + 8);
  uint64_t v212 = v214;
  *((void *)v209 + 1) = v214;
  if (v214) {
    *(void *)(v212 + 16) = v209 + 8;
  }
  *((void *)v209 + 2) = v213;
  *int v213 = v209;
  if (*((void *)v209 + 4))
  {
    **((void **)v209 + 6) = *((void *)v209 + 5);
    uint64_t v241 = *((void *)v209 + 5);
    if (v241) {
      *(void *)(v241 + 16) = *((void *)v209 + 6);
    }
  }
  *unsigned int v210 = v207;
  if (v207)
  {
    uint64_t v217 = *(void *)(v207 + 8);
    uint64_t v216 = (void *)(v207 + 8);
    uint64_t v215 = v217;
    *((void *)v209 + 5) = v217;
    if (v217) {
      *(void *)(v215 + 16) = v209 + 40;
    }
    *((void *)v209 + 6) = v216;
    *uint64_t v216 = v210;
  }
  *((_WORD *)v209 + 41) = 2 * (v208 & 0x3F);
  v209[124] = 1;
  LOWORD(v258) = 257;
  (*(void (**)(uint64_t, llvm::Instruction *, void **, llvm::BasicBlock *, char *))(*(void *)v265 + 16))(v265, v211, &v255, v263, v264);
  if (LODWORD(__p[1]))
  {
    size_t v238 = (llvm::MDNode **)__p[0];
    size_t v239 = (llvm::MDNode **)((char *)__p[0] + 16 * LODWORD(__p[1]));
    do
    {
      llvm::Instruction::setMetadata(v211, *(_DWORD *)v238, v238[1]);
      v238 += 2;
    }
    while (v238 != v239);
  }
  if (v268) {
    p_s2 = &__s2;
  }
  else {
    p_s2 = 0;
  }
  sub_1CC46D220((uint64_t)&v255, v251, (uint64_t)"gc_cleanup", 1, (uint64_t)p_s2);
  int v219 = llvm::EscapeEnumerator::Next((llvm::EscapeEnumerator *)&v255);
  int32x2_t v220 = v245;
  if (v219)
  {
    uint64_t v221 = v219;
    do
    {
      uint64_t v222 = sub_1CC46CC78(v254, (uint64_t *)v221, v249, v246, 0, "gc_frame.next");
      uint64_t v223 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)v220[5], 0);
      uint64_t v273 = "gc_savedhead";
      __int16 v275 = 259;
      char v224 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*(void *)(*((void *)v221 + 6) + 56) + 40) + 272), v223, 1);
      int32x2_t v225 = operator new(0x60uLL);
      v225[13] = v225[13] & 0x38000000 | 1;
      uint64_t v226 = (llvm::Instruction *)(v225 + 8);
      *(void *)int32x2_t v225 = 0;
      *((void *)v225 + 1) = 0;
      *((void *)v225 + 2) = 0;
      *((void *)v225 + 3) = v225 + 8;
      __int16 v277 = 257;
      llvm::LoadInst::LoadInst((llvm::Value *)(v225 + 8), (uint64_t)v223, v222, (const char **)&v276.__r_.__value_.__l.__data_, 0, v224, 0);
      (*(void (**)(void, llvm::Instruction *, const char **, void, void))(**((void **)v221 + 10)
                                                                                         + 16))(*((void *)v221 + 10), v226, &v273, *((void *)v221 + 6), *((void *)v221 + 7));
      uint64_t v227 = *((unsigned int *)v221 + 2);
      unsigned int v228 = v220;
      if (v227)
      {
        uint64_t v229 = *(void *)v221;
        uint64_t v230 = *(void *)v221 + 16 * v227;
        do
        {
          llvm::Instruction::setMetadata(v226, *(_DWORD *)v229, *(llvm::MDNode **)(v229 + 8));
          v229 += 16;
        }
        while (v229 != v230);
      }
      sub_1CC27BF8C((uint64_t *)v221, (uint64_t)v226, v228[4], 0, 0);
      uint64_t v221 = llvm::EscapeEnumerator::Next((llvm::EscapeEnumerator *)&v255);
      int32x2_t v220 = v228;
    }
    while (v221);
  }
  uint64_t v231 = v220[7];
  if (v231 != v220[8]) {
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
  v220[8] = v231;
  if (v258 != &v259) {
    free(v258);
  }
  if (__p[0] != v261) {
    free(__p[0]);
  }
  if (v268) {
    sub_1CC2930C0((uint64_t)&__s2);
  }
  return 1;
}

uint64_t sub_1CC46CC78(uint64_t a1, uint64_t *a2, const llvm::APInt *a3, uint64_t *a4, unsigned int a5, unsigned char *a6)
{
  v31[3] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(llvm::ConstantInt **)(*(void *)a1 + 1960);
  unsigned int v13 = *(_DWORD *)(*(void *)a1 + 1968);
  unsigned int v28 = v13 >> 8;
  if (v13 >> 8 >= 0x41) {
    operator new[]();
  }
  int v27 = 0;
  uint64_t v15 = llvm::ConstantInt::get(v12, (llvm::LLVMContext *)&v27, a3);
  if (v28 >= 0x41 && v27) {
    MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
  }
  v31[0] = (uint64_t)v15;
  uint64_t v16 = *(llvm::ConstantInt **)(*(void *)a1 + 1960);
  unsigned int v17 = *(_DWORD *)(*(void *)a1 + 1968);
  unsigned int v28 = v17 >> 8;
  if (v17 >> 8 >= 0x41) {
    operator new[]();
  }
  int v27 = 0;
  uint64_t v19 = llvm::ConstantInt::get(v16, (llvm::LLVMContext *)&v27, v14);
  if (v28 >= 0x41 && v27) {
    MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
  }
  v31[1] = (uint64_t)v19;
  uint64_t v20 = a5;
  uint64_t v21 = *(llvm::ConstantInt **)(*(void *)a1 + 1960);
  unsigned int v22 = *(_DWORD *)(*(void *)a1 + 1968);
  unsigned int v28 = v22 >> 8;
  if (v22 >> 8 > 0x40) {
    operator new[]();
  }
  if (v22 <= 0xFF) {
    unint64_t v23 = 0;
  }
  else {
    unint64_t v23 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v22) + 63);
  }
  int v27 = (unsigned char *)(v23 & v20);
  uint64_t v24 = llvm::ConstantInt::get(v21, (llvm::LLVMContext *)&v27, v18);
  if (v28 >= 0x41 && v27) {
    MEMORY[0x1D25D9CB0](v27, 0x1000C8000313F17);
  }
  v31[2] = (uint64_t)v24;
  char v25 = 1;
  char v30 = 1;
  if (*a6)
  {
    int v27 = a6;
    char v25 = 3;
  }
  char v29 = v25;
  uint64_t result = sub_1CC27CEC0(a2, (uint64_t)a3, a4, v31, 3, (uint64_t)&v27);
  if (*(unsigned char *)(result + 16) != 62) {
    return 0;
  }
  return result;
}

uint64_t sub_1CC46CFB0(uint64_t a1, uint64_t *a2, const llvm::APInt *a3, uint64_t *a4, int a5, unsigned char *a6)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(llvm::ConstantInt **)(*(void *)a1 + 1960);
  unsigned int v13 = *(_DWORD *)(*(void *)a1 + 1968);
  unsigned int v24 = v13 >> 8;
  if (v13 >> 8 >= 0x41) {
    operator new[]();
  }
  unint64_t v23 = 0;
  uint64_t v15 = llvm::ConstantInt::get(v12, (llvm::LLVMContext *)&v23, a3);
  if (v24 >= 0x41 && v23) {
    MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
  }
  v27[0] = (uint64_t)v15;
  uint64_t v16 = a5;
  unsigned int v17 = *(llvm::ConstantInt **)(*(void *)a1 + 1960);
  unsigned int v18 = *(_DWORD *)(*(void *)a1 + 1968);
  unsigned int v24 = v18 >> 8;
  if (v18 >> 8 > 0x40) {
    operator new[]();
  }
  if (v18 <= 0xFF) {
    unint64_t v19 = 0;
  }
  else {
    unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v18) + 63);
  }
  unint64_t v23 = (unsigned char *)(v19 & v16);
  uint64_t v20 = llvm::ConstantInt::get(v17, (llvm::LLVMContext *)&v23, v14);
  if (v24 >= 0x41 && v23) {
    MEMORY[0x1D25D9CB0](v23, 0x1000C8000313F17);
  }
  v27[1] = (uint64_t)v20;
  char v21 = 1;
  char v26 = 1;
  if (*a6)
  {
    unint64_t v23 = a6;
    char v21 = 3;
  }
  char v25 = v21;
  uint64_t result = sub_1CC27CEC0(a2, (uint64_t)a3, a4, v27, 2, (uint64_t)&v23);
  if (*(unsigned char *)(result + 16) != 62) {
    return 0;
  }
  return result;
}

double sub_1CC46D220(uint64_t a1, uint64_t **a2, uint64_t a3, char a4, uint64_t a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a2[10];
  *(void *)(a1 + 24) = a2 + 9;
  uint64_t v5 = **a2;
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)&double result = 0x200000000;
  *(void *)(a1 + 40) = 0x200000000;
  *(void *)(a1 + 96) = v5;
  *(void *)(a1 + 104) = a1 + 152;
  *(void *)(a1 + 112) = a1 + 160;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_WORD *)(a1 + 132) = 512;
  *(unsigned char *)(a1 + 134) = 7;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = &unk_1F2616E88;
  *(void *)(a1 + 160) = &unk_1F2617008;
  *(unsigned char *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 169) = a4;
  *(void *)(a1 + 176) = a5;
  return result;
}

void sub_1CC46D2C0(llvm *a1, llvm::PassRegistry *a2)
{
  llvm::initializeMachineBlockFrequencyInfoPass(a1, a2);
  llvm::initializeMachineDominatorTreePass((uint64_t)a1);
  llvm::initializeMachinePostDominatorTreePass(a1, v3);
  llvm::initializeMachineLoopInfoPass((uint64_t)a1);
  llvm::initializeMachineOptimizationRemarkEmitterPassPass(a1, v4);
  operator new();
}

void sub_1CC46D380()
{
}

void sub_1CC46D520(uint64_t a1)
{
  *(void *)a1 = &unk_1F2612F28;
  uint64_t v2 = *(void **)(a1 + 648);
  if (v2 != (void *)(a1 + 664)) {
    free(v2);
  }
  if ((*(unsigned char *)(a1 + 576) & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 584), 4);
  }
  sub_1CD50C1C0((uint64_t *)(a1 + 248));
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = *(void **)(a1 + 176);
  if (v3 != (void *)(a1 + 192)) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 104);
  if (v4 != (void *)(a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 32);
  if (v5 != (void *)(a1 + 48)) {
    free(v5);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC46D608(uint64_t a1)
{
  sub_1CC46D520(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC46D640()
{
  return "Shrink Wrapping analysis";
}

void sub_1CC46D650(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachinePostDominatorTree::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineLoopInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineOptimizationRemarkEmitterPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC46D6F4(uint64_t a1, uint64_t a2)
{
  if ((llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, *(llvm::LLVMContextImpl *****)a2) & 1) != 0
    || *(void *)(a2 + 320) == a2 + 320)
  {
    return 0;
  }
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
  if (dword_1EBCD3B08)
  {
    if (dword_1EBCD3B08 == 2) {
      return 0;
    }
    goto LABEL_15;
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v4 + 72))(v4, a2))
  {
    uint64_t v5 = *(void *)(*(void *)(a2 + 8) + 560);
    if (*(_DWORD *)(v5 + 412) != 4 || ((int v6 = *(_DWORD *)(v5 + 420), v6 != 6) ? (v7 = v6 == 0) : (v7 = 1), v7))
    {
      uint64_t v8 = *(void *)(*(void *)a2 + 112);
      if (!v8 || (*(unsigned char *)(v8 + 18) & 0x6C) == 0)
      {
LABEL_15:
        llvm::RegisterClassInfo::runOnMachineFunction((llvm::RegisterClassInfo *)(a1 + 248), (const llvm::MachineFunction *)a2);
        uint64_t v9 = *(uint64_t **)(a1 + 8);
        uint64_t v10 = *v9;
        uint64_t v11 = v9[1];
        if (v10 == v11)
        {
LABEL_18:
          uint64_t v12 = 0;
        }
        else
        {
          while (*(_UNKNOWN **)v10 != &llvm::MachineDominatorTree::ID)
          {
            v10 += 16;
            if (v10 == v11) {
              goto LABEL_18;
            }
          }
          uint64_t v12 = *(void *)(v10 + 8);
        }
        *(void *)(a1 + 488) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MachineDominatorTree::ID);
        unsigned int v13 = *(uint64_t **)(a1 + 8);
        uint64_t v14 = *v13;
        uint64_t v15 = v13[1];
        if (v14 == v15)
        {
LABEL_23:
          uint64_t v16 = 0;
        }
        else
        {
          while (*(_UNKNOWN **)v14 != &llvm::MachinePostDominatorTree::ID)
          {
            v14 += 16;
            if (v14 == v15) {
              goto LABEL_23;
            }
          }
          uint64_t v16 = *(void *)(v14 + 8);
        }
        uint64_t v17 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v16 + 96))(v16, &llvm::MachinePostDominatorTree::ID);
        uint64_t v18 = 0;
        *(void *)(a1 + 504) = 0;
        *(void *)(a1 + 512) = 0;
        *(void *)(a1 + 496) = v17;
        unint64_t v19 = *(uint64_t **)(a1 + 8);
        uint64_t v20 = *v19;
        uint64_t v21 = v19[1];
        if (v20 == v21) {
          goto LABEL_30;
        }
        while (*(_UNKNOWN **)v20 != &llvm::MachineBlockFrequencyInfo::ID)
        {
          v20 += 16;
          if (v20 == v21)
          {
            uint64_t v18 = 0;
            goto LABEL_30;
          }
        }
        uint64_t v18 = *(void *)(v20 + 8);
LABEL_30:
        *(void *)(a1 + 520) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::MachineBlockFrequencyInfo::ID);
        unsigned int v22 = *(uint64_t **)(a1 + 8);
        uint64_t v23 = *v22;
        uint64_t v24 = v22[1];
        if (v23 == v24)
        {
LABEL_33:
          uint64_t v25 = 0;
        }
        else
        {
          while (*(_UNKNOWN **)v23 != &llvm::MachineLoopInfo::ID)
          {
            v23 += 16;
            if (v23 == v24) {
              goto LABEL_33;
            }
          }
          uint64_t v25 = *(void *)(v23 + 8);
        }
        *(void *)(a1 + 528) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v25 + 96))(v25, &llvm::MachineLoopInfo::ID);
        char v26 = *(uint64_t **)(a1 + 8);
        uint64_t v27 = *v26;
        uint64_t v28 = v26[1];
        if (v27 == v28)
        {
LABEL_38:
          uint64_t v29 = 0;
        }
        else
        {
          while (*(_UNKNOWN **)v27 != &llvm::MachineOptimizationRemarkEmitterPass::ID)
          {
            v27 += 16;
            if (v27 == v28) {
              goto LABEL_38;
            }
          }
          uint64_t v29 = *(void *)(v27 + 8);
        }
        *(void *)(a1 + 536) = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v29 + 96))(v29, &llvm::MachineOptimizationRemarkEmitterPass::ID)+ 248);
        uint64_t v30 = *(void *)(*(void *)(a1 + 520) + 248);
        if (v30) {
          uint64_t v30 = *(void *)(*(void *)(v30 + 8) + 16);
        }
        *(void *)(a1 + 544) = v30;
        uint64_t v31 = *(void *)(a2 + 16);
        *(void *)(a1 + 552) = *(void *)((*(uint64_t (**)(uint64_t))(*(void *)v31 + 104))(v31) + 64);
        *(_DWORD *)(a1 + 560) = *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)v31 + 120))(v31) + 88);
        *(void *)(a1 + 568) = *(void *)(a2 + 328);
        sub_1CBC30010((void *)(a1 + 576));
        *(_DWORD *)(a1 + 656) = 0;
        *(void *)(a1 + 728) = a2;
        *(void *)&long long v85 = *(void *)(a2 + 328);
        unsigned int v87 = 0;
        uint64_t v88 = 0;
        long long __p = 0;
        sub_1CD50D084((char **)&__p, (uint64_t *)&v85);
        if (sub_1CD57B698((uint64_t)__p, (uint64_t)v87, *(void *)(a1 + 528)))
        {
          uint64_t v32 = *(uint64_t *****)(a1 + 536);
          uint64_t v33 = *(llvm::LLVMContextImpl *****)a2;
          if ((*(unsigned char *)(*(void *)a2 + 23) & 0x20) == 0) {
            goto LABEL_58;
          }
          unint64_t v34 = ***v33;
          *(void *)&long long v85 = *(void *)a2;
          int v35 = *((_DWORD *)v34 + 624);
          if (v35)
          {
            uint64_t v36 = *((void *)v34 + 310);
            int v37 = v35 - 1;
            unsigned int v38 = v37 & ((v33 >> 4) ^ (v33 >> 9));
            int v39 = (llvm::LLVMContextImpl *****)(v36 + 40 * v38);
            int64_t v40 = *v39;
            if (*v39 == v33) {
              goto LABEL_54;
            }
            BOOL v41 = 0;
            int v42 = 1;
            while (v40 != (llvm::LLVMContextImpl ****)-4096)
            {
              if (v41) {
                BOOL v43 = 0;
              }
              else {
                BOOL v43 = v40 == (llvm::LLVMContextImpl ****)-8192;
              }
              if (v43) {
                BOOL v41 = v39;
              }
              unsigned int v44 = v38 + v42++;
              unsigned int v38 = v44 & v37;
              int v39 = (llvm::LLVMContextImpl *****)(v36 + 40 * v38);
              int64_t v40 = *v39;
              if (*v39 == v33) {
                goto LABEL_54;
              }
            }
            if (v41) {
              uint64_t v83 = v41;
            }
            else {
              uint64_t v83 = v39;
            }
          }
          else
          {
            uint64_t v83 = 0;
          }
          int v39 = (llvm::LLVMContextImpl *****)sub_1CC609054((uint64_t)v34 + 2480, (uint64_t)&v85, (uint64_t *)&v85, v83);
          int v84 = (llvm::LLVMContextImpl ****)v85;
          v39[3] = 0;
          v39[4] = 0;
          *int v39 = v84;
          v39[1] = (llvm::LLVMContextImpl ****)(v39 + 3);
          v39[2] = (llvm::LLVMContextImpl ****)0x100000000;
LABEL_54:
          uint64_t v45 = *((unsigned int *)v39 + 4);
          if (v45)
          {
            uint64_t v46 = v39[1] + 1;
            uint64_t v47 = 16 * v45;
            while (*((_DWORD *)v46 - 2))
            {
              v46 += 2;
              v47 -= 16;
              if (!v47) {
                goto LABEL_58;
              }
            }
            uint64_t v81 = *v46;
            long long v85 = 0uLL;
            if (v81)
            {
              uint64_t v82 = v81;
              if (*(unsigned char *)v81 != 15) {
                uint64_t v82 = *(void *)(v81 - 8 * *(unsigned int *)(v81 + 8));
              }
              *(void *)&long long v85 = v82;
              DWORD2(v85) = *(_DWORD *)(v81 + 28);
            }
            goto LABEL_59;
          }
LABEL_58:
          long long v85 = 0uLL;
LABEL_59:
          sub_1CC46E1C8(v32, (uint64_t)"UnsupportedIrreducibleCFG", 25, "Irreducible CFGs are not supported yet.", 39, &v85, *(void *)(a2 + 328));
          goto LABEL_122;
        }
        uint64_t v48 = *(void *)(*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16));
        if ((*(unsigned int (**)(void))(v48 + 376))()) {
          operator new();
        }
        for (uint64_t i = *(void *)(a2 + 328); i != a2 + 320; uint64_t i = *(void *)(i + 8))
        {
          if (*(unsigned char *)(i + 189))
          {
            unint64_t v79 = *(uint64_t *****)(a1 + 536);
            llvm::DiagnosticLocation::DiagnosticLocation(&v85, (const llvm::DebugLoc *)(*(void *)(i + 56) + 56));
            sub_1CC46E1C8(v79, (uint64_t)"UnsupportedEHFunclets", 21, "EH Funclets are not supported yet.", 34, &v85, i);
            goto LABEL_122;
          }
          if (*(unsigned char *)(i + 184) || *(unsigned char *)(i + 202))
          {
            sub_1CC46E4C8(a1, (llvm::MachineBasicBlock *)i);
            uint64_t v50 = *(void *)(a1 + 504);
            if (!v50 || v50 == *(void *)(a1 + 568)) {
              goto LABEL_122;
            }
LABEL_69:
            if (!*(void *)(a1 + 512))
            {
LABEL_122:
              if (__p)
              {
                unsigned int v87 = __p;
                operator delete(__p);
              }
              return 0;
            }
          }
          else
          {
            for (uint64_t j = *(void *)(i + 56); j != i + 48; uint64_t j = *(void *)(j + 8))
            {
              if (sub_1CC46EB4C(a1, j))
              {
                sub_1CC46E4C8(a1, (llvm::MachineBasicBlock *)i);
                uint64_t v52 = *(void *)(a1 + 504);
                if (v52) {
                  BOOL v53 = v52 == *(void *)(a1 + 568);
                }
                else {
                  BOOL v53 = 1;
                }
                if (v53) {
                  goto LABEL_122;
                }
                goto LABEL_69;
              }
              if ((*(unsigned char *)j & 4) == 0)
              {
                while ((*(_WORD *)(j + 44) & 8) != 0)
                  uint64_t j = *(void *)(j + 8);
              }
            }
          }
        }
        uint64_t v54 = *(void *)(a1 + 504);
        if (!v54 || v54 == *(void *)(a1 + 568) || !*(void *)(a1 + 512)) {
          goto LABEL_122;
        }
        uint64_t v55 = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 112))(*(void *)(a2 + 16));
        uint64_t v56 = *(void *)(a1 + 504);
        while (1)
        {
          uint64_t v57 = *(void *)(*(void *)(a1 + 520) + 248);
          if (v57)
          {
            int v58 = *(_DWORD *)(v57 + 176);
            if (v58)
            {
              unint64_t v59 = *(void *)(a1 + 544);
              uint64_t v60 = *(void *)(v57 + 160);
              unsigned int v61 = v58 - 1;
              uint64_t v62 = v61 & ((v56 >> 4) ^ (v56 >> 9));
              uint64_t v63 = *(void *)(v60 + 16 * v62);
              if (v63 == v56)
              {
LABEL_91:
                uint64_t v64 = *(unsigned int *)(v60 + 16 * v62 + 8);
                if (v64 != 0xFFFFFFFFLL && v59 < *(void *)(*(void *)(v57 + 8) + 24 * v64 + 16)) {
                  goto LABEL_105;
                }
              }
              else
              {
                int v70 = 1;
                while (v63 != -4096)
                {
                  int v71 = v62 + v70++;
                  uint64_t v62 = v71 & v61;
                  uint64_t v63 = *(void *)(v60 + 16 * v62);
                  if (v63 == v56) {
                    goto LABEL_91;
                  }
                }
              }
              uint64_t v65 = *(void *)(a1 + 512);
              uint64_t v66 = ((v65 >> 4) ^ (v65 >> 9)) & v61;
              uint64_t v67 = *(void *)(v60 + 16 * v66);
              if (v67 == v65)
              {
LABEL_94:
                uint64_t v68 = *(unsigned int *)(v60 + 16 * v66 + 8);
                if (v68 != 0xFFFFFFFFLL && v59 < *(void *)(*(void *)(v57 + 8) + 24 * v68 + 16)) {
                  goto LABEL_105;
                }
              }
              else
              {
                int v73 = 1;
                while (v67 != -4096)
                {
                  int v74 = v66 + v73++;
                  uint64_t v66 = v74 & v61;
                  uint64_t v67 = *(void *)(v60 + 16 * v66);
                  if (v67 == v65) {
                    goto LABEL_94;
                  }
                }
              }
            }
          }
          if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v55 + 312))(v55, v56) & 1) == 0)
          {
            uint64_t v56 = *(void *)(a1 + 504);
LABEL_105:
            uint64_t v72 = (llvm::MachineBasicBlock *)sub_1CC46F02C(v56, *(void *)(v56 + 64), *(void *)(v56 + 72), *(void ****)(a1 + 488));
            *(void *)(a1 + 504) = v72;
            if (!v72) {
              goto LABEL_117;
            }
            goto LABEL_106;
          }
          if ((*(uint64_t (**)(uint64_t, void))(*(void *)v55 + 320))(v55, *(void *)(a1 + 512))) {
            goto LABEL_117;
          }
          uint64_t v69 = *(llvm::MachineBasicBlock **)(a1 + 512);
          if (*((void *)v69 + 11) != *((void *)v69 + 12)) {
            llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::findNearestCommonDominator();
          }
          uint64_t v72 = *(llvm::MachineBasicBlock **)(a1 + 512);
          uint64_t v75 = v72 == v69 ? 0 : *(void *)(a1 + 512);
          *(void *)(a1 + 512) = v75;
          if (!v75)
          {
LABEL_117:
            uint64_t v76 = *(void *)(a1 + 504);
            if (v76)
            {
              if (v76 != *(void *)(a1 + 568))
              {
                uint64_t v77 = *(void *)(a1 + 512);
                if (v77)
                {
                  uint64_t v78 = *(void *)(a2 + 56);
                  *(void *)(v78 + 656) = v76;
                  *(void *)(v78 + 664) = v77;
                }
              }
            }
            goto LABEL_122;
          }
LABEL_106:
          sub_1CC46E4C8(a1, v72);
          uint64_t v56 = *(void *)(a1 + 504);
          if (!v56 || !*(void *)(a1 + 512)) {
            goto LABEL_117;
          }
        }
      }
    }
  }
  return 0;
}

double sub_1CC46E1A0@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 8;
  *(void *)a1 = a1 + 16;
  *(void *)&double result = 0x600000001;
  *(void *)(a1 + 8) = 0x600000001;
  *(_DWORD *)(a1 + 64) = 11;
  return result;
}

void sub_1CC46E1C8(uint64_t ****a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, _OWORD *a6, uint64_t a7)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = *(void *)****a1;
  if (*(void *)(v14 + 128)
    || (*(unsigned int (**)(void))(**(void **)(v14 + 72) + 48))(*(void *)(v14 + 72)))
  {
    uint64_t v15 = **(void **)(a7 + 32);
    int v34 = 16;
    char v35 = 2;
    *(void *)uint64_t v36 = v15;
    *(_OWORD *)&v36[8] = *a6;
    *(void *)&long long v37 = "shrink-wrap";
    *((void *)&v37 + 1) = a2;
    *(void *)&long long v38 = a3;
    BYTE8(v38) = 0;
    LOBYTE(v39) = 0;
    int64_t v40 = v42;
    uint64_t v41 = 0x400000000;
    LOBYTE(v43) = 0;
    HIDWORD(v43) = -1;
    uint64_t v44 = a7;
    uint64_t v33 = &unk_1F260B560;
    uint64_t v23 = a4;
    uint64_t v24 = a5;
    sub_1CC59ADEC((uint64_t *)&v40, (uint64_t)&v23);
    unsigned int v16 = 0;
    LODWORD(v24) = v34;
    BYTE4(v24) = v35;
    long long v25 = *(_OWORD *)v36;
    uint64_t v26 = *(void *)&v36[16];
    uint64_t v23 = &unk_1F2616800;
    long long v27 = v37;
    long long v28 = v38;
    uint64_t v29 = v39;
    uint64_t v30 = v32;
    uint64_t v31 = 0x400000000;
    if (v41)
    {
      sub_1CD494D68((uint64_t)&v30, (uint64_t)&v40);
      unsigned int v16 = v41;
    }
    v32[32] = v43;
    v32[33] = v44;
    uint64_t v23 = &unk_1F260B560;
    uint64_t v33 = &unk_1F2616800;
    uint64_t v17 = (char *)v40;
    if (v16)
    {
      unint64_t v18 = (unint64_t)v16 << 6;
      do
      {
        unint64_t v19 = (void **)&v17[v18];
        if (v17[v18 - 17] < 0) {
          operator delete(*(v19 - 5));
        }
        if (*((char *)v19 - 41) < 0) {
          operator delete(*(v19 - 8));
        }
        v18 -= 64;
      }
      while (v18);
      uint64_t v17 = (char *)v40;
    }
    if (v17 != v42) {
      free(v17);
    }
    llvm::MachineOptimizationRemarkEmitter::emit(a1, (llvm::DiagnosticInfoOptimizationBase *)&v23);
    uint64_t v23 = &unk_1F2616800;
    uint64_t v20 = (char *)v30;
    if (v31)
    {
      unint64_t v21 = (unint64_t)v31 << 6;
      do
      {
        unsigned int v22 = (void **)&v20[v21];
        if (v20[v21 - 17] < 0) {
          operator delete(*(v22 - 5));
        }
        if (*((char *)v22 - 41) < 0) {
          operator delete(*(v22 - 8));
        }
        v21 -= 64;
      }
      while (v21);
      uint64_t v20 = (char *)v30;
    }
    if (v20 != (char *)v32) {
      free(v20);
    }
  }
}

unint64_t sub_1CC46E4C8(uint64_t a1, llvm::MachineBasicBlock *a2)
{
  if (*(void *)(a1 + 504))
  {
    llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 488));
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator();
  }
  *(void *)(a1 + 504) = a2;
  if (*(void *)(a1 + 512))
  {
    unint64_t result = sub_1CBA9D508(*(void *)(a1 + 496), (uint64_t)a2);
    if (result) {
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::findNearestCommonDominator();
    }
LABEL_18:
    *(void *)(a1 + 512) = 0;
    return result;
  }
  *(void *)(a1 + 512) = a2;
  unint64_t result = llvm::MachineBasicBlock::getFirstTerminator(a2);
  if ((llvm::MachineBasicBlock *)((char *)a2 + 48) == (llvm::MachineBasicBlock *)result)
  {
LABEL_13:
    if (*(void *)(a1 + 512))
    {
      llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 488));
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
    }
  }
  else
  {
    uint64_t v5 = result;
    while (1)
    {
      unint64_t result = sub_1CC46EB4C(a1, v5);
      if (result) {
        break;
      }
      if ((*(unsigned char *)v5 & 4) == 0)
      {
        while ((*(_WORD *)(v5 + 44) & 8) != 0)
          uint64_t v5 = *(void *)(v5 + 8);
      }
      uint64_t v5 = *(void *)(v5 + 8);
      if ((llvm::MachineBasicBlock *)v5 == (llvm::MachineBasicBlock *)((char *)a2 + 48)) {
        goto LABEL_13;
      }
    }
    if (*((void *)a2 + 11) == *((void *)a2 + 12)) {
      goto LABEL_18;
    }
    if (*(void *)(*(void *)(a1 + 512) + 88) != *(void *)(*(void *)(a1 + 512) + 96)) {
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::findNearestCommonDominator();
    }
    *(void *)(a1 + 512) = 0;
  }
  return result;
}

uint64_t sub_1CC46EB4C(uint64_t a1, uint64_t a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned __int16 **)(a2 + 16);
  int v5 = *v4;
  if ((v5 - 1) <= 1 && (*(unsigned char *)(*(void *)(a2 + 32) + 48) & 8) != 0) {
    return 1;
  }
  unsigned int v6 = *(unsigned __int16 *)(a2 + 44);
  BOOL v19 = (v6 & 0xC) == 0;
  int v7 = (v6 >> 2) & 1;
  if (v19) {
    LOBYTE(v7) = 1;
  }
  uint64_t v8 = *((void *)v4 + 1);
  if (v7)
  {
    if ((v8 & 0x80000) != 0) {
      return 1;
    }
  }
  else
  {
    if ((v8 & 0x80000) != 0) {
      return 1;
    }
    uint64_t v57 = a2;
    uint64_t result = 1;
    while ((*(_WORD *)(v57 + 44) & 8) != 0)
    {
      uint64_t v57 = *(void *)(v57 + 8);
      if ((*(unsigned char *)(*(void *)(v57 + 16) + 10) & 8) != 0) {
        return result;
      }
    }
  }
  if ((v5 - 1) <= 1 && (*(unsigned char *)(*(void *)(a2 + 32) + 48) & 0x10) != 0) {
    return 1;
  }
  if (v7)
  {
    if ((v8 & 0x100000) != 0) {
      return 1;
    }
  }
  else
  {
    if ((v8 & 0x100000) != 0) {
      return 1;
    }
    uint64_t v58 = a2;
    uint64_t result = 1;
    while ((*(_WORD *)(v58 + 44) & 8) != 0)
    {
      uint64_t v58 = *(void *)(v58 + 8);
      if ((*(unsigned char *)(*(void *)(v58 + 16) + 10) & 0x10) != 0) {
        return result;
      }
    }
  }
  if (*(_DWORD *)(a1 + 552) == v5 || *(_DWORD *)(a1 + 556) == v5) {
    return 1;
  }
  uint64_t v10 = *(void *)(*(void *)(*(void *)(a2 + 24) + 32) + 16);
  uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 176))(v10);
  uint64_t v12 = *(unsigned int *)(a2 + 40);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = v11;
  uint64_t v14 = *(int **)(a2 + 32);
  uint64_t v15 = &v14[8 * v12];
  while (1)
  {
    int v16 = *v14;
    if (*v14 == 12) {
      break;
    }
    if (*v14) {
      goto LABEL_76;
    }
    if ((v16 & 0x1000000) == 0)
    {
      int v17 = v16 & 0x30000000;
      int v18 = v16 & 0x10FFF00;
      BOOL v19 = v17 || v18 == 0x1000000;
      if (v19) {
        goto LABEL_78;
      }
    }
    unint64_t v20 = v14[1];
    if (!v20) {
      goto LABEL_78;
    }
    unsigned int v21 = *(unsigned __int16 *)(a2 + 44);
    BOOL v19 = (v21 & 0xC) == 0;
    int v22 = (v21 >> 2) & 1;
    if (v19) {
      LOBYTE(v22) = 1;
    }
    uint64_t v23 = *(void *)(a2 + 16);
    uint64_t v24 = *(void *)(v23 + 8);
    if (v22)
    {
      if ((v24 & 0x80) == 0) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v36 = a2;
      if ((v24 & 0x80) == 0)
      {
        while ((*(_WORD *)(v36 + 44) & 8) != 0)
        {
          uint64_t v36 = *(void *)(v36 + 8);
          if ((*(unsigned char *)(*(void *)(v36 + 16) + 8) & 0x80) != 0) {
            goto LABEL_29;
          }
        }
LABEL_28:
        if (v20 == *(_DWORD *)(a1 + 560)) {
          return 1;
        }
      }
    }
LABEL_29:
    if (*(void *)(a1 + 296) > v20 && *(_WORD *)(*(void *)(a1 + 288) + 2 * v20)) {
      return 1;
    }
    uint64_t v25 = *(void *)(v23 + 8);
    if (v22)
    {
      if ((v25 & 0x20) != 0) {
        goto LABEL_76;
      }
    }
    else
    {
      uint64_t v37 = a2;
      if ((v25 & 0x20) != 0) {
        goto LABEL_76;
      }
      while ((*(_WORD *)(v37 + 44) & 8) != 0)
      {
        uint64_t v37 = *(void *)(v37 + 8);
        if ((*(unsigned char *)(*(void *)(v37 + 16) + 8) & 0x20) != 0) {
          goto LABEL_76;
        }
      }
    }
    if ((*(uint64_t (**)(uint64_t))(*(void *)v13 + 592))(v13)) {
      return 1;
    }
LABEL_76:
    if (*(unsigned char *)v14 == 5 && **(unsigned __int16 **)(a2 + 16) - 13 > 1) {
      return 1;
    }
LABEL_78:
    uint64_t result = 0;
    v14 += 8;
    if (v14 == v15) {
      return result;
    }
  }
  uint64_t v26 = *(unsigned int *)(a1 + 656);
  if (!v26)
  {
    uint64_t v60 = v62;
    uint64_t v61 = 0x600000000;
    int v63 = 0;
    uint64_t v27 = *(void *)(*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 728) + 16) + 112))(*(void *)(*(void *)(a1 + 728) + 16));
    (*(void (**)(void))(v27 + 264))();
    long long v28 = v60;
    if (v63)
    {
      uint64_t v29 = 0;
      uint64_t v30 = (v63 - 1) & 0xFFFFFFC0;
      uint64_t v31 = (uint64_t *)v60;
      while (1)
      {
        uint64_t v33 = *v31++;
        uint64_t v32 = v33;
        unint64_t v34 = v30 + v29 ? -1 : 0xFFFFFFFFFFFFFFFFLL >> -(char)v63;
        unint64_t v35 = v34 & v32;
        if (v35) {
          break;
        }
        v29 -= 64;
        if (v30 + v29 == -64) {
          goto LABEL_70;
        }
      }
      int v38 = __clz(__rbit64(v35));
      if (v38 + 1 != v29)
      {
        int v39 = v38 - v29;
        while (1)
        {
          int v59 = v39;
          sub_1CB8FB8C0(a1 + 576, &v59);
          unsigned int v40 = v39 + 1;
          if (v39 + 1 == v63) {
            break;
          }
          unsigned int v41 = v40 >> 6;
          unsigned int v42 = v63 - 1;
          long long v28 = v60;
          if (v40 >> 6 <= (v63 - 1) >> 6)
          {
            uint64_t v43 = 0;
            uint64_t v44 = v42 >> 6;
            int v45 = v40 & 0x3F;
            BOOL v19 = v45 == 0;
            unint64_t v46 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v45;
            uint64_t v47 = v19 ? -1 : ~v46;
            unint64_t v48 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v42;
            int v49 = v41 << 6;
            uint64_t v50 = v44 - v41;
            uint64_t v51 = (char *)v60 + 8 * v41;
            while (1)
            {
              uint64_t v52 = v43 ? -1 : v47;
              unint64_t v53 = v50 == v43 ? v48 : -1;
              unint64_t v54 = v52 & v53 & *(void *)&v51[8 * v43];
              if (v54) {
                break;
              }
              v49 += 64;
              if (v50 + 1 == ++v43) {
                goto LABEL_70;
              }
            }
            int v39 = __clz(__rbit64(v54)) + v49;
            if (v39 != -1) {
              continue;
            }
          }
          goto LABEL_70;
        }
        long long v28 = v60;
      }
    }
LABEL_70:
    if (v28 != v62) {
      free(v28);
    }
    uint64_t v26 = *(unsigned int *)(a1 + 656);
    if (!v26) {
      goto LABEL_76;
    }
  }
  uint64_t v55 = *(_DWORD **)(a1 + 648);
  uint64_t v56 = &v55[v26];
  while (((*(_DWORD *)(*((void *)v14 + 2) + (((unint64_t)*v55 >> 3) & 0x1FFFFFFC)) >> *v55) & 1) != 0)
  {
    if (++v55 == v56) {
      goto LABEL_76;
    }
  }
  return 1;
}

uint64_t sub_1CC46F02C(int a1, uint64_t a2, uint64_t a3, void ***this)
{
  if (a2 != a3)
  {
    llvm::MachineDominatorTree::applySplitCriticalEdges(this);
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator();
  }
  return 0;
}

uint64_t sub_1CC46F0B0()
{
  int v2 = 1;
  *(void *)&long long v1 = "enable the shrink-wrapping pass";
  *((void *)&v1 + 1) = 31;
  sub_1CD57B7CC(&v2, &v1);

  return __cxa_atexit((void (*)(void *))sub_1CC243CA8, &qword_1EBCD3A88, &dword_1CB82C000);
}

void sub_1CC46F120()
{
}

void sub_1CC46F1BC()
{
}

void sub_1CC46F228(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CC46F260()
{
  return "SJLJ Exception Handling preparation";
}

uint64_t sub_1CC46F270(void *a1, llvm::IntegerType **a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::ArrayType *)llvm::PointerType::get((llvm::PointerType *)(*(void *)*a2 + 1912), 0);
  uint64_t v5 = a1[20];
  if (v5) {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 144))(v5);
  }
  else {
    uint64_t v6 = 32;
  }
  int v7 = (llvm::ArrayType *)llvm::IntegerType::get(*a2, (llvm::LLVMContext *)v6);
  a1[4] = v7;
  a1[5] = llvm::ArrayType::get(v7, (llvm::Type *)4);
  uint64_t v8 = llvm::ArrayType::get(v4, (llvm::Type *)5);
  a1[6] = v8;
  uint64_t v9 = *(uint64_t **)v4;
  uint64_t v11 = v4;
  long long v12 = *((_OWORD *)a1 + 2);
  uint64_t v13 = v4;
  uint64_t v14 = v4;
  uint64_t v15 = v8;
  a1[7] = llvm::StructType::get(v9, (uint64_t)&v11, 6, 0);
  return 1;
}

uint64_t sub_1CC46F380(uint64_t a1, uint64_t ***a2)
{
  uint64_t v473 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (unsigned int *)a2[5];
  uint64_t v5 = (uint64_t **)(**(void **)v4 + 1576);
  unint64_t v6 = llvm::PointerType::get(*(llvm::PointerType **)(a1 + 56), 0);
  *(void *)(a1 + 64) = sub_1CD57B9C0((uint64_t)v4, "_Unwind_SjLj_Register", (const char *)0x15, 0, v5, v6);
  *(void *)(a1 + 72) = v7;
  uint64_t v8 = (uint64_t **)(**(void **)v4 + 1576);
  unint64_t v9 = llvm::PointerType::get(*(llvm::PointerType **)(a1 + 56), 0);
  *(void *)(a1 + 80) = sub_1CD57B9C0((uint64_t)v4, "_Unwind_SjLj_Unregister", (const char *)0x17, 0, v8, v9);
  *(void *)(a1 + 88) = v10;
  size_t v442 = (void *)llvm::PointerType::get((llvm::PointerType *)(**(void **)v4 + 1912), (llvm::Type *)v4[69]);
  *(void *)(a1 + 104) = llvm::Intrinsic::getDeclaration((uint64_t **)v4, 147, (uint64_t)&v442, 1);
  llvm::Intrinsic::getType(*(uint64_t **)v4, 288, 0, 0);
  Type = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v4, 288, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)v4, "llvm.stacksave", (const char *)0xE, Type, 0);
  *(void *)(a1 + 112) = v12;
  llvm::Intrinsic::getType(*(uint64_t **)v4, 287, 0, 0);
  uint64_t v13 = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v4, 287, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)v4, "llvm.stackrestore", (const char *)0x11, v13, 0);
  *(void *)(a1 + 120) = v14;
  llvm::Intrinsic::getType(*(uint64_t **)v4, 72, 0, 0);
  uint64_t v15 = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v4, 72, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)v4, "llvm.eh.sjlj.setup.dispatch", (const char *)0x1B, v15, 0);
  *(void *)(a1 + 96) = v16;
  llvm::Intrinsic::getType(*(uint64_t **)v4, 70, 0, 0);
  int v17 = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v4, 70, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)v4, "llvm.eh.sjlj.lsda", (const char *)0x11, v17, 0);
  *(void *)(a1 + 128) = v18;
  llvm::Intrinsic::getType(*(uint64_t **)v4, 67, 0, 0);
  BOOL v19 = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v4, 67, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)v4, "llvm.eh.sjlj.callsite", (const char *)0x15, v19, 0);
  *(void *)(a1 + 136) = v20;
  llvm::Intrinsic::getType(*(uint64_t **)v4, 68, 0, 0);
  unsigned int v21 = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v4, 68, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)v4, "llvm.eh.sjlj.functioncontext", (const char *)0x1C, v21, 0);
  *(void *)(a1 + 144) = v22;
  int v439 = v441;
  uint64_t v440 = 0x1000000000;
  v436 = v438;
  uint64_t v437 = 0x1000000000;
  v432[0] = 1;
  uint64_t v25 = 1;
  int64x2_t v26 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  do
  {
    *(int64x2_t *)&v432[v25] = v26;
    v25 += 2;
  }
  while (v25 != 17);
  uint64_t v433 = v435;
  uint64_t v434 = 0x1000000000;
  uint64_t v27 = (uint64_t ***)a2[10];
  if (v27 == a2 + 9)
  {
    uint64_t v57 = 0;
    goto LABEL_62;
  }
  v422 = (uint64_t **)(a2 + 9);
  do
  {
    if (v27) {
      long long v28 = v27 - 3;
    }
    else {
      long long v28 = 0;
    }
    uint64_t v29 = (uint64_t ***)v28[5];
    if (v29 != v28 + 5)
    {
      if (v29) {
        uint64_t v30 = v29 - 3;
      }
      else {
        uint64_t v30 = 0;
      }
      unsigned int v31 = *((unsigned __int8 *)v30 + 16) - 40;
      if (v31 >= 0xFFFFFFF5) {
        uint64_t v32 = v30;
      }
      else {
        uint64_t v32 = 0;
      }
      int v33 = *((unsigned __int8 *)v32 + 16);
      if (v29 && (v33 == 33 ? (BOOL v34 = v31 >= 0xFFFFFFF5) : (BOOL v34 = 0), v34))
      {
        uint64_t v35 = *(v32 - 4);
        if (v35 && !*(unsigned char *)(v35 + 16) && *(void *)(v35 + 24) == v32[9] && *(_DWORD *)(v35 + 36) == 60)
        {
          uint64_t v36 = *(v32 - 12);
          uint64_t v37 = (char *)operator new(0x60uLL);
          *((_DWORD *)v37 + 13) = *((_DWORD *)v37 + 13) & 0x38000000 | 1;
          *((void *)v37 + 1) = 0;
          *((void *)v37 + 2) = 0;
          *(void *)uint64_t v37 = 0;
          *((void *)v37 + 4) = ***(void ***)v36 + 1576;
          *((void *)v37 + 3) = v37 + 32;
          *((void *)v37 + 5) = 0;
          *((_WORD *)v37 + 24) = 30;
          *((_WORD *)v37 + 25) = 0;
          *((_DWORD *)v37 + 13) = 1;
          *(_OWORD *)(v37 + 56) = 0u;
          int v38 = v37 + 56;
          *(_OWORD *)(v37 + 72) = 0u;
          *((_DWORD *)v37 + 22) = 0;
          uint64_t v39 = v32[5];
          unsigned int v40 = v32 + 3;
          *((void *)v37 + 9) = v39;
          *(_WORD *)(v39 + 18) &= ~0x8000u;
          if ((v37[55] & 0x10) != 0
            && (uint64_t v51 = *(void *)(v39 + 56)) != 0
            && (uint64_t v52 = *(llvm::ValueSymbolTable **)(v51 + 104)) != 0)
          {
            llvm::ValueSymbolTable::reinsertValue(v52, (llvm::Value *)(v37 + 32));
            uint64_t v53 = *(void *)v37;
            uint64_t v54 = *v40;
            *((void *)v37 + 7) = *v40;
            *((void *)v37 + 8) = v40;
            *(void *)(v54 + 8) = v38;
            *unsigned int v40 = (uint64_t)v38;
            if (v53)
            {
              **((void **)v37 + 2) = *((void *)v37 + 1);
              uint64_t v55 = *((void *)v37 + 1);
              if (v55) {
                *(void *)(v55 + 16) = *((void *)v37 + 2);
              }
            }
          }
          else
          {
            uint64_t v41 = *v40;
            *((void *)v37 + 7) = *v40;
            *((void *)v37 + 8) = v40;
            *(void *)(v41 + 8) = v38;
            *unsigned int v40 = (uint64_t)v38;
          }
          *(void *)uint64_t v37 = v36;
          uint64_t v44 = *(void *)(v36 + 8);
          uint64_t v43 = (void *)(v36 + 8);
          uint64_t v42 = v44;
          *((void *)v37 + 1) = v44;
          if (v44) {
            *(void *)(v42 + 16) = v37 + 8;
          }
          *((void *)v37 + 2) = v43;
          void *v43 = v37;
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        if (v437 >= (unint64_t)HIDWORD(v437)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v436 + v437) = v32;
        LODWORD(v437) = v437 + 1;
        uint64_t v46 = *(v32 - 8);
        uint64_t v47 = v46 + 40;
        for (uint64_t i = *(void *)(v46 + 48); i != v47; uint64_t i = *(void *)(i + 8))
        {
          int v49 = (unsigned char *)(i - 24);
          if (i) {
            uint64_t v50 = i - 24;
          }
          else {
            uint64_t v50 = 0;
          }
          if (*(unsigned char *)(v50 + 16) != 83) {
            goto LABEL_54;
          }
        }
        int v49 = 0;
LABEL_54:
        if (v49[16] == 94) {
          uint64_t v56 = v49;
        }
        else {
          uint64_t v56 = 0;
        }
        size_t v442 = v56;
        sub_1CD5296A0((uint64_t)v432, (uint64_t *)&v442);
      }
      else if (v29)
      {
        if (v33 == 29 && v31 >= 0xFFFFFFF5)
        {
          if (v440 >= (unint64_t)HIDWORD(v440)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v439 + v440) = v32;
          LODWORD(v440) = v440 + 1;
        }
      }
    }
    uint64_t v27 = (uint64_t ***)v27[1];
  }
  while (v27 != a2 + 9);
  if (!v437)
  {
    uint64_t v57 = 0;
    goto LABEL_62;
  }
  int v59 = a2[10];
  if (v59) {
    uint64_t v60 = v59 - 3;
  }
  else {
    uint64_t v60 = 0;
  }
  for (uint64_t j = v60[6]; ; uint64_t j = (uint64_t *)j[1])
  {
    uint64_t v62 = (uint64_t)(j - 3);
    uint64_t v63 = j ? (uint64_t)(j - 3) : 0;
    if (*(unsigned char *)(v63 + 16) != 59 || *(unsigned char *)(*(j - 7) + 16) != 16) {
      break;
    }
    uint64_t v64 = j[2];
    uint64_t v65 = *(void *)(*(void *)(v64 + 56) + 80);
    uint64_t v66 = v65 ? v65 - 24 : 0;
    if (v64 != v66 || (*((_WORD *)j - 3) & 0x40) != 0) {
      break;
    }
  }
  uint64_t v420 = a1;
  if ((*((_WORD *)a2 + 9) & 1) == 0)
  {
    uint64_t v67 = (uint64_t ***)a2[11];
LABEL_88:
    uint64_t v68 = v67;
    goto LABEL_89;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)a2);
  uint64_t v67 = (uint64_t ***)a2[11];
  if ((*((_WORD *)a2 + 9) & 1) == 0) {
    goto LABEL_88;
  }
  llvm::Function::BuildLazyArguments((llvm::Function *)a2);
  uint64_t v68 = (uint64_t ***)a2[11];
LABEL_89:
  v421 = a2;
  for (uint64_t k = &v68[5 * (void)a2[12]]; v67 != k; v67 += 5)
  {
    int v155 = *((unsigned __int8 *)v67 + 16);
    if (v67 && v155 == 21)
    {
      uint64_t v182 = v67[3][14];
      if (!v182
        || (unsigned int v183 = *((_DWORD *)v67 + 8) + 2, v183 >= *((_DWORD *)v182 + 2))
        || (uint64_t v184 = v182[v183 + 5]) == 0
        || (*(char *)(v184 + 19) & 0x80000000) == 0)
      {
LABEL_272:
        uint64_t v156 = (llvm::UndefValue *)*v67;
        uint64_t v157 = **a2;
        uint64_t v158 = *v157;
        uint64_t v159 = *(void **)(*v157 + 1560);
        if (!v159)
        {
          uint64_t v179 = *(llvm::ConstantInt **)(v158 + 1888);
          unsigned int v180 = *(_DWORD *)(v158 + 1896);
          LODWORD(v443) = v180 >> 8;
          if (v180 >> 8 > 0x40) {
            operator new[]();
          }
          if (v180 <= 0xFF) {
            char v181 = 0;
          }
          else {
            char v181 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v180) + 63);
          }
          size_t v442 = (void *)(v181 & 1);
          uint64_t v159 = llvm::ConstantInt::get(v179, (llvm::LLVMContext *)&v442, v23);
          if (v443 >= 0x41 && v442) {
            MEMORY[0x1D25D9CB0](v442, 0x1000C8000313F17);
          }
          *(void *)(v158 + 1560) = v159;
        }
        uint64_t v160 = llvm::UndefValue::get(v156, v22);
        if ((*((unsigned char *)v67 + 23) & 0x10) != 0)
        {
          uint64_t v161 = ***v67;
          uint64_t v162 = *(void *)(v161 + 152);
          uint64_t v163 = *(unsigned int *)(v161 + 168);
          if (!v163) {
            goto LABEL_280;
          }
          LODWORD(v164) = (v163 - 1) & ((v67 >> 4) ^ (v67 >> 9));
          uint64_t v165 = (uint64_t ****)(v162 + 16 * v164);
          uint64_t v166 = *v165;
          if (*v165 != v67)
          {
            int v167 = 1;
            while (v166 != (uint64_t ***)-4096)
            {
              int v168 = v164 + v167++;
              uint64_t v164 = v168 & (v163 - 1);
              uint64_t v166 = *(uint64_t ****)(v162 + 16 * v164);
              if (v166 == v67)
              {
                uint64_t v165 = (uint64_t ****)(v162 + 16 * v164);
                goto LABEL_281;
              }
            }
LABEL_280:
            uint64_t v165 = (uint64_t ****)(v162 + 16 * v163);
          }
LABEL_281:
          uint64_t v169 = v165[1];
          uint64_t v172 = *v169;
          uint64_t v171 = (char *)(v169 + 2);
          uint64_t v170 = v172;
        }
        else
        {
          uint64_t v170 = 0;
          uint64_t v171 = &byte_1CFBCE98E;
        }
        LOWORD(v446[0]) = 773;
        size_t v442 = v171;
        v443 = v170;
        uint64_t v444 = (uint64_t)".tmp";
        uint64_t v173 = sub_1CC199EFC((uint64_t)v159, (uint64_t *)v67, (uint64_t)v160, (const char **)&v442, v62, 0);
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)v67, v173, (llvm::Value *)1);
        int v174 = *((_DWORD *)v173 + 5);
        if ((v174 & 0x40000000) != 0) {
          unsigned int v175 = (char *)*((void *)v173 - 1);
        }
        else {
          unsigned int v175 = (char *)v173 - 32 * (v174 & 0x7FFFFFF);
        }
        if (*((void *)v175 + 4))
        {
          **((void **)v175 + 6) = *((void *)v175 + 5);
          uint64_t v176 = *((void *)v175 + 5);
          if (v176) {
            *(void *)(v176 + 16) = *((void *)v175 + 6);
          }
        }
        *((void *)v175 + 4) = v67;
        uint64_t v177 = v67 + 1;
        uint64_t v178 = v67[1];
        *((void *)v175 + 5) = v178;
        if (v178) {
          v178[2] = (uint64_t *)(v175 + 40);
        }
        *((void *)v175 + 6) = v177;
        void *v177 = v175 + 32;
      }
    }
    else if (!v67 || v155 != 59 || (*((_WORD *)v67 + 9) & 0x80) == 0)
    {
      goto LABEL_272;
    }
  }
  int v424 = v436;
  uint64_t v70 = v437;
  int v71 = a2[10];
  if (v71 != v422)
  {
    uint64_t v72 = (char *)v436 + 8 * v437;
    do
    {
      uint64_t v423 = v71;
      if (v71) {
        int v73 = (const llvm::APInt *)(v71 - 3);
      }
      else {
        int v73 = 0;
      }
      int v74 = (void *)((char *)v73 + 40);
      uint64_t v75 = (void *)*((void *)v73 + 6);
      if (v75 != (void *)((char *)v73 + 40))
      {
        do
        {
          if (v75) {
            uint64_t v76 = (llvm *)(v75 - 3);
          }
          else {
            uint64_t v76 = 0;
          }
          uint64_t v77 = *((void *)v76 + 1);
          if (v77)
          {
            if (*(void *)(v77 + 8)
              || (uint64_t v78 = *(void *)(v77 + 24), *(const llvm::APInt **)(v78 + 40) != v73)
              || *(unsigned char *)(v78 + 16) == 83)
            {
              if (!v75
                || *((unsigned char *)v76 + 16) != 59
                || *(unsigned char *)(*((void *)v76 - 4) + 16) != 16
                || ((v79 = *((void *)v76 + 5), (uint64_t v80 = *(void *)(*(void *)(v79 + 56) + 80)) != 0)
                  ? (uint64_t v81 = v80 - 24)
                  : (uint64_t v81 = 0),
                    v79 != v81 || (*((_WORD *)v76 + 9) & 0x40) != 0))
              {
                uint64_t v82 = v70;
                unsigned int v83 = 0;
                uint64_t v460 = v462;
                uint64_t v461 = 0x1000000000;
                do
                {
                  uint64_t v84 = *(void *)(v77 + 24);
                  if (*(const llvm::APInt **)(v84 + 40) != v73 || *(unsigned char *)(v84 + 16) == 83)
                  {
                    if (v83 >= HIDWORD(v461)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v460 + v83) = v84;
                    unsigned int v83 = v461 + 1;
                    LODWORD(v461) = v461 + 1;
                  }
                  uint64_t v77 = *(void *)(v77 + 8);
                }
                while (v77);
                long long v85 = (const llvm::APInt **)v446;
                size_t v442 = v446;
                v443 = v446;
                int v445 = 0;
                uint64_t v444 = 0x100000020;
                unint64_t v86 = (const llvm::APInt **)v446;
                v446[0] = v73;
                if (v83)
                {
                  do
                  {
                    uint64_t v87 = *((void *)v460 + v83 - 1);
                    LODWORD(v461) = v83 - 1;
                    if (*(unsigned char *)(v87 + 16) == 83)
                    {
                      uint64_t v88 = *(_DWORD *)(v87 + 20) & 0x7FFFFFF;
                      if (v88)
                      {
                        uint64_t v89 = 0;
                        uint64_t v90 = 0;
                        uint64_t v91 = 32 * v88;
                        do
                        {
                          int v92 = *(_DWORD *)(v87 + 20);
                          if ((v92 & 0x40000000) != 0) {
                            uint64_t v93 = *(void *)(v87 - 8);
                          }
                          else {
                            uint64_t v93 = v87 - 32 * (v92 & 0x7FFFFFF);
                          }
                          if (*(llvm **)(v93 + v90) == v76) {
                            sub_1CC472764(*(void *)(v93 + 32 * *(unsigned int *)(v87 + 60) + v89), (llvm::SmallPtrSetImplBase *)&v442);
                          }
                          v90 += 32;
                          v89 += 8;
                        }
                        while (v91 != v90);
                      }
                    }
                    else
                    {
                      sub_1CC472764(*(void *)(v87 + 40), (llvm::SmallPtrSetImplBase *)&v442);
                    }
                    unsigned int v83 = v461;
                  }
                  while (v461);
                  long long v85 = (const llvm::APInt **)v443;
                  unint64_t v86 = (const llvm::APInt **)v442;
                }
                uint64_t v70 = v82;
                if (v82)
                {
                  unsigned int v94 = v444 - 1;
                  unint64_t v95 = v424;
                  int v74 = (void *)((char *)v73 + 40);
                  while (1)
                  {
                    int v96 = *(const llvm::APInt **)(*v95 - 64);
                    if (v96 != v73)
                    {
                      if (v85 == v86)
                      {
                        if (HIDWORD(v444))
                        {
                          uint64_t v97 = v86;
                          while (*v97 != v96)
                          {
                            if (++v97 == &v85[HIDWORD(v444)])
                            {
                              int v98 = HIDWORD(v444);
                              goto LABEL_156;
                            }
                          }
                          int v98 = HIDWORD(v444);
                        }
                        else
                        {
                          int v98 = 0;
LABEL_156:
                          uint64_t v97 = &v85[HIDWORD(v444)];
                        }
                      }
                      else
                      {
                        unsigned int v99 = v94 & ((v96 >> 4) ^ (v96 >> 9));
                        uint64_t v97 = &v85[v99];
                        uint64_t v23 = *v97;
                        if (*v97 == (const llvm::APInt *)-1)
                        {
                          size_t v100 = 0;
LABEL_158:
                          if (v100) {
                            uint64_t v97 = v100;
                          }
                          uint64_t v103 = *v97;
                        }
                        else
                        {
                          size_t v100 = 0;
                          uint64_t v24 = 1;
                          while (v23 != v96)
                          {
                            if (v100) {
                              BOOL v101 = 0;
                            }
                            else {
                              BOOL v101 = v23 == (const llvm::APInt *)-2;
                            }
                            if (v101) {
                              size_t v100 = v97;
                            }
                            int v102 = v99 + v24;
                            uint64_t v24 = (v24 + 1);
                            unsigned int v99 = v102 & v94;
                            uint64_t v97 = &v85[v102 & v94];
                            uint64_t v23 = *v97;
                            if (*v97 == (const llvm::APInt *)-1) {
                              goto LABEL_158;
                            }
                          }
                          uint64_t v103 = *(const llvm::APInt **)(*v95 - 64);
                        }
                        if (v103 != v96) {
                          uint64_t v97 = &v85[v444];
                        }
                        int v98 = v444;
                      }
                      if (v97 != &v85[v98]) {
                        break;
                      }
                    }
                    if (++v95 == (void *)v72) {
                      goto LABEL_169;
                    }
                  }
                  llvm::DemoteRegToStack(v76, (llvm::Instruction *)1, 0, (llvm::Instruction *)v24);
                  long long v85 = (const llvm::APInt **)v443;
                  unint64_t v86 = (const llvm::APInt **)v442;
                }
                else
                {
                  int v74 = (void *)((char *)v73 + 40);
                }
LABEL_169:
                if (v85 != v86) {
                  free(v85);
                }
                if (v460 != v462) {
                  free(v460);
                }
              }
            }
          }
          uint64_t v75 = (void *)v75[1];
        }
        while (v75 != v74);
      }
      int v71 = (uint64_t **)v423[1];
    }
    while (v71 != v422);
  }
  unint64_t v104 = (void *)v420;
  uint64_t v105 = v424;
  if (!v70) {
    goto LABEL_251;
  }
  do
  {
    unint64_t v106 = v105;
    uint64_t v107 = *(void *)(*v105 - 64);
    uint64_t v108 = *(void *)(v107 + 48);
    uint64_t v109 = v108;
    if (v108 == v107 + 40)
    {
LABEL_182:
      uint64_t v110 = 0;
    }
    else
    {
      while (1)
      {
        uint64_t v110 = (llvm::Instruction *)(v109 - 24);
        uint64_t v111 = v109 ? v109 - 24 : 0;
        if (*(unsigned char *)(v111 + 16) != 83) {
          break;
        }
        uint64_t v109 = *(void *)(v109 + 8);
        if (v109 == v107 + 40) {
          goto LABEL_182;
        }
      }
    }
    if (*((unsigned char *)v110 + 16) == 94) {
      unsigned int v112 = v110;
    }
    else {
      unsigned int v112 = 0;
    }
    size_t v442 = v446;
    v443 = v446;
    uint64_t v444 = 8;
    int v445 = 0;
    uint64_t v113 = v108 - 24;
    if (v108) {
      uint64_t v114 = v108 - 24;
    }
    else {
      uint64_t v114 = 0;
    }
    if (*(unsigned char *)(v114 + 16) != 83) {
      goto LABEL_250;
    }
    unsigned int v115 = 0;
    unsigned int v116 = 8;
    uint64_t v117 = v446;
    uint64_t v118 = v446;
    do
    {
      if (v118 != v117) {
        goto LABEL_201;
      }
      if (!v115)
      {
LABEL_199:
        if (v116 > v115)
        {
          HIDWORD(v444) = v115 + 1;
          v117[v115] = v113;
          goto LABEL_221;
        }
LABEL_201:
        if (3 * v116 <= 4 * (v115 - v445))
        {
          if (v116 >= 0x40) {
            v116 *= 2;
          }
          else {
            unsigned int v116 = 128;
          }
        }
        else if (v116 - v115 >= v116 >> 3)
        {
          goto LABEL_203;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v442, v116);
        unsigned int v116 = v444;
        uint64_t v118 = v443;
LABEL_203:
        unsigned int v122 = v116 - 1;
        unsigned int v123 = (v116 - 1) & ((v113 >> 4) ^ (v113 >> 9));
        uint64_t v124 = &v118[v123];
        uint64_t v125 = *v124;
        if (*v124 == -1)
        {
          uint64_t v126 = 0;
LABEL_215:
          if (v126) {
            uint64_t v124 = v126;
          }
          if (*v124 != v113)
          {
            if (*v124 == -2) {
              --v445;
            }
            else {
              ++HIDWORD(v444);
            }
            void *v124 = v113;
          }
        }
        else
        {
          uint64_t v126 = 0;
          int v127 = 1;
          while (v125 != v113)
          {
            if (v126) {
              BOOL v128 = 0;
            }
            else {
              BOOL v128 = v125 == -2;
            }
            if (v128) {
              uint64_t v126 = v124;
            }
            unsigned int v129 = v123 + v127++;
            unsigned int v123 = v129 & v122;
            uint64_t v124 = &v118[v129 & v122];
            uint64_t v125 = *v124;
            if (*v124 == -1) {
              goto LABEL_215;
            }
          }
        }
        goto LABEL_221;
      }
      uint64_t v119 = 0;
      uint64_t v120 = 8 * v115;
      uint64_t v121 = v117;
      while (*v121 != v113)
      {
        if (*v121 == -2) {
          uint64_t v119 = v121;
        }
        ++v121;
        v120 -= 8;
        if (!v120)
        {
          if (!v119) {
            goto LABEL_199;
          }
          *uint64_t v119 = v113;
          --v445;
          break;
        }
      }
LABEL_221:
      uint64_t v118 = v443;
      uint64_t v117 = v442;
      unsigned int v115 = HIDWORD(v444);
      unsigned int v116 = v444;
      uint64_t v108 = *(void *)(v108 + 8);
      uint64_t v113 = v108 - 24;
      if (v108) {
        uint64_t v130 = v108 - 24;
      }
      else {
        uint64_t v130 = 0;
      }
    }
    while (*(unsigned char *)(v130 + 16) == 83);
    if (HIDWORD(v444) != v445)
    {
      if (v443 == v442) {
        uint64_t v131 = HIDWORD(v444);
      }
      else {
        uint64_t v131 = v444;
      }
      if (v131)
      {
        uint64_t v132 = 8 * v131;
        uint64_t v133 = (llvm **)v443;
        while ((unint64_t)*v133 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v133;
          v132 -= 8;
          if (!v132) {
            goto LABEL_244;
          }
        }
      }
      else
      {
        uint64_t v133 = (llvm **)v443;
      }
      if (v133 != (llvm **)((char *)v443 + 8 * v131)) {
        llvm::DemotePHIToStack(*v133, 0, v23);
      }
LABEL_244:
      uint64_t v134 = *(void *)(v107 + 48);
      if (v134) {
        uint64_t v135 = (llvm::Instruction *)(v134 - 24);
      }
      else {
        uint64_t v135 = 0;
      }
      llvm::Instruction::moveBefore(v112, v135);
      uint64_t v118 = v443;
      uint64_t v117 = v442;
    }
    if (v118 != v117) {
      free(v118);
    }
LABEL_250:
    uint64_t v105 = v106 + 1;
  }
  while (v106 + 1 != &v424[v70]);
LABEL_251:
  *(void *)size_t v428 = 0;
  uint64_t v136 = (char *)v433;
  uint64_t v137 = v434;
  uint64_t v138 = v421[10];
  uint64_t v139 = v421[5];
  unsigned __int8 Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)(v139 + 34), *(llvm::Type **)(v420 + 56), 0);
  unint64_t v141 = (char *)operator new(0x68uLL);
  size_t v142 = v141 + 32;
  *((_DWORD *)v141 + 13) = *((_DWORD *)v141 + 13) & 0x38000000 | 1;
  *(void *)unint64_t v141 = 0;
  *((void *)v141 + 1) = 0;
  *((void *)v141 + 2) = 0;
  *((void *)v141 + 3) = v141 + 32;
  if (v138) {
    uint64_t v143 = v138 - 3;
  }
  else {
    uint64_t v143 = 0;
  }
  uint64_t v144 = *(llvm::PointerType **)(v420 + 56);
  uint64_t v145 = (llvm::Type *)*((unsigned int *)v139 + 69);
  size_t v442 = "fn_context";
  LOWORD(v446[0]) = 259;
  uint64_t v419 = v143;
  uint64_t v146 = v143[6];
  if (v146) {
    uint64_t v147 = (uint64_t)(v146 - 3);
  }
  else {
    uint64_t v147 = 0;
  }
  llvm::AllocaInst::AllocaInst((unint64_t *)v141 + 4, v144, v145, 0, Alignment, (const char **)&v442, v147);
  *(void *)(v420 + 152) = v142;
  if (!v137) {
    goto LABEL_258;
  }
  size_t v426 = (size_t)&v136[8 * v137];
  do
  {
    uint64_t v185 = *(void *)v136;
    uint64_t v186 = *(void *)(*(void *)v136 + 40);
    uint64_t v187 = v186 + 40;
    for (uint64_t m = *(void *)(v186 + 48); m != v187; uint64_t m = *(void *)(m + 8))
    {
      uint64_t v189 = m - 24;
      if (!m) {
        uint64_t v189 = 0;
      }
      if (*(unsigned char *)(v189 + 16) != 83)
      {
        unsigned int v190 = *(unsigned __int8 *)(m - 8) - 38;
        BOOL v191 = v190 > 0x38;
        uint64_t v192 = (1 << v190) & 0x100060000000001;
        if (v191 || v192 == 0) {
          uint64_t v187 = m;
        }
        else {
          uint64_t v187 = *(void *)(m + 8);
        }
        break;
      }
    }
    sub_1CBF537B4((uint64_t)&v460, (uint64_t **)v186, v187, 0, 0, 0);
    uint64_t v194 = v104[7];
    int v195 = (uint64_t *)v104[19];
    size_t v442 = "__data";
    LOWORD(v446[0]) = 259;
    uint64_t v196 = (uint64_t *)sub_1CD57BA94((uint64_t)&v460, v194, v195, 0, 2u, (uint64_t)&v442);
    uint64_t v197 = v104[5];
    size_t v442 = "exception_gep";
    LOWORD(v446[0]) = 259;
    char v198 = sub_1CD57BA94((uint64_t)&v460, v197, v196, 0, 0, (uint64_t)&v442);
    uint64_t v199 = (llvm::Type *)v104[4];
    v469 = "exn_val";
    __int16 v472 = 259;
    char v200 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*(void *)(v464 + 56) + 40) + 272), v199, 1);
    uint64_t v201 = (char *)operator new(0x60uLL);
    *((_DWORD *)v201 + 13) = *((_DWORD *)v201 + 13) & 0x38000000 | 1;
    unsigned int v202 = (unsigned __int8 *)(v201 + 32);
    *(void *)uint64_t v201 = 0;
    *((void *)v201 + 1) = 0;
    *((void *)v201 + 2) = 0;
    *((void *)v201 + 3) = v201 + 32;
    LOWORD(v446[0]) = 257;
    llvm::LoadInst::LoadInst((llvm::Value *)(v201 + 32), (uint64_t)v199, (uint64_t)v198, (const char **)&v442, 1, v200, 0);
    (*(void (**)(uint64_t, char *, char **, uint64_t, uint64_t))(*(void *)v468 + 16))(v468, v201 + 32, &v469, v464, v465);
    if (v461)
    {
      int32x2_t v225 = (llvm::MDNode **)v460;
      uint64_t v226 = (llvm::MDNode **)((char *)v460 + 16 * v461);
      do
      {
        llvm::Instruction::setMetadata((llvm::Instruction *)v202, *(_DWORD *)v225, v225[1]);
        v225 += 2;
      }
      while (v225 != v226);
    }
    unint64_t v203 = llvm::PointerType::get((llvm::PointerType *)(*(void *)v466 + 1912), 0);
    __int16 v472 = 257;
    if (*(void *)v202 == v203) {
      goto LABEL_373;
    }
    if (v201[48] > 0x14u)
    {
      LOWORD(v446[0]) = 257;
      unsigned int v202 = (unsigned __int8 *)llvm::CastInst::Create(48, (uint64_t)v202, v203, (const char **)&v442, 0);
      (*(void (**)(uint64_t, unsigned __int8 *, char **, uint64_t, uint64_t))(*(void *)v468 + 16))(v468, v202, &v469, v464, v465);
      uint64_t v204 = v420;
      if (v461)
      {
        int32x2_t v205 = (llvm::MDNode **)v460;
        uint64_t v206 = (llvm::MDNode **)((char *)v460 + 16 * v461);
        do
        {
          llvm::Instruction::setMetadata((llvm::Instruction *)v202, *(_DWORD *)v205, v205[1]);
          v205 += 2;
        }
        while (v205 != v206);
      }
      goto LABEL_334;
    }
    unsigned int v202 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, unint64_t))(*(void *)v467 + 224))(v467, 48, v202, v203);
    if (v202) {
      BOOL v207 = v202[16] >= 0x1Cu;
    }
    else {
      BOOL v207 = 0;
    }
    uint64_t v204 = v420;
    if (v207)
    {
      (*(void (**)(uint64_t, unsigned __int8 *, char **, uint64_t, uint64_t))(*(void *)v468 + 16))(v468, v202, &v469, v464, v465);
      if (v461)
      {
        uint64_t v229 = (llvm::MDNode **)v460;
        uint64_t v230 = (llvm::MDNode **)((char *)v460 + 16 * v461);
        do
        {
          llvm::Instruction::setMetadata((llvm::Instruction *)v202, *(_DWORD *)v229, v229[1]);
          v229 += 2;
        }
        while (v229 != v230);
      }
LABEL_373:
      uint64_t v204 = v420;
    }
LABEL_334:
    uint64_t v208 = *(void *)(v204 + 40);
    size_t v442 = "exn_selector_gep";
    LOWORD(v446[0]) = 259;
    int v209 = sub_1CD57BA94((uint64_t)&v460, v208, v196, 0, 1u, (uint64_t)&v442);
    unsigned int v210 = *(llvm::Type **)(v204 + 32);
    v469 = "exn_selector_val";
    __int16 v472 = 259;
    char v211 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*(void *)(v464 + 56) + 40) + 272), v210, 1);
    uint64_t v212 = operator new(0x60uLL);
    v212[13] = v212[13] & 0x38000000 | 1;
    int v213 = (llvm::Value *)(v212 + 8);
    *(void *)uint64_t v212 = 0;
    *((void *)v212 + 1) = 0;
    *((void *)v212 + 2) = 0;
    *((void *)v212 + 3) = v212 + 8;
    LOWORD(v446[0]) = 257;
    llvm::LoadInst::LoadInst((llvm::Value *)(v212 + 8), (uint64_t)v210, (uint64_t)v209, (const char **)&v442, 1, v211, 0);
    (*(void (**)(uint64_t, _DWORD *, char **, uint64_t, uint64_t))(*(void *)v468 + 16))(v468, v212 + 8, &v469, v464, v465);
    if (v461)
    {
      uint64_t v227 = (llvm::MDNode **)v460;
      unsigned int v228 = (llvm::MDNode **)((char *)v460 + 16 * v461);
      do
      {
        llvm::Instruction::setMetadata(v213, *(_DWORD *)v227, v227[1]);
        v227 += 2;
      }
      while (v227 != v228);
    }
    uint64_t v214 = ***v421 + 1960;
    __int16 v472 = 257;
    if (*(void *)v213 == v214)
    {
      unint64_t v104 = (void *)v420;
    }
    else if (*((unsigned __int8 *)v212 + 48) <= 0x14u)
    {
      int v213 = (llvm::Value *)(*(uint64_t (**)(uint64_t, uint64_t, llvm::Value *, uint64_t))(*(void *)v467 + 224))(v467, 38, v213, v214);
      if (v213) {
        BOOL v217 = *((unsigned __int8 *)v213 + 16) >= 0x1Cu;
      }
      else {
        BOOL v217 = 0;
      }
      unint64_t v104 = (void *)v420;
      if (v217)
      {
        (*(void (**)(uint64_t, llvm::Value *, char **, uint64_t, uint64_t))(*(void *)v468 + 16))(v468, v213, &v469, v464, v465);
        if (v461)
        {
          uint64_t v231 = (llvm::MDNode **)v460;
          uint64_t v232 = (llvm::MDNode **)((char *)v460 + 16 * v461);
          do
          {
            llvm::Instruction::setMetadata(v213, *(_DWORD *)v231, v231[1]);
            v231 += 2;
          }
          while (v231 != v232);
        }
        unint64_t v104 = (void *)v420;
      }
    }
    else
    {
      LOWORD(v446[0]) = 257;
      int v213 = llvm::CastInst::Create(38, (uint64_t)v213, v214, (const char **)&v442, 0);
      (*(void (**)(uint64_t, llvm::Value *, char **, uint64_t, uint64_t))(*(void *)v468 + 16))(v468, v213, &v469, v464, v465);
      unint64_t v104 = (void *)v420;
      if (v461)
      {
        uint64_t v215 = (llvm::MDNode **)v460;
        uint64_t v216 = (llvm::MDNode **)((char *)v460 + 16 * v461);
        do
        {
          llvm::Instruction::setMetadata(v213, *(_DWORD *)v215, v215[1]);
          v215 += 2;
        }
        while (v215 != v216);
      }
    }
    uint64_t v218 = *(void *)(v185 + 8);
    v469 = v471;
    uint64_t v470 = 0x800000000;
    sub_1CC472E24((uint64_t)&v469, v218, 0);
    while (v470)
    {
      uint64_t v220 = *(void *)&v469[8 * v470 - 8];
      LODWORD(v470) = v470 - 1;
      if (v220 && *(unsigned char *)(v220 + 16) == 92 && *(_DWORD *)(v220 + 72) == 1)
      {
        int v221 = **(_DWORD **)(v220 + 64);
        int v219 = (llvm::Value *)v202;
        if (!v221) {
          goto LABEL_353;
        }
        if (v221 == 1)
        {
          int v219 = v213;
LABEL_353:
          llvm::Value::doRAUW((llvm::ValueAsMetadata *)v220, v219, (llvm::Value *)1);
        }
        if (!*(void *)(v220 + 8)) {
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
      }
    }
    if (*(void *)(v185 + 8))
    {
      uint64_t v222 = llvm::UndefValue::get(*(llvm::UndefValue **)v185, v219);
      sub_1CBF537B4((uint64_t)&v442, *((uint64_t ***)v213 + 5), *((void *)v213 + 4), 0, 0, 0);
      int v431 = 0;
      v429[0] = (uint64_t)"lpad.val";
      __int16 v430 = 259;
      uint64_t v223 = sub_1CC2411F8((uint64_t)&v442, (uint64_t)v222, (uint64_t)v202, &v431, 1, (uint64_t)v429);
      int v431 = 1;
      v429[0] = (uint64_t)"lpad.val";
      __int16 v430 = 259;
      char v224 = sub_1CC2411F8((uint64_t)&v442, (uint64_t)v223, (uint64_t)v213, &v431, 1, (uint64_t)v429);
      llvm::Value::doRAUW((llvm::ValueAsMetadata *)v185, v224, (llvm::Value *)1);
      if (v442 != &v444) {
        free(v442);
      }
    }
    if (v469 != v471) {
      free(v469);
    }
    if (v460 != v462) {
      free(v460);
    }
    v136 += 8;
  }
  while (v136 != (char *)v426);
LABEL_258:
  uint64_t v148 = 0;
  uint64_t v149 = v419[5];
  if (v149) {
    uint64_t v150 = (uint64_t **)(v149 - 3);
  }
  else {
    uint64_t v150 = 0;
  }
  if (*((unsigned __int8 *)v150 + 16) - 29 >= 0xB) {
    uint64_t v150 = 0;
  }
  uint64_t v151 = **v150;
  size_t v442 = &v444;
  v443 = (void *)0x200000000;
  uint64_t v449 = v151;
  int v450 = &v458;
  int v451 = v459;
  uint64_t v452 = 0;
  int v453 = 0;
  __int16 v454 = 512;
  char v455 = 7;
  v448 = 0;
  uint64_t v447 = 0;
  uint64_t v457 = 0;
  uint64_t v456 = 0;
  int64_t v458 = &unk_1F2616E88;
  v459[0] = &unk_1F2617008;
  uint64_t v447 = v150[5];
  v448 = v150 + 3;
  int v152 = (char *)v150[6];
  v469 = v152;
  if (v152)
  {
    llvm::MetadataTracking::track((uint64_t)&v469, (unsigned __int8 *)v152, 2);
    uint64_t v148 = v469;
  }
  sub_1CB8461A4((uint64_t)&v442, 0, (uint64_t)v148);
  if (v469)
  {
    int v391 = *v469;
    if ((v391 - 4) > 0x1E)
    {
      if ((v391 - 3) >= 0xFFFFFFFE) {
        uint64_t v407 = v469;
      }
      else {
        uint64_t v407 = 0;
      }
      if ((v391 - 3) < 0xFFFFFFFE)
      {
        if (v391 == 3) {
          *((void *)v469 + 1) = 0;
        }
        goto LABEL_266;
      }
      unint64_t v393 = (unint64_t)(v407 + 8);
    }
    else
    {
      if ((v469[1] & 0x7F) != 2 && !*((_DWORD *)v469 + 3)) {
        goto LABEL_266;
      }
      uint64_t v392 = *((void *)v469 + 2);
      if ((v392 & 4) == 0) {
        goto LABEL_266;
      }
      unint64_t v393 = v392 & 0xFFFFFFFFFFFFFFF8;
      if (!v393) {
        goto LABEL_266;
      }
    }
    uint64_t v460 = &v469;
    sub_1CC5FA668(v393 + 16, &v460);
  }
LABEL_266:
  int v153 = *((_DWORD *)v421 + 5);
  if ((v153 & 0x40000000) != 0) {
    int v154 = (llvm::Value **)*(v421 - 1);
  }
  else {
    int v154 = (llvm::Value **)&v421[-4 * (v153 & 0x7FFFFFF)];
  }
  uint64_t v233 = *v154;
  uint64_t v234 = v104[7];
  uint64_t v235 = (uint64_t *)v104[19];
  uint64_t v460 = "pers_fn_gep";
  __int16 v463 = 259;
  int v236 = sub_1CD57BA94((uint64_t)&v442, v234, v235, 0, 3u, (uint64_t)&v460);
  unint64_t v237 = llvm::PointerType::get((llvm::PointerType *)(*(void *)v449 + 1912), 0);
  __int16 v472 = 257;
  if (*(void *)v233 != v237)
  {
    if (*((unsigned __int8 *)v233 + 16) <= 0x14u)
    {
      uint64_t v240 = (*((uint64_t (**)(void **, uint64_t, llvm::Value *, unint64_t))*v450 + 28))(v450, 49, v233, v237);
      uint64_t v233 = (llvm::Value *)v240;
      if (v240 && *(unsigned __int8 *)(v240 + 16) >= 0x1Cu)
      {
        (*(void (**)(void *, uint64_t, char **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v240, &v469, v447, v448);
        if (v443)
        {
          uint64_t v417 = (llvm::MDNode **)v442;
          uint64_t v418 = (llvm::MDNode **)((char *)v442 + 16 * v443);
          do
          {
            llvm::Instruction::setMetadata(v233, *(_DWORD *)v417, v417[1]);
            v417 += 2;
          }
          while (v417 != v418);
        }
        unint64_t v104 = (void *)v420;
      }
    }
    else
    {
      __int16 v463 = 257;
      uint64_t v233 = llvm::CastInst::Create(49, (uint64_t)v233, v237, (const char **)&v460, 0);
      (*(void (**)(void *, llvm::Value *, char **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v233, &v469, v447, v448);
      if (v443)
      {
        size_t v238 = (llvm::MDNode **)v442;
        size_t v239 = (llvm::MDNode **)((char *)v442 + 16 * v443);
        do
        {
          llvm::Instruction::setMetadata(v233, *(_DWORD *)v238, v238[1]);
          v238 += 2;
        }
        while (v238 != v239);
      }
    }
  }
  char v241 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(v447[7] + 40) + 272), *(llvm::Type **)v233, 1);
  uint64_t v242 = (char *)operator new(0x80uLL);
  *((_DWORD *)v242 + 21) = *((_DWORD *)v242 + 21) & 0x38000000 | 2;
  *(void *)uint64_t v242 = 0;
  *((void *)v242 + 2) = 0;
  *((void *)v242 + 1) = 0;
  *((void *)v242 + 5) = 0;
  *((void *)v242 + 6) = 0;
  *((void *)v242 + 4) = 0;
  uint64_t v243 = (llvm::Instruction **)(v242 + 32);
  *((void *)v242 + 8) = ***(void ***)v233 + 1576;
  uint64_t v244 = (llvm::Instruction *)(v242 + 64);
  *((void *)v242 + 3) = v242 + 64;
  *((void *)v242 + 7) = v242 + 64;
  *((void *)v242 + 9) = 0;
  v242[80] = 61;
  v242[81] = 0;
  *((_WORD *)v242 + 41) = 0;
  *((_DWORD *)v242 + 21) = 2;
  *(_OWORD *)(v242 + 88) = 0u;
  *(_OWORD *)(v242 + 104) = 0u;
  *((_DWORD *)v242 + 30) = 0;
  *(void *)uint64_t v242 = v233;
  uint64_t v247 = *((void *)v233 + 1);
  size_t v246 = (void *)((char *)v233 + 8);
  uint64_t v245 = v247;
  *((void *)v242 + 1) = v247;
  if (v247) {
    *(void *)(v245 + 16) = v242 + 8;
  }
  *((void *)v242 + 2) = v246;
  *size_t v246 = v242;
  if (*((void *)v242 + 4))
  {
    **((void **)v242 + 6) = *((void *)v242 + 5);
    uint64_t v411 = *((void *)v242 + 5);
    if (v411) {
      *(void *)(v411 + 16) = *((void *)v242 + 6);
    }
  }
  *uint64_t v243 = v236;
  if (v236)
  {
    uint64_t v250 = *((void *)v236 + 1);
    long long v249 = (llvm::Instruction ***)((char *)v236 + 8);
    uint64_t v248 = v250;
    *((void *)v242 + 5) = v250;
    if (v250) {
      *(void *)(v248 + 16) = v242 + 40;
    }
    *((void *)v242 + 6) = v249;
    *long long v249 = v243;
  }
  *((_WORD *)v242 + 41) = (2 * (v241 & 0x3F)) | 1;
  v242[124] = 1;
  __int16 v463 = 257;
  (*(void (**)(void *, llvm::Instruction *, void **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v244, &v460, v447, v448);
  if (v443)
  {
    uint64_t v400 = (llvm::MDNode **)v442;
    uint64_t v401 = (llvm::MDNode **)((char *)v442 + 16 * v443);
    do
    {
      llvm::Instruction::setMetadata(v244, *(_DWORD *)v400, v400[1]);
      v400 += 2;
    }
    while (v400 != v401);
  }
  uint64_t v251 = v104[16];
  if (v251) {
    size_t v252 = *(uint64_t ***)(v251 + 24);
  }
  else {
    size_t v252 = 0;
  }
  uint64_t v460 = "lsda_addr";
  __int16 v463 = 259;
  uint64_t v253 = sub_1CB845BAC((uint64_t *)&v442, v252, (uint64_t **)v251, 0, 0, (uint64_t)&v460, 0);
  uint64_t v254 = v104[7];
  unint64_t v255 = (uint64_t *)v104[19];
  uint64_t v460 = "lsda_gep";
  __int16 v463 = 259;
  uint64_t v256 = sub_1CD57BA94((uint64_t)&v442, v254, v255, 0, 4u, (uint64_t)&v460);
  char v257 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(v447[7] + 40) + 272), *(llvm::Type **)v253, 1);
  unint64_t v258 = (char *)operator new(0x80uLL);
  *((_DWORD *)v258 + 21) = *((_DWORD *)v258 + 21) & 0x38000000 | 2;
  *(void *)unint64_t v258 = 0;
  *((void *)v258 + 2) = 0;
  *((void *)v258 + 1) = 0;
  *((void *)v258 + 5) = 0;
  *((void *)v258 + 6) = 0;
  *((void *)v258 + 4) = 0;
  uint64_t v259 = (llvm::Instruction **)(v258 + 32);
  *((void *)v258 + 8) = ***(void ***)v253 + 1576;
  size_t v260 = (llvm::Instruction *)(v258 + 64);
  *((void *)v258 + 3) = v258 + 64;
  *((void *)v258 + 7) = v258 + 64;
  *((void *)v258 + 9) = 0;
  v258[80] = 61;
  v258[81] = 0;
  *((_WORD *)v258 + 41) = 0;
  *((_DWORD *)v258 + 21) = 2;
  *(_OWORD *)(v258 + 88) = 0u;
  *(_OWORD *)(v258 + 104) = 0u;
  *((_DWORD *)v258 + 30) = 0;
  *(void *)unint64_t v258 = v253;
  uint64_t v263 = *(void *)(v253 + 8);
  __int16 v262 = (void *)(v253 + 8);
  uint64_t v261 = v263;
  *((void *)v258 + 1) = v263;
  if (v263) {
    *(void *)(v261 + 16) = v258 + 8;
  }
  *((void *)v258 + 2) = v262;
  void *v262 = v258;
  if (*((void *)v258 + 4))
  {
    **((void **)v258 + 6) = *((void *)v258 + 5);
    uint64_t v412 = *((void *)v258 + 5);
    if (v412) {
      *(void *)(v412 + 16) = *((void *)v258 + 6);
    }
  }
  *uint64_t v259 = v256;
  if (v256)
  {
    uint64_t v266 = *((void *)v256 + 1);
    uint64_t v265 = (llvm::Instruction ***)((char *)v256 + 8);
    uint64_t v264 = v266;
    *((void *)v258 + 5) = v266;
    if (v266) {
      *(void *)(v264 + 16) = v258 + 40;
    }
    *((void *)v258 + 6) = v265;
    *uint64_t v265 = v259;
  }
  *((_WORD *)v258 + 41) = (2 * (v257 & 0x3F)) | 1;
  v258[124] = 1;
  __int16 v463 = 257;
  (*(void (**)(void *, llvm::Instruction *, void **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v260, &v460, v447, v448);
  int v267 = (uint64_t *)v442;
  if (v443)
  {
    v402 = (uint64_t *)((char *)v442 + 16 * v443);
    do
    {
      llvm::Instruction::setMetadata(v260, *(_DWORD *)v267, (llvm::MDNode *)v267[1]);
      v267 += 2;
    }
    while (v267 != v402);
    int v267 = (uint64_t *)v442;
  }
  uint64_t v268 = v104[19];
  if (v267 != &v444) {
    free(v267);
  }
  uint64_t v269 = 0;
  *(void *)size_t v428 = v268;
  uint64_t v270 = v421[10];
  int v271 = v270 - 3;
  if (!v270) {
    int v271 = 0;
  }
  uint64_t v272 = v271[5];
  v425 = v271 + 5;
  if (v272) {
    uint64_t v273 = (uint64_t **)(v272 - 3);
  }
  else {
    uint64_t v273 = 0;
  }
  if (*((unsigned __int8 *)v273 + 16) - 29 >= 0xB) {
    uint64_t v273 = 0;
  }
  uint64_t v274 = **v273;
  size_t v442 = &v444;
  v443 = (void *)0x200000000;
  uint64_t v449 = v274;
  int v450 = &v458;
  int v451 = v459;
  uint64_t v452 = 0;
  int v453 = 0;
  __int16 v454 = 512;
  char v455 = 7;
  v448 = 0;
  uint64_t v447 = 0;
  uint64_t v457 = 0;
  uint64_t v456 = 0;
  int64_t v458 = &unk_1F2616E88;
  v459[0] = &unk_1F2617008;
  uint64_t v447 = v273[5];
  v448 = v273 + 3;
  __int16 v275 = (char *)v273[6];
  v469 = v275;
  if (v275)
  {
    llvm::MetadataTracking::track((uint64_t)&v469, (unsigned __int8 *)v275, 2);
    uint64_t v269 = v469;
  }
  sub_1CB8461A4((uint64_t)&v442, 0, (uint64_t)v269);
  if (v469)
  {
    int v394 = *v469;
    if ((v394 - 4) > 0x1E)
    {
      if ((v394 - 3) >= 0xFFFFFFFE) {
        v408 = v469;
      }
      else {
        v408 = 0;
      }
      if ((v394 - 3) < 0xFFFFFFFE)
      {
        if (v394 == 3) {
          *((void *)v469 + 1) = 0;
        }
        goto LABEL_422;
      }
      unint64_t v396 = (unint64_t)(v408 + 8);
    }
    else
    {
      if ((v469[1] & 0x7F) != 2 && !*((_DWORD *)v469 + 3)) {
        goto LABEL_422;
      }
      uint64_t v395 = *((void *)v469 + 2);
      if ((v395 & 4) == 0) {
        goto LABEL_422;
      }
      unint64_t v396 = v395 & 0xFFFFFFFFFFFFFFF8;
      if (!v396) {
        goto LABEL_422;
      }
    }
    uint64_t v460 = &v469;
    sub_1CC5FA668(v396 + 16, &v460);
  }
LABEL_422:
  uint64_t v276 = v104[7];
  uint64_t v460 = "jbuf_gep";
  __int16 v463 = 259;
  __int16 v277 = (uint64_t *)sub_1CD57BA94((uint64_t)&v442, v276, *(uint64_t **)v428, 0, 5u, (uint64_t)&v460);
  uint64_t v278 = v104[6];
  uint64_t v460 = "jbuf_fp_gep";
  __int16 v463 = 259;
  size_t v280 = sub_1CD57BA94((uint64_t)&v442, v278, v277, 0, 0, (uint64_t)&v460);
  uint64_t v281 = v104[13];
  if (v281) {
    v282 = *(uint64_t ***)(v281 + 24);
  }
  else {
    v282 = 0;
  }
  unsigned int v283 = *(llvm::ConstantInt **)(*(void *)v449 + 1960);
  unsigned int v284 = *(_DWORD *)(*(void *)v449 + 1968);
  LODWORD(v461) = v284 >> 8;
  if (v284 >> 8 >= 0x41) {
    operator new[]();
  }
  uint64_t v460 = 0;
  uint64_t v285 = (char *)llvm::ConstantInt::get(v283, (llvm::LLVMContext *)&v460, v279);
  if (v461 >= 0x41 && v460) {
    MEMORY[0x1D25D9CB0](v460, 0x1000C8000313F17);
  }
  v469 = v285;
  uint64_t v460 = "fp";
  __int16 v463 = 259;
  uint64_t v286 = sub_1CB845BAC((uint64_t *)&v442, v282, (uint64_t **)v281, (uint64_t *)&v469, 1, (uint64_t)&v460, 0);
  char v287 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(v447[7] + 40) + 272), *(llvm::Type **)v286, 1);
  uint64_t v288 = (char *)operator new(0x80uLL);
  *((_DWORD *)v288 + 21) = *((_DWORD *)v288 + 21) & 0x38000000 | 2;
  *(void *)uint64_t v288 = 0;
  *((void *)v288 + 2) = 0;
  *((void *)v288 + 1) = 0;
  *((void *)v288 + 5) = 0;
  *((void *)v288 + 6) = 0;
  *((void *)v288 + 4) = 0;
  uint64_t v289 = (llvm::Instruction **)(v288 + 32);
  *((void *)v288 + 8) = ***(void ***)v286 + 1576;
  uint64_t v290 = (llvm::Instruction *)(v288 + 64);
  *((void *)v288 + 3) = v288 + 64;
  *((void *)v288 + 7) = v288 + 64;
  *((void *)v288 + 9) = 0;
  v288[80] = 61;
  v288[81] = 0;
  *((_WORD *)v288 + 41) = 0;
  *((_DWORD *)v288 + 21) = 2;
  *(_OWORD *)(v288 + 88) = 0u;
  *(_OWORD *)(v288 + 104) = 0u;
  *((_DWORD *)v288 + 30) = 0;
  *(void *)uint64_t v288 = v286;
  uint64_t v293 = *(void *)(v286 + 8);
  BOOL v292 = (void *)(v286 + 8);
  uint64_t v291 = v293;
  *((void *)v288 + 1) = v293;
  uint64_t v294 = v420;
  if (v293) {
    *(void *)(v291 + 16) = v288 + 8;
  }
  *((void *)v288 + 2) = v292;
  *BOOL v292 = v288;
  if (*((void *)v288 + 4))
  {
    **((void **)v288 + 6) = *((void *)v288 + 5);
    uint64_t v413 = *((void *)v288 + 5);
    if (v413) {
      *(void *)(v413 + 16) = *((void *)v288 + 6);
    }
  }
  const void *v289 = v280;
  if (v280)
  {
    uint64_t v297 = *((void *)v280 + 1);
    unint64_t v296 = (llvm::Instruction ***)((char *)v280 + 8);
    uint64_t v295 = v297;
    *((void *)v288 + 5) = v297;
    if (v297) {
      *(void *)(v295 + 16) = v288 + 40;
    }
    *((void *)v288 + 6) = v296;
    void *v296 = v289;
  }
  *((_WORD *)v288 + 41) = (2 * (v287 & 0x3F)) | 1;
  v288[124] = 1;
  __int16 v463 = 257;
  (*(void (**)(void *, llvm::Instruction *, void **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v290, &v460, v447, v448);
  if (v443)
  {
    uint64_t v403 = (llvm::MDNode **)v442;
    unsigned int v404 = (llvm::MDNode **)((char *)v442 + 16 * v443);
    do
    {
      llvm::Instruction::setMetadata(v290, *(_DWORD *)v403, v403[1]);
      v403 += 2;
    }
    while (v403 != v404);
  }
  uint64_t v298 = *(void *)(v420 + 48);
  uint64_t v460 = "jbuf_sp_gep";
  __int16 v463 = 259;
  size_t v427 = sub_1CD57BA94((uint64_t)&v442, v298, v277, 0, 2u, (uint64_t)&v460);
  uint64_t v299 = *(void *)(v420 + 112);
  if (v299) {
    uint64_t v300 = *(uint64_t ***)(v299 + 24);
  }
  else {
    uint64_t v300 = 0;
  }
  uint64_t v460 = "sp";
  __int16 v463 = 259;
  uint64_t v301 = sub_1CB845BAC((uint64_t *)&v442, v300, (uint64_t **)v299, 0, 0, (uint64_t)&v460, 0);
  char v302 = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(v447[7] + 40) + 272), *(llvm::Type **)v301, 1);
  unsigned int v303 = (char *)operator new(0x80uLL);
  *((_DWORD *)v303 + 21) = *((_DWORD *)v303 + 21) & 0x38000000 | 2;
  *(void *)unsigned int v303 = 0;
  *((void *)v303 + 2) = 0;
  *((void *)v303 + 1) = 0;
  *((void *)v303 + 4) = 0;
  int v304 = (llvm::Instruction **)(v303 + 32);
  *((void *)v303 + 5) = 0;
  *((void *)v303 + 6) = 0;
  *((void *)v303 + 8) = ***(void ***)v301 + 1576;
  uint64_t v305 = (llvm::Instruction *)(v303 + 64);
  *((void *)v303 + 3) = v303 + 64;
  *((void *)v303 + 7) = v303 + 64;
  *((void *)v303 + 9) = 0;
  v303[80] = 61;
  v303[81] = 0;
  *((_WORD *)v303 + 41) = 0;
  *((_DWORD *)v303 + 21) = 2;
  *(_OWORD *)(v303 + 88) = 0u;
  *(_OWORD *)(v303 + 104) = 0u;
  *((_DWORD *)v303 + 30) = 0;
  *(void *)unsigned int v303 = v301;
  uint64_t v308 = *(void *)(v301 + 8);
  unsigned int v307 = (void *)(v301 + 8);
  uint64_t v306 = v308;
  *((void *)v303 + 1) = v308;
  if (v308) {
    *(void *)(v306 + 16) = v303 + 8;
  }
  *((void *)v303 + 2) = v307;
  *unsigned int v307 = v303;
  if (*((void *)v303 + 4))
  {
    **((void **)v303 + 6) = *((void *)v303 + 5);
    uint64_t v414 = *((void *)v303 + 5);
    if (v414) {
      *(void *)(v414 + 16) = *((void *)v303 + 6);
    }
  }
  *int v304 = v427;
  if (v427)
  {
    int v309 = (llvm::Instruction ***)((char *)v427 + 8);
    uint64_t v310 = *((void *)v427 + 1);
    *((void *)v303 + 5) = v310;
    if (v310) {
      *(void *)(v310 + 16) = v303 + 40;
    }
    *((void *)v303 + 6) = v309;
    *int v309 = v304;
  }
  *((_WORD *)v303 + 41) = (2 * (v302 & 0x3F)) | 1;
  v303[124] = 1;
  __int16 v463 = 257;
  (*(void (**)(void *, llvm::Instruction *, void **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v305, &v460, v447, v448);
  if (v443)
  {
    long long v405 = (llvm::MDNode **)v442;
    long long v406 = (llvm::MDNode **)((char *)v442 + 16 * v443);
    do
    {
      llvm::Instruction::setMetadata(v305, *(_DWORD *)v405, v405[1]);
      v405 += 2;
    }
    while (v405 != v406);
  }
  uint64_t v311 = *(void *)(v420 + 96);
  if (v311) {
    int v312 = *(uint64_t ***)(v311 + 24);
  }
  else {
    int v312 = 0;
  }
  __int16 v463 = 257;
  sub_1CB845BAC((uint64_t *)&v442, v312, (uint64_t **)v311, 0, 0, (uint64_t)&v460, 0);
  v313 = *(unsigned __int8 **)v428;
  unint64_t v314 = llvm::PointerType::get((llvm::PointerType *)(*(void *)v449 + 1912), 0);
  __int16 v472 = 257;
  if (**(void **)v428 != v314)
  {
    if (*(unsigned __int8 *)(*(void *)v428 + 16) <= 0x14u)
    {
      v313 = (unsigned __int8 *)(*((uint64_t (**)(void **, uint64_t, void, unint64_t))*v450 + 28))(v450, 49, *(void *)v428, v314);
      if (v313) {
        BOOL v317 = v313[16] >= 0x1Cu;
      }
      else {
        BOOL v317 = 0;
      }
      if (v317)
      {
        (*(void (**)(void *, unsigned __int8 *, char **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v313, &v469, v447, v448);
        if (v443)
        {
          v415 = (llvm::MDNode **)v442;
          v416 = (llvm::MDNode **)((char *)v442 + 16 * v443);
          do
          {
            llvm::Instruction::setMetadata((llvm::Instruction *)v313, *(_DWORD *)v415, v415[1]);
            v415 += 2;
          }
          while (v415 != v416);
        }
        uint64_t v294 = v420;
      }
    }
    else
    {
      __int16 v463 = 257;
      v313 = (unsigned __int8 *)llvm::CastInst::Create(49, *(uint64_t *)v428, v314, (const char **)&v460, 0);
      (*(void (**)(void *, unsigned __int8 *, char **, uint64_t *, uint64_t **))(*v451 + 16))(v451, v313, &v469, v447, v448);
      if (v443)
      {
        int v315 = (llvm::MDNode **)v442;
        v316 = (llvm::MDNode **)((char *)v442 + 16 * v443);
        do
        {
          llvm::Instruction::setMetadata((llvm::Instruction *)v313, *(_DWORD *)v315, v315[1]);
          v315 += 2;
        }
        while (v315 != v316);
      }
    }
  }
  v469 = (char *)v313;
  uint64_t v318 = *(void *)(v294 + 144);
  if (v318) {
    uint64_t v319 = *(uint64_t ***)(v318 + 24);
  }
  else {
    uint64_t v319 = 0;
  }
  __int16 v463 = 257;
  sub_1CB845BAC((uint64_t *)&v442, v319, (uint64_t **)v318, (uint64_t *)&v469, 1, (uint64_t)&v460, 0);
  uint64_t v320 = v437;
  if (v437)
  {
    uint64_t v321 = 0;
    do
    {
      uint64_t v322 = v321 + 1;
      sub_1CC4722EC((void *)v420, *((uint64_t ***)v436 + v321), v321 + 1);
      uint64_t v324 = ***v421;
      v325 = *(llvm::ConstantInt **)(v324 + 1960);
      unint64_t v326 = *(unsigned int *)(v324 + 1968);
      LODWORD(v461) = v326 >> 8;
      if (v326 >> 8 > 0x40) {
        operator new[]();
      }
      if (v326 <= 0xFF) {
        unint64_t v327 = 0;
      }
      else {
        unint64_t v327 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v326) + 63);
      }
      uint64_t v460 = (void *)(v327 & v322);
      unsigned int v328 = llvm::ConstantInt::get(v325, (llvm::LLVMContext *)&v460, v323);
      if (v461 >= 0x41 && v460) {
        MEMORY[0x1D25D9CB0](v460, 0x1000C8000313F17);
      }
      uint64_t v329 = *(void *)(v420 + 136);
      if (v329) {
        int32x2_t v330 = *(uint64_t ***)(v329 + 24);
      }
      else {
        int32x2_t v330 = 0;
      }
      v429[0] = (uint64_t)v328;
      __int16 v463 = 257;
      uint64_t v331 = *((void *)v436 + v321);
      unsigned int v332 = (char *)operator new(0x90uLL);
      unsigned int v333 = v332;
      unsigned int v334 = (llvm::Value *)(v332 + 64);
      *((_DWORD *)v332 + 21) = *((_DWORD *)v332 + 21) & 0x38000000 | 2;
      *(void *)unsigned int v332 = 0;
      *((void *)v332 + 1) = 0;
      *((void *)v332 + 2) = 0;
      *((void *)v332 + 3) = v332 + 64;
      *((void *)v332 + 4) = 0;
      *((void *)v332 + 5) = 0;
      *((void *)v332 + 6) = 0;
      *((void *)v332 + 7) = v332 + 64;
      *((void *)v332 + 8) = *v330[2];
      *((void *)v332 + 9) = 0;
      *((_WORD *)v332 + 40) = 84;
      *((_WORD *)v332 + 41) = 0;
      *((_DWORD *)v332 + 21) = 2;
      *(_OWORD *)(v332 + 88) = 0u;
      unsigned int v335 = v332 + 88;
      *((_DWORD *)v332 + 30) = 0;
      *(_OWORD *)(v332 + 104) = 0u;
      if (v331)
      {
        uint64_t v336 = *(void *)(v331 + 40);
        *((void *)v332 + 13) = v336;
        *(_WORD *)(v336 + 18) &= ~0x8000u;
        if ((v332[87] & 0x10) != 0)
        {
          uint64_t v338 = *(void *)(v336 + 56);
          if (v338)
          {
            uint64_t v339 = *(llvm::ValueSymbolTable **)(v338 + 104);
            if (v339) {
              llvm::ValueSymbolTable::reinsertValue(v339, v334);
            }
          }
        }
        uint64_t v337 = *(void *)(v331 + 24);
        v333[11] = v337;
        v333[12] = v331 + 24;
        *(void *)(v337 + 8) = v335;
        *(void *)(v331 + 24) = v335;
      }
      v333[16] = 0;
      llvm::CallInst::init((uint64_t ***)v334, v330, (uint64_t **)v329, v429, 1, 0, 0, (const char **)&v460);
      uint64_t v321 = v322;
    }
    while (v320 != v322);
  }
  int v340 = v421[10];
  if (v340 != v422)
  {
    while (1)
    {
      int32x2_t v341 = v340 - 3;
      BOOL v342 = v340 == 0;
      if (!v340) {
        int32x2_t v341 = 0;
      }
      unsigned int v343 = v421[10];
      if (v343) {
        BOOL v342 = v343 - 3 == v341;
      }
      if (!v342) {
        break;
      }
LABEL_489:
      int v340 = (uint64_t **)v340[1];
      if (v340 == v422) {
        goto LABEL_511;
      }
    }
    int v344 = (uint64_t *)(v341 + 5);
    uint64_t v345 = v341[6];
    while (2)
    {
      if (v345 == v344) {
        goto LABEL_489;
      }
      if (v345) {
        uint64_t v346 = (uint64_t)(v345 - 3);
      }
      else {
        uint64_t v346 = 0;
      }
      int v347 = *(unsigned __int8 *)(v346 + 16);
      if (v345 && v347 == 84)
      {
        uint64_t v348 = *(void *)(v346 + 64);
        if (v348 && (*(unsigned char *)(v348 + 16) & 0x20) != 0
          || (llvm::CallBase::hasFnAttrOnCalledFunction(v346, 37) & 1) != 0)
        {
          goto LABEL_504;
        }
      }
      else
      {
        if ((!v345 || v347 != 36) && (!v345 || v347 != 38))
        {
          if (v347 == 34) {
            break;
          }
LABEL_504:
          uint64_t v345 = (uint64_t *)v345[1];
          continue;
        }
        if (*(_WORD *)(v346 + 18)) {
          goto LABEL_504;
        }
      }
      break;
    }
    sub_1CC4722EC((void *)v420, (uint64_t **)v346, -1);
    goto LABEL_504;
  }
LABEL_511:
  int v349 = *(uint64_t ***)(v420 + 64);
  uint64_t v350 = *(uint64_t ***)(v420 + 72);
  __int16 v463 = 257;
  uint64_t v351 = (void *)*v425;
  if ((void *)*v425 == v425)
  {
    v354 = 0;
  }
  else
  {
    uint64_t v352 = v351 - 3;
    if (v351) {
      uint64_t v353 = v351 - 3;
    }
    else {
      uint64_t v353 = 0;
    }
    if (*((unsigned __int8 *)v353 + 16) - 29 >= 0xB) {
      v354 = 0;
    }
    else {
      v354 = v352;
    }
  }
  uint64_t v355 = (char *)operator new(0x90uLL);
  int v356 = v355;
  uint64_t v357 = (llvm::Value *)(v355 + 64);
  *((_DWORD *)v355 + 21) = *((_DWORD *)v355 + 21) & 0x38000000 | 2;
  *(void *)uint64_t v355 = 0;
  *((void *)v355 + 1) = 0;
  *((void *)v355 + 2) = 0;
  *((void *)v355 + 3) = v355 + 64;
  *((void *)v355 + 4) = 0;
  *((void *)v355 + 5) = 0;
  *((void *)v355 + 6) = 0;
  *((void *)v355 + 7) = v355 + 64;
  *((void *)v355 + 8) = *v349[2];
  *((void *)v355 + 9) = 0;
  v355[80] = 84;
  v355[81] = 0;
  *((_WORD *)v355 + 41) = 0;
  *((_DWORD *)v355 + 21) = 2;
  *(_OWORD *)(v355 + 88) = 0u;
  int v358 = v355 + 88;
  *((_DWORD *)v355 + 30) = 0;
  *(_OWORD *)(v355 + 104) = 0u;
  if (v354)
  {
    uint64_t v397 = v354[5];
    v398 = v354 + 3;
    *((void *)v355 + 13) = v397;
    *(_WORD *)(v397 + 18) &= ~0x8000u;
    if ((v355[87] & 0x10) != 0)
    {
      uint64_t v409 = *(void *)(v397 + 56);
      if (v409)
      {
        int v410 = *(llvm::ValueSymbolTable **)(v409 + 104);
        if (v410) {
          llvm::ValueSymbolTable::reinsertValue(v410, v357);
        }
      }
    }
    uint64_t v399 = *v398;
    *((void *)v356 + 11) = *v398;
    *((void *)v356 + 12) = v398;
    *(void *)(v399 + 8) = v358;
    uint64_t *v398 = (uint64_t)v358;
  }
  *((void *)v356 + 16) = 0;
  llvm::CallInst::init((uint64_t ***)v357, v349, v350, (uint64_t *)v428, 1, 0, 0, (const char **)&v460);
  *((void *)v356 + 16) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v356 + 16, **((uint64_t ***)v356 + 8), -1, 37);
  unsigned int v359 = v422;
  uint64_t v360 = v421[10];
  if (v360 != v422)
  {
    while (1)
    {
      int32x2_t v361 = v360 - 3;
      BOOL v362 = v360 == 0;
      if (!v360) {
        int32x2_t v361 = 0;
      }
      uint64_t v363 = v421[10];
      if (v363) {
        BOOL v362 = v363 - 3 == v361;
      }
      if (!v362) {
        break;
      }
LABEL_526:
      uint64_t v360 = (uint64_t **)v360[1];
      if (v360 == v359) {
        goto LABEL_556;
      }
    }
    int v364 = (uint64_t *)(v361 + 5);
    uint64_t v365 = v361[6];
    while (2)
    {
      if (v365 == v364) {
        goto LABEL_526;
      }
      if (v365) {
        uint64_t v366 = v365 - 3;
      }
      else {
        uint64_t v366 = 0;
      }
      int v367 = *((unsigned __int8 *)v366 + 16);
      if (v367 == 84) {
        uint64_t v368 = v366;
      }
      else {
        uint64_t v368 = 0;
      }
      if (v365 && v367 == 84)
      {
        uint64_t v369 = *(v368 - 4);
        if (!v369 || *(unsigned char *)(v369 + 16) || *(void *)(v369 + 24) != v368[9]) {
          uint64_t v369 = 0;
        }
        if (v369 == *(void *)(v420 + 120))
        {
LABEL_546:
          int v370 = *(llvm::Value **)(v420 + 112);
          if (v370) {
            int v371 = (llvm::Type ***)*((void *)v370 + 3);
          }
          else {
            int v371 = 0;
          }
          uint64_t v460 = "sp";
          __int16 v463 = 259;
          v372 = operator new(0x70uLL);
          v372[13] = v372[13] & 0x38000000 | 1;
          *(void *)v372 = 0;
          *((void *)v372 + 1) = 0;
          *((void *)v372 + 2) = 0;
          *((void *)v372 + 3) = v372 + 8;
          llvm::CallInst::CallInst((llvm::CallInst *)(v372 + 8), v371, v370, (const char **)&v460, 0);
          sub_1CC5C6C08((void *)(v366[5] + 40), (uint64_t)(v366 + 3), (llvm::Value *)(v372 + 8));
          uint64_t v373 = operator new(0x80uLL);
          v373[21] = v373[21] & 0x38000000 | 2;
          *(void *)uint64_t v373 = 0;
          *((void *)v373 + 1) = 0;
          *((void *)v373 + 2) = 0;
          *((void *)v373 + 3) = v373 + 16;
          *((void *)v373 + 4) = 0;
          *((void *)v373 + 5) = 0;
          *((void *)v373 + 6) = 0;
          *((void *)v373 + 7) = v373 + 16;
          uint64_t v374 = *((void *)v372 + 8);
          if (v374) {
            BOOL v375 = v374 == *((void *)v372 + 9) + 40;
          }
          else {
            BOOL v375 = 1;
          }
          if (v375) {
            uint64_t v376 = 0;
          }
          else {
            uint64_t v376 = (llvm::Instruction *)(v374 - 24);
          }
          llvm::StoreInst::StoreInst((llvm::StoreInst *)(v373 + 16), (llvm::Type **)v372 + 4, v427, 1, v376);
          unsigned int v359 = v422;
        }
      }
      else if (v367 == 59)
      {
        goto LABEL_546;
      }
      uint64_t v365 = (uint64_t *)v365[1];
      continue;
    }
  }
LABEL_556:
  if (v440)
  {
    uint64_t v377 = (char *)v439;
    uint64_t v378 = 8 * v440;
    do
    {
      uint64_t v379 = *(void *)v377;
      uint64_t v380 = llvm::BasicBlock::getTerminatingMustTailCall(*(llvm::BasicBlock **)(*(void *)v377 + 40));
      v381 = *(uint64_t ***)(v420 + 80);
      long long v382 = *(uint64_t ***)(v420 + 88);
      __int16 v463 = 257;
      int v383 = (char *)operator new(0x90uLL);
      uint64_t v384 = v383;
      unsigned int v385 = (llvm::Value *)(v383 + 64);
      *((_DWORD *)v383 + 21) = *((_DWORD *)v383 + 21) & 0x38000000 | 2;
      *(void *)int v383 = 0;
      *((void *)v383 + 1) = 0;
      *((void *)v383 + 2) = 0;
      *((void *)v383 + 3) = v383 + 64;
      *((void *)v383 + 4) = 0;
      *((void *)v383 + 5) = 0;
      *((void *)v383 + 6) = 0;
      *((void *)v383 + 7) = v383 + 64;
      if (!v380) {
        uint64_t v380 = v379;
      }
      *((void *)v383 + 8) = *v381[2];
      *((void *)v383 + 9) = 0;
      *((_WORD *)v383 + 40) = 84;
      *((_WORD *)v383 + 41) = 0;
      *((_DWORD *)v383 + 21) = 2;
      *(_OWORD *)(v383 + 88) = 0u;
      v386 = v383 + 88;
      *((_DWORD *)v383 + 30) = 0;
      *(_OWORD *)(v383 + 104) = 0u;
      if (v380)
      {
        uint64_t v387 = *(void *)(v380 + 40);
        *((void *)v383 + 13) = v387;
        *(_WORD *)(v387 + 18) &= ~0x8000u;
        if ((v383[87] & 0x10) != 0)
        {
          uint64_t v389 = *(void *)(v387 + 56);
          if (v389)
          {
            uint64_t v390 = *(llvm::ValueSymbolTable **)(v389 + 104);
            if (v390) {
              llvm::ValueSymbolTable::reinsertValue(v390, v385);
            }
          }
        }
        uint64_t v388 = *(void *)(v380 + 24);
        v384[11] = v388;
        v384[12] = v380 + 24;
        *(void *)(v388 + 8) = v386;
        *(void *)(v380 + 24) = v386;
      }
      v384[16] = 0;
      llvm::CallInst::init((uint64_t ***)v385, v381, v382, (uint64_t *)v428, 1, 0, 0, (const char **)&v460);
      v377 += 8;
      v378 -= 8;
    }
    while (v378);
  }
  if (v442 != &v444) {
    free(v442);
  }
  uint64_t v57 = 1;
LABEL_62:
  if (v433 != v435) {
    free(v433);
  }
  if ((v432[0] & 1) == 0) {
    MEMORY[0x1D25D9CD0](v432[1], 8);
  }
  if (v436 != v438) {
    free(v436);
  }
  if (v439 != v441) {
    free(v439);
  }
  return v57;
}

void sub_1CC4722EC(void *a1, uint64_t **a2, int a3)
{
  uint64_t v6 = 0;
  v57[1] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = **a2;
  uint64_t v42 = v44;
  uint64_t v43 = 0x200000000;
  uint64_t v47 = v7;
  unint64_t v48 = &v56;
  int v49 = v57;
  uint64_t v50 = 0;
  int v51 = 0;
  __int16 v52 = 512;
  char v53 = 7;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = &unk_1F2616E88;
  v57[0] = &unk_1F2617008;
  uint64_t v8 = a2 + 3;
  uint64_t v10 = a2[5];
  unint64_t v9 = (unsigned __int8 *)a2[6];
  int v45 = v10;
  uint64_t v46 = v8;
  v41[0] = (uint64_t)v9;
  if (v9)
  {
    llvm::MetadataTracking::track((uint64_t)v41, v9, 2);
    uint64_t v6 = v41[0];
  }
  sub_1CB8461A4((uint64_t)&v42, 0, v6);
  if (v41[0])
  {
    int v33 = *(unsigned __int8 *)v41[0];
    if ((v33 - 4) > 0x1E)
    {
      if ((v33 - 3) >= 0xFFFFFFFE) {
        uint64_t v37 = v41[0];
      }
      else {
        uint64_t v37 = 0;
      }
      if ((v33 - 3) < 0xFFFFFFFE)
      {
        if (v33 == 3) {
          *(void *)(v41[0] + 8) = 0;
        }
        goto LABEL_4;
      }
      unint64_t v35 = v37 + 8;
    }
    else
    {
      if ((*(unsigned char *)(v41[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v41[0] + 12)) {
        goto LABEL_4;
      }
      uint64_t v34 = *(void *)(v41[0] + 16);
      if ((v34 & 4) == 0) {
        goto LABEL_4;
      }
      unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFF8;
      if (!v35) {
        goto LABEL_4;
      }
    }
    int v38 = v41;
    sub_1CC5FA668(v35 + 16, &v38);
  }
LABEL_4:
  uint64_t v11 = (llvm::ConstantInt *)(*(void *)**a2 + 1960);
  uint64_t v12 = llvm::ConstantInt::get(v11, 0, 0);
  uint64_t v13 = llvm::ConstantInt::get(v11, 1uLL, 0);
  v41[0] = (uint64_t)v12;
  v41[1] = (uint64_t)v13;
  uint64_t v14 = a1[7];
  uint64_t v15 = (uint64_t *)a1[19];
  int v38 = (uint64_t *)"call_site";
  __int16 v40 = 259;
  uint64_t v17 = sub_1CC27CEC0((uint64_t *)&v42, v14, v15, v41, 2, (uint64_t)&v38);
  uint64_t v18 = a1[4];
  uint64_t v19 = a3;
  uint64_t v20 = *(llvm::ConstantInt **)v18;
  unint64_t v21 = *(unsigned int *)(v18 + 8);
  unsigned int v39 = v21 >> 8;
  if (v21 >> 8 > 0x40) {
    operator new[]();
  }
  if (v21 <= 0xFF) {
    unint64_t v22 = 0;
  }
  else {
    unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> ~(BYTE1(v21) + 63);
  }
  int v38 = (uint64_t *)(v22 & v19);
  uint64_t v23 = llvm::ConstantInt::get(v20, (llvm::LLVMContext *)&v38, v16);
  if (v39 >= 0x41 && v38) {
    MEMORY[0x1D25D9CB0](v38, 0x1000C8000313F17);
  }
  char Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(v45[7] + 40) + 272), (llvm::Type *)*v23, 1);
  uint64_t v25 = (char *)operator new(0x80uLL);
  *((_DWORD *)v25 + 21) = *((_DWORD *)v25 + 21) & 0x38000000 | 2;
  *(void *)uint64_t v25 = 0;
  *((void *)v25 + 2) = 0;
  *((void *)v25 + 1) = 0;
  *((void *)v25 + 5) = 0;
  *((void *)v25 + 6) = 0;
  *((void *)v25 + 4) = 0;
  *((void *)v25 + 8) = **(void **)*v23 + 1576;
  int64x2_t v26 = (llvm::Instruction *)(v25 + 64);
  *((void *)v25 + 3) = v25 + 64;
  *((void *)v25 + 7) = v25 + 64;
  *((void *)v25 + 9) = 0;
  v25[80] = 61;
  v25[81] = 0;
  *((_DWORD *)v25 + 21) = 2;
  *(_OWORD *)(v25 + 88) = 0u;
  *(_OWORD *)(v25 + 104) = 0u;
  *((_DWORD *)v25 + 30) = 0;
  uint64_t v27 = v23 + 1;
  uint64_t v28 = v23[1];
  *(void *)uint64_t v25 = v23;
  *((void *)v25 + 1) = v28;
  if (v28) {
    *(void *)(v28 + 16) = v25 + 8;
  }
  *((void *)v25 + 2) = v27;
  *uint64_t v27 = v25;
  *((void *)v25 + 4) = v17;
  if (v17)
  {
    uint64_t v31 = *(void *)(v17 + 8);
    uint64_t v30 = (void *)(v17 + 8);
    uint64_t v29 = v31;
    *((void *)v25 + 5) = v31;
    if (v31) {
      *(void *)(v29 + 16) = v25 + 40;
    }
    *((void *)v25 + 6) = v30;
    *uint64_t v30 = v25 + 32;
  }
  *((_WORD *)v25 + 41) = (2 * (Alignment & 0x3F)) | 1;
  v25[124] = 1;
  __int16 v40 = 257;
  (*(void (**)(void *, llvm::Instruction *, uint64_t **, uint64_t *, uint64_t **))(*v49 + 16))(v49, v26, &v38, v45, v46);
  uint64_t v32 = (llvm::MDNode **)v42;
  if (v43)
  {
    uint64_t v36 = (llvm::MDNode **)((char *)v42 + 16 * v43);
    do
    {
      llvm::Instruction::setMetadata(v26, *(_DWORD *)v32, v32[1]);
      v32 += 2;
    }
    while (v32 != v36);
    uint64_t v32 = (llvm::MDNode **)v42;
  }
  if (v32 != (llvm::MDNode **)v44) {
    free(v32);
  }
}

void sub_1CC472764(uint64_t a1, llvm::SmallPtrSetImplBase *this)
{
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *((unsigned int *)this + 5);
  if (v4 == *(void *)this)
  {
    if (v5)
    {
      uint64_t v6 = 0;
      uint64_t v7 = 8 * v5;
      uint64_t v8 = (uint64_t *)*((void *)this + 1);
      do
      {
        if (*v8 == a1) {
          return;
        }
        if (*v8 == -2) {
          uint64_t v6 = v8;
        }
        ++v8;
        v7 -= 8;
      }
      while (v7);
      if (v6)
      {
        *uint64_t v6 = a1;
        --*((_DWORD *)this + 6);
        goto LABEL_33;
      }
    }
    unsigned int v9 = *((_DWORD *)this + 4);
    if (v5 < v9)
    {
      *((_DWORD *)this + 5) = v5 + 1;
      *(void *)(v4 + 8 * v5) = a1;
      goto LABEL_33;
    }
  }
  else
  {
    unsigned int v9 = *((_DWORD *)this + 4);
  }
  if (3 * v9 <= 4 * ((int)v5 - *((_DWORD *)this + 6)))
  {
    if (v9 >= 0x40) {
      v9 *= 2;
    }
    else {
      unsigned int v9 = 128;
    }
  }
  else if (v9 - v5 >= v9 >> 3)
  {
    goto LABEL_14;
  }
  llvm::SmallPtrSetImplBase::Grow(this, v9);
  unsigned int v9 = *((_DWORD *)this + 4);
  uint64_t v4 = *((void *)this + 1);
LABEL_14:
  unsigned int v10 = v9 - 1;
  unsigned int v11 = (v9 - 1) & ((a1 >> 4) ^ (a1 >> 9));
  uint64_t v12 = (uint64_t *)(v4 + 8 * v11);
  uint64_t v13 = *v12;
  if (*v12 == -1)
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = 0;
    int v15 = 1;
    do
    {
      if (v13 == a1) {
        return;
      }
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v13 == -2;
      }
      if (v16) {
        uint64_t v14 = v12;
      }
      unsigned int v17 = v11 + v15++;
      unsigned int v11 = v17 & v10;
      uint64_t v12 = (uint64_t *)(v4 + 8 * (v17 & v10));
      uint64_t v13 = *v12;
    }
    while (*v12 != -1);
  }
  if (v14) {
    uint64_t v18 = v14;
  }
  else {
    uint64_t v18 = v12;
  }
  if (*v18 != a1)
  {
    if (*v18 == -2) {
      --*((_DWORD *)this + 6);
    }
    else {
      ++*((_DWORD *)this + 5);
    }
    *uint64_t v18 = a1;
LABEL_33:
    uint64_t v81 = v85;
    uint64_t v82 = v85;
    uint64_t v83 = 8;
    int v84 = 0;
    sub_1CD520EA4(&v86, a1, (llvm::SmallPtrSetImplBase *)&v81);
    uint64_t v19 = v87;
    v75[0] = v86;
    v75[1] = v87;
    long long v76 = v88;
    uint64_t v77 = &v81;
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    uint64_t v80 = 0;
    uint64_t v20 = (unsigned char *)v88;
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v88 - (void)v87) >> 3);
    uint64_t v87 = 0;
    long long v88 = 0uLL;
    sub_1CBF340A8(&v87, v19, v20, v21);
    unint64_t v22 = (char *)v88;
    if ((char *)v88 == v87) {
      goto LABEL_156;
    }
    while (1)
    {
      uint64_t v23 = *((void *)v22 - 3);
      uint64_t v24 = *((void *)this + 1);
      uint64_t v25 = *((unsigned int *)this + 5);
      if (v24 == *(void *)this)
      {
        if (v25)
        {
          int64x2_t v26 = 0;
          uint64_t v27 = 8 * v25;
          uint64_t v28 = (void *)*((void *)this + 1);
          do
          {
            if (*v28 == v23) {
              goto LABEL_66;
            }
            if (*v28 == -2) {
              int64x2_t v26 = v28;
            }
            ++v28;
            v27 -= 8;
          }
          while (v27);
          if (v26)
          {
            *int64x2_t v26 = v23;
            --*((_DWORD *)this + 6);
            goto LABEL_66;
          }
        }
        unsigned int v29 = *((_DWORD *)this + 4);
        if (v25 < v29)
        {
          *((_DWORD *)this + 5) = v25 + 1;
          *(void *)(v24 + 8 * v25) = v23;
          goto LABEL_66;
        }
      }
      else
      {
        unsigned int v29 = *((_DWORD *)this + 4);
      }
      if (3 * v29 <= 4 * ((int)v25 - *((_DWORD *)this + 6)))
      {
        if (v29 >= 0x40) {
          v29 *= 2;
        }
        else {
          unsigned int v29 = 128;
        }
      }
      else if (v29 - v25 >= v29 >> 3)
      {
        goto LABEL_47;
      }
      llvm::SmallPtrSetImplBase::Grow(this, v29);
      unsigned int v29 = *((_DWORD *)this + 4);
      uint64_t v24 = *((void *)this + 1);
LABEL_47:
      unsigned int v30 = v29 - 1;
      unsigned int v31 = (v29 - 1) & ((v23 >> 4) ^ (v23 >> 9));
      uint64_t v32 = (void *)(v24 + 8 * v31);
      uint64_t v33 = *v32;
      if (*v32 == -1)
      {
        uint64_t v34 = 0;
LABEL_59:
        if (v34) {
          int v38 = v34;
        }
        else {
          int v38 = v32;
        }
        if (*v38 != v23)
        {
          if (*v38 == -2) {
            --*((_DWORD *)this + 6);
          }
          else {
            ++*((_DWORD *)this + 5);
          }
          *int v38 = v23;
        }
      }
      else
      {
        uint64_t v34 = 0;
        int v35 = 1;
        while (v33 != v23)
        {
          if (v34) {
            BOOL v36 = 0;
          }
          else {
            BOOL v36 = v33 == -2;
          }
          if (v36) {
            uint64_t v34 = v32;
          }
          unsigned int v37 = v31 + v35++;
          unsigned int v31 = v37 & v30;
          uint64_t v32 = (void *)(v24 + 8 * (v37 & v30));
          uint64_t v33 = *v32;
          if (*v32 == -1) {
            goto LABEL_59;
          }
        }
      }
LABEL_66:
      unint64_t v22 = (char *)v88;
      while (1)
      {
        if (*(v22 - 8))
        {
          uint64_t v39 = *((void *)v22 - 2);
          if (v39) {
            goto LABEL_69;
          }
          goto LABEL_123;
        }
        uint64_t v39 = *((void *)v22 - 3);
        do
        {
          uint64_t v39 = *(void *)(v39 + 8);
          if (!v39) {
            break;
          }
          uint64_t v62 = *(void *)(v39 + 24);
          unsigned int v63 = *(unsigned __int8 *)(v62 + 16);
          BOOL v64 = v62 && v63 >= 0x1C;
        }
        while (!v64 || v63 - 29 >= 0xB);
        *((void *)v22 - 2) = v39;
        *(v22 - 8) = 1;
        if (v39) {
          break;
        }
LABEL_123:
        unint64_t v22 = (char *)(v88 - 24);
        *(void *)&long long v88 = v22;
        if (v87 == v22) {
          goto LABEL_157;
        }
      }
      while (1)
      {
LABEL_69:
        uint64_t v40 = v39;
        do
        {
          uint64_t v40 = *(void *)(v40 + 8);
          if (!v40) {
            break;
          }
          uint64_t v41 = *(void *)(v40 + 24);
          unsigned int v42 = *(unsigned __int8 *)(v41 + 16);
          BOOL v43 = v41 && v42 >= 0x1C;
        }
        while (!v43 || v42 - 29 > 0xA);
        *((void *)v22 - 2) = v40;
        uint64_t v45 = *(void *)(*(void *)(v39 + 24) + 40);
        uint64_t v46 = v86;
        uint64_t v47 = *((void *)v86 + 1);
        uint64_t v48 = *((unsigned int *)v86 + 5);
        if (v47 == *(void *)v86)
        {
          if (v48)
          {
            int v49 = 0;
            uint64_t v50 = 8 * v48;
            int v51 = (void *)*((void *)v86 + 1);
            while (*v51 != v45)
            {
              if (*v51 == -2) {
                int v49 = v51;
              }
              ++v51;
              v50 -= 8;
              if (!v50)
              {
                if (!v49) {
                  goto LABEL_86;
                }
                *int v49 = v45;
                --*((_DWORD *)v46 + 6);
                goto LABEL_129;
              }
            }
            goto LABEL_107;
          }
LABEL_86:
          unsigned int v52 = *((_DWORD *)v86 + 4);
          if (v48 < v52)
          {
            *((_DWORD *)v86 + 5) = v48 + 1;
            *(void *)(v47 + 8 * v48) = v45;
            goto LABEL_129;
          }
        }
        else
        {
          unsigned int v52 = *((_DWORD *)v86 + 4);
        }
        if (3 * v52 <= 4 * ((int)v48 - *((_DWORD *)v86 + 6)))
        {
          if (v52 >= 0x40) {
            v52 *= 2;
          }
          else {
            unsigned int v52 = 128;
          }
        }
        else if (v52 - v48 >= v52 >> 3)
        {
          goto LABEL_91;
        }
        llvm::SmallPtrSetImplBase::Grow(v86, v52);
        unsigned int v52 = *((_DWORD *)v46 + 4);
        uint64_t v47 = *((void *)v46 + 1);
LABEL_91:
        unsigned int v53 = v52 - 1;
        unsigned int v54 = (v52 - 1) & ((v45 >> 4) ^ (v45 >> 9));
        uint64_t v55 = (void *)(v47 + 8 * v54);
        uint64_t v56 = *v55;
        if (*v55 == -1) {
          break;
        }
        uint64_t v57 = 0;
        int v58 = 1;
        while (v56 != v45)
        {
          if (v57) {
            BOOL v59 = 0;
          }
          else {
            BOOL v59 = v56 == -2;
          }
          if (v59) {
            uint64_t v57 = v55;
          }
          unsigned int v60 = v54 + v58++;
          unsigned int v54 = v60 & v53;
          uint64_t v55 = (void *)(v47 + 8 * (v60 & v53));
          uint64_t v56 = *v55;
          if (*v55 == -1) {
            goto LABEL_103;
          }
        }
LABEL_107:
        uint64_t v39 = *((void *)v22 - 2);
        if (!v39) {
          goto LABEL_123;
        }
      }
      uint64_t v57 = 0;
LABEL_103:
      if (v57) {
        uint64_t v61 = v57;
      }
      else {
        uint64_t v61 = v55;
      }
      if (*v61 == v45) {
        goto LABEL_107;
      }
      if (*v61 == -2) {
        --*((_DWORD *)v46 + 6);
      }
      else {
        ++*((_DWORD *)v46 + 5);
      }
      *uint64_t v61 = v45;
LABEL_129:
      uint64_t v66 = (char *)v88;
      if ((unint64_t)v88 >= *((void *)&v88 + 1))
      {
        uint64_t v67 = v87;
        unint64_t v68 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v88 - (void)v87) >> 3);
        unint64_t v69 = v68 + 1;
        if (v68 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * ((uint64_t)(*((void *)&v88 + 1) - (void)v87) >> 3) > v69) {
          unint64_t v69 = 0x5555555555555556 * ((uint64_t)(*((void *)&v88 + 1) - (void)v87) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v88 + 1) - (void)v87) >> 3) >= 0x555555555555555) {
          unint64_t v70 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v70 = v69;
        }
        if (v70)
        {
          if (v70 > 0xAAAAAAAAAAAAAAALL) {
            sub_1CB833614();
          }
          int v71 = (char *)operator new(24 * v70);
        }
        else
        {
          int v71 = 0;
        }
        uint64_t v72 = &v71[24 * v68];
        *(void *)uint64_t v72 = v45;
        v72[8] = 0;
        v72[16] = 0;
        int v73 = v72;
        if (v66 != v67)
        {
          do
          {
            long long v74 = *(_OWORD *)(v66 - 24);
            *((void *)v73 - 1) = *((void *)v66 - 1);
            *(_OWORD *)(v73 - 24) = v74;
            v73 -= 24;
            v66 -= 24;
          }
          while (v66 != v67);
          uint64_t v66 = v87;
        }
        unint64_t v22 = v72 + 24;
        uint64_t v87 = v73;
        *(void *)&long long v88 = v72 + 24;
        *((void *)&v88 + 1) = &v71[24 * v70];
        if (v66) {
          operator delete(v66);
        }
      }
      else
      {
        *(void *)long long v88 = v45;
        v66[8] = 0;
        unint64_t v22 = v66 + 24;
        v66[16] = 0;
      }
      *(void *)&long long v88 = v22;
      if (v22 == v87)
      {
        unint64_t v22 = v87;
LABEL_156:
        if (v22)
        {
LABEL_157:
          *(void *)&long long v88 = v22;
          operator delete(v22);
        }
        sub_1CD481D8C(v75);
        if (v82 != v81) {
          free(v82);
        }
        return;
      }
    }
  }
}

uint64_t sub_1CC472E24(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a2 == a3)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2;
    do
    {
      ++v4;
      uint64_t v5 = *(void *)(v5 + 8);
    }
    while (v5 != a3);
  }
  uint64_t v6 = *(unsigned int *)(result + 8);
  if (v4 + v6 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    uint64_t v7 = (void *)(*(void *)result + 8 * v6);
    do
    {
      *v7++ = *(void *)(v3 + 24);
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a3);
  }
  *(_DWORD *)(result + 8) = v6 + v4;
  return result;
}

void llvm::initializeSlotIndexesPass(uint64_t a1)
{
  uint64_t v1 = a1;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD3B58, memory_order_acquire) != -1)
  {
    v3[0] = sub_1CC473008;
    v3[1] = &v1;
    int v2 = v3;
    std::__call_once(&qword_1EBCD3B58, &v2, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::SlotIndexes::~SlotIndexes(llvm::SlotIndexes *this)
{
  *(void *)this = &unk_1F2613088;
  int v2 = (char *)this + 344;
  *((void *)this + 43) = (char *)this + 344;
  *((void *)this + 44) = (char *)this + 344;
  uint64_t v3 = (char *)*((void *)this + 67);
  if (v3 != (char *)this + 552) {
    free(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 49);
  if (v4 != (char *)this + 408) {
    free(v4);
  }
  MEMORY[0x1D25D9CD0](*((void *)this + 46), 8);
  uint64_t v5 = (char *)*((void *)this + 44);
  if (v5 != v2)
  {
    do
    {
      uint64_t v7 = *(void *)v5;
      uint64_t v6 = (char *)*((void *)v5 + 1);
      *(void *)uint64_t v6 = *(void *)v5;
      *(void *)(v7 + 8) = v6;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v5 = v6;
    }
    while (v6 != v2);
  }
  sub_1CBFFBA64((uint64_t)this + 248);

  sub_1CBA0E6AC(this);
}

{
  uint64_t vars8;

  llvm::SlotIndexes::~SlotIndexes(this);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC473008()
{
}

unsigned int *llvm::SlotIndexes::releaseMemory(unsigned int *this)
{
  uint64_t v1 = this;
  int v2 = (char *)(this + 92);
  unsigned int v3 = this[94];
  if (v3)
  {
    unsigned int v4 = this[96];
    if (v4 > 4 * v3 && v4 >= 0x41)
    {
      int v5 = 1 << (33 - __clz(v3 - 1));
      if (v5 <= 64) {
        int v6 = 64;
      }
      else {
        int v6 = v5;
      }
LABEL_7:
      if (v6 == v4)
      {
        *((void *)this + 47) = 0;
        uint64_t v26 = 16 * v4;
        uint64_t v27 = (void *)*((void *)this + 46);
        do
        {
          *uint64_t v27 = -4096;
          v27 += 2;
          v26 -= 16;
        }
        while (v26);
      }
      else
      {
        this = (unsigned int *)MEMORY[0x1D25D9CD0](*(void *)v2, 8);
        if (v6)
        {
          unint64_t v7 = (4 * v6 / 3u + 1) | ((unint64_t)(4 * v6 / 3u + 1) >> 1);
          unint64_t v8 = v7 | (v7 >> 2) | ((v7 | (v7 >> 2)) >> 4);
          LODWORD(v8) = (((v8 | (v8 >> 8)) >> 16) | v8 | (v8 >> 8)) + 1;
          v1[96] = v8;
          this = (unsigned int *)operator new(16 * v8, (std::align_val_t)8uLL);
          *((void *)v1 + 46) = this;
          *((void *)v1 + 47) = 0;
          uint64_t v9 = v1[96];
          if (v9)
          {
            uint64_t v10 = 16 * v9;
            do
            {
              *(void *)this = -4096;
              this += 4;
              v10 -= 16;
            }
            while (v10);
          }
        }
        else
        {
          *(void *)int v2 = 0;
          *((void *)v2 + 1) = 0;
          *((_DWORD *)v2 + 4) = 0;
        }
      }
      goto LABEL_21;
    }
  }
  else
  {
    if (!this[95]) {
      goto LABEL_21;
    }
    unsigned int v4 = this[96];
    if (v4 > 0x40)
    {
      int v6 = 0;
      goto LABEL_7;
    }
  }
  if (v4)
  {
    unsigned int v11 = *(void **)v2;
    uint64_t v12 = 16 * v4;
    do
    {
      *unsigned int v11 = -4096;
      v11 += 2;
      v12 -= 16;
    }
    while (v12);
  }
  *((void *)this + 47) = 0;
LABEL_21:
  v1[100] = 0;
  v1[136] = 0;
  uint64_t v13 = (unsigned int *)*((void *)v1 + 44);
  if (v13 != v1 + 86)
  {
    do
    {
      uint64_t v15 = *(void *)v13;
      uint64_t v14 = (unsigned int *)*((void *)v13 + 1);
      *(void *)uint64_t v14 = *(void *)v13;
      *(void *)(v15 + 8) = v14;
      *(void *)uint64_t v13 = 0;
      *((void *)v13 + 1) = 0;
      uint64_t v13 = v14;
    }
    while (v14 != v1 + 86);
  }
  uint64_t v16 = v1[80];
  if (v16)
  {
    uint64_t v23 = (uint64_t *)*((void *)v1 + 39);
    uint64_t v24 = 16 * v16;
    do
    {
      uint64_t v25 = *v23;
      v23 += 2;
      this = (unsigned int *)MEMORY[0x1D25D9CD0](v25, 8);
      v24 -= 16;
    }
    while (v24);
  }
  v1[80] = 0;
  uint64_t v17 = v1[68];
  if (v17)
  {
    *((void *)v1 + 41) = 0;
    uint64_t v18 = (void *)*((void *)v1 + 33);
    uint64_t v19 = *v18 + 4096;
    *((void *)v1 + 31) = *v18;
    *((void *)v1 + 32) = v19;
    if (v17 != 1)
    {
      uint64_t v20 = v18 + 1;
      uint64_t v21 = 8 * v17 - 8;
      do
      {
        uint64_t v22 = *v20++;
        this = (unsigned int *)MEMORY[0x1D25D9CD0](v22, 8);
        v21 -= 8;
      }
      while (v21);
    }
    v1[68] = 1;
  }
  return this;
}

uint64_t llvm::SlotIndexes::runOnMachineFunction(llvm::SlotIndexes *this, llvm::MachineFunction *a2)
{
  *((void *)this + 45) = a2;
  unint64_t v3 = *((void *)a2 + 14) - *((void *)a2 + 13);
  unint64_t v4 = (v3 >> 3);
  unint64_t v5 = *((unsigned int *)this + 100);
  if (v4 != v5)
  {
    if (v4 >= v5)
    {
      if (v4 > *((unsigned int *)this + 101)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v4 != v5) {
        bzero((void *)(*((void *)this + 49) + 16 * v5), 16 * (v4 - v5));
      }
    }
    *((_DWORD *)this + 100) = v3 >> 3;
    a2 = (llvm::MachineFunction *)*((void *)this + 45);
  }
  unsigned int v6 = -1;
  unint64_t v7 = (void *)((char *)a2 + 320);
  do
  {
    unint64_t v7 = (void *)v7[1];
    ++v6;
  }
  while (v7 != (void *)((char *)a2 + 320));
  unint64_t v8 = (uint64_t *)((char *)this + 536);
  if (v6 > (unint64_t)*((unsigned int *)this + 137)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v9 = (uint64_t *)((char *)this + 344);
  *((void *)this + 41) += 32;
  uint64_t v10 = *((void *)this + 31);
  if (((v10 + 7) & 0xFFFFFFFFFFFFFFF8) - v10 + 32 > *((void *)this + 32) - v10)
  {
    unsigned int v54 = *((_DWORD *)this + 68) >> 7;
    if (v54 >= 0x1E) {
      LOBYTE(v54) = 30;
    }
    uint64_t v55 = 4096 << v54;
    unint64_t v11 = (unint64_t)operator new(4096 << v54, (std::align_val_t)8uLL);
    unsigned int v56 = *((_DWORD *)this + 68);
    if (v56 >= *((_DWORD *)this + 69)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*((void *)this + 33) + 8 * v56) = v11;
    ++*((_DWORD *)this + 68);
    *((void *)this + 32) = v11 + v55;
  }
  else
  {
    unint64_t v11 = (v10 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *((void *)this + 31) = v11 + 32;
  *(_DWORD *)(v11 + 24) = 0;
  *(void *)(v11 + 8) = 0;
  *(void *)(v11 + 16) = 0;
  *(void *)unint64_t v11 = 0;
  uint64_t v12 = *((void *)this + 43);
  *(void *)unint64_t v11 = v12;
  *(void *)(v11 + 8) = v9;
  *(void *)(v12 + 8) = v11;
  *((void *)this + 43) = v11;
  uint64_t v13 = *((void *)this + 45);
  uint64_t v14 = v13 + 320;
  unint64_t v15 = *(void *)(v13 + 328);
  if (v15 != v13 + 320)
  {
    int v16 = 0;
    uint64_t v57 = v13 + 320;
    while (1)
    {
      uint64_t v58 = *v9;
      for (uint64_t i = *(void *)(v15 + 56); i != v15 + 48; uint64_t i = *(void *)(i + 8))
      {
        unsigned int v18 = **(unsigned __int16 **)(i + 16);
        BOOL v19 = v18 > 0x17;
        int v20 = (1 << v18) & 0x83E000;
        if (!v19 && v20 != 0) {
          goto LABEL_25;
        }
        *((void *)this + 41) += 32;
        uint64_t v22 = *((void *)this + 31);
        if (((v22 + 7) & 0xFFFFFFFFFFFFFFF8) - v22 + 32 > *((void *)this + 32) - v22)
        {
          unsigned int v37 = *((_DWORD *)this + 68) >> 7;
          if (v37 >= 0x1E) {
            LOBYTE(v37) = 30;
          }
          uint64_t v38 = 4096 << v37;
          unint64_t v23 = (unint64_t)operator new(4096 << v37, (std::align_val_t)8uLL);
          unint64_t v39 = *((unsigned int *)this + 68);
          if (v39 >= *((unsigned int *)this + 69)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*((void *)this + 33) + 8 * v39) = v23;
          ++*((_DWORD *)this + 68);
          *((void *)this + 32) = v23 + v38;
          uint64_t v14 = v57;
        }
        else
        {
          unint64_t v23 = (v22 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        v16 += 16;
        *((void *)this + 31) = v23 + 32;
        *(void *)unint64_t v23 = 0;
        *(void *)(v23 + 8) = 0;
        *(void *)(v23 + 16) = i;
        *(_DWORD *)(v23 + 24) = v16;
        uint64_t v24 = *((void *)this + 43);
        *(void *)unint64_t v23 = v24;
        *(void *)(v23 + 8) = v9;
        *(void *)(v24 + 8) = v23;
        *((void *)this + 43) = v23;
        uint64_t v59 = i;
        unint64_t v60 = v23 & 0xFFFFFFFFFFFFFFF9;
        int v25 = *((_DWORD *)this + 96);
        if (v25)
        {
          uint64_t v26 = *((void *)this + 46);
          int v27 = v25 - 1;
          unsigned int v28 = v27 & ((i >> 4) ^ (i >> 9));
          unsigned int v29 = (void *)(v26 + 16 * v28);
          uint64_t v30 = *v29;
          if (i == *v29) {
            goto LABEL_25;
          }
          unsigned int v31 = 0;
          int v32 = 1;
          while (v30 != -4096)
          {
            if (v31) {
              BOOL v33 = 0;
            }
            else {
              BOOL v33 = v30 == -8192;
            }
            if (v33) {
              unsigned int v31 = v29;
            }
            unsigned int v34 = v28 + v32++;
            unsigned int v28 = v34 & v27;
            unsigned int v29 = (void *)(v26 + 16 * v28);
            uint64_t v30 = *v29;
            if (i == *v29) {
              goto LABEL_36;
            }
          }
          int v35 = v31 ? v31 : v29;
        }
        else
        {
          int v35 = 0;
        }
        BOOL v36 = sub_1CB9150E4((uint64_t)this + 368, (uint64_t)&v59, &v59, v35);
        *BOOL v36 = v59;
        v36[1] = v60;
LABEL_36:
        if (i)
        {
LABEL_25:
          if ((*(unsigned char *)i & 4) != 0) {
            continue;
          }
        }
        if ((*(_WORD *)(i + 44) & 8) != 0)
        {
          do
            uint64_t i = *(void *)(i + 8);
          while ((*(_WORD *)(i + 44) & 8) != 0);
          uint64_t v14 = v57;
        }
      }
      *((void *)this + 41) += 32;
      uint64_t v40 = *((void *)this + 31);
      if (((v40 + 7) & 0xFFFFFFFFFFFFFFF8) - v40 + 32 > *((void *)this + 32) - v40)
      {
        unsigned int v51 = *((_DWORD *)this + 68) >> 7;
        if (v51 >= 0x1E) {
          LOBYTE(v51) = 30;
        }
        uint64_t v52 = 4096 << v51;
        unint64_t v41 = (unint64_t)operator new(4096 << v51, (std::align_val_t)8uLL);
        unint64_t v53 = *((unsigned int *)this + 68);
        if (v53 >= *((unsigned int *)this + 69)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*((void *)this + 33) + 8 * v53) = v41;
        ++*((_DWORD *)this + 68);
        *((void *)this + 32) = v41 + v52;
        uint64_t v14 = v57;
        uint64_t v42 = v58;
      }
      else
      {
        unint64_t v41 = (v40 + 7) & 0xFFFFFFFFFFFFFFF8;
        uint64_t v42 = v58;
      }
      v16 += 16;
      *((void *)this + 31) = v41 + 32;
      *(void *)unint64_t v41 = 0;
      *(void *)(v41 + 8) = 0;
      *(void *)(v41 + 16) = 0;
      *(_DWORD *)(v41 + 24) = v16;
      uint64_t v43 = *((void *)this + 43);
      *(void *)unint64_t v41 = v43;
      *(void *)(v41 + 8) = v9;
      *(void *)(v43 + 8) = v41;
      *((void *)this + 43) = v41;
      uint64_t v44 = (unint64_t *)(*((void *)this + 49) + 16 * *(int *)(v15 + 24));
      *uint64_t v44 = v42 & 0xFFFFFFFFFFFFFFF9;
      v44[1] = v41 & 0xFFFFFFFFFFFFFFF9;
      unint64_t v45 = *((unsigned int *)this + 136);
      if (v45 >= *((unsigned int *)this + 137)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v46 = (unint64_t *)(*((void *)this + 67) + 16 * v45);
      unint64_t *v46 = v42 & 0xFFFFFFFFFFFFFFF9;
      v46[1] = v15;
      unsigned int v47 = *((_DWORD *)this + 136) + 1;
      *((_DWORD *)this + 136) = v47;
      unint64_t v15 = *(void *)(v15 + 8);
      if (v15 == v14)
      {
        unint64_t v8 = (uint64_t *)((char *)this + 536);
        goto LABEL_51;
      }
    }
  }
  unsigned int v47 = *((_DWORD *)this + 136);
LABEL_51:
  unint64_t v48 = 126 - 2 * __clz(v47);
  if (v47) {
    uint64_t v49 = v48;
  }
  else {
    uint64_t v49 = 0;
  }
  sub_1CC319DC8(*v8, (uint64_t *)(*v8 + 16 * v47), (uint64_t)&v59, v49, 1);
  return 0;
}

int32x2_t llvm::SlotIndexes::removeMachineInstrFromMaps(int32x2_t *this, llvm::MachineInstr *a2)
{
  int32x2_t v2 = this[46];
  uint64_t v3 = this[48].u32[0];
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v5 = *(void *)&v2 + 16 * v4;
    unsigned int v6 = *(llvm::MachineInstr **)v5;
    if (*(llvm::MachineInstr **)v5 == a2) {
      goto LABEL_3;
    }
    int v9 = 1;
    while (v6 != (llvm::MachineInstr *)-4096)
    {
      int v10 = v4 + v9++;
      uint64_t v4 = v10 & (v3 - 1);
      unsigned int v6 = *(llvm::MachineInstr **)(*(void *)&v2 + 16 * v4);
      if (v6 == a2)
      {
        uint64_t v5 = *(void *)&v2 + 16 * v4;
        goto LABEL_3;
      }
    }
  }
  uint64_t v5 = *(void *)&v2 + 16 * v3;
LABEL_3:
  if (v5 != *(void *)&v2 + 16 * v3)
  {
    unint64_t v7 = *(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8;
    *(void *)uint64_t v5 = -8192;
    int32x2_t result = vadd_s32(this[47], (int32x2_t)0x1FFFFFFFFLL);
    this[47] = result;
    *(void *)(v7 + 16) = 0;
  }
  return result;
}

int32x2_t *llvm::SlotIndexes::removeSingleMachineInstrFromMaps(int32x2_t *this, llvm::MachineInstr *a2)
{
  int32x2_t v2 = this[46];
  uint64_t v3 = this[48].u32[0];
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v5 = *(void *)&v2 + 16 * v4;
    unsigned int v6 = *(llvm::MachineInstr **)v5;
    if (*(llvm::MachineInstr **)v5 == a2) {
      goto LABEL_3;
    }
    int v9 = 1;
    while (v6 != (llvm::MachineInstr *)-4096)
    {
      int v10 = v4 + v9++;
      uint64_t v4 = v10 & (v3 - 1);
      unsigned int v6 = *(llvm::MachineInstr **)(*(void *)&v2 + 16 * v4);
      if (v6 == a2)
      {
        uint64_t v5 = *(void *)&v2 + 16 * v4;
        goto LABEL_3;
      }
    }
  }
  uint64_t v5 = *(void *)&v2 + 16 * v3;
LABEL_3:
  if (v5 == *(void *)&v2 + 16 * v3) {
    return this;
  }
  int32x2_t v7 = *(int32x2_t *)(v5 + 8);
  unint64_t v8 = *(void *)&v7 & 0xFFFFFFFFFFFFFFF8;
  *(void *)uint64_t v5 = -8192;
  this[47] = vadd_s32(this[47], (int32x2_t)0x1FFFFFFFFLL);
  if ((*((unsigned char *)a2 + 44) & 8) == 0)
  {
    *(void *)(v8 + 16) = 0;
    return this;
  }
  this += 46;
  uint64_t v11 = *((void *)a2 + 1);
  *(void *)(v8 + 16) = v11;
  uint64_t v21 = v11;
  int32x2_t v22 = v7;
  if (!v3)
  {
    int v20 = 0;
LABEL_26:
    this = (int32x2_t *)sub_1CB9150E4((uint64_t)this, (uint64_t)&v21, &v21, v20);
    *this = (int32x2_t)v21;
    this[1] = v22;
    return this;
  }
  int v12 = v3 - 1;
  unsigned int v13 = ((v11 >> 4) ^ (v11 >> 9)) & v12;
  uint64_t v14 = (void *)(*(void *)this + 16 * v13);
  uint64_t v15 = *v14;
  if (v11 != *v14)
  {
    int v16 = 0;
    int v17 = 1;
    while (v15 != -4096)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -8192;
      }
      if (v18) {
        int v16 = v14;
      }
      unsigned int v19 = v13 + v17++;
      unsigned int v13 = v19 & v12;
      uint64_t v14 = (void *)(*(void *)this + 16 * v13);
      uint64_t v15 = *v14;
      if (v11 == *v14) {
        return this;
      }
    }
    if (v16) {
      int v20 = v16;
    }
    else {
      int v20 = v14;
    }
    goto LABEL_26;
  }
  return this;
}

uint64_t llvm::SlotIndexes::renumberIndexes(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)a2 + 24);
  do
  {
    v2 += 8;
    *(_DWORD *)(a2 + 24) = v2;
    a2 = *(void *)(a2 + 8);
  }
  while (a2 != result + 344 && *(_DWORD *)(a2 + 24) <= v2);
  return result;
}

unint64_t llvm::SlotIndexes::repairIndexesInRange(unint64_t result, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  unint64_t v5 = a3;
  unsigned int v6 = (int32x2_t *)result;
  uint64_t v7 = *(void *)(a2 + 56);
  if (v7 != a3)
  {
    uint64_t v8 = *(void *)(result + 368);
    int v9 = *(_DWORD *)(result + 384);
    int v10 = v9 - 1;
    do
    {
      if (v9)
      {
        unsigned int v11 = ((v5 >> 4) ^ (v5 >> 9)) & v10;
        uint64_t v12 = *(void *)(v8 + 16 * v11);
        if (v5 == v12) {
          goto LABEL_16;
        }
        int v13 = 1;
        while (v12 != -4096)
        {
          unsigned int v14 = v11 + v13++;
          unsigned int v11 = v14 & v10;
          uint64_t v12 = *(void *)(v8 + 16 * v11);
          if (v5 == v12) {
            goto LABEL_16;
          }
        }
      }
      unint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFF8;
      if (!v5 || (*(unsigned char *)v5 & 4) == 0)
      {
        while ((*(_WORD *)(v5 + 44) & 4) != 0)
          unint64_t v5 = *(void *)v5 & 0xFFFFFFFFFFFFFFF8;
      }
    }
    while (v5 != v7);
    unint64_t v5 = *(void *)(a2 + 56);
  }
LABEL_16:
  uint64_t v15 = a2 + 48;
  if (a2 + 48 != a4)
  {
    uint64_t v16 = *(void *)(result + 368);
    int v17 = *(_DWORD *)(result + 384);
    int v18 = v17 - 1;
    while (1)
    {
      if (v17)
      {
        unsigned int v19 = ((v4 >> 4) ^ (v4 >> 9)) & v18;
        uint64_t v20 = *(void *)(v16 + 16 * v19);
        if (v4 == v20)
        {
LABEL_31:
          int v23 = 0;
          goto LABEL_33;
        }
        int v21 = 1;
        while (v20 != -4096)
        {
          unsigned int v22 = v19 + v21++;
          unsigned int v19 = v22 & v18;
          uint64_t v20 = *(void *)(v16 + 16 * v19);
          if (v4 == v20) {
            goto LABEL_31;
          }
        }
      }
      if (!v4 || (*(unsigned char *)v4 & 4) == 0)
      {
        while ((*(_WORD *)(v4 + 44) & 8) != 0)
          unint64_t v4 = *(void *)(v4 + 8);
      }
      unint64_t v4 = *(void *)(v4 + 8);
      int v23 = 1;
      if (v4 == v15)
      {
        unint64_t v4 = a2 + 48;
        goto LABEL_33;
      }
    }
  }
  int v23 = 1;
LABEL_33:
  if (v5 == v7)
  {
    unint64_t v39 = (uint64_t *)(*(void *)(result + 392) + 16 * *(unsigned int *)(a2 + 24));
    goto LABEL_52;
  }
  __int16 v24 = *(_WORD *)(v5 + 44);
  unint64_t v25 = v5;
  if ((v24 & 4) != 0)
  {
    unint64_t v25 = v5;
    do
      unint64_t v25 = *(void *)v25 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v25 + 44) & 4) != 0);
  }
  unint64_t v26 = v5;
  if ((v24 & 8) != 0)
  {
    unint64_t v26 = v5;
    do
      unint64_t v26 = *(void *)(v26 + 8);
    while ((*(_WORD *)(v26 + 44) & 8) != 0);
  }
  uint64_t v27 = *(void *)(v26 + 8);
  if (v25 != v27)
  {
    while (1)
    {
      unsigned int v28 = **(unsigned __int16 **)(v25 + 16);
      BOOL v29 = v28 > 0x17;
      int v30 = (1 << v28) & 0x83E000;
      if (v29 || v30 == 0) {
        break;
      }
      unint64_t v25 = *(void *)(v25 + 8);
      if (v25 == v27)
      {
        unint64_t v25 = *(void *)(v26 + 8);
        break;
      }
    }
  }
  uint64_t v32 = *(void *)(result + 368);
  uint64_t v33 = *(unsigned int *)(result + 384);
  if (!v33) {
    goto LABEL_50;
  }
  LODWORD(v34) = ((v25 >> 4) ^ (v25 >> 9)) & (v33 - 1);
  int v35 = (uint64_t *)(v32 + 16 * v34);
  uint64_t v36 = *v35;
  if (v25 != *v35)
  {
    int v37 = 1;
    while (v36 != -4096)
    {
      int v38 = v34 + v37++;
      uint64_t v34 = v38 & (v33 - 1);
      uint64_t v36 = *(void *)(v32 + 16 * v34);
      if (v25 == v36)
      {
        int v35 = (uint64_t *)(v32 + 16 * v34);
        goto LABEL_51;
      }
    }
LABEL_50:
    int v35 = (uint64_t *)(v32 + 16 * v33);
  }
LABEL_51:
  unint64_t v39 = v35 + 1;
LABEL_52:
  uint64_t v40 = *v39;
  if (v23)
  {
    unint64_t v41 = (uint64_t *)(*(void *)(result + 392) + 16 * *(unsigned int *)(a2 + 24) + 8);
    goto LABEL_71;
  }
  __int16 v42 = *(_WORD *)(v4 + 44);
  unint64_t v43 = v4;
  if ((v42 & 4) != 0)
  {
    unint64_t v43 = v4;
    do
      unint64_t v43 = *(void *)v43 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v43 + 44) & 4) != 0);
  }
  unint64_t v44 = v4;
  if ((v42 & 8) != 0)
  {
    unint64_t v44 = v4;
    do
      unint64_t v44 = *(void *)(v44 + 8);
    while ((*(_WORD *)(v44 + 44) & 8) != 0);
  }
  uint64_t v45 = *(void *)(v44 + 8);
  if (v43 != v45)
  {
    while (1)
    {
      unsigned int v46 = **(unsigned __int16 **)(v43 + 16);
      BOOL v29 = v46 > 0x17;
      int v47 = (1 << v46) & 0x83E000;
      if (v29 || v47 == 0) {
        break;
      }
      unint64_t v43 = *(void *)(v43 + 8);
      if (v43 == v45)
      {
        unint64_t v43 = *(void *)(v44 + 8);
        break;
      }
    }
  }
  uint64_t v49 = *(void *)(result + 368);
  uint64_t v50 = *(unsigned int *)(result + 384);
  if (!v50) {
    goto LABEL_69;
  }
  LODWORD(v51) = ((v43 >> 4) ^ (v43 >> 9)) & (v50 - 1);
  uint64_t v52 = (uint64_t *)(v49 + 16 * v51);
  uint64_t v53 = *v52;
  if (v43 != *v52)
  {
    int v54 = 1;
    while (v53 != -4096)
    {
      int v55 = v51 + v54++;
      uint64_t v51 = v55 & (v50 - 1);
      uint64_t v53 = *(void *)(v49 + 16 * v51);
      if (v43 == v53)
      {
        uint64_t v52 = (uint64_t *)(v49 + 16 * v51);
        goto LABEL_70;
      }
    }
LABEL_69:
    uint64_t v52 = (uint64_t *)(v49 + 16 * v50);
  }
LABEL_70:
  unint64_t v41 = v52 + 1;
LABEL_71:
  uint64_t v56 = 0;
  uint64_t v57 = *v41;
  unint64_t v58 = v40 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v59 = (void *)(v57 & 0xFFFFFFFFFFFFFFF8);
  unint64_t v60 = v4;
  while (1)
  {
    uint64_t v61 = v56;
    uint64_t v62 = (void *)v60;
    if (v59 == (void *)v58) {
      break;
    }
    unsigned __int8 v63 = (v5 != v7) | v56;
LABEL_76:
    uint64_t v64 = v59[2];
    if ((v60 == v15) | v61 & 1) {
      unint64_t v60 = 0;
    }
    int32x2_t result = v62 == (void *)v5;
    if (v64 != v60 || ((v62 == (void *)v5) & v63) != 0)
    {
      if (v60)
      {
        int32x2_t v65 = v6[46];
        int32x2_t result = v6[48].u32[0];
        if (result)
        {
          LODWORD(v66) = (result - 1) & ((v60 >> 4) ^ (v60 >> 9));
          uint64_t v67 = (uint64_t *)(*(void *)&v65 + 16 * v66);
          uint64_t v68 = *v67;
          if (v60 == *v67) {
            goto LABEL_94;
          }
          int v69 = 1;
          while (v68 != -4096)
          {
            int v70 = v66 + v69++;
            uint64_t v66 = v70 & (result - 1);
            uint64_t v68 = *(void *)(*(void *)&v65 + 16 * v66);
            if (v60 == v68)
            {
              uint64_t v67 = (uint64_t *)(*(void *)&v65 + 16 * v66);
              goto LABEL_94;
            }
          }
        }
        uint64_t v67 = (uint64_t *)(*(void *)&v65 + 16 * result);
LABEL_94:
        if (v67 != (uint64_t *)(*(void *)&v65 + 16 * result)) {
          goto LABEL_95;
        }
        uint64_t v56 = 1;
        unint64_t v60 = v5;
        if (v62 != (void *)v5)
        {
          unint64_t v60 = *v62 & 0xFFFFFFFFFFFFFFF8;
          if (!v60 || (uint64_t v56 = v61, (*(unsigned char *)v60 & 4) == 0))
          {
            uint64_t v56 = v61;
            if ((*(_WORD *)(v60 + 44) & 4) != 0)
            {
              do
                unint64_t v60 = *(void *)v60 & 0xFFFFFFFFFFFFFFF8;
              while ((*(_WORD *)(v60 + 44) & 4) != 0);
LABEL_111:
              uint64_t v56 = v61;
            }
          }
        }
      }
      else
      {
LABEL_95:
        uint64_t v59 = (void *)*v59;
        unint64_t v60 = (unint64_t)v62;
        uint64_t v56 = v61;
        if (v64)
        {
          int32x2_t v71 = v6[46];
          uint64_t v72 = v6[48].u32[0];
          if (!v72) {
            goto LABEL_108;
          }
          int32x2_t result = (v72 - 1) & ((v64 >> 4) ^ (v64 >> 9));
          int v73 = (uint64_t *)(*(void *)&v71 + 16 * result);
          uint64_t v74 = *v73;
          if (*v73 != v64)
          {
            int v75 = 1;
            while (v74 != -4096)
            {
              int v76 = result + v75++;
              int32x2_t result = v76 & (v72 - 1);
              uint64_t v74 = *(void *)(*(void *)&v71 + 16 * result);
              if (v74 == v64)
              {
                int v73 = (uint64_t *)(*(void *)&v71 + 16 * result);
                goto LABEL_109;
              }
            }
LABEL_108:
            int v73 = (uint64_t *)(*(void *)&v71 + 16 * v72);
          }
LABEL_109:
          uint64_t v77 = (uint64_t *)(*(void *)&v71 + 16 * v72);
          unint64_t v60 = (unint64_t)v62;
          uint64_t v56 = v61;
          if (v73 != v77)
          {
            unint64_t v78 = v73[1] & 0xFFFFFFFFFFFFFFF8;
            *int v73 = -8192;
            v6[47] = vadd_s32(v6[47], (int32x2_t)0x1FFFFFFFFLL);
            *(void *)(v78 + 16) = 0;
            unint64_t v60 = (unint64_t)v62;
            goto LABEL_111;
          }
        }
      }
    }
    else
    {
      uint64_t v59 = (void *)*v59;
      uint64_t v56 = 1;
      unint64_t v60 = v5;
      if (v62 != (void *)v5)
      {
        unint64_t v60 = *v62 & 0xFFFFFFFFFFFFFFF8;
        if (!v60 || (uint64_t v56 = v61, (*(unsigned char *)v60 & 4) == 0))
        {
          uint64_t v56 = v61;
          if ((*(_WORD *)(v60 + 44) & 4) != 0)
          {
            do
              unint64_t v60 = *(void *)v60 & 0xFFFFFFFFFFFFFFF8;
            while ((*(_WORD *)(v60 + 44) & 4) != 0);
            goto LABEL_111;
          }
        }
      }
    }
  }
  unsigned __int8 v63 = (v5 != v7) | v56;
  if (v60 != v5 || (v63 & 1) == 0) {
    goto LABEL_76;
  }
  while (v4 != v5)
  {
    unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
    if (!v4 || (*(unsigned char *)v4 & 4) == 0)
    {
      while ((*(_WORD *)(v4 + 44) & 4) != 0)
        unint64_t v4 = *(void *)v4 & 0xFFFFFFFFFFFFFFF8;
    }
    int v79 = **(unsigned __int16 **)(v4 + 16);
    if ((v79 - 13) >= 5 && v79 != 23)
    {
      int32x2_t v81 = v6[46];
      uint64_t v82 = v6[48].u32[0];
      if (!v82) {
        goto LABEL_127;
      }
      LODWORD(v83) = (v82 - 1) & ((v4 >> 4) ^ (v4 >> 9));
      int v84 = (uint64_t *)(*(void *)&v81 + 16 * v83);
      uint64_t v85 = *v84;
      if (v4 != *v84)
      {
        int v86 = 1;
        while (v85 != -4096)
        {
          int v87 = v83 + v86++;
          uint64_t v83 = v87 & (v82 - 1);
          uint64_t v85 = *(void *)(*(void *)&v81 + 16 * v83);
          if (v4 == v85)
          {
            int v84 = (uint64_t *)(*(void *)&v81 + 16 * v83);
            goto LABEL_128;
          }
        }
LABEL_127:
        int v84 = (uint64_t *)(*(void *)&v81 + 16 * v82);
      }
LABEL_128:
      if (v84 == (uint64_t *)(*(void *)&v81 + 16 * v82)) {
        int32x2_t result = sub_1CB914C88((uint64_t)v6, v4, 0);
      }
    }
  }
  return result;
}

void sub_1CC4740BC(llvm *a1, llvm::PassRegistry *a2)
{
}

void llvm::SpillPlacement::runOnMachineFunction(llvm::SpillPlacement *this, llvm::MachineFunction *a2)
{
  *((void *)this + 31) = a2;
  uint64_t v3 = (uint64_t *)*((void *)this + 1);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::EdgeBundles::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  *((void *)this + 32) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::EdgeBundles::ID);
  uint64_t v7 = (uint64_t *)*((void *)this + 1);
  uint64_t v8 = *v7;
  uint64_t v9 = v7[1];
  if (v8 == v9)
  {
LABEL_9:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::MachineLoopInfo::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_9;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  *((void *)this + 33) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::MachineLoopInfo::ID);
  operator new[]();
}

uint64_t llvm::SpillPlacement::setThreshold(uint64_t result, void *a2)
{
  unint64_t v2 = ((*a2 >> 12) & 1) + (*a2 >> 13);
  if (v2 <= 1) {
    unint64_t v2 = 1;
  }
  *(void *)(result + 472) = v2;
  return result;
}

uint64_t llvm::SpillPlacement::releaseMemory(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)(this + 280);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 112 * v3;
      do
      {
        uint64_t v5 = *(void **)(v2 + v4 - 88);
        if ((void *)(v2 + v4 - 72) != v5) {
          free(v5);
        }
        v4 -= 112;
      }
      while (v4);
    }
    this = MEMORY[0x1D25D9CB0](v2 - 16, 0x1080C8068569297);
  }
  *(void *)(v1 + 280) = 0;
  *(_DWORD *)(v1 + 488) = 0;
  return this;
}

uint64_t llvm::SpillPlacement::activate(uint64_t this, unsigned int a2)
{
  uint64_t v2 = *(void *)(this + 528);
  unsigned int v3 = *(unsigned __int8 *)(v2 + a2);
  unsigned int v4 = *(_DWORD *)(this + 488);
  if (v4 <= v3) {
    goto LABEL_4;
  }
  while (*(_DWORD *)(*(void *)(this + 480) + 4 * v3) != a2)
  {
    v3 += 256;
    if (v3 >= v4) {
      goto LABEL_4;
    }
  }
  if (v4 == v3)
  {
LABEL_4:
    *(unsigned char *)(v2 + a2) = v4;
    unsigned int v5 = *(_DWORD *)(this + 488);
    if (v5 >= *(_DWORD *)(this + 492)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)(this + 480) + 4 * v5) = a2;
    ++*(_DWORD *)(this + 488);
  }
  uint64_t v6 = a2 >> 6;
  uint64_t v7 = **(void **)(this + 288);
  uint64_t v8 = *(void *)(v7 + 8 * v6);
  if ((v8 & (1 << a2)) == 0)
  {
    *(void *)(v7 + 8 * v6) = v8 | (1 << a2);
    uint64_t v9 = *(void *)(this + 280);
    uint64_t v10 = v9 + 112 * a2;
    *(void *)uint64_t v10 = 0;
    *(void *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(void *)(v10 + 104) = *(void *)(this + 472);
    *(_DWORD *)(v10 + 32) = 0;
    if (*(_DWORD *)(*(void *)(*(void *)(this + 256) + 312) + 48 * a2 + 8) >= 0x65u)
    {
      *(void *)(v9 + 112 * a2 + 8) = 0;
      uint64_t v11 = *(void *)(*(void *)(this + 272) + 248);
      if (v11) {
        uint64_t v11 = *(void *)(*(void *)(v11 + 8) + 16) >> 4;
      }
      *(void *)(*(void *)(this + 280) + 112 * a2) = v11;
    }
  }
  return this;
}

void *llvm::SpillPlacement::addConstraints(void *this, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = this;
    uint64_t v4 = 8 * a3;
    unsigned int v5 = (unsigned __int16 *)(a2 + 4);
    do
    {
      uint64_t v6 = *((unsigned int *)v5 - 1);
      uint64_t v7 = *(void *)(v3[49] + 8 * v6);
      unsigned int v8 = *v5;
      if (*v5)
      {
        unsigned int v9 = *(_DWORD *)(*(void *)(v3[32] + 256) + 4 * (2 * v6));
        this = (void *)llvm::SpillPlacement::activate((uint64_t)v3, v9);
        uint64_t v10 = v3[35];
        uint64_t v11 = (uint64_t *)(v10 + 112 * v9);
        unsigned int v8 = *v5;
        int v12 = *v5;
        switch(v12)
        {
          case 4:
            *uint64_t v11 = -1;
            break;
          case 1:
            uint64_t v13 = v10 + 112 * v9;
            uint64_t v14 = *(void *)(v13 + 8);
            BOOL v15 = __CFADD__(v7, v14);
            uint64_t v16 = v7 + v14;
            if (v15) {
              uint64_t v16 = -1;
            }
            *(void *)(v13 + 8) = v16;
            break;
          case 2:
            uint64_t v24 = v7 + *v11;
            if (__CFADD__(v7, *v11)) {
              uint64_t v24 = -1;
            }
            *uint64_t v11 = v24;
            break;
          default:
            goto LABEL_12;
        }
        unsigned int v8 = *v5;
      }
LABEL_12:
      if (v8 >= 0x100)
      {
        unsigned int v17 = *(_DWORD *)(*(void *)(v3[32] + 256) + 4 * ((2 * *((_DWORD *)v5 - 1)) | 1u));
        this = (void *)llvm::SpillPlacement::activate((uint64_t)v3, v17);
        uint64_t v18 = v3[35];
        unsigned int v19 = (uint64_t *)(v18 + 112 * v17);
        int v20 = *((unsigned __int8 *)v5 + 1);
        switch(v20)
        {
          case 4:
            *unsigned int v19 = -1;
            break;
          case 1:
            uint64_t v21 = v18 + 112 * v17;
            uint64_t v22 = *(void *)(v21 + 8);
            BOOL v15 = __CFADD__(v7, v22);
            uint64_t v23 = v7 + v22;
            if (v15) {
              uint64_t v23 = -1;
            }
            *(void *)(v21 + 8) = v23;
            break;
          case 2:
            uint64_t v25 = v7 + *v19;
            if (__CFADD__(v7, *v19)) {
              uint64_t v25 = -1;
            }
            *unsigned int v19 = v25;
            break;
        }
      }
      v5 += 4;
      v4 -= 8;
    }
    while (v4);
  }
  return this;
}

void *llvm::SpillPlacement::addPrefSpill(void *this, unsigned int *a2, uint64_t a3, int a4)
{
  if (a3)
  {
    uint64_t v6 = this;
    uint64_t v7 = 4 * a3;
    do
    {
      unsigned int v9 = *a2++;
      unsigned int v8 = v9;
      uint64_t v10 = *(void *)(v6[49] + 8 * v9);
      uint64_t v11 = 2 * v10;
      if (__CFADD__(v10, v10)) {
        uint64_t v11 = -1;
      }
      if (a4) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v10;
      }
      uint64_t v13 = *(void *)(v6[32] + 256);
      unsigned int v14 = *(_DWORD *)(v13 + 8 * v8);
      unsigned int v15 = *(_DWORD *)(v13 + 4 * ((2 * v8) | 1));
      llvm::SpillPlacement::activate((uint64_t)v6, v14);
      this = (void *)llvm::SpillPlacement::activate((uint64_t)v6, v15);
      uint64_t v16 = v6[35];
      uint64_t v17 = *(void *)(v16 + 112 * v14);
      BOOL v18 = __CFADD__(v12, v17);
      uint64_t v19 = v12 + v17;
      if (v18) {
        uint64_t v19 = -1;
      }
      *(void *)(v16 + 112 * v14) = v19;
      uint64_t v20 = *(void *)(v16 + 112 * v15);
      BOOL v18 = __CFADD__(v12, v20);
      uint64_t v21 = v12 + v20;
      if (v18) {
        uint64_t v21 = -1;
      }
      *(void *)(v16 + 112 * v15) = v21;
      v7 -= 4;
    }
    while (v7);
  }
  return this;
}

void *llvm::SpillPlacement::addLinks(void *this, unsigned int *a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v3 = a2;
    uint64_t v4 = this;
    unsigned int v5 = &a2[a3];
    do
    {
      uint64_t v6 = *v3;
      uint64_t v7 = *(void *)(v4[32] + 256);
      uint64_t v8 = *(unsigned int *)(v7 + 4 * (2 * v6));
      uint64_t v9 = *(unsigned int *)(v7 + 4 * ((2 * v6) | 1u));
      if (v8 != v9)
      {
        llvm::SpillPlacement::activate((uint64_t)v4, *(_DWORD *)(v7 + 4 * (2 * v6)));
        this = (void *)llvm::SpillPlacement::activate((uint64_t)v4, v9);
        uint64_t v10 = *(void *)(v4[49] + 8 * v6);
        uint64_t v11 = v4[35];
        uint64_t v12 = v11 + 112 * v8;
        uint64_t v15 = *(void *)(v12 + 24);
        uint64_t v13 = v12 + 24;
        uint64_t v14 = v15;
        uint64_t v16 = *(void *)(v13 + 80);
        BOOL v17 = __CFADD__(v10, v16);
        uint64_t v18 = v10 + v16;
        if (v17) {
          uint64_t v18 = -1;
        }
        *(void *)(v13 + 80) = v18;
        uint64_t v19 = *(unsigned int *)(v13 + 8);
        if (v19)
        {
          uint64_t v20 = 16 * v19;
          uint64_t v21 = v14;
          while (*(_DWORD *)(v21 + 8) != v9)
          {
            v21 += 16;
            v20 -= 16;
            if (!v20) {
              goto LABEL_11;
            }
          }
          uint64_t v33 = v10 + *(void *)v21;
          if (__CFADD__(v10, *(void *)v21)) {
            uint64_t v33 = -1;
          }
          *(void *)uint64_t v21 = v33;
        }
        else
        {
LABEL_11:
          if (v19 >= *(_DWORD *)(v11 + 112 * v8 + 36)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v22 = (void *)(v14 + 16 * v19);
          *uint64_t v22 = v10;
          v22[1] = v9;
          ++*(_DWORD *)(v13 + 8);
          uint64_t v11 = v4[35];
        }
        uint64_t v23 = v11 + 112 * v9;
        uint64_t v26 = *(void *)(v23 + 24);
        uint64_t v24 = v23 + 24;
        uint64_t v25 = v26;
        uint64_t v27 = *(void *)(v24 + 80);
        BOOL v17 = __CFADD__(v10, v27);
        uint64_t v28 = v10 + v27;
        if (v17) {
          uint64_t v28 = -1;
        }
        *(void *)(v24 + 80) = v28;
        uint64_t v29 = *(unsigned int *)(v24 + 8);
        if (v29)
        {
          uint64_t v30 = 16 * v29;
          uint64_t v31 = v25;
          while (*(_DWORD *)(v31 + 8) != v8)
          {
            v31 += 16;
            v30 -= 16;
            if (!v30) {
              goto LABEL_20;
            }
          }
          BOOL v17 = __CFADD__(v10, *(void *)v31);
          uint64_t v34 = v10 + *(void *)v31;
          if (v17) {
            uint64_t v34 = -1;
          }
          *(void *)uint64_t v31 = v34;
        }
        else
        {
LABEL_20:
          if (v29 >= *(_DWORD *)(v11 + 112 * v9 + 36)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v32 = (void *)(v25 + 16 * v29);
          *uint64_t v32 = v10;
          v32[1] = v8;
          ++*(_DWORD *)(v24 + 8);
        }
      }
      ++v3;
    }
    while (v3 != v5);
  }
  return this;
}

BOOL llvm::SpillPlacement::scanActiveBundles(llvm::SpillPlacement *this)
{
  *((_DWORD *)this + 88) = 0;
  uint64_t v1 = *((void *)this + 36);
  int v2 = *(_DWORD *)(v1 + 64);
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  int v5 = -v2;
  int v6 = v2 - 1;
  uint64_t v7 = *(uint64_t **)v1;
  unint64_t v8 = 0xFFFFFFFFFFFFFFFFLL >> v5;
  uint64_t v9 = v6 & 0xFFFFFFC0;
  while (1)
  {
    uint64_t v11 = *v7++;
    uint64_t v10 = v11;
    unint64_t v12 = v9 == v4 ? v8 : -1;
    unint64_t v13 = v12 & v10;
    if (v13) {
      break;
    }
    v4 += 64;
    if (v9 + 64 == v4) {
      return 0;
    }
  }
  unint64_t v14 = __clz(__rbit64(v13));
  uint64_t v15 = v14 + v4;
  if (v14 + v4 == -1) {
    return 0;
  }
  unsigned int v16 = v14 + v4;
  do
  {
    llvm::SpillPlacement::update(this, v16);
    uint64_t v17 = *((void *)this + 35);
    uint64_t v18 = (unint64_t *)(v17 + 112 * v15);
    unint64_t v19 = v18[13];
    unint64_t v20 = *v18;
    uint64_t v21 = *(void *)(v17 + 112 * v15 + 8);
    BOOL v22 = __CFADD__(v19, v21);
    unint64_t v23 = v19 + v21;
    if (v22) {
      unint64_t v23 = -1;
    }
    if (v20 < v23 && *(int *)(v17 + 112 * v15 + 16) >= 1)
    {
      unint64_t v24 = *((unsigned int *)this + 88);
      if (v24 >= *((unsigned int *)this + 89)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*((void *)this + 43) + 4 * v24) = v16;
      ++*((_DWORD *)this + 88);
    }
    unsigned int v25 = v16 + 1;
    int v26 = *(_DWORD *)(v1 + 64);
    if (v16 + 1 == v26) {
      break;
    }
    unsigned int v27 = v25 >> 6;
    unsigned int v28 = v26 - 1;
    if (v25 >> 6 > (v26 - 1) >> 6) {
      break;
    }
    uint64_t v29 = 0;
    uint64_t v30 = v28 >> 6;
    int v32 = v25 & 0x3F;
    BOOL v31 = v32 == 0;
    unint64_t v33 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v32;
    uint64_t v34 = v31 ? -1 : ~v33;
    unint64_t v35 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v28;
    unsigned int v36 = v27 << 6;
    uint64_t v37 = v30 - v27;
    uint64_t v38 = *(void *)v1 + 8 * v27;
    while (1)
    {
      uint64_t v39 = v29 ? -1 : v34;
      unint64_t v40 = v37 == v29 ? v35 : -1;
      unint64_t v41 = v39 & v40 & *(void *)(v38 + 8 * v29);
      if (v41) {
        break;
      }
      v36 += 64;
      if (v37 + 1 == ++v29) {
        return *((_DWORD *)this + 88) != 0;
      }
    }
    unsigned int v16 = __clz(__rbit64(v41)) + v36;
    uint64_t v15 = v16;
  }
  while (v16 != -1);
  return *((_DWORD *)this + 88) != 0;
}

uint64_t llvm::SpillPlacement::update(llvm::SpillPlacement *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 35);
  uint64_t v3 = v2 + 112 * a2;
  unint64_t v5 = *(void *)v3;
  unint64_t v4 = *(void *)(v3 + 8);
  unint64_t v31 = v4;
  unint64_t v32 = v5;
  uint64_t v6 = *(void *)(v3 + 24);
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  if (v7)
  {
    uint64_t v8 = 16 * v7;
    uint64_t v9 = (unsigned int *)(v6 + 8);
    while (1)
    {
      int v10 = *(_DWORD *)(v2 + 112 * *v9 + 16);
      if (v10 == 1) {
        break;
      }
      if (v10 == -1)
      {
        uint64_t v11 = (uint64_t *)&v32;
        goto LABEL_5;
      }
LABEL_9:
      v9 += 4;
      v8 -= 16;
      if (!v8)
      {
        unint64_t v4 = v31;
        unint64_t v5 = v32;
        goto LABEL_13;
      }
    }
    uint64_t v11 = (uint64_t *)&v31;
LABEL_5:
    uint64_t v12 = *((void *)v9 - 1);
    BOOL v13 = __CFADD__(v12, *v11);
    uint64_t v14 = v12 + *v11;
    if (v13) {
      uint64_t v14 = -1;
    }
    *uint64_t v11 = v14;
    goto LABEL_9;
  }
LABEL_13:
  uint64_t v15 = v2 + 112 * a2;
  int v18 = *(_DWORD *)(v15 + 16);
  uint64_t v17 = (BOOL *)(v15 + 16);
  int v16 = v18;
  uint64_t v19 = *((void *)this + 59);
  unint64_t v20 = v19 + v4;
  if (__CFADD__(v19, v4)) {
    unint64_t v20 = -1;
  }
  if (v5 >= v20)
  {
    *uint64_t v17 = -1;
    if (v16 <= 0) {
      return 0;
    }
  }
  else
  {
    BOOL v13 = __CFADD__(v19, v5);
    unint64_t v21 = v19 + v5;
    if (v13) {
      unint64_t v21 = -1;
    }
    BOOL v22 = v4 >= v21;
    *uint64_t v17 = v22;
    if (v16 > 0 == v22) {
      return 0;
    }
  }
  if (!v7) {
    return 1;
  }
  uint64_t v25 = v6 + 16 * v7;
  do
  {
    uint64_t v26 = *(unsigned int *)(v6 + 8);
    if (*v17 != *(_DWORD *)(v2 + 112 * v26 + 16))
    {
      uint64_t v27 = *((void *)this + 66);
      unsigned int v28 = *(unsigned __int8 *)(v27 + v26);
      unsigned int v29 = *((_DWORD *)this + 122);
      if (v29 <= v28) {
        goto LABEL_33;
      }
      while (*(_DWORD *)(*((void *)this + 60) + 4 * v28) != v26)
      {
        v28 += 256;
        if (v28 >= v29) {
          goto LABEL_33;
        }
      }
      if (v29 == v28)
      {
LABEL_33:
        *(unsigned char *)(v27 + v26) = v29;
        unint64_t v30 = *((unsigned int *)this + 122);
        if (v30 >= *((unsigned int *)this + 123)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*((void *)this + 60) + 4 * v30) = v26;
        ++*((_DWORD *)this + 122);
      }
    }
    v6 += 16;
    uint64_t v23 = 1;
  }
  while (v6 != v25);
  return v23;
}

uint64_t llvm::SpillPlacement::iterate(uint64_t this)
{
  *(_DWORD *)(this + 352) = 0;
  int v1 = *(_DWORD *)(*(void *)(this + 256) + 304);
  if (10 * v1)
  {
    uint64_t v2 = this;
    int v3 = -10 * v1;
    do
    {
      uint64_t v4 = *(unsigned int *)(v2 + 488);
      if (!v4) {
        break;
      }
      unsigned int v5 = *(_DWORD *)(*(void *)(v2 + 480) + 4 * v4 - 4);
      *(_DWORD *)(v2 + 488) = v4 - 1;
      this = llvm::SpillPlacement::update((llvm::SpillPlacement *)v2, v5);
      if (this && *(int *)(*(void *)(v2 + 280) + 112 * v5 + 16) >= 1)
      {
        unint64_t v6 = *(unsigned int *)(v2 + 352);
        if (v6 >= *(unsigned int *)(v2 + 356)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)(v2 + 344) + 4 * v6) = v5;
        ++*(_DWORD *)(v2 + 352);
      }
    }
    while (!__CFADD__(v3++, 1));
  }
  return this;
}

void llvm::SpillPlacement::prepare(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  *(void *)(a1 + 288) = a2;
  *(_DWORD *)(a2 + 8) = 0;
  int v3 = *(_DWORD *)(*(void *)(a1 + 256) + 304);
  *(_DWORD *)(a2 + 64) = v3;
  if ((v3 + 63) < 0x40)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v4 = (v3 + 63) >> 6;
    if (v4 > *(_DWORD *)(a2 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    bzero(*(void **)a2, 8 * v4);
    uint64_t v5 = v4;
    *(_DWORD *)(a2 + 8) = v4;
  }
  if ((v3 & 0x3F) != 0) {
    *(void *)(*(void *)a2 + 8 * v5 - 8) &= ~(-1 << (v3 & 0x3F));
  }
}

uint64_t llvm::SpillPlacement::finish(llvm::SpillPlacement *this)
{
  uint64_t v1 = *((void *)this + 36);
  int v2 = *(_DWORD *)(v1 + 64);
  if (!v2) {
    goto LABEL_29;
  }
  uint64_t v3 = 0;
  uint64_t v4 = (v2 - 1) >> 6;
  uint64_t v5 = *(uint64_t **)v1;
  uint64_t v6 = v4 << 6;
  uint64_t v7 = v5;
  while (1)
  {
    uint64_t v9 = *v7++;
    uint64_t v8 = v9;
    unint64_t v10 = v6 == v3 ? 0xFFFFFFFFFFFFFFFFLL >> -(char)v2 : -1;
    unint64_t v11 = v10 & v8;
    if (v11) {
      break;
    }
    v3 += 64;
    if (v6 + 64 == v3) {
      goto LABEL_29;
    }
  }
  unint64_t v12 = __clz(__rbit64(v11));
  unint64_t v13 = v12 + v3;
  if (v12 + v3 == -1)
  {
LABEL_29:
    char v16 = 1;
  }
  else
  {
    uint64_t v14 = *((void *)this + 35);
    LODWORD(v15) = v12 + v3;
    char v16 = 1;
    do
    {
      if (*(int *)(v14 + 112 * v13 + 16) <= 0)
      {
        char v16 = 0;
        *(uint64_t *)((char *)v5 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << v13);
      }
      unsigned int v17 = v15 + 1;
      if (v17 == v2) {
        break;
      }
      unsigned int v18 = v17 >> 6;
      if (v17 >> 6 > v4) {
        break;
      }
      uint64_t v19 = 0;
      int v21 = v17 & 0x3F;
      BOOL v20 = v21 == 0;
      unint64_t v22 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v21;
      uint64_t v23 = v20 ? -1 : ~v22;
      unint64_t v24 = (unint64_t)v18 << 6;
      uint64_t v25 = v4 - v18;
      uint64_t v26 = &v5[v18];
      while (1)
      {
        uint64_t v27 = v19 ? -1 : v23;
        unint64_t v28 = v25 == v19 ? 0xFFFFFFFFFFFFFFFFLL >> -(char)v2 : -1;
        unint64_t v29 = v27 & v28 & v26[v19];
        if (v29) {
          break;
        }
        v24 += 64;
        if (v25 + 1 == ++v19) {
          goto LABEL_27;
        }
      }
      unint64_t v15 = __clz(__rbit64(v29)) + v24;
      unint64_t v13 = v15;
    }
    while (v15 != -1);
  }
LABEL_27:
  *((void *)this + 36) = 0;
  return v16 & 1;
}

llvm::raw_ostream *llvm::SpillPlacement::BlockConstraint::print(llvm::SpillPlacement::BlockConstraint *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = llvm::dbgs(this);
  uint64_t v4 = v3;
  uint64_t v5 = (unsigned char *)*((void *)v3 + 4);
  if (*((unsigned char **)v3 + 3) == v5)
  {
    llvm::raw_ostream::write(v3, "{", 1uLL);
  }
  else
  {
    *uint64_t v5 = 123;
    ++*((void *)v3 + 4);
  }
  sub_1CD098D14(v4, *(unsigned int *)this, 0, 0, 0);
  uint64_t v6 = (_WORD *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v6 > 1uLL)
  {
    *uint64_t v6 = 8236;
    *((void *)v4 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v4, ", ", 2uLL);
  }
  uint64_t v7 = *((char *)this + 4);
  size_t v8 = qword_1CFAC7418[v7];
  uint64_t v9 = off_1E6830590[v7];
  unint64_t v10 = (void *)*((void *)v4 + 4);
  if (v8 <= *((void *)v4 + 3) - (void)v10)
  {
    memcpy(v10, v9, v8);
    unint64_t v11 = (_WORD *)(*((void *)v4 + 4) + v8);
    *((void *)v4 + 4) = v11;
  }
  else
  {
    llvm::raw_ostream::write(v4, v9, v8);
    unint64_t v11 = (_WORD *)*((void *)v4 + 4);
  }
  if (*((void *)v4 + 3) - (void)v11 > 1uLL)
  {
    *unint64_t v11 = 8236;
    *((void *)v4 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v4, ", ", 2uLL);
  }
  uint64_t v12 = *((char *)this + 5);
  size_t v13 = qword_1CFAC7418[v12];
  uint64_t v14 = off_1E6830590[v12];
  unint64_t v15 = (void *)*((void *)v4 + 4);
  if (v13 <= *((void *)v4 + 3) - (void)v15)
  {
    memcpy(v15, v14, v13);
    char v16 = (_WORD *)(*((void *)v4 + 4) + v13);
    *((void *)v4 + 4) = v16;
  }
  else
  {
    llvm::raw_ostream::write(v4, v14, v13);
    char v16 = (_WORD *)*((void *)v4 + 4);
  }
  if (*((void *)v4 + 3) - (void)v16 > 1uLL)
  {
    _WORD *v16 = 8236;
    unsigned int v17 = (void *)(*((void *)v4 + 4) + 2);
    *((void *)v4 + 4) = v17;
  }
  else
  {
    llvm::raw_ostream::write(v4, ", ", 2uLL);
    unsigned int v17 = (void *)*((void *)v4 + 4);
  }
  if (*((unsigned char *)this + 6)) {
    unsigned int v18 = "changes";
  }
  else {
    unsigned int v18 = "no change";
  }
  if (*((unsigned char *)this + 6)) {
    size_t v19 = 7;
  }
  else {
    size_t v19 = 9;
  }
  if (v19 <= *((void *)v4 + 3) - (void)v17)
  {
    int32x2_t result = (llvm::raw_ostream *)memcpy(v17, v18, v19);
    int v21 = (unsigned char *)(*((void *)v4 + 4) + v19);
    *((void *)v4 + 4) = v21;
  }
  else
  {
    int32x2_t result = llvm::raw_ostream::write(v4, v18, v19);
    int v21 = (unsigned char *)*((void *)v4 + 4);
  }
  if (*((unsigned char **)v4 + 3) == v21)
  {
    return llvm::raw_ostream::write(v4, "}", 1uLL);
  }
  else
  {
    *int v21 = 125;
    ++*((void *)v4 + 4);
  }
  return result;
}

llvm *llvm::SpillPlacement::BlockConstraint::dump(llvm::SpillPlacement::BlockConstraint *this)
{
  llvm::dbgs(this);
  uint64_t v3 = llvm::SpillPlacement::BlockConstraint::print(this, v2);
  int32x2_t result = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v5)
  {
    return llvm::raw_ostream::write(result, "\n", 1uLL);
  }
  else
  {
    *uint64_t v5 = 10;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t sub_1CC4754EC(void *a1, uint64_t a2, llvm::MachineBasicBlock *this)
{
  v55[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((unsigned int *)this + 6);
  uint64_t v7 = a1[1];
  uint64_t v8 = v7 + 16 * v6;
  uint64_t v9 = *(void *)(*(void *)(*(void *)(*a1 + 288) + 392) + 16 * v6 + 8);
  unsigned int v54 = 0;
  unint64_t v10 = (uint64_t *)*((void *)this + 11);
  unint64_t v11 = (uint64_t *)*((void *)this + 12);
  if (v10 != v11)
  {
    int v12 = 0;
    char v13 = 0;
    while (!*(unsigned char *)(*v10 + 184))
    {
      if (*(unsigned char *)(*v10 + 202))
      {
        uint64_t v50 = *v10;
        uint64_t v51 = v10;
        uint64_t v52 = v11;
        goto LABEL_34;
      }
LABEL_5:
      if (++v10 == v11) {
        goto LABEL_6;
      }
    }
    uint64_t v50 = *v10;
    uint64_t v51 = v10;
    uint64_t v52 = v11;
    char v13 = 1;
LABEL_34:
    if (v12) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    v55[0] = v50;
    int v12 = ++v54;
    unint64_t v10 = v51;
    unint64_t v11 = v52;
    goto LABEL_5;
  }
  char v13 = 0;
LABEL_6:
  if (*(void *)v8 > 7uLL) {
    goto LABEL_57;
  }
  unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator(this);
  unint64_t v15 = (void *)((char *)this + 48);
  uint64_t v16 = v9;
  if (v15 != (void *)FirstTerminator)
  {
    __int16 v17 = *(_WORD *)(FirstTerminator + 44);
    unint64_t v18 = FirstTerminator;
    if ((v17 & 4) != 0)
    {
      unint64_t v18 = FirstTerminator;
      do
        unint64_t v18 = *(void *)v18 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v18 + 44) & 4) != 0);
    }
    uint64_t v19 = *(void *)(*a1 + 288);
    if ((v17 & 8) != 0)
    {
      do
        unint64_t FirstTerminator = *(void *)(FirstTerminator + 8);
      while ((*(_WORD *)(FirstTerminator + 44) & 8) != 0);
    }
    uint64_t v20 = *(void *)(FirstTerminator + 8);
    if (v18 != v20)
    {
      while (1)
      {
        unsigned int v21 = **(unsigned __int16 **)(v18 + 16);
        BOOL v22 = v21 > 0x17;
        int v23 = (1 << v21) & 0x83E000;
        if (v22 || v23 == 0) {
          break;
        }
        unint64_t v18 = *(void *)(v18 + 8);
        if (v18 == v20)
        {
          unint64_t v18 = *(void *)(FirstTerminator + 8);
          break;
        }
      }
    }
    uint64_t v25 = *(void *)(v19 + 368);
    uint64_t v26 = *(unsigned int *)(v19 + 384);
    if (v26)
    {
      LODWORD(v27) = ((v18 >> 4) ^ (v18 >> 9)) & (v26 - 1);
      unint64_t v28 = (uint64_t *)(v25 + 16 * v27);
      uint64_t v29 = *v28;
      if (v18 == *v28)
      {
LABEL_18:
        uint64_t v16 = v28[1];
        goto LABEL_19;
      }
      int v31 = 1;
      while (v29 != -4096)
      {
        int v32 = v27 + v31++;
        uint64_t v27 = v32 & (v26 - 1);
        uint64_t v29 = *(void *)(v25 + 16 * v27);
        if (v18 == v29)
        {
          unint64_t v28 = (uint64_t *)(v25 + 16 * v27);
          goto LABEL_18;
        }
      }
    }
    unint64_t v28 = (uint64_t *)(v25 + 16 * v26);
    goto LABEL_18;
  }
LABEL_19:
  *(void *)uint64_t v8 = v16;
  if (!v54) {
    return v16;
  }
  uint64_t v53 = v15;
  unint64_t v33 = *v15 & 0xFFFFFFFFFFFFFFF8;
  if (!v33 || (*(unsigned char *)v33 & 4) == 0)
  {
    while ((*(_WORD *)(v33 + 44) & 4) != 0)
      unint64_t v33 = *(void *)v33 & 0xFFFFFFFFFFFFFFF8;
  }
  while ((void *)v33 != v53)
  {
    if (v13)
    {
      if ((*(_WORD *)(v33 + 44) & 0xC) != 0 && (*(_WORD *)(v33 + 44) & 4) == 0)
      {
        if (llvm::MachineInstr::hasPropertyInBundle(v33, 128, 1)) {
          goto LABEL_65;
        }
      }
      else if ((*(unsigned char *)(*(void *)(v33 + 16) + 8) & 0x80) != 0)
      {
        goto LABEL_65;
      }
    }
    if (**(_WORD **)(v33 + 16) == 2)
    {
LABEL_65:
      *(void *)(v7 + 16 * v6 + 8) = sub_1CBB24CA0(*(void *)(*a1 + 288), v33, 0);
      break;
    }
    unint64_t v33 = *(void *)v33 & 0xFFFFFFFFFFFFFFF8;
    if (!v33 || (*(unsigned char *)v33 & 4) == 0)
    {
      while ((*(_WORD *)(v33 + 44) & 4) != 0)
        unint64_t v33 = *(void *)v33 & 0xFFFFFFFFFFFFFFF8;
    }
  }
LABEL_57:
  uint64_t v35 = v7 + 16 * v6;
  unint64_t v37 = *(void *)(v35 + 8);
  unsigned int v36 = (uint64_t *)(v35 + 8);
  if (v37 < 8 || !v54) {
    return *(void *)v8;
  }
  uint64_t v38 = v55;
  uint64_t v39 = *(void *)(*(void *)(*a1 + 288) + 392);
  unint64_t v40 = *(void **)a2;
  unsigned int v41 = *(_DWORD *)(a2 + 8);
  uint64_t v42 = 8 * v54;
  while (!sub_1CC477B90(v40, v41, *(void *)(v39 + 16 * *(unsigned int *)(*v38 + 24))))
  {
    ++v38;
    v42 -= 8;
    if (!v42) {
      return *(void *)v8;
    }
  }
  uint64_t v43 = sub_1CC39166C(a2, v9);
  if (!v43) {
    return *(void *)v8;
  }
  uint64_t v44 = *(void *)(v43 + 8);
  uint64_t v16 = *v36;
  unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v46 = *v36 & 0xFFFFFFFFFFFFFFF8;
  BOOL v47 = (unint64_t)*v36 >= 8 && v45 == v46;
  if (!v47 || (uint64_t v49 = *(void *)(v45 + 16)) == 0 || **(_WORD **)(v49 + 16) != 31)
  {
    unsigned int v48 = *(_DWORD *)(v45 + 24);
    if (v48 >= *(_DWORD *)(v46 + 24)
      && (v48 | (v44 >> 1) & 3) < (*(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24) | (v9 >> 1) & 3))
    {
      return *(void *)v8;
    }
  }
  return v16;
}

unsigned int *sub_1CC475930(void *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = a3[6];
  uint64_t v5 = a1[1];
  unint64_t v6 = *(void *)(v5 + 16 * v4);
  if (v6 < 8 || *(void *)(v5 + 16 * v4 + 8) >= 8uLL)
  {
    uint64_t v8 = a3;
    uint64_t v9 = v3;
    unint64_t v6 = sub_1CC4754EC(v3, a2, (llvm::MachineBasicBlock *)a3);
    a3 = v8;
    uint64_t v3 = v9;
    uint64_t v4 = v8[6];
  }
  if (v6 == *(void *)(*(void *)(*(void *)(*v3 + 288) + 392) + 16 * v4 + 8)) {
    return a3 + 12;
  }
  if (v6 < 8) {
    return 0;
  }
  return *(unsigned int **)((v6 & 0xFFFFFFFFFFFFFFF8) + 16);
}

void *sub_1CC4759CC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a2 + 272);
  *a1 = v6;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = (*(uint64_t (**)(void))(**(void **)(v6 + 16) + 104))(*(void *)(v6 + 16));
  a1[5] = 0;
  unint64_t v7 = *(void *)(*a1 + 112) - *(void *)(*a1 + 104);
  a1[6] = a3;
  a1[7] = a1 + 9;
  a1[8] = 0x800000000;
  sub_1CC47EBA8((uint64_t)(a1 + 7), (v7 >> 3), 0, 0);
  a1[25] = a1 + 27;
  a1[26] = 0x800000000;
  a1[35] = a1 + 37;
  a1[36] = 0x800000000;
  a1[78] = a1 + 80;
  a1[79] = 0x600000000;
  *((_DWORD *)a1 + 172) = 0;
  return a1;
}

void sub_1CC475A9C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(unsigned int *)(v2 + 72);
  if (v3)
  {
    uint64_t v4 = *(void *)(v2 + 64);
    uint64_t v5 = 8 * v3;
    do
    {
      unint64_t v6 = *(void *)(*(void *)v4 + 8);
      if (v6 >= 8 && (*(void *)(*(void *)v4 + 8) & 6) != 0)
      {
        unint64_t v8 = *(unsigned int *)(a1 + 208);
        if (v8 >= *(unsigned int *)(a1 + 212)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(a1 + 200) + 8 * v8) = v6;
        ++*(_DWORD *)(a1 + 208);
      }
      v4 += 8;
      v5 -= 8;
    }
    while (v5);
    uint64_t v2 = *(void *)(a1 + 40);
  }
  uint64_t v9 = *(void *)(*(void *)a1 + 40);
  uint64_t v10 = *(unsigned int *)(v2 + 112);
  if ((v10 & 0x80000000) != 0) {
    unint64_t v11 = (int **)(*(void *)(v9 + 24) + 16 * (v10 & 0x7FFFFFFF) + 8);
  }
  else {
    unint64_t v11 = (int **)(*(void *)(v9 + 272) + 8 * v10);
  }
  int v12 = *v11;
  if (!*v11) {
    goto LABEL_16;
  }
  while (1)
  {
    int v13 = *v12;
    if ((*v12 & 0x81000000) == 0) {
      break;
    }
    int v12 = (int *)*((void *)v12 + 3);
    if (!v12) {
      goto LABEL_16;
    }
  }
LABEL_28:
  if ((v13 & 0x10000000) != 0) {
    goto LABEL_41;
  }
  unint64_t v24 = *((void *)v12 + 1);
  __int16 v25 = *(_WORD *)(v24 + 44);
  unint64_t v26 = v24;
  if ((v25 & 4) != 0)
  {
    do
      unint64_t v26 = *(void *)v26 & 0xFFFFFFFFFFFFFFF8;
    while ((*(_WORD *)(v26 + 44) & 4) != 0);
  }
  if ((v25 & 8) != 0)
  {
    do
      unint64_t v24 = *(void *)(v24 + 8);
    while ((*(_WORD *)(v24 + 44) & 8) != 0);
  }
  unint64_t v27 = *(void *)(v24 + 8);
  if (v26 != v27)
  {
    while (1)
    {
      unsigned int v28 = **(unsigned __int16 **)(v26 + 16);
      BOOL v29 = v28 > 0x17;
      int v30 = (1 << v28) & 0x83E000;
      if (v29 || v30 == 0) {
        break;
      }
      unint64_t v26 = *(void *)(v26 + 8);
      if (v26 == v27)
      {
        unint64_t v26 = v27;
        break;
      }
    }
  }
  uint64_t v32 = *(void *)(*(void *)(a1 + 16) + 288);
  uint64_t v33 = *(void *)(v32 + 368);
  uint64_t v34 = *(unsigned int *)(v32 + 384);
  if (v34)
  {
    LODWORD(v35) = ((v26 >> 4) ^ (v26 >> 9)) & (v34 - 1);
    unsigned int v36 = (uint64_t *)(v33 + 16 * v35);
    uint64_t v37 = *v36;
    if (v26 == *v36) {
      goto LABEL_39;
    }
    int v39 = 1;
    while (v37 != -4096)
    {
      int v40 = v35 + v39++;
      uint64_t v35 = v40 & (v34 - 1);
      uint64_t v37 = *(void *)(v33 + 16 * v35);
      if (v26 == v37)
      {
        unsigned int v36 = (uint64_t *)(v33 + 16 * v35);
        goto LABEL_39;
      }
    }
  }
  unsigned int v36 = (uint64_t *)(v33 + 16 * v34);
LABEL_39:
  unint64_t v38 = *(unsigned int *)(a1 + 208);
  if (v38 >= *(unsigned int *)(a1 + 212)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 200) + 8 * v38) = v36[1] & 0xFFFFFFFFFFFFFFF8 | 4;
  ++*(_DWORD *)(a1 + 208);
LABEL_41:
  while (1)
  {
    int v12 = (int *)*((void *)v12 + 3);
    if (!v12) {
      break;
    }
    int v13 = *v12;
    if ((*v12 & 0x81000000) == 0) {
      goto LABEL_28;
    }
  }
LABEL_16:
  size_t v14 = *(unsigned int *)(a1 + 208);
  if (v14 >= 2)
  {
    qsort(*(void **)(a1 + 200), v14, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CBB24DA4);
    LODWORD(v14) = *(_DWORD *)(a1 + 208);
  }
  uint64_t v15 = *(void *)(a1 + 200);
  if (v14)
  {
    uint64_t v16 = (uint64_t *)(v15 + 8 * v14);
    uint64_t v17 = 8 * v14 - 16;
    unint64_t v18 = *(uint64_t **)(a1 + 200);
    while (1)
    {
      uint64_t v19 = v18++;
      if (v18 == v16) {
        break;
      }
      uint64_t v20 = v17;
      uint64_t v21 = *v19;
      v17 -= 8;
      if ((*v19 & 0xFFFFFFFFFFFFFFF8) == (v19[1] & 0xFFFFFFFFFFFFFFF8))
      {
        if (v19 + 2 != v16)
        {
          uint64_t v22 = 1;
          do
          {
            uint64_t v23 = v18[v22];
            if ((v21 & 0xFFFFFFFFFFFFFFF8) != (v23 & 0xFFFFFFFFFFFFFFF8))
            {
              v19[1] = v23;
              ++v19;
              uint64_t v21 = v23;
            }
            ++v22;
            v20 -= 8;
          }
          while (v20);
        }
        uint64_t v16 = v19 + 1;
        break;
      }
    }
  }
  else
  {
    uint64_t v16 = *(uint64_t **)(a1 + 200);
  }
  *(_DWORD *)(a1 + 208) = ((unint64_t)v16 - v15) >> 3;
  uint64_t v41 = (*(void *)(*(void *)a1 + 112) - *(void *)(*(void *)a1 + 104)) >> 3;
  uint64_t v42 = *(unsigned int *)(a1 + 632);
  if ((*(_DWORD *)(a1 + 688) & 0x3F) != 0)
  {
    uint64_t v101 = *(void *)(a1 + 624) + 8 * v42;
    *(void *)(v101 - 8) &= ~(-1 << (*(_DWORD *)(a1 + 688) & 0x3F));
  }
  unsigned int v43 = v42;
  uint64_t v44 = (void *)(a1 + 624);
  *(_DWORD *)(a1 + 688) = v41;
  unsigned int v45 = v41 + 63;
  if (v42 != (v41 + 63) >> 6)
  {
    uint64_t v46 = v45 >> 6;
    if (v42 > v46)
    {
      *(_DWORD *)(a1 + 632) = v46;
      unsigned int v43 = v45 >> 6;
    }
    else
    {
      if (v46 > *(_DWORD *)(a1 + 636)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v46 != v42) {
        bzero((void *)(*v44 + 8 * v42), 8 * (v46 - v42));
      }
      unsigned int v43 = v46;
      *(_DWORD *)(a1 + 632) = v46;
      LODWORD(v41) = *(_DWORD *)(a1 + 688);
    }
  }
  int v47 = v41 & 0x3F;
  if (v47) {
    *(void *)(*v44 + 8 * v43 - 8) &= ~(-1 << v47);
  }
  *(_DWORD *)(a1 + 616) = 0;
  *(_DWORD *)(a1 + 696) = 0;
  uint64_t v48 = *(void *)(a1 + 40);
  unsigned int v49 = *(_DWORD *)(v48 + 8);
  if (v49)
  {
    uint64_t v50 = *(unint64_t **)v48;
    uint64_t v51 = *(void *)v48 + 24 * v49;
    uint64_t v52 = *(unint64_t **)(a1 + 200);
    uint64_t v53 = &v52[*(unsigned int *)(a1 + 208)];
    unint64_t v54 = **(void **)v48;
    uint64_t v55 = *(void *)(*(void *)(a1 + 16) + 288);
    if (v54 >= 8 && (uint64_t v56 = *(void *)((v54 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
    {
      uint64_t v57 = (uint64_t *)(v56 + 24);
    }
    else
    {
      uint64_t v86 = *(unsigned int *)(v55 + 544);
      if (v86)
      {
        unsigned int v87 = *(_DWORD *)((v54 & 0xFFFFFFFFFFFFFFF8) + 24) | (v54 >> 1) & 3;
        long long v88 = *(void **)(v55 + 536);
        unint64_t v89 = *(unsigned int *)(v55 + 544);
        do
        {
          unint64_t v90 = v89 >> 1;
          uint64_t v91 = &v88[2 * (v89 >> 1)];
          uint64_t v93 = *v91;
          int v92 = v91 + 2;
          v89 += ~(v89 >> 1);
          if (((v93 >> 1) & 3 | *(_DWORD *)((v93 & 0xFFFFFFFFFFFFFFF8) + 24)) < v87) {
            long long v88 = v92;
          }
          else {
            unint64_t v89 = v90;
          }
        }
        while (v89);
        if (v88 == (void *)(*(void *)(v55 + 536) + 16 * v86)
          || ((*v88 >> 1) & 3 | *(_DWORD *)((*v88 & 0xFFFFFFFFFFFFFFF8) + 24)) > v87)
        {
          v88 -= 2;
        }
      }
      else
      {
        long long v88 = *(void **)(v55 + 536);
      }
      uint64_t v57 = v88 + 1;
    }
    uint64_t v58 = *v57;
    uint64_t v102 = a1 + 280;
    uint64_t v103 = (unint64_t *)v51;
    while (1)
    {
      unint64_t v106 = 0;
      unint64_t v107 = 0;
      unint64_t v105 = 0;
      uint64_t v104 = v58;
      uint64_t v59 = *(unsigned int *)(v58 + 24);
      unint64_t v60 = (uint64_t *)(*(void *)(v55 + 392) + 16 * v59);
      uint64_t v61 = v60[1];
      if (v52 == v53
        || (unint64_t v62 = *v52,
            unsigned int v63 = (v61 >> 1) & 3,
            unsigned int v64 = *(_DWORD *)((v61 & 0xFFFFFFFFFFFFFFF8) + 24) | v63,
            ((*v52 >> 1) & 3 | *(_DWORD *)((*v52 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v64))
      {
        ++*(_DWORD *)(a1 + 696);
        *(void *)(*(void *)(a1 + 624) + 8 * (v59 >> 6)) |= 1 << v59;
      }
      else
      {
        uint64_t v68 = *v60;
        unint64_t v105 = *v52;
        int v69 = v52 + 1;
        while (1)
        {
          int v70 = v69;
          if (v69 == v53) {
            break;
          }
          ++v69;
          if (((*v70 >> 1) & 3 | *(_DWORD *)((*v70 & 0xFFFFFFFFFFFFFFF8) + 24)) >= v64)
          {
            uint64_t v52 = v70;
            goto LABEL_76;
          }
        }
        uint64_t v52 = v53;
LABEL_76:
        unint64_t v106 = *(v70 - 1);
        unsigned int v71 = (*v50 >> 1) & 3 | *(_DWORD *)((*v50 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v72 = *(_DWORD *)((v68 & 0xFFFFFFFFFFFFFFF8) + 24) | (v68 >> 1) & 3;
        LOBYTE(v108) = v71 <= v72;
        if (v71 > v72) {
          unint64_t v107 = v62;
        }
        else {
          unint64_t v62 = 0;
        }
        HIBYTE(v108) = 1;
        unint64_t v73 = v50[1];
        unsigned int v74 = (v73 >> 1) & 3 | *(_DWORD *)((v73 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v74 < v64)
        {
          v50 += 3;
          int v79 = v103;
          while (v50 != v79)
          {
            unsigned int v80 = (*v50 >> 1) & 3 | *(_DWORD *)((*v50 & 0xFFFFFFFFFFFFFFF8) + 24);
            if (v80 >= v64) {
              goto LABEL_98;
            }
            if (v74 < v80)
            {
              ++*(_DWORD *)(a1 + 616);
              HIBYTE(v108) = 0;
              unint64_t v82 = sub_1CC47EC6C(v102, (unint64_t)&v104);
              int v79 = v103;
              uint64_t v83 = *(void *)(a1 + 280) + 40 * *(unsigned int *)(a1 + 288);
              long long v84 = *(_OWORD *)v82;
              long long v85 = *(_OWORD *)(v82 + 16);
              *(void *)(v83 + 32) = *(void *)(v82 + 32);
              *(_OWORD *)uint64_t v83 = v84;
              *(_OWORD *)(v83 + 16) = v85;
              LODWORD(v83) = *(_DWORD *)(a1 + 288) + 1;
              *(_DWORD *)(a1 + 288) = v83;
              *(void *)(*(void *)(a1 + 280) + 40 * v83 - 24) = v73;
              __int16 v108 = 256;
              unint64_t v62 = *v50;
              unint64_t v107 = v62;
              unint64_t v105 = v62;
            }
            if (v62 <= 7)
            {
              unint64_t v62 = *v50;
              unint64_t v107 = *v50;
            }
            unint64_t v73 = v50[1];
            unsigned int v74 = (v73 >> 1) & 3 | *(_DWORD *)((v73 & 0xFFFFFFFFFFFFFFF8) + 24);
            unsigned int v64 = *(_DWORD *)((v61 & 0xFFFFFFFFFFFFFFF8) + 24) | v63;
            v50 += 3;
            if (v74 >= v64)
            {
              v50 -= 3;
              goto LABEL_79;
            }
          }
          uint64_t v50 = v79;
LABEL_98:
          HIBYTE(v108) = 0;
          unint64_t v106 = v73;
        }
LABEL_79:
        unint64_t v75 = sub_1CC47EC6C(v102, (unint64_t)&v104);
        uint64_t v76 = *(void *)(a1 + 280) + 40 * *(unsigned int *)(a1 + 288);
        uint64_t v77 = *(void *)(v75 + 32);
        long long v78 = *(_OWORD *)(v75 + 16);
        *(_OWORD *)uint64_t v76 = *(_OWORD *)v75;
        *(_OWORD *)(v76 + 16) = v78;
        *(void *)(v76 + 32) = v77;
        ++*(_DWORD *)(a1 + 288);
        uint64_t v51 = (uint64_t)v103;
        if (v50 == v103) {
          return;
        }
      }
      if (v50[1] == v61)
      {
        v50 += 3;
        if (v50 == (unint64_t *)v51) {
          return;
        }
      }
      unint64_t v65 = *v50 & 0xFFFFFFFFFFFFFFF8;
      unsigned int v66 = (*v50 >> 1) & 3 | *(_DWORD *)(v65 + 24);
      if (v66 >= (*(_DWORD *)((v61 & 0xFFFFFFFFFFFFFFF8) + 24) | (v61 >> 1) & 3))
      {
        uint64_t v55 = *(void *)(*(void *)(a1 + 16) + 288);
        if (*v50 >= 8 && (uint64_t v81 = *(void *)(v65 + 16)) != 0)
        {
          uint64_t v67 = (uint64_t *)(v81 + 24);
        }
        else
        {
          uint64_t v94 = *(unsigned int *)(v55 + 544);
          if (v94)
          {
            unint64_t v95 = *(void **)(v55 + 536);
            unint64_t v96 = *(unsigned int *)(v55 + 544);
            do
            {
              unint64_t v97 = v96 >> 1;
              int v98 = &v95[2 * (v96 >> 1)];
              uint64_t v100 = *v98;
              unsigned int v99 = v98 + 2;
              v96 += ~(v96 >> 1);
              if (((v100 >> 1) & 3 | *(_DWORD *)((v100 & 0xFFFFFFFFFFFFFFF8) + 24)) < v66) {
                unint64_t v95 = v99;
              }
              else {
                unint64_t v96 = v97;
              }
            }
            while (v96);
            if (v95 == (void *)(*(void *)(v55 + 536) + 16 * v94)
              || ((*v95 >> 1) & 3 | *(_DWORD *)((*v95 & 0xFFFFFFFFFFFFFFF8) + 24)) > v66)
            {
              v95 -= 2;
            }
          }
          else
          {
            unint64_t v95 = *(void **)(v55 + 536);
          }
          uint64_t v67 = v95 + 1;
        }
      }
      else
      {
        uint64_t v67 = (uint64_t *)(v58 + 8);
        uint64_t v55 = *(void *)(*(void *)(a1 + 16) + 288);
      }
      uint64_t v58 = *v67;
    }
  }
}

uint64_t sub_1CC47631C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(unint64_t **)a2;
  uint64_t v4 = *(void *)a2 + 24 * v2;
  unint64_t v5 = **(void **)a2;
  uint64_t v6 = *(void *)(*(void *)(a1 + 16) + 288);
  if (v5 >= 8 && (uint64_t v7 = *(void *)((v5 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
  {
    unint64_t v8 = (uint64_t *)(v7 + 24);
  }
  else
  {
    uint64_t v16 = *(unsigned int *)(v6 + 544);
    if (v16)
    {
      unsigned int v17 = *(_DWORD *)((v5 & 0xFFFFFFFFFFFFFFF8) + 24) | (v5 >> 1) & 3;
      unint64_t v18 = *(void **)(v6 + 536);
      unint64_t v19 = *(unsigned int *)(v6 + 544);
      do
      {
        unint64_t v20 = v19 >> 1;
        uint64_t v21 = &v18[2 * (v19 >> 1)];
        uint64_t v23 = *v21;
        uint64_t v22 = v21 + 2;
        v19 += ~(v19 >> 1);
        if (((v23 >> 1) & 3 | *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFF8) + 24)) < v17) {
          unint64_t v18 = v22;
        }
        else {
          unint64_t v19 = v20;
        }
      }
      while (v19);
      if (v18 == (void *)(*(void *)(v6 + 536) + 16 * v16)
        || ((*v18 >> 1) & 3 | *(_DWORD *)((*v18 & 0xFFFFFFFFFFFFFFF8) + 24)) > v17)
      {
        v18 -= 2;
      }
    }
    else
    {
      unint64_t v18 = *(void **)(v6 + 536);
    }
    unint64_t v8 = v18 + 1;
  }
  uint64_t v9 = *v8;
  uint64_t v10 = *(void *)(v6 + 392);
  uint64_t v11 = *(void *)(v10 + 16 * *(unsigned int *)(v9 + 24) + 8);
  unsigned int v12 = *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24) | (v11 >> 1) & 3;
  for (uint64_t result = 1;
        v12 < ((*(void *)(v4 - 16) >> 1) & 3 | *(_DWORD *)((*(void *)(v4 - 16) & 0xFFFFFFFFFFFFFFF8)
                                                                         + 24));
        uint64_t result = (result + 1))
  {
    v3 -= 3;
    do
    {
      unsigned int v14 = (v3[4] >> 1) & 3 | *(_DWORD *)((v3[4] & 0xFFFFFFFFFFFFFFF8) + 24);
      v3 += 3;
    }
    while (v14 <= v12);
    if (v3 == (unint64_t *)v4) {
      break;
    }
    do
    {
      uint64_t v9 = *(void *)(v9 + 8);
      uint64_t v15 = *(void *)(v10 + 16 * *(unsigned int *)(v9 + 24) + 8);
      unsigned int v12 = (v15 >> 1) & 3 | *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFF8) + 24);
    }
    while (v12 <= ((*v3 >> 1) & 3 | *(_DWORD *)((*v3 & 0xFFFFFFFFFFFFFFF8) + 24)));
  }
  return result;
}

uint64_t sub_1CC4764A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = *(void *)(*(void *)(a5 + 272) + 40);
  *(void *)(a1 + 40) = a6;
  *(void *)(a1 + 48) = (*(uint64_t (**)(void))(**(void **)(*(void *)(a5 + 272) + 16) + 104))(*(void *)(*(void *)(a5 + 272) + 16));
  uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a5 + 272) + 16) + 176))(*(void *)(*(void *)(a5 + 272) + 16));
  *(_OWORD *)(a1 + 200) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 56) = v12;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 72) = a8;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = a1 + 136;
  *(void *)(a1 + 128) = 0x400000000;
  *(void *)(a1 + 168) = a1 + 184;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 192) = 1;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 392) = a1 + 96;
  *(_DWORD *)(a1 + 416) = 0;
  uint64_t v13 = 424;
  do
  {
    uint64_t v14 = a1 + v13;
    *(_OWORD *)uint64_t v14 = 0uLL;
    *(_OWORD *)(v14 + 16) = 0uLL;
    *(void *)(v14 + 32) = 0;
    *(void *)(v14 + 40) = a1 + v13 + 56;
    *(void *)(v14 + 48) = 0x600000000;
    *(_DWORD *)(v14 + 104) = 0;
    *(void *)(v14 + 112) = 0;
    *(void *)(v14 + 120) = 0;
    *(_DWORD *)(v14 + 128) = 0;
    *(void *)(a1 + v13 + 152) = 0;
    *(void *)(v14 + 136) = a1 + v13 + 152;
    *(void *)(v14 + 144) = 0;
    *(void *)(v14 + 160) = 0;
    *(void *)(v14 + 176) = a1 + v13 + 192;
    v13 += 704;
    *(void *)(v14 + 184) = 0x1000000000;
  }
  while (v14 + 704 != a1 + 1832);
  return a1;
}

void *sub_1CC47661C(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)(a1 + 80) = a2;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 92) = a3;
  if (*(_DWORD *)(a1 + 384))
  {
    sub_1CC422A74(a1 + 200, (void (*)(void *, void, uint64_t))llvm::IntervalMap<llvm::SlotIndex,unsigned int,9u,llvm::IntervalMapInfo<llvm::SlotIndex>>::deleteNode, 0);
    *(_OWORD *)(a1 + 372) = 0u;
    *(_OWORD *)(a1 + 344) = 0u;
    *(_OWORD *)(a1 + 360) = 0u;
    *(_OWORD *)(a1 + 312) = 0u;
    *(_OWORD *)(a1 + 328) = 0u;
    *(_OWORD *)(a1 + 280) = 0u;
    *(_OWORD *)(a1 + 296) = 0u;
    *(_OWORD *)(a1 + 264) = 0u;
    *(_OWORD *)(a1 + 248) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
  }
  *(_DWORD *)(a1 + 388) = 0;
  uint64_t v4 = (void *)(a1 + 400);
  int v5 = *(_DWORD *)(a1 + 408);
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(a1 + 416);
    if (v6 <= 4 * v5 || v6 < 0x41)
    {
LABEL_6:
      if (v6)
      {
        uint64_t v7 = (void *)*v4;
        uint64_t v8 = 16 * v6;
        do
        {
          *uint64_t v7 = -1;
          v7 += 2;
          v8 -= 16;
        }
        while (v8);
      }
      *(void *)(a1 + 408) = 0;
      goto LABEL_10;
    }
    int v20 = 1 << (33 - __clz(v5 - 1));
    if (v20 <= 64) {
      int v19 = 64;
    }
    else {
      int v19 = v20;
    }
  }
  else
  {
    if (!*(_DWORD *)(a1 + 412)) {
      goto LABEL_10;
    }
    unsigned int v6 = *(_DWORD *)(a1 + 416);
    if (v6 <= 0x40) {
      goto LABEL_6;
    }
    int v19 = 0;
  }
  if (v19 == v6)
  {
    *(void *)(a1 + 408) = 0;
    uint64_t v26 = 16 * v6;
    unint64_t v27 = *(void **)(a1 + 400);
    do
    {
      *unint64_t v27 = -1;
      v27 += 2;
      v26 -= 16;
    }
    while (v26);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v4, 8);
    if (v19)
    {
      unint64_t v21 = (4 * v19 / 3u + 1) | ((unint64_t)(4 * v19 / 3u + 1) >> 1);
      unint64_t v22 = v21 | (v21 >> 2) | ((v21 | (v21 >> 2)) >> 4);
      LODWORD(v22) = (((v22 | (v22 >> 8)) >> 16) | v22 | (v22 >> 8)) + 1;
      *(_DWORD *)(a1 + 416) = v22;
      uint64_t v23 = operator new(16 * v22, (std::align_val_t)8uLL);
      *(void *)(a1 + 400) = v23;
      *(void *)(a1 + 408) = 0;
      uint64_t v24 = *(unsigned int *)(a1 + 416);
      if (v24)
      {
        uint64_t v25 = 16 * v24;
        do
        {
          *uint64_t v23 = -1;
          v23 += 2;
          v25 -= 16;
        }
        while (v25);
      }
    }
    else
    {
      *uint64_t v4 = 0;
      *(void *)(a1 + 408) = 0;
      *(_DWORD *)(a1 + 416) = 0;
    }
  }
LABEL_10:
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(*(void *)(a1 + 24) + 272);
  uint64_t v11 = *(void *)(v9 + 288);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(v10 + 40);
  *(void *)(a1 + 424) = v10;
  *(void *)(a1 + 432) = v13;
  *(void *)(a1 + 440) = v11;
  *(void *)(a1 + 448) = v12;
  *(void *)(a1 + 456) = v9 + 312;
  llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)(a1 + 424));
  *(_DWORD *)(a1 + 608) = 0;
  if (*(_DWORD *)(a1 + 92))
  {
    uint64_t v14 = *(void *)(a1 + 16);
    uint64_t v15 = *(void *)(*(void *)(a1 + 24) + 272);
    uint64_t v16 = *(void *)(v14 + 288);
    uint64_t v17 = *(void *)(a1 + 40);
    *(void *)(a1 + 1128) = v15;
    *(void *)(a1 + 1136) = *(void *)(v15 + 40);
    *(void *)(a1 + 1144) = v16;
    *(void *)(a1 + 1152) = v17;
    *(void *)(a1 + 1160) = v14 + 312;
    llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)(a1 + 1128));
    *(_DWORD *)(a1 + 1312) = 0;
  }
  uint64_t result = *(void **)(a1 + 80);
  if (!*((unsigned char *)result + 68))
  {
    return llvm::LiveRangeEdit::scanRemattable(result, 0);
  }
  return result;
}

uint64_t sub_1CC476878(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  uint64_t v2 = v1 + 16 * *(unsigned int *)(result + 16);
  int v3 = *(_DWORD *)(v2 - 4) + 1;
  *(_DWORD *)(v2 - 4) = v3;
  if (v3 == *(_DWORD *)(v1 + 16 * *(unsigned int *)(result + 16) - 8))
  {
    uint64_t v4 = *(unsigned int *)(*(void *)result + 184);
    if (v4)
    {
      unsigned int v5 = 1;
      uint64_t v6 = v4 + 1;
      uint64_t v7 = (_DWORD *)(v1 + 16 * v4 - 8);
      while (1)
      {
        uint64_t v8 = v7;
        if (v6 == 2) {
          break;
        }
        int v10 = *v7;
        int v9 = v7[1];
        int v11 = *v7 - 1;
        --v6;
        v7 -= 4;
        if (v9 != v11)
        {
          unsigned int v5 = v6;
          goto LABEL_9;
        }
      }
      int v10 = *(_DWORD *)(v1 + 8);
      int v9 = *(_DWORD *)(v1 + 12);
LABEL_9:
      unsigned int v12 = v9 + 1;
      v8[1] = v12;
      if (v12 != v10)
      {
        uint64_t v13 = *(void *)(*((void *)v8 - 1) + 8 * v12);
        if (v4 != v5)
        {
          do
          {
            uint64_t v15 = *(void *)(result + 8) + 16 * v5;
            *(void *)uint64_t v15 = v13 & 0xFFFFFFFFFFFFFFC0;
            *(_DWORD *)(v15 + 8) = (v13 & 0x3F) + 1;
            *(_DWORD *)(v15 + 12) = 0;
            ++v5;
            uint64_t v13 = *(void *)(v13 & 0xFFFFFFFFFFFFFFC0);
          }
          while (v4 != v5);
          uint64_t v1 = *(void *)(result + 8);
        }
        uint64_t v14 = (unint64_t *)(v1 + 16 * v4);
        *uint64_t v14 = v13 & 0xFFFFFFFFFFFFFFC0;
        v14[1] = (v13 & 0x3F) + 1;
      }
    }
  }
  return result;
}

uint64_t getSubRangeForMaskExact(uint64_t a1, uint64_t a2)
{
  for (uint64_t result = *(void *)(a2 + 104); result; uint64_t result = *(void *)(result + 104))
  {
    if (*(void *)(result + 112) == a1) {
      break;
    }
  }
  return result;
}

{
  uint64_t result;

  for (uint64_t result = *(void *)(a2 + 104); result; uint64_t result = *(void *)(result + 104))
  {
    if (*(void *)(result + 112) == a1) {
      break;
    }
  }
  return result;
}

uint64_t getSubRangeForMask(uint64_t a1, uint64_t a2)
{
  for (uint64_t result = *(void *)(a2 + 104); result; uint64_t result = *(void *)(result + 104))
  {
    if ((a1 & ~*(void *)(result + 112)) == 0) {
      break;
    }
  }
  return result;
}

unint64_t sub_1CC4769D4(unint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4 = *(unint64_t **)(a2 + 104);
  if (!v4)
  {
    return llvm::LiveRange::createDeadDef((unint64_t *)a2, a3);
  }
  unint64_t v5 = result;
  unint64_t v6 = *(void *)(a3 + 8);
  if (a4)
  {
    unint64_t v17 = v6 & 0xFFFFFFFFFFFFFFF8;
    unsigned int v18 = (v6 >> 1) & 3;
    while (1)
    {
      uint64_t v19 = *(void *)(*(void *)(v5 + 80) + 8) + 104;
      do
      {
        uint64_t v20 = *(void *)v19;
        uint64_t v21 = *(void *)(*(void *)v19 + 112);
        uint64_t v19 = *(void *)v19 + 104;
      }
      while ((v4[14] & ~v21) != 0);
      unint64_t v22 = *(unsigned int *)(v20 + 8);
      uint64_t v23 = *(void **)v20;
      if (v22)
      {
        uint64_t v24 = v23[3 * v22 - 2];
        unsigned int v25 = *(_DWORD *)(v17 + 24) | v18;
        unsigned int v26 = (v24 >> 1) & 3 | *(_DWORD *)((v24 & 0xFFFFFFFFFFFFFFF8) + 24);
        unint64_t v27 = v23;
        unint64_t v28 = v22;
        if (v25 < v26)
        {
          do
          {
            unint64_t v29 = v28 >> 1;
            uint64_t v30 = v27[3 * (v28 >> 1) + 1];
            LODWORD(v30) = (v30 >> 1) & 3 | *(_DWORD *)((v30 & 0xFFFFFFFFFFFFFFF8) + 24);
            v28 -= (v28 >> 1) + 1;
            BOOL v31 = v25 >= v30;
            if (v25 >= v30) {
              unint64_t v32 = v29 + 1;
            }
            else {
              unint64_t v32 = 0;
            }
            v27 += 3 * v32;
            if (!v31) {
              unint64_t v28 = v29;
            }
          }
          while (v28);
          goto LABEL_28;
        }
      }
      else
      {
        LODWORD(v22) = 0;
      }
      unint64_t v27 = &v23[3 * v22];
LABEL_28:
      if (v27 != &v23[3 * v22]
        && ((*v27 >> 1) & 3 | *(_DWORD *)((*v27 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)(v17 + 24) | v18))
      {
        uint64_t v33 = v27[2];
        if (v33)
        {
          if (*(void *)(v33 + 8) == v6)
          {
            uint64_t v34 = *(void *)(v5 + 16) + 312;
            if (v4[12])
            {
              int v39 = v4;
              uint64_t result = sub_1CC2F6AE4((uint64_t *)&v39, v6, v34, 0);
            }
            else
            {
              int v39 = v4;
              uint64_t result = sub_1CC2F6F18(&v39, v6, v34, 0);
            }
          }
        }
      }
      uint64_t v4 = (unint64_t *)v4[13];
      if (!v4) {
        return result;
      }
    }
  }
  if (v6 < 8) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *(void *)((v6 & 0xFFFFFFFFFFFFFFF8) + 16);
  }
  uint64_t v8 = *(void *)(v7 + 32);
  uint64_t v9 = *(void *)(v7 + 16);
  unsigned int v10 = *(unsigned __int8 *)(v9 + 4);
  if ((*(unsigned char *)(v9 + 8) & 2) == 0 || (int v36 = *(_DWORD *)(v7 + 40), v36 == v10))
  {
    unsigned int v11 = *(unsigned __int8 *)(v9 + 4);
  }
  else
  {
    int v37 = v36 - 1;
    unsigned int v11 = v10;
    do
    {
      int v38 = *(_DWORD *)(v8 + 32 * v10);
      if ((v38 & 0x10000FF) != 0x1000000) {
        break;
      }
      v11 += (v38 & 0x2000000) == 0;
      if (v37 == v10) {
        break;
      }
      ++v10;
    }
    while ((v38 & 0x2000000) == 0);
  }
  uint64_t v12 = 0;
  if (!v11) {
    goto LABEL_39;
  }
  int v13 = *(_DWORD *)(a2 + 112);
  uint64_t v14 = 32 * v11;
  uint64_t v15 = (_DWORD *)(v8 + 4);
  while (*v15 != v13)
  {
LABEL_15:
    v15 += 8;
    v14 -= 32;
    if (!v14) {
      goto LABEL_39;
    }
  }
  unint64_t v16 = ((unint64_t)*(v15 - 1) >> 8) & 0xFFF;
  if (v16)
  {
    v12 |= *(void *)(*(void *)(*(void *)(result + 56) + 232) + 8 * v16);
    goto LABEL_15;
  }
  uint64_t v12 = *(void *)((*(void *)(*(void *)(*(void *)(result + 32) + 24) + 16 * (v13 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8)
                  + 24);
  do
  {
LABEL_39:
    if ((v4[14] & v12) != 0)
    {
      uint64_t v35 = *(void *)(v5 + 16) + 312;
      if (v4[12])
      {
        int v39 = v4;
        uint64_t result = sub_1CC2F6AE4((uint64_t *)&v39, v6, v35, 0);
      }
      else
      {
        int v39 = v4;
        uint64_t result = sub_1CC2F6F18(&v39, v6, v35, 0);
      }
    }
    uint64_t v4 = (unint64_t *)v4[13];
  }
  while (v4);
  return result;
}

unint64_t sub_1CC476CC8(unint64_t a1, unsigned int a2, unsigned int *a3, uint64_t a4, int a5)
{
  uint64_t v10 = *(void *)(a1 + 16);
  unint64_t v11 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16) + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + a2)) & 0x7FFFFFFF;
  uint64_t v12 = (void *)(v10 + 408);
  unint64_t v13 = *(unsigned int *)(v10 + 416);
  BOOL v14 = v11 >= v13;
  unint64_t v15 = v11 - v13;
  if (v14)
  {
    sub_1CB9153B8((uint64_t)v12, v15 + 1, *(void *)(v10 + 424));
LABEL_48:
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v16 = *(void *)(*v12 + 8 * v11);
  if (!v16) {
    goto LABEL_48;
  }
  *(void *)(v10 + 392) += 16;
  uint64_t v17 = *(void *)(v10 + 312);
  if (((v17 + 7) & 0xFFFFFFFFFFFFFFF8) - v17 + 16 > *(void *)(v10 + 320) - v17)
  {
    unsigned int v44 = *(_DWORD *)(v10 + 336) >> 7;
    if (v44 >= 0x1E) {
      LOBYTE(v44) = 30;
    }
    uint64_t v45 = 4096 << v44;
    unint64_t v18 = (unint64_t)operator new(4096 << v44, (std::align_val_t)8uLL);
    unsigned int v46 = *(_DWORD *)(v10 + 336);
    if (v46 >= *(_DWORD *)(v10 + 340)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v10 + 328) + 8 * v46) = v18;
    ++*(_DWORD *)(v10 + 336);
    *(void *)(v10 + 320) = v18 + v45;
  }
  else
  {
    unint64_t v18 = (v17 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v10 + 312) = v18 + 16;
  unsigned int v19 = *(_DWORD *)(v16 + 72);
  *(_DWORD *)unint64_t v18 = v19;
  *(void *)(v18 + 8) = a4;
  if (v19 >= *(_DWORD *)(v16 + 76)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(v16 + 64) + 8 * v19) = v18;
  ++*(_DWORD *)(v16 + 72);
  uint64_t v20 = *(void *)(v16 + 104);
  if (v20) {
    unint64_t v21 = 0;
  }
  else {
    unint64_t v21 = v18;
  }
  unint64_t v22 = v21 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v20 != 0));
  uint64_t v23 = *a3;
  v47[0] = a2 | (unint64_t)(v23 << 32);
  v47[1] = v22;
  int v24 = *(_DWORD *)(a1 + 416);
  if (v24)
  {
    uint64_t v25 = *(void *)(a1 + 400);
    unint64_t v26 = ((37 * v23) | ((unint64_t)(37 * a2) << 32))
        + ~((unint64_t)(37 * v23) << 32);
    unint64_t v27 = (v26 ^ (v26 >> 22)) + ~((v26 ^ (v26 >> 22)) << 13);
    unint64_t v28 = (9 * (v27 ^ (v27 >> 8))) ^ ((9 * (v27 ^ (v27 >> 8))) >> 15);
    int v29 = v24 - 1;
    unsigned int v30 = v29 & (((v28 + ~(v28 << 27)) >> 31) ^ (v28 + ~(v28 << 27)));
    BOOL v31 = (_DWORD *)(v25 + 16 * v30);
    int v32 = *v31;
    int v33 = v31[1];
    if (*v31 == a2 && v23 == v33)
    {
LABEL_15:
      unint64_t v22 = *((void *)v31 + 1);
      goto LABEL_16;
    }
    int v36 = 0;
    int v37 = 1;
    while (v32 != -1 || v33 != -1)
    {
      if (v36) {
        BOOL v40 = 0;
      }
      else {
        BOOL v40 = v33 == -2;
      }
      if (v40 && v32 == -2) {
        int v36 = v31;
      }
      unsigned int v42 = v30 + v37++;
      unsigned int v30 = v42 & v29;
      BOOL v31 = (_DWORD *)(v25 + 16 * v30);
      int v32 = *v31;
      int v33 = v31[1];
      if (*v31 == a2 && v23 == v33) {
        goto LABEL_15;
      }
    }
    if (v36) {
      int v38 = v36;
    }
    else {
      int v38 = v31;
    }
  }
  else
  {
    int v38 = 0;
  }
  int v39 = sub_1CC47F07C(a1 + 400, (int *)v47, v38);
  *int v39 = a2;
  v39[1] = v23;
  *((void *)v39 + 1) = v22;
  if (!v20) {
    return v18;
  }
  BOOL v31 = v39;
LABEL_16:
  if ((v22 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    sub_1CC4769D4(a1, v16, v22 & 0xFFFFFFFFFFFFFFF8, a5);
    *((void *)v31 + 1) = 4 * (v20 != 0);
  }
  sub_1CC4769D4(a1, v16, v18, a5);
  return v18;
}

unint64_t sub_1CC476FDC(unint64_t result, unsigned int a2, uint64_t a3)
{
  int v3 = a3;
  unint64_t v5 = result;
  unint64_t v34 = a2 | (unint64_t)(a3 << 32);
  int v6 = *(_DWORD *)(result + 416);
  if (!v6)
  {
    unint64_t v22 = 0;
LABEL_15:
    uint64_t result = (unint64_t)sub_1CC47F07C(result + 400, (int *)&v34, v22);
    unint64_t v13 = result;
    *(_DWORD *)uint64_t result = a2;
    *(_DWORD *)(result + 4) = v3;
    *(void *)(result + 8) = 0;
    goto LABEL_7;
  }
  uint64_t v7 = *(void *)(result + 400);
  unint64_t v8 = ((37 * a3) | ((unint64_t)(37 * a2) << 32))
     + ~((unint64_t)(37 * a3) << 32);
  unint64_t v9 = (v8 ^ (v8 >> 22)) + ~((v8 ^ (v8 >> 22)) << 13);
  unint64_t v10 = (9 * (v9 ^ (v9 >> 8))) ^ ((9 * (v9 ^ (v9 >> 8))) >> 15);
  int v11 = v6 - 1;
  unsigned int v12 = v11 & (((v10 + ~(v10 << 27)) >> 31) ^ (v10 + ~(v10 << 27)));
  unint64_t v13 = v7 + 16 * v12;
  int v14 = *(_DWORD *)v13;
  int v15 = *(_DWORD *)(v13 + 4);
  if (*(_DWORD *)v13 != a2 || v15 != a3)
  {
    uint64_t v20 = 0;
    int v21 = 1;
    while (v14 != -1 || v15 != -1)
    {
      if (v20) {
        BOOL v30 = 0;
      }
      else {
        BOOL v30 = v15 == -2;
      }
      if (v30 && v14 == -2) {
        uint64_t v20 = (_DWORD *)v13;
      }
      unsigned int v32 = v12 + v21++;
      unsigned int v12 = v32 & v11;
      unint64_t v13 = v7 + 16 * v12;
      int v14 = *(_DWORD *)v13;
      int v15 = *(_DWORD *)(v13 + 4);
      if (*(_DWORD *)v13 == a2 && v15 == a3) {
        goto LABEL_7;
      }
    }
    if (v20) {
      unint64_t v22 = v20;
    }
    else {
      unint64_t v22 = (_DWORD *)v13;
    }
    goto LABEL_15;
  }
LABEL_7:
  uint64_t v17 = *(void *)(v13 + 8);
  unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFF8;
  if ((v17 & 0xFFFFFFFFFFFFFFF8) != 0)
  {
    uint64_t v23 = *(void *)(v5 + 16);
    unint64_t v24 = *(_DWORD *)(**(void **)(*(void *)(v5 + 80) + 16) + 4 * (*(_DWORD *)(*(void *)(v5 + 80) + 64) + a2)) & 0x7FFFFFFF;
    uint64_t v25 = (void *)(v23 + 408);
    unint64_t v26 = *(unsigned int *)(v23 + 416);
    BOOL v27 = v24 >= v26;
    unint64_t v28 = v24 - v26;
    if (v27)
    {
      sub_1CB9153B8((uint64_t)v25, v28 + 1, *(void *)(v23 + 424));
    }
    else
    {
      uint64_t v29 = *(void *)(*v25 + 8 * v24);
      if (v29)
      {
        uint64_t result = sub_1CC4769D4(v5, v29, v18, 0);
        uint64_t v19 = 4;
        goto LABEL_9;
      }
    }
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v19 = v17 | 4;
LABEL_9:
  *(void *)(v13 + 8) = v19;
  return result;
}

unint64_t sub_1CC4771B0(void *a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  uint64_t v7 = a5;
  unsigned int v10 = a2;
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1[2];
  int v13 = *(_DWORD *)(**(void **)(a1[10] + 16) + 4 * (*(_DWORD *)(a1[10] + 64) + a2));
  int v14 = (void *)(v12 + 408);
  unint64_t v15 = *(unsigned int *)(v12 + 416);
  if ((v13 & 0x7FFFFFFFu) >= v15)
  {
    sub_1CB9153B8((uint64_t)v14, (v13 & 0x7FFFFFFF) - v15 + 1, *(void *)(v12 + 424));
LABEL_108:
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v16 = *(void *)(*v14 + 8 * (v13 & 0x7FFFFFFF));
  if (!v16) {
    goto LABEL_108;
  }
  if (*(_DWORD *)(*(void *)(a1[3] + 328) + 4 * (v13 & 0x7FFFFFFF))) {
    int v13 = *(_DWORD *)(*(void *)(a1[3] + 328) + 4 * (v13 & 0x7FFFFFFF));
  }
  uint64_t v17 = (void *)(v12 + 408);
  BOOL v28 = (v13 & 0x7FFFFFFFu) >= v15;
  unint64_t v18 = (v13 & 0x7FFFFFFF) - v15;
  if (v28)
  {
    sub_1CB9153B8((uint64_t)v17, v18 + 1, *(void *)(v12 + 424));
LABEL_110:
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v19 = *(void *)(*v17 + 8 * (v13 & 0x7FFFFFFF));
  if (!v19) {
    goto LABEL_110;
  }
  unsigned int v20 = *(_DWORD *)(v19 + 8);
  int v21 = *(void **)v19;
  if (v20)
  {
    uint64_t v22 = v21[3 * v20 - 2];
    unsigned int v23 = *(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3;
    if (v23 < ((v22 >> 1) & 3 | *(_DWORD *)((v22 & 0xFFFFFFFFFFFFFFF8) + 24)))
    {
      unint64_t v24 = *(void **)v19;
      unint64_t v25 = *(unsigned int *)(v19 + 8);
      do
      {
        unint64_t v26 = v25 >> 1;
        uint64_t v27 = v24[3 * (v25 >> 1) + 1];
        LODWORD(v27) = (v27 >> 1) & 3 | *(_DWORD *)((v27 & 0xFFFFFFFFFFFFFFF8) + 24);
        v25 -= (v25 >> 1) + 1;
        BOOL v28 = v23 >= v27;
        if (v23 >= v27) {
          unint64_t v29 = v26 + 1;
        }
        else {
          unint64_t v29 = 0;
        }
        v24 += 3 * v29;
        if (!v28) {
          unint64_t v25 = v26;
        }
      }
      while (v25);
      goto LABEL_16;
    }
  }
  else
  {
    unsigned int v20 = 0;
  }
  unint64_t v24 = &v21[3 * v20];
LABEL_16:
  if (v24 == &v21[3 * v20]
    || ((*v24 >> 1) & 3 | *(_DWORD *)((*v24 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3))
  {
    unsigned int v31 = *(_DWORD *)(v16 + 112);
  }
  else
  {
    uint64_t v30 = v24[2];
    unsigned int v31 = *(_DWORD *)(v16 + 112);
    if (v30)
    {
      uint64_t v117 = a3;
      unint64_t v32 = *(void *)(v30 + 8);
      if (v32 < 8) {
        uint64_t v34 = 0;
      }
      else {
        uint64_t v34 = *(void *)((v32 & 0xFFFFFFFFFFFFFFF8) + 16);
      }
      uint64_t v118 = v34;
      if (llvm::LiveRangeEdit::canRematerializeAt(a1[10], (uint64_t)&v117, v30, a4, 1))
      {
        unint64_t v52 = llvm::LiveRangeEdit::rematerializeAt(a1[10], a5, a6, v31, (uint64_t *)&v117, a1[7], v10 != 0);
        return sub_1CC476CC8((unint64_t)a1, v10, (unsigned int *)a3, v52, 0);
      }
      uint64_t v7 = a5;
    }
  }
  uint64_t v35 = *(void *)(v19 + 104);
  if (!v35)
  {
    uint64_t v36 = -1;
LABEL_26:
    uint64_t v37 = a1[10];
    int v38 = *(_DWORD *)(*(void *)(v37 + 8) + 112);
    uint64_t v39 = *(void *)(a1[6] + 8);
    uint64_t v40 = a1[2];
    *(void *)unsigned int v115 = *(void *)(v40 + 288);
    if (v36 == -1
      || (uint64_t v70 = a1[4],
          *(void *)((*(void *)(*(void *)(v70 + 24) + 16 * (v38 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8) + 24) == v36))
    {
      uint64_t v41 = *(llvm::MachineFunction **)(v7 + 32);
      uint64_t v121 = 0;
      uint64_t v42 = v7;
      uint64_t v43 = (uint64_t)llvm::MachineFunction::CreateMachineInstr(v41, v39 + 912, &v121, 0);
      if (v121) {
        llvm::MetadataTracking::untrack((uint64_t)&v121, v121);
      }
      uint64_t v44 = *(void *)(v42 + 40);
      *(void *)(v43 + 24) = v44;
      uint64_t v45 = *(void *)(v44 + 32);
      uint64_t v46 = *(unsigned int *)(v43 + 40);
      if (v46)
      {
        uint64_t v94 = *(void *)(v43 + 32);
        uint64_t v95 = *(void *)(v45 + 40);
        uint64_t v96 = 32 * v46;
        do
        {
          if (!*(unsigned char *)v94)
          {
            uint64_t v97 = *(unsigned int *)(v94 + 4);
            if ((int)v97 >= 0) {
              int v98 = (uint64_t *)(*(void *)(v95 + 272) + 8 * v97);
            }
            else {
              int v98 = (uint64_t *)(*(void *)(v95 + 24) + 16 * (v97 & 0x7FFFFFFF) + 8);
            }
            uint64_t v99 = *v98;
            if (*v98)
            {
              uint64_t v100 = *(void *)(v99 + 16);
              *(void *)(v99 + 16) = v94;
              *(void *)(v94 + 16) = v100;
              if (*(unsigned char *)(v94 + 3))
              {
                *(void *)(v94 + 24) = v99;
              }
              else
              {
                *(void *)(v94 + 24) = 0;
                int v98 = (uint64_t *)(v100 + 24);
              }
            }
            else
            {
              *(void *)(v94 + 16) = v94;
              *(void *)(v94 + 24) = 0;
            }
            *int v98 = v94;
          }
          v94 += 32;
          v96 -= 32;
        }
        while (v96);
      }
      uint64_t v47 = *(void *)(v45 + 728);
      if (v47) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v47 + 24))(v47, v43);
      }
      unint64_t v48 = *a6 & 0xFFFFFFFFFFFFFFF8;
      *(void *)uint64_t v43 = v48 | *(void *)v43 & 7;
      *(void *)(v43 + 8) = a6;
      *(void *)(v48 + 8) = v43;
      *a6 = *a6 & 7 | v43;
      uint64_t v118 = 0;
      uint64_t v119 = 0;
      uint64_t v120 = 0;
      LODWORD(v117) = 0x1000000;
      HIDWORD(v117) = v31;
      llvm::MachineInstr::addOperand((llvm::MachineInstr *)v43, v41, (const llvm::MachineOperand *)&v117);
      uint64_t v118 = 0;
      uint64_t v119 = 0;
      LODWORD(v117) = 0;
      HIDWORD(v117) = v38;
      uint64_t v120 = 0;
      llvm::MachineInstr::addOperand((llvm::MachineInstr *)v43, v41, (const llvm::MachineOperand *)&v117);
      uint64_t v49 = *(void *)v115;
      uint64_t v50 = v43;
      BOOL v51 = v10 != 0;
      goto LABEL_33;
    }
    unsigned int v71 = v10;
    unsigned int v72 = a3;
    unsigned int v112 = v71;
    unint64_t v73 = *(_DWORD *)(**(void **)(v37 + 16) + 4 * (*(_DWORD *)(v37 + 64) + v71)) & 0x7FFFFFFF;
    unsigned int v74 = (void *)(v40 + 408);
    unint64_t v75 = *(unsigned int *)(v40 + 416);
    BOOL v28 = v73 >= v75;
    unint64_t v76 = v73 - v75;
    uint64_t v111 = v7;
    if (v28)
    {
      sub_1CB9153B8((uint64_t)v74, v76 + 1, *(void *)(v40 + 424));
    }
    else if (*(void *)(*v74 + 8 * v73))
    {
      uint64_t v113 = *(void *)(*v74 + 8 * v73);
      uint64_t v110 = v72;
      unint64_t v77 = *(void *)(*(void *)(v70 + 24) + 16 * (v38 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v117 = &v119;
      uint64_t v118 = 0x800000000;
      unsigned int v10 = v71;
      if ((llvm::TargetRegisterInfo::getCoveringSubRegIndexes(a1[7], v70, v77, v36, (uint64_t)&v117) & 1) == 0) {
        llvm::report_fatal_error((llvm *)"Impossible to implement partial COPY", (const llvm::Twine *)1);
      }
      unint64_t v52 = 0;
      if (v118)
      {
        unsigned int v78 = v31;
        int v79 = (char *)v117;
        __int16 v108 = (char *)v117 + 4 * v118;
        int v109 = v78;
        do
        {
          int v114 = *(_DWORD *)v79;
          uint64_t v80 = *(void *)(a1[6] + 8) + 912;
          uint64_t v81 = *(llvm::MachineFunction **)(v111 + 32);
          uint64_t v121 = 0;
          unint64_t v82 = llvm::MachineFunction::CreateMachineInstr(v81, v80, &v121, 0);
          if (v121) {
            llvm::MetadataTracking::untrack((uint64_t)&v121, v121);
          }
          uint64_t v83 = *(void *)(v111 + 40);
          *((void *)v82 + 3) = v83;
          uint64_t v84 = *(void *)(v83 + 32);
          uint64_t v85 = *((unsigned int *)v82 + 10);
          if (v85)
          {
            uint64_t v101 = *((void *)v82 + 4);
            uint64_t v102 = *(void *)(v84 + 40);
            uint64_t v103 = 32 * v85;
            do
            {
              if (!*(unsigned char *)v101)
              {
                uint64_t v104 = *(unsigned int *)(v101 + 4);
                if ((int)v104 >= 0) {
                  unint64_t v105 = (uint64_t *)(*(void *)(v102 + 272) + 8 * v104);
                }
                else {
                  unint64_t v105 = (uint64_t *)(*(void *)(v102 + 24) + 16 * (v104 & 0x7FFFFFFF) + 8);
                }
                uint64_t v106 = *v105;
                if (*v105)
                {
                  uint64_t v107 = *(void *)(v106 + 16);
                  *(void *)(v106 + 16) = v101;
                  *(void *)(v101 + 16) = v107;
                  if (*(unsigned char *)(v101 + 3))
                  {
                    *(void *)(v101 + 24) = v106;
                  }
                  else
                  {
                    *(void *)(v101 + 24) = 0;
                    unint64_t v105 = (uint64_t *)(v107 + 24);
                  }
                }
                else
                {
                  *(void *)(v101 + 16) = v101;
                  *(void *)(v101 + 24) = 0;
                }
                uint64_t *v105 = v101;
              }
              v101 += 32;
              v103 -= 32;
            }
            while (v103);
          }
          uint64_t v86 = *(void *)(v84 + 728);
          if (v86) {
            (*(void (**)(uint64_t, llvm::MachineInstr *))(*(void *)v86 + 24))(v86, v82);
          }
          unint64_t v87 = *a6 & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v82 = v87 | *(void *)v82 & 7;
          *((void *)v82 + 1) = a6;
          *(void *)(v87 + 8) = v82;
          *a6 = *a6 & 7 | (unint64_t)v82;
          v116[0] = v81;
          v116[1] = v82;
          if (v52 >= 8) {
            unsigned int v88 = 258;
          }
          else {
            unsigned int v88 = 34;
          }
          unint64_t v89 = sub_1CB89517C(v116, v109, v88, v114);
          unint64_t v90 = v89[1];
          uint64_t v91 = *v89;
          unint64_t v122 = 0;
          uint64_t v123 = 0;
          uint64_t v124 = 0;
          LODWORD(v121) = (v114 & 0xFFF) << 8;
          HIDWORD(v121) = v38;
          llvm::MachineInstr::addOperand(v90, v91, (const llvm::MachineOperand *)&v121);
          uint64_t v92 = (uint64_t)v89[1];
          if (v52 > 7)
          {
            *(_WORD *)(v92 + 44) |= 4u;
            *(_WORD *)((*(void *)v92 & 0xFFFFFFFFFFFFFFF8) + 44) |= 8u;
          }
          else
          {
            unint64_t v52 = sub_1CB914C88(*(void *)(a1[2] + 288), v92, v112 != 0) & 0xFFFFFFFFFFFFFFF8 | 4;
          }
          v79 += 4;
        }
        while (v79 != v108);
      }
      uint64_t v93 = a1[2] + 312;
      uint64_t v121 = (unsigned __int8 *)&unk_1F2613208;
      unint64_t v122 = v52;
      uint64_t v123 = v93;
      uint64_t v124 = &v121;
      llvm::LiveInterval::refineSubRanges(v113, v93, v36, (uint64_t)&v121, v115[0], (void *)a1[7], 0);
      if (v124 == &v121)
      {
        (*((void (**)(unsigned __int8 **))v121 + 4))(&v121);
        a3 = v110;
      }
      else
      {
        a3 = v110;
        if (v124) {
          (*((void (**)(unsigned __int8 **))*v124 + 5))(v124);
        }
      }
      if (v117 != &v119) {
        free(v117);
      }
      return sub_1CC476CC8((unint64_t)a1, v10, (unsigned int *)a3, v52, 0);
    }
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v36 = 0;
  unint64_t v54 = a4 & 0xFFFFFFFFFFFFFFF8;
  unsigned int v55 = (a4 >> 1) & 3;
  do
  {
    unsigned int v56 = *(_DWORD *)(v35 + 8);
    uint64_t v57 = *(void **)v35;
    if (!v56)
    {
      unsigned int v56 = 0;
LABEL_50:
      uint64_t v61 = &v57[3 * v56];
      goto LABEL_44;
    }
    uint64_t v58 = v57[3 * v56 - 2];
    unsigned int v59 = *(_DWORD *)(v54 + 24) | v55;
    unsigned int v60 = (v58 >> 1) & 3 | *(_DWORD *)((v58 & 0xFFFFFFFFFFFFFFF8) + 24);
    uint64_t v61 = *(void **)v35;
    unint64_t v62 = *(unsigned int *)(v35 + 8);
    if (v59 >= v60) {
      goto LABEL_50;
    }
    do
    {
      unint64_t v63 = v62 >> 1;
      uint64_t v64 = v61[3 * (v62 >> 1) + 1];
      LODWORD(v64) = (v64 >> 1) & 3 | *(_DWORD *)((v64 & 0xFFFFFFFFFFFFFFF8) + 24);
      v62 -= (v62 >> 1) + 1;
      BOOL v65 = v59 >= v64;
      if (v59 >= v64) {
        unint64_t v66 = v63 + 1;
      }
      else {
        unint64_t v66 = 0;
      }
      v61 += 3 * v66;
      if (!v65) {
        unint64_t v62 = v63;
      }
    }
    while (v62);
LABEL_44:
    if (v61 != &v57[3 * v56]
      && ((*v61 >> 1) & 3 | *(_DWORD *)((*v61 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)(v54 + 24) | v55))
    {
      v36 |= *(void *)(v35 + 112);
    }
    uint64_t v35 = *(void *)(v35 + 104);
  }
  while (v35);
  if (v36) {
    goto LABEL_26;
  }
  uint64_t v67 = *(void *)(a1[6] + 8) + 480;
  uint64_t v117 = 0;
  sub_1CB85AA4C(v7, a6, (unsigned __int8 **)&v117, v67, v31);
  uint64_t v69 = v68;
  if (v117) {
    llvm::MetadataTracking::untrack((uint64_t)&v117, (unsigned __int8 *)v117);
  }
  BOOL v51 = v10 != 0;
  uint64_t v49 = *(void *)(a1[2] + 288);
  uint64_t v50 = v69;
LABEL_33:
  unint64_t v52 = sub_1CB914C88(v49, v50, v51) & 0xFFFFFFFFFFFFFFF8 | 4;
  return sub_1CC476CC8((unint64_t)a1, v10, (unsigned int *)a3, v52, 0);
}

BOOL sub_1CC477B90(void *a1, unsigned int a2, uint64_t a3)
{
  if (!a2)
  {
    unsigned int v3 = 0;
    goto LABEL_13;
  }
  unsigned int v3 = a2;
  uint64_t v4 = a1[3 * a2 - 2];
  unsigned int v5 = *(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (a3 >> 1) & 3;
  if (v5 >= ((v4 >> 1) & 3 | *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_13:
    int v6 = &a1[3 * v3];
    return v6 != &a1[3 * v3]
        && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (a3 >> 1) & 3);
  }
  int v6 = a1;
  unint64_t v7 = a2;
  do
  {
    unint64_t v8 = v7 >> 1;
    uint64_t v9 = v6[3 * (v7 >> 1) + 1];
    LODWORD(v9) = (v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24);
    v7 -= (v7 >> 1) + 1;
    BOOL v10 = v5 >= v9;
    if (v5 >= v9) {
      unint64_t v11 = v8 + 1;
    }
    else {
      unint64_t v11 = 0;
    }
    v6 += 3 * v11;
    if (!v10) {
      unint64_t v7 = v8;
    }
  }
  while (v7);
  return v6 != &a1[3 * v3]
      && ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (a3 >> 1) & 3);
}

void sub_1CC477C68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  int v3 = *(_DWORD *)(*(void *)(v2 + 16) + 8);
  int v4 = *(_DWORD *)(v2 + 64);
  if (v3 == v4) {
    llvm::LiveRangeEdit::createEmptyIntervalFrom((void *)v2, *(_DWORD *)(*(void *)(v2 + 8) + 112));
  }
  *(_DWORD *)(a1 + 88) = v3 - v4;
  llvm::LiveRangeEdit::createEmptyIntervalFrom((void *)v2, *(_DWORD *)(*(void *)(v2 + 8) + 112));
}

unint64_t sub_1CC477CDC(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v3 = *(void *)(*(void *)(a1 + 80) + 8);
  unint64_t v4 = *(unsigned int *)(v3 + 8);
  unsigned int v5 = *(void **)v3;
  if (!v4)
  {
    LODWORD(v4) = 0;
    goto LABEL_18;
  }
  uint64_t v6 = v5[3 * v4 - 2];
  unsigned int v7 = *(_DWORD *)(v2 + 24);
  if (v7 >= ((v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_18:
    unint64_t v8 = &v5[3 * v4];
    goto LABEL_10;
  }
  unint64_t v8 = v5;
  unint64_t v9 = v4;
  do
  {
    unint64_t v10 = v9 >> 1;
    uint64_t v11 = v8[3 * (v9 >> 1) + 1];
    LODWORD(v11) = (v11 >> 1) & 3 | *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24);
    v9 -= (v9 >> 1) + 1;
    BOOL v12 = v7 >= v11;
    if (v7 >= v11) {
      unint64_t v13 = v10 + 1;
    }
    else {
      unint64_t v13 = 0;
    }
    v8 += 3 * v13;
    if (!v12) {
      unint64_t v9 = v10;
    }
  }
  while (v9);
LABEL_10:
  if (v8 != &v5[3 * v4]
    && ((*v8 >> 1) & 3 | *(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24)) <= *(_DWORD *)(v2 + 24))
  {
    int v14 = (void *)v8[2];
    if (v14)
    {
      if (v2) {
        uint64_t v15 = *(void *)(v2 + 16);
      }
      else {
        uint64_t v15 = 0;
      }
      return *(void *)(sub_1CC4771B0((void *)a1, *(_DWORD *)(a1 + 88), v14, v2, *(void *)(v15 + 24), (unint64_t *)v15)+ 8);
    }
  }
  return v2;
}

unint64_t sub_1CC477DE0(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v3 = a2 & 0xFFFFFFFFFFFFFFF8 | 6;
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 8);
  unint64_t v5 = *(unsigned int *)(v4 + 8);
  uint64_t v6 = *(void **)v4;
  if (!v5)
  {
    LODWORD(v5) = 0;
    goto LABEL_20;
  }
  uint64_t v7 = v6[3 * v5 - 2];
  unsigned int v8 = *(_DWORD *)(v2 + 24) | 3;
  if (v8 >= ((v7 >> 1) & 3 | *(_DWORD *)((v7 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_20:
    unint64_t v9 = &v6[3 * v5];
    goto LABEL_10;
  }
  unint64_t v9 = v6;
  unint64_t v10 = v5;
  do
  {
    unint64_t v11 = v10 >> 1;
    uint64_t v12 = v9[3 * (v10 >> 1) + 1];
    LODWORD(v12) = (v12 >> 1) & 3 | *(_DWORD *)((v12 & 0xFFFFFFFFFFFFFFF8) + 24);
    v10 -= (v10 >> 1) + 1;
    BOOL v13 = v8 >= v12;
    if (v8 >= v12) {
      unint64_t v14 = v11 + 1;
    }
    else {
      unint64_t v14 = 0;
    }
    v9 += 3 * v14;
    if (!v13) {
      unint64_t v10 = v11;
    }
  }
  while (v10);
LABEL_10:
  if (v9 != &v6[3 * v5]
    && ((*v9 >> 1) & 3 | *(_DWORD *)((*v9 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)(v2 + 24) | 3u))
  {
    uint64_t v15 = (void *)v9[2];
    if (v15)
    {
      if (v3 < 8) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = *(void *)(v2 + 16);
      }
      uint64_t v17 = *(void *)(v16 + 24);
      if ((*(unsigned char *)v16 & 4) == 0)
      {
        while ((*(_WORD *)(v16 + 44) & 8) != 0)
          uint64_t v16 = *(void *)(v16 + 8);
      }
      return *(void *)(sub_1CC4771B0((void *)a1, *(_DWORD *)(a1 + 88), v15, v3, v17, *(unint64_t **)(v16 + 8))+ 8);
    }
  }
  return v3;
}

uint64_t sub_1CC477F10(uint64_t a1, llvm::MachineBasicBlock *this)
{
  uint64_t v4 = *((unsigned int *)this + 6);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392) + 16 * v4 + 8);
  unsigned int v6 = (v5 >> 1) & 3;
  unint64_t v7 = v5 & 0xFFFFFFFFFFFFFFF8;
  if (v6) {
    uint64_t v8 = v7 | (2 * (v6 - 1));
  }
  else {
    uint64_t v8 = *(void *)v7 | 6;
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 80) + 8);
  unint64_t v10 = *(unsigned int *)(v9 + 8);
  unint64_t v11 = *(void **)v9;
  if (!v10)
  {
    LODWORD(v10) = 0;
    goto LABEL_33;
  }
  uint64_t v12 = v11[3 * v10 - 2];
  unsigned int v13 = *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | (v8 >> 1) & 3;
  if (v13 >= ((v12 >> 1) & 3 | *(_DWORD *)((v12 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_33:
    unint64_t v14 = &v11[3 * v10];
    goto LABEL_12;
  }
  unint64_t v14 = v11;
  unint64_t v15 = v10;
  do
  {
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = v14[3 * (v15 >> 1) + 1];
    LODWORD(v17) = (v17 >> 1) & 3 | *(_DWORD *)((v17 & 0xFFFFFFFFFFFFFFF8) + 24);
    v15 -= (v15 >> 1) + 1;
    BOOL v18 = v13 >= v17;
    if (v13 >= v17) {
      unint64_t v19 = v16 + 1;
    }
    else {
      unint64_t v19 = 0;
    }
    v14 += 3 * v19;
    if (!v18) {
      unint64_t v15 = v16;
    }
  }
  while (v15);
LABEL_12:
  if (v14 == &v11[3 * v10]) {
    return v5;
  }
  unsigned int v20 = (v8 >> 1) & 3;
  unsigned int v21 = *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | v20;
  if (((*v14 >> 1) & 3 | *(_DWORD *)((*v14 & 0xFFFFFFFFFFFFFFF8) + 24)) > v21) {
    return v5;
  }
  uint64_t v22 = (void *)v14[2];
  if (!v22) {
    return v5;
  }
  uint64_t v23 = *(void *)(*(void *)a1 + 40);
  uint64_t v24 = *(void *)(*(void *)a1 + 56);
  unint64_t v25 = *(void *)(v24 + 16 * v4);
  if (v25 < 8 || *(void *)(v24 + 16 * v4 + 8) >= 8uLL)
  {
    unint64_t v25 = sub_1CC4754EC((void *)(*(void *)a1 + 48), v23, this);
    unsigned int v21 = *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24) | v20;
  }
  unsigned int v26 = (v25 >> 1) & 3 | *(_DWORD *)((v25 & 0xFFFFFFFFFFFFFFF8) + 24);
  if (v26 >= v21) {
    goto LABEL_30;
  }
  uint64_t v27 = *(void *)(*(void *)(a1 + 80) + 8);
  unint64_t v28 = *(unsigned int *)(v27 + 8);
  unint64_t v29 = *(void **)v27;
  if (!v28)
  {
    LODWORD(v28) = 0;
    goto LABEL_36;
  }
  uint64_t v30 = v29[3 * v28 - 2];
  if (v26 >= ((v30 >> 1) & 3 | *(_DWORD *)((v30 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_36:
    unsigned int v31 = &v29[3 * v28];
    goto LABEL_27;
  }
  unsigned int v31 = v29;
  unint64_t v32 = v28;
  do
  {
    unint64_t v33 = v32 >> 1;
    uint64_t v34 = v31[3 * (v32 >> 1) + 1];
    LODWORD(v34) = (v34 >> 1) & 3 | *(_DWORD *)((v34 & 0xFFFFFFFFFFFFFFF8) + 24);
    v32 -= (v32 >> 1) + 1;
    BOOL v35 = v26 >= v34;
    if (v26 >= v34) {
      unint64_t v36 = v33 + 1;
    }
    else {
      unint64_t v36 = 0;
    }
    v31 += 3 * v36;
    if (!v35) {
      unint64_t v32 = v33;
    }
  }
  while (v32);
LABEL_27:
  if (v31 != &v29[3 * v28]
    && ((*v31 >> 1) & 3 | *(_DWORD *)((*v31 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v26)
  {
    uint64_t v22 = (void *)v31[2];
    uint64_t v8 = v25;
    if (v22)
    {
LABEL_30:
      unsigned int v37 = *(_DWORD *)(a1 + 88);
      int v38 = (unint64_t *)sub_1CC475930((void *)(*(void *)a1 + 48), *(void *)(*(void *)a1 + 40), (unsigned int *)this);
      unint64_t v39 = sub_1CC4771B0((void *)a1, v37, v22, v8, (uint64_t)this, v38);
      sub_1CC4781D8(a1 + 200, *(void *)(v39 + 8), v5, *(_DWORD *)(a1 + 88));
      return *(void *)(v39 + 8);
    }
  }
  return v5;
}

void sub_1CC4781D8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v28[8] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 184) || (uint64_t v8 = *(unsigned int *)(a1 + 188), v8 == 9))
  {
    uint64_t v25 = a1;
    unsigned int v26 = v28;
    uint64_t v27 = 0x400000000;
    sub_1CC478B64((uint64_t)&v25, a2);
    uint64_t v7 = v25;
    if (!*(_DWORD *)(v25 + 184))
    {
      unsigned int v12 = sub_1CC47F504(v25, (_DWORD *)v26 + 4 * v27 - 1, *(unsigned int *)(v25 + 188), a2, a3, a4);
      if (v12 <= 9)
      {
        *(_DWORD *)(v7 + 188) = v12;
        *((_DWORD *)v26 + 2) = v12;
LABEL_4:
        if (v26 != v28) {
          free(v26);
        }
        return;
      }
      uint64_t v13 = sub_1CC47F93C(v7, *((_DWORD *)v26 + 4 * v27 - 1));
      int v14 = *(_DWORD *)(v7 + 188);
      unint64_t v15 = v26;
      *(void *)unsigned int v26 = v7 + 8;
      v15[2] = v14;
      void v15[3] = v13;
      unint64_t v16 = v26;
      unint64_t v17 = *(void *)(*(void *)v26 + 8 * *((unsigned int *)v26 + 3)) & 0xFFFFFFFFFFFFFFC0;
      unint64_t v18 = (v13 & 0xFFFFFFFF00000000 | *(void *)(*(void *)v26 + 8 * *((unsigned int *)v26 + 3)) & 0x3FLL) + 1;
      if (v27 == 1)
      {
        if (HIDWORD(v27) <= 1) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unint64_t v19 = (char *)v26 + 16;
        *((void *)v26 + 2) = v17;
        *((void *)v19 + 1) = v18;
        LODWORD(v27) = v27 + 1;
      }
      else
      {
        if (v27 >= HIDWORD(v27)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        unsigned int v20 = (char *)v26 + 16;
        *((_OWORD *)v26 + v27) = *((_OWORD *)v26 + v27 - 1);
        int v21 = v27;
        uint64_t v22 = (char *)v26 + 16 * v27 - 16;
        if (v22 != (char *)(v16 + 2))
        {
          unint64_t v23 = v18;
          uint64_t v24 = v16;
          memmove(v16 + 4, v20, v22 - (char *)(v16 + 2));
          unint64_t v16 = v24;
          unint64_t v18 = v23;
          int v21 = v27;
        }
        LODWORD(v27) = v21 + 1;
        v16[2] = v17;
        v16[3] = v18;
      }
    }
    sub_1CC47F648(&v25, a2, a3, a4);
    goto LABEL_4;
  }
  if (v8)
  {
    uint64_t v9 = 0;
    unint64_t v10 = (uint64_t *)(a1 + 8);
    while (1)
    {
      uint64_t v11 = *v10;
      v10 += 2;
      if (((v11 >> 1) & 3 | *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3)) {
        break;
      }
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(a1 + 188);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  LODWORD(v25) = v9;
  *(_DWORD *)(a1 + 188) = sub_1CC47F504(a1, &v25, v8, a2, a3, a4);
}

unint64_t sub_1CC47849C(unint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v4 = a2 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 8);
  unsigned int v6 = *(_DWORD *)(v5 + 8);
  uint64_t v7 = *(void **)v5;
  if (!v6)
  {
    unsigned int v6 = 0;
    goto LABEL_40;
  }
  uint64_t v8 = v7[3 * v6 - 2];
  unsigned int v9 = *(_DWORD *)(v4 + 24) | 3;
  if (v9 >= ((v8 >> 1) & 3 | *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_40:
    unint64_t v10 = &v7[3 * v6];
    goto LABEL_10;
  }
  unint64_t v10 = *(void **)v5;
  unint64_t v11 = *(unsigned int *)(v5 + 8);
  do
  {
    unint64_t v12 = v11 >> 1;
    uint64_t v13 = v10[3 * (v11 >> 1) + 1];
    LODWORD(v13) = (v13 >> 1) & 3 | *(_DWORD *)((v13 & 0xFFFFFFFFFFFFFFF8) + 24);
    v11 -= (v11 >> 1) + 1;
    BOOL v14 = v9 >= v13;
    if (v9 >= v13) {
      unint64_t v15 = v12 + 1;
    }
    else {
      unint64_t v15 = 0;
    }
    v10 += 3 * v15;
    if (!v14) {
      unint64_t v11 = v12;
    }
  }
  while (v11);
LABEL_10:
  if (v10 == &v7[3 * v6]) {
    return *(void *)(v4 + 8) & 0xFFFFFFFFFFFFFFF9;
  }
  if (((*v10 >> 1) & 3 | *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)(v4 + 24) | 3u)) {
    return *(void *)(v4 + 8) & 0xFFFFFFFFFFFFFFF9;
  }
  unint64_t v16 = (void *)v10[2];
  if (!v16) {
    return *(void *)(v4 + 8) & 0xFFFFFFFFFFFFFFF9;
  }
  uint64_t v17 = v4 | 6;
  if ((v4 | 6) < 8) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)(v4 + 16);
  }
  if (!*(_DWORD *)(a1 + 92)) {
    goto LABEL_36;
  }
  if ((v16[1] & 0xFFFFFFFFFFFFFFF8) == v4) {
    goto LABEL_36;
  }
  uint64_t v19 = *(unsigned int *)(v18 + 40);
  if (!v19) {
    goto LABEL_36;
  }
  int v20 = 0;
  char v21 = 0;
  int v22 = 0;
  int v23 = *(_DWORD *)(v5 + 112);
  uint64_t v24 = (_DWORD *)(*(void *)(v18 + 32) + 4);
  do
  {
    unsigned int v25 = *(v24 - 1);
    if (!(_BYTE)v25 && *v24 == v23)
    {
      int v26 = (v25 >> 28) & 1;
      if ((v25 & 0xFFF00) == 0) {
        int v26 = 1;
      }
      int v27 = v26 | v22;
      int v28 = v26 ^ 1 | v20;
      if ((v25 & 0x1000000) != 0) {
        int v22 = v27;
      }
      else {
        v21 |= (v25 & 0x10000000) == 0;
      }
      if ((v25 & 0x1000000) != 0) {
        int v20 = v28;
      }
    }
    v24 += 8;
    --v19;
  }
  while (v19);
  if ((v21 & 1) != 0 || ((v20 ^ 1 | v22) & 1) == 0)
  {
    sub_1CC476FDC(a1, 0, *(unsigned int *)v16);
    sub_1CC4771B0((void *)a1, 0, v16, v2, *(void *)(v18 + 24), (unint64_t *)v18);
  }
  else
  {
LABEL_36:
    uint64_t v30 = *(void *)(v18 + 24);
    if ((*(unsigned char *)v18 & 4) == 0)
    {
      while ((*(_WORD *)(v18 + 44) & 8) != 0)
        uint64_t v18 = *(void *)(v18 + 8);
    }
    return *(void *)(sub_1CC4771B0((void *)a1, 0, v16, v17, v30, *(unint64_t **)(v18 + 8)) + 8);
  }
  return v2;
}

uint64_t sub_1CC4786D0(void *a1, uint64_t a2)
{
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v3 = *(void *)(a1[10] + 8);
  unint64_t v4 = *(unsigned int *)(v3 + 8);
  uint64_t v5 = *(void **)v3;
  if (!v4)
  {
    LODWORD(v4) = 0;
    goto LABEL_19;
  }
  uint64_t v6 = v5[3 * v4 - 2];
  unsigned int v7 = *(_DWORD *)(v2 + 24);
  if (v7 >= ((v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_19:
    uint64_t v8 = &v5[3 * v4];
    goto LABEL_10;
  }
  uint64_t v8 = v5;
  unint64_t v9 = v4;
  do
  {
    unint64_t v10 = v9 >> 1;
    uint64_t v11 = v8[3 * (v9 >> 1) + 1];
    LODWORD(v11) = (v11 >> 1) & 3 | *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 24);
    v9 -= (v9 >> 1) + 1;
    BOOL v12 = v7 >= v11;
    if (v7 >= v11) {
      unint64_t v13 = v10 + 1;
    }
    else {
      unint64_t v13 = 0;
    }
    v8 += 3 * v13;
    if (!v12) {
      unint64_t v9 = v10;
    }
  }
  while (v9);
LABEL_10:
  if (v8 == &v5[3 * v4]) {
    return v2 | 2;
  }
  if (((*v8 >> 1) & 3 | *(_DWORD *)((*v8 & 0xFFFFFFFFFFFFFFF8) + 24)) > *(_DWORD *)(v2 + 24)) {
    return v2 | 2;
  }
  BOOL v14 = (void *)v8[2];
  if (!v14) {
    return v2 | 2;
  }
  if (v2) {
    uint64_t v15 = *(void *)(v2 + 16);
  }
  else {
    uint64_t v15 = 0;
  }
  return *(void *)(sub_1CC4771B0(a1, 0, v14, v2, *(void *)(v15 + 24), (unint64_t *)v15) + 8);
}

uint64_t sub_1CC4787D8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392) + 16 * *(unsigned int *)(a2 + 24));
  uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 8);
  unint64_t v6 = *(unsigned int *)(v5 + 8);
  unsigned int v7 = *(void **)v5;
  if (!v6)
  {
    LODWORD(v6) = 0;
    goto LABEL_16;
  }
  uint64_t v8 = v7[3 * v6 - 2];
  unsigned int v9 = *(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24) | (v4 >> 1) & 3;
  if (v9 >= ((v8 >> 1) & 3 | *(_DWORD *)((v8 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_16:
    unint64_t v10 = &v7[3 * v6];
    goto LABEL_10;
  }
  unint64_t v10 = v7;
  unint64_t v11 = v6;
  do
  {
    unint64_t v12 = v11 >> 1;
    uint64_t v13 = v10[3 * (v11 >> 1) + 1];
    LODWORD(v13) = (v13 >> 1) & 3 | *(_DWORD *)((v13 & 0xFFFFFFFFFFFFFFF8) + 24);
    v11 -= (v11 >> 1) + 1;
    BOOL v14 = v9 >= v13;
    if (v9 >= v13) {
      unint64_t v15 = v12 + 1;
    }
    else {
      unint64_t v15 = 0;
    }
    v10 += 3 * v15;
    if (!v14) {
      unint64_t v11 = v12;
    }
  }
  while (v11);
LABEL_10:
  if (v10 != &v7[3 * v6]
    && ((*v10 >> 1) & 3 | *(_DWORD *)((*v10 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((v4 & 0xFFFFFFFFFFFFFFF8) + 24) | (v4 >> 1) & 3))
  {
    unint64_t v16 = (void *)v10[2];
    if (v16)
    {
      uint64_t v17 = (unint64_t *)llvm::MachineBasicBlock::SkipPHIsLabelsAndDebug(a2, *(void *)(a2 + 56), 1);
      unint64_t v18 = sub_1CC4771B0((void *)a1, 0, v16, v4, a2, v17);
      sub_1CC4781D8(a1 + 200, v4, *(void *)(v18 + 8), *(_DWORD *)(a1 + 88));
      return *(void *)(v18 + 8);
    }
  }
  return v4;
}

void sub_1CC478948(unint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 80) + 8);
  unint64_t v7 = *(unsigned int *)(v6 + 8);
  uint64_t v8 = *(void **)v6;
  if (!v7)
  {
    LODWORD(v7) = 0;
    goto LABEL_12;
  }
  uint64_t v9 = v8[3 * v7 - 2];
  unsigned int v10 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3;
  if (v10 >= ((v9 >> 1) & 3 | *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
LABEL_12:
    unint64_t v11 = &v8[3 * v7];
    goto LABEL_13;
  }
  unint64_t v11 = v8;
  unint64_t v12 = v7;
  do
  {
    unint64_t v13 = v12 >> 1;
    uint64_t v14 = v11[3 * (v12 >> 1) + 1];
    LODWORD(v14) = (v14 >> 1) & 3 | *(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24);
    v12 -= (v12 >> 1) + 1;
    BOOL v15 = v10 >= v14;
    if (v10 >= v14) {
      unint64_t v16 = v13 + 1;
    }
    else {
      unint64_t v16 = 0;
    }
    v11 += 3 * v16;
    if (!v15) {
      unint64_t v12 = v13;
    }
  }
  while (v12);
LABEL_13:
  if (v11 != &v8[3 * v7]
    && ((*v11 >> 1) & 3 | *(_DWORD *)((*v11 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3))
  {
    uint64_t v17 = (unsigned int *)v11[2];
    if (v17) {
      sub_1CC476FDC(a1, 0, *v17);
    }
  }
  if (a3 < 8) {
    goto LABEL_29;
  }
  uint64_t v18 = *(void *)((a3 & 0xFFFFFFFFFFFFFFF8) + 16);
  if (!v18) {
    goto LABEL_29;
  }
  uint64_t v19 = *(void *)(v18 + 32);
  uint64_t v20 = *(void *)(v18 + 16);
  unsigned int v21 = *(unsigned __int8 *)(v20 + 4);
  if ((*(unsigned char *)(v20 + 8) & 2) == 0 || (int v27 = *(_DWORD *)(v18 + 40), v27 == v21))
  {
    unsigned int v22 = *(unsigned __int8 *)(v20 + 4);
  }
  else
  {
    int v28 = v27 - 1;
    unsigned int v22 = v21;
    do
    {
      int v29 = *(_DWORD *)(v19 + 32 * v21);
      if ((v29 & 0x10000FF) != 0x1000000) {
        break;
      }
      v22 += (v29 & 0x2000000) == 0;
      if (v28 == v21) {
        break;
      }
      ++v21;
    }
    while ((v29 & 0x2000000) == 0);
  }
  if (v22)
  {
    uint64_t v23 = 32 * v22;
    uint64_t v24 = (_DWORD *)(v19 + 4);
    while (1)
    {
      BOOL v25 = *(v24 - 1) || (*(v24 - 1) & 0xF00000) == 0;
      if (!v25 && *v24 == *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 112)) {
        break;
      }
      v24 += 8;
      v23 -= 32;
      if (!v23) {
        goto LABEL_29;
      }
    }
  }
  else
  {
LABEL_29:
    int v26 = *(_DWORD *)(a1 + 88);
    sub_1CC4781D8(a1 + 200, a2, a3, v26);
  }
}

uint64_t sub_1CC478B64(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)result;
  if (*(_DWORD *)(*(void *)result + 184))
  {
    uint64_t v3 = v2 + 8;
    uint64_t v4 = *(unsigned int *)(v2 + 188);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = v2 + 96;
      while (((*(void *)(v6 + 8 * v5) >> 1) & 3 | *(_DWORD *)((*(void *)(v6 + 8 * v5) & 0xFFFFFFFFFFFFFFF8)
                                                                             + 24)) <= (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8)
                                                                                                  + 24) | (a2 >> 1) & 3))
      {
        if (v4 == ++v5)
        {
          uint64_t v5 = v4;
          break;
        }
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
    *(_DWORD *)(result + 16) = 0;
    if (!*(_DWORD *)(result + 20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = v4 | (v5 << 32);
    uint64_t v8 = *(void **)(result + 8);
    void *v8 = v3;
    v8[1] = v7;
    int v9 = *(_DWORD *)(result + 16);
    *(_DWORD *)(result + 16) = v9 + 1;
    if (v9 != -1 && *(_DWORD *)(*(void *)(result + 8) + 12) < *(_DWORD *)(*(void *)(result + 8) + 8))
    {
      return sub_1CC481060(result, a2);
    }
  }
  else
  {
    uint64_t v10 = *(unsigned int *)(v2 + 188);
    if (v10)
    {
      uint64_t v11 = 0;
      unint64_t v12 = (uint64_t *)(v2 + 8);
      while (1)
      {
        uint64_t v13 = *v12;
        v12 += 2;
        if (((v13 >> 1) & 3 | *(_DWORD *)((v13 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3)) {
          break;
        }
        if (v10 == ++v11)
        {
          uint64_t v11 = *(unsigned int *)(v2 + 188);
          break;
        }
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    *(_DWORD *)(result + 16) = 0;
    if (!*(_DWORD *)(result + 20)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v14 = v10 | (v11 << 32);
    BOOL v15 = *(void **)(result + 8);
    *BOOL v15 = v2;
    v15[1] = v14;
    ++*(_DWORD *)(result + 16);
  }
  return result;
}

void sub_1CC478D3C(uint64_t a1, uint64_t a2, uint64_t a3, llvm::LiveRangeCalc *a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  if (a2 != a3)
  {
    for (uint64_t i = a2; i != a3; i += 8)
    {
      unint64_t v16 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392)
                      + 16 * *(unsigned int *)(*(void *)i + 24)
                      + 8);
      unsigned int v17 = (v16 >> 1) & 3;
      unint64_t v18 = v16 & 0xFFFFFFFFFFFFFFF8;
      if (v17) {
        uint64_t v19 = v18 | (2 * (v17 - 1));
      }
      else {
        uint64_t v19 = *(void *)v18 | 6;
      }
      uint64_t v20 = *(void *)(*(void *)(a1 + 80) + 8);
      if (a6 != -1)
      {
        uint64_t v21 = *(void *)(v20 + 104);
        do
        {
          uint64_t v20 = v21;
          if (*(void *)(v21 + 112) == a6) {
            break;
          }
          uint64_t v21 = *(void *)(v21 + 104);
        }
        while (v21);
      }
      unint64_t v22 = *(unsigned int *)(v20 + 8);
      uint64_t v23 = *(void **)v20;
      if (v22)
      {
        uint64_t v24 = v23[3 * v22 - 2];
        unsigned int v25 = *(_DWORD *)((v19 & 0xFFFFFFFFFFFFFFF8) + 24) | (v19 >> 1) & 3;
        unsigned int v26 = (v24 >> 1) & 3 | *(_DWORD *)((v24 & 0xFFFFFFFFFFFFFFF8) + 24);
        int v27 = v23;
        unint64_t v28 = v22;
        if (v25 < v26)
        {
          do
          {
            unint64_t v29 = v28 >> 1;
            uint64_t v30 = v27[3 * (v28 >> 1) + 1];
            LODWORD(v30) = (v30 >> 1) & 3 | *(_DWORD *)((v30 & 0xFFFFFFFFFFFFFFF8) + 24);
            v28 -= (v28 >> 1) + 1;
            BOOL v31 = v25 >= v30;
            if (v25 >= v30) {
              unint64_t v32 = v29 + 1;
            }
            else {
              unint64_t v32 = 0;
            }
            v27 += 3 * v32;
            if (!v31) {
              unint64_t v28 = v29;
            }
          }
          while (v28);
          goto LABEL_17;
        }
      }
      else
      {
        LODWORD(v22) = 0;
      }
      int v27 = &v23[3 * v22];
LABEL_17:
      if (v27 != &v23[3 * v22]
        && ((*v27 >> 1) & 3 | *(_DWORD *)((*v27 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((v19 & 0xFFFFFFFFFFFFFFF8) + 24) | (v19 >> 1) & 3))
      {
        llvm::LiveRangeCalc::extend(a4, a5, v16, 0, a7, a8);
      }
    }
  }
}

uint64_t sub_1CC478EF8(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  uint64_t v4 = *(void *)a2;
  if (!v3)
  {
    unint64_t v13 = 0;
    goto LABEL_13;
  }
  uint64_t v5 = *(void *)(v4 + 24 * v3 - 16);
  unsigned int v6 = *(_DWORD *)((a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (a1 >> 1) & 3;
  if (v6 >= ((v5 >> 1) & 3 | *(_DWORD *)((v5 & 0xFFFFFFFFFFFFFFF8) + 24)))
  {
    unint64_t v13 = *(unsigned int *)(a2 + 8);
LABEL_13:
    uint64_t v7 = (char *)(v4 + 24 * v13);
    goto LABEL_14;
  }
  uint64_t v7 = *(char **)a2;
  unint64_t v8 = *(unsigned int *)(a2 + 8);
  do
  {
    unint64_t v9 = v8 >> 1;
    uint64_t v10 = *(void *)&v7[24 * (v8 >> 1) + 8];
    LODWORD(v10) = (v10 >> 1) & 3 | *(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8) + 24);
    v8 -= (v8 >> 1) + 1;
    BOOL v11 = v6 >= v10;
    if (v6 >= v10) {
      unint64_t v12 = v9 + 1;
    }
    else {
      unint64_t v12 = 0;
    }
    v7 += 24 * v12;
    if (!v11) {
      unint64_t v8 = v9;
    }
  }
  while (v8);
  unint64_t v13 = *(unsigned int *)(a2 + 8);
LABEL_14:
  uint64_t v14 = (char *)(v4 + 24 * v13);
  if (v7 == v14) {
    return 1;
  }
  uint64_t v15 = *(void *)v7;
  unsigned int v16 = (*(void *)v7 >> 1) & 3 | *(_DWORD *)((*(void *)v7 & 0xFFFFFFFFFFFFFFF8) + 24);
  if (v16 > (*(_DWORD *)((a1 & 0xFFFFFFFFFFFFFFF8) + 24) | (a1 >> 1) & 3)) {
    return 1;
  }
  unint64_t v18 = a1 & 0xFFFFFFFFFFFFFFF8 | 6;
  if (*((void *)v7 + 1) == v18)
  {
    if (v3)
    {
      uint64_t v19 = (void *)(v4 + 24 * v13);
      if (v16 < ((*((void *)v14 - 2) >> 1) & 3 | *(_DWORD *)((*((void *)v14 - 2) & 0xFFFFFFFFFFFFFFF8)
                                                                            + 24)))
      {
        uint64_t v19 = *(void **)a2;
        do
        {
          unint64_t v20 = v13 >> 1;
          uint64_t v21 = v19[3 * (v13 >> 1) + 1];
          LODWORD(v21) = (v21 >> 1) & 3 | *(_DWORD *)((v21 & 0xFFFFFFFFFFFFFFF8) + 24);
          v13 -= (v13 >> 1) + 1;
          BOOL v22 = v16 >= v21;
          if (v16 >= v21) {
            unint64_t v23 = v20 + 1;
          }
          else {
            unint64_t v23 = 0;
          }
          v19 += 3 * v23;
          if (!v22) {
            unint64_t v13 = v20;
          }
        }
        while (v13);
      }
    }
    else
    {
      uint64_t v19 = (void *)(v4 + 24 * v13);
    }
    uint64_t v24 = v19[1];
    uint64_t v25 = v19[2];
    if (*v19 == v15)
    {
      if (v24 == v18)
      {
        if (v14 != (char *)(v19 + 3))
        {
          memmove(v19, v19 + 3, v14 - (char *)(v19 + 3));
          unsigned int v3 = *(_DWORD *)(a2 + 8);
        }
        *(_DWORD *)(a2 + 8) = v3 - 1;
        llvm::LiveRange::removeValNoIfDead(a2, v25);
      }
      else
      {
        *uint64_t v19 = v18;
      }
    }
    else
    {
      v19[1] = v15;
      if (v24 != v18)
      {
        v26[0] = v18;
        v26[1] = v24;
        v26[2] = v25;
        sub_1CC2FC960((uint64_t *)a2, (unint64_t)(v19 + 3), (unint64_t)v26);
      }
    }
    return 1;
  }
  return 0;
}

void sub_1CC4790F8(unint64_t a1, uint64_t a2)
{
  uint64_t v1031 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 72);
  if (!v3) {
    goto LABEL_46;
  }
  uint64_t v4 = *(unsigned int ***)(v2 + 64);
  uint64_t v5 = &v4[v3];
  unsigned int v6 = (void *)(a1 + 200);
  unint64_t v7 = a1 + 208;
  do
  {
    unint64_t v8 = *v4;
    unint64_t v9 = *((void *)*v4 + 1);
    if (v9 < 8) {
      goto LABEL_23;
    }
    int v10 = *(_DWORD *)(a1 + 388);
    if (!v10) {
      goto LABEL_38;
    }
    unsigned int v11 = *(_DWORD *)((v9 & 0xFFFFFFFFFFFFFFF8) + 24) | (v9 >> 1) & 3;
    if (v11 < ((*v6 >> 1) & 3 | *(_DWORD *)((*v6 & 0xFFFFFFFFFFFFFFF8) + 24))) {
      goto LABEL_38;
    }
    unsigned int v12 = *(_DWORD *)(a1 + 384);
    unsigned int v13 = v10 - 1;
    uint64_t v14 = (uint64_t)&v6[2 * v13 + 1];
    uint64_t v15 = (void *)(v7 + 8 * v13 + 88);
    if (!v12) {
      uint64_t v15 = (void *)v14;
    }
    if (((*v15 >> 1) & 3 | *(_DWORD *)((*v15 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v11)
    {
LABEL_38:
      unsigned int v19 = 0;
      goto LABEL_13;
    }
    if (v12)
    {
      unsigned int v19 = sub_1CC481228((uint64_t)v6, *((void *)*v4 + 1));
    }
    else
    {
      do
      {
        unsigned int v16 = v12;
        uint64_t v17 = v6[2 * v12 + 1];
        unsigned int v18 = (v17 >> 1) & 3 | *(_DWORD *)((v17 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v12 = v16 + 1;
      }
      while (v18 <= v11);
      if (v11 < ((v6[2 * v16] >> 1) & 3 | *(_DWORD *)((v6[2 * v16] & 0xFFFFFFFFFFFFFFF8) + 24))) {
        goto LABEL_38;
      }
      unsigned int v19 = *((_DWORD *)v6 + v16 + 36);
    }
LABEL_13:
    sub_1CC476CC8(a1, v19, v8, v9, 1);
    uint64_t v20 = *(void *)(a1 + 80);
    uint64_t v22 = *(void *)(v20 + 144);
    uint64_t v21 = *(void *)(v20 + 152);
    if (v21 == v22)
    {
      uint64_t v23 = *(unsigned int *)(v20 + 164);
      uint64_t v24 = (unsigned int **)(v21 + 8 * v23);
      if (v23)
      {
        uint64_t v25 = 0;
        uint64_t v26 = 8 * v23;
        while (*(unsigned int **)(v21 + v25) != v8)
        {
          v25 += 8;
          if (v26 == v25) {
            goto LABEL_18;
          }
        }
        uint64_t v24 = (unsigned int **)(v21 + v25);
      }
LABEL_18:
      uint64_t v22 = *(void *)(v20 + 152);
    }
    else
    {
      uint64_t v28 = *(unsigned int *)(v20 + 160);
      int v29 = v28 - 1;
      unsigned int v30 = (v28 - 1) & ((v8 >> 4) ^ (v8 >> 9));
      uint64_t v24 = (unsigned int **)(v21 + 8 * v30);
      BOOL v31 = *v24;
      if (*v24 == (unsigned int *)-1)
      {
        unint64_t v32 = 0;
LABEL_40:
        if (v32) {
          uint64_t v24 = v32;
        }
        if (*v24 != v8) {
          uint64_t v24 = (unsigned int **)(v21 + 8 * v28);
        }
      }
      else
      {
        unint64_t v32 = 0;
        int v33 = 1;
        while (v31 != v8)
        {
          if (v32) {
            BOOL v34 = 0;
          }
          else {
            BOOL v34 = v31 == (unsigned int *)-2;
          }
          if (v34) {
            unint64_t v32 = v24;
          }
          unsigned int v35 = v30 + v33++;
          unsigned int v30 = v35 & v29;
          uint64_t v24 = (unsigned int **)(v21 + 8 * (v35 & v29));
          BOOL v31 = *v24;
          if (*v24 == (unsigned int *)-1) {
            goto LABEL_40;
          }
        }
      }
    }
    if (v21 == v22) {
      uint64_t v27 = 164;
    }
    else {
      uint64_t v27 = 160;
    }
    if (v24 == (unsigned int **)(v21 + 8 * *(unsigned int *)(v20 + v27))) {
      goto LABEL_23;
    }
    if ((v8[2] & 6) != 0)
    {
      int v640 = *(_DWORD *)(*(void *)(v20 + 16) + 8);
      int v641 = *(_DWORD *)(v20 + 64);
      int v642 = v640 - v641;
      if (v640 != v641)
      {
        unsigned int v36 = 0;
        do
          sub_1CC476FDC(a1, v36++, *v8);
        while (v642 != v36);
      }
      goto LABEL_23;
    }
    *(void *)&long long v981 = &v983;
    *((void *)&v981 + 1) = &v983;
    DWORD2(v982) = 0;
    *(void *)&long long v1028 = v1029;
    HIDWORD(v1028) = 4;
    *(void *)&long long v982 = 0x100000008;
    *(void *)&long long v983 = v8;
    uint64_t v853 = *(void *)(*(void *)(a1 + 16) + 288);
    *(void *)&v1029[0] = v8;
    uint64_t v963 = *(void *)(v20 + 8);
    uint64_t v966 = v853;
    unsigned int v854 = 1;
    do
    {
      v855 = *(unsigned int **)(v1028 + 8 * v854 - 8);
      DWORD2(v1028) = v854 - 1;
      uint64_t v856 = *(void *)(a1 + 80);
      int v857 = *(_DWORD *)(*(void *)(v856 + 16) + 8);
      LODWORD(v856) = *(_DWORD *)(v856 + 64);
      int v858 = v857 - v856;
      if (v857 != v856)
      {
        unsigned int v859 = 0;
        do
          sub_1CC476FDC(a1, v859++, *v855);
        while (v858 != v859);
      }
      unint64_t v860 = *((void *)v855 + 1);
      if ((v860 & 6) == 0)
      {
        if (v860 >= 8 && (uint64_t v861 = *(void *)((v860 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
        {
          v862 = (uint64_t *)(v861 + 24);
        }
        else
        {
          uint64_t v922 = *(unsigned int *)(v966 + 544);
          if (v922)
          {
            unsigned int v923 = *(_DWORD *)((v860 & 0xFFFFFFFFFFFFFFF8) + 24) | (v860 >> 1) & 3;
            v902 = *(void **)(v966 + 536);
            unint64_t v901 = *(unsigned int *)(v966 + 544);
            do
            {
              unint64_t v897 = v901 >> 1;
              v898 = &v902[2 * (v901 >> 1)];
              uint64_t v900 = *v898;
              v899 = v898 + 2;
              v901 += ~(v901 >> 1);
              if (((v900 >> 1) & 3 | *(_DWORD *)((v900 & 0xFFFFFFFFFFFFFFF8) + 24)) < v923) {
                v902 = v899;
              }
              else {
                unint64_t v901 = v897;
              }
            }
            while (v901);
            if (v902 == (void *)(*(void *)(v966 + 536) + 16 * v922)
              || ((*v902 >> 1) & 3 | *(_DWORD *)((*v902 & 0xFFFFFFFFFFFFFFF8) + 24)) > v923)
            {
              v902 -= 2;
            }
          }
          else
          {
            v902 = *(void **)(v966 + 536);
          }
          v862 = v902 + 1;
        }
        uint64_t v863 = *v862;
        uint64_t v865 = *(void *)(v863 + 64);
        uint64_t v864 = *(void *)(v863 + 72);
        while (1)
        {
          if (v865 == v864) {
            goto LABEL_1110;
          }
          uint64_t v866 = *(void *)(*(void *)(v966 + 392) + 16 * *(unsigned int *)(*(void *)v865 + 24) + 8);
          unsigned int v867 = (v866 >> 1) & 3;
          unint64_t v868 = v866 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v869 = v867 ? v868 | (2 * (v867 - 1)) : *(void *)v868 | 6;
          unsigned int v870 = *(_DWORD *)(v963 + 8);
          v871 = *(void **)v963;
          if (!v870) {
            break;
          }
          uint64_t v872 = v871[3 * v870 - 2];
          unsigned int v873 = *(_DWORD *)((v869 & 0xFFFFFFFFFFFFFFF8) + 24) | (v869 >> 1) & 3;
          unsigned int v874 = (v872 >> 1) & 3 | *(_DWORD *)((v872 & 0xFFFFFFFFFFFFFFF8) + 24);
          v875 = *(void **)v963;
          unint64_t v876 = *(unsigned int *)(v963 + 8);
          if (v873 >= v874) {
            goto LABEL_1167;
          }
          do
          {
            unint64_t v877 = v876 >> 1;
            uint64_t v878 = v875[3 * (v876 >> 1) + 1];
            LODWORD(v878) = (v878 >> 1) & 3 | *(_DWORD *)((v878 & 0xFFFFFFFFFFFFFFF8) + 24);
            v876 -= (v876 >> 1) + 1;
            BOOL v879 = v873 >= v878;
            if (v873 >= v878) {
              unint64_t v880 = v877 + 1;
            }
            else {
              unint64_t v880 = 0;
            }
            v875 += 3 * v880;
            if (!v879) {
              unint64_t v876 = v877;
            }
          }
          while (v876);
LABEL_1127:
          if (v875 == &v871[3 * v870]
            || ((*v875 >> 1) & 3 | *(_DWORD *)((*v875 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((v869 & 0xFFFFFFFFFFFFFFF8) + 24) | (v869 >> 1) & 3))
          {
            uint64_t v881 = 0;
          }
          else
          {
            uint64_t v881 = v875[2];
          }
          uint64_t v882 = *((void *)&v981 + 1);
          uint64_t v883 = DWORD1(v982);
          if (*((void *)&v981 + 1) == (void)v981)
          {
            if (DWORD1(v982))
            {
              v884 = 0;
              uint64_t v885 = 8 * DWORD1(v982);
              v886 = (void *)*((void *)&v981 + 1);
              while (*v886 != v881)
              {
                if (*v886 == -2) {
                  v884 = v886;
                }
                ++v886;
                v885 -= 8;
                if (!v885)
                {
                  if (!v884) {
                    goto LABEL_1138;
                  }
                  void *v884 = v881;
                  --DWORD2(v982);
                  goto LABEL_1140;
                }
              }
              goto LABEL_1142;
            }
LABEL_1138:
            unsigned int v887 = v982;
            if (DWORD1(v982) < v982)
            {
              ++DWORD1(v982);
              *(void *)(*((void *)&v981 + 1) + 8 * v883) = v881;
LABEL_1140:
              if (DWORD2(v1028) >= (unint64_t)HIDWORD(v1028)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(v1028 + 8 * DWORD2(v1028)) = v881;
              ++DWORD2(v1028);
              goto LABEL_1142;
            }
          }
          else
          {
            unsigned int v887 = v982;
          }
          if (3 * v887 <= 4 * (DWORD1(v982) - DWORD2(v982)))
          {
            if (v887 >= 0x40) {
              v887 *= 2;
            }
            else {
              unsigned int v887 = 128;
            }
          }
          else if (v887 - DWORD1(v982) >= v887 >> 3)
          {
            goto LABEL_1147;
          }
          uint64_t v959 = v864;
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v981, v887);
          uint64_t v864 = v959;
          unsigned int v887 = v982;
          uint64_t v882 = *((void *)&v981 + 1);
LABEL_1147:
          unsigned int v888 = v887 - 1;
          unsigned int v889 = (v887 - 1) & ((v881 >> 4) ^ (v881 >> 9));
          v890 = (void *)(v882 + 8 * v889);
          uint64_t v891 = *v890;
          if (*v890 == -1)
          {
            v892 = 0;
LABEL_1159:
            if (v892) {
              v896 = v892;
            }
            else {
              v896 = v890;
            }
            if (*v896 != v881)
            {
              if (*v896 == -2) {
                --DWORD2(v982);
              }
              else {
                ++DWORD1(v982);
              }
              void *v896 = v881;
              goto LABEL_1140;
            }
          }
          else
          {
            v892 = 0;
            int v893 = 1;
            while (v891 != v881)
            {
              if (v892) {
                BOOL v894 = 0;
              }
              else {
                BOOL v894 = v891 == -2;
              }
              if (v894) {
                v892 = v890;
              }
              unsigned int v895 = v889 + v893++;
              unsigned int v889 = v895 & v888;
              v890 = (void *)(v882 + 8 * (v895 & v888));
              uint64_t v891 = *v890;
              if (*v890 == -1) {
                goto LABEL_1159;
              }
            }
          }
LABEL_1142:
          v865 += 8;
        }
        unsigned int v870 = 0;
LABEL_1167:
        v875 = &v871[3 * v870];
        goto LABEL_1127;
      }
LABEL_1110:
      unsigned int v854 = DWORD2(v1028);
    }
    while (DWORD2(v1028));
    if ((_OWORD *)v1028 != v1029) {
      free((void *)v1028);
    }
    if (*((void *)&v981 + 1) != (void)v981) {
      free(*((void **)&v981 + 1));
    }
LABEL_23:
    ++v4;
  }
  while (v4 != v5);
LABEL_46:
  unint64_t v37 = a1;
  int v38 = dword_1CD912700 + 30976;
  if ((*(_DWORD *)(a1 + 92) - 1) >= 2) {
    goto LABEL_206;
  }
  uint64_t v39 = *(void *)(a1 + 16);
  uint64_t v40 = *(void *)(a1 + 80);
  unint64_t v41 = *(_DWORD *)(**(void **)(v40 + 16) + 4 * *(unsigned int *)(v40 + 64)) & 0x7FFFFFFF;
  uint64_t v42 = (void *)(v39 + 408);
  unint64_t v43 = *(unsigned int *)(v39 + 416);
  BOOL v64 = v41 >= v43;
  unint64_t v44 = v41 - v43;
  if (v64)
  {
    sub_1CB9153B8((uint64_t)v42, v44 + 1, *(void *)(v39 + 424));
LABEL_1245:
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v45 = *(void *)(*v42 + 8 * v41);
  if (!v45) {
    goto LABEL_1245;
  }
  uint64_t v46 = *(void *)(v40 + 8);
  uint64_t v47 = *(unsigned int *)(v46 + 72);
  *(void *)&long long v1028 = v1029;
  HIDWORD(v1028) = 8;
  uint64_t v964 = v46;
  if (v47 >= 9)
  {
    DWORD2(v1028) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v47)
  {
    bzero(v1029, 16 * v47);
    unsigned int v48 = *(_DWORD *)(v46 + 72);
  }
  else
  {
    unsigned int v48 = 0;
  }
  DWORD2(v1028) = v47;
  v974[0] = v975;
  v974[1] = (void *)0x800000000;
  sub_1CC248708((uint64_t)v974, v48, 0);
  uint64_t v968 = 0;
  uint64_t v969 = 0;
  int v970 = 0;
  uint64_t v49 = *(unsigned int *)(v45 + 72);
  if (v49)
  {
    uint64_t v50 = *(void *)(v45 + 64);
    uint64_t v51 = v50 + 8 * v49;
    while (2)
    {
      unint64_t v52 = *(void *)(*(void *)v50 + 8);
      if (v52 < 8) {
        goto LABEL_89;
      }
      uint64_t v53 = *(void *)(a1 + 80);
      uint64_t v54 = *(void *)(v53 + 8);
      unint64_t v55 = *(unsigned int *)(v54 + 8);
      unsigned int v56 = *(void **)v54;
      if (v55)
      {
        uint64_t v57 = v56[3 * v55 - 2];
        unsigned int v58 = *(_DWORD *)((v52 & 0xFFFFFFFFFFFFFFF8) + 24) | (v52 >> 1) & 3;
        unsigned int v59 = (v57 >> 1) & 3 | *(_DWORD *)((v57 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v60 = v56;
        unint64_t v61 = v55;
        if (v58 < v59)
        {
          do
          {
            unint64_t v62 = v61 >> 1;
            uint64_t v63 = v60[3 * (v61 >> 1) + 1];
            LODWORD(v63) = (v63 >> 1) & 3 | *(_DWORD *)((v63 & 0xFFFFFFFFFFFFFFF8) + 24);
            v61 -= (v61 >> 1) + 1;
            BOOL v64 = v58 >= v63;
            if (v58 >= v63) {
              unint64_t v65 = v62 + 1;
            }
            else {
              unint64_t v65 = 0;
            }
            v60 += 3 * v65;
            if (!v64) {
              unint64_t v61 = v62;
            }
          }
          while (v61);
          goto LABEL_63;
        }
      }
      else
      {
        LODWORD(v55) = 0;
      }
      unsigned int v60 = &v56[3 * v55];
LABEL_63:
      if (v60 == &v56[3 * v55]
        || ((*v60 >> 1) & 3 | *(_DWORD *)((*v60 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((v52 & 0xFFFFFFFFFFFFFFF8) + 24) | (v52 >> 1) & 3))
      {
        unint64_t v66 = 0;
      }
      else
      {
        unint64_t v66 = (unsigned int *)v60[2];
      }
      uint64_t v68 = *(void *)(v53 + 144);
      uint64_t v67 = *(void *)(v53 + 152);
      if (v67 == v68)
      {
        uint64_t v69 = *(unsigned int *)(v53 + 164);
        uint64_t v70 = (unsigned int **)(v67 + 8 * v69);
        if (v69)
        {
          uint64_t v71 = 0;
          uint64_t v72 = 8 * v69;
          while (*(unsigned int **)(v67 + v71) != v66)
          {
            v71 += 8;
            if (v72 == v71) {
              goto LABEL_71;
            }
          }
          uint64_t v70 = (unsigned int **)(v67 + v71);
        }
LABEL_71:
        uint64_t v68 = *(void *)(v53 + 152);
      }
      else
      {
        uint64_t v93 = *(unsigned int *)(v53 + 160);
        int v94 = v93 - 1;
        unsigned int v95 = (v93 - 1) & ((v66 >> 4) ^ (v66 >> 9));
        uint64_t v70 = (unsigned int **)(v67 + 8 * v95);
        uint64_t v96 = *v70;
        if (*v70 == (unsigned int *)-1)
        {
          uint64_t v97 = 0;
LABEL_117:
          if (v97) {
            uint64_t v70 = v97;
          }
          if (*v70 != v66) {
            uint64_t v70 = (unsigned int **)(v67 + 8 * v93);
          }
        }
        else
        {
          uint64_t v97 = 0;
          int v98 = 1;
          while (v96 != v66)
          {
            if (v97) {
              BOOL v99 = 0;
            }
            else {
              BOOL v99 = v96 == (unsigned int *)-2;
            }
            if (v99) {
              uint64_t v97 = v70;
            }
            unsigned int v100 = v95 + v98++;
            unsigned int v95 = v100 & v94;
            uint64_t v70 = (unsigned int **)(v67 + 8 * (v100 & v94));
            uint64_t v96 = *v70;
            if (*v70 == (unsigned int *)-1) {
              goto LABEL_117;
            }
          }
        }
      }
      if (v67 == v68) {
        uint64_t v73 = 164;
      }
      else {
        uint64_t v73 = 160;
      }
      if (v70 != (unsigned int **)(v67 + 8 * *(unsigned int *)(v53 + v73))) {
        goto LABEL_89;
      }
      unint64_t v74 = v52 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v75 = *(void *)((v52 & 0xFFFFFFFFFFFFFFF8) + 16);
      if (v75)
      {
        unint64_t v76 = (uint64_t *)(v75 + 24);
      }
      else
      {
        uint64_t v658 = *(void *)(*(void *)(a1 + 16) + 288);
        uint64_t v659 = *(void *)(v658 + 536);
        unint64_t v660 = *(unsigned int *)(v658 + 544);
        if (v660)
        {
          unsigned int v661 = *(_DWORD *)(v74 + 24) | (v52 >> 1) & 3;
          uint64_t v107 = *(void **)(v658 + 536);
          unint64_t v106 = v660;
          do
          {
            unint64_t v102 = v106 >> 1;
            uint64_t v103 = &v107[2 * (v106 >> 1)];
            uint64_t v105 = *v103;
            uint64_t v104 = v103 + 2;
            v106 += ~(v106 >> 1);
            if (((v105 >> 1) & 3 | *(_DWORD *)((v105 & 0xFFFFFFFFFFFFFFF8) + 24)) < v661) {
              uint64_t v107 = v104;
            }
            else {
              unint64_t v106 = v102;
            }
          }
          while (v106);
          if (v107 == (void *)(v659 + 16 * v660)
            || ((*v107 >> 1) & 3 | *(_DWORD *)((*v107 & 0xFFFFFFFFFFFFFFF8) + 24)) > v661)
          {
            v107 -= 2;
          }
        }
        else
        {
          uint64_t v107 = *(void **)(v658 + 536);
        }
        unint64_t v76 = v107 + 1;
      }
      uint64_t v77 = *v76;
      uint64_t v78 = *v66;
      uint64_t v79 = v1028;
      uint64_t v80 = (void *)(v1028 + 16 * v78);
      if (v52 == *((void *)v66 + 1))
      {
        *uint64_t v80 = v77;
        v80[1] = v52;
      }
      else
      {
        int v81 = *(_DWORD *)(a1 + 416);
        if (!v81) {
          goto LABEL_86;
        }
        uint64_t v82 = *(void *)(a1 + 400);
        unint64_t v83 = ~((unint64_t)(37 * v78) << 32) + (37 * v78);
        unint64_t v84 = (v83 ^ (v83 >> 22)) + ~((v83 ^ (v83 >> 22)) << 13);
        unint64_t v85 = (9 * (v84 ^ (v84 >> 8))) ^ ((9 * (v84 ^ (v84 >> 8))) >> 15);
        unsigned int v86 = ((v85 + ~(v85 << 27)) >> 31) ^ (v85 + ~(v85 << 27));
        unsigned int v87 = v81 - 1;
        uint64_t v88 = (v81 - 1) & v86;
        unint64_t v89 = (int *)(v82 + 16 * v88);
        int v91 = *v89;
        int v90 = v89[1];
        if (v91) {
          BOOL v92 = 0;
        }
        else {
          BOOL v92 = v78 == v90;
        }
        if (!v92)
        {
          int v101 = 1;
          while (v91 != -1 || v90 != -1)
          {
            int v637 = v88 + v101++;
            uint64_t v88 = v637 & v87;
            v638 = (int *)(v82 + 16 * v88);
            int v91 = *v638;
            int v90 = v638[1];
            if (v91) {
              BOOL v639 = 0;
            }
            else {
              BOOL v639 = v78 == v90;
            }
            if (v639) {
              goto LABEL_85;
            }
          }
LABEL_86:
          if (*v80)
          {
            if (*v80 != v77)
            {
              llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 40));
              llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::findNearestCommonDominator();
            }
            uint64_t v849 = v1028 + 16 * v78;
            unint64_t v852 = *(void *)(v849 + 8);
            v850 = (unint64_t *)(v849 + 8);
            unint64_t v851 = v852;
            if (v852 < 8
              || (*(_DWORD *)(v74 + 24) | (v52 >> 1) & 3) < (*(_DWORD *)((v851 & 0xFFFFFFFFFFFFFFF8) + 24) | (v851 >> 1) & 3))
            {
              unint64_t *v850 = v52;
            }
          }
          else
          {
            *uint64_t v80 = v77;
            *(void *)(v79 + 16 * v78 + 8) = v52;
          }
          goto LABEL_89;
        }
LABEL_85:
        if (*(void *)(v82 + 16 * v88 + 8) <= 7uLL) {
          goto LABEL_86;
        }
      }
LABEL_89:
      v50 += 8;
      if (v50 == v51) {
        break;
      }
      continue;
    }
  }
  uint64_t v108 = v964;
  uint64_t v109 = *(unsigned int *)(v964 + 72);
  if (!v109) {
    goto LABEL_166;
  }
  uint64_t v110 = 0;
  while (2)
  {
    uint64_t v111 = (unsigned int **)(v1028 + 16 * v110);
    unsigned int v112 = *v111;
    if (!*v111) {
      goto LABEL_124;
    }
    uint64_t v113 = v111 + 1;
    if ((unint64_t)v111[1] > 7) {
      goto LABEL_124;
    }
    v956 = *(unsigned int **)(*(void *)(v108 + 64) + 8 * v110);
    unint64_t v114 = *((void *)v956 + 1);
    uint64_t v115 = *(void *)(*(void *)(a1 + 16) + 288);
    if (v114 >= 8 && (uint64_t v116 = *(void *)((v114 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
    {
      uint64_t v117 = (unsigned int **)(v116 + 24);
    }
    else
    {
      uint64_t v827 = *(void **)(v115 + 536);
      unint64_t v828 = *(unsigned int *)(v115 + 544);
      if (v828)
      {
        unsigned int v829 = *(_DWORD *)((v114 & 0xFFFFFFFFFFFFFFF8) + 24) | (v114 >> 1) & 3;
        int v830 = v827;
        unint64_t v831 = v828;
        do
        {
          unint64_t v832 = v831 >> 1;
          size_t v833 = &v830[2 * (v831 >> 1)];
          uint64_t v835 = *v833;
          size_t v834 = v833 + 2;
          v831 += ~(v831 >> 1);
          if (((v835 >> 1) & 3 | *(_DWORD *)((v835 & 0xFFFFFFFFFFFFFFF8) + 24)) < v829) {
            int v830 = v834;
          }
          else {
            unint64_t v831 = v832;
          }
        }
        while (v831);
        if (v830 == &v827[2 * v828]
          || ((*v830 >> 1) & 3 | *(_DWORD *)((*v830 & 0xFFFFFFFFFFFFFFF8) + 24)) > v829)
        {
          v830 -= 2;
        }
      }
      else
      {
        int v830 = *(void **)(v115 + 536);
      }
      uint64_t v117 = (unsigned int **)(v830 + 1);
    }
    uint64_t v118 = *v117;
    if (v112 == *v117)
    {
LABEL_743:
      uint64_t v138 = v112;
      goto LABEL_153;
    }
    uint64_t v119 = *(void *)(*(void *)a1 + 24);
    int v120 = *(_DWORD *)(v119 + 264);
    unsigned int v121 = v118 >> 4;
    if (v120)
    {
      uint64_t v122 = *(void *)(v119 + 248);
      unsigned int v123 = v120 - 1;
      uint64_t v124 = (v120 - 1) & (v121 ^ (v118 >> 9));
      uint64_t v125 = *(unsigned int **)(v122 + 16 * v124);
      if (v125 != v118)
      {
        int v126 = 1;
        while (v125 != (unsigned int *)-4096)
        {
          int v127 = v124 + v126++;
          uint64_t v124 = v127 & v123;
          uint64_t v125 = *(unsigned int **)(v122 + 16 * v124);
          if (v125 == v118) {
            goto LABEL_737;
          }
        }
        goto LABEL_730;
      }
LABEL_737:
      uint64_t v632 = v45;
      uint64_t v955 = *(void *)(v122 + 16 * v124 + 8);
    }
    else
    {
LABEL_730:
      uint64_t v632 = v45;
      uint64_t v955 = 0;
    }
    uint64_t v128 = *(void *)(a1 + 40);
    llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v128);
    uint64_t v129 = *(void *)(v128 + 1320);
    uint64_t v130 = *(void *)(v129 + 24);
    uint64_t v131 = *(unsigned int *)(v129 + 40);
    uint64_t v45 = v632;
    if (v131)
    {
      LODWORD(v132) = (v131 - 1) & (v121 ^ (v118 >> 9));
      uint64_t v133 = (unsigned int **)(v130 + 16 * v132);
      uint64_t v134 = *v133;
      if (*v133 == v118) {
        goto LABEL_140;
      }
      int v656 = 1;
      while (v134 != (unsigned int *)-4096)
      {
        int v657 = v132 + v656++;
        uint64_t v132 = v657 & (v131 - 1);
        uint64_t v134 = *(unsigned int **)(v130 + 16 * v132);
        if (v134 == v118)
        {
          uint64_t v133 = (unsigned int **)(v130 + 16 * v132);
          goto LABEL_140;
        }
      }
    }
    uint64_t v133 = (unsigned int **)(v130 + 16 * v131);
LABEL_140:
    if (v133 == (unsigned int **)(v130 + 16 * v131)) {
      uint64_t v135 = 0;
    }
    else {
      uint64_t v135 = v133[1];
    }
    int v136 = *(_DWORD *)(v119 + 264);
    if (!v136) {
      goto LABEL_743;
    }
    unsigned int v137 = -1;
    uint64_t v138 = v112;
    while (2)
    {
      uint64_t v139 = *(void *)(v119 + 248);
      unsigned int v140 = v136 - 1;
      uint64_t v141 = ((v138 >> 4) ^ (v138 >> 9)) & (v136 - 1);
      size_t v142 = *(unsigned int **)(v139 + 16 * v141);
      if (v138 == v142)
      {
LABEL_148:
        uint64_t v145 = *(void *)(v139 + 16 * v141 + 8);
        if (v145) {
          BOOL v146 = v145 == v955;
        }
        else {
          BOOL v146 = 1;
        }
        if (v146) {
          goto LABEL_153;
        }
        uint64_t v952 = v45;
        unsigned int v664 = 0;
        v665 = (void *)v145;
        do
        {
          v665 = (void *)*v665;
          ++v664;
        }
        while (v665);
        if (v664 < v137)
        {
          unsigned int v112 = v138;
          unsigned int v137 = v664;
        }
        uint64_t v666 = *(void *)(a1 + 40);
        uint64_t v667 = **(void **)(v145 + 32);
        llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v666);
        uint64_t v668 = *(void *)(v666 + 1320);
        uint64_t v669 = *(void *)(v668 + 24);
        uint64_t v670 = *(unsigned int *)(v668 + 40);
        if (v670)
        {
          LODWORD(v671) = (v670 - 1) & ((v667 >> 4) ^ (v667 >> 9));
          size_t v672 = (uint64_t *)(v669 + 16 * v671);
          uint64_t v673 = *v672;
          if (*v672 == v667) {
            goto LABEL_792;
          }
          int v817 = 1;
          while (v673 != -4096)
          {
            int v818 = v671 + v817++;
            uint64_t v671 = v818 & (v670 - 1);
            uint64_t v673 = *(void *)(v669 + 16 * v671);
            if (v673 == v667)
            {
              size_t v672 = (uint64_t *)(v669 + 16 * v671);
              goto LABEL_792;
            }
          }
        }
        size_t v672 = (uint64_t *)(v669 + 16 * v670);
LABEL_792:
        uint64_t v674 = *(void *)(v672[1] + 8);
        if (!v674) {
          goto LABEL_1197;
        }
        uint64_t v675 = *(void *)(a1 + 40);
        llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v675);
        if ((unsigned int *)v674 != v135)
        {
          if (!v135) {
            goto LABEL_1197;
          }
          if (*(unsigned int **)(v674 + 8) != v135)
          {
            if (*((void *)v135 + 1) == v674) {
              goto LABEL_1197;
            }
            unsigned int v676 = v135[4];
            if (v676 >= *(_DWORD *)(v674 + 16)) {
              goto LABEL_1197;
            }
            uint64_t v677 = *(void *)(v675 + 1320);
            if (*(unsigned char *)(v677 + 64))
            {
              if (*(_DWORD *)(v674 + 72) < v135[18] || *(_DWORD *)(v674 + 76) > v135[19]) {
                goto LABEL_1197;
              }
            }
            else
            {
              unsigned int v908 = *(_DWORD *)(v677 + 68) + 1;
              *(_DWORD *)(v677 + 68) = v908;
              v909 = (unsigned int *)v674;
              if (v908 > 0x20) {
                llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::updateDFSNumbers();
              }
              do
              {
                v910 = v909;
                v909 = (unsigned int *)*((void *)v909 + 1);
              }
              while (v909 && v909[4] >= v676);
              if (v910 != v135)
              {
LABEL_1197:
                uint64_t v138 = v112;
                uint64_t v45 = v952;
                goto LABEL_153;
              }
            }
          }
        }
        uint64_t v138 = *(unsigned int **)v674;
        int v136 = *(_DWORD *)(v119 + 264);
        uint64_t v45 = v952;
        if (!v136) {
          goto LABEL_153;
        }
        continue;
      }
      break;
    }
    int v143 = 1;
    while (v142 != (unsigned int *)-4096)
    {
      int v144 = v141 + v143++;
      uint64_t v141 = v144 & v140;
      size_t v142 = *(unsigned int **)(v139 + 16 * v141);
      if (v138 == v142) {
        goto LABEL_148;
      }
    }
LABEL_153:
    *uint64_t v111 = v138;
    uint64_t v108 = v964;
    if (*(_DWORD *)(a1 + 92) != 2) {
      goto LABEL_763;
    }
    uint64_t v147 = *(void *)(*(void *)(a1 + 64) + 248);
    if (!v147) {
      goto LABEL_763;
    }
    int v148 = *(_DWORD *)(v147 + 176);
    if (!v148) {
      goto LABEL_763;
    }
    uint64_t v149 = *(void *)(v147 + 160);
    unsigned int v150 = v148 - 1;
    uint64_t v151 = (v148 - 1) & ((v138 >> 4) ^ (v138 >> 9));
    int v152 = *(unsigned int **)(v149 + 16 * v151);
    if (v152 != v138)
    {
      int v648 = 1;
      while (v152 != (unsigned int *)-4096)
      {
        int v649 = v151 + v648++;
        uint64_t v151 = v649 & v150;
        int v152 = *(unsigned int **)(v149 + 16 * v151);
        if (v152 == v138) {
          goto LABEL_157;
        }
      }
LABEL_763:
      uint64_t v650 = v45;
      uint64_t v651 = v138[6];
      uint64_t v652 = *(void *)(*(void *)a1 + 56);
      unint64_t v653 = *(void *)(v652 + 16 * v651);
      if (v653 < 8 || *(void *)(v652 + 16 * v651 + 8) >= 8uLL) {
        unint64_t v653 = sub_1CC4754EC((void *)(*(void *)a1 + 48), *(void *)(*(void *)a1 + 40), (llvm::MachineBasicBlock *)v138);
      }
      if (((v653 >> 1) & 3 | *(_DWORD *)((v653 & 0xFFFFFFFFFFFFFFF8) + 24)) <= ((*((void *)v956 + 1) >> 1) & 3 | *(_DWORD *)((*((void *)v956 + 1) & 0xFFFFFFFFFFFFFFF8) + 24)))
      {
        sub_1CBF7CCE0((uint64_t)&v968, (int *)v956, (uint64_t)&v981);
      }
      else
      {
        v654 = *v111;
        int v655 = (unint64_t *)sub_1CC475930((void *)(*(void *)a1 + 48), *(void *)(*(void *)a1 + 40), v654);
        *uint64_t v113 = *(void *)(sub_1CC4771B0((void *)a1, 0, v956, v653, (uint64_t)v654, v655) + 8);
      }
      uint64_t v45 = v650;
      goto LABEL_124;
    }
LABEL_157:
    uint64_t v153 = *(unsigned int *)(v149 + 16 * v151 + 8);
    if (v153 == 0xFFFFFFFFLL) {
      goto LABEL_763;
    }
    unint64_t v154 = *(void *)(*(void *)(v147 + 8) + 24 * v153 + 16);
    uint64_t v155 = *v956;
    if (v154 <= *((void *)v974[0] + v155)) {
      goto LABEL_763;
    }
    if (!v970)
    {
      uint64_t v161 = 0;
      goto LABEL_137;
    }
    unsigned int v156 = (v970 - 1) & (37 * v155);
    uint64_t v157 = (int *)(v968 + 4 * v156);
    int v158 = *v157;
    if (v155 != *v157)
    {
      uint64_t v159 = 0;
      int v160 = 1;
      while (v158 != -1)
      {
        if (v159) {
          BOOL v918 = 0;
        }
        else {
          BOOL v918 = v158 == -2;
        }
        if (v918) {
          uint64_t v159 = v157;
        }
        unsigned int v919 = v156 + v160++;
        unsigned int v156 = v919 & (v970 - 1);
        uint64_t v157 = (int *)(v968 + 4 * v156);
        int v158 = *v157;
        if (v155 == *v157) {
          goto LABEL_124;
        }
      }
      if (v159) {
        uint64_t v161 = v159;
      }
      else {
        uint64_t v161 = v157;
      }
LABEL_137:
      *sub_1CBB29C30((uint64_t)&v968, (uint64_t)v956, v956, v161) = *v956;
    }
LABEL_124:
    if (++v110 != v109) {
      continue;
    }
    break;
  }
LABEL_166:
  uint64_t v162 = v973;
  v971 = v973;
  uint64_t v972 = 0x800000000;
  uint64_t v163 = *(unsigned int *)(v45 + 72);
  int v38 = &dword_1CD912700[7744];
  if (v163)
  {
    uint64_t v164 = *(void *)(v45 + 64);
    uint64_t v165 = v164 + 8 * v163;
    while (2)
    {
      unint64_t v166 = *(void *)(*(void *)v164 + 8);
      if (v166 < 8) {
        goto LABEL_184;
      }
      uint64_t v167 = *(void *)(*(void *)(a1 + 80) + 8);
      unint64_t v168 = *(unsigned int *)(v167 + 8);
      uint64_t v169 = *(void **)v167;
      if (v168)
      {
        uint64_t v170 = v169[3 * v168 - 2];
        unsigned int v171 = *(_DWORD *)((v166 & 0xFFFFFFFFFFFFFFF8) + 24) | (v166 >> 1) & 3;
        unsigned int v172 = (v170 >> 1) & 3 | *(_DWORD *)((v170 & 0xFFFFFFFFFFFFFFF8) + 24);
        uint64_t v173 = v169;
        unint64_t v174 = v168;
        if (v171 < v172)
        {
          do
          {
            unint64_t v175 = v174 >> 1;
            uint64_t v176 = v173[3 * (v174 >> 1) + 1];
            LODWORD(v176) = (v176 >> 1) & 3 | *(_DWORD *)((v176 & 0xFFFFFFFFFFFFFFF8) + 24);
            v174 -= (v174 >> 1) + 1;
            BOOL v177 = v171 >= v176;
            if (v171 >= v176) {
              unint64_t v178 = v175 + 1;
            }
            else {
              unint64_t v178 = 0;
            }
            v173 += 3 * v178;
            if (!v177) {
              unint64_t v174 = v175;
            }
          }
          while (v174);
LABEL_177:
          if (v173 == &v169[3 * v168]
            || ((*v173 >> 1) & 3 | *(_DWORD *)((*v173 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((v166 & 0xFFFFFFFFFFFFFFF8) + 24) | (v166 >> 1) & 3))
          {
            uint64_t v179 = 0;
          }
          else
          {
            uint64_t v179 = (unsigned int *)v173[2];
          }
          uint64_t v180 = *v179;
          if (*(void *)(v1028 + 16 * v180) && *(void *)(v1028 + 16 * v180 + 8) != v166)
          {
            if (!v970) {
              goto LABEL_187;
            }
            unsigned int v181 = (v970 - 1) & (37 * v180);
            int v182 = *(_DWORD *)(v968 + 4 * v181);
            if (v180 != v182)
            {
              int v836 = 1;
              while (v182 != -1)
              {
                unsigned int v837 = v181 + v836++;
                unsigned int v181 = v837 & (v970 - 1);
                int v182 = *(_DWORD *)(v968 + 4 * v181);
                if (v180 == v182) {
                  goto LABEL_184;
                }
              }
LABEL_187:
              if (v972 >= (unint64_t)HIDWORD(v972)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v971 + v972) = *(void *)v164;
              LODWORD(v972) = v972 + 1;
              sub_1CC476FDC(a1, 0, *v179);
            }
          }
LABEL_184:
          v164 += 8;
          if (v164 == v165) {
            goto LABEL_191;
          }
          continue;
        }
      }
      else
      {
        LODWORD(v168) = 0;
      }
      break;
    }
    uint64_t v173 = &v169[3 * v168];
    goto LABEL_177;
  }
LABEL_191:
  uint64_t v183 = *(void *)(a1 + 16);
  uint64_t v184 = *(void *)(a1 + 80);
  if (*(_DWORD *)(a1 + 92) != 2 || v969 == 0) {
    goto LABEL_196;
  }
  unint64_t v592 = *(_DWORD *)(**(void **)(v184 + 16) + 4 * *(unsigned int *)(v184 + 64)) & 0x7FFFFFFF;
  uint64_t v593 = (void *)(v183 + 408);
  unint64_t v594 = *(unsigned int *)(v183 + 416);
  BOOL v64 = v592 >= v594;
  unint64_t v595 = v592 - v594;
  if (v64)
  {
    sub_1CB9153B8((uint64_t)v593, v595 + 1, *(void *)(v183 + 424));
LABEL_1271:
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v596 = *(void *)(*v593 + 8 * v592);
  if (!v596) {
    goto LABEL_1271;
  }
  uint64_t v597 = *(void *)(v184 + 8);
  unint64_t v598 = *(unsigned int *)(v597 + 72);
  v976 = v980;
  __src = v980;
  unint64_t v978 = 8;
  unsigned int v979 = 0;
  *(void *)&long long v981 = &v982;
  *((void *)&v981 + 1) = 0x800000000;
  if (v598 >= 9)
  {
    if (v598 <= 0x11) {
      uint64_t v678 = 17;
    }
    else {
      uint64_t v678 = v598;
    }
    uint64_t v679 = (char *)malloc_type_malloc(96 * v678, 0x4065EBACuLL);
    if (!v679)
    {
      v927 = "Allocation failed";
      goto LABEL_1346;
    }
    uint64_t v680 = v679;
    uint64_t v681 = 0;
    do
    {
      uint64_t v682 = &v680[v681 + 32];
      *(void *)&v680[v681] = v682;
      v683 = __src;
      if (__src == v976)
      {
        *(void *)&v680[v681 + 8] = v682;
      }
      else
      {
        int v687 = v978;
        uint64_t v682 = (char *)malloc_type_malloc(8 * v978, 0x4065EBACuLL);
        if (!v682)
        {
          if (v687) {
            goto LABEL_1345;
          }
          uint64_t v682 = (char *)malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v682) {
            goto LABEL_1345;
          }
        }
        *(void *)&v680[v681 + 8] = v682;
        v683 = v976;
      }
      v684 = &v680[v681];
      *(_DWORD *)&v680[v681 + 16] = v978;
      int v685 = HIDWORD(v978);
      if (__src == v683) {
        unsigned int v686 = HIDWORD(v978);
      }
      else {
        unsigned int v686 = v978;
      }
      if (v686)
      {
        memmove(v682, __src, 8 * v686);
        int v685 = HIDWORD(v978);
      }
      *((_DWORD *)v684 + 5) = v685;
      *((_DWORD *)v684 + 6) = v979;
      v681 += 96;
    }
    while (96 * v598 != v681);
    size_t v688 = (char *)v981;
    if (DWORD2(v981))
    {
      uint64_t v928 = 96 * DWORD2(v981);
      do
      {
        v929 = *(void **)&v688[v928 - 88];
        if (v929 != *(void **)&v688[v928 - 96]) {
          free(v929);
        }
        v928 -= 96;
      }
      while (v928);
      size_t v688 = (char *)v981;
    }
    if (v688 != (char *)&v982) {
      free(v688);
    }
    *(void *)&long long v981 = v680;
    HIDWORD(v981) = v678;
  }
  else if (v598)
  {
    size_t v599 = &v984;
    *(void *)&long long v982 = &v984;
    size_t v600 = __src;
    if (__src == v976)
    {
      unsigned int v601 = 0;
      *((void *)&v982 + 1) = &v984;
      uint64_t v602 = __src;
      goto LABEL_668;
    }
    size_t v599 = (uint64_t *)malloc_type_malloc(8 * v978, 0x4065EBACuLL);
    if (!v599) {
      goto LABEL_1345;
    }
    *((void *)&v982 + 1) = v599;
    uint64_t v602 = v976;
    size_t v600 = __src;
    unsigned int v601 = HIDWORD(v978);
LABEL_668:
    LODWORD(v983) = v978;
    if (v600 == v602) {
      unsigned int v603 = v601;
    }
    else {
      unsigned int v603 = v978;
    }
    if (v603)
    {
      memmove(v599, v600, 8 * v603);
      unsigned int v601 = HIDWORD(v978);
    }
    *(void *)((char *)&v983 + 4) = __PAIR64__(v979, v601);
    if (v598 != 1)
    {
      uint64_t v604 = &v992;
      v987 = &v992;
      uint64_t v605 = __src;
      if (__src == v976)
      {
        v988 = &v992;
        v606 = __src;
        goto LABEL_676;
      }
      int v848 = v978;
      uint64_t v604 = (uint64_t *)malloc_type_malloc(8 * v978, 0x4065EBACuLL);
      if (!v604 && (v848 || (uint64_t v604 = (uint64_t *)malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0))
      {
LABEL_1345:
        v927 = "Allocation failed";
LABEL_1346:
        llvm::report_bad_alloc_error((llvm *)v927, (const char *)1);
      }
      v988 = v604;
      v606 = v976;
      uint64_t v605 = __src;
      unsigned int v601 = HIDWORD(v978);
LABEL_676:
      unsigned int v989 = v978;
      if (v605 == v606) {
        unsigned int v607 = v601;
      }
      else {
        unsigned int v607 = v978;
      }
      if (v607)
      {
        memmove(v604, v605, 8 * v607);
        unsigned int v601 = HIDWORD(v978);
      }
      unsigned int v990 = v601;
      LODWORD(v991) = v979;
      if (v598 != 2)
      {
        int v608 = v1002;
        v997[2] = v1002;
        int v609 = __src;
        if (__src == v976)
        {
          v998 = v1002;
          v610 = __src;
        }
        else
        {
          int v911 = v978;
          int v608 = malloc_type_malloc(8 * v978, 0x4065EBACuLL);
          if (!v608)
          {
            if (v911) {
              goto LABEL_1345;
            }
            int v608 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
            if (!v608) {
              goto LABEL_1345;
            }
          }
          v998 = v608;
          v610 = v976;
          int v609 = __src;
          unsigned int v601 = HIDWORD(v978);
        }
        int v999 = v978;
        if (v609 == v610) {
          unsigned int v611 = v601;
        }
        else {
          unsigned int v611 = v978;
        }
        if (v611)
        {
          memmove(v608, v609, 8 * v611);
          unsigned int v601 = HIDWORD(v978);
        }
        unsigned int v1000 = v601;
        unsigned int v1001 = v979;
        if (v598 != 3)
        {
          size_t v612 = v1007;
          v1002[8] = v1007;
          size_t v613 = __src;
          if (__src == v976)
          {
            v1003 = v1007;
            size_t v614 = __src;
          }
          else
          {
            int v913 = v978;
            size_t v612 = malloc_type_malloc(8 * v978, 0x4065EBACuLL);
            if (!v612)
            {
              if (v913) {
                goto LABEL_1345;
              }
              size_t v612 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
              if (!v612) {
                goto LABEL_1345;
              }
            }
            v1003 = v612;
            size_t v614 = v976;
            size_t v613 = __src;
            unsigned int v601 = HIDWORD(v978);
          }
          int v1004 = v978;
          if (v613 == v614) {
            unsigned int v615 = v601;
          }
          else {
            unsigned int v615 = v978;
          }
          if (v615)
          {
            memmove(v612, v613, 8 * v615);
            unsigned int v601 = HIDWORD(v978);
          }
          unsigned int v1005 = v601;
          unsigned int v1006 = v979;
          if (v598 != 4)
          {
            uint64_t v616 = v1012;
            v1007[8] = v1012;
            unint64_t v617 = __src;
            if (__src == v976)
            {
              v1008 = v1012;
              v618 = __src;
            }
            else
            {
              int v917 = v978;
              uint64_t v616 = malloc_type_malloc(8 * v978, 0x4065EBACuLL);
              if (!v616)
              {
                if (v917) {
                  goto LABEL_1345;
                }
                uint64_t v616 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
                if (!v616) {
                  goto LABEL_1345;
                }
              }
              v1008 = v616;
              v618 = v976;
              unint64_t v617 = __src;
              unsigned int v601 = HIDWORD(v978);
            }
            int v1009 = v978;
            if (v617 == v618) {
              unsigned int v619 = v601;
            }
            else {
              unsigned int v619 = v978;
            }
            if (v619)
            {
              memmove(v616, v617, 8 * v619);
              unsigned int v601 = HIDWORD(v978);
            }
            unsigned int v1010 = v601;
            unsigned int v1011 = v979;
            if (v598 != 5)
            {
              v620 = v1017;
              v1012[8] = v1017;
              uint64_t v621 = __src;
              if (__src == v976)
              {
                v1013 = v1017;
                uint64_t v622 = __src;
              }
              else
              {
                int v920 = v978;
                v620 = malloc_type_malloc(8 * v978, 0x4065EBACuLL);
                if (!v620)
                {
                  if (v920) {
                    goto LABEL_1345;
                  }
                  v620 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
                  if (!v620) {
                    goto LABEL_1345;
                  }
                }
                v1013 = v620;
                uint64_t v622 = v976;
                uint64_t v621 = __src;
                unsigned int v601 = HIDWORD(v978);
              }
              int v1014 = v978;
              if (v621 == v622) {
                unsigned int v623 = v601;
              }
              else {
                unsigned int v623 = v978;
              }
              if (v623)
              {
                memmove(v620, v621, 8 * v623);
                unsigned int v601 = HIDWORD(v978);
              }
              unsigned int v1015 = v601;
              unsigned int v1016 = v979;
              if (v598 != 6)
              {
                uint64_t v624 = v1022;
                v1017[8] = v1022;
                v625 = __src;
                if (__src == v976)
                {
                  v1018 = v1022;
                  v626 = __src;
                }
                else
                {
                  int v921 = v978;
                  uint64_t v624 = malloc_type_malloc(8 * v978, 0x4065EBACuLL);
                  if (!v624)
                  {
                    if (v921) {
                      goto LABEL_1345;
                    }
                    uint64_t v624 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
                    if (!v624) {
                      goto LABEL_1345;
                    }
                  }
                  v1018 = v624;
                  v626 = v976;
                  v625 = __src;
                  unsigned int v601 = HIDWORD(v978);
                }
                int v1019 = v978;
                if (v625 == v626) {
                  unsigned int v627 = v601;
                }
                else {
                  unsigned int v627 = v978;
                }
                if (v627)
                {
                  memmove(v624, v625, 8 * v627);
                  unsigned int v601 = HIDWORD(v978);
                }
                unsigned int v1020 = v601;
                unsigned int v1021 = v979;
                if (v598 != 7)
                {
                  int v628 = v1027;
                  v1022[8] = v1027;
                  v629 = __src;
                  if (__src == v976)
                  {
                    v1023 = v1027;
                    size_t v630 = __src;
                  }
                  else
                  {
                    int v924 = v978;
                    int v628 = malloc_type_malloc(8 * v978, 0x4065EBACuLL);
                    if (!v628)
                    {
                      if (v924) {
                        goto LABEL_1345;
                      }
                      int v628 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
                      if (!v628) {
                        goto LABEL_1345;
                      }
                    }
                    v1023 = v628;
                    size_t v630 = v976;
                    v629 = __src;
                    unsigned int v601 = HIDWORD(v978);
                  }
                  int v1024 = v978;
                  if (v629 == v630) {
                    unsigned int v631 = v601;
                  }
                  else {
                    unsigned int v631 = v978;
                  }
                  if (v631)
                  {
                    memmove(v628, v629, 8 * v631);
                    unsigned int v601 = HIDWORD(v978);
                  }
                  unsigned int v1025 = v601;
                  unsigned int v1026 = v979;
                }
              }
            }
          }
        }
      }
    }
  }
  DWORD2(v981) = v598;
  if (__src != v976) {
    free(__src);
  }
  v976 = v980;
  __src = v980;
  unint64_t v978 = 8;
  unsigned int v979 = 0;
  uint64_t v689 = *(unsigned int *)(v596 + 72);
  if (v689)
  {
    v690 = *(uint64_t **)(v596 + 64);
    v691 = &v690[v689];
    while (2)
    {
      uint64_t v692 = *v690;
      unint64_t v693 = *(void *)(*v690 + 8);
      if (v693 < 8) {
        goto LABEL_853;
      }
      uint64_t v694 = *(uint64_t **)(*(void *)(a1 + 80) + 8);
      unint64_t v695 = *((unsigned int *)v694 + 2);
      uint64_t v696 = *v694;
      if (v695)
      {
        uint64_t v697 = *(void *)(v696 + 24 * v695 - 16);
        unsigned int v698 = *(_DWORD *)((v693 & 0xFFFFFFFFFFFFFFF8) + 24) | (v693 >> 1) & 3;
        unsigned int v699 = (v697 >> 1) & 3 | *(_DWORD *)((v697 & 0xFFFFFFFFFFFFFFF8) + 24);
        uint64_t v700 = v696;
        unint64_t v701 = v695;
        if (v698 < v699)
        {
          do
          {
            unint64_t v702 = v701 >> 1;
            uint64_t v703 = *(void *)(v700 + 24 * (v701 >> 1) + 8);
            LODWORD(v703) = (v703 >> 1) & 3 | *(_DWORD *)((v703 & 0xFFFFFFFFFFFFFFF8) + 24);
            v701 -= (v701 >> 1) + 1;
            BOOL v704 = v698 >= v703;
            if (v698 >= v703) {
              unint64_t v705 = v702 + 1;
            }
            else {
              unint64_t v705 = 0;
            }
            v700 += 24 * v705;
            if (!v704) {
              unint64_t v701 = v702;
            }
          }
          while (v701);
LABEL_840:
          uint64_t v706 = v696 + 24 * v695;
          if (v700 == v706
            || ((*(void *)v700 >> 1) & 3 | *(_DWORD *)((*(void *)v700 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((v693 & 0xFFFFFFFFFFFFFFF8) + 24) | (v693 >> 1) & 3))
          {
            uint64_t v700 = v706;
          }
          uint64_t v707 = v981 + 96 * **(unsigned int **)(v700 + 16);
          uint64_t v708 = *(void *)(v707 + 8);
          uint64_t v709 = *(unsigned int *)(v707 + 20);
          if (v708 != *(void *)v707)
          {
            unsigned int v713 = *(_DWORD *)(v707 + 16);
LABEL_856:
            if (3 * v713 <= 4 * ((int)v709 - *(_DWORD *)(v707 + 24)))
            {
              if (v713 >= 0x40) {
                v713 *= 2;
              }
              else {
                unsigned int v713 = 128;
              }
            }
            else if (v713 - v709 >= v713 >> 3)
            {
              goto LABEL_858;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)v707, v713);
            unsigned int v713 = *(_DWORD *)(v707 + 16);
            uint64_t v708 = *(void *)(v707 + 8);
LABEL_858:
            unsigned int v714 = v713 - 1;
            unsigned int v715 = (v713 - 1) & ((v692 >> 4) ^ (v692 >> 9));
            size_t v716 = (void *)(v708 + 8 * v715);
            uint64_t v717 = *v716;
            if (*v716 == -1)
            {
              v718 = 0;
LABEL_870:
              if (v718) {
                uint64_t v722 = v718;
              }
              else {
                uint64_t v722 = v716;
              }
              if (*v722 != v692)
              {
                if (*v722 == -2) {
                  --*(_DWORD *)(v707 + 24);
                }
                else {
                  ++*(_DWORD *)(v707 + 20);
                }
                *uint64_t v722 = v692;
              }
            }
            else
            {
              v718 = 0;
              int v719 = 1;
              while (v717 != v692)
              {
                if (v718) {
                  BOOL v720 = 0;
                }
                else {
                  BOOL v720 = v717 == -2;
                }
                if (v720) {
                  v718 = v716;
                }
                unsigned int v721 = v715 + v719++;
                unsigned int v715 = v721 & v714;
                size_t v716 = (void *)(v708 + 8 * (v721 & v714));
                uint64_t v717 = *v716;
                if (*v716 == -1) {
                  goto LABEL_870;
                }
              }
            }
            goto LABEL_853;
          }
          if (v709)
          {
            uint64_t v710 = 0;
            uint64_t v711 = 8 * v709;
            v712 = *(void **)(v707 + 8);
            while (*v712 != v692)
            {
              if (*v712 == -2) {
                uint64_t v710 = v712;
              }
              ++v712;
              v711 -= 8;
              if (!v711)
              {
                if (!v710) {
                  goto LABEL_851;
                }
                *uint64_t v710 = v692;
                --*(_DWORD *)(v707 + 24);
                goto LABEL_853;
              }
            }
            goto LABEL_853;
          }
LABEL_851:
          unsigned int v713 = *(_DWORD *)(v707 + 16);
          if (v709 >= v713) {
            goto LABEL_856;
          }
          *(_DWORD *)(v707 + 20) = v709 + 1;
          *(void *)(v708 + 8 * v709) = v692;
LABEL_853:
          if (++v690 == v691) {
            goto LABEL_879;
          }
          continue;
        }
      }
      else
      {
        LODWORD(v695) = 0;
      }
      break;
    }
    uint64_t v700 = v696 + 24 * v695;
    goto LABEL_840;
  }
LABEL_879:
  uint64_t v723 = *(unsigned int *)(v597 + 72);
  if (v723)
  {
    uint64_t v724 = 0;
    uint64_t v953 = v597;
    uint64_t v958 = *(unsigned int *)(v597 + 72);
    while (2)
    {
      if (!v970) {
        goto LABEL_998;
      }
      int v725 = *(unsigned int **)(*(void *)(v597 + 64) + 8 * v724);
      uint64_t v726 = *v725;
      unsigned int v727 = (37 * v726) & (v970 - 1);
      int v728 = *(_DWORD *)(v968 + 4 * v727);
      if (v726 != v728)
      {
        int v793 = 1;
        while (v728 != -1)
        {
          unsigned int v925 = v727 + v793++;
          unsigned int v727 = v925 & (v970 - 1);
          int v728 = *(_DWORD *)(v968 + 4 * v727);
          if (v726 == v728) {
            goto LABEL_883;
          }
        }
        goto LABEL_998;
      }
LABEL_883:
      uint64_t v729 = v981;
      size_t v730 = (uint64_t **)(v981 + 96 * v726);
      int v732 = *v730;
      size_t v731 = v730[1];
      if (v731 == *v730) {
        uint64_t v733 = 20;
      }
      else {
        uint64_t v733 = 16;
      }
      uint64_t v734 = *(unsigned int *)((char *)v730 + v733);
      size_t v735 = v731;
      if (v734)
      {
        uint64_t v736 = 8 * v734;
        size_t v735 = v731;
        while ((unint64_t)*v735 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v735;
          v736 -= 8;
          if (!v736) {
            goto LABEL_997;
          }
        }
      }
      uint64_t v737 = &v731[v734];
      if (v735 != v737)
      {
        do
        {
          uint64_t v738 = (unint64_t *)(v735 + 1);
          uint64_t v739 = (unint64_t *)(v735 + 1);
          while (v739 != (unint64_t *)v737)
          {
            unint64_t v740 = *v739++;
            if (v740 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              v741 = (uint64_t *)(v739 - 1);
              goto LABEL_896;
            }
          }
          v741 = v737;
LABEL_896:
          for (uint64_t i = (uint64_t **)(v729 + 96 * v726); ; v731 = i[1])
          {
            uint64_t v743 = v731 == v732 ? 20 : 16;
            if (v741 == &v731[*(unsigned int *)((char *)i + v743)]) {
              break;
            }
            uint64_t v744 = *v735;
            v745 = v976;
            if (__src == v976)
            {
              unsigned int v746 = HIDWORD(v978);
              size_t v747 = (char *)__src + 8 * HIDWORD(v978);
              if (HIDWORD(v978))
              {
                uint64_t v748 = 0;
                while (*(void *)((char *)__src + v748) != v744)
                {
                  v748 += 8;
                  if (8 * HIDWORD(v978) == v748) {
                    goto LABEL_906;
                  }
                }
                size_t v747 = (char *)__src + v748;
              }
LABEL_906:
              uint64_t v749 = __src;
            }
            else
            {
              int v764 = v978 - 1;
              unsigned int v765 = (v978 - 1) & ((v744 >> 4) ^ (v744 >> 9));
              size_t v747 = (char *)__src + 8 * v765;
              uint64_t v766 = *(void *)v747;
              if (*(void *)v747 == -1)
              {
                v767 = 0;
LABEL_945:
                if (v767) {
                  size_t v747 = v767;
                }
                unsigned int v746 = HIDWORD(v978);
                if (*(void *)v747 != v744) {
                  size_t v747 = (char *)__src + 8 * v978;
                }
              }
              else
              {
                v767 = 0;
                int v768 = 1;
                while (v766 != v744)
                {
                  if (v767) {
                    BOOL v769 = 0;
                  }
                  else {
                    BOOL v769 = v766 == -2;
                  }
                  if (v769) {
                    v767 = v747;
                  }
                  unsigned int v770 = v765 + v768++;
                  unsigned int v765 = v770 & v764;
                  size_t v747 = (char *)__src + 8 * (v770 & v764);
                  uint64_t v766 = *(void *)v747;
                  if (*(void *)v747 == -1) {
                    goto LABEL_945;
                  }
                }
                unsigned int v746 = HIDWORD(v978);
              }
              uint64_t v749 = v976;
            }
            if (__src == v749) {
              unsigned int v750 = v746;
            }
            else {
              unsigned int v750 = v978;
            }
            if (v747 == (char *)__src + 8 * v750)
            {
              uint64_t v751 = *v741;
              if (__src == v749)
              {
                uint64_t v752 = (char *)__src + 8 * v746;
                if (v746)
                {
                  uint64_t v753 = 0;
                  while (*(void *)((char *)__src + v753) != v751)
                  {
                    v753 += 8;
                    if (8 * v746 == v753) {
                      goto LABEL_916;
                    }
                  }
                  uint64_t v752 = (char *)__src + v753;
                }
LABEL_916:
                v745 = __src;
              }
              else
              {
                int v771 = v978 - 1;
                unsigned int v772 = ((v751 >> 4) ^ (v751 >> 9)) & (v978 - 1);
                uint64_t v752 = (char *)__src + 8 * v772;
                uint64_t v773 = *(void *)v752;
                if (*(void *)v752 == -1)
                {
                  v774 = 0;
LABEL_987:
                  if (v774) {
                    uint64_t v752 = v774;
                  }
                  if (*(void *)v752 != v751)
                  {
                    if (__src == v976) {
                      unsigned int v792 = v746;
                    }
                    else {
                      unsigned int v792 = v978;
                    }
                    uint64_t v752 = (char *)__src + 8 * v792;
                  }
                }
                else
                {
                  v774 = 0;
                  int v775 = 1;
                  while (v773 != v751)
                  {
                    if (v774) {
                      BOOL v776 = 0;
                    }
                    else {
                      BOOL v776 = v773 == -2;
                    }
                    if (v776) {
                      v774 = v752;
                    }
                    unsigned int v777 = v772 + v775++;
                    unsigned int v772 = v777 & v771;
                    uint64_t v752 = (char *)__src + 8 * (v777 & v771);
                    uint64_t v773 = *(void *)v752;
                    if (*(void *)v752 == -1) {
                      goto LABEL_987;
                    }
                  }
                }
              }
              if (__src == v745) {
                unsigned int v754 = v746;
              }
              else {
                unsigned int v754 = v978;
              }
              if (v752 == (char *)__src + 8 * v754)
              {
                unint64_t v755 = *(void *)(v744 + 8);
                uint64_t v756 = *(void *)(*(void *)(a1 + 16) + 288);
                if (v755 >= 8 && (uint64_t v757 = *(void *)((v755 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
                {
                  v758 = (void *)(v757 + 24);
                }
                else
                {
                  uint64_t v797 = *(unsigned int *)(v756 + 544);
                  if (v797)
                  {
                    unsigned int v798 = *(_DWORD *)((v755 & 0xFFFFFFFFFFFFFFF8) + 24) | (v755 >> 1) & 3;
                    uint64_t v785 = *(void **)(v756 + 536);
                    unint64_t v784 = *(unsigned int *)(v756 + 544);
                    do
                    {
                      unint64_t v780 = v784 >> 1;
                      v781 = &v785[2 * (v784 >> 1)];
                      uint64_t v783 = *v781;
                      uint64_t v782 = v781 + 2;
                      v784 += ~(v784 >> 1);
                      if (((v783 >> 1) & 3 | *(_DWORD *)((v783 & 0xFFFFFFFFFFFFFFF8) + 24)) < v798) {
                        uint64_t v785 = v782;
                      }
                      else {
                        unint64_t v784 = v780;
                      }
                    }
                    while (v784);
                    if (v785 == (void *)(*(void *)(v756 + 536) + 16 * v797)
                      || ((*v785 >> 1) & 3 | *(_DWORD *)((*v785 & 0xFFFFFFFFFFFFFFF8) + 24)) > v798)
                    {
                      v785 -= 2;
                    }
                  }
                  else
                  {
                    uint64_t v785 = *(void **)(v756 + 536);
                  }
                  v758 = v785 + 1;
                }
                unint64_t v759 = *(void *)(v751 + 8);
                if (v759 >= 8 && (uint64_t v760 = *(void *)((v759 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
                {
                  size_t v761 = (void *)(v760 + 24);
                }
                else
                {
                  uint64_t v799 = *(void *)(v756 + 536);
                  unint64_t v800 = *(unsigned int *)(v756 + 544);
                  if (v800)
                  {
                    unsigned int v801 = *(_DWORD *)((v759 & 0xFFFFFFFFFFFFFFF8) + 24) | (v759 >> 1) & 3;
                    v791 = *(void **)(v756 + 536);
                    unint64_t v790 = v800;
                    do
                    {
                      unint64_t v786 = v790 >> 1;
                      v787 = &v791[2 * (v790 >> 1)];
                      uint64_t v789 = *v787;
                      int v788 = v787 + 2;
                      v790 += ~(v790 >> 1);
                      if (((v789 >> 1) & 3 | *(_DWORD *)((v789 & 0xFFFFFFFFFFFFFFF8) + 24)) < v801) {
                        v791 = v788;
                      }
                      else {
                        unint64_t v790 = v786;
                      }
                    }
                    while (v790);
                    if (v791 == (void *)(v799 + 16 * v800)
                      || ((*v791 >> 1) & 3 | *(_DWORD *)((*v791 & 0xFFFFFFFFFFFFFFF8) + 24)) > v801)
                    {
                      v791 -= 2;
                    }
                  }
                  else
                  {
                    v791 = *(void **)(v756 + 536);
                  }
                  size_t v761 = v791 + 1;
                }
                if (*v758 != *v761)
                {
                  llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 40));
                  llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
                }
                if ((*(_DWORD *)((v755 & 0xFFFFFFFFFFFFFFF8) + 24) | (v755 >> 1) & 3) >= (*(_DWORD *)((v759 & 0xFFFFFFFFFFFFFFF8) + 24) | (v759 >> 1) & 3)) {
                  uint64_t v926 = *v735;
                }
                else {
                  uint64_t v926 = *v741;
                }
                sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v976, v926);
              }
            }
            v762 = (unint64_t *)(v741 + 1);
            while (v762 != (unint64_t *)v737)
            {
              unint64_t v763 = *v762++;
              if (v763 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                v741 = (uint64_t *)(v762 - 1);
                goto LABEL_934;
              }
            }
            v741 = v737;
LABEL_934:
            uint64_t v726 = *v725;
            uint64_t v729 = v981;
            uint64_t i = (uint64_t **)(v981 + 96 * v726);
            int v732 = *i;
          }
          while (v738 != (unint64_t *)v737)
          {
            unint64_t v778 = *v738++;
            if (v778 <= 0xFFFFFFFFFFFFFFFDLL)
            {
              size_t v735 = (uint64_t *)(v738 - 1);
              goto LABEL_968;
            }
          }
          size_t v735 = v737;
LABEL_968:
          if (v731 == v732) {
            uint64_t v779 = 20;
          }
          else {
            uint64_t v779 = 16;
          }
        }
        while (v735 != &v731[*(unsigned int *)(v729 + 96 * v726 + v779)]);
      }
LABEL_997:
      uint64_t v597 = v953;
      uint64_t v162 = v973;
      uint64_t v723 = v958;
      if (HIDWORD(v978) == v979)
      {
LABEL_998:
        if (++v724 == v723) {
          goto LABEL_999;
        }
        continue;
      }
      break;
    }
    sub_1CC476FDC(a1, 0, v726);
    v802 = (unint64_t *)__src;
    if (__src == v976) {
      int v803 = (unint64_t *)((char *)&v978 + 4);
    }
    else {
      int v803 = &v978;
    }
    uint64_t v804 = *(unsigned int *)v803;
    v805 = (unint64_t *)((char *)__src + 8 * v804);
    if (v804)
    {
      uint64_t v806 = 8 * v804;
      while (*v802 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v802;
        v806 -= 8;
        if (!v806) {
          goto LABEL_1213;
        }
      }
    }
    if (v802 == v805)
    {
LABEL_1213:
      uint64_t v807 = 0;
      char v811 = 1;
      v802 = v805;
    }
    else
    {
      uint64_t v807 = 0;
      v808 = v802;
LABEL_1031:
      ++v807;
      uint64_t v809 = v808 + 1;
      while (v809 != v805)
      {
        unint64_t v810 = *v809++;
        if (v810 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v808 = v809 - 1;
          goto LABEL_1031;
        }
      }
      char v811 = 0;
    }
    int v812 = v972;
    if (v807 + (unint64_t)v972 > HIDWORD(v972)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if ((v811 & 1) == 0)
    {
      v813 = (unint64_t *)((char *)v971 + 8 * v972);
      unint64_t v814 = *v802;
LABEL_1039:
      unint64_t *v813 = v814;
      int v815 = v802 + 1;
      while (v815 != v805)
      {
        unint64_t v816 = *v815++;
        unint64_t v814 = v816;
        if (v816 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          ++v813;
          v802 = v815 - 1;
          goto LABEL_1039;
        }
      }
    }
    LODWORD(v972) = v812 + v807;
    uint64_t v723 = v958;
    if (__src != v976)
    {
      if (v978 >= 0x21 && 4 * (HIDWORD(v978) - v979) < v978)
      {
        llvm::SmallPtrSetImplBase::shrink_and_clear(&v976);
        goto LABEL_998;
      }
      memset(__src, 255, 8 * v978);
    }
    unsigned int v979 = 0;
    HIDWORD(v978) = 0;
    goto LABEL_998;
  }
LABEL_999:
  if (__src != v976) {
    free(__src);
  }
  size_t v794 = (char *)v981;
  int v38 = dword_1CD912700 + 30976;
  if (DWORD2(v981))
  {
    uint64_t v795 = 96 * DWORD2(v981);
    do
    {
      v796 = *(void **)&v794[v795 - 88];
      if (v796 != *(void **)&v794[v795 - 96]) {
        free(v796);
      }
      v795 -= 96;
    }
    while (v795);
    size_t v794 = (char *)v981;
  }
  if (v794 != (char *)&v982) {
    free(v794);
  }
  uint64_t v183 = *(void *)(a1 + 16);
  uint64_t v184 = *(void *)(a1 + 80);
LABEL_196:
  unint64_t v186 = *(_DWORD *)(**(void **)(v184 + 16) + 4 * *(unsigned int *)(v184 + 64)) & 0x7FFFFFFF;
  uint64_t v187 = (void *)(v183 + 408);
  unint64_t v188 = *(unsigned int *)(v183 + 416);
  BOOL v64 = v186 >= v188;
  unint64_t v189 = v186 - v188;
  if (v64)
  {
    sub_1CB9153B8((uint64_t)v187, v189 + 1, *(void *)(v183 + 424));
LABEL_1247:
    llvm::LiveIntervals::createInterval();
  }
  uint64_t v190 = *(void *)(*v187 + 8 * v186);
  if (!v190) {
    goto LABEL_1247;
  }
  *(void *)&long long v982 = *((void *)v38 + 126);
  *(void *)&long long v981 = a1 + 200;
  *((void *)&v981 + 1) = (char *)&v982 + 8;
  if (!v972) {
    goto LABEL_199;
  }
  uint64_t v526 = (char *)v971;
  uint64_t v527 = (char *)v971 + 8 * v972;
  while (2)
  {
    unint64_t v528 = *(void *)(*(void *)v526 + 8);
    if (v528 < 8) {
      uint64_t v529 = 0;
    }
    else {
      uint64_t v529 = *(llvm::MachineInstr **)((v528 & 0xFFFFFFFFFFFFFFF8) + 16);
    }
    v530 = v162;
    v531 = *(llvm::MachineInstr **)(*((void *)v529 + 3) + 56);
    if (v529 == v531)
    {
      int v536 = 1;
      unint64_t v532 = (unint64_t)v529;
    }
    else
    {
      unint64_t v532 = (unint64_t)v529;
      do
      {
        unint64_t v532 = *(void *)v532 & 0xFFFFFFFFFFFFFFF8;
        if (!v532 || (*(unsigned char *)v532 & 4) == 0)
        {
          while ((*(_WORD *)(v532 + 44) & 4) != 0)
            unint64_t v532 = *(void *)v532 & 0xFFFFFFFFFFFFFFF8;
        }
        unsigned int v533 = **(unsigned __int16 **)(v532 + 16);
        BOOL v303 = v533 > 0x17;
        int v534 = (1 << v533) & 0x83E000;
        if (v303 || v534 == 0)
        {
          int v536 = 0;
          goto LABEL_596;
        }
        int v536 = 1;
      }
      while ((llvm::MachineInstr *)v532 != v531);
      unint64_t v532 = *(void *)(*((void *)v529 + 3) + 56);
    }
LABEL_596:
    llvm::LiveIntervals::removeVRegDefAt(*(void *)(a1 + 16), v190, *(void *)(*(void *)v526 + 8));
    unint64_t v537 = *(int32x2_t **)(*(void *)(a1 + 16) + 288);
    int32x2_t v538 = v537[46];
    uint64_t v539 = v537[48].u32[0];
    if (v539)
    {
      LODWORD(v540) = (v539 - 1) & ((v529 >> 4) ^ (v529 >> 9));
      uint64_t v541 = (llvm::MachineInstr **)(*(void *)&v538 + 16 * v540);
      uint64_t v542 = *v541;
      if (*v541 == v529) {
        goto LABEL_598;
      }
      int v565 = 1;
      while (v542 != (llvm::MachineInstr *)-4096)
      {
        int v566 = v540 + v565++;
        uint64_t v540 = v566 & (v539 - 1);
        uint64_t v542 = *(llvm::MachineInstr **)(*(void *)&v538 + 16 * v540);
        if (v542 == v529)
        {
          uint64_t v541 = (llvm::MachineInstr **)(*(void *)&v538 + 16 * v540);
          goto LABEL_598;
        }
      }
    }
    uint64_t v541 = (llvm::MachineInstr **)(*(void *)&v538 + 16 * v539);
LABEL_598:
    if (v541 != (llvm::MachineInstr **)(*(void *)&v538 + 16 * v539))
    {
      unint64_t v543 = (unint64_t)v541[1] & 0xFFFFFFFFFFFFFFF8;
      *uint64_t v541 = (llvm::MachineInstr *)-8192;
      v537[47] = vadd_s32(v537[47], (int32x2_t)0x1FFFFFFFFLL);
      *(void *)(v543 + 16) = 0;
    }
    llvm::MachineInstr::eraseFromParent(v529);
    unsigned int v544 = (v528 >> 1) & 3;
    unint64_t v545 = v528 & 0xFFFFFFFFFFFFFFF8;
    if (v544) {
      uint64_t v546 = v545 | (2 * (v544 - 1));
    }
    else {
      uint64_t v546 = *(void *)v545 | 6;
    }
    sub_1CC478B64((uint64_t)&v981, v546);
    if (!v982) {
      goto LABEL_620;
    }
    if (*(_DWORD *)(*((void *)&v981 + 1) + 12) >= *(_DWORD *)(*((void *)&v981 + 1) + 8)) {
      goto LABEL_620;
    }
    uint64_t v547 = *((void *)&v981 + 1) + 16 * v982;
    uint64_t v548 = *(void *)(v547 - 16);
    uint64_t v549 = *(unsigned int *)(v547 - 4);
    unsigned int v550 = (*(void *)(v548 + 16 * v549) >> 1) & 3 | *(_DWORD *)((*(void *)(v548 + 16 * v549) & 0xFFFFFFFFFFFFFFF8)
                                                                              + 24);
    unsigned int v551 = *(_DWORD *)(v545 + 24) | v544;
    if (v550 >= v551 || *(void *)(v548 + 16 * v549 + 8) != v528) {
      goto LABEL_620;
    }
    unsigned int v552 = *(_DWORD *)(v548 + 4 * v549 + 144);
    if (v536)
    {
      int v553 = *(uint64_t **)(*(void *)(a1 + 80) + 8);
      goto LABEL_608;
    }
    __int16 v567 = *(_WORD *)(v532 + 44);
    unint64_t v568 = v532;
    if ((v567 & 4) != 0)
    {
      do
        unint64_t v568 = *(void *)v568 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v568 + 44) & 4) != 0);
    }
    unint64_t v569 = v532;
    if ((v567 & 8) != 0)
    {
      do
        unint64_t v569 = *(void *)(v569 + 8);
      while ((*(_WORD *)(v569 + 44) & 8) != 0);
    }
    unint64_t v570 = *(void *)(v569 + 8);
    if (v568 != v570)
    {
      while (1)
      {
        unsigned int v571 = **(unsigned __int16 **)(v568 + 16);
        BOOL v303 = v571 > 0x17;
        int v572 = (1 << v571) & 0x83E000;
        if (v303 || v572 == 0) {
          break;
        }
        unint64_t v568 = *(void *)(v568 + 8);
        if (v568 == v570)
        {
          unint64_t v568 = v570;
          break;
        }
      }
    }
    uint64_t v574 = *(void *)(*(void *)(a1 + 16) + 288);
    uint64_t v575 = *(void *)(v574 + 368);
    uint64_t v576 = *(unsigned int *)(v574 + 384);
    if (!v576)
    {
LABEL_803:
      unint64_t v578 = (uint64_t *)(v575 + 16 * v576);
      goto LABEL_637;
    }
    LODWORD(v577) = ((v568 >> 4) ^ (v568 >> 9)) & (v576 - 1);
    unint64_t v578 = (uint64_t *)(v575 + 16 * v577);
    uint64_t v579 = *v578;
    if (v568 != *v578)
    {
      int v590 = 1;
      while (v579 != -4096)
      {
        int v591 = v577 + v590++;
        uint64_t v577 = v591 & (v576 - 1);
        uint64_t v579 = *(void *)(v575 + 16 * v577);
        if (v568 == v579)
        {
          unint64_t v578 = (uint64_t *)(v575 + 16 * v577);
          goto LABEL_637;
        }
      }
      goto LABEL_803;
    }
LABEL_637:
    int v553 = *(uint64_t **)(*(void *)(a1 + 80) + 8);
    uint64_t v580 = *(unsigned int *)(v532 + 40);
    if (v580)
    {
      int v581 = 0;
      char v582 = 0;
      int v583 = 0;
      unint64_t v584 = v578[1] & 0xFFFFFFFFFFFFFFF8;
      v585 = (_DWORD *)(*(void *)(v532 + 32) + 4);
      do
      {
        unsigned int v586 = *(v585 - 1);
        if (!(_BYTE)v586 && *v585 == *((_DWORD *)v553 + 28))
        {
          int v587 = (v586 >> 28) & 1;
          if ((v586 & 0xFFF00) == 0) {
            int v587 = 1;
          }
          int v588 = v587 | v583;
          int v589 = v587 ^ 1 | v581;
          if ((v586 & 0x1000000) != 0) {
            int v583 = v588;
          }
          else {
            v582 |= (v586 & 0x10000000) == 0;
          }
          if ((v586 & 0x1000000) != 0) {
            int v581 = v589;
          }
        }
        v585 += 8;
        --v580;
      }
      while (v580);
      if (((v582 & 1) != 0 || ((v581 ^ 1 | v583) & 1) == 0) && (*(_DWORD *)(v584 + 24) | 2u) > v550)
      {
        sub_1CD57C548((uint64_t)&v981, v584 | 4);
        goto LABEL_620;
      }
    }
LABEL_608:
    unint64_t v554 = *((unsigned int *)v553 + 2);
    uint64_t v555 = *v553;
    if (!v554)
    {
      LODWORD(v554) = 0;
      goto LABEL_805;
    }
    uint64_t v556 = *(void *)(v555 + 24 * v554 - 16);
    unsigned int v557 = (v556 >> 1) & 3 | *(_DWORD *)((v556 & 0xFFFFFFFFFFFFFFF8) + 24);
    uint64_t v558 = v555;
    unint64_t v559 = v554;
    if (v551 >= v557)
    {
LABEL_805:
      uint64_t v558 = v555 + 24 * v554;
      goto LABEL_616;
    }
    do
    {
      unint64_t v560 = v559 >> 1;
      uint64_t v561 = *(void *)(v558 + 24 * (v559 >> 1) + 8);
      LODWORD(v561) = (v561 >> 1) & 3 | *(_DWORD *)((v561 & 0xFFFFFFFFFFFFFFF8) + 24);
      v559 -= (v559 >> 1) + 1;
      BOOL v562 = v551 >= v561;
      if (v551 >= v561) {
        unint64_t v563 = v560 + 1;
      }
      else {
        unint64_t v563 = 0;
      }
      v558 += 24 * v563;
      if (!v562) {
        unint64_t v559 = v560;
      }
    }
    while (v559);
LABEL_616:
    uint64_t v564 = v555 + 24 * v554;
    if (v558 == v564
      || ((*(void *)v558 >> 1) & 3 | *(_DWORD *)((*(void *)v558 & 0xFFFFFFFFFFFFFFF8) + 24)) > v551)
    {
      uint64_t v558 = v564;
    }
    sub_1CC476FDC(a1, v552, **(unsigned int **)(v558 + 16));
LABEL_620:
    v526 += 8;
    uint64_t v162 = v530;
    if (v526 != v527) {
      continue;
    }
    break;
  }
  int v38 = dword_1CD912700 + 30976;
  if (*((long long **)&v981 + 1) != (long long *)((char *)&v982 + 8)) {
    free(*((void **)&v981 + 1));
  }
LABEL_199:
  if (v971 != v162) {
    free(v971);
  }
  MEMORY[0x1D25D9CD0](v968, 4);
  if (v974[0] != v975) {
    free(v974[0]);
  }
  if ((_OWORD *)v1028 != v1029) {
    free((void *)v1028);
  }
  unint64_t v37 = a1;
LABEL_206:
  v954 = (void *)(v37 + 200);
  *(void *)&long long v1028 = v37 + 200;
  *((void *)&v1028 + 1) = (char *)v1029 + 8;
  *(void *)&v1029[0] = *((void *)v38 + 126);
  BOOL v191 = *(void **)&v1029[0];
  sub_1CC47ECE8((uint64_t *)&v1028);
  *(void *)&long long v981 = v1028;
  *((void *)&v981 + 1) = (char *)&v982 + 8;
  *(void *)&long long v982 = v191;
  if (LODWORD(v1029[0])) {
    sub_1CC2D01B8((uint64_t)&v981 + 8, (uint64_t)&v1028 + 8);
  }
  if (*((_OWORD **)&v1028 + 1) != (_OWORD *)((char *)v1029 + 8)) {
    free(*((void **)&v1028 + 1));
  }
  uint64_t v192 = *(void *)(*(void *)(a1 + 80) + 8);
  unsigned int v193 = *(_DWORD *)(v192 + 8);
  if (v193)
  {
    char v957 = 0;
    uint64_t v194 = *(uint64_t **)v192;
    uint64_t v195 = *(void *)v192 + 24 * v193;
    uint64_t v949 = v195;
    while (1)
    {
      uint64_t v960 = v194[2];
      uint64_t v196 = *v194;
      int v197 = v982;
      if (!v982 || *(_DWORD *)(*((void *)&v981 + 1) + 12) >= *(_DWORD *)(*((void *)&v981 + 1) + 8)) {
        goto LABEL_218;
      }
      uint64_t v198 = *((void *)&v981 + 1) + 16 * v982;
      if (*(_DWORD *)(v981 + 184))
      {
        uint64_t v277 = *(void *)(v198 - 16);
        uint64_t v278 = *(void *)(v277 + 16 * (*(_DWORD *)(v198 - 8) - 1) + 8);
        unsigned int v279 = (v278 >> 1) & 3 | *(_DWORD *)((v278 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v280 = *(_DWORD *)((v196 & 0xFFFFFFFFFFFFFFF8) + 24) | (v196 >> 1) & 3;
        if (v279 <= v280)
        {
          LODWORD(v982) = v982 - 1;
          unsigned int v644 = v197 - 2;
          if (v197 == 2)
          {
            uint64_t v645 = *(unsigned int *)(*((void *)&v981 + 1) + 12);
            goto LABEL_752;
          }
          uint64_t v914 = (v197 - 3);
          if (v914)
          {
            uint64_t v930 = v196;
            uint64_t v931 = v195;
            v932 = v194;
            uint64_t v933 = *(void *)(*(void *)(*((void *)&v981 + 1) + 16 * v914)
                             + 8 * *(unsigned int *)(*((void *)&v981 + 1) + 16 * v914 + 12)
                             + 96);
            if (((v933 >> 1) & 3 | *(_DWORD *)((v933 & 0xFFFFFFFFFFFFFFF8) + 24)) > v280)
            {
LABEL_1327:
              uint64_t v934 = *((void *)&v981 + 1) + 16 * v644;
              uint64_t v935 = *(void *)v934;
              unsigned int v938 = *(_DWORD *)(v934 + 12);
              v936 = (_DWORD *)(v934 + 12);
              unsigned int v937 = v938;
              do
                uint64_t v939 = *(void *)(v935 + 8 * v937++ + 96);
              while (((v939 >> 1) & 3 | *(_DWORD *)((v939 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v280);
              _DWORD *v936 = v937 - 1;
              uint64_t v196 = v930;
              sub_1CC481060((uint64_t)&v981, v930);
              uint64_t v194 = v932;
              uint64_t v195 = v931;
              goto LABEL_218;
            }
            uint64_t v940 = 16 * v914;
            while (1)
            {
              LODWORD(v982) = v644;
              uint64_t v941 = v940 - 16;
              uint64_t v194 = v932;
              uint64_t v195 = v931;
              uint64_t v196 = v930;
              if (v940 == 16) {
                break;
              }
              uint64_t v942 = *(void *)(*(void *)(*((void *)&v981 + 1) + v940 - 16)
                               + 8 * *(unsigned int *)(*((void *)&v981 + 1) + v940 - 4)
                               + 96);
              unsigned int v943 = (v942 >> 1) & 3 | *(_DWORD *)((v942 & 0xFFFFFFFFFFFFFFF8) + 24);
              --v644;
              uint64_t v940 = v941;
              if (v943 > v280) {
                goto LABEL_1327;
              }
            }
          }
          uint64_t v645 = *(unsigned int *)(*((void *)&v981 + 1) + 12);
          if (((*(void *)(v981 + 8 * v645 + 96) >> 1) & 3 | *(_DWORD *)((*(void *)(v981 + 8 * v645 + 96) & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 24)) <= v280)
          {
LABEL_752:
            int v646 = *(_DWORD *)(v981 + 188);
            if (v645 != v646)
            {
              while (1)
              {
                uint64_t v647 = *(void *)(v981 + 8 + 8 * v645 + 88);
                if (((v647 >> 1) & 3 | *(_DWORD *)((v647 & 0xFFFFFFFFFFFFFFF8) + 24)) > v280) {
                  break;
                }
                uint64_t v645 = (v645 + 1);
                if (v646 == v645)
                {
                  uint64_t v645 = *(unsigned int *)(v981 + 188);
                  break;
                }
              }
            }
            sub_1CC47EE8C(&v981, v645);
            if (!v982
              || *(_DWORD *)(*((void *)&v981 + 1) + 12) >= *(_DWORD *)(*((void *)&v981 + 1) + 8))
            {
              goto LABEL_218;
            }
          }
          else
          {
            unsigned int v915 = *(_DWORD *)(*((void *)&v981 + 1) + 28);
            do
              uint64_t v916 = *(void *)(*(void *)(*((void *)&v981 + 1) + 16) + 8 * v915++ + 96);
            while (((v916 >> 1) & 3 | *(_DWORD *)((v916 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v280);
            *(_DWORD *)(*((void *)&v981 + 1) + 28) = v915 - 1;
          }
          sub_1CC481060((uint64_t)&v981, v196);
          goto LABEL_218;
        }
        unsigned int v281 = *(_DWORD *)(v198 - 4);
        do
          uint64_t v282 = *(void *)(v277 + 16 * v281++ + 8);
        while (((v282 >> 1) & 3 | *(_DWORD *)((v282 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v280);
        unsigned int v199 = v281 - 1;
      }
      else
      {
        unsigned int v199 = *(_DWORD *)(v198 - 4);
        int v200 = *(_DWORD *)(v981 + 188);
        if (v199 != v200)
        {
          while (1)
          {
            uint64_t v201 = *(void *)(v981 + 16 * v199 + 8);
            if (((v201 >> 1) & 3 | *(_DWORD *)((v201 & 0xFFFFFFFFFFFFFFF8) + 24)) > (*(_DWORD *)((v196 & 0xFFFFFFFFFFFFFFF8) + 24) | (v196 >> 1) & 3)) {
              break;
            }
            if (v200 == ++v199)
            {
              unsigned int v199 = *(_DWORD *)(v981 + 188);
              break;
            }
          }
        }
      }
      *(_DWORD *)(v198 - 4) = v199;
LABEL_218:
      uint64_t v202 = v194[1];
      do
      {
        unint64_t v203 = v196;
        if (!v982 || *(_DWORD *)(*((void *)&v981 + 1) + 12) >= *(_DWORD *)(*((void *)&v981 + 1) + 8))
        {
          int v208 = 0;
LABEL_223:
          uint64_t v196 = v202;
          goto LABEL_224;
        }
        uint64_t v204 = *((void *)&v981 + 1) + 16 * v982;
        uint64_t v205 = *(void *)(v204 - 16);
        uint64_t v206 = *(unsigned int *)(v204 - 4);
        unsigned int v207 = (*(void *)(v205 + 16 * v206) >> 1) & 3 | *(_DWORD *)((*(void *)(v205 + 16 * v206) & 0xFFFFFFFFFFFFFFF8)
                                                                                  + 24);
        if (v207 > (*(_DWORD *)((v196 & 0xFFFFFFFFFFFFFFF8) + 24) | (v196 >> 1) & 3))
        {
          int v208 = 0;
          if (v207 >= (*(_DWORD *)((v202 & 0xFFFFFFFFFFFFFFF8) + 24) | (v202 >> 1) & 3)) {
            uint64_t v196 = v202;
          }
          else {
            uint64_t v196 = *(void *)(v205 + 16 * v206);
          }
        }
        else
        {
          int v208 = *(_DWORD *)(v205 + 4 * v206 + 144);
          uint64_t v196 = *(void *)(v205 + 16 * v206 + 8);
          if (((v196 >> 1) & 3 | *(_DWORD *)((v196 & 0xFFFFFFFFFFFFFFF8) + 24)) >= (*(_DWORD *)((v202 & 0xFFFFFFFFFFFFFFF8) + 24) | (v202 >> 1) & 3)) {
            goto LABEL_223;
          }
          sub_1CC476878((uint64_t)&v981);
        }
LABEL_224:
        uint64_t v209 = *(void *)(a1 + 16);
        unint64_t v210 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16)
                         + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + v208)) & 0x7FFFFFFF;
        char v211 = (void *)(v209 + 408);
        unint64_t v212 = *(unsigned int *)(v209 + 416);
        BOOL v64 = v210 >= v212;
        unint64_t v213 = v210 - v212;
        if (v64)
        {
          sub_1CB9153B8((uint64_t)v211, v213 + 1, *(void *)(v209 + 424));
LABEL_1207:
          llvm::LiveIntervals::createInterval();
        }
        uint64_t v965 = *(void *)(*v211 + 8 * v210);
        if (!v965) {
          goto LABEL_1207;
        }
        int v214 = *(_DWORD *)(a1 + 416);
        if (v214)
        {
          int v215 = *(_DWORD *)v960;
          uint64_t v216 = *(void *)(a1 + 400);
          unint64_t v217 = ((37 * v215) | ((unint64_t)(37 * v208) << 32))
               + ~((unint64_t)(37 * v215) << 32);
          unint64_t v218 = (v217 ^ (v217 >> 22)) + ~((v217 ^ (v217 >> 22)) << 13);
          unint64_t v219 = (9 * (v218 ^ (v218 >> 8))) ^ ((9 * (v218 ^ (v218 >> 8))) >> 15);
          unsigned int v220 = ((v219 + ~(v219 << 27)) >> 31) ^ (v219 + ~(v219 << 27));
          unsigned int v221 = v214 - 1;
          uint64_t v222 = (v214 - 1) & v220;
          uint64_t v223 = (int *)(v216 + 16 * v222);
          int v225 = *v223;
          int v224 = v223[1];
          if (v208 == v225 && v215 == v224)
          {
LABEL_232:
            uint64_t v227 = *(void *)(v216 + 16 * v222 + 8);
            if ((v227 & 0xFFFFFFFFFFFFFFF8) != 0)
            {
              v976 = (void *)v203;
              __src = (void *)v196;
              unint64_t v978 = v227 & 0xFFFFFFFFFFFFFFF8;
              llvm::LiveRange::addSegment(v965, (uint64_t)&v976);
              goto LABEL_235;
            }
            if ((v227 & 4) != 0)
            {
              char v957 = 1;
              goto LABEL_235;
            }
          }
          else
          {
            int v228 = 1;
            while (v225 != -1 || v224 != -1)
            {
              int v283 = v222 + v228++;
              uint64_t v222 = v283 & v221;
              unsigned int v284 = (int *)(v216 + 16 * v222);
              int v225 = *v284;
              int v224 = v284[1];
              if (v208 == v225 && v215 == v224) {
                goto LABEL_232;
              }
            }
          }
        }
        if (v208) {
          BOOL v229 = *(_DWORD *)(a1 + 92) == 0;
        }
        else {
          BOOL v229 = 1;
        }
        unsigned int v230 = !v229;
        uint64_t v231 = *(void *)(*(void *)(a1 + 16) + 288);
        if (v203 >= 8 && (uint64_t v232 = *(void *)((v203 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
        {
          uint64_t v233 = (void *)(v232 + 24);
        }
        else
        {
          uint64_t v662 = *(unsigned int *)(v231 + 544);
          if (v662)
          {
            unsigned int v663 = *(_DWORD *)((v203 & 0xFFFFFFFFFFFFFFF8) + 24) | (v203 >> 1) & 3;
            uint64_t v291 = *(void **)(v231 + 536);
            unint64_t v290 = *(unsigned int *)(v231 + 544);
            do
            {
              unint64_t v286 = v290 >> 1;
              char v287 = &v291[2 * (v290 >> 1)];
              uint64_t v289 = *v287;
              uint64_t v288 = v287 + 2;
              v290 += ~(v290 >> 1);
              if (((v289 >> 1) & 3 | *(_DWORD *)((v289 & 0xFFFFFFFFFFFFFFF8) + 24)) < v663) {
                uint64_t v291 = v288;
              }
              else {
                unint64_t v290 = v286;
              }
            }
            while (v290);
            if (v291 == (void *)(*(void *)(v231 + 536) + 16 * v662)
              || ((*v291 >> 1) & 3 | *(_DWORD *)((*v291 & 0xFFFFFFFFFFFFFFF8) + 24)) > v663)
            {
              v291 -= 2;
            }
          }
          else
          {
            uint64_t v291 = *(void **)(v231 + 536);
          }
          uint64_t v233 = v291 + 1;
        }
        uint64_t v234 = a1 + 704 * v230 + 424;
        uint64_t v235 = *v233;
        int v236 = (uint64_t *)(*(void *)(v231 + 392) + 16 * *(unsigned int *)(*v233 + 24));
        unint64_t v237 = v196 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v951 = v196;
        if (v203 == *v236)
        {
          unsigned int v239 = (v196 >> 1) & 3;
          unsigned int v243 = *(_DWORD *)((v203 & 0xFFFFFFFFFFFFFFF8) + 24) | (v203 >> 1) & 3;
          unsigned int v244 = *(_DWORD *)(v237 + 24) | v239;
        }
        else
        {
          unint64_t v203 = v236[1];
          uint64_t v238 = v196;
          unsigned int v239 = (v196 >> 1) & 3;
          unsigned int v240 = (v203 >> 1) & 3;
          if ((*(_DWORD *)(v237 + 24) | v239) >= (*(_DWORD *)((v203 & 0xFFFFFFFFFFFFFFF8) + 24) | v240)) {
            uint64_t v241 = v236[1];
          }
          else {
            uint64_t v241 = v238;
          }
          uint64_t v242 = llvm::LiveRange::extendInBlock(v965, *v236, v241);
          unsigned int v243 = *(_DWORD *)((v203 & 0xFFFFFFFFFFFFFFF8) + 24) | v240;
          unsigned int v244 = *(_DWORD *)(v237 + 24) | v239;
          if (v243 <= v244)
          {
            unint64_t v245 = *(unsigned int *)(v235 + 24);
            *(void *)(*(void *)(v234 + 40) + ((v245 >> 3) & 0x1FFFFFF8)) |= 1 << v245;
            size_t v246 = (uint64_t *)(*(void *)(v234 + 136) + 16 * v245);
            *size_t v246 = v242;
            v246[1] = 0;
          }
          uint64_t v235 = *(void *)(v235 + 8);
        }
        if (v243 < v244)
        {
          v950 = v194;
          while (1)
          {
            unint64_t v247 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392)
                             + 16 * *(unsigned int *)(v235 + 24)
                             + 8);
            unint64_t v248 = v247 & 0xFFFFFFFFFFFFFFF8;
            unsigned int v249 = (v247 >> 1) & 3;
            unsigned int v250 = v249 | *(_DWORD *)((v247 & 0xFFFFFFFFFFFFFFF8) + 24);
            if (v203 == *(void *)(v960 + 8))
            {
              if (v244 >= v250) {
                uint64_t v633 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392)
              }
                                 + 16 * *(unsigned int *)(v235 + 24)
                                 + 8);
              else {
                uint64_t v633 = v951;
              }
              uint64_t v634 = llvm::LiveRange::extendInBlock(v965, v203, v633);
              if ((*(_DWORD *)(v237 + 24) | v239) >= (*(_DWORD *)(v248 + 24) | v249))
              {
                unint64_t v635 = *(unsigned int *)(v235 + 24);
                *(void *)(*(void *)(v234 + 40) + ((v635 >> 3) & 0x1FFFFFF8)) |= 1 << v635;
                uint64_t v636 = (uint64_t *)(*(void *)(v234 + 136) + 16 * v635);
                *uint64_t v636 = v634;
                v636[1] = 0;
              }
              goto LABEL_266;
            }
            uint64_t v251 = *(void *)(a1 + 40);
            llvm::MachineDominatorTree::applySplitCriticalEdges((void ***)v251);
            uint64_t v252 = *(void *)(v251 + 1320);
            uint64_t v253 = *(void *)(v252 + 24);
            uint64_t v254 = *(unsigned int *)(v252 + 40);
            if (v244 < v250)
            {
              if (v254)
              {
                LODWORD(v267) = (v254 - 1) & ((v235 >> 4) ^ (v235 >> 9));
                uint64_t v268 = (uint64_t *)(v253 + 16 * v267);
                uint64_t v269 = *v268;
                if (*v268 == v235)
                {
LABEL_275:
                  if (v268 == (uint64_t *)(v253 + 16 * v254)) {
                    uint64_t v270 = 0;
                  }
                  else {
                    uint64_t v270 = v268[1];
                  }
                  *(void *)&long long v1028 = v965;
                  *((void *)&v1028 + 1) = v270;
                  v1029[0] = (unint64_t)v951;
                  uint64_t v271 = *(unsigned int *)(v234 + 184);
                  unint64_t v272 = *(void *)(v234 + 176);
                  if (v271 >= *(_DWORD *)(v234 + 188))
                  {
                    BOOL v847 = v272 + 32 * v271 > (unint64_t)&v1028;
                    if (v272 > (unint64_t)&v1028 || !v847) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  uint64_t v273 = (_OWORD *)(v272 + 32 * *(unsigned int *)(v234 + 184));
                  long long v274 = v1029[0];
                  _OWORD *v273 = v1028;
                  v273[1] = v274;
                  ++*(_DWORD *)(v234 + 184);
                  goto LABEL_266;
                }
                int v275 = 1;
                while (v269 != -4096)
                {
                  int v276 = v267 + v275++;
                  uint64_t v267 = v276 & (v254 - 1);
                  uint64_t v269 = *(void *)(v253 + 16 * v267);
                  if (v269 == v235)
                  {
                    uint64_t v268 = (uint64_t *)(v253 + 16 * v267);
                    goto LABEL_275;
                  }
                }
              }
              uint64_t v268 = (uint64_t *)(v253 + 16 * v254);
              goto LABEL_275;
            }
            if (!v254) {
              goto LABEL_272;
            }
            LODWORD(v255) = (v254 - 1) & ((v235 >> 4) ^ (v235 >> 9));
            uint64_t v256 = (uint64_t *)(v253 + 16 * v255);
            uint64_t v257 = *v256;
            if (*v256 != v235) {
              break;
            }
LABEL_262:
            if (v256 == (uint64_t *)(v253 + 16 * v254)) {
              uint64_t v258 = 0;
            }
            else {
              uint64_t v258 = v256[1];
            }
            *(void *)&long long v1028 = v965;
            *((void *)&v1028 + 1) = v258;
            v1029[0] = 0uLL;
            uint64_t v259 = *(unsigned int *)(v234 + 184);
            unint64_t v260 = *(void *)(v234 + 176);
            if (v259 >= *(_DWORD *)(v234 + 188))
            {
              BOOL v643 = v260 + 32 * v259 > (unint64_t)&v1028;
              if (v260 > (unint64_t)&v1028 || !v643) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v261 = (_OWORD *)(v260 + 32 * *(unsigned int *)(v234 + 184));
            long long v262 = v1029[0];
            *uint64_t v261 = v1028;
            v261[1] = v262;
            ++*(_DWORD *)(v234 + 184);
            unint64_t v263 = *(unsigned int *)(v235 + 24);
            *(void *)(*(void *)(v234 + 40) + ((v263 >> 3) & 0x1FFFFFF8)) |= 1 << v263;
            uint64_t v264 = (void *)(*(void *)(v234 + 136) + 16 * v263);
            *uint64_t v264 = 0;
            v264[1] = 0;
LABEL_266:
            uint64_t v235 = *(void *)(v235 + 8);
            unsigned int v244 = *(_DWORD *)(v237 + 24) | v239;
            unint64_t v203 = v247;
            if ((*(_DWORD *)(v248 + 24) | v249) >= v244)
            {
              uint64_t v195 = v949;
              uint64_t v194 = v950;
              goto LABEL_287;
            }
          }
          int v265 = 1;
          while (v257 != -4096)
          {
            int v266 = v255 + v265++;
            uint64_t v255 = v266 & (v254 - 1);
            uint64_t v257 = *(void *)(v253 + 16 * v255);
            if (v257 == v235)
            {
              uint64_t v256 = (uint64_t *)(v253 + 16 * v255);
              goto LABEL_262;
            }
          }
LABEL_272:
          uint64_t v256 = (uint64_t *)(v253 + 16 * v254);
          goto LABEL_262;
        }
LABEL_287:
        uint64_t v196 = v951;
LABEL_235:
        uint64_t v202 = v194[1];
      }
      while (v196 != v202);
      v194 += 3;
      if (v194 == (uint64_t *)v195) {
        goto LABEL_314;
      }
    }
  }
  char v957 = 0;
LABEL_314:
  llvm::LiveRangeCalc::updateSSA(a1 + 424);
  llvm::LiveRangeCalc::updateFromLiveIns((llvm::LiveRangeCalc *)(a1 + 424));
  if (*(_DWORD *)(a1 + 92))
  {
    llvm::LiveRangeCalc::updateSSA(a1 + 1128);
    llvm::LiveRangeCalc::updateFromLiveIns((llvm::LiveRangeCalc *)(a1 + 1128));
  }
  if (*((long long **)&v981 + 1) != (long long *)((char *)&v982 + 8)) {
    free(*((void **)&v981 + 1));
  }
  *(void *)&long long v1028 = v1029;
  *((void *)&v1028 + 1) = v191;
  uint64_t v292 = *(void *)(a1 + 32);
  uint64_t v293 = *(unsigned int *)(*(void *)(*(void *)(a1 + 80) + 8) + 112);
  if ((v293 & 0x80000000) != 0) {
    uint64_t v294 = (uint64_t *)(*(void *)(v292 + 24) + 16 * (v293 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v294 = (uint64_t *)(*(void *)(v292 + 272) + 8 * v293);
  }
  uint64_t v295 = *v294;
  if (!*v294) {
    goto LABEL_423;
  }
  unint64_t v296 = v954;
  while (2)
  {
    uint64_t v297 = v295;
    uint64_t v295 = *(void *)(v295 + 24);
    uint64_t v298 = *(void *)(v297 + 8);
    if (**(unsigned __int16 **)(v298 + 16) - 13 <= 1)
    {
      llvm::MachineOperand::setReg(v297, 0);
      goto LABEL_359;
    }
    __int16 v299 = *(_WORD *)(v298 + 44);
    unint64_t v300 = *(void *)(v297 + 8);
    if ((v299 & 4) != 0)
    {
      do
        unint64_t v300 = *(void *)v300 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v300 + 44) & 4) != 0);
    }
    if ((v299 & 8) != 0)
    {
      do
        uint64_t v298 = *(void *)(v298 + 8);
      while ((*(_WORD *)(v298 + 44) & 8) != 0);
    }
    unint64_t v301 = *(void *)(v298 + 8);
    if (v300 != v301)
    {
      while (1)
      {
        unsigned int v302 = **(unsigned __int16 **)(v300 + 16);
        BOOL v303 = v302 > 0x17;
        int v304 = (1 << v302) & 0x83E000;
        if (v303 || v304 == 0) {
          break;
        }
        unint64_t v300 = *(void *)(v300 + 8);
        if (v300 == v301)
        {
          unint64_t v300 = v301;
          break;
        }
      }
    }
    uint64_t v306 = *(void *)(a1 + 16);
    uint64_t v307 = *(void *)(v306 + 288);
    uint64_t v308 = *(void *)(v307 + 368);
    uint64_t v309 = *(unsigned int *)(v307 + 384);
    if (v309)
    {
      LODWORD(v310) = ((v300 >> 4) ^ (v300 >> 9)) & (v309 - 1);
      uint64_t v311 = (uint64_t *)(v308 + 16 * v310);
      uint64_t v312 = *v311;
      if (v300 == *v311) {
        goto LABEL_333;
      }
      int v339 = 1;
      while (v312 != -4096)
      {
        int v340 = v310 + v339++;
        uint64_t v310 = v340 & (v309 - 1);
        uint64_t v312 = *(void *)(v308 + 16 * v310);
        if (v300 == v312)
        {
          uint64_t v311 = (uint64_t *)(v308 + 16 * v310);
          goto LABEL_333;
        }
      }
    }
    uint64_t v311 = (uint64_t *)(v308 + 16 * v309);
LABEL_333:
    uint64_t v313 = 2;
    if ((*(_DWORD *)v297 & 0x40000000) == 0) {
      uint64_t v313 = 4;
    }
    if ((*(_DWORD *)v297 & 0x11000000) != 0) {
      unint64_t v314 = v313 | v311[1] & 0xFFFFFFFFFFFFFFF8;
    }
    else {
      unint64_t v314 = v311[1];
    }
    int v315 = *(_DWORD *)(a1 + 388);
    if (!v315) {
      goto LABEL_374;
    }
    unsigned int v316 = *(_DWORD *)((v314 & 0xFFFFFFFFFFFFFFF8) + 24) | (v314 >> 1) & 3;
    if (v316 < ((*v296 >> 1) & 3 | *(_DWORD *)((*v296 & 0xFFFFFFFFFFFFFFF8) + 24))) {
      goto LABEL_374;
    }
    unsigned int v317 = *(_DWORD *)(a1 + 384);
    unsigned int v318 = v315 - 1;
    uint64_t v319 = (uint64_t)&v296[2 * v318 + 1];
    uint64_t v320 = (void *)(a1 + 208 + 8 * v318 + 88);
    if (!v317) {
      uint64_t v320 = (void *)v319;
    }
    if (((*v320 >> 1) & 3 | *(_DWORD *)((*v320 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v316) {
      goto LABEL_374;
    }
    if (v317)
    {
      int v324 = sub_1CC481228((uint64_t)v296, v314);
    }
    else
    {
      do
      {
        unsigned int v321 = v317;
        uint64_t v322 = v296[2 * v317 + 1];
        unsigned int v323 = (v322 >> 1) & 3 | *(_DWORD *)((v322 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v317 = v321 + 1;
      }
      while (v323 <= v316);
      if (v316 >= ((v296[2 * v321] >> 1) & 3 | *(_DWORD *)((v296[2 * v321] & 0xFFFFFFFFFFFFFFF8) + 24)))
      {
        int v324 = *((_DWORD *)v296 + v321 + 36);
        goto LABEL_347;
      }
LABEL_374:
      int v324 = 0;
    }
LABEL_347:
    int v325 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16)
                     + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + v324));
    uint64_t v326 = v325 & 0x7FFFFFFF;
    unint64_t v327 = (void *)(v306 + 408);
    uint64_t v328 = *(unsigned int *)(v306 + 416);
    if ((v325 & 0x7FFFFFFFu) >= v328)
    {
      sub_1CB9153B8((uint64_t)v327, v326 - v328 + 1, *(void *)(v306 + 424));
LABEL_1102:
      operator new();
    }
    uint64_t v329 = *(void *)(*v327 + 8 * v326);
    if (!v329) {
      goto LABEL_1102;
    }
    llvm::MachineOperand::setReg(v297, *(_DWORD *)(v329 + 112));
    unint64_t v296 = v954;
    if (v957)
    {
      int v330 = *(_DWORD *)v297;
      if ((*(_DWORD *)v297 & 0x10000000) == 0)
      {
        if ((v330 & 0x1000000) == 0)
        {
          unint64_t v331 = v314 & 0xFFFFFFFFFFFFFFF8;
          unsigned int v332 = ((v314 & 0xFFFFFFF8) >> 1) | 1;
LABEL_353:
          int v333 = v332 & 3;
          if (v333 == 3) {
            unint64_t v334 = *(void *)(v331 + 8) & 0xFFFFFFFFFFFFFFF9;
          }
          else {
            unint64_t v334 = v331 | (2 * v333 + 2);
          }
          if (*(void *)(v329 + 104))
          {
            if ((v330 & 0x1000000) == 0)
            {
              long long v335 = *(_OWORD *)(v297 + 16);
              long long v981 = *(_OWORD *)v297;
              long long v982 = v335;
              LODWORD(v983) = v324;
              *((void *)&v983 + 1) = v334;
              if (DWORD2(v1028) >= HIDWORD(v1028))
              {
                if ((unint64_t)v1028 > (unint64_t)&v981
                  || (unint64_t)v1028 + 48 * DWORD2(v1028) <= (unint64_t)&v981)
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v336 = (_OWORD *)(v1028 + 48 * DWORD2(v1028));
              long long v337 = v981;
              long long v338 = v983;
              v336[1] = v982;
              v336[2] = v338;
              *uint64_t v336 = v337;
              ++DWORD2(v1028);
            }
          }
          else
          {
            if (v324) {
              BOOL v341 = *(_DWORD *)(a1 + 92) == 0;
            }
            else {
              BOOL v341 = 1;
            }
            unsigned int v342 = !v341;
            llvm::LiveRangeCalc::extend((llvm::LiveRangeCalc *)(a1 + 704 * v342 + 424), v329, v334, 0, 0, 0);
          }
          goto LABEL_359;
        }
        if ((v330 & 0x400FFF00) == 0) {
          goto LABEL_359;
        }
        unsigned int v343 = (v314 >> 1) & 3;
        unint64_t v344 = v314 & 0xFFFFFFFFFFFFFFF8;
        if (v343) {
          uint64_t v345 = v344 | (2 * (v343 - 1));
        }
        else {
          uint64_t v345 = *(void *)v344 | 6;
        }
        uint64_t v346 = *(void *)(*(void *)(a1 + 80) + 8);
        unint64_t v347 = *(unsigned int *)(v346 + 8);
        uint64_t v348 = *(void **)v346;
        if (v347)
        {
          uint64_t v349 = v348[3 * v347 - 2];
          unsigned int v350 = *(_DWORD *)((v345 & 0xFFFFFFFFFFFFFFF8) + 24) | (v345 >> 1) & 3;
          unsigned int v351 = (v349 >> 1) & 3 | *(_DWORD *)((v349 & 0xFFFFFFFFFFFFFFF8) + 24);
          uint64_t v352 = v348;
          unint64_t v353 = v347;
          if (v350 < v351)
          {
            do
            {
              unint64_t v354 = v353 >> 1;
              uint64_t v355 = v352[3 * (v353 >> 1) + 1];
              LODWORD(v355) = (v355 >> 1) & 3 | *(_DWORD *)((v355 & 0xFFFFFFFFFFFFFFF8) + 24);
              v353 -= (v353 >> 1) + 1;
              BOOL v356 = v350 >= v355;
              if (v350 >= v355) {
                unint64_t v357 = v354 + 1;
              }
              else {
                unint64_t v357 = 0;
              }
              v352 += 3 * v357;
              if (!v356) {
                unint64_t v353 = v354;
              }
            }
            while (v353);
            goto LABEL_386;
          }
        }
        else
        {
          LODWORD(v347) = 0;
        }
        uint64_t v352 = &v348[3 * v347];
LABEL_386:
        if (v352 != &v348[3 * v347])
        {
          unint64_t v331 = v345 & 0xFFFFFFFFFFFFFFF8;
          if (((*v352 >> 1) & 3 | *(_DWORD *)((*v352 & 0xFFFFFFFFFFFFFFF8) + 24)) <= (*(_DWORD *)((v345 & 0xFFFFFFFFFFFFFFF8) + 24) | (v345 >> 1) & 3))
          {
            unsigned int v332 = v345 >> 1;
            goto LABEL_353;
          }
        }
      }
    }
LABEL_359:
    if (v295) {
      continue;
    }
    break;
  }
  if (DWORD2(v1028))
  {
    int v358 = (unsigned int *)v1028;
    uint64_t v961 = v1028 + 48 * DWORD2(v1028);
    do
    {
      uint64_t v359 = *(void *)(a1 + 16);
      unint64_t v360 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16)
                       + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + v358[8])) & 0x7FFFFFFF;
      int32x2_t v361 = (void *)(v359 + 408);
      unint64_t v362 = *(unsigned int *)(v359 + 416);
      BOOL v64 = v360 >= v362;
      unint64_t v363 = v360 - v362;
      if (v64)
      {
        sub_1CB9153B8((uint64_t)v361, v363 + 1, *(void *)(v359 + 424));
LABEL_1211:
        llvm::LiveIntervals::createInterval();
      }
      uint64_t v364 = *(void *)(*v361 + 8 * v360);
      if (!v364) {
        goto LABEL_1211;
      }
      long long v981 = 0u;
      long long v982 = 0u;
      *(void *)&long long v983 = 0;
      *((void *)&v983 + 1) = v985;
      uint64_t v984 = 0x600000000;
      int v986 = 0;
      v987 = 0;
      v988 = 0;
      unsigned int v989 = 0;
      uint64_t v993 = 0;
      uint64_t v994 = 0;
      uint64_t v992 = 0;
      v991 = &v993;
      v995 = v997;
      uint64_t v996 = 0x1000000000;
      unint64_t v365 = ((unint64_t)*v358 >> 8) & 0xFFF;
      if (v365) {
        uint64_t v366 = (uint64_t *)(*(void *)(*(void *)(a1 + 56) + 232) + 8 * v365);
      }
      else {
        uint64_t v366 = (uint64_t *)((*(void *)(*(void *)(*(void *)(a1 + 32) + 24) + 16 * (v358[1] & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8)
      }
                         + 24);
      uint64_t v367 = *(void *)(v364 + 104);
      if (v367)
      {
        uint64_t v368 = *v366;
        do
        {
          if ((*(void *)(v367 + 112) & v368) != 0)
          {
            if (*(_DWORD *)(v367 + 8))
            {
              uint64_t v369 = *(void *)(a1 + 16);
              uint64_t v370 = *(void *)(v369 + 288);
              uint64_t v371 = *(void *)(a1 + 40);
              uint64_t v372 = *(void *)(*(void *)(*(void *)(a1 + 24) + 272) + 40);
              *(void *)&long long v981 = *(void *)(*(void *)(a1 + 24) + 272);
              *((void *)&v981 + 1) = v372;
              *(void *)&long long v982 = v370;
              *((void *)&v982 + 1) = v371;
              *(void *)&long long v983 = v369 + 312;
              llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)&v981);
              LODWORD(v996) = 0;
              v976 = &v978;
              __src = v191;
              llvm::LiveInterval::computeSubRangeUndefs(v364, (uint64_t)&v976, *(void *)(v367 + 112), *(void **)(a1 + 32), *(void *)(*(void *)(a1 + 16) + 288));
              llvm::LiveRangeCalc::extend((llvm::LiveRangeCalc *)&v981, v367, *((void *)v358 + 5), 0, v976, __src);
              if (v976 != &v978) {
                free(v976);
              }
            }
          }
          uint64_t v367 = *(void *)(v367 + 104);
        }
        while (v367);
        if (v995 != v997) {
          free(v995);
        }
      }
      if (v991 != &v993) {
        free(v991);
      }
      uint64_t v373 = v987;
      if (v989)
      {
        BOOL v375 = v987 + 12;
        uint64_t v376 = 152 * v989;
        do
        {
          uint64_t v374 = *(v375 - 12);
          if (v374 != -4096 && v374 != -8192)
          {
            uint64_t v377 = (void *)*(v375 - 2);
            if (v375 != v377) {
              free(v377);
            }
            uint64_t v378 = (void *)*(v375 - 11);
            if (v375 - 9 != v378) {
              free(v378);
            }
          }
          v375 += 19;
          v376 -= 152;
        }
        while (v376);
        uint64_t v373 = v987;
      }
      MEMORY[0x1D25D9CD0](v373, 8);
      if (*((unsigned char **)&v983 + 1) != v985) {
        free(*((void **)&v983 + 1));
      }
      v358 += 12;
    }
    while (v358 != (unsigned int *)v961);
  }
LABEL_423:
  uint64_t v379 = *(void *)(a1 + 80);
  uint64_t v380 = *(uint64_t **)(v379 + 16);
  uint64_t v381 = *(unsigned int *)(v379 + 64);
  uint64_t v382 = *((unsigned int *)v380 + 2);
  if (v381 != v382)
  {
    uint64_t v383 = *v380;
    uint64_t v384 = (_DWORD *)(v383 + 4 * v382);
    unsigned int v385 = (_DWORD *)(v383 + 4 * v381);
    do
    {
      uint64_t v386 = *(void *)(a1 + 16);
      unint64_t v387 = *v385 & 0x7FFFFFFF;
      uint64_t v388 = (void *)(v386 + 408);
      unint64_t v389 = *(unsigned int *)(v386 + 416);
      BOOL v64 = v387 >= v389;
      unint64_t v390 = v387 - v389;
      if (v64)
      {
        sub_1CB9153B8((uint64_t)v388, v390 + 1, *(void *)(v386 + 424));
LABEL_1225:
        llvm::LiveIntervals::createInterval();
      }
      uint64_t v391 = *(void *)(*v388 + 8 * v387);
      if (!v391) {
        goto LABEL_1225;
      }
      unint64_t v393 = (void *)(v391 + 104);
      uint64_t v392 = *(void *)(v391 + 104);
      if (v392)
      {
        *(_DWORD *)(v391 + 72) = 0;
        *(_DWORD *)(v391 + 8) = 0;
        while (1)
        {
          uint64_t v394 = v392;
          if (!*(_DWORD *)(v392 + 8)) {
            break;
          }
LABEL_432:
          unint64_t v393 = (void *)(v392 + 104);
          uint64_t v392 = *(void *)(v392 + 104);
          if (!v392) {
            goto LABEL_433;
          }
        }
        while (1)
        {
          uint64_t v944 = *(void *)(v394 + 96);
          uint64_t v392 = *(void *)(v394 + 104);
          *(void *)(v394 + 96) = 0;
          if (v944)
          {
            sub_1CB833A08(v944, *(void **)(v944 + 8));
            MEMORY[0x1D25D9CE0](v944, 0x1020C4062D53EE8);
          }
          v945 = *(void **)(v394 + 64);
          if (v945 != (void *)(v394 + 80)) {
            free(v945);
          }
          if (*(void *)v394 != v394 + 16) {
            free(*(void **)v394);
          }
          if (!v392) {
            break;
          }
          uint64_t v394 = v392;
          if (*(_DWORD *)(v392 + 8))
          {
            *unint64_t v393 = v392;
            goto LABEL_432;
          }
        }
        *unint64_t v393 = 0;
LABEL_433:
        llvm::LiveIntervals::constructMainRangeFromSubranges(*(llvm::LiveIntervals **)(a1 + 16), (llvm::LiveInterval *)v391);
      }
      ++v385;
    }
    while (v385 != v384);
  }
  if ((_OWORD *)v1028 != v1029) {
    free((void *)v1028);
  }
  uint64_t v395 = *(void *)(a1 + 80);
  if ((v957 & 1) == 0)
  {
    uint64_t v471 = a2;
    goto LABEL_514;
  }
  uint64_t v396 = *(void *)(v395 + 8);
  uint64_t v397 = *(unsigned int *)(v396 + 72);
  if (v397)
  {
    uint64_t v398 = *(void *)(v396 + 64);
    uint64_t v399 = v398 + 8 * v397;
    while (2)
    {
      unint64_t v400 = *(void *)(*(void *)v398 + 8);
      if (v400 < 8 || (*(void *)(*(void *)v398 + 8) & 6) != 0) {
        goto LABEL_443;
      }
      int v402 = *(_DWORD *)(a1 + 388);
      if (!v402) {
        goto LABEL_774;
      }
      unsigned int v403 = *(_DWORD *)((v400 & 0xFFFFFFFFFFFFFFF8) + 24) | (v400 >> 1) & 3;
      if (v403 < ((*v954 >> 1) & 3 | *(_DWORD *)((*v954 & 0xFFFFFFFFFFFFFFF8) + 24))) {
        goto LABEL_774;
      }
      unsigned int v404 = v402 - 1;
      unint64_t v405 = a1 + 8 * (v402 - 1);
      int v406 = *(_DWORD *)(a1 + 384);
      uint64_t v407 = &v954[2 * v404 + 1];
      v408 = (void *)(v405 + 296);
      if (v406) {
        uint64_t v407 = v408;
      }
      if (((*v407 >> 1) & 3 | *(_DWORD *)((*v407 & 0xFFFFFFFFFFFFFFF8) + 24)) <= v403) {
        goto LABEL_774;
      }
      if (v406)
      {
        int v413 = sub_1CC481228((uint64_t)v954, *(void *)(*(void *)v398 + 8));
      }
      else
      {
        unsigned int v409 = 0;
        do
        {
          unsigned int v410 = v409;
          uint64_t v411 = v954[2 * v409 + 1];
          unsigned int v412 = (v411 >> 1) & 3 | *(_DWORD *)((v411 & 0xFFFFFFFFFFFFFFF8) + 24);
          unsigned int v409 = v410 + 1;
        }
        while (v412 <= v403);
        if (v403 >= ((v954[2 * v410] >> 1) & 3 | *(_DWORD *)((v954[2 * v410] & 0xFFFFFFFFFFFFFFF8) + 24)))
        {
          int v413 = *((_DWORD *)v954 + v410 + 36);
          goto LABEL_455;
        }
LABEL_774:
        int v413 = 0;
      }
LABEL_455:
      uint64_t v414 = *(void *)(a1 + 16);
      unint64_t v415 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16)
                       + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + v413)) & 0x7FFFFFFF;
      v416 = (void *)(v414 + 408);
      unint64_t v417 = *(unsigned int *)(v414 + 416);
      BOOL v64 = v415 >= v417;
      unint64_t v418 = v415 - v417;
      if (v64)
      {
        sub_1CB9153B8((uint64_t)v416, v418 + 1, *(void *)(v414 + 424));
LABEL_1269:
        llvm::LiveIntervals::createInterval();
      }
      uint64_t v419 = *(void *)(*v416 + 8 * v415);
      if (!v419) {
        goto LABEL_1269;
      }
      int v420 = *(_DWORD *)(a1 + 92);
      uint64_t v421 = *(void *)(v414 + 288);
      if (v400 >= 8 && (uint64_t v422 = *(void *)((v400 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
      {
        uint64_t v423 = (uint64_t *)(v422 + 24);
      }
      else
      {
        uint64_t v838 = *(void *)(v421 + 536);
        unint64_t v839 = *(unsigned int *)(v421 + 544);
        if (v839)
        {
          unsigned int v840 = *(_DWORD *)((v400 & 0xFFFFFFFFFFFFFFF8) + 24) | (v400 >> 1) & 3;
          v841 = *(void **)(v421 + 536);
          unint64_t v842 = v839;
          do
          {
            unint64_t v843 = v842 >> 1;
            v844 = &v841[2 * (v842 >> 1)];
            uint64_t v846 = *v844;
            v845 = v844 + 2;
            v842 += ~(v842 >> 1);
            if (((v846 >> 1) & 3 | *(_DWORD *)((v846 & 0xFFFFFFFFFFFFFFF8) + 24)) < v840) {
              v841 = v845;
            }
            else {
              unint64_t v842 = v843;
            }
          }
          while (v842);
          if (v841 == (void *)(v838 + 16 * v839)
            || ((*v841 >> 1) & 3 | *(_DWORD *)((*v841 & 0xFFFFFFFFFFFFFFF8) + 24)) > v840)
          {
            v841 -= 2;
          }
        }
        else
        {
          v841 = *(void **)(v421 + 536);
        }
        uint64_t v423 = v841 + 1;
      }
      uint64_t v424 = *v423;
      if ((sub_1CC478EF8(v400, v419) & 1) == 0)
      {
        if (v413) {
          BOOL v425 = v420 == 0;
        }
        else {
          BOOL v425 = 1;
        }
        unsigned int v426 = !v425;
        sub_1CC478D3C(a1, *(void *)(v424 + 64), *(void *)(v424 + 72), (llvm::LiveRangeCalc *)(a1 + 704 * v426 + 424), v419, -1, 0, 0);
      }
LABEL_443:
      v398 += 8;
      if (v398 == v399) {
        break;
      }
      continue;
    }
  }
  size_t v427 = v1029;
  *(void *)&long long v1028 = v1029;
  *((void *)&v1028 + 1) = v191;
  size_t v428 = v985;
  long long v981 = 0u;
  long long v982 = 0u;
  *(void *)&long long v983 = 0;
  *((void *)&v983 + 1) = v985;
  uint64_t v984 = 0x600000000;
  int v986 = 0;
  size_t v429 = &v993;
  v987 = 0;
  v988 = 0;
  unsigned int v989 = 0;
  v991 = &v993;
  uint64_t v992 = 0;
  uint64_t v994 = 0;
  uint64_t v993 = 0;
  v995 = v997;
  uint64_t v996 = 0x1000000000;
  uint64_t v430 = *(void *)(v396 + 104);
  if (!v430) {
    goto LABEL_503;
  }
  while (2)
  {
    uint64_t v431 = *(unsigned int *)(v430 + 72);
    if (v431)
    {
      uint64_t v432 = *(uint64_t **)(v430 + 64);
      uint64_t v433 = &v432[v431];
      while (2)
      {
        uint64_t v434 = *v432;
        unint64_t v435 = *(void *)(*v432 + 8);
        if (v435 < 8 || (*(void *)(*v432 + 8) & 6) != 0) {
          goto LABEL_476;
        }
        int v437 = *(_DWORD *)(a1 + 388);
        v962 = v429;
        if (v437)
        {
          unsigned int v438 = *(_DWORD *)((v435 & 0xFFFFFFFFFFFFFFF8) + 24) | (v435 >> 1) & 3;
          if (v438 >= ((*v954 >> 1) & 3 | *(_DWORD *)((*v954 & 0xFFFFFFFFFFFFFFF8) + 24)))
          {
            unsigned int v439 = v437 - 1;
            unint64_t v440 = a1 + 8 * (v437 - 1);
            int v441 = *(_DWORD *)(a1 + 384);
            size_t v442 = &v954[2 * v439 + 1];
            v443 = (void *)(v440 + 296);
            if (v441) {
              size_t v442 = v443;
            }
            if (((*v442 >> 1) & 3 | *(_DWORD *)((*v442 & 0xFFFFFFFFFFFFFFF8) + 24)) > v438)
            {
              if (v441)
              {
                v448 = v428;
                uint64_t v449 = v427;
                int v450 = sub_1CC481228((uint64_t)v954, v435);
              }
              else
              {
                unsigned int v444 = 0;
                do
                {
                  unsigned int v445 = v444;
                  uint64_t v446 = v954[2 * v444 + 1];
                  unsigned int v447 = (v446 >> 1) & 3 | *(_DWORD *)((v446 & 0xFFFFFFFFFFFFFFF8) + 24);
                  unsigned int v444 = v445 + 1;
                }
                while (v447 <= v438);
                v448 = v428;
                if (v438 >= ((v954[2 * v445] >> 1) & 3 | *(_DWORD *)((v954[2 * v445] & 0xFFFFFFFFFFFFFFF8)
                                                                                  + 24)))
                {
                  uint64_t v449 = v427;
                  int v450 = *((_DWORD *)v954 + v445 + 36);
                  goto LABEL_488;
                }
LABEL_784:
                uint64_t v449 = v427;
                int v450 = 0;
              }
LABEL_488:
              uint64_t v451 = *(void *)(a1 + 16);
              unint64_t v452 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16)
                               + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + v450)) & 0x7FFFFFFF;
              int v453 = (void *)(v451 + 408);
              unint64_t v454 = *(unsigned int *)(v451 + 416);
              BOOL v64 = v452 >= v454;
              unint64_t v455 = v452 - v454;
              if (v64)
              {
                sub_1CB9153B8((uint64_t)v453, v455 + 1, *(void *)(v451 + 424));
LABEL_1264:
                llvm::LiveIntervals::createInterval();
              }
              uint64_t v456 = *(void *)(*v453 + 8 * v452);
              if (!v456) {
                goto LABEL_1264;
              }
              uint64_t v457 = *(void *)(v456 + 104);
              if (v457)
              {
                size_t v427 = v449;
                size_t v428 = v448;
                size_t v429 = v962;
                do
                {
                  if (*(void *)(v457 + 112) == *(void *)(v430 + 112)) {
                    break;
                  }
                  uint64_t v457 = *(void *)(v457 + 104);
                }
                while (v457);
              }
              else
              {
                size_t v427 = v449;
                size_t v428 = v448;
                size_t v429 = v962;
              }
              if ((sub_1CC478EF8(*(void *)(v434 + 8), v457) & 1) == 0)
              {
                uint64_t v458 = *(void *)(a1 + 16);
                unint64_t v459 = *(void *)(v434 + 8);
                uint64_t v460 = *(void *)(v458 + 288);
                if (v459 >= 8 && (uint64_t v461 = *(void *)((v459 & 0xFFFFFFFFFFFFFFF8) + 16)) != 0)
                {
                  v462 = (uint64_t *)(v461 + 24);
                }
                else
                {
                  uint64_t v819 = *(unsigned int *)(v460 + 544);
                  if (v819)
                  {
                    unsigned int v820 = *(_DWORD *)((v459 & 0xFFFFFFFFFFFFFFF8) + 24) | (v459 >> 1) & 3;
                    size_t v821 = *(void **)(v460 + 536);
                    unint64_t v822 = *(unsigned int *)(v460 + 544);
                    do
                    {
                      unint64_t v823 = v822 >> 1;
                      uint64_t v824 = &v821[2 * (v822 >> 1)];
                      uint64_t v826 = *v824;
                      uint64_t v825 = v824 + 2;
                      v822 += ~(v822 >> 1);
                      if (((v826 >> 1) & 3 | *(_DWORD *)((v826 & 0xFFFFFFFFFFFFFFF8) + 24)) < v820) {
                        size_t v821 = v825;
                      }
                      else {
                        unint64_t v822 = v823;
                      }
                    }
                    while (v822);
                    if (v821 == (void *)(*(void *)(v460 + 536) + 16 * v819)
                      || ((*v821 >> 1) & 3 | *(_DWORD *)((*v821 & 0xFFFFFFFFFFFFFFF8) + 24)) > v820)
                    {
                      v821 -= 2;
                    }
                  }
                  else
                  {
                    size_t v821 = *(void **)(v460 + 536);
                  }
                  v462 = v821 + 1;
                }
                uint64_t v463 = *v462;
                uint64_t v464 = *(void *)(a1 + 40);
                uint64_t v465 = *(void *)(*(void *)(*(void *)(a1 + 24) + 272) + 40);
                *(void *)&long long v981 = *(void *)(*(void *)(a1 + 24) + 272);
                *((void *)&v981 + 1) = v465;
                *(void *)&long long v982 = v460;
                *((void *)&v982 + 1) = v464;
                *(void *)&long long v983 = v458 + 312;
                llvm::LiveRangeCalc::resetLiveOutMap((llvm::LiveRangeCalc *)&v981);
                LODWORD(v996) = 0;
                DWORD2(v1028) = 0;
                llvm::LiveInterval::computeSubRangeUndefs(v456, (uint64_t)&v1028, *(void *)(v430 + 112), *(void **)(a1 + 32), *(void *)(*(void *)(a1 + 16) + 288));
                sub_1CC478D3C(a1, *(void *)(v463 + 64), *(void *)(v463 + 72), (llvm::LiveRangeCalc *)&v981, v457, *(void *)(v430 + 112), (void *)v1028, DWORD2(v1028));
              }
LABEL_476:
              if (++v432 == v433) {
                goto LABEL_500;
              }
              continue;
            }
          }
        }
        break;
      }
      v448 = v428;
      goto LABEL_784;
    }
LABEL_500:
    uint64_t v430 = *(void *)(v430 + 104);
    if (v430) {
      continue;
    }
    break;
  }
  if (v995 != v997) {
    free(v995);
  }
LABEL_503:
  if (v991 != v429) {
    free(v991);
  }
  uint64_t v466 = v987;
  if (v989)
  {
    v903 = v987 + 12;
    uint64_t v904 = 152 * v989;
    do
    {
      uint64_t v905 = *(v903 - 12);
      if (v905 != -4096 && v905 != -8192)
      {
        v906 = (void *)*(v903 - 2);
        if (v903 != v906) {
          free(v906);
        }
        v907 = (void *)*(v903 - 11);
        if (v903 - 9 != v907) {
          free(v907);
        }
      }
      v903 += 19;
      v904 -= 152;
    }
    while (v904);
    uint64_t v466 = v987;
  }
  MEMORY[0x1D25D9CD0](v466, 8);
  if (*((unsigned char **)&v983 + 1) != v428) {
    free(*((void **)&v983 + 1));
  }
  if ((_OWORD *)v1028 != v427) {
    free((void *)v1028);
  }
  *(void *)&long long v981 = &v982;
  *((void *)&v981 + 1) = 0x800000000;
  uint64_t v467 = *(void *)(a1 + 80);
  uint64_t v468 = *(uint64_t **)(v467 + 16);
  uint64_t v469 = *(unsigned int *)(v467 + 64);
  uint64_t v470 = *((unsigned int *)v468 + 2);
  if (v469 != v470)
  {
    uint64_t v508 = *v468;
    uint64_t v509 = (_DWORD *)(v508 + 4 * v470);
    uint64_t v510 = (_DWORD *)(v508 + 4 * v469);
    do
    {
      uint64_t v511 = *(void *)(a1 + 16);
      uint64_t v512 = *v510 & 0x7FFFFFFF;
      v513 = (void *)(v511 + 408);
      uint64_t v514 = *(unsigned int *)(v511 + 416);
      if ((*v510 & 0x7FFFFFFFu) >= v514)
      {
        sub_1CB9153B8((uint64_t)v513, v512 - v514 + 1, *(void *)(v511 + 424));
LABEL_1181:
        operator new();
      }
      int v515 = *(uint64_t **)(*v513 + 8 * v512);
      if (!v515) {
        goto LABEL_1181;
      }
      unsigned int v516 = *((_DWORD *)v515 + 2);
      if (v516)
      {
        uint64_t v517 = *v515;
        uint64_t v518 = *v515 + 24 * v516;
        do
        {
          unint64_t v519 = *(void *)(*(void *)(v517 + 16) + 8);
          if ((v519 & 6) != 0 && *(void *)(v517 + 8) == (v519 & 0xFFFFFFFFFFFFFFF8 | 6))
          {
            if (v519 < 8) {
              uint64_t v521 = 0;
            }
            else {
              uint64_t v521 = *(void *)((v519 & 0xFFFFFFFFFFFFFFF8) + 16);
            }
            llvm::MachineInstr::addRegisterDead((llvm::MachineInstr *)v521, *((_DWORD *)v515 + 28), *(void *)(a1 + 56), 0);
            uint64_t v522 = *(unsigned int *)(v521 + 40);
            if (v522)
            {
              uint64_t v523 = *(_DWORD **)(v521 + 32);
              uint64_t v524 = 32 * v522;
              while ((*v523 & 0x10000FF) != 0x1000000 || (*v523 & 0x5000000) == 83886080)
              {
                v523 += 8;
                v524 -= 32;
                if (!v524) {
                  goto LABEL_578;
                }
              }
            }
            else
            {
LABEL_578:
              if (DWORD2(v981) >= (unint64_t)HIDWORD(v981)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(v981 + 8 * DWORD2(v981)) = v521;
              ++DWORD2(v981);
            }
          }
          v517 += 24;
        }
        while (v517 != v518);
      }
      ++v510;
    }
    while (v510 != v509);
    if (DWORD2(v981)) {
      llvm::LiveRangeEdit::eliminateDeadDefs(*(void **)(a1 + 80), (uint64_t)&v981, 0, 0, *(llvm::AAResults **)(a1 + 8));
    }
  }
  uint64_t v471 = a2;
  if ((long long *)v981 != &v982) {
    free((void *)v981);
  }
  uint64_t v395 = *(void *)(a1 + 80);
LABEL_514:
  __int16 v472 = *(uint64_t **)(v395 + 16);
  uint64_t v473 = *(unsigned int *)(v395 + 64);
  uint64_t v474 = *((unsigned int *)v472 + 2);
  if (v473 != v474)
  {
    uint64_t v475 = *v472;
    v476 = (_DWORD *)(v475 + 4 * v474);
    v477 = (_DWORD *)(v475 + 4 * v473);
    do
    {
      uint64_t v478 = *(void *)(a1 + 16);
      unint64_t v479 = *v477 & 0x7FFFFFFF;
      uint64_t v480 = (void *)(v478 + 408);
      unint64_t v481 = *(unsigned int *)(v478 + 416);
      BOOL v64 = v479 >= v481;
      unint64_t v482 = v479 - v481;
      if (v64)
      {
        sub_1CB9153B8((uint64_t)v480, v482 + 1, *(void *)(v478 + 424));
LABEL_1227:
        llvm::LiveIntervals::createInterval();
      }
      v483 = *(void **)(*v480 + 8 * v479);
      if (!v483) {
        goto LABEL_1227;
      }
      int v485 = v483 + 13;
      uint64_t v484 = v483[13];
      if (v484)
      {
        while (1)
        {
          uint64_t v486 = v484;
          if (!*(_DWORD *)(v484 + 8)) {
            break;
          }
LABEL_522:
          int v485 = (void *)(v484 + 104);
          uint64_t v484 = *(void *)(v484 + 104);
          if (!v484) {
            goto LABEL_519;
          }
        }
        while (1)
        {
          uint64_t v946 = *(void *)(v486 + 96);
          uint64_t v484 = *(void *)(v486 + 104);
          *(void *)(v486 + 96) = 0;
          if (v946)
          {
            sub_1CB833A08(v946, *(void **)(v946 + 8));
            MEMORY[0x1D25D9CE0](v946, 0x1020C4062D53EE8);
          }
          v947 = *(void **)(v486 + 64);
          if (v947 != (void *)(v486 + 80)) {
            free(v947);
          }
          if (*(void *)v486 != v486 + 16) {
            free(*(void **)v486);
          }
          if (!v484) {
            break;
          }
          uint64_t v486 = v484;
          if (*(_DWORD *)(v484 + 8))
          {
            *int v485 = v484;
            goto LABEL_522;
          }
        }
        *int v485 = 0;
      }
LABEL_519:
      llvm::LiveRange::RenumberValues((llvm::LiveRange *)v483);
      ++v477;
    }
    while (v477 != v476);
    uint64_t v395 = *(void *)(a1 + 80);
  }
  if (v471)
  {
    uint64_t v487 = (*(_DWORD *)(*(void *)(v395 + 16) + 8) - *(_DWORD *)(v395 + 64));
    *(_DWORD *)(v471 + 8) = 0;
    sub_1CC2D7744(v471, 0, v487);
    unint64_t v488 = a1;
    uint64_t v395 = *(void *)(a1 + 80);
  }
  else
  {
    unint64_t v488 = a1;
  }
  *(void *)&long long v1028 = *(void *)(v488 + 16);
  *((void *)&v1028 + 1) = (char *)v1029 + 8;
  *(void *)&v1029[0] = 0x800000000;
  int v1030 = 0;
  int v489 = *(_DWORD *)(*(void *)(v395 + 16) + 8);
  int v490 = *(_DWORD *)(v395 + 64);
  int v491 = v489 - v490;
  if (v489 != v490)
  {
    int v492 = 0;
    do
    {
      int v493 = *(_DWORD *)(**(void **)(*(void *)(a1 + 80) + 16)
                       + 4 * (*(_DWORD *)(*(void *)(a1 + 80) + 64) + v492));
      uint64_t v494 = *(void *)(a1 + 16);
      unint64_t v495 = v493 & 0x7FFFFFFF;
      v496 = (void *)(v494 + 408);
      unint64_t v497 = *(unsigned int *)(v494 + 416);
      BOOL v64 = v495 >= v497;
      unint64_t v498 = v495 - v497;
      if (v64)
      {
        sub_1CB9153B8((uint64_t)v496, v498 + 1, *(void *)(v494 + 424));
LABEL_1229:
        llvm::LiveIntervals::createInterval();
      }
      uint64_t v499 = *(const llvm::LiveRange **)(*v496 + 8 * v495);
      if (!v499) {
        goto LABEL_1229;
      }
      *(void *)&long long v981 = &v982;
      *((void *)&v981 + 1) = 0x800000000;
      llvm::LiveIntervals::splitSeparateComponents(v494, v499);
      if (DWORD2(v981))
      {
        v502 = (uint64_t *)v981;
        if (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 328) + 4 * v495)) {
          int v493 = *(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 328) + 4 * v495);
        }
        uint64_t v503 = 8 * DWORD2(v981);
        do
        {
          uint64_t v504 = *v502++;
          sub_1CC3044E0(*(void *)(a1 + 24), *(_DWORD *)(v504 + 112), v493);
          v503 -= 8;
        }
        while (v503);
      }
      if (v471)
      {
        uint64_t v500 = (*(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 16) + 8)
                            - *(_DWORD *)(*(void *)(a1 + 80) + 64));
        uint64_t v501 = *(unsigned int *)(v471 + 8);
        if (v501 != v500)
        {
          if (v501 <= v500)
          {
            int v505 = *(_DWORD *)(v471 + 8);
            if (v500 > *(_DWORD *)(v471 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v500 != v501)
            {
              size_t v506 = (_DWORD *)(*(void *)v471 + 4 * *(unsigned int *)(v471 + 8));
              uint64_t v507 = v501 - v500;
              do
              {
                *v506++ = v492;
                BOOL v64 = __CFADD__(v507++, 1);
              }
              while (!v64);
              int v505 = *(_DWORD *)(v471 + 8);
            }
            LODWORD(v500) = v505 + v500 - v501;
          }
          *(_DWORD *)(v471 + 8) = v500;
        }
      }
      if ((long long *)v981 != &v982) {
        free((void *)v981);
      }
      ++v492;
    }
    while (v492 != v491);
    unint64_t v488 = a1;
    uint64_t v395 = *(void *)(a1 + 80);
  }
  llvm::LiveRangeEdit::calculateRegClassAndHint((llvm::LiveRangeEdit *)v395, *(llvm::MachineFunction **)(*(void *)(v488 + 24) + 272), *(llvm::VirtRegAuxInfo **)(v488 + 72));
  if (*((_OWORD **)&v1028 + 1) != (_OWORD *)((char *)v1029 + 8)) {
    free(*((void **)&v1028 + 1));
  }
}

BOOL sub_1CC47E344(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t v5 = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFF8;
  BOOL v7 = (v4 & 0xFFFFFFFFFFFFFFF8) == v5;
  BOOL v6 = (v4 & 0xFFFFFFFFFFFFFFF8) != v5;
  BOOL v7 = !v7 || a3 == 0;
  if (v7) {
    return v6;
  }
  int v9 = *(unsigned __int8 *)(a2 + 32);
  int v10 = *(unsigned __int8 *)(a2 + 33);
  if (v9) {
    BOOL v11 = v10 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  if (!v11) {
    return 1;
  }
  int v12 = **(unsigned __int16 **)(*(void *)((v4 & 0xFFFFFFFFFFFFFFF8) + 16) + 16);
  if (v12 == 11 || v12 == 19) {
    return 0;
  }
  return sub_1CD57C280(a1, v4);
}

void sub_1CC47E3B0(uint64_t a1)
{
}

void sub_1CC47E50C(uint64_t a1, unsigned int a2, int a3, unint64_t a4, int a5, unint64_t a6)
{
  unint64_t v8 = *(llvm::MachineBasicBlock **)(*(void *)(*(void *)(*(void *)(a1 + 24) + 272) + 104) + 8 * a2);
  if (a5)
  {
    if (a3)
    {
      int v12 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392) + 16 * a2);
      uint64_t v13 = *v12;
      uint64_t v14 = v12[1];
      if (a3 == a5 && a4 <= 7 && a6 <= 7)
      {
        *(_DWORD *)(a1 + 88) = a5;
        uint64_t v15 = a1 + 200;
        uint64_t v16 = v13;
        uint64_t v17 = v14;
        int v18 = a5;
LABEL_25:
        sub_1CC4781D8(v15, v16, v17, v18);
        return;
      }
      uint64_t v19 = sub_1CC41A70C(*(uint64_t **)a1, a2);
      if (a3 != a5)
      {
        if (a4 < 8 || a6 < 8)
        {
          *(_DWORD *)(a1 + 88) = a5;
          if (a4 < 8) {
            goto LABEL_23;
          }
          unsigned int v20 = *(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24);
LABEL_21:
          if ((v20 | (a4 >> 1) & 3) < (*(_DWORD *)((v19 & 0xFFFFFFFFFFFFFFF8) + 24) | (v19 >> 1) & 3))
          {
            uint64_t v22 = sub_1CC477CDC(a1, a4);
            sub_1CC4781D8(a1 + 200, v22, v14, *(_DWORD *)(a1 + 88));
LABEL_24:
            *(_DWORD *)(a1 + 88) = a3;
            uint64_t v15 = a1 + 200;
            uint64_t v16 = v13;
            uint64_t v17 = v22;
            int v18 = a3;
            goto LABEL_25;
          }
LABEL_23:
          uint64_t v22 = sub_1CC477F10(a1, v8);
          goto LABEL_24;
        }
        unsigned int v20 = *(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24);
        if (v20 > (*(_DWORD *)((a6 & 0xFFFFFFFFFFFFFFF8) + 24) | 3u))
        {
          *(_DWORD *)(a1 + 88) = a5;
          goto LABEL_21;
        }
      }
      *(_DWORD *)(a1 + 88) = a5;
      unint64_t v21 = sub_1CC477DE0(a1, a6);
      sub_1CC4781D8(a1 + 200, v21, v14, *(_DWORD *)(a1 + 88));
      *(_DWORD *)(a1 + 88) = a3;
      uint64_t v17 = sub_1CC4786D0((void *)a1, a4);
      int v18 = *(_DWORD *)(a1 + 88);
      uint64_t v15 = a1 + 200;
      uint64_t v16 = v13;
      goto LABEL_25;
    }
    *(_DWORD *)(a1 + 88) = a5;
    sub_1CC477F10(a1, v8);
  }
  else
  {
    *(_DWORD *)(a1 + 88) = a3;
    sub_1CC4787D8(a1, (uint64_t)v8);
  }
}

void sub_1CC47E738(_DWORD *a1, uint64_t a2, int a3, unint64_t a4)
{
  uint64_t v8 = *(unsigned int *)(*(void *)a2 + 24);
  uint64_t v9 = *(void *)(*(void *)(*(void *)(*((void *)a1 + 2) + 288) + 392) + 16 * v8);
  if (*(unsigned char *)(a2 + 33)
    || (unint64_t v10 = *(void *)(a2 + 16), a4 >= 8)
    && (*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3) < (*(_DWORD *)((v10 & 0xFFFFFFFFFFFFFFF8)
                                                                                                  + 24) | (v10 >> 1) & 3))
  {
    uint64_t v15 = *(void *)(*(void *)a1 + 56);
    unint64_t v16 = *(void *)(v15 + 16 * v8);
    if (v16 < 8 || *(void *)(v15 + 16 * v8 + 8) >= 8uLL) {
      unint64_t v16 = sub_1CC4754EC((void *)(*(void *)a1 + 48), *(void *)(*(void *)a1 + 40), *(llvm::MachineBasicBlock **)a2);
    }
    uint64_t v17 = *(void *)(a2 + 16);
    unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFF8;
    if (a4 <= 7)
    {
      int v19 = *(_DWORD *)(v18 + 24);
    }
    else
    {
      int v19 = *(_DWORD *)(v18 + 24);
      if ((*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3) <= (v19 | 3u)) {
        sub_1CC477C68((uint64_t)a1);
      }
    }
    unsigned int v20 = *(_DWORD *)((v16 & 0xFFFFFFFFFFFFFFF8) + 24) | (v16 >> 1) & 3;
    a1[22] = a3;
    if ((v19 | (v17 >> 1) & 3) >= v20)
    {
      uint64_t v21 = sub_1CC4786D0(a1, v16);
      sub_1CC478948((unint64_t)a1, v21, *(void *)(a2 + 16));
      uint64_t v11 = (uint64_t)(a1 + 50);
      int v14 = a1[22];
      uint64_t v12 = v9;
      unint64_t v13 = v21;
    }
    else
    {
      unint64_t v13 = sub_1CC47849C((unint64_t)a1, v17);
      uint64_t v11 = (uint64_t)(a1 + 50);
      int v14 = a1[22];
      uint64_t v12 = v9;
    }
  }
  else
  {
    a1[22] = a3;
    uint64_t v11 = (uint64_t)(a1 + 50);
    uint64_t v12 = v9;
    unint64_t v13 = v10;
    int v14 = a3;
  }

  sub_1CC4781D8(v11, v12, v13, v14);
}

void sub_1CC47E9D0(uint64_t a1, uint64_t a2, int a3, unint64_t a4)
{
  uint64_t v8 = *(llvm::MachineBasicBlock **)a2;
  uint64_t v9 = *(unsigned int *)(*(void *)a2 + 24);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 16) + 288) + 392) + 16 * v9 + 8);
  uint64_t v11 = *(void *)a1;
  uint64_t v12 = *(void *)(*(void *)a1 + 40);
  uint64_t v13 = *(void *)(*(void *)a1 + 56);
  unint64_t v14 = *(void *)(v13 + 16 * v9);
  if (v14 < 8 || *(void *)(v13 + 16 * v9 + 8) >= 8uLL) {
    unint64_t v14 = sub_1CC4754EC((void *)(v11 + 48), v12, v8);
  }
  unint64_t v15 = *(void *)(a2 + 8);
  if (!*(unsigned char *)(a2 + 32))
  {
    if (a4 < 8
      || (unsigned int v19 = *(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3,
          unsigned int v20 = *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFF8) + 24),
          v19 <= (v20 | (v15 >> 1) & 3)))
    {
      *(_DWORD *)(a1 + 88) = a3;
      uint64_t v16 = a1 + 200;
      uint64_t v17 = v10;
      int v18 = a3;
      goto LABEL_6;
    }
    goto LABEL_17;
  }
  unint64_t v21 = v15 & 0xFFFFFFFFFFFFFFF8;
  if (a4 > 7)
  {
    unsigned int v20 = *(_DWORD *)(v21 + 24);
    unsigned int v19 = *(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3;
LABEL_17:
    if (v19 >= v20)
    {
      *(_DWORD *)(a1 + 88) = a3;
      unint64_t v22 = sub_1CC477DE0(a1, a4);
      sub_1CC4781D8(a1 + 200, v22, v10, *(_DWORD *)(a1 + 88));
      sub_1CC477C68(a1);
    }
    goto LABEL_13;
  }
  unsigned int v20 = *(_DWORD *)(v21 + 24);
LABEL_13:
  *(_DWORD *)(a1 + 88) = a3;
  if ((v20 | (v15 >> 1) & 3) >= (*(_DWORD *)((v14 & 0xFFFFFFFFFFFFFFF8) + 24) | (v14 >> 1) & 3)) {
    unint64_t v15 = v14;
  }
  unint64_t v15 = sub_1CC477CDC(a1, v15);
  uint64_t v16 = a1 + 200;
  int v18 = *(_DWORD *)(a1 + 88);
  uint64_t v17 = v10;
LABEL_6:

  sub_1CC4781D8(v16, v15, v17, v18);
}

uint64_t sub_1CC47EBA8(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned int *)(result + 12) < a2)
  {
    *(_DWORD *)(result + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v4 = *(void **)result;
  unint64_t v5 = *(unsigned int *)(result + 8);
  if (v5 >= a2) {
    unint64_t v6 = a2;
  }
  else {
    unint64_t v6 = *(unsigned int *)(result + 8);
  }
  if (v6)
  {
    uint64_t v10 = *(void **)result;
    do
    {
      *uint64_t v10 = a3;
      v10[1] = a4;
      v10 += 2;
      --v6;
    }
    while (v6);
  }
  unint64_t v7 = v5 - a2;
  if (v5 < a2)
  {
    uint64_t v8 = &v4[2 * v5];
    do
    {
      void *v8 = a3;
      v8[1] = a4;
      v8 += 2;
    }
    while (!__CFADD__(v7++, 1));
  }
  *(_DWORD *)(result + 8) = a2;
  return result;
}

unint64_t sub_1CC47EC6C(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 40 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t *sub_1CC47ECE8(uint64_t *result)
{
  uint64_t v1 = result + 1;
  uint64_t v2 = *result;
  if (*(_DWORD *)(*result + 184))
  {
    unsigned int v3 = *(_DWORD *)(v2 + 188);
    *((_DWORD *)result + 4) = 0;
    if (!*((_DWORD *)result + 5)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unint64_t v4 = (void *)*v1;
    *(void *)*uint64_t v1 = v2 + 8;
  }
  else
  {
    unsigned int v3 = *(_DWORD *)(v2 + 188);
    *((_DWORD *)result + 4) = 0;
    if (!*((_DWORD *)result + 5)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unint64_t v4 = (void *)*v1;
    *(void *)*uint64_t v1 = v2;
  }
  v4[1] = v3;
  unsigned int v5 = *((_DWORD *)result + 4);
  unsigned int v6 = v5 + 1;
  *((_DWORD *)result + 4) = v5 + 1;
  unsigned int v7 = *(_DWORD *)(*result + 184);
  if (v7) {
    BOOL v8 = v5 >= v7;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    do
    {
      uint64_t v9 = result[1];
      uint64_t v10 = *(void *)(*(void *)(v9 + 16 * v5) + 8 * *(unsigned int *)(v9 + 16 * v5 + 12));
      if (v6 >= *((_DWORD *)result + 5)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v11 = (unint64_t *)(v9 + 16 * v6);
      *uint64_t v11 = v10 & 0xFFFFFFFFFFFFFFC0;
      v11[1] = (v10 & 0x3F) + 1;
      unsigned int v5 = *((_DWORD *)result + 4);
      unsigned int v6 = v5 + 1;
      *((_DWORD *)result + 4) = v5 + 1;
    }
    while (v5 < v7);
  }
  return result;
}

_DWORD *sub_1CC47EE8C(_DWORD *result, uint64_t a2)
{
  uint64_t v2 = (void **)(result + 2);
  uint64_t v3 = *(void *)result;
  if (*(_DWORD *)(*(void *)result + 184))
  {
    uint64_t v4 = v3 + 8;
    uint64_t v5 = *(unsigned int *)(v3 + 188);
    result[4] = 0;
    unsigned int v6 = result + 4;
    if (!result[5]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = v5 | (a2 << 32);
    BOOL v8 = *v2;
    void *v8 = v4;
  }
  else
  {
    uint64_t v9 = *(unsigned int *)(v3 + 188);
    result[4] = 0;
    unsigned int v6 = result + 4;
    if (!result[5]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v7 = v9 | (a2 << 32);
    BOOL v8 = *v2;
    void *v8 = v3;
  }
  v8[1] = v7;
  ++*v6;
  return result;
}

uint64_t sub_1CC47EFAC(uint64_t result, int a2, int a3, int a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)(37 * a4) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (_DWORD *)(result + 16 * v9);
    int v11 = *v10;
    int v12 = v10[1];
    if (*v10 != a3 || v12 != a4)
    {
      unint64_t v14 = 0;
      int v15 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v14) {
          BOOL v16 = 0;
        }
        else {
          BOOL v16 = v12 == -2;
        }
        if (v16 && v11 == -2) {
          unint64_t v14 = v10;
        }
        unsigned int v18 = v9 + v15++;
        unsigned int v9 = v18 & v8;
        uint64_t v10 = (_DWORD *)(result + 16 * (v18 & v8));
        int v11 = *v10;
        int v12 = v10[1];
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_7;
        }
      }
      if (v14) {
        uint64_t v10 = v14;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
LABEL_7:
  *a5 = v10;
  return result;
}

_DWORD *sub_1CC47F07C(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CC47F214(a1, 2 * v6);
    int v9 = *(_DWORD *)(a1 + 16);
    if (v9)
    {
      int v10 = a2[1];
      unint64_t v11 = ((37 * v10) | ((unint64_t)(37 * *a2) << 32))
          + ~((unint64_t)(37 * v10) << 32);
      unint64_t v12 = (v11 ^ (v11 >> 22)) + ~((v11 ^ (v11 >> 22)) << 13);
      unint64_t v13 = (9 * (v12 ^ (v12 >> 8))) ^ ((9 * (v12 ^ (v12 >> 8))) >> 15);
      int v14 = v9 - 1;
      unsigned int v15 = v14 & (((v13 + ~(v13 << 27)) >> 31) ^ (v13 + ~(v13 << 27)));
      a3 = (_DWORD *)(*(void *)a1 + 16 * v15);
      int v16 = *a3;
      int v17 = a3[1];
      if (*a2 != *a3 || v10 != v17)
      {
        unsigned int v19 = 0;
        int v20 = 1;
        while (v16 != -1 || v17 != -1)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v17 == -2;
          }
          if (v21 && v16 == -2) {
            unsigned int v19 = a3;
          }
          unsigned int v23 = v15 + v20++;
          unsigned int v15 = v23 & v14;
          a3 = (_DWORD *)(*(void *)a1 + 16 * v15);
          int v16 = *a3;
          int v17 = a3[1];
          if (*a2 == *a3 && v10 == v17) {
            goto LABEL_4;
          }
        }
        if (v19) {
          a3 = v19;
        }
      }
    }
    else
    {
      a3 = 0;
    }
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
    sub_1CC47F214(a1, v6);
    uint64_t v25 = 0;
    sub_1CC47EFAC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v25);
    a3 = v25;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC47F214(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC47F2E0(a1, v4, &v4[4 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      *uint64_t result = -1;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CC47F2E0(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    uint64_t v4 = *(void **)result;
    uint64_t v5 = 16 * v3;
    do
    {
      *uint64_t v4 = -1;
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 4)
  {
    int v6 = *a2;
    int v7 = a2[1];
    if ((*a2 != -1 || v7 != -1) && (v6 != -2 || v7 != -2))
    {
      unint64_t v10 = ((37 * v7) | ((unint64_t)(37 * v6) << 32))
          + ~((unint64_t)(37 * v7) << 32);
      unint64_t v11 = (v10 ^ (v10 >> 22)) + ~((v10 ^ (v10 >> 22)) << 13);
      unint64_t v12 = (9 * (v11 ^ (v11 >> 8))) ^ ((9 * (v11 ^ (v11 >> 8))) >> 15);
      int v13 = ((v12 + ~(v12 << 27)) >> 31) ^ (v12 + ~(v12 << 27));
      int v14 = *(_DWORD *)(result + 16) - 1;
      unsigned int v15 = v14 & v13;
      uint64_t v16 = *(void *)result + 16 * v15;
      int v17 = *(_DWORD *)v16;
      int v18 = *(_DWORD *)(v16 + 4);
      if (v6 != *(_DWORD *)v16 || v7 != v18)
      {
        uint64_t v20 = 0;
        int v21 = 1;
        while (v17 != -1 || v18 != -1)
        {
          if (v20) {
            BOOL v22 = 0;
          }
          else {
            BOOL v22 = v18 == -2;
          }
          if (v22 && v17 == -2) {
            uint64_t v20 = v16;
          }
          unsigned int v24 = v15 + v21++;
          unsigned int v15 = v24 & v14;
          uint64_t v16 = *(void *)result + 16 * (v24 & v14);
          int v17 = *(_DWORD *)v16;
          int v18 = *(_DWORD *)(v16 + 4);
          if (v6 == *(_DWORD *)v16 && v7 == v18) {
            goto LABEL_18;
          }
        }
        if (v20) {
          uint64_t v16 = v20;
        }
      }
LABEL_18:
      *(_DWORD *)uint64_t v16 = v6;
      *(_DWORD *)(v16 + 4) = a2[1];
      *(void *)(v16 + 8) = *((void *)a2 + 1);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

void sub_1CC47F424()
{
}

__n128 sub_1CC47F438(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F2613208;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CC47F484(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2613208;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

unint64_t sub_1CC47F4B4(uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (a2[12])
  {
    int v6 = a2;
    return sub_1CC2F6AE4((uint64_t *)&v6, v3, v4, 0);
  }
  else
  {
    int v6 = a2;
    return sub_1CC2F6F18(&v6, v3, v4, 0);
  }
}

uint64_t sub_1CC47F504(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6 = *a2;
  if (!v6)
  {
LABEL_10:
    if (v6 == a3)
    {
      int v18 = (void *)(a1 + 16 * a3);
      *int v18 = a4;
      v18[1] = a5;
      *(_DWORD *)(a1 + 4 * a3 + 144) = a6;
      return (a3 + 1);
    }
    uint64_t v12 = a1 + 4 * v6;
    int v14 = *(_DWORD *)(v12 + 144);
    int v13 = (_DWORD *)(v12 + 144);
    if (v14 == a6)
    {
      unsigned int v15 = (void *)(a1 + 16 * v6);
      if (*v15 == a5)
      {
        *unsigned int v15 = a4;
        return a3;
      }
    }
    if (a3 != 9)
    {
      unsigned int v16 = a3;
      do
      {
        *(_OWORD *)(a1 + 16 * v16) = *(_OWORD *)(a1 + 16 * (v16 - 1));
        *(_DWORD *)(a1 + 144 + 4 * v16) = *(_DWORD *)(a1 + 144 + 4 * (v16 - 1));
        --v16;
      }
      while (v6 != v16);
      int v17 = (void *)(a1 + 16 * v6);
      *int v17 = a4;
      v17[1] = a5;
      *int v13 = a6;
      return (a3 + 1);
    }
    return 10;
  }
  uint64_t v7 = (v6 - 1);
  if (*(_DWORD *)(a1 + 4 * v7 + 144) != a6
    || (v8 = a1 + 16 * v7, v10 = *(void *)(v8 + 8), int v9 = (void *)(v8 + 8), v10 != a4))
  {
    if (v6 == 9) {
      return 10;
    }
    goto LABEL_10;
  }
  *a2 = v7;
  if (v6 != a3 && *(_DWORD *)(a1 + 4 * v6 + 144) == a6 && *(void *)(a1 + 16 * v6) == a5)
  {
    *int v9 = *(void *)(a1 + 16 * v6 + 8);
    if (v6 + 1 != a3)
    {
      do
      {
        *(_OWORD *)(a1 + 16 * v6) = *(_OWORD *)(a1 + 16 * (v6 + 1));
        *(_DWORD *)(a1 + 144 + 4 * v6) = *(_DWORD *)(a1 + 144 + 4 * (v6 + 1));
        LODWORD(v6) = v6 + 1;
      }
      while (a3 - 1 != v6);
    }
    return (a3 - 1);
  }
  else
  {
    *int v9 = a5;
  }
  return a3;
}

uint64_t sub_1CC47F648(_DWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (llvm::IntervalMapImpl::Path *)(a1 + 2);
  unsigned int v9 = a1[4];
  if (!v9 || (uint64_t v10 = *(void *)v8, *(_DWORD *)(*(void *)v8 + 12) >= *(_DWORD *)(*(void *)v8 + 8)))
  {
    uint64_t v37 = *(unsigned int *)(*(void *)a1 + 184);
    llvm::IntervalMapImpl::Path::moveLeft((llvm::IntervalMapImpl::Path *)(a1 + 2), *(_DWORD *)(*(void *)a1 + 184));
    uint64_t v10 = *((void *)a1 + 1);
    ++*(_DWORD *)(v10 + 16 * v37 + 12);
    unsigned int v9 = a1[4];
  }
  uint64_t v11 = v9;
  uint64_t v12 = v10 + 16 * v9;
  int v13 = *(_DWORD *)(v12 - 4);
  if (!v13)
  {
    uint64_t v22 = *(void *)(v12 - 16);
    if ((*(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3) >= ((*(void *)v22 >> 1) & 3 | *(_DWORD *)((*(void *)v22 & 0xFFFFFFFFFFFFFFF8) + 24))) {
      goto LABEL_31;
    }
    unsigned int v23 = v9 - 1;
    if (v9 == 1) {
      goto LABEL_17;
    }
    unsigned int v24 = v9 - 2;
    int v25 = v9;
    while (1)
    {
      uint64_t v26 = v24;
      if (!v24) {
        break;
      }
      int v27 = *(_DWORD *)(v10 + 16 * v24 + 12);
      --v25;
      --v24;
      if (v27) {
        goto LABEL_19;
      }
    }
    int v27 = *(_DWORD *)(v10 + 12);
    if (!v27) {
      goto LABEL_17;
    }
    int v25 = 1;
LABEL_19:
    uint64_t v28 = *(void *)(*(void *)(v10 + 16 * v26) + 8 * (v27 - 1));
    if (v25 != v23)
    {
      unsigned int v38 = ~v25 + v9;
      do
      {
        uint64_t v28 = *(void *)((v28 & 0xFFFFFFFFFFFFFFC0) + 8 * (v28 & 0x3F));
        --v38;
      }
      while (v38);
    }
    if (!v28)
    {
LABEL_17:
      int v13 = 0;
      **(void **)a1 = a2;
      goto LABEL_4;
    }
    unint64_t v29 = v28 & 0xFFFFFFFFFFFFFFC0;
    uint64_t v30 = v28 & 0x3F;
    if (*(_DWORD *)((v28 & 0xFFFFFFFFFFFFFFC0) + 4 * v30 + 0x90) == a4
      && (unint64_t v31 = v29 + 16 * v30, v33 = *(void *)(v31 + 8), v32 = (uint64_t *)(v31 + 8), v33 == a2))
    {
      llvm::IntervalMapImpl::Path::moveLeft(v8, v23);
      if ((*(_DWORD *)((a3 & 0xFFFFFFFFFFFFFFF8) + 24) | (a3 >> 1) & 3) <= ((*(void *)v22 >> 1) & 3 | *(_DWORD *)((*(void *)v22 & 0xFFFFFFFFFFFFFFF8) + 24))
        && (*(_DWORD *)(v22 + 144) != a4 || *(void *)v22 != a3))
      {
        unsigned int v20 = a1[4] - 1;
        *unint64_t v32 = a3;
LABEL_27:
        return sub_1CC47FB18((uint64_t)a1, v20, a3);
      }
      a2 = *(void *)(v29 + 16 * v30);
      sub_1CC47FB68((uint64_t)a1, 0);
      uint64_t v10 = *((void *)a1 + 1);
      uint64_t v11 = a1[4];
      int v13 = *(_DWORD *)(v10 + 16 * v11 - 4);
    }
    else
    {
LABEL_31:
      int v13 = 0;
    }
  }
LABEL_4:
  uint64_t v14 = v10 + 16 * v11;
  uint64_t v15 = *(unsigned int *)(v14 - 8);
  BOOL v16 = v13 == v15;
  uint64_t result = sub_1CC47F504(*(void *)(v14 - 16), (_DWORD *)(v14 - 4), v15, a2, a3, a4);
  if (result >= 0xA)
  {
    sub_1CC47FD94((llvm::IntervalMapImpl::Path *)a1, a1[4] - 1);
    BOOL v34 = (_DWORD *)(*((void *)a1 + 1) + 16 * a1[4]);
    int v35 = *--v34;
    uint64_t v36 = *(v34 - 1);
    BOOL v16 = v35 == v36;
    uint64_t result = sub_1CC47F504(*(void *)(v34 - 3), v34, v36, a2, a3, a4);
  }
  int v18 = a1[4];
  uint64_t v19 = *((void *)a1 + 1);
  unsigned int v20 = v18 - 1;
  *(_DWORD *)(v19 + 16 * (v18 - 1) + 8) = result;
  if (v18 != 1)
  {
    uint64_t v21 = v19 + 16 * (v18 - 2);
    *(void *)(*(void *)v21 + 8 * *(unsigned int *)(v21 + 12)) = *(void *)(*(void *)v21
                                                                                + 8 * *(unsigned int *)(v21 + 12)) & 0xFFFFFFFFFFFFFFC0 | (result - 1);
  }
  if (v16) {
    goto LABEL_27;
  }
  return result;
}

uint64_t sub_1CC47F93C(uint64_t a1, unsigned int a2)
{
  unint64_t v3 = 0;
  unsigned int v4 = 0;
  LODWORD(v5) = 0;
  v29[3] = *MEMORY[0x1E4F143B8];
  unsigned int v6 = *(_DWORD *)(a1 + 188) + 1;
  unsigned int v7 = v6 >> 1;
  unint64_t v8 = v6 & 1;
  LODWORD(v9) = 2;
  do
  {
    if (v3 >= v8) {
      unsigned int v10 = v7;
    }
    else {
      unsigned int v10 = v7 + 1;
    }
    *((_DWORD *)&v29[2] + v3) = v10;
    unsigned int v11 = a2 - v4;
    v4 += v10;
    BOOL v12 = v9 == 2;
    BOOL v13 = v4 > a2;
    if (v12 && v13) {
      uint64_t v9 = v3;
    }
    else {
      uint64_t v9 = v9;
    }
    if (v12 && v13) {
      uint64_t v5 = v11;
    }
    else {
      uint64_t v5 = v5;
    }
    ++v3;
  }
  while (v3 != 2);
  char v14 = 0;
  uint64_t v15 = 0;
  unsigned int v16 = 0;
  --*((_DWORD *)&v29[2] + v9);
  v29[0] = 0;
  v29[1] = 0;
  do
  {
    char v17 = v14;
    sub_1CC480550(*(void *)(a1 + 192));
    int v19 = *((_DWORD *)&v29[2] + v15);
    if (v19)
    {
      unsigned int v20 = (_DWORD *)(v18 + 144);
      uint64_t v21 = (void *)(v18 + 8);
      int v22 = *((_DWORD *)&v29[2] + v15);
      unsigned int v23 = v16;
      do
      {
        unsigned int v24 = (void *)(a1 + 16 * v23);
        *(v21 - 1) = *v24;
        *uint64_t v21 = v24[1];
        v21 += 2;
        *v20++ = *(_DWORD *)(a1 + 4 * v23++ + 144);
        --v22;
      }
      while (v22);
    }
    v16 += v19;
    v29[v15] = v18 & 0xFFFFFFFFFFFFFFC0 | (v19 - 1);
    char v14 = 1;
    uint64_t v15 = 1;
  }
  while ((v17 & 1) == 0);
  uint64_t v25 = 0;
  *(_DWORD *)(a1 + 184) = 1;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = 0;
  do
  {
    uint64_t v26 = v29[v25];
    uint64_t v27 = a1 + 8 * v25;
    *(void *)(v27 + 96) = *(void *)((v26 & 0xFFFFFFFFFFFFFFC0)
                                      + 16 * (*((_DWORD *)&v29[2] + v25) - 1)
                                      + 8);
    *(void *)(v27 + 8) = v26;
    ++v25;
  }
  while (v25 != 2);
  *(void *)a1 = *(void *)(v29[0] & 0xFFFFFFFFFFFFFFC0);
  *(_DWORD *)(a1 + 188) = 2;
  return v9 | (v5 << 32);
}

uint64_t sub_1CC47FB18(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v4 = 16 * a2;
    while (1)
    {
      uint64_t v5 = v4 - 16;
      if (v4 == 16) {
        break;
      }
      uint64_t v6 = v3 + v4;
      uint64_t v7 = *(void *)(v6 - 16);
      uint64_t v9 = v6 - 8;
      LODWORD(v6) = *(_DWORD *)(v6 - 8);
      uint64_t v8 = *(unsigned int *)(v9 + 4);
      *(void *)(v7 + 8 * v8 + 96) = a3;
      LODWORD(v7) = v6 - 1;
      uint64_t v4 = v5;
      if (v8 != v7) {
        return result;
      }
    }
    *(void *)(*(void *)v3 + 8 * *(unsigned int *)(v3 + 12) + 88) = a3;
  }
  return result;
}

uint64_t sub_1CC47FB68(uint64_t result, int a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *(void *)result;
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v6 = *(unsigned int *)(result + 16);
  uint64_t v7 = v4 + 16 * v6;
  uint64_t v8 = *(void **)(v7 - 16);
  int v9 = *(_DWORD *)(v7 - 8);
  if (v9 == 1)
  {
    uint64_t v25 = *(void **)(v5 + 192);
    void *v8 = *v25;
    *uint64_t v25 = v8;
    uint64_t result = (uint64_t)sub_1CC480364((uint64_t *)result, *(_DWORD *)(v5 + 184));
    if (a2)
    {
      if (*(_DWORD *)(v5 + 184))
      {
        uint64_t v26 = *(unsigned int *)(v3 + 16);
        if (v26)
        {
          uint64_t v27 = *(void *)(v3 + 8);
          if (*(_DWORD *)(v27 + 12) < *(_DWORD *)(v27 + 8))
          {
            uint64_t v28 = (int *)(v27 + 12);
            uint64_t v29 = *(unsigned int *)(v3 + 16);
            while (1)
            {
              int v30 = *v28;
              v28 += 4;
              if (v30) {
                break;
              }
              if (!--v29)
              {
                unint64_t v31 = *(void **)(v27 + 16 * v26 - 16);
                goto LABEL_34;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(v7 - 4);
    if (v10 + 1 != v9)
    {
      do
      {
        *(_OWORD *)&v8[2 * v10] = *(_OWORD *)&v8[2 * v10 + 2];
        *((_DWORD *)v8 + v10 + 36) = *((_DWORD *)v8 + v10 + 37);
        ++v10;
      }
      while (v9 - 1 != v10);
      uint64_t v6 = *(unsigned int *)(result + 16);
      int v9 = *(_DWORD *)(v4 + 16 * v6 - 8);
    }
    uint64_t v11 = v4 + 16 * v6;
    uint64_t v12 = *(unsigned int *)(v5 + 184);
    *(_DWORD *)(v4 + 16 * v12 + 8) = v9 - 1;
    if (v12)
    {
      uint64_t v13 = v4 + 16 * (v12 - 1);
      *(void *)(*(void *)v13 + 8 * *(unsigned int *)(v13 + 12)) = *(void *)(*(void *)v13
                                                                                  + 8 * *(unsigned int *)(v13 + 12)) & 0xFFFFFFFFFFFFFFC0 | (v9 - 2);
    }
    if (*(_DWORD *)(v11 - 4) == v9 - 1)
    {
      uint64_t result = sub_1CC47FB18(result, v12, v8[2 * (v9 - 2) + 1]);
      int v14 = 0;
      uint64_t v15 = *(unsigned int *)(v5 + 184);
      uint64_t v16 = *(void *)(v3 + 8);
      int v17 = v15 - 1;
      while (1)
      {
        int v18 = v14;
        uint64_t v19 = (v17 + v14);
        if (!(v17 + v14)) {
          break;
        }
        int v21 = *(_DWORD *)(v16 + 16 * v19 + 8);
        int v20 = *(_DWORD *)(v16 + 16 * v19 + 12);
        --v14;
        if (v20 != v21 - 1) {
          goto LABEL_11;
        }
      }
      uint64_t v19 = 0;
      int v21 = *(_DWORD *)(v16 + 8);
      int v20 = *(_DWORD *)(v16 + 12);
LABEL_11:
      unsigned int v22 = v20 + 1;
      *(_DWORD *)(v16 + 16 * v19 + 12) = v22;
      if (v22 != v21)
      {
        uint64_t v23 = *(void *)(*(void *)(v16 + 16 * v19) + 8 * v22);
        if (v18)
        {
          do
          {
            uint64_t v32 = *(void *)(v3 + 8) + 16 * (v15 + v18);
            *(void *)uint64_t v32 = v23 & 0xFFFFFFFFFFFFFFC0;
            *(_DWORD *)(v32 + 8) = (v23 & 0x3F) + 1;
            *(_DWORD *)(v32 + 12) = 0;
            uint64_t v23 = *(void *)(v23 & 0xFFFFFFFFFFFFFFC0);
          }
          while (!__CFADD__(v18++, 1));
          uint64_t v16 = *(void *)(v3 + 8);
        }
        unsigned int v24 = (unint64_t *)(v16 + 16 * v15);
        *unsigned int v24 = v23 & 0xFFFFFFFFFFFFFFC0;
        v24[1] = (v23 & 0x3F) + 1;
      }
    }
    else if (a2)
    {
      if (v6)
      {
        uint64_t v34 = v6;
        int v35 = (int *)(v4 + 12);
        while (1)
        {
          int v36 = *v35;
          v35 += 4;
          if (v36) {
            break;
          }
          if (!--v34) {
            goto LABEL_33;
          }
        }
      }
      else
      {
LABEL_33:
        unint64_t v31 = *(void **)(v11 - 16);
LABEL_34:
        *(void *)uint64_t v5 = *v31;
      }
    }
  }
  return result;
}

uint64_t sub_1CC47FD94(llvm::IntervalMapImpl::Path *a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::IntervalMapImpl::Path *)((char *)a1 + 8);
  uint64_t v3 = *((void *)a1 + 1);
  memset(v78, 0, 32);
  unsigned int v5 = *(_DWORD *)(v3 + 16 * a2 + 12);
  if (a2)
  {
    int v6 = -1;
    while (1)
    {
      uint64_t v7 = a2 + v6;
      if (!(a2 + v6)) {
        break;
      }
      int v8 = *(_DWORD *)(v3 + 16 * v7 + 12);
      --v6;
      if (v8)
      {
        int v9 = a2 + v6 + 2;
        goto LABEL_8;
      }
    }
    int v8 = *(_DWORD *)(v3 + 12);
    int v9 = 1;
    if (!v8)
    {
      LODWORD(v10) = 0;
      goto LABEL_13;
    }
LABEL_8:
    uint64_t v10 = *(void *)(*(void *)(v3 + 16 * v7) + 8 * (v8 - 1));
    if (v9 != a2)
    {
      unsigned int v69 = a2 - v9;
      do
      {
        uint64_t v10 = *(void *)((v10 & 0xFFFFFFFFFFFFFFC0) + 8 * (v10 & 0x3F));
        --v69;
      }
      while (v69);
    }
    if (v10)
    {
      LOBYTE(v9) = 0;
      int v8 = (v10 & 0x3F) + 1;
      v79[0] = v8;
      v5 += v8;
      v78[0] = v10 & 0xFFFFFFFFFFFFFFC0;
      LODWORD(v10) = 1;
      goto LABEL_13;
    }
    int v8 = 0;
  }
  else
  {
    int v8 = 0;
    LODWORD(v10) = 0;
  }
  LOBYTE(v9) = 1;
LABEL_13:
  uint64_t v11 = v3 + 16 * a2;
  int v12 = *(_DWORD *)(v11 + 8);
  v79[v10] = v12;
  int v13 = v12 + v8;
  unsigned int v14 = v10 + 1;
  *(void *)((unint64_t)v78 | (8 * v10)) = *(void *)v11;
  char v73 = v9;
  if (a2)
  {
    int v15 = -1;
    while (1)
    {
      uint64_t v16 = a2 + v15;
      if (!(a2 + v15)) {
        break;
      }
      int v17 = *(_DWORD *)(v3 + 16 * v16 + 12);
      int v18 = *(_DWORD *)(v3 + 16 * v16 + 8) - 1;
      --v15;
      if (v17 != v18)
      {
        int v19 = a2 + v15 + 2;
        goto LABEL_19;
      }
    }
    int v17 = *(_DWORD *)(v3 + 12);
    int v18 = *(_DWORD *)(v3 + 8) - 1;
    int v19 = 1;
LABEL_19:
    if (v17 != v18)
    {
      uint64_t v20 = *(void *)(*(void *)(v3 + 16 * v16) + 8 * (v17 + 1));
      if (v19 != a2)
      {
        unsigned int v68 = a2 - v19;
        do
        {
          uint64_t v20 = *(void *)(v20 & 0xFFFFFFFFFFFFFFC0);
          --v68;
        }
        while (v68);
      }
      if (v20)
      {
        int v21 = (v20 & 0x3F) + 1;
        v79[v14] = v21;
        v13 += v21;
        v78[v14] = v20 & 0xFFFFFFFFFFFFFFC0;
        unsigned int v14 = v10 | 2;
      }
    }
  }
  unsigned int v22 = v13 + 1;
  if (v13 + 1 <= (v14 | (8 * v14)))
  {
    int v76 = 0;
  }
  else
  {
    if (v14 == 1) {
      int v23 = 1;
    }
    else {
      int v23 = v14 - 1;
    }
    v79[v14] = v79[v23];
    v78[v14] = v78[v23];
    v79[v23] = 0;
    sub_1CC480550(*(void *)(*(void *)a1 + 192));
    int v76 = v23;
    v78[v23] = v24;
    ++v14;
  }
  unint64_t v25 = 0;
  unsigned int v26 = 0;
  unsigned int v27 = 0;
  uint64_t v28 = v14;
  int v29 = v14;
  do
  {
    if (v25 >= v22 % v14) {
      int v30 = v22 / v14;
    }
    else {
      int v30 = v22 / v14 + 1;
    }
    v77[v25] = v30;
    unsigned int v31 = v5 - v26;
    v26 += v30;
    if (v29 == v14 && v26 > v5)
    {
      int v29 = v25;
      unsigned int v27 = v31;
    }
    ++v25;
  }
  while (v14 != v25);
  unsigned int v72 = v27;
  int v75 = v29;
  --v77[v29];
  uint64_t v32 = a1;
  if (v14 != 1)
  {
    uint64_t v70 = v14 - 1;
    uint64_t v33 = (int)(v14 - 1);
    uint64_t v34 = v14;
    do
    {
      unsigned int v35 = v79[v33];
      unsigned int v36 = v77[v33];
      if (v35 != v36)
      {
        uint64_t v37 = v34;
        do
        {
          if (v37 == 1) {
            break;
          }
          unsigned int v38 = *((_DWORD *)&v78[4] + v37);
          int v39 = sub_1CC4808A8(v78[v33], v35, *(void *)&v77[2 * v37], v38, v36 - v35);
          *((_DWORD *)&v78[4] + v37) = v38 - v39;
          unsigned int v35 = v79[v33] + v39;
          v79[v33] = v35;
          --v37;
        }
        while (v35 < v36);
      }
      --v34;
      --v33;
    }
    while (v33);
    uint64_t v32 = a1;
    uint64_t v40 = v14 - 1;
    uint64_t v41 = 0;
    int v42 = 1;
    do
    {
      unsigned int v43 = v79[v41];
      unsigned int v44 = v77[v41];
      if (v43 != v44)
      {
        int v45 = v42;
        do
        {
          if (v28 == v45) {
            break;
          }
          unsigned int v71 = v79[v45];
          int v46 = sub_1CC4808A8(v78[v45], v71, v78[v41], v43, v43 - v44);
          uint64_t v40 = v70;
          v79[v45] = v46 + v71;
          unsigned int v43 = v79[v41] - v46;
          v79[v41] = v43;
          ++v45;
        }
        while (v43 < v44);
      }
      ++v41;
      ++v42;
    }
    while (v41 != v40);
  }
  if ((v73 & 1) == 0) {
    llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
  }
  uint64_t v47 = 0;
  char v48 = 0;
  for (int i = v75; ; --i)
  {
    uint64_t v50 = v78[v47];
    int v51 = v77[v47];
    uint64_t v52 = (v51 - 1);
    uint64_t v53 = *(void *)(v50 + 16 * v52 + 8);
    if (v76 && v47 == v76)
    {
      int v54 = sub_1CC48066C(v32, v2, v50 & 0xFFFFFFFFFFFFFFC0 | v52, v53);
      char v48 = v54;
      v2 += v54;
    }
    else
    {
      uint64_t v55 = *(void *)v4;
      *(_DWORD *)(*(void *)v4 + 16 * v2 + 8) = v51;
      if (v2) {
        *(void *)(*(void *)(v55 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v55 + 16 * (v2 - 1) + 12)) = *(void *)(*(void *)(v55 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v55 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v52;
      }
      sub_1CC47FB18((uint64_t)v32, v2, v53);
    }
    if (v47 + 1 == v28) {
      break;
    }
    int v56 = 0;
    ++v47;
    uint64_t v57 = *(void *)v4;
    while (1)
    {
      int v58 = v56;
      if (v2 + v56 == 1) {
        break;
      }
      uint64_t v59 = v2 - 1 + v56;
      int v61 = *(_DWORD *)(v57 + 16 * v59 + 8);
      int v60 = *(_DWORD *)(v57 + 16 * v59 + 12);
      --v56;
      if (v60 != v61 - 1) {
        goto LABEL_66;
      }
    }
    uint64_t v59 = 0;
    int v61 = *(_DWORD *)(v57 + 8);
    int v60 = *(_DWORD *)(v57 + 12);
LABEL_66:
    unsigned int v62 = v60 + 1;
    *(_DWORD *)(v57 + 16 * v59 + 12) = v62;
    if (v62 != v61)
    {
      uint64_t v63 = *(void *)(*(void *)(v57 + 16 * v59) + 8 * v62);
      if (v58)
      {
        do
        {
          uint64_t v65 = *(void *)v4 + 16 * (v2 + v58);
          *(void *)uint64_t v65 = v63 & 0xFFFFFFFFFFFFFFC0;
          *(_DWORD *)(v65 + 8) = (v63 & 0x3F) + 1;
          *(_DWORD *)(v65 + 12) = 0;
          uint64_t v63 = *(void *)(v63 & 0xFFFFFFFFFFFFFFC0);
          BOOL v66 = __CFADD__(v58++, 1);
        }
        while (!v66);
        uint64_t v57 = *(void *)v4;
      }
      BOOL v64 = (unint64_t *)(v57 + 16 * v2);
      *BOOL v64 = v63 & 0xFFFFFFFFFFFFFFC0;
      v64[1] = (v63 & 0x3F) + 1;
    }
  }
  if (v75 != v47)
  {
    do
    {
      llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
      BOOL v66 = __CFADD__(i++, 1);
    }
    while (!v66);
  }
  *(_DWORD *)(*(void *)v4 + 16 * v2 + 12) = v72;
  return v48 & 1;
}

uint64_t *sub_1CC480364(uint64_t *result, unsigned int a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *result;
  int v6 = result + 1;
  uint64_t v5 = result[1];
  uint64_t v7 = a2 - 1;
  if (a2 != 1)
  {
    uint64_t v14 = v5 + 16 * v7;
    int v15 = *(void **)(v5 + 16 * (a2 - 1));
    int v18 = *(_DWORD *)(v14 + 8);
    int v17 = (_DWORD *)(v14 + 8);
    int v16 = v18;
    int v19 = v18 - 1;
    if (v18 == 1)
    {
      unsigned int v27 = *(void **)(v4 + 192);
      *int v15 = *v27;
      *unsigned int v27 = v15;
      uint64_t result = (uint64_t *)sub_1CC480364(result, a2 - 1);
    }
    else
    {
      int v20 = *(_DWORD *)(v5 + 16 * v7 + 12);
      if (v20 + 1 != v16)
      {
        unsigned int v21 = *(_DWORD *)(v5 + 16 * v7 + 12);
        do
        {
          v15[v21] = v15[v21 + 1];
          v15[v21 + 12] = v15[v21 + 13];
          ++v21;
        }
        while (v19 != v21);
      }
      *int v17 = v19;
      uint64_t v22 = v5 + 16 * (a2 - 2);
      uint64_t v23 = *(unsigned int *)(v22 + 12);
      uint64_t v24 = *(void *)v22;
      uint64_t v25 = *(void *)(*(void *)v22 + 8 * v23);
      uint64_t v26 = (v16 - 2);
      *(void *)(v24 + 8 * v23) = v25 & 0xFFFFFFFFFFFFFFC0 | v26;
      if (v20 == v19)
      {
        sub_1CC47FB18((uint64_t)result, a2 - 1, v15[v26 + 12]);
        uint64_t result = llvm::IntervalMapImpl::Path::moveRight(v6, v7);
      }
    }
    goto LABEL_5;
  }
  unsigned int v8 = *(_DWORD *)(v5 + 12);
  int v9 = *(_DWORD *)(v4 + 188);
  if (v8 + 1 != v9)
  {
    do
    {
      *(void *)(v4 + 8 + 8 * v8) = *(void *)(v4 + 8 + 8 * (v8 + 1));
      *(void *)(v4 + 96 + 8 * v8) = *(void *)(v4 + 96 + 8 * (v8 + 1));
      ++v8;
    }
    while (v9 - 1 != v8);
  }
  int v10 = v9 - 1;
  *(_DWORD *)(v4 + 188) = v10;
  *(_DWORD *)(v5 + 8) = v10;
  if (v10)
  {
LABEL_5:
    if (*((_DWORD *)v3 + 4))
    {
      uint64_t v11 = *v6;
      if (*(_DWORD *)(*v6 + 12) < *(_DWORD *)(*v6 + 8))
      {
        uint64_t v12 = *(void *)(*(void *)(v11 + 16 * v7)
                        + 8 * *(unsigned int *)(v11 + 16 * v7 + 12));
        uint64_t v13 = v11 + 16 * a2;
        *(void *)uint64_t v13 = v12 & 0xFFFFFFFFFFFFFFC0;
        *(_DWORD *)(v13 + 8) = (v12 & 0x3F) + 1;
        *(_DWORD *)(*v6 + 16 * a2 + 12) = 0;
      }
    }
    return result;
  }
  *(_OWORD *)(v4 + 172) = 0u;
  *(_OWORD *)(v4 + 144) = 0u;
  *(_OWORD *)(v4 + 160) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)uint64_t v4 = 0u;

  return (uint64_t *)sub_1CC47EE8C(result, 0);
}

double sub_1CC480550(uint64_t a1)
{
  unint64_t v2 = *(void *)a1;
  if (v2)
  {
    *(void *)a1 = *(void *)v2;
  }
  else
  {
    *(void *)(a1 + 88) += 192;
    uint64_t v4 = *(void *)(a1 + 8);
    if (((v4 + 63) & 0xFFFFFFFFFFFFFFC0) - v4 + 192 > *(void *)(a1 + 16) - v4)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 32) >> 7;
      if (v5 >= 0x1E) {
        LOBYTE(v5) = 30;
      }
      uint64_t v6 = 4096 << v5;
      uint64_t v7 = (char *)operator new(4096 << v5, (std::align_val_t)8uLL);
      unsigned int v8 = *(_DWORD *)(a1 + 32);
      if (v8 >= *(_DWORD *)(a1 + 36)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(a1 + 24) + 8 * v8) = v7;
      ++*(_DWORD *)(a1 + 32);
      int v9 = &v7[v6];
      unint64_t v2 = (unint64_t)(v7 + 63) & 0xFFFFFFFFFFFFFFC0;
      *(void *)(a1 + 8) = v2 + 192;
      *(void *)(a1 + 16) = v9;
    }
    else
    {
      unint64_t v2 = (v4 + 63) & 0xFFFFFFFFFFFFFFC0;
      *(void *)(a1 + 8) = v2 + 192;
    }
  }
  *(void *)(v2 + 176) = 0;
  double result = 0.0;
  *(_OWORD *)(v2 + 144) = 0u;
  *(_OWORD *)(v2 + 160) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)unint64_t v2 = 0u;
  return result;
}

uint64_t sub_1CC48066C(llvm::IntervalMapImpl::Path *this, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = (unsigned int *)((char *)this + 8);
  uint64_t v7 = *(void *)this;
  uint64_t v9 = a2 == 1;
  if (a2 == 1)
  {
    unsigned int v10 = *(_DWORD *)(v7 + 188);
    if (v10 <= 0xA)
    {
      uint64_t v11 = v7 + 8;
      uint64_t v12 = *(void *)v8;
      uint64_t v13 = *(unsigned int *)(*(void *)v8 + 12);
      if (v10 != v13)
      {
        unsigned int v14 = *(_DWORD *)(v7 + 188);
        do
        {
          *(void *)(v11 + 8 * v14) = *(void *)(v11 + 8 * (v14 - 1));
          *(void *)(v7 + 96 + 8 * v14) = *(void *)(v7 + 96 + 8 * (v14 - 1));
          --v14;
        }
        while (v13 != v14);
      }
      uint64_t v9 = 0;
      int v15 = (void *)(v11 + 8 * v13);
      *int v15 = a3;
      v15[11] = a4;
      unsigned int v16 = v10 + 1;
      *(_DWORD *)(v7 + 188) = v16;
      uint64_t v17 = *(void *)(*(void *)v12 + 8 * v13);
      *(_DWORD *)(v12 + 8) = v16;
      *(void *)(v12 + 16) = v17 & 0xFFFFFFFFFFFFFFC0;
      *(_DWORD *)(v12 + 24) = (v17 & 0x3F) + 1;
      return v9;
    }
    uint64_t v19 = sub_1CC480A00(*(void *)this, *(unsigned int *)(*(void *)v8 + 12));
    llvm::IntervalMapImpl::Path::replaceRoot(v8, v7 + 8, *(_DWORD *)(v7 + 188), v19);
    a2 = 2;
  }
  uint64_t v20 = (a2 - 1);
  if (!*((_DWORD *)this + 4)
    || (uint64_t v21 = *(void *)v8, *(_DWORD *)(*(void *)v8 + 12) >= *(_DWORD *)(*(void *)v8 + 8)))
  {
    llvm::IntervalMapImpl::Path::moveLeft((llvm::IntervalMapImpl::Path *)v8, a2 - 1);
    uint64_t v21 = *(void *)v8;
    ++*(_DWORD *)(*(void *)v8 + 16 * v20 + 12);
  }
  unsigned int v22 = *(_DWORD *)(v21 + 16 * v20 + 8);
  if (v22 == 12)
  {
    uint64_t v9 = sub_1CC480AD4(this, v20);
    uint64_t v20 = (v20 + v9);
    uint64_t v21 = *((void *)this + 1);
    unsigned int v22 = *(_DWORD *)(v21 + 16 * v20 + 8);
  }
  uint64_t v23 = (uint64_t *)(v21 + 16 * v20);
  uint64_t v24 = *v23;
  uint64_t v25 = *((unsigned int *)v23 + 3);
  uint64_t v26 = v23 + 1;
  if (v22 != v25)
  {
    unsigned int v27 = v22;
    do
    {
      *(void *)(v24 + 8 * v27) = *(void *)(v24 + 8 * (v27 - 1));
      *(void *)(v24 + 96 + 8 * v27) = *(void *)(v24 + 96 + 8 * (v27 - 1));
      --v27;
    }
    while (v25 != v27);
  }
  uint64_t v28 = (void *)(v24 + 8 * v25);
  *uint64_t v28 = a3;
  v28[12] = a4;
  *uint64_t v26 = v22 + 1;
  if (v20)
  {
    uint64_t v29 = v21 + 16 * (v20 - 1);
    *(void *)(*(void *)v29 + 8 * *(unsigned int *)(v29 + 12)) = *(void *)(*(void *)v29
                                                                                + 8 * *(unsigned int *)(v29 + 12)) & 0xFFFFFFFFFFFFFFC0 | v22;
  }
  if (v22 == v25)
  {
    sub_1CC47FB18((uint64_t)this, v20, a4);
    uint64_t v21 = *((void *)this + 1);
    uint64_t v24 = *(void *)(v21 + 16 * v20);
  }
  uint64_t v30 = *(void *)(v24 + 8 * *(unsigned int *)(v21 + 16 * v20 + 12));
  uint64_t v31 = v21 + 16 * (v20 + 1);
  *(void *)uint64_t v31 = v30 & 0xFFFFFFFFFFFFFFC0;
  *(_DWORD *)(v31 + 8) = (v30 & 0x3F) + 1;
  return v9;
}

uint64_t sub_1CC4808A8(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  if ((int)a5 >= 1)
  {
    unsigned int v17 = 9 - a2;
    if (a4 >= a5) {
      LODWORD(v15) = a5;
    }
    else {
      LODWORD(v15) = a4;
    }
    if (v17 >= v15) {
      uint64_t v15 = v15;
    }
    else {
      uint64_t v15 = v17;
    }
    if (a2)
    {
      uint64_t v18 = a2 - 1;
      int v19 = -a2;
      unint64_t v20 = a5;
      if (a5 >= (unint64_t)a4) {
        unint64_t v20 = a4;
      }
      if (v20 < v17) {
        unsigned int v17 = v20;
      }
      do
      {
        *(_OWORD *)(a1 + 16 * (v17 + v18)) = *(_OWORD *)(a1 + 16 * v18);
        *(_DWORD *)(a1 + 4 * (v17 + v18) + 144) = *(_DWORD *)(a1 + 4 * v18 + 144);
        --v18;
        BOOL v21 = __CFADD__(v19++, 1);
      }
      while (!v21);
    }
    if (v15)
    {
      unsigned int v22 = (_DWORD *)(a1 + 144);
      uint64_t v23 = (void *)(a1 + 8);
      int v24 = -(int)v15;
      do
      {
        uint64_t v25 = (void *)(a3 + 16 * (a4 + v24));
        *(v23 - 1) = *v25;
        *uint64_t v23 = v25[1];
        v23 += 2;
        *v22++ = *(_DWORD *)(a3 + 4 * (a4 + v24) + 144);
        BOOL v21 = __CFADD__(v24++, 1);
      }
      while (!v21);
    }
  }
  else
  {
    unint64_t v5 = -a5;
    unsigned int v6 = 9 - a4;
    if (v5 < a2) {
      LODWORD(v7) = -a5;
    }
    else {
      LODWORD(v7) = a2;
    }
    if (v6 >= v7) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = v6;
    }
    if (v7)
    {
      unsigned int v8 = (_DWORD *)(a1 + 144);
      uint64_t v9 = (uint64_t *)(a1 + 8);
      uint64_t v10 = v7;
      do
      {
        uint64_t v11 = (void *)(a3 + 16 * a4);
        *uint64_t v11 = *(v9 - 1);
        uint64_t v13 = *v9;
        v9 += 2;
        uint64_t v12 = v13;
        LODWORD(v13) = *v8++;
        v11[1] = v12;
        *(_DWORD *)(a3 + 4 * a4++ + 144) = v13;
        --v10;
      }
      while (v10);
    }
    if (a2 != v7)
    {
      uint64_t v14 = 0;
      if (a2 < (unint64_t)v5) {
        unint64_t v5 = a2;
      }
      if (v5 < v6) {
        unsigned int v6 = v5;
      }
      do
      {
        *(_OWORD *)(a1 + 16 * v14) = *(_OWORD *)(a1 + 16 * (v6 + v14));
        *(_DWORD *)(a1 + 4 * v14 + 144) = *(_DWORD *)(a1 + 4 * (v6 + v14) + 144);
        ++v14;
      }
      while (a2 - v7 != v14);
    }
    return -(int)v7;
  }
  return v15;
}

uint64_t sub_1CC480A00(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 188);
  unint64_t v5 = *(uint64_t **)(a1 + 192);
  uint64_t v6 = *v5;
  if (*v5) {
    *unint64_t v5 = *(void *)v6;
  }
  else {
    uint64_t v6 = sub_1CB906F34(v5 + 1, 192, 6);
  }
  *(_OWORD *)(v6 + 160) = 0u;
  *(_OWORD *)(v6 + 176) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)uint64_t v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  if (v4)
  {
    uint64_t v7 = (uint64_t *)(a1 + 96);
    unsigned int v8 = (void *)v6;
    uint64_t v9 = v4;
    do
    {
      void *v8 = *(v7 - 11);
      uint64_t v10 = *v7++;
      v8[12] = v10;
      ++v8;
      --v9;
    }
    while (v9);
  }
  uint64_t v11 = (v4 - 1);
  *(void *)(a1 + 96) = *(void *)((v6 & 0xFFFFFFFFFFFFFFC0 | v11 & 0xFFFFFFFFFFFFFFC0)
                                   + 8 * v11
                                   + 0x60);
  *(void *)(a1 + 8) = v6 & 0xFFFFFFFFFFFFFFC0 | v11;
  ++*(_DWORD *)(a1 + 184);
  *(_DWORD *)(a1 + 188) = 1;
  return a2 << 32;
}

uint64_t sub_1CC480AD4(llvm::IntervalMapImpl::Path *a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::IntervalMapImpl::Path *)((char *)a1 + 8);
  uint64_t v3 = *((void *)a1 + 1);
  memset(v67, 0, sizeof(v67));
  unsigned int v5 = *(_DWORD *)(v3 + 16 * a2 + 12);
  if (!a2)
  {
    int v8 = 0;
    LODWORD(v10) = 0;
    goto LABEL_11;
  }
  int v6 = -1;
  while (1)
  {
    uint64_t v7 = a2 + v6;
    if (!(a2 + v6)) {
      break;
    }
    int v8 = *(_DWORD *)(v3 + 16 * v7 + 12);
    --v6;
    if (v8)
    {
      int v9 = a2 + v6 + 2;
      goto LABEL_8;
    }
  }
  int v8 = *(_DWORD *)(v3 + 12);
  int v9 = 1;
  if (!v8)
  {
    LODWORD(v10) = 0;
    goto LABEL_13;
  }
LABEL_8:
  uint64_t v10 = *(void *)(*(void *)(v3 + 16 * v7) + 8 * (v8 - 1));
  if (v9 != a2)
  {
    unsigned int v64 = a2 - v9;
    do
    {
      uint64_t v10 = *(void *)((v10 & 0xFFFFFFFFFFFFFFC0) + 8 * (v10 & 0x3F));
      --v64;
    }
    while (v64);
  }
  if (!v10)
  {
    int v8 = 0;
LABEL_11:
    LOBYTE(v9) = 1;
    goto LABEL_13;
  }
  LOBYTE(v9) = 0;
  int v8 = (v10 & 0x3F) + 1;
  v68[0] = v8;
  v5 += v8;
  *(void *)&v67[0] = v10 & 0xFFFFFFFFFFFFFFC0;
  LODWORD(v10) = 1;
LABEL_13:
  uint64_t v11 = v3 + 16 * a2;
  int v12 = *(_DWORD *)(v11 + 8);
  v68[v10] = v12;
  int v13 = v12 + v8;
  unsigned int v14 = v10 + 1;
  *(void *)((unint64_t)v67 | (8 * v10)) = *(void *)v11;
  if (a2)
  {
    int v15 = -1;
    while (1)
    {
      uint64_t v16 = a2 + v15;
      if (!(a2 + v15)) {
        break;
      }
      int v17 = *(_DWORD *)(v3 + 16 * v16 + 12);
      int v18 = *(_DWORD *)(v3 + 16 * v16 + 8) - 1;
      --v15;
      if (v17 != v18)
      {
        int v19 = a2 + v15 + 2;
        goto LABEL_19;
      }
    }
    int v17 = *(_DWORD *)(v3 + 12);
    int v18 = *(_DWORD *)(v3 + 8) - 1;
    int v19 = 1;
LABEL_19:
    if (v17 != v18)
    {
      uint64_t v20 = *(void *)(*(void *)(v3 + 16 * v16) + 8 * (v17 + 1));
      if (v19 != a2)
      {
        unsigned int v59 = a2 - v19;
        do
        {
          uint64_t v20 = *(void *)(v20 & 0xFFFFFFFFFFFFFFC0);
          --v59;
        }
        while (v59);
      }
      if (v20)
      {
        int v21 = (v20 & 0x3F) + 1;
        v68[v14] = v21;
        v13 += v21;
        *((void *)v67 + v14) = v20 & 0xFFFFFFFFFFFFFFC0;
        unsigned int v14 = v10 | 2;
      }
    }
  }
  unsigned int v22 = v13 + 1;
  if (v13 + 1 <= 12 * v14)
  {
    LODWORD(v23) = 0;
  }
  else
  {
    if (v14 == 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v14 - 1;
    }
    v68[v14] = v68[v23];
    *((void *)v67 + v14) = *((void *)v67 + v23);
    v68[v23] = 0;
    uint64_t v24 = *(void *)(*(void *)a1 + 192);
    unint64_t v25 = *(void *)v24;
    if (*(void *)v24)
    {
      *(void *)uint64_t v24 = *(void *)v25;
    }
    else
    {
      *(void *)(v24 + 88) += 192;
      uint64_t v26 = *(void *)(v24 + 8);
      if (((v26 + 63) & 0xFFFFFFFFFFFFFFC0) - v26 + 192 > *(void *)(v24 + 16) - v26)
      {
        unsigned int v60 = *(_DWORD *)(v24 + 32) >> 7;
        if (v60 >= 0x1E) {
          LOBYTE(v60) = 30;
        }
        uint64_t v61 = 4096 << v60;
        unsigned int v62 = (char *)operator new(4096 << v60, (std::align_val_t)8uLL);
        unsigned int v63 = *(_DWORD *)(v24 + 32);
        if (v63 >= *(_DWORD *)(v24 + 36)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v24 + 24) + 8 * v63) = v62;
        ++*(_DWORD *)(v24 + 32);
        unint64_t v25 = (unint64_t)(v62 + 63) & 0xFFFFFFFFFFFFFFC0;
        *(void *)(v24 + 8) = v25 + 192;
        *(void *)(v24 + 16) = &v62[v61];
      }
      else
      {
        unint64_t v25 = (v26 + 63) & 0xFFFFFFFFFFFFFFC0;
        *(void *)(v24 + 8) = v25 + 192;
      }
    }
    *(_OWORD *)(v25 + 160) = 0u;
    *(_OWORD *)(v25 + 176) = 0u;
    *(_OWORD *)(v25 + 128) = 0u;
    *(_OWORD *)(v25 + 144) = 0u;
    *(_OWORD *)(v25 + 96) = 0u;
    *(_OWORD *)(v25 + 112) = 0u;
    *(_OWORD *)(v25 + 64) = 0u;
    *(_OWORD *)(v25 + 80) = 0u;
    *(_OWORD *)(v25 + 32) = 0u;
    *(_OWORD *)(v25 + 48) = 0u;
    ++v14;
    *(_OWORD *)unint64_t v25 = 0u;
    *(_OWORD *)(v25 + 16) = 0u;
    *((void *)v67 + v23) = v25;
  }
  unint64_t v27 = 0;
  unsigned int v28 = 0;
  unsigned int v29 = 0;
  uint64_t v30 = v14;
  int v31 = v22 / v14;
  unint64_t v32 = v22 % v14;
  unsigned int v33 = v14;
  do
  {
    if (v27 >= v32) {
      int v34 = v31;
    }
    else {
      int v34 = v31 + 1;
    }
    v66[v27] = v34;
    unsigned int v35 = v5 - v28;
    v28 += v34;
    if (v33 == v14 && v28 > v5)
    {
      unsigned int v33 = v27;
      unsigned int v29 = v35;
    }
    ++v27;
  }
  while (v14 != v27);
  --v66[v33];
  sub_1CD57C620((uint64_t)v67, v14, (uint64_t)v68, (uint64_t)v66);
  if ((v9 & 1) == 0) {
    llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
  }
  uint64_t v36 = 0;
  char v37 = 0;
  for (unsigned int i = v33; ; --i)
  {
    int v39 = v66[v36];
    uint64_t v40 = (v39 - 1);
    uint64_t v41 = *(void *)(*((void *)v67 + v36) + 8 * v40 + 96);
    if (v23 && v36 == v23)
    {
      int v42 = sub_1CC48066C(a1);
      char v37 = v42;
      v2 += v42;
    }
    else
    {
      uint64_t v43 = *(void *)v4;
      *(_DWORD *)(*(void *)v4 + 16 * v2 + 8) = v39;
      if (v2) {
        *(void *)(*(void *)(v43 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v43 + 16 * (v2 - 1) + 12)) = *(void *)(*(void *)(v43 + 16 * (v2 - 1)) + 8 * *(unsigned int *)(v43 + 16 * (v2 - 1) + 12)) & 0xFFFFFFFFFFFFFFC0 | v40;
      }
      sub_1CC47FB18((uint64_t)a1, v2, v41);
    }
    if (v36 + 1 == v30) {
      break;
    }
    int v44 = 0;
    uint64_t v45 = 0;
    ++v36;
    uint64_t v46 = *(void *)v4;
    uint64_t v47 = (int *)(*(void *)v4 + 16 * (v2 - 1) + 12);
    while (1)
    {
      uint64_t v48 = v45;
      int v49 = v44;
      if (v2 + v45 == 1) {
        break;
      }
      int v50 = *(v47 - 1);
      int v51 = *v47;
      --v45;
      v47 -= 4;
      --v44;
      if (v51 != v50 - 1)
      {
        uint64_t v52 = v2 - 1 + v48;
        goto LABEL_55;
      }
    }
    uint64_t v52 = 0;
    int v50 = *(_DWORD *)(v46 + 8);
    int v51 = *(_DWORD *)(v46 + 12);
LABEL_55:
    unsigned int v53 = v51 + 1;
    *(_DWORD *)(v46 + 16 * v52 + 12) = v53;
    if (v53 != v50)
    {
      uint64_t v54 = *(void *)(*(void *)(v46 + 16 * v52) + 8 * v53);
      if (v48)
      {
        do
        {
          uint64_t v56 = *(void *)v4 + 16 * (v2 + v49);
          *(void *)uint64_t v56 = v54 & 0xFFFFFFFFFFFFFFC0;
          *(_DWORD *)(v56 + 8) = (v54 & 0x3F) + 1;
          *(_DWORD *)(v56 + 12) = 0;
          uint64_t v54 = *(void *)(v54 & 0xFFFFFFFFFFFFFFC0);
          BOOL v57 = __CFADD__(v49++, 1);
        }
        while (!v57);
        uint64_t v46 = *(void *)v4;
      }
      uint64_t v55 = (unint64_t *)(v46 + 16 * v2);
      unint64_t *v55 = v54 & 0xFFFFFFFFFFFFFFC0;
      v55[1] = (v54 & 0x3F) + 1;
    }
  }
  if (v33 != v36)
  {
    do
    {
      llvm::IntervalMapImpl::Path::moveLeft(v4, v2);
      BOOL v57 = __CFADD__(i++, 1);
    }
    while (!v57);
  }
  *(_DWORD *)(*(void *)v4 + 16 * v2 + 12) = v29;
  return v37 & 1;
}

uint64_t sub_1CC481060(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 16);
  uint64_t v3 = *(void *)(result + 8) + 16 * (v2 - 1);
  int v4 = *(_DWORD *)(*(void *)result + 184);
  uint64_t v5 = *(void *)(*(void *)v3 + 8 * *(unsigned int *)(v3 + 12));
  unint64_t v6 = a2 & 0xFFFFFFFFFFFFFFF8;
  int v7 = v4 - v2;
  if (v4 == v2)
  {
    unsigned int v8 = (a2 >> 1) & 3;
  }
  else
  {
    unsigned int v8 = (a2 >> 1) & 3;
    do
    {
      unsigned int v17 = 0;
      unint64_t v18 = v5 & 0xFFFFFFFFFFFFFFC0;
      do
      {
        unsigned int v19 = v17;
        uint64_t v20 = *(void *)((v5 & 0xFFFFFFFFFFFFFFC0) + 8 * v17 + 0x60);
        unsigned int v21 = (v20 >> 1) & 3 | *(_DWORD *)((v20 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v17 = v19 + 1;
      }
      while (v21 <= (*(_DWORD *)(v6 + 24) | v8));
      if (v2 >= *(_DWORD *)(result + 20)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      unsigned int v22 = (unint64_t *)(*(void *)(result + 8) + 16 * v2);
      *unsigned int v22 = v18;
      v22[1] = (v5 & 0x3F | ((unint64_t)v19 << 32)) + 1;
      unsigned int v2 = *(_DWORD *)(result + 16) + 1;
      *(_DWORD *)(result + 16) = v2;
      uint64_t v5 = *(void *)(v18 + 8 * v19);
      --v7;
    }
    while (v7);
  }
  unsigned int v9 = 0;
  unint64_t v10 = v5 & 0xFFFFFFFFFFFFFFC0;
  unsigned int v11 = *(_DWORD *)(v6 + 24) | v8;
  do
  {
    unsigned int v12 = v9;
    uint64_t v13 = *(void *)((v5 & 0xFFFFFFFFFFFFFFC0) + 16 * v9 + 8);
    unsigned int v14 = (v13 >> 1) & 3 | *(_DWORD *)((v13 & 0xFFFFFFFFFFFFFFF8) + 24);
    unsigned int v9 = v12 + 1;
  }
  while (v14 <= v11);
  if (v2 >= *(_DWORD *)(result + 20)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v15 = (v5 & 0x3F | ((unint64_t)v12 << 32)) + 1;
  uint64_t v16 = (unint64_t *)(*(void *)(result + 8) + 16 * v2);
  unint64_t *v16 = v10;
  v16[1] = v15;
  ++*(_DWORD *)(result + 16);
  return result;
}

uint64_t sub_1CC481228(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = 0;
  uint64_t v3 = a1 + 8;
  unsigned int v4 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFF8) + 24) | (a2 >> 1) & 3;
  do
  {
    unsigned int v5 = v2;
    uint64_t v6 = *(void *)(v3 + 8 * v2 + 88);
    unsigned int v7 = (v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24);
    unsigned int v2 = v5 + 1;
  }
  while (v7 <= v4);
  uint64_t v8 = v5;
  int v9 = *(_DWORD *)(a1 + 184);
  uint64_t v10 = *(void *)(v3 + 8 * v8);
  int v11 = v9 - 1;
  if (v9 != 1)
  {
    do
    {
      unsigned int v18 = 0;
      unint64_t v19 = v10 & 0xFFFFFFFFFFFFFFC0;
      do
      {
        unsigned int v20 = v18;
        uint64_t v21 = *(void *)(v19 + 8 * v18 + 96);
        unsigned int v22 = (v21 >> 1) & 3 | *(_DWORD *)((v21 & 0xFFFFFFFFFFFFFFF8) + 24);
        unsigned int v18 = v20 + 1;
      }
      while (v22 <= v4);
      uint64_t v10 = *(void *)(v19 + 8 * v20);
      --v11;
    }
    while (v11);
  }
  unsigned int v12 = 0;
  unint64_t v13 = v10 & 0xFFFFFFFFFFFFFFC0;
  do
  {
    unsigned int v14 = v12;
    uint64_t v15 = *(void *)(v13 + 16 * v12 + 8);
    unsigned int v16 = (v15 >> 1) & 3 | *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFF8) + 24);
    unsigned int v12 = v14 + 1;
  }
  while (v16 <= v4);
  if (v4 < ((*(void *)(v13 + 16 * v14) >> 1) & 3 | *(_DWORD *)((*(void *)(v13 + 16 * v14) & 0xFFFFFFFFFFFFFFF8)
                                                                                + 24)))
    return 0;
  else {
    return *(unsigned int *)(v13 + 4 * v14 + 144);
  }
}

void sub_1CC481328(uint64_t a1)
{
}

llvm *sub_1CC4813C8(llvm *a1, const char *a2, uint64_t a3)
{
  unsigned int v5 = llvm::dbgs(a1);
  uint64_t v6 = v5;
  if (a2)
  {
    size_t v7 = strlen(a2);
    unsigned int v5 = (llvm::raw_ostream *)*((void *)v6 + 4);
    if (v7 <= *((void *)v6 + 3) - (void)v5)
    {
      if (v7)
      {
        unsigned int v5 = (llvm::raw_ostream *)memcpy(v5, a2, v7);
        *((void *)v6 + 4) += v7;
      }
    }
    else
    {
      unsigned int v5 = llvm::raw_ostream::write(v6, a2, v7);
    }
  }
  uint64_t v8 = *((void *)v6 + 4);
  if ((unint64_t)(*((void *)v6 + 3) - v8) > 4)
  {
    *(unsigned char *)(v8 + 4) = 32;
    *(_DWORD *)uint64_t v8 = 2065709600;
    *((void *)v6 + 4) += 5;
  }
  else
  {
    unsigned int v5 = llvm::raw_ostream::write(v6, " : { ", 5uLL);
  }
  int v9 = *(_DWORD *)(a3 + 64);
  if (v9)
  {
    for (unsigned int i = 0; i != v9; ++i)
    {
      unint64_t v13 = llvm::dbgs(v5);
      unsigned int v5 = sub_1CD098D14(v13, (*(void *)(*(void *)a3 + 8 * (i >> 6)) >> i) & 1, 0, 0, 0);
      unsigned int v14 = (unsigned char *)*((void *)v13 + 4);
      if (*((unsigned char **)v13 + 3) == v14)
      {
        unsigned int v5 = llvm::raw_ostream::write(v13, " ", 1uLL);
      }
      else
      {
        *unsigned int v14 = 32;
        ++*((void *)v13 + 4);
      }
    }
  }
  double result = llvm::dbgs(v5);
  int v11 = (_WORD *)*((void *)result + 4);
  if (*((void *)result + 3) - (void)v11 > 1uLL)
  {
    *int v11 = 2685;
    *((void *)result + 4) += 2;
  }
  else
  {
    return llvm::raw_ostream::write(result, "}\n", 2uLL);
  }
  return result;
}

llvm *sub_1CC481578(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  uint64_t v3 = (llvm *)sub_1CC486124(*(void *)(a1 + 264), *(_DWORD *)(a1 + 280), a2, &v9);
  if (v3) {
    uint64_t v4 = v9;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 264) + 296 * *(unsigned int *)(a1 + 280);
  }
  unsigned int v5 = sub_1CC4813C8(v3, "BEGIN", v4 + 8);
  uint64_t v6 = sub_1CC4813C8(v5, "END", v4 + 80);
  size_t v7 = sub_1CC4813C8(v6, "LIVE_IN", v4 + 152);

  return sub_1CC4813C8(v7, "LIVE_OUT", v4 + 224);
}

void sub_1CC481620(uint64_t a1)
{
  sub_1CD50D210(a1 + 256, &v54);
  unsigned int v2 = v50;
  uint64_t v45 = v50;
  uint64_t v3 = v55;
  if (v55 == v54)
  {
    uint64_t v46 = v50;
    uint64_t v4 = v55;
  }
  else
  {
    unsigned int v38 = v56;
    unsigned int v2 = malloc_type_malloc(8 * v56, 0x4065EBACuLL);
    if (!v2)
    {
      if (v38) {
        goto LABEL_83;
      }
      unsigned int v2 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v2) {
        goto LABEL_83;
      }
    }
    uint64_t v46 = v2;
    uint64_t v4 = v54;
    uint64_t v3 = v55;
  }
  unsigned int v5 = v57;
  unsigned int v47 = v56;
  if (v3 == v4) {
    unsigned int v6 = v57;
  }
  else {
    unsigned int v6 = v56;
  }
  if (v6)
  {
    memmove(v2, v3, 8 * v6);
    unsigned int v5 = v57;
  }
  unsigned int v48 = v5;
  int v49 = v58;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  long long __p = 0;
  sub_1CBF340A8(&__p, v59, v60, 0xAAAAAAAAAAAAAAABLL * ((v60 - (unsigned char *)v59) >> 3));
  size_t v7 = v41;
  uint64_t v8 = v62;
  if (v62 != v61)
  {
    unsigned int v39 = v63;
    size_t v7 = malloc_type_malloc(8 * v63, 0x4065EBACuLL);
    if (v7 || !v39 && (size_t v7 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      uint64_t v40 = v7;
      uint64_t v9 = v61;
      uint64_t v8 = v62;
      goto LABEL_10;
    }
LABEL_83:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v40 = v41;
  uint64_t v9 = v62;
LABEL_10:
  if (v8 == v9) {
    unsigned int v10 = v64;
  }
  else {
    unsigned int v10 = v63;
  }
  if (v10) {
    memmove(v7, v8, 8 * v10);
  }
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  int v42 = 0;
  sub_1CBF340A8(&v42, v65, v66, 0xAAAAAAAAAAAAAAABLL * ((v66 - (unsigned char *)v65) >> 3));
  while (1)
  {
    if (v52 - (unsigned char *)__p != v43 - v42) {
      goto LABEL_30;
    }
    if (__p == v52) {
      break;
    }
    int v11 = (char *)v42 + 8;
    unsigned int v12 = (char *)__p + 8;
    while (1)
    {
      unint64_t v13 = v12 - 8;
      if (*((void *)v12 - 1) != *((void *)v11 - 1)) {
        break;
      }
      int v14 = v11[8];
      if (v12[8]) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15)
      {
        if ((v12[8] == 0) == (v14 != 0)) {
          break;
        }
      }
      else if (*(void *)v12 != *(void *)v11)
      {
        break;
      }
      v11 += 24;
      v12 += 24;
      if (v13 + 24 == v52) {
        goto LABEL_57;
      }
    }
LABEL_30:
    uint64_t v16 = *((void *)v52 - 3);
    unsigned int v17 = llvm::dbgs(v42);
    unsigned int v18 = v17;
    uint64_t v19 = *((void *)v17 + 4);
    if ((unint64_t)(*((void *)v17 + 3) - v19) > 0x11)
    {
      *(_WORD *)(v19 + 16) = 8992;
      *(_OWORD *)uint64_t v19 = *(_OWORD *)"Inspecting block #";
      *((void *)v17 + 4) += 18;
    }
    else
    {
      llvm::raw_ostream::write(v17, "Inspecting block #", 0x12uLL);
    }
    unint64_t v20 = *(int *)(v16 + 24);
    if ((v20 & 0x80000000) != 0)
    {
      unint64_t v20 = -(uint64_t)v20;
      uint64_t v21 = v18;
      int v22 = 1;
    }
    else
    {
      uint64_t v21 = v18;
      int v22 = 0;
    }
    sub_1CD098D14(v21, v20, 0, 0, v22);
    uint64_t v23 = (_WORD *)*((void *)v18 + 4);
    if (*((void *)v18 + 3) - (void)v23 > 1uLL)
    {
      *uint64_t v23 = 23328;
      *((void *)v18 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v18, " [", 2uLL);
    }
    uint64_t v24 = *(uint64_t ****)(v16 + 16);
    if (!v24 || (*((unsigned char *)v24 + 23) & 0x10) == 0) {
      goto LABEL_47;
    }
    uint64_t v25 = ***v24;
    uint64_t v26 = *(void *)(v25 + 152);
    uint64_t v27 = *(unsigned int *)(v25 + 168);
    if (v27)
    {
      LODWORD(v28) = (v27 - 1) & ((v24 >> 4) ^ (v24 >> 9));
      unsigned int v29 = (uint64_t ****)(v26 + 16 * v28);
      uint64_t v30 = *v29;
      if (*v29 == v24) {
        goto LABEL_45;
      }
      int v31 = 1;
      while (v30 != (uint64_t ***)-4096)
      {
        int v32 = v28 + v31++;
        uint64_t v28 = v32 & (v27 - 1);
        uint64_t v30 = *(uint64_t ****)(v26 + 16 * v28);
        if (v30 == v24)
        {
          unsigned int v29 = (uint64_t ****)(v26 + 16 * v28);
          goto LABEL_45;
        }
      }
    }
    unsigned int v29 = (uint64_t ****)(v26 + 16 * v27);
LABEL_45:
    unsigned int v33 = v29[1];
    size_t v36 = (size_t)*v33;
    int v34 = (const char *)(v33 + 2);
    size_t v35 = v36;
    char v37 = (_WORD *)*((void *)v18 + 4);
    if (v36 > *((void *)v18 + 3) - (void)v37)
    {
      llvm::raw_ostream::write(v18, v34, v35);
LABEL_47:
      char v37 = (_WORD *)*((void *)v18 + 4);
      goto LABEL_48;
    }
    if (v35)
    {
      memcpy(v37, v34, v35);
      char v37 = (_WORD *)(*((void *)v18 + 4) + v35);
      *((void *)v18 + 4) = v37;
    }
LABEL_48:
    if (*((void *)v18 + 3) - (void)v37 > 1uLL)
    {
      *char v37 = 2653;
      *((void *)v18 + 4) += 2;
    }
    else
    {
      llvm::raw_ostream::write(v18, "]\n", 2uLL);
    }
    sub_1CC481578(a1, v16);
    sub_1CD50D36C((char *)&v45);
  }
LABEL_57:
  if (v42)
  {
    uint64_t v43 = v42;
    operator delete(v42);
  }
  if (v40 != v41) {
    free(v40);
  }
  if (__p)
  {
    uint64_t v52 = (char *)__p;
    operator delete(__p);
  }
  if (v46 != v45) {
    free(v46);
  }
  if (v65)
  {
    BOOL v66 = v65;
    operator delete(v65);
  }
  if (v62 != v61) {
    free(v62);
  }
  if (v59)
  {
    unsigned int v60 = v59;
    operator delete(v59);
  }
  if (v55 != v54) {
    free(v55);
  }
}

unsigned int *sub_1CC481AE0(unsigned int *result)
{
  uint64_t v1 = result[100];
  if (v1)
  {
    unsigned int v2 = result;
    for (unint64_t i = 0; i != v1; ++i)
    {
      uint64_t v4 = llvm::dbgs((llvm *)result);
      unsigned int v5 = v4;
      uint64_t v6 = *((void *)v4 + 4);
      if ((unint64_t)(*((void *)v4 + 3) - v6) > 8)
      {
        *(unsigned char *)(v6 + 8) = 91;
        *(void *)uint64_t v6 = *(void *)"Interval[";
        *((void *)v4 + 4) += 9;
      }
      else
      {
        llvm::raw_ostream::write(v4, "Interval[", 9uLL);
      }
      sub_1CD098D14(v5, i, 0, 0, 0);
      uint64_t v7 = *((void *)v5 + 4);
      if ((unint64_t)(*((void *)v5 + 3) - v7) > 2)
      {
        *(unsigned char *)(v7 + 2) = 10;
        *(_WORD *)uint64_t v7 = 14941;
        *((void *)v5 + 4) += 3;
      }
      else
      {
        llvm::raw_ostream::write(v5, "]:\n", 3uLL);
      }
      double result = (unsigned int *)llvm::LiveInterval::dump(*(llvm::LiveInterval **)(*((void *)v2 + 49) + 8 * i));
    }
  }
  return result;
}

void sub_1CC481BF8()
{
}

void sub_1CC481DD0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2613250;
  unsigned int v2 = *(void **)(a1 + 1648);
  if (v2 != (void *)(a1 + 1664)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 1576);
  if (v3 != (void *)(a1 + 1592)) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 1504);
  if (v4 != (void *)(a1 + 1520)) {
    free(v4);
  }
  unsigned int v5 = *(void **)(a1 + 1424);
  if (v5 != (void *)(a1 + 1440)) {
    free(v5);
  }
  uint64_t v6 = *(unsigned int *)(a1 + 1344);
  if (v6)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 1336);
    uint64_t v8 = 8 * v6;
    do
    {
      uint64_t v9 = *v7++;
      MEMORY[0x1D25D9CD0](v9, 8);
      v8 -= 8;
    }
    while (v8);
  }
  unsigned int v10 = *(uint64_t **)(a1 + 1384);
  uint64_t v11 = *(unsigned int *)(a1 + 1392);
  if (v11)
  {
    uint64_t v25 = 16 * v11;
    do
    {
      uint64_t v26 = *v10;
      v10 += 2;
      MEMORY[0x1D25D9CD0](v26, 8);
      v25 -= 16;
    }
    while (v25);
    unsigned int v10 = *(uint64_t **)(a1 + 1384);
  }
  if (v10 != (uint64_t *)(a1 + 1400)) {
    free(v10);
  }
  unsigned int v12 = *(void **)(a1 + 1336);
  if (v12 != (void *)(a1 + 1352)) {
    free(v12);
  }
  sub_1CD48219C((char **)(a1 + 536));
  sub_1CD57C93C((char **)(a1 + 392));
  unint64_t v13 = *(void **)(a1 + 312);
  if (v13 != (void *)(a1 + 328)) {
    free(v13);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 288), 8);
  unsigned int v14 = *(_DWORD *)(a1 + 280);
  uint64_t v15 = *(void *)(a1 + 264);
  if (v14)
  {
    uint64_t v16 = 296 * v14;
    unsigned int v17 = (void *)(v15 + 240);
    do
    {
      if ((*(v17 - 30) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v18 = (void *)*(v17 - 2);
        if (v17 != v18) {
          free(v18);
        }
        uint64_t v19 = (char *)*(v17 - 11);
        if (v17 - 9 != (void *)v19) {
          free(v19);
        }
        unint64_t v20 = (char *)*(v17 - 20);
        if (v17 - 18 != (void *)v20) {
          free(v20);
        }
        uint64_t v21 = (char *)*(v17 - 29);
        if (v17 - 27 != (void *)v21) {
          free(v21);
        }
      }
      v17 += 37;
      v16 -= 296;
    }
    while (v16);
    uint64_t v15 = *(void *)(a1 + 264);
  }
  MEMORY[0x1D25D9CD0](v15, 8);
  *(void *)a1 = &unk_1F260E110;
  int v22 = *(void **)(a1 + 176);
  if (v22 != (void *)(a1 + 192)) {
    free(v22);
  }
  uint64_t v23 = *(void **)(a1 + 104);
  if (v23 != (void *)(a1 + 120)) {
    free(v23);
  }
  uint64_t v24 = *(void **)(a1 + 32);
  if (v24 != (void *)(a1 + 48)) {
    free(v24);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC482018(uint64_t a1)
{
  sub_1CC481DD0(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC482050(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::SlotIndexes::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

BOOL sub_1CC48209C(uint64_t a1, uint64_t a2)
{
  uint64_t v670 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 256) = a2;
  *(void *)(a1 + 248) = *(void *)(a2 + 56);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::SlotIndexes::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  *(void *)(a1 + 1416) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::SlotIndexes::ID);
  uint64_t v8 = (void *)(a1 + 264);
  int v9 = *(_DWORD *)(a1 + 272);
  if (v9 || *(_DWORD *)(a1 + 276))
  {
    unsigned int v10 = *(_DWORD *)(a1 + 280);
    uint64_t v11 = *(void *)(a1 + 264);
    if (v10 > 4 * v9 && v10 >= 0x41)
    {
      uint64_t v12 = 296 * v10;
      unint64_t v13 = (void *)(v11 + 240);
      do
      {
        if ((*(v13 - 30) | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v14 = (void *)*(v13 - 2);
          if (v13 != v14) {
            free(v14);
          }
          uint64_t v15 = (char *)*(v13 - 11);
          if (v13 - 9 != (void *)v15) {
            free(v15);
          }
          uint64_t v16 = (char *)*(v13 - 20);
          if (v13 - 18 != (void *)v16) {
            free(v16);
          }
          unsigned int v17 = (char *)*(v13 - 29);
          if (v13 - 27 != (void *)v17) {
            free(v17);
          }
        }
        v13 += 37;
        v12 -= 296;
      }
      while (v12);
      int v18 = 1 << (33 - __clz(v9 - 1));
      if (v18 <= 64) {
        int v18 = 64;
      }
      if (v9) {
        unsigned int v19 = v18;
      }
      else {
        unsigned int v19 = 0;
      }
      if (v19 == *(_DWORD *)(a1 + 280))
      {
        *(void *)(a1 + 272) = 0;
        if (v19)
        {
          unint64_t v20 = *(void **)(a1 + 264);
          uint64_t v21 = 296 * v19;
          do
          {
            *unint64_t v20 = -4096;
            v20 += 37;
            v21 -= 296;
          }
          while (v21);
        }
      }
      else
      {
        MEMORY[0x1D25D9CD0](*v8, 8);
        if (v19)
        {
          unint64_t v46 = (4 * v19 / 3 + 1) | ((unint64_t)(4 * v19 / 3 + 1) >> 1);
          unint64_t v47 = v46 | (v46 >> 2) | ((v46 | (v46 >> 2)) >> 4);
          LODWORD(v47) = (((v47 | (v47 >> 8)) >> 16) | v47 | (v47 >> 8)) + 1;
          *(_DWORD *)(a1 + 280) = v47;
          unsigned int v48 = operator new(296 * v47, (std::align_val_t)8uLL);
          *(void *)(a1 + 264) = v48;
          *(void *)(a1 + 272) = 0;
          unsigned int v49 = *(_DWORD *)(a1 + 280);
          if (v49)
          {
            uint64_t v50 = 296 * v49;
            do
            {
              *unsigned int v48 = -4096;
              v48 += 37;
              v50 -= 296;
            }
            while (v50);
          }
        }
        else
        {
          void *v8 = 0;
          *(void *)(a1 + 272) = 0;
          *(_DWORD *)(a1 + 280) = 0;
        }
      }
      goto LABEL_46;
    }
    if (!v10)
    {
LABEL_45:
      *(void *)(a1 + 272) = 0;
      goto LABEL_46;
    }
    uint64_t v22 = 296 * v10;
    uint64_t v23 = (void *)(v11 + 240);
    while (1)
    {
      uint64_t v24 = *(v23 - 30);
      if (v24 == -8192) {
        goto LABEL_43;
      }
      if (v24 != -4096) {
        break;
      }
LABEL_44:
      v23 += 37;
      v22 -= 296;
      if (!v22) {
        goto LABEL_45;
      }
    }
    uint64_t v25 = (void *)*(v23 - 2);
    if (v23 != v25) {
      free(v25);
    }
    uint64_t v26 = (char *)*(v23 - 11);
    if (v23 - 9 != (void *)v26) {
      free(v26);
    }
    uint64_t v27 = (char *)*(v23 - 20);
    if (v23 - 18 != (void *)v27) {
      free(v27);
    }
    uint64_t v28 = (char *)*(v23 - 29);
    if (v23 - 27 != (void *)v28) {
      free(v28);
    }
LABEL_43:
    *(v23 - 30) = -4096;
    goto LABEL_44;
  }
LABEL_46:
  unsigned int v29 = (uint64_t *)(a1 + 288);
  sub_1CD3C7F68((_DWORD *)(a1 + 288));
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 1432) = 0;
  uint64_t v30 = *(unsigned int *)(a1 + 400);
  if (v30)
  {
    uint64_t v31 = 8 * v30;
    uint64_t v32 = *(void *)(a1 + 392) - 8;
    do
    {
      sub_1CC2CAB7C((uint64_t *)(v32 + v31), 0);
      v31 -= 8;
    }
    while (v31);
  }
  *(_DWORD *)(a1 + 400) = 0;
  uint64_t v33 = *(unsigned int *)(a1 + 544);
  if (v33)
  {
    uint64_t v34 = *(void *)(a1 + 536);
    uint64_t v35 = 48 * v33;
    do
    {
      size_t v36 = *(void **)(v34 + v35 - 48);
      if ((void *)(v34 + v35 - 32) != v36) {
        free(v36);
      }
      v35 -= 48;
    }
    while (v35);
  }
  *(_DWORD *)(a1 + 544) = 0;
  uint64_t v37 = *(unsigned int *)(a1 + 1392);
  if (v37)
  {
    uint64_t v579 = *(uint64_t **)(a1 + 1384);
    uint64_t v580 = 16 * v37;
    do
    {
      uint64_t v581 = *v579;
      v579 += 2;
      MEMORY[0x1D25D9CD0](v581, 8);
      v580 -= 16;
    }
    while (v580);
  }
  *(_DWORD *)(a1 + 1392) = 0;
  uint64_t v38 = *(unsigned int *)(a1 + 1344);
  if (v38)
  {
    *(void *)(a1 + 1400) = 0;
    unsigned int v39 = *(uint64_t **)(a1 + 1336);
    uint64_t v40 = *v39;
    *(void *)(a1 + 1320) = *v39;
    *(void *)(a1 + 1328) = v40 + 4096;
    if (v38 != 1)
    {
      int v51 = v39 + 1;
      uint64_t v52 = 8 * v38 - 8;
      do
      {
        uint64_t v53 = *v51++;
        MEMORY[0x1D25D9CD0](v53, 8);
        v52 -= 8;
      }
      while (v52);
    }
    *(_DWORD *)(a1 + 1344) = 1;
  }
  uint64_t v41 = *(void *)(a1 + 248);
  int v42 = -858993459 * ((*(void *)(v41 + 16) - *(void *)(v41 + 8)) >> 3);
  LODWORD(v41) = *(_DWORD *)(v41 + 32);
  unint64_t v43 = (v42 - v41);
  if (v42 == v41) {
    return 0;
  }
  unsigned int v623 = v625;
  uint64_t v624 = 0x800000000;
  if (v43 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v617 = (void *)(a1 + 392);
  v610 = (void *)(a1 + 536);
  if (*(_DWORD *)(a1 + 404) < v43) {
    sub_1CD57CA2C();
  }
  sub_1CD57CAD8((uint64_t)v610, v43);
  uint64_t v54 = (void *)(a1 + 1504);
  v620[0] = 0;
  v620[1] = 0;
  unsigned int v621 = 0;
  *(_DWORD *)(a1 + 1512) = 0;
  *(_DWORD *)(a1 + 1568) = v43;
  unint64_t v600 = v43;
  unsigned int v55 = v43 + 63;
  uint64_t v56 = (v43 + 63) >> 6;
  if ((v43 + 63) < 0x40)
  {
    unsigned int v57 = 0;
  }
  else
  {
    if (v56 > *(_DWORD *)(a1 + 1516)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    bzero(*(void **)(a1 + 1504), 8 * v56);
    unsigned int v57 = (v43 + 63) >> 6;
    *(_DWORD *)(a1 + 1512) = v56;
    uint64_t v54 = (void *)(a1 + 1504);
  }
  if ((v43 & 0x3F) != 0) {
    *(void *)(*v54 + 8 * v57 - 8) &= ~(-1 << v43);
  }
  int v58 = (void *)(a1 + 1576);
  *(_DWORD *)(a1 + 1584) = 0;
  *(_DWORD *)(a1 + 1640) = v600;
  if (v55 < 0x40)
  {
    unsigned int v60 = 0;
    char v59 = v600;
  }
  else
  {
    if (v56 > *(_DWORD *)(a1 + 1588)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    char v59 = v600;
    bzero(*(void **)(a1 + 1576), 8 * v56);
    unsigned int v60 = v56;
    *(_DWORD *)(a1 + 1584) = v56;
  }
  if ((v59 & 0x3F) != 0) {
    *(void *)(*v58 + 8 * v60 - 8) &= ~(-1 << v59);
  }
  uint64_t v61 = (void *)(a1 + 1648);
  *(_DWORD *)(a1 + 1656) = 0;
  *(_DWORD *)(a1 + 1712) = v600;
  if (v55 < 0x40)
  {
    unsigned int v63 = 0;
    char v62 = v600;
  }
  else
  {
    if (v56 > *(_DWORD *)(a1 + 1660)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    char v62 = v600;
    bzero(*(void **)(a1 + 1648), 8 * v56);
    unsigned int v63 = v56;
    *(_DWORD *)(a1 + 1656) = v56;
  }
  uint64_t v596 = v55 >> 6;
  if ((v62 & 0x3F) != 0) {
    *(void *)(*v61 + 8 * v63 - 8) &= ~(-1 << (v62 & 0x3F));
  }
  size_t v599 = (uint64_t **)(a1 + 256);
  unsigned int v64 = v654;
  uint64_t v652 = v654;
  HIDWORD(v653) = 8;
  unsigned int v595 = v55;
  if (v600)
  {
    bzero(v654, 4 * v600);
    LODWORD(v653) = v600;
    uint64_t v65 = v651;
    int v649 = v651;
    HIDWORD(v650) = 8;
    bzero(v651, 4 * v600);
    LODWORD(v650) = v600;
    uint64_t v645 = v648;
    int v647 = 8;
    BOOL v66 = v648;
    bzero(v648, 4 * v600);
  }
  else
  {
    LODWORD(v653) = 0;
    uint64_t v65 = v651;
    int v649 = v651;
    uint64_t v650 = 0x800000000;
    BOOL v66 = v648;
    uint64_t v645 = v648;
    int v647 = 8;
  }
  int v646 = v600;
  sub_1CD50D210((uint64_t)v599, &v655);
  uint64_t v67 = v640;
  __dst[0] = v640;
  unsigned int v68 = __src;
  if (__src == v655)
  {
    __dst[1] = v640;
    uint64_t v69 = __src;
  }
  else
  {
    int v345 = (int)v657;
    uint64_t v67 = malloc_type_malloc(8 * v657, 0x4065EBACuLL);
    if (!v67)
    {
      if (v345) {
        goto LABEL_994;
      }
      uint64_t v67 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      BOOL v66 = v648;
      if (!v67) {
        goto LABEL_994;
      }
    }
    __dst[1] = v67;
    uint64_t v69 = v655;
    unsigned int v68 = __src;
  }
  int v70 = HIDWORD(v657);
  LODWORD(__dst[2]) = v657;
  if (v68 == v69) {
    unsigned int v71 = HIDWORD(v657);
  }
  else {
    unsigned int v71 = v657;
  }
  if (v71)
  {
    memmove(v67, v68, 8 * v71);
    int v70 = HIDWORD(v657);
  }
  HIDWORD(__dst[2]) = v70;
  LODWORD(__dst[3]) = v658;
  uint64_t v644 = 0;
  long long __p = 0;
  BOOL v643 = 0;
  sub_1CBF340A8(&__p, v661, v662, 0xAAAAAAAAAAAAAAABLL * ((v662 - (unsigned char *)v661) >> 3));
  unsigned int v72 = v635;
  size_t v630 = v635;
  char v73 = v664;
  if (v664 == v663)
  {
    uint64_t v631 = (uint64_t)v635;
    unint64_t v74 = v664;
  }
  else
  {
    unsigned int v346 = v665;
    unsigned int v72 = malloc_type_malloc(8 * v665, 0x4065EBACuLL);
    if (!v72)
    {
      if (v346) {
        goto LABEL_994;
      }
      unsigned int v72 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v72) {
        goto LABEL_994;
      }
    }
    uint64_t v631 = (uint64_t)v72;
    unint64_t v74 = v663;
    char v73 = v664;
  }
  uint64_t v75 = a1 + 312;
  unsigned int v76 = v666;
  unsigned int v632 = v665;
  if (v73 == v74) {
    unsigned int v77 = v666;
  }
  else {
    unsigned int v77 = v665;
  }
  if (v77)
  {
    memmove(v72, v73, 8 * v77);
    unsigned int v76 = v666;
  }
  unsigned int v633 = v76;
  int v634 = v667;
  int v637 = 0;
  uint64_t v638 = 0;
  uint64_t v636 = 0;
  sub_1CBF340A8(&v636, v668, v669, 0xAAAAAAAAAAAAAAABLL * ((v669 - (unsigned char *)v668) >> 3));
  unsigned int v602 = 0;
  uint64_t v78 = v628;
  uint64_t v79 = a1 + 1440;
LABEL_107:
  if (v643 - (unsigned char *)__p != v637 - v636)
  {
LABEL_121:
    uint64_t v593 = v78;
    unint64_t v594 = v65;
    uint64_t v85 = *((void *)v643 - 3);
    uint64_t v619 = v85;
    v626 = v78;
    uint64_t v627 = 0x600000000;
    unsigned int v629 = v600;
    int v590 = v64;
    unint64_t v592 = v29;
    uint64_t v585 = v79;
    uint64_t v586 = v75;
    if (v595 < 0x40)
    {
      unsigned int v88 = 0;
      unsigned int v87 = v78;
      char v86 = v600;
    }
    else
    {
      if (v595 >= 0x1C0) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      char v86 = v600;
      unsigned int v87 = v78;
      bzero(v78, 8 * v56);
      unsigned int v88 = v596;
      LODWORD(v627) = v596;
    }
    int v588 = v66;
    if ((v86 & 0x3F) != 0) {
      v87[v88 - 1] &= ~(-1 << (v86 & 0x3F));
    }
    unint64_t v89 = *(uint64_t **)(v85 + 64);
    int v90 = *(uint64_t **)(v85 + 72);
    if (v89 != v90)
    {
      int v136 = v621;
      uint64_t v612 = v620[0];
      uint64_t v605 = v620[0] + 80 * v621;
      do
      {
        uint64_t v137 = *v89;
        uint64_t v622 = 0;
        int v138 = sub_1CD4C612C(v612, v136, v137, &v622);
        uint64_t v139 = v622;
        if (v138) {
          BOOL v140 = v622 == v605;
        }
        else {
          BOOL v140 = 1;
        }
        if (!v140)
        {
          unsigned int v141 = *(_DWORD *)(v622 + 72);
          if (v629 < v141)
          {
            uint64_t v146 = v627;
            if ((v629 & 0x3F) != 0) {
              *((void *)v626 + v627 - 1) &= ~(-1 << (v629 & 0x3F));
            }
            unsigned int v147 = v146;
            unsigned int v629 = v141;
            unsigned int v148 = v141 + 63;
            if (v146 != (v141 + 63) >> 6)
            {
              uint64_t v149 = v148 >> 6;
              if (v146 > v149)
              {
                LODWORD(v627) = v148 >> 6;
                unsigned int v147 = v148 >> 6;
              }
              else
              {
                int v584 = v146;
                if (v149 > HIDWORD(v627)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if (v149 != v146)
                {
                  int v582 = v146;
                  unsigned int v583 = v148 >> 6;
                  bzero((char *)v626 + 8 * v146, 8 * (v149 - v146));
                  LODWORD(v146) = v582;
                  LODWORD(v149) = v583;
                }
                unsigned int v147 = v584 + v149 - v146;
                LODWORD(v627) = v147;
                LOBYTE(v141) = v629;
              }
            }
            int v150 = v141 & 0x3F;
            if (v150) {
              *((void *)v626 + v147 - 1) &= ~(-1 << v150);
            }
          }
          uint64_t v142 = *(unsigned int *)(v139 + 16);
          if (v142)
          {
            int v143 = *(uint64_t **)(v139 + 8);
            int v144 = v626;
            do
            {
              uint64_t v145 = *v143++;
              *v144++ |= v145;
              --v142;
            }
            while (v142);
          }
        }
        ++v89;
      }
      while (v89 != v90);
    }
    uint64_t v91 = *(void *)(v85 + 56);
    unsigned int v29 = v592;
    unsigned int v92 = v602;
    if (v91 == v85 + 48) {
      goto LABEL_128;
    }
    while (1)
    {
      unsigned int v112 = *(unsigned __int16 **)(v91 + 16);
      int v113 = *v112;
      if ((v113 - 13) < 5) {
        goto LABEL_190;
      }
      uint64_t v114 = *(void *)(v91 + 32);
      if ((v113 - 21) <= 1)
      {
        int v115 = *(_DWORD *)(v114 + 16);
        if (v115 < 0) {
          unsigned int v116 = -1;
        }
        else {
          unsigned int v116 = v115;
        }
        if ((v115 & 0x80000000) == 0)
        {
          uint64_t v117 = 1 << v116;
          uint64_t v118 = v116 >> 6;
          *(void *)(*(void *)(a1 + 1504) + 8 * v118) |= 1 << v116;
          if (v113 == 21)
          {
            *((void *)v626 + v118) |= v117;
            uint64_t v119 = v652;
          }
          else
          {
            *((void *)v626 + v118) &= ~v117;
            uint64_t v119 = v649;
          }
          ++v119[v116];
          unint64_t v135 = *(unsigned int *)(a1 + 1432);
          if (v135 >= *(unsigned int *)(a1 + 1436)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(a1 + 1424) + 8 * v135) = v91;
          ++*(_DWORD *)(a1 + 1432);
          ++v92;
        }
        goto LABEL_190;
      }
      uint64_t v120 = *(unsigned int *)(v91 + 40);
      if (!v120) {
        goto LABEL_190;
      }
      uint64_t v121 = v114 + 32 * v120;
      uint64_t v122 = v626;
      unsigned int v123 = v113 - 1;
      uint64_t v124 = v645;
      uint64_t v125 = *(void *)(v91 + 32);
      do
      {
        if (*(unsigned char *)v125 != 5) {
          goto LABEL_171;
        }
        uint64_t v126 = *(unsigned int *)(v125 + 16);
        if ((v126 & 0x80000000) != 0) {
          goto LABEL_171;
        }
        uint64_t v127 = 1 << v126;
        uint64_t v128 = v126 >> 6;
        if ((v122[v128] & (1 << v126)) == 0) {
          *(void *)(*v58 + 8 * v128) |= v127;
        }
        if (v123 <= 1 && (*(unsigned char *)(v114 + 48) & 0x10) != 0)
        {
LABEL_163:
          *(void *)(*v61 + 8 * v128) |= v127;
          goto LABEL_164;
        }
        __int16 v129 = *(_WORD *)(v91 + 44);
        uint64_t v130 = *((void *)v112 + 1);
        if ((v129 & 0xC) != 0 && (v129 & 4) == 0)
        {
          uint64_t v133 = v91;
          if ((v130 & 0x100000) != 0) {
            goto LABEL_163;
          }
          while ((*(_WORD *)(v133 + 44) & 8) != 0)
          {
            uint64_t v133 = *(void *)(v133 + 8);
            if ((*(unsigned char *)(*(void *)(v133 + 16) + 10) & 0x10) != 0) {
              goto LABEL_163;
            }
          }
        }
        else if ((v130 & 0x100000) != 0)
        {
          goto LABEL_163;
        }
LABEL_164:
        if ((*v599)[12] && *(unsigned char *)(v85 + 184))
        {
          if (v123 <= 1 && (*(unsigned char *)(v114 + 48) & 8) != 0) {
            goto LABEL_170;
          }
          __int16 v131 = *(_WORD *)(v91 + 44);
          uint64_t v132 = *((void *)v112 + 1);
          if ((v131 & 0xC) == 0 || (v131 & 4) != 0)
          {
            if ((v132 & 0x80000) == 0) {
              goto LABEL_171;
            }
LABEL_170:
            ++v124[v126];
            goto LABEL_171;
          }
          uint64_t v134 = v91;
          if ((v132 & 0x80000) != 0) {
            goto LABEL_170;
          }
          while ((*(_WORD *)(v134 + 44) & 8) != 0)
          {
            uint64_t v134 = *(void *)(v134 + 8);
            if ((*(unsigned char *)(*(void *)(v134 + 16) + 10) & 8) != 0) {
              goto LABEL_170;
            }
          }
        }
LABEL_171:
        v125 += 32;
      }
      while (v125 != v121);
      if (!v91) {
        goto LABEL_193;
      }
LABEL_190:
      if ((*(unsigned char *)v91 & 4) == 0)
      {
LABEL_193:
        while ((*(_WORD *)(v91 + 44) & 8) != 0)
          uint64_t v91 = *(void *)(v91 + 8);
      }
      uint64_t v91 = *(void *)(v91 + 8);
      if (v91 == v85 + 48)
      {
LABEL_128:
        unsigned int v602 = v92;
        uint64_t v93 = sub_1CD55B7E0((uint64_t)v620, &v619);
        int v94 = (char *)(v93 + 1);
        unsigned int v95 = v629;
        uint64_t v96 = v593;
        if (*((_DWORD *)v93 + 18) < v629)
        {
          uint64_t v97 = v93;
          int v98 = v93[9] & 0x3F;
          BOOL v99 = (char *)*((unsigned int *)v93 + 4);
          if (v98)
          {
            uint64_t v151 = v93[1] + 8 * v99;
            *(void *)(v151 - 8) &= ~(-1 << v98);
          }
          unsigned int v100 = v99;
          *((_DWORD *)v93 + 18) = v95;
          unsigned int v101 = v95 + 63;
          if (v99 != (v95 + 63) >> 6)
          {
            unint64_t v102 = (char *)(v101 >> 6);
            if (v99 > v102)
            {
              *((_DWORD *)v93 + 4) = v102;
              unsigned int v100 = v101 >> 6;
            }
            else
            {
              uint64_t v103 = v99;
              if (v102 > *((_DWORD *)v93 + 5)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v102 != v99)
              {
                size_t v104 = 8 * (v102 - v99);
                int v611 = (int)v99;
                BOOL v99 = (char *)(v93 + 1);
                bzero((void *)(*(void *)v94 + 8 * (void)v103), v104);
                int v94 = v99;
                LODWORD(v99) = v611;
                uint64_t v96 = v593;
              }
              v100 += v102 - v99;
              *((_DWORD *)v97 + 4) = v100;
              unsigned int v95 = *((_DWORD *)v97 + 18);
            }
          }
          int v105 = v95 & 0x3F;
          if (v105) {
            *(void *)(*(void *)v94 + 8 * v100 - 8) &= ~(-1 << v105);
          }
        }
        uint64_t v106 = v627;
        uint64_t v107 = v626;
        uint64_t v65 = v594;
        if (v627)
        {
          uint64_t v108 = *(void **)v94;
          uint64_t v109 = (uint64_t *)v626;
          do
          {
            uint64_t v110 = *v109++;
            *v108++ |= v110;
            --v106;
          }
          while (v106);
        }
        uint64_t v111 = v96;
        BOOL v66 = v588;
        unsigned int v64 = v590;
        if (v107 != v96) {
          free(v107);
        }
        sub_1CD50D36C((char *)__dst);
        uint64_t v78 = v111;
        uint64_t v79 = v585;
        uint64_t v75 = v586;
        goto LABEL_107;
      }
    }
  }
  if (__p != v643)
  {
    uint64_t v80 = v636 + 8;
    int v81 = (char *)__p + 8;
    do
    {
      uint64_t v82 = v81 - 8;
      if (*((void *)v81 - 1) != *((void *)v80 - 1)) {
        goto LABEL_121;
      }
      int v83 = v80[8];
      if (v81[8]) {
        BOOL v84 = v83 == 0;
      }
      else {
        BOOL v84 = 1;
      }
      if (v84)
      {
        if ((v81[8] == 0) == (v83 != 0)) {
          goto LABEL_121;
        }
      }
      else if (*(void *)v81 != *(void *)v80)
      {
        goto LABEL_121;
      }
      v80 += 24;
      v81 += 24;
    }
    while (v82 + 24 != v643);
  }
  if (v636)
  {
    int v637 = v636;
    operator delete(v636);
  }
  if ((void *)v631 != v630) {
    free((void *)v631);
  }
  if (__p)
  {
    BOOL v643 = (char *)__p;
    operator delete(__p);
  }
  if (__dst[1] != __dst[0]) {
    free(__dst[1]);
  }
  if (v668)
  {
    uint64_t v669 = v668;
    operator delete(v668);
  }
  if (v664 != v663) {
    free(v664);
  }
  if (v661)
  {
    uint64_t v662 = v661;
    operator delete(v661);
  }
  if (__src != v655) {
    free(__src);
  }
  if (v602)
  {
    if (v600)
    {
      uint64_t v216 = 0;
      unint64_t v217 = (int *)v652;
      unint64_t v218 = (int *)v649;
      unint64_t v219 = (int *)v645;
      do
      {
        if (v217[v216] > 1
          || v218[v216] > 1
          || v219[v216] >= 2 && ((*(void *)(*v61 + 8 * (v216 >> 6)) >> v216) & 1) == 0)
        {
          *(void *)(*v58 + 8 * (v216 >> 6)) |= 1 << v216;
        }
        ++v216;
      }
      while (v600 != v216);
    }
    sub_1CD50D210((uint64_t)v599, &v655);
    unint64_t v166 = v640;
    __dst[0] = v640;
    uint64_t v167 = __src;
    if (__src == v655)
    {
      __dst[1] = v640;
      unint64_t v168 = __src;
    }
    else
    {
      int v577 = (int)v657;
      unint64_t v166 = malloc_type_malloc(8 * v657, 0x4065EBACuLL);
      if (!v166)
      {
        if (v577) {
          goto LABEL_994;
        }
        unint64_t v166 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v166) {
          goto LABEL_994;
        }
      }
      __dst[1] = v166;
      unint64_t v168 = v655;
      uint64_t v167 = __src;
    }
    int v169 = HIDWORD(v657);
    LODWORD(__dst[2]) = v657;
    if (v167 == v168) {
      unsigned int v170 = HIDWORD(v657);
    }
    else {
      unsigned int v170 = v657;
    }
    if (v170)
    {
      memmove(v166, v167, 8 * v170);
      int v169 = HIDWORD(v657);
    }
    HIDWORD(__dst[2]) = v169;
    LODWORD(__dst[3]) = v658;
    uint64_t v644 = 0;
    long long __p = 0;
    BOOL v643 = 0;
    sub_1CBF340A8(&__p, v661, v662, 0xAAAAAAAAAAAAAAABLL * ((v662 - (unsigned char *)v661) >> 3));
    unsigned int v171 = v635;
    size_t v630 = v635;
    unsigned int v172 = v664;
    if (v664 == v663)
    {
      uint64_t v631 = (uint64_t)v635;
      uint64_t v173 = v664;
LABEL_279:
      unsigned int v174 = v666;
      unsigned int v632 = v665;
      if (v172 == v173) {
        unsigned int v175 = v666;
      }
      else {
        unsigned int v175 = v665;
      }
      if (v175)
      {
        memmove(v171, v172, 8 * v175);
        unsigned int v174 = v666;
      }
      unsigned int v633 = v174;
      int v634 = v667;
      int v637 = 0;
      uint64_t v638 = 0;
      uint64_t v636 = 0;
      sub_1CBF340A8(&v636, v668, v669, 0xAAAAAAAAAAAAAAABLL * ((v669 - (unsigned char *)v668) >> 3));
      uint64_t v176 = a1 + 328;
      BOOL v177 = v628;
      while (1)
      {
        if (v643 - (unsigned char *)__p == v637 - v636)
        {
          if (__p == v643)
          {
LABEL_348:
            if (v636)
            {
              int v637 = v636;
              operator delete(v636);
            }
            if ((void *)v631 != v630) {
              free((void *)v631);
            }
            if (__p)
            {
              BOOL v643 = (char *)__p;
              operator delete(__p);
            }
            if (__dst[1] != __dst[0]) {
              free(__dst[1]);
            }
            if (v668)
            {
              uint64_t v669 = v668;
              operator delete(v668);
            }
            if (v664 != v663) {
              free(v664);
            }
            if (v661)
            {
              uint64_t v662 = v661;
              operator delete(v661);
            }
            if (__src != v655) {
              free(__src);
            }
            goto LABEL_241;
          }
          unint64_t v178 = v636 + 8;
          uint64_t v179 = (char *)__p + 8;
          while (1)
          {
            uint64_t v180 = v179 - 8;
            if (*((void *)v179 - 1) != *((void *)v178 - 1)) {
              break;
            }
            int v181 = v178[8];
            if (v179[8]) {
              BOOL v182 = v181 == 0;
            }
            else {
              BOOL v182 = 1;
            }
            if (v182)
            {
              if ((v179[8] == 0) == (v181 != 0)) {
                break;
              }
            }
            else if (*(void *)v179 != *(void *)v178)
            {
              break;
            }
            v178 += 24;
            v179 += 24;
            if (v180 + 24 == v643) {
              goto LABEL_348;
            }
          }
        }
        size_t v613 = v177;
        uint64_t v622 = 0;
        uint64_t v622 = *((void *)v643 - 3);
        int v183 = *(_DWORD *)(a1 + 320);
        *((_DWORD *)sub_1CD3CDD24(v29, &v622) + 2) = v183;
        unint64_t v184 = *(unsigned int *)(a1 + 320);
        int v589 = v66;
        if (v184 >= *(unsigned int *)(a1 + 324)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v606 = v176;
        *(void *)(*(void *)(a1 + 312) + 8 * v184) = v622;
        ++*(_DWORD *)(a1 + 320);
        v626 = 0;
        char v185 = sub_1CC486124(*(void *)(a1 + 264), *(_DWORD *)(a1 + 280), v622, &v626);
        unint64_t v186 = (unsigned int *)v626;
        int v591 = v64;
        uint64_t v587 = v75;
        if ((v185 & 1) == 0) {
          break;
        }
        uint64_t v187 = (int *)((char *)v626 + 72);
        unint64_t v188 = (uint64_t *)((char *)v626 + 8);
        if ((*((_DWORD *)v626 + 18) & 0x3F) == 0)
        {
          unsigned int v189 = *((_DWORD *)v626 + 4);
LABEL_304:
          uint64_t v191 = v189;
          goto LABEL_305;
        }
        uint64_t v191 = *((unsigned int *)v626 + 4);
        uint64_t v215 = *((void *)v626 + 1) + 8 * v191;
        *(void *)(v215 - 8) &= ~(-1 << (*((_DWORD *)v626 + 18) & 0x3F));
        unsigned int v189 = v191;
LABEL_305:
        LOBYTE(v192) = v600;
        v186[18] = v600;
        unsigned int v193 = v596;
        if (v189 != v596)
        {
          if (v189 > v596)
          {
            unsigned int v193 = v596;
            v186[4] = v596;
            LOBYTE(v192) = v600;
          }
          else
          {
            if (v596 > v186[5]) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v596 != v191) {
              bzero((void *)(*v188 + 8 * v191), 8 * (v596 - v191));
            }
            unsigned int v193 = v189 + v596 - v191;
            v186[4] = v193;
            int v192 = *v187;
          }
        }
        int v194 = v192 & 0x3F;
        if (v194) {
          *(void *)(*v188 + 8 * v193 - 8) &= ~(-1 << v194);
        }
        uint64_t v195 = v186[22];
        if ((v186[36] & 0x3F) != 0)
        {
          uint64_t v214 = *((void *)v186 + 10) + 8 * v195;
          *(void *)(v214 - 8) &= ~(-1 << (v186[36] & 0x3F));
        }
        uint64_t v196 = (uint64_t *)(v186 + 20);
        LOBYTE(v197) = v600;
        v186[36] = v600;
        unsigned int v198 = v596;
        if (v195 != v596)
        {
          if (v195 > v596)
          {
            unsigned int v198 = v596;
            v186[22] = v596;
            LOBYTE(v197) = v600;
          }
          else
          {
            if (v596 > v186[23]) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            if (v596 != v195) {
              bzero((void *)(*v196 + 8 * v195), 8 * (v596 - v195));
            }
            unsigned int v198 = v596;
            v186[22] = v596;
            unsigned int v197 = v186[36];
          }
        }
        int v199 = v197 & 0x3F;
        if (v199) {
          *(void *)(*v196 + 8 * v198 - 8) &= ~(-1 << v199);
        }
        v626 = v613;
        HIDWORD(v627) = 4;
        uint64_t v200 = v622 + 48;
        uint64_t v201 = *(void *)(v622 + 56);
        BOOL v66 = v589;
        if (v201 != v622 + 48)
        {
          do
          {
            LOBYTE(v619) = 0;
            LODWORD(v627) = 0;
            if (sub_1CC485ED4(a1, v201, (uint64_t)&v626, (char *)&v619))
            {
              uint64_t v202 = (unsigned int *)v626;
              if ((_BYTE)v619)
              {
                if (v627)
                {
                  uint64_t v203 = *v196;
                  uint64_t v204 = *v188;
                  uint64_t v205 = 4 * v627;
                  do
                  {
                    unint64_t v206 = *v202;
                    uint64_t v207 = 1 << v206;
                    unint64_t v208 = v206 >> 6;
                    uint64_t v209 = *(void *)(v203 + 8 * v208);
                    if ((v207 & v209) != 0) {
                      *(void *)(v203 + 8 * v208) = v209 & ~v207;
                    }
                    *(void *)(v204 + 8 * v208) |= v207;
                    ++v202;
                    v205 -= 4;
                  }
                  while (v205);
                }
              }
              else
              {
                unint64_t v210 = *(unsigned int *)v626;
                uint64_t v211 = 1 << v210;
                unint64_t v212 = v210 >> 6;
                uint64_t v213 = *(void *)(*v188 + 8 * v212);
                if ((v211 & v213) != 0) {
                  *(void *)(*v188 + 8 * v212) = v213 & ~v211;
                }
                *(void *)(*v196 + 8 * v212) |= v211;
              }
            }
            if ((*(unsigned char *)v201 & 4) == 0)
            {
              while ((*(_WORD *)(v201 + 44) & 8) != 0)
                uint64_t v201 = *(void *)(v201 + 8);
            }
            uint64_t v201 = *(void *)(v201 + 8);
          }
          while (v201 != v200);
          if (v626 != v613) {
            free(v626);
          }
        }
        sub_1CD50D36C((char *)__dst);
        unsigned int v64 = v591;
        uint64_t v75 = v587;
        BOOL v177 = v613;
        uint64_t v176 = v606;
      }
      unint64_t v186 = (unsigned int *)sub_1CC4861BC(a1 + 264, &v622, v626);
      unsigned int v189 = 0;
      *(_OWORD *)(v186 + 18) = 0u;
      uint64_t v187 = (int *)(v186 + 18);
      *(_OWORD *)(v186 + 42) = 0u;
      uint64_t v190 = v622;
      *(_OWORD *)(v186 + 6) = 0u;
      unint64_t v188 = (uint64_t *)(v186 + 2);
      *(_OWORD *)(v186 + 66) = 0u;
      *(_OWORD *)(v186 + 70) = 0u;
      *(void *)unint64_t v186 = v190;
      *((void *)v186 + 1) = v186 + 6;
      *((void *)v186 + 10) = v186 + 24;
      *(_OWORD *)(v186 + 10) = 0u;
      *(_OWORD *)(v186 + 14) = 0u;
      *(_OWORD *)(v186 + 22) = 0u;
      *(_OWORD *)(v186 + 26) = 0u;
      *(_OWORD *)(v186 + 30) = 0u;
      *(_OWORD *)(v186 + 34) = 0u;
      *(_OWORD *)(v186 + 38) = 0u;
      *(_OWORD *)(v186 + 46) = 0u;
      *(_OWORD *)(v186 + 50) = 0u;
      *(_OWORD *)(v186 + 54) = 0u;
      *(_OWORD *)(v186 + 58) = 0u;
      *(_OWORD *)(v186 + 62) = 0u;
      *((void *)v186 + 2) = 0x600000000;
      v186[23] = 6;
      *((void *)v186 + 19) = v186 + 42;
      v186[41] = 6;
      *((void *)v186 + 28) = v186 + 60;
      v186[59] = 6;
      goto LABEL_304;
    }
    unsigned int v578 = v665;
    unsigned int v171 = malloc_type_malloc(8 * v665, 0x4065EBACuLL);
    if (v171 || !v578 && (unsigned int v171 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      uint64_t v631 = (uint64_t)v171;
      uint64_t v173 = v663;
      unsigned int v172 = v664;
      goto LABEL_279;
    }
LABEL_994:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
LABEL_241:
  if (v645 != v66) {
    free(v645);
  }
  if (v649 != v65) {
    free(v649);
  }
  if (v652 != v64) {
    free(v652);
  }
  uint64_t v152 = v620[0];
  if (v621)
  {
    uint64_t v153 = 80 * v621;
    uint64_t v154 = v620[0] + 24;
    do
    {
      if ((*(void *)(v154 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v155 = *(void **)(v154 - 16);
        if ((void *)v154 != v155) {
          free(v155);
        }
      }
      v154 += 80;
      v153 -= 80;
    }
    while (v153);
  }
  MEMORY[0x1D25D9CD0](v152, 8);
  uint64_t v156 = *(void *)(a1 + 248);
  uint64_t v157 = *(void *)(v156 + 8);
  unsigned int v158 = *(_DWORD *)(v156 + 32);
  uint64_t v159 = -858993459 * ((unint64_t)(*(void *)(v156 + 16) - v157) >> 3) - v158;
  if ((int)v159 >= 1)
  {
    unsigned int v160 = 0;
    do
    {
      v160 += *(_DWORD *)(v157 + 40 * v158++ + 8);
      --v159;
    }
    while (v159);
    if (v602 >= 2)
    {
      BOOL v161 = v160 >= 0x10 && byte_1EBCD3BF0 == 0;
      if (v161
        && (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, *(llvm::LLVMContextImpl *****)a2) & 1) == 0)
      {
        if (v600) {
          operator new();
        }
        int v220 = 0;
        while (1)
        {
          ++v220;
          uint64_t v221 = *(unsigned int *)(a1 + 320);
          if (!v221) {
            goto LABEL_497;
          }
          int v598 = v220;
          char v607 = 0;
          uint64_t v222 = *(uint64_t **)(a1 + 312);
          unsigned int v603 = &v222[v221];
          do
          {
            size_t v614 = v222;
            uint64_t v223 = *v222;
            int v655 = 0;
            if (sub_1CC486124(*(void *)(a1 + 264), *(_DWORD *)(a1 + 280), v223, &v655)) {
              int v224 = (unsigned int *)v655;
            }
            else {
              int v224 = (unsigned int *)(*(void *)(a1 + 264) + 296 * *(unsigned int *)(a1 + 280));
            }
            int v655 = &v657;
            __src = (void *)0x600000000;
            unsigned int v660 = 0;
            int v225 = *(uint64_t **)(v223 + 64);
            uint64_t v226 = *(uint64_t **)(v223 + 72);
            if (v225 == v226)
            {
              unsigned int v227 = 0;
              LODWORD(v228) = 0;
              __dst[0] = &__dst[2];
              __dst[1] = (void *)0x600000000;
            }
            else
            {
              unsigned int v227 = 0;
              uint64_t v228 = 0;
              do
              {
                uint64_t v229 = *v225;
                __dst[0] = 0;
                int v230 = sub_1CC486124(*(void *)(a1 + 264), *(_DWORD *)(a1 + 280), v229, __dst);
                uint64_t v231 = __dst[0];
                if (v230) {
                  BOOL v232 = __dst[0] == (void *)(*(void *)(a1 + 264) + 296 * *(unsigned int *)(a1 + 280));
                }
                else {
                  BOOL v232 = 1;
                }
                if (!v232)
                {
                  uint64_t v233 = *((unsigned int *)__dst[0] + 72);
                  if (v228 < v233)
                  {
                    if ((v228 & 0x3F) != 0) {
                      *((void *)v655 + v227 - 1) &= ~(-1 << (v228 & 0x3F));
                    }
                    unsigned int v660 = v233;
                    unsigned int v238 = v233 + 63;
                    if (v227 != (v233 + 63) >> 6)
                    {
                      uint64_t v239 = v238 >> 6;
                      if (v227 > v239)
                      {
                        LODWORD(__src) = v238 >> 6;
                        unsigned int v227 = v238 >> 6;
                      }
                      else
                      {
                        if (v239 > HIDWORD(__src)) {
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        if (v239 != v227) {
                          bzero((char *)v655 + 8 * v227, 8 * (v239 - v227));
                        }
                        unsigned int v227 = v239;
                        LODWORD(__src) = v239;
                        uint64_t v233 = v660;
                      }
                    }
                    if ((v233 & 0x3F) != 0) {
                      *((void *)v655 + v227 - 1) &= ~(-1 << (v233 & 0x3F));
                    }
                  }
                  else
                  {
                    uint64_t v233 = v228;
                  }
                  uint64_t v234 = *((unsigned int *)v231 + 58);
                  if (v234)
                  {
                    uint64_t v235 = (uint64_t *)v231[28];
                    int v236 = v655;
                    do
                    {
                      uint64_t v237 = *v235++;
                      *v236++ |= v237;
                      --v234;
                    }
                    while (v234);
                  }
                  uint64_t v228 = v233;
                }
                ++v225;
              }
              while (v225 != v226);
              __dst[0] = &__dst[2];
              __dst[1] = (void *)0x600000000;
              if (v227)
              {
                if (v227 >= 7) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                memcpy(&__dst[2], v655, 8 * v227);
                LODWORD(__dst[1]) = v227;
                LODWORD(v228) = v660;
              }
            }
            unsigned int v641 = v228;
            LODWORD(v240) = v224[22];
            if (v240 >= v227) {
              uint64_t v240 = v227;
            }
            else {
              uint64_t v240 = v240;
            }
            if (v240)
            {
              uint64_t v241 = (uint64_t *)*((void *)v224 + 10);
              uint64_t v242 = __dst[0];
              do
              {
                uint64_t v243 = *v241++;
                *v242++ &= ~v243;
                --v240;
              }
              while (v240);
            }
            unsigned int v244 = v224[18];
            if (v228 < v244)
            {
              if ((v228 & 0x3F) != 0) {
                *((void *)__dst[0] + v227 - 1) &= ~(-1 << (v228 & 0x3F));
              }
              unsigned int v641 = v244;
              unsigned int v285 = v244 + 63;
              if (v227 != (v244 + 63) >> 6)
              {
                uint64_t v286 = v285 >> 6;
                if (v227 > v286)
                {
                  LODWORD(__dst[1]) = v285 >> 6;
                  unsigned int v227 = v285 >> 6;
                }
                else
                {
                  if (v286 > HIDWORD(__dst[1])) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v286 != v227) {
                    bzero((char *)__dst[0] + 8 * v227, 8 * (v286 - v227));
                  }
                  unsigned int v227 = v286;
                  LODWORD(__dst[1]) = v286;
                  LOBYTE(v244) = v641;
                }
              }
              int v287 = v244 & 0x3F;
              if (v287) {
                *((void *)__dst[0] + v227 - 1) &= ~(-1 << v287);
              }
            }
            uint64_t v245 = v224[4];
            if (v245)
            {
              size_t v246 = (uint64_t *)*((void *)v224 + 1);
              unint64_t v247 = __dst[0];
              do
              {
                uint64_t v248 = *v246++;
                *v247++ |= v248;
                --v245;
              }
              while (v245);
            }
            unsigned int v249 = (uint64_t **)(v224 + 38);
            uint64_t v250 = v224[40];
            if (v250 >= __src) {
              uint64_t v251 = __src;
            }
            else {
              uint64_t v251 = v250;
            }
            if (v251)
            {
              uint64_t v252 = (uint64_t *)v655;
              uint64_t v253 = *v249;
              uint64_t v254 = v251;
              while (1)
              {
                uint64_t v256 = *v252++;
                uint64_t v255 = v256;
                uint64_t v257 = *v253++;
                if ((v255 & ~v257) != 0) {
                  break;
                }
                if (!--v254) {
                  goto LABEL_429;
                }
              }
            }
            else
            {
LABEL_429:
              if (__src <= v250) {
                goto LABEL_448;
              }
              while (!*((void *)v655 + v251))
              {
                LODWORD(v251) = v251 + 1;
                if (__src == v251) {
                  goto LABEL_448;
                }
              }
            }
            unsigned int v258 = v660;
            if (v224[54] < v660)
            {
              int v259 = v224[54] & 0x3F;
              if (v259) {
                (*v249)[v250 - 1] &= ~(-1 << v259);
              }
              v224[54] = v258;
              unsigned int v260 = v258 + 63;
              if (v250 != (v258 + 63) >> 6)
              {
                uint64_t v261 = v260 >> 6;
                if (v250 > v261)
                {
                  v224[40] = v261;
                  LODWORD(v250) = v260 >> 6;
                }
                else
                {
                  if (v261 > v224[41]) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v261 != v250) {
                    bzero(&(*v249)[v250], 8 * (v261 - v250));
                  }
                  LODWORD(v250) = v261;
                  v224[40] = v261;
                  unsigned int v258 = v224[54];
                }
              }
              int v262 = v258 & 0x3F;
              if (v262) {
                (*v249)[v250 - 1] &= ~(-1 << v262);
              }
            }
            uint64_t v263 = __src;
            if (__src)
            {
              uint64_t v264 = (uint64_t *)v655;
              int v265 = *v249;
              do
              {
                uint64_t v266 = *v264++;
                *v265++ |= v266;
                --v263;
              }
              while (v263);
            }
            char v607 = 1;
LABEL_448:
            uint64_t v267 = (uint64_t **)(v224 + 56);
            uint64_t v268 = v224[58];
            if (v268 >= LODWORD(__dst[1])) {
              uint64_t v269 = LODWORD(__dst[1]);
            }
            else {
              uint64_t v269 = v268;
            }
            uint64_t v270 = (void **)__dst[0];
            if (v269)
            {
              uint64_t v271 = *v267;
              uint64_t v272 = v269;
              uint64_t v273 = (uint64_t *)__dst[0];
              while (1)
              {
                uint64_t v275 = *v273++;
                uint64_t v274 = v275;
                uint64_t v276 = *v271++;
                if ((v274 & ~v276) != 0) {
                  break;
                }
                if (!--v272) {
                  goto LABEL_455;
                }
              }
            }
            else
            {
LABEL_455:
              if (LODWORD(__dst[1]) <= v268) {
                goto LABEL_474;
              }
              while (!*((void *)__dst[0] + v269))
              {
                LODWORD(v269) = v269 + 1;
                if (LODWORD(__dst[1]) == v269) {
                  goto LABEL_474;
                }
              }
            }
            unsigned int v277 = v641;
            if (v224[72] < v641)
            {
              int v278 = v224[72] & 0x3F;
              if (v278) {
                (*v267)[v268 - 1] &= ~(-1 << v278);
              }
              v224[72] = v277;
              unsigned int v279 = v277 + 63;
              if (v268 != (v277 + 63) >> 6)
              {
                uint64_t v280 = v279 >> 6;
                if (v268 > v280)
                {
                  v224[58] = v280;
                  LODWORD(v268) = v279 >> 6;
                }
                else
                {
                  if (v280 > v224[59]) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  if (v280 != v268) {
                    bzero(&(*v267)[v268], 8 * (v280 - v268));
                  }
                  LODWORD(v268) = v280;
                  v224[58] = v280;
                  unsigned int v277 = v224[72];
                }
              }
              int v281 = v277 & 0x3F;
              if (v281) {
                (*v267)[v268 - 1] &= ~(-1 << v281);
              }
            }
            uint64_t v270 = (void **)__dst[0];
            if (LODWORD(__dst[1]))
            {
              unint64_t v282 = 0;
              int v283 = *v267;
              uint64_t v284 = 8 * LODWORD(__dst[1]);
              do
              {
                v283[v282 / 8] |= (unint64_t)v270[v282 / 8];
                v282 += 8;
              }
              while (v284 != v282);
            }
            char v607 = 1;
LABEL_474:
            if (v270 != &__dst[2]) {
              free(v270);
            }
            if (v655 != &v657) {
              free(v655);
            }
            uint64_t v222 = v614 + 1;
          }
          while (v614 + 1 != v603);
          int v220 = v598;
          if ((v607 & 1) == 0)
          {
LABEL_497:
            *(_DWORD *)(a1 + 1720) = v220;
            int v655 = &v657;
            __src = (void *)0x1000000000;
            __dst[0] = &__dst[3];
            *(_OWORD *)&__dst[1] = xmmword_1CDB15990;
            uint64_t v288 = *(void *)(a1 + 256);
            uint64_t v289 = *(void *)(v288 + 328);
            uint64_t v608 = v288 + 320;
            if (v289 == v288 + 320) {
              goto LABEL_582;
            }
            uint64_t v290 = a1 + 264;
            while (2)
            {
              LODWORD(__src) = 0;
              sub_1CD42769C((uint64_t)&v655, v600);
              __dst[1] = 0;
              int v649 = (void *)v289;
              size_t v630 = 0;
              if (sub_1CC486124(*(void *)(a1 + 264), *(_DWORD *)(a1 + 280), v289, &v630))
              {
                int v291 = *((_DWORD *)v630 + 54);
                if (v291)
                {
                  uint64_t v292 = 0;
                  uint64_t v293 = (v291 - 1) >> 6;
                  uint64_t v294 = (uint64_t *)*((void *)v630 + 19);
                  uint64_t v295 = v293 << 6;
                  unint64_t v296 = v294;
                  while (1)
                  {
                    uint64_t v298 = *v296++;
                    uint64_t v297 = v298;
                    unint64_t v299 = v295 + v292 ? -1 : 0xFFFFFFFFFFFFFFFFLL >> -(char)v291;
                    unint64_t v300 = v299 & v297;
                    if (v300) {
                      break;
                    }
                    v292 -= 64;
                    if (v295 + v292 == -64) {
                      goto LABEL_510;
                    }
                  }
                  int v302 = __clz(__rbit64(v300));
                  if (v302 + 1 != v292)
                  {
                    int v330 = v302 - v292;
                    unint64_t v331 = (void *)(*(void *)(*(void *)(a1 + 1416) + 392) + 16 * *(unsigned int *)(v289 + 24));
                    unsigned int v332 = v655;
                    do
                    {
                      v332[v330] = *v331;
                      unsigned int v333 = v330 + 1;
                      if (v330 + 1 == v291) {
                        break;
                      }
                      unsigned int v334 = v333 >> 6;
                      if (v333 >> 6 > v293) {
                        break;
                      }
                      uint64_t v335 = 0;
                      int v336 = v333 & 0x3F;
                      BOOL v84 = v336 == 0;
                      unint64_t v337 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v336;
                      uint64_t v338 = v84 ? -1 : ~v337;
                      int v339 = v334 << 6;
                      uint64_t v340 = v293 - v334;
                      BOOL v341 = &v294[v334];
                      while (1)
                      {
                        uint64_t v342 = v335 ? -1 : v338;
                        unint64_t v343 = v340 == v335 ? 0xFFFFFFFFFFFFFFFFLL >> -(char)v291 : -1;
                        unint64_t v344 = v342 & v343 & v341[v335];
                        if (v344) {
                          break;
                        }
                        v339 += 64;
                        if (v340 + 1 == ++v335) {
                          goto LABEL_510;
                        }
                      }
                      int v330 = __clz(__rbit64(v344)) + v339;
                    }
                    while (v330 != -1);
                  }
                }
              }
              else
              {
                unint64_t v301 = sub_1CC4861BC(v290, (uint64_t *)&v649, v630);
                *(_OWORD *)(v301 + 5) = 0u;
                *(_OWORD *)(v301 + 7) = 0u;
                *(_OWORD *)(v301 + 9) = 0u;
                *(_OWORD *)(v301 + 11) = 0u;
                *(_OWORD *)(v301 + 13) = 0u;
                *(_OWORD *)(v301 + 15) = 0u;
                *(_OWORD *)(v301 + 17) = 0u;
                *(_OWORD *)(v301 + 19) = 0u;
                *(_OWORD *)(v301 + 23) = 0u;
                *(_OWORD *)(v301 + 25) = 0u;
                *(_OWORD *)(v301 + 27) = 0u;
                *(_OWORD *)(v301 + 29) = 0u;
                *(_OWORD *)(v301 + 33) = 0u;
                *(_OWORD *)(v301 + 35) = 0u;
                *(_OWORD *)(v301 + 21) = 0u;
                *(_OWORD *)(v301 + 3) = 0u;
                *(_OWORD *)(v301 + 31) = 0u;
                *unint64_t v301 = v289;
                v301[1] = v301 + 3;
                v301[2] = 0x600000000;
                v301[10] = v301 + 12;
                *((_DWORD *)v301 + 23) = 6;
                v301[19] = v301 + 21;
                *((_DWORD *)v301 + 41) = 6;
                v301[28] = v301 + 30;
                *((_DWORD *)v301 + 59) = 6;
              }
LABEL_510:
              uint64_t v303 = v289 + 48;
              uint64_t v615 = v289;
              uint64_t v304 = *(void *)(v289 + 56);
              while (2)
              {
                if (v304 != v303)
                {
                  size_t v630 = &v632;
                  uint64_t v631 = 0x400000000;
                  LOBYTE(v649) = 0;
                  if (sub_1CC485ED4(a1, v304, (uint64_t)&v630, (char *)&v649))
                  {
                    __int16 v305 = *(_WORD *)(v304 + 44);
                    unint64_t v306 = v304;
                    if ((v305 & 4) != 0)
                    {
                      do
                        unint64_t v306 = *(void *)v306 & 0xFFFFFFFFFFFFFFF8;
                      while ((*(_WORD *)(v306 + 44) & 4) != 0);
                    }
                    uint64_t v307 = v304;
                    if ((v305 & 8) != 0)
                    {
                      do
                        uint64_t v307 = *(void *)(v307 + 8);
                      while ((*(_WORD *)(v307 + 44) & 8) != 0);
                    }
                    unint64_t v308 = *(void *)(v307 + 8);
                    if (v306 != v308)
                    {
                      while (1)
                      {
                        unsigned int v309 = **(unsigned __int16 **)(v306 + 16);
                        BOOL v310 = v309 > 0x17;
                        int v311 = (1 << v309) & 0x83E000;
                        if (v310 || v311 == 0) {
                          break;
                        }
                        unint64_t v306 = *(void *)(v306 + 8);
                        if (v306 == v308)
                        {
                          unint64_t v306 = v308;
                          break;
                        }
                      }
                    }
                    uint64_t v313 = *(void *)(a1 + 1416);
                    uint64_t v314 = *(void *)(v313 + 368);
                    uint64_t v315 = *(unsigned int *)(v313 + 384);
                    if (v315)
                    {
                      LODWORD(v316) = ((v306 >> 4) ^ (v306 >> 9)) & (v315 - 1);
                      unsigned int v317 = (uint64_t *)(v314 + 16 * v316);
                      uint64_t v318 = *v317;
                      if (v306 != *v317)
                      {
                        int v319 = 1;
                        while (v318 != -4096)
                        {
                          int v320 = v316 + v319++;
                          uint64_t v316 = v320 & (v315 - 1);
                          uint64_t v318 = *(void *)(v314 + 16 * v316);
                          if (v306 == v318)
                          {
                            unsigned int v317 = (uint64_t *)(v314 + 16 * v316);
                            goto LABEL_529;
                          }
                        }
                        goto LABEL_528;
                      }
                    }
                    else
                    {
LABEL_528:
                      unsigned int v317 = (uint64_t *)(v314 + 16 * v315);
                    }
LABEL_529:
                    if (v631)
                    {
                      uint64_t v321 = v317[1];
                      uint64_t v322 = (int *)v630;
                      uint64_t v323 = 4 * v631;
                      int v324 = v649;
                      do
                      {
                        uint64_t v325 = *v322;
                        if (v324)
                        {
                          if (!*((unsigned char *)__dst[0] + v325))
                          {
                            uint64_t v326 = *v610 + 48 * (int)v325;
                            unint64_t v327 = *(unsigned int *)(v326 + 8);
                            if (v327 >= *(unsigned int *)(v326 + 12)) {
                              llvm::SmallVectorBase<unsigned int>::grow_pod();
                            }
                            *(void *)(*(void *)v326 + 8 * v327) = v321;
                            ++*(_DWORD *)(v326 + 8);
                            *((unsigned char *)__dst[0] + v325) = 1;
                          }
                          if (*((void *)v655 + v325) <= 7uLL) {
                            *((void *)v655 + v325) = v321;
                          }
                        }
                        else if (*((void *)v655 + v325) >= 8uLL)
                        {
                          uint64_t v328 = *(void *)(*v617 + 8 * v325);
                          uint64_t v329 = **(void **)(v328 + 64);
                          v626 = (void *)*((void *)v655 + v325);
                          uint64_t v627 = v321;
                          v628[0] = v329;
                          llvm::LiveRange::addSegment(v328, (uint64_t)&v626);
                          *((void *)v655 + v325) = 0;
                          *((unsigned char *)__dst[0] + v325) = 0;
                        }
                        ++v322;
                        v323 -= 4;
                      }
                      while (v323);
                    }
                  }
                  if (v630 != &v632) {
                    free(v630);
                  }
                  if ((*(unsigned char *)v304 & 4) == 0)
                  {
                    while ((*(_WORD *)(v304 + 44) & 8) != 0)
                      uint64_t v304 = *(void *)(v304 + 8);
                  }
                  uint64_t v304 = *(void *)(v304 + 8);
                  continue;
                }
                break;
              }
              uint64_t v290 = a1 + 264;
              uint64_t v289 = *(void *)(v615 + 8);
              if (v289 != v608) {
                continue;
              }
              break;
            }
            if (__dst[0] != &__dst[3]) {
              free(__dst[0]);
            }
LABEL_582:
            if (v655 != &v657) {
              free(v655);
            }
            if (byte_1EBCD3CB0)
            {
              uint64_t v347 = (uint64_t)(*v599 + 40);
              uint64_t v348 = (*v599)[41];
              if (v348 != v347)
              {
LABEL_586:
                for (unint64_t i = *(void *)(v348 + 56); ; unint64_t i = *(void *)(i + 8))
                {
                  if (i == v348 + 48)
                  {
                    uint64_t v348 = *(void *)(v348 + 8);
                    if (v348 == v347) {
                      break;
                    }
                    goto LABEL_586;
                  }
                  unsigned int v350 = *(unsigned __int16 **)(i + 16);
                  int v351 = *v350;
                  BOOL v352 = (v351 - 13) >= 5 && (v351 - 21) >= 2;
                  if (!v352) {
                    goto LABEL_639;
                  }
                  unsigned int v353 = v351 - 1;
                  if (v353 <= 1 && (*(unsigned char *)(*(void *)(i + 32) + 48) & 8) != 0) {
                    goto LABEL_602;
                  }
                  unsigned int v354 = *(unsigned __int16 *)(i + 44);
                  BOOL v84 = (v354 & 0xC) == 0;
                  int v355 = (v354 >> 2) & 1;
                  if (v84) {
                    LOBYTE(v355) = 1;
                  }
                  uint64_t v356 = *((void *)v350 + 1);
                  if (v355)
                  {
                    if ((v356 & 0x80000) == 0) {
                      goto LABEL_599;
                    }
                  }
                  else
                  {
                    unint64_t v385 = i;
                    if ((v356 & 0x80000) == 0)
                    {
                      while ((*(_WORD *)(v385 + 44) & 8) != 0)
                      {
                        unint64_t v385 = *(void *)(v385 + 8);
                        if ((*(unsigned char *)(*(void *)(v385 + 16) + 10) & 8) != 0) {
                          goto LABEL_602;
                        }
                      }
LABEL_599:
                      if (v353 > 1 || (*(unsigned char *)(*(void *)(i + 32) + 48) & 0x10) == 0)
                      {
                        if (v355)
                        {
                          if ((v356 & 0x100000) == 0) {
                            goto LABEL_639;
                          }
                        }
                        else
                        {
                          unint64_t v386 = i;
                          if ((v356 & 0x100000) == 0)
                          {
                            while ((*(_WORD *)(v386 + 44) & 8) != 0)
                            {
                              unint64_t v386 = *(void *)(v386 + 8);
                              if ((*(unsigned char *)(*(void *)(v386 + 16) + 10) & 0x10) != 0) {
                                goto LABEL_602;
                              }
                            }
LABEL_639:
                            if ((*(unsigned char *)i & 4) == 0) {
                              goto LABEL_642;
                            }
                            continue;
                          }
                        }
                      }
                    }
                  }
LABEL_602:
                  uint64_t v357 = *(unsigned int *)(i + 40);
                  if (!v357) {
                    goto LABEL_639;
                  }
                  uint64_t v358 = *(void *)(i + 32);
                  uint64_t v359 = v358 + 32 * v357;
                  do
                  {
                    if (*(unsigned char *)v358 != 5) {
                      goto LABEL_632;
                    }
                    uint64_t v360 = *(unsigned int *)(v358 + 16);
                    if ((v360 & 0x80000000) != 0) {
                      goto LABEL_632;
                    }
                    int32x2_t v361 = *(uint64_t **)(*v617 + 8 * v360);
                    unint64_t v362 = *((unsigned int *)v361 + 2);
                    if (!v362) {
                      goto LABEL_632;
                    }
                    __int16 v363 = *(_WORD *)(i + 44);
                    unint64_t v364 = i;
                    if ((v363 & 4) != 0)
                    {
                      do
                        unint64_t v364 = *(void *)v364 & 0xFFFFFFFFFFFFFFF8;
                      while ((*(_WORD *)(v364 + 44) & 4) != 0);
                    }
                    unint64_t v365 = i;
                    if ((v363 & 8) != 0)
                    {
                      do
                        unint64_t v365 = *(void *)(v365 + 8);
                      while ((*(_WORD *)(v365 + 44) & 8) != 0);
                    }
                    unint64_t v366 = *(void *)(v365 + 8);
                    if (v364 != v366)
                    {
                      while (1)
                      {
                        unsigned int v367 = **(unsigned __int16 **)(v364 + 16);
                        BOOL v310 = v367 > 0x17;
                        int v368 = (1 << v367) & 0x83E000;
                        if (v310 || v368 == 0) {
                          break;
                        }
                        unint64_t v364 = *(void *)(v364 + 8);
                        if (v364 == v366)
                        {
                          unint64_t v364 = v366;
                          break;
                        }
                      }
                    }
                    uint64_t v370 = *(void *)(a1 + 1416);
                    uint64_t v371 = *(void *)(v370 + 368);
                    uint64_t v372 = *(unsigned int *)(v370 + 384);
                    if (!v372) {
                      goto LABEL_622;
                    }
                    LODWORD(v373) = ((v364 >> 4) ^ (v364 >> 9)) & (v372 - 1);
                    uint64_t v374 = (uint64_t *)(v371 + 16 * v373);
                    uint64_t v375 = *v374;
                    if (v364 != *v374)
                    {
                      int v376 = 1;
                      while (v375 != -4096)
                      {
                        int v377 = v373 + v376++;
                        uint64_t v373 = v377 & (v372 - 1);
                        uint64_t v375 = *(void *)(v371 + 16 * v373);
                        if (v364 == v375)
                        {
                          uint64_t v374 = (uint64_t *)(v371 + 16 * v373);
                          goto LABEL_623;
                        }
                      }
LABEL_622:
                      uint64_t v374 = (uint64_t *)(v371 + 16 * v372);
                    }
LABEL_623:
                    uint64_t v378 = *v361;
                    uint64_t v379 = *v361 + 24 * v362;
                    unsigned int v380 = *(_DWORD *)((v374[1] & 0xFFFFFFFFFFFFFFF8) + 24) | (v374[1] >> 1) & 3;
                    if (v380 >= ((*(void *)(v379 - 16) >> 1) & 3 | *(_DWORD *)((*(void *)(v379 - 16) & 0xFFFFFFFFFFFFFFF8)
                                                                                              + 24)))
                      goto LABEL_631;
                    do
                    {
                      unint64_t v381 = v362 >> 1;
                      uint64_t v382 = *(void *)(v378 + 24 * (v362 >> 1) + 8);
                      LODWORD(v382) = (v382 >> 1) & 3 | *(_DWORD *)((v382 & 0xFFFFFFFFFFFFFFF8) + 24);
                      v362 -= (v362 >> 1) + 1;
                      BOOL v383 = v380 >= v382;
                      if (v380 >= v382) {
                        unint64_t v384 = v381 + 1;
                      }
                      else {
                        unint64_t v384 = 0;
                      }
                      v378 += 24 * v384;
                      if (!v383) {
                        unint64_t v362 = v381;
                      }
                    }
                    while (v362);
                    if (v378 == v379)
                    {
LABEL_631:
                      *((_DWORD *)v361 + 18) = 0;
                      *((_DWORD *)v361 + 2) = 0;
                    }
LABEL_632:
                    v358 += 32;
                  }
                  while (v358 != v359);
                  if (i) {
                    goto LABEL_639;
                  }
LABEL_642:
                  while ((*(_WORD *)(i + 44) & 8) != 0)
                    unint64_t i = *(void *)(i + 8);
                }
              }
            }
            uint64_t v650 = 0;
            int v649 = 0;
            v651[0] = 0;
            unint64_t v387 = (int *)v623;
            unint64_t v388 = v624;
            unint64_t v389 = (int *)((char *)v623 + 4 * v624);
            int v655 = (void *)a1;
            if (v624 < 0x81)
            {
LABEL_661:
              sub_1CC4866DC(v387, v389, (uint64_t *)&v655, v388, 0, 0);
            }
            else
            {
              unint64_t v390 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
              unint64_t v391 = v624;
              while (1)
              {
                uint64_t v392 = (int *)operator new(4 * v391, v390);
                if (v392) {
                  break;
                }
                BOOL v310 = v391 > 1;
                v391 >>= 1;
                if (!v310) {
                  goto LABEL_661;
                }
              }
              unint64_t v393 = v392;
              sub_1CC4866DC(v387, v389, (uint64_t *)&v655, v388, v392, v391);
              operator delete(v393);
            }
            uint64_t v394 = *(unsigned int *)(a1 + 544);
            if (v394)
            {
              uint64_t v395 = 48 * v394;
              uint64_t v396 = (void **)(*(void *)(a1 + 536) + 8);
              do
              {
                size_t v397 = *(unsigned int *)v396;
                if (v397 >= 2) {
                  qsort(*(v396 - 1), v397, 8uLL, (int (__cdecl *)(const void *, const void *))sub_1CBB24DA4);
                }
                v396 += 6;
                v395 -= 48;
              }
              while (v395);
            }
            uint64_t v398 = *((unsigned int *)*v599 + 194);
            if (v398)
            {
              uint64_t v401 = (*v599)[96];
              uint64_t v402 = v401 + 32 * v398;
              do
              {
                if (*(void *)v401 && v651[0])
                {
                  int v403 = *(_DWORD *)(v401 + 16);
                  unsigned int v404 = (37 * v403) & (v651[0] - 1);
                  int v405 = *((_DWORD *)v649 + 2 * v404);
                  if (v403 == v405)
                  {
LABEL_678:
                    *(_DWORD *)(v401 + 16) = sub_1CD542EA8((uint64_t)&v649, (_DWORD *)(v401 + 16))[1];
                  }
                  else
                  {
                    int v406 = 1;
                    while (v405 != 0x7FFFFFFF)
                    {
                      unsigned int v407 = v404 + v406++;
                      unsigned int v404 = v407 & (v651[0] - 1);
                      int v405 = *((_DWORD *)v649 + 2 * v404);
                      if (v403 == v405) {
                        goto LABEL_678;
                      }
                    }
                  }
                }
                v401 += 32;
              }
              while (v401 != v402);
            }
            v626 = 0;
            uint64_t v627 = 0;
            LODWORD(v628[0]) = 0;
            int v655 = v659;
            __src = v659;
            int v657 = (llvm::Type *)32;
            int v658 = 0;
            uint64_t v399 = (char *)v649 + 8 * v651[0];
            if (v650)
            {
              if (v651[0])
              {
                uint64_t v576 = 8 * v651[0];
                unint64_t v400 = (char *)v649;
                while ((*(_DWORD *)v400 - 0x7FFFFFFF) <= 1)
                {
                  v400 += 8;
                  v576 -= 8;
                  if (!v576) {
                    goto LABEL_673;
                  }
                }
              }
              else
              {
                unint64_t v400 = (char *)v649;
              }
            }
            else
            {
LABEL_673:
              unint64_t v400 = (char *)v649 + 8 * v651[0];
            }
            v408 = (char *)v649 + 8 * v651[0];
            if (v400 == v408)
            {
LABEL_688:
              sub_1CD45F678(&v652, (int)(-858993459* ((*(void *)(*(void *)(a1 + 248) + 16) - *(void *)(*(void *)(a1 + 248) + 8)) >> 3)- *(_DWORD *)(*(void *)(a1 + 248) + 32)));
              uint64_t v409 = *(void *)(a1 + 256);
              uint64_t v410 = *(void *)(v409 + 328);
              uint64_t v601 = v409 + 320;
              if (v410 == v409 + 320)
              {
LABEL_824:
                int v485 = (unint64_t ***)v652;
                uint64_t v486 = v653;
                if (v652 != v653)
                {
                  int v487 = 0;
                  do
                  {
                    if (*v485 != v485[1])
                    {
                      unint64_t v488 = (uint64_t **)(*v599)[54];
                      LODWORD(__dst[0]) = v487;
                      int v489 = sub_1CD53E7FC((uint64_t *)&v649, __dst);
                      FixedStacuint64_t k = llvm::PseudoSourceValueManager::getFixedStack(v488, v489[1]);
                      int v491 = *v485;
                      int v492 = v485[1];
                      if (*v485 != v492)
                      {
                        do
                        {
                          int v493 = *v491++;
                          *int v493 = (unint64_t)FixedStack | 4;
                        }
                        while (v491 != v492);
                      }
                    }
                    v485 += 3;
                    ++v487;
                  }
                  while (v485 != v486);
                }
                uint64_t v494 = (*v599)[12];
                if (v494)
                {
                  uint64_t v495 = *(unsigned int *)(v494 + 184);
                  if (v495)
                  {
                    uint64_t v496 = *(void *)(v494 + 176);
                    uint64_t v497 = v496 + (v495 << 6);
                    do
                    {
                      uint64_t v498 = *(unsigned int *)(v496 + 24);
                      if (v498)
                      {
                        uint64_t v499 = *(void *)(v496 + 16);
                        uint64_t v500 = v499 + 32 * v498;
                        do
                        {
                          int v501 = *(_DWORD *)(v499 + 8);
                          if (v501 != 0x7FFFFFFF && v651[0])
                          {
                            unsigned int v502 = (v651[0] - 1) & (37 * v501);
                            int v503 = *((_DWORD *)v649 + 2 * v502);
                            if (v501 == v503)
                            {
LABEL_840:
                              *(_DWORD *)(v499 + 8) = sub_1CD542EA8((uint64_t)&v649, (_DWORD *)(v499 + 8))[1];
                            }
                            else
                            {
                              int v504 = 1;
                              while (v503 != 0x7FFFFFFF)
                              {
                                unsigned int v505 = v502 + v504++;
                                unsigned int v502 = v505 & (v651[0] - 1);
                                int v503 = *((_DWORD *)v649 + 2 * v502);
                                if (v501 == v503) {
                                  goto LABEL_840;
                                }
                              }
                            }
                          }
                          v499 += 32;
                        }
                        while (v499 != v500);
                      }
                      v496 += 64;
                    }
                    while (v496 != v497);
                  }
                }
                size_t v506 = (unint64_t ***)v652;
                if (v652)
                {
                  uint64_t v507 = v653;
                  uint64_t v508 = v652;
                  if (v653 != v652)
                  {
                    uint64_t v509 = v653;
                    do
                    {
                      uint64_t v511 = *(v509 - 3);
                      v509 -= 3;
                      uint64_t v510 = v511;
                      if (v511)
                      {
                        *(v507 - 2) = v510;
                        operator delete(v510);
                      }
                      uint64_t v507 = v509;
                    }
                    while (v509 != v506);
                    uint64_t v508 = v652;
                  }
                  unint64_t v653 = v506;
                  operator delete(v508);
                }
                if (__src != v655) {
                  free(__src);
                }
                MEMORY[0x1D25D9CD0](v626, 8);
                uint64_t v162 = *(unsigned int *)(a1 + 1432);
                if (v162)
                {
                  uint64_t v512 = *(llvm::MachineInstr ***)(a1 + 1424);
                  uint64_t v513 = 8 * v162;
                  do
                  {
                    uint64_t v514 = *v512++;
                    llvm::MachineInstr::eraseFromParent(v514);
                    v513 -= 8;
                  }
                  while (v513);
                }
                *(_DWORD *)(a1 + 1432) = 0;
                MEMORY[0x1D25D9CD0](v649, 4);
                goto LABEL_267;
              }
              while (1)
              {
                uint64_t v411 = v410 + 48;
                uint64_t v412 = *(void *)(v410 + 56);
                uint64_t v618 = v410 + 48;
                if (v412 != v410 + 48) {
                  break;
                }
LABEL_823:
                uint64_t v410 = *(void *)(v410 + 8);
                if (v410 == v601) {
                  goto LABEL_824;
                }
              }
              while (2)
              {
                if (**(unsigned __int16 **)(v412 + 16) - 21 < 2) {
                  goto LABEL_733;
                }
                uint64_t v414 = (uint64_t *)(v412 + 48);
                unint64_t v413 = *(void *)(v412 + 48);
                if (v413 >= 8)
                {
                  if ((v413 & 7) != 0)
                  {
                    unint64_t v415 = (int *)(v413 & 0xFFFFFFFFFFFFFFF8);
                    if ((*(void *)(v412 + 48) & 7) == 3 && v415 != 0)
                    {
                      uint64_t v419 = *v415;
                      unint64_t v418 = (unint64_t **)(v415 + 2);
                      uint64_t v417 = v419;
                      if (v419)
                      {
                        int v420 = &v418[v417];
                        goto LABEL_704;
                      }
                    }
                  }
                  else
                  {
                    *(void *)(v412 + 48) = v413 & 0xFFFFFFFFFFFFFFF8;
                    int v420 = (unint64_t **)(v412 + 56);
                    unint64_t v418 = (unint64_t **)(v412 + 48);
                    do
                    {
LABEL_704:
                      BOOL v425 = *v418;
                      unint64_t v426 = **v418;
                      if ((v426 & 4) == 0)
                      {
                        size_t v427 = (unsigned char *)(v426 & 0xFFFFFFFFFFFFFFF8);
                        if (v427)
                        {
                          if (v427[16] == 59)
                          {
                            __dst[0] = v427;
                            if (LODWORD(v628[0]))
                            {
                              unsigned int v423 = (LODWORD(v628[0]) - 1) & ((v427 >> 4) ^ (v427 >> 9));
                              uint64_t v424 = (unsigned char *)*((void *)v626 + 2 * v423);
                              if (v424 == v427)
                              {
LABEL_709:
                                unint64_t *v425 = sub_1CD467E2C((uint64_t)&v626, (uint64_t *)__dst)[1] & 0xFFFFFFFFFFFFFFFBLL;
                              }
                              else
                              {
                                int v421 = 1;
                                while (v424 != (unsigned char *)-4096)
                                {
                                  unsigned int v422 = v423 + v421++;
                                  unsigned int v423 = v422 & (LODWORD(v628[0]) - 1);
                                  uint64_t v424 = (unsigned char *)*((void *)v626 + 2 * v423);
                                  if (v424 == v427) {
                                    goto LABEL_709;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      ++v418;
                    }
                    while (v418 != v420);
                  }
                }
                uint64_t v428 = *(unsigned int *)(v412 + 40);
                if (v428)
                {
                  uint64_t v429 = *(void *)(v412 + 32);
                  uint64_t v430 = v429 + 32 * v428;
                  do
                  {
                    if (*(unsigned char *)v429 == 5)
                    {
                      int v431 = *(_DWORD *)(v429 + 16);
                      LODWORD(__dst[0]) = v431;
                      if ((v431 & 0x80000000) == 0)
                      {
                        if (v651[0])
                        {
                          unsigned int v432 = (v651[0] - 1) & (37 * v431);
                          int v433 = *((_DWORD *)v649 + 2 * v432);
                          if (v431 == v433)
                          {
LABEL_717:
                            *(_DWORD *)(v429 + 16) = sub_1CD542EA8((uint64_t)&v649, __dst)[1];
                          }
                          else
                          {
                            int v434 = 1;
                            while (v433 != 0x7FFFFFFF)
                            {
                              unsigned int v435 = v432 + v434++;
                              unsigned int v432 = v435 & (v651[0] - 1);
                              int v433 = *((_DWORD *)v649 + 2 * v432);
                              if (v431 == v433) {
                                goto LABEL_717;
                              }
                            }
                          }
                        }
                      }
                    }
                    v429 += 32;
                  }
                  while (v429 != v430);
                }
                size_t v630 = &v632;
                uint64_t v631 = 0x200000000;
                unint64_t v436 = *v414;
                if ((unint64_t)*v414 < 8) {
                  goto LABEL_732;
                }
                if ((v436 & 7) != 0)
                {
                  int v437 = (int *)(v436 & 0xFFFFFFFFFFFFFFF8);
                  if ((v436 & 7) == 3 && v437 != 0)
                  {
                    uint64_t v440 = *v437;
                    uint64_t v414 = (uint64_t *)(v437 + 2);
                    uint64_t v439 = v440;
                    if (v440)
                    {
                      int v441 = &v414[v439];
                      goto LABEL_736;
                    }
                  }
LABEL_732:
                  uint64_t v411 = v618;
LABEL_733:
                  if ((*(unsigned char *)v412 & 4) != 0)
                  {
LABEL_822:
                    uint64_t v412 = *(void *)(v412 + 8);
                    if (v412 == v411) {
                      goto LABEL_823;
                    }
                    continue;
                  }
                }
                else
                {
                  *(void *)(v412 + 48) = v436 & 0xFFFFFFFFFFFFFFF8;
                  int v441 = (uint64_t *)(v412 + 56);
LABEL_736:
                  char v442 = 0;
LABEL_737:
                  char v616 = v442;
                  do
                  {
                    uint64_t v443 = *v414;
                    uint64_t v444 = *(void *)*v414;
                    if ((v444 & 4) != 0)
                    {
                      unint64_t v445 = v444 & 0xFFFFFFFFFFFFFFF8;
                      if (v445)
                      {
                        if (*(_DWORD *)(v445 + 8) == 4)
                        {
                          LODWORD(__dst[0]) = *(_DWORD *)(v445 + 16);
                          uint64_t v464 = sub_1CD53E7FC((uint64_t *)&v649, __dst);
                          if ((char *)v649 + 8 * v651[0] != (char *)v464)
                          {
                            uint64_t v465 = (char *)v652 + 24 * SLODWORD(__dst[0]);
                            uint64_t v468 = (uint64_t *)*((void *)v465 + 1);
                            uint64_t v467 = v465 + 8;
                            uint64_t v466 = v468;
                            uint64_t v470 = v467 + 1;
                            unint64_t v469 = v467[1];
                            if ((unint64_t)v468 >= v469)
                            {
                              uint64_t v609 = v410;
                              __int16 v472 = (uint64_t **)((char *)v652 + 24 * SLODWORD(__dst[0]));
                              uint64_t v473 = *v472;
                              uint64_t v474 = v466 - *v472;
                              unint64_t v475 = v474 + 1;
                              if ((unint64_t)(v474 + 1) >> 61) {
                                abort();
                              }
                              uint64_t v476 = v469 - (void)v473;
                              if (v476 >> 2 > v475) {
                                unint64_t v475 = v476 >> 2;
                              }
                              BOOL v352 = (unint64_t)v476 >= 0x7FFFFFFFFFFFFFF8;
                              unint64_t v477 = 0x1FFFFFFFFFFFFFFFLL;
                              if (!v352) {
                                unint64_t v477 = v475;
                              }
                              unint64_t v604 = v477;
                              if (v477)
                              {
                                uint64_t v597 = (uint64_t **)((char *)v652 + 24 * SLODWORD(__dst[0]));
                                if (v477 >> 61) {
                                  sub_1CB833614();
                                }
                                uint64_t v478 = (char *)operator new(8 * v477);
                                uint64_t v470 = v467 + 1;
                                __int16 v472 = v597;
                              }
                              else
                              {
                                uint64_t v478 = 0;
                              }
                              unint64_t v479 = (uint64_t *)&v478[8 * v474];
                              *unint64_t v479 = v443;
                              uint64_t v471 = v479 + 1;
                              if (v466 == v473)
                              {
                                unint64_t v480 = v604;
                              }
                              else
                              {
                                unint64_t v480 = v604;
                                do
                                {
                                  uint64_t v481 = *--v466;
                                  *--unint64_t v479 = v481;
                                }
                                while (v466 != v473);
                                uint64_t v466 = *v472;
                              }
                              *__int16 v472 = v479;
                              *uint64_t v467 = v471;
                              *uint64_t v470 = &v478[8 * v480];
                              uint64_t v410 = v609;
                              if (v466) {
                                operator delete(v466);
                              }
                            }
                            else
                            {
                              *uint64_t v466 = v443;
                              uint64_t v471 = v466 + 1;
                            }
                            *uint64_t v467 = v471;
                          }
                        }
                      }
                    }
                    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)(v443 + 40)), (int32x4_t)vceqzq_s64(*(int64x2_t *)(v443 + 56)))))))
                    {
                      uint64_t v446 = *(void *)v443;
                      if ((*(void *)v443 & 4) == 0 && (v446 & 0xFFFFFFFFFFFFFFF8) != 0)
                      {
                        __dst[0] = &__dst[2];
                        __dst[1] = (void *)0x400000000;
                        llvm::getUnderlyingObjectsForCodeGen(v446 & 0xFFFFFFFFFFFFFFF8, (uint64_t)__dst);
                        if (LODWORD(__dst[1]))
                        {
                          int v447 = v657 - 1;
                          v448 = (uint64_t *)__dst[0];
                          while (1)
                          {
                            uint64_t v449 = *v448;
                            if (*v448 && *(unsigned char *)(v449 + 16) == 59)
                            {
                              if (__src == v655)
                              {
                                if (HIDWORD(v657))
                                {
                                  uint64_t v450 = 0;
                                  while (*(void *)((char *)__src + v450) != v449)
                                  {
                                    v450 += 8;
                                    if (8 * HIDWORD(v657) == v450)
                                    {
                                      unsigned int v451 = HIDWORD(v657);
                                      goto LABEL_768;
                                    }
                                  }
                                  uint64_t v460 = (char *)__src + v450;
                                  unsigned int v451 = HIDWORD(v657);
                                  uint64_t v461 = __src;
                                }
                                else
                                {
                                  unsigned int v451 = 0;
LABEL_768:
                                  uint64_t v461 = __src;
                                  uint64_t v460 = (char *)__src + 8 * HIDWORD(v657);
                                }
                              }
                              else
                              {
                                unsigned int v452 = v447 & ((v449 >> 4) ^ (v449 >> 9));
                                int v453 = (char *)__src + 8 * v452;
                                uint64_t v454 = *(void *)v453;
                                if (*(void *)v453 == -1)
                                {
                                  unint64_t v455 = 0;
LABEL_770:
                                  if (v455) {
                                    int v453 = v455;
                                  }
                                  uint64_t v459 = *(void *)v453;
                                }
                                else
                                {
                                  unint64_t v455 = 0;
                                  int v456 = 1;
                                  while (v454 != v449)
                                  {
                                    if (v455) {
                                      BOOL v457 = 0;
                                    }
                                    else {
                                      BOOL v457 = v454 == -2;
                                    }
                                    if (v457) {
                                      unint64_t v455 = v453;
                                    }
                                    unsigned int v458 = v452 + v456++;
                                    unsigned int v452 = v458 & v447;
                                    int v453 = (char *)__src + 8 * (v458 & v447);
                                    uint64_t v454 = *(void *)v453;
                                    if (*(void *)v453 == -1) {
                                      goto LABEL_770;
                                    }
                                  }
                                  uint64_t v459 = *v448;
                                }
                                uint64_t v460 = v459 == v449 ? v453 : (char *)__src + 8 * v657;
                                unsigned int v451 = HIDWORD(v657);
                                uint64_t v461 = v655;
                              }
                              if (__src != v461) {
                                unsigned int v451 = v657;
                              }
                              if (v460 != (char *)__src + 8 * v451) {
                                break;
                              }
                            }
                            if (++v448 == (uint64_t *)((char *)__dst[0] + 8 * LODWORD(__dst[1])))
                            {
                              char v462 = 1;
                              goto LABEL_783;
                            }
                          }
                        }
                        char v462 = 0;
LABEL_783:
                        if (__dst[0] != &__dst[2]) {
                          free(__dst[0]);
                        }
                        if ((v462 & 1) == 0)
                        {
                          uint64_t v482 = (uint64_t)*v599;
                          memset(__dst, 0, sizeof(__dst));
                          unint64_t MachineMemOperand = llvm::MachineFunction::getMachineMemOperand(v482, v443, (long long *)__dst);
                          if (v631 >= (unint64_t)HIDWORD(v631)) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          *((void *)v630 + v631) = MachineMemOperand;
                          unsigned int v463 = v631 + 1;
                          LODWORD(v631) = v631 + 1;
                          ++v414;
                          char v442 = 1;
                          if (v414 == v441)
                          {
                            uint64_t v484 = (int *)v630;
                            goto LABEL_815;
                          }
                          goto LABEL_737;
                        }
                      }
                    }
                    if (v631 >= (unint64_t)HIDWORD(v631)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v630 + v631) = v443;
                    unsigned int v463 = v631 + 1;
                    LODWORD(v631) = v631 + 1;
                    ++v414;
                  }
                  while (v414 != v441);
                  uint64_t v484 = (int *)v630;
                  if ((v616 & 1) == 0) {
                    goto LABEL_816;
                  }
LABEL_815:
                  llvm::MachineInstr::setMemRefs(v412, *v599, v484, v463);
                  uint64_t v484 = (int *)v630;
LABEL_816:
                  uint64_t v411 = v618;
                  if (v484 != (int *)&v632) {
                    free(v484);
                  }
                  if (v412) {
                    goto LABEL_733;
                  }
                }
                break;
              }
              while ((*(_WORD *)(v412 + 44) & 8) != 0)
                uint64_t v412 = *(void *)(v412 + 8);
              goto LABEL_822;
            }
            while (2)
            {
              size_t v630 = 0;
              uint64_t v515 = *(void *)(a1 + 248);
              int v516 = *(_DWORD *)(v515 + 32);
              uint64_t v517 = *(void *)(v515 + 8);
              size_t v630 = *(void **)(v517 + 40 * (v516 + *(_DWORD *)v400) + 24);
              uint64_t v518 = (llvm::Instruction *)v630;
              uint64_t v519 = *(void *)(v517 + 40 * (*((_DWORD *)v400 + 1) + v516) + 24);
              sub_1CD467E2C((uint64_t)&v626, (uint64_t *)&v630)[1] = v519;
              uint64_t v520 = *((void *)v518 + 5);
              int v521 = *(__int16 *)(v520 + 18);
              if ((v521 & 0x80000000) == 0)
              {
                uint64_t v573 = *(void *)(v520 + 48);
                if (v573 != v520 + 40)
                {
                  int v574 = 0;
                  do
                  {
                    uint64_t v575 = v573 - 24;
                    if (!v573) {
                      uint64_t v575 = 0;
                    }
                    *(_DWORD *)(v575 + 56) = v574++;
                    uint64_t v573 = *(void *)(v573 + 8);
                  }
                  while (v573 != v520 + 40);
                }
                *(_WORD *)(v520 + 18) = v521 | 0x8000;
              }
              if (*((_DWORD *)v518 + 14) < *(_DWORD *)(v519 + 56)) {
                llvm::Instruction::moveBefore((llvm::Instruction *)v519, v518);
              }
              uint64_t v522 = (llvm::Value *)v519;
              if (*(void *)v518 != *(void *)v519)
              {
                uint64_t v523 = operator new(0x60uLL);
                uint64_t v522 = (llvm::Value *)(v523 + 8);
                v523[13] = v523[13] & 0x38000000 | 1;
                *(void *)uint64_t v523 = 0;
                *((void *)v523 + 1) = 0;
                *((void *)v523 + 2) = 0;
                *((void *)v523 + 3) = v523 + 8;
                uint64_t v524 = *(llvm::Type **)v518;
                v640[0] = 257;
                llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v523 + 8), (llvm::Value *)v519, v524, (const char **)__dst, 0);
                sub_1CC5C6C08((void *)(*(void *)(v519 + 40) + 40), v519 + 24, v522);
              }
              v525 = (char *)__src;
              uint64_t v526 = HIDWORD(v657);
              if (__src == v655)
              {
                if (HIDWORD(v657))
                {
                  uint64_t v527 = 0;
                  uint64_t v528 = 8 * HIDWORD(v657);
                  uint64_t v529 = (llvm::Instruction **)__src;
                  while (*v529 != v518)
                  {
                    if (*v529 == (llvm::Instruction *)-2) {
                      uint64_t v527 = v529;
                    }
                    ++v529;
                    v528 -= 8;
                    if (!v528)
                    {
                      if (!v527) {
                        goto LABEL_875;
                      }
                      *uint64_t v527 = v518;
                      --v658;
                      break;
                    }
                  }
LABEL_899:
                  uint64_t v540 = (char *)__src;
                  uint64_t v541 = HIDWORD(v657);
                  uint64_t v542 = (llvm::Type *)v657;
                  if (__src == v655)
                  {
                    if (HIDWORD(v657))
                    {
                      unint64_t v543 = 0;
                      uint64_t v544 = 8 * HIDWORD(v657);
                      unint64_t v545 = __src;
                      while (*v545 != v519)
                      {
                        if (*v545 == -2) {
                          unint64_t v543 = v545;
                        }
                        ++v545;
                        v544 -= 8;
                        if (!v544)
                        {
                          if (!v543) {
                            goto LABEL_907;
                          }
                          *unint64_t v543 = v519;
                          --v658;
                          break;
                        }
                      }
LABEL_930:
                      uint64_t v555 = *(void *)(a1 + 248);
                      int v556 = *(_DWORD *)(v555 + 32);
                      unsigned int v557 = v556 + *(_DWORD *)v400;
                      uint64_t v558 = *(void *)(v555 + 8);
                      int v559 = *(unsigned __int8 *)(v558 + 40 * v557 + 36);
                      if (*(unsigned char *)(v558 + 40 * v557 + 36))
                      {
                        uint64_t v560 = v558 + 40 * (*((_DWORD *)v400 + 1) + v556);
                        int v563 = *(unsigned __int8 *)(v560 + 36);
                        uint64_t v561 = (unsigned char *)(v560 + 36);
                        int v562 = v563;
                        if (!v563 || (v559 != 3 ? (BOOL v564 = v562 == 1) : (BOOL v564 = 1), !v564)) {
                          *uint64_t v561 = v559;
                        }
                      }
                      if ((*((unsigned char *)v518 + 23) & 8) != 0)
                      {
                        int v565 = llvm::UndefValue::get(*(llvm::UndefValue **)v518, v542);
                        llvm::ValueAsMetadata::handleRAUW((uint64_t *)v518, v565, v566);
                      }
                      for (uint64_t j = (uint64_t *)*((void *)v518 + 1); j; uint64_t j = (uint64_t *)j[1])
                      {
                        uint64_t v568 = *j;
                        if (*j && *(unsigned char *)(v568 + 16) == 77 && (*(unsigned char *)(v568 + 23) & 8) != 0)
                        {
                          unint64_t v569 = llvm::UndefValue::get(*(llvm::UndefValue **)v568, v542);
                          llvm::ValueAsMetadata::handleRAUW((uint64_t *)v568, v569, v570);
                        }
                      }
                      llvm::Value::doRAUW(v518, v522, (llvm::Value *)1);
                      unsigned int v571 = v400 + 8;
                      while (v571 != v399)
                      {
                        int v572 = *(_DWORD *)v571;
                        v571 += 8;
                        if ((v572 - 0x7FFFFFFF) >= 2)
                        {
                          unint64_t v400 = v571 - 8;
                          goto LABEL_950;
                        }
                      }
                      unint64_t v400 = v399;
LABEL_950:
                      if (v400 == v408) {
                        goto LABEL_688;
                      }
                      continue;
                    }
LABEL_907:
                    if (v657 > HIDWORD(v657))
                    {
                      ++HIDWORD(v657);
                      *((void *)__src + v541) = v519;
                      goto LABEL_930;
                    }
                  }
                  if (3 * (int)v657 <= (4 * (HIDWORD(v657) - v658)))
                  {
                    if (v657 >= 0x40) {
                      LODWORD(v542) = 2 * v657;
                    }
                    else {
                      LODWORD(v542) = 128;
                    }
                  }
                  else if ((int)v657 - HIDWORD(v657) >= v657 >> 3)
                  {
                    goto LABEL_911;
                  }
                  llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v655, v542);
                  uint64_t v542 = (llvm::Type *)v657;
                  uint64_t v540 = (char *)__src;
LABEL_911:
                  int v546 = v542 - 1;
                  unsigned int v547 = (v542 - 1) & ((v519 >> 4) ^ (v519 >> 9));
                  uint64_t v548 = &v540[8 * v547];
                  uint64_t v549 = *(void *)v548;
                  if (*(void *)v548 == -1)
                  {
                    unsigned int v550 = 0;
LABEL_923:
                    if (v550) {
                      unint64_t v554 = v550;
                    }
                    else {
                      unint64_t v554 = v548;
                    }
                    if (*(void *)v554 != v519)
                    {
                      if (*(void *)v554 == -2) {
                        --v658;
                      }
                      else {
                        ++HIDWORD(v657);
                      }
                      *(void *)unint64_t v554 = v519;
                    }
                  }
                  else
                  {
                    unsigned int v550 = 0;
                    int v551 = 1;
                    while (v549 != v519)
                    {
                      if (v550) {
                        BOOL v552 = 0;
                      }
                      else {
                        BOOL v552 = v549 == -2;
                      }
                      if (v552) {
                        unsigned int v550 = v548;
                      }
                      unsigned int v553 = v547 + v551++;
                      unsigned int v547 = v553 & v546;
                      uint64_t v548 = &v540[8 * (v553 & v546)];
                      uint64_t v549 = *(void *)v548;
                      if (*(void *)v548 == -1) {
                        goto LABEL_923;
                      }
                    }
                  }
                  goto LABEL_930;
                }
LABEL_875:
                unsigned int v530 = v657;
                if (HIDWORD(v657) < v657)
                {
                  ++HIDWORD(v657);
                  *((void *)__src + v526) = v518;
                  goto LABEL_899;
                }
              }
              else
              {
                unsigned int v530 = v657;
              }
              break;
            }
            if (3 * v530 <= 4 * (HIDWORD(v657) - v658))
            {
              if (v530 >= 0x40) {
                v530 *= 2;
              }
              else {
                unsigned int v530 = 128;
              }
            }
            else if (v530 - HIDWORD(v657) >= v530 >> 3)
            {
              goto LABEL_880;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v655, v530);
            unsigned int v530 = v657;
            v525 = (char *)__src;
LABEL_880:
            unsigned int v531 = v530 - 1;
            unsigned int v532 = (v530 - 1) & ((v518 >> 4) ^ (v518 >> 9));
            unsigned int v533 = &v525[8 * v532];
            int v534 = *(llvm::Instruction **)v533;
            if (*(void *)v533 == -1)
            {
              v535 = 0;
LABEL_892:
              if (v535) {
                uint64_t v539 = v535;
              }
              else {
                uint64_t v539 = (void **)v533;
              }
              if (*v539 != v518)
              {
                if (*v539 == (void *)-2) {
                  --v658;
                }
                else {
                  ++HIDWORD(v657);
                }
                *uint64_t v539 = v518;
              }
            }
            else
            {
              v535 = 0;
              int v536 = 1;
              while (v534 != v518)
              {
                if (v535) {
                  BOOL v537 = 0;
                }
                else {
                  BOOL v537 = v534 == (llvm::Instruction *)-2;
                }
                if (v537) {
                  v535 = (void **)v533;
                }
                unsigned int v538 = v532 + v536++;
                unsigned int v532 = v538 & v531;
                unsigned int v533 = &v525[8 * (v538 & v531)];
                int v534 = *(llvm::Instruction **)v533;
                if (*(void *)v533 == -1) {
                  goto LABEL_892;
                }
              }
            }
            goto LABEL_899;
          }
        }
      }
    }
  }
  uint64_t v162 = *(unsigned int *)(a1 + 1432);
  if (v162)
  {
    uint64_t v163 = *(llvm::MachineInstr ***)(a1 + 1424);
    uint64_t v164 = 8 * v162;
    do
    {
      uint64_t v165 = *v163++;
      llvm::MachineInstr::eraseFromParent(v165);
      v164 -= 8;
    }
    while (v164);
  }
  *(_DWORD *)(a1 + 1432) = 0;
LABEL_267:
  BOOL v44 = v162 != 0;
  if (v623 != v625) {
    free(v623);
  }
  return v44;
}

uint64_t sub_1CC485ED4(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  int v4 = **(unsigned __int16 **)(a2 + 16);
  if ((v4 - 21) > 1)
  {
    if ((v4 - 13) >= 5 && byte_1EBCD3D70 != 0 && byte_1EBCD3CB0 == 0)
    {
      uint64_t v11 = *(unsigned int *)(a2 + 40);
      if (v11)
      {
        char v8 = 0;
        uint64_t v12 = *(void *)(a2 + 32);
        uint64_t v13 = v12 + 32 * v11;
        do
        {
          while (*(unsigned char *)v12 == 5)
          {
            unint64_t v14 = *(unsigned int *)(v12 + 16);
            if ((v14 & 0x80000000) != 0) {
              break;
            }
            BOOL v15 = (*(void *)(*(void *)(a1 + 1504) + 8 * (v14 >> 6)) & (1 << v14)) == 0 || byte_1EBCD3D70 == 0;
            BOOL v16 = !v15 && byte_1EBCD3CB0 == 0;
            if (!v16 || (*(void *)(*(void *)(a1 + 1576) + 8 * (v14 >> 6)) & (1 << v14)) != 0) {
              break;
            }
            unint64_t v17 = *(unsigned int *)(a3 + 8);
            if (v17 >= *(unsigned int *)(a3 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(_DWORD *)(*(void *)a3 + 4 * v17) = v14;
            ++*(_DWORD *)(a3 + 8);
            v12 += 32;
            char v8 = 1;
            if (v12 == v13) {
              goto LABEL_42;
            }
          }
          v12 += 32;
        }
        while (v12 != v13);
        if (v8)
        {
          char v8 = 1;
          goto LABEL_42;
        }
      }
    }
  }
  else
  {
    if (*(int *)(*(void *)(a2 + 32) + 16) < 0) {
      unsigned int v5 = -1;
    }
    else {
      unsigned int v5 = *(_DWORD *)(*(void *)(a2 + 32) + 16);
    }
    if ((v5 & 0x80000000) == 0)
    {
      uint64_t v6 = v5 >> 6;
      if ((*(void *)(*(void *)(a1 + 1504) + 8 * v6) & (1 << v5)) != 0)
      {
        unsigned int v7 = *(_DWORD *)(a3 + 8);
        if (v7 >= *(_DWORD *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)a3 + 4 * v7) = v5;
        ++*(_DWORD *)(a3 + 8);
        if (**(_WORD **)(a2 + 16) == 22)
        {
          char v8 = 0;
LABEL_42:
          *a4 = v8;
          return 1;
        }
        char v8 = 1;
        if (!byte_1EBCD3D70 || byte_1EBCD3CB0 || (*(void *)(*(void *)(a1 + 1576) + 8 * v6) & (1 << v5)) != 0) {
          goto LABEL_42;
        }
      }
    }
  }
  return 0;
}

uint64_t sub_1CC486124(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 296 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      unsigned int v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          unsigned int v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 296 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

void *sub_1CC4861BC(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CC486270(a1, v6);
  uint64_t v8 = 0;
  sub_1CC486124(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CC486270(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  double result = operator new(296 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 296 * v10;
      do
      {
        *double result = -4096;
        result += 37;
        v11 -= 296;
      }
      while (v11);
    }
    if (v3)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 296 * v3;
      do
      {
        uint64_t v14 = v4 + v12;
        uint64_t v15 = *(void *)(v4 + v12);
        if ((v15 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v49 = 0;
          sub_1CC486124(*(void *)a1, *(_DWORD *)(a1 + 16), v15, &v49);
          BOOL v16 = v49;
          *unsigned int v49 = v15;
          v16[1] = (uint64_t)(v16 + 3);
          v16[2] = 0x600000000;
          unsigned int v17 = *(_DWORD *)(v14 + 16);
          if ((uint64_t *)v14 != v16 && v17 != 0)
          {
            unsigned int v19 = *(const void **)(v14 + 8);
            uint64_t v20 = v4 + v12;
            uint64_t v21 = v4 + v12 + 24;
            if ((const void *)v21 == v19)
            {
              if (v17 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v16 + 3, v19, 8 * *(unsigned int *)(v14 + 16));
              *((_DWORD *)v16 + 4) = v17;
            }
            else
            {
              v16[1] = (uint64_t)v19;
              int v46 = *(_DWORD *)(v20 + 20);
              *((_DWORD *)v16 + 4) = v17;
              *((_DWORD *)v16 + 5) = v46;
              *(void *)(v14 + 8) = v21;
              *(_DWORD *)(v20 + 20) = 0;
            }
            *(_DWORD *)(v14 + 16) = 0;
          }
          uint64_t v22 = v4 + v12;
          int v23 = *(_DWORD *)(v4 + v12 + 72);
          long long v16[10] = (uint64_t)(v16 + 12);
          *((_DWORD *)v16 + 18) = v23;
          v16[11] = 0x600000000;
          unsigned int v24 = *(_DWORD *)(v4 + v12 + 88);
          if (v24 && (uint64_t *)v14 != v16)
          {
            uint64_t v25 = *(const void **)(v22 + 80);
            uint64_t v26 = v4 + v12;
            uint64_t v27 = v4 + v12 + 96;
            if ((const void *)v27 == v25)
            {
              if (v24 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v16 + 12, v25, 8 * *(unsigned int *)(v4 + v12 + 88));
              *((_DWORD *)v16 + 22) = v24;
            }
            else
            {
              long long v16[10] = (uint64_t)v25;
              int v43 = *(_DWORD *)(v26 + 92);
              *((_DWORD *)v16 + 22) = v24;
              *((_DWORD *)v16 + 23) = v43;
              *(void *)(v22 + 80) = v27;
              *(_DWORD *)(v26 + 92) = 0;
            }
            *(_DWORD *)(v22 + 88) = 0;
          }
          int v28 = *(_DWORD *)(v22 + 144);
          v16[19] = (uint64_t)(v16 + 21);
          *((_DWORD *)v16 + 36) = v28;
          v16[20] = 0x600000000;
          unsigned int v29 = *(_DWORD *)(v22 + 160);
          if (v29 && (uint64_t *)v14 != v16)
          {
            uint64_t v30 = *(const void **)(v4 + v12 + 152);
            uint64_t v31 = v4 + v12 + 168;
            if ((const void *)v31 == v30)
            {
              if (v29 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v16 + 21, v30, 8 * *(unsigned int *)(v22 + 160));
              *((_DWORD *)v16 + 40) = v29;
            }
            else
            {
              v16[19] = (uint64_t)v30;
              int v44 = *(_DWORD *)(v4 + v12 + 164);
              *((_DWORD *)v16 + 40) = v29;
              *((_DWORD *)v16 + 41) = v44;
              *(void *)(v4 + v12 + 152) = v31;
              *(_DWORD *)(v4 + v12 + 164) = 0;
            }
            *(_DWORD *)(v22 + 160) = 0;
          }
          uint64_t v32 = v4 + v12;
          int v33 = *(_DWORD *)(v4 + v12 + 216);
          v16[28] = (uint64_t)(v16 + 30);
          *((_DWORD *)v16 + 54) = v33;
          v16[29] = 0x600000000;
          unsigned int v34 = *(_DWORD *)(v4 + v12 + 232);
          if (v34 && (uint64_t *)v14 != v16)
          {
            uint64_t v35 = *(const void **)(v32 + 224);
            uint64_t v36 = v4 + v12;
            uint64_t v37 = v4 + v12 + 240;
            if ((const void *)v37 == v35)
            {
              if (v34 >= 7) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v16 + 30, v35, 8 * *(unsigned int *)(v4 + v12 + 232));
              *((_DWORD *)v16 + 58) = v34;
            }
            else
            {
              v16[28] = (uint64_t)v35;
              int v45 = *(_DWORD *)(v36 + 236);
              *((_DWORD *)v16 + 58) = v34;
              *((_DWORD *)v16 + 59) = v45;
              *(void *)(v32 + 224) = v37;
              *(_DWORD *)(v36 + 236) = 0;
            }
            *(_DWORD *)(v32 + 232) = 0;
          }
          *((_DWORD *)v16 + 72) = *(_DWORD *)(v32 + 288);
          ++*(_DWORD *)(a1 + 8);
          uint64_t v38 = *(void **)(v32 + 224);
          if ((void *)(v32 + 240) != v38) {
            free(v38);
          }
          uint64_t v39 = v4 + v12;
          uint64_t v40 = *(void **)(v4 + v12 + 152);
          if ((void *)(v4 + v12 + 168) != v40) {
            free(v40);
          }
          uint64_t v41 = *(void **)(v39 + 80);
          if ((void *)(v39 + 96) != v41) {
            free(v41);
          }
          int v42 = *(void **)(v14 + 8);
          if ((void *)(v4 + v12 + 24) != v42) {
            free(v42);
          }
        }
        v12 += 296;
      }
      while (v13 != v12);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v47 = *(_DWORD *)(a1 + 16);
  if (v47)
  {
    uint64_t v48 = 296 * v47;
    do
    {
      *double result = -4096;
      result += 37;
      v48 -= 296;
    }
    while (v48);
  }
  return result;
}

int *sub_1CC4866DC(int *result, int *a2, uint64_t *a3, unint64_t a4, int *a5, uint64_t a6)
{
  if (a4 >= 2)
  {
    unsigned int v8 = result;
    if (a4 == 2)
    {
      int v9 = *(a2 - 1);
      if (v9 != -1)
      {
        int v10 = *result;
        if (*result == -1
          || (uint64_t v11 = *(void *)(*a3 + 248),
              *(void *)(*(void *)(v11 + 8) + 40 * (*(_DWORD *)(v11 + 32) + v9) + 8) > *(void *)(*(void *)(v11 + 8) + 40 * (*(_DWORD *)(v11 + 32) + v10) + 8)))
        {
          *double result = v9;
          *(a2 - 1) = v10;
        }
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      uint64_t v27 = a5;
      unint64_t v28 = a4 >> 1;
      unsigned int v29 = &result[a4 >> 1];
      unint64_t v30 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        sub_1CC486A0C((uint64_t)result, v29, a3, v30, a5);
        uint64_t v31 = &v27[v28];
        double result = (int *)sub_1CC486A0C((uint64_t)&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v31);
        uint64_t v32 = &v27[a4];
        uint64_t v33 = *a3;
        unsigned int v34 = v31;
        while (v34 != v32)
        {
          int v35 = *v34;
          int v36 = *v27;
          if (*v34 == -1
            || v36 != -1
            && *(void *)(*(void *)(*(void *)(v33 + 248) + 8)
                         + 40 * (*(_DWORD *)(*(void *)(v33 + 248) + 32) + v35)
                         + 8) <= *(void *)(*(void *)(*(void *)(v33 + 248) + 8)
                                           + 40 * (*(_DWORD *)(*(void *)(v33 + 248) + 32) + v36)
                                           + 8))
          {
            int *v8 = v36;
            ++v27;
          }
          else
          {
            int *v8 = v35;
            ++v34;
          }
          ++v8;
          if (v27 == v31)
          {
            if (v34 != v32)
            {
              uint64_t v37 = 0;
              do
              {
                v8[v37] = v34[v37];
                ++v37;
              }
              while (&v34[v37] != v32);
            }
            return result;
          }
        }
        if (v27 != v31)
        {
          uint64_t v38 = 0;
          do
          {
            v8[v38] = v27[v38];
            ++v38;
          }
          while (&v27[v38] != v31);
        }
      }
      else
      {
        sub_1CC4866DC(result, v29, a3, v30, a5, a6);
        sub_1CC4866DC(&v8[a4 >> 1], a2, a3, a4 - (a4 >> 1), v27, a6);
        return sub_1CC486CF4(v8, &v8[a4 >> 1], a2, a3, a4 >> 1, a4 - (a4 >> 1), v27, a6);
      }
    }
    else if (result != a2)
    {
      uint64_t v13 = result + 1;
      if (result + 1 != a2)
      {
        uint64_t v14 = 0;
        uint64_t v15 = *a3;
        BOOL v16 = result;
        do
        {
          unsigned int v17 = v16;
          BOOL v16 = v13;
          int v18 = v17[1];
          if (v18 != -1)
          {
            int v19 = *v17;
            if (*v17 == -1
              || *(void *)(*(void *)(*(void *)(v15 + 248) + 8)
                           + 40 * (*(_DWORD *)(*(void *)(v15 + 248) + 32) + v18)
                           + 8) > *(void *)(*(void *)(*(void *)(v15 + 248) + 8)
                                            + 40 * (*(_DWORD *)(*(void *)(v15 + 248) + 32) + v19)
                                            + 8))
            {
              v17[1] = v19;
              uint64_t v20 = v8;
              if (v17 != v8)
              {
                uint64_t v21 = v14;
                while (1)
                {
                  int v22 = *(int *)((char *)v8 + v21 - 4);
                  if (v22 != -1)
                  {
                    uint64_t v23 = *(void *)(v15 + 248);
                    int v24 = *(_DWORD *)(v23 + 32);
                    uint64_t v25 = *(void *)(v23 + 8);
                    double result = *(int **)(v25 + 40 * (v24 + v18) + 8);
                    if ((uint64_t)result <= *(void *)(v25 + 40 * (v24 + v22) + 8)) {
                      break;
                    }
                  }
                  *(int *)((char *)v8 + v21) = v22;
                  v21 -= 4;
                  if (!v21)
                  {
                    uint64_t v20 = v8;
                    goto LABEL_22;
                  }
                }
                uint64_t v20 = (int *)((char *)v8 + v21);
              }
LABEL_22:
              *uint64_t v20 = v18;
            }
          }
          uint64_t v13 = v16 + 1;
          v14 += 4;
        }
        while (v16 + 1 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CC486A0C(uint64_t result, int *a2, uint64_t *a3, unint64_t a4, int *a5)
{
  if (a4)
  {
    unint64_t v5 = a5;
    int v7 = (int *)result;
    if (a4 == 1)
    {
LABEL_9:
      *unint64_t v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      int v10 = *(a2 - 1);
      int v11 = *(_DWORD *)result;
      if (v10 == -1
        || v11 != -1
        && (uint64_t v12 = *(void *)(*a3 + 248),
            *(void *)(*(void *)(v12 + 8) + 40 * (*(_DWORD *)(v12 + 32) + v10) + 8) <= *(void *)(*(void *)(v12 + 8) + 40 * (*(_DWORD *)(v12 + 32) + v11) + 8)))
      {
        int v10 = *(_DWORD *)result;
        int v7 = a2 - 1;
      }
      *a5 = v10;
      unint64_t v5 = a5 + 1;
      goto LABEL_9;
    }
    if ((uint64_t)a4 > 8)
    {
      unint64_t v28 = (int *)(result + 4 * (a4 >> 1));
      sub_1CC4866DC(result, v28, a3, a4 >> 1, a5, a4 >> 1);
      double result = sub_1CC4866DC(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      uint64_t v29 = *a3;
      unint64_t v30 = &v7[a4 >> 1];
      while (v30 != a2)
      {
        int v31 = *v30;
        int v32 = *v7;
        if (*v30 == -1
          || v32 != -1
          && *(void *)(*(void *)(*(void *)(v29 + 248) + 8)
                       + 40 * (*(_DWORD *)(*(void *)(v29 + 248) + 32) + v31)
                       + 8) <= *(void *)(*(void *)(*(void *)(v29 + 248) + 8)
                                         + 40 * (*(_DWORD *)(*(void *)(v29 + 248) + 32) + v32)
                                         + 8))
        {
          *unint64_t v5 = v32;
          ++v7;
        }
        else
        {
          *unint64_t v5 = v31;
          ++v30;
        }
        ++v5;
        if (v7 == v28)
        {
          if (v30 != a2)
          {
            uint64_t v33 = 0;
            do
            {
              v5[v33] = v30[v33];
              ++v33;
            }
            while (&v30[v33] != a2);
          }
          return result;
        }
      }
      if (v7 != v28)
      {
        uint64_t v34 = 0;
        do
        {
          v5[v34] = v7[v34];
          ++v34;
        }
        while (&v7[v34] != v28);
      }
    }
    else if ((int *)result != a2)
    {
      uint64_t v13 = (int *)(result + 4);
      *a5 = *(_DWORD *)result;
      if ((int *)(result + 4) != a2)
      {
        uint64_t v14 = 0;
        uint64_t v15 = *a3;
        BOOL v16 = a5;
        unsigned int v17 = a5;
        do
        {
          int v19 = *v17++;
          int v18 = v19;
          int v20 = *v13;
          if (*v13 == -1
            || v18 != -1
            && *(void *)(*(void *)(*(void *)(v15 + 248) + 8)
                         + 40 * (*(_DWORD *)(*(void *)(v15 + 248) + 32) + v20)
                         + 8) <= *(void *)(*(void *)(*(void *)(v15 + 248) + 8)
                                           + 40 * (*(_DWORD *)(*(void *)(v15 + 248) + 32) + v18)
                                           + 8))
          {
            *unsigned int v17 = v20;
          }
          else
          {
            v16[1] = v18;
            uint64_t v21 = a5;
            if (v16 != a5)
            {
              uint64_t v22 = v14;
              while (1)
              {
                if (*v13 == -1)
                {
                  uint64_t v21 = v16;
                  goto LABEL_28;
                }
                int v23 = *(int *)((char *)a5 + v22 - 4);
                if (v23 != -1)
                {
                  uint64_t v24 = *(void *)(v15 + 248);
                  int v25 = *(_DWORD *)(v24 + 32);
                  uint64_t v26 = *(void *)(v24 + 8);
                  uint64_t v27 = *(void *)(v26 + 40 * (v25 + *v13) + 8);
                  double result = (v25 + v23);
                  if (v27 <= *(void *)(v26 + 40 * result + 8)) {
                    break;
                  }
                }
                --v16;
                *(int *)((char *)a5 + v22) = v23;
                v22 -= 4;
                if (!v22)
                {
                  uint64_t v21 = a5;
                  goto LABEL_28;
                }
              }
              uint64_t v21 = (int *)((char *)a5 + v22);
            }
LABEL_28:
            *uint64_t v21 = *v13;
          }
          ++v13;
          v14 += 4;
          BOOL v16 = v17;
        }
        while (v13 != a2);
      }
    }
  }
  return result;
}

_DWORD *sub_1CC486CF4(_DWORD *result, _DWORD *a2, _DWORD *a3, uint64_t *a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  if (!a6) {
    return result;
  }
  uint64_t v8 = a6;
  int v11 = result;
  while (a5 > a8 && v8 > a8)
  {
    if (!a5) {
      return result;
    }
    int v12 = *a2;
    uint64_t v13 = *a4;
    while (1)
    {
      if (v12 != -1)
      {
        int v14 = *v11;
        if (*v11 == -1
          || *(void *)(*(void *)(*(void *)(v13 + 248) + 8)
                       + 40 * (*(_DWORD *)(*(void *)(v13 + 248) + 32) + v12)
                       + 8) > *(void *)(*(void *)(*(void *)(v13 + 248) + 8)
                                        + 40 * (*(_DWORD *)(*(void *)(v13 + 248) + 32) + v14)
                                        + 8))
        {
          break;
        }
      }
      ++v11;
      if (!--a5) {
        return result;
      }
    }
    if (a5 >= v8)
    {
      if (a5 == 1)
      {
        *int v11 = v12;
        *a2 = v14;
        return result;
      }
      if (a5 >= 0) {
        uint64_t v23 = a5;
      }
      else {
        uint64_t v23 = a5 + 1;
      }
      uint64_t v22 = v23 >> 1;
      unsigned int v17 = &v11[v23 >> 1];
      uint64_t v16 = 0;
      if (a3 == a2)
      {
        uint64_t v29 = a3;
LABEL_44:
        int v31 = v17;
        goto LABEL_48;
      }
      unint64_t v24 = a3 - a2;
      int v25 = *v17;
      do
      {
        unint64_t v26 = v24 >> 1;
        unint64_t v27 = v16 + (v24 >> 1);
        int v28 = a2[v27];
        if (v28 != -1
          && (v25 == -1
           || *(void *)(*(void *)(*(void *)(v13 + 248) + 8)
                        + 40 * (*(_DWORD *)(*(void *)(v13 + 248) + 32) + v28)
                        + 8) > *(void *)(*(void *)(*(void *)(v13 + 248) + 8)
                                         + 40 * (*(_DWORD *)(*(void *)(v13 + 248) + 32) + v25)
                                         + 8)))
        {
          uint64_t v16 = v27 + 1;
          unint64_t v26 = v24 + ~v26;
        }
        unint64_t v24 = v26;
      }
      while (v26);
    }
    else
    {
      if (v8 >= 0) {
        uint64_t v15 = v8;
      }
      else {
        uint64_t v15 = v8 + 1;
      }
      uint64_t v16 = v15 >> 1;
      unsigned int v17 = a2;
      if (v11 != a2)
      {
        unint64_t v18 = a2 - v11;
        int v19 = a2[v16];
        unsigned int v17 = v11;
        do
        {
          unint64_t v20 = v18 >> 1;
          uint64_t v21 = &v17[v18 >> 1];
          if (v19 == -1
            || *v21 != -1
            && *(void *)(*(void *)(*(void *)(v13 + 248) + 8)
                         + 40 * (*(_DWORD *)(*(void *)(v13 + 248) + 32) + v19)
                         + 8) <= *(void *)(*(void *)(*(void *)(v13 + 248) + 8)
                                           + 40 * (*(_DWORD *)(*(void *)(v13 + 248) + 32) + *v21)
                                           + 8))
          {
            unsigned int v17 = v21 + 1;
            unint64_t v20 = v18 + ~v20;
          }
          unint64_t v18 = v20;
        }
        while (v20);
      }
      uint64_t v22 = v17 - v11;
    }
    uint64_t v29 = &a2[v16];
    v8 -= v16;
    if (v17 != a2)
    {
      if (v16)
      {
        uint64_t v61 = a8;
        char v62 = a3;
        if (v17 + 1 == a2)
        {
          int v60 = *v17;
          int v32 = a7;
          memmove(v17, a2, 4 * v16);
          a8 = v61;
          a3 = v62;
          a7 = v32;
          int v31 = &v17[v16];
          *int v31 = v60;
        }
        else
        {
          char v59 = a7;
          if (v16 == 1)
          {
            int v30 = *(v29 - 1);
            int v31 = v17 + 1;
            if (v29 - 1 != v17) {
              memmove(v17 + 1, v17, (char *)(v29 - 1) - (char *)v17);
            }
            *unsigned int v17 = v30;
            uint64_t v16 = 1;
          }
          else
          {
            int v31 = sub_1CBB1C390(v17, a2, &a2[v16]);
          }
          a7 = v59;
          a8 = v61;
          a3 = v62;
        }
        goto LABEL_48;
      }
      goto LABEL_44;
    }
    unsigned int v17 = a2;
    int v31 = &a2[v16];
LABEL_48:
    a5 -= v22;
    if (v16 + v22 >= a5 + v8)
    {
      uint64_t v39 = v29;
      uint64_t v40 = v8;
      uint64_t v41 = a7;
      uint64_t v42 = a8;
      double result = (_DWORD *)sub_1CC486CF4(v31, v39, a3, a4, a5, v40);
      a8 = v42;
      a7 = v41;
      uint64_t v29 = v17;
      uint64_t v8 = v16;
      a5 = v22;
      a3 = v31;
    }
    else
    {
      uint64_t v33 = v11;
      uint64_t v34 = v17;
      int v35 = a3;
      uint64_t v36 = v16;
      uint64_t v37 = a7;
      uint64_t v38 = a8;
      double result = (_DWORD *)sub_1CC486CF4(v33, v34, v31, a4, v22, v36);
      a8 = v38;
      a3 = v35;
      a7 = v37;
      int v11 = v31;
    }
    a2 = v29;
    if (!v8) {
      return result;
    }
  }
  if (a5 <= v8)
  {
    if (v11 != a2)
    {
      uint64_t v53 = 0;
      do
      {
        a7[v53] = v11[v53];
        ++v53;
      }
      while (&v11[v53] != a2);
      if (v53 * 4)
      {
        uint64_t v54 = *a4;
        unsigned int v55 = a7;
        while (a2 != a3)
        {
          int v56 = *a2;
          int v57 = *v55;
          if (*a2 == -1
            || v57 != -1
            && *(void *)(*(void *)(*(void *)(v54 + 248) + 8)
                         + 40 * (*(_DWORD *)(*(void *)(v54 + 248) + 32) + v56)
                         + 8) <= *(void *)(*(void *)(*(void *)(v54 + 248) + 8)
                                           + 40 * (*(_DWORD *)(*(void *)(v54 + 248) + 32) + v57)
                                           + 8))
          {
            *int v11 = v57;
            ++v55;
          }
          else
          {
            *int v11 = v56;
            ++a2;
          }
          ++v11;
          if (&a7[v53] == v55) {
            return result;
          }
        }
        return memmove(v11, v55, (char *)a7 - (char *)v55 + v53 * 4);
      }
    }
  }
  else if (a2 != a3)
  {
    uint64_t v43 = 0;
    do
    {
      a7[v43] = a2[v43];
      ++v43;
    }
    while (&a2[v43] != a3);
    if (v43 * 4)
    {
      int v44 = &a7[v43];
      uint64_t v45 = *a4;
      int v46 = a3 - 1;
      while (a2 != v11)
      {
        int v47 = *(v44 - 1);
        if (v47 == -1
          || (uint64_t v48 = a2 - 1, v49 = *(a2 - 1), v49 != -1)
          && (uint64_t v50 = *(void *)(v45 + 248),
              int v51 = *(_DWORD *)(v50 + 32),
              uint64_t v52 = *(void *)(v50 + 8),
              double result = *(_DWORD **)(v52 + 40 * (v51 + v47) + 8),
              (uint64_t)result <= *(void *)(v52 + 40 * (v51 + v49) + 8)))
        {
          int v49 = *(v44 - 1);
          uint64_t v48 = a2;
          --v44;
        }
        *v46-- = v49;
        a2 = v48;
        if (v44 == a7) {
          return result;
        }
      }
      if (v44 != a7)
      {
        uint64_t v58 = 0;
        do
        {
          v46[v58] = v44[v58 - 1];
          --v58;
        }
        while (&v44[v58] != a7);
      }
    }
  }
  return result;
}

void *sub_1CC487200(void *result, void *a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    int v11 = result;
    while (a4 > a7 && v8 > a7)
    {
      while (1)
      {
        uint64_t v12 = *v11;
        if (((*a2 >> 1) & 3 | *(_DWORD *)((*a2 & 0xFFFFFFFFFFFFFFF8) + 24)) < ((*v11 >> 1) & 3 | *(_DWORD *)((*v11 & 0xFFFFFFFFFFFFFFF8) + 24))) {
          break;
        }
        ++v11;
        if (!--a4) {
          return result;
        }
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *int v11 = *a2;
          *a2 = v12;
          return result;
        }
        unint64_t v21 = (unint64_t)a4 >> 1;
        uint64_t v15 = &v11[(unint64_t)a4 >> 1];
        int v14 = a3;
        if (a3 != a2)
        {
          unint64_t v22 = a3 - a2;
          int v14 = a2;
          do
          {
            unint64_t v23 = v22 >> 1;
            unint64_t v24 = &v14[v22 >> 1];
            uint64_t v26 = *v24;
            int v25 = v24 + 1;
            v22 += ~(v22 >> 1);
            if (((v26 >> 1) & 3 | *(_DWORD *)((v26 & 0xFFFFFFFFFFFFFFF8) + 24)) < ((*v15 >> 1) & 3 | *(_DWORD *)((*v15 & 0xFFFFFFFFFFFFFFF8) + 24))) {
              int v14 = v25;
            }
            else {
              unint64_t v22 = v23;
            }
          }
          while (v22);
        }
        uint64_t v13 = v14 - a2;
      }
      else
      {
        uint64_t v13 = (unint64_t)v8 >> 1;
        int v14 = &a2[(unint64_t)v8 >> 1];
        uint64_t v15 = a2;
        if (v11 != a2)
        {
          unint64_t v16 = a2 - v11;
          uint64_t v15 = v11;
          do
          {
            unint64_t v17 = v16 >> 1;
            unint64_t v18 = &v15[v16 >> 1];
            uint64_t v20 = *v18;
            int v19 = v18 + 1;
            v16 += ~(v16 >> 1);
            if (((*v14 >> 1) & 3 | *(_DWORD *)((*v14 & 0xFFFFFFFFFFFFFFF8) + 24)) < ((v20 >> 1) & 3 | *(_DWORD *)((v20 & 0xFFFFFFFFFFFFFFF8) + 24))) {
              unint64_t v16 = v17;
            }
            else {
              uint64_t v15 = v19;
            }
          }
          while (v16);
        }
        unint64_t v21 = v15 - v11;
      }
      unint64_t v27 = v14;
      if (v15 != a2)
      {
        unint64_t v27 = v15;
        if (a2 != v14)
        {
          if (v15 + 1 == a2)
          {
            uint64_t v69 = *v15;
            unsigned int v71 = a3;
            int64_t v34 = (char *)v14 - (char *)a2;
            char v73 = a6;
            memmove(v15, a2, (char *)v14 - (char *)a2);
            a3 = v71;
            a6 = v73;
            unint64_t v27 = (void *)((char *)v15 + v34);
            *unint64_t v27 = v69;
          }
          else if (a2 + 1 == v14)
          {
            uint64_t v35 = *(v14 - 1);
            unint64_t v27 = v15 + 1;
            if (v14 - 1 != v15)
            {
              unsigned int v72 = a3;
              unint64_t v74 = a6;
              uint64_t v70 = *(v14 - 1);
              memmove(v15 + 1, v15, (char *)(v14 - 1) - (char *)v15);
              uint64_t v35 = v70;
              a3 = v72;
              a6 = v74;
            }
            *uint64_t v15 = v35;
          }
          else
          {
            uint64_t v28 = a2 - v15;
            if (v28 == v14 - a2)
            {
              uint64_t v29 = 0;
              do
              {
                uint64_t v30 = v15[v29];
                v15[v29] = a2[v29];
                uint64_t v31 = (uint64_t)&v15[v29 + 1];
                a2[v29] = v30;
                uint64_t v32 = (uint64_t)&a2[++v29];
              }
              while ((void *)v31 != a2 && v32 != (void)v14);
              unint64_t v27 = a2;
            }
            else
            {
              uint64_t v36 = v14 - a2;
              uint64_t v37 = a2 - v15;
              do
              {
                uint64_t v38 = v37;
                uint64_t v37 = v36;
                uint64_t v36 = v38 % v36;
              }
              while (v36);
              if (v37)
              {
                uint64_t v39 = &v15[v37];
                do
                {
                  uint64_t v41 = *--v39;
                  uint64_t v40 = v41;
                  uint64_t v42 = &v39[v28];
                  uint64_t v43 = v39;
                  do
                  {
                    int v44 = v43;
                    uint64_t v43 = v42;
                    *int v44 = *v42;
                    BOOL v45 = __OFSUB__(v28, v14 - v42);
                    uint64_t v47 = v28 - (v14 - v42);
                    char v46 = (v47 < 0) ^ v45;
                    uint64_t v42 = &v15[v47];
                    if (v46) {
                      uint64_t v42 = &v43[v28];
                    }
                  }
                  while (v42 != v39);
                  void *v43 = v40;
                }
                while (v39 != v15);
              }
              unint64_t v27 = &v15[v14 - a2];
            }
          }
        }
      }
      a4 -= v21;
      v8 -= v13;
      if ((uint64_t)(v21 + v13) >= a4 + v8)
      {
        uint64_t v52 = v8;
        uint64_t v53 = a6;
        double result = (void *)sub_1CC487200(v27, v14, a3, a4, v52, a6, a7);
        a6 = v53;
        int v14 = v15;
        uint64_t v8 = v13;
        a4 = v21;
        a3 = v27;
      }
      else
      {
        uint64_t v48 = v11;
        int v49 = v15;
        uint64_t v50 = a6;
        int v51 = a3;
        double result = (void *)sub_1CC487200(v48, v49, v27, v21, v13, a6, a7);
        a3 = v51;
        a6 = v50;
        int v11 = v27;
      }
      a2 = v14;
      if (!v8) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v60 = 0;
        do
        {
          a6[v60] = v11[v60];
          ++v60;
        }
        while (&v11[v60] != a2);
        if (v60 * 8)
        {
          uint64_t v61 = a6;
          while (a2 != a3)
          {
            uint64_t v62 = *v61;
            unsigned int v63 = (*a2 >> 1) & 3 | *(_DWORD *)((*a2 & 0xFFFFFFFFFFFFFFF8) + 24);
            unsigned int v64 = *(_DWORD *)((*v61 & 0xFFFFFFFFFFFFFFF8) + 24) | (*v61 >> 1) & 3;
            BOOL v65 = v63 >= v64;
            BOOL v66 = v63 < v64;
            unsigned int v67 = v65;
            if (!v65) {
              uint64_t v62 = *a2;
            }
            v61 += v67;
            a2 += v66;
            *v11++ = v62;
            if (&a6[v60] == v61) {
              return result;
            }
          }
          return memmove(v11, v61, (char *)a6 - (char *)v61 + v60 * 8);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v54 = 0;
      do
      {
        a6[v54] = a2[v54];
        ++v54;
      }
      while (&a2[v54] != a3);
      if (v54 * 8)
      {
        unsigned int v55 = &a6[v54];
        int v56 = a3 - 1;
        while (a2 != v11)
        {
          uint64_t v57 = *(a2 - 1);
          unsigned int v58 = (*(v55 - 1) >> 1) & 3 | *(_DWORD *)((*(v55 - 1) & 0xFFFFFFFFFFFFFFF8) + 24);
          unsigned int v59 = *(_DWORD *)((v57 & 0xFFFFFFFFFFFFFFF8) + 24) | (v57 >> 1) & 3;
          if (v58 < v59) {
            --a2;
          }
          else {
            uint64_t v57 = *(v55 - 1);
          }
          if (v58 >= v59) {
            --v55;
          }
          *v56-- = v57;
          if (v55 == a6) {
            return result;
          }
        }
        if (v55 != a6)
        {
          uint64_t v68 = 0;
          do
          {
            v56[v68] = v55[v68 - 1];
            --v68;
          }
          while (&v55[v68] != a6);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CC48770C()
{
  char v3 = 0;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Disable stack coloring";
  v1.n128_u64[1] = 22;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCD3B70, "no-stack-coloring", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3B70, &dword_1CB82C000);
  char v3 = 0;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Do not optimize lifetime zones that are broken";
  v1.n128_u64[1] = 46;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCD3C30, "protect-from-escaped-allocas", &v4, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3C30, &dword_1CB82C000);
  char v3 = 1;
  uint64_t v4 = &v3;
  int v2 = 1;
  v1.n128_u64[0] = (unint64_t)"Treat stack lifetimes as starting on first use, not on START marker.";
  v1.n128_u64[1] = 68;
  sub_1CD57CD9C(&v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &qword_1EBCD3CF0, &dword_1CB82C000);
}

void sub_1CC487838()
{
}

void sub_1CC4878D4()
{
}

void sub_1CC487A04(uint64_t a1)
{
  *(void *)a1 = &unk_1F2613310;
  free(*(void **)(a1 + 304));
  int v2 = *(void **)(a1 + 264);
  if (v2 != (void *)(a1 + 288)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F260E110;
  char v3 = *(void **)(a1 + 176);
  if (v3 != (void *)(a1 + 192)) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 104);
  if (v4 != (void *)(a1 + 120)) {
    free(v4);
  }
  unint64_t v5 = *(void **)(a1 + 32);
  if (v5 != (void *)(a1 + 48)) {
    free(v5);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC487AD4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2613310;
  free(*(void **)(a1 + 304));
  int v2 = *(void **)(a1 + 264);
  if (v2 != (void *)(a1 + 288)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F260E110;
  char v3 = *(void **)(a1 + 176);
  if (v3 != (void *)(a1 + 192)) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 104);
  if (v4 != (void *)(a1 + 120)) {
    free(v4);
  }
  unint64_t v5 = *(void **)(a1 + 32);
  if (v5 != (void *)(a1 + 48)) {
    free(v5);
  }
  llvm::Pass::~Pass((llvm::Pass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC487BB8(llvm::PassRegistry *a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  v5[0] = &unk_1F2617E40;
  v5[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v5);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC487C34(void *a1, uint64_t a2)
{
  if (byte_1EBCD3E30
    && (a1[31] = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16)),
        *(unsigned char *)(*(void *)(a2 + 56) + 40))
    && (uint64_t v4 = *(const llvm::MachineBasicBlock **)(a2 + 328), v4 != (const llvm::MachineBasicBlock *)(a2 + 320)))
  {
    char v5 = 0;
    do
    {
      uint64_t v6 = a1[31];
      a1[32] = v6;
      a1[34] = 0;
      sub_1CD50BAB8(a1 + 33, *(_DWORD *)(v6 + 16));
      llvm::LivePhysRegs::addLiveOutsNoPristines((llvm::LivePhysRegs *)(a1 + 32), v4);
      unint64_t v7 = *((void *)v4 + 6) & 0xFFFFFFFFFFFFFFF8;
      if (!v7 || (*(unsigned char *)v7 & 4) == 0)
      {
        while ((*(_WORD *)(v7 + 44) & 4) != 0)
          unint64_t v7 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
      }
      while ((const llvm::MachineBasicBlock *)v7 != (const llvm::MachineBasicBlock *)((char *)v4 + 48))
      {
        if (**(_WORD **)(v7 + 16) == 27)
        {
          llvm::MachineFunction::allocateRegMask((llvm::MachineFunction *)a2);
          uint64_t v9 = v8;
          uint64_t v10 = a1[34];
          if (v10)
          {
            int v11 = (unsigned __int16 *)a1[33];
            uint64_t v12 = 2 * v10;
            do
            {
              unsigned int v13 = *v11++;
              *(_DWORD *)(v8 + (((unint64_t)v13 >> 3) & 0x1FFC)) |= 1 << v13;
              v12 -= 2;
            }
            while (v12);
          }
          (*(void (**)(void, uint64_t))(*(void *)a1[31] + 176))(a1[31], v8);
          int v15 = 13;
          uint64_t v16 = 0;
          uint64_t v17 = v9;
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v7, (llvm::MachineFunction *)a2, (const llvm::MachineOperand *)&v15);
          char v5 = 1;
        }
        llvm::LivePhysRegs::removeDefs((llvm::LivePhysRegs *)(a1 + 32), (const llvm::MachineInstr *)v7);
        llvm::LivePhysRegs::addUses((llvm::LivePhysRegs *)(a1 + 32), (const llvm::MachineInstr *)v7);
        unint64_t v7 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
        if (!v7 || (*(unsigned char *)v7 & 4) == 0)
        {
          while ((*(_WORD *)(v7 + 44) & 4) != 0)
            unint64_t v7 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
        }
      }
      uint64_t v4 = (const llvm::MachineBasicBlock *)*((void *)v4 + 1);
    }
    while (v4 != (const llvm::MachineBasicBlock *)(a2 + 320));
  }
  else
  {
    char v5 = 0;
  }
  return v5 & 1;
}

double sub_1CC487E34@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 8;
  *(void *)a1 = a1 + 16;
  *(void *)&double result = 0x600000001;
  *(void *)(a1 + 8) = 0x600000001;
  *(_DWORD *)(a1 + 64) = 11;
  return result;
}

uint64_t sub_1CC487E5C()
{
  int v4 = 1;
  char v2 = 1;
  char v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Enable PatchPoint Liveness Analysis Pass";
  v1.n128_u64[1] = 40;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCD3DB0, "enable-patchpoint-liveness", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3DB0, &dword_1CB82C000);
}

void *llvm::StackMapOpers::StackMapOpers(void *this, const llvm::MachineInstr *a2)
{
  *this = a2;
  return this;
}

{
  *this = a2;
  return this;
}

uint64_t llvm::PatchPointOpers::PatchPointOpers(uint64_t this, const llvm::MachineInstr *a2)
{
  *(void *)this = a2;
  *(unsigned char *)(this + 8) = (**((_DWORD **)a2 + 4) & 0x30000FF) == 0x1000000;
  return this;
}

{
  *(void *)this = a2;
  *(unsigned char *)(this + 8) = (**((_DWORD **)a2 + 4) & 0x30000FF) == 0x1000000;
  return this;
}

uint64_t llvm::PatchPointOpers::getNextScratchIdx(llvm::PatchPointOpers *this, uint64_t a2)
{
  uint64_t v2 = *(void *)this;
  if (!a2) {
    a2 = *((unsigned __int8 *)this + 8)
  }
       + *(_DWORD *)(*(void *)(v2 + 32) + 32 * *((unsigned __int8 *)this + 8) + 112)
       + 5;
  uint64_t v3 = *(unsigned int *)(v2 + 40);
  if (a2 < v3)
  {
    int v4 = (int *)(*(void *)(v2 + 32) + 32 * a2);
    while (1)
    {
      int v5 = *v4;
      v4 += 8;
      if ((v5 & 0x430000FF) == 0x43000000) {
        break;
      }
      a2 = (a2 + 1);
      if (v3 == a2) {
        return v3;
      }
    }
  }
  return a2;
}

uint64_t llvm::StatepointOpers::getGCPointerMap(llvm::StatepointOpers *a1, uint64_t a2)
{
  unsigned int NumGcMapEntriesIdx = llvm::StatepointOpers::getNumGcMapEntriesIdx(a1);
  uint64_t v5 = *(unsigned int *)(*(void *)(*(void *)a1 + 32) + 32 * NumGcMapEntriesIdx + 16);
  if (v5)
  {
    unsigned int v6 = *(_DWORD *)(a2 + 8);
    unsigned int v7 = NumGcMapEntriesIdx + 2;
    int v8 = *(_DWORD *)(*(void *)(*(void *)a1 + 32) + 32 * NumGcMapEntriesIdx + 16);
    do
    {
      if (v6 >= *(_DWORD *)(a2 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a2 + 8 * v6) = *(unsigned int *)(*(void *)(*(void *)a1 + 32) + 32 * (v7 - 1) + 16) | (*(void *)(*(void *)(*(void *)a1 + 32) + 32 * v7 + 16) << 32);
      unsigned int v6 = *(_DWORD *)(a2 + 8) + 1;
      *(_DWORD *)(a2 + 8) = v6;
      v7 += 2;
      --v8;
    }
    while (v8);
  }
  return v5;
}

double llvm::StackMaps::StackMaps(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = 0;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 36) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 84) = 0u;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = 0;
  return result;
}

int *llvm::StackMaps::parseOperand(llvm::StackMaps *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v8 = a1;
  v50[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(*(void *)(*(void *)a1 + 280) + 16);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 176))(v9);
  uint64_t v11 = v10;
  int v12 = *a2;
  int v13 = *a2;
  if (!*a2)
  {
    if ((v12 & 0x2000000) != 0) {
      return a2 + 8;
    }
    if ((v12 & 0x10000000) != 0)
    {
      uint64_t v21 = 4278124286;
      unsigned int v22 = *(_DWORD *)(a4 + 8);
      if (v22 < *(_DWORD *)(a4 + 12))
      {
        uint64_t v23 = *(void *)a4 + 24 * v22;
        *(void *)uint64_t v23 = 0x800000004;
        *(_DWORD *)(v23 + 8) = 0;
        *(void *)(v23 + 16) = 4278124286;
LABEL_12:
        *(_DWORD *)(a4 + 8) = v22 + 1;
        return a2 + 8;
      }
      uint64_t v48 = (void *)0x800000004;
      unsigned int v49 = 0;
    }
    else
    {
      unint64_t v29 = a2[1];
      uint64_t v30 = *(char **)(v10 + 240);
      uint64_t v31 = *(char **)(v10 + 248);
      if (v30 == v31)
      {
        uint64_t v32 = 0;
      }
      else
      {
        uint64_t v32 = 0;
        unint64_t v33 = v29 >> 3;
        int64_t v34 = *(char **)(v10 + 240);
        do
        {
          if ((v29 - 0x40000000) >= 0xC0000001)
          {
            uint64_t v35 = **(void **)v34;
            if (v33 < *(unsigned __int16 *)(v35 + 22)
              && ((1 << (v29 & 7)) & *(unsigned __int8 *)(*(void *)(v35 + 8) + v33)) != 0
              && (!v32
               || *(uint64_t **)v34 != v32
               && ((*(_DWORD *)(v32[1] + ((*(unsigned __int16 *)(v35 + 24) >> 3) & 0x1FFCLL)) >> *(_WORD *)(v35 + 24)) & 1) != 0))
            {
              uint64_t v32 = *(uint64_t **)v34;
            }
          }
          v34 += 8;
        }
        while (v34 != v31);
      }
      unsigned int v36 = sub_1CC488510(a2[1], v10);
      LLVMRegNuuint64_t m = llvm::MCRegisterInfo::getLLVMRegNum((llvm::MCRegisterInfo *)(v11 + 8), v36, 0);
      unsigned int SubRegIndex = llvm::MCRegisterInfo::getSubRegIndex((void *)(v11 + 8), LLVMRegNum, v29);
      if (SubRegIndex) {
        uint64_t v21 = *(unsigned __int16 *)(*(void *)(v11 + 96) + 4 * SubRegIndex);
      }
      else {
        uint64_t v21 = 0;
      }
      int v39 = *(_DWORD *)(*(void *)(v11 + 264)
                      + 24
                      * (*(unsigned __int16 *)(*v32 + 24)
                       + *(_DWORD *)(v11 + 272) * ((unint64_t)(v31 - v30) >> 3))
                      + 4) >> 3;
      unsigned int v22 = *(_DWORD *)(a4 + 8);
      if (v22 < *(_DWORD *)(a4 + 12))
      {
        uint64_t v40 = *(void *)a4 + 24 * v22;
        *(_DWORD *)uint64_t v40 = 1;
        *(_DWORD *)(v40 + 4) = v39;
        *(_DWORD *)(v40 + 8) = v36;
        *(void *)(v40 + 16) = v21;
        goto LABEL_12;
      }
      LODWORD(v48) = 1;
      HIDWORD(v48) = v39;
      unsigned int v49 = v36;
    }
    v50[0] = v21;
    unint64_t v41 = sub_1CD483108(a4, (unint64_t)&v48);
    uint64_t v42 = *(void *)a4 + 24 * *(unsigned int *)(a4 + 8);
    long long v43 = *(_OWORD *)v41;
    *(void *)(v42 + 16) = *(void *)(v41 + 16);
    *(_OWORD *)uint64_t v42 = v43;
    unsigned int v22 = *(_DWORD *)(a4 + 8);
    goto LABEL_12;
  }
  if (v13 == 13)
  {
    llvm::StackMaps::parseRegisterLiveOutMask(v8, *((const unsigned int **)a2 + 2), (unsigned __int16 **)&v48);
    sub_1CC48B538(a5, (uint64_t)&v48);
    if (v48 != v50) {
      free(v48);
    }
  }
  else if (v13 == 1)
  {
    uint64_t v14 = *((void *)a2 + 2);
    if (v14)
    {
      if (v14 != 1)
      {
        int v15 = a2 + 8;
        uint64_t v25 = *((void *)a2 + 6);
        unsigned int v26 = *(_DWORD *)(a4 + 8);
        int v19 = (_DWORD *)(a4 + 8);
        if (v26 < *(_DWORD *)(a4 + 12))
        {
          uint64_t v27 = *(void *)a4 + 24 * v26;
          *(void *)uint64_t v27 = 0x800000004;
          *(_DWORD *)(v27 + 8) = 0;
          *(void *)(v27 + 16) = v25;
          unsigned int v18 = v26;
          goto LABEL_19;
        }
        uint64_t v48 = (void *)0x800000004;
        unsigned int v49 = 0;
        v50[0] = v25;
LABEL_44:
        unint64_t v45 = sub_1CD483108(a4, (unint64_t)&v48);
        uint64_t v46 = *(void *)a4 + 24 * *(unsigned int *)(a4 + 8);
        long long v47 = *(_OWORD *)v45;
        *(void *)(v46 + 16) = *(void *)(v45 + 16);
        *(_OWORD *)uint64_t v46 = v47;
        unsigned int v18 = *(_DWORD *)(a4 + 8);
        goto LABEL_19;
      }
      int v8 = (llvm::StackMaps *)*((void *)a2 + 6);
      int v15 = a2 + 24;
      uint64_t v16 = *((void *)a2 + 14);
      unsigned int v17 = sub_1CC488510(a2[17], v10);
      unsigned int v18 = *(_DWORD *)(a4 + 8);
      int v19 = (_DWORD *)(a4 + 8);
      if (v18 < *(_DWORD *)(a4 + 12))
      {
        uint64_t v20 = *(void *)a4 + 24 * v18;
        *(_DWORD *)uint64_t v20 = 3;
        *(_DWORD *)(v20 + 4) = v8;
        *(_DWORD *)(v20 + 8) = v17;
        *(void *)(v20 + 16) = v16;
LABEL_19:
        *int v19 = v18 + 1;
        a2 = v15;
        return a2 + 8;
      }
      int v44 = 3;
    }
    else
    {
      LODWORD(v8) = *(_DWORD *)(*(void *)(*(void *)(**(void **)(*(void *)v8 + 280) + 40) + 504) + 4) >> 3;
      int v15 = a2 + 16;
      uint64_t v16 = *((void *)a2 + 10);
      unsigned int v17 = sub_1CC488510(a2[9], v10);
      unsigned int v18 = *(_DWORD *)(a4 + 8);
      int v19 = (_DWORD *)(a4 + 8);
      if (v18 < *(_DWORD *)(a4 + 12))
      {
        uint64_t v24 = *(void *)a4 + 24 * v18;
        *(_DWORD *)uint64_t v24 = 2;
        *(_DWORD *)(v24 + 4) = v8;
        *(_DWORD *)(v24 + 8) = v17;
        *(void *)(v24 + 16) = v16;
        goto LABEL_19;
      }
      int v44 = 2;
    }
    uint64_t v48 = (void *)__PAIR64__(v8, v44);
    unsigned int v49 = v17;
    v50[0] = v16;
    goto LABEL_44;
  }
  return a2 + 8;
}

uint64_t sub_1CC488510(unsigned int a1, uint64_t a2)
{
  uint64_t v4 = a2 + 8;
  uint64_t result = llvm::MCRegisterInfo::getDwarfRegNum(a2 + 8, a1, 0);
  if (a2) {
    unsigned int v6 = (void *)v4;
  }
  else {
    unsigned int v6 = 0;
  }
  unsigned int v7 = (_WORD *)(v6[6] + 2 * *(unsigned int *)(*v6 + 24 * a1 + 8));
  if (*v7 && (result & 0x80000000) != 0)
  {
    int v8 = v7 + 1;
    unsigned __int16 v9 = *v7 + a1;
    do
    {
      uint64_t result = llvm::MCRegisterInfo::getDwarfRegNum(v4, v9, 0);
      int v11 = *v8++;
      int v10 = v11;
      if (!v11) {
        int v8 = 0;
      }
      if (!v10) {
        break;
      }
      v9 += v10;
    }
    while ((result & 0x80000000) != 0);
  }
  return result;
}

_WORD *llvm::StackMaps::parseRegisterLiveOutMask@<X0>(llvm::StackMaps *this@<X0>, const unsigned int *a2@<X1>, unsigned __int16 **a3@<X8>)
{
  uint64_t v5 = *(void *)(*(void *)(*(void *)this + 280) + 16);
  LiveOutReg = (const llvm::TargetRegisterInfo *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 176))(v5);
  unsigned int v7 = LiveOutReg;
  int v8 = (unsigned int *)(a3 + 2);
  *a3 = (unsigned __int16 *)(a3 + 2);
  a3[1] = (unsigned __int16 *)0x800000000;
  int v9 = *((_DWORD *)LiveOutReg + 4);
  if (v9)
  {
    unsigned int v10 = 0;
    for (unsigned int i = 0; i != v9; ++i)
    {
      if ((a2[i >> 5] >> i))
      {
        LiveOutReg = (const llvm::TargetRegisterInfo *)llvm::StackMaps::createLiveOutReg(LiveOutReg, i, v7);
        if (v10 >= *((_DWORD *)a3 + 3)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v12 = (uint64_t)&(*a3)[3 * v10];
        *(_WORD *)(v12 + 4) = WORD2(LiveOutReg);
        *(_DWORD *)uint64_t v12 = LiveOutReg;
        unsigned int v10 = *((_DWORD *)a3 + 2) + 1;
        *((_DWORD *)a3 + 2) = v10;
      }
    }
    uint64_t v13 = (uint64_t)*a3;
    int v8 = (unsigned int *)&(*a3)[3 * v10];
    if (v10)
    {
      uint64_t v14 = 126 - 2 * __clz(v10);
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = (uint64_t)(a3 + 2);
  }
  uint64_t v14 = 0;
LABEL_13:
  uint64_t result = (_WORD *)sub_1CC48B664(v13, v8, v14, 1);
  uint64_t v16 = *a3;
  unsigned int v17 = *((_DWORD *)a3 + 2);
  if (v17)
  {
    unsigned int v18 = &v16[3 * v17];
    int v19 = *a3;
    do
    {
      uint64_t v20 = v19 + 3;
      if (v19 + 3 != v18)
      {
        int v21 = v19[1];
        unsigned int v22 = v19;
        while (1)
        {
          uint64_t v23 = v20;
          if (v21 != v22[4]) {
            break;
          }
          unsigned int v24 = v19[2];
          if (v24 <= v22[5]) {
            LOWORD(v24) = v22[5];
          }
          v19[2] = v24;
          int v25 = v22[3];
          uint64_t result = (_WORD *)(*((void *)v7 + 7) + 2 * *(unsigned int *)(*((void *)v7 + 1) + 24 * *v19 + 8));
          BOOL v26 = *result == 0;
          if (*result)
          {
            int v27 = (unsigned __int16)*result + *v19;
            if (v25 != (unsigned __int16)v27)
            {
              ++result;
              do
              {
                int v29 = (unsigned __int16)*result++;
                int v28 = v29;
                BOOL v26 = v29 == 0;
                if (!v29) {
                  uint64_t result = 0;
                }
                if (!v28) {
                  break;
                }
                v27 += v28;
              }
              while (v25 != (unsigned __int16)v27);
            }
          }
          if (!v26) {
            *int v19 = v25;
          }
          *uint64_t v23 = 0;
          uint64_t v20 = v23 + 3;
          unsigned int v22 = v23;
          if (v23 + 3 == v18) {
            goto LABEL_32;
          }
        }
        int v19 = v22;
      }
LABEL_32:
      v19 += 3;
    }
    while (v19 != v18);
    uint64_t v30 = 6 * v17 - 6;
    uint64_t v31 = v16;
    uint64_t v32 = v16;
    while (1)
    {
      int v33 = *v32;
      v32 += 3;
      if (!v33) {
        break;
      }
      v30 -= 6;
      uint64_t v31 = v32;
      if (v32 == v18) {
        goto LABEL_45;
      }
    }
    if (v32 == v18)
    {
      unsigned int v18 = v31;
    }
    else
    {
      uint64_t v34 = 3;
      unsigned int v18 = v31;
      do
      {
        uint64_t v35 = &v31[v34];
        if (v31[v34])
        {
          int v36 = *(_DWORD *)v35;
          v18[2] = v35[2];
          *(_DWORD *)unsigned int v18 = v36;
          v18 += 3;
        }
        v34 += 3;
        v30 -= 6;
      }
      while (v30);
      uint64_t v16 = *a3;
    }
  }
  else
  {
    unsigned int v18 = *a3;
  }
LABEL_45:
  *((_DWORD *)a3 + 2) = -1431655765 * ((unint64_t)((char *)v18 - (char *)v16) >> 1);
  return result;
}

void *llvm::StackMaps::print(void *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = this;
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*this + 280);
  if (v4)
  {
    this = (void *)(*(uint64_t (**)(void))(**(void **)(v4 + 16) + 176))(*(void *)(v4 + 16));
    uint64_t v5 = this;
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (llvm::StackMaps::WSMP)
  {
    unint64_t v6 = strlen((const char *)llvm::StackMaps::WSMP);
    this = (void *)*((void *)a2 + 4);
    if (v6 <= *((void *)a2 + 3) - (void)this)
    {
      if (v6)
      {
        this = memcpy(this, (const void *)llvm::StackMaps::WSMP, v6);
        *((void *)a2 + 4) += v6;
      }
    }
    else
    {
      this = llvm::raw_ostream::write(a2, (const char *)llvm::StackMaps::WSMP, v6);
    }
  }
  uint64_t v7 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v7) > 0xA)
  {
    *(_DWORD *)(v7 + 7) = 171602789;
    *(void *)uint64_t v7 = *(void *)"callsites:\n";
    *((void *)a2 + 4) += 11;
  }
  else
  {
    this = llvm::raw_ostream::write(a2, "callsites:\n", 0xBuLL);
  }
  uint64_t v8 = v3[1];
  uint64_t v73 = v3[2];
  if (v8 != v73)
  {
    uint64_t v75 = (void (*)(llvm::raw_ostream *, llvm::raw_ostream *))off_1F2615510;
    while (1)
    {
      int v9 = (unsigned char *)*((void *)a2 + 4);
      if (llvm::StackMaps::WSMP)
      {
        size_t v10 = strlen((const char *)llvm::StackMaps::WSMP);
        size_t v11 = v10;
        if (v10 <= *((void *)a2 + 3) - (void)v9)
        {
          if (v10)
          {
            memcpy(v9, (const void *)llvm::StackMaps::WSMP, v10);
            int v9 = (unsigned char *)(*((void *)a2 + 4) + v11);
            *((void *)a2 + 4) = v9;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, (const char *)llvm::StackMaps::WSMP, v10);
          int v9 = (unsigned char *)*((void *)a2 + 4);
        }
      }
      if (*((void *)a2 + 3) - (void)v9 > 8uLL)
      {
        v9[8] = 32;
        *(void *)int v9 = *(void *)"callsite ";
        *((void *)a2 + 4) += 9;
      }
      else
      {
        llvm::raw_ostream::write(a2, "callsite ", 9uLL);
      }
      sub_1CD098D14(a2, *(void *)(v8 + 8), 0, 0, 0);
      uint64_t v12 = (unsigned char *)*((void *)a2 + 4);
      if (*((unsigned char **)a2 + 3) == v12)
      {
        llvm::raw_ostream::write(a2, "\n", 1uLL);
        uint64_t v13 = (_WORD *)*((void *)a2 + 4);
      }
      else
      {
        *uint64_t v12 = 10;
        uint64_t v13 = (_WORD *)(*((void *)a2 + 4) + 1);
        *((void *)a2 + 4) = v13;
      }
      if (llvm::StackMaps::WSMP)
      {
        size_t v14 = strlen((const char *)llvm::StackMaps::WSMP);
        size_t v15 = v14;
        if (v14 <= *((void *)a2 + 3) - (void)v13)
        {
          if (v14)
          {
            memcpy(v13, (const void *)llvm::StackMaps::WSMP, v14);
            uint64_t v13 = (_WORD *)(*((void *)a2 + 4) + v15);
            *((void *)a2 + 4) = v13;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, (const char *)llvm::StackMaps::WSMP, v14);
          uint64_t v13 = (_WORD *)*((void *)a2 + 4);
        }
      }
      if (*((void *)a2 + 3) - (void)v13 > 5uLL)
      {
        v13[2] = 8307;
        *(_DWORD *)uint64_t v13 = 1634213920;
        *((void *)a2 + 4) += 6;
      }
      else
      {
        llvm::raw_ostream::write(a2, "  has ", 6uLL);
      }
      sub_1CD098D14(a2, *(unsigned int *)(v8 + 24), 0, 0, 0);
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) > 0xA)
      {
        *(_DWORD *)(v16 + 7) = 175337071;
        *(void *)uint64_t v16 = *(void *)" locations\n";
        *((void *)a2 + 4) += 11;
      }
      else
      {
        llvm::raw_ostream::write(a2, " locations\n", 0xBuLL);
      }
      uint64_t v74 = v8;
      unsigned int v17 = *(_DWORD *)(v8 + 24);
      if (v17)
      {
        unint64_t v18 = 0;
        uint64_t v19 = *(void *)(v8 + 16);
        uint64_t v20 = (int *)(v19 + 24 * v17);
        int v21 = (unint64_t *)(v19 + 16);
        while (2)
        {
          unsigned int v22 = (_WORD *)*((void *)a2 + 4);
          if (llvm::StackMaps::WSMP)
          {
            size_t v23 = strlen((const char *)llvm::StackMaps::WSMP);
            size_t v24 = v23;
            if (v23 <= *((void *)a2 + 3) - (void)v22)
            {
              if (v23)
              {
                memcpy(v22, (const void *)llvm::StackMaps::WSMP, v23);
                unsigned int v22 = (_WORD *)(*((void *)a2 + 4) + v24);
                *((void *)a2 + 4) = v22;
              }
            }
            else
            {
              llvm::raw_ostream::write(a2, (const char *)llvm::StackMaps::WSMP, v23);
              unsigned int v22 = (_WORD *)*((void *)a2 + 4);
            }
          }
          if (*((void *)a2 + 3) - (void)v22 > 5uLL)
          {
            v22[2] = 8291;
            *(_DWORD *)unsigned int v22 = 1867254025;
            *((void *)a2 + 4) += 6;
          }
          else
          {
            llvm::raw_ostream::write(a2, "\t\tLoc ", 6uLL);
          }
          sub_1CD098D14(a2, v18, 0, 0, 0);
          int v25 = (_WORD *)*((void *)a2 + 4);
          if (*((void *)a2 + 3) - (void)v25 > 1uLL)
          {
            *int v25 = 8250;
            *((void *)a2 + 4) += 2;
          }
          else
          {
            llvm::raw_ostream::write(a2, ": ", 2uLL);
          }
          BOOL v26 = v21 - 2;
          switch(*((_DWORD *)v21 - 4))
          {
            case 0:
              int v27 = (void *)*((void *)a2 + 4);
              if (*((void *)a2 + 3) - (void)v27 > 0x14uLL)
              {
                qmemcpy(v27, "<Unprocessed operand>", 21);
                *((void *)a2 + 4) += 21;
              }
              else
              {
                llvm::raw_ostream::write(a2, "<Unprocessed operand>", 0x15uLL);
              }
              goto LABEL_76;
            case 1:
              uint64_t v38 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v38) > 8)
              {
                *(unsigned char *)(v38 + 8) = 32;
                *(void *)uint64_t v38 = *(void *)"Register ";
                *((void *)a2 + 4) += 9;
                if (!v5)
                {
LABEL_102:
                  sub_1CD098D14(a2, *((unsigned int *)v21 - 2), 0, 0, 0);
                  goto LABEL_76;
                }
              }
              else
              {
                llvm::raw_ostream::write(a2, "Register ", 9uLL);
                if (!v5) {
                  goto LABEL_102;
                }
              }
              int v39 = *((_DWORD *)v21 - 2);
              uint64_t v40 = operator new(0x28uLL);
              *(void *)uint64_t v40 = &unk_1F26154E0;
              v40[2] = v39;
              *((void *)v40 + 2) = v5;
              v40[6] = 0;
              *((void *)v40 + 4) = 0;
              unsigned int v77 = v40;
              v75((llvm::raw_ostream *)v40, a2);
              if (v77 == v76)
              {
                (*(void (**)(void *))(v76[0] + 32))(v76);
              }
              else if (v77)
              {
                (*(void (**)(void))(*v77 + 40))();
              }
LABEL_76:
              uint64_t v45 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v45) > 0x11)
              {
                *(_WORD *)(v45 + 16) = 8293;
                *(_OWORD *)uint64_t v45 = *(_OWORD *)"\t[encoding: .byte ";
                *((void *)a2 + 4) += 18;
              }
              else
              {
                llvm::raw_ostream::write(a2, "\t[encoding: .byte ", 0x12uLL);
              }
              unint64_t v46 = *(int *)v26;
              if ((v46 & 0x80000000) != 0)
              {
                unint64_t v46 = -(uint64_t)v46;
                long long v47 = a2;
                int v48 = 1;
              }
              else
              {
                long long v47 = a2;
                int v48 = 0;
              }
              sub_1CD098D14(v47, v46, 0, 0, v48);
              uint64_t v49 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v49) > 8)
              {
                *(unsigned char *)(v49 + 8) = 48;
                *(void *)uint64_t v49 = *(void *)", .byte 0";
                uint64_t v50 = *((void *)a2 + 4) + 9;
                *((void *)a2 + 4) = v50;
              }
              else
              {
                llvm::raw_ostream::write(a2, ", .byte 0", 9uLL);
                uint64_t v50 = *((void *)a2 + 4);
              }
              if ((unint64_t)(*((void *)a2 + 3) - v50) > 8)
              {
                *(unsigned char *)(v50 + 8) = 32;
                *(void *)uint64_t v50 = *(void *)", .short ";
                *((void *)a2 + 4) += 9;
              }
              else
              {
                llvm::raw_ostream::write(a2, ", .short ", 9uLL);
              }
              sub_1CD098D14(a2, *((unsigned int *)v21 - 3), 0, 0, 0);
              uint64_t v51 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v51) > 8)
              {
                *(unsigned char *)(v51 + 8) = 32;
                *(void *)uint64_t v51 = *(void *)", .short ";
                *((void *)a2 + 4) += 9;
              }
              else
              {
                llvm::raw_ostream::write(a2, ", .short ", 9uLL);
              }
              sub_1CD098D14(a2, *((unsigned int *)v21 - 2), 0, 0, 0);
              uint64_t v52 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v52) > 9)
              {
                *(_WORD *)(v52 + 8) = 12320;
                *(void *)uint64_t v52 = *(void *)", .short 0";
                uint64_t v53 = (_DWORD *)(*((void *)a2 + 4) + 10);
                *((void *)a2 + 4) = v53;
              }
              else
              {
                llvm::raw_ostream::write(a2, ", .short 0", 0xAuLL);
                uint64_t v53 = (_DWORD *)*((void *)a2 + 4);
              }
              if (*((void *)a2 + 3) - (void)v53 > 6uLL)
              {
                *(_DWORD *)((char *)v53 + 3) = 544501353;
                *uint64_t v53 = 1764630572;
                *((void *)a2 + 4) += 7;
              }
              else
              {
                llvm::raw_ostream::write(a2, ", .int ", 7uLL);
              }
              llvm::raw_ostream::operator<<(a2, *v21);
              uint64_t v54 = (_WORD *)*((void *)a2 + 4);
              if (*((void *)a2 + 3) - (void)v54 > 1uLL)
              {
                *uint64_t v54 = 2653;
                *((void *)a2 + 4) += 2;
              }
              else
              {
                llvm::raw_ostream::write(a2, "]\n", 2uLL);
              }
              ++v18;
              v21 += 3;
              if (v26 + 3 == (unint64_t *)v20) {
                break;
              }
              continue;
            case 2:
              uint64_t v32 = (_DWORD *)*((void *)a2 + 4);
              if (*((void *)a2 + 3) - (void)v32 > 6uLL)
              {
                *(_DWORD *)((char *)v32 + 3) = 544498533;
                *uint64_t v32 = 1701996868;
                *((void *)a2 + 4) += 7;
                if (!v5)
                {
LABEL_66:
                  sub_1CD098D14(a2, *((unsigned int *)v21 - 2), 0, 0, 0);
                  goto LABEL_67;
                }
              }
              else
              {
                llvm::raw_ostream::write(a2, "Direct ", 7uLL);
                if (!v5) {
                  goto LABEL_66;
                }
              }
              int v33 = *((_DWORD *)v21 - 2);
              uint64_t v34 = operator new(0x28uLL);
              *(void *)uint64_t v34 = &unk_1F26154E0;
              v34[2] = v33;
              *((void *)v34 + 2) = v5;
              v34[6] = 0;
              *((void *)v34 + 4) = 0;
              unsigned int v77 = v34;
              v75((llvm::raw_ostream *)v34, a2);
              if (v77 == v76)
              {
                (*(void (**)(void *))(v76[0] + 32))(v76);
              }
              else if (v77)
              {
                (*(void (**)(void))(*v77 + 40))();
              }
LABEL_67:
              if (*v21)
              {
                uint64_t v43 = *((void *)a2 + 4);
                if ((unint64_t)(*((void *)a2 + 3) - v43) <= 2)
                {
                  int v29 = a2;
                  uint64_t v30 = " + ";
                  size_t v31 = 3;
                  goto LABEL_74;
                }
                *(unsigned char *)(v43 + 2) = 32;
                *(_WORD *)uint64_t v43 = 11040;
                uint64_t v42 = *((void *)a2 + 4) + 3;
                goto LABEL_106;
              }
              goto LABEL_76;
            case 3:
              uint64_t v35 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v35) > 8)
              {
                *(unsigned char *)(v35 + 8) = 32;
                *(void *)uint64_t v35 = *(void *)"Indirect ";
                *((void *)a2 + 4) += 9;
                if (v5)
                {
LABEL_46:
                  int v36 = *((_DWORD *)v21 - 2);
                  uint64_t v37 = operator new(0x28uLL);
                  *(void *)uint64_t v37 = &unk_1F26154E0;
                  v37[2] = v36;
                  *((void *)v37 + 2) = v5;
                  v37[6] = 0;
                  *((void *)v37 + 4) = 0;
                  unsigned int v77 = v37;
                  v75((llvm::raw_ostream *)v37, a2);
                  if (v77 == v76)
                  {
                    (*(void (**)(void *))(v76[0] + 32))(v76);
                  }
                  else if (v77)
                  {
                    (*(void (**)(void))(*v77 + 40))();
                  }
                  goto LABEL_72;
                }
              }
              else
              {
                llvm::raw_ostream::write(a2, "Indirect ", 9uLL);
                if (v5) {
                  goto LABEL_46;
                }
              }
              sub_1CD098D14(a2, *((unsigned int *)v21 - 2), 0, 0, 0);
LABEL_72:
              int v44 = (unsigned char *)*((void *)a2 + 4);
              if (*((unsigned char **)a2 + 3) == v44)
              {
                int v29 = a2;
                uint64_t v30 = "+";
                size_t v31 = 1;
                goto LABEL_74;
              }
              *int v44 = 43;
              uint64_t v42 = *((void *)a2 + 4) + 1;
              goto LABEL_106;
            case 4:
              uint64_t v28 = *((void *)a2 + 4);
              if ((unint64_t)(*((void *)a2 + 3) - v28) <= 8)
              {
                int v29 = a2;
                uint64_t v30 = "Constant ";
                size_t v31 = 9;
                goto LABEL_74;
              }
              *(unsigned char *)(v28 + 8) = 32;
              *(void *)uint64_t v28 = *(void *)"Constant ";
              uint64_t v42 = *((void *)a2 + 4) + 9;
              goto LABEL_106;
            case 5:
              unint64_t v41 = (void *)*((void *)a2 + 4);
              if (*((void *)a2 + 3) - (void)v41 > 0xEuLL)
              {
                qmemcpy(v41, "Constant Index ", 15);
                uint64_t v42 = *((void *)a2 + 4) + 15;
LABEL_106:
                *((void *)a2 + 4) = v42;
              }
              else
              {
                int v29 = a2;
                uint64_t v30 = "Constant Index ";
                size_t v31 = 15;
LABEL_74:
                llvm::raw_ostream::write(v29, v30, v31);
              }
              llvm::raw_ostream::operator<<(a2, *v21);
              goto LABEL_76;
            default:
              goto LABEL_76;
          }
          break;
        }
      }
      unsigned int v55 = (unsigned char *)*((void *)a2 + 4);
      if (llvm::StackMaps::WSMP)
      {
        size_t v56 = strlen((const char *)llvm::StackMaps::WSMP);
        size_t v57 = v56;
        uint64_t v58 = v74;
        if (v56 <= *((void *)a2 + 3) - (void)v55)
        {
          if (v56)
          {
            memcpy(v55, (const void *)llvm::StackMaps::WSMP, v56);
            unsigned int v55 = (unsigned char *)(*((void *)a2 + 4) + v57);
            *((void *)a2 + 4) = v55;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, (const char *)llvm::StackMaps::WSMP, v56);
          unsigned int v55 = (unsigned char *)*((void *)a2 + 4);
        }
      }
      else
      {
        uint64_t v58 = v74;
      }
      if (*((void *)a2 + 3) - (void)v55 > 4uLL)
      {
        v55[4] = 32;
        *(_DWORD *)unsigned int v55 = 1935763465;
        *((void *)a2 + 4) += 5;
      }
      else
      {
        llvm::raw_ostream::write(a2, "\thas ", 5uLL);
      }
      this = sub_1CD098D14(a2, *(unsigned int *)(v58 + 232), 0, 0, 0);
      uint64_t v59 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v59) > 0x13)
      {
        *(_DWORD *)(v59 + 16) = 175338085;
        *(_OWORD *)uint64_t v59 = *(_OWORD *)" live-out registers\n";
        *((void *)a2 + 4) += 20;
      }
      else
      {
        this = llvm::raw_ostream::write(a2, " live-out registers\n", 0x14uLL);
      }
      uint64_t v60 = *(unsigned int *)(v58 + 232);
      if (v60) {
        break;
      }
LABEL_144:
      uint64_t v8 = v74 + 288;
      if (v74 + 288 == v73) {
        return this;
      }
    }
    unint64_t v61 = 0;
    uint64_t v62 = *(unsigned __int16 **)(v74 + 224);
    uint64_t v63 = 6 * v60;
    while (1)
    {
      unsigned int v64 = (unsigned char *)*((void *)a2 + 4);
      if (llvm::StackMaps::WSMP)
      {
        size_t v65 = strlen((const char *)llvm::StackMaps::WSMP);
        size_t v66 = v65;
        if (v65 <= *((void *)a2 + 3) - (void)v64)
        {
          if (v65)
          {
            memcpy(v64, (const void *)llvm::StackMaps::WSMP, v65);
            unsigned int v64 = (unsigned char *)(*((void *)a2 + 4) + v66);
            *((void *)a2 + 4) = v64;
          }
        }
        else
        {
          llvm::raw_ostream::write(a2, (const char *)llvm::StackMaps::WSMP, v65);
          unsigned int v64 = (unsigned char *)*((void *)a2 + 4);
        }
      }
      if (*((void *)a2 + 3) - (void)v64 > 4uLL)
      {
        v64[4] = 32;
        *(_DWORD *)unsigned int v64 = 1330383113;
        *((void *)a2 + 4) += 5;
      }
      else
      {
        llvm::raw_ostream::write(a2, "\t\tLO ", 5uLL);
      }
      sub_1CD098D14(a2, v61, 0, 0, 0);
      unsigned int v67 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v67 > 1uLL)
      {
        _WORD *v67 = 8250;
        *((void *)a2 + 4) += 2;
        if (v5)
        {
LABEL_124:
          int v68 = *v62;
          uint64_t v69 = operator new(0x28uLL);
          *(void *)uint64_t v69 = &unk_1F26154E0;
          v69[2] = v68;
          *((void *)v69 + 2) = v5;
          v69[6] = 0;
          *((void *)v69 + 4) = 0;
          unsigned int v77 = v69;
          v75((llvm::raw_ostream *)v69, a2);
          if (v77 == v76)
          {
            (*(void (**)(void *))(v76[0] + 32))(v76);
          }
          else if (v77)
          {
            (*(void (**)(void))(*v77 + 40))();
          }
          goto LABEL_131;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, ": ", 2uLL);
        if (v5) {
          goto LABEL_124;
        }
      }
      sub_1CD098D14(a2, *v62, 0, 0, 0);
LABEL_131:
      uint64_t v70 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v70) > 0x12)
      {
        *(_DWORD *)(v70 + 15) = 544502383;
        *(_OWORD *)uint64_t v70 = *(_OWORD *)"\t[encoding: .short ";
        *((void *)a2 + 4) += 19;
      }
      else
      {
        llvm::raw_ostream::write(a2, "\t[encoding: .short ", 0x13uLL);
      }
      sub_1CD098D14(a2, v62[1], 0, 0, 0);
      uint64_t v71 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v71) > 0x10)
      {
        *(unsigned char *)(v71 + 16) = 32;
        *(_OWORD *)uint64_t v71 = *(_OWORD *)", .byte 0, .byte ";
        *((void *)a2 + 4) += 17;
      }
      else
      {
        llvm::raw_ostream::write(a2, ", .byte 0, .byte ", 0x11uLL);
      }
      this = sub_1CD098D14(a2, v62[2], 0, 0, 0);
      unsigned int v72 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v72 > 1uLL)
      {
        *unsigned int v72 = 2653;
        *((void *)a2 + 4) += 2;
      }
      else
      {
        this = llvm::raw_ostream::write(a2, "]\n", 2uLL);
      }
      ++v61;
      v62 += 3;
      v63 -= 6;
      if (!v63) {
        goto LABEL_144;
      }
    }
  }
  return this;
}

unint64_t llvm::StackMaps::createLiveOutReg(llvm::StackMaps *this, unsigned int a2, const llvm::TargetRegisterInfo *a3)
{
  int v5 = sub_1CC488510(a2, (uint64_t)a3);
  unint64_t v6 = 0;
  uint64_t v7 = (uint64_t **)*((void *)a3 + 31);
  unint64_t v8 = (unint64_t)a2 >> 3;
  int v9 = (uint64_t **)*((void *)a3 + 30);
  do
  {
    if (a2 - 0x40000000 >= 0xC0000001)
    {
      uint64_t v10 = **v9;
      if (v8 < *(unsigned __int16 *)(v10 + 22)
        && ((1 << (a2 & 7)) & *(unsigned __int8 *)(*(void *)(v10 + 8) + v8)) != 0
        && (!v6
         || *v9 != v6
         && ((*(_DWORD *)(v6[1] + ((*(unsigned __int16 *)(v10 + 24) >> 3) & 0x1FFCLL)) >> *(_WORD *)(v10 + 24)) & 1) != 0))
      {
        unint64_t v6 = *v9;
      }
    }
    ++v9;
  }
  while (v9 != v7);
  return (v5 << 16) | ((unint64_t)(*(_DWORD *)(*((void *)a3 + 33)
                                                                  + 24
                                                                  * (*(unsigned __int16 *)(*v6 + 24)
                                                                   + *((_DWORD *)a3 + 68)
                                                                   * (((unint64_t)v7
                                                                                   - *((void *)a3 + 30)) >> 3))
                                                                  + 4) >> 3) << 32) | (unsigned __int16)a2;
}

void llvm::StackMaps::parseStatepointOpers(llvm::StackMaps *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48[4] = *MEMORY[0x1E4F143B8];
  uint64_t v41 = a2;
  uint64_t v10 = *(void *)(a2 + 16);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 4);
  if ((*(unsigned char *)(v10 + 8) & 2) == 0 || (int v26 = *(_DWORD *)(a2 + 40), v26 == v11))
  {
    int v12 = *(unsigned __int8 *)(v10 + 4);
  }
  else
  {
    int v27 = v26 - 1;
    int v12 = *(unsigned __int8 *)(v10 + 4);
    do
    {
      int v28 = *(_DWORD *)(*(void *)(a2 + 32) + 32 * v11);
      if ((v28 & 0x10000FF) != 0x1000000) {
        break;
      }
      v12 += (v28 & 0x2000000) == 0;
      if (v27 == v11) {
        break;
      }
      ++v11;
    }
    while ((v28 & 0x2000000) == 0);
  }
  uint64_t v13 = *(void *)(v10 + 32);
  if (v13)
  {
    unsigned int v14 = -1;
    do
      ++v14;
    while (*(_WORD *)(v13 + 2 * v14));
  }
  else
  {
    unsigned int v14 = 0;
  }
  int v42 = v14 + v12;
  size_t v15 = llvm::StackMaps::parseOperand(a1, a3, (uint64_t)a3, a5, a6);
  unsigned int v17 = llvm::StackMaps::parseOperand(a1, v15, v16, a5, a6);
  uint64_t v19 = llvm::StackMaps::parseOperand(a1, v17, v18, a5, a6);
  for (int i = *(_DWORD *)(*(void *)a5 + 24 * *(unsigned int *)(a5 + 8) - 8);
        i;
        uint64_t v19 = llvm::StackMaps::parseOperand(a1, v19, v20, a5, a6))
  {
    --i;
  }
  int v22 = v19[12];
  if (v22)
  {
    unint64_t v46 = v48;
    uint64_t v47 = 0x800000000;
    unsigned int NumGCPtrIdx = llvm::StatepointOpers::getNumGCPtrIdx((llvm::StatepointOpers *)&v41);
    unsigned int v30 = 0;
    if (*(_DWORD *)(*(void *)(a2 + 32) + 32 * NumGCPtrIdx + 16)) {
      LODWORD(v31) = NumGCPtrIdx + 1;
    }
    else {
      LODWORD(v31) = -1;
    }
    do
    {
      if (v30 >= HIDWORD(v47)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v46 + v30) = v31;
      unsigned int v30 = v47 + 1;
      LODWORD(v47) = v47 + 1;
      uint64_t v32 = *(void *)(a2 + 32);
      if (*(unsigned char *)(v32 + 32 * v31) == 1)
      {
        uint64_t v33 = *(void *)(v32 + 32 * v31 + 16);
        if (v33)
        {
          if (v33 == 1) {
            LODWORD(v31) = v31 + 3;
          }
          else {
            LODWORD(v31) = v31 + 1;
          }
        }
        else
        {
          LODWORD(v31) = v31 + 2;
        }
      }
      uint64_t v31 = (v31 + 1);
      --v22;
    }
    while (v22);
    uint64_t v43 = v45;
    uint64_t v44 = 0x800000000;
    llvm::StatepointOpers::getGCPointerMap((llvm::StatepointOpers *)&v41, (uint64_t)&v43);
    uint64_t v34 = *(void *)(a2 + 32);
    uint64_t v35 = (unsigned int *)v43;
    if (v44)
    {
      int v36 = (unsigned int *)((char *)v43 + 8 * v44);
      do
      {
        uint64_t v37 = *v35;
        uint64_t v38 = v35[1];
        v35 += 2;
        uint64_t v39 = *((unsigned int *)v46 + v38);
        llvm::StackMaps::parseOperand(a1, (int *)(v34 + 32 * *((unsigned int *)v46 + v37)), v20, a5, a6);
        llvm::StackMaps::parseOperand(a1, (int *)(v34 + 32 * v39), v40, a5, a6);
      }
      while (v35 != v36);
      uint64_t v35 = (unsigned int *)v43;
    }
    if (v35 != (unsigned int *)v45) {
      free(v35);
    }
    size_t v23 = (int *)(v34 + 32 * v31);
    if (v46 != v48) {
      free(v46);
    }
  }
  else
  {
    size_t v23 = v19 + 16;
  }
  int v24 = v23[12];
  if (v24)
  {
    int v25 = v23 + 16;
    do
    {
      --v24;
      int v25 = llvm::StackMaps::parseOperand(a1, v25, v20, a5, a6);
    }
    while (v24);
  }
}

void llvm::StackMaps::recordStackMapOpers(llvm::StackMaps *this, const llvm::MCSymbol *a2, int **a3, uint64_t a4, const llvm::MachineOperand *a5, const llvm::MachineOperand *a6, int a7)
{
  v106[24] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)(*(void *)(*(void *)this + 272) + 8);
  size_t v104 = v106;
  uint64_t v105 = 0x800000000;
  v102[0] = v103;
  v102[1] = (void *)0x800000000;
  if (a7) {
    llvm::StackMaps::parseOperand(this, a3[4], (uint64_t)a3, (uint64_t)&v104, (uint64_t)v102);
  }
  uint64_t v95 = v12;
  uint64_t v96 = a2;
  if (*(_WORD *)a3[2] == 31)
  {
    llvm::StackMaps::parseStatepointOpers(this, (uint64_t)a3, (int *)a5, a4, (uint64_t)&v104, (uint64_t)v102);
  }
  else
  {
    for (;
          a5 != a6;
          a5 = (const llvm::MachineOperand *)llvm::StackMaps::parseOperand(this, (int *)a5, (uint64_t)a3, (uint64_t)&v104, (uint64_t)v102))
    {
      ;
    }
  }
  if (v105)
  {
    uint64_t v13 = (char *)v104;
    unsigned int v14 = (char *)v104 + 24 * v105;
    size_t v15 = (char *)this + 32;
    do
    {
      if (*(_DWORD *)v13 == 4)
      {
        uint64_t v16 = (void *)*((void *)v13 + 2);
        if (v16 != (void *)(int)v16)
        {
          *(_DWORD *)uint64_t v13 = 5;
          uint64_t v97 = v16;
          int v98 = 0;
          sub_1CC48C3BC((uint64_t)v15, (uint64_t *)&v97, &v98, (uint64_t)&v99);
          if (v101)
          {
            uint64_t v18 = (int64x2_t *)*((void *)this + 7);
            unsigned int v17 = (int64x2_t *)*((void *)this + 8);
            uint64_t v19 = (char *)v17 - (char *)v18;
            *(_DWORD *)(v99 + 8) = (unint64_t)((char *)v17 - (char *)v18) >> 4;
            unint64_t v20 = *((void *)this + 9);
            if ((unint64_t)v17 >= v20)
            {
              int v24 = v15;
              uint64_t v25 = v19 >> 4;
              unint64_t v26 = (v19 >> 4) + 1;
              if (v26 >> 60) {
                goto LABEL_112;
              }
              uint64_t v27 = v20 - (void)v18;
              if (v27 >> 3 > v26) {
                unint64_t v26 = v27 >> 3;
              }
              if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v28 = v26;
              }
              if (v28 >> 60) {
                goto LABEL_113;
              }
              int v29 = (char *)operator new(16 * v28);
              unsigned int v30 = (int64x2_t *)&v29[16 * v25];
              *unsigned int v30 = vdupq_n_s64((unint64_t)v16);
              int v21 = v30 + 1;
              if (v17 == v18)
              {
                uint64_t v31 = (int64x2_t *)&v29[16 * v25];
                size_t v15 = v24;
              }
              else
              {
                size_t v15 = v24;
                do
                {
                  uint64_t v31 = v30 - 1;
                  v30[-1] = v17[-1];
                  --v17;
                  --v30;
                }
                while (v17 != v18);
              }
              *((void *)this + 7) = v31;
              *((void *)this + 8) = v21;
              *((void *)this + 9) = &v29[16 * v28];
              if (v18) {
                operator delete(v18);
              }
            }
            else
            {
              v17->i64[0] = (uint64_t)v16;
              v17->i64[1] = (uint64_t)v16;
              int v21 = v17 + 1;
            }
            *((void *)this + 8) = v21;
            size_t v23 = v21 - 1;
            uint64_t v22 = *((void *)this + 7);
          }
          else
          {
            uint64_t v22 = *((void *)this + 7);
            size_t v23 = (int64x2_t *)(v22 + 16 * *(unsigned int *)(v99 + 8));
          }
          *((void *)v13 + 2) = ((uint64_t)v23->i64 - v22) >> 4;
        }
      }
      v13 += 24;
    }
    while (v13 != v14);
  }
  *(void *)(v95 + 272) += 24;
  uint64_t v32 = *(void *)(v95 + 192);
  if (((v32 + 7) & 0xFFFFFFFFFFFFFFF8) - v32 + 24 > *(void *)(v95 + 200) - v32)
  {
    unsigned int v85 = *(_DWORD *)(v95 + 216) >> 7;
    if (v85 >= 0x1E) {
      LOBYTE(v85) = 30;
    }
    uint64_t v86 = 4096 << v85;
    unint64_t v33 = (unint64_t)operator new(4096 << v85, (std::align_val_t)8uLL);
    unsigned int v87 = *(_DWORD *)(v95 + 216);
    uint64_t v34 = v96;
    if (v87 >= *(_DWORD *)(v95 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v95 + 208) + 8 * v87) = v33;
    ++*(_DWORD *)(v95 + 216);
    *(void *)(v95 + 200) = v33 + v86;
  }
  else
  {
    unint64_t v33 = (v32 + 7) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v34 = v96;
  }
  *(void *)(v95 + 192) = v33 + 24;
  int v35 = *(unsigned __int8 *)(*(void *)(v95 + 152) + 18) << 16;
  *(unsigned char *)unint64_t v33 = 2;
  *(_DWORD *)(v33 + 1) = v35 | (*(unsigned __int8 *)(v33 + 4) << 24);
  *(void *)(v33 + 8) = 0;
  *(void *)(v33 + 16) = v34;
  uint64_t v36 = *(void *)(*(void *)this + 344);
  *(void *)(v95 + 272) += 24;
  uint64_t v37 = *(void *)(v95 + 192);
  if (((v37 + 7) & 0xFFFFFFFFFFFFFFF8) - v37 + 24 > *(void *)(v95 + 200) - v37)
  {
    unsigned int v88 = *(_DWORD *)(v95 + 216) >> 7;
    if (v88 >= 0x1E) {
      LOBYTE(v88) = 30;
    }
    uint64_t v89 = 4096 << v88;
    unint64_t v38 = (unint64_t)operator new(4096 << v88, (std::align_val_t)8uLL);
    unsigned int v90 = *(_DWORD *)(v95 + 216);
    if (v90 >= *(_DWORD *)(v95 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v95 + 208) + 8 * v90) = v38;
    ++*(_DWORD *)(v95 + 216);
    *(void *)(v95 + 200) = v38 + v89;
  }
  else
  {
    unint64_t v38 = (v37 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v95 + 192) = v38 + 24;
  int v39 = *(unsigned __int8 *)(*(void *)(v95 + 152) + 18) << 16;
  *(unsigned char *)unint64_t v38 = 2;
  *(_DWORD *)(v38 + 1) = v39 | (*(unsigned __int8 *)(v38 + 4) << 24);
  *(void *)(v38 + 8) = 0;
  *(void *)(v38 + 16) = v36;
  *(void *)(v95 + 272) += 32;
  uint64_t v40 = *(void *)(v95 + 192);
  if (((v40 + 7) & 0xFFFFFFFFFFFFFFF8) - v40 + 32 > *(void *)(v95 + 200) - v40)
  {
    unsigned int v91 = *(_DWORD *)(v95 + 216) >> 7;
    if (v91 >= 0x1E) {
      LOBYTE(v91) = 30;
    }
    uint64_t v92 = 4096 << v91;
    uint64_t v41 = (uint64_t)operator new(4096 << v91, (std::align_val_t)8uLL);
    unsigned int v93 = *(_DWORD *)(v95 + 216);
    if (v93 >= *(_DWORD *)(v95 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v95 + 208) + 8 * v93) = v41;
    ++*(_DWORD *)(v95 + 216);
    *(void *)(v95 + 200) = v41 + v92;
  }
  else
  {
    uint64_t v41 = (v40 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v95 + 192) = v41 + 32;
  *(unsigned char *)uint64_t v41 = 0;
  *(_DWORD *)(v41 + 1) = (*(unsigned __int8 *)(v41 + 4) << 24) | 0x12;
  *(void *)(v41 + 8) = 0;
  *(void *)(v41 + 16) = v33;
  *(void *)(v41 + 24) = v38;
  int v42 = (void *)*((void *)this + 2);
  unint64_t v43 = *((void *)this + 3);
  if ((unint64_t)v42 >= v43)
  {
    uint64_t v45 = *((void *)this + 1);
    unint64_t v46 = 0x8E38E38E38E38E39 * (((uint64_t)v42 - v45) >> 5);
    if (v46 + 1 > 0xE38E38E38E38E3) {
      goto LABEL_112;
    }
    unint64_t v47 = 0x8E38E38E38E38E39 * ((uint64_t)(v43 - v45) >> 5);
    uint64_t v48 = 2 * v47;
    if (2 * v47 <= v46 + 1) {
      uint64_t v48 = v46 + 1;
    }
    if (v47 >= 0x71C71C71C71C71) {
      unint64_t v49 = 0xE38E38E38E38E3;
    }
    else {
      unint64_t v49 = v48;
    }
    if (v49)
    {
      if (v49 > 0xE38E38E38E38E3) {
        goto LABEL_113;
      }
      uint64_t v50 = (char *)operator new(288 * v49);
    }
    else
    {
      uint64_t v50 = 0;
    }
    uint64_t v51 = &v50[288 * v46];
    uint64_t v52 = &v50[288 * v49];
    sub_1CC48C4B0(v51, v41, a4, (uint64_t)&v104, (uint64_t)v102);
    uint64_t v44 = v51 + 288;
    uint64_t v54 = (char *)*((void *)this + 1);
    uint64_t v53 = (char *)*((void *)this + 2);
    if (v53 == v54)
    {
      *((void *)this + 1) = v51;
      *((void *)this + 2) = v44;
      *((void *)this + 3) = v52;
    }
    else
    {
      uint64_t v55 = 0;
      do
      {
        size_t v56 = &v51[v55];
        size_t v57 = &v53[v55];
        *(_OWORD *)&v51[v55 - 288] = *(_OWORD *)&v53[v55 - 288];
        uint64_t v58 = &v51[v55 - 272];
        *(void *)uint64_t v58 = &v51[v55 - 256];
        *(void *)&v51[v55 - 264] = 0x800000000;
        if (*(_DWORD *)&v53[v55 - 264]) {
          sub_1CB831C80((uint64_t)v58, (uint64_t)(v57 - 272));
        }
        *((void *)v56 - 8) = v56 - 48;
        uint64_t v59 = (uint64_t)(v56 - 64);
        *(void *)(v59 + 8) = 0x800000000;
        if (*((_DWORD *)v57 - 14)) {
          sub_1CC48B538(v59, (uint64_t)&v53[v55 - 64]);
        }
        v55 -= 288;
      }
      while (&v53[v55] != v54);
      uint64_t v53 = (char *)*((void *)this + 1);
      uint64_t v60 = (char *)*((void *)this + 2);
      *((void *)this + 1) = &v51[v55];
      *((void *)this + 2) = v44;
      *((void *)this + 3) = v52;
      while (v60 != v53)
      {
        unint64_t v61 = (char *)*((void *)v60 - 8);
        if (v60 - 48 != v61) {
          free(v61);
        }
        uint64_t v62 = (char *)*((void *)v60 - 34);
        if (v60 - 256 != v62) {
          free(v62);
        }
        v60 -= 288;
      }
    }
    if (v53) {
      operator delete(v53);
    }
  }
  else
  {
    uint64_t v44 = sub_1CC48C4B0(v42, v41, a4, (uint64_t)&v104, (uint64_t)v102) + 36;
  }
  *((void *)this + 2) = v44;
  uint64_t v63 = *(void *)(*(void *)this + 280);
  uint64_t v64 = *(void *)(v63 + 56);
  uint64_t v65 = (*(uint64_t (**)(void))(**(void **)(v63 + 16) + 176))(*(void *)(v63 + 16));
  if (*(unsigned char *)(v64 + 36)
    || (uint64_t v67 = v65,
        uint64_t v68 = *(void *)(*(void *)this + 280),
        (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v65 + 440))(v65, v68))
    && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v67 + 432))(v67, v68) & 1) != 0)
  {
    uint64_t v66 = -1;
  }
  else
  {
    uint64_t v66 = *(void *)(v64 + 48);
  }
  uint64_t v97 = *(void **)(*(void *)this + 328);
  uint64_t v99 = 0;
  if (sub_1CC48C528((uint64_t *)this + 10, &v97, &v99))
  {
    if (v99 != *((void *)this + 10) + 16 * *((unsigned int *)this + 24))
    {
      unsigned int v69 = *(_DWORD *)(v99 + 8);
      uint64_t v70 = *((void *)this + 13);
      if (*((void *)this + 14) != v70 + 24 * v69)
      {
        ++*(void *)(v70 + 24 * v69 + 16);
        goto LABEL_77;
      }
    }
  }
  uint64_t v71 = *(void *)(*(void *)this + 328);
  uint64_t v99 = v71;
  int v100 = 0;
  uint64_t v97 = 0;
  if ((sub_1CC48C528((uint64_t *)this + 10, &v99, &v97) & 1) == 0)
  {
    unsigned int v72 = sub_1CD57D368((uint64_t)this + 80, (uint64_t)&v99, &v99, v97);
    *unsigned int v72 = v99;
    uint64_t v74 = (char *)*((void *)this + 13);
    uint64_t v73 = (char *)*((void *)this + 14);
    uint64_t v75 = (v73 - v74) / 24;
    *((_DWORD *)v72 + 2) = v75;
    unint64_t v76 = *((void *)this + 15);
    if ((unint64_t)v73 < v76)
    {
      *(void *)uint64_t v73 = v71;
      *((void *)v73 + 1) = v66;
      *((void *)v73 + 2) = 1;
      unsigned int v77 = v73 + 24;
LABEL_108:
      *((void *)this + 14) = v77;
      goto LABEL_77;
    }
    unint64_t v78 = v75 + 1;
    if ((unint64_t)(v75 + 1) <= 0xAAAAAAAAAAAAAAALL)
    {
      unint64_t v79 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v76 - (void)v74) >> 3);
      if (2 * v79 > v78) {
        unint64_t v78 = 2 * v79;
      }
      if (v79 >= 0x555555555555555) {
        unint64_t v80 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v80 = v78;
      }
      if (v80 <= 0xAAAAAAAAAAAAAAALL)
      {
        uint64_t v81 = 3 * v80;
        uint64_t v82 = (char *)operator new(24 * v80);
        int v83 = &v82[24 * v75];
        *(void *)int v83 = v71;
        *((void *)v83 + 1) = v66;
        *((void *)v83 + 2) = 1;
        unsigned int v77 = v83 + 24;
        if (v73 != v74)
        {
          do
          {
            long long v84 = *(_OWORD *)(v73 - 24);
            *((void *)v83 - 1) = *((void *)v73 - 1);
            *(_OWORD *)(v83 - 24) = v84;
            v83 -= 24;
            v73 -= 24;
          }
          while (v73 != v74);
          uint64_t v73 = v74;
        }
        *((void *)this + 13) = v83;
        *((void *)this + 14) = v77;
        *((void *)this + 15) = &v82[8 * v81];
        if (v73) {
          operator delete(v73);
        }
        goto LABEL_108;
      }
LABEL_113:
      sub_1CB833614();
    }
LABEL_112:
    abort();
  }
LABEL_77:
  if (v102[0] != v103) {
    free(v102[0]);
  }
  if (v104 != v106) {
    free(v104);
  }
}

void llvm::StackMaps::recordStackMap(llvm::StackMaps *this, const llvm::MCSymbol *a2, int **a3)
{
}

void llvm::StackMaps::recordPatchPoint(llvm::StackMaps *this, const llvm::MCSymbol *a2, const llvm::MachineInstr *a3)
{
  uint64_t v3 = (_DWORD *)*((void *)a3 + 4);
  int v4 = *v3 & 0x30000FF;
  int v5 = &v3[8 * (v4 == 0x1000000)];
  uint64_t v6 = *((void *)v5 + 2);
  uint64_t v7 = v5[36];
  uint64_t v8 = 5;
  if (v4 == 0x1000000) {
    uint64_t v8 = 6;
  }
  if (v7 != 13)
  {
    uint64_t v9 = 24;
    if (v4 == 0x1000000) {
      uint64_t v9 = 32;
    }
    uint64_t v8 = (v3[v9 + 4] + v8);
  }
  BOOL v11 = v4 == 0x1000000 && v7 == 13;
  llvm::StackMaps::recordStackMapOpers(this, a2, (int **)a3, v6, (const llvm::MachineOperand *)&v3[8 * v8], (const llvm::MachineOperand *)&v3[8 * *((unsigned int *)a3 + 10)], v11);
}

void llvm::StackMaps::recordStatepoint(llvm::StackMaps *this, const llvm::MCSymbol *a2, const llvm::MachineInstr *a3)
{
  uint64_t v3 = *((void *)a3 + 2);
  unsigned int v4 = *(unsigned __int8 *)(v3 + 4);
  if ((*(unsigned char *)(v3 + 8) & 2) == 0 || (int v8 = *((_DWORD *)a3 + 10), v8 == v4))
  {
    int v5 = *(unsigned __int8 *)(v3 + 4);
  }
  else
  {
    int v9 = v8 - 1;
    int v5 = *(unsigned __int8 *)(v3 + 4);
    do
    {
      int v10 = *(_DWORD *)(*((void *)a3 + 4) + 32 * v4);
      if ((v10 & 0x10000FF) != 0x1000000) {
        break;
      }
      v5 += (v10 & 0x2000000) == 0;
      if (v9 == v4) {
        break;
      }
      ++v4;
    }
    while ((v10 & 0x2000000) == 0);
  }
  uint64_t v6 = *(void *)(v3 + 32);
  if (v6)
  {
    unsigned int v7 = -1;
    do
      ++v7;
    while (*(_WORD *)(v6 + 2 * v7));
  }
  else
  {
    unsigned int v7 = 0;
  }
  llvm::StackMaps::recordStackMapOpers(this, a2, (int **)a3, *(void *)(*((void *)a3 + 4) + 32 * (v7 + v5) + 16), (const llvm::MachineOperand *)(*((void *)a3 + 4)+ 32 * (v7 + v5 + *(_DWORD *)(*((void *)a3 + 4) + 32 * (v7 + v5 + 2) + 16) + 4)), (const llvm::MachineOperand *)(*((void *)a3 + 4) + 32 * *((unsigned int *)a3 + 10)), 0);
}

uint64_t llvm::StackMaps::emitStackmapHeader(void *a1, uint64_t a2)
{
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, dword_1EBCD3EF8, 1);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 1);
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
  (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 520))(a2, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[14] - a1[13]) >> 3), 4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, (uint64_t)(a1[8] - a1[7]) >> 4, 4);
  unint64_t v4 = 0x8E38E38E38E38E39 * ((uint64_t)(a1[2] - a1[1]) >> 5);
  int v5 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2 + 520);

  return v5(a2, v4, 4);
}

uint64_t llvm::StackMaps::emitFunctionFrameRecords(uint64_t this, llvm::MCStreamer *a2)
{
  uint64_t v2 = *(void *)(this + 104);
  for (uint64_t i = *(void *)(this + 112); v2 != i; v2 += 24)
  {
    llvm::MCStreamer::emitSymbolValue(a2, *(const llvm::MCSymbol **)v2, 8, 0);
    (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, *(void *)(v2 + 8), 8);
    this = (*(uint64_t (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, *(void *)(v2 + 16), 8);
  }
  return this;
}

uint64_t llvm::StackMaps::emitConstantPoolEntries(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 56);
  for (uint64_t i = *(void *)(result + 64); v2 != i; v2 += 16)
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, *(void *)(v2 + 8), 8);
  return result;
}

uint64_t llvm::StackMaps::emitCallsiteEntries(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 8);
  for (uint64_t i = *(void **)(result + 16); v2 != i; v2 += 36)
  {
    if (*((_WORD *)v2 + 13) || *((_DWORD *)v2 + 58) >= 0x10000u)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 520))(a2, -1, 8);
      (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)a2 + 512))(a2, *v2, 4, 0);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 4);
    }
    else
    {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, v2[1], 8);
      (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)a2 + 512))(a2, *v2, 4, 0);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, *((unsigned int *)v2 + 6), 2);
      int v5 = *((_DWORD *)v2 + 6);
      if (v5)
      {
        uint64_t v6 = (unsigned int *)v2[2];
        unsigned int v7 = &v6[6 * v5];
        do
        {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, *v6, 1);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 1);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, v6[1], 2);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, v6[2], 2);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, *((void *)v6 + 2), 4);
          v6 += 6;
        }
        while (v6 != v7);
      }
      (*(void (**)(uint64_t, uint64_t, void, uint64_t, void))(*(void *)a2 + 640))(a2, 8, 0, 1, 0);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 2);
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, *((unsigned int *)v2 + 58), 2);
      uint64_t v8 = *((unsigned int *)v2 + 58);
      if (v8)
      {
        uint64_t v9 = 6 * v8;
        int v10 = (unsigned __int16 *)(v2[28] + 4);
        do
        {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, *(v10 - 1), 2);
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 1);
          unsigned int v11 = *v10;
          v10 += 3;
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a2 + 520))(a2, v11, 1);
          v9 -= 6;
        }
        while (v9);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void))(*(void *)a2 + 640))(a2, 8, 0, 1, 0);
    }
  }
  return result;
}

void llvm::StackMaps::serializeToStackMapSection(llvm::StackMaps *this)
{
  if (*((void *)this + 1) != *((void *)this + 2))
  {
    uint64_t v2 = *(llvm::MCStreamer **)(*(void *)this + 272);
    uint64_t v3 = (llvm::MCContext *)*((void *)v2 + 1);
    (*(void (**)(llvm::MCStreamer *, void, void))(*(void *)v2 + 168))(v2, *(void *)(*((void *)v3 + 21) + 432), 0);
    uint64_t v25 = (unsigned __int8 **)"__LLVM_StackMaps";
    __int16 v26 = 259;
    uint64_t v4 = llvm::MCContext::getOrCreateSymbol(v3, &v25);
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)v2 + 192))(v2, v4, 0);
    llvm::StackMaps::emitStackmapHeader(this, (uint64_t)v2);
    llvm::StackMaps::emitFunctionFrameRecords((uint64_t)this, v2);
    uint64_t v5 = *((void *)this + 7);
    uint64_t v6 = *((void *)this + 8);
    while (v5 != v6)
    {
      (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)v2 + 520))(v2, *(void *)(v5 + 8), 8);
      v5 += 16;
    }
    llvm::StackMaps::emitCallsiteEntries((uint64_t)this, (uint64_t)v2);
    (*(void (**)(llvm::MCStreamer *))(*(void *)v2 + 152))(v2);
    uint64_t v7 = *((void *)this + 1);
    for (uint64_t i = *((void *)this + 2); i != v7; i -= 288)
    {
      uint64_t v9 = *(void **)(i - 64);
      if ((void *)(i - 48) != v9) {
        free(v9);
      }
      int v10 = *(void **)(i - 272);
      if ((void *)(i - 256) != v10) {
        free(v10);
      }
    }
    *((void *)this + 2) = v7;
    unsigned int v11 = (void *)((char *)this + 32);
    int v12 = *((_DWORD *)this + 10);
    if (v12)
    {
      unsigned int v13 = *((_DWORD *)this + 12);
      if (v13 > 4 * v12 && v13 >= 0x41)
      {
        int v14 = 1 << (33 - __clz(v12 - 1));
        if (v14 <= 64) {
          int v15 = 64;
        }
        else {
          int v15 = v14;
        }
LABEL_21:
        if (v15 == v13)
        {
          *((void *)this + 5) = 0;
          uint64_t v16 = 16 * v13;
          unsigned int v17 = (void *)*((void *)this + 4);
          do
          {
            *unsigned int v17 = -1;
            v17 += 2;
            v16 -= 16;
          }
          while (v16);
        }
        else
        {
          MEMORY[0x1D25D9CD0](*v11, 8);
          if (v15)
          {
            unint64_t v20 = (4 * v15 / 3u + 1) | ((unint64_t)(4 * v15 / 3u + 1) >> 1);
            unint64_t v21 = v20 | (v20 >> 2) | ((v20 | (v20 >> 2)) >> 4);
            LODWORD(v21) = (((v21 | (v21 >> 8)) >> 16) | v21 | (v21 >> 8)) + 1;
            *((_DWORD *)this + 12) = v21;
            uint64_t v22 = operator new(16 * v21, (std::align_val_t)8uLL);
            *((void *)this + 4) = v22;
            *((void *)this + 5) = 0;
            uint64_t v23 = *((unsigned int *)this + 12);
            if (v23)
            {
              uint64_t v24 = 16 * v23;
              do
              {
                *uint64_t v22 = -1;
                v22 += 2;
                v24 -= 16;
              }
              while (v24);
            }
          }
          else
          {
            *unsigned int v11 = 0;
            *((void *)this + 5) = 0;
            *((_DWORD *)this + 12) = 0;
          }
        }
        goto LABEL_29;
      }
    }
    else
    {
      if (!*((_DWORD *)this + 11))
      {
LABEL_29:
        *((void *)this + 8) = *((void *)this + 7);
        return;
      }
      unsigned int v13 = *((_DWORD *)this + 12);
      if (v13 > 0x40)
      {
        int v15 = 0;
        goto LABEL_21;
      }
    }
    if (v13)
    {
      uint64_t v18 = (void *)*v11;
      uint64_t v19 = 16 * v13;
      do
      {
        *uint64_t v18 = -1;
        v18 += 2;
        v19 -= 16;
      }
      while (v19);
    }
    *((void *)this + 5) = 0;
    goto LABEL_29;
  }
}

uint64_t sub_1CC48B538(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      uint64_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v8 = *(unsigned int *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8) {
          memmove(*(void **)a1, v4, 6 * v8);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9) {
          memmove(*(void **)a1, v4, 6 * v9);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = *v7;
        if (v9 != v10) {
          memcpy((void *)(*(void *)a1 + 6 * v9), (const void *)(*(void *)a2 + 6 * v9), *(void *)a2 + 6 * v10 - (*(void *)a2 + 6 * v9));
        }
      }
      *(_DWORD *)(a1 + 8) = v8;
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *uint64_t v7 = 0;
  }
  return a1;
}

uint64_t sub_1CC48B664(uint64_t result, unsigned int *a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          uint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 1);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                if (*((unsigned __int16 *)a2 - 2) < *(unsigned __int16 *)(v10 + 2))
                {
                  __int16 v121 = *(_WORD *)(v10 + 4);
                  unsigned int v115 = *(_DWORD *)v10;
                  int v49 = *(unsigned int *)((char *)a2 - 6);
                  *(_WORD *)(v10 + 4) = *((_WORD *)a2 - 1);
                  *(_DWORD *)unint64_t v10 = v49;
                  *((_WORD *)a2 - 1) = v121;
                  *(unsigned int *)((char *)a2 - 6) = v115;
                }
                break;
              case 3:
                uint64_t result = (uint64_t)sub_1CC48BF60((unsigned int *)v10, (unsigned int *)(v10 + 6), (unsigned int *)((char *)a2 - 6));
                break;
              case 4:
                uint64_t result = (uint64_t)sub_1CC48C2EC(v10, v10 + 6, v10 + 12, (uint64_t)a2 - 6);
                break;
              case 5:
                uint64_t v50 = (unsigned int *)(v10 + 6);
                uint64_t v51 = (unsigned int *)(v10 + 12);
                uint64_t v52 = (unsigned int *)(v10 + 18);
                uint64_t result = (uint64_t)sub_1CC48C2EC(v10, v10 + 6, v10 + 12, v10 + 18);
                if (*((unsigned __int16 *)a2 - 2) < *(unsigned __int16 *)(v10 + 20))
                {
                  unsigned int v53 = *v52;
                  __int16 v54 = *(_WORD *)(v10 + 22);
                  __int16 v55 = *((_WORD *)a2 - 1);
                  unsigned int *v52 = *(unsigned int *)((char *)a2 - 6);
                  *(_WORD *)(v10 + 22) = v55;
                  *((_WORD *)a2 - 1) = v54;
                  *(unsigned int *)((char *)a2 - 6) = v53;
                  if (*(unsigned __int16 *)(v10 + 20) < *(unsigned __int16 *)(v10 + 14))
                  {
                    __int16 v56 = *(_WORD *)(v10 + 16);
                    unsigned int v57 = *v51;
                    *uint64_t v51 = *v52;
                    *(_WORD *)(v10 + 16) = *(_WORD *)(v10 + 22);
                    unsigned int *v52 = v57;
                    *(_WORD *)(v10 + 22) = v56;
                    if (*(unsigned __int16 *)(v10 + 14) < *(unsigned __int16 *)(v10 + 8))
                    {
                      __int16 v58 = *(_WORD *)(v10 + 10);
                      unsigned int v59 = *v50;
                      *uint64_t v50 = *v51;
                      *(_WORD *)(v10 + 10) = *(_WORD *)(v10 + 16);
                      *uint64_t v51 = v59;
                      *(_WORD *)(v10 + 16) = v58;
                      if (*(unsigned __int16 *)(v10 + 8) < *(unsigned __int16 *)(v10 + 2))
                      {
                        __int16 v122 = *(_WORD *)(v10 + 4);
                        unsigned int v116 = *(_DWORD *)v10;
                        *(_DWORD *)unint64_t v10 = *v50;
                        *(_WORD *)(v10 + 4) = *(_WORD *)(v10 + 10);
                        *uint64_t v50 = v116;
                        *(_WORD *)(v10 + 10) = v122;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 143)
          {
            uint64_t v60 = (unsigned int *)(v10 + 6);
            BOOL v62 = (unsigned int *)v10 == a2 || v60 == a2;
            if (a4)
            {
              if (!v62)
              {
                uint64_t v63 = 0;
                uint64_t v64 = (unsigned __int16 *)v10;
                do
                {
                  uint64_t v65 = (unsigned __int16 *)v60;
                  unsigned int v66 = v64[4];
                  if (v66 < v64[1])
                  {
                    unsigned __int16 v67 = *v65;
                    unsigned __int16 v68 = v64[5];
                    uint64_t v69 = v63;
                    while (1)
                    {
                      uint64_t v70 = v10 + v69;
                      *(_DWORD *)(v70 + 6) = *(_DWORD *)(v10 + v69);
                      *(_WORD *)(v70 + 10) = *(_WORD *)(v10 + v69 + 4);
                      if (!v69) {
                        break;
                      }
                      v69 -= 6;
                      if (v66 >= *(unsigned __int16 *)(v70 - 4))
                      {
                        uint64_t v71 = (_WORD *)(v10 + v69 + 6);
                        goto LABEL_85;
                      }
                    }
                    uint64_t v71 = (_WORD *)v10;
LABEL_85:
                    _WORD *v71 = v67;
                    v71[1] = v66;
                    v71[2] = v68;
                  }
                  uint64_t v60 = (unsigned int *)(v65 + 3);
                  v63 += 6;
                  uint64_t v64 = v65;
                }
                while (v65 + 3 != (unsigned __int16 *)a2);
              }
            }
            else if (!v62)
            {
              do
              {
                uint64_t v105 = v60;
                unsigned int v106 = *(unsigned __int16 *)(v9 + 8);
                if (v106 < *(unsigned __int16 *)(v9 + 2))
                {
                  __int16 v107 = *(_WORD *)v60;
                  __int16 v108 = *(_WORD *)(v9 + 10);
                  uint64_t v109 = v105;
                  do
                  {
                    uint64_t v110 = v109;
                    unsigned int v111 = *(unsigned int *)((char *)v109 - 6);
                    uint64_t v109 = (unsigned int *)((char *)v109 - 6);
                    *uint64_t v110 = v111;
                    *((_WORD *)v110 + 2) = *((_WORD *)v110 - 1);
                  }
                  while (v106 < *((unsigned __int16 *)v110 - 5));
                  *(_WORD *)uint64_t v109 = v107;
                  *((_WORD *)v109 + 1) = v106;
                  *((_WORD *)v109 + 2) = v108;
                }
                uint64_t v60 = (unsigned int *)((char *)v105 + 6);
                unint64_t v9 = (unint64_t)v105;
              }
              while ((unsigned int *)((char *)v105 + 6) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((unsigned int *)v10 != a2)
            {
              int64_t v72 = (unint64_t)(v12 - 2) >> 1;
              int64_t v73 = v72;
              do
              {
                int64_t v74 = v73;
                if (v72 >= v73)
                {
                  uint64_t v75 = (2 * v73) | 1;
                  unint64_t v76 = (__int16 *)(v10 + 6 * v75);
                  if (2 * v74 + 2 < v12)
                  {
                    unsigned int v77 = *(unsigned __int16 *)(v10 + 6 * v75 + 2);
                    unsigned int v78 = (unsigned __int16)v76[4];
                    v76 += 3 * (v77 < v78);
                    if (v77 < v78) {
                      uint64_t v75 = 2 * v74 + 2;
                    }
                  }
                  unsigned int v79 = *(unsigned __int16 *)(v10 + 6 * v74 + 2);
                  if ((unsigned __int16)v76[1] >= v79)
                  {
                    unint64_t v80 = (__int16 *)(v10 + 6 * v74);
                    __int16 v81 = *v80;
                    __int16 v82 = v80[2];
                    do
                    {
                      uint64_t result = (uint64_t)v80;
                      unint64_t v80 = v76;
                      int v83 = *(_DWORD *)v76;
                      *(_WORD *)(result + 4) = v80[2];
                      *(_DWORD *)uint64_t result = v83;
                      if (v72 < v75) {
                        break;
                      }
                      uint64_t result = (2 * v75) | 1;
                      unint64_t v76 = (__int16 *)(v10 + 6 * result);
                      uint64_t v84 = 2 * v75 + 2;
                      if (v84 < v12)
                      {
                        unsigned int v85 = *(unsigned __int16 *)(v10 + 6 * result + 2);
                        unsigned int v86 = (unsigned __int16)v76[4];
                        v76 += 3 * (v85 < v86);
                        if (v85 < v86) {
                          uint64_t result = v84;
                        }
                      }
                      uint64_t v75 = result;
                    }
                    while ((unsigned __int16)v76[1] >= v79);
                    *unint64_t v80 = v81;
                    v80[1] = v79;
                    v80[2] = v82;
                  }
                }
                int64_t v73 = v74 - 1;
              }
              while (v74);
              do
              {
                uint64_t v87 = 0;
                __int16 v123 = *(_WORD *)(v10 + 4);
                unsigned int v117 = *(_DWORD *)v10;
                unint64_t v88 = v10;
                do
                {
                  uint64_t v89 = v87 + 1;
                  unsigned int v90 = (unsigned int *)(v88 + 6 * (v87 + 1));
                  uint64_t v91 = (2 * v87) | 1;
                  uint64_t v92 = 2 * v87 + 2;
                  if (v92 < v12)
                  {
                    unsigned int v93 = *(unsigned __int16 *)(v88 + 6 * v89 + 2);
                    unsigned int v94 = *((unsigned __int16 *)v90 + 4);
                    unsigned int v90 = (unsigned int *)((char *)v90 + 6 * (v93 < v94));
                    if (v93 < v94) {
                      uint64_t v91 = v92;
                    }
                  }
                  unsigned int v95 = *v90;
                  *(_WORD *)(v88 + 4) = *((_WORD *)v90 + 2);
                  *(_DWORD *)unint64_t v88 = v95;
                  unint64_t v88 = (unint64_t)v90;
                  uint64_t v87 = v91;
                }
                while (v91 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                a2 = (unsigned int *)((char *)a2 - 6);
                if (v90 == a2)
                {
                  *((_WORD *)v90 + 2) = v123;
                  *unsigned int v90 = v117;
                }
                else
                {
                  unsigned int v96 = *a2;
                  *((_WORD *)v90 + 2) = *((_WORD *)a2 + 2);
                  *unsigned int v90 = v96;
                  *((_WORD *)a2 + 2) = v123;
                  *a2 = v117;
                  uint64_t v97 = (uint64_t)v90 - v10 + 6;
                  if (v97 >= 7)
                  {
                    unint64_t v98 = (v97 / 6uLL - 2) >> 1;
                    unsigned int v99 = *((unsigned __int16 *)v90 + 1);
                    if (*(unsigned __int16 *)(v10 + 6 * v98 + 2) < v99)
                    {
                      __int16 v100 = *(_WORD *)v90;
                      __int16 v101 = *((_WORD *)v90 + 2);
                      do
                      {
                        unint64_t v102 = v90;
                        unsigned int v90 = (unsigned int *)(v10 + 6 * v98);
                        unsigned int v103 = *v90;
                        uint64_t result = *((unsigned __int16 *)v90 + 2);
                        *((_WORD *)v102 + 2) = result;
                        *unint64_t v102 = v103;
                        if (!v98) {
                          break;
                        }
                        unint64_t v98 = (v98 - 1) >> 1;
                      }
                      while (*(unsigned __int16 *)(v10 + 6 * v98 + 2) < v99);
                      *(_WORD *)unsigned int v90 = v100;
                      *((_WORD *)v90 + 1) = v99;
                      *((_WORD *)v90 + 2) = v101;
                    }
                  }
                }
              }
              while (v12-- > 2);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unint64_t v14 = v10 + 6 * ((unint64_t)v12 >> 1);
          if ((unint64_t)v11 >= 0x301)
          {
            sub_1CC48BF60((unsigned int *)v9, (unsigned int *)(v9 + 6 * ((unint64_t)v12 >> 1)), (unsigned int *)((char *)a2 - 6));
            uint64_t v15 = 3 * v13;
            uint64_t v16 = (unsigned int *)(v9 + 6 * v13 - 6);
            sub_1CC48BF60((unsigned int *)(v9 + 6), v16, a2 - 3);
            unsigned int v17 = (unsigned int *)(v9 + 6 + 2 * v15);
            sub_1CC48BF60((unsigned int *)(v9 + 12), v17, (unsigned int *)((char *)a2 - 18));
            uint64_t result = (uint64_t)sub_1CC48BF60(v16, (unsigned int *)v14, v17);
            __int16 v118 = *(_WORD *)(v9 + 4);
            unsigned int v112 = *(_DWORD *)v9;
            __int16 v18 = *(_WORD *)(v14 + 4);
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v14;
            *(_WORD *)(v9 + 4) = v18;
            *(_WORD *)(v14 + 4) = v118;
            *(_DWORD *)unint64_t v14 = v112;
          }
          else
          {
            uint64_t result = (uint64_t)sub_1CC48BF60((unsigned int *)(v9 + 6 * ((unint64_t)v12 >> 1)), (unsigned int *)v9, (unsigned int *)((char *)a2 - 6));
          }
          --a3;
          if (a4) {
            break;
          }
          unsigned int v19 = *(unsigned __int16 *)(v9 + 2);
          if (*(unsigned __int16 *)(v9 - 4) < v19) {
            goto LABEL_13;
          }
          if (v19 >= *((unsigned __int16 *)a2 - 2))
          {
            unint64_t v38 = v9 + 6;
            do
            {
              unint64_t v10 = v38;
              if (v38 >= (unint64_t)a2) {
                break;
              }
              unsigned int v39 = *(unsigned __int16 *)(v38 + 2);
              v38 += 6;
            }
            while (v19 >= v39);
          }
          else
          {
            unint64_t v36 = v9;
            do
            {
              unint64_t v10 = v36 + 6;
              unsigned int v37 = *(unsigned __int16 *)(v36 + 8);
              v36 += 6;
            }
            while (v19 >= v37);
          }
          uint64_t v40 = a2;
          if (v10 < (unint64_t)a2)
          {
            uint64_t v41 = a2;
            do
            {
              uint64_t v40 = (unsigned int *)((char *)v41 - 6);
              unsigned int v42 = *((unsigned __int16 *)v41 - 2);
              uint64_t v41 = (unsigned int *)((char *)v41 - 6);
            }
            while (v19 < v42);
          }
          __int16 v43 = *(_WORD *)v9;
          __int16 v44 = *(_WORD *)(v9 + 4);
          while (v10 < (unint64_t)v40)
          {
            __int16 v120 = *(_WORD *)(v10 + 4);
            unsigned int v114 = *(_DWORD *)v10;
            unsigned int v45 = *v40;
            *(_WORD *)(v10 + 4) = *((_WORD *)v40 + 2);
            *(_DWORD *)unint64_t v10 = v45;
            *((_WORD *)v40 + 2) = v120;
            *uint64_t v40 = v114;
            do
            {
              unsigned int v46 = *(unsigned __int16 *)(v10 + 8);
              v10 += 6;
            }
            while (v19 >= v46);
            do
            {
              unsigned int v47 = *((unsigned __int16 *)v40 - 2);
              uint64_t v40 = (unsigned int *)((char *)v40 - 6);
            }
            while (v19 < v47);
          }
          BOOL v4 = v10 - 6 >= v9;
          BOOL v5 = v10 - 6 == v9;
          if (v10 - 6 != v9)
          {
            int v48 = *(_DWORD *)(v10 - 6);
            *(_WORD *)(v9 + 4) = *(_WORD *)(v10 - 2);
            *(_DWORD *)unint64_t v9 = v48;
          }
          a4 = 0;
          *(_WORD *)(v10 - 6) = v43;
          *(_WORD *)(v10 - 4) = v19;
          *(_WORD *)(v10 - 2) = v44;
        }
        unsigned int v19 = *(unsigned __int16 *)(v9 + 2);
LABEL_13:
        uint64_t v20 = 0;
        __int16 v21 = *(_WORD *)v9;
        __int16 v22 = *(_WORD *)(v9 + 4);
        do
        {
          unsigned int v23 = *(unsigned __int16 *)(v9 + v20 + 8);
          v20 += 6;
        }
        while (v23 < v19);
        unint64_t v24 = v9 + v20;
        uint64_t v25 = a2;
        if (v20 == 6)
        {
          unint64_t v28 = a2;
          while (v24 < (unint64_t)v28)
          {
            __int16 v26 = (unsigned int *)((char *)v28 - 6);
            unsigned int v29 = *((unsigned __int16 *)v28 - 2);
            unint64_t v28 = (unsigned int *)((char *)v28 - 6);
            if (v29 < v19) {
              goto LABEL_23;
            }
          }
          __int16 v26 = v28;
        }
        else
        {
          do
          {
            __int16 v26 = (unsigned int *)((char *)v25 - 6);
            unsigned int v27 = *((unsigned __int16 *)v25 - 2);
            uint64_t v25 = (unsigned int *)((char *)v25 - 6);
          }
          while (v27 >= v19);
        }
LABEL_23:
        unint64_t v10 = v24;
        if (v24 < (unint64_t)v26)
        {
          unint64_t v30 = (unint64_t)v26;
          do
          {
            __int16 v119 = *(_WORD *)(v10 + 4);
            unsigned int v113 = *(_DWORD *)v10;
            int v31 = *(_DWORD *)v30;
            *(_WORD *)(v10 + 4) = *(_WORD *)(v30 + 4);
            *(_DWORD *)unint64_t v10 = v31;
            *(_WORD *)(v30 + 4) = v119;
            *(_DWORD *)unint64_t v30 = v113;
            do
            {
              unsigned int v32 = *(unsigned __int16 *)(v10 + 8);
              v10 += 6;
            }
            while (v32 < v19);
            do
            {
              unsigned int v33 = *(unsigned __int16 *)(v30 - 4);
              v30 -= 6;
            }
            while (v33 >= v19);
          }
          while (v10 < v30);
        }
        if (v10 - 6 != v9)
        {
          int v34 = *(_DWORD *)(v10 - 6);
          *(_WORD *)(v9 + 4) = *(_WORD *)(v10 - 2);
          *(_DWORD *)unint64_t v9 = v34;
        }
        *(_WORD *)(v10 - 6) = v21;
        *(_WORD *)(v10 - 4) = v19;
        *(_WORD *)(v10 - 2) = v22;
        if (v24 >= (unint64_t)v26) {
          break;
        }
LABEL_34:
        uint64_t result = sub_1CC48B664(v9, v10 - 6, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = sub_1CC48C050(v9, (_WORD *)(v10 - 6));
      uint64_t result = sub_1CC48C050(v10, a2);
      if (result) {
        break;
      }
      if (!v35) {
        goto LABEL_34;
      }
    }
    a2 = (unsigned int *)(v10 - 6);
    if (!v35) {
      continue;
    }
    return result;
  }
}

unsigned int *sub_1CC48BF60(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *((unsigned __int16 *)a2 + 1);
  unsigned int v4 = *((unsigned __int16 *)a3 + 1);
  if (v3 >= *((unsigned __int16 *)result + 1))
  {
    if (v4 < v3)
    {
      __int16 v8 = *((_WORD *)a2 + 2);
      unsigned int v9 = *a2;
      __int16 v10 = *((_WORD *)a3 + 2);
      *a2 = *a3;
      *((_WORD *)a2 + 2) = v10;
      *a3 = v9;
      *((_WORD *)a3 + 2) = v8;
      if (*((unsigned __int16 *)a2 + 1) < *((unsigned __int16 *)result + 1))
      {
        __int16 v11 = *((_WORD *)result + 2);
        unsigned int v12 = *result;
        __int16 v13 = *((_WORD *)a2 + 2);
        *uint64_t result = *a2;
        *((_WORD *)result + 2) = v13;
        *a2 = v12;
        *((_WORD *)a2 + 2) = v11;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      __int16 v14 = *((_WORD *)result + 2);
      unsigned int v15 = *result;
      __int16 v16 = *((_WORD *)a2 + 2);
      *uint64_t result = *a2;
      *((_WORD *)result + 2) = v16;
      *a2 = v15;
      *((_WORD *)a2 + 2) = v14;
      if (*((unsigned __int16 *)a3 + 1) >= HIWORD(v15)) {
        return result;
      }
      __int16 v5 = *((_WORD *)a2 + 2);
      unsigned int v6 = *a2;
      __int16 v17 = *((_WORD *)a3 + 2);
      *a2 = *a3;
      *((_WORD *)a2 + 2) = v17;
    }
    else
    {
      __int16 v5 = *((_WORD *)result + 2);
      unsigned int v6 = *result;
      __int16 v7 = *((_WORD *)a3 + 2);
      *uint64_t result = *a3;
      *((_WORD *)result + 2) = v7;
    }
    *a3 = v6;
    *((_WORD *)a3 + 2) = v5;
  }
  return result;
}

BOOL sub_1CC48C050(uint64_t a1, _WORD *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if ((unsigned __int16)*(a2 - 2) < *(unsigned __int16 *)(a1 + 2))
      {
        __int16 v6 = *(_WORD *)(a1 + 4);
        unsigned int v7 = *(_DWORD *)a1;
        __int16 v8 = *(a2 - 1);
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 3);
        *(_WORD *)(a1 + 4) = v8;
        *(_DWORD *)(a2 - 3) = v7;
        *(a2 - 1) = v6;
      }
      return result;
    case 3uLL:
      sub_1CC48BF60((unsigned int *)a1, (unsigned int *)(a1 + 6), (unsigned int *)(a2 - 3));
      return 1;
    case 4uLL:
      sub_1CC48C2EC(a1, a1 + 6, a1 + 12, (uint64_t)(a2 - 3));
      return 1;
    case 5uLL:
      unsigned int v19 = (unsigned int *)(a1 + 6);
      uint64_t v20 = (unsigned int *)(a1 + 12);
      __int16 v21 = (unsigned int *)(a1 + 18);
      sub_1CC48C2EC(a1, a1 + 6, a1 + 12, a1 + 18);
      if ((unsigned __int16)*(a2 - 2) < *(unsigned __int16 *)(a1 + 20))
      {
        __int16 v22 = *(_WORD *)(a1 + 22);
        unsigned int v23 = *v21;
        __int16 v24 = *(a2 - 1);
        *__int16 v21 = *(_DWORD *)(a2 - 3);
        *(_WORD *)(a1 + 22) = v24;
        *(_DWORD *)(a2 - 3) = v23;
        *(a2 - 1) = v22;
        if (*(unsigned __int16 *)(a1 + 20) < *(unsigned __int16 *)(a1 + 14))
        {
          __int16 v25 = *(_WORD *)(a1 + 16);
          unsigned int v26 = *v20;
          *uint64_t v20 = *v21;
          *(_WORD *)(a1 + 16) = *(_WORD *)(a1 + 22);
          *__int16 v21 = v26;
          *(_WORD *)(a1 + 22) = v25;
          if (*(unsigned __int16 *)(a1 + 14) < *(unsigned __int16 *)(a1 + 8))
          {
            __int16 v27 = *(_WORD *)(a1 + 10);
            unsigned int v28 = *v19;
            *unsigned int v19 = *v20;
            *(_WORD *)(a1 + 10) = *(_WORD *)(a1 + 16);
            *uint64_t v20 = v28;
            *(_WORD *)(a1 + 16) = v27;
            if (*(unsigned __int16 *)(a1 + 8) < *(unsigned __int16 *)(a1 + 2))
            {
              __int16 v29 = *(_WORD *)(a1 + 4);
              unsigned int v30 = *(_DWORD *)a1;
              *(_DWORD *)a1 = *v19;
              *(_WORD *)(a1 + 4) = *(_WORD *)(a1 + 10);
              *unsigned int v19 = v30;
              *(_WORD *)(a1 + 10) = v29;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v9 = (_WORD *)(a1 + 12);
      sub_1CC48BF60((unsigned int *)a1, (unsigned int *)(a1 + 6), (unsigned int *)(a1 + 12));
      __int16 v10 = (_WORD *)(a1 + 18);
      if ((_WORD *)(a1 + 18) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    unsigned int v13 = (unsigned __int16)v10[1];
    if (v13 < (unsigned __int16)v9[1])
    {
      __int16 v14 = *v10;
      __int16 v15 = v10[2];
      uint64_t v16 = v11;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        *(_DWORD *)(v17 + 18) = *(_DWORD *)(a1 + v16 + 12);
        *(_WORD *)(v17 + 22) = *(_WORD *)(a1 + v16 + 16);
        if (v16 == -12) {
          break;
        }
        v16 -= 6;
        if (v13 >= *(unsigned __int16 *)(v17 + 8))
        {
          __int16 v18 = (_WORD *)(a1 + v16 + 18);
          goto LABEL_13;
        }
      }
      __int16 v18 = (_WORD *)a1;
LABEL_13:
      *__int16 v18 = v14;
      v18[1] = v13;
      v18[2] = v15;
      if (++v12 == 8) {
        return v10 + 3 == a2;
      }
    }
    unsigned int v9 = v10;
    v11 += 6;
    v10 += 3;
    if (v10 == a2) {
      return 1;
    }
  }
}

unsigned int *sub_1CC48C2EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = sub_1CC48BF60((unsigned int *)a1, (unsigned int *)a2, (unsigned int *)a3);
  if (*(unsigned __int16 *)(a4 + 2) < *(unsigned __int16 *)(a3 + 2))
  {
    __int16 v9 = *(_WORD *)(a3 + 4);
    unsigned int v10 = *(_DWORD *)a3;
    __int16 v11 = *(_WORD *)(a4 + 4);
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_WORD *)(a3 + 4) = v11;
    *(_DWORD *)a4 = v10;
    *(_WORD *)(a4 + 4) = v9;
    if (*(unsigned __int16 *)(a3 + 2) < *(unsigned __int16 *)(a2 + 2))
    {
      __int16 v12 = *(_WORD *)(a2 + 4);
      unsigned int v13 = *(_DWORD *)a2;
      __int16 v14 = *(_WORD *)(a3 + 4);
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_WORD *)(a2 + 4) = v14;
      *(_DWORD *)a3 = v13;
      *(_WORD *)(a3 + 4) = v12;
      if (*(unsigned __int16 *)(a2 + 2) < *(unsigned __int16 *)(a1 + 2))
      {
        __int16 v15 = *(_WORD *)(a1 + 4);
        unsigned int v16 = *(_DWORD *)a1;
        __int16 v17 = *(_WORD *)(a2 + 4);
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_WORD *)(a1 + 4) = v17;
        *(_DWORD *)a2 = v16;
        *(_WORD *)(a2 + 4) = v15;
      }
    }
  }
  return result;
}

void *sub_1CC48C3BC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v8 = *(_DWORD *)(a1 + 16);
  if (!v8)
  {
    __int16 v14 = 0;
LABEL_6:
    BOOL result = sub_1CD541520(a1, (uint64_t)a2, a2, v14);
    *BOOL result = *a2;
    *((_DWORD *)result + 2) = *a3;
    uint64_t v9 = *(void *)a1;
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a1;
  unsigned int v10 = (37 * *a2) & (v8 - 1);
  BOOL result = (void *)(*(void *)a1 + 16 * v10);
  uint64_t v12 = *result;
  if (*a2 != *result)
  {
    __int16 v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        __int16 v15 = result;
      }
      unsigned int v18 = v10 + v16++;
      unsigned int v10 = v18 & (v8 - 1);
      BOOL result = (void *)(v9 + 16 * v10);
      uint64_t v12 = *result;
      if (*a2 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      __int16 v14 = v15;
    }
    else {
      __int16 v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a4 = result;
  *(void *)(a4 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a4 + 16) = v13;
  return result;
}

void *sub_1CC48C4B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a1 + 4;
  uint64_t v7 = (uint64_t)(a1 + 2);
  a1[3] = 0x800000000;
  if (*(_DWORD *)(a4 + 8)) {
    sub_1CB831C80(v7, a4);
  }
  a1[28] = a1 + 30;
  a1[29] = 0x800000000;
  if (*(_DWORD *)(a5 + 8)) {
    sub_1CC48B538((uint64_t)(a1 + 28), a5);
  }
  return a1;
}

uint64_t sub_1CC48C528(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v6 = *a1;
    int v7 = v3 - 1;
    unsigned int v8 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    uint64_t v4 = (void *)(*a1 + 16 * v8);
    uint64_t v9 = *v4;
    if (*a2 == *v4)
    {
      uint64_t result = 1;
    }
    else
    {
      unsigned int v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v9 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v9 == -8192;
        }
        if (v12) {
          unsigned int v10 = v4;
        }
        unsigned int v13 = v8 + v11++;
        unsigned int v8 = v13 & v7;
        uint64_t v4 = (void *)(v6 + 16 * (v13 & v7));
        uint64_t v9 = *v4;
        if (*a2 == *v4) {
          goto LABEL_3;
        }
      }
      uint64_t result = 0;
      if (v10) {
        uint64_t v4 = v10;
      }
    }
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t result = 0;
  }
LABEL_3:
  *a3 = v4;
  return result;
}

uint64_t sub_1CC48C5C4()
{
  uint64_t v4 = &v3;
  int v2 = 1;
  int v3 = 3;
  v1.n128_u64[0] = (unint64_t)"Specify the stackmap encoding version (default = 3)";
  v1.n128_u64[1] = 51;
  sub_1CD57D1E4((llvm::cl::Option *)&unk_1EBCD3E78, "stackmap-version", &v4, &v2, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &unk_1EBCD3E78, &dword_1CB82C000);
}

void sub_1CC48C654(uint64_t a1)
{
}

uint64_t llvm::StackProtector::runOnFunction(llvm::StackProtector *this, llvm::Function *a2)
{
  uint64_t v4 = *((void *)a2 + 5);
  *((void *)this + 12) = a2;
  *((void *)this + 13) = v4;
  __int16 v5 = (uint64_t *)*((void *)this + 1);
  uint64_t AnalysisPass = llvm::PMDataManager::findAnalysisPass((llvm::PMDataManager *)v5[3], &llvm::DominatorTreeWrapperPass::ID, 1);
  if (AnalysisPass)
  {
    uint64_t AnalysisPass = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisPass + 96))(AnalysisPass, &llvm::DominatorTreeWrapperPass::ID);
    __int16 v5 = (uint64_t *)*((void *)this + 1);
  }
  uint64_t v7 = AnalysisPass + 32;
  if (!AnalysisPass) {
    uint64_t v7 = 0;
  }
  *((void *)this + 14) = v7;
  uint64_t v8 = *v5;
  uint64_t v9 = v5[1];
  if (*v5 == v9)
  {
LABEL_49:
    uint64_t v10 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v8 != &llvm::TargetPassConfig::ID)
    {
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_49;
      }
    }
    uint64_t v10 = *(void *)(v8 + 8);
  }
  uint64_t v11 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::TargetPassConfig::ID)+ 112);
  *((void *)this + 4) = v11;
  std::string::operator=((std::string *)this + 2, (const std::string *)(v11 + 448));
  long long v12 = *(_OWORD *)(v11 + 472);
  *((void *)this + 11) = *(void *)(v11 + 488);
  *(_OWORD *)((char *)this + 72) = v12;
  uint64_t v13 = (*(uint64_t (**)(void, llvm::Function *))(**((void **)this + 4) + 16))(*((void *)this + 4), a2);
  *((void *)this + 5) = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 120))(v13);
  *((_WORD *)this + 156) = 0;
  uint64_t v14 = *((void *)a2 + 14);
  if (!v14) {
    goto LABEL_17;
  }
  if (!*(_DWORD *)(v14 + 8)) {
    goto LABEL_17;
  }
  uint64_t v15 = *(void *)(v14 + 40);
  if (!v15) {
    goto LABEL_17;
  }
  int v16 = *(_DWORD *)(v15 + 40);
  if (!v16) {
    goto LABEL_17;
  }
  uint64_t v17 = *(void *)(v15 + 24);
  unsigned int v18 = &unk_1EBCBE000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0)
  {
    int v45 = v16;
    int v41 = __cxa_guard_acquire(&qword_1EBCBE588);
    unsigned int v18 = &unk_1EBCBE000;
    int v16 = v45;
    if (v41)
    {
      unint64_t v42 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v42 = 0xFF51AFD7ED558CCDLL;
      }
      qword_1EBCBE580 = v42;
      __cxa_guard_release(&qword_1EBCBE588);
      unsigned int v18 = (void *)&unk_1EBCBE000;
      int v16 = v45;
    }
  }
  uint64_t v19 = v18[176];
  uint64_t v20 = __ROR8__(v19 ^ 0xB34481606306CA7ALL, 30);
  unint64_t v21 = 0x9DDFEA08EB382D69
      * ((v19 - 0x3DB671C564579177) ^ ((0x9DDFEA08EB382D69
                                        * ((v20 - 0x67A3B8BE64EA70E9) ^ (v19 - 0x3DB671C564579177))) >> 47) ^ (0x9DDFEA08EB382D69 * ((v20 - 0x67A3B8BE64EA70E9) ^ (v19 - 0x3DB671C564579177))));
  unsigned int v22 = -348639895 * ((v21 >> 47) ^ v21);
  int v23 = v16 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v25 = v22 & v23;
    uint64_t v26 = v17 + 24 * v25;
    __int16 v27 = *(void **)v26;
    if (*(void *)v26 == -1)
    {
      if ("stack-protector-buffer-size" == (char *)-1) {
        goto LABEL_32;
      }
      goto LABEL_16;
    }
    if (v27 != (void *)-2) {
      break;
    }
    if ("stack-protector-buffer-size" == (char *)-2) {
      goto LABEL_32;
    }
LABEL_16:
    if (v27 == (void *)-1) {
      goto LABEL_17;
    }
    unsigned int v22 = i + v25;
  }
  if (*(void *)(v26 + 8) != 27) {
    goto LABEL_16;
  }
  BOOL v29 = *v27 == 0x72702D6B63617473 && v27[1] == 0x2D726F746365746FLL;
  BOOL v30 = v29 && v27[2] == 0x732D726566667562;
  if (!v30 || *(void *)((char *)v27 + 19) != 0x657A69732D726566) {
    goto LABEL_16;
  }
LABEL_32:
  uint64_t v32 = *(void *)(v26 + 16);
  if (v32 && *(unsigned char *)(v32 + 8) == 2)
  {
    uint64_t v33 = *(unsigned int *)(v32 + 16);
    if (v33)
    {
      unint64_t v34 = 0;
      BOOL v35 = (unsigned __int8 *)(*(unsigned int *)(v32 + 12) + v32 + 25);
      while (1)
      {
        int v37 = *v35++;
        int v36 = v37;
        if ((v37 - 48) >= 0xA)
        {
          if ((v36 - 97) >= 0x1A)
          {
            if ((v36 - 65) > 0x19) {
              return 0;
            }
            int v38 = -55;
          }
          else
          {
            int v38 = -87;
          }
        }
        else
        {
          int v38 = -48;
        }
        unsigned int v39 = v38 + v36;
        if (v39 > 9) {
          break;
        }
        unint64_t v40 = 10 * v34 + v39;
        if (v34 > v40 / 0xA) {
          break;
        }
        unint64_t v34 = v40;
        if (!--v33)
        {
          if (HIDWORD(v40)) {
            return 0;
          }
          *((_DWORD *)this + 36) = v40;
          goto LABEL_17;
        }
      }
    }
    return 0;
  }
LABEL_17:
  if (!llvm::StackProtector::RequiresStackProtector(this)) {
    return 0;
  }
  if ((*((_WORD *)a2 + 9) & 8) != 0)
  {
    PersonalityFuint64_t n = (llvm::Value *)llvm::Function::getPersonalityFn(a2);
    if (llvm::classifyEHPersonality(PersonalityFn, v44) - 7 < 4) {
      return 0;
    }
  }

  return llvm::StackProtector::InsertStackProtectors(this);
}

uint64_t llvm::StackProtector::RequiresStackProtector(llvm::StackProtector *this)
{
  v102[34] = *MEMORY[0x1E4F143B8];
  int v2 = (const llvm::Function *)*((void *)this + 12);
  uint64_t v3 = *((void *)v2 + 14);
  if (v3 && (*(unsigned char *)(v3 + 18) & 2) != 0)
  {
    LOBYTE(v18) = 0;
    return v18 & 1;
  }
  llvm::OptimizationRemarkEmitter::OptimizationRemarkEmitter(v79, v2);
  uint64_t v4 = (llvm::Function *)*((void *)this + 12);
  uint64_t v5 = *((void *)v4 + 14);
  if (v5)
  {
    unsigned int v6 = *(unsigned __int8 *)(v5 + 19);
    if ((v6 & 8) != 0)
    {
      uint64_t v7 = ***(void ***)v79[0];
      if (*(void *)(v7 + 128)
        || (int v8 = (*(uint64_t (**)(void))(**(void **)(v7 + 72) + 48))(*(void *)(v7 + 72)),
            uint64_t v4 = (llvm::Function *)*((void *)this + 12),
            v8))
      {
        llvm::OptimizationRemark::OptimizationRemark((uint64_t)v99, (uint64_t)"stack-protector", (uint64_t)"StackProtectorRequested", 23, v4);
        uint64_t v87 = "Stack protection applied to function ";
        uint64_t v88 = 37;
        sub_1CC59ADEC((uint64_t *)&v100, (uint64_t)&v87);
        llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v81, "Function", 8uLL, *((unsigned __int8 **)this + 12));
        uint64_t v9 = sub_1CD3D6290((uint64_t)v99, (long long *)v81);
        uint64_t v87 = " due to a function attribute or command-line switch";
        uint64_t v88 = 51;
        sub_1CC59ADEC((uint64_t *)(v9 + 80), (uint64_t)&v87);
        int v10 = *(_DWORD *)(v9 + 8);
        BYTE4(v88) = *(unsigned char *)(v9 + 12);
        LODWORD(v88) = v10;
        long long v11 = *(_OWORD *)(v9 + 16);
        uint64_t v90 = *(void *)(v9 + 32);
        long long v89 = v11;
        uint64_t v87 = (const char *)&unk_1F2616800;
        uint64_t v12 = *(void *)(v9 + 72);
        long long v13 = *(_OWORD *)(v9 + 56);
        long long v91 = *(_OWORD *)(v9 + 40);
        long long v92 = v13;
        uint64_t v93 = v12;
        unsigned int v94 = v96;
        uint64_t v95 = 0x400000000;
        if (*(_DWORD *)(v9 + 88)) {
          sub_1CD494D68((uint64_t)&v94, v9 + 80);
        }
        uint64_t v14 = *(void *)(v9 + 360);
        uint64_t v97 = *(void *)(v9 + 352);
        uint64_t v98 = v14;
        uint64_t v87 = (const char *)&unk_1F2616570;
        if (v84 < 0) {
          operator delete(__p);
        }
        if (v82 < 0) {
          operator delete(v81[0]);
        }
        v99[0] = &unk_1F2616800;
        uint64_t v15 = v100;
        if (v101)
        {
          unint64_t v16 = (unint64_t)v101 << 6;
          do
          {
            uint64_t v17 = (void **)&v15[v16];
            if (v15[v16 - 17] < 0) {
              operator delete(*(v17 - 5));
            }
            if (*((char *)v17 - 41) < 0) {
              operator delete(*(v17 - 8));
            }
            v16 -= 64;
          }
          while (v16);
          uint64_t v15 = v100;
        }
        if (v15 != (char *)v102) {
          free(v15);
        }
        llvm::OptimizationRemarkEmitter::emit(v79, (llvm::DiagnosticInfoOptimizationBase *)&v87);
        uint64_t v87 = (const char *)&unk_1F2616800;
        uint64_t v20 = v94;
        if (v95)
        {
          unint64_t v21 = (unint64_t)v95 << 6;
          do
          {
            unsigned int v22 = (void **)&v20[v21];
            if (v20[v21 - 17] < 0) {
              operator delete(*(v22 - 5));
            }
            if (*((char *)v22 - 41) < 0) {
              operator delete(*(v22 - 8));
            }
            v21 -= 64;
          }
          while (v21);
          uint64_t v20 = v94;
        }
        if (v20 != v96) {
          free(v20);
        }
        uint64_t v4 = (llvm::Function *)*((void *)this + 12);
      }
    }
    else if ((v6 & 0x10) == 0)
    {
      BOOL v19 = 0;
      LOBYTE(v18) = 0;
      if ((v6 & 4) == 0) {
        goto LABEL_143;
      }
LABEL_40:
      int v18 = (v6 >> 3) & 1;
      int v23 = (void *)*((void *)v4 + 10);
      unsigned int v77 = (void *)((char *)v4 + 72);
      if (v23 != (void *)((char *)v4 + 72))
      {
        while (1)
        {
          __int16 v24 = v23 - 3;
          if (!v23) {
            __int16 v24 = 0;
          }
          unsigned int v25 = v24 + 5;
          for (int i = (void *)v24[6]; i != v25; int i = (void *)i[1])
          {
            if (i) {
              uint64_t v27 = (uint64_t)(i - 3);
            }
            else {
              uint64_t v27 = 0;
            }
            int v28 = *(unsigned __int8 *)(v27 + 16);
            if (v28 == 59) {
              BOOL v29 = (llvm::Type ***)v27;
            }
            else {
              BOOL v29 = 0;
            }
            if (i && v28 == 59)
            {
              if (llvm::AllocaInst::isArrayAllocation((llvm::AllocaInst *)v29))
              {
                uint64_t v30 = (uint64_t)*(v29 - 4);
                if (v30) {
                  BOOL v31 = *(unsigned char *)(v30 + 16) == 16;
                }
                else {
                  BOOL v31 = 0;
                }
                if (!v31)
                {
LABEL_58:
                  LOBYTE(v18) = 1;
                  uint64_t v87 = (const char *)v29;
                  uint64_t v88 = 1;
                  sub_1CD57DF40((uint64_t)v99, (uint64_t)this + 120, &v87, &v88);
                  sub_1CC48E370(v79, v27, (uint64_t)this);
                  continue;
                }
                uint64_t v32 = *(unsigned int *)(v30 + 32);
                if (v32 >= 0x41)
                {
                  int v34 = 0;
                  int64_t v35 = (unint64_t)(v32 + 63) >> 6;
                  do
                  {
                    if (v35-- < 1) {
                      break;
                    }
                    unint64_t v37 = *(void *)(*(void *)(v30 + 24) + 8 * v35);
                    v34 += __clz(v37);
                  }
                  while (!v37);
                  int v38 = v32 | 0xFFFFFFC0;
                  if ((v32 & 0x3F) == 0) {
                    int v38 = 0;
                  }
                  if ((v32 - v34 - v38) > 0x40) {
                    goto LABEL_58;
                  }
                  unint64_t v33 = **(void **)(v30 + 24);
                }
                else
                {
                  unint64_t v33 = *(void *)(v30 + 24);
                }
                if (v33 >= *((unsigned int *)this + 36)) {
                  goto LABEL_58;
                }
                if (v19)
                {
                  uint64_t v87 = (const char *)v29;
                  uint64_t v88 = 2;
                  sub_1CD57DF40((uint64_t)v99, (uint64_t)this + 120, &v87, &v88);
                  sub_1CC48E370(v79, v27, (uint64_t)this);
LABEL_77:
                  LOBYTE(v18) = 1;
                  continue;
                }
              }
              else
              {
                BOOL v78 = 0;
                if (llvm::StackProtector::ContainsProtectableArray(this, v29[8], &v78, v19, 0))
                {
                  uint64_t v41 = 1;
                  if (!v78) {
                    uint64_t v41 = 2;
                  }
                  uint64_t v87 = (const char *)v29;
                  uint64_t v88 = v41;
                  sub_1CD57DF40((uint64_t)v99, (uint64_t)this + 120, &v87, &v88);
                  uint64_t v42 = ***(void ***)v79[0];
                  if (*(void *)(v42 + 128)
                    || (*(unsigned int (**)(void))(**(void **)(v42 + 72) + 48))(*(void *)(v42 + 72)))
                  {
                    llvm::OptimizationRemark::OptimizationRemark((uint64_t)v99, (uint64_t)"stack-protector", (uint64_t)"StackProtectorBuffer", 20, v27);
                    v81[0] = "Stack protection applied to function ";
                    v81[1] = (void *)37;
                    sub_1CC59ADEC((uint64_t *)&v100, (uint64_t)v81);
                    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v81, "Function", 8uLL, *((unsigned __int8 **)this + 12));
                    uint64_t v43 = sub_1CD3D6290((uint64_t)v99, (long long *)v81);
                    unsigned int v85 = " due to a stack allocated buffer or struct containing a buffer";
                    uint64_t v86 = 62;
                    sub_1CC59ADEC((uint64_t *)(v43 + 80), (uint64_t)&v85);
                    int v44 = *(_DWORD *)(v43 + 8);
                    BYTE4(v88) = *(unsigned char *)(v43 + 12);
                    LODWORD(v88) = v44;
                    long long v45 = *(_OWORD *)(v43 + 16);
                    uint64_t v90 = *(void *)(v43 + 32);
                    long long v89 = v45;
                    uint64_t v87 = (const char *)&unk_1F2616800;
                    uint64_t v46 = *(void *)(v43 + 72);
                    long long v47 = *(_OWORD *)(v43 + 56);
                    long long v91 = *(_OWORD *)(v43 + 40);
                    long long v92 = v47;
                    uint64_t v93 = v46;
                    unsigned int v94 = v96;
                    uint64_t v95 = 0x400000000;
                    if (*(_DWORD *)(v43 + 88)) {
                      sub_1CD494D68((uint64_t)&v94, v43 + 80);
                    }
                    uint64_t v48 = *(void *)(v43 + 360);
                    uint64_t v97 = *(void *)(v43 + 352);
                    uint64_t v98 = v48;
                    uint64_t v87 = (const char *)&unk_1F2616570;
                    if (v84 < 0) {
                      operator delete(__p);
                    }
                    if (v82 < 0) {
                      operator delete(v81[0]);
                    }
                    v99[0] = &unk_1F2616800;
                    int v49 = v100;
                    if (v101)
                    {
                      unint64_t v50 = (unint64_t)v101 << 6;
                      do
                      {
                        uint64_t v51 = (void **)&v49[v50];
                        if (v49[v50 - 17] < 0) {
                          operator delete(*(v51 - 5));
                        }
                        if (*((char *)v51 - 41) < 0) {
                          operator delete(*(v51 - 8));
                        }
                        v50 -= 64;
                      }
                      while (v50);
                      int v49 = v100;
                    }
                    if (v49 != (char *)v102) {
                      free(v49);
                    }
                    llvm::OptimizationRemarkEmitter::emit(v79, (llvm::DiagnosticInfoOptimizationBase *)&v87);
                    uint64_t v87 = (const char *)&unk_1F2616800;
                    __int16 v55 = v94;
                    if (v95)
                    {
                      unint64_t v56 = (unint64_t)v95 << 6;
                      do
                      {
                        unsigned int v57 = (void **)&v55[v56];
                        if (v55[v56 - 17] < 0) {
                          operator delete(*(v57 - 5));
                        }
                        if (*((char *)v57 - 41) < 0) {
                          operator delete(*(v57 - 8));
                        }
                        v56 -= 64;
                      }
                      while (v56);
                      __int16 v55 = v94;
                    }
                    if (v55 != v96) {
                      free(v55);
                    }
                  }
                  goto LABEL_77;
                }
                if (v19)
                {
                  int64_t v73 = (llvm::Type *)v29[8];
                  int64_t v74 = (llvm::DataLayout *)(*((void *)this + 13) + 272);
                  unint64_t v75 = (unint64_t)(sub_1CB83544C((uint64_t)v74, (uint64_t)v73) + 7) >> 3;
                  BOOL v76 = v52 == 1;
                  char Alignment = llvm::DataLayout::getAlignment(v74, v73, 1);
                  if (llvm::StackProtector::HasAddressTaken((uint64_t)this, (uint64_t)v29, ((1 << Alignment) + v75 - 1) & -(1 << Alignment), v76))
                  {
                    uint64_t v87 = (const char *)v29;
                    uint64_t v88 = 3;
                    sub_1CD57DF40((uint64_t)v99, (uint64_t)this + 120, &v87, &v88);
                    uint64_t v54 = ***(void ***)v79[0];
                    if (*(void *)(v54 + 128)
                      || (*(unsigned int (**)(void))(**(void **)(v54 + 72) + 48))(*(void *)(v54 + 72)))
                    {
                      llvm::OptimizationRemark::OptimizationRemark((uint64_t)v99, (uint64_t)"stack-protector", (uint64_t)"StackProtectorAddressTaken", 26, v27);
                      v81[0] = "Stack protection applied to function ";
                      v81[1] = (void *)37;
                      sub_1CC59ADEC((uint64_t *)&v100, (uint64_t)v81);
                      llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v81, "Function", 8uLL, *((unsigned __int8 **)this + 12));
                      uint64_t v58 = sub_1CD3D6290((uint64_t)v99, (long long *)v81);
                      unsigned int v85 = " due to the address of a local variable being taken";
                      uint64_t v86 = 51;
                      sub_1CC59ADEC((uint64_t *)(v58 + 80), (uint64_t)&v85);
                      int v59 = *(_DWORD *)(v58 + 8);
                      BYTE4(v88) = *(unsigned char *)(v58 + 12);
                      LODWORD(v88) = v59;
                      long long v60 = *(_OWORD *)(v58 + 16);
                      uint64_t v90 = *(void *)(v58 + 32);
                      long long v89 = v60;
                      uint64_t v87 = (const char *)&unk_1F2616800;
                      uint64_t v61 = *(void *)(v58 + 72);
                      long long v62 = *(_OWORD *)(v58 + 56);
                      long long v91 = *(_OWORD *)(v58 + 40);
                      long long v92 = v62;
                      uint64_t v93 = v61;
                      unsigned int v94 = v96;
                      uint64_t v95 = 0x400000000;
                      if (*(_DWORD *)(v58 + 88)) {
                        sub_1CD494D68((uint64_t)&v94, v58 + 80);
                      }
                      uint64_t v63 = *(void *)(v58 + 360);
                      uint64_t v97 = *(void *)(v58 + 352);
                      uint64_t v98 = v63;
                      uint64_t v87 = (const char *)&unk_1F2616570;
                      if (v84 < 0) {
                        operator delete(__p);
                      }
                      if (v82 < 0) {
                        operator delete(v81[0]);
                      }
                      v99[0] = &unk_1F2616800;
                      uint64_t v64 = v100;
                      if (v101)
                      {
                        unint64_t v65 = (unint64_t)v101 << 6;
                        do
                        {
                          unsigned int v66 = (void **)&v64[v65];
                          if (v64[v65 - 17] < 0) {
                            operator delete(*(v66 - 5));
                          }
                          if (*((char *)v66 - 41) < 0) {
                            operator delete(*(v66 - 8));
                          }
                          v65 -= 64;
                        }
                        while (v65);
                        uint64_t v64 = v100;
                      }
                      if (v64 != (char *)v102) {
                        free(v64);
                      }
                      llvm::OptimizationRemarkEmitter::emit(v79, (llvm::DiagnosticInfoOptimizationBase *)&v87);
                      uint64_t v87 = (const char *)&unk_1F2616800;
                      unsigned __int16 v67 = v94;
                      if (v95)
                      {
                        unint64_t v68 = (unint64_t)v95 << 6;
                        do
                        {
                          uint64_t v69 = (void **)&v67[v68];
                          if (v67[v68 - 17] < 0) {
                            operator delete(*(v69 - 5));
                          }
                          if (*((char *)v69 - 41) < 0) {
                            operator delete(*(v69 - 8));
                          }
                          v68 -= 64;
                        }
                        while (v68);
                        unsigned __int16 v67 = v94;
                      }
                      if (v67 != v96) {
                        free(v67);
                      }
                    }
                    LOBYTE(v18) = 1;
                  }
                }
                unsigned int v39 = (void *)*((void *)this + 20);
                if (v39 == *((void **)this + 19)) {
                  goto LABEL_75;
                }
                uint64_t v40 = *((unsigned int *)this + 42);
                if (v40 < 0x21
                  || 4 * (*((_DWORD *)this + 43) - *((_DWORD *)this + 44)) >= v40)
                {
                  memset(v39, 255, 8 * v40);
LABEL_75:
                  *((_DWORD *)this + 43) = 0;
                  *((_DWORD *)this + 44) = 0;
                  continue;
                }
                llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this + 19);
              }
            }
          }
          int v23 = (void *)v23[1];
          if (v23 == v77) {
            goto LABEL_143;
          }
        }
      }
      goto LABEL_143;
    }
    BOOL v19 = 1;
    goto LABEL_40;
  }
  LOBYTE(v18) = 0;
LABEL_143:
  uint64_t v70 = v80;
  unint64_t v80 = 0;
  if (v70)
  {
    uint64_t v71 = *v70;
    *uint64_t v70 = 0;
    if (v71) {
      (*(void (**)(uint64_t))(*(void *)v71 + 8))(v71);
    }
    MEMORY[0x1D25D9CE0](v70, 0x20C4093837F09);
  }
  return v18 & 1;
}

uint64_t llvm::StackProtector::InsertStackProtectors(llvm::StackProtector *this)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(void))(**((void **)this + 5) + 784))(*((void *)this + 5)))
  {
    BOOL v2 = 1;
  }
  else if (byte_1EBCD3FB8)
  {
    BOOL v2 = (*(_WORD *)(*((void *)this + 4) + 1020) & 0x800) == 0;
  }
  else
  {
    BOOL v2 = 0;
  }
  uint64_t v3 = *((void *)this + 12);
  uint64_t v4 = v3 + 72;
  uint64_t v5 = *(void *)(v3 + 80);
  if (v5 != v3 + 72)
  {
    long long v62 = 0;
    uint64_t v61 = v3 + 72;
    while (1)
    {
      uint64_t v6 = v5 - 24;
      BOOL v7 = v5 == 0;
      uint64_t v5 = *(void *)(v5 + 8);
      uint64_t v8 = v7 ? 0 : v6;
      uint64_t v9 = *(void *)(v8 + 40);
      if (v9 != v8 + 40)
      {
        uint64_t v10 = v9 ? v9 - 24 : 0;
        unsigned int v11 = *(unsigned __int8 *)(v10 + 16) - 40;
        uint64_t v12 = v11 >= 0xFFFFFFF5 ? (uint64_t **)v10 : 0;
        if (v9)
        {
          if (*((unsigned char *)v12 + 16) == 29 && v11 >= 0xFFFFFFF5) {
            break;
          }
        }
      }
LABEL_75:
      if (v5 == v4) {
        return *((unsigned __int8 *)this + 312);
      }
    }
    if (*((unsigned char *)this + 312))
    {
      if (v2) {
        return *((unsigned __int8 *)this + 312);
      }
      goto LABEL_41;
    }
    uint64_t v14 = 0;
    *((unsigned char *)this + 312) = 1;
    uint64_t v15 = *((void *)this + 12);
    unint64_t v16 = (llvm::Module *)*((void *)this + 13);
    uint64_t v17 = *((void *)this + 5);
    unsigned __int8 v63 = 0;
    uint64_t v18 = *(void *)(v15 + 80);
    if (v18) {
      uint64_t v19 = v18 - 24;
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = *(void *)(v19 + 48);
    if (v20) {
      unint64_t v21 = (uint64_t **)(v20 - 24);
    }
    else {
      unint64_t v21 = 0;
    }
    uint64_t v22 = **v21;
    unsigned int v66 = v68;
    uint64_t v67 = 0x200000000;
    uint64_t v71 = v22;
    int64_t v72 = &v80;
    int64_t v73 = &v81;
    uint64_t v74 = 0;
    int v75 = 0;
    __int16 v76 = 512;
    char v77 = 7;
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    uint64_t v78 = 0;
    uint64_t v79 = 0;
    unint64_t v80 = &unk_1F2616E88;
    __int16 v81 = &unk_1F2617008;
    uint64_t v69 = v21[5];
    uint64_t v70 = v21 + 3;
    int v23 = (unsigned __int8 *)v21[6];
    v64[0] = (uint64_t)v23;
    if (v23)
    {
      llvm::MetadataTracking::track((uint64_t)v64, v23, 2);
      uint64_t v14 = v64[0];
    }
    sub_1CB8461A4((uint64_t)&v66, 0, v14);
    if (!v64[0])
    {
LABEL_36:
      __int16 v24 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)(*(void *)**v12 + 1912), 0);
      v82[0] = "StackGuardSlot";
      __int16 v83 = 259;
      long long v62 = sub_1CB935044((uint64_t *)&v66, v24, 0, (uint64_t)v82);
      uint64_t v25 = sub_1CC48E65C(v17, v16, (uint64_t)&v66, &v63);
      llvm::Intrinsic::getType(*(uint64_t **)v16, 286, 0, 0);
      Type = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)v16, 286, 0, 0);
      llvm::Module::getOrInsertFunction((uint64_t)v16, "llvm.stackprotector", (const char *)0x13, Type, 0);
      int v28 = (uint64_t **)v27;
      if (v27) {
        uint64_t v27 = *(void *)(v27 + 24);
      }
      v64[0] = v25;
      v64[1] = (uint64_t)v62;
      __int16 v83 = 257;
      sub_1CB845BAC((uint64_t *)&v66, (uint64_t **)v27, v28, v64, 2, (uint64_t)v82, 0);
      int v29 = v63;
      if (v66 != v68) {
        free(v66);
      }
      if (v2 && v29 != 0) {
        return *((unsigned __int8 *)this + 312);
      }
LABEL_41:
      if (!v62)
      {
        uint64_t v30 = (uint64_t *)(*((void *)this + 12) + 80);
LABEL_43:
        uint64_t v31 = *v30;
        uint64_t v32 = v31 - 24;
        if (!v31) {
          uint64_t v32 = 0;
        }
        uint64_t v33 = v32 + 40;
        for (uint64_t i = *(void *)(v32 + 48); ; uint64_t i = *(void *)(i + 8))
        {
          if (i == v33)
          {
            uint64_t v30 = (uint64_t *)(v31 + 8);
            goto LABEL_43;
          }
          uint64_t v35 = i ? i - 24 : 0;
          if (*(unsigned char *)(v35 + 16) == 84)
          {
            uint64_t v36 = *(void *)(v35 - 32);
            if (v36)
            {
              if (!*(unsigned char *)(v36 + 16)
                && *(void *)(v36 + 24) == *(void *)(v35 + 72)
                && (*(unsigned char *)(v36 + 33) & 0x20) != 0
                && *(_DWORD *)(*(void *)(i - 56) + 36) == 286)
              {
                break;
              }
            }
          }
        }
        long long v62 = *(llvm::Instruction **)(i - 24 - 32 * (*(_DWORD *)(i - 4) & 0x7FFFFFF) + 32);
      }
      *((unsigned char *)this + 313) = 1;
      PrevNonDebugInstructiouint64_t n = (uint64_t **)llvm::Instruction::getPrevNonDebugInstruction((llvm::Instruction *)v12, 0);
      if (PrevNonDebugInstruction)
      {
        if (*((unsigned char *)PrevNonDebugInstruction + 16) == 84 && (*((_WORD *)PrevNonDebugInstruction + 9) & 3) == 2)
        {
          uint64_t v12 = PrevNonDebugInstruction;
        }
        else
        {
          int v38 = (uint64_t **)llvm::Instruction::getPrevNonDebugInstruction((llvm::Instruction *)PrevNonDebugInstruction, 0);
          if (v38 && *((unsigned char *)v38 + 16) == 84 && (*((_WORD *)v38 + 9) & 3) == 2) {
            uint64_t v12 = v38;
          }
        }
      }
      uint64_t v39 = (*(uint64_t (**)(void, void))(**((void **)this + 5) + 792))(*((void *)this + 5), *((void *)this + 13));
      if (!v39) {
        llvm::StackProtector::CreateFailBB(this);
      }
      uint64_t v40 = v39;
      uint64_t v41 = 0;
      uint64_t v42 = **v12;
      unsigned int v66 = v68;
      uint64_t v67 = 0x200000000;
      uint64_t v71 = v42;
      int64_t v72 = &v80;
      int64_t v73 = &v81;
      uint64_t v74 = 0;
      int v75 = 0;
      __int16 v76 = 512;
      char v77 = 7;
      uint64_t v69 = 0;
      uint64_t v70 = 0;
      uint64_t v78 = 0;
      uint64_t v79 = 0;
      unint64_t v80 = &unk_1F2616E88;
      __int16 v81 = &unk_1F2617008;
      uint64_t v69 = v12[5];
      uint64_t v70 = v12 + 3;
      uint64_t v43 = (unsigned __int8 *)v12[6];
      v64[0] = (uint64_t)v43;
      if (v43)
      {
        llvm::MetadataTracking::track((uint64_t)v64, v43, 2);
        uint64_t v41 = v64[0];
      }
      sub_1CB8461A4((uint64_t)&v66, 0, v41);
      if (!v64[0]) {
        goto LABEL_71;
      }
      int v52 = *(unsigned __int8 *)v64[0];
      if ((v52 - 4) > 0x1E)
      {
        if ((v52 - 3) >= 0xFFFFFFFE) {
          uint64_t v58 = v64[0];
        }
        else {
          uint64_t v58 = 0;
        }
        if ((v52 - 3) < 0xFFFFFFFE)
        {
          if (v52 == 3) {
            *(void *)(v64[0] + 8) = 0;
          }
          goto LABEL_71;
        }
        unint64_t v54 = v58 + 8;
      }
      else
      {
        if ((*(unsigned char *)(v64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v64[0] + 12)) {
          goto LABEL_71;
        }
        uint64_t v53 = *(void *)(v64[0] + 16);
        if ((v53 & 4) == 0) {
          goto LABEL_71;
        }
        unint64_t v54 = v53 & 0xFFFFFFFFFFFFFFF8;
        if (!v54) {
          goto LABEL_71;
        }
      }
      v82[0] = (const char *)v64;
      sub_1CC5FA668(v54 + 16, v82);
LABEL_71:
      int v44 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)(*(void *)v71 + 1912), 0);
      v64[0] = (uint64_t)"Guard";
      __int16 v65 = 259;
      char Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(v69[7] + 40) + 272), v44, 1);
      uint64_t v46 = operator new(0x60uLL);
      v46[13] = v46[13] & 0x38000000 | 1;
      long long v47 = (llvm::Instruction *)(v46 + 8);
      *(void *)uint64_t v46 = 0;
      *((void *)v46 + 1) = 0;
      *((void *)v46 + 2) = 0;
      *((void *)v46 + 3) = v46 + 8;
      __int16 v83 = 257;
      llvm::LoadInst::LoadInst((llvm::Value *)(v46 + 8), (uint64_t)v44, (uint64_t)v62, v82, 1, Alignment, 0);
      (*((void (**)(void **, llvm::Instruction *, uint64_t *, uint64_t *, void **))*v73 + 2))(v73, v47, v64, v69, v70);
      if (v67)
      {
        unint64_t v50 = (llvm::MDNode **)v66;
        uint64_t v51 = (llvm::MDNode **)((char *)v66 + 16 * v67);
        do
        {
          llvm::Instruction::setMetadata(v47, *(_DWORD *)v50, v50[1]);
          v50 += 2;
        }
        while (v50 != v51);
      }
      uint64_t v48 = *(uint64_t ***)(v40 + 24);
      v64[0] = (uint64_t)v47;
      __int16 v83 = 257;
      uint64_t v49 = sub_1CB845BAC((uint64_t *)&v66, v48, (uint64_t **)v40, v64, 1, (uint64_t)v82, 0);
      *(void *)(v49 + 64) = *(void *)(v40 + 112);
      *(_WORD *)(v49 + 18) = (*(_WORD *)(v40 + 18) >> 2) & 0xFFC | *(_WORD *)(v49 + 18) & 0xF003;
      if (v66 != v68) {
        free(v66);
      }
      BOOL v2 = 0;
      uint64_t v4 = v61;
      goto LABEL_75;
    }
    int v55 = *(unsigned __int8 *)v64[0];
    if ((v55 - 4) > 0x1E)
    {
      if ((v55 - 3) >= 0xFFFFFFFE) {
        uint64_t v59 = v64[0];
      }
      else {
        uint64_t v59 = 0;
      }
      if ((v55 - 3) < 0xFFFFFFFE)
      {
        if (v55 == 3) {
          *(void *)(v64[0] + 8) = 0;
        }
        goto LABEL_36;
      }
      unint64_t v57 = v59 + 8;
    }
    else
    {
      if ((*(unsigned char *)(v64[0] + 1) & 0x7F) != 2 && !*(_DWORD *)(v64[0] + 12)) {
        goto LABEL_36;
      }
      uint64_t v56 = *(void *)(v64[0] + 16);
      if ((v56 & 4) == 0) {
        goto LABEL_36;
      }
      unint64_t v57 = v56 & 0xFFFFFFFFFFFFFFF8;
      if (!v57) {
        goto LABEL_36;
      }
    }
    v82[0] = (const char *)v64;
    sub_1CC5FA668(v57 + 16, v82);
    goto LABEL_36;
  }
  return *((unsigned __int8 *)this + 312);
}

void sub_1CC48E370(uint64_t ***a1, uint64_t a2, uint64_t a3)
{
  v36[34] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)***a1;
  if (*(void *)(v6 + 128)
    || (*(unsigned int (**)(void))(**(void **)(v6 + 72) + 48))(*(void *)(v6 + 72)))
  {
    llvm::OptimizationRemark::OptimizationRemark((uint64_t)v33, (uint64_t)"stack-protector", (uint64_t)"StackProtectorAllocaOrArray", 27, a2);
    int v23 = "Stack protection applied to function ";
    uint64_t v24 = 37;
    sub_1CC59ADEC((uint64_t *)&v34, (uint64_t)&v23);
    llvm::DiagnosticInfoOptimizationBase::Argument::Argument((uint64_t)v19, "Function", 8uLL, *(unsigned __int8 **)(a3 + 96));
    uint64_t v7 = sub_1CD3D6290((uint64_t)v33, (long long *)v19);
    int v23 = " due to a call to alloca or use of a variable length array";
    uint64_t v24 = 58;
    sub_1CC59ADEC((uint64_t *)(v7 + 80), (uint64_t)&v23);
    int v8 = *(_DWORD *)(v7 + 8);
    BYTE4(v24) = *(unsigned char *)(v7 + 12);
    LODWORD(v24) = v8;
    long long v9 = *(_OWORD *)(v7 + 16);
    uint64_t v26 = *(void *)(v7 + 32);
    long long v25 = v9;
    int v23 = (const char *)&unk_1F2616800;
    uint64_t v10 = *(void *)(v7 + 72);
    long long v11 = *(_OWORD *)(v7 + 56);
    long long v27 = *(_OWORD *)(v7 + 40);
    long long v28 = v11;
    uint64_t v29 = v10;
    uint64_t v30 = v32;
    uint64_t v31 = 0x400000000;
    if (*(_DWORD *)(v7 + 88)) {
      sub_1CD494D68((uint64_t)&v30, v7 + 80);
    }
    uint64_t v12 = *(void *)(v7 + 360);
    v32[32] = *(void *)(v7 + 352);
    v32[33] = v12;
    int v23 = (const char *)&unk_1F2616570;
    if (v22 < 0) {
      operator delete(__p);
    }
    if (v20 < 0) {
      operator delete(v19[0]);
    }
    v33[0] = &unk_1F2616800;
    long long v13 = (char *)v34;
    if (v35)
    {
      unint64_t v14 = (unint64_t)v35 << 6;
      do
      {
        uint64_t v15 = (void **)&v13[v14];
        if (v13[v14 - 17] < 0) {
          operator delete(*(v15 - 5));
        }
        if (*((char *)v15 - 41) < 0) {
          operator delete(*(v15 - 8));
        }
        v14 -= 64;
      }
      while (v14);
      long long v13 = (char *)v34;
    }
    if (v13 != (char *)v36) {
      free(v13);
    }
    llvm::OptimizationRemarkEmitter::emit(a1, (llvm::DiagnosticInfoOptimizationBase *)&v23);
    int v23 = (const char *)&unk_1F2616800;
    unint64_t v16 = (char *)v30;
    if (v31)
    {
      unint64_t v17 = (unint64_t)v31 << 6;
      do
      {
        uint64_t v18 = (void **)&v16[v17];
        if (v16[v17 - 17] < 0) {
          operator delete(*(v18 - 5));
        }
        if (*((char *)v18 - 41) < 0) {
          operator delete(*(v18 - 8));
        }
        v17 -= 64;
      }
      while (v17);
      unint64_t v16 = (char *)v30;
    }
    if (v16 != (char *)v32) {
      free(v16);
    }
  }
}

uint64_t sub_1CC48E65C(uint64_t a1, llvm::Module *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 760))(a1, a3);
  StackProtectorGuard = (unsigned __int16 *)llvm::Module::getStackProtectorGuard(a2);
  if (v10 == 3)
  {
    if (*StackProtectorGuard ^ 0x6C74 | *((unsigned __int8 *)StackProtectorGuard + 2) ^ 0x73) {
      BOOL v11 = 1;
    }
    else {
      BOOL v11 = v8 == 0;
    }
    if (!v11) {
      goto LABEL_10;
    }
  }
  else if (!v10 && v8)
  {
LABEL_10:
    uint64_t v12 = (llvm::Type *)llvm::PointerType::get((llvm::PointerType *)(**(void **)(a3 + 64) + 1912), 0);
    int v23 = "StackGuard";
    __int16 v24 = 259;
    char Alignment = llvm::DataLayout::getAlignment((llvm::DataLayout *)(*(void *)(*(void *)(*(void *)(a3 + 48) + 56) + 40) + 272), v12, 1);
    unint64_t v14 = operator new(0x60uLL);
    v14[13] = v14[13] & 0x38000000 | 1;
    uint64_t v15 = (llvm::Instruction *)(v14 + 8);
    *(void *)unint64_t v14 = 0;
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *((void *)v14 + 3) = v14 + 8;
    __int16 v26 = 257;
    llvm::LoadInst::LoadInst((llvm::Value *)(v14 + 8), (uint64_t)v12, v8, v25, 1, Alignment, 0);
    (*(void (**)(void, llvm::Instruction *, const char **, void, void))(**(void **)(a3 + 80) + 16))(*(void *)(a3 + 80), v15, &v23, *(void *)(a3 + 48), *(void *)(a3 + 56));
    uint64_t v16 = *(unsigned int *)(a3 + 8);
    if (v16)
    {
      uint64_t v17 = *(void *)a3;
      uint64_t v18 = v17 + 16 * v16;
      do
      {
        llvm::Instruction::setMetadata(v15, *(_DWORD *)v17, *(llvm::MDNode **)(v17 + 8));
        v17 += 16;
      }
      while (v17 != v18);
    }
    return (uint64_t)v15;
  }
  if (a4) {
    *a4 = 1;
  }
  (*(void (**)(uint64_t, llvm::Module *))(*(void *)a1 + 768))(a1, a2);
  llvm::Intrinsic::getType(*(uint64_t **)a2, 285, 0, 0);
  Type = (llvm::PointerType *)llvm::Intrinsic::getType(*(uint64_t **)a2, 285, 0, 0);
  llvm::Module::getOrInsertFunction((uint64_t)a2, "llvm.stackguard", (const char *)0xF, Type, 0);
  unint64_t v21 = (uint64_t **)v20;
  if (v20) {
    uint64_t v20 = *(void *)(v20 + 24);
  }
  __int16 v26 = 257;
  return sub_1CB845BAC((uint64_t *)a3, (uint64_t **)v20, v21, 0, 0, (uint64_t)v25, 0);
}

llvm::Instruction *sub_1CC48E8CC(uint64_t *a1, llvm::Value *a2, llvm::BasicBlock *a3, llvm::BasicBlock *a4, llvm::MDNode *a5, llvm::MDNode *a6)
{
  uint64_t v12 = (char *)operator new(0xA0uLL);
  uint64_t v13 = 0;
  unint64_t v14 = (uint64_t ***)(v12 + 96);
  *((_DWORD *)v12 + 29) = *((_DWORD *)v12 + 29) & 0x38000000 | 3;
  do
  {
    uint64_t v15 = &v12[v13];
    *(void *)uint64_t v15 = 0;
    *((void *)v15 + 1) = 0;
    *((void *)v15 + 2) = 0;
    *((void *)v15 + 3) = v14;
    v13 += 32;
  }
  while (v13 != 96);
  llvm::BranchInst::BranchInst((llvm::BranchInst *)(v12 + 96), a3, a4, a2, 0);
  if (a5) {
    llvm::Value::setMetadata(v14, 2, a5);
  }
  if (a6) {
    llvm::Value::setMetadata(v14, 15, a6);
  }
  __int16 v18 = 257;
  return sub_1CB844E0C(a1, (llvm::Instruction *)v14, (uint64_t)v17);
}

BOOL llvm::StackProtector::shouldEmitSDCheck(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 312) || *(unsigned char *)(a1 + 313)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a2 + 40);
  if (v3) {
    uint64_t v4 = v3 - 24;
  }
  else {
    uint64_t v4 = 0;
  }
  if (*(unsigned __int8 *)(v4 + 16) - 29 >= 0xB) {
    uint64_t v4 = 0;
  }
  return *(unsigned char *)(v4 + 16) == 29;
}

uint64_t llvm::StackProtector::copyToMachineFrameInfo(uint64_t this, llvm::MachineFrameInfo *a2)
{
  if (*(_DWORD *)(this + 128))
  {
    int v2 = -858993459 * ((*((void *)a2 + 2) - *((void *)a2 + 1)) >> 3);
    int v3 = *((_DWORD *)a2 + 8);
    int v4 = v2 - v3;
    if (v2 != v3)
    {
      int v5 = 0;
      uint64_t v6 = (uint64_t *)(this + 120);
      do
      {
        uint64_t v7 = this;
        unsigned int v8 = v5 + *((_DWORD *)a2 + 8);
        long long v9 = a2;
        uint64_t v10 = *((void *)a2 + 1);
        if (*(void *)(v10 + 40 * v8 + 8) != -1)
        {
          uint64_t v11 = *(void *)(v10 + 40 * v8 + 24);
          if (v11)
          {
            uint64_t v15 = 0;
            uint64_t v16 = v11;
            if (sub_1CD3C8538(v6, &v16, &v15))
            {
              uint64_t v12 = v15;
              uint64_t v13 = *(void *)(v7 + 120);
              uint64_t v14 = *(unsigned int *)(v7 + 136);
            }
            else
            {
              uint64_t v13 = *(void *)(v7 + 120);
              uint64_t v14 = *(unsigned int *)(v7 + 136);
              uint64_t v12 = v13 + 16 * v14;
            }
            if (v12 != v13 + 16 * v14) {
              *(unsigned char *)(*((void *)v9 + 1) + 40 * (v5 + *((_DWORD *)v9 + 8)) + 36) = *(_DWORD *)(v12 + 8);
            }
          }
        }
        ++v5;
        a2 = v9;
        this = v7;
      }
      while (v4 != v5);
    }
  }
  return this;
}

void *sub_1CC48EB1C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
    {
      sub_1CC2DF04C(a1, v7);
      uint64_t v17 = 0;
      sub_1CBA0E618(a1, a3, &v17);
      a4 = v17;
    }
LABEL_4:
    uint64_t v8 = *a4;
    goto LABEL_5;
  }
  sub_1CC2DF04C(a1, 2 * v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a4 = (void *)(*(void *)a1 + 16 * v11);
  uint64_t v12 = *a4;
  if (*a3 != *a4)
  {
    uint64_t v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        uint64_t v13 = a4;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a4 = (void *)(*(void *)a1 + 16 * v11);
      uint64_t v12 = *a4;
      if (v8 == *a4) {
        goto LABEL_5;
      }
    }
    if (v13) {
      a4 = v13;
    }
    goto LABEL_4;
  }
LABEL_5:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CC48EC50()
{
  char v2 = 1;
  int v3 = &v2;
  int v1 = 1;
  sub_1CD4D2D28((uint64_t)&unk_1EBCD3F38, "enable-selectiondag-sp", &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD3F38, &dword_1CB82C000);
}

void sub_1CC48ECC8(llvm *a1)
{
  llvm::initializeSlotIndexesPass((uint64_t)a1);
  llvm::initializeLiveStacksPass(a1, v2);
  llvm::initializeMachineLoopInfoPass((uint64_t)a1);
  operator new();
}

void sub_1CC48ED74()
{
}

void sub_1CC48EF08(uint64_t a1)
{
  *(void *)a1 = &unk_1F2613470;
  sub_1CD57E04C((char **)(a1 + 2064));
  sub_1CD57E0CC((void **)(a1 + 1904));
  char v2 = *(void **)(a1 + 1880);
  if (v2 != (void *)(a1 + 1896)) {
    free(v2);
  }
  sub_1CD57E0CC((void **)(a1 + 1720));
  int v3 = *(void **)(a1 + 1640);
  if (v3 != (void *)(a1 + 1656)) {
    free(v3);
  }
  int v4 = *(void **)(a1 + 1600);
  if (v4 != (void *)(a1 + 1624)) {
    free(v4);
  }
  sub_1CD57E158((char **)(a1 + 304));
  int v5 = *(void **)(a1 + 280);
  if (v5)
  {
    *(void *)(a1 + 288) = v5;
    operator delete(v5);
  }
  *(void *)a1 = &unk_1F260E110;
  int v6 = *(void **)(a1 + 176);
  if (v6 != (void *)(a1 + 192)) {
    free(v6);
  }
  unsigned int v7 = *(void **)(a1 + 104);
  if (v7 != (void *)(a1 + 120)) {
    free(v7);
  }
  uint64_t v8 = *(void **)(a1 + 32);
  if (v8 != (void *)(a1 + 48)) {
    free(v8);
  }

  llvm::Pass::~Pass((llvm::Pass *)a1);
}

void sub_1CC48F028(uint64_t a1)
{
  sub_1CC48EF08(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC48F060(llvm::PassRegistry *a1, uint64_t a2)
{
  uint64_t v4 = a2 + 112;
  v6[0] = &unk_1F2617E40;
  v6[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v6);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::SlotIndexes::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::SlotIndexes::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LiveStacks::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  sub_1CB843600(a2, v4, (uint64_t)&llvm::MachineDominatorTree::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)a1, a2);
}

uint64_t sub_1CC48F154(uint64_t a1, uint64_t a2)
{
  v335[4] = *MEMORY[0x1E4F143B8];
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, *(llvm::LLVMContextImpl *****)a2)) {
    return 0;
  }
  *(void *)(a1 + 256) = *(void *)(a2 + 56);
  *(void *)(a1 + 264) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_5:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::LiveStacks::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_5;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  *(void *)(a1 + 248) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::LiveStacks::ID);
  uint64_t v8 = *(uint64_t **)(a1 + 8);
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  if (v9 == v10)
  {
LABEL_10:
    uint64_t v11 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v9 != &llvm::MachineBlockFrequencyInfo::ID)
    {
      v9 += 16;
      if (v9 == v10) {
        goto LABEL_10;
      }
    }
    uint64_t v11 = *(void *)(v9 + 8);
  }
  *(void *)(a1 + 272) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v11 + 96))(v11, &llvm::MachineBlockFrequencyInfo::ID);
  BOOL v12 = *(_DWORD *)(*(void *)(a1 + 248) + 376) && *(unsigned char *)(a2 + 353) == 0;
  if (!v12) {
    return 0;
  }
  int v14 = (uint64_t *)(a1 + 304);
  int v15 = -858993459 * ((*(void *)(*(void *)(a1 + 256) + 16) - *(void *)(*(void *)(a1 + 256) + 8)) >> 3)
      - *(_DWORD *)(*(void *)(a1 + 256) + 32);
  unint64_t v16 = *(unsigned int *)(a1 + 312);
  if (v16 != v15)
  {
    if (v16 > v15)
    {
      uint64_t v300 = 5 * v16;
      unint64_t v301 = (void **)(*v14 + 16 * v300 - 80);
      uint64_t v302 = 80 * v15 - 16 * v300;
      do
      {
        if (v301 + 2 != *v301) {
          free(*v301);
        }
        v301 -= 10;
        v302 += 80;
      }
      while (v302);
    }
    else
    {
      if (*(unsigned int *)(a1 + 316) < (unint64_t)v15) {
        sub_1CD57E1D8();
      }
      if (v16 != v15)
      {
        uint64_t v17 = *v14;
        uint64_t v18 = 5 * v16;
        uint64_t v19 = 80 * v15 - 80 * v16;
        uint64_t v20 = v17 + 16 * v18 + 16;
        do
        {
          *(void *)(v20 - 16) = v20;
          *(void *)(v20 - 8) = 0x800000000;
          v20 += 80;
          v19 -= 80;
        }
        while (v19);
      }
    }
    *(_DWORD *)(a1 + 312) = v15;
  }
  uint64_t v306 = a2;
  uint64_t v21 = *(void *)(a2 + 328);
  uint64_t v313 = a2 + 320;
  if (v21 != a2 + 320)
  {
LABEL_25:
    uint64_t v22 = v21 + 48;
    uint64_t v315 = v21;
    for (uint64_t i = *(void *)(v21 + 56); ; uint64_t i = *(void *)(i + 8))
    {
      if (i == v22)
      {
        uint64_t v21 = *(void *)(v315 + 8);
        if (v21 == v313) {
          break;
        }
        goto LABEL_25;
      }
      uint64_t v24 = *(unsigned int *)(i + 40);
      if (v24)
      {
        uint64_t v25 = *(void *)(i + 32);
        uint64_t v26 = v25 + 32 * v24;
        do
        {
          if (*(unsigned char *)v25 == 5)
          {
            int v27 = *(_DWORD *)(v25 + 16);
            if ((v27 & 0x80000000) == 0)
            {
              uint64_t v28 = *(void *)(a1 + 248);
              LODWORD(v322) = *(_DWORD *)(v25 + 16);
              if (sub_1CC3BAF58((void *)(v28 + 352), (int *)&v322))
              {
                uint64_t v29 = *(void *)(a1 + 248);
                LODWORD(v322) = v27;
                uint64_t v30 = sub_1CC2CD930((void *)(v29 + 352), (int *)&v322);
                if (**(unsigned __int16 **)(i + 16) - 13 >= 5)
                {
                  uint64_t v31 = v30;
                  uint64_t v32 = *(void *)(a1 + 272);
                  uint64_t v33 = *(void *)(*(void *)(*(void *)(i + 24) + 32) + 16);
                  uint64_t v34 = *(void *)(*(uint64_t (**)(uint64_t))(*(void *)v33 + 176))(v33);
                  (*(void (**)(void))(v34 + 336))();
                  uint64_t v36 = *(void *)(v32 + 248);
                  if (v36)
                  {
                    int v37 = *(_DWORD *)(v36 + 176);
                    float v38 = 0.0;
                    if (v37)
                    {
                      uint64_t v39 = *(void *)(i + 24);
                      uint64_t v40 = *(void *)(v36 + 160);
                      unsigned int v41 = v37 - 1;
                      uint64_t v42 = (v37 - 1) & ((v39 >> 4) ^ (v39 >> 9));
                      uint64_t v43 = *(void *)(v40 + 16 * v42);
                      if (v43 == v39)
                      {
LABEL_36:
                        uint64_t v44 = *(unsigned int *)(v40 + 16 * v42 + 8);
                        if (v44 != 0xFFFFFFFFLL) {
                          float v38 = (float)*(unint64_t *)(*(void *)(v36 + 8) + 24 * v44 + 16);
                        }
                      }
                      else
                      {
                        int v46 = 1;
                        while (v43 != -4096)
                        {
                          int v47 = v42 + v46++;
                          uint64_t v42 = v47 & v41;
                          uint64_t v43 = *(void *)(v40 + 16 * v42);
                          if (v43 == v39) {
                            goto LABEL_36;
                          }
                        }
                      }
                    }
                    float v45 = (float)*(unint64_t *)(*(void *)(v36 + 8) + 16);
                  }
                  else
                  {
                    float v38 = 0.0;
                    float v45 = 0.0;
                  }
                  *((float *)v31 + 35) = *((float *)v31 + 35)
                                       + (float)((float)((float)(v35 * 0.0) + 1.0) * (float)(v38 * (float)(1.0 / v45)));
                }
              }
            }
          }
          v25 += 32;
        }
        while (v25 != v26);
      }
      uint64_t v48 = (unint64_t *)(i + 48);
      unint64_t v49 = *(void *)(i + 48);
      if (v49 < 8)
      {
        int v52 = 0;
        uint64_t v48 = 0;
        unint64_t v49 = 0;
        unint64_t v50 = (void *)(a1 + 304);
        goto LABEL_64;
      }
      unint64_t v50 = (void *)(a1 + 304);
      if ((v49 & 7) != 0)
      {
        if ((v49 & 0xFFFFFFFFFFFFFFF8) != 0 && (*(void *)(i + 48) & 7) == 3) {
          int v52 = (unint64_t *)((v49 & 0xFFFFFFFFFFFFFFF8) + 8);
        }
        else {
          int v52 = 0;
        }
      }
      else
      {
        int v52 = (unint64_t *)(i + 48);
        v49 &= 0xFFFFFFFFFFFFFFF8;
        *uint64_t v48 = v49;
        if (!v49)
        {
          int v52 = (unint64_t *)(i + 48);
          uint64_t v48 = 0;
          goto LABEL_64;
        }
      }
      if ((v49 & 7) != 0)
      {
        uint64_t v48 = 0;
        if ((v49 & 7) == 3 && (uint64_t v53 = (int *)(v49 & 0xFFFFFFFFFFFFFFF8), (v49 & 0xFFFFFFFFFFFFFFF8) != 0))
        {
          unint64_t v49 = *v53;
          uint64_t v48 = (unint64_t *)(v53 + 2);
        }
        else
        {
          unint64_t v49 = 0;
        }
      }
      else
      {
        *uint64_t v48 = v49 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v49 = 1;
      }
LABEL_64:
      unint64_t v54 = &v48[v49];
      if (v52 != v54)
      {
        do
        {
          uint64_t v55 = *(void *)*v52;
          if ((v55 & 4) != 0)
          {
            unint64_t v56 = v55 & 0xFFFFFFFFFFFFFFF8;
            if (v56)
            {
              if (*(_DWORD *)(v56 + 8) == 4)
              {
                unsigned int v57 = *(_DWORD *)(v56 + 16);
                if ((v57 & 0x80000000) == 0)
                {
                  uint64_t v58 = *v50 + 80 * v57;
                  unint64_t v59 = *(unsigned int *)(v58 + 8);
                  if (v59 >= *(unsigned int *)(v58 + 12)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)v58 + 8 * v59) = *v52;
                  ++*(_DWORD *)(v58 + 8);
                }
              }
            }
          }
          ++v52;
        }
        while (v52 != v54);
        if (!i) {
          goto LABEL_78;
        }
      }
      if ((*(unsigned char *)i & 4) == 0)
      {
LABEL_78:
        while ((*(_WORD *)(i + 44) & 8) != 0)
          uint64_t i = *(void *)(i + 8);
      }
    }
  }
  int v60 = -*(_DWORD *)(*(void *)(a1 + 256) + 32)
      - 858993459 * ((*(void *)(*(void *)(a1 + 256) + 16) - *(void *)(*(void *)(a1 + 256) + 8)) >> 3);
  uint64_t v316 = a1 + 1720;
  sub_1CC490E7C(a1 + 1720, 1uLL);
  uint64_t v312 = a1 + 1904;
  sub_1CC490E7C(a1 + 1904, 1uLL);
  unint64_t v61 = v60;
  unint64_t v62 = *(void *)(a1 + 1608);
  int v308 = v60;
  if (v62 != v60)
  {
    if (v62 <= v60)
    {
      if (*(void *)(a1 + 1616) < (unint64_t)v60) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      if (v60 != v62) {
        bzero((void *)(*(void *)(a1 + 1600) + v62), v60 - v62);
      }
    }
    *(void *)(a1 + 1608) = v60;
  }
  uint64_t v307 = (void *)(a1 + 1640);
  unint64_t v63 = *(unsigned int *)(a1 + 1648);
  if (v63 != v60)
  {
    if (v63 <= v60)
    {
      if (*(unsigned int *)(a1 + 1652) < (unint64_t)v60) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v60 != v63) {
        bzero((void *)(*v307 + 4 * v63), 4 * (v60 - v63));
      }
    }
    *(_DWORD *)(a1 + 1648) = v60;
  }
  uint64_t v64 = *(void *)v316;
  uint64_t v65 = *(unsigned int *)(*(void *)v316 + 8);
  if ((*(_DWORD *)(*(void *)v316 + 64) & 0x3F) != 0) {
    *(void *)(*(void *)v64 + 8 * v65 - 8) &= ~(-1 << (*(_DWORD *)(*(void *)v316 + 64) & 0x3F));
  }
  unsigned int v66 = v65;
  *(_DWORD *)(v64 + 64) = v308;
  uint64_t v67 = (v308 + 63) >> 6;
  if (v65 != (v308 + 63) >> 6)
  {
    if (v65 <= v67)
    {
      if (v67 > *(_DWORD *)(v64 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v67 != v65) {
        bzero((void *)(*(void *)v64 + 8 * v65), 8 * (v67 - v65));
      }
      unsigned int v66 = (v308 + 63) >> 6;
      *(_DWORD *)(v64 + 8) = v67;
      int v68 = *(_DWORD *)(v64 + 64);
      goto LABEL_101;
    }
    *(_DWORD *)(v64 + 8) = v67;
    unsigned int v66 = (v308 + 63) >> 6;
  }
  LOBYTE(v68) = v308;
LABEL_101:
  int v69 = v68 & 0x3F;
  if (v69) {
    *(void *)(*(void *)v64 + 8 * v66 - 8) &= ~(-1 << v69);
  }
  uint64_t v70 = *(void *)v312;
  uint64_t v71 = *(unsigned int *)(*(void *)v312 + 8);
  if ((*(_DWORD *)(*(void *)v312 + 64) & 0x3F) != 0) {
    *(void *)(*(void *)v70 + 8 * v71 - 8) &= ~(-1 << (*(_DWORD *)(*(void *)v312 + 64) & 0x3F));
  }
  LOBYTE(v72) = v308;
  *(_DWORD *)(v70 + 64) = v308;
  unsigned int v73 = (v308 + 63) >> 6;
  if (v71 != v67)
  {
    if (v71 > v67)
    {
      *(_DWORD *)(v70 + 8) = v67;
      unsigned int v73 = (v308 + 63) >> 6;
      LOBYTE(v72) = v308;
    }
    else
    {
      if (v67 > *(_DWORD *)(v70 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v67 != v71) {
        bzero((void *)(*(void *)v70 + 8 * v71), 8 * (v67 - v71));
      }
      unsigned int v73 = (v308 + 63) >> 6;
      *(_DWORD *)(v70 + 8) = v67;
      int v72 = *(_DWORD *)(v70 + 64);
    }
  }
  int v74 = v72 & 0x3F;
  if (v74) {
    *(void *)(*(void *)v70 + 8 * v73 - 8) &= ~(-1 << v74);
  }
  uint64_t v314 = (void *)(a1 + 2064);
  unint64_t v75 = *(unsigned int *)(a1 + 2072);
  if (v75 != v61)
  {
    if (v75 > v61)
    {
      uint64_t v303 = 3 * v75;
      uint64_t v304 = (void **)(*v314 + 16 * v303 - 48);
      uint64_t v305 = 48 * (int)v61 - 16 * v303;
      do
      {
        if (v304 + 2 != *v304) {
          free(*v304);
        }
        v304 -= 6;
        v305 += 48;
      }
      while (v305);
    }
    else
    {
      if (*(unsigned int *)(a1 + 2076) < v61) {
        sub_1CD57E30C();
      }
      if (v75 != v61)
      {
        uint64_t v76 = 3 * v75;
        uint64_t v77 = 48 * (int)v61 - 48 * v75;
        uint64_t v78 = *v314 + 16 * v76 + 16;
        do
        {
          *(void *)(v78 - 16) = v78;
          *(void *)(v78 - 8) = 0x400000000;
          v78 += 48;
          v77 -= 48;
        }
        while (v77);
      }
    }
    *(_DWORD *)(a1 + 2072) = v308;
  }
  uint64_t v322 = v324;
  uint64_t v323 = 0x1000000000;
  uint64_t v79 = *(void *)(a1 + 248);
  if (*(unsigned int *)(v79 + 376) >= 0x11uLL) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unsigned int v80 = 0;
  for (uint64_t j = *(void **)(v79 + 368); j; uint64_t j = (void *)*j)
  {
    if (v80 >= HIDWORD(v323)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v322 + v80) = j + 2;
    unsigned int v80 = v323 + 1;
    LODWORD(v323) = v323 + 1;
  }
  unint64_t v82 = 126 - 2 * __clz(v80);
  if (v80) {
    uint64_t v83 = v82;
  }
  else {
    uint64_t v83 = 0;
  }
  sub_1CC490F60((unint64_t)v322, (int **)v322 + v80, v83, 1);
  if (v323)
  {
    uint64_t v84 = (char *)v322;
    BOOL v310 = (char *)v322 + 8 * v323;
    do
    {
      int v85 = *(_DWORD *)(*(void *)v84 + 120);
      unsigned int v86 = v85 - 0x40000000;
      if (*(void *)(*(void *)(*(void *)(a1 + 256) + 8)
                     + 40 * (*(_DWORD *)(*(void *)(a1 + 256) + 32) + v85 - 0x40000000)
                     + 8) != -1)
      {
        uint64_t v87 = *(void *)v84 + 8;
        long long v89 = *(uint64_t **)(a1 + 288);
        unint64_t v88 = *(void *)(a1 + 296);
        if ((unint64_t)v89 >= v88)
        {
          long long v91 = *(void **)(a1 + 280);
          uint64_t v92 = v89 - v91;
          unint64_t v93 = v92 + 1;
          if ((unint64_t)(v92 + 1) >> 61) {
            abort();
          }
          uint64_t v94 = v88 - (void)v91;
          if (v94 >> 2 > v93) {
            unint64_t v93 = v94 >> 2;
          }
          if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v95 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v95 = v93;
          }
          if (v95)
          {
            if (v95 >> 61) {
              sub_1CB833614();
            }
            unsigned int v96 = (char *)operator new(8 * v95);
          }
          else
          {
            unsigned int v96 = 0;
          }
          uint64_t v97 = (uint64_t *)&v96[8 * v92];
          *uint64_t v97 = v87;
          uint64_t v90 = v97 + 1;
          if (v89 != v91)
          {
            do
            {
              uint64_t v98 = *--v89;
              *--uint64_t v97 = v98;
            }
            while (v89 != v91);
            long long v89 = *(uint64_t **)(a1 + 280);
          }
          *(void *)(a1 + 280) = v97;
          *(void *)(a1 + 288) = v90;
          *(void *)(a1 + 296) = &v96[8 * v95];
          if (v89) {
            operator delete(v89);
          }
        }
        else
        {
          uint64_t *v89 = v87;
          uint64_t v90 = v89 + 1;
        }
        *(void *)(a1 + 288) = v90;
        *(unsigned char *)(*(void *)(a1 + 1600) + (int)v86) = *(unsigned char *)(*(void *)(*(void *)(a1 + 256) + 8)
                                                                 + 40
                                                                 * (*(_DWORD *)(*(void *)(a1 + 256) + 32) + v86)
                                                                 + 16);
        uint64_t v99 = *(void *)(a1 + 256);
        uint64_t v100 = *(void *)(v99 + 8);
        *(_DWORD *)(*(void *)(a1 + 1640) + 4 * (int)v86) = *(void *)(v100
                                                                         + 40 * (*(_DWORD *)(v99 + 32) + v86)
                                                                         + 8);
        uint64_t v101 = v100 + 40 * (*(_DWORD *)(v99 + 32) + v86);
        uint64_t v102 = *(unsigned __int8 *)(v101 + 20);
        if (*(unsigned char *)(v101 + 20))
        {
          sub_1CC490E7C(v316, v102 + 1);
          sub_1CC490E7C(v312, v102 + 1);
          uint64_t v103 = *(void *)v316 + 72 * v102;
          size_t v104 = (int *)(v103 + 64);
          char v105 = *(_DWORD *)(v103 + 64) & 0x3F;
          uint64_t v106 = *(unsigned int *)(v103 + 8);
          if (v105) {
            *(void *)(*(void *)v103 + 8 * v106 - 8) &= ~(-1 << v105);
          }
          LOBYTE(v107) = v308;
          *size_t v104 = v308;
          unsigned int v108 = (v308 + 63) >> 6;
          if (v106 != v67)
          {
            if (v106 > v67)
            {
              *(_DWORD *)(v103 + 8) = v67;
              unsigned int v108 = (v308 + 63) >> 6;
              LOBYTE(v107) = v308;
            }
            else
            {
              if (v67 > *(_DWORD *)(v103 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v67 != v106) {
                bzero((void *)(*(void *)v103 + 8 * v106), 8 * (v67 - v106));
              }
              unsigned int v108 = (v308 + 63) >> 6;
              *(_DWORD *)(v103 + 8) = v67;
              int v107 = *v104;
            }
          }
          int v109 = v107 & 0x3F;
          if (v109) {
            *(void *)(*(void *)v103 + 8 * v108 - 8) &= ~(-1 << v109);
          }
          uint64_t v110 = *(void *)v312 + 72 * v102;
          unsigned int v111 = (int *)(v110 + 64);
          char v112 = *(_DWORD *)(v110 + 64) & 0x3F;
          uint64_t v113 = *(unsigned int *)(v110 + 8);
          if (v112) {
            *(void *)(*(void *)v110 + 8 * v113 - 8) &= ~(-1 << v112);
          }
          LOBYTE(v114) = v308;
          *unsigned int v111 = v308;
          unsigned int v115 = (v308 + 63) >> 6;
          if (v113 != v67)
          {
            if (v113 > v67)
            {
              *(_DWORD *)(v110 + 8) = v67;
              unsigned int v115 = (v308 + 63) >> 6;
              LOBYTE(v114) = v308;
            }
            else
            {
              if (v67 > *(_DWORD *)(v110 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              if (v67 != v113) {
                bzero((void *)(*(void *)v110 + 8 * v113), 8 * (v67 - v113));
              }
              unsigned int v115 = (v308 + 63) >> 6;
              *(_DWORD *)(v110 + 8) = v67;
              int v114 = *v111;
            }
          }
          int v116 = v114 & 0x3F;
          if (v116) {
            *(void *)(*(void *)v110 + 8 * v115 - 8) &= ~(-1 << v116);
          }
        }
        uint64_t v117 = *(void *)(*(void *)v316 + 72 * v102);
        *(void *)(v117 + 8 * (v86 >> 6)) |= 1 << v85;
      }
      v84 += 8;
    }
    while (v84 != v310);
  }
  sub_1CC490DA4(*(char **)(a1 + 280), *(char **)(a1 + 288));
  __int16 v118 = (uint64_t *)(a1 + 1880);
  sub_1CBB1173C(a1 + 1880, *(unsigned int *)(a1 + 1728));
  uint64_t v119 = *(unsigned int *)(a1 + 1728);
  if (v119)
  {
    uint64_t v120 = 0;
    uint64_t v121 = *(void *)v316;
    uint64_t v122 = *v118;
    do
    {
      int v123 = *(_DWORD *)(v121 + 72 * v120 + 64);
      if (v123)
      {
        uint64_t v124 = 0;
        int v125 = -v123;
        int v126 = v123 - 1;
        uint64_t v127 = *(uint64_t **)(v121 + 72 * v120);
        unint64_t v128 = 0xFFFFFFFFFFFFFFFFLL >> v125;
        uint64_t v129 = v126 & 0xFFFFFFC0;
        while (1)
        {
          uint64_t v131 = *v127++;
          uint64_t v130 = v131;
          unint64_t v132 = v129 == v124 ? v128 : -1;
          unint64_t v133 = v132 & v130;
          if (v133) {
            break;
          }
          v124 += 64;
          if (v129 + 64 == v124) {
            goto LABEL_187;
          }
        }
        int v134 = __clz(__rbit64(v133)) + v124;
      }
      else
      {
LABEL_187:
        int v134 = -1;
      }
      *(_DWORD *)(v122 + 4 * v120++) = v134;
    }
    while (v120 != v119);
  }
  if (v322 != v324) {
    free(v322);
  }
  uint64_t v135 = *(void *)(a1 + 256);
  int v136 = -858993459 * ((*(void *)(v135 + 16) - *(void *)(v135 + 8)) >> 3);
  int v137 = *(_DWORD *)(v135 + 32);
  unint64_t v138 = (v136 - v137);
  uint64_t v329 = v332;
  int v331 = 16;
  if (v138 > 0x10)
  {
    int v330 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v136 == v137)
  {
    int v330 = v136 - v137;
    uint64_t v325 = v328;
    int v327 = 16;
  }
  else
  {
    memset(v332, 255, 4 * v138);
    int v330 = v138;
    uint64_t v325 = v328;
    int v327 = 16;
    bzero(v328, 4 * v138);
  }
  int v326 = v138;
  int v319 = v321;
  uint64_t v320 = 0x400000000;
  uint64_t v322 = v324;
  uint64_t v323 = 0x1000000000;
  sub_1CC37DAB4((char **)&v322, v138, (uint64_t)&v319);
  if (v319 != v321) {
    free(v319);
  }
  int v319 = v321;
  HIDWORD(v320) = 6;
  if ((v138 + 63) >= 0x1C0)
  {
    LODWORD(v320) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if ((v138 + 63) >= 0x40) {
    bzero(v321, 8 * ((v138 + 63) >> 6));
  }
  LODWORD(v320) = (v138 + 63) >> 6;
  v321[12] = v138;
  uint64_t v139 = *(char **)(a1 + 280);
  unsigned int v309 = (void **)(a1 + 1880);
  int v311 = *(char **)(a1 + 288);
  if (v139 == v311)
  {
    sub_1CC490DA4(v139, v139);
LABEL_406:
    uint64_t v13 = 0;
    goto LABEL_407;
  }
  char v140 = 0;
  do
  {
    uint64_t v141 = *(void *)v139;
    int v142 = *(_DWORD *)(*(void *)v139 + 112) - 0x40000000;
    uint64_t v143 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 256) + 8)
                              + 40 * (*(_DWORD *)(*(void *)(a1 + 256) + 32) + v142)
                              + 20);
    uint64_t v144 = *(void *)(a1 + 1904);
    if (!byte_1EBCD4088)
    {
      int v145 = *(_DWORD *)(v144
                       + 72
                       * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 256) + 8)
                                            + 40 * (*(_DWORD *)(*(void *)(a1 + 256) + 32) + v142)
                                            + 20)
                       + 64);
      if (v145)
      {
        uint64_t v146 = 0;
        int v147 = -v145;
        int v148 = v145 - 1;
        uint64_t v149 = *(uint64_t **)(v144
                           + 72
                           * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 256) + 8)
                                                + 40
                                                * (*(_DWORD *)(*(void *)(a1 + 256) + 32) + v142)
                                                + 20));
        unint64_t v150 = 0xFFFFFFFFFFFFFFFFLL >> v147;
        uint64_t v151 = v148 & 0xFFFFFFC0;
        while (1)
        {
          uint64_t v153 = *v149++;
          uint64_t v152 = v153;
          uint64_t v154 = v151 + v146 ? -1 : v150;
          unint64_t v155 = v154 & v152;
          if (v155) {
            break;
          }
          v146 -= 64;
          if (v151 + v146 == -64) {
            goto LABEL_241;
          }
        }
        int v156 = __clz(__rbit64(v155));
        if (v156 + 1 != v146)
        {
          LODWORD(v157) = v156 - v146;
          while (1)
          {
            uint64_t v158 = *v314 + 48 * (int)v157;
            uint64_t v159 = *(unsigned int *)(v158 + 8);
            if (!v159) {
              break;
            }
            uint64_t v160 = 0;
            uint64_t v161 = 8 * v159;
            while (!*(_DWORD *)(v141 + 8)
                 || !llvm::LiveRange::overlapsFrom(*(void *)(*(void *)v158 + v160), v141, *(void **)v141))
            {
              v160 += 8;
              if (v161 == v160) {
                goto LABEL_238;
              }
            }
            uint64_t v144 = *(void *)v312;
            uint64_t v162 = *(void *)v312 + 72 * v143;
            unsigned int v163 = v157 + 1;
            int v164 = *(_DWORD *)(v162 + 64);
            if (v157 + 1 == v164)
            {
              __int16 v118 = (uint64_t *)(a1 + 1880);
              goto LABEL_241;
            }
            unsigned int v165 = v163 >> 6;
            unsigned int v166 = v164 - 1;
            __int16 v118 = (uint64_t *)(a1 + 1880);
            if (v163 >> 6 <= (v164 - 1) >> 6)
            {
              uint64_t v167 = 0;
              uint64_t v168 = v166 >> 6;
              int v169 = v163 & 0x3F;
              BOOL v12 = v169 == 0;
              unint64_t v170 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v169;
              uint64_t v171 = *(void *)v162;
              uint64_t v172 = v12 ? -1 : ~v170;
              unint64_t v173 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v166;
              int v174 = v165 << 6;
              uint64_t v175 = v168 - v165;
              uint64_t v176 = v171 + 8 * v165;
              while (1)
              {
                uint64_t v177 = v167 ? -1 : v172;
                unint64_t v178 = v175 == v167 ? v173 : -1;
                unint64_t v179 = v177 & v178 & *(void *)(v176 + 8 * v167);
                if (v179) {
                  break;
                }
                v174 += 64;
                if (v175 + 1 == ++v167) {
                  goto LABEL_241;
                }
              }
              LODWORD(v157) = __clz(__rbit64(v179)) + v174;
              if (v157 != -1) {
                continue;
              }
            }
            goto LABEL_241;
          }
LABEL_238:
          if (*(unsigned __int8 *)(*(void *)(*(void *)(a1 + 256) + 8)
                                  + 40 * (*(_DWORD *)(*(void *)(a1 + 256) + 32) + v157)
                                  + 20) == *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 256) + 8)
                                                              + 40
                                                              * (*(_DWORD *)(*(void *)(a1 + 256) + 32)
                                                                             + v142)
                                                              + 20))
          {
            uint64_t v180 = (int)v157;
            int v181 = 1;
            __int16 v118 = (uint64_t *)(a1 + 1880);
            goto LABEL_258;
          }
          uint64_t v144 = *(void *)v312;
          __int16 v118 = (uint64_t *)(a1 + 1880);
        }
      }
    }
LABEL_241:
    uint64_t v182 = *v118;
    unint64_t v157 = *(unsigned int *)(*v118 + 4 * v143);
    *(void *)(*(void *)(v144 + 72 * v143) + ((v157 >> 3) & 0x1FFFFFF8)) |= 1 << v157;
    uint64_t v183 = *(void *)v316 + 72 * v143;
    unsigned int v184 = v157 + 1;
    int v185 = *(_DWORD *)(v183 + 64);
    if (v157 + 1 == v185 || (unsigned int v186 = v184 >> 6, v187 = v185 - 1, v184 >> 6 > (v185 - 1) >> 6))
    {
      int v201 = -1;
    }
    else
    {
      uint64_t v188 = 0;
      uint64_t v189 = v187 >> 6;
      int v190 = v184 & 0x3F;
      BOOL v12 = v190 == 0;
      unint64_t v191 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v190;
      unint64_t v192 = 0xFFFFFFFFFFFFFFFFLL >> ~(_BYTE)v187;
      uint64_t v193 = *(void *)v183;
      if (v12) {
        uint64_t v194 = -1;
      }
      else {
        uint64_t v194 = ~v191;
      }
      int v195 = -64 * v186;
      uint64_t v196 = v189 - v186;
      uint64_t v197 = v193 + 8 * v186;
      while (1)
      {
        uint64_t v198 = v188 ? -1 : v194;
        unint64_t v199 = v196 == v188 ? v192 : -1;
        unint64_t v200 = v198 & v199 & *(void *)(v197 + 8 * v188);
        if (v200) {
          break;
        }
        v195 -= 64;
        if (v196 + 1 == ++v188)
        {
          int v201 = -1;
          goto LABEL_257;
        }
      }
      int v201 = __clz(__rbit64(v200)) - v195;
    }
LABEL_257:
    int v181 = 0;
    uint64_t v180 = (int)v157;
    *(_DWORD *)(v182 + 4 * v143) = v201;
LABEL_258:
    uint64_t v202 = *v314 + 48 * (int)v180;
    unint64_t v203 = *(unsigned int *)(v202 + 8);
    if (v203 >= *(unsigned int *)(v202 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)v202 + 8 * v203) = v141;
    ++*(_DWORD *)(v202 + 8);
    unsigned int v204 = *(unsigned __int8 *)(*(void *)(a1 + 1600) + v142);
    uint64_t v205 = *(void *)(a1 + 256);
    if (v181)
    {
      unsigned int v206 = *(_DWORD *)(v205 + 32) + v157;
      uint64_t v207 = *(void *)(v205 + 8);
      if (v204 <= *(unsigned __int8 *)(v207 + 40 * v206 + 16))
      {
        uint64_t v208 = *(unsigned int *)(*v307 + 4 * v142);
LABEL_267:
        if (*(void *)(v207 + 40 * v206 + 8) >= v208) {
          goto LABEL_269;
        }
        goto LABEL_268;
      }
    }
    else
    {
      uint64_t v207 = *(void *)(v205 + 8);
      unsigned int v206 = *(_DWORD *)(v205 + 32) + v157;
    }
    *(unsigned char *)(v207 + 40 * v206 + 16) = v204;
    if (!*(unsigned char *)(*(void *)(v205 + 8) + 40 * (*(_DWORD *)(v205 + 32) + v157) + 20)
      && v204 > *(unsigned __int8 *)(v205 + 60))
    {
      *(unsigned char *)(v205 + 60) = v204;
    }
    uint64_t v208 = *(unsigned int *)(*(void *)(a1 + 1640) + 4 * v142);
    uint64_t v209 = *(void *)(a1 + 256);
    int v210 = *(_DWORD *)(v209 + 32);
    uint64_t v207 = *(void *)(v209 + 8);
    unsigned int v206 = v210 + v157;
    if (v181) {
      goto LABEL_267;
    }
LABEL_268:
    *(void *)(v207 + 40 * v206 + 8) = v208;
LABEL_269:
    v329[v142] = v157;
    uint64_t v211 = (char *)v322 + 32 * v180;
    unint64_t v212 = *((unsigned int *)v211 + 2);
    if (v212 >= *((unsigned int *)v211 + 3)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)v211 + 4 * v212) = v142;
    ++*((_DWORD *)v211 + 2);
    uint64_t v213 = v325;
    *((float *)v325 + v180) = *(float *)(v141 + 116) + *((float *)v325 + v180);
    *((void *)v319 + (v157 >> 6)) |= 1 << v157;
    v140 |= v142 != v157;
    v139 += 8;
  }
  while (v139 != v311);
  uint64_t v214 = *(char **)(a1 + 280);
  uint64_t v215 = *(char **)(a1 + 288);
  if (v214 != v215)
  {
    uint64_t v216 = *(char **)(a1 + 280);
    do
    {
      uint64_t v217 = *(void *)v216;
      v216 += 8;
      *(_DWORD *)(v217 + 116) = v213[*(_DWORD *)(v217 + 112) - 0x40000000];
    }
    while (v216 != v215);
  }
  sub_1CC490DA4(v214, v215);
  if ((v140 & 1) == 0) {
    goto LABEL_406;
  }
  uint64_t v218 = *(unsigned int *)(a1 + 312);
  if (v218)
  {
    for (uint64_t k = 0; k != v218; ++k)
    {
      uint64_t v220 = v329[k];
      if (v220 != -1 && k != v220)
      {
        FixedStacuint64_t k = llvm::PseudoSourceValueManager::getFixedStack(*(uint64_t ***)(v306 + 432), v220);
        uint64_t v223 = *(void *)(a1 + 304) + 80 * k;
        uint64_t v224 = *(unsigned int *)(v223 + 8);
        if (v224)
        {
          int v225 = *(unint64_t ***)v223;
          do
          {
            uint64_t v226 = *v225++;
            unint64_t *v226 = (unint64_t)FixedStack | 4;
            --v224;
          }
          while (v224);
        }
      }
    }
  }
  uint64_t v227 = *(void *)(v306 + 328);
  if (v227 != v313)
  {
    while (1)
    {
      uint64_t v228 = v227 + 48;
      uint64_t v229 = *(void *)(v227 + 56);
      if (v229 != v227 + 48)
      {
        int v230 = v329;
        do
        {
          uint64_t v231 = *(unsigned int *)(v229 + 40);
          if (v231)
          {
            uint64_t v232 = 32 * v231;
            uint64_t v233 = (_DWORD *)(*(void *)(v229 + 32) + 16);
            do
            {
              if (*((unsigned char *)v233 - 16) == 5)
              {
                uint64_t v234 = *v233;
                if ((v234 & 0x80000000) == 0)
                {
                  int v235 = v230[v234];
                  if (v235 != -1 && v235 != v234) {
                    *uint64_t v233 = v235;
                  }
                }
              }
              v233 += 8;
              v232 -= 32;
            }
            while (v232);
            if (!v229) {
              goto LABEL_308;
            }
          }
          if ((*(unsigned char *)v229 & 4) == 0)
          {
LABEL_308:
            while ((*(_WORD *)(v229 + 44) & 8) != 0)
              uint64_t v229 = *(void *)(v229 + 8);
          }
          uint64_t v229 = *(void *)(v229 + 8);
        }
        while (v229 != v228);
        uint64_t v229 = *(void *)(v227 + 56);
      }
      unsigned int v333 = (llvm::MachineInstr **)v335;
      uint64_t v334 = 0x400000000;
      if (v229 != v228) {
        break;
      }
LABEL_382:
      uint64_t v227 = *(void *)(v227 + 8);
      if (v227 == v313) {
        goto LABEL_383;
      }
    }
    while (2)
    {
      if (dword_1EBCD4148 != -1 && dword_1EBCD4148 < 1)
      {
LABEL_376:
        uint64_t v250 = v333;
        if (v334)
        {
          uint64_t v251 = 8 * v334;
          do
          {
            uint64_t v252 = *v250++;
            llvm::MachineInstr::eraseFromParent(v252);
            v251 -= 8;
          }
          while (v251);
          uint64_t v250 = v333;
        }
        if (v250 != v335) {
          free(v250);
        }
        goto LABEL_382;
      }
      uint64_t v318 = 0;
      if ((*(unsigned int (**)(void, uint64_t, char *, uint64_t *))(**(void **)(a1 + 264) + 128))(*(void *)(a1 + 264), v229, (char *)&v318 + 4, &v318)&& (HIDWORD(v318) != -1 ? (BOOL v238 = HIDWORD(v318) == v318) : (BOOL v238 = 0), v238))
      {
        if (v334 >= (unint64_t)HIDWORD(v334)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        v333[v334] = (llvm::MachineInstr *)v229;
        LODWORD(v334) = v334 + 1;
        if (v229) {
          goto LABEL_356;
        }
      }
      else
      {
        if (!v229 || (uint64_t v239 = v229, (*(unsigned char *)v229 & 4) == 0))
        {
          uint64_t v239 = v229;
          if ((*(_WORD *)(v229 + 44) & 8) != 0)
          {
            uint64_t v239 = v229;
            do
              uint64_t v239 = *(void *)(v239 + 8);
            while ((*(_WORD *)(v239 + 44) & 8) != 0);
          }
        }
        uint64_t v240 = *(void *)(v239 + 8);
        uint64_t v317 = 0;
        unsigned int v241 = (*(uint64_t (**)(void, uint64_t, char *, char *))(**(void **)(a1 + 264) + 72))(*(void *)(a1 + 264), v229, (char *)&v318 + 4, (char *)&v317 + 4);
        if (v241) {
          BOOL v242 = v240 == v228;
        }
        else {
          BOOL v242 = 1;
        }
        if (v242)
        {
          uint64_t v244 = v229;
        }
        else
        {
          unsigned int v243 = v241;
          uint64_t v244 = v229;
          while (**(unsigned __int16 **)(v240 + 16) - 13 <= 4)
          {
            if ((*(unsigned char *)v240 & 4) == 0)
            {
              while ((*(_WORD *)(v240 + 44) & 8) != 0)
                uint64_t v240 = *(void *)(v240 + 8);
            }
            if (!v244 || (*(unsigned char *)v244 & 4) == 0)
            {
              while ((*(_WORD *)(v244 + 44) & 8) != 0)
                uint64_t v244 = *(void *)(v244 + 8);
            }
            uint64_t v240 = *(void *)(v240 + 8);
            uint64_t v244 = *(void *)(v244 + 8);
            if (v240 == v228) {
              goto LABEL_355;
            }
          }
          int v245 = (*(uint64_t (**)(void, uint64_t, uint64_t *, uint64_t *))(**(void **)(a1 + 264) + 104))(*(void *)(a1 + 264), v240, &v318, &v317);
          if (v245)
          {
            BOOL v246 = HIDWORD(v318) == v318 && v243 == v245;
            BOOL v247 = !v246 || HIDWORD(v318) == -1;
            if (!v247 && HIDWORD(v317) == v317)
            {
              int RegisterUseOperandIdx = llvm::MachineInstr::findRegisterUseOperandIdx(v240, v243, 1, 0);
              unsigned int v249 = v334;
              if (RegisterUseOperandIdx != -1)
              {
                if (v334 >= HIDWORD(v334)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v333[v334] = (llvm::MachineInstr *)v229;
                unsigned int v249 = v334 + 1;
                LODWORD(v334) = v334 + 1;
              }
              if (v249 >= HIDWORD(v334)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v333[v249] = (llvm::MachineInstr *)v240;
              LODWORD(v334) = v334 + 1;
              if (!v244 || (*(unsigned char *)v244 & 4) == 0)
              {
                while ((*(_WORD *)(v244 + 44) & 8) != 0)
                  uint64_t v244 = *(void *)(v244 + 8);
              }
              uint64_t v244 = *(void *)(v244 + 8);
            }
          }
        }
LABEL_355:
        uint64_t v229 = v244;
        if (v244)
        {
LABEL_356:
          if ((*(unsigned char *)v229 & 4) != 0) {
            goto LABEL_360;
          }
        }
      }
      while ((*(_WORD *)(v229 + 44) & 8) != 0)
        uint64_t v229 = *(void *)(v229 + 8);
LABEL_360:
      uint64_t v229 = *(void *)(v229 + 8);
      if (v229 == v228) {
        goto LABEL_376;
      }
      continue;
    }
  }
LABEL_383:
  uint64_t v253 = *(unsigned int *)(a1 + 1728);
  if (v253)
  {
    uint64_t v254 = 0;
    uint64_t v255 = *v309;
    do
    {
      int v256 = v255[v254];
      if (v256 != -1)
      {
        uint64_t v257 = *(void *)(a1 + 256);
        int v258 = *(_DWORD *)(v257 + 32);
        uint64_t v259 = *(void *)(v257 + 8);
        uint64_t v260 = *(void *)(a1 + 1720) + 72 * v254;
        int v261 = *(_DWORD *)(v260 + 64);
        uint64_t v262 = (v261 - 1) >> 6;
        do
        {
          *(void *)(v259 + 40 * (v256 + v258) + 8) = -1;
          unsigned int v263 = v256 + 1;
          if (v256 + 1 == v261) {
            break;
          }
          unsigned int v264 = v263 >> 6;
          if (v263 >> 6 > v262) {
            break;
          }
          uint64_t v265 = 0;
          int v266 = v263 & 0x3F;
          BOOL v12 = v266 == 0;
          unint64_t v267 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v266;
          uint64_t v268 = v12 ? -1 : ~v267;
          int v269 = v264 << 6;
          uint64_t v270 = v262 - v264;
          uint64_t v271 = *(void *)v260 + 8 * v264;
          while (1)
          {
            uint64_t v272 = v265 ? -1 : v268;
            unint64_t v273 = v270 == v265 ? 0xFFFFFFFFFFFFFFFFLL >> -(char)v261 : -1;
            unint64_t v274 = v272 & v273 & *(void *)(v271 + 8 * v265);
            if (v274) {
              break;
            }
            v269 += 64;
            if (v270 + 1 == ++v265) {
              goto LABEL_403;
            }
          }
          int v256 = __clz(__rbit64(v274)) + v269;
        }
        while (v256 != -1);
      }
LABEL_403:
      ++v254;
    }
    while (v254 != v253);
    uint64_t v13 = 1;
  }
  else
  {
    uint64_t v13 = 1;
  }
LABEL_407:
  if (v319 != v321) {
    free(v319);
  }
  uint64_t v275 = (char *)v322;
  if (v323)
  {
    uint64_t v276 = 32 * v323;
    do
    {
      unsigned int v277 = *(char **)&v275[v276 - 32];
      if (&v275[v276 - 16] != v277) {
        free(v277);
      }
      v276 -= 32;
    }
    while (v276);
    uint64_t v275 = (char *)v322;
  }
  if (v275 != v324) {
    free(v275);
  }
  if (v325 != v328) {
    free(v325);
  }
  if (v329 != (_DWORD *)v332) {
    free(v329);
  }
  uint64_t v278 = *(unsigned int *)(a1 + 1888);
  if (v278) {
    memset(*v309, 255, 4 * v278);
  }
  *(void *)(a1 + 288) = *(void *)(a1 + 280);
  uint64_t v279 = *(unsigned int *)(a1 + 312);
  if (v279)
  {
    uint64_t v280 = *(void *)(a1 + 304);
    int v281 = (_DWORD *)(v280 + 8);
    do
    {
      _DWORD *v281 = 0;
      v281 += 20;
      --v279;
    }
    while (v279);
    uint64_t v282 = *(unsigned int *)(a1 + 312);
    if (v282)
    {
      uint64_t v283 = 80 * v282;
      do
      {
        uint64_t v284 = *(void **)(v280 + v283 - 80);
        if ((void *)(v280 + v283 - 64) != v284) {
          free(v284);
        }
        v283 -= 80;
      }
      while (v283);
    }
  }
  *(_DWORD *)(a1 + 312) = 0;
  *(void *)(a1 + 1608) = 0;
  *(_DWORD *)(a1 + 1648) = 0;
  uint64_t v285 = *(unsigned int *)(a1 + 1728);
  if (v285)
  {
    uint64_t v286 = *(void *)(a1 + 1720);
    uint64_t v287 = 72 * v285;
    do
    {
      uint64_t v288 = *(void **)(v286 + v287 - 72);
      if ((void *)(v286 + v287 - 56) != v288) {
        free(v288);
      }
      v287 -= 72;
    }
    while (v287);
  }
  *(_DWORD *)(a1 + 1728) = 0;
  uint64_t v289 = *(unsigned int *)(a1 + 1912);
  if (v289)
  {
    uint64_t v290 = *(void *)(a1 + 1904);
    uint64_t v291 = 72 * v289;
    do
    {
      uint64_t v292 = *(void **)(v290 + v291 - 72);
      if ((void *)(v290 + v291 - 56) != v292) {
        free(v292);
      }
      v291 -= 72;
    }
    while (v291);
  }
  *(_DWORD *)(a1 + 1912) = 0;
  uint64_t v293 = *(unsigned int *)(a1 + 2072);
  if (v293)
  {
    uint64_t v294 = *(void *)(a1 + 2064);
    uint64_t v295 = (_DWORD *)(v294 + 8);
    do
    {
      *uint64_t v295 = 0;
      v295 += 12;
      --v293;
    }
    while (v293);
    uint64_t v296 = *(unsigned int *)(a1 + 2072);
    if (v296)
    {
      uint64_t v297 = 48 * v296;
      do
      {
        uint64_t v298 = *(void **)(v294 + v297 - 48);
        if ((void *)(v294 + v297 - 32) != v298) {
          free(v298);
        }
        v297 -= 48;
      }
      while (v297);
    }
  }
  *(_DWORD *)(a1 + 2072) = 0;
  return v13;
}

void sub_1CC490DA4(char *a1, char *a2)
{
  unint64_t v4 = (a2 - a1) >> 3;
  if (a2 - a1 < 1025)
  {
LABEL_5:
    sub_1CC4919C0(a1, a2, v4, 0, 0);
  }
  else
  {
    uint64_t v5 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v6 = (a2 - a1) >> 3;
    while (1)
    {
      uint64_t v7 = (uint64_t *)operator new(8 * v6, v5);
      if (v7) {
        break;
      }
      BOOL v8 = v6 > 1;
      v6 >>= 1;
      if (!v8) {
        goto LABEL_5;
      }
    }
    uint64_t v9 = v7;
    sub_1CC4919C0(a1, a2, v4, v7, v6);
    operator delete(v9);
  }
}

uint64_t sub_1CC490E7C(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 != a2)
  {
    if (v2 > a2)
    {
      uint64_t v6 = 9 * v2;
      uint64_t v7 = (void **)(*(void *)result + 8 * v6 - 72);
      uint64_t v8 = 72 * a2 - 8 * v6;
      int v9 = a2;
      uint64_t v10 = result;
      do
      {
        if (v7 + 2 != *v7) {
          free(*v7);
        }
        v7 -= 9;
        v8 += 72;
        LODWORD(a2) = v9;
        uint64_t result = v10;
      }
      while (v8);
    }
    else
    {
      if (*(unsigned int *)(result + 12) < a2) {
        sub_1CD4C75A0();
      }
      if (v2 != a2)
      {
        uint64_t v3 = 9 * v2;
        uint64_t v4 = *(void *)result + 72 * v2;
        uint64_t v5 = 72 * a2 - 8 * v3;
        do
        {
          *(void *)uint64_t v4 = v4 + 16;
          *(void *)(v4 + 8) = 0x600000000;
          *(_DWORD *)(v4 + 64) = 0;
          v4 += 72;
          v5 -= 72;
        }
        while (v5);
      }
    }
    *(_DWORD *)(result + 8) = a2;
  }
  return result;
}

unint64_t sub_1CC490F60(unint64_t result, int **a2, uint64_t a3, char a4)
{
  int v9 = (int **)result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          uint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t v39 = *(a2 - 1);
                uint64_t v40 = *v10;
                if (*v39 < **v10)
                {
                  *uint64_t v10 = v39;
                  *(a2 - 1) = v40;
                }
                break;
              case 3:
                uint64_t result = (unint64_t)sub_1CC491694(v10, v10 + 1, a2 - 1);
                break;
              case 4:
                uint64_t result = (unint64_t)sub_1CC491928(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5:
                unsigned int v41 = v10 + 1;
                uint64_t v42 = v10 + 2;
                uint64_t v43 = v10 + 3;
                uint64_t result = (unint64_t)sub_1CC491928(v10, v10 + 1, v10 + 2, v10 + 3);
                uint64_t v44 = *(a2 - 1);
                float v45 = v10[3];
                if (*v44 < *v45)
                {
                  unsigned __int8 *v43 = v44;
                  *(a2 - 1) = v45;
                  int v46 = *v43;
                  int v47 = *v42;
                  int v48 = **v43;
                  if (v48 < **v42)
                  {
                    *uint64_t v42 = v46;
                    unsigned __int8 *v43 = v47;
                    unint64_t v49 = *v41;
                    if (v48 < **v41)
                    {
                      v10[1] = v46;
                      v10[2] = v49;
                      unint64_t v50 = *v10;
                      if (v48 < **v10)
                      {
                        *uint64_t v10 = v46;
                        v10[1] = v50;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            uint64_t v51 = v10 + 1;
            BOOL v53 = v10 == a2 || v51 == a2;
            if (a4)
            {
              if (!v53)
              {
                uint64_t v54 = 8;
                uint64_t v55 = v10;
                do
                {
                  unsigned int v57 = *v55;
                  unint64_t v56 = v55[1];
                  uint64_t v55 = v51;
                  int v58 = *v56;
                  if (*v56 < *v57)
                  {
                    uint64_t v59 = v54;
                    do
                    {
                      *(int **)((char *)v10 + v59) = v57;
                      uint64_t v60 = v59 - 8;
                      if (v59 == 8)
                      {
                        unint64_t v61 = v10;
                        goto LABEL_84;
                      }
                      unsigned int v57 = *(int **)((char *)v10 + v59 - 16);
                      v59 -= 8;
                    }
                    while (v58 < *v57);
                    unint64_t v61 = (int **)((char *)v10 + v60);
LABEL_84:
                    *unint64_t v61 = v56;
                  }
                  uint64_t v51 = v55 + 1;
                  v54 += 8;
                }
                while (v55 + 1 != a2);
              }
            }
            else if (!v53)
            {
              do
              {
                unint64_t v93 = *v9;
                uint64_t v92 = v9[1];
                int v9 = v51;
                int v94 = *v92;
                if (*v92 < *v93)
                {
                  do
                  {
                    *uint64_t v51 = v93;
                    unint64_t v93 = *(v51 - 2);
                    --v51;
                  }
                  while (v94 < *v93);
                  *uint64_t v51 = v92;
                }
                uint64_t v51 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v62 = (unint64_t)(v12 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  unsigned int v66 = &v10[v65];
                  uint64_t v67 = *v66;
                  if (2 * v64 + 2 < v12)
                  {
                    int v68 = *v67;
                    uint64_t result = *v66[1];
                    if (*v67 <= (int)result) {
                      int v68 = *v66[1];
                    }
                    if (*v67 < (int)result)
                    {
                      uint64_t v67 = v66[1];
                      ++v66;
                      uint64_t v65 = 2 * v64 + 2;
                    }
                  }
                  else
                  {
                    int v68 = *v67;
                  }
                  int v69 = &v10[v64];
                  uint64_t v70 = *v69;
                  int v71 = **v69;
                  if (v68 >= v71)
                  {
                    do
                    {
                      int v72 = v66;
                      *int v69 = v67;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t v73 = (2 * v65) | 1;
                      unsigned int v66 = &v10[v73];
                      uint64_t v65 = 2 * v65 + 2;
                      uint64_t v67 = *v66;
                      if (v65 < v12)
                      {
                        LODWORD(result) = *v67;
                        signed int v74 = *v66[1];
                        uint64_t result = *v67 <= v74 ? v74 : result;
                        if (*v67 >= v74)
                        {
                          uint64_t v65 = v73;
                        }
                        else
                        {
                          uint64_t v67 = v66[1];
                          ++v66;
                        }
                      }
                      else
                      {
                        uint64_t result = *v67;
                        uint64_t v65 = v73;
                      }
                      int v69 = v72;
                    }
                    while ((int)result >= v71);
                    *int v72 = v70;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              do
              {
                uint64_t v75 = 0;
                uint64_t v76 = *v10;
                uint64_t v77 = v10;
                do
                {
                  uint64_t v78 = &v77[v75];
                  __int16 v81 = (unsigned int *)v78[1];
                  uint64_t v79 = v78 + 1;
                  unsigned int v80 = (int *)v81;
                  uint64_t v82 = (2 * v75) | 1;
                  uint64_t v83 = 2 * v75 + 2;
                  if (v83 < v12)
                  {
                    uint64_t result = *v80;
                    if ((int)result < *v79[1])
                    {
                      unsigned int v80 = v79[1];
                      ++v79;
                      uint64_t v82 = v83;
                    }
                  }
                  void *v77 = v80;
                  uint64_t v77 = v79;
                  uint64_t v75 = v82;
                }
                while (v82 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                if (v79 == --a2)
                {
                  *uint64_t v79 = v76;
                }
                else
                {
                  *uint64_t v79 = *a2;
                  *a2 = v76;
                  uint64_t v84 = (char *)v79 - (char *)v10 + 8;
                  if (v84 >= 9)
                  {
                    unint64_t v85 = (((unint64_t)v84 >> 3) - 2) >> 1;
                    unsigned int v86 = &v10[v85];
                    uint64_t v87 = *v86;
                    unint64_t v88 = *v79;
                    int v89 = **v79;
                    if (**v86 < v89)
                    {
                      do
                      {
                        uint64_t v90 = v86;
                        *uint64_t v79 = v87;
                        if (!v85) {
                          break;
                        }
                        unint64_t v85 = (v85 - 1) >> 1;
                        unsigned int v86 = &v10[v85];
                        uint64_t v87 = *v86;
                        uint64_t v79 = v90;
                      }
                      while (**v86 < v89);
                      *uint64_t v90 = v88;
                    }
                  }
                }
              }
              while (v12-- > 2);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          int v14 = &v10[(unint64_t)v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            sub_1CC491694(v9, &v9[(unint64_t)v12 >> 1], a2 - 1);
            sub_1CC491694(v9 + 1, v14 - 1, a2 - 2);
            sub_1CC491694(v9 + 2, &v9[v13 + 1], a2 - 3);
            uint64_t result = (unint64_t)sub_1CC491694(v14 - 1, v14, &v9[v13 + 1]);
            int v15 = *v9;
            *int v9 = *v14;
            *int v14 = v15;
          }
          else
          {
            uint64_t result = (unint64_t)sub_1CC491694(&v9[(unint64_t)v12 >> 1], v9, a2 - 1);
          }
          --a3;
          unint64_t v16 = *v9;
          int v17 = **v9;
          if ((a4 & 1) != 0 || **(v9 - 1) < v17) {
            break;
          }
          if (v17 >= **(a2 - 1))
          {
            uint64_t v31 = v9 + 1;
            do
            {
              uint64_t v10 = v31;
              if (v31 >= a2) {
                break;
              }
              ++v31;
            }
            while (v17 >= **v10);
          }
          else
          {
            uint64_t v10 = v9;
            do
            {
              uint64_t v30 = v10[1];
              ++v10;
            }
            while (v17 >= *v30);
          }
          uint64_t v32 = a2;
          if (v10 < a2)
          {
            uint64_t v32 = a2;
            do
              uint64_t v33 = *--v32;
            while (v17 < *v33);
          }
          if (v10 < v32)
          {
            uint64_t v34 = *v10;
            float v35 = *v32;
            do
            {
              *uint64_t v10 = v35;
              *uint64_t v32 = v34;
              do
              {
                uint64_t v36 = v10[1];
                ++v10;
                uint64_t v34 = v36;
              }
              while (v17 >= *v36);
              do
              {
                int v37 = *--v32;
                float v35 = v37;
              }
              while (v17 < *v37);
            }
            while (v10 < v32);
          }
          float v38 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *int v9 = *v38;
          }
          a4 = 0;
          *float v38 = v16;
        }
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (*v19 < v17);
        uint64_t v20 = &v9[v18];
        uint64_t v21 = a2;
        if (v18 == 1)
        {
          uint64_t v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            int v23 = *--v21;
          }
          while (*v23 >= v17);
        }
        else
        {
          do
            uint64_t v22 = *--v21;
          while (*v22 >= v17);
        }
        if (v20 >= v21)
        {
          uint64_t v10 = &v9[v18];
        }
        else
        {
          uint64_t v24 = *v21;
          uint64_t v10 = &v9[v18];
          uint64_t v25 = v21;
          do
          {
            *uint64_t v10 = v24;
            *uint64_t v25 = v19;
            do
            {
              uint64_t v26 = v10[1];
              ++v10;
              uint64_t v19 = v26;
            }
            while (*v26 < v17);
            do
            {
              int v27 = *--v25;
              uint64_t v24 = v27;
            }
            while (*v27 >= v17);
          }
          while (v10 < v25);
        }
        uint64_t v28 = v10 - 1;
        if (v10 - 1 != v9) {
          *int v9 = *v28;
        }
        *uint64_t v28 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_33:
        uint64_t result = sub_1CC490F60(v9, v10 - 1, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v29 = sub_1CC49171C(v9, v10 - 1);
      uint64_t result = sub_1CC49171C(v10, a2);
      if (result) {
        break;
      }
      if (!v29) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 1;
    if (!v29) {
      continue;
    }
    return result;
  }
}

int **sub_1CC491694(int **result, int **a2, int **a3)
{
  uint64_t v3 = *a2;
  BOOL v4 = *result;
  int v5 = **a2;
  int v6 = **result;
  uint64_t v7 = *a3;
  int v8 = **a3;
  if (v5 >= v6)
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v3;
      int v9 = *result;
      if (**a2 < **result)
      {
        *uint64_t result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *uint64_t result = v3;
      *a2 = v4;
      if (**a3 >= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v7;
    }
    *a3 = v4;
  }
  return result;
}

BOOL sub_1CC49171C(int **a1, int **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*v6 < **a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1CC491694(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CC491928(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      uint64_t v19 = a1 + 2;
      uint64_t v20 = a1 + 3;
      sub_1CC491928(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (*v21 < *v22)
      {
        *uint64_t v20 = v21;
        *(a2 - 1) = v22;
        int v23 = *v20;
        uint64_t v24 = *v19;
        int v25 = **v20;
        if (v25 < **v19)
        {
          *uint64_t v19 = v23;
          *uint64_t v20 = v24;
          uint64_t v26 = *v18;
          if (v25 < **v18)
          {
            a1[1] = v23;
            a1[2] = v26;
            int v27 = *a1;
            if (v25 < **a1)
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      int v8 = a1 + 2;
      sub_1CC491694(a1, a1 + 1, a1 + 2);
      int v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    unint64_t v13 = *v8;
    int v14 = **v9;
    if (v14 < **v8)
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(int **)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        unint64_t v13 = *(int **)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *v13)
        {
          int v17 = (int **)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      int v17 = a1;
LABEL_13:
      *int v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    int v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

int **sub_1CC491928(int **a1, int **a2, int **a3, int **a4)
{
  BOOL result = sub_1CC491694(a1, a2, a3);
  int v9 = *a3;
  if (**a4 < **a3)
  {
    *a3 = *a4;
    *a4 = v9;
    int v10 = *a2;
    if (**a3 < **a2)
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (**a2 < **a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

char *sub_1CC4919C0(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    int v6 = result;
    if (a3 == 2)
    {
      uint64_t v7 = *((void *)a2 - 1);
      uint64_t v8 = *(void *)result;
      if (*(float *)(v7 + 116) > *(float *)(*(void *)result + 116))
      {
        *(void *)BOOL result = v7;
        *((void *)a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v19 = (char *)a4;
      unint64_t v20 = a3 >> 1;
      uint64_t v21 = &result[8 * (a3 >> 1)];
      unint64_t v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CC491C0C((uint64_t)result, v21, v22, a4);
        int v23 = (uint64_t *)&v19[8 * v20];
        BOOL result = (char *)sub_1CC491C0C((uint64_t)&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        uint64_t v24 = &v19[8 * a3];
        int v25 = v23;
        while (v25 != (uint64_t *)v24)
        {
          uint64_t v26 = v25;
          uint64_t v27 = *v25;
          uint64_t v28 = *(void *)v19;
          float v29 = *(float *)(v27 + 116);
          float v30 = *(float *)(*(void *)v19 + 116);
          if (v29 > v30) {
            uint64_t v28 = v27;
          }
          v19 += 8 * (v29 <= v30);
          int v25 = &v26[v29 > v30];
          *(void *)int v6 = v28;
          v6 += 8;
          if (v19 == (char *)v23)
          {
            if (v25 != (uint64_t *)v24)
            {
              uint64_t v31 = 0;
              if (v29 > v30) {
                char v32 = 1;
              }
              else {
                char v32 = 2;
              }
              uint64_t v33 = &v26[v32 & 1];
              do
              {
                *(void *)&v6[v31 * 8] = v33[v31];
                ++v31;
              }
              while (&v33[v31] != (uint64_t *)v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          uint64_t v34 = 0;
          do
          {
            *(void *)&v6[v34] = *(void *)&v19[v34];
            v34 += 8;
          }
          while (&v19[v34] != (char *)v23);
        }
      }
      else
      {
        sub_1CC4919C0(result, v21, v22, a4, a5);
        sub_1CC4919C0(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);
        return sub_1CC491E0C(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (result != a2)
    {
      int v10 = result + 8;
      if (result + 8 != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = result;
        do
        {
          uint64_t v13 = *(void *)v12;
          uint64_t v12 = v10;
          uint64_t v14 = *(void *)v10;
          float v15 = *(float *)(v14 + 116);
          if (v15 > *(float *)(v13 + 116))
          {
            uint64_t v16 = v11;
            while (1)
            {
              *(void *)&result[v16 + 8] = v13;
              if (!v16) {
                break;
              }
              uint64_t v13 = *(void *)&result[v16 - 8];
              v16 -= 8;
              if (v15 <= *(float *)(v13 + 116))
              {
                int v17 = &result[v16 + 8];
                goto LABEL_15;
              }
            }
            int v17 = result;
LABEL_15:
            *(void *)int v17 = v14;
          }
          int v10 = v12 + 8;
          v11 += 8;
        }
        while (v12 + 8 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CC491C0C(uint64_t result, void *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    uint64_t v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      *uint64_t v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = *(a2 - 1);
      float v9 = *(float *)(v8 + 116);
      float v10 = *(float *)(*(void *)result + 116);
      if (v9 <= v10) {
        uint64_t v8 = *(void *)result;
      }
      *a4 = v8;
      uint64_t v4 = a4 + 1;
      if (v9 <= v10) {
        uint64_t v6 = (uint64_t)(a2 - 1);
      }
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = result + 8 * (a3 >> 1);
      sub_1CC4919C0(result, v20, a3 >> 1, a4, a3 >> 1);
      BOOL result = sub_1CC4919C0(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      uint64_t v21 = (void *)(v6 + 8 * (a3 >> 1));
      while (v21 != a2)
      {
        unint64_t v22 = v21;
        uint64_t v23 = *v21;
        uint64_t v24 = *(void *)v6;
        float v25 = *(float *)(v23 + 116);
        float v26 = *(float *)(*(void *)v6 + 116);
        if (v25 > v26) {
          uint64_t v24 = v23;
        }
        uint64_t v21 = &v22[v25 > v26];
        v6 += 8 * (v25 <= v26);
        *v4++ = v24;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v27 = 0;
            uint64_t v28 = &v22[v25 > v26];
            do
            {
              v4[v27] = v28[v27];
              ++v27;
            }
            while (&v28[v27] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v29 = 0;
        do
        {
          v4[v29] = *(void *)(v6 + v29 * 8);
          ++v29;
        }
        while (v6 + v29 * 8 != v20);
      }
    }
    else if ((void *)result != a2)
    {
      uint64_t v11 = result + 8;
      *a4 = *(void *)result;
      if ((void *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = a4;
        uint64_t v14 = a4;
        do
        {
          uint64_t v16 = *v14++;
          uint64_t v15 = v16;
          if (*(float *)(*(void *)v11 + 116) <= *(float *)(v16 + 116))
          {
            *uint64_t v14 = *(void *)v11;
          }
          else
          {
            v13[1] = v15;
            int v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                int v17 = (uint64_t *)((char *)a4 + v18);
                uint64_t v19 = *(uint64_t *)((char *)a4 + v18 - 8);
                if (*(float *)(*(void *)v11 + 116) <= *(float *)(v19 + 116)) {
                  break;
                }
                *int v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  int v17 = a4;
                  break;
                }
              }
            }
            *int v17 = *(void *)v11;
          }
          v11 += 8;
          v12 += 8;
          uint64_t v13 = v14;
        }
        while ((void *)v11 != a2);
      }
    }
  }
  return result;
}

char *sub_1CC491E0C(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v7 = a5;
    float v10 = result;
    while (a4 > a7 && v7 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v11 = 0;
      uint64_t v12 = -a4;
      while (1)
      {
        uint64_t v13 = *(void *)&v10[v11];
        if (*(float *)(*(void *)a2 + 116) > *(float *)(v13 + 116)) {
          break;
        }
        v11 += 8;
        if (__CFADD__(v12++, 1)) {
          return result;
        }
      }
      uint64_t v15 = &v10[v11];
      if (-v12 >= v7)
      {
        if (v12 == -1)
        {
          *(void *)&v10[v11] = *(void *)a2;
          *(void *)a2 = v13;
          return result;
        }
        if (v12 <= 0) {
          uint64_t v25 = -v12;
        }
        else {
          uint64_t v25 = 1 - v12;
        }
        uint64_t v26 = v25 >> 1;
        unint64_t v20 = &v10[8 * (v25 >> 1) + v11];
        uint64_t v18 = a3;
        if (a3 != a2)
        {
          unint64_t v27 = (a3 - a2) >> 3;
          uint64_t v18 = a2;
          do
          {
            unint64_t v28 = v27 >> 1;
            uint64_t v29 = &v18[8 * (v27 >> 1)];
            uint64_t v31 = *(void *)v29;
            float v30 = v29 + 8;
            v27 += ~(v27 >> 1);
            if (*(float *)(v31 + 116) > *(float *)(*(void *)v20 + 116)) {
              uint64_t v18 = v30;
            }
            else {
              unint64_t v27 = v28;
            }
          }
          while (v27);
        }
        uint64_t v17 = (v18 - a2) >> 3;
      }
      else
      {
        if (v7 >= 0) {
          uint64_t v16 = v7;
        }
        else {
          uint64_t v16 = v7 + 1;
        }
        uint64_t v17 = v16 >> 1;
        uint64_t v18 = &a2[8 * (v16 >> 1)];
        if (v15 == a2)
        {
          unint64_t v20 = a2;
        }
        else
        {
          unint64_t v19 = (a2 - v10 - v11) >> 3;
          unint64_t v20 = &v10[v11];
          do
          {
            unint64_t v21 = v19 >> 1;
            unint64_t v22 = &v20[8 * (v19 >> 1)];
            uint64_t v24 = *(void *)v22;
            uint64_t v23 = v22 + 8;
            v19 += ~(v19 >> 1);
            if (*(float *)(*(void *)v18 + 116) > *(float *)(v24 + 116)) {
              unint64_t v19 = v21;
            }
            else {
              unint64_t v20 = v23;
            }
          }
          while (v19);
        }
        uint64_t v26 = (v20 - v10 - v11) >> 3;
      }
      char v32 = v18;
      if (v20 != a2)
      {
        char v32 = v20;
        if (a2 != v18)
        {
          if (v20 + 8 == a2)
          {
            uint64_t v80 = *(void *)v20;
            uint64_t v82 = v17;
            int64_t v38 = v18 - a2;
            uint64_t v84 = a6;
            uint64_t v86 = a7;
            uint64_t v39 = a3;
            uint64_t v40 = v26;
            memmove(v20, a2, v18 - a2);
            uint64_t v26 = v40;
            uint64_t v17 = v82;
            a6 = v84;
            uint64_t v15 = &v10[v11];
            a7 = v86;
            a3 = v39;
            char v32 = &v20[v38];
            *(void *)char v32 = v80;
          }
          else if (a2 + 8 == v18)
          {
            uint64_t v41 = *((void *)v18 - 1);
            char v32 = v20 + 8;
            if (v18 - 8 != v20)
            {
              unint64_t v85 = a6;
              uint64_t v87 = a7;
              uint64_t v42 = a3;
              uint64_t v81 = *((void *)v18 - 1);
              uint64_t v83 = v17;
              uint64_t v43 = v26;
              memmove(v20 + 8, v20, v18 - 8 - v20);
              uint64_t v41 = v81;
              uint64_t v17 = v83;
              uint64_t v26 = v43;
              uint64_t v15 = &v10[v11];
              a6 = v85;
              a7 = v87;
              a3 = v42;
            }
            *(void *)unint64_t v20 = v41;
          }
          else
          {
            uint64_t v33 = (a2 - v20) >> 3;
            if (v33 == (v18 - a2) >> 3)
            {
              BOOL v34 = a2 == v18 || v20 == a2;
              if (!v34)
              {
                float v35 = v20 + 8;
                uint64_t v36 = a2 + 8;
                do
                {
                  uint64_t v37 = *((void *)v35 - 1);
                  *((void *)v35 - 1) = *((void *)v36 - 1);
                  *((void *)v36 - 1) = v37;
                  if (v35 == a2) {
                    break;
                  }
                  v35 += 8;
                  BOOL v34 = v36 == v18;
                  v36 += 8;
                }
                while (!v34);
              }
              char v32 = a2;
            }
            else
            {
              uint64_t v44 = (v18 - a2) >> 3;
              uint64_t v45 = (a2 - v20) >> 3;
              do
              {
                uint64_t v46 = v45;
                uint64_t v45 = v44;
                uint64_t v44 = v46 % v44;
              }
              while (v44);
              if (v45)
              {
                int v47 = &v20[8 * v45];
                do
                {
                  uint64_t v49 = *((void *)v47 - 1);
                  v47 -= 8;
                  uint64_t v48 = v49;
                  unint64_t v50 = &v47[8 * v33];
                  uint64_t v51 = v47;
                  do
                  {
                    int v52 = v50;
                    *(void *)uint64_t v51 = *(void *)v50;
                    BOOL v53 = &v50[8 * v33];
                    BOOL v54 = __OFSUB__(v33, (v18 - v50) >> 3);
                    uint64_t v56 = v33 - ((v18 - v50) >> 3);
                    char v55 = (v56 < 0) ^ v54;
                    unint64_t v50 = &v20[8 * v56];
                    if (v55) {
                      unint64_t v50 = v53;
                    }
                    uint64_t v51 = v52;
                  }
                  while (v50 != v47);
                  *(void *)int v52 = v48;
                }
                while (v47 != v20);
              }
              char v32 = &v20[8 * ((v18 - a2) >> 3)];
            }
          }
        }
      }
      a4 = -(v26 + v12);
      uint64_t v57 = v7 - v17;
      if (v26 + v17 >= v7 - (v26 + v17) - v12)
      {
        uint64_t v63 = v26;
        uint64_t v64 = -(v26 + v12);
        uint64_t v65 = v17;
        uint64_t v66 = v7 - v17;
        uint64_t v67 = a6;
        uint64_t v68 = a7;
        int v69 = v15;
        BOOL result = (char *)sub_1CC491E0C(v32, v18, a3, v64, v66);
        int64_t v62 = v69;
        a7 = v68;
        a6 = v67;
        uint64_t v18 = v20;
        uint64_t v57 = v65;
        a4 = v63;
        a3 = v32;
      }
      else
      {
        int v58 = &v10[v11];
        uint64_t v59 = a6;
        uint64_t v60 = a7;
        unint64_t v61 = a3;
        BOOL result = (char *)sub_1CC491E0C(v58, v20, v32, v26, v17);
        a7 = v60;
        a3 = v61;
        a6 = v59;
        int64_t v62 = v32;
      }
      uint64_t v7 = v57;
      float v10 = v62;
      a2 = v18;
      if (!v57) {
        return result;
      }
    }
    if (a4 <= v7)
    {
      if (v10 != a2)
      {
        unint64_t v74 = 0;
        do
        {
          *(void *)&a6[v74] = *(void *)&v10[v74];
          v74 += 8;
        }
        while (&v10[v74] != a2);
        if (v74)
        {
          uint64_t v75 = a6;
          while (a2 != a3)
          {
            uint64_t v76 = *(void *)a2;
            float v77 = *(float *)(*(void *)a2 + 116);
            float v78 = *(float *)(*(void *)v75 + 116);
            if (v77 <= v78) {
              uint64_t v76 = *(void *)v75;
            }
            a2 += 8 * (v77 > v78);
            v75 += 8 * (v77 <= v78);
            *(void *)float v10 = v76;
            v10 += 8;
            if (&a6[v74] == v75) {
              return result;
            }
          }
          return (char *)memmove(v10, v75, a6 - v75 + v74);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v70 = 0;
      do
      {
        *(void *)&a6[v70] = *(void *)&a2[v70];
        v70 += 8;
      }
      while (&a2[v70] != a3);
      if (v70)
      {
        int v71 = &a6[v70];
        int v72 = a3 - 8;
        while (a2 != v10)
        {
          uint64_t v73 = *((void *)v71 - 1);
          if (*(float *)(v73 + 116) <= *(float *)(*((void *)a2 - 1) + 116))
          {
            v71 -= 8;
          }
          else
          {
            uint64_t v73 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)int v72 = v73;
          v72 -= 8;
          if (v71 == a6) {
            return result;
          }
        }
        if (v71 != a6)
        {
          uint64_t v79 = 0;
          do
          {
            *(void *)&v72[v79] = *(void *)&v71[v79 - 8];
            v79 -= 8;
          }
          while (&v71[v79] != a6);
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CC492344()
{
  char v2 = 0;
  uint64_t v3 = &v2;
  int v4 = 1;
  v1.n128_u64[0] = (unint64_t)"Suppress slot sharing during stack coloring";
  v1.n128_u64[1] = 43;
  sub_1CBA9E5B0((llvm::cl::Option *)&unk_1EBCD4008, "no-stack-slot-sharing", &v3, &v4, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD4008, &dword_1CB82C000);
  LODWORD(v3) = -1;
  v1.n128_u64[0] = (unint64_t)&v3;
  int v4 = 1;
  sub_1CD5161BC((uint64_t)&unk_1EBCD40C8, "ssc-dce-limit", &v1, &v4);
  return __cxa_atexit((void (*)(void *))sub_1CBB1C45C, &unk_1EBCD40C8, &dword_1CB82C000);
}

void llvm::SwiftErrorValueTracking::setFunction(llvm::SwiftErrorValueTracking *this, llvm::MachineFunction *a2)
{
  uint64_t v3 = *(void **)a2;
  *(void *)this = a2;
  *((void *)this + 1) = v3;
  *((void *)this + 2) = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 120))(*((void *)a2 + 2));
  *((void *)this + 3) = (*(uint64_t (**)(void))(**(void **)(*(void *)this + 16) + 104))(*(void *)(*(void *)this + 16));
  if ((*(unsigned int (**)(void))(**((void **)this + 2) + 1768))())
  {
    *((_DWORD *)this + 30) = 0;
    sub_1CD553F7C((_DWORD *)this + 8);
    sub_1CD553F7C((_DWORD *)this + 14);
    sub_1CD57E814((_DWORD *)this + 20);
    *((void *)this + 13) = 0;
    uint64_t v4 = *((void *)this + 1);
    if (*(_WORD *)(v4 + 18))
    {
      llvm::Function::BuildLazyArguments(*((llvm::Function **)this + 1));
      uint64_t v6 = *((void *)this + 1);
      uint64_t v5 = *(void *)(v4 + 88);
      if (*(_WORD *)(v6 + 18)) {
        llvm::Function::BuildLazyArguments(*((llvm::Function **)this + 1));
      }
      uint64_t v4 = v6;
    }
    else
    {
      uint64_t v5 = *(void *)(v4 + 88);
    }
    uint64_t v7 = *(void *)(v4 + 88) + 40 * *(void *)(v4 + 96);
    if (v5 != v7)
    {
      uint64_t v8 = v5;
      do
      {
        uint64_t v9 = *(void *)(*(void *)(v5 + 24) + 112);
        if (v9)
        {
          unsigned int v10 = *(_DWORD *)(v5 + 32) + 2;
          if (v10 < *(_DWORD *)(v9 + 8))
          {
            uint64_t v11 = *(void *)(v9 + 8 * v10 + 40);
            if (v11)
            {
              if (*(char *)(v11 + 19) < 0)
              {
                *((void *)this + 13) = v5;
                unint64_t v12 = *((unsigned int *)this + 30);
                if (v12 >= *((unsigned int *)this + 31)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *(void *)(*((void *)this + 14) + 8 * v12) = v8;
                ++*((_DWORD *)this + 30);
              }
            }
          }
        }
        v5 += 40;
        v8 += 40;
      }
      while (v5 != v7);
    }
    uint64_t v13 = *((void *)this + 1);
    uint64_t v14 = v13 + 72;
    uint64_t v15 = *(void *)(v13 + 80);
    if (v15 != v13 + 72)
    {
      do
      {
        uint64_t v16 = v15 - 24;
        if (!v15) {
          uint64_t v16 = 0;
        }
        uint64_t v17 = v16 + 40;
        for (uint64_t i = *(void *)(v16 + 48); i != v17; uint64_t i = *(void *)(i + 8))
        {
          uint64_t v19 = i - 24;
          if (!i) {
            uint64_t v19 = 0;
          }
          int v20 = *(unsigned __int8 *)(v19 + 16);
          if (v20 == 59) {
            uint64_t v21 = v19;
          }
          else {
            uint64_t v21 = 0;
          }
          if (i && v20 == 59 && (*(_WORD *)(v21 + 18) & 0x80) != 0)
          {
            unint64_t v22 = *((unsigned int *)this + 30);
            if (v22 >= *((unsigned int *)this + 31)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*((void *)this + 14) + 8 * v22) = v21;
            ++*((_DWORD *)this + 30);
          }
        }
        uint64_t v15 = *(void *)(v15 + 8);
      }
      while (v15 != v14);
    }
  }
}

uint64_t llvm::SwiftErrorValueTracking::createEntriesInEntryBlock(uint64_t a1, unsigned __int8 **a2)
{
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 16) + 1768))(*(void *)(a1 + 16))) {
    goto LABEL_2;
  }
  int v4 = *(_DWORD *)(a1 + 120);
  if (!v4) {
    return v4 & 1;
  }
  uint64_t v6 = *(llvm::MachineBasicBlock **)(*(void *)a1 + 328);
  uint64_t DataLayout = llvm::MachineFunction::getDataLayout(*(llvm::MachineFunction **)a1);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (*(unsigned __int8 (**)(uint64_t, uint64_t, void))(*(void *)v8 + 32))(v8, DataLayout, 0);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v8 + 424))(v8, v9, 0);
  uint64_t v11 = *(unsigned int *)(a1 + 120);
  if (v11)
  {
    uint64_t v12 = v10;
    LOBYTE(v4) = 0;
    uint64_t v13 = *(uint64_t **)(a1 + 112);
    uint64_t v14 = 8 * v11;
    do
    {
      uint64_t v15 = *v13;
      uint64_t v16 = *(void *)(a1 + 104);
      if (v16) {
        BOOL v17 = v16 == v15;
      }
      else {
        BOOL v17 = 0;
      }
      if (!v17)
      {
        int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*(void *)(*(void *)a1 + 40), v12, "", 0);
        FirstNonPHI = (unint64_t *)llvm::MachineBasicBlock::getFirstNonPHI(v6);
        sub_1CB85AA4C((uint64_t)v6, FirstNonPHI, a2, *(void *)(*(void *)(a1 + 24) + 8) + 480, VirtualRegister);
        v20[0] = (uint64_t)v6;
        v20[1] = v15;
        *((_DWORD *)sub_1CD57EB4C(a1 + 32, v20) + 4) = VirtualRegister;
        LOBYTE(v4) = 1;
      }
      ++v13;
      v14 -= 8;
    }
    while (v14);
  }
  else
  {
LABEL_2:
    LOBYTE(v4) = 0;
  }
  return v4 & 1;
}

void llvm::SwiftErrorValueTracking::propagateVRegs(llvm::SwiftErrorValueTracking *this)
{
  v61[8] = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(void))(**((void **)this + 2) + 1768))(*((void *)this + 2))
    && *((_DWORD *)this + 30))
  {
    int v52 = 0;
    BOOL v53 = 0;
    uint64_t v54 = 0;
    sub_1CB93939C(&v52, (uint64_t)this);
    long long __p = v53;
    uint64_t v41 = v52;
    if (v53 != v52)
    {
      uint64_t v40 = (char *)this + 32;
      while (1)
      {
        char v2 = (llvm::MachineBasicBlock *)*((void *)__p - 1);
        __p -= 8;
        uint64_t v3 = *((unsigned int *)this + 30);
        if (v3) {
          break;
        }
LABEL_54:
        if (__p == v41)
        {
          long long __p = v52;
          goto LABEL_61;
        }
      }
      int v4 = (uint64_t *)*((void *)this + 14);
      uint64_t v42 = &v4[v3];
      while (1)
      {
        uint64_t v5 = *v4;
        int v47 = 0;
        uint64_t v6 = (sub_1CD553C1C(*((void *)this + 7), *((_DWORD *)this + 18), (uint64_t)v2, v5, &v47) & 1) != 0
           ? v47
           : (unsigned char *)(*((void *)this + 7) + 24 * *((unsigned int *)this + 18));
        int v47 = 0;
        uint64_t v7 = (sub_1CD553C1C(*((void *)this + 4), *((_DWORD *)this + 12), (uint64_t)v2, v5, &v47) & 1) != 0
           ? v47
           : (unsigned char *)(*((void *)this + 4) + 24 * *((unsigned int *)this + 12));
        uint64_t v8 = *((void *)this + 7) + 24 * *((unsigned int *)this + 18);
        BOOL v45 = v6 != (unsigned char *)v8;
        if (v6 != (unsigned char *)v8) {
          break;
        }
        if (v7 == (unsigned char *)(*((void *)this + 4) + 24 * *((unsigned int *)this + 12)))
        {
          int VirtualRegister = 0;
LABEL_16:
          uint64_t v59 = (char *)v61;
          uint64_t v60 = 0x400000000;
          int v47 = v51;
          uint64_t v48 = v51;
          uint64_t v49 = 8;
          int v50 = 0;
          uint64_t v10 = (uint64_t *)*((void *)v2 + 8);
          uint64_t v9 = (uint64_t *)*((void *)v2 + 9);
          if (v10 == v9) {
            goto LABEL_29;
          }
          do
          {
            uint64_t v11 = (const llvm::MachineBasicBlock *)*v10;
            sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v47, *v10);
            if (v12)
            {
              unsigned int VReg = llvm::SwiftErrorValueTracking::getOrCreateVReg(this, v11, (const llvm::Value *)v5);
              if (v60 >= (unint64_t)HIDWORD(v60)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v14 = (const llvm::MachineBasicBlock **)&v59[16 * v60];
              *uint64_t v14 = v11;
              v14[1] = (const llvm::MachineBasicBlock *)VReg;
              LODWORD(v60) = v60 + 1;
              if (v11 == v2 && !v45)
              {
                char v55 = 0;
                char v37 = sub_1CD553C1C(*((void *)this + 7), *((_DWORD *)this + 18), (uint64_t)v2, v5, &v55);
                if (v37) {
                  uint64_t v38 = (uint64_t)v55;
                }
                else {
                  uint64_t v38 = *((void *)this + 7) + 24 * *((unsigned int *)this + 18);
                }
                int VirtualRegister = *(_DWORD *)(v38 + 16);
                BOOL v45 = 1;
              }
            }
            ++v10;
          }
          while (v10 != v9);
          if (!v60)
          {
LABEL_29:
            BOOL v17 = 0;
          }
          else
          {
            uint64_t v15 = v59;
            uint64_t v16 = 16 * v60;
            while (*((_DWORD *)v15 + 2) == *((_DWORD *)v59 + 2))
            {
              v15 += 16;
              v16 -= 16;
              if (!v16)
              {
                uint64_t v15 = &v59[16 * v60];
                break;
              }
            }
            BOOL v17 = v15 != &v59[16 * v60];
          }
          if (v45 || v17)
          {
            if (*(unsigned __int8 *)(v5 + 16) < 0x1Cu)
            {
              uint64_t v46 = 0;
            }
            else
            {
              uint64_t v18 = *(unsigned __int8 **)(v5 + 48);
              uint64_t v46 = v18;
              if (v18) {
                llvm::MetadataTracking::track((uint64_t)&v46, v18, 2);
              }
            }
            uint64_t v19 = (*(uint64_t (**)(void))(**(void **)(*(void *)this + 16) + 104))(*(void *)(*(void *)this + 16));
            if (v17)
            {
              uint64_t DataLayout = llvm::MachineFunction::getDataLayout(*(llvm::MachineFunction **)this);
              uint64_t v21 = *((void *)this + 2);
              uint64_t v22 = (*(unsigned __int8 (**)(uint64_t, uint64_t, void))(*(void *)v21 + 32))(v21, DataLayout, 0);
              uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v21 + 424))(v21, v22, 0);
              if (!v45) {
                int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*(void *)(*(void *)this + 40), v23, "", 0);
              }
              FirstNonPHI = (unint64_t *)llvm::MachineBasicBlock::getFirstNonPHI(v2);
              uint64_t v25 = sub_1CB85AA4C((uint64_t)v2, FirstNonPHI, &v46, *(void *)(v19 + 8), VirtualRegister);
              if (v60)
              {
                unint64_t v27 = v25;
                unint64_t v28 = v26;
                uint64_t v29 = v59;
                float v30 = &v59[16 * v60];
                do
                {
                  uint64_t v31 = *(void *)v29;
                  int v32 = *((_DWORD *)v29 + 2);
                  uint64_t v56 = 0;
                  LODWORD(v55) = 0;
                  HIDWORD(v55) = v32;
                  uint64_t v57 = 0;
                  uint64_t v58 = 0;
                  llvm::MachineInstr::addOperand(v28, v27, (const llvm::MachineOperand *)&v55);
                  uint64_t v56 = 0;
                  uint64_t v57 = v31;
                  LODWORD(v55) = 4;
                  llvm::MachineInstr::addOperand(v28, v27, (const llvm::MachineOperand *)&v55);
                  v29 += 16;
                }
                while (v29 != v30);
              }
              if (!v45)
              {
                char v55 = v2;
                uint64_t v56 = v5;
                *((_DWORD *)sub_1CD57EB4C((uint64_t)v40, (uint64_t *)&v55) + 4) = VirtualRegister;
              }
            }
            else
            {
              uint64_t v33 = (unint64_t *)llvm::MachineBasicBlock::getFirstNonPHI(v2);
              BOOL v34 = sub_1CB85AA4C((uint64_t)v2, v33, &v46, *(void *)(v19 + 8) + 912, VirtualRegister);
              int v35 = *((_DWORD *)v59 + 2);
              uint64_t v56 = 0;
              LODWORD(v55) = 0;
              HIDWORD(v55) = v35;
              uint64_t v57 = 0;
              uint64_t v58 = 0;
              llvm::MachineInstr::addOperand(v36, v34, (const llvm::MachineOperand *)&v55);
            }
            if (v46) {
              llvm::MetadataTracking::untrack((uint64_t)&v46, v46);
            }
          }
          else
          {
            int v39 = *((_DWORD *)v59 + 2);
            char v55 = v2;
            uint64_t v56 = v5;
            *((_DWORD *)sub_1CD57EB4C((uint64_t)v40, (uint64_t *)&v55) + 4) = v39;
          }
          if (v48 != v47) {
            free(v48);
          }
          if (v59 != (char *)v61) {
            free(v59);
          }
        }
        if (++v4 == v42) {
          goto LABEL_54;
        }
      }
      int VirtualRegister = *((_DWORD *)v6 + 4);
      goto LABEL_16;
    }
LABEL_61:
    if (__p)
    {
      BOOL v53 = __p;
      operator delete(__p);
    }
  }
}

uint64_t llvm::SwiftErrorValueTracking::preassignVRegs(uint64_t a1, const llvm::MachineBasicBlock *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 1768))(*(void *)(a1 + 16));
  if (result)
  {
    if (*(_DWORD *)(a1 + 120) && a3 != a4)
    {
      while (1)
      {
        uint64_t v10 = a3 - 24;
        unint64_t v11 = a3 ? a3 - 24 : 0;
        int v12 = *(unsigned __int8 *)(v11 + 16);
        if ((v12 - 33) <= 0x33 && ((1 << (v12 - 33)) & 0x8000000000041) != 0) {
          break;
        }
        if (v12 == 60) {
          unint64_t v28 = v11;
        }
        else {
          unint64_t v28 = 0;
        }
        if (a3 && v12 == 60)
        {
          uint64_t v29 = *(void *)(v28 - 32);
          int v30 = *(unsigned __int8 *)(v29 + 16);
          if (v29) {
            BOOL v31 = v30 == 21;
          }
          else {
            BOOL v31 = 0;
          }
          if (v31)
          {
            uint64_t v34 = *(void *)(*(void *)(v29 + 24) + 112);
            if (!v34) {
              goto LABEL_37;
            }
            unsigned int v35 = *(_DWORD *)(v29 + 32) + 2;
            if (v35 >= *(_DWORD *)(v34 + 8)) {
              goto LABEL_37;
            }
            uint64_t v36 = *(void *)(v34 + 8 * v35 + 40);
            if (!v36 || (*(char *)(v36 + 19) & 0x80000000) == 0) {
              goto LABEL_37;
            }
          }
          else if (!v29 || v30 != 59 || (*(_WORD *)(v29 + 18) & 0x80) == 0)
          {
            goto LABEL_37;
          }
          goto LABEL_68;
        }
        if (!a3 || v12 != 61)
        {
          if (v12 == 29) {
            unint64_t v28 = v11;
          }
          else {
            unint64_t v28 = 0;
          }
          if (!a3) {
            goto LABEL_37;
          }
          if (v12 != 29) {
            goto LABEL_37;
          }
          uint64_t v33 = *(void *)(*(void *)(*(void *)(v28 + 40) + 56) + 112);
          if (!v33 || (*(char *)(v33 + 31) & 0x80000000) == 0) {
            goto LABEL_37;
          }
          uint64_t v29 = *(void *)(a1 + 104);
LABEL_68:
          uint64_t result = llvm::SwiftErrorValueTracking::getOrCreateVRegUseAt((llvm::SwiftErrorValueTracking *)a1, v28, a2, (const llvm::Value *)v29);
          goto LABEL_37;
        }
        int v20 = *(const llvm::Value **)(v11 - 32);
        int v32 = *((unsigned __int8 *)v20 + 16);
        if (v20 && v32 == 21)
        {
          uint64_t v37 = *(void *)(*((void *)v20 + 3) + 112);
          if (v37)
          {
            unsigned int v38 = *((_DWORD *)v20 + 8) + 2;
            if (v38 < *(_DWORD *)(v37 + 8))
            {
              uint64_t v39 = *(void *)(v37 + 8 * v38 + 40);
              if (v39)
              {
                if (*(char *)(v39 + 19) < 0) {
                  goto LABEL_59;
                }
              }
            }
          }
        }
        else if (v20 && v32 == 59 && (*((_WORD *)v20 + 9) & 0x80) != 0)
        {
          goto LABEL_59;
        }
LABEL_37:
        a3 = *(void *)(a3 + 8);
        if (a3 == a4) {
          return result;
        }
      }
      int v14 = *(unsigned __int8 *)(a3 - 8);
      if (v14 == 84)
      {
        uint64_t v15 = 0;
      }
      else if (v14 == 39)
      {
        uint64_t v15 = (*(_DWORD *)(a3 + 56) + 1);
      }
      else
      {
        uint64_t v15 = 2;
      }
      int v16 = *(_DWORD *)(a3 - 4);
      uint64_t v17 = v16 & 0x7FFFFFF;
      uint64_t v18 = (const llvm::Value **)(v10 - 32 * v17);
      if (v16 < 0 && (uint64_t v40 = (uint64_t)*(v18 - 1), (v40 & 0xFFFFFFFF0) != 0)) {
        uint64_t v19 = (*((_DWORD *)v18 - 3) - *(_DWORD *)((char *)v18 - v40));
      }
      else {
        uint64_t v19 = 0;
      }
      if (v18 == (const llvm::Value **)(v10 - 32 * v15 - 32 * v19 - 32)) {
        goto LABEL_37;
      }
      int v20 = 0;
      uint64_t v21 = 32 * v17 - 32 * v15 - 32 * v19 - 32;
      while (1)
      {
        uint64_t v22 = *v18;
        int v23 = *((unsigned __int8 *)*v18 + 16);
        if (*v18) {
          BOOL v24 = v23 == 21;
        }
        else {
          BOOL v24 = 0;
        }
        if (v24)
        {
          uint64_t v25 = *(void *)(*((void *)v22 + 3) + 112);
          if (!v25) {
            goto LABEL_27;
          }
          unsigned int v26 = *((_DWORD *)v22 + 8) + 2;
          if (v26 >= *(_DWORD *)(v25 + 8)) {
            goto LABEL_27;
          }
          uint64_t v27 = *(void *)(v25 + 8 * v26 + 40);
          if (!v27 || (*(char *)(v27 + 19) & 0x80000000) == 0) {
            goto LABEL_27;
          }
        }
        else if (!v22 || v23 != 59 || (*((_WORD *)v22 + 9) & 0x80) == 0)
        {
          goto LABEL_27;
        }
        uint64_t result = llvm::SwiftErrorValueTracking::getOrCreateVRegUseAt((llvm::SwiftErrorValueTracking *)a1, v11, a2, *v18);
        int v20 = v22;
LABEL_27:
        v18 += 4;
        v21 -= 32;
        if (!v21)
        {
          if (!v20) {
            goto LABEL_37;
          }
LABEL_59:
          uint64_t result = llvm::SwiftErrorValueTracking::getOrCreateVRegDefAt((llvm::SwiftErrorValueTracking *)a1, v11, a2, v20);
          goto LABEL_37;
        }
      }
    }
  }
  return result;
}

_DWORD *sub_1CC49318C(_DWORD *result, int a2)
{
  char v2 = result;
  if (a2)
  {
    unint64_t v3 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    LODWORD(v4) = (((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8)) + 1;
    result[4] = v4;
    uint64_t result = operator new(16 * v4, (std::align_val_t)8uLL);
    *(void *)char v2 = result;
    *((void *)v2 + 1) = 0;
    uint64_t v5 = v2[4];
    if (v5)
    {
      uint64_t v6 = 16 * v5;
      do
      {
        *(void *)uint64_t result = -4;
        result += 4;
        v6 -= 16;
      }
      while (v6);
    }
  }
  else
  {
    *(void *)uint64_t result = 0;
    *((void *)result + 1) = 0;
    result[4] = 0;
  }
  return result;
}

uint64_t llvm::SwitchCG::getJumpTableNumCases(void *a1, int a2, unsigned int a3)
{
  if (a2) {
    int v3 = *(_DWORD *)(*a1 + 4 * (a2 - 1));
  }
  else {
    int v3 = 0;
  }
  return (*(_DWORD *)(*a1 + 4 * a3) - v3);
}

void llvm::SwitchCG::SwitchLowering::findJumpTables(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v58[4] = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(void, void))(**(void **)(a1 + 80) + 528))(*(void *)(a1 + 80), *(void *)(*(void *)(a3 + 40) + 56)))
  {
    unsigned int v44 = (*(uint64_t (**)(void))(**(void **)(a1 + 80) + 696))(*(void *)(a1 + 80));
    uint64_t v12 = a2[1] - *a2;
    if (v12 >= 80)
    {
      int64_t v45 = v12 / 40;
      if (v12 / 40 >= v44)
      {
        v57[0] = v58;
        v57[1] = (void *)0x800000000;
        sub_1CB9CDA9C((uint64_t)v57, v45, 0);
        uint64_t v13 = 0;
        unsigned int v14 = 1;
        do
        {
          uint64_t v15 = *a2 + 40 * v13;
          uint64_t v17 = *(void *)(v15 + 8);
          uint64_t v16 = *(void *)(v15 + 16);
          uint64_t v18 = (const llvm::APInt *)(v16 + 24);
          unsigned int v49 = *(_DWORD *)(v16 + 32);
          if (v49 > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v48, v18);
          }
          uint64_t v48 = *(_DWORD **)v18;
          llvm::APInt::operator-=((uint64_t)&v48, (unint64_t **)(v17 + 24));
          LODWORD(v55) = v49;
          uint64_t v54 = v48;
          unsigned int v49 = 0;
          unsigned int v19 = sub_1CBF82054((uint64_t)&v54, 0xFFFFFFFFFFFFFFFFLL);
          *((_DWORD *)v57[0] + v13) = v19 + 1;
          if (v55 >= 0x41 && v54) {
            MEMORY[0x1D25D9CB0](v54, 0x1000C8000313F17);
          }
          if (v49 >= 0x41 && v48) {
            MEMORY[0x1D25D9CB0](v48, 0x1000C8000313F17);
          }
          if (v14 != 1) {
            *((_DWORD *)v57[0] + v13) += *((_DWORD *)v57[0] + v14 - 2);
          }
          uint64_t v13 = v14;
          BOOL v29 = v45 <= v14++;
        }
        while (!v29);
        llvm::SwitchCG::getJumpTableRange(a2, 0, v45 - 1);
        uint64_t v43 = v45 - 1;
        if ((*(uint64_t (**)(void))(**(void **)(a1 + 80) + 536))())
        {
          v56[4] = -1;
          llvm::SwitchCG::SwitchLowering::buildJumpTable(a1, a2, 0, v43, a3, a4, (uint64_t)&v54);
        }
        if (*(_DWORD *)(*(void *)(a1 + 88) + 552))
        {
          uint64_t v54 = v56;
          uint64_t v55 = 0x800000000;
          sub_1CB9CDA9C((uint64_t)&v54, v45, 0);
          v52[0] = v53;
          v52[1] = (void *)0x800000000;
          sub_1CB9CDA9C((uint64_t)v52, v45, 0);
          v50[0] = v51;
          v50[1] = (void *)0x800000000;
          sub_1CB9CDA9C((uint64_t)v50, v45, 0);
          uint64_t v20 = 1;
          v54[v43] = 1;
          *((_DWORD *)v52[0] + v43) = v43;
          *((_DWORD *)v50[0] + v43) = 2;
          uint64_t v21 = v45 - 2;
          uint64_t v42 = v45;
          while (1)
          {
            uint64_t v22 = 4 * v21 + 4;
            v54[v21] = *(_DWORD *)((char *)v54 + v22) + 1;
            *((_DWORD *)v52[0] + v21) = v21;
            *((_DWORD *)v50[0] + v21) = *(_DWORD *)((char *)v50[0] + v22) + 2;
            if (v43 > v21) {
              break;
            }
LABEL_44:
            ++v20;
            BOOL v29 = v21-- <= 0;
            if (v29)
            {
              int64_t v32 = 0;
              unsigned int v33 = 0;
              unsigned int v34 = 0;
              do
              {
                unsigned int v35 = *((_DWORD *)v52[0] + v32);
                int v47 = -1;
                if (v35 - v33 + 1 >= v44) {
                  llvm::SwitchCG::SwitchLowering::buildJumpTable(a1, a2, v33, v35, a3, a4, (uint64_t)&v46);
                }
                if (v35 >= v33)
                {
                  unsigned int v36 = v34;
                  do
                  {
                    unsigned int v34 = v36 + 1;
                    uint64_t v37 = *a2 + 40 * v36;
                    uint64_t v38 = *a2 + 40 * v33;
                    long long v39 = *(_OWORD *)v38;
                    long long v40 = *(_OWORD *)(v38 + 16);
                    *(void *)(v37 + 32) = *(void *)(v38 + 32);
                    *(_OWORD *)uint64_t v37 = v39;
                    *(_OWORD *)(v37 + 16) = v40;
                    ++v33;
                    unsigned int v36 = v34;
                  }
                  while (v33 <= v35);
                }
                int64_t v32 = v35 + 1;
                unsigned int v33 = v35 + 1;
              }
              while (v45 > v32);
              unint64_t v41 = 0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 3);
              if (v34 > v41)
              {
                sub_1CD57F824((void **)a2, v34 - v41);
              }
              else if (v34 < v41)
              {
                a2[1] = *a2 + 40 * v34;
              }
              if (v50[0] != v51) {
                free(v50[0]);
              }
              if (v52[0] != v53) {
                free(v52[0]);
              }
              if (v54 != v56) {
                free(v54);
              }
              goto LABEL_63;
            }
          }
          uint64_t v23 = 0;
          while (1)
          {
            unsigned int v24 = v45 + v23 - 1;
            JumpTableRange = llvm::SwitchCG::getJumpTableRange(a2, v21, v24);
            if (v21) {
              int v26 = *((_DWORD *)v57[0] + (v21 - 1));
            }
            else {
              int v26 = 0;
            }
            if (!(*(unsigned int (**)(void, uint64_t, void, char *, uint64_t, uint64_t))(**(void **)(a1 + 80) + 536))(*(void *)(a1 + 80), a3, (*((_DWORD *)v57[0] + v24) - v26), JumpTableRange, a5, a6))goto LABEL_37; {
            if (v23)
            }
            {
              unsigned int v27 = v54[v42 + v23] + 1;
              unsigned int v28 = *(_DWORD *)((char *)v50[0] + 4 * v23 + v42 * 4);
            }
            else
            {
              unsigned int v28 = 0;
              unsigned int v27 = 1;
            }
            BOOL v29 = v20 + v23 >= v44 >> 1 && v20 + v23 < v44 - 1;
            if (!v29) {
              ++v28;
            }
            unsigned int v30 = v54[v21];
            if (v27 >= v30)
            {
              if (v27 != v30) {
                goto LABEL_37;
              }
              BOOL v31 = v50[0];
              if (v28 <= *((_DWORD *)v50[0] + v21)) {
                goto LABEL_37;
              }
            }
            else
            {
              BOOL v31 = v50[0];
            }
            v54[v21] = v27;
            *((_DWORD *)v52[0] + v21) = v24;
            v31[v21] = v28;
LABEL_37:
            --v23;
            if (v45 + v23 - 1 <= v21) {
              goto LABEL_44;
            }
          }
        }
LABEL_63:
        if (v57[0] != v58) {
          free(v57[0]);
        }
      }
    }
  }
}

void llvm::SwitchCG::SwitchLowering::findBitTestClusters(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1[11] + 552))
  {
    LOBYTE(v43[0]) = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1[10] + 32))(a1[10], a1[12], 0);
    v43[1] = 0;
    if (LOBYTE(v43[0]))
    {
      uint64_t v6 = a1[10];
      if ((LOBYTE(v43[0]) == 1 || *(void *)(v6 + 8 * LOBYTE(v43[0]) + 96))
        && !*(unsigned char *)(v6 + 390 * LOBYTE(v43[0]) + 4037))
      {
        int v8 = sub_1CB87E200((unsigned __int8 *)v43);
        if (v7 == 1) {
        uint64_t v10 = *a2;
        }
        uint64_t v9 = a2[1];
        uint64_t v11 = v9 - *a2;
        unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (v11 >> 3);
        int v52 = v55;
        int v54 = 8;
        uint64_t v38 = a3;
        if (v12 > 8)
        {
          int v53 = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9 == v10)
        {
          LODWORD(v13) = 0;
          int v53 = -858993459 * (v11 >> 3);
          uint64_t v48 = v51;
          int v50 = 8;
        }
        else
        {
          bzero(v55, 0x3333333333333334 * (v11 >> 3));
          int v53 = -858993459 * (v11 >> 3);
          uint64_t v48 = v51;
          int v50 = 8;
          bzero(v51, 0x3333333333333334 * (v11 >> 3));
          unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * (v11 >> 3);
        }
        int v49 = v13;
        int64_t v40 = 0xCCCCCCCCCCCCCCCDLL * (v11 >> 3);
        v55[v12 - 1] = 1;
        int64_t v42 = v12 - 1;
        v51[v12 - 1] = v12 - 1;
        uint64_t v39 = v11;
        if (v11 >= 41)
        {
          int64_t v14 = v40 - 2;
          uint64_t v41 = v8 - 1;
          int64_t v15 = v40 - 3;
          uint64_t v16 = 40 * v40 - 80;
          do
          {
            v52[v14] = v52[v14 + 1] + 1;
            *((_DWORD *)v48 + v14) = v14;
            if (v41 + v14 >= v42) {
              int64_t v17 = v42;
            }
            else {
              int64_t v17 = v41 + v14;
            }
            while (v17 > v14)
            {
              if (sub_1CB908330(a1[10], (void *)(*(void *)(*a2 + 40 * v14 + 8) + 24), *(void *)(*a2 + 40 * v17 + 16) + 24, a1[12]))
              {
                uint64_t v18 = (*(void *)(*(void *)(a1[13] + 8) + 112) - *(void *)(*(void *)(a1[13] + 8) + 104)) >> 3;
                uint64_t v19 = (v18 + 63) >> 6;
                v44[0] = &v45;
                HIDWORD(v44[1]) = 6;
                if (v19 >= 7)
                {
                  LODWORD(v44[1]) = 0;
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                if ((v18 + 63) >> 6) {
                  bzero(&v45, 8 * v19);
                }
                LODWORD(v44[1]) = (v18 + 63) >> 6;
                int v47 = v18;
                uint64_t v20 = *a2 + v16;
                int64_t v21 = v15;
                while (!*(_DWORD *)v20)
                {
                  unint64_t v22 = *(unsigned int *)(*(void *)(v20 + 24) + 24);
                  *(void *)((char *)&v45 + ((v22 >> 3) & 0x1FFFFFF8)) |= 1 << v22;
                  ++v21;
                  v20 += 40;
                  if (v21 >= v17)
                  {
                    if (v19)
                    {
                      unsigned int v23 = 0;
                      uint64_t v24 = 8 * v19;
                      uint64_t v25 = (int8x8_t *)&v45;
                      do
                      {
                        int8x8_t v26 = *v25++;
                        uint8x8_t v27 = (uint8x8_t)vcnt_s8(v26);
                        v27.i16[0] = vaddlv_u8(v27);
                        v23 += v27.i32[0];
                        v24 -= 8;
                      }
                      while (v24);
                      if (v23 > 3) {
                        goto LABEL_36;
                      }
                    }
                    if (v17 == v42) {
                      int v28 = 0;
                    }
                    else {
                      int v28 = v52[v17 + 1];
                    }
                    unsigned int v29 = v28 + 1;
                    if (v29 < v52[v14])
                    {
                      v52[v14] = v29;
                      *((_DWORD *)v48 + v14) = v17;
                    }
                    goto LABEL_35;
                  }
                }
                break;
              }
LABEL_35:
              --v17;
            }
LABEL_36:
            --v15;
            v16 -= 40;
          }
          while (v14-- > 0);
        }
        if (v39 < 1)
        {
          unsigned int v33 = 0;
        }
        else
        {
          int64_t v31 = 0;
          unsigned int v32 = 0;
          unsigned int v33 = 0;
          do
          {
            unsigned int v34 = *((_DWORD *)v48 + v31);
            int v46 = -1;
            if (llvm::SwitchCG::SwitchLowering::buildBitTests(a1, a2, v32, v34, v38, (uint64_t)v44))
            {
              uint64_t v35 = *a2 + 40 * v33++;
              *(_OWORD *)uint64_t v35 = *(_OWORD *)v44;
              *(_OWORD *)(v35 + 16) = v45;
              *(_DWORD *)(v35 + 32) = v46;
            }
            else
            {
              unsigned int v36 = v34 - v32 + 1;
              memmove((void *)(*a2 + 40 * v33), (const void *)(*a2 + 40 * v31), 40 * v36);
              v33 += v36;
            }
            int64_t v31 = v34 + 1;
            unsigned int v32 = v34 + 1;
          }
          while (v40 > v31);
        }
        unint64_t v37 = 0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 3);
        if (v33 > v37)
        {
          sub_1CD57F824((void **)a2, v33 - v37);
        }
        else if (v33 < v37)
        {
          a2[1] = *a2 + 40 * v33;
        }
        if (v48 != v51) {
          free(v48);
        }
        if (v52 != v55) {
          free(v52);
        }
      }
    }
  }
}

uint64_t llvm::SwitchCG::SwitchLowering::buildBitTests(uint64_t *a1, uint64_t *a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  if (a3 == a4) {
    return 0;
  }
  unsigned int v10 = a3;
  uint64_t v13 = (*(void *)(*(void *)(a1[13] + 8) + 112) - *(void *)(*(void *)(a1[13] + 8) + 104)) >> 3;
  uint64_t v14 = (v13 + 63) >> 6;
  __int16 v118 = v121;
  int v120 = 6;
  uint64_t v15 = 8 * v14;
  if (v14 >= 7)
  {
    unsigned int v119 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if ((v13 + 63) >> 6) {
    bzero(v121, 8 * v14);
  }
  uint64_t v16 = (int8x8_t *)v121;
  unsigned int v119 = (v13 + 63) >> 6;
  int v122 = v13;
  if (v10 > a4)
  {
    unsigned int v17 = 0;
  }
  else
  {
    unsigned int v17 = 0;
    unint64_t v18 = a4 - (unint64_t)v10 + 1;
    uint64_t v19 = (void *)(*a2 + 40 * v10 + 16);
    do
    {
      unint64_t v20 = *(unsigned int *)(v19[1] + 24);
      *(void *)&v121[(v20 >> 3) & 0x1FFFFFF8] |= 1 << v20;
      if (*(v19 - 1) == *v19) {
        int v21 = 1;
      }
      else {
        int v21 = 2;
      }
      v17 += v21;
      v19 += 5;
      --v18;
    }
    while (v18);
  }
  if (v14)
  {
    LODWORD(v14) = 0;
    do
    {
      int8x8_t v22 = *v16++;
      uint8x8_t v23 = (uint8x8_t)vcnt_s8(v22);
      v23.i16[0] = vaddlv_u8(v23);
      LODWORD(v14) = v14 + v23.i32[0];
      v15 -= 8;
    }
    while (v15);
  }
  uint64_t v24 = *a2;
  unsigned int v92 = v10;
  uint64_t v25 = *(void *)(*a2 + 40 * v10 + 8);
  int8x8_t v26 = (const llvm::APInt *)(v25 + 24);
  unsigned int v115 = *(_DWORD *)(v25 + 32);
  unsigned int v27 = a4;
  if (v115 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v114, v26);
  }
  int v114 = *(unint64_t **)v26;
  uint64_t v28 = *(void *)(v24 + 40 * a4 + 16);
  unsigned int v29 = (const llvm::APInt *)(v28 + 24);
  unsigned int v113 = *(_DWORD *)(v28 + 32);
  if (v113 > 0x40) {
    llvm::APInt::initSlowCase((llvm::APInt *)&v112, v29);
  }
  uint64_t v112 = *(void *)v29;
  if (sub_1CB908330(a1[10], &v114, (uint64_t)&v112, a1[12]))
  {
    if (v17 >= 3 && v14 == 1 || v17 >= 5 && v14 == 2 || (uint64_t v6 = 0, v17 >= 6) && v14 == 3)
    {
      unsigned int v111 = 1;
      uint64_t v110 = 0;
      unsigned int v109 = 1;
      uint64_t v108 = 0;
      LOBYTE(v116) = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1[10] + 32))(a1[10], a1[12], 0);
      int v85 = sub_1CB87E200((unsigned __int8 *)&v116);
      if (v30 == 1) {
      if (v10 + 1 <= a4)
      }
      {
        uint64_t v91 = 40 * (v10 + 1);
        unint64_t v87 = a4 - (unint64_t)(v10 + 1) + 1;
        while (1)
        {
          uint64_t v32 = *a2 + v91;
          uint64_t v33 = *(void *)(v32 + 8);
          uint64_t v34 = *(void *)(v32 - 24);
          uint64_t v35 = (const llvm::APInt *)(v34 + 24);
          unsigned int v107 = *(_DWORD *)(v34 + 32);
          if (v107 > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v106, v35);
          }
          uint64_t v106 = *(const void **)v35;
          int v89 = (const void **)(v33 + 24);
          llvm::APInt::operator+=((uint64_t)&v106, 1uLL);
          unsigned int v36 = v107;
          DWORD2(v116) = v107;
          unint64_t v37 = v106;
          *(void *)&long long v116 = v106;
          unsigned int v107 = 0;
          if (*(_DWORD *)(v33 + 32) > 0x40u) {
            BOOL v38 = llvm::APInt::equalSlowCase(v89, (const void **)&v116);
          }
          else {
            BOOL v38 = *v89 == v106;
          }
          if (v36 >= 0x41)
          {
            if (v37)
            {
              MEMORY[0x1D25D9CB0](v37, 0x1000C8000313F17);
              if (v107 >= 0x41)
              {
                if (v106) {
                  MEMORY[0x1D25D9CB0](v106, 0x1000C8000313F17);
                }
              }
            }
          }
          if (!v38) {
            break;
          }
          v91 += 40;
          if (!--v87) {
            goto LABEL_34;
          }
        }
        char v84 = 0;
      }
      else
      {
LABEL_34:
        char v84 = 1;
      }
      if (sub_1CBBE05BC((uint64_t)&v114) && sub_1CBFC5D80((llvm::APInt *)&v112, v85))
      {
        sub_1CB8F1EEC((uint64_t)&v116, v115, 0);
        if (v111 >= 0x41 && v110) {
          MEMORY[0x1D25D9CB0](v110, 0x1000C8000313F17);
        }
        uint64_t v110 = (unint64_t *)v116;
        unsigned int v111 = DWORD2(v116);
        if (v109 > 0x40 || v113 > 0x40)
        {
          llvm::APInt::assignSlowCase((const llvm::APInt *)&v108, (const llvm::APInt *)&v112);
          char v84 = 0;
        }
        else
        {
          char v84 = 0;
          uint64_t v108 = v112;
          unsigned int v109 = v113;
        }
      }
      else
      {
        if (v111 > 0x40 || v115 > 0x40)
        {
          llvm::APInt::assignSlowCase((const llvm::APInt *)&v110, (const llvm::APInt *)&v114);
        }
        else
        {
          uint64_t v110 = v114;
          unsigned int v111 = v115;
        }
        unsigned int v105 = v113;
        if (v113 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v104, (const llvm::APInt *)&v112);
        }
        uint64_t v104 = v112;
        llvm::APInt::operator-=((uint64_t)&v104, &v114);
        unsigned int v39 = v105;
        uint64_t v40 = v104;
        unsigned int v105 = 0;
        if (v109 > 0x40 && v108)
        {
          MEMORY[0x1D25D9CB0](v108, 0x1000C8000313F17);
          uint64_t v108 = v40;
          unsigned int v109 = v39;
          if (v105 >= 0x41 && v104) {
            MEMORY[0x1D25D9CB0](v104, 0x1000C8000313F17);
          }
        }
        else
        {
          uint64_t v108 = v104;
          unsigned int v109 = v39;
        }
      }
      uint64_t v90 = 0;
      uint64_t v41 = 0;
      uint64_t v101 = 0;
      uint64_t v102 = 0;
      unint64_t v103 = 0;
      unsigned int v100 = 0;
      if (v10 <= a4)
      {
        uint64_t v41 = 0;
        uint64_t v90 = 0;
        unsigned int v88 = 0;
        uint64_t v42 = *a2;
        do
        {
          uint64_t v43 = v42 + 40 * v10;
          unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((v90 - v41) >> 3);
          uint64_t v45 = 0;
          if (v90 != v41)
          {
            unsigned int v46 = 1;
            do
            {
              if (*(void *)&v41[24 * v45 + 8] == *(void *)(v43 + 24)) {
                break;
              }
              uint64_t v45 = v46;
            }
            while (v44 > v46++);
          }
          if (v44 == v45)
          {
            uint64_t v48 = *(void *)(v43 + 24);
            *(void *)&long long v116 = 0;
            *((void *)&v116 + 1) = v48;
            v117[0] = 0;
            if ((unint64_t)v90 >= v103)
            {
              uint64_t v90 = sub_1CBF99908((void **)&v101, (uint64_t)&v116);
            }
            else
            {
              long long v49 = v116;
              *((void *)v90 + 2) = v117[0];
              *(_OWORD *)uint64_t v90 = v49;
              v90 += 24;
            }
            uint64_t v102 = v90;
            uint64_t v41 = v101;
            uint64_t v42 = *a2;
          }
          uint64_t v50 = *(void *)(v42 + 40 * v10 + 8);
          uint64_t v51 = (const llvm::APInt *)(v50 + 24);
          unsigned int v99 = *(_DWORD *)(v50 + 32);
          if (v99 > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v98, v51);
          }
          uint64_t v98 = *(uint64_t **)v51;
          llvm::APInt::operator-=((uint64_t)&v98, &v110);
          unsigned int v52 = v99;
          unsigned int v99 = 0;
          if (v52 >= 0x41)
          {
            uint64_t v86 = *v98;
            if (v98)
            {
              MEMORY[0x1D25D9CB0](v98, 0x1000C8000313F17);
              if (v99 >= 0x41)
              {
                if (v98) {
                  MEMORY[0x1D25D9CB0](v98, 0x1000C8000313F17);
                }
              }
            }
          }
          else
          {
            LODWORD(v86) = v98;
          }
          uint64_t v53 = *(void *)(*a2 + 40 * v10 + 16);
          int v54 = (const llvm::APInt *)(v53 + 24);
          unsigned int v97 = *(_DWORD *)(v53 + 32);
          if (v97 > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v96, v54);
          }
          unsigned int v96 = *(uint64_t **)v54;
          llvm::APInt::operator-=((uint64_t)&v96, &v110);
          unsigned int v55 = v97;
          unsigned int v97 = 0;
          if (v55 >= 0x41)
          {
            uint64_t v56 = *v96;
            if (v96)
            {
              MEMORY[0x1D25D9CB0](v96, 0x1000C8000313F17);
              if (v97 >= 0x41)
              {
                if (v96) {
                  MEMORY[0x1D25D9CB0](v96, 0x1000C8000313F17);
                }
              }
            }
          }
          else
          {
            LODWORD(v56) = v96;
          }
          *(void *)&v41[24 * v45] |= 0xFFFFFFFFFFFFFFFFLL >> ~(v56 - v86) << v86;
          uint64_t v57 = &v41[24 * v45];
          uint64_t v58 = *((unsigned int *)v57 + 5);
          *((_DWORD *)v57 + 4) += v56 - v86 + 1;
          uint64_t v42 = *a2;
          uint64_t v59 = *a2 + 40 * v10;
          uint64_t v60 = *(unsigned int *)(v59 + 32);
          unint64_t v61 = v58 + v60;
          unsigned int v62 = v58 + v60;
          if (v61 > 0x80000000) {
            unsigned int v62 = 0x80000000;
          }
          *((_DWORD *)v57 + 5) = v62;
          uint64_t v63 = *(unsigned int *)(v59 + 32);
          unint64_t v64 = v63 + v88;
          unsigned int v65 = v63 + v88;
          if (v64 > 0x80000000) {
            unsigned int v65 = 0x80000000;
          }
          unsigned int v88 = v65;
          ++v10;
        }
        while (v10 <= a4);
        unsigned int v100 = v65;
      }
      unint64_t v66 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v90 - v41) >> 3));
      *(void *)&long long v116 = v117;
      v31.n128_u64[0] = 0x300000000;
      *((void *)&v116 + 1) = 0x300000000;
      if (v90 == v41) {
        uint64_t v67 = 0;
      }
      else {
        uint64_t v67 = v66;
      }
      sub_1CC494F30((unint64_t)v41, (unint64_t)v90, v67, 1, v31);
      uint64_t v68 = v101;
      int v69 = v102;
      if (v101 != v102)
      {
        uint64_t v70 = v101;
        do
        {
          MachineBasicBlocuint64_t k = llvm::MachineFunction::CreateMachineBasicBlock(*(llvm::MachineFunction **)(a1[13] + 8), *(const llvm::BasicBlock **)(a5 + 40));
          uint64_t v72 = *((void *)v70 + 1);
          int v73 = *((_DWORD *)v70 + 5);
          v94[0] = *(void *)v70;
          v94[1] = MachineBasicBlock;
          v94[2] = v72;
          int v95 = v73;
          unint64_t v74 = (_OWORD *)sub_1CD57FBCC((uint64_t)&v116, (unint64_t)v94);
          uint64_t v75 = (_OWORD *)(v116 + 32 * DWORD2(v116));
          long long v76 = v74[1];
          *uint64_t v75 = *v74;
          v75[1] = v76;
          ++DWORD2(v116);
          v70 += 24;
        }
        while (v70 != v69);
      }
      int v77 = *(_DWORD *)(a5 + 20);
      if ((v77 & 0x40000000) != 0) {
        float v78 = *(uint64_t **)(a5 - 8);
      }
      else {
        float v78 = (uint64_t *)(a5 - 32 * (v77 & 0x7FFFFFF));
      }
      uint64_t v79 = *v78;
      LODWORD(v94[0]) = -1;
      sub_1CD57F7C8(a1 + 7, (uint64_t *)&v110, &v108, v79, (int *)v94, 1, 0, v84, (uint64_t)&v116, (int *)&v100);
      uint64_t v80 = *(void *)(*a2 + 40 * v92 + 8);
      uint64_t v81 = *(void *)(*a2 + 40 * v27 + 16);
      int v82 = -1431655765 * ((unint64_t)(a1[8] - a1[7]) >> 6) - 1;
      int v83 = v100;
      *(_DWORD *)a6 = 2;
      *(void *)(a6 + 8) = v80;
      *(void *)(a6 + 16) = v81;
      *(_DWORD *)(a6 + 24) = v82;
      *(_DWORD *)(a6 + 32) = v83;
      if ((void *)v116 != v117) {
        free((void *)v116);
      }
      if (v68) {
        operator delete(v68);
      }
      if (v109 >= 0x41 && v108) {
        MEMORY[0x1D25D9CB0](v108, 0x1000C8000313F17);
      }
      if (v111 >= 0x41 && v110) {
        MEMORY[0x1D25D9CB0](v110, 0x1000C8000313F17);
      }
      uint64_t v6 = 1;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (v113 >= 0x41 && v112) {
    MEMORY[0x1D25D9CB0](v112, 0x1000C8000313F17);
  }
  if (v115 >= 0x41 && v114) {
    MEMORY[0x1D25D9CB0](v114, 0x1000C8000313F17);
  }
  if (v118 != v121) {
    free(v118);
  }
  return v6;
}

void llvm::SwitchCG::sortAndRangeify(char **a1)
{
  char v2 = *a1;
  unint64_t v3 = (unint64_t)a1[1];
  unint64_t v4 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v3 - (void)v2) >> 3));
  if ((char *)v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  sub_1CC496558((uint64_t)v2, v3, v5, 1);
  uint64_t v6 = *a1;
  uint64_t v7 = (a1[1] - *a1) >> 3;
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * v7;
  uint64_t v9 = (-858993459 * v7);
  if (-858993459 * v7)
  {
    uint64_t v10 = 0;
    unsigned int v11 = 0;
    while (1)
    {
      unint64_t v12 = *a1;
      if (v11)
      {
        unsigned int v13 = v11 - 1;
        uint64_t v14 = *a1;
        if (*(void *)&v12[40 * v11 - 16] == *(void *)&v12[40 * v10 + 24])
        {
          uint64_t v19 = *(void *)&v12[40 * v10 + 8];
          unint64_t v20 = (const llvm::APInt *)(v19 + 24);
          unsigned int v21 = *(_DWORD *)(v19 + 32);
          unsigned int v29 = v21;
          if (v21 > 0x40) {
            llvm::APInt::initSlowCase((llvm::APInt *)&v28, v20);
          }
          unint64_t v22 = v21 ? 0xFFFFFFFFFFFFFFFFLL >> -(char)v21 : 0;
          unint64_t v28 = v22 & (*(void *)v20 - *(void *)(*(void *)&v12[40 * v13 + 16] + 24));
          unsigned int v29 = 0;
          uint64_t v14 = *a1;
          if (v28 == 1)
          {
            uint8x8_t v23 = &v14[40 * v13];
            *((void *)v23 + 2) = v19;
            uint64_t v24 = *(unsigned int *)&v12[40 * v10 + 32];
            uint64_t v25 = *((unsigned int *)v23 + 8);
            unint64_t v26 = v25 + v24;
            unsigned int v27 = v25 + v24;
            if (v26 > 0x80000000) {
              unsigned int v27 = 0x80000000;
            }
            *((_DWORD *)v23 + 8) = v27;
            goto LABEL_9;
          }
        }
      }
      else
      {
        uint64_t v14 = *a1;
      }
      uint64_t v15 = &v14[40 * v11];
      uint64_t v16 = &v14[40 * v10];
      long long v17 = *(_OWORD *)v16;
      long long v18 = *((_OWORD *)v16 + 1);
      *((void *)v15 + 4) = *((void *)v16 + 4);
      ++v11;
      *(_OWORD *)uint64_t v15 = v17;
      *((_OWORD *)v15 + 1) = v18;
LABEL_9:
      if (++v10 == v9)
      {
        uint64_t v6 = *a1;
        unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
        goto LABEL_12;
      }
    }
  }
  unsigned int v11 = 0;
LABEL_12:
  if (v11 > v8)
  {
    sub_1CD57F824((void **)a1, v11 - v8);
  }
  else if (v11 < v8)
  {
    a1[1] = &v6[40 * v11];
  }
}

char *sub_1CC494D70(void **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = (char *)*a1;
  unint64_t v3 = (char *)a1[1];
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - (unsigned char *)*a1) >> 4);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * (((unsigned char *)a1[2] - v4) >> 4) > v6) {
    unint64_t v6 = 0x999999999999999ALL * (((unsigned char *)a1[2] - v4) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * (((unsigned char *)a1[2] - v4) >> 4) >= 0x199999999999999) {
    unint64_t v10 = 0x333333333333333;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 > 0x333333333333333) {
      sub_1CB833614();
    }
    unsigned int v11 = (char *)operator new(80 * v10);
  }
  else
  {
    unsigned int v11 = 0;
  }
  unint64_t v12 = &v11[80 * v5];
  *((_DWORD *)v12 + 2) = *(_DWORD *)(a2 + 8);
  *(void *)unint64_t v12 = *(void *)a2;
  unsigned int v13 = &v11[80 * v10];
  *(_DWORD *)(a2 + 8) = 0;
  *((_DWORD *)v12 + 6) = *(_DWORD *)(a2 + 24);
  *((void *)v12 + 2) = *(void *)(a2 + 16);
  *(_DWORD *)(a2 + 24) = 0;
  *((_OWORD *)v12 + 2) = *(_OWORD *)(a2 + 32);
  *((_WORD *)v12 + 24) = *(_WORD *)(a2 + 48);
  *(_OWORD *)(v12 + 56) = *(_OWORD *)a3;
  uint64_t v14 = *(void *)(a3 + 16);
  uint64_t v15 = v12 + 80;
  *((void *)v12 + 9) = v14;
  if (v3 == v4)
  {
    *a1 = v12;
    a1[1] = v15;
    a1[2] = v13;
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      long long v17 = &v12[v16];
      long long v18 = &v3[v16];
      *((_DWORD *)v17 - 18) = *(_DWORD *)&v3[v16 - 72];
      *((void *)v17 - 10) = *(void *)&v3[v16 - 80];
      *((_DWORD *)v18 - 18) = 0;
      *((_DWORD *)v17 - 14) = *(_DWORD *)&v3[v16 - 56];
      *((void *)v17 - 8) = *(void *)&v3[v16 - 64];
      *((_DWORD *)v18 - 14) = 0;
      long long v19 = *(_OWORD *)&v3[v16 - 48];
      *((_WORD *)v17 - 16) = *(_WORD *)&v3[v16 - 32];
      *((_OWORD *)v17 - 3) = v19;
      long long v20 = *(_OWORD *)&v3[v16 - 24];
      *((void *)v17 - 1) = *(void *)&v3[v16 - 8];
      *(_OWORD *)(v17 - 24) = v20;
      v16 -= 80;
    }
    while (&v3[v16] != v4);
    unint64_t v3 = (char *)*a1;
    uint64_t v21 = (uint64_t)a1[1];
    *a1 = &v12[v16];
    a1[1] = v15;
    a1[2] = v13;
    while ((char *)v21 != v3)
      uint64_t v21 = sub_1CD494A40(v21 - 80);
  }
  if (v3) {
    operator delete(v3);
  }
  return v15;
}

void sub_1CC494F30(unint64_t a1, unint64_t a2, uint64_t a3, char a4, __n128 a5)
{
__n128 sub_1CC495B64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  result.n128_u64[0] = sub_1CC49613C(a1, a2, a3, a4, a6).n128_u64[0];
  unsigned int v12 = *(_DWORD *)(a4 + 20);
  unsigned int v13 = *(_DWORD *)(a5 + 20);
  BOOL v14 = v13 > v12;
  if (v13 == v12 && (v15 = *(_DWORD *)(a5 + 16), v16 = *(_DWORD *)(a4 + 16), BOOL v14 = v15 > v16, v15 == v16))
  {
    if (*(void *)a5 >= *(void *)a4) {
      return result;
    }
  }
  else if (!v14)
  {
    return result;
  }
  uint64_t v17 = *(void *)(a4 + 16);
  __n128 result = *(__n128 *)a4;
  uint64_t v18 = *(void *)(a5 + 16);
  *(_OWORD *)a4 = *(_OWORD *)a5;
  *(void *)(a4 + 16) = v18;
  *(__n128 *)a5 = result;
  *(void *)(a5 + 16) = v17;
  LODWORD(v17) = *(_DWORD *)(a3 + 20);
  LODWORD(v18) = *(_DWORD *)(a4 + 20);
  BOOL v19 = v18 > v17;
  if (v18 == v17
    && (v20 = *(_DWORD *)(a4 + 16), v21 = *(_DWORD *)(a3 + 16), BOOL v19 = v20 > v21, v20 == v21))
  {
    if (*(void *)a4 >= *(void *)a3) {
      return result;
    }
  }
  else if (!v19)
  {
    return result;
  }
  uint64_t v22 = *(void *)(a3 + 16);
  __n128 result = *(__n128 *)a3;
  uint64_t v23 = *(void *)(a4 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(void *)(a3 + 16) = v23;
  *(__n128 *)a4 = result;
  *(void *)(a4 + 16) = v22;
  LODWORD(v22) = *(_DWORD *)(a2 + 20);
  LODWORD(v23) = *(_DWORD *)(a3 + 20);
  BOOL v24 = v23 > v22;
  if (v23 == v22
    && (v25 = *(_DWORD *)(a3 + 16), v26 = *(_DWORD *)(a2 + 16), BOOL v24 = v25 > v26, v25 == v26))
  {
    if (*(void *)a3 >= *(void *)a2) {
      return result;
    }
  }
  else if (!v24)
  {
    return result;
  }
  uint64_t v27 = *(void *)(a2 + 16);
  __n128 result = *(__n128 *)a2;
  uint64_t v28 = *(void *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = v28;
  *(__n128 *)a3 = result;
  *(void *)(a3 + 16) = v27;
  LODWORD(v27) = *(_DWORD *)(a1 + 20);
  LODWORD(v28) = *(_DWORD *)(a2 + 20);
  BOOL v29 = v28 > v27;
  if (v28 == v27)
  {
    unsigned int v30 = *(_DWORD *)(a2 + 16);
    unsigned int v31 = *(_DWORD *)(a1 + 16);
    BOOL v29 = v30 > v31;
    if (v30 == v31)
    {
      if (*(void *)a2 >= *(void *)a1) {
        return result;
      }
LABEL_25:
      uint64_t v32 = *(void *)(a1 + 16);
      __n128 result = *(__n128 *)a1;
      uint64_t v33 = *(void *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = v33;
      *(__n128 *)a2 = result;
      *(void *)(a2 + 16) = v32;
      return result;
    }
  }
  if (v29) {
    goto LABEL_25;
  }
  return result;
}

__n128 sub_1CC495D10(uint64_t a1, uint64_t a2, uint64_t a3, __n128 result)
{
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  unsigned int v5 = *(_DWORD *)(a2 + 20);
  BOOL v6 = v5 > v4;
  if (v5 == v4)
  {
    unsigned int v7 = *(_DWORD *)(a2 + 16);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    BOOL v6 = v7 > v8;
    if (v7 == v8)
    {
      if (*(void *)a2 >= *(void *)a1) {
        goto LABEL_4;
      }
LABEL_10:
      unsigned int v13 = *(_DWORD *)(a3 + 20);
      BOOL v14 = v13 > v5;
      if (v13 == v5 && (v15 = *(_DWORD *)(a3 + 16), v16 = *(_DWORD *)(a2 + 16), BOOL v14 = v15 > v16, v15 == v16))
      {
        if (*(void *)a3 >= *(void *)a2) {
          goto LABEL_13;
        }
      }
      else if (!v14)
      {
LABEL_13:
        unint64_t v17 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v18 = *(void *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v18;
        *(__n128 *)a2 = result;
        *(void *)(a2 + 16) = v17;
        v17 >>= 32;
        LODWORD(v18) = *(_DWORD *)(a3 + 20);
        BOOL v19 = v18 > v17;
        if (v18 == v17
          && (v20 = *(_DWORD *)(a3 + 16), v21 = *(_DWORD *)(a2 + 16), BOOL v19 = v20 > v21, v20 == v21))
        {
          if (*(void *)a3 >= *(void *)a2) {
            return result;
          }
        }
        else if (!v19)
        {
          return result;
        }
        uint64_t v27 = *(void *)(a2 + 16);
        __n128 result = *(__n128 *)a2;
        uint64_t v29 = *(void *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(void *)(a2 + 16) = v29;
LABEL_29:
        *(__n128 *)a3 = result;
        *(void *)(a3 + 16) = v27;
        return result;
      }
      uint64_t v27 = *(void *)(a1 + 16);
      __n128 result = *(__n128 *)a1;
      uint64_t v28 = *(void *)(a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(void *)(a1 + 16) = v28;
      goto LABEL_29;
    }
  }
  if (v6) {
    goto LABEL_10;
  }
LABEL_4:
  unsigned int v9 = *(_DWORD *)(a3 + 20);
  BOOL v10 = v9 > v5;
  if (v9 == v5 && (v11 = *(_DWORD *)(a3 + 16), v12 = *(_DWORD *)(a2 + 16), BOOL v10 = v11 > v12, v11 == v12))
  {
    if (*(void *)a3 >= *(void *)a2) {
      return result;
    }
  }
  else if (!v10)
  {
    return result;
  }
  uint64_t v22 = *(void *)(a2 + 16);
  __n128 result = *(__n128 *)a2;
  uint64_t v23 = *(void *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = v23;
  *(__n128 *)a3 = result;
  *(void *)(a3 + 16) = v22;
  LODWORD(v22) = *(_DWORD *)(a1 + 20);
  LODWORD(v23) = *(_DWORD *)(a2 + 20);
  BOOL v24 = v23 > v22;
  if (v23 == v22)
  {
    unsigned int v25 = *(_DWORD *)(a2 + 16);
    unsigned int v26 = *(_DWORD *)(a1 + 16);
    BOOL v24 = v25 > v26;
    if (v25 == v26)
    {
      if (*(void *)a2 >= *(void *)a1) {
        return result;
      }
LABEL_32:
      uint64_t v30 = *(void *)(a1 + 16);
      __n128 result = *(__n128 *)a1;
      uint64_t v31 = *(void *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = v31;
      *(__n128 *)a2 = result;
      *(void *)(a2 + 16) = v30;
      return result;
    }
  }
  if (v24) {
    goto LABEL_32;
  }
  return result;
}

BOOL sub_1CC495EC4(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unsigned int v7 = (void *)(a2 - 24);
      unsigned int v8 = *(_DWORD *)(a1 + 20);
      unsigned int v9 = *(_DWORD *)(a2 - 4);
      BOOL v10 = v9 > v8;
      if (v9 == v8 && (v11 = *(_DWORD *)(a2 - 8), v12 = *(_DWORD *)(a1 + 16), BOOL v10 = v11 > v12, v11 == v12))
      {
        if (*v7 >= *(void *)a1) {
          return result;
        }
      }
      else if (!v10)
      {
        return result;
      }
      uint64_t v29 = *(void *)(a1 + 16);
      long long v30 = *(_OWORD *)a1;
      uint64_t v31 = *(void *)(a2 - 8);
      *(_OWORD *)a1 = *(_OWORD *)v7;
      *(void *)(a1 + 16) = v31;
      *(_OWORD *)unsigned int v7 = v30;
      *(void *)(a2 - 8) = v29;
      return result;
    case 3uLL:
      sub_1CC495D10(a1, a1 + 24, a2 - 24, a3);
      return 1;
    case 4uLL:
      sub_1CC49613C(a1, a1 + 24, a1 + 48, a2 - 24, a3);
      return 1;
    case 5uLL:
      sub_1CC495B64(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24, a3);
      return 1;
    default:
      uint64_t v13 = a1 + 48;
      sub_1CC495D10(a1, a1 + 24, a1 + 48, a3);
      uint64_t v14 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v15 = 0;
      int v16 = 0;
      break;
  }
  do
  {
    unsigned int v17 = *(_DWORD *)(v13 + 20);
    unsigned int v18 = *(_DWORD *)(v14 + 20);
    if (v18 == v17)
    {
      unsigned int v19 = *(_DWORD *)(v14 + 16);
      unsigned int v20 = *(_DWORD *)(v13 + 16);
      if (v19 == v20)
      {
        if (*(void *)v14 >= *(void *)v13) {
          goto LABEL_29;
        }
      }
      else if (v19 <= v20)
      {
        goto LABEL_29;
      }
    }
    else
    {
      if (v18 <= v17) {
        goto LABEL_29;
      }
      unsigned int v19 = *(_DWORD *)(v14 + 16);
    }
    unint64_t v21 = *(void *)v14;
    uint64_t v22 = *(void *)(v14 + 8);
    *(_OWORD *)uint64_t v14 = *(_OWORD *)v13;
    *(void *)(v14 + 16) = *(void *)(v13 + 16);
    uint64_t v23 = a1;
    if (v13 == a1) {
      goto LABEL_28;
    }
    uint64_t v24 = v15;
    while (1)
    {
      uint64_t v25 = a1 + v24;
      unsigned int v26 = (unint64_t *)(a1 + v24 + 24);
      unsigned int v27 = *(_DWORD *)(a1 + v24 + 44);
      if (v18 != v27) {
        break;
      }
      unsigned int v28 = *(_DWORD *)(v25 + 40);
      if (v19 == v28)
      {
        if (v21 >= *v26) {
          goto LABEL_27;
        }
      }
      else if (v19 <= v28)
      {
        uint64_t v23 = a1 + v24 + 48;
        goto LABEL_28;
      }
LABEL_25:
      v13 -= 24;
      *(_OWORD *)(v25 + 48) = *(_OWORD *)v26;
      *(void *)(v25 + 64) = *(void *)(a1 + v24 + 40);
      v24 -= 24;
      if (v24 == -48)
      {
        uint64_t v23 = a1;
        goto LABEL_28;
      }
    }
    if (v18 > v27) {
      goto LABEL_25;
    }
LABEL_27:
    uint64_t v23 = v13;
LABEL_28:
    *(void *)uint64_t v23 = v21;
    *(void *)(v23 + 8) = v22;
    *(_DWORD *)(v23 + 16) = v19;
    *(_DWORD *)(v23 + 20) = v18;
    if (++v16 == 8) {
      return v14 + 24 == a2;
    }
LABEL_29:
    uint64_t v13 = v14;
    v15 += 24;
    v14 += 24;
  }
  while (v14 != a2);
  return 1;
}

__n128 sub_1CC49613C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  result.n128_u64[0] = sub_1CC495D10(a1, a2, a3, a5).n128_u64[0];
  unsigned int v10 = *(_DWORD *)(a3 + 20);
  unsigned int v11 = *(_DWORD *)(a4 + 20);
  BOOL v12 = v11 > v10;
  if (v11 == v10 && (unsigned int v13 = *(_DWORD *)(a4 + 16), v14 = *(_DWORD *)(a3 + 16), v12 = v13 > v14, v13 == v14))
  {
    if (*(void *)a4 >= *(void *)a3) {
      return result;
    }
  }
  else if (!v12)
  {
    return result;
  }
  uint64_t v15 = *(void *)(a3 + 16);
  __n128 result = *(__n128 *)a3;
  uint64_t v16 = *(void *)(a4 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(void *)(a3 + 16) = v16;
  *(__n128 *)a4 = result;
  *(void *)(a4 + 16) = v15;
  LODWORD(v15) = *(_DWORD *)(a2 + 20);
  LODWORD(v16) = *(_DWORD *)(a3 + 20);
  BOOL v17 = v16 > v15;
  if (v16 == v15
    && (v18 = *(_DWORD *)(a3 + 16), v19 = *(_DWORD *)(a2 + 16), BOOL v17 = v18 > v19, v18 == v19))
  {
    if (*(void *)a3 >= *(void *)a2) {
      return result;
    }
  }
  else if (!v17)
  {
    return result;
  }
  uint64_t v20 = *(void *)(a2 + 16);
  __n128 result = *(__n128 *)a2;
  uint64_t v21 = *(void *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = v21;
  *(__n128 *)a3 = result;
  *(void *)(a3 + 16) = v20;
  LODWORD(v20) = *(_DWORD *)(a1 + 20);
  LODWORD(v21) = *(_DWORD *)(a2 + 20);
  BOOL v22 = v21 > v20;
  if (v21 == v20)
  {
    unsigned int v23 = *(_DWORD *)(a2 + 16);
    unsigned int v24 = *(_DWORD *)(a1 + 16);
    BOOL v22 = v23 > v24;
    if (v23 == v24)
    {
      if (*(void *)a2 >= *(void *)a1) {
        return result;
      }
LABEL_19:
      uint64_t v25 = *(void *)(a1 + 16);
      __n128 result = *(__n128 *)a1;
      uint64_t v26 = *(void *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = v26;
      *(__n128 *)a2 = result;
      *(void *)(a2 + 16) = v25;
      return result;
    }
  }
  if (v22) {
    goto LABEL_19;
  }
  return result;
}

uint64_t sub_1CC496284(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, int *a5, char a6, char a7, char a8, uint64_t a9, int *a10)
{
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 6);
  unint64_t v11 = v10 + 1;
  if (v10 + 1 > 0x155555555555555) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 6) > v11) {
    unint64_t v11 = 0x5555555555555556 * ((a1[2] - *a1) >> 6);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 6) >= 0xAAAAAAAAAAAAAALL) {
    unint64_t v20 = 0x155555555555555;
  }
  else {
    unint64_t v20 = v11;
  }
  if (v20)
  {
    if (v20 > 0x155555555555555) {
      sub_1CB833614();
    }
    uint64_t v21 = (char *)operator new(192 * v20);
  }
  else
  {
    uint64_t v21 = 0;
  }
  uint64_t v22 = (uint64_t)&v21[192 * v10];
  unsigned int v23 = &v21[192 * v20];
  sub_1CC496404(v22, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  uint64_t v24 = v22 + 192;
  uint64_t v26 = (char *)*a1;
  uint64_t v25 = (char *)a1[1];
  if (v25 == (char *)*a1)
  {
    *a1 = v22;
    a1[1] = v24;
    a1[2] = (uint64_t)v23;
  }
  else
  {
    do
    {
      v22 -= 192;
      v25 -= 192;
      sub_1CD57FD64(v22, (uint64_t)v25);
    }
    while (v25 != v26);
    uint64_t v25 = (char *)*a1;
    uint64_t v27 = a1[1];
    *a1 = v22;
    a1[1] = v24;
    a1[2] = (uint64_t)v23;
    while ((char *)v27 != v25)
      uint64_t v27 = sub_1CD57FDF4(v27 - 192);
  }
  if (v25) {
    operator delete(v25);
  }
  return v24;
}

void sub_1CC496404(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, int *a5, char a6, char a7, char a8, uint64_t a9, int *a10)
{
  v24[12] = *MEMORY[0x1E4F143B8];
  int v13 = *((_DWORD *)a2 + 2);
  uint64_t v14 = *a2;
  *((_DWORD *)a2 + 2) = 0;
  int v15 = *((_DWORD *)a3 + 2);
  uint64_t v16 = *a3;
  *((_DWORD *)a3 + 2) = 0;
  int v17 = *a5;
  uint64_t v22 = v24;
  uint64_t v23 = 0x300000000;
  if (*(_DWORD *)(a9 + 8))
  {
    char v20 = a7;
    char v21 = a8;
    sub_1CD57FC44((uint64_t)&v22, a9);
    a7 = v20;
    a8 = v21;
    BOOL v18 = v23 == 0;
  }
  else
  {
    BOOL v18 = 1;
  }
  int v19 = *a10;
  *(_DWORD *)(a1 + 8) = v13;
  *(void *)a1 = v14;
  *(_DWORD *)(a1 + 24) = v15;
  *(void *)(a1 + 16) = v16;
  *(void *)(a1 + 32) = a4;
  *(_DWORD *)(a1 + 40) = v17;
  *(unsigned char *)(a1 + 44) = a6;
  *(unsigned char *)(a1 + 45) = a7;
  *(unsigned char *)(a1 + 46) = a8;
  *(void *)(a1 + 64) = a1 + 80;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 72) = 0x300000000;
  if (!v18) {
    sub_1CD57FC44(a1 + 64, (uint64_t)&v22);
  }
  *(_DWORD *)(a1 + 176) = v19;
  *(_DWORD *)(a1 + 180) = -1;
  *(unsigned char *)(a1 + 184) = 0;
  if (v22 != v24) {
    free(v22);
  }
}

uint64_t sub_1CC496558(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v9 = result;
LABEL_2:
  unint64_t v10 = v9;
LABEL_3:
  while (1)
  {
    unint64_t v9 = v10;
    uint64_t v11 = a2 - v10;
    uint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
    if (v5 || !v4) {
      break;
    }
    if (v11 <= 959)
    {
      unint64_t v220 = v10 + 40;
      BOOL v222 = v10 == a2 || v220 == a2;
      if (a4)
      {
        if (!v222)
        {
          unint64_t v223 = v10;
          while (1)
          {
            unint64_t v224 = v223;
            unint64_t v223 = v220;
            uint64_t v225 = *(void *)(v224 + 48);
            uint64_t v226 = *(void *)(v224 + 8);
            uint64_t v227 = (void *)(v226 + 24);
            uint64_t v228 = *(unsigned int *)(v225 + 32);
            if (v228 <= 0x40) {
              break;
            }
            uint64_t v247 = *(void *)(v225 + 24);
            uint64_t v248 = *(void *)(v247 + 8 * ((v228 - 1) >> 6)) & (1 << (v228 - 1));
            __n128 result = *(unsigned int *)(v226 + 32);
            unsigned int v249 = result - 1;
            uint64_t v250 = *(void *)(v226 + 24);
            if (result >= 0x41) {
              uint64_t v227 = (void *)(v250 + 8 * (v249 >> 6));
            }
            if ((v248 != 0) != ((*v227 >> v249) & 1))
            {
              if (!v248) {
                goto LABEL_252;
              }
              goto LABEL_236;
            }
            unint64_t v251 = v228 + 63;
            uint64_t v252 = v250 - 8;
            uint64_t v253 = (v251 >> 3) & 0x3FFFFFF8;
            uint64_t v254 = v247 - 8;
            do
            {
              if (!v253) {
                goto LABEL_252;
              }
              unint64_t v255 = *(void *)(v254 + v253);
              unint64_t v256 = *(void *)(v252 + v253);
              v253 -= 8;
            }
            while (v255 == v256);
            if (v255 <= v256) {
              goto LABEL_236;
            }
LABEL_252:
            unint64_t v220 = v223 + 40;
            if (v223 + 40 == a2) {
              return result;
            }
          }
          if ((uint64_t)(*(void *)(v225 + 24) << -(char)v228) >> -(char)v228 >= (uint64_t)(*v227 << -(char)v228) >> -(char)v228) {
            goto LABEL_252;
          }
LABEL_236:
          uint64_t v229 = *(void *)(v224 + 40);
          uint64_t v501 = *(void *)(v224 + 72);
          long long v491 = *(_OWORD *)(v224 + 56);
          *(_DWORD *)(v223 + 32) = *(_DWORD *)(v224 + 32);
          long long v230 = *(_OWORD *)(v224 + 16);
          *(_OWORD *)unint64_t v223 = *(_OWORD *)v224;
          *(_OWORD *)(v223 + 16) = v230;
          unint64_t v231 = v10;
          if (v224 == v10) {
            goto LABEL_251;
          }
          while (1)
          {
            uint64_t v232 = *(void *)(v224 - 32);
            uint64_t v233 = (void *)(v232 + 24);
            uint64_t v234 = *(unsigned int *)(v225 + 32);
            if (v234 > 0x40)
            {
              uint64_t v236 = *(void *)(v225 + 24);
              uint64_t v237 = *(void *)(v236 + 8 * ((v234 - 1) >> 6)) & (1 << (v234 - 1));
              __n128 result = v237 != 0;
              unsigned int v238 = *(_DWORD *)(v232 + 32);
              unsigned int v239 = v238 - 1;
              uint64_t v240 = *(void *)(v232 + 24);
              if (v238 >= 0x41) {
                uint64_t v233 = (void *)(v240 + 8 * (v239 >> 6));
              }
              if (result == ((*v233 >> v239) & 1))
              {
                unint64_t v241 = v234 + 63;
                uint64_t v242 = v240 - 8;
                uint64_t v243 = (v241 >> 3) & 0x3FFFFFF8;
                uint64_t v244 = v236 - 8;
                while (v243)
                {
                  unint64_t v245 = *(void *)(v244 + v243);
                  unint64_t v246 = *(void *)(v242 + v243);
                  v243 -= 8;
                  if (v245 != v246)
                  {
                    if (v245 <= v246) {
                      goto LABEL_239;
                    }
                    break;
                  }
                }
LABEL_250:
                unint64_t v231 = v224;
LABEL_251:
                *(void *)unint64_t v231 = v229;
                *(void *)(v231 + 8) = v225;
                *(_OWORD *)(v231 + 16) = v491;
                *(_DWORD *)(v231 + 32) = v501;
                goto LABEL_252;
              }
              if (!v237) {
                goto LABEL_250;
              }
            }
            else if ((uint64_t)(*(void *)(v225 + 24) << -(char)v234) >> -(char)v234 >= (uint64_t)(*v233 << -(char)v234) >> -(char)v234)
            {
              goto LABEL_250;
            }
LABEL_239:
            long long v235 = *(_OWORD *)(v224 - 24);
            *(_OWORD *)unint64_t v224 = *(_OWORD *)(v224 - 40);
            *(_OWORD *)(v224 + 16) = v235;
            *(_DWORD *)(v224 + 32) = *(_DWORD *)(v224 - 8);
            v224 -= 40;
            if (v224 == v10)
            {
              unint64_t v231 = v10;
              goto LABEL_251;
            }
          }
        }
        return result;
      }
      if (v222) {
        return result;
      }
      while (2)
      {
        unint64_t v393 = v9;
        unint64_t v9 = v220;
        uint64_t v394 = *(void *)(v393 + 48);
        uint64_t v395 = *(void *)(v393 + 8);
        uint64_t v396 = (void *)(v395 + 24);
        uint64_t v397 = *(unsigned int *)(v394 + 32);
        if (v397 <= 0x40)
        {
          if ((uint64_t)(*(void *)(v394 + 24) << -(char)v397) >> -(char)v397 < (uint64_t)(*v396 << -(char)v397) >> -(char)v397)
          {
LABEL_387:
            uint64_t v398 = *(void *)v9;
            long long v494 = *(_OWORD *)(v393 + 56);
            uint64_t v504 = *(void *)(v393 + 72);
            unint64_t v399 = v9;
            while (1)
            {
LABEL_388:
              while (1)
              {
                unint64_t v400 = v399;
                unint64_t v399 = v393;
                long long v401 = *(_OWORD *)(v393 + 16);
                *(_OWORD *)unint64_t v400 = *(_OWORD *)v393;
                *(_OWORD *)(v400 + 16) = v401;
                *(_DWORD *)(v400 + 32) = *(_DWORD *)(v393 + 32);
                v393 -= 40;
                uint64_t v402 = *(void *)(v399 - 32);
                int v403 = (void *)(v402 + 24);
                uint64_t v404 = *(unsigned int *)(v394 + 32);
                if (v404 > 0x40) {
                  break;
                }
                if ((uint64_t)(*(void *)(v394 + 24) << -(char)v404) >> -(char)v404 >= (uint64_t)(*v403 << -(char)v404) >> -(char)v404) {
                  goto LABEL_400;
                }
              }
              uint64_t v405 = *(void *)(v394 + 24);
              uint64_t v406 = *(void *)(v405 + 8 * ((v404 - 1) >> 6)) & (1 << (v404 - 1));
              __n128 result = v406 != 0;
              unsigned int v407 = *(_DWORD *)(v402 + 32);
              unsigned int v408 = v407 - 1;
              uint64_t v409 = *(void *)(v402 + 24);
              if (v407 >= 0x41) {
                int v403 = (void *)(v409 + 8 * (v408 >> 6));
              }
              if (result == ((*v403 >> v408) & 1)) {
                break;
              }
              if (!v406) {
                goto LABEL_400;
              }
            }
            unint64_t v410 = v404 + 63;
            uint64_t v411 = v409 - 8;
            uint64_t v412 = (v410 >> 3) & 0x3FFFFFF8;
            uint64_t v413 = v405 - 8;
            while (v412)
            {
              unint64_t v414 = *(void *)(v413 + v412);
              unint64_t v415 = *(void *)(v411 + v412);
              v412 -= 8;
              if (v414 != v415)
              {
                if (v414 <= v415) {
                  goto LABEL_388;
                }
                break;
              }
            }
LABEL_400:
            *(void *)unint64_t v399 = v398;
            *(void *)(v399 + 8) = v394;
            *(_OWORD *)(v399 + 16) = v494;
            *(_DWORD *)(v399 + 32) = v504;
          }
        }
        else
        {
          uint64_t v416 = *(void *)(v394 + 24);
          uint64_t v417 = *(void *)(v416 + 8 * ((v397 - 1) >> 6)) & (1 << (v397 - 1));
          unsigned int v418 = *(_DWORD *)(v395 + 32);
          __n128 result = v418 - 1;
          uint64_t v419 = *(void *)(v395 + 24);
          if (v418 >= 0x41) {
            uint64_t v396 = (void *)(v419 + 8 * (result >> 6));
          }
          if ((v417 != 0) == ((*v396 >> (v418 - 1)) & 1))
          {
            unint64_t v420 = v397 + 63;
            uint64_t v421 = v419 - 8;
            uint64_t v422 = (v420 >> 3) & 0x3FFFFFF8;
            uint64_t v423 = v416 - 8;
            while (v422)
            {
              unint64_t v424 = *(void *)(v423 + v422);
              unint64_t v425 = *(void *)(v421 + v422);
              v422 -= 8;
              if (v424 != v425)
              {
                if (v424 <= v425) {
                  goto LABEL_387;
                }
                break;
              }
            }
          }
          else if (v417)
          {
            goto LABEL_387;
          }
        }
        unint64_t v220 = v9 + 40;
        if (v9 + 40 == a2) {
          return result;
        }
        continue;
      }
    }
    if (!a3)
    {
      if (v10 == a2) {
        return result;
      }
      int64_t v257 = (unint64_t)(v12 - 2) >> 1;
      int64_t v258 = v257;
      while (2)
      {
        int64_t v259 = v258;
        if (v257 < v258) {
          goto LABEL_305;
        }
        uint64_t v260 = (2 * v258) | 1;
        unint64_t v261 = v10 + 40 * v260;
        if (2 * v259 + 2 < v12)
        {
          uint64_t v262 = *(void *)(v10 + 40 * v260 + 8);
          uint64_t v263 = *(void *)(v261 + 48);
          unsigned int v264 = (void *)(v263 + 24);
          uint64_t v265 = *(unsigned int *)(v262 + 32);
          if (v265 > 0x40)
          {
            uint64_t v311 = *(void *)(v262 + 24);
            uint64_t v312 = *(void *)(v311 + 8 * ((v265 - 1) >> 6)) & (1 << (v265 - 1));
            unsigned int v313 = *(_DWORD *)(v263 + 32);
            unsigned int v314 = v313 - 1;
            uint64_t v315 = *(void *)(v263 + 24);
            if (v313 >= 0x41) {
              unsigned int v264 = (void *)(v315 + 8 * (v314 >> 6));
            }
            if ((v312 != 0) == ((*v264 >> v314) & 1))
            {
              unint64_t v322 = v265 + 63;
              uint64_t v323 = v315 - 8;
              uint64_t v324 = (v322 >> 3) & 0x3FFFFFF8;
              uint64_t v325 = v311 - 8;
              do
              {
                if (!v324) {
                  goto LABEL_271;
                }
                unint64_t v326 = *(void *)(v325 + v324);
                unint64_t v327 = *(void *)(v323 + v324);
                v324 -= 8;
              }
              while (v326 == v327);
              if (v326 > v327) {
                goto LABEL_271;
              }
            }
            else if (!v312)
            {
              goto LABEL_271;
            }
LABEL_270:
            v261 += 40;
            uint64_t v260 = 2 * v259 + 2;
            goto LABEL_271;
          }
          if ((uint64_t)(*(void *)(v262 + 24) << -(char)v265) >> -(char)v265 < (uint64_t)(*v264 << -(char)v265) >> -(char)v265) {
            goto LABEL_270;
          }
        }
LABEL_271:
        uint64_t v266 = *(void *)(v261 + 8);
        uint64_t v267 = *(void *)(v10 + 40 * v259 + 8);
        uint64_t v268 = (void *)(v267 + 24);
        uint64_t v269 = *(unsigned int *)(v266 + 32);
        if (v269 > 0x40)
        {
          uint64_t v305 = *(void *)(v266 + 24);
          uint64_t v306 = *(void *)(v305 + 8 * ((v269 - 1) >> 6)) & (1 << (v269 - 1));
          unsigned int v307 = *(_DWORD *)(v267 + 32);
          unsigned int v308 = v307 - 1;
          uint64_t v309 = *(void *)(v267 + 24);
          if (v307 >= 0x41) {
            BOOL v310 = (void *)(v309 + 8 * (v308 >> 6));
          }
          else {
            BOOL v310 = (void *)(v267 + 24);
          }
          if ((v306 != 0) == ((*v310 >> v308) & 1))
          {
            unint64_t v316 = v269 + 63;
            uint64_t v317 = v309 - 8;
            uint64_t v318 = (v316 >> 3) & 0x3FFFFFF8;
            uint64_t v319 = v305 - 8;
            do
            {
              if (!v318) {
                goto LABEL_273;
              }
              unint64_t v320 = *(void *)(v319 + v318);
              unint64_t v321 = *(void *)(v317 + v318);
              v318 -= 8;
            }
            while (v320 == v321);
            if (v320 <= v321) {
              goto LABEL_305;
            }
          }
          else if (v306)
          {
            goto LABEL_305;
          }
        }
        else if ((uint64_t)(*(void *)(v266 + 24) << -(char)v269) >> -(char)v269 < (uint64_t)(*v268 << -(char)v269) >> -(char)v269)
        {
          goto LABEL_305;
        }
LABEL_273:
        unint64_t v270 = v10 + 40 * v259;
        uint64_t v271 = *(void *)v270;
        uint64_t v502 = *(void *)(v270 + 32);
        long long v492 = *(_OWORD *)(v270 + 16);
LABEL_274:
        long long v272 = *(_OWORD *)v261;
        long long v273 = *(_OWORD *)(v261 + 16);
        *(_DWORD *)(v270 + 32) = *(_DWORD *)(v261 + 32);
        *(_OWORD *)unint64_t v270 = v272;
        *(_OWORD *)(v270 + 16) = v273;
        if (v257 < v260) {
          goto LABEL_304;
        }
        unint64_t v270 = v261;
        uint64_t v274 = 2 * v260;
        uint64_t v260 = (2 * v260) | 1;
        unint64_t v261 = v10 + 40 * v260;
        uint64_t v275 = v274 + 2;
        if (v275 < v12)
        {
          uint64_t v276 = *(void *)(v10 + 40 * v260 + 8);
          uint64_t v277 = *(void *)(v261 + 48);
          uint64_t v278 = (void *)(v277 + 24);
          uint64_t v279 = *(unsigned int *)(v276 + 32);
          if (v279 > 0x40)
          {
            uint64_t v288 = *(void *)(v276 + 24);
            uint64_t v289 = *(void *)(v288 + 8 * ((v279 - 1) >> 6)) & (1 << (v279 - 1));
            unsigned int v290 = *(_DWORD *)(v277 + 32);
            unsigned int v291 = v290 - 1;
            uint64_t v292 = *(void *)(v277 + 24);
            if (v290 >= 0x41) {
              uint64_t v278 = (void *)(v292 + 8 * (v291 >> 6));
            }
            if ((v289 != 0) == ((*v278 >> v291) & 1))
            {
              unint64_t v299 = v279 + 63;
              uint64_t v300 = v292 - 8;
              uint64_t v301 = (v299 >> 3) & 0x3FFFFFF8;
              uint64_t v302 = v288 - 8;
              do
              {
                if (!v301) {
                  goto LABEL_279;
                }
                unint64_t v303 = *(void *)(v302 + v301);
                unint64_t v304 = *(void *)(v300 + v301);
                v301 -= 8;
              }
              while (v303 == v304);
              if (v303 > v304) {
                goto LABEL_279;
              }
            }
            else if (!v289)
            {
              goto LABEL_279;
            }
LABEL_278:
            v261 += 40;
            uint64_t v260 = v275;
            goto LABEL_279;
          }
          if ((uint64_t)(*(void *)(v276 + 24) << -(char)v279) >> -(char)v279 < (uint64_t)(*v278 << -(char)v279) >> -(char)v279) {
            goto LABEL_278;
          }
        }
LABEL_279:
        uint64_t v280 = *(void *)(v261 + 8);
        uint64_t v281 = *(unsigned int *)(v280 + 32);
        if (v281 > 0x40)
        {
          uint64_t v282 = *(void *)(v280 + 24);
          uint64_t v283 = *(void *)(v282 + 8 * ((v281 - 1) >> 6)) & (1 << (v281 - 1));
          unsigned int v284 = *(_DWORD *)(v267 + 32);
          unsigned int v285 = v284 - 1;
          uint64_t v286 = *(void *)(v267 + 24);
          if (v284 >= 0x41) {
            uint64_t v287 = (void *)(v286 + 8 * (v285 >> 6));
          }
          else {
            uint64_t v287 = (void *)(v267 + 24);
          }
          if ((v283 != 0) == ((*v287 >> v285) & 1))
          {
            unint64_t v293 = v281 + 63;
            uint64_t v294 = v286 - 8;
            uint64_t v295 = (v293 >> 3) & 0x3FFFFFF8;
            uint64_t v296 = v282 - 8;
            do
            {
              if (!v295) {
                goto LABEL_274;
              }
              unint64_t v297 = *(void *)(v296 + v295);
              unint64_t v298 = *(void *)(v294 + v295);
              v295 -= 8;
            }
            while (v297 == v298);
            if (v297 <= v298)
            {
LABEL_303:
              unint64_t v261 = v270;
LABEL_304:
              *(void *)unint64_t v261 = v271;
              *(void *)(v261 + 8) = v267;
              *(_OWORD *)(v261 + 16) = v492;
              *(_DWORD *)(v261 + 32) = v502;
LABEL_305:
              int64_t v258 = v259 - 1;
              if (v259) {
                continue;
              }
              while (2)
              {
                int64_t v328 = 0;
                uint64_t v509 = *(void *)(v10 + 32);
                long long v493 = *(_OWORD *)v10;
                long long v503 = *(_OWORD *)(v10 + 16);
                unint64_t v329 = v10;
LABEL_329:
                unint64_t v330 = v329;
                int64_t v331 = v328 + 1;
                v329 += 40 * (v328 + 1);
                uint64_t v332 = 2 * v328;
                __n128 result = (2 * v328) | 1;
                int64_t v328 = result;
                int64_t v333 = v332 + 2;
                if (v333 < v12)
                {
                  uint64_t v334 = *(void *)(v330 + 40 * v331 + 8);
                  uint64_t v335 = *(void *)(v329 + 48);
                  int v336 = (void *)(v335 + 24);
                  uint64_t v337 = *(unsigned int *)(v334 + 32);
                  if (v337 > 0x40)
                  {
                    uint64_t v341 = *(void *)(v334 + 24);
                    uint64_t v342 = *(void *)(v341 + 8 * ((v337 - 1) >> 6)) & (1 << (v337 - 1));
                    unsigned int v343 = *(_DWORD *)(v335 + 32);
                    unsigned int v344 = v343 - 1;
                    uint64_t v345 = *(void *)(v335 + 24);
                    if (v343 >= 0x41) {
                      int v336 = (void *)(v345 + 8 * (v344 >> 6));
                    }
                    __n128 result = (*v336 >> v344) & 1;
                    if ((v342 != 0) == result)
                    {
                      unint64_t v346 = v337 + 63;
                      uint64_t v347 = v345 - 8;
                      __n128 result = (v346 >> 3) & 0x3FFFFFF8;
                      uint64_t v348 = v341 - 8;
                      while (result)
                      {
                        unint64_t v349 = *(void *)(v348 + result);
                        unint64_t v350 = *(void *)(v347 + result);
                        result -= 8;
                        if (v349 != v350)
                        {
                          if (v349 <= v350) {
                            goto LABEL_332;
                          }
                          break;
                        }
                      }
                    }
                    else if (v342)
                    {
LABEL_332:
                      v329 += 40;
                      int64_t v328 = v333;
                    }
                  }
                  else
                  {
                    uint64_t v338 = -v337;
                    __n128 result = *v336 << v338;
                    if ((uint64_t)(*(void *)(v334 + 24) << v338) >> v338 < result >> v338) {
                      goto LABEL_332;
                    }
                  }
                }
                long long v339 = *(_OWORD *)v329;
                long long v340 = *(_OWORD *)(v329 + 16);
                *(_DWORD *)(v330 + 32) = *(_DWORD *)(v329 + 32);
                *(_OWORD *)unint64_t v330 = v339;
                *(_OWORD *)(v330 + 16) = v340;
                if (v328 > (uint64_t)((unint64_t)(v12 - 2) >> 1))
                {
                  a2 -= 40;
                  if (v329 == a2)
                  {
                    *(_DWORD *)(v329 + 32) = v509;
                    *(_OWORD *)unint64_t v329 = v493;
                    *(_OWORD *)(v329 + 16) = v503;
                    goto LABEL_368;
                  }
                  long long v351 = *(_OWORD *)a2;
                  long long v352 = *(_OWORD *)(a2 + 16);
                  *(_DWORD *)(v329 + 32) = *(_DWORD *)(a2 + 32);
                  *(_OWORD *)unint64_t v329 = v351;
                  *(_OWORD *)(v329 + 16) = v352;
                  *(_DWORD *)(a2 + 32) = v509;
                  *(_OWORD *)a2 = v493;
                  *(_OWORD *)(a2 + 16) = v503;
                  uint64_t v353 = v329 - v10 + 40;
                  if (v353 >= 41)
                  {
                    __n128 result = v353 / 0x28uLL - 2;
                    unint64_t v354 = (unint64_t)result >> 1;
                    uint64_t v355 = *(void *)(v10 + 40 * ((unint64_t)result >> 1) + 8);
                    uint64_t v356 = *(void *)(v329 + 8);
                    uint64_t v357 = (void *)(v356 + 24);
                    uint64_t v358 = *(unsigned int *)(v355 + 32);
                    if (v358 > 0x40)
                    {
                      uint64_t v381 = *(void *)(v355 + 24);
                      uint64_t v382 = *(void *)(v381 + 8 * ((v358 - 1) >> 6)) & (1 << (v358
                                                                                                - 1));
                      unsigned int v383 = *(_DWORD *)(v356 + 32);
                      unsigned int v384 = v383 - 1;
                      uint64_t v385 = *(void *)(v356 + 24);
                      if (v383 >= 0x41) {
                        unint64_t v386 = (void *)(v385 + 8 * (v384 >> 6));
                      }
                      else {
                        unint64_t v386 = (void *)(v356 + 24);
                      }
                      if ((v382 != 0) == ((*v386 >> v384) & 1))
                      {
                        unint64_t v387 = v358 + 63;
                        uint64_t v388 = v385 - 8;
                        uint64_t v389 = (v387 >> 3) & 0x3FFFFFF8;
                        uint64_t v390 = v381 - 8;
                        while (v389)
                        {
                          unint64_t v391 = *(void *)(v390 + v389);
                          unint64_t v392 = *(void *)(v388 + v389);
                          v389 -= 8;
                          if (v391 != v392)
                          {
                            if (v391 <= v392) {
                              goto LABEL_350;
                            }
                            break;
                          }
                        }
                      }
                      else if (v382)
                      {
LABEL_350:
                        uint64_t v359 = *(void *)v329;
                        uint64_t v486 = *(void *)(v329 + 32);
                        long long v483 = *(_OWORD *)(v329 + 16);
                        unint64_t v360 = v10 + 40 * v354;
                        long long v361 = *(_OWORD *)v360;
                        long long v362 = *(_OWORD *)(v360 + 16);
                        *(_DWORD *)(v329 + 32) = *(_DWORD *)(v360 + 32);
                        *(_OWORD *)unint64_t v329 = v361;
                        *(_OWORD *)(v329 + 16) = v362;
                        if ((unint64_t)result >= 2)
                        {
                          while (1)
                          {
                            unint64_t v363 = v354 - 1;
                            unint64_t v354 = (v354 - 1) >> 1;
                            uint64_t v364 = *(void *)(v10 + 40 * v354 + 8);
                            uint64_t v365 = *(unsigned int *)(v364 + 32);
                            if (v365 > 0x40)
                            {
                              uint64_t v368 = *(void *)(v364 + 24);
                              uint64_t v369 = *(void *)(v368 + 8 * ((v365 - 1) >> 6)) & (1 << (v365 - 1));
                              unsigned int v370 = *(_DWORD *)(v356 + 32);
                              unsigned int v371 = v370 - 1;
                              uint64_t v372 = *(void *)(v356 + 24);
                              if (v370 >= 0x41) {
                                uint64_t v373 = (void *)(v372 + 8 * (v371 >> 6));
                              }
                              else {
                                uint64_t v373 = (void *)(v356 + 24);
                              }
                              if ((v369 != 0) == ((*v373 >> v371) & 1))
                              {
                                unint64_t v374 = v365 + 63;
                                uint64_t v375 = v372 - 8;
                                uint64_t v376 = (v374 >> 3) & 0x3FFFFFF8;
                                uint64_t v377 = v368 - 8;
                                while (v376)
                                {
                                  unint64_t v378 = *(void *)(v377 + v376);
                                  unint64_t v379 = *(void *)(v375 + v376);
                                  v376 -= 8;
                                  if (v378 != v379)
                                  {
                                    if (v378 <= v379) {
                                      goto LABEL_355;
                                    }
                                    goto LABEL_351;
                                  }
                                }
                                break;
                              }
                              if (!v369) {
                                break;
                              }
                            }
                            else if ((uint64_t)(*(void *)(v364 + 24) << -(char)v365) >> -(char)v365 >= (uint64_t)(*v357 << -(char)v365) >> -(char)v365)
                            {
                              break;
                            }
LABEL_355:
                            __n128 result = v10 + 40 * v354;
                            long long v366 = *(_OWORD *)result;
                            long long v367 = *(_OWORD *)(result + 16);
                            *(_DWORD *)(v360 + 32) = *(_DWORD *)(result + 32);
                            *(_OWORD *)unint64_t v360 = v366;
                            *(_OWORD *)(v360 + 16) = v367;
                            unint64_t v360 = result;
                            if (v363 <= 1) {
                              goto LABEL_352;
                            }
                          }
                        }
LABEL_351:
                        __n128 result = v360;
LABEL_352:
                        *(void *)__n128 result = v359;
                        *(void *)(result + 8) = v356;
                        *(_OWORD *)(result + 16) = v483;
                        *(_DWORD *)(result + 32) = v486;
                      }
                    }
                    else if ((uint64_t)(*(void *)(v355 + 24) << -(char)v358) >> -(char)v358 < (uint64_t)(*v357 << -(char)v358) >> -(char)v358)
                    {
                      goto LABEL_350;
                    }
                  }
LABEL_368:
                  if (v12-- <= 2) {
                    return result;
                  }
                  continue;
                }
                goto LABEL_329;
              }
            }
          }
          else if (v283)
          {
            goto LABEL_303;
          }
        }
        else if ((uint64_t)(*(void *)(v280 + 24) << -(char)v281) >> -(char)v281 < (uint64_t)(*v268 << -(char)v281) >> -(char)v281)
        {
          goto LABEL_303;
        }
        goto LABEL_274;
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    unint64_t v14 = v10 + 40 * ((unint64_t)v12 >> 1);
    if ((unint64_t)v11 >= 0x1401)
    {
      sub_1CC4982F0((long long *)v9, (long long *)(v9 + 40 * ((unint64_t)v12 >> 1)), (long long *)(a2 - 40));
      uint64_t v15 = 5 * v13;
      uint64_t v16 = (long long *)(v9 + 40 * v13 - 40);
      sub_1CC4982F0((long long *)(v9 + 40), v16, (long long *)(a2 - 80));
      int v17 = (long long *)(v9 + 40 + 8 * v15);
      sub_1CC4982F0((long long *)(v9 + 80), v17, (long long *)(a2 - 120));
      __n128 result = (uint64_t)sub_1CC4982F0(v16, (long long *)v14, v17);
      uint64_t v505 = *(void *)(v9 + 32);
      long long v487 = *(_OWORD *)v9;
      long long v495 = *(_OWORD *)(v9 + 16);
      long long v18 = *(_OWORD *)v14;
      long long v19 = *(_OWORD *)(v14 + 16);
      *(_DWORD *)(v9 + 32) = *(_DWORD *)(v14 + 32);
      *(_OWORD *)unint64_t v9 = v18;
      *(_OWORD *)(v9 + 16) = v19;
      *(_DWORD *)(v14 + 32) = v505;
      *(_OWORD *)unint64_t v14 = v487;
      *(_OWORD *)(v14 + 16) = v495;
    }
    else
    {
      __n128 result = (uint64_t)sub_1CC4982F0((long long *)(v9 + 40 * ((unint64_t)v12 >> 1)), (long long *)v9, (long long *)(a2 - 40));
    }
    --a3;
    if (a4)
    {
      uint64_t v20 = *(void *)(v9 + 8);
    }
    else
    {
      uint64_t v21 = *(void *)(v9 - 32);
      uint64_t v20 = *(void *)(v9 + 8);
      uint64_t v22 = (uint64_t *)(v20 + 24);
      uint64_t v23 = *(unsigned int *)(v21 + 32);
      if (v23 > 0x40)
      {
        uint64_t v158 = *(void *)(v21 + 24);
        uint64_t v159 = *(void *)(v158 + 8 * ((v23 - 1) >> 6)) & (1 << (v23 - 1));
        unsigned int v104 = *(_DWORD *)(v20 + 32);
        uint64_t v26 = *(void *)(v20 + 24);
        unsigned int v160 = (void *)(v26 + 8 * ((v104 - 1) >> 6));
        if (v104 < 0x41) {
          unsigned int v160 = (void *)(v20 + 24);
        }
        if ((v159 != 0) == ((*v160 >> (v104 - 1)) & 1))
        {
          unint64_t v161 = ((unint64_t)(v23 + 63) >> 3) & 0x3FFFFFF8;
          uint64_t v162 = v158 - 8;
          do
          {
            if (!v161) {
              goto LABEL_108;
            }
            unint64_t v163 = *(void *)(v162 + v161);
            unint64_t v164 = *(void *)(v26 + v161 - 8);
            v161 -= 8;
          }
          while (v163 == v164);
          if (v163 > v164) {
            goto LABEL_108;
          }
        }
        else if (!v159)
        {
          goto LABEL_108;
        }
      }
      else
      {
        uint64_t v24 = -v23;
        uint64_t v25 = (uint64_t)(*(void *)(v21 + 24) << v24) >> v24;
        uint64_t v26 = *v22;
        if (v25 >= *v22 << v24 >> v24)
        {
          unsigned int v104 = *(_DWORD *)(v20 + 32);
LABEL_108:
          uint64_t v105 = *(void *)v9;
          long long v482 = *(_OWORD *)(v9 + 16);
          uint64_t v485 = *(void *)(v9 + 32);
          uint64_t v106 = *(void *)(a2 - 32);
          unint64_t v107 = (void *)(v106 + 24);
          if (v104 > 0x40)
          {
            uint64_t v165 = *(void *)(v26 + 8 * ((v104 - 1) >> 6)) & (1 << (v104 - 1));
            __n128 result = *(unsigned int *)(v106 + 32);
            unsigned int v166 = result - 1;
            uint64_t v167 = *(void *)(v106 + 24);
            if (result >= 0x41) {
              unint64_t v107 = (void *)(v167 + 8 * (v166 >> 6));
            }
            if ((v165 != 0) == ((*v107 >> v166) & 1))
            {
              unint64_t v180 = (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8;
              while (v180)
              {
                unint64_t v181 = *(void *)(v26 - 8 + v180);
                __n128 result = *(void *)(v167 - 8 + v180);
                v180 -= 8;
                if (v181 != result)
                {
                  if (v181 <= result) {
                    goto LABEL_110;
                  }
                  break;
                }
              }
            }
            else if (v165)
            {
              goto LABEL_110;
            }
          }
          else if (v26 << -(char)v104 >> -(char)v104 < (uint64_t)(*v107 << -(char)v104) >> -(char)v104)
          {
LABEL_110:
            uint64_t v108 = (v104 - 1) >> 6;
            uint64_t v109 = 1 << (v104 - 1);
            __n128 result = (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8;
            unint64_t v10 = v9;
            do
            {
LABEL_111:
              while (1)
              {
                uint64_t v110 = *(void *)(v10 + 48);
                v10 += 40;
                unsigned int v111 = (void *)(v110 + 24);
                if (v104 <= 0x40) {
                  break;
                }
                unsigned int v112 = *(_DWORD *)(v110 + 32);
                unsigned int v113 = v112 - 1;
                uint64_t v114 = *(void *)(v110 + 24);
                if (v112 >= 0x41) {
                  unsigned int v111 = (void *)(v114 + 8 * (v113 >> 6));
                }
                if ((((*(void *)(v26 + 8 * v108) & v109) != 0) ^ (*v111 >> v113)))
                {
                  if ((*(void *)(v26 + 8 * v108) & v109) != 0) {
                    goto LABEL_123;
                  }
                }
                else
                {
                  uint64_t v115 = v114 - 8;
                  unint64_t v116 = (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8;
                  while (v116)
                  {
                    unint64_t v117 = *(void *)(v26 - 8 + v116);
                    unint64_t v118 = *(void *)(v115 + v116);
                    v116 -= 8;
                    if (v117 != v118)
                    {
                      if (v117 <= v118) {
                        goto LABEL_123;
                      }
                      goto LABEL_111;
                    }
                  }
                }
              }
            }
            while (v26 << -(char)v104 >> -(char)v104 >= (uint64_t)(*v111 << (64 - v104)) >> (64 - v104));
LABEL_123:
            unint64_t v119 = a2;
            if (v10 >= a2) {
              goto LABEL_164;
            }
            uint64_t v120 = (v104 - 1) >> 6;
            uint64_t v121 = 1 << (v104 - 1);
            __n128 result = v26 << -(char)v104 >> -(char)v104;
            for (unint64_t i = a2; ; i -= 40)
            {
              unint64_t v119 = i - 40;
              uint64_t v123 = (void *)(v106 + 24);
              if (v104 > 0x40)
              {
                unsigned int v124 = *(_DWORD *)(v106 + 32);
                unsigned int v125 = v124 - 1;
                uint64_t v126 = *(void *)(v106 + 24);
                if (v124 >= 0x41) {
                  uint64_t v123 = (void *)(v126 + 8 * (v125 >> 6));
                }
                if (((((*(void *)(v26 + 8 * v120) & v121) != 0) ^ (*v123 >> v125)) & 1) == 0)
                {
                  uint64_t v127 = v126 - 8;
                  unint64_t v128 = (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8;
                  while (v128)
                  {
                    unint64_t v129 = *(void *)(v26 + v128 - 8);
                    unint64_t v130 = *(void *)(v127 + v128);
                    v128 -= 8;
                    if (v129 != v130)
                    {
                      if (v129 <= v130) {
                        goto LABEL_127;
                      }
                      break;
                    }
                  }
LABEL_164:
                  while (v10 < v119)
                  {
                    uint64_t v506 = *(void *)(v10 + 32);
                    long long v488 = *(_OWORD *)v10;
                    long long v497 = *(_OWORD *)(v10 + 16);
                    long long v131 = *(_OWORD *)v119;
                    long long v132 = *(_OWORD *)(v119 + 16);
                    *(_DWORD *)(v10 + 32) = *(_DWORD *)(v119 + 32);
                    *(_OWORD *)unint64_t v10 = v131;
                    *(_OWORD *)(v10 + 16) = v132;
                    *(_DWORD *)(v119 + 32) = v506;
                    *(_OWORD *)unint64_t v119 = v488;
                    *(_OWORD *)(v119 + 16) = v497;
                    uint64_t v133 = *(unsigned int *)(v20 + 32);
                    uint64_t v134 = (v133 - 1) >> 6;
                    uint64_t v135 = 1 << (v133 - 1);
                    char v136 = 64 - v133;
                    do
                    {
                      while (1)
                      {
LABEL_139:
                        while (1)
                        {
                          uint64_t v137 = *(void *)(v10 + 48);
                          v10 += 40;
                          uint64_t v138 = (void *)(v137 + 24);
                          if (v133 > 0x40) {
                            break;
                          }
                          uint64_t v139 = *v22;
                          if (*v22 << v136 >> v136 < (uint64_t)(*v138 << v136) >> v136) {
                            goto LABEL_151;
                          }
                        }
                        uint64_t v139 = *v22;
                        unsigned int v140 = *(_DWORD *)(v137 + 32);
                        unsigned int v141 = v140 - 1;
                        uint64_t v142 = *(void *)(v137 + 24);
                        if (v140 >= 0x41) {
                          uint64_t v138 = (void *)(v142 + 8 * (v141 >> 6));
                        }
                        if ((((*(void *)(*v22 + 8 * v134) & v135) != 0) ^ (*v138 >> v141))) {
                          break;
                        }
                        uint64_t v143 = v142 - 8;
                        unint64_t v144 = ((unint64_t)(v133 + 63) >> 3) & 0x3FFFFFF8;
                        while (v144)
                        {
                          unint64_t v145 = *(void *)(v139 + v144 - 8);
                          unint64_t v146 = *(void *)(v143 + v144);
                          v144 -= 8;
                          if (v145 != v146)
                          {
                            if (v145 > v146) {
                              goto LABEL_139;
                            }
                            goto LABEL_151;
                          }
                        }
                      }
                    }
                    while ((*(void *)(*v22 + 8 * v134) & v135) == 0);
LABEL_151:
                    __n128 result = v139 << v136 >> v136;
                    while (1)
                    {
LABEL_152:
                      while (1)
                      {
                        uint64_t v147 = *(void *)(v119 - 32);
                        v119 -= 40;
                        unint64_t v148 = (void *)(v147 + 24);
                        if (v133 > 0x40) {
                          break;
                        }
                        if (result >= (uint64_t)(*v148 << v136) >> v136) {
                          goto LABEL_164;
                        }
                      }
                      unsigned int v149 = *(_DWORD *)(v147 + 32);
                      unsigned int v150 = v149 - 1;
                      uint64_t v151 = *(void *)(v147 + 24);
                      if (v149 >= 0x41) {
                        unint64_t v148 = (void *)(v151 + 8 * (v150 >> 6));
                      }
                      if (((((*(void *)(v139 + 8 * v134) & v135) != 0) ^ (*v148 >> v150)) & 1) == 0) {
                        break;
                      }
                      if ((*(void *)(v139 + 8 * v134) & v135) == 0) {
                        goto LABEL_164;
                      }
                    }
                    uint64_t v152 = v151 - 8;
                    unint64_t v153 = ((unint64_t)(v133 + 63) >> 3) & 0x3FFFFFF8;
                    while (v153)
                    {
                      unint64_t v154 = *(void *)(v139 - 8 + v153);
                      unint64_t v155 = *(void *)(v152 + v153);
                      v153 -= 8;
                      if (v154 != v155)
                      {
                        if (v154 <= v155) {
                          goto LABEL_152;
                        }
                        goto LABEL_164;
                      }
                    }
                  }
                  BOOL v4 = v10 - 40 >= v9;
                  BOOL v5 = v10 - 40 == v9;
                  if (v10 - 40 != v9)
                  {
                    long long v156 = *(_OWORD *)(v10 - 40);
                    long long v157 = *(_OWORD *)(v10 - 24);
                    *(_DWORD *)(v9 + 32) = *(_DWORD *)(v10 - 8);
                    *(_OWORD *)unint64_t v9 = v156;
                    *(_OWORD *)(v9 + 16) = v157;
                  }
                  a4 = 0;
                  *(void *)(v10 - 40) = v105;
                  *(void *)(v10 - 32) = v20;
                  *(_DWORD *)(v10 - 8) = v485;
                  *(_OWORD *)(v10 - 24) = v482;
                  goto LABEL_3;
                }
                if ((*(void *)(v26 + 8 * v120) & v121) == 0) {
                  goto LABEL_164;
                }
              }
              else if (result >= (uint64_t)(*v123 << (64 - v104)) >> (64 - v104))
              {
                goto LABEL_164;
              }
LABEL_127:
              uint64_t v106 = *(void *)(i - 72);
            }
          }
          unint64_t v10 = v9 + 40;
          if (v9 + 40 < a2)
          {
            uint64_t v168 = (v104 - 1) >> 6;
            uint64_t v169 = 1 << (v104 - 1);
            __n128 result = (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8;
            unint64_t v170 = v9;
            while (1)
            {
              uint64_t v171 = *(void *)(v170 + 48);
              unint64_t v170 = v10;
              uint64_t v172 = (void *)(v171 + 24);
              if (v104 > 0x40)
              {
                unsigned int v173 = *(_DWORD *)(v171 + 32);
                unsigned int v174 = v173 - 1;
                uint64_t v175 = *(void *)(v171 + 24);
                if (v173 >= 0x41) {
                  uint64_t v172 = (void *)(v175 + 8 * (v174 >> 6));
                }
                if ((((*(void *)(v26 + 8 * v168) & v169) != 0) ^ (*v172 >> v174)))
                {
                  if ((*(void *)(v26 + 8 * v168) & v169) != 0) {
                    goto LABEL_123;
                  }
                }
                else
                {
                  uint64_t v176 = v175 - 8;
                  unint64_t v177 = (((unint64_t)v104 + 63) >> 3) & 0x3FFFFFF8;
                  while (v177)
                  {
                    unint64_t v178 = *(void *)(v26 + v177 - 8);
                    unint64_t v179 = *(void *)(v176 + v177);
                    v177 -= 8;
                    if (v178 != v179)
                    {
                      if (v178 > v179) {
                        break;
                      }
                      goto LABEL_123;
                    }
                  }
                }
              }
              else if (v26 << -(char)v104 >> -(char)v104 < (uint64_t)(*v172 << (64 - v104)) >> (64 - v104))
              {
                goto LABEL_123;
              }
              v10 += 40;
              if (v170 + 40 >= a2) {
                goto LABEL_123;
              }
            }
          }
          goto LABEL_123;
        }
      }
    }
    uint64_t v27 = *(void *)v9;
    long long v481 = *(_OWORD *)(v9 + 16);
    uint64_t v484 = *(void *)(v9 + 32);
    unsigned int v28 = (uint64_t *)(v20 + 24);
    unint64_t v29 = v9;
    while (1)
    {
LABEL_15:
      while (1)
      {
        unint64_t v30 = v29;
        v29 += 40;
        uint64_t v31 = *(void *)(v30 + 48);
        uint64_t v32 = *(unsigned int *)(v31 + 32);
        if (v32 > 0x40) {
          break;
        }
        uint64_t v33 = -v32;
        uint64_t v34 = (uint64_t)(*(void *)(v31 + 24) << v33) >> v33;
        uint64_t v35 = *v28;
        if (v34 >= *v28 << v33 >> v33) {
          goto LABEL_28;
        }
      }
      uint64_t v36 = *(void *)(v31 + 24);
      uint64_t v37 = *(void *)(v36 + 8 * ((v32 - 1) >> 6)) & (1 << (v32 - 1));
      unsigned int v38 = *(_DWORD *)(v20 + 32);
      unsigned int v39 = v38 - 1;
      uint64_t v35 = *(void *)(v20 + 24);
      unsigned int v40 = (void *)(v38 >= 0x41 ? v35 + 8 * (v39 >> 6) : v20 + 24);
      if ((v37 != 0) == ((*v40 >> v39) & 1)) {
        break;
      }
      if (!v37) {
        goto LABEL_28;
      }
    }
    unint64_t v41 = ((unint64_t)(v32 + 63) >> 3) & 0x3FFFFFF8;
    uint64_t v42 = v36 - 8;
    while (v41)
    {
      unint64_t v43 = *(void *)(v42 + v41);
      unint64_t v44 = *(void *)(v35 + v41 - 8);
      v41 -= 8;
      if (v43 != v44)
      {
        if (v43 <= v44) {
          goto LABEL_15;
        }
        break;
      }
    }
LABEL_28:
    if (v30 == v9)
    {
      unint64_t v45 = a2;
      if (v29 < a2)
      {
        unint64_t v45 = a2;
        do
        {
LABEL_46:
          while (1)
          {
            uint64_t v57 = *(void *)(v45 - 32);
            v45 -= 40;
            uint64_t v58 = *(unsigned int *)(v57 + 32);
            if (v58 <= 0x40) {
              break;
            }
            uint64_t v59 = *(void *)(v57 + 24);
            uint64_t v60 = *(void *)(v59 + 8 * ((v58 - 1) >> 6)) & (1 << (v58 - 1));
            unsigned int v61 = *(_DWORD *)(v20 + 32);
            unsigned int v62 = v61 - 1;
            if (v61 >= 0x41) {
              unsigned int v63 = (void *)(v35 + 8 * (v62 >> 6));
            }
            else {
              unsigned int v63 = (void *)(v20 + 24);
            }
            if ((v60 != 0) == ((*v63 >> v62) & 1))
            {
              unint64_t v65 = ((unint64_t)(v58 + 63) >> 3) & 0x3FFFFFF8;
              uint64_t v66 = v59 - 8;
              do
              {
                if (!v65)
                {
                  if (v29 < v45) {
                    goto LABEL_46;
                  }
                  goto LABEL_71;
                }
                unint64_t v67 = *(void *)(v66 + v65);
                unint64_t v68 = *(void *)(v35 - 8 + v65);
                v65 -= 8;
              }
              while (v67 == v68);
              if (v67 <= v68 || v29 >= v45) {
                goto LABEL_71;
              }
            }
            else
            {
              if (v60) {
                BOOL v64 = 1;
              }
              else {
                BOOL v64 = v29 >= v45;
              }
              if (v64) {
                goto LABEL_71;
              }
            }
          }
        }
        while ((uint64_t)(*(void *)(v57 + 24) << -(char)v58) >> -(char)v58 >= v35 << -(char)v58 >> -(char)v58
             && v29 < v45);
      }
    }
    else
    {
      unint64_t v45 = a2;
      do
      {
LABEL_30:
        while (1)
        {
          uint64_t v46 = *(void *)(v45 - 32);
          v45 -= 40;
          uint64_t v47 = *(unsigned int *)(v46 + 32);
          if (v47 <= 0x40) {
            break;
          }
          uint64_t v48 = *(void *)(v46 + 24);
          uint64_t v49 = *(void *)(v48 + 8 * ((v47 - 1) >> 6)) & (1 << (v47 - 1));
          unsigned int v50 = *(_DWORD *)(v20 + 32);
          unsigned int v51 = v50 - 1;
          if (v50 >= 0x41) {
            BOOL v52 = (void *)(v35 + 8 * (v51 >> 6));
          }
          else {
            BOOL v52 = (void *)(v20 + 24);
          }
          if ((v49 != 0) == ((*v52 >> v51) & 1))
          {
            unint64_t v53 = ((unint64_t)(v47 + 63) >> 3) & 0x3FFFFFF8;
            uint64_t v54 = v48 - 8;
            while (v53)
            {
              unint64_t v55 = *(void *)(v54 + v53);
              unint64_t v56 = *(void *)(v35 - 8 + v53);
              v53 -= 8;
              if (v55 != v56)
              {
                if (v55 <= v56) {
                  goto LABEL_71;
                }
                goto LABEL_30;
              }
            }
          }
          else if (v49)
          {
            goto LABEL_71;
          }
        }
      }
      while ((uint64_t)(*(void *)(v46 + 24) << -(char)v47) >> -(char)v47 >= v35 << -(char)v47 >> -(char)v47);
    }
LABEL_71:
    unint64_t v10 = v29;
    if (v29 < v45)
    {
      unint64_t v71 = v45;
      do
      {
        long long v72 = *(_OWORD *)v10;
        long long v496 = *(_OWORD *)(v10 + 16);
        uint64_t v73 = *(void *)(v10 + 32);
        long long v75 = *(_OWORD *)v71;
        long long v74 = *(_OWORD *)(v71 + 16);
        *(_DWORD *)(v10 + 32) = *(_DWORD *)(v71 + 32);
        *(_OWORD *)unint64_t v10 = v75;
        *(_OWORD *)(v10 + 16) = v74;
        *(_DWORD *)(v71 + 32) = v73;
        *(_OWORD *)unint64_t v71 = v72;
        *(_OWORD *)(v71 + 16) = v496;
        do
        {
          while (1)
          {
            while (1)
            {
              uint64_t v76 = *(void *)(v10 + 48);
              v10 += 40;
              uint64_t v77 = *(unsigned int *)(v76 + 32);
              if (v77 > 0x40) {
                break;
              }
              uint64_t v78 = -v77;
              uint64_t v79 = (uint64_t)(*(void *)(v76 + 24) << v78) >> v78;
              uint64_t v80 = *v28;
              if (v79 >= *v28 << v78 >> v78) {
                goto LABEL_87;
              }
            }
            uint64_t v81 = *(void *)(v76 + 24);
            uint64_t v82 = *(void *)(v81 + 8 * ((v77 - 1) >> 6)) & (1 << (v77 - 1));
            unsigned int v83 = *(_DWORD *)(v20 + 32);
            unsigned int v84 = v83 - 1;
            uint64_t v80 = *(void *)(v20 + 24);
            int v85 = (void *)(v83 >= 0x41 ? v80 + 8 * (v84 >> 6) : v20 + 24);
            if ((v82 != 0) == ((*v85 >> v84) & 1)) {
              break;
            }
            if (!v82) {
              goto LABEL_87;
            }
          }
          unint64_t v86 = ((unint64_t)(v77 + 63) >> 3) & 0x3FFFFFF8;
          uint64_t v87 = v81 - 8;
          do
          {
            if (!v86) {
              goto LABEL_87;
            }
            unint64_t v88 = *(void *)(v87 + v86);
            unint64_t v89 = *(void *)(v80 + v86 - 8);
            v86 -= 8;
          }
          while (v88 == v89);
        }
        while (v88 <= v89);
        do
        {
LABEL_87:
          while (1)
          {
            uint64_t v90 = *(void *)(v71 - 32);
            v71 -= 40;
            uint64_t v91 = *(unsigned int *)(v90 + 32);
            if (v91 <= 0x40) {
              break;
            }
            uint64_t v92 = *(void *)(v90 + 24);
            uint64_t v93 = *(void *)(v92 + 8 * ((v91 - 1) >> 6)) & (1 << (v91 - 1));
            unsigned int v94 = *(_DWORD *)(v20 + 32);
            unsigned int v95 = v94 - 1;
            if (v94 >= 0x41) {
              uint64_t v96 = (void *)(v80 + 8 * (v95 >> 6));
            }
            else {
              uint64_t v96 = (void *)(v20 + 24);
            }
            if ((v93 != 0) == ((*v96 >> v95) & 1))
            {
              unint64_t v97 = ((unint64_t)(v91 + 63) >> 3) & 0x3FFFFFF8;
              uint64_t v98 = v92 - 8;
              while (v97)
              {
                unint64_t v99 = *(void *)(v98 + v97);
                unint64_t v100 = *(void *)(v80 - 8 + v97);
                v97 -= 8;
                if (v99 != v100)
                {
                  if (v99 <= v100) {
                    goto LABEL_100;
                  }
                  goto LABEL_87;
                }
              }
            }
            else if (v93)
            {
              goto LABEL_100;
            }
          }
        }
        while ((uint64_t)(*(void *)(v90 + 24) << -(char)v91) >> -(char)v91 >= v80 << -(char)v91 >> -(char)v91);
LABEL_100:
        ;
      }
      while (v10 < v71);
    }
    if (v10 - 40 != v9)
    {
      long long v101 = *(_OWORD *)(v10 - 40);
      long long v102 = *(_OWORD *)(v10 - 24);
      *(_DWORD *)(v9 + 32) = *(_DWORD *)(v10 - 8);
      *(_OWORD *)unint64_t v9 = v101;
      *(_OWORD *)(v9 + 16) = v102;
    }
    *(void *)(v10 - 40) = v27;
    *(void *)(v10 - 32) = v20;
    *(_DWORD *)(v10 - 8) = v484;
    *(_OWORD *)(v10 - 24) = v481;
    if (v29 >= v45)
    {
      BOOL v103 = sub_1CC498694(v9, v10 - 40);
      __n128 result = sub_1CC498694(v10, a2);
      if (result)
      {
        a2 = v10 - 40;
        if (v103) {
          return result;
        }
        goto LABEL_2;
      }
      if (v103) {
        continue;
      }
    }
    __n128 result = sub_1CC496558(v9, v10 - 40, a3, a4 & 1);
    a4 = 0;
  }
  switch(v12)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v182 = *(void *)(a2 - 32);
      uint64_t v183 = *(void *)(v10 + 8);
      uint64_t v184 = (void *)(v183 + 24);
      uint64_t v185 = *(unsigned int *)(v182 + 32);
      if (v185 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v182 + 24) << -(char)v185) >> -(char)v185 >= (uint64_t)(*v184 << -(char)v185) >> -(char)v185) {
          return result;
        }
        goto LABEL_208;
      }
      uint64_t v426 = *(void *)(v182 + 24);
      uint64_t v427 = *(void *)(v426 + 8 * ((v185 - 1) >> 6)) & (1 << (v185 - 1));
      unsigned int v428 = *(_DWORD *)(v183 + 32);
      unsigned int v429 = v428 - 1;
      uint64_t v430 = *(void *)(v183 + 24);
      if (v428 >= 0x41) {
        uint64_t v184 = (void *)(v430 + 8 * (v429 >> 6));
      }
      if ((v427 != 0) == ((*v184 >> v429) & 1))
      {
        unint64_t v451 = v185 + 63;
        uint64_t v452 = v430 - 8;
        uint64_t v453 = (v451 >> 3) & 0x3FFFFFF8;
        uint64_t v454 = v426 - 8;
        do
        {
          if (!v453) {
            return result;
          }
          unint64_t v455 = *(void *)(v454 + v453);
          unint64_t v456 = *(void *)(v452 + v453);
          v453 -= 8;
        }
        while (v455 == v456);
        if (v455 <= v456)
        {
LABEL_208:
          uint64_t v507 = *(void *)(v10 + 32);
          long long v489 = *(_OWORD *)v10;
          long long v498 = *(_OWORD *)(v10 + 16);
          long long v186 = *(_OWORD *)(a2 - 40);
          long long v187 = *(_OWORD *)(a2 - 24);
          *(_DWORD *)(v10 + 32) = *(_DWORD *)(a2 - 8);
          *(_OWORD *)unint64_t v10 = v186;
          *(_OWORD *)(v10 + 16) = v187;
          *(_DWORD *)(a2 - 8) = v507;
          *(_OWORD *)(a2 - 24) = v498;
          *(_OWORD *)(a2 - 40) = v489;
          return result;
        }
      }
      else if (v427)
      {
        goto LABEL_208;
      }
      return result;
    case 3:
      return (uint64_t)sub_1CC4982F0((long long *)v10, (long long *)(v10 + 40), (long long *)(a2 - 40));
    case 4:
      return (uint64_t)sub_1CC498E6C(v10, v10 + 40, v10 + 80, a2 - 40);
    case 5:
      uint64_t v188 = (long long *)(v10 + 40);
      uint64_t v189 = (long long *)(v10 + 80);
      int v190 = (long long *)(v10 + 120);
      __n128 result = (uint64_t)sub_1CC498E6C(v10, v10 + 40, v10 + 80, v10 + 120);
      uint64_t v191 = *(void *)(a2 - 32);
      uint64_t v192 = *(void *)(v10 + 128);
      uint64_t v193 = (void *)(v192 + 24);
      uint64_t v194 = *(unsigned int *)(v191 + 32);
      if (v194 > 0x40)
      {
        uint64_t v431 = *(void *)(v191 + 24);
        uint64_t v432 = *(void *)(v431 + 8 * ((v194 - 1) >> 6)) & (1 << (v194 - 1));
        unsigned int v433 = *(_DWORD *)(v192 + 32);
        unsigned int v434 = v433 - 1;
        uint64_t v435 = *(void *)(v192 + 24);
        if (v433 >= 0x41) {
          uint64_t v193 = (void *)(v435 + 8 * (v434 >> 6));
        }
        if ((v432 != 0) == ((*v193 >> v434) & 1))
        {
          unint64_t v457 = v194 + 63;
          uint64_t v458 = v435 - 8;
          uint64_t v459 = (v457 >> 3) & 0x3FFFFFF8;
          uint64_t v460 = v431 - 8;
          do
          {
            if (!v459) {
              return result;
            }
            unint64_t v461 = *(void *)(v460 + v459);
            unint64_t v462 = *(void *)(v458 + v459);
            v459 -= 8;
          }
          while (v461 == v462);
          if (v461 > v462) {
            return result;
          }
        }
        else if (!v432)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v191 + 24) << -(char)v194) >> -(char)v194 >= (uint64_t)(*v193 << -(char)v194) >> -(char)v194)
      {
        return result;
      }
      long long v195 = *v190;
      long long v499 = *(_OWORD *)(v10 + 136);
      int v196 = *(void *)(v10 + 152);
      long long v197 = *(_OWORD *)(a2 - 24);
      long long v198 = *(_OWORD *)(a2 - 40);
      *(_DWORD *)(v10 + 152) = *(_DWORD *)(a2 - 8);
      *int v190 = v198;
      *(_OWORD *)(v10 + 136) = v197;
      *(_OWORD *)(a2 - 24) = v499;
      *(_DWORD *)(a2 - 8) = v196;
      *(_OWORD *)(a2 - 40) = v195;
      uint64_t v199 = *(void *)(v10 + 128);
      uint64_t v200 = *(void *)(v10 + 88);
      int v201 = (void *)(v200 + 24);
      uint64_t v202 = *(unsigned int *)(v199 + 32);
      if (v202 > 0x40)
      {
        uint64_t v436 = *(void *)(v199 + 24);
        uint64_t v437 = *(void *)(v436 + 8 * ((v202 - 1) >> 6)) & (1 << (v202 - 1));
        unsigned int v438 = *(_DWORD *)(v200 + 32);
        unsigned int v439 = v438 - 1;
        uint64_t v440 = *(void *)(v200 + 24);
        if (v438 >= 0x41) {
          int v201 = (void *)(v440 + 8 * (v439 >> 6));
        }
        if ((v437 != 0) == ((*v201 >> v439) & 1))
        {
          unint64_t v463 = v202 + 63;
          uint64_t v464 = v440 - 8;
          uint64_t v465 = (v463 >> 3) & 0x3FFFFFF8;
          uint64_t v466 = v436 - 8;
          do
          {
            if (!v465) {
              return result;
            }
            unint64_t v467 = *(void *)(v466 + v465);
            unint64_t v468 = *(void *)(v464 + v465);
            v465 -= 8;
          }
          while (v467 == v468);
          if (v467 > v468) {
            return result;
          }
        }
        else if (!v437)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v199 + 24) << -(char)v202) >> -(char)v202 >= (uint64_t)(*v201 << -(char)v202) >> -(char)v202)
      {
        return result;
      }
      uint64_t v203 = *(void *)(v10 + 112);
      long long v205 = *v189;
      long long v204 = *(_OWORD *)(v10 + 96);
      long long v206 = *(_OWORD *)(v10 + 136);
      long long *v189 = *v190;
      *(_OWORD *)(v10 + 96) = v206;
      *(_DWORD *)(v10 + 112) = *(_DWORD *)(v10 + 152);
      *int v190 = v205;
      *(_OWORD *)(v10 + 136) = v204;
      *(_DWORD *)(v10 + 152) = v203;
      uint64_t v207 = *(void *)(v10 + 88);
      uint64_t v208 = *(void *)(v10 + 48);
      uint64_t v209 = (void *)(v208 + 24);
      uint64_t v210 = *(unsigned int *)(v207 + 32);
      if (v210 > 0x40)
      {
        uint64_t v441 = *(void *)(v207 + 24);
        uint64_t v442 = *(void *)(v441 + 8 * ((v210 - 1) >> 6)) & (1 << (v210 - 1));
        unsigned int v443 = *(_DWORD *)(v208 + 32);
        unsigned int v444 = v443 - 1;
        uint64_t v445 = *(void *)(v208 + 24);
        if (v443 >= 0x41) {
          uint64_t v209 = (void *)(v445 + 8 * (v444 >> 6));
        }
        if ((v442 != 0) == ((*v209 >> v444) & 1))
        {
          unint64_t v469 = v210 + 63;
          uint64_t v470 = v445 - 8;
          uint64_t v471 = (v469 >> 3) & 0x3FFFFFF8;
          uint64_t v472 = v441 - 8;
          do
          {
            if (!v471) {
              return result;
            }
            unint64_t v473 = *(void *)(v472 + v471);
            unint64_t v474 = *(void *)(v470 + v471);
            v471 -= 8;
          }
          while (v473 == v474);
          if (v473 > v474) {
            return result;
          }
        }
        else if (!v442)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v207 + 24) << -(char)v210) >> -(char)v210 >= (uint64_t)(*v209 << -(char)v210) >> -(char)v210)
      {
        return result;
      }
      uint64_t v211 = *(void *)(v10 + 72);
      long long v213 = *v188;
      long long v212 = *(_OWORD *)(v10 + 56);
      long long v214 = *(_OWORD *)(v10 + 96);
      long long *v188 = *v189;
      *(_OWORD *)(v10 + 56) = v214;
      *(_DWORD *)(v10 + 72) = *(_DWORD *)(v10 + 112);
      long long *v189 = v213;
      *(_OWORD *)(v10 + 96) = v212;
      *(_DWORD *)(v10 + 112) = v211;
      uint64_t v215 = *(void *)(v10 + 48);
      uint64_t v216 = *(void *)(v10 + 8);
      uint64_t v217 = (void *)(v216 + 24);
      uint64_t v218 = *(unsigned int *)(v215 + 32);
      if (v218 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v215 + 24) << -(char)v218) >> -(char)v218 >= (uint64_t)(*v217 << -(char)v218) >> -(char)v218) {
          return result;
        }
        goto LABEL_223;
      }
      uint64_t v446 = *(void *)(v215 + 24);
      uint64_t v447 = *(void *)(v446 + 8 * ((v218 - 1) >> 6)) & (1 << (v218 - 1));
      unsigned int v448 = *(_DWORD *)(v216 + 32);
      unsigned int v449 = v448 - 1;
      uint64_t v450 = *(void *)(v216 + 24);
      if (v448 >= 0x41) {
        uint64_t v217 = (void *)(v450 + 8 * (v449 >> 6));
      }
      if ((v447 != 0) == ((*v217 >> v449) & 1))
      {
        unint64_t v475 = v218 + 63;
        uint64_t v476 = v450 - 8;
        uint64_t v477 = (v475 >> 3) & 0x3FFFFFF8;
        uint64_t v478 = v446 - 8;
        do
        {
          if (!v477) {
            return result;
          }
          unint64_t v479 = *(void *)(v478 + v477);
          unint64_t v480 = *(void *)(v476 + v477);
          v477 -= 8;
        }
        while (v479 == v480);
        if (v479 <= v480)
        {
LABEL_223:
          uint64_t v508 = *(void *)(v10 + 32);
          long long v490 = *(_OWORD *)v10;
          long long v500 = *(_OWORD *)(v10 + 16);
          long long v219 = *(_OWORD *)(v10 + 56);
          *(_OWORD *)unint64_t v10 = *v188;
          *(_OWORD *)(v10 + 16) = v219;
          *(_DWORD *)(v10 + 32) = *(_DWORD *)(v10 + 72);
          long long *v188 = v490;
          *(_OWORD *)(v10 + 56) = v500;
          *(_DWORD *)(v10 + 72) = v508;
          return result;
        }
      }
      else if (v447)
      {
        goto LABEL_223;
      }
      break;
    default:
      JUMPOUT(0);
  }
  return result;
}

long long *sub_1CC4982F0(long long *result, long long *a2, long long *a3)
{
  uint64_t v3 = *((void *)a2 + 1);
  BOOL v4 = (uint64_t *)(v3 + 24);
  uint64_t v5 = *((void *)result + 1);
  BOOL v6 = (void *)(v5 + 24);
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  if (v7 > 0x40)
  {
    uint64_t v8 = *v4;
    uint64_t v9 = *(void *)(*v4 + 8 * ((v7 - 1) >> 6)) >> (v7 - 1);
    unsigned int v31 = *(_DWORD *)(v5 + 32);
    unsigned int v32 = v31 - 1;
    uint64_t v33 = *(void *)(v5 + 24);
    if (v31 >= 0x41) {
      BOOL v6 = (void *)(v33 + 8 * (v32 >> 6));
    }
    if (((v9 ^ (*v6 >> v32)) & 1) == 0)
    {
      uint64_t v34 = v33 - 8;
      unint64_t v35 = ((unint64_t)(v7 + 63) >> 3) & 0x3FFFFFF8;
      while (v35)
      {
        unint64_t v36 = *(void *)(v8 + v35 - 8);
        unint64_t v37 = *(void *)(v34 + v35);
        v35 -= 8;
        if (v36 != v37)
        {
          LOBYTE(v9) = v36 <= v37;
          goto LABEL_3;
        }
      }
      LOBYTE(v9) = 0;
    }
  }
  else
  {
    uint64_t v8 = *v4;
    LOBYTE(v9) = *v4 << -(char)v7 >> -(char)v7 < (uint64_t)(*v6 << -(char)v7) >> -(char)v7;
  }
LABEL_3:
  unint64_t v10 = *((void *)a3 + 1);
  uint64_t v11 = *(unsigned int *)(v10 + 32);
  if (v11 > 0x40)
  {
    uint64_t v38 = *(void *)(v10 + 24);
    unint64_t v10 = *(void *)(v38 + 8 * ((v11 - 1) >> 6)) >> (v11 - 1);
    unsigned int v39 = v7 - 1;
    if (v7 >= 0x41) {
      BOOL v4 = (uint64_t *)(v8 + 8 * (v39 >> 6));
    }
    if (((v10 ^ ((unint64_t)*v4 >> v39)) & 1) == 0)
    {
      uint64_t v40 = v8 - 8;
      unint64_t v41 = ((unint64_t)(v11 + 63) >> 3) & 0x3FFFFFF8;
      while (v41)
      {
        unint64_t v42 = *(void *)(v38 - 8 + v41);
        unint64_t v10 = *(void *)(v40 + v41);
        v41 -= 8;
        if (v42 != v10)
        {
          LOBYTE(v10) = v42 <= v10;
          goto LABEL_5;
        }
      }
      if ((v9 & 1) == 0) {
        return result;
      }
      goto LABEL_28;
    }
  }
  else
  {
    LOBYTE(v10) = (uint64_t)(*(void *)(v10 + 24) << -(char)v11) >> -(char)v11 < v8 << -(char)v11 >> -(char)v11;
  }
LABEL_5:
  if ((v9 & 1) == 0)
  {
    if ((v10 & 1) == 0) {
      return result;
    }
    uint64_t v17 = *((void *)a2 + 4);
    long long v18 = *a2;
    long long v19 = a2[1];
    int v20 = *((_DWORD *)a3 + 8);
    long long v21 = a3[1];
    *a2 = *a3;
    a2[1] = v21;
    *((_DWORD *)a2 + 8) = v20;
    *a3 = v18;
    a3[1] = v19;
    *((_DWORD *)a3 + 8) = v17;
    uint64_t v22 = *((void *)a2 + 1);
    uint64_t v23 = *((void *)result + 1);
    uint64_t v24 = (void *)(v23 + 24);
    uint64_t v25 = *(unsigned int *)(v22 + 32);
    if (v25 > 0x40)
    {
      uint64_t v59 = *(void *)(v22 + 24);
      uint64_t v60 = *(void *)(v59 + 8 * ((v25 - 1) >> 6)) & (1 << (v25 - 1));
      unsigned int v61 = *(_DWORD *)(v23 + 32);
      unsigned int v62 = v61 - 1;
      uint64_t v63 = *(void *)(v23 + 24);
      if (v61 >= 0x41) {
        uint64_t v24 = (void *)(v63 + 8 * (v62 >> 6));
      }
      if ((v60 != 0) == ((*v24 >> v62) & 1))
      {
        unint64_t v70 = v25 + 63;
        uint64_t v71 = v63 - 8;
        uint64_t v72 = (v70 >> 3) & 0x3FFFFFF8;
        uint64_t v73 = v59 - 8;
        while (v72)
        {
          unint64_t v74 = *(void *)(v73 + v72);
          unint64_t v75 = *(void *)(v71 + v72);
          v72 -= 8;
          if (v74 != v75)
          {
            if (v74 <= v75) {
              goto LABEL_11;
            }
            return result;
          }
        }
        return result;
      }
      if (!v60) {
        return result;
      }
    }
    else if ((uint64_t)(*(void *)(v22 + 24) << -(char)v25) >> -(char)v25 >= (uint64_t)(*v24 << -(char)v25) >> -(char)v25)
    {
      return result;
    }
LABEL_11:
    uint64_t v26 = *((void *)result + 4);
    long long v27 = *result;
    long long v28 = result[1];
    int v29 = *((_DWORD *)a2 + 8);
    long long v30 = a2[1];
    *__n128 result = *a2;
    result[1] = v30;
    *((_DWORD *)result + 8) = v29;
    *a2 = v27;
    a2[1] = v28;
    *((_DWORD *)a2 + 8) = v26;
    return result;
  }
  if (v10)
  {
    uint64_t v12 = *((void *)result + 4);
    long long v13 = *result;
    long long v14 = result[1];
    int v15 = *((_DWORD *)a3 + 8);
    long long v16 = a3[1];
    *__n128 result = *a3;
    result[1] = v16;
    *((_DWORD *)result + 8) = v15;
LABEL_31:
    *a3 = v13;
    a3[1] = v14;
    *((_DWORD *)a3 + 8) = v12;
    return result;
  }
LABEL_28:
  uint64_t v43 = *((void *)result + 4);
  long long v44 = *result;
  long long v45 = result[1];
  int v46 = *((_DWORD *)a2 + 8);
  long long v47 = a2[1];
  *__n128 result = *a2;
  result[1] = v47;
  *((_DWORD *)result + 8) = v46;
  *a2 = v44;
  a2[1] = v45;
  *((_DWORD *)a2 + 8) = v43;
  uint64_t v48 = *((void *)a3 + 1);
  uint64_t v49 = *((void *)a2 + 1);
  unsigned int v50 = (void *)(v49 + 24);
  uint64_t v51 = *(unsigned int *)(v48 + 32);
  if (v51 <= 0x40)
  {
    if ((uint64_t)(*(void *)(v48 + 24) << -(char)v51) >> -(char)v51 >= (uint64_t)(*v50 << -(char)v51) >> -(char)v51) {
      return result;
    }
    goto LABEL_30;
  }
  uint64_t v54 = *(void *)(v48 + 24);
  uint64_t v55 = *(void *)(v54 + 8 * ((v51 - 1) >> 6)) & (1 << (v51 - 1));
  unsigned int v56 = *(_DWORD *)(v49 + 32);
  unsigned int v57 = v56 - 1;
  uint64_t v58 = *(void *)(v49 + 24);
  if (v56 >= 0x41) {
    unsigned int v50 = (void *)(v58 + 8 * (v57 >> 6));
  }
  if ((v55 != 0) == ((*v50 >> v57) & 1))
  {
    unint64_t v64 = v51 + 63;
    uint64_t v65 = v58 - 8;
    uint64_t v66 = (v64 >> 3) & 0x3FFFFFF8;
    uint64_t v67 = v54 - 8;
    while (v66)
    {
      unint64_t v68 = *(void *)(v67 + v66);
      unint64_t v69 = *(void *)(v65 + v66);
      v66 -= 8;
      if (v68 != v69)
      {
        if (v68 <= v69) {
          goto LABEL_30;
        }
        return result;
      }
    }
  }
  else if (v55)
  {
LABEL_30:
    uint64_t v12 = *((void *)a2 + 4);
    long long v13 = *a2;
    long long v14 = a2[1];
    int v52 = *((_DWORD *)a3 + 8);
    long long v53 = a3[1];
    *a2 = *a3;
    a2[1] = v53;
    *((_DWORD *)a2 + 8) = v52;
    goto LABEL_31;
  }
  return result;
}

BOOL sub_1CC498694(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = *(void *)(a2 - 32);
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = (void *)(v7 + 24);
      uint64_t v9 = *(unsigned int *)(v6 + 32);
      if (v9 > 0x40)
      {
        uint64_t v87 = *(void *)(v6 + 24);
        uint64_t v88 = *(void *)(v87 + 8 * ((v9 - 1) >> 6)) & (1 << (v9 - 1));
        unsigned int v89 = *(_DWORD *)(v7 + 32);
        unsigned int v90 = v89 - 1;
        uint64_t v91 = *(void *)(v7 + 24);
        if (v89 >= 0x41) {
          uint64_t v8 = (void *)(v91 + 8 * (v90 >> 6));
        }
        if ((v88 != 0) == ((*v8 >> v90) & 1))
        {
          unint64_t v112 = v9 + 63;
          uint64_t v113 = v91 - 8;
          uint64_t v114 = (v112 >> 3) & 0x3FFFFFF8;
          uint64_t v115 = v87 - 8;
          do
          {
            if (!v114) {
              return 1;
            }
            unint64_t v116 = *(void *)(v115 + v114);
            unint64_t v117 = *(void *)(v113 + v114);
            v114 -= 8;
          }
          while (v116 == v117);
          if (v116 > v117) {
            return 1;
          }
        }
        else if (!v88)
        {
          return result;
        }
      }
      else if ((uint64_t)(*(void *)(v6 + 24) << -(char)v9) >> -(char)v9 >= (uint64_t)(*v8 << -(char)v9) >> -(char)v9)
      {
        return result;
      }
      uint64_t v10 = *(void *)(a1 + 32);
      long long v11 = *(_OWORD *)a1;
      long long v12 = *(_OWORD *)(a1 + 16);
      int v13 = *(_DWORD *)(a2 - 8);
      long long v14 = *(_OWORD *)(a2 - 24);
      *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
      *(_OWORD *)(a1 + 16) = v14;
      *(_DWORD *)(a1 + 32) = v13;
      *(_OWORD *)(a2 - 24) = v12;
      *(_OWORD *)(a2 - 40) = v11;
      BOOL result = 1;
      *(_DWORD *)(a2 - 8) = v10;
      return result;
    case 3uLL:
      sub_1CC4982F0((long long *)a1, (long long *)(a1 + 40), (long long *)(a2 - 40));
      return 1;
    case 4uLL:
      sub_1CC498E6C(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      uint64_t v51 = (long long *)(a1 + 40);
      int v52 = (long long *)(a1 + 80);
      long long v53 = (long long *)(a1 + 120);
      sub_1CC498E6C(a1, a1 + 40, a1 + 80, a1 + 120);
      uint64_t v54 = *(void *)(a2 - 32);
      uint64_t v55 = *(void *)(a1 + 128);
      unsigned int v56 = (void *)(v55 + 24);
      uint64_t v57 = *(unsigned int *)(v54 + 32);
      if (v57 > 0x40)
      {
        uint64_t v92 = *(void *)(v54 + 24);
        uint64_t v93 = *(void *)(v92 + 8 * ((v57 - 1) >> 6)) & (1 << (v57 - 1));
        unsigned int v94 = *(_DWORD *)(v55 + 32);
        unsigned int v95 = v94 - 1;
        uint64_t v96 = *(void *)(v55 + 24);
        if (v94 >= 0x41) {
          unsigned int v56 = (void *)(v96 + 8 * (v95 >> 6));
        }
        if ((v93 != 0) == ((*v56 >> v95) & 1))
        {
          unint64_t v118 = v57 + 63;
          uint64_t v119 = v96 - 8;
          uint64_t v120 = (v118 >> 3) & 0x3FFFFFF8;
          uint64_t v121 = v92 - 8;
          do
          {
            if (!v120) {
              return 1;
            }
            unint64_t v122 = *(void *)(v121 + v120);
            unint64_t v123 = *(void *)(v119 + v120);
            v120 -= 8;
          }
          while (v122 == v123);
          if (v122 > v123) {
            return 1;
          }
        }
        else if (!v93)
        {
          return 1;
        }
      }
      else if ((uint64_t)(*(void *)(v54 + 24) << -(char)v57) >> -(char)v57 >= (uint64_t)(*v56 << -(char)v57) >> -(char)v57)
      {
        return 1;
      }
      uint64_t v58 = *(void *)(a1 + 152);
      long long v59 = *v53;
      long long v60 = *(_OWORD *)(a1 + 136);
      int v61 = *(_DWORD *)(a2 - 8);
      long long v62 = *(_OWORD *)(a2 - 24);
      *long long v53 = *(_OWORD *)(a2 - 40);
      *(_OWORD *)(a1 + 136) = v62;
      *(_DWORD *)(a1 + 152) = v61;
      *(_OWORD *)(a2 - 24) = v60;
      *(_OWORD *)(a2 - 40) = v59;
      *(_DWORD *)(a2 - 8) = v58;
      uint64_t v63 = *(void *)(a1 + 128);
      uint64_t v64 = *(void *)(a1 + 88);
      uint64_t v65 = (void *)(v64 + 24);
      uint64_t v66 = *(unsigned int *)(v63 + 32);
      if (v66 > 0x40)
      {
        uint64_t v97 = *(void *)(v63 + 24);
        uint64_t v98 = *(void *)(v97 + 8 * ((v66 - 1) >> 6)) & (1 << (v66 - 1));
        unsigned int v99 = *(_DWORD *)(v64 + 32);
        unsigned int v100 = v99 - 1;
        uint64_t v101 = *(void *)(v64 + 24);
        if (v99 >= 0x41) {
          uint64_t v65 = (void *)(v101 + 8 * (v100 >> 6));
        }
        if ((v98 != 0) == ((*v65 >> v100) & 1))
        {
          unint64_t v124 = v66 + 63;
          uint64_t v125 = v101 - 8;
          uint64_t v126 = (v124 >> 3) & 0x3FFFFFF8;
          uint64_t v127 = v97 - 8;
          do
          {
            if (!v126) {
              return 1;
            }
            unint64_t v128 = *(void *)(v127 + v126);
            unint64_t v129 = *(void *)(v125 + v126);
            v126 -= 8;
          }
          while (v128 == v129);
          if (v128 > v129) {
            return 1;
          }
        }
        else if (!v98)
        {
          return 1;
        }
      }
      else if ((uint64_t)(*(void *)(v63 + 24) << -(char)v66) >> -(char)v66 >= (uint64_t)(*v65 << -(char)v66) >> -(char)v66)
      {
        return 1;
      }
      uint64_t v67 = *(void *)(a1 + 112);
      long long v69 = *v52;
      long long v68 = *(_OWORD *)(a1 + 96);
      long long v70 = *(_OWORD *)(a1 + 136);
      long long *v52 = *v53;
      *(_OWORD *)(a1 + 96) = v70;
      *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 152);
      *long long v53 = v69;
      *(_OWORD *)(a1 + 136) = v68;
      *(_DWORD *)(a1 + 152) = v67;
      uint64_t v71 = *(void *)(a1 + 88);
      uint64_t v72 = *(void *)(a1 + 48);
      uint64_t v73 = (void *)(v72 + 24);
      uint64_t v74 = *(unsigned int *)(v71 + 32);
      if (v74 > 0x40)
      {
        uint64_t v102 = *(void *)(v71 + 24);
        uint64_t v103 = *(void *)(v102 + 8 * ((v74 - 1) >> 6)) & (1 << (v74 - 1));
        unsigned int v104 = *(_DWORD *)(v72 + 32);
        unsigned int v105 = v104 - 1;
        uint64_t v106 = *(void *)(v72 + 24);
        if (v104 >= 0x41) {
          uint64_t v73 = (void *)(v106 + 8 * (v105 >> 6));
        }
        if ((v103 != 0) == ((*v73 >> v105) & 1))
        {
          unint64_t v130 = v74 + 63;
          uint64_t v131 = v106 - 8;
          uint64_t v132 = (v130 >> 3) & 0x3FFFFFF8;
          uint64_t v133 = v102 - 8;
          do
          {
            if (!v132) {
              return 1;
            }
            unint64_t v134 = *(void *)(v133 + v132);
            unint64_t v135 = *(void *)(v131 + v132);
            v132 -= 8;
          }
          while (v134 == v135);
          if (v134 > v135) {
            return 1;
          }
        }
        else if (!v103)
        {
          return 1;
        }
      }
      else if ((uint64_t)(*(void *)(v71 + 24) << -(char)v74) >> -(char)v74 >= (uint64_t)(*v73 << -(char)v74) >> -(char)v74)
      {
        return 1;
      }
      uint64_t v75 = *(void *)(a1 + 72);
      long long v77 = *v51;
      long long v76 = *(_OWORD *)(a1 + 56);
      long long v78 = *(_OWORD *)(a1 + 96);
      *uint64_t v51 = *v52;
      *(_OWORD *)(a1 + 56) = v78;
      *(_DWORD *)(a1 + 72) = *(_DWORD *)(a1 + 112);
      long long *v52 = v77;
      *(_OWORD *)(a1 + 96) = v76;
      *(_DWORD *)(a1 + 112) = v75;
      uint64_t v79 = *(void *)(a1 + 48);
      uint64_t v80 = *(void *)(a1 + 8);
      uint64_t v81 = (void *)(v80 + 24);
      uint64_t v82 = *(unsigned int *)(v79 + 32);
      if (v82 <= 0x40)
      {
        if ((uint64_t)(*(void *)(v79 + 24) << -(char)v82) >> -(char)v82 >= (uint64_t)(*v81 << -(char)v82) >> -(char)v82) {
          return 1;
        }
        goto LABEL_49;
      }
      uint64_t v107 = *(void *)(v79 + 24);
      uint64_t v108 = *(void *)(v107 + 8 * ((v82 - 1) >> 6)) & (1 << (v82 - 1));
      unsigned int v109 = *(_DWORD *)(v80 + 32);
      unsigned int v110 = v109 - 1;
      uint64_t v111 = *(void *)(v80 + 24);
      if (v109 >= 0x41) {
        uint64_t v81 = (void *)(v111 + 8 * (v110 >> 6));
      }
      if ((v108 != 0) == ((*v81 >> v110) & 1))
      {
        unint64_t v136 = v82 + 63;
        uint64_t v137 = v111 - 8;
        uint64_t v138 = (v136 >> 3) & 0x3FFFFFF8;
        uint64_t v139 = v107 - 8;
        do
        {
          if (!v138) {
            return 1;
          }
          unint64_t v140 = *(void *)(v139 + v138);
          unint64_t v141 = *(void *)(v137 + v138);
          v138 -= 8;
        }
        while (v140 == v141);
        if (v140 <= v141)
        {
LABEL_49:
          uint64_t v83 = *(void *)(a1 + 32);
          long long v85 = *(_OWORD *)a1;
          long long v84 = *(_OWORD *)(a1 + 16);
          long long v86 = *(_OWORD *)(a1 + 56);
          *(_OWORD *)a1 = *v51;
          *(_OWORD *)(a1 + 16) = v86;
          *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 72);
          *uint64_t v51 = v85;
          *(_OWORD *)(a1 + 56) = v84;
          BOOL result = 1;
          *(_DWORD *)(a1 + 72) = v83;
          return result;
        }
      }
      else if (v108)
      {
        goto LABEL_49;
      }
      return 1;
    default:
      uint64_t v15 = a1 + 80;
      sub_1CC4982F0((long long *)a1, (long long *)(a1 + 40), (long long *)(a1 + 80));
      uint64_t v16 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      int v17 = 0;
      while (2)
      {
        uint64_t v18 = *(void *)(v16 + 8);
        uint64_t v19 = *(void *)(v15 + 8);
        int v20 = (void *)(v19 + 24);
        uint64_t v21 = *(unsigned int *)(v18 + 32);
        if (v21 > 0x40)
        {
          uint64_t v40 = *(void *)(v18 + 24);
          uint64_t v41 = *(void *)(v40 + 8 * ((v21 - 1) >> 6)) & (1 << (v21 - 1));
          unsigned int v42 = *(_DWORD *)(v19 + 32);
          unsigned int v43 = v42 - 1;
          uint64_t v44 = *(void *)(v19 + 24);
          if (v42 >= 0x41) {
            int v20 = (void *)(v44 + 8 * (v43 >> 6));
          }
          if ((v41 != 0) == ((*v20 >> v43) & 1))
          {
            unint64_t v45 = v21 + 63;
            uint64_t v46 = v44 - 8;
            uint64_t v47 = (v45 >> 3) & 0x3FFFFFF8;
            uint64_t v48 = v40 - 8;
            do
            {
              if (!v47) {
                goto LABEL_25;
              }
              unint64_t v49 = *(void *)(v48 + v47);
              unint64_t v50 = *(void *)(v46 + v47);
              v47 -= 8;
            }
            while (v49 == v50);
            if (v49 > v50)
            {
LABEL_25:
              uint64_t v15 = v16;
              v16 += 40;
              if (v16 == a2) {
                return 1;
              }
              continue;
            }
          }
          else if (!v41)
          {
            goto LABEL_25;
          }
        }
        else if ((uint64_t)(*(void *)(v18 + 24) << -(char)v21) >> -(char)v21 >= (uint64_t)(*v20 << -(char)v21) >> -(char)v21)
        {
          goto LABEL_25;
        }
        break;
      }
      uint64_t v22 = *(void *)v16;
      uint64_t v143 = *(void *)(v16 + 32);
      long long v142 = *(_OWORD *)(v16 + 16);
      *(_DWORD *)(v16 + 32) = *(_DWORD *)(v15 + 32);
      long long v23 = *(_OWORD *)(v15 + 16);
      *(_OWORD *)uint64_t v16 = *(_OWORD *)v15;
      *(_OWORD *)(v16 + 16) = v23;
      uint64_t v24 = a1;
      if (v15 == a1) {
        goto LABEL_24;
      }
      while (2)
      {
        uint64_t v25 = *(void *)(v15 - 32);
        uint64_t v26 = (void *)(v25 + 24);
        uint64_t v27 = *(unsigned int *)(v18 + 32);
        if (v27 <= 0x40)
        {
          if ((uint64_t)(*(void *)(v18 + 24) << -(char)v27) >> -(char)v27 >= (uint64_t)(*v26 << -(char)v27) >> -(char)v27) {
            goto LABEL_23;
          }
LABEL_12:
          long long v28 = *(_OWORD *)(v15 - 24);
          *(_OWORD *)uint64_t v15 = *(_OWORD *)(v15 - 40);
          *(_OWORD *)(v15 + 16) = v28;
          *(_DWORD *)(v15 + 32) = *(_DWORD *)(v15 - 8);
          v15 -= 40;
          if (v15 == a1)
          {
            uint64_t v24 = a1;
            goto LABEL_24;
          }
          continue;
        }
        break;
      }
      uint64_t v29 = *(void *)(v18 + 24);
      uint64_t v30 = *(void *)(v29 + 8 * ((v27 - 1) >> 6)) & (1 << (v27 - 1));
      unsigned int v31 = *(_DWORD *)(v25 + 32);
      unsigned int v32 = v31 - 1;
      uint64_t v33 = *(void *)(v25 + 24);
      if (v31 >= 0x41) {
        uint64_t v26 = (void *)(v33 + 8 * (v32 >> 6));
      }
      if ((v30 != 0) != ((*v26 >> v32) & 1))
      {
        if (!v30) {
          goto LABEL_23;
        }
        goto LABEL_12;
      }
      unint64_t v34 = v27 + 63;
      uint64_t v35 = v33 - 8;
      uint64_t v36 = (v34 >> 3) & 0x3FFFFFF8;
      uint64_t v37 = v29 - 8;
      while (v36)
      {
        unint64_t v38 = *(void *)(v37 + v36);
        unint64_t v39 = *(void *)(v35 + v36);
        v36 -= 8;
        if (v38 != v39)
        {
          if (v38 <= v39) {
            goto LABEL_12;
          }
          break;
        }
      }
LABEL_23:
      uint64_t v24 = v15;
LABEL_24:
      *(void *)uint64_t v24 = v22;
      *(void *)(v24 + 8) = v18;
      *(_OWORD *)(v24 + 16) = v142;
      *(_DWORD *)(v24 + 32) = v143;
      if (++v17 != 8) {
        goto LABEL_25;
      }
      return v16 + 40 == a2;
  }
}

long long *sub_1CC498E6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = sub_1CC4982F0((long long *)a1, (long long *)a2, (long long *)a3);
  uint64_t v9 = *(void *)(a4 + 8);
  uint64_t v10 = *(void *)(a3 + 8);
  long long v11 = (void *)(v10 + 24);
  uint64_t v12 = *(unsigned int *)(v9 + 32);
  if (v12 > 0x40)
  {
    uint64_t v36 = *(void *)(v9 + 24);
    uint64_t v37 = *(void *)(v36 + 8 * ((v12 - 1) >> 6)) & (1 << (v12 - 1));
    unsigned int v38 = *(_DWORD *)(v10 + 32);
    unsigned int v39 = v38 - 1;
    uint64_t v40 = *(void *)(v10 + 24);
    if (v38 >= 0x41) {
      long long v11 = (void *)(v40 + 8 * (v39 >> 6));
    }
    if ((v37 != 0) == ((*v11 >> v39) & 1))
    {
      unint64_t v51 = v12 + 63;
      uint64_t v52 = v40 - 8;
      uint64_t v53 = (v51 >> 3) & 0x3FFFFFF8;
      uint64_t v54 = v36 - 8;
      while (v53)
      {
        unint64_t v55 = *(void *)(v54 + v53);
        unint64_t v56 = *(void *)(v52 + v53);
        v53 -= 8;
        if (v55 != v56)
        {
          if (v55 <= v56) {
            goto LABEL_3;
          }
          return result;
        }
      }
      return result;
    }
    if (!v37) {
      return result;
    }
  }
  else if ((uint64_t)(*(void *)(v9 + 24) << -(char)v12) >> -(char)v12 >= (uint64_t)(*v11 << -(char)v12) >> -(char)v12)
  {
    return result;
  }
LABEL_3:
  uint64_t v13 = *(void *)(a3 + 32);
  long long v14 = *(_OWORD *)a3;
  long long v15 = *(_OWORD *)(a3 + 16);
  int v16 = *(_DWORD *)(a4 + 32);
  long long v17 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a4;
  *(_OWORD *)(a3 + 16) = v17;
  *(_DWORD *)(a3 + 32) = v16;
  *(_OWORD *)a4 = v14;
  *(_OWORD *)(a4 + 16) = v15;
  *(_DWORD *)(a4 + 32) = v13;
  uint64_t v18 = *(void *)(a3 + 8);
  uint64_t v19 = *(void *)(a2 + 8);
  int v20 = (void *)(v19 + 24);
  uint64_t v21 = *(unsigned int *)(v18 + 32);
  if (v21 > 0x40)
  {
    uint64_t v41 = *(void *)(v18 + 24);
    uint64_t v42 = *(void *)(v41 + 8 * ((v21 - 1) >> 6)) & (1 << (v21 - 1));
    unsigned int v43 = *(_DWORD *)(v19 + 32);
    unsigned int v44 = v43 - 1;
    uint64_t v45 = *(void *)(v19 + 24);
    if (v43 >= 0x41) {
      int v20 = (void *)(v45 + 8 * (v44 >> 6));
    }
    if ((v42 != 0) == ((*v20 >> v44) & 1))
    {
      unint64_t v57 = v21 + 63;
      uint64_t v58 = v45 - 8;
      uint64_t v59 = (v57 >> 3) & 0x3FFFFFF8;
      uint64_t v60 = v41 - 8;
      while (v59)
      {
        unint64_t v61 = *(void *)(v60 + v59);
        unint64_t v62 = *(void *)(v58 + v59);
        v59 -= 8;
        if (v61 != v62)
        {
          if (v61 <= v62) {
            goto LABEL_5;
          }
          return result;
        }
      }
      return result;
    }
    if (!v42) {
      return result;
    }
  }
  else if ((uint64_t)(*(void *)(v18 + 24) << -(char)v21) >> -(char)v21 >= (uint64_t)(*v20 << -(char)v21) >> -(char)v21)
  {
    return result;
  }
LABEL_5:
  uint64_t v22 = *(void *)(a2 + 32);
  long long v23 = *(_OWORD *)a2;
  long long v24 = *(_OWORD *)(a2 + 16);
  int v25 = *(_DWORD *)(a3 + 32);
  long long v26 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v26;
  *(_DWORD *)(a2 + 32) = v25;
  *(_OWORD *)a3 = v23;
  *(_OWORD *)(a3 + 16) = v24;
  *(_DWORD *)(a3 + 32) = v22;
  uint64_t v27 = *(void *)(a2 + 8);
  uint64_t v28 = *(void *)(a1 + 8);
  uint64_t v29 = (void *)(v28 + 24);
  uint64_t v30 = *(unsigned int *)(v27 + 32);
  if (v30 <= 0x40)
  {
    if ((uint64_t)(*(void *)(v27 + 24) << -(char)v30) >> -(char)v30 >= (uint64_t)(*v29 << -(char)v30) >> -(char)v30) {
      return result;
    }
    goto LABEL_7;
  }
  uint64_t v46 = *(void *)(v27 + 24);
  uint64_t v47 = *(void *)(v46 + 8 * ((v30 - 1) >> 6)) & (1 << (v30 - 1));
  unsigned int v48 = *(_DWORD *)(v28 + 32);
  unsigned int v49 = v48 - 1;
  uint64_t v50 = *(void *)(v28 + 24);
  if (v48 >= 0x41) {
    uint64_t v29 = (void *)(v50 + 8 * (v49 >> 6));
  }
  if ((v47 != 0) == ((*v29 >> v49) & 1))
  {
    unint64_t v63 = v30 + 63;
    uint64_t v64 = v50 - 8;
    uint64_t v65 = (v63 >> 3) & 0x3FFFFFF8;
    uint64_t v66 = v46 - 8;
    while (v65)
    {
      unint64_t v67 = *(void *)(v66 + v65);
      unint64_t v68 = *(void *)(v64 + v65);
      v65 -= 8;
      if (v67 != v68)
      {
        if (v67 <= v68) {
          goto LABEL_7;
        }
        return result;
      }
    }
  }
  else if (v47)
  {
LABEL_7:
    uint64_t v31 = *(void *)(a1 + 32);
    long long v32 = *(_OWORD *)a1;
    long long v33 = *(_OWORD *)(a1 + 16);
    int v34 = *(_DWORD *)(a2 + 32);
    long long v35 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v35;
    *(_DWORD *)(a1 + 32) = v34;
    *(_OWORD *)a2 = v32;
    *(_OWORD *)(a2 + 16) = v33;
    *(_DWORD *)(a2 + 32) = v31;
  }
  return result;
}

void sub_1CC499164()
{
}

void sub_1CC499200()
{
}

void sub_1CC49929C()
{
}

void sub_1CC4993D4(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26135F0;
  uint64_t v2 = *((void *)a1 + 53);
  *((void *)a1 + 53) = 0;
  if (v2)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v2 + 8), 8);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4012208D3FLL);
  }
  sub_1CD5295FC((uint64_t)a1 + 248);
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC4994C0(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26135F0;
  uint64_t v2 = *((void *)a1 + 53);
  *((void *)a1 + 53) = 0;
  if (v2)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v2 + 8), 8);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4012208D3FLL);
  }
  sub_1CD5295FC((uint64_t)a1 + 248);
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC4995C0(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBranchProbabilityInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::LazyMachineBlockFrequencyInfoPass::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::ProfileSummaryInfoWrapperPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CC499634(uint64_t a1, llvm::MachineFunction *a2)
{
  if (llvm::FunctionPass::skipFunction((llvm::FunctionPass *)a1, *(llvm::LLVMContextImpl *****)a2))
  {
    char v4 = 0;
  }
  else
  {
    uint64_t v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    if (v7 == v8)
    {
LABEL_7:
      uint64_t v9 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v7 != &llvm::MachineBranchProbabilityInfo::ID)
      {
        v7 += 16;
        if (v7 == v8) {
          goto LABEL_7;
        }
      }
      uint64_t v9 = *(void *)(v7 + 8);
    }
    uint64_t v10 = (const llvm::MachineBranchProbabilityInfo *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 96))(v9, &llvm::MachineBranchProbabilityInfo::ID);
    long long v11 = *(uint64_t **)(a1 + 8);
    uint64_t v12 = *v11;
    uint64_t v13 = v11[1];
    if (v12 == v13)
    {
LABEL_12:
      uint64_t v14 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v12 != &llvm::ProfileSummaryInfoWrapperPass::ID)
      {
        v12 += 16;
        if (v12 == v13) {
          goto LABEL_12;
        }
      }
      uint64_t v14 = *(void *)(v12 + 8);
    }
    long long v15 = *(llvm::ProfileSummaryInfo **)((*(uint64_t (**)(uint64_t, void *))(*(void *)v14 + 96))(v14, &llvm::ProfileSummaryInfoWrapperPass::ID)+ 32);
    if (*((void *)v15 + 1))
    {
      int v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = *v16;
      uint64_t v18 = v16[1];
      if (v17 == v18)
      {
LABEL_19:
        uint64_t v19 = 0;
      }
      else
      {
        while (*(_UNKNOWN **)v17 != &llvm::LazyMachineBlockFrequencyInfoPass::ID)
        {
          v17 += 16;
          if (v17 == v18) {
            goto LABEL_19;
          }
        }
        uint64_t v19 = *(void *)(v17 + 8);
      }
      int v20 = (llvm::PMDataManager ***)(*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 96))(v19, &llvm::LazyMachineBlockFrequencyInfoPass::ID);
      llvm::LazyMachineBlockFrequencyInfoPass::calculateIfNotAvailable(v20);
      operator new();
    }
    llvm::TailDuplicator::initMF((llvm::TailDuplicator *)(a1 + 248), a2, *(unsigned char *)(a1 + 432), v10, 0, v15, 0, 0);
    char v22 = 0;
    do
    {
      char v4 = v22;
      char v23 = llvm::TailDuplicator::tailDuplicateBlocks((llvm::TailDuplicator *)(a1 + 248), v21);
      char v22 = 1;
    }
    while ((v23 & 1) != 0);
  }
  return v4 & 1;
}

void sub_1CC499870(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26135F0;
  uint64_t v2 = *((void *)a1 + 53);
  *((void *)a1 + 53) = 0;
  if (v2)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v2 + 8), 8);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4012208D3FLL);
  }
  sub_1CD5295FC((uint64_t)a1 + 248);
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  char v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC49995C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26135F0;
  uint64_t v2 = *((void *)a1 + 53);
  *((void *)a1 + 53) = 0;
  if (v2)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v2 + 8), 8);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4012208D3FLL);
  }
  sub_1CD5295FC((uint64_t)a1 + 248);
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  char v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CC499A5C()
{
}

void sub_1CC499B98(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26135F0;
  uint64_t v2 = *((void *)a1 + 53);
  *((void *)a1 + 53) = 0;
  if (v2)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v2 + 8), 8);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4012208D3FLL);
  }
  sub_1CD5295FC((uint64_t)a1 + 248);
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  char v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }

  llvm::Pass::~Pass(a1);
}

void sub_1CC499C84(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F26135F0;
  uint64_t v2 = *((void *)a1 + 53);
  *((void *)a1 + 53) = 0;
  if (v2)
  {
    MEMORY[0x1D25D9CD0](*(void *)(v2 + 8), 8);
    MEMORY[0x1D25D9CE0](v2, 0x1060C4012208D3FLL);
  }
  sub_1CD5295FC((uint64_t)a1 + 248);
  *(void *)a1 = &unk_1F260E110;
  uint64_t v3 = (void *)*((void *)a1 + 22);
  if (v3 != (void *)((char *)a1 + 192)) {
    free(v3);
  }
  char v4 = (void *)*((void *)a1 + 13);
  if (v4 != (void *)((char *)a1 + 120)) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 4);
  if (v5 != (void *)((char *)a1 + 48)) {
    free(v5);
  }
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

double sub_1CC499D84@<D0>(uint64_t a1@<X8>)
{
  *(void *)(a1 + 16) = 2;
  *(void *)a1 = a1 + 16;
  *(void *)&double result = 0x600000001;
  *(void *)(a1 + 8) = 0x600000001;
  *(_DWORD *)(a1 + 64) = 11;
  return result;
}

uint64_t llvm::TailDuplicator::tailDuplicate(uint64_t *a1, int a2, llvm::MachineBasicBlock *this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v109[8] = *MEMORY[0x1E4F143B8];
  uint64_t FallThrough = llvm::MachineBasicBlock::getFallThrough(this);
  long long v11 = (unint64_t *)((char *)this + 48);
  v94[0] = 0;
  v94[1] = 0;
  int v95 = 0;
  uint64_t v12 = *((void *)this + 7);
  if ((llvm::MachineBasicBlock *)v12 == (llvm::MachineBasicBlock *)((char *)this + 48)) {
    goto LABEL_32;
  }
  do
  {
    int v13 = **(unsigned __int16 **)(v12 + 16);
    if (v13 != 69 && v13 != 0) {
      break;
    }
    int v15 = *(_DWORD *)(v12 + 40);
    if (v15 == 1) {
      goto LABEL_27;
    }
    for (unsigned int i = 1; i != v15; i += 2)
    {
      int v17 = *(_DWORD *)(*(void *)(v12 + 32) + 32 * i + 4);
      LODWORD(v102) = v17;
      if (v95)
      {
        int v18 = (v95 - 1) & (37 * v17);
        uint64_t v19 = &v94[0][4 * v18];
        int v20 = *(_DWORD *)v19;
        if (v17 == *(_DWORD *)v19) {
          continue;
        }
        uint64_t v21 = 0;
        int v22 = 1;
        while (v20 != -1)
        {
          if (v21) {
            BOOL v23 = 0;
          }
          else {
            BOOL v23 = v20 == -2;
          }
          if (v23) {
            uint64_t v21 = v19;
          }
          int v24 = v18 + v22++;
          int v18 = v24 & (v95 - 1);
          uint64_t v19 = &v94[0][4 * v18];
          int v20 = *(_DWORD *)v19;
          if (v17 == *(_DWORD *)v19) {
            goto LABEL_25;
          }
        }
        if (v21) {
          int v25 = v21;
        }
        else {
          int v25 = v19;
        }
      }
      else
      {
        int v25 = 0;
      }
      long long v26 = sub_1CBA855C4(v94, (uint64_t)&v102, (int *)&v102, v25);
      *(_DWORD *)long long v26 = v102;
LABEL_25:
      ;
    }
    if (v12)
    {
LABEL_27:
      if ((*(unsigned char *)v12 & 4) != 0) {
        goto LABEL_31;
      }
    }
    while ((*(_WORD *)(v12 + 44) & 8) != 0)
      uint64_t v12 = *(void *)(v12 + 8);
LABEL_31:
    uint64_t v12 = *(void *)(v12 + 8);
  }
  while ((unint64_t *)v12 != v11);
LABEL_32:
  if (a2)
  {
    uint64_t v27 = llvm::TailDuplicator::duplicateSimpleBB(a1, this, a5);
    goto LABEL_34;
  }
  uint64_t v102 = 1;
  int64x2_t v103 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v104 = v103;
  int64x2_t v105 = v103;
  int64x2_t v106 = v103;
  uint64_t v29 = v109;
  uint64_t v107 = v109;
  uint64_t v108 = 0x800000000;
  uint64_t v30 = a1;
  if (a7) {
    sub_1CD53F660(&v102, *(uint64_t **)a7, (uint64_t *)(*(void *)a7 + 8 * *(unsigned int *)(a7 + 8)));
  }
  else {
    sub_1CD53F660(&v102, *((uint64_t **)this + 8), *((uint64_t **)this + 9));
  }
  long long v32 = &dword_1CD912700[7744];
  uint64_t v33 = a4;
  char v34 = 0;
  if (v108)
  {
    long long v35 = (llvm::MachineBasicBlock **)v107;
    uint64_t v83 = (llvm::MachineBasicBlock **)((char *)v107 + 8 * v108);
    do
    {
      uint64_t v36 = *v35;
      if (llvm::TailDuplicator::canTailDuplicate((llvm::TailDuplicator *)a1, v31, *v35))
      {
        llvm::Function::getEntryCount(*(uint64_t ****)a1[5], 0, (uint64_t)&v99);
        if (v101[0] && *((unsigned char *)a1 + 65))
        {
LABEL_48:
          unint64_t v37 = *(unsigned int *)(a5 + 8);
          if (v37 >= *(unsigned int *)(a5 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a5 + 8 * v37) = v36;
          ++*(_DWORD *)(a5 + 8);
          (*(void (**)(void))(*(void *)*a1 + 264))();
          uint64_t v96 = 0;
          uint64_t v97 = 0;
          v98[0] = 0;
          unsigned int v99 = v101;
          uint64_t v100 = 0x400000000;
          uint64_t v38 = *((void *)this + 7);
          if ((unint64_t *)v38 != v11)
          {
            do
            {
              if (!v38 || (uint64_t v39 = v38, (*(unsigned char *)v38 & 4) == 0))
              {
                uint64_t v39 = v38;
                if ((*(_WORD *)(v38 + 44) & 8) != 0)
                {
                  uint64_t v39 = v38;
                  do
                    uint64_t v39 = *(void *)(v39 + 8);
                  while ((*(_WORD *)(v39 + 44) & 8) != 0);
                }
              }
              uint64_t v40 = *(unint64_t **)(v39 + 8);
              int v41 = **(unsigned __int16 **)(v38 + 16);
              if (v41 == 69 || v41 == 0) {
                llvm::TailDuplicator::processPHI(a1, v38, (uint64_t)this, (uint64_t)v36, (uint64_t)&v96, (uint64_t)&v99, (uint64_t)v94, 1);
              }
              else {
                llvm::TailDuplicator::duplicateInstruction((uint64_t)a1, v38, (uint64_t)this, (uint64_t)v36, (int32x2_t *)&v96, (uint64_t)v94);
              }
              uint64_t v38 = (uint64_t)v40;
            }
            while (v40 != v11);
          }
          unsigned int v43 = v29;
          llvm::TailDuplicator::appendCopies((uint64_t)a1, v36, (uint64_t)&v99, a6);
          llvm::MachineBasicBlock::removeSuccessor((uint64_t)v36, *((char **)v36 + 11), 0);
          unsigned int v44 = (const llvm::MachineBasicBlock **)*((void *)this + 11);
          uint64_t v45 = (const llvm::MachineBasicBlock **)*((void *)this + 12);
          while (v44 != v45)
          {
            uint64_t v46 = *v44++;
            int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability((llvm::MachineBranchProbabilityInfo *)a1[2], this, v46);
            llvm::MachineBasicBlock::addSuccessor(v36, v46, EdgeProbability);
          }
          if (FallThrough)
          {
            if (*((void *)this + 1) == *((void *)this + 4) + 320) {
              unsigned int v48 = 0;
            }
            else {
              unsigned int v48 = (llvm::MachineBasicBlock *)*((void *)this + 1);
            }
            llvm::MachineBasicBlock::updateTerminator(v36, v48);
          }
          uint64_t v29 = v43;
          uint64_t v33 = a4;
          if (v99 != v101) {
            free(v99);
          }
          MEMORY[0x1D25D9CD0](v96, 4);
          char v34 = 1;
          long long v32 = dword_1CD912700 + 30976;
          goto LABEL_73;
        }
        if (v33)
        {
          if (v36 != (llvm::MachineBasicBlock *)v33) {
            goto LABEL_48;
          }
        }
        else if (*((llvm::MachineBasicBlock **)v36 + 1) != this || !llvm::MachineBasicBlock::getFallThrough(v36))
        {
          goto LABEL_48;
        }
      }
LABEL_73:
      ++v35;
    }
    while (v35 != v83);
  }
  if (!v33) {
    uint64_t v33 = *(void *)this;
  }
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  unsigned int v99 = v101;
  uint64_t v49 = *((void *)v32 + 126);
  uint64_t v100 = v49;
  uint64_t v50 = *(llvm::MachineBasicBlock ***)(v33 + 88);
  if (((*(void *)(v33 + 96) - (void)v50) & 0x7FFFFFFF8) != 8
    || *v50 != this
    || ((*(uint64_t (**)(uint64_t, uint64_t, llvm::MachineBasicBlock **, uint64_t *, void **, void))(*(void *)*a1 + 248))(*a1, v33, &v93, &v92, &v99, 0) & 1) != 0|| v100|| v93 && v93 != this|| ((*((void *)this + 9) - *((void *)this + 8)) & 0x7FFFFFFF8) != 8|| *((unsigned char *)this + 185))
  {
    goto LABEL_80;
  }
  int v63 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)*a1 + 264))(*a1, v33, 0);
  unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator((llvm::MachineBasicBlock *)v33);
  if (v33 + 48 == FirstTerminator)
  {
    uint64_t v87 = v29;
    if (*((unsigned char *)a1 + 64))
    {
      int32x2_t v89 = 0;
      uint64_t v90 = 0;
      int v91 = 0;
      uint64_t v96 = v98;
      uint64_t v97 = v49;
      uint64_t v73 = *((void *)this + 7);
      uint64_t v74 = (uint64_t)a1;
      if ((unint64_t *)v73 != v11)
      {
        while (1)
        {
          int v75 = **(unsigned __int16 **)(v73 + 16);
          if (v75 != 69 && v75 != 0) {
            break;
          }
          uint64_t v77 = v73;
          if ((*(unsigned char *)v73 & 4) == 0)
          {
            uint64_t v77 = v73;
            if ((*(_WORD *)(v73 + 44) & 8) != 0)
            {
              uint64_t v77 = v73;
              do
                uint64_t v77 = *(void *)(v77 + 8);
              while ((*(_WORD *)(v77 + 44) & 8) != 0);
            }
          }
          long long v78 = *(unint64_t **)(v77 + 8);
          llvm::TailDuplicator::processPHI(a1, v73, (uint64_t)this, v33, (uint64_t)&v89, (uint64_t)&v96, (uint64_t)v94, 1);
          uint64_t v73 = (uint64_t)v78;
          if (v78 == v11) {
            goto LABEL_150;
          }
        }
        if ((unint64_t *)v73 != v11)
        {
          uint64_t v74 = (uint64_t)a1;
          do
          {
            if (!v73 || (uint64_t v79 = v73, (*(unsigned char *)v73 & 4) == 0))
            {
              uint64_t v79 = v73;
              if ((*(_WORD *)(v73 + 44) & 8) != 0)
              {
                uint64_t v79 = v73;
                do
                  uint64_t v79 = *(void *)(v79 + 8);
                while ((*(_WORD *)(v79 + 44) & 8) != 0);
              }
            }
            uint64_t v80 = *(unint64_t **)(v79 + 8);
            llvm::TailDuplicator::duplicateInstruction((uint64_t)a1, v73, (uint64_t)this, v33, &v89, (uint64_t)v94);
            llvm::MachineInstr::eraseFromParent((llvm::MachineInstr *)v73);
            uint64_t v73 = (uint64_t)v80;
          }
          while (v80 != v11);
        }
      }
LABEL_150:
      llvm::TailDuplicator::appendCopies(v74, (llvm::MachineBasicBlock *)v33, (uint64_t)&v96, a6);
      if (v96 != v98) {
        free(v96);
      }
      MEMORY[0x1D25D9CD0](*(void *)&v89, 4);
    }
    else
    {
      uint64_t v65 = (void *)FirstTerminator;
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)*a1 + 264))(*a1, v33, 0);
      if ((llvm::MachineBasicBlock *)v33 != this)
      {
        uint64_t v66 = (unint64_t *)*((void *)this + 7);
        if (v66 != v11)
        {
          unint64_t v67 = *(void *)(v33 + 40);
          unint64_t v68 = (unint64_t *)*((void *)this + 7);
          do
          {
            v68[3] = v67;
            unint64_t v68 = (unint64_t *)v68[1];
          }
          while (v68 != v11);
          unint64_t v69 = *v11;
          unint64_t v70 = *v11 & 0xFFFFFFFFFFFFFFF8;
          unint64_t v71 = *v66 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v71 + 8) = v11;
          *long long v11 = v71 | v69 & 7;
          unint64_t v72 = *v65 & 0xFFFFFFFFFFFFFFF8;
          *(void *)(v70 + 8) = v65;
          *uint64_t v66 = v72 | *v66 & 7;
          *(void *)(v72 + 8) = v66;
          *uint64_t v65 = v69 & 0xFFFFFFFFFFFFFFF8 | *v65 & 7;
        }
      }
    }
    llvm::MachineBasicBlock::removeSuccessor(v33, *(char **)(v33 + 88), 0);
    llvm::MachineBasicBlock::transferSuccessors((char *)v33, this);
    if (FallThrough)
    {
      if (*((void *)this + 1) == *((void *)this + 4) + 320) {
        uint64_t v81 = 0;
      }
      else {
        uint64_t v81 = (llvm::MachineBasicBlock *)*((void *)this + 1);
      }
      llvm::MachineBasicBlock::updateTerminator((llvm::MachineBasicBlock *)v33, v81);
    }
    unsigned int v82 = *(_DWORD *)(a5 + 8);
    if (v82 >= *(_DWORD *)(a5 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a5 + 8 * v82) = v33;
    ++*(_DWORD *)(a5 + 8);
    char v34 = 1;
    uint64_t v29 = v87;
    uint64_t v30 = a1;
LABEL_80:
    uint64_t v27 = (*((unsigned char *)v30 + 64) == 0) & v34;
    if (*((unsigned char *)v30 + 64) && (v34 & 1) != 0)
    {
      if (v108)
      {
        unint64_t v51 = (llvm::MachineBasicBlock **)v107;
        uint64_t v52 = (llvm::MachineBasicBlock **)((char *)v107 + 8 * v108);
        do
        {
          uint64_t v53 = *v51;
          uint64_t v54 = *(llvm::MachineBasicBlock ***)a5;
          uint64_t v55 = *(unsigned int *)(a5 + 8);
          if (v55)
          {
            uint64_t v56 = 8 * v55;
            unint64_t v57 = *(llvm::MachineBasicBlock ***)a5;
            while (*v57 != v53)
            {
              ++v57;
              v56 -= 8;
              if (!v56)
              {
                unint64_t v57 = &v54[v55];
                break;
              }
            }
          }
          else
          {
            unint64_t v57 = *(llvm::MachineBasicBlock ***)a5;
          }
          if (v55 == v57 - v54 && ((*((void *)v53 + 12) - *((void *)v53 + 11)) & 0x7FFFFFFF8) == 8)
          {
            int32x2_t v89 = 0;
            uint64_t v90 = 0;
            int v91 = 0;
            uint64_t v96 = v98;
            uint64_t v97 = v49;
            uint64_t v58 = *((void *)this + 7);
            if ((unint64_t *)v58 != v11)
            {
              do
              {
                int v59 = **(unsigned __int16 **)(v58 + 16);
                if (v59 != 69 && v59 != 0) {
                  break;
                }
                uint64_t v61 = v58;
                if ((*(unsigned char *)v58 & 4) == 0)
                {
                  uint64_t v61 = v58;
                  if ((*(_WORD *)(v58 + 44) & 8) != 0)
                  {
                    uint64_t v61 = v58;
                    do
                      uint64_t v61 = *(void *)(v61 + 8);
                    while ((*(_WORD *)(v61 + 44) & 8) != 0);
                  }
                }
                unint64_t v62 = *(unint64_t **)(v61 + 8);
                llvm::TailDuplicator::processPHI(a1, v58, (uint64_t)this, (uint64_t)v53, (uint64_t)&v89, (uint64_t)&v96, (uint64_t)v94, 0);
                uint64_t v58 = (uint64_t)v62;
              }
              while (v62 != v11);
            }
            llvm::TailDuplicator::appendCopies((uint64_t)a1, v53, (uint64_t)&v96, a6);
            if (v96 != v98) {
              free(v96);
            }
            MEMORY[0x1D25D9CD0](*(void *)&v89, 4);
          }
          ++v51;
        }
        while (v51 != v52);
      }
      uint64_t v27 = 1;
    }
    goto LABEL_109;
  }
  uint64_t v27 = v63 != 0;
  if (v34)
  {
    char v34 = 1;
    goto LABEL_80;
  }
LABEL_109:
  if (v99 != v101) {
    free(v99);
  }
  if (v107 != v29) {
    free(v107);
  }
  if ((v102 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v103.i64[0], 8);
  }
LABEL_34:
  MEMORY[0x1D25D9CD0](v94[0], 4);
  return v27;
}

void sub_1CC49A7B0(uint64_t a1, int a2)
{
  v47[8] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (void *)(a1 + 320);
  uint64_t v3 = *(void **)(*(void *)(a1 + 328) + 8);
  if (v3 != (void *)(a1 + 320))
  {
    int64x2_t v36 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      uint64_t v5 = (uint64_t *)v3[8];
      uint64_t v6 = (uint64_t *)v3[9];
      uint64_t v40 = 1;
      int64x2_t v41 = v36;
      int64x2_t v42 = v36;
      int64x2_t v43 = v36;
      int64x2_t v44 = v36;
      uint64_t v45 = v47;
      uint64_t v46 = 0x800000000;
      uint64_t v7 = (uint64_t)sub_1CD53F660(&v40, v5, v6);
      for (uint64_t i = v3[7]; (void *)i != v3 + 6; uint64_t i = *(void *)(i + 8))
      {
        int v9 = **(unsigned __int16 **)(i + 16);
        if (v9 != 69 && v9 != 0) {
          break;
        }
        int v11 = *(_DWORD *)(i + 40);
        if (v46)
        {
          uint64_t v12 = (uint64_t *)v45;
          while (1)
          {
            uint64_t v13 = *v12;
            if (v11 == 1) {
              break;
            }
            int v14 = 1;
            while (*(void *)(*(void *)(i + 32) + 32 * (v14 + 1) + 16) != v13)
            {
              v14 += 2;
              if (v11 == v14) {
                goto LABEL_36;
              }
            }
            if (++v12 == (uint64_t *)((char *)v45 + 8 * v46)) {
              goto LABEL_18;
            }
          }
LABEL_36:
          int v17 = llvm::dbgs((llvm *)v7);
          int v18 = sub_1CB8E509C(v17, "Malformed PHI in ");
          uint64_t v39 = &v37;
          unint64_t v37 = &unk_1F260D508;
          uint64_t v38 = v3;
          uint64_t v19 = (llvm::raw_ostream *)sub_1CD5818EC((uint64_t)v18, (uint64_t)&v37);
          int v20 = sub_1CB8E509C(v19, ": ");
          sub_1CD5818A8(v20, (llvm::MachineInstr *)i);
          uint64_t v21 = (llvm *)sub_1CD581944(&v37);
          char v34 = llvm::dbgs(v21);
          long long v35 = "  missing input from predecessor ";
LABEL_37:
          int v22 = sub_1CB8E509C(v34, v35);
          uint64_t v39 = &v37;
          unint64_t v37 = &unk_1F260D508;
          uint64_t v38 = (void *)v13;
          BOOL v23 = (llvm::raw_ostream *)sub_1CD5818EC((uint64_t)v22, (uint64_t)&v37);
          sub_1CD4B4374(v23, 10);
          sub_1CD581944(&v37);
          __break(1u);
        }
LABEL_18:
        if (v11 != 1)
        {
          int v15 = 1;
          while (1)
          {
            uint64_t v16 = *(void *)(i + 32) + 32 * (v15 + 1);
            uint64_t v13 = *(void *)(v16 + 16);
            if (a2)
            {
              uint64_t v7 = sub_1CD5434AC((uint64_t)&v40, *(void *)(v16 + 16), &v37);
              if ((v7 & 1) == 0)
              {
                uint64_t v29 = llvm::dbgs((llvm *)v7);
                uint64_t v30 = sub_1CB8E509C(v29, "Warning: malformed PHI in ");
                uint64_t v39 = &v37;
                unint64_t v37 = &unk_1F260D508;
                uint64_t v38 = v3;
                uint64_t v31 = (llvm::raw_ostream *)sub_1CD5818EC((uint64_t)v30, (uint64_t)&v37);
                long long v32 = sub_1CB8E509C(v31, ": ");
                sub_1CD5818A8(v32, (llvm::MachineInstr *)i);
                uint64_t v33 = (llvm *)sub_1CD581944(&v37);
                char v34 = llvm::dbgs(v33);
                long long v35 = "  extra input from predecessor ";
                goto LABEL_37;
              }
            }
            if ((*(_DWORD *)(v13 + 24) & 0x80000000) != 0) {
              break;
            }
            v15 += 2;
            if (v11 == v15) {
              goto LABEL_19;
            }
          }
          int v24 = llvm::dbgs((llvm *)v7);
          int v25 = sub_1CB8E509C(v24, "Malformed PHI in ");
          uint64_t v39 = &v37;
          unint64_t v37 = &unk_1F260D508;
          uint64_t v38 = v3;
          long long v26 = (llvm::raw_ostream *)sub_1CD5818EC((uint64_t)v25, (uint64_t)&v37);
          uint64_t v27 = sub_1CB8E509C(v26, ": ");
          sub_1CD5818A8(v27, (llvm::MachineInstr *)i);
          uint64_t v28 = (llvm *)sub_1CD581944(&v37);
          char v34 = llvm::dbgs(v28);
          long long v35 = "  non-existing ";
          goto LABEL_37;
        }
LABEL_19:
        if ((*(unsigned char *)i & 4) == 0)
        {
          while ((*(_WORD *)(i + 44) & 8) != 0)
            uint64_t i = *(void *)(i + 8);
        }
      }
      if (v45 != v47) {
        free(v45);
      }
      if ((v40 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v41.i64[0], 8);
      }
      uint64_t v3 = (void *)v3[1];
    }
    while (v3 != v2);
  }
}

void llvm::TailDuplicator::addSSAUpdateEntry(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8 = a1 + 152;
  uint64_t v9 = *(void *)(a1 + 152);
  uint64_t v10 = *(unsigned int *)(a1 + 168);
  int v11 = sub_1CD489BC0(v9, v10, a2);
  if ((int *)(v9 + 32 * v10) == v11)
  {
    BOOL v23 = operator new(0x10uLL);
    *BOOL v23 = a4;
    v23[1] = a3;
    int v27 = a2;
    int v24 = operator new(0x10uLL);
    __p[1] = v24 + 1;
    __p[2] = v24 + 1;
    *int v24 = *(_OWORD *)v23;
    __p[0] = v24;
    sub_1CD581C0C((uint64_t)v26, v8, &v27, (uint64_t)__p);
    if (__p[0]) {
      operator delete(__p[0]);
    }
    unsigned int v25 = *(_DWORD *)(a1 + 80);
    if (v25 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)(a1 + 72) + 4 * v25) = a2;
    ++*(_DWORD *)(a1 + 80);
    operator delete(v23);
  }
  else
  {
    uint64_t v12 = v11;
    int v14 = (char *)*((void *)v11 + 2);
    unint64_t v13 = *((void *)v11 + 3);
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = (char *)*((void *)v11 + 1);
      uint64_t v17 = (v14 - v16) >> 4;
      unint64_t v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60) {
        abort();
      }
      uint64_t v19 = v13 - (void)v16;
      if (v19 >> 3 > v18) {
        unint64_t v18 = v19 >> 3;
      }
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v20 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20)
      {
        if (v20 >> 60) {
          sub_1CB833614();
        }
        uint64_t v21 = (char *)operator new(16 * v20);
      }
      else
      {
        uint64_t v21 = 0;
      }
      int v22 = &v21[16 * v17];
      *(void *)int v22 = a4;
      *((void *)v22 + 1) = a3;
      int v15 = v22 + 16;
      if (v14 != v16)
      {
        do
        {
          *((_OWORD *)v22 - 1) = *((_OWORD *)v14 - 1);
          v22 -= 16;
          v14 -= 16;
        }
        while (v14 != v16);
        int v14 = (char *)*((void *)v12 + 1);
      }
      *((void *)v12 + 1) = v22;
      *((void *)v12 + 2) = v15;
      *((void *)v12 + 3) = &v21[16 * v20];
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *(void *)int v14 = a4;
      *((void *)v14 + 1) = a3;
      int v15 = v14 + 16;
    }
    *((void *)v12 + 2) = v15;
  }
}

uint64_t sub_1CC49AD24(unsigned int a1, uint64_t a2, uint64_t a3)
{
  if ((a1 & 0x80000000) != 0) {
    uint64_t v3 = (uint64_t *)(*(void *)(a3 + 24) + 16 * (a1 & 0x7FFFFFFF) + 8);
  }
  else {
    uint64_t v3 = (uint64_t *)(*(void *)(a3 + 272) + 8 * a1);
  }
  uint64_t v4 = *v3;
  if (!v4) {
    return 0;
  }
  while ((*(unsigned char *)(v4 + 3) & 1) != 0)
  {
    uint64_t v4 = *(void *)(v4 + 24);
    if (!v4) {
      return 0;
    }
  }
  uint64_t v6 = *(void *)(v4 + 8);
LABEL_8:
  if (**(unsigned __int16 **)(v6 + 16) - 13 < 2 || *(void *)(v6 + 24) == a2)
  {
    while (1)
    {
      uint64_t v4 = *(void *)(v4 + 24);
      if (!v4) {
        return 0;
      }
      if ((*(unsigned char *)(v4 + 3) & 1) == 0 && *(void *)(v4 + 8) != v6)
      {
        uint64_t v6 = *(void *)(v4 + 8);
        goto LABEL_8;
      }
    }
  }
  return 1;
}

uint64_t llvm::TailDuplicator::duplicateSimpleBB(void *a1, llvm::MachineBasicBlock *a2, uint64_t a3)
{
  v84[8] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (uint64_t *)*((void *)a2 + 11);
  uint64_t v7 = (uint64_t *)*((void *)a2 + 12);
  uint64_t v8 = v77;
  uint64_t v73 = v77;
  uint64_t v74 = v77;
  uint64_t v75 = 8;
  int v76 = 0;
  if (v6 != v7)
  {
    unsigned int v9 = 8;
    uint64_t v10 = v77;
    while (1)
    {
      uint64_t v11 = *v6;
      uint64_t v12 = HIDWORD(v75);
      if (v10 != v8) {
        break;
      }
      if (HIDWORD(v75))
      {
        unint64_t v13 = 0;
        uint64_t v14 = 8 * HIDWORD(v75);
        int v15 = v8;
        while (*(void *)v15 != v11)
        {
          if (*(void *)v15 == -2) {
            unint64_t v13 = v15;
          }
          v15 += 8;
          v14 -= 8;
          if (!v14)
          {
            if (!v13) {
              goto LABEL_11;
            }
            *(void *)unint64_t v13 = v11;
            --v76;
            goto LABEL_34;
          }
        }
        goto LABEL_34;
      }
LABEL_11:
      if (HIDWORD(v75) >= v9) {
        break;
      }
      ++HIDWORD(v75);
      *(void *)&v8[8 * v12] = v11;
LABEL_34:
      uint64_t v8 = v73;
      uint64_t v10 = v74;
      if (++v6 == v7) {
        goto LABEL_42;
      }
    }
    if (3 * v9 <= 4 * (HIDWORD(v75) - v76))
    {
      if (v9 >= 0x40) {
        v9 *= 2;
      }
      else {
        unsigned int v9 = 128;
      }
    }
    else if (v9 - HIDWORD(v75) >= v9 >> 3)
    {
      goto LABEL_15;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v73, v9);
    unsigned int v9 = v75;
    uint64_t v10 = v74;
LABEL_15:
    unsigned int v16 = v9 - 1;
    unsigned int v17 = (v9 - 1) & ((v11 >> 4) ^ (v11 >> 9));
    unint64_t v18 = &v10[8 * v17];
    uint64_t v19 = *(void *)v18;
    if (*(void *)v18 == -1)
    {
      unint64_t v20 = 0;
LABEL_27:
      if (v20) {
        int v24 = v20;
      }
      else {
        int v24 = v18;
      }
      if (*(void *)v24 != v11)
      {
        if (*(void *)v24 == -2) {
          --v76;
        }
        else {
          ++HIDWORD(v75);
        }
        *(void *)int v24 = v11;
      }
    }
    else
    {
      unint64_t v20 = 0;
      int v21 = 1;
      while (v19 != v11)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v19 == -2;
        }
        if (v22) {
          unint64_t v20 = v18;
        }
        unsigned int v23 = v17 + v21++;
        unsigned int v17 = v23 & v16;
        unint64_t v18 = &v10[8 * (v23 & v16)];
        uint64_t v19 = *(void *)v18;
        if (*(void *)v18 == -1) {
          goto LABEL_27;
        }
      }
    }
    goto LABEL_34;
  }
LABEL_42:
  unsigned int v25 = (char *)*((void *)a2 + 8);
  long long v26 = (char *)*((void *)a2 + 9);
  unsigned int v82 = (llvm::MachineBasicBlock **)v84;
  uint64_t v83 = 0x800000000;
  unint64_t v27 = v26 - v25;
  if ((unint64_t)(v26 - v25) >= 0x41) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v28 = (llvm::MachineBasicBlock **)v84;
  if (v25 != v26)
  {
    uint64_t v29 = v84;
    do
    {
      uint64_t v30 = *(void *)v25;
      v25 += 8;
      *v29++ = v30;
    }
    while (v25 != v26);
    uint64_t v28 = v82;
  }
  int v31 = v27 >> 3;
  LODWORD(v83) = v31;
  char v32 = 0;
  if (v31)
  {
    uint64_t v33 = &v28[v31];
    while (1)
    {
      char v34 = *v28;
      long long v35 = (void *)*((void *)*v28 + 11);
      int64x2_t v36 = (void *)*((void *)*v28 + 12);
      unint64_t v37 = v35;
      if (v35 != v36)
      {
        while (!*(unsigned char *)(*v37 + 184))
        {
          if (++v37 == v36)
          {
            uint64_t v38 = (void *)*((void *)*v28 + 11);
            while (!*(unsigned char *)(*v38 + 202))
            {
              if (++v38 == v36)
              {
                if (v35 == v36) {
                  goto LABEL_96;
                }
                int v39 = v75 - 1;
                if (v74 == v73) {
                  int v40 = HIDWORD(v75);
                }
                else {
                  int v40 = v75;
                }
                int64x2_t v41 = &v74[8 * v40];
                int64x2_t v42 = v74;
                while (1)
                {
                  uint64_t v43 = *v35;
                  if (v42 == v73)
                  {
                    if (HIDWORD(v75))
                    {
                      uint64_t v44 = 0;
                      while (*(void *)&v73[v44] != v43)
                      {
                        v44 += 8;
                        if (8 * HIDWORD(v75) == v44)
                        {
                          int v45 = HIDWORD(v75);
                          goto LABEL_80;
                        }
                      }
                      uint64_t v54 = &v73[v44];
                      int v45 = HIDWORD(v75);
                      int64x2_t v42 = v73;
                    }
                    else
                    {
                      int v45 = 0;
LABEL_80:
                      int64x2_t v42 = v73;
                      uint64_t v54 = &v73[8 * HIDWORD(v75)];
                    }
                  }
                  else
                  {
                    unsigned int v46 = v39 & ((v43 >> 4) ^ (v43 >> 9));
                    uint64_t v47 = &v74[8 * v46];
                    uint64_t v48 = *(void *)v47;
                    if (*(void *)v47 == -1)
                    {
                      uint64_t v49 = 0;
LABEL_82:
                      if (v49) {
                        uint64_t v47 = v49;
                      }
                      uint64_t v53 = *(void *)v47;
                    }
                    else
                    {
                      uint64_t v49 = 0;
                      int v50 = 1;
                      while (v48 != v43)
                      {
                        if (v49) {
                          BOOL v51 = 0;
                        }
                        else {
                          BOOL v51 = v48 == -2;
                        }
                        if (v51) {
                          uint64_t v49 = v47;
                        }
                        unsigned int v52 = v46 + v50++;
                        unsigned int v46 = v52 & v39;
                        uint64_t v47 = &v74[8 * (v52 & v39)];
                        uint64_t v48 = *(void *)v47;
                        if (*(void *)v47 == -1) {
                          goto LABEL_82;
                        }
                      }
                      uint64_t v53 = *v35;
                    }
                    uint64_t v54 = v53 == v43 ? v47 : v41;
                    int v45 = HIDWORD(v75);
                    int64x2_t v42 = v74;
                  }
                  if (v42 != v73) {
                    int v45 = v75;
                  }
                  if (v54 != &v42[8 * v45] && v43 + 48 != (*(void *)(v43 + 48) & 0xFFFFFFFFFFFFFFF8))
                  {
                    int v55 = **(unsigned __int16 **)(*(void *)(v43 + 56) + 16);
                    if (!v55 || v55 == 69) {
                      goto LABEL_142;
                    }
                  }
                  if (++v35 == v36) {
                    goto LABEL_96;
                  }
                }
              }
            }
            goto LABEL_142;
          }
        }
        goto LABEL_142;
      }
LABEL_96:
      unint64_t v71 = 0;
      unint64_t v72 = 0;
      uint64_t v79 = v81;
      uint64_t v80 = 0x400000000;
      if (((*(uint64_t (**)(void, llvm::MachineBasicBlock *, llvm::MachineBasicBlock **, llvm::MachineBasicBlock **, void **, void))(*(void *)*a1 + 248))(*a1, v34, &v72, &v71, &v79, 0) & 1) == 0)break; {
LABEL_140:
      }
      if (v79 != v81) {
        free(v79);
      }
LABEL_142:
      if (++v28 == v33)
      {
        uint64_t v28 = v82;
        goto LABEL_156;
      }
    }
    uint64_t v56 = (llvm::MachineBasicBlock *)**((void **)a2 + 11);
    if (*((void *)v34 + 1) == *((void *)v34 + 4) + 320) {
      unint64_t v57 = 0;
    }
    else {
      unint64_t v57 = (llvm::MachineBasicBlock *)*((void *)v34 + 1);
    }
    uint64_t v58 = v72;
    if (v80)
    {
      if (v72) {
        goto LABEL_102;
      }
    }
    else
    {
      unint64_t v71 = v72;
      if (v72) {
        goto LABEL_102;
      }
    }
    unint64_t v72 = v57;
    uint64_t v58 = v57;
LABEL_102:
    if (v71) {
      int v59 = v71;
    }
    else {
      int v59 = v57;
    }
    BOOL v60 = v59 == a2;
    if (v59 == a2) {
      int v59 = v56;
    }
    if (!v71 || v60) {
      unint64_t v71 = v59;
    }
    if (v58 == a2)
    {
      unint64_t v72 = v56;
      uint64_t v58 = v56;
    }
    if (v58 == v59)
    {
      int v59 = 0;
      LODWORD(v80) = 0;
      unint64_t v71 = 0;
    }
    if (v59 == v57)
    {
      int v59 = 0;
      unint64_t v71 = 0;
    }
    if (v58 == v57 && v59 == 0) {
      unint64_t v72 = 0;
    }
    llvm::MachineBasicBlock::findBranchDebugLoc(v34, &v70);
    (*(void (**)(void, llvm::MachineBasicBlock *, void))(*(void *)*a1 + 264))(*a1, v34, 0);
    unint64_t v62 = (llvm::MachineBasicBlock **)*((void *)v34 + 11);
    int v63 = (llvm::MachineBasicBlock **)*((void *)v34 + 12);
    if (v62 != v63)
    {
      while (*v62 != v56)
      {
        if (++v62 == v63)
        {
          unint64_t v62 = (llvm::MachineBasicBlock **)*((void *)v34 + 12);
          break;
        }
      }
    }
    if (v62 == v63) {
      llvm::MachineBasicBlock::replaceSuccessor(v34, a2, v56);
    }
    else {
      llvm::MachineBasicBlock::removeSuccessor(v34, a2, 1);
    }
    if (v72) {
      (*(void (**)(void, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void *, void, unsigned __int8 **, void))(*(void *)*a1 + 272))(*a1, v34, v72, v71, v79, v80, &v70, 0);
    }
    unint64_t v64 = *(unsigned int *)(a3 + 8);
    if (v64 >= *(unsigned int *)(a3 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)a3 + 8 * v64) = v34;
    ++*(_DWORD *)(a3 + 8);
    if (!v70) {
      goto LABEL_139;
    }
    int v65 = *v70;
    if ((v65 - 4) > 0x1E)
    {
      if ((v65 - 3) >= 0xFFFFFFFE) {
        uint64_t v66 = v70;
      }
      else {
        uint64_t v66 = 0;
      }
      if ((v65 - 3) < 0xFFFFFFFE)
      {
        if (v65 == 3) {
          *((void *)v70 + 1) = 0;
        }
        goto LABEL_139;
      }
      unint64_t v67 = (unint64_t)(v66 + 8);
    }
    else
    {
      if ((v70[1] & 0x7F) != 2 && !*((_DWORD *)v70 + 3)) {
        goto LABEL_139;
      }
      uint64_t v68 = *((void *)v70 + 2);
      if ((v68 & 4) == 0) {
        goto LABEL_139;
      }
      unint64_t v67 = v68 & 0xFFFFFFFFFFFFFFF8;
      if (!v67) {
        goto LABEL_139;
      }
    }
    long long v78 = &v70;
    sub_1CC5FA668(v67 + 16, &v78);
LABEL_139:
    char v32 = 1;
    goto LABEL_140;
  }
LABEL_156:
  if (v28 != v84) {
    free(v28);
  }
  if (v74 != v73) {
    free(v74);
  }
  return v32 & 1;
}

uint64_t sub_1CC49B4E8()
{
  v3.n128_u64[0] = (unint64_t)"Maximum instructions to consider tail duplicating";
  v3.n128_u64[1] = 49;
  int v4 = 2;
  uint64_t v2 = &v4;
  int v1 = 1;
  sub_1CD50BCD4((uint64_t)&unk_1EBCD4198, "tail-dup-size", &v3, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD4198, &dword_1CB82C000);
  v3.n128_u64[0] = (unint64_t)"Maximum instructions to consider tail duplicating blocks that end with indirect branches.";
  v3.n128_u64[1] = 89;
  int v4 = 20;
  uint64_t v2 = &v4;
  int v1 = 1;
  sub_1CD5819C8((long long *)&v3, &v2, &v1);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCD4258, &dword_1CB82C000);
  v3.n128_u64[0] = (unint64_t)"Verify sanity of PHI instructions during taildup";
  v3.n128_u64[1] = 48;
  LOBYTE(v1) = 0;
  uint64_t v2 = &v1;
  int v4 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBD06048, "tail-dup-verify", &v3, (unsigned char **)&v2, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBD06048, &dword_1CB82C000);
  LODWORD(v2) = -1;
  v3.n128_u64[0] = (unint64_t)&v2;
  int v4 = 1;
  sub_1CD581AF0((uint64_t)&unk_1EBD06108, "tail-dup-limit", &v3, &v4);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBD06108, &dword_1CB82C000);
}

BOOL llvm::TargetFrameLowering::needsFrameIndexResolution(llvm::TargetFrameLowering *this, const llvm::MachineFunction *a2)
{
  return *(void *)(*((void *)a2 + 7) + 8) != *(void *)(*((void *)a2 + 7) + 16);
}

void llvm::TargetFrameLowering::getCalleeSaves(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)((*(uint64_t (**)(void))(**(void **)(a2 + 16) + 176))(*(void *)(a2 + 16)) + 16);
  uint64_t v6 = *((unsigned int *)a3 + 2);
  if ((a3[8] & 0x3F) != 0) {
    *(void *)(*a3 + 8 * v6 - 8) &= ~(-1 << (a3[8] & 0x3F));
  }
  unsigned int v7 = v6;
  *((_DWORD *)a3 + 16) = v5;
  unsigned int v8 = v5 + 63;
  if (v6 != (v5 + 63) >> 6)
  {
    uint64_t v9 = v8 >> 6;
    if (v6 > v9)
    {
      *((_DWORD *)a3 + 2) = v9;
      unsigned int v7 = v8 >> 6;
    }
    else
    {
      if (v9 > *((_DWORD *)a3 + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v9 != v6) {
        bzero((void *)(*a3 + 8 * v6), 8 * (v9 - v6));
      }
      unsigned int v7 = v9;
      *((_DWORD *)a3 + 2) = v9;
      int v5 = *((_DWORD *)a3 + 16);
    }
  }
  int v10 = v5 & 0x3F;
  if (v10) {
    *(void *)(*a3 + 8 * v7 - 8) &= ~(-1 << v10);
  }
  uint64_t v11 = *(void *)(a2 + 56);
  if (*(unsigned char *)(v11 + 104))
  {
    uint64_t v12 = *(unsigned int **)(v11 + 80);
    unint64_t v13 = *(unsigned int **)(v11 + 88);
    if (v12 != v13)
    {
      uint64_t v14 = *a3;
      do
      {
        unsigned int v15 = *v12;
        v12 += 3;
        *(void *)(v14 + (((unint64_t)v15 >> 3) & 0x1FFFFFF8)) |= 1 << v15;
      }
      while (v12 != v13);
    }
  }
}

void llvm::TargetFrameLowering::determineCalleeSaves(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  int v6 = *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a2[2] + 176))(a2[2]) + 16);
  uint64_t v7 = *(unsigned int *)(a3 + 8);
  if ((*(_DWORD *)(a3 + 64) & 0x3F) != 0) {
    *(void *)(*(void *)a3 + 8 * v7 - 8) &= ~(-1 << (*(_DWORD *)(a3 + 64) & 0x3F));
  }
  unsigned int v8 = v7;
  *(_DWORD *)(a3 + 64) = v6;
  unsigned int v9 = v6 + 63;
  if (v7 != (v6 + 63) >> 6)
  {
    uint64_t v10 = v9 >> 6;
    if (v7 > v10)
    {
      *(_DWORD *)(a3 + 8) = v10;
      unsigned int v8 = v9 >> 6;
    }
    else
    {
      if (v10 > *(_DWORD *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v10 != v7) {
        bzero((void *)(*(void *)a3 + 8 * v7), 8 * (v10 - v7));
      }
      unsigned int v8 = v10;
      *(_DWORD *)(a3 + 8) = v10;
      int v6 = *(_DWORD *)(a3 + 64);
    }
  }
  int v11 = v6 & 0x3F;
  if (v11) {
    *(void *)(*(void *)a3 + 8 * v8 - 8) &= ~(-1 << v11);
  }
  if ((*(unsigned char *)(a2[1] + 1042) & 8) != 0)
  {
    uint64_t v12 = *a2;
    if ((*(_DWORD *)(*a2 + 32) & 0xFu) - 7 <= 1
      && (llvm::Function::hasAddressTaken((llvm::Function *)*a2, 0, 0, 1, 0, 0) & 1) == 0)
    {
      uint64_t v17 = *(void *)(v12 + 112);
      if (v17)
      {
        if ((*(unsigned char *)(v17 + 15) & 0x40) != 0)
        {
          uint64_t v18 = *(void *)(v12 + 8);
          if (v18)
          {
            while (1)
            {
              uint64_t v19 = *(void *)(v18 + 24);
              if (*(unsigned char *)(v19 + 16) == 84 && (*(_WORD *)(v19 + 18) & 3u) - 1 < 2) {
                break;
              }
              uint64_t v18 = *(void *)(v18 + 8);
              if (!v18) {
                goto LABEL_25;
              }
            }
          }
          else
          {
LABEL_25:
            if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 344))(a1, *a2)) {
              return;
            }
          }
        }
      }
    }
  }
  unint64_t v13 = (void *)a2[5];
  if (*((unsigned char *)v13 + 144))
  {
    unsigned int v15 = (_WORD *)v13[19];
  }
  else
  {
    uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(*v13 + 16) + 176))(*(void *)(*v13 + 16));
    unsigned int v15 = (_WORD *)(*(uint64_t (**)(uint64_t, void))(*(void *)v14 + 32))(v14, *v13);
  }
  if (v15)
  {
    unsigned int v16 = (unsigned __int16)*v15;
    if (*v15)
    {
      unint64_t v20 = *(unsigned char **)(*a2 + 112);
      if (!v20
        || (v20[14] & 2) == 0
        && ((v20[16] & 1) == 0
         || (v20[16] & 0x20) == 0
         || (char)v20[21] < 0
         || ((*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 88))(a1, a2) & 1) == 0
         && (unsigned int v16 = (unsigned __int16)*v15, *v15)))
      {
        int v21 = *((unsigned __int8 *)a2 + 633);
        BOOL v22 = (void *)a2[5];
        unsigned int v23 = 1;
        do
        {
          if (v21 || llvm::MachineRegisterInfo::isPhysRegModified(v22, v16, 0)) {
            *(void *)(*(void *)a3 + 8 * (v16 >> 6)) |= 1 << v16;
          }
          unsigned int v16 = (unsigned __int16)v15[v23++];
        }
        while (v16);
      }
    }
  }
}

uint64_t llvm::TargetFrameLowering::isSafeForNoCSROpt(llvm::TargetFrameLowering *this, const llvm::Function *a2)
{
  if ((*((_DWORD *)this + 8) & 0xFu) - 7 > 1) {
    return 0;
  }
  hasAddressTakeuint64_t n = llvm::Function::hasAddressTaken(this, 0, 0, 1, 0, 0);
  uint64_t result = 0;
  if ((hasAddressTaken & 1) == 0)
  {
    uint64_t v5 = *((void *)this + 14);
    if (v5 && (*(unsigned char *)(v5 + 15) & 0x40) != 0)
    {
      uint64_t v6 = *((void *)this + 1);
      if (!v6) {
        return 1;
      }
      uint64_t result = 1;
      while (1)
      {
        uint64_t v7 = *(void *)(v6 + 24);
        if (*(unsigned char *)(v7 + 16) == 84 && (*(_WORD *)(v7 + 18) & 3u) - 1 < 2) {
          break;
        }
        uint64_t v6 = *(void *)(v6 + 8);
        if (!v6) {
          return result;
        }
      }
    }
    return 0;
  }
  return result;
}

unint64_t llvm::TargetFrameLowering::getStackAlignmentSkew(llvm::TargetFrameLowering *this, const llvm::MachineFunction *a2)
{
  if ((*(_WORD *)(*(void *)a2 + 18) & 0x3FF0) == 0x510) {
    return llvm::DataLayout::getPointerSize((llvm::DataLayout *)(*((void *)a2 + 1) + 16), *(_DWORD *)(*((void *)a2 + 1) + 20));
  }
  else {
    return 0;
  }
}

uint64_t llvm::TargetFrameLowering::allocateScavengingFrameIndexesNearIncomingSP(llvm::TargetFrameLowering *this, const llvm::MachineFunction *a2)
{
  uint64_t result = (*(uint64_t (**)(llvm::TargetFrameLowering *))(*(void *)this + 200))(this);
  if (result)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
    uint64_t result = (*(uint64_t (**)(void))(*(void *)v4 + 384))();
    if (result)
    {
      if ((*(unsigned int (**)(uint64_t, const llvm::MachineFunction *))(*(void *)v4 + 440))(v4, a2)) {
        return (*(unsigned int (**)(uint64_t, const llvm::MachineFunction *))(*(void *)v4 + 432))(v4, a2) ^ 1;
      }
      else {
        return 1;
      }
    }
  }
  return result;
}

uint64_t llvm::TargetFrameLowering::getDwarfFrameBase(llvm::TargetFrameLowering *this, const llvm::MachineFunction *a2)
{
  uint64_t v2 = *(void *)(*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  return (*(uint64_t (**)(void))(v2 + 552))() << 32;
}

uint64_t sub_1CC49BDE8()
{
  return 0;
}

uint64_t sub_1CC49BDF0()
{
  return 0;
}

uint64_t llvm::TargetInstrInfo::getRegClass(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, uint64_t a5)
{
  if (*(unsigned __int16 *)(a2 + 2) <= a3) {
    return 0;
  }
  uint64_t v5 = (unsigned __int16 *)(*(void *)(a2 + 40) + 6 * a3);
  uint64_t v6 = (__int16)*v5;
  if ((v5[1] & 1) == 0)
  {
    if ((v6 & 0x80000000) == 0) {
      return *(void *)(a4[30] + 8 * *v5);
    }
    return 0;
  }
  return (*(uint64_t (**)(void *, uint64_t, uint64_t))(*a4 + 240))(a4, a5, v6);
}

uint64_t llvm::TargetInstrInfo::getInlineAsmLength(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 72))(a3, a4);
  uint64_t v7 = 0;
  char v8 = 1;
  while (1)
  {
    unsigned int v9 = *(unsigned __int8 *)a2;
    if (v9 == 10)
    {
LABEL_10:
      char v8 = 1;
      goto LABEL_11;
    }
    if (!*a2) {
      return v7;
    }
    size_t v10 = strlen(*(const char **)(a3 + 40));
    if (strncmp(a2, *(const char **)(a3 + 40), v10)
      && (strncmp(a2, *(const char **)(a3 + 48), *(void *)(a3 + 56)) == 0 || (v8 & 1) == 0))
    {
      char v8 = 0;
    }
    else
    {
      if (v9 <= 0x20 && ((1 << v9) & 0x100003A00) != 0) {
        goto LABEL_10;
      }
      int v12 = strncmp(a2, ".space", 6uLL);
      int v13 = v6;
      if (!v12)
      {
        __endptr = 0;
        int v14 = strtol(a2 + 6, &__endptr, 10);
        int v15 = v14 & ~(v14 >> 31);
        for (uint64_t i = __endptr; ; ++i)
        {
          unsigned int v17 = *i;
          if (v17 > 0x20) {
            goto LABEL_20;
          }
          if (((1 << v17) & 0x100003A00) == 0) {
            break;
          }
        }
        if (((1 << v17) & 0x401) != 0)
        {
LABEL_19:
          int v13 = v15;
          goto LABEL_21;
        }
LABEL_20:
        int v18 = strncmp(i, *(const char **)(a3 + 48), *(void *)(a3 + 56));
        int v13 = v6;
        if (!v18) {
          goto LABEL_19;
        }
      }
LABEL_21:
      char v8 = 0;
      uint64_t v7 = (v13 + v7);
    }
LABEL_11:
    ++a2;
  }
}

void sub_1CC49C000(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = a2;
  if (a2)
  {
    uint64_t v4 = a2;
    if ((*a2 & 4) != 0) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  while ((*((_WORD *)v4 + 22) & 8) != 0)
    uint64_t v4 = (unsigned char *)*((void *)v4 + 1);
LABEL_4:
  uint64_t v5 = (unsigned char *)*((void *)v4 + 1);
  if (v5 != a2)
  {
    do
    {
      int v6 = (unsigned char *)*((void *)v2 + 1);
      uint64_t v7 = *(void *)(*((void *)v2 + 3) + 32);
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 728);
        if (v8) {
          (*(void (**)(uint64_t, unsigned char *))(*(void *)v8 + 32))(v8, v2);
        }
        uint64_t v9 = *((unsigned int *)v2 + 10);
        if (v9)
        {
          uint64_t v10 = *((void *)v2 + 4);
          uint64_t v11 = *(void *)(v7 + 40);
          uint64_t v12 = 32 * v9;
          do
          {
            if (!*(unsigned char *)v10)
            {
              uint64_t v13 = *(unsigned int *)(v10 + 4);
              if ((v13 & 0x80000000) != 0) {
                int v14 = (uint64_t *)(*(void *)(v11 + 24) + 16 * (v13 & 0x7FFFFFFF) + 8);
              }
              else {
                int v14 = (uint64_t *)(*(void *)(v11 + 272) + 8 * v13);
              }
              uint64_t v15 = *v14;
              uint64_t v17 = *(void *)(v10 + 16);
              uint64_t v16 = *(void *)(v10 + 24);
              if (v10 != *v14) {
                int v14 = (uint64_t *)(v17 + 24);
              }
              *int v14 = v16;
              if (v16) {
                uint64_t v18 = v16;
              }
              else {
                uint64_t v18 = v15;
              }
              *(void *)(v18 + 16) = v17;
              *(void *)(v10 + 16) = 0;
              *(void *)(v10 + 24) = 0;
            }
            v10 += 32;
            v12 -= 32;
          }
          while (v12);
        }
      }
      *((void *)v2 + 3) = 0;
      uint64_t v19 = (unint64_t *)*((void *)v2 + 1);
      unint64_t v20 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
      *uint64_t v19 = v20 | *v19 & 7;
      *(void *)(v20 + 8) = v19;
      *(void *)v2 &= 7uLL;
      *((void *)v2 + 1) = 0;
      uint64_t v21 = *(void *)(*(void *)(a1 + 40) + 32);
      BOOL v22 = (void *)*((void *)v2 + 4);
      if (v22)
      {
        uint64_t v23 = v2[47];
        int v24 = (uint64_t *)(v21 + 232);
        if (*(_DWORD *)(v21 + 240) <= v23) {
          sub_1CC34BDE0(v21 + 232, v23 + 1);
        }
        uint64_t v25 = *v24;
        *BOOL v22 = *(void *)(*v24 + 8 * v23);
        *(void *)(v25 + 8 * v23) = v22;
      }
      *(void *)uint64_t v2 = *(void *)(v21 + 224);
      *(void *)(v21 + 224) = v2;
      uint64_t v2 = v6;
    }
    while (v6 != v5);
  }
}

BOOL llvm::TargetInstrInfo::fixCommutedOpIndices(llvm::TargetInstrInfo *this, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  int v4 = *(_DWORD *)this;
  int v5 = *a2;
  if (*(_DWORD *)this == -1 && v5 == -1)
  {
    *(_DWORD *)this = a3;
LABEL_20:
    *a2 = a4;
    return 1;
  }
  if (v4 == -1)
  {
    if (v5 != a3)
    {
      if (v5 == a4)
      {
        *(_DWORD *)this = a3;
        return 1;
      }
      return 0;
    }
    *(_DWORD *)this = a4;
    return 1;
  }
  if (v5 == -1)
  {
    if (v4 != a3)
    {
      if (v4 == a4)
      {
        *a2 = a3;
        return 1;
      }
      return 0;
    }
    goto LABEL_20;
  }
  BOOL v8 = v4 == a4 && v5 == a3;
  return v4 == a3 && v5 == a4 || v8;
}

uint64_t llvm::TargetInstrInfo::isUnpredicatedTerminator(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2)
{
  uint64_t v2 = *(void *)(*((void *)a2 + 2) + 8);
  if ((*((_WORD *)a2 + 22) & 0xC) == 0 || (*((_WORD *)a2 + 22) & 4) != 0)
  {
    if ((v2 & 0x200) != 0)
    {
      uint64_t v4 = v2 & 0x400000;
      if ((*(void *)(*((void *)a2 + 2) + 8) & 0x500) != 0x400 && v4 != 0) {
        return (*(unsigned int (**)(llvm::TargetInstrInfo *))(*(void *)this + 768))(this) ^ 1;
      }
      return 1;
    }
    return 0;
  }
  if ((v2 & 0x200) == 0)
  {
    uint64_t v7 = a2;
    while ((*((_WORD *)v7 + 22) & 8) != 0)
    {
      uint64_t v7 = (const llvm::MachineInstr *)*((void *)v7 + 1);
      if ((*(unsigned char *)(*((void *)v7 + 2) + 9) & 2) != 0) {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  if ((v2 & 0x400) != 0)
  {
LABEL_21:
    if ((v2 & 0x100) == 0)
    {
      uint64_t v9 = a2;
      while ((*((_WORD *)v9 + 22) & 8) != 0)
      {
        uint64_t v9 = (const llvm::MachineInstr *)*((void *)v9 + 1);
        if (*(unsigned char *)(*((void *)v9 + 2) + 9)) {
          goto LABEL_25;
        }
      }
      return 1;
    }
  }
  else
  {
    BOOL v8 = a2;
    while ((*((_WORD *)v8 + 22) & 8) != 0)
    {
      BOOL v8 = (const llvm::MachineInstr *)*((void *)v8 + 1);
      if ((*(unsigned char *)(*((void *)v8 + 2) + 9) & 4) != 0) {
        goto LABEL_21;
      }
    }
  }
LABEL_25:
  for (uint64_t i = a2; ; uint64_t i = (const llvm::MachineInstr *)*((void *)i + 1))
  {
    uint64_t v11 = *((void *)i + 2);
    if ((*(unsigned char *)(v11 + 10) & 0x40) == 0 && *(_WORD *)v11 != 20) {
      break;
    }
    if ((*((_WORD *)i + 22) & 8) == 0) {
      return (*(unsigned int (**)(llvm::TargetInstrInfo *))(*(void *)this + 768))(this) ^ 1;
    }
  }
  return 1;
}

BOOL llvm::TargetInstrInfo::hasStoreToStackSlot(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 8);
  unint64_t v6 = *(void *)(a2 + 48);
  uint64_t v4 = (void *)(a2 + 48);
  uint64_t v5 = v6;
  if (v6 < 8)
  {
    unint64_t v7 = 0;
LABEL_17:
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    goto LABEL_6;
  }
  if ((v5 & 7) != 0)
  {
    BOOL v13 = (v5 & 0xFFFFFFFFFFFFFFF8) != 0 && (v5 & 7) == 3;
    unint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if (!v13) {
      unint64_t v7 = 0;
    }
  }
  else
  {
    unint64_t v7 = (unint64_t)v4;
    v5 &= 0xFFFFFFFFFFFFFFF8;
    *uint64_t v4 = v5;
    if (!v5)
    {
      unint64_t v7 = (unint64_t)v4;
      uint64_t v4 = 0;
      goto LABEL_6;
    }
  }
  if ((v5 & 7) != 0)
  {
    int v14 = (int *)(v5 & 0xFFFFFFFFFFFFFFF8);
    if ((v5 & 7) == 3 && v14 != 0)
    {
      uint64_t v16 = *v14;
      uint64_t v4 = v14 + 2;
      uint64_t v5 = v16;
      goto LABEL_6;
    }
    goto LABEL_17;
  }
  *uint64_t v4 = v5 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v5 = 1;
LABEL_6:
  BOOL v8 = &v4[v5];
  while ((void *)v7 != v8)
  {
    uint64_t v9 = *(void **)v7;
    if ((*(_WORD *)(*(void *)v7 + 32) & 2) != 0 && (*v9 & 4) != 0)
    {
      unint64_t v11 = *v9 & 0xFFFFFFFFFFFFFFF8;
      if (v11)
      {
        if (*(_DWORD *)(v11 + 8) == 4)
        {
          unint64_t v12 = *(unsigned int *)(a3 + 8);
          if (v12 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a3 + 8 * v12) = v9;
          ++*(_DWORD *)(a3 + 8);
        }
      }
    }
    v7 += 8;
  }
  return *(_DWORD *)(a3 + 8) != v3;
}

uint64_t llvm::TargetInstrInfo::reMaterialize(int a1, uint64_t a2, unint64_t *a3, unsigned int a4, uint64_t a5, llvm::MachineInstr *a6, void *a7)
{
  unint64_t v12 = llvm::MachineFunction::CloneMachineInstr(*(llvm::MachineFunction **)(a2 + 32), a6);
  llvm::MachineInstr::substituteRegister(v12, *(_DWORD *)(*(void *)(v12 + 32) + 4), a4, a5, a7);
  uint64_t v13 = *(void *)(a2 + 40);
  *(void *)(v12 + 24) = v13;
  uint64_t v14 = *(void *)(v13 + 32);
  uint64_t v15 = *(unsigned int *)(v12 + 40);
  if (v15)
  {
    uint64_t v18 = *(void *)(v12 + 32);
    uint64_t v19 = *(void *)(v14 + 40);
    uint64_t v20 = 32 * v15;
    do
    {
      if (!*(unsigned char *)v18)
      {
        uint64_t v21 = *(unsigned int *)(v18 + 4);
        if ((int)v21 >= 0) {
          BOOL v22 = (uint64_t *)(*(void *)(v19 + 272) + 8 * v21);
        }
        else {
          BOOL v22 = (uint64_t *)(*(void *)(v19 + 24) + 16 * (v21 & 0x7FFFFFFF) + 8);
        }
        uint64_t v23 = *v22;
        if (*v22)
        {
          uint64_t v24 = *(void *)(v23 + 16);
          *(void *)(v23 + 16) = v18;
          *(void *)(v18 + 16) = v24;
          if (*(unsigned char *)(v18 + 3))
          {
            *(void *)(v18 + 24) = v23;
          }
          else
          {
            *(void *)(v18 + 24) = 0;
            BOOL v22 = (uint64_t *)(v24 + 24);
          }
        }
        else
        {
          *(void *)(v18 + 16) = v18;
          *(void *)(v18 + 24) = 0;
        }
        *BOOL v22 = v18;
      }
      v18 += 32;
      v20 -= 32;
    }
    while (v20);
  }
  uint64_t result = *(void *)(v14 + 728);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)result + 24))(result, v12);
  }
  unint64_t v17 = *a3 & 0xFFFFFFFFFFFFFFF8;
  *(void *)unint64_t v12 = v17 | *(void *)v12 & 7;
  *(void *)(v12 + 8) = a3;
  *(void *)(v17 + 8) = v12;
  *a3 = *a3 & 7 | v12;
  return result;
}

const llvm::MachineInstr *llvm::TargetInstrInfo::duplicate(uint64_t a1, uint64_t a2, uint64_t *a3, const llvm::MachineInstr *a4)
{
  return llvm::MachineFunction::cloneMachineInstrBundle(*(void *)(a2 + 32), a2, a3, a4);
}

unint64_t llvm::TargetInstrInfo::foldMemoryOperand(void *a1, uint64_t a2, __int32 *a3, size_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v13 = 0;
  if (a4)
  {
    uint64_t v14 = 4 * a4;
    uint64_t v15 = a3;
    do
    {
      unsigned int v16 = *v15++;
      if (*(unsigned char *)(*(void *)(a2 + 32) + 32 * v16 + 3)) {
        __int16 v17 = 2;
      }
      else {
        __int16 v17 = 1;
      }
      v13 |= v17;
      v14 -= 4;
    }
    while (v14);
  }
  uint64_t v88 = *(void *)(a2 + 24);
  uint64_t v18 = *(void *)(v88 + 32);
  uint64_t v19 = *(void *)(v18 + 56);
  uint64_t v20 = (*(uint64_t (**)(void))(**(void **)(v18 + 16) + 176))(*(void *)(v18 + 16));
  uint64_t v21 = v20;
  if ((v13 & 2) != 0)
  {
    uint64_t v22 = *(void *)(*(void *)(v19 + 8) + 40 * (*(_DWORD *)(v19 + 32) + a5) + 8);
  }
  else
  {
    uint64_t v22 = 0;
    if (a4)
    {
      uint64_t v23 = 4 * a4;
      uint64_t v24 = a3;
      do
      {
        unint64_t v25 = ((unint64_t)*(unsigned int *)(*(void *)(a2 + 32) + 32 * *v24) >> 8) & 0xFFF;
        uint64_t v26 = *(void *)(*(void *)(v19 + 8) + 40 * (*(_DWORD *)(v19 + 32) + a5) + 8);
        if (v25)
        {
          unint64_t v27 = *(unsigned __int16 *)(*(void *)(v20 + 96) + 4 * v25 + 2);
          BOOL v28 = v27 && (v27 & 7) == 0;
          uint64_t v26 = *(void *)(*(void *)(v19 + 8) + 40 * (*(_DWORD *)(v19 + 32) + a5) + 8);
          if (v28) {
            uint64_t v26 = v27 >> 3;
          }
        }
        if (v22 <= v26) {
          uint64_t v22 = v26;
        }
        ++v24;
        v23 -= 4;
      }
      while (v23);
    }
  }
  unsigned int v29 = **(unsigned __int16 **)(a2 + 16);
  BOOL v30 = v29 > 0x1F;
  unsigned int v31 = (1 << v29) & 0x8A000000;
  if (!v30 && v31 != 0)
  {
    uint64_t v33 = sub_1CC49CD34((llvm::MachineFunction *)v18, a2, a3, a4, a5, a1);
    if (!v33)
    {
LABEL_27:
      unint64_t v34 = 0;
      if (a4 != 1) {
        return v34;
      }
      if (**(_WORD **)(a2 + 16) != 19 || *(_DWORD *)(a2 + 40) != 2) {
        return v34;
      }
      uint64_t v36 = *a3;
      uint64_t v37 = *(void *)(a2 + 32);
      if ((*(_DWORD *)(v37 + 32 * v36) & 0xFFF00) != 0) {
        return 0;
      }
      uint64_t v38 = (_DWORD *)(v37 + 32 * (1 - v36));
      if ((*v38 & 0xFFF00) != 0) {
        return 0;
      }
      int v44 = *(_DWORD *)(v37 + 32 * v36 + 4);
      unint64_t v45 = v38[1];
      uint64_t v46 = *(void *)(*(void *)(*(void *)(a2 + 24) + 32) + 40);
      uint64_t v47 = v44 & 0x7FFFFFFF;
      uint64_t v48 = *(void *)(v46 + 24);
      uint64_t v49 = (void *)(*(void *)(v48 + 16 * v47) & 0xFFFFFFFFFFFFFFF8);
      if ((v45 - 1) > 0x3FFFFFFE)
      {
        unsigned int v62 = *(unsigned __int16 *)(*(void *)(*(void *)(v48 + 16 * (v45 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8) + 24);
        if (((*(_DWORD *)(v49[1] + ((v62 >> 3) & 0x1FFCLL)) >> v62) & 1) == 0) {
          return 0;
        }
      }
      else if (v38[1] >> 3 >= *(unsigned __int16 *)(*v49 + 22) {
             || ((*(unsigned __int8 *)(*(void *)(*v49 + 8) + (v45 >> 3)) >> (v45 & 7)) & 1) == 0)
      }
      {
        return 0;
      }
      __int16 v63 = *(_WORD *)(a2 + 44);
      unint64_t v64 = a2;
      if ((v63 & 4) != 0)
      {
        unint64_t v64 = a2;
        do
          unint64_t v64 = *(void *)v64 & 0xFFFFFFFFFFFFFFF8;
        while ((*(_WORD *)(v64 + 44) & 4) != 0);
      }
      uint64_t v65 = *(void *)(a6 + 288);
      uint64_t v66 = a2;
      if ((v63 & 8) != 0)
      {
        uint64_t v66 = a2;
        do
          uint64_t v66 = *(void *)(v66 + 8);
        while ((*(_WORD *)(v66 + 44) & 8) != 0);
      }
      uint64_t v67 = *(void *)(v66 + 8);
      if (v64 != v67)
      {
        while (1)
        {
          unsigned int v68 = **(unsigned __int16 **)(v64 + 16);
          BOOL v30 = v68 > 0x17;
          int v69 = (1 << v68) & 0x83E000;
          if (v30 || v69 == 0) {
            break;
          }
          unint64_t v64 = *(void *)(v64 + 8);
          if (v64 == v67)
          {
            unint64_t v64 = *(void *)(v66 + 8);
            break;
          }
        }
      }
      uint64_t v71 = *(void *)(v65 + 368);
      uint64_t v72 = *(unsigned int *)(v65 + 384);
      if (v72)
      {
        LODWORD(v73) = ((v64 >> 4) ^ (v64 >> 9)) & (v72 - 1);
        uint64_t v74 = (uint64_t *)(v71 + 16 * v73);
        uint64_t v75 = *v74;
        if (v64 == *v74) {
          goto LABEL_82;
        }
        int v76 = 1;
        while (v75 != -4096)
        {
          int v77 = v73 + v76++;
          uint64_t v73 = v77 & (v72 - 1);
          uint64_t v75 = *(void *)(v71 + 16 * v73);
          if (v64 == v75)
          {
            uint64_t v74 = (uint64_t *)(v71 + 16 * v73);
            goto LABEL_82;
          }
        }
      }
      uint64_t v74 = (uint64_t *)(v71 + 16 * v72);
LABEL_82:
      *(void *)&v91[0] = v74[1];
      uint64_t LiveSubranges = -1;
      if (a8 && (v45 & 0x80000000) != 0)
      {
        uint64_t LiveSubranges = llvm::LiveIntervals::getLiveSubranges(a6, a8, v46, v91);
        LODWORD(v45) = v38[1];
      }
      if (v13 == 2) {
        (*(void (**)(void *, uint64_t, uint64_t, void, void, void, void *, uint64_t, uint64_t))(*a1 + 456))(a1, v88, a2, v45, (*v38 >> 26) & ~HIBYTE(*v38) & 1, a5, v49, v21, LiveSubranges);
      }
      else {
        (*(void (**)(void *, uint64_t, uint64_t, void, void, void *, uint64_t, uint64_t))(*a1 + 472))(a1, v88, a2, v45, a5, v49, v21, LiveSubranges);
      }
      unint64_t v34 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
      if (!v34 || (*(unsigned char *)v34 & 4) == 0)
      {
        while ((*(_WORD *)(v34 + 44) & 4) != 0)
          unint64_t v34 = *(void *)v34 & 0xFFFFFFFFFFFFFFF8;
      }
      return v34;
    }
    unint64_t v34 = (unint64_t)v33;
    uint64_t v50 = *(void *)(v88 + 40);
    *((void *)v33 + 3) = v50;
    uint64_t v51 = *(void *)(v50 + 32);
    uint64_t v52 = *((unsigned int *)v33 + 10);
    if (v52)
    {
      uint64_t v80 = *((void *)v33 + 4);
      uint64_t v81 = *(void *)(v51 + 40);
      uint64_t v82 = 32 * v52;
      do
      {
        if (!*(unsigned char *)v80)
        {
          uint64_t v83 = *(unsigned int *)(v80 + 4);
          if ((int)v83 >= 0) {
            long long v84 = (uint64_t *)(*(void *)(v81 + 272) + 8 * v83);
          }
          else {
            long long v84 = (uint64_t *)(*(void *)(v81 + 24) + 16 * (v83 & 0x7FFFFFFF) + 8);
          }
          uint64_t v85 = *v84;
          if (*v84)
          {
            uint64_t v86 = *(void *)(v85 + 16);
            *(void *)(v85 + 16) = v80;
            *(void *)(v80 + 16) = v86;
            if (*(unsigned char *)(v80 + 3))
            {
              *(void *)(v80 + 24) = v85;
            }
            else
            {
              *(void *)(v80 + 24) = 0;
              long long v84 = (uint64_t *)(v86 + 24);
            }
          }
          else
          {
            *(void *)(v80 + 16) = v80;
            *(void *)(v80 + 24) = 0;
          }
          *long long v84 = v80;
        }
        v80 += 32;
        v82 -= 32;
      }
      while (v82);
    }
    uint64_t v53 = *(void *)(v51 + 728);
    if (v53) {
      (*(void (**)(uint64_t, unint64_t))(*(void *)v53 + 24))(v53, v34);
    }
    unint64_t v54 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v34 = v54 | *(void *)v34 & 7;
    *(void *)(v34 + 8) = a2;
    *(void *)(v54 + 8) = v34;
    *(void *)a2 = *(void *)a2 & 7 | v34;
    goto LABEL_55;
  }
  uint64_t v40 = (*(uint64_t (**)(void *, uint64_t, uint64_t, __int32 *, size_t, uint64_t, void, uint64_t, uint64_t))(*a1 + 592))(a1, v18, a2, a3, a4, a2, a5, a6, a7);
  if (!v40) {
    goto LABEL_27;
  }
  unint64_t v34 = v40;
  unint64_t v41 = *(void *)(v40 + 48);
  if (v41 < 8) {
    goto LABEL_55;
  }
  if ((v41 & 7) == 0)
  {
    *(void *)(v40 + 48) = v41 & 0xFFFFFFFFFFFFFFF8;
    return v34;
  }
  int64x2_t v42 = (_DWORD *)(v41 & 0xFFFFFFFFFFFFFFF8);
  BOOL v43 = (*(void *)(v40 + 48) & 7) != 3 || v42 == 0;
  if (v43 || !*v42)
  {
LABEL_55:
    int v55 = (unint64_t *)(a2 + 48);
    unint64_t v56 = *(void *)(a2 + 48);
    if (v56 < 8)
    {
      int v55 = 0;
      uint64_t v57 = 0;
    }
    else if ((v56 & 7) != 0)
    {
      int v55 = 0;
      uint64_t v57 = 0;
      if ((*(void *)(a2 + 48) & 7) == 3)
      {
        long long v78 = (int *)(v56 & 0xFFFFFFFFFFFFFFF8);
        if (v78)
        {
          uint64_t v57 = *v78;
          int v55 = (unint64_t *)(v78 + 2);
        }
      }
    }
    else
    {
      unint64_t *v55 = v56 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v57 = 1;
    }
    llvm::MachineInstr::setMemRefs(v34, (uint64_t *)v18, v55, v57);
    FixedStacunint64_t k = llvm::PseudoSourceValueManager::getFixedStack(*(uint64_t ***)(v18 + 432), a5);
    v92[0] = (unint64_t)FixedStack | 4;
    v92[1] = 0;
    char v94 = 0;
    if (FixedStack) {
      int v59 = *((_DWORD *)FixedStack + 3);
    }
    else {
      int v59 = 0;
    }
    int v93 = v59;
    char v60 = *(unsigned char *)(*(void *)(v19 + 8) + 40 * (*(_DWORD *)(v19 + 32) + a5) + 16);
    memset(v91, 0, sizeof(v91));
    unint64_t MachineMemOperand = (llvm::MachineMemOperand *)llvm::MachineFunction::getMachineMemOperand(v18, (uint64_t)v92, v13, v22, v60, v91, 0, 1, 0, 0, 0);
    llvm::MachineInstr::addMemOperand((llvm::MachineInstr *)v34, (llvm::MachineFunction *)v18, MachineMemOperand);
    llvm::MachineInstr::cloneInstrSymbols((const llvm::MachineInstr *)v34, (llvm::MachineFunction *)v18, (const llvm::MachineInstr *)a2);
  }
  return v34;
}

llvm::MachineInstr *sub_1CC49CD34(llvm::MachineFunction *a1, uint64_t a2, __int32 *a3, size_t a4, int a5, void *a6)
{
  unint64_t v10 = (*(uint64_t (**)(void *))(*a6 + 496))(a6);
  uint64_t v11 = HIDWORD(v10);
  uint64_t v12 = *(unsigned int *)(a2 + 40);
  if (!a4)
  {
    LODWORD(v16) = *(_DWORD *)(a2 + 40);
LABEL_10:
    uint64_t v18 = a6[1] + 48 * **(unsigned __int16 **)(a2 + 16);
    uint64_t v19 = *(unsigned __int8 **)(a2 + 56);
    uint64_t v40 = v19;
    if (v19) {
      llvm::MetadataTracking::track((uint64_t)&v40, v19, 2);
    }
    __int16 v17 = llvm::MachineFunction::CreateMachineInstr(a1, v18, &v40, 1);
    if (!v40) {
      goto LABEL_16;
    }
    int v20 = *v40;
    if ((v20 - 4) > 0x1E)
    {
      if ((v20 - 3) >= 0xFFFFFFFE) {
        uint64_t v33 = v40;
      }
      else {
        uint64_t v33 = 0;
      }
      if ((v20 - 3) < 0xFFFFFFFE)
      {
        if (v20 == 3) {
          *((void *)v40 + 1) = 0;
        }
        goto LABEL_16;
      }
      unint64_t v34 = (unint64_t)(v33 + 8);
    }
    else
    {
      if ((v40[1] & 0x7F) != 2 && !*((_DWORD *)v40 + 3)) {
        goto LABEL_16;
      }
      uint64_t v35 = *((void *)v40 + 2);
      if ((v35 & 4) == 0) {
        goto LABEL_16;
      }
      unint64_t v34 = v35 & 0xFFFFFFFFFFFFFFF8;
      if (!v34) {
        goto LABEL_16;
      }
    }
    unint64_t v41 = &v40;
    sub_1CC5FA668(v34 + 16, &v41);
LABEL_16:
    uint64_t v21 = 32 * v11;
    if (v11)
    {
      uint64_t v22 = 0;
      do
      {
        if (32 * v16 != v22) {
          llvm::MachineInstr::addOperand(v17, a1, (const llvm::MachineOperand *)(*(void *)(a2 + 32) + v22));
        }
        v22 += 32;
      }
      while (v21 != v22);
    }
    unsigned int v23 = *(_DWORD *)(a2 + 40);
    if (v23 > v11)
    {
      unsigned int v36 = v16;
      do
      {
        uint64_t v24 = *(void *)(a2 + 32);
        int v25 = *(_DWORD *)(v24 + v21);
        int v26 = v25 & 0x10000FF;
        int v27 = v25 & 0xF00000;
        if (v26) {
          BOOL v28 = 1;
        }
        else {
          BOOL v28 = v27 == 0;
        }
        unsigned int TiedOperandIdx = v23;
        if (!v28) {
          unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx((llvm::MachineInstr *)a2, v11);
        }
        BOOL v30 = wmemchr(a3, v11, a4);
        unsigned int v31 = &a3[a4];
        if (v30) {
          unsigned int v31 = v30;
        }
        if (a4 == v31 - a3)
        {
          llvm::MachineInstr::addOperand(v17, a1, (const llvm::MachineOperand *)(v24 + v21));
          if (TiedOperandIdx < v23) {
            llvm::MachineInstr::tieOperands((uint64_t)v17, (__PAIR64__(TiedOperandIdx, v36) - TiedOperandIdx) >> 32, *((_DWORD *)v17 + 10) - 1);
          }
        }
        else
        {
          uint64_t v39 = 0;
          if (((*(uint64_t (**)(void *, unint64_t, void, char *, uint64_t *, llvm::MachineFunction *))(*a6 + 136))(a6, *(void *)(*(void *)(*((void *)a1 + 5) + 24) + 16 * (*(_DWORD *)(v24 + v21 + 4) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, (*(_DWORD *)(v24 + v21) >> 8) & 0xFFF, (char *)&v39 + 4, &v39, a1) & 1) == 0)llvm::report_fatal_error((llvm *)"cannot spill patchpoint subregister operand", (const llvm::Twine *)1); {
          LODWORD(v41) = 1;
          }
          uint64_t v42 = 0;
          uint64_t v43 = 1;
          llvm::MachineInstr::addOperand(v17, a1, (const llvm::MachineOperand *)&v41);
          LODWORD(v41) = 1;
          uint64_t v42 = 0;
          uint64_t v43 = HIDWORD(v39);
          llvm::MachineInstr::addOperand(v17, a1, (const llvm::MachineOperand *)&v41);
          LODWORD(v41) = 5;
          uint64_t v42 = 0;
          LODWORD(v43) = a5;
          llvm::MachineInstr::addOperand(v17, a1, (const llvm::MachineOperand *)&v41);
          LODWORD(v41) = 1;
          uint64_t v42 = 0;
          uint64_t v43 = v39;
          llvm::MachineInstr::addOperand(v17, a1, (const llvm::MachineOperand *)&v41);
        }
        uint64_t v11 = (v11 + 1);
        v21 += 32;
      }
      while (v23 != v11);
    }
    return v17;
  }
  uint64_t v13 = 4 * a4;
  uint64_t v14 = a3;
  while (1)
  {
    uint64_t v15 = *v14;
    uint64_t v16 = v15;
    if (v15 >= v10)
    {
      uint64_t v16 = v12;
      if (v15 < HIDWORD(v10)) {
        return 0;
      }
    }
    if ((*(unsigned char *)(*(void *)(a2 + 32) + 32 * v15 + 2) & 0xF0) != 0) {
      return 0;
    }
    ++v14;
    uint64_t v12 = v16;
    v13 -= 4;
    if (!v13) {
      goto LABEL_10;
    }
  }
}

BOOL llvm::TargetInstrInfo::isReassociationCandidate(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, BOOL *a3)
{
  if (!(*(unsigned int (**)(llvm::TargetInstrInfo *))(*(void *)this + 536))(this)
    || !(*(unsigned int (**)(llvm::TargetInstrInfo *, const llvm::MachineInstr *, void))(*(void *)this + 544))(this, a2, *((void *)a2 + 3)))
  {
    return 0;
  }

  return llvm::TargetInstrInfo::hasReassociableSibling(this, a2, a3);
}

BOOL llvm::TargetInstrInfo::getMachineCombinerPatterns(llvm::TargetInstrInfo *a1, const llvm::MachineInstr *a2, uint64_t a3)
{
  BOOL v11 = 0;
  BOOL isReassociationCandidate = llvm::TargetInstrInfo::isReassociationCandidate(a1, a2, &v11);
  if (isReassociationCandidate)
  {
    unsigned int v5 = *(_DWORD *)(a3 + 8);
    unsigned int v6 = *(_DWORD *)(a3 + 12);
    if (v11)
    {
      if (v5 >= v6) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a3 + 4 * v5) = 1;
      unsigned int v7 = *(_DWORD *)(a3 + 12);
      unsigned int v8 = *(_DWORD *)(a3 + 8) + 1;
      *(_DWORD *)(a3 + 8) = v8;
      int v9 = 3;
    }
    else
    {
      if (v5 >= v6) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a3 + 4 * v5) = 0;
      unsigned int v7 = *(_DWORD *)(a3 + 12);
      unsigned int v8 = *(_DWORD *)(a3 + 8) + 1;
      *(_DWORD *)(a3 + 8) = v8;
      int v9 = 2;
    }
    if (v8 >= v7) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)a3 + 4 * v8) = v9;
    ++*(_DWORD *)(a3 + 8);
  }
  return isReassociationCandidate;
}

uint64_t llvm::TargetInstrInfo::isReallyTriviallyReMaterializableGeneric(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, llvm::AAResults *a3)
{
  uint64_t v3 = *((unsigned int *)a2 + 10);
  if (!v3) {
    return 0;
  }
  unsigned int v5 = (_DWORD *)*((void *)a2 + 4);
  if (*v5) {
    return 0;
  }
  uint64_t v7 = *(void *)(*((void *)a2 + 3) + 32);
  unsigned int v8 = *(void **)(v7 + 40);
  int v9 = v5[1];
  if ((*v5 & 0xFFF00) != 0 && v9 < 0)
  {
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
    uint64_t v13 = v5 + 1;
    do
    {
      unsigned int v14 = *(v13 - 1);
      if (!(_BYTE)v14 && *v13 == v9)
      {
        int v15 = (v14 >> 28) & 1;
        if ((v14 & 0xFFF00) == 0) {
          int v15 = 1;
        }
        int v16 = v15 | v12;
        int v17 = v15 ^ 1 | v10;
        if ((v14 & 0x1000000) != 0) {
          int v12 = v16;
        }
        else {
          v11 |= (v14 & 0x10000000) == 0;
        }
        if ((v14 & 0x1000000) != 0) {
          int v10 = v17;
        }
      }
      v13 += 8;
      --v3;
    }
    while (v3);
    if ((v11 | v10 & ~v12)) {
      return 0;
    }
  }
  int v36 = 0;
  if ((*(unsigned int (**)(llvm::TargetInstrInfo *, const llvm::MachineInstr *, int *))(*(void *)this
                                                                                                  + 64))(this, a2, &v36))
  {
    uint64_t v18 = *(void *)(v7 + 56);
    if (!*(unsigned char *)(v18 + 654))
    {
      if (*(unsigned char *)(*(void *)(v18 + 8) + 40 * (*(_DWORD *)(v18 + 32) + v36) + 17)) {
        return 1;
      }
    }
  }
  __int16 v19 = *((_WORD *)a2 + 22);
  BOOL v20 = (v19 & 0xC) == 0 || (v19 & 4) != 0;
  uint64_t v21 = (unsigned __int16 *)*((void *)a2 + 2);
  uint64_t v22 = *((void *)v21 + 1);
  if (v20)
  {
    if ((v22 & 0x800000) != 0) {
      return 0;
    }
  }
  else
  {
    if ((v22 & 0x800000) != 0) {
      return 0;
    }
    unsigned int v31 = a2;
    uint64_t result = 0;
    while ((*((_WORD *)v31 + 22) & 8) != 0)
    {
      unsigned int v31 = (const llvm::MachineInstr *)*((void *)v31 + 1);
      if ((*(unsigned char *)(*((void *)v31 + 2) + 10) & 0x80) != 0) {
        return result;
      }
    }
  }
  unsigned int v23 = *v21 - 1;
  if (v23 <= 1 && (*(unsigned char *)(*((void *)a2 + 4) + 48) & 0x10) != 0) {
    return 0;
  }
  if (v20)
  {
    if ((v22 & 0x100000) == 0)
    {
      if ((v22 & 0x200000) == 0) {
        goto LABEL_28;
      }
      goto LABEL_64;
    }
    return 0;
  }
  if ((v22 & 0x100000) != 0) {
    return 0;
  }
  char v32 = a2;
  uint64_t result = 0;
  while ((*((_WORD *)v32 + 22) & 8) != 0)
  {
    char v32 = (const llvm::MachineInstr *)*((void *)v32 + 1);
    if ((*(unsigned char *)(*((void *)v32 + 2) + 10) & 0x10) != 0) {
      return result;
    }
  }
  if ((v22 & 0x200000) == 0)
  {
    uint64_t v33 = a2;
    while ((*((_WORD *)v33 + 22) & 8) != 0)
    {
      uint64_t v33 = (const llvm::MachineInstr *)*((void *)v33 + 1);
      if ((*(unsigned char *)(*((void *)v33 + 2) + 10) & 0x20) != 0) {
        goto LABEL_64;
      }
    }
    goto LABEL_67;
  }
LABEL_64:
  if ((*((_WORD *)a2 + 22) & 0x4000) == 0) {
    return 0;
  }
LABEL_67:
  if (!v20)
  {
    if ((v22 & 0x1000000) != 0) {
      return 0;
    }
    unint64_t v34 = a2;
    uint64_t result = 0;
    while ((*((_WORD *)v34 + 22) & 8) != 0)
    {
      unint64_t v34 = (const llvm::MachineInstr *)*((void *)v34 + 1);
      if (*(unsigned char *)(*((void *)v34 + 2) + 11)) {
        return result;
      }
    }
    if (v23 < 2) {
      return 0;
    }
LABEL_30:
    if (v20)
    {
      if ((v22 & 0x80000) == 0) {
        goto LABEL_33;
      }
    }
    else if ((v22 & 0x80000) == 0)
    {
      uint64_t v35 = a2;
      while ((*((_WORD *)v35 + 22) & 8) != 0)
      {
        uint64_t v35 = (const llvm::MachineInstr *)*((void *)v35 + 1);
        if ((*(unsigned char *)(*((void *)v35 + 2) + 10) & 8) != 0) {
          goto LABEL_32;
        }
      }
      goto LABEL_33;
    }
LABEL_32:
    uint64_t result = llvm::MachineInstr::isDereferenceableInvariantLoad(a2, a3);
    if (!result) {
      return result;
    }
LABEL_33:
    uint64_t v25 = *((unsigned int *)a2 + 10);
    if (v25)
    {
      uint64_t v26 = *((void *)a2 + 4);
      uint64_t v27 = 32 * v25;
      for (uint64_t i = (unsigned int *)(v26 + 4); ; i += 8)
      {
        int v29 = *(i - 1);
        if (!(_BYTE)v29)
        {
          unsigned int v30 = *i;
          if (*i)
          {
            if (v30 >> 30)
            {
              uint64_t result = 0;
              if ((v29 & 0x1000000) == 0 || v30 != v9) {
                return result;
              }
            }
            else if ((v29 & 0x1000000) != 0 || (llvm::MachineRegisterInfo::isConstantPhysReg(v8, v30) & 1) == 0)
            {
              return 0;
            }
          }
        }
        v27 -= 32;
        if (!v27) {
          return 1;
        }
      }
    }
    return 1;
  }
LABEL_28:
  uint64_t result = 0;
  if ((v22 & 0x1000000) == 0 && v23 >= 2) {
    goto LABEL_30;
  }
  return result;
}

uint64_t llvm::TargetInstrInfo::getSPAdjust(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2)
{
  uint64_t v4 = *(void *)(*(void *)(*((void *)a2 + 3) + 32) + 16);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 112))(v4);
  int v6 = *((_DWORD *)this + 16);
  int v7 = *((_DWORD *)this + 17);
  int v8 = **((unsigned __int16 **)a2 + 2);
  if (v6 != v8 && v7 != v8) {
    return 0;
  }
  int v11 = *(_DWORD *)(v5 + 8);
  uint64_t v12 = *(void *)(*((void *)a2 + 4) + 16);
  if ((v12 & 0x80000000) != 0) {
    uint64_t result = -(((1 << *(unsigned char *)(v5 + 12)) + -*(_DWORD *)(*((void *)a2 + 4) + 16) - 1) & -(1 << *(unsigned char *)(v5 + 12)));
  }
  else {
    uint64_t result = ((1 << *(unsigned char *)(v5 + 12)) + v12 - 1) & -(1 << *(unsigned char *)(v5 + 12));
  }
  if (v11 == 1)
  {
    if (v7 == v8) {
      return -(int)result;
    }
  }
  else if (v6 == v8)
  {
    return -(int)result;
  }
  return result;
}

BOOL llvm::TargetInstrInfo::isSchedulingBoundary(llvm::TargetInstrInfo *this, const llvm::MachineInstr *a2, const llvm::MachineBasicBlock *a3, const llvm::MachineFunction *a4)
{
  int v6 = (unsigned __int16 *)*((void *)a2 + 2);
  uint64_t v7 = *((void *)v6 + 1);
  if ((*((_WORD *)a2 + 22) & 0xC) != 0 && (*((_WORD *)a2 + 22) & 4) == 0)
  {
    if ((v7 & 0x200) != 0) {
      return 1;
    }
    uint64_t v12 = a2;
    BOOL result = 1;
    while ((*((_WORD *)v12 + 22) & 8) != 0)
    {
      uint64_t v12 = (const llvm::MachineInstr *)*((void *)v12 + 1);
      if ((*(unsigned char *)(*((void *)v12 + 2) + 9) & 2) != 0) {
        return result;
      }
    }
  }
  else if ((v7 & 0x200) != 0)
  {
    return 1;
  }
  if (*v6 - 2 >= 5)
  {
    uint64_t v9 = (*(uint64_t (**)(void))(**((void **)a4 + 2) + 120))(*((void *)a4 + 2));
    uint64_t v10 = (*(uint64_t (**)(void))(**((void **)a4 + 2) + 176))(*((void *)a4 + 2));
    return llvm::MachineInstr::findRegisterDefOperandIdx((uint64_t)a2, *(_DWORD *)(v9 + 88), 0, 1, v10) != -1;
  }
  return 1;
}

BOOL llvm::TargetInstrInfo::usePreRAHazardRecognizer(llvm::TargetInstrInfo *this)
{
  return byte_1EBCD4398 == 0;
}

void llvm::TargetInstrInfo::CreateTargetMIHazardRecognizer()
{
}

uint64_t llvm::TargetInstrInfo::defaultDefLatency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned __int16 **)(a3 + 16);
  int v5 = *v4;
  if ((v5 - 9) <= 0x3C && ((1 << (v5 - 9)) & 0x1000000000000605) != 0 || v5 == 0) {
    return 0;
  }
  uint64_t v8 = *((void *)v4 + 1);
  if ((v8 & 0x10) != 0) {
    return 0;
  }
  if ((v5 - 1) <= 1 && (*(unsigned char *)(*(void *)(a3 + 32) + 48) & 8) != 0) {
    return *(unsigned int *)(a2 + 12);
  }
  __int16 v9 = *(_WORD *)(a3 + 44);
  if ((v9 & 0xC) != 0 && (v9 & 4) == 0)
  {
    if ((v8 & 0x80000) != 0) {
      return *(unsigned int *)(a2 + 12);
    }
    while ((*(_WORD *)(a3 + 44) & 8) != 0)
    {
      a3 = *(void *)(a3 + 8);
      if ((*(unsigned char *)(*(void *)(a3 + 16) + 10) & 8) != 0) {
        return *(unsigned int *)(a2 + 12);
      }
    }
  }
  else if ((v8 & 0x80000) != 0)
  {
    return *(unsigned int *)(a2 + 12);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 984))(a1)) {
    return *(unsigned int *)(a2 + 16);
  }
  else {
    return 1;
  }
}

uint64_t llvm::TargetInstrInfo::getRegSequenceInputs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (**(_WORD **)(a2 + 16) == 18)
  {
    int v4 = *(_DWORD *)(a2 + 40);
    if (v4 != 1)
    {
      unsigned int v5 = 1;
      do
      {
        uint64_t v6 = *(void *)(a2 + 32);
        uint64_t v7 = v5;
        unsigned int v8 = *(_DWORD *)(v6 + 32 * v5);
        if ((v8 & 0x10000000) == 0)
        {
          uint64_t v9 = *(unsigned int *)(v6 + 32 * v7 + 4);
          uint64_t v10 = *(void *)(v6 + 32 * (v7 + 1) + 16);
          unint64_t v11 = *(unsigned int *)(a4 + 8);
          if (v11 >= *(unsigned int *)(a4 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          unint64_t v12 = v9 | ((unint64_t)((v8 >> 8) & 0xFFF) << 32);
          uint64_t v13 = *(void *)a4 + 12 * v11;
          *(void *)uint64_t v13 = v12;
          *(_DWORD *)(v13 + 8) = v10;
          ++*(_DWORD *)(a4 + 8);
        }
        unsigned int v5 = v7 + 2;
      }
      while (v4 != v7 + 2);
    }
    return 1;
  }
  else
  {
    int v15 = *(uint64_t (**)(void))(*(void *)a1 + 608);
    return v15();
  }
}

void llvm::TargetInstrInfo::createMIROperandComment(const llvm::MachineInstr *a1@<X1>, const llvm::MachineOperand *a2@<X2>, const llvm::TargetRegisterInfo *a3@<X4>, unsigned int a4@<W3>, uint64_t a5@<X8>)
{
  if (**((unsigned __int16 **)a1 + 2) - 1 >= 2)
  {
    *(unsigned char *)(a5 + 23) = 0;
    *(unsigned char *)a5 = 0;
    return;
  }
  v45[0] = 0;
  v45[1] = 0;
  uint64_t v46 = 0;
  int v37 = 0;
  char v41 = 0;
  uint64_t v42 = 0;
  int v44 = v45;
  int v43 = 0;
  int v36 = &unk_1F2646F30;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  std::string __dst = 0;
  if (a4 == 1)
  {
    sub_1CD583FB4((uint64_t)&v34, *((_DWORD *)a2 + 4));
    uint64_t v9 = v34;
    uint64_t v10 = v35;
    if (v34 != v35)
    {
      char v11 = 1;
      do
      {
        uint64_t v13 = *v9;
        size_t v12 = (size_t)v9[1];
        unsigned int v14 = (char *)__dst;
        if ((v11 & 1) == 0)
        {
          if (v39 == __dst)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v36, " ", 1uLL);
            unsigned int v14 = (char *)__dst;
          }
          else
          {
            *(unsigned char *)std::string __dst = 32;
            unsigned int v14 = (char *)__dst + 1;
            std::string __dst = (char *)__dst + 1;
          }
        }
        if (v12 <= v39 - v14)
        {
          if (v12)
          {
            memcpy(v14, v13, v12);
            std::string __dst = (char *)__dst + v12;
          }
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v36, (const char *)v13, v12);
        }
        char v11 = 0;
        v9 += 2;
      }
      while (v9 != v10);
      uint64_t v9 = v34;
    }
    if (v9)
    {
      uint64_t v35 = v9;
      operator delete(v9);
    }
LABEL_45:
    if (*((char *)v44 + 23) < 0)
    {
      sub_1CB8BDF7C(a5, *v44, (unint64_t)v44[1]);
    }
    else
    {
      long long v30 = *(_OWORD *)v44;
      *(void *)(a5 + 16) = v44[2];
      *(_OWORD *)a5 = v30;
    }
    goto LABEL_48;
  }
  int InlineAsmFlagIdx = llvm::MachineInstr::findInlineAsmFlagIdx(a1, a4, 0);
  if ((InlineAsmFlagIdx & 0x80000000) == 0 && InlineAsmFlagIdx == a4)
  {
    unint64_t v17 = *((void *)a2 + 2);
    uint64_t v18 = "reguse";
    size_t v19 = 6;
    switch(v17 & 7)
    {
      case 2uLL:
        uint64_t v18 = "regdef";
        size_t v19 = 6;
        goto LABEL_26;
      case 3uLL:
        uint64_t v18 = "regdef-ec";
        size_t v19 = 9;
        goto LABEL_26;
      case 4uLL:
        uint64_t v18 = "clobber";
        size_t v19 = 7;
        goto LABEL_26;
      case 5uLL:
        uint64_t v22 = "imm";
        size_t v23 = 3;
        goto LABEL_32;
      case 6uLL:
        llvm::raw_ostream::write((llvm::raw_ostream *)&v36, "mem", 3uLL);
        if (v39 == __dst)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v36, ":", 1uLL);
        }
        else
        {
          *(unsigned char *)std::string __dst = 58;
          std::string __dst = (char *)__dst + 1;
        }
        char v32 = sub_1CD535588(WORD1(v17) & 0x7FFF);
        size_t v33 = v31;
        if (v31 <= v39 - (unsigned char *)__dst)
        {
          if (v31)
          {
            memcpy(__dst, v32, v31);
            std::string __dst = (char *)__dst + v33;
          }
        }
        else
        {
          uint64_t v22 = v32;
          size_t v23 = v33;
LABEL_32:
          llvm::raw_ostream::write((llvm::raw_ostream *)&v36, v22, v23);
        }
        if ((v17 & 0x80000000) != 0) {
          goto LABEL_34;
        }
        goto LABEL_45;
      default:
LABEL_26:
        llvm::raw_ostream::write((llvm::raw_ostream *)&v36, v18, v19);
        if ((v17 & 0x80000000) != 0)
        {
LABEL_34:
          uint64_t v24 = __dst;
          if ((unint64_t)(v39 - (unsigned char *)__dst) > 8)
          {
            *((unsigned char *)__dst + 8) = 36;
            *uint64_t v24 = *(void *)" tiedto:$";
            std::string __dst = (char *)__dst + 9;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v36, " tiedto:$", 9uLL);
          }
          unint64_t v25 = (v17 >> 16) & 0x7FFF;
        }
        else
        {
          if (v17 < 0x10000) {
            goto LABEL_45;
          }
          unint64_t v20 = WORD1(v17) - 1;
          if (a3)
          {
            uint64_t v21 = __dst;
            if (__dst >= v39)
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)&v36, 58);
            }
            else
            {
              std::string __dst = (char *)__dst + 1;
              *uint64_t v21 = 58;
            }
            uint64_t v27 = *((void *)a3 + 10);
            if (v27)
            {
              BOOL v28 = (const char *)(v27 + *(unsigned int *)(**(void **)(*((void *)a3 + 30) + 8 * v20) + 16));
              size_t v29 = strlen(v28);
              if (v29 <= v39 - (unsigned char *)__dst)
              {
                if (v29)
                {
                  memcpy(__dst, v28, v29);
                  std::string __dst = (char *)__dst + v29;
                }
              }
              else
              {
                llvm::raw_ostream::write((llvm::raw_ostream *)&v36, v28, v29);
              }
            }
            goto LABEL_45;
          }
          uint64_t v26 = __dst;
          if ((unint64_t)(v39 - (unsigned char *)__dst) > 2)
          {
            *((unsigned char *)__dst + 2) = 67;
            *uint64_t v26 = 21050;
            std::string __dst = (char *)__dst + 3;
          }
          else
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v36, ":RC", 3uLL);
          }
          unint64_t v25 = v20;
        }
        sub_1CD098D14((llvm::raw_ostream *)&v36, v25, 0, 0, 0);
        goto LABEL_45;
    }
  }
  *(unsigned char *)(a5 + 23) = 0;
  *(unsigned char *)a5 = 0;
LABEL_48:
  int v36 = &unk_1F2646B98;
  if (v43 == 1 && v38) {
    MEMORY[0x1D25D9CB0](v38, 0x1000C8077774924);
  }
  if (SHIBYTE(v46) < 0) {
    operator delete(v45[0]);
  }
}

uint64_t sub_1CC49DF3C()
{
  int v4 = 1;
  char v2 = 0;
  uint64_t v3 = &v2;
  v1.n128_u64[0] = (unint64_t)"Disable hazard detection during preRA scheduling";
  v1.n128_u64[1] = 48;
  sub_1CC025F34((llvm::cl::Option *)&unk_1EBCD4318, "disable-sched-hazard", &v4, &v3, &v1);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD4318, &dword_1CB82C000);
}

void llvm::TargetLoweringBase::InitLibcalls(llvm::TargetLoweringBase *this, const llvm::Triple *a2)
{
  int v4 = (void *)((char *)this + 174048);
  *((void *)this + 21756) = "__ashlhi3";
  *((void *)this + 21757) = "__ashlsi3";
  *((void *)this + 21758) = "__ashldi3";
  *((void *)this + 21759) = "__ashlti3";
  *((void *)this + 21760) = "__lshrhi3";
  *((void *)this + 21761) = "__lshrsi3";
  *((void *)this + 21762) = "__lshrdi3";
  *((void *)this + 21763) = "__lshrti3";
  *((void *)this + 21764) = "__ashrhi3";
  *((void *)this + 21765) = "__ashrsi3";
  *((void *)this + 21766) = "__ashrdi3";
  *((void *)this + 21767) = "__ashrti3";
  *((void *)this + 21768) = "__mulqi3";
  *((void *)this + 21769) = "__mulhi3";
  *((void *)this + 21770) = "__mulsi3";
  *((void *)this + 21771) = "__muldi3";
  *((void *)this + 21772) = "__multi3";
  *((void *)this + 21773) = 0;
  *((void *)this + 21774) = "__mulosi4";
  *((void *)this + 21775) = "__mulodi4";
  *((void *)this + 21776) = "__muloti4";
  *((void *)this + 21777) = "__divqi3";
  *((void *)this + 21778) = "__divhi3";
  *((void *)this + 21779) = "__divsi3";
  *((void *)this + 21780) = "__divdi3";
  *((void *)this + 21781) = "__divti3";
  *((void *)this + 21782) = "__divei4";
  *((void *)this + 21783) = "__udivqi3";
  *((void *)this + 21784) = "__udivhi3";
  *((void *)this + 21785) = "__udivsi3";
  *((void *)this + 21786) = "__udivdi3";
  *((void *)this + 21787) = "__udivti3";
  *((void *)this + 21788) = "__udivei4";
  *((void *)this + 21789) = "__modqi3";
  *((void *)this + 21790) = "__modhi3";
  *((void *)this + 21791) = "__modsi3";
  *((void *)this + 21792) = "__moddi3";
  *((void *)this + 21793) = "__modti3";
  *((void *)this + 21794) = "__modei4";
  *((void *)this + 21795) = "__umodqi3";
  *((void *)this + 21796) = "__umodhi3";
  *((void *)this + 21797) = "__umodsi3";
  *((void *)this + 21798) = "__umoddi3";
  *((void *)this + 21799) = "__umodti3";
  *((void *)this + 21800) = "__umodei4";
  *(_OWORD *)((char *)this + 174472) = 0u;
  *(_OWORD *)((char *)this + 174488) = 0u;
  *(_OWORD *)((char *)this + 174440) = 0u;
  *(_OWORD *)((char *)this + 174456) = 0u;
  *(_OWORD *)((char *)this + 174408) = 0u;
  *(_OWORD *)((char *)this + 174424) = 0u;
  *((void *)this + 21813) = "__negsi2";
  *((void *)this + 21814) = "__negdi2";
  *((void *)this + 21815) = "__clzsi2";
  *((void *)this + 21816) = "__clzdi2";
  *((void *)this + 21817) = "__clzti2";
  *((void *)this + 21818) = "__addsf3";
  *((void *)this + 21819) = "__adddf3";
  *((void *)this + 21820) = "__addxf3";
  *((void *)this + 21821) = "__addtf3";
  *((void *)this + 21822) = "__gcc_qadd";
  *((void *)this + 21823) = "__subsf3";
  *((void *)this + 21824) = "__subdf3";
  *((void *)this + 21825) = "__subxf3";
  *((void *)this + 21826) = "__subtf3";
  *((void *)this + 21827) = "__gcc_qsub";
  *((void *)this + 21828) = "__mulsf3";
  *((void *)this + 21829) = "__muldf3";
  *((void *)this + 21830) = "__mulxf3";
  *((void *)this + 21831) = "__multf3";
  *((void *)this + 21832) = "__gcc_qmul";
  *((void *)this + 21833) = "__divsf3";
  *((void *)this + 21834) = "__divdf3";
  *((void *)this + 21835) = "__divxf3";
  *((void *)this + 21836) = "__divtf3";
  *((void *)this + 21837) = "__gcc_qdiv";
  *((void *)this + 21838) = "fmodf";
  *((void *)this + 21839) = "fmod";
  *((void *)this + 21840) = "fmodl";
  *((void *)this + 21841) = "fmodl";
  *((void *)this + 21842) = "fmodl";
  *((void *)this + 21843) = "fmaf";
  *((void *)this + 21844) = "fma";
  *((void *)this + 21845) = "fmal";
  *((void *)this + 21846) = "fmal";
  *((void *)this + 21847) = "fmal";
  *((void *)this + 21848) = "__powisf2";
  *((void *)this + 21849) = "__powidf2";
  *((void *)this + 21850) = "__powixf2";
  *((void *)this + 21851) = "__powitf2";
  *((void *)this + 21852) = "__powitf2";
  *((void *)this + 21853) = "sqrtf";
  *((void *)this + 21854) = "sqrt";
  *((void *)this + 21855) = "sqrtl";
  *((void *)this + 21856) = "sqrtl";
  *((void *)this + 21857) = "sqrtl";
  *((void *)this + 21858) = "cbrtf";
  *((void *)this + 21859) = "cbrt";
  *((void *)this + 21860) = "cbrtl";
  *((void *)this + 21861) = "cbrtl";
  *((void *)this + 21862) = "cbrtl";
  *((void *)this + 21863) = "logf";
  *((void *)this + 21864) = "log";
  *((void *)this + 21865) = "logl";
  *((void *)this + 21866) = "logl";
  *((void *)this + 21867) = "logl";
  *((void *)this + 21868) = "__logf_finite";
  *((void *)this + 21869) = "__log_finite";
  *((void *)this + 21870) = "__logl_finite";
  *((void *)this + 21871) = "__logl_finite";
  *((void *)this + 21872) = "__logl_finite";
  *((void *)this + 21873) = "log2f";
  *((void *)this + 21874) = "log2";
  *((void *)this + 21875) = "log2l";
  *((void *)this + 21876) = "log2l";
  *((void *)this + 21877) = "log2l";
  *((void *)this + 21878) = "__log2f_finite";
  *((void *)this + 21879) = "__log2_finite";
  *((void *)this + 21880) = "__log2l_finite";
  *((void *)this + 21881) = "__log2l_finite";
  *((void *)this + 21882) = "__log2l_finite";
  *((void *)this + 21883) = "log10f";
  *((void *)this + 21884) = "log10";
  *((void *)this + 21885) = "log10l";
  *((void *)this + 21886) = "log10l";
  *((void *)this + 21887) = "log10l";
  *((void *)this + 21888) = "__log10f_finite";
  *((void *)this + 21889) = "__log10_finite";
  *((void *)this + 21890) = "__log10l_finite";
  *((void *)this + 21891) = "__log10l_finite";
  *((void *)this + 21892) = "__log10l_finite";
  *((void *)this + 21893) = "expf";
  *((void *)this + 21894) = "exp";
  *((void *)this + 21895) = "expl";
  *((void *)this + 21896) = "expl";
  *((void *)this + 21897) = "expl";
  *((void *)this + 21898) = "__expf_finite";
  *((void *)this + 21899) = "__exp_finite";
  *((void *)this + 21900) = "__expl_finite";
  *((void *)this + 21901) = "__expl_finite";
  *((void *)this + 21902) = "__expl_finite";
  *((void *)this + 21903) = "exp2f";
  *((void *)this + 21904) = "exp2";
  *((void *)this + 21905) = "exp2l";
  *((void *)this + 21906) = "exp2l";
  *((void *)this + 21907) = "exp2l";
  *((void *)this + 21908) = "__exp2f_finite";
  *((void *)this + 21909) = "__exp2_finite";
  *((void *)this + 21910) = "__exp2l_finite";
  *((void *)this + 21911) = "__exp2l_finite";
  *((void *)this + 21912) = "__exp2l_finite";
  *((void *)this + 21913) = "sinf";
  *((void *)this + 21914) = "sin";
  *((void *)this + 21915) = "sinl";
  *((void *)this + 21916) = "sinl";
  *((void *)this + 21917) = "sinl";
  *((void *)this + 21918) = "cosf";
  *((void *)this + 21919) = "cos";
  *((void *)this + 21920) = "cosl";
  *((void *)this + 21921) = "cosl";
  *((void *)this + 21922) = "cosl";
  *((void *)this + 21929) = 0;
  *(_OWORD *)((char *)this + 175400) = 0u;
  *(_OWORD *)((char *)this + 175416) = 0u;
  *(_OWORD *)((char *)this + 175384) = 0u;
  *((void *)this + 21930) = "powf";
  *((void *)this + 21931) = "pow";
  *((void *)this + 21932) = "powl";
  *((void *)this + 21933) = "powl";
  *((void *)this + 21934) = "powl";
  *((void *)this + 21935) = "__powf_finite";
  *((void *)this + 21936) = "__pow_finite";
  *((void *)this + 21937) = "__powl_finite";
  *((void *)this + 21938) = "__powl_finite";
  *((void *)this + 21939) = "__powl_finite";
  *((void *)this + 21940) = "ceilf";
  *((void *)this + 21941) = "ceil";
  *((void *)this + 21942) = "ceill";
  *((void *)this + 21943) = "ceill";
  *((void *)this + 21944) = "ceill";
  *((void *)this + 21945) = "truncf";
  *((void *)this + 21946) = "trunc";
  *((void *)this + 21947) = "truncl";
  *((void *)this + 21948) = "truncl";
  *((void *)this + 21949) = "truncl";
  *((void *)this + 21950) = "rintf";
  *((void *)this + 21951) = "rint";
  *((void *)this + 21952) = "rintl";
  *((void *)this + 21953) = "rintl";
  *((void *)this + 21954) = "rintl";
  *((void *)this + 21955) = "nearbyintf";
  *((void *)this + 21956) = "nearbyint";
  *((void *)this + 21957) = "nearbyintl";
  *((void *)this + 21958) = "nearbyintl";
  *((void *)this + 21959) = "nearbyintl";
  *((void *)this + 21960) = "roundf";
  *((void *)this + 21961) = "round";
  *((void *)this + 21962) = "roundl";
  *((void *)this + 21963) = "roundl";
  *((void *)this + 21964) = "roundl";
  *((void *)this + 21965) = "roundevenf";
  *((void *)this + 21966) = "roundeven";
  *((void *)this + 21967) = "roundevenl";
  *((void *)this + 21968) = "roundevenl";
  *((void *)this + 21969) = "roundevenl";
  *((void *)this + 21970) = "floorf";
  *((void *)this + 21971) = "floor";
  *((void *)this + 21972) = "floorl";
  *((void *)this + 21973) = "floorl";
  *((void *)this + 21974) = "floorl";
  *((void *)this + 21975) = "copysignf";
  *((void *)this + 21976) = "copysign";
  *((void *)this + 21977) = "copysignl";
  *((void *)this + 21978) = "copysignl";
  *((void *)this + 21979) = "copysignl";
  *((void *)this + 21980) = "fminf";
  *((void *)this + 21981) = "fmin";
  *((void *)this + 21982) = "fminl";
  *((void *)this + 21983) = "fminl";
  *((void *)this + 21984) = "fminl";
  *((void *)this + 21985) = "fmaxf";
  *((void *)this + 21986) = "fmax";
  *((void *)this + 21987) = "fmaxl";
  *((void *)this + 21988) = "fmaxl";
  *((void *)this + 21989) = "fmaxl";
  *((void *)this + 21990) = "lroundf";
  *((void *)this + 21991) = "lround";
  *((void *)this + 21992) = "lroundl";
  *((void *)this + 21993) = "lroundl";
  *((void *)this + 21994) = "lroundl";
  *((void *)this + 21995) = "llroundf";
  *((void *)this + 21996) = "llround";
  *((void *)this + 21997) = "llroundl";
  *((void *)this + 21998) = "llroundl";
  *((void *)this + 21999) = "llroundl";
  *((void *)this + 22000) = "lrintf";
  *((void *)this + 22001) = "lrint";
  *((void *)this + 22002) = "lrintl";
  *((void *)this + 22003) = "lrintl";
  *((void *)this + 22004) = "lrintl";
  *((void *)this + 22005) = "llrintf";
  *((void *)this + 22006) = "llrint";
  *((void *)this + 22007) = "llrintl";
  *((void *)this + 22008) = "llrintl";
  *((void *)this + 22009) = "llrintl";
  *((void *)this + 22010) = "__gcc_stoq";
  *((void *)this + 22011) = "__gcc_dtoq";
  *((void *)this + 22012) = "__extendxftf2";
  *((void *)this + 22013) = "__extenddftf2";
  *((void *)this + 22014) = "__extendsftf2";
  *((void *)this + 22015) = "__extendhftf2";
  *((void *)this + 22016) = "__extendhfxf2";
  *((void *)this + 22017) = "__extendsfdf2";
  *((void *)this + 22018) = "__extendhfdf2";
  *((void *)this + 22019) = "__gnu_h2f_ieee";
  *((void *)this + 22020) = "__gnu_f2h_ieee";
  *((void *)this + 22021) = "__truncdfhf2";
  *((void *)this + 22022) = "__truncxfhf2";
  *((void *)this + 22023) = "__trunctfhf2";
  *((void *)this + 22024) = "__trunctfhf2";
  *((void *)this + 22025) = "__truncdfsf2";
  *((void *)this + 22026) = "__truncxfsf2";
  *((void *)this + 22027) = "__trunctfsf2";
  *((void *)this + 22028) = "__gcc_qtos";
  *((void *)this + 22029) = "__truncxfdf2";
  *((void *)this + 22030) = "__trunctfdf2";
  *((void *)this + 22031) = "__gcc_qtod";
  *((void *)this + 22032) = "__trunctfxf2";
  *((void *)this + 22033) = "__fixhfsi";
  *((void *)this + 22034) = "__fixhfdi";
  *((void *)this + 22035) = "__fixhfti";
  *((void *)this + 22036) = "__fixsfsi";
  *((void *)this + 22037) = "__fixsfdi";
  *((void *)this + 22038) = "__fixsfti";
  *((void *)this + 22039) = "__fixdfsi";
  *((void *)this + 22040) = "__fixdfdi";
  *((void *)this + 22041) = "__fixdfti";
  *((void *)this + 22042) = "__fixxfsi";
  *((void *)this + 22043) = "__fixxfdi";
  *((void *)this + 22044) = "__fixxfti";
  *((void *)this + 22045) = "__fixtfsi";
  *((void *)this + 22046) = "__fixtfdi";
  *((void *)this + 22047) = "__fixtfti";
  *((void *)this + 22048) = "__gcc_qtou";
  *((void *)this + 22049) = "__fixtfdi";
  *((void *)this + 22050) = "__fixtfti";
  *((void *)this + 22051) = "__fixunshfsi";
  *((void *)this + 22052) = "__fixunshfdi";
  *((void *)this + 22053) = "__fixunshfti";
  *((void *)this + 22054) = "__fixunssfsi";
  *((void *)this + 22055) = "__fixunssfdi";
  *((void *)this + 22056) = "__fixunssfti";
  *((void *)this + 22057) = "__fixunsdfsi";
  *((void *)this + 22058) = "__fixunsdfdi";
  *((void *)this + 22059) = "__fixunsdfti";
  *((void *)this + 22060) = "__fixunsxfsi";
  *((void *)this + 22061) = "__fixunsxfdi";
  *((void *)this + 22062) = "__fixunsxfti";
  *((void *)this + 22063) = "__fixunstfsi";
  *((void *)this + 22064) = "__fixunstfdi";
  *((void *)this + 22065) = "__fixunstfti";
  *((void *)this + 22066) = "__fixunstfsi";
  *((void *)this + 22067) = "__fixunstfdi";
  *((void *)this + 22068) = "__fixunstfti";
  *((void *)this + 22069) = "__floatsihf";
  *((void *)this + 22070) = "__floatsisf";
  *((void *)this + 22071) = "__floatsidf";
  *((void *)this + 22072) = "__floatsixf";
  *((void *)this + 22073) = "__floatsitf";
  *((void *)this + 22074) = "__gcc_itoq";
  *((void *)this + 22075) = "__floatdihf";
  *((void *)this + 22076) = "__floatdisf";
  *((void *)this + 22077) = "__floatdidf";
  *((void *)this + 22078) = "__floatdixf";
  *((void *)this + 22079) = "__floatditf";
  *((void *)this + 22080) = "__floatditf";
  *((void *)this + 22081) = "__floattihf";
  *((void *)this + 22082) = "__floattisf";
  *((void *)this + 22083) = "__floattidf";
  *((void *)this + 22084) = "__floattixf";
  *((void *)this + 22085) = "__floattitf";
  *((void *)this + 22086) = "__floattitf";
  *((void *)this + 22087) = "__floatunsihf";
  *((void *)this + 22088) = "__floatunsisf";
  *((void *)this + 22089) = "__floatunsidf";
  *((void *)this + 22090) = "__floatunsixf";
  *((void *)this + 22091) = "__floatunsitf";
  *((void *)this + 22092) = "__gcc_utoq";
  *((void *)this + 22093) = "__floatundihf";
  *((void *)this + 22094) = "__floatundisf";
  *((void *)this + 22095) = "__floatundidf";
  *((void *)this + 22096) = "__floatundixf";
  *((void *)this + 22097) = "__floatunditf";
  *((void *)this + 22098) = "__floatunditf";
  *((void *)this + 22099) = "__floatuntihf";
  *((void *)this + 22100) = "__floatuntisf";
  *((void *)this + 22101) = "__floatuntidf";
  *((void *)this + 22102) = "__floatuntixf";
  *((void *)this + 22103) = "__floatuntitf";
  *((void *)this + 22104) = "__floatuntitf";
  *((void *)this + 22105) = "__extendkftf2";
  *((void *)this + 22106) = "__trunctfkf2";
  *((void *)this + 22107) = "__eqsf2";
  *((void *)this + 22108) = "__eqdf2";
  *((void *)this + 22109) = "__eqtf2";
  *((void *)this + 22110) = "__gcc_qeq";
  *((void *)this + 22111) = "__nesf2";
  *((void *)this + 22112) = "__nedf2";
  *((void *)this + 22113) = "__netf2";
  *((void *)this + 22114) = "__gcc_qne";
  *((void *)this + 22115) = "__gesf2";
  *((void *)this + 22116) = "__gedf2";
  *((void *)this + 22117) = "__getf2";
  *((void *)this + 22118) = "__gcc_qge";
  *((void *)this + 22119) = "__ltsf2";
  *((void *)this + 22120) = "__ltdf2";
  *((void *)this + 22121) = "__lttf2";
  *((void *)this + 22122) = "__gcc_qlt";
  *((void *)this + 22123) = "__lesf2";
  *((void *)this + 22124) = "__ledf2";
  *((void *)this + 22125) = "__letf2";
  *((void *)this + 22126) = "__gcc_qle";
  *((void *)this + 22127) = "__gtsf2";
  *((void *)this + 22128) = "__gtdf2";
  *((void *)this + 22129) = "__gttf2";
  *((void *)this + 22130) = "__gcc_qgt";
  *((void *)this + 22131) = "__unordsf2";
  *((void *)this + 22132) = "__unorddf2";
  *((void *)this + 22133) = "__unordtf2";
  *((void *)this + 22134) = "__gcc_qunord";
  *((void *)this + 22135) = "memcpy";
  *((void *)this + 22136) = "memmove";
  *((void *)this + 22137) = "memset";
  *((void *)this + 22138) = 0;
  *((void *)this + 22139) = "__llvm_memcpy_element_unordered_atomic_1";
  *((void *)this + 22140) = "__llvm_memcpy_element_unordered_atomic_2";
  *((void *)this + 22141) = "__llvm_memcpy_element_unordered_atomic_4";
  *((void *)this + 22142) = "__llvm_memcpy_element_unordered_atomic_8";
  *((void *)this + 22143) = "__llvm_memcpy_element_unordered_atomic_16";
  *((void *)this + 22144) = "__llvm_memmove_element_unordered_atomic_1";
  *((void *)this + 22145) = "__llvm_memmove_element_unordered_atomic_2";
  *((void *)this + 22146) = "__llvm_memmove_element_unordered_atomic_4";
  *((void *)this + 22147) = "__llvm_memmove_element_unordered_atomic_8";
  *((void *)this + 22148) = "__llvm_memmove_element_unordered_atomic_16";
  *((void *)this + 22149) = "__llvm_memset_element_unordered_atomic_1";
  *((void *)this + 22150) = "__llvm_memset_element_unordered_atomic_2";
  *((void *)this + 22151) = "__llvm_memset_element_unordered_atomic_4";
  *((void *)this + 22152) = "__llvm_memset_element_unordered_atomic_8";
  *((void *)this + 22153) = "__llvm_memset_element_unordered_atomic_16";
  *((void *)this + 22154) = "_Unwind_Resume";
  *((void *)this + 22155) = "__cxa_end_cleanup";
  *((void *)this + 22156) = "__sync_val_compare_and_swap_1";
  *((void *)this + 22157) = "__sync_val_compare_and_swap_2";
  *((void *)this + 22158) = "__sync_val_compare_and_swap_4";
  *((void *)this + 22159) = "__sync_val_compare_and_swap_8";
  *((void *)this + 22160) = "__sync_val_compare_and_swap_16";
  *((void *)this + 22161) = "__sync_lock_test_and_set_1";
  *((void *)this + 22162) = "__sync_lock_test_and_set_2";
  *((void *)this + 22163) = "__sync_lock_test_and_set_4";
  *((void *)this + 22164) = "__sync_lock_test_and_set_8";
  *((void *)this + 22165) = "__sync_lock_test_and_set_16";
  *((void *)this + 22166) = "__sync_fetch_and_add_1";
  *((void *)this + 22167) = "__sync_fetch_and_add_2";
  *((void *)this + 22168) = "__sync_fetch_and_add_4";
  *((void *)this + 22169) = "__sync_fetch_and_add_8";
  *((void *)this + 22170) = "__sync_fetch_and_add_16";
  *((void *)this + 22171) = "__sync_fetch_and_sub_1";
  *((void *)this + 22172) = "__sync_fetch_and_sub_2";
  *((void *)this + 22173) = "__sync_fetch_and_sub_4";
  *((void *)this + 22174) = "__sync_fetch_and_sub_8";
  *((void *)this + 22175) = "__sync_fetch_and_sub_16";
  *((void *)this + 22176) = "__sync_fetch_and_and_1";
  *((void *)this + 22177) = "__sync_fetch_and_and_2";
  *((void *)this + 22178) = "__sync_fetch_and_and_4";
  *((void *)this + 22179) = "__sync_fetch_and_and_8";
  *((void *)this + 22180) = "__sync_fetch_and_and_16";
  *((void *)this + 22181) = "__sync_fetch_and_or_1";
  *((void *)this + 22182) = "__sync_fetch_and_or_2";
  *((void *)this + 22183) = "__sync_fetch_and_or_4";
  *((void *)this + 22184) = "__sync_fetch_and_or_8";
  *((void *)this + 22185) = "__sync_fetch_and_or_16";
  *((void *)this + 22186) = "__sync_fetch_and_xor_1";
  *((void *)this + 22187) = "__sync_fetch_and_xor_2";
  *((void *)this + 22188) = "__sync_fetch_and_xor_4";
  *((void *)this + 22189) = "__sync_fetch_and_xor_8";
  *((void *)this + 22190) = "__sync_fetch_and_xor_16";
  *((void *)this + 22191) = "__sync_fetch_and_nand_1";
  *((void *)this + 22192) = "__sync_fetch_and_nand_2";
  *((void *)this + 22193) = "__sync_fetch_and_nand_4";
  *((void *)this + 22194) = "__sync_fetch_and_nand_8";
  *((void *)this + 22195) = "__sync_fetch_and_nand_16";
  *((void *)this + 22196) = "__sync_fetch_and_max_1";
  *((void *)this + 22197) = "__sync_fetch_and_max_2";
  *((void *)this + 22198) = "__sync_fetch_and_max_4";
  *((void *)this + 22199) = "__sync_fetch_and_max_8";
  *((void *)this + 22200) = "__sync_fetch_and_max_16";
  *((void *)this + 22201) = "__sync_fetch_and_umax_1";
  *((void *)this + 22202) = "__sync_fetch_and_umax_2";
  *((void *)this + 22203) = "__sync_fetch_and_umax_4";
  *((void *)this + 22204) = "__sync_fetch_and_umax_8";
  *((void *)this + 22205) = "__sync_fetch_and_umax_16";
  *((void *)this + 22206) = "__sync_fetch_and_min_1";
  *((void *)this + 22207) = "__sync_fetch_and_min_2";
  *((void *)this + 22208) = "__sync_fetch_and_min_4";
  *((void *)this + 22209) = "__sync_fetch_and_min_8";
  *((void *)this + 22210) = "__sync_fetch_and_min_16";
  *((void *)this + 22211) = "__sync_fetch_and_umin_1";
  *((void *)this + 22212) = "__sync_fetch_and_umin_2";
  *((void *)this + 22213) = "__sync_fetch_and_umin_4";
  *((void *)this + 22214) = "__sync_fetch_and_umin_8";
  *((void *)this + 22215) = "__sync_fetch_and_umin_16";
  *((void *)this + 22216) = "__atomic_load";
  *((void *)this + 22217) = "__atomic_load_1";
  *((void *)this + 22218) = "__atomic_load_2";
  *((void *)this + 22219) = "__atomic_load_4";
  *((void *)this + 22220) = "__atomic_load_8";
  *((void *)this + 22221) = "__atomic_load_16";
  *((void *)this + 22222) = "__atomic_store";
  *((void *)this + 22223) = "__atomic_store_1";
  *((void *)this + 22224) = "__atomic_store_2";
  *((void *)this + 22225) = "__atomic_store_4";
  *((void *)this + 22226) = "__atomic_store_8";
  *((void *)this + 22227) = "__atomic_store_16";
  *((void *)this + 22228) = "__atomic_exchange";
  *((void *)this + 22229) = "__atomic_exchange_1";
  *((void *)this + 22230) = "__atomic_exchange_2";
  *((void *)this + 22231) = "__atomic_exchange_4";
  *((void *)this + 22232) = "__atomic_exchange_8";
  *((void *)this + 22233) = "__atomic_exchange_16";
  *((void *)this + 22234) = "__atomic_compare_exchange";
  *((void *)this + 22235) = "__atomic_compare_exchange_1";
  *((void *)this + 22236) = "__atomic_compare_exchange_2";
  *((void *)this + 22237) = "__atomic_compare_exchange_4";
  *((void *)this + 22238) = "__atomic_compare_exchange_8";
  *((void *)this + 22239) = "__atomic_compare_exchange_16";
  *((void *)this + 22240) = "__atomic_fetch_add_1";
  *((void *)this + 22241) = "__atomic_fetch_add_2";
  *((void *)this + 22242) = "__atomic_fetch_add_4";
  *((void *)this + 22243) = "__atomic_fetch_add_8";
  *((void *)this + 22244) = "__atomic_fetch_add_16";
  *((void *)this + 22245) = "__atomic_fetch_sub_1";
  *((void *)this + 22246) = "__atomic_fetch_sub_2";
  *((void *)this + 22247) = "__atomic_fetch_sub_4";
  *((void *)this + 22248) = "__atomic_fetch_sub_8";
  *((void *)this + 22249) = "__atomic_fetch_sub_16";
  *((void *)this + 22250) = "__atomic_fetch_and_1";
  *((void *)this + 22251) = "__atomic_fetch_and_2";
  *((void *)this + 22252) = "__atomic_fetch_and_4";
  *((void *)this + 22253) = "__atomic_fetch_and_8";
  *((void *)this + 22254) = "__atomic_fetch_and_16";
  *((void *)this + 22255) = "__atomic_fetch_or_1";
  *((void *)this + 22256) = "__atomic_fetch_or_2";
  *((void *)this + 22257) = "__atomic_fetch_or_4";
  *((void *)this + 22258) = "__atomic_fetch_or_8";
  *((void *)this + 22259) = "__atomic_fetch_or_16";
  *((void *)this + 22260) = "__atomic_fetch_xor_1";
  *((void *)this + 22261) = "__atomic_fetch_xor_2";
  *((void *)this + 22262) = "__atomic_fetch_xor_4";
  *((void *)this + 22263) = "__atomic_fetch_xor_8";
  *((void *)this + 22264) = "__atomic_fetch_xor_16";
  *((void *)this + 22265) = "__atomic_fetch_nand_1";
  *((void *)this + 22266) = "__atomic_fetch_nand_2";
  *((void *)this + 22267) = "__atomic_fetch_nand_4";
  *((void *)this + 22268) = "__atomic_fetch_nand_8";
  *((void *)this + 22269) = "__atomic_fetch_nand_16";
  bzero((char *)this + 178160, 0x3C0uLL);
  v4[634] = "__stack_chk_fail";
  v4[635] = "__llvm_deoptimize";
  bzero((char *)this + 181700, 0x9F4uLL);
  v4[637] = 0;
  v4[636] = 0;
  int v5 = *((_DWORD *)a2 + 6);
  if ((v5 - 21) <= 3)
  {
    v4[65] = "__addkf3";
    v4[70] = "__subkf3";
    v4[75] = "__mulkf3";
    v4[80] = "__divkf3";
    v4[95] = "__powikf2";
    v4[258] = "__extendsfkf2";
    v4[257] = "__extenddfkf2";
    v4[271] = "__trunckfsf2";
    v4[274] = "__trunckfdf2";
    v4[289] = "__fixkfsi";
    v4[290] = "__fixkfdi";
    v4[291] = "__fixkfti";
    v4[307] = "__fixunskfsi";
    v4[308] = "__fixunskfdi";
    v4[309] = "__fixunskfti";
    v4[317] = "__floatsikf";
    v4[323] = "__floatdikf";
    v4[329] = "__floattikf";
    v4[335] = "__floatunsikf";
    v4[341] = "__floatundikf";
    v4[347] = "__floatuntikf";
    v4[353] = "__eqkf2";
    v4[357] = "__nekf2";
    v4[361] = "__gekf2";
    v4[365] = "__ltkf2";
    v4[369] = "__lekf2";
    v4[373] = "__gtkf2";
    v4[377] = "__unordkf2";
  }
  unsigned int v6 = *((_DWORD *)a2 + 9);
  if (v6 != 7 && (v6 > 0x21 || ((1 << v6) & 0x3F0000808) == 0))
  {
    v4[263] = "__gnu_h2f_ieee";
    v4[264] = "__gnu_f2h_ieee";
    goto LABEL_11;
  }
  v4[263] = "__extendhfsf2";
  v4[264] = "__truncsfhf2";
  uint64_t v7 = "bzero";
  if (v5 == 3 || v5 == 5) {
    goto LABEL_32;
  }
  if ((v5 - 41) <= 1
    && (v6 & 0xFFFFFFF7) == 3
    && (llvm::Triple::isMacOSXVersionLT(a2, 0xAu, 6, 0) & 1) == 0)
  {
    uint64_t v7 = "__bzero";
LABEL_32:
    v4[382] = v7;
  }
  if (*((_DWORD *)a2 + 6) == 41) {
    goto LABEL_11;
  }
  int v8 = *((_DWORD *)a2 + 9);
  if ((v8 & 0xFFFFFFF7) == 3)
  {
    if ((llvm::Triple::isMacOSXVersionLT(a2, 0xAu, 9, 0) & 1) != 0 || !llvm::Triple::isArch64Bit(a2)) {
      goto LABEL_11;
    }
  }
  else if (v8 == 7 || v8 == 28)
  {
    v13[0] = llvm::Triple::getOSVersion(a2);
    v13[1] = v9;
    v12[0] = 7;
    v12[1] = 0;
    if (sub_1CC156834(v13, v12)) {
      goto LABEL_11;
    }
  }
  v4[172] = "__sincosf_stret";
  v4[173] = "__sincos_stret";
  if (*((_DWORD *)a2 + 7) == 22) {
    *(void *)((char *)v4 + 8340) = 0x4400000044;
  }
LABEL_11:
  int v10 = *((_DWORD *)a2 + 10);
  if ((v10 - 1) < 6) {
    goto LABEL_27;
  }
  int v11 = *((_DWORD *)a2 + 9);
  if (v11 == 6) {
    goto LABEL_27;
  }
  if (v10 == 11)
  {
    if (sub_1CD4CF6B4(a2, 9u))
    {
LABEL_28:
      int v11 = *((_DWORD *)a2 + 9);
      goto LABEL_14;
    }
LABEL_27:
    v4[167] = "sincosf";
    v4[168] = "sincos";
    v4[169] = "sincosl";
    v4[170] = "sincosl";
    v4[171] = "sincosl";
    goto LABEL_28;
  }
LABEL_14:
  if (*((_DWORD *)a2 + 6) == 42 && *((_DWORD *)a2 + 8) == 3 && v11 == 25)
  {
    v4[167] = "sincosf";
    v4[168] = "sincos";
  }
  else if (v11 == 13)
  {
    v4[634] = 0;
  }
}

llvm::TargetLoweringBase *llvm::TargetLoweringBase::TargetLoweringBase(llvm::TargetLoweringBase *this, const llvm::TargetMachine *a2)
{
  *(void *)this = &unk_1F2613E58;
  *((void *)this + 1) = a2;
  *((_DWORD *)this + 22) = 0;
  uint64_t v3 = (char *)this + 184288;
  *(_OWORD *)((char *)this + 1886) = 0u;
  *(_OWORD *)((char *)this + 1902) = 0u;
  int v4 = (void *)((char *)this + 174024);
  *(_OWORD *)((char *)this + 1918) = 0u;
  *(_OWORD *)((char *)this + 1934) = 0u;
  *(_OWORD *)((char *)this + 1950) = 0u;
  *(_OWORD *)((char *)this + 1966) = 0u;
  *(_OWORD *)((char *)this + 1982) = 0u;
  *(_OWORD *)((char *)this + 1998) = 0u;
  *(_OWORD *)((char *)this + 2014) = 0u;
  *(_OWORD *)((char *)this + 2030) = 0u;
  *(_OWORD *)((char *)this + 2046) = 0u;
  *(_DWORD *)((char *)this + 2061) = 0;
  *(_OWORD *)((char *)this + 3683) = 0u;
  *(_OWORD *)((char *)this + 3699) = 0u;
  *(_OWORD *)((char *)this + 3715) = 0u;
  *(_OWORD *)((char *)this + 3731) = 0u;
  *(_OWORD *)((char *)this + 3747) = 0u;
  *(_OWORD *)((char *)this + 3763) = 0u;
  *(_OWORD *)((char *)this + 3779) = 0u;
  *(_OWORD *)((char *)this + 3795) = 0u;
  *(_OWORD *)((char *)this + 3811) = 0u;
  *(_OWORD *)((char *)this + 3827) = 0u;
  *(_OWORD *)((char *)this + 3843) = 0u;
  *(_DWORD *)((char *)this + 3858) = 0;
  *(_DWORD *)((char *)this + 173971) = 0;
  *(_OWORD *)((char *)this + 173940) = 0u;
  *(_OWORD *)((char *)this + 173956) = 0u;
  *(_OWORD *)((char *)this + 173908) = 0u;
  *(_OWORD *)((char *)this + 173924) = 0u;
  *(_OWORD *)((char *)this + 173876) = 0u;
  *(_OWORD *)((char *)this + 173892) = 0u;
  *(_OWORD *)((char *)this + 173844) = 0u;
  *(_OWORD *)((char *)this + 173860) = 0u;
  *(_OWORD *)((char *)this + 173812) = 0u;
  *(_OWORD *)((char *)this + 173828) = 0u;
  *(_OWORD *)((char *)this + 173796) = 0u;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 17) = 0;
  *((void *)this + 21755) = 0;
  *((void *)this + 21754) = 0;
  *((void *)this + 21753) = (char *)this + 174032;
  *((_DWORD *)this + 46067) = 0;
  llvm::TargetLoweringBase::initActions(this);
  *((_OWORD *)this + 11517) = xmmword_1CFAC74A0;
  v4[1280] = 4;
  v4[1279] = 0x800000004;
  *((_WORD *)this + 8) = 0;
  *((unsigned char *)this + 48) = byte_1EBCD4458;
  *(_WORD *)uint64_t v3 = 0;
  *((_DWORD *)this + 22) = 0;
  *(_OWORD *)((char *)this + 52) = xmmword_1CFAC74B0;
  v4[1278] = 0x800000012;
  void v3[2] = byte_1EBCD4818;
  *((void *)this + 9) = 0x40000000000;
  *((_DWORD *)this + 20) = 0;
  *((unsigned char *)this + 84) = 0;
  bzero((char *)this + 174048, 0x13F0uLL);
  llvm::TargetLoweringBase::InitLibcalls(this, (const llvm::Triple *)(*((void *)this + 1) + 448));
  memset_pattern16((char *)this + 179152, &unk_1CFAC74E0, 0x9F4uLL);
  *(void *)&long long v5 = 0x1100000011;
  *((void *)&v5 + 1) = 0x1100000011;
  *(_OWORD *)((char *)this + 180556) = v5;
  *(void *)&long long v5 = 0x1600000016;
  *((void *)&v5 + 1) = 0x1600000016;
  *(_OWORD *)((char *)this + 180572) = v5;
  *(void *)&long long v6 = 0x1300000013;
  *((void *)&v6 + 1) = 0x1300000013;
  *(_OWORD *)((char *)this + 180588) = v6;
  *(void *)&long long v6 = 0x1400000014;
  *((void *)&v6 + 1) = 0x1400000014;
  *(_OWORD *)((char *)this + 180604) = v6;
  *(void *)&long long v6 = 0x1500000015;
  *((void *)&v6 + 1) = 0x1500000015;
  *(_OWORD *)((char *)this + 180620) = v6;
  *(void *)&long long v6 = 0x1200000012;
  *((void *)&v6 + 1) = 0x1200000012;
  *(_OWORD *)((char *)this + 180636) = v6;
  *(_OWORD *)((char *)this + 180652) = v5;
  return this;
}

int *llvm::TargetLoweringBase::initActions(llvm::TargetLoweringBase *this)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  char v2 = (char *)this + 4536;
  uint64_t v3 = (char *)this + 3862;
  bzero((char *)this + 169796, 0x6FEuLL);
  bzero((char *)this + 171588, 0x8A0uLL);
  bzero((char *)this + 96, 0x598uLL);
  *((unsigned char *)this + 174023) = 0;
  *(_OWORD *)((char *)this + 173991) = 0u;
  *(_OWORD *)((char *)this + 174007) = 0u;
  *(_OWORD *)((char *)this + 173975) = 0u;
  bzero(v3, 0x2882DuLL);
  for (uint64_t i = 8; i != 15; ++i)
  {
    unsigned __int8 v26 = i;
    int v5 = sub_1CB87E200(&v26);
    if (v5 > 31)
    {
      switch(v5)
      {
        case 128:
          char v6 = 7;
          goto LABEL_5;
        case 32:
          char v6 = 5;
          goto LABEL_5;
        case 64:
          char v6 = 6;
          goto LABEL_5;
      }
    }
    else
    {
      switch(v5)
      {
        case 16:
          char v6 = 4;
LABEL_5:
          unsigned __int8 v7 = v26;
          *((unsigned char *)this + 390 * v26 + 4156) = 1;
          unint64_t v27 = ((unint64_t)v7 << 32) | 0x126;
          *(void *)&long long v28 = &v27;
          sub_1CD585F18((uint64_t)this + 174024, 0x126u, v7, (void **)&v28)[36] = v6;
          continue;
        case 1:
          char v6 = 2;
          goto LABEL_5;
        case 8:
          char v6 = 3;
          goto LABEL_5;
      }
    }
  }
  uint64_t v8 = 0;
  uint64_t v9 = 1;
  BOOL result = dword_1CFAC77A8;
  *(void *)&long long v11 = 0x202020202020202;
  *((void *)&v11 + 1) = 0x202020202020202;
  do
  {
    uint64_t v12 = 0;
    *(void *)((char *)this + 10 * v8 + 169808) = 0x2222222222222222;
    *((unsigned char *)this + 390 * v9 + 4155) = 2;
    do
      *((unsigned char *)this + 390 * v9 + dword_1CFAC7710[v12++] + 3862) = 2;
    while (v12 != 32);
    for (uint64_t j = 0; j != 6; ++j)
      *((unsigned char *)this + 390 * v9 + dword_1CFAC7790[j] + 3862) = 2;
    for (uint64_t k = 0; k != 5; ++k)
      *((unsigned char *)this + 390 * v9 + dword_1CFAC77A8[k] + 3862) = 2;
    uint64_t v15 = 0;
    long long v28 = xmmword_1CFAC74C0;
    do
    {
      *((unsigned char *)this + 390 * v9 + *(unsigned int *)((char *)&v28 + v15) + 3862) = 2;
      v15 += 4;
    }
    while (v15 != 16);
    uint64_t v16 = 0;
    long long v28 = xmmword_1CFAC74D0;
    do
    {
      *((unsigned char *)this + 390 * v9 + *(unsigned int *)((char *)&v28 + v16) + 3862) = 2;
      v16 += 4;
    }
    while (v16 != 16);
    uint64_t v17 = 0;
    uint64_t v18 = (char *)this + 390 * v9;
    *(_WORD *)(v18 + 4027) = 514;
    *((_DWORD *)v18 + 1012) = 33686018;
    *(void *)&long long v28 = 0xF0000000EFLL;
    DWORD2(v28) = 228;
    do
    {
      *((unsigned char *)this + 390 * v9 + *(unsigned int *)((char *)&v28 + v17) + 3862) = 2;
      v17 += 4;
    }
    while (v17 != 12);
    if (v9 - 15 <= 0x9B)
    {
      for (uint64_t m = 0; m != 6; ++m)
        *((unsigned char *)this + 390 * v9 + dword_1CFAC77BC[m] + 3862) = 2;
    }
    uint64_t v20 = 0;
    uint64_t v21 = (char *)this + 390 * v9 + 3862;
    v21[316] = 2;
    *(_OWORD *)(v21 + 101) = v11;
    *(_OWORD *)(v21 + 117) = v11;
    *(void *)(v21 + 132) = 0x202020202020202;
    do
      *((unsigned char *)this + 390 * v9 + dword_1CFAC77D4[v20++] + 3862) = 2;
    while (v20 != 15);
    *((unsigned char *)this + 390 * v9++ + 4016) = 2;
    ++v8;
  }
  while (v9 != 179);
  uint64_t v22 = 0;
  v2[3] = 2;
  v2[1946] = 2;
  LODWORD(v28) = 202050057;
  BYTE4(v28) = 13;
  do
    *((unsigned char *)this + 390 * *((unsigned __int8 *)&v28 + v22++) + 3874) = 2;
  while (v22 != 5);
  uint64_t v23 = 0;
  LOWORD(v28) = 2826;
  BYTE2(v28) = 13;
  do
  {
    uint64_t v24 = 0;
    int v25 = *((unsigned __int8 *)&v28 + v23);
    do
      *((unsigned char *)this + 390 * v25 + dword_1CFAC7810[v24++] + 3862) = 2;
    while (v24 != 15);
    ++v23;
  }
  while (v23 != 3);
  *(_WORD *)char v2 = 514;
  v2[2] = 2;
  return result;
}

uint64_t llvm::TargetLoweringBase::isFreeAddrSpaceCast(llvm::TargetLoweringBase *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 64))();
}

unint64_t llvm::TargetLoweringBase::getTypeConversion@<X0>(unint64_t result@<X0>, llvm::LLVMContext *a2@<X1>, BOOL a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6 = result;
  BOOL v54 = a3;
  uint64_t v55 = a4;
  if (a3)
  {
    LOBYTE(v51) = a3;
    int v8 = *(unsigned __int8 *)(result + a3 + 173796);
    if (v8 == 5)
    {
      BOOL result = sub_1CB8C2FBC((unsigned __int8 *)&v51);
      *(unsigned char *)a5 = 5;
      *(unsigned char *)(a5 + 8) = result;
    }
    else
    {
      if (v8 == 6)
      {
        LOBYTE(v52) = a3;
        *((void *)&v52 + 1) = 0;
        BOOL result = sub_1CC4A0588((uint64_t)&v52, a2, a3);
LABEL_5:
        char v10 = 6;
LABEL_6:
        *(unsigned char *)a5 = v10;
        *(void *)(a5 + 8) = result;
        *(void *)(a5 + 16) = v9;
        return result;
      }
      char v16 = *(unsigned char *)(result + a3 + 3683);
      *(unsigned char *)a5 = v8;
      *(unsigned char *)(a5 + 8) = v16;
    }
LABEL_12:
    *(void *)(a5 + 16) = 0;
    return result;
  }
  if ((*(_DWORD *)(a4 + 8) & 0xFE) != 0x12)
  {
    unsigned int ExtendedSizeInBits = llvm::EVT::getExtendedSizeInBits((llvm::EVT *)&v54);
    if (v17 == 1) {
    if (ExtendedSizeInBits < 8
    }
      || (uint8x8_t v19 = (uint8x8_t)vcnt_s8((int8x8_t)ExtendedSizeInBits), v19.i16[0] = vaddlv_u8(v19), v19.i32[0] >= 2u))
    {
      uint64_t v24 = sub_1CC4A0628((unsigned __int8 *)&v54, a2);
      uint64_t v26 = v25;
      BOOL result = (unint64_t)llvm::TargetLoweringBase::getTypeConversion(&v52, v6, a2, v24, v25);
      if (v52 == 1)
      {
        *(_OWORD *)a5 = v52;
        *(void *)(a5 + 16) = v53;
      }
      else
      {
        *(unsigned char *)a5 = 1;
        *(void *)(a5 + 8) = v24;
        *(void *)(a5 + 16) = v26;
      }
      return result;
    }
    uint64_t v21 = llvm::EVT::getExtendedSizeInBits((llvm::EVT *)&v54);
    if (v20 == 1) {
    uint64_t v22 = (llvm::LLVMContext *)((unint64_t)v21 >> 1);
    }
    if ((int)((unint64_t)v21 >> 1) <= 31)
    {
      switch(v22)
      {
        case 1:
          BOOL result = 0;
          uint64_t v23 = 2;
          goto LABEL_94;
        case 0x10:
          BOOL result = 0;
          uint64_t v23 = 4;
          goto LABEL_94;
        case 8:
          BOOL result = 0;
          uint64_t v23 = 3;
          goto LABEL_94;
      }
    }
    else
    {
      switch(v22)
      {
        case 0x20:
          BOOL result = 0;
          uint64_t v23 = 5;
LABEL_94:
          *(unsigned char *)a5 = 2;
          *(void *)(a5 + 8) = v23;
          *(void *)(a5 + 16) = result;
          return result;
        case 0x40:
          BOOL result = 0;
          uint64_t v23 = 6;
          goto LABEL_94;
        case 0x80:
          BOOL result = 0;
          uint64_t v23 = 7;
          goto LABEL_94;
      }
    }
    BOOL result = llvm::IntegerType::get(a2, v22);
    uint64_t v23 = 0;
    goto LABEL_94;
  }
  unint64_t v12 = sub_1CC4A0738((llvm::EVT *)&v54);
  unint64_t v13 = HIDWORD(v12);
  if (v54)
  {
    BOOL result = sub_1CB8C2FBC((unsigned __int8 *)&v54);
    unint64_t v14 = 0;
    uint64_t v15 = 0;
  }
  else
  {
    BOOL result = llvm::EVT::getEVT(*(llvm::EVT **)(v55 + 24), 0, v11);
    unint64_t v14 = result & 0xFFFFFFFFFFFFFF00;
  }
  *(void *)&long long v51 = v14 | result;
  *((void *)&v51 + 1) = v15;
  if (HIDWORD(v12) != 1 && v12 == 1)
  {
    char v27 = 5;
    goto LABEL_28;
  }
  if ((_BYTE)result)
  {
    if ((result - 120) >= 0x20u
      && (result - 2) >= 6u
      && (result - 15) >= 0x3Cu)
    {
      goto LABEL_78;
    }
  }
  else
  {
    if ((*(_DWORD *)(v15 + 8) & 0xFE) == 0x12) {
      int v28 = *(unsigned __int8 *)(**(void **)(v15 + 16) + 8);
    }
    else {
      int v28 = *(_DWORD *)(v15 + 8);
    }
    if (v28 != 13) {
      goto LABEL_78;
    }
  }
  int v29 = sub_1CC4A0738((llvm::EVT *)&v54);
  if ((v29 & (v29 - 1)) != 0)
  {
    unint64_t v32 = v12 | ((unint64_t)v12 >> 1) | ((v12 | ((unint64_t)v12 >> 1)) >> 2);
    unint64_t v33 = v32 | (v32 >> 4) | ((v32 | (v32 >> 4)) >> 8);
    BOOL result = sub_1CB882C1C(a2, v51, *((uint64_t *)&v51 + 1), (llvm::Type *)((((v33 >> 16) | v33) + 1) | ((unint64_t)(HIDWORD(v12) == 1) << 32)));
LABEL_45:
    char v10 = 7;
    goto LABEL_6;
  }
  llvm::TargetLoweringBase::getTypeConversion(&v52, v6, a2, v51, *((void *)&v51 + 1));
  if (v52 == 2)
  {
    BOOL result = sub_1CC4A0738((llvm::EVT *)&v54);
    if (HIDWORD(result) == 1)
    {
      *(_OWORD *)(a5 + 8) = v51;
      char v31 = 10;
    }
    else
    {
      BOOL result = sub_1CC4A0588((uint64_t)&v54, a2, v30);
      *(void *)(a5 + 8) = result;
      *(void *)(a5 + 16) = v47;
      char v31 = 6;
    }
    *(unsigned char *)a5 = v31;
    return result;
  }
  long long v50 = v51;
  while (1)
  {
    if ((_BYTE)v51) {
      unsigned int v34 = sub_1CB87E200((unsigned __int8 *)&v51);
    }
    else {
      unsigned int v34 = llvm::EVT::getExtendedSizeInBits((llvm::EVT *)&v51);
    }
    int v36 = v34;
    if (v35 == 1)
    {
      unsigned int v48 = v34;
      int v36 = v48;
    }
    uint64_t v37 = v36;
    if (v36 <= 30)
    {
      switch(v36)
      {
        case 0:
          uint64_t v38 = 2;
          goto LABEL_65;
        case 15:
          uint64_t v37 = 0;
          uint64_t v38 = 4;
          goto LABEL_65;
        case 7:
          uint64_t v37 = 0;
          uint64_t v38 = 3;
          goto LABEL_65;
      }
    }
    else
    {
      switch(v36)
      {
        case 31:
          uint64_t v37 = 0;
          uint64_t v38 = 5;
          goto LABEL_65;
        case 63:
          uint64_t v37 = 0;
          uint64_t v38 = 6;
          goto LABEL_65;
        case 127:
          uint64_t v37 = 0;
          uint64_t v38 = 7;
          goto LABEL_65;
      }
    }
    uint64_t v37 = llvm::IntegerType::get(a2, (llvm::LLVMContext *)(v36 + 1));
    uint64_t v38 = 0;
LABEL_65:
    v49[0] = v38;
    v49[1] = v37;
    *(void *)&long long v51 = sub_1CC4A0628((unsigned __int8 *)v49, a2);
    *((void *)&v51 + 1) = v39;
    if (!(_BYTE)v51) {
      break;
    }
    if ((v12 & 0xFFFFFFFF00000000) == 0x100000000) {
      unsigned __int8 v40 = sub_1CB882CA4(v51, v12);
    }
    else {
      unsigned __int8 v40 = sub_1CB883124(v51, v12);
    }
    if (v40 && !*(unsigned char *)(v6 + 173796 + v40))
    {
      BOOL result = sub_1CB882C1C(a2, v51, *((uint64_t *)&v51 + 1), (llvm::Type *)v12);
      char v10 = 1;
      goto LABEL_6;
    }
  }
  long long v51 = v50;
LABEL_78:
  unint64_t v41 = v6 + 173796;
  while ((_BYTE)v51)
  {
    unint64_t v42 = v12 | ((unint64_t)v12 >> 1) | ((v12 | ((unint64_t)v12 >> 1)) >> 2);
    unint64_t v43 = v42 | (v42 >> 4) | ((v42 | (v42 >> 4)) >> 8);
    unint64_t v12 = (v43 | (v43 >> 16)) + 1;
    BOOL result = v13 == 1 ? sub_1CB882CA4(v51, v12) : sub_1CB883124(v51, v12);
    if (!(_BYTE)result) {
      break;
    }
    if (!*(unsigned char *)(v41 + result))
    {
      *(unsigned char *)a5 = 7;
      *(unsigned char *)(a5 + 8) = result;
      goto LABEL_12;
    }
  }
  int v44 = sub_1CC4A0738((llvm::EVT *)&v54);
  if ((v44 & (v44 - 1)) != 0)
  {
    BOOL result = sub_1CD584B84((llvm::EVT *)&v54, a2);
    goto LABEL_45;
  }
  BOOL result = sub_1CC4A0738((llvm::EVT *)&v54);
  if (result != 0x100000001)
  {
    long long v45 = v51;
    unint64_t v46 = sub_1CC4A0738((llvm::EVT *)&v54);
    BOOL result = sub_1CB882C1C(a2, v45, *((uint64_t *)&v45 + 1), (llvm::Type *)((v46 >> 1) | ((unint64_t)(HIDWORD(v46) == 1) << 32)));
    goto LABEL_5;
  }
  char v27 = 10;
LABEL_28:
  *(unsigned char *)a5 = v27;
  *(_OWORD *)(a5 + 8) = v51;
  return result;
}

unint64_t sub_1CC4A0588(uint64_t a1, llvm::LLVMContext *a2, BOOL a3)
{
  if (*(unsigned char *)a1)
  {
    LOBYTE(EVT) = sub_1CB8C2FBC((unsigned __int8 *)a1);
    unint64_t v6 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    unint64_t EVT = llvm::EVT::getEVT(*(llvm::EVT **)(*(void *)(a1 + 8) + 24), 0, a3);
    uint64_t v7 = v11;
    unint64_t v6 = EVT & 0xFFFFFFFFFFFFFF00;
  }
  uint64_t v8 = v6 | EVT;
  unint64_t v9 = sub_1CC4A0738((llvm::EVT *)a1);

  return sub_1CB882C1C(a2, v8, v7, (llvm::Type *)((v9 >> 1) | ((unint64_t)(HIDWORD(v9) == 1) << 32)));
}

uint64_t sub_1CC4A0628(unsigned __int8 *a1, llvm::IntegerType *a2)
{
  if (*a1) {
    unsigned int ExtendedSizeInBits = sub_1CB87E200(a1);
  }
  else {
    unsigned int ExtendedSizeInBits = llvm::EVT::getExtendedSizeInBits((llvm::EVT *)a1);
  }
  if (v4 == 1)
  {
    unsigned int v7 = ExtendedSizeInBits;
    unsigned int ExtendedSizeInBits = v7;
  }
  if (ExtendedSizeInBits < 9) {
    return 3;
  }
  unint64_t v6 = (llvm::LLVMContext *)(1 << -__clz(ExtendedSizeInBits - 1));
  if ((int)v6 <= 31)
  {
    switch(v6)
    {
      case 1:
        return 2;
      case 0x10:
        return 4;
      case 8:
        return 3;
    }
  }
  else
  {
    switch(v6)
    {
      case 0x20:
        return 5;
      case 0x40:
        return 6;
      case 0x80:
        return 7;
    }
  }
  llvm::IntegerType::get(a2, v6);
  return 0;
}

unint64_t sub_1CC4A0738(llvm::EVT *this)
{
  if (*(unsigned char *)this) {
    return sub_1CB8C32B0((unsigned __int8 *)this) | ((unint64_t)(*(unsigned __int8 *)this
  }
                                                                                    - 120 < 0x33) << 32);

  return llvm::EVT::getExtendedVectorElementCount(this);
}

uint64_t llvm::TargetLoweringBase::isLegalRC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 **)(*(void *)(a2 + 264)
                           + 24
                           * (*(unsigned __int16 *)(*(void *)a3 + 24)
                            + *(_DWORD *)(a2 + 272)
                            * ((*(void *)(a2 + 248) - *(void *)(a2 + 240)) >> 3))
                           + 16);
  unsigned int v4 = *v3;
  if (v4 == 1) {
    return 0;
  }
  int v5 = v3 + 1;
  while (!v4 || !*(void *)(a1 + 8 * v4 + 96))
  {
    unsigned int v6 = *v5++;
    unsigned int v4 = v6;
    if (v6 == 1) {
      return 0;
    }
  }
  return 1;
}

llvm::MachineBasicBlock *llvm::TargetLoweringBase::emitPatchPoint(llvm::TargetLoweringBase *this, llvm::MachineInstr *a2, llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = *((unsigned int *)a2 + 10);
  if (!v4) {
    return v3;
  }
  unsigned int v6 = (unsigned char *)*((void *)a2 + 4);
  uint64_t v7 = *(void *)(*((void *)a2 + 3) + 32);
  uint64_t v8 = *(void *)(v7 + 56);
  uint64_t v9 = 32 * v4;
  while (*v6 != 5)
  {
    v6 += 32;
    v9 -= 32;
    if (!v9) {
      return v3;
    }
  }
  uint64_t v10 = *((void *)a2 + 2);
  uint64_t v11 = (unsigned __int8 *)*((void *)a2 + 7);
  uint64_t v49 = v11;
  if (v11) {
    llvm::MetadataTracking::track((uint64_t)&v49, v11, 2);
  }
  uint64_t v12 = (uint64_t)llvm::MachineFunction::CreateMachineInstr((llvm::MachineFunction *)v7, v10, &v49, 0);
  uint64_t v43 = v8;
  if (v49)
  {
    int v38 = *v49;
    if ((v38 - 4) > 0x1E)
    {
      if ((v38 - 3) >= 0xFFFFFFFE) {
        unint64_t v41 = v49;
      }
      else {
        unint64_t v41 = 0;
      }
      if ((v38 - 3) < 0xFFFFFFFE)
      {
        if (v38 == 3) {
          *((void *)v49 + 1) = 0;
        }
        goto LABEL_9;
      }
      unint64_t v40 = (unint64_t)(v41 + 8);
    }
    else
    {
      if ((v49[1] & 0x7F) != 2 && !*((_DWORD *)v49 + 3)) {
        goto LABEL_9;
      }
      uint64_t v39 = *((void *)v49 + 2);
      if ((v39 & 4) == 0) {
        goto LABEL_9;
      }
      unint64_t v40 = v39 & 0xFFFFFFFFFFFFFFF8;
      if (!v40) {
        goto LABEL_9;
      }
    }
    *(void *)&long long v47 = &v49;
    sub_1CC5FA668(v40 + 16, &v47);
  }
LABEL_9:
  llvm::MachineInstr::cloneMemRefs((const llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, a2);
  if (*((_DWORD *)a2 + 10))
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = (const llvm::MachineOperand *)(*((void *)a2 + 4) + v13);
      if (*(_DWORD *)v15 == 5)
      {
        int v17 = *((_DWORD *)v15 + 4);
        if (*(unsigned char *)(*(void *)(v8 + 8) + 40 * (*(_DWORD *)(v8 + 32) + v17) + 19))
        {
          LODWORD(v47) = 1;
          *((void *)&v47 + 1) = 0;
          *(void *)&long long v48 = 1;
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, (const llvm::MachineOperand *)&v47);
          uint64_t v18 = *(void *)(*(void *)(v8 + 8) + 40 * (*(_DWORD *)(v8 + 32) + v17) + 8);
          LODWORD(v47) = 1;
          *((void *)&v47 + 1) = 0;
          *(void *)&long long v48 = v18;
        }
        else
        {
          LODWORD(v47) = 1;
          *((void *)&v47 + 1) = 0;
          *(void *)&long long v48 = 0;
        }
        llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, (const llvm::MachineOperand *)&v47);
        llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, v15);
        LODWORD(v47) = 1;
        *((void *)&v47 + 1) = 0;
        *(void *)&long long v48 = 0;
        llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, (const llvm::MachineOperand *)&v47);
        uint64_t v8 = v43;
        if (**((_WORD **)a2 + 2) != 31)
        {
          FixedStacuint64_t k = llvm::PseudoSourceValueManager::getFixedStack(*(uint64_t ***)(v7 + 432), v17);
          v44[0] = (unint64_t)FixedStack | 4;
          v44[1] = 0;
          char v46 = 0;
          if (FixedStack) {
            int v21 = *((_DWORD *)FixedStack + 3);
          }
          else {
            int v21 = 0;
          }
          int v45 = v21;
          unint64_t v22 = ((unint64_t)*(unsigned int *)(*(void *)(*(void *)(*(void *)v7 + 40) + 504) + 4) + 7) >> 3;
          char v23 = *(unsigned char *)(*(void *)(v43 + 8) + 40 * (*(_DWORD *)(v43 + 32) + v17) + 16);
          long long v47 = 0u;
          long long v48 = 0u;
          unint64_t MachineMemOperand = (llvm::MachineMemOperand *)llvm::MachineFunction::getMachineMemOperand(v7, (uint64_t)v44, 1, v22, v23, &v47, 0, 1, 0, 0, 0);
          llvm::MachineInstr::addMemOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, MachineMemOperand);
        }
      }
      else
      {
        if (*(_DWORD *)v15) {
          BOOL v16 = 1;
        }
        else {
          BOOL v16 = (*(_DWORD *)v15 & 0xF00000) == 0;
        }
        if (v16)
        {
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, (const llvm::MachineOperand *)(*((void *)a2 + 4) + v13));
        }
        else
        {
          unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx(a2, v14);
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v12, (llvm::MachineFunction *)v7, v15);
          if (v14 > TiedOperandIdx) {
            llvm::MachineInstr::tieOperands(v12, TiedOperandIdx, *(_DWORD *)(v12 + 40) - 1);
          }
        }
      }
      ++v14;
      v13 += 32;
    }
    while (v14 < *((unsigned int *)a2 + 10));
  }
  uint64_t v3 = a3;
  uint64_t v25 = *((void *)a3 + 5);
  *(void *)(v12 + 24) = v25;
  uint64_t v26 = *(void *)(v25 + 32);
  uint64_t v27 = *(unsigned int *)(v12 + 40);
  if (v27)
  {
    uint64_t v31 = *(void *)(v12 + 32);
    uint64_t v32 = *(void *)(v26 + 40);
    uint64_t v33 = 32 * v27;
    do
    {
      if (!*(unsigned char *)v31)
      {
        uint64_t v34 = *(unsigned int *)(v31 + 4);
        if ((int)v34 >= 0) {
          uint64_t v35 = (uint64_t *)(*(void *)(v32 + 272) + 8 * v34);
        }
        else {
          uint64_t v35 = (uint64_t *)(*(void *)(v32 + 24) + 16 * (v34 & 0x7FFFFFFF) + 8);
        }
        uint64_t v36 = *v35;
        if (*v35)
        {
          uint64_t v37 = *(void *)(v36 + 16);
          *(void *)(v36 + 16) = v31;
          *(void *)(v31 + 16) = v37;
          if (*(unsigned char *)(v31 + 3))
          {
            *(void *)(v31 + 24) = v36;
          }
          else
          {
            *(void *)(v31 + 24) = 0;
            uint64_t v35 = (uint64_t *)(v37 + 24);
          }
        }
        else
        {
          *(void *)(v31 + 16) = v31;
          *(void *)(v31 + 24) = 0;
        }
        *uint64_t v35 = v31;
      }
      v31 += 32;
      v33 -= 32;
    }
    while (v33);
  }
  uint64_t v28 = *(void *)(v26 + 728);
  if (v28) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v28 + 24))(v28, v12);
  }
  unint64_t v29 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
  *(void *)uint64_t v12 = v29 | *(void *)v12 & 7;
  *(void *)(v12 + 8) = a2;
  *(void *)(v29 + 8) = v12;
  *(void *)a2 = *(void *)a2 & 7 | v12;
  llvm::MachineInstr::eraseFromParent(a2);
  return v3;
}

void *llvm::TargetLoweringBase::findRepresentativeClass(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void **)(a1 + 8 * a3 + 96);
  if (v3)
  {
    uint64_t v7 = (*(void *)(a2 + 248) - *(void *)(a2 + 240)) >> 3;
    v44[0] = v45;
    v44[1] = (void *)0x600000000;
    sub_1CB90D610((uint64_t)v44, (v7 + 63) >> 6, 0);
    int v46 = v7;
    uint64_t v8 = (_WORD *)v3[2];
    if (*v8)
    {
      uint64_t v9 = 4 * ((((*(void *)(a2 + 248) - *(void *)(a2 + 240)) >> 3) + 31) >> 5);
      uint64_t v10 = (unsigned int *)(v3[1] + v9);
      uint64_t v11 = v8 + 1;
      do
      {
        sub_1CB9F9B60((uint64_t)v44, v10, 0xFFFFFFFF);
        int v12 = *v11++;
        uint64_t v10 = (unsigned int *)((char *)v10 + v9);
      }
      while (v12);
      LODWORD(v7) = v46;
    }
    if (v7)
    {
      uint64_t v13 = 0;
      uint64_t v14 = (v7 - 1) >> 6;
      uint64_t v15 = v14 << 6;
      BOOL v16 = (uint64_t *)v44[0];
      while (1)
      {
        uint64_t v18 = *v16++;
        uint64_t v17 = v18;
        unint64_t v19 = v15 + v13 ? -1 : 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
        unint64_t v20 = v19 & v17;
        if (v20) {
          break;
        }
        v13 -= 64;
        if (v15 + v13 == -64) {
          goto LABEL_38;
        }
      }
      int v21 = __clz(__rbit64(v20));
      if (v21 + 1 != v13)
      {
        LODWORD(v22) = v21 - v13;
        uint64_t v23 = (v21 - v13);
        uint64_t v24 = *(void *)(a2 + 264);
        uint64_t v25 = *(void *)(a2 + 240);
        int v26 = *(_DWORD *)(a2 + 272) * ((unint64_t)(*(void *)(a2 + 248) - v25) >> 3);
        do
        {
          uint64_t v27 = *(void **)(v25 + 8 * v23);
          unsigned int v28 = v26 + *(unsigned __int16 *)(*v27 + 24);
          if (*(_DWORD *)(v24 + 24 * v28 + 4) >> 3 > *(_DWORD *)(v24
                                                                  + 24
                                                                  * (v26
                                                                   + *(unsigned __int16 *)(*v3 + 24))
                                                                  + 4) >> 3)
          {
            for (uint64_t i = *(unsigned char **)(v24 + 24 * v28 + 16); ; ++i)
            {
              uint64_t v30 = *i;
              if (v30 == 1) {
                break;
              }
              if (*i && *(void *)(a1 + 8 * v30 + 96))
              {
                uint64_t v3 = v27;
                break;
              }
            }
          }
          unsigned int v31 = v22 + 1;
          if (v22 + 1 == v7) {
            break;
          }
          unsigned int v32 = v31 >> 6;
          if (v31 >> 6 > v14) {
            break;
          }
          uint64_t v33 = 0;
          int v35 = v31 & 0x3F;
          BOOL v34 = v35 == 0;
          unint64_t v36 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v35;
          uint64_t v37 = v34 ? -1 : ~v36;
          unint64_t v38 = (unint64_t)v32 << 6;
          uint64_t v39 = v14 - v32;
          unint64_t v40 = (char *)v44[0] + 8 * v32;
          while (1)
          {
            uint64_t v41 = v33 ? -1 : v37;
            unint64_t v42 = v39 == v33 ? 0xFFFFFFFFFFFFFFFFLL >> -(char)v7 : -1;
            unint64_t v43 = v41 & v42 & *(void *)&v40[8 * v33];
            if (v43) {
              break;
            }
            v38 += 64;
            if (v39 + 1 == ++v33) {
              goto LABEL_38;
            }
          }
          unint64_t v22 = __clz(__rbit64(v43)) + v38;
          uint64_t v23 = v22;
        }
        while (v22 != -1);
      }
    }
LABEL_38:
    if (v44[0] != v45) {
      free(v44[0]);
    }
  }
  return v3;
}

uint64_t llvm::TargetLoweringBase::computeRegisterProperties(llvm::TargetLoweringBase *this, const llvm::TargetRegisterInfo *a2)
{
  uint64_t v4 = (char *)this + 173805;
  memset_pattern16((char *)this + 1528, &unk_1CFAC74F0, 0x166uLL);
  for (uint64_t i = 0; i != 179; ++i)
  {
    unsigned int v6 = (char *)this + i;
    v6[3683] = i;
    v6[1886] = i;
  }
  *((_WORD *)this + 937) = 0;
  LODWORD(v7) = 7;
  do
  {
    uint64_t v8 = *((void *)this + v7 + 12);
    uint64_t v7 = (v7 - 1);
  }
  while (!v8);
  uint64_t v9 = (v7 + 2);
  uint64_t v10 = (v7 + 1);
  if (v9 <= 7)
  {
    unsigned int v11 = v7 + 1;
    do
    {
      *((_WORD *)this + v9 + 764) = 2 * *((_WORD *)this + v11 + 764);
      int v12 = (char *)this + v9;
      v12[1886] = v7 + 1;
      v12[3683] = v11;
      *((unsigned char *)this + v9++ + 173796) = 2;
      ++v11;
    }
    while (v9 != 8);
  }
  if (v7 >= 2)
  {
    do
    {
      if (!(_BYTE)v7 || (uint64_t v13 = v7, !*((void *)this + v7 + 12)))
      {
        uint64_t v14 = (char *)this + v7;
        v14[3683] = v10;
        v14[1886] = v10;
        *((unsigned char *)this + v7 + 173796) = 1;
        uint64_t v13 = v10;
      }
      --v7;
      uint64_t v10 = v13;
    }
    while ((v7 & 0xFFFFFFFE) != 0);
  }
  if (!*((void *)this + 26))
  {
    if (*((void *)this + 23))
    {
      __int16 v15 = 2 * *((_WORD *)this + 775);
      char v17 = 4;
      char v16 = 11;
      char v18 = 11;
    }
    else
    {
      __int16 v15 = *((_WORD *)this + 771);
      char v16 = *((unsigned char *)this + 1893);
      char v17 = 3;
      char v18 = 7;
    }
    *((_WORD *)this + 778) = v15;
    *((unsigned char *)this + 1900) = v16;
    *((unsigned char *)this + 3697) = v18;
    v4[5] = v17;
  }
  if (!*((void *)this + 25))
  {
    *((_WORD *)this + 777) = *((_WORD *)this + 771);
    *((unsigned char *)this + 1899) = *((unsigned char *)this + 1893);
    *((unsigned char *)this + 3696) = 7;
    v4[4] = 3;
  }
  if (!*((void *)this + 23))
  {
    *((_WORD *)this + 775) = *((_WORD *)this + 770);
    *((unsigned char *)this + 1897) = *((unsigned char *)this + 1892);
    *((unsigned char *)this + 3694) = 6;
    v4[2] = 3;
  }
  if (!*((void *)this + 22))
  {
    *((_WORD *)this + 774) = *((_WORD *)this + 769);
    *((unsigned char *)this + 1896) = *((unsigned char *)this + 1891);
    *((unsigned char *)this + 3693) = 5;
    v4[1] = 3;
  }
  long long v78 = a2;
  if (!*((void *)this + 21))
  {
    if ((*(unsigned int (**)(llvm::TargetLoweringBase *))(*(void *)this + 128))(this))
    {
      *((_WORD *)this + 773) = *((_WORD *)this + 768);
      *((unsigned char *)this + 1895) = *((unsigned char *)this + 1890);
      *((unsigned char *)this + 3692) = 10;
      char v77 = 9;
    }
    else
    {
      *((_WORD *)this + 773) = *((_WORD *)this + 774);
      *((unsigned char *)this + 1895) = *((unsigned char *)this + 1896);
      *((unsigned char *)this + 3692) = 10;
      char v77 = 8;
    }
    *uint64_t v4 = v77;
  }
  uint64_t v80 = (char *)this + 173796;
  int v19 = 16;
  for (unint64_t j = 15; j != 171; ++j)
  {
    unsigned __int8 v83 = j;
    if (*((void *)this + j + 12)) {
      goto LABEL_93;
    }
    unsigned __int8 v82 = sub_1CB8C2FBC(&v83);
    unsigned int v21 = sub_1CB8C32B0(&v83);
    unsigned int v22 = v83 - 120;
    int v23 = (*(uint64_t (**)(llvm::TargetLoweringBase *))(*(void *)this + 120))(this);
    int v25 = v23;
    if (v23 == 1)
    {
      if (v22 >= 0x33) {
        unint64_t v26 = 74;
      }
      else {
        unint64_t v26 = 151;
      }
      if (j < v26)
      {
        int v27 = j;
        while (1)
        {
          unsigned __int8 v28 = v27++ - 14;
          v84[0] = v27;
          char v29 = v28 > 0x9Bu ? v27 : sub_1CB8C2FBC(v84);
          LOBYTE(v89[0]) = v29;
          unint64_t v30 = sub_1CB87E200((unsigned __int8 *)v89);
          if (v30 > sub_1CB87E200(&v82))
          {
            int v31 = sub_1CB8C32B0(v84);
            unsigned __int8 v32 = v84[0];
            if (v31 == v21)
            {
              BOOL v33 = v22 < 0x33 == (v84[0] + 85) < 0xCDu || v84[0] == 0;
              if (!v33 && *((void *)this + v84[0] + 12)) {
                break;
              }
            }
          }
          if (v26 == v27) {
            goto LABEL_46;
          }
        }
        BOOL v34 = (char *)this + j;
        v34[3683] = v84[0];
        v34[1886] = v32;
        char v35 = 1;
        *((_WORD *)this + j + 764) = 1;
        uint64_t v36 = v83;
        uint64_t v37 = (char *)this + 173796;
        goto LABEL_92;
      }
    }
    else if (v23 != 7)
    {
      goto LABEL_59;
    }
LABEL_46:
    v24.i32[0] = v21;
    uint8x8_t v38 = (uint8x8_t)vcnt_s8(v24);
    v38.i16[0] = vaddlv_u8(v38);
    if (v38.i32[0] == 1)
    {
      if (j <= 0xA9)
      {
        int v39 = v19;
        while (1)
        {
          LOBYTE(v89[0]) = v39;
          unsigned __int8 v40 = sub_1CB8C2FBC((unsigned __int8 *)v89);
          if (v82 == v40
            && v22 < 0x33 == LOBYTE(v89[0]) - 120 < 0x33
            && sub_1CB8C32B0((unsigned __int8 *)v89) > v21)
          {
            char v41 = v89[0];
            if (LOBYTE(v89[0]))
            {
              if (*((void *)this + LOBYTE(v89[0]) + 12)) {
                break;
              }
            }
          }
          if (++v39 == 171) {
            goto LABEL_59;
          }
        }
        uint64_t v71 = (char *)this + j;
        v71[3683] = v89[0];
        v71[1886] = v41;
        *((_WORD *)this + j + 764) = 1;
        uint64_t v72 = v83;
        char v73 = 7;
        goto LABEL_117;
      }
    }
    else
    {
      unsigned __int8 v42 = sub_1CC4A1730(&v83);
      if (v42 && *((void *)this + v42 + 12))
      {
        int v76 = (char *)this + j;
        v76[3683] = v42;
        v80[v83] = 7;
        v76[1886] = v42;
        *((_WORD *)this + j + 764) = 1;
        goto LABEL_93;
      }
    }
LABEL_59:
    int v81 = v25;
    unsigned __int8 v88 = v83;
    unsigned int v43 = sub_1CB8C32B0(&v88);
    int v44 = v88;
    char v45 = sub_1CB8C2FBC(&v88);
    v46.i32[0] = v43;
    uint8x8_t v47 = (uint8x8_t)vcnt_s8(v46);
    v47.i16[0] = vaddlv_u8(v47);
    if (v47.i32[0] == 1) {
      unsigned int v48 = v43;
    }
    else {
      unsigned int v48 = 1;
    }
    if (v47.i32[0] == 1) {
      int v49 = 1;
    }
    else {
      int v49 = v43;
    }
    BOOL v50 = (v44 - 120) < 0x33 && v47.i32[0] == 1;
    if (v48 >= 2)
    {
      while (1)
      {
        unsigned __int8 v51 = v50 ? sub_1CB882CA4(v45, v43) : sub_1CB883124(v45, v43);
        if (v51 && *((void *)this + v51 + 12)) {
          break;
        }
        unsigned int v48 = v43 >> 1;
        v49 *= 2;
        BOOL v52 = v43 > 3;
        v43 >>= 1;
        if (!v52) {
          goto LABEL_77;
        }
      }
      unsigned int v48 = v43;
    }
LABEL_77:
    if (v50) {
      unsigned __int8 v53 = sub_1CB882CA4(v45, v48);
    }
    else {
      unsigned __int8 v53 = sub_1CB883124(v45, v48);
    }
    unsigned __int8 v87 = v53;
    if (!v53 || !*((void *)this + v53 + 12))
    {
      unsigned __int8 v87 = v45;
      unsigned __int8 v53 = v45;
    }
    if ((v53 - 15) <= 0x9Bu) {
      unsigned __int8 v53 = sub_1CB8C2FBC(&v87);
    }
    LOBYTE(v89[0]) = v53;
    unsigned int v54 = sub_1CB87E200((unsigned __int8 *)v89);
    LODWORD(v55) = v54;
    uint8x8_t v56 = (uint8x8_t)vcnt_s8((int8x8_t)v54);
    v56.i16[0] = vaddlv_u8(v56);
    if (v56.i32[0] != 1)
    {
      unint64_t v74 = v54 | ((unint64_t)v54 >> 1) | ((v54 | ((unint64_t)v54 >> 1)) >> 2);
      unint64_t v75 = v74 | (v74 >> 4) | ((v74 | (v74 >> 4)) >> 8);
      uint64_t v55 = (v75 | (v75 >> 16)) + 1;
    }
    int v57 = v87;
    int v58 = *((unsigned __int8 *)this + v87 + 1886);
    unsigned __int8 v86 = v58;
    v84[0] = v58;
    uint64_t v85 = 0;
    if (v58 != v87)
    {
      v89[0] = v87;
      v89[1] = 0;
      uint64_t v61 = v58 ? (llvm::Type *)sub_1CB87E200(v84) : llvm::EVT::getExtendedSizeInBits((llvm::EVT *)v84);
      uint64_t v79 = v61;
      int v63 = v62;
      unint64_t v64 = v57
          ? (llvm::Type *)sub_1CB87E200((unsigned __int8 *)v89)
          : llvm::EVT::getExtendedSizeInBits((llvm::EVT *)v89);
      if ((v63 != 1 || v65 == 1) && v79 < v64)
      {
        unsigned __int8 v66 = v86;
        if ((v86 - 15) <= 0x9Bu) {
          unsigned __int8 v66 = sub_1CB8C2FBC(&v86);
        }
        LOBYTE(v89[0]) = v66;
        v49 *= (v55 / (unint64_t)sub_1CB87E200((unsigned __int8 *)v89));
      }
    }
    *((_WORD *)this + j + 764) = v49;
    *((unsigned char *)this + j + 1886) = v58;
    unsigned __int8 v59 = sub_1CC4A1730(&v83);
    uint64_t v36 = v83;
    char v60 = (unsigned __int8 *)this + j + 3683;
    if (v83 != v59)
    {
      *char v60 = v59;
      uint64_t v37 = (char *)this + 173796;
      char v35 = 7;
      goto LABEL_92;
    }
    *char v60 = 1;
    if (v81 == 5)
    {
      uint64_t v36 = v59;
      uint64_t v37 = (char *)this + 173796;
      char v35 = 5;
      goto LABEL_92;
    }
    if (v81 == 6)
    {
      uint64_t v72 = v59;
      char v73 = 6;
LABEL_117:
      v80[v72] = v73;
      goto LABEL_93;
    }
    if (v21 >= 2)
    {
      uint64_t v36 = v59;
      uint64_t v37 = (char *)this + 173796;
      char v35 = 6;
LABEL_92:
      v37[v36] = v35;
      goto LABEL_93;
    }
    if (v22 >= 0x33) {
      char v67 = 5;
    }
    else {
      char v67 = 10;
    }
    v80[v59] = v67;
LABEL_93:
    ++v19;
  }
  for (uint64_t k = 0; k != 179; ++k)
  {
    uint64_t result = (*(uint64_t (**)(llvm::TargetLoweringBase *, const llvm::TargetRegisterInfo *, uint64_t))(*(void *)this + 1048))(this, v78, k);
    *((void *)this + k + 259) = result;
    *((unsigned char *)this + k + 3504) = v70;
  }
  return result;
}

unint64_t sub_1CC4A1730(unsigned __int8 *a1)
{
  int v2 = sub_1CB8C32B0(a1);
  if ((v2 & (v2 - 1)) == 0) {
    return *a1;
  }
  int v4 = sub_1CB8C32B0(a1);
  unsigned int v5 = *a1 - 120;
  int v6 = 1 << -__clz(v4 - 1);
  char v7 = sub_1CB8C2FBC(a1);
  if (v5 <= 0x32)
  {
    return sub_1CB882CA4(v7, v6);
  }
  else
  {
    return sub_1CB883124(v7, v6);
  }
}

BOOL llvm::TargetLoweringBase::isSuitableForJumpTable(llvm::TargetLoweringBase *this, const llvm::SwitchInst *a2, uint64_t a3, unint64_t a4, llvm::ProfileSummaryInfo *a5, llvm::BlockFrequencyInfoImplBase **a6)
{
  uint64_t v8 = (llvm::BasicBlock *)*((void *)a2 + 5);
  uint64_t v9 = *(void *)(*((void *)v8 + 7) + 112);
  if (v9 && ((*(unsigned char *)(v9 + 17) & 4) != 0 || *(char *)(v9 + 13) < 0)) {
    goto LABEL_8;
  }
  int shouldOptimizeForSize = llvm::shouldOptimizeForSize(v8, a5, a6);
  if ((shouldOptimizeForSize & 1) == 0 && dword_1EBCD45D8 < a4) {
    return 0;
  }
  if (shouldOptimizeForSize) {
LABEL_8:
  }
    int v12 = &dword_1EBCD4758;
  else {
    int v12 = &dword_1EBCD4698;
  }
  return 100 * a3 >= *v12 * a4;
}

uint64_t llvm::TargetLoweringBase::getMinimumJumpTableDensity(llvm::TargetLoweringBase *this, int a2)
{
  uint64_t v2 = 72;
  if (a2) {
    uint64_t v2 = 96;
  }
  return LODWORD(qword_1EBCD43D8[v2 + 16]);
}

uint64_t llvm::TargetLoweringBase::getMaximumJumpTableSize(llvm::TargetLoweringBase *this)
{
  return dword_1EBCD45D8;
}

uint64_t llvm::TargetLoweringBase::InstructionOpcodeToISD(llvm::TargetLoweringBase *this, int a2)
{
  return dword_1CFAC7880[a2 - 1];
}

uint64_t llvm::TargetLoweringBase::getTypeLegalizationCost@<X0>(llvm::TargetLoweringBase *this@<X0>, const llvm::DataLayout *a2@<X1>, llvm::LLVMContext **a3@<X2>, uint64_t a4@<X8>)
{
  int v6 = *a3;
  unint64_t v7 = sub_1CB87DC14((uint64_t)this, (uint64_t)a2, (llvm::EVT *)a3, 0);
  uint64_t v9 = v8;
  *(void *)&long long v17 = 1;
  DWORD2(v17) = 0;
  while (1)
  {
    int v10 = v7;
    uint64_t result = llvm::TargetLoweringBase::getTypeConversion((unint64_t)this, v6, v7, v9, (uint64_t)v14);
    if (!v14[0])
    {
LABEL_3:
      long long v12 = v17;
      goto LABEL_4;
    }
    if (v14[0] == 10) {
      break;
    }
    if ((v14[0] & 0xFB) == 2)
    {
      uint64_t v18 = 2;
      int v19 = 0;
      uint64_t result = sub_1CB90C9D4((uint64_t)&v17, (uint64_t)&v18);
    }
    unint64_t v7 = v15;
    if (v10 == v15)
    {
      if (v10) {
        goto LABEL_3;
      }
      uint64_t v13 = v16;
      if (v9 == v16) {
        goto LABEL_3;
      }
    }
    else
    {
      uint64_t v13 = v16;
    }
    uint64_t v9 = v13;
  }
  if (!v10) {
    LOBYTE(v10) = 6;
  }
  long long v12 = xmmword_1CD96D880;
LABEL_4:
  *(_OWORD *)a4 = v12;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

BOOL llvm::TargetLoweringBase::isLegalAddressingMode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  if ((unint64_t)(v3 + 0xFFFF) > 0x1FFFD || *(void *)a3 != 0) {
    return 0;
  }
  uint64_t v6 = *(void *)(a3 + 24);
  if (!v6) {
    return 1;
  }
  if (v6 != 2) {
    return v6 == 1 && (!v3 || !*(unsigned char *)(a3 + 16));
  }
  BOOL result = 0;
  if (!v3 && !*(unsigned char *)(a3 + 16)) {
    return 1;
  }
  return result;
}

uint64_t llvm::TargetLoweringBase::setMinimumJumpTableEntries(llvm::TargetLoweringBase *this, int a2)
{
  int v5 = a2;
  dword_1EBCD4518 = a2;
  if (qword_1EBCD4550) {
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)qword_1EBCD4550 + 48))(qword_1EBCD4550, &v5);
  }
  sub_1CB920400();
  return llvm::TargetLoweringBase::setMaximumJumpTableSize(v3, v4);
}

uint64_t llvm::TargetLoweringBase::setMaximumJumpTableSize(llvm::TargetLoweringBase *this, int a2)
{
  int v3 = a2;
  dword_1EBCD45D8 = a2;
  if (qword_1EBCD4610) {
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)qword_1EBCD4610 + 48))(qword_1EBCD4610, &v3);
  }
  sub_1CB920400();
  return sub_1CC4A1AF0();
}

uint64_t sub_1CC4A1AF0(int a1, uint64_t a2, uint64_t a3, uint64_t a4, size_t a5)
{
  v41[8] = *MEMORY[0x1E4F143B8];
  v38[0] = a4;
  v38[1] = a5;
  if (!a5) {
    return 0xFFFFFFFFLL;
  }
  int v39 = v41;
  uint64_t v40 = 0x400000000;
  llvm::StringRef::split((char *)v38, (uint64_t)&v39, 44, -1, 1);
  if (v40 != 1) {
    goto LABEL_24;
  }
  v37.__r_.__value_.__r.__words[0] = 0;
  int v10 = sub_1CC4A2968((unsigned char *)a4, a5, &v37, &__p);
  std::string::size_type v11 = v37.__r_.__value_.__r.__words[0];
  if (a5 < v37.__r_.__value_.__r.__words[0]) {
    std::string::size_type v11 = a5;
  }
  if (!v10) {
    std::string::size_type v11 = a5;
  }
  switch(v11)
  {
    case 7uLL:
      if (*(_DWORD *)a4 != 1634100580 || *(_DWORD *)(a4 + 3) != 1953264993) {
        goto LABEL_24;
      }
      uint64_t v13 = 0xFFFFFFFFLL;
      break;
    case 4uLL:
      if (*(_DWORD *)a4 != 1701736302)
      {
LABEL_24:
        sub_1CC4A2A18(&v37, a1, a2, a3);
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          sub_1CB8BDF7C((uint64_t)&__p, v37.__r_.__value_.__l.__data_, v37.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v37;
        }
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        std::string::size_type v17 = size - 1;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          __p.__r_.__value_.__l.__size_ = v17;
        }
        else {
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = v17 & 0x7F;
        }
        p_p->__r_.__value_.__s.__data_[v17] = 0;
        if (v40)
        {
          uint64_t v18 = (char *)v39;
          int v19 = (char *)v39 + 16 * v40;
          while (1)
          {
            unint64_t v20 = *(unsigned char **)v18;
            size_t v21 = *((void *)v18 + 1);
            size_t v35 = 0;
            int v22 = sub_1CC4A2968(v20, v21, &v35, &v34);
            size_t v23 = v35;
            if (v21 < v35) {
              size_t v23 = v21;
            }
            if (v22) {
              size_t v24 = v23;
            }
            else {
              size_t v24 = v21;
            }
            int v25 = *v20;
            if (v24) {
              BOOL v26 = v25 == 33;
            }
            else {
              BOOL v26 = 0;
            }
            uint64_t v27 = v26;
            if (v26) {
              ++v20;
            }
            size_t v28 = v24 - v27;
            if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v29 = &v37;
            }
            else {
              char v29 = (std::string *)v37.__r_.__value_.__r.__words[0];
            }
            std::string::size_type v30 = *((unsigned char *)&v37.__r_.__value_.__s + 23) & 0x7F;
            if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v30 = v37.__r_.__value_.__l.__size_;
            }
            if (v28 == v30 && (v24 == v27 || !memcmp(v20, v29, v24 - v27))) {
              break;
            }
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v31 = &__p;
            }
            else {
              int v31 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            std::string::size_type v32 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type v32 = __p.__r_.__value_.__l.__size_;
            }
            if (v28 == v32 && (v24 == v27 || !memcmp(v20, v31, v24 - v27))) {
              break;
            }
            v18 += 16;
            if (v18 == v19)
            {
              uint64_t v13 = 0xFFFFFFFFLL;
              goto LABEL_69;
            }
          }
          uint64_t v13 = v25 != 33;
        }
        else
        {
          uint64_t v13 = 0xFFFFFFFFLL;
        }
LABEL_69:
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v37.__r_.__value_.__l.__data_);
        }
        break;
      }
      uint64_t v13 = 0;
      break;
    case 3uLL:
      if (*(_WORD *)a4 != 27745 || *(unsigned char *)(a4 + 2) != 108) {
        goto LABEL_24;
      }
      uint64_t v13 = 1;
      break;
    default:
      goto LABEL_24;
  }
  if (v39 != v41) {
    free(v39);
  }
  return v13;
}

uint64_t sub_1CC4A1E20(int a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, size_t a5)
{
  v35[8] = *MEMORY[0x1E4F143B8];
  v32[0] = a4;
  v32[1] = a5;
  if (!a5) {
    return 0xFFFFFFFFLL;
  }
  BOOL v33 = v35;
  uint64_t v34 = 0x400000000;
  llvm::StringRef::split((char *)v32, (uint64_t)&v33, 44, -1, 1);
  if (v34 != 1) {
    goto LABEL_16;
  }
  v31.__r_.__value_.__r.__words[0] = 0;
  __p.__r_.__value_.__s.__data_[0] = 0;
  if (sub_1CC4A2968(a4, a5, &v31, &__p))
  {
    std::string::size_type v10 = v31.__r_.__value_.__r.__words[0];
    if (a5 < v31.__r_.__value_.__r.__words[0]) {
      std::string::size_type v10 = a5;
    }
    if (v10 == 7)
    {
      int v11 = *(_DWORD *)((char *)a4 + 3);
      BOOL v12 = *(_DWORD *)a4 == 1634100580;
      int v13 = 1953264993;
    }
    else
    {
      if (v10 != 3)
      {
LABEL_16:
        sub_1CC4A2A18(&v31, a1, a2, a3);
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          sub_1CB8BDF7C((uint64_t)&__p, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
        }
        else {
          std::string __p = v31;
        }
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        p_p = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        std::string::size_type v18 = size - 1;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          __p.__r_.__value_.__l.__size_ = v18;
        }
        else {
          *((unsigned char *)&__p.__r_.__value_.__s + 23) = v18 & 0x7F;
        }
        p_p->__r_.__value_.__s.__data_[v18] = 0;
        if (v34)
        {
          int v19 = (char *)v33;
          unint64_t v20 = (char *)v33 + 16 * v34;
          while (1)
          {
            size_t v21 = *(unsigned char **)v19;
            size_t v22 = *((void *)v19 + 1);
            size_t v29 = 0;
            unsigned __int8 v28 = 0;
            if (sub_1CC4A2968(v21, v22, &v29, &v28))
            {
              if (v22 >= v29) {
                size_t v22 = v29;
              }
              if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                size_t v23 = &v31;
              }
              else {
                size_t v23 = (std::string *)v31.__r_.__value_.__r.__words[0];
              }
              std::string::size_type v24 = *((unsigned char *)&v31.__r_.__value_.__s + 23) & 0x7F;
              if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type v24 = v31.__r_.__value_.__l.__size_;
              }
              if (v22 == v24 && (!v22 || !memcmp(v21, v23, v22))) {
                break;
              }
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                int v25 = &__p;
              }
              else {
                int v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              std::string::size_type v26 = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                std::string::size_type v26 = __p.__r_.__value_.__l.__size_;
              }
              if (v22 == v26 && (!v22 || !memcmp(v21, v25, v22))) {
                break;
              }
            }
            v19 += 16;
            if (v19 == v20) {
              goto LABEL_48;
            }
          }
          uint64_t v14 = v28;
        }
        else
        {
LABEL_48:
          uint64_t v14 = 0xFFFFFFFFLL;
        }
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v31.__r_.__value_.__l.__data_);
        }
        goto LABEL_54;
      }
      int v11 = *((unsigned __int8 *)a4 + 2);
      BOOL v12 = *a4 == 27745;
      int v13 = 108;
    }
    if (!v12 || v11 != v13) {
      goto LABEL_16;
    }
    uint64_t v14 = __p.__r_.__value_.__s.__data_[0];
  }
  else
  {
    uint64_t v14 = 0xFFFFFFFFLL;
  }
LABEL_54:
  if (v33 != v35) {
    free(v33);
  }
  return v14;
}

void llvm::TargetLoweringBase::finalizeLowering(llvm::TargetLoweringBase *this, llvm::MachineRegisterInfo **a2)
{
}

uint64_t llvm::TargetLoweringBase::getLoadMemOperandFlags(llvm::TargetLoweringBase *this, uint64_t ***a2, const llvm::DataLayout *a3)
{
  __int16 v6 = *((_WORD *)a2 + 9);
  unint64_t v7 = a2[6];
  int v8 = *((_DWORD *)a2 + 5);
  if (v6)
  {
    if (v7)
    {
      if ((v8 & 0x20000000) == 0)
      {
        LODWORD(v46) = 0;
LABEL_99:
        int v8 = *((_DWORD *)a2 + 5);
LABEL_66:
        if ((v8 & 0x20000000) == 0) {
          goto LABEL_67;
        }
        uint64_t v48 = ***a2;
        unsigned __int8 v82 = (const llvm::LoadInst *)a2;
        int v49 = *(_DWORD *)(v48 + 2496);
        if (v49)
        {
          uint64_t v50 = *(void *)(v48 + 2480);
          int v51 = v49 - 1;
          unsigned int v52 = v51 & ((a2 >> 4) ^ (a2 >> 9));
          unsigned __int8 v53 = (const llvm::LoadInst **)(v50 + 40 * v52);
          unsigned int v54 = *v53;
          if (*v53 == (const llvm::LoadInst *)a2) {
            goto LABEL_75;
          }
          int v58 = 0;
          int v59 = 1;
          while (v54 != (const llvm::LoadInst *)-4096)
          {
            if (v58) {
              BOOL v60 = 0;
            }
            else {
              BOOL v60 = v54 == (const llvm::LoadInst *)-8192;
            }
            if (v60) {
              int v58 = v53;
            }
            unsigned int v61 = v52 + v59++;
            unsigned int v52 = v61 & v51;
            unsigned __int8 v53 = (const llvm::LoadInst **)(v50 + 40 * v52);
            unsigned int v54 = *v53;
            if (*v53 == (const llvm::LoadInst *)a2) {
              goto LABEL_75;
            }
          }
          int v81 = v46;
          if (v58) {
            uint64_t v79 = v58;
          }
          else {
            uint64_t v79 = v53;
          }
        }
        else
        {
          int v81 = v46;
          uint64_t v79 = 0;
        }
        unsigned __int8 v53 = (const llvm::LoadInst **)sub_1CC609054(v48 + 2480, (uint64_t)&v82, (uint64_t *)&v82, v79);
        uint64_t v80 = v82;
        v53[3] = 0;
        v53[4] = 0;
        *unsigned __int8 v53 = v80;
        v53[1] = (const llvm::LoadInst *)(v53 + 3);
        v53[2] = (const llvm::LoadInst *)0x100000000;
        LODWORD(v46) = v81;
LABEL_75:
        uint64_t v55 = *((unsigned int *)v53 + 4);
        if (v55)
        {
          uint8x8_t v56 = (void *)((char *)v53[1] + 8);
          uint64_t v57 = 16 * v55;
          while (*((_DWORD *)v56 - 2) != 6)
          {
            v56 += 2;
            v57 -= 16;
            if (!v57) {
              goto LABEL_67;
            }
          }
          uint64_t v75 = *v56;
          if (v6) {
            int v76 = 5;
          }
          else {
            int v76 = 1;
          }
          if (v46) {
            int v10 = v76 | 8;
          }
          else {
            int v10 = v76;
          }
          if (v75) {
            goto LABEL_54;
          }
          goto LABEL_9;
        }
LABEL_67:
        if (v6) {
          int v47 = 5;
        }
        else {
          int v47 = 1;
        }
        if (v46) {
          int v10 = v47 | 8;
        }
        else {
          int v10 = v47;
        }
        goto LABEL_9;
      }
    }
    else if ((v8 & 0x20000000) == 0)
    {
      LODWORD(v46) = 0;
      goto LABEL_66;
    }
    uint64_t v62 = ***a2;
    unsigned __int8 v82 = (const llvm::LoadInst *)a2;
    int v63 = *(_DWORD *)(v62 + 2496);
    if (v63)
    {
      uint64_t v64 = *(void *)(v62 + 2480);
      int v65 = v63 - 1;
      unsigned int v66 = v65 & ((a2 >> 4) ^ (a2 >> 9));
      char v67 = (const llvm::LoadInst **)(v64 + 40 * v66);
      unsigned int v68 = *v67;
      if (*v67 == (const llvm::LoadInst *)a2) {
        goto LABEL_95;
      }
      uint64_t v71 = 0;
      int v72 = 1;
      while (v68 != (const llvm::LoadInst *)-4096)
      {
        if (v71) {
          BOOL v73 = 0;
        }
        else {
          BOOL v73 = v68 == (const llvm::LoadInst *)-8192;
        }
        if (v73) {
          uint64_t v71 = v67;
        }
        unsigned int v74 = v66 + v72++;
        unsigned int v66 = v74 & v65;
        char v67 = (const llvm::LoadInst **)(v64 + 40 * v66);
        unsigned int v68 = *v67;
        if (*v67 == (const llvm::LoadInst *)a2) {
          goto LABEL_95;
        }
      }
      if (v71) {
        char v77 = v71;
      }
      else {
        char v77 = v67;
      }
    }
    else
    {
      char v77 = 0;
    }
    char v67 = (const llvm::LoadInst **)sub_1CC609054(v62 + 2480, (uint64_t)&v82, (uint64_t *)&v82, v77);
    long long v78 = v82;
    v67[3] = 0;
    v67[4] = 0;
    char *v67 = v78;
    v67[1] = (const llvm::LoadInst *)(v67 + 3);
    _OWORD v67[2] = (const llvm::LoadInst *)0x100000000;
LABEL_95:
    uint64_t v46 = *((unsigned int *)v67 + 4);
    if (v46)
    {
      int v69 = (void *)((char *)v67[1] + 8);
      uint64_t v70 = 16 * v46;
      while (*((_DWORD *)v69 - 2) != 9)
      {
        LODWORD(v46) = 0;
        v69 += 2;
        v70 -= 16;
        if (!v70) {
          goto LABEL_99;
        }
      }
      LODWORD(v46) = *v69 != 0;
    }
    goto LABEL_99;
  }
  if (v7)
  {
    if ((v8 & 0x20000000) == 0)
    {
LABEL_21:
      BOOL v9 = 0;
      goto LABEL_22;
    }
  }
  else if ((v8 & 0x20000000) == 0)
  {
    BOOL v9 = 0;
    goto LABEL_5;
  }
  uint64_t v13 = ***a2;
  unsigned __int8 v82 = (const llvm::LoadInst *)a2;
  int v14 = *(_DWORD *)(v13 + 2496);
  if (v14)
  {
    uint64_t v15 = *(void *)(v13 + 2480);
    int v16 = v14 - 1;
    unsigned int v17 = v16 & ((a2 >> 4) ^ (a2 >> 9));
    std::string::size_type v18 = (const llvm::LoadInst **)(v15 + 40 * v17);
    int v19 = *v18;
    if (*v18 == (const llvm::LoadInst *)a2) {
      goto LABEL_16;
    }
    BOOL v33 = 0;
    int v34 = 1;
    while (v19 != (const llvm::LoadInst *)-4096)
    {
      if (v33) {
        BOOL v35 = 0;
      }
      else {
        BOOL v35 = v19 == (const llvm::LoadInst *)-8192;
      }
      if (v35) {
        BOOL v33 = v18;
      }
      unsigned int v36 = v17 + v34++;
      unsigned int v17 = v36 & v16;
      std::string::size_type v18 = (const llvm::LoadInst **)(v15 + 40 * v17);
      int v19 = *v18;
      if (*v18 == (const llvm::LoadInst *)a2) {
        goto LABEL_16;
      }
    }
    if (v33) {
      unsigned __int8 v42 = v33;
    }
    else {
      unsigned __int8 v42 = v18;
    }
  }
  else
  {
    unsigned __int8 v42 = 0;
  }
  std::string::size_type v18 = (const llvm::LoadInst **)sub_1CC609054(v13 + 2480, (uint64_t)&v82, (uint64_t *)&v82, v42);
  unsigned int v43 = v82;
  v18[3] = 0;
  v18[4] = 0;
  *std::string::size_type v18 = v43;
  v18[1] = (const llvm::LoadInst *)(v18 + 3);
  v18[2] = (const llvm::LoadInst *)0x100000000;
LABEL_16:
  uint64_t v20 = *((unsigned int *)v18 + 4);
  if (!v20) {
    goto LABEL_21;
  }
  size_t v21 = (void *)((char *)v18[1] + 8);
  uint64_t v22 = 16 * v20;
  while (*((_DWORD *)v21 - 2) != 9)
  {
    BOOL v9 = 0;
    v21 += 2;
    v22 -= 16;
    if (!v22) {
      goto LABEL_22;
    }
  }
  BOOL v9 = *v21 != 0;
LABEL_22:
  int v8 = *((_DWORD *)a2 + 5);
  if (!a2[6])
  {
LABEL_5:
    if ((v8 & 0x20000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_24;
  }
  if ((v8 & 0x20000000) == 0) {
    goto LABEL_6;
  }
LABEL_24:
  uint64_t v23 = ***a2;
  unsigned __int8 v82 = (const llvm::LoadInst *)a2;
  int v24 = *(_DWORD *)(v23 + 2496);
  if (v24)
  {
    uint64_t v25 = *(void *)(v23 + 2480);
    int v26 = v24 - 1;
    unsigned int v27 = v26 & ((a2 >> 4) ^ (a2 >> 9));
    unsigned __int8 v28 = (const llvm::LoadInst **)(v25 + 40 * v27);
    size_t v29 = *v28;
    if (*v28 == (const llvm::LoadInst *)a2) {
      goto LABEL_26;
    }
    std::string v37 = 0;
    int v38 = 1;
    while (v29 != (const llvm::LoadInst *)-4096)
    {
      if (v37) {
        BOOL v39 = 0;
      }
      else {
        BOOL v39 = v29 == (const llvm::LoadInst *)-8192;
      }
      if (v39) {
        std::string v37 = v28;
      }
      unsigned int v40 = v27 + v38++;
      unsigned int v27 = v40 & v26;
      unsigned __int8 v28 = (const llvm::LoadInst **)(v25 + 40 * v27);
      size_t v29 = *v28;
      if (*v28 == (const llvm::LoadInst *)a2) {
        goto LABEL_26;
      }
    }
    if (v37) {
      int v44 = v37;
    }
    else {
      int v44 = v28;
    }
  }
  else
  {
    int v44 = 0;
  }
  unsigned __int8 v28 = (const llvm::LoadInst **)sub_1CC609054(v23 + 2480, (uint64_t)&v82, (uint64_t *)&v82, v44);
  char v45 = v82;
  v28[3] = 0;
  v28[4] = 0;
  *unsigned __int8 v28 = v45;
  v28[1] = (const llvm::LoadInst *)(v28 + 3);
  v28[2] = (const llvm::LoadInst *)0x100000000;
LABEL_26:
  uint64_t v30 = *((unsigned int *)v28 + 4);
  if (!v30)
  {
LABEL_6:
    if (v9) {
      int v10 = 9;
    }
    else {
      int v10 = 1;
    }
    goto LABEL_9;
  }
  std::string v31 = (void *)((char *)v28[1] + 8);
  uint64_t v32 = 16 * v30;
  while (*((_DWORD *)v31 - 2) != 6)
  {
    v31 += 2;
    v32 -= 16;
    if (!v32) {
      goto LABEL_6;
    }
  }
  uint64_t v41 = *v31;
  if (v9) {
    int v10 = 9;
  }
  else {
    int v10 = 1;
  }
  if (v41) {
LABEL_54:
  }
    v10 |= 0x20u;
LABEL_9:
  if (llvm::isDereferenceableAndAlignedPointer((uint64_t)*(a2 - 4), (uint64_t)*a2, 0, (uint64_t)a3, 0, 0, 0))int v11 = v10 | 0x10; {
  else
  }
    int v11 = v10;
  return (*(unsigned int (**)(llvm::TargetLoweringBase *, uint64_t ***))(*(void *)this + 88))(this, a2) | v11;
}

uint64_t llvm::TargetLoweringBase::getStoreMemOperandFlags(llvm::TargetLoweringBase *this, const llvm::StoreInst *a2, const llvm::DataLayout *a3)
{
  LOWORD(v5) = *((_WORD *)a2 + 9);
  int v6 = *((_DWORD *)a2 + 5);
  if ((v5 & 1) == 0)
  {
    if ((v6 & 0x20000000) == 0)
    {
LABEL_3:
      int v7 = 2;
      return (*(unsigned int (**)(llvm::TargetLoweringBase *, const llvm::StoreInst *, const llvm::DataLayout *))(*(void *)this + 88))(this, a2, a3) | v7;
    }
    uint64_t v9 = ***(void ***)a2;
    unsigned int v43 = a2;
    int v10 = *(_DWORD *)(v9 + 2496);
    if (v10)
    {
      uint64_t v11 = *(void *)(v9 + 2480);
      int v12 = v10 - 1;
      unsigned int v13 = v12 & ((a2 >> 4) ^ (a2 >> 9));
      int v14 = (const llvm::StoreInst **)(v11 + 40 * v13);
      uint64_t v15 = *v14;
      if (*v14 == a2)
      {
LABEL_7:
        uint64_t v16 = *((unsigned int *)v14 + 4);
        if (v16)
        {
          unsigned int v17 = (void *)((char *)v14[1] + 8);
          uint64_t v18 = 16 * v16;
          while (*((_DWORD *)v17 - 2) != 9)
          {
            v17 += 2;
            v18 -= 16;
            if (!v18) {
              goto LABEL_3;
            }
          }
          if (*v17)
          {
            int v7 = 10;
            return (*(unsigned int (**)(llvm::TargetLoweringBase *, const llvm::StoreInst *, const llvm::DataLayout *))(*(void *)this + 88))(this, a2, a3) | v7;
          }
        }
        goto LABEL_3;
      }
      int v19 = 0;
      int v20 = 1;
      while (v15 != (const llvm::StoreInst *)-4096)
      {
        if (v19) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v15 == (const llvm::StoreInst *)-8192;
        }
        if (v21) {
          int v19 = v14;
        }
        unsigned int v22 = v13 + v20++;
        unsigned int v13 = v22 & v12;
        int v14 = (const llvm::StoreInst **)(v11 + 40 * v13);
        uint64_t v15 = *v14;
        if (*v14 == a2) {
          goto LABEL_7;
        }
      }
      if (v19) {
        uint64_t v23 = v19;
      }
      else {
        uint64_t v23 = v14;
      }
    }
    else
    {
      uint64_t v23 = 0;
    }
    int v14 = (const llvm::StoreInst **)sub_1CC609054(v9 + 2480, (uint64_t)&v43, (uint64_t *)&v43, v23);
    int v24 = v43;
    v14[3] = 0;
    v14[4] = 0;
    *int v14 = v24;
    v14[1] = (const llvm::StoreInst *)(v14 + 3);
    v14[2] = (const llvm::StoreInst *)0x100000000;
    goto LABEL_7;
  }
  if ((v6 & 0x20000000) == 0) {
    goto LABEL_28;
  }
  uint64_t v25 = ***(void ***)a2;
  unsigned int v43 = a2;
  int v26 = *(_DWORD *)(v25 + 2496);
  if (v26)
  {
    uint64_t v27 = *(void *)(v25 + 2480);
    int v28 = v26 - 1;
    unsigned int v29 = v28 & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v30 = (const llvm::StoreInst **)(v27 + 40 * v29);
    std::string v31 = *v30;
    if (*v30 == a2) {
      goto LABEL_33;
    }
    BOOL v35 = 0;
    int v36 = 1;
    while (v31 != (const llvm::StoreInst *)-4096)
    {
      if (v35) {
        BOOL v37 = 0;
      }
      else {
        BOOL v37 = v31 == (const llvm::StoreInst *)-8192;
      }
      if (v37) {
        BOOL v35 = v30;
      }
      unsigned int v38 = v29 + v36++;
      unsigned int v29 = v38 & v28;
      uint64_t v30 = (const llvm::StoreInst **)(v27 + 40 * v29);
      std::string v31 = *v30;
      if (*v30 == a2) {
        goto LABEL_33;
      }
    }
    char v41 = (char)v5;
    if (v35) {
      unsigned __int8 v42 = v35;
    }
    else {
      unsigned __int8 v42 = v30;
    }
  }
  else
  {
    char v41 = (char)v5;
    unsigned __int8 v42 = 0;
  }
  uint64_t v30 = (const llvm::StoreInst **)sub_1CC609054(v25 + 2480, (uint64_t)&v43, (uint64_t *)&v43, v42);
  int v5 = v43;
  v30[3] = 0;
  v30[4] = 0;
  *uint64_t v30 = v5;
  v30[1] = (const llvm::StoreInst *)(v30 + 3);
  v30[2] = (const llvm::StoreInst *)0x100000000;
  LOBYTE(v5) = v41;
LABEL_33:
  uint64_t v32 = *((unsigned int *)v30 + 4);
  if (!v32)
  {
LABEL_28:
    if (v5) {
      int v7 = 6;
    }
    else {
      int v7 = 2;
    }
    return (*(unsigned int (**)(llvm::TargetLoweringBase *, const llvm::StoreInst *, const llvm::DataLayout *))(*(void *)this + 88))(this, a2, a3) | v7;
  }
  BOOL v33 = (void *)((char *)v30[1] + 8);
  uint64_t v34 = 16 * v32;
  while (*((_DWORD *)v33 - 2) != 9)
  {
    v33 += 2;
    v34 -= 16;
    if (!v34) {
      goto LABEL_28;
    }
  }
  uint64_t v39 = *v33;
  if (v5) {
    int v7 = 6;
  }
  else {
    int v7 = 2;
  }
  if (v5) {
    int v40 = 14;
  }
  else {
    int v40 = 10;
  }
  if (v39) {
    int v7 = v40;
  }
  return (*(unsigned int (**)(llvm::TargetLoweringBase *, const llvm::StoreInst *, const llvm::DataLayout *))(*(void *)this + 88))(this, a2, a3) | v7;
}

uint64_t llvm::TargetLoweringBase::getAtomicMemOperandFlags(uint64_t a1, uint64_t a2)
{
  if (*(_WORD *)(a2 + 18)) {
    int v2 = 7;
  }
  else {
    int v2 = 3;
  }
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 88))(a1) | v2;
}

uint64_t sub_1CC4A2968(unsigned char *a1, size_t __n, void *a3, unsigned char *a4)
{
  if (__n && (int v8 = memchr(a1, 58, __n)) != 0)
  {
    int64_t v9 = v8 - a1;
    *a3 = v8 - a1;
    if (v8 - a1 == -1)
    {
      return 0;
    }
    else
    {
      if (__n >= v9 + 1) {
        size_t v10 = v9 + 1;
      }
      else {
        size_t v10 = __n;
      }
      if (__n - v10 != 1 || (unsigned int v11 = a1[v10] - 48, v11 > 9)) {
        llvm::report_fatal_error((llvm *)"Invalid refinement step for -recip.", (const llvm::Twine *)1);
      }
      *a4 = v11;
      return 1;
    }
  }
  else
  {
    uint64_t result = 0;
    *a3 = -1;
  }
  return result;
}

std::string *sub_1CC4A2A18(std::string *this, int a2, uint64_t a3, uint64_t a4)
{
  v15[0] = a3;
  v15[1] = a4;
  if ((_BYTE)a3)
  {
    unsigned int v7 = a3 - 15;
    *((unsigned char *)&this->__r_.__value_.__s + 23) = 4 * (v7 < 0x9C);
    if (v7 >= 0x9C) {
      goto LABEL_3;
    }
  }
  else
  {
    BOOL v5 = (*(_DWORD *)(a4 + 8) & 0xFE) == 18;
    *((unsigned char *)&this->__r_.__value_.__s + 23) = 4 * v5;
    if (!v5)
    {
LABEL_3:
      uint64_t v6 = 0;
      goto LABEL_6;
    }
  }
  LODWORD(this->__r_.__value_.__l.__data_) = 761488758;
  uint64_t v6 = 4;
LABEL_6:
  this->__r_.__value_.__s.__data_[v6] = 0;
  if (a2) {
    int v8 = "sqrt";
  }
  else {
    int v8 = "div";
  }
  std::string::append(this, v8);
  if (sub_1CD3DD468((unsigned __int8 *)v15, v9, v10) == 11)
  {
    unsigned int v13 = "d";
  }
  else if (sub_1CD3DD468((unsigned __int8 *)v15, v11, v12) == 9)
  {
    unsigned int v13 = "h";
  }
  else
  {
    unsigned int v13 = "f";
  }
  return std::string::append(this, v13);
}

uint64_t sub_1CC4A2B08()
{
  LOBYTE(v1) = 0;
  int v3 = &v1;
  v4.n128_u64[0] = (unint64_t)"Do not create extra branches to split comparison logic.";
  v4.n128_u64[1] = 55;
  int v2 = 1;
  sub_1CD586024((char **)&v3, &v4, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, qword_1EBCD43D8, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 4;
  int v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Set minimum number of entries to use a jump table.";
  v4.n128_u64[1] = 50;
  sub_1CD58619C(&v3, &v1, (long long *)&v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCD4498, &dword_1CB82C000);
  int v1 = 1;
  int v2 = -1;
  int v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Set maximum size of jump tables.";
  v4.n128_u64[1] = 32;
  sub_1CD5862C4(&v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &qword_1EBCD4558, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 10;
  int v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Minimum density for building a jump table in a normal function";
  v4.n128_u64[1] = 62;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCD4618, "jump-table-density", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD4618, &dword_1CB82C000);
  int v1 = 1;
  int v2 = 40;
  int v3 = &v2;
  v4.n128_u64[0] = (unint64_t)"Minimum density for building a jump table in an optsize function";
  v4.n128_u64[1] = 64;
  sub_1CBF7A9F8((uint64_t)&unk_1EBCD46D8, "optsize-jump-table-density", &v3, &v1, &v4);
  __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCD46D8, &dword_1CB82C000);
  v4.n128_u64[0] = (unint64_t)"Don't mutate strict-float node to a legalize node";
  v4.n128_u64[1] = 49;
  LOBYTE(v1) = 0;
  int v3 = &v1;
  int v2 = 1;
  sub_1CD4130FC((llvm::cl::Option *)&unk_1EBCD4798, "disable-strictnode-mutation", &v4, (unsigned char **)&v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB9064B0, &unk_1EBCD4798, &dword_1CB82C000);
}

llvm::TargetLoweringObjectFileELF *llvm::TargetLoweringObjectFileELF::TargetLoweringObjectFileELF(llvm::TargetLoweringObjectFileELF *this)
{
  *((unsigned char *)this + 912) = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  bzero((char *)this + 24, 0x329uLL);
  *((unsigned char *)this + 864) = 0;
  *((void *)this + 107) = 0;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((void *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((unsigned char *)this + 944) = 0;
  *(_WORD *)((char *)this + 945) = 257;
  *(_OWORD *)((char *)this + 948) = 0u;
  *((void *)this + 121) = 0;
  *((_OWORD *)this + 61) = 0u;
  *(void *)this = &unk_1F2614448;
  *((unsigned char *)this + 992) = 0;
  *((_DWORD *)this + 249) = 1;
  *((void *)this + 125) = (char *)this + 1032;
  *((void *)this + 126) = (char *)this + 1032;
  *((void *)this + 127) = 2;
  *((_DWORD *)this + 256) = 0;
  *((_WORD *)this + 524) = 0;
  *((unsigned char *)this + 947) = 1;
  return this;
}

{
  *((unsigned char *)this + 912) = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  bzero((char *)this + 24, 0x329uLL);
  *((unsigned char *)this + 864) = 0;
  *((void *)this + 107) = 0;
  *(_OWORD *)((char *)this + 840) = 0u;
  *((void *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((unsigned char *)this + 944) = 0;
  *(_WORD *)((char *)this + 945) = 257;
  *(_OWORD *)((char *)this + 948) = 0u;
  *((void *)this + 121) = 0;
  *((_OWORD *)this + 61) = 0u;
  *(void *)this = &unk_1F2614448;
  *((unsigned char *)this + 992) = 0;
  *((_DWORD *)this + 249) = 1;
  *((void *)this + 125) = (char *)this + 1032;
  *((void *)this + 126) = (char *)this + 1032;
  *((void *)this + 127) = 2;
  *((_DWORD *)this + 256) = 0;
  *((_WORD *)this + 524) = 0;
  *((unsigned char *)this + 947) = 1;
  return this;
}

void llvm::TargetLoweringObjectFileELF::Initialize(llvm::TargetLoweringObjectFileELF *this, llvm::MCContext *a2, const llvm::TargetMachine *a3)
{
}

uint64_t llvm::TargetLoweringObjectFileELF::InitializeELF(llvm::TargetLoweringObjectFileELF *this, char a2)
{
  *((unsigned char *)this + 992) = a2;
  int v3 = (llvm::MCContext *)*((void *)this + 105);
  if (a2)
  {
    v5[0] = ".init_array";
    __int16 v6 = 259;
    __int16 v8 = 257;
    *((void *)this + 121) = llvm::MCContext::getELFSection(v3, (const llvm::Twine *)v5, 14, 3, 0, (const llvm::Twine *)v7, 0, -1, 0);
    v5[0] = ".fini_array";
    __int16 v6 = 259;
    __int16 v8 = 257;
    uint64_t result = llvm::MCContext::getELFSection(v3, (const llvm::Twine *)v5, 15, 3, 0, (const llvm::Twine *)v7, 0, -1, 0);
  }
  else
  {
    v5[0] = ".ctors";
    __int16 v6 = 259;
    __int16 v8 = 257;
    *((void *)this + 121) = llvm::MCContext::getELFSection(v3, (const llvm::Twine *)v5, 1, 3, 0, (const llvm::Twine *)v7, 0, -1, 0);
    v5[0] = ".dtors";
    __int16 v6 = 259;
    __int16 v8 = 257;
    uint64_t result = llvm::MCContext::getELFSection(v3, (const llvm::Twine *)v5, 1, 3, 0, (const llvm::Twine *)v7, 0, -1, 0);
  }
  *((void *)this + 122) = result;
  return result;
}

void llvm::TargetLoweringObjectFileELF::getModuleMetadata(llvm::TargetLoweringObjectFileELF *this, llvm::Module *a2)
{
  v25[4] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = v25;
  uint64_t v24 = 0x400000000;
  llvm::collectUsedGlobalVariables((uint64_t)a2, (uint64_t)&v23, 0);
  int v3 = (char *)v23;
  if (!v24) {
    goto LABEL_47;
  }
  __n128 v4 = (char *)v23 + 8 * v24;
  do
  {
    uint64_t v5 = *(void *)v3;
    unsigned int v6 = *(unsigned __int8 *)(*(void *)v3 + 16);
    if (v6 > 3 || v6 == 1) {
      goto LABEL_39;
    }
    uint64_t v8 = *((void *)this + 126);
    uint64_t v9 = *((unsigned int *)this + 255);
    if (v8 != *((void *)this + 125))
    {
      unsigned int v13 = *((_DWORD *)this + 254);
      goto LABEL_18;
    }
    if (!v9)
    {
LABEL_15:
      unsigned int v13 = *((_DWORD *)this + 254);
      if (v9 < v13)
      {
        *((_DWORD *)this + 255) = v9 + 1;
        *(void *)(v8 + 8 * v9) = v5;
        goto LABEL_39;
      }
LABEL_18:
      if (3 * v13 <= 4 * ((int)v9 - *((_DWORD *)this + 256)))
      {
        if (v13 >= 0x40) {
          v13 *= 2;
        }
        else {
          unsigned int v13 = 128;
        }
      }
      else if (v13 - v9 >= v13 >> 3)
      {
        goto LABEL_20;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::TargetLoweringObjectFileELF *)((char *)this + 1000), v13);
      unsigned int v13 = *((_DWORD *)this + 254);
      uint64_t v8 = *((void *)this + 126);
LABEL_20:
      unsigned int v14 = v13 - 1;
      unsigned int v15 = (v13 - 1) & ((v5 >> 4) ^ (v5 >> 9));
      uint64_t v16 = (void *)(v8 + 8 * v15);
      uint64_t v17 = *v16;
      if (*v16 == -1)
      {
        uint64_t v18 = 0;
LABEL_32:
        if (v18) {
          unsigned int v22 = v18;
        }
        else {
          unsigned int v22 = v16;
        }
        if (*v22 != v5)
        {
          if (*v22 == -2) {
            --*((_DWORD *)this + 256);
          }
          else {
            ++*((_DWORD *)this + 255);
          }
          *unsigned int v22 = v5;
        }
      }
      else
      {
        uint64_t v18 = 0;
        int v19 = 1;
        while (v17 != v5)
        {
          if (v18) {
            BOOL v20 = 0;
          }
          else {
            BOOL v20 = v17 == -2;
          }
          if (v20) {
            uint64_t v18 = v16;
          }
          unsigned int v21 = v15 + v19++;
          unsigned int v15 = v21 & v14;
          uint64_t v16 = (void *)(v8 + 8 * (v21 & v14));
          uint64_t v17 = *v16;
          if (*v16 == -1) {
            goto LABEL_32;
          }
        }
      }
      goto LABEL_39;
    }
    BOOL v10 = 0;
    uint64_t v11 = 8 * v9;
    BOOL v12 = (void *)*((void *)this + 126);
    while (*v12 != v5)
    {
      if (*v12 == -2) {
        BOOL v10 = v12;
      }
      ++v12;
      v11 -= 8;
      if (!v11)
      {
        if (!v10) {
          goto LABEL_15;
        }
        *BOOL v10 = v5;
        --*((_DWORD *)this + 256);
        break;
      }
    }
LABEL_39:
    v3 += 8;
  }
  while (v3 != v4);
  int v3 = (char *)v23;
LABEL_47:
  if (v3 != (char *)v25) {
    free(v3);
  }
}

void llvm::TargetLoweringObjectFileELF::emitModuleMetadata(llvm::TargetLoweringObjectFileELF *this, llvm::MCStreamer *a2, llvm::Module *a3)
{
  unsigned int v6 = (uint64_t *)*((void *)this + 105);
  v48[0] = (unsigned __int8 **)"llvm.linker.options";
  __int16 v49 = 259;
  uint64_t NamedMetadata = llvm::Module::getNamedMetadata(a3, (const char **)v48);
  if (NamedMetadata)
  {
    uint64_t v28 = NamedMetadata;
    v46[0] = ".linker-options";
    __int16 v47 = 259;
    __int16 v49 = 257;
    ELFSectiouint64_t n = llvm::MCContext::getELFSection((llvm::MCContext *)v6, (const llvm::Twine *)v46, 1879002113, 0x80000000, 0, (const llvm::Twine *)v48, 0, -1, 0);
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, ELFSection, 0);
    uint64_t v30 = *(unsigned int *)(*(void *)(v28 + 48) + 8);
    if (v30)
    {
      for (uint64_t i = 0; i != v30; ++i)
      {
        uint64_t v32 = *(void *)(**(void **)(v28 + 48) + 8 * i);
        if (*(_DWORD *)(v32 + 8) != 2) {
          llvm::report_fatal_error((llvm *)"invalid llvm.linker.options", (const llvm::Twine *)1);
        }
        uint64_t v33 = -16;
        do
        {
          (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 488))(a2, *(void *)(*(void *)(v32 + v33) + 8) + 24, **(void **)(*(void *)(v32 + v33) + 8));
          (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 1);
          v33 += 8;
        }
        while (v33);
      }
    }
  }
  v48[0] = (unsigned __int8 **)"llvm.dependent-libraries";
  __int16 v49 = 259;
  uint64_t v8 = llvm::Module::getNamedMetadata(a3, (const char **)v48);
  if (v8)
  {
    uint64_t v34 = v8;
    v46[0] = ".deplibs";
    __int16 v47 = 259;
    __int16 v49 = 257;
    uint64_t v35 = llvm::MCContext::getELFSection((llvm::MCContext *)v6, (const llvm::Twine *)v46, 1879002116, 48, 1, (const llvm::Twine *)v48, 0, -1, 0);
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, v35, 0);
    uint64_t v36 = *(unsigned int *)(*(void *)(v34 + 48) + 8);
    if (v36)
    {
      uint64_t v37 = 0;
      uint64_t v38 = 8 * v36;
      do
      {
        uint64_t v39 = *(void *)(**(void **)(v34 + 48) + v37);
        int v40 = *(void **)(*(void *)(v39 - 8 * *(unsigned int *)(v39 + 8)) + 8);
        (*(void (**)(llvm::MCStreamer *, void *, void))(*(void *)a2 + 488))(a2, v40 + 3, *v40);
        (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, 0, 1);
        v37 += 8;
      }
      while (v38 != v37);
    }
  }
  v48[0] = (unsigned __int8 **)"llvm.pseudo_probe_desc";
  __int16 v49 = 259;
  uint64_t v9 = llvm::Module::getNamedMetadata(a3, (const char **)v48);
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(unsigned int *)(*(void *)(v9 + 48) + 8);
    if (v11)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 8 * v11;
      do
      {
        uint64_t v14 = *(void *)(**(void **)(v10 + 48) + v12);
        unsigned int v15 = (void *)(v14 - 8 * *(unsigned int *)(v14 + 8));
        if (*(unsigned char *)*v15 == 1)
        {
          if (*(unsigned char *)(*(void *)(*v15 + 128) + 16) == 16) {
            uint64_t v16 = *(void *)(*v15 + 128);
          }
          else {
            uint64_t v16 = 0;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v17 = v15[1];
        if (*(unsigned char *)v17 == 1)
        {
          uint64_t v18 = *(void *)(v17 + 128);
          if (*(unsigned char *)(v18 + 16) == 16) {
            uint64_t v19 = v18;
          }
          else {
            uint64_t v19 = 0;
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        uint64_t v20 = v15[2];
        if ((*(unsigned char *)(*((void *)this + 123) + 1040) & 2) != 0)
        {
          uint64_t v23 = *(uint64_t **)(v20 + 8);
          uint64_t v24 = *v23;
          uint64_t v22 = (uint64_t)(v23 + 3);
          uint64_t v21 = v24;
        }
        else
        {
          uint64_t v21 = 0;
          uint64_t v22 = 0;
        }
        PseudoProbeDescSectiouint64_t n = llvm::MCObjectFileInfo::getPseudoProbeDescSection(v6[21], v22, v21);
        (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, PseudoProbeDescSection, 0);
        int v26 = (void *)(v16 + 24);
        if (*(_DWORD *)(v16 + 32) >= 0x41u) {
          int v26 = (void *)*v26;
        }
        (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, *v26, 8);
        uint64_t v27 = (void *)(v19 + 24);
        if (*(_DWORD *)(v19 + 32) >= 0x41u) {
          uint64_t v27 = (void *)*v27;
        }
        (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, *v27, 8);
        llvm::MCStreamer::emitULEB128IntValue(a2, **(void **)(v20 + 8), 0);
        (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 488))(a2, *(void *)(v20 + 8) + 24, **(void **)(v20 + 8));
        v12 += 8;
      }
      while (v13 != v12);
    }
  }
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v43 = 0;
  sub_1CC4A3C14(a3, (_DWORD *)&v45 + 1, (int *)&v45, &v43);
  if (v44)
  {
    __int16 v47 = 261;
    v46[0] = v43;
    v46[1] = v44;
    __int16 v49 = 257;
    uint64_t v41 = llvm::MCContext::getELFSection((llvm::MCContext *)v6, (const llvm::Twine *)v46, 1, 2, 0, (const llvm::Twine *)v48, 0, -1, 0);
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, v41, 0);
    __int16 v49 = 261;
    v48[0] = (unsigned __int8 **)"OBJC_IMAGE_INFO";
    v48[1] = (unsigned __int8 **)15;
    uint64_t Symbol = llvm::MCContext::getOrCreateSymbol((llvm::MCContext *)v6, v48);
    (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 192))(a2, Symbol, 0);
    (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, HIDWORD(v45), 4);
    (*(void (**)(llvm::MCStreamer *, void, uint64_t))(*(void *)a2 + 520))(a2, v45, 4);
    (*(void (**)(llvm::MCStreamer *))(*(void *)a2 + 152))(a2);
  }
  llvm::TargetLoweringObjectFile::emitCGProfileMetadata(this, a2, a3);
}

void sub_1CC4A3C14(llvm::Module *a1, _DWORD *a2, int *a3, void *a4)
{
  v54[24] = *MEMORY[0x1E4F143B8];
  unsigned int v52 = v54;
  uint64_t v53 = 0x800000000;
  llvm::Module::getModuleFlagsMetadata(a1, (uint64_t)&v52);
  unsigned int v7 = v52;
  if (v53)
  {
    uint64_t v8 = 24 * v53;
    uint64_t v9 = (char *)v52 + 16;
    do
    {
      if (*((_DWORD *)v9 - 4) != 3)
      {
        uint64_t v10 = *(uint64_t **)(*((void *)v9 - 1) + 8);
        uint64_t v13 = *v10;
        uint64_t v11 = v10 + 3;
        uint64_t v12 = v13;
        switch(v13)
        {
          case 17:
            if (*v11 == 0x4241207466697753 && v11[1] == 0x6F69737265562049 && *((unsigned char *)v11 + 16) == 110)
            {
              uint64_t v16 = *(void *)(*(void *)v9 + 128);
              uint64_t v17 = (void *)(v16 + 24);
              if (*(_DWORD *)(v16 + 32) >= 0x41u) {
                uint64_t v17 = (void *)*v17;
              }
              int v18 = *a3 | (*(_DWORD *)v17 << 8);
              goto LABEL_111;
            }
            break;
          case 18:
          case 20:
          case 21:
          case 22:
          case 23:
          case 25:
          case 26:
          case 27:
          case 29:
            break;
          case 19:
            if (*v11 == 0x76697463656A624FLL
              && v11[1] == 0x4F20434720432D65
              && *(void *)((char *)v11 + 11) == 0x796C6E4F20434720)
            {
              goto LABEL_108;
            }
            if (*v11 == 0x614D207466697753
              && v11[1] == 0x7372655620726F6ALL
              && *(void *)((char *)v11 + 11) == 0x6E6F697372655620)
            {
              uint64_t v50 = *(void *)(*(void *)v9 + 128);
              int v51 = (void *)(v50 + 24);
              if (*(_DWORD *)(v50 + 32) >= 0x41u) {
                int v51 = (void *)*v51;
              }
              int v18 = *a3 | (*(_DWORD *)v51 << 24);
              goto LABEL_111;
            }
            if (*v11 == 0x694D207466697753
              && v11[1] == 0x7372655620726F6ELL
              && *(void *)((char *)v11 + 11) == 0x6E6F697372655620)
            {
              uint64_t v25 = *(void *)(*(void *)v9 + 128);
              int v26 = (void *)(v25 + 24);
              if (*(_DWORD *)(v25 + 32) >= 0x41u) {
                int v26 = (void *)*v26;
              }
              int v18 = *a3 | (*(_DWORD *)v26 << 16);
              goto LABEL_111;
            }
            break;
          case 24:
            if (*v11 == 0x76697463656A624FLL && v11[1] == 0x5320734920432D65 && v11[2] == 0x646574616C756D69) {
              goto LABEL_108;
            }
            break;
          case 28:
            if (*v11 == 0x76697463656A624FLL
              && v11[1] == 0x73616C4320432D65
              && v11[2] == 0x7265706F72502073
              && *((_DWORD *)v11 + 6) == 1936025972)
            {
              goto LABEL_108;
            }
            break;
          case 30:
            if (*v11 == 0x76697463656A624FLL
              && v11[1] == 0x67616D4920432D65
              && v11[2] == 0x56206F666E492065
              && *(void *)((char *)v11 + 22) == 0x6E6F697372655620)
            {
              uint64_t v48 = *(void *)(*(void *)v9 + 128);
              __int16 v49 = (void *)(v48 + 24);
              if (*(_DWORD *)(v48 + 32) >= 0x41u) {
                __int16 v49 = (void *)*v49;
              }
              *a2 = *v49;
            }
            else
            {
              if (*v11 == 0x76697463656A624FLL
                && v11[1] == 0x6272614720432D65
                && v11[2] == 0x6C6C6F4320656761
                && *(void *)((char *)v11 + 22) == 0x6E6F697463656C6CLL)
              {
                goto LABEL_108;
              }
              if (*v11 == 0x76697463656A624FLL
                && v11[1] == 0x67616D4920432D65
                && v11[2] == 0x53206F666E492065
                && *(void *)((char *)v11 + 22) == 0x6E6F697463655320)
              {
                uint64_t v41 = *(uint64_t **)(*(void *)v9 + 8);
                uint64_t v42 = *v41;
                *a4 = v41 + 3;
                a4[1] = v42;
              }
            }
            break;
          case 31:
            if (*v11 == 0x76697463656A624FLL
              && v11[1] == 0x67616D4920432D65
              && v11[2] == 0x2074666977532065
              && *(void *)((char *)v11 + 23) == 0x6E6F697372655620)
            {
              goto LABEL_108;
            }
            break;
          default:
            if (v12 == 43 && !memcmp(v11, "Objective-C Enforce ClassRO Pointer Signing", 0x2BuLL))
            {
LABEL_108:
              uint64_t v46 = *(void *)(*(void *)v9 + 128);
              __int16 v47 = (void *)(v46 + 24);
              if (*(_DWORD *)(v46 + 32) >= 0x41u) {
                __int16 v47 = (void *)*v47;
              }
              int v18 = *a3 | *(_DWORD *)v47;
LABEL_111:
              *a3 = v18;
            }
            break;
        }
      }
      v9 += 24;
      v8 -= 24;
    }
    while (v8);
  }
  if (v7 != v54) {
    free(v7);
  }
}

uint64_t llvm::TargetLoweringObjectFileELF::getCFIPersonalitySymbol(llvm::TargetLoweringObjectFileELF *this, const llvm::GlobalValue *a2, const llvm::TargetMachine *a3, llvm::MachineModuleInfo *a4)
{
  int v4 = *((_DWORD *)this + 237);
  if ((v4 & 0x80) != 0)
  {
    unsigned int v6 = (llvm::MCContext *)*((void *)this + 105);
    uint64_t Symbol = (unsigned char *)llvm::TargetMachine::getSymbol(a3, a2);
    if ((*Symbol & 4) != 0)
    {
      uint64_t v10 = (void *)*((void *)Symbol - 1);
      uint64_t v11 = (unsigned __int8 **)*v10;
      uint64_t v8 = (unsigned __int8 **)(v10 + 2);
      uint64_t v9 = v11;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
    }
    v12[0] = (unsigned __int8 **)"DW.ref.";
    v12[1] = (unsigned __int8 **)7;
    void v12[2] = v8;
    v12[3] = v9;
    __int16 v13 = 1285;
    return llvm::MCContext::getOrCreateSymbol(v6, v12);
  }
  else
  {
    if ((v4 & 0x70) != 0) {
      llvm::report_fatal_error((llvm *)"We do not support this DWARF encoding yet!", (const llvm::Twine *)1);
    }
    return llvm::TargetMachine::getSymbol(a3, a2);
  }
}

void llvm::TargetLoweringObjectFileELF::emitPersonalityValue(llvm::TargetLoweringObjectFileELF *this, llvm::MCStreamer *a2, const llvm::DataLayout *a3, const llvm::MCSymbol *a4)
{
  *(void *)&v36[57] = *MEMORY[0x1E4F143B8];
  uint64_t v33 = v35;
  qmemcpy(v35, "DW.ref.", sizeof(v35));
  long long v34 = xmmword_1CFAC79D0;
  if ((*(unsigned char *)a4 & 4) != 0)
  {
    uint64_t v8 = (size_t *)*((void *)a4 - 1);
    size_t v11 = *v8;
    uint64_t v10 = v8 + 2;
    size_t v9 = v11;
    if (v11 + 7 >= 0x41) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    uint64_t v12 = 7;
    if (v9)
    {
      memcpy(v36, v10, v9);
      __int16 v13 = (unsigned __int8 **)v33;
      uint64_t v12 = v34;
      goto LABEL_5;
    }
  }
  else
  {
    size_t v9 = 0;
    uint64_t v12 = 7;
  }
  __int16 v13 = (unsigned __int8 **)v35;
LABEL_5:
  *(void *)&long long v34 = v12 + v9;
  uint64_t v14 = (llvm::MCContext *)*((void *)this + 105);
  __int16 v32 = 261;
  v31[0] = v13;
  v31[1] = (unsigned __int8 **)(v12 + v9);
  uint64_t Symbol = (unsigned char *)llvm::MCContext::getOrCreateSymbol(v14, v31);
  (*(void (**)(llvm::MCStreamer *, unsigned char *, uint64_t))(*(void *)a2 + 304))(a2, Symbol, 12);
  (*(void (**)(llvm::MCStreamer *, unsigned char *, uint64_t))(*(void *)a2 + 304))(a2, Symbol, 23);
  uint64_t v16 = (llvm::MCContext *)*((void *)this + 105);
  v31[0] = (unsigned __int8 **)".data";
  __int16 v32 = 259;
  if ((*Symbol & 4) != 0)
  {
    uint64_t v19 = (uint64_t *)*((void *)Symbol - 1);
    uint64_t v20 = *v19;
    uint64_t v17 = v19 + 2;
    uint64_t v18 = v20;
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
  }
  __int16 v30 = 261;
  v29[0] = v17;
  v29[1] = v18;
  ELFNamedSectiouint64_t n = llvm::MCContext::getELFNamedSection(v16, (const llvm::Twine *)v31, (const llvm::Twine *)v29, 1, 515, 0);
  unint64_t v22 = ((unint64_t)*(unsigned int *)(*((void *)a3 + 29) + 4) + 7) >> 3;
  (*(void (**)(llvm::MCStreamer *, uint64_t, void))(*(void *)a2 + 168))(a2, ELFNamedSection, 0);
  (*(void (**)(llvm::MCStreamer *, uint64_t, void, uint64_t, void))(*(void *)a2 + 640))(a2, 1 << **((unsigned char **)a3 + 29), 0, 1, 0);
  (*(void (**)(llvm::MCStreamer *, unsigned char *, uint64_t))(*(void *)a2 + 304))(a2, Symbol, 4);
  uint64_t v23 = *((void *)this + 105);
  *(void *)(v23 + 272) += 24;
  uint64_t v24 = *(void *)(v23 + 192);
  if (((v24 + 7) & 0xFFFFFFFFFFFFFFF8) - v24 + 24 > *(void *)(v23 + 200) - v24)
  {
    unsigned int v26 = *(_DWORD *)(v23 + 216) >> 7;
    if (v26 >= 0x1E) {
      LOBYTE(v26) = 30;
    }
    uint64_t v27 = 4096 << v26;
    unint64_t v25 = (unint64_t)operator new(4096 << v26, (std::align_val_t)8uLL);
    unsigned int v28 = *(_DWORD *)(v23 + 216);
    if (v28 >= *(_DWORD *)(v23 + 220)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(v23 + 208) + 8 * v28) = v25;
    ++*(_DWORD *)(v23 + 216);
    *(void *)(v23 + 200) = v25 + v27;
  }
  else
  {
    unint64_t v25 = (v24 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)(v23 + 192) = v25 + 24;
  *(unsigned char *)unint64_t v25 = 1;
  *(_DWORD *)(v25 + 1) = *(unsigned __int8 *)(v25 + 4) << 24;
  *(void *)(v25 + 8) = 0;
  *(void *)(v25 + 16) = v22;
  (*(void (**)(llvm::MCStreamer *, unsigned char *, unint64_t))(*(void *)a2 + 424))(a2, Symbol, v25);
  (*(void (**)(llvm::MCStreamer *, unsigned char *, void))(*(void *)a2 + 192))(a2, Symbol, 0);
  llvm::MCStreamer::emitSymbolValue(a2, a4, v22, 0);
  if (v33 != v35) {
    free(v33);
  }
}

unint64_t llvm::TargetLoweringObjectFileELF::getTTypeGlobalReference(llvm::TargetLoweringObjectFileELF *this, const llvm::GlobalValue *a2, char a3, const llvm::TargetMachine *a4, llvm::MachineModuleInfo *a5, llvm::MCStreamer *a6)
{
  if (a3 < 0)
  {
    uint64_t v12 = *((void *)a5 + 259);
    if (!v12) {
      operator new();
    }
    uint64_t SymbolWithGlobalValueBase = llvm::TargetLoweringObjectFile::getSymbolWithGlobalValueBase((uint64_t)this, a2, ".DW.stub", 8, (uint64_t)a4);
    uint64_t v22 = SymbolWithGlobalValueBase;
    uint64_t v14 = sub_1CD45F378(v12 + 8, &v22);
    if (v14[1] <= 7uLL) {
      v14[1] = llvm::TargetMachine::getSymbol(a4, a2) & 0xFFFFFFFFFFFFFFFBLL | (4
    }
                                                                              * ((*((_DWORD *)a2 + 8) & 0xFu) - 9 < 0xFFFFFFFE));
    uint64_t v15 = *((void *)this + 105);
    *(void *)(v15 + 272) += 24;
    uint64_t v16 = *(void *)(v15 + 192);
    if (((v16 + 7) & 0xFFFFFFFFFFFFFFF8) - v16 + 24 > *(void *)(v15 + 200) - v16)
    {
      unsigned int v19 = *(_DWORD *)(v15 + 216) >> 7;
      if (v19 >= 0x1E) {
        LOBYTE(v19) = 30;
      }
      uint64_t v20 = 4096 << v19;
      uint64_t v17 = (uint64_t)operator new(4096 << v19, (std::align_val_t)8uLL);
      unsigned int v21 = *(_DWORD *)(v15 + 216);
      if (v21 >= *(_DWORD *)(v15 + 220)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v15 + 208) + 8 * v21) = v17;
      ++*(_DWORD *)(v15 + 216);
      *(void *)(v15 + 200) = v17 + v20;
    }
    else
    {
      uint64_t v17 = (v16 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    *(void *)(v15 + 192) = v17 + 24;
    int v18 = *(unsigned __int8 *)(*(void *)(v15 + 152) + 18) << 16;
    *(unsigned char *)uint64_t v17 = 2;
    *(_DWORD *)(v17 + 1) = v18 | (*(unsigned __int8 *)(v17 + 4) << 24);
    *(void *)(v17 + 8) = 0;
    *(void *)(v17 + 16) = SymbolWithGlobalValueBase;
    return llvm::TargetLoweringObjectFile::getTTypeReference((uint64_t)this, v17, a3 & 0x7F, (uint64_t)a6);
  }
  else
  {
    return llvm::TargetLoweringObjectFile::getTTypeGlobalReference(this, a2, a3, a4, a5, a6);
  }
}

uint64_t llvm::TargetLoweringObjectFileELF::getExplicitSectionGlobal(uint64_t a1, uint64_t **a2, unsigned __int8 a3, llvm::TargetMachine *a4)
{
  uint64_t v5 = *(void *)(a1 + 1008);
  uint64_t v6 = *(void *)(a1 + 1000);
  if (v5 == v6)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 1020);
    uint64_t v8 = (uint64_t ***)(v5 + 8 * v7);
    if (v7)
    {
      uint64_t v9 = 0;
      uint64_t v10 = 8 * v7;
      while (*(uint64_t ***)(v5 + v9) != a2)
      {
        v9 += 8;
        if (v10 == v9) {
          goto LABEL_19;
        }
      }
      uint64_t v8 = (uint64_t ***)(v5 + v9);
    }
LABEL_19:
    uint64_t v6 = *(void *)(a1 + 1008);
  }
  else
  {
    uint64_t v11 = *(unsigned int *)(a1 + 1016);
    int v12 = v11 - 1;
    unsigned int v13 = (v11 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    uint64_t v8 = (uint64_t ***)(v5 + 8 * v13);
    uint64_t v14 = *v8;
    if (*v8 == (uint64_t **)-1)
    {
      uint64_t v15 = 0;
LABEL_24:
      if (v15) {
        uint64_t v8 = v15;
      }
      if (*v8 != a2) {
        uint64_t v8 = (uint64_t ***)(v5 + 8 * v11);
      }
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      while (v14 != a2)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v14 == (uint64_t **)-2;
        }
        if (v17) {
          uint64_t v15 = v8;
        }
        unsigned int v18 = v13 + v16++;
        unsigned int v13 = v18 & v12;
        uint64_t v8 = (uint64_t ***)(v5 + 8 * (v18 & v12));
        uint64_t v14 = *v8;
        if (*v8 == (uint64_t **)-1) {
          goto LABEL_24;
        }
      }
    }
  }
  BOOL v17 = v5 == v6;
  uint64_t v19 = 1016;
  if (v17) {
    uint64_t v19 = 1020;
  }
  return sub_1CC4A4A00(a2, a3, a4, *(llvm::MCContext **)(a1 + 840), *(llvm::Mangler **)(a1 + 936), (int *)(a1 + 996), v8 != (uint64_t ***)(v5 + 8 * *(unsigned int *)(a1 + v19)), 0);
}

uint64_t sub_1CC4A4A00(uint64_t **a1, unsigned __int8 a2, llvm::TargetMachine *a3, llvm::MCContext *a4, llvm::Mangler *a5, int *a6, int a7, int a8)
{
  uint64_t v201 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)a1 + 34) & 0x40) == 0)
  {
    int v12 = 0;
    std::string::size_type v13 = 0;
    goto LABEL_6;
  }
  uint64_t v14 = *(void *)**a1;
  v198.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
  int v15 = *(_DWORD *)(v14 + 2520);
  if (!v15)
  {
    unsigned int v54 = 0;
LABEL_69:
    uint64_t v19 = (uint64_t ***)sub_1CC5BF31C(v14 + 2504, (uint64_t)&v198, (uint64_t *)&v198, v54);
    std::string::size_type v55 = v198.__r_.__value_.__r.__words[0];
    v19[1] = 0;
    v19[2] = 0;
    *uint64_t v19 = (uint64_t **)v55;
    goto LABEL_5;
  }
  uint64_t v16 = *(void *)(v14 + 2504);
  int v17 = v15 - 1;
  unsigned int v18 = v17 & ((a1 >> 4) ^ (a1 >> 9));
  uint64_t v19 = (uint64_t ***)(v16 + 24 * v18);
  uint64_t v20 = *v19;
  if (*v19 != a1)
  {
    uint64_t v50 = 0;
    int v51 = 1;
    while (v20 != (uint64_t **)-4096)
    {
      if (v50) {
        BOOL v52 = 0;
      }
      else {
        BOOL v52 = v20 == (uint64_t **)-8192;
      }
      if (v52) {
        uint64_t v50 = v19;
      }
      unsigned int v53 = v18 + v51++;
      unsigned int v18 = v53 & v17;
      uint64_t v19 = (uint64_t ***)(v16 + 24 * v18);
      uint64_t v20 = *v19;
      if (*v19 == a1) {
        goto LABEL_5;
      }
    }
    if (v50) {
      unsigned int v54 = v50;
    }
    else {
      unsigned int v54 = v19;
    }
    goto LABEL_69;
  }
LABEL_5:
  int v12 = v19[1];
  std::string::size_type v13 = (std::string::size_type)v19[2];
LABEL_6:
  int v21 = *((unsigned __int8 *)a1 + 16);
  if (v21 != 3) {
    goto LABEL_10;
  }
  if (sub_1CC2AD970((uint64_t)a1))
  {
    uint64_t v22 = (uint64_t)a1[9];
    v190[0] = v22;
    if (v22)
    {
      v198.__r_.__value_.__r.__words[0] = (std::string::size_type)"bss-section";
      v198.__r_.__value_.__l.__size_ = 11;
      long long v156 = (uint64_t *)(v22 + 24);
      v196.__r_.__value_.__r.__words[0] = 0;
      if (sub_1CC5122C8((uint64_t *)(v22 + 24), (uint64_t)&v198, &v196) && a2 - 15 <= 2)
      {
        long long v157 = "bss-section";
        uint64_t v158 = 11;
      }
      else
      {
        v198.__r_.__value_.__r.__words[0] = (std::string::size_type)"rodata-section";
        v198.__r_.__value_.__l.__size_ = 14;
        v196.__r_.__value_.__r.__words[0] = 0;
        if (sub_1CC5122C8(v156, (uint64_t)&v198, &v196) && ((a2 & 0xFC) == 8 || (a2 & 0xFC) == 4))
        {
          long long v157 = "rodata-section";
          uint64_t v158 = 14;
        }
        else
        {
          v198.__r_.__value_.__r.__words[0] = (std::string::size_type)"relro-section";
          v198.__r_.__value_.__l.__size_ = 13;
          v196.__r_.__value_.__r.__words[0] = 0;
          if (sub_1CC5122C8(v156, (uint64_t)&v198, &v196) && a2 == 20)
          {
            long long v157 = "relro-section";
            uint64_t v158 = 13;
          }
          else
          {
            v198.__r_.__value_.__r.__words[0] = (std::string::size_type)"data-section";
            v198.__r_.__value_.__l.__size_ = 12;
            v196.__r_.__value_.__r.__words[0] = 0;
            if (!sub_1CC5122C8(v156, (uint64_t)&v198, &v196) || a2 != 19) {
              goto LABEL_9;
            }
            long long v157 = "data-section";
            uint64_t v158 = 12;
          }
        }
      }
      uint64_t Attribute = llvm::AttributeSet::getAttribute(v190, (uint64_t)v157, v158);
      if (Attribute)
      {
        std::string::size_type v13 = *(unsigned int *)(Attribute + 16);
        int v12 = (uint64_t **)(Attribute + *(unsigned int *)(Attribute + 12) + 25);
      }
      else
      {
        int v12 = 0;
        std::string::size_type v13 = 0;
      }
    }
  }
LABEL_9:
  int v21 = *((unsigned __int8 *)a1 + 16);
LABEL_10:
  if (v21) {
    goto LABEL_71;
  }
  uint64_t v23 = a1[14];
  if (!v23) {
    goto LABEL_71;
  }
  if (!*((_DWORD *)v23 + 2)) {
    goto LABEL_71;
  }
  uint64_t v24 = v23[5];
  if (!v24) {
    goto LABEL_71;
  }
  int v25 = *(_DWORD *)(v24 + 40);
  if (!v25) {
    goto LABEL_71;
  }
  uint64_t v26 = *(void *)(v24 + 24);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCBE588))
  {
    unint64_t v166 = llvm::hashing::detail::fixed_seed_override;
    if (!llvm::hashing::detail::fixed_seed_override) {
      unint64_t v166 = 0xFF51AFD7ED558CCDLL;
    }
    qword_1EBCBE580 = v166;
    __cxa_guard_release(&qword_1EBCBE588);
  }
  uint64_t v27 = __ROR8__(qword_1EBCBE580 ^ 0xF54B982192FEA167, 30);
  unint64_t v28 = 0x9DDFEA08EB382D69
      * ((qword_1EBCBE580 + 0x18EB4DAABB32FA18) ^ ((0x9DDFEA08EB382D69
                                                    * ((v27 - 0x1A1B69534B932F1) ^ (qword_1EBCBE580
                                                                                    + 0x18EB4DAABB32FA18))) >> 47) ^ (0x9DDFEA08EB382D69 * ((v27 - 0x1A1B69534B932F1) ^ (qword_1EBCBE580 + 0x18EB4DAABB32FA18))));
  unsigned int v29 = -348639895 * ((v28 >> 47) ^ v28);
  for (int i = 1; ; ++i)
  {
    unsigned int v31 = v29 & (v25 - 1);
    uint64_t v32 = v26 + 24 * v31;
    uint64_t v33 = *(void **)v32;
    if (*(void *)v32 == -1)
    {
      if ("implicit-section-name" == (char *)-1) {
        goto LABEL_33;
      }
      goto LABEL_19;
    }
    if (v33 != (void *)-2) {
      break;
    }
    if ("implicit-section-name" == (char *)-2) {
      goto LABEL_33;
    }
LABEL_19:
    if (v33 == (void *)-1) {
      goto LABEL_71;
    }
    unsigned int v29 = i + v31;
  }
  if (*(void *)(v32 + 8) != 21) {
    goto LABEL_19;
  }
  BOOL v34 = *v33 == 0x746963696C706D69 && v33[1] == 0x6E6F69746365732DLL;
  if (!v34 || *(void *)((char *)v33 + 13) != 0x656D616E2D6E6F69) {
    goto LABEL_19;
  }
LABEL_33:
  uint64_t v36 = a1[14];
  if (!v36) {
    goto LABEL_70;
  }
  if (!*((_DWORD *)v36 + 2)) {
    goto LABEL_70;
  }
  uint64_t v37 = v36[5];
  if (!v37) {
    goto LABEL_70;
  }
  int v38 = *(_DWORD *)(v37 + 40);
  if (!v38) {
    goto LABEL_70;
  }
  uint64_t v39 = *(void *)(v37 + 24);
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCBE588))
  {
    unint64_t v167 = llvm::hashing::detail::fixed_seed_override;
    if (!llvm::hashing::detail::fixed_seed_override) {
      unint64_t v167 = 0xFF51AFD7ED558CCDLL;
    }
    qword_1EBCBE580 = v167;
    __cxa_guard_release(&qword_1EBCBE588);
  }
  uint64_t v40 = __ROR8__(qword_1EBCBE580 ^ 0xF54B982192FEA167, 30);
  unint64_t v41 = 0x9DDFEA08EB382D69
      * ((qword_1EBCBE580 + 0x18EB4DAABB32FA18) ^ ((0x9DDFEA08EB382D69
                                                    * ((v40 - 0x1A1B69534B932F1) ^ (qword_1EBCBE580
                                                                                    + 0x18EB4DAABB32FA18))) >> 47) ^ (0x9DDFEA08EB382D69 * ((v40 - 0x1A1B69534B932F1) ^ (qword_1EBCBE580 + 0x18EB4DAABB32FA18))));
  unsigned int v42 = -348639895 * ((v41 >> 47) ^ v41);
  int v43 = 1;
  while (2)
  {
    unsigned int v44 = v42 & (v38 - 1);
    uint64_t v45 = v39 + 24 * v44;
    uint64_t v46 = *(void **)v45;
    if (*(void *)v45 == -1)
    {
      if ("implicit-section-name" == (char *)-1) {
        break;
      }
      goto LABEL_41;
    }
    if (v46 == (void *)-2)
    {
      if ("implicit-section-name" == (char *)-2) {
        break;
      }
      goto LABEL_41;
    }
    if (*(void *)(v45 + 8) != 21
      || (*v46 == 0x746963696C706D69 ? (BOOL v47 = v46[1] == 0x6E6F69746365732DLL) : (BOOL v47 = 0),
          v47 ? (BOOL v48 = *(void *)((char *)v46 + 13) == 0x656D616E2D6E6F69) : (BOOL v48 = 0),
          !v48))
    {
LABEL_41:
      if (v46 == (void *)-1) {
        goto LABEL_70;
      }
      unsigned int v42 = v43 + v44;
      ++v43;
      continue;
    }
    break;
  }
  uint64_t v49 = *(void *)(v45 + 16);
  if (v49)
  {
    std::string::size_type v13 = *(unsigned int *)(v49 + 16);
    int v12 = (uint64_t **)(v49 + *(unsigned int *)(v49 + 12) + 25);
    goto LABEL_71;
  }
LABEL_70:
  int v12 = 0;
  std::string::size_type v13 = 0;
LABEL_71:
  memset(&v198, 0, sizeof(v198));
  std::string::append(&v198, "__llvm_covmap");
  char v56 = HIBYTE(v198.__r_.__value_.__r.__words[2]);
  if ((v198.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v57 = &v198;
  }
  else {
    uint64_t v57 = (std::string *)v198.__r_.__value_.__r.__words[0];
  }
  std::string::size_type size = *((unsigned char *)&v198.__r_.__value_.__s + 23) & 0x7F;
  if ((v198.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v198.__r_.__value_.__l.__size_;
  }
  if (v13 != size || v13 && memcmp(v12, v57, v13))
  {
    memset(&v196, 0, sizeof(v196));
    std::string::append(&v196, "__llvm_covfun");
    int v60 = SHIBYTE(v196.__r_.__value_.__r.__words[2]);
    unsigned int v61 = (void *)v196.__r_.__value_.__r.__words[0];
    if ((v196.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v62 = &v196;
    }
    else {
      uint64_t v62 = (std::string *)v196.__r_.__value_.__r.__words[0];
    }
    std::string::size_type v63 = *((unsigned char *)&v196.__r_.__value_.__s + 23) & 0x7F;
    if ((v196.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v63 = v196.__r_.__value_.__l.__size_;
    }
    if (v13 == v63 && (!v13 || !memcmp(v12, v62, v13)))
    {
      char v59 = 1;
      if ((v60 & 0x80000000) == 0) {
        goto LABEL_102;
      }
LABEL_101:
      operator delete(v61);
      goto LABEL_102;
    }
    if (v13 == 8)
    {
      BOOL v64 = *v12 == (uint64_t *)0x646D636D766C6C2ELL;
    }
    else
    {
      if (v13 != 7)
      {
        char v59 = 0;
        if (v60 < 0) {
          goto LABEL_101;
        }
LABEL_102:
        if ((*((unsigned char *)&v198.__r_.__value_.__s + 23) & 0x80) == 0) {
          goto LABEL_104;
        }
        goto LABEL_103;
      }
      BOOL v64 = *(_DWORD *)v12 == 1986817070 && *(_DWORD *)((char *)v12 + 3) == 1667394934;
    }
    char v59 = v64;
    if (v60 < 0) {
      goto LABEL_101;
    }
    goto LABEL_102;
  }
  char v59 = 1;
  if (v56 < 0) {
LABEL_103:
  }
    operator delete(v198.__r_.__value_.__l.__data_);
LABEL_104:
  uint64_t v172 = (uint64_t)v12;
  if (v59)
  {
    a2 = 0;
    goto LABEL_106;
  }
  if (v13 < 0x10)
  {
    if (v13) {
      goto LABEL_172;
    }
    goto LABEL_106;
  }
  if (*v12 == (uint64_t *)0x666F2E6D766C6C2ELL && v12[1] == (uint64_t *)0x676E6964616F6C66)
  {
    a2 = 1;
    goto LABEL_106;
  }
LABEL_172:
  if (*(unsigned char *)v12 == 46)
  {
    if (v13 == 4)
    {
      if (*(_DWORD *)v12 != 1936941614) {
        goto LABEL_106;
      }
      goto LABEL_199;
    }
    if (v13 < 5) {
      goto LABEL_106;
    }
    if (*(_DWORD *)v12 == 1936941614 && *((unsigned char *)v12 + 4) == 46) {
      goto LABEL_199;
    }
    if (v13 >= 0x10)
    {
      if (*v12 == (uint64_t *)0x6E696C2E756E672ELL && v12[1] == (uint64_t *)0x2E622E65636E6F6BLL) {
        goto LABEL_199;
      }
      if (v13 < 0x11)
      {
        if (*(_DWORD *)v12 == 1935831854 && *((_WORD *)v12 + 2) == 11891) {
          goto LABEL_199;
        }
        goto LABEL_312;
      }
      if (*v12 == (uint64_t *)0x696C2E6D766C6C2ELL
        && v12[1] == (uint64_t *)0x622E65636E6F6B6ELL
        && *((unsigned char *)v12 + 16) == 46)
      {
        goto LABEL_199;
      }
      if (*(_DWORD *)v12 == 1935831854 && *((_WORD *)v12 + 2) == 11891) {
        goto LABEL_199;
      }
      BOOL v145 = *v12 == (uint64_t *)0x6E696C2E756E672ELL && v12[1] == (uint64_t *)0x62732E65636E6F6BLL;
      if (v145 && *((unsigned char *)v12 + 16) == 46) {
        goto LABEL_199;
      }
      if (v13 >= 0x12)
      {
        BOOL v147 = *v12 == (uint64_t *)0x696C2E6D766C6C2ELL && v12[1] == (uint64_t *)0x732E65636E6F6B6ELL;
        if (v147 && *((_WORD *)v12 + 8) == 11874) {
          goto LABEL_199;
        }
      }
      if (*(_DWORD *)v12 != 1633973294 || *(_DWORD *)((char *)v12 + 3) != 778138721)
      {
        BOOL v150 = *v12 == (uint64_t *)0x6E696C2E756E672ELL && v12[1] == (uint64_t *)0x64742E65636E6F6BLL;
        if (!v150 || *((unsigned char *)v12 + 16) != 46)
        {
          if (v13 >= 0x12)
          {
            if (*v12 == (uint64_t *)0x696C2E6D766C6C2ELL
              && v12[1] == (uint64_t *)0x742E65636E6F6B6ELL
              && *((_WORD *)v12 + 8) == 11876)
            {
              a2 = 13;
              goto LABEL_106;
            }
            char v152 = 0;
            char v153 = 0;
          }
          else
          {
            char v152 = 0;
            char v153 = 1;
          }
LABEL_320:
          if (*(_DWORD *)v12 != 1935832110 || *((_WORD *)v12 + 2) != 11891)
          {
            if ((v152 & 1) != 0
              || (*v12 == (uint64_t *)0x6E696C2E756E672ELL
                ? (BOOL v159 = v12[1] == (uint64_t *)0x62742E65636E6F6BLL)
                : (BOOL v159 = 0),
                  v159 ? (BOOL v160 = *((unsigned char *)v12 + 16) == 46) : (BOOL v160 = 0),
                  !v160))
            {
              if (v153) {
                goto LABEL_106;
              }
              BOOL v161 = *v12 == (uint64_t *)0x696C2E6D766C6C2ELL && v12[1] == (uint64_t *)0x742E65636E6F6B6ELL;
              if (!v161 || *((_WORD *)v12 + 8) != 11874) {
                goto LABEL_106;
              }
            }
          }
LABEL_325:
          a2 = 12;
          goto LABEL_106;
        }
      }
    }
    else
    {
      if (v13 == 5)
      {
        if (*(_DWORD *)v12 != 1935831854 || *((unsigned char *)v12 + 4) != 115)
        {
          if (*(_DWORD *)v12 != 1935832110 || *((unsigned char *)v12 + 4) != 115) {
            goto LABEL_106;
          }
          goto LABEL_325;
        }
LABEL_199:
        a2 = 15;
        goto LABEL_106;
      }
      if (*(_DWORD *)v12 == 1935831854 && *((_WORD *)v12 + 2) == 11891) {
        goto LABEL_199;
      }
      if (v13 == 6)
      {
        int v137 = *((unsigned __int16 *)v12 + 2);
        BOOL v138 = *(_DWORD *)v12 == 1633973294;
        int v139 = 24948;
        goto LABEL_313;
      }
LABEL_312:
      int v137 = *(_DWORD *)((char *)v12 + 3);
      BOOL v138 = *(_DWORD *)v12 == 1633973294;
      int v139 = 778138721;
LABEL_313:
      if (!v138 || v137 != v139)
      {
        char v152 = 1;
        char v153 = 1;
        goto LABEL_320;
      }
    }
    a2 = 13;
  }
LABEL_106:
  unsigned __int8 v65 = a2;
  int v66 = 2 * (a2 > 1u);
  if (a2 == 1) {
    int v66 = 0x80000000;
  }
  if ((a2 & 0xFE) == 2) {
    v66 |= 4u;
  }
  if (a2 == 3) {
    int v67 = v66 | 0x20000000;
  }
  else {
    int v67 = v66;
  }
  unsigned int v68 = (a2 - 12);
  int v69 = v67 | (v68 < 9);
  if (v68 < 3) {
    v69 |= 0x400u;
  }
  unsigned int v70 = (a2 - 5);
  if ((a2 & 0xFC) == 8 || v70 < 3) {
    v69 |= 0x10u;
  }
  if (v70 >= 3) {
    int v72 = v69;
  }
  else {
    int v72 = v69 | 0x20;
  }
  if (v13 == 24)
  {
    unint64_t v73 = 0x2E7377696674315FLL;
    unint64_t v74 = bswap64((unint64_t)*v12);
    if (v74 == 0x2E7377696674315FLL
      && (unint64_t v73 = 0x6175746F6C696E6BLL, v74 = bswap64((unint64_t)v12[1]), v74 == 0x6175746F6C696E6BLL)
      && (unint64_t v73 = 0x5F656E7472696573, v74 = bswap64((unint64_t)v12[2]), v74 == 0x5F656E7472696573))
    {
      int v75 = 0;
    }
    else
    {
      int v75 = v74 < v73 ? -1 : 1;
    }
    if (!v75) {
      v72 |= 0x80000000;
    }
  }
  int v76 = sub_1CC4A681C((llvm::GlobalAlias *)a1);
  if (v76)
  {
    long long v78 = (const char *)(*(void *)v76 + 72);
    std::string::size_type v77 = **(void **)v76;
    char v170 = *((_DWORD *)v76 + 2) == 0;
    v72 |= 0x200u;
  }
  else
  {
    std::string::size_type v77 = 0;
    char v170 = 0;
    long long v78 = "";
  }
  if ((v65 - 5) >= 6u) {
    int v79 = 32 * (v65 == 11);
  }
  else {
    int v79 = dword_1CFAC7A40[(char)(v65 - 5)];
  }
  if (a8)
  {
LABEL_143:
    uint64_t v80 = a6;
    int v81 = *a6;
    *uint64_t v80 = v81 + 1;
    goto LABEL_144;
  }
  if ((*((unsigned char *)a1 + 23) & 0x20) != 0)
  {
    uint64_t v88 = *(void *)**a1;
    v198.__r_.__value_.__r.__words[0] = (std::string::size_type)a1;
    int v89 = *(_DWORD *)(v88 + 2496);
    if (!v89)
    {
      unint64_t v124 = 0;
      goto LABEL_229;
    }
    uint64_t v90 = *(void *)(v88 + 2480);
    int v91 = v89 - 1;
    unsigned int v92 = v91 & ((a1 >> 4) ^ (a1 >> 9));
    int v93 = (uint64_t ***)(v90 + 40 * v92);
    char v94 = *v93;
    if (*v93 != a1)
    {
      int v95 = 0;
      int v96 = 1;
      while (v94 != (uint64_t **)-4096)
      {
        if (v95) {
          BOOL v97 = 0;
        }
        else {
          BOOL v97 = v94 == (uint64_t **)-8192;
        }
        if (v97) {
          int v95 = v93;
        }
        unsigned int v98 = v92 + v96++;
        unsigned int v92 = v98 & v91;
        int v93 = (uint64_t ***)(v90 + 40 * v92);
        char v94 = *v93;
        if (*v93 == a1) {
          goto LABEL_157;
        }
      }
      if (v95) {
        unint64_t v124 = v95;
      }
      else {
        unint64_t v124 = v93;
      }
LABEL_229:
      int v93 = (uint64_t ***)sub_1CC609054(v88 + 2480, (uint64_t)&v198, (uint64_t *)&v198, v124);
      std::string::size_type v125 = v198.__r_.__value_.__r.__words[0];
      v93[3] = 0;
      v93[4] = 0;
      *int v93 = (uint64_t **)v125;
      v93[1] = (uint64_t **)(v93 + 3);
      v93[2] = (uint64_t **)0x100000000;
    }
LABEL_157:
    uint64_t v99 = *((unsigned int *)v93 + 4);
    if (v99)
    {
      uint64_t v100 = v93[1] + 1;
      uint64_t v101 = 16 * v99;
      while (*((_DWORD *)v100 - 2) != 22)
      {
        v100 += 2;
        v101 -= 16;
        if (!v101) {
          goto LABEL_182;
        }
      }
      if (*v100)
      {
        v72 |= 0x80u;
        goto LABEL_143;
      }
    }
  }
LABEL_182:
  if (a7)
  {
    if (*((_DWORD *)a3 + 121) == 14)
    {
      v72 |= 0x100000u;
    }
    else
    {
      uint64_t v107 = *((void *)a4 + 19);
      if (*(unsigned char *)(v107 + 464)
        || (int v108 = *(_DWORD *)(v107 + 456), v108 >= 2) && (v108 != 2 || *(int *)(v107 + 460) >= 36))
      {
        v72 |= 0x200000u;
      }
    }
    goto LABEL_143;
  }
  uint64_t v105 = *((void *)a4 + 19);
  if (!*(unsigned char *)(v105 + 464))
  {
    int v106 = *(_DWORD *)(v105 + 456);
    if (v106 < 2 || v106 == 2 && *(int *)(v105 + 460) <= 34)
    {
      int v79 = 0;
      v72 &= ~0x10u;
      goto LABEL_213;
    }
  }
  isELFGenericMergeableSectiouint64_t n = llvm::MCContext::isELFGenericMergeableSection((uint64_t)a4, v12, v13);
  if ((v72 & 0x10) == 0 && !isELFGenericMergeableSection)
  {
LABEL_213:
    int v81 = -1;
    goto LABEL_144;
  }
  ELFUniqueIDForEntstd::string::size_type size = llvm::MCContext::getELFUniqueIDForEntsize((uint64_t)a4, v12, v13, v72, v79);
  if ((ELFUniqueIDForEntsize & 0xFF00000000) != 0)
  {
    int v81 = ELFUniqueIDForEntsize;
    goto LABEL_144;
  }
  sub_1CC4AC950((uint64_t)&v198, (uint64_t)a1, v65, a5, v79, 0);
  if ((v72 & 0x10) == 0)
  {
    unint64_t v122 = (uint64_t *)v198.__r_.__value_.__r.__words[0];
LABEL_223:
    unint64_t v123 = a6;
    int v81 = *a6;
    *unint64_t v123 = v81 + 1;
    goto LABEL_224;
  }
  BOOL isELFImplicitMergeableSectionNamePrefix = llvm::MCContext::isELFImplicitMergeableSectionNamePrefix((uint64_t)a4, v12, v13);
  unint64_t v122 = (uint64_t *)v198.__r_.__value_.__r.__words[0];
  if (!isELFImplicitMergeableSectionNamePrefix || v13 < v198.__r_.__value_.__l.__size_) {
    goto LABEL_223;
  }
  if (v198.__r_.__value_.__l.__size_)
  {
    unint64_t v140 = v12;
    std::string::size_type v141 = v198.__r_.__value_.__r.__words[0];
    if (!memcmp(v140, v198.__r_.__value_.__l.__data_, v198.__r_.__value_.__l.__size_))
    {
      int v81 = -1;
      unint64_t v122 = (uint64_t *)v141;
      goto LABEL_224;
    }
    unint64_t v122 = (uint64_t *)v141;
    goto LABEL_223;
  }
  int v81 = -1;
LABEL_224:
  if (v122 != &v199) {
    free(v122);
  }
LABEL_144:
  unsigned __int8 v82 = (const llvm::MCSymbolELF *)sub_1CC4AC680((uint64_t)a1, a3);
  __int16 v200 = 261;
  v198.__r_.__value_.__r.__words[0] = v172;
  v198.__r_.__value_.__l.__size_ = v13;
  int v83 = sub_1CC4AC814(v172, v13, v65);
  __int16 v197 = 261;
  v196.__r_.__value_.__r.__words[0] = (std::string::size_type)v78;
  v196.__r_.__value_.__l.__size_ = v77;
  ELFSectiouint64_t n = llvm::MCContext::getELFSection(a4, (const llvm::Twine *)&v198, v83, v72, v79, (const llvm::Twine *)&v196, v170, v81, v82);
  uint64_t v85 = ELFSection;
  uint64_t v86 = *((void *)a4 + 19);
  if (!*(unsigned char *)(v86 + 464))
  {
    int v102 = *(_DWORD *)(v86 + 456);
    if ((v102 < 2 || v102 == 2 && *(int *)(v86 + 460) <= 34) && (*(unsigned char *)(ELFSection + 228) & 0x10) != 0)
    {
      int v103 = (v65 - 5) >= 6u ? 32 * (v65 == 11) : dword_1CFAC7A40[(char)(v65 - 5)];
      if (*(_DWORD *)(ELFSection + 236) != v103)
      {
        uint64_t v110 = **a1;
        if ((*((unsigned char *)a1 + 23) & 0x10) != 0)
        {
          uint64_t v111 = *(void *)(*(void *)v110 + 152);
          uint64_t v112 = *(unsigned int *)(*(void *)v110 + 168);
          uint64_t v113 = v172;
          if (!v112) {
            goto LABEL_242;
          }
          LODWORD(v114) = (v112 - 1) & ((a1 >> 4) ^ (a1 >> 9));
          uint64_t v115 = (uint64_t ***)(v111 + 16 * v114);
          unint64_t v116 = *v115;
          if (*v115 != a1)
          {
            int v117 = 1;
            while (v116 != (uint64_t **)-4096)
            {
              int v118 = v114 + v117++;
              uint64_t v114 = v118 & (v112 - 1);
              unint64_t v116 = *(uint64_t ***)(v111 + 16 * v114);
              if (v116 == a1)
              {
                uint64_t v115 = (uint64_t ***)(v111 + 16 * v114);
                goto LABEL_243;
              }
            }
LABEL_242:
            uint64_t v115 = (uint64_t ***)(v111 + 16 * v112);
          }
LABEL_243:
          unint64_t v128 = v115[1];
          uint64_t v131 = *v128;
          unint64_t v129 = (char *)(v128 + 2);
          unint64_t v130 = v131;
        }
        else
        {
          unint64_t v130 = 0;
          unint64_t v129 = &byte_1CFBCE98E;
          uint64_t v113 = v172;
        }
        __int16 v177 = 1283;
        v176[0] = "Symbol '";
        v176[2] = v129;
        v176[3] = v130;
        v178[0] = v176;
        v178[2] = "' from module '";
        __int16 v179 = 770;
        uint64_t v132 = a1[5];
        if (v132)
        {
          if (*((char *)v132 + 215) < 0)
          {
            sub_1CB8BDF7C((uint64_t)__p, (const void *)v132[24], v132[25]);
          }
          else
          {
            *(_OWORD *)std::string __p = *((_OWORD *)v132 + 12);
            uint64_t v175 = v132[26];
          }
        }
        else
        {
          HIBYTE(v175) = 7;
          strcpy((char *)__p, "unknown");
        }
        v180[0] = v178;
        v180[2] = __p;
        __int16 v181 = 1026;
        v182[0] = v180;
        v182[2] = "' required a section with entry-size=";
        __int16 v183 = 770;
        if ((v65 - 5) >= 6u) {
          uint64_t v133 = 32 * (v65 == 11);
        }
        else {
          uint64_t v133 = qword_1CFAC7A10[(char)(v65 - 5)];
        }
        v184[0] = v182;
        v184[2] = v133;
        __int16 v185 = 2050;
        v186[0] = v184;
        v186[2] = " but was placed in section '";
        __int16 v187 = 770;
        v188[0] = v186;
        v188[2] = v113;
        v188[3] = v13;
        __int16 v189 = 1282;
        v190[0] = (uint64_t)v188;
        v190[2] = (uint64_t)"' with entry-size=";
        __int16 v191 = 770;
        v196.__r_.__value_.__r.__words[2] = *(unsigned int *)(v85 + 236);
        __int16 v197 = 2050;
        v198.__r_.__value_.__r.__words[0] = (std::string::size_type)&v196;
        v198.__r_.__value_.__r.__words[2] = (std::string::size_type)": Explicit assignment by pragma or attribute of an i"
                                                                    "ncompatible symbol to this section?";
        __int16 v200 = 770;
        int v193 = 4;
        char v194 = 0;
        uint64_t v192 = &unk_1F2614AA8;
        long long v195 = &v198;
        v196.__r_.__value_.__r.__words[0] = (std::string::size_type)v190;
        llvm::LLVMContext::diagnose(v110, (const llvm::DiagnosticInfo *)&v192);
        if (SHIBYTE(v175) < 0) {
          operator delete(__p[0]);
        }
      }
    }
  }
  return v85;
}